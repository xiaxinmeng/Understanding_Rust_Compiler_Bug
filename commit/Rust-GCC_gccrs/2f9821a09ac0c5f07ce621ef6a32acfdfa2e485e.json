{"sha": "2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY5ODIxYTA5YWMwYzVmMDdjZTYyMWVmNmEzMmFjZmRmYTJlNDg1ZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2020-05-25T15:30:56Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-07-10T09:16:17Z"}, "message": "[Ada] Make System.Generic_Bignums more flexible\n\ngcc/ada/\n\n\t* Makefile.rtl (GNATRTL_NONTASKING_OBJS): Add s-shabig.o.\n\t* libgnat/s-shabig.ads: New file to share definitions.\n\t* libgnat/s-genbig.ads, libgnat/s-genbig.adb: Reorganized to\n\tmake it more generic and flexible in terms of memory allocation\n\tand data structure returned.\n\t(To_String): Moved to System.Generic_Bignums to allow sharing\n\tthis code.\n\t(Big_And, Big_Or, Big_Shift_Left, Big_Shift_Right): New.\n\t* libgnat/s-bignum.adb, libgnat/s-bignum.ads: Adapt to new\n\tSystem.Generic_Bignums spec.\n\t* libgnat/a-nbnbin.adb: Likewise.\n\t(To_String): Moved to System.Generic_Bignums to allow sharing\n\tthis code.\n\t* libgnat/a-nbnbre.adb (Normalize): Fix handling of Num = 0\n\tleading to an exception.", "tree": {"sha": "02567e042b72d4a8c8e076c15bec3d80a87c9022", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02567e042b72d4a8c8e076c15bec3d80a87c9022"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e0cd875b5c5911200543044f855843afb93bf67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e0cd875b5c5911200543044f855843afb93bf67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e0cd875b5c5911200543044f855843afb93bf67"}], "stats": {"total": 1019, "additions": 625, "deletions": 394}, "files": [{"sha": "73109a293e34464c6d6f108063c1b8f8e91eae63", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e", "patch": "@@ -696,6 +696,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-scaval$(objext) \\\n   s-secsta$(objext) \\\n   s-sequio$(objext) \\\n+  s-shabig$(objext) \\\n   s-shasto$(objext) \\\n   s-soflin$(objext) \\\n   s-soliin$(objext) \\"}, {"sha": "d3c5f6a37ff9418eb0288ac7b2c51c18c778ffd1", "filename": "gcc/ada/libgnat/a-nbnbin.adb", "status": "modified", "additions": 33, "deletions": 76, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e/gcc%2Fada%2Flibgnat%2Fa-nbnbin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e/gcc%2Fada%2Flibgnat%2Fa-nbnbin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-nbnbin.adb?ref=2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e", "patch": "@@ -37,15 +37,43 @@ with Ada.Strings.Text_Output.Utils;\n with Interfaces; use Interfaces;\n \n with System.Generic_Bignums;\n+with System.Shared_Bignums; use System.Shared_Bignums;\n \n package body Ada.Numerics.Big_Numbers.Big_Integers is\n \n-   package Bignums is new\n-     System.Generic_Bignums (Use_Secondary_Stack => False);\n-   use Bignums, System;\n+   function Allocate_Bignum (D : Digit_Vector; Neg : Boolean) return Bignum;\n+   --  Allocate Bignum value with the given contents\n+\n+   procedure Free_Bignum (X : in out Bignum);\n+   --  Free memory associated with X\n+\n+   function To_Bignum (X : aliased in out Bignum) return Bignum is (X);\n \n    procedure Free is new Ada.Unchecked_Deallocation (Bignum_Data, Bignum);\n \n+   ---------------------\n+   -- Allocate_Bignum --\n+   ---------------------\n+\n+   function Allocate_Bignum (D : Digit_Vector; Neg : Boolean) return Bignum is\n+   begin\n+      return new Bignum_Data'(D'Length, Neg, D);\n+   end Allocate_Bignum;\n+\n+   -----------------\n+   -- Free_Bignum --\n+   -----------------\n+\n+   procedure Free_Bignum (X : in out Bignum) is\n+   begin\n+      Free (X);\n+   end Free_Bignum;\n+\n+   package Bignums is new System.Generic_Bignums\n+     (Bignum, Allocate_Bignum, Free_Bignum, To_Bignum);\n+\n+   use Bignums, System;\n+\n    function Get_Bignum (Arg : Big_Integer) return Bignum is\n      (if Arg.Value.C = System.Null_Address\n       then raise Constraint_Error with \"invalid big integer\"\n@@ -198,82 +226,11 @@ package body Ada.Numerics.Big_Numbers.Big_Integers is\n    -- To_String --\n    ---------------\n \n-   Hex_Chars : constant array (0 .. 15) of Character := \"0123456789ABCDEF\";\n-\n    function To_String\n      (Arg : Valid_Big_Integer; Width : Field := 0; Base : Number_Base := 10)\n-      return String\n-   is\n-      Big_Base : constant Big_Integer := To_Big_Integer (Integer (Base));\n-\n-      function Add_Base (S : String) return String;\n-      --  Add base information if Base /= 10\n-\n-      function Leading_Padding\n-        (Str        : String;\n-         Min_Length : Field;\n-         Char       : Character := ' ') return String;\n-      --  Return padding of Char concatenated with Str so that the resulting\n-      --  string is at least Min_Length long.\n-\n-      function Image (Arg : Big_Integer) return String;\n-      --  Return image of Arg, assuming Arg is positive.\n-\n-      function Image (N : Natural) return String;\n-      --  Return image of N, with no leading space.\n-\n-      --------------\n-      -- Add_Base --\n-      --------------\n-\n-      function Add_Base (S : String) return String is\n-      begin\n-         if Base = 10 then\n-            return S;\n-         else\n-            return Image (Base) & \"#\" & S & \"#\";\n-         end if;\n-      end Add_Base;\n-\n-      -----------\n-      -- Image --\n-      -----------\n-\n-      function Image (N : Natural) return String is\n-         S : constant String := Natural'Image (N);\n-      begin\n-         return S (2 .. S'Last);\n-      end Image;\n-\n-      function Image (Arg : Big_Integer) return String is\n-      begin\n-         if Arg < Big_Base then\n-            return (1 => Hex_Chars (To_Integer (Arg)));\n-         else\n-            return Image (Arg / Big_Base)\n-              & Hex_Chars (To_Integer (Arg rem Big_Base));\n-         end if;\n-      end Image;\n-\n-      ---------------------\n-      -- Leading_Padding --\n-      ---------------------\n-\n-      function Leading_Padding\n-        (Str        : String;\n-         Min_Length : Field;\n-         Char       : Character := ' ') return String is\n-      begin\n-         return (1 .. Integer'Max (Integer (Min_Length) - Str'Length, 0)\n-                        => Char) & Str;\n-      end Leading_Padding;\n-\n+      return String is\n    begin\n-      if Arg < To_Big_Integer (0) then\n-         return Leading_Padding (\"-\" & Add_Base (Image (-Arg)), Width);\n-      else\n-         return Leading_Padding (\" \" & Add_Base (Image (Arg)), Width);\n-      end if;\n+      return To_String (Get_Bignum (Arg), Natural (Width), Positive (Base));\n    end To_String;\n \n    -----------------"}, {"sha": "987cdb4edaefd8651c7a871859ca55c6b595998e", "filename": "gcc/ada/libgnat/a-nbnbre.adb", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e/gcc%2Fada%2Flibgnat%2Fa-nbnbre.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e/gcc%2Fada%2Flibgnat%2Fa-nbnbre.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-nbnbre.adb?ref=2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e", "patch": "@@ -531,19 +531,24 @@ package body Ada.Numerics.Big_Numbers.Big_Reals is\n    ---------------\n \n    procedure Normalize (Arg : in out Big_Real) is\n+      Zero : constant Big_Integer := To_Big_Integer (0);\n    begin\n-      if Arg.Den < To_Big_Integer (0) then\n+      if Arg.Den < Zero then\n          Arg.Num := -Arg.Num;\n          Arg.Den := -Arg.Den;\n       end if;\n \n-      declare\n-         GCD : constant Big_Integer :=\n-           Greatest_Common_Divisor (Arg.Num, Arg.Den);\n-      begin\n-         Arg.Num := Arg.Num / GCD;\n-         Arg.Den := Arg.Den / GCD;\n-      end;\n+      if Arg.Num = Zero then\n+         Arg.Den := To_Big_Integer (1);\n+      else\n+         declare\n+            GCD : constant Big_Integer :=\n+              Greatest_Common_Divisor (Arg.Num, Arg.Den);\n+         begin\n+            Arg.Num := Arg.Num / GCD;\n+            Arg.Den := Arg.Den / GCD;\n+         end;\n+      end if;\n    end Normalize;\n \n end Ada.Numerics.Big_Numbers.Big_Reals;"}, {"sha": "5e85c4aff5731b74778b3bba41dc53e6b9a45a02", "filename": "gcc/ada/libgnat/s-bignum.adb", "status": "modified", "additions": 97, "deletions": 44, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e/gcc%2Fada%2Flibgnat%2Fs-bignum.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e/gcc%2Fada%2Flibgnat%2Fs-bignum.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-bignum.adb?ref=2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e", "patch": "@@ -29,68 +29,121 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Generic_Bignums;\n with Ada.Unchecked_Conversion;\n+with System.Generic_Bignums;\n+with System.Secondary_Stack;  use System.Secondary_Stack;\n+with System.Shared_Bignums;   use System.Shared_Bignums;\n+with System.Storage_Elements; use System.Storage_Elements;\n \n package body System.Bignums is\n \n-   package Sec_Stack_Bignums is new\n-     System.Generic_Bignums (Use_Secondary_Stack => True);\n-   use Sec_Stack_Bignums;\n+   function Allocate_Bignum (D : Digit_Vector; Neg : Boolean) return Bignum;\n+   --  Allocate Bignum value with the given contents\n+\n+   procedure Free_Bignum (X : in out Bignum) is null;\n+   --  No op when using the secondary stack\n+\n+   function To_Bignum (X : aliased in out Bignum) return Bignum is (X);\n+\n+   ---------------------\n+   -- Allocate_Bignum --\n+   ---------------------\n+\n+   function Allocate_Bignum (D : Digit_Vector; Neg : Boolean) return Bignum is\n+      Addr : aliased Address;\n+   begin\n+      --  Note: The approach used here is designed to avoid strict aliasing\n+      --  warnings that appeared previously using unchecked conversion.\n+\n+      SS_Allocate (Addr, Storage_Offset (4 + 4 * D'Length));\n+\n+      declare\n+         B : Bignum;\n+         for B'Address use Addr'Address;\n+         pragma Import (Ada, B);\n+\n+         BD : Bignum_Data (D'Length);\n+         for BD'Address use Addr;\n+         pragma Import (Ada, BD);\n+\n+         --  Expose a writable view of discriminant BD.Len so that we can\n+         --  initialize it. We need to use the exact layout of the record\n+         --  to ensure that the Length field has 24 bits as expected.\n+\n+         type Bignum_Data_Header is record\n+            Len : Length;\n+            Neg : Boolean;\n+         end record;\n+\n+         for Bignum_Data_Header use record\n+            Len at 0 range 0 .. 23;\n+            Neg at 3 range 0 .. 7;\n+         end record;\n+\n+         BDH : Bignum_Data_Header;\n+         for BDH'Address use BD'Address;\n+         pragma Import (Ada, BDH);\n+\n+         pragma Assert (BDH.Len'Size = BD.Len'Size);\n \n-   function \"+\" is new Ada.Unchecked_Conversion\n-     (Bignum, Sec_Stack_Bignums.Bignum);\n+      begin\n+         BDH.Len := D'Length;\n+         BDH.Neg := Neg;\n+         B.D := D;\n+         return B;\n+      end;\n+   end Allocate_Bignum;\n \n-   function \"-\" is new Ada.Unchecked_Conversion\n-     (Sec_Stack_Bignums.Bignum, Bignum);\n+   package Sec_Stack_Bignums is new System.Generic_Bignums\n+     (Bignum, Allocate_Bignum, Free_Bignum, To_Bignum);\n \n-   function Big_Add (X, Y : Bignum) return Bignum is\n-     (-Sec_Stack_Bignums.Big_Add (+X, +Y));\n+   function Big_Add (X, Y : Bignum) return Bignum\n+     renames Sec_Stack_Bignums.Big_Add;\n \n-   function Big_Sub (X, Y : Bignum) return Bignum is\n-     (-Sec_Stack_Bignums.Big_Sub (+X, +Y));\n+   function Big_Sub (X, Y : Bignum) return Bignum\n+     renames Sec_Stack_Bignums.Big_Sub;\n \n-   function Big_Mul (X, Y : Bignum) return Bignum is\n-     (-Sec_Stack_Bignums.Big_Mul (+X, +Y));\n+   function Big_Mul (X, Y : Bignum) return Bignum\n+     renames Sec_Stack_Bignums.Big_Mul;\n \n-   function Big_Div (X, Y : Bignum) return Bignum is\n-     (-Sec_Stack_Bignums.Big_Div (+X, +Y));\n+   function Big_Div (X, Y : Bignum) return Bignum\n+     renames Sec_Stack_Bignums.Big_Div;\n \n-   function Big_Exp (X, Y : Bignum) return Bignum is\n-     (-Sec_Stack_Bignums.Big_Exp (+X, +Y));\n+   function Big_Exp (X, Y : Bignum) return Bignum\n+     renames Sec_Stack_Bignums.Big_Exp;\n \n-   function Big_Mod (X, Y : Bignum) return Bignum is\n-     (-Sec_Stack_Bignums.Big_Mod (+X, +Y));\n+   function Big_Mod (X, Y : Bignum) return Bignum\n+     renames Sec_Stack_Bignums.Big_Mod;\n \n-   function Big_Rem (X, Y : Bignum) return Bignum is\n-     (-Sec_Stack_Bignums.Big_Rem (+X, +Y));\n+   function Big_Rem (X, Y : Bignum) return Bignum\n+     renames Sec_Stack_Bignums.Big_Rem;\n \n-   function Big_Neg (X    : Bignum) return Bignum is\n-     (-Sec_Stack_Bignums.Big_Neg (+X));\n+   function Big_Neg (X : Bignum) return Bignum\n+     renames Sec_Stack_Bignums.Big_Neg;\n \n-   function Big_Abs (X    : Bignum) return Bignum is\n-     (-Sec_Stack_Bignums.Big_Abs (+X));\n+   function Big_Abs (X : Bignum) return Bignum\n+     renames Sec_Stack_Bignums.Big_Abs;\n \n-   function Big_EQ  (X, Y : Bignum) return Boolean is\n-     (Sec_Stack_Bignums.Big_EQ (+X, +Y));\n-   function Big_NE  (X, Y : Bignum) return Boolean is\n-     (Sec_Stack_Bignums.Big_NE (+X, +Y));\n-   function Big_GE  (X, Y : Bignum) return Boolean is\n-     (Sec_Stack_Bignums.Big_GE (+X, +Y));\n-   function Big_LE  (X, Y : Bignum) return Boolean is\n-     (Sec_Stack_Bignums.Big_LE (+X, +Y));\n-   function Big_GT  (X, Y : Bignum) return Boolean is\n-     (Sec_Stack_Bignums.Big_GT (+X, +Y));\n-   function Big_LT  (X, Y : Bignum) return Boolean is\n-     (Sec_Stack_Bignums.Big_LT (+X, +Y));\n+   function Big_EQ  (X, Y : Bignum) return Boolean\n+     renames Sec_Stack_Bignums.Big_EQ;\n+   function Big_NE  (X, Y : Bignum) return Boolean\n+     renames Sec_Stack_Bignums.Big_NE;\n+   function Big_GE  (X, Y : Bignum) return Boolean\n+     renames Sec_Stack_Bignums.Big_GE;\n+   function Big_LE  (X, Y : Bignum) return Boolean\n+     renames Sec_Stack_Bignums.Big_LE;\n+   function Big_GT  (X, Y : Bignum) return Boolean\n+     renames Sec_Stack_Bignums.Big_GT;\n+   function Big_LT  (X, Y : Bignum) return Boolean\n+     renames Sec_Stack_Bignums.Big_LT;\n \n-   function Bignum_In_LLI_Range (X : Bignum) return Boolean is\n-     (Sec_Stack_Bignums.Bignum_In_LLI_Range (+X));\n+   function Bignum_In_LLI_Range (X : Bignum) return Boolean\n+     renames Sec_Stack_Bignums.Bignum_In_LLI_Range;\n \n-   function To_Bignum (X : Long_Long_Integer) return Bignum is\n-     (-Sec_Stack_Bignums.To_Bignum (X));\n+   function To_Bignum (X : Long_Long_Integer) return Bignum\n+     renames Sec_Stack_Bignums.To_Bignum;\n \n-   function From_Bignum (X : Bignum) return Long_Long_Integer is\n-     (Sec_Stack_Bignums.From_Bignum (+X));\n+   function From_Bignum (X : Bignum) return Long_Long_Integer\n+     renames Sec_Stack_Bignums.From_Bignum;\n \n end System.Bignums;"}, {"sha": "728e5438c586065b9da63ddcfb4ecb063367096f", "filename": "gcc/ada/libgnat/s-bignum.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e/gcc%2Fada%2Flibgnat%2Fs-bignum.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e/gcc%2Fada%2Flibgnat%2Fs-bignum.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-bignum.ads?ref=2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e", "patch": "@@ -36,10 +36,12 @@\n --  Note that we cannot use a straight instantiation of System.Generic_Bignums\n --  because the rtsfind mechanism is not ready to handle instantiations.\n \n+with System.Shared_Bignums;\n+\n package System.Bignums is\n    pragma Preelaborate;\n \n-   type Bignum is private;\n+   subtype Bignum is System.Shared_Bignums.Bignum;\n \n    function Big_Add (X, Y : Bignum) return Bignum;  --  \"+\"\n    function Big_Sub (X, Y : Bignum) return Bignum;  --  \"-\"\n@@ -77,8 +79,6 @@ package System.Bignums is\n \n private\n \n-   type Bignum is new System.Address;\n-\n    pragma Inline (Big_Add);\n    pragma Inline (Big_Sub);\n    pragma Inline (Big_Mul);"}, {"sha": "2f6bdd5c79a868844238fc992f80abba109c9cb1", "filename": "gcc/ada/libgnat/s-genbig.adb", "status": "modified", "additions": 353, "deletions": 204, "changes": 557, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e/gcc%2Fada%2Flibgnat%2Fs-genbig.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e/gcc%2Fada%2Flibgnat%2Fs-genbig.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-genbig.adb?ref=2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e", "patch": "@@ -31,15 +31,13 @@\n \n --  This package provides arbitrary precision signed integer arithmetic.\n \n-with System;                  use System;\n-with System.Secondary_Stack;  use System.Secondary_Stack;\n-with System.Storage_Elements; use System.Storage_Elements;\n-\n package body System.Generic_Bignums is\n \n    use Interfaces;\n    --  So that operations on Unsigned_32/Unsigned_64 are available\n \n+   use Shared_Bignums;\n+\n    type DD is mod Base ** 2;\n    --  Double length digit used for intermediate computations\n \n@@ -65,18 +63,13 @@ package body System.Generic_Bignums is\n    function Add\n      (X, Y  : Digit_Vector;\n       X_Neg : Boolean;\n-      Y_Neg : Boolean) return Bignum\n+      Y_Neg : Boolean) return Big_Integer\n    with\n      Pre => X'First = 1 and then Y'First = 1;\n    --  This procedure adds two signed numbers returning the Sum, it is used\n    --  for both addition and subtraction. The value computed is X + Y, with\n    --  X_Neg and Y_Neg giving the signs of the operands.\n \n-   function Allocate_Bignum (Len : Length) return Bignum with\n-     Post => Allocate_Bignum'Result.Len = Len;\n-   --  Allocate Bignum value of indicated length on secondary stack. On return\n-   --  the Neg and D fields are left uninitialized.\n-\n    type Compare_Result is (LT, EQ, GT);\n    --  Indicates result of comparison in following call\n \n@@ -90,27 +83,24 @@ package body System.Generic_Bignums is\n \n    procedure Div_Rem\n      (X, Y              : Bignum;\n-      Quotient          : out Bignum;\n-      Remainder         : out Bignum;\n+      Quotient          : out Big_Integer;\n+      Remainder         : out Big_Integer;\n       Discard_Quotient  : Boolean := False;\n       Discard_Remainder : Boolean := False);\n    --  Returns the Quotient and Remainder from dividing abs (X) by abs (Y). The\n    --  values of X and Y are not modified. If Discard_Quotient is True, then\n    --  Quotient is undefined on return, and if Discard_Remainder is True, then\n    --  Remainder is undefined on return. Service routine for Big_Div/Rem/Mod.\n \n-   procedure Free_Bignum (X : Bignum) is null;\n-   --  Called to free a Bignum value used in intermediate computations. In\n-   --  this implementation using the secondary stack, it does nothing at all,\n-   --  because we rely on Mark/Release, but it may be of use for some\n-   --  alternative implementation.\n-\n    function Normalize\n      (X   : Digit_Vector;\n-      Neg : Boolean := False) return Bignum;\n-   --  Given a digit vector and sign, allocate and construct a Bignum value.\n-   --  Note that X may have leading zeroes which must be removed, and if the\n-   --  result is zero, the sign is forced positive.\n+      Neg : Boolean := False) return Big_Integer;\n+   --  Given a digit vector and sign, allocate and construct a big integer\n+   --  value. Note that X may have leading zeroes which must be removed, and if\n+   --  the result is zero, the sign is forced positive.\n+\n+   function \"**\" (X : Bignum; Y : SD) return Big_Integer;\n+   --  Exponentiation routine where we know right operand is one word\n \n    ---------\n    -- Add --\n@@ -119,7 +109,7 @@ package body System.Generic_Bignums is\n    function Add\n      (X, Y  : Digit_Vector;\n       X_Neg : Boolean;\n-      Y_Neg : Boolean) return Bignum\n+      Y_Neg : Boolean) return Big_Integer\n    is\n    begin\n       --  If signs are the same, we are doing an addition, it is convenient to\n@@ -202,73 +192,11 @@ package body System.Generic_Bignums is\n       end if;\n    end Add;\n \n-   ---------------------\n-   -- Allocate_Bignum --\n-   ---------------------\n-\n-   function Allocate_Bignum (Len : Length) return Bignum is\n-      Addr : Address;\n-\n-   begin\n-      --  Allocation on the heap\n-\n-      if not Use_Secondary_Stack then\n-         declare\n-            B : Bignum;\n-         begin\n-            B := new Bignum_Data'(Len, False, (others => 0));\n-            return B;\n-         end;\n-\n-      --  Allocation on the secondary stack\n-\n-      else\n-         --  Note: The approach used here is designed to avoid strict aliasing\n-         --  warnings that appeared previously using unchecked conversion.\n-\n-         SS_Allocate (Addr, Storage_Offset (4 + 4 * Len));\n-\n-         declare\n-            B : Bignum;\n-            for B'Address use Addr'Address;\n-            pragma Import (Ada, B);\n-\n-            BD : Bignum_Data (Len);\n-            for BD'Address use Addr;\n-            pragma Import (Ada, BD);\n-\n-            --  Expose a writable view of discriminant BD.Len so that we can\n-            --  initialize it. We need to use the exact layout of the record\n-            --  to ensure that the Length field has 24 bits as expected.\n-\n-            type Bignum_Data_Header is record\n-               Len : Length;\n-               Neg : Boolean;\n-            end record;\n-\n-            for Bignum_Data_Header use record\n-               Len at 0 range 0 .. 23;\n-               Neg at 3 range 0 .. 7;\n-            end record;\n-\n-            BDH : Bignum_Data_Header;\n-            for BDH'Address use BD'Address;\n-            pragma Import (Ada, BDH);\n-\n-            pragma Assert (BDH.Len'Size = BD.Len'Size);\n-\n-         begin\n-            BDH.Len := Len;\n-            return B;\n-         end;\n-      end if;\n-   end Allocate_Bignum;\n-\n    -------------\n    -- Big_Abs --\n    -------------\n \n-   function Big_Abs (X : Bignum) return Bignum is\n+   function Big_Abs (X : Bignum) return Big_Integer is\n    begin\n       return Normalize (X.D);\n    end Big_Abs;\n@@ -277,7 +205,7 @@ package body System.Generic_Bignums is\n    -- Big_Add --\n    -------------\n \n-   function Big_Add  (X, Y : Bignum) return Bignum is\n+   function Big_Add  (X, Y : Bignum) return Big_Integer is\n    begin\n       return Add (X.D, Y.D, X.Neg, Y.Neg);\n    end Big_Add;\n@@ -305,85 +233,83 @@ package body System.Generic_Bignums is\n    --   13    -5   -2      -13   -5     2\n    --   14    -5   -2      -14   -5     2\n \n-   function Big_Div  (X, Y : Bignum) return Bignum is\n-      Q, R : Bignum;\n+   function Big_Div  (X, Y : Bignum) return Big_Integer is\n+      Q, R : aliased Big_Integer;\n    begin\n       Div_Rem (X, Y, Q, R, Discard_Remainder => True);\n-      Q.Neg := Q.Len > 0 and then (X.Neg xor Y.Neg);\n+      To_Bignum (Q).Neg := To_Bignum (Q).Len > 0 and then (X.Neg xor Y.Neg);\n       return Q;\n    end Big_Div;\n \n-   -------------\n-   -- Big_Exp --\n-   -------------\n-\n-   function Big_Exp  (X, Y : Bignum) return Bignum is\n-\n-      function \"**\" (X : Bignum; Y : SD) return Bignum;\n-      --  Internal routine where we know right operand is one word\n-\n-      ----------\n-      -- \"**\" --\n-      ----------\n+   ----------\n+   -- \"**\" --\n+   ----------\n \n-      function \"**\" (X : Bignum; Y : SD) return Bignum is\n-      begin\n-         case Y is\n+   function \"**\" (X : Bignum; Y : SD) return Big_Integer is\n+   begin\n+      case Y is\n \n-            --  X ** 0 is 1\n+         --  X ** 0 is 1\n \n-            when 0 =>\n-               return Normalize (One_Data);\n+         when 0 =>\n+            return Normalize (One_Data);\n \n-            --  X ** 1 is X\n+         --  X ** 1 is X\n \n-            when 1 =>\n-               return Normalize (X.D);\n+         when 1 =>\n+            return Normalize (X.D);\n \n-            --  X ** 2 is X * X\n+         --  X ** 2 is X * X\n \n-            when 2 =>\n-               return Big_Mul (X, X);\n+         when 2 =>\n+            return Big_Mul (X, X);\n \n-            --  For X greater than 2, use the recursion\n+         --  For X greater than 2, use the recursion\n \n-            --  X even, X ** Y = (X ** (Y/2)) ** 2;\n-            --  X odd,  X ** Y = (X ** (Y/2)) ** 2 * X;\n+         --  X even, X ** Y = (X ** (Y/2)) ** 2;\n+         --  X odd,  X ** Y = (X ** (Y/2)) ** 2 * X;\n \n-            when others =>\n-               declare\n-                  XY2  : constant Bignum := X ** (Y / 2);\n-                  XY2S : constant Bignum := Big_Mul (XY2, XY2);\n-                  Res  : Bignum;\n-\n-               begin\n-                  Free_Bignum (XY2);\n-\n-                  --  Raise storage error if intermediate value is getting too\n-                  --  large, which we arbitrarily define as 200 words for now.\n-\n-                  if XY2S.Len > 200 then\n-                     Free_Bignum (XY2S);\n-                     raise Storage_Error with\n-                       \"exponentiation result is too large\";\n-                  end if;\n+         when others =>\n+            declare\n+               XY2  : aliased Big_Integer := X ** (Y / 2);\n+               XY2S : aliased Big_Integer :=\n+                 Big_Mul (To_Bignum (XY2), To_Bignum (XY2));\n+               Res  : Big_Integer;\n \n-                  --  Otherwise take care of even/odd cases\n+            begin\n+               Free_Big_Integer (XY2);\n+\n+               --  Raise storage error if intermediate value is getting too\n+               --  large, which we arbitrarily define as 200 words for now.\n+               --  ??? Consider putting a limit instead in a wrapper of\n+               --  Allocate_Big_Integer and update all calls to\n+               --  Allocate_Big_Integer to call this wrapper, to catch all such\n+               --  cases.\n+\n+               if To_Bignum (XY2S).Len > 200 then\n+                  Free_Big_Integer (XY2S);\n+                  raise Storage_Error with\n+                    \"exponentiation result is too large\";\n+               end if;\n \n-                  if (Y and 1) = 0 then\n-                     return XY2S;\n+               --  Otherwise take care of even/odd cases\n \n-                  else\n-                     Res := Big_Mul (XY2S, X);\n-                     Free_Bignum (XY2S);\n-                     return Res;\n-                  end if;\n-               end;\n-         end case;\n-      end \"**\";\n+               if (Y and 1) = 0 then\n+                  return XY2S;\n+               else\n+                  Res := Big_Mul (To_Bignum (XY2S), X);\n+                  Free_Big_Integer (XY2S);\n+                  return Res;\n+               end if;\n+            end;\n+      end case;\n+   end \"**\";\n \n-   --  Start of processing for Big_Exp\n+   -------------\n+   -- Big_Exp --\n+   -------------\n \n+   function Big_Exp  (X, Y : Bignum) return Big_Integer is\n    begin\n       --  Error if right operand negative\n \n@@ -431,6 +357,127 @@ package body System.Generic_Bignums is\n       end if;\n    end Big_Exp;\n \n+   -------------\n+   -- Big_And --\n+   -------------\n+\n+   function Big_And (X, Y : Bignum) return Big_Integer is\n+   begin\n+      if X.Len > Y.Len then\n+         return Big_And (X => Y, Y => X);\n+      end if;\n+\n+      --  X is the smallest integer\n+\n+      declare\n+         Result : Digit_Vector (1 .. X.Len);\n+         Diff   : constant Length := Y.Len - X.Len;\n+      begin\n+         for J in 1 .. X.Len loop\n+            Result (J) := X.D (J) and Y.D (J + Diff);\n+         end loop;\n+\n+         return Normalize (Result, X.Neg and Y.Neg);\n+      end;\n+   end Big_And;\n+\n+   ------------\n+   -- Big_Or --\n+   ------------\n+\n+   function Big_Or  (X, Y : Bignum) return Big_Integer is\n+   begin\n+      if X.Len < Y.Len then\n+         return Big_Or (X => Y, Y => X);\n+      end if;\n+\n+      --  X is the largest integer\n+\n+      declare\n+         Result : Digit_Vector (1 .. X.Len);\n+         Index  : Length;\n+         Diff   : constant Length := X.Len - Y.Len;\n+\n+      begin\n+         Index := 1;\n+\n+         while Index <= Diff loop\n+            Result (Index) := X.D (Index);\n+            Index := Index + 1;\n+         end loop;\n+\n+         for J in 1 .. Y.Len loop\n+            Result (Index) := X.D (Index) or Y.D (J);\n+            Index := Index + 1;\n+         end loop;\n+\n+         return Normalize (Result, X.Neg or Y.Neg);\n+      end;\n+   end Big_Or;\n+\n+   --------------------\n+   -- Big_Shift_Left --\n+   --------------------\n+\n+   function Big_Shift_Left (X : Bignum; Amount : Natural) return Big_Integer is\n+   begin\n+      if X.Neg then\n+         raise Constraint_Error;\n+      elsif Amount = 0 then\n+         return Allocate_Big_Integer (X.D, False);\n+      end if;\n+\n+      declare\n+         Shift  : constant Natural := Amount rem SD'Size;\n+         Result : Digit_Vector (0 .. X.Len + Amount / SD'Size);\n+         Carry  : SD := 0;\n+\n+      begin\n+         for J in X.Len + 1 .. Result'Last loop\n+            Result (J) := 0;\n+         end loop;\n+\n+         for J in reverse 1 .. X.Len loop\n+            Result (J) := Shift_Left (X.D (J), Shift) or Carry;\n+            Carry := Shift_Right (X.D (J), SD'Size - Shift);\n+         end loop;\n+\n+         Result (0) := Carry;\n+         return Normalize (Result, False);\n+      end;\n+   end Big_Shift_Left;\n+\n+   ---------------------\n+   -- Big_Shift_Right --\n+   ---------------------\n+\n+   function Big_Shift_Right\n+     (X : Bignum; Amount : Natural) return Big_Integer is\n+   begin\n+      if X.Neg then\n+         raise Constraint_Error;\n+      elsif Amount = 0 then\n+         return Allocate_Big_Integer (X.D, False);\n+      end if;\n+\n+      declare\n+         Shift  : constant Natural := Amount rem SD'Size;\n+         Result : Digit_Vector (1 .. X.Len - Amount / SD'Size);\n+         Carry  : SD := 0;\n+\n+      begin\n+         for J in 1 .. Result'Last - 1 loop\n+            Result (J) := Shift_Right (X.D (J), Shift) or Carry;\n+            Carry := Shift_Left (X.D (J), SD'Size - Shift);\n+         end loop;\n+\n+         Result (Result'Last) :=\n+           Shift_Right (X.D (Result'Last), Shift) or Carry;\n+\n+         return Normalize (Result, False);\n+      end;\n+   end Big_Shift_Right;\n+\n    ------------\n    -- Big_EQ --\n    ------------\n@@ -499,8 +546,8 @@ package body System.Generic_Bignums is\n    --   13    -5      -2        3       -13   -5      -3       -3\n    --   14    -5      -1        4       -14   -5      -4       -4\n \n-   function Big_Mod (X, Y : Bignum) return Bignum is\n-      Q, R : Bignum;\n+   function Big_Mod (X, Y : Bignum) return Big_Integer is\n+      Q, R : aliased Big_Integer;\n \n    begin\n       --  If signs are same, result is same as Rem\n@@ -517,17 +564,17 @@ package body System.Generic_Bignums is\n \n          --  Zero result is unchanged\n \n-         if R.Len = 0 then\n+         if To_Bignum (R).Len = 0 then\n             return R;\n \n          --  Otherwise adjust result\n \n          else\n             declare\n-               T1 : constant Bignum := Big_Sub (Y, R);\n+               T1 : aliased Big_Integer := Big_Sub (Y, To_Bignum (R));\n             begin\n-               T1.Neg := Y.Neg;\n-               Free_Bignum (R);\n+               To_Bignum (T1).Neg := Y.Neg;\n+               Free_Big_Integer (R);\n                return T1;\n             end;\n          end if;\n@@ -538,7 +585,7 @@ package body System.Generic_Bignums is\n    -- Big_Mul --\n    -------------\n \n-   function Big_Mul (X, Y : Bignum) return Bignum is\n+   function Big_Mul (X, Y : Bignum) return Big_Integer is\n       Result : Digit_Vector (1 .. X.Len + Y.Len) := (others => 0);\n       --  Accumulate result (max length of result is sum of operand lengths)\n \n@@ -589,7 +636,7 @@ package body System.Generic_Bignums is\n    -- Big_Neg --\n    -------------\n \n-   function Big_Neg (X : Bignum) return Bignum is\n+   function Big_Neg (X : Bignum) return Big_Integer is\n    begin\n       return Normalize (X.D, not X.Neg);\n    end Big_Neg;\n@@ -617,19 +664,19 @@ package body System.Generic_Bignums is\n    --   13    -5     3      -13   -5     -3\n    --   14    -5     4      -14   -5     -4\n \n-   function Big_Rem (X, Y : Bignum) return Bignum is\n-      Q, R : Bignum;\n+   function Big_Rem (X, Y : Bignum) return Big_Integer is\n+      Q, R : aliased Big_Integer;\n    begin\n       Div_Rem (X, Y, Q, R, Discard_Quotient => True);\n-      R.Neg := R.Len > 0 and then X.Neg;\n+      To_Bignum (R).Neg := To_Bignum (R).Len > 0 and then X.Neg;\n       return R;\n    end Big_Rem;\n \n    -------------\n    -- Big_Sub --\n    -------------\n \n-   function Big_Sub (X, Y : Bignum) return Bignum is\n+   function Big_Sub (X, Y : Bignum) return Big_Integer is\n    begin\n       --  If right operand zero, return left operand (avoiding sharing)\n \n@@ -681,11 +728,10 @@ package body System.Generic_Bignums is\n \n    procedure Div_Rem\n      (X, Y              : Bignum;\n-      Quotient          : out Bignum;\n-      Remainder         : out Bignum;\n+      Quotient          : out Big_Integer;\n+      Remainder         : out Big_Integer;\n       Discard_Quotient  : Boolean := False;\n-      Discard_Remainder : Boolean := False)\n-   is\n+      Discard_Remainder : Boolean := False) is\n    begin\n       --  Error if division by zero\n \n@@ -698,8 +744,14 @@ package body System.Generic_Bignums is\n       --  If X < Y then quotient is zero and remainder is X\n \n       if Compare (X.D, Y.D, False, False) = LT then\n-         Remainder := Normalize (X.D);\n-         Quotient  := Normalize (Zero_Data);\n+         if not Discard_Quotient then\n+            Quotient := Normalize (Zero_Data);\n+         end if;\n+\n+         if not Discard_Remainder then\n+            Remainder := Normalize (X.D);\n+         end if;\n+\n          return;\n \n       --  If both X and Y are less than 2**63-1, we can use Long_Long_Integer\n@@ -714,8 +766,14 @@ package body System.Generic_Bignums is\n             A : constant LLI := abs (From_Bignum (X));\n             B : constant LLI := abs (From_Bignum (Y));\n          begin\n-            Quotient  := To_Bignum (A / B);\n-            Remainder := To_Bignum (A rem B);\n+            if not Discard_Quotient then\n+               Quotient := To_Bignum (A / B);\n+            end if;\n+\n+            if not Discard_Remainder then\n+               Remainder := To_Bignum (A rem B);\n+            end if;\n+\n             return;\n          end;\n \n@@ -738,9 +796,15 @@ package body System.Generic_Bignums is\n                ND := ND rem Div;\n             end loop;\n \n-            Quotient  := Normalize (Result);\n-            Remdr (1) := SD (ND);\n-            Remainder := Normalize (Remdr);\n+            if not Discard_Quotient then\n+               Quotient  := Normalize (Result);\n+            end if;\n+\n+            if not Discard_Remainder then\n+               Remdr (1) := SD (ND);\n+               Remainder := Normalize (Remdr);\n+            end if;\n+\n             return;\n          end;\n       end if;\n@@ -969,9 +1033,9 @@ package body System.Generic_Bignums is\n          if not Discard_Remainder then\n             declare\n                Remdr : DD;\n-\n             begin\n                Remdr := 0;\n+\n                for K in 1 .. n loop\n                   Remdr := Base * Remdr + DD (u (m + K));\n                   r (K) := SD (Remdr / d);\n@@ -1046,9 +1110,8 @@ package body System.Generic_Bignums is\n \n    function Normalize\n      (X   : Digit_Vector;\n-      Neg : Boolean := False) return Bignum\n+      Neg : Boolean := False) return Big_Integer\n    is\n-      B : Bignum;\n       J : Length;\n \n    begin\n@@ -1057,73 +1120,159 @@ package body System.Generic_Bignums is\n          J := J + 1;\n       end loop;\n \n-      B := Allocate_Bignum (X'Last - J + 1);\n-      B.Neg := B.Len > 0 and then Neg;\n-      B.D := X (J .. X'Last);\n-      return B;\n+      return Allocate_Big_Integer (X (J .. X'Last), J <= X'Last and then Neg);\n    end Normalize;\n \n    ---------------\n    -- To_Bignum --\n    ---------------\n \n-   function To_Bignum (X : Long_Long_Integer) return Bignum is\n-      R : Bignum;\n-\n+   function To_Bignum (X : Long_Long_Integer) return Big_Integer is\n    begin\n       if X = 0 then\n-         R := Allocate_Bignum (0);\n+         return Allocate_Big_Integer ((1 .. 0 => <>), False);\n \n       --  One word result\n \n       elsif X in -(2 ** 32 - 1) .. +(2 ** 32 - 1) then\n-         R := Allocate_Bignum (1);\n-         R.D (1) := SD (abs (X));\n+         return Allocate_Big_Integer ((1 => SD (abs X)), X < 0);\n \n       --  Largest negative number annoyance\n \n       elsif X = Long_Long_Integer'First then\n-         R := Allocate_Bignum (2);\n-         R.D (1) := 2 ** 31;\n-         R.D (2) := 0;\n+         return Allocate_Big_Integer ((2 ** 31, 0), True);\n \n-      --  Normal two word case\n+      --  Other negative numbers\n \n+      elsif X < 0 then\n+         return Allocate_Big_Integer\n+                  ((SD ((-X) / Base), SD ((-X) mod Base)), True);\n+\n+      --  Positive numbers\n       else\n-         R := Allocate_Bignum (2);\n-         R.D (2) := SD (abs (X) mod Base);\n-         R.D (1) := SD (abs (X) / Base);\n+         return Allocate_Big_Integer ((SD (X / Base), SD (X mod Base)), False);\n       end if;\n-\n-      R.Neg := X < 0;\n-      return R;\n    end To_Bignum;\n \n-   function To_Bignum (X : Unsigned_64) return Bignum is\n-      R : Bignum;\n-\n+   function To_Bignum (X : Unsigned_64) return Big_Integer is\n    begin\n       if X = 0 then\n-         R := Allocate_Bignum (0);\n+         return Allocate_Big_Integer ((1 .. 0 => <>), False);\n \n       --  One word result\n \n       elsif X < 2 ** 32 then\n-         R := Allocate_Bignum (1);\n-         R.D (1) := SD (X);\n+         return Allocate_Big_Integer ((1 => SD (X)), False);\n \n       --  Two word result\n \n       else\n-         R := Allocate_Bignum (2);\n-         R.D (2) := SD (X mod Base);\n-         R.D (1) := SD (X / Base);\n+         return Allocate_Big_Integer ((SD (X / Base), SD (X mod Base)), False);\n       end if;\n-\n-      R.Neg := False;\n-      return R;\n    end To_Bignum;\n \n+   ---------------\n+   -- To_String --\n+   ---------------\n+\n+   Hex_Chars : constant array (0 .. 15) of Character := \"0123456789ABCDEF\";\n+\n+   function To_String\n+     (X : Bignum; Width : Natural := 0; Base : Positive := 10) return String\n+   is\n+      Big_Base : aliased Bignum_Data := (1, False, (1 => SD (Base)));\n+\n+      function Add_Base (S : String) return String;\n+      --  Add base information if Base /= 10\n+\n+      function Leading_Padding\n+        (Str        : String;\n+         Min_Length : Natural;\n+         Char       : Character := ' ') return String;\n+      --  Return padding of Char concatenated with Str so that the resulting\n+      --  string is at least Min_Length long.\n+\n+      function Image (Arg : Bignum) return String;\n+      --  Return image of Arg, assuming Arg is positive.\n+\n+      function Image (N : Natural) return String;\n+      --  Return image of N, with no leading space.\n+\n+      --------------\n+      -- Add_Base --\n+      --------------\n+\n+      function Add_Base (S : String) return String is\n+      begin\n+         if Base = 10 then\n+            return S;\n+         else\n+            return Image (Base) & \"#\" & S & \"#\";\n+         end if;\n+      end Add_Base;\n+\n+      -----------\n+      -- Image --\n+      -----------\n+\n+      function Image (N : Natural) return String is\n+         S : constant String := Natural'Image (N);\n+      begin\n+         return S (2 .. S'Last);\n+      end Image;\n+\n+      function Image (Arg : Bignum) return String is\n+      begin\n+         if Big_LT (Arg, Big_Base'Unchecked_Access) then\n+            return (1 => Hex_Chars (Natural (From_Bignum (Arg))));\n+         else\n+            declare\n+               Div    : aliased Big_Integer;\n+               Remain : aliased Big_Integer;\n+               R      : Natural;\n+\n+            begin\n+               Div_Rem (Arg, Big_Base'Unchecked_Access, Div, Remain);\n+               R := Natural (From_Bignum (To_Bignum (Remain)));\n+               Free_Big_Integer (Remain);\n+\n+               return S : constant String :=\n+                 Image (To_Bignum (Div)) & Hex_Chars (R)\n+               do\n+                  Free_Big_Integer (Div);\n+               end return;\n+            end;\n+         end if;\n+      end Image;\n+\n+      ---------------------\n+      -- Leading_Padding --\n+      ---------------------\n+\n+      function Leading_Padding\n+        (Str        : String;\n+         Min_Length : Natural;\n+         Char       : Character := ' ') return String is\n+      begin\n+         return (1 .. Integer'Max (Integer (Min_Length) - Str'Length, 0)\n+                        => Char) & Str;\n+      end Leading_Padding;\n+\n+      Zero : aliased Bignum_Data := (0, False, D => Zero_Data);\n+\n+   begin\n+      if Big_LT (X, Zero'Unchecked_Access) then\n+         declare\n+            X_Pos : aliased Bignum_Data := (X.Len, not X.Neg, X.D);\n+         begin\n+            return Leading_Padding\n+                     (\"-\" & Add_Base (Image (X_Pos'Unchecked_Access)), Width);\n+         end;\n+      else\n+         return Leading_Padding (\" \" & Add_Base (Image (X)), Width);\n+      end if;\n+   end To_String;\n+\n    -------------\n    -- Is_Zero --\n    -------------"}, {"sha": "003a8fdb1e93937a8057e0e7851bee53ab4171bb", "filename": "gcc/ada/libgnat/s-genbig.ads", "status": "modified", "additions": 45, "deletions": 59, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e/gcc%2Fada%2Flibgnat%2Fs-genbig.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e/gcc%2Fada%2Flibgnat%2Fs-genbig.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-genbig.ads?ref=2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e", "patch": "@@ -33,77 +33,57 @@\n --  and can be used either built into the compiler via System.Bignums or to\n --  implement a default version of Ada.Numerics.Big_Numbers.Big_Integers.\n \n---  If Use_Secondary_Stack is True then all Bignum values are allocated on the\n---  secondary stack. If False, the heap is used and the caller is responsible\n---  for memory management.\n-\n-with Ada.Unchecked_Conversion;\n with Interfaces;\n+with System.Shared_Bignums;\n \n generic\n-   Use_Secondary_Stack : Boolean;\n-package System.Generic_Bignums is\n-   pragma Preelaborate;\n-\n-   pragma Assert (Long_Long_Integer'Size = 64);\n-   --  This package assumes that Long_Long_Integer size is 64 bit (i.e. that it\n-   --  has a range of -2**63 to 2**63-1). The front end ensures that the mode\n-   --  ELIMINATED is not allowed for overflow checking if this is not the case.\n-\n-   subtype Length is Natural range 0 .. 2 ** 23 - 1;\n-   --  Represent number of words in Digit_Vector\n-\n-   Base : constant := 2 ** 32;\n-   --  Digit vectors use this base\n-\n-   subtype SD is Interfaces.Unsigned_32;\n-   --  Single length digit\n+   type Big_Integer is private;\n \n-   type Digit_Vector is array (Length range <>) of SD;\n-   --  Represent digits of a number (most significant digit first)\n+   with function Allocate_Big_Integer\n+          (D : Shared_Bignums.Digit_Vector; Neg : Boolean) return Big_Integer;\n+   --  Allocate Bignum value with the given contents\n \n-   type Bignum_Data (Len : Length) is record\n-      Neg : Boolean;\n-      --  Set if value is negative, never set for zero\n+   with procedure Free_Big_Integer (X : in out Big_Integer);\n+   --  Free the memory associated with X\n \n-      D : Digit_Vector (1 .. Len);\n-      --  Digits of number, most significant first, represented in base\n-      --  2**Base. No leading zeroes are stored, and the value of zero is\n-      --  represented using an empty vector for D.\n-   end record;\n+   with function To_Bignum\n+          (X : aliased in out Big_Integer) return Shared_Bignums.Bignum;\n+   --  Convert the given Big_Integer to a Bignum\n \n-   for Bignum_Data use record\n-      Len at 0 range 0 .. 23;\n-      Neg at 3 range 0 .. 7;\n-   end record;\n+package System.Generic_Bignums is\n+   pragma Preelaborate;\n \n-   type Bignum is access all Bignum_Data;\n-   --  This is the type that is used externally. Possibly this could be a\n-   --  private type, but we leave the structure exposed for now. For one\n-   --  thing it helps with debugging. Note that this package never shares\n-   --  an allocated Bignum value, so for example for X + 0, a copy of X is\n-   --  returned, not X itself.\n+   subtype Bignum is Shared_Bignums.Bignum;\n \n-   function To_Bignum is new Ada.Unchecked_Conversion (System.Address, Bignum);\n-   function To_Address is new\n-     Ada.Unchecked_Conversion (Bignum, System.Address);\n+   --  Note that this package never shares an allocated Big_Integer value, so\n+   --  so for example for X + 0, a copy of X is returned, not X itself.\n \n    --  Note: none of the subprograms in this package modify the Bignum_Data\n    --  records referenced by Bignum arguments of mode IN.\n \n-   function Big_Add (X, Y : Bignum) return Bignum;  --  \"+\"\n-   function Big_Sub (X, Y : Bignum) return Bignum;  --  \"-\"\n-   function Big_Mul (X, Y : Bignum) return Bignum;  --  \"*\"\n-   function Big_Div (X, Y : Bignum) return Bignum;  --  \"/\"\n-   function Big_Exp (X, Y : Bignum) return Bignum;  --  \"**\"\n-   function Big_Mod (X, Y : Bignum) return Bignum;  --  \"mod\"\n-   function Big_Rem (X, Y : Bignum) return Bignum;  --  \"rem\"\n-   function Big_Neg (X    : Bignum) return Bignum;  --  \"-\"\n-   function Big_Abs (X    : Bignum) return Bignum;  --  \"abs\"\n+   function Big_Add (X, Y : Bignum) return Big_Integer;  --  \"+\"\n+   function Big_Sub (X, Y : Bignum) return Big_Integer;  --  \"-\"\n+   function Big_Mul (X, Y : Bignum) return Big_Integer;  --  \"*\"\n+   function Big_Div (X, Y : Bignum) return Big_Integer;  --  \"/\"\n+   function Big_Exp (X, Y : Bignum) return Big_Integer;  --  \"**\"\n+   function Big_Mod (X, Y : Bignum) return Big_Integer;  --  \"mod\"\n+   function Big_Rem (X, Y : Bignum) return Big_Integer;  --  \"rem\"\n+   function Big_Neg (X    : Bignum) return Big_Integer;  --  \"-\"\n+   function Big_Abs (X    : Bignum) return Big_Integer;  --  \"abs\"\n    --  Perform indicated arithmetic operation on bignum values. No exception\n    --  raised except for Div/Mod/Rem by 0 which raises Constraint_Error with\n    --  an appropriate message.\n \n+   function Big_And (X, Y : Bignum) return Big_Integer;  --  \"and\"\n+   function Big_Or  (X, Y : Bignum) return Big_Integer;  --  \"or\"\n+   --  Perform indicated bitwise operation on big num values.\n+   --  The negative flags of X and Y are also combined.\n+\n+   function Big_Shift_Left  (X : Bignum; Amount : Natural) return Big_Integer;\n+   function Big_Shift_Right (X : Bignum; Amount : Natural) return Big_Integer;\n+   --  Perform indicated bitwise operation on big num values.\n+   --  Constraint_Error is raised if X is negative.\n+\n    function Big_EQ  (X, Y : Bignum) return Boolean;  -- \"=\"\n    function Big_NE  (X, Y : Bignum) return Boolean;  -- \"/=\"\n    function Big_GE  (X, Y : Bignum) return Boolean;  -- \">=\"\n@@ -117,18 +97,24 @@ package System.Generic_Bignums is\n    --  Returns True if the Bignum value is in the range of Long_Long_Integer,\n    --  so that a call to From_Bignum is guaranteed not to raise an exception.\n \n-   function To_Bignum (X : Long_Long_Integer) return Bignum;\n-   --  Convert Long_Long_Integer to Bignum. No exception can be raised for any\n-   --  input argument.\n+   function To_Bignum (X : Long_Long_Integer) return Big_Integer;\n+   --  Convert Long_Long_Integer to a big integer. No exception can be raised\n+   --  for any input argument.\n \n-   function To_Bignum (X : Interfaces.Unsigned_64) return Bignum;\n-   --  Convert Unsigned_64 to Bignum. No exception can be raised for any\n+   function To_Bignum (X : Interfaces.Unsigned_64) return Big_Integer;\n+   --  Convert Unsigned_64 to a big integer. No exception can be raised for any\n    --  input argument.\n \n    function From_Bignum (X : Bignum) return Long_Long_Integer;\n    --  Convert Bignum to Long_Long_Integer. Constraint_Error raised with\n    --  appropriate message if value is out of range of Long_Long_Integer.\n \n+   function To_String\n+     (X : Bignum; Width : Natural := 0; Base : Positive := 10)\n+      return String;\n+   --  Return the image of X, based on the given Width and Base, as defined\n+   --  in the RM for Ada.Text_IO. Base should really be in the range 2 .. 16.\n+\n    function Is_Zero (X : Bignum) return Boolean;\n    --  Return True if X = 0\n "}, {"sha": "c4f694408e249052ac11d39ae3b03f720f42df5d", "filename": "gcc/ada/libgnat/s-shabig.ads", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e/gcc%2Fada%2Flibgnat%2Fs-shabig.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e/gcc%2Fada%2Flibgnat%2Fs-shabig.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-shabig.ads?ref=2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e", "patch": "@@ -0,0 +1,80 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                S Y S T E M . S H A R E D _ B I G N U M S                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2012-2020, Free Software Foundation, Inc.       --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides declarations shared across all instantiations of\n+--  System.Generic_Bignums.\n+\n+with Ada.Unchecked_Conversion;\n+with Interfaces;\n+\n+package System.Shared_Bignums is\n+   pragma Preelaborate;\n+\n+   pragma Assert (Long_Long_Integer'Size = 64);\n+   --  This package assumes that Long_Long_Integer size is 64 bit (i.e. that it\n+   --  has a range of -2**63 to 2**63-1). The front end ensures that the mode\n+   --  ELIMINATED is not allowed for overflow checking if this is not the case.\n+\n+   subtype Length is Natural range 0 .. 2 ** 23 - 1;\n+   --  Represent number of words in Digit_Vector\n+\n+   Base : constant := 2 ** 32;\n+   --  Digit vectors use this base\n+\n+   subtype SD is Interfaces.Unsigned_32;\n+   --  Single length digit\n+\n+   type Digit_Vector is array (Length range <>) of SD;\n+   --  Represent digits of a number (most significant digit first)\n+\n+   type Bignum_Data (Len : Length) is record\n+      Neg : Boolean;\n+      --  Set if value is negative, never set for zero\n+\n+      D : Digit_Vector (1 .. Len);\n+      --  Digits of number, most significant first, represented in base\n+      --  2**Base. No leading zeroes are stored, and the value of zero is\n+      --  represented using an empty vector for D.\n+   end record;\n+\n+   for Bignum_Data use record\n+      Len at 0 range 0 .. 23;\n+      Neg at 3 range 0 .. 7;\n+   end record;\n+\n+   type Bignum is access all Bignum_Data;\n+\n+   function To_Bignum is new Ada.Unchecked_Conversion (System.Address, Bignum);\n+\n+   function To_Address is new\n+     Ada.Unchecked_Conversion (Bignum, System.Address);\n+\n+end System.Shared_Bignums;"}]}