{"sha": "e0db9cc648242cbbea38cc3c559663acb501aee8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBkYjljYzY0ODI0MmNiYmVhMzhjYzNjNTU5NjYzYWNiNTAxYWVlOA==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2010-04-12T20:20:54Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2010-04-12T20:20:54Z"}, "message": "i386.md (any_rotate): New code iterator.\n\n\t* config/i386/i386.md (any_rotate): New code iterator.\n\t(rotate_insn): New code attribute.\n\t(rotate): Ditto.\n\t(SWIM124): New mode iterator.\n\t(<rotate_insn>ti3): New expander.\n\t(<rotate_insn>di3): Macroize expander from {rotl,rotr}di3 using\n\tany_rotate code iterator.\n\t(<rotate_insn><mode>3) Macroize expander from {rotl,rotr}{qi,hi,si}3\n\tusing any_rotate code iterator and SWIM124 mode iterator.\n\t(ix86_rotlti3): New insn_and_split pattern.\n\t(ix86_rotrti3): Ditto.\n\t(ix86_rotl<dwi>3_doubleword): Macroize insn_and_split pattern from\n\tix86_rotl{di,ti}3 patterns.\n\t(ix86_rotr<dwi>3_doubleword): Ditto from ix86_rotr{di,ti}3 patterns.\n\t(*<rotate_insn><mode>3_1): Merge with *{rotl,rotr}{qi,hi,si}3_1_one_bit\n\tand *{rotl,rotr}di3_1_one_bit_rex64. Macroize insn from\n\t*{rotl,rotr}{qi,hi,si}3_1 and *{rotl,rotr}di3_1_rex64 using any_rotate\n\tcode iterator and SWI mode iterator.\n\t(*<rotate_insn>si3_1_zext): Merge with *{rotl,rotr}si3_1_one_bit_zext.\n\tMacroize insn from {rotl,rotr}si3_1_zext using any_rotate\n\tcode iterator.\n\t(*<rotate_insn>qi3_1_slp): Merge with *{rotl,rotr}qi3_1_one_bit_slp.\n\tMacroize insn from {rotl,rotr}qi3_1_slp using any_rotate code iterator.\n\t(bswap rotatert splitter): Add splitter.\n\t(bswap splitter): Macroize splitter using any_rotate code iterator.\n\tAdd insn predicate to split only for TARGET_USE_XCHGB or when\n\toptimizing function for size.\n\ntestsuite/ChangeLog:\n\n\t* gcc.target/i386/rotate-2.c: New test.\n\nFrom-SVN: r158243", "tree": {"sha": "9a4d5d39c4a0cf17232366e25ea5b59494809dfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a4d5d39c4a0cf17232366e25ea5b59494809dfa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0db9cc648242cbbea38cc3c559663acb501aee8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0db9cc648242cbbea38cc3c559663acb501aee8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0db9cc648242cbbea38cc3c559663acb501aee8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0db9cc648242cbbea38cc3c559663acb501aee8/comments", "author": null, "committer": null, "parents": [{"sha": "077c8adab1eabe459c25ca1419067a00dc2cbd6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/077c8adab1eabe459c25ca1419067a00dc2cbd6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/077c8adab1eabe459c25ca1419067a00dc2cbd6e"}], "stats": {"total": 638, "additions": 219, "deletions": 419}, "files": [{"sha": "7c2a25d7afd7aaff684bbe5073ecc80e1daece31", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 22, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0db9cc648242cbbea38cc3c559663acb501aee8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0db9cc648242cbbea38cc3c559663acb501aee8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e0db9cc648242cbbea38cc3c559663acb501aee8", "patch": "@@ -1,3 +1,33 @@\n+2010-04-12  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.md (any_rotate): New code iterator.\n+\t(rotate_insn): New code attribute.\n+\t(rotate): Ditto.\n+\t(SWIM124): New mode iterator.\n+\t(<rotate_insn>ti3): New expander.\n+\t(<rotate_insn>di3): Macroize expander from {rotl,rotr}di3 using\n+\tany_rotate code iterator.\n+\t(<rotate_insn><mode>3) Macroize expander from {rotl,rotr}{qi,hi,si}3\n+\tusing any_rotate code iterator and SWIM124 mode iterator.\n+\t(ix86_rotlti3): New insn_and_split pattern.\n+\t(ix86_rotrti3): Ditto.\n+\t(ix86_rotl<dwi>3_doubleword): Macroize insn_and_split pattern from\n+\tix86_rotl{di,ti}3 patterns.\n+\t(ix86_rotr<dwi>3_doubleword): Ditto from ix86_rotr{di,ti}3 patterns.\n+\t(*<rotate_insn><mode>3_1): Merge with *{rotl,rotr}{qi,hi,si}3_1_one_bit\n+\tand *{rotl,rotr}di3_1_one_bit_rex64. Macroize insn from\n+\t*{rotl,rotr}{qi,hi,si}3_1 and *{rotl,rotr}di3_1_rex64 using any_rotate\n+\tcode iterator and SWI mode iterator.\n+\t(*<rotate_insn>si3_1_zext): Merge with *{rotl,rotr}si3_1_one_bit_zext.\n+\tMacroize insn from {rotl,rotr}si3_1_zext using any_rotate\n+\tcode iterator.\n+\t(*<rotate_insn>qi3_1_slp): Merge with *{rotl,rotr}qi3_1_one_bit_slp.\n+\tMacroize insn from {rotl,rotr}qi3_1_slp using any_rotate code iterator.\n+\t(bswap rotatert splitter): Add splitter.\n+\t(bswap splitter): Macroize splitter using any_rotate code iterator.\n+\tAdd insn predicate to split only for TARGET_USE_XCHGB or when\n+\toptimizing function for size.\n+\n 2010-04-12  Steve Ellcey  <sje@cup.hp.com>\n \n \t* config/pa/pa.c (emit_move_sequence): Remove use of\n@@ -95,8 +125,7 @@\n \t* ipa.c (cgraph_postorder): Adjust postorder to guarantee\n \tsingle-iteration always-inline inlining.\n \t* ipa-inline.c (cgraph_mark_inline): Do not return anything.\n-\t(cgraph_decide_inlining): Do not handle always-inline\n-\tspecially.\n+\t(cgraph_decide_inlining): Do not handle always-inline specially.\n \t(try_inline): Remove always-inline cycle detection special case.\n \tDo not recurse on always-inlines.\n \t(cgraph_early_inlining): Do not iterate if not optimizing.\n@@ -151,25 +180,20 @@\n \t* config/i386/i386.md (any_shiftrt): New code iterator.\n \t(shiftrt_insn): New code attribute.\n \t(shiftrt): Ditto.\n-\t(<shiftrt_insn><mode>3): Macroize expander from ashr<mode>3 and\n-\tlshr<mode>3 using any_shiftrt code iterator.\n+\t(<shiftrt_insn><mode>3): Macroize expander from {ashr,lshr}<mode>3\n+\tusing any_shiftrt code iterator.\n \t(*<shiftrt_insn><mode>3_doubleword): Macroize insn_and_split from\n-\t*ashr<mode>3_doubleword and *lshr<mode>3_doubleword using\n-\tany_shiftrt code iterator.\n+\t*{ashr,lshr}<mode>3_doubleword using any_shiftrt code iterator.\n \t(*<shiftrt_insn><mode>3_doubleword peephole2): Macroize peephole2\n \tpattern from corresponding peephole2 patterns.\n-\t(*<shiftrt_insn><mode>3_1): Macroize insn from *ashr<mode>3_1\n-\tand *lshr<mode>3_1 using any_shiftrt code iterator.\n-\t(*<shiftrt_insn>si3_1_zext): Ditto from *ashrsi3_1_zext\n-\tand *lshrsi3_1_zext.\n-\t(*<shiftrt_insn>qi3_1_slp): Ditto from *ashrqi3_1_slp\n-\tand *lshrqi3_1_slp.\n-\t(*<shiftrt_insn><mode>3_cmp): Ditto from *ashr<mode>3_cmp\n-\tand *lshr<mode>3_cmp.\n-\t(*<shiftrt_insn><mode>3_cmp_zext): Ditto from *ashr<mode>3_cmp_zext\n-\tand *lshr<mode>3_cmp_zext.\n-\t(*<shiftrt_insn><mode>3_cconly): Ditto from *ashr<mode>3_cconly\n-\tand *lshr<mode>3_cconly.\n+\t(*<shiftrt_insn><mode>3_1): Macroize insn from *{ashr,lshr}<mode>3_1\n+\tusing any_shiftrt code iterator.\n+\t(*<shiftrt_insn>si3_1_zext): Ditto from *{ashr,lshr}si3_1_zext.\n+\t(*<shiftrt_insn>qi3_1_slp): Ditto from *{ashr,lshr}qi3_1_slp.\n+\t(*<shiftrt_insn><mode>3_cmp): Ditto from *{ashr,lshr}<mode>3_cmp.\n+\t(*<shiftrt_insn><mode>3_cmp_zext): Ditto from\n+\t*{ashr,lshr}<mode>3_cmp_zext.\n+\t(*<shiftrt_insn><mode>3_cconly): Ditto from *{ashr,lshr}<mode>3_cconly.\n \n 2010-04-11  Uros Bizjak  <ubizjak@gmail.com>\n \n@@ -187,8 +211,8 @@\n \t(*lshr<mode>3_doubleword peephole2): Macroize peephole2 pattern\n \tfrom corresponding peephole2 patterns.\n \t(*lshr<mode>3_1): Merge with *lshr{qi,hi,si}3_1_one_bit and\n-\t*lshrdi3_1_one_bit_rex64. Macroize insn from *lshr{qi,hi,si}3_cmp\n-\tand *lshrdi3_cmp_rex64 using SWI mode iterator.\n+\t*lshrdi3_1_one_bit_rex64. Macroize insn from *lshr{qi,hi,si}3_1\n+\tand *lshrdi3_1_rex64 using SWI mode iterator.\n \t(*lshrsi3_1_zext): Merge with *lshrsi3_1_one_bit_zext.\n \t(*lshrqi3_1_slp): Merge with *lshrqi3_1_one_bit_slp.\n \t(*lshr<mode>3_cmp): Merge with *lshr{qi,hi,si}3_one_bit_cmp and\n@@ -215,8 +239,8 @@\n \t(x86_shift<mode>_adj_3): Macroize expander from x86_shift_adj_3\n \tand x86_64_shift_adj_3 using SWI48 mode iterator.\n \t(*ashr<mode>3_1): Merge with *ashr{qi,hi,si}3_1_one_bit and\n-\t*ashrdi3_1_one_bit_rex64. Macroize insn from *ashr{qi,hi,si}3_cmp\n-\tand *ashrdi3_cmp_rex64 using SWI mode iterator.\n+\t*ashrdi3_1_one_bit_rex64. Macroize insn from *ashr{qi,hi,si}3_1\n+\tand *ashrdi3_1_rex64 using SWI mode iterator.\n \t(*ashrsi3_1_zext): Merge with *ashrsi3_1_one_bit_zext.\n \t(*ashrqi3_1_slp): Merge with *ashrqi3_1_one_bit_slp.\n \t(*ashr<mode>3_cmp): Merge with *ashr{qi,hi,si}3_one_bit_cmp and"}, {"sha": "411feaf6fa8bb8e65dc044d4111f3e7a78c00d2c", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 152, "deletions": 396, "changes": 548, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0db9cc648242cbbea38cc3c559663acb501aee8/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0db9cc648242cbbea38cc3c559663acb501aee8/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=e0db9cc648242cbbea38cc3c559663acb501aee8", "patch": "@@ -733,6 +733,15 @@\n ;; Base name for insn mnemonic.\n (define_code_attr shiftrt [(lshiftrt \"shr\") (ashiftrt \"sar\")])\n \n+;; Mapping of rotate operators\n+(define_code_iterator any_rotate [rotate rotatert])\n+\n+;; Base name for define_insn\n+(define_code_attr rotate_insn [(rotate \"rotl\") (rotatert \"rotr\")])\n+\n+;; Base name for insn mnemonic.\n+(define_code_attr rotate [(rotate \"rol\") (rotatert \"ror\")])\n+\n ;; Mapping of abs neg operators\n (define_code_iterator absneg [abs neg])\n \n@@ -776,6 +785,11 @@\n \t\t\t    (HI \"TARGET_HIMODE_MATH\")\n \t\t\t    SI (DI \"TARGET_64BIT\")])\n \n+;; Math-dependant single word integer modes without DImode.\n+(define_mode_iterator SWIM124 [(QI \"TARGET_QIMODE_MATH\")\n+\t\t\t       (HI \"TARGET_HIMODE_MATH\")\n+\t\t\t       SI])\n+\n ;; Math-dependant single word integer modes without QImode.\n (define_mode_iterator SWIM248 [(HI \"TARGET_HIMODE_MATH\")\n \t\t      \t       SI (DI \"TARGET_64BIT\")])\n@@ -10542,451 +10556,193 @@\n \f\n ;; Rotate instructions\n \n-(define_expand \"rotldi3\"\n+(define_expand \"<rotate_insn>ti3\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"\")\n+\t(any_rotate:TI (match_operand:TI 1 \"register_operand\" \"\")\n+\t\t       (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  \"TARGET_64BIT\"\n+{\n+  if (const_1_to_63_operand (operands[2], VOIDmode))\n+    emit_insn (gen_ix86_<rotate_insn>ti3_doubleword\n+\t\t(operands[0], operands[1], operands[2]));\n+  else\n+    FAIL;\n+\n+  DONE;\n+})\n+\n+(define_expand \"<rotate_insn>di3\"\n   [(set (match_operand:DI 0 \"shiftdi_operand\" \"\")\n-\t(rotate:DI (match_operand:DI 1 \"shiftdi_operand\" \"\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+\t(any_rotate:DI (match_operand:DI 1 \"shiftdi_operand\" \"\")\n+\t\t       (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n  \"\"\n {\n   if (TARGET_64BIT)\n-    {\n-      ix86_expand_binary_operator (ROTATE, DImode, operands);\n-      DONE;\n-    }\n-  if (!const_1_to_31_operand (operands[2], VOIDmode))\n+    ix86_expand_binary_operator (<CODE>, DImode, operands);\n+  else if (const_1_to_31_operand (operands[2], VOIDmode))\n+    emit_insn (gen_ix86_<rotate_insn>di3_doubleword\n+\t\t(operands[0], operands[1], operands[2]));\n+  else\n     FAIL;\n-  emit_insn (gen_ix86_rotldi3 (operands[0], operands[1], operands[2]));\n+\n   DONE;\n })\n \n-;; Implement rotation using two double-precision shift instructions\n-;; and a scratch register.\n-(define_insn_and_split \"ix86_rotldi3\"\n- [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-       (rotate:DI (match_operand:DI 1 \"register_operand\" \"0\")\n-                  (match_operand:QI 2 \"const_1_to_31_operand\" \"I\")))\n+(define_expand \"<rotate_insn><mode>3\"\n+  [(set (match_operand:SWIM124 0 \"nonimmediate_operand\" \"\")\n+\t(any_rotate:SWIM124 (match_operand:SWIM124 1 \"nonimmediate_operand\" \"\")\n+\t\t\t    (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"ix86_expand_binary_operator (<CODE>, <MODE>mode, operands); DONE;\")\n+\n+;; Implement rotation using two double-precision\n+;; shift instructions and a scratch register.\n+\n+(define_insn_and_split \"ix86_rotl<dwi>3_doubleword\"\n+ [(set (match_operand:<DWI> 0 \"register_operand\" \"=r\")\n+       (rotate:<DWI> (match_operand:<DWI> 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"<shift_immediate_operand>\" \"<S>\")))\n   (clobber (reg:CC FLAGS_REG))\n-  (clobber (match_scratch:SI 3 \"=&r\"))]\n- \"!TARGET_64BIT\"\n+  (clobber (match_scratch:DWIH 3 \"=&r\"))]\n  \"\"\n- \"&& reload_completed\"\n+ \"#\"\n+ \"reload_completed\"\n  [(set (match_dup 3) (match_dup 4))\n   (parallel\n    [(set (match_dup 4)\n-         (ior:SI (ashift:SI (match_dup 4) (match_dup 2))\n-                 (lshiftrt:SI (match_dup 5)\n-                              (minus:QI (const_int 32) (match_dup 2)))))\n+\t (ior:DWIH (ashift:DWIH (match_dup 4) (match_dup 2))\n+\t\t   (lshiftrt:DWIH (match_dup 5)\n+\t\t\t\t  (minus:QI (match_dup 6) (match_dup 2)))))\n     (clobber (reg:CC FLAGS_REG))])\n   (parallel\n    [(set (match_dup 5)\n-         (ior:SI (ashift:SI (match_dup 5) (match_dup 2))\n-                 (lshiftrt:SI (match_dup 3)\n-                              (minus:QI (const_int 32) (match_dup 2)))))\n+\t (ior:DWIH (ashift:DWIH (match_dup 5) (match_dup 2))\n+\t\t   (lshiftrt:DWIH (match_dup 3)\n+\t\t\t\t  (minus:QI (match_dup 6) (match_dup 2)))))\n     (clobber (reg:CC FLAGS_REG))])]\n- \"split_di (&operands[0], 1, &operands[4], &operands[5]);\")\n-\n-(define_insn \"*rotlsi3_1_one_bit_rex64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(rotate:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0\")\n-\t\t   (match_operand:QI 2 \"const1_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\n-   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_binary_operator_ok (ROTATE, DImode, operands)\"\n-  \"rol{q}\\t%0\"\n-  [(set_attr \"type\" \"rotate\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"DI\")])\n-\n-(define_insn \"*rotldi3_1_rex64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm,rm\")\n-\t(rotate:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0,0\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"e,c\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && ix86_binary_operator_ok (ROTATE, DImode, operands)\"\n-  \"@\n-   rol{q}\\t{%2, %0|%0, %2}\n-   rol{q}\\t{%b2, %0|%0, %b2}\"\n-  [(set_attr \"type\" \"rotate\")\n-   (set_attr \"mode\" \"DI\")])\n-\n-(define_expand \"rotlsi3\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n-\t(rotate:SI (match_operand:SI 1 \"nonimmediate_operand\" \"\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"ix86_expand_binary_operator (ROTATE, SImode, operands); DONE;\")\n-\n-(define_insn \"*rotlsi3_1_one_bit\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(rotate:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n-\t\t   (match_operand:QI 2 \"const1_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"(TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_binary_operator_ok (ROTATE, SImode, operands)\"\n-  \"rol{l}\\t%0\"\n-  [(set_attr \"type\" \"rotate\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*rotlsi3_1_one_bit_zext\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:DI\n-\t  (rotate:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"const1_operand\" \"\"))))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\n-   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_binary_operator_ok (ROTATE, SImode, operands)\"\n-  \"rol{l}\\t%k0\"\n-  [(set_attr \"type\" \"rotate\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*rotlsi3_1\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm,rm\")\n-\t(rotate:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0,0\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"I,c\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_binary_operator_ok (ROTATE, SImode, operands)\"\n-  \"@\n-   rol{l}\\t{%2, %0|%0, %2}\n-   rol{l}\\t{%b2, %0|%0, %b2}\"\n-  [(set_attr \"type\" \"rotate\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*rotlsi3_1_zext\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n-\t(zero_extend:DI\n-\t  (rotate:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"I,c\"))))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && ix86_binary_operator_ok (ROTATE, SImode, operands)\"\n-  \"@\n-   rol{l}\\t{%2, %k0|%k0, %2}\n-   rol{l}\\t{%b2, %k0|%k0, %b2}\"\n-  [(set_attr \"type\" \"rotate\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"rotlhi3\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n-\t(rotate:HI (match_operand:HI 1 \"nonimmediate_operand\" \"\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n-  \"TARGET_HIMODE_MATH\"\n-  \"ix86_expand_binary_operator (ROTATE, HImode, operands); DONE;\")\n-\n-(define_insn \"*rotlhi3_1_one_bit\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(rotate:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")\n-\t\t   (match_operand:QI 2 \"const1_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"(TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_binary_operator_ok (ROTATE, HImode, operands)\"\n-  \"rol{w}\\t%0\"\n-  [(set_attr \"type\" \"rotate\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"HI\")])\n-\n-(define_insn \"*rotlhi3_1\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,rm\")\n-\t(rotate:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0,0\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"I,c\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_binary_operator_ok (ROTATE, HImode, operands)\"\n-  \"@\n-   rol{w}\\t{%2, %0|%0, %2}\n-   rol{w}\\t{%b2, %0|%0, %b2}\"\n-  [(set_attr \"type\" \"rotate\")\n-   (set_attr \"mode\" \"HI\")])\n-\n-(define_split\n- [(set (match_operand:HI 0 \"register_operand\" \"\")\n-       (rotate:HI (match_dup 0) (const_int 8)))\n-  (clobber (reg:CC FLAGS_REG))]\n- \"reload_completed\"\n- [(parallel [(set (strict_low_part (match_dup 0))\n-\t\t  (bswap:HI (match_dup 0)))\n-\t     (clobber (reg:CC FLAGS_REG))])]\n- \"\")\n-\n-(define_expand \"rotlqi3\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n-\t(rotate:QI (match_operand:QI 1 \"nonimmediate_operand\" \"\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n-  \"TARGET_QIMODE_MATH\"\n-  \"ix86_expand_binary_operator (ROTATE, QImode, operands); DONE;\")\n-\n-(define_insn \"*rotlqi3_1_one_bit_slp\"\n-  [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm\"))\n-\t(rotate:QI (match_dup 0)\n-\t\t   (match_operand:QI 1 \"const1_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"(! TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n-   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\"\n-  \"rol{b}\\t%0\"\n-  [(set_attr \"type\" \"rotate1\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_insn \"*rotlqi3_1_one_bit\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm\")\n-\t(rotate:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0\")\n-\t\t   (match_operand:QI 2 \"const1_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"(TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_binary_operator_ok (ROTATE, QImode, operands)\"\n-  \"rol{b}\\t%0\"\n-  [(set_attr \"type\" \"rotate\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_insn \"*rotlqi3_1_slp\"\n-  [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm,qm\"))\n-\t(rotate:QI (match_dup 0)\n-\t\t   (match_operand:QI 1 \"nonmemory_operand\" \"I,c\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"(! TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n-  \"@\n-   rol{b}\\t{%1, %0|%0, %1}\n-   rol{b}\\t{%b1, %0|%0, %b1}\"\n-  [(set_attr \"type\" \"rotate1\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_insn \"*rotlqi3_1\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,qm\")\n-\t(rotate:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0,0\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"I,c\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_binary_operator_ok (ROTATE, QImode, operands)\"\n-  \"@\n-   rol{b}\\t{%2, %0|%0, %2}\n-   rol{b}\\t{%b2, %0|%0, %b2}\"\n-  [(set_attr \"type\" \"rotate\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_expand \"rotrdi3\"\n-  [(set (match_operand:DI 0 \"shiftdi_operand\" \"\")\n-\t(rotate:DI (match_operand:DI 1 \"shiftdi_operand\" \"\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n- \"\"\n {\n-  if (TARGET_64BIT)\n-    {\n-      ix86_expand_binary_operator (ROTATERT, DImode, operands);\n-      DONE;\n-    }\n-  if (!const_1_to_31_operand (operands[2], VOIDmode))\n-    FAIL;\n-  emit_insn (gen_ix86_rotrdi3 (operands[0], operands[1], operands[2]));\n-  DONE;\n+  operands[6] = GEN_INT (GET_MODE_BITSIZE (<MODE>mode));\n+\n+  split_<dwi> (&operands[0], 1, &operands[4], &operands[5]);\n })\n \n-;; Implement rotation using two double-precision shift instructions\n-;; and a scratch register.\n-(define_insn_and_split \"ix86_rotrdi3\"\n- [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-       (rotatert:DI (match_operand:DI 1 \"register_operand\" \"0\")\n-                    (match_operand:QI 2 \"const_1_to_31_operand\" \"I\")))\n+(define_insn_and_split \"ix86_rotr<dwi>3_doubleword\"\n+ [(set (match_operand:<DWI> 0 \"register_operand\" \"=r\")\n+       (rotatert:<DWI> (match_operand:<DWI> 1 \"register_operand\" \"0\")\n+\t\t       (match_operand:QI 2 \"<shift_immediate_operand>\" \"<S>\")))\n   (clobber (reg:CC FLAGS_REG))\n-  (clobber (match_scratch:SI 3 \"=&r\"))]\n- \"!TARGET_64BIT\"\n+  (clobber (match_scratch:DWIH 3 \"=&r\"))]\n  \"\"\n- \"&& reload_completed\"\n+ \"#\"\n+ \"reload_completed\"\n  [(set (match_dup 3) (match_dup 4))\n   (parallel\n    [(set (match_dup 4)\n-         (ior:SI (ashiftrt:SI (match_dup 4) (match_dup 2))\n-                 (ashift:SI (match_dup 5)\n-                            (minus:QI (const_int 32) (match_dup 2)))))\n+\t (ior:DWIH (ashiftrt:DWIH (match_dup 4) (match_dup 2))\n+\t\t   (ashift:DWIH (match_dup 5)\n+\t\t\t\t(minus:QI (match_dup 6) (match_dup 2)))))\n     (clobber (reg:CC FLAGS_REG))])\n   (parallel\n    [(set (match_dup 5)\n-         (ior:SI (ashiftrt:SI (match_dup 5) (match_dup 2))\n-                 (ashift:SI (match_dup 3)\n-                            (minus:QI (const_int 32) (match_dup 2)))))\n+\t (ior:DWIH (ashiftrt:DWIH (match_dup 5) (match_dup 2))\n+\t\t   (ashift:DWIH (match_dup 3)\n+\t\t\t\t(minus:QI (match_dup 6) (match_dup 2)))))\n     (clobber (reg:CC FLAGS_REG))])]\n- \"split_di (&operands[0], 1, &operands[4], &operands[5]);\")\n-\n-(define_insn \"*rotrdi3_1_one_bit_rex64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(rotatert:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"const1_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\n-   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_binary_operator_ok (ROTATERT, DImode, operands)\"\n-  \"ror{q}\\t%0\"\n-  [(set_attr \"type\" \"rotate\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"DI\")])\n-\n-(define_insn \"*rotrdi3_1_rex64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm,rm\")\n-\t(rotatert:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0,0\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"J,c\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && ix86_binary_operator_ok (ROTATERT, DImode, operands)\"\n-  \"@\n-   ror{q}\\t{%2, %0|%0, %2}\n-   ror{q}\\t{%b2, %0|%0, %b2}\"\n-  [(set_attr \"type\" \"rotate\")\n-   (set_attr \"mode\" \"DI\")])\n+{\n+  operands[6] = GEN_INT (GET_MODE_BITSIZE (<MODE>mode));\n \n-(define_expand \"rotrsi3\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n-\t(rotatert:SI (match_operand:SI 1 \"nonimmediate_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"ix86_expand_binary_operator (ROTATERT, SImode, operands); DONE;\")\n+  split_<dwi> (&operands[0], 1, &operands[4], &operands[5]);\n+})\n \n-(define_insn \"*rotrsi3_1_one_bit\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(rotatert:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"const1_operand\" \"\")))\n+(define_insn \"*<rotate_insn><mode>3_1\"\n+  [(set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>m\")\n+\t(any_rotate:SWI (match_operand:SWI 1 \"nonimmediate_operand\" \"0\")\n+\t\t\t(match_operand:QI 2 \"nonmemory_operand\" \"c<S>\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"(TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_binary_operator_ok (ROTATERT, SImode, operands)\"\n-  \"ror{l}\\t%0\"\n+  \"ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n+{\n+  if (REG_P (operands[2]))\n+    return \"<rotate>{<imodesuffix>}\\t{%b2, %0|%0, %b2}\";\n+  else if (operands[2] == const1_rtx\n+\t   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n+    return \"<rotate>{<imodesuffix>}\\t%0\";\n+  else\n+    return \"<rotate>{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n+}\n   [(set_attr \"type\" \"rotate\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"SI\")])\n+   (set (attr \"length_immediate\")\n+     (if_then_else\n+       (and (match_operand 2 \"const1_operand\" \"\")\n+\t    (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n+\t\t(const_int 0)))\n+       (const_string \"0\")\n+       (const_string \"*\")))\n+   (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*rotrsi3_1_one_bit_zext\"\n+(define_insn \"*<rotate_insn>si3_1_zext\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI\n-\t  (rotatert:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const1_operand\" \"\"))))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\n-   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_binary_operator_ok (ROTATERT, SImode, operands)\"\n-  \"ror{l}\\t%k0\"\n-  [(set_attr \"type\" \"rotate\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*rotrsi3_1\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm,rm\")\n-\t(rotatert:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0,0\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"I,c\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_binary_operator_ok (ROTATERT, SImode, operands)\"\n-  \"@\n-   ror{l}\\t{%2, %0|%0, %2}\n-   ror{l}\\t{%b2, %0|%0, %b2}\"\n-  [(set_attr \"type\" \"rotate\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*rotrsi3_1_zext\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n-\t(zero_extend:DI\n-\t  (rotatert:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t\t       (match_operand:QI 2 \"nonmemory_operand\" \"I,c\"))))\n+\t  (any_rotate:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t (match_operand:QI 2 \"nonmemory_operand\" \"cI\"))))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && ix86_binary_operator_ok (ROTATERT, SImode, operands)\"\n-  \"@\n-   ror{l}\\t{%2, %k0|%k0, %2}\n-   ror{l}\\t{%b2, %k0|%k0, %b2}\"\n+  \"TARGET_64BIT && ix86_binary_operator_ok (<CODE>, SImode, operands)\"\n+{\n+  if (REG_P (operands[2]))\n+    return \"<rotate>{l}\\t{%b2, %k0|%k0, %b2}\";\n+  else if (operands[2] == const1_rtx\n+\t   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n+    return \"<rotate>{l}\\t%k0\";\n+  else\n+    return \"<rotate>{l}\\t{%2, %k0|%k0, %2}\";\n+}\n   [(set_attr \"type\" \"rotate\")\n+   (set (attr \"length_immediate\")\n+     (if_then_else\n+       (and (match_operand 2 \"const1_operand\" \"\")\n+\t    (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n+\t\t(const_int 0)))\n+       (const_string \"0\")\n+       (const_string \"*\")))\n    (set_attr \"mode\" \"SI\")])\n \n-(define_expand \"rotrhi3\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n-\t(rotatert:HI (match_operand:HI 1 \"nonimmediate_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n-  \"TARGET_HIMODE_MATH\"\n-  \"ix86_expand_binary_operator (ROTATERT, HImode, operands); DONE;\")\n-\n-(define_insn \"*rotrhi3_one_bit\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(rotatert:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"const1_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"(TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_binary_operator_ok (ROTATERT, HImode, operands)\"\n-  \"ror{w}\\t%0\"\n-  [(set_attr \"type\" \"rotate\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"HI\")])\n-\n-(define_insn \"*rotrhi3_1\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,rm\")\n-\t(rotatert:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0,0\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"I,c\")))\n+(define_insn \"*<rotate_insn>qi3_1_slp\"\n+  [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm\"))\n+\t(any_rotate:QI (match_dup 0)\n+\t\t       (match_operand:QI 1 \"nonmemory_operand\" \"cI\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_binary_operator_ok (ROTATERT, HImode, operands)\"\n-  \"@\n-   ror{w}\\t{%2, %0|%0, %2}\n-   ror{w}\\t{%b2, %0|%0, %b2}\"\n-  [(set_attr \"type\" \"rotate\")\n-   (set_attr \"mode\" \"HI\")])\n+  \"(optimize_function_for_size_p (cfun)\n+    || !TARGET_PARTIAL_REG_STALL\n+    || (operands[1] == const1_rtx\n+\t&& TARGET_SHIFT1))\"\n+{\n+  if (REG_P (operands[1]))\n+    return \"<rotate>{b}\\t{%b1, %0|%0, %b1}\";\n+  else if (operands[1] == const1_rtx\n+\t   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n+    return \"<rotate>{b}\\t%0\";\n+  else\n+    return \"<rotate>{b}\\t{%1, %0|%0, %1}\";\n+}\n+  [(set_attr \"type\" \"rotate1\")\n+   (set (attr \"length_immediate\")\n+     (if_then_else\n+       (and (match_operand 1 \"const1_operand\" \"\")\n+\t    (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n+\t\t(const_int 0)))\n+       (const_string \"0\")\n+       (const_string \"*\")))\n+   (set_attr \"mode\" \"QI\")])\n \n (define_split\n  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-       (rotatert:HI (match_dup 0) (const_int 8)))\n+       (any_rotate:HI (match_dup 0) (const_int 8)))\n   (clobber (reg:CC FLAGS_REG))]\n- \"reload_completed\"\n+ \"reload_completed\n+  && (TARGET_USE_XCHGB || optimize_function_for_size_p (cfun))\"\n  [(parallel [(set (strict_low_part (match_dup 0))\n \t\t  (bswap:HI (match_dup 0)))\n \t     (clobber (reg:CC FLAGS_REG))])]\n  \"\")\n-\n-(define_expand \"rotrqi3\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n-\t(rotatert:QI (match_operand:QI 1 \"nonimmediate_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n-  \"TARGET_QIMODE_MATH\"\n-  \"ix86_expand_binary_operator (ROTATERT, QImode, operands); DONE;\")\n-\n-(define_insn \"*rotrqi3_1_one_bit\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm\")\n-\t(rotatert:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"const1_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"(TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_binary_operator_ok (ROTATERT, QImode, operands)\"\n-  \"ror{b}\\t%0\"\n-  [(set_attr \"type\" \"rotate\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_insn \"*rotrqi3_1_one_bit_slp\"\n-  [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm\"))\n-\t(rotatert:QI (match_dup 0)\n-\t\t     (match_operand:QI 1 \"const1_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"(! TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n-   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\"\n-  \"ror{b}\\t%0\"\n-  [(set_attr \"type\" \"rotate1\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_insn \"*rotrqi3_1\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,qm\")\n-\t(rotatert:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0,0\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"I,c\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_binary_operator_ok (ROTATERT, QImode, operands)\"\n-  \"@\n-   ror{b}\\t{%2, %0|%0, %2}\n-   ror{b}\\t{%b2, %0|%0, %b2}\"\n-  [(set_attr \"type\" \"rotate\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_insn \"*rotrqi3_1_slp\"\n-  [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm,qm\"))\n-\t(rotatert:QI (match_dup 0)\n-\t\t     (match_operand:QI 1 \"nonmemory_operand\" \"I,c\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"(! TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n-  \"@\n-   ror{b}\\t{%1, %0|%0, %1}\n-   ror{b}\\t{%b1, %0|%0, %b1}\"\n-  [(set_attr \"type\" \"rotate1\")\n-   (set_attr \"mode\" \"QI\")])\n \f\n ;; Bit set / bit test instructions\n "}, {"sha": "68e4aa9e452a6451f5a6a26ad5a4a3ee1b7f7b88", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0db9cc648242cbbea38cc3c559663acb501aee8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0db9cc648242cbbea38cc3c559663acb501aee8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e0db9cc648242cbbea38cc3c559663acb501aee8", "patch": "@@ -1,8 +1,11 @@\n+2010-04-12  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* gcc.target/i386/rotate-2.c: New test.\n+\n 2010-04-12  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/43641\n \t* g++.dg/cpp0x/lambda/lambda-conv4.C: New.\n-\n \t* g++.dg/cpp0x/lambda/lambda-deduce2.C: New.\n \n 2010-04-12  Fabien Chene  <fabien.chene@gmail.com>"}, {"sha": "69a062527a4ec23433e2b969556289af615d95f8", "filename": "gcc/testsuite/gcc.target/i386/rotate-2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0db9cc648242cbbea38cc3c559663acb501aee8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frotate-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0db9cc648242cbbea38cc3c559663acb501aee8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frotate-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Frotate-2.c?ref=e0db9cc648242cbbea38cc3c559663acb501aee8", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O2\" } */\n+\n+typedef unsigned int UTItype __attribute__ ((mode (TI)));\n+\n+void foo (UTItype *);\n+\n+UTItype\n+test (void)\n+{\n+  UTItype c = 0;\n+  foo (&c);\n+  c = c >> 5 | c << 123;\n+  return c;\n+}\n+/* { dg-final { scan-assembler-times \"shrdq\" 2 } } */"}]}