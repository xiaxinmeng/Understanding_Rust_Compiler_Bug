{"sha": "bc6d3f91a344f7ba4840fd41890076c62d2a538a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM2ZDNmOTFhMzQ0ZjdiYTQ4NDBmZDQxODkwMDc2YzYyZDJhNTM4YQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-06-02T10:48:11Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-06-02T10:48:11Z"}, "message": "function.h (struct stack_usage): Remove dynamic_alloc_count field.\n\n\t* function.h (struct stack_usage): Remove dynamic_alloc_count field.\n\t(current_function_dynamic_alloc_count): Delete.\n\t* builtins.c (expand_builtin_setjmp_setup): Do not set calls_setjmp.\n\t(expand_builtin_nonlocal_goto): Remove obsolete comment.\n\t(expand_builtin_update_setjmp_buf): Remove dead code.\n\t* cse.c (cse_find_path): Do not follow a single abnormal incoming edge.\n\t* explow.c (allocate_dynamic_stack_space): Remove SETJMP_VIA_SAVE_AREA\n\tsupport.\n\t* function.c (instantiate_virtual_regs): Likewise.\n\t* postreload-gcse.c (bb_has_well_behaved_predecessors): Return false\n\tfor a block with a single abnormal incoming edge.\n\t* config/sparc/sparc.h (STACK_SAVEAREA_MODE): Define.\n\t* config/sparc/sparc-protos.h (load_got_register): Declare.\n\t* config/sparc/sparc.c (TARGET_BUILTIN_SETJMP_FRAME_VALUE): Define.\n\t(load_got_register): Make global.\n\t(sparc_frame_pointer_required): Add 'static'.\n\t(sparc_can_eliminate): Likewise.  Call sparc_frame_pointer_required.\n\t(sparc_builtin_setjmp_frame_value): New function.\n\t* config/sparc/sparc.md (UNSPECV_SETJMP): Remove.\n\t(save_stack_nonlocal): New expander.\n\t(restore_stack_nonlocal): Likewise.\n\t(nonlocal_goto): Remove modes, adjust predicates and reimplement.\n\t(nonlocal_goto_internal): New insn.\n\t(goto_handler_and_restore): Delete.\n\t(builtin_setjmp_setup): Likewise.\n\t(do_builtin_setjmp_setup): Likewise.\n\t(setjmp): Likewise.\n\t(builtin_setjmp_receiver): New expander.\n\nFrom-SVN: r174564", "tree": {"sha": "5f109a1d3dfcb88bc0c15d333cf680895b7292b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f109a1d3dfcb88bc0c15d333cf680895b7292b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc6d3f91a344f7ba4840fd41890076c62d2a538a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc6d3f91a344f7ba4840fd41890076c62d2a538a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc6d3f91a344f7ba4840fd41890076c62d2a538a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc6d3f91a344f7ba4840fd41890076c62d2a538a/comments", "author": null, "committer": null, "parents": [{"sha": "66bd20e7b61b37c6a13cb71e20be5f69236d0bbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66bd20e7b61b37c6a13cb71e20be5f69236d0bbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66bd20e7b61b37c6a13cb71e20be5f69236d0bbe"}], "stats": {"total": 337, "additions": 142, "deletions": 195}, "files": [{"sha": "cddb5243b51bcd65c4567c198fb3b35713c77cbf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc6d3f91a344f7ba4840fd41890076c62d2a538a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc6d3f91a344f7ba4840fd41890076c62d2a538a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc6d3f91a344f7ba4840fd41890076c62d2a538a", "patch": "@@ -1,3 +1,34 @@\n+2011-06-02  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* function.h (struct stack_usage): Remove dynamic_alloc_count field.\n+\t(current_function_dynamic_alloc_count): Delete.\n+\t* builtins.c (expand_builtin_setjmp_setup): Do not set calls_setjmp.\n+\t(expand_builtin_nonlocal_goto): Remove obsolete comment.\n+\t(expand_builtin_update_setjmp_buf): Remove dead code.\n+\t* cse.c (cse_find_path): Do not follow a single abnormal incoming edge.\n+\t* explow.c (allocate_dynamic_stack_space): Remove SETJMP_VIA_SAVE_AREA\n+\tsupport.\n+\t* function.c (instantiate_virtual_regs): Likewise.\n+\t* postreload-gcse.c (bb_has_well_behaved_predecessors): Return false\n+\tfor a block with a single abnormal incoming edge.\n+\t* config/sparc/sparc.h (STACK_SAVEAREA_MODE): Define.\n+\t* config/sparc/sparc-protos.h (load_got_register): Declare.\n+\t* config/sparc/sparc.c (TARGET_BUILTIN_SETJMP_FRAME_VALUE): Define.\n+\t(load_got_register): Make global.\n+\t(sparc_frame_pointer_required): Add 'static'.\n+\t(sparc_can_eliminate): Likewise.  Call sparc_frame_pointer_required.\n+\t(sparc_builtin_setjmp_frame_value): New function.\n+\t* config/sparc/sparc.md (UNSPECV_SETJMP): Remove.\n+\t(save_stack_nonlocal): New expander.\n+\t(restore_stack_nonlocal): Likewise.\n+\t(nonlocal_goto): Remove modes, adjust predicates and reimplement.\n+\t(nonlocal_goto_internal): New insn.\n+\t(goto_handler_and_restore): Delete.\n+\t(builtin_setjmp_setup): Likewise.\n+\t(do_builtin_setjmp_setup): Likewise.\n+\t(setjmp): Likewise.\n+\t(builtin_setjmp_receiver): New expander.\n+\n 2011-06-01  David Li  <davidxl@google.com>\n \n \tPR middle-end/49261"}, {"sha": "d37558c15260c166db559588fb06b2ef70cf0d9b", "filename": "gcc/builtins.c", "status": "modified", "additions": 5, "deletions": 29, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc6d3f91a344f7ba4840fd41890076c62d2a538a/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc6d3f91a344f7ba4840fd41890076c62d2a538a/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=bc6d3f91a344f7ba4840fd41890076c62d2a538a", "patch": "@@ -806,10 +806,6 @@ expand_builtin_setjmp_setup (rtx buf_addr, rtx receiver_label)\n     emit_insn (gen_builtin_setjmp_setup (buf_addr));\n #endif\n \n-  /* Tell optimize_save_area_alloca that extra work is going to\n-     need to go on during alloca.  */\n-  cfun->calls_setjmp = 1;\n-\n   /* We have a nonlocal label.   */\n   cfun->has_nonlocal_label = 1;\n }\n@@ -992,8 +988,8 @@ expand_builtin_nonlocal_goto (tree exp)\n   r_label = convert_memory_address (Pmode, r_label);\n   r_save_area = expand_normal (t_save_area);\n   r_save_area = convert_memory_address (Pmode, r_save_area);\n-  /* Copy the address of the save location to a register just in case it was based\n-    on the frame pointer.   */\n+  /* Copy the address of the save location to a register just in case it was\n+     based on the frame pointer.   */\n   r_save_area = copy_to_reg (r_save_area);\n   r_fp = gen_rtx_MEM (Pmode, r_save_area);\n   r_sp = gen_rtx_MEM (STACK_SAVEAREA_MODE (SAVE_NONLOCAL),\n@@ -1013,11 +1009,7 @@ expand_builtin_nonlocal_goto (tree exp)\n       emit_clobber (gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (VOIDmode)));\n       emit_clobber (gen_rtx_MEM (BLKmode, hard_frame_pointer_rtx));\n \n-      /* Restore frame pointer for containing function.\n-\t This sets the actual hard register used for the frame pointer\n-\t to the location of the function's incoming static chain info.\n-\t The non-local goto handler will then adjust it to contain the\n-\t proper value and reload the argument pointer, if needed.  */\n+      /* Restore frame pointer for containing function.  */\n       emit_move_insn (hard_frame_pointer_rtx, r_fp);\n       emit_stack_restore (SAVE_NONLOCAL, r_sp);\n \n@@ -1066,29 +1058,13 @@ expand_builtin_nonlocal_goto (tree exp)\n static void\n expand_builtin_update_setjmp_buf (rtx buf_addr)\n {\n-  enum machine_mode sa_mode = Pmode;\n-  rtx stack_save;\n-\n-\n-#ifdef HAVE_save_stack_nonlocal\n-  if (HAVE_save_stack_nonlocal)\n-    sa_mode = insn_data[(int) CODE_FOR_save_stack_nonlocal].operand[0].mode;\n-#endif\n-#ifdef STACK_SAVEAREA_MODE\n-  sa_mode = STACK_SAVEAREA_MODE (SAVE_NONLOCAL);\n-#endif\n-\n-  stack_save\n+  enum machine_mode sa_mode = STACK_SAVEAREA_MODE (SAVE_NONLOCAL);\n+  rtx stack_save\n     = gen_rtx_MEM (sa_mode,\n \t\t   memory_address\n \t\t   (sa_mode,\n \t\t    plus_constant (buf_addr, 2 * GET_MODE_SIZE (Pmode))));\n \n-#ifdef HAVE_setjmp\n-  if (HAVE_setjmp)\n-    emit_insn (gen_setjmp ());\n-#endif\n-\n   emit_stack_save (SAVE_NONLOCAL, &stack_save);\n }\n "}, {"sha": "ccf16573cb496fbcda8b47570199d89b06e8b97e", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc6d3f91a344f7ba4840fd41890076c62d2a538a/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc6d3f91a344f7ba4840fd41890076c62d2a538a/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=bc6d3f91a344f7ba4840fd41890076c62d2a538a", "patch": "@@ -60,6 +60,7 @@ extern bool constant_address_p (rtx);\n extern bool legitimate_pic_operand_p (rtx);\n extern rtx sparc_legitimize_reload_address (rtx, enum machine_mode, int, int,\n \t\t\t\t\t    int, int *win);\n+extern void load_got_register (void);\n extern void sparc_emit_call_insn (rtx, rtx);\n extern void sparc_defer_case_vector (rtx, rtx, int);\n extern bool sparc_expand_move (enum machine_mode, rtx *);"}, {"sha": "d5d043def0f3127fdf5808710118f6eef5587ed3", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc6d3f91a344f7ba4840fd41890076c62d2a538a/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc6d3f91a344f7ba4840fd41890076c62d2a538a/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=bc6d3f91a344f7ba4840fd41890076c62d2a538a", "patch": "@@ -387,7 +387,6 @@ static rtx sparc_builtin_saveregs (void);\n static int epilogue_renumber (rtx *, int);\n static bool sparc_assemble_integer (rtx, unsigned int, int);\n static int set_extends (rtx);\n-static void load_got_register (void);\n static int save_or_restore_regs (int, int, rtx, int, int);\n static void emit_save_or_restore_regs (int);\n static void sparc_asm_function_prologue (FILE *, HOST_WIDE_INT);\n@@ -464,6 +463,7 @@ static void sparc_output_dwarf_dtprel (FILE *, int, rtx) ATTRIBUTE_UNUSED;\n static void sparc_file_end (void);\n static bool sparc_frame_pointer_required (void);\n static bool sparc_can_eliminate (const int, const int);\n+static rtx sparc_builtin_setjmp_frame_value (void);\n static void sparc_conditional_register_usage (void);\n #ifdef TARGET_ALTERNATE_LONG_DOUBLE_MANGLING\n static const char *sparc_mangle_type (const_tree);\n@@ -650,8 +650,12 @@ static const struct default_options sparc_option_optimization_table[] =\n #undef TARGET_FRAME_POINTER_REQUIRED\n #define TARGET_FRAME_POINTER_REQUIRED sparc_frame_pointer_required\n \n+#undef TARGET_BUILTIN_SETJMP_FRAME_VALUE\n+#define TARGET_BUILTIN_SETJMP_FRAME_VALUE sparc_builtin_setjmp_frame_value\n+\n #undef TARGET_CAN_ELIMINATE\n #define TARGET_CAN_ELIMINATE sparc_can_eliminate\n+\n #undef  TARGET_PREFERRED_RELOAD_CLASS\n #define TARGET_PREFERRED_RELOAD_CLASS sparc_preferred_reload_class\n \n@@ -3770,7 +3774,7 @@ gen_load_pcrel_sym (rtx op0, rtx op1, rtx op2, rtx op3)\n \n /* Emit code to load the GOT register.  */\n \n-static void\n+void\n load_got_register (void)\n {\n   /* In PIC mode, this will retrieve pic_offset_table_rtx.  */\n@@ -9801,7 +9805,7 @@ sparc_expand_compare_and_swap_12 (rtx result, rtx mem, rtx oldval, rtx newval)\n \n /* Implement TARGET_FRAME_POINTER_REQUIRED.  */\n \n-bool\n+static bool\n sparc_frame_pointer_required (void)\n {\n   return !(current_function_is_leaf && only_leaf_regs_used ());\n@@ -9812,11 +9816,18 @@ sparc_frame_pointer_required (void)\n    in that case.  But the test in update_eliminables doesn't know we are\n    assuming below that we only do the former elimination.  */\n \n-bool\n+static bool\n sparc_can_eliminate (const int from ATTRIBUTE_UNUSED, const int to)\n {\n-  return (to == HARD_FRAME_POINTER_REGNUM\n-          || !targetm.frame_pointer_required ());\n+  return to == HARD_FRAME_POINTER_REGNUM || !sparc_frame_pointer_required ();\n+}\n+\n+/* Return the hard frame pointer directly to bypass the stack bias.  */\n+\n+static rtx\n+sparc_builtin_setjmp_frame_value (void)\n+{\n+  return hard_frame_pointer_rtx;\n }\n \n /* If !TARGET_FPU, then make the fp registers and fp cc regs fixed so that"}, {"sha": "67189ecfe8d4104ba9405c05b60a56c20041e114", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc6d3f91a344f7ba4840fd41890076c62d2a538a/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc6d3f91a344f7ba4840fd41890076c62d2a538a/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=bc6d3f91a344f7ba4840fd41890076c62d2a538a", "patch": "@@ -1384,11 +1384,19 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define EPILOGUE_USES(REGNO) ((REGNO) == 31 \\\n   || (crtl->calls_eh_return && (REGNO) == 1))\n \f\n+/* We need 2 words, so we can save the stack pointer and the return register\n+   of the function containing a non-local goto target.  */\n+\n+#define STACK_SAVEAREA_MODE(LEVEL) \\\n+  ((LEVEL) == SAVE_NONLOCAL ? (TARGET_ARCH64 ? TImode : DImode) : Pmode)\n+\n /* Length in units of the trampoline for entering a nested function.  */\n \n #define TRAMPOLINE_SIZE (TARGET_ARCH64 ? 32 : 16)\n \n-#define TRAMPOLINE_ALIGNMENT 128 /* 16 bytes */\n+/* Alignment required for trampolines, in bits.  */\n+\n+#define TRAMPOLINE_ALIGNMENT 128\n \f\n /* Generate RTL to flush the register windows so as to make arbitrary frames\n    available.  */"}, {"sha": "e6342eca5e91826e4ae92e0e2bcb789ddf939457", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 67, "deletions": 104, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc6d3f91a344f7ba4840fd41890076c62d2a538a/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc6d3f91a344f7ba4840fd41890076c62d2a538a/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=bc6d3f91a344f7ba4840fd41890076c62d2a538a", "patch": "@@ -1,7 +1,7 @@\n ;; Machine description for SPARC chip for GCC\n ;;  Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-;;  1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n-;;  Free Software Foundation, Inc.\n+;;  1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n+;;  2011 Free Software Foundation, Inc.\n ;;  Contributed by Michael Tiemann (tiemann@cygnus.com)\n ;;  64-bit SPARC-V9 support by Michael Tiemann, Jim Wilson, and Doug Evans,\n ;;  at Cygnus Support.\n@@ -70,7 +70,6 @@\n    (UNSPECV_FLUSHW\t\t1)\n    (UNSPECV_GOTO\t\t2)\n    (UNSPECV_FLUSH\t\t4)\n-   (UNSPECV_SETJMP\t\t5)\n    (UNSPECV_SAVEW\t\t6)\n    (UNSPECV_CAS\t\t\t8)\n    (UNSPECV_SWAP\t\t9)\n@@ -6444,136 +6443,100 @@\n   \"jmp\\t%a0%#\"\n   [(set_attr \"type\" \"uncond_branch\")])\n \n+(define_expand \"save_stack_nonlocal\"\n+  [(set (match_operand 0 \"memory_operand\" \"\")\n+\t(match_operand 1 \"register_operand\" \"\"))\n+   (set (match_dup 2) (match_dup 3))]\n+  \"\"\n+{\n+  operands[0] = adjust_address_nv (operands[0], Pmode, 0);\n+  operands[2] = adjust_address_nv (operands[0], Pmode, GET_MODE_SIZE (Pmode));\n+  operands[3] = gen_rtx_REG (Pmode, 31); /* %i7 */\n+})\n+\n+(define_expand \"restore_stack_nonlocal\"\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(match_operand 1 \"memory_operand\" \"\"))]\n+  \"\"\n+{\n+  operands[1] = adjust_address_nv (operands[1], Pmode, 0);\n+})\n+\n (define_expand \"nonlocal_goto\"\n-  [(match_operand:SI 0 \"general_operand\" \"\")\n-   (match_operand:SI 1 \"general_operand\" \"\")\n-   (match_operand:SI 2 \"general_operand\" \"\")\n-   (match_operand:SI 3 \"\" \"\")]\n+  [(match_operand 0 \"general_operand\" \"\")\n+   (match_operand 1 \"general_operand\" \"\")\n+   (match_operand 2 \"memory_operand\" \"\")\n+   (match_operand 3 \"memory_operand\" \"\")]\n   \"\"\n {\n-  rtx lab = operands[1];\n-  rtx stack = operands[2];\n-  rtx fp = operands[3];\n-  rtx labreg;\n+  rtx r_label = copy_to_reg (operands[1]);\n+  rtx r_sp = adjust_address_nv (operands[2], Pmode, 0);\n+  rtx r_fp = operands[3];\n+  rtx r_i7 = adjust_address_nv (operands[2], Pmode, GET_MODE_SIZE (Pmode));\n \n-  /* Trap instruction to flush all the register windows.  */\n+  /* We need to flush all the register windows so that their contents will\n+     be re-synchronized by the restore insn of the target function.  */\n   emit_insn (gen_flush_register_windows ());\n \n-  /* Load the fp value for the containing fn into %fp.  This is needed\n-     because STACK refers to %fp.  Note that virtual register instantiation\n-     fails if the virtual %fp isn't set from a register.  */\n-  if (GET_CODE (fp) != REG)\n-    fp = force_reg (Pmode, fp);\n-  emit_move_insn (virtual_stack_vars_rtx, fp);\n-\n-  /* Find the containing function's current nonlocal goto handler,\n-     which will do any cleanups and then jump to the label.  */\n-  labreg = gen_rtx_REG (Pmode, 8);\n-  emit_move_insn (labreg, lab);\n+  emit_clobber (gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (VOIDmode)));\n+  emit_clobber (gen_rtx_MEM (BLKmode, hard_frame_pointer_rtx));\n \n-  /* Restore %fp from stack pointer value for containing function.\n-     The restore insn that follows will move this to %sp,\n-     and reload the appropriate value into %fp.  */\n-  emit_move_insn (hard_frame_pointer_rtx, stack);\n+  /* Restore frame pointer for containing function.  */\n+  emit_move_insn (hard_frame_pointer_rtx, r_fp);\n+  emit_stack_restore (SAVE_NONLOCAL, r_sp);\n \n+  /* USE of hard_frame_pointer_rtx added for consistency;\n+     not clear if really needed.  */\n+  emit_use (hard_frame_pointer_rtx);\n   emit_use (stack_pointer_rtx);\n \n-  /* ??? The V9-specific version was disabled in rev 1.65.  */\n-  emit_jump_insn (gen_goto_handler_and_restore (labreg));\n+  /* We need to smuggle the load of %i7 as it is a fixed register.  */\n+  emit_jump_insn (gen_nonlocal_goto_internal (r_label, r_i7));\n   emit_barrier ();\n   DONE;\n })\n \n-;; Special trap insn to flush register windows.\n-(define_insn \"flush_register_windows\"\n-  [(unspec_volatile [(const_int 0)] UNSPECV_FLUSHW)]\n-  \"\"\n-  { return TARGET_V9 ? \"flushw\" : \"ta\\t3\"; }\n-  [(set_attr \"type\" \"flushw\")])\n-\n-(define_insn \"goto_handler_and_restore\"\n-  [(unspec_volatile [(match_operand 0 \"register_operand\" \"=r\")] UNSPECV_GOTO)]\n-  \"GET_MODE (operands[0]) == Pmode\"\n+(define_insn \"nonlocal_goto_internal\"\n+  [(unspec_volatile [(match_operand 0 \"register_operand\" \"r\")\n+                     (match_operand 1 \"memory_operand\" \"m\")] UNSPECV_GOTO)]\n+  \"GET_MODE (operands[0]) == Pmode && GET_MODE (operands[1]) == Pmode\"\n {\n   if (flag_delayed_branch)\n-    return \"jmp\\t%0\\n\\t restore\";\n+    {\n+      if (TARGET_ARCH64)\n+\treturn \"jmp\\t%0\\n\\t ldx\\t%1, %%i7\";\n+      else\n+\treturn \"jmp\\t%0\\n\\t ld\\t%1, %%i7\";\n+    }\n   else\n-    return \"mov\\t%0,%%g1\\n\\trestore\\n\\tjmp\\t%%g1\\n\\t nop\";\n+    {\n+      if (TARGET_ARCH64)\n+\treturn \"ldx\\t%1, %%i7\\n\\tjmp\\t%0\\n\\t nop\";\n+      else\n+\treturn \"ld\\t%1, %%i7\\n\\tjmp\\t%0\\n\\t nop\";\n+    }\n }\n   [(set (attr \"type\") (const_string \"multi\"))\n    (set (attr \"length\")\n \t(if_then_else (eq_attr \"delayed_branch\" \"true\")\n \t\t      (const_int 2)\n-\t\t      (const_int 4)))])\n+\t\t      (const_int 3)))])\n \n-;; For __builtin_setjmp we need to flush register windows iff the function\n-;; calls alloca as well, because otherwise the current register window might\n-;; be saved after the %sp adjustment and thus setjmp would crash.\n-(define_expand \"builtin_setjmp_setup\"\n-  [(match_operand 0 \"register_operand\" \"r\")]\n-  \"\"\n+(define_expand \"builtin_setjmp_receiver\"\n+  [(label_ref (match_operand 0 \"\" \"\"))]\n+  \"flag_pic\"\n {\n-  emit_insn (gen_do_builtin_setjmp_setup ());\n+  load_got_register ();\n   DONE;\n })\n \n-(define_insn \"do_builtin_setjmp_setup\"\n-  [(unspec_volatile [(const_int 0)] UNSPECV_SETJMP)]\n-  \"\"\n-{\n-  if (!cfun->calls_alloca)\n-    return \"\";\n-  if (!TARGET_V9)\n-    return \"ta\\t3\";\n-  fputs (\"\\tflushw\\n\", asm_out_file);\n-  if (flag_pic)\n-    fprintf (asm_out_file, \"\\tst%c\\t%%l7, [%%sp+%d]\\n\",\n-\t     TARGET_ARCH64 ? 'x' : 'w',\n-\t     SPARC_STACK_BIAS + 7 * UNITS_PER_WORD);\n-  fprintf (asm_out_file, \"\\tst%c\\t%%fp, [%%sp+%d]\\n\",\n-\t   TARGET_ARCH64 ? 'x' : 'w',\n-\t   SPARC_STACK_BIAS + 14 * UNITS_PER_WORD);\n-  fprintf (asm_out_file, \"\\tst%c\\t%%i7, [%%sp+%d]\\n\",\n-\t   TARGET_ARCH64 ? 'x' : 'w',\n-\t   SPARC_STACK_BIAS + 15 * UNITS_PER_WORD);\n-  return \"\";\n-}\n-  [(set_attr \"type\" \"multi\")\n-   (set (attr \"length\")\n-        (cond [(eq_attr \"calls_alloca\" \"false\")\n-                 (const_int 0)\n-               (eq_attr \"isa\" \"!v9\")\n-                 (const_int 1)\n-               (eq_attr \"pic\" \"true\")\n-                 (const_int 4)] (const_int 3)))])\n-\n-;; Pattern for use after a setjmp to store registers into the save area.\n+;; Special insn to flush register windows.\n \n-(define_expand \"setjmp\"\n-  [(const_int 0)]\n+(define_insn \"flush_register_windows\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_FLUSHW)]\n   \"\"\n-{\n-  rtx mem;\n-\n-  if (flag_pic)\n-    {\n-      mem = gen_rtx_MEM (Pmode,\n-\t\t\t plus_constant (stack_pointer_rtx,\n-\t\t\t\t\tSPARC_STACK_BIAS + 7 * UNITS_PER_WORD));\n-      emit_insn (gen_rtx_SET (VOIDmode, mem, pic_offset_table_rtx));\n-    }\n-\n-  mem = gen_rtx_MEM (Pmode,\n-\t\t     plus_constant (stack_pointer_rtx,\n-\t\t\t\t    SPARC_STACK_BIAS + 14 * UNITS_PER_WORD));\n-  emit_insn (gen_rtx_SET (VOIDmode, mem, hard_frame_pointer_rtx));\n-\n-  mem = gen_rtx_MEM (Pmode,\n-\t\t     plus_constant (stack_pointer_rtx,\n-\t\t\t\t    SPARC_STACK_BIAS + 15 * UNITS_PER_WORD));\n-  emit_insn (gen_rtx_SET (VOIDmode, mem, gen_rtx_REG (Pmode, 31)));\n-  DONE;\n-})\n+  { return TARGET_V9 ? \"flushw\" : \"ta\\t3\"; }\n+  [(set_attr \"type\" \"flushw\")])\n \n ;; Special pattern for the FLUSH instruction.\n "}, {"sha": "5e2b4d83dc5f8c53ab7e75d6a72a173d757c1b22", "filename": "gcc/cse.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc6d3f91a344f7ba4840fd41890076c62d2a538a/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc6d3f91a344f7ba4840fd41890076c62d2a538a/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=bc6d3f91a344f7ba4840fd41890076c62d2a538a", "patch": "@@ -1,7 +1,7 @@\n /* Common subexpression elimination for GNU compiler.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n-   Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n+   2011 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -6192,7 +6192,9 @@ cse_find_path (basic_block first_bb, struct cse_basic_block_data *data,\n \t  else\n \t    e = NULL;\n \n-\t  if (e && e->dest != EXIT_BLOCK_PTR\n+\t  if (e\n+\t      && (e->flags & EDGE_ABNORMAL) == 0\n+\t      && e->dest != EXIT_BLOCK_PTR\n \t      && single_pred_p (e->dest)\n \t      /* Avoid visiting basic blocks twice.  The large comment\n \t\t above explains why this can happen.  */"}, {"sha": "7387dad98df234ec27a13c4ffcfd019dbfd654cc", "filename": "gcc/explow.c", "status": "modified", "additions": 2, "deletions": 34, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc6d3f91a344f7ba4840fd41890076c62d2a538a/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc6d3f91a344f7ba4840fd41890076c62d2a538a/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=bc6d3f91a344f7ba4840fd41890076c62d2a538a", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines for manipulating rtx's in semantically interesting ways.\n-   Copyright (C) 1987, 1991, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   Copyright (C) 1987, 1991, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n+   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -1249,38 +1249,6 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,\n \tsize_align = extra_align;\n     }\n \n-#ifdef SETJMP_VIA_SAVE_AREA\n-  /* If setjmp restores regs from a save area in the stack frame,\n-     avoid clobbering the reg save area.  Note that the offset of\n-     virtual_incoming_args_rtx includes the preallocated stack args space.\n-     It would be no problem to clobber that, but it's on the wrong side\n-     of the old save area.\n-\n-     What used to happen is that, since we did not know for sure\n-     whether setjmp() was invoked until after RTL generation, we\n-     would use reg notes to store the \"optimized\" size and fix things\n-     up later.  These days we know this information before we ever\n-     start building RTL so the reg notes are unnecessary.  */\n-  if (cfun->calls_setjmp)\n-    {\n-      rtx dynamic_offset\n-\t= expand_binop (Pmode, sub_optab, virtual_stack_dynamic_rtx,\n-\t\t\tstack_pointer_rtx, NULL_RTX, 1, OPTAB_LIB_WIDEN);\n-\n-      size = expand_binop (Pmode, add_optab, size, dynamic_offset,\n-\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n-\n-      /* The above dynamic offset cannot be computed statically at this\n-\t point, but it will be possible to do so after RTL expansion is\n-\t done.  Record how many times we will need to add it.  */\n-      if (flag_stack_usage_info)\n-\tcurrent_function_dynamic_alloc_count++;\n-\n-      /* ??? Can we infer a minimum of STACK_BOUNDARY here?  */\n-      size_align = BITS_PER_UNIT;\n-    }\n-#endif /* SETJMP_VIA_SAVE_AREA */\n-\n   /* Round the size to a multiple of the required stack alignment.\n      Since the stack if presumed to be rounded before this allocation,\n      this will maintain the required alignment."}, {"sha": "30cc9ff2b4f9bb137743fb27d4644657f1dfa428", "filename": "gcc/function.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc6d3f91a344f7ba4840fd41890076c62d2a538a/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc6d3f91a344f7ba4840fd41890076c62d2a538a/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=bc6d3f91a344f7ba4840fd41890076c62d2a538a", "patch": "@@ -1937,17 +1937,6 @@ instantiate_virtual_regs (void)\n      frame_pointer_rtx.  */\n   virtuals_instantiated = 1;\n \n-  /* See allocate_dynamic_stack_space for the rationale.  */\n-#ifdef SETJMP_VIA_SAVE_AREA\n-  if (flag_stack_usage_info && cfun->calls_setjmp)\n-    {\n-      int align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;\n-      dynamic_offset = (dynamic_offset + align - 1) / align * align;\n-      current_function_dynamic_stack_size\n-\t+= current_function_dynamic_alloc_count * dynamic_offset;\n-    }\n-#endif\n-\n   return 0;\n }\n "}, {"sha": "3b572cc16a78fc6d5b1d79029382dffd7bfa50c8", "filename": "gcc/function.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc6d3f91a344f7ba4840fd41890076c62d2a538a/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc6d3f91a344f7ba4840fd41890076c62d2a538a/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=bc6d3f91a344f7ba4840fd41890076c62d2a538a", "patch": "@@ -1,6 +1,6 @@\n /* Structure for saving state for a nested function.\n    Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   1999, 2000, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -476,9 +476,6 @@ struct GTY(()) stack_usage\n      !ACCUMULATE_OUTGOING_ARGS, it contains the outgoing arguments.  */\n   int pushed_stack_size;\n \n-  /* # of dynamic allocations in the function.  */\n-  unsigned int dynamic_alloc_count : 31;\n-\n   /* Nonzero if the amount of stack space allocated dynamically cannot\n      be bounded at compile-time.  */\n   unsigned int has_unbounded_dynamic_stack_size : 1;\n@@ -487,7 +484,6 @@ struct GTY(()) stack_usage\n #define current_function_static_stack_size (cfun->su->static_stack_size)\n #define current_function_dynamic_stack_size (cfun->su->dynamic_stack_size)\n #define current_function_pushed_stack_size (cfun->su->pushed_stack_size)\n-#define current_function_dynamic_alloc_count (cfun->su->dynamic_alloc_count)\n #define current_function_has_unbounded_dynamic_stack_size \\\n   (cfun->su->has_unbounded_dynamic_stack_size)\n #define current_function_allocates_dynamic_stack_space    \\"}, {"sha": "0ee50d8122986b61d10560882c3e10b18a661aa9", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc6d3f91a344f7ba4840fd41890076c62d2a538a/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc6d3f91a344f7ba4840fd41890076c62d2a538a/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=bc6d3f91a344f7ba4840fd41890076c62d2a538a", "patch": "@@ -1,5 +1,5 @@\n /* Post reload partially redundant load elimination\n-   Copyright (C) 2004, 2005, 2006, 2007, 2008, 2010\n+   Copyright (C) 2004, 2005, 2006, 2007, 2008, 2010, 2011\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -912,10 +912,12 @@ get_avail_load_store_reg (rtx insn)\n static bool\n bb_has_well_behaved_predecessors (basic_block bb)\n {\n+  unsigned int edge_count = EDGE_COUNT (bb->preds);\n   edge pred;\n   edge_iterator ei;\n \n-  if (EDGE_COUNT (bb->preds) == 0)\n+  if (edge_count == 0\n+      || (edge_count == 1 && (single_pred_edge (bb)->flags & EDGE_ABNORMAL)))\n     return false;\n \n   FOR_EACH_EDGE (pred, ei, bb->preds)"}]}