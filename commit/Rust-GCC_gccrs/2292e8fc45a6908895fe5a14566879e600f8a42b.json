{"sha": "2292e8fc45a6908895fe5a14566879e600f8a42b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjI5MmU4ZmM0NWE2OTA4ODk1ZmU1YTE0NTY2ODc5ZTYwMGY4YTQyYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-05-11T00:32:01Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-05-11T00:32:01Z"}, "message": "final.c (end_final): Tidy whitespace.\n\n        * final.c (end_final): Tidy whitespace.  Don't honor flag_pack_struct.\n        Convert integers constants as needed.  Replace \"nwords\" field with\n        \"sizeof_bb\".\n        (final): Save profile data if cfun->arc_profile, not profile_arc_flag.\n        * function.h: Fix typo in comment.\n        * libgcc2.c (struct bb): Replace \"nwords\" with \"sizeof_bb\".\n\nFrom-SVN: r53374", "tree": {"sha": "2cb1f64448644304b80597457c575f4d16bb0144", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2cb1f64448644304b80597457c575f4d16bb0144"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2292e8fc45a6908895fe5a14566879e600f8a42b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2292e8fc45a6908895fe5a14566879e600f8a42b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2292e8fc45a6908895fe5a14566879e600f8a42b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2292e8fc45a6908895fe5a14566879e600f8a42b/comments", "author": null, "committer": null, "parents": [{"sha": "dbfb1116b34897645d29db19c7557348cd69d21b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbfb1116b34897645d29db19c7557348cd69d21b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbfb1116b34897645d29db19c7557348cd69d21b"}], "stats": {"total": 241, "additions": 120, "deletions": 121}, "files": [{"sha": "993063461cc5d4987816146e5a42f9d1edd4eb6c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2292e8fc45a6908895fe5a14566879e600f8a42b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2292e8fc45a6908895fe5a14566879e600f8a42b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2292e8fc45a6908895fe5a14566879e600f8a42b", "patch": "@@ -1,3 +1,12 @@\n+2002-05-10  Richard Henderson  <rth@redhat.com>\n+\n+\t* final.c (end_final): Tidy whitespace.  Don't honor flag_pack_struct.\n+\tConvert integers constants as needed.  Replace \"nwords\" field with\n+\t\"sizeof_bb\".\n+\t(final): Save profile data if cfun->arc_profile, not profile_arc_flag.\n+\t* function.h: Fix typo in comment.\n+\t* libgcc2.c (struct bb): Replace \"nwords\" with \"sizeof_bb\".\n+\n 2002-05-10  Roger Sayle  <roger@eyesopen.com>\n \n \t* fold-const.c (build_range_check): Optimize (c>=1) && (c<=127)"}, {"sha": "13e2aca11a1decdc8d21c588ebf9fb2b1a0b9a2b", "filename": "gcc/final.c", "status": "modified", "additions": 109, "deletions": 119, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2292e8fc45a6908895fe5a14566879e600f8a42b/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2292e8fc45a6908895fe5a14566879e600f8a42b/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=2292e8fc45a6908895fe5a14566879e600f8a42b", "patch": "@@ -258,14 +258,13 @@ end_final (filename)\n       tree string_type, string_cst;\n       tree structure_decl, structure_value, structure_pointer_type;\n       tree field_decl, decl_chain, value_chain;\n-      tree nwords_field_value, domain_type;\n+      tree sizeof_field_value, domain_type;\n \n       /* Build types.  */\n       string_type = build_pointer_type (char_type_node);\n \n       /* Libgcc2 bb structure.  */\n       structure_decl = make_node (RECORD_TYPE);\n-      TYPE_PACKED (structure_decl) = flag_pack_struct;\n       structure_pointer_type = build_pointer_type (structure_decl);\n \n       /* Output the main header, of 7 words:\n@@ -284,96 +283,103 @@ end_final (filename)\n       decl_chain =\n \tbuild_decl (FIELD_DECL, get_identifier (\"zero_word\"),\n \t\t    long_integer_type_node);\n-      value_chain = build_tree_list (decl_chain, integer_zero_node);\n+      value_chain = build_tree_list (decl_chain,\n+\t\t\t\t     convert (long_integer_type_node,\n+\t\t\t\t\t      integer_zero_node));\n \n       /* Address of filename.  */\n       {\n-\tchar *cwd = getpwd ();\n-\tint da_filename_len = strlen (filename) + strlen (cwd) + 4 + 1;\n-\tchar *da_filename = (char *) alloca (da_filename_len);\n+\tchar *cwd, *da_filename;\n+\tint da_filename_len;\n \n+\tfield_decl =\n+\t  build_decl (FIELD_DECL, get_identifier (\"filename\"), string_type);\n+\tTREE_CHAIN (field_decl) = decl_chain;\n+\tdecl_chain = field_decl;\n+\n+\tcwd = getpwd ();\n+\tda_filename_len = strlen (filename) + strlen (cwd) + 4 + 1;\n+\tda_filename = (char *) alloca (da_filename_len);\n \tstrcpy (da_filename, cwd);\n \tstrcat (da_filename, \"/\");\n \tstrcat (da_filename, filename);\n \tstrip_off_ending (da_filename, da_filename_len - 3);\n \tstrcat (da_filename, \".da\");\n-\tfield_decl =\n-\t  build_decl (FIELD_DECL, get_identifier (\"filename\"), string_type);\n-\tstring_cst = build_string (strlen (da_filename) + 1, da_filename);\n-\tdomain_type = build_index_type (build_int_2 (strlen (da_filename) + 1,\n-\t\t\t\t\t\t     0));\n-\tTREE_TYPE (string_cst) =\n-\t  build_array_type (char_type_node, domain_type);\n+\tda_filename_len = strlen (da_filename);\n+\tstring_cst = build_string (da_filename_len + 1, da_filename);\n+\tdomain_type = build_index_type (build_int_2 (da_filename_len, 0));\n+\tTREE_TYPE (string_cst)\n+\t  = build_array_type (char_type_node, domain_type);\n \tvalue_chain = tree_cons (field_decl,\n \t\t\t\t build1 (ADDR_EXPR, string_type, string_cst),\n \t\t\t\t value_chain);\n-\tTREE_CHAIN (field_decl) = decl_chain;\n-\tdecl_chain = field_decl;\n       }\n \n       /* Table of counts.  */\n       {\n \ttree gcov_type_type = make_unsigned_type (GCOV_TYPE_SIZE);\n \ttree gcov_type_pointer_type = build_pointer_type (gcov_type_type);\n-\ttree gcov_type_array_type, gcov_type_array_pointer_type;\n-\ttree domain_tree = build_index_type (build_int_2\n-\t\t\t\t\t     (profile_info.\n-\t\t\t\t\t      count_instrumented_edges - 1,\n-\t\t\t\t\t      0));\n+\ttree domain_tree\n+\t  = build_index_type (build_int_2 (profile_info.\n+\t\t\t\t\t   count_instrumented_edges - 1, 0));\n+\ttree gcov_type_array_type\n+\t  = build_array_type (gcov_type_type, domain_tree);\n+\ttree gcov_type_array_pointer_type\n+\t  = build_pointer_type (gcov_type_array_type);\n \ttree counts_table;\n \n-\tgcov_type_array_type = build_array_type (gcov_type_type, domain_tree);\n-\tgcov_type_array_pointer_type =\n-\t  build_pointer_type (gcov_type_array_type);\n+\tfield_decl =\n+\t  build_decl (FIELD_DECL, get_identifier (\"counts\"),\n+\t\t      gcov_type_pointer_type);\n+\tTREE_CHAIN (field_decl) = decl_chain;\n+\tdecl_chain = field_decl;\n \n \t/* No values.  */\n-\tcounts_table =\n-\t  build (VAR_DECL, gcov_type_array_type, NULL_TREE, NULL_TREE);\n+\tcounts_table\n+\t  = build (VAR_DECL, gcov_type_array_type, NULL_TREE, NULL_TREE);\n \tTREE_STATIC (counts_table) = 1;\n \tASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 2);\n \tDECL_NAME (counts_table) = get_identifier (name);\n \tassemble_variable (counts_table, 0, 0, 0);\n \n-\tfield_decl =\n-\t  build_decl (FIELD_DECL, get_identifier (\"counts\"),\n-\t\t      gcov_type_pointer_type);\n \tvalue_chain = tree_cons (field_decl,\n \t\t\t\t build1 (ADDR_EXPR,\n \t\t\t\t\t gcov_type_array_pointer_type,\n \t\t\t\t\t counts_table), value_chain);\n-\tTREE_CHAIN (field_decl) = decl_chain;\n-\tdecl_chain = field_decl;\n       }\n \n       /* Count of the # of instrumented arcs.  */\n-      field_decl =\n-\tbuild_decl (FIELD_DECL, get_identifier (\"ncounts\"),\n-\t\t    long_integer_type_node);\n+      field_decl\n+\t= build_decl (FIELD_DECL, get_identifier (\"ncounts\"),\n+\t\t      long_integer_type_node);\n+      TREE_CHAIN (field_decl) = decl_chain;\n+      decl_chain = field_decl;\n+\n       value_chain = tree_cons (field_decl,\n \t\t\t       convert (long_integer_type_node,\n \t\t\t\t\tbuild_int_2 (profile_info.\n \t\t\t\t\t\t     count_instrumented_edges,\n \t\t\t\t\t\t     0)), value_chain);\n+      /* Pointer to the next bb.  */\n+      field_decl\n+\t= build_decl (FIELD_DECL, get_identifier (\"next\"),\n+\t\t      structure_pointer_type);\n       TREE_CHAIN (field_decl) = decl_chain;\n       decl_chain = field_decl;\n \n-      /* Pointer to the next bb.  */\n-      field_decl =\n-\tbuild_decl (FIELD_DECL, get_identifier (\"next\"),\n-\t\t    structure_pointer_type);\n       value_chain = tree_cons (field_decl, null_pointer_node, value_chain);\n-      TREE_CHAIN (field_decl) = decl_chain;\n-      decl_chain = field_decl;\n \n-      /* Number of words. We'll set this after entire structure is laid out.  */\n-      field_decl =\n-\tbuild_decl (FIELD_DECL, get_identifier (\"nwords\"),\n-\t\t    long_integer_type_node);\n-      value_chain = nwords_field_value =\n-\ttree_cons (field_decl, NULL, value_chain);\n+      /* sizeof(struct bb).  We'll set this after entire structure\n+\t is laid out.  */\n+      field_decl\n+\t= build_decl (FIELD_DECL, get_identifier (\"sizeof_bb\"),\n+\t\t      long_integer_type_node);\n       TREE_CHAIN (field_decl) = decl_chain;\n       decl_chain = field_decl;\n \n+      sizeof_field_value = tree_cons (field_decl, NULL, value_chain);\n+      value_chain = sizeof_field_value;\n+\n       /* struct bb_function [].  */\n       {\n \tstruct function_list *item;\n@@ -388,16 +394,17 @@ end_final (filename)\n \ttree field_value, field_value_chain;\n \n \tbb_fn_struct_type = make_node (RECORD_TYPE);\n-\tTYPE_PACKED (bb_fn_struct_type) = flag_pack_struct;\n \n \tchecksum_field = build_decl (FIELD_DECL, get_identifier (\"checksum\"),\n \t\t\t\t     long_integer_type_node);\n-\tarc_count_field =\n-\t  build_decl (FIELD_DECL, get_identifier (\"arc_count\"),\n-\t\t      integer_type_node);\n+\n+\tarc_count_field\n+\t  = build_decl (FIELD_DECL, get_identifier (\"arc_count\"),\n+\t\t        integer_type_node);\n \tTREE_CHAIN (checksum_field) = arc_count_field;\n-\tname_field =\n-\t  build_decl (FIELD_DECL, get_identifier (\"name\"), string_type);\n+\n+\tname_field\n+\t  = build_decl (FIELD_DECL, get_identifier (\"name\"), string_type);\n \tTREE_CHAIN (arc_count_field) = name_field;\n \n \tTYPE_FIELDS (bb_fn_struct_type) = checksum_field;\n@@ -411,10 +418,10 @@ end_final (filename)\n \tdomain = build_index_type (build_int_2 (num_nodes, 0));\n \n \tbb_fn_struct_pointer_type = build_pointer_type (bb_fn_struct_type);\n-\tbb_fn_struct_array_type = build_array_type (bb_fn_struct_type,\n-\t\t\t\t\t\t    domain);\n-\tbb_fn_struct_array_pointer_type =\n-\t  build_pointer_type (bb_fn_struct_array_type);\n+\tbb_fn_struct_array_type\n+\t  = build_array_type (bb_fn_struct_type, domain);\n+\tbb_fn_struct_array_pointer_type\n+\t  = build_pointer_type (bb_fn_struct_array_type);\n \n \tlayout_type (bb_fn_struct_type);\n \tlayout_type (bb_fn_struct_pointer_type);\n@@ -423,38 +430,35 @@ end_final (filename)\n \n \tfor (item = functions_head; item != 0; item = item->next)\n \t  {\n+\t    size_t name_len;\n+\n \t    /* create constructor for structure.  */\n-\t    field_value_chain = build_tree_list (checksum_field,\n-\t\t\t\t\t\t convert\n-\t\t\t\t\t\t (long_integer_type_node,\n-\t\t\t\t\t\t  build_int_2 (item->\n-\t\t\t\t\t\t\t       cfg_checksum,\n-\t\t\t\t\t\t\t       0)));\n-\t    field_value_chain =\n-\t      tree_cons (arc_count_field,\n-\t\t\t convert (integer_type_node,\n-\t\t\t\t  build_int_2 (item->count_edges, 0)),\n-\t\t\t field_value_chain);\n-\n-\t    string_cst = build_string (strlen (item->name) + 1, item->name);\n-\t    domain_type = build_index_type (build_int_2 (strlen (item->name) +\n-\t\t\t\t\t\t\t 1, 0));\n-\t    TREE_TYPE (string_cst) = build_array_type (char_type_node,\n-\t\t\t\t\t\t       domain_type);\n+\t    field_value_chain\n+\t      = build_tree_list (checksum_field,\n+\t\t\t\t convert (long_integer_type_node,\n+\t\t\t\t\t  build_int_2 (item->cfg_checksum, 0)));\n+\t    field_value_chain\n+\t      = tree_cons (arc_count_field,\n+\t\t\t   convert (integer_type_node,\n+\t\t\t\t    build_int_2 (item->count_edges, 0)),\n+\t\t\t   field_value_chain);\n+\n+\t    name_len = strlen (item->name);\n+\t    string_cst = build_string (name_len + 1, item->name);\n+\t    domain_type = build_index_type (build_int_2 (name_len, 0));\n+\t    TREE_TYPE (string_cst)\n+\t      = build_array_type (char_type_node, domain_type);\n \t    field_value_chain = tree_cons (name_field,\n \t\t\t\t\t   build1 (ADDR_EXPR, string_type,\n \t\t\t\t\t\t   string_cst),\n \t\t\t\t\t   field_value_chain);\n \n \t    /* Add to chain.  */\n-\n-\t    array_value_chain = tree_cons (NULL_TREE,\n-\t\t\t\t\t   build (CONSTRUCTOR,\n-\t\t\t\t\t\t  bb_fn_struct_type,\n-\t\t\t\t\t\t  NULL_TREE,\n-\t\t\t\t\t\t  nreverse\n-\t\t\t\t\t\t  (field_value_chain)),\n-\t\t\t\t\t   array_value_chain);\n+\t    array_value_chain\n+\t      = tree_cons (NULL_TREE, build (CONSTRUCTOR,\n+\t\t\t\t\t     bb_fn_struct_type, NULL_TREE,\n+\t\t\t\t\t     nreverse (field_value_chain)),\n+\t\t\t   array_value_chain);\n \t  }\n \n \t/* Add terminator.  */\n@@ -469,10 +473,9 @@ end_final (filename)\n \n \n \t/* Create constructor for array.  */\n-\n-\tfield_decl =\n-\t  build_decl (FIELD_DECL, get_identifier (\"function_infos\"),\n-\t\t      bb_fn_struct_pointer_type);\n+\tfield_decl\n+\t  = build_decl (FIELD_DECL, get_identifier (\"function_infos\"),\n+\t\t        bb_fn_struct_pointer_type);\n \tvalue_chain = tree_cons (field_decl,\n \t\t\t\t build1 (ADDR_EXPR,\n \t\t\t\t\t bb_fn_struct_array_pointer_type,\n@@ -486,37 +489,26 @@ end_final (filename)\n \tdecl_chain = field_decl;\n       }\n \n-\n       /* Finish structure.  */\n       TYPE_FIELDS (structure_decl) = nreverse (decl_chain);\n       layout_type (structure_decl);\n \n-      structure_value =\n-\tbuild (VAR_DECL, structure_decl, NULL_TREE, NULL_TREE);\n-      DECL_INITIAL (structure_value) =\n-\tbuild (CONSTRUCTOR, structure_decl, NULL_TREE,\n-\t       nreverse (value_chain));\n+      structure_value\n+\t= build (VAR_DECL, structure_decl, NULL_TREE, NULL_TREE);\n+      DECL_INITIAL (structure_value)\n+\t= build (CONSTRUCTOR, structure_decl, NULL_TREE,\n+\t         nreverse (value_chain));\n       TREE_STATIC (structure_value) = 1;\n       ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 0);\n       DECL_NAME (structure_value) = get_identifier (name);\n \n-      /* Set number of words in this structure. */\n-      TREE_VALUE (nwords_field_value) =\n-\tbuild_int_2 (TREE_INT_CST_LOW (TYPE_SIZE_UNIT (structure_decl)) /\n-\t\t     (INT_TYPE_SIZE / BITS_PER_UNIT), 0);\n+      /* Size of this structure. */\n+      TREE_VALUE (sizeof_field_value)\n+\t= convert (long_integer_type_node,\n+\t\t   build_int_2 (int_size_in_bytes (structure_decl), 0));\n \n       /* Build structure.  */\n       assemble_variable (structure_value, 0, 0, 0);\n-\n-      /* Offset to table of arc counters for thread-safe profiling.  */\n-      {\n-\ttree table_offset_var = make_node (VAR_DECL);\n-\tTREE_TYPE (table_offset_var) = build_pointer_type (integer_type_node);\n-\tDECL_INITIAL (table_offset_var) = integer_zero_node;\n-\tDECL_NAME (table_offset_var) = get_identifier (\".LPBF0\");\n-\tTREE_STATIC (table_offset_var) = 1;\n-\tassemble_variable (table_offset_var, 0, 0, 0);\n-      }\n     }\n }\n \n@@ -1931,22 +1923,20 @@ final (first, file, optimize, prescan)\n     }\n \n   /* Store function names for edge-profiling.  */\n+  /* ??? Probably should re-use the existing struct function.  */\n \n-  if (profile_arc_flag)\n-  {\n-    struct function_list *new_item = xmalloc (sizeof (struct function_list));\n-\n-    /* Add function to linked list.  */\n-    new_item->next = 0;\n-    *functions_tail = new_item;\n-    functions_tail = &new_item->next;\n-\n-    /* Set values.  */\n-    new_item->cfg_checksum = profile_info.current_function_cfg_checksum;\n-    new_item->count_edges = profile_info.count_edges_instrumented_now;\n-    new_item->name = xstrdup (current_function_name);\n-    \n-  }\n+  if (cfun->arc_profile)\n+    {\n+      struct function_list *new_item = xmalloc (sizeof (struct function_list));\n+\n+      *functions_tail = new_item;\n+      functions_tail = &new_item->next;\n+\n+      new_item->next = 0;\n+      new_item->name = xstrdup (current_function_name);\n+      new_item->cfg_checksum = profile_info.current_function_cfg_checksum;\n+      new_item->count_edges = profile_info.count_edges_instrumented_now;\n+    }\n   \n   free (line_note_exists);\n   line_note_exists = NULL;"}, {"sha": "bc789c8181a85ba813459655c2886a3b3368fd39", "filename": "gcc/function.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2292e8fc45a6908895fe5a14566879e600f8a42b/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2292e8fc45a6908895fe5a14566879e600f8a42b/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=2292e8fc45a6908895fe5a14566879e600f8a42b", "patch": "@@ -437,7 +437,7 @@ struct function\n      generated.  */\n   unsigned int instrument_entry_exit : 1;\n \n-  /* Nonzero if no profiling should be done for the function.  */\n+  /* Nonzero if arc profiling should be done for the function.  */\n   unsigned int arc_profile : 1;\n \n   /* Nonzero if profiling code should be generated.  */"}, {"sha": "80710e2623ae960fa1b500cf352620d52fa61a5f", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2292e8fc45a6908895fe5a14566879e600f8a42b/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2292e8fc45a6908895fe5a14566879e600f8a42b/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=2292e8fc45a6908895fe5a14566879e600f8a42b", "patch": "@@ -1254,7 +1254,7 @@ struct bb\n   struct bb *next;\n \n   /* Older GCC's did not emit these fields.  */\n-  long nwords;\n+  long sizeof_bb;\n   struct bb_function_info *function_infos;\n };\n "}]}