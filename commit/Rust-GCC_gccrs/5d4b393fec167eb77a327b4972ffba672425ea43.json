{"sha": "5d4b393fec167eb77a327b4972ffba672425ea43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ0YjM5M2ZlYzE2N2ViNzdhMzI3YjQ5NzJmZmJhNjcyNDI1ZWE0Mw==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2010-06-12T00:12:12Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2010-06-12T00:12:12Z"}, "message": "opts-common.c: Include options.h.\n\n\t* opts-common.c: Include options.h.\n\t(integral_argument): Move from opts.c.\n\t(decode_cmdline_option): New.  Based on read_cmdline_option.\n\t* opts.c (integral_argument): Move to opts-common.c.\n\t(read_cmdline_option): Move most contents to\n\tdecode_cmdline_option.  Use %qs in diagnostics.\n\t* opts.h (CL_ERR_DISABLED, CL_ERR_MISSING_ARG, CL_ERR_WRONG_LANG,\n\tCL_ERR_UINT_ARG, struct cl_decoded_option, integral_argument,\n\tdecode_cmdline_option): New.\n\ntestsuite:\n\t* gcc.dg/funroll-loops-all.c: Update expected error.\n\nFrom-SVN: r160639", "tree": {"sha": "50451f0ea94bd6c134f87ada11def37b34fdd724", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50451f0ea94bd6c134f87ada11def37b34fdd724"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d4b393fec167eb77a327b4972ffba672425ea43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d4b393fec167eb77a327b4972ffba672425ea43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d4b393fec167eb77a327b4972ffba672425ea43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d4b393fec167eb77a327b4972ffba672425ea43/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b79a08f6c4b57f701b6a879365b5506003cefba7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b79a08f6c4b57f701b6a879365b5506003cefba7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b79a08f6c4b57f701b6a879365b5506003cefba7"}], "stats": {"total": 329, "additions": 209, "deletions": 120}, "files": [{"sha": "a2e6acecd157e252650f62592d11bf50b102407d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d4b393fec167eb77a327b4972ffba672425ea43/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d4b393fec167eb77a327b4972ffba672425ea43/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d4b393fec167eb77a327b4972ffba672425ea43", "patch": "@@ -1,3 +1,15 @@\n+2010-06-11  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* opts-common.c: Include options.h.\n+\t(integral_argument): Move from opts.c.\n+\t(decode_cmdline_option): New.  Based on read_cmdline_option.\n+\t* opts.c (integral_argument): Move to opts-common.c.\n+\t(read_cmdline_option): Move most contents to\n+\tdecode_cmdline_option.  Use %qs in diagnostics.\n+\t* opts.h (CL_ERR_DISABLED, CL_ERR_MISSING_ARG, CL_ERR_WRONG_LANG,\n+\tCL_ERR_UINT_ARG, struct cl_decoded_option, integral_argument,\n+\tdecode_cmdline_option): New.\n+\n 2010-06-11  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/44481"}, {"sha": "513a766e520da221be38f845977a863ca5ce99c1", "filename": "gcc/opts-common.c", "status": "modified", "additions": 134, "deletions": 1, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d4b393fec167eb77a327b4972ffba672425ea43/gcc%2Fopts-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d4b393fec167eb77a327b4972ffba672425ea43/gcc%2Fopts-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts-common.c?ref=5d4b393fec167eb77a327b4972ffba672425ea43", "patch": "@@ -1,5 +1,5 @@\n /* Command line option handling.\n-   Copyright (C) 2006, 2007, 2008 Free Software Foundation, Inc.\n+   Copyright (C) 2006, 2007, 2008, 2010 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"intl.h\"\n #include \"coretypes.h\"\n #include \"opts.h\"\n+#include \"options.h\"\n \n /* Perform a binary search to find which option the command-line INPUT\n    matches.  Returns its index in the option array, and N_OPTS\n@@ -107,6 +108,138 @@ find_opt (const char *input, int lang_mask)\n   return match_wrong_lang;\n }\n \n+/* If ARG is a non-negative integer made up solely of digits, return its\n+   value, otherwise return -1.  */\n+\n+int\n+integral_argument (const char *arg)\n+{\n+  const char *p = arg;\n+\n+  while (*p && ISDIGIT (*p))\n+    p++;\n+\n+  if (*p == '\\0')\n+    return atoi (arg);\n+\n+  return -1;\n+}\n+\n+/* Decode the switch beginning at ARGV for the language indicated by\n+   LANG_MASK, into the structure *DECODED.  Returns the number of\n+   switches consumed.  */\n+\n+unsigned int\n+decode_cmdline_option (const char **argv, unsigned int lang_mask,\n+\t\t       struct cl_decoded_option *decoded)\n+{\n+  size_t opt_index;\n+  const char *opt, *arg = 0;\n+  char *dup = 0;\n+  int value = 1;\n+  unsigned int result = 1;\n+  const struct cl_option *option;\n+  int errors = 0;\n+\n+  opt = argv[0];\n+\n+  opt_index = find_opt (opt + 1, lang_mask | CL_COMMON | CL_TARGET);\n+  if (opt_index == cl_options_count\n+      && (opt[1] == 'W' || opt[1] == 'f' || opt[1] == 'm')\n+      && opt[2] == 'n' && opt[3] == 'o' && opt[4] == '-')\n+    {\n+      /* Drop the \"no-\" from negative switches.  */\n+      size_t len = strlen (opt) - 3;\n+\n+      dup = XNEWVEC (char, len + 1);\n+      dup[0] = '-';\n+      dup[1] = opt[1];\n+      memcpy (dup + 2, opt + 5, len - 2 + 1);\n+      opt = dup;\n+      value = 0;\n+      opt_index = find_opt (opt + 1, lang_mask | CL_COMMON | CL_TARGET);\n+    }\n+\n+  if (opt_index == cl_options_count)\n+    goto done;\n+\n+  option = &cl_options[opt_index];\n+\n+  /* Reject negative form of switches that don't take negatives as\n+     unrecognized.  */\n+  if (!value && (option->flags & CL_REJECT_NEGATIVE))\n+    {\n+      opt_index = cl_options_count;\n+      goto done;\n+    }\n+\n+  /* Check to see if the option is disabled for this configuration.  */\n+  if (option->flags & CL_DISABLED)\n+    errors |= CL_ERR_DISABLED;\n+\n+  /* Sort out any argument the switch takes.  */\n+  if (option->flags & CL_JOINED)\n+    {\n+      /* Have arg point to the original switch.  This is because\n+\t some code, such as disable_builtin_function, expects its\n+\t argument to be persistent until the program exits.  */\n+      arg = argv[0] + cl_options[opt_index].opt_len + 1;\n+      if (!value)\n+\targ += strlen (\"no-\");\n+\n+      if (*arg == '\\0' && !(option->flags & CL_MISSING_OK))\n+\t{\n+\t  if (option->flags & CL_SEPARATE)\n+\t    {\n+\t      arg = argv[1];\n+\t      result = 2;\n+\t      if (arg == NULL)\n+\t\tresult = 1;\n+\t    }\n+\t  else\n+\t    /* Missing argument.  */\n+\t    arg = NULL;\n+\t}\n+    }\n+  else if (option->flags & CL_SEPARATE)\n+    {\n+      arg = argv[1];\n+      result = 2;\n+      if (arg == NULL)\n+\tresult = 1;\n+    }\n+\n+  /* Check if this is a switch for a different front end.  */\n+  if (!(option->flags & (lang_mask | CL_COMMON | CL_TARGET)))\n+    errors |= CL_ERR_WRONG_LANG;\n+  else if ((option->flags & CL_TARGET)\n+\t   && (option->flags & CL_LANG_ALL)\n+\t   && !(option->flags & lang_mask))\n+    /* Complain for target flag language mismatches if any languages\n+       are specified.  */\n+      errors |= CL_ERR_WRONG_LANG;\n+\n+  if (arg == NULL && (option->flags & (CL_JOINED | CL_SEPARATE)))\n+    errors |= CL_ERR_MISSING_ARG;\n+\n+  /* If the switch takes an integer, convert it.  */\n+  if (arg && (option->flags & CL_UINTEGER))\n+    {\n+      value = integral_argument (arg);\n+      if (value == -1)\n+\terrors |= CL_ERR_UINT_ARG;\n+    }\n+\n+ done:\n+  if (dup)\n+    free (dup);\n+  decoded->opt_index = opt_index;\n+  decoded->arg = arg;\n+  decoded->value = value;\n+  decoded->errors = errors;\n+  return result;\n+}\n+\n /* Return true if NEXT_OPT_IDX cancels OPT_IDX.  Return false if the\n    next one is the same as ORIG_NEXT_OPT_IDX.  */\n "}, {"sha": "d5fe326bced1ecd83219a10ba3861e4561e5afec", "filename": "gcc/opts.c", "status": "modified", "additions": 25, "deletions": 117, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d4b393fec167eb77a327b4972ffba672425ea43/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d4b393fec167eb77a327b4972ffba672425ea43/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=5d4b393fec167eb77a327b4972ffba672425ea43", "patch": "@@ -381,22 +381,6 @@ static void complain_wrong_lang (const char *, const struct cl_option *,\n static void set_debug_level (enum debug_info_type type, int extended,\n \t\t\t     const char *arg);\n \n-/* If ARG is a non-negative integer made up solely of digits, return its\n-   value, otherwise return -1.  */\n-static int\n-integral_argument (const char *arg)\n-{\n-  const char *p = arg;\n-\n-  while (*p && ISDIGIT (*p))\n-    p++;\n-\n-  if (*p == '\\0')\n-    return atoi (arg);\n-\n-  return -1;\n-}\n-\n /* Return a malloced slash-separated list of languages in MASK.  */\n static char *\n write_langs (unsigned int mask)\n@@ -536,131 +520,61 @@ handle_option (int opt_index, int value, const char *arg,\n static unsigned int\n read_cmdline_option (const char **argv, unsigned int lang_mask)\n {\n-  size_t opt_index;\n-  const char *opt, *arg = 0;\n-  char *dup = 0;\n-  int value = 1;\n-  unsigned int result = 0;\n+  struct cl_decoded_option decoded;\n+  unsigned int result;\n+  const char *opt;\n   const struct cl_option *option;\n \n   opt = argv[0];\n \n-  opt_index = find_opt (opt + 1, lang_mask | CL_COMMON | CL_TARGET);\n-  if (opt_index == cl_options_count\n-      && (opt[1] == 'W' || opt[1] == 'f' || opt[1] == 'm')\n-      && opt[2] == 'n' && opt[3] == 'o' && opt[4] == '-')\n+  result = decode_cmdline_option (argv, lang_mask, &decoded);\n+  if (decoded.opt_index == cl_options_count)\n     {\n-      /* Drop the \"no-\" from negative switches.  */\n-      size_t len = strlen (opt) - 3;\n-\n-      dup = XNEWVEC (char, len + 1);\n-      dup[0] = '-';\n-      dup[1] = opt[1];\n-      memcpy (dup + 2, opt + 5, len - 2 + 1);\n-      opt = dup;\n-      value = 0;\n-      opt_index = find_opt (opt + 1, lang_mask | CL_COMMON | CL_TARGET);\n-      if (opt_index == cl_options_count && opt[1] == 'W')\n-\t{\n-\t  /* We don't generate warnings for unknown -Wno-* options\n-             unless we issue diagnostics.  */\n+      if (opt[1] == 'W' && opt[2] == 'n' && opt[3] == 'o' && opt[4] == '-')\n+\t/* We don't generate warnings for unknown -Wno-* options\n+\t   unless we issue diagnostics.  */\n \t  postpone_unknown_option_warning (argv[0]);\n-\t  result = 1;\n-\t  goto done;\n-\t}\n+      else\n+\terror (\"unrecognized command line option %qs\", opt);\n+      return result;\n     }\n \n-  if (opt_index == cl_options_count)\n-    goto done;\n-\n-  option = &cl_options[opt_index];\n-\n-  /* Reject negative form of switches that don't take negatives as\n-     unrecognized.  */\n-  if (!value && (option->flags & CL_REJECT_NEGATIVE))\n-    goto done;\n-\n-  /* We've recognized this switch.  */\n-  result = 1;\n+  option = &cl_options[decoded.opt_index];\n \n-  /* Check to see if the option is disabled for this configuration.  */\n-  if (option->flags & CL_DISABLED)\n+  if (decoded.errors & CL_ERR_DISABLED)\n     {\n       error (\"command line option %qs\"\n \t     \" is not supported by this configuration\", opt);\n       goto done;\n     }\n \n-  /* Sort out any argument the switch takes.  */\n-  if (option->flags & CL_JOINED)\n-    {\n-      /* Have arg point to the original switch.  This is because\n-\t some code, such as disable_builtin_function, expects its\n-\t argument to be persistent until the program exits.  */\n-      arg = argv[0] + cl_options[opt_index].opt_len + 1;\n-      if (!value)\n-\targ += strlen (\"no-\");\n-\n-      if (*arg == '\\0' && !(option->flags & CL_MISSING_OK))\n-\t{\n-\t  if (option->flags & CL_SEPARATE)\n-\t    {\n-\t      arg = argv[1];\n-\t      result = 2;\n-\t    }\n-\t  else\n-\t    /* Missing argument.  */\n-\t    arg = NULL;\n-\t}\n-    }\n-  else if (option->flags & CL_SEPARATE)\n-    {\n-      arg = argv[1];\n-      result = 2;\n-    }\n-\n-  /* Now we've swallowed any potential argument, complain if this\n-     is a switch for a different front end.  */\n-  if (!(option->flags & (lang_mask | CL_COMMON | CL_TARGET)))\n+  if (decoded.errors & CL_ERR_WRONG_LANG)\n     {\n       complain_wrong_lang (argv[0], option, lang_mask);\n       goto done;\n     }\n-  else if ((option->flags & CL_TARGET)\n-\t   && (option->flags & CL_LANG_ALL)\n-\t   && !(option->flags & lang_mask))\n+\n+  if (decoded.errors & CL_ERR_MISSING_ARG)\n     {\n-      /* Complain for target flag language mismatches if any languages\n-\t are specified.  */\n-      complain_wrong_lang (argv[0], option, lang_mask);\n+      if (!lang_hooks.missing_argument (opt, decoded.opt_index))\n+\terror (\"missing argument to %qs\", opt);\n       goto done;\n     }\n \n-  if (arg == NULL && (option->flags & (CL_JOINED | CL_SEPARATE)))\n+  if (decoded.errors & CL_ERR_UINT_ARG)\n     {\n-      if (!lang_hooks.missing_argument (opt, opt_index))\n-\terror (\"missing argument to \\\"%s\\\"\", opt);\n+      error (\"argument to %qs should be a non-negative integer\",\n+\t     option->opt_text);\n       goto done;\n     }\n \n-  /* If the switch takes an integer, convert it.  */\n-  if (arg && (option->flags & CL_UINTEGER))\n-    {\n-      value = integral_argument (arg);\n-      if (value == -1)\n-\t{\n-\t  error (\"argument to \\\"%s\\\" should be a non-negative integer\",\n-\t\t option->opt_text);\n-\t  goto done;\n-\t}\n-    }\n+  gcc_assert (!decoded.errors);\n \n-  if (!handle_option (opt_index, value, arg, lang_mask, DK_UNSPECIFIED))\n-    result = 0;\n+  if (!handle_option (decoded.opt_index, decoded.value, decoded.arg,\n+\t\t      lang_mask, DK_UNSPECIFIED))\n+    error (\"unrecognized command line option %qs\", opt);\n \n  done:\n-  if (dup)\n-    free (dup);\n   return result;\n }\n \n@@ -780,12 +694,6 @@ read_cmdline_options (unsigned int argc, const char **argv, unsigned int lang_ma\n \t}\n \n       n = read_cmdline_option (argv + i, lang_mask);\n-\n-      if (!n)\n-\t{\n-\t  n = 1;\n-\t  error (\"unrecognized command line option \\\"%s\\\"\", opt);\n-\t}\n     }\n }\n "}, {"sha": "c50cbca1c1e648eb2608dfaded658354997b1cc9", "filename": "gcc/opts.h", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d4b393fec167eb77a327b4972ffba672425ea43/gcc%2Fopts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d4b393fec167eb77a327b4972ffba672425ea43/gcc%2Fopts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.h?ref=5d4b393fec167eb77a327b4972ffba672425ea43", "patch": "@@ -1,5 +1,5 @@\n /* Command line option handling.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008\n+   Copyright (C) 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -90,6 +90,34 @@ extern const unsigned int cl_lang_count;\n #define CL_UINTEGER\t\t(1 << 29) /* Argument is an integer >=0.  */\n #define CL_UNDOCUMENTED\t\t(1 << 30) /* Do not output with --help.  */\n \n+/* Possible ways in which a command-line option may be erroneous.\n+   These do not include not being known at all; an option index of\n+   cl_options_count is used for that.  */\n+\n+#define CL_ERR_DISABLED\t\t(1 << 0) /* Disabled in this configuration.  */\n+#define CL_ERR_MISSING_ARG\t(1 << 1) /* Argument required but missing.  */\n+#define CL_ERR_WRONG_LANG\t(1 << 2) /* Option for wrong language.  */\n+#define CL_ERR_UINT_ARG\t\t(1 << 3) /* Bad unsigned integer argument.  */\n+\n+/* Structure describing the result of decoding an option.  */\n+\n+struct cl_decoded_option\n+{\n+  /* The index of this option, or cl_options_count if not known.  */\n+  size_t opt_index;\n+\n+  /* The string argument, or NULL if none.  */\n+  const char *arg;\n+\n+  /* For a boolean option, 1 for the true case and 0 for the \"no-\"\n+     case.  For an unsigned integer option, the value of the\n+     argument.  1 in all other cases.  */\n+  int value;\n+\n+  /* Any flags describing errors detected in this option.  */\n+  int errors;\n+};\n+\n /* Input file names.  */\n \n extern const char **in_fnames;\n@@ -99,6 +127,10 @@ extern const char **in_fnames;\n extern unsigned num_in_fnames;\n \n size_t find_opt (const char *input, int lang_mask);\n+extern int integral_argument (const char *arg);\n+extern unsigned int decode_cmdline_option (const char **argv,\n+\t\t\t\t\t   unsigned int lang_mask,\n+\t\t\t\t\t   struct cl_decoded_option *decoded);\n extern void prune_options (int *argcp, char ***argvp);\n extern void decode_options (unsigned int argc, const char **argv);\n extern int option_enabled (int opt_idx);"}, {"sha": "b6d4be9b5e223ac82f95f92f04131da6850089f0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d4b393fec167eb77a327b4972ffba672425ea43/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d4b393fec167eb77a327b4972ffba672425ea43/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5d4b393fec167eb77a327b4972ffba672425ea43", "patch": "@@ -1,3 +1,7 @@\n+2010-06-11  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* gcc.dg/funroll-loops-all.c: Update expected error.\n+\n 2010-06-11  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/44481"}, {"sha": "9cdc90172557e18ac2d206a65274919e1fbd1939", "filename": "gcc/testsuite/gcc.dg/funroll-loops-all.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d4b393fec167eb77a327b4972ffba672425ea43/gcc%2Ftestsuite%2Fgcc.dg%2Ffunroll-loops-all.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d4b393fec167eb77a327b4972ffba672425ea43/gcc%2Ftestsuite%2Fgcc.dg%2Ffunroll-loops-all.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffunroll-loops-all.c?ref=5d4b393fec167eb77a327b4972ffba672425ea43", "patch": "@@ -1,4 +1,4 @@\n /* PR 17594 */\n /* { dg-do compile } */\n /* { dg-options \"-funroll-loops-all\" } */\n-/* { dg-error \"unrecognized command line option \\\"-funroll-loops-all\\\"\" \"\" { target *-*-* } 0 } */\n+/* { dg-error \"unrecognized command line option '-funroll-loops-all'\" \"\" { target *-*-* } 0 } */"}]}