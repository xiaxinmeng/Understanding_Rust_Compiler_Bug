{"sha": "10ee5386adadefebd247c7e4870c666f2c9b359d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBlZTUzODZhZGFkZWZlYmQyNDdjN2U0ODcwYzY2NmYyYzliMzU5ZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2008-07-31T17:38:08Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2008-07-31T17:38:08Z"}, "message": "re PR middle-end/36633 (warning \"array subscript is below array bounds\" on delete [] with -O2, -Wall)\n\n        PR c++/36633\n        * init.c (build_new_1): Don't convert pointer to the data type\n        until we're actually going to treat it as that type.\n\nFrom-SVN: r138425", "tree": {"sha": "8faf9acdedf5f85f81f9b4f164dc21693c231eb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8faf9acdedf5f85f81f9b4f164dc21693c231eb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10ee5386adadefebd247c7e4870c666f2c9b359d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10ee5386adadefebd247c7e4870c666f2c9b359d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10ee5386adadefebd247c7e4870c666f2c9b359d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10ee5386adadefebd247c7e4870c666f2c9b359d/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fc74cbc4bd40b9f1b0f58abff1fb9efecb5b1d49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc74cbc4bd40b9f1b0f58abff1fb9efecb5b1d49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc74cbc4bd40b9f1b0f58abff1fb9efecb5b1d49"}], "stats": {"total": 86, "additions": 68, "deletions": 18}, "files": [{"sha": "db536e4d9d3097b9d23b92f55b74b2ff77028fe0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10ee5386adadefebd247c7e4870c666f2c9b359d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10ee5386adadefebd247c7e4870c666f2c9b359d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=10ee5386adadefebd247c7e4870c666f2c9b359d", "patch": "@@ -1,5 +1,9 @@\n 2008-07-31  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/36633\n+\t* init.c (build_new_1): Don't convert pointer to the data type\n+\tuntil we're actually going to treat it as that type.\n+\n \tPR c++/11309\n \t* tree.c (build_aggr_init_expr): Split out...\n \t(build_cplus_new): ...from here."}, {"sha": "c6d63b8409695269b0fa40ee8dc73fbcc05f9c56", "filename": "gcc/cp/init.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10ee5386adadefebd247c7e4870c666f2c9b359d/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10ee5386adadefebd247c7e4870c666f2c9b359d/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=10ee5386adadefebd247c7e4870c666f2c9b359d", "patch": "@@ -2055,11 +2055,9 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n       return rval;\n     }\n \n-  /* While we're working, use a pointer to the type we've actually\n-     allocated. Store the result of the call in a variable so that we\n-     can use it more than once.  */\n-  full_pointer_type = build_pointer_type (full_type);\n-  alloc_expr = get_target_expr (build_nop (full_pointer_type, alloc_call));\n+  /* Store the result of the allocation call in a variable so that we can\n+     use it more than once.  */\n+  alloc_expr = get_target_expr (alloc_call);\n   alloc_node = TARGET_EXPR_SLOT (alloc_expr);\n \n   /* Strip any COMPOUND_EXPRs from ALLOC_CALL.  */\n@@ -2111,16 +2109,17 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n       tree size_ptr_type;\n \n       /* Adjust so we're pointing to the start of the object.  */\n-      data_addr = get_target_expr (build2 (POINTER_PLUS_EXPR, full_pointer_type,\n-\t\t\t\t\t   alloc_node, cookie_size));\n+      data_addr = build2 (POINTER_PLUS_EXPR, TREE_TYPE (alloc_node),\n+\t\t\t  alloc_node, cookie_size);\n \n       /* Store the number of bytes allocated so that we can know how\n \t many elements to destroy later.  We use the last sizeof\n \t (size_t) bytes to store the number of elements.  */\n-      cookie_ptr = fold_build1 (NEGATE_EXPR, sizetype, size_in_bytes (sizetype));\n+      cookie_ptr = size_binop (MINUS_EXPR, cookie_size, size_in_bytes (sizetype));\n+      cookie_ptr = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (alloc_node),\n+\t\t\t\talloc_node, cookie_ptr);\n       size_ptr_type = build_pointer_type (sizetype);\n-      cookie_ptr = build2 (POINTER_PLUS_EXPR, size_ptr_type,\n-\t\t\t   fold_convert (size_ptr_type, data_addr), cookie_ptr);\n+      cookie_ptr = fold_convert (size_ptr_type, cookie_ptr);\n       cookie = cp_build_indirect_ref (cookie_ptr, NULL, complain);\n \n       cookie_expr = build2 (MODIFY_EXPR, sizetype, cookie, nelts);\n@@ -2134,18 +2133,21 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \n \t  cookie = cp_build_indirect_ref (cookie_ptr, NULL, complain);\n \t  cookie = build2 (MODIFY_EXPR, sizetype, cookie,\n-\t\t\t   size_in_bytes(elt_type));\n+\t\t\t   size_in_bytes (elt_type));\n \t  cookie_expr = build2 (COMPOUND_EXPR, TREE_TYPE (cookie_expr),\n \t\t\t\tcookie, cookie_expr);\n \t}\n-      data_addr = TARGET_EXPR_SLOT (data_addr);\n     }\n   else\n     {\n       cookie_expr = NULL_TREE;\n       data_addr = alloc_node;\n     }\n \n+  /* Now use a pointer to the type we've actually allocated.  */\n+  full_pointer_type = build_pointer_type (full_type);\n+  data_addr = fold_convert (full_pointer_type, data_addr);\n+\n   /* Now initialize the allocated object.  Note that we preevaluate the\n      initialization expression, apart from the actual constructor call or\n      assignment--we do this because we want to delay the allocation as long\n@@ -2241,11 +2243,13 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \t  /* The Standard is unclear here, but the right thing to do\n \t     is to use the same method for finding deallocation\n \t     functions that we use for finding allocation functions.  */\n-\t  cleanup = build_op_delete_call (dcode, alloc_node, size,\n-\t\t\t\t\t  globally_qualified_p,\n-\t\t\t\t\t  (placement_allocation_fn_p\n-\t\t\t\t\t   ? alloc_call : NULL_TREE),\n-\t\t\t\t\t  alloc_fn);\n+\t  cleanup = (build_op_delete_call\n+\t\t     (dcode,\n+\t\t      fold_convert (full_pointer_type, alloc_node),\n+\t\t      size,\n+\t\t      globally_qualified_p,\n+\t\t      placement_allocation_fn_p ? alloc_call : NULL_TREE,\n+\t\t      alloc_fn));\n \n \t  if (!cleanup)\n \t    /* We're done.  */;\n@@ -2300,7 +2304,7 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n   if (cookie_expr)\n     rval = build2 (COMPOUND_EXPR, TREE_TYPE (rval), cookie_expr, rval);\n \n-  if (rval == alloc_node)\n+  if (rval == data_addr)\n     /* If we don't have an initializer or a cookie, strip the TARGET_EXPR\n        and return the call (which doesn't need to be adjusted).  */\n     rval = TARGET_EXPR_INITIAL (alloc_expr);"}, {"sha": "a859f0ac3775225b9a12e63002dfa2ddcfd76944", "filename": "gcc/testsuite/g++.dg/tree-ssa/new1.C", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10ee5386adadefebd247c7e4870c666f2c9b359d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fnew1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10ee5386adadefebd247c7e4870c666f2c9b359d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fnew1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fnew1.C?ref=10ee5386adadefebd247c7e4870c666f2c9b359d", "patch": "@@ -0,0 +1,42 @@\n+// PR c++/36633\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wall -fdump-tree-forwprop1\" } */\n+// No particular reason for choosing forwprop1 dump to look at.\n+\n+struct B { ~B() {} };\n+struct D : public B {};\n+//struct D {};\n+\n+struct my_deleter\n+{\n+  void operator()(D * d)\n+  {\n+    //    delete [] d;\n+  }\n+};\n+\n+struct smart_ptr\n+{\n+  smart_ptr(D * ptr) : p(ptr) { }\n+  ~smart_ptr() { d(p); }\n+  D * p;\n+  my_deleter d;  \n+};\n+\n+int\n+test01()\n+{\n+  smart_ptr p(new D[7]);\n+\n+  return 0;\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"= .* \\\\+ -\" \"forwprop1\" } } */\n+/* { dg-final { cleanup-tree-dump \"forwprop1\" } } */"}]}