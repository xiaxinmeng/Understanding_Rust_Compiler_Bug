{"sha": "c93320c457dc75596c5482cdbef7783ad6cdaf2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzkzMzIwYzQ1N2RjNzU1OTZjNTQ4MmNkYmVmNzc4M2FkNmNkYWYyZQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2004-09-21T07:48:29Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2004-09-21T07:48:29Z"}, "message": "re PR rtl-optimization/17482 (GCSE after reload replacing changing instructions)\n\n\tPR rtl-optimization/17482\n\t* postreload-gcse.c (reg_avail_info, oprs_unchanged_p,\n\tload_killed_in_block_p): Clarify comments.\n\t(record_last_reg_set_info): Make static inline.\n\t(mark_call, mark_set, mark_clobber, mark_oprs_set): Remove.\n\t(record_opr_changes): New function to replace the above.\n\t(compute_hash_table): Clarify comments.  Use record_opr_changes.\n\t(reg_set_between_after_reload_p): Clean up.\n\t(reg_used_between_after_reload_p): Likewise.\n\t(eliminate_partially_redundant_load): Clarify comments.\n\nFrom-SVN: r87794", "tree": {"sha": "cf57012ff1cccade663d2393c59d5330bb6d67f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf57012ff1cccade663d2393c59d5330bb6d67f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c93320c457dc75596c5482cdbef7783ad6cdaf2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c93320c457dc75596c5482cdbef7783ad6cdaf2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c93320c457dc75596c5482cdbef7783ad6cdaf2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c93320c457dc75596c5482cdbef7783ad6cdaf2e/comments", "author": null, "committer": null, "parents": [{"sha": "15ee342b73adc73b1c307c9b827bdd5341561bf1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15ee342b73adc73b1c307c9b827bdd5341561bf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15ee342b73adc73b1c307c9b827bdd5341561bf1"}], "stats": {"total": 277, "additions": 119, "deletions": 158}, "files": [{"sha": "801759d5a89056f079a3f9c295782b24baca09a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93320c457dc75596c5482cdbef7783ad6cdaf2e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93320c457dc75596c5482cdbef7783ad6cdaf2e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c93320c457dc75596c5482cdbef7783ad6cdaf2e", "patch": "@@ -1,3 +1,16 @@\n+2004-09-21  Steven Bosscher  <stevenb@suse.de>\n+\n+\tPR rtl-optimization/17482\n+\t* postreload-gcse.c (reg_avail_info, oprs_unchanged_p,\n+\tload_killed_in_block_p): Clarify comments.\n+\t(record_last_reg_set_info): Make static inline.\n+\t(mark_call, mark_set, mark_clobber, mark_oprs_set): Remove.\n+\t(record_opr_changes): New function to replace the above.\n+\t(compute_hash_table): Clarify comments.  Use record_opr_changes.\n+\t(reg_set_between_after_reload_p): Clean up.\n+\t(reg_used_between_after_reload_p): Likewise.\n+\t(eliminate_partially_redundant_load): Clarify comments.\n+\n 2004-09-21  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \tPR rtl-optimization/17266"}, {"sha": "0238acefccf02d8272392350f497ad913bc285fb", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 106, "deletions": 158, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93320c457dc75596c5482cdbef7783ad6cdaf2e/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93320c457dc75596c5482cdbef7783ad6cdaf2e/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=c93320c457dc75596c5482cdbef7783ad6cdaf2e", "patch": "@@ -135,7 +135,13 @@ static struct obstack unoccr_obstack;\n \n /* Array where each element is the CUID if the insn that last set the hard\n    register with the number of the element, since the start of the current\n-   basic block.  */\n+   basic block.\n+\n+   This array is used during the building of the hash table (step 1) to\n+   determine if a reg is killed before the end of a basic block.\n+\n+   It is also used when eliminating partial redundancies (step 2) to see\n+   if a reg was modified since the start of a basic block.  */\n static int *reg_avail_info;\n \n /* A list of insns that may modify memory within the current basic block.  */\n@@ -169,10 +175,7 @@ static bool oprs_unchanged_p (rtx, rtx, bool);\n static void record_last_reg_set_info (rtx, int);\n static void record_last_mem_set_info (rtx);\n static void record_last_set_info (rtx, rtx, void *);\n-static void mark_call (rtx);\n-static void mark_set (rtx, rtx);\n-static void mark_clobber (rtx, rtx);\n-static void mark_oprs_set (rtx);\n+static void record_opr_changes (rtx);\n \n static void find_mem_conflicts (rtx, rtx, void *);\n static int load_killed_in_block_p (int, rtx, bool);\n@@ -466,10 +469,10 @@ dump_hash_table (FILE *file)\n }\n \f\n \n-/* Return nonzero if the operands of expression X are unchanged from the\n-   start of INSN's basic block up to but not including INSN if AFTER_INSN\n-   is false, or from INSN to the end of INSN's basic block if AFTER_INSN\n-   is true.  */\n+/* Return nonzero if the operands of expression X are unchanged\n+   1) from the start of INSN's basic block up to but not including INSN\n+      if AFTER_INSN is false, or\n+   2) from INSN to the end of INSN's basic block if AFTER_INSN is true.  */\n \n static bool\n oprs_unchanged_p (rtx x, rtx insn, bool after_insn)\n@@ -584,8 +587,12 @@ find_mem_conflicts (rtx dest, rtx setter ATTRIBUTE_UNUSED,\n \f\n \n /* Return nonzero if the expression in X (a memory reference) is killed\n-   in block BB before if (AFTER_INSN is false) or after (if AFTER_INSN\n-   is true) the insn with the CUID in UID_LIMIT.  */\n+   in the current basic block before (if AFTER_INSN is false) or after\n+   (if AFTER_INSN is true) the insn with the CUID in UID_LIMIT.\n+\n+   This function assumes that the modifies_mem table is flushed when\n+   the hash table construction or redundancy elimination phases start\n+   processing a new basic block.  */\n \n static int\n load_killed_in_block_p (int uid_limit, rtx x, bool after_insn)\n@@ -629,7 +636,7 @@ load_killed_in_block_p (int uid_limit, rtx x, bool after_insn)\n \n /* Record register first/last/block set information for REGNO in INSN.  */\n \n-static void\n+static inline void\n record_last_reg_set_info (rtx insn, int regno)\n {\n   reg_avail_info[regno] = INSN_CUID (insn);\n@@ -671,7 +678,7 @@ record_last_set_info (rtx dest, rtx setter ATTRIBUTE_UNUSED, void *data)\n \t   && ! push_operand (dest, GET_MODE (dest)))\n     record_last_mem_set_info (last_set_insn);\n }\n-\f\n+\n \n /* Reset tables used to keep track of what's still available since the\n    start of the block.  */\n@@ -683,85 +690,44 @@ reset_opr_set_tables (void)\n   obstack_free (&modifies_mem_obstack, modifies_mem_obstack_bottom);\n   modifies_mem_list = NULL;\n }\n-\n-/* Mark things set by a CALL.  */\n-\n-static void\n-mark_call (rtx insn)\n-{\n-  if (! CONST_OR_PURE_CALL_P (insn))\n-    record_last_mem_set_info (insn);\n-}\n-\n-/* Mark things set by a SET.  */\n-\n-static void\n-mark_set (rtx pat, rtx insn)\n-{\n-  rtx dest = SET_DEST (pat);\n-\n-  while (GET_CODE (dest) == SUBREG\n-\t || GET_CODE (dest) == ZERO_EXTRACT\n-\t || GET_CODE (dest) == SIGN_EXTRACT\n-\t || GET_CODE (dest) == STRICT_LOW_PART)\n-    dest = XEXP (dest, 0);\n-\n-  if (REG_P (dest))\n-    record_last_reg_set_info (insn, REGNO (dest));\n-  else if (MEM_P (dest))\n-    record_last_mem_set_info (insn);\n-\n-  if (GET_CODE (SET_SRC (pat)) == CALL)\n-    mark_call (insn);\n-}\n-\n-/* Record things set by a CLOBBER.  */\n-\n-static void\n-mark_clobber (rtx pat, rtx insn)\n-{\n-  rtx clob = XEXP (pat, 0);\n-\n-  while (GET_CODE (clob) == SUBREG\n-\t || GET_CODE (clob) == STRICT_LOW_PART)\n-    clob = XEXP (clob, 0);\n-\n-  if (REG_P (clob))\n-    record_last_reg_set_info (insn, REGNO (clob));\n-  else\n-    record_last_mem_set_info (insn);\n-}\n+\f\n \n /* Record things set by INSN.\n    This data is used by oprs_unchanged_p.  */\n \n static void\n-mark_oprs_set (rtx insn)\n+record_opr_changes (rtx insn)\n {\n-  rtx pat = PATTERN (insn);\n-  int i;\n+  rtx note;\n \n-  if (GET_CODE (pat) == SET)\n-    mark_set (pat, insn);\n+  /* Find all stores and record them.  */\n+  note_stores (PATTERN (insn), record_last_set_info, insn);\n \n-  else if (GET_CODE (pat) == PARALLEL)\n-    for (i = 0; i < XVECLEN (pat, 0); i++)\n-      {\n-\trtx x = XVECEXP (pat, 0, i);\n-\n-\tif (GET_CODE (x) == SET)\n-\t  mark_set (x, insn);\n-\telse if (GET_CODE (x) == CLOBBER)\n-\t  mark_clobber (x, insn);\n-\telse if (GET_CODE (x) == CALL)\n-\t  mark_call (insn);\n-      }\n+  /* Also record autoincremented REGs for this insn as changed.  */\n+  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+    if (REG_NOTE_KIND (note) == REG_INC)\n+      record_last_reg_set_info (insn, REGNO (XEXP (note, 0)));\n \n-  else if (GET_CODE (pat) == CLOBBER)\n-    mark_clobber (pat, insn);\n+  /* Finally, if this is a call, record all call clobbers.  */\n+  if (CALL_P (insn))\n+    {\n+      unsigned int regno;\n+      bool clobbers_all = false;\n+\n+#ifdef NON_SAVING_SETJMP\n+      if (NON_SAVING_SETJMP\n+\t  && find_reg_note (insn, REG_SETJMP, NULL_RTX))\n+\tclobbers_all = true;\n+#endif\n+\n+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\tif (clobbers_all\n+\t    || TEST_HARD_REG_BIT (regs_invalidated_by_call, regno))\n+\t  record_last_reg_set_info (insn, regno);\n \n-  else if (GET_CODE (pat) == CALL)\n-    mark_call (insn);\n+      if (! CONST_OR_PURE_CALL_P (insn))\n+\trecord_last_mem_set_info (insn);\n+    }\n }\n \f\n \n@@ -791,7 +757,7 @@ hash_scan_set (rtx insn)\n \n   if (REG_P (dest))\n     {\n-      if (/* Don't GCSE something if we can't do a reg/reg copy.  */\n+      if (/* Don't CSE something if we can't do a reg/reg copy.  */\n \t  can_copy_p (GET_MODE (dest))\n \t  /* Is SET_SRC something we want to gcse?  */\n \t  && general_operand (src, GET_MODE (src))\n@@ -805,7 +771,7 @@ hash_scan_set (rtx insn)\n   else if (REG_P (src))\n     {\n       /* Only record sets of pseudo-regs in the hash table.  */\n-      if (/* Don't GCSE something if we can't do a reg/reg copy.  */\n+      if (/* Don't CSE something if we can't do a reg/reg copy.  */\n \t  can_copy_p (GET_MODE (src))\n \t  /* Is SET_DEST something we want to gcse?  */\n \t  && general_operand (dest, GET_MODE (dest))\n@@ -819,8 +785,12 @@ hash_scan_set (rtx insn)\n     }\n }\n \f\n+\n /* Create hash table of memory expressions available at end of basic\n-   blocks.  */\n+   blocks.  Basically you should think of this hash table as the\n+   representation of AVAIL_OUT.  This is the set of expressions that\n+   is generated in a basic block and not killed before the end of the\n+   same basic block.  Notice that this is really a local computation.  */\n \n static void\n compute_hash_table (void)\n@@ -830,59 +800,20 @@ compute_hash_table (void)\n   FOR_EACH_BB (bb)\n     {\n       rtx insn;\n-      unsigned int regno;\n-\n-      reset_opr_set_tables ();\n \n       /* First pass over the instructions records information used to\n-\t determine when registers and memory are first and last set.  */\n+\t determine when registers and memory are last set.\n+\t Since we compute a \"local\" AVAIL_OUT, reset the tables that\n+\t help us keep track of what has been modified since the start\n+\t of the block.  */\n+      reset_opr_set_tables ();\n       FOR_BB_INSNS (bb, insn)\n \t{\n-\t  if (! INSN_P (insn))\n-\t    continue;\n-\n-\t  if (CALL_P (insn))\n-\t    {\n-\t      bool clobbers_all = false;\n-\n-#ifdef NON_SAVING_SETJMP\n-\t      if (NON_SAVING_SETJMP\n-\t\t  && find_reg_note (insn, REG_SETJMP, NULL_RTX))\n-\t\tclobbers_all = true;\n-#endif\n-\n-\t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\t\tif (clobbers_all\n-\t\t    || TEST_HARD_REG_BIT (regs_invalidated_by_call,\n-\t\t\t\t\t  regno))\n-\t\t  record_last_reg_set_info (insn, regno);\n-\n-\t      if (! CONST_OR_PURE_CALL_P (insn))\n-\t\trecord_last_mem_set_info (insn);\n-\t    }\n-\n-\t  note_stores (PATTERN (insn), record_last_set_info, insn);\n-\n-\t  if (GET_CODE (PATTERN (insn)) == SET)\n-\t    {\n-\t      rtx src, dest;\n-\n-\t      src = SET_SRC (PATTERN (insn));\n-\t      dest = SET_DEST (PATTERN (insn));\n-\t      if (MEM_P (src) && auto_inc_p (XEXP (src, 0)))\n-\t\t{\n-\t\t  regno = REGNO (XEXP (XEXP (src, 0), 0));\n-\t\t  record_last_reg_set_info (insn, regno);\n-\t\t}\n-\t      if (MEM_P (dest) && auto_inc_p (XEXP (dest, 0)))\n-\t\t{\n-\t\t  regno = REGNO (XEXP (XEXP (dest, 0), 0));\n-\t\t  record_last_reg_set_info (insn, regno);\n-\t\t}\n-\t     }\n-\t  }\n+\t  if (INSN_P (insn))\n+            record_opr_changes (insn);\n+\t}\n \n-      /* The next pass builds the hash table.  */\n+      /* The next pass actually builds the hash table.  */\n       FOR_BB_INSNS (bb, insn)\n \tif (INSN_P (insn) && GET_CODE (PATTERN (insn)) == SET)\n \t  hash_scan_set (insn);\n@@ -932,7 +863,6 @@ static rtx\n reg_set_between_after_reload_p (rtx reg, rtx from_insn, rtx to_insn)\n {\n   rtx insn;\n-  int regno;\n \n #ifdef ENABLE_CHECKING\n   /* We are called after register allocation.  */\n@@ -943,22 +873,21 @@ reg_set_between_after_reload_p (rtx reg, rtx from_insn, rtx to_insn)\n   if (from_insn == to_insn)\n     return NULL_RTX;\n \n-  regno = REGNO (reg);\n   for (insn = NEXT_INSN (from_insn);\n        insn != to_insn;\n        insn = NEXT_INSN (insn))\n-    {\n-      if (INSN_P (insn))\n-\t{\n-\t  if (FIND_REG_INC_NOTE (insn, reg)\n-\t      || (CALL_P (insn)\n-\t\t  && call_used_regs[regno])\n-\t      || find_reg_fusage (insn, CLOBBER, reg))\n-\t    return insn;\n-\t}\n-      if (set_of (reg, insn) != NULL_RTX)\n-\treturn insn;\n-    }\n+    if (INSN_P (insn))\n+      {\n+\tif (set_of (reg, insn) != NULL_RTX)\n+\t  return insn;\n+\tif ((CALL_P (insn)\n+\t      && call_used_regs[REGNO (reg)])\n+\t    || find_reg_fusage (insn, CLOBBER, reg))\n+\t  return insn;\n+\n+\tif (FIND_REG_INC_NOTE (insn, reg))\n+\t  return insn;\n+      }\n \n   return NULL_RTX;\n }\n@@ -971,7 +900,6 @@ static rtx\n reg_used_between_after_reload_p (rtx reg, rtx from_insn, rtx to_insn)\n {\n   rtx insn;\n-  int regno;\n \n #ifdef ENABLE_CHECKING\n   /* We are called after register allocation.  */\n@@ -982,17 +910,21 @@ reg_used_between_after_reload_p (rtx reg, rtx from_insn, rtx to_insn)\n   if (from_insn == to_insn)\n     return NULL_RTX;\n \n-  regno = REGNO (reg);\n   for (insn = NEXT_INSN (from_insn);\n        insn != to_insn;\n        insn = NEXT_INSN (insn))\n-    if (INSN_P (insn)\n-\t&& (reg_overlap_mentioned_p (reg, PATTERN (insn))\n+    if (INSN_P (insn))\n+      {\n+\tif (reg_overlap_mentioned_p (reg, PATTERN (insn))\n \t    || (CALL_P (insn)\n-\t\t&& call_used_regs[regno])\n+\t\t&& call_used_regs[REGNO (reg)])\n \t    || find_reg_fusage (insn, USE, reg)\n-\t    || find_reg_fusage (insn, CLOBBER, reg)))\n-      return insn;\n+\t    || find_reg_fusage (insn, CLOBBER, reg))\n+\t  return insn;\n+\n+\tif (FIND_REG_INC_NOTE (insn, reg))\n+\t  return insn;\n+      }\n \n   return NULL_RTX;\n }\n@@ -1066,7 +998,16 @@ get_bb_avail_insn (basic_block bb, struct occr *occr)\n \n /* This handles the case where several stores feed a partially redundant\n    load. It checks if the redundancy elimination is possible and if it's\n-   worth it.  */\n+   worth it.\n+\n+   Redundancy elimination is possible if,\n+   1) None of the operands of an insn have been modified since the start\n+      of the current basic block.\n+   2) In any predecessor of the current basic block, the same expression\n+      is generated.\n+\n+   See the function body for the heuristics that determine if eliminating\n+   a redundancy is also worth doing, assuming it is possible.  */\n \n static void\n eliminate_partially_redundant_load (basic_block bb, rtx insn,\n@@ -1251,15 +1192,20 @@ eliminate_partially_redundant_loads (void)\n \t\t  EXIT_BLOCK_PTR,\n \t\t  next_bb)\n     {\n+      /* Don't try anything on basic blocks with strange predecessors.  */\n       if (! bb_has_well_behaved_predecessors (bb))\n \tcontinue;\n \n-      /* Do not try this optimization on cold basic blocks.  */\n+      /* Do not try anything on cold basic blocks.  */\n       if (probably_cold_bb_p (bb))\n \tcontinue;\n \n+      /* Reset the table of things changed since the start of the current\n+\t basic block.  */\n       reset_opr_set_tables ();\n \n+      /* Look at all insns in the current basic block and see if there are\n+\t any loads in it that we can record.  */\n       FOR_BB_INSNS (bb, insn)\n \t{\n \t  /* Is it a load - of the form (set (reg) (mem))?  */\n@@ -1290,9 +1236,11 @@ eliminate_partially_redundant_loads (void)\n \t\t}\n \t    }\n \n-\t  /* Keep track of everything modified by this insn.  */\n+\t  /* Keep track of everything modified by this insn, so that we\n+\t     know what has been modified since the start of the current\n+\t     basic block.  */\n \t  if (INSN_P (insn))\n-\t    mark_oprs_set (insn);\n+\t    record_opr_changes (insn);\n \t}\n     }\n "}]}