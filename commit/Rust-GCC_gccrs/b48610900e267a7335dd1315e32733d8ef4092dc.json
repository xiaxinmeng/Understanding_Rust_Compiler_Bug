{"sha": "b48610900e267a7335dd1315e32733d8ef4092dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ4NjEwOTAwZTI2N2E3MzM1ZGQxMzE1ZTMyNzMzZDhlZjQwOTJkYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2005-04-21T13:18:23Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2005-04-21T13:18:23Z"}, "message": "cgraphunit.c: Include tree-pass.h (cgraph_decide_recursive_inlining...\n\n\t* cgraphunit.c: Include tree-pass.h\n\t(cgraph_decide_recursive_inlining,\n\tcgraph_decide_inlining_of_small_function, cgraph_set_inline_failed,\n\tcgraph_decide_inlining): Dump goes to dump_file.\n\t(cgraph_optimize): Call ipa passes instead of inliner.\n\t(cgraph_gate_inlining, pass_ipa_inline): New.\n\t* tree-optimize.c (all_ipa_passes): New static variable.\n\t(register_one_dump_file): Dead with IPA passes.\n\t(register_dump_files): Likewise.\n\t(init_tree_optimization_passes): Initialize IPA passes.\n\t(execute_todo): Do cgraph dump when asked to, do not dump function body\n\tfor IPA pass.\n\t* tree-pass.h (TODO_dump_cgraph): New macro.\n\t(ipa_passes): Declare.\n\t* Makefile.in (cgraphunit.o): Add dependency on cgraphunit.h\n\nFrom-SVN: r98501", "tree": {"sha": "9b1c4ea35be4dd923659057c72272052e51d3eef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b1c4ea35be4dd923659057c72272052e51d3eef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b48610900e267a7335dd1315e32733d8ef4092dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b48610900e267a7335dd1315e32733d8ef4092dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b48610900e267a7335dd1315e32733d8ef4092dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b48610900e267a7335dd1315e32733d8ef4092dc/comments", "author": null, "committer": null, "parents": [{"sha": "d0396b7941243ea231a4f812de072c89ca2cd345", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0396b7941243ea231a4f812de072c89ca2cd345", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0396b7941243ea231a4f812de072c89ca2cd345"}], "stats": {"total": 194, "additions": 136, "deletions": 58}, "files": [{"sha": "fa41617d5984a231bfeca2fac3a2fbb23a73d9f2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48610900e267a7335dd1315e32733d8ef4092dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48610900e267a7335dd1315e32733d8ef4092dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b48610900e267a7335dd1315e32733d8ef4092dc", "patch": "@@ -1,3 +1,21 @@\n+2005-04-21  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraphunit.c: Include tree-pass.h\n+\t(cgraph_decide_recursive_inlining,\n+\tcgraph_decide_inlining_of_small_function, cgraph_set_inline_failed,\n+\tcgraph_decide_inlining): Dump goes to dump_file.\n+\t(cgraph_optimize): Call ipa passes instead of inliner.\n+\t(cgraph_gate_inlining, pass_ipa_inline): New.\n+\t* tree-optimize.c (all_ipa_passes): New static variable.\n+\t(register_one_dump_file): Dead with IPA passes.\n+\t(register_dump_files): Likewise.\n+\t(init_tree_optimization_passes): Initialize IPA passes.\n+\t(execute_todo): Do cgraph dump when asked to, do not dump function body\n+\tfor IPA pass.\n+\t* tree-pass.h (TODO_dump_cgraph): New macro.\n+\t(ipa_passes): Declare.\n+\t* Makefile.in (cgraphunit.o): Add dependency on cgraphunit.h\n+\n 2005-04-21  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* config/i386/i386.c (type_natural_mode): Use gcc_unreachable and"}, {"sha": "e578a6d8b41f27170033817e32de2523ab966303", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48610900e267a7335dd1315e32733d8ef4092dc/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48610900e267a7335dd1315e32733d8ef4092dc/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b48610900e267a7335dd1315e32733d8ef4092dc", "patch": "@@ -1975,7 +1975,7 @@ cgraph.o : cgraph.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    output.h intl.h\n cgraphunit.o : cgraphunit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    langhooks.h tree-inline.h toplev.h $(FLAGS_H) $(GGC_H)  $(TARGET_H) $(CGRAPH_H) intl.h \\\n-   pointer-set.h function.h $(TREE_GIMPLE_H) $(TREE_FLOW_H)\n+   pointer-set.h function.h $(TREE_GIMPLE_H) $(TREE_FLOW_H) tree-pass.h\n coverage.o : coverage.c gcov-io.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(RTL_H) $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) function.h \\\n    toplev.h $(GGC_H) $(TARGET_H) langhooks.h $(COVERAGE_H) libfuncs.h \\"}, {"sha": "bcb971947232b3cdf5000df5b6446f1e751ab9f3", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 62, "deletions": 39, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48610900e267a7335dd1315e32733d8ef4092dc/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48610900e267a7335dd1315e32733d8ef4092dc/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=b48610900e267a7335dd1315e32733d8ef4092dc", "patch": "@@ -189,6 +189,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"intl.h\"\n #include \"function.h\"\n #include \"tree-gimple.h\"\n+#include \"tree-pass.h\"\n #include \"output.h\"\n \n static void cgraph_expand_all_functions (void);\n@@ -1400,8 +1401,8 @@ cgraph_decide_recursive_inlining (struct cgraph_node *node)\n   if (!first_call)\n     return;\n \n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \n+  if (dump_file)\n+    fprintf (dump_file, \n \t     \"\\nPerforming recursive inlining on %s\\n\",\n \t     cgraph_node_name (node));\n \n@@ -1439,8 +1440,8 @@ cgraph_decide_recursive_inlining (struct cgraph_node *node)\n       first_call->aux = NULL;\n       first_call = next;\n     }\n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \n+  if (dump_file)\n+    fprintf (dump_file, \n \t     \"\\n   Inlined %i times, body grown from %i to %i insns\\n\", n,\n \t     master_clone->global.insns, node->global.insns);\n \n@@ -1461,8 +1462,8 @@ cgraph_set_inline_failed (struct cgraph_node *node, const char *reason)\n {\n   struct cgraph_edge *e;\n \n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \"Inlining failed: %s\\n\", reason);\n+  if (dump_file)\n+    fprintf (dump_file, \"Inlining failed: %s\\n\", reason);\n   for (e = node->callers; e; e = e->next_caller)\n     if (e->inline_failed)\n       e->inline_failed = reason;\n@@ -1503,16 +1504,16 @@ cgraph_decide_inlining_of_small_functions (void)\n \tfibheap_insert (heap, cgraph_estimate_growth (node), node);\n     }\n \n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \"\\nDeciding on smaller functions:\\n\");\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nDeciding on smaller functions:\\n\");\n   while (overall_insns <= max_insns && (node = fibheap_extract_min (heap)))\n     {\n       struct cgraph_edge *e, *next;\n       int old_insns = overall_insns;\n \n       heap_node[node->uid] = NULL;\n-      if (cgraph_dump_file)\n-\tfprintf (cgraph_dump_file, \n+      if (dump_file)\n+\tfprintf (dump_file, \n \t\t \"\\nConsidering %s with %i insns\\n\"\n \t\t \" Estimated growth is %+i insns.\\n\",\n \t\t cgraph_node_name (node), node->global.insns,\n@@ -1535,8 +1536,8 @@ cgraph_decide_inlining_of_small_functions (void)\n \t\t  || !cgraph_check_inline_limits (e->caller, e->callee,\n \t\t\t  \t\t\t  &e->inline_failed))\n \t\t{\n-\t\t  if (cgraph_dump_file)\n-\t\t    fprintf (cgraph_dump_file, \" Not inlining into %s:%s.\\n\",\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \" Not inlining into %s:%s.\\n\",\n \t\t\t     cgraph_node_name (e->caller), e->inline_failed);\n \t\t  continue;\n \t\t}\n@@ -1549,8 +1550,8 @@ cgraph_decide_inlining_of_small_functions (void)\n \t\tfibheap_replace_key (heap, heap_node[where->uid],\n \t\t\t\t     cgraph_estimate_growth (where));\n \n-\t      if (cgraph_dump_file)\n-\t\tfprintf (cgraph_dump_file, \n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \n \t\t\t \" Inlined into %s which now has %i insns.\\n\",\n \t\t\t cgraph_node_name (e->caller),\n \t\t\t e->caller->global.insns);\n@@ -1563,8 +1564,8 @@ cgraph_decide_inlining_of_small_functions (void)\n          are now called more times; update keys.  */\n       update_callee_keys (heap, heap_node, node);\n \n-      if (cgraph_dump_file)\n-\tfprintf (cgraph_dump_file, \n+      if (dump_file)\n+\tfprintf (dump_file, \n \t\t \" Inlined for a net change of %+i insns.\\n\",\n \t\t overall_insns - old_insns);\n     }\n@@ -1594,16 +1595,16 @@ cgraph_decide_inlining (void)\n \n   nnodes = cgraph_postorder (order);\n \n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file,\n+  if (dump_file)\n+    fprintf (dump_file,\n \t     \"\\nDeciding on inlining.  Starting with %i insns.\\n\",\n \t     initial_insns);\n \n   for (node = cgraph_nodes; node; node = node->next)\n     node->aux = 0;\n \n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \"\\nInlining always_inline functions:\\n\");\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nInlining always_inline functions:\\n\");\n \n   /* In the first pass mark all always_inline edges.  Do this with a priority\n      so none of our later choices will make this impossible.  */\n@@ -1615,8 +1616,8 @@ cgraph_decide_inlining (void)\n \n       if (!node->local.disregard_inline_limits)\n \tcontinue;\n-      if (cgraph_dump_file)\n-\tfprintf (cgraph_dump_file,\n+      if (dump_file)\n+\tfprintf (dump_file,\n \t\t \"\\nConsidering %s %i insns (always inline)\\n\",\n \t\t cgraph_node_name (node), node->global.insns);\n       old_insns = overall_insns;\n@@ -1629,14 +1630,14 @@ cgraph_decide_inlining (void)\n \t\t\t\t  \t   &e->inline_failed))\n \t    continue;\n \t  cgraph_mark_inline_edge (e);\n-\t  if (cgraph_dump_file)\n-\t    fprintf (cgraph_dump_file, \n+\t  if (dump_file)\n+\t    fprintf (dump_file, \n \t\t     \" Inlined into %s which now has %i insns.\\n\",\n \t\t     cgraph_node_name (e->caller),\n \t\t     e->caller->global.insns);\n \t}\n-      if (cgraph_dump_file)\n-\tfprintf (cgraph_dump_file, \n+      if (dump_file)\n+\tfprintf (dump_file, \n \t\t \" Inlined for a net change of %+i insns.\\n\",\n \t\t overall_insns - old_insns);\n     }\n@@ -1645,8 +1646,8 @@ cgraph_decide_inlining (void)\n     {\n       cgraph_decide_inlining_of_small_functions ();\n \n-      if (cgraph_dump_file)\n-\tfprintf (cgraph_dump_file, \"\\nDeciding on functions called once:\\n\");\n+      if (dump_file)\n+\tfprintf (dump_file, \"\\nDeciding on functions called once:\\n\");\n \n       /* And finally decide what functions are called once.  */\n \n@@ -1669,8 +1670,8 @@ cgraph_decide_inlining (void)\n \t\t  ok = false;\n \t      if (ok)\n \t\t{\n-\t\t  if (cgraph_dump_file)\n-\t\t    fprintf (cgraph_dump_file,\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file,\n \t\t\t     \"\\nConsidering %s %i insns.\\n\"\n \t\t\t     \" Called once from %s %i insns.\\n\",\n \t\t\t     cgraph_node_name (node), node->global.insns,\n@@ -1683,8 +1684,8 @@ cgraph_decide_inlining (void)\n \t\t\t\t\t  \t  NULL))\n \t\t    {\n \t\t      cgraph_mark_inline (node->callers);\n-\t\t      if (cgraph_dump_file)\n-\t\t\tfprintf (cgraph_dump_file,\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file,\n \t\t\t\t \" Inlined into %s which now has %i insns\"\n \t\t\t\t \" for a net change of %+i insns.\\n\",\n \t\t\t\t cgraph_node_name (node->callers->caller),\n@@ -1693,8 +1694,8 @@ cgraph_decide_inlining (void)\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      if (cgraph_dump_file)\n-\t\t\tfprintf (cgraph_dump_file,\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file,\n \t\t\t\t \" Inline limit reached, not inlined.\\n\");\n \t\t    }\n \t\t}\n@@ -1707,8 +1708,8 @@ cgraph_decide_inlining (void)\n      inline functions.  */\n   cgraph_remove_unreachable_nodes ();\n \n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file,\n+  if (dump_file)\n+    fprintf (dump_file,\n \t     \"\\nInlined %i calls, eliminated %i functions, \"\n \t     \"%i insns turned to %i insns.\\n\\n\",\n \t     ncalls_inlined, nfunctions_inlined, initial_insns,\n@@ -1883,9 +1884,7 @@ cgraph_optimize (void)\n       fprintf (cgraph_dump_file, \"Marked \");\n       dump_cgraph (cgraph_dump_file);\n     }\n-\n-  if (flag_inline_trees)\n-    cgraph_decide_inlining ();\n+  ipa_passes ();\n   cgraph_global_info_ready = true;\n   if (cgraph_dump_file)\n     {\n@@ -2015,3 +2014,27 @@ init_cgraph (void)\n {\n   cgraph_dump_file = dump_begin (TDI_cgraph, NULL);\n }\n+\n+/* When inlining shall be performed.  */\n+static bool\n+cgraph_gate_inlining (void)\n+{\n+  return flag_inline_trees;\n+}\n+\n+struct tree_opt_pass pass_ipa_inline = \n+{\n+  \"inline\",\t\t\t\t/* name */\n+  cgraph_gate_inlining,\t\t\t/* gate */\n+  cgraph_decide_inlining,\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_INTEGRATION,\t\t\t/* tv_id */\n+  0,\t                                /* properties_required */\n+  PROP_trees,\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_cgraph | TODO_dump_func,\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};"}, {"sha": "80c89bf27872e37e7f3bec2fea7c095d376fe018", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 50, "deletions": 18, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48610900e267a7335dd1315e32733d8ef4092dc/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48610900e267a7335dd1315e32733d8ef4092dc/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=b48610900e267a7335dd1315e32733d8ef4092dc", "patch": "@@ -55,7 +55,7 @@ int dump_flags;\n bool in_gimple_form;\n \n /* The root of the compilation pass tree, once constructed.  */\n-static struct tree_opt_pass *all_passes;\n+static struct tree_opt_pass *all_passes, *all_ipa_passes;\n \n /* Pass: dump the gimplified, inlined, functions.  */\n \n@@ -210,7 +210,7 @@ static struct tree_opt_pass pass_init_datastructures =\n    enabled or not.  */\n \n static void\n-register_one_dump_file (struct tree_opt_pass *pass, int n)\n+register_one_dump_file (struct tree_opt_pass *pass, bool ipa, int n)\n {\n   char *dot_name, *flag_name, *glob_name;\n   char num[10];\n@@ -222,7 +222,15 @@ register_one_dump_file (struct tree_opt_pass *pass, int n)\n \t\t\t ? 1 : pass->static_pass_number));\n \n   dot_name = concat (\".\", pass->name, num, NULL);\n-  if (pass->properties_provided & PROP_trees)\n+  if (ipa)\n+    {\n+      flag_name = concat (\"ipa-\", pass->name, num, NULL);\n+      glob_name = concat (\"ipa-\", pass->name, NULL);\n+      /* First IPA dump is cgraph that is dumped via separate channels.  */\n+      pass->static_pass_number = dump_register (dot_name, flag_name, glob_name,\n+                                                TDF_IPA, n + 1, 0);\n+    }\n+  else if (pass->properties_provided & PROP_trees)\n     {\n       flag_name = concat (\"tree-\", pass->name, num, NULL);\n       glob_name = concat (\"tree-\", pass->name, NULL);\n@@ -239,7 +247,7 @@ register_one_dump_file (struct tree_opt_pass *pass, int n)\n }\n \n static int \n-register_dump_files (struct tree_opt_pass *pass, int properties)\n+register_dump_files (struct tree_opt_pass *pass, bool ipa, int properties)\n {\n   static int n = 0;\n   do\n@@ -260,7 +268,7 @@ register_dump_files (struct tree_opt_pass *pass, int properties)\n         n++;\n \n       if (pass->sub)\n-        new_properties = register_dump_files (pass->sub, new_properties);\n+        new_properties = register_dump_files (pass->sub, ipa, new_properties);\n \n       /* If we have a gate, combine the properties that we could have with\n          and without the pass being examined.  */\n@@ -271,7 +279,7 @@ register_dump_files (struct tree_opt_pass *pass, int properties)\n \n       pass->properties_provided = properties;\n       if (pass->name)\n-        register_one_dump_file (pass, pass_number);\n+        register_one_dump_file (pass, ipa, pass_number);\n \n       pass = pass->next;\n     }\n@@ -326,6 +334,10 @@ init_tree_optimization_passes (void)\n   struct tree_opt_pass **p;\n \n #define NEXT_PASS(PASS)  (p = next_pass_1 (p, &PASS))\n+  /* Intraprocedural optimization passes.  */\n+  p = &all_ipa_passes;\n+  NEXT_PASS (pass_ipa_inline);\n+  *p = NULL;\n \n   p = &all_passes;\n   NEXT_PASS (pass_gimple);\n@@ -432,12 +444,16 @@ init_tree_optimization_passes (void)\n \n #undef NEXT_PASS\n \n-  /* Register the passes with the tree dump code.  */\n-  register_dump_files (all_passes, 0);\n+  register_dump_files (all_passes, false, PROP_gimple_any\n+\t\t\t\t\t  | PROP_gimple_lcf\n+\t\t\t\t\t  | PROP_gimple_leh\n+\t\t\t\t\t  | PROP_cfg);\n+  register_dump_files (all_ipa_passes, true, PROP_gimple_any\n+\t\t\t\t\t     | PROP_gimple_lcf\n+\t\t\t\t\t     | PROP_gimple_leh\n+\t\t\t\t\t     | PROP_cfg);\n }\n \n-static void execute_pass_list (struct tree_opt_pass *);\n-\n static unsigned int last_verified;\n \n static void\n@@ -465,7 +481,8 @@ execute_todo (struct tree_opt_pass *pass, unsigned int flags, bool use_required)\n \tcleanup_tree_cfg ();\n     }\n \n-  if ((flags & TODO_dump_func) && dump_file)\n+  if ((flags & TODO_dump_func)\n+      && dump_file && current_function_decl)\n     {\n       if (properties & PROP_trees)\n         dump_function_to_file (current_function_decl,\n@@ -479,6 +496,14 @@ execute_todo (struct tree_opt_pass *pass, unsigned int flags, bool use_required)\n \t close the file before aborting.  */\n       fflush (dump_file);\n     }\n+  if ((flags & TODO_dump_cgraph)\n+      && dump_file && !current_function_decl)\n+    {\n+      dump_cgraph (dump_file);\n+      /* Flush the file.  If verification fails, we won't be able to\n+\t close the file before aborting.  */\n+      fflush (dump_file);\n+    }\n \n   if (flags & TODO_ggc_collect)\n     {\n@@ -522,18 +547,18 @@ execute_one_pass (struct tree_opt_pass *pass)\n       bool initializing_dump = !dump_initialized_p (pass->static_pass_number);\n       dump_file_name = get_dump_file_name (pass->static_pass_number);\n       dump_file = dump_begin (pass->static_pass_number, &dump_flags);\n-      if (dump_file)\n+      if (dump_file && current_function_decl)\n \t{\n \t  const char *dname, *aname;\n \t  dname = lang_hooks.decl_printable_name (current_function_decl, 2);\n \t  aname = (IDENTIFIER_POINTER\n \t\t   (DECL_ASSEMBLER_NAME (current_function_decl)));\n-          fprintf (dump_file, \"\\n;; Function %s (%s)%s\\n\\n\", dname, aname,\n-             cfun->function_frequency == FUNCTION_FREQUENCY_HOT\n-             ? \" (hot)\"\n-             : cfun->function_frequency == FUNCTION_FREQUENCY_UNLIKELY_EXECUTED\n-             ? \" (unlikely executed)\"\n-             : \"\");\n+\t  fprintf (dump_file, \"\\n;; Function %s (%s)%s\\n\\n\", dname, aname,\n+\t     cfun->function_frequency == FUNCTION_FREQUENCY_HOT\n+\t     ? \" (hot)\"\n+\t     : cfun->function_frequency == FUNCTION_FREQUENCY_UNLIKELY_EXECUTED\n+\t     ? \" (unlikely executed)\"\n+\t     : \"\");\n \t}\n \n       if (initializing_dump\n@@ -592,6 +617,13 @@ execute_pass_list (struct tree_opt_pass *pass)\n     }\n   while (pass);\n }\n+\n+/* Execute all IPA passes.  */\n+void\n+ipa_passes (void)\n+{\n+   execute_pass_list (all_ipa_passes);\n+}\n \f\n \n /* Update recursively all inlined_to pointers of functions"}, {"sha": "c9fdd852ec2df6c9a92a502647056a1856927473", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48610900e267a7335dd1315e32733d8ef4092dc/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48610900e267a7335dd1315e32733d8ef4092dc/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=b48610900e267a7335dd1315e32733d8ef4092dc", "patch": "@@ -106,6 +106,7 @@ struct dump_file_info\n #define TODO_verify_stmts\t\t(1 << 4)\n #define TODO_cleanup_cfg        \t(1 << 5)\n #define TODO_verify_loops\t\t(1 << 6)\n+#define TODO_dump_cgraph\t\t(1 << 7)\n \n /* To-do flags for calls to update_ssa.  */\n \n@@ -153,6 +154,8 @@ struct dump_file_info\n #define TODO_verify_all \\\n   (TODO_verify_ssa | TODO_verify_flow | TODO_verify_stmts)\n \n+extern void ipa_passes (void);\n+\n extern struct tree_opt_pass pass_mudflap_1;\n extern struct tree_opt_pass pass_mudflap_2;\n extern struct tree_opt_pass pass_remove_useless_stmts;\n@@ -214,4 +217,6 @@ extern struct tree_opt_pass pass_vrp;\n extern struct tree_opt_pass pass_create_structure_vars;\n extern struct tree_opt_pass pass_uncprop;\n \n+extern struct tree_opt_pass pass_ipa_inline;\n+\n #endif /* GCC_TREE_PASS_H */"}]}