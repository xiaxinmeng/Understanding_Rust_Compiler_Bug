{"sha": "1af1688bcde2b1df29d8edd65676d72dc416cb48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWFmMTY4OGJjZGUyYjFkZjI5ZDhlZGQ2NTY3NmQ3MmRjNDE2Y2I0OA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1991-11-24T19:01:50Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1991-11-24T19:01:50Z"}, "message": "Initial revision\n\nFrom-SVN: r70", "tree": {"sha": "a2b32d2638afbda0308e5d3d5269d0f1cd6af137", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2b32d2638afbda0308e5d3d5269d0f1cd6af137"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1af1688bcde2b1df29d8edd65676d72dc416cb48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1af1688bcde2b1df29d8edd65676d72dc416cb48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1af1688bcde2b1df29d8edd65676d72dc416cb48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1af1688bcde2b1df29d8edd65676d72dc416cb48/comments", "author": null, "committer": null, "parents": [{"sha": "a46ecc2682bca14ed082bba33566f8c8b7d51a0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a46ecc2682bca14ed082bba33566f8c8b7d51a0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a46ecc2682bca14ed082bba33566f8c8b7d51a0d"}], "stats": {"total": 729, "additions": 729, "deletions": 0}, "files": [{"sha": "7a40daab4463b7af6e8ad33951e006b7055418e3", "filename": "gcc/rtl.def", "status": "added", "additions": 729, "deletions": 0, "changes": 729, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1af1688bcde2b1df29d8edd65676d72dc416cb48/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1af1688bcde2b1df29d8edd65676d72dc416cb48/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=1af1688bcde2b1df29d8edd65676d72dc416cb48", "patch": "@@ -0,0 +1,729 @@\n+/* This file contains the definitions and documentation for the\n+   Register Transfer Expressions (rtx's) that make up the\n+   Register Transfer Language (rtl) used in the Back End of the GNU compiler.\n+   Copyright (C) 1987-1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* Expression definitions and descriptions for all targets are in this file.\n+   Some will not be used for some targets.\n+\n+   The fields in the cpp macro call \"DEF_RTL_EXPR()\"\n+   are used to create declarations in the C source of the compiler.\n+\n+   The fields are:\n+\n+   1.  The internal name of the rtx used in the C source.\n+   It is a tag in the enumeration \"enum rtx_code\" defined in \"rtl.h\".\n+   By convention these are in UPPER_CASE.\n+\n+   2.  The name of the rtx in the external ASCII format read by\n+   read_rtx(), and printed by print_rtx().\n+   These names are stored in rtx_name[].\n+   By convention these are the internal (field 1) names in lower_case.\n+\n+   3.  The print format, and type of each rtx->fld[] (field) in this rtx.\n+   These formats are stored in rtx_format[].\n+   The meaning of the formats is documented in front of this array in rtl.c\n+   \n+   4.  The class of the rtx.  These are stored in rtx_class and are accessed\n+   via the GET_RTX_CLASS macro.  They are defined as follows:\n+\n+     \"o\" an rtx code that can be used to represent an object (e.g, REG, MEM)\n+     \"<\" an rtx code for a comparison (e.g, EQ, NE, LT)\n+     \"1\" an rtx code for a unary arithmetic expression (e.g, NEG, NOT)\n+     \"c\" an rtx code for a commutative binary operation (e.g,, PLUS, MULT)\n+     \"3\" an rtx code for a non-bitfield three input operation (IF_THEN_ELSE)\n+     \"2\" an rtx code for a non-commutative binary operation (e.g., MINUS, DIV)\n+     \"b\" an rtx code for a bit-field operation (ZERO_EXTRACT, SIGN_EXTRACT)\n+     \"i\" an rtx code for a machine insn (INSN, JUMP_INSN, CALL_INSN)\n+     \"m\" an rtx code for something that matches in insns (e.g, MATCH_DUP)\n+     \"x\" everything else\n+     \n+   */\n+\n+/* ---------------------------------------------------------------------\n+   Expressions (and \"meta\" expressions) used for structuring the\n+   rtl representation of a program.\n+   --------------------------------------------------------------------- */\n+\n+/* an expression code name unknown to the reader */\n+DEF_RTL_EXPR(UNKNOWN, \"UnKnown\", \"*\", 'x')\n+\n+/* (NIL) is used by rtl reader and printer to represent a null pointer.  */\n+\n+DEF_RTL_EXPR(NIL, \"nil\", \"*\", 'x')\n+\n+/* ---------------------------------------------------------------------\n+   Expressions used in constructing lists.\n+   --------------------------------------------------------------------- */\n+\n+/* a linked list of expressions */\n+DEF_RTL_EXPR(EXPR_LIST, \"expr_list\", \"ee\", 'x')\n+\n+/* a linked list of instructions.\n+   The insns are represented in print by their uids.  */\n+DEF_RTL_EXPR(INSN_LIST, \"insn_list\", \"ue\", 'x')\n+\n+/* ----------------------------------------------------------------------\n+   Expression types for machine descripions.\n+   These do not appear in actual rtl code in the compiler.\n+   ---------------------------------------------------------------------- */\n+\n+/* Appears only in machine descriptions.\n+   Means use the function named by the second arg (the string)\n+   as a predicate; if matched, store the structure that was matched\n+   in the operand table at index specified by the first arg (the integer).\n+   If the second arg is the null string, the structure is just stored.\n+\n+   A third string argument indicates to the register allocator restrictions\n+   on where the operand can be allocated.\n+\n+   If the target needs no restriction on any instruction this field should\n+   be the null string.\n+\n+   The string is prepended by:\n+   '=' to indicate the operand is only written to.\n+   '+' to indicate the operand is both read and written to.\n+\n+   Each character in the string represents an allocatable class for an operand.\n+   'g' indicates the operand can be any valid class.\n+   'i' indicates the operand can be immediate (in the instruction) data.\n+   'r' indicates the operand can be in a register.\n+   'm' indicates the operand can be in memory.\n+   'o' a subset of the 'm' class.  Those memory addressing modes that\n+       can be offset at compile time (have a constant added to them).\n+\n+   Other characters indicate target dependent operand classes and\n+   are described in each target's machine description.\n+\n+   For instructions with more than one operand, sets of classes can be\n+   separated by a comma to indicate the appropriate multi-operand constraints.\n+   There must be a 1 to 1 correspondence between these sets of classes in\n+   all operands for an instruction.\n+   */\n+DEF_RTL_EXPR(MATCH_OPERAND, \"match_operand\", \"iss\", 'm')\n+\n+/* Appears only in machine descriptions.\n+   Means match a SCRATCH or a register.  When used to generate rtl, a\n+   SCRATCH is generated.  As for MATCH_OPERAND, the mode specifies\n+   the desired mode and the first argument is the operand number.\n+   The second argument is the constraint.  */\n+DEF_RTL_EXPR(MATCH_SCRATCH, \"match_scratch\", \"is\", 'm')\n+\n+/* Appears only in machine descriptions.\n+   Means match only something equal to what is stored in the operand table\n+   at the index specified by the argument.  */\n+DEF_RTL_EXPR(MATCH_DUP, \"match_dup\", \"i\", 'm')\n+\n+/* Appears only in machine descriptions.\n+   Means apply a predicate, AND match recursively the operands of the rtx.\n+   Operand 0 is the operand-number, as in match_operand.\n+   Operand 1 is a predicate to apply (as a string, a function name).\n+   Operand 2 is a vector of expressions, each of which must match\n+   one subexpression of the rtx this construct is matching.  */\n+DEF_RTL_EXPR(MATCH_OPERATOR, \"match_operator\", \"isE\", 'm')\n+\n+/* Appears only in machine descriptions.\n+   Means to match a PARALLEL of arbitrary length.  The predicate is applied\n+   to the PARALLEL and the initial expressions in the PARALLEL are matched.\n+   Operand 0 is the operand-number, as in match_operand.\n+   Operand 1 is a predicate to apply to the PARALLEL.\n+   Operand 2 is a vector of expressions, each of which must match the \n+   corresponding element in the PARALLEL.  */\n+DEF_RTL_EXPR(MATCH_PARALLEL, \"match_parallel\", \"isE\", 'm')\n+\n+/* Appears only in machine descriptions.\n+   Means match only something equal to what is stored in the operand table\n+   at the index specified by the argument.  For MATCH_OPERATOR.  */\n+DEF_RTL_EXPR(MATCH_OP_DUP, \"match_op_dup\", \"iE\", 'm')\n+\n+/* Appears only in machine descriptions.\n+   Defines the pattern for one kind of instruction.\n+   Operand:\n+   0: names this instruction.\n+      If the name is the null string, the instruction is in the\n+      machine description just to be recognized, and will never be emitted by\n+      the tree to rtl expander.\n+   1: is the pattern.\n+   2: is a string which is a C expression\n+      giving an additional condition for recognizing this pattern.\n+      A null string means no extra condition.\n+   3: is the action to execute if this pattern is matched.\n+      If this assembler code template starts with a * then it is a fragment of\n+      C code to run to decide on a template to use.  Otherwise, it is the\n+      template to use.\n+   4: optionally, a vector of attributes for this insn.\n+     */\n+DEF_RTL_EXPR(DEFINE_INSN, \"define_insn\", \"sEssV\", 'x')\n+\n+/* Definition of a peephole optimization.\n+   1st operand: vector of insn patterns to match\n+   2nd operand: C expression that must be true\n+   3rd operand: template or C code to produce assembler output.\n+   4: optionally, a vector of attributes for this insn.\n+     */\n+DEF_RTL_EXPR(DEFINE_PEEPHOLE, \"define_peephole\", \"EssV\", 'x')\n+\n+/* Definition of a split operation.\n+   1st operand: insn pattern to match\n+   2nd operand: C expression that must be true\n+   3rd operand: vector of insn patterns to place into a SEQUENCE\n+   4th operand: optionally, some C code to execute before generating the\n+\tinsns.  This might, for example, create some RTX's and store them in\n+\telements of `recog_operand' for use by the vector of insn-patterns.\n+\t(`operands' is an alias here for `recog_operand').   */\n+DEF_RTL_EXPR(DEFINE_SPLIT, \"define_split\", \"EsES\", 'x')\n+\n+/* Definition of a combiner pattern.\n+   Operands not defined yet.  */\n+DEF_RTL_EXPR(DEFINE_COMBINE, \"define_combine\", \"Ess\", 'x')\n+\n+/* Define how to generate multiple insns for a standard insn name.\n+   1st operand: the insn name.\n+   2nd operand: vector of insn-patterns.\n+\tUse match_operand to substitute an element of `recog_operand'.\n+   3rd operand: C expression that must be true for this to be available.\n+\tThis may not test any operands.\n+   4th operand: Extra C code to execute before generating the insns.\n+\tThis might, for example, create some RTX's and store them in\n+\telements of `recog_operand' for use by the vector of insn-patterns.\n+\t(`operands' is an alias here for `recog_operand').  */\n+DEF_RTL_EXPR(DEFINE_EXPAND, \"define_expand\", \"sEss\", 'x')\n+   \n+/* Define a requirement for delay slots.\n+   1st operand: Condition involving insn attributes that, if true,\n+\t        indicates that the insn requires the number of delay slots\n+\t\tshown.\n+   2nd operand: Vector whose length is the three times the number of delay\n+\t\tslots required.\n+\t        Each entry gives three conditions, each involving attributes.\n+\t\tThe first must be true for an insn to occupy that delay slot\n+\t\tlocation.  The second is true for all insns that can be\n+\t\tannulled if the branch is true and the third is true for all\n+\t\tinsns that can be annulled if the branch is false. \n+\n+   Multiple DEFINE_DELAYs may be present.  They indicate differing\n+   requirements for delay slots.  */\n+DEF_RTL_EXPR(DEFINE_DELAY, \"define_delay\", \"eE\", 'x')\n+\n+/* Define a set of insns that requires a function unit.  This means that\n+   these insns produce their result after a delay and that there may be\n+   restrictions on the number of insns of this type that can be scheduled\n+   simultaneously.\n+\n+   More than one DEFINE_FUNCTION_UNIT can be specified for a function unit.\n+   Each gives a set of operations and associated delays.  The first three\n+   operands must be the same for each operation for the same function unit.\n+\n+   All delays are specified in units of COST_PER_CYCLE.\n+\n+   1st operand: Name of function unit (mostly for documentation)\n+   2nd operand: Number of identical function units in CPU\n+   3rd operand: Total number of simultaneous insns that can execute on this\n+\t\tfunction unit; 0 if unlimited.\n+   4th operand: Condition involving insn attribute, that, if true, specifies\n+\t\tthose insns that this expression applies to.\n+   5th operand: Constant delay after which insn result will be\n+\t\tavailable.\n+   6th operand: Delay until next insn can be scheduled on the function unit\n+\t\texecuting this operation.  The meaning depends on whether or\n+\t\tnot the next operand is supplied.\n+   7th operand: If this operand is not specified, the 6th operand gives the\n+\t\tcost of scheduling another operation on this unit while a\n+\t\tprevious one is active.  A value of zero should be used for a\n+\t\tpipelined unit.  If only one operation can be executed a time\n+\t\tand the unit is busy for the entire time, the 3rd operand\n+\t\tshould be specified as 1 and the 6th and 7th operands will\n+\t\tbe ignored.\n+\n+\t\tIf this operand is specified, it is a list of attribute\n+\t\texpressions.  If an insn for which any of these expressions\n+\t\tis true is currently executing on the function unit, the\n+\t\tdelay will be given by the 6th operand.  Otherwise, the\n+\t\tinsn can be immediately scheduled (subject to the limit on\n+\t\tthe number of simultaneous operations executing on the\n+\t\tunit.)  */\n+DEF_RTL_EXPR(DEFINE_FUNCTION_UNIT, \"define_function_unit\", \"siieiiV\", 'x')\n+\n+/* Define attribute computation for `asm' instructions.  */\n+DEF_RTL_EXPR(DEFINE_ASM_ATTRIBUTES, \"define_asm_attributes\", \"V\", 'x' )\n+\n+/* SEQUENCE appears in the result of a `gen_...' function\n+   for a DEFINE_EXPAND that wants to make several insns.\n+   Its elements are the bodies of the insns that should be made.\n+   `emit_insn' takes the SEQUENCE apart and makes separate insns.  */\n+DEF_RTL_EXPR(SEQUENCE, \"sequence\", \"E\", 'x')\n+\n+/* Refers to the address of its argument.\n+   This appears only in machine descriptions, indicating that\n+   any expression that would be acceptable as the operand of MEM\n+   should be matched.  */\n+DEF_RTL_EXPR(ADDRESS, \"address\", \"e\", 'm')\n+\n+/* ----------------------------------------------------------------------\n+   Expressions used for insn attributes.  These also do not appear in\n+   actual rtl code in the compiler.\n+   ---------------------------------------------------------------------- */\n+\n+/* Definition of an insn attribute.\n+   1st operand: name of the attribute\n+   2nd operand: comma-separated list of possible attribute values\n+   3rd operand: expression for the default value of the attribute. */\n+DEF_RTL_EXPR(DEFINE_ATTR, \"define_attr\", \"sse\", 'x')\n+\n+/* Marker for the name of an attribute. */\n+DEF_RTL_EXPR(ATTR, \"attr\", \"s\", 'x')\n+\n+/* For use in the last (optional) operand of DEFINE_INSN or DEFINE_PEEPHOLE and\n+   in DEFINE_ASM_INSN to specify an attribute to assign to insns matching that\n+   pattern.\n+\n+   (set_attr \"name\" \"value\") is equivalent to\n+   (set (attr \"name\") (const_string \"value\"))  */\n+DEF_RTL_EXPR(SET_ATTR, \"set_attr\", \"ss\", 'x')\n+\n+/* In the last operand of DEFINE_INSN and DEFINE_PEEPHOLE, this can be used to\n+   specify that attribute values are to be assigned according to the\n+   alternative matched.\n+\n+   The following three expressions are equivalent:\n+\n+   (set (attr \"att\") (cond [(eq_attrq \"alternative\" \"1\") (const_string \"a1\")\n+\t\t\t    (eq_attrq \"alternative\" \"2\") (const_string \"a2\")]\n+\t\t\t   (const_string \"a3\")))\n+   (set_attr_alternative \"att\" [(const_string \"a1\") (const_string \"a2\")\n+\t\t\t\t (const_string \"a3\")])\n+   (set_attr \"att\" \"a1,a2,a3\")\n+ */\n+DEF_RTL_EXPR(SET_ATTR_ALTERNATIVE, \"set_attr_alternative\", \"sE\", 'x')\n+\n+/* A conditional expression true if the value of the specified attribute of\n+   the current insn equals the specified value.  The first operand is the\n+   attribute name and the second is the comparison value.  */\n+DEF_RTL_EXPR(EQ_ATTR, \"eq_attr\", \"ss\", 'x')\n+\n+/* ----------------------------------------------------------------------\n+   Expression types used for things in the instruction chain.\n+\n+   All formats must start with \"iuu\" to handle the chain.\n+   Each insn expression holds an rtl instruction and its semantics\n+   during back-end processing.\n+   See macros's in \"rtl.h\" for the meaning of each rtx->fld[].\n+\n+   ---------------------------------------------------------------------- */\n+\n+/* An instruction that cannot jump.  */\n+DEF_RTL_EXPR(INSN, \"insn\", \"iuueiee\", 'i')\n+\n+/* An instruction that can possibly jump.\n+   Fields ( rtx->fld[] ) have exact same meaning as INSN's.  */\n+DEF_RTL_EXPR(JUMP_INSN, \"jump_insn\", \"iuueiee0\", 'i')\n+\n+/* An instruction that can possibly call a subroutine\n+   but which will not change which instruction comes next\n+   in the current function.\n+   Fields ( rtx->fld[] ) have exact same meaning as INSN's.  */\n+DEF_RTL_EXPR(CALL_INSN, \"call_insn\", \"iuueiee\", 'i')\n+\n+/* A marker that indicates that control will not flow through.  */\n+DEF_RTL_EXPR(BARRIER, \"barrier\", \"iuu\", 'x')\n+\n+/* Holds a label that is followed by instructions.\n+   Operand:\n+   3: is a number that is unique in the entire compilation.\n+   4: is the user-given name of the label, if any.\n+   5: is used in jump.c for the use-count of the label.\n+   and in flow.c to point to the chain of label_ref's to this label.  */\n+DEF_RTL_EXPR(CODE_LABEL, \"code_label\", \"iuuis0\", 'x')\n+     \n+/* Say where in the code a source line starts, for symbol table's sake.\n+   Contains a filename and a line number.  Line numbers <= 0 are special:\n+   0 is used in a dummy placed at the front of every function\n+      just so there will never be a need to delete the first insn;\n+   -1 indicates a dummy; insns to be deleted by flow analysis and combining\n+      are really changed to NOTEs with a number of -1.\n+   -2 means beginning of a name binding contour; output N_LBRAC.\n+   -3 means end of a contour; output N_RBRAC.  */\n+DEF_RTL_EXPR(NOTE, \"note\", \"iuusn\", 'x')\n+\n+/* INLINE_HEADER is use by inline function machinery.  The information\n+   it contains helps to build the mapping function between the rtx's of\n+   the function to be inlined and the current function being expanded.  */\n+\n+DEF_RTL_EXPR(INLINE_HEADER, \"inline_header\", \"iuuuiiiiiieiiEe\", 'x')\n+\n+/* ----------------------------------------------------------------------\n+   Top level constituents of INSN, JUMP_INSN and CALL_INSN.\n+   ---------------------------------------------------------------------- */\n+   \n+/* Several operations to be done in parallel.  */\n+DEF_RTL_EXPR(PARALLEL, \"parallel\", \"E\", 'x')\n+\n+/* A string that is passed through to the assembler as input.\n+     One can obviously pass comments through by using the\n+     assembler comment syntax.\n+     These occur in an insn all by themselves as the PATTERN.\n+     They also appear inside an ASM_OPERANDS\n+     as a convenient way to hold a string.  */\n+DEF_RTL_EXPR(ASM_INPUT, \"asm_input\", \"s\", 'x')\n+\n+/* An assembler instruction with operands.\n+   1st operand is the instruction template.\n+   2nd operand is the constraint for the output.\n+   3rd operand is the number of the output this expression refers to.\n+     When an insn stores more than one value, a separate ASM_OPERANDS\n+     is made for each output; this integer distinguishes them.\n+   4th is a vector of values of input operands.\n+   5th is a vector of modes and constraints for the input operands.\n+     Each element is an ASM_INPUT containing a constraint string\n+     and whose mode indicates the mode of the input operand.\n+   6th is the name of the containing source file.\n+   7th is the source line number.  */\n+DEF_RTL_EXPR(ASM_OPERANDS, \"asm_operands\", \"ssiEEsi\", 'x')\n+\n+/* Vector of addresses, stored as full words.  */\n+/* Each element is a LABEL_REF to a CODE_LABEL whose address we want.  */\n+DEF_RTL_EXPR(ADDR_VEC, \"addr_vec\", \"E\", 'x')\n+\n+/* Vector of address differences X0 - BASE, X1 - BASE, ...\n+   First operand is BASE; the vector contains the X's.\n+   The machine mode of this rtx says how much space to leave\n+   for each difference.  */\n+DEF_RTL_EXPR(ADDR_DIFF_VEC, \"addr_diff_vec\", \"eE\", 'x')\n+\n+/* ----------------------------------------------------------------------\n+   At the top level of an instruction (perhaps under PARALLEL).\n+   ---------------------------------------------------------------------- */\n+\n+/* Assignment.\n+   Operand 1 is the location (REG, MEM, PC, CC0 or whatever) assigned to.\n+   Operand 2 is the value stored there.\n+   ALL assignment must use SET.\n+   Instructions that do multiple assignments must use multiple SET,\n+   under PARALLEL.  */\n+DEF_RTL_EXPR(SET, \"set\", \"ee\", 'x')\n+\n+/* Indicate something is used in a way that we don't want to explain.\n+   For example, subroutine calls will use the register\n+   in which the static chain is passed.  */\n+DEF_RTL_EXPR(USE, \"use\", \"e\", 'x')\n+\n+/* Indicate something is clobbered in a way that we don't want to explain.\n+   For example, subroutine calls will clobber some physical registers\n+   (the ones that are by convention not saved).  */\n+DEF_RTL_EXPR(CLOBBER, \"clobber\", \"e\", 'x')\n+\n+/* Call a subroutine.\n+   Operand 1 is the address to call.\n+   Operand 2 is the number of arguments.  */\n+\n+DEF_RTL_EXPR(CALL, \"call\", \"ee\", 'x')\n+\n+/* Return from a subroutine.  */\n+\n+DEF_RTL_EXPR(RETURN, \"return\", \"\", 'x')\n+\n+/* Conditional trap.\n+   Operand 1 is the condition.\n+   Operand 2 is the trap code.\n+   For an unconditional trap, make the condition (const_int 1).  */\n+DEF_RTL_EXPR(TRAP_IF, \"trap_if\", \"ei\", 'x')\n+\n+/* ----------------------------------------------------------------------\n+   Primitive values for use in expressions.\n+   ---------------------------------------------------------------------- */\n+\n+/* numeric integer constant */\n+DEF_RTL_EXPR(CONST_INT, \"const_int\", \"i\", 'o')\n+\n+/* numeric double constant.\n+   Operand 0 is the MEM that stores this constant in memory,\n+   or various other things (see comments at immed_double_const in varasm.c).\n+   Operand 1 is a chain of all CONST_DOUBLEs in use in the current function.\n+   Remaining operands hold the actual value.\n+   The number of operands may be more than 2 if cross-compiling;\n+   see init_rtl.  */\n+DEF_RTL_EXPR(CONST_DOUBLE, \"const_double\", \"e0ii\", 'o')\n+\n+/* String constant.  Used only for attributes right now.  */\n+DEF_RTL_EXPR(CONST_STRING, \"const_string\", \"s\", 'o')\n+\n+/* This is used to encapsulate an expression whose value is constant\n+   (such as the sum of a SYMBOL_REF and a CONST_INT) so that it will be\n+   recognized as a constant operand rather than by arithmetic instructions.  */\n+\n+DEF_RTL_EXPR(CONST, \"const\", \"e\", 'o')\n+\n+/* program counter.  Ordinary jumps are represented\n+   by a SET whose first operand is (PC).  */\n+DEF_RTL_EXPR(PC, \"pc\", \"\", 'o')\n+\n+/* A register.  The \"operand\" is the register number, accessed\n+   with the REGNO macro.  If this number is less than FIRST_PSEUDO_REGISTER\n+   than a hardware register is being referred to.  */\n+DEF_RTL_EXPR(REG, \"reg\", \"i\", 'o')\n+\n+/* A scratch register.  This represents a register used only within a\n+   single insn.  It will be turned into a REG during register allocation\n+   or reload unless the constraint indicates that the register won't be\n+   needed, in which case it can remain a SCRATCH.  This code is\n+   marked as having one operand so it can be turned into a REG.  */\n+DEF_RTL_EXPR(SCRATCH, \"scratch\", \"0\", 'o')\n+\n+/* One word of a multi-word value.\n+   The first operand is the complete value; the second says which word.\n+   The WORDS_BIG_ENDIAN flag controls whether word number 0\n+   (as numbered in a SUBREG) is the most or least significant word.\n+\n+   This is also used to refer to a value in a different machine mode.\n+   For example, it can be used to refer to a SImode value as if it were\n+   Qimode, or vice versa.  Then the word number is always 0.  */\n+DEF_RTL_EXPR(SUBREG, \"subreg\", \"ei\", 'x')\n+\n+/* This one-argument rtx is used for move instructions\n+   that are guaranteed to alter only the low part of a destination.\n+   Thus, (SET (SUBREG:HI (REG...)) (MEM:HI ...))\n+   has an unspecified effect on the high part of REG,\n+   but (SET (STRICT_LOW_PART (SUBREG:HI (REG...))) (MEM:HI ...))\n+   is guaranteed to alter only the bits of REG that are in HImode.\n+\n+   The actual instruction used is probably the same in both cases,\n+   but the register constraints may be tighter when STRICT_LOW_PART\n+   is in use.  */\n+\n+DEF_RTL_EXPR(STRICT_LOW_PART, \"strict_low_part\", \"e\", 'x')\n+\n+/* A memory location; operand is the address.\n+   Can be nested inside a VOLATILE.  */\n+DEF_RTL_EXPR(MEM, \"mem\", \"e\", 'o')\n+\n+/* Reference to an assembler label in the code for this function.\n+   The operand is a CODE_LABEL found in the insn chain.\n+   The unprinted fields 1 and 2 are used in flow.c for the\n+   LABEL_NEXTREF and CONTAINING_INSN.  */\n+DEF_RTL_EXPR(LABEL_REF, \"label_ref\", \"u00\", 'o')\n+\n+/* Reference to a named label: the string that is the first operand,\n+   with `_' added implicitly in front.\n+   Exception: if the first character explicitly given is `*',\n+   to give it to the assembler, remove the `*' and do not add `_'.  */\n+DEF_RTL_EXPR(SYMBOL_REF, \"symbol_ref\", \"s\", 'o')\n+\n+/* The condition code register is represented, in our imagination,\n+   as a register holding a value that can be compared to zero.\n+   In fact, the machine has already compared them and recorded the\n+   results; but instructions that look at the condition code\n+   pretend to be looking at the entire value and comparing it.  */\n+DEF_RTL_EXPR(CC0, \"cc0\", \"\", 'o')\n+\n+/* =====================================================================\n+   A QUEUED expression really points to a member of the queue of instructions\n+   to be output later for postincrement/postdecrement.\n+   QUEUED expressions never become part of instructions.\n+   When a QUEUED expression would be put into an instruction,\n+   instead either the incremented variable or a copy of its previous\n+   value is used.\n+   \n+   Operands are:\n+   0. the variable to be incremented (a REG rtx).\n+   1. the incrementing instruction, or 0 if it hasn't been output yet.\n+   2. A REG rtx for a copy of the old value of the variable, or 0 if none yet.\n+   3. the body to use for the incrementing instruction\n+   4. the next QUEUED expression in the queue.\n+   ====================================================================== */\n+\n+DEF_RTL_EXPR(QUEUED, \"queued\", \"eeeee\", 'x')\n+\n+/* ----------------------------------------------------------------------\n+   Expressions for operators in an rtl pattern\n+   ---------------------------------------------------------------------- */\n+\n+/* if_then_else.  This is used in representing ordinary\n+   conditional jump instructions.\n+     Operand:\n+     0:  condition\n+     1:  then expr\n+     2:  else expr */\n+DEF_RTL_EXPR(IF_THEN_ELSE, \"if_then_else\", \"eee\", '3')\n+\n+/* General conditional. The first operand is a vector composed of pairs of\n+   expressions.  The first element of each pair is evaluated, in turn.\n+   The value of the conditional is the second expression of the first pair\n+   whose first expression evaluates non-zero.  If none of the expressions is\n+   true, the second operand will be used as the value of the conditional.\n+\n+   This should be replaced with use of IF_THEN_ELSE.  */\n+DEF_RTL_EXPR(COND, \"cond\", \"Ee\", 'x')\n+\n+/* Comparison, produces a condition code result.  */\n+DEF_RTL_EXPR(COMPARE, \"compare\", \"ee\", '2')\n+\n+/* plus */\n+DEF_RTL_EXPR(PLUS, \"plus\", \"ee\", 'c')\n+\n+/* Operand 0 minus operand 1.  */\n+DEF_RTL_EXPR(MINUS, \"minus\", \"ee\", '2')\n+\n+/* Minus operand 0.  */\n+DEF_RTL_EXPR(NEG, \"neg\", \"e\", '1')\n+\n+DEF_RTL_EXPR(MULT, \"mult\", \"ee\", 'c')\n+\n+/* Operand 0 divided by operand 1.  */\n+DEF_RTL_EXPR(DIV, \"div\", \"ee\", '2')\n+/* Remainder of operand 0 divided by operand 1.  */\n+DEF_RTL_EXPR(MOD, \"mod\", \"ee\", '2')\n+\n+/* Unsigned divide and remainder.  */\n+DEF_RTL_EXPR(UDIV, \"udiv\", \"ee\", '2')\n+DEF_RTL_EXPR(UMOD, \"umod\", \"ee\", '2')\n+\n+/* Bitwise operations.  */\n+DEF_RTL_EXPR(AND, \"and\", \"ee\", 'c')\n+\n+DEF_RTL_EXPR(IOR, \"ior\", \"ee\", 'c')\n+\n+DEF_RTL_EXPR(XOR, \"xor\", \"ee\", 'c')\n+\n+DEF_RTL_EXPR(NOT, \"not\", \"e\", '1')\n+\n+/* Operand:\n+     0:  value to be shifted.\n+     1:  number of bits.\n+   ASHIFT and LSHIFT are distinguished because on some machines\n+   these allow a negative operand and shift right in that case.  */\n+DEF_RTL_EXPR(LSHIFT, \"lshift\", \"ee\", '2')\n+DEF_RTL_EXPR(ASHIFT, \"ashift\", \"ee\", '2')\n+DEF_RTL_EXPR(ROTATE, \"rotate\", \"ee\", '2')\n+\n+/* Right shift operations, for machines where these are not the same\n+   as left shifting with a negative argument.  */\n+\n+DEF_RTL_EXPR(ASHIFTRT, \"ashiftrt\", \"ee\", '2')\n+DEF_RTL_EXPR(LSHIFTRT, \"lshiftrt\", \"ee\", '2')\n+DEF_RTL_EXPR(ROTATERT, \"rotatert\", \"ee\", '2')\n+\n+/* Minimum and maximum values of two operands.  We need both signed and\n+   unsigned forms.  (We cannot use MIN for SMIN because it conflicts\n+   with a macro of the same name.) */\n+\n+DEF_RTL_EXPR(SMIN, \"smin\", \"ee\", 'c')\n+DEF_RTL_EXPR(SMAX, \"smax\", \"ee\", 'c')\n+DEF_RTL_EXPR(UMIN, \"umin\", \"ee\", 'c')\n+DEF_RTL_EXPR(UMAX, \"umax\", \"ee\", 'c')\n+\n+/* These unary operations are used to represent incrementation\n+   and decrementation as they occur in memory addresses.\n+   The amount of increment or decrement are not represented\n+   because they can be understood from the machine-mode of the\n+   containing MEM.  These operations exist in only two cases:\n+   1. pushes onto the stack.\n+   2. created automatically by the life_analysis pass in flow.c.  */\n+DEF_RTL_EXPR(PRE_DEC, \"pre_dec\", \"e\", 'x')\n+DEF_RTL_EXPR(PRE_INC, \"pre_inc\", \"e\", 'x')\n+DEF_RTL_EXPR(POST_DEC, \"post_dec\", \"e\", 'x')\n+DEF_RTL_EXPR(POST_INC, \"post_inc\", \"e\", 'x')\n+\n+/* Comparison operations.  The ordered comparisons exist in two\n+   flavors, signed and unsigned.  */\n+DEF_RTL_EXPR(NE, \"ne\", \"ee\", '<')\n+DEF_RTL_EXPR(EQ, \"eq\", \"ee\", '<')\n+DEF_RTL_EXPR(GE, \"ge\", \"ee\", '<')\n+DEF_RTL_EXPR(GT, \"gt\", \"ee\", '<')\n+DEF_RTL_EXPR(LE, \"le\", \"ee\", '<')\n+DEF_RTL_EXPR(LT, \"lt\", \"ee\", '<')\n+DEF_RTL_EXPR(GEU, \"geu\", \"ee\", '<')\n+DEF_RTL_EXPR(GTU, \"gtu\", \"ee\", '<')\n+DEF_RTL_EXPR(LEU, \"leu\", \"ee\", '<')\n+DEF_RTL_EXPR(LTU, \"ltu\", \"ee\", '<')\n+\n+/* Represents the result of sign-extending the sole operand.\n+   The machine modes of the operand and of the SIGN_EXTEND expression\n+   determine how much sign-extension is going on.  */\n+DEF_RTL_EXPR(SIGN_EXTEND, \"sign_extend\", \"e\", '1')\n+\n+/* Similar for zero-extension (such as unsigned short to int).  */\n+DEF_RTL_EXPR(ZERO_EXTEND, \"zero_extend\", \"e\", '1')\n+\n+/* Similar but here the operand has a wider mode.  */\n+DEF_RTL_EXPR(TRUNCATE, \"truncate\", \"e\", '1')\n+\n+/* Similar for extending floating-point values (such as SFmode to DFmode).  */\n+DEF_RTL_EXPR(FLOAT_EXTEND, \"float_extend\", \"e\", '1')\n+DEF_RTL_EXPR(FLOAT_TRUNCATE, \"float_truncate\", \"e\", '1')\n+\n+/* Conversion of fixed point operand to floating point value.  */\n+DEF_RTL_EXPR(FLOAT, \"float\", \"e\", '1')\n+\n+/* With fixed-point machine mode:\n+   Conversion of floating point operand to fixed point value.\n+   Value is defined only when the operand's value is an integer.\n+   With floating-point machine mode (and operand with same mode):\n+   Operand is rounded toward zero to produce an integer value\n+   represented in floating point.  */\n+DEF_RTL_EXPR(FIX, \"fix\", \"e\", '1')\n+\n+/* Conversion of unsigned fixed point operand to floating point value.  */\n+DEF_RTL_EXPR(UNSIGNED_FLOAT, \"unsigned_float\", \"e\", '1')\n+\n+/* With fixed-point machine mode:\n+   Conversion of floating point operand to *unsigned* fixed point value.\n+   Value is defined only when the operand's value is an integer.  */\n+DEF_RTL_EXPR(UNSIGNED_FIX, \"unsigned_fix\", \"e\", '1')\n+\n+/* Absolute value */\n+DEF_RTL_EXPR(ABS, \"abs\", \"e\", '1')\n+\n+/* Square root */\n+DEF_RTL_EXPR(SQRT, \"sqrt\", \"e\", '1')\n+\n+/* Find first bit that is set.\n+   Value is 1 + number of trailing zeros in the arg.,\n+   or 0 if arg is 0.  */\n+DEF_RTL_EXPR(FFS, \"ffs\", \"e\", '1')\n+\n+/* Reference to a signed bit-field of specified size and position.\n+   Operand 0 is the memory unit (usually SImode or QImode) which\n+   contains the field's first bit.  Operand 1 is the width, in bits.\n+   Operand 2 is the number of bits in the memory unit before the\n+   first bit of this field.\n+   If BITS_BIG_ENDIAN is defined, the first bit is the msb and\n+   operand 2 counts from the msb of the memory unit.\n+   Otherwise, the first bit is the lsb and operand 2 counts from\n+   the lsb of the memory unit.  */\n+DEF_RTL_EXPR(SIGN_EXTRACT, \"sign_extract\", \"eee\", 'b')\n+\n+/* Similar for unsigned bit-field.  */\n+DEF_RTL_EXPR(ZERO_EXTRACT, \"zero_extract\", \"eee\", 'b')\n+\n+/* For RISC machines.  These save memory when splitting insns.  */\n+\n+/* HIGH are the high-order bits of a constant expression.  */\n+DEF_RTL_EXPR(HIGH, \"high\", \"e\", 'o')\n+\n+/* LO_SUM is the sum of a register and the low-order bits\n+   of a constant expression.  */\n+DEF_RTL_EXPR(LO_SUM, \"lo_sum\", \"ee\", 'o')\n+\n+/*\n+Local variables:\n+mode:c\n+version-control: t\n+End:\n+*/"}]}