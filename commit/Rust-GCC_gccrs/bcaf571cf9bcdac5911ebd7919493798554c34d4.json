{"sha": "bcaf571cf9bcdac5911ebd7919493798554c34d4", "node_id": "C_kwDOANBUbNoAKGJjYWY1NzFjZjliY2RhYzU5MTFlYmQ3OTE5NDkzNzk4NTU0YzM0ZDQ", "commit": {"author": {"name": "chenglulu", "email": "chenglulu@loongson.cn", "date": "2021-11-27T06:50:20Z"}, "committer": {"name": "Chenghua Xu", "email": "paul.hua.gm@gmail.com", "date": "2022-03-29T09:43:33Z"}, "message": "LoongArch Port: Machine description files.\n\n2022-03-29  Chenghua Xu  <xuchenghua@loongson.cn>\n\t    Lulu Cheng  <chenglulu@loongson.cn>\n\ngcc/ChangeLog:\n\n\t* config/loongarch/constraints.md: New file.\n\t* config/loongarch/generic.md: New file.\n\t* config/loongarch/la464.md: New file.\n\t* config/loongarch/loongarch-ftypes.def: New file.\n\t* config/loongarch/loongarch-modes.def: New file.\n\t* config/loongarch/loongarch.md: New file.\n\t* config/loongarch/predicates.md: New file.\n\t* config/loongarch/sync.md: New file.", "tree": {"sha": "4b16cb59626d8f0763bbbb18acb0f257399fc855", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b16cb59626d8f0763bbbb18acb0f257399fc855"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bcaf571cf9bcdac5911ebd7919493798554c34d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcaf571cf9bcdac5911ebd7919493798554c34d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcaf571cf9bcdac5911ebd7919493798554c34d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcaf571cf9bcdac5911ebd7919493798554c34d4/comments", "author": {"login": "chenglulu326", "id": 88083425, "node_id": "MDQ6VXNlcjg4MDgzNDI1", "avatar_url": "https://avatars.githubusercontent.com/u/88083425?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenglulu326", "html_url": "https://github.com/chenglulu326", "followers_url": "https://api.github.com/users/chenglulu326/followers", "following_url": "https://api.github.com/users/chenglulu326/following{/other_user}", "gists_url": "https://api.github.com/users/chenglulu326/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenglulu326/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenglulu326/subscriptions", "organizations_url": "https://api.github.com/users/chenglulu326/orgs", "repos_url": "https://api.github.com/users/chenglulu326/repos", "events_url": "https://api.github.com/users/chenglulu326/events{/privacy}", "received_events_url": "https://api.github.com/users/chenglulu326/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ChenghuaXu", "id": 87753117, "node_id": "MDQ6VXNlcjg3NzUzMTE3", "avatar_url": "https://avatars.githubusercontent.com/u/87753117?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChenghuaXu", "html_url": "https://github.com/ChenghuaXu", "followers_url": "https://api.github.com/users/ChenghuaXu/followers", "following_url": "https://api.github.com/users/ChenghuaXu/following{/other_user}", "gists_url": "https://api.github.com/users/ChenghuaXu/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChenghuaXu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChenghuaXu/subscriptions", "organizations_url": "https://api.github.com/users/ChenghuaXu/orgs", "repos_url": "https://api.github.com/users/ChenghuaXu/repos", "events_url": "https://api.github.com/users/ChenghuaXu/events{/privacy}", "received_events_url": "https://api.github.com/users/ChenghuaXu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "225761396df8c98f1a1ac88da46ff401bd326e56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/225761396df8c98f1a1ac88da46ff401bd326e56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/225761396df8c98f1a1ac88da46ff401bd326e56"}], "stats": {"total": 4762, "additions": 4762, "deletions": 0}, "files": [{"sha": "d0bfddbd5a9c48a085ce0607afc2bdc8316929fc", "filename": "gcc/config/loongarch/constraints.md", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcaf571cf9bcdac5911ebd7919493798554c34d4/gcc%2Fconfig%2Floongarch%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcaf571cf9bcdac5911ebd7919493798554c34d4/gcc%2Fconfig%2Floongarch%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Fconstraints.md?ref=bcaf571cf9bcdac5911ebd7919493798554c34d4", "patch": "@@ -0,0 +1,202 @@\n+;; Constraint definitions for LoongArch.\n+;; Copyright (C) 2021-2022 Free Software Foundation, Inc.\n+;; Contributed by Loongson Ltd.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; Register constraints\n+\n+;; \"a\" \"A constant call global and noplt address.\"\n+;; \"b\" <-----unused\n+;; \"c\" \"A constant call local address.\"\n+;; \"d\" <-----unused\n+;; \"e\" JIRL_REGS\n+;; \"f\" FP_REGS\n+;; \"g\" <-----unused\n+;; \"h\" \"A constant call plt address.\"\n+;; \"i\" \"Matches a general integer constant.\" (Global non-architectural)\n+;; \"j\" SIBCALL_REGS\n+;; \"k\" \"A memory operand whose address is formed by a base register and\n+;;      (optionally scaled) index register.\"\n+;; \"l\" \"A signed 16-bit constant.\"\n+;; \"m\" \"A memory operand whose address is formed by a base register and offset\n+;;      that is suitable for use in instructions with the same addressing mode\n+;;      as @code{st.w} and @code{ld.w}.\"\n+;; \"n\" \"Matches a non-symbolic integer constant.\" (Global non-architectural)\n+;; \"o\" \"Matches an offsettable memory reference.\" (Global non-architectural)\n+;; \"p\" \"Matches a general address.\" (Global non-architectural)\n+;; \"q\" CSR_REGS\n+;; \"r\" GENERAL_REGS (Global non-architectural)\n+;; \"s\" \"Matches a symbolic integer constant.\" (Global non-architectural)\n+;; \"t\" \"A constant call weak address\"\n+;; \"u\" \"A signed 52bit constant and low 32-bit is zero (for logic instructions)\"\n+;; \"v\" \"A signed 64-bit constant and low 44-bit is zero (for logic instructions).\"\n+;; \"w\" \"Matches any valid memory.\"\n+;; \"x\" <-----unused\n+;; \"y\" <-----unused\n+;; \"z\" FCC_REGS\n+;; \"A\" <-----unused\n+;; \"B\" <-----unused\n+;; \"C\" <-----unused\n+;; \"D\" <-----unused\n+;; \"E\" \"Matches a floating-point constant.\" (Global non-architectural)\n+;; \"F\" \"Matches a floating-point constant.\" (Global non-architectural)\n+;; \"G\" \"Floating-point zero.\"\n+;; \"H\" <-----unused\n+;; \"I\" \"A signed 12-bit constant (for arithmetic instructions).\"\n+;; \"J\" \"Integer zero.\"\n+;; \"K\" \"An unsigned 12-bit constant (for logic instructions).\"\n+;; \"L\" <-----unused\n+;; \"M\" <-----unused\n+;; \"N\" <-----unused\n+;; \"O\" <-----unused\n+;; \"P\" <-----unused\n+;; \"Q\" <-----unused\n+;; \"R\" <-----unused\n+;; \"S\" <-----unused\n+;; \"T\" <-----unused\n+;; \"U\" <-----unused\n+;; \"V\" \"Matches a non-offsettable memory reference.\" (Global non-architectural)\n+;; \"W\" <-----unused\n+;; \"X\" \"Matches anything.\" (Global non-architectural)\n+;; \"Y\" -\n+;;    \"Yd\"\n+;;       \"A constant @code{move_operand} that can be safely loaded using\n+;;\t  @code{la}.\"\n+;;    \"Yx\"\n+;; \"Z\" -\n+;;    \"ZC\"\n+;;      \"A memory operand whose address is formed by a base register and offset\n+;;       that is suitable for use in instructions with the same addressing mode\n+;;       as @code{ll.w} and @code{sc.w}.\"\n+;;    \"ZB\"\n+;;      \"An address that is held in a general-purpose register.\n+;;      The offset is zero\"\n+;; \"<\" \"Matches a pre-dec or post-dec operand.\" (Global non-architectural)\n+;; \">\" \"Matches a pre-inc or post-inc operand.\" (Global non-architectural)\n+\n+(define_constraint \"a\"\n+  \"@internal\n+   A constant call global and noplt address.\"\n+  (match_operand 0 \"is_const_call_global_noplt_symbol\"))\n+\n+(define_constraint \"c\"\n+  \"@internal\n+   A constant call local address.\"\n+  (match_operand 0 \"is_const_call_local_symbol\"))\n+\n+(define_register_constraint \"e\" \"JIRL_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"f\" \"TARGET_HARD_FLOAT ? FP_REGS : NO_REGS\"\n+  \"A floating-point register (if available).\")\n+\n+(define_constraint \"h\"\n+  \"@internal\n+   A constant call plt address.\"\n+  (match_operand 0 \"is_const_call_plt_symbol\"))\n+\n+(define_register_constraint \"j\" \"SIBCALL_REGS\"\n+  \"@internal\")\n+\n+(define_memory_constraint \"k\"\n+  \"A memory operand whose address is formed by a base register and (optionally scaled)\n+   index register.\"\n+  (and (match_code \"mem\")\n+       (match_test \"loongarch_base_index_address_p (XEXP (op, 0), mode)\")))\n+\n+(define_constraint \"l\"\n+\"A signed 16-bit constant.\"\n+(and (match_code \"const_int\")\n+     (match_test \"IMM16_OPERAND (ival)\")))\n+\n+(define_memory_constraint \"m\"\n+  \"A memory operand whose address is formed by a base register and offset\n+   that is suitable for use in instructions with the same addressing mode\n+   as @code{st.w} and @code{ld.w}.\"\n+  (and (match_code \"mem\")\n+       (match_test \"loongarch_12bit_offset_address_p (XEXP (op, 0), mode)\")))\n+\n+(define_register_constraint \"q\" \"CSR_REGS\"\n+  \"A general-purpose register except for $r0 and $r1 for lcsr.\")\n+\n+(define_constraint \"t\"\n+  \"@internal\n+   A constant call weak address.\"\n+  (match_operand 0 \"is_const_call_weak_symbol\"))\n+\n+(define_constraint \"u\"\n+  \"A signed 52bit constant and low 32-bit is zero (for logic instructions).\"\n+  (and (match_code \"const_int\")\n+       (match_test \"LU32I_OPERAND (ival)\")))\n+\n+(define_constraint \"v\"\n+  \"A signed 64-bit constant and low 44-bit is zero (for logic instructions).\"\n+  (and (match_code \"const_int\")\n+       (match_test \"LU52I_OPERAND (ival)\")))\n+\n+(define_register_constraint \"z\" \"FCC_REGS\"\n+  \"A floating-point condition code register.\")\n+\n+;; Floating-point constraints\n+\n+(define_constraint \"G\"\n+  \"Floating-point zero.\"\n+  (and (match_code \"const_double\")\n+       (match_test \"op == CONST0_RTX (mode)\")))\n+\n+;; Integer constraints\n+\n+(define_constraint \"I\"\n+  \"A signed 12-bit constant (for arithmetic instructions).\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IMM12_OPERAND (ival)\")))\n+\n+(define_constraint \"J\"\n+  \"Integer zero.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 0\")))\n+\n+(define_constraint \"K\"\n+  \"An unsigned 12-bit constant (for logic instructions).\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IMM12_OPERAND_UNSIGNED (ival)\")))\n+\n+(define_constraint \"Yd\"\n+  \"@internal\n+   A constant @code{move_operand} that can be safely loaded using\n+   @code{la}.\"\n+  (and (match_operand 0 \"move_operand\")\n+       (match_test \"CONSTANT_P (op)\")))\n+\n+(define_constraint \"Yx\"\n+   \"@internal\"\n+   (match_operand 0 \"low_bitmask_operand\"))\n+\n+(define_memory_constraint \"ZC\"\n+  \"A memory operand whose address is formed by a base register and offset\n+   that is suitable for use in instructions with the same addressing mode\n+   as @code{ll.w} and @code{sc.w}.\"\n+  (and (match_code \"mem\")\n+       (match_test \"loongarch_14bit_shifted_offset_address_p (XEXP (op, 0), mode)\")))\n+\n+(define_memory_constraint \"ZB\"\n+  \"@internal\n+  An address that is held in a general-purpose register.\n+  The offset is zero\"\n+  (and (match_code \"mem\")\n+       (match_test \"REG_P (XEXP (op, 0))\")))"}, {"sha": "6e5a0934d053a31c7d86e3e5da304969bfc8ed99", "filename": "gcc/config/loongarch/generic.md", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcaf571cf9bcdac5911ebd7919493798554c34d4/gcc%2Fconfig%2Floongarch%2Fgeneric.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcaf571cf9bcdac5911ebd7919493798554c34d4/gcc%2Fconfig%2Floongarch%2Fgeneric.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Fgeneric.md?ref=bcaf571cf9bcdac5911ebd7919493798554c34d4", "patch": "@@ -0,0 +1,118 @@\n+;; Generic DFA-based pipeline description for LoongArch targets\n+;; Copyright (C) 2021-2022 Free Software Foundation, Inc.\n+;; Contributed by Loongson Ltd.\n+;; Based on MIPS target for GNU compiler.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_automaton \"alu,imuldiv\")\n+\n+(define_cpu_unit \"alu\" \"alu\")\n+(define_cpu_unit \"imuldiv\" \"imuldiv\")\n+\n+;; Ghost instructions produce no real code.\n+;; They exist purely to express an effect on dataflow.\n+(define_insn_reservation \"ghost\" 0\n+  (eq_attr \"type\" \"ghost\")\n+  \"nothing\")\n+\n+(define_insn_reservation \"generic_alu\" 1\n+  (eq_attr \"type\" \"unknown,prefetch,prefetchx,condmove,const,arith,\n+\t\t   shift,slt,clz,trap,multi,nop,logical,signext,move\")\n+  \"alu\")\n+\n+(define_insn_reservation \"generic_load\" 3\n+  (eq_attr \"type\" \"load,fpload,fpidxload\")\n+  \"alu\")\n+\n+(define_insn_reservation \"generic_store\" 1\n+  (eq_attr \"type\" \"store,fpstore,fpidxstore\")\n+  \"alu\")\n+\n+(define_insn_reservation \"generic_xfer\" 2\n+  (eq_attr \"type\" \"mftg,mgtf\")\n+  \"alu\")\n+\n+(define_insn_reservation \"generic_branch\" 1\n+  (eq_attr \"type\" \"branch,jump,call\")\n+  \"alu\")\n+\n+(define_insn_reservation \"generic_imul\" 17\n+  (eq_attr \"type\" \"imul\")\n+  \"imuldiv*17\")\n+\n+(define_insn_reservation \"generic_fcvt\" 1\n+  (eq_attr \"type\" \"fcvt\")\n+  \"alu\")\n+\n+(define_insn_reservation \"generic_fmove\" 2\n+  (eq_attr \"type\" \"fabs,fneg,fmove\")\n+  \"alu\")\n+\n+(define_insn_reservation \"generic_fcmp\" 3\n+  (eq_attr \"type\" \"fcmp\")\n+  \"alu\")\n+\n+(define_insn_reservation \"generic_fadd\" 4\n+  (eq_attr \"type\" \"fadd\")\n+  \"alu\")\n+\n+(define_insn_reservation \"generic_fmul_single\" 7\n+  (and (eq_attr \"type\" \"fmul,fmadd\")\n+       (eq_attr \"mode\" \"SF\"))\n+  \"alu\")\n+\n+(define_insn_reservation \"generic_fmul_double\" 8\n+  (and (eq_attr \"type\" \"fmul,fmadd\")\n+       (eq_attr \"mode\" \"DF\"))\n+  \"alu\")\n+\n+(define_insn_reservation \"generic_fdiv_single\" 23\n+  (and (eq_attr \"type\" \"fdiv,frdiv\")\n+       (eq_attr \"mode\" \"SF\"))\n+  \"alu\")\n+\n+(define_insn_reservation \"generic_fdiv_double\" 36\n+  (and (eq_attr \"type\" \"fdiv,frdiv\")\n+       (eq_attr \"mode\" \"DF\"))\n+  \"alu\")\n+\n+(define_insn_reservation \"generic_fsqrt_single\" 54\n+  (and (eq_attr \"type\" \"fsqrt,frsqrt\")\n+       (eq_attr \"mode\" \"SF\"))\n+  \"alu\")\n+\n+(define_insn_reservation \"generic_fsqrt_double\" 112\n+  (and (eq_attr \"type\" \"fsqrt,frsqrt\")\n+       (eq_attr \"mode\" \"DF\"))\n+  \"alu\")\n+\n+(define_insn_reservation \"generic_atomic\" 10\n+  (eq_attr \"type\" \"atomic\")\n+  \"alu\")\n+\n+;; Sync loop consists of (in order)\n+;; (1) optional sync,\n+;; (2) LL instruction,\n+;; (3) branch and 1-2 ALU instructions,\n+;; (4) SC instruction,\n+;; (5) branch and ALU instruction.\n+;; The net result of this reservation is a big delay with a flush of\n+;; ALU pipeline.\n+(define_insn_reservation \"generic_sync_loop\" 40\n+  (eq_attr \"type\" \"syncloop\")\n+  \"alu*39\")"}, {"sha": "0ae177610c99ea2a36255b6b7dd24fde126d4e98", "filename": "gcc/config/loongarch/la464.md", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcaf571cf9bcdac5911ebd7919493798554c34d4/gcc%2Fconfig%2Floongarch%2Fla464.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcaf571cf9bcdac5911ebd7919493798554c34d4/gcc%2Fconfig%2Floongarch%2Fla464.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Fla464.md?ref=bcaf571cf9bcdac5911ebd7919493798554c34d4", "patch": "@@ -0,0 +1,132 @@\n+;; Pipeline model for LoongArch LA464 cores.\n+\n+;; Copyright (C) 2021-2022 Free Software Foundation, Inc.\n+;; Contributed by Loongson Ltd.\n+\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; Uncomment the following line to output automata for debugging.\n+;; (automata_option \"v\")\n+\n+;; Automaton for integer instructions.\n+(define_automaton \"la464_a_alu\")\n+\n+;; Automaton for floating-point instructions.\n+(define_automaton \"la464_a_falu\")\n+\n+;; Automaton for memory operations.\n+(define_automaton \"la464_a_mem\")\n+\n+;; Describe the resources.\n+\n+(define_cpu_unit \"la464_alu1\" \"la464_a_alu\")\n+(define_cpu_unit \"la464_alu2\" \"la464_a_alu\")\n+(define_cpu_unit \"la464_mem1\" \"la464_a_mem\")\n+(define_cpu_unit \"la464_mem2\" \"la464_a_mem\")\n+(define_cpu_unit \"la464_falu1\" \"la464_a_falu\")\n+(define_cpu_unit \"la464_falu2\" \"la464_a_falu\")\n+\n+;; Describe instruction reservations.\n+\n+(define_insn_reservation \"la464_arith\" 1\n+  (and (match_test \"TARGET_TUNE_LA464\")\n+       (eq_attr \"type\" \"arith,clz,const,logical,\n+\t\t\tmove,nop,shift,signext,slt\"))\n+  \"la464_alu1 | la464_alu2\")\n+\n+(define_insn_reservation \"la464_branch\" 1\n+  (and (match_test \"TARGET_TUNE_LA464\")\n+       (eq_attr \"type\" \"branch,jump,call,condmove,trap\"))\n+  \"la464_alu1 | la464_alu2\")\n+\n+(define_insn_reservation \"la464_imul\" 7\n+  (and (match_test \"TARGET_TUNE_LA464\")\n+       (eq_attr \"type\" \"imul\"))\n+  \"la464_alu1 | la464_alu2\")\n+\n+(define_insn_reservation \"la464_idiv_si\" 12\n+  (and (match_test \"TARGET_TUNE_LA464\")\n+       (and (eq_attr \"type\" \"idiv\")\n+\t    (eq_attr \"mode\" \"SI\")))\n+  \"la464_alu1 | la464_alu2\")\n+\n+(define_insn_reservation \"la464_idiv_di\" 25\n+  (and (match_test \"TARGET_TUNE_LA464\")\n+       (and (eq_attr \"type\" \"idiv\")\n+\t    (eq_attr \"mode\" \"DI\")))\n+  \"la464_alu1 | la464_alu2\")\n+\n+(define_insn_reservation \"la464_load\" 4\n+  (and (match_test \"TARGET_TUNE_LA464\")\n+       (eq_attr \"type\" \"load\"))\n+  \"la464_mem1 | la464_mem2\")\n+\n+(define_insn_reservation \"la464_gpr_fp\" 16\n+  (and (match_test \"TARGET_TUNE_LA464\")\n+       (eq_attr \"type\" \"mftg,mgtf\"))\n+  \"la464_mem1\")\n+\n+(define_insn_reservation \"la464_fpload\" 4\n+  (and (match_test \"TARGET_TUNE_LA464\")\n+       (eq_attr \"type\" \"fpload\"))\n+  \"la464_mem1 | la464_mem2\")\n+\n+(define_insn_reservation \"la464_prefetch\" 0\n+  (and (match_test \"TARGET_TUNE_LA464\")\n+       (eq_attr \"type\" \"prefetch,prefetchx\"))\n+  \"la464_mem1 | la464_mem2\")\n+\n+(define_insn_reservation \"la464_store\" 0\n+  (and (match_test \"TARGET_TUNE_LA464\")\n+       (eq_attr \"type\" \"store,fpstore,fpidxstore\"))\n+  \"la464_mem1 | la464_mem2\")\n+\n+(define_insn_reservation \"la464_fadd\" 4\n+  (and (match_test \"TARGET_TUNE_LA464\")\n+       (eq_attr \"type\" \"fadd,fmul,fmadd\"))\n+  \"la464_falu1 | la464_falu2\")\n+\n+(define_insn_reservation \"la464_fcmp\" 2\n+  (and (match_test \"TARGET_TUNE_LA464\")\n+       (eq_attr \"type\" \"fabs,fcmp,fmove,fneg\"))\n+  \"la464_falu1 | la464_falu2\")\n+\n+(define_insn_reservation \"la464_fcvt\" 4\n+  (and (match_test \"TARGET_TUNE_LA464\")\n+       (eq_attr \"type\" \"fcvt\"))\n+  \"la464_falu1 | la464_falu2\")\n+\n+(define_insn_reservation \"la464_fdiv_sf\" 12\n+  (and (match_test \"TARGET_TUNE_LA464\")\n+       (and (eq_attr \"type\" \"fdiv,frdiv,fsqrt,frsqrt\")\n+\t    (eq_attr \"mode\" \"SF\")))\n+  \"la464_falu1 | la464_falu2\")\n+\n+(define_insn_reservation \"la464_fdiv_df\" 19\n+  (and (match_test \"TARGET_TUNE_LA464\")\n+       (and (eq_attr \"type\" \"fdiv,frdiv,fsqrt,frsqrt\")\n+\t    (eq_attr \"mode\" \"DF\")))\n+  \"la464_falu1 | la464_falu2\")\n+\n+;; Force single-dispatch for unknown or multi.\n+(define_insn_reservation \"la464_unknown\" 1\n+  (and (match_test \"TARGET_TUNE_LA464\")\n+       (eq_attr \"type\" \"unknown,multi,atomic,syncloop\"))\n+  \"la464_alu1 + la464_alu2 + la464_falu1\n+   + la464_falu2 + la464_mem1 + la464_mem2\")\n+\n+;; End of DFA-based pipeline description for la464"}, {"sha": "2babff414a23540166b18f8b2d04bb24c03134fb", "filename": "gcc/config/loongarch/loongarch-ftypes.def", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcaf571cf9bcdac5911ebd7919493798554c34d4/gcc%2Fconfig%2Floongarch%2Floongarch-ftypes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcaf571cf9bcdac5911ebd7919493798554c34d4/gcc%2Fconfig%2Floongarch%2Floongarch-ftypes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Floongarch-ftypes.def?ref=bcaf571cf9bcdac5911ebd7919493798554c34d4", "patch": "@@ -0,0 +1,65 @@\n+/* Definitions of prototypes for LoongArch built-in functions.\n+   Copyright (C) 2021-2022 Free Software Foundation, Inc.\n+   Contributed by Loongson Ltd.\n+   Based on MIPS target for GNU ckompiler.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Invoke DEF_LARCH_FTYPE (NARGS, LIST) for each prototype used by\n+   LoongArch built-in functions, where:\n+\n+      NARGS is the number of arguments.\n+      LIST contains the return-type code followed by the codes for each\n+      argument type.\n+\n+   Argument- and return-type codes are either modes or one of the following:\n+\n+      VOID for void_type_node\n+      INT for integer_type_node\n+      POINTER for ptr_type_node\n+\n+   (we don't use PTR because that's a ANSI-compatibillity macro).\n+\n+   Please keep this list lexicographically sorted by the LIST argument.  */\n+\n+DEF_LARCH_FTYPE (1, (UQI, USI))\n+DEF_LARCH_FTYPE (1, (UHI, USI))\n+DEF_LARCH_FTYPE (1, (USI, USI))\n+DEF_LARCH_FTYPE (1, (UDI, USI))\n+DEF_LARCH_FTYPE (1, (USI, UQI))\n+DEF_LARCH_FTYPE (1, (VOID, USI))\n+\n+DEF_LARCH_FTYPE (2, (VOID, UQI, USI))\n+DEF_LARCH_FTYPE (2, (VOID, UHI, USI))\n+DEF_LARCH_FTYPE (2, (VOID, USI, USI))\n+DEF_LARCH_FTYPE (2, (VOID, UDI, USI))\n+DEF_LARCH_FTYPE (2, (VOID, DI, UQI))\n+DEF_LARCH_FTYPE (2, (VOID, SI, UQI))\n+DEF_LARCH_FTYPE (2, (VOID, DI, DI))\n+DEF_LARCH_FTYPE (2, (SI, SI, UQI))\n+DEF_LARCH_FTYPE (2, (DI, DI, UQI))\n+DEF_LARCH_FTYPE (2, (SI, QI, SI))\n+DEF_LARCH_FTYPE (2, (SI, HI, SI))\n+DEF_LARCH_FTYPE (2, (SI, SI, SI))\n+DEF_LARCH_FTYPE (2, (SI, DI, SI))\n+DEF_LARCH_FTYPE (2, (USI, USI, USI))\n+DEF_LARCH_FTYPE (2, (UDI, UDI, USI))\n+\n+DEF_LARCH_FTYPE (3, (VOID, USI, USI, SI))\n+DEF_LARCH_FTYPE (3, (VOID, USI, UDI, SI))\n+DEF_LARCH_FTYPE (3, (USI, USI, USI, USI))\n+DEF_LARCH_FTYPE (3, (UDI, UDI, UDI, USI))"}, {"sha": "7f06e2d6547b0e017377b20f1d6ddef20497275a", "filename": "gcc/config/loongarch/loongarch-modes.def", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcaf571cf9bcdac5911ebd7919493798554c34d4/gcc%2Fconfig%2Floongarch%2Floongarch-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcaf571cf9bcdac5911ebd7919493798554c34d4/gcc%2Fconfig%2Floongarch%2Floongarch-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Floongarch-modes.def?ref=bcaf571cf9bcdac5911ebd7919493798554c34d4", "patch": "@@ -0,0 +1,25 @@\n+/* LoongArch extra machine modes.\n+   Copyright (C) 2021-2022 Free Software Foundation, Inc.\n+   Contributed by Loongson Ltd.\n+   Based on MIPS target for GNU compiler.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+FLOAT_MODE (TF, 16, ieee_quad_format);\n+\n+/* For floating point conditions in FCC registers.  */\n+CC_MODE (FCC);"}, {"sha": "6c57c8b70254633f474caa7fa0aa930c566f008b", "filename": "gcc/config/loongarch/loongarch.md", "status": "added", "additions": 3393, "deletions": 0, "changes": 3393, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcaf571cf9bcdac5911ebd7919493798554c34d4/gcc%2Fconfig%2Floongarch%2Floongarch.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcaf571cf9bcdac5911ebd7919493798554c34d4/gcc%2Fconfig%2Floongarch%2Floongarch.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Floongarch.md?ref=bcaf571cf9bcdac5911ebd7919493798554c34d4"}, {"sha": "edd74d4783d501c2292f7e45513c391315809d32", "filename": "gcc/config/loongarch/predicates.md", "status": "added", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcaf571cf9bcdac5911ebd7919493798554c34d4/gcc%2Fconfig%2Floongarch%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcaf571cf9bcdac5911ebd7919493798554c34d4/gcc%2Fconfig%2Floongarch%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Fpredicates.md?ref=bcaf571cf9bcdac5911ebd7919493798554c34d4", "patch": "@@ -0,0 +1,253 @@\n+;; Predicate definitions for LoongArch target.\n+;; Copyright (C) 2021-2022 Free Software Foundation, Inc.\n+;; Contributed by Loongson Ltd.\n+;; Based on MIPS target for GNU compiler.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_predicate \"const_uns_arith_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IMM12_OPERAND_UNSIGNED (INTVAL (op))\")))\n+\n+(define_predicate \"uns_arith_operand\"\n+  (ior (match_operand 0 \"const_uns_arith_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"const_lu32i_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"LU32I_OPERAND (INTVAL (op))\")))\n+\n+(define_predicate \"const_lu52i_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"LU52I_OPERAND (INTVAL (op))\")))\n+\n+(define_predicate \"const_arith_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IMM12_OPERAND (INTVAL (op))\")))\n+\n+(define_predicate \"const_imm16_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IMM16_OPERAND (INTVAL (op))\")))\n+\n+(define_predicate \"arith_operand\"\n+  (ior (match_operand 0 \"const_arith_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"const_immalsl_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 1, 4)\")))\n+\n+(define_predicate \"const_uimm5_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 0, 31)\")))\n+\n+(define_predicate \"const_uimm14_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 0, 16383)\")))\n+\n+(define_predicate \"const_uimm15_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 0, 32767)\")))\n+\n+(define_predicate \"const_imm12_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IMM12_OPERAND (INTVAL (op))\")))\n+\n+(define_predicate \"sle_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IMM12_OPERAND (INTVAL (op) + 1)\")))\n+\n+(define_predicate \"sleu_operand\"\n+  (and (match_operand 0 \"sle_operand\")\n+       (match_test \"INTVAL (op) + 1 != 0\")))\n+\n+(define_predicate \"const_0_operand\"\n+  (and (match_code \"const_int,const_double,const_vector\")\n+       (match_test \"op == CONST0_RTX (GET_MODE (op))\")))\n+\n+(define_predicate \"reg_or_0_operand\"\n+  (ior (match_operand 0 \"const_0_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"const_1_operand\"\n+  (and (match_code \"const_int,const_double,const_vector\")\n+       (match_test \"op == CONST1_RTX (GET_MODE (op))\")))\n+\n+(define_predicate \"reg_or_1_operand\"\n+  (ior (match_operand 0 \"const_1_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"const_0_to_3_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 0, 3)\")))\n+\n+(define_predicate \"const_0_to_7_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 0, 7)\")))\n+\n+(define_predicate \"lu52i_mask_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"UINTVAL (op) == 0xfffffffffffff\")))\n+\n+(define_predicate \"low_bitmask_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"low_bitmask_len (mode, INTVAL (op)) > 12\")))\n+\n+(define_predicate \"const_call_insn_operand\"\n+  (match_code \"const,symbol_ref,label_ref\")\n+{\n+  enum loongarch_symbol_type symbol_type;\n+\n+  if (!loongarch_symbolic_constant_p (op, &symbol_type))\n+    return false;\n+\n+  switch (symbol_type)\n+    {\n+    case SYMBOL_GOT_DISP:\n+      /* Without explicit relocs, there is no special syntax for\n+\t loading the address of a call destination into a register.\n+\t Using \"la.global JIRL_REGS,foo; jirl JIRL_REGS\" would prevent the lazy\n+\t binding of \"foo\", so keep the address of global symbols with the jirl\n+\t macro.  */\n+      return 1;\n+\n+    default:\n+      return false;\n+    }\n+})\n+\n+(define_predicate \"call_insn_operand\"\n+  (ior (match_operand 0 \"const_call_insn_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"is_const_call_local_symbol\"\n+  (and (match_operand 0 \"const_call_insn_operand\")\n+       (ior (match_test \"loongarch_global_symbol_p (op) == 0\")\n+\t    (match_test \"loongarch_symbol_binds_local_p (op) != 0\"))\n+       (match_test \"CONSTANT_P (op)\")))\n+\n+(define_predicate \"is_const_call_weak_symbol\"\n+  (and (match_operand 0 \"const_call_insn_operand\")\n+       (not (match_operand 0 \"is_const_call_local_symbol\"))\n+       (match_test \"loongarch_weak_symbol_p (op) != 0\")\n+       (match_test \"CONSTANT_P (op)\")))\n+\n+(define_predicate \"is_const_call_plt_symbol\"\n+  (and (match_operand 0 \"const_call_insn_operand\")\n+       (match_test \"flag_plt != 0\")\n+       (match_test \"loongarch_global_symbol_noweak_p (op) != 0\")\n+       (match_test \"CONSTANT_P (op)\")))\n+\n+(define_predicate \"is_const_call_global_noplt_symbol\"\n+  (and (match_operand 0 \"const_call_insn_operand\")\n+       (match_test \"flag_plt == 0\")\n+       (match_test \"loongarch_global_symbol_noweak_p (op) != 0\")\n+       (match_test \"CONSTANT_P (op)\")))\n+\n+;; A legitimate CONST_INT operand that takes more than one instruction\n+;; to load.\n+(define_predicate \"splittable_const_int_operand\"\n+  (match_code \"const_int\")\n+{\n+  /* Don't handle multi-word moves this way; we don't want to introduce\n+     the individual word-mode moves until after reload.  */\n+  if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n+    return false;\n+\n+  /* Otherwise check whether the constant can be loaded in a single\n+     instruction.  */\n+  return !LU12I_INT (op) && !IMM12_INT (op) && !IMM12_INT_UNSIGNED (op)\n+\t && !LU52I_INT (op);\n+})\n+\n+(define_predicate \"move_operand\"\n+  (match_operand 0 \"general_operand\")\n+{\n+  enum loongarch_symbol_type symbol_type;\n+\n+  /* The thinking here is as follows:\n+\n+     (1) The move expanders should split complex load sequences into\n+\t individual instructions.  Those individual instructions can\n+\t then be optimized by all rtl passes.\n+\n+     (2) The target of pre-reload load sequences should not be used\n+\t to store temporary results.  If the target register is only\n+\t assigned one value, reload can rematerialize that value\n+\t on demand, rather than spill it to the stack.\n+\n+     (3) If we allowed pre-reload passes like combine and cse to recreate\n+\t complex load sequences, we would want to be able to split the\n+\t sequences before reload as well, so that the pre-reload scheduler\n+\t can see the individual instructions.  This falls foul of (2);\n+\t the splitter would be forced to reuse the target register for\n+\t intermediate results.\n+\n+     (4) We want to define complex load splitters for combine.  These\n+\t splitters can request a temporary scratch register, which avoids\n+\t the problem in (2).  They allow things like:\n+\n+\t      (set (reg T1) (high SYM))\n+\t      (set (reg T2) (low (reg T1) SYM))\n+\t      (set (reg X) (plus (reg T2) (const_int OFFSET)))\n+\n+\t to be combined into:\n+\n+\t      (set (reg T3) (high SYM+OFFSET))\n+\t      (set (reg X) (lo_sum (reg T3) SYM+OFFSET))\n+\n+\t if T2 is only used this once.  */\n+  switch (GET_CODE (op))\n+    {\n+    case CONST_INT:\n+      return !splittable_const_int_operand (op, mode);\n+\n+    case CONST:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return (loongarch_symbolic_constant_p (op, &symbol_type));\n+    default:\n+      return true;\n+    }\n+})\n+\n+(define_predicate \"symbolic_operand\"\n+  (match_code \"const,symbol_ref,label_ref\")\n+{\n+  enum loongarch_symbol_type type;\n+  return loongarch_symbolic_constant_p (op, &type);\n+})\n+\n+(define_predicate \"equality_operator\"\n+  (match_code \"eq,ne\"))\n+\n+(define_predicate \"order_operator\"\n+  (match_code \"lt,ltu,le,leu,ge,geu,gt,gtu\"))\n+\n+;; For NE, cstore uses sltu instructions in which the first operand is $0.\n+\n+(define_predicate \"loongarch_cstore_operator\"\n+  (match_code \"ne,eq,gt,gtu,ge,geu,lt,ltu,le,leu\"))\n+\n+(define_predicate \"small_data_pattern\"\n+  (and (match_code \"set,parallel,unspec,unspec_volatile,prefetch\")\n+       (match_test \"loongarch_small_data_pattern_p (op)\")))\n+\n+;; Return 1 if the operand is in non-volatile memory.\n+(define_predicate \"non_volatile_mem_operand\"\n+  (and (match_operand 0 \"memory_operand\")\n+       (not (match_test \"MEM_VOLATILE_P (op)\"))))"}, {"sha": "0c4f1983e889d3409bd4d5c0099635ab54dfa873", "filename": "gcc/config/loongarch/sync.md", "status": "added", "additions": 574, "deletions": 0, "changes": 574, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcaf571cf9bcdac5911ebd7919493798554c34d4/gcc%2Fconfig%2Floongarch%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcaf571cf9bcdac5911ebd7919493798554c34d4/gcc%2Fconfig%2Floongarch%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Fsync.md?ref=bcaf571cf9bcdac5911ebd7919493798554c34d4", "patch": "@@ -0,0 +1,574 @@\n+;; Machine description for LoongArch atomic operations.\n+;; Copyright (C) 2021-2022 Free Software Foundation, Inc.\n+;; Contributed by Loongson Ltd.\n+;; Based on MIPS and RISC-V target for GNU compiler.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_c_enum \"unspec\" [\n+  UNSPEC_COMPARE_AND_SWAP\n+  UNSPEC_COMPARE_AND_SWAP_ADD\n+  UNSPEC_COMPARE_AND_SWAP_SUB\n+  UNSPEC_COMPARE_AND_SWAP_AND\n+  UNSPEC_COMPARE_AND_SWAP_XOR\n+  UNSPEC_COMPARE_AND_SWAP_OR\n+  UNSPEC_COMPARE_AND_SWAP_NAND\n+  UNSPEC_SYNC_OLD_OP\n+  UNSPEC_SYNC_EXCHANGE\n+  UNSPEC_ATOMIC_STORE\n+  UNSPEC_MEMORY_BARRIER\n+])\n+\n+(define_code_iterator any_atomic [plus ior xor and])\n+(define_code_attr atomic_optab\n+  [(plus \"add\") (ior \"or\") (xor \"xor\") (and \"and\")])\n+\n+;; This attribute gives the format suffix for atomic memory operations.\n+(define_mode_attr amo [(SI \"w\") (DI \"d\")])\n+\n+;; <amop> expands to the name of the atomic operand that implements a\n+;; particular code.\n+(define_code_attr amop [(ior \"or\") (xor \"xor\") (and \"and\") (plus \"add\")])\n+\n+;; Memory barriers.\n+\n+(define_expand \"mem_thread_fence\"\n+  [(match_operand:SI 0 \"const_int_operand\" \"\")] ;; model\n+  \"\"\n+{\n+  if (INTVAL (operands[0]) != MEMMODEL_RELAXED)\n+    {\n+      rtx mem = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));\n+      MEM_VOLATILE_P (mem) = 1;\n+      emit_insn (gen_mem_thread_fence_1 (mem, operands[0]));\n+    }\n+  DONE;\n+})\n+\n+;; Until the LoongArch memory model (hence its mapping from C++) is finalized,\n+;; conservatively emit a full FENCE.\n+(define_insn \"mem_thread_fence_1\"\n+  [(set (match_operand:BLK 0 \"\" \"\")\n+\t(unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))\n+   (match_operand:SI 1 \"const_int_operand\" \"\")] ;; model\n+  \"\"\n+  \"dbar\\t0\")\n+\n+;; Atomic memory operations.\n+\n+;; Implement atomic stores with amoswap.  Fall back to fences for atomic loads.\n+(define_insn \"atomic_store<mode>\"\n+  [(set (match_operand:GPR 0 \"memory_operand\" \"+ZB\")\n+    (unspec_volatile:GPR\n+      [(match_operand:GPR 1 \"reg_or_0_operand\" \"rJ\")\n+       (match_operand:SI 2 \"const_int_operand\")]      ;; model\n+      UNSPEC_ATOMIC_STORE))]\n+  \"\"\n+  \"amswap%A2.<amo>\\t$zero,%z1,%0\"\n+  [(set (attr \"length\") (const_int 8))])\n+\n+(define_insn \"atomic_<atomic_optab><mode>\"\n+  [(set (match_operand:GPR 0 \"memory_operand\" \"+ZB\")\n+\t(unspec_volatile:GPR\n+\t  [(any_atomic:GPR (match_dup 0)\n+\t\t\t   (match_operand:GPR 1 \"reg_or_0_operand\" \"rJ\"))\n+\t   (match_operand:SI 2 \"const_int_operand\")] ;; model\n+\t UNSPEC_SYNC_OLD_OP))]\n+  \"\"\n+  \"am<amop>%A2.<amo>\\t$zero,%z1,%0\"\n+  [(set (attr \"length\") (const_int 8))])\n+\n+(define_insn \"atomic_fetch_<atomic_optab><mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=&r\")\n+\t(match_operand:GPR 1 \"memory_operand\" \"+ZB\"))\n+   (set (match_dup 1)\n+\t(unspec_volatile:GPR\n+\t  [(any_atomic:GPR (match_dup 1)\n+\t\t     (match_operand:GPR 2 \"reg_or_0_operand\" \"rJ\"))\n+\t   (match_operand:SI 3 \"const_int_operand\")] ;; model\n+\t UNSPEC_SYNC_OLD_OP))]\n+  \"\"\n+  \"am<amop>%A3.<amo>\\t%0,%z2,%1\"\n+  [(set (attr \"length\") (const_int 8))])\n+\n+(define_insn \"atomic_exchange<mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=&r\")\n+\t(unspec_volatile:GPR\n+\t  [(match_operand:GPR 1 \"memory_operand\" \"+ZB\")\n+\t   (match_operand:SI 3 \"const_int_operand\")] ;; model\n+\t  UNSPEC_SYNC_EXCHANGE))\n+   (set (match_dup 1)\n+\t(match_operand:GPR 2 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"amswap%A3.<amo>\\t%0,%z2,%1\"\n+  [(set (attr \"length\") (const_int 8))])\n+\n+(define_insn \"atomic_cas_value_strong<mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=&r\")\n+\t(match_operand:GPR 1 \"memory_operand\" \"+ZC\"))\n+   (set (match_dup 1)\n+\t(unspec_volatile:GPR [(match_operand:GPR 2 \"reg_or_0_operand\" \"rJ\")\n+\t\t\t      (match_operand:GPR 3 \"reg_or_0_operand\" \"rJ\")\n+\t\t\t      (match_operand:SI 4 \"const_int_operand\")  ;; mod_s\n+\t\t\t      (match_operand:SI 5 \"const_int_operand\")] ;; mod_f\n+\t UNSPEC_COMPARE_AND_SWAP))\n+   (clobber (match_scratch:GPR 6 \"=&r\"))]\n+  \"\"\n+{\n+  return \"%G5\\\\n\\\\t\"\n+\t \"1:\\\\n\\\\t\"\n+\t \"ll.<amo>\\\\t%0,%1\\\\n\\\\t\"\n+\t \"bne\\\\t%0,%z2,2f\\\\n\\\\t\"\n+\t \"or%i3\\\\t%6,$zero,%3\\\\n\\\\t\"\n+\t \"sc.<amo>\\\\t%6,%1\\\\n\\\\t\"\n+\t \"beq\\\\t$zero,%6,1b\\\\n\\\\t\"\n+\t \"b\\\\t3f\\\\n\\\\t\"\n+\t \"2:\\\\n\\\\t\"\n+\t \"dbar\\\\t0x700\\\\n\\\\t\"\n+\t \"3:\\\\n\\\\t\";\n+}\n+  [(set (attr \"length\") (const_int 32))])\n+\n+(define_expand \"atomic_compare_and_swap<mode>\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")   ;; bool output\n+   (match_operand:GPR 1 \"register_operand\" \"\")  ;; val output\n+   (match_operand:GPR 2 \"memory_operand\" \"\")    ;; memory\n+   (match_operand:GPR 3 \"reg_or_0_operand\" \"\")  ;; expected value\n+   (match_operand:GPR 4 \"reg_or_0_operand\" \"\")  ;; desired value\n+   (match_operand:SI 5 \"const_int_operand\" \"\")  ;; is_weak\n+   (match_operand:SI 6 \"const_int_operand\" \"\")  ;; mod_s\n+   (match_operand:SI 7 \"const_int_operand\" \"\")] ;; mod_f\n+  \"\"\n+{\n+  emit_insn (gen_atomic_cas_value_strong<mode> (operands[1], operands[2],\n+\t\t\t\t\t\toperands[3], operands[4],\n+\t\t\t\t\t\toperands[6], operands[7]));\n+\n+  rtx compare = operands[1];\n+  if (operands[3] != const0_rtx)\n+    {\n+      rtx difference = gen_rtx_MINUS (<MODE>mode, operands[1], operands[3]);\n+      compare = gen_reg_rtx (<MODE>mode);\n+      emit_insn (gen_rtx_SET (compare, difference));\n+    }\n+\n+  if (word_mode != <MODE>mode)\n+    {\n+      rtx reg = gen_reg_rtx (word_mode);\n+      emit_insn (gen_rtx_SET (reg, gen_rtx_SIGN_EXTEND (word_mode, compare)));\n+      compare = reg;\n+    }\n+\n+  emit_insn (gen_rtx_SET (operands[0],\n+\t\t\t  gen_rtx_EQ (SImode, compare, const0_rtx)));\n+  DONE;\n+})\n+\n+(define_expand \"atomic_test_and_set\"\n+  [(match_operand:QI 0 \"register_operand\" \"\")     ;; bool output\n+   (match_operand:QI 1 \"memory_operand\" \"+ZB\")    ;; memory\n+   (match_operand:SI 2 \"const_int_operand\" \"\")]   ;; model\n+  \"\"\n+{\n+  /* We have no QImode atomics, so use the address LSBs to form a mask,\n+     then use an aligned SImode atomic.  */\n+  rtx result = operands[0];\n+  rtx mem = operands[1];\n+  rtx model = operands[2];\n+  rtx addr = force_reg (Pmode, XEXP (mem, 0));\n+  rtx tmp_reg = gen_reg_rtx (Pmode);\n+  rtx zero_reg = gen_rtx_REG (Pmode, 0);\n+\n+  rtx aligned_addr = gen_reg_rtx (Pmode);\n+  emit_move_insn (tmp_reg, gen_rtx_PLUS (Pmode, zero_reg, GEN_INT (-4)));\n+  emit_move_insn (aligned_addr, gen_rtx_AND (Pmode, addr, tmp_reg));\n+\n+  rtx aligned_mem = change_address (mem, SImode, aligned_addr);\n+  set_mem_alias_set (aligned_mem, 0);\n+\n+  rtx offset = gen_reg_rtx (SImode);\n+  emit_move_insn (offset, gen_rtx_AND (SImode, gen_lowpart (SImode, addr),\n+\t\t\t\t       GEN_INT (3)));\n+\n+  rtx tmp = gen_reg_rtx (SImode);\n+  emit_move_insn (tmp, GEN_INT (1));\n+\n+  rtx shmt = gen_reg_rtx (SImode);\n+  emit_move_insn (shmt, gen_rtx_ASHIFT (SImode, offset, GEN_INT (3)));\n+\n+  rtx word = gen_reg_rtx (SImode);\n+  emit_move_insn (word, gen_rtx_ASHIFT (SImode, tmp, shmt));\n+\n+  tmp = gen_reg_rtx (SImode);\n+  emit_insn (gen_atomic_fetch_orsi (tmp, aligned_mem, word, model));\n+\n+  emit_move_insn (gen_lowpart (SImode, result),\n+\t\t  gen_rtx_LSHIFTRT (SImode, tmp, shmt));\n+  DONE;\n+})\n+\n+(define_insn \"atomic_cas_value_cmp_and_7_<mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=&r\")\n+\t(match_operand:GPR 1 \"memory_operand\" \"+ZC\"))\n+   (set (match_dup 1)\n+\t(unspec_volatile:GPR [(match_operand:GPR 2 \"reg_or_0_operand\" \"rJ\")\n+\t\t\t      (match_operand:GPR 3 \"reg_or_0_operand\" \"rJ\")\n+\t\t\t      (match_operand:GPR 4 \"reg_or_0_operand\"  \"rJ\")\n+\t\t\t      (match_operand:GPR 5 \"reg_or_0_operand\"  \"rJ\")\n+\t\t\t      (match_operand:SI 6 \"const_int_operand\")] ;; model\n+\t UNSPEC_COMPARE_AND_SWAP))\n+   (clobber (match_scratch:GPR 7 \"=&r\"))]\n+  \"\"\n+{\n+  return \"%G6\\\\n\\\\t\"\n+\t \"1:\\\\n\\\\t\"\n+\t \"ll.<amo>\\\\t%0,%1\\\\n\\\\t\"\n+\t \"and\\\\t%7,%0,%2\\\\n\\\\t\"\n+\t \"bne\\\\t%7,%z4,2f\\\\n\\\\t\"\n+\t \"and\\\\t%7,%0,%z3\\\\n\\\\t\"\n+\t \"or%i5\\\\t%7,%7,%5\\\\n\\\\t\"\n+\t \"sc.<amo>\\\\t%7,%1\\\\n\\\\t\"\n+\t \"beq\\\\t$zero,%7,1b\\\\n\\\\t\"\n+\t \"b\\\\t3f\\\\n\\\\t\"\n+\t \"2:\\\\n\\\\t\"\n+\t \"dbar\\\\t0x700\\\\n\\\\t\"\n+\t \"3:\\\\n\\\\t\";\n+}\n+  [(set (attr \"length\") (const_int 40))])\n+\n+(define_expand \"atomic_compare_and_swap<mode>\"\n+  [(match_operand:SI 0 \"register_operand\" \"\")   ;; bool output\n+   (match_operand:SHORT 1 \"register_operand\" \"\")  ;; val output\n+   (match_operand:SHORT 2 \"memory_operand\" \"\")    ;; memory\n+   (match_operand:SHORT 3 \"reg_or_0_operand\" \"\")  ;; expected value\n+   (match_operand:SHORT 4 \"reg_or_0_operand\" \"\")  ;; desired value\n+   (match_operand:SI 5 \"const_int_operand\" \"\")  ;; is_weak\n+   (match_operand:SI 6 \"const_int_operand\" \"\")  ;; mod_s\n+   (match_operand:SI 7 \"const_int_operand\" \"\")] ;; mod_f\n+  \"\"\n+{\n+  union loongarch_gen_fn_ptrs generator;\n+  generator.fn_7 = gen_atomic_cas_value_cmp_and_7_si;\n+  loongarch_expand_atomic_qihi (generator, operands[1], operands[2],\n+\t\t\t\toperands[3], operands[4], operands[7]);\n+\n+  rtx compare = operands[1];\n+  if (operands[3] != const0_rtx)\n+    {\n+      machine_mode mode = GET_MODE (operands[3]);\n+      rtx op1 = convert_modes (SImode, mode, operands[1], true);\n+      rtx op3 = convert_modes (SImode, mode, operands[3], true);\n+      rtx difference = gen_rtx_MINUS (SImode, op1, op3);\n+      compare = gen_reg_rtx (SImode);\n+      emit_insn (gen_rtx_SET (compare, difference));\n+    }\n+\n+  if (word_mode != <MODE>mode)\n+    {\n+      rtx reg = gen_reg_rtx (word_mode);\n+      emit_insn (gen_rtx_SET (reg, gen_rtx_SIGN_EXTEND (word_mode, compare)));\n+      compare = reg;\n+    }\n+\n+  emit_insn (gen_rtx_SET (operands[0],\n+\t\t\t  gen_rtx_EQ (SImode, compare, const0_rtx)));\n+  DONE;\n+})\n+\n+(define_insn \"atomic_cas_value_add_7_<mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=&r\")\t\t\t\t;; res\n+\t(match_operand:GPR 1 \"memory_operand\" \"+ZC\"))\n+   (set (match_dup 1)\n+\t(unspec_volatile:GPR [(match_operand:GPR 2 \"reg_or_0_operand\" \"rJ\")\t;; mask\n+\t\t\t      (match_operand:GPR 3 \"reg_or_0_operand\" \"rJ\")\t;; inverted_mask\n+\t\t\t      (match_operand:GPR 4 \"reg_or_0_operand\"  \"rJ\")\t;; old val\n+\t\t\t      (match_operand:GPR 5 \"reg_or_0_operand\"  \"rJ\")\t;; new val\n+\t\t\t      (match_operand:SI 6 \"const_int_operand\")]\t\t;; model\n+\t UNSPEC_COMPARE_AND_SWAP_ADD))\n+   (clobber (match_scratch:GPR 7 \"=&r\"))\n+   (clobber (match_scratch:GPR 8 \"=&r\"))]\n+  \"\"\n+{\n+  return \"%G6\\\\n\\\\t\"\n+\t \"1:\\\\n\\\\t\"\n+\t \"ll.<amo>\\\\t%0,%1\\\\n\\\\t\"\n+\t \"and\\\\t%7,%0,%3\\\\n\\\\t\"\n+\t \"add.w\\\\t%8,%0,%z5\\\\n\\\\t\"\n+\t \"and\\\\t%8,%8,%z2\\\\n\\\\t\"\n+\t \"or%i8\\\\t%7,%7,%8\\\\n\\\\t\"\n+\t \"sc.<amo>\\\\t%7,%1\\\\n\\\\t\"\n+\t \"beq\\\\t$zero,%7,1b\";\n+}\n+\n+  [(set (attr \"length\") (const_int 32))])\n+\n+(define_insn \"atomic_cas_value_sub_7_<mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=&r\")\t\t\t\t;; res\n+\t(match_operand:GPR 1 \"memory_operand\" \"+ZC\"))\n+   (set (match_dup 1)\n+\t(unspec_volatile:GPR [(match_operand:GPR 2 \"reg_or_0_operand\" \"rJ\")\t;; mask\n+\t\t\t      (match_operand:GPR 3 \"reg_or_0_operand\" \"rJ\")\t;; inverted_mask\n+\t\t\t      (match_operand:GPR 4 \"reg_or_0_operand\"  \"rJ\")\t;; old val\n+\t\t\t      (match_operand:GPR 5 \"reg_or_0_operand\"  \"rJ\")\t;; new val\n+\t\t\t      (match_operand:SI 6 \"const_int_operand\")]\t\t;; model\n+\t UNSPEC_COMPARE_AND_SWAP_SUB))\n+   (clobber (match_scratch:GPR 7 \"=&r\"))\n+   (clobber (match_scratch:GPR 8 \"=&r\"))]\n+  \"\"\n+{\n+  return \"%G6\\\\n\\\\t\"\n+\t \"1:\\\\n\\\\t\"\n+\t \"ll.<amo>\\\\t%0,%1\\\\n\\\\t\"\n+\t \"and\\\\t%7,%0,%3\\\\n\\\\t\"\n+\t \"sub.w\\\\t%8,%0,%z5\\\\n\\\\t\"\n+\t \"and\\\\t%8,%8,%z2\\\\n\\\\t\"\n+\t \"or%i8\\\\t%7,%7,%8\\\\n\\\\t\"\n+\t \"sc.<amo>\\\\t%7,%1\\\\n\\\\t\"\n+\t \"beq\\\\t$zero,%7,1b\";\n+}\n+  [(set (attr \"length\") (const_int 32))])\n+\n+(define_insn \"atomic_cas_value_and_7_<mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=&r\")\t\t\t\t;; res\n+\t(match_operand:GPR 1 \"memory_operand\" \"+ZC\"))\n+   (set (match_dup 1)\n+\t(unspec_volatile:GPR [(match_operand:GPR 2 \"reg_or_0_operand\" \"rJ\")\t;; mask\n+\t\t\t      (match_operand:GPR 3 \"reg_or_0_operand\" \"rJ\")\t;; inverted_mask\n+\t\t\t      (match_operand:GPR 4 \"reg_or_0_operand\"  \"rJ\")\t;; old val\n+\t\t\t      (match_operand:GPR 5 \"reg_or_0_operand\"  \"rJ\")\t;; new val\n+\t\t\t      (match_operand:SI 6 \"const_int_operand\")]\t\t;; model\n+\t UNSPEC_COMPARE_AND_SWAP_AND))\n+   (clobber (match_scratch:GPR 7 \"=&r\"))\n+   (clobber (match_scratch:GPR 8 \"=&r\"))]\n+  \"\"\n+{\n+  return \"%G6\\\\n\\\\t\"\n+\t \"1:\\\\n\\\\t\"\n+\t \"ll.<amo>\\\\t%0,%1\\\\n\\\\t\"\n+\t \"and\\\\t%7,%0,%3\\\\n\\\\t\"\n+\t \"and\\\\t%8,%0,%z5\\\\n\\\\t\"\n+\t \"and\\\\t%8,%8,%z2\\\\n\\\\t\"\n+\t \"or%i8\\\\t%7,%7,%8\\\\n\\\\t\"\n+\t \"sc.<amo>\\\\t%7,%1\\\\n\\\\t\"\n+\t \"beq\\\\t$zero,%7,1b\";\n+}\n+  [(set (attr \"length\") (const_int 32))])\n+\n+(define_insn \"atomic_cas_value_xor_7_<mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=&r\")\t\t\t\t;; res\n+\t(match_operand:GPR 1 \"memory_operand\" \"+ZC\"))\n+   (set (match_dup 1)\n+\t(unspec_volatile:GPR [(match_operand:GPR 2 \"reg_or_0_operand\" \"rJ\")\t;; mask\n+\t\t\t      (match_operand:GPR 3 \"reg_or_0_operand\" \"rJ\")\t;; inverted_mask\n+\t\t\t      (match_operand:GPR 4 \"reg_or_0_operand\"  \"rJ\")\t;; old val\n+\t\t\t      (match_operand:GPR 5 \"reg_or_0_operand\"  \"rJ\")\t;; new val\n+\t\t\t      (match_operand:SI 6 \"const_int_operand\")]\t\t;; model\n+\t UNSPEC_COMPARE_AND_SWAP_XOR))\n+   (clobber (match_scratch:GPR 7 \"=&r\"))\n+   (clobber (match_scratch:GPR 8 \"=&r\"))]\n+  \"\"\n+{\n+  return \"%G6\\\\n\\\\t\"\n+\t \"1:\\\\n\\\\t\"\n+\t \"ll.<amo>\\\\t%0,%1\\\\n\\\\t\"\n+\t \"and\\\\t%7,%0,%3\\\\n\\\\t\"\n+\t \"xor\\\\t%8,%0,%z5\\\\n\\\\t\"\n+\t \"and\\\\t%8,%8,%z2\\\\n\\\\t\"\n+\t \"or%i8\\\\t%7,%7,%8\\\\n\\\\t\"\n+\t \"sc.<amo>\\\\t%7,%1\\\\n\\\\t\"\n+\t \"beq\\\\t$zero,%7,1b\";\n+}\n+\n+  [(set (attr \"length\") (const_int 32))])\n+\n+(define_insn \"atomic_cas_value_or_7_<mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=&r\")\t\t\t\t;; res\n+\t(match_operand:GPR 1 \"memory_operand\" \"+ZC\"))\n+   (set (match_dup 1)\n+\t(unspec_volatile:GPR [(match_operand:GPR 2 \"reg_or_0_operand\" \"rJ\")\t;; mask\n+\t\t\t      (match_operand:GPR 3 \"reg_or_0_operand\" \"rJ\")\t;; inverted_mask\n+\t\t\t      (match_operand:GPR 4 \"reg_or_0_operand\"  \"rJ\")\t;; old val\n+\t\t\t      (match_operand:GPR 5 \"reg_or_0_operand\"  \"rJ\")\t;; new val\n+\t\t\t      (match_operand:SI 6 \"const_int_operand\")]\t\t;; model\n+\t UNSPEC_COMPARE_AND_SWAP_OR))\n+   (clobber (match_scratch:GPR 7 \"=&r\"))\n+   (clobber (match_scratch:GPR 8 \"=&r\"))]\n+  \"\"\n+{\n+  return \"%G6\\\\n\\\\t\"\n+\t \"1:\\\\n\\\\t\"\n+\t \"ll.<amo>\\\\t%0,%1\\\\n\\\\t\"\n+\t \"and\\\\t%7,%0,%3\\\\n\\\\t\"\n+\t \"or\\\\t%8,%0,%z5\\\\n\\\\t\"\n+\t \"and\\\\t%8,%8,%z2\\\\n\\\\t\"\n+\t \"or%i8\\\\t%7,%7,%8\\\\n\\\\t\"\n+\t \"sc.<amo>\\\\t%7,%1\\\\n\\\\t\"\n+\t \"beq\\\\t$zero,%7,1b\";\n+}\n+\n+  [(set (attr \"length\") (const_int 32))])\n+\n+(define_insn \"atomic_cas_value_nand_7_<mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=&r\")\t\t\t\t;; res\n+\t(match_operand:GPR 1 \"memory_operand\" \"+ZC\"))\n+   (set (match_dup 1)\n+\t(unspec_volatile:GPR [(match_operand:GPR 2 \"reg_or_0_operand\" \"rJ\")\t;; mask\n+\t\t\t      (match_operand:GPR 3 \"reg_or_0_operand\" \"rJ\")\t;; inverted_mask\n+\t\t\t      (match_operand:GPR 4 \"reg_or_0_operand\"  \"rJ\")\t;; old val\n+\t\t\t      (match_operand:GPR 5 \"reg_or_0_operand\"  \"rJ\")\t;; new val\n+\t\t\t      (match_operand:SI 6 \"const_int_operand\")]\t\t;; model\n+\t UNSPEC_COMPARE_AND_SWAP_NAND))\n+   (clobber (match_scratch:GPR 7 \"=&r\"))\n+   (clobber (match_scratch:GPR 8 \"=&r\"))]\n+  \"\"\n+{\n+  return \"%G6\\\\n\\\\t\"\n+\t \"1:\\\\n\\\\t\"\n+\t \"ll.<amo>\\\\t%0,%1\\\\n\\\\t\"\n+\t \"and\\\\t%7,%0,%3\\\\n\\\\t\"\n+\t \"and\\\\t%8,%0,%z5\\\\n\\\\t\"\n+\t \"xor\\\\t%8,%8,%z2\\\\n\\\\t\"\n+\t \"or%i8\\\\t%7,%7,%8\\\\n\\\\t\"\n+\t \"sc.<amo>\\\\t%7,%1\\\\n\\\\t\"\n+\t \"beq\\\\t$zero,%7,1b\";\n+}\n+  [(set (attr \"length\") (const_int 32))])\n+\n+(define_expand \"atomic_exchange<mode>\"\n+  [(set (match_operand:SHORT 0 \"register_operand\")\n+\t(unspec_volatile:SHORT\n+\t  [(match_operand:SHORT 1 \"memory_operand\")\n+\t   (match_operand:SI 3 \"const_int_operand\")] ;; model\n+\t  UNSPEC_SYNC_EXCHANGE))\n+   (set (match_dup 1)\n+\t(match_operand:SHORT 2 \"register_operand\"))]\n+  \"\"\n+{\n+  union loongarch_gen_fn_ptrs generator;\n+  generator.fn_7 = gen_atomic_cas_value_cmp_and_7_si;\n+  loongarch_expand_atomic_qihi (generator, operands[0], operands[1],\n+\t\t\t\toperands[1], operands[2], operands[3]);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_fetch_add<mode>\"\n+  [(set (match_operand:SHORT 0 \"register_operand\" \"=&r\")\n+\t(match_operand:SHORT 1 \"memory_operand\" \"+ZB\"))\n+   (set (match_dup 1)\n+\t(unspec_volatile:SHORT\n+\t  [(plus:SHORT (match_dup 1)\n+\t\t       (match_operand:SHORT 2 \"reg_or_0_operand\" \"rJ\"))\n+\t   (match_operand:SI 3 \"const_int_operand\")] ;; model\n+\t UNSPEC_SYNC_OLD_OP))]\n+  \"\"\n+{\n+  union loongarch_gen_fn_ptrs generator;\n+  generator.fn_7 = gen_atomic_cas_value_add_7_si;\n+  loongarch_expand_atomic_qihi (generator, operands[0], operands[1],\n+\t\t\t\toperands[1], operands[2], operands[3]);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_fetch_sub<mode>\"\n+  [(set (match_operand:SHORT 0 \"register_operand\" \"=&r\")\n+\t(match_operand:SHORT 1 \"memory_operand\" \"+ZB\"))\n+   (set (match_dup 1)\n+\t(unspec_volatile:SHORT\n+\t  [(minus:SHORT (match_dup 1)\n+\t\t\t(match_operand:SHORT 2 \"reg_or_0_operand\" \"rJ\"))\n+\t   (match_operand:SI 3 \"const_int_operand\")] ;; model\n+\t UNSPEC_SYNC_OLD_OP))]\n+  \"\"\n+{\n+  union loongarch_gen_fn_ptrs generator;\n+  generator.fn_7 = gen_atomic_cas_value_sub_7_si;\n+  loongarch_expand_atomic_qihi (generator, operands[0], operands[1],\n+\t\t\t\toperands[1], operands[2], operands[3]);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_fetch_and<mode>\"\n+  [(set (match_operand:SHORT 0 \"register_operand\" \"=&r\")\n+\t(match_operand:SHORT 1 \"memory_operand\" \"+ZB\"))\n+   (set (match_dup 1)\n+\t(unspec_volatile:SHORT\n+\t  [(and:SHORT (match_dup 1)\n+\t\t      (match_operand:SHORT 2 \"reg_or_0_operand\" \"rJ\"))\n+\t   (match_operand:SI 3 \"const_int_operand\")] ;; model\n+\t UNSPEC_SYNC_OLD_OP))]\n+  \"\"\n+{\n+  union loongarch_gen_fn_ptrs generator;\n+  generator.fn_7 = gen_atomic_cas_value_and_7_si;\n+  loongarch_expand_atomic_qihi (generator, operands[0], operands[1],\n+\t\t\t\toperands[1], operands[2], operands[3]);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_fetch_xor<mode>\"\n+  [(set (match_operand:SHORT 0 \"register_operand\" \"=&r\")\n+\t(match_operand:SHORT 1 \"memory_operand\" \"+ZB\"))\n+   (set (match_dup 1)\n+\t(unspec_volatile:SHORT\n+\t  [(xor:SHORT (match_dup 1)\n+\t\t      (match_operand:SHORT 2 \"reg_or_0_operand\" \"rJ\"))\n+\t   (match_operand:SI 3 \"const_int_operand\")] ;; model\n+\t UNSPEC_SYNC_OLD_OP))]\n+  \"\"\n+{\n+  union loongarch_gen_fn_ptrs generator;\n+  generator.fn_7 = gen_atomic_cas_value_xor_7_si;\n+  loongarch_expand_atomic_qihi (generator, operands[0], operands[1],\n+\t\t\t\toperands[1], operands[2], operands[3]);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_fetch_or<mode>\"\n+  [(set (match_operand:SHORT 0 \"register_operand\" \"=&r\")\n+\t(match_operand:SHORT 1 \"memory_operand\" \"+ZB\"))\n+   (set (match_dup 1)\n+\t(unspec_volatile:SHORT\n+\t  [(ior:SHORT (match_dup 1)\n+\t\t      (match_operand:SHORT 2 \"reg_or_0_operand\" \"rJ\"))\n+\t   (match_operand:SI 3 \"const_int_operand\")] ;; model\n+\t UNSPEC_SYNC_OLD_OP))]\n+  \"\"\n+{\n+  union loongarch_gen_fn_ptrs generator;\n+  generator.fn_7 = gen_atomic_cas_value_or_7_si;\n+  loongarch_expand_atomic_qihi (generator, operands[0], operands[1],\n+\t\t\t\toperands[1], operands[2], operands[3]);\n+  DONE;\n+})\n+\n+(define_expand \"atomic_fetch_nand<mode>\"\n+  [(set (match_operand:SHORT 0 \"register_operand\" \"=&r\")\n+\t(match_operand:SHORT 1 \"memory_operand\" \"+ZB\"))\n+   (set (match_dup 1)\n+\t(unspec_volatile:SHORT\n+\t  [(not:SHORT (and:SHORT (match_dup 1)\n+\t\t\t\t (match_operand:SHORT 2 \"reg_or_0_operand\" \"rJ\")))\n+\t   (match_operand:SI 3 \"const_int_operand\")] ;; model\n+\t UNSPEC_SYNC_OLD_OP))]\n+  \"\"\n+{\n+  union loongarch_gen_fn_ptrs generator;\n+  generator.fn_7 = gen_atomic_cas_value_nand_7_si;\n+  loongarch_expand_atomic_qihi (generator, operands[0], operands[1],\n+\t\t\t\toperands[1], operands[2], operands[3]);\n+  DONE;\n+})"}]}