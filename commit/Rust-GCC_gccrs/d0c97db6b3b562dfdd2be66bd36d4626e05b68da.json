{"sha": "d0c97db6b3b562dfdd2be66bd36d4626e05b68da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBjOTdkYjZiM2I1NjJkZmRkMmJlNjZiZDM2ZDQ2MjZlMDViNjhkYQ==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2002-09-12T06:35:51Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2002-09-12T06:35:51Z"}, "message": "2002-09-12  Michael Koch  <konqueror@gmx.de>\n\n\t* java/net/DatagramSocketImpl.jav\n\t(peekData): New method.\n\t* java/net/PlainDatagramSocketImpl.java\n\t(peekData): New method.\n\t* java/net/natPlainDatagramSocketImpl.cc\n\t(peekData): New method.\n\t* java/net/URLConnection\n\t(getPermission): New method.\n\t(addRequestProperty): New method.\n\t(getRequestProperties): New method.\n\t(guessContentTypeFromStream): New method, not really implemented.\n\t(URLConnection): Added/updated documentation.\n\t(connect): Added/updated documentation.\n\t(getURL): Added/updated documentation.\n\t(getContentLength): Added/updated documentation.\n\t(getContentType: Added/updated documentation.\n\t(getContentEncoding): Added/updated documentation.\n\t(getExpiration): Added/updated documentation.\n\t(getDate): Added/updated documentation.\n\t(getLastModified): Added/updated documentation.\n\t(getHeaderField): Added/updated documentation.\n\t(getHeaderFields): Added/updated documentation.\n\t(getHeaderFieldInt): Added/updated documentation.\n\t(getHeaderFieldDate): Added/updated documentation.\n\t(getHeaderFieldKey): Added/updated documentation.\n\t(getContent): Added/updated documentation.\n\t(getInputStream): Added/updated documentation.\n\t(getOutputStream): Added/updated documentation.\n\t(toString): Added/updated documentation.\n\t(setDoInput): Added/updated documentation.\n\t(getDoInput): Added/updated documentation.\n\t(setDoOutput): Added/updated documentation.\n\t(getDoOutput): Added/updated documentation.\n\t(setAllowUserInteraction): Added/updated documentation.\n\t(getAllowUserInteraction): Added/updated documentation.\n\t(setDefaultAllowUserInteraction): Added/updated documentation.\n\t(getDefaultAllowUserInteraction): Added/updated documentation.\n\t(setUseCaches): Added/updated documentation.\n\t(getUseCaches): Added/updated documentation.\n\t(setIfModifiedSince): Added/updated documentation.\n\t(getIfModifiedSince): Added/updated documentation.\n\t(getDefaultUseCaches): Added/updated documentation.\n\t(setDefaultUseCaches): Added/updated documentation.\n\t(setRequestProperty): Added/updated documentation.\n\t(getRequestProperty): Added/updated documentation.\n\t(setDefaultRequestProperty): Added/updated documentation.\n\t(getDefaultRequestProperty): Added/updated documentation.\n\t(setContentHandlerFactory): Added/updated documentation.\n\nFrom-SVN: r57049", "tree": {"sha": "94264e3f551da9a61cee0a8bc5b962de94b3c3f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94264e3f551da9a61cee0a8bc5b962de94b3c3f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0c97db6b3b562dfdd2be66bd36d4626e05b68da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0c97db6b3b562dfdd2be66bd36d4626e05b68da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0c97db6b3b562dfdd2be66bd36d4626e05b68da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0c97db6b3b562dfdd2be66bd36d4626e05b68da/comments", "author": null, "committer": null, "parents": [{"sha": "35aff10b0f617c6f4dab622ec0d1700e270f16a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35aff10b0f617c6f4dab622ec0d1700e270f16a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35aff10b0f617c6f4dab622ec0d1700e270f16a0"}], "stats": {"total": 438, "additions": 408, "deletions": 30}, "files": [{"sha": "cf111d0cc7c0de6a5e93e9aeb401afc1f6c8b109", "filename": "libjava/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c97db6b3b562dfdd2be66bd36d4626e05b68da/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c97db6b3b562dfdd2be66bd36d4626e05b68da/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=d0c97db6b3b562dfdd2be66bd36d4626e05b68da", "patch": "@@ -1,3 +1,57 @@\n+2002-09-12  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/net/DatagramSocketImpl.jav\n+\t(peekData): New method.\n+\t* java/net/PlainDatagramSocketImpl.java\n+\t(peekData): New method.\n+\t* java/net/natPlainDatagramSocketImpl.cc\n+\t(peekData): New method.\n+\t* java/net/URLConnection\n+\t(getPermission): New method.\n+\t(addRequestProperty): New method.\n+\t(getRequestProperties): New method.\n+\t(guessContentTypeFromStream): New method, not really implemented.\n+\t(URLConnection): Added/updated documentation.\n+\t(connect): Added/updated documentation.\n+\t(getURL): Added/updated documentation.\n+\t(getContentLength): Added/updated documentation.\n+\t(getContentType: Added/updated documentation.\n+\t(getContentEncoding): Added/updated documentation.\n+\t(getExpiration): Added/updated documentation.\n+\t(getDate): Added/updated documentation.\n+\t(getLastModified): Added/updated documentation.\n+\t(getHeaderField): Added/updated documentation.\n+\t(getHeaderFields): Added/updated documentation.\n+\t(getHeaderFieldInt): Added/updated documentation.\n+\t(getHeaderFieldDate): Added/updated documentation.\n+\t(getHeaderFieldKey): Added/updated documentation.\n+\t(getContent): Added/updated documentation.\n+\t(getInputStream): Added/updated documentation.\n+\t(getOutputStream): Added/updated documentation.\n+\t(toString): Added/updated documentation.\n+\t(setDoInput): Added/updated documentation.\n+\t(getDoInput): Added/updated documentation.\n+\t(setDoOutput): Added/updated documentation.\n+\t(getDoOutput): Added/updated documentation.\n+\t(setAllowUserInteraction): Added/updated documentation.\n+\t(getAllowUserInteraction): Added/updated documentation.\n+\t(setDefaultAllowUserInteraction): Added/updated documentation.\n+\t(getDefaultAllowUserInteraction): Added/updated documentation.\n+\t(setUseCaches): Added/updated documentation.\n+\t(getUseCaches): Added/updated documentation.\n+\t(setIfModifiedSince): Added/updated documentation.\n+\t(getIfModifiedSince): Added/updated documentation.\n+\t(getDefaultUseCaches): Added/updated documentation.\n+\t(setDefaultUseCaches): Added/updated documentation.\n+\t(setRequestProperty): Added/updated documentation.\n+\t(getRequestProperty): Added/updated documentation.\n+\t(setDefaultRequestProperty): Added/updated documentation.\n+\t(getDefaultRequestProperty): Added/updated documentation.\n+\t(setContentHandlerFactory): Added/updated documentation.\n+\t(guessContentTypeFromName): Added/updated documentation.\n+\t(getFileNameMap): Added/updated documentation.\n+\t(setFileNameMap): Added/updated documentation.\n+\t\n 2002-09-11  Michael Koch  <konqueror@gmx.de>\n \n \t* java/net/Socket.java"}, {"sha": "6f10a78b190a721971602baf20ef6a6a27f269a6", "filename": "libjava/java/net/DatagramSocketImpl.java", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c97db6b3b562dfdd2be66bd36d4626e05b68da/libjava%2Fjava%2Fnet%2FDatagramSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c97db6b3b562dfdd2be66bd36d4626e05b68da/libjava%2Fjava%2Fnet%2FDatagramSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FDatagramSocketImpl.java?ref=d0c97db6b3b562dfdd2be66bd36d4626e05b68da", "patch": "@@ -111,6 +111,20 @@ protected abstract void bind(int lport, InetAddress laddr)\n    */\n   protected abstract int peek(InetAddress i) throws IOException;\n \n+  /**\n+   * Takes a peek at the next packet received.  This packet is not consumed.\n+   * With the next peekData/receive operation this packet will be read again.\n+   * \n+   * @param p The DatagramPacket to fill in with the data sent.\n+   *\n+   * @return The port number of the sender of the packet.\n+   * \n+   * @exception IOException If an error occurs\n+   * \n+   * @since 1.4\n+   */\n+  protected abstract int peekData (DatagramPacket p) throws IOException;\n+\n   /**\n    * Transmits the specified packet of data to the network.  The destination\n    * host and port should be encoded in the packet.\n@@ -208,7 +222,7 @@ protected int getLocalPort()\n    * Sets the specified option on a socket to the passed in object.  For\n    * options that take an integer argument, the passed in object is an\n    * <code>Integer</code>.  For options that are set to on or off, the\n-   * value passed will be a <code>Boolean</code>.   The <code>option_id</code> \n+   * value passed will be a <code>Boolean</code>.   The <code>option_id</code>\n    * parameter is one of the defined constants in the superinterface.\n    *\n    * @param option_id The identifier of the option\n@@ -221,9 +235,9 @@ public abstract void setOption(int option_id, Object val)\n     throws SocketException;\n \n   /**\n-   * Returns the current setting of the specified option.  The \n-   * <code>Object</code> returned will be an <code>Integer</code> for options \n-   * that have integer values.  For options that are set to on or off, a \n+   * Returns the current setting of the specified option.  The\n+   * <code>Object</code> returned will be an <code>Integer</code> for options\n+   * that have integer values.  For options that are set to on or off, a\n    * <code>Boolean</code> will be returned.   The <code>option_id</code>\n    * is one of the defined constants in the superinterface.\n    *"}, {"sha": "3a8db03627e5e800d472c3f33fa24cdd66617723", "filename": "libjava/java/net/PlainDatagramSocketImpl.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c97db6b3b562dfdd2be66bd36d4626e05b68da/libjava%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c97db6b3b562dfdd2be66bd36d4626e05b68da/libjava%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java?ref=d0c97db6b3b562dfdd2be66bd36d4626e05b68da", "patch": "@@ -65,6 +65,7 @@ protected native void bind(int lport, InetAddress laddr)\n \tthrows SocketException;\n   protected native void create() throws SocketException;\n   protected native int peek(InetAddress i) throws IOException;\n+  protected native int peekData (DatagramPacket dp) throws IOException;\n   protected native void setTimeToLive(int ttl) throws IOException;\n   protected native int getTimeToLive() throws IOException;\n   protected native void send(DatagramPacket p) throws IOException;"}, {"sha": "f11f1b8118f7034fa671b794fd43cceb58d24d88", "filename": "libjava/java/net/URLConnection.java", "status": "modified", "additions": 259, "deletions": 19, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c97db6b3b562dfdd2be66bd36d4626e05b68da/libjava%2Fjava%2Fnet%2FURLConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c97db6b3b562dfdd2be66bd36d4626e05b68da/libjava%2Fjava%2Fnet%2FURLConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURLConnection.java?ref=d0c97db6b3b562dfdd2be66bd36d4626e05b68da", "patch": "@@ -19,6 +19,8 @@\n import java.util.Hashtable;\n import java.util.Map;\n import java.util.StringTokenizer;\n+import java.security.Permission;\n+import java.security.AllPermission;\n import gnu.gcj.io.MimeTypes;\n \n /**\n@@ -52,63 +54,108 @@\n   private static SimpleDateFormat dateFormat1, dateFormat2, dateFormat3;\n   private static boolean dateformats_initialized = false;\n \n+  /**\n+   * Creates a URL connection to a given URL. A real connection is not made.\n+   * Use #connect to do this.\n+   *\n+   * @param url The Object to create the URL connection to\n+   *\n+   * @see URLConnection:connect\n+   */\n   protected URLConnection(URL url)\n   {\n     this.url = url;\n     allowUserInteraction = defaultAllowUserInteraction;\n     useCaches = defaultUseCaches;\n   }\n \n+  /**\n+   * Creates a real connection to the object references by the URL given\n+   * to the constructor\n+   */\n   public abstract void connect() throws IOException;\n \n+  /**\n+   * Returns ths URL to the object.\n+   */\n   public URL getURL()\n   {\n     return url;\n   }\n \n+  /**\n+   * Returns the value of the content-length header field\n+   */\n   public int getContentLength()\n   {\n     return getHeaderFieldInt(\"content-length\", -1);\n   }\n \n+  /**\n+   * Returns the value of the content-type header field\n+   */\n   public String getContentType()\n   {\n     return getHeaderField(\"content-type\");\n   }\n \n+  /**\n+   * Returns the value of the content-encoding header field\n+   */\n   public String getContentEncoding()\n   {\n     return getHeaderField(\"content-encoding\");\n   }\n \n+  /**\n+   * Returns the value of the expires header field\n+   */\n   public long getExpiration()\n   {\n     return getHeaderFieldDate(\"expiration\", 0L);\n   }\n \n+  /**\n+   * Returns the value of the date header field\n+   */\n   public long getDate()\n   {\n     return getHeaderFieldDate(\"date\", 0L);\n   }\n \n+  /**\n+   * Returns the value of the last-modified header field\n+   */\n   public long getLastModified()\n   {\n     return getHeaderFieldDate(\"last-modified\", 0L);\n   }\n \n-  public String getHeaderField(int n)\n+  /**\n+   * Returns the value of the n-th header field\n+   *\n+   * @param num The number of the header field\n+   */\n+  public String getHeaderField(int num)\n   {\n     // Subclasses for specific protocols override this.\n     return null;\n   }\n \n+  /**\n+   * Returns the value of the header filed specified by name\n+   *\n+   * @param name The name of the header field\n+   */\n   public String getHeaderField(String name)\n   {\n     // Subclasses for specific protocols override this.\n     return null;\n   }\n \n   /**\n+   * Returns a map of all sent header fields\n+   * \n    * @since 1.4\n    */\n   public Map getHeaderFields()\n@@ -117,6 +164,15 @@ public Map getHeaderFields()\n     return null;\n   }\n \n+  /**\n+   * Returns the value of the header filed name as int.\n+   *\n+   * @param name The name of the header field\n+   * @param val The default value\n+   *\n+   * @return Returns the value of the header filed or the default value\n+   * if the field is missing or malformed\n+   */\n   public int getHeaderFieldInt(String name, int val)\n   {\n     String str = getHeaderField(name);\n@@ -132,6 +188,16 @@ public int getHeaderFieldInt(String name, int val)\n     return val;\n   }\n \n+  /**\n+   * Returns the value of a header field parsed as date. The result is then\n+   * number of milliseconds since January 1st, 1970 GMT.\n+   *\n+   * @param name The name of the header field\n+   * @param val The dafault date\n+   *\n+   * @return Returns the date value of the header filed or the default value\n+   * if the field is missing or malformed\n+   */\n   public long getHeaderFieldDate(String name, long val)\n   {\n     if (! dateformats_initialized)\n@@ -150,12 +216,20 @@ else if ((date = dateFormat3.parse(str, new ParsePosition(0))) != null)\n     return val;\n   }\n \n-  public String getHeaderFieldKey(int n)\n+  /**\n+   * Returns the key of the n-th header field\n+   *\n+   * @param num The number of the header field\n+   */\n+  public String getHeaderFieldKey(int num)\n   {\n     // Subclasses for specific protocols override this.\n     return null;\n   }\n \n+  /**\n+   * Retrieves the content of this URLConnection\n+   */\n   public Object getContent() throws IOException\n   {\n     // FIXME: Doc indicates that other criteria should be applied as\n@@ -170,31 +244,50 @@ public Object getContent() throws IOException\n     return contentHandler.getContent(this);\n   }\n \n-// TODO12:  public Permission getPermission() throws IOException\n-//   {\n-//     // Subclasses may override this.\n-//     return java.security.AllPermission;\n-//   }\n+  /**\n+   * Returns a permission object representing the permission necessary to make\n+   * the connection represented by this object. This method returns null if no\n+   * permission is required to make the connection.\n+   */\n+  public Permission getPermission() throws IOException\n+  {\n+    // Subclasses may override this.\n+    return new java.security.AllPermission();\n+  }\n \n+  /**\n+   * Returns the input stream of the URL connection\n+   */\n   public InputStream getInputStream() throws IOException\n   {\n     // Subclasses for specific protocols override this.\n     throw new UnknownServiceException(\"Protocol \" + url.getProtocol() +\n \t\t\t\" does not support input.\");\n   }\n \n+  /**\n+   * Returns the output stream of the URL connection\n+   */\n   public OutputStream getOutputStream() throws IOException\n   {\n     // Subclasses for specific protocols override this.\n     throw new UnknownServiceException(\"Protocol \" + url.getProtocol() +\n \t\t\t\" does not support output.\");\n   }\n \n+  /**\n+   * Returns a string representation of the URL connection object\n+   */\n   public String toString()\n   {\n     return this.getClass().getName() + \":\" + url.toString();\n   }\n \n+  /**\n+   * Sets tha value of the doInput field.\n+   *\n+   * @param doinput The new value of the doInput field\n+   */\n   public void setDoInput(boolean doinput)\n   {\n     if (connected)\n@@ -203,11 +296,19 @@ public void setDoInput(boolean doinput)\n     doInput = doinput;\n   }\n \n+  /**\n+   * Returns the current value of the doInput field\n+   */\n   public boolean getDoInput()\n   {\n     return doInput;\n   }\n \n+  /**\n+   * Sets the value of the doOutput field\n+   *\n+   * @param dooutput The new value of the doOutput field\n+   */\n   public void setDoOutput(boolean dooutput)\n   {\n     if (connected)\n@@ -216,35 +317,58 @@ public void setDoOutput(boolean dooutput)\n     doOutput = dooutput;\n   }\n \n+  /**\n+   * Returns the current value of the doOutput field\n+   */\n   public boolean getDoOutput()\n   {\n     return doOutput;\n   }\n \n-  public void setAllowUserInteraction(boolean allowuserinteraction)\n+  /**\n+   * Sets a new value to the allowUserInteraction field\n+   *\n+   * @param allowed The new value\n+   */\n+  public void setAllowUserInteraction(boolean allowed)\n   {\n     if (connected)\n       throw new IllegalAccessError(\"Already connected\");\n \n-    allowUserInteraction = allowuserinteraction;\n+    allowUserInteraction = allowed;\n   }\n \n+  /**\n+   * Returns the current value of the allowUserInteraction field\n+   */\n   public boolean getAllowUserInteraction()\n   {\n     return allowUserInteraction;\n   }\n \n-  public static void\n-    setDefaultAllowUserInteraction(boolean defaultallowuserinteraction)\n+  /**\n+   * Sets the default value if the allowUserInteraction field\n+   *\n+   * @param allowed The new default value\n+   */\n+  public static void setDefaultAllowUserInteraction(boolean allowed)\n   {\n-    defaultAllowUserInteraction = defaultallowuserinteraction;\n+    defaultAllowUserInteraction = allowed;\n   }\n \n+  /**\n+   * Returns the default value of the allowUserInteraction field\n+   */\n   public static boolean getDefaultAllowUserInteraction()\n   {\n     return defaultAllowUserInteraction;\n   }\n \n+  /**\n+   * Sets a new value to the useCaches field\n+   *\n+   * @param usecaches The new value\n+   */\n   public void setUseCaches(boolean usecaches)\n   {\n     if (connected)\n@@ -253,11 +377,20 @@ public void setUseCaches(boolean usecaches)\n     useCaches = usecaches;\n   }\n \n+  /**\n+   * The current value of the useCaches field\n+   */\n   public boolean getUseCaches()\n   {\n     return useCaches;\n   }\n \n+  /**\n+   * Sets the value of the ifModifiedSince field\n+   *\n+   * @param ifmodifiedsince The new value in milliseconds\n+   * since January 1, 1970 GMT\n+   */\n   public void setIfModifiedSince(long ifmodifiedsince)\n   {\n     if (connected)\n@@ -266,49 +399,134 @@ public void setIfModifiedSince(long ifmodifiedsince)\n     ifModifiedSince = ifmodifiedsince;\n   }\n \n+  /**\n+   * Returns the current value of the ifModifiedSince field\n+   */\n   public long getIfModifiedSince()\n   {\n     return ifModifiedSince;\n   }\n \n+  /**\n+   * Returns the default value of the useCaches field\n+   */\n   public boolean getDefaultUseCaches()\n   {\n     return defaultUseCaches;\n   }\n \n+  /**\n+   * Sets the default value of the useCaches field\n+   *\n+   * @param defaultusecaches The new default value\n+   */\n   public void setDefaultUseCaches(boolean defaultusecaches)\n   {\n     defaultUseCaches = defaultusecaches;\n   }\n \n+  /**\n+   * Sets a property specified by key to value.\n+   * \n+   * @param key Key of the property to set\n+   * @param value Value of the Property to set\n+   *\n+   * @see URLConnection:getRequestProperty(String key)\n+   * @see URLConnection:addRequestProperty/String key, String value)\n+   */\n   public void setRequestProperty(String key, String value)\n   {\n     // Do nothing unless overridden by subclasses that support setting\n     // header fields in the request.\n   }\n \n+  /**\n+   * Sets a property specified by key to value. If the property key already\n+   * is assigned to a value it does nothing.\n+   * \n+   * @param key Key of the property to add\n+   * @param value Value of the Property to add\n+   * \n+   * @see URLConnection:getRequestProperty(String key)\n+   * @see URLConnection:setRequestProperty(String key, String value)\n+   * \n+   * @since 1.4\n+   */\n+  public void addRequestProperty(String key, String value)\n+  {\n+    if (getRequestProperty (key) == null)\n+      {\n+        setRequestProperty (key, value);\n+      }\n+  }\n+\n+  /**\n+   * Returns a property value specified by key.\n+   *\n+   * @param key Key of the property to return\n+   *\n+   * @see URLConnection:setRequestProperty(String key, String value)\n+   * @see URLConnection:addRequestProperty(String key, String value)\n+   * \n+   * @return Value of the property.\n+   */\n   public String getRequestProperty(String key)\n   {\n     // Overridden by subclasses that support reading header fields from the\n     // request.\n     return null;\n   }\n \n+  /**\n+   * Returns a map that contains all properties of the request\n+   *\n+   * @return The map of properties\n+   */\n+  public Map getRequestProperties()\n+  {\n+    // Overridden by subclasses that support reading header fields from the\n+    // request.\n+    return null;\n+  }\n+\n+  /**\n+   * Defines a default request property\n+   *\n+   * @param key The key of the property\n+   * @param value The value of the property\n+   *\n+   * @deprecated 1.3 The method setRequestProperty should be used instead\n+   *\n+   * @see URLConnection:setRequestProperty\n+   */\n   public static void setDefaultRequestProperty(String key, String value)\n   {\n     // Do nothing unless overridden by subclasses that support setting\n     // default request properties.\n   }\n \n   /**\n-   * @deprecated 1.3\n+   * Returns the value of a default request property\n+   *\n+   * @param key The key of the default property\n+   *\n+   * @return The value of the default property or null if not available\n+   * \n+   * @deprecated 1.3 The method getRequestProperty should be used instead\n+   *\n+   * @see URLConnection:getRequestProperty\n    */\n   public static String getDefaultRequestProperty(String key)\n   {\n     // Overridden by subclasses that support default request properties.\n     return null;\n   }\n \n+  /**\n+   * Sets a ContentHandlerFactory\n+   *\n+   * @param fac The ContentHandlerFactory\n+   */\n   public static void setContentHandlerFactory(ContentHandlerFactory fac)\n   {\n     if (factory != null)\n@@ -322,6 +540,12 @@ public static void setContentHandlerFactory(ContentHandlerFactory fac)\n     factory = fac;\n   }\n \n+  /**\n+   * Tries to determine the content type of an object, based on the\n+   * specified file name\n+   *\n+   * @param fname The filename to guess the content type from\n+   */\n   protected static String guessContentTypeFromName(String fname)\n   {\n     int dot = fname.lastIndexOf (\".\");\n@@ -342,14 +566,26 @@ protected static String guessContentTypeFromName(String fname)\n     return(type);\n   }\n \n-// TODO:  public static String guessContentTypeFromStream(InputStream is)\n-//          throws IOException\n-//   {\n-//   }\n-\n-// TODO12:  protected void parseURL(URL u, String spec, int start, int limit)\n+  /**\n+   * Tries to guess the content type of an object, based on the characters\n+   * at the beginning of then input stream\n+   *\n+   * @param is The input stream to guess from\n+   *\n+   * @exception IOException If an error occurs\n+   */\n+  public static String guessContentTypeFromStream(InputStream is)\n+    throws IOException\n+  {\n+    is.mark(1024);\n+    // FIXME: Implement this. Use system mimetype informations (like \"file\").\n+    is.reset();\n+    return null;\n+  }\n \n   /**\n+   * Returns a filename map (a mimetable)\n+   *\n    * @since 1.2\n    */\n   public static FileNameMap getFileNameMap()\n@@ -358,6 +594,10 @@ public static FileNameMap getFileNameMap()\n   }\n \n   /**\n+   * Sets a FileNameMap\n+   *\n+   * @param map The new FileNameMap\n+   * \n    * @since 1.2\n    */\n   public static void setFileNameMap(FileNameMap map)"}, {"sha": "6a29fb372ee32a64d314406daa34978d28053415", "filename": "libjava/java/net/natPlainDatagramSocketImpl.cc", "status": "modified", "additions": 76, "deletions": 7, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c97db6b3b562dfdd2be66bd36d4626e05b68da/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c97db6b3b562dfdd2be66bd36d4626e05b68da/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc?ref=d0c97db6b3b562dfdd2be66bd36d4626e05b68da", "patch": "@@ -93,6 +93,13 @@ java::net::PlainDatagramSocketImpl::peek (java::net::InetAddress *)\n     JvNewStringLatin1 (\"DatagramSocketImpl.peek: unimplemented\"));\n }\n \n+jint\n+java::net::PlainDatagramSocketImpl::peekData(java::net::DatagramPacket *)\n+{\n+  throw new java::io::IOException (\n+    JvNewStringLatin1 (\"DatagramSocketImpl.peekData: unimplemented\"));\n+}\n+\n void\n java::net::PlainDatagramSocketImpl::close ()\n {\n@@ -295,6 +302,68 @@ java::net::PlainDatagramSocketImpl::peek (java::net::InetAddress *i)\n   throw new java::io::IOException (JvNewStringUTF (strerr));\n }\n \n+jint\n+java::net::PlainDatagramSocketImpl::peekData(java::net::DatagramPacket *p)\n+{\n+  // FIXME: Deal with Multicast and if the socket is connected.\n+  union SockAddr u;\n+  socklen_t addrlen = sizeof(u);\n+  jbyte *dbytes = elements (p->getData());\n+  ssize_t retlen = 0;\n+\n+// FIXME: implement timeout support for Win32\n+#ifndef WIN32\n+  // Do timeouts via select since SO_RCVTIMEO is not always available.\n+  if (timeout > 0 && fnum >= 0 && fnum < FD_SETSIZE)\n+    {\n+      fd_set rset;\n+      struct timeval tv;\n+      FD_ZERO(&rset);\n+      FD_SET(fnum, &rset);\n+      tv.tv_sec = timeout / 1000;\n+      tv.tv_usec = (timeout % 1000) * 1000;\n+      int retval;\n+      if ((retval = _Jv_select (fnum + 1, &rset, NULL, NULL, &tv)) < 0)\n+\tgoto error;\n+      else if (retval == 0)\n+\tthrow new java::io::InterruptedIOException ();\n+    }\n+#endif /* WIN32 */\n+\n+  retlen =\n+    ::recvfrom (fnum, (char *) dbytes, p->getLength(), MSG_PEEK, (sockaddr*) &u,\n+      &addrlen);\n+  if (retlen < 0)\n+    goto error;\n+  // FIXME: Deal with Multicast addressing and if the socket is connected.\n+  jbyteArray raddr;\n+  jint rport;\n+  if (u.address.sin_family == AF_INET)\n+    {\n+      raddr = JvNewByteArray (4);\n+      memcpy (elements (raddr), &u.address.sin_addr, 4);\n+      rport = ntohs (u.address.sin_port);\n+    }\n+#ifdef HAVE_INET6\n+  else if (u.address.sin_family == AF_INET6)\n+    {\n+      raddr = JvNewByteArray (16);\n+      memcpy (elements (raddr), &u.address6.sin6_addr, 16);\n+      rport = ntohs (u.address6.sin6_port);\n+    }\n+#endif\n+  else\n+    throw new java::net::SocketException (JvNewStringUTF (\"invalid family\"));\n+\n+  p->setAddress (new InetAddress (raddr, NULL));\n+  p->setPort (rport);\n+  p->setLength ((jint) retlen);\n+  return rport;\n+ error:\n+  char* strerr = strerror (errno);\n+  throw new java::io::IOException (JvNewStringUTF (strerr));\n+}\n+\n // Close(shutdown) the socket.\n void\n java::net::PlainDatagramSocketImpl::close ()\n@@ -529,12 +598,12 @@ java::net::PlainDatagramSocketImpl::setOption (jint optID,\n         throw new java::net::SocketException (\n           JvNewStringUTF (\"SO_KEEPALIVE not valid for UDP\"));\n         return;\n-\t\n+\n       case _Jv_SO_BROADCAST_ :\n         if (::setsockopt (fnum, SOL_SOCKET, SO_BROADCAST, (char *) &val,\n                           val_len) != 0)\n           goto error;\n-        break;\n+\tbreak;\n \t\n       case _Jv_SO_OOBINLINE_ :\n         throw new java::net::SocketException (\n@@ -620,7 +689,7 @@ java::net::PlainDatagramSocketImpl::setOption (jint optID,\n \t   val_len) != 0)\n \t  goto error;    \n \treturn;\n-\n+\t\n       case _Jv_SO_TIMEOUT_ :\n \ttimeout = val;\n         return;\n@@ -655,7 +724,7 @@ java::net::PlainDatagramSocketImpl::getOption (jint optID)\n         throw new java::net::SocketException (\n           JvNewStringUTF (\"SO_KEEPALIVE not valid for UDP\"));\n         break;\n-\n+\t\n       case _Jv_SO_BROADCAST_ :\n \tif (::getsockopt (fnum, SOL_SOCKET, SO_BROADCAST, (char *) &val,\n \t    &val_len) != 0)\n@@ -665,8 +734,8 @@ java::net::PlainDatagramSocketImpl::getOption (jint optID)\n       case _Jv_SO_OOBINLINE_ :\n         throw new java::net::SocketException (\n           JvNewStringUTF (\"SO_OOBINLINE not valid for UDP\"));\n-\tbreak;\n-\t\n+        break;\n+      \n       case _Jv_SO_RCVBUF_ :\n       case _Jv_SO_SNDBUF_ :\n #if defined(SO_SNDBUF) && defined(SO_RCVBUF)\n@@ -756,7 +825,7 @@ java::net::PlainDatagramSocketImpl::getOption (jint optID)\n            &val_len) != 0)\n           goto error;\n         return new java::lang::Integer (val);\n-\n+\t\n       default :\n \terrno = ENOPROTOOPT;\n     }"}]}