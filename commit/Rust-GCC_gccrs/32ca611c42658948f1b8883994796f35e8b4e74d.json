{"sha": "32ca611c42658948f1b8883994796f35e8b4e74d", "node_id": "C_kwDOANBUbNoAKDMyY2E2MTFjNDI2NTg5NDhmMWI4ODgzOTk0Nzk2ZjM1ZThiNGU3NGQ", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-03-18T17:58:06Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-03-18T18:02:19Z"}, "message": "Allow (void *) 0xdeadbeef accesses without warnings [PR99578]\n\nStarting with GCC11 we keep emitting false positive -Warray-bounds or\n-Wstringop-overflow etc. warnings on widely used *(type *)0x12345000\nstyle accesses (or memory/string routines to such pointers).\nThis is a standard programming style supported by all C/C++ compilers\nI've ever tried, used mostly in kernel or DSP programming, but sometimes\nalso together with mmap MAP_FIXED when certain things, often I/O registers\nbut could be anything else too are known to be present at fixed\naddresses.\n\nSuch INTEGER_CST addresses can appear in code either because a user\nused it like that (in which case it is fine) or because somebody used\npointer arithmetics (including &((struct whatever *)NULL)->field) on\na NULL pointer.  The middle-end warning code wrongly assumes that the\nlatter case is what is very likely, while the former is unlikely and\nusers should change their code.\n\nThe following patch adds a min-pagesize param defaulting to 4KB,\nand treats INTEGER_CST addresses smaller than that as assumed results\nof pointer arithmetics from NULL while addresses equal or larger than\nthat as expected user constant addresses.  For GCC 13 we can\nrepresent results from pointer arithmetics on NULL using\n&MEM[(void*)0 + offset] instead of (void*)offset INTEGER_CSTs.\n\n2022-03-18  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR middle-end/99578\n\tPR middle-end/100680\n\tPR tree-optimization/100834\n\t* params.opt (--param=min-pagesize=): New parameter.\n\t* pointer-query.cc\n\t(compute_objsize_r) <case ARRAY_REF>: Formatting fix.\n\t(compute_objsize_r) <case INTEGER_CST>: Use maximum object size instead\n\tof zero for pointer constants equal or larger than min-pagesize.\n\n\t* gcc.dg/tree-ssa/pr99578-1.c: New test.\n\t* gcc.dg/pr99578-1.c: New test.\n\t* gcc.dg/pr99578-2.c: New test.\n\t* gcc.dg/pr99578-3.c: New test.\n\t* gcc.dg/pr100680.c: New test.\n\t* gcc.dg/pr100834.c: New test.", "tree": {"sha": "20ce7c597f2ef4552d030bc33b37a2255d60fcef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20ce7c597f2ef4552d030bc33b37a2255d60fcef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32ca611c42658948f1b8883994796f35e8b4e74d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32ca611c42658948f1b8883994796f35e8b4e74d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32ca611c42658948f1b8883994796f35e8b4e74d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32ca611c42658948f1b8883994796f35e8b4e74d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a0c2c3f06227d46b5e9542dfdd4e0fd2d67d894", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a0c2c3f06227d46b5e9542dfdd4e0fd2d67d894", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a0c2c3f06227d46b5e9542dfdd4e0fd2d67d894"}], "stats": {"total": 180, "additions": 173, "deletions": 7}, "files": [{"sha": "b88e13720057d69ca2780aa6b48a9c3c72dd6e69", "filename": "gcc/params.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ca611c42658948f1b8883994796f35e8b4e74d/gcc%2Fparams.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ca611c42658948f1b8883994796f35e8b4e74d/gcc%2Fparams.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.opt?ref=32ca611c42658948f1b8883994796f35e8b4e74d", "patch": "@@ -613,6 +613,10 @@ The maximum number of insns in loop header duplicated by the copy loop headers p\n Common Joined UInteger Var(param_max_modulo_backtrack_attempts) Init(40) Param Optimization\n The maximum number of backtrack attempts the scheduler should make when modulo scheduling a loop.\n \n+-param=min-pagesize=\n+Common Joined UInteger Var(param_min_pagesize) Init(4096) Param Optimization\n+Minimum page size for warning purposes.\n+\n -param=max-partial-antic-length=\n Common Joined UInteger Var(param_max_partial_antic_length) Init(100) Param Optimization\n Maximum length of partial antic set when performing tree pre optimization."}, {"sha": "4390535ef56230edbf5020444ee21db90dbc8f2f", "filename": "gcc/pointer-query.cc", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ca611c42658948f1b8883994796f35e8b4e74d/gcc%2Fpointer-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ca611c42658948f1b8883994796f35e8b4e74d/gcc%2Fpointer-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-query.cc?ref=32ca611c42658948f1b8883994796f35e8b4e74d", "patch": "@@ -2243,7 +2243,7 @@ compute_objsize_r (tree ptr, gimple *stmt, bool addr, int ostype,\n       }\n \n     case ARRAY_REF:\n-\treturn handle_array_ref (ptr, stmt, addr, ostype, pref, snlim, qry);\n+      return handle_array_ref (ptr, stmt, addr, ostype, pref, snlim, qry);\n \n     case COMPONENT_REF:\n       return handle_component_ref (ptr, stmt, addr, ostype, pref, snlim, qry);\n@@ -2264,12 +2264,14 @@ compute_objsize_r (tree ptr, gimple *stmt, bool addr, int ostype,\n       }\n \n     case INTEGER_CST:\n-      /* Pointer constants other than null are most likely the result\n-\t of erroneous null pointer addition/subtraction.  Unless zero\n-\t is a valid address set size to zero.  For null pointers, set\n-\t size to the maximum for now since those may be the result of\n-\t jump threading.  */\n-      if (integer_zerop (ptr))\n+      /* Pointer constants other than null smaller than param_min_pagesize\n+\t might be the result of erroneous null pointer addition/subtraction.\n+\t Unless zero is a valid address set size to zero.  For null pointers,\n+\t set size to the maximum for now since those may be the result of\n+\t jump threading.  Similarly, for values >= param_min_pagesize in\n+\t order to support (type *) 0x7cdeab00.  */\n+      if (integer_zerop (ptr)\n+\t  || wi::to_widest (ptr) >= param_min_pagesize)\n \tpref->set_max_size_range ();\n       else if (POINTER_TYPE_P (TREE_TYPE (ptr)))\n \t{"}, {"sha": "4b5ffc6565f3819795715638fe17311b6c6156f5", "filename": "gcc/testsuite/gcc.dg/pr100680.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ca611c42658948f1b8883994796f35e8b4e74d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr100680.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ca611c42658948f1b8883994796f35e8b4e74d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr100680.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr100680.c?ref=32ca611c42658948f1b8883994796f35e8b4e74d", "patch": "@@ -0,0 +1,31 @@\n+/* PR middle-end/100680 */\n+/* { dg-do compile { target size32plus } } */\n+/* { dg-options \"-O2 -Wstringop-overread\" } */\n+\n+struct s {\n+  char a[8];\n+  int i;\n+  long l;\n+};\n+\n+extern char ea[8];\n+static char sa[8] = { 1, 2, 3, 4 };\n+\n+int\n+test (void)\n+{\n+  const struct s *ps = (const struct s *) 0x12345678L;\n+  if (__builtin_memcmp (ps->a, ps->a, 8))\n+    return 0;\n+\n+  if (__builtin_memcmp (ps->a, ea, 8))\t\t/* { dg-bogus \"exceeds source size 0\" } */\n+    return 0;\n+\n+  if (__builtin_memcmp (ps->a, sa, 8))\t\t/* { dg-bogus \"exceeds source size 0\" } */\n+    return 0;\n+\n+  if (__builtin_memcmp (ps->a, \"abcdABCD\", 8))\t/* { dg-bogus \"exceeds source size 0\" } */\n+    return 0;\n+\n+  return 1;\n+}"}, {"sha": "4bd2691aca7788e1bea067ece135a0d7f65197b0", "filename": "gcc/testsuite/gcc.dg/pr100834.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ca611c42658948f1b8883994796f35e8b4e74d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr100834.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ca611c42658948f1b8883994796f35e8b4e74d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr100834.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr100834.c?ref=32ca611c42658948f1b8883994796f35e8b4e74d", "patch": "@@ -0,0 +1,42 @@\n+/* PR tree-optimization/100834 */\n+/* { dg-do compile { target size32plus } } */\n+/* { dg-options \"-O2 -Wall\" } */\n+\n+#define PAGE_SIZE \t4096\n+#define STACK_SIZE \tPAGE_SIZE\n+\n+union registers\n+{\n+  struct\n+  {\n+    unsigned long r15, r14, r13, r12, r11, r10, r9, r8;\n+    unsigned long rdi, rsi, rbp, unused, rbx, rdx, rcx, rax;\n+  };\n+  unsigned long by_index[16];\n+};\n+\n+struct per_cpu\n+{\n+  union\n+  {\n+    unsigned char stack[STACK_SIZE];\n+    struct\n+    {\n+      unsigned char __fill[STACK_SIZE - sizeof (union registers)];\n+      union registers guest_regs;\n+    };\n+  };\n+} __attribute__((aligned (PAGE_SIZE)));\n+\n+static inline struct per_cpu *\n+this_cpu_data (void)\n+{\n+  return (struct per_cpu *) 0xdeadbeef;\n+}\n+\n+void\n+foo (void)\n+{\n+  struct per_cpu *cpu_data = this_cpu_data ();\n+  __builtin_memset (&cpu_data->guest_regs, 0, sizeof (cpu_data->guest_regs));\t/* { dg-bogus \"is out of the bounds\" } */\n+}"}, {"sha": "c31d95dbccba93a76f8af9e64043be2182288ef5", "filename": "gcc/testsuite/gcc.dg/pr99578-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ca611c42658948f1b8883994796f35e8b4e74d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr99578-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ca611c42658948f1b8883994796f35e8b4e74d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr99578-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr99578-1.c?ref=32ca611c42658948f1b8883994796f35e8b4e74d", "patch": "@@ -0,0 +1,26 @@\n+/* PR middle-end/99578 */\n+/* { dg-do compile { target int32 } } */\n+/* { dg-options \"-O2 -Warray-bounds\" } */\n+\n+struct S { int a, b[4]; };\n+struct T { int a, b[8192], c[4]; };\n+\n+void\n+foo (struct S *p)\n+{\n+  if (p) return;\n+  __builtin_memset (p->b, 0, sizeof p->b);\t/* { dg-warning \"offset \\\\\\[0, 15\\\\\\] is out of the bounds \\\\\\[0, 0\\\\\\]\" } */\n+}\n+\n+void\n+bar (struct T *p)\n+{\n+  if (p) return;\n+  __builtin_memset (p->c, 0, sizeof p->c);\t/* { dg-warning \"offset \\\\\\[0, 15\\\\\\] is out of the bounds \\\\\\[0, 0\\\\\\]\" \"\" { xfail *-*-* } } */\n+}\n+\n+void\n+baz (void)\n+{\n+  __builtin_memset ((void *) 0x8004, 0, 16);\t/* { dg-bogus \"is out of the bounds\" } */\n+}"}, {"sha": "462b606cae10a0b4b17c226a264e328cd2ceeb22", "filename": "gcc/testsuite/gcc.dg/pr99578-2.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ca611c42658948f1b8883994796f35e8b4e74d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr99578-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ca611c42658948f1b8883994796f35e8b4e74d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr99578-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr99578-2.c?ref=32ca611c42658948f1b8883994796f35e8b4e74d", "patch": "@@ -0,0 +1,26 @@\n+/* PR middle-end/99578 */\n+/* { dg-do compile { target int32 } } */\n+/* { dg-options \"-O2 -Wstringop-overflow\" } */\n+\n+struct S { int a, b[4]; };\n+struct T { int a, b[8192], c[4]; };\n+\n+void\n+foo (struct S *p)\n+{\n+  if (p) return;\n+  __builtin_memset (p->b, 0, sizeof p->b);\t/* { dg-warning \"writing 16 bytes into a region of size 0 overflows the destination\" } */\n+}\n+\n+void\n+bar (struct T *p)\n+{\n+  if (p) return;\n+  __builtin_memset (p->c, 0, sizeof p->c);\t/* { dg-warning \"writing 16 bytes into a region of size 0 overflows the destination\" \"\" { xfail *-*-* } } */\n+}\n+\n+void\n+baz (void)\n+{\n+  __builtin_memset ((void *) 0x8004, 0, 16);\t/* { dg-bogus \"overflows the destination\" } */\n+}"}, {"sha": "ef563243dbfacb5ca18a053049cbc56a01d30e0d", "filename": "gcc/testsuite/gcc.dg/pr99578-3.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ca611c42658948f1b8883994796f35e8b4e74d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr99578-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ca611c42658948f1b8883994796f35e8b4e74d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr99578-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr99578-3.c?ref=32ca611c42658948f1b8883994796f35e8b4e74d", "patch": "@@ -0,0 +1,13 @@\n+/* PR middle-end/99578 */\n+/* { dg-do compile { target size32plus } } */\n+/* { dg-options \"-O2 -Wstringop-overread\" } */\n+\n+struct S { unsigned int s; };\n+extern struct S v;\n+extern void *memcpy (void *, const void *, __SIZE_TYPE__);\n+\n+void\n+foo (void)\n+{\n+  memcpy (&v, (void *)(0xe8ffc000), sizeof (struct S));\t/* { dg-bogus \"from a region of size 0\" } */\n+}"}, {"sha": "030f3bd3cf91213862a5c8d7bd7d5ef48c54c0e6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr99578-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ca611c42658948f1b8883994796f35e8b4e74d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr99578-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ca611c42658948f1b8883994796f35e8b4e74d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr99578-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr99578-1.c?ref=32ca611c42658948f1b8883994796f35e8b4e74d", "patch": "@@ -0,0 +1,22 @@\n+/* PR middle-end/99578 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump-not \"&MEM\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"PHI <-?1\\\\\\(\\[0-9\\]+\\\\\\), -?1\\\\\\(\\[0-9\\]+\\\\\\)>\" 2 \"optimized\" } } */\n+\n+struct S { int a, b[4]; };\n+struct T { int a, b[8192], c[4]; };\n+\n+int\n+foo (struct S *p)\n+{\n+  if (p) return -1;\n+  return p->b == (void *)4;\n+}\n+\n+int\n+bar (struct T *p)\n+{\n+  if (p) return -1;\n+  return p->c == (void *)32772;\n+}"}]}