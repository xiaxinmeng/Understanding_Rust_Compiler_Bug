{"sha": "16493b5771cf3b1670a4a9bf7c7426fd74b727d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY0OTNiNTc3MWNmM2IxNjcwYTRhOWJmN2M3NDI2ZmQ3NGI3MjdkMA==", "commit": {"author": {"name": "Claudiu Zissulescu", "email": "claziss@synopsys.com", "date": "2018-06-13T08:43:56Z"}, "committer": {"name": "Claudiu Zissulescu", "email": "claziss@gcc.gnu.org", "date": "2018-06-13T08:43:56Z"}, "message": "[ARC] Reimplement return padding operation for ARC700.\n\nFor ARC700, adding padding if necessary to avoid a mispredict.  A\nreturn could happen immediately after the function start.  A\ncall/return and return/return must be 6 bytes apart to avoid\nmispredict.\n\nThe old implementation was doing this operation very late in the\ncompilation process, and the additional nop instructions and/or\nforcing some other instruction to take their long form was not taken\ninto account when generating brcc instructions. Thus, wrong code could\nbe generated.\n\ngcc/\n2017-03-24  Claudiu Zissulescu  <claziss@synopsys.com>\n\n\t* config/arc/arc-protos.h (arc_pad_return): Remove.\n\t* config/arc/arc.c (machine_function): Remove force_short_suffix\n\tand size_reason.\n\t(arc_print_operand): Adjust printing of '&'.\n\t(arc_verify_short): Remove conditional printing of short suffix.\n\t(arc_final_prescan_insn): Remove reference to size_reason.\n\t(pad_return): New function.\n\t(arc_reorg): Call pad_return.\n\t(arc_pad_return): Remove.\n\t(arc_init_machine_status): Remove reference to force_short_suffix.\n\t* config/arc/arc.md (vunspec): Add VUNSPEC_ARC_BLOCKAGE.\n\t(attr length): When attribute iscompact is true force to 2\n\tregardless; in the case of maybe check if we want to force the\n\tinstruction to have 4 bytes length.\n\t(nopv): Change it to generate 4 byte long nop as well.\n\t(blockage): New pattern.\n\t(simple_return): Remove call to arc_pad_return.\n\t(p_return_i): Likewise.\n\ngcc/testsuite/\n2017-03-24  Claudiu Zissulescu  <claziss@synopsys.com>\n\n\t* gcc.target/arc/pr9001107555.c: New file.\n\nFrom-SVN: r261542", "tree": {"sha": "e980080e39e343317abe7dc492173a7cc68e3e56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e980080e39e343317abe7dc492173a7cc68e3e56"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16493b5771cf3b1670a4a9bf7c7426fd74b727d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16493b5771cf3b1670a4a9bf7c7426fd74b727d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16493b5771cf3b1670a4a9bf7c7426fd74b727d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16493b5771cf3b1670a4a9bf7c7426fd74b727d0/comments", "author": {"login": "claziss", "id": 2761368, "node_id": "MDQ6VXNlcjI3NjEzNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/2761368?v=4", "gravatar_id": "", "url": "https://api.github.com/users/claziss", "html_url": "https://github.com/claziss", "followers_url": "https://api.github.com/users/claziss/followers", "following_url": "https://api.github.com/users/claziss/following{/other_user}", "gists_url": "https://api.github.com/users/claziss/gists{/gist_id}", "starred_url": "https://api.github.com/users/claziss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/claziss/subscriptions", "organizations_url": "https://api.github.com/users/claziss/orgs", "repos_url": "https://api.github.com/users/claziss/repos", "events_url": "https://api.github.com/users/claziss/events{/privacy}", "received_events_url": "https://api.github.com/users/claziss/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "60a3f6590618c8fa74ddc54d3232d57b2908765d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60a3f6590618c8fa74ddc54d3232d57b2908765d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60a3f6590618c8fa74ddc54d3232d57b2908765d"}], "stats": {"total": 259, "additions": 166, "deletions": 93}, "files": [{"sha": "ce7197bf27c201f259f24e5b44e7592d5d34701c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16493b5771cf3b1670a4a9bf7c7426fd74b727d0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16493b5771cf3b1670a4a9bf7c7426fd74b727d0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=16493b5771cf3b1670a4a9bf7c7426fd74b727d0", "patch": "@@ -1,3 +1,24 @@\n+2018-06-12  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* config/arc/arc-protos.h (arc_pad_return): Remove.\n+\t* config/arc/arc.c (machine_function): Remove force_short_suffix\n+\tand size_reason.\n+\t(arc_print_operand): Adjust printing of '&'.\n+\t(arc_verify_short): Remove conditional printing of short suffix.\n+\t(arc_final_prescan_insn): Remove reference to size_reason.\n+\t(pad_return): New function.\n+\t(arc_reorg): Call pad_return.\n+\t(arc_pad_return): Remove.\n+\t(arc_init_machine_status): Remove reference to force_short_suffix.\n+\t* config/arc/arc.md (vunspec): Add VUNSPEC_ARC_BLOCKAGE.\n+\t(attr length): When attribute iscompact is true force to 2\n+\tregardless; in the case of maybe check if we want to force the\n+\tinstruction to have 4 bytes length.\n+\t(nopv): Change it to generate 4 byte long nop as well.\n+\t(blockage): New pattern.\n+\t(simple_return): Remove call to arc_pad_return.\n+\t(p_return_i): Likewise.\n+\n 2018-06-12  Claudiu Zissulescu  <claziss@synopsys.com>\n \n \t* config/arc/elf.h (LINK_GCC_C_SEQUENCE_SPEC): Define."}, {"sha": "ce4b6f84749e66f021a8d89f3d8a74d9f870a6e1", "filename": "gcc/config/arc/arc-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16493b5771cf3b1670a4a9bf7c7426fd74b727d0/gcc%2Fconfig%2Farc%2Farc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16493b5771cf3b1670a4a9bf7c7426fd74b727d0/gcc%2Fconfig%2Farc%2Farc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-protos.h?ref=16493b5771cf3b1670a4a9bf7c7426fd74b727d0", "patch": "@@ -89,7 +89,6 @@ extern void arc_clear_unalign (void);\n extern void arc_toggle_unalign (void);\n extern void split_addsi (rtx *);\n extern void split_subsi (rtx *);\n-extern void arc_pad_return (void);\n extern void arc_split_move (rtx *);\n extern const char *arc_short_long (rtx_insn *insn, const char *, const char *);\n extern rtx arc_regno_use_in (unsigned int, rtx);"}, {"sha": "85f473ab195c6ee1823a92eab15e8976db0cf34a", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 72, "deletions": 84, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16493b5771cf3b1670a4a9bf7c7426fd74b727d0/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16493b5771cf3b1670a4a9bf7c7426fd74b727d0/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=16493b5771cf3b1670a4a9bf7c7426fd74b727d0", "patch": "@@ -2629,8 +2629,6 @@ typedef struct GTY (()) machine_function\n   struct arc_frame_info frame_info;\n   /* To keep track of unalignment caused by short insns.  */\n   int unalign;\n-  int force_short_suffix; /* Used when disgorging return delay slot insns.  */\n-  const char *size_reason;\n   struct arc_ccfsm ccfsm_current;\n   /* Map from uid to ccfsm state during branch shortening.  */\n   rtx ccfsm_current_insn;\n@@ -4288,7 +4286,7 @@ arc_print_operand (FILE *file, rtx x, int code)\n \t}\n       break;\n     case '&':\n-      if (TARGET_ANNOTATE_ALIGN && cfun->machine->size_reason)\n+      if (TARGET_ANNOTATE_ALIGN)\n \tfprintf (file, \"; unalign: %d\", cfun->machine->unalign);\n       return;\n     case '+':\n@@ -4961,18 +4959,13 @@ static int\n arc_verify_short (rtx_insn *insn, int, int check_attr)\n {\n   enum attr_iscompact iscompact;\n-  struct machine_function *machine;\n \n   if (check_attr > 0)\n     {\n       iscompact = get_attr_iscompact (insn);\n       if (iscompact == ISCOMPACT_FALSE)\n \treturn 0;\n     }\n-  machine = cfun->machine;\n-\n-  if (machine->force_short_suffix >= 0)\n-    return machine->force_short_suffix;\n \n   return (get_attr_length (insn) & 2) != 0;\n }\n@@ -5011,8 +5004,6 @@ arc_final_prescan_insn (rtx_insn *insn, rtx *opvec ATTRIBUTE_UNUSED,\n       cfun->machine->prescan_initialized = 1;\n     }\n   arc_ccfsm_advance (insn, &arc_ccfsm_current);\n-\n-  cfun->machine->size_reason = 0;\n }\n \n /* Given FROM and TO register numbers, say whether this elimination is allowed.\n@@ -7654,6 +7645,76 @@ jli_call_scan (void)\n     }\n }\n \n+/* Add padding if necessary to avoid a mispredict.  A return could\n+   happen immediately after the function start.  A call/return and\n+   return/return must be 6 bytes apart to avoid mispredict.  */\n+\n+static void\n+pad_return (void)\n+{\n+  rtx_insn *insn;\n+  long offset;\n+\n+  if (!TARGET_PAD_RETURN)\n+    return;\n+\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      rtx_insn *prev0 = prev_active_insn (insn);\n+      bool wantlong = false;\n+\n+      if (!INSN_P (insn) || GET_CODE (PATTERN (insn)) != SIMPLE_RETURN)\n+\tcontinue;\n+\n+      if (!prev0)\n+\t{\n+\t  prev0 = emit_insn_before (gen_nopv (), insn);\n+\t  /* REG_SAVE_NOTE is used by Haifa scheduler, we are in reorg\n+\t     so it is safe to reuse it for forcing a particular length\n+\t     for an instruction.  */\n+\t  add_reg_note (prev0, REG_SAVE_NOTE, GEN_INT (1));\n+\t  emit_insn_before (gen_nopv (), insn);\n+\t  continue;\n+\t}\n+      offset = get_attr_length (prev0);\n+\n+      if (get_attr_length (prev0) == 2\n+\t  && get_attr_iscompact (prev0) != ISCOMPACT_TRUE)\n+\t{\n+\t  /* Force long version of the insn.  */\n+\t  wantlong = true;\n+\t  offset += 2;\n+\t}\n+\n+     rtx_insn *prev = prev_active_insn (prev0);\n+      if (prev)\n+\toffset += get_attr_length (prev);\n+\n+      prev = prev_active_insn (prev);\n+      if (prev)\n+\toffset += get_attr_length (prev);\n+\n+      switch (offset)\n+\t{\n+\tcase 2:\n+\t  prev = emit_insn_before (gen_nopv (), insn);\n+\t  add_reg_note (prev, REG_SAVE_NOTE, GEN_INT (1));\n+\t  break;\n+\tcase 4:\n+\t  emit_insn_before (gen_nopv (), insn);\n+\t  break;\n+\tdefault:\n+\t  continue;\n+\t}\n+\n+      if (wantlong)\n+\tadd_reg_note (prev0, REG_SAVE_NOTE, GEN_INT (1));\n+\n+      /* Emit a blockage to avoid delay slot scheduling.  */\n+      emit_insn_before (gen_blockage (), insn);\n+    }\n+}\n+\n static int arc_reorg_in_progress = 0;\n \n /* ARC's machince specific reorg function.  */\n@@ -7679,6 +7740,7 @@ arc_reorg (void)\n \n   workaround_arc_anomaly ();\n   jli_call_scan ();\n+  pad_return ();\n \n /* FIXME: should anticipate ccfsm action, generate special patterns for\n    to-be-deleted branches that have no delay slot and have at least the\n@@ -9237,79 +9299,6 @@ arc_branch_size_unknown_p (void)\n   return !optimize_size && arc_reorg_in_progress;\n }\n \n-/* We are about to output a return insn.  Add padding if necessary to avoid\n-   a mispredict.  A return could happen immediately after the function\n-   start, but after a call we know that there will be at least a blink\n-   restore.  */\n-\n-void\n-arc_pad_return (void)\n-{\n-  rtx_insn *insn = current_output_insn;\n-  rtx_insn *prev = prev_active_insn (insn);\n-  int want_long;\n-\n-  if (!prev)\n-    {\n-      fputs (\"\\tnop_s\\n\", asm_out_file);\n-      cfun->machine->unalign ^= 2;\n-      want_long = 1;\n-    }\n-  /* If PREV is a sequence, we know it must be a branch / jump or a tailcall,\n-     because after a call, we'd have to restore blink first.  */\n-  else if (GET_CODE (PATTERN (prev)) == SEQUENCE)\n-    return;\n-  else\n-    {\n-      want_long = (get_attr_length (prev) == 2);\n-      prev = prev_active_insn (prev);\n-    }\n-  if (!prev\n-      || ((NONJUMP_INSN_P (prev) && GET_CODE (PATTERN (prev)) == SEQUENCE)\n-\t  ? CALL_ATTR (as_a <rtx_sequence *> (PATTERN (prev))->insn (0),\n-\t\t       NON_SIBCALL)\n-\t  : CALL_ATTR (prev, NON_SIBCALL)))\n-    {\n-      if (want_long)\n-\tcfun->machine->size_reason\n-\t  = \"call/return and return/return must be 6 bytes apart to avoid mispredict\";\n-      else if (TARGET_UNALIGN_BRANCH && cfun->machine->unalign)\n-\t{\n-\t  cfun->machine->size_reason\n-\t    = \"Long unaligned jump avoids non-delay slot penalty\";\n-\t  want_long = 1;\n-\t}\n-      /* Disgorge delay insn, if there is any, and it may be moved.  */\n-      if (final_sequence\n-\t  /* ??? Annulled would be OK if we can and do conditionalize\n-\t     the delay slot insn accordingly.  */\n-\t  && !INSN_ANNULLED_BRANCH_P (insn)\n-\t  && (get_attr_cond (insn) != COND_USE\n-\t      || !reg_set_p (gen_rtx_REG (CCmode, CC_REG),\n-\t\t\t     XVECEXP (final_sequence, 0, 1))))\n-\t{\n-\t  prev = as_a <rtx_insn *> (XVECEXP (final_sequence, 0, 1));\n-\t  gcc_assert (!prev_real_insn (insn)\n-\t\t      || !arc_hazard (prev_real_insn (insn), prev));\n-\t  cfun->machine->force_short_suffix = !want_long;\n-\t  rtx save_pred = current_insn_predicate;\n-\t  final_scan_insn (prev, asm_out_file, optimize, 1, NULL);\n-\t  cfun->machine->force_short_suffix = -1;\n-\t  prev->set_deleted ();\n-\t  current_output_insn = insn;\n-\t  current_insn_predicate = save_pred;\n-\t}\n-      else if (want_long)\n-\tfputs (\"\\tnop\\n\", asm_out_file);\n-      else\n-\t{\n-\t  fputs (\"\\tnop_s\\n\", asm_out_file);\n-\t  cfun->machine->unalign ^= 2;\n-\t}\n-    }\n-  return;\n-}\n-\n /* The usual; we set up our machine_function data.  */\n \n static struct machine_function *\n@@ -9318,7 +9307,6 @@ arc_init_machine_status (void)\n   struct machine_function *machine;\n   machine = ggc_cleared_alloc<machine_function> ();\n   machine->fn_type = ARC_FUNCTION_UNKNOWN;\n-  machine->force_short_suffix = -1;\n \n   return machine;\n }"}, {"sha": "ebe2982f657af70f4ccc70be240c33818c4901dd", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16493b5771cf3b1670a4a9bf7c7426fd74b727d0/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16493b5771cf3b1670a4a9bf7c7426fd74b727d0/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=16493b5771cf3b1670a4a9bf7c7426fd74b727d0", "patch": "@@ -161,6 +161,7 @@\n   VUNSPEC_ARC_CAS\n   VUNSPEC_ARC_SC\n   VUNSPEC_ARC_LL\n+  VUNSPEC_ARC_BLOCKAGE\n   ])\n \n (define_constants\n@@ -384,13 +385,18 @@\n ;; and insn lengths: insns with shimm values cannot be conditionally executed.\n (define_attr \"length\" \"\"\n   (cond\n-    [(eq_attr \"iscompact\" \"true,maybe\")\n+    [(eq_attr \"iscompact\" \"true\")\n+      (const_int 2)\n+\n+     (eq_attr \"iscompact\" \"maybe\")\n      (cond\n        [(eq_attr \"type\" \"sfunc\")\n \t(cond [(match_test \"GET_CODE (PATTERN (insn)) == COND_EXEC\")\n \t       (const_int 12)]\n \t      (const_int 10))\n-\t(match_test \"GET_CODE (PATTERN (insn)) == COND_EXEC\") (const_int 4)]\n+\t(match_test \"GET_CODE (PATTERN (insn)) == COND_EXEC\") (const_int 4)\n+\t(match_test \"find_reg_note (insn, REG_SAVE_NOTE, GEN_INT (1))\")\n+\t(const_int 4)]\n       (const_int 2))\n \n     (eq_attr \"iscompact\" \"true_limm\")\n@@ -4431,8 +4437,16 @@\n   \"\"\n   \"nop%?\"\n   [(set_attr \"type\" \"misc\")\n-   (set_attr \"iscompact\" \"true\")\n-   (set_attr \"length\" \"2\")])\n+   (set_attr \"iscompact\" \"maybe\")\n+   (set_attr \"length\" \"*\")])\n+\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] VUNSPEC_ARC_BLOCKAGE)]\n+  \"\"\n+  \"\"\n+  [(set_attr \"length\" \"0\")\n+   (set_attr \"type\" \"block\")]\n+)\n \n ;; Split up troublesome insns for better scheduling.\n \n@@ -4977,8 +4991,6 @@\n   {\n     return \\\"rtie\\\";\n   }\n-  if (TARGET_PAD_RETURN)\n-    arc_pad_return ();\n   output_asm_insn (\\\"j%!%* [%0]%&\\\", &reg);\n   return \\\"\\\";\n }\n@@ -5022,8 +5034,6 @@\n \t\t   arc_return_address_register (arc_compute_function_type\n \t\t\t\t\t\t(cfun)));\n \n-  if (TARGET_PAD_RETURN)\n-    arc_pad_return ();\n   output_asm_insn (\\\"j%d0%!%# [%1]%&\\\", xop);\n   /* record the condition in case there is a delay insn.  */\n   arc_ccfsm_record_condition (xop[0], false, insn, 0);"}, {"sha": "572424df1faa0b89d3d007d5f27372c71d9e602e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16493b5771cf3b1670a4a9bf7c7426fd74b727d0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16493b5771cf3b1670a4a9bf7c7426fd74b727d0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=16493b5771cf3b1670a4a9bf7c7426fd74b727d0", "patch": "@@ -1,3 +1,7 @@\n+2018-06-12  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* gcc.target/arc/pr9001107555.c: New file.\n+\n 2018-06-12  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* g++.dg/torture/aarch64-vect-init-1.C: New test."}, {"sha": "420fa835fa41b4ae55a1beeb26ad8103050fa780", "filename": "gcc/testsuite/gcc.target/arc/pr9001107555.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16493b5771cf3b1670a4a9bf7c7426fd74b727d0/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fpr9001107555.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16493b5771cf3b1670a4a9bf7c7426fd74b727d0/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fpr9001107555.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fpr9001107555.c?ref=16493b5771cf3b1670a4a9bf7c7426fd74b727d0", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-do assemble } *\n+/* { dg-skip-if \"\" { ! { clmcpu } } } */\n+/* { dg-options \"-O3 -funroll-loops -mno-sdata -mcpu=arc700\" } */\n+\n+typedef long long a __attribute__((__mode__(__DI__)));\n+typedef struct c c;\n+\n+struct b\n+{\n+  int d;\n+  c *e;\n+};\n+\n+enum { f };\n+\n+typedef struct\n+{\n+  a g;\n+  a h;\n+  int i;\n+} j;\n+\n+struct c\n+{\n+  int count;\n+  int current;\n+};\n+\n+int k;\n+\n+extern void bar (int, long long);\n+int foo (struct b *demux, __builtin_va_list args)\n+{\n+  c m = *demux->e;\n+  j *n;\n+  switch (k)\n+  case f:\n+    {\n+      a o = __builtin_va_arg(args, a);\n+      m.current = 0;\n+      while (m.current < m.count)\n+\t{\n+\t  if (n[m.current].h > o) {\n+\t    bar (demux->d, 4 + 128LL * n[m.current].i);\n+\t    break;\n+\t  }\n+\t  m.current++;\n+\t}\n+      return 0;\n+    }\n+}"}]}