{"sha": "a2e2a66815796bd961250264ff32809bae478a31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJlMmE2NjgxNTc5NmJkOTYxMjUwMjY0ZmYzMjgwOWJhZTQ3OGEzMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-08-06T16:59:49Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-08-06T16:59:49Z"}, "message": "cgraph.c (cgraph_get_body): New function based on lto.c implementation.\n\n\t* cgraph.c (cgraph_get_body): New function based on lto.c\n\timplementation.\n\t* cgraph.h (cgraph_get_body): Declare.\n\t* cgraphclones.c (cgraph_create_virtual_clone): Commonize WPA and LTO paths.\n\t* cgraphunit.c (expand_function): Get body prior expanding.\n\t* ipa.c (function_and_variable_visibility): Use gimple_has_body_p test.\n\t* lto-cgraph.c (lto_output_node): Do not stream bodies we don't really need.\n\t* passes.c (do_per_function_toporder): Get body.\n\t* tree-inline.c (expand_call_inline): Get body prior inlining it.\n\t* tree-ssa-structalias.c (ipa_pta_execute): Get body; skip clones.\n\n\t* lto.c (lto_materialize_function): Do not read body anymore.\n\nFrom-SVN: r201537", "tree": {"sha": "e06c2e69d4ad72b54dff08acfb5ac74d389b8f74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e06c2e69d4ad72b54dff08acfb5ac74d389b8f74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2e2a66815796bd961250264ff32809bae478a31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2e2a66815796bd961250264ff32809bae478a31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2e2a66815796bd961250264ff32809bae478a31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2e2a66815796bd961250264ff32809bae478a31/comments", "author": null, "committer": null, "parents": [{"sha": "e086adbdb433ea655c8bf0bdcd210baa5a0a63f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e086adbdb433ea655c8bf0bdcd210baa5a0a63f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e086adbdb433ea655c8bf0bdcd210baa5a0a63f6"}], "stats": {"total": 122, "additions": 83, "deletions": 39}, "files": [{"sha": "5dec128162dbd98a69dd870c56cf66bcbf3f0a21", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2e2a66815796bd961250264ff32809bae478a31/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2e2a66815796bd961250264ff32809bae478a31/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a2e2a66815796bd961250264ff32809bae478a31", "patch": "@@ -1,3 +1,16 @@\n+2013-08-06  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_get_body): New function based on lto.c\n+\timplementation.\n+\t* cgraph.h (cgraph_get_body): Declare.\n+\t* cgraphclones.c (cgraph_create_virtual_clone): Commonize WPA and LTO paths.\n+\t* cgraphunit.c (expand_function): Get body prior expanding.\n+\t* ipa.c (function_and_variable_visibility): Use gimple_has_body_p test.\n+\t* lto-cgraph.c (lto_output_node): Do not stream bodies we don't really need.\n+\t* passes.c (do_per_function_toporder): Get body.\n+\t* tree-inline.c (expand_call_inline): Get body prior inlining it.\n+\t* tree-ssa-structalias.c (ipa_pta_execute): Get body; skip clones.\n+\n 2013-08-06  Martin Jambor  <mjambor@suse.cz>\n \n \tPR fortran/57987"}, {"sha": "bb7016f441d3c2c81375972e63c028b813636fba", "filename": "gcc/cgraph.c", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2e2a66815796bd961250264ff32809bae478a31/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2e2a66815796bd961250264ff32809bae478a31/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=a2e2a66815796bd961250264ff32809bae478a31", "patch": "@@ -2707,4 +2707,44 @@ cgraph_function_node (struct cgraph_node *node, enum availability *availability)\n   return node;\n }\n \n+/* When doing LTO, read NODE's body from disk if it is not already present.  */\n+\n+bool\n+cgraph_get_body (struct cgraph_node *node)\n+{\n+  struct lto_file_decl_data *file_data;\n+  const char *data, *name;\n+  size_t len;\n+  tree decl = node->symbol.decl;\n+\n+  if (DECL_RESULT (decl))\n+    return false;\n+\n+  gcc_assert (in_lto_p);\n+\n+  file_data = node->symbol.lto_file_data;\n+  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+\n+  /* We may have renamed the declaration, e.g., a static function.  */\n+  name = lto_get_decl_name_mapping (file_data, name);\n+\n+  data = lto_get_section_data (file_data, LTO_section_function_body,\n+\t\t\t       name, &len);\n+  if (!data)\n+    {\n+\tdump_cgraph_node (stderr, node);\n+    fatal_error (\"%s: section %s is missing\",\n+\t\t file_data->file_name,\n+\t\t name);\n+    }\n+\n+  gcc_assert (DECL_STRUCT_FUNCTION (decl) == NULL);\n+\n+  lto_input_function_body (file_data, decl, data);\n+  lto_stats.num_function_bodies++;\n+  lto_free_section_data (file_data, LTO_section_function_body, name,\n+\t\t\t data, len);\n+  return true;\n+}\n+\n #include \"gt-cgraph.h\""}, {"sha": "d681a1d65b4ef62d2a410ee68c990bfb16614ddb", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2e2a66815796bd961250264ff32809bae478a31/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2e2a66815796bd961250264ff32809bae478a31/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=a2e2a66815796bd961250264ff32809bae478a31", "patch": "@@ -701,6 +701,7 @@ gimple cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *);\n bool cgraph_propagate_frequency (struct cgraph_node *node);\n struct cgraph_node * cgraph_function_node (struct cgraph_node *,\n \t\t\t\t\t   enum availability *avail = NULL);\n+bool cgraph_get_body (struct cgraph_node *node);\n \n /* In cgraphunit.c  */\n struct asm_node *add_asm_node (tree);"}, {"sha": "21ef1f57f12dd455ce6bf4f3221c486759f073a7", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2e2a66815796bd961250264ff32809bae478a31/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2e2a66815796bd961250264ff32809bae478a31/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=a2e2a66815796bd961250264ff32809bae478a31", "patch": "@@ -295,7 +295,7 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n   size_t i;\n   struct ipa_replace_map *map;\n \n-  if (!flag_wpa)\n+  if (!in_lto_p)\n     gcc_checking_assert  (tree_versionable_function_p (old_decl));\n \n   gcc_assert (old_node->local.can_change_signature || !args_to_skip);\n@@ -829,6 +829,8 @@ cgraph_materialize_all_clones (void)\n \t  if (node->clone_of && node->symbol.decl != node->clone_of->symbol.decl\n \t      && !gimple_has_body_p (node->symbol.decl))\n \t    {\n+\t      if (!node->clone_of->clone_of)\n+\t\tcgraph_get_body (node->clone_of);\n \t      if (gimple_has_body_p (node->clone_of->symbol.decl))\n \t        {\n \t\t  if (cgraph_dump_file)"}, {"sha": "1472483342f1df2d8ad0437018b64b4fa6afe224", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2e2a66815796bd961250264ff32809bae478a31/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2e2a66815796bd961250264ff32809bae478a31/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=a2e2a66815796bd961250264ff32809bae478a31", "patch": "@@ -1581,6 +1581,7 @@ expand_function (struct cgraph_node *node)\n   announce_function (decl);\n   node->process = 0;\n   gcc_assert (node->lowered);\n+  cgraph_get_body (node);\n \n   /* Generate RTL for the body of DECL.  */\n "}, {"sha": "9905ba78d665a66fa688c7cc4cdc3d2659270fdb", "filename": "gcc/ipa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2e2a66815796bd961250264ff32809bae478a31/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2e2a66815796bd961250264ff32809bae478a31/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=a2e2a66815796bd961250264ff32809bae478a31", "patch": "@@ -915,7 +915,7 @@ function_and_variable_visibility (bool whole_program)\n \t\t  struct cgraph_edge *e = node->callers;\n \n \t\t  cgraph_redirect_edge_callee (e, alias);\n-\t\t  if (!flag_wpa)\n+\t\t  if (gimple_has_body_p (e->caller->symbol.decl))\n \t\t    {\n \t\t      push_cfun (DECL_STRUCT_FUNCTION (e->caller->symbol.decl));\n \t\t      cgraph_redirect_edge_call_stmt_to_callee (e);"}, {"sha": "51dc705b28fc4b8c6a1f6fa4b6c552d51fce0f0d", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2e2a66815796bd961250264ff32809bae478a31/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2e2a66815796bd961250264ff32809bae478a31/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=a2e2a66815796bd961250264ff32809bae478a31", "patch": "@@ -376,7 +376,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bool boundary_p;\n   intptr_t ref;\n   bool in_other_partition = false;\n-  struct cgraph_node *clone_of;\n+  struct cgraph_node *clone_of, *ultimate_clone_of;\n   struct ipa_opt_pass_d *pass;\n   int i;\n   bool alias_p;\n@@ -423,7 +423,16 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n     else\n       clone_of = clone_of->clone_of;\n \n-  if (LTO_symtab_analyzed_node)\n+  /* See if body of the master function is output.  If not, we are seeing only\n+     an declaration and we do not need to pass down clone tree. */\n+  ultimate_clone_of = clone_of;\n+  while (ultimate_clone_of && ultimate_clone_of->clone_of)\n+    ultimate_clone_of = ultimate_clone_of->clone_of;\n+\n+  if (clone_of && !lto_symtab_encoder_encode_body_p (encoder, ultimate_clone_of))\n+    clone_of = NULL;\n+\n+  if (tag == LTO_symtab_analyzed_node)\n     gcc_assert (clone_of || !node->clone_of);\n   if (!clone_of)\n     streamer_write_hwi_stream (ob->main_stream, LCC_NOT_FOUND);"}, {"sha": "cb10a4bf8c8d55ba97a6f1b30a6fbc34d7363e7a", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2e2a66815796bd961250264ff32809bae478a31/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2e2a66815796bd961250264ff32809bae478a31/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=a2e2a66815796bd961250264ff32809bae478a31", "patch": "@@ -1,3 +1,7 @@\n+2013-08-06  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (lto_materialize_function): Do not read body anymore.\n+\n 2013-08-02  Jan Hubicka  <jh@suse.cz>\n \n \t* lto.c (lto_materialize_function): Do not push struct function."}, {"sha": "c854589c673df7627b67233f1d1c73d8af5455a2", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 3, "deletions": 32, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2e2a66815796bd961250264ff32809bae478a31/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2e2a66815796bd961250264ff32809bae478a31/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=a2e2a66815796bd961250264ff32809bae478a31", "patch": "@@ -192,48 +192,19 @@ static void\n lto_materialize_function (struct cgraph_node *node)\n {\n   tree decl;\n-  struct lto_file_decl_data *file_data;\n-  const char *data, *name;\n-  size_t len;\n \n   decl = node->symbol.decl;\n   /* Read in functions with body (analyzed nodes)\n      and also functions that are needed to produce virtual clones.  */\n   if ((cgraph_function_with_gimple_body_p (node) && node->symbol.analyzed)\n+      || node->used_as_abstract_origin\n       || has_analyzed_clone_p (node))\n     {\n       /* Clones don't need to be read.  */\n       if (node->clone_of)\n \treturn;\n-\n-      /* Load the function body only if not operating in WPA mode.  In\n-\t WPA mode, the body of the function is not needed.  */\n-      if (!flag_wpa)\n-\t{\n-\t  file_data = node->symbol.lto_file_data;\n-\t  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n-\n-\t  /* We may have renamed the declaration, e.g., a static function.  */\n-\t  name = lto_get_decl_name_mapping (file_data, name);\n-\n-\t  data = lto_get_section_data (file_data, LTO_section_function_body,\n-\t\t\t\t       name, &len);\n-\t  if (!data)\n-\t    fatal_error (\"%s: section %s is missing\",\n-\t\t\t file_data->file_name,\n-\t\t\t name);\n-\n-\t  gcc_assert (DECL_STRUCT_FUNCTION (decl) == NULL);\n-\n-\t  announce_function (decl);\n-\t  lto_input_function_body (file_data, decl, data);\n-\t  if (DECL_FUNCTION_PERSONALITY (decl) && !first_personality_decl)\n-\t    first_personality_decl = DECL_FUNCTION_PERSONALITY (decl);\n-\t  lto_stats.num_function_bodies++;\n-\t  lto_free_section_data (file_data, LTO_section_function_body, name,\n-\t\t\t\t data, len);\n-\t  ggc_collect ();\n-\t}\n+      if (DECL_FUNCTION_PERSONALITY (decl) && !first_personality_decl)\n+\tfirst_personality_decl = DECL_FUNCTION_PERSONALITY (decl);\n     }\n \n   /* Let the middle end know about the function.  */"}, {"sha": "e3a7212ccce3574bcf56973cdc238a253a1cc314", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2e2a66815796bd961250264ff32809bae478a31/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2e2a66815796bd961250264ff32809bae478a31/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=a2e2a66815796bd961250264ff32809bae478a31", "patch": "@@ -1597,6 +1597,7 @@ do_per_function_toporder (void (*callback) (void *data), void *data)\n \t  node->process = 0;\n \t  if (cgraph_function_with_gimple_body_p (node))\n \t    {\n+\t      cgraph_get_body (node);\n \t      push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n \t      callback (data);\n \t      free_dominance_info (CDI_DOMINATORS);"}, {"sha": "e33e5a3a7e7607f7a0b62d1a106812d3ada57e51", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2e2a66815796bd961250264ff32809bae478a31/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2e2a66815796bd961250264ff32809bae478a31/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=a2e2a66815796bd961250264ff32809bae478a31", "patch": "@@ -3939,6 +3939,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n       goto egress;\n     }\n   fn = cg_edge->callee->symbol.decl;\n+  cgraph_get_body (cg_edge->callee);\n \n #ifdef ENABLE_CHECKING\n   if (cg_edge->callee->symbol.decl != id->dst_node->symbol.decl)"}, {"sha": "ff6babb14a3c415ce3974637c31d527c4e59c89d", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2e2a66815796bd961250264ff32809bae478a31/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2e2a66815796bd961250264ff32809bae478a31/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=a2e2a66815796bd961250264ff32809bae478a31", "patch": "@@ -7088,8 +7088,9 @@ ipa_pta_execute (void)\n       /* Nodes without a body are not interesting.  Especially do not\n          visit clones at this point for now - we get duplicate decls\n \t there for inline clones at least.  */\n-      if (!cgraph_function_with_gimple_body_p (node))\n+      if (!cgraph_function_with_gimple_body_p (node) || node->clone_of)\n \tcontinue;\n+      cgraph_get_body (node);\n \n       gcc_assert (!node->clone_of);\n \n@@ -7122,7 +7123,7 @@ ipa_pta_execute (void)\n       basic_block bb;\n \n       /* Nodes without a body are not interesting.  */\n-      if (!cgraph_function_with_gimple_body_p (node))\n+      if (!cgraph_function_with_gimple_body_p (node) || node->clone_of)\n \tcontinue;\n \n       if (dump_file)\n@@ -7231,7 +7232,7 @@ ipa_pta_execute (void)\n       struct cgraph_edge *e;\n \n       /* Nodes without a body are not interesting.  */\n-      if (!cgraph_function_with_gimple_body_p (node))\n+      if (!cgraph_function_with_gimple_body_p (node) || node->clone_of)\n \tcontinue;\n \n       fn = DECL_STRUCT_FUNCTION (node->symbol.decl);"}]}