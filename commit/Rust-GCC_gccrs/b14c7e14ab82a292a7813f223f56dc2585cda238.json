{"sha": "b14c7e14ab82a292a7813f223f56dc2585cda238", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE0YzdlMTRhYjgyYTI5MmE3ODEzZjIyM2Y1NmRjMjU4NWNkYTIzOA==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2005-12-09T02:53:41Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2005-12-09T02:53:41Z"}, "message": "re PR libfortran/25039 ([4.1 only] comma short-circuit field width)\n\n2005-12-08  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libgfortran/25039\n\t* io/io.h: Create a new flag sf_read_comma to control comma\n\tseparators in numeric reads.\n\t* io/transfer.c (formatted_transfer_scalar): Initialize the flag.\n\t(read_sf): Check for commas coming in and if the flag is set,\n\tshortcut the read.\n\t* io/read.c (read_a) (read_x): Clear the flag for character reads and\n\treset it after the reads.\n\nFrom-SVN: r108271", "tree": {"sha": "5889deeb49a6f23a2237c4405b7a024084c89977", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5889deeb49a6f23a2237c4405b7a024084c89977"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b14c7e14ab82a292a7813f223f56dc2585cda238", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b14c7e14ab82a292a7813f223f56dc2585cda238", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b14c7e14ab82a292a7813f223f56dc2585cda238", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b14c7e14ab82a292a7813f223f56dc2585cda238/comments", "author": null, "committer": null, "parents": [{"sha": "7691ec4e73c9b12b8216fe5181bf7bdc9c404eb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7691ec4e73c9b12b8216fe5181bf7bdc9c404eb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7691ec4e73c9b12b8216fe5181bf7bdc9c404eb3"}], "stats": {"total": 37, "additions": 36, "deletions": 1}, "files": [{"sha": "1810d224bfa4e6c6a9431cc5b87cc89aeb72bf28", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b14c7e14ab82a292a7813f223f56dc2585cda238/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b14c7e14ab82a292a7813f223f56dc2585cda238/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=b14c7e14ab82a292a7813f223f56dc2585cda238", "patch": "@@ -1,3 +1,14 @@\n+2005-12-08  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/25039\n+\t* io/io.h: Create a new flag sf_read_comma to control comma\n+\tseparators in numeric reads.\n+\t* io/transfer.c (formatted_transfer_scalar): Initialize the flag.\n+\t(read_sf): Check for commas coming in and if the flag is set,\n+\tshortcut the read.\n+\t* io/read.c (read_a) (read_x): Clear the flag for character reads and\n+\treset it after the reads.\n+\n 2005-12-04  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \t* io/format.c: Removing unused code."}, {"sha": "e7b0ac18d1e2e8d230a728b0d52b8bb6aa5243ce", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b14c7e14ab82a292a7813f223f56dc2585cda238/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b14c7e14ab82a292a7813f223f56dc2585cda238/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=b14c7e14ab82a292a7813f223f56dc2585cda238", "patch": "@@ -394,7 +394,11 @@ typedef struct st_parameter_dt\n \t     to flag read errors and return, so that an attempt can be\n \t     made to read a new object name.  */\n \t  unsigned nml_read_error : 1;\n-\t  /* 20 unused bits.  */\n+\t  /* A sequential formatted read specific flag used to signal that a\n+\t     character string is being read so don't use commas to shorten a\n+\t     formatted field width.  */\n+\t  unsigned sf_read_comma : 1;\n+\t  /* 19 unused bits.  */\n \n \t  char last_char;\n \t  char nml_delim;"}, {"sha": "e1e61ee30da5d3ab6a4c596fee44638c7545e701", "filename": "libgfortran/io/read.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b14c7e14ab82a292a7813f223f56dc2585cda238/libgfortran%2Fio%2Fread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b14c7e14ab82a292a7813f223f56dc2585cda238/libgfortran%2Fio%2Fread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fread.c?ref=b14c7e14ab82a292a7813f223f56dc2585cda238", "patch": "@@ -244,7 +244,9 @@ read_a (st_parameter_dt *dtp, const fnode *f, char *p, int length)\n   if (w == -1) /* '(A)' edit descriptor  */\n     w = length;\n \n+  dtp->u.p.sf_read_comma = 0;\n   source = read_block (dtp, &w);\n+  dtp->u.p.sf_read_comma = 1;\n   if (source == NULL)\n     return;\n   if (w > length)\n@@ -843,6 +845,9 @@ read_x (st_parameter_dt *dtp, int n)\n       && dtp->u.p.current_unit->bytes_left < n)\n     n = dtp->u.p.current_unit->bytes_left;\n \n+  dtp->u.p.sf_read_comma = 0;\n   if (n > 0)\n     read_block (dtp, &n);\n+  dtp->u.p.sf_read_comma = 1;\n+\n }"}, {"sha": "b2d26ac7be888e7eb92d304f2f2d965fb82de4bb", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b14c7e14ab82a292a7813f223f56dc2585cda238/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b14c7e14ab82a292a7813f223f56dc2585cda238/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=b14c7e14ab82a292a7813f223f56dc2585cda238", "patch": "@@ -210,6 +210,16 @@ read_sf (st_parameter_dt *dtp, int *length)\n \t  dtp->u.p.sf_seen_eor = (crlf ? 2 : 1);\n \t  break;\n \t}\n+      /*  Short circuit the read if a comma is found during numeric input.\n+\t  The flag is set to zero during character reads so that commas in\n+\t  strings are not ignored  */\n+      if (*q == ',')\n+\tif (dtp->u.p.sf_read_comma == 1)\n+\t  {\n+\t    notify_std (GFC_STD_GNU, \"Comma in formatted numeric read.\");\n+\t    *length = n;\n+\t    break;\n+\t  }\n \n       n++;\n       *p++ = *q;\n@@ -527,6 +537,11 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int len,\n   if (dtp->u.p.eor_condition)\n     return;\n \n+  /* Set this flag so that commas in reads cause the read to complete before\n+     the entire field has been read.  The next read field will start right after\n+     the comma in the stream.  (Set to 0 for character reads).  */\n+  dtp->u.p.sf_read_comma = 1;\n+\n   dtp->u.p.line_buffer = scratch;\n   for (;;)\n     {"}]}