{"sha": "7a442791bbd35236ae2c45e383db88d704f8f41c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2E0NDI3OTFiYmQzNTIzNmFlMmM0NWUzODNkYjg4ZDcwNGY4ZjQxYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-06-28T18:14:05Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-06-28T18:14:05Z"}, "message": "flow.c (try_merge_block): Rename to try_optimize_cfg; do basic simplifications on the CFG.\n\n\n\t* flow.c (try_merge_block): Rename to try_optimize_cfg;\n\tdo basic simplifications on the CFG.\n\t(is_forwarder_block_p, can_fallthru, try_redirect_by_replacing_jump,\n\t try_simplify_condjump): New.\n\t(redirect_edge_and_branch): Try replace jump insn.\n\t(flow_delete_insn): Handle deleting of ADDR_VEC insns.\n\n\t* basic-block.h (FALLTHRU_EDGE, BRANCH_EDGE): New macros.\n\nFrom-SVN: r43642", "tree": {"sha": "411b8f5eb989eadf53babde84c57d46a4759fd2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/411b8f5eb989eadf53babde84c57d46a4759fd2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a442791bbd35236ae2c45e383db88d704f8f41c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a442791bbd35236ae2c45e383db88d704f8f41c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a442791bbd35236ae2c45e383db88d704f8f41c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a442791bbd35236ae2c45e383db88d704f8f41c/comments", "author": null, "committer": null, "parents": [{"sha": "d72c3ec3f65c7e75b9d7149de4eb02701992cdb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d72c3ec3f65c7e75b9d7149de4eb02701992cdb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d72c3ec3f65c7e75b9d7149de4eb02701992cdb9"}], "stats": {"total": 433, "additions": 400, "deletions": 33}, "files": [{"sha": "a6f96b4f54eb2d933720de3437a1602e5fd0a1e7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a442791bbd35236ae2c45e383db88d704f8f41c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a442791bbd35236ae2c45e383db88d704f8f41c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a442791bbd35236ae2c45e383db88d704f8f41c", "patch": "@@ -1,3 +1,14 @@\n+Thu Jun 28 20:13:11 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* flow.c (try_merge_block): Rename to try_optimize_cfg;\n+\tdo basic simplifications on the CFG.\n+\t(is_forwarder_block_p, can_fallthru, try_redirect_by_replacing_jump,\n+\t try_simplify_condjump): New.\n+\t(redirect_edge_and_branch): Try replace jump insn.\n+\t(flow_delete_insn): Handle deleting of ADDR_VEC insns.\n+\n+\t* basic-block.h (FALLTHRU_EDGE, BRANCH_EDGE): New macros.\n+\n Thu Jun 28 11:19:42 2001  Jeffrey A Law  (law@cygnus.com)\n \n \t* ssa-dce.c (eliminate_dead_code): Remove fake edges from the"}, {"sha": "8e4aa4182ea20e7eb99fbe45068c5bf577040956", "filename": "gcc/basic-block.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a442791bbd35236ae2c45e383db88d704f8f41c/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a442791bbd35236ae2c45e383db88d704f8f41c/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=7a442791bbd35236ae2c45e383db88d704f8f41c", "patch": "@@ -488,6 +488,14 @@ struct edge_list\n /* Number of edges in the compressed edge list.  */\n #define NUM_EDGES(el)\t\t\t((el)->num_edges)\n \n+/* BB is assumed to contain conditional jump.  Return the fallthru edge.  */\n+#define FALLTHRU_EDGE(bb)\t\t((bb)->succ->flags & EDGE_FALLTHRU \\\n+\t\t\t\t\t ? (bb)->succ : (bb)->succ->succ_next)\n+\n+/* BB is assumed to contain conditional jump.  Return the branch edge.  */\n+#define BRANCH_EDGE(bb)\t\t\t((bb)->succ->flags & EDGE_FALLTHRU \\\n+\t\t\t\t\t ? (bb)->succ->succ_next : (bb)->succ)\n+\n struct edge_list * create_edge_list\tPARAMS ((void));\n void free_edge_list\t\t\tPARAMS ((struct edge_list *));\n void print_edge_list\t\t\tPARAMS ((FILE *, struct edge_list *));"}, {"sha": "a18c6253873badc1259f2f5bc0962030ea86da3c", "filename": "gcc/flow.c", "status": "modified", "additions": 381, "deletions": 33, "changes": 414, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a442791bbd35236ae2c45e383db88d704f8f41c/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a442791bbd35236ae2c45e383db88d704f8f41c/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=7a442791bbd35236ae2c45e383db88d704f8f41c", "patch": "@@ -381,7 +381,12 @@ static int merge_blocks_move_predecessor_nojumps PARAMS ((basic_block,\n static int merge_blocks_move_successor_nojumps PARAMS ((basic_block,\n \t\t\t\t\t\t\tbasic_block));\n static int merge_blocks\t\t\tPARAMS ((edge,basic_block,basic_block));\n-static void try_merge_blocks\t\tPARAMS ((void));\n+static bool try_optimize_cfg\t\tPARAMS ((void));\n+static bool forwarder_block_p\t\tPARAMS ((basic_block));\n+static bool can_fallthru\t\tPARAMS ((basic_block, basic_block));\n+static bool try_redirect_by_replacing_jump PARAMS ((edge, basic_block));\n+static bool try_simplify_condjump\tPARAMS ((basic_block));\n+static bool try_forward_edges\t\tPARAMS ((basic_block));\n static void tidy_fallthru_edges\t\tPARAMS ((void));\n static int verify_wide_reg_1\t\tPARAMS ((rtx *, void *));\n static void verify_wide_reg\t\tPARAMS ((int, rtx, rtx));\n@@ -471,7 +476,7 @@ static int flow_loop_level_compute\tPARAMS ((struct loop *, int));\n static int flow_loops_level_compute\tPARAMS ((struct loops *));\n static void allocate_bb_life_data\tPARAMS ((void));\n static void find_sub_basic_blocks\tPARAMS ((basic_block));\n-static int redirect_edge_and_branch \tPARAMS ((edge, basic_block));\n+static bool redirect_edge_and_branch \tPARAMS ((edge, basic_block));\n static rtx block_label\t\t\tPARAMS ((basic_block));\n \f\n /* Find basic blocks of the current function.\n@@ -1010,7 +1015,8 @@ void\n cleanup_cfg ()\n {\n   delete_unreachable_blocks ();\n-  try_merge_blocks ();\n+  if (try_optimize_cfg ())\n+    delete_unreachable_blocks ();\n   mark_critical_edges ();\n \n   /* Kill the data we won't maintain.  */\n@@ -1586,22 +1592,161 @@ block_label (block)\n   return block->head;\n }\n \n+/* Return true if the block has no effect and only forwards control flow to\n+   its single destination.  */\n+static bool\n+forwarder_block_p (bb)\n+     basic_block bb;\n+{\n+  rtx insn;\n+  if (bb == EXIT_BLOCK_PTR || bb == ENTRY_BLOCK_PTR\n+      || !bb->succ || bb->succ->succ_next)\n+    return false;\n+\n+  insn = next_active_insn (bb->head);\n+  if (!insn)\n+    return false;\n+  if (GET_CODE (insn) == CODE_LABEL\n+      || (GET_CODE (insn) == JUMP_INSN && onlyjump_p (insn)))\n+    return true;\n+  return false;\n+}\n+\n+/* Return nonzero if we can reach target from src by falling trought.  */\n+static bool\n+can_fallthru (src, target)\n+     basic_block src, target;\n+{\n+  rtx insn = src->end;\n+  rtx insn2 = target->head;\n+\n+  if (!active_insn_p (insn2))\n+    insn2 = next_active_insn (insn2);\n+  /* ??? Later we may add code to move jump tables offline.  */\n+  return next_active_insn (insn) == insn2;\n+}\n+\n+/* Attempt to perform edge redirection by replacing possibly complex jump\n+   instruction by unconditional jump or removing jump completely.\n+   This can apply only if all edges now point to the same block. \n+\n+   The parameters and return values are equivalent to redirect_edge_and_branch.\n+ */\n+static bool\n+try_redirect_by_replacing_jump (e, target)\n+     edge e;\n+     basic_block target;\n+{\n+  basic_block src = e->src;\n+  rtx insn = src->end;\n+  edge tmp;\n+  rtx set;\n+  int fallthru = 0;\n+  rtx barrier;\n+\n+  /* Verify that all targets will be TARGET.  */\n+  for (tmp = src->succ; tmp; tmp = tmp->succ_next)\n+    if (tmp->dest != target && tmp != e)\n+      break;\n+  if (tmp || GET_CODE (insn) != JUMP_INSN)\n+    return false;\n+\n+  /* Avoid removing branch with side effects.  */\n+  set = single_set (insn);\n+  if (!set || side_effects_p (set))\n+    return false;\n+\n+  /* See if we can create the fallthru edge.  */\n+  if (can_fallthru (src, target))\n+    {\n+      src->end = PREV_INSN (insn);\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \"Removing jump %i.\\n\", INSN_UID (insn));\n+      flow_delete_insn (insn);\n+      fallthru = 1;\n+      insn = src->end;\n+    }\n+  /* If this already is simplejump, redirect it.  */\n+  else if (simplejump_p (insn))\n+    {\n+      if (e->dest == target)\n+\treturn false;\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \"Redirecting jump %i from %i to %i.\\n\",\n+\t\t INSN_UID (insn), e->dest->index, target->index);\n+      redirect_jump (insn, block_label (target), 0);\n+    }\n+  /* Or replace possibly complicated jump insn by simple jump insn.  */\n+  else\n+    {\n+      rtx target_label = block_label (target);\n+\n+      src->end = PREV_INSN (insn);\n+      src->end = emit_jump_insn_after (gen_jump (target_label), src->end);\n+      JUMP_LABEL (src->end) = target_label;\n+      LABEL_NUSES (target_label)++;\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \"Replacing insn %i by jump %i\\n\",\n+\t\t INSN_UID (insn), INSN_UID (src->end));\n+      flow_delete_insn (insn);\n+      insn = src->end;\n+    }\n+\n+  /* Keep only one edge out and set proper flags.  */\n+  while (src->succ->succ_next)\n+    remove_edge (src->succ);\n+  e = src->succ;\n+  if (fallthru)\n+    e->flags = EDGE_FALLTHRU;\n+  else\n+    e->flags = 0;\n+\n+  /* Fixup barriers.  */\n+  barrier = next_nonnote_insn (insn);\n+  if (fallthru && GET_CODE (barrier) == BARRIER)\n+    flow_delete_insn (barrier);\n+  else if (!fallthru && GET_CODE (barrier) != BARRIER)\n+    emit_barrier_after (insn);\n+\n+  if (e->dest != target)\n+    redirect_edge_succ (e, target);\n+  return true;\n+}\n+\n /* Attempt to change code to redirect edge E to TARGET.\n    Don't do that on expense of adding new instructions or reordering\n-   basic blocks.  */\n-static int\n+   basic blocks.\n+\n+   Function can be also called with edge destionation equivalent to the\n+   TARGET.  Then it should try the simplifications and do nothing if\n+   none is possible.\n+\n+   Return true if transformation suceeded.  We still return flase in case\n+   E already destinated TARGET and we didn't managed to simplify instruction\n+   stream.  */\n+static bool\n redirect_edge_and_branch (e, target)\n      edge e;\n      basic_block target;\n {\n-  rtx insn = e->src->end;\n   rtx tmp;\n   rtx old_label = e->dest->head;\n+  basic_block src = e->src;\n+  rtx insn = src->end;\n+\n+  if (try_redirect_by_replacing_jump (e, target))\n+    return true;\n+  /* Do this fast path late, as we want above code to simplify for cases\n+     where called on single edge leaving basic block containing nontrivial\n+     jump insn.  */\n+  else if (e->dest == target)\n+    return false;\n+\n+  /* We can only redirect non-fallthru edges of jump insn.  */\n   if (e->flags & EDGE_FALLTHRU)\n-    return 0;\n-\n+    return false;\n   if (GET_CODE (insn) != JUMP_INSN)\n-    abort ();\n+    return false;\n \n   /* Recognize a tablejump and adjust all matching cases.  */\n   if ((tmp = JUMP_LABEL (insn)) != NULL_RTX\n@@ -1646,23 +1791,39 @@ redirect_edge_and_branch (e, target)\n \t one basic block to the other in case only one computed_jump is\n \t available.  */\n       if (computed_jump_p (insn))\n-\treturn 0;\n+\treturn false;\n \n       /* A return instruction can't be redirected.  */\n       if (returnjump_p (insn))\n-\treturn 0;\n+\treturn false;\n \n       /* If the insn doesn't go where we think, we're confused.  */\n       if (JUMP_LABEL (insn) != old_label)\n \tabort ();\n       redirect_jump (insn, block_label (target), 0);\n     }\n \n-  redirect_edge_succ (e, target);\n-  return 1;\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \"Edge %i->%i redirected to %i\\n\",\n+\t     e->src->index, e->dest->index, target->index);\n+  if (e->dest != target)\n+    {\n+      edge s;\n+      /* Check whether the edge is already present.  */\n+      for (s = src->succ; s; s=s->succ_next)\n+\tif (s->dest == target)\n+\t  break;\n+      if (s)\n+\t{\n+\t  s->flags |= e->flags;\n+\t  remove_edge (e);\n+\t}\n+      else\n+\tredirect_edge_succ (e, target);\n+    }\n+  return true;\n }\n \n-\n /* Split a (typically critical) edge.  Return the new block.\n    Abort on abnormal edges.\n \n@@ -2331,6 +2492,19 @@ flow_delete_insn (insn)\n \t   && GET_CODE (XEXP (note, 0)) == CODE_LABEL)\n     LABEL_NUSES (XEXP (note, 0))--;\n \n+  if (GET_CODE (insn) == JUMP_INSN\n+      && (GET_CODE (PATTERN (insn)) == ADDR_VEC\n+\t  || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC))\n+    {\n+      rtx pat = PATTERN (insn);\n+      int diff_vec_p = GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC;\n+      int len = XVECLEN (pat, diff_vec_p);\n+      int i;\n+\n+      for (i = 0; i < len; i++)\n+\tLABEL_NUSES (XEXP (XVECEXP (pat, diff_vec_p, i), 0))--;\n+    }\n+\n   return next;\n }\n \n@@ -2668,37 +2842,211 @@ merge_blocks (e, b, c)\n     }\n }\n \n-/* Top level driver for merge_blocks.  */\n+/* Simplify conditional jump around an jump.  \n+   Return nonzero in case optimization matched.  */\n \n-static void\n-try_merge_blocks ()\n+static bool\n+try_simplify_condjump (src)\n+     basic_block src;\n+{\n+  basic_block final_block, next_block;\n+  rtx insn = src->end;\n+  edge branch, fallthru;\n+\n+  if (!any_condjump_p (insn))\n+    return false;\n+\n+  fallthru = FALLTHRU_EDGE (src);\n+\n+  /* Following block must be simple forwarder block with single\n+     entry and must not be last in the stream.  */\n+  next_block = fallthru->dest;\n+  if (!forwarder_block_p (next_block)\n+      || next_block->pred->pred_next\n+      || next_block->index == n_basic_blocks - 1)\n+    return false;\n+\n+  /* The branch must target to block afterwards.  */\n+  final_block = BASIC_BLOCK (next_block->index + 1);\n+\n+  branch = BRANCH_EDGE (src);\n+\n+  if (branch->dest != final_block)\n+    return false;\n+\n+  /* Avoid jump.c from being overactive on removin ureachable insns.  */\n+  LABEL_NUSES (JUMP_LABEL (insn))++;\n+  if (!invert_jump (insn, block_label (next_block->succ->dest), 1))\n+    {\n+      LABEL_NUSES (JUMP_LABEL (insn))--;\n+      return false;\n+    }\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \"Simplifying condjump %i around jump %i\\n\",\n+\t     INSN_UID (insn), INSN_UID (next_block->end));\n+\n+  redirect_edge_succ (branch, final_block);\n+  redirect_edge_succ (fallthru, next_block->succ->dest);\n+\n+  branch->flags |= EDGE_FALLTHRU;\n+  fallthru->flags &= EDGE_FALLTHRU;\n+  \n+  flow_delete_block (next_block);\n+  return true;\n+}\n+\n+/* Attempt to forward edges leaving basic block B.\n+   Return nonzero if sucessfull.  */\n+\n+static bool\n+try_forward_edges (b)\n+     basic_block b;\n+{\n+  bool changed = 0;\n+  edge e;\n+  for (e = b->succ; e; e = e->succ_next)\n+    {\n+      basic_block target = e->dest, first = e->dest;\n+      int counter = 0;\n+\n+      /* Look for the real destination of jump.\n+         Avoid inifinite loop in the infinite empty loop by counting\n+         up to n_basic_blocks.  */\n+      while (forwarder_block_p (target)\n+\t     && target->succ->dest != EXIT_BLOCK_PTR\n+\t     && counter < n_basic_blocks)\n+\t{\n+\t  /* Bypass trivial infinite loops.  */\n+\t  if (target == target->succ->dest)\n+\t    counter = n_basic_blocks;\n+\t  target = target->succ->dest, counter++;\n+\t}\n+\n+      if (target != first && counter < n_basic_blocks\n+\t  && redirect_edge_and_branch (e, target))\n+\t{\n+\t  while (first != target)\n+\t    {\n+\t      first->count -= e->count;\n+\t      first->succ->count -= e->count;\n+\t      first->frequency -= ((e->probability * b->frequency\n+\t\t\t\t    + REG_BR_PROB_BASE / 2)\n+\t\t\t\t   / REG_BR_PROB_BASE);\n+\t      first = first->succ->dest;\n+\t    }\n+\t  /* We've possibly removed the edge.  */\n+\t  changed = 1;\n+\t  e = b->succ;\n+\t}\n+      else if (rtl_dump_file && counter == n_basic_blocks)\n+\tfprintf (rtl_dump_file, \"Infinite loop in BB %i.\\n\", target->index);\n+      else if (rtl_dump_file && first != target)\n+\tfprintf (rtl_dump_file,\n+\t\t \"Forwarding edge %i->%i to %i failed.\\n\", b->index,\n+\t\t e->dest->index, target->index);\n+    }\n+  return changed;\n+}\n+\n+/* Do simple CFG optimizations - basic block merging, simplifying of jump\n+   instructions etc.\n+\n+   Return nonzero in case some optimizations matched.  */\n+\n+static bool\n+try_optimize_cfg ()\n {\n   int i;\n+  bool changed_overall = 0;\n+  bool changed;\n \n   /* Attempt to merge blocks as made possible by edge removal.  If a block\n      has only one successor, and the successor has only one predecessor,\n      they may be combined.  */\n \n-  for (i = 0; i < n_basic_blocks;)\n+  do\n     {\n-      basic_block c, b = BASIC_BLOCK (i);\n-      edge s;\n+      changed = 0;\n+      for (i = 0; i < n_basic_blocks;)\n+\t{\n+\t  basic_block c, b = BASIC_BLOCK (i);\n+\t  edge s;\n+\t  int changed_here = 0;\n \n-      /* A loop because chains of blocks might be combineable.  */\n-      while ((s = b->succ) != NULL\n-\t     && s->succ_next == NULL\n-\t     && (s->flags & EDGE_EH) == 0\n-\t     && (c = s->dest) != EXIT_BLOCK_PTR\n-\t     && c->pred->pred_next == NULL\n-\t     /* If the jump insn has side effects, we can't kill the edge.  */\n-\t     && (GET_CODE (b->end) != JUMP_INSN\n-\t\t || onlyjump_p (b->end))\n-\t     && merge_blocks (s, b, c))\n-\tcontinue;\n+\t  /* Delete trivially dead basic block.  */\n+\t  if (b->pred == NULL)\n+\t    {\n+\t      c = BASIC_BLOCK (i - 1);\n+\t      if (rtl_dump_file)\n+\t\tfprintf (rtl_dump_file, \"Deleting block %i.\\n\", b->index);\n+\t      flow_delete_block (b);\n+\t      changed = 1;\n+\t      b = c;\n+\t    }\n+\t  /* The fallthru forwarder block can be deleted.  */\n+\t  if (b->pred->pred_next == NULL\n+\t      && forwarder_block_p (b)\n+\t      && (b->pred->flags & EDGE_FALLTHRU)\n+\t      && (b->succ->flags & EDGE_FALLTHRU))\n+\t    {\n+\t      if (rtl_dump_file)\n+\t\tfprintf (rtl_dump_file, \"Deleting fallthru block %i.\\n\",\n+\t\t\t b->index);\n+\t      c = BASIC_BLOCK (i ? i - 1 : i + 1);\n+\t      redirect_edge_succ (b->pred, b->succ->dest);\n+\t      flow_delete_block (b);\n+\t      changed = 1;\n+\t      b = c;\n+\t    }\n \n-      /* Don't get confused by the index shift caused by deleting blocks.  */\n-      i = b->index + 1;\n+\t  /* A loop because chains of blocks might be combineable.  */\n+\t  while ((s = b->succ) != NULL\n+\t\t && s->succ_next == NULL\n+\t\t && (s->flags & EDGE_EH) == 0\n+\t\t && (c = s->dest) != EXIT_BLOCK_PTR\n+\t\t && c->pred->pred_next == NULL\n+\t\t /* If the jump insn has side effects, we can't kill the edge.  */\n+\t\t && (GET_CODE (b->end) != JUMP_INSN\n+\t\t     || onlyjump_p (b->end)) && merge_blocks (s, b, c))\n+\t    changed_here = 1;\n+\n+\t  if (try_simplify_condjump (b))\n+\t    changed_here = 1;\n+\n+\t  /* In the case basic blocks has single outgoing edge, but over by the\n+\t     non-trivial jump instruction, we can replace it by unconditional\n+\t     jump, or delete the jump completely.  Use logic of\n+\t     redirect_edge_and_branch to do the dirty job for us.  \n+\n+\t     We match cases as conditional jumps jumping to the next block or\n+\t     dispatch tables.  */\n+\n+\t  if (b->succ\n+\t      && b->succ->succ_next == NULL\n+\t      && GET_CODE (b->end) == JUMP_INSN\n+\t      && b->succ->dest != EXIT_BLOCK_PTR\n+\t      && redirect_edge_and_branch (b->succ, b->succ->dest))\n+\t    changed_here = 1;\n+\n+\t  if (try_forward_edges (b))\n+\t    changed_here = 1;\n+\n+\t  /* Don't get confused by the index shift caused by deleting\n+\t     blocks.  */\n+\t  if (!changed_here)\n+\t    i = b->index + 1;\n+\t  else\n+\t    changed = 1;\n+\t}\n+      changed_overall |= changed;\n+      changed = 0;\n     }\n+  while (changed);\n+#ifdef ENABLE_CHECKING\n+  if (changed)\n+    verify_flow_info ();\n+#endif\n+  return changed_overall;\n }\n \n /* The given edge should potentially be a fallthru edge.  If that is in"}]}