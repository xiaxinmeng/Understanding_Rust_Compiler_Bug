{"sha": "45d144619c4c660a182a4d1e426648bb13f77b90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVkMTQ0NjE5YzRjNjYwYTE4MmE0ZDFlNDI2NjQ4YmIxM2Y3N2I5MA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2018-04-10T17:19:09Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2018-04-10T17:19:09Z"}, "message": "PR debug/65821 - wrong location for main().\n\n\t* call.c (clear_location_r, convert_default_arg): Revert.\n\t* tree.c (break_out_target_exprs): Add clear_location parm.\n\t(struct bot_data): New.\n\t(bot_manip): Clear location if requested.\n\t* init.c (get_nsdmi): Pass clear_location.\n\nFrom-SVN: r259291", "tree": {"sha": "0b6d25c43e8743bca9b6ffbc54e5e42515bba619", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b6d25c43e8743bca9b6ffbc54e5e42515bba619"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45d144619c4c660a182a4d1e426648bb13f77b90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45d144619c4c660a182a4d1e426648bb13f77b90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45d144619c4c660a182a4d1e426648bb13f77b90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45d144619c4c660a182a4d1e426648bb13f77b90/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f6d17c4d02a8fa3c99bae23c0f2ae213e8bd42be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6d17c4d02a8fa3c99bae23c0f2ae213e8bd42be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6d17c4d02a8fa3c99bae23c0f2ae213e8bd42be"}], "stats": {"total": 67, "additions": 36, "deletions": 31}, "files": [{"sha": "0f93be75eecef03163089b7358f8673a16190a9b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d144619c4c660a182a4d1e426648bb13f77b90/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d144619c4c660a182a4d1e426648bb13f77b90/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=45d144619c4c660a182a4d1e426648bb13f77b90", "patch": "@@ -1,3 +1,12 @@\n+2018-04-10  Jason Merrill  <jason@redhat.com>\n+\n+\tPR debug/65821 - wrong location for main().\n+\t* call.c (clear_location_r, convert_default_arg): Revert.\n+\t* tree.c (break_out_target_exprs): Add clear_location parm.\n+\t(struct bot_data): New.\n+\t(bot_manip): Clear location if requested.\n+\t* init.c (get_nsdmi): Pass clear_location.\n+\n 2018-04-10  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c++/85110"}, {"sha": "fb6d71d260d24e8c974f5ee01703570f72af47a4", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d144619c4c660a182a4d1e426648bb13f77b90/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d144619c4c660a182a4d1e426648bb13f77b90/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=45d144619c4c660a182a4d1e426648bb13f77b90", "patch": "@@ -7296,21 +7296,6 @@ cxx_type_promotes_to (tree type)\n   return promote;\n }\n \n-/* walk_tree callback to override EXPR_LOCATION in an expression tree.  */\n-\n-tree\n-clear_location_r (tree *tp, int *walk_subtrees, void */*data*/)\n-{\n-  if (!EXPR_P (*tp))\n-    {\n-      *walk_subtrees = 0;\n-      return NULL_TREE;\n-    }\n-  if (EXPR_HAS_LOCATION (*tp))\n-    SET_EXPR_LOCATION (*tp, input_location);\n-  return NULL_TREE;\n-}\n-\n /* ARG is a default argument expression being passed to a parameter of\n    the indicated TYPE, which is a parameter to FN.  PARMNUM is the\n    zero-based argument number.  Do any required conversions.  Return\n@@ -7374,11 +7359,7 @@ convert_default_arg (tree type, tree arg, tree fn, int parmnum,\n   push_deferring_access_checks (dk_no_check);\n   /* We must make a copy of ARG, in case subsequent processing\n      alters any part of it.  */\n-  arg = break_out_target_exprs (arg);\n-\n-  /* The use of a default argument has the location of the call, not where it\n-     was originally written.  */\n-  cp_walk_tree_without_duplicates (&arg, clear_location_r, NULL);\n+  arg = break_out_target_exprs (arg, /*clear location*/true);\n \n   arg = convert_for_initialization (0, type, arg, LOOKUP_IMPLICIT,\n \t\t\t\t    ICR_DEFAULT_ARGUMENT, fn, parmnum,"}, {"sha": "d0f87603e98ef018cd767581fd01d123616c0030", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d144619c4c660a182a4d1e426648bb13f77b90/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d144619c4c660a182a4d1e426648bb13f77b90/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=45d144619c4c660a182a4d1e426648bb13f77b90", "patch": "@@ -7060,7 +7060,7 @@ extern tree build_exception_variant\t\t(tree, tree);\n extern tree bind_template_template_parm\t\t(tree, tree);\n extern tree array_type_nelts_total\t\t(tree);\n extern tree array_type_nelts_top\t\t(tree);\n-extern tree break_out_target_exprs\t\t(tree);\n+extern tree break_out_target_exprs\t\t(tree, bool = false);\n extern tree build_ctor_subob_ref\t\t(tree, tree, tree);\n extern tree replace_placeholders\t\t(tree, tree, bool * = NULL);\n extern bool find_placeholders\t\t\t(tree);"}, {"sha": "5bc8394222b976c6e56a7be513821b27ef7f9a73", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d144619c4c660a182a4d1e426648bb13f77b90/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d144619c4c660a182a4d1e426648bb13f77b90/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=45d144619c4c660a182a4d1e426648bb13f77b90", "patch": "@@ -634,7 +634,7 @@ get_nsdmi (tree member, bool in_ctor, tsubst_flags_t complain)\n   bool simple_target = (init && SIMPLE_TARGET_EXPR_P (init));\n   if (simple_target)\n     init = TARGET_EXPR_INITIAL (init);\n-  init = break_out_target_exprs (init);\n+  init = break_out_target_exprs (init, /*loc*/true);\n   if (simple_target && TREE_CODE (init) != CONSTRUCTOR)\n     /* Now put it back so C++17 copy elision works.  */\n     init = get_target_expr (init);"}, {"sha": "dbe84c08a8fc627aaa58e1786941e26d705a2666", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d144619c4c660a182a4d1e426648bb13f77b90/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d144619c4c660a182a4d1e426648bb13f77b90/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=45d144619c4c660a182a4d1e426648bb13f77b90", "patch": "@@ -2908,12 +2908,19 @@ array_type_nelts_total (tree type)\n   return sz;\n }\n \n+struct bot_data\n+{\n+  splay_tree target_remap;\n+  bool clear_location;\n+};\n+\n /* Called from break_out_target_exprs via mapcar.  */\n \n static tree\n-bot_manip (tree* tp, int* walk_subtrees, void* data)\n+bot_manip (tree* tp, int* walk_subtrees, void* data_)\n {\n-  splay_tree target_remap = ((splay_tree) data);\n+  bot_data &data = *(bot_data*)data_;\n+  splay_tree target_remap = data.target_remap;\n   tree t = *tp;\n \n   if (!TYPE_P (t) && TREE_CONSTANT (t) && !TREE_SIDE_EFFECTS (t))\n@@ -2953,7 +2960,8 @@ bot_manip (tree* tp, int* walk_subtrees, void* data)\n \t\t\t (splay_tree_key) TREE_OPERAND (t, 0),\n \t\t\t (splay_tree_value) TREE_OPERAND (u, 0));\n \n-      TREE_OPERAND (u, 1) = break_out_target_exprs (TREE_OPERAND (u, 1));\n+      TREE_OPERAND (u, 1) = break_out_target_exprs (TREE_OPERAND (u, 1),\n+\t\t\t\t\t\t    data.clear_location);\n       if (TREE_OPERAND (u, 1) == error_mark_node)\n \treturn error_mark_node;\n \n@@ -2993,6 +3001,8 @@ bot_manip (tree* tp, int* walk_subtrees, void* data)\n   t = copy_tree_r (tp, walk_subtrees, NULL);\n   if (TREE_CODE (*tp) == CALL_EXPR)\n     set_flags_from_callee (*tp);\n+  if (data.clear_location && EXPR_HAS_LOCATION (*tp))\n+    SET_EXPR_LOCATION (*tp, input_location);\n   return t;\n }\n \n@@ -3001,9 +3011,10 @@ bot_manip (tree* tp, int* walk_subtrees, void* data)\n    variables.  */\n \n static tree\n-bot_replace (tree* t, int* /*walk_subtrees*/, void* data)\n+bot_replace (tree* t, int* /*walk_subtrees*/, void* data_)\n {\n-  splay_tree target_remap = ((splay_tree) data);\n+  bot_data &data = *(bot_data*)data_;\n+  splay_tree target_remap = data.target_remap;\n \n   if (VAR_P (*t))\n     {\n@@ -3041,10 +3052,13 @@ bot_replace (tree* t, int* /*walk_subtrees*/, void* data)\n /* When we parse a default argument expression, we may create\n    temporary variables via TARGET_EXPRs.  When we actually use the\n    default-argument expression, we make a copy of the expression\n-   and replace the temporaries with appropriate local versions.  */\n+   and replace the temporaries with appropriate local versions.\n+\n+   If CLEAR_LOCATION is true, override any EXPR_LOCATION with\n+   input_location.  */\n \n tree\n-break_out_target_exprs (tree t)\n+break_out_target_exprs (tree t, bool clear_location /* = false */)\n {\n   static int target_remap_count;\n   static splay_tree target_remap;\n@@ -3053,9 +3067,10 @@ break_out_target_exprs (tree t)\n     target_remap = splay_tree_new (splay_tree_compare_pointers,\n \t\t\t\t   /*splay_tree_delete_key_fn=*/NULL,\n \t\t\t\t   /*splay_tree_delete_value_fn=*/NULL);\n-  if (cp_walk_tree (&t, bot_manip, target_remap, NULL) == error_mark_node)\n+  bot_data data = { target_remap, clear_location };\n+  if (cp_walk_tree (&t, bot_manip, &data, NULL) == error_mark_node)\n     t = error_mark_node;\n-  cp_walk_tree (&t, bot_replace, target_remap, NULL);\n+  cp_walk_tree (&t, bot_replace, &data, NULL);\n \n   if (!--target_remap_count)\n     {"}]}