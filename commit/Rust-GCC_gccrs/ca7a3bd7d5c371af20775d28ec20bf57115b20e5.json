{"sha": "ca7a3bd7d5c371af20775d28ec20bf57115b20e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E3YTNiZDdkNWMzNzFhZjIwNzc1ZDI4ZWMyMGJmNTcxMTViMjBlNQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-08-05T09:03:42Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-08-05T09:03:42Z"}, "message": "tree.h (force_fit_type): Return a tree, take three flags.\n\n\t* tree.h (force_fit_type): Return a tree, take three flags.\n\t* fold-const.c (force_fit_type): Set TREE_OVERFLOW and\n\tTREE_CONSTANT_OVERFLOW here.\n\t(int_const_binop, const_binop): Adjust.\n\t(size_int_type): Do sign extension here.\n\t(fold_convert_const, optimize_bit_field_compare,\n\tdecode_field_reference, all_ones_mask_p, fold_div_compare, fold,\n\tfold_negate_const, fold_abs_const, fold_not_const): Adjust.\n\t* tree.c (size_in_bytes, int_fits_type_p): Adjust.\n\n\t* cp/cvt.c (cp_convert_to_pointer): Adjust force_fit_type call.\n\n\t* java/jcf-parse.c (get_constant): Adjust force_fit_type call.\n\t* java/lex.h (SET_LVAL_NODE_TYPE): Remove.\n\t* java/lex.c (java_perform_atof): Use SET_LVAL_NODE directly.\n\t(do_java_lex): Likewise. Adjust force_fit_type call.\n\nFrom-SVN: r85599", "tree": {"sha": "267e3abff19f5eff30100b2ff7fa407469a91070", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/267e3abff19f5eff30100b2ff7fa407469a91070"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca7a3bd7d5c371af20775d28ec20bf57115b20e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca7a3bd7d5c371af20775d28ec20bf57115b20e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca7a3bd7d5c371af20775d28ec20bf57115b20e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca7a3bd7d5c371af20775d28ec20bf57115b20e5/comments", "author": null, "committer": null, "parents": [{"sha": "d36837f4cac8268ddb67fcf4f8ecfe323d79d92b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d36837f4cac8268ddb67fcf4f8ecfe323d79d92b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d36837f4cac8268ddb67fcf4f8ecfe323d79d92b"}], "stats": {"total": 349, "additions": 197, "deletions": 152}, "files": [{"sha": "d3c1d6bb91130e91a7809383751d0152eb1e5bb9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca7a3bd7d5c371af20775d28ec20bf57115b20e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca7a3bd7d5c371af20775d28ec20bf57115b20e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca7a3bd7d5c371af20775d28ec20bf57115b20e5", "patch": "@@ -1,3 +1,15 @@\n+2004-08-05  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* tree.h (force_fit_type): Return a tree, take three flags.\n+\t* fold-const.c (force_fit_type): Set TREE_OVERFLOW and\n+\tTREE_CONSTANT_OVERFLOW here.\n+\t(int_const_binop, const_binop): Adjust.\n+\t(size_int_type): Do sign extension here.\n+\t(fold_convert_const, optimize_bit_field_compare,\n+\tdecode_field_reference, all_ones_mask_p, fold_div_compare, fold,\n+\tfold_negate_const, fold_abs_const, fold_not_const): Adjust.\n+\t* tree.c (size_in_bytes, int_fits_type_p): Adjust.\n+\n 2004-08-05  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n \n \tPR tree-optimization/16864\n@@ -268,7 +280,7 @@\n \t* config/i386/xmmintrin.h: Include <mm_malloc.h>.\n \n 2004-08-03  H.J. Lu  <hongjiu.lu@intel.com>\n-\t    Tanguy Fautr\ufffd  <tfautre@pandora.be>\n+\t    Tanguy Fautr\u00c3  <tfautre@pandora.be>\n \n \t* config/i386/pmm_malloc.h: New file.\n "}, {"sha": "43ba64936e2c09f172e077fb8cf565063d4550e5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca7a3bd7d5c371af20775d28ec20bf57115b20e5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca7a3bd7d5c371af20775d28ec20bf57115b20e5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ca7a3bd7d5c371af20775d28ec20bf57115b20e5", "patch": "@@ -1,3 +1,7 @@\n+2004-08-05  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cvt.c (cp_convert_to_pointer): Adjust force_fit_type call.\n+\n 2004-08-04  Geoffrey Keating  <geoffk@apple.com>\n \n \t* decl.c (make_rtl_for_nonlocal_decl): Set DECL_ASSEMBLER_NAME rather"}, {"sha": "56057af26ddb9621cf0860c8c73fadc51ec799ad", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca7a3bd7d5c371af20775d28ec20bf57115b20e5/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca7a3bd7d5c371af20775d28ec20bf57115b20e5/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=ca7a3bd7d5c371af20775d28ec20bf57115b20e5", "patch": "@@ -267,8 +267,10 @@ cp_convert_to_pointer (tree type, tree expr, bool force)\n       else\n \texpr = build_int_2 (0, 0);\n       TREE_TYPE (expr) = type;\n+      \n       /* Fix up the representation of -1 if appropriate.  */\n-      force_fit_type (expr, 0);\n+      expr = force_fit_type (expr, 0, false, false);\n+      \n       return expr;\n     }\n   else if (TYPE_PTR_TO_MEMBER_P (type) && INTEGRAL_CODE_P (form))"}, {"sha": "0b225c05e029d2d8b65fbebc2830f5396888d6be", "filename": "gcc/fold-const.c", "status": "modified", "additions": 146, "deletions": 130, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca7a3bd7d5c371af20775d28ec20bf57115b20e5/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca7a3bd7d5c371af20775d28ec20bf57115b20e5/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=ca7a3bd7d5c371af20775d28ec20bf57115b20e5", "patch": "@@ -39,8 +39,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    size_int takes an integer value, and creates a tree constant\n    with type from `sizetype'.\n \n-   force_fit_type takes a constant and prior overflow indicator, and\n-   forces the value to fit the type.  It returns an overflow indicator.  */\n+   force_fit_type takes a constant, an overflowable flag and prior\n+   overflow indicators.  It forces the value to fit the type and sets\n+   TREE_OVERFLOW and TREE_CONSTANT_OVERFLOW as appropriate.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -184,30 +185,32 @@ decode (HOST_WIDE_INT *words, unsigned HOST_WIDE_INT *low,\n   *hi = words[2] + words[3] * BASE;\n }\n \f\n-/* Make the integer constant T valid for its type by setting to 0 or 1 all\n-   the bits in the constant that don't belong in the type.\n+/* T is an INT_CST node.  OVERFLOWABLE indicates if we are interested\n+   in overflow of the value, when >0 we are only interested in signed\n+   overflow, for <0 we are interested in any overflow.  OVERFLOWED\n+   indicates whether overflow has already occurred.  CONST_OVERFLOWED\n+   indicates whether constant overflow has already occurred.  We force\n+   T's value to be within range of T's type (by setting to 0 or 1 all\n+   the bits outside the type's range).  We set TREE_OVERFLOWED if,\n+  \tOVERFLOWED is non-zero,\n+\tor OVERFLOWABLE is >0 and signed overflow occurs\n+\tor OVERFLOWABLE is <0 and any overflow occurs\n+   We set TREE_CONSTANT_OVERFLOWED if,\n+        CONST_OVERFLOWED is non-zero\n+\tor we set TREE_OVERFLOWED.\n+  We return either the original T, or a copy.  */\n \n-   Return 1 if a signed overflow occurs, 0 otherwise.  If OVERFLOW is\n-   nonzero, a signed overflow has already occurred in calculating T, so\n-   propagate it.  */\n-\n-int\n-force_fit_type (tree t, int overflow)\n+tree\n+force_fit_type (tree t, int overflowable, bool overflowed, bool overflowed_const)\n {\n   unsigned HOST_WIDE_INT low;\n   HOST_WIDE_INT high;\n   unsigned int prec;\n+  int sign_extended_type;\n \n-  if (TREE_CODE (t) == REAL_CST)\n-    {\n-      /* ??? Used to check for overflow here via CHECK_FLOAT_TYPE.\n-\t Consider doing it via real_convert now.  */\n-      return overflow;\n-    }\n-\n-  else if (TREE_CODE (t) != INTEGER_CST)\n-    return overflow;\n-\n+  if (TREE_CODE (t) != INTEGER_CST)\n+    abort ();\n+  \n   low = TREE_INT_CST_LOW (t);\n   high = TREE_INT_CST_HIGH (t);\n \n@@ -216,54 +219,69 @@ force_fit_type (tree t, int overflow)\n     prec = POINTER_SIZE;\n   else\n     prec = TYPE_PRECISION (TREE_TYPE (t));\n+  /* Size types *are* sign extended.  */\n+  sign_extended_type = (!TYPE_UNSIGNED (TREE_TYPE (t))\n+\t\t\t|| (TREE_CODE (TREE_TYPE (t)) == INTEGER_TYPE\n+\t\t\t    && TYPE_IS_SIZETYPE (TREE_TYPE (t))));\n \n   /* First clear all bits that are beyond the type's precision.  */\n \n   if (prec == 2 * HOST_BITS_PER_WIDE_INT)\n     ;\n   else if (prec > HOST_BITS_PER_WIDE_INT)\n-    TREE_INT_CST_HIGH (t)\n-      &= ~((HOST_WIDE_INT) (-1) << (prec - HOST_BITS_PER_WIDE_INT));\n+    high &= ~((HOST_WIDE_INT) (-1) << (prec - HOST_BITS_PER_WIDE_INT));\n   else\n     {\n-      TREE_INT_CST_HIGH (t) = 0;\n+      high = 0;\n       if (prec < HOST_BITS_PER_WIDE_INT)\n-\tTREE_INT_CST_LOW (t) &= ~((unsigned HOST_WIDE_INT) (-1) << prec);\n-    }\n-\n-  /* Unsigned types do not suffer sign extension or overflow unless they\n-     are a sizetype.  */\n-  if (TYPE_UNSIGNED (TREE_TYPE (t))\n-      && ! (TREE_CODE (TREE_TYPE (t)) == INTEGER_TYPE\n-\t    && TYPE_IS_SIZETYPE (TREE_TYPE (t))))\n-    return overflow;\n-\n-  /* If the value's sign bit is set, extend the sign.  */\n-  if (prec != 2 * HOST_BITS_PER_WIDE_INT\n-      && (prec > HOST_BITS_PER_WIDE_INT\n-\t  ? 0 != (TREE_INT_CST_HIGH (t)\n-\t\t  & ((HOST_WIDE_INT) 1\n-\t\t     << (prec - HOST_BITS_PER_WIDE_INT - 1)))\n-\t  : 0 != (TREE_INT_CST_LOW (t)\n-\t\t  & ((unsigned HOST_WIDE_INT) 1 << (prec - 1)))))\n-    {\n-      /* Value is negative:\n-\t set to 1 all the bits that are outside this type's precision.  */\n-      if (prec > HOST_BITS_PER_WIDE_INT)\n-\tTREE_INT_CST_HIGH (t)\n-\t  |= ((HOST_WIDE_INT) (-1) << (prec - HOST_BITS_PER_WIDE_INT));\n-      else\n+\tlow &= ~((HOST_WIDE_INT) (-1) << prec);\n+    }\n+\n+  if (!sign_extended_type)\n+    /* No sign extension */;\n+  else if (prec == 2 * HOST_BITS_PER_WIDE_INT)\n+    /* Correct width already.  */;\n+  else if (prec > HOST_BITS_PER_WIDE_INT)\n+    {\n+      /* Sign extend top half? */\n+      if (high & ((unsigned HOST_WIDE_INT)1\n+\t\t  << (prec - HOST_BITS_PER_WIDE_INT - 1)))\n+\thigh |= (HOST_WIDE_INT) (-1) << (prec - HOST_BITS_PER_WIDE_INT);\n+    }\n+  else if (prec == HOST_BITS_PER_WIDE_INT)\n+    {\n+      if ((HOST_WIDE_INT)low < 0)\n+\thigh = -1;\n+    }\n+  else\n+    {\n+      /* Sign extend bottom half? */\n+      if (low & ((unsigned HOST_WIDE_INT)1 << (prec - 1)))\n \t{\n-\t  TREE_INT_CST_HIGH (t) = -1;\n-\t  if (prec < HOST_BITS_PER_WIDE_INT)\n-\t    TREE_INT_CST_LOW (t) |= ((unsigned HOST_WIDE_INT) (-1) << prec);\n+\t  high = -1;\n+\t  low |= (HOST_WIDE_INT)(-1) << prec;\n \t}\n     }\n \n-  /* Return nonzero if signed overflow occurred.  */\n-  return\n-    ((overflow | (low ^ TREE_INT_CST_LOW (t)) | (high ^ TREE_INT_CST_HIGH (t)))\n-     != 0);\n+  /* If the value changed, return a new node.  */\n+  if (overflowed || overflowed_const\n+      || low != TREE_INT_CST_LOW (t) || high != TREE_INT_CST_HIGH (t))\n+    {\n+      if (overflowed\n+\t  || overflowable < 0\n+\t  || (overflowable > 0 && sign_extended_type))\n+\t{\n+\t  TREE_OVERFLOW (t) = 1;\n+\t  TREE_CONSTANT_OVERFLOW (t) = 1;\n+\t}\n+      else if (overflowed_const)\n+\tTREE_CONSTANT_OVERFLOW (t) = 1;\n+      \n+      TREE_INT_CST_LOW (t) = low;\n+      TREE_INT_CST_HIGH (t) = high;\n+    }\n+  \n+  return t;\n }\n \f\n /* Add two doubleword integers with doubleword result.\n@@ -1404,25 +1422,24 @@ int_const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n       TREE_TYPE (t) = TREE_TYPE (arg1);\n     }\n \n-  TREE_OVERFLOW (t)\n-    = ((notrunc\n-\t? (!uns || is_sizetype) && overflow\n-\t: (force_fit_type (t, (!uns || is_sizetype) && overflow)\n-\t   && ! no_overflow))\n-       | TREE_OVERFLOW (arg1)\n-       | TREE_OVERFLOW (arg2));\n+  if (notrunc)\n+    {\n+      /* Propagate overflow flags ourselves.  */\n+      if (((!uns || is_sizetype) && overflow)\n+\t  | TREE_OVERFLOW (arg1) | TREE_OVERFLOW (arg2))\n+\tTREE_OVERFLOW (t) = 1;\n \n-  /* If we're doing a size calculation, unsigned arithmetic does overflow.\n-     So check if force_fit_type truncated the value.  */\n-  if (is_sizetype\n-      && ! TREE_OVERFLOW (t)\n-      && (TREE_INT_CST_HIGH (t) != hi\n-\t  || TREE_INT_CST_LOW (t) != low))\n-    TREE_OVERFLOW (t) = 1;\n-\n-  TREE_CONSTANT_OVERFLOW (t) = (TREE_OVERFLOW (t)\n-\t\t\t\t| TREE_CONSTANT_OVERFLOW (arg1)\n-\t\t\t\t| TREE_CONSTANT_OVERFLOW (arg2));\n+      if (TREE_OVERFLOW (t) | TREE_CONSTANT_OVERFLOW (arg1)\n+\t  | TREE_CONSTANT_OVERFLOW (arg2))\n+\tTREE_CONSTANT_OVERFLOW (t) = 1;\n+    }\n+  else\n+    t = force_fit_type (t, 1,\n+\t\t\t((!uns || is_sizetype) && overflow)\n+\t\t\t| TREE_OVERFLOW (arg1) | TREE_OVERFLOW (arg2),\n+\t\t\tTREE_CONSTANT_OVERFLOW (arg1)\n+\t\t\t| TREE_CONSTANT_OVERFLOW (arg2));\n+  \n   return t;\n }\n \n@@ -1479,9 +1496,7 @@ const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n \n       t = build_real (type, real_value_truncate (mode, value));\n \n-      TREE_OVERFLOW (t)\n-\t= (force_fit_type (t, 0)\n-\t   | TREE_OVERFLOW (arg1) | TREE_OVERFLOW (arg2));\n+      TREE_OVERFLOW (t) = TREE_OVERFLOW (arg1) | TREE_OVERFLOW (arg2);\n       TREE_CONSTANT_OVERFLOW (t)\n \t= TREE_OVERFLOW (t)\n \t  | TREE_CONSTANT_OVERFLOW (arg1)\n@@ -1616,6 +1631,9 @@ tree\n size_int_type (HOST_WIDE_INT number, tree type)\n {\n   void **slot;\n+  unsigned int prec;\n+  HOST_WIDE_INT high;\n+  unsigned HOST_WIDE_INT low;\n \n   if (size_htab == 0)\n     {\n@@ -1626,12 +1644,26 @@ size_int_type (HOST_WIDE_INT number, tree type)\n   /* Adjust NEW_CONST to be the constant we want.  If it's already in the\n      hash table, we return the value from the hash table.  Otherwise, we\n      place that in the hash table and make a new node for the next time.  */\n-  TREE_INT_CST_LOW (new_const) = number;\n-  TREE_INT_CST_HIGH (new_const) = number < 0 ? -1 : 0;\n+  prec = TYPE_PRECISION (type);\n   TREE_TYPE (new_const) = type;\n-  TREE_OVERFLOW (new_const) = TREE_CONSTANT_OVERFLOW (new_const)\n-    = force_fit_type (new_const, 0);\n+  TREE_OVERFLOW (new_const) = TREE_CONSTANT_OVERFLOW (new_const) = 0;\n+  low = number;\n+  if (number >= 0)\n+    high = 0;\n+  else\n+    {\n+      /* Sizetype IS sign extended.  */\n+      high = -1;\n+      if (prec <= HOST_BITS_PER_WIDE_INT)\n+\tlow |= (HOST_WIDE_INT)(-1) << (prec - 1);\n+    }\n+  TREE_INT_CST_LOW (new_const) = low;\n+  TREE_INT_CST_HIGH (new_const) = high;\n \n+  if (low != (unsigned HOST_WIDE_INT)number\n+      || high != (number < 0 ? -1 : 0))\n+    TREE_OVERFLOW (new_const) = TREE_CONSTANT_OVERFLOW (new_const) = 1;\n+  \n   slot = htab_find_slot (size_htab, new_const, INSERT);\n   if (*slot == 0)\n     {\n@@ -1757,20 +1789,16 @@ fold_convert_const (enum tree_code code, tree type, tree arg1)\n \t  t = build_int_2 (TREE_INT_CST_LOW (arg1),\n \t\t\t   TREE_INT_CST_HIGH (arg1));\n \t  TREE_TYPE (t) = type;\n-\t  /* Indicate an overflow if (1) ARG1 already overflowed,\n-\t     or (2) force_fit_type indicates an overflow.\n-\t     Tell force_fit_type that an overflow has already occurred\n-\t     if ARG1 is a too-large unsigned value and T is signed.\n-\t     But don't indicate an overflow if converting a pointer.  */\n-\t  TREE_OVERFLOW (t)\n-\t    = ((force_fit_type (t,\n-\t\t\t\t(TREE_INT_CST_HIGH (arg1) < 0\n-\t\t\t\t && (TYPE_UNSIGNED (type)\n-\t\t\t\t    < TYPE_UNSIGNED (TREE_TYPE (arg1)))))\n-\t\t&& ! POINTER_TYPE_P (TREE_TYPE (arg1)))\n-\t       || TREE_OVERFLOW (arg1));\n-\t  TREE_CONSTANT_OVERFLOW (t)\n-\t    = TREE_OVERFLOW (t) | TREE_CONSTANT_OVERFLOW (arg1);\n+\n+\t  t = force_fit_type (t,\n+\t\t\t      /* Don't set the overflow when\n+\t\t\t      \t converting a pointer  */\n+\t\t\t      !POINTER_TYPE_P (TREE_TYPE (arg1)),\n+\t\t\t      (TREE_INT_CST_HIGH (arg1) < 0\n+\t\t\t       && (TYPE_UNSIGNED (type)\n+\t\t\t\t   < TYPE_UNSIGNED (TREE_TYPE (arg1))))\n+\t\t\t      | TREE_OVERFLOW (arg1),\n+\t\t\t      TREE_CONSTANT_OVERFLOW (arg1));\n \t  return t;\n \t}\n       else if (TREE_CODE (arg1) == REAL_CST)\n@@ -1785,7 +1813,6 @@ fold_convert_const (enum tree_code code, tree type, tree arg1)\n \t     FP-to-integer conversion is unspecified upon overflow.  */\n \n \t  HOST_WIDE_INT high, low;\n-\n \t  REAL_VALUE_TYPE r;\n \t  REAL_VALUE_TYPE x = TREE_REAL_CST (arg1);\n \n@@ -1854,10 +1881,9 @@ fold_convert_const (enum tree_code code, tree type, tree arg1)\n \n \t  t = build_int_2 (low, high);\n \t  TREE_TYPE (t) = type;\n-\t  TREE_OVERFLOW (t)\n-\t    = TREE_OVERFLOW (arg1) | force_fit_type (t, overflow);\n-\t  TREE_CONSTANT_OVERFLOW (t)\n-\t    = TREE_OVERFLOW (t) | TREE_CONSTANT_OVERFLOW (arg1);\n+\n+\t  t = force_fit_type (t, -1, overflow | TREE_OVERFLOW (arg1),\n+\t\t\t      TREE_CONSTANT_OVERFLOW (arg1));\n \t  return t;\n \t}\n     }\n@@ -1880,8 +1906,7 @@ fold_convert_const (enum tree_code code, tree type, tree arg1)\n \t\t\t  real_value_truncate (TYPE_MODE (type),\n \t\t\t\t\t       TREE_REAL_CST (arg1)));\n \n-\t  TREE_OVERFLOW (t)\n-\t    = TREE_OVERFLOW (arg1) | force_fit_type (t, 0);\n+\t  TREE_OVERFLOW (t) = TREE_OVERFLOW (arg1);\n \t  TREE_CONSTANT_OVERFLOW (t)\n \t    = TREE_OVERFLOW (t) | TREE_CONSTANT_OVERFLOW (arg1);\n \t  return t;\n@@ -3166,7 +3191,7 @@ optimize_bit_field_compare (enum tree_code code, tree compare_type,\n   /* Make the mask to be used against the extracted field.  */\n   mask = build_int_2 (~0, ~0);\n   TREE_TYPE (mask) = unsigned_type;\n-  force_fit_type (mask, 0);\n+  mask = force_fit_type (mask, 0, false, false);\n   mask = fold_convert (unsigned_type, mask);\n   mask = const_binop (LSHIFT_EXPR, mask, size_int (nbitsize - lbitsize), 0);\n   mask = const_binop (RSHIFT_EXPR, mask,\n@@ -3323,7 +3348,8 @@ decode_field_reference (tree exp, HOST_WIDE_INT *pbitsize,\n \n   mask = build_int_2 (~0, ~0);\n   TREE_TYPE (mask) = unsigned_type;\n-  force_fit_type (mask, 0);\n+  mask = force_fit_type (mask, 0, false, false);\n+  \n   mask = const_binop (LSHIFT_EXPR, mask, size_int (precision - *pbitsize), 0);\n   mask = const_binop (RSHIFT_EXPR, mask, size_int (precision - *pbitsize), 0);\n \n@@ -3349,7 +3375,8 @@ all_ones_mask_p (tree mask, int size)\n \n   tmask = build_int_2 (~0, ~0);\n   TREE_TYPE (tmask) = lang_hooks.types.signed_type (type);\n-  force_fit_type (tmask, 0);\n+  tmask = force_fit_type (tmask, 0, false, false);\n+  \n   return\n     tree_int_cst_equal (mask,\n \t\t\tconst_binop (RSHIFT_EXPR,\n@@ -5675,10 +5702,7 @@ fold_div_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n \t\t\t TREE_INT_CST_HIGH (arg1), &lpart, &hpart);\n   prod = build_int_2 (lpart, hpart);\n   TREE_TYPE (prod) = TREE_TYPE (arg00);\n-  TREE_OVERFLOW (prod) = force_fit_type (prod, overflow)\n-\t\t\t || TREE_INT_CST_HIGH (prod) != hpart\n-\t\t\t || TREE_INT_CST_LOW (prod) != lpart;\n-  TREE_CONSTANT_OVERFLOW (prod) = TREE_OVERFLOW (prod);\n+  prod = force_fit_type (prod, -1, overflow, false);\n \n   if (TYPE_UNSIGNED (TREE_TYPE (arg0)))\n     {\n@@ -5693,11 +5717,8 @@ fold_div_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n \t\t\t     &lpart, &hpart);\n       hi = build_int_2 (lpart, hpart);\n       TREE_TYPE (hi) = TREE_TYPE (arg00);\n-      TREE_OVERFLOW (hi) = force_fit_type (hi, overflow)\n-\t\t\t   || TREE_INT_CST_HIGH (hi) != hpart\n-\t\t\t   || TREE_INT_CST_LOW (hi) != lpart\n-\t\t\t   || TREE_OVERFLOW (prod);\n-      TREE_CONSTANT_OVERFLOW (hi) = TREE_OVERFLOW (hi);\n+      hi = force_fit_type (hi, -1, overflow | TREE_OVERFLOW (prod),\n+\t\t\t   TREE_CONSTANT_OVERFLOW (prod));\n     }\n   else if (tree_int_cst_sgn (arg01) >= 0)\n     {\n@@ -7238,7 +7259,7 @@ fold (tree expr)\n \t{\n \t  t1 = build_int_2 (-1, -1);\n \t  TREE_TYPE (t1) = type;\n-\t  force_fit_type (t1, 0);\n+\t  t1 = force_fit_type (t1, 0, false, false);\n \t  return omit_one_operand (type, t1, arg1);\n \t}\n \n@@ -7248,7 +7269,7 @@ fold (tree expr)\n \t{\n \t  t1 = build_int_2 (-1, -1);\n \t  TREE_TYPE (t1) = type;\n-\t  force_fit_type (t1, 0);\n+\t  t1 = force_fit_type (t1, 0, false, false);\n \t  return omit_one_operand (type, t1, arg0);\n \t}\n \n@@ -7289,7 +7310,7 @@ fold (tree expr)\n \t{\n \t  t1 = build_int_2 (-1, -1);\n \t  TREE_TYPE (t1) = type;\n-\t  force_fit_type (t1, 0);\n+\t  t1 = force_fit_type (t1, 0, false, false);\n \t  return omit_one_operand (type, t1, arg1);\n \t}\n \n@@ -7299,7 +7320,7 @@ fold (tree expr)\n \t{\n \t  t1 = build_int_2 (-1, -1);\n \t  TREE_TYPE (t1) = type;\n-\t  force_fit_type (t1, 0);\n+\t  t1 = force_fit_type (t1, 0, false, false);\n \t  return omit_one_operand (type, t1, arg0);\n \t}\n \n@@ -10340,11 +10361,10 @@ fold_negate_const (tree arg0, tree type)\n \t\t\t\t &low, &high);\n       t = build_int_2 (low, high);\n       TREE_TYPE (t) = type;\n-      TREE_OVERFLOW (t)\n-\t= (TREE_OVERFLOW (arg0)\n-\t   | force_fit_type (t, overflow && !TYPE_UNSIGNED (type)));\n-      TREE_CONSTANT_OVERFLOW (t)\n-\t= TREE_OVERFLOW (t) | TREE_CONSTANT_OVERFLOW (arg0);\n+      t = force_fit_type (t, 1,\n+\t\t\t  (overflow | TREE_OVERFLOW (arg0))\n+\t\t\t  && !TYPE_UNSIGNED (type),\n+\t\t\t  TREE_CONSTANT_OVERFLOW (arg0));\n     }\n   else if (TREE_CODE (arg0) == REAL_CST)\n     t = build_real (type, REAL_VALUE_NEGATE (TREE_REAL_CST (arg0)));\n@@ -10386,11 +10406,8 @@ fold_abs_const (tree arg0, tree type)\n \t\t\t\t     &low, &high);\n \t  t = build_int_2 (low, high);\n \t  TREE_TYPE (t) = type;\n-\t  TREE_OVERFLOW (t)\n-\t    = (TREE_OVERFLOW (arg0)\n-\t       | force_fit_type (t, overflow));\n-\t  TREE_CONSTANT_OVERFLOW (t)\n-\t    = TREE_OVERFLOW (t) | TREE_CONSTANT_OVERFLOW (arg0);\n+\t  t = force_fit_type (t, -1, overflow | TREE_OVERFLOW (arg0),\n+\t\t\t      TREE_CONSTANT_OVERFLOW (arg0));\n \t  return t;\n \t}\n     }\n@@ -10422,9 +10439,8 @@ fold_not_const (tree arg0, tree type)\n       t = build_int_2 (~ TREE_INT_CST_LOW (arg0),\n \t\t       ~ TREE_INT_CST_HIGH (arg0));\n       TREE_TYPE (t) = type;\n-      force_fit_type (t, 0);\n-      TREE_OVERFLOW (t) = TREE_OVERFLOW (arg0);\n-      TREE_CONSTANT_OVERFLOW (t) = TREE_CONSTANT_OVERFLOW (arg0);\n+      t = force_fit_type (t, 0, TREE_OVERFLOW (arg0),\n+\t\t\t  TREE_CONSTANT_OVERFLOW (arg0));\n     }\n #ifdef ENABLE_CHECKING\n   else"}, {"sha": "e2a768493c9b9d851fdccabf98402b03017b0ccd", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca7a3bd7d5c371af20775d28ec20bf57115b20e5/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca7a3bd7d5c371af20775d28ec20bf57115b20e5/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=ca7a3bd7d5c371af20775d28ec20bf57115b20e5", "patch": "@@ -1,3 +1,10 @@\n+2004-08-05  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* jcf-parse.c (get_constant): Adjust force_fit_type call.\n+\t* lex.h (SET_LVAL_NODE_TYPE): Remove.\n+\t* lex.c (java_perform_atof): Use SET_LVAL_NODE directly.\n+\t(do_java_lex): Likewise. Adjust force_fit_type call.\n+\n 2004-08-04  Roger Sayle  <roger@eyesopen.com>\n \t    Andrew Haley  <aph@redhat.com>\n "}, {"sha": "272ce96c779993e6e7eb811ee85f84e5ab26e22f", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca7a3bd7d5c371af20775d28ec20bf57115b20e5/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca7a3bd7d5c371af20775d28ec20bf57115b20e5/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=ca7a3bd7d5c371af20775d28ec20bf57115b20e5", "patch": "@@ -275,12 +275,13 @@ get_constant (JCF *jcf, int index)\n \tunsigned HOST_WIDE_INT num = JPOOL_UINT (jcf, index);\n \tunsigned HOST_WIDE_INT lo;\n \tHOST_WIDE_INT hi;\n+\t\n \tlshift_double (num, 0, 32, 64, &lo, &hi, 0);\n \tnum = JPOOL_UINT (jcf, index+1);\n \tadd_double (lo, hi, num, 0, &lo, &hi);\n \tvalue = build_int_2 (lo, hi);\n \tTREE_TYPE (value) = long_type_node;\n-\tforce_fit_type (value, 0);\n+\tvalue = force_fit_type (value, 0, false, false);\n \tbreak;\n       }\n "}, {"sha": "95fbd5763c48a3215a6415861ca3a7bc4e3c8668", "filename": "gcc/java/lex.c", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca7a3bd7d5c371af20775d28ec20bf57115b20e5/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca7a3bd7d5c371af20775d28ec20bf57115b20e5/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=ca7a3bd7d5c371af20775d28ec20bf57115b20e5", "patch": "@@ -939,7 +939,7 @@ java_perform_atof (YYSTYPE *java_lval, char *literal_token, int fflag,\n \t}\n     }\n \n-  SET_LVAL_NODE_TYPE (build_real (type, value), type);\n+  SET_LVAL_NODE (build_real (type, value));\n }\n #endif\n \n@@ -1278,9 +1278,10 @@ do_java_lex (YYSTYPE *java_lval)\n       /* Range checking.  */\n       value = build_int_2 (low, high);\n       /* Temporarily set type to unsigned.  */\n-      SET_LVAL_NODE_TYPE (value, (long_suffix\n-\t\t\t\t  ? unsigned_long_type_node\n-\t\t\t\t  : unsigned_int_type_node));\n+      TREE_TYPE (value) =  (long_suffix\n+\t\t\t    ? unsigned_long_type_node\n+\t\t\t    : unsigned_int_type_node);\n+      SET_LVAL_NODE (value);\n \n       /* For base 10 numbers, only values up to the highest value\n \t (plus one) can be written.  For instance, only ints up to\n@@ -1300,12 +1301,11 @@ do_java_lex (YYSTYPE *java_lval)\n \t}\n \n       /* Sign extend the value.  */\n-      SET_LVAL_NODE_TYPE (value, (long_suffix ? long_type_node : int_type_node));\n-      force_fit_type (value, 0);\n+      TREE_TYPE (value) = long_suffix ? long_type_node : int_type_node;\n+      value = force_fit_type (value, 0, false, false);\n+      SET_LVAL_NODE (value);\n+      \n       JAVA_RADIX10_FLAG (value) = radix == 10;\n-#else\n-      SET_LVAL_NODE_TYPE (build_int_2 (low, high),\n-\t\t\t  long_suffix ? long_type_node : int_type_node);\n #endif\n       return INT_LIT_TK;\n     }\n@@ -1314,6 +1314,7 @@ do_java_lex (YYSTYPE *java_lval)\n   if (c == '\\'')\n     {\n       int char_lit;\n+      \n       if ((c = java_get_unicode ()) == '\\\\')\n \tchar_lit = java_parse_escape_sequence ();\n       else\n@@ -1334,7 +1335,13 @@ do_java_lex (YYSTYPE *java_lval)\n         char_lit = 0;\t\t/* We silently convert it to zero.  */\n \n       JAVA_LEX_CHAR_LIT (char_lit);\n-      SET_LVAL_NODE_TYPE (build_int_2 (char_lit, 0), char_type_node);\n+#ifndef JC1_LITE\n+      {\n+\ttree value = build_int_2 (char_lit, 0);\n+\tTREE_TYPE (value) = char_type_node;\n+\tSET_LVAL_NODE (value);\n+      }\n+#endif\n       return CHAR_LIT_TK;\n     }\n "}, {"sha": "bae504782c43d8332ac9518a6a96390c4beedebf", "filename": "gcc/java/lex.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca7a3bd7d5c371af20775d28ec20bf57115b20e5/gcc%2Fjava%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca7a3bd7d5c371af20775d28ec20bf57115b20e5/gcc%2Fjava%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.h?ref=ca7a3bd7d5c371af20775d28ec20bf57115b20e5", "patch": "@@ -188,7 +188,6 @@ extern void java_destroy_lexer (java_lexer *);\n #define BUILD_OPERATOR(TOKEN)\treturn TOKEN\n #define BUILD_OPERATOR2(TOKEN)\treturn ASSIGN_ANY_TK\n #define SET_LVAL_NODE(NODE)\n-#define SET_LVAL_NODE_TYPE(NODE, TYPE)\n #define BUILD_ID_WFL(EXP) (EXP)\n #define JAVA_FLOAT_RANGE_ERROR(S) {}\n #define JAVA_INTEGRAL_RANGE_ERROR(S) do { } while (0)\n@@ -225,11 +224,6 @@ extern void java_destroy_lexer (java_lexer *);\n   }\n /* Set java_lval->node and TREE_TYPE(java_lval->node) in macros */\n #define SET_LVAL_NODE(NODE) java_lval->node = (NODE)\n-#define SET_LVAL_NODE_TYPE(NODE,TYPE)\t\t\\\n-  {\t\t\t\t\t\t\\\n-    java_lval->node = (NODE);\t\t\t\\\n-    TREE_TYPE (java_lval->node) = (TYPE);\t\\\n-  }\n /* Wrap identifier around a wfl */\n #define BUILD_ID_WFL(EXP) build_wfl_node ((EXP))\n /* Special ways to report error on numeric literals  */"}, {"sha": "ef73afdbe6ca808f98f8d195720bdaeb61205ae5", "filename": "gcc/tree.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca7a3bd7d5c371af20775d28ec20bf57115b20e5/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca7a3bd7d5c371af20775d28ec20bf57115b20e5/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=ca7a3bd7d5c371af20775d28ec20bf57115b20e5", "patch": "@@ -1130,7 +1130,7 @@ size_in_bytes (tree type)\n     }\n \n   if (TREE_CODE (t) == INTEGER_CST)\n-    force_fit_type (t, 0);\n+    t = force_fit_type (t, 0, false, false);\n \n   return t;\n }\n@@ -4563,7 +4563,8 @@ int_fits_type_p (tree c, tree type)\n     {\n       c = copy_node (c);\n       TREE_TYPE (c) = type;\n-      return !force_fit_type (c, 0);\n+      c = force_fit_type (c, -1, false, false);\n+      return !TREE_OVERFLOW (c);\n     }\n }\n "}, {"sha": "49fcd0debb231e77522d9356192177b1df74d2e1", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca7a3bd7d5c371af20775d28ec20bf57115b20e5/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca7a3bd7d5c371af20775d28ec20bf57115b20e5/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=ca7a3bd7d5c371af20775d28ec20bf57115b20e5", "patch": "@@ -3384,7 +3384,8 @@ extern tree fold_single_bit_test (enum tree_code, tree, tree, tree);\n extern tree fold_ignored_result (tree);\n extern tree fold_abs_const (tree, tree);\n \n-extern int force_fit_type (tree, int);\n+extern tree force_fit_type (tree, int, bool, bool);\n+\n extern int add_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t       unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t       unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);"}]}