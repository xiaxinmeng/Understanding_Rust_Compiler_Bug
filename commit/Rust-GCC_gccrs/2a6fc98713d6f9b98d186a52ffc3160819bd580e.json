{"sha": "2a6fc98713d6f9b98d186a52ffc3160819bd580e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmE2ZmM5ODcxM2Q2ZjliOThkMTg2YTUyZmZjMzE2MDgxOWJkNTgwZQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-11-15T06:30:31Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-11-15T06:30:31Z"}, "message": "explow.c (anti_adjust_stack_and_probe_stack_clash): Avoid probing the red zone for stack_clash_protection_final_dynamic_probe...\n\n\t* explow.c (anti_adjust_stack_and_probe_stack_clash): Avoid probing\n\tthe red zone for stack_clash_protection_final_dynamic_probe targets\n\twhen the total dynamic stack size is zero bytes.\n\nFrom-SVN: r254753", "tree": {"sha": "49e95bd9149f24000e549eef8d8e9514c2fc12f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49e95bd9149f24000e549eef8d8e9514c2fc12f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a6fc98713d6f9b98d186a52ffc3160819bd580e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a6fc98713d6f9b98d186a52ffc3160819bd580e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a6fc98713d6f9b98d186a52ffc3160819bd580e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a6fc98713d6f9b98d186a52ffc3160819bd580e/comments", "author": null, "committer": null, "parents": [{"sha": "611a7c7e3799549b0de94c75ca810ba0d450b804", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/611a7c7e3799549b0de94c75ca810ba0d450b804", "html_url": "https://github.com/Rust-GCC/gccrs/commit/611a7c7e3799549b0de94c75ca810ba0d450b804"}], "stats": {"total": 18, "additions": 16, "deletions": 2}, "files": [{"sha": "08642663d953ea622a7e13b8304ec806650c6475", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a6fc98713d6f9b98d186a52ffc3160819bd580e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a6fc98713d6f9b98d186a52ffc3160819bd580e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a6fc98713d6f9b98d186a52ffc3160819bd580e", "patch": "@@ -1,5 +1,9 @@\n 2017-11-14  Jeff Law  <law@redhat.com>\n \n+\t* explow.c (anti_adjust_stack_and_probe_stack_clash): Avoid probing\n+\tthe red zone for stack_clash_protection_final_dynamic_probe targets\n+\twhen the total dynamic stack size is zero bytes.\n+\n \t* tree-ssa-threadupdate.c (thread_through_all_blocks): Thread\n \tblocks is post order.\n "}, {"sha": "96334b2b448835791ed95352c6e4af32edd0670c", "filename": "gcc/explow.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a6fc98713d6f9b98d186a52ffc3160819bd580e/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a6fc98713d6f9b98d186a52ffc3160819bd580e/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=2a6fc98713d6f9b98d186a52ffc3160819bd580e", "patch": "@@ -1999,6 +1999,13 @@ anti_adjust_stack_and_probe_stack_clash (rtx size)\n   if (size != CONST0_RTX (Pmode)\n       && targetm.stack_clash_protection_final_dynamic_probe (residual))\n     {\n+      /* SIZE could be zero at runtime and in that case *sp could hold\n+\t live data.  Furthermore, we don't want to probe into the red\n+\t zone.\n+\n+\t Go ahead and just guard a probe at *sp on SIZE != 0 at runtime\n+\t if SIZE is not a compile time constant.  */\n+\n       /* Ideally we would just probe at *sp.  However, if SIZE is not\n \t a compile-time constant, but is zero at runtime, then *sp\n \t might hold live data.  So probe at *sp if we know that\n@@ -2011,9 +2018,12 @@ anti_adjust_stack_and_probe_stack_clash (rtx size)\n \t}\n       else\n \t{\n-\t  emit_stack_probe (plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t   -GET_MODE_SIZE (word_mode)));\n+\t  rtx label = gen_label_rtx ();\n+\t  emit_cmp_and_jump_insns (size, CONST0_RTX (GET_MODE (size)),\n+\t\t\t\t   EQ, NULL_RTX, Pmode, 1, label);\n+\t  emit_stack_probe (stack_pointer_rtx);\n \t  emit_insn (gen_blockage ());\n+\t  emit_label (label);\n \t}\n     }\n }"}]}