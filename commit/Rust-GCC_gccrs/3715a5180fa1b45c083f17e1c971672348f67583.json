{"sha": "3715a5180fa1b45c083f17e1c971672348f67583", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzcxNWE1MTgwZmExYjQ1YzA4M2YxN2UxYzk3MTY3MjM0OGY2NzU4Mw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-06T23:13:18Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-06T23:13:18Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r925", "tree": {"sha": "7f451f836bef1fce73f9965f0bd22c0d87af70f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f451f836bef1fce73f9965f0bd22c0d87af70f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3715a5180fa1b45c083f17e1c971672348f67583", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3715a5180fa1b45c083f17e1c971672348f67583", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3715a5180fa1b45c083f17e1c971672348f67583", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3715a5180fa1b45c083f17e1c971672348f67583/comments", "author": null, "committer": null, "parents": [{"sha": "dad0145a312f30add10804c200b8d662c2eefe13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dad0145a312f30add10804c200b8d662c2eefe13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dad0145a312f30add10804c200b8d662c2eefe13"}], "stats": {"total": 288, "additions": 232, "deletions": 56}, "files": [{"sha": "b7e1be9141d51be1ea324858218da5634ff9187d", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 232, "deletions": 56, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3715a5180fa1b45c083f17e1c971672348f67583/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3715a5180fa1b45c083f17e1c971672348f67583/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=3715a5180fa1b45c083f17e1c971672348f67583", "patch": "@@ -81,7 +81,16 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    for constant attributes and generate a set of functions for that given\n    combination.  An initialization function would be written that evaluates\n    the attributes and installs the corresponding set of routines and\n-   definitions (each would be accessed through a pointer).  */\n+   definitions (each would be accessed through a pointer).\n+\n+   We use the flags in an RTX as follows:\n+   `unchanging' (RTX_UNCHANGING_P): This rtx is fully simplified\n+      independent of the insn code.\n+   `in_struct' (MEM_IN_STRUCT_P): This rtx is fully simplified\n+      for the insn code currently being processed (see optimize_attrs).\n+   `integrated' (RTX_INTEGRATED_P): This rtx is permanent and unique\n+      (see attr_rtx).  */\n+\n \n #include <stdio.h>\n #include \"gvarargs.h\"\n@@ -202,7 +211,9 @@ struct function_unit\n \n /* Listheads of above structures.  */\n \n-static struct attr_desc *attrs;\n+/* This one is indexed by the first character of the attribute name.  */\n+#define MAX_ATTRS_INDEX 256\n+static struct attr_desc *attrs[MAX_ATTRS_INDEX];\n static struct insn_def *defs;\n static struct delay_desc *delays;\n static struct function_unit *units;\n@@ -223,11 +234,21 @@ static int num_units;\n \n enum operator {PLUS_OP, MINUS_OP, OR_OP, MAX_OP};\n \n+/* Stores, for each insn code, the number of constraint alternatives.  */\n+\n+static int *insn_n_alternatives;\n+\n /* Stores, for each insn code, a bitmap that has bits on for each possible\n    alternative.  */\n \n static int *insn_alternatives;\n \n+/* If nonzero, assume that the `alternative' attr has this value.\n+   This is the hashed, unique string for the numeral\n+   whose value is chosen alternative.  */\n+\n+static char *current_alternative_string;\n+\n /* Used to simplify expressions.  */\n \n static rtx true_rtx, false_rtx;\n@@ -239,9 +260,18 @@ static char *alternative_name;\n /* Simplify an expression.  Only call the routine if there is something to\n    simplify.  */\n #define SIMPLIFY_TEST_EXP(EXP,INSN_CODE,INSN_INDEX)\t\\\n-  (RTX_UNCHANGING_P (EXP) || MEM_IN_STRUCT_P (EXP) ? (EXP)\t\t\\\n+  (RTX_UNCHANGING_P (EXP) || MEM_IN_STRUCT_P (EXP) ? (EXP)\t\\\n    : simplify_test_exp (EXP, INSN_CODE, INSN_INDEX))\n   \n+/* Simplify (eq_attr (\"alternative\") ...)\n+   when we are working with a particular alternative.  */\n+#define SIMPLIFY_ALTERNATIVE(EXP)\t\t\t\t\\\n+  if (current_alternative_string\t\t\t\t\\\n+      && GET_CODE ((EXP)) == EQ_ATTR\t\t\t\t\\\n+      && XSTR ((EXP), 0) == alternative_name)\t\t\t\\\n+    (EXP) = (XSTR ((EXP), 1) == current_alternative_string\t\\\n+\t    ? true_rtx : false_rtx);\n+\n /* These are referenced by rtlanal.c and hence need to be defined somewhere.\n    They won't actually be used.  */\n \n@@ -271,6 +301,7 @@ static rtx zero_fn ();\n static rtx one_fn ();\n static rtx max_fn ();\n static rtx simplify_cond ();\n+static rtx simplify_by_alternatives ();\n static void remove_insn_ent ();\n static void insert_insn_ent ();\n static rtx insert_right_side ();\n@@ -1157,7 +1188,7 @@ convert_const_symbol_ref (exp, attr)\n       value = attr_rtx (SYMBOL_REF, string);\n       RTX_UNCHANGING_P (value) = 1;\n       \n-      XVECEXP (condexp, 0, 2 * i) = attr_eq (exp, value);\n+      XVECEXP (condexp, 0, 2 * i) = attr_rtx (EQ, exp, value);\n \n       XVECEXP (condexp, 0, 2 * i + 1) = av->value;\n     }\n@@ -1197,6 +1228,10 @@ make_canonical (attr, exp)\n     case SYMBOL_REF:\n       if (!attr->is_const || RTX_UNCHANGING_P (exp))\n \tbreak;\n+      /* The SYMBOL_REF is constant for a given run, so mark it as unchanging.\n+\t This makes the COND something that won't be considered an arbitrary\n+\t expression by walk_attr_value.  */\n+      RTX_UNCHANGING_P (exp) = 1;\n       exp = convert_const_symbol_ref (exp, attr);\n       RTX_UNCHANGING_P (exp) = 1;\n       exp = check_attr_value (exp, attr);\n@@ -2169,11 +2204,16 @@ evaluate_eq_attr (exp, value, insn_code, insn_index)\n       orexp = false_rtx;\n       andexp = true_rtx;\n \n+      if (current_alternative_string)\n+\tclear_struct_flag (value);\n+\n       for (i = 0; i < XVECLEN (value, 0); i += 2)\n \t{\n \t  rtx this = SIMPLIFY_TEST_EXP (XVECEXP (value, 0, i),\n \t\t\t\t\tinsn_code, insn_index);\n \n+\t  SIMPLIFY_ALTERNATIVE (this);\n+\n \t  right = insert_right_side (AND, andexp, this,\n \t\t\t\t     insn_code, insn_index);\n \t  right = insert_right_side (AND, right,\n@@ -2207,7 +2247,7 @@ evaluate_eq_attr (exp, value, insn_code, insn_index)\n \n   if (address_used)\n     {\n-      if (! RTX_UNCHANGING_P (exp))\n+      if (! RTX_UNCHANGING_P (exp) && current_alternative_string)\n \treturn copy_rtx_unchanging (exp);\n       return exp;\n     }\n@@ -2456,7 +2496,19 @@ simplify_test_exp (exp, insn_code, insn_index)\n     {\n     case AND:\n       left = SIMPLIFY_TEST_EXP (XEXP (exp, 0), insn_code, insn_index);\n+      SIMPLIFY_ALTERNATIVE (left);\n+      if (left == false_rtx)\n+\t{\n+\t  obstack_free (rtl_obstack, spacer);\n+\t  return false_rtx;\n+\t}\n       right = SIMPLIFY_TEST_EXP (XEXP (exp, 1), insn_code, insn_index);\n+      SIMPLIFY_ALTERNATIVE (right);\n+      if (left == false_rtx)\n+\t{\n+\t  obstack_free (rtl_obstack, spacer);\n+\t  return false_rtx;\n+\t}\n \n       /* If either side is an IOR and we have (eq_attr \"alternative\" ..\")\n \t present on both sides, apply the distributive law since this will\n@@ -2542,7 +2594,19 @@ simplify_test_exp (exp, insn_code, insn_index)\n \n     case IOR:\n       left = SIMPLIFY_TEST_EXP (XEXP (exp, 0), insn_code, insn_index);\n+      SIMPLIFY_ALTERNATIVE (left);\n+      if (left == true_rtx)\n+\t{\n+\t  obstack_free (rtl_obstack, spacer);\n+\t  return true_rtx;\n+\t}\n       right = SIMPLIFY_TEST_EXP (XEXP (exp, 1), insn_code, insn_index);\n+      SIMPLIFY_ALTERNATIVE (right);\n+      if (right == true_rtx)\n+\t{\n+\t  obstack_free (rtl_obstack, spacer);\n+\t  return true_rtx;\n+\t}\n \n       right = simplify_or_tree (right, &left, insn_code, insn_index);\n       if (left == XEXP (exp, 0) && right == XEXP (exp, 1))\n@@ -2623,9 +2687,15 @@ simplify_test_exp (exp, insn_code, insn_index)\n \n     case NOT:\n       if (GET_CODE (XEXP (exp, 0)) == NOT)\n-\treturn SIMPLIFY_TEST_EXP (XEXP (XEXP (exp, 0), 0),\n-\t\t\t\t  insn_code, insn_index);\n+\t{\n+\t  left = SIMPLIFY_TEST_EXP (XEXP (XEXP (exp, 0), 0),\n+\t\t\t\t    insn_code, insn_index);\n+\t  SIMPLIFY_ALTERNATIVE (left);\n+\t  return left;\n+\t}\n+\n       left = SIMPLIFY_TEST_EXP (XEXP (exp, 0), insn_code, insn_index);\n+      SIMPLIFY_ALTERNATIVE (left);\n       if (GET_CODE (left) == NOT)\n \treturn XEXP (left, 0);\n \n@@ -2664,6 +2734,10 @@ simplify_test_exp (exp, insn_code, insn_index)\n       break;\n \n     case EQ_ATTR:\n+      if (current_alternative_string && XSTR (exp, 0) == alternative_name)\n+\treturn (XSTR (exp, 1) == current_alternative_string\n+\t\t? true_rtx : false_rtx);\n+\t\n       /* Look at the value for this insn code in the specified attribute.\n \t We normally can replace this comparison with the condition that\n \t would give this insn the values being tested for.   */\n@@ -2678,10 +2752,9 @@ simplify_test_exp (exp, insn_code, insn_index)\n   /* We have already simplified this expression.  Simplifying it again\n      won't buy anything unless we weren't given a valid insn code\n      to process (i.e., we are canonicalizing something.).  */\n-  if (insn_code != -2 && ! RTX_UNCHANGING_P (newexp))\n-    {\n-      return copy_rtx_unchanging (newexp);\n-    }\n+  if (insn_code != -2 && current_alternative_string\n+      && ! RTX_UNCHANGING_P (newexp))\n+    return copy_rtx_unchanging (newexp);\n \n   return newexp;\n }\n@@ -2721,31 +2794,33 @@ optimize_attrs ()\n   /* Offset the table address so we can index by -2 or -1.  */\n   insn_code_values += 2;\n \n-  for (attr = attrs; attr; attr = attr->next)\n-    for (av = attr->first_value; av; av = av->next)\n-      for (ie = av->first_insn; ie; ie = ie->next)\n-\t{\n-\t  iv = ((struct attr_value_list *)\n-\t\talloca (sizeof (struct attr_value_list)));\n-\t  iv->attr = attr;\n-\t  iv->av = av;\n-\t  iv->ie = ie;\n-\t  iv->next = insn_code_values[ie->insn_code];\n-\t  insn_code_values[ie->insn_code] = iv;\n-\t}\n+  for (i = 0; i < MAX_ATTRS_INDEX; i++)\n+    for (attr = attrs[i]; attr; attr = attr->next)\n+      for (av = attr->first_value; av; av = av->next)\n+\tfor (ie = av->first_insn; ie; ie = ie->next)\n+\t  {\n+\t    iv = ((struct attr_value_list *)\n+\t\t  alloca (sizeof (struct attr_value_list)));\n+\t    iv->attr = attr;\n+\t    iv->av = av;\n+\t    iv->ie = ie;\n+\t    iv->next = insn_code_values[ie->insn_code];\n+\t    insn_code_values[ie->insn_code] = iv;\n+\t  }\n \n-  /* Loop until nothing changes for one iteration.  */\n-  while (something_changed)\n+  /* Process one insn code at a time.  */\n+  for (i = -2; i < insn_code_number; i++)\n     {\n-      something_changed = 0;\n-      /* Process one insn code at a time.  */\n-      for (i = -2; i < insn_code_number; i++)\n+      /* Clear the MEM_IN_STRUCT_P flag everywhere relevant.\n+\t We use it to mean \"already simplified for this insn\".  */\n+      for (iv = insn_code_values[i]; iv; iv = iv->next)\n+\tclear_struct_flag (iv->av->value);\n+\n+      /* Loop until nothing changes for one iteration.  */\n+      something_changed = 1;\n+      while (something_changed)\n \t{\n-\t  /* Clear the MEM_IN_STRUCT_P flag everywhere relevant.\n-\t     We use it to mean \"already simplified for this insn\".  */\n-\t  for (iv = insn_code_values[i]; iv; iv = iv->next)\n-\t    clear_struct_flag (iv->av->value);\n-\t\t  \n+\t  something_changed = 0;\n \t  for (iv = insn_code_values[i]; iv; iv = iv->next)\n \t    {\n \t      struct obstack *old = rtl_obstack;\n@@ -2758,8 +2833,16 @@ optimize_attrs ()\n \t\tcontinue;\n \n \t      rtl_obstack = temp_obstack;\n-\t      newexp = simplify_cond (av->value, ie->insn_code,\n-\t\t\t\t      ie->insn_index);\n+#if 0 /* This was intended as a speed up, but it was slower.  */\n+\t      if (insn_n_alternatives[ie->insn_code] > 6\n+\t\t  && count_sub_rtxs (av->value, 200) >= 200)\n+\t\tnewexp = simplify_by_alternatives (av->value, ie->insn_code,\n+\t\t\t\t\t\t   ie->insn_index);\n+\t      else\n+#endif\n+\t\tnewexp = simplify_cond (av->value, ie->insn_code,\n+\t\t\t\t\tie->insn_index);\n+\n \t      rtl_obstack = old;\n \t      if (newexp != av->value)\n \t\t{\n@@ -2776,6 +2859,38 @@ optimize_attrs ()\n     }\n }\n \n+static rtx\n+simplify_by_alternatives (exp, insn_code, insn_index)\n+     rtx exp;\n+     int insn_code, insn_index;\n+{\n+  int i;\n+  int len = insn_n_alternatives[insn_code];\n+  rtx newexp = rtx_alloc (COND);\n+  rtx ultimate;\n+\n+\n+  XVEC (newexp, 0) = rtvec_alloc (len * 2);\n+\n+  /* It will not matter what value we use as the default value\n+     of the new COND, since that default will never be used.\n+     Choose something of the right type.  */\n+  for (ultimate = exp; GET_CODE (ultimate) == COND;)\n+    ultimate = XEXP (ultimate, 1);\n+  XEXP (newexp, 1) = ultimate;\n+\n+  for (i = 0; i < insn_n_alternatives[insn_code]; i++)\n+    {\n+      current_alternative_string = attr_numeral (i);\n+      XVECEXP (newexp, 0, i * 2) = make_alternative_compare (1 << i);\n+      XVECEXP (newexp, 0, i * 2 + 1)\n+\t= simplify_cond (exp, insn_code, insn_index);\n+    }\n+\n+  current_alternative_string = 0;\n+  return simplify_cond (newexp, insn_code, insn_index);\n+}\n+\f\n /* Clear the MEM_IN_STRUCT_P flag in EXP and its subexpressions.  */\n \n clear_struct_flag (x)\n@@ -2816,7 +2931,6 @@ clear_struct_flag (x)\n \t{\n \tcase 'V':\n \tcase 'E':\n-\t  /* And the corresponding elements must match.  */\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    clear_struct_flag (XVECEXP (x, i, j));\n \t  break;\n@@ -2827,6 +2941,61 @@ clear_struct_flag (x)\n \t}\n     }\n }\n+\n+/* Return the number of RTX objects making up the expression X.\n+   But if we count more more than MAX objects, stop counting.  */\n+\n+count_sub_rtxs (x, max)\n+     rtx x;\n+     int max;\n+{\n+  register int i;\n+  register int j;\n+  register enum rtx_code code;\n+  register char *fmt;\n+  int total = 0;\n+\n+  code = GET_CODE (x);\n+\n+  switch (code)\n+    {\n+    case REG:\n+    case QUEUED:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case SYMBOL_REF:\n+    case CODE_LABEL:\n+    case PC:\n+    case CC0:\n+    case EQ_ATTR:\n+      return 1;\n+    }\n+\n+  /* Compare the elements.  If any pair of corresponding elements\n+     fail to match, return 0 for the whole things.  */\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (total >= max)\n+\treturn total;\n+\n+      switch (fmt[i])\n+\t{\n+\tcase 'V':\n+\tcase 'E':\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    total += count_sub_rtxs (XVECEXP (x, i, j), max);\n+\t  break;\n+\n+\tcase 'e':\n+\t  total += count_sub_rtxs (XEXP (x, i), max);\n+\t  break;\n+\t}\n+    }\n+  return total;\n+\n+}\n \f\n /* Create table entries for DEFINE_ATTR.  */\n \n@@ -4059,34 +4228,32 @@ find_attr (name, create)\n      int create;\n {\n   struct attr_desc *attr;\n-  char *new_name;\n+  int index;\n \n   /* Before we resort to using `strcmp', see if the string address matches\n      anywhere.  In most cases, it should have been canonicalized to do so.  */\n   if (name == alternative_name)\n     return NULL;\n \n-  for (attr = attrs; attr; attr = attr->next)\n+  index = name[0] & (MAX_ATTRS_INDEX - 1);\n+  for (attr = attrs[index]; attr; attr = attr->next)\n     if (name == attr->name)\n       return attr;\n \n   /* Otherwise, do it the slow way.  */\n-  for (attr = attrs; attr; attr = attr->next)\n+  for (attr = attrs[index]; attr; attr = attr->next)\n     if (name[0] == attr->name[0] && ! strcmp (name, attr->name))\n       return attr;\n \n   if (! create)\n     return NULL;\n \n-  new_name = (char *) xmalloc (strlen (name) + 1);\n-  strcpy (new_name, name);\n-\n   attr = (struct attr_desc *) xmalloc (sizeof (struct attr_desc));\n-  attr->name = new_name;\n+  attr->name = attr_string (name, strlen (name));\n   attr->first_value = attr->default_val = NULL;\n   attr->is_numeric = attr->is_const = attr->is_special = 0;\n-  attr->next = attrs;\n-  attrs = attr;\n+  attr->next = attrs[index];\n+  attrs[index] = attr;\n \n   return attr;\n }\n@@ -4266,6 +4433,7 @@ main (argc, argv)\n   struct attr_value *av;\n   struct insn_def *id;\n   rtx tem;\n+  int i;\n \n   obstack_init (rtl_obstack);\n   obstack_init (hash_obstack);\n@@ -4369,16 +4537,23 @@ from the machine description file `md'.  */\\n\\n\");\n     if (id->insn_code >= 0)\n       insn_alternatives[id->insn_code] = (1 << id->num_alternatives) - 1;\n \n+  /* Make `insn_n_alternatives'.  */\n+  insn_n_alternatives = (int *) xmalloc (insn_code_number * sizeof (int));\n+  for (id = defs; id; id = id->next)\n+    if (id->insn_code >= 0)\n+      insn_n_alternatives[id->insn_code] = id->num_alternatives;\n+\n   /* Prepare to write out attribute subroutines by checking everything stored\n      away and building the attribute cases.  */\n \n   check_defs ();\n-  for (attr = attrs; attr; attr = attr->next)\n-    {\n-      attr->default_val->value\n-\t= check_attr_value (attr->default_val->value, attr);\n-      fill_attr (attr);\n-    }\n+  for (i = 0; i < MAX_ATTRS_INDEX; i++)\n+    for (attr = attrs[i]; attr; attr = attr->next)\n+      {\n+\tattr->default_val->value\n+\t  = check_attr_value (attr->default_val->value, attr);\n+\tfill_attr (attr);\n+      }\n \n   /* Construct extra attributes for `length'.  */\n   make_length_attrs ();\n@@ -4390,11 +4565,12 @@ from the machine description file `md'.  */\\n\\n\");\n      special routines (specifically before write_function_unit_info), so\n      that they get defined before they are used.  */\n \n-  for (attr = attrs; attr; attr = attr->next)\n-    {\n-      if (! attr->is_special)\n-\twrite_attr_get (attr);\n-    }\n+  for (i = 0; i < MAX_ATTRS_INDEX; i++)\n+    for (attr = attrs[i]; attr; attr = attr->next)\n+      {\n+\tif (! attr->is_special)\n+\t  write_attr_get (attr);\n+      }\n \n   /* Write out delay eligibility information, if DEFINE_DELAY present.\n      (The function to compute the number of delay slots will be written"}]}