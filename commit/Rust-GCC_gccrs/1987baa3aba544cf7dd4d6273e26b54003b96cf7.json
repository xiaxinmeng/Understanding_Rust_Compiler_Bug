{"sha": "1987baa3aba544cf7dd4d6273e26b54003b96cf7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTk4N2JhYTNhYmE1NDRjZjdkZDRkNjI3M2UyNmI1NDAwM2I5NmNmNw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "ook@ucw.cz", "date": "2010-08-30T19:50:05Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2010-08-30T19:50:05Z"}, "message": "re PR tree-optimization/45427 (Number of iteration analysis bogus)\n\n\tPR tree-optimization/45427\n\t* tree-ssa-loop-niter.c (number_of_iterations_ne_max): Rewritten.\n\tHandle the case that the exit is never taken correctly.\n\t(number_of_iterations_ne): Pass exit_must_be_taken to\n\tnumber_of_iterations_ne_max.\n\n\t* gcc.dg/tree-ssa/pr45427.c: New test.\n\nFrom-SVN: r163659", "tree": {"sha": "18b2f021f973e4257567646741b248f6ff55d0fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18b2f021f973e4257567646741b248f6ff55d0fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1987baa3aba544cf7dd4d6273e26b54003b96cf7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1987baa3aba544cf7dd4d6273e26b54003b96cf7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1987baa3aba544cf7dd4d6273e26b54003b96cf7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1987baa3aba544cf7dd4d6273e26b54003b96cf7/comments", "author": {"login": "rakdver", "id": 20416833, "node_id": "MDQ6VXNlcjIwNDE2ODMz", "avatar_url": "https://avatars.githubusercontent.com/u/20416833?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rakdver", "html_url": "https://github.com/rakdver", "followers_url": "https://api.github.com/users/rakdver/followers", "following_url": "https://api.github.com/users/rakdver/following{/other_user}", "gists_url": "https://api.github.com/users/rakdver/gists{/gist_id}", "starred_url": "https://api.github.com/users/rakdver/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rakdver/subscriptions", "organizations_url": "https://api.github.com/users/rakdver/orgs", "repos_url": "https://api.github.com/users/rakdver/repos", "events_url": "https://api.github.com/users/rakdver/events{/privacy}", "received_events_url": "https://api.github.com/users/rakdver/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "037f9973716f8e3e9f8f33847bce345075f87141", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/037f9973716f8e3e9f8f33847bce345075f87141", "html_url": "https://github.com/Rust-GCC/gccrs/commit/037f9973716f8e3e9f8f33847bce345075f87141"}], "stats": {"total": 111, "additions": 93, "deletions": 18}, "files": [{"sha": "fe16d48fae50a21801487a4e0832dbe6b3442d9e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1987baa3aba544cf7dd4d6273e26b54003b96cf7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1987baa3aba544cf7dd4d6273e26b54003b96cf7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1987baa3aba544cf7dd4d6273e26b54003b96cf7", "patch": "@@ -1,3 +1,11 @@\n+2010-08-30  Zdenek Dvorak  <ook@ucw.cz>\n+\n+\tPR tree-optimization/45427\n+\t* tree-ssa-loop-niter.c (number_of_iterations_ne_max): Rewritten.\n+\tHandle the case that the exit is never taken correctly.\n+\t(number_of_iterations_ne): Pass exit_must_be_taken to\n+\tnumber_of_iterations_ne_max.\n+\n 2010-08-31  Catherine Moore  <clm@codesourcery.com>\n \n \t* config/mips/mips.h (BASE_DRIVER_SELF_SPECS):"}, {"sha": "fd8fecbd9e88e90066662307a869ece49682ad6b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1987baa3aba544cf7dd4d6273e26b54003b96cf7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1987baa3aba544cf7dd4d6273e26b54003b96cf7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1987baa3aba544cf7dd4d6273e26b54003b96cf7", "patch": "@@ -1,3 +1,8 @@\n+2010-08-30  Zdenek Dvorak  <ook@ucw.cz>\n+\n+\tPR tree-optimization/45427\n+\t* gcc.dg/tree-ssa/pr45427.c: New test.\n+\n 2010-08-30  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/45043"}, {"sha": "0952b5a04f86a415353d000a6a149008ba2b5a9c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr45427.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1987baa3aba544cf7dd4d6273e26b54003b96cf7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr45427.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1987baa3aba544cf7dd4d6273e26b54003b96cf7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr45427.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr45427.c?ref=1987baa3aba544cf7dd4d6273e26b54003b96cf7", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-cunrolli-details\" } */\n+\n+extern void abort (void);\n+int __attribute__((noinline,noclone))\n+foo (char *p)\n+{\n+  int h = 0;\n+  do\n+    {\n+      if (*p == '\\0')\n+        break;\n+      ++h;\n+      if (p == 0)\n+        abort ();\n+      ++p;\n+    }\n+  while (1);\n+  return h;\n+}\n+int main()\n+{\n+  if (foo(\"a\") != 1)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"bounded by 0\" 0 \"cunrolli\"} } */\n+/* { dg-final { cleanup-tree-dump \"cunrolli\" } } */"}, {"sha": "2118b973a63ef5bc06d334b28e108468a2f2c6bb", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 51, "deletions": 18, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1987baa3aba544cf7dd4d6273e26b54003b96cf7/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1987baa3aba544cf7dd4d6273e26b54003b96cf7/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=1987baa3aba544cf7dd4d6273e26b54003b96cf7", "patch": "@@ -536,37 +536,69 @@ inverse (tree x, tree mask)\n }\n \n /* Derives the upper bound BND on the number of executions of loop with exit\n-   condition S * i <> C, assuming that this exit is taken.  If\n-   NO_OVERFLOW is true, then the control variable of the loop does not\n-   overflow.  If NO_OVERFLOW is true or BNDS.below >= 0, then BNDS.up\n-   contains the upper bound on the value of C.  */\n+   condition S * i <> C.  If NO_OVERFLOW is true, then the control variable of\n+   the loop does not overflow.  EXIT_MUST_BE_TAKEN is true if we are guaranteed\n+   that the loop ends through this exit, i.e., the induction variable ever\n+   reaches the value of C.  \n+   \n+   The value C is equal to final - base, where final and base are the final and\n+   initial value of the actual induction variable in the analysed loop.  BNDS\n+   bounds the value of this difference when computed in signed type with\n+   unbounded range, while the computation of C is performed in an unsigned\n+   type with the range matching the range of the type of the induction variable.\n+   In particular, BNDS.up contains an upper bound on C in the following cases:\n+   -- if the iv must reach its final value without overflow, i.e., if\n+      NO_OVERFLOW && EXIT_MUST_BE_TAKEN is true, or\n+   -- if final >= base, which we know to hold when BNDS.below >= 0.  */\n \n static void\n number_of_iterations_ne_max (mpz_t bnd, bool no_overflow, tree c, tree s,\n-\t\t\t     bounds *bnds)\n+\t\t\t     bounds *bnds, bool exit_must_be_taken)\n {\n   double_int max;\n   mpz_t d;\n+  bool bnds_u_valid = ((no_overflow && exit_must_be_taken)\n+\t\t       || mpz_sgn (bnds->below) >= 0);\n \n-  /* If the control variable does not overflow, the number of iterations is\n-     at most c / s.  Otherwise it is at most the period of the control\n-     variable.  */\n-  if (!no_overflow && !multiple_of_p (TREE_TYPE (c), c, s))\n+  if (multiple_of_p (TREE_TYPE (c), c, s))\n+    {\n+      /* If C is an exact multiple of S, then its value will be reached before\n+\t the induction variable overflows (unless the loop is exited in some\n+\t other way before).  Note that the actual induction variable in the\n+\t loop (which ranges from base to final instead of from 0 to C) may\n+\t overflow, in which case BNDS.up will not be giving a correct upper\n+\t bound on C; thus, BNDS_U_VALID had to be computed in advance.  */\n+      no_overflow = true;\n+      exit_must_be_taken = true;\n+    }\n+\n+  /* If the induction variable can overflow, the number of iterations is at\n+     most the period of the control variable (or infinite, but in that case\n+     the whole # of iterations analysis will fail).  */\n+  if (!no_overflow)\n     {\n       max = double_int_mask (TYPE_PRECISION (TREE_TYPE (c))\n \t\t\t     - tree_low_cst (num_ending_zeros (s), 1));\n       mpz_set_double_int (bnd, max, true);\n       return;\n     }\n \n-  /* Determine the upper bound on C.  */\n-  if (no_overflow || mpz_sgn (bnds->below) >= 0)\n-    mpz_set (bnd, bnds->up);\n-  else if (TREE_CODE (c) == INTEGER_CST)\n-    mpz_set_double_int (bnd, tree_to_double_int (c), true);\n-  else\n-    mpz_set_double_int (bnd, double_int_mask (TYPE_PRECISION (TREE_TYPE (c))),\n-\t\t\ttrue);\n+  /* Now we know that the induction variable does not overflow, so the loop\n+     iterates at most (range of type / S) times.  */\n+  mpz_set_double_int (bnd, double_int_mask (TYPE_PRECISION (TREE_TYPE (c))),\n+\t\t      true);\n+\n+  /* If the induction variable is guaranteed to reach the value of C before\n+     overflow, ... */\n+  if (exit_must_be_taken)\n+    {\n+      /* ... then we can strenghten this to C / S, and possibly we can use\n+\t the upper bound on C given by BNDS.  */\n+      if (TREE_CODE (c) == INTEGER_CST)\n+\tmpz_set_double_int (bnd, tree_to_double_int (c), true);\n+      else if (bnds_u_valid)\n+\tmpz_set (bnd, bnds->up);\n+    }\n \n   mpz_init (d);\n   mpz_set_double_int (d, tree_to_double_int (s), true);\n@@ -618,7 +650,8 @@ number_of_iterations_ne (tree type, affine_iv *iv, tree final,\n     }\n \n   mpz_init (max);\n-  number_of_iterations_ne_max (max, iv->no_overflow, c, s, bnds);\n+  number_of_iterations_ne_max (max, iv->no_overflow, c, s, bnds,\n+\t\t\t       exit_must_be_taken);\n   niter->max = mpz_get_double_int (niter_type, max, false);\n   mpz_clear (max);\n "}]}