{"sha": "8b47039cde38d852471193033965e9d3e40e97bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI0NzAzOWNkZTM4ZDg1MjQ3MTE5MzAzMzk2NWU5ZDNlNDBlOTdiYw==", "commit": {"author": {"name": "Teresa Johnson", "email": "tejohnson@google.com", "date": "2013-05-02T13:20:47Z"}, "committer": {"name": "Teresa Johnson", "email": "tejohnson@gcc.gnu.org", "date": "2013-05-02T13:20:47Z"}, "message": "Follow-on patch to r197595 to complete the replacement of truncating divides in...\n\nFollow-on patch to r197595 to complete the replacement of truncating divides\nin profile scaling code with rounding divide equivalents using helper routines\nin basic-block.h. \n\nIn addition to bootstrap and profiledbootstrap builds and tests (with and\nwithout LTO), I built and tested performance of the SPEC cpu2006 benchmarks\nwith FDO on a Nehalem system. I didn't see any performance changes that\nlooked significant.\n\n2013-05-02  Teresa Johnson  <tejohnson@google.com>\n\n\t* loop-unswitch.c (unswitch_loop): Use helper routines with rounding\n        divides.\n\t* cfg.c (update_bb_profile_for_threading): Ditto.\n\t* tree-inline.c (copy_bb): Ditto.\n\t(copy_edges_for_bb): Ditto.\n\t(initialize_cfun): Ditto.\n\t(copy_cfg_body): Ditto.\n\t(expand_call_inline): Ditto.\n\t* ipa-inline-analysis.c (estimate_edge_size_and_time): Ditto.\n\t(estimate_node_size_and_time): Ditto.\n\t(inline_merge_summary): Ditto.\n\t* cgraphclones.c (cgraph_clone_edge): Ditto.\n\t(cgraph_clone_node): Ditto.\n\t* sched-rgn.c (compute_dom_prob_ps): Ditto.\n\t(compute_trg_info): Ditto.\n\nFrom-SVN: r198532", "tree": {"sha": "e9eaf4c390a4ad7d8e3e0600f9736eb3868af2dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9eaf4c390a4ad7d8e3e0600f9736eb3868af2dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b47039cde38d852471193033965e9d3e40e97bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b47039cde38d852471193033965e9d3e40e97bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b47039cde38d852471193033965e9d3e40e97bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b47039cde38d852471193033965e9d3e40e97bc/comments", "author": {"login": "teresajohnson", "id": 20446403, "node_id": "MDQ6VXNlcjIwNDQ2NDAz", "avatar_url": "https://avatars.githubusercontent.com/u/20446403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/teresajohnson", "html_url": "https://github.com/teresajohnson", "followers_url": "https://api.github.com/users/teresajohnson/followers", "following_url": "https://api.github.com/users/teresajohnson/following{/other_user}", "gists_url": "https://api.github.com/users/teresajohnson/gists{/gist_id}", "starred_url": "https://api.github.com/users/teresajohnson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/teresajohnson/subscriptions", "organizations_url": "https://api.github.com/users/teresajohnson/orgs", "repos_url": "https://api.github.com/users/teresajohnson/repos", "events_url": "https://api.github.com/users/teresajohnson/events{/privacy}", "received_events_url": "https://api.github.com/users/teresajohnson/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "da65928c1d160f7e9ba156c5f189bca40f0527d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da65928c1d160f7e9ba156c5f189bca40f0527d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da65928c1d160f7e9ba156c5f189bca40f0527d6"}], "stats": {"total": 78, "additions": 40, "deletions": 38}, "files": [{"sha": "023c6b924b4071b349407052c015d4435e873a09", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b47039cde38d852471193033965e9d3e40e97bc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b47039cde38d852471193033965e9d3e40e97bc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b47039cde38d852471193033965e9d3e40e97bc", "patch": "@@ -1,3 +1,21 @@\n+2013-05-02  Teresa Johnson  <tejohnson@google.com>\n+\n+\t* loop-unswitch.c (unswitch_loop): Use helper routines with rounding\n+\tdivides.\n+\t* cfg.c (update_bb_profile_for_threading): Ditto.\n+\t* tree-inline.c (copy_bb): Ditto.\n+\t(copy_edges_for_bb): Ditto.\n+\t(initialize_cfun): Ditto.\n+\t(copy_cfg_body): Ditto.\n+\t(expand_call_inline): Ditto.\n+\t* ipa-inline-analysis.c (estimate_edge_size_and_time): Ditto.\n+\t(estimate_node_size_and_time): Ditto.\n+\t(inline_merge_summary): Ditto.\n+\t* cgraphclones.c (cgraph_clone_edge): Ditto.\n+\t(cgraph_clone_node): Ditto.\n+\t* sched-rgn.c (compute_dom_prob_ps): Ditto.\n+\t(compute_trg_info): Ditto.\n+\n 2013-05-02  Ian Bolton  <ian.bolton@arm.com>\n \n \t* config/aarch64/aarch64.md (movsi_aarch64): Only allow to/from"}, {"sha": "9c6c939139c35ee49f13105ff22b5e3938861838", "filename": "gcc/cfg.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b47039cde38d852471193033965e9d3e40e97bc/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b47039cde38d852471193033965e9d3e40e97bc/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=8b47039cde38d852471193033965e9d3e40e97bc", "patch": "@@ -848,8 +848,7 @@ update_bb_profile_for_threading (basic_block bb, int edge_frequency,\n   /* Compute the probability of TAKEN_EDGE being reached via threaded edge.\n      Watch for overflows.  */\n   if (bb->frequency)\n-    /* Update to use GCOV_COMPUTE_SCALE.  */\n-    prob = edge_frequency * REG_BR_PROB_BASE / bb->frequency;\n+    prob = GCOV_COMPUTE_SCALE (edge_frequency, bb->frequency);\n   else\n     prob = 0;\n   if (prob > taken_edge->probability)"}, {"sha": "f015f18666ccdc191927736889292183c601d4d8", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b47039cde38d852471193033965e9d3e40e97bc/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b47039cde38d852471193033965e9d3e40e97bc/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=8b47039cde38d852471193033965e9d3e40e97bc", "patch": "@@ -102,8 +102,7 @@ cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n \t\t   int freq_scale, bool update_original)\n {\n   struct cgraph_edge *new_edge;\n-  /* Update this to use GCOV_COMPUTE_SCALE.  */\n-  gcov_type count = e->count * count_scale / REG_BR_PROB_BASE;\n+  gcov_type count = apply_probability (e->count, count_scale);\n   gcov_type freq;\n \n   /* We do not want to ignore loop nest after frequency drops to 0.  */\n@@ -205,8 +204,7 @@ cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n       if (new_node->count > n->count)\n         count_scale = REG_BR_PROB_BASE;\n       else\n-        /* Update to use GCOV_COMPUTE_SCALE.  */\n-        count_scale = new_node->count * REG_BR_PROB_BASE / n->count;\n+        count_scale = GCOV_COMPUTE_SCALE (new_node->count, n->count);\n     }\n   else\n     count_scale = 0;"}, {"sha": "8d66325237b542b77ace1e7790ae51a85b0a4a2b", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b47039cde38d852471193033965e9d3e40e97bc/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b47039cde38d852471193033965e9d3e40e97bc/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=8b47039cde38d852471193033965e9d3e40e97bc", "patch": "@@ -2790,8 +2790,7 @@ estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *time,\n       && hints && cgraph_maybe_hot_edge_p (e))\n     *hints |= INLINE_HINT_indirect_call;\n   *size += call_size * INLINE_SIZE_SCALE;\n-  /* Update to use apply_probability().  */\n-  *time += call_time * prob / REG_BR_PROB_BASE\n+  *time += apply_probability ((gcov_type) call_time, prob)\n     * e->frequency * (INLINE_TIME_SCALE / CGRAPH_FREQ_BASE);\n   if (*time > MAX_TIME * INLINE_TIME_SCALE)\n     *time = MAX_TIME * INLINE_TIME_SCALE;\n@@ -2901,8 +2900,7 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \t\t\t\t\t      inline_param_summary);\n \t    gcc_checking_assert (prob >= 0);\n \t    gcc_checking_assert (prob <= REG_BR_PROB_BASE);\n-            /* Update to use apply_probability().  */\n-\t    time += ((gcov_type) e->time * prob) / REG_BR_PROB_BASE;\n+\t    time += apply_probability ((gcov_type) e->time, prob);\n \t  }\n \tif (time > MAX_TIME * INLINE_TIME_SCALE)\n \t  time = MAX_TIME * INLINE_TIME_SCALE;\n@@ -3311,8 +3309,7 @@ inline_merge_summary (struct cgraph_edge *edge)\n \t  int prob = predicate_probability (callee_info->conds,\n \t\t\t\t\t    &e->predicate,\n \t\t\t\t\t    clause, es->param);\n-          /* Update to use apply_probability().  */\n-\t  add_time = ((gcov_type) add_time * prob) / REG_BR_PROB_BASE;\n+\t  add_time = apply_probability ((gcov_type) add_time, prob);\n \t  if (add_time > MAX_TIME * INLINE_TIME_SCALE)\n \t    add_time = MAX_TIME * INLINE_TIME_SCALE;\n \t  if (prob != REG_BR_PROB_BASE"}, {"sha": "213e74d515a3d25d928878fcb4d4f687597e6b1c", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b47039cde38d852471193033965e9d3e40e97bc/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b47039cde38d852471193033965e9d3e40e97bc/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=8b47039cde38d852471193033965e9d3e40e97bc", "patch": "@@ -436,12 +436,10 @@ unswitch_loop (struct loop *loop, basic_block unswitch_on, rtx cond, rtx cinsn)\n   emit_insn_after (seq, BB_END (switch_bb));\n   e = make_edge (switch_bb, true_edge->dest, 0);\n   e->probability = prob;\n-  /* Update to use apply_probability().  */\n-  e->count = latch_edge->count * prob / REG_BR_PROB_BASE;\n+  e->count = apply_probability (latch_edge->count, prob);\n   e = make_edge (switch_bb, FALLTHRU_EDGE (unswitch_on)->dest, EDGE_FALLTHRU);\n   e->probability = false_edge->probability;\n-  /* Update to use apply_probability().  */\n-  e->count = latch_edge->count * (false_edge->probability) / REG_BR_PROB_BASE;\n+  e->count = apply_probability (latch_edge->count, false_edge->probability);\n \n   if (irred_flag)\n     {"}, {"sha": "3f5b4ba178b0e9cf5f25e752d4976a013f81a4da", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b47039cde38d852471193033965e9d3e40e97bc/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b47039cde38d852471193033965e9d3e40e97bc/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=8b47039cde38d852471193033965e9d3e40e97bc", "patch": "@@ -1441,8 +1441,7 @@ compute_dom_prob_ps (int bb)\n       FOR_EACH_EDGE (out_edge, out_ei, in_edge->src->succs)\n \tbitmap_set_bit (pot_split[bb], EDGE_TO_BIT (out_edge));\n \n-      /* Update to use apply_probability().  */\n-      prob[bb] += ((prob[pred_bb] * in_edge->probability) / REG_BR_PROB_BASE);\n+      prob[bb] += combine_probabilities (prob[pred_bb], in_edge->probability);\n     }\n \n   bitmap_set_bit (dom[bb], bb);\n@@ -1515,8 +1514,7 @@ compute_trg_info (int trg)\n \t  int tf = prob[trg], cf = prob[i];\n \n \t  /* In CFGs with low probability edges TF can possibly be zero.  */\n-          /* Update to use GCOV_COMPUTE_SCALE.  */\n-\t  sp->src_prob = (tf ? ((cf * REG_BR_PROB_BASE) / tf) : 0);\n+\t  sp->src_prob = (tf ? GCOV_COMPUTE_SCALE (cf, tf) : 0);\n \t  sp->is_valid = (sp->src_prob >= min_spec_prob);\n \t}\n "}, {"sha": "a650f0dc7c1224427e67bf7229b26919393fda48", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b47039cde38d852471193033965e9d3e40e97bc/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b47039cde38d852471193033965e9d3e40e97bc/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=8b47039cde38d852471193033965e9d3e40e97bc", "patch": "@@ -1519,13 +1519,11 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n      basic_block_info automatically.  */\n   copy_basic_block = create_basic_block (NULL, (void *) 0,\n                                          (basic_block) prev->aux);\n-  /* Update to use apply_scale().  */\n-  copy_basic_block->count = bb->count * count_scale / REG_BR_PROB_BASE;\n+  copy_basic_block->count = apply_scale (bb->count, count_scale);\n \n   /* We are going to rebuild frequencies from scratch.  These values\n      have just small importance to drive canonicalize_loop_headers.  */\n-  /* Update to use EDGE_FREQUENCY.  */\n-  freq = ((gcov_type)bb->frequency * frequency_scale / REG_BR_PROB_BASE);\n+  freq = apply_scale ((gcov_type)bb->frequency, frequency_scale);\n \n   /* We recompute frequencies after inlining, so this is quite safe.  */\n   if (freq > BB_FREQ_MAX)\n@@ -1891,8 +1889,7 @@ copy_edges_for_bb (basic_block bb, gcov_type count_scale, basic_block ret_bb,\n \t    && old_edge->dest->aux != EXIT_BLOCK_PTR)\n \t  flags |= EDGE_FALLTHRU;\n \tnew_edge = make_edge (new_bb, (basic_block) old_edge->dest->aux, flags);\n-        /* Update to use apply_scale().  */\n-\tnew_edge->count = old_edge->count * count_scale / REG_BR_PROB_BASE;\n+\tnew_edge->count = apply_scale (old_edge->count, count_scale);\n \tnew_edge->probability = old_edge->probability;\n       }\n \n@@ -2066,10 +2063,10 @@ initialize_cfun (tree new_fndecl, tree callee_fndecl, gcov_type count)\n   struct function *src_cfun = DECL_STRUCT_FUNCTION (callee_fndecl);\n   gcov_type count_scale;\n \n-  /* Update to use GCOV_COMPUTE_SCALE.  */\n   if (ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count)\n-    count_scale = (REG_BR_PROB_BASE * count\n-\t\t   / ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count);\n+    count_scale\n+        = GCOV_COMPUTE_SCALE (count,\n+                              ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count);\n   else\n     count_scale = REG_BR_PROB_BASE;\n \n@@ -2253,10 +2250,10 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n   int incoming_frequency = 0;\n   gcov_type incoming_count = 0;\n \n-  /* Update to use GCOV_COMPUTE_SCALE.  */\n   if (ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count)\n-    count_scale = (REG_BR_PROB_BASE * count\n-\t\t   / ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count);\n+    count_scale\n+        = GCOV_COMPUTE_SCALE (count,\n+                              ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count);\n   else\n     count_scale = REG_BR_PROB_BASE;\n \n@@ -2278,11 +2275,9 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n \t    incoming_frequency += EDGE_FREQUENCY (e);\n \t    incoming_count += e->count;\n \t  }\n-      /* Update to use apply_scale().  */\n-      incoming_count = incoming_count * count_scale / REG_BR_PROB_BASE;\n-      /* Update to use EDGE_FREQUENCY.  */\n+      incoming_count = apply_scale (incoming_count, count_scale);\n       incoming_frequency\n-\t= incoming_frequency * frequency_scale / REG_BR_PROB_BASE;\n+\t= apply_scale ((gcov_type)incoming_frequency, frequency_scale);\n       ENTRY_BLOCK_PTR->count = incoming_count;\n       ENTRY_BLOCK_PTR->frequency = incoming_frequency;\n     }\n@@ -4114,8 +4109,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n      a self-referential call; if we're calling ourselves, we need to\n      duplicate our body before altering anything.  */\n   copy_body (id, bb->count,\n-             /* Update to use GCOV_COMPUTE_SCALE.  */\n-  \t     cg_edge->frequency * REG_BR_PROB_BASE / CGRAPH_FREQ_BASE,\n+  \t     GCOV_COMPUTE_SCALE (cg_edge->frequency, CGRAPH_FREQ_BASE),\n \t     bb, return_block, NULL, NULL);\n \n   /* Reset the escaped solution.  */"}]}