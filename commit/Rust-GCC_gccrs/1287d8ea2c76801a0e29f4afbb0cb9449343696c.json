{"sha": "1287d8ea2c76801a0e29f4afbb0cb9449343696c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTI4N2Q4ZWEyYzc2ODAxYTBlMjlmNGFmYmIwY2I5NDQ5MzQzNjk2Yw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2011-10-10T11:42:38Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-10-10T11:42:38Z"}, "message": "modulo-sched.c (ps_insn): Adjust comment.\n\ngcc/\n\t* modulo-sched.c (ps_insn): Adjust comment.\n\t(ps_reg_move_info): New structure.\n\t(partial_schedule): Add reg_moves field.\n\t(SCHED_PARAMS): Use node_sched_param_vec instead of node_sched_params.\n\t(node_sched_params): Turn first_reg_move into an identifier.\n\t(ps_reg_move): New function.\n\t(ps_rtl_insn): Cope with register moves.\n\t(ps_first_note): Adjust comment and assert that the instruction\n\tisn't a register move.\n\t(node_sched_params): Replace with...\n\t(node_sched_param_vec): ...this vector.\n\t(set_node_sched_params): Adjust accordingly.\n\t(print_node_sched_params): Take a partial schedule instead of a ddg.\n\tUse ps_rtl_insn and ps_reg_move.\n\t(generate_reg_moves): Rename to...\n\t(schedule_reg_moves): ...this.  Remove rescan parameter.  Record each\n\tmove in the partial schedule, but don't emit it here.  Don't perform\n\tregister substitutions here either.\n\t(apply_reg_moves): New function.\n\t(duplicate_insns_of_cycles): Use register indices directly,\n\trather than finding instructions using PREV_INSN.  Use ps_reg_move.\n\t(sms_schedule): Call schedule_reg_moves before committing to\n\ta partial schedule.   Try the next ii if the schedule fails.\n\tUse apply_reg_moves instead of generate_reg_moves.  Adjust\n\tcall to print_node_sched_params.  Free node_sched_param_vec\n\tinstead of node_sched_params.\n\t(create_partial_schedule): Initialize reg_moves.\n\t(free_partial_schedule): Free reg_moves.\n\nFrom-SVN: r179743", "tree": {"sha": "8c1801e2b55fa66b8eb4f3c4775ff2ba32e0f549", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c1801e2b55fa66b8eb4f3c4775ff2ba32e0f549"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1287d8ea2c76801a0e29f4afbb0cb9449343696c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1287d8ea2c76801a0e29f4afbb0cb9449343696c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1287d8ea2c76801a0e29f4afbb0cb9449343696c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1287d8ea2c76801a0e29f4afbb0cb9449343696c/comments", "author": null, "committer": null, "parents": [{"sha": "88e9c867a92b231a6b4e1c4f2e8803ac3c786f13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88e9c867a92b231a6b4e1c4f2e8803ac3c786f13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88e9c867a92b231a6b4e1c4f2e8803ac3c786f13"}], "stats": {"total": 355, "additions": 236, "deletions": 119}, "files": [{"sha": "7fe7824bb71d65389cda576ea4804b0d21c3d978", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1287d8ea2c76801a0e29f4afbb0cb9449343696c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1287d8ea2c76801a0e29f4afbb0cb9449343696c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1287d8ea2c76801a0e29f4afbb0cb9449343696c", "patch": "@@ -1,3 +1,34 @@\n+2011-10-10  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* modulo-sched.c (ps_insn): Adjust comment.\n+\t(ps_reg_move_info): New structure.\n+\t(partial_schedule): Add reg_moves field.\n+\t(SCHED_PARAMS): Use node_sched_param_vec instead of node_sched_params.\n+\t(node_sched_params): Turn first_reg_move into an identifier.\n+\t(ps_reg_move): New function.\n+\t(ps_rtl_insn): Cope with register moves.\n+\t(ps_first_note): Adjust comment and assert that the instruction\n+\tisn't a register move.\n+\t(node_sched_params): Replace with...\n+\t(node_sched_param_vec): ...this vector.\n+\t(set_node_sched_params): Adjust accordingly.\n+\t(print_node_sched_params): Take a partial schedule instead of a ddg.\n+\tUse ps_rtl_insn and ps_reg_move.\n+\t(generate_reg_moves): Rename to...\n+\t(schedule_reg_moves): ...this.  Remove rescan parameter.  Record each\n+\tmove in the partial schedule, but don't emit it here.  Don't perform\n+\tregister substitutions here either.\n+\t(apply_reg_moves): New function.\n+\t(duplicate_insns_of_cycles): Use register indices directly,\n+\trather than finding instructions using PREV_INSN.  Use ps_reg_move.\n+\t(sms_schedule): Call schedule_reg_moves before committing to\n+\ta partial schedule.   Try the next ii if the schedule fails.\n+\tUse apply_reg_moves instead of generate_reg_moves.  Adjust\n+\tcall to print_node_sched_params.  Free node_sched_param_vec\n+\tinstead of node_sched_params.\n+\t(create_partial_schedule): Initialize reg_moves.\n+\t(free_partial_schedule): Free reg_moves.\n+\n 2011-10-10  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* modulo-sched.c (ps_insn): Replace node field with an identifier."}, {"sha": "713e4c6baca36995ff67ce39e8d7e9bda573339b", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 205, "deletions": 119, "changes": 324, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1287d8ea2c76801a0e29f4afbb0cb9449343696c/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1287d8ea2c76801a0e29f4afbb0cb9449343696c/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=1287d8ea2c76801a0e29f4afbb0cb9449343696c", "patch": "@@ -124,7 +124,9 @@ typedef struct ps_insn *ps_insn_ptr;\n /* A single instruction in the partial schedule.  */\n struct ps_insn\n {\n-  /* The number of the ddg node whose instruction is being scheduled.  */\n+  /* Identifies the instruction to be scheduled.  Values smaller than\n+     the ddg's num_nodes refer directly to ddg nodes.  A value of\n+     X - num_nodes refers to register move X.  */\n   int id;\n \n   /* The (absolute) cycle in which the PS instruction is scheduled.\n@@ -137,6 +139,30 @@ struct ps_insn\n \n };\n \n+/* Information about a register move that has been added to a partial\n+   schedule.  */\n+struct ps_reg_move_info\n+{\n+  /* The source of the move is defined by the ps_insn with id DEF.\n+     The destination is used by the ps_insns with the ids in USES.  */\n+  int def;\n+  sbitmap uses;\n+\n+  /* The original form of USES' instructions used OLD_REG, but they\n+     should now use NEW_REG.  */\n+  rtx old_reg;\n+  rtx new_reg;\n+\n+  /* An instruction that sets NEW_REG to the correct value.  The first\n+     move associated with DEF will have an rhs of OLD_REG; later moves\n+     use the result of the previous move.  */\n+  rtx insn;\n+};\n+\n+typedef struct ps_reg_move_info ps_reg_move_info;\n+DEF_VEC_O (ps_reg_move_info);\n+DEF_VEC_ALLOC_O (ps_reg_move_info, heap);\n+\n /* Holds the partial schedule as an array of II rows.  Each entry of the\n    array points to a linked list of PS_INSNs, which represents the\n    instructions that are scheduled for that row.  */\n@@ -148,6 +174,10 @@ struct partial_schedule\n   /* rows[i] points to linked list of insns scheduled in row i (0<=i<ii).  */\n   ps_insn_ptr *rows;\n \n+  /* All the moves added for this partial schedule.  Index X has\n+     a ps_insn id of X + g->num_nodes.  */\n+  VEC (ps_reg_move_info, heap) *reg_moves;\n+\n   /*  rows_length[i] holds the number of instructions in the row.\n       It is used only (as an optimization) to back off quickly from\n       trying to schedule a node in a full row; that is, to avoid running\n@@ -201,7 +231,7 @@ static void remove_node_from_ps (partial_schedule_ptr, ps_insn_ptr);\n \n #define NODE_ASAP(node) ((node)->aux.count)\n \n-#define SCHED_PARAMS(x) (&node_sched_params[x])\n+#define SCHED_PARAMS(x) VEC_index (node_sched_params, node_sched_param_vec, x)\n #define SCHED_TIME(x) (SCHED_PARAMS (x)->time)\n #define SCHED_FIRST_REG_MOVE(x) (SCHED_PARAMS (x)->first_reg_move)\n #define SCHED_NREG_MOVES(x) (SCHED_PARAMS (x)->nreg_moves)\n@@ -214,14 +244,13 @@ typedef struct node_sched_params\n {\n   int time;\t/* The absolute scheduling cycle.  */\n \n-  /* The following field (first_reg_move) is a pointer to the first\n+  /* The following field (first_reg_move) is the ps_insn id of the first\n      register-move instruction added to handle the modulo-variable-expansion\n      of the register defined by this node.  This register-move copies the\n      original register defined by the node.  */\n-  rtx first_reg_move;\n+  int first_reg_move;\n \n-  /* The number of register-move instructions added, immediately preceding\n-     first_reg_move.  */\n+  /* The number of register-move instructions added.  */\n   int nreg_moves;\n \n   int row;    /* Holds time % ii.  */\n@@ -232,6 +261,9 @@ typedef struct node_sched_params\n   int column;\n } *node_sched_params_ptr;\n \n+typedef struct node_sched_params node_sched_params;\n+DEF_VEC_O (node_sched_params);\n+DEF_VEC_ALLOC_O (node_sched_params, heap);\n \f\n /* The following three functions are copied from the current scheduler\n    code in order to use sched_analyze() for computing the dependencies.\n@@ -280,20 +312,35 @@ static struct haifa_sched_info sms_sched_info =\n   0\n };\n \n+/* Partial schedule instruction ID in PS is a register move.  Return\n+   information about it.  */\n+static struct ps_reg_move_info *\n+ps_reg_move (partial_schedule_ptr ps, int id)\n+{\n+  gcc_checking_assert (id >= ps->g->num_nodes);\n+  return VEC_index (ps_reg_move_info, ps->reg_moves, id - ps->g->num_nodes);\n+}\n+\n /* Return the rtl instruction that is being scheduled by partial schedule\n    instruction ID, which belongs to schedule PS.  */\n static rtx\n ps_rtl_insn (partial_schedule_ptr ps, int id)\n {\n-  return ps->g->nodes[id].insn;\n+  if (id < ps->g->num_nodes)\n+    return ps->g->nodes[id].insn;\n+  else\n+    return ps_reg_move (ps, id)->insn;\n }\n \n-/* Return the first instruction in the original (unscheduled) loop that\n-   was associated with ps_rtl_insn (PS, ID).  If the instruction had\n-   some notes before it, this is the first of those notes.  */\n+/* Partial schedule instruction ID, which belongs to PS, occured in\n+   the original (unscheduled) loop.  Return the first instruction\n+   in the loop that was associated with ps_rtl_insn (PS, ID).\n+   If the instruction had some notes before it, this is the first\n+   of those notes.  */\n static rtx\n ps_first_note (partial_schedule_ptr ps, int id)\n {\n+  gcc_assert (id < ps->g->num_nodes);\n   return ps->g->nodes[id].first_note;\n }\n \n@@ -397,18 +444,20 @@ res_MII (ddg_ptr g)\n }\n \n \n-/* Points to the array that contains the sched data for each node.  */\n-static node_sched_params_ptr node_sched_params;\n+/* A vector that contains the sched data for each ps_insn.  */\n+static VEC (node_sched_params, heap) *node_sched_param_vec;\n \n /* Allocate sched_params for each node and initialize it.  */\n static void\n set_node_sched_params (ddg_ptr g)\n {\n-  node_sched_params = XCNEWVEC (struct node_sched_params, g->num_nodes);\n+  VEC_truncate (node_sched_params, node_sched_param_vec, 0);\n+  VEC_safe_grow_cleared (node_sched_params, heap,\n+\t\t\t node_sched_param_vec, g->num_nodes);\n }\n \n static void\n-print_node_sched_params (FILE *file, int num_nodes, ddg_ptr g)\n+print_node_sched_params (FILE *file, int num_nodes, partial_schedule_ptr ps)\n {\n   int i;\n \n@@ -417,19 +466,19 @@ print_node_sched_params (FILE *file, int num_nodes, ddg_ptr g)\n   for (i = 0; i < num_nodes; i++)\n     {\n       node_sched_params_ptr nsp = SCHED_PARAMS (i);\n-      rtx reg_move = nsp->first_reg_move;\n       int j;\n \n       fprintf (file, \"Node = %d; INSN = %d\\n\", i,\n-\t       (INSN_UID (g->nodes[i].insn)));\n-      fprintf (file, \" asap = %d:\\n\", NODE_ASAP (&g->nodes[i]));\n+\t       INSN_UID (ps_rtl_insn (ps, i)));\n+      fprintf (file, \" asap = %d:\\n\", NODE_ASAP (&ps->g->nodes[i]));\n       fprintf (file, \" time = %d:\\n\", nsp->time);\n       fprintf (file, \" nreg_moves = %d:\\n\", nsp->nreg_moves);\n       for (j = 0; j < nsp->nreg_moves; j++)\n \t{\n+\t  ps_reg_move_info *move = ps_reg_move (ps, nsp->first_reg_move + j);\n+\n \t  fprintf (file, \" reg_move = \");\n-\t  print_rtl_single (file, reg_move);\n-\t  reg_move = PREV_INSN (reg_move);\n+\t  print_rtl_single (file, move->insn);\n \t}\n     }\n }\n@@ -445,8 +494,8 @@ print_node_sched_params (FILE *file, int num_nodes, ddg_ptr g)\n    nreg_moves = ----------------------------------- + 1 - {   dependence.\n                             ii                          { 1 if not.\n */\n-static void\n-generate_reg_moves (partial_schedule_ptr ps, bool rescan)\n+static bool\n+schedule_reg_moves (partial_schedule_ptr ps)\n {\n   ddg_ptr g = ps->g;\n   int ii = ps->ii;\n@@ -457,9 +506,8 @@ generate_reg_moves (partial_schedule_ptr ps, bool rescan)\n       ddg_node_ptr u = &g->nodes[i];\n       ddg_edge_ptr e;\n       int nreg_moves = 0, i_reg_move;\n-      sbitmap *uses_of_defs;\n-      rtx last_reg_move;\n       rtx prev_reg, old_reg;\n+      int first_move;\n       rtx set = single_set (u->insn);\n       \n       /* Skip instructions that do not set a register.  */\n@@ -504,12 +552,35 @@ generate_reg_moves (partial_schedule_ptr ps, bool rescan)\n       if (nreg_moves == 0)\n \tcontinue;\n \n+      /* Create NREG_MOVES register moves.  */\n+      first_move = VEC_length (ps_reg_move_info, ps->reg_moves);\n+      VEC_safe_grow_cleared (ps_reg_move_info, heap, ps->reg_moves,\n+\t\t\t     first_move + nreg_moves);\n+\n+      /* Record the moves associated with this node.  */\n+      first_move += ps->g->num_nodes;\n+      SCHED_FIRST_REG_MOVE (i) = first_move;\n+      SCHED_NREG_MOVES (i) = nreg_moves;\n+\n+      /* Generate each move.  */\n+      old_reg = prev_reg = SET_DEST (single_set (u->insn));\n+      for (i_reg_move = 0; i_reg_move < nreg_moves; i_reg_move++)\n+\t{\n+\t  ps_reg_move_info *move = ps_reg_move (ps, first_move + i_reg_move);\n+\n+\t  move->def = i_reg_move > 0 ? first_move + i_reg_move - 1 : i;\n+\t  move->uses = sbitmap_alloc (g->num_nodes);\n+\t  move->old_reg = old_reg;\n+\t  move->new_reg = gen_reg_rtx (GET_MODE (prev_reg));\n+\t  move->insn = gen_move_insn (move->new_reg, copy_rtx (prev_reg));\n+\t  sbitmap_zero (move->uses);\n+\n+\t  prev_reg = move->new_reg;\n+\t}\n+\n       /* Every use of the register defined by node may require a different\n \t copy of this register, depending on the time the use is scheduled.\n-\t Set a bitmap vector, telling which nodes use each copy of this\n-\t register.  */\n-      uses_of_defs = sbitmap_vector_alloc (nreg_moves, g->num_nodes);\n-      sbitmap_vector_zero (uses_of_defs, nreg_moves);\n+\t Record which uses require which move results.  */\n       for (e = u->out; e; e = e->next_out)\n \tif (e->type == TRUE_DEP && e->dest != e->src)\n \t  {\n@@ -525,40 +596,39 @@ generate_reg_moves (partial_schedule_ptr ps, bool rescan)\n \t      dest_copy--;\n \n \t    if (dest_copy)\n-\t      SET_BIT (uses_of_defs[dest_copy - 1], e->dest->cuid);\n-\t  }\n-\n-      /* Now generate the reg_moves, attaching relevant uses to them.  */\n-      SCHED_NREG_MOVES (i) = nreg_moves;\n-      old_reg = prev_reg = copy_rtx (SET_DEST (single_set (u->insn)));\n-      /* Insert the reg-moves right before the notes which precede\n-         the insn they relates to.  */\n-      last_reg_move = u->first_note;\n-\n-      for (i_reg_move = 0; i_reg_move < nreg_moves; i_reg_move++)\n-\t{\n-\t  unsigned int i_use = 0;\n-\t  rtx new_reg = gen_reg_rtx (GET_MODE (prev_reg));\n-\t  rtx reg_move = gen_move_insn (new_reg, prev_reg);\n-\t  sbitmap_iterator sbi;\n+\t      {\n+\t\tps_reg_move_info *move;\n \n-\t  add_insn_before (reg_move, last_reg_move, NULL);\n-\t  last_reg_move = reg_move;\n+\t\tmove = ps_reg_move (ps, first_move + dest_copy - 1);\n+\t\tSET_BIT (move->uses, e->dest->cuid);\n+\t      }\n+\t  }\n+    }\n+  return true;\n+}\n \n-\t  if (!SCHED_FIRST_REG_MOVE (i))\n-\t    SCHED_FIRST_REG_MOVE (i) = reg_move;\n+/* Emit the moves associatied with PS.  Apply the substitutions\n+   associated with them.  */\n+static void\n+apply_reg_moves (partial_schedule_ptr ps)\n+{\n+  ps_reg_move_info *move;\n+  int i;\n \n-\t  EXECUTE_IF_SET_IN_SBITMAP (uses_of_defs[i_reg_move], 0, i_use, sbi)\n-\t    {\n-\t      replace_rtx (g->nodes[i_use].insn, old_reg, new_reg);\n-\t      if (rescan)\n-\t\tdf_insn_rescan (g->nodes[i_use].insn);\n-\t    }\n+  FOR_EACH_VEC_ELT (ps_reg_move_info, ps->reg_moves, i, move)\n+    {\n+      unsigned int i_use;\n+      sbitmap_iterator sbi;\n \n-\t  prev_reg = new_reg;\n+      EXECUTE_IF_SET_IN_SBITMAP (move->uses, 0, i_use, sbi)\n+\t{\n+\t  replace_rtx (ps->g->nodes[i_use].insn, move->old_reg, move->new_reg);\n+\t  df_insn_rescan (ps->g->nodes[i_use].insn);\n \t}\n-      sbitmap_vector_free (uses_of_defs);\n     }\n+\n+  FOR_EACH_VEC_ELT (ps_reg_move_info, ps->reg_moves, i, move)\n+    add_insn_before (move->insn, ps_first_note (ps, move->def), NULL);\n }\n \n /* Update the sched_params (time, row and stage) for node U using the II,\n@@ -874,8 +944,7 @@ duplicate_insns_of_cycles (partial_schedule_ptr ps, int from_stage,\n     for (ps_ij = ps->rows[row]; ps_ij; ps_ij = ps_ij->next_in_row)\n       {\n \tint u = ps_ij->id;\n-\tint j, i_reg_moves;\n-\trtx reg_move = NULL_RTX;\n+\tint j, i_reg_moves, i_reg_move;\n \trtx u_insn;\n \n         /* Do not duplicate any insn which refers to count_reg as it\n@@ -899,12 +968,7 @@ duplicate_insns_of_cycles (partial_schedule_ptr ps, int from_stage,\n \t    i_reg_moves = MIN (i_reg_moves, SCHED_NREG_MOVES (u));\n \n \t    /* The reg_moves start from the *first* reg_move backwards.  */\n-\t    if (i_reg_moves)\n-\t      {\n-\t\treg_move = SCHED_FIRST_REG_MOVE (u);\n-\t\tfor (j = 1; j < i_reg_moves; j++)\n-\t\t  reg_move = PREV_INSN (reg_move);\n-\t      }\n+\t    i_reg_move = SCHED_FIRST_REG_MOVE (u) + (i_reg_moves - 1);\n \t  }\n \telse /* It's for the epilog.  */\n \t  {\n@@ -918,16 +982,15 @@ duplicate_insns_of_cycles (partial_schedule_ptr ps, int from_stage,\n \t    i_reg_moves = MIN (i_reg_moves, SCHED_NREG_MOVES (u));\n \n \t    /* The reg_moves start from the *last* reg_move forwards.  */\n-\t    if (i_reg_moves)\n-\t      {\n-\t\treg_move = SCHED_FIRST_REG_MOVE (u);\n-\t\tfor (j = 1; j < SCHED_NREG_MOVES (u); j++)\n-\t\t  reg_move = PREV_INSN (reg_move);\n-\t      }\n+\t    i_reg_move = SCHED_FIRST_REG_MOVE (u) + (SCHED_NREG_MOVES (u) - 1);\n \t  }\n \n-\tfor (j = 0; j < i_reg_moves; j++, reg_move = NEXT_INSN (reg_move))\n-\t  emit_insn (copy_rtx (PATTERN (reg_move)));\n+\tfor (j = 0; j < i_reg_moves; j++)\n+\t  {\n+\t    ps_reg_move_info *move = ps_reg_move (ps, i_reg_move - j);\n+\n+\t    emit_insn (copy_rtx (PATTERN (move->insn)));\n+\t  }\n \tif (SCHED_STAGE (u) >= from_stage\n \t    && SCHED_STAGE (u) <= to_stage)\n \t  duplicate_insn_chain (ps_first_note (ps, u), u_insn);\n@@ -1313,9 +1376,9 @@ sms_schedule (void)\n       rtx head, tail;\n       rtx count_reg, count_init;\n       int mii, rec_mii;\n-      unsigned stage_count = 0;\n+      unsigned stage_count;\n       HOST_WIDEST_INT loop_count = 0;\n-      bool opt_sc_p = false;\n+      bool opt_sc_p;\n \n       if (! (g = g_arr[loop->num]))\n         continue;\n@@ -1392,54 +1455,60 @@ sms_schedule (void)\n \tfprintf (dump_file, \"SMS iis %d %d %d (rec_mii, mii, maxii)\\n\",\n \t\t rec_mii, mii, maxii);\n \n-      set_node_sched_params (g);\n-\n-      ps = sms_schedule_by_order (g, mii, maxii, node_order);\n-      \n-      if (ps)\n+      for (;;)\n \t{\n-\t  /* Try to achieve optimized SC by normalizing the partial\n-\t     schedule (having the cycles start from cycle zero).\n-\t     The branch location must be placed in row ii-1 in the\n-\t     final scheduling.\tIf failed, shift all instructions to\n-\t     position the branch in row ii-1.  */\n-\t  opt_sc_p = optimize_sc (ps, g);\n-\t  if (opt_sc_p)\n-\t    stage_count = calculate_stage_count (ps, 0);\n-\t  else\n+\t  set_node_sched_params (g);\n+\n+\t  stage_count = 0;\n+\t  opt_sc_p = false;\n+\t  ps = sms_schedule_by_order (g, mii, maxii, node_order);\n+\n+\t  if (ps)\n \t    {\n-\t      /* Bring the branch to cycle ii-1.  */\n-\t      int amount = SCHED_TIME (g->closing_branch->cuid) - (ps->ii - 1);\n-\t      \n-\t      if (dump_file)\n-\t\tfprintf (dump_file, \"SMS schedule branch at cycle ii-1\\n\");\n-\t      \n-\t      stage_count = calculate_stage_count (ps, amount);\n+\t      /* Try to achieve optimized SC by normalizing the partial\n+\t\t schedule (having the cycles start from cycle zero).\n+\t\t The branch location must be placed in row ii-1 in the\n+\t\t final scheduling.\tIf failed, shift all instructions to\n+\t\t position the branch in row ii-1.  */\n+\t      opt_sc_p = optimize_sc (ps, g);\n+\t      if (opt_sc_p)\n+\t\tstage_count = calculate_stage_count (ps, 0);\n+\t      else\n+\t\t{\n+\t\t  /* Bring the branch to cycle ii-1.  */\n+\t\t  int amount = (SCHED_TIME (g->closing_branch->cuid)\n+\t\t\t\t- (ps->ii - 1));\n+\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \"SMS schedule branch at cycle ii-1\\n\");\n+\n+\t\t  stage_count = calculate_stage_count (ps, amount);\n+\t\t}\n+\n+\t      gcc_assert (stage_count >= 1);\n+\t      PS_STAGE_COUNT (ps) = stage_count;\n \t    }\n-\t  \n-\t  gcc_assert (stage_count >= 1);\n-\t  PS_STAGE_COUNT (ps) = stage_count;\n-\t}\n-      \n-      /* The default value of PARAM_SMS_MIN_SC is 2 as stage count of\n-\t 1 means that there is no interleaving between iterations thus\n-\t we let the scheduling passes do the job in this case.  */\n-      if (stage_count < (unsigned) PARAM_VALUE (PARAM_SMS_MIN_SC)\n-\t  || (count_init && (loop_count <= stage_count))\n-\t  || (flag_branch_probabilities && (trip_count <= stage_count)))\n-\t{\n-\t  if (dump_file)\n+\n+\t  /* The default value of PARAM_SMS_MIN_SC is 2 as stage count of\n+\t     1 means that there is no interleaving between iterations thus\n+\t     we let the scheduling passes do the job in this case.  */\n+\t  if (stage_count < (unsigned) PARAM_VALUE (PARAM_SMS_MIN_SC)\n+\t      || (count_init && (loop_count <= stage_count))\n+\t      || (flag_branch_probabilities && (trip_count <= stage_count)))\n \t    {\n-\t      fprintf (dump_file, \"SMS failed... \\n\");\n-\t      fprintf (dump_file, \"SMS sched-failed (stage-count=%d, loop-count=\", stage_count);\n-\t      fprintf (dump_file, HOST_WIDEST_INT_PRINT_DEC, loop_count);\n-\t      fprintf (dump_file, \", trip-count=\");\n-\t      fprintf (dump_file, HOST_WIDEST_INT_PRINT_DEC, trip_count);\n-\t      fprintf (dump_file, \")\\n\");\n+\t      if (dump_file)\n+\t\t{\n+\t\t  fprintf (dump_file, \"SMS failed... \\n\");\n+\t\t  fprintf (dump_file, \"SMS sched-failed (stage-count=%d,\"\n+\t\t\t   \" loop-count=\", stage_count);\n+\t\t  fprintf (dump_file, HOST_WIDEST_INT_PRINT_DEC, loop_count);\n+\t\t  fprintf (dump_file, \", trip-count=\");\n+\t\t  fprintf (dump_file, HOST_WIDEST_INT_PRINT_DEC, trip_count);\n+\t\t  fprintf (dump_file, \")\\n\");\n+\t\t}\n+\t      break;\n \t    }\n-\t}\n-      else\n-\t{\n+\n           if (!opt_sc_p)\n             {\n \t      /* Rotate the partial schedule to have the branch in row ii-1.  */\n@@ -1451,6 +1520,13 @@ sms_schedule (void)\n \t  \n \t  set_columns_for_ps (ps);\n \n+\t  if (!schedule_reg_moves (ps))\n+\t    {\n+\t      mii = ps->ii + 1;\n+\t      free_partial_schedule (ps);\n+\t      continue;\n+\t    }\n+\n \t  canon_loop (loop);\n \n           if (dump_file)\n@@ -1489,15 +1565,16 @@ sms_schedule (void)\n \t  /* The life-info is not valid any more.  */\n \t  df_set_bb_dirty (g->bb);\n \n-\t  generate_reg_moves (ps, true);\n+\t  apply_reg_moves (ps);\n \t  if (dump_file)\n-\t    print_node_sched_params (dump_file, g->num_nodes, g);\n+\t    print_node_sched_params (dump_file, g->num_nodes, ps);\n \t  /* Generate prolog and epilog.  */\n           generate_prolog_epilog (ps, loop, count_reg, count_init);\n+\t  break;\n \t}\n \n       free_partial_schedule (ps);\n-      free (node_sched_params);\n+      VEC_free (node_sched_params, heap, node_sched_param_vec);\n       free (node_order);\n       free_ddg (g);\n     }\n@@ -2584,6 +2661,7 @@ create_partial_schedule (int ii, ddg_ptr g, int history)\n   partial_schedule_ptr ps = XNEW (struct partial_schedule);\n   ps->rows = (ps_insn_ptr *) xcalloc (ii, sizeof (ps_insn_ptr));\n   ps->rows_length = (int *) xcalloc (ii, sizeof (int));\n+  ps->reg_moves = NULL;\n   ps->ii = ii;\n   ps->history = history;\n   ps->min_cycle = INT_MAX;\n@@ -2618,8 +2696,16 @@ free_ps_insns (partial_schedule_ptr ps)\n static void\n free_partial_schedule (partial_schedule_ptr ps)\n {\n+  ps_reg_move_info *move;\n+  unsigned int i;\n+\n   if (!ps)\n     return;\n+\n+  FOR_EACH_VEC_ELT (ps_reg_move_info, ps->reg_moves, i, move)\n+    sbitmap_free (move->uses);\n+  VEC_free (ps_reg_move_info, heap, ps->reg_moves);\n+\n   free_ps_insns (ps);\n   free (ps->rows);\n   free (ps->rows_length);"}]}