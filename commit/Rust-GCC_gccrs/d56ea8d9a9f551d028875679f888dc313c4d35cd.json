{"sha": "d56ea8d9a9f551d028875679f888dc313c4d35cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU2ZWE4ZDlhOWY1NTFkMDI4ODc1Njc5Zjg4OGRjMzEzYzRkMzVjZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-05-05T04:06:38Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-05-05T04:06:38Z"}, "message": "ffi64.c (ffi_prep_cif_machdep): Save sse-used flag in bit 11 of flags.\n\n        * src/x86/ffi64.c (ffi_prep_cif_machdep): Save sse-used flag in\n        bit 11 of flags.\n        (ffi_call): Mask return type field.  Pass ssecount to ffi_call_unix64.\n        (ffi_prep_closure): Set carry bit if sse-used flag set.\n        * src/x86/unix64.S (ffi_call_unix64): Add ssecount argument.\n        Only load sse registers if ssecount non-zero.\n        (ffi_closure_unix64): Only save sse registers if carry set on entry.\n\nFrom-SVN: r99257", "tree": {"sha": "8708120ca3f10331ac685fc82ea84ae59c27cd3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8708120ca3f10331ac685fc82ea84ae59c27cd3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d56ea8d9a9f551d028875679f888dc313c4d35cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d56ea8d9a9f551d028875679f888dc313c4d35cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d56ea8d9a9f551d028875679f888dc313c4d35cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d56ea8d9a9f551d028875679f888dc313c4d35cd/comments", "author": null, "committer": null, "parents": [{"sha": "08cce8fe0c24e5f3b8d4c1c94da7fb71fa0e180a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08cce8fe0c24e5f3b8d4c1c94da7fb71fa0e180a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08cce8fe0c24e5f3b8d4c1c94da7fb71fa0e180a"}], "stats": {"total": 159, "additions": 107, "deletions": 52}, "files": [{"sha": "84003df8de2762bc1248d407f036edd3f4c0f886", "filename": "libffi/ChangeLog", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d56ea8d9a9f551d028875679f888dc313c4d35cd/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d56ea8d9a9f551d028875679f888dc313c4d35cd/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=d56ea8d9a9f551d028875679f888dc313c4d35cd", "patch": "@@ -1,4 +1,15 @@\n-2005-05-29  Ralf Corsepius  <ralf.corsepius@rtems.org>\n+2005-05-04  Andreas Degert <ad@papyrus-gmbh.de>\n+\t    Richard Henderson  <rth@redhat.com>\n+\n+\t* src/x86/ffi64.c (ffi_prep_cif_machdep): Save sse-used flag in\n+\tbit 11 of flags.\n+\t(ffi_call): Mask return type field.  Pass ssecount to ffi_call_unix64.\n+\t(ffi_prep_closure): Set carry bit if sse-used flag set.\n+\t* src/x86/unix64.S (ffi_call_unix64): Add ssecount argument.\n+\tOnly load sse registers if ssecount non-zero.\n+\t(ffi_closure_unix64): Only save sse registers if carry set on entry.\n+\n+2005-04-29  Ralf Corsepius  <ralf.corsepius@rtems.org>\n \n \t* configure.ac: Add i*86-*-rtems*, sparc*-*-rtems*,\n \tpowerpc-*rtems*, arm*-*-rtems*, sh-*-rtems*."}, {"sha": "c6cf330c2c3e7321027e30639654a8e5faba5b9f", "filename": "libffi/src/x86/ffi64.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d56ea8d9a9f551d028875679f888dc313c4d35cd/libffi%2Fsrc%2Fx86%2Fffi64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d56ea8d9a9f551d028875679f888dc313c4d35cd/libffi%2Fsrc%2Fx86%2Fffi64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffi64.c?ref=d56ea8d9a9f551d028875679f888dc313c4d35cd", "patch": "@@ -42,7 +42,7 @@ struct register_args\n };\n \n extern void ffi_call_unix64 (void *args, unsigned long bytes, unsigned flags,\n-\t\t\t     void *raddr, void (*fnaddr)());\n+\t\t\t     void *raddr, void (*fnaddr)(), unsigned ssecount);\n \n /* All reference to register classes here is identical to the code in\n    gcc/config/i386/i386.c. Do *not* change one without the other.  */\n@@ -303,10 +303,9 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n \t  else if (sse0 && sse1)\n \t    flags |= 1 << 10;\n \t  /* Mark the true size of the structure.  */\n-\t  flags |= cif->rtype->size << 11;\n+\t  flags |= cif->rtype->size << 12;\n \t}\n     }\n-  cif->flags = flags;\n \n   /* Go over all arguments and determine the way they should be passed.\n      If it's in a register and there is space for it, let that be so. If\n@@ -331,6 +330,9 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n \t  ssecount += nsse;\n \t}\n     }\n+  if (ssecount)\n+    flags |= 1 << 11;\n+  cif->flags = flags;\n   cif->bytes = bytes;\n \n   return FFI_OK;\n@@ -353,7 +355,7 @@ ffi_call (ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n      address then we need to make one.  Note the setting of flags to\n      VOID above in ffi_prep_cif_machdep.  */\n   ret_in_memory = (cif->rtype->type == FFI_TYPE_STRUCT\n-\t\t   && cif->flags == FFI_TYPE_VOID);\n+\t\t   && (cif->flags & 0xff) == FFI_TYPE_VOID);\n   if (rvalue == NULL && ret_in_memory)\n     rvalue = alloca (cif->rtype->size);\n \n@@ -424,7 +426,7 @@ ffi_call (ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n     }\n \n   ffi_call_unix64 (stack, cif->bytes + sizeof (struct register_args),\n-\t\t   cif->flags, rvalue, fn);\n+\t\t   cif->flags, rvalue, fn, ssecount);\n }\n \n \n@@ -439,13 +441,18 @@ ffi_prep_closure (ffi_closure* closure,\n   volatile unsigned short *tramp;\n \n   tramp = (volatile unsigned short *) &closure->tramp[0];\n+\n   tramp[0] = 0xbb49;\t\t/* mov <code>, %r11\t*/\n-  tramp[5] = 0xba49;\t\t/* mov <data>, %r10\t*/\n-  tramp[10] = 0xff49;\t\t/* jmp *%r11\t*/\n-  tramp[11] = 0x00e3;\n   *(void * volatile *) &tramp[1] = ffi_closure_unix64;\n+  tramp[5] = 0xba49;\t\t/* mov <data>, %r10\t*/\n   *(void * volatile *) &tramp[6] = closure;\n \n+  /* Set the carry bit iff the function uses any sse registers.\n+     This is clc or stc, together with the first byte of the jmp.  */\n+  tramp[10] = cif->flags & (1 << 11) ? 0x49f9 : 0x49f8;\n+\n+  tramp[11] = 0xe3ff;\t\t\t/* jmp *%r11    */\n+\n   closure->cif = cif;\n   closure->fun = fun;\n   closure->user_data = user_data;"}, {"sha": "831e1d7132fe8c2f8b7873d5bda46c9051d3f326", "filename": "libffi/src/x86/unix64.S", "status": "modified", "additions": 80, "deletions": 43, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d56ea8d9a9f551d028875679f888dc313c4d35cd/libffi%2Fsrc%2Fx86%2Funix64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d56ea8d9a9f551d028875679f888dc313c4d35cd/libffi%2Fsrc%2Fx86%2Funix64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Funix64.S?ref=d56ea8d9a9f551d028875679f888dc313c4d35cd", "patch": "@@ -31,15 +31,15 @@\n .text\n \n /* ffi_call_unix64 (void *args, unsigned long bytes, unsigned flags,\n-                    void *raddr, void (*fnaddr)());\n+\t            void *raddr, void (*fnaddr)());\n \n    Bit o trickiness here -- ARGS+BYTES is the base of the stack frame\n    for this function.  This has been allocated by ffi_call.  We also\n    deallocate some of the stack that has been alloca'd.  */\n \n \t.align\t2\n \t.globl\tffi_call_unix64\n-        .type\tffi_call_unix64,@function\n+\t.type\tffi_call_unix64,@function\n \n ffi_call_unix64:\n .LUW0:\n@@ -53,6 +53,7 @@ ffi_call_unix64:\n .LUW1:\n \tmovq\t%rdi, %r10\t\t/* Save a copy of the register area. */\n \tmovq\t%r8, %r11\t\t/* Save a copy of the target fn.  */\n+\tmovl\t%r9d, %eax\t\t/* Set number of SSE registers.  */\n \n \t/* Load up all argument registers.  */\n \tmovq\t(%r10), %rdi\n@@ -61,14 +62,9 @@ ffi_call_unix64:\n \tmovq\t24(%r10), %rcx\n \tmovq\t32(%r10), %r8\n \tmovq\t40(%r10), %r9\n-\tmovdqa\t48(%r10), %xmm0\n-\tmovdqa\t64(%r10), %xmm1\n-\tmovdqa\t80(%r10), %xmm2\n-\tmovdqa\t96(%r10), %xmm3\n-\tmovdqa\t112(%r10), %xmm4\n-\tmovdqa\t128(%r10), %xmm5\n-\tmovdqa\t144(%r10), %xmm6\n-\tmovdqa\t160(%r10), %xmm7\n+\ttestl\t%eax, %eax\n+\tjnz\t.Lload_sse\n+.Lret_from_load_sse:\n \n \t/* Deallocate the reg arg area.  */\n \tleaq\t176(%r10), %rsp\n@@ -181,37 +177,49 @@ ffi_call_unix64:\n \tmovq\t%rax, (%rsi)\n \tmovq\t%rdx, 8(%rsi)\n \n-\t/* Bits 11-31 contain the true size of the structure.  Copy from\n+\t/* Bits 12-31 contain the true size of the structure.  Copy from\n \t   the scratch area to the true destination.  */\n-\tshrl\t$11, %ecx\n+\tshrl\t$12, %ecx\n \trep movsb\n \tret\n+\n+\t/* Many times we can avoid loading any SSE registers at all.\n+\t   It's not worth an indirect jump to load the exact set of\n+\t   SSE registers needed; zero or all is a good compromise.  */\n+\t.align 2\n .LUW3:\n+.Lload_sse:\n+\tmovdqa\t48(%r10), %xmm0\n+\tmovdqa\t64(%r10), %xmm1\n+\tmovdqa\t80(%r10), %xmm2\n+\tmovdqa\t96(%r10), %xmm3\n+\tmovdqa\t112(%r10), %xmm4\n+\tmovdqa\t128(%r10), %xmm5\n+\tmovdqa\t144(%r10), %xmm6\n+\tmovdqa\t160(%r10), %xmm7\n+\tjmp\t.Lret_from_load_sse\n+\n+.LUW4:\n \t.size    ffi_call_unix64,.-ffi_call_unix64\n \n \t.align\t2\n \t.globl ffi_closure_unix64\n-        .type\tffi_closure_unix64,@function\n+\t.type\tffi_closure_unix64,@function\n \n ffi_closure_unix64:\n-.LUW4:\n-\tsubq\t$200, %rsp\n .LUW5:\n-\n+\t/* The carry flag is set by the trampoline iff SSE registers\n+\t   are used.  Don't clobber it before the branch instruction.  */\n+\tleaq    -200(%rsp), %rsp\n+.LUW6:\n \tmovq\t%rdi, (%rsp)\n-        movq    %rsi, 8(%rsp)\n-        movq    %rdx, 16(%rsp)\n-        movq    %rcx, 24(%rsp)\n-        movq    %r8, 32(%rsp)\n-        movq    %r9, 40(%rsp)\n-\tmovdqa\t%xmm0, 48(%rsp)\n-\tmovdqa\t%xmm1, 64(%rsp)\n-\tmovdqa\t%xmm2, 80(%rsp)\n-\tmovdqa\t%xmm3, 96(%rsp)\n-\tmovdqa\t%xmm4, 112(%rsp)\n-\tmovdqa\t%xmm5, 128(%rsp)\n-\tmovdqa\t%xmm6, 144(%rsp)\n-\tmovdqa\t%xmm7, 160(%rsp)\n+\tmovq    %rsi, 8(%rsp)\n+\tmovq    %rdx, 16(%rsp)\n+\tmovq    %rcx, 24(%rsp)\n+\tmovq    %r8, 32(%rsp)\n+\tmovq    %r9, 40(%rsp)\n+\tjc      .Lsave_sse\n+.Lret_from_save_sse:\n \n \tmovq\t%r10, %rdi\n \tleaq\t176(%rsp), %rsi\n@@ -221,7 +229,7 @@ ffi_closure_unix64:\n \n \t/* Deallocate stack frame early; return value is now in redzone.  */\n \taddq\t$200, %rsp\n-.LUW6:\n+.LUW7:\n \n \t/* The first byte of the return value contains the FFI_TYPE.  */\n \tmovzbl\t%al, %r10d\n@@ -300,7 +308,22 @@ ffi_closure_unix64:\n \tmovq\t-24(%rsp), %rax\n \tcmovnz\t%rdx, %rax\n \tret\n-.LUW7:\n+\n+\t/* See the comment above .Lload_sse; the same logic applies here.  */\n+\t.align 2\n+.LUW8:\n+.Lsave_sse:\n+\tmovdqa\t%xmm0, 48(%rsp)\n+\tmovdqa\t%xmm1, 64(%rsp)\n+\tmovdqa\t%xmm2, 80(%rsp)\n+\tmovdqa\t%xmm3, 96(%rsp)\n+\tmovdqa\t%xmm4, 112(%rsp)\n+\tmovdqa\t%xmm5, 128(%rsp)\n+\tmovdqa\t%xmm6, 144(%rsp)\n+\tmovdqa\t%xmm7, 160(%rsp)\n+\tjmp\t.Lret_from_save_sse\n+\n+.LUW9:\n \t.size\tffi_closure_unix64,.-ffi_closure_unix64\n \n \t.section\t.eh_frame,\"a\",@progbits\n@@ -327,48 +350,62 @@ ffi_closure_unix64:\n .LASFDE1:\n \t.long\t.LASFDE1-.Lframe1\t/* FDE CIE offset */\n \t.long\t.LUW0-.\t\t\t/* FDE initial location */\n-\t.long\t.LUW3-.LUW0\t\t/* FDE address range */\n+\t.long\t.LUW4-.LUW0\t\t/* FDE address range */\n \t.uleb128 0x0\t\t\t/* Augmentation size */\n \n \t.byte\t0x4\t\t\t/* DW_CFA_advance_loc4 */\n \t.long\t.LUW1-.LUW0\n \n-        /* New stack frame based off rbp.  This is a itty bit of unwind\n-           trickery in that the CFA *has* changed.  There is no easy way\n-           to describe it correctly on entry to the function.  Fortunately,\n-           it doesn't matter too much since at all points we can correctly\n-           unwind back to ffi_call.  Note that the location to which we\n-           moved the return address is (the new) CFA-8, so from the\n-           perspective of the unwind info, it hasn't moved.  */\n+\t/* New stack frame based off rbp.  This is a itty bit of unwind\n+\t   trickery in that the CFA *has* changed.  There is no easy way\n+\t   to describe it correctly on entry to the function.  Fortunately,\n+\t   it doesn't matter too much since at all points we can correctly\n+\t   unwind back to ffi_call.  Note that the location to which we\n+\t   moved the return address is (the new) CFA-8, so from the\n+\t   perspective of the unwind info, it hasn't moved.  */\n \t.byte\t0xc\t\t\t/* DW_CFA_def_cfa, %rbp offset 32 */\n \t.uleb128 6\n \t.uleb128 32\n \t.byte\t0x80+6\t\t\t/* DW_CFA_offset, %rbp offset 2*-8 */\n \t.uleb128 2\n+\t.byte\t0xa\t\t\t/* DW_CFA_remember_state */\n \n \t.byte\t0x4\t\t\t/* DW_CFA_advance_loc4 */\n \t.long\t.LUW2-.LUW1\n \t.byte\t0xc\t\t\t/* DW_CFA_def_cfa, %rsp offset 8 */\n \t.uleb128 7\n \t.uleb128 8\n \t.byte\t0xc0+6\t\t\t/* DW_CFA_restore, %rbp */\n+\n+\t.byte\t0x4\t\t\t/* DW_CFA_advance_loc4 */\n+\t.long\t.LUW3-.LUW2\n+\t.byte\t0xb\t\t\t/* DW_CFA_restore_state */\n+\n \t.align 8\n .LEFDE1:\n .LSFDE3:\n \t.long\t.LEFDE3-.LASFDE3\t/* FDE Length */\n .LASFDE3:\n \t.long\t.LASFDE3-.Lframe1\t/* FDE CIE offset */\n-\t.long\t.LUW4-.\t\t\t/* FDE initial location */\n-\t.long\t.LUW7-.LUW4\t\t/* FDE address range */\n+\t.long\t.LUW5-.\t\t\t/* FDE initial location */\n+\t.long\t.LUW9-.LUW5\t\t/* FDE address range */\n \t.uleb128 0x0\t\t\t/* Augmentation size */\n+\n \t.byte\t0x4\t\t\t/* DW_CFA_advance_loc4 */\n-\t.long\t.LUW5-.LUW4\n+\t.long\t.LUW6-.LUW5\n \t.byte\t0xe\t\t\t/* DW_CFA_def_cfa_offset */\n \t.uleb128 208\n+\t.byte\t0xa\t\t\t/* DW_CFA_remember_state */\n+\n \t.byte\t0x4\t\t\t/* DW_CFA_advance_loc4 */\n-\t.long\t.LUW6-.LUW5\n+\t.long\t.LUW7-.LUW6\n \t.byte\t0xe\t\t\t/* DW_CFA_def_cfa_offset */\n \t.uleb128 8\n+\n+\t.byte\t0x4\t\t\t/* DW_CFA_advance_loc4 */\n+\t.long\t.LUW8-.LUW7\n+\t.byte\t0xb\t\t\t/* DW_CFA_restore_state */\n+\n \t.align 8\n .LEFDE3:\n "}]}