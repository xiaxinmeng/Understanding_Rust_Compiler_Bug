{"sha": "e4fe948a6e9049df934677fc95d78b11c5cff4bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTRmZTk0OGE2ZTkwNDlkZjkzNDY3N2ZjOTVkNzhiMTFjNWNmZjRiZA==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2011-11-04T16:20:18Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2011-11-04T16:20:18Z"}, "message": "re PR target/50931 ([avr] Support a 24-bit scalar integer mode)\n\ngcc/\n\tPR target/50931\n\t* config/avr/avr-modes.def: New file defining PSImode.\n\t* config/avr/avr-c.c (__INT24_MAX__, __INT24_MIN__,\n\t__UINT24_MAX__): New built-in defines.\n\t* config/avr/avr.md (adjust_len): Add tstpsi, mov24,  reload_in24,\n\tashlpsi, ashrpsi, lshrpsi.\n\t(QISO, QIDI, HISI, HIDI, MPUSH, rotx, rotsmode): Add PSI.\n\t(MOVMODE): New mode iterator.\n\t(movpsi): New expander.\n\t(movqi, movhi, movsi, movsf, movpsi): Write as one using MOVMODE.\n\t(*reload_inpsi, *movpsi): New insns.\n\t(*reload_inpsi): New RTL peephole.\n\t(addpsi3, *addpsi3_zero_extend.qi, *addpsi3_zero_extend.hi,\n\t*addpsi3_sign_extend.hi): New insns.\n\t(subpsi3, *subpsi3_zero_extend.qi, *subpsi3_zero_extend.hi,\n\t*subpsi3_sign_extend.hi): New insns.\n\t(divmodpsi4, udivmodpsi4): New define insn-and-split.\n\t(*divmodpsi4_call, *udivmodpsi4_call): New insns.\n\t(andpsi3, iorpsi3, xorpsi3): New insns.\n\t(*rotlpsi2.1, *rotlpsi2.23): New insns.\n\t(*rotw<mode>): Insn condition only allow even-sized modes.\n\t(*rotb<mode>): Insn condition allows odd-sized modes.\n\t(ashlpsi3, ashrpsi3, lshrpsi3, *addpsi3.lt0): New insns.\n\t(negpsi2, one_cmplpsi2): New insns.\n\t(extendqipsi2, extendhipsi2, extendpsisi2): New insns.\n\t(zero_extendqipsi2, zero_extendhipsi2, zero_extendpsisi2): New\n\tinsn-and-splits.\n\t(*cmppsi, *negated_tstpsi, *reversed_tstpsi): New insns.\n\t(cbranchpsi4): New expander.\n\t* config/avr/constraints.md (Ca3, Co3, Cx3): New constraints.\n\t* config/avr/avr-protos.h (avr_out_tstpsi, avr_out_movpsi,\n\tavr_out_ashlpsi3, avr_out_ashrpsi3, avr_out_lshrpsi3,\n\tavr_out_reload_inpsi): New prototypes.\n\n\t* config/avr/avr.c (TARGET_SCALAR_MODE_SUPPORTED_P): Define to...\n\t(avr_scalar_mode_supported_p): ...this new static function.\n\t(avr_asm_len): Always return \"\".\n\t(avr_out_load_psi, avr_out_store_psi): New static functions.\n\t(avr_out_movpsi, avr_out_reload_inpsi): New functions.\n\t(avr_out_tstpsi): New function.\n\t(avr_out_ashlpsi3, avr_out_ashrpsi3, avr_out_lshrpsi3): New functions.\n\t(avr_out_plus_1, output_reload_in_const): Handle 3-byte types.\n\t(avr_simplify_comparison_p): Ditto.\n\t(adjust_insn_length): Handle ADJUST_LEN_RELOAD_IN24,\n\tADJUST_LEN_MOV24, ADJUST_LEN_TSTPSI, ADJUST_LEN_ASHLPSI,\n\tADJUST_LEN_ASHRPSI, ADJUST_LEN_LSHRPSI.\n\t(avr_rtx_costs_1): Report PSI costs.\n\t(avr_libcall_value): Handle odd-sized parameters.\n\t(avr_init_builtin_int24): New static function to define built-in\n\t24-bit types __int24 and __uint24.\n\t(avr_init_builtins): Use it.\n\nlibgcc/\n\tPR target/50931\n\t* config/t-avr (LIB1ASMFUNCS): Add _divmodpsi4, _udivmodpsi4.\n\t* config/lib1funcs.S (__udivmodpsi4, __divmodpsi4): New functions.\n\nFrom-SVN: r180962", "tree": {"sha": "8a4a616f637a4b3c284af95ea6b72a33644a4462", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a4a616f637a4b3c284af95ea6b72a33644a4462"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4fe948a6e9049df934677fc95d78b11c5cff4bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4fe948a6e9049df934677fc95d78b11c5cff4bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4fe948a6e9049df934677fc95d78b11c5cff4bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4fe948a6e9049df934677fc95d78b11c5cff4bd/comments", "author": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2fcc5e64740e48417e93d986bd58595296bec0c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fcc5e64740e48417e93d986bd58595296bec0c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fcc5e64740e48417e93d986bd58595296bec0c5"}], "stats": {"total": 1520, "additions": 1425, "deletions": 95}, "files": [{"sha": "d6e9551bc61003746d5e8948079dab58d3dbb0f2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4fe948a6e9049df934677fc95d78b11c5cff4bd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4fe948a6e9049df934677fc95d78b11c5cff4bd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e4fe948a6e9049df934677fc95d78b11c5cff4bd", "patch": "@@ -1,4 +1,58 @@\n-2011-11-04\tThomas Doerfler <thomas.doerfler@embedded-brains.de>\n+2011-11-04  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/50931\n+\t* config/avr/avr-modes.def: New file defining PSImode.\n+\t* config/avr/avr-c.c (__INT24_MAX__, __INT24_MIN__,\n+\t__UINT24_MAX__): New built-in defines.\n+\t* config/avr/avr.md (adjust_len): Add tstpsi, mov24,  reload_in24,\n+\tashlpsi, ashrpsi, lshrpsi.\n+\t(QISO, QIDI, HISI, HIDI, MPUSH, rotx, rotsmode): Add PSI.\n+\t(MOVMODE): New mode iterator.\n+\t(movpsi): New expander.\n+\t(movqi, movhi, movsi, movsf, movpsi): Write as one using MOVMODE.\n+\t(*reload_inpsi, *movpsi): New insns.\n+\t(*reload_inpsi): New RTL peephole.\n+\t(addpsi3, *addpsi3_zero_extend.qi, *addpsi3_zero_extend.hi,\n+\t*addpsi3_sign_extend.hi): New insns.\n+\t(subpsi3, *subpsi3_zero_extend.qi, *subpsi3_zero_extend.hi,\n+\t*subpsi3_sign_extend.hi): New insns.\n+\t(divmodpsi4, udivmodpsi4): New define insn-and-split.\n+\t(*divmodpsi4_call, *udivmodpsi4_call): New insns.\n+\t(andpsi3, iorpsi3, xorpsi3): New insns.\n+\t(*rotlpsi2.1, *rotlpsi2.23): New insns.\n+\t(*rotw<mode>): Insn condition only allow even-sized modes.\n+\t(*rotb<mode>): Insn condition allows odd-sized modes.\n+\t(ashlpsi3, ashrpsi3, lshrpsi3, *addpsi3.lt0): New insns.\n+\t(negpsi2, one_cmplpsi2): New insns.\n+\t(extendqipsi2, extendhipsi2, extendpsisi2): New insns.\n+\t(zero_extendqipsi2, zero_extendhipsi2, zero_extendpsisi2): New\n+\tinsn-and-splits.\n+\t(*cmppsi, *negated_tstpsi, *reversed_tstpsi): New insns.\n+\t(cbranchpsi4): New expander.\n+\t* config/avr/constraints.md (Ca3, Co3, Cx3): New constraints.\n+\t* config/avr/avr-protos.h (avr_out_tstpsi, avr_out_movpsi,\n+\tavr_out_ashlpsi3, avr_out_ashrpsi3, avr_out_lshrpsi3,\n+\tavr_out_reload_inpsi): New prototypes.\n+\n+\t* config/avr/avr.c (TARGET_SCALAR_MODE_SUPPORTED_P): Define to...\n+\t(avr_scalar_mode_supported_p): ...this new static function.\n+\t(avr_asm_len): Always return \"\".\n+\t(avr_out_load_psi, avr_out_store_psi): New static functions.\n+\t(avr_out_movpsi, avr_out_reload_inpsi): New functions.\n+\t(avr_out_tstpsi): New function.\n+\t(avr_out_ashlpsi3, avr_out_ashrpsi3, avr_out_lshrpsi3): New functions.\n+\t(avr_out_plus_1, output_reload_in_const): Handle 3-byte types.\n+\t(avr_simplify_comparison_p): Ditto.\n+\t(adjust_insn_length): Handle ADJUST_LEN_RELOAD_IN24,\n+\tADJUST_LEN_MOV24, ADJUST_LEN_TSTPSI, ADJUST_LEN_ASHLPSI,\n+\tADJUST_LEN_ASHRPSI, ADJUST_LEN_LSHRPSI.\n+\t(avr_rtx_costs_1): Report PSI costs.\n+\t(avr_libcall_value): Handle odd-sized parameters.\n+\t(avr_init_builtin_int24): New static function to define built-in\n+\t24-bit types __int24 and __uint24.\n+\t(avr_init_builtins): Use it.\n+\t\n+2011-11-04  Thomas Doerfler <thomas.doerfler@embedded-brains.de>\n \n \tPR target/50989\n \t* config/arm/rtems-elf.h, config/arm/t-rtems: Add optional"}, {"sha": "55de2d7fe4b8976485204c628673c77834ae27cf", "filename": "gcc/config/avr/avr-c.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4fe948a6e9049df934677fc95d78b11c5cff4bd/gcc%2Fconfig%2Favr%2Favr-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4fe948a6e9049df934677fc95d78b11c5cff4bd/gcc%2Fconfig%2Favr%2Favr-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-c.c?ref=e4fe948a6e9049df934677fc95d78b11c5cff4bd", "patch": "@@ -105,4 +105,8 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n   cpp_define (pfile, \"__BUILTIN_AVR_FMUL\");\n   cpp_define (pfile, \"__BUILTIN_AVR_FMULS\");\n   cpp_define (pfile, \"__BUILTIN_AVR_FMULSU\");\n+\n+  cpp_define (pfile, \"__INT24_MAX__=8388607L\");\n+  cpp_define (pfile, \"__INT24_MIN__=(-__INT24_MAX__-1)\");\n+  cpp_define (pfile, \"__UINT24_MAX__=16777215UL\");\n }"}, {"sha": "4a16f888ddf6a286f0b87c2dad968d4489b1d7ff", "filename": "gcc/config/avr/avr-modes.def", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4fe948a6e9049df934677fc95d78b11c5cff4bd/gcc%2Fconfig%2Favr%2Favr-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4fe948a6e9049df934677fc95d78b11c5cff4bd/gcc%2Fconfig%2Favr%2Favr-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-modes.def?ref=e4fe948a6e9049df934677fc95d78b11c5cff4bd", "patch": "@@ -0,0 +1 @@\n+FRACTIONAL_INT_MODE (PSI, 24, 3);"}, {"sha": "f72c5f8ab15dc96b273ca840ceec87baac9b74d3", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4fe948a6e9049df934677fc95d78b11c5cff4bd/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4fe948a6e9049df934677fc95d78b11c5cff4bd/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=e4fe948a6e9049df934677fc95d78b11c5cff4bd", "patch": "@@ -59,8 +59,10 @@ extern const char *out_movsi_mr_r (rtx insn, rtx op[], int *l);\n extern const char *output_movsisf (rtx insn, rtx operands[], int *l);\n extern const char *avr_out_tstsi (rtx, rtx*, int*);\n extern const char *avr_out_tsthi (rtx, rtx*, int*);\n+extern const char *avr_out_tstpsi (rtx, rtx*, int*);\n extern const char *avr_out_compare (rtx, rtx*, int*);\n extern const char *ret_cond_branch (rtx x, int len, int reverse);\n+extern const char *avr_out_movpsi (rtx, rtx*, int*);\n \n extern const char *ashlqi3_out (rtx insn, rtx operands[], int *len);\n extern const char *ashlhi3_out (rtx insn, rtx operands[], int *len);\n@@ -73,6 +75,11 @@ extern const char *ashrsi3_out (rtx insn, rtx operands[], int *len);\n extern const char *lshrqi3_out (rtx insn, rtx operands[], int *len);\n extern const char *lshrhi3_out (rtx insn, rtx operands[], int *len);\n extern const char *lshrsi3_out (rtx insn, rtx operands[], int *len);\n+\n+extern const char *avr_out_ashlpsi3 (rtx, rtx*, int*);\n+extern const char *avr_out_ashrpsi3 (rtx, rtx*, int*);\n+extern const char *avr_out_lshrpsi3 (rtx, rtx*, int*);\n+\n extern bool avr_rotate_bytes (rtx operands[]);\n \n extern void expand_prologue (void);\n@@ -93,6 +100,7 @@ extern int extra_constraint_Q (rtx x);\n extern int adjust_insn_length (rtx insn, int len);\n extern const char* output_reload_inhi (rtx*, rtx, int*);\n extern const char* output_reload_insisf (rtx*, rtx, int*);\n+extern const char* avr_out_reload_inpsi (rtx*, rtx, int*);\n extern void notice_update_cc (rtx body, rtx insn);\n extern void print_operand (FILE *file, rtx x, int code);\n extern void print_operand_address (FILE *file, rtx addr);"}, {"sha": "c8b2689a7ae3975a4b1f4d881afddf6820087bbd", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 687, "deletions": 28, "changes": 715, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4fe948a6e9049df934677fc95d78b11c5cff4bd/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4fe948a6e9049df934677fc95d78b11c5cff4bd/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=e4fe948a6e9049df934677fc95d78b11c5cff4bd", "patch": "@@ -217,6 +217,9 @@ bool avr_need_copy_data_p = false;\n #undef TARGET_ASM_FUNCTION_RODATA_SECTION\n #define TARGET_ASM_FUNCTION_RODATA_SECTION avr_asm_function_rodata_section\n \n+#undef  TARGET_SCALAR_MODE_SUPPORTED_P\n+#define TARGET_SCALAR_MODE_SUPPORTED_P avr_scalar_mode_supported_p\n+\n \f\n \n /* Custom function to replace string prefix.\n@@ -369,6 +372,17 @@ avr_regno_reg_class (int r)\n   return ALL_REGS;\n }\n \n+\n+static bool\n+avr_scalar_mode_supported_p (enum machine_mode mode)\n+{\n+  if (PSImode == mode)\n+    return true;\n+\n+  return default_scalar_mode_supported_p (mode);\n+}\n+\n+\n /* A helper for the subsequent function attribute used to dig for\n    attribute 'name' in a FUNCTION_DECL or FUNCTION_TYPE */\n \n@@ -1487,7 +1501,7 @@ avr_legitimize_reload_address (rtx *px, enum machine_mode mode,\n \n \n /* Helper function to print assembler resp. track instruction\n-   sequence lengths.\n+   sequence lengths.  Always return \"\".\n    \n    If PLEN == NULL:\n        Output assembler code from template TPL with operands supplied\n@@ -1499,7 +1513,7 @@ avr_legitimize_reload_address (rtx *px, enum machine_mode mode,\n        Don't output anything.\n */\n \n-static void\n+static const char*\n avr_asm_len (const char* tpl, rtx* operands, int* plen, int n_words)\n {\n   if (NULL == plen)\n@@ -1513,6 +1527,8 @@ avr_asm_len (const char* tpl, rtx* operands, int* plen, int n_words)\n       else\n         *plen += n_words;\n     }\n+\n+  return \"\";\n }\n \n \n@@ -1562,6 +1578,8 @@ cond_string (enum rtx_code code)\n     default:\n       gcc_unreachable ();\n     }\n+\n+  return \"\";\n }\n \n /* Output ADDR to FILE as address.  */\n@@ -1968,6 +1986,7 @@ avr_simplify_comparison_p (enum machine_mode mode, RTX_CODE op, rtx x)\n {\n   unsigned int max = (mode == QImode ? 0xff :\n                       mode == HImode ? 0xffff :\n+                      mode == PSImode ? 0xffffff :\n                       mode == SImode ? 0xffffffff : 0);\n   if (max && op && GET_CODE (x) == CONST_INT)\n     {\n@@ -2956,6 +2975,306 @@ output_movsisf (rtx insn, rtx operands[], int *l)\n   return \"\";\n }\n \n+\n+/* Handle loads of 24-bit types from memory to register.  */\n+\n+static const char*\n+avr_out_load_psi (rtx insn, rtx *op, int *plen)\n+{\n+  rtx dest = op[0];\n+  rtx src = op[1];\n+  rtx base = XEXP (src, 0);\n+  int reg_dest = true_regnum (dest);\n+  int reg_base = true_regnum (base);\n+  \n+  if (reg_base > 0)\n+    {\n+      if (reg_base == REG_X)        /* (R26) */\n+        {\n+          if (reg_dest == REG_X)\n+            /* \"ld r26,-X\" is undefined */\n+            return avr_asm_len (\"adiw r26,2\"        CR_TAB\n+                                \"ld r28,X\"          CR_TAB\n+                                \"ld __tmp_reg__,-X\" CR_TAB\n+                                \"sbiw r26,1\"        CR_TAB\n+                                \"ld r26,X\"          CR_TAB\n+                                \"mov r27,__tmp_reg__\", op, plen, -6);\n+          else\n+            {\n+              avr_asm_len (\"ld %A0,X+\" CR_TAB\n+                           \"ld %B0,X+\" CR_TAB\n+                           \"ld %C0,X\", op, plen, -3);\n+\n+              if (reg_dest != REG_X - 2\n+                  && !reg_unused_after (insn, base))\n+                {\n+                  avr_asm_len (\"sbiw r26,2\", op, plen, 1);\n+                }\n+\n+              return \"\";\n+            }\n+        }\n+      else /* reg_base != REG_X */\n+        {\n+          if (reg_dest == reg_base)\n+            return avr_asm_len (\"ldd %C0,%1+2\"          CR_TAB\n+                                \"ldd __tmp_reg__,%1+1\"  CR_TAB\n+                                \"ld  %A0,%1\"            CR_TAB\n+                                \"mov %B0,__tmp_reg__\", op, plen, -4);\n+          else\n+            return avr_asm_len (\"ld  %A0,%1\"    CR_TAB\n+                                \"ldd %B0,%1+1\"  CR_TAB\n+                                \"ldd %C0,%1+2\", op, plen, -3);\n+        }\n+    }\n+  else if (GET_CODE (base) == PLUS) /* (R + i) */\n+    {\n+      int disp = INTVAL (XEXP (base, 1));\n+      \n+      if (disp > MAX_LD_OFFSET (GET_MODE (src)))\n+        {\n+          if (REGNO (XEXP (base, 0)) != REG_Y)\n+            fatal_insn (\"incorrect insn:\",insn);\n+\n+          if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (src)))\n+            return avr_asm_len (\"adiw r28,%o1-61\" CR_TAB\n+                                \"ldd %A0,Y+61\"    CR_TAB\n+                                \"ldd %B0,Y+62\"    CR_TAB\n+                                \"ldd %C0,Y+63\"    CR_TAB\n+                                \"sbiw r28,%o1-61\", op, plen, -5);\n+\n+          return avr_asm_len (\"subi r28,lo8(-%o1)\" CR_TAB\n+                              \"sbci r29,hi8(-%o1)\" CR_TAB\n+                              \"ld  %A0,Y\"           CR_TAB\n+                              \"ldd %B0,Y+1\"        CR_TAB\n+                              \"ldd %C0,Y+2\"        CR_TAB\n+                              \"subi r28,lo8(%o1)\"  CR_TAB\n+                              \"sbci r29,hi8(%o1)\", op, plen, -7);\n+        }\n+\n+      reg_base = true_regnum (XEXP (base, 0));\n+      if (reg_base == REG_X)\n+        {\n+          /* R = (X + d) */\n+          if (reg_dest == REG_X)\n+            {\n+              /* \"ld r26,-X\" is undefined */\n+              return avr_asm_len (\"adiw r26,%o1+2\"     CR_TAB\n+                                  \"ld  r28,X\"          CR_TAB\n+                                  \"ld  __tmp_reg__,-X\" CR_TAB\n+                                  \"sbiw r26,1\"         CR_TAB\n+                                  \"ld  r26,X\"          CR_TAB\n+                                  \"mov r27,__tmp_reg__\", op, plen, -6);\n+            }\n+          \n+            avr_asm_len (\"adiw r26,%o1\"      CR_TAB\n+                         \"ld r24,X+\"         CR_TAB\n+                         \"ld r25,X+\"         CR_TAB\n+                         \"ld r26,X\", op, plen, -4);\n+\n+            if (reg_dest != REG_X - 2)\n+              avr_asm_len (\"sbiw r26,%o1+2\", op, plen, 1);\n+\n+            return \"\";\n+        }\n+      \n+      if (reg_dest == reg_base)\n+        return avr_asm_len (\"ldd %C0,%C1\" CR_TAB\n+                            \"ldd __tmp_reg__,%B1\"  CR_TAB\n+                            \"ldd %A0,%A1\" CR_TAB\n+                            \"mov %B0,__tmp_reg__\", op, plen, -4);\n+\n+        return avr_asm_len (\"ldd %A0,%A1\" CR_TAB\n+                            \"ldd %B0,%B1\" CR_TAB\n+                            \"ldd %C0,%C1\", op, plen, -3);\n+    }\n+  else if (GET_CODE (base) == PRE_DEC) /* (--R) */\n+    return avr_asm_len (\"ld %C0,%1\" CR_TAB\n+                        \"ld %B0,%1\" CR_TAB\n+                        \"ld %A0,%1\", op, plen, -3);\n+  else if (GET_CODE (base) == POST_INC) /* (R++) */\n+    return avr_asm_len (\"ld %A0,%1\" CR_TAB\n+                        \"ld %B0,%1\" CR_TAB\n+                        \"ld %C0,%1\", op, plen, -3);\n+\n+  else if (CONSTANT_ADDRESS_P (base))\n+    return avr_asm_len (\"lds %A0,%m1\" CR_TAB\n+                        \"lds %B0,%m1+1\" CR_TAB\n+                        \"lds %C0,%m1+2\", op, plen , -6);\n+  \n+  fatal_insn (\"unknown move insn:\",insn);\n+  return \"\";\n+}\n+\n+/* Handle store of 24-bit type from register or zero to memory.  */\n+\n+static const char*\n+avr_out_store_psi (rtx insn, rtx *op, int *plen)\n+{\n+  rtx dest = op[0];\n+  rtx src = op[1];\n+  rtx base = XEXP (dest, 0);\n+  int reg_base = true_regnum (base);\n+  \n+  if (CONSTANT_ADDRESS_P (base))\n+    return avr_asm_len (\"sts %m0,%A1\"   CR_TAB\n+                        \"sts %m0+1,%B1\" CR_TAB\n+                        \"sts %m0+2,%C1\", op, plen, -6);\n+  \n+  if (reg_base > 0)                 /* (r) */\n+    {\n+      if (reg_base == REG_X)        /* (R26) */\n+        {\n+          gcc_assert (!reg_overlap_mentioned_p (base, src));\n+          \n+          avr_asm_len (\"st %0+,%A1\"  CR_TAB\n+                       \"st %0+,%B1\" CR_TAB\n+                       \"st %0,%C1\", op, plen, -3);\n+\n+          if (!reg_unused_after (insn, base))\n+            avr_asm_len (\"sbiw r26,2\", op, plen, 1);\n+\n+          return \"\";\n+        }\n+      else\n+        return avr_asm_len (\"st %0,%A1\"    CR_TAB\n+                            \"std %0+1,%B1\" CR_TAB\n+                            \"std %0+2,%C1\", op, plen, -3);\n+    }\n+  else if (GET_CODE (base) == PLUS) /* (R + i) */\n+    {\n+      int disp = INTVAL (XEXP (base, 1));\n+      reg_base = REGNO (XEXP (base, 0));\n+\n+      if (disp > MAX_LD_OFFSET (GET_MODE (dest)))\n+        {\n+          if (reg_base != REG_Y)\n+            fatal_insn (\"incorrect insn:\",insn);\n+\n+          if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (dest)))\n+            return avr_asm_len (\"adiw r28,%o0-61\" CR_TAB\n+                                \"std Y+61,%A1\"    CR_TAB\n+                                \"std Y+62,%B1\"    CR_TAB\n+                                \"std Y+63,%C1\"    CR_TAB\n+                                \"sbiw r28,%o0-60\", op, plen, -5);\n+\n+          return avr_asm_len (\"subi r28,lo8(-%o0)\" CR_TAB\n+                              \"sbci r29,hi8(-%o0)\" CR_TAB\n+                              \"st Y,%A1\"           CR_TAB\n+                              \"std Y+1,%B1\"        CR_TAB\n+                              \"std Y+2,%C1\"        CR_TAB\n+                              \"subi r28,lo8(%o0)\"  CR_TAB\n+                              \"sbci r29,hi8(%o0)\", op, plen, -7);\n+        }\n+      if (reg_base == REG_X)\n+        {\n+          /* (X + d) = R */\n+          gcc_assert (!reg_overlap_mentioned_p (XEXP (base, 0), src));\n+          \n+          avr_asm_len (\"adiw r26,%o0\" CR_TAB\n+                       \"st X+,%A1\"    CR_TAB\n+                       \"st X+,%B1\"    CR_TAB\n+                       \"st X,%C1\", op, plen, -4);\n+\n+          if (!reg_unused_after (insn, XEXP (base, 0)))\n+            avr_asm_len (\"sbiw r26,%o0+2\", op, plen, 1);\n+\n+          return \"\";\n+        }\n+      \n+      return avr_asm_len (\"std %A0,%A1\" CR_TAB\n+                          \"std %B0,%B1\" CR_TAB\n+                          \"std %C0,%C1\", op, plen, -3);\n+    }\n+  else if (GET_CODE (base) == PRE_DEC) /* (--R) */\n+    return avr_asm_len (\"st %0,%C1\" CR_TAB\n+                        \"st %0,%B1\" CR_TAB\n+                        \"st %0,%A1\", op, plen, -3);\n+  else if (GET_CODE (base) == POST_INC) /* (R++) */\n+    return avr_asm_len (\"st %0,%A1\" CR_TAB\n+                        \"st %0,%B1\" CR_TAB\n+                        \"st %0,%C1\", op, plen, -3);\n+\n+  fatal_insn (\"unknown move insn:\",insn);\n+  return \"\";\n+}\n+\n+\n+/* Move around 24-bit stuff.  */\n+\n+const char *\n+avr_out_movpsi (rtx insn, rtx *op, int *plen)\n+{\n+  rtx dest = op[0];\n+  rtx src = op[1];\n+  \n+  if (register_operand (dest, VOIDmode))\n+    {\n+      if (register_operand (src, VOIDmode)) /* mov r,r */\n+        {\n+          if (true_regnum (dest) > true_regnum (src))\n+            {\n+              avr_asm_len (\"mov %C0,%C1\", op, plen, -1);\n+\n+              if (AVR_HAVE_MOVW)\n+                return avr_asm_len (\"movw %A0,%A1\", op, plen, 1);\n+              else\n+                return avr_asm_len (\"mov %B0,%B1\"  CR_TAB\n+                                    \"mov %A0,%A1\", op, plen, 2);\n+            }\n+          else\n+            {\n+              if (AVR_HAVE_MOVW)\n+                avr_asm_len (\"movw %A0,%A1\", op, plen, -1);\n+              else\n+                avr_asm_len (\"mov %A0,%A1\"  CR_TAB\n+                             \"mov %B0,%B1\", op, plen, -2);\n+              \n+              return avr_asm_len (\"mov %C0,%C1\", op, plen, 1);\n+            }\n+        }\n+      else if (CONST_INT_P (src))\n+        {\n+          return avr_out_reload_inpsi (op, NULL_RTX, plen);\n+        }\n+      else if (CONSTANT_P (src))\n+        {\n+          if (test_hard_reg_class (LD_REGS, dest)) /* ldi d,i */\n+            {\n+              return avr_asm_len (\"ldi %A0,lo8(%1)\" CR_TAB\n+                                  \"ldi %B0,hi8(%1)\" CR_TAB\n+                                  \"ldi %C0,hh8(%1)\", op, plen, -3);\n+            }\n+          \n+          /* Last resort, better than loading from memory.  */\n+          return avr_asm_len (\"mov __tmp_reg__,r31\" CR_TAB\n+                              \"ldi r31,lo8(%1)\" CR_TAB\n+                              \"mov %A0,r31\"     CR_TAB\n+                              \"ldi r31,hi8(%1)\" CR_TAB\n+                              \"mov %B0,r31\"     CR_TAB\n+                              \"ldi r31,hh8(%1)\" CR_TAB\n+                              \"mov %C0,r31\"     CR_TAB\n+                              \"mov r31,__tmp_reg__\", op, plen, -8);\n+        }\n+      else if (MEM_P (src))\n+        return avr_out_load_psi (insn, op, plen); /* mov r,m */\n+    }\n+  else if (MEM_P (dest))\n+    {\n+      if (src == CONST0_RTX (GET_MODE (dest)))\n+        op[1] = zero_reg_rtx;\n+      \n+      avr_out_store_psi (insn, op, plen);\n+      \n+      op[1] = src;\n+      return \"\";\n+    }\n+    \n+  fatal_insn (\"invalid insn:\", insn);\n+  return \"\";\n+}\n+\n+\n const char *\n out_movqi_mr_r (rtx insn, rtx op[], int *l)\n {\n@@ -3280,22 +3599,24 @@ avr_out_compare (rtx insn, rtx *xop, int *plen)\n           avr_asm_len (\"dec %A0\" CR_TAB\n                        \"or %A0,%B0\", xop, plen, 2);\n           \n-          if (n_bytes == 4)\n-            avr_asm_len (\"or %A0,%C0\" CR_TAB\n-                         \"or %A0,%D0\", xop, plen, 2);\n+          if (n_bytes >= 3)\n+            avr_asm_len (\"or %A0,%C0\", xop, plen, 1);\n+\n+          if (n_bytes >= 4)\n+            avr_asm_len (\"or %A0,%D0\", xop, plen, 1);\n \n           return \"\";\n         }\n       else if (xval == constm1_rtx)\n         {\n-          if (n_bytes == 4)\n-            avr_asm_len (\"and %A0,%D0\" CR_TAB\n-                         \"and %A0,%C0\", xop, plen, 2);\n+          if (n_bytes >= 4)\n+            avr_asm_len (\"and %A0,%D0\", xop, plen, 1);\n           \n-          avr_asm_len (\"and %A0,%B0\" CR_TAB\n-                       \"com %A0\", xop, plen, 2);\n+          if (n_bytes >= 3)\n+            avr_asm_len (\"and %A0,%C0\", xop, plen, 1);\n           \n-          return \"\";\n+          return avr_asm_len (\"and %A0,%B0\" CR_TAB\n+                              \"com %A0\", xop, plen, 2);\n         }\n     }\n \n@@ -3335,8 +3656,7 @@ avr_out_compare (rtx insn, rtx *xop, int *plen)\n               && compare_eq_p (insn)\n               && reg_unused_after (insn, xreg))\n             {\n-              avr_asm_len (\"adiw %0,%n1\", xop, plen, 1);\n-              break;\n+              return avr_asm_len (\"adiw %0,%n1\", xop, plen, 1);\n             }\n         }\n \n@@ -3410,6 +3730,31 @@ avr_out_tsthi (rtx insn, rtx *op, int *plen)\n }\n \n \n+/* Output test instruction for PSImode.  */\n+\n+const char*\n+avr_out_tstpsi (rtx insn, rtx *op, int *plen)\n+{\n+  if (compare_sign_p (insn))\n+    {\n+      avr_asm_len (\"tst %C0\", op, plen, -1);\n+    }\n+  else if (reg_unused_after (insn, op[0])\n+           && compare_eq_p (insn))\n+    {\n+      /* Faster than sbiw if we can clobber the operand.  */\n+      avr_asm_len (\"or %A0,%B0\" CR_TAB\n+                   \"or %A0,%C0\", op, plen, -2);\n+    }\n+  else\n+    {\n+      avr_out_compare (insn, op, plen);\n+    }\n+\n+  return \"\";\n+}\n+\n+\n /* Output test instruction for SImode.  */\n \n const char*\n@@ -3938,6 +4283,69 @@ ashlhi3_out (rtx insn, rtx operands[], int *len)\n }\n \n \n+/* 24-bit shift left */\n+\n+const char*\n+avr_out_ashlpsi3 (rtx insn, rtx *op, int *plen)\n+{\n+  if (plen)\n+    *plen = 0;\n+  \n+  if (CONST_INT_P (op[2]))\n+    {\n+      switch (INTVAL (op[2]))\n+        {\n+        default:\n+          if (INTVAL (op[2]) < 24)\n+            break;\n+\n+          return avr_asm_len (\"clr %A0\" CR_TAB\n+                              \"clr %B0\" CR_TAB\n+                              \"clr %C0\", op, plen, 3);\n+\n+        case 8:\n+          {\n+            int reg0 = REGNO (op[0]);\n+            int reg1 = REGNO (op[1]);\n+            \n+            if (reg0 >= reg1)\n+              return avr_asm_len (\"mov %C0,%B1\"  CR_TAB\n+                                  \"mov %B0,%A1\"  CR_TAB\n+                                  \"clr %A0\", op, plen, 3);\n+            else\n+              return avr_asm_len (\"clr %A0\"      CR_TAB\n+                                  \"mov %B0,%A1\"  CR_TAB\n+                                  \"mov %C0,%B1\", op, plen, 3);\n+          }\n+\n+        case 16:\n+          {\n+            int reg0 = REGNO (op[0]);\n+            int reg1 = REGNO (op[1]);\n+\n+            if (reg0 + 2 != reg1)\n+              avr_asm_len (\"mov %C0,%A0\", op, plen, 1);\n+            \n+            return avr_asm_len (\"clr %B0\"  CR_TAB\n+                                \"clr %A0\", op, plen, 2);\n+          }\n+\n+        case 23:\n+          return avr_asm_len (\"clr %C0\" CR_TAB\n+                              \"lsr %A0\" CR_TAB\n+                              \"ror %C0\" CR_TAB\n+                              \"clr %B0\" CR_TAB\n+                              \"clr %A0\", op, plen, 5);\n+        }\n+    }\n+  \n+  out_shift_with_cnt (\"lsl %A0\" CR_TAB\n+                      \"rol %B0\" CR_TAB\n+                      \"rol %C0\", insn, op, plen, 3);\n+  return \"\";\n+}\n+\n+\n /* 32bit shift left ((long)x << i)   */\n \n const char *\n@@ -4264,6 +4672,65 @@ ashrhi3_out (rtx insn, rtx operands[], int *len)\n }\n \n \n+/* 24-bit arithmetic shift right */\n+\n+const char*\n+avr_out_ashrpsi3 (rtx insn, rtx *op, int *plen)\n+{\n+  int dest = REGNO (op[0]);\n+  int src = REGNO (op[1]);\n+\n+  if (CONST_INT_P (op[2]))\n+    {\n+      if (plen)\n+        *plen = 0;\n+      \n+      switch (INTVAL (op[2]))\n+        {\n+        case 8:\n+          if (dest <= src)\n+            return avr_asm_len (\"mov %A0,%B1\" CR_TAB\n+                                \"mov %B0,%C1\" CR_TAB\n+                                \"clr %C0\"     CR_TAB\n+                                \"sbrc %B0,7\"  CR_TAB\n+                                \"dec %C0\", op, plen, 5);\n+          else\n+            return avr_asm_len (\"clr %C0\"     CR_TAB\n+                                \"sbrc %C1,7\"  CR_TAB\n+                                \"dec %C0\"     CR_TAB\n+                                \"mov %B0,%C1\" CR_TAB\n+                                \"mov %A0,%B1\", op, plen, 5);\n+          \n+        case 16:\n+          if (dest != src + 2)\n+            avr_asm_len (\"mov %A0,%C1\", op, plen, 1);\n+          \n+          return avr_asm_len (\"clr %B0\"     CR_TAB\n+                              \"sbrc %A0,7\"  CR_TAB\n+                              \"com %B0\"     CR_TAB\n+                              \"mov %C0,%B0\", op, plen, 4);\n+\n+        default:\n+          if (INTVAL (op[2]) < 24)\n+            break;\n+\n+          /* fall through */\n+\n+        case 31:\n+          return avr_asm_len (\"lsl %C0\"     CR_TAB\n+                              \"sbc %A0,%A0\" CR_TAB\n+                              \"mov %B0,%A0\" CR_TAB\n+                              \"mov %C0,%A0\", op, plen, 4);\n+        } /* switch */\n+    }\n+  \n+  out_shift_with_cnt (\"asr %C0\" CR_TAB\n+                      \"ror %B0\" CR_TAB\n+                      \"ror %A0\", insn, op, plen, 3);\n+  return \"\";\n+}\n+\n+\n /* 32bit arithmetic shift right  ((signed long)x >> i) */\n \n const char *\n@@ -4714,6 +5181,61 @@ lshrhi3_out (rtx insn, rtx operands[], int *len)\n   return \"\";\n }\n \n+\n+/* 24-bit logic shift right */\n+\n+const char*\n+avr_out_lshrpsi3 (rtx insn, rtx *op, int *plen)\n+{\n+  int dest = REGNO (op[0]);\n+  int src = REGNO (op[1]);\n+\n+  if (CONST_INT_P (op[2]))\n+    {\n+      if (plen)\n+        *plen = 0;\n+      \n+      switch (INTVAL (op[2]))\n+        {\n+        case 8:\n+          if (dest <= src)\n+            return avr_asm_len (\"mov %A0,%B1\" CR_TAB\n+                                \"mov %B0,%C1\" CR_TAB\n+                                \"clr %C0\", op, plen, 3);\n+          else\n+            return avr_asm_len (\"clr %C0\"     CR_TAB\n+                                \"mov %B0,%C1\" CR_TAB\n+                                \"mov %A0,%B1\", op, plen, 3);\n+          \n+        case 16:\n+          if (dest != src + 2)\n+            avr_asm_len (\"mov %A0,%C1\", op, plen, 1);\n+          \n+          return avr_asm_len (\"clr %B0\"  CR_TAB\n+                              \"clr %C0\", op, plen, 2);\n+\n+        default:\n+          if (INTVAL (op[2]) < 24)\n+            break;\n+\n+          /* fall through */\n+\n+        case 23:\n+          return avr_asm_len (\"clr %A0\"    CR_TAB\n+                              \"sbrc %C0,7\" CR_TAB\n+                              \"inc %A0\"    CR_TAB\n+                              \"clr %B0\"    CR_TAB\n+                              \"clr %C0\", op, plen, 5);\n+        } /* switch */\n+    }\n+  \n+  out_shift_with_cnt (\"lsr %C0\" CR_TAB\n+                      \"ror %B0\" CR_TAB\n+                      \"ror %A0\", insn, op, plen, 3);\n+  return \"\";\n+}\n+\n+\n /* 32bit logic shift right ((unsigned int)x >> i) */\n \n const char *\n@@ -4874,7 +5396,9 @@ avr_out_plus_1 (rtx *xop, int *plen, enum rtx_code code, int *pcc)\n       if (i && !started)\n         *pcc = CC_CLOBBER;\n       \n-      if (!started && i % 2 == 0\n+      if (!started\n+          && i % 2 == 0\n+          && i + 2 <= n_bytes\n           && test_hard_reg_class (ADDW_REGS, reg8))\n         {\n           rtx xval16 = simplify_gen_subreg (HImode, xval, mode, i);\n@@ -4911,11 +5435,11 @@ avr_out_plus_1 (rtx *xop, int *plen, enum rtx_code code, int *pcc)\n       else if ((val8 == 1 || val8 == 0xff)\n                && !started\n                && i == n_bytes - 1)\n-      {\n+        {\n           avr_asm_len ((code == PLUS) ^ (val8 == 1) ? \"dec %0\" : \"inc %0\",\n                        op, plen, 1);\n           break;\n-      }\n+        }\n \n       switch (code)\n         {\n@@ -5399,6 +5923,7 @@ adjust_insn_length (rtx insn, int len)\n   switch (adjust_len)\n     {\n     case ADJUST_LEN_RELOAD_IN16: output_reload_inhi (op, op[2], &len); break;\n+    case ADJUST_LEN_RELOAD_IN24: avr_out_reload_inpsi (op, op[2], &len); break;\n     case ADJUST_LEN_RELOAD_IN32: output_reload_insisf (op, op[2], &len); break;\n       \n     case ADJUST_LEN_OUT_BITOP: avr_out_bitop (insn, op, &len); break;\n@@ -5411,9 +5936,11 @@ adjust_insn_length (rtx insn, int len)\n       \n     case ADJUST_LEN_MOV8:  output_movqi (insn, op, &len); break;\n     case ADJUST_LEN_MOV16: output_movhi (insn, op, &len); break;\n+    case ADJUST_LEN_MOV24: avr_out_movpsi (insn, op, &len); break;\n     case ADJUST_LEN_MOV32: output_movsisf (insn, op, &len); break;\n       \n     case ADJUST_LEN_TSTHI: avr_out_tsthi (insn, op, &len); break;\n+    case ADJUST_LEN_TSTPSI: avr_out_tstpsi (insn, op, &len); break;\n     case ADJUST_LEN_TSTSI: avr_out_tstsi (insn, op, &len); break;\n     case ADJUST_LEN_COMPARE: avr_out_compare (insn, op, &len); break;\n \n@@ -5429,6 +5956,10 @@ adjust_insn_length (rtx insn, int len)\n     case ADJUST_LEN_ASHLHI: ashlhi3_out (insn, op, &len); break;\n     case ADJUST_LEN_ASHLSI: ashlsi3_out (insn, op, &len); break;\n       \n+    case ADJUST_LEN_ASHLPSI: avr_out_ashlpsi3 (insn, op, &len); break;\n+    case ADJUST_LEN_ASHRPSI: avr_out_ashrpsi3 (insn, op, &len); break;\n+    case ADJUST_LEN_LSHRPSI: avr_out_lshrpsi3 (insn, op, &len); break;\n+\n     case ADJUST_LEN_CALL: len = AVR_HAVE_JMP_CALL ? 2 : 1; break;\n \n     default:\n@@ -6228,13 +6759,11 @@ avr_rtx_costs_1 (rtx x, int codearg, int outer_code ATTRIBUTE_UNUSED,\n \t  *total = COSTS_N_INSNS (1);\n \t  break;\n \n-\tcase HImode:\n-\t  *total = COSTS_N_INSNS (3);\n-\t  break;\n-\n-\tcase SImode:\n-\t  *total = COSTS_N_INSNS (7);\n-\t  break;\n+        case HImode:\n+        case PSImode:\n+        case SImode:\n+          *total = COSTS_N_INSNS (2 * GET_MODE_SIZE (mode) - 1);\n+          break;\n \n \tdefault:\n \t  return false;\n@@ -6320,6 +6849,19 @@ avr_rtx_costs_1 (rtx x, int codearg, int outer_code ATTRIBUTE_UNUSED,\n \t    *total = COSTS_N_INSNS (2);\n \t  break;\n \n+        case PSImode:\n+          if (!CONST_INT_P (XEXP (x, 1)))\n+            {\n+              *total = COSTS_N_INSNS (3);\n+              *total += avr_operand_rtx_cost (XEXP (x, 1), mode, code, 1,\n+                                              speed);\n+            }\n+          else if (INTVAL (XEXP (x, 1)) >= -63 && INTVAL (XEXP (x, 1)) <= 63)\n+            *total = COSTS_N_INSNS (2);\n+          else\n+            *total = COSTS_N_INSNS (3);\n+          break;\n+\n \tcase SImode:\n \t  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n \t    {\n@@ -6367,6 +6909,7 @@ avr_rtx_costs_1 (rtx x, int codearg, int outer_code ATTRIBUTE_UNUSED,\n             *total = COSTS_N_INSNS (1) + *total;\n           return true;\n         }\n+      /* FALLTHRU */\n     case AND:\n     case IOR:\n       *total = COSTS_N_INSNS (GET_MODE_SIZE (mode));\n@@ -6437,6 +6980,13 @@ avr_rtx_costs_1 (rtx x, int codearg, int outer_code ATTRIBUTE_UNUSED,\n \t    return false;\n \t  break;\n \n+        case PSImode:\n+          if (!speed)\n+            *total = COSTS_N_INSNS (AVR_HAVE_JMP_CALL ? 2 : 1);\n+          else\n+            *total = 10;\n+          break;\n+\n \tcase SImode:\n \t  if (AVR_HAVE_MUL)\n             {\n@@ -6611,6 +7161,31 @@ avr_rtx_costs_1 (rtx x, int codearg, int outer_code ATTRIBUTE_UNUSED,\n \t      }\n \t  break;\n \n+        case PSImode:\n+          if (!CONST_INT_P (XEXP (x, 1)))\n+            {\n+              *total = COSTS_N_INSNS (!speed ? 6 : 73);\n+            }\n+          else\n+            switch (INTVAL (XEXP (x, 1)))\n+              {\n+              case 0:\n+                *total = 0;\n+                break;\n+              case 1:\n+              case 8:\n+              case 16:\n+                *total = COSTS_N_INSNS (3);\n+                break;\n+              case 23:\n+                *total = COSTS_N_INSNS (5);\n+                break;\n+              default:\n+                *total = COSTS_N_INSNS (!speed ? 5 : 3 * INTVAL (XEXP (x, 1)));\n+                break;\n+              }\n+          break;\n+\n \tcase SImode:\n \t  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n \t    {\n@@ -6721,6 +7296,33 @@ avr_rtx_costs_1 (rtx x, int codearg, int outer_code ATTRIBUTE_UNUSED,\n \t      }\n \t  break;\n \n+        case PSImode:\n+          if (!CONST_INT_P (XEXP (x, 1)))\n+            {\n+              *total = COSTS_N_INSNS (!speed ? 6 : 73);\n+            }\n+          else\n+            switch (INTVAL (XEXP (x, 1)))\n+              {\n+              case 0:\n+                *total = 0;\n+                break;\n+              case 1:\n+                *total = COSTS_N_INSNS (3);\n+                break;\n+              case 16:\n+              case 8:\n+                *total = COSTS_N_INSNS (5);\n+                break;\n+              case 23:\n+                *total = COSTS_N_INSNS (4);\n+                break;\n+              default:\n+                *total = COSTS_N_INSNS (!speed ? 5 : 3 * INTVAL (XEXP (x, 1)));\n+                break;\n+              }\n+          break;\n+\n \tcase SImode:\n \t  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n \t    {\n@@ -6832,6 +7434,31 @@ avr_rtx_costs_1 (rtx x, int codearg, int outer_code ATTRIBUTE_UNUSED,\n \t      }\n \t  break;\n \n+        case PSImode:\n+          if (!CONST_INT_P (XEXP (x, 1)))\n+            {\n+              *total = COSTS_N_INSNS (!speed ? 6 : 73);\n+            }\n+          else\n+            switch (INTVAL (XEXP (x, 1)))\n+              {\n+              case 0:\n+                *total = 0;\n+                break;\n+              case 1:\n+              case 8:\n+              case 16:\n+                *total = COSTS_N_INSNS (3);\n+                break;\n+              case 23:\n+                *total = COSTS_N_INSNS (5);\n+                break;\n+              default:\n+                *total = COSTS_N_INSNS (!speed ? 5 : 3 * INTVAL (XEXP (x, 1)));\n+                break;\n+              }\n+          break;\n+\n \tcase SImode:\n \t  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n \t    {\n@@ -6889,6 +7516,12 @@ avr_rtx_costs_1 (rtx x, int codearg, int outer_code ATTRIBUTE_UNUSED,\n \t    *total += COSTS_N_INSNS (1);\n           break;\n \n+        case PSImode:\n+          *total = COSTS_N_INSNS (3);\n+          if (CONST_INT_P (XEXP (x, 1)) && INTVAL (XEXP (x, 1)) != 0)\n+            *total += COSTS_N_INSNS (2);\n+          break;\n+\n         case SImode:\n           *total = COSTS_N_INSNS (4);\n           if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n@@ -7310,8 +7943,10 @@ avr_libcall_value (enum machine_mode mode,\n \t\t   const_rtx func ATTRIBUTE_UNUSED)\n {\n   int offs = GET_MODE_SIZE (mode);\n-  if (offs < 2)\n-    offs = 2;\n+  \n+  if (offs <= 4)\n+    offs = (offs + 1) & ~1;\n+  \n   return gen_rtx_REG (mode, avr_ret_register () + 2 - offs);\n }\n \n@@ -7537,10 +8172,11 @@ output_reload_in_const (rtx *op, rtx clobber_reg, int *len, bool clear_p)\n   /* (REG:SI 14) is special: It's neither in LD_REGS nor in NO_LD_REGS\n      but has some subregs that are in LD_REGS.  Use the MSB (REG:QI 17).  */\n   \n-  if (14 == REGNO (dest)\n-      && 4 == GET_MODE_SIZE (mode))\n+  if (REGNO (dest) < 16\n+      && REGNO (dest) + GET_MODE_SIZE (mode) > 16)\n     {\n-      clobber_reg = gen_rtx_REG (QImode, 17);\n+      clobber_reg = gen_rtx_REG (QImode,\n+                                 REGNO (dest) + GET_MODE_SIZE (mode) - 1);\n     }\n \n   /* We might need a clobber reg but don't have one.  Look at the value\n@@ -7577,6 +8213,7 @@ output_reload_in_const (rtx *op, rtx clobber_reg, int *len, bool clear_p)\n       /* Look if we can reuse the low word by means of MOVW.  */\n       \n       if (n == 2\n+          && GET_MODE_SIZE (mode) >= 4\n           && AVR_HAVE_MOVW)\n         {\n           rtx lo16 = simplify_gen_subreg (HImode, src, mode, 0);\n@@ -7820,6 +8457,16 @@ output_reload_insisf (rtx *op, rtx clobber_reg, int *len)\n   return \"\";\n }\n \n+const char *\n+avr_out_reload_inpsi (rtx *op, rtx clobber_reg, int *len)\n+{\n+  gcc_assert (REG_P (op[0])\n+              && CONST_INT_P (op[1]));\n+\n+  output_reload_in_const (op, clobber_reg, len, false);\n+  return \"\";\n+}\n+\n void\n avr_output_bld (rtx operands[], int bit_nr)\n {\n@@ -8078,6 +8725,16 @@ enum avr_builtin_id\n     AVR_BUILTIN_DELAY_CYCLES\n   };\n \n+static void\n+avr_init_builtin_int24 (void)\n+{\n+  tree int24_type  = make_signed_type (GET_MODE_BITSIZE (PSImode));\n+  tree uint24_type = make_unsigned_type (GET_MODE_BITSIZE (PSImode));\n+\n+  (*lang_hooks.types.register_builtin_type) (int24_type, \"__int24\");\n+  (*lang_hooks.types.register_builtin_type) (uint24_type, \"__uint24\");\n+}\n+\n #define DEF_BUILTIN(NAME, TYPE, CODE)                                   \\\n   do                                                                    \\\n     {                                                                   \\\n@@ -8133,6 +8790,8 @@ avr_init_builtins (void)\n                AVR_BUILTIN_FMULS);\n   DEF_BUILTIN (\"__builtin_avr_fmulsu\", int_ftype_char_uchar, \n                AVR_BUILTIN_FMULSU);\n+\n+  avr_init_builtin_int24 ();\n }\n \n #undef DEF_BUILTIN"}, {"sha": "12e94850c954e7fa61ef4a21fcc260424066782a", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 512, "deletions": 65, "changes": 577, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4fe948a6e9049df934677fc95d78b11c5cff4bd/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4fe948a6e9049df934677fc95d78b11c5cff4bd/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=e4fe948a6e9049df934677fc95d78b11c5cff4bd", "patch": "@@ -125,11 +125,12 @@\n \n (define_attr \"adjust_len\"\n   \"out_bitop, out_plus, out_plus_noclobber, addto_sp,\n-   tsthi, tstsi, compare, call,\n-   mov8, mov16, mov32, reload_in16, reload_in32,\n+   tsthi, tstpsi, tstsi, compare, call,\n+   mov8, mov16, mov24, mov32, reload_in16, reload_in24, reload_in32,\n    ashlqi, ashrqi, lshrqi,\n    ashlhi, ashrhi, lshrhi,\n    ashlsi, ashrsi, lshrsi,\n+   ashlpsi, ashrpsi, lshrpsi,\n    no\"\n   (const_string \"no\"))\n \n@@ -180,10 +181,13 @@\n ;; Define mode iterators\n (define_mode_iterator QIHI  [(QI \"\") (HI \"\")])\n (define_mode_iterator QIHI2 [(QI \"\") (HI \"\")])\n-(define_mode_iterator QISI [(QI \"\") (HI \"\") (SI \"\")])\n-(define_mode_iterator QIDI [(QI \"\") (HI \"\") (SI \"\") (DI \"\")])\n-(define_mode_iterator HIDI [(HI \"\") (SI \"\") (DI \"\")])\n-(define_mode_iterator HISI [(HI \"\") (SI \"\")])\n+(define_mode_iterator QISI [(QI \"\") (HI \"\") (PSI \"\") (SI \"\")])\n+(define_mode_iterator QIDI [(QI \"\") (HI \"\") (PSI \"\") (SI \"\") (DI \"\")])\n+(define_mode_iterator HIDI [(HI \"\") (PSI \"\") (SI \"\") (DI \"\")])\n+(define_mode_iterator HISI [(HI \"\") (PSI \"\") (SI \"\")])\n+\n+;; All supported move-modes\n+(define_mode_iterator MOVMODE [(QI \"\") (HI \"\") (SI \"\") (SF \"\") (PSI \"\")])\n \n ;; Define code iterators\n ;; Define two incarnations so that we can build the cross product.\n@@ -279,6 +283,7 @@\n (define_mode_iterator MPUSH\n   [(CQI \"\")\n    (HI \"\") (CHI \"\")\n+   (PSI \"\")\n    (SI \"\") (CSI \"\")\n    (DI \"\") (CDI \"\")\n    (SF \"\") (SC \"\")])\n@@ -309,6 +314,28 @@\n   [(set (reg:HI REG_SP) (reg:HI REG_Y))]\n   \"\")\n \n+;;========================================================================\n+\n+;; \"movqi\"\n+;; \"movhi\"\n+;; \"movsi\"\n+;; \"movsf\"\n+;; \"movpsi\"\n+\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:MOVMODE 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:MOVMODE 1 \"general_operand\" \"\"))]\n+  \"\"\n+  {\n+    /* One of the ops has to be in a register.  */\n+    if (!register_operand (operands[0], <MODE>mode)\n+        && !(register_operand (operands[1], <MODE>mode)\n+             || CONST0_RTX (<MODE>mode) == operands[1]))\n+      {\n+        operands[1] = copy_to_mode_reg (<MODE>mode, operands[1]);\n+      }\n+  })\n+\n ;;========================================================================\n ;; move byte\n ;; The last alternative (any immediate constant to any register) is\n@@ -318,16 +345,6 @@\n ;; are call-saved registers, and most of LD_REGS are call-used registers,\n ;; so this may still be a win for registers live across function calls.\n \n-(define_expand \"movqi\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:QI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"/* One of the ops has to be in a register.  */\n-   if (!register_operand(operand0, QImode)\n-       && ! (register_operand(operand1, QImode) || const0_rtx == operand1))\n-       operands[1] = copy_to_mode_reg(QImode, operand1);\n-  \")\n-\n (define_insn \"movqi_insn\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,d,Qm,r,q,r,*r\")\n \t(match_operand:QI 1 \"general_operand\"       \"rL,i,rL,Qm,r,q,i\"))]\n@@ -365,21 +382,6 @@\n ;;============================================================================\n ;; move word (16 bit)\n \n-(define_expand \"movhi\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n-        (match_operand:HI 1 \"general_operand\"       \"\"))]\n-  \"\"\n-  \"\n-{\n-   /* One of the ops has to be in a register.  */\n-  if (!register_operand(operand0, HImode)\n-      && !(register_operand(operand1, HImode) || const0_rtx == operands[1]))\n-    {\n-      operands[1] = copy_to_mode_reg(HImode, operand1);\n-    }\n-}\")\n-\n-\n ;; Move register $1 to the Stack Pointer register SP.\n ;; This insn is emit during function prologue/epilogue generation.\n ;;    $2 = 0: We know that IRQs are off\n@@ -461,23 +463,48 @@\n   })\n \n ;;==========================================================================\n-;; move double word (32 bit)\n-\n-(define_expand \"movsi\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n-        (match_operand:SI 1 \"general_operand\"  \"\"))]\n-  \"\"\n-  \"\n-{\n-  /* One of the ops has to be in a register.  */\n-  if (!register_operand (operand0, SImode)\n-      && !(register_operand (operand1, SImode) || const0_rtx == operand1))\n-    {\n-      operands[1] = copy_to_mode_reg (SImode, operand1);\n-    }\n-}\")\n-\n+;; xpointer move (24 bit)\n+  \n+(define_peephole2 ; *reload_inpsi\n+  [(match_scratch:QI 2 \"d\")\n+   (set (match_operand:PSI 0 \"l_register_operand\" \"\")\n+        (match_operand:PSI 1 \"immediate_operand\" \"\"))\n+   (match_dup 2)]\n+  \"operands[1] != const0_rtx\n+   && operands[1] != constm1_rtx\"\n+  [(parallel [(set (match_dup 0)\n+                   (match_dup 1))\n+\t      (clobber (match_dup 2))])]\n+  \"\")\n+  \n+;; '*' because it is not used in rtl generation.\n+(define_insn \"*reload_inpsi\"\n+  [(set (match_operand:PSI 0 \"register_operand\" \"=r\")\n+        (match_operand:PSI 1 \"immediate_operand\" \"i\"))\n+   (clobber (match_operand:QI 2 \"register_operand\" \"=&d\"))]\n+  \"reload_completed\"\n+  {\n+    return avr_out_reload_inpsi (operands, operands[2], NULL);\n+  }\n+  [(set_attr \"length\" \"6\")\n+   (set_attr \"adjust_len\" \"reload_in24\")\n+   (set_attr \"cc\" \"clobber\")])\n \n+(define_insn \"*movpsi\"\n+  [(set (match_operand:PSI 0 \"nonimmediate_operand\" \"=r,r,r ,Qm,!d,r\")\n+        (match_operand:PSI 1 \"general_operand\"       \"r,L,Qm,rL,i ,i\"))]\n+  \"register_operand (operands[0], PSImode)\n+   || register_operand (operands[1], PSImode)\n+   || const0_rtx == operands[1]\"\n+  {\n+    return avr_out_movpsi (insn, operands, NULL);\n+  }\n+  [(set_attr \"length\" \"3,3,8,9,4,10\")\n+   (set_attr \"adjust_len\" \"mov24\")\n+   (set_attr \"cc\" \"none,set_zn,clobber,clobber,clobber,clobber\")])\n+  \n+;;==========================================================================\n+;; move double word (32 bit)\n \n (define_peephole2 ; *reload_insi\n   [(match_scratch:QI 2 \"d\")\n@@ -519,20 +546,6 @@\n ;; fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n ;; move floating point numbers (32 bit)\n \n-(define_expand \"movsf\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n-        (match_operand:SF 1 \"general_operand\"  \"\"))]\n-  \"\"\n-  \"\n-{\n-  /* One of the ops has to be in a register.  */\n-  if (!register_operand (operand1, SFmode)\n-      && !register_operand (operand0, SFmode))\n-    {\n-      operands[1] = copy_to_mode_reg (SFmode, operand1);\n-    }\n-}\")\n-\n (define_insn \"*movsf\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,r,Qm,!d,r\")\n         (match_operand:SF 1 \"general_operand\"       \"r,G,Qm,rG,F,F\"))]\n@@ -914,6 +927,33 @@\n    (set_attr \"adjust_len\" \"*,*,out_plus,out_plus\")\n    (set_attr \"cc\" \"set_n,set_czn,out_plus,out_plus\")])\n \n+(define_insn \"*addpsi3_zero_extend.qi\"\n+  [(set (match_operand:PSI 0 \"register_operand\"                          \"=r\")\n+        (plus:PSI (zero_extend:PSI (match_operand:QI 1 \"register_operand\" \"r\"))\n+                  (match_operand:PSI 2 \"register_operand\"                 \"0\")))]\n+  \"\"\n+  \"add %A0,%A1\\;adc %B0,__zero_reg__\\;adc %C0,__zero_reg__\"\n+  [(set_attr \"length\" \"3\")\n+   (set_attr \"cc\" \"set_n\")])\n+\n+(define_insn \"*addpsi3_zero_extend.hi\"\n+  [(set (match_operand:PSI 0 \"register_operand\"                          \"=r\")\n+        (plus:PSI (zero_extend:PSI (match_operand:HI 1 \"register_operand\" \"r\"))\n+                  (match_operand:PSI 2 \"register_operand\"                 \"0\")))]\n+  \"\"\n+  \"add %A0,%A1\\;adc %B0,%B1\\;adc %C0,__zero_reg__\"\n+  [(set_attr \"length\" \"3\")\n+   (set_attr \"cc\" \"set_n\")])\n+\n+(define_insn \"*addpsi3_sign_extend.hi\"\n+  [(set (match_operand:PSI 0 \"register_operand\"                          \"=r\")\n+        (plus:PSI (sign_extend:PSI (match_operand:HI 1 \"register_operand\" \"r\"))\n+                  (match_operand:PSI 2 \"register_operand\"                 \"0\")))]\n+  \"\"\n+  \"add %A0,%1\\;adc %B0,%B1\\;adc %C0,__zero_reg__\\;sbrc %B1,7\\;dec %C0\"\n+  [(set_attr \"length\" \"5\")\n+   (set_attr \"cc\" \"set_n\")])\n+\n (define_insn \"*addsi3_zero_extend\"\n   [(set (match_operand:SI 0 \"register_operand\"                         \"=r\")\n         (plus:SI (zero_extend:SI (match_operand:QI 1 \"register_operand\" \"r\"))\n@@ -932,6 +972,66 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"set_n\")])\n \n+(define_insn \"addpsi3\"\n+  [(set (match_operand:PSI 0 \"register_operand\"           \"=r,d ,d,r\")\n+        (plus:PSI (match_operand:PSI 1 \"register_operand\" \"%0,0 ,0,0\")\n+                  (match_operand:PSI 2 \"nonmemory_operand\" \"r,s ,n,n\")))\n+   (clobber (match_scratch:QI 3                           \"=X,X ,X,&d\"))]\n+  \"\"\n+  {\n+    static const char * const asm_code[] =\n+      {\n+        \"add %A0,%A2\\;adc %B0,%B2\\;adc %C0,%C2\",\n+        \"subi %0,lo8(-(%2))\\;sbci %B0,hi8(-(%2))\\;sbci %C0,hlo8(-(%2))\",\n+        \"\",\n+        \"\"\n+      };\n+\n+    if (*asm_code[which_alternative])\n+      return asm_code [which_alternative];\n+\n+    return avr_out_plus (operands, NULL, NULL);\n+  }\n+  [(set_attr \"length\" \"3,3,3,6\")\n+   (set_attr \"adjust_len\" \"*,*,out_plus,out_plus\")\n+   (set_attr \"cc\" \"set_n,set_czn,out_plus,out_plus\")])\n+\n+(define_insn \"subpsi3\"\n+  [(set (match_operand:PSI 0 \"register_operand\"           \"=r\")\n+        (minus:PSI (match_operand:PSI 1 \"register_operand\" \"0\")\n+                   (match_operand:PSI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"sub %0,%2\\;sbc %B0,%B2\\;sbc %C0,%C2\"\n+  [(set_attr \"length\" \"3\")\n+   (set_attr \"cc\" \"set_czn\")])\n+\n+(define_insn \"*subpsi3_zero_extend.qi\"\n+  [(set (match_operand:PSI 0 \"register_operand\"                           \"=r\")\n+        (minus:PSI (match_operand:SI 1 \"register_operand\"                  \"0\")\n+                   (zero_extend:PSI (match_operand:QI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"sub %A0,%2\\;sbc %B0,__zero_reg__\\;sbc %C0,__zero_reg__\"\n+  [(set_attr \"length\" \"3\")\n+   (set_attr \"cc\" \"set_czn\")])\n+\n+(define_insn \"*subpsi3_zero_extend.hi\"\n+  [(set (match_operand:PSI 0 \"register_operand\"                           \"=r\")\n+        (minus:PSI (match_operand:PSI 1 \"register_operand\"                 \"0\")\n+                   (zero_extend:PSI (match_operand:HI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"sub %A0,%2\\;sbc %B0,%B2\\;sbc %C0,__zero_reg__\"\n+  [(set_attr \"length\" \"3\")\n+   (set_attr \"cc\" \"set_czn\")])\n+\n+(define_insn \"*subpsi3_sign_extend.hi\"\n+  [(set (match_operand:PSI 0 \"register_operand\"                           \"=r\")\n+        (minus:PSI (match_operand:PSI 1 \"register_operand\"                 \"0\")\n+                   (sign_extend:PSI (match_operand:HI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"sub %A0,%A2\\;sbc %B0,%B2\\;sbc %C0,__zero_reg__\\;sbrc %B2,7\\;inc %C0\"\n+  [(set_attr \"length\" \"5\")\n+   (set_attr \"cc\" \"set_czn\")])\n+\n ;-----------------------------------------------------------------------------\n ; sub bytes\n (define_insn \"subqi3\"\n@@ -1099,6 +1199,17 @@\n   [(set_attr \"length\" \"2,3\")\n    (set_attr \"cc\" \"clobber\")])\n \n+(define_insn \"*addpsi3.lt0\"\n+  [(set (match_operand:PSI 0 \"register_operand\"                         \"=r\")\n+        (plus:PSI (lshiftrt:PSI (match_operand:PSI 1 \"register_operand\"  \"r\")\n+                                (const_int 23))\n+                 (match_operand:PSI 2 \"register_operand\"                 \"0\")))]\n+  \"\"\n+  \"mov __tmp_reg__,%C1\\;lsl __tmp_reg__\n+\tadc %A0,__zero_reg__\\;adc %B0,__zero_reg__\\;adc %C0,__zero_reg__\"\n+  [(set_attr \"length\" \"5\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n (define_insn \"*addsi3.lt0\"\n   [(set (match_operand:SI 0 \"register_operand\"                       \"=r\")\n         (plus:SI (lshiftrt:SI (match_operand:SI 1 \"register_operand\"  \"r\")\n@@ -2062,7 +2173,7 @@\n ; / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % / %\n ; divmod\n \n-;; Generate libgcc.S calls ourselves, because:\n+;; Generate lib1funcs.S calls ourselves, because:\n ;;  - we know exactly which registers are clobbered (for QI and HI\n ;;    modes, some of the call-used registers are preserved)\n ;;  - we get both the quotient and the remainder at no extra cost\n@@ -2199,6 +2310,80 @@\n   [(set_attr \"type\" \"xcall\")\n    (set_attr \"cc\" \"clobber\")])\n \n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; 24-bit signed/unsigned division and modulo.\n+;; Notice that the libgcc implementation return the quotient in R22\n+;; and the remainder in R18 whereas the 32-bit [u]divmodsi4\n+;; implementation works the other way round.\n+\n+(define_insn_and_split \"divmodpsi4\"\n+  [(parallel [(set (match_operand:PSI 0 \"pseudo_register_operand\" \"\")\n+                   (div:PSI (match_operand:PSI 1 \"pseudo_register_operand\" \"\")\n+                            (match_operand:PSI 2 \"pseudo_register_operand\" \"\")))\n+              (set (match_operand:PSI 3 \"pseudo_register_operand\" \"\")\n+                   (mod:PSI (match_dup 1)\n+                            (match_dup 2)))\n+              (clobber (reg:DI 18))\n+              (clobber (reg:QI 26))])]\n+  \"\"\n+  { gcc_unreachable(); }\n+  \"\"\n+  [(set (reg:PSI 22) (match_dup 1))\n+   (set (reg:PSI 18) (match_dup 2))\n+   (parallel [(set (reg:PSI 22) (div:PSI (reg:PSI 22) (reg:PSI 18)))\n+              (set (reg:PSI 18) (mod:PSI (reg:PSI 22) (reg:PSI 18)))\n+              (clobber (reg:QI 21))\n+              (clobber (reg:QI 25))\n+              (clobber (reg:QI 26))])\n+   (set (match_dup 0) (reg:PSI 22))\n+   (set (match_dup 3) (reg:PSI 18))])\n+\n+(define_insn \"*divmodpsi4_call\"\n+  [(set (reg:PSI 22) (div:PSI (reg:PSI 22) (reg:PSI 18)))\n+   (set (reg:PSI 18) (mod:PSI (reg:PSI 22) (reg:PSI 18)))\n+   (clobber (reg:QI 21))\n+   (clobber (reg:QI 25))\n+   (clobber (reg:QI 26))]\n+  \"\"\n+  \"%~call __divmodpsi4\"\n+  [(set_attr \"type\" \"xcall\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn_and_split \"udivmodpsi4\"\n+  [(parallel [(set (match_operand:PSI 0 \"pseudo_register_operand\" \"\")\n+                   (udiv:PSI (match_operand:PSI 1 \"pseudo_register_operand\" \"\")\n+                             (match_operand:PSI 2 \"pseudo_register_operand\" \"\")))\n+              (set (match_operand:PSI 3 \"pseudo_register_operand\" \"\")\n+                   (umod:PSI (match_dup 1)\n+                             (match_dup 2)))\n+              (clobber (reg:DI 18))\n+              (clobber (reg:QI 26))])]\n+  \"\"\n+  { gcc_unreachable(); }\n+  \"\"\n+  [(set (reg:PSI 22) (match_dup 1))\n+   (set (reg:PSI 18) (match_dup 2))\n+   (parallel [(set (reg:PSI 22) (udiv:PSI (reg:PSI 22) (reg:PSI 18)))\n+              (set (reg:PSI 18) (umod:PSI (reg:PSI 22) (reg:PSI 18)))\n+              (clobber (reg:QI 21))\n+              (clobber (reg:QI 25))\n+              (clobber (reg:QI 26))])\n+   (set (match_dup 0) (reg:PSI 22))\n+   (set (match_dup 3) (reg:PSI 18))])\n+\n+(define_insn \"*udivmodpsi4_call\"\n+  [(set (reg:PSI 22) (udiv:PSI (reg:PSI 22) (reg:PSI 18)))\n+   (set (reg:PSI 18) (umod:PSI (reg:PSI 22) (reg:PSI 18)))\n+   (clobber (reg:QI 21))\n+   (clobber (reg:QI 25))\n+   (clobber (reg:QI 26))]\n+  \"\"\n+  \"%~call __udivmodpsi4\"\n+  [(set_attr \"type\" \"xcall\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n (define_insn_and_split \"divmodsi4\"\n   [(parallel [(set (match_operand:SI 0 \"pseudo_register_operand\" \"\") \n                    (div:SI (match_operand:SI 1 \"pseudo_register_operand\" \"\") \n@@ -2297,6 +2482,24 @@\n    (set_attr \"adjust_len\" \"*,*,out_bitop,out_bitop,out_bitop\")\n    (set_attr \"cc\" \"set_n,set_n,clobber,clobber,clobber\")])\n \n+(define_insn \"andpsi3\"\n+  [(set (match_operand:PSI 0 \"register_operand\"          \"=r,d,r  ,r\")\n+        (and:PSI (match_operand:PSI 1 \"register_operand\" \"%0,0,0  ,0\")\n+                 (match_operand:PSI 2 \"nonmemory_operand\" \"r,n,Ca3,n\")))\n+   (clobber (match_scratch:QI 3                          \"=X,X,X  ,&d\"))]\n+  \"\"\n+  {\n+    if (which_alternative == 0)\n+      return \"and %A0,%A2\" CR_TAB\n+             \"and %B0,%B2\" CR_TAB\n+             \"and %C0,%C2\";\n+\n+    return avr_out_bitop (insn, operands, NULL);\n+  }\n+  [(set_attr \"length\" \"3,3,6,6\")\n+   (set_attr \"adjust_len\" \"*,out_bitop,out_bitop,out_bitop\")\n+   (set_attr \"cc\" \"set_n,clobber,clobber,clobber\")])\n+\n (define_insn \"andsi3\"\n   [(set (match_operand:SI 0 \"register_operand\"         \"=r,d,r  ,r\")\n         (and:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0  ,0\")\n@@ -2361,6 +2564,24 @@\n    (set_attr \"adjust_len\" \"*,*,out_bitop,out_bitop,out_bitop\")\n    (set_attr \"cc\" \"set_n,set_n,clobber,clobber,clobber\")])\n \n+(define_insn \"iorpsi3\"\n+  [(set (match_operand:PSI 0 \"register_operand\"          \"=r,d,r  ,r\")\n+        (ior:PSI (match_operand:PSI 1 \"register_operand\" \"%0,0,0  ,0\")\n+                 (match_operand:PSI 2 \"nonmemory_operand\" \"r,n,Co3,n\")))\n+   (clobber (match_scratch:QI 3                          \"=X,X,X  ,&d\"))]\n+  \"\"\n+  {\n+    if (which_alternative == 0)\n+      return \"or %A0,%A2\" CR_TAB\n+             \"or %B0,%B2\" CR_TAB\n+             \"or %C0,%C2\";\n+\n+    return avr_out_bitop (insn, operands, NULL);\n+  }\n+  [(set_attr \"length\" \"3,3,6,6\")\n+   (set_attr \"adjust_len\" \"*,out_bitop,out_bitop,out_bitop\")\n+   (set_attr \"cc\" \"set_n,clobber,clobber,clobber\")])\n+\n (define_insn \"iorsi3\"\n   [(set (match_operand:SI 0 \"register_operand\"         \"=r,d,r  ,r\")\n         (ior:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0  ,0\")\n@@ -2408,6 +2629,24 @@\n    (set_attr \"adjust_len\" \"*,out_bitop,out_bitop\")\n    (set_attr \"cc\" \"set_n,clobber,clobber\")])\n \n+(define_insn \"xorpsi3\"\n+  [(set (match_operand:PSI 0 \"register_operand\"          \"=r,r  ,r\")\n+        (xor:PSI (match_operand:PSI 1 \"register_operand\" \"%0,0  ,0\")\n+                 (match_operand:PSI 2 \"nonmemory_operand\" \"r,Cx3,n\")))\n+   (clobber (match_scratch:QI 3                          \"=X,X  ,&d\"))]\n+  \"\"\n+  {\n+    if (which_alternative == 0)\n+      return \"eor %A0,%A2\" CR_TAB\n+             \"eor %B0,%B2\" CR_TAB\n+             \"eor %C0,%C2\";\n+\n+    return avr_out_bitop (insn, operands, NULL);\n+  }\n+  [(set_attr \"length\" \"3,6,6\")\n+   (set_attr \"adjust_len\" \"*,out_bitop,out_bitop\")\n+   (set_attr \"cc\" \"set_n,clobber,clobber\")])\n+\n (define_insn \"xorsi3\"\n   [(set (match_operand:SI 0 \"register_operand\"         \"=r,r  ,r\")\n         (xor:SI (match_operand:SI 1 \"register_operand\" \"%0,0  ,0\")\n@@ -2472,10 +2711,11 @@\n ;; HImode does not need scratch.  Use attribute for this constraint.\n ;; Use QI scratch for DI mode as this is often split into byte sized operands.\n \n-(define_mode_attr rotx [(DI \"&r,&r,X\") (SI \"&r,&r,X\") (HI \"X,X,X\")])\n-(define_mode_attr rotsmode [(DI \"QI\") (SI \"HI\") (HI \"QI\")])\n+(define_mode_attr rotx [(DI \"&r,&r,X\") (SI \"&r,&r,X\") (PSI \"&r,&r,X\") (HI \"X,X,X\")])\n+(define_mode_attr rotsmode [(DI \"QI\") (SI \"HI\") (PSI \"QI\") (HI \"QI\")])\n \n ;; \"rotlhi3\"\n+;; \"rotlpsi3\"\n ;; \"rotlsi3\"\n ;; \"rotldi3\"\n (define_expand \"rotl<mode>3\"\n@@ -2531,6 +2771,24 @@\n   [(set_attr \"length\" \"3\")\n    (set_attr \"cc\" \"clobber\")])\n \n+(define_insn \"*rotlpsi2.1\"\n+  [(set (match_operand:PSI 0 \"register_operand\"            \"=r\")\n+        (rotate:PSI (match_operand:PSI 1 \"register_operand\" \"0\")\n+                    (const_int 1)))]\n+  \"\"\n+  \"lsl %A0\\;rol %B0\\;rol %C0\\;adc %A0,__zero_reg__\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"*rotlpsi2.23\"\n+  [(set (match_operand:PSI 0 \"register_operand\"            \"=r\")\n+        (rotate:PSI (match_operand:PSI 1 \"register_operand\" \"0\")\n+                    (const_int 23)))]\n+  \"\"\n+  \"bst %A0,0\\;ror %C0\\;ror %B0\\;ror %A0\\;bld %C0,7\"\n+  [(set_attr \"length\" \"5\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n (define_insn \"*rotlsi2.1\"\n   [(set (match_operand:SI 0 \"register_operand\"           \"=r\")\n         (rotate:SI (match_operand:SI 1 \"register_operand\" \"0\")\n@@ -2567,6 +2825,7 @@\n    (clobber (match_scratch:<rotsmode> 3 \"=<rotx>\"))]\n   \"AVR_HAVE_MOVW\n    && CONST_INT_P (operands[2])\n+   && GET_MODE_SIZE (<MODE>mode) % 2 == 0\n    && 0 == INTVAL (operands[2]) % 16\"\n   \"#\"\n   \"&& (reload_completed || <MODE>mode == DImode)\"\n@@ -2580,6 +2839,7 @@\n ;; Split byte aligned rotates using scratch that is always QI mode.\n \n ;; \"*rotbhi\"\n+;; \"*rotbpsi\"\n ;; \"*rotbsi\"\n ;; \"*rotbdi\"\n (define_insn_and_split \"*rotb<mode>\"\n@@ -2589,7 +2849,8 @@\n    (clobber (match_scratch:QI 3 \"=<rotx>\"))]\n   \"CONST_INT_P (operands[2])\n    && (8 == INTVAL (operands[2]) % 16\n-       || (!AVR_HAVE_MOVW\n+       || ((!AVR_HAVE_MOVW\n+            || GET_MODE_SIZE (<MODE>mode) % 2 != 0)\n            && 0 == INTVAL (operands[2]) % 16))\"\n   \"#\"\n   \"&& (reload_completed || <MODE>mode == DImode)\"\n@@ -2830,6 +3091,18 @@\n    (set_attr \"adjust_len\" \"ashlsi\")\n    (set_attr \"cc\" \"none,set_n,clobber,clobber\")])\n \n+(define_insn \"ashlpsi3\"\n+  [(set (match_operand:PSI 0 \"register_operand\"             \"=r,r,r,r\")\n+        (ashift:PSI (match_operand:PSI 1 \"register_operand\"  \"0,0,r,0\")\n+                    (match_operand:QI 2 \"nonmemory_operand\"  \"r,P,O,n\")))\n+   (clobber (match_scratch:QI 3                             \"=X,X,X,&d\"))]\n+  \"\"\n+  {\n+    return avr_out_ashlpsi3 (insn, operands, NULL);\n+  }\n+  [(set_attr \"adjust_len\" \"ashlpsi\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n ;; >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>\n ;; arithmetic shift right\n \n@@ -2853,6 +3126,18 @@\n    (set_attr \"adjust_len\" \"ashrhi\")\n    (set_attr \"cc\" \"clobber,none,clobber,set_n,clobber,clobber,clobber\")])\n \n+(define_insn \"ashrpsi3\"\n+  [(set (match_operand:PSI 0 \"register_operand\"                 \"=r,r,r,r,r\")\n+        (ashiftrt:PSI (match_operand:PSI 1 \"register_operand\"    \"0,0,0,r,0\")\n+                      (match_operand:QI 2 \"nonmemory_operand\"    \"r,P,K,O,n\")))\n+   (clobber (match_scratch:QI 3                                 \"=X,X,X,X,&d\"))]\n+  \"\"\n+  {\n+    return avr_out_ashrpsi3 (insn, operands, NULL);\n+  }\n+  [(set_attr \"adjust_len\" \"ashrpsi\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n (define_insn \"ashrsi3\"\n   [(set (match_operand:SI 0 \"register_operand\"             \"=r,r,r,r,r,r,r\")\n \t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0,0,0,r,0,0,0\")\n@@ -2966,6 +3251,18 @@\n    (set_attr \"adjust_len\" \"lshrhi\")\n    (set_attr \"cc\" \"clobber,none,clobber,clobber,clobber,clobber,clobber\")])\n \n+(define_insn \"lshrpsi3\"\n+  [(set (match_operand:PSI 0 \"register_operand\"                 \"=r,r,r,r,r\")\n+        (lshiftrt:PSI (match_operand:PSI 1 \"register_operand\"    \"0,0,r,0,0\")\n+                      (match_operand:QI 2 \"nonmemory_operand\"    \"r,P,O,K,n\")))\n+   (clobber (match_scratch:QI 3                                 \"=X,X,X,X,&d\"))]\n+  \"\"\n+  {\n+    return avr_out_lshrpsi3 (insn, operands, NULL);\n+  }\n+  [(set_attr \"adjust_len\" \"lshrpsi\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n (define_insn \"lshrsi3\"\n   [(set (match_operand:SI 0 \"register_operand\"             \"=r,r,r,r,r,r,r\")\n \t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0,0,0,r,0,0,0\")\n@@ -3100,6 +3397,17 @@\n   [(set_attr \"length\" \"3,4,4\")\n    (set_attr \"cc\" \"set_czn,set_n,set_czn\")])\n \n+(define_insn \"negpsi2\"\n+  [(set (match_operand:PSI 0 \"register_operand\"        \"=!d,r,&r\")\n+        (neg:PSI (match_operand:PSI 1 \"register_operand\" \"0,0,r\")))]\n+  \"\"\n+  \"@\n+\tcom %C0\\;com %B0\\;neg %A0\\;sbci %B0,-1\\;sbci %C0,-1\n+\tcom %C0\\;com %B0\\;com %A0\\;adc %A0,__zero_reg__\\;adc %B0,__zero_reg__\\;adc %C0,__zero_reg__\n+\tclr %A0\\;clr %B0\\;clr %C0\\;sub %A0,%A1\\;sbc %B0,%B1\\;sbc %C0,%C1\"\n+  [(set_attr \"length\" \"5,6,6\")\n+   (set_attr \"cc\" \"set_czn,set_n,set_czn\")])\n+\n (define_insn \"negsi2\"\n   [(set (match_operand:SI 0 \"register_operand\"       \"=!d,r,&r,&r\")\n         (neg:SI (match_operand:SI 1 \"register_operand\" \"0,0,r ,r\")))]\n@@ -3143,6 +3451,14 @@\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set_n\")])\n \n+(define_insn \"one_cmplpsi2\"\n+  [(set (match_operand:PSI 0 \"register_operand\" \"=r\")\n+        (not:PSI (match_operand:PSI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"com %0\\;com %B0\\;com %C0\"\n+  [(set_attr \"length\" \"3\")\n+   (set_attr \"cc\" \"set_n\")])\n+\n (define_insn \"one_cmplsi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n         (not:SI (match_operand:SI 1 \"register_operand\" \"0\")))]\n@@ -3174,6 +3490,16 @@\n   [(set_attr \"length\" \"3,4\")\n    (set_attr \"cc\" \"set_n,set_n\")])\n \n+(define_insn \"extendqipsi2\"\n+  [(set (match_operand:PSI 0 \"register_operand\" \"=r,r\")\n+        (sign_extend:PSI (match_operand:QI 1 \"combine_pseudo_register_operand\" \"0,*r\")))]\n+  \"\"\n+  \"@\n+\tclr %B0\\;sbrc %A0,7\\;com %B0\\;mov %C0,%B0\n+\tmov %A0,%A1\\;clr %B0\\;sbrc %A0,7\\;com %B0\\;mov %C0,%B0\"\n+  [(set_attr \"length\" \"4,5\")\n+   (set_attr \"cc\" \"set_n,set_n\")])\n+\n (define_insn \"extendqisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n         (sign_extend:SI (match_operand:QI 1 \"combine_pseudo_register_operand\" \"0,*r\")))]\n@@ -3184,6 +3510,18 @@\n   [(set_attr \"length\" \"5,6\")\n    (set_attr \"cc\" \"set_n,set_n\")])\n \n+(define_insn \"extendhipsi2\"\n+  [(set (match_operand:PSI 0 \"register_operand\"                               \"=r,r ,r\")\n+        (sign_extend:PSI (match_operand:HI 1 \"combine_pseudo_register_operand\" \"0,*r,*r\")))]\n+  \"\"\n+  \"@\n+\tclr %C0\\;sbrc %B0,7\\;com %C0\n+\tmov %A0,%A1\\;mov %B0,%B1\\;clr %C0\\;sbrc %B0,7\\;com %C0\n+\tmovw %A0,%A1\\;clr %C0\\;sbrc %B0,7\\;com %C0\"\n+  [(set_attr \"length\" \"3,5,4\")\n+   (set_attr \"isa\" \"*,mov,movw\")\n+   (set_attr \"cc\" \"set_n\")])\n+\n (define_insn \"extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\"                               \"=r,r ,r\")\n         (sign_extend:SI (match_operand:HI 1 \"combine_pseudo_register_operand\" \"0,*r,*r\")))]\n@@ -3196,6 +3534,14 @@\n    (set_attr \"isa\" \"*,mov,movw\")\n    (set_attr \"cc\" \"set_n\")])\n \n+(define_insn \"extendpsisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\"                                \"=r\")\n+        (sign_extend:SI (match_operand:PSI 1 \"combine_pseudo_register_operand\" \"0\")))]\n+  \"\"\n+  \"clr %D0\\;sbrc %C0,7\\;com %D0\"\n+  [(set_attr \"length\" \"3\")\n+   (set_attr \"cc\" \"set_n\")])\n+\n ;; xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x\n ;; zero extend\n \n@@ -3215,6 +3561,21 @@\n   operands[3] = simplify_gen_subreg (QImode, operands[0], HImode, high_off);\n })\n \n+(define_insn_and_split \"zero_extendqipsi2\"\n+  [(set (match_operand:PSI 0 \"register_operand\" \"=r\")\n+        (zero_extend:PSI (match_operand:QI 1 \"combine_pseudo_register_operand\" \"r\")))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 3) (const_int 0))\n+   (set (match_dup 4) (const_int 0))]\n+  {\n+    operands[2] = simplify_gen_subreg (QImode, operands[0], PSImode, 0);\n+    operands[3] = simplify_gen_subreg (QImode, operands[0], PSImode, 1);\n+    operands[4] = simplify_gen_subreg (QImode, operands[0], PSImode, 2);\n+  })\n+\n (define_insn_and_split \"zero_extendqisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n         (zero_extend:SI (match_operand:QI 1 \"combine_pseudo_register_operand\" \"r\")))]\n@@ -3231,6 +3592,19 @@\n   operands[3] = simplify_gen_subreg (HImode, operands[0], SImode, high_off);\n })\n \n+(define_insn_and_split \"zero_extendhipsi2\"\n+  [(set (match_operand:PSI 0 \"register_operand\"                               \"=r\")\n+        (zero_extend:PSI (match_operand:HI 1 \"combine_pseudo_register_operand\" \"r\")))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 3) (const_int 0))]\n+  {\n+    operands[2] = simplify_gen_subreg (HImode, operands[0], PSImode, 0);\n+    operands[3] = simplify_gen_subreg (QImode, operands[0], PSImode, 2);\n+  })\n+\n (define_insn_and_split \"zero_extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\"                               \"=r\")\n         (zero_extend:SI (match_operand:HI 1 \"combine_pseudo_register_operand\" \"r\")))]\n@@ -3247,6 +3621,19 @@\n   operands[3] = simplify_gen_subreg (HImode, operands[0], SImode, high_off);\n })\n \n+(define_insn_and_split \"zero_extendpsisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\"                                \"=r\")\n+        (zero_extend:SI (match_operand:PSI 1 \"combine_pseudo_register_operand\" \"r\")))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 3) (const_int 0))]\n+  {\n+    operands[2] = simplify_gen_subreg (PSImode, operands[0], SImode, 0);\n+    operands[3] = simplify_gen_subreg (QImode, operands[0], SImode, 3);\n+  })\n+\n (define_insn_and_split \"zero_extendqidi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (zero_extend:DI (match_operand:QI 1 \"register_operand\" \"r\")))]\n@@ -3340,6 +3727,25 @@\n [(set_attr \"cc\" \"compare\")\n  (set_attr \"length\" \"2\")])\n \n+(define_insn \"*negated_tstpsi\"\n+  [(set (cc0)\n+        (compare (neg:PSI (match_operand:PSI 0 \"register_operand\" \"r\"))\n+                 (const_int 0)))]\n+  \"!flag_wrapv && !flag_trapv && flag_strict_overflow\"\n+  \"cp __zero_reg__,%A0\\;cpc __zero_reg__,%B0\\;cpc __zero_reg__,%C0\"\n+  [(set_attr \"cc\" \"compare\")\n+   (set_attr \"length\" \"3\")])\n+\n+(define_insn \"*reversed_tstpsi\"\n+  [(set (cc0)\n+        (compare (const_int 0)\n+                 (match_operand:PSI 0 \"register_operand\" \"r\")))\n+   (clobber (match_scratch:QI 1 \"=X\"))]\n+  \"\"\n+  \"cp __zero_reg__,%A0\\;cpc __zero_reg__,%B0\\;cpc __zero_reg__,%C0\"\n+  [(set_attr \"cc\" \"compare\")\n+   (set_attr \"length\" \"3\")])\n+\n (define_insn \"*negated_tstsi\"\n   [(set (cc0)\n         (compare (neg:SI (match_operand:SI 0 \"register_operand\" \"r\"))\n@@ -3418,6 +3824,35 @@\n    (set_attr \"length\" \"1,2,2,3,4,2,4\")\n    (set_attr \"adjust_len\" \"tsthi,tsthi,*,*,*,compare,compare\")])\n \n+(define_insn \"*cmppsi\"\n+  [(set (cc0)\n+        (compare (match_operand:PSI 0 \"register_operand\"  \"r,r,d ,r  ,d,r\")\n+                 (match_operand:PSI 1 \"nonmemory_operand\" \"L,r,s ,s  ,M,n\")))\n+   (clobber (match_scratch:QI 2                          \"=X,X,&d,&d ,X,&d\"))]\n+  \"\"\n+  {\n+    switch (which_alternative)\n+      {\n+      case 0:\n+        return avr_out_tstpsi (insn, operands, NULL);\n+\n+      case 1:\n+        return \"cp %A0,%A1\\;cpc %B0,%B1\\;cpc %C0,%C1\";\n+\n+      case 2:\n+        return reg_unused_after (insn, operands[0])\n+               ? \"subi %A0,lo8(%1)\\;sbci %B0,hi8(%1)\\;sbci %C0,hh8(%1)\"\n+               : \"cpi %A0,lo8(%1)\\;ldi %2,hi8(%1)\\;cpc %B0,%2\\;ldi %2,hh8(%1)\\;cpc %C0,%2\";\n+               \n+      case 3:\n+        return \"ldi %2,lo8(%1)\\;cp %A0,%2\\;ldi %2,hi8(%1)\\;cpc %B0,%2\\;ldi %2,hh8(%1)\\;cpc %C0,%2\";\n+      }\n+    \n+    return avr_out_compare (insn, operands, NULL);\n+  }\n+  [(set_attr \"cc\" \"compare\")\n+   (set_attr \"length\" \"3,3,5,6,3,7\")\n+   (set_attr \"adjust_len\" \"tstpsi,*,*,*,compare,compare\")])\n \n (define_insn \"*cmpsi\"\n   [(set (cc0)\n@@ -3456,6 +3891,18 @@\n               (pc)))]\n  \"\")\n \n+(define_expand \"cbranchpsi4\"\n+  [(parallel [(set (cc0)\n+                   (compare (match_operand:PSI 1 \"register_operand\" \"\")\n+                            (match_operand:PSI 2 \"nonmemory_operand\" \"\")))\n+              (clobber (match_scratch:QI 4 \"\"))])\n+   (set (pc)\n+        (if_then_else (match_operator 0 \"ordered_comparison_operator\" [(cc0)\n+                                                                       (const_int 0)])\n+                      (label_ref (match_operand 3 \"\" \"\"))\n+                      (pc)))]\n+ \"\")\n+\n (define_expand \"cbranchhi4\"\n   [(parallel [(set (cc0)\n \t           (compare (match_operand:HI 1 \"register_operand\" \"\")"}, {"sha": "0f6a03adbf1973e99bc7ab9bf0ce36086a7849e4", "filename": "gcc/config/avr/constraints.md", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4fe948a6e9049df934677fc95d78b11c5cff4bd/gcc%2Fconfig%2Favr%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4fe948a6e9049df934677fc95d78b11c5cff4bd/gcc%2Fconfig%2Favr%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fconstraints.md?ref=e4fe948a6e9049df934677fc95d78b11c5cff4bd", "patch": "@@ -133,6 +133,11 @@\n   (and (match_code \"const_int\")\n        (match_test \"avr_popcount_each_byte (op, 2, (1<<0) | (1<<7) | (1<<8))\")))\n \n+(define_constraint \"Ca3\"\n+  \"Constant 3-byte integer that allows AND without clobber register.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"avr_popcount_each_byte (op, 3, (1<<0) | (1<<7) | (1<<8))\")))\n+\n (define_constraint \"Ca4\"\n   \"Constant 4-byte integer that allows AND without clobber register.\"\n   (and (match_code \"const_int\")\n@@ -143,6 +148,11 @@\n   (and (match_code \"const_int\")\n        (match_test \"avr_popcount_each_byte (op, 2, (1<<0) | (1<<1) | (1<<8))\")))\n \n+(define_constraint \"Co3\"\n+  \"Constant 3-byte integer that allows OR without clobber register.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"avr_popcount_each_byte (op, 3, (1<<0) | (1<<1) | (1<<8))\")))\n+\n (define_constraint \"Co4\"\n   \"Constant 4-byte integer that allows OR without clobber register.\"\n   (and (match_code \"const_int\")\n@@ -153,6 +163,11 @@\n   (and (match_code \"const_int\")\n        (match_test \"avr_popcount_each_byte (op, 2, (1<<0) | (1<<8))\")))\n \n+(define_constraint \"Cx3\"\n+  \"Constant 3-byte integer that allows XOR without clobber register.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"avr_popcount_each_byte (op, 3, (1<<0) | (1<<8))\")))\n+\n (define_constraint \"Cx4\"\n   \"Constant 4-byte integer that allows XOR without clobber register.\"\n   (and (match_code \"const_int\")"}, {"sha": "df6ad30c99b631bcf7a8966d75c4b15b25d50ee7", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4fe948a6e9049df934677fc95d78b11c5cff4bd/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4fe948a6e9049df934677fc95d78b11c5cff4bd/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=e4fe948a6e9049df934677fc95d78b11c5cff4bd", "patch": "@@ -1,3 +1,9 @@\n+2011-11-04  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/50931\n+\t* config/t-avr (LIB1ASMFUNCS): Add _divmodpsi4, _udivmodpsi4.\n+\t* config/lib1funcs.S (__udivmodpsi4, __divmodpsi4): New functions.\n+\n 2011-11-04  Joel Sherrill  <joel.sherrill@oarcorp.com>\n \n \tPR target/50989"}, {"sha": "cd88a57bce706226aeb904008f6f446099310326", "filename": "libgcc/config/avr/lib1funcs.S", "status": "modified", "additions": 136, "deletions": 1, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4fe948a6e9049df934677fc95d78b11c5cff4bd/libgcc%2Fconfig%2Favr%2Flib1funcs.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4fe948a6e9049df934677fc95d78b11c5cff4bd/libgcc%2Fconfig%2Favr%2Flib1funcs.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flib1funcs.S?ref=e4fe948a6e9049df934677fc95d78b11c5cff4bd", "patch": "@@ -599,7 +599,142 @@ ENDF __divmodhi4\n #undef r_arg2L \n              \t\n #undef r_cnt   \t\n-\t\n+\n+/*******************************************************\n+       Division 24 / 24 => (result + remainder)\n+*******************************************************/\n+\n+;; A[0..2]: In: Dividend; Out: Quotient\n+#define A0  22\n+#define A1  A0+1\n+#define A2  A0+2\n+\n+;; B[0..2]: In: Divisor;   Out: Remainder\n+#define B0  18\n+#define B1  B0+1\n+#define B2  B0+2\n+\n+;; C[0..2]: Expand remainder\n+#define C0  __zero_reg__\n+#define C1  26\n+#define C2  25\n+\n+;; Loop counter\n+#define r_cnt   21\n+\n+#if defined (L_udivmodpsi4)\n+;; R24:R22 = R24:R22  udiv  R20:R18\n+;; R20:R18 = R24:R22  umod  R20:R18\n+;; Clobbers: R21, R25, R26\n+\n+DEFUN __udivmodpsi4\n+    ; init loop counter\n+    ldi     r_cnt, 24+1\n+    ; Clear remainder and carry.  C0 is already 0\n+    clr     C1\n+    sub     C2, C2\n+    ; jump to entry point\n+    rjmp    __udivmodpsi4_start\n+__udivmodpsi4_loop:\n+    ; shift dividend into remainder\n+    rol     C0\n+    rol     C1\n+    rol     C2\n+    ; compare remainder & divisor\n+    cp      C0, B0\n+    cpc     C1, B1\n+    cpc     C2, B2\n+    brcs    __udivmodpsi4_start ; remainder <= divisor\n+    sub     C0, B0              ; restore remainder\n+    sbc     C1, B1\n+    sbc     C2, B2\n+__udivmodpsi4_start:\n+    ; shift dividend (with CARRY)\n+    rol     A0\n+    rol     A1\n+    rol     A2\n+    ; decrement loop counter\n+    dec     r_cnt\n+    brne    __udivmodpsi4_loop\n+    com     A0\n+    com     A1\n+    com     A2\n+    ; div/mod results to return registers\n+    ; remainder\n+    mov     B0, C0\n+    mov     B1, C1\n+    mov     B2, C2\n+    clr     __zero_reg__ ; C0\n+    ret\n+ENDF __udivmodpsi4\n+#endif /* defined (L_udivmodpsi4) */\n+\n+#if defined (L_divmodpsi4)\n+;; R24:R22 = R24:R22  div  R20:R18\n+;; R20:R18 = R24:R22  mod  R20:R18\n+;; Clobbers: T, __tmp_reg__, R21, R25, R26\n+\n+DEFUN __divmodpsi4\n+    ; R0.7 will contain the sign of the result:\n+    ; R0.7 = A.sign ^ B.sign\n+    mov __tmp_reg__, B2\n+    ; T-flag = sign of dividend\n+    bst     A2, 7\n+    brtc    0f\n+    com     __tmp_reg__\n+    ; Adjust dividend's sign\n+    rcall   __divmodpsi4_negA\n+0:\n+    ; Adjust divisor's sign\n+    sbrc    B2, 7\n+    rcall   __divmodpsi4_negB\n+\n+    ; Do the unsigned div/mod\n+    XCALL   __udivmodpsi4\n+\n+    ; Adjust quotient's sign\n+    sbrc    __tmp_reg__, 7\n+    rcall   __divmodpsi4_negA\n+\n+    ; Adjust remainder's sign\n+    brtc    __divmodpsi4_end\n+\n+__divmodpsi4_negB:\n+    ; Correct divisor/remainder sign\n+    com     B2\n+    com     B1\n+    neg     B0\n+    sbci    B1, -1\n+    sbci    B2, -1\n+    ret\n+\n+    ; Correct dividend/quotient sign\n+__divmodpsi4_negA:\n+    com     A2\n+    com     A1\n+    neg     A0\n+    sbci    A1, -1\n+    sbci    A2, -1\n+__divmodpsi4_end:\n+    ret\n+\n+ENDF __divmodpsi4\n+#endif /* defined (L_divmodpsi4) */\n+\n+#undef A0\n+#undef A1\n+#undef A2\n+\n+#undef B0\n+#undef B1\n+#undef B2\n+\n+#undef C0\n+#undef C1\n+#undef C2\n+\n+#undef r_cnt\n+\n /*******************************************************\n        Division 32 / 32 => (result + remainder)\n *******************************************************/"}, {"sha": "63f7460e2b3131c642c4200a70f7badeabe85314", "filename": "libgcc/config/avr/t-avr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4fe948a6e9049df934677fc95d78b11c5cff4bd/libgcc%2Fconfig%2Favr%2Ft-avr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4fe948a6e9049df934677fc95d78b11c5cff4bd/libgcc%2Fconfig%2Favr%2Ft-avr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Ft-avr?ref=e4fe948a6e9049df934677fc95d78b11c5cff4bd", "patch": "@@ -12,6 +12,7 @@ LIB1ASMFUNCS = \\\n \t_divmodqi4 \\\n \t_udivmodhi4 \\\n \t_divmodhi4 \\\n+\t_divmodpsi4 _udivmodpsi4 \\\n \t_udivmodsi4 \\\n \t_divmodsi4 \\\n \t_prologue \\"}]}