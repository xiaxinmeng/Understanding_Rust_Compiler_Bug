{"sha": "07b6642b935e1cd499a2aae071db06d845e39a8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdiNjY0MmI5MzVlMWNkNDk5YTJhYWUwNzFkYjA2ZDg0NWUzOWE4Yg==", "commit": {"author": {"name": "Torvald Riegel", "email": "triegel@redhat.com", "date": "2012-01-13T23:45:06Z"}, "committer": {"name": "Torvald Riegel", "email": "torvald@gcc.gnu.org", "date": "2012-01-13T23:45:06Z"}, "message": "libitm: Filter out undo writes that overlap with the libitm stack.\n\n\tPR libitm/51855\n\t* config/generic/tls.h (GTM::mask_stack_top): New.\n\t(GTM::mask_stack_bottom): Declare.\n\t* config/generic/tls.c (GTM::mask_stack_bottom): New.\n\t* local.cc (gtm_undolog::rollback): Filter out any updates that\n\toverlap the libitm stack.  Add current transaction as parameter.\n\t* libitm_i.h (GTM::gtm_undolog::rollback): Adapt.\n\t* beginend.cc (GTM::gtm_thread::rollback): Adapt.\n\t* testsuite/libitm.c/stackundo.c: New test.\n\nFrom-SVN: r183172", "tree": {"sha": "8ed0df69ae3d1543fa4811e7cb7e72a8d99333b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ed0df69ae3d1543fa4811e7cb7e72a8d99333b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07b6642b935e1cd499a2aae071db06d845e39a8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07b6642b935e1cd499a2aae071db06d845e39a8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07b6642b935e1cd499a2aae071db06d845e39a8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07b6642b935e1cd499a2aae071db06d845e39a8b/comments", "author": {"login": "triegelrh", "id": 62400967, "node_id": "MDQ6VXNlcjYyNDAwOTY3", "avatar_url": "https://avatars.githubusercontent.com/u/62400967?v=4", "gravatar_id": "", "url": "https://api.github.com/users/triegelrh", "html_url": "https://github.com/triegelrh", "followers_url": "https://api.github.com/users/triegelrh/followers", "following_url": "https://api.github.com/users/triegelrh/following{/other_user}", "gists_url": "https://api.github.com/users/triegelrh/gists{/gist_id}", "starred_url": "https://api.github.com/users/triegelrh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/triegelrh/subscriptions", "organizations_url": "https://api.github.com/users/triegelrh/orgs", "repos_url": "https://api.github.com/users/triegelrh/repos", "events_url": "https://api.github.com/users/triegelrh/events{/privacy}", "received_events_url": "https://api.github.com/users/triegelrh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4cce1836bde85844781736f0f87b51ae9393da5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cce1836bde85844781736f0f87b51ae9393da5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cce1836bde85844781736f0f87b51ae9393da5f"}], "stats": {"total": 90, "additions": 84, "deletions": 6}, "files": [{"sha": "8efaef5f329726984d716d8e94a255e0787e9b50", "filename": "libitm/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b6642b935e1cd499a2aae071db06d845e39a8b/libitm%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b6642b935e1cd499a2aae071db06d845e39a8b/libitm%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2FChangeLog?ref=07b6642b935e1cd499a2aae071db06d845e39a8b", "patch": "@@ -1,3 +1,15 @@\n+2012-01-14  Torvald Riegel  <triegel@redhat.com>\n+\n+\tPR libitm/51855\n+\t* config/generic/tls.h (GTM::mask_stack_top): New.\n+\t(GTM::mask_stack_bottom): Declare.\n+\t* config/generic/tls.c (GTM::mask_stack_bottom): New.\n+\t* local.cc (gtm_undolog::rollback): Filter out any updates that\n+\toverlap the libitm stack.  Add current transaction as parameter.\n+\t* libitm_i.h (GTM::gtm_undolog::rollback): Adapt.\n+\t* beginend.cc (GTM::gtm_thread::rollback): Adapt.\n+\t* testsuite/libitm.c/stackundo.c: New test.\n+\n 2012-01-10  Richard Henderson  <rth@redhat.com>\n \n \t* libitm_i.h (_Unwind_DeleteException): Declare weak."}, {"sha": "08c2174ea6765369aeec52daf8c8236ab850ef4a", "filename": "libitm/beginend.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b6642b935e1cd499a2aae071db06d845e39a8b/libitm%2Fbeginend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b6642b935e1cd499a2aae071db06d845e39a8b/libitm%2Fbeginend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fbeginend.cc?ref=07b6642b935e1cd499a2aae071db06d845e39a8b", "patch": "@@ -327,7 +327,7 @@ GTM::gtm_thread::rollback (gtm_transaction_cp *cp, bool aborting)\n   // data. Because of the latter, we have to roll it back before any\n   // dispatch-specific rollback (which handles synchronization with other\n   // transactions).\n-  undolog.rollback (cp ? cp->undolog_size : 0);\n+  undolog.rollback (this, cp ? cp->undolog_size : 0);\n \n   // Perform dispatch-specific rollback.\n   abi_disp()->rollback (cp);"}, {"sha": "f07d082b4eef41d57760a4eb7ffeeb6eb2a71e8e", "filename": "libitm/config/generic/tls.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b6642b935e1cd499a2aae071db06d845e39a8b/libitm%2Fconfig%2Fgeneric%2Ftls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b6642b935e1cd499a2aae071db06d845e39a8b/libitm%2Fconfig%2Fgeneric%2Ftls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fgeneric%2Ftls.cc?ref=07b6642b935e1cd499a2aae071db06d845e39a8b", "patch": "@@ -30,4 +30,11 @@ namespace GTM HIDDEN {\n __thread gtm_thread_tls _gtm_thr_tls;\n #endif\n \n+// See tls.h for comments.\n+void * __attribute__((noinline))\n+mask_stack_bottom(gtm_thread *tx)\n+{\n+  return (uint8_t*)__builtin_dwarf_cfa() - 256;\n+}\n+\n } // namespace GTM"}, {"sha": "dfcd76a0dac9356ee43391867111c737ff08e984", "filename": "libitm/config/generic/tls.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b6642b935e1cd499a2aae071db06d845e39a8b/libitm%2Fconfig%2Fgeneric%2Ftls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b6642b935e1cd499a2aae071db06d845e39a8b/libitm%2Fconfig%2Fgeneric%2Ftls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fgeneric%2Ftls.h?ref=07b6642b935e1cd499a2aae071db06d845e39a8b", "patch": "@@ -60,6 +60,23 @@ static inline abi_dispatch * abi_disp() { return _gtm_thr_tls.disp; }\n static inline void set_abi_disp(abi_dispatch *x) { _gtm_thr_tls.disp = x; }\n #endif\n \n+#ifndef HAVE_ARCH_GTM_MASK_STACK\n+// To filter out any updates that overlap the libitm stack, we define\n+// gtm_mask_stack_top to the entry point to the library and\n+// gtm_mask_stack_bottom to below the calling function (enforced with the\n+// noinline attribute).  This definition should be fine for all\n+// stack-grows-down architectures.\n+// FIXME We fake the bottom to be lower so that we are safe even if we might\n+// call further functions (compared to where we called gtm_mask_stack_bottom\n+// in the call hierarchy) to actually undo or redo writes (e.g., memcpy).\n+// This is a completely arbitrary value; can we instead ensure that there are\n+// no such calls, or can we determine a future-proof value otherwise?\n+static inline void *\n+mask_stack_top(gtm_thread *tx) { return tx->jb.cfa; }\n+void * __attribute__((noinline))\n+mask_stack_bottom(gtm_thread *tx);\n+#endif\n+\n } // namespace GTM\n \n #endif // LIBITM_TLS_H"}, {"sha": "bf17086ef2ebddea654595dc0d605ffae2f9b29d", "filename": "libitm/libitm_i.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b6642b935e1cd499a2aae071db06d845e39a8b/libitm%2Flibitm_i.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b6642b935e1cd499a2aae071db06d845e39a8b/libitm%2Flibitm_i.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Flibitm_i.h?ref=07b6642b935e1cd499a2aae071db06d845e39a8b", "patch": "@@ -142,7 +142,7 @@ struct gtm_undolog\n   size_t size() const { return undolog.size(); }\n \n   // In local.cc\n-  void rollback (size_t until_size = 0);\n+  void rollback (gtm_thread* tx, size_t until_size = 0);\n };\n \n // Contains all thread-specific data required by the entire library."}, {"sha": "5645a12bab891849df45f003d538852b21ee8652", "filename": "libitm/local.cc", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b6642b935e1cd499a2aae071db06d845e39a8b/libitm%2Flocal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b6642b935e1cd499a2aae071db06d845e39a8b/libitm%2Flocal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Flocal.cc?ref=07b6642b935e1cd499a2aae071db06d845e39a8b", "patch": "@@ -26,11 +26,20 @@\n \n namespace GTM HIDDEN {\n \n-\n-void\n-gtm_undolog::rollback (size_t until_size)\n+// This function needs to be noinline because we need to prevent that it gets\n+// inlined into another function that calls further functions. This could\n+// break our assumption that we only call memcpy and thus only need to\n+// additionally protect the memcpy stack (see the hack in mask_stack_bottom()).\n+// Even if that isn't an issue because those other calls don't happen during\n+// copying, we still need mask_stack_bottom() to be called \"close\" to the\n+// memcpy in terms of stack frames, so just ensure that for now using the\n+// noinline.\n+void __attribute__((noinline))\n+gtm_undolog::rollback (gtm_thread* tx, size_t until_size)\n {\n   size_t i, n = undolog.size();\n+  void *top = mask_stack_top(tx);\n+  void *bot = mask_stack_bottom(tx);\n \n   if (n > 0)\n     {\n@@ -40,7 +49,17 @@ gtm_undolog::rollback (size_t until_size)\n           size_t len = undolog[i];\n           size_t words = (len + sizeof(gtm_word) - 1) / sizeof(gtm_word);\n           i -= words;\n-          __builtin_memcpy (ptr, &undolog[i], len);\n+          // Filter out any updates that overlap the libitm stack.  We don't\n+          // bother filtering out just the overlapping bytes because we don't\n+          // merge writes and thus any overlapping write is either bogus or\n+          // would restore data on stack frames that are not in use anymore.\n+          // FIXME The memcpy can/will end up as another call but we\n+          // calculated BOT based on the current function.  Can we inline or\n+          // reimplement this without too much trouble due to unaligned calls\n+          // and still have good performance, so that we can remove the hack\n+          // in mask_stack_bottom()?\n+          if (likely(ptr > top || (uint8_t*)ptr + len <= bot))\n+            __builtin_memcpy (ptr, &undolog[i], len);\n \t}\n     }\n }"}, {"sha": "02759d77014b30eee5cb370d82894c6c794cfcca", "filename": "libitm/testsuite/libitm.c/stackundo.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b6642b935e1cd499a2aae071db06d845e39a8b/libitm%2Ftestsuite%2Flibitm.c%2Fstackundo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b6642b935e1cd499a2aae071db06d845e39a8b/libitm%2Ftestsuite%2Flibitm.c%2Fstackundo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Ftestsuite%2Flibitm.c%2Fstackundo.c?ref=07b6642b935e1cd499a2aae071db06d845e39a8b", "patch": "@@ -0,0 +1,23 @@\n+int __attribute__((noinline)) test2(int x[1000])\n+{\n+  int i;\n+  return x[12];\n+}\n+\n+int __attribute__((noinline)) test1()\n+{\n+  int x[1000], i;\n+\n+  for (i = 0; i < 1000; i++)\n+    x[i] = i;\n+  return test2(x);\n+}\n+\n+int main()\n+{\n+  __transaction_atomic {\n+    if (test1() !=0)\n+      __transaction_cancel;\n+  }\n+  return 0;\n+}"}]}