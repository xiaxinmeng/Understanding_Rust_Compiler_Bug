{"sha": "433ce291b562b15ae197c373fb75bfa4944c1a02", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDMzY2UyOTFiNTYyYjE1YWUxOTdjMzczZmI3NWJmYTQ5NDRjMWEwMg==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2010-09-05T18:10:11Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2010-09-05T18:10:11Z"}, "message": "re PR fortran/45186 (Gfortran 4.5.0 emits wrong linenumbers)\n\n2010-09-05  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/45186\n        * trans-intrinsic.c (gfc_conv_intrinsic_sign,\n        gfc_conv_intrinsic_leadz): Use build_call_expr_loc instead\n        of build_call_expr.\n        * trans-expr.c (gfc_conv_expr_present, gfc_conv_missing_dummy,\n        gfc_conv_string_length, gfc_conv_substring,\n        gfc_conv_component_ref, gfc_conv_unary_op, gfc_conv_powi,\n        gfc_conv_cst_int_power, gfc_conv_string_tmp, gfc_conv_concat_op,\n        gfc_conv_expr_op, gfc_build_compare_string,\n        gfc_set_interface_mapping_bounds, gfc_conv_subref_array_arg,\n        gfc_conv_derived_to_class, conv_isocbinding_procedure,\n        gfc_conv_procedure_call, fill_with_spaces,\n        gfc_trans_string_copy, gfc_trans_alloc_subarray_assign,\n        gfc_trans_structure_assign, gfc_trans_pointer_assignment,\n        gfc_trans_scalar_assign, gfc_trans_zero_assign,\n        gfc_trans_array_copy, gfc_trans_array_constructor_copy): Change\n        fold_build[0-9] to fold_build[0-9]_loc.\n        * trans-io.c (set_parameter_const, set_parameter_value,\n        set_parameter_ref, gfc_convert_array_to_string, set_string,\n        set_internal_unit, io_result, set_error_locus,\n        nml_get_addr_expr, build_dt): Ditto.\n        * trans-openmp.c (gfc_omp_clause_default_ctor,\n        gfc_omp_clause_copy_ctor, gfc_omp_clause_assign_op,\n        gfc_trans_omp_array_reduction, gfc_trans_omp_atomic,\n        gfc_trans_omp_do): Ditto.\n        * trans.c (gfc_add_modify, gfc_build_addr_expr,\n        gfc_build_array_ref, gfc_trans_runtime_error_vararg,\n        gfc_trans_runtime_check, gfc_call_malloc,\n        gfc_allocate_with_status, gfc_allocate_array_with_status,\n        gfc_call_free, gfc_deallocate_with_status,\n        gfc_call_realloc): Ditto.\n\nFrom-SVN: r163879", "tree": {"sha": "4d02d71598e853334e3a8c5d484b88da3249edf7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d02d71598e853334e3a8c5d484b88da3249edf7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/433ce291b562b15ae197c373fb75bfa4944c1a02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/433ce291b562b15ae197c373fb75bfa4944c1a02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/433ce291b562b15ae197c373fb75bfa4944c1a02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/433ce291b562b15ae197c373fb75bfa4944c1a02/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "226b53d2c179b8527abc1ce649fad94cc07aac71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/226b53d2c179b8527abc1ce649fad94cc07aac71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/226b53d2c179b8527abc1ce649fad94cc07aac71"}], "stats": {"total": 824, "additions": 479, "deletions": 345}, "files": [{"sha": "0d8a59039901540d482067cf29392ec1736e3ad6", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/433ce291b562b15ae197c373fb75bfa4944c1a02/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/433ce291b562b15ae197c373fb75bfa4944c1a02/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=433ce291b562b15ae197c373fb75bfa4944c1a02", "patch": "@@ -1,3 +1,37 @@\n+2010-09-05  Tobias Burnus <burnus@net-b.de>\n+\n+\tPR fortran/45186\n+\t* f95-lang.c (gfc_truthvalue_conversion): Use\n+\tfold_build[0-9]_loc instead of fold_build[0-9].\n+\t* convert.c (convert): Ditto.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_conversion,\n+\tbuild_fixbound_expr, build_fix_expr, gfc_conv_intrinsic_aint,\n+\tgfc_conv_intrinsic_int, gfc_conv_intrinsic_imagpart,\n+\tgfc_conv_intrinsic_conjg, gfc_trans_same_strlen_check,\n+\tgfc_conv_intrinsic_bound, gfc_conv_intrinsic_abs,\n+\tgfc_conv_intrinsic_cmplx, gfc_conv_intrinsic_mod,\n+\tgfc_conv_intrinsic_dim, gfc_conv_intrinsic_sign,\n+\tgfc_conv_intrinsic_dprod, gfc_conv_intrinsic_char,\n+\tgfc_conv_intrinsic_ctime, gfc_conv_intrinsic_fdate,\n+\tgfc_conv_intrinsic_ttynam, gfc_conv_intrinsic_minmax,\n+\tgfc_conv_intrinsic_minmax_char, gfc_conv_intrinsic_anyall,\n+\tgfc_conv_intrinsic_count, gfc_conv_intrinsic_arith,\n+\tgfc_conv_intrinsic_dot_product, gfc_conv_intrinsic_minmaxloc,\n+\tgfc_conv_intrinsic_minmaxval, gfc_conv_intrinsic_btest,\n+\tgfc_conv_intrinsic_bitop, gfc_conv_intrinsic_not,\n+\tgfc_conv_intrinsic_singlebitop, gfc_conv_intrinsic_ibits,\n+\tgfc_conv_intrinsic_rlshift, gfc_conv_intrinsic_ishft,\n+\tgfc_conv_intrinsic_ishftc, gfc_conv_intrinsic_leadz,\n+\tgfc_conv_intrinsic_trailz, gfc_conv_intrinsic_popcnt_poppar,\n+\tgfc_conv_intrinsic_ichar, gfc_conv_has_intvalue,\n+\tgfc_conv_intrinsic_merge, gfc_conv_intrinsic_spacing,\n+\tgfc_conv_intrinsic_rrspacing, gfc_conv_intrinsic_size,\n+\tsize_of_string_in_bytes, gfc_conv_intrinsic_sizeof,\n+\tgfc_conv_intrinsic_storage_size, gfc_conv_intrinsic_strcmp,\n+\tgfc_conv_intrinsic_transfer, gfc_conv_allocated,\n+\tgfc_conv_associated, gfc_conv_same_type_as,\n+\tgfc_conv_intrinsic_trim, gfc_conv_intrinsic_repeat): Ditto.\n+\n 2010-09-04  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/45530"}, {"sha": "0493f3fd5736b4980cf1c7e4e7a88a3ddf33ed0a", "filename": "gcc/fortran/convert.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/433ce291b562b15ae197c373fb75bfa4944c1a02/gcc%2Ffortran%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/433ce291b562b15ae197c373fb75bfa4944c1a02/gcc%2Ffortran%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fconvert.c?ref=433ce291b562b15ae197c373fb75bfa4944c1a02", "patch": "@@ -80,7 +80,7 @@ convert (tree type, tree expr)\n     return expr;\n \n   if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (expr)))\n-    return fold_build1 (NOP_EXPR, type, expr);\n+    return fold_build1_loc (input_location, NOP_EXPR, type, expr);\n   if (TREE_CODE (TREE_TYPE (expr)) == ERROR_MARK)\n     return error_mark_node;\n   if (TREE_CODE (TREE_TYPE (expr)) == VOID_TYPE)\n@@ -89,7 +89,7 @@ convert (tree type, tree expr)\n       return error_mark_node;\n     }\n   if (code == VOID_TYPE)\n-    return fold_build1 (CONVERT_EXPR, type, e);\n+    return fold_build1_loc (input_location, CONVERT_EXPR, type, e);\n #if 0\n   /* This is incorrect.  A truncation can't be stripped this way.\n      Extensions will be stripped by the use of get_unwidened.  */\n@@ -105,9 +105,10 @@ convert (tree type, tree expr)\n       /* If we have a NOP_EXPR, we must fold it here to avoid\n \t infinite recursion between fold () and convert ().  */\n       if (TREE_CODE (e) == NOP_EXPR)\n-\treturn fold_build1 (NOP_EXPR, type, TREE_OPERAND (e, 0));\n+\treturn fold_build1_loc (input_location, NOP_EXPR, type,\n+\t\t\t\tTREE_OPERAND (e, 0));\n       else\n-\treturn fold_build1 (NOP_EXPR, type, e);\n+\treturn fold_build1_loc (input_location, NOP_EXPR, type, e);\n     }\n   if (code == POINTER_TYPE || code == REFERENCE_TYPE)\n     return fold (convert_to_pointer (type, e));"}, {"sha": "8c957d2d141373a3f06108243e9baa2b1b51c77c", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/433ce291b562b15ae197c373fb75bfa4944c1a02/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/433ce291b562b15ae197c373fb75bfa4944c1a02/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=433ce291b562b15ae197c373fb75bfa4944c1a02", "patch": "@@ -200,17 +200,18 @@ gfc_truthvalue_conversion (tree expr)\n \t  return expr;\n \t}\n       else if (TREE_CODE (expr) == NOP_EXPR)\n-        return fold_build1 (NOP_EXPR,\n+        return fold_build1_loc (input_location, NOP_EXPR,\n \t\t\t    boolean_type_node, TREE_OPERAND (expr, 0));\n       else\n-        return fold_build1 (NOP_EXPR, boolean_type_node, expr);\n+        return fold_build1_loc (input_location, NOP_EXPR, boolean_type_node,\n+\t\t\t\texpr);\n \n     case INTEGER_TYPE:\n       if (TREE_CODE (expr) == INTEGER_CST)\n \treturn integer_zerop (expr) ? boolean_false_node : boolean_true_node;\n       else\n-        return fold_build2 (NE_EXPR, boolean_type_node, expr,\n-\t\t\t    build_int_cst (TREE_TYPE (expr), 0));\n+        return fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t\texpr, build_int_cst (TREE_TYPE (expr), 0));\n \n     default:\n       internal_error (\"Unexpected type in truthvalue_conversion\");"}, {"sha": "38b7ecc8d63471ac34e0fee05111b74a8551f375", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 435, "deletions": 337, "changes": 772, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/433ce291b562b15ae197c373fb75bfa4944c1a02/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/433ce291b562b15ae197c373fb75bfa4944c1a02/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=433ce291b562b15ae197c373fb75bfa4944c1a02", "patch": "@@ -331,7 +331,8 @@ gfc_conv_intrinsic_conversion (gfc_se * se, gfc_expr * expr)\n       tree artype;\n \n       artype = TREE_TYPE (TREE_TYPE (args[0]));\n-      args[0] = fold_build1 (REALPART_EXPR, artype, args[0]);\n+      args[0] = fold_build1_loc (input_location, REALPART_EXPR, artype,\n+\t\t\t\t args[0]);\n     }\n \n   se->expr = convert (type, args[0]);\n@@ -357,11 +358,12 @@ build_fixbound_expr (stmtblock_t * pblock, tree arg, tree type, int up)\n   intval = gfc_evaluate_now (intval, pblock);\n \n   tmp = convert (argtype, intval);\n-  cond = fold_build2 (up ? GE_EXPR : LE_EXPR, boolean_type_node, tmp, arg);\n+  cond = fold_build2_loc (input_location, up ? GE_EXPR : LE_EXPR,\n+\t\t\t  boolean_type_node, tmp, arg);\n \n-  tmp = fold_build2 (up ? PLUS_EXPR : MINUS_EXPR, type, intval,\n-\t\t     build_int_cst (type, 1));\n-  tmp = fold_build3 (COND_EXPR, type, cond, intval, tmp);\n+  tmp = fold_build2_loc (input_location, up ? PLUS_EXPR : MINUS_EXPR, type,\n+\t\t\t intval, build_int_cst (type, 1));\n+  tmp = fold_build3_loc (input_location, COND_EXPR, type, cond, intval, tmp);\n   return tmp;\n }\n \n@@ -424,7 +426,7 @@ build_fix_expr (stmtblock_t * pblock, tree arg, tree type,\n       break;\n \n     case RND_TRUNC:\n-      return fold_build1 (FIX_TRUNC_EXPR, type, arg);\n+      return fold_build1_loc (input_location, FIX_TRUNC_EXPR, type, arg);\n       break;\n \n     default:\n@@ -496,17 +498,21 @@ gfc_conv_intrinsic_aint (gfc_se * se, gfc_expr * expr, enum rounding_mode op)\n   n = gfc_validate_kind (BT_INTEGER, kind, false);\n   mpfr_set_z (huge, gfc_integer_kinds[n].huge, GFC_RND_MODE);\n   tmp = gfc_conv_mpfr_to_tree (huge, kind, 0);\n-  cond = fold_build2 (LT_EXPR, boolean_type_node, arg[0], tmp);\n+  cond = fold_build2_loc (input_location, LT_EXPR, boolean_type_node, arg[0],\n+\t\t\t  tmp);\n \n   mpfr_neg (huge, huge, GFC_RND_MODE);\n   tmp = gfc_conv_mpfr_to_tree (huge, kind, 0);\n-  tmp = fold_build2 (GT_EXPR, boolean_type_node, arg[0], tmp);\n-  cond = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, cond, tmp);\n+  tmp = fold_build2_loc (input_location, GT_EXPR, boolean_type_node, arg[0],\n+\t\t\t tmp);\n+  cond = fold_build2_loc (input_location, TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t  cond, tmp);\n   itype = gfc_get_int_type (kind);\n \n   tmp = build_fix_expr (&se->pre, arg[0], itype, op);\n   tmp = convert (type, tmp);\n-  se->expr = fold_build3 (COND_EXPR, type, cond, tmp, arg[0]);\n+  se->expr = fold_build3_loc (input_location, COND_EXPR, type, cond, tmp,\n+\t\t\t      arg[0]);\n   mpfr_clear (huge);\n }\n \n@@ -544,7 +550,8 @@ gfc_conv_intrinsic_int (gfc_se * se, gfc_expr * expr, enum rounding_mode op)\n \t  tree artype;\n \n \t  artype = TREE_TYPE (TREE_TYPE (args[0]));\n-\t  args[0] = fold_build1 (REALPART_EXPR, artype, args[0]);\n+\t  args[0] = fold_build1_loc (input_location, REALPART_EXPR, artype,\n+\t\t\t\t     args[0]);\n \t}\n \n       se->expr = build_fix_expr (&se->pre, args[0], type, op);\n@@ -560,7 +567,8 @@ gfc_conv_intrinsic_imagpart (gfc_se * se, gfc_expr * expr)\n   tree arg;\n \n   gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n-  se->expr = fold_build1 (IMAGPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg);\n+  se->expr = fold_build1_loc (input_location, IMAGPART_EXPR,\n+\t\t\t      TREE_TYPE (TREE_TYPE (arg)), arg);\n }\n \n \n@@ -572,7 +580,7 @@ gfc_conv_intrinsic_conjg (gfc_se * se, gfc_expr * expr)\n   tree arg;\n \n   gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n-  se->expr = fold_build1 (CONJ_EXPR, TREE_TYPE (arg), arg);\n+  se->expr = fold_build1_loc (input_location, CONJ_EXPR, TREE_TYPE (arg), arg);\n }\n \n \n@@ -875,7 +883,7 @@ gfc_trans_same_strlen_check (const char* intr_name, locus* where,\n     return;\n \n   /* Compare the two string lengths.  */\n-  cond = fold_build2 (NE_EXPR, boolean_type_node, a, b);\n+  cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, a, b);\n \n   /* Output the runtime-check.  */\n   name = gfc_build_cstring_const (intr_name);\n@@ -942,8 +950,9 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n       gcc_assert (se->ss->expr == expr);\n       gfc_advance_se_ss_chain (se);\n       bound = se->loop->loopvar[0];\n-      bound = fold_build2 (MINUS_EXPR, gfc_array_index_type, bound,\n-\t\t\t   se->loop->from[0]);\n+      bound = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t       gfc_array_index_type, bound,\n+\t\t\t       se->loop->from[0]);\n     }\n   else\n     {\n@@ -954,8 +963,9 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n       gfc_add_block_to_block (&se->pre, &argse.pre);\n       bound = argse.expr;\n       /* Convert from one based to zero based.  */\n-      bound = fold_build2 (MINUS_EXPR, gfc_array_index_type, bound,\n-\t\t\t   gfc_index_one_node);\n+      bound = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t       gfc_array_index_type, bound,\n+\t\t\t       gfc_index_one_node);\n     }\n \n   /* TODO: don't re-evaluate the descriptor on each iteration.  */\n@@ -985,11 +995,13 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n       if (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)\n         {\n           bound = gfc_evaluate_now (bound, &se->pre);\n-          cond = fold_build2 (LT_EXPR, boolean_type_node,\n-\t\t\t      bound, build_int_cst (TREE_TYPE (bound), 0));\n+          cond = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t\t\t\t  bound, build_int_cst (TREE_TYPE (bound), 0));\n           tmp = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (TREE_TYPE (desc))];\n-          tmp = fold_build2 (GE_EXPR, boolean_type_node, bound, tmp);\n-          cond = fold_build2 (TRUTH_ORIF_EXPR, boolean_type_node, cond, tmp);\n+          tmp = fold_build2_loc (input_location, GE_EXPR, boolean_type_node,\n+\t\t\t\t bound, tmp);\n+          cond = fold_build2_loc (input_location, TRUTH_ORIF_EXPR,\n+\t\t\t\t  boolean_type_node, cond, tmp);\n           gfc_trans_runtime_check (true, false, cond, &se->pre, &expr->where,\n \t\t\t\t   gfc_msg_fault);\n         }\n@@ -1025,53 +1037,63 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n     {\n       tree stride = gfc_conv_descriptor_stride_get (desc, bound);\n \n-      cond1 = fold_build2 (GE_EXPR, boolean_type_node, ubound, lbound);\n-\n-      cond3 = fold_build2 (GE_EXPR, boolean_type_node, stride,\n-\t\t\t   gfc_index_zero_node);\n-      cond3 = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, cond3, cond1);\n-\n-      cond4 = fold_build2 (LT_EXPR, boolean_type_node, stride,\n-\t\t\t   gfc_index_zero_node);\n+      cond1 = fold_build2_loc (input_location, GE_EXPR, boolean_type_node,\n+\t\t\t       ubound, lbound);\n+      cond3 = fold_build2_loc (input_location, GE_EXPR, boolean_type_node,\n+\t\t\t       stride, gfc_index_zero_node);\n+      cond3 = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n+\t\t\t       boolean_type_node, cond3, cond1);\n+      cond4 = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t\t\t       stride, gfc_index_zero_node);\n \n       if (upper)\n \t{\n \t  tree cond5;\n-\t  cond = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, cond3, cond4);\n-\n-\t  cond5 = fold_build2 (EQ_EXPR, boolean_type_node, gfc_index_one_node, lbound);\n-\t  cond5 = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, cond4, cond5);\n-\n-\t  cond = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, cond, cond5);\n-\n-\t  se->expr = fold_build3 (COND_EXPR, gfc_array_index_type, cond,\n-\t\t\t\t  ubound, gfc_index_zero_node);\n+\t  cond = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n+\t\t\t\t  boolean_type_node, cond3, cond4);\n+\t  cond5 = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t\t   gfc_index_one_node, lbound);\n+\t  cond5 = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n+\t\t\t\t   boolean_type_node, cond4, cond5);\n+\n+\t  cond = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n+\t\t\t\t  boolean_type_node, cond, cond5);\n+\n+\t  se->expr = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t\t      gfc_array_index_type, cond,\n+\t\t\t\t      ubound, gfc_index_zero_node);\n \t}\n       else\n \t{\n \t  if (as->type == AS_ASSUMED_SIZE)\n-\t    cond = fold_build2 (EQ_EXPR, boolean_type_node, bound,\n-\t\t\t\tbuild_int_cst (TREE_TYPE (bound),\n-\t\t\t\t\t       arg->expr->rank - 1));\n+\t    cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t\t    bound, build_int_cst (TREE_TYPE (bound),\n+\t\t\t\t\t\t\t  arg->expr->rank - 1));\n \t  else\n \t    cond = boolean_false_node;\n \n-\t  cond1 = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, cond3, cond4);\n-\t  cond = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, cond, cond1);\n+\t  cond1 = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n+\t\t\t\t   boolean_type_node, cond3, cond4);\n+\t  cond = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n+\t\t\t\t  boolean_type_node, cond, cond1);\n \n-\t  se->expr = fold_build3 (COND_EXPR, gfc_array_index_type, cond,\n-\t\t\t\t  lbound, gfc_index_one_node);\n+\t  se->expr = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t\t      gfc_array_index_type, cond,\n+\t\t\t\t      lbound, gfc_index_one_node);\n \t}\n     }\n   else\n     {\n       if (upper)\n         {\n-\t  size = fold_build2 (MINUS_EXPR, gfc_array_index_type, ubound, lbound);\n-\t  se->expr = fold_build2 (PLUS_EXPR, gfc_array_index_type, size,\n+\t  size = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t  gfc_array_index_type, ubound, lbound);\n+\t  se->expr = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t      gfc_array_index_type, size,\n \t\t\t\t  gfc_index_one_node);\n-\t  se->expr = fold_build2 (MAX_EXPR, gfc_array_index_type, se->expr,\n-\t\t\t\t  gfc_index_zero_node);\n+\t  se->expr = fold_build2_loc (input_location, MAX_EXPR,\n+\t\t\t\t      gfc_array_index_type, se->expr,\n+\t\t\t\t      gfc_index_zero_node);\n \t}\n       else\n \tse->expr = gfc_index_one_node;\n@@ -1093,7 +1115,8 @@ gfc_conv_intrinsic_abs (gfc_se * se, gfc_expr * expr)\n     {\n     case BT_INTEGER:\n     case BT_REAL:\n-      se->expr = fold_build1 (ABS_EXPR, TREE_TYPE (arg), arg);\n+      se->expr = fold_build1_loc (input_location, ABS_EXPR, TREE_TYPE (arg),\n+\t\t\t\t  arg);\n       break;\n \n     case BT_COMPLEX:\n@@ -1128,14 +1151,14 @@ gfc_conv_intrinsic_cmplx (gfc_se * se, gfc_expr * expr, int both)\n     imag = convert (TREE_TYPE (type), args[1]);\n   else if (TREE_CODE (TREE_TYPE (args[0])) == COMPLEX_TYPE)\n     {\n-      imag = fold_build1 (IMAGPART_EXPR, TREE_TYPE (TREE_TYPE (args[0])),\n-\t\t\t  args[0]);\n+      imag = fold_build1_loc (input_location, IMAGPART_EXPR,\n+\t\t\t      TREE_TYPE (TREE_TYPE (args[0])), args[0]);\n       imag = convert (TREE_TYPE (type), imag);\n     }\n   else\n     imag = build_real_from_int_cst (TREE_TYPE (type), integer_zero_node);\n \n-  se->expr = fold_build2 (COMPLEX_EXPR, type, real, imag);\n+  se->expr = fold_build2_loc (input_location, COMPLEX_EXPR, type, real, imag);\n }\n \n /* Remainder function MOD(A, P) = A - INT(A / P) * P\n@@ -1164,9 +1187,11 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n       type = TREE_TYPE (args[0]);\n \n       if (modulo)\n-       se->expr = fold_build2 (FLOOR_MOD_EXPR, type, args[0], args[1]);\n+       se->expr = fold_build2_loc (input_location, FLOOR_MOD_EXPR, type,\n+\t\t\t\t   args[0], args[1]);\n       else\n-       se->expr = fold_build2 (TRUNC_MOD_EXPR, type, args[0], args[1]);\n+       se->expr = fold_build2_loc (input_location, TRUNC_MOD_EXPR, type,\n+\t\t\t\t   args[0], args[1]);\n       break;\n \n     case BT_REAL:\n@@ -1201,21 +1226,26 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n \t{\n \t  tree zero = gfc_build_const (type, integer_zero_node);\n \t  tmp = gfc_evaluate_now (se->expr, &se->pre);\n-\t  test = fold_build2 (LT_EXPR, boolean_type_node, args[0], zero);\n-\t  test2 = fold_build2 (LT_EXPR, boolean_type_node, args[1], zero);\n-\t  test2 = fold_build2 (TRUTH_XOR_EXPR, boolean_type_node, test, test2);\n-\t  test = fold_build2 (NE_EXPR, boolean_type_node, tmp, zero);\n-\t  test = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, test, test2);\n+\t  test = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t\t\t\t  args[0], zero);\n+\t  test2 = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t\t\t\t   args[1], zero);\n+\t  test2 = fold_build2_loc (input_location, TRUTH_XOR_EXPR,\n+\t\t\t\t   boolean_type_node, test, test2);\n+\t  test = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t\t  tmp, zero);\n+\t  test = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n+\t\t\t\t  boolean_type_node, test, test2);\n \t  test = gfc_evaluate_now (test, &se->pre);\n-\t  se->expr = fold_build3 (COND_EXPR, type, test,\n-\t\t\t\t  fold_build2 (PLUS_EXPR, type, tmp, args[1]),\n-\t\t\t\t  tmp);\n+\t  se->expr = fold_build3_loc (input_location, COND_EXPR, type, test,\n+\t\t\t\t  fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t\t\t   type, tmp, args[1]), tmp);\n \t  return;\n \t}\n \n       /* If we do not have a built_in fmod, the calculation is going to\n \t have to be done longhand.  */\n-      tmp = fold_build2 (RDIV_EXPR, type, args[0], args[1]);\n+      tmp = fold_build2_loc (input_location, RDIV_EXPR, type, args[0], args[1]);\n \n       /* Test if the value is too large to handle sensibly.  */\n       gfc_set_model_kind (expr->ts.kind);\n@@ -1229,22 +1259,27 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n \t}\n       mpfr_set_z (huge, gfc_integer_kinds[n].huge, GFC_RND_MODE);\n       test = gfc_conv_mpfr_to_tree (huge, expr->ts.kind, 0);\n-      test2 = fold_build2 (LT_EXPR, boolean_type_node, tmp, test);\n+      test2 = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t\t\t       tmp, test);\n \n       mpfr_neg (huge, huge, GFC_RND_MODE);\n       test = gfc_conv_mpfr_to_tree (huge, expr->ts.kind, 0);\n-      test = fold_build2 (GT_EXPR, boolean_type_node, tmp, test);\n-      test2 = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, test, test2);\n+      test = fold_build2_loc (input_location, GT_EXPR, boolean_type_node, tmp,\n+\t\t\t      test);\n+      test2 = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n+\t\t\t       boolean_type_node, test, test2);\n \n       itype = gfc_get_int_type (ikind);\n       if (modulo)\n        tmp = build_fix_expr (&se->pre, tmp, itype, RND_FLOOR);\n       else\n        tmp = build_fix_expr (&se->pre, tmp, itype, RND_TRUNC);\n       tmp = convert (type, tmp);\n-      tmp = fold_build3 (COND_EXPR, type, test2, tmp, args[0]);\n-      tmp = fold_build2 (MULT_EXPR, type, tmp, args[1]);\n-      se->expr = fold_build2 (MINUS_EXPR, type, args[0], tmp);\n+      tmp = fold_build3_loc (input_location, COND_EXPR, type, test2, tmp,\n+\t\t\t     args[0]);\n+      tmp = fold_build2_loc (input_location, MULT_EXPR, type, tmp, args[1]);\n+      se->expr = fold_build2_loc (input_location, MINUS_EXPR, type, args[0],\n+\t\t\t\t  tmp);\n       mpfr_clear (huge);\n       break;\n \n@@ -1267,12 +1302,12 @@ gfc_conv_intrinsic_dim (gfc_se * se, gfc_expr * expr)\n   gfc_conv_intrinsic_function_args (se, expr, args, 2);\n   type = TREE_TYPE (args[0]);\n \n-  val = fold_build2 (MINUS_EXPR, type, args[0], args[1]);\n+  val = fold_build2_loc (input_location, MINUS_EXPR, type, args[0], args[1]);\n   val = gfc_evaluate_now (val, &se->pre);\n \n   zero = gfc_build_const (type, integer_zero_node);\n-  tmp = fold_build2 (LE_EXPR, boolean_type_node, val, zero);\n-  se->expr = fold_build3 (COND_EXPR, type, tmp, zero, val);\n+  tmp = fold_build2_loc (input_location, LE_EXPR, boolean_type_node, val, zero);\n+  se->expr = fold_build3_loc (input_location, COND_EXPR, type, tmp, zero, val);\n }\n \n \n@@ -1304,8 +1339,10 @@ gfc_conv_intrinsic_sign (gfc_se * se, gfc_expr * expr)\n \t{\n \t  tree cond, zero;\n \t  zero = build_real_from_int_cst (TREE_TYPE (args[1]), integer_zero_node);\n-\t  cond = fold_build2 (EQ_EXPR, boolean_type_node, args[1], zero);\n-\t  se->expr = fold_build3 (COND_EXPR, TREE_TYPE (args[0]), cond,\n+\t  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t\t  args[1], zero);\n+\t  se->expr = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t\t  TREE_TYPE (args[0]), cond,\n \t\t\t\t  build_call_expr_loc (input_location, abs, 1,\n \t\t\t\t\t\t       args[0]),\n \t\t\t\t  build_call_expr_loc (input_location, tmp, 2,\n@@ -1326,16 +1363,16 @@ gfc_conv_intrinsic_sign (gfc_se * se, gfc_expr * expr)\n \n   /* Construct (A ^ B) >> 31, which generates a bit mask of all zeros if\n      the signs of A and B are the same, and of all ones if they differ.  */\n-  tmp = fold_build2 (BIT_XOR_EXPR, type, args[0], args[1]);\n-  tmp = fold_build2 (RSHIFT_EXPR, type, tmp,\n-\t\t     build_int_cst (type, TYPE_PRECISION (type) - 1));\n+  tmp = fold_build2_loc (input_location, BIT_XOR_EXPR, type, args[0], args[1]);\n+  tmp = fold_build2_loc (input_location, RSHIFT_EXPR, type, tmp,\n+\t\t\t build_int_cst (type, TYPE_PRECISION (type) - 1));\n   tmp = gfc_evaluate_now (tmp, &se->pre);\n \n   /* Construct (A + tmp) ^ tmp, which is A if tmp is zero, and -A if tmp]\n      is all ones (i.e. -1).  */\n-  se->expr = fold_build2 (BIT_XOR_EXPR, type,\n-\t\t\t  fold_build2 (PLUS_EXPR, type, args[0], tmp),\n-\t\t\t  tmp);\n+  se->expr = fold_build2_loc (input_location, BIT_XOR_EXPR, type,\n+\t\t\t      fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t\t       type, args[0], tmp), tmp);\n }\n \n \n@@ -1367,7 +1404,8 @@ gfc_conv_intrinsic_dprod (gfc_se * se, gfc_expr * expr)\n   type = gfc_typenode_for_spec (&expr->ts);\n   args[0] = convert (type, args[0]);\n   args[1] = convert (type, args[1]);\n-  se->expr = fold_build2 (MULT_EXPR, type, args[0], args[1]);\n+  se->expr = fold_build2_loc (input_location, MULT_EXPR, type, args[0],\n+\t\t\t      args[1]);\n }\n \n \n@@ -1387,7 +1425,7 @@ gfc_conv_intrinsic_char (gfc_se * se, gfc_expr * expr)\n   type = gfc_get_char_type (expr->ts.kind);\n   var = gfc_create_var (type, \"char\");\n \n-  arg[0] = fold_build1 (NOP_EXPR, type, arg[0]);\n+  arg[0] = fold_build1_loc (input_location, NOP_EXPR, type, arg[0]);\n   gfc_add_modify (&se->pre, var, arg[0]);\n   se->expr = gfc_build_addr_expr (build_pointer_type (type), var);\n   se->string_length = integer_one_node;\n@@ -1422,8 +1460,8 @@ gfc_conv_intrinsic_ctime (gfc_se * se, gfc_expr * expr)\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   /* Free the temporary afterwards, if necessary.  */\n-  cond = fold_build2 (GT_EXPR, boolean_type_node,\n-\t\t      len, build_int_cst (TREE_TYPE (len), 0));\n+  cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+\t\t\t  len, build_int_cst (TREE_TYPE (len), 0));\n   tmp = gfc_call_free (var);\n   tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&se->post, tmp);\n@@ -1461,8 +1499,8 @@ gfc_conv_intrinsic_fdate (gfc_se * se, gfc_expr * expr)\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   /* Free the temporary afterwards, if necessary.  */\n-  cond = fold_build2 (GT_EXPR, boolean_type_node,\n-\t\t      len, build_int_cst (TREE_TYPE (len), 0));\n+  cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+\t\t\t  len, build_int_cst (TREE_TYPE (len), 0));\n   tmp = gfc_call_free (var);\n   tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&se->post, tmp);\n@@ -1502,8 +1540,8 @@ gfc_conv_intrinsic_ttynam (gfc_se * se, gfc_expr * expr)\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   /* Free the temporary afterwards, if necessary.  */\n-  cond = fold_build2 (GT_EXPR, boolean_type_node,\n-\t\t      len, build_int_cst (TREE_TYPE (len), 0));\n+  cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+\t\t\t  len, build_int_cst (TREE_TYPE (len), 0));\n   tmp = gfc_call_free (var);\n   tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&se->post, tmp);\n@@ -1580,7 +1618,8 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \n       thencase = build2_v (MODIFY_EXPR, mvar, convert (type, val));\n \n-      tmp = fold_build2 (op, boolean_type_node, convert (type, val), mvar);\n+      tmp = fold_build2_loc (input_location, op, boolean_type_node,\n+\t\t\t     convert (type, val), mvar);\n \n       /* FIXME: When the IEEE_ARITHMETIC module is implemented, the call to\n \t __builtin_isnan might be made dependent on that module being loaded,\n@@ -1589,8 +1628,9 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \t{\n \t  isnan = build_call_expr_loc (input_location,\n \t\t\t\t   built_in_decls[BUILT_IN_ISNAN], 1, mvar);\n-\t  tmp = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, tmp,\n-\t\t\t     fold_convert (boolean_type_node, isnan));\n+\t  tmp = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n+\t\t\t\t boolean_type_node, tmp,\n+\t\t\t\t fold_convert (boolean_type_node, isnan));\n \t}\n       tmp = build3_v (COND_EXPR, tmp, thencase,\n \t\t      build_empty_stmt (input_location));\n@@ -1642,8 +1682,8 @@ gfc_conv_intrinsic_minmax_char (gfc_se * se, gfc_expr * expr, int op)\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   /* Free the temporary afterwards, if necessary.  */\n-  cond = fold_build2 (GT_EXPR, boolean_type_node,\n-\t\t      len, build_int_cst (TREE_TYPE (len), 0));\n+  cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+\t\t\t  len, build_int_cst (TREE_TYPE (len), 0));\n   tmp = gfc_call_free (var);\n   tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&se->post, tmp);\n@@ -1841,8 +1881,8 @@ gfc_conv_intrinsic_anyall (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   gfc_conv_expr_val (&arrayse, actual->expr);\n \n   gfc_add_block_to_block (&body, &arrayse.pre);\n-  tmp = fold_build2 (op, boolean_type_node, arrayse.expr,\n-\t\t     build_int_cst (TREE_TYPE (arrayse.expr), 0));\n+  tmp = fold_build2_loc (input_location, op, boolean_type_node, arrayse.expr,\n+\t\t\t build_int_cst (TREE_TYPE (arrayse.expr), 0));\n   tmp = build3_v (COND_EXPR, tmp, found, build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&body, tmp);\n   gfc_add_block_to_block (&body, &arrayse.post);\n@@ -1902,8 +1942,8 @@ gfc_conv_intrinsic_count (gfc_se * se, gfc_expr * expr)\n   /* Generate the loop body.  */\n   gfc_start_scalarized_body (&loop, &body);\n \n-  tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (resvar),\n-\t\t     resvar, build_int_cst (TREE_TYPE (resvar), 1));\n+  tmp = fold_build2_loc (input_location, PLUS_EXPR, TREE_TYPE (resvar),\n+\t\t\t resvar, build_int_cst (TREE_TYPE (resvar), 1));\n   tmp = build2_v (MODIFY_EXPR, resvar, tmp);\n \n   gfc_init_se (&arrayse, NULL);\n@@ -2059,43 +2099,48 @@ gfc_conv_intrinsic_arith (gfc_se * se, gfc_expr * expr, enum tree_code op,\n \n       absX = gfc_create_var (type, \"absX\");\n       gfc_add_modify (&ifblock1, absX,\n-\t\t      fold_build1 (ABS_EXPR, type, arrayse.expr));\n+\t\t      fold_build1_loc (input_location, ABS_EXPR, type,\n+\t\t\t\t       arrayse.expr));\n       val = gfc_create_var (type, \"val\");\n       gfc_add_expr_to_block (&ifblock1, val);\n \n       gfc_init_block (&ifblock2);\n       gfc_add_modify (&ifblock2, val,\n-\t\t      fold_build2 (RDIV_EXPR, type, scale, absX));\n-      res1 = fold_build2 (MULT_EXPR, type, val, val); \n-      res1 = fold_build2 (MULT_EXPR, type, resvar, res1);\n-      res1 = fold_build2 (PLUS_EXPR, type, res1,\n-\t\t\t  gfc_build_const (type, integer_one_node));\n+\t\t      fold_build2_loc (input_location, RDIV_EXPR, type, scale,\n+\t\t\t\t       absX));\n+      res1 = fold_build2_loc (input_location, MULT_EXPR, type, val, val); \n+      res1 = fold_build2_loc (input_location, MULT_EXPR, type, resvar, res1);\n+      res1 = fold_build2_loc (input_location, PLUS_EXPR, type, res1,\n+\t\t\t      gfc_build_const (type, integer_one_node));\n       gfc_add_modify (&ifblock2, resvar, res1);\n       gfc_add_modify (&ifblock2, scale, absX);\n       res1 = gfc_finish_block (&ifblock2); \n \n       gfc_init_block (&ifblock3);\n       gfc_add_modify (&ifblock3, val,\n-\t\t      fold_build2 (RDIV_EXPR, type, absX, scale));\n-      res2 = fold_build2 (MULT_EXPR, type, val, val); \n-      res2 = fold_build2 (PLUS_EXPR, type, resvar, res2);\n+\t\t      fold_build2_loc (input_location, RDIV_EXPR, type, absX,\n+\t\t\t\t       scale));\n+      res2 = fold_build2_loc (input_location, MULT_EXPR, type, val, val); \n+      res2 = fold_build2_loc (input_location, PLUS_EXPR, type, resvar, res2);\n       gfc_add_modify (&ifblock3, resvar, res2);\n       res2 = gfc_finish_block (&ifblock3);\n \n-      cond = fold_build2 (GT_EXPR, boolean_type_node, absX, scale);\n+      cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+\t\t\t      absX, scale);\n       tmp = build3_v (COND_EXPR, cond, res1, res2);\n       gfc_add_expr_to_block (&ifblock1, tmp);  \n       tmp = gfc_finish_block (&ifblock1);\n \n-      cond = fold_build2 (NE_EXPR, boolean_type_node, arrayse.expr,\n-\t\t\t  gfc_build_const (type, integer_zero_node));\n+      cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t      arrayse.expr,\n+\t\t\t      gfc_build_const (type, integer_zero_node));\n \n       tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt (input_location));\n       gfc_add_expr_to_block (&block, tmp);  \n     }\n   else\n     {\n-      tmp = fold_build2 (op, type, resvar, arrayse.expr);\n+      tmp = fold_build2_loc (input_location, op, type, resvar, arrayse.expr);\n       gfc_add_modify (&block, resvar, tmp);\n     }\n \n@@ -2145,7 +2190,7 @@ gfc_conv_intrinsic_arith (gfc_se * se, gfc_expr * expr, enum tree_code op,\n       sqrt = gfc_builtin_decl_for_float_kind (BUILT_IN_SQRT, expr->ts.kind);\n       resvar = build_call_expr_loc (input_location,\n \t\t\t\t    sqrt, 1, resvar);\n-      resvar = fold_build2 (MULT_EXPR, type, scale, resvar);\n+      resvar = fold_build2_loc (input_location, MULT_EXPR, type, scale, resvar);\n     }\n \n   se->expr = resvar;\n@@ -2213,7 +2258,8 @@ gfc_conv_intrinsic_dot_product (gfc_se * se, gfc_expr * expr)\n   arrayse1.ss = arrayss1;\n   gfc_conv_expr_val (&arrayse1, arrayexpr1);\n   if (expr->ts.type == BT_COMPLEX)\n-    arrayse1.expr = fold_build1 (CONJ_EXPR, type, arrayse1.expr);\n+    arrayse1.expr = fold_build1_loc (input_location, CONJ_EXPR, type,\n+\t\t\t\t     arrayse1.expr);\n   gfc_add_block_to_block (&block, &arrayse1.pre);\n \n   /* Make the tree expression for array2.  */\n@@ -2226,13 +2272,15 @@ gfc_conv_intrinsic_dot_product (gfc_se * se, gfc_expr * expr)\n   /* Do the actual product and sum.  */\n   if (expr->ts.type == BT_LOGICAL)\n     {\n-      tmp = fold_build2 (TRUTH_AND_EXPR, type, arrayse1.expr, arrayse2.expr);\n-      tmp = fold_build2 (TRUTH_OR_EXPR, type, resvar, tmp);\n+      tmp = fold_build2_loc (input_location, TRUTH_AND_EXPR, type,\n+\t\t\t     arrayse1.expr, arrayse2.expr);\n+      tmp = fold_build2_loc (input_location, TRUTH_OR_EXPR, type, resvar, tmp);\n     }\n   else\n     {\n-      tmp = fold_build2 (MULT_EXPR, type, arrayse1.expr, arrayse2.expr);\n-      tmp = fold_build2 (PLUS_EXPR, type, resvar, tmp);\n+      tmp = fold_build2_loc (input_location, MULT_EXPR, type, arrayse1.expr,\n+\t\t\t     arrayse2.expr);\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR, type, resvar, tmp);\n     }\n   gfc_add_modify (&block, resvar, tmp);\n \n@@ -2375,8 +2423,9 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \t{\n \t  nonempty = gfc_conv_mpz_to_tree (asize, gfc_index_integer_kind);\n \t  mpz_clear (asize);\n-\t  nonempty = fold_build2 (GT_EXPR, boolean_type_node, nonempty,\n-\t\t\t\t  gfc_index_zero_node);\n+\t  nonempty = fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t\t      boolean_type_node, nonempty,\n+\t\t\t\t      gfc_index_zero_node);\n \t}\n       maskss = NULL;\n     }\n@@ -2411,10 +2460,10 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n      -HUGE for BT_REAL and (-HUGE - 1) for BT_INTEGER; the most positive\n      possible value is HUGE in both cases.  */\n   if (op == GT_EXPR)\n-    tmp = fold_build1 (NEGATE_EXPR, TREE_TYPE (tmp), tmp);\n+    tmp = fold_build1_loc (input_location, NEGATE_EXPR, TREE_TYPE (tmp), tmp);\n   if (op == GT_EXPR && expr->ts.type == BT_INTEGER)\n-    tmp = fold_build2 (MINUS_EXPR, TREE_TYPE (tmp), tmp,\n-\t\t       build_int_cst (type, 1));\n+    tmp = fold_build2_loc (input_location, MINUS_EXPR, TREE_TYPE (tmp), tmp,\n+\t\t\t   build_int_cst (type, 1));\n \n   gfc_add_modify (&se->pre, limit, tmp);\n \n@@ -2430,8 +2479,8 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \n   gcc_assert (loop.dimen == 1);\n   if (nonempty == NULL && maskss == NULL && loop.from[0] && loop.to[0])\n-    nonempty = fold_build2 (LE_EXPR, boolean_type_node, loop.from[0],\n-\t\t\t    loop.to[0]);\n+    nonempty = fold_build2_loc (input_location, LE_EXPR, boolean_type_node,\n+\t\t\t\tloop.from[0], loop.to[0]);\n \n   lab1 = NULL;\n   lab2 = NULL;\n@@ -2442,9 +2491,10 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n      the inner loop.  */\n   if (nonempty != NULL && !HONOR_NANS (DECL_MODE (limit)))\n     gfc_add_modify (&loop.pre, pos,\n-\t\t    fold_build3 (COND_EXPR, gfc_array_index_type,\n-\t\t\t\t nonempty, gfc_index_one_node,\n-\t\t\t\t gfc_index_zero_node));\n+\t\t    fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t\t     gfc_array_index_type,\n+\t\t\t\t     nonempty, gfc_index_one_node,\n+\t\t\t\t     gfc_index_zero_node));\n   else\n     {\n       gfc_add_modify (&loop.pre, pos, gfc_index_zero_node);\n@@ -2490,8 +2540,8 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   /* Remember where we are.  An offset must be added to the loop\n      counter to obtain the required position.  */\n   if (loop.from[0])\n-    tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t       gfc_index_one_node, loop.from[0]);\n+    tmp = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t   gfc_index_one_node, loop.from[0]);\n   else\n     tmp = gfc_index_one_node;\n \n@@ -2503,19 +2553,19 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n       tree ifbody2;\n \n       gfc_start_block (&ifblock2);\n-      tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (pos),\n-\t\t\t loop.loopvar[0], offset);\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR, TREE_TYPE (pos),\n+\t\t\t     loop.loopvar[0], offset);\n       gfc_add_modify (&ifblock2, pos, tmp);\n       ifbody2 = gfc_finish_block (&ifblock2);\n-      cond = fold_build2 (EQ_EXPR, boolean_type_node, pos,\n-\t\t\t  gfc_index_zero_node);\n+      cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, pos,\n+\t\t\t      gfc_index_zero_node);\n       tmp = build3_v (COND_EXPR, cond, ifbody2,\n \t\t      build_empty_stmt (input_location));\n       gfc_add_expr_to_block (&block, tmp);\n     }\n \n-  tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (pos),\n-\t\t     loop.loopvar[0], offset);\n+  tmp = fold_build2_loc (input_location, PLUS_EXPR, TREE_TYPE (pos),\n+\t\t\t loop.loopvar[0], offset);\n   gfc_add_modify (&ifblock, pos, tmp);\n \n   if (lab1)\n@@ -2526,10 +2576,12 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   if (!lab1 || HONOR_NANS (DECL_MODE (limit)))\n     {\n       if (lab1)\n-\tcond = fold_build2 (op == GT_EXPR ? GE_EXPR : LE_EXPR,\n-\t\t\t    boolean_type_node, arrayse.expr, limit);\n+\tcond = fold_build2_loc (input_location,\n+\t\t\t\top == GT_EXPR ? GE_EXPR : LE_EXPR,\n+\t\t\t\tboolean_type_node, arrayse.expr, limit);\n       else\n-\tcond = fold_build2 (op, boolean_type_node, arrayse.expr, limit);\n+\tcond = fold_build2_loc (input_location, op, boolean_type_node,\n+\t\t\t\tarrayse.expr, limit);\n \n       ifbody = build3_v (COND_EXPR, cond, ifbody,\n \t\t\t build_empty_stmt (input_location));\n@@ -2597,20 +2649,21 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n       /* Remember where we are.  An offset must be added to the loop\n \t counter to obtain the required position.  */\n       if (loop.from[0])\n-\ttmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t   gfc_index_one_node, loop.from[0]);\n+\ttmp = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t       gfc_index_one_node, loop.from[0]);\n       else\n \ttmp = gfc_index_one_node;\n \n       gfc_add_modify (&block, offset, tmp);\n \n-      tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (pos),\n-\t\t\t loop.loopvar[0], offset);\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR, TREE_TYPE (pos),\n+\t\t\t     loop.loopvar[0], offset);\n       gfc_add_modify (&ifblock, pos, tmp);\n \n       ifbody = gfc_finish_block (&ifblock);\n \n-      cond = fold_build2 (op, boolean_type_node, arrayse.expr, limit);\n+      cond = fold_build2_loc (input_location, op, boolean_type_node,\n+\t\t\t      arrayse.expr, limit);\n \n       tmp = build3_v (COND_EXPR, cond, ifbody,\n \t\t      build_empty_stmt (input_location));\n@@ -2830,14 +2883,15 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n      possible value is HUGE in both cases.  */\n   if (op == GT_EXPR)\n     {\n-      tmp = fold_build1 (NEGATE_EXPR, TREE_TYPE (tmp), tmp);\n+      tmp = fold_build1_loc (input_location, NEGATE_EXPR, TREE_TYPE (tmp), tmp);\n       if (huge_cst)\n-\thuge_cst = fold_build1 (NEGATE_EXPR, TREE_TYPE (huge_cst), huge_cst);\n+\thuge_cst = fold_build1_loc (input_location, NEGATE_EXPR,\n+\t\t\t\t    TREE_TYPE (huge_cst), huge_cst);\n     }\n \n   if (op == GT_EXPR && expr->ts.type == BT_INTEGER)\n-    tmp = fold_build2 (MINUS_EXPR, TREE_TYPE (tmp),\n-\t\t       tmp, build_int_cst (type, 1));\n+    tmp = fold_build2_loc (input_location, MINUS_EXPR, TREE_TYPE (tmp),\n+\t\t\t   tmp, build_int_cst (type, 1));\n \n   gfc_add_modify (&se->pre, limit, tmp);\n \n@@ -2863,8 +2917,9 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \t{\n \t  nonempty = gfc_conv_mpz_to_tree (asize, gfc_index_integer_kind);\n \t  mpz_clear (asize);\n-\t  nonempty = fold_build2 (GT_EXPR, boolean_type_node, nonempty,\n-\t\t\t\t  gfc_index_zero_node);\n+\t  nonempty = fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t\t      boolean_type_node, nonempty,\n+\t\t\t\t      gfc_index_zero_node);\n \t}\n       maskss = NULL;\n     }\n@@ -2881,8 +2936,8 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \n   if (nonempty == NULL && maskss == NULL\n       && loop.dimen == 1 && loop.from[0] && loop.to[0])\n-    nonempty = fold_build2 (LE_EXPR, boolean_type_node, loop.from[0],\n-\t\t\t    loop.to[0]);\n+    nonempty = fold_build2_loc (input_location, LE_EXPR, boolean_type_node,\n+\t\t\t\tloop.from[0], loop.to[0]);\n   nonempty_var = NULL;\n   if (nonempty == NULL\n       && (HONOR_INFINITIES (DECL_MODE (limit))\n@@ -2942,8 +2997,8 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \n   if (HONOR_NANS (DECL_MODE (limit)))\n     {\n-      tmp = fold_build2 (op == GT_EXPR ? GE_EXPR : LE_EXPR,\n-\t\t\t boolean_type_node, arrayse.expr, limit);\n+      tmp = fold_build2_loc (input_location, op == GT_EXPR ? GE_EXPR : LE_EXPR,\n+\t\t\t     boolean_type_node, arrayse.expr, limit);\n       if (lab)\n \tifbody = build1_v (GOTO_EXPR, lab);\n       else\n@@ -2965,16 +3020,18 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \t signed zeros.  */\n       if (HONOR_SIGNED_ZEROS (DECL_MODE (limit)))\n \t{\n-\t  tmp = fold_build2 (op, boolean_type_node, arrayse.expr, limit);\n+\t  tmp = fold_build2_loc (input_location, op, boolean_type_node,\n+\t\t\t\t arrayse.expr, limit);\n \t  ifbody = build2_v (MODIFY_EXPR, limit, arrayse.expr);\n \t  tmp = build3_v (COND_EXPR, tmp, ifbody,\n \t\t\t  build_empty_stmt (input_location));\n \t  gfc_add_expr_to_block (&block2, tmp);\n \t}\n       else\n \t{\n-\t  tmp = fold_build2 (op == GT_EXPR ? MAX_EXPR : MIN_EXPR,\n-\t\t\t     type, arrayse.expr, limit);\n+\t  tmp = fold_build2_loc (input_location,\n+\t\t\t\t op == GT_EXPR ? MAX_EXPR : MIN_EXPR,\n+\t\t\t\t type, arrayse.expr, limit);\n \t  gfc_add_modify (&block2, limit, tmp);\n \t}\n     }\n@@ -2988,15 +3045,17 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n       if (HONOR_NANS (DECL_MODE (limit))\n \t  || HONOR_SIGNED_ZEROS (DECL_MODE (limit)))\n \t{\n-\t  tmp = fold_build2 (op, boolean_type_node, arrayse.expr, limit);\n+\t  tmp = fold_build2_loc (input_location, op, boolean_type_node,\n+\t\t\t\t arrayse.expr, limit);\n \t  ifbody = build2_v (MODIFY_EXPR, limit, arrayse.expr);\n \t  ifbody = build3_v (COND_EXPR, tmp, ifbody,\n \t\t\t     build_empty_stmt (input_location));\n \t}\n       else\n \t{\n-\t  tmp = fold_build2 (op == GT_EXPR ? MAX_EXPR : MIN_EXPR,\n-\t\t\t     type, arrayse.expr, limit);\n+\t  tmp = fold_build2_loc (input_location,\n+\t\t\t\t op == GT_EXPR ? MAX_EXPR : MIN_EXPR,\n+\t\t\t\t type, arrayse.expr, limit);\n \t  ifbody = build2_v (MODIFY_EXPR, limit, tmp);\n \t}\n       tmp = build3_v (COND_EXPR, fast, ifbody, elsebody);\n@@ -3018,7 +3077,8 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n     {\n       gfc_trans_scalarized_loop_end (&loop, 0, &body);\n \n-      tmp = fold_build3 (COND_EXPR, type, nonempty, nan_cst, huge_cst);\n+      tmp = fold_build3_loc (input_location, COND_EXPR, type, nonempty,\n+\t\t\t     nan_cst, huge_cst);\n       gfc_add_modify (&loop.code[0], limit, tmp);\n       gfc_add_expr_to_block (&loop.code[0], build1_v (LABEL_EXPR, lab));\n \n@@ -3050,16 +3110,18 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n       if (HONOR_NANS (DECL_MODE (limit))\n \t  || HONOR_SIGNED_ZEROS (DECL_MODE (limit)))\n \t{\n-\t  tmp = fold_build2 (op, boolean_type_node, arrayse.expr, limit);\n+\t  tmp = fold_build2_loc (input_location, op, boolean_type_node,\n+\t\t\t\t arrayse.expr, limit);\n \t  ifbody = build2_v (MODIFY_EXPR, limit, arrayse.expr);\n \t  tmp = build3_v (COND_EXPR, tmp, ifbody,\n \t\t\t  build_empty_stmt (input_location));\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n       else\n \t{\n-\t  tmp = fold_build2 (op == GT_EXPR ? MAX_EXPR : MIN_EXPR,\n-\t\t\t     type, arrayse.expr, limit);\n+\t  tmp = fold_build2_loc (input_location,\n+\t\t\t\t op == GT_EXPR ? MAX_EXPR : MIN_EXPR,\n+\t\t\t\t type, arrayse.expr, limit);\n \t  gfc_add_modify (&block, limit, tmp);\n \t}\n \n@@ -3079,15 +3141,17 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \n   if (fast)\n     {\n-      tmp = fold_build3 (COND_EXPR, type, nonempty, nan_cst, huge_cst);\n+      tmp = fold_build3_loc (input_location, COND_EXPR, type, nonempty,\n+\t\t\t     nan_cst, huge_cst);\n       ifbody = build2_v (MODIFY_EXPR, limit, tmp);\n       tmp = build3_v (COND_EXPR, fast, build_empty_stmt (input_location),\n \t\t      ifbody);\n       gfc_add_expr_to_block (&loop.pre, tmp);\n     }\n   else if (HONOR_INFINITIES (DECL_MODE (limit)) && !lab)\n     {\n-      tmp = fold_build3 (COND_EXPR, type, nonempty, limit, huge_cst);\n+      tmp = fold_build3_loc (input_location, COND_EXPR, type, nonempty, limit,\n+\t\t\t     huge_cst);\n       gfc_add_modify (&loop.pre, limit, tmp);\n     }\n \n@@ -3133,10 +3197,11 @@ gfc_conv_intrinsic_btest (gfc_se * se, gfc_expr * expr)\n   gfc_conv_intrinsic_function_args (se, expr, args, 2);\n   type = TREE_TYPE (args[0]);\n \n-  tmp = fold_build2 (LSHIFT_EXPR, type, build_int_cst (type, 1), args[1]);\n-  tmp = fold_build2 (BIT_AND_EXPR, type, args[0], tmp);\n-  tmp = fold_build2 (NE_EXPR, boolean_type_node, tmp,\n-\t\t     build_int_cst (type, 0));\n+  tmp = fold_build2_loc (input_location, LSHIFT_EXPR, type,\n+\t\t\t build_int_cst (type, 1), args[1]);\n+  tmp = fold_build2_loc (input_location, BIT_AND_EXPR, type, args[0], tmp);\n+  tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, tmp,\n+\t\t\t build_int_cst (type, 0));\n   type = gfc_typenode_for_spec (&expr->ts);\n   se->expr = convert (type, tmp);\n }\n@@ -3148,7 +3213,8 @@ gfc_conv_intrinsic_bitop (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   tree args[2];\n \n   gfc_conv_intrinsic_function_args (se, expr, args, 2);\n-  se->expr = fold_build2 (op, TREE_TYPE (args[0]), args[0], args[1]);\n+  se->expr = fold_build2_loc (input_location, op, TREE_TYPE (args[0]),\n+\t\t\t      args[0], args[1]);\n }\n \n /* Bitwise not.  */\n@@ -3158,7 +3224,8 @@ gfc_conv_intrinsic_not (gfc_se * se, gfc_expr * expr)\n   tree arg;\n \n   gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n-  se->expr = fold_build1 (BIT_NOT_EXPR, TREE_TYPE (arg), arg);\n+  se->expr = fold_build1_loc (input_location, BIT_NOT_EXPR,\n+\t\t\t      TREE_TYPE (arg), arg);\n }\n \n /* Set or clear a single bit.  */\n@@ -3173,15 +3240,16 @@ gfc_conv_intrinsic_singlebitop (gfc_se * se, gfc_expr * expr, int set)\n   gfc_conv_intrinsic_function_args (se, expr, args, 2);\n   type = TREE_TYPE (args[0]);\n \n-  tmp = fold_build2 (LSHIFT_EXPR, type, build_int_cst (type, 1), args[1]);\n+  tmp = fold_build2_loc (input_location, LSHIFT_EXPR, type,\n+\t\t\t build_int_cst (type, 1), args[1]);\n   if (set)\n     op = BIT_IOR_EXPR;\n   else\n     {\n       op = BIT_AND_EXPR;\n-      tmp = fold_build1 (BIT_NOT_EXPR, type, tmp);\n+      tmp = fold_build1_loc (input_location, BIT_NOT_EXPR, type, tmp);\n     }\n-  se->expr = fold_build2 (op, type, args[0], tmp);\n+  se->expr = fold_build2_loc (input_location, op, type, args[0], tmp);\n }\n \n /* Extract a sequence of bits.\n@@ -3198,12 +3266,12 @@ gfc_conv_intrinsic_ibits (gfc_se * se, gfc_expr * expr)\n   type = TREE_TYPE (args[0]);\n \n   mask = build_int_cst (type, -1);\n-  mask = fold_build2 (LSHIFT_EXPR, type, mask, args[2]);\n-  mask = fold_build1 (BIT_NOT_EXPR, type, mask);\n+  mask = fold_build2_loc (input_location, LSHIFT_EXPR, type, mask, args[2]);\n+  mask = fold_build1_loc (input_location, BIT_NOT_EXPR, type, mask);\n \n-  tmp = fold_build2 (RSHIFT_EXPR, type, args[0], args[1]);\n+  tmp = fold_build2_loc (input_location, RSHIFT_EXPR, type, args[0], args[1]);\n \n-  se->expr = fold_build2 (BIT_AND_EXPR, type, tmp, mask);\n+  se->expr = fold_build2_loc (input_location, BIT_AND_EXPR, type, tmp, mask);\n }\n \n /* RSHIFT (I, SHIFT) = I >> SHIFT\n@@ -3215,8 +3283,9 @@ gfc_conv_intrinsic_rlshift (gfc_se * se, gfc_expr * expr, int right_shift)\n \n   gfc_conv_intrinsic_function_args (se, expr, args, 2);\n \n-  se->expr = fold_build2 (right_shift ? RSHIFT_EXPR : LSHIFT_EXPR,\n-\t\t\t  TREE_TYPE (args[0]), args[0], args[1]);\n+  se->expr = fold_build2_loc (input_location,\n+\t\t\t      right_shift ? RSHIFT_EXPR : LSHIFT_EXPR,\n+\t\t\t      TREE_TYPE (args[0]), args[0], args[1]);\n }\n \n /* ISHFT (I, SHIFT) = (abs (shift) >= BIT_SIZE (i))\n@@ -3244,31 +3313,32 @@ gfc_conv_intrinsic_ishft (gfc_se * se, gfc_expr * expr)\n   type = TREE_TYPE (args[0]);\n   utype = unsigned_type_for (type);\n \n-  width = fold_build1 (ABS_EXPR, TREE_TYPE (args[1]), args[1]);\n+  width = fold_build1_loc (input_location, ABS_EXPR, TREE_TYPE (args[1]),\n+\t\t\t   args[1]);\n \n   /* Left shift if positive.  */\n-  lshift = fold_build2 (LSHIFT_EXPR, type, args[0], width);\n+  lshift = fold_build2_loc (input_location, LSHIFT_EXPR, type, args[0], width);\n \n   /* Right shift if negative.\n      We convert to an unsigned type because we want a logical shift.\n      The standard doesn't define the case of shifting negative\n      numbers, and we try to be compatible with other compilers, most\n      notably g77, here.  */\n-  rshift = fold_convert (type, fold_build2 (RSHIFT_EXPR, utype, \n-\t\t\t\t\t    convert (utype, args[0]), width));\n+  rshift = fold_convert (type, fold_build2_loc (input_location, RSHIFT_EXPR,\n+\t\t\t\t    utype, convert (utype, args[0]), width));\n \n-  tmp = fold_build2 (GE_EXPR, boolean_type_node, args[1],\n-\t\t     build_int_cst (TREE_TYPE (args[1]), 0));\n-  tmp = fold_build3 (COND_EXPR, type, tmp, lshift, rshift);\n+  tmp = fold_build2_loc (input_location, GE_EXPR, boolean_type_node, args[1],\n+\t\t\t build_int_cst (TREE_TYPE (args[1]), 0));\n+  tmp = fold_build3_loc (input_location, COND_EXPR, type, tmp, lshift, rshift);\n \n   /* The Fortran standard allows shift widths <= BIT_SIZE(I), whereas\n      gcc requires a shift width < BIT_SIZE(I), so we have to catch this\n      special case.  */\n   num_bits = build_int_cst (TREE_TYPE (args[1]), TYPE_PRECISION (type));\n-  cond = fold_build2 (GE_EXPR, boolean_type_node, width, num_bits);\n-\n-  se->expr = fold_build3 (COND_EXPR, type, cond,\n-\t\t\t  build_int_cst (type, 0), tmp);\n+  cond = fold_build2_loc (input_location, GE_EXPR, boolean_type_node, width,\n+\t\t\t  num_bits);\n+  se->expr = fold_build3_loc (input_location, COND_EXPR, type, cond,\n+\t\t\t      build_int_cst (type, 0), tmp);\n }\n \n \n@@ -3341,19 +3411,23 @@ gfc_conv_intrinsic_ishftc (gfc_se * se, gfc_expr * expr)\n   args[1] = gfc_evaluate_now (args[1], &se->pre);\n \n   /* Rotate left if positive.  */\n-  lrot = fold_build2 (LROTATE_EXPR, type, args[0], args[1]);\n+  lrot = fold_build2_loc (input_location, LROTATE_EXPR, type, args[0], args[1]);\n \n   /* Rotate right if negative.  */\n-  tmp = fold_build1 (NEGATE_EXPR, TREE_TYPE (args[1]), args[1]);\n-  rrot = fold_build2 (RROTATE_EXPR, type, args[0], tmp);\n+  tmp = fold_build1_loc (input_location, NEGATE_EXPR, TREE_TYPE (args[1]),\n+\t\t\t args[1]);\n+  rrot = fold_build2_loc (input_location,RROTATE_EXPR, type, args[0], tmp);\n \n   zero = build_int_cst (TREE_TYPE (args[1]), 0);\n-  tmp = fold_build2 (GT_EXPR, boolean_type_node, args[1], zero);\n-  rrot = fold_build3 (COND_EXPR, type, tmp, lrot, rrot);\n+  tmp = fold_build2_loc (input_location, GT_EXPR, boolean_type_node, args[1],\n+\t\t\t zero);\n+  rrot = fold_build3_loc (input_location, COND_EXPR, type, tmp, lrot, rrot);\n \n   /* Do nothing if shift == 0.  */\n-  tmp = fold_build2 (EQ_EXPR, boolean_type_node, args[1], zero);\n-  se->expr = fold_build3 (COND_EXPR, type, tmp, args[0], rrot);\n+  tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, args[1],\n+\t\t\t zero);\n+  se->expr = fold_build3_loc (input_location, COND_EXPR, type, tmp, args[0],\n+\t\t\t      rrot);\n }\n \n /* LEADZ (i) = (i == 0) ? BIT_SIZE (i)\n@@ -3416,15 +3490,16 @@ gfc_conv_intrinsic_leadz (gfc_se * se, gfc_expr * expr)\n   s = TYPE_PRECISION (arg_type) - argsize;\n   tmp = fold_convert (result_type, build_call_expr_loc (input_location, func,\n \t\t\t\t\t\t\t1, arg));\n-  leadz = fold_build2 (MINUS_EXPR, result_type,\n-\t\t       tmp, build_int_cst (result_type, s));\n+  leadz = fold_build2_loc (input_location, MINUS_EXPR, result_type,\n+\t\t\t   tmp, build_int_cst (result_type, s));\n \n   /* Build BIT_SIZE.  */\n   bit_size = build_int_cst (result_type, argsize);\n \n-  cond = fold_build2 (EQ_EXPR, boolean_type_node,\n-\t\t      arg, build_int_cst (arg_type, 0));\n-  se->expr = fold_build3 (COND_EXPR, result_type, cond, bit_size, leadz);\n+  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t  arg, build_int_cst (arg_type, 0));\n+  se->expr = fold_build3_loc (input_location, COND_EXPR, result_type, cond,\n+\t\t\t      bit_size, leadz);\n }\n \n /* TRAILZ(i) = (i == 0) ? BIT_SIZE (i) : __builtin_ctz(i)\n@@ -3485,9 +3560,10 @@ gfc_conv_intrinsic_trailz (gfc_se * se, gfc_expr *expr)\n   /* Build BIT_SIZE.  */\n   bit_size = build_int_cst (result_type, argsize);\n \n-  cond = fold_build2 (EQ_EXPR, boolean_type_node,\n-\t\t      arg, build_int_cst (arg_type, 0));\n-  se->expr = fold_build3 (COND_EXPR, result_type, cond, bit_size, trailz);\n+  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t  arg, build_int_cst (arg_type, 0));\n+  se->expr = fold_build3_loc (input_location, COND_EXPR, result_type, cond,\n+\t\t\t      bit_size, trailz);\n }\n \n /* Using __builtin_popcount for POPCNT and __builtin_parity for POPPAR;\n@@ -3546,17 +3622,19 @@ gfc_conv_intrinsic_popcnt_poppar (gfc_se * se, gfc_expr *expr, int parity)\n \t\t\t\t   fold_convert (long_long_unsigned_type_node,\n \t\t\t\t\t\t arg));\n \n-      arg2 = fold_build2 (RSHIFT_EXPR, utype, arg,\n-\t\t\t  build_int_cst (utype, LONG_LONG_TYPE_SIZE));\n+      arg2 = fold_build2_loc (input_location, RSHIFT_EXPR, utype, arg,\n+\t\t\t      build_int_cst (utype, LONG_LONG_TYPE_SIZE));\n       call2 = build_call_expr_loc (input_location, func, 1,\n \t\t\t\t   fold_convert (long_long_unsigned_type_node,\n \t\t\t\t\t\t arg2));\n \t\t\t  \n       /* Combine the results.  */\n       if (parity)\n-\tse->expr = fold_build2 (BIT_XOR_EXPR, result_type, call1, call2);\n+\tse->expr = fold_build2_loc (input_location, BIT_XOR_EXPR, result_type,\n+\t\t\t\t    call1, call2);\n       else\n-\tse->expr = fold_build2 (PLUS_EXPR, result_type, call1, call2);\n+\tse->expr = fold_build2_loc (input_location, PLUS_EXPR, result_type,\n+\t\t\t\t    call1, call2);\n \n       return;\n     }\n@@ -3767,7 +3845,7 @@ gfc_conv_intrinsic_ichar (gfc_se * se, gfc_expr * expr)\n   gfc_conv_intrinsic_function_args (se, expr, args, 2);\n   gcc_assert (POINTER_TYPE_P (TREE_TYPE (args[1])));\n   pchartype = gfc_get_pchar_type (expr->value.function.actual->expr->ts.kind);\n-  args[1] = fold_build1 (NOP_EXPR, pchartype, args[1]);\n+  args[1] = fold_build1_loc (input_location, NOP_EXPR, pchartype, args[1]);\n   type = gfc_typenode_for_spec (&expr->ts);\n \n   se->expr = build_fold_indirect_ref_loc (input_location,\n@@ -3800,8 +3878,9 @@ gfc_conv_has_intvalue (gfc_se * se, gfc_expr * expr, const int value)\n   tree arg;\n \n   gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n-  se->expr = fold_build2 (EQ_EXPR, gfc_typenode_for_spec (&expr->ts),\n-\t\t\t  arg, build_int_cst (TREE_TYPE (arg), value));\n+  se->expr = fold_build2_loc (input_location, EQ_EXPR,\n+\t\t\t      gfc_typenode_for_spec (&expr->ts),\n+\t\t\t      arg, build_int_cst (TREE_TYPE (arg), value));\n }\n \n \n@@ -3845,8 +3924,8 @@ gfc_conv_intrinsic_merge (gfc_se * se, gfc_expr * expr)\n       se->string_length = len;\n     }\n   type = TREE_TYPE (tsource);\n-  se->expr = fold_build3 (COND_EXPR, type, mask, tsource,\n-\t\t\t  fold_convert (type, fsource));\n+  se->expr = fold_build3_loc (input_location, COND_EXPR, type, mask, tsource,\n+\t\t\t      fold_convert (type, fsource));\n }\n \n \n@@ -3939,17 +4018,18 @@ gfc_conv_intrinsic_spacing (gfc_se * se, gfc_expr * expr)\n \t\t\t     gfc_build_addr_expr (NULL_TREE, e));\n   gfc_add_expr_to_block (&block, tmp);\n \n-  tmp = fold_build2 (MINUS_EXPR, integer_type_node, e, prec);\n-  gfc_add_modify (&block, e, fold_build2 (MAX_EXPR, integer_type_node,\n-\t\t\t\t\t  tmp, emin));\n+  tmp = fold_build2_loc (input_location, MINUS_EXPR, integer_type_node, e,\n+\t\t\t prec);\n+  gfc_add_modify (&block, e, fold_build2_loc (input_location, MAX_EXPR,\n+\t\t\t\t\t      integer_type_node, tmp, emin));\n \n   tmp = build_call_expr_loc (input_location, scalbn, 2,\n \t\t\t build_real_from_int_cst (type, integer_one_node), e);\n   gfc_add_modify (&block, res, tmp);\n \n   /* Finish by building the IF statement.  */\n-  cond = fold_build2 (EQ_EXPR, boolean_type_node, arg,\n-\t\t      build_real_from_int_cst (type, integer_zero_node));\n+  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, arg,\n+\t\t\t  build_real_from_int_cst (type, integer_zero_node));\n   tmp = build3_v (COND_EXPR, cond, build2_v (MODIFY_EXPR, res, tiny),\n \t\t  gfc_finish_block (&block));\n \n@@ -4000,14 +4080,14 @@ gfc_conv_intrinsic_rrspacing (gfc_se * se, gfc_expr * expr)\n \t\t\t     gfc_build_addr_expr (NULL_TREE, e));\n   gfc_add_expr_to_block (&block, tmp);\n \n-  tmp = fold_build2 (MINUS_EXPR, integer_type_node,\n-\t\t     build_int_cst (NULL_TREE, prec), e);\n+  tmp = fold_build2_loc (input_location, MINUS_EXPR, integer_type_node,\n+\t\t\t build_int_cst (NULL_TREE, prec), e);\n   tmp = build_call_expr_loc (input_location, scalbn, 2, x, tmp);\n   gfc_add_modify (&block, x, tmp);\n   stmt = gfc_finish_block (&block);\n \n-  cond = fold_build2 (NE_EXPR, boolean_type_node, x,\n-\t\t      build_real_from_int_cst (type, integer_zero_node));\n+  cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, x,\n+\t\t\t  build_real_from_int_cst (type, integer_zero_node));\n   tmp = build3_v (COND_EXPR, cond, stmt, build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n@@ -4108,17 +4188,18 @@ gfc_conv_intrinsic_size (gfc_se * se, gfc_expr * expr)\n \t  argse.data_not_needed = 1;\n \t  gfc_conv_expr (&argse, actual->expr);\n \t  gfc_add_block_to_block (&se->pre, &argse.pre);\n-\t  tmp = fold_build2 (NE_EXPR, boolean_type_node,\n-\t\t\t     argse.expr, null_pointer_node);\n+\t  tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t\t argse.expr, null_pointer_node);\n \t  tmp = gfc_evaluate_now (tmp, &se->pre);\n-\t  se->expr = fold_build3 (COND_EXPR, pvoid_type_node,\n-\t\t\t\t  tmp, fncall1, fncall0);\n+\t  se->expr = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t\t      pvoid_type_node, tmp, fncall1, fncall0);\n \t}\n       else\n \t{\n \t  se->expr = NULL_TREE;\n-\t  argse.expr = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t\t    argse.expr, gfc_index_one_node);\n+\t  argse.expr = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t\tgfc_array_index_type,\n+\t\t\t\t\targse.expr, gfc_index_one_node);\n \t}\n     }\n   else if (expr->value.function.actual->expr->rank == 1)\n@@ -4137,12 +4218,14 @@ gfc_conv_intrinsic_size (gfc_se * se, gfc_expr * expr)\n \t\t\t\t      arg1);\n       ubound = gfc_conv_descriptor_ubound_get (arg1, argse.expr);\n       lbound = gfc_conv_descriptor_lbound_get (arg1, argse.expr);\n-      se->expr = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t      ubound, lbound);\n-      se->expr = fold_build2 (PLUS_EXPR, gfc_array_index_type, se->expr,\n-\t\t\t      gfc_index_one_node);\n-      se->expr = fold_build2 (MAX_EXPR, gfc_array_index_type, se->expr,\n-\t\t\t      gfc_index_zero_node);\n+      se->expr = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t  gfc_array_index_type, ubound, lbound);\n+      se->expr = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t  gfc_array_index_type,\n+\t\t\t\t  se->expr, gfc_index_one_node);\n+      se->expr = fold_build2_loc (input_location, MAX_EXPR,\n+\t\t\t\t  gfc_array_index_type, se->expr,\n+\t\t\t\t  gfc_index_zero_node);\n     }\n \n   type = gfc_typenode_for_spec (&expr->ts);\n@@ -4163,8 +4246,9 @@ size_of_string_in_bytes (int kind, tree string_length)\n   bytesize = build_int_cst (gfc_array_index_type,\n \t\t\t    gfc_character_kinds[i].bit_size / 8);\n \n-  return fold_build2 (MULT_EXPR, gfc_array_index_type, bytesize,\n-\t\t      fold_convert (gfc_array_index_type, string_length));\n+  return fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t  bytesize,\n+\t\t\t  fold_convert (gfc_array_index_type, string_length));\n }\n \n \n@@ -4225,12 +4309,12 @@ gfc_conv_intrinsic_sizeof (gfc_se *se, gfc_expr *expr)\n \t  idx = gfc_rank_cst[n];\n \t  lower = gfc_conv_descriptor_lbound_get (argse.expr, idx);\n \t  upper = gfc_conv_descriptor_ubound_get (argse.expr, idx);\n-\t  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t     upper, lower);\n-\t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t     tmp, gfc_index_one_node);\n-\t  tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t     tmp, source_bytes);\n+\t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t gfc_array_index_type, upper, lower);\n+\t  tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t gfc_array_index_type, tmp, gfc_index_one_node);\n+\t  tmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t gfc_array_index_type, tmp, source_bytes);\n \t  gfc_add_modify (&argse.pre, source_bytes, tmp);\n \t}\n       se->expr = source_bytes;\n@@ -4285,7 +4369,8 @@ gfc_conv_intrinsic_storage_size (gfc_se *se, gfc_expr *expr)\n     tmp = fold_convert (result_type, size_in_bytes (type)); \n \n done:\n-  se->expr = fold_build2 (MULT_EXPR, result_type, tmp, eight.expr);\n+  se->expr = fold_build2_loc (input_location, MULT_EXPR, result_type, tmp,\n+\t\t\t      eight.expr);\n   gfc_add_block_to_block (&se->pre, &argse.pre);\n }\n \n@@ -4303,8 +4388,9 @@ gfc_conv_intrinsic_strcmp (gfc_se * se, gfc_expr * expr, enum tree_code op)\n     = gfc_build_compare_string (args[0], args[1], args[2], args[3],\n \t\t\t\texpr->value.function.actual->expr->ts.kind,\n \t\t\t\top);\n-  se->expr = fold_build2 (op, gfc_typenode_for_spec (&expr->ts), se->expr,\n-\t\t\t  build_int_cst (TREE_TYPE (se->expr), 0));\n+  se->expr = fold_build2_loc (input_location, op,\n+\t\t\t      gfc_typenode_for_spec (&expr->ts), se->expr,\n+\t\t\t      build_int_cst (TREE_TYPE (se->expr), 0));\n }\n \n /* Generate a call to the adjustl/adjustr library function.  */\n@@ -4442,7 +4528,8 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n \t  /* Clean up if it was repacked.  */\n \t  gfc_init_block (&block);\n \t  tmp = gfc_conv_array_data (argse.expr);\n-\t  tmp = fold_build2 (NE_EXPR, boolean_type_node, source, tmp);\n+\t  tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t\t source, tmp);\n \t  tmp = build3_v (COND_EXPR, tmp, stmt,\n \t\t\t  build_empty_stmt (input_location));\n \t  gfc_add_expr_to_block (&block, tmp);\n@@ -4468,13 +4555,14 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n \t  gfc_add_modify (&argse.pre, source_bytes, tmp);\n \t  lower = gfc_conv_descriptor_lbound_get (argse.expr, idx);\n \t  upper = gfc_conv_descriptor_ubound_get (argse.expr, idx);\n-\t  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t     upper, lower);\n+\t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t gfc_array_index_type, upper, lower);\n \t  gfc_add_modify (&argse.pre, extent, tmp);\n-\t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t     extent, gfc_index_one_node);\n-\t  tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t     tmp, source_bytes);\n+\t  tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t gfc_array_index_type, extent,\n+\t\t\t\t gfc_index_one_node);\n+\t  tmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t gfc_array_index_type, tmp, source_bytes);\n \t}\n     }\n \n@@ -4552,15 +4640,16 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n \n   size_bytes = gfc_create_var (gfc_array_index_type, NULL);\n   if (tmp != NULL_TREE)\n-    tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t       tmp, dest_word_len);\n+    tmp = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t   tmp, dest_word_len);\n   else\n     tmp = source_bytes;\n \n   gfc_add_modify (&se->pre, size_bytes, tmp);\n   gfc_add_modify (&se->pre, size_words,\n-\t\t       fold_build2 (CEIL_DIV_EXPR, gfc_array_index_type,\n-\t\t\t\t    size_bytes, dest_word_len));\n+\t\t       fold_build2_loc (input_location, CEIL_DIV_EXPR,\n+\t\t\t\t\tgfc_array_index_type,\n+\t\t\t\t\tsize_bytes, dest_word_len));\n \n   /* Evaluate the bounds of the result.  If the loop range exists, we have\n      to check if it is too large.  If so, we modify loop->to be consistent\n@@ -4569,25 +4658,26 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n   n = se->loop->order[0];\n   if (se->loop->to[n] != NULL_TREE)\n     {\n-      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t se->loop->to[n], se->loop->from[n]);\n-      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t tmp, gfc_index_one_node);\n-      tmp = fold_build2 (MIN_EXPR, gfc_array_index_type,\n+      tmp = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t     se->loop->to[n], se->loop->from[n]);\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     tmp, gfc_index_one_node);\n+      tmp = fold_build2_loc (input_location, MIN_EXPR, gfc_array_index_type,\n \t\t\t tmp, size_words);\n       gfc_add_modify (&se->pre, size_words, tmp);\n       gfc_add_modify (&se->pre, size_bytes,\n-\t\t\t   fold_build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t\t\tsize_words, dest_word_len));\n-      upper = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t   size_words, se->loop->from[n]);\n-      upper = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t   upper, gfc_index_one_node);\n+\t\t\t   fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t\t    gfc_array_index_type,\n+\t\t\t\t\t    size_words, dest_word_len));\n+      upper = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t       size_words, se->loop->from[n]);\n+      upper = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t       upper, gfc_index_one_node);\n     }\n   else\n     {\n-      upper = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t   size_words, gfc_index_one_node);\n+      upper = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t       size_words, gfc_index_one_node);\n       se->loop->from[n] = gfc_index_zero_node;\n     }\n \n@@ -4609,8 +4699,9 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n \t\t\t 3,\n \t\t\t tmp,\n \t\t\t fold_convert (pvoid_type_node, source),\n-\t\t\t fold_build2 (MIN_EXPR, gfc_array_index_type,\n-\t\t\t\t      size_bytes, source_bytes));\n+\t\t\t fold_build2_loc (input_location, MIN_EXPR,\n+\t\t\t\t\t  gfc_array_index_type,\n+\t\t\t\t\t  size_bytes, source_bytes));\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   se->expr = info->descriptor;\n@@ -4621,10 +4712,10 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n \n /* Deal with scalar results.  */\n scalar_transfer:\n-  extent = fold_build2 (MIN_EXPR, gfc_array_index_type,\n-\t\t\tdest_word_len, source_bytes);\n-  extent = fold_build2 (MAX_EXPR, gfc_array_index_type,\n-\t\t\textent, gfc_index_zero_node);\n+  extent = fold_build2_loc (input_location, MIN_EXPR, gfc_array_index_type,\n+\t\t\t    dest_word_len, source_bytes);\n+  extent = fold_build2_loc (input_location, MAX_EXPR, gfc_array_index_type,\n+\t\t\t    extent, gfc_index_zero_node);\n \n   if (expr->ts.type == BT_CHARACTER)\n     {\n@@ -4657,8 +4748,8 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n       indirect = gfc_finish_block (&block);\n \n       /* Wrap it up with the condition.  */\n-      tmp = fold_build2 (LE_EXPR, boolean_type_node,\n-\t\t\t dest_word_len, source_bytes);\n+      tmp = fold_build2_loc (input_location, LE_EXPR, boolean_type_node,\n+\t\t\t     dest_word_len, source_bytes);\n       tmp = build3_v (COND_EXPR, tmp, direct, indirect);\n       gfc_add_expr_to_block (&se->pre, tmp);\n \n@@ -4717,8 +4808,8 @@ gfc_conv_allocated (gfc_se *se, gfc_expr *expr)\n       tmp = gfc_conv_descriptor_data_get (arg1se.expr);\n     }\n \n-  tmp = fold_build2 (NE_EXPR, boolean_type_node,\n-\t\t     tmp, fold_convert (TREE_TYPE (tmp), null_pointer_node));\n+  tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, tmp,\n+\t\t\t fold_convert (TREE_TYPE (tmp), null_pointer_node));\n   se->expr = convert (gfc_typenode_for_spec (&expr->ts), tmp);\n }\n \n@@ -4768,8 +4859,8 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n         }\n       gfc_add_block_to_block (&se->pre, &arg1se.pre);\n       gfc_add_block_to_block (&se->post, &arg1se.post);\n-      tmp = fold_build2 (NE_EXPR, boolean_type_node, tmp2,\n-\t\t\t fold_convert (TREE_TYPE (tmp2), null_pointer_node));\n+      tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, tmp2,\n+\t\t\t     fold_convert (TREE_TYPE (tmp2), null_pointer_node));\n       se->expr = tmp;\n     }\n   else\n@@ -4781,9 +4872,10 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n \n       nonzero_charlen = NULL_TREE;\n       if (arg1->expr->ts.type == BT_CHARACTER)\n-\tnonzero_charlen = fold_build2 (NE_EXPR, boolean_type_node,\n-\t\t\t\t       arg1->expr->ts.u.cl->backend_decl,\n-\t\t\t\t       integer_zero_node);\n+\tnonzero_charlen = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t\t   boolean_type_node,\n+\t\t\t\t\t   arg1->expr->ts.u.cl->backend_decl,\n+\t\t\t\t\t   integer_zero_node);\n \n       if (ss1 == gfc_ss_terminator)\n         {\n@@ -4795,12 +4887,12 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n           gfc_conv_expr (&arg2se, arg2->expr);\n \t  gfc_add_block_to_block (&se->pre, &arg1se.pre);\n \t  gfc_add_block_to_block (&se->post, &arg1se.post);\n-          tmp = fold_build2 (EQ_EXPR, boolean_type_node,\n-\t\t\t     arg1se.expr, arg2se.expr);\n-          tmp2 = fold_build2 (NE_EXPR, boolean_type_node,\n-\t\t\t      arg1se.expr, null_pointer_node);\n-          se->expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t  tmp, tmp2);\n+          tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t\t arg1se.expr, arg2se.expr);\n+          tmp2 = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t\t  arg1se.expr, null_pointer_node);\n+          se->expr = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n+\t\t\t\t      boolean_type_node, tmp, tmp2);\n         }\n       else\n         {\n@@ -4810,8 +4902,9 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n \t  gfc_conv_expr_lhs (&arg1se, arg1->expr);\n \t  tmp = gfc_conv_descriptor_stride_get (arg1se.expr,\n \t\t\t\t\t    gfc_rank_cst[arg1->expr->rank - 1]);\n-\t  nonzero_arraylen = fold_build2 (NE_EXPR, boolean_type_node, tmp,\n-\t\t\t\t\t  build_int_cst (TREE_TYPE (tmp), 0));\n+\t  nonzero_arraylen = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t\t      boolean_type_node, tmp,\n+\t\t\t\t\t      build_int_cst (TREE_TYPE (tmp), 0));\n \n           /* A pointer to an array, call library function _gfor_associated.  */\n           gcc_assert (ss2 != gfc_ss_terminator);\n@@ -4826,15 +4919,17 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n \t\t\t\t      gfor_fndecl_associated, 2,\n \t\t\t\t      arg1se.expr, arg2se.expr);\n \t  se->expr = convert (boolean_type_node, se->expr);\n-\t  se->expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t  se->expr, nonzero_arraylen);\n+\t  se->expr = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n+\t\t\t\t      boolean_type_node, se->expr,\n+\t\t\t\t      nonzero_arraylen);\n         }\n \n       /* If target is present zero character length pointers cannot\n \t be associated.  */\n       if (nonzero_charlen != NULL_TREE)\n-\tse->expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\tse->expr, nonzero_charlen);\n+\tse->expr = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n+\t\t\t\t    boolean_type_node,\n+\t\t\t\t    se->expr, nonzero_charlen);\n     }\n \n   se->expr = convert (gfc_typenode_for_spec (&expr->ts), se->expr);\n@@ -4878,8 +4973,8 @@ gfc_conv_same_type_as (gfc_se *se, gfc_expr *expr)\n   gfc_conv_expr (&se1, a);\n   gfc_conv_expr (&se2, b);\n \n-  tmp = fold_build2 (EQ_EXPR, boolean_type_node,\n-\t\t     se1.expr, fold_convert (TREE_TYPE (se1.expr), se2.expr));\n+  tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t se1.expr, fold_convert (TREE_TYPE (se1.expr), se2.expr));\n   se->expr = convert (gfc_typenode_for_spec (&expr->ts), tmp);\n }\n \n@@ -5004,8 +5099,8 @@ gfc_conv_intrinsic_trim (gfc_se * se, gfc_expr * expr)\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   /* Free the temporary afterwards, if necessary.  */\n-  cond = fold_build2 (GT_EXPR, boolean_type_node,\n-\t\t      len, build_int_cst (TREE_TYPE (len), 0));\n+  cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+\t\t\t  len, build_int_cst (TREE_TYPE (len), 0));\n   tmp = gfc_call_free (var);\n   tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&se->post, tmp);\n@@ -5038,8 +5133,8 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n   ncopies_type = TREE_TYPE (ncopies);\n \n   /* Check that NCOPIES is not negative.  */\n-  cond = fold_build2 (LT_EXPR, boolean_type_node, ncopies,\n-\t\t      build_int_cst (ncopies_type, 0));\n+  cond = fold_build2_loc (input_location, LT_EXPR, boolean_type_node, ncopies,\n+\t\t\t  build_int_cst (ncopies_type, 0));\n   gfc_trans_runtime_check (true, false, cond, &se->pre, &expr->where,\n \t\t\t   \"Argument NCOPIES of REPEAT intrinsic is negative \"\n \t\t\t   \"(its value is %lld)\",\n@@ -5048,10 +5143,10 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n   /* If the source length is zero, any non negative value of NCOPIES\n      is valid, and nothing happens.  */\n   n = gfc_create_var (ncopies_type, \"ncopies\");\n-  cond = fold_build2 (EQ_EXPR, boolean_type_node, slen,\n-\t\t      build_int_cst (size_type_node, 0));\n-  tmp = fold_build3 (COND_EXPR, ncopies_type, cond,\n-\t\t     build_int_cst (ncopies_type, 0), ncopies);\n+  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, slen,\n+\t\t\t  build_int_cst (size_type_node, 0));\n+  tmp = fold_build3_loc (input_location, COND_EXPR, ncopies_type, cond,\n+\t\t\t build_int_cst (ncopies_type, 0), ncopies);\n   gfc_add_modify (&se->pre, n, tmp);\n   ncopies = n;\n \n@@ -5061,24 +5156,24 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n      case to avoid the division by zero.  */\n   i = gfc_validate_kind (BT_INTEGER, gfc_charlen_int_kind, false);\n   max = gfc_conv_mpz_to_tree (gfc_integer_kinds[i].huge, gfc_charlen_int_kind);\n-  max = fold_build2 (TRUNC_DIV_EXPR, size_type_node,\n-\t\t     fold_convert (size_type_node, max), slen);\n+  max = fold_build2_loc (input_location, TRUNC_DIV_EXPR, size_type_node,\n+\t\t\t  fold_convert (size_type_node, max), slen);\n   largest = TYPE_PRECISION (size_type_node) > TYPE_PRECISION (ncopies_type)\n \t      ? size_type_node : ncopies_type;\n-  cond = fold_build2 (GT_EXPR, boolean_type_node,\n-\t\t      fold_convert (largest, ncopies),\n-\t\t      fold_convert (largest, max));\n-  tmp = fold_build2 (EQ_EXPR, boolean_type_node, slen,\n-\t\t     build_int_cst (size_type_node, 0));\n-  cond = fold_build3 (COND_EXPR, boolean_type_node, tmp, boolean_false_node,\n-\t\t      cond);\n+  cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+\t\t\t  fold_convert (largest, ncopies),\n+\t\t\t  fold_convert (largest, max));\n+  tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, slen,\n+\t\t\t build_int_cst (size_type_node, 0));\n+  cond = fold_build3_loc (input_location, COND_EXPR, boolean_type_node, tmp,\n+\t\t\t  boolean_false_node, cond);\n   gfc_trans_runtime_check (true, false, cond, &se->pre, &expr->where,\n \t\t\t   \"Argument NCOPIES of REPEAT intrinsic is too large\");\n \n   /* Compute the destination length.  */\n-  dlen = fold_build2 (MULT_EXPR, gfc_charlen_type_node,\n-\t\t      fold_convert (gfc_charlen_type_node, slen),\n-\t\t      fold_convert (gfc_charlen_type_node, ncopies));\n+  dlen = fold_build2_loc (input_location, MULT_EXPR, gfc_charlen_type_node,\n+\t\t\t  fold_convert (gfc_charlen_type_node, slen),\n+\t\t\t  fold_convert (gfc_charlen_type_node, ncopies));\n   type = gfc_get_character_type (expr->ts.kind, expr->ts.u.cl);\n   dest = gfc_conv_string_tmp (se, build_pointer_type (type), dlen);\n \n@@ -5094,31 +5189,34 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n   gfc_start_block (&body);\n \n   /* Exit the loop if count >= ncopies.  */\n-  cond = fold_build2 (GE_EXPR, boolean_type_node, count, ncopies);\n+  cond = fold_build2_loc (input_location, GE_EXPR, boolean_type_node, count,\n+\t\t\t  ncopies);\n   tmp = build1_v (GOTO_EXPR, exit_label);\n   TREE_USED (exit_label) = 1;\n-  tmp = fold_build3 (COND_EXPR, void_type_node, cond, tmp,\n-\t\t     build_empty_stmt (input_location));\n+  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond, tmp,\n+\t\t\t build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&body, tmp);\n \n   /* Call memmove (dest + (i*slen*size), src, slen*size).  */\n-  tmp = fold_build2 (MULT_EXPR, gfc_charlen_type_node,\n-\t\t     fold_convert (gfc_charlen_type_node, slen),\n-\t\t     fold_convert (gfc_charlen_type_node, count));\n-  tmp = fold_build2 (MULT_EXPR, gfc_charlen_type_node,\n-\t\t     tmp, fold_convert (gfc_charlen_type_node, size));\n-  tmp = fold_build2 (POINTER_PLUS_EXPR, pvoid_type_node,\n-\t\t     fold_convert (pvoid_type_node, dest),\n-\t\t     fold_convert (sizetype, tmp));\n+  tmp = fold_build2_loc (input_location, MULT_EXPR, gfc_charlen_type_node,\n+\t\t\t fold_convert (gfc_charlen_type_node, slen),\n+\t\t\t fold_convert (gfc_charlen_type_node, count));\n+  tmp = fold_build2_loc (input_location, MULT_EXPR, gfc_charlen_type_node,\n+\t\t\t tmp, fold_convert (gfc_charlen_type_node, size));\n+  tmp = fold_build2_loc (input_location, POINTER_PLUS_EXPR, pvoid_type_node,\n+\t\t\t fold_convert (pvoid_type_node, dest),\n+\t\t\t fold_convert (sizetype, tmp));\n   tmp = build_call_expr_loc (input_location,\n-\t\t\t built_in_decls[BUILT_IN_MEMMOVE], 3, tmp, src,\n-\t\t\t fold_build2 (MULT_EXPR, size_type_node, slen,\n-\t\t\t\t      fold_convert (size_type_node, size)));\n+\t\t\t     built_in_decls[BUILT_IN_MEMMOVE], 3, tmp, src,\n+\t\t\t     fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t\t      size_type_node, slen,\n+\t\t\t\t\t      fold_convert (size_type_node,\n+\t\t\t\t\t\t\t    size)));\n   gfc_add_expr_to_block (&body, tmp);\n \n   /* Increment count.  */\n-  tmp = fold_build2 (PLUS_EXPR, ncopies_type,\n-\t\t     count, build_int_cst (TREE_TYPE (count), 1));\n+  tmp = fold_build2_loc (input_location, PLUS_EXPR, ncopies_type,\n+\t\t\t count, build_int_cst (TREE_TYPE (count), 1));\n   gfc_add_modify (&body, count, tmp);\n \n   /* Build the loop.  */"}]}