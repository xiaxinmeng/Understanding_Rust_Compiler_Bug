{"sha": "345ed1fe96a21671979f900d0d9075f225804a7a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ1ZWQxZmU5NmEyMTY3MTk3OWY5MDBkMGQ5MDc1ZjIyNTgwNGE3YQ==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@codesourcery.com", "date": "2000-04-22T11:49:16Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2000-04-22T11:49:16Z"}, "message": "diagnostic.h: New file.\n\n2000-04-22  Gabriel Dos Reis  <gdr@codesourcery.com>\n\n        * diagnostic.h: New file.\n\n        * Makefile.in (diagnostic.o): Depends on diagnostic.h\n\n        * diagnostic.c: Tweak.  Rationalize the output logic.  Adjust\n        various function prototypes.\n        (diagnostic.h): #include.\n        (struct output_buffer): Move into diagnostic.h.\n        (get_output_prefix): Rename to output_get_prefix.  Export.\n        (init_output_buffer): Export. Break out.  Ajust intialization.\n        (output_space_left, output_append): Export.\n        (output_newline): Rename to output_add_newline.  Export.\n        (output_clear): Nullify additional output_buffer fields.\n        (output_puts): Rename to output_add_string.  Export.\n        (dump_output): Rename to output_flush_on.  Export.\n        (build_location_prefix): Constify return-type.\n        (emit_output_prefix): Rename to output_emit_prefix. Export.\n        (set_real_maximum_length): New function.\n        (output_set_maximum_length): Ditto\n        (output_clear): Ditto.\n        (output_add_character): Ditto.\n        (output_add_integer): Ditto.\n        (output_add_space): Ditto.\n        (output_format): Ditto.\n        (output_printf): Adjust buffer initialization.\n        (vline_wrapper_message_with_location): Ditto.\n        (v_message_with_decl): Ditto.  Adjust call to output_puts\n        and get_output_prefix.\n        (default_print_error_function): Adjust buffer intialization.\n\nFrom-SVN: r33337", "tree": {"sha": "0f2cf6c7437414df4f5307941db234dbd22b8373", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f2cf6c7437414df4f5307941db234dbd22b8373"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/345ed1fe96a21671979f900d0d9075f225804a7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/345ed1fe96a21671979f900d0d9075f225804a7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/345ed1fe96a21671979f900d0d9075f225804a7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/345ed1fe96a21671979f900d0d9075f225804a7a/comments", "author": null, "committer": null, "parents": [{"sha": "219fe89837351e72273863b6dc54ca4c5d2ddb6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/219fe89837351e72273863b6dc54ca4c5d2ddb6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/219fe89837351e72273863b6dc54ca4c5d2ddb6c"}], "stats": {"total": 492, "additions": 375, "deletions": 117}, "files": [{"sha": "6ca390b1269e454830bfabe7654065e6c485f6ae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345ed1fe96a21671979f900d0d9075f225804a7a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345ed1fe96a21671979f900d0d9075f225804a7a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=345ed1fe96a21671979f900d0d9075f225804a7a", "patch": "@@ -1,3 +1,35 @@\n+2000-04-22  Gabriel Dos Reis  <gdr@codesourcery.com>\n+\n+\t* diagnostic.h: New file.\n+\n+\t* Makefile.in (diagnostic.o): Depends on diagnostic.h\n+\n+        * diagnostic.c: Tweak.  Rationalize the output logic.  Adjust\n+\tvarious function prototypes.\n+        (diagnostic.h): #include.\n+        (struct output_buffer): Move into diagnostic.h.\n+        (get_output_prefix): Rename to output_get_prefix.  Export.\n+        (init_output_buffer): Export. Break out.  Ajust intialization.\n+        (output_space_left, output_append): Export.\n+        (output_newline): Rename to output_add_newline.  Export.\n+\t(output_clear): Nullify additional output_buffer fields.\n+        (output_puts): Rename to output_add_string.  Export.\n+        (dump_output): Rename to output_flush_on.  Export.\n+        (build_location_prefix): Constify return-type.\n+        (emit_output_prefix): Rename to output_emit_prefix. Export.\n+        (set_real_maximum_length): New function.\n+        (output_set_maximum_length): Ditto\n+        (output_clear): Ditto.\n+        (output_add_character): Ditto.\n+        (output_add_integer): Ditto.\n+        (output_add_space): Ditto.\n+        (output_format): Ditto.\n+        (output_printf): Adjust buffer initialization.\n+        (vline_wrapper_message_with_location): Ditto.\n+        (v_message_with_decl): Ditto.  Adjust call to output_puts\n+\tand get_output_prefix.\n+        (default_print_error_function): Adjust buffer intialization.\n+\n Sat Apr 22 06:45:04 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* expr.c (preexpand_calls, case CALL_EXPR): Don't look at TYPE_SIZE"}, {"sha": "887ee8993752e93dcbf8b3e4e48873baf9cfe893", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345ed1fe96a21671979f900d0d9075f225804a7a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345ed1fe96a21671979f900d0d9075f225804a7a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=345ed1fe96a21671979f900d0d9075f225804a7a", "patch": "@@ -1497,9 +1497,10 @@ print-tree.o : print-tree.c $(CONFIG_H) system.h $(TREE_H) $(GGC_H)\n stor-layout.o : stor-layout.c $(CONFIG_H) system.h $(TREE_H) flags.h \\\n    function.h $(EXPR_H) $(RTL_H) toplev.h $(GGC_H)\n fold-const.o : fold-const.c $(CONFIG_H) system.h $(TREE_H) flags.h toplev.h \\\n-   $(RTL_H) $(GGC_H)\n-diagnostic.o : diagnostic.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) tm_p.h flags.h \\\n-   input.h insn-attr.h insn-codes.h insn-config.h toplev.h intl.h \n+   $(RTL_H) ggc.h\n+diagnostic.o : diagnostic.c diagnostic.h \\\n+   $(CONFIG_H) system.h $(TREE_H) $(RTL_H) tm_p.h flags.h \\\n+   $(GGC_H) input.h insn-attr.h insn-codes.h insn-config.h toplev.h intl.h \n toplev.o : toplev.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) function.h \\\n    flags.h input.h insn-attr.h xcoffout.h defaults.h output.h \\\n    insn-codes.h insn-config.h intl.h $(RECOG_H) Makefile toplev.h dwarfout.h \\"}, {"sha": "28b6998de339f6a5cf93d58f54329a86b22a4532", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 243, "deletions": 114, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345ed1fe96a21671979f900d0d9075f225804a7a/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345ed1fe96a21671979f900d0d9075f225804a7a/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=345ed1fe96a21671979f900d0d9075f225804a7a", "patch": "@@ -1,4 +1,4 @@\n-/* Top level of GNU C compiler\n+/* Language-independent diagnostic subroutines for the GNU C compiler\n    Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n@@ -37,38 +37,19 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-config.h\"\n #include \"toplev.h\"\n #include \"intl.h\"\n-#include \"obstack.h\"\n+#include \"diagnostic.h\"\n \n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free  free\n \n-struct output_buffer\n-{\n-  struct obstack obstack;       /* where we build the text to output */\n-  char *prefix;                 /* prefix of every new line  */\n-  int line_length;              /* current line length (in characters) */\n-  int max_length;               /* maximum characters per line */\n-};\n-\n /* Prototypes. */\n static int doing_line_wrapping PARAMS ((void));\n-static void init_output_buffer PARAMS ((struct output_buffer*, char *, int));\n-static char *get_output_prefix PARAMS ((const struct output_buffer *));\n-static int output_space_left PARAMS ((const struct output_buffer *));\n-static void emit_output_prefix PARAMS ((struct output_buffer *));\n-static void output_newline PARAMS ((struct output_buffer *));\n-static void output_append PARAMS ((struct output_buffer *, const char *,\n-\t\t\t\t   const char *));\n-static void output_puts PARAMS ((struct output_buffer *, const char *));\n-static void dump_output PARAMS ((struct output_buffer *, FILE *));\n-static char *vbuild_message_string PARAMS ((const char *, va_list));\n-static char *build_message_string PARAMS ((const char *, ...))\n+\n+static const char *vbuild_message_string PARAMS ((const char *, va_list));\n+static const char *build_message_string PARAMS ((const char *, ...))\n      ATTRIBUTE_PRINTF_1;\n-static char *build_location_prefix PARAMS ((const char *, int, int));\n-static void voutput_notice PARAMS ((struct output_buffer *, const char *,\n-\t\t\t\t    va_list));\n-static void output_printf PARAMS ((struct output_buffer *, const char *, ...))\n-     ATTRIBUTE_PRINTF_2;\n+static const char *build_location_prefix PARAMS ((const char *, int, int));\n+static void output_notice PARAMS ((output_buffer *, const char *));\n static void line_wrapper_printf PARAMS ((FILE *, const char *, ...))\n      ATTRIBUTE_PRINTF_2;\n static void vline_wrapper_message_with_location PARAMS ((const char *, int,\n@@ -98,13 +79,15 @@ static void vsorry PARAMS ((const char *, va_list));\n static void report_file_and_line PARAMS ((const char *, int, int));\n static void vnotice PARAMS ((FILE *, const char *, va_list));\n \n-\n extern int rtl_dump_and_exit;\n extern int inhibit_warnings;\n extern int warnings_are_errors;\n extern int warningcount;\n extern int errorcount;\n \n+/* Front-end specific tree formatter, if non-NULL.  */\n+printer_fn lang_printer = NULL;\n+\n static int need_error_newline;\n \n /* Function of last error message;\n@@ -143,52 +126,115 @@ set_message_length (n)\n     output_maximum_width = n;\n }\n \n-/* Construct an output BUFFER with PREFIX and of MAX_LENGTH characters\n-   per line.  */\n+/* Returns true if BUFFER is in line-wrappind mode.  */\n+int\n+output_is_line_wrapping (buffer)\n+     output_buffer *buffer;\n+{\n+  return buffer->ideal_maximum_length > 0;\n+}\n \n+/* Return BUFFER's prefix.  */\n+const char *\n+output_get_prefix (buffer)\n+     const output_buffer *buffer;\n+{\n+  return buffer->prefix;\n+}\n+\n+/* Subroutine of output_set_maximum_length.  Set up BUFFER's\n+   internal maximum characters per line.  */\n static void\n-init_output_buffer (buffer, prefix, max_length)\n-     struct output_buffer *buffer;\n-     char *prefix;\n-     int max_length;\n+set_real_maximum_length (buffer)\n+     output_buffer *buffer;\n+{\n+  /* If we're told not to wrap lines then do the obvious thing.  */\n+  if (! output_is_line_wrapping (buffer))\n+    buffer->maximum_length = buffer->ideal_maximum_length;\n+  else\n+    {\n+      int prefix_length = buffer->prefix ? strlen (buffer->prefix) : 0;\n+      /* If the prefix is ridiculously too long, output at least\n+         32 characters.  */\n+      if (buffer->ideal_maximum_length - prefix_length < 32)\n+        buffer->maximum_length = buffer->ideal_maximum_length + 32;\n+      else\n+        buffer->maximum_length = buffer->ideal_maximum_length;\n+    }\n+}\n+\n+/* Sets the number of maximum characters per line BUFFER can output\n+   in line-wrapping mode.  A LENGTH value 0 suppresses line-wrapping.  */\n+void\n+output_set_maximum_length (buffer, length)\n+     output_buffer *buffer;\n+     int length;\n {\n-  int prefix_length = prefix == 0 ? 0 : strlen (prefix);\n+  buffer->ideal_maximum_length = length;\n+  set_real_maximum_length (buffer);\n+}\n \n-  obstack_init (&buffer->obstack);\n+/* Sets BUFFER's PREFIX.  */\n+void\n+output_set_prefix (buffer, prefix)\n+     output_buffer *buffer;\n+     const char *prefix;\n+{\n   buffer->prefix = prefix;\n+  set_real_maximum_length (buffer);\n+}\n+\n+/* Construct an output BUFFER with PREFIX and of MAXIMUM_LENGTH\n+   characters per line.  */\n+void\n+init_output_buffer (buffer, prefix, maximum_length)\n+     output_buffer *buffer;\n+     const char *prefix;\n+     int maximum_length;\n+{\n+  obstack_init (&buffer->obstack);\n+  buffer->ideal_maximum_length = maximum_length;\n   buffer->line_length = 0;\n-  /* If the prefix is ridiculously too long, output at least\n-     32 characters.  */\n-  if (max_length - prefix_length < 32)\n-    buffer->max_length = max_length + 32;\n-  else\n-    buffer->max_length = max_length;\n+  output_set_prefix (buffer, prefix);\n+  \n+  buffer->cursor = NULL;\n+  buffer->format_args = NULL;\n }\n \n-/* Return BUFFER's prefix.  */\n+/* Reinitialize BUFFER.  */\n+void\n+output_clear (buffer)\n+     output_buffer *buffer;\n+{\n+  obstack_free (&buffer->obstack, obstack_base (&buffer->obstack));\n+  buffer->line_length = 0;\n+  buffer->cursor = NULL;\n+  buffer->format_args = NULL;\n+}\n \n-static char *\n-get_output_prefix (buffer)\n-     const struct output_buffer *buffer;\n+/* Finishes to construct a NULL-terminated character string representing\n+   the BUFFERed message.  */\n+const char *\n+output_finish (buffer)\n+     output_buffer *buffer;\n {\n-  return buffer->prefix;\n+  obstack_1grow (&buffer->obstack, '\\0');\n+  return (const char *) obstack_finish (&buffer->obstack);\n }\n \n /* Return the amount of characters BUFFER can accept to\n    make a full line.  */\n-\n-static int\n+int\n output_space_left (buffer)\n-     const struct output_buffer *buffer;\n+     const output_buffer *buffer;\n {\n-  return buffer->max_length - buffer->line_length;\n+  return buffer->maximum_length - buffer->line_length;\n }\n \n-/* Dump BUFFER's prefix.  */\n-\n-static void\n-emit_output_prefix (buffer)\n-     struct output_buffer *buffer;\n+/* Write out BUFFER's prefix.  */\n+void\n+output_emit_prefix (buffer)\n+     output_buffer *buffer;\n {\n   if (buffer->prefix)\n     {\n@@ -198,21 +244,60 @@ emit_output_prefix (buffer)\n }\n \n /* Have BUFFER start a new line.  */\n-\n-static void\n-output_newline (buffer)\n-     struct output_buffer *buffer;\n+void\n+output_add_newline (buffer)\n+     output_buffer *buffer;\n {\n   obstack_1grow (&buffer->obstack, '\\n');\n   buffer->line_length = 0;\n }\n \n+/* Appends a character to BUFFER.  */\n+void\n+output_add_character (buffer, c)\n+     output_buffer *buffer;\n+     int c;\n+{\n+  if (output_is_line_wrapping (buffer) && output_space_left (buffer) <= 0)\n+    output_add_newline (buffer);\n+  obstack_1grow (&buffer->obstack, c);\n+  ++buffer->line_length;\n+}\n+\n+/* Adds a space to BUFFER.  */\n+void\n+output_add_space (buffer)\n+     output_buffer *buffer;\n+{\n+  if (output_is_line_wrapping (buffer) && output_space_left (buffer) <= 0)\n+    {\n+      output_add_newline (buffer);\n+      return;\n+    }\n+  obstack_1grow (&buffer->obstack, ' ');\n+  ++buffer->line_length;\n+}\n+\n+/* Add the stringified version of an integer to BUFFER.  */\n+void\n+output_add_integer (buffer, i)\n+     output_buffer *buffer;\n+     HOST_WIDE_INT i;\n+{\n+  /* This must be large enough to hold any printed integer or\n+     floating-point value.  */\n+  static char digit_buffer[128];\n+\n+  sprintf (digit_buffer, HOST_WIDE_INT_PRINT_DEC, i);\n+  output_add_string (buffer, digit_buffer);\n+}\n+\n /* Append a string deliminated by START and END to BUFFER.  No wrapping is\n    done.  The caller must ensure that it is safe to do so.  */\n \n-static void\n+void\n output_append (buffer, start, end)\n-     struct output_buffer *buffer;\n+     output_buffer *buffer;\n      const char *start;\n      const char *end;\n {\n@@ -221,7 +306,7 @@ output_append (buffer, start, end)\n   /* Emit prefix and skip whitespace if we're starting a new line.  */\n   if (buffer->line_length == 0)\n     {\n-      emit_output_prefix (buffer);\n+      output_emit_prefix (buffer);\n       while (start != end && *start == ' ')\n         ++start;\n     }\n@@ -232,14 +317,16 @@ output_append (buffer, start, end)\n \n /* Wrap a STRing into BUFFER.  */\n \n-static void\n-output_puts (buffer, str)\n-     struct output_buffer *buffer;\n+void\n+output_add_string (buffer, str)\n+     output_buffer *buffer;\n      const char *str;\n {\n   const char *p = str;\n-  \n-  while (*str)\n+\n+  if (!output_is_line_wrapping (buffer))\n+    output_append (buffer, str, str + strlen (str));\n+  else while (*str)\n     {\n       while (*p && *p != ' ' && *p != '\\n')\n         ++p;\n@@ -248,37 +335,71 @@ output_puts (buffer, str)\n         output_append (buffer, str, p);\n       else\n         {\n-          output_newline (buffer);\n+          output_add_newline (buffer);\n           output_append (buffer, str, p);\n         }\n       \n       while (*p && *p == '\\n')\n         {\n-          output_newline (buffer);\n+          output_add_newline (buffer);\n           ++p;\n         }\n \n       str = p++;\n     }\n }\n \n-/* Dump the content of BUFFER into FILE.  */\n+/* Flush the content of BUFFER onto FILE and reinitialize BUFFER.  */\n \n-static void\n-dump_output (buffer, file)\n-     struct output_buffer *buffer;\n+void\n+output_flush_on (buffer, file)\n+     output_buffer *buffer;\n      FILE *file;\n {\n-  char *text;\n-  \n-  obstack_1grow (&buffer->obstack, '\\0');\n-  text = obstack_finish (&buffer->obstack);\n+  const char *text = output_finish (buffer);\n   fputs (text, file);\n-  obstack_free (&buffer->obstack, text);\n-  buffer->line_length = 0;\n+  output_clear (buffer);\n+}\n+\n+/* Format MESSAGE into BUFFER.  */\n+void\n+output_format (buffer, msg)\n+     output_buffer *buffer;\n+     const char *msg;\n+{\n+  for (buffer->cursor = msg; *buffer->cursor; ++buffer->cursor)\n+    {\n+      /* Ignore text.  */\n+      if (*buffer->cursor != '%')\n+        {\n+          output_add_character (buffer, *buffer->cursor);\n+          continue;\n+        }\n+\n+      /* We got a '%'.  Let's see what happens.  */\n+      ++buffer->cursor;\n+\n+      /* Let's handle the traditional cases.  */\n+      if (*buffer->cursor == 's')\n+        output_add_string (buffer, va_arg (buffer->format_args, const char *));\n+      else if (*buffer->cursor == 'd')\n+        output_add_integer (buffer, va_arg (buffer->format_args, int));\n+      else if (*buffer->cursor == '%')\n+        /* It was a '%%'.  Just output a '%'.  */\n+        output_add_character (buffer, '%');\n+      else if (lang_printer)\n+        (*lang_printer) (buffer);\n+      else\n+        {\n+          /* Hmmm.  The front-end failed to install a format translator\n+             but called us with an unrecognized format.  Sorry.  */\n+          abort();\n+        }\n+    }\n+  output_finish (buffer);\n }\n \n-static char *\n+static const char *\n vbuild_message_string (msgid, ap)\n      const char *msgid;\n      va_list ap;\n@@ -292,14 +413,14 @@ vbuild_message_string (msgid, ap)\n /*  Return a malloc'd string containing MSGID formatted a la\n     printf.  The caller is reponsible for freeing the memory.  */\n \n-static char *\n+static const char *\n build_message_string VPARAMS ((const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char *msgid;\n #endif\n   va_list ap;\n-  char *str;\n+  const char *str;\n \n   VA_START (ap, msgid);\n \n@@ -318,7 +439,7 @@ build_message_string VPARAMS ((const char *msgid, ...))\n /* Return a malloc'd string describing a location.  The caller is\n    responsible for freeing the memory.  */\n \n-static char *\n+static const char *\n build_location_prefix (file, line, warn)\n      const char *file;\n      int line;\n@@ -343,21 +464,20 @@ build_location_prefix (file, line, warn)\n /* Format a MESSAGE into BUFFER.  Automatically wrap lines.  */\n \n static void\n-voutput_notice (buffer, msgid, ap)\n-     struct output_buffer *buffer;\n+output_notice (buffer, msgid)\n+     output_buffer *buffer;\n      const char *msgid;\n-     va_list ap;\n {\n-  char *message = vbuild_message_string (msgid, ap);\n+  const char *message = vbuild_message_string (msgid, buffer->format_args);\n \n-  output_puts (buffer, message);\n-  free (message);\n+  output_add_string (buffer, message);\n+  free ((char *) message);\n }\n \n \n /* Format a message into BUFFER a la printf.  */\n \n-static void\n+void\n output_printf VPARAMS ((struct output_buffer *buffer, const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n@@ -373,8 +493,9 @@ output_printf VPARAMS ((struct output_buffer *buffer, const char *msgid, ...))\n   msgid = va_arg (ap, const char *);\n #endif\n \n-  voutput_notice (buffer, msgid, ap);\n-  va_end (ap);\n+  buffer->format_args = ap;\n+  output_notice (buffer, msgid);\n+  va_end (buffer->format_args);\n }\n \n \n@@ -388,7 +509,7 @@ line_wrapper_printf VPARAMS ((FILE *file, const char *msgid, ...))\n   FILE *file;\n   const char *msgid;\n #endif\n-  struct output_buffer buffer;\n+  output_buffer buffer;\n   va_list ap;\n   \n   VA_START (ap, msgid);\n@@ -399,10 +520,11 @@ line_wrapper_printf VPARAMS ((FILE *file, const char *msgid, ...))\n #endif  \n \n   init_output_buffer (&buffer, NULL, output_maximum_width);\n-  voutput_notice (&buffer, msgid, ap);\n-  dump_output (&buffer, file);\n+  buffer.format_args = ap;\n+  output_notice (&buffer, msgid);\n+  output_flush_on (&buffer, file);\n \n-  va_end (ap);\n+  va_end (buffer.format_args);\n }\n \n \n@@ -414,13 +536,15 @@ vline_wrapper_message_with_location (file, line, warn, msgid, ap)\n      const char *msgid;\n      va_list ap;\n {\n-  struct output_buffer buffer;\n+  output_buffer buffer;\n   \n   init_output_buffer\n     (&buffer, build_location_prefix (file, line, warn), output_maximum_width);\n-  voutput_notice (&buffer, msgid, ap);\n-  dump_output (&buffer, stderr);\n-  free ((char*)get_output_prefix (&buffer));\n+  buffer.format_args = ap;\n+  output_notice (&buffer, msgid);\n+  output_flush_on (&buffer, stderr);\n+\n+  free ((char*) output_get_prefix (&buffer));\n   fputc ('\\n', stderr);\n }\n \n@@ -498,14 +622,15 @@ v_message_with_decl (decl, warn, msgid, ap)\n      va_list ap;\n {\n   const char *p;\n-  struct output_buffer buffer;\n+  output_buffer buffer;\n \n   if (doing_line_wrapping ())\n-    init_output_buffer\n-      (&buffer,\n-       build_location_prefix (DECL_SOURCE_FILE (decl),\n-                              DECL_SOURCE_LINE (decl), warn),\n-       output_maximum_width);\n+    {\n+      init_output_buffer\n+        (&buffer, build_location_prefix\n+         (DECL_SOURCE_FILE (decl), DECL_SOURCE_LINE (decl), warn),\n+         output_maximum_width);\n+    }\n   else\n     report_file_and_line (DECL_SOURCE_FILE (decl),\n                           DECL_SOURCE_LINE (decl), warn);\n@@ -541,7 +666,7 @@ v_message_with_decl (decl, warn, msgid, ap)\n \t\t ? (*decl_printable_name) (decl, 2)\n \t\t : \"((anonymous))\");\n       if (doing_line_wrapping ())\n-        output_puts (&buffer, n);\n+        output_add_string (&buffer, n);\n       else\n         fputs (n, stderr);\n       while (*p)\n@@ -555,15 +680,19 @@ v_message_with_decl (decl, warn, msgid, ap)\n   if (*p)\t\t\t/* Print the rest of the message.  */\n     {\n       if (doing_line_wrapping ())\n-        voutput_notice (&buffer, p, ap);\n+        {\n+          buffer.format_args = ap;\n+          output_notice (&buffer, p);\n+          ap = buffer.format_args;\n+        }\n       else\n         vfprintf (stderr, p, ap);\n     }\n \n   if (doing_line_wrapping())\n     {\n-      dump_output (&buffer, stderr);\n-      free ((char *)get_output_prefix (&buffer));\n+      output_flush_on (&buffer, stderr);\n+      free ((char *) output_get_prefix (&buffer));\n     }\n   \n   fputc ('\\n', stderr);\n@@ -1012,8 +1141,8 @@ default_print_error_function (file)\n {\n   if (last_error_function != current_function_decl)\n     {\n-      char *prefix = NULL;\n-      struct output_buffer buffer;\n+      const char *prefix = NULL;\n+      output_buffer buffer;\n       \n       if (file)\n         prefix = build_message_string (\"%s: \", file);\n@@ -1060,9 +1189,9 @@ default_print_error_function (file)\n       last_error_function = current_function_decl;\n \n       if (doing_line_wrapping ())\n-        dump_output (&buffer, stderr);\n+        output_flush_on (&buffer, stderr);\n       \n-      free (prefix);\n+      free ((char*) prefix);\n     }\n }\n "}, {"sha": "d60d240626c4a1441a0fbce033a762ffcb7b2e9a", "filename": "gcc/diagnostic.h", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/345ed1fe96a21671979f900d0d9075f225804a7a/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/345ed1fe96a21671979f900d0d9075f225804a7a/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=345ed1fe96a21671979f900d0d9075f225804a7a", "patch": "@@ -0,0 +1,96 @@\n+/* Various declarations for language-independent diagnostics subroutines.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Contributed by Gabriel Dos Reis <gdr@codesourcery.com>\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#ifndef __GCC_DIAGNOSTIC_H__\n+#define __GCC_DIAGNOSTIC_H__\n+\n+#include \"obstack.h\"\n+\n+/*  Forward declarations.  */\n+typedef struct output_buffer output_buffer;\n+\n+/* The type of front-end specific hook that formats trees into an\n+   output_buffer.  */\n+typedef void (*printer_fn) PARAMS ((output_buffer *));\n+\n+/* The output buffer datatype.  This is best seen as an abstract datatype.  */\n+struct output_buffer\n+{\n+  /* Internal data.  These fields should not be accessed directly by\n+     front-ends.  */\n+\n+  /* The obstack where the text is built up.  */  \n+  struct obstack obstack;\n+  /* The prefix for each new line.   */\n+  const char *prefix;\n+  /* The amount of characters output so far.  */  \n+  int line_length;\n+  /* The real upper bound of number of characters per line, taking into\n+     accompt the case of a very very looong prefix.  */  \n+  int maximum_length;\n+  /* The ideal upper bound of number of characters per line, as suggested\n+     by front-end. */  \n+  int ideal_maximum_length;\n+\n+  /* Public fields.  These are used by front-ends to extract formats and\n+     arguments from the variable argument-list passed to output_format.  */\n+\n+  /* The current char to output.  Updated by front-end (*format_map) when\n+     it is called to report front-end printer for a specified format.  */  \n+  const char *cursor;\n+  /* Variable argument-list for formatting.  */  \n+  va_list format_args;\n+};\n+\n+/* If non-NULL, this function formats data in the BUFFER.\n+   BUFFER->CURSOR points to a format code.  LANG_PRINTER should\n+   call output_add_string (and related functions) to add data to\n+   the BUFFER.  LANG_PRINTER can read arguments from\n+   BUFFER->FORMAT_ARGS using VA_ARG.  If the BUFFER needs\n+   additional characters from the format string, it should advance\n+   the BUFFER->CURSOR as it goes.  When LANG_PRINTER returns,\n+   BUFFER->CURSOR should point to the last character processed.  */\n+\n+extern printer_fn lang_printer;\n+\n+/* Prototypes */\n+void init_output_buffer\t\tPARAMS ((output_buffer *, const char *, int));\n+void output_clear\t\tPARAMS ((output_buffer *));\n+const char *output_get_prefix\tPARAMS ((const output_buffer *));\n+void output_set_prefix\t\tPARAMS ((output_buffer *, const char *));\n+void output_set_maximum_length  PARAMS ((output_buffer *, int));\n+void output_emit_prefix\t\tPARAMS ((output_buffer *));\n+void output_add_newline\t\tPARAMS ((output_buffer *));\n+void output_add_space\t\tPARAMS ((output_buffer *));\n+int output_space_left\t\tPARAMS ((const output_buffer *));\n+void output_append\t\tPARAMS ((output_buffer *, const char *,\n+                                         const char *));\n+void output_add_character\tPARAMS ((output_buffer *, int));\n+void output_add_integer\t\tPARAMS ((output_buffer *, HOST_WIDE_INT));\n+void output_add_string\t\tPARAMS ((output_buffer *, const char *));\n+const char *output_finish\tPARAMS ((output_buffer *));\n+void output_flush_on\t\tPARAMS ((output_buffer *, FILE *));\n+void output_printf\t\tPARAMS ((output_buffer *, const char *,\n+                                         ...)) ATTRIBUTE_PRINTF_2;\n+void output_format\t\tPARAMS ((output_buffer *, const char *));\n+int output_is_line_wrapping\tPARAMS ((output_buffer *));\n+\n+#endif /* __GCC_DIAGNOSTIC_H__ */"}]}