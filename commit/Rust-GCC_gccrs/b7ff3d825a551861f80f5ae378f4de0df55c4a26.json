{"sha": "b7ff3d825a551861f80f5ae378f4de0df55c4a26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjdmZjNkODI1YTU1MTg2MWY4MGY1YWUzNzhmNGRlMGRmNTVjNGEyNg==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "1996-03-06T16:40:14Z"}, "committer": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "1996-03-06T16:40:14Z"}, "message": "add scheduling information for stores\n\nFrom-SVN: r11481", "tree": {"sha": "153cf89ab368dcbcf56ec738c69b8a86a8086115", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/153cf89ab368dcbcf56ec738c69b8a86a8086115"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7ff3d825a551861f80f5ae378f4de0df55c4a26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7ff3d825a551861f80f5ae378f4de0df55c4a26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7ff3d825a551861f80f5ae378f4de0df55c4a26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7ff3d825a551861f80f5ae378f4de0df55c4a26/comments", "author": null, "committer": null, "parents": [{"sha": "1ec26da6f158b7d081cc1ed73e5a9346b1a1280e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ec26da6f158b7d081cc1ed73e5a9346b1a1280e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ec26da6f158b7d081cc1ed73e5a9346b1a1280e"}], "stats": {"total": 302, "additions": 181, "deletions": 121}, "files": [{"sha": "aa1b0fe6146c5c686ba21e77c31e25cec3ebff0b", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 181, "deletions": 121, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7ff3d825a551861f80f5ae378f4de0df55c4a26/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7ff3d825a551861f80f5ae378f4de0df55c4a26/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=b7ff3d825a551861f80f5ae378f4de0df55c4a26", "patch": "@@ -23,7 +23,7 @@\n \f\n ;; Define an insn type attribute.  This is used in function unit delay\n ;; computations.\n-(define_attr \"type\" \"integer,load,fpload,imul,idiv,branch,compare,delayed_compare,fpcompare,mtjmpr,fp,dmul,sdiv,ddiv,ssqrt,dsqrt,jmpreg\"\n+(define_attr \"type\" \"integer,load,store,fpload,fpstore,imul,idiv,branch,compare,delayed_compare,fpcompare,mtjmpr,fp,dmul,sdiv,ddiv,ssqrt,dsqrt,jmpreg\"\n   (const_string \"integer\"))\n \n ;; Length (in bytes).\n@@ -40,45 +40,74 @@\n ;; Processor type -- this attribute must exactly match the processor_type\n ;; enumeration in rs6000.h.\n \n-(define_attr \"cpu\" \"rios1,rios2,mpccore,ppc403,ppc601,ppc602,ppc603,ppc604,ppc620\"\n+(define_attr \"cpu\" \"rios1,rios2,mpccore,ppc403,ppc601,ppc603,ppc604,ppc620\"\n   (const (symbol_ref \"rs6000_cpu_attr\")))\n \n ; (define_function_unit NAME MULTIPLICITY SIMULTANEITY\n ;\t\t\tTEST READY-DELAY ISSUE-DELAY [CONFLICT-LIST])\n \n-; Load/Store Unit -- POWER/2 and pure PowerPC only\n+; Load/Store Unit -- pure PowerPC only\n ; (POWER and 601 use Integer Unit)\n (define_function_unit \"lsu\" 1 0\n   (and (eq_attr \"type\" \"load\")\n-       (eq_attr \"cpu\" \"mpccore,ppc602,ppc603,ppc604,ppc620\"))\n+       (eq_attr \"cpu\" \"mpccore,ppc603,ppc604,ppc620\"))\n   2 1)\n \n (define_function_unit \"lsu\" 1 0\n-  (and (eq_attr \"type\" \"fpload\")\n-       (eq_attr \"cpu\" \"ppc604,ppc620\"))\n-  3 1)\n+  (and (eq_attr \"type\" \"store,fpstore\")\n+       (eq_attr \"cpu\" \"mpccore,ppc603,ppc604,ppc620\"))\n+  1 1)\n \n (define_function_unit \"lsu\" 1 0\n   (and (eq_attr \"type\" \"fpload\")\n-       (eq_attr \"cpu\" \"mpccore,ppc602,ppc603\"))\n+       (eq_attr \"cpu\" \"mpccore,ppc603\"))\n   2 1)\n \n+(define_function_unit \"lsu\" 1 0\n+  (and (eq_attr \"type\" \"fpload\")\n+       (eq_attr \"cpu\" \"ppc604,ppc620\"))\n+  3 1)\n+\n (define_function_unit \"iu\" 1 0\n   (and (eq_attr \"type\" \"load\")\n-       (eq_attr \"cpu\" \"rios1,ppc601,ppc403\"))\n+       (eq_attr \"cpu\" \"rios1,ppc403,ppc601\"))\n   2 1)\n \n (define_function_unit \"iu\" 1 0\n-  (and (eq_attr \"type\" \"fpload\")\n+  (and (eq_attr \"type\" \"store,fpstore\")\n+       (eq_attr \"cpu\" \"rios1,ppc403,ppc601\"))\n+  1 1)\n+\n+(define_function_unit \"fpu\" 1 0\n+  (and (eq_attr \"type\" \"fpstore\")\n        (eq_attr \"cpu\" \"rios1,ppc601\"))\n-  2 0)\n+  0 1)\n \n-; Integer Unit (RIOS1, PPC601, PPC603)\n-; Trivial operations take one cycle which need not be listed here.\n (define_function_unit \"iu\" 1 0\n-  (and (eq_attr \"type\" \"imul\")\n+  (and (eq_attr \"type\" \"fpload\")\n        (eq_attr \"cpu\" \"rios1\"))\n-  3 3)\n+  2 1)\n+\n+(define_function_unit \"iu\" 1 0\n+  (and (eq_attr \"type\" \"fpload\")\n+       (eq_attr \"cpu\" \"ppc601\"))\n+  3 1)\n+\n+(define_function_unit \"iu2\" 2 0\n+  (and (eq_attr \"type\" \"load,fpload\")\n+       (eq_attr \"cpu\" \"rios2\"))\n+  2 1)\n+\n+(define_function_unit \"iu2\" 2 0\n+  (and (eq_attr \"type\" \"store,fpstore\")\n+       (eq_attr \"cpu\" \"rios2\"))\n+  1 1)\n+\n+; Integer Unit (RIOS1, PPC601, PPC603)\n+(define_function_unit \"iu\" 1 0\n+  (and (eq_attr \"type\" \"integer\")\n+       (eq_attr \"cpu\" \"rios1,mpccore,ppc403,ppc601,ppc603\"))\n+  1 1)\n \n (define_function_unit \"iu\" 1 0\n   (and (eq_attr \"type\" \"imul\")\n@@ -87,7 +116,7 @@\n \n (define_function_unit \"iu\" 1 0\n   (and (eq_attr \"type\" \"imul\")\n-       (eq_attr \"cpu\" \"ppc601,ppc602,ppc603\"))\n+       (eq_attr \"cpu\" \"rios1,ppc601,ppc603\"))\n   5 5)\n \n (define_function_unit \"iu\" 1 0\n@@ -97,17 +126,17 @@\n \n (define_function_unit \"iu\" 1 0\n   (and (eq_attr \"type\" \"idiv\")\n-       (eq_attr \"cpu\" \"ppc601\"))\n-  36 36)\n+       (eq_attr \"cpu\" \"ppc403\"))\n+  33 33)\n \n (define_function_unit \"iu\" 1 0\n   (and (eq_attr \"type\" \"idiv\")\n-       (eq_attr \"cpu\" \"ppc403\"))\n-  33 33)\n+       (eq_attr \"cpu\" \"ppc601\"))\n+  36 36)\n \n (define_function_unit \"iu\" 1 0\n   (and (eq_attr \"type\" \"idiv\")\n-       (eq_attr \"cpu\" \"ppc602,ppc603\"))\n+       (eq_attr \"cpu\" \"ppc603\"))\n   37 36)\n \n ; RIOS2 has two integer units: a primary one which can perform all\n@@ -118,7 +147,7 @@\n (define_function_unit \"iu2\" 2 0\n   (and (eq_attr \"type\" \"integer\")\n        (eq_attr \"cpu\" \"rios2\"))\n-  1 0)\n+  1 1)\n \n (define_function_unit \"iu2\" 2 0\n   (and (eq_attr \"type\" \"imul\")\n@@ -135,7 +164,6 @@\n        (eq_attr \"cpu\" \"rios2\"))\n   2 2)\n \n-\n (define_function_unit \"imuldiv\" 1 0\n   (and (eq_attr \"type\" \"idiv\")\n        (eq_attr \"cpu\" \"rios2\"))\n@@ -159,20 +187,17 @@\n (define_function_unit \"iu2\" 2 0\n   (and (eq_attr \"type\" \"integer\")\n        (eq_attr \"cpu\" \"ppc604,ppc620\"))\n-  1 1\n-  [(eq_attr \"type\" \"imul,idiv\")])\n+  1 1)\n \n (define_function_unit \"imuldiv\" 1 0\n   (and (eq_attr \"type\" \"imul\")\n        (eq_attr \"cpu\" \"ppc604,ppc620\"))\n-  4 2\n-  [(eq_attr \"type\" \"integer\")])\n+  4 2)\n \n (define_function_unit \"imuldiv\" 1 0\n   (and (eq_attr \"type\" \"idiv\")\n        (eq_attr \"cpu\" \"ppc604,ppc620\"))\n-  20 19\n-  [(eq_attr \"type\" \"integer\")])\n+  20 19)\n \n ; compare is done on integer unit, but feeds insns which\n ; execute on the branch unit.  Ready-delay of the compare \n@@ -182,36 +207,34 @@\n ; able to fill the compare-branch delay, with insns on iu/fpu.\n (define_function_unit \"iu\" 1 0   \n   (and (eq_attr \"type\" \"compare\")\n-       (eq_attr \"cpu\" \"rios1,mpccore,ppc601\"))\n-  1 1)\n+       (eq_attr \"cpu\" \"rios1\"))\n+  4 1)\n+\n+(define_function_unit \"iu\" 1 0   \n+  (and (eq_attr \"type\" \"delayed_compare\")\n+       (eq_attr \"cpu\" \"rios1\"))\n+  5 1)\n+\n+(define_function_unit \"iu\" 1 0\n+  (and (eq_attr \"type\" \"compare,delayed_compare\")\n+       (eq_attr \"cpu\" \"mpccore,ppc403,ppc601,ppc603,ppc604,ppc620\"))\n+  3 1)\n \n (define_function_unit \"iu2\" 2 0   \n-  (and (eq_attr \"type\" \"compare\")\n+  (and (eq_attr \"type\" \"compare,delayed_compare\")\n        (eq_attr \"cpu\" \"rios2\"))\n-  1 1)\n-\n-(define_function_unit \"bpu\" 1 0   \n-  (and (eq_attr \"type\" \"compare\")\n-       (eq_attr \"cpu\" \"rios1,rios2,ppc403,mpccore,ppc601,ppc603,ppc604,ppc620\"))\n-  4 1)\n+  3 1)\n \n-; different machines have different compare timings\n-; in ppc604, compare is done on the one of the two\n-; main integer units.\n (define_function_unit \"iu2\" 2 0\n-  (and (eq_attr \"type\" \"compare\")\n+  (and (eq_attr \"type\" \"compare,delayed_compare\")\n        (eq_attr \"cpu\" \"ppc604,ppc620\"))\n   1 1)\n \n-(define_function_unit \"bpu\" 1 0\n-  (eq_attr \"type\" \"delayed_compare\")\n-  5 0)\n-\n ; fp compare uses fp unit\n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"type\" \"fpcompare\")\n        (eq_attr \"cpu\" \"rios1\"))\n-  8 1)\n+  9 1)\n \n ; rios1 and rios2 have different fpcompare delays\n (define_function_unit \"fpu2\" 2 0\n@@ -222,16 +245,16 @@\n ; on ppc601 and ppc603, fpcompare takes also 2 cycles from\n ; the integer unit\n ; here we do not define delays, just occupy the unit. The dependencies\n-; will be signed by the fpcompare definition in the fpu.\n+; will be assigned by the fpcompare definition in the fpu.\n (define_function_unit \"iu\" 1 0\n   (and (eq_attr \"type\" \"fpcompare\")\n-       (eq_attr \"cpu\" \"ppc601,ppc602,ppc603\"))\n+       (eq_attr \"cpu\" \"ppc601,ppc603\"))\n   0 2)\n \n ; fp compare uses fp unit\n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"type\" \"fpcompare\")\n-       (eq_attr \"cpu\" \"ppc601,ppc602,ppc603,ppc604,ppc620\"))\n+       (eq_attr \"cpu\" \"ppc601,ppc603,ppc604,ppc620\"))\n   5 1)\n \n (define_function_unit \"fpu\" 1 0\n@@ -242,27 +265,27 @@\n (define_function_unit \"bpu\" 1 0\n   (and (eq_attr \"type\" \"mtjmpr\")\n        (eq_attr \"cpu\" \"rios1,rios2\"))\n-  5 0)\n+  5 1)\n \n (define_function_unit \"bpu\" 1 0\n   (and (eq_attr \"type\" \"mtjmpr\")\n-       (eq_attr \"cpu\" \"ppc403,mpccore,ppc601,ppc602,ppc603,ppc604,ppc620\"))\n-  4 0)\n+       (eq_attr \"cpu\" \"mpccore,ppc403,ppc601,ppc603,ppc604,ppc620\"))\n+  4 1)\n \n ; all jumps/branches are executing on the bpu, in 1 cycle, for all machines.\n (define_function_unit \"bpu\" 1 0\n   (eq_attr \"type\" \"jmpreg\")\n-  1 0)\n+  1 1)\n \n (define_function_unit \"bpu\" 1 0\n   (eq_attr \"type\" \"branch\")\n-  1 0)\n+  1 1)\n \n ; Floating Point Unit\n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"type\" \"fp,dmul\")\n        (eq_attr \"cpu\" \"rios1\"))\n-  2 0)\n+  2 1)\n \n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"type\" \"fp\")\n@@ -272,11 +295,11 @@\n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"type\" \"fp\")\n        (eq_attr \"cpu\" \"ppc601\"))\n-  4 0)\n+  4 1)\n \n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"type\" \"fp\")\n-       (eq_attr \"cpu\" \"ppc602,ppc603,ppc604,ppc620\"))\n+       (eq_attr \"cpu\" \"ppc603,ppc604,ppc620\"))\n   3 1)\n \n (define_function_unit \"fpu\" 1 0\n@@ -292,7 +315,7 @@\n ; is this true?\n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"type\" \"dmul\")\n-       (eq_attr \"cpu\" \"ppc602,ppc603\"))\n+       (eq_attr \"cpu\" \"ppc603\"))\n   4 2)\n \n (define_function_unit \"fpu\" 1 0\n@@ -317,7 +340,7 @@\n \n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"type\" \"sdiv\")\n-       (eq_attr \"cpu\" \"ppc602,ppc603,ppc604,ppc620\"))\n+       (eq_attr \"cpu\" \"ppc603,ppc604,ppc620\"))\n   18 18)\n \n (define_function_unit \"fpu\" 1 0\n@@ -332,7 +355,7 @@\n \n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"type\" \"ddiv\")\n-       (eq_attr \"cpu\" \"ppc602,ppc603\"))\n+       (eq_attr \"cpu\" \"ppc603\"))\n   33 33)\n \n (define_function_unit \"fpu\" 1 0\n@@ -349,12 +372,12 @@\n (define_function_unit \"fpu2\" 2 0\n   (and (eq_attr \"type\" \"fp\")\n        (eq_attr \"cpu\" \"rios2\"))\n-  2 0)\n+  2 1)\n \n (define_function_unit \"fpu2\" 2 0\n   (and (eq_attr \"type\" \"dmul\")\n        (eq_attr \"cpu\" \"rios2\"))\n-  2 0)\n+  2 1)\n \n (define_function_unit \"fpu2\" 2 0\n   (and (eq_attr \"type\" \"sdiv,ddiv\")\n@@ -1570,7 +1593,8 @@\n \t\t      (const_int 32))))\n    (clobber (match_scratch:SI 0 \"=l\"))]\n   \"! TARGET_POWER && ! TARGET_POWERPC\"\n-  \"bla __mulh\")\n+  \"bla __mulh\"\n+  [(set_attr \"type\" \"imul\")])\n \n (define_insn \"mull_call\"\n   [(set (reg:DI 3)\n@@ -1579,7 +1603,8 @@\n    (clobber (match_scratch:SI 0 \"=l\"))\n    (clobber (reg:SI 0))]\n   \"! TARGET_POWER && ! TARGET_POWERPC\"\n-  \"bla __mull\")\n+  \"bla __mull\"\n+  [(set_attr \"type\" \"imul\")])\n \n (define_insn \"divss_call\"\n   [(set (reg:SI 3)\n@@ -1589,7 +1614,8 @@\n    (clobber (match_scratch:SI 0 \"=l\"))\n    (clobber (reg:SI 0))]\n   \"! TARGET_POWER && ! TARGET_POWERPC\"\n-  \"bla __divss\")\n+  \"bla __divss\"\n+  [(set_attr \"type\" \"idiv\")])\n \n (define_insn \"divus_call\"\n   [(set (reg:SI 3)\n@@ -1601,14 +1627,16 @@\n    (clobber (match_scratch:CC 1 \"=x\"))\n    (clobber (reg:CC 69))]\n   \"! TARGET_POWER && ! TARGET_POWERPC\"\n-  \"bla __divus\")\n+  \"bla __divus\"\n+  [(set_attr \"type\" \"idiv\")])\n \n (define_insn \"quoss_call\"\n   [(set (reg:SI 3)\n \t(div:SI (reg:SI 3) (reg:SI 4)))\n    (clobber (match_scratch:SI 0 \"=l\"))]\n   \"! TARGET_POWER && ! TARGET_POWERPC\"\n-  \"bla __quoss\")\n+  \"bla __quoss\"\n+  [(set_attr \"type\" \"idiv\")])\n \n (define_insn \"quous_call\"\n   [(set (reg:SI 3)\n@@ -1618,7 +1646,8 @@\n    (clobber (match_scratch:CC 1 \"=x\"))\n    (clobber (reg:CC 69))]\n   \"! TARGET_POWER && ! TARGET_POWERPC\"\n-  \"bla __quous\")\n+  \"bla __quous\"\n+  [(set_attr \"type\" \"idiv\")])\n \f\n (define_insn \"andsi3\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r,r\")\n@@ -4941,7 +4970,7 @@\n    mt%0 %1\n    mt%0 %1\n    cror 0,0,0\"\n-  [(set_attr \"type\" \"*,load,load,*,load,*,*,*,*,*,*,*,mtjmpr,*\")\n+  [(set_attr \"type\" \"*,load,load,*,load,store,*,*,*,*,*,*,mtjmpr,*\")\n    (set_attr \"length\" \"4,4,4,4,4,4,4,4,8,4,4,4,4,4\")])\n \n ;; Split a load of a large constant into the appropriate two-insn\n@@ -5006,7 +5035,7 @@\n    mt%0 %1\n    mt%0 %1\n    cror 0,0,0\"\n-  [(set_attr \"type\" \"*,load,*,*,*,*,mtjmpr,*\")])\n+  [(set_attr \"type\" \"*,load,store,*,*,*,mtjmpr,*\")])\n \n (define_expand \"movqi\"\n   [(set (match_operand:QI 0 \"general_operand\" \"\")\n@@ -5041,7 +5070,7 @@\n    mt%0 %1\n    mt%0 %1\n    cror 0,0,0\"\n-  [(set_attr \"type\" \"*,load,*,*,*,*,mtjmpr,*\")])\n+  [(set_attr \"type\" \"*,load,store,*,*,*,mtjmpr,*\")])\n \f\n ;; Here is how to move condition codes around.  When we store CC data in\n ;; an integer register or memory, we store just the high-order 4 bits.\n@@ -5066,7 +5095,7 @@\n    mr %0,%1\n    {l%U1%X1|lwz%U1%X1} %0,%1\n    {st%U0%U1|stw%U0%U1} %1,%0\"\n-  [(set_attr \"type\" \"*,*,*,compare,*,*,load,*\")\n+  [(set_attr \"type\" \"*,*,*,compare,*,*,load,store\")\n    (set_attr \"length\" \"*,*,12,*,8,*,*,*\")])\n \f\n ;; For floating-point, we normally deal with the floating-point registers\n@@ -5199,7 +5228,7 @@\n    fmr %0,%1\n    lfs%U1%X1 %0,%1\n    stfs%U0%X0 %1,%0\"\n-  [(set_attr \"type\" \"fp,fpload,*\")])\n+  [(set_attr \"type\" \"fp,fpload,fpstore\")])\n \n (define_insn \"\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,m,r,r,r\")\n@@ -5213,7 +5242,7 @@\n    {lil|li} %0,%1\n    {liu|lis} %0,%u1\n    {cal|la} %0,%1(%*)\"\n-  [(set_attr \"type\" \"*,load,*,*,*,*\")])\n+  [(set_attr \"type\" \"*,load,store,*,*,*\")])\n \n \f\n (define_expand \"movdf\"\n@@ -5317,7 +5346,7 @@\n       return \\\"stfd%U0%X0 %1,%0\\\";\n     }\n }\"\n-  [(set_attr \"type\" \"*,load,*,*,fp,fpload,*\")\n+  [(set_attr \"type\" \"*,load,store,*,fp,fpload,fpstore\")\n    (set_attr \"length\" \"8,8,8,8,*,*,*\")])\n \n (define_insn \"\"\n@@ -5354,7 +5383,7 @@\n       return \\\"#\\\";\n     }\n }\"\n-  [(set_attr \"type\" \"*,load,*,*\")\n+  [(set_attr \"type\" \"*,load,store,*\")\n    (set_attr \"length\" \"8,8,8,8\")])\n \n (define_insn \"\"\n@@ -5371,7 +5400,7 @@\n    fmr %0,%1\n    lfd%U1%X1 %0,%1\n    stfd%U0%X0 %1,%0\"\n-  [(set_attr \"type\" \"*,load,*,*,fp,fpload,*\")])\n+  [(set_attr \"type\" \"*,load,store,*,fp,fpload,fpstore\")])\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,r,o,r\")\n@@ -5384,7 +5413,7 @@\n    ld%U1%X1 %0,%1\n    std%U0%X0 %1,%0\n    #\"\n-  [(set_attr \"type\" \"*,load,*,*\")])\n+  [(set_attr \"type\" \"*,load,store,*\")])\n \f\n ;; Next come the multi-word integer load and store and the load and store\n ;; multiple insns.\n@@ -5513,7 +5542,7 @@\n       return \\\"stfd%U0%X0 %1,%0\\\";\n     }\n }\"\n-  [(set_attr \"type\" \"*,load,*,fp,fpload,*\")\n+  [(set_attr \"type\" \"*,load,store,fp,fpload,fpstore\")\n    (set_attr \"length\" \"8,8,8,*,*,*\")])\n \n (define_insn \"\"\n@@ -5535,7 +5564,7 @@\n    mf%1 %0\n    mt%0 %1\n    cror 0,0,0\"\n-  [(set_attr \"type\" \"*,load,*,*,*,*,*,fp,fpload,*,*,mtjmpr,*\")\n+  [(set_attr \"type\" \"*,load,store,*,*,*,*,fp,fpload,fpstore,*,mtjmpr,*\")\n    (set_attr \"length\" \"4,4,4,4,4,20,4,4,4,4,4,4,4\")])\n \n ;; Split a load of a large constant into the appropriate five-instruction\n@@ -5684,7 +5713,7 @@\n \treturn \\\"{l%U1|lwz%U1} %0,%1\\;{l|lwz} %L0,%L1\\;{l|lwz} %Y0,%Y1\\;{l|lwz} %Z0,%Z1\\\";\n     }\n }\"\n-  [(set_attr \"type\" \"*,load,load,*,*\")\n+  [(set_attr \"type\" \"store,store,*,load,load\")\n    (set_attr \"length\" \"*,16,16,*,16\")])\n \n (define_insn \"\"\n@@ -5729,7 +5758,7 @@\n \treturn \\\"{l%U1|lwz%U1} %0,%1\\;{l|lwz} %L0,%L1\\;{l|lwz} %Y0,%Y1\\;{l|lwz} %Z0,%Z1\\\";\n     }\n }\"\n-  [(set_attr \"type\" \"load,*,*\")\n+  [(set_attr \"type\" \"store,*,load\")\n    (set_attr \"length\" \"16,16,16\")])\n \n (define_insn \"\"\n@@ -5763,7 +5792,7 @@\n       return \\\"std%U0 %1,%0\\;std %L1,%L0\\\";\n     }\n }\"\n-  [(set_attr \"type\" \"*,load,*\")\n+  [(set_attr \"type\" \"*,load,store\")\n    (set_attr \"length\" \"8,8,8\")])\n \f\n (define_expand \"load_multiple\"\n@@ -5858,8 +5887,8 @@\n }\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"32\")])\n-\f\n \n+\f\n (define_expand \"store_multiple\"\n   [(match_par_dup 3 [(set (match_operand:SI 0 \"\" \"\")\n \t\t\t  (match_operand:SI 1 \"\" \"\"))\n@@ -5908,15 +5937,17 @@\n \t\t\t (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))\n \t\t    (clobber (match_scratch:SI 3 \"=q\"))])]\n   \"TARGET_STRING && TARGET_POWER\"\n-  \"{stsi|stswi} %2,%P1,%O0\")\n+  \"{stsi|stswi} %2,%P1,%O0\"\n+  [(set_attr \"type\" \"store\")])\n \n (define_insn \"\"\n   [(match_parallel 0 \"store_multiple_operation\"\n \t\t   [(set (mem:SI (match_operand:SI 1 \"register_operand\" \"b\"))\n \t\t\t (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))\n \t\t    (clobber (match_scratch:SI 3 \"X\"))])]\n   \"TARGET_STRING && !TARGET_POWER\"\n-  \"{stsi|stswi} %2,%1,%O0\")\n+  \"{stsi|stswi} %2,%1,%O0\"\n+  [(set_attr \"type\" \"store\")])\n \n \f\n ;; String/block move insn.\n@@ -5978,7 +6009,8 @@\n    && (REGNO (operands[1]) < 5 || REGNO (operands[1]) > 12)\n    && REGNO (operands[4]) == 5\"\n   \"{lsi|lswi} %4,%1,%2\\;{stsi|stswi} %4,%0,%2\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"8\")])\n \n (define_insn \"\"\n   [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"b\"))\n@@ -6000,7 +6032,8 @@\n    && (REGNO (operands[1]) < 5 || REGNO (operands[1]) > 12)\n    && REGNO (operands[4]) == 5\"\n   \"{lsi|lswi} %4,%1,%2\\;{stsi|stswi} %4,%0,%2\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"8\")])\n \n ;; Move up to 24 bytes at a time.  The fixed registers are needed because the\n ;; register allocator doesn't have a clue about allocating 6 word registers\n@@ -6037,7 +6070,8 @@\n    && (REGNO (operands[1]) < 7 || REGNO (operands[1]) > 12)\n    && REGNO (operands[4]) == 7\"\n   \"{lsi|lswi} %4,%1,%2\\;{stsi|stswi} %4,%0,%2\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"8\")])\n \n (define_insn \"\"\n   [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"b\"))\n@@ -6057,7 +6091,8 @@\n    && (REGNO (operands[1]) < 7 || REGNO (operands[1]) > 12)\n    && REGNO (operands[4]) == 7\"\n   \"{lsi|lswi} %4,%1,%2\\;{stsi|stswi} %4,%0,%2\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"8\")])\n \n ;; Move up to 16 bytes at a time, using 4 fixed registers to avoid spill problems\n ;; with TImode\n@@ -6090,7 +6125,8 @@\n    && (REGNO (operands[1]) < 9 || REGNO (operands[1]) > 12)\n    && REGNO (operands[4]) == 9\"\n   \"{lsi|lswi} %4,%1,%2\\;{stsi|stswi} %4,%0,%2\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"8\")])\n \n (define_insn \"\"\n   [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"b\"))\n@@ -6108,7 +6144,8 @@\n    && (REGNO (operands[1]) < 9 || REGNO (operands[1]) > 12)\n    && REGNO (operands[4]) == 9\"\n   \"{lsi|lswi} %4,%1,%2\\;{stsi|stswi} %4,%0,%2\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"8\")])\n \n ;; Move up to 8 bytes at a time.\n (define_expand \"movstrsi_2reg\"\n@@ -6131,7 +6168,8 @@\n   \"TARGET_STRING && TARGET_POWER && !TARGET_64BIT\n    && INTVAL (operands[2]) > 4 && INTVAL (operands[2]) <= 8\"\n   \"{lsi|lswi} %4,%1,%2\\;{stsi|stswi} %4,%0,%2\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"8\")])\n \n (define_insn \"\"\n   [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"b\"))\n@@ -6143,7 +6181,8 @@\n   \"TARGET_STRING && !TARGET_POWER && !TARGET_64BIT\n    && INTVAL (operands[2]) > 4 && INTVAL (operands[2]) <= 8\"\n   \"{lsi|lswi} %4,%1,%2\\;{stsi|stswi} %4,%0,%2\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"8\")])\n \n ;; Move up to 4 bytes at a time.\n (define_expand \"movstrsi_1reg\"\n@@ -6166,7 +6205,8 @@\n   \"TARGET_STRING && TARGET_POWER\n    && INTVAL (operands[2]) > 0 && INTVAL (operands[2]) <= 4\"\n   \"{lsi|lswi} %4,%1,%2\\;{stsi|stswi} %4,%0,%2\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"8\")])\n \n (define_insn \"\"\n   [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"b\"))\n@@ -6178,7 +6218,8 @@\n   \"TARGET_STRING && !TARGET_POWER\n    && INTVAL (operands[2]) > 0 && INTVAL (operands[2]) <= 4\"\n   \"{lsi|lswi} %4,%1,%2\\;{stsi|stswi} %4,%0,%2\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"8\")])\n \n \f\n ;; Define insns that do load or store with update.  Some of these we can\n@@ -6222,7 +6263,8 @@\n   \"TARGET_POWERPC64\"\n   \"@\n    stdux %3,%0,%2\n-   stdu %3,%2(%0)\")\n+   stdu %3,%2(%0)\"\n+  [(set_attr \"type\" \"store\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 3 \"gpc_reg_operand\" \"=r,r\")\n@@ -6245,7 +6287,8 @@\n   \"\"\n   \"@\n    {stux|stwux} %3,%0,%2\n-   {stu|stwu} %3,%2(%0)\")\n+   {stu|stwu} %3,%2(%0)\"\n+  [(set_attr \"type\" \"store\")])\n \n (define_insn \"\"\n   [(set (match_operand:HI 3 \"gpc_reg_operand\" \"=r,r\")\n@@ -6294,7 +6337,8 @@\n   \"\"\n   \"@\n    sthux %3,%0,%2\n-   sthu %3,%2(%0)\")\n+   sthu %3,%2(%0)\"\n+  [(set_attr \"type\" \"store\")])\n \n (define_insn \"\"\n   [(set (match_operand:QI 3 \"gpc_reg_operand\" \"=r,r\")\n@@ -6330,7 +6374,8 @@\n   \"\"\n   \"@\n    stbux %3,%0,%2\n-   stbu %3,%2(%0)\")\n+   stbu %3,%2(%0)\"\n+  [(set_attr \"type\" \"store\")])\n \n (define_insn \"\"\n   [(set (match_operand:SF 3 \"gpc_reg_operand\" \"=f,f\")\n@@ -6353,7 +6398,8 @@\n   \"TARGET_HARD_FLOAT\"\n   \"@\n    stfsux %3,%0,%2\n-   stfsu %3,%2(%0)\")\n+   stfsu %3,%2(%0)\"\n+  [(set_attr \"type\" \"fpstore\")])\n \n (define_insn \"\"\n   [(set (match_operand:DF 3 \"gpc_reg_operand\" \"=f,f\")\n@@ -6376,7 +6422,8 @@\n   \"TARGET_HARD_FLOAT\"\n   \"@\n    stfdux %3,%0,%2\n-   stfdu %3,%2(%0)\")\n+   stfdu %3,%2(%0)\"\n+  [(set_attr \"type\" \"fpstore\")])\n \n ;; Peephole to convert two consecutive FP loads or stores into lfq/stfq.\n \n@@ -6520,8 +6567,8 @@\n   emit_move_insn (gen_rtx (MEM, SImode, operands[0]), temp);\n   DONE;\n }\")\n-\f\n \n+\f\n ;; A function pointer under AIX is a pointer to a data area whose first word\n ;; contains the actual address of the function, whose second word contains a\n ;; pointer to its TOC, and whose third word contains a value to place in the\n@@ -6550,7 +6597,8 @@\n   \"DEFAULT_ABI == ABI_AIX\n    && (INTVAL (operands[2]) == CALL_NORMAL || (INTVAL (operands[2]) & CALL_LONG) != 0)\"\n   \"{st|stw} %4,%a3\\;{l|lwz} %6,0(%0)\\;{l|lwz} %4,4(%0)\\;mt%7 %6\\;{l|lwz} %5,8(%0)\\;{brl|blrl}\\;{l|lwz} %4,%a3\"\n-  [(set_attr \"length\" \"28\")])\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"28\")])\n \n (define_insn \"call_value_indirect_aix\"\n   [(set (match_operand 0 \"register_operand\" \"fg\")\n@@ -6565,7 +6613,8 @@\n   \"DEFAULT_ABI == ABI_AIX\n    && (INTVAL (operands[3]) == CALL_NORMAL || (INTVAL (operands[3]) & CALL_LONG) != 0)\"\n   \"{st|stw} %5,%a4\\;{l|lwz} %7,0(%1)\\;{l|lwz} %5,4(%1);\\;mt%8 %7\\;{l|lwz} %6,8(%1)\\;{brl|blrl}\\;{l|lwz} %5,%a4\"\n-  [(set_attr \"length\" \"28\")])\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"28\")])\n \n ;; A function pointer undef NT is a pointer to a data area whose first word\n ;; contains the actual address of the function, whose second word contains a\n@@ -6592,7 +6641,8 @@\n   \"DEFAULT_ABI == ABI_NT\n    && (INTVAL (operands[2]) == CALL_NORMAL || (INTVAL (operands[2]) & CALL_LONG) != 0)\"\n   \"{st|stw} %4,%a3\\;{l|lwz} %5,0(%0)\\;{l|lwz} %4,4(%0)\\;mt%6 %5\\;{brl|blrl}\\;{l|lwz} %4,%a3\"\n-  [(set_attr \"length\" \"24\")])\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"24\")])\n \n (define_insn \"call_value_indirect_nt\"\n   [(set (match_operand 0 \"register_operand\" \"fg\")\n@@ -6606,7 +6656,8 @@\n   \"DEFAULT_ABI == ABI_NT\n    && (INTVAL (operands[3]) == CALL_NORMAL || (INTVAL (operands[3]) & CALL_LONG) != 0)\"\n   \"{st|stw} %5,%a4\\;{l|lwz} %6,0(%1)\\;{l|lwz} %5,4(%1)\\;mt%7 %6\\;{brl|blrl}\\;{l|lwz} %5,%a4\"\n-  [(set_attr \"length\" \"24\")])\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"24\")])\n \n ;; A function pointer under System V is just a normal pointer\n ;; operands[0] is the function pointer\n@@ -6629,7 +6680,8 @@\n \n   return \\\"{brl|blrl}\\\";\n }\"\n-  [(set_attr \"length\" \"4,8\")])\n+  [(set_attr \"type\" \"jmpreg\")\n+   (set_attr \"length\" \"4,8\")])\n \n (define_insn \"call_value_indirect_sysv\"\n   [(set (match_operand 0 \"register_operand\" \"=fg,fg\")\n@@ -6648,7 +6700,8 @@\n \n   return \\\"{brl|blrl}\\\";\n }\"\n-  [(set_attr \"length\" \"4,8\")])\n+  [(set_attr \"type\" \"jmpreg\")\n+   (set_attr \"length\" \"4,8\")])\n \n ;; Now the definitions for the call and call_value insns\n (define_expand \"call\"\n@@ -6792,7 +6845,8 @@\n \n   return \\\"bl %z0\\\";\n }\"\n-  [(set_attr \"length\" \"4,8\")])\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"4,8\")])\n \n ;; Call to function which may be in another module.  Restore the TOC\n ;; pointer (r2) after the call unless this is System V.\n@@ -6822,7 +6876,8 @@\n \n   return (TARGET_WINDOWS_NT) ? \\\"bl %z0\\;.znop %z0\\\" : \\\"bl %z0\\;%.\\\";\n }\"\n-  [(set_attr \"length\" \"8,12\")])\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"8,12\")])\n \n (define_insn \"\"\n   [(call (mem:SI (match_operand:SI 0 \"call_operand\" \"s,s\"))\n@@ -6845,7 +6900,8 @@\n \n   return \\\"bl %z0\\\";\n }\"\n-  [(set_attr \"length\" \"4,8\")])\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"4,8\")])\n \n (define_insn \"\"\n   [(set (match_operand 0 \"\" \"=fg,fg\")\n@@ -6864,7 +6920,8 @@\n \n   return \\\"bl %z1\\\";\n }\"\n-  [(set_attr \"length\" \"4,8\")])\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"4,8\")])\n \n (define_insn \"\"\n   [(set (match_operand 0 \"\" \"=fg,fg\")\n@@ -6888,7 +6945,8 @@\n \n   return (TARGET_WINDOWS_NT) ? \\\"bl %z1\\;.znop %z1\\\" : \\\"bl %z1\\;%.\\\";\n }\"\n-  [(set_attr \"length\" \"8,12\")])\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"8,12\")])\n \n (define_insn \"\"\n   [(set (match_operand 0 \"\" \"=fg,fg\")\n@@ -6912,11 +6970,10 @@\n \n   return \\\"bl %z1\\\";\n }\"\n-  [(set_attr \"length\" \"4,8\")])\n-\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"4,8\")])\n \n ;; Call subroutine returning any type.\n-\n (define_expand \"untyped_call\"\n   [(parallel [(call (match_operand 0 \"\" \"\")\n \t\t    (const_int 0))\n@@ -8590,7 +8647,8 @@\n \t\t      (pc)))]\n   \"direct_return ()\"\n   \"{%C0bcr|%C0bclr} %t0,%j0\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"8\")])\n \n (define_insn \"\"\n   [(set (pc)\n@@ -8620,15 +8678,17 @@\n \t\t      (return)))]\n   \"direct_return ()\"\n   \"{%C0bcr|%C0bclr} %T0,%j0\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"8\")])\n \n ;; Unconditional branch and return.\n \n (define_insn \"jump\"\n   [(set (pc)\n \t(label_ref (match_operand 0 \"\" \"\")))]\n   \"\"\n-  \"b %l0\")\n+  \"b %l0\"\n+  [(set_attr \"type\" \"branch\")])\n \n (define_insn \"return\"\n   [(return)]"}]}