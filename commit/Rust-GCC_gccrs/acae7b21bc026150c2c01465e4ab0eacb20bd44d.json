{"sha": "acae7b21bc026150c2c01465e4ab0eacb20bd44d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWNhZTdiMjFiYzAyNjE1MGMyYzAxNDY1ZTRhYjBlYWNiMjBiZDQ0ZA==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-01-07T17:30:30Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-01-09T22:45:46Z"}, "message": "d: Implement expression-based contract syntax\n\nExpression-based contract syntax has been added.  Contracts that consist\nof a single assertion can now be written more succinctly and multiple\n`in` or `out` contracts can be specified for the same function.\n\nReviewed-on: https://github.com/dlang/dmd/pull/12106\n\ngcc/d/ChangeLog:\n\n\t* dmd/MERGE: Merge upstream dmd e598f69c0.", "tree": {"sha": "b0ed635955a5668753257db827e230358448ee0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0ed635955a5668753257db827e230358448ee0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/acae7b21bc026150c2c01465e4ab0eacb20bd44d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acae7b21bc026150c2c01465e4ab0eacb20bd44d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acae7b21bc026150c2c01465e4ab0eacb20bd44d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acae7b21bc026150c2c01465e4ab0eacb20bd44d/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2a5346244a18c89bebac078657d0f74dbb24622", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2a5346244a18c89bebac078657d0f74dbb24622", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2a5346244a18c89bebac078657d0f74dbb24622"}], "stats": {"total": 649, "additions": 551, "deletions": 98}, "files": [{"sha": "f6c8f6f02cf2ac2e65c4fe368e8fa4d28ebaf2fa", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acae7b21bc026150c2c01465e4ab0eacb20bd44d/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acae7b21bc026150c2c01465e4ab0eacb20bd44d/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=acae7b21bc026150c2c01465e4ab0eacb20bd44d", "patch": "@@ -1,4 +1,4 @@\n-9038e64c5b67a10763d32893f53bb6c610df3595\n+e598f69c0726ad1bf6b2e15e0b60d7cead737fad\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "627464a635f2e45985d0ae2b32108e04caff4595", "filename": "gcc/d/dmd/arraytypes.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acae7b21bc026150c2c01465e4ab0eacb20bd44d/gcc%2Fd%2Fdmd%2Farraytypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acae7b21bc026150c2c01465e4ab0eacb20bd44d/gcc%2Fd%2Fdmd%2Farraytypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Farraytypes.h?ref=acae7b21bc026150c2c01465e4ab0eacb20bd44d", "patch": "@@ -61,3 +61,5 @@ typedef Array<class ReturnStatement *> ReturnStatements;\n typedef Array<class GotoStatement *> GotoStatements;\n \n typedef Array<class TemplateInstance *> TemplateInstances;\n+\n+typedef Array<struct Ensure> Ensures;"}, {"sha": "19e4d1a5aa84e51d78fb4bab2da9fe42a934ae78", "filename": "gcc/d/dmd/declaration.h", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acae7b21bc026150c2c01465e4ab0eacb20bd44d/gcc%2Fd%2Fdmd%2Fdeclaration.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acae7b21bc026150c2c01465e4ab0eacb20bd44d/gcc%2Fd%2Fdmd%2Fdeclaration.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.h?ref=acae7b21bc026150c2c01465e4ab0eacb20bd44d", "patch": "@@ -20,6 +20,16 @@ class LabelDsymbol;\n class Initializer;\n class Module;\n class ForeachStatement;\n+struct Ensure\n+{\n+    Identifier *id;\n+    Statement *ensure;\n+\n+    Ensure();\n+    Ensure(Identifier *id, Statement *ensure);\n+    Ensure syntaxCopy();\n+    static Ensures *arraySyntaxCopy(Ensures *a);\n+};\n class FuncDeclaration;\n class ExpInitializer;\n class StructDeclaration;\n@@ -516,8 +526,10 @@ class FuncDeclaration : public Declaration\n {\n public:\n     Types *fthrows;                     // Array of Type's of exceptions (not used)\n-    Statement *frequire;\n-    Statement *fensure;\n+    Statements *frequires;              // in contracts\n+    Ensures *fensures;                  // out contracts\n+    Statement *frequire;                // lowered in contract\n+    Statement *fensure;                 // lowered out contract\n     Statement *fbody;\n \n     FuncDeclarations foverrides;        // functions this function overrides\n@@ -526,8 +538,7 @@ class FuncDeclaration : public Declaration\n \n     const char *mangleString;           // mangled symbol created from mangleExact()\n \n-    Identifier *outId;                  // identifier for out statement\n-    VarDeclaration *vresult;            // variable corresponding to outId\n+    VarDeclaration *vresult;            // result variable for out contracts\n     LabelDsymbol *returnLabel;          // where the return goes\n \n     // used to prevent symbols in different"}, {"sha": "f8f43dc09bba9ed2a25714b25da438fd15bff9cd", "filename": "gcc/d/dmd/func.c", "status": "modified", "additions": 167, "deletions": 39, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acae7b21bc026150c2c01465e4ab0eacb20bd44d/gcc%2Fd%2Fdmd%2Ffunc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acae7b21bc026150c2c01465e4ab0eacb20bd44d/gcc%2Fd%2Fdmd%2Ffunc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffunc.c?ref=acae7b21bc026150c2c01465e4ab0eacb20bd44d", "patch": "@@ -292,6 +292,42 @@ class NrvoWalker : public StatementRewriteWalker\n     }\n };\n \n+/***********************************************************\n+ * Tuple of result identifier (possibly null) and statement.\n+ * This is used to store out contracts: out(id){ ensure }\n+ */\n+Ensure::Ensure()\n+{\n+    this->id = NULL;\n+    this->ensure = NULL;\n+}\n+\n+Ensure::Ensure(Identifier *id, Statement *ensure)\n+{\n+    this->id = id;\n+    this->ensure = ensure;\n+}\n+\n+Ensure Ensure::syntaxCopy()\n+{\n+    return Ensure(id, ensure->syntaxCopy());\n+}\n+\n+/*****************************************\n+ * Do syntax copy of an array of Ensure's.\n+ */\n+Ensures *Ensure::arraySyntaxCopy(Ensures *a)\n+{\n+    Ensures *b = NULL;\n+    if (a)\n+    {\n+        b = a->copy();\n+        for (size_t i = 0; i < a->length; i++)\n+            (*b)[i] = (*a)[i].syntaxCopy();\n+    }\n+    return b;\n+}\n+\n /********************************* FuncDeclaration ****************************/\n \n FuncDeclaration::FuncDeclaration(Loc loc, Loc endloc, Identifier *id, StorageClass storage_class, Type *type)\n@@ -314,10 +350,11 @@ FuncDeclaration::FuncDeclaration(Loc loc, Loc endloc, Identifier *id, StorageCla\n     fdrequire = NULL;\n     fdensure = NULL;\n     mangleString = NULL;\n-    outId = NULL;\n     vresult = NULL;\n     returnLabel = NULL;\n     fensure = NULL;\n+    frequires = NULL;\n+    fensures = NULL;\n     fbody = NULL;\n     localsymtab = NULL;\n     vthis = NULL;\n@@ -372,10 +409,9 @@ Dsymbol *FuncDeclaration::syntaxCopy(Dsymbol *s)\n     FuncDeclaration *f =\n         s ? (FuncDeclaration *)s\n           : new FuncDeclaration(loc, endloc, ident, storage_class, type->syntaxCopy());\n-    f->outId = outId;\n-    f->frequire = frequire ? frequire->syntaxCopy() : NULL;\n-    f->fensure  = fensure  ? fensure->syntaxCopy()  : NULL;\n-    f->fbody    = fbody    ? fbody->syntaxCopy()    : NULL;\n+    f->frequires = frequires ? Statement::arraySyntaxCopy(frequires) : NULL;\n+    f->fensures = fensures ? Ensure::arraySyntaxCopy(fensures) : NULL;\n+    f->fbody = fbody ? fbody->syntaxCopy() : NULL;\n     assert(!fthrows); // deprecated\n     return f;\n }\n@@ -441,6 +477,28 @@ static void initInferAttributes(FuncDeclaration *fd)\n         fd->flags |= FUNCFLAGinferScope;\n }\n \n+// Returns true if a contract can appear without a function body.\n+static bool allowsContractWithoutBody(FuncDeclaration *funcdecl)\n+{\n+    assert(!funcdecl->fbody);\n+\n+    /* Contracts can only appear without a body when they are virtual\n+     * interface functions or abstract.\n+     */\n+    Dsymbol *parent = funcdecl->toParent();\n+    InterfaceDeclaration *id = parent->isInterfaceDeclaration();\n+\n+    if (!funcdecl->isAbstract() &&\n+        (funcdecl->fensures || funcdecl->frequires) &&\n+        !(id && funcdecl->isVirtual()))\n+    {\n+        ClassDeclaration *cd = parent->isClassDeclaration();\n+        if (!(cd && cd->isAbstract()))\n+            return false;\n+    }\n+    return true;\n+}\n+\n // Do the semantic analysis on the external interface to the function.\n \n void FuncDeclaration::semantic(Scope *sc)\n@@ -780,11 +838,6 @@ void FuncDeclaration::semantic(Scope *sc)\n             error(\"destructors, postblits and invariants are not allowed in union %s\", ud->toChars());\n     }\n \n-    /* Contracts can only appear without a body when they are virtual interface functions\n-     */\n-    if (!fbody && (fensure || frequire) && !(id && isVirtual()))\n-        error(\"in and out contracts require function body\");\n-\n     if (parent->isStructDeclaration())\n     {\n         if (isCtorDeclaration())\n@@ -1157,6 +1210,12 @@ void FuncDeclaration::semantic(Scope *sc)\n     // Reflect this->type to f because it could be changed by findVtblIndex\n     f = type->toTypeFunction();\n \n+Ldone:\n+    /* Contracts can only appear without a body when they are virtual interface functions\n+     */\n+    if (!fbody && !allowsContractWithoutBody(this))\n+        error(\"in and out contracts can only appear without a body when they are virtual interface functions or abstract\");\n+\n     /* Do not allow template instances to add virtual functions\n      * to a class.\n      */\n@@ -1186,7 +1245,6 @@ void FuncDeclaration::semantic(Scope *sc)\n     if (isMain())\n         checkDmain();       // Check main() parameters and return type\n \n-Ldone:\n     /* Purity and safety can be inferred for some functions by examining\n      * the function body.\n      */\n@@ -1270,7 +1328,7 @@ void FuncDeclaration::semantic2(Scope *sc)\n  */\n static bool needsFensure(FuncDeclaration *fd)\n {\n-    if (fd->fensure)\n+    if (fd->fensures)\n         return true;\n \n     for (size_t i = 0; i < fd->foverrides.length; i++)\n@@ -1287,16 +1345,83 @@ static bool needsFensure(FuncDeclaration *fd)\n }\n \n /****************************************************\n- * Rewrite contracts as nested functions, then call them. Doing it as nested\n- * functions means that overriding functions can call them.\n+ * Check whether result variable can be built.\n+ * Returns:\n+ *     `true` if the function has a return type that\n+ *     is different from `void`.\n+ */\n+static bool canBuildResultVar(FuncDeclaration *fd)\n+{\n+    TypeFunction *f = (TypeFunction *)fd->type;\n+    return f && f->nextOf() && f->nextOf()->toBasetype()->ty != Tvoid;\n+}\n+\n+/****************************************************\n+ * Rewrite contracts as statements.\n  * Params:\n- *      fd = the function to rewrite contracts for\n+ *      fdx = the function to rewrite contracts for\n  */\n static void buildEnsureRequire(FuncDeclaration *fdx)\n {\n+    if (fdx->frequires)\n+    {\n+        /*   in { statements1... }\n+         *   in { statements2... }\n+         *   ...\n+         * becomes:\n+         *   in { { statements1... } { statements2... } ... }\n+         */\n+        assert(fdx->frequires->length);\n+        Loc loc = (*fdx->frequires)[0]->loc;\n+        Statements *s = new Statements;\n+        for (size_t i = 0; i < fdx->frequires->length; i++)\n+        {\n+            Statement *r = (*fdx->frequires)[i];\n+            s->push(new ScopeStatement(r->loc, r, r->loc));\n+        }\n+        fdx->frequire = new CompoundStatement(loc, s);\n+    }\n+\n+    if (fdx->fensures)\n+    {\n+        /*   out(id1) { statements1... }\n+         *   out(id2) { statements2... }\n+         *   ...\n+         * becomes:\n+         *   out(__result) { { ref id1 = __result; { statements1... } }\n+         *                   { ref id2 = __result; { statements2... } } ... }\n+         */\n+        assert(fdx->fensures->length);\n+        Loc loc = (*fdx->fensures)[0].ensure->loc;\n+        Statements *s = new Statements;\n+        for (size_t i = 0; i < fdx->fensures->length; i++)\n+        {\n+            Ensure r = (*fdx->fensures)[i];\n+            if (r.id && canBuildResultVar(fdx))\n+            {\n+                Loc rloc = r.ensure->loc;\n+                IdentifierExp *resultId = new IdentifierExp(rloc, Id::result);\n+                ExpInitializer *init = new ExpInitializer(rloc, resultId);\n+                StorageClass stc = STCref | STCtemp | STCresult;\n+                VarDeclaration *decl = new VarDeclaration(rloc, NULL, r.id, init);\n+                decl->storage_class = stc;\n+                ExpStatement *sdecl = new ExpStatement(rloc, decl);\n+                s->push(new ScopeStatement(rloc, new CompoundStatement(rloc, sdecl, r.ensure), rloc));\n+            }\n+            else\n+            {\n+                s->push(r.ensure);\n+            }\n+        }\n+        fdx->fensure = new CompoundStatement(loc, s);\n+    }\n+\n     if (!fdx->isVirtual())\n         return;\n \n+    /* Rewrite contracts as nested functions, then call them. Doing it as nested\n+     * functions means that overriding functions can call them.\n+     */\n     TypeFunction *f = (TypeFunction *)fdx->type;\n \n     if (fdx->frequire)\n@@ -1322,9 +1447,6 @@ static void buildEnsureRequire(FuncDeclaration *fdx)\n         fdx->fdrequire = fd;\n     }\n \n-    if (!fdx->outId && f->nextOf() && f->nextOf()->toBasetype()->ty != Tvoid)\n-        fdx->outId = Id::result; // provide a default\n-\n     if (fdx->fensure)\n     {\n         /*   out (result) { ... }\n@@ -1335,9 +1457,9 @@ static void buildEnsureRequire(FuncDeclaration *fdx)\n         Loc loc = fdx->fensure->loc;\n         Parameters *fparams = new Parameters();\n         Parameter *p = NULL;\n-        if (fdx->outId)\n+        if (canBuildResultVar(fdx))\n         {\n-            p = new Parameter(STCref | STCconst, f->nextOf(), fdx->outId, NULL, NULL);\n+            p = new Parameter(STCref | STCconst, f->nextOf(), Id::result, NULL, NULL);\n             fparams->push(p);\n         }\n         TypeFunction *tf = new TypeFunction(ParameterList(fparams), Type::tvoid, LINKd);\n@@ -1350,8 +1472,8 @@ static void buildEnsureRequire(FuncDeclaration *fdx)\n         fd->fbody = fdx->fensure;\n         Statement *s1 = new ExpStatement(loc, fd);\n         Expression *eresult = NULL;\n-        if (fdx->outId)\n-            eresult = new IdentifierExp(loc, fdx->outId);\n+        if (canBuildResultVar(fdx))\n+            eresult = new IdentifierExp(loc, Id::result);\n         Expression *e = new CallExp(loc, new VarExp(loc, fd, false), eresult);\n         Statement *s2 = new ExpStatement(loc, e);\n         fdx->fensure = new CompoundStatement(loc, s1, s2);\n@@ -1435,13 +1557,13 @@ void FuncDeclaration::semantic3(Scope *sc)\n \n     unsigned oldErrors = global.errors;\n \n-    if (frequire)\n+    if (frequires)\n     {\n         for (size_t i = 0; i < foverrides.length; i++)\n         {\n             FuncDeclaration *fdv = foverrides[i];\n \n-            if (fdv->fbody && !fdv->frequire)\n+            if (fdv->fbody && !fdv->frequires)\n             {\n                 error(\"cannot have an in contract when overriden function %s does not have an in contract\", fdv->toPrettyChars());\n                 break;\n@@ -1450,9 +1572,9 @@ void FuncDeclaration::semantic3(Scope *sc)\n     }\n \n     // Remember whether we need to generate an 'out' contract.\n-    bool needEnsure = needsFensure(this);\n+    const bool needEnsure = needsFensure(this);\n \n-    if (fbody || frequire || needEnsure)\n+    if (fbody || frequires || needEnsure)\n     {\n         /* Symbol table into which we place parameters and nested functions,\n          * solely to diagnose name collisions.\n@@ -2039,7 +2161,7 @@ void FuncDeclaration::semantic3(Scope *sc)\n         }\n \n         frequire = mergeFrequire(frequire);\n-        fensure = mergeFensure(fensure, outId);\n+        fensure = mergeFensure(fensure, Id::result);\n \n         Statement *freq = frequire;\n         Statement *fens = fensure;\n@@ -2075,8 +2197,18 @@ void FuncDeclaration::semantic3(Scope *sc)\n         {\n             /* fensure is composed of the [out] contracts\n              */\n-            if (f->next->ty == Tvoid && outId)\n-                error(\"void functions have no result\");\n+            if (f->next->ty == Tvoid && fensures)\n+            {\n+                for (size_t i = 0; i < fensures->length; i++)\n+                {\n+                    Ensure e = (*fensures)[i];\n+                    if (e.id)\n+                    {\n+                        error(e.ensure->loc, \"`void` functions have no result\");\n+                        //fens = NULL;\n+                    }\n+                }\n+            }\n \n             sc2 = scout;    //push\n             sc2->flags = (sc2->flags & ~SCOPEcontract) | SCOPEensure;\n@@ -2263,8 +2395,7 @@ void FuncDeclaration::semantic3(Scope *sc)\n             }\n \n             // If declaration has no body, don't set sbody to prevent incorrect codegen.\n-            InterfaceDeclaration *id = parent->isInterfaceDeclaration();\n-            if (fbody || (id && (fdensure || fdrequire) && isVirtual()))\n+            if (fbody || allowsContractWithoutBody(this))\n                 fbody = sbody;\n         }\n \n@@ -2277,7 +2408,7 @@ void FuncDeclaration::semantic3(Scope *sc)\n             }\n         }\n \n-        if (naked && (fensure || frequire))\n+        if (naked && (fensures || frequires))\n             error(\"naked assembly functions with contracts are not supported\");\n \n         sc2->callSuper = 0;\n@@ -2610,11 +2741,8 @@ void FuncDeclaration::buildResultVar(Scope *sc, Type *tret)\n          * So, in here it may be a temporary type for vresult, and after\n          * fbody->semantic() running, vresult->type might be modified.\n          */\n-        vresult = new VarDeclaration(loc, tret, outId ? outId : Id::result, NULL);\n-        vresult->storage_class |= STCnodtor;\n-\n-        if (outId == Id::result)\n-            vresult->storage_class |= STCtemp;\n+        vresult = new VarDeclaration(loc, tret, Id::result, NULL);\n+        vresult->storage_class |= STCnodtor | STCtemp;\n         if (!isVirtual())\n             vresult->storage_class |= STCconst;\n         vresult->storage_class |= STCresult;\n@@ -2685,7 +2813,7 @@ Statement *FuncDeclaration::mergeFrequire(Statement *sf)\n          * be completed before code generation occurs.\n          * https://issues.dlang.org/show_bug.cgi?id=3602\n          */\n-        if (fdv->frequire && fdv->semanticRun != PASSsemantic3done)\n+        if (fdv->frequires && fdv->semanticRun != PASSsemantic3done)\n         {\n             assert(fdv->_scope);\n             Scope *sc = fdv->_scope->push();\n@@ -2758,7 +2886,7 @@ Statement *FuncDeclaration::mergeFensure(Statement *sf, Identifier *oid)\n             //printf(\"fdv->fensure: %s\\n\", fdv->fensure->toChars());\n             // Make the call: __ensure(result)\n             Expression *eresult = NULL;\n-            if (outId)\n+            if (canBuildResultVar(this))\n             {\n                 eresult = new IdentifierExp(loc, oid);\n "}, {"sha": "a351930ce457389b5b9bdada2c14cee94f7aa7f7", "filename": "gcc/d/dmd/hdrgen.c", "status": "modified", "additions": 65, "deletions": 16, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acae7b21bc026150c2c01465e4ab0eacb20bd44d/gcc%2Fd%2Fdmd%2Fhdrgen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acae7b21bc026150c2c01465e4ab0eacb20bd44d/gcc%2Fd%2Fdmd%2Fhdrgen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fhdrgen.c?ref=acae7b21bc026150c2c01465e4ab0eacb20bd44d", "patch": "@@ -1950,32 +1950,70 @@ class PrettyPrintVisitor : public Visitor\n         int saveauto = hgs->autoMember;\n         hgs->tpltMember = 0;\n         hgs->autoMember = 0;\n-\n         buf->writenl();\n-\n+        bool requireDo = false;\n         // in{}\n-        if (f->frequire)\n+        if (f->frequires)\n         {\n-            buf->writestring(\"in\");\n-            buf->writenl();\n-            f->frequire->accept(this);\n+            for (size_t i = 0; i < f->frequires->length; i++)\n+            {\n+                Statement *frequire = (*f->frequires)[i];\n+                buf->writestring(\"in\");\n+                if (ExpStatement *es = frequire->isExpStatement())\n+                {\n+                    assert(es->exp && es->exp->op == TOKassert);\n+                    buf->writestring(\" (\");\n+                    ((AssertExp *)es->exp)->e1->accept(this);\n+                    buf->writeByte(')');\n+                    buf->writenl();\n+                    requireDo = false;\n+                }\n+                else\n+                {\n+                    buf->writenl();\n+                    frequire->accept(this);\n+                    requireDo = true;\n+                }\n+            }\n         }\n \n         // out{}\n-        if (f->fensure)\n+        if (f->fensures)\n         {\n-            buf->writestring(\"out\");\n-            if (f->outId)\n+            for (size_t i = 0; i < f->fensures->length; i++)\n             {\n-                buf->writeByte('(');\n-                buf->writestring(f->outId->toChars());\n-                buf->writeByte(')');\n+                Ensure fensure = (*f->fensures)[i];\n+                buf->writestring(\"out\");\n+                if (ExpStatement *es = fensure.ensure->isExpStatement())\n+                {\n+                    assert(es->exp && es->exp->op == TOKassert);\n+                    buf->writestring(\" (\");\n+                    if (fensure.id)\n+                    {\n+                        buf->writestring(fensure.id->toChars());\n+                    }\n+                    buf->writestring(\"; \");\n+                    ((AssertExp *)es->exp)->e1->accept(this);\n+                    buf->writeByte(')');\n+                    buf->writenl();\n+                    requireDo = false;\n+                }\n+                else\n+                {\n+                    if (fensure.id)\n+                    {\n+                        buf->writeByte('(');\n+                        buf->writestring(fensure.id->toChars());\n+                        buf->writeByte(')');\n+                    }\n+                    buf->writenl();\n+                    fensure.ensure->accept(this);\n+                    requireDo = true;\n+                }\n             }\n-            buf->writenl();\n-            f->fensure->accept(this);\n         }\n \n-        if (f->frequire || f->fensure)\n+        if (requireDo)\n         {\n             buf->writestring(\"body\");\n             buf->writenl();\n@@ -2093,7 +2131,18 @@ class PrettyPrintVisitor : public Visitor\n         if (stcToBuffer(buf, d->storage_class))\n             buf->writeByte(' ');\n         buf->writestring(\"invariant\");\n-        bodyToBuffer(d);\n+        if (ExpStatement *es = d->fbody->isExpStatement())\n+        {\n+            assert(es->exp && es->exp->op == TOKassert);\n+            buf->writestring(\" (\");\n+            ((AssertExp *)es->exp)->e1->accept(this);\n+            buf->writestring(\");\");\n+            buf->writenl();\n+        }\n+        else\n+        {\n+            bodyToBuffer(d);\n+        }\n     }\n \n     void visit(UnitTestDeclaration *d)"}, {"sha": "80aaac089eccfd2c0b6163b21e64cf13708d4359", "filename": "gcc/d/dmd/parse.c", "status": "modified", "additions": 116, "deletions": 23, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acae7b21bc026150c2c01465e4ab0eacb20bd44d/gcc%2Fd%2Fdmd%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acae7b21bc026150c2c01465e4ab0eacb20bd44d/gcc%2Fd%2Fdmd%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.c?ref=acae7b21bc026150c2c01465e4ab0eacb20bd44d", "patch": "@@ -372,11 +372,11 @@ Dsymbols *Parser::parseDeclDefs(int once, Dsymbol **pLastDecl, PrefixAttributes\n             case TOKinvariant:\n             {\n                 Token *t = peek(&token);\n-                if ((t->value == TOKlparen && peek(t)->value == TOKrparen) ||\n-                    t->value == TOKlcurly)\n+                if (t->value == TOKlparen || t->value == TOKlcurly)\n                 {\n-                    // invariant {}\n-                    // invariant() {}\n+                    // invariant { statements... }\n+                    // invariant() { statements... }\n+                    // invariant (expression);\n                     s = parseInvariant(pAttrs);\n                 }\n                 else\n@@ -1846,7 +1846,9 @@ Dsymbol *Parser::parseSharedStaticDtor(PrefixAttributes *pAttrs)\n \n /*****************************************\n  * Parse an invariant definition:\n- *      invariant() { body }\n+ *      invariant { statements... }\n+ *      invariant() { statements... }\n+ *      invariant (expression);\n  * Current token is 'invariant'.\n  */\n \n@@ -1856,10 +1858,35 @@ Dsymbol *Parser::parseInvariant(PrefixAttributes *pAttrs)\n     StorageClass stc = pAttrs ? pAttrs->storageClass : STCundefined;\n \n     nextToken();\n-    if (token.value == TOKlparen)       // optional ()\n+    if (token.value == TOKlparen) // optional () or invariant (expression);\n     {\n         nextToken();\n-        check(TOKrparen);\n+        if (token.value != TOKrparen) // invariant (expression);\n+        {\n+            Expression *e = parseAssignExp();\n+            Expression *msg = NULL;\n+            if (token.value == TOKcomma)\n+            {\n+                nextToken();\n+                if (token.value != TOKrparen)\n+                {\n+                    msg = parseAssignExp();\n+                    if (token.value == TOKcomma)\n+                        nextToken();\n+                }\n+            }\n+            check(TOKrparen);\n+            check(TOKsemicolon);\n+            e = new AssertExp(loc, e, msg);\n+            ExpStatement *fbody = new ExpStatement(loc, e);\n+            InvariantDeclaration *f = new InvariantDeclaration(loc, token.loc, stc);\n+            f->fbody = fbody;\n+            return f;\n+        }\n+        else\n+        {\n+            nextToken();\n+        }\n     }\n \n     InvariantDeclaration *f = new InvariantDeclaration(loc, Loc(), stc);\n@@ -4426,11 +4453,12 @@ FuncDeclaration *Parser::parseContracts(FuncDeclaration *f)\n     // The following is irrelevant, as it is overridden by sc->linkage in\n     // TypeFunction::semantic\n     linkage = LINKd;            // nested functions have D linkage\n+    bool requireDo = false;\n L1:\n     switch (token.value)\n     {\n         case TOKlcurly:\n-            if (f->frequire || f->fensure)\n+            if (requireDo)\n                 error(\"missing body { ... } after in or out\");\n             f->fbody = parseStatement(PSsemi);\n             f->endloc = endloc;\n@@ -4448,35 +4476,100 @@ FuncDeclaration *Parser::parseContracts(FuncDeclaration *f)\n             break;\n \n         case TOKin:\n+        {\n+            // in { statements... }\n+            // in (expression)\n+            Loc loc = token.loc;\n             nextToken();\n-            if (f->frequire)\n-                error(\"redundant 'in' statement\");\n-            f->frequire = parseStatement(PScurly | PSscope);\n+            if (!f->frequires)\n+            {\n+                f->frequires = new Statements();\n+            }\n+            if (token.value == TOKlparen)\n+            {\n+                nextToken();\n+                Expression *e = parseAssignExp();\n+                Expression *msg = NULL;\n+                if (token.value == TOKcomma)\n+                {\n+                    nextToken();\n+                    if (token.value != TOKrparen)\n+                    {\n+                        msg = parseAssignExp();\n+                        if (token.value == TOKcomma)\n+                            nextToken();\n+                    }\n+                }\n+                check(TOKrparen);\n+                e = new AssertExp(loc, e, msg);\n+                f->frequires->push(new ExpStatement(loc, e));\n+                requireDo = false;\n+            }\n+            else\n+            {\n+                f->frequires->push(parseStatement(PScurly | PSscope));\n+                requireDo = true;\n+            }\n             goto L1;\n+        }\n \n         case TOKout:\n-            // parse: out (identifier) { statement }\n+        {\n+            // out { statements... }\n+            // out (; expression)\n+            // out (identifier) { statements... }\n+            // out (identifier; expression)\n+            Loc loc = token.loc;\n             nextToken();\n+            if (!f->fensures)\n+            {\n+                f->fensures = new Ensures();\n+            }\n+            Identifier *id = NULL;\n             if (token.value != TOKlcurly)\n             {\n                 check(TOKlparen);\n-                if (token.value != TOKidentifier)\n-                    error(\"(identifier) following 'out' expected, not %s\", token.toChars());\n-                f->outId = token.ident;\n-                nextToken();\n+                if (token.value != TOKidentifier && token.value != TOKsemicolon)\n+                    error(\"`(identifier) { ... }` or `(identifier; expression)` following `out` expected, not `%s`\", token.toChars());\n+                if (token.value != TOKsemicolon)\n+                {\n+                    id = token.ident;\n+                    nextToken();\n+                }\n+                if (token.value == TOKsemicolon)\n+                {\n+                    nextToken();\n+                    Expression *e = parseAssignExp();\n+                    Expression *msg = NULL;\n+                    if (token.value == TOKcomma)\n+                    {\n+                        nextToken();\n+                        if (token.value != TOKrparen)\n+                        {\n+                            msg = parseAssignExp();\n+                            if (token.value == TOKcomma)\n+                                nextToken();\n+                        }\n+                    }\n+                    check(TOKrparen);\n+                    e = new AssertExp(loc, e, msg);\n+                    f->fensures->push(Ensure(id, new ExpStatement(loc, e)));\n+                    requireDo = false;\n+                    goto L1;\n+                }\n                 check(TOKrparen);\n             }\n-            if (f->fensure)\n-                error(\"redundant 'out' statement\");\n-            f->fensure = parseStatement(PScurly | PSscope);\n+            f->fensures->push(Ensure(id, parseStatement(PScurly | PSscope)));\n+            requireDo = true;\n             goto L1;\n+        }\n \n         case TOKsemicolon:\n             if (!literal)\n             {\n                 // Bugzilla 15799: Semicolon becomes a part of function declaration\n-                // only when neither of contracts exists.\n-                if (!f->frequire && !f->fensure)\n+                // only when 'do' is not required\n+                if (!requireDo)\n                     nextToken();\n                 break;\n             }\n@@ -4486,10 +4579,10 @@ FuncDeclaration *Parser::parseContracts(FuncDeclaration *f)\n         Ldefault:\n             if (literal)\n             {\n-                const char *sbody = (f->frequire || f->fensure) ? \"body \" : \"\";\n+                const char *sbody = requireDo ? \"do \" : \"\";\n                 error(\"missing %s{ ... } for function literal\", sbody);\n             }\n-            else if (!f->frequire && !f->fensure)   // allow these even with no body\n+            else if (!requireDo)   // allow these even with no body\n             {\n                 error(\"semicolon expected following function declaration\");\n             }"}, {"sha": "76dfe1d3f06f33d910d4c30110e0d0ab0bc00e5a", "filename": "gcc/d/dmd/statement.c", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acae7b21bc026150c2c01465e4ab0eacb20bd44d/gcc%2Fd%2Fdmd%2Fstatement.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acae7b21bc026150c2c01465e4ab0eacb20bd44d/gcc%2Fd%2Fdmd%2Fstatement.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatement.c?ref=acae7b21bc026150c2c01465e4ab0eacb20bd44d", "patch": "@@ -109,6 +109,24 @@ Statement *Statement::syntaxCopy()\n     return NULL;\n }\n \n+/*************************************\n+ * Do syntax copy of an array of Statement's.\n+ */\n+Statements *Statement::arraySyntaxCopy(Statements *a)\n+{\n+    Statements *b = NULL;\n+    if (a)\n+    {\n+        b = a->copy();\n+        for (size_t i = 0; i < a->length; i++)\n+        {\n+            Statement *s = (*a)[i];\n+            (*b)[i] = s ? s->syntaxCopy() : NULL;\n+        }\n+    }\n+    return b;\n+}\n+\n void Statement::print()\n {\n     fprintf(stderr, \"%s\\n\", toChars());\n@@ -560,14 +578,7 @@ CompoundStatement *CompoundStatement::create(Loc loc, Statement *s1, Statement *\n \n Statement *CompoundStatement::syntaxCopy()\n {\n-    Statements *a = new Statements();\n-    a->setDim(statements->length);\n-    for (size_t i = 0; i < statements->length; i++)\n-    {\n-        Statement *s = (*statements)[i];\n-        (*a)[i] = s ? s->syntaxCopy() : NULL;\n-    }\n-    return new CompoundStatement(loc, a);\n+    return new CompoundStatement(loc, Statement::arraySyntaxCopy(statements));\n }\n \n Statements *CompoundStatement::flatten(Scope *)"}, {"sha": "08eb5fd0fa5121416d6e31ec87b094cd44c567f6", "filename": "gcc/d/dmd/statement.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acae7b21bc026150c2c01465e4ab0eacb20bd44d/gcc%2Fd%2Fdmd%2Fstatement.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acae7b21bc026150c2c01465e4ab0eacb20bd44d/gcc%2Fd%2Fdmd%2Fstatement.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatement.h?ref=acae7b21bc026150c2c01465e4ab0eacb20bd44d", "patch": "@@ -74,6 +74,7 @@ class Statement : public ASTNode\n \n     Statement(Loc loc);\n     virtual Statement *syntaxCopy();\n+    static Statements *arraySyntaxCopy(Statements *a);\n \n     void print();\n     const char *toChars();"}, {"sha": "5eb6afd1787b29def995e85cee312fb43fe6ecf5", "filename": "gcc/testsuite/gdc.test/compilable/extra-files/header1.d", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acae7b21bc026150c2c01465e4ab0eacb20bd44d/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Fheader1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acae7b21bc026150c2c01465e4ab0eacb20bd44d/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Fheader1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Fheader1.d?ref=acae7b21bc026150c2c01465e4ab0eacb20bd44d", "patch": "@@ -10,6 +10,30 @@ static assert(true, \"message\");\n \n alias double mydbl;\n \n+alias fl1 = function ()\n+    in {}\n+    in (true)\n+    out (; true)\n+    out (r; true)\n+    out\n+    {\n+    }\n+    out (r)\n+    {\n+    }\n+    do\n+    {\n+        return 2;\n+    };\n+\n+alias fl2 = function ()\n+    in (true)\n+    out(; true)\n+    out(r; true)\n+    {\n+        return 2;\n+    };\n+\n int testmain()\n in\n {\n@@ -133,11 +157,11 @@ template Foo(T, int V)\n     }\n \n     try\n-\t    bar(1, 2);\n+\tbar(1, 2);\n     catch(Object o)\n-\t    x++;\n+\tx++;\n     finally\n-\t    x--;\n+\tx--;\n \n     Object o;\n     synchronized (o)\n@@ -244,6 +268,7 @@ class Test\n \n     pure nothrow @safe @nogc unittest {}\n     pure nothrow @safe @nogc invariant {}\n+    pure nothrow @safe @nogc invariant (true);\n \n     pure nothrow @safe @nogc new (size_t sz) { return null; }\n     pure nothrow @safe @nogc delete (void* p) { }"}, {"sha": "b1366d136b9c26a3bdb0c201941a62367ba733f0", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail17502.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acae7b21bc026150c2c01465e4ab0eacb20bd44d/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17502.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acae7b21bc026150c2c01465e4ab0eacb20bd44d/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17502.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17502.d?ref=acae7b21bc026150c2c01465e4ab0eacb20bd44d", "patch": "@@ -1,10 +1,10 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail17502.d(12): Error: function fail17502.Foo.foo void functions have no result\n-fail_compilation/fail17502.d(13): Error: cannot have parameter of type const(void)\n-fail_compilation/fail17502.d(16): Error: function fail17502.Foo.bar void functions have no result\n-fail_compilation/fail17502.d(17): Error: cannot have parameter of type const(void)\n+fail_compilation/fail17502.d(13): Error: function `fail17502.Foo.foo` `void` functions have no result\n+fail_compilation/fail17502.d(13): Error: undefined identifier `res`\n+fail_compilation/fail17502.d(17): Error: function `fail17502.Foo.bar` `void` functions have no result\n+fail_compilation/fail17502.d(17): Error: undefined identifier `res`\n ---\n */\n class Foo"}, {"sha": "f99a10afff24e5d2df42c1aa29b407e7cd54b270", "filename": "gcc/testsuite/gdc.test/runnable/testcontracts.d", "status": "modified", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acae7b21bc026150c2c01465e4ab0eacb20bd44d/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestcontracts.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acae7b21bc026150c2c01465e4ab0eacb20bd44d/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestcontracts.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestcontracts.d?ref=acae7b21bc026150c2c01465e4ab0eacb20bd44d", "patch": "@@ -421,6 +421,56 @@ void test6417()\n     (new Bug6417).bar();\n }\n \n+/*******************************************/\n+// 6549\n+\n+class C6549\n+{\n+    static int ocount = 0;\n+    static int icount = 0;\n+\n+    abstract int foo(int)\n+    in { ++icount; }\n+    out { ++ocount; }\n+}\n+\n+class CD6549 : C6549\n+{\n+    override int foo(int)\n+    in { assert(false); }\n+    do { return 10; }\n+}\n+\n+abstract class D6549\n+{\n+    static int icount = 0;\n+    static int ocount = 0;\n+\n+    int foo(int)\n+    in { ++icount; }\n+    out { ++ocount; }\n+}\n+\n+class DD6549 : D6549\n+{\n+    override int foo(int)\n+    in { assert(false); }\n+    do { return 10; }\n+}\n+\n+void test6549()\n+{\n+    auto c = new CD6549;\n+    c.foo(10);\n+    assert(C6549.icount == 1);\n+    assert(C6549.ocount == 1);\n+\n+    auto d = new DD6549;\n+    d.foo(10);\n+    assert(D6549.icount == 1);\n+    assert(D6549.ocount == 1);\n+}\n+\n /*******************************************/\n // 7218\n \n@@ -1030,6 +1080,81 @@ void test14779()\n \n /*******************************************/\n \n+//******************************************/\n+// DIP 1009\n+\n+int dip1009_1(int x)\n+  in  (x > 0, \"x must be positive!\")\n+  out (r; r < 0, \"r must be negative!\")\n+  in (true, \"cover trailing comma case\",)\n+  out (; true, \"cover trailing comma case\",)\n+{\n+    return -x;\n+}\n+\n+int dip1009_2(int x)\n+  in  (x > 0)\n+  out (r; r < 0)\n+{\n+    return -x;\n+}\n+\n+int dip1009_3(int x)\n+in  (x > 0,)\n+out (r; r < 0,)\n+do\n+{\n+    return -x;\n+}\n+\n+void dip1009_4(int x)\n+  in  (x > 0)\n+  out (; x > 1)\n+{\n+    x += 1;\n+}\n+\n+interface DIP1009_5\n+{\n+    void dip1009_5(int x)\n+      in  (x > 0)\n+      out (; x > 1);\n+}\n+\n+int dip1009_6(int x, int y)\n+  in  (x > 0)\n+  out (r; r > 1)\n+  out (; x > 0)\n+  in  (y > 0)\n+  in  (x + y > 1)\n+  out (r; r > 1)\n+{\n+    return x+y;\n+}\n+\n+int dip1009_7(int x)\n+  in (x > 0)\n+  in { assert(x > 1); }\n+  out { assert(x > 2); }\n+  out (; x > 3)\n+  out (r; r > 3)\n+{\n+    x += 2;\n+    return x;\n+}\n+\n+class DIP1009_8\n+{\n+    private int x = 4;\n+    invariant (x > 0, \"x must stay positive\");\n+    invariant (x > 1, \"x must be greater than one\",);\n+    invariant (x > 2);\n+    invariant (x > 3,);\n+    void foo(){ x = 5; }\n+}\n+\n+/*******************************************/\n+\n int main()\n {\n     test1();\n@@ -1043,6 +1168,7 @@ int main()\n     test9();\n     test4785();\n     test6417();\n+    test6549();\n     test7218();\n     test7517();\n     test8073();\n@@ -1051,6 +1177,13 @@ int main()\n     test15524();\n     test15524a();\n     test14779();\n+    dip1009_1(1);\n+    dip1009_2(1);\n+    dip1009_3(1);\n+    dip1009_4(1);\n+    dip1009_6(1, 1);\n+    dip1009_7(3);\n+    new DIP1009_8().foo();\n \n     printf(\"Success\\n\");\n     return 0;"}]}