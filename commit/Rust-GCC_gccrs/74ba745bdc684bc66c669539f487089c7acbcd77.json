{"sha": "74ba745bdc684bc66c669539f487089c7acbcd77", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzRiYTc0NWJkYzY4NGJjNjZjNjY5NTM5ZjQ4NzA4OWM3YWNiY2Q3Nw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-11-20T17:44:45Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-11-20T17:44:45Z"}, "message": "Makefile.in (OBJS): Add gimple-ssa-evrp-analyze.o.\n\n\t* Makefile.in (OBJS): Add gimple-ssa-evrp-analyze.o.\n\t* gimple-ssa-evrp-analyze.c: New file pulled from gimple-ssa-evrp.c.\n\t* gimple-ssa-evrp-analyze.h: New file pulled from gimple-ssa-evrp.c.\n\t* gimple-ssa-evrp.c: Remove bits moved into new files.  Include\n\tgimple-ssa-evrp-analyze.h.\n\nFrom-SVN: r254961", "tree": {"sha": "508745dee41b1d0f3a0e677873e5b715f9d91acb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/508745dee41b1d0f3a0e677873e5b715f9d91acb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74ba745bdc684bc66c669539f487089c7acbcd77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74ba745bdc684bc66c669539f487089c7acbcd77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74ba745bdc684bc66c669539f487089c7acbcd77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74ba745bdc684bc66c669539f487089c7acbcd77/comments", "author": null, "committer": null, "parents": [{"sha": "8c66dd9b3330192da7b5e173acbe7bb58bf7a89d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c66dd9b3330192da7b5e173acbe7bb58bf7a89d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c66dd9b3330192da7b5e173acbe7bb58bf7a89d"}], "stats": {"total": 774, "additions": 422, "deletions": 352}, "files": [{"sha": "05b3e656b87c5cdab425e08642cff71afdf42a2e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74ba745bdc684bc66c669539f487089c7acbcd77/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74ba745bdc684bc66c669539f487089c7acbcd77/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=74ba745bdc684bc66c669539f487089c7acbcd77", "patch": "@@ -1,5 +1,11 @@\n 2017-11-20  Jeff Law  <law@redhat.com>\n \n+\t* Makefile.in (OBJS): Add gimple-ssa-evrp-analyze.o.\n+\t* gimple-ssa-evrp-analyze.c: New file pulled from gimple-ssa-evrp.c.\n+\t* gimple-ssa-evrp-analyze.h: New file pulled from gimple-ssa-evrp.c.\n+\t* gimple-ssa-evrp.c: Remove bits moved into new files.  Include\n+\tgimple-ssa-evrp-analyze.h.\n+\n \t* gimple-ssa-evrp.c (evrp_dom_walker::before_dom_children): Do not\n \tset BB_VISITED here.\n \t(evrp_range_analyzer::enter): Set BB_VISITED here instead."}, {"sha": "38ab4e8102685dbc7686114255f469e01c346a98", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74ba745bdc684bc66c669539f487089c7acbcd77/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74ba745bdc684bc66c669539f487089c7acbcd77/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=74ba745bdc684bc66c669539f487089c7acbcd77", "patch": "@@ -1302,6 +1302,7 @@ OBJS = \\\n \tgimple-pretty-print.o \\\n \tgimple-ssa-backprop.o \\\n \tgimple-ssa-evrp.o \\\n+\tgimple-ssa-evrp-analyze.o \\\n \tgimple-ssa-isolate-paths.o \\\n \tgimple-ssa-nonnull-compare.o \\\n \tgimple-ssa-split-paths.o \\"}, {"sha": "9e581834d08234314dc012f1ef02893285d58896", "filename": "gcc/gimple-ssa-evrp-analyze.c", "status": "added", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74ba745bdc684bc66c669539f487089c7acbcd77/gcc%2Fgimple-ssa-evrp-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74ba745bdc684bc66c669539f487089c7acbcd77/gcc%2Fgimple-ssa-evrp-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp-analyze.c?ref=74ba745bdc684bc66c669539f487089c7acbcd77", "patch": "@@ -0,0 +1,343 @@\n+/* Support routines for Value Range Propagation (VRP).\n+   Copyright (C) 2005-2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"tree-pass.h\"\n+#include \"ssa.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"cfganal.h\"\n+#include \"gimple-fold.h\"\n+#include \"tree-eh.h\"\n+#include \"gimple-iterator.h\"\n+#include \"tree-cfg.h\"\n+#include \"tree-ssa-loop-manip.h\"\n+#include \"tree-ssa-loop.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"tree-ssa-propagate.h\"\n+#include \"alloc-pool.h\"\n+#include \"domwalk.h\"\n+#include \"tree-cfgcleanup.h\"\n+#include \"vr-values.h\"\n+#include \"gimple-ssa-evrp-analyze.h\"\n+\n+evrp_range_analyzer::evrp_range_analyzer () : stack (10)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  basic_block bb;\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      bb->flags &= ~BB_VISITED;\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+        e->flags |= EDGE_EXECUTABLE;\n+    }\n+}\n+\n+void\n+evrp_range_analyzer::enter (basic_block bb)\n+{\n+  stack.safe_push (std::make_pair (NULL_TREE, (value_range *)NULL));\n+  record_ranges_from_incoming_edge (bb);\n+  record_ranges_from_phis (bb);\n+  bb->flags |= BB_VISITED;\n+}\n+\n+/* Find new range for NAME such that (OP CODE LIMIT) is true.  */\n+value_range *\n+evrp_range_analyzer::try_find_new_range (tree name,\n+\t\t\t\t    tree op, tree_code code, tree limit)\n+{\n+  value_range vr = VR_INITIALIZER;\n+  value_range *old_vr = get_value_range (name);\n+\n+  /* Discover VR when condition is true.  */\n+  extract_range_for_var_from_comparison_expr (name, code, op,\n+\t\t\t\t\t      limit, &vr);\n+  /* If we found any usable VR, set the VR to ssa_name and create a\n+     PUSH old value in the stack with the old VR.  */\n+  if (vr.type == VR_RANGE || vr.type == VR_ANTI_RANGE)\n+    {\n+      if (old_vr->type == vr.type\n+\t  && vrp_operand_equal_p (old_vr->min, vr.min)\n+\t  && vrp_operand_equal_p (old_vr->max, vr.max))\n+\treturn NULL;\n+      value_range *new_vr = vr_values.vrp_value_range_pool.allocate ();\n+      *new_vr = vr;\n+      return new_vr;\n+    }\n+  return NULL;\n+}\n+\n+void\n+evrp_range_analyzer::record_ranges_from_incoming_edge (basic_block bb)\n+{\n+  edge pred_e = single_pred_edge_ignoring_loop_edges (bb, false);\n+  if (pred_e)\n+    {\n+      gimple *stmt = last_stmt (pred_e->src);\n+      tree op0 = NULL_TREE;\n+\n+      if (stmt\n+\t  && gimple_code (stmt) == GIMPLE_COND\n+\t  && (op0 = gimple_cond_lhs (stmt))\n+\t  && TREE_CODE (op0) == SSA_NAME\n+\t  && (INTEGRAL_TYPE_P (TREE_TYPE (gimple_cond_lhs (stmt)))\n+\t      || POINTER_TYPE_P (TREE_TYPE (gimple_cond_lhs (stmt)))))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Visiting controlling predicate \");\n+\t      print_gimple_stmt (dump_file, stmt, 0);\n+\t    }\n+\t  /* Entering a new scope.  Try to see if we can find a VR\n+\t     here.  */\n+\t  tree op1 = gimple_cond_rhs (stmt);\n+\t  if (TREE_OVERFLOW_P (op1))\n+\t    op1 = drop_tree_overflow (op1);\n+\t  tree_code code = gimple_cond_code (stmt);\n+\n+\t  auto_vec<assert_info, 8> asserts;\n+\t  register_edge_assert_for (op0, pred_e, code, op0, op1, asserts);\n+\t  if (TREE_CODE (op1) == SSA_NAME)\n+\t    register_edge_assert_for (op1, pred_e, code, op0, op1, asserts);\n+\n+\t  auto_vec<std::pair<tree, value_range *>, 8> vrs;\n+\t  for (unsigned i = 0; i < asserts.length (); ++i)\n+\t    {\n+\t      value_range *vr = try_find_new_range (asserts[i].name,\n+\t\t\t\t\t\t    asserts[i].expr,\n+\t\t\t\t\t\t    asserts[i].comp_code,\n+\t\t\t\t\t\t    asserts[i].val);\n+\t      if (vr)\n+\t\tvrs.safe_push (std::make_pair (asserts[i].name, vr));\n+\t    }\n+\t  /* Push updated ranges only after finding all of them to avoid\n+\t     ordering issues that can lead to worse ranges.  */\n+\t  for (unsigned i = 0; i < vrs.length (); ++i)\n+\t    push_value_range (vrs[i].first, vrs[i].second);\n+\t}\n+    }\n+}\n+\n+void\n+evrp_range_analyzer::record_ranges_from_phis (basic_block bb)\n+{\n+  /* Visit PHI stmts and discover any new VRs possible.  */\n+  bool has_unvisited_preds = false;\n+  edge_iterator ei;\n+  edge e;\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    if (e->flags & EDGE_EXECUTABLE\n+\t&& !(e->src->flags & BB_VISITED))\n+      {\n+\thas_unvisited_preds = true;\n+\tbreak;\n+      }\n+\n+  for (gphi_iterator gpi = gsi_start_phis (bb);\n+       !gsi_end_p (gpi); gsi_next (&gpi))\n+    {\n+      gphi *phi = gpi.phi ();\n+      tree lhs = PHI_RESULT (phi);\n+      if (virtual_operand_p (lhs))\n+\tcontinue;\n+\n+      value_range vr_result = VR_INITIALIZER;\n+      bool interesting = stmt_interesting_for_vrp (phi);\n+      if (!has_unvisited_preds && interesting)\n+\textract_range_from_phi_node (phi, &vr_result);\n+      else\n+\t{\n+\t  set_value_range_to_varying (&vr_result);\n+\t  /* When we have an unvisited executable predecessor we can't\n+\t     use PHI arg ranges which may be still UNDEFINED but have\n+\t     to use VARYING for them.  But we can still resort to\n+\t     SCEV for loop header PHIs.  */\n+\t  struct loop *l;\n+\t  if (interesting\n+\t      && (l = loop_containing_stmt (phi))\n+\t      && l->header == gimple_bb (phi))\n+\t  adjust_range_with_scev (&vr_result, l, phi, lhs);\n+\t}\n+      update_value_range (lhs, &vr_result);\n+\n+      /* Set the SSA with the value range.  */\n+      if (INTEGRAL_TYPE_P (TREE_TYPE (lhs)))\n+\t{\n+\t  if ((vr_result.type == VR_RANGE\n+\t       || vr_result.type == VR_ANTI_RANGE)\n+\t      && (TREE_CODE (vr_result.min) == INTEGER_CST)\n+\t      && (TREE_CODE (vr_result.max) == INTEGER_CST))\n+\t    set_range_info (lhs, vr_result.type,\n+\t\t\t    wi::to_wide (vr_result.min),\n+\t\t\t    wi::to_wide (vr_result.max));\n+\t}\n+      else if (POINTER_TYPE_P (TREE_TYPE (lhs))\n+\t       && ((vr_result.type == VR_RANGE\n+\t\t    && range_includes_zero_p (vr_result.min,\n+\t\t\t\t\t      vr_result.max) == 0)\n+\t\t   || (vr_result.type == VR_ANTI_RANGE\n+\t\t       && range_includes_zero_p (vr_result.min,\n+\t\t\t\t\t\t vr_result.max) == 1)))\n+\tset_ptr_nonnull (lhs);\n+    }\n+}\n+\n+void\n+evrp_range_analyzer::record_ranges_from_stmt (gimple *stmt)\n+{\n+  tree output = NULL_TREE;\n+\n+  if (dyn_cast <gcond *> (stmt))\n+    ;\n+  else if (stmt_interesting_for_vrp (stmt))\n+    {\n+      edge taken_edge;\n+      value_range vr = VR_INITIALIZER;\n+      extract_range_from_stmt (stmt, &taken_edge, &output, &vr);\n+      if (output\n+\t  && (vr.type == VR_RANGE || vr.type == VR_ANTI_RANGE))\n+\t{\n+\t  update_value_range (output, &vr);\n+\n+\t  /* Set the SSA with the value range.  */\n+\t  if (INTEGRAL_TYPE_P (TREE_TYPE (output)))\n+\t    {\n+\t      if ((vr.type == VR_RANGE || vr.type == VR_ANTI_RANGE)\n+\t\t  && (TREE_CODE (vr.min) == INTEGER_CST)\n+\t\t  && (TREE_CODE (vr.max) == INTEGER_CST))\n+\t\tset_range_info (output, vr.type,\n+\t\t\t\twi::to_wide (vr.min),\n+\t\t\t\twi::to_wide (vr.max));\n+\t    }\n+\t  else if (POINTER_TYPE_P (TREE_TYPE (output))\n+\t\t   && ((vr.type == VR_RANGE\n+\t\t\t&& range_includes_zero_p (vr.min, vr.max) == 0)\n+\t\t       || (vr.type == VR_ANTI_RANGE\n+\t\t\t   && range_includes_zero_p (vr.min, vr.max) == 1)))\n+\t    set_ptr_nonnull (output);\n+\t}\n+      else\n+\tset_defs_to_varying (stmt);\n+    }\n+  else\n+    set_defs_to_varying (stmt);\n+\n+  /* See if we can derive a range for any of STMT's operands.  */\n+  tree op;\n+  ssa_op_iter i;\n+  FOR_EACH_SSA_TREE_OPERAND (op, stmt, i, SSA_OP_USE)\n+    {\n+      tree value;\n+      enum tree_code comp_code;\n+\n+      /* If OP is used in such a way that we can infer a value\n+         range for it, and we don't find a previous assertion for\n+         it, create a new assertion location node for OP.  */\n+      if (infer_value_range (stmt, op, &comp_code, &value))\n+\t{\n+\t  /* If we are able to infer a nonzero value range for OP,\n+\t     then walk backwards through the use-def chain to see if OP\n+\t     was set via a typecast.\n+\t     If so, then we can also infer a nonzero value range\n+\t     for the operand of the NOP_EXPR.  */\n+\t  if (comp_code == NE_EXPR && integer_zerop (value))\n+\t    {\n+\t      tree t = op;\n+\t      gimple *def_stmt = SSA_NAME_DEF_STMT (t);\n+\t      while (is_gimple_assign (def_stmt)\n+\t\t     && CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (def_stmt))\n+\t\t     && TREE_CODE\n+\t\t\t  (gimple_assign_rhs1 (def_stmt)) == SSA_NAME\n+\t\t     && POINTER_TYPE_P\n+\t\t\t  (TREE_TYPE (gimple_assign_rhs1 (def_stmt))))\n+\t\t{\n+\t\t  t = gimple_assign_rhs1 (def_stmt);\n+\t\t  def_stmt = SSA_NAME_DEF_STMT (t);\n+\n+\t\t  /* Add VR when (T COMP_CODE value) condition is\n+\t\t     true.  */\n+\t\t  value_range *op_range\n+\t\t    = try_find_new_range (t, t, comp_code, value);\n+\t\t  if (op_range)\n+\t\t    push_value_range (t, op_range);\n+\t\t}\n+\t    }\n+\t  /* Add VR when (OP COMP_CODE value) condition is true.  */\n+\t  value_range *op_range = try_find_new_range (op, op,\n+\t\t\t\t\t\t      comp_code, value);\n+\t  if (op_range)\n+\t    push_value_range (op, op_range);\n+\t}\n+    }\n+}\n+\n+/* Restore/pop VRs valid only for BB when we leave BB.  */\n+\n+void\n+evrp_range_analyzer::leave (basic_block bb ATTRIBUTE_UNUSED)\n+{\n+  gcc_checking_assert (!stack.is_empty ());\n+  while (stack.last ().first != NULL_TREE)\n+    pop_value_range (stack.last ().first);\n+  stack.pop ();\n+}\n+\n+/* Push the Value Range of VAR to the stack and update it with new VR.  */\n+\n+void\n+evrp_range_analyzer::push_value_range (tree var, value_range *vr)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"pushing new range for \");\n+      print_generic_expr (dump_file, var);\n+      fprintf (dump_file, \": \");\n+      dump_value_range (dump_file, vr);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+  stack.safe_push (std::make_pair (var, get_value_range (var)));\n+  set_vr_value (var, vr);\n+}\n+\n+/* Pop the Value Range from the vrp_stack and update VAR with it.  */\n+\n+value_range *\n+evrp_range_analyzer::pop_value_range (tree var)\n+{\n+  value_range *vr = stack.last ().second;\n+  gcc_checking_assert (var == stack.last ().first);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"popping range for \");\n+      print_generic_expr (dump_file, var);\n+      fprintf (dump_file, \", restoring \");\n+      dump_value_range (dump_file, vr);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+  set_vr_value (var, vr);\n+  stack.pop ();\n+  return vr;\n+}"}, {"sha": "2e6c609c45b44fcf13f5ee24f142e654ba71dee3", "filename": "gcc/gimple-ssa-evrp-analyze.h", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74ba745bdc684bc66c669539f487089c7acbcd77/gcc%2Fgimple-ssa-evrp-analyze.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74ba745bdc684bc66c669539f487089c7acbcd77/gcc%2Fgimple-ssa-evrp-analyze.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp-analyze.h?ref=74ba745bdc684bc66c669539f487089c7acbcd77", "patch": "@@ -0,0 +1,71 @@\n+/* Support routines for Value Range Propagation (VRP).\n+   Copyright (C) 2016-2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_GIMPLE_SSA_EVRP_ANALYZE_H\n+#define GCC_GIMPLE_SSA_EVRP_ANALYZE_H\n+\n+class evrp_range_analyzer\n+{\n+ public:\n+  evrp_range_analyzer (void);\n+  ~evrp_range_analyzer (void) { stack.release (); }\n+\n+  void enter (basic_block);\n+  void leave (basic_block);\n+  void record_ranges_from_stmt (gimple *);\n+\n+  class vr_values vr_values;\n+\n+ private:\n+  DISABLE_COPY_AND_ASSIGN (evrp_range_analyzer);\n+  void push_value_range (tree var, value_range *vr);\n+  value_range *pop_value_range (tree var);\n+  value_range *try_find_new_range (tree, tree op, tree_code code, tree limit);\n+  void record_ranges_from_incoming_edge (basic_block);\n+  void record_ranges_from_phis (basic_block);\n+\n+  /* STACK holds the old VR.  */\n+  auto_vec<std::pair <tree, value_range*> > stack;\n+\n+  /* Temporary delegators.  */\n+  value_range *get_value_range (const_tree op)\n+    { return vr_values.get_value_range (op); }\n+  bool update_value_range (const_tree op, value_range *vr)\n+    { return vr_values.update_value_range (op, vr); }\n+  void extract_range_from_phi_node (gphi *phi, value_range *vr)\n+    { vr_values.extract_range_from_phi_node (phi, vr); }\n+  void adjust_range_with_scev (value_range *vr, struct loop *loop,\n+                               gimple *stmt, tree var)\n+    { vr_values.adjust_range_with_scev (vr, loop, stmt, var); }\n+  void extract_range_from_stmt (gimple *stmt, edge *taken_edge_p,\n+                                tree *output_p, value_range *vr)\n+    { vr_values.extract_range_from_stmt (stmt, taken_edge_p, output_p, vr); }\n+  void set_defs_to_varying (gimple *stmt)\n+    { return vr_values.set_defs_to_varying (stmt); }\n+  void set_vr_value (tree name, value_range *vr)\n+    { vr_values.set_vr_value (name, vr); }\n+  void extract_range_for_var_from_comparison_expr (tree var,\n+\t\t\t\t\t\t   enum tree_code cond_code,\n+\t\t\t\t\t\t   tree op, tree limit,\n+\t\t\t\t\t\t   value_range *vr_p)\n+    { vr_values.extract_range_for_var_from_comparison_expr (var, cond_code,\n+\t\t\t\t\t\t\t    op, limit, vr_p); }\n+};\n+\n+#endif /* GCC_GIMPLE_SSA_EVRP_ANALYZE_H */"}, {"sha": "27a983dd9ae8eb6f251f3d495d5f7d3b77b3778a", "filename": "gcc/gimple-ssa-evrp.c", "status": "modified", "additions": 1, "deletions": 352, "changes": 353, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74ba745bdc684bc66c669539f487089c7acbcd77/gcc%2Fgimple-ssa-evrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74ba745bdc684bc66c669539f487089c7acbcd77/gcc%2Fgimple-ssa-evrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp.c?ref=74ba745bdc684bc66c669539f487089c7acbcd77", "patch": "@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"domwalk.h\"\n #include \"tree-cfgcleanup.h\"\n #include \"vr-values.h\"\n+#include \"gimple-ssa-evrp-analyze.h\"\n \n class evrp_folder : public substitute_and_fold_engine\n {\n@@ -55,69 +56,6 @@ evrp_folder::get_value (tree op)\n   return vr_values->op_with_constant_singleton_value_range (op);\n }\n \n-class evrp_range_analyzer\n-{\n- public:\n-  evrp_range_analyzer (void);\n-  ~evrp_range_analyzer (void) { stack.release (); }\n-\n-  void enter (basic_block);\n-  void leave (basic_block);\n-  void record_ranges_from_stmt (gimple *);\n-\n-  class vr_values vr_values;\n-\n- private:\n-  DISABLE_COPY_AND_ASSIGN (evrp_range_analyzer);\n-  void push_value_range (tree var, value_range *vr);\n-  value_range *pop_value_range (tree var);\n-  value_range *try_find_new_range (tree, tree op, tree_code code, tree limit);\n-  void record_ranges_from_incoming_edge (basic_block);\n-  void record_ranges_from_phis (basic_block);\n-\n-  /* STACK holds the old VR.  */\n-  auto_vec<std::pair <tree, value_range*> > stack;\n-\n-  /* Temporary delegators.  */\n-  value_range *get_value_range (const_tree op)\n-    { return vr_values.get_value_range (op); }\n-  bool update_value_range (const_tree op, value_range *vr)\n-    { return vr_values.update_value_range (op, vr); }\n-  void extract_range_from_phi_node (gphi *phi, value_range *vr)\n-    { vr_values.extract_range_from_phi_node (phi, vr); }\n-  void adjust_range_with_scev (value_range *vr, struct loop *loop,\n-                               gimple *stmt, tree var)\n-    { vr_values.adjust_range_with_scev (vr, loop, stmt, var); }\n-  void extract_range_from_stmt (gimple *stmt, edge *taken_edge_p,\n-                                tree *output_p, value_range *vr)\n-    { vr_values.extract_range_from_stmt (stmt, taken_edge_p, output_p, vr); }\n-  void set_defs_to_varying (gimple *stmt)\n-    { return vr_values.set_defs_to_varying (stmt); }\n-  void set_vr_value (tree name, value_range *vr)\n-    { vr_values.set_vr_value (name, vr); }\n-  void extract_range_for_var_from_comparison_expr (tree var,\n-\t\t\t\t\t\t   enum tree_code cond_code,\n-\t\t\t\t\t\t   tree op, tree limit,\n-\t\t\t\t\t\t   value_range *vr_p)\n-    { vr_values.extract_range_for_var_from_comparison_expr (var, cond_code,\n-\t\t\t\t\t\t\t    op, limit, vr_p); }\n-};\n-\n-evrp_range_analyzer::evrp_range_analyzer () : stack (10)\n-{\n-  edge e;\n-  edge_iterator ei;\n-  basic_block bb;\n-\n-  FOR_EACH_BB_FN (bb, cfun)\n-    {\n-      bb->flags &= ~BB_VISITED;\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n-\te->flags |= EDGE_EXECUTABLE;\n-    }\n-}\n-\n-\n /* evrp_dom_walker visits the basic blocks in the dominance order and set\n    the Value Ranges (VR) for SSA_NAMEs in the scope.  Use this VR to\n    discover more VRs.  */\n@@ -154,247 +92,6 @@ class evrp_dom_walker : public dom_walker\n     { evrp_range_analyzer.vr_values.vrp_visit_cond_stmt (cond, e); }\n };\n \n-void\n-evrp_range_analyzer::enter (basic_block bb)\n-{\n-  stack.safe_push (std::make_pair (NULL_TREE, (value_range *)NULL));\n-  record_ranges_from_incoming_edge (bb);\n-  record_ranges_from_phis (bb);\n-  bb->flags |= BB_VISITED;\n-}\n-\n-/* Find new range for NAME such that (OP CODE LIMIT) is true.  */\n-value_range *\n-evrp_range_analyzer::try_find_new_range (tree name,\n-\t\t\t\t    tree op, tree_code code, tree limit)\n-{\n-  value_range vr = VR_INITIALIZER;\n-  value_range *old_vr = get_value_range (name);\n-\n-  /* Discover VR when condition is true.  */\n-  extract_range_for_var_from_comparison_expr (name, code, op,\n-\t\t\t\t\t      limit, &vr);\n-  /* If we found any usable VR, set the VR to ssa_name and create a\n-     PUSH old value in the stack with the old VR.  */\n-  if (vr.type == VR_RANGE || vr.type == VR_ANTI_RANGE)\n-    {\n-      if (old_vr->type == vr.type\n-\t  && vrp_operand_equal_p (old_vr->min, vr.min)\n-\t  && vrp_operand_equal_p (old_vr->max, vr.max))\n-\treturn NULL;\n-      value_range *new_vr = vr_values.vrp_value_range_pool.allocate ();\n-      *new_vr = vr;\n-      return new_vr;\n-    }\n-  return NULL;\n-}\n-\n-/* If BB is reached by a single incoming edge (ignoring loop edges),\n-   then derive ranges implied by traversing that edge.  */\n-\n-void\n-evrp_range_analyzer::record_ranges_from_incoming_edge (basic_block bb)\n-{\n-  edge pred_e = single_pred_edge_ignoring_loop_edges (bb, false);\n-  if (pred_e)\n-    {\n-      gimple *stmt = last_stmt (pred_e->src);\n-      tree op0 = NULL_TREE;\n-\n-      if (stmt\n-\t  && gimple_code (stmt) == GIMPLE_COND\n-\t  && (op0 = gimple_cond_lhs (stmt))\n-\t  && TREE_CODE (op0) == SSA_NAME\n-\t  && (INTEGRAL_TYPE_P (TREE_TYPE (gimple_cond_lhs (stmt)))\n-\t      || POINTER_TYPE_P (TREE_TYPE (gimple_cond_lhs (stmt)))))\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"Visiting controlling predicate \");\n-\t      print_gimple_stmt (dump_file, stmt, 0);\n-\t    }\n-\t  /* Entering a new scope.  Try to see if we can find a VR\n-\t     here.  */\n-\t  tree op1 = gimple_cond_rhs (stmt);\n-\t  if (TREE_OVERFLOW_P (op1))\n-\t    op1 = drop_tree_overflow (op1);\n-\t  tree_code code = gimple_cond_code (stmt);\n-\n-\t  auto_vec<assert_info, 8> asserts;\n-\t  register_edge_assert_for (op0, pred_e, code, op0, op1, asserts);\n-\t  if (TREE_CODE (op1) == SSA_NAME)\n-\t    register_edge_assert_for (op1, pred_e, code, op0, op1, asserts);\n-\n-\t  auto_vec<std::pair<tree, value_range *>, 8> vrs;\n-\t  for (unsigned i = 0; i < asserts.length (); ++i)\n-\t    {\n-\t      value_range *vr = try_find_new_range (asserts[i].name,\n-\t\t\t\t\t\t    asserts[i].expr,\n-\t\t\t\t\t\t    asserts[i].comp_code,\n-\t\t\t\t\t\t    asserts[i].val);\n-\t      if (vr)\n-\t\tvrs.safe_push (std::make_pair (asserts[i].name, vr));\n-\t    }\n-\t  /* Push updated ranges only after finding all of them to avoid\n-\t     ordering issues that can lead to worse ranges.  */\n-\t  for (unsigned i = 0; i < vrs.length (); ++i)\n-\t    push_value_range (vrs[i].first, vrs[i].second);\n-\t}\n-    }\n-}\n-\n-void\n-evrp_range_analyzer::record_ranges_from_phis (basic_block bb)\n-{\n-  /* Visit PHI stmts and discover any new VRs possible.  */\n-  bool has_unvisited_preds = false;\n-  edge_iterator ei;\n-  edge e;\n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    if (e->flags & EDGE_EXECUTABLE\n-\t&& !(e->src->flags & BB_VISITED))\n-      {\n-\thas_unvisited_preds = true;\n-\tbreak;\n-      }\n-\n-  for (gphi_iterator gpi = gsi_start_phis (bb);\n-       !gsi_end_p (gpi); gsi_next (&gpi))\n-    {\n-      gphi *phi = gpi.phi ();\n-      tree lhs = PHI_RESULT (phi);\n-      if (virtual_operand_p (lhs))\n-\tcontinue;\n-\n-      value_range vr_result = VR_INITIALIZER;\n-      bool interesting = stmt_interesting_for_vrp (phi);\n-      if (!has_unvisited_preds && interesting)\n-\textract_range_from_phi_node (phi, &vr_result);\n-      else\n-\t{\n-\t  set_value_range_to_varying (&vr_result);\n-\t  /* When we have an unvisited executable predecessor we can't\n-\t     use PHI arg ranges which may be still UNDEFINED but have\n-\t     to use VARYING for them.  But we can still resort to\n-\t     SCEV for loop header PHIs.  */\n-\t  struct loop *l;\n-\t  if (interesting\n-\t      && (l = loop_containing_stmt (phi))\n-\t      && l->header == gimple_bb (phi))\n-\t  adjust_range_with_scev (&vr_result, l, phi, lhs);\n-\t}\n-      update_value_range (lhs, &vr_result);\n-\n-      /* Set the SSA with the value range.  */\n-      if (INTEGRAL_TYPE_P (TREE_TYPE (lhs)))\n-\t{\n-\t  if ((vr_result.type == VR_RANGE\n-\t       || vr_result.type == VR_ANTI_RANGE)\n-\t      && (TREE_CODE (vr_result.min) == INTEGER_CST)\n-\t      && (TREE_CODE (vr_result.max) == INTEGER_CST))\n-\t    set_range_info (lhs, vr_result.type,\n-\t\t\t    wi::to_wide (vr_result.min),\n-\t\t\t    wi::to_wide (vr_result.max));\n-\t}\n-      else if (POINTER_TYPE_P (TREE_TYPE (lhs))\n-\t       && ((vr_result.type == VR_RANGE\n-\t\t    && range_includes_zero_p (vr_result.min,\n-\t\t\t\t\t      vr_result.max) == 0)\n-\t\t   || (vr_result.type == VR_ANTI_RANGE\n-\t\t       && range_includes_zero_p (vr_result.min,\n-\t\t\t\t\t\t vr_result.max) == 1)))\n-\tset_ptr_nonnull (lhs);\n-    }\n-}\n-\n-/* Record any ranges created by statement STMT.  */\n-\n-void\n-evrp_range_analyzer::record_ranges_from_stmt (gimple *stmt)\n-{\n-  tree output = NULL_TREE;\n-\n-  if (dyn_cast <gcond *> (stmt))\n-    ;\n-  else if (stmt_interesting_for_vrp (stmt))\n-    {\n-      edge taken_edge;\n-      value_range vr = VR_INITIALIZER;\n-      extract_range_from_stmt (stmt, &taken_edge, &output, &vr);\n-      if (output && (vr.type == VR_RANGE || vr.type == VR_ANTI_RANGE))\n-\t{\n-\t  update_value_range (output, &vr);\n-\n-\t  /* Set the SSA with the value range.  */\n-\t  if (INTEGRAL_TYPE_P (TREE_TYPE (output)))\n-\t    {\n-\t      if ((vr.type == VR_RANGE || vr.type == VR_ANTI_RANGE)\n-\t\t  && (TREE_CODE (vr.min) == INTEGER_CST)\n-\t\t  && (TREE_CODE (vr.max) == INTEGER_CST))\n-\t\tset_range_info (output, vr.type,\n-\t\t\t\twi::to_wide (vr.min),\n-\t\t\t\twi::to_wide (vr.max));\n-\t    }\n-\t  else if (POINTER_TYPE_P (TREE_TYPE (output))\n-\t\t   && ((vr.type == VR_RANGE\n-\t\t\t&& range_includes_zero_p (vr.min, vr.max) == 0)\n-\t\t       || (vr.type == VR_ANTI_RANGE\n-\t\t\t   && range_includes_zero_p (vr.min, vr.max) == 1)))\n-\t    set_ptr_nonnull (output);\n-\t}\n-      else\n-\tset_defs_to_varying (stmt);\n-    }\n-  else\n-    set_defs_to_varying (stmt);\n-\n-  /* See if we can derive a range for any of STMT's operands.  */\n-  tree op;\n-  ssa_op_iter i;\n-  FOR_EACH_SSA_TREE_OPERAND (op, stmt, i, SSA_OP_USE)\n-    {\n-      tree value;\n-      enum tree_code comp_code;\n-\n-      /* If OP is used in such a way that we can infer a value\n-\t range for it, and we don't find a previous assertion for\n-\t it, create a new assertion location node for OP.  */\n-      if (infer_value_range (stmt, op, &comp_code, &value))\n-\t{\n-\t  /* If we are able to infer a nonzero value range for OP,\n-\t     then walk backwards through the use-def chain to see if OP\n-\t     was set via a typecast.\n-\t     If so, then we can also infer a nonzero value range\n-\t     for the operand of the NOP_EXPR.  */\n-\t  if (comp_code == NE_EXPR && integer_zerop (value))\n-\t    {\n-\t      tree t = op;\n-\t      gimple *def_stmt = SSA_NAME_DEF_STMT (t);\n-\t      while (is_gimple_assign (def_stmt)\n-\t\t     && CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (def_stmt))\n-\t\t     && TREE_CODE (gimple_assign_rhs1 (def_stmt)) == SSA_NAME\n-\t\t     && POINTER_TYPE_P\n-\t\t\t  (TREE_TYPE (gimple_assign_rhs1 (def_stmt))))\n-\t\t{\n-\t\t  t = gimple_assign_rhs1 (def_stmt);\n-\t\t  def_stmt = SSA_NAME_DEF_STMT (t);\n-\n-\t\t  /* Add VR when (T COMP_CODE value) condition is true.  */\n-\t\t  value_range *op_range\n-\t\t    = try_find_new_range (t, t, comp_code, value);\n-\t\t  if (op_range)\n-\t\t    push_value_range (t, op_range);\n-\t\t}\n-\t    }\n-\t  /* Add VR when (OP COMP_CODE value) condition is true.  */\n-\t  value_range *op_range = try_find_new_range (op, op,\n-\t\t\t\t\t\t      comp_code, value);\n-\t  if (op_range)\n-\t    push_value_range (op, op_range);\n-\t}\n-    }\n-}\n-\n edge\n evrp_dom_walker::before_dom_children (basic_block bb)\n {\n@@ -540,54 +237,6 @@ evrp_dom_walker::after_dom_children (basic_block bb)\n   evrp_range_analyzer.leave (bb);\n }\n \n-/* Restore/pop VRs valid only for BB when we leave BB.  */\n-\n-void\n-evrp_range_analyzer::leave (basic_block bb ATTRIBUTE_UNUSED)\n-{\n-  gcc_checking_assert (!stack.is_empty ());\n-  while (stack.last ().first != NULL_TREE)\n-    pop_value_range (stack.last ().first);\n-  stack.pop ();\n-}\n-\n-/* Push the Value Range of VAR to the stack and update it with new VR.  */\n-\n-void\n-evrp_range_analyzer::push_value_range (tree var, value_range *vr)\n-{\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"pushing new range for \");\n-      print_generic_expr (dump_file, var);\n-      fprintf (dump_file, \": \");\n-      dump_value_range (dump_file, vr);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-  stack.safe_push (std::make_pair (var, get_value_range (var)));\n-  set_vr_value (var, vr);\n-}\n-\n-/* Pop the Value Range from the vrp_stack and update VAR with it.  */\n-\n-value_range *\n-evrp_range_analyzer::pop_value_range (tree var)\n-{\n-  value_range *vr = stack.last ().second;\n-  gcc_checking_assert (var == stack.last ().first);\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"popping range for \");\n-      print_generic_expr (dump_file, var);\n-      fprintf (dump_file, \", restoring \");\n-      dump_value_range (dump_file, vr);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-  set_vr_value (var, vr);\n-  stack.pop ();\n-  return vr;\n-}\n-\n /* Perform any cleanups after the main phase of EVRP has completed.  */\n \n void"}]}