{"sha": "3fe2ddae4b15a17184237097a5c9363eb94fe99a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZlMmRkYWU0YjE1YTE3MTg0MjM3MDk3YTVjOTM2M2ViOTRmZTk5YQ==", "commit": {"author": {"name": "Ville Voutilainen", "email": "ville.voutilainen@gmail.com", "date": "2016-10-03T11:06:53Z"}, "committer": {"name": "Ville Voutilainen", "email": "ville@gcc.gnu.org", "date": "2016-10-03T11:06:53Z"}, "message": "re PR libstdc++/77802 (Boost Fiber doesn't compile)\n\n    PR libstdc++/77802\n    * testsuite/20_util/tuple/77802.cc: New.\n\n    Revert:\n    2016-09-21  Ville Voutilainen  <ville.voutilainen@gmail.com>\n    Implement LWG 2729 for tuple.\n    * include/std/tuple (_Tuple_impl(_Tuple_impl&&)):\n    Suppress conditionally.\n    (_Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&&)): Likewise.\n    (__is_tuple_impl_trait_impl, __is_tuple_impl_trait): New.\n    (_Tuple_impl(const _Head&)): Constrain.\n    (_Tuple_impl(_UHead&&)): Likewise.\n    (_Tuple_impl(_Tuple_impl&&)): Suppress conditionally.\n    (_Tuple_impl(const _Tuple_impl<_Idx, _UHead>&)): Constrain.\n    (_Tuple_impl(_Tuple_impl<_Idx, _UHead>&&)): Likewise.\n    (operator=(const tuple&)): Enable conditionally.\n    (operator=(tuple&&)): Suppress conditionally.\n    (operator=(const tuple<_UElements...>&)): Constrain.\n    (operator=(tuple<_UElements...>&&)): Likewise.\n    (operator=(const tuple&)): Enable conditionally (2-param tuple).\n    (operator=(tuple&&)): Suppress conditionally (2-param tuple).\n    (operator=(const tuple<_U1, _U2>&)): Constrain.\n    (operator=(tuple<_U1, _U2>&&)): Likewise.\n    (operator=(const pair<_U1, _U2>&)): Likewise.\n    (operator=(pair<_U1, _U2>&&)): Likewise.\n    * testsuite/20_util/tuple/element_access/get_neg.cc: Adjust.\n    * testsuite/20_util/tuple/tuple_traits.cc: New.\n\nFrom-SVN: r240709", "tree": {"sha": "1eb19d848dc6e636d1ad47c311b49dcb4f972603", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1eb19d848dc6e636d1ad47c311b49dcb4f972603"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fe2ddae4b15a17184237097a5c9363eb94fe99a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fe2ddae4b15a17184237097a5c9363eb94fe99a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fe2ddae4b15a17184237097a5c9363eb94fe99a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fe2ddae4b15a17184237097a5c9363eb94fe99a/comments", "author": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b44a42cfab6a2c7e25b1665a89e2bb423e47e677", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b44a42cfab6a2c7e25b1665a89e2bb423e47e677", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b44a42cfab6a2c7e25b1665a89e2bb423e47e677"}], "stats": {"total": 421, "additions": 97, "deletions": 324}, "files": [{"sha": "31dfa65bf56bbee295872a70dca17dc0fea17fbf", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe2ddae4b15a17184237097a5c9363eb94fe99a/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe2ddae4b15a17184237097a5c9363eb94fe99a/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=3fe2ddae4b15a17184237097a5c9363eb94fe99a", "patch": "@@ -1,3 +1,33 @@\n+2016-10-03  Ville Voutilainen  <ville.voutilainen@gmail.com>\n+\n+\tPR libstdc++/77802\n+\t* testsuite/20_util/tuple/77802.cc: New.\n+\n+\tRevert:\n+\t2016-09-21  Ville Voutilainen  <ville.voutilainen@gmail.com>\n+\tImplement LWG 2729 for tuple.\n+\t* include/std/tuple (_Tuple_impl(_Tuple_impl&&)):\n+\tSuppress conditionally.\n+\t(_Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&&)): Likewise.\n+\t(__is_tuple_impl_trait_impl, __is_tuple_impl_trait): New.\n+\t(_Tuple_impl(const _Head&)): Constrain.\n+\t(_Tuple_impl(_UHead&&)): Likewise.\n+\t(_Tuple_impl(_Tuple_impl&&)): Suppress conditionally.\n+\t(_Tuple_impl(const _Tuple_impl<_Idx, _UHead>&)): Constrain.\n+\t(_Tuple_impl(_Tuple_impl<_Idx, _UHead>&&)): Likewise.\n+\t(operator=(const tuple&)): Enable conditionally.\n+\t(operator=(tuple&&)): Suppress conditionally.\n+\t(operator=(const tuple<_UElements...>&)): Constrain.\n+\t(operator=(tuple<_UElements...>&&)): Likewise.\n+\t(operator=(const tuple&)): Enable conditionally (2-param tuple).\n+\t(operator=(tuple&&)): Suppress conditionally (2-param tuple).\n+\t(operator=(const tuple<_U1, _U2>&)): Constrain.\n+\t(operator=(tuple<_U1, _U2>&&)): Likewise.\n+\t(operator=(const pair<_U1, _U2>&)): Likewise.\n+\t(operator=(pair<_U1, _U2>&&)): Likewise.\n+\t* testsuite/20_util/tuple/element_access/get_neg.cc: Adjust.\n+\t* testsuite/20_util/tuple/tuple_traits.cc: New.\n+\n 2016-09-30  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/77795"}, {"sha": "c06a040a960995d18da4531a46757460c7ffc55f", "filename": "libstdc++-v3/include/std/tuple", "status": "modified", "additions": 17, "deletions": 79, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe2ddae4b15a17184237097a5c9363eb94fe99a/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe2ddae4b15a17184237097a5c9363eb94fe99a/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple?ref=3fe2ddae4b15a17184237097a5c9363eb94fe99a", "patch": "@@ -220,11 +220,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       constexpr _Tuple_impl(const _Tuple_impl&) = default;\n \n       constexpr\n-      _Tuple_impl(typename conditional<\n-\t\t  __and_<is_move_constructible<_Head>,\n-\t\t         is_move_constructible<_Inherited>>::value,\n-\t\t  _Tuple_impl&&, __nonesuch&&>::type __in)\n-\tnoexcept(__and_<is_nothrow_move_constructible<_Head>,\n+      _Tuple_impl(_Tuple_impl&& __in)\n+      noexcept(__and_<is_nothrow_move_constructible<_Head>,\n \t              is_nothrow_move_constructible<_Inherited>>::value)\n       : _Inherited(std::move(_M_tail(__in))),\n \t_Base(std::forward<_Head>(_M_head(__in))) { }\n@@ -235,11 +232,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }\n \n       template<typename _UHead, typename... _UTails>\n-        constexpr _Tuple_impl(typename conditional<\n-\t\t\t      __and_<is_move_constructible<_Head>,\n-\t\t\t      is_move_constructible<_Inherited>>::value,\n-\t\t\t      _Tuple_impl<_Idx, _UHead, _UTails...>&&,\n-\t\t\t      __nonesuch&&>::type __in)\n+        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)\n \t: _Inherited(std::move\n \t\t     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),\n \t  _Base(std::forward<_UHead>\n@@ -345,18 +338,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n     };\n \n-  template<typename...>\n-    struct __is_tuple_impl_trait_impl : false_type\n-    { };\n-\n-  template<std::size_t _Idx, typename... _Tp>\n-    struct __is_tuple_impl_trait_impl<_Tuple_impl<_Idx, _Tp...>> : true_type\n-    { };\n-\n-  template<typename _Tp>\n-    struct __is_tuple_impl_trait : public __is_tuple_impl_trait_impl<_Tp>\n-    { };\n-\n   // Basis case of inheritance recursion.\n   template<std::size_t _Idx, typename _Head>\n     struct _Tuple_impl<_Idx, _Head>\n@@ -375,42 +356,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       constexpr _Tuple_impl()\n       : _Base() { }\n \n-      template<typename _Dummy=void,\n-\t       typename enable_if<is_constructible<_Base, const _Head&>::value,\n-\t\t\t\t  bool>::type=true>\n       explicit\n       constexpr _Tuple_impl(const _Head& __head)\n       : _Base(__head) { }\n \n-      template<typename _UHead,\n-\t       typename enable_if<__and_<is_constructible<_Base, _UHead&&>,\n-\t\t\t\t\t __not_<__is_tuple_impl_trait<\n-\t\t\t\t\t   typename\n-\t\t\t\t\t     remove_reference<_UHead>::type>>\n-\t\t\t\t\t >::value,\n-\t\t\t\t  bool>::type = true>\n+      template<typename _UHead>\n         explicit\n         constexpr _Tuple_impl(_UHead&& __head)\n \t: _Base(std::forward<_UHead>(__head)) { }\n \n       constexpr _Tuple_impl(const _Tuple_impl&) = default;\n \n       constexpr\n-      _Tuple_impl(typename conditional<\n-\t\t  is_move_constructible<_Head>::value,\n-\t\t  _Tuple_impl&&, __nonesuch&&>::type __in)\n+      _Tuple_impl(_Tuple_impl&& __in)\n       noexcept(is_nothrow_move_constructible<_Head>::value)\n       : _Base(std::forward<_Head>(_M_head(__in))) { }\n \n-      template<typename _UHead,\n-\t       typename enable_if<!is_same<_Head, _UHead>::value,\n-\t\t\t\t  bool>::type = true>\n+      template<typename _UHead>\n         constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)\n \t: _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }\n \n-      template<typename _UHead,\n-\t       typename enable_if<!is_same<_Head, _UHead>::value,\n-\t\t\t\t  bool>::type = true>\n+      template<typename _UHead>\n         constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)\n \t: _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))\n \t{ }\n@@ -866,18 +832,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t{ }\n \n       tuple&\n-      operator=(typename\n-\t\tconditional<__and_<is_copy_assignable<_Elements>...>::value,\n-\t\tconst tuple&, const __nonesuch&>::type __in)\n+      operator=(const tuple& __in)\n       {\n \tstatic_cast<_Inherited&>(*this) = __in;\n \treturn *this;\n       }\n \n       tuple&\n-      operator=(typename\n-\t\tconditional<__and_<is_move_assignable<_Elements>...>::value,\n-\t\ttuple&&, __nonesuch&&>::type __in)\n+      operator=(tuple&& __in)\n       noexcept(is_nothrow_move_assignable<_Inherited>::value)\n       {\n \tstatic_cast<_Inherited&>(*this) = std::move(__in);\n@@ -886,10 +848,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       template<typename... _UElements, typename = typename\n \t       enable_if<sizeof...(_UElements)\n-\t\t\t == sizeof...(_Elements)\n-\t       &&\n-\t       __and_<is_assignable<_Elements&,\n-\t\t\t\t    const _UElements&>...>::value>::type>\n+\t\t\t == sizeof...(_Elements)>::type>\n         tuple&\n         operator=(const tuple<_UElements...>& __in)\n         {\n@@ -899,10 +858,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       template<typename... _UElements, typename = typename\n \t       enable_if<sizeof...(_UElements)\n-\t\t\t == sizeof...(_Elements)\n-\t       &&\n-\t       __and_<is_assignable<_Elements&,\n-\t\t\t\t    _UElements&&>...>::value>::type>\n+\t\t\t == sizeof...(_Elements)>::type>\n         tuple&\n         operator=(tuple<_UElements...>&& __in)\n         {\n@@ -1233,53 +1189,38 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t     std::forward<_U2>(__in.second)) { }\n \n       tuple&\n-      operator=(typename\n-\t\tconditional<__and_<is_copy_assignable<_T1>,\n-\t\t                   is_copy_assignable<_T2>>::value,\n-\t\tconst tuple&, const __nonesuch&>::type __in)\n+      operator=(const tuple& __in)\n       {\n \tstatic_cast<_Inherited&>(*this) = __in;\n \treturn *this;\n       }\n \n       tuple&\n-      operator=(typename\n-\t\tconditional<__and_<is_move_assignable<_T1>,\n-\t\t                   is_move_assignable<_T2>>::value,\n-\t\ttuple&&, __nonesuch&&>::type __in)\n+      operator=(tuple&& __in)\n       noexcept(is_nothrow_move_assignable<_Inherited>::value)\n       {\n \tstatic_cast<_Inherited&>(*this) = std::move(__in);\n \treturn *this;\n       }\n \n       template<typename _U1, typename _U2>\n-        typename\n-          enable_if<__and_<is_assignable<_T1&, const _U1&>,\n-\t\t\t   is_assignable<_T2&, const _U2&>>::value,\n-\t\t\t   tuple&>::type\n+        tuple&\n         operator=(const tuple<_U1, _U2>& __in)\n         {\n \t  static_cast<_Inherited&>(*this) = __in;\n \t  return *this;\n \t}\n \n       template<typename _U1, typename _U2>\n-        typename\n-          enable_if<__and_<is_assignable<_T1&, _U1&&>,\n-\t\t\t   is_assignable<_T2&, _U2&&>>::value,\n-\t\t\t   tuple&>::type\n+        tuple&\n         operator=(tuple<_U1, _U2>&& __in)\n         {\n \t  static_cast<_Inherited&>(*this) = std::move(__in);\n \t  return *this;\n \t}\n \n       template<typename _U1, typename _U2>\n-        typename\n-          enable_if<__and_<is_assignable<_T1&, const _U1&>,\n-\t\t\t   is_assignable<_T2&, const _U2&>>::value,\n-\t\t\t   tuple&>::type\n+        tuple&\n         operator=(const pair<_U1, _U2>& __in)\n         {\n \t  this->_M_head(*this) = __in.first;\n@@ -1288,10 +1229,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n \n       template<typename _U1, typename _U2>\n-        typename\n-          enable_if<__and_<is_assignable<_T1&, _U1&&>,\n-\t\t\t   is_assignable<_T2&, _U2&&>>::value,\n-\t\t\t   tuple&>::type\n+        tuple&\n         operator=(pair<_U1, _U2>&& __in)\n         {\n \t  this->_M_head(*this) = std::forward<_U1>(__in.first);"}, {"sha": "8a520106746f5dd48cd9f53e0ee3d0641479ee98", "filename": "libstdc++-v3/testsuite/20_util/tuple/77802.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe2ddae4b15a17184237097a5c9363eb94fe99a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2F77802.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe2ddae4b15a17184237097a5c9363eb94fe99a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2F77802.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2F77802.cc?ref=3fe2ddae4b15a17184237097a5c9363eb94fe99a", "patch": "@@ -0,0 +1,49 @@\n+// { dg-do compile { target c++11 } }\n+\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <tuple>\n+\n+// This testcase instantiates a tuple with an incomplete type.\n+// That is undefined behavior, but our tuple implementation manages\n+// to cope with this particular case. The attempt to provide\n+// a tuple implementation that yields the right result for\n+// traits like is_copy_constructible and is_move_constructible as\n+// per LWG 2729 results in ill-formed copy/move constructors being\n+// generated for a tuple that contains an incomplete type.\n+// Once we get concepts, we can solve that problem much easier.\n+\n+template <typename... Args> struct execution_context\n+{\n+  typedef std::tuple<Args...> args_tpl_t;\n+  typedef std::tuple<execution_context, typename std::decay<Args>::type...>\n+  ret_tpl_t;\n+  execution_context();\n+  execution_context(execution_context &&);\n+  ret_tpl_t operator()() {\n+    args_tpl_t data;\n+    return tuple_cat(std::forward_as_tuple(execution_context()), data);\n+  }\n+};\n+\n+void fn1()\n+{\n+  execution_context<int> cc;\n+  cc();\n+}\n+"}, {"sha": "5bcf5761c360ed01bdfa4f2ae68f02178142cc4b", "filename": "libstdc++-v3/testsuite/20_util/tuple/element_access/get_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fe2ddae4b15a17184237097a5c9363eb94fe99a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Felement_access%2Fget_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fe2ddae4b15a17184237097a5c9363eb94fe99a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Felement_access%2Fget_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Felement_access%2Fget_neg.cc?ref=3fe2ddae4b15a17184237097a5c9363eb94fe99a", "patch": "@@ -17,7 +17,7 @@\n \n // { dg-options \"-fno-show-column\" }\n // { dg-do compile { target c++14 } }\n-// { dg-error \"in range\" \"\" { target *-*-* } 1342 }\n+// { dg-error \"in range\" \"\" { target *-*-* } 1280 }\n \n #include <tuple>\n "}, {"sha": "b72f535a6fc1977239ba4cd0d3886213bd21797f", "filename": "libstdc++-v3/testsuite/20_util/tuple/tuple_traits.cc", "status": "removed", "additions": 0, "deletions": 244, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b44a42cfab6a2c7e25b1665a89e2bb423e47e677/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Ftuple_traits.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b44a42cfab6a2c7e25b1665a89e2bb423e47e677/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Ftuple_traits.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Ftuple_traits.cc?ref=b44a42cfab6a2c7e25b1665a89e2bb423e47e677", "patch": "@@ -1,244 +0,0 @@\n-// { dg-do compile { target c++11 } }\n-\n-// Copyright (C) 2016 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-#include <tuple>\n-#include <type_traits>\n-#include <utility>\n-#include <vector>\n-#include <memory>\n-\n-using namespace std;\n-\n-struct Poison\n-{\n-\tPoison(Poison&&) = delete;\n-};\n-\n-\n-int main()\n-{\n-\tstatic_assert(!is_copy_constructible<Poison>::value, \"\");\n-\tstatic_assert(!is_move_constructible<Poison>::value, \"\");\n-\tstatic_assert(!is_copy_assignable<Poison>::value, \"\");\n-\tstatic_assert(!is_move_assignable<Poison>::value, \"\");\n-\n-\tstatic_assert(!is_copy_constructible<std::tuple<Poison>>::value, \"\");\n-\tstatic_assert(!is_move_constructible<std::tuple<Poison>>::value, \"\");\n-\tstatic_assert(!is_copy_assignable<std::tuple<Poison>>::value, \"\");\n-\tstatic_assert(!is_move_assignable<std::tuple<Poison>>::value, \"\");\n-\n-\tstatic_assert(!is_copy_constructible<std::tuple<int, Poison>>::value,\n-\t\t      \"\");\n-\tstatic_assert(!is_move_constructible<std::tuple<int, Poison>>::value,\n-\t\t      \"\");\n-\tstatic_assert(!is_copy_assignable<std::tuple<int, Poison>>::value, \"\");\n-\tstatic_assert(!is_move_assignable<std::tuple<int, Poison>>::value, \"\");\n-\tstatic_assert(!is_constructible<std::tuple<int, Poison>&,\n-\t\t      std::tuple<char, Poison>&>::value, \"\");\n-\tstatic_assert(!is_assignable<std::tuple<int, Poison>&,\n-\t\t      std::tuple<char, Poison>&>::value, \"\");\n-\tstatic_assert(!is_constructible<std::tuple<int, Poison>&,\n-\t\t      std::tuple<char, Poison>>::value, \"\");\n-\tstatic_assert(!is_assignable<std::tuple<int, Poison>&,\n-\t\t      std::tuple<char, Poison>>::value, \"\");\n-\tstatic_assert(!is_constructible<std::tuple<int, Poison>&,\n-\t\t      std::pair<char, Poison>&>::value, \"\");\n-\tstatic_assert(!is_assignable<std::tuple<int, Poison>&,\n-\t\t      std::pair<char, Poison>&>::value, \"\");\n-\tstatic_assert(!is_constructible<std::tuple<int, Poison>&,\n-\t\t      std::pair<char, Poison>>::value, \"\");\n-\tstatic_assert(!is_assignable<std::tuple<int, Poison>&,\n-\t\t      std::pair<char, Poison>>::value, \"\");\n-\n-\tstatic_assert(!is_copy_constructible<\n-\t\t      std::tuple<int, int, Poison>>::value, \"\");\n-\tstatic_assert(!is_move_constructible<\n-\t\t      std::tuple<int, int, Poison>>::value, \"\");\n-\tstatic_assert(!is_copy_assignable<\n-\t\t      std::tuple<int, int, Poison>>::value, \"\");\n-\tstatic_assert(!is_move_assignable<\n-\t\t      std::tuple<int, int, Poison>>::value, \"\");\n-\tstatic_assert(!is_constructible<\n-\t\t      std::tuple<int, int,Poison>&,\n-\t\t      std::tuple<int, char, Poison>&>::value, \"\");\n-\tstatic_assert(!is_assignable<\n-\t\t      std::tuple<int, int, Poison>&,\n-\t\t      std::tuple<int, char, Poison>&>::value, \"\");\n-\tstatic_assert(!is_constructible<\n-\t\t      std::tuple<int, int, Poison>&,\n-\t\t      std::tuple<int, char, Poison>>::value, \"\");\n-\tstatic_assert(!is_assignable<\n-\t\t      std::tuple<int, int, Poison>&,\n-\t\t      std::tuple<int, char, Poison>>::value, \"\");\n-\tstatic_assert(!is_constructible<\n-\t\t      std::tuple<int, int, Poison>&,\n-\t\t      std::pair<char, Poison>&>::value, \"\");\n-\tstatic_assert(!is_assignable<\n-\t\t      std::tuple<int, int, Poison>&,\n-\t\t      std::pair<char, Poison>&>::value, \"\");\n-\tstatic_assert(!is_constructible<\n-\t\t      std::tuple<int, int, Poison>&,\n-\t\t      std::pair<char, Poison>>::value, \"\");\n-\tstatic_assert(!is_assignable<\n-\t\t      std::tuple<int, int, Poison>&,\n-\t\t      std::pair<char, Poison>>::value, \"\");\n-\n-\tstatic_assert(is_trivially_copy_constructible<tuple<int>>::value, \"\");\n-\tstatic_assert(!is_trivially_move_constructible<tuple<int>>::value, \"\");\n-\n-\tstatic_assert(!is_trivially_copy_assignable<tuple<int>>::value, \"\");\n-\tstatic_assert(!is_trivially_move_assignable<tuple<int>>::value, \"\");\n-\n-\tstatic_assert(is_copy_constructible<tuple<int>>::value, \"\");\n-\tstatic_assert(is_move_constructible<tuple<int>>::value, \"\");\n-\n-\tstatic_assert(is_copy_assignable<tuple<int>>::value, \"\");\n-\tstatic_assert(is_move_assignable<tuple<int>>::value, \"\");\n-\n-\tstatic_assert(!is_trivially_copy_constructible<\n-\t\t      tuple<vector<int>>>::value, \"\");\n-\tstatic_assert(!is_trivially_move_constructible<\n-\t\t      tuple<vector<int>>>::value, \"\");\n-\n-\tstatic_assert(!is_trivially_copy_assignable<\n-\t\t      tuple<vector<int>>>::value, \"\");\n-\tstatic_assert(!is_trivially_move_assignable<\n-\t\t      tuple<vector<int>>>::value, \"\");\n-\n-\tstatic_assert(is_copy_constructible<tuple<vector<int>>>::value, \"\");\n-\tstatic_assert(is_move_constructible<tuple<vector<int>>>::value, \"\");\n-\n-\tstatic_assert(is_copy_assignable<tuple<vector<int>>>::value, \"\");\n-\tstatic_assert(is_move_assignable<tuple<vector<int>>>::value, \"\");\n-\n-\tstatic_assert(!is_trivially_copy_constructible<\n-\t\t      tuple<unique_ptr<int>>>::value, \"\");\n-\tstatic_assert(!is_trivially_move_constructible<\n-\t\t      tuple<unique_ptr<int>>>::value, \"\");\n-\n-\tstatic_assert(!is_trivially_copy_assignable<\n-\t\t      tuple<unique_ptr<int>>>::value, \"\");\n-\tstatic_assert(!is_trivially_move_assignable<\n-\t\t      tuple<unique_ptr<int>>>::value, \"\");\n-\tstatic_assert(!is_copy_constructible<\n-\t\t      tuple<unique_ptr<int>>>::value, \"\");\n-\tstatic_assert(is_move_constructible<tuple<unique_ptr<int>>>::value, \"\");\n-\n-\tstatic_assert(!is_copy_assignable<tuple<unique_ptr<int>>>::value, \"\");\n-\tstatic_assert(is_move_assignable<tuple<unique_ptr<int>>>::value, \"\");\n-\n-\tstatic_assert(is_trivially_copy_constructible<\n-\t\t      tuple<int, int>>::value, \"\");\n-\tstatic_assert(!is_trivially_move_constructible<\n-\t\t      tuple<int, int>>::value, \"\");\n-\n-\tstatic_assert(!is_trivially_copy_assignable<\n-\t\t      tuple<int, int>>::value, \"\");\n-\tstatic_assert(!is_trivially_move_assignable<\n-\t\t      tuple<int, int>>::value, \"\");\n-\n-\tstatic_assert(is_copy_constructible<tuple<int, int>>::value, \"\");\n-\tstatic_assert(is_move_constructible<tuple<int, int>>::value, \"\");\n-\n-\tstatic_assert(is_copy_assignable<tuple<int, int>>::value, \"\");\n-\tstatic_assert(is_move_assignable<tuple<int, int>>::value, \"\");\n-\tstatic_assert(!is_trivially_copy_constructible<\n-\t\t      tuple<int, vector<int>>>::value, \"\");\n-\tstatic_assert(!is_trivially_move_constructible<\n-\t\t      tuple<int, vector<int>>>::value, \"\");\n-\n-\tstatic_assert(!is_trivially_copy_assignable<\n-\t\t      tuple<int, vector<int>>>::value, \"\");\n-\tstatic_assert(!is_trivially_move_assignable<\n-\t\t      tuple<int, vector<int>>>::value, \"\");\n-\n-\tstatic_assert(is_copy_constructible<\n-\t\t      tuple<int, vector<int>>>::value, \"\");\n-\tstatic_assert(is_move_constructible<\n-\t\t      tuple<int, vector<int>>>::value, \"\");\n-\n-\tstatic_assert(is_copy_assignable<tuple<int, vector<int>>>::value, \"\");\n-\tstatic_assert(is_move_assignable<tuple<int, vector<int>>>::value, \"\");\n-\n-\tstatic_assert(!is_trivially_copy_constructible<\n-\t\t      tuple<int, unique_ptr<int>>>::value, \"\");\n-\tstatic_assert(!is_trivially_move_constructible<\n-\t\t      tuple<int, unique_ptr<int>>>::value, \"\");\n-\n-\tstatic_assert(!is_trivially_copy_assignable<\n-\t\t      tuple<int, unique_ptr<int>>>::value, \"\");\n-\tstatic_assert(!is_trivially_move_assignable<\n-\t\t      tuple<int, unique_ptr<int>>>::value, \"\");\n-\n-\tstatic_assert(!is_copy_constructible<\n-\t\t      tuple<int, unique_ptr<int>>>::value, \"\");\n-\tstatic_assert(is_move_constructible<\n-\t\t      tuple<int, unique_ptr<int>>>::value, \"\");\n-\n-\tstatic_assert(!is_copy_assignable<\n-\t\t      tuple<int, unique_ptr<int>>>::value, \"\");\n-\tstatic_assert(is_move_assignable<\n-\t\t      tuple<int, unique_ptr<int>>>::value, \"\");\n-\n-\tstatic_assert(is_copy_constructible<tuple<int, int, int>>::value, \"\");\n-\tstatic_assert(is_move_constructible<tuple<int, int, int>>::value, \"\");\n-\n-\tstatic_assert(is_copy_assignable<tuple<int, int, int>>::value, \"\");\n-\tstatic_assert(is_move_assignable<tuple<int, int, int>>::value, \"\");\n-\n-\tstatic_assert(!is_trivially_copy_constructible<\n-\t\t      tuple<int, int, vector<int>>>::value, \"\");\n-\tstatic_assert(!is_trivially_move_constructible<\n-\t\t      tuple<int, int, vector<int>>>::value, \"\");\n-\n-\tstatic_assert(!is_trivially_copy_assignable<\n-\t\t      tuple<int, int, vector<int>>>::value, \"\");\n-\tstatic_assert(!is_trivially_move_assignable<\n-\t\t      tuple<int, int, vector<int>>>::value, \"\");\n-\n-\tstatic_assert(is_copy_constructible<\n-\t\t      tuple<int, int, vector<int>>>::value, \"\");\n-\tstatic_assert(is_move_constructible<\n-\t\t      tuple<int, int, vector<int>>>::value, \"\");\n-\n-\tstatic_assert(is_copy_assignable<\n-\t\t      tuple<int, int, vector<int>>>::value, \"\");\n-\tstatic_assert(is_move_assignable<\n-\t\t      tuple<int, int, vector<int>>>::value, \"\");\n-\n-\tstatic_assert(!is_trivially_copy_constructible<\n-\t\t      tuple<int, int, unique_ptr<int>>>::value, \"\");\n-\tstatic_assert(!is_trivially_move_constructible<\n-\t\t      tuple<int, int, unique_ptr<int>>>::value, \"\");\n-\n-\tstatic_assert(!is_trivially_copy_assignable<\n-\t\t      tuple<int, int, unique_ptr<int>>>::value, \"\");\n-\tstatic_assert(!is_trivially_move_assignable<\n-\t\t      tuple<int, int, unique_ptr<int>>>::value, \"\");\n-\n-\tstatic_assert(!is_copy_constructible<\n-\t\t      tuple<int, int, unique_ptr<int>>>::value, \"\");\n-\tstatic_assert(is_move_constructible<\n-\t\t      tuple<int, int, unique_ptr<int>>>::value, \"\");\n-\n-\tstatic_assert(!is_copy_assignable<\n-\t\t      tuple<int, int, unique_ptr<int>>>::value, \"\");\n-\tstatic_assert(is_move_assignable<\n-\t\t      tuple<int, int, unique_ptr<int>>>::value, \"\");\n-}"}]}