{"sha": "9e19701e69491cec96e0212856280f65a0d5eea8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWUxOTcwMWU2OTQ5MWNlYzk2ZTAyMTI4NTYyODBmNjVhMGQ1ZWVhOA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1995-11-30T18:24:37Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1995-11-30T18:24:37Z"}, "message": "PowerPC Windows NT support\n\nFrom-SVN: r10643", "tree": {"sha": "366fea9f2ce59c8af0077ca1b867bc8228f5cb4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/366fea9f2ce59c8af0077ca1b867bc8228f5cb4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e19701e69491cec96e0212856280f65a0d5eea8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e19701e69491cec96e0212856280f65a0d5eea8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e19701e69491cec96e0212856280f65a0d5eea8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e19701e69491cec96e0212856280f65a0d5eea8/comments", "author": null, "committer": null, "parents": [{"sha": "e09150c7c0602ed7aa36db50a1535160af96a35a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e09150c7c0602ed7aa36db50a1535160af96a35a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e09150c7c0602ed7aa36db50a1535160af96a35a"}], "stats": {"total": 401, "additions": 401, "deletions": 0}, "files": [{"sha": "46593464ca1b6b967698f4b0c2c04b77f4d6b550", "filename": "gcc/config/rs6000/t-winnt", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e19701e69491cec96e0212856280f65a0d5eea8/gcc%2Fconfig%2Frs6000%2Ft-winnt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e19701e69491cec96e0212856280f65a0d5eea8/gcc%2Fconfig%2Frs6000%2Ft-winnt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-winnt?ref=9e19701e69491cec96e0212856280f65a0d5eea8", "patch": "@@ -0,0 +1,27 @@\n+# Do not build libgcc1.\n+LIBGCC1 =\n+CROSS_LIBGCC1 =\n+\n+EXTRA_HEADERS = $(srcdir)/ginclude/ppc-asm.h\n+\n+# At present, we don't have a cross linker, so turn this off\n+LIBGCC1_TEST = \n+\n+# These are really part of libgcc1, but this will cause them to be\n+# built correctly, so... [taken from t-sparclite]\n+LIB2FUNCS_EXTRA = fp-bit.c dp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c > dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+# Build the libraries for both hard and soft floating point\n+\n+MULTILIB_OPTIONS = msoft-float\n+MULTILIB_DIRNAMES = soft-float\n+\n+LIBGCC = stmp-multilib\n+INSTALL_LIBGCC = install-multilib"}, {"sha": "9df2a5b2336fd2fe01fd60a920db93904bb4b68d", "filename": "gcc/config/rs6000/win-nt.h", "status": "added", "additions": 374, "deletions": 0, "changes": 374, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e19701e69491cec96e0212856280f65a0d5eea8/gcc%2Fconfig%2Frs6000%2Fwin-nt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e19701e69491cec96e0212856280f65a0d5eea8/gcc%2Fconfig%2Frs6000%2Fwin-nt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fwin-nt.h?ref=9e19701e69491cec96e0212856280f65a0d5eea8", "patch": "@@ -0,0 +1,374 @@\n+/* Definitions of target machine for GNU compiler, for PowerPC\n+   running Windows/NT.\n+   Copyright (C) 1995 Free Software Foundation, Inc.\n+   Contributed by Cygnus Support.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Say this is Windows/NT for the other config files.  */\n+#define WINDOWS_NT 1\n+#define COFF_WITH_PE 1\n+\n+/* Default ABI to compile code for */\n+#define DEFAULT_ABI ABI_NT\n+\n+#include \"rs6000/powerpc.h\"\n+\n+/* Pseudo target that we can test in the md file.  */\n+#undef \tTARGET_WINDOWS_NT\n+#define\tTARGET_WINDOWS_NT 1\n+\n+#undef\tCPP_PREDEFINES\n+#define\tCPP_PREDEFINES \"-DWIN32 -D_WIN32 \\\n+  -DWINNT -D__STDC__=0 -DALMOST_STDC \\\n+  -D_POWER -DPPC -Asystem(winnt) -Acpu(powerpc) -Amachine(powerpc)\"\n+\n+#if 0\n+#include \"winnt/win-nt.h\"\n+#endif\n+\n+#undef\tLIB_SPEC\n+#define\tLIB_SPEC \"%{mwindows:-subsystem:windows -entry:WinMainCRTStartup \\\n+  USER32.LIB GDI32.LIB COMDLG32.LIB WINSPOOL.LIB} \\\n+ %{!mwindows:-subsystem:console -entry:mainCRTStartup} \\\n+ %{mcrtmt:LIBCMT.LIB KERNEL32.LIB} %{!mcrtmt:LIBC.LIB KERNEL32.LIB} \\\n+ %{v}\"\n+\n+#undef\tLINK_SPEC\n+#define\tLINK_SPEC \"%{V} %{v:%{!V:-V}}\"\n+\n+/* Allow switches specified in LIB_SPEC, but don't do anything with them\n+   in the compiler.  */\n+#undef\tSUBTARGET_SWITCHES\n+#define SUBTARGET_SWITCHES\t\\\n+   { \"windows\",\t0 },\t\t\\\n+   { \"crtmt\",\t0 },\n+\n+#undef XCOFF_DEBUGGING_INFO\n+\n+/* this is pure coff, not xcoff */\n+#define SDB_DEBUGGING_INFO\n+#define DBX_DEBUGGING_INFO\n+\n+#undef  SDB_DELIM\n+#define SDB_DELIM \";\"\n+\n+#undef\tPREFERRED_DEBUGGING_TYPE\n+#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n+\n+#undef PROCESSOR_DEFAULT\n+#define PROCESSOR_DEFAULT PROCESSOR_POWERPC\n+\n+/* NT always runs little endian */\n+#undef  BYTES_BIG_ENDIAN\n+#define BYTES_BIG_ENDIAN 0 \n+\n+#undef  WORDS_BIG_ENDIAN\n+#define WORDS_BIG_ENDIAN 0 \n+\n+/* Define cutoff for using external functions to save floating point.\n+   Currently on NT, always use inline stores */\n+#undef\tFP_SAVE_INLINE\n+#define FP_SAVE_INLINE(FIRST_REG) ((FIRST_REG) < 64)\n+\n+/* Note, little endian systems trap on unaligned addresses, so never\n+   turn off strict alignment in that case. */\n+\n+#undef STRICT_ALIGNMENT\n+#define\tSTRICT_ALIGNMENT 1\n+\n+/* Align stack to 16 byte boundaries */\n+#undef\tSTACK_BOUNDARY\n+#define\tSTACK_BOUNDARY\t128\n+\n+/* No data type wants to be aligned rounder than this.  */\n+#undef\tBIGGEST_ALIGNMENT\n+#define BIGGEST_ALIGNMENT 128\n+\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (PowerPC PE)\");\n+\n+#undef TARGET_DEFAULT \n+#define TARGET_DEFAULT (MASK_POWERPC | MASK_NEW_MNEMONICS | MASK_NO_FP_IN_TOC | MASK_NO_SUM_IN_TOC)\n+\n+#undef PROCESSOR_DEFAULT\n+#define PROCESSOR_DEFAULT PROCESSOR_PPC601\n+\n+/* Address to save the TOC register */\n+#undef\tRS6000_SAVE_TOC\n+#define RS6000_SAVE_TOC plus_constant (virtual_incoming_args_rtx, -RS6000_SAVE_AREA - 8)\n+\n+/* Windows NT specifies that r13 is reserved to the OS, so it is not available\n+   to the normal user.  */\n+\n+#undef\tFIXED_R13\n+#define FIXED_R13 1\n+\n+\f\n+/* Output .file and comments listing what options there are */\n+#undef\tASM_FILE_START\n+#define ASM_FILE_START(FILE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  ASM_OUTPUT_OPTIONS (FILE);\t\t\t\t\t\\\n+  output_file_directive (FILE, main_input_filename);\t\t\\\n+}\n+\n+/* Define the extra sections we need.  We define three: one is the read-only\n+   data section which is used for constants.  This is a csect whose name is\n+   derived from the name of the input file.  The second is for initialized\n+   global variables.  This is a csect whose name is that of the variable.\n+   The third is the TOC.  */\n+\n+#undef SELECT_SECTION\n+\n+#undef\tREADONLY_DATA_SECTION\n+#undef\tEXTRA_SECTIONS\n+#define EXTRA_SECTIONS toc, bss\n+\n+/* Define the routines to implement these extra sections.  */\n+\n+#undef\tEXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\\\n+toc_section ()\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+}\n+\n+\n+#undef SELECT_RTX_SECTION\n+#undef ASM_DECLARE_FUNCTION_NAME\n+\n+\f\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+\n+#undef\tASM_OUTPUT_ALIGNED_COMMON\n+#define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGNMENT)\t\\\n+  do { fputs (\"\\t.comm \\t\", (FILE));\t\t\t        \\\n+       assemble_name ((FILE), (NAME));\t\t\t\t\\\n+       if ( (SIZE) > 4)                                         \\\n+         fprintf ((FILE), \",%d,%d\\n\", (SIZE), 3);               \\\n+       else                                                     \\\n+\t fprintf( (FILE), \",%d\\n\", (SIZE));                     \\\n+  } while (0) \n+\n+#undef\tASM_OUTPUT_ALIGNED_LOCAL\n+\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+\n+#undef  ASM_OUTPUT_COMMON\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)\t\\\n+  do { fputs (\"\\t.comm \\t\", (FILE));\t\t\t\\\n+       assemble_name ((FILE), (NAME));\t\t\t\\\n+       fprintf ((FILE), \",%d\\n\", (SIZE)); } while (0)\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+#undef ASM_OUTPUT_LOCAL\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE,ROUNDED)\t\\\n+  do { fputs (\"\\t.lcomm \\t\", (FILE));\t\t\t\\\n+       assemble_name ((FILE), (NAME));\t\t\t\\\n+       fprintf ((FILE), \",%d\\n\", (SIZE));               \\\n+     } while (0)\n+\n+\n+/* Stuff to force fit us into the Motorola PPC assembler */\n+\n+#if 0\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  output_file_directive (FILE, main_input_filename);\t\t\\\n+  fprintf (FILE, \"\\n#\\tDirective section\\n\");                   \\\n+  fprintf (FILE, \"\\t.section\\t.drectve,\\\"iR\\\"\\n\");              \\\n+  fprintf (FILE, \"\\t.byte\\t\\\"-defaultlib:LIBC\\\" \\n\");           \\\n+  fprintf (FILE, \"\\t.previous\\n\\n\");                              \\\n+}\n+#endif\n+\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  ASM_OUTPUT_OPTIONS (FILE);\t\t\t\t\t\\\n+  output_file_directive (FILE, main_input_filename);\t\t\\\n+  data_section ();\t\t\t\t\t\t\\\n+}\n+\n+#undef ASM_FILE_END\n+\n+#undef  ASM_OUTPUT_FUNCTION_PREFIX\n+#define ASM_OUTPUT_FUNCTION_PREFIX(FILE,NAME)                   \\\n+{                                                               \\\n+  fprintf (FILE, \"\\n#\\tFunction: '..\");                         \\\n+  assemble_name (FILE, NAME);\t\t\t\t\t\\\n+  fprintf (FILE, \"'\\n\");                                        \\\n+  fprintf (FILE, \"#\\tText in section: <%s>\\n\\n\",\"default\");     \\\n+  fprintf (FILE, \"#\\tSetup MS Structured-Exception-Handling\\n\"); \\\n+  fprintf (FILE, \"\\t.pdata\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.align 2\\n\");\t\t\t\t\\\n+  fprintf (FILE, \"\\t.ualong ..\");                               \\\n+  assemble_name (FILE, NAME);\t\t\t\t\t\\\n+  fprintf (FILE, \",\");                                          \\\n+  assemble_name (FILE, NAME);\t\t\t\t\t\\\n+  fprintf (FILE, \".e,0,0,\");                                    \\\n+  assemble_name (FILE, NAME);\t\t\t\t\t\\\n+  fprintf (FILE, \".b\\n\\n\");                                     \\\n+  fprintf (FILE, \"#\\tSwitch to the relocation section\\n\");      \\\n+  fprintf (FILE, \"\\t.reldata\\n\");                               \\\n+}\n+\n+\n+#define ASM_DECLARE_FUNCTION_NAME(FILE,NAME,DECL)\t\t\\\n+{                                                               \\\n+  if (TREE_PUBLIC (DECL))\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.globl ..\");\t\t\t\t\\\n+      assemble_name (FILE, NAME);\t\t\t\t\\\n+      fprintf (FILE, \"\\n\");\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  assemble_name (FILE, NAME);\t\t\t\t\t\\\n+  fprintf (FILE, \":\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.ualong ..\");\t\t\t\t\\\n+  assemble_name (FILE, NAME);\t\t\t\t\t\\\n+  fprintf (FILE, \",.toc\\n\");\t\t\t\t        \\\n+  fprintf (FILE, \"\\t.section .text\\n\\t.align 2\\n..\");\t\t\\\n+  assemble_name (FILE, NAME);\t\t\t\t\t\\\n+  fprintf (FILE, \":\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.function\\t..\");                            \\\n+  assemble_name (FILE, NAME);\t\t\t\t\t\\\n+  fprintf (FILE, \"\\n\");\t\t\t\t\t        \\\n+}\n+\n+/* This is how to output an assembler line defining a `double' constant.  */\n+\n+#undef\tASM_OUTPUT_DOUBLE\n+#define ASM_OUTPUT_DOUBLE(FILE, VALUE)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (REAL_VALUE_ISINF (VALUE)\t\t\t\t\t\\\n+        || REAL_VALUE_ISNAN (VALUE)\t\t\t\t\t\\\n+\t|| REAL_VALUE_MINUS_ZERO (VALUE))\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tlong t[2];\t\t\t\t\t\t\t\\\n+\tREAL_VALUE_TO_TARGET_DOUBLE ((VALUE), t);\t\t\t\\\n+\tfprintf (FILE, \"\\t.ualong 0x%lx\\n\\t.long 0x%lx\\n\",\t\t\\\n+\t\tt[0] & 0xffffffff, t[1] & 0xffffffff);\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tchar str[30];\t\t\t\t\t\t\t\\\n+\tREAL_VALUE_TO_DECIMAL (VALUE, \"%.20e\", str);\t\t\t\\\n+\tfprintf (FILE, \"\\t.double %s\\n\", str);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n+#undef\tASM_OUTPUT_FLOAT\n+#define ASM_OUTPUT_FLOAT(FILE, VALUE)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (REAL_VALUE_ISINF (VALUE)\t\t\t\t\t\\\n+        || REAL_VALUE_ISNAN (VALUE)\t\t\t\t\t\\\n+\t|| REAL_VALUE_MINUS_ZERO (VALUE))\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tlong t;\t\t\t\t\t\t\t\t\\\n+\tREAL_VALUE_TO_TARGET_SINGLE ((VALUE), t);\t\t\t\\\n+\tfprintf (FILE, \"\\t.ualong 0x%lx\\n\", t & 0xffffffff);\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tchar str[30];\t\t\t\t\t\t\t\\\n+\tREAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", str);\t\t\t\\\n+\tfprintf (FILE, \"\\t.float %s\\n\", str);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\n+/* Output before instructions.  */\n+#undef TEXT_SECTION_ASM_OP\n+#define TEXT_SECTION_ASM_OP \"\\t.text\"\n+\n+/* Output before writable data.  */\n+#undef DATA_SECTION_ASM_OP\n+#define DATA_SECTION_ASM_OP \"\\t.data\"\n+\n+/* Text to write out after a CALL that may be replaced by glue code by\n+   the loader.  The motorola asm demands that, for dll support, a .znop\n+   be issued after a bl instruction, and the symbol on the .znop is the\n+   symbol on the bl instruction */\n+\n+#undef RS6000_CALL_GLUE\n+#define RS6000_CALL_GLUE \"nop #\\tFIXME: only works for non-dll calls.\"\n+\n+#define RS6000_CALL_GLUE2 \".znop \"\n+\n+#undef ASM_OUTPUT_SPECIAL_POOL_ENTRY\n+\n+/* Output something to declare an external symbol to the assembler.  Most\n+   assemblers don't need this.  */\n+\n+#undef ASM_OUTPUT_EXTERNAL\n+\n+#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\t\\\n+{ rtx _symref = XEXP (DECL_RTL (DECL), 0);\t\\\n+  if ((TREE_CODE (DECL) == VAR_DECL\t\t\\\n+       || TREE_CODE (DECL) == FUNCTION_DECL)\t\\\n+      && (NAME)[0] != '*'\t\t\t\\\n+      && (NAME)[strlen (NAME) - 1] != ']')\t\\\n+    {\t\t\t\t\t\t\\\n+      char *_name = (char *) permalloc (strlen (XSTR (_symref, 0)) + 5); \\\n+      strcpy (_name, XSTR (_symref, 0));\t\\\n+      XSTR (_symref, 0) = _name;\t\t\\\n+    }\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.extern \");\t\t\t\\\n+  assemble_name (FILE, XSTR (_symref, 0));\t\\\n+  if (TREE_CODE (DECL) == FUNCTION_DECL)\t\\\n+    {\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\n\\t.extern ..\");\t\t\\\n+      assemble_name (FILE, XSTR (_symref, 0));\t\\\n+    }\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\n\");\t\t\t\t\\\n+}\n+\n+/* Similar, but for libcall.  We only have to worry about the function name,\n+   not that of the descriptor. */\n+\n+#undef ASM_OUTPUT_EXTERNAL_LIBCALL\n+\n+#define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)\t\\\n+{ fprintf (FILE, \"\\t.extern ..\");\t\t\\\n+  assemble_name (FILE, XSTR (FUN, 0));\t\t\\\n+  fprintf (FILE, \"\\n\");\t\t\t\t\\\n+}\n+\n+\n+/* Eliminate AIX style constant pool processing */\n+#undef\tLEGITIMATE_CONSTANT_POOL_BASE_P\n+#define\tLEGITIMATE_CONSTANT_POOL_BASE_P(X) 0\n+\n+#undef\tLEGITIMATE_CONSTANT_POOL_ADDRESS_P\n+#define\tLEGITIMATE_CONSTANT_POOL_ADDRESS_P(X) 0\n+\n+#undef ASM_OUTPUT_SPECIAL_POOL_ENTRY\n+\n+#undef  ASM_IDENTIFY_GCC\n+#define ASM_IDENTIFY_GCC(x)\n+\n+#undef\tHAS_INIT_SECTION\n+#define HAS_INIT_SECTION"}]}