{"sha": "886b230d42e4a326e24f029e673ad1591159f7ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODg2YjIzMGQ0MmU0YTMyNmUyNGYwMjllNjczYWQxNTkxMTU5ZjdhZA==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-30T22:59:20Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2020-12-01T17:50:50Z"}, "message": "Add Type resolution to Array expressions\n\nThis adds type inferencing and validation for arrays such as:\n\n  let x: [i32, 5] = [1,2,3,4,5]\n  ley y = [1,2,3];\n\nIt checks that each element is of a valid type and they line up correctly.\nThere needs to be some refactoring of the type resolution to handle the\narray index expressions so this is a good save point for now.\n\nAddresses: #27 #55", "tree": {"sha": "323140e2d4794300b65c7a09eed2e63d35d36cbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/323140e2d4794300b65c7a09eed2e63d35d36cbc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/886b230d42e4a326e24f029e673ad1591159f7ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/886b230d42e4a326e24f029e673ad1591159f7ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/886b230d42e4a326e24f029e673ad1591159f7ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/886b230d42e4a326e24f029e673ad1591159f7ad/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37560f930d8068c1241fa1d5db9030b4287c3e66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37560f930d8068c1241fa1d5db9030b4287c3e66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37560f930d8068c1241fa1d5db9030b4287c3e66"}], "stats": {"total": 194, "additions": 180, "deletions": 14}, "files": [{"sha": "aa2ea18ace011dd609aad05fe104dd074ed28264", "filename": "gcc/rust/analysis/rust-type-resolution.cc", "status": "modified", "additions": 156, "deletions": 8, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/886b230d42e4a326e24f029e673ad1591159f7ad/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/886b230d42e4a326e24f029e673ad1591159f7ad/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc?ref=886b230d42e4a326e24f029e673ad1591159f7ad", "patch": "@@ -104,7 +104,13 @@ TypeResolution::typesAreCompatible (AST::Type *lhs, AST::Type *rhs,\n     }\n \n   AST::Type *val = NULL;\n-  return scope.LookupType (lhsTypeStr, &val);\n+  if (!scope.LookupType (lhsTypeStr, &val))\n+    {\n+      rust_error_at (locus, \"Unknown type: %s\", lhsTypeStr.c_str ());\n+      return false;\n+    }\n+\n+  return true;\n }\n \n bool\n@@ -395,19 +401,112 @@ TypeResolution::visit (AST::CompoundAssignmentExpr &expr)\n void\n TypeResolution::visit (AST::GroupedExpr &expr)\n {}\n-// void TypeResolution::visit(ArrayElems& elems) {}\n+\n void\n TypeResolution::visit (AST::ArrayElemsValues &elems)\n-{}\n+{\n+  // we need to generate the AST::ArrayType for this array init_expression\n+  // we can get the size via get_num_values() but we need to ensure each element\n+  // are type compatible\n+\n+  bool failed = false;\n+  AST::Type *last_inferred_type = nullptr;\n+  elems.iterate ([&] (AST::Expr *expr) mutable -> bool {\n+    size_t before;\n+    before = typeBuffer.size ();\n+    expr->accept_vis (*this);\n+    if (typeBuffer.size () <= before)\n+      {\n+\trust_error_at (expr->get_locus_slow (),\n+\t\t       \"unable to determine element type\");\n+\treturn false;\n+      }\n+\n+    AST::Type *inferedType = typeBuffer.back ();\n+    typeBuffer.pop_back ();\n+\n+    if (last_inferred_type == nullptr)\n+      last_inferred_type = inferedType;\n+    else\n+      {\n+\tif (!typesAreCompatible (last_inferred_type, inferedType,\n+\t\t\t\t expr->get_locus_slow ()))\n+\t  {\n+\t    failed = true;\n+\t    return false;\n+\t  }\n+      }\n+\n+    return true;\n+  });\n+\n+  // nothing to do when its failed\n+  if (failed)\n+    return;\n+\n+  auto capacity\n+    = new AST::LiteralExpr (std::to_string (elems.get_num_values ()),\n+\t\t\t    AST::Literal::INT,\n+\t\t\t    Linemap::predeclared_location ());\n+  auto arrayType = new AST::ArrayType (last_inferred_type->clone_type (),\n+\t\t\t\t       std::unique_ptr<AST::Expr> (capacity),\n+\t\t\t\t       Linemap::predeclared_location ());\n+  typeBuffer.push_back (arrayType);\n+}\n+\n void\n TypeResolution::visit (AST::ArrayElemsCopied &elems)\n-{}\n+{\n+  printf (\"ArrayElemsCopied: %s\\n\", elems.as_string ().c_str ());\n+}\n+\n void\n TypeResolution::visit (AST::ArrayExpr &expr)\n-{}\n+{\n+  auto elements = expr.get_internal_elements ();\n+  elements->accept_vis (*this);\n+}\n+\n void\n TypeResolution::visit (AST::ArrayIndexExpr &expr)\n-{}\n+{\n+  printf (\"ArrayIndexExpr: %s\\n\", expr.as_string ().c_str ());\n+\n+  auto before = typeBuffer.size ();\n+  expr.get_array_expr ()->accept_vis (*this);\n+  if (typeBuffer.size () <= before)\n+    {\n+      rust_error_at (expr.get_locus_slow (),\n+\t\t     \"unable to determine type for array index expression\");\n+      return;\n+    }\n+  AST::Type *array_expr_type = typeBuffer.back ();\n+  typeBuffer.pop_back ();\n+\n+  before = typeBuffer.size ();\n+  expr.get_index_expr ()->accept_vis (*this);\n+  if (typeBuffer.size () <= before)\n+    {\n+      rust_error_at (expr.get_index_expr ()->get_locus_slow (),\n+\t\t     \"unable to determine type for index expression\");\n+      return;\n+    }\n+\n+  AST::Type *array_index_type = typeBuffer.back ();\n+  typeBuffer.pop_back ();\n+\n+  printf (\"Array expr type %s array index expr type: [%s]\\n\",\n+\t  array_expr_type->as_string ().c_str (),\n+\t  array_index_type->as_string ().c_str ());\n+\n+  // the the element type from the array_expr_type and it _must_ be an array\n+  // TODO\n+\n+  // check the index_type should be an i32 which should really be\n+  // more permissive\n+  // TODO\n+}\n+\n void\n TypeResolution::visit (AST::TupleExpr &expr)\n {}\n@@ -1015,7 +1114,7 @@ TypeResolution::visit (AST::LetStmt &stmt)\n       return;\n     }\n \n-  AST::Type *inferedType = NULL;\n+  AST::Type *inferedType = nullptr;\n   if (stmt.has_init_expr ())\n     {\n       auto before = typeBuffer.size ();\n@@ -1048,6 +1147,51 @@ TypeResolution::visit (AST::LetStmt &stmt)\n \t  return;\n \t}\n     }\n+  else if (stmt.has_type ())\n+    {\n+      auto before = typeComparisonBuffer.size ();\n+      stmt.type->accept_vis (*this);\n+      if (typeComparisonBuffer.size () <= before)\n+\t{\n+\t  rust_error_at (stmt.locus, \"failed to understand type for lhs\");\n+\t  return;\n+\t}\n+      auto typeString = typeComparisonBuffer.back ();\n+      typeComparisonBuffer.pop_back ();\n+\n+      AST::Type *val = NULL;\n+      if (!scope.LookupType (typeString, &val))\n+\t{\n+\t  rust_error_at (stmt.locus, \"LetStmt has unknown type: %s\",\n+\t\t\t stmt.type->as_string ().c_str ());\n+\t  return;\n+\t}\n+    }\n+  else if (inferedType != nullptr)\n+    {\n+      auto before = typeComparisonBuffer.size ();\n+      inferedType->accept_vis (*this);\n+      if (typeComparisonBuffer.size () <= before)\n+\t{\n+\t  rust_error_at (stmt.locus, \"failed to understand type for lhs\");\n+\t  return;\n+\t}\n+      auto typeString = typeComparisonBuffer.back ();\n+      typeComparisonBuffer.pop_back ();\n+\n+      AST::Type *val = NULL;\n+      if (!scope.LookupType (typeString, &val))\n+\t{\n+\t  rust_error_at (stmt.locus, \"Inferred unknown type: %s\",\n+\t\t\t inferedType->as_string ().c_str ());\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      rust_fatal_error (stmt.locus, \"Failed to determine any type for LetStmt\");\n+      return;\n+    }\n \n   // ensure the decl has the type set for compilation later on\n   if (!stmt.has_type ())\n@@ -1115,9 +1259,13 @@ TypeResolution::visit (AST::RawPointerType &type)\n void\n TypeResolution::visit (AST::ReferenceType &type)\n {}\n+\n void\n TypeResolution::visit (AST::ArrayType &type)\n-{}\n+{\n+  typeComparisonBuffer.push_back (type.get_element_type ()->as_string ());\n+}\n+\n void\n TypeResolution::visit (AST::SliceType &type)\n {}"}, {"sha": "d3e7cbdc86ae97a87a72b4149430687bf3ee3040", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/886b230d42e4a326e24f029e673ad1591159f7ad/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/886b230d42e4a326e24f029e673ad1591159f7ad/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=886b230d42e4a326e24f029e673ad1591159f7ad", "patch": "@@ -928,6 +928,17 @@ class ArrayElemsValues : public ArrayElems\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  size_t get_num_values () const { return values.size (); }\n+\n+  void iterate (std::function<bool (Expr *)> cb)\n+  {\n+    for (auto it = values.begin (); it != values.end (); it++)\n+      {\n+\tif (!cb ((*it).get ()))\n+\t  return;\n+      }\n+  }\n+\n protected:\n   ArrayElemsValues *clone_array_elems_impl () const override\n   {\n@@ -1037,6 +1048,8 @@ class ArrayExpr : public ExprWithoutBlock\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  ArrayElems *get_internal_elements () { return internal_elements.get (); };\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1100,6 +1113,9 @@ class ArrayIndexExpr : public ExprWithoutBlock\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  Expr *get_array_expr () { return array_expr.get (); }\n+  Expr *get_index_expr () { return index_expr.get (); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "301b66472db4be419b7710e0e0124451a76e7227", "filename": "gcc/rust/ast/rust-type.h", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/886b230d42e4a326e24f029e673ad1591159f7ad/gcc%2Frust%2Fast%2Frust-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/886b230d42e4a326e24f029e673ad1591159f7ad/gcc%2Frust%2Fast%2Frust-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-type.h?ref=886b230d42e4a326e24f029e673ad1591159f7ad", "patch": "@@ -60,7 +60,7 @@ class ImplTraitType : public Type\n {\n   // TypeParamBounds type_param_bounds;\n   // inlined form\n-  std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds;\n+  std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds;\n \n   Location locus;\n \n@@ -74,7 +74,7 @@ class ImplTraitType : public Type\n \n public:\n   ImplTraitType (\n-    std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds,\n+    std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n     Location locus)\n     : type_param_bounds (std::move (type_param_bounds)), locus (locus)\n   {}\n@@ -115,7 +115,7 @@ class TraitObjectType : public Type\n {\n   bool has_dyn;\n   // TypeParamBounds type_param_bounds;\n-  std::vector<std::unique_ptr<TypeParamBound>>\n+  std::vector<std::unique_ptr<TypeParamBound> >\n     type_param_bounds; // inlined form\n \n   Location locus;\n@@ -130,7 +130,7 @@ class TraitObjectType : public Type\n \n public:\n   TraitObjectType (\n-    std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds,\n+    std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n     Location locus, bool is_dyn_dispatch = false)\n     : has_dyn (is_dyn_dispatch),\n       type_param_bounds (std::move (type_param_bounds)), locus (locus)\n@@ -318,14 +318,14 @@ class TypePath; // definition moved to \"rust-path.h\"\n  * specific order */\n class TupleType : public TypeNoBounds\n {\n-  std::vector<std::unique_ptr<Type>> elems;\n+  std::vector<std::unique_ptr<Type> > elems;\n   Location locus;\n \n public:\n   // Returns whether the tuple type is the unit type, i.e. has no elements.\n   bool is_unit_type () const { return elems.empty (); }\n \n-  TupleType (std::vector<std::unique_ptr<Type>> elems, Location locus)\n+  TupleType (std::vector<std::unique_ptr<Type> > elems, Location locus)\n     : elems (std::move (elems)), locus (locus)\n   {}\n \n@@ -574,6 +574,8 @@ class ArrayType : public TypeNoBounds\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  Type *get_element_type () { return elem_type.get (); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}]}