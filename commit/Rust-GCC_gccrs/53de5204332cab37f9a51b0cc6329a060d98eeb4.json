{"sha": "53de5204332cab37f9a51b0cc6329a060d98eeb4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTNkZTUyMDQzMzJjYWIzN2Y5YTUxYjBjYzYzMjlhMDYwZDk4ZWViNA==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2003-09-18T08:25:12Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2003-09-18T08:25:12Z"}, "message": "c-pretty-print.h (pp_type_specifier_seq): Fix thinko.\n\n        * c-pretty-print.h (pp_type_specifier_seq): Fix thinko.\n        * c-pretty-print.c: Fix formatting.\n        (pp_c_integer_constant): Append type annotation to literals.  Tidy.\n        (pp_c_type_specifier): Tidy.\n        (pp_c_compound_literal): New function.\n        (pp_c_initializer): Simplify..\n        (pp_c_initializer_list): Likewise.\n        (pp_c_brace_enclosed_initializer_list): New function.\n        (pp_c_postfix_expression): Simplify.\n\ncp/\n        * error.c (dump_type): Simplify.  Use pp_type_specifier_seq for\n        \"C\" types.\n        * cxx-pretty-print.c (pp_cxx_type_specifier_seq): Fix thinko.\n\nFrom-SVN: r71511", "tree": {"sha": "fdbd03638ca28d0078d1a7f42225d33c7a199b20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fdbd03638ca28d0078d1a7f42225d33c7a199b20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/53de5204332cab37f9a51b0cc6329a060d98eeb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53de5204332cab37f9a51b0cc6329a060d98eeb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53de5204332cab37f9a51b0cc6329a060d98eeb4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53de5204332cab37f9a51b0cc6329a060d98eeb4/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1ea8e73b809603d2c182b20899ca7824bd0d0209", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ea8e73b809603d2c182b20899ca7824bd0d0209", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ea8e73b809603d2c182b20899ca7824bd0d0209"}], "stats": {"total": 270, "additions": 177, "deletions": 93}, "files": [{"sha": "53cc64271b7536253643c0507024b160fe82339f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53de5204332cab37f9a51b0cc6329a060d98eeb4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53de5204332cab37f9a51b0cc6329a060d98eeb4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=53de5204332cab37f9a51b0cc6329a060d98eeb4", "patch": "@@ -1,3 +1,15 @@\n+2003-09-18  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* c-pretty-print.h (pp_type_specifier_seq): Fix thinko.\n+\t* c-pretty-print.c: Fix formatting.\n+\t(pp_c_integer_constant): Append type annotation to literals.  Tidy.\n+\t(pp_c_type_specifier): Tidy.\n+\t(pp_c_compound_literal): New function.\n+\t(pp_c_initializer): Simplify..\n+\t(pp_c_initializer_list): Likewise.\n+\t(pp_c_brace_enclosed_initializer_list): New function.\n+\t(pp_c_postfix_expression): Simplify.\n+\n 2003-09-17  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* config/mn10300/mn10300.md (andsi3, iorsi3, xorsi3,"}, {"sha": "39dd8dba2b97d61712d34e21333e1a16f4e90cd9", "filename": "gcc/c-pretty-print.c", "status": "modified", "additions": 153, "deletions": 55, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53de5204332cab37f9a51b0cc6329a060d98eeb4/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53de5204332cab37f9a51b0cc6329a060d98eeb4/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=53de5204332cab37f9a51b0cc6329a060d98eeb4", "patch": "@@ -64,6 +64,7 @@ static void pp_c_char (c_pretty_printer *, int);\n \n /* postfix-expression  */\n static void pp_c_initializer_list (c_pretty_printer *, tree);\n+static void pp_c_brace_enclosed_initializer_list (c_pretty_printer *, tree);\n \n static void pp_c_multiplicative_expression (c_pretty_printer *, tree);\n static void pp_c_additive_expression (c_pretty_printer *, tree);\n@@ -155,6 +156,7 @@ pp_c_cv_qualifier (c_pretty_printer *pp, const char *cv)\n }\n \n /* Pretty-print T using the type-cast notation '( type-name )'.  */\n+\n static inline void\n pp_c_type_cast (c_pretty_printer *pp, tree t)\n {\n@@ -191,6 +193,7 @@ pp_c_space_for_pointer_operator (c_pretty_printer *pp, tree t)\n        restrict                              -- C99\n        __restrict__                          -- GNU C\n        volatile    */\n+\n void\n pp_c_type_qualifier_list (c_pretty_printer *pp, tree t)\n {\n@@ -211,6 +214,7 @@ pp_c_type_qualifier_list (c_pretty_printer *pp, tree t)\n /* pointer:\n       * type-qualifier-list(opt)\n       * type-qualifier-list(opt) pointer  */\n+\n static void\n pp_c_pointer (c_pretty_printer *pp, tree t)\n {\n@@ -256,6 +260,7 @@ pp_c_pointer (c_pretty_printer *pp, tree t)\n   simple-type-specifier:\n       __complex__\n       __vector__   */\n+\n void\n pp_c_type_specifier (c_pretty_printer *pp, tree t)\n {\n@@ -275,7 +280,11 @@ pp_c_type_specifier (c_pretty_printer *pp, tree t)\n     case CHAR_TYPE:\n     case INTEGER_TYPE:\n     case REAL_TYPE:\n-      pp_c_type_specifier (pp, TYPE_NAME (t));\n+      if (TYPE_NAME (t))\n+        t = TYPE_NAME (t);\n+      else\n+        t = c_common_type_for_mode (TYPE_MODE (t), TREE_UNSIGNED (t));\n+      pp_c_type_specifier (pp, t);\n       break;\n \n     case TYPE_DECL:\n@@ -319,6 +328,7 @@ pp_c_type_specifier (c_pretty_printer *pp, tree t)\n   specifier-qualifier-list of such entities or types of such entities,\n   but also the 'pointer' production part of their declarators.  The\n   remaining part is done by pp_declarator or pp_c_abstract_declarator.  */\n+\n void\n pp_c_specifier_qualifier_list (c_pretty_printer *pp, tree t)\n {\n@@ -353,9 +363,9 @@ pp_c_specifier_qualifier_list (c_pretty_printer *pp, tree t)\n     case COMPLEX_TYPE:\n       pp_c_specifier_qualifier_list (pp, TREE_TYPE (t));\n       if (code == COMPLEX_TYPE)\n-\tpp_c_identifier (pp, flag_isoc99 ? \"_Complex\" : \"__complex__\");\n+        pp_c_identifier (pp, flag_isoc99 ? \"_Complex\" : \"__complex__\");\n       else if (code == VECTOR_TYPE)\n-\tpp_c_identifier (pp, \"__vector__\");\n+        pp_c_identifier (pp, \"__vector__\");\n       break;\n \n     default:\n@@ -375,6 +385,7 @@ pp_c_specifier_qualifier_list (c_pretty_printer *pp, tree t)\n    parameter-declaration:\n       declaration-specifiers declarator\n       declaration-specifiers abstract-declarator(opt)   */\n+\n void\n pp_c_parameter_type_list (c_pretty_printer *pp, tree t)\n {\n@@ -405,6 +416,7 @@ pp_c_parameter_type_list (c_pretty_printer *pp, tree t)\n /* abstract-declarator:\n       pointer\n       pointer(opt) direct-abstract-declarator  */\n+\n static inline void\n pp_c_abstract_declarator (c_pretty_printer *pp, tree t)\n {\n@@ -424,6 +436,7 @@ pp_c_abstract_declarator (c_pretty_printer *pp, tree t)\n       direct-abstract-declarator(opt) [ assignment-expression(opt) ]\n       direct-abstract-declarator(opt) [ * ]\n       direct-abstract-declarator(opt) ( parameter-type-list(opt) )  */\n+\n void\n pp_c_direct_abstract_declarator (c_pretty_printer *pp, tree t)\n {\n@@ -467,6 +480,7 @@ pp_c_direct_abstract_declarator (c_pretty_printer *pp, tree t)\n \n /* type-name:\n       specifier-qualifier-list  abstract-declarator(opt)  */\n+\n void\n pp_c_type_id (c_pretty_printer *pp, tree t)\n {\n@@ -480,6 +494,7 @@ pp_c_type_id (c_pretty_printer *pp, tree t)\n       static\n       auto\n       register  */\n+\n void\n pp_c_storage_class_specifier (c_pretty_printer *pp, tree t)\n {\n@@ -496,6 +511,7 @@ pp_c_storage_class_specifier (c_pretty_printer *pp, tree t)\n \n /* function-specifier:\n       inline   */\n+\n void\n pp_c_function_specifier (c_pretty_printer *pp, tree t)\n {\n@@ -508,6 +524,7 @@ pp_c_function_specifier (c_pretty_printer *pp, tree t)\n       type-specifier declaration-specifiers(opt)\n       type-qualifier declaration-specifiers(opt)\n       function-specifier declaration-specifiers(opt)  */\n+\n void\n pp_c_declaration_specifiers (c_pretty_printer *pp, tree t)\n {\n@@ -525,6 +542,7 @@ pp_c_declaration_specifiers (c_pretty_printer *pp, tree t)\n       direct-declarator [ type-qualifier-list * ]\n       direct-declaratpr ( parameter-type-list )\n       direct-declarator ( identifier-list(opt) )  */\n+\n void\n pp_c_direct_declarator (c_pretty_printer *pp, tree t)\n {\n@@ -578,6 +596,7 @@ pp_c_direct_declarator (c_pretty_printer *pp, tree t)\n \n /* declarator:\n       pointer(opt)  direct-declarator   */\n+\n void\n pp_c_declarator (c_pretty_printer *pp, tree t)\n {\n@@ -609,6 +628,7 @@ pp_c_declarator (c_pretty_printer *pp, tree t)\n \n /* declaration:\n       declaration-specifiers init-declarator-list(opt) ;  */\n+\n void\n pp_c_declaration (c_pretty_printer *pp, tree t)\n {\n@@ -617,6 +637,7 @@ pp_c_declaration (c_pretty_printer *pp, tree t)\n }\n \n /* Pretty-print ATTRIBUTES using GNU C extension syntax.  */\n+\n void\n pp_c_attributes (c_pretty_printer *pp, tree attributes)\n {\n@@ -641,6 +662,7 @@ pp_c_attributes (c_pretty_printer *pp, tree attributes)\n \n /* function-definition:\n       declaration-specifiers declarator compound-statement  */\n+\n void\n pp_c_function_definition (c_pretty_printer *pp, tree t)\n {\n@@ -656,6 +678,7 @@ pp_c_function_definition (c_pretty_printer *pp, tree t)\n /* Expressions.  */\n \n /* Print out a c-char.  */\n+\n static void\n pp_c_char (c_pretty_printer *pp, int c)\n {\n@@ -701,6 +724,7 @@ pp_c_char (c_pretty_printer *pp, int c)\n }\n \n /* Print out a STRING literal.  */\n+\n void\n pp_c_string_literal (c_pretty_printer *pp, tree s)\n {\n@@ -716,7 +740,9 @@ pp_c_string_literal (c_pretty_printer *pp, tree s)\n static void\n pp_c_integer_constant (c_pretty_printer *pp, tree i)\n {\n-  if (host_integerp (i, 0))\n+  tree type = TREE_TYPE (i);\n+\n+  if (TREE_INT_CST_HIGH (i) == 0)\n     pp_wide_integer (pp, TREE_INT_CST_LOW (i));\n   else\n     {\n@@ -731,9 +757,17 @@ pp_c_integer_constant (c_pretty_printer *pp, tree i)\n                TREE_INT_CST_HIGH (i), TREE_INT_CST_LOW (i));\n       pp_string (pp, pp_buffer (pp)->digit_buffer);\n     }\n+  if (TREE_UNSIGNED (type))\n+    pp_character (pp, 'u');\n+  if (type == long_integer_type_node || type == long_unsigned_type_node)\n+    pp_character (pp, 'l');\n+  else if (type == long_long_integer_type_node\n+           || type == long_long_unsigned_type_node)\n+    pp_string (pp, \"ll\");\n }\n \n /* Print out a CHARACTER literal.  */\n+\n static inline void\n pp_c_character_constant (c_pretty_printer *pp, tree c)\n {\n@@ -749,6 +783,7 @@ pp_c_character_constant (c_pretty_printer *pp, tree c)\n }\n \n /* Print out a BOOLEAN literal.  */\n+\n static void\n pp_c_bool_constant (c_pretty_printer *pp, tree b)\n {\n@@ -780,6 +815,7 @@ pp_c_bool_constant (c_pretty_printer *pp, tree b)\n    false; that means the value was obtained by a cast, in which case\n    print out the type-id part of the cast-expression -- the casted value\n    is then printed by pp_c_integer_literal.  */\n+\n static bool\n pp_c_enumeration_constant (c_pretty_printer *pp, tree e)\n {\n@@ -819,15 +855,43 @@ pp_c_floating_constant (c_pretty_printer *pp, tree r)\n     pp_character (pp, 'l');\n }\n \n+/* Pretty-print a compound literal expression.  GNU extensions include\n+   vector constants.  */ \n+\n+static void\n+pp_c_compound_literal (c_pretty_printer *pp, tree e)\n+{\n+  tree type = TREE_TYPE (e);  \n+  pp_c_type_cast (pp, type);\n+\n+  switch (TREE_CODE (type))\n+    {\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case ARRAY_TYPE:\n+    case VECTOR_TYPE:\n+    case COMPLEX_TYPE:\n+      pp_c_brace_enclosed_initializer_list (pp, e);\n+      break;\n+\n+    default:\n+      pp_unsupported_tree (pp, e);\n+      break;\n+    }\n+}\n+\n /* constant:\n       integer-constant\n       floating-constant\n       enumeration-constant\n       chatracter-constant   */\n+\n void\n pp_c_constant (c_pretty_printer *pp, tree e)\n {\n-  switch (TREE_CODE (e))\n+  const enum tree_code code = TREE_CODE (e);\n+\n+  switch (code)\n     {\n     case INTEGER_CST:\n       {\n@@ -872,6 +936,7 @@ pp_c_identifier (c_pretty_printer *pp, const char *id)\n       constant\n       string-literal\n       ( expression )   */\n+\n void\n pp_c_primary_expression (c_pretty_printer *pp, tree e)\n {\n@@ -931,11 +996,7 @@ pp_c_initializer (c_pretty_printer *pp, tree e)\n     {\n       enum tree_code code = TREE_CODE (TREE_TYPE (e));\n       if (code == RECORD_TYPE || code == UNION_TYPE || code == ARRAY_TYPE)\n-\t{\n-\t  pp_c_left_brace (pp);\n-\t  pp_c_initializer_list (pp, e);\n-\t  pp_c_right_brace (pp);\n-\t}\n+        pp_c_brace_enclosed_initializer_list (pp, e);\n       else\n \tpp_unsupported_tree (pp, TREE_OPERAND (e, 1));\n     }\n@@ -946,6 +1007,7 @@ pp_c_initializer (c_pretty_printer *pp, tree e)\n /* init-declarator:\n       declarator:\n       declarator = initializer   */\n+\n void\n pp_c_init_declarator (c_pretty_printer *pp, tree t)\n {\n@@ -987,46 +1049,80 @@ pp_c_init_declarator (c_pretty_printer *pp, tree t)\n    designator:\n       [ constant-expression ]\n       identifier   */\n+\n static void\n pp_c_initializer_list (c_pretty_printer *pp, tree e)\n {\n   tree type = TREE_TYPE (e);\n   const enum tree_code code = TREE_CODE (type);\n \n-  if (code == RECORD_TYPE || code == UNION_TYPE || code == ARRAY_TYPE)\n+  switch (code)\n     {\n-      tree init = TREE_OPERAND (e, 0);\n-      for (; init != NULL_TREE; init = TREE_CHAIN (init))\n-\t{\n-\t  if (code == RECORD_TYPE || code == UNION_TYPE)\n-\t    {\n-\t      pp_c_dot (pp);\n-\t      pp_c_primary_expression (pp, TREE_PURPOSE (init));\n-\t    }\n-\t  else\n-\t    {\n-\t      pp_c_left_bracket (pp);\n-\t      if (TREE_PURPOSE (init))\n-\t\tpp_c_constant (pp, TREE_PURPOSE (init));\n-\t      pp_c_right_bracket (pp);\n-\t    }\n-\t  pp_c_whitespace (pp);\n-\t  pp_equal (pp);\n-\t  pp_c_whitespace (pp);\n-\t  pp_initializer (pp, TREE_VALUE (init));\n-\t  if (TREE_CHAIN (init))\n-\t    pp_separate_with (pp, ',');\n-\t}\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case ARRAY_TYPE:\n+      {\n+        tree init = TREE_OPERAND (e, 0);\n+        for (; init != NULL_TREE; init = TREE_CHAIN (init))\n+          {\n+            if (code == RECORD_TYPE || code == UNION_TYPE)\n+              {\n+                pp_c_dot (pp);\n+                pp_c_primary_expression (pp, TREE_PURPOSE (init));\n+              }\n+            else\n+              {\n+                pp_c_left_bracket (pp);\n+                if (TREE_PURPOSE (init))\n+                  pp_c_constant (pp, TREE_PURPOSE (init));\n+                pp_c_right_bracket (pp);\n+              }\n+            pp_c_whitespace (pp);\n+            pp_equal (pp);\n+            pp_c_whitespace (pp);\n+            pp_initializer (pp, TREE_VALUE (init));\n+            if (TREE_CHAIN (init))\n+              pp_separate_with (pp, ',');\n+          }\n+      }\n+      break;\n+\n+    case VECTOR_TYPE:\n+      pp_c_expression_list (pp, TREE_VECTOR_CST_ELTS (e));\n+      break;\n+\n+    case COMPLEX_TYPE:\n+      {\n+        const bool cst = TREE_CODE (e) == COMPLEX_CST;\n+        pp_expression (pp, cst ? TREE_REALPART (e) : TREE_OPERAND (e, 0));\n+        pp_separate_with (pp, ',');\n+        pp_expression (pp, cst ? TREE_IMAGPART (e) : TREE_OPERAND (e, 1));\n+      }\n+      break;\n+\n+    default:\n+      pp_unsupported_tree (pp, type);\n+      break;\n     }\n-  else\n-    pp_unsupported_tree (pp, type);\n }\n \n+/* Pretty-print a brace-enclosed initializer-list.   */\n+\n+static void\n+pp_c_brace_enclosed_initializer_list (c_pretty_printer *pp, tree l)\n+{\n+  pp_c_left_brace (pp);\n+  pp_c_initializer_list (pp, l);\n+  pp_c_right_brace (pp);\n+}\n+\n+\n /*  This is a convenient function, used to bridge gap between C and C++\n     grammars.\n \n     id-expression:\n        identifier  */\n+\n void\n pp_c_id_expression (c_pretty_printer *pp, tree t)\n {\n@@ -1060,6 +1156,7 @@ pp_c_id_expression (c_pretty_printer *pp, tree t)\n       postfix-expression --\n       ( type-name ) { initializer-list }\n       ( type-name ) { initializer-list , }  */\n+\n void\n pp_c_postfix_expression (c_pretty_printer *pp, tree e)\n {\n@@ -1118,25 +1215,7 @@ pp_c_postfix_expression (c_pretty_printer *pp, tree e)\n     case COMPLEX_CST:\n     case VECTOR_CST:\n     case COMPLEX_EXPR:\n-      pp_c_type_cast (pp, TREE_TYPE (e));\n-      pp_c_left_brace (pp);\n-\n-      if (code == COMPLEX_CST)\n-\t{\n-\t  pp_expression (pp, TREE_REALPART (e));\n-\t  pp_separate_with (pp, ',');\n-\t  pp_expression (pp, TREE_IMAGPART (e));\n-\t}\n-      else if (code == VECTOR_CST)\n-\tpp_c_expression_list (pp, TREE_VECTOR_CST_ELTS (e));\n-      else if (code == COMPLEX_EXPR)\n-\t{\n-\t  pp_expression (pp, TREE_OPERAND (e, 0));\n-\t  pp_separate_with (pp, ',');\n-\t  pp_expression (pp, TREE_OPERAND (e, 1));\n-\t}\n-\n-      pp_c_right_brace (pp);\n+      pp_c_compound_literal (pp, e);\n       break;\n \n     case COMPOUND_LITERAL_EXPR:\n@@ -1170,6 +1249,7 @@ pp_c_postfix_expression (c_pretty_printer *pp, tree e)\n }\n \n /* Print out an expression-list; E is expected to be a TREE_LIST  */\n+\n void\n pp_c_expression_list (c_pretty_printer *pp, tree e)\n {\n@@ -1182,6 +1262,7 @@ pp_c_expression_list (c_pretty_printer *pp, tree e)\n }\n \n /* Print out an expression-list in parens, as in a function call.   */\n+\n void\n pp_c_call_argument_list (c_pretty_printer *pp, tree t)\n {\n@@ -1208,6 +1289,7 @@ pp_c_call_argument_list (c_pretty_printer *pp, tree t)\n       __alignof__ ( type-id )\n       __real__ unary-expression\n       __imag__ unary-expression  */\n+\n void\n pp_c_unary_expression (c_pretty_printer *pp, tree e)\n {\n@@ -1266,6 +1348,7 @@ pp_c_unary_expression (c_pretty_printer *pp, tree e)\n /* cast-expression:\n       unary-expression\n       ( type-name ) cast-expression  */\n+\n void\n pp_c_cast_expression (c_pretty_printer *pp, tree e)\n {\n@@ -1288,6 +1371,7 @@ pp_c_cast_expression (c_pretty_printer *pp, tree e)\n       multiplicative-expression * cast-expression\n       multiplicative-expression / cast-expression\n       multiplicative-expression % cast-expression   */\n+\n static void\n pp_c_multiplicative_expression (c_pretty_printer *pp, tree e)\n {\n@@ -1319,6 +1403,7 @@ pp_c_multiplicative_expression (c_pretty_printer *pp, tree e)\n       multiplicative-expression\n       additive-expression + multiplicative-expression\n       additive-expression - multiplicative-expression   */\n+\n static inline void\n pp_c_additive_expression (c_pretty_printer *pp, tree e)\n {\n@@ -1347,6 +1432,7 @@ pp_c_additive_expression (c_pretty_printer *pp, tree e)\n       additive-expression\n       shift-expression << additive-expression\n       shift-expression >> additive-expression   */\n+\n static inline void\n pp_c_shift_expression (c_pretty_printer *pp, tree e)\n {\n@@ -1373,6 +1459,7 @@ pp_c_shift_expression (c_pretty_printer *pp, tree e)\n       relational-expression > shift-expression\n       relational-expression <= shift-expression\n       relational-expression >= shift-expression   */\n+\n static void\n pp_c_relational_expression (c_pretty_printer *pp, tree e)\n {\n@@ -1407,6 +1494,7 @@ pp_c_relational_expression (c_pretty_printer *pp, tree e)\n       relational-expression\n       equality-expression == relational-expression\n       equality-equality != relational-expression  */\n+\n static inline void\n pp_c_equality_expression (c_pretty_printer *pp, tree e)\n {\n@@ -1431,6 +1519,7 @@ pp_c_equality_expression (c_pretty_printer *pp, tree e)\n /* AND-expression:\n       equality-expression\n       AND-expression & equality-equality   */\n+\n static inline void\n pp_c_and_expression (c_pretty_printer *pp, tree e)\n {\n@@ -1449,6 +1538,7 @@ pp_c_and_expression (c_pretty_printer *pp, tree e)\n /* exclusive-OR-expression:\n      AND-expression\n      exclusive-OR-expression ^ AND-expression  */\n+\n static inline void\n pp_c_exclusive_or_expression (c_pretty_printer *pp, tree e)\n {\n@@ -1467,6 +1557,7 @@ pp_c_exclusive_or_expression (c_pretty_printer *pp, tree e)\n /* inclusive-OR-expression:\n      exclusive-OR-expression\n      inclusive-OR-expression | exclusive-OR-expression  */\n+\n static inline void\n pp_c_inclusive_or_expression (c_pretty_printer *pp, tree e)\n {\n@@ -1485,6 +1576,7 @@ pp_c_inclusive_or_expression (c_pretty_printer *pp, tree e)\n /* logical-AND-expression:\n       inclusive-OR-expression\n       logical-AND-expression && inclusive-OR-expression  */\n+\n static inline void\n pp_c_logical_and_expression (c_pretty_printer *pp, tree e)\n {\n@@ -1503,6 +1595,7 @@ pp_c_logical_and_expression (c_pretty_printer *pp, tree e)\n /* logical-OR-expression:\n       logical-AND-expression\n       logical-OR-expression || logical-AND-expression  */\n+\n void\n pp_c_logical_or_expression (c_pretty_printer *pp, tree e)\n {\n@@ -1521,6 +1614,7 @@ pp_c_logical_or_expression (c_pretty_printer *pp, tree e)\n /* conditional-expression:\n       logical-OR-expression\n       logical-OR-expression ? expression : conditional-expression  */\n+\n static void\n pp_c_conditional_expression (c_pretty_printer *pp, tree e)\n {\n@@ -1547,6 +1641,7 @@ pp_c_conditional_expression (c_pretty_printer *pp, tree e)\n \n    assignment-expression: one of\n       =    *=    /=    %=    +=    -=    >>=    <<=    &=    ^=    |=  */\n+\n static void\n pp_c_assignment_expression (c_pretty_printer *pp, tree e)\n {\n@@ -1571,6 +1666,7 @@ pp_c_assignment_expression (c_pretty_printer *pp, tree e)\n   functions.  This makes some redundancy, but it worths it. That also\n   prevents a possible infinite recursion between pp_c_primary_expression ()\n   and pp_c_expression ().  */\n+\n void\n pp_c_expression (c_pretty_printer *pp, tree e)\n {\n@@ -1608,12 +1704,12 @@ pp_c_expression (c_pretty_printer *pp, tree e)\n     case CALL_EXPR:\n     case COMPONENT_REF:\n     case COMPLEX_CST:\n+    case COMPLEX_EXPR:\n     case VECTOR_CST:\n     case ABS_EXPR:\n     case FFS_EXPR:\n     case CONSTRUCTOR:\n     case COMPOUND_LITERAL_EXPR:\n-    case COMPLEX_EXPR:\n     case VA_ARG_EXPR:\n       pp_postfix_expression (pp, e);\n       break;\n@@ -1732,6 +1828,7 @@ pp_c_expression (c_pretty_printer *pp, tree e)\n       selection-statement\n       iteration-statement\n       jump-statement   */\n+\n void\n pp_c_statement (c_pretty_printer *pp, tree stmt)\n {\n@@ -2030,6 +2127,7 @@ pp_c_statement (c_pretty_printer *pp, tree stmt)\n \n \f\n /* Initialize the PRETTY-PRINTER for handling C codes.  */\n+\n void\n pp_c_pretty_printer_init (c_pretty_printer *pp)\n {"}, {"sha": "26b3cae99c782724279cdbc631f6f1f7431c8136", "filename": "gcc/c-pretty-print.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53de5204332cab37f9a51b0cc6329a060d98eeb4/gcc%2Fc-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53de5204332cab37f9a51b0cc6329a060d98eeb4/gcc%2Fc-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.h?ref=53de5204332cab37f9a51b0cc6329a060d98eeb4", "patch": "@@ -106,7 +106,7 @@ struct c_pretty_print_info\n #define pp_abstract_declarator(PP, D)             \\\n    pp_c_base (PP)->abstract_declarator (pp_c_base (PP), D)\n #define pp_type_specifier_seq(PPI, D)             \\\n-   pp_c_base (PPI)->type_specifie_seqr (pp_c_base (PPI), D)\n+   pp_c_base (PPI)->type_specifier_seq (pp_c_base (PPI), D)\n #define pp_declarator(PPI, D)                     \\\n    pp_c_base (PPI)->declarator (pp_c_base (PPI), D)\n #define pp_direct_declarator(PPI, D)              \\"}, {"sha": "8db2dc915066ae29591417cdfca0e38465624ace", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53de5204332cab37f9a51b0cc6329a060d98eeb4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53de5204332cab37f9a51b0cc6329a060d98eeb4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=53de5204332cab37f9a51b0cc6329a060d98eeb4", "patch": "@@ -1,3 +1,9 @@\n+2003-09-18  Gabriel Dos Reis <gdr@integrable-solutions.net>\n+\n+\t* error.c (dump_type): Simplify.  Use pp_type_specifier_seq for\n+\t\"C\" types. \n+\t* cxx-pretty-print.c (pp_cxx_type_specifier_seq): Fix thinko.\n+\n 2003-09-17  Richard Henderson  <rth@redhat.com>\n \n \t* semantics.c (expand_body): Don't save/restore input_location."}, {"sha": "69ee6b53675a11cf967d242d0bd275bd3e28036a", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53de5204332cab37f9a51b0cc6329a060d98eeb4/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53de5204332cab37f9a51b0cc6329a060d98eeb4/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=53de5204332cab37f9a51b0cc6329a060d98eeb4", "patch": "@@ -993,14 +993,13 @@ pp_cxx_simple_type_specifier (cxx_pretty_printer *pp, tree t)\n static void\n pp_cxx_type_specifier_seq (cxx_pretty_printer *pp, tree t)\n {\n-  pp_c_type_qualifier_list (pp_c_base (pp), t);\n-\n   switch (TREE_CODE (t))\n     {\n     case TEMPLATE_DECL:\n     case TEMPLATE_TYPE_PARM:\n     case TYPE_DECL:\n     case BOUND_TEMPLATE_TEMPLATE_PARM:\n+      pp_c_type_qualifier_list (pp_c_base (pp), t);\n       pp_cxx_simple_type_specifier (pp, t);\n       break;\n "}, {"sha": "a10dcf6a87611506e967a23e9b31584fd3e1c020", "filename": "gcc/cp/error.c", "status": "modified", "additions": 4, "deletions": 35, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53de5204332cab37f9a51b0cc6329a060d98eeb4/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53de5204332cab37f9a51b0cc6329a060d98eeb4/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=53de5204332cab37f9a51b0cc6329a060d98eeb4", "patch": "@@ -338,45 +338,14 @@ dump_type (tree t, int flags)\n       dump_decl (t, flags & ~TFF_DECL_SPECIFIERS);\n       break;\n \n-    case COMPLEX_TYPE:\n-      pp_string (cxx_pp, \"__complex__ \");\n-      dump_type (TREE_TYPE (t), flags);\n-      break;\n-\n-    case VECTOR_TYPE:\n-      pp_string (cxx_pp, \"__vector__ \");\n-      {\n-\t/* The subtype of a VECTOR_TYPE is something like intQI_type_node,\n-\t   which has no name and is not very useful for diagnostics.  So\n-\t   look up the equivalent C type and print its name.  */\n-\ttree elt = TREE_TYPE (t);\n-\telt = c_common_type_for_mode (TYPE_MODE (elt), TREE_UNSIGNED (elt));\n-\tdump_type (elt, flags);\n-      }\n-      break;\n-\n     case INTEGER_TYPE:\n-      if (!TREE_UNSIGNED (TYPE_MAIN_VARIANT (t)) && TREE_UNSIGNED (t))\n-\tpp_string (cxx_pp, \"unsigned \");\n-      else if (TREE_UNSIGNED (TYPE_MAIN_VARIANT (t)) && !TREE_UNSIGNED (t))\n-\tpp_string (cxx_pp, \"signed \");\n-\n-      /* fall through.  */\n     case REAL_TYPE:\n     case VOID_TYPE:\n     case BOOLEAN_TYPE:\n-      {\n-\ttree type;\n-\tdump_qualifiers (t, after);\n-\ttype = flags & TFF_CHASE_TYPEDEF ? TYPE_MAIN_VARIANT (t) : t;\n-\tif (TYPE_NAME (type) && TYPE_IDENTIFIER (type))\n-\t  pp_tree_identifier (cxx_pp, TYPE_IDENTIFIER (type));\n-\telse\n-\t  /* Types like intQI_type_node and friends have no names.\n-\t     These don't come up in user error messages, but it's nice\n-\t     to be able to print them from the debugger.  */\n-\t  pp_identifier (cxx_pp, \"<anonymous>\");\n-      }\n+    case COMPLEX_TYPE:\n+    case VECTOR_TYPE:\n+      pp_base (cxx_pp)->padding = pp_none;\n+      pp_type_specifier_seq (cxx_pp, t);\n       break;\n \n     case TEMPLATE_TEMPLATE_PARM:"}]}