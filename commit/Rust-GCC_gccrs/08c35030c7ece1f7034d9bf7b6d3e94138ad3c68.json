{"sha": "08c35030c7ece1f7034d9bf7b6d3e94138ad3c68", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhjMzUwMzBjN2VjZTFmNzAzNGQ5YmY3YjZkM2U5NDEzOGFkM2M2OA==", "commit": {"author": {"name": "Bernd Edlinger", "email": "bernd.edlinger@hotmail.de", "date": "2019-01-07T17:08:51Z"}, "committer": {"name": "Bernd Edlinger", "email": "edlinger@gcc.gnu.org", "date": "2019-01-07T17:08:51Z"}, "message": "re PR c++/88261 (ICE: verify_gimple failed (error: non-trivial conversion at assignment))\n\n        PR c++/88261\n        PR c++/69338\n        PR c++/69696\n        PR c++/69697\n        * cp-tree.h (LOOKUP_ALLOW_FLEXARRAY_INIT): New flag value.\n        * typeck2.c (digest_init_r): Raise an error for non-static\n        initialization of a flexible array member.\n        (process_init_constructor, massage_init_elt,\n        process_init_constructor_array, process_init_constructor_record,\n        process_init_constructor_union, process_init_constructor): Add the\n        flags parameter and pass it thru.\n        (store_init_value): Pass LOOKUP_ALLOW_FLEXARRAY_INIT parameter to\n        digest_init_flags for static decls.\n\ngcc/testsuite:\n2019-01-07  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n\n        PR c++/88261\n        PR c++/69338\n        PR c++/69696\n        PR c++/69697\n        * gcc.dg/array-6.c: Move from here ...\n        * c-c++-common/array-6.c: ... to here and add some more test coverage.\n        * g++.dg/pr69338.C: New test.\n        * g++.dg/pr69697.C: Likewise.\n        * g++.dg/ext/flexary32.C: Likewise.\n        * g++.dg/ext/flexary3.C: Adjust test.\n        * g++.dg/ext/flexary12.C: Likewise.\n        * g++.dg/ext/flexary13.C: Likewise.\n        * g++.dg/ext/flexary15.C: Likewise.\n        * g++.dg/warn/Wplacement-new-size-1.C: Likewise.\n        * g++.dg/warn/Wplacement-new-size-2.C: Likewise.\n        * g++.dg/warn/Wplacement-new-size-6.C: Likewise.\n\nFrom-SVN: r267653", "tree": {"sha": "a29a65864defc38e95dac82a895bf307d05df660", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a29a65864defc38e95dac82a895bf307d05df660"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/comments", "author": {"login": "bernd-edlinger", "id": 17638929, "node_id": "MDQ6VXNlcjE3NjM4OTI5", "avatar_url": "https://avatars.githubusercontent.com/u/17638929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bernd-edlinger", "html_url": "https://github.com/bernd-edlinger", "followers_url": "https://api.github.com/users/bernd-edlinger/followers", "following_url": "https://api.github.com/users/bernd-edlinger/following{/other_user}", "gists_url": "https://api.github.com/users/bernd-edlinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/bernd-edlinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bernd-edlinger/subscriptions", "organizations_url": "https://api.github.com/users/bernd-edlinger/orgs", "repos_url": "https://api.github.com/users/bernd-edlinger/repos", "events_url": "https://api.github.com/users/bernd-edlinger/events{/privacy}", "received_events_url": "https://api.github.com/users/bernd-edlinger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "18fd43b95264a7244b50fd34cf983f4d78c208dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18fd43b95264a7244b50fd34cf983f4d78c208dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18fd43b95264a7244b50fd34cf983f4d78c208dc"}], "stats": {"total": 282, "additions": 211, "deletions": 71}, "files": [{"sha": "60c8ae1934eca33847f34dfe8f0e8c2560ff11ee", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=08c35030c7ece1f7034d9bf7b6d3e94138ad3c68", "patch": "@@ -1,3 +1,19 @@\n+2019-01-07  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n+\n+\tPR c++/88261\n+\tPR c++/69338\n+\tPR c++/69696\n+\tPR c++/69697\n+\t* cp-tree.h (LOOKUP_ALLOW_FLEXARRAY_INIT): New flag value.\n+\t* typeck2.c (digest_init_r): Raise an error for non-static\n+\tinitialization of a flexible array member.\n+\t(process_init_constructor, massage_init_elt,\n+\tprocess_init_constructor_array, process_init_constructor_record,\n+\tprocess_init_constructor_union, process_init_constructor): Add the\n+\tflags parameter and pass it thru.\n+\t(store_init_value): Pass LOOKUP_ALLOW_FLEXARRAY_INIT parameter to\n+\tdigest_init_flags for static decls.\n+\n 2019-01-07  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/85052"}, {"sha": "44739049b8d4e003cfb64f9f994527900b2aa417", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=08c35030c7ece1f7034d9bf7b6d3e94138ad3c68", "patch": "@@ -5454,6 +5454,8 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, TYPENAME_FLAG };\n #define LOOKUP_NO_NON_INTEGRAL (LOOKUP_NO_RVAL_BIND << 1)\n /* Used for delegating constructors in order to diagnose self-delegation.  */\n #define LOOKUP_DELEGATING_CONS (LOOKUP_NO_NON_INTEGRAL << 1)\n+/* Allow initialization of a flexible array members.  */\n+#define LOOKUP_ALLOW_FLEXARRAY_INIT (LOOKUP_DELEGATING_CONS << 1)\n \n #define LOOKUP_NAMESPACES_ONLY(F)  \\\n   (((F) & LOOKUP_PREFER_NAMESPACES) && !((F) & LOOKUP_PREFER_TYPES))"}, {"sha": "ecc313b2355f0cef1ae0e55f20203a4dbad08e7a", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 56, "deletions": 32, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=08c35030c7ece1f7034d9bf7b6d3e94138ad3c68", "patch": "@@ -35,7 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gcc-rich-location.h\"\n \n static tree\n-process_init_constructor (tree type, tree init, int nested,\n+process_init_constructor (tree type, tree init, int nested, int flags,\n \t\t\t  tsubst_flags_t complain);\n \n \n@@ -817,8 +817,12 @@ store_init_value (tree decl, tree init, vec<tree, va_gc>** cleanups, int flags)\n   if (flags & LOOKUP_ALREADY_DIGESTED)\n     value = init;\n   else\n-    /* Digest the specified initializer into an expression.  */\n-    value = digest_init_flags (type, init, flags, tf_warning_or_error);\n+    {\n+      if (TREE_STATIC (decl))\n+\tflags |= LOOKUP_ALLOW_FLEXARRAY_INIT;\n+      /* Digest the specified initializer into an expression.  */\n+      value = digest_init_flags (type, init, flags, tf_warning_or_error);\n+    }\n \n   if (TREE_CODE (type) == ARRAY_TYPE\n       && TYPE_STRING_FLAG (TREE_TYPE (type))\n@@ -1068,8 +1072,18 @@ digest_init_r (tree type, tree init, int nested, int flags,\n     {\n       if (nested && !TYPE_DOMAIN (type))\n \t/* C++ flexible array members have a null domain.  */\n-\tpedwarn (loc, OPT_Wpedantic,\n-\t\t \"initialization of a flexible array member\");\n+\t{\n+\t  if (flags & LOOKUP_ALLOW_FLEXARRAY_INIT)\n+\t    pedwarn (loc, OPT_Wpedantic,\n+\t\t     \"initialization of a flexible array member\");\n+\t  else\n+\t    {\n+\t      if (complain & tf_error)\n+\t\terror_at (loc, \"non-static initialization of\"\n+\t\t\t       \" a flexible array member\");\n+\t      return error_mark_node;\n+\t    }\n+\t}\n \n       tree typ1 = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n       if (char_type_p (typ1)\n@@ -1193,7 +1207,8 @@ digest_init_r (tree type, tree init, int nested, int flags,\n \n   if (BRACE_ENCLOSED_INITIALIZER_P (stripped_init)\n       && !TYPE_NON_AGGREGATE_CLASS (type))\n-    return process_init_constructor (type, stripped_init, nested, complain);\n+    return process_init_constructor (type, stripped_init, nested, flags,\n+\t\t\t\t     complain);\n   else\n     {\n       if (COMPOUND_LITERAL_P (stripped_init) && code == ARRAY_TYPE)\n@@ -1291,9 +1306,12 @@ picflag_from_initializer (tree init)\n /* Adjust INIT for going into a CONSTRUCTOR.  */\n \n static tree\n-massage_init_elt (tree type, tree init, int nested, tsubst_flags_t complain)\n+massage_init_elt (tree type, tree init, int nested, int flags,\n+\t\t  tsubst_flags_t complain)\n {\n-  init = digest_init_r (type, init, nested ? 2 : 1, LOOKUP_IMPLICIT, complain);\n+  flags &= LOOKUP_ALLOW_FLEXARRAY_INIT;\n+  flags |= LOOKUP_IMPLICIT;\n+  init = digest_init_r (type, init, nested ? 2 : 1, flags, complain);\n   /* Strip a simple TARGET_EXPR when we know this is an initializer.  */\n   if (SIMPLE_TARGET_EXPR_P (init))\n     init = TARGET_EXPR_INITIAL (init);\n@@ -1311,11 +1329,11 @@ massage_init_elt (tree type, tree init, int nested, tsubst_flags_t complain)\n    which describe the initializers.  */\n \n static int\n-process_init_constructor_array (tree type, tree init, int nested,\n+process_init_constructor_array (tree type, tree init, int nested, int flags,\n \t\t\t\ttsubst_flags_t complain)\n {\n   unsigned HOST_WIDE_INT i, len = 0;\n-  int flags = 0;\n+  int picflags = 0;\n   bool unbounded = false;\n   constructor_elt *ce;\n   vec<constructor_elt, va_gc> *v = CONSTRUCTOR_ELTS (init);\n@@ -1365,15 +1383,16 @@ process_init_constructor_array (tree type, tree init, int nested,\n \tce->index = error_mark_node;\n       gcc_assert (ce->value);\n       ce->value\n-\t= massage_init_elt (TREE_TYPE (type), ce->value, nested, complain);\n+\t= massage_init_elt (TREE_TYPE (type), ce->value, nested, flags,\n+\t\t\t    complain);\n \n       gcc_checking_assert\n \t(ce->value == error_mark_node\n \t || (same_type_ignoring_top_level_qualifiers_p\n \t     (strip_array_types (TREE_TYPE (type)),\n \t      strip_array_types (TREE_TYPE (ce->value)))));\n \n-      flags |= picflag_from_initializer (ce->value);\n+      picflags |= picflag_from_initializer (ce->value);\n     }\n \n   /* No more initializers. If the array is unbounded, we are done. Otherwise,\n@@ -1389,7 +1408,8 @@ process_init_constructor_array (tree type, tree init, int nested,\n \t       we can't rely on the back end to do it for us, so make the\n \t       initialization explicit by list-initializing from T{}.  */\n \t    next = build_constructor (init_list_type_node, NULL);\n-\t    next = massage_init_elt (TREE_TYPE (type), next, nested, complain);\n+\t    next = massage_init_elt (TREE_TYPE (type), next, nested, flags,\n+\t\t\t\t     complain);\n \t    if (initializer_zerop (next))\n \t      /* The default zero-initialization is fine for us; don't\n \t\t add anything to the CONSTRUCTOR.  */\n@@ -1406,7 +1426,7 @@ process_init_constructor_array (tree type, tree init, int nested,\n \n \tif (next)\n \t  {\n-\t    flags |= picflag_from_initializer (next);\n+\t    picflags |= picflag_from_initializer (next);\n \t    if (len > i+1\n \t\t&& (initializer_constant_valid_p (next, TREE_TYPE (next))\n \t\t    == null_pointer_node))\n@@ -1426,15 +1446,15 @@ process_init_constructor_array (tree type, tree init, int nested,\n       }\n \n   CONSTRUCTOR_ELTS (init) = v;\n-  return flags;\n+  return picflags;\n }\n \n /* Subroutine of process_init_constructor, which will process an initializer\n    INIT for a class of type TYPE. Returns the flags (PICFLAG_*) which describe\n    the initializers.  */\n \n static int\n-process_init_constructor_record (tree type, tree init, int nested,\n+process_init_constructor_record (tree type, tree init, int nested, int flags,\n \t\t\t\t tsubst_flags_t complain)\n {\n   vec<constructor_elt, va_gc> *v = NULL;\n@@ -1449,7 +1469,7 @@ process_init_constructor_record (tree type, tree init, int nested,\n   gcc_assert (!TYPE_POLYMORPHIC_P (type));\n \n  restart:\n-  int flags = 0;\n+  int picflags = 0;\n   unsigned HOST_WIDE_INT idx = 0;\n   int designator_skip = -1;\n   /* Generally, we will always have an index for each initializer (which is\n@@ -1517,7 +1537,7 @@ process_init_constructor_record (tree type, tree init, int nested,\n \t  if (ce)\n \t    {\n \t      gcc_assert (ce->value);\n-\t      next = massage_init_elt (type, next, nested, complain);\n+\t      next = massage_init_elt (type, next, nested, flags, complain);\n \t      ++idx;\n \t    }\n \t}\n@@ -1546,7 +1566,8 @@ process_init_constructor_record (tree type, tree init, int nested,\n \t     for us, so build up TARGET_EXPRs.  If the type in question is\n \t     a class, just build one up; if it's an array, recurse.  */\n \t  next = build_constructor (init_list_type_node, NULL);\n-\t  next = massage_init_elt (TREE_TYPE (field), next, nested, complain);\n+\t  next = massage_init_elt (TREE_TYPE (field), next, nested, flags,\n+\t\t\t\t   complain);\n \n \t  /* Warn when some struct elements are implicitly initialized.  */\n \t  if ((complain & tf_warning)\n@@ -1597,7 +1618,7 @@ process_init_constructor_record (tree type, tree init, int nested,\n       /* If this is a bitfield, now convert to the lowered type.  */\n       if (type != TREE_TYPE (field))\n \tnext = cp_convert_and_check (TREE_TYPE (field), next, complain);\n-      flags |= picflag_from_initializer (next);\n+      picflags |= picflag_from_initializer (next);\n       CONSTRUCTOR_APPEND_ELT (v, field, next);\n     }\n \n@@ -1653,15 +1674,15 @@ process_init_constructor_record (tree type, tree init, int nested,\n     }\n \n   CONSTRUCTOR_ELTS (init) = v;\n-  return flags;\n+  return picflags;\n }\n \n /* Subroutine of process_init_constructor, which will process a single\n    initializer INIT for a union of type TYPE. Returns the flags (PICFLAG_*)\n    which describe the initializer.  */\n \n static int\n-process_init_constructor_union (tree type, tree init, int nested,\n+process_init_constructor_union (tree type, tree init, int nested, int flags,\n \t\t\t\ttsubst_flags_t complain)\n {\n   constructor_elt *ce;\n@@ -1749,7 +1770,7 @@ process_init_constructor_union (tree type, tree init, int nested,\n \n   if (ce->value && ce->value != error_mark_node)\n     ce->value = massage_init_elt (TREE_TYPE (ce->index), ce->value, nested,\n-\t\t\t\t  complain);\n+\t\t\t\t  flags, complain);\n \n   return picflag_from_initializer (ce->value);\n }\n@@ -1769,40 +1790,43 @@ process_init_constructor_union (tree type, tree init, int nested,\n    of error.  */\n \n static tree\n-process_init_constructor (tree type, tree init, int nested,\n+process_init_constructor (tree type, tree init, int nested, int flags,\n \t\t\t  tsubst_flags_t complain)\n {\n-  int flags;\n+  int picflags;\n \n   gcc_assert (BRACE_ENCLOSED_INITIALIZER_P (init));\n \n   if (TREE_CODE (type) == ARRAY_TYPE || VECTOR_TYPE_P (type))\n-    flags = process_init_constructor_array (type, init, nested, complain);\n+    picflags = process_init_constructor_array (type, init, nested, flags,\n+\t\t\t\t\t       complain);\n   else if (TREE_CODE (type) == RECORD_TYPE)\n-    flags = process_init_constructor_record (type, init, nested, complain);\n+    picflags = process_init_constructor_record (type, init, nested, flags,\n+\t\t\t\t\t\tcomplain);\n   else if (TREE_CODE (type) == UNION_TYPE)\n-    flags = process_init_constructor_union (type, init, nested, complain);\n+    picflags = process_init_constructor_union (type, init, nested, flags,\n+\t\t\t\t\t       complain);\n   else\n     gcc_unreachable ();\n \n-  if (flags & PICFLAG_ERRONEOUS)\n+  if (picflags & PICFLAG_ERRONEOUS)\n     return error_mark_node;\n \n   TREE_TYPE (init) = type;\n   if (TREE_CODE (type) == ARRAY_TYPE && TYPE_DOMAIN (type) == NULL_TREE)\n     cp_complete_array_type (&TREE_TYPE (init), init, /*do_default=*/0);\n-  if (flags & PICFLAG_SIDE_EFFECTS)\n+  if (picflags & PICFLAG_SIDE_EFFECTS)\n     {\n       TREE_CONSTANT (init) = false;\n       TREE_SIDE_EFFECTS (init) = true;\n     }\n-  else if (flags & PICFLAG_NOT_ALL_CONSTANT)\n+  else if (picflags & PICFLAG_NOT_ALL_CONSTANT)\n     /* Make sure TREE_CONSTANT isn't set from build_constructor.  */\n     TREE_CONSTANT (init) = false;\n   else\n     {\n       TREE_CONSTANT (init) = 1;\n-      if (!(flags & PICFLAG_NOT_ALL_SIMPLE))\n+      if (!(picflags & PICFLAG_NOT_ALL_SIMPLE))\n \tTREE_STATIC (init) = 1;\n     }\n   return init;"}, {"sha": "4bb56349adff891e7d2358fb37ce46ef70cc52c6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=08c35030c7ece1f7034d9bf7b6d3e94138ad3c68", "patch": "@@ -1,3 +1,22 @@\n+2019-01-07  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n+\n+\tPR c++/88261\n+\tPR c++/69338\n+\tPR c++/69696\n+\tPR c++/69697\n+\t* gcc.dg/array-6.c: Move from here ...\n+\t* c-c++-common/array-6.c: ... to here and add some more test coverage.\n+\t* g++.dg/pr69338.C: New test.\n+\t* g++.dg/pr69697.C: Likewise.\n+\t* g++.dg/ext/flexary32.C: Likewise.\n+\t* g++.dg/ext/flexary3.C: Adjust test.\n+\t* g++.dg/ext/flexary12.C: Likewise.\n+\t* g++.dg/ext/flexary13.C: Likewise.\n+\t* g++.dg/ext/flexary15.C: Likewise.\n+\t* g++.dg/warn/Wplacement-new-size-1.C: Likewise.\n+\t* g++.dg/warn/Wplacement-new-size-2.C: Likewise.\n+\t* g++.dg/warn/Wplacement-new-size-6.C: Likewise.\n+\n 2019-01-07  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* gcc.target/aarch64/subs_compare_2.c: Make '#' immediate prefix"}, {"sha": "f3f2eda4ae7d63e6af239cf3a85002f11b0d1398", "filename": "gcc/testsuite/c-c++-common/array-6.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Farray-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Farray-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Farray-6.c?ref=08c35030c7ece1f7034d9bf7b6d3e94138ad3c68", "patch": "@@ -0,0 +1,47 @@\n+/* PR c/5597 */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+/* Verify that GCC forbids non-static initialization of\n+   flexible array members. */\n+\n+struct str { int len; char s[]; };\n+\n+struct str a = { 2, \"a\" };\n+\n+void foo()\n+{\n+  static struct str b = { 2, \"b\" };\n+  struct str c = { 2, \"c\" }; /* { dg-error \"(non-static)|(near initialization)\" } */\n+  struct str d = (struct str) { 2, \"d\" }; /* { dg-error \"(non-static)|(near initialization)\" } */\n+  struct str e = (struct str) { d.len, \"e\" }; /* { dg-error \"(non-static)|(initialization)\" } */\n+}\n+\n+struct str f = { 0, {} };\n+\n+void bar()\n+{\n+  static struct str g = { 0, {} };\n+  struct str h = { 0, {} }; /* { dg-error \"(non-static)|(near initialization)\" } */\n+  struct str i = (struct str) { 0, {} }; /* { dg-error \"(non-static)|(near initialization)\" } */\n+  struct str j = (struct str) { i.len, {} }; /* { dg-error \"(non-static)|(initialization)\" } */\n+}\n+\n+struct str k = { 0 };\n+\n+void baz()\n+{\n+  static struct str l = { 0 };\n+  struct str m = { 0 };\n+  struct str n = (struct str) { 0 };\n+  struct str o = (struct str) { n.len };\n+}\n+\n+struct str p = {};\n+\n+void qux()\n+{\n+  static struct str q = {};\n+  struct str r = {};\n+  struct str s = (struct str) {};\n+}"}, {"sha": "b0964948731d8172fab1e27f655ab908ba750c1e", "filename": "gcc/testsuite/g++.dg/ext/flexary12.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary12.C?ref=08c35030c7ece1f7034d9bf7b6d3e94138ad3c68", "patch": "@@ -12,7 +12,7 @@ struct A {\n void f1 ()\n {\n   // This is the meat of the test from c++/69290:\n-  struct A a\n+  static struct A a\n     = { \"c\" };   // { dg-error \"invalid conversion from .const char\\\\*. to .int.\" }\n \n   (void)&a;\n@@ -27,13 +27,13 @@ struct B {\n \n void f2 ()\n {\n-  struct B b1\n+  static struct B b1\n     = { 0, \"c\" };   // { dg-error \"invalid conversion from .const char\\\\*. to .int.\" }\n \n   (void)&b1;\n \n   const char s[] = \"c\";\n-  struct B b2\n+  static struct B b2\n     = { 0, s };   // { dg-error \"invalid conversion from .const char\\\\*. to .int.\" }\n \n   (void)&b2;\n@@ -57,7 +57,7 @@ struct C {\n \n void f3 ()\n {\n-  struct C<double> cd\n+  static struct C<double> cd\n     = { \"c\" };   // { dg-error \"cannot convert .const char\\\\*. to .double.\" }\n \n   (void)&cd;"}, {"sha": "7c67d09ee5a7cedc37ea5b4ff04f8e44ba82af8a", "filename": "gcc/testsuite/g++.dg/ext/flexary13.C", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary13.C?ref=08c35030c7ece1f7034d9bf7b6d3e94138ad3c68", "patch": "@@ -19,33 +19,33 @@ int main ()\n     ASSERT (s.n == 0);\n   }\n   {\n-    Ax s =\n+    static Ax s =\n       { 0, { } };   // dg-warning \"initialization of a flexible array member\" }\n     ASSERT (s.n == 0);\n   }\n   {\n-    Ax s =\n+    static Ax s =\n       { 1, { 2 } };   // dg-warning \"initialization of a flexible array member\" }\n     ASSERT (s.n == 1 && s.a [0] == 2);\n   }\n   {\n-    Ax s =\n+    static Ax s =\n       { 2, { 3, 4 } }; // dg-warning \"initialization of a flexible array member\" }\n     ASSERT (s.n = 2 && s.a [0] == 3 && s.a [1] == 4);\n   }\n   {\n-    Ax s =\n+    static Ax s =\n       { 123, i };   // dg-warning \"initialization of a flexible array member\" }\n     ASSERT (s.n == 123 && s.a [0] == i);\n   }\n   {\n-    Ax s =\n+    static Ax s =\n       { 456, { i } }; // dg-warning \"initialization of a flexible array member\" }\n     ASSERT (s.n == 456 && s.a [0] == i);\n   }\n   {\n     int j = i + 1, k = j + 1;\n-    Ax s =\n+    static Ax s =\n       { 3, { i, j, k } }; // dg-warning \"initialization of a flexible array member\" }\n     ASSERT (s.n == 3 && s.a [0] == i && s.a [1] == j && s.a [2] == k);\n   }"}, {"sha": "da5f5f43123eca995eac464eb9c749df0f7e74ff", "filename": "gcc/testsuite/g++.dg/ext/flexary15.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary15.C?ref=08c35030c7ece1f7034d9bf7b6d3e94138ad3c68", "patch": "@@ -10,5 +10,5 @@ struct S {\n \n void foo (const char *a)\n {\n-  const S s = { 1, { a, \"b\" } };   // { dg-warning \"invalid conversion\" }\n+  static const S s = { 1, { a, \"b\" } };   // { dg-warning \"invalid conversion\" }\n }"}, {"sha": "34b17254f8cd381ec0c90025ab2e830b7f6ff7c3", "filename": "gcc/testsuite/g++.dg/ext/flexary3.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary3.C?ref=08c35030c7ece1f7034d9bf7b6d3e94138ad3c68", "patch": "@@ -17,5 +17,6 @@ struct s {\n int main()\n {\n     struct s s = { .c = 0 };\t// { dg-error \"initializer\" }\n+    // { dg-error \"non-static initialization of a flexible array member\" \"\" { target *-*-* } .-1 }\n     return 0;\n }"}, {"sha": "7ca78b19d36a2584848ae01e33bfe186d0ad0e24", "filename": "gcc/testsuite/g++.dg/ext/flexary32.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary32.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary32.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fflexary32.C?ref=08c35030c7ece1f7034d9bf7b6d3e94138ad3c68", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile { target c++11 } } */\n+/* { dg-options -Wno-pedantic } */\n+\n+struct str { int len; char s[]; };\n+\n+struct foo {\n+  str x = {3, {1,2,3}}; /* { dg-error \"(non-static)|(initialization)\" } */\n+  foo() {}\n+};\n+\n+struct bar {\n+  static constexpr str x = {3, {1,2,3}};\n+  bar() {}\n+};\n+\n+struct baz {\n+  str x = {3};\n+  baz() {}\n+};"}, {"sha": "8b1351b93d732f239d4fee55ec8a4b9e58829b8e", "filename": "gcc/testsuite/g++.dg/pr69338.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr69338.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr69338.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr69338.C?ref=08c35030c7ece1f7034d9bf7b6d3e94138ad3c68", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile { target c++11 } } */\n+/* { dg-additional-options \"-Wno-pedantic\" } */\n+\n+struct A { char i, a[]; };\n+\n+void foo()\n+{\n+  struct A a0 = { 3, \"AB\" };                /* { dg-error \"(non-static)|(initialization)\" } */\n+}\n+\n+struct A a1 = { 3, \"AB\" };                  /* { dg-bogus \"(non-static)|(initialization)\" } */\n+\n+struct A a2 = (struct A){ 3, \"AB\" };        /* { dg-error \"(non-static)|(initialization)\" } */\n+\n+struct B1 {\n+    A a3;\n+    B1 (): a3 { 3, \"AB\" } { }               /* { dg-error \"(non-static)|(initialization)\" } */\n+} b1;\n+\n+struct B2 {\n+    A a4;\n+    B2 (): a4 ((struct A){ 3, \"AB\" }) { }   /* { dg-error \"(non-static)|(initialization)\" } */\n+} b2;"}, {"sha": "b0b72365faa27ced05eacdf91da622fc52dea2f7", "filename": "gcc/testsuite/g++.dg/pr69697.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr69697.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr69697.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr69697.C?ref=08c35030c7ece1f7034d9bf7b6d3e94138ad3c68", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do compile { target c++11 } } */\n+/* { dg-additional-options \"-Wno-pedantic\" } */\n+\n+int i;\n+struct A { int n, a[]; }\n+  a = i ? A({ 1, { 2 } })     /* { dg-error \"(non-static)|(initialization)\" } */\n+        : A({ 2, { 3, 4 } }); /* { dg-error \"(non-static)|(initialization)\" } */"}, {"sha": "d2ec608afd4cee767d88513bd24b95f75701d109", "filename": "gcc/testsuite/g++.dg/warn/Wplacement-new-size-1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-1.C?ref=08c35030c7ece1f7034d9bf7b6d3e94138ad3c68", "patch": "@@ -28,7 +28,7 @@ void fAx (Ax *px, Ax &rx)\n \n void fAx2 ()\n {\n-  Ax ax2 = { 1, { 2, 3 } };\n+  static Ax ax2 = { 1, { 2, 3 } };\n \n   new (ax2.a) Int16;\n   new (ax2.a) Int32;    // { dg-warning \"placement\" }\n@@ -82,7 +82,7 @@ void fBx (BAx *pbx, BAx &rbx)\n \n void fBx1 ()\n {\n-  BAx bax1 = { 1, /* Ax = */ { 2, /* a[] = */ {} } };\n+  static BAx bax1 = { 1, /* Ax = */ { 2, /* a[] = */ {} } };\n \n   new (bax1.ax.a) char;\t    // { dg-warning \"placement\" }\n   new (bax1.ax.a) char[2];  // { dg-warning \"placement\" }"}, {"sha": "e00515eeaa959cc3f7891f1ac64a87769fc4c0f5", "filename": "gcc/testsuite/g++.dg/warn/Wplacement-new-size-2.C", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-2.C?ref=08c35030c7ece1f7034d9bf7b6d3e94138ad3c68", "patch": "@@ -33,13 +33,13 @@ void fAx (Ax *px, Ax &rx)\n void fAx2 ()\n {\n   // Initialization of non-static objects with flexible array members\n-  // isn't allowed in C and should perhaps be disallowed in C++ as\n+  // isn't allowed in C and had to be be disallowed in C++ as\n   // well to avoid c++/69696 - incorrect initialization of block-scope\n   // flexible array members.\n-  Ax ax2 = { 1, { 2, 3 } };\n+  Ax ax2 = { 1, { 2, 3 } };   // { dg-error \"non-static initialization of a flexible array member\" }\n \n-  new (ax2.a) Int16;\n-  new (ax2.a) Int16[1];\n+  new (ax2.a) Int16;          // { dg-warning \"placement\" }\n+  new (ax2.a) Int16[1];       // { dg-warning \"placement\" }\n   new (ax2.a) Int16[2];       // { dg-warning \"placement\" }\n   new (ax2.a) Int32;          // { dg-warning \"placement\" }\n   new (ax2.a) Int32[2];       // { dg-warning \"placement\" }\n@@ -140,7 +140,7 @@ void fBx (BAx *pbx, BAx &rbx)\n \n void fBx1 ()\n {\n-  BAx bax1 = { 1, /* Ax = */ { 2, /* a[] = */ {} } };\n+  static BAx bax1 = { 1, /* Ax = */ { 2, /* a[] = */ {} } };\n \n   new (bax1.ax.a) char;\t      // { dg-warning \"placement\" }\n   new (bax1.ax.a) char[2];    // { dg-warning \"placement\" }"}, {"sha": "b6a72b18f6a26f43085e0c42dd99517fef0fc724", "filename": "gcc/testsuite/g++.dg/warn/Wplacement-new-size-6.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c35030c7ece1f7034d9bf7b6d3e94138ad3c68/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-6.C?ref=08c35030c7ece1f7034d9bf7b6d3e94138ad3c68", "patch": "@@ -15,7 +15,7 @@ struct BAx { int i; Ax ax; };\n \n void fBx1 ()\n {\n-  BAx bax1 = { 1, /* Ax = */ { 2, /* a[] = */ { 3 } } };\t// { dg-error \"initialization of flexible array member in a nested context\" }\n+  static BAx bax1 = { 1, /* Ax = */ { 2, /* a[] = */ { 3 } } }; // { dg-error \"initialization of flexible array member in a nested context\" }\n \n   new (bax1.ax.a) char;     // { dg-warning \"placement\" }\n   new (bax1.ax.a) char[2];  // { dg-warning \"placement\" }\n@@ -25,7 +25,7 @@ void fBx1 ()\n \n void fBx2 ()\n {\n-  BAx bax2 = { 1, /* Ax = */ { 2, /* a[] = */ { 3, 4 } } };\t// { dg-error \"initialization of flexible array member in a nested context\" }\n+  static BAx bax2 = { 1, /* Ax = */ { 2, /* a[] = */ { 3, 4 } } }; // { dg-error \"initialization of flexible array member in a nested context\" }\n \n   new (bax2.ax.a) char;       // { dg-warning \"placement\" }\n   new (bax2.ax.a) char[2];    // { dg-warning \"placement\" }\n@@ -37,7 +37,7 @@ void fBx2 ()\n \n void fBx3 ()\n {\n-  BAx bax2 = { 1, /* Ax = */ { 3, /* a[] = */ { 4, 5, 6 } } };\t// { dg-error \"initialization of flexible array member in a nested context\" }\n+  static BAx bax2 = { 1, /* Ax = */ { 3, /* a[] = */ { 4, 5, 6 } } }; // { dg-error \"initialization of flexible array member in a nested context\" }\n \n   new (bax2.ax.a) char;       // { dg-warning \"placement\" }\n   new (bax2.ax.a) char[2];    // { dg-warning \"placement\" }"}, {"sha": "6ef64625b964ec73bed3203bd83fde3dfb723a6b", "filename": "gcc/testsuite/gcc.dg/array-6.c", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fd43b95264a7244b50fd34cf983f4d78c208dc/gcc%2Ftestsuite%2Fgcc.dg%2Farray-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fd43b95264a7244b50fd34cf983f4d78c208dc/gcc%2Ftestsuite%2Fgcc.dg%2Farray-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Farray-6.c?ref=18fd43b95264a7244b50fd34cf983f4d78c208dc", "patch": "@@ -1,18 +0,0 @@\n-/* PR c/5597 */\n-/* { dg-do compile } */\n-/* { dg-options \"\" } */\n-\n-/* Verify that GCC forbids non-static initialization of\n-   flexible array members. */\n-\n-struct str { int len; char s[]; };\n-\n-struct str a = { 2, \"a\" };\n-\n-void foo()\n-{\n-  static struct str b = { 2, \"b\" };\n-  struct str c = { 2, \"c\" }; /* { dg-error \"(non-static)|(near initialization)\" } */\n-  struct str d = (struct str) { 2, \"d\" }; /* { dg-error \"(non-static)|(near initialization)\" } */\n-  struct str e = (struct str) { d.len, \"e\" }; /* { dg-error \"(non-static)|(initialization)\" } */\n-}"}]}