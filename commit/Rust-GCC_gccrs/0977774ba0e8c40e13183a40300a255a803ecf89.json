{"sha": "0977774ba0e8c40e13183a40300a255a803ecf89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk3Nzc3NGJhMGU4YzQwZTEzMTgzYTQwMzAwYTI1NWE4MDNlY2Y4OQ==", "commit": {"author": {"name": "Jason Thorpe", "email": "thorpej@gcc.gnu.org", "date": "2002-11-07T18:32:00Z"}, "committer": {"name": "Jason Thorpe", "email": "thorpej@gcc.gnu.org", "date": "2002-11-07T18:32:00Z"}, "message": "[multiple changes]\n\n2002-11-07  Jason Thorpe  <thorpej@wasabisystems.com>\n\n* config/arm/arm-protos.h (arm_get_frame_size)\n(thumb_get_frame_size): New prototypes.\n* config/arm/arm.c (arm_get_frame_size)\n(thumb_get_frame_size): New functions.\n(use_return_insn, arm_output_epilogue, arm_output_function_epilogue)\n(arm_compute_initial_elimination_offset, arm_expand_prologue): Use\narm_get_frame_size.\n(thumb_expand_prologue, thumb_expand_epilogue): Use\nthumb_get_frame_size.\n* config/arm/arm.h (PREFERRED_STACK_BOUNDARY): Define.\n(machine_function): Add frame_size member.\n(THUMB_INITIAL_ELIMINATION_OFFSET): Use thumb_get_frame_size.\n\n2002-11-07  Richard Earnshaw  <rearnsha@arm.com>\n\n* arm.c (bit_count): Make argument unsigned long.  Return unsigned.\nAdjust code to use portable unsigned bit manipulation.\n(insn_flags, tune_flags): Change type to unsigned.\n(struct processors): Make flags unsigned long.\n(arm_override_options): Change type of count and current_bit_count\nto unsigned.\n\nFrom-SVN: r58901", "tree": {"sha": "b440b7d0e8a2ef0a9d7bb246087b79a351005a5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b440b7d0e8a2ef0a9d7bb246087b79a351005a5d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0977774ba0e8c40e13183a40300a255a803ecf89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0977774ba0e8c40e13183a40300a255a803ecf89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0977774ba0e8c40e13183a40300a255a803ecf89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0977774ba0e8c40e13183a40300a255a803ecf89/comments", "author": null, "committer": null, "parents": [{"sha": "f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7"}], "stats": {"total": 189, "additions": 171, "deletions": 18}, "files": [{"sha": "c167ca56ed025e0383c03ebefaf8c179422209e3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0977774ba0e8c40e13183a40300a255a803ecf89/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0977774ba0e8c40e13183a40300a255a803ecf89/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0977774ba0e8c40e13183a40300a255a803ecf89", "patch": "@@ -1,3 +1,27 @@\n+2002-11-07  Jason Thorpe  <thorpej@wasabisystems.com>\n+  \n+\t* config/arm/arm-protos.h (arm_get_frame_size)\n+\t(thumb_get_frame_size): New prototypes.  \n+\t* config/arm/arm.c (arm_get_frame_size)\n+\t(thumb_get_frame_size): New functions.       \n+\t(use_return_insn, arm_output_epilogue, arm_output_function_epilogue) \n+\t(arm_compute_initial_elimination_offset, arm_expand_prologue): Use  \n+\tarm_get_frame_size.\n+\t(thumb_expand_prologue, thumb_expand_epilogue): Use\n+\tthumb_get_frame_size.\n+\t* config/arm/arm.h (PREFERRED_STACK_BOUNDARY): Define.\n+\t(machine_function): Add frame_size member.\n+\t(THUMB_INITIAL_ELIMINATION_OFFSET): Use thumb_get_frame_size.\n+\n+2002-11-07  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.c (bit_count): Make argument unsigned long.  Return unsigned.\n+\tAdjust code to use portable unsigned bit manipulation.\n+\t(insn_flags, tune_flags): Change type to unsigned.\n+\t(struct processors): Make flags unsigned long.\n+\t(arm_override_options): Change type of count and current_bit_count\n+\tto unsigned.\n+\n 2002-11-07  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm/elf.h (TYPE_OPERAND_FMT): Prefix type with %."}, {"sha": "671fe9d3820081c157f5061d55defebc145d449a", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0977774ba0e8c40e13183a40300a255a803ecf89/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0977774ba0e8c40e13183a40300a255a803ecf89/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=0977774ba0e8c40e13183a40300a255a803ecf89", "patch": "@@ -31,6 +31,7 @@ extern void   arm_finalize_pic\t\tPARAMS ((int));\n extern int    arm_volatile_func\t\tPARAMS ((void));\n extern const char * arm_output_epilogue\tPARAMS ((int));\n extern void   arm_expand_prologue\tPARAMS ((void));\n+extern HOST_WIDE_INT arm_get_frame_size\tPARAMS ((void));\n /* Used in arm.md, but defined in output.c.  */\n extern void   assemble_align\t\tPARAMS ((int)); \n extern const char * arm_strip_name_encoding\tPARAMS ((const char *));\n@@ -160,6 +161,7 @@ extern int    arm_float_words_big_endian PARAMS ((void));\n extern void   arm_init_expanders\tPARAMS ((void));\n extern int    thumb_far_jump_used_p\tPARAMS ((int));\n extern const char * thumb_unexpanded_epilogue\tPARAMS ((void));\n+extern HOST_WIDE_INT thumb_get_frame_size PARAMS ((void));\n extern void   thumb_expand_prologue\tPARAMS ((void));\n extern void   thumb_expand_epilogue\tPARAMS ((void));\n #ifdef TREE_CODE"}, {"sha": "a51b95c57d1b74795bc17d7053f77778f43f0cb0", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 140, "deletions": 17, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0977774ba0e8c40e13183a40300a255a803ecf89/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0977774ba0e8c40e13183a40300a255a803ecf89/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=0977774ba0e8c40e13183a40300a255a803ecf89", "patch": "@@ -65,7 +65,7 @@ const struct attribute_spec arm_attribute_table[];\n /* Forward function declarations.  */\n static void      arm_add_gc_roots \t\tPARAMS ((void));\n static int       arm_gen_constant\t\tPARAMS ((enum rtx_code, Mmode, Hint, rtx, rtx, int, int));\n-static Ulong     bit_count \t\t\tPARAMS ((signed int));\n+static unsigned  bit_count \t\t\tPARAMS ((Ulong));\n static int       const_ok_for_op \t\tPARAMS ((Hint, enum rtx_code));\n static int       eliminate_lr2ip\t\tPARAMS ((rtx *));\n static rtx\t emit_multi_reg_push\t\tPARAMS ((int));\n@@ -246,13 +246,13 @@ int    arm_structure_size_boundary = DEFAULT_STRUCTURE_SIZE_BOUNDARY;\n \n /* The bits in this mask specify which\n    instructions we are allowed to generate.  */\n-static int insn_flags = 0;\n+static unsigned long insn_flags = 0;\n \n /* The bits in this mask specify which instruction scheduling options should\n    be used.  Note - there is an overlap with the FL_FAST_MULT.  For some\n    hardware we want to be able to generate the multiply instructions, but to\n    tune as if they were not present in the architecture.  */\n-static int tune_flags = 0;\n+static unsigned long tune_flags = 0;\n \n /* The following are used in the arm.md file as equivalents to bits\n    in the above two flag variables.  */\n@@ -324,7 +324,7 @@ static const char * const arm_condition_codes[] =\n struct processors\n {\n   const char *const name;\n-  const unsigned int flags;\n+  const unsigned long flags;\n };\n \n /* Not all of these give usefully different compilation alternatives,\n@@ -412,17 +412,17 @@ struct arm_cpu_select arm_select[] =\n   { NULL,\t\"-mtune=\",\tall_cores }\n };\n \n-/* Return the number of bits set in value' */\n-static unsigned long\n+/* Return the number of bits set in VALUE.  */\n+static unsigned\n bit_count (value)\n-     signed int value;\n+     unsigned long value;\n {\n   unsigned long count = 0;\n   \n   while (value)\n     {\n-      value &= ~(value & -value);\n-      ++count;\n+      count++;\n+      value &= value - 1;  /* Clear the least-significant set bit.  */\n     }\n \n   return count;\n@@ -549,7 +549,7 @@ arm_override_options ()\n \n \t  if (sel->name == NULL)\n \t    {\n-\t      unsigned int        current_bit_count = 0;\n+\t      unsigned current_bit_count = 0;\n \t      const struct processors * best_fit = NULL;\n \t      \n \t      /* Ideally we would like to issue an error message here\n@@ -568,7 +568,7 @@ arm_override_options ()\n \t      for (sel = all_cores; sel->name != NULL; sel++)\n \t\tif ((sel->flags & sought) == sought)\n \t\t  {\n-\t\t    unsigned int count;\n+\t\t    unsigned count;\n \n \t\t    count = bit_count (sel->flags & insn_flags);\n \n@@ -928,7 +928,7 @@ use_return_insn (iscond)\n       /* Of if the function calls __builtin_eh_return () */\n       || ARM_FUNC_TYPE (func_type) == ARM_FT_EXCEPTION_HANDLER\n       /* Or if there is no frame pointer and there is a stack adjustment.  */\n-      || ((get_frame_size () + current_function_outgoing_args_size != 0)\n+      || ((arm_get_frame_size () + current_function_outgoing_args_size != 0)\n \t  && !frame_pointer_needed))\n     return 0;\n \n@@ -7564,7 +7564,7 @@ arm_output_epilogue (really_return)\n      frame that is $fp + 4 for a non-variadic function.  */\n   int floats_offset = 0;\n   rtx operands[3];\n-  int frame_size = get_frame_size ();\n+  int frame_size = arm_get_frame_size ();\n   FILE * f = asm_out_file;\n   rtx eh_ofs = cfun->machine->eh_epilogue_sp_ofs;\n \n@@ -7846,6 +7846,9 @@ arm_output_function_epilogue (file, frame_size)\n     }\n   else\n     {\n+      /* We need to take into account any stack-frame rounding.  */\n+      frame_size = arm_get_frame_size ();\n+\n       if (use_return_insn (FALSE)\n \t  && return_used_this_function\n \t  && (frame_size + current_function_outgoing_args_size) != 0\n@@ -8088,7 +8091,7 @@ arm_compute_initial_elimination_offset (from, to)\n      unsigned int from;\n      unsigned int to;\n {\n-  unsigned int local_vars    = (get_frame_size () + 3) & ~3;\n+  unsigned int local_vars    = arm_get_frame_size ();\n   unsigned int outgoing_args = current_function_outgoing_args_size;\n   unsigned int stack_frame;\n   unsigned int call_saved_registers;\n@@ -8209,6 +8212,51 @@ arm_compute_initial_elimination_offset (from, to)\n     }\n }\n \n+/* Calculate the size of the stack frame, taking into account any\n+   padding that is required to ensure stack-alignment.  */\n+\n+HOST_WIDE_INT\n+arm_get_frame_size ()\n+{\n+  int regno;\n+\n+  int base_size = ROUND_UP (get_frame_size ());\n+  int entry_size = 0;\n+  unsigned long func_type = arm_current_func_type ();\n+\n+  if (! TARGET_ARM)\n+    abort();\n+\n+  if (! TARGET_ATPCS)\n+    return base_size;\n+\n+  /* We know that SP will be word aligned on entry, and we must\n+     preserve that condition at any subroutine call.  But those are\n+     the only constraints.  */\n+\n+  /* Space for variadic functions.  */\n+  if (current_function_pretend_args_size)\n+    entry_size += current_function_pretend_args_size;\n+\n+  /* Space for saved registers.  */\n+  entry_size += bit_count (arm_compute_save_reg_mask ()) * 4;\n+\n+  /* Space for saved FPA registers.  */\n+  if (! IS_VOLATILE (func_type))\n+    {\n+      for (regno = FIRST_ARM_FP_REGNUM; regno <= LAST_ARM_FP_REGNUM; regno++)\n+      if (regs_ever_live[regno] && ! call_used_regs[regno])\n+\tentry_size += 12;\n+    }\n+\n+  if ((entry_size + base_size + current_function_outgoing_args_size) & 7)\n+    base_size += 4;\n+  if ((entry_size + base_size + current_function_outgoing_args_size) & 7)\n+    abort ();\n+\n+  return base_size;\n+}\n+\n /* Generate the prologue instructions for entry into an ARM function.  */\n \n void\n@@ -8444,7 +8492,7 @@ arm_expand_prologue ()\n \t}\n     }\n \n-  amount = GEN_INT (-(get_frame_size ()\n+  amount = GEN_INT (-(arm_get_frame_size ()\n \t\t      + current_function_outgoing_args_size));\n \n   if (amount != const0_rtx)\n@@ -10193,12 +10241,87 @@ arm_init_expanders ()\n   init_machine_status = arm_init_machine_status;\n }\n \n+HOST_WIDE_INT\n+thumb_get_frame_size ()\n+{\n+  int regno;\n+\n+  int base_size = ROUND_UP (get_frame_size ());\n+  int count_regs = 0;\n+  int entry_size = 0;\n+\n+  if (! TARGET_THUMB)\n+    abort ();\n+\n+  if (! TARGET_ATPCS)\n+    return base_size;\n+\n+  /* We need to know if we are a leaf function.  Unfortunately, it\n+     is possible to be called after start_sequence has been called,\n+     which causes get_insns to return the insns for the sequence,\n+     not the function, which will cause leaf_function_p to return\n+     the incorrect result.\n+\n+     To work around this, we cache the computed frame size.  This\n+     works because we will only be calling RTL expanders that need\n+     to know about leaf functions once reload has completed, and the\n+     frame size cannot be changed after that time, so we can safely\n+     use the cached value.  */\n+\n+  if (reload_completed)\n+    return cfun->machine->frame_size;\n+\n+  /* We know that SP will be word aligned on entry, and we must\n+     preserve that condition at any subroutine call.  But those are\n+     the only constraints.  */\n+\n+  /* Space for variadic functions.  */\n+  if (current_function_pretend_args_size)\n+    entry_size += current_function_pretend_args_size;\n+\n+  /* Space for pushed lo registers.  */\n+  for (regno = 0; regno <= LAST_LO_REGNUM; regno++)\n+    if (THUMB_REG_PUSHED_P (regno))\n+      count_regs++;\n+\n+  /* Space for backtrace structure.  */\n+  if (TARGET_BACKTRACE)\n+    {\n+      if (count_regs == 0 && regs_ever_live[LAST_ARG_REGNUM] != 0)\n+\tentry_size += 20;\n+      else\n+\tentry_size += 16;\n+    }\n+\n+  if (count_regs || !leaf_function_p () || thumb_far_jump_used_p (1))\n+    count_regs++;\t/* LR */\n+\n+  entry_size += count_regs * 4;\n+  count_regs = 0;\n+\n+  /* Space for pushed hi regs.  */\n+  for (regno = 8; regno < 13; regno++)\n+    if (THUMB_REG_PUSHED_P (regno))\n+      count_regs++;\n+\n+  entry_size += count_regs * 4;\n+\n+  if ((entry_size + base_size + current_function_outgoing_args_size) & 7)\n+    base_size += 4;\n+  if ((entry_size + base_size + current_function_outgoing_args_size) & 7)\n+    abort ();\n+\n+  cfun->machine->frame_size = base_size;\n+\n+  return base_size;\n+}\n+\n /* Generate the rest of a function's prologue.  */\n \n void\n thumb_expand_prologue ()\n {\n-  HOST_WIDE_INT amount = (get_frame_size ()\n+  HOST_WIDE_INT amount = (thumb_get_frame_size ()\n \t\t\t  + current_function_outgoing_args_size);\n   unsigned long func_type;\n \n@@ -10293,7 +10416,7 @@ thumb_expand_prologue ()\n void\n thumb_expand_epilogue ()\n {\n-  HOST_WIDE_INT amount = (get_frame_size ()\n+  HOST_WIDE_INT amount = (thumb_get_frame_size ()\n \t\t\t  + current_function_outgoing_args_size);\n   \n   /* Naked functions don't have prologues.  */"}, {"sha": "13da6f701feaa994966b9690ed3220c7bb862ad0", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0977774ba0e8c40e13183a40300a255a803ecf89/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0977774ba0e8c40e13183a40300a255a803ecf89/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=0977774ba0e8c40e13183a40300a255a803ecf89", "patch": "@@ -689,6 +689,8 @@ extern int arm_is_6_or_7;\n \n #define STACK_BOUNDARY  32\n \n+#define PREFERRED_STACK_BOUNDARY (TARGET_ATPCS ? 64 : 32)\n+\n #define FUNCTION_BOUNDARY  32\n \n /* The lowest bit is used to indicate Thumb-mode functions, so the\n@@ -1436,6 +1438,8 @@ typedef struct machine_function GTY(())\n   int arg_pointer_live;\n   /* Records if the save of LR has been eliminated.  */\n   int lr_save_eliminated;\n+  /* The size of the stack frame.  Only valid after reload.  */\n+  int frame_size;\n   /* Records the type of the current function.  */\n   unsigned long func_type;\n   /* Record if the function has a variable argument list.  */\n@@ -1679,7 +1683,7 @@ typedef struct\n   if ((TO) == STACK_POINTER_REGNUM)\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       (OFFSET) += current_function_outgoing_args_size;\t\t\t\\\n-      (OFFSET) += ROUND_UP (get_frame_size ());\t\t\t\t\\\n+      (OFFSET) += thumb_get_frame_size ();\t\t\t\t\\\n      }\t\t\t\t\t\t\t\t\t\\\n }\n "}]}