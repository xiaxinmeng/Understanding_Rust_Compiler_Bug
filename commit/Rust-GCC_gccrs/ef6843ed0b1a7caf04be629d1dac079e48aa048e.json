{"sha": "ef6843ed0b1a7caf04be629d1dac079e48aa048e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWY2ODQzZWQwYjFhN2NhZjA0YmU2MjlkMWRhYzA3OWU0OGFhMDQ4ZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2006-04-11T16:25:46Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2006-04-11T16:25:46Z"}, "message": "sparc.c (function_arg_slotno): Handle aggregate types other than record and union types.\n\n\t* config/sparc/sparc.c (function_arg_slotno) <BLKmode>: Handle\n\taggregate types other than record and union types.\n\t(function_arg): Likewise.\n\t(function_arg_pass_by_reference): In 64-bit mode, return 0 for\n\tsmall arrays.\n\t(function_value): In 64-bit mode, return objects that require it\n\tin FP registers.\n\nFrom-SVN: r112859", "tree": {"sha": "473c6698ddb98834e8855bb71655e69829762bc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/473c6698ddb98834e8855bb71655e69829762bc1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef6843ed0b1a7caf04be629d1dac079e48aa048e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef6843ed0b1a7caf04be629d1dac079e48aa048e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef6843ed0b1a7caf04be629d1dac079e48aa048e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef6843ed0b1a7caf04be629d1dac079e48aa048e/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "20cbfac4e95d090a361db413209a1545ca058342", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20cbfac4e95d090a361db413209a1545ca058342", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20cbfac4e95d090a361db413209a1545ca058342"}], "stats": {"total": 158, "additions": 86, "deletions": 72}, "files": [{"sha": "0cf5ae0d1e58b6a4baab018e27d0e12eca6cfc9c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef6843ed0b1a7caf04be629d1dac079e48aa048e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef6843ed0b1a7caf04be629d1dac079e48aa048e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ef6843ed0b1a7caf04be629d1dac079e48aa048e", "patch": "@@ -1,3 +1,13 @@\n+2006-04-11  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\t* config/sparc/sparc.c (function_arg_slotno) <BLKmode>: Handle\n+\taggregate types other than record and union types.\n+\t(function_arg): Likewise.\n+\t(function_arg_pass_by_reference): In 64-bit mode, return 0 for\n+\tsmall arrays.\n+\t(function_value): In 64-bit mode, return objects that require it\n+\tin FP registers.\n+\n 2006-04-11  Roger Sayle  <roger@eyesopen.com>\n \n \t* dwarf2out.c (premark_used_types): Remove problematic prototype."}, {"sha": "578f91668b1c5db44655b69a34d7ae116fe0d37d", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 76, "deletions": 72, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef6843ed0b1a7caf04be629d1dac079e48aa048e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef6843ed0b1a7caf04be629d1dac079e48aa048e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=ef6843ed0b1a7caf04be629d1dac079e48aa048e", "patch": "@@ -4559,7 +4559,10 @@ function_arg_slotno (const struct sparc_args *cum, enum machine_mode mode,\n \n       gcc_assert (mode == BLKmode);\n \n-      if (TARGET_ARCH32 || !type || (TREE_CODE (type) == UNION_TYPE))\n+      if (TARGET_ARCH32\n+\t  || !type\n+\t  || (TREE_CODE (type) != VECTOR_TYPE\n+\t      && TREE_CODE (type) != RECORD_TYPE))\n \t{\n \t  if (slotno >= SPARC_INT_ARG_MAX)\n \t    return -1;\n@@ -5073,62 +5076,58 @@ function_arg (const struct sparc_args *cum, enum machine_mode mode,\n \t\t : SPARC_OUTGOING_INT_ARG_FIRST);\n   int slotno, regno, padding;\n   enum mode_class mclass = GET_MODE_CLASS (mode);\n-  rtx reg;\n \n   slotno = function_arg_slotno (cum, mode, type, named, incoming_p,\n \t\t\t\t&regno, &padding);\n-\n   if (slotno == -1)\n     return 0;\n \n-  if (TARGET_ARCH32)\n+  /* Vector types deserve special treatment because they are polymorphic wrt\n+     their mode, depending upon whether VIS instructions are enabled.  */\n+  if (type && TREE_CODE (type) == VECTOR_TYPE)\n     {\n-      reg = gen_rtx_REG (mode, regno);\n-      return reg;\n+      HOST_WIDE_INT size = int_size_in_bytes (type);\n+      gcc_assert ((TARGET_ARCH32 && size <= 8)\n+\t\t  || (TARGET_ARCH64 && size <= 16));\n+\n+      if (mode == BLKmode)\n+\treturn function_arg_vector_value (size,\n+\t\t\t\t\t  TYPE_MODE (TREE_TYPE (type)),\n+\t\t\t\t\t  SPARC_FP_ARG_FIRST + 2*slotno);\n+      else\n+\tmclass = MODE_FLOAT;\n     }\n-    \n-  if (type && TREE_CODE (type) == RECORD_TYPE)\n-    {\n-      /* Structures up to 16 bytes in size are passed in arg slots on the\n-\t stack and are promoted to registers where possible.  */\n \n-      gcc_assert (int_size_in_bytes (type) <= 16);\n+  if (TARGET_ARCH32)\n+    return gen_rtx_REG (mode, regno);\n \n-      return function_arg_record_value (type, mode, slotno, named, regbase);\n-    }\n-  else if (type && TREE_CODE (type) == UNION_TYPE)\n+  /* Structures up to 16 bytes in size are passed in arg slots on the stack\n+     and are promoted to registers if possible.  */\n+  if (type && TREE_CODE (type) == RECORD_TYPE)\n     {\n       HOST_WIDE_INT size = int_size_in_bytes (type);\n-\n       gcc_assert (size <= 16);\n \n-      return function_arg_union_value (size, mode, slotno, regno);\n+      return function_arg_record_value (type, mode, slotno, named, regbase);\n     }\n-  else if (type && TREE_CODE (type) == VECTOR_TYPE)\n+\n+  /* Unions up to 16 bytes in size are passed in integer registers.  */\n+  else if (type && TREE_CODE (type) == UNION_TYPE)\n     {\n-      /* Vector types deserve special treatment because they are\n-\t polymorphic wrt their mode, depending upon whether VIS\n-\t instructions are enabled.  */\n       HOST_WIDE_INT size = int_size_in_bytes (type);\n-\n       gcc_assert (size <= 16);\n \n-      if (mode == BLKmode)\n-\treturn function_arg_vector_value (size,\n-\t\t\t\t\t  TYPE_MODE (TREE_TYPE (type)),\n-\t\t\t\t\t  SPARC_FP_ARG_FIRST + 2*slotno);\n-      else\n-\tmclass = MODE_FLOAT;\n+      return function_arg_union_value (size, mode, slotno, regno);\n     }\n \n   /* v9 fp args in reg slots beyond the int reg slots get passed in regs\n      but also have the slot allocated for them.\n      If no prototype is in scope fp values in register slots get passed\n      in two places, either fp regs and int regs or fp regs and memory.  */\n-  if ((mclass == MODE_FLOAT || mclass == MODE_COMPLEX_FLOAT)\n-      && SPARC_FP_REG_P (regno))\n+  else if ((mclass == MODE_FLOAT || mclass == MODE_COMPLEX_FLOAT)\n+\t   && SPARC_FP_REG_P (regno))\n     {\n-      reg = gen_rtx_REG (mode, regno);\n+      rtx reg = gen_rtx_REG (mode, regno);\n       if (cum->prototype_p || cum->libcall_p)\n \t{\n \t  /* \"* 2\" because fp reg numbers are recorded in 4 byte\n@@ -5189,13 +5188,18 @@ function_arg (const struct sparc_args *cum, enum machine_mode mode,\n \t    }\n \t}\n     }\n-  else\n+\n+  /* All other aggregate types are passed in an integer register in a mode\n+     corresponding to the size of the type.  */\n+  else if (type && AGGREGATE_TYPE_P (type))\n     {\n-      /* Scalar or complex int.  */\n-      reg = gen_rtx_REG (mode, regno);\n+      HOST_WIDE_INT size = int_size_in_bytes (type);\n+      gcc_assert (size <= 16);\n+\n+      mode = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0);\n     }\n \n-  return reg;\n+  return gen_rtx_REG (mode, regno);\n }\n \n /* For an arg passed partly in registers and partly in memory,\n@@ -5271,7 +5275,6 @@ sparc_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n \t\t\t bool named ATTRIBUTE_UNUSED)\n {\n   if (TARGET_ARCH32)\n-    {\n     /* Original SPARC 32-bit ABI says that structures and unions,\n        and quad-precision floats are passed by reference.  For Pascal,\n        also pass arrays by reference.  All other base types are passed\n@@ -5286,19 +5289,17 @@ sparc_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n        integers are passed like floats of the same size, that is in\n        registers up to 8 bytes.  Pass all vector floats by reference\n        like structure and unions.  */\n-      return ((type && (AGGREGATE_TYPE_P (type) || VECTOR_FLOAT_TYPE_P (type)))\n-\t      || mode == SCmode\n-\t      /* Catch CDImode, TFmode, DCmode and TCmode.  */\n-\t      || GET_MODE_SIZE (mode) > 8\n-\t      || (type\n-\t\t  && TREE_CODE (type) == VECTOR_TYPE\n-\t\t  && (unsigned HOST_WIDE_INT) int_size_in_bytes (type) > 8));\n-    }\n+    return ((type && (AGGREGATE_TYPE_P (type) || VECTOR_FLOAT_TYPE_P (type)))\n+\t    || mode == SCmode\n+\t    /* Catch CDImode, TFmode, DCmode and TCmode.  */\n+\t    || GET_MODE_SIZE (mode) > 8\n+\t    || (type\n+\t\t&& TREE_CODE (type) == VECTOR_TYPE\n+\t\t&& (unsigned HOST_WIDE_INT) int_size_in_bytes (type) > 8));\n   else\n-    {\n     /* Original SPARC 64-bit ABI says that structures and unions\n        smaller than 16 bytes are passed in registers, as well as\n-       all other base types.  For Pascal, pass arrays by reference.\n+       all other base types.\n        \n        Extended ABI (as implemented by the Sun compiler) says that\n        complex floats are passed in registers up to 16 bytes.  Pass\n@@ -5309,13 +5310,11 @@ sparc_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n        integers are passed like floats of the same size, that is in\n        registers (up to 16 bytes).  Pass all vector floats like structure\n        and unions.  */\n-      return ((type && TREE_CODE (type) == ARRAY_TYPE)\n-\t      || (type\n-\t\t  && (AGGREGATE_TYPE_P (type) || TREE_CODE (type) == VECTOR_TYPE)\n-\t\t  && (unsigned HOST_WIDE_INT) int_size_in_bytes (type) > 16)\n-\t      /* Catch CTImode and TCmode.  */\n-\t      || GET_MODE_SIZE (mode) > 16);\n-    }\n+    return ((type\n+\t     && (AGGREGATE_TYPE_P (type) || TREE_CODE (type) == VECTOR_TYPE)\n+\t     && (unsigned HOST_WIDE_INT) int_size_in_bytes (type) > 16)\n+\t    /* Catch CTImode and TCmode.  */\n+\t    || GET_MODE_SIZE (mode) > 16);\n }\n \n /* Handle the FUNCTION_ARG_ADVANCE macro.\n@@ -5499,13 +5498,11 @@ function_value (tree type, enum machine_mode mode, int incoming_p)\n   enum mode_class mclass = GET_MODE_CLASS (mode);\n   int regno;\n \n+  /* Vector types deserve special treatment because they are polymorphic wrt\n+     their mode, depending upon whether VIS instructions are enabled.  */\n   if (type && TREE_CODE (type) == VECTOR_TYPE)\n     {\n-      /* Vector types deserve special treatment because they are\n-\t polymorphic wrt their mode, depending upon whether VIS\n-\t instructions are enabled.  */\n       HOST_WIDE_INT size = int_size_in_bytes (type);\n-\n       gcc_assert ((TARGET_ARCH32 && size <= 8)\n \t\t  || (TARGET_ARCH64 && size <= 32));\n \n@@ -5516,34 +5513,41 @@ function_value (tree type, enum machine_mode mode, int incoming_p)\n       else\n \tmclass = MODE_FLOAT;\n     }\n-  else if (type && TARGET_ARCH64)\n+\n+  if (TARGET_ARCH64 && type)\n     {\n+      /* Structures up to 32 bytes in size are returned in registers.  */\n       if (TREE_CODE (type) == RECORD_TYPE)\n \t{\n-\t  /* Structures up to 32 bytes in size are passed in registers,\n-\t     promoted to fp registers where possible.  */\n-\n-\t  gcc_assert (int_size_in_bytes (type) <= 32);\n+\t  HOST_WIDE_INT size = int_size_in_bytes (type);\n+\t  gcc_assert (size <= 32);\n \n \t  return function_arg_record_value (type, mode, 0, 1, regbase);\n \t}\n+\n+      /* Unions up to 32 bytes in size are returned in integer registers.  */\n       else if (TREE_CODE (type) == UNION_TYPE)\n \t{\n \t  HOST_WIDE_INT size = int_size_in_bytes (type);\n-\n \t  gcc_assert (size <= 32);\n \n \t  return function_arg_union_value (size, mode, 0, regbase);\n \t}\n+\n+      /* Objects that require it are returned in FP registers.  */\n+      else if (mclass == MODE_FLOAT || mclass == MODE_COMPLEX_FLOAT)\n+\t;\n+\n+      /* All other aggregate types are returned in an integer register in a\n+\t mode corresponding to the size of the type.  */\n       else if (AGGREGATE_TYPE_P (type))\n \t{\n \t  /* All other aggregate types are passed in an integer register\n \t     in a mode corresponding to the size of the type.  */\n-\t  HOST_WIDE_INT bytes = int_size_in_bytes (type);\n-\n-\t  gcc_assert (bytes <= 32);\n+\t  HOST_WIDE_INT size = int_size_in_bytes (type);\n+\t  gcc_assert (size <= 32);\n \n-\t  mode = mode_for_size (bytes * BITS_PER_UNIT, MODE_INT, 0);\n+\t  mode = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0);\n \n \t  /* ??? We probably should have made the same ABI change in\n \t     3.4.0 as the one we made for unions.   The latter was\n@@ -5555,17 +5559,17 @@ function_value (tree type, enum machine_mode mode, int incoming_p)\n \t     try to be unduly clever, and simply follow the ABI\n \t     for unions in that case.  */\n \t  if (mode == BLKmode)\n-\t    return function_arg_union_value (bytes, mode, 0, regbase);\n+\t    return function_arg_union_value (size, mode, 0, regbase);\n \t  else\n \t    mclass = MODE_INT;\n \t}\n-      else if (mclass == MODE_INT\n-\t       && GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n+\n+      /* This must match PROMOTE_FUNCTION_MODE.  */\n+      else if (mclass == MODE_INT && GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n \tmode = word_mode;\n     }\n \n-  if ((mclass == MODE_FLOAT || mclass == MODE_COMPLEX_FLOAT)\n-      && TARGET_FPU)\n+  if ((mclass == MODE_FLOAT || mclass == MODE_COMPLEX_FLOAT) && TARGET_FPU)\n     regno = SPARC_FP_ARG_FIRST;\n   else\n     regno = regbase;"}]}