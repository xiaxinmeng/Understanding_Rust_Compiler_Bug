{"sha": "e54a38e86b29eb062545ed30ab0bda6ebd4c9c33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU0YTM4ZTg2YjI5ZWIwNjI1NDVlZDMwYWIwYmRhNmViZDRjOWMzMw==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2016-04-28T12:07:04Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2016-04-28T12:07:04Z"}, "message": "i386.md (*fop_<mode>_1_mixed): Do not check for mult_operator when calculating \"type\" attribute.\n\n\t* config/i386/i386.md (*fop_<mode>_1_mixed): Do not check for\n\tmult_operator when calculating \"type\" attribute.\n\t(*fop_<mode>_1_i387): Ditto.\n\t(*fop_xf_1_i387): Ditto.\n\t(x87 stack loads peephole2): Add \"reg = op (mem, reg)\" peephole2.\n\tUse std::swap to swap operands.  Use RTL expressions to generate\n\tconverted pattern.\n\nFrom-SVN: r235561", "tree": {"sha": "045417cee542f2a220747d70ef89aabb93226257", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/045417cee542f2a220747d70ef89aabb93226257"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e54a38e86b29eb062545ed30ab0bda6ebd4c9c33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e54a38e86b29eb062545ed30ab0bda6ebd4c9c33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e54a38e86b29eb062545ed30ab0bda6ebd4c9c33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e54a38e86b29eb062545ed30ab0bda6ebd4c9c33/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4877829bff4a8655ff3882986e6c7a20e5c3a9b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4877829bff4a8655ff3882986e6c7a20e5c3a9b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4877829bff4a8655ff3882986e6c7a20e5c3a9b6"}], "stats": {"total": 98, "additions": 57, "deletions": 41}, "files": [{"sha": "bfe7b833a49aa76efbf95d8894a81828bda27633", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e54a38e86b29eb062545ed30ab0bda6ebd4c9c33/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e54a38e86b29eb062545ed30ab0bda6ebd4c9c33/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e54a38e86b29eb062545ed30ab0bda6ebd4c9c33", "patch": "@@ -1,3 +1,13 @@\n+2016-04-28  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.md (*fop_<mode>_1_mixed): Do not check for\n+\tmult_operator when calculating \"type\" attribute.\n+\t(*fop_<mode>_1_i387): Ditto.\n+\t(*fop_xf_1_i387): Ditto.\n+\t(x87 stack loads peephole2): Add \"reg = op (mem, reg)\" peephole2.\n+\tUse std::swap to swap operands.  Use RTL expressions to generate\n+\tconverted pattern.\n+\n 2016-04-28  Claudiu Zissulescu  <claziss@synopsys.com>\n \t    Joern Rennecke  <joern.rennecke@embecosm.com>\n "}, {"sha": "b19bc93505e58ceef62eb81d91649f5500306c53", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 47, "deletions": 41, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e54a38e86b29eb062545ed30ab0bda6ebd4c9c33/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e54a38e86b29eb062545ed30ab0bda6ebd4c9c33/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=e54a38e86b29eb062545ed30ab0bda6ebd4c9c33", "patch": "@@ -14055,20 +14055,13 @@\n    && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\")\n-        (cond [(and (eq_attr \"alternative\" \"2,3\")\n-\t            (match_operand:MODEF 3 \"mult_operator\"))\n-                 (const_string \"ssemul\")\n-\t       (and (eq_attr \"alternative\" \"2,3\")\n-\t            (match_operand:MODEF 3 \"div_operator\"))\n-                 (const_string \"ssediv\")\n-\t       (eq_attr \"alternative\" \"2,3\")\n-                 (const_string \"sseadd\")\n-\t       (match_operand:MODEF 3 \"mult_operator\")\n-                 (const_string \"fmul\")\n-               (match_operand:MODEF 3 \"div_operator\")\n-                 (const_string \"fdiv\")\n-              ]\n-              (const_string \"fop\")))\n+\t(if_then_else (eq_attr \"alternative\" \"2,3\")\n+\t   (if_then_else (match_operand:MODEF 3 \"div_operator\")\n+\t      (const_string \"ssediv\")\n+\t      (const_string \"sseadd\"))\n+\t   (if_then_else (match_operand:MODEF 3 \"div_operator\")\n+\t      (const_string \"fdiv\")\n+\t      (const_string \"fop\"))))\n    (set_attr \"isa\" \"*,*,noavx,avx\")\n    (set_attr \"prefix\" \"orig,orig,orig,vex\")\n    (set_attr \"mode\" \"<MODE>\")\n@@ -14090,12 +14083,9 @@\n    && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\")\n-        (cond [(match_operand:MODEF 3 \"mult_operator\")\n-                 (const_string \"fmul\")\n-               (match_operand:MODEF 3 \"div_operator\")\n-                 (const_string \"fdiv\")\n-              ]\n-              (const_string \"fop\")))\n+        (if_then_else (match_operand:MODEF 3 \"div_operator\")\n+           (const_string \"fdiv\")\n+           (const_string \"fop\")))\n    (set_attr \"mode\" \"<MODE>\")])\n \n ;; ??? Add SSE splitters for these!\n@@ -14109,7 +14099,7 @@\n    && !(SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH)\n    && (TARGET_USE_<SWI24:MODE>MODE_FIOP\n        || optimize_function_for_size_p (cfun))\"\n-  { return output_387_binary_op (insn, operands); }\n+  \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\")\n         (cond [(match_operand:MODEF 3 \"mult_operator\")\n                  (const_string \"fmul\")\n@@ -14130,7 +14120,7 @@\n    && !(SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH)\n    && (TARGET_USE_<SWI24:MODE>MODE_FIOP\n        || optimize_function_for_size_p (cfun))\"\n-  { return output_387_binary_op (insn, operands); }\n+  \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\")\n         (cond [(match_operand:MODEF 3 \"mult_operator\")\n                  (const_string \"fmul\")\n@@ -14220,12 +14210,9 @@\n    && !COMMUTATIVE_ARITH_P (operands[3])\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\")\n-        (cond [(match_operand:XF 3 \"mult_operator\")\n-                 (const_string \"fmul\")\n-               (match_operand:XF 3 \"div_operator\")\n-                 (const_string \"fdiv\")\n-              ]\n-              (const_string \"fop\")))\n+        (if_then_else (match_operand:XF 3 \"div_operator\")\n+           (const_string \"fdiv\")\n+           (const_string \"fop\")))\n    (set_attr \"mode\" \"XF\")])\n \n (define_insn \"*fop_xf_2_i387\"\n@@ -14236,7 +14223,7 @@\n \t   (match_operand:XF 2 \"register_operand\" \"0\")]))]\n   \"TARGET_80387\n    && (TARGET_USE_<MODE>MODE_FIOP || optimize_function_for_size_p (cfun))\"\n-  { return output_387_binary_op (insn, operands); }\n+  \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\")\n         (cond [(match_operand:XF 3 \"mult_operator\")\n                  (const_string \"fmul\")\n@@ -14255,7 +14242,7 @@\n \t     (match_operand:SWI24 2 \"nonimmediate_operand\" \"m\"))]))]\n   \"TARGET_80387\n    && (TARGET_USE_<MODE>MODE_FIOP || optimize_function_for_size_p (cfun))\"\n-  { return output_387_binary_op (insn, operands); }\n+  \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\")\n         (cond [(match_operand:XF 3 \"mult_operator\")\n                  (const_string \"fmul\")\n@@ -17394,6 +17381,7 @@\n ;;   fmul bb             fmul %st(1), %st\n ;;\n ;; Actually we only match the last two instructions for simplicity.\n+\n (define_peephole2\n   [(set (match_operand 0 \"fp_register_operand\")\n \t(match_operand 1 \"fp_register_operand\"))\n@@ -17403,21 +17391,39 @@\n \t    (match_operand 3 \"memory_operand\")]))]\n   \"REGNO (operands[0]) != REGNO (operands[1])\"\n   [(set (match_dup 0) (match_dup 3))\n-   (set (match_dup 0) (match_dup 4))]\n-\n-  ;; The % modifier is not operational anymore in peephole2's, so we have to\n-  ;; swap the operands manually in the case of addition and multiplication.\n+   (set (match_dup 0)\n+\t(match_op_dup 2\n+\t  [(match_dup 5) (match_dup 4)]))]\n {\n-  rtx op0, op1;\n+  operands[4] = operands[0];\n+  operands[5] = operands[1];\n \n+  /* The % modifier is not operational anymore in peephole2's, so we have to\n+     swap the operands manually in the case of addition and multiplication. */\n   if (COMMUTATIVE_ARITH_P (operands[2]))\n-    op0 = operands[0], op1 = operands[1];\n-  else\n-    op0 = operands[1], op1 = operands[0];\n+    std::swap (operands[4], operands[5]);\n+})\n \n-  operands[4] = gen_rtx_fmt_ee (GET_CODE (operands[2]),\n-\t\t\t\tGET_MODE (operands[2]),\n-\t\t\t\top0, op1);\n+(define_peephole2\n+  [(set (match_operand 0 \"fp_register_operand\")\n+\t(match_operand 1 \"fp_register_operand\"))\n+   (set (match_dup 0)\n+\t(match_operator 2 \"binary_fp_operator\"\n+\t   [(match_operand 3 \"memory_operand\")\n+\t    (match_dup 0)]))]\n+  \"REGNO (operands[0]) != REGNO (operands[1])\"\n+  [(set (match_dup 0) (match_dup 3))\n+   (set (match_dup 0)\n+\t(match_op_dup 2\n+\t  [(match_dup 4) (match_dup 5)]))]\n+{\n+  operands[4] = operands[0];\n+  operands[5] = operands[1];\n+\n+  /* The % modifier is not operational anymore in peephole2's, so we have to\n+     swap the operands manually in the case of addition and multiplication. */\n+  if (COMMUTATIVE_ARITH_P (operands[2]))\n+    std::swap (operands[4], operands[5]);\n })\n \n ;; Conditional addition patterns"}]}