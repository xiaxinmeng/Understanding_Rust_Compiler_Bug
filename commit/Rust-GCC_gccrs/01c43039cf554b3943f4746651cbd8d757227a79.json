{"sha": "01c43039cf554b3943f4746651cbd8d757227a79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFjNDMwMzljZjU1NGIzOTQzZjQ3NDY2NTFjYmQ4ZDc1NzIyN2E3OQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2003-12-03T10:02:28Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2003-12-03T10:02:28Z"}, "message": "gcse.c (reg_clear_last_set): New function.\n\n* gcse.c (reg_clear_last_set): New function.\n(reg_set_info): If data is non-null, treat it as an sbitmap of\nregisters, set the bit for the register being set.\n(compute_store_table): Allocate last_set_in with xcalloc.  Do not\nmemset this array on each iteration.  Pass reg_set_in_block[bb->index]\nto note_stores while computing last_set_in instead of scanning\nlast_set_in after the first pass through the insns.\nClear last_set_in using reg_clear_last_set instead of explicitly\nrescanning after each insn.  If checking is enabled, assert that\nlast_set_in is completely zeroed after each bb has been processed.\n\nFrom-SVN: r74224", "tree": {"sha": "78a32ee85afcae7c521c74c580db1d4c919b5e2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78a32ee85afcae7c521c74c580db1d4c919b5e2c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01c43039cf554b3943f4746651cbd8d757227a79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01c43039cf554b3943f4746651cbd8d757227a79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01c43039cf554b3943f4746651cbd8d757227a79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01c43039cf554b3943f4746651cbd8d757227a79/comments", "author": null, "committer": null, "parents": [{"sha": "817fe804cf6c8c2c6e87058096c12e565ad5cf36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/817fe804cf6c8c2c6e87058096c12e565ad5cf36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/817fe804cf6c8c2c6e87058096c12e565ad5cf36"}], "stats": {"total": 86, "additions": 71, "deletions": 15}, "files": [{"sha": "1a51101435b2dd394a445bd3c0bef0e813805da0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01c43039cf554b3943f4746651cbd8d757227a79/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01c43039cf554b3943f4746651cbd8d757227a79/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01c43039cf554b3943f4746651cbd8d757227a79", "patch": "@@ -1,3 +1,16 @@\n+2003-12-03  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* gcse.c (reg_clear_last_set): New function.\n+\t(reg_set_info): If data is non-null, treat it as an sbitmap of\n+\tregisters, set the bit for the register being set.\n+\t(compute_store_table): Allocate last_set_in with xcalloc.  Do not\n+\tmemset this array on each iteration.  Pass reg_set_in_block[bb->index]\n+\tto note_stores while computing last_set_in instead of scanning\n+\tlast_set_in after the first pass through the insns.\n+\tClear last_set_in using reg_clear_last_set instead of explicitly\n+\trescanning after each insn.  If checking is enabled, assert that\n+\tlast_set_in is completely zeroed after each bb has been processed.\n+\n 2003-12-02  Geoffrey Keating  <geoffk@geoffk.org>\n \n \t* df.c (df_uses_record) <MEM>: The argument of a MEM is read-only,"}, {"sha": "4481dc762149e9363400c4713c01f2e14ceabddc", "filename": "gcc/gcse.c", "status": "modified", "additions": 58, "deletions": 15, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01c43039cf554b3943f4746651cbd8d757227a79/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01c43039cf554b3943f4746651cbd8d757227a79/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=01c43039cf554b3943f4746651cbd8d757227a79", "patch": "@@ -679,6 +679,7 @@ static void compute_ld_motion_mems (void);\n static void trim_ld_motion_mems (void);\n static void update_ld_motion_stores (struct expr *);\n static void reg_set_info (rtx, rtx, void *);\n+static void reg_clear_last_set (rtx, rtx, void *);\n static bool store_ops_ok (rtx, int *);\n static rtx extract_mentioned_regs (rtx);\n static rtx extract_mentioned_regs_helper (rtx, rtx);\n@@ -6921,17 +6922,41 @@ static sbitmap * st_antloc;\n /* Global holding the number of store expressions we are dealing with.  */\n static int num_stores;\n \n-/* Checks to set if we need to mark a register set. Called from note_stores.  */\n+/* Checks to set if we need to mark a register set.  Called from\n+   note_stores.  */\n \n static void\n reg_set_info (rtx dest, rtx setter ATTRIBUTE_UNUSED,\n-\t      void *data ATTRIBUTE_UNUSED)\n+\t      void *data)\n {\n+  sbitmap bb_reg = data;\n+\n   if (GET_CODE (dest) == SUBREG)\n     dest = SUBREG_REG (dest);\n \n   if (GET_CODE (dest) == REG)\n-    regvec[REGNO (dest)] = INSN_UID (compute_store_table_current_insn);\n+    {\n+      regvec[REGNO (dest)] = INSN_UID (compute_store_table_current_insn);\n+      if (bb_reg)\n+\tSET_BIT (bb_reg, REGNO (dest));\n+    }\n+}\n+\n+/* Clear any mark that says that this insn sets dest.  Called from\n+   note_stores.  */\n+\n+static void\n+reg_clear_last_set (rtx dest, rtx setter ATTRIBUTE_UNUSED,\n+\t      void *data)\n+{\n+  int *dead_vec = data;\n+\n+  if (GET_CODE (dest) == SUBREG)\n+    dest = SUBREG_REG (dest);\n+\n+  if (GET_CODE (dest) == REG &&\n+      dead_vec[REGNO (dest)] == INSN_UID (compute_store_table_current_insn))\n+    dead_vec[REGNO (dest)] = 0;\n }\n \n /* Return zero if some of the registers in list X are killed\n@@ -7165,14 +7190,13 @@ compute_store_table (void)\n \t\t\t\t\t\t       max_gcse_regno);\n   sbitmap_vector_zero (reg_set_in_block, last_basic_block);\n   pre_ldst_mems = 0;\n-  last_set_in = xmalloc (sizeof (int) * max_gcse_regno);\n+  last_set_in = xcalloc (max_gcse_regno, sizeof (int));\n   already_set = xmalloc (sizeof (int) * max_gcse_regno);\n \n   /* Find all the stores we care about.  */\n   FOR_EACH_BB (bb)\n     {\n       /* First compute the registers set in this block.  */\n-      memset (last_set_in, 0, sizeof (int) * max_gcse_regno);\n       regvec = last_set_in;\n \n       for (insn = bb->head;\n@@ -7194,19 +7218,17 @@ compute_store_table (void)\n \t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t\tif (clobbers_all\n \t\t    || TEST_HARD_REG_BIT (regs_invalidated_by_call, regno))\n-\t\t  last_set_in[regno] = INSN_UID (insn);\n+\t\t  {\n+\t\t    last_set_in[regno] = INSN_UID (insn);\n+\t\t    SET_BIT (reg_set_in_block[bb->index], regno);\n+\t\t  }\n \t    }\n \n \t  pat = PATTERN (insn);\n \t  compute_store_table_current_insn = insn;\n-\t  note_stores (pat, reg_set_info, NULL);\n+\t  note_stores (pat, reg_set_info, reg_set_in_block[bb->index]);\n \t}\n \n-      /* Record the set registers.  */\n-      for (regno = 0; regno < max_gcse_regno; regno++)\n-\tif (last_set_in[regno])\n-\t  SET_BIT (reg_set_in_block[bb->index], regno);\n-\n       /* Now find the stores.  */\n       memset (already_set, 0, sizeof (int) * max_gcse_regno);\n       regvec = already_set;\n@@ -7239,11 +7261,32 @@ compute_store_table (void)\n \t  find_moveable_store (insn, already_set, last_set_in);\n \n \t  /* Unmark regs that are no longer set.  */\n-\t  for (regno = 0; regno < max_gcse_regno; regno++)\n-\t    if (last_set_in[regno] == INSN_UID (insn))\n-\t      last_set_in[regno] = 0;\n+\t  compute_store_table_current_insn = insn;\n+\t  note_stores (pat, reg_clear_last_set, last_set_in);\n+\t  if (GET_CODE (insn) == CALL_INSN)\n+\t    {\n+\t      bool clobbers_all = false;\n+#ifdef NON_SAVING_SETJMP\n+\t      if (NON_SAVING_SETJMP\n+\t\t  && find_reg_note (insn, REG_SETJMP, NULL_RTX))\n+\t\tclobbers_all = true;\n+#endif\n+\n+\t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\t\tif ((clobbers_all\n+\t\t     || TEST_HARD_REG_BIT (regs_invalidated_by_call, regno))\n+\t\t    && last_set_in[regno] == INSN_UID (insn))\n+\t\t  last_set_in[regno] = 0;\n+\t    }\n \t}\n \n+#ifdef ENABLE_CHECKING\n+      /* last_set_in should now be all-zero.  */\n+      for (regno = 0; regno < max_gcse_regno; regno++)\n+\tif (last_set_in[regno] != 0)\n+\t  abort ();\n+#endif\n+\n       /* Clear temporary marks.  */\n       for (ptr = first_ls_expr (); ptr != NULL; ptr = next_ls_expr (ptr))\n \t{"}]}