{"sha": "dc703151d4f4560e647649506d5b4ceb0ee11e90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM3MDMxNTFkNGY0NTYwZTY0NzY0OTUwNmQ1YjRjZWIwZWUxMWU5MA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-05-12T07:17:09Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-05-12T07:17:09Z"}, "message": "openmp: Implement discovery of implicit declare target to clauses\n\nThis attempts to implement what the OpenMP 5.0 spec in declare target section\nsays as ammended by the 5.1 changes so far (related to device_type(host)), except\nthat it doesn't have the device(ancestor: ...) handling yet because we do not\nsupport it yet, and I've left so far out the except lambda note, because I need\nthat clarified.\n\n2020-05-12  Jakub Jelinek  <jakub@redhat.com>\n\n\t* omp-offload.h (omp_discover_implicit_declare_target): Declare.\n\t* omp-offload.c: Include context.h.\n\t(omp_declare_target_fn_p, omp_declare_target_var_p,\n\tomp_discover_declare_target_fn_r, omp_discover_declare_target_var_r,\n\tomp_discover_implicit_declare_target): New functions.\n\t* cgraphunit.c (analyze_functions): Call\n\tomp_discover_implicit_declare_target.\n\n\t* testsuite/libgomp.c/target-39.c: New test.", "tree": {"sha": "e0982957d9abe22aec71e6199d1e306e9b0795ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0982957d9abe22aec71e6199d1e306e9b0795ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc703151d4f4560e647649506d5b4ceb0ee11e90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc703151d4f4560e647649506d5b4ceb0ee11e90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc703151d4f4560e647649506d5b4ceb0ee11e90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc703151d4f4560e647649506d5b4ceb0ee11e90/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe8c8f1e5ed61f00c14ff36caf4f510a7a09781d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe8c8f1e5ed61f00c14ff36caf4f510a7a09781d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe8c8f1e5ed61f00c14ff36caf4f510a7a09781d"}], "stats": {"total": 199, "additions": 199, "deletions": 0}, "files": [{"sha": "ffa00559387be1289f765067c08e8216a4272c5b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc703151d4f4560e647649506d5b4ceb0ee11e90/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc703151d4f4560e647649506d5b4ceb0ee11e90/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc703151d4f4560e647649506d5b4ceb0ee11e90", "patch": "@@ -1,3 +1,13 @@\n+2020-05-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* omp-offload.h (omp_discover_implicit_declare_target): Declare.\n+\t* omp-offload.c: Include context.h.\n+\t(omp_declare_target_fn_p, omp_declare_target_var_p,\n+\tomp_discover_declare_target_fn_r, omp_discover_declare_target_var_r,\n+\tomp_discover_implicit_declare_target): New functions.\n+\t* cgraphunit.c (analyze_functions): Call\n+\tomp_discover_implicit_declare_target.\n+\n 2020-05-12  Richard Biener  <rguenther@suse.de>\n \n \t* gimple-fold.c (maybe_canonicalize_mem_ref_addr): Canonicalize"}, {"sha": "01b3f82a4b2a43d3c1b5153113613637cedf719a", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc703151d4f4560e647649506d5b4ceb0ee11e90/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc703151d4f4560e647649506d5b4ceb0ee11e90/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=dc703151d4f4560e647649506d5b4ceb0ee11e90", "patch": "@@ -206,6 +206,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"ipa-inline.h\"\n+#include \"omp-offload.h\"\n \n /* Queue of cgraph nodes scheduled to be added into cgraph.  This is a\n    secondary queue used during optimization to accommodate passes that\n@@ -1160,6 +1161,9 @@ analyze_functions (bool first_time)\n \t  node->fixup_same_cpp_alias_visibility (node->get_alias_target ());\n   build_type_inheritance_graph ();\n \n+  if (flag_openmp && first_time)\n+    omp_discover_implicit_declare_target ();\n+\n   /* Analysis adds static variables that in turn adds references to new functions.\n      So we need to iterate the process until it stabilize.  */\n   while (changed)"}, {"sha": "c1eb378e2a1c5795ac2d97c7b77321c429d2ff75", "filename": "gcc/omp-offload.c", "status": "modified", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc703151d4f4560e647649506d5b4ceb0ee11e90/gcc%2Fomp-offload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc703151d4f4560e647649506d5b4ceb0ee11e90/gcc%2Fomp-offload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-offload.c?ref=dc703151d4f4560e647649506d5b4ceb0ee11e90", "patch": "@@ -52,6 +52,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"cfgloop.h\"\n+#include \"context.h\"\n \n /* Describe the OpenACC looping structure of a function.  The entire\n    function is held in a 'NULL' loop.  */\n@@ -158,6 +159,138 @@ add_decls_addresses_to_decl_constructor (vec<tree, va_gc> *v_decls,\n     }\n }\n \n+/* Return true if DECL is a function for which its references should be\n+   analyzed.  */\n+\n+static bool\n+omp_declare_target_fn_p (tree decl)\n+{\n+  return (TREE_CODE (decl) == FUNCTION_DECL\n+\t  && lookup_attribute (\"omp declare target\", DECL_ATTRIBUTES (decl))\n+\t  && !lookup_attribute (\"omp declare target host\",\n+\t\t\t\tDECL_ATTRIBUTES (decl))\n+\t  && (!flag_openacc\n+\t      || oacc_get_fn_attrib (decl) == NULL_TREE));\n+}\n+\n+/* Return true if DECL Is a variable for which its initializer references\n+   should be analyzed.  */\n+\n+static bool\n+omp_declare_target_var_p (tree decl)\n+{\n+  return (VAR_P (decl)\n+\t  && lookup_attribute (\"omp declare target\", DECL_ATTRIBUTES (decl))\n+\t  && !lookup_attribute (\"omp declare target link\",\n+\t\t\t\tDECL_ATTRIBUTES (decl)));\n+}\n+\n+/* Helper function for omp_discover_implicit_declare_target, called through\n+   walk_tree.  Mark referenced FUNCTION_DECLs implicitly as\n+   declare target to.  */\n+\n+static tree\n+omp_discover_declare_target_fn_r (tree *tp, int *walk_subtrees, void *data)\n+{\n+  if (TREE_CODE (*tp) == FUNCTION_DECL\n+      && !omp_declare_target_fn_p (*tp)\n+      && !lookup_attribute (\"omp declare target host\", DECL_ATTRIBUTES (*tp)))\n+    {\n+      tree id = get_identifier (\"omp declare target\");\n+      if (!DECL_EXTERNAL (*tp) && DECL_SAVED_TREE (*tp))\n+\t((vec<tree> *) data)->safe_push (*tp);\n+      DECL_ATTRIBUTES (*tp) = tree_cons (id, NULL_TREE, DECL_ATTRIBUTES (*tp));\n+      symtab_node *node = symtab_node::get (*tp);\n+      if (node != NULL)\n+\t{\n+\t  node->offloadable = 1;\n+\t  if (ENABLE_OFFLOADING)\n+\t    g->have_offload = true;\n+\t}\n+    }\n+  else if (TYPE_P (*tp))\n+    *walk_subtrees = 0;\n+  /* else if (TREE_CODE (*tp) == OMP_TARGET)\n+       {\n+\t if (tree dev = omp_find_clause (OMP_TARGET_CLAUSES (*tp)))\n+\t   if (OMP_DEVICE_ANCESTOR (dev))\n+\t     *walk_subtrees = 0;\n+       } */\n+  return NULL_TREE;\n+}\n+\n+/* Helper function for omp_discover_implicit_declare_target, called through\n+   walk_tree.  Mark referenced FUNCTION_DECLs implicitly as\n+   declare target to.  */\n+\n+static tree\n+omp_discover_declare_target_var_r (tree *tp, int *walk_subtrees, void *data)\n+{\n+  if (TREE_CODE (*tp) == FUNCTION_DECL)\n+    return omp_discover_declare_target_fn_r (tp, walk_subtrees, data);\n+  else if (VAR_P (*tp)\n+\t   && is_global_var (*tp)\n+\t   && !omp_declare_target_var_p (*tp))\n+    {\n+      tree id = get_identifier (\"omp declare target\");\n+      if (lookup_attribute (\"omp declare target link\", DECL_ATTRIBUTES (*tp)))\n+\t{\n+\t  error_at (DECL_SOURCE_LOCATION (*tp),\n+\t\t    \"%qD specified both in declare target %<link%> and \"\n+\t\t    \"implicitly in %<to%> clauses\", *tp);\n+\t  DECL_ATTRIBUTES (*tp)\n+\t    = remove_attribute (\"omp declare target link\", DECL_ATTRIBUTES (*tp));\n+\t}\n+      if (TREE_STATIC (*tp) && DECL_INITIAL (*tp))\n+\t((vec<tree> *) data)->safe_push (*tp);\n+      DECL_ATTRIBUTES (*tp) = tree_cons (id, NULL_TREE, DECL_ATTRIBUTES (*tp));\n+      symtab_node *node = symtab_node::get (*tp);\n+      if (node != NULL && !node->offloadable)\n+\t{\n+\t  node->offloadable = 1;\n+\t  if (ENABLE_OFFLOADING)\n+\t    {\n+\t      g->have_offload = true;\n+\t      if (is_a <varpool_node *> (node))\n+\t\tvec_safe_push (offload_vars, node->decl);\n+\t    }\n+\t}\n+    }\n+  else if (TYPE_P (*tp))\n+    *walk_subtrees = 0;\n+  return NULL_TREE;\n+}\n+\n+/* Perform the OpenMP implicit declare target to discovery.  */\n+\n+void\n+omp_discover_implicit_declare_target (void)\n+{\n+  cgraph_node *node;\n+  varpool_node *vnode;\n+  auto_vec<tree> worklist;\n+\n+  FOR_EACH_DEFINED_FUNCTION (node)\n+    if (omp_declare_target_fn_p (node->decl) && DECL_SAVED_TREE (node->decl))\n+      worklist.safe_push (node->decl);\n+  FOR_EACH_STATIC_INITIALIZER (vnode)\n+    if (omp_declare_target_var_p (vnode->decl))\n+      worklist.safe_push (vnode->decl);\n+  while (!worklist.is_empty ())\n+    {\n+      tree decl = worklist.pop ();\n+      if (TREE_CODE (decl) == FUNCTION_DECL)\n+\twalk_tree_without_duplicates (&DECL_SAVED_TREE (decl),\n+\t\t\t\t      omp_discover_declare_target_fn_r,\n+\t\t\t\t      &worklist);\n+      else\n+\twalk_tree_without_duplicates (&DECL_INITIAL (decl),\n+\t\t\t\t      omp_discover_declare_target_var_r,\n+\t\t\t\t      &worklist);\n+    }\n+}\n+\n+\n /* Create new symbols containing (address, size) pairs for global variables,\n    marked with \"omp declare target\" attribute, as well as addresses for the\n    functions, which are outlined offloading regions.  */"}, {"sha": "0809189db2556fb82c312ff419ae55addd3f3670", "filename": "gcc/omp-offload.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc703151d4f4560e647649506d5b4ceb0ee11e90/gcc%2Fomp-offload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc703151d4f4560e647649506d5b4ceb0ee11e90/gcc%2Fomp-offload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-offload.h?ref=dc703151d4f4560e647649506d5b4ceb0ee11e90", "patch": "@@ -30,5 +30,6 @@ extern GTY(()) vec<tree, va_gc> *offload_funcs;\n extern GTY(()) vec<tree, va_gc> *offload_vars;\n \n extern void omp_finish_file (void);\n+extern void omp_discover_implicit_declare_target (void);\n \n #endif /* GCC_OMP_DEVICE_H */"}, {"sha": "1265640a2c36fecd06f26ad4acf0526ba9e57278", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc703151d4f4560e647649506d5b4ceb0ee11e90/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc703151d4f4560e647649506d5b4ceb0ee11e90/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=dc703151d4f4560e647649506d5b4ceb0ee11e90", "patch": "@@ -1,3 +1,7 @@\n+2020-05-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.c/target-39.c: New test.\n+\n 2020-04-29  Thomas Schwinge  <thomas@codesourcery.com>\n \n \t* config/accel/openacc.f90 (acc_device_current): Set to '-1'."}, {"sha": "4442f43c8efecd596f20b01550d424087e1b233a", "filename": "libgomp/testsuite/libgomp.c/target-39.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc703151d4f4560e647649506d5b4ceb0ee11e90/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-39.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc703151d4f4560e647649506d5b4ceb0ee11e90/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-39.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-39.c?ref=dc703151d4f4560e647649506d5b4ceb0ee11e90", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O0\" } */\n+\n+extern void abort (void);\n+volatile int v;\n+#pragma omp declare target to (v)\n+typedef void (*fnp1) (void);\n+typedef fnp1 (*fnp2) (void);\n+void f1 (void) { v++; }\n+void f2 (void) { v += 4; }\n+void f3 (void) { v += 16; f1 (); }\n+fnp1 f4 (void) { v += 64; return f2; }\n+int a = 1;\n+int *b = &a;\n+int **c = &b;\n+fnp2 f5 (void) { f3 (); return f4; }\n+#pragma omp declare target to (c, f5)\n+\n+int\n+main ()\n+{\n+  int err = 0;\n+  #pragma omp target map(from:err)\n+  {\n+    volatile int xa;\n+    int *volatile xb;\n+    int **volatile xc;\n+    fnp2 xd;\n+    fnp1 xe;\n+    err = 0;\n+    xa = a;\n+    err |= xa != 1;\n+    xb = b;\n+    err |= xb != &a;\n+    xc = c;\n+    err |= xc != &b;\n+    xd = f5 ();\n+    err |= v != 17;\n+    xe = xd ();\n+    err |= v != 81;\n+    xe ();\n+    err |= v != 85;\n+  }\n+  if (err)\n+    abort ();\n+  return 0;\n+}"}]}