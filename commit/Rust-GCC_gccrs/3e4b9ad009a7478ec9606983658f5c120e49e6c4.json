{"sha": "3e4b9ad009a7478ec9606983658f5c120e49e6c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2U0YjlhZDAwOWE3NDc4ZWM5NjA2OTgzNjU4ZjVjMTIwZTQ5ZTZjNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-02-19T21:15:28Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-02-19T21:15:28Z"}, "message": "predict.c (predict_paths_leading_to): Rewrite.\n\n\n\t* predict.c (predict_paths_leading_to): Rewrite.\n\t(predict_paths_for_bb): New.\n\t(tree_bb_level_predictions): Update call of predict_paths_leading_to.\n\nFrom-SVN: r132450", "tree": {"sha": "d13629c062d8231e94ed7998bb2e536e53f9446b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d13629c062d8231e94ed7998bb2e536e53f9446b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e4b9ad009a7478ec9606983658f5c120e49e6c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e4b9ad009a7478ec9606983658f5c120e49e6c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e4b9ad009a7478ec9606983658f5c120e49e6c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e4b9ad009a7478ec9606983658f5c120e49e6c4/comments", "author": null, "committer": null, "parents": [{"sha": "a0e527e319e3e6aa7768e439496ad49d8537b618", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0e527e319e3e6aa7768e439496ad49d8537b618", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0e527e319e3e6aa7768e439496ad49d8537b618"}], "stats": {"total": 98, "additions": 42, "deletions": 56}, "files": [{"sha": "35cdc2d8786f23d48b63d12cd6db9401fa1aba07", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e4b9ad009a7478ec9606983658f5c120e49e6c4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e4b9ad009a7478ec9606983658f5c120e49e6c4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3e4b9ad009a7478ec9606983658f5c120e49e6c4", "patch": "@@ -1,3 +1,9 @@\n+2008-02-19  Jan Hubicka  <jh@suse.cz>\n+\n+\t* predict.c (predict_paths_leading_to): Rewrite.\n+\t(predict_paths_for_bb): New.\n+\t(tree_bb_level_predictions): Update call of predict_paths_leading_to.\n+\n 2008-02-19  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \tPR bootstrap/35218\n@@ -10,12 +16,14 @@\n 2008-02-19  Jan Hubicka  <jh@suse.cz>\n \n \tPR rtl-optimization/34408\n-\t* see.c (see_def_extension_not_merged): Copy subreg so we don't have invalid sharing.\n+\t* see.c (see_def_extension_not_merged): Copy subreg so we don't have\n+\tinvalid sharing.\n \n 2008-02-19  Jan Hubicka  <jh@suse.cz>\n \n \tPR middle-end/28779\n-\t* tree-inline.c (estimate_num_insns_1): Fix counting of cost of call_expr.\n+\t* tree-inline.c (estimate_num_insns_1): Fix counting of cost of\n+\tcall_expr.\n \n 2008-02-19  H.J. Lu  <hongjiu.lu@intel.com>\n "}, {"sha": "472484822f3c5bade01c445d55f79ff15aa4f462", "filename": "gcc/predict.c", "status": "modified", "additions": 32, "deletions": 54, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e4b9ad009a7478ec9606983658f5c120e49e6c4/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e4b9ad009a7478ec9606983658f5c120e49e6c4/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=3e4b9ad009a7478ec9606983658f5c120e49e6c4", "patch": "@@ -74,7 +74,7 @@ static sreal real_zero, real_one, real_almost_one, real_br_prob_base,\n \n static void combine_predictions_for_insn (rtx, basic_block);\n static void dump_prediction (FILE *, enum br_predictor, int, basic_block, int);\n-static void predict_paths_leading_to (basic_block, int *, enum br_predictor, enum prediction);\n+static void predict_paths_leading_to (basic_block, enum br_predictor, enum prediction);\n static void compute_function_frequency (void);\n static void choose_function_section (void);\n static bool can_predict_insn_p (const_rtx);\n@@ -1225,7 +1225,7 @@ return_prediction (tree val, enum prediction *prediction)\n /* Find the basic block with return expression and look up for possible\n    return value trying to apply RETURN_PREDICTION heuristics.  */\n static void\n-apply_return_prediction (int *heads)\n+apply_return_prediction (void)\n {\n   tree return_stmt = NULL;\n   tree return_val;\n@@ -1273,7 +1273,7 @@ apply_return_prediction (int *heads)\n       {\n \tpred = return_prediction (PHI_ARG_DEF (phi, i), &direction);\n \tif (pred != PRED_NO_PREDICTION)\n-\t  predict_paths_leading_to (PHI_ARG_EDGE (phi, i)->src, heads, pred,\n+\t  predict_paths_leading_to (PHI_ARG_EDGE (phi, i)->src, pred,\n \t\t\t\t    direction);\n       }\n }\n@@ -1286,12 +1286,8 @@ static void\n tree_bb_level_predictions (void)\n {\n   basic_block bb;\n-  int *heads;\n \n-  heads = XCNEWVEC (int, last_basic_block);\n-  heads[ENTRY_BLOCK_PTR->next_bb->index] = last_basic_block;\n-\n-  apply_return_prediction (heads);\n+  apply_return_prediction ();\n \n   FOR_EACH_BB (bb)\n     {\n@@ -1301,6 +1297,7 @@ tree_bb_level_predictions (void)\n \t{\n \t  tree stmt = bsi_stmt (bsi);\n \t  tree decl;\n+\t  bool next = false;\n \t  switch (TREE_CODE (stmt))\n \t    {\n \t      case GIMPLE_MODIFY_STMT:\n@@ -1313,22 +1310,20 @@ tree_bb_level_predictions (void)\n \t      case CALL_EXPR:\n call_expr:;\n \t\tif (call_expr_flags (stmt) & ECF_NORETURN)\n-\t\t  predict_paths_leading_to (bb, heads, PRED_NORETURN,\n+\t\t  predict_paths_leading_to (bb, PRED_NORETURN,\n \t\t      \t\t\t    NOT_TAKEN);\n \t\tdecl = get_callee_fndecl (stmt);\n \t\tif (decl\n \t\t    && lookup_attribute (\"cold\",\n \t\t\t\t\t DECL_ATTRIBUTES (decl)))\n-\t\t  predict_paths_leading_to (bb, heads, PRED_COLD_FUNCTION,\n+\t\t  predict_paths_leading_to (bb, PRED_COLD_FUNCTION,\n \t\t      \t\t\t    NOT_TAKEN);\n \t\tbreak;\n \t      default:\n \t\tbreak;\n \t    }\n \t}\n     }\n-\n-  free (heads);\n }\n \n #ifdef ENABLE_CHECKING\n@@ -1469,58 +1464,41 @@ tree_estimate_probability (void)\n   return 0;\n }\n \f\n-/* Sets branch probabilities according to PREDiction and\n-   FLAGS. HEADS[bb->index] should be index of basic block in that we\n-   need to alter branch predictions (i.e. the first of our dominators\n-   such that we do not post-dominate it) (but we fill this information\n-   on demand, so -1 may be there in case this was not needed yet).  */\n+/* Predict edges to succestors of CUR whose sources are not postdominated by\n+   BB by PRED and recurse to all postdominators.  */\n \n static void\n-predict_paths_leading_to (basic_block bb, int *heads, enum br_predictor pred,\n-\t\t\t  enum prediction taken)\n+predict_paths_for_bb (basic_block cur, basic_block bb,\n+\t\t      enum br_predictor pred,\n+\t\t      enum prediction taken)\n {\n   edge e;\n   edge_iterator ei;\n-  int y;\n+  basic_block son;\n \n-  if (heads[bb->index] == ENTRY_BLOCK)\n+  /* We are looking for all edges forming edge cut induced by\n+     set of all blocks postdominated by BB.  */\n+  FOR_EACH_EDGE (e, ei, cur->preds)\n+    if (e->src->index >= NUM_FIXED_BLOCKS\n+\t&& !dominated_by_p (CDI_POST_DOMINATORS, e->src, bb))\n     {\n-      /* This is first time we need this field in heads array; so\n-         find first dominator that we do not post-dominate (we are\n-         using already known members of heads array).  */\n-      basic_block ai = bb;\n-      basic_block next_ai = get_immediate_dominator (CDI_DOMINATORS, bb);\n-      int head;\n-\n-      while (heads[next_ai->index] == ENTRY_BLOCK)\n-\t{\n-\t  if (!dominated_by_p (CDI_POST_DOMINATORS, next_ai, bb))\n-\t    break;\n-\t  heads[next_ai->index] = ai->index;\n-\t  ai = next_ai;\n-\t  next_ai = get_immediate_dominator (CDI_DOMINATORS, next_ai);\n-\t}\n-      if (!dominated_by_p (CDI_POST_DOMINATORS, next_ai, bb))\n-\thead = next_ai->index;\n-      else\n-\thead = heads[next_ai->index];\n-      while (next_ai != bb)\n-\t{\n-\t  next_ai = ai;\n-\t  ai = BASIC_BLOCK (heads[ai->index]);\n-\t  heads[next_ai->index] = head;\n-\t}\n+      gcc_assert (bb == cur || dominated_by_p (CDI_POST_DOMINATORS, cur, bb));\n+      predict_edge_def (e, pred, taken);\n     }\n-  y = heads[bb->index];\n+  for (son = first_dom_son (CDI_POST_DOMINATORS, cur);\n+       son;\n+       son = next_dom_son (CDI_POST_DOMINATORS, son))\n+    predict_paths_for_bb (son, bb, pred, taken);\n+}\n \n-  /* Now find the edge that leads to our branch and aply the prediction.  */\n+/* Sets branch probabilities according to PREDiction and\n+   FLAGS.  */\n \n-  if (y == last_basic_block)\n-    return;\n-  FOR_EACH_EDGE (e, ei, BASIC_BLOCK (y)->succs)\n-    if (e->dest->index >= NUM_FIXED_BLOCKS\n-\t&& dominated_by_p (CDI_POST_DOMINATORS, e->dest, bb))\n-      predict_edge_def (e, pred, taken);\n+static void\n+predict_paths_leading_to (basic_block bb, enum br_predictor pred,\n+\t\t\t  enum prediction taken)\n+{\n+  predict_paths_for_bb (bb, bb, pred, taken);\n }\n \f\n /* This is used to carry information about basic blocks.  It is"}]}