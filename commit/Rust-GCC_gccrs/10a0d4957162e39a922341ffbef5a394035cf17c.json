{"sha": "10a0d4957162e39a922341ffbef5a394035cf17c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBhMGQ0OTU3MTYyZTM5YTkyMjM0MWZmYmVmNWEzOTQwMzVjZjE3Yw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2005-06-27T12:17:39Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2005-06-27T12:17:39Z"}, "message": "builtin-attrs.def (DEF_ATTR_FOR_INT): Add for 5 and 6.\n\n\t* builtin-attrs.def (DEF_ATTR_FOR_INT): Add for 5 and 6.\n\t(DEF_LIST_INT_INT): Add for 4,0, 4,5, 5,0, 5,6.\n\t(ATTR_NOTHROW_NONNULL_4, ATTR_NOTHROW_NONNULL_5): Define.\n\t(ATTR_FORMAT_PRINTF_4_0, ATTR_FORMAT_PRINTF_4_5,\n\tATTR_FORMAT_PRINTF_5_0, ATTR_FORMAT_PRINTF_5_6): Define.\n\t* builtins.c: Include tree-flow.h.\n\t(expand_builtin_mempcpy, expand_builtin_memmove): Comment fixes.\n\t(expand_builtin_object_size, expand_builtin_memory_chk,\n\tmaybe_emit_chk_warning, maybe_emit_sprintf_chk_warning,\n\tcompute_object_offset, compute_builtin_object_size,\n\tfold_builtin_object_size): New functions.\n\t(expand_builtin): Handle BUILT_IN_OBJECT_SIZE and BUILT_IN_*_CHK.\n\t(fold_builtin_1): Likewise.  Handle BUILT_IN_{,V}{,F}PRINTF\n\tand BUILT_IN_{,F}PRINTF_UNLOCKED.\n\t(fold_builtin_memory_chk, fold_builtin_stxcpy_chk,\n\tfold_builtin_strncpy_chk, fold_builtin_strcat_chk,\n\tfold_builtin_strncat_chk, fold_builtin_sprintf_chk,\n\tfold_builtin_snprintf_chk, fold_builtin_printf, fold_builtin_fprintf):\n\tNew functions.\n\t* builtins.def (BUILT_IN_OBJECT_SIZE, BUILT_IN_MEMCPY_CHK,\n\tBUILT_IN_MEMMOVE_CHK, BUILT_IN_MEMPCPY_CHK, BUILT_IN_MEMSET_CHK,\n\tBUILT_IN_STPCPY_CHK, BUILT_IN_STRCAT_CHK, BUILT_IN_STRCPY_CHK,\n\tBUILT_IN_STRNCAT_CHK, BUILT_IN_STRNCPY_CHK, BUILT_IN_SNPRINTF_CHK,\n\tBUILT_IN_SPRINTF_CHK, BUILT_IN_VSNPRINTF_CHK, BUILT_IN_VSPRINTF_CHK,\n\tBUILT_IN_FPRINTF_CHK, BUILT_IN_PRINTF_CHK, BUILT_IN_VFPRINTF_CHK,\n\tBUILT_IN_VPRINTF_CHK): New builtins.\n\t* builtin-types.def (DEF_FUNCTION_TYPE_5, DEF_FUNCTION_TYPE_VAR_4):\n\tDocument.\n\t(BT_FN_SIZE_CONST_PTR_INT, BT_FN_INT_INT_CONST_STRING_VALIST_ARG,\n\tBT_FN_PTR_PTR_CONST_PTR_SIZE_SIZE, BT_FN_PTR_PTR_INT_SIZE_SIZE,\n\tBT_FN_STRING_STRING_CONST_STRING_SIZE_SIZE,\n\tBT_FN_INT_FILEPTR_INT_CONST_STRING_VALIST_ARG,\n\tBT_FN_INT_STRING_INT_SIZE_CONST_STRING_VALIST_ARG,\n\tBT_FN_INT_STRING_SIZE_INT_SIZE_CONST_STRING_VALIST_ARG,\n\tBT_FN_INT_INT_CONST_STRING_VAR, BT_FN_INT_FILEPTR_INT_CONST_STRING_VAR,\n\tBT_FN_INT_STRING_INT_SIZE_CONST_STRING_VAR,\n\tBT_FN_INT_STRING_SIZE_INT_SIZE_CONST_STRING_VAR): New types.\n\t* c-common.c (DEF_FUNCTION_TYPE_5, DEF_FUNCTION_TYPE_6,\n\tDEF_FUNCTION_TYPE_VAR_4, DEF_FUNCTION_TYPE_VAR_5): Define.\n\t* Makefile.in (OBJS-common): Add tree-object-size.o.\n\t(tree-object-size.o): Add dependencies.\n\t* tree-pass.h (pass_object_sizes): Add.\n\t* tree-optimize.c (init_tree_optimization_passes): Add\n\tpass_object_sizes.\n\t* tree-object-size.c: New file.\n\t* tree.h (fold_builtin_memory_chk, fold_builtin_stxcpy_chk,\n\tfold_builtin_strncpy_chk, fold_builtin_snprintf_chk,\n\tcompute_builtin_object_size, init_object_sizes, fini_object_sizes):\n\tNew prototypes.\n\t* tree-ssa-ccp.c (get_strlen): Rename to ...\n\t(get_maxval_strlen): ...this function.  Handle also computing of maximum\n\tstring length and maximum integral value.\n\t(ccp_fold_builtin): Handle BUILT_IN_*_CHK.  Use get_maxval_strlen\n\tinstead of get_strlen.  Pass CALLEE and ARGLIST variables to the\n\tfolding functions instead of computing them again.\n\t(execute_fold_all_builtins): Retry ccp_fold_builtin if a builtin changed\n\tinto some other builtin.\n\t* doc/extend.texi (Object Size Checking): Document.\n\n\t* gcc.c-torture/execute/builtins/lib/main.c (abort): Add prototype.\n\t* gcc.c-torture/execute/builtins/lib/strncat.c (strncat): Avoid\n\ttesting uninitialized var.\n\n\t* gcc.c-torture/execute/builtins/chk.h: New.\n\t* gcc.c-torture/execute/builtins/lib/chk.c: New.\n\t* gcc.c-torture/execute/builtins/memcpy-chk.c: New test.\n\t* gcc.c-torture/execute/builtins/memcpy-chk-lib.c: New.\n\t* gcc.c-torture/execute/builtins/memmove-chk.c: New test.\n\t* gcc.c-torture/execute/builtins/memmove-chk-lib.c: New.\n\t* gcc.c-torture/execute/builtins/mempcpy-chk.c: New test.\n\t* gcc.c-torture/execute/builtins/mempcpy-chk-lib.c: New.\n\t* gcc.c-torture/execute/builtins/memset-chk.c: New test.\n\t* gcc.c-torture/execute/builtins/memset-chk-lib.c: New.\n\t* gcc.c-torture/execute/builtins/snprintf-chk.c: New test.\n\t* gcc.c-torture/execute/builtins/snprintf-chk-lib.c: New.\n\t* gcc.c-torture/execute/builtins/sprintf-chk.c: New test.\n\t* gcc.c-torture/execute/builtins/sprintf-chk-lib.c: New.\n\t* gcc.c-torture/execute/builtins/stpcpy-chk.c: New test.\n\t* gcc.c-torture/execute/builtins/stpcpy-chk-lib.c: New.\n\t* gcc.c-torture/execute/builtins/strcat-chk.c: New test.\n\t* gcc.c-torture/execute/builtins/strcat-chk-lib.c: New.\n\t* gcc.c-torture/execute/builtins/strcpy-chk.c: New test.\n\t* gcc.c-torture/execute/builtins/strcpy-chk-lib.c: New.\n\t* gcc.c-torture/execute/builtins/strncat-chk.c: New test.\n\t* gcc.c-torture/execute/builtins/strncat-chk-lib.c: New.\n\t* gcc.c-torture/execute/builtins/strncpy-chk.c: New test.\n\t* gcc.c-torture/execute/builtins/strncpy-chk-lib.c: New.\n\t* gcc.c-torture/execute/builtins/vsnprintf-chk.c: New test.\n\t* gcc.c-torture/execute/builtins/vsnprintf-chk-lib.c: New.\n\t* gcc.c-torture/execute/builtins/vsprintf-chk.c: New test.\n\t* gcc.c-torture/execute/builtins/vsprintf-chk-lib.c: New.\n\t* gcc.dg/builtin-object-size-1.c: New test.\n\t* gcc.dg/builtin-object-size-2.c: New test.\n\t* gcc.dg/builtin-object-size-3.c: New test.\n\t* gcc.dg/builtin-object-size-4.c: New test.\n\t* gcc.dg/builtin-object-size-5.c: New test.\n\t* gcc.dg/builtin-stringop-chk-1.c: New test.\n\t* gcc.dg/builtin-stringop-chk-2.c: New test.\n\t* gcc.dg/tree-ssa/builtin-fprintf-1.c: New test.\n\t* gcc.dg/tree-ssa/builtin-fprintf-chk-1.c: New test.\n\t* gcc.dg/tree-ssa/builtin-printf-1.c: New test.\n\t* gcc.dg/tree-ssa/builtin-printf-chk-1.c: New test.\n\t* gcc.dg/tree-ssa/builtin-vfprintf-1.c: New test.\n\t* gcc.dg/tree-ssa/builtin-vfprintf-chk-1.c: New test.\n\t* gcc.dg/tree-ssa/builtin-vprintf-1.c: New test.\n\t* gcc.dg/tree-ssa/builtin-vprintf-chk-1.c: New test.\n\t* gcc.c-torture/execute/printf-1.c: New test.\n\t* gcc.c-torture/execute/fprintf-1.c: New test.\n\t* gcc.c-torture/execute/vprintf-1.c: New test.\n\t* gcc.c-torture/execute/vfprintf-1.c: New test.\n\t* gcc.c-torture/execute/printf-chk-1.c: New test.\n\t* gcc.c-torture/execute/fprintf-chk-1.c: New test.\n\t* gcc.c-torture/execute/vprintf-chk-1.c: New test.\n\t* gcc.c-torture/execute/vfprintf-chk-1.c: New test.\n\nFrom-SVN: r101352", "tree": {"sha": "bb3939873bf2cf5cb7bd56f678141658affb0021", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb3939873bf2cf5cb7bd56f678141658affb0021"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10a0d4957162e39a922341ffbef5a394035cf17c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10a0d4957162e39a922341ffbef5a394035cf17c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10a0d4957162e39a922341ffbef5a394035cf17c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10a0d4957162e39a922341ffbef5a394035cf17c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "de16a5b6a405055fe49ac876878ebe2a65459b42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de16a5b6a405055fe49ac876878ebe2a65459b42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de16a5b6a405055fe49ac876878ebe2a65459b42"}], "stats": {"total": 10638, "additions": 10572, "deletions": 66}, "files": [{"sha": "2ee61b3fe50275d546a4f7b57c496acf66d18509", "filename": "gcc/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -1,5 +1,64 @@\n 2005-06-27  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* builtin-attrs.def (DEF_ATTR_FOR_INT): Add for 5 and 6.\n+\t(DEF_LIST_INT_INT): Add for 4,0, 4,5, 5,0, 5,6.\n+\t(ATTR_NOTHROW_NONNULL_4, ATTR_NOTHROW_NONNULL_5): Define.\n+\t(ATTR_FORMAT_PRINTF_4_0, ATTR_FORMAT_PRINTF_4_5,\n+\tATTR_FORMAT_PRINTF_5_0, ATTR_FORMAT_PRINTF_5_6): Define.\n+\t* builtins.c: Include tree-flow.h.\n+\t(expand_builtin_mempcpy, expand_builtin_memmove): Comment fixes.\n+\t(expand_builtin_object_size, expand_builtin_memory_chk,\n+\tmaybe_emit_chk_warning, maybe_emit_sprintf_chk_warning,\n+\tcompute_object_offset, compute_builtin_object_size,\n+\tfold_builtin_object_size): New functions.\n+\t(expand_builtin): Handle BUILT_IN_OBJECT_SIZE and BUILT_IN_*_CHK.\n+\t(fold_builtin_1): Likewise.  Handle BUILT_IN_{,V}{,F}PRINTF\n+\tand BUILT_IN_{,F}PRINTF_UNLOCKED.\n+\t(fold_builtin_memory_chk, fold_builtin_stxcpy_chk,\n+\tfold_builtin_strncpy_chk, fold_builtin_strcat_chk,\n+\tfold_builtin_strncat_chk, fold_builtin_sprintf_chk,\n+\tfold_builtin_snprintf_chk, fold_builtin_printf, fold_builtin_fprintf):\n+\tNew functions.\n+\t* builtins.def (BUILT_IN_OBJECT_SIZE, BUILT_IN_MEMCPY_CHK,\n+\tBUILT_IN_MEMMOVE_CHK, BUILT_IN_MEMPCPY_CHK, BUILT_IN_MEMSET_CHK,\n+\tBUILT_IN_STPCPY_CHK, BUILT_IN_STRCAT_CHK, BUILT_IN_STRCPY_CHK,\n+\tBUILT_IN_STRNCAT_CHK, BUILT_IN_STRNCPY_CHK, BUILT_IN_SNPRINTF_CHK,\n+\tBUILT_IN_SPRINTF_CHK, BUILT_IN_VSNPRINTF_CHK, BUILT_IN_VSPRINTF_CHK,\n+\tBUILT_IN_FPRINTF_CHK, BUILT_IN_PRINTF_CHK, BUILT_IN_VFPRINTF_CHK,\n+\tBUILT_IN_VPRINTF_CHK): New builtins.\n+\t* builtin-types.def (DEF_FUNCTION_TYPE_5, DEF_FUNCTION_TYPE_VAR_4):\n+\tDocument.\n+\t(BT_FN_SIZE_CONST_PTR_INT, BT_FN_INT_INT_CONST_STRING_VALIST_ARG,\n+\tBT_FN_PTR_PTR_CONST_PTR_SIZE_SIZE, BT_FN_PTR_PTR_INT_SIZE_SIZE,\n+\tBT_FN_STRING_STRING_CONST_STRING_SIZE_SIZE,\n+\tBT_FN_INT_FILEPTR_INT_CONST_STRING_VALIST_ARG,\n+\tBT_FN_INT_STRING_INT_SIZE_CONST_STRING_VALIST_ARG,\n+\tBT_FN_INT_STRING_SIZE_INT_SIZE_CONST_STRING_VALIST_ARG,\n+\tBT_FN_INT_INT_CONST_STRING_VAR, BT_FN_INT_FILEPTR_INT_CONST_STRING_VAR,\n+\tBT_FN_INT_STRING_INT_SIZE_CONST_STRING_VAR,\n+\tBT_FN_INT_STRING_SIZE_INT_SIZE_CONST_STRING_VAR): New types.\n+\t* c-common.c (DEF_FUNCTION_TYPE_5, DEF_FUNCTION_TYPE_6,\n+\tDEF_FUNCTION_TYPE_VAR_4, DEF_FUNCTION_TYPE_VAR_5): Define.\n+\t* Makefile.in (OBJS-common): Add tree-object-size.o.\n+\t(tree-object-size.o): Add dependencies.\n+\t* tree-pass.h (pass_object_sizes): Add.\n+\t* tree-optimize.c (init_tree_optimization_passes): Add\n+\tpass_object_sizes.\n+\t* tree-object-size.c: New file.\n+\t* tree.h (fold_builtin_memory_chk, fold_builtin_stxcpy_chk,\n+\tfold_builtin_strncpy_chk, fold_builtin_snprintf_chk,\n+\tcompute_builtin_object_size, init_object_sizes, fini_object_sizes):\n+\tNew prototypes.\n+\t* tree-ssa-ccp.c (get_strlen): Rename to ...\n+\t(get_maxval_strlen): ...this function.  Handle also computing of maximum\n+\tstring length and maximum integral value.\n+\t(ccp_fold_builtin): Handle BUILT_IN_*_CHK.  Use get_maxval_strlen\n+\tinstead of get_strlen.  Pass CALLEE and ARGLIST variables to the\n+\tfolding functions instead of computing them again.\n+\t(execute_fold_all_builtins): Retry ccp_fold_builtin if a builtin changed\n+\tinto some other builtin.\n+\t* doc/extend.texi (Object Size Checking): Document.\n+\n \t* regrename.c (copy_value): Fix comment.\n \n \t* toplev.c (process_options): Use if (FRAME_GROWS_DOWNWARD)"}, {"sha": "98ace16f4a79b382ad4c76ad5d04728a143b5448", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -956,7 +956,7 @@ OBJS-common = \\\n  rtl-profile.o tree-profile.o rtlhooks.o cfgexpand.o lambda-mat.o          \\\n  lambda-trans.o\tlambda-code.o tree-loop-linear.o tree-ssa-sink.o \t   \\\n  tree-vrp.o tree-stdarg.o tree-cfgcleanup.o tree-ssa-reassoc.o\t\t   \\\n- tree-ssa-structalias.o\n+ tree-ssa-structalias.o tree-object-size.o\n \n \n OBJS-md = $(out_object_file)\n@@ -1945,6 +1945,9 @@ tree-loop-linear.o: tree-loop-linear.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n tree-stdarg.o: tree-stdarg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) function.h $(DIAGNOSTIC_H) $(TREE_FLOW_H) tree-pass.h \\\n    tree-stdarg.h $(TARGET_H) langhooks.h\n+tree-object-size.o: tree-object-size.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   $(TM_H) $(TREE_H) $(DIAGNOSTIC_H) $(TREE_FLOW_H) tree-pass.h \\\n+   tree-ssa-propagate.h\n tree-gimple.o : tree-gimple.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(EXPR_H) \\\n    $(RTL_H) $(TREE_GIMPLE_H) $(TM_H) coretypes.h bitmap.h $(GGC_H) \\\n    output.h $(TREE_FLOW_H)"}, {"sha": "46ac70d4c35ba799926822608295a2900558ae36", "filename": "gcc/builtin-attrs.def", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Fbuiltin-attrs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Fbuiltin-attrs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-attrs.def?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -55,6 +55,8 @@ DEF_ATTR_FOR_INT (1)\n DEF_ATTR_FOR_INT (2)\n DEF_ATTR_FOR_INT (3)\n DEF_ATTR_FOR_INT (4)\n+DEF_ATTR_FOR_INT (5)\n+DEF_ATTR_FOR_INT (6)\n #undef DEF_ATTR_FOR_INT\n \n /* Construct a tree for a list of two integers.  */\n@@ -67,6 +69,10 @@ DEF_LIST_INT_INT (2,0)\n DEF_LIST_INT_INT (2,3)\n DEF_LIST_INT_INT (3,0)\n DEF_LIST_INT_INT (3,4)\n+DEF_LIST_INT_INT (4,0)\n+DEF_LIST_INT_INT (4,5)\n+DEF_LIST_INT_INT (5,0)\n+DEF_LIST_INT_INT (5,6)\n #undef DEF_LIST_INT_INT\n \n /* Construct trees for identifiers.  */\n@@ -127,6 +133,12 @@ DEF_ATTR_TREE_LIST (ATTR_NOTHROW_NONNULL_2, ATTR_NONNULL, ATTR_LIST_2, \\\n /* Nothrow functions whose third parameter is a nonnull pointer.  */\n DEF_ATTR_TREE_LIST (ATTR_NOTHROW_NONNULL_3, ATTR_NONNULL, ATTR_LIST_3, \\\n \t\t\tATTR_NOTHROW_LIST)\n+/* Nothrow functions whose fourth parameter is a nonnull pointer.  */\n+DEF_ATTR_TREE_LIST (ATTR_NOTHROW_NONNULL_4, ATTR_NONNULL, ATTR_LIST_4, \\\n+\t\t\tATTR_NOTHROW_LIST)\n+/* Nothrow functions whose fifth parameter is a nonnull pointer.  */\n+DEF_ATTR_TREE_LIST (ATTR_NOTHROW_NONNULL_5, ATTR_NONNULL, ATTR_LIST_5, \\\n+\t\t\tATTR_NOTHROW_LIST)\n /* Nothrow const functions whose pointer parameter(s) are all nonnull.  */\n DEF_ATTR_TREE_LIST (ATTR_CONST_NOTHROW_NONNULL, ATTR_CONST, ATTR_NULL, \\\n \t\t\tATTR_NOTHROW_NONNULL)\n@@ -149,6 +161,10 @@ DEF_FORMAT_ATTRIBUTE(PRINTF,2,2_0)\n DEF_FORMAT_ATTRIBUTE(PRINTF,2,2_3)\n DEF_FORMAT_ATTRIBUTE(PRINTF,3,3_0)\n DEF_FORMAT_ATTRIBUTE(PRINTF,3,3_4)\n+DEF_FORMAT_ATTRIBUTE(PRINTF,4,4_0)\n+DEF_FORMAT_ATTRIBUTE(PRINTF,4,4_5)\n+DEF_FORMAT_ATTRIBUTE(PRINTF,5,5_0)\n+DEF_FORMAT_ATTRIBUTE(PRINTF,5,5_6)\n DEF_FORMAT_ATTRIBUTE(SCANF,1,1_0)\n DEF_FORMAT_ATTRIBUTE(SCANF,1,1_2)\n DEF_FORMAT_ATTRIBUTE(SCANF,2,2_0)"}, {"sha": "3f25cdd447783b0b58d78ce316913f774ba3f426", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -32,6 +32,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    DEF_FUNCTION_TYPE_2 (ENUM, RETURN, ARG1, ARG2)\n    DEF_FUNCTION_TYPE_3 (ENUM, RETURN, ARG1, ARG2, ARG3)\n    DEF_FUNCTION_TYPE_4 (ENUM, RETURN, ARG1, ARG2, ARG3, ARG4)\n+   DEF_FUNCTION_TYPE_5 (ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5)\n \n      These macros describe function types.  ENUM is as above.  The\n      RETURN type is one of the enumerals already defined.  ARG1, ARG2,\n@@ -41,6 +42,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    DEF_FUNCTION_TYPE_VAR_1 (ENUM, RETURN, ARG1)\n    DEF_FUNCTION_TYPE_VAR_2 (ENUM, RETURN, ARG1, ARG2)\n    DEF_FUNCTION_TYPE_VAR_3 (ENUM, RETURN, ARG1, ARG2, ARG3)\n+   DEF_FUNCTION_TYPE_VAR_4 (ENUM, RETURN, ARG1, ARG2, ARG3, ARG4)\n \n      Similar, but for function types that take variable arguments.\n      For example:\n@@ -252,6 +254,7 @@ DEF_FUNCTION_TYPE_2 (BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOU\n DEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTR_PTR, BT_VOID, BT_PTR, BT_PTR)\n DEF_FUNCTION_TYPE_2 (BT_FN_INT_CONST_STRING_PTR_CONST_STRING,\n \t\t     BT_INT, BT_CONST_STRING, BT_PTR_CONST_STRING)\n+DEF_FUNCTION_TYPE_2 (BT_FN_SIZE_CONST_PTR_INT, BT_SIZE, BT_CONST_PTR, BT_INT)\n DEF_FUNCTION_TYPE_2 (BT_FN_I1_VPTR_I1, BT_I1, BT_VOLATILE_PTR, BT_I1)\n DEF_FUNCTION_TYPE_2 (BT_FN_I2_VPTR_I2, BT_I2, BT_VOLATILE_PTR, BT_I2)\n DEF_FUNCTION_TYPE_2 (BT_FN_I4_VPTR_I4, BT_I4, BT_VOLATILE_PTR, BT_I4)\n@@ -300,6 +303,8 @@ DEF_FUNCTION_TYPE_3 (BT_FN_VOID_LONGDOUBLE_LONGDOUBLEPTR_LONGDOUBLEPTR,\n DEF_FUNCTION_TYPE_3 (BT_FN_VOID_PTR_PTR_PTR, BT_VOID, BT_PTR, BT_PTR, BT_PTR)\n DEF_FUNCTION_TYPE_3 (BT_FN_INT_CONST_STRING_PTR_CONST_STRING_PTR_CONST_STRING,\n \t\t     BT_INT, BT_CONST_STRING, BT_PTR_CONST_STRING, BT_PTR_CONST_STRING)\n+DEF_FUNCTION_TYPE_3 (BT_FN_INT_INT_CONST_STRING_VALIST_ARG,\n+\t\t     BT_INT, BT_INT, BT_CONST_STRING, BT_VALIST_ARG)\n DEF_FUNCTION_TYPE_3 (BT_FN_BOOL_VPTR_I1_I1, BT_BOOL, BT_VOLATILE_PTR,\n \t\t     BT_I1, BT_I1)\n DEF_FUNCTION_TYPE_3 (BT_FN_BOOL_VPTR_I2_I2, BT_BOOL, BT_VOLATILE_PTR,\n@@ -319,6 +324,22 @@ DEF_FUNCTION_TYPE_4 (BT_FN_INT_STRING_SIZE_CONST_STRING_VALIST_ARG,\n \t\tBT_INT, BT_STRING, BT_SIZE, BT_CONST_STRING, BT_VALIST_ARG)\n DEF_FUNCTION_TYPE_4 (BT_FN_SIZE_STRING_SIZE_CONST_STRING_CONST_PTR,\n \t\tBT_SIZE, BT_STRING, BT_SIZE, BT_CONST_STRING, BT_CONST_PTR)\n+DEF_FUNCTION_TYPE_4 (BT_FN_PTR_PTR_CONST_PTR_SIZE_SIZE,\n+\t\t     BT_PTR, BT_PTR, BT_CONST_PTR, BT_SIZE, BT_SIZE)\n+DEF_FUNCTION_TYPE_4 (BT_FN_PTR_PTR_INT_SIZE_SIZE,\n+\t\t     BT_PTR, BT_PTR, BT_INT, BT_SIZE, BT_SIZE)\n+DEF_FUNCTION_TYPE_4 (BT_FN_STRING_STRING_CONST_STRING_SIZE_SIZE,\n+\t\t     BT_STRING, BT_STRING, BT_CONST_STRING, BT_SIZE, BT_SIZE)\n+DEF_FUNCTION_TYPE_4 (BT_FN_INT_FILEPTR_INT_CONST_STRING_VALIST_ARG,\n+\t\t     BT_INT, BT_FILEPTR, BT_INT, BT_CONST_STRING, BT_VALIST_ARG)\n+\n+DEF_FUNCTION_TYPE_5 (BT_FN_INT_STRING_INT_SIZE_CONST_STRING_VALIST_ARG,\n+\t\t     BT_INT, BT_STRING, BT_INT, BT_SIZE, BT_CONST_STRING,\n+\t\t     BT_VALIST_ARG)\n+\n+DEF_FUNCTION_TYPE_6 (BT_FN_INT_STRING_SIZE_INT_SIZE_CONST_STRING_VALIST_ARG,\n+\t\t     BT_INT, BT_STRING, BT_SIZE, BT_INT, BT_SIZE,\n+\t\t     BT_CONST_STRING, BT_VALIST_ARG)\n \n DEF_FUNCTION_TYPE_VAR_0 (BT_FN_VOID_VAR, BT_VOID)\n DEF_FUNCTION_TYPE_VAR_0 (BT_FN_INT_VAR, BT_INT)\n@@ -337,11 +358,22 @@ DEF_FUNCTION_TYPE_VAR_2 (BT_FN_INT_STRING_CONST_STRING_VAR,\n \t\t\t BT_INT, BT_STRING, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_VAR_2 (BT_FN_INT_CONST_STRING_CONST_STRING_VAR,\n \t\t\t BT_INT, BT_CONST_STRING, BT_CONST_STRING)\n+DEF_FUNCTION_TYPE_VAR_2 (BT_FN_INT_INT_CONST_STRING_VAR,\n+\t\t\t BT_INT, BT_INT, BT_CONST_STRING)\n \n DEF_FUNCTION_TYPE_VAR_3 (BT_FN_INT_STRING_SIZE_CONST_STRING_VAR,\n \t\t\t BT_INT, BT_STRING, BT_SIZE, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_VAR_3 (BT_FN_SSIZE_STRING_SIZE_CONST_STRING_VAR,\n \t\t\t BT_SSIZE, BT_STRING, BT_SIZE, BT_CONST_STRING)\n+DEF_FUNCTION_TYPE_VAR_3 (BT_FN_INT_FILEPTR_INT_CONST_STRING_VAR,\n+\t\t\t BT_INT, BT_FILEPTR, BT_INT, BT_CONST_STRING)\n+\n+DEF_FUNCTION_TYPE_VAR_4 (BT_FN_INT_STRING_INT_SIZE_CONST_STRING_VAR,\n+\t\t\t BT_INT, BT_STRING, BT_INT, BT_SIZE, BT_CONST_STRING)\n+\n+DEF_FUNCTION_TYPE_VAR_5 (BT_FN_INT_STRING_SIZE_INT_SIZE_CONST_STRING_VAR,\n+\t\t\t BT_INT, BT_STRING, BT_SIZE, BT_INT, BT_SIZE,\n+\t\t\t BT_CONST_STRING)\n \n DEF_POINTER_TYPE (BT_PTR_FN_VOID_VAR, BT_FN_VOID_VAR)\n DEF_FUNCTION_TYPE_3 (BT_FN_PTR_PTR_FN_VOID_VAR_PTR_SIZE,"}, {"sha": "313170bbfbb9f6437a425fe178d05386f732efc2", "filename": "gcc/builtins.c", "status": "modified", "additions": 1225, "deletions": 4, "changes": 1229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -188,6 +188,18 @@ static tree fold_builtin_strspn (tree);\n static tree fold_builtin_strcspn (tree);\n static tree fold_builtin_sprintf (tree, int);\n \n+static rtx expand_builtin_object_size (tree);\n+static rtx expand_builtin_memory_chk (tree, rtx, enum machine_mode,\n+\t\t\t\t      enum built_in_function);\n+static void maybe_emit_chk_warning (tree, enum built_in_function);\n+static void maybe_emit_sprintf_chk_warning (tree, enum built_in_function);\n+static tree fold_builtin_object_size (tree);\n+static tree fold_builtin_strcat_chk (tree, tree);\n+static tree fold_builtin_strncat_chk (tree, tree);\n+static tree fold_builtin_sprintf_chk (tree, enum built_in_function);\n+static tree fold_builtin_printf (tree, tree, bool, enum built_in_function);\n+static tree fold_builtin_fprintf (tree, tree, bool, enum built_in_function);\n+\n /* Return true if NODE should be considered for inline expansion regardless\n    of the optimization level.  This means whenever a function is invoked with\n    its \"internal\" name, which normally contains the prefix \"__builtin\".  */\n@@ -2821,7 +2833,7 @@ expand_builtin_memcpy (tree exp, rtx target, enum machine_mode mode)\n }\n \n /* Expand a call to the mempcpy builtin, with arguments in ARGLIST.\n-   Return 0 if we failed the caller should emit a normal call,\n+   Return 0 if we failed; the caller should emit a normal call,\n    otherwise try to get the result in TARGET, if convenient (and in\n    mode MODE if that's convenient).  If ENDP is 0 return the\n    destination pointer, if ENDP is 1 return the end pointer ala\n@@ -2912,7 +2924,7 @@ expand_builtin_mempcpy (tree arglist, tree type, rtx target, enum machine_mode m\n }\n \n /* Expand expression EXP, which is a call to the memmove builtin.  Return 0\n-   if we failed the caller should emit a normal call.  */\n+   if we failed; the caller should emit a normal call.  */\n \n static rtx\n expand_builtin_memmove (tree arglist, tree type, rtx target,\n@@ -6238,6 +6250,32 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n       expand_builtin_synchronize ();\n       return const0_rtx;\n \n+    case BUILT_IN_OBJECT_SIZE:\n+      return expand_builtin_object_size (exp);\n+\n+    case BUILT_IN_MEMCPY_CHK:\n+    case BUILT_IN_MEMPCPY_CHK:\n+    case BUILT_IN_MEMMOVE_CHK:\n+    case BUILT_IN_MEMSET_CHK:\n+      target = expand_builtin_memory_chk (exp, target, mode, fcode);\n+      if (target)\n+\treturn target;\n+      break;\n+\n+    case BUILT_IN_STRCPY_CHK:\n+    case BUILT_IN_STPCPY_CHK:\n+    case BUILT_IN_STRNCPY_CHK:\n+    case BUILT_IN_STRCAT_CHK:\n+    case BUILT_IN_SNPRINTF_CHK:\n+    case BUILT_IN_VSNPRINTF_CHK:\n+      maybe_emit_chk_warning (exp, fcode);\n+      break;\n+\n+    case BUILT_IN_SPRINTF_CHK:\n+    case BUILT_IN_VSPRINTF_CHK:\n+      maybe_emit_sprintf_chk_warning (exp, fcode);\n+      break;\n+\n     default:\t/* just do library call, if unknown builtin */\n       break;\n     }\n@@ -8787,6 +8825,48 @@ fold_builtin_1 (tree fndecl, tree arglist, bool ignore)\n     case BUILT_IN_VA_START:\n       break;\n \n+    case BUILT_IN_OBJECT_SIZE:\n+      return fold_builtin_object_size (arglist);\n+    case BUILT_IN_MEMCPY_CHK:\n+    case BUILT_IN_MEMPCPY_CHK:\n+    case BUILT_IN_MEMMOVE_CHK:\n+    case BUILT_IN_MEMSET_CHK:\n+      return fold_builtin_memory_chk (fndecl, arglist, NULL_TREE, ignore,\n+\t\t\t\t      DECL_FUNCTION_CODE (fndecl));\n+    case BUILT_IN_STRCPY_CHK:\n+    case BUILT_IN_STPCPY_CHK:\n+      return fold_builtin_stxcpy_chk (fndecl, arglist, NULL_TREE, ignore,\n+\t\t\t\t      DECL_FUNCTION_CODE (fndecl));\n+    case BUILT_IN_STRNCPY_CHK:\n+      return fold_builtin_strncpy_chk (arglist, NULL_TREE);\n+    case BUILT_IN_STRCAT_CHK:\n+      return fold_builtin_strcat_chk (fndecl, arglist);\n+    case BUILT_IN_STRNCAT_CHK:\n+      return fold_builtin_strncat_chk (fndecl, arglist);\n+    case BUILT_IN_SPRINTF_CHK:\n+    case BUILT_IN_VSPRINTF_CHK:\n+      return fold_builtin_sprintf_chk (arglist, DECL_FUNCTION_CODE (fndecl));\n+    case BUILT_IN_SNPRINTF_CHK:\n+    case BUILT_IN_VSNPRINTF_CHK:\n+      return fold_builtin_snprintf_chk (arglist, NULL_TREE,\n+\t\t\t\t\tDECL_FUNCTION_CODE (fndecl));\n+\n+    case BUILT_IN_PRINTF:\n+    case BUILT_IN_PRINTF_UNLOCKED:\n+    case BUILT_IN_VPRINTF:\n+    case BUILT_IN_PRINTF_CHK:\n+    case BUILT_IN_VPRINTF_CHK:\n+      return fold_builtin_printf (fndecl, arglist, ignore,\n+\t\t\t\t  DECL_FUNCTION_CODE (fndecl));\n+\n+    case BUILT_IN_FPRINTF:\n+    case BUILT_IN_FPRINTF_UNLOCKED:\n+    case BUILT_IN_VFPRINTF:\n+    case BUILT_IN_FPRINTF_CHK:\n+    case BUILT_IN_VFPRINTF_CHK:\n+      return fold_builtin_fprintf (fndecl, arglist, ignore,\n+\t\t\t\t   DECL_FUNCTION_CODE (fndecl));\n+\n     default:\n       break;\n     }\n@@ -9238,7 +9318,7 @@ fold_builtin_strncat (tree arglist)\n       const char *p = c_getstr (src);\n \n       /* If the requested length is zero, or the src parameter string\n-          length is zero, return the dst parameter.  */\n+\t length is zero, return the dst parameter.  */\n       if (integer_zerop (len) || (p && *p == '\\0'))\n         return omit_two_operands (TREE_TYPE (dst), dst, src, len);\n \n@@ -9535,7 +9615,7 @@ fold_builtin_sprintf (tree arglist, int ignored)\n      'sprintf (dest, \"%s\", orig)'.  */\n   if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE)\n       && !validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, POINTER_TYPE,\n-\t                    VOID_TYPE))\n+\t\t\t    VOID_TYPE))\n     return NULL_TREE;\n \n   /* Get the destination string and the format specifier.  */\n@@ -9599,3 +9679,1144 @@ fold_builtin_sprintf (tree arglist, int ignored)\n   else\n     return call;\n }\n+\n+/* Expand a call to __builtin_object_size.  */\n+\n+rtx\n+expand_builtin_object_size (tree exp)\n+{\n+  tree ost;\n+  int object_size_type;\n+  tree fndecl = get_callee_fndecl (exp);\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  location_t locus = EXPR_LOCATION (exp);\n+\n+  if (!validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n+    {\n+      error (\"%Hfirst argument of %D must be a pointer, second integer constant\",\n+\t     &locus, fndecl);\n+      expand_builtin_trap ();\n+      return const0_rtx;\n+    }\n+\n+  ost = TREE_VALUE (TREE_CHAIN (arglist));\n+  STRIP_NOPS (ost);\n+\n+  if (TREE_CODE (ost) != INTEGER_CST\n+      || tree_int_cst_sgn (ost) < 0\n+      || compare_tree_int (ost, 3) > 0)\n+    {\n+      error (\"%Hlast argument of %D is not integer constant between 0 and 3\",\n+\t     &locus, fndecl);\n+      expand_builtin_trap ();\n+      return const0_rtx;\n+    }\n+\n+  object_size_type = tree_low_cst (ost, 0);\n+\n+  return object_size_type < 2 ? constm1_rtx : const0_rtx;\n+}\n+\n+/* Expand EXP, a call to the __mem{cpy,pcpy,move,set}_chk builtin.\n+   FCODE is the BUILT_IN_* to use.\n+   Return 0 if we failed; the caller should emit a normal call,\n+   otherwise try to get the result in TARGET, if convenient (and in\n+   mode MODE if that's convenient).  */\n+\n+static rtx\n+expand_builtin_memory_chk (tree exp, rtx target, enum machine_mode mode,\n+\t\t\t   enum built_in_function fcode)\n+{\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  tree dest, src, len, size;\n+\n+  if (!validate_arglist (arglist,\n+\t\t\t POINTER_TYPE,\n+\t\t\t fcode == BUILT_IN_MEMSET_CHK\n+\t\t\t ? INTEGER_TYPE : POINTER_TYPE,\n+\t\t\t INTEGER_TYPE, INTEGER_TYPE, VOID_TYPE))\n+    return 0;\n+\n+  dest = TREE_VALUE (arglist);\n+  src = TREE_VALUE (TREE_CHAIN (arglist));\n+  len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+  size = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (arglist))));\n+\n+  if (! host_integerp (size, 1))\n+    return 0;\n+\n+  if (host_integerp (len, 1) || integer_all_onesp (size))\n+    {\n+      tree fn;\n+\n+      if (! integer_all_onesp (size) && tree_int_cst_lt (size, len))\n+\t{\n+\t  location_t locus = EXPR_LOCATION (exp);\n+\t  warning (0, \"%Hcall to %D will always overflow destination buffer\",\n+\t\t   &locus, get_callee_fndecl (exp));\n+\t  return 0;\n+\t}\n+\n+      arglist = build_tree_list (NULL_TREE, len);\n+      arglist = tree_cons (NULL_TREE, src, arglist);\n+      arglist = tree_cons (NULL_TREE, dest, arglist);\n+\n+      fn = NULL_TREE;\n+      /* If __builtin_mem{cpy,pcpy,move,set}_chk is used, assume\n+\t mem{cpy,pcpy,move,set} is available.  */\n+      switch (fcode)\n+\t{\n+\tcase BUILT_IN_MEMCPY_CHK:\n+\t  fn = built_in_decls[BUILT_IN_MEMCPY];\n+\t  break;\n+\tcase BUILT_IN_MEMPCPY_CHK:\n+\t  fn = built_in_decls[BUILT_IN_MEMPCPY];\n+\t  break;\n+\tcase BUILT_IN_MEMMOVE_CHK:\n+\t  fn = built_in_decls[BUILT_IN_MEMMOVE];\n+\t  break;\n+\tcase BUILT_IN_MEMSET_CHK:\n+\t  fn = built_in_decls[BUILT_IN_MEMSET];\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+\n+      if (! fn)\n+\treturn 0;\n+\n+      fn = build_function_call_expr (fn, arglist);\n+      if (TREE_CODE (fn) == CALL_EXPR)\n+\tCALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (exp);\n+      return expand_expr (fn, target, mode, EXPAND_NORMAL);\n+    }\n+  else if (fcode == BUILT_IN_MEMSET_CHK)\n+    return 0;\n+  else\n+    {\n+      unsigned int dest_align\n+\t= get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n+\n+      /* If DEST is not a pointer type, call the normal function.  */\n+      if (dest_align == 0)\n+\treturn 0;\n+\n+      /* If SRC and DEST are the same (and not volatile), do nothing.  */\n+      if (operand_equal_p (src, dest, 0))\n+\t{\n+\t  tree expr;\n+\n+\t  if (fcode != BUILT_IN_MEMPCPY_CHK)\n+\t    {\n+\t      /* Evaluate and ignore LEN in case it has side-effects.  */\n+\t      expand_expr (len, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\t      return expand_expr (dest, target, mode, EXPAND_NORMAL);\n+\t    }\n+\n+\t  len = fold_convert (TREE_TYPE (dest), len);\n+\t  expr = fold_build2 (PLUS_EXPR, TREE_TYPE (dest), dest, len);\n+\t  return expand_expr (expr, target, mode, EXPAND_NORMAL);\n+\t}\n+\n+      /* __memmove_chk special case.  */\n+      if (fcode == BUILT_IN_MEMMOVE_CHK)\n+\t{\n+\t  unsigned int src_align\n+\t    = get_pointer_alignment (src, BIGGEST_ALIGNMENT);\n+\n+\t  if (src_align == 0)\n+\t    return 0;\n+\n+\t  /* If src is categorized for a readonly section we can use\n+\t     normal __memcpy_chk.  */\n+\t  if (readonly_data_expr (src))\n+\t    {\n+\t      tree fn = built_in_decls[BUILT_IN_MEMCPY_CHK];\n+\t      if (!fn)\n+\t\treturn 0;\n+\t      fn = build_function_call_expr (fn, arglist);\n+\t      if (TREE_CODE (fn) == CALL_EXPR)\n+\t\tCALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (exp);\n+\t      return expand_expr (fn, target, mode, EXPAND_NORMAL);\n+\t    }\n+\t}\n+      return 0;\n+    }\n+}\n+\n+/* Emit warning if a buffer overflow is detected at compile time.  */\n+\n+static void\n+maybe_emit_chk_warning (tree exp, enum built_in_function fcode)\n+{\n+  int arg_mask, is_strlen = 0;\n+  tree arglist = TREE_OPERAND (exp, 1), a;\n+  tree len, size;\n+  location_t locus;\n+\n+  switch (fcode)\n+    {\n+    case BUILT_IN_STRCPY_CHK:\n+    case BUILT_IN_STPCPY_CHK:\n+    /* For __strcat_chk the warning will be emitted only if overflowing\n+       by at least strlen (dest) + 1 bytes.  */\n+    case BUILT_IN_STRCAT_CHK:\n+      arg_mask = 6;\n+      is_strlen = 1;\n+      break;\n+    case BUILT_IN_STRNCPY_CHK:\n+      arg_mask = 12;\n+      break;\n+    case BUILT_IN_SNPRINTF_CHK:\n+    case BUILT_IN_VSNPRINTF_CHK:\n+      arg_mask = 10;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  len = NULL_TREE;\n+  size = NULL_TREE;\n+  for (a = arglist; a && arg_mask; a = TREE_CHAIN (a), arg_mask >>= 1)\n+    if (arg_mask & 1)\n+      {\n+\tif (len)\n+\t  size = a;\n+\telse\n+\t  len = a;\n+      }\n+\n+  if (!len || !size)\n+    return;\n+\n+  len = TREE_VALUE (len);\n+  size = TREE_VALUE (size);\n+\n+  if (! host_integerp (size, 1) || integer_all_onesp (size))\n+    return;\n+\n+  if (is_strlen)\n+    {\n+      len = c_strlen (len, 1);\n+      if (! len || ! host_integerp (len, 1) || tree_int_cst_lt (len, size))\n+\treturn;\n+    }\n+  else if (! host_integerp (len, 1) || ! tree_int_cst_lt (size, len))\n+    return;\n+\n+  locus = EXPR_LOCATION (exp);\n+  warning (0, \"%Hcall to %D will always overflow destination buffer\",\n+\t   &locus, get_callee_fndecl (exp));\n+}\n+\n+/* Emit warning if a buffer overflow is detected at compile time\n+   in __sprintf_chk/__vsprintf_chk calls.  */\n+\n+static void\n+maybe_emit_sprintf_chk_warning (tree exp, enum built_in_function fcode)\n+{\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  tree dest, size, len, fmt, flag;\n+  const char *fmt_str;\n+\n+  /* Verify the required arguments in the original call.  */\n+  if (! arglist)\n+    return;\n+  dest = TREE_VALUE (arglist);\n+  arglist = TREE_CHAIN (arglist);\n+  if (! arglist)\n+    return;\n+  flag = TREE_VALUE (arglist);\n+  arglist = TREE_CHAIN (arglist);\n+  if (! arglist)\n+    return;\n+  size = TREE_VALUE (arglist);\n+  arglist = TREE_CHAIN (arglist);\n+  if (! arglist)\n+    return;\n+  fmt = TREE_VALUE (arglist);\n+  arglist = TREE_CHAIN (arglist);\n+\n+  if (! host_integerp (size, 1) || integer_all_onesp (size))\n+    return;\n+\n+  /* Check whether the format is a literal string constant.  */\n+  fmt_str = c_getstr (fmt);\n+  if (fmt_str == NULL)\n+    return;\n+\n+  /* If the format doesn't contain % args or %%, we know its size.  */\n+  if (strchr (fmt_str, '%') == 0)\n+    len = build_int_cstu (size_type_node, strlen (fmt_str));\n+  /* If the format is \"%s\" and first ... argument is a string literal,\n+     we know it too.  */\n+  else if (fcode == BUILT_IN_SPRINTF_CHK && strcmp (fmt_str, \"%s\") == 0)\n+    {\n+      tree arg;\n+\n+      if (! arglist)\n+\treturn;\n+      arg = TREE_VALUE (arglist);\n+      if (! POINTER_TYPE_P (TREE_TYPE (arg)))\n+\treturn;\n+\n+      len = c_strlen (arg, 1);\n+      if (!len || ! host_integerp (len, 1))\n+\treturn;\n+    }\n+  else\n+    return;\n+\n+  if (! tree_int_cst_lt (len, size))\n+    {\n+      location_t locus = EXPR_LOCATION (exp);\n+      warning (0, \"%Hcall to %D will always overflow destination buffer\",\n+\t       &locus, get_callee_fndecl (exp));\n+    }\n+}\n+\n+/* Fold a call to __builtin_object_size, if possible.  */\n+\n+tree\n+fold_builtin_object_size (tree arglist)\n+{\n+  tree ptr, ost, ret = 0;\n+  int object_size_type;\n+\n+  if (!validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n+    return 0;\n+\n+  ptr = TREE_VALUE (arglist);\n+  ost = TREE_VALUE (TREE_CHAIN (arglist));\n+  STRIP_NOPS (ost);\n+\n+  if (TREE_CODE (ost) != INTEGER_CST\n+      || tree_int_cst_sgn (ost) < 0\n+      || compare_tree_int (ost, 3) > 0)\n+    return 0;\n+\n+  object_size_type = tree_low_cst (ost, 0);\n+\n+  /* __builtin_object_size doesn't evaluate side-effects in its arguments;\n+     if there are any side-effects, it returns (size_t) -1 for types 0 and 1\n+     and (size_t) 0 for types 2 and 3.  */\n+  if (TREE_SIDE_EFFECTS (ptr))\n+    return fold_convert (size_type_node,\n+\t\t\t object_size_type < 2\n+\t\t\t ? integer_minus_one_node : integer_zero_node);\n+\n+  if (TREE_CODE (ptr) == ADDR_EXPR)\n+    ret = build_int_cstu (size_type_node,\n+\t\t\tcompute_builtin_object_size (ptr, object_size_type));\n+\n+  else if (TREE_CODE (ptr) == SSA_NAME)\n+    {\n+      unsigned HOST_WIDE_INT bytes;\n+\n+      /* If object size is not known yet, delay folding until\n+       later.  Maybe subsequent passes will help determining\n+       it.  */\n+      bytes = compute_builtin_object_size (ptr, object_size_type);\n+      if (bytes != (unsigned HOST_WIDE_INT) (object_size_type < 2\n+\t\t\t\t\t     ? -1 : 0))\n+\tret = build_int_cstu (size_type_node, bytes);\n+    }\n+\n+  if (ret)\n+    {\n+      ret = force_fit_type (ret, -1, false, false);\n+      if (TREE_CONSTANT_OVERFLOW (ret))\n+\tret = 0;\n+    }\n+\n+  return ret;\n+}\n+\n+/* Fold a call to the __mem{cpy,pcpy,move,set}_chk builtin.\n+   IGNORE is true, if return value can be ignored.  FCODE is the BUILT_IN_*\n+   code of the builtin.  If MAXLEN is not NULL, it is maximum length\n+   passed as third argument.  */\n+\n+tree\n+fold_builtin_memory_chk (tree fndecl, tree arglist, tree maxlen, bool ignore,\n+\t\t\t enum built_in_function fcode)\n+{\n+  tree dest, src, len, size, fn;\n+\n+  if (!validate_arglist (arglist,\n+\t\t\t POINTER_TYPE,\n+\t\t\t fcode == BUILT_IN_MEMSET_CHK\n+\t\t\t ? INTEGER_TYPE : POINTER_TYPE,\n+\t\t\t INTEGER_TYPE, INTEGER_TYPE, VOID_TYPE))\n+    return 0;\n+\n+  dest = TREE_VALUE (arglist);\n+  /* Actually val for __memset_chk, but it doesn't matter.  */\n+  src = TREE_VALUE (TREE_CHAIN (arglist));\n+  len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+  size = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (arglist))));\n+\n+  /* If SRC and DEST are the same (and not volatile), return DEST\n+     (resp. DEST+LEN for __mempcpy_chk).  */\n+  if (fcode != BUILT_IN_MEMSET_CHK && operand_equal_p (src, dest, 0))\n+    {\n+      if (fcode != BUILT_IN_MEMPCPY_CHK)\n+\treturn omit_one_operand (TREE_TYPE (TREE_TYPE (fndecl)), dest, len);\n+      else\n+\t{\n+\t  tree temp = fold_convert (TREE_TYPE (dest), len);\n+\t  temp = fold_build2 (PLUS_EXPR, TREE_TYPE (dest), dest, temp);\n+\t  return fold_convert (TREE_TYPE (TREE_TYPE (fndecl)), temp);\n+\t}\n+    }\n+\n+  if (! host_integerp (size, 1))\n+    return 0;\n+\n+  if (! integer_all_onesp (size))\n+    {\n+      if (! host_integerp (len, 1))\n+\t{\n+\t  /* If LEN is not constant, try MAXLEN too.\n+\t     For MAXLEN only allow optimizing into non-_ocs function\n+\t     if SIZE is >= MAXLEN, never convert to __ocs_fail ().  */\n+\t  if (maxlen == NULL_TREE || ! host_integerp (maxlen, 1))\n+\t    {\n+\t      if (fcode == BUILT_IN_MEMPCPY_CHK && ignore)\n+\t\t{\n+\t\t  /* (void) __mempcpy_chk () can be optimized into\n+\t\t     (void) __memcpy_chk ().  */\n+\t\t  fn = built_in_decls[BUILT_IN_MEMCPY_CHK];\n+\t\t  if (!fn)\n+\t\t    return 0;\n+\n+\t\t  return build_function_call_expr (fn, arglist);\n+\t\t}\n+\t      return 0;\n+\t    }\n+\t  len = maxlen;\n+\t}\n+\n+      if (tree_int_cst_lt (size, len))\n+\treturn 0;\n+    }\n+\n+  arglist = build_tree_list (NULL_TREE, len);\n+  arglist = tree_cons (NULL_TREE, src, arglist);\n+  arglist = tree_cons (NULL_TREE, dest, arglist);\n+\n+  fn = NULL_TREE;\n+  /* If __builtin_mem{cpy,pcpy,move,set}_chk is used, assume\n+     mem{cpy,pcpy,move,set} is available.  */\n+  switch (fcode)\n+    {\n+    case BUILT_IN_MEMCPY_CHK:\n+      fn = built_in_decls[BUILT_IN_MEMCPY];\n+      break;\n+    case BUILT_IN_MEMPCPY_CHK:\n+      fn = built_in_decls[BUILT_IN_MEMPCPY];\n+      break;\n+    case BUILT_IN_MEMMOVE_CHK:\n+      fn = built_in_decls[BUILT_IN_MEMMOVE];\n+      break;\n+    case BUILT_IN_MEMSET_CHK:\n+      fn = built_in_decls[BUILT_IN_MEMSET];\n+      break;\n+    default:\n+      break;\n+    }\n+\n+  if (!fn)\n+    return 0;\n+\n+  return build_function_call_expr (fn, arglist);\n+}\n+\n+/* Fold a call to the __st[rp]cpy_chk builtin.\n+   IGNORE is true, if return value can be ignored.  FCODE is the BUILT_IN_*\n+   code of the builtin.  If MAXLEN is not NULL, it is maximum length of\n+   strings passed as second argument.  */\n+\n+tree\n+fold_builtin_stxcpy_chk (tree fndecl, tree arglist, tree maxlen, bool ignore,\n+\t\t\t enum built_in_function fcode)\n+{\n+  tree dest, src, size, len, fn;\n+\n+  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE,\n+\t\t\t VOID_TYPE))\n+    return 0;\n+\n+  dest = TREE_VALUE (arglist);\n+  src = TREE_VALUE (TREE_CHAIN (arglist));\n+  size = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+\n+  /* If SRC and DEST are the same (and not volatile), return DEST.  */\n+  if (fcode == BUILT_IN_STRCPY_CHK && operand_equal_p (src, dest, 0))\n+    return fold_convert (TREE_TYPE (TREE_TYPE (fndecl)), dest);\n+ \n+  if (! host_integerp (size, 1))\n+    return 0;\n+\n+  if (! integer_all_onesp (size))\n+    {\n+      len = c_strlen (src, 1);\n+      if (! len || ! host_integerp (len, 1))\n+\t{\n+\t  /* If LEN is not constant, try MAXLEN too.\n+\t     For MAXLEN only allow optimizing into non-_ocs function\n+\t     if SIZE is >= MAXLEN, never convert to __ocs_fail ().  */\n+\t  if (maxlen == NULL_TREE || ! host_integerp (maxlen, 1))\n+\t    {\n+\t      if (fcode == BUILT_IN_STPCPY_CHK)\n+\t\t{\n+\t\t  if (! ignore)\n+\t\t    return 0;\n+\n+\t\t  /* If return value of __stpcpy_chk is ignored,\n+\t\t     optimize into __strcpy_chk.  */\n+\t\t  fn = built_in_decls[BUILT_IN_STRCPY_CHK];\n+\t\t  if (!fn)\n+\t\t    return 0;\n+\n+\t\t  return build_function_call_expr (fn, arglist);\n+\t\t}\n+\n+\t      if (! len || TREE_SIDE_EFFECTS (len))\n+\t\treturn 0;\n+\n+\t      /* If c_strlen returned something, but not a constant,\n+\t\t transform __strcpy_chk into __memcpy_chk.  */\n+\t      fn = built_in_decls[BUILT_IN_MEMCPY_CHK];\n+\t      if (!fn)\n+\t\treturn 0;\n+\n+\t      len = size_binop (PLUS_EXPR, len, ssize_int (1));\n+\t      arglist = build_tree_list (NULL_TREE, size);\n+\t      arglist = tree_cons (NULL_TREE, len, arglist);\n+\t      arglist = tree_cons (NULL_TREE, src, arglist);\n+\t      arglist = tree_cons (NULL_TREE, dest, arglist);\n+\t      return fold_convert (TREE_TYPE (TREE_TYPE (fndecl)),\n+\t\t\t\t   build_function_call_expr (fn, arglist));\n+\t    }\n+\t  len = maxlen;\n+\t}\n+      \n+      if (! tree_int_cst_lt (len, size))\n+\treturn 0;\n+    }\n+\n+  arglist = build_tree_list (NULL_TREE, src);\n+  arglist = tree_cons (NULL_TREE, dest, arglist);\n+\n+  /* If __builtin_st{r,p}cpy_chk is used, assume st{r,p}cpy is available.  */\n+  fn = built_in_decls[fcode == BUILT_IN_STPCPY_CHK\n+\t\t      ? BUILT_IN_STPCPY : BUILT_IN_STRCPY];\n+  if (!fn)\n+    return 0;\n+\n+  return build_function_call_expr (fn, arglist);\n+}\n+\n+/* Fold a call to the __strncpy_chk builtin.\n+   If MAXLEN is not NULL, it is maximum length passed as third argument.  */\n+\n+tree\n+fold_builtin_strncpy_chk (tree arglist, tree maxlen)\n+{\n+  tree dest, src, size, len, fn;\n+\n+  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE,\n+\t\t\t INTEGER_TYPE, VOID_TYPE))\n+    return 0;\n+\n+  dest = TREE_VALUE (arglist);\n+  src = TREE_VALUE (TREE_CHAIN (arglist));\n+  len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+  size = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (arglist))));\n+\n+  if (! host_integerp (size, 1))\n+    return 0;\n+\n+  if (! integer_all_onesp (size))\n+    {\n+      if (! host_integerp (len, 1))\n+\t{\n+\t  /* If LEN is not constant, try MAXLEN too.\n+\t     For MAXLEN only allow optimizing into non-_ocs function\n+\t     if SIZE is >= MAXLEN, never convert to __ocs_fail ().  */\n+\t  if (maxlen == NULL_TREE || ! host_integerp (maxlen, 1))\n+\t    return 0;\n+\t  len = maxlen;\n+\t}\n+\n+      if (tree_int_cst_lt (size, len))\n+\treturn 0;\n+    }\n+\n+  arglist = build_tree_list (NULL_TREE, len);\n+  arglist = tree_cons (NULL_TREE, src, arglist);\n+  arglist = tree_cons (NULL_TREE, dest, arglist);\n+\n+  /* If __builtin_strncpy_chk is used, assume strncpy is available.  */\n+  fn = built_in_decls[BUILT_IN_STRNCPY];\n+  if (!fn)\n+    return 0;\n+\n+  return build_function_call_expr (fn, arglist);\n+}\n+\n+/* Fold a call to the __strcat_chk builtin FNDECL with ARGLIST.  */\n+\n+static tree\n+fold_builtin_strcat_chk (tree fndecl, tree arglist)\n+{\n+  tree dest, src, size, fn;\n+  const char *p;\n+\n+  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE,\n+\t\t\t VOID_TYPE))\n+    return 0;\n+\n+  dest = TREE_VALUE (arglist);\n+  src = TREE_VALUE (TREE_CHAIN (arglist));\n+  size = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+\n+  p = c_getstr (src);\n+  /* If the SRC parameter is \"\", return DEST.  */\n+  if (p && *p == '\\0')\n+    return omit_one_operand (TREE_TYPE (TREE_TYPE (fndecl)), dest, src);\n+\n+  if (! host_integerp (size, 1) || ! integer_all_onesp (size))\n+    return 0;\n+\n+  arglist = build_tree_list (NULL_TREE, src);\n+  arglist = tree_cons (NULL_TREE, dest, arglist);\n+\n+  /* If __builtin_strcat_chk is used, assume strcat is available.  */\n+  fn = built_in_decls[BUILT_IN_STRCAT];\n+  if (!fn)\n+    return 0;\n+\n+  return build_function_call_expr (fn, arglist);\n+}\n+\n+/* Fold a call to the __strncat_chk builtin EXP.  */\n+\n+static tree\n+fold_builtin_strncat_chk (tree fndecl, tree arglist)\n+{\n+  tree dest, src, size, len, fn;\n+  const char *p;\n+\n+  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE,\n+\t\t\t INTEGER_TYPE, VOID_TYPE))\n+    return 0;\n+\n+  dest = TREE_VALUE (arglist);\n+  src = TREE_VALUE (TREE_CHAIN (arglist));\n+  len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+  size = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (arglist))));\n+\n+  p = c_getstr (src);\n+  /* If the SRC parameter is \"\" or if LEN is 0, return DEST.  */\n+  if (p && *p == '\\0')\n+    return omit_one_operand (TREE_TYPE (TREE_TYPE (fndecl)), dest, len);\n+  else if (integer_zerop (len))\n+    return omit_one_operand (TREE_TYPE (TREE_TYPE (fndecl)), dest, src);\n+\n+  if (! host_integerp (size, 1))\n+    return 0;\n+\n+  if (! integer_all_onesp (size))\n+    {\n+      tree src_len = c_strlen (src, 1);\n+      if (src_len\n+\t  && host_integerp (src_len, 1)\n+\t  && host_integerp (len, 1)\n+\t  && ! tree_int_cst_lt (len, src_len))\n+\t{\n+\t  /* If LEN >= strlen (SRC), optimize into __strcat_chk.  */\n+\t  fn = built_in_decls[BUILT_IN_STRCAT_CHK];\n+\t  if (!fn)\n+\t    return 0;\n+\n+\t  arglist = build_tree_list (NULL_TREE, size);\n+\t  arglist = tree_cons (NULL_TREE, src, arglist);\n+\t  arglist = tree_cons (NULL_TREE, dest, arglist);\n+\t  return build_function_call_expr (fn, arglist);\n+\t}\n+      return 0;\n+    }\n+\n+  arglist = build_tree_list (NULL_TREE, len);\n+  arglist = tree_cons (NULL_TREE, src, arglist);\n+  arglist = tree_cons (NULL_TREE, dest, arglist);\n+\n+  /* If __builtin_strncat_chk is used, assume strncat is available.  */\n+  fn = built_in_decls[BUILT_IN_STRNCAT];\n+  if (!fn)\n+    return 0;\n+\n+  return build_function_call_expr (fn, arglist);\n+}\n+\n+/* Fold a call to __{,v}sprintf_chk with argument list ARGLIST.  Return 0 if\n+   a normal call should be emitted rather than expanding the function\n+   inline.  FCODE is either BUILT_IN_SPRINTF_CHK or BUILT_IN_VSPRINTF_CHK.  */\n+\n+static tree\n+fold_builtin_sprintf_chk (tree arglist, enum built_in_function fcode)\n+{\n+  tree dest, size, len, fn, fmt, flag;\n+  const char *fmt_str;\n+\n+  /* Verify the required arguments in the original call.  */\n+  if (! arglist)\n+    return 0;\n+  dest = TREE_VALUE (arglist);\n+  if (! POINTER_TYPE_P (TREE_TYPE (dest)))\n+    return 0;\n+  arglist = TREE_CHAIN (arglist);\n+  if (! arglist)\n+    return 0;\n+  flag = TREE_VALUE (arglist);\n+  if (TREE_CODE (TREE_TYPE (flag)) != INTEGER_TYPE)\n+    return 0;\n+  arglist = TREE_CHAIN (arglist);\n+  if (! arglist)\n+    return 0;\n+  size = TREE_VALUE (arglist);\n+  if (TREE_CODE (TREE_TYPE (size)) != INTEGER_TYPE)\n+    return 0;\n+  arglist = TREE_CHAIN (arglist);\n+  if (! arglist)\n+    return 0;\n+  fmt = TREE_VALUE (arglist);\n+  if (! POINTER_TYPE_P (TREE_TYPE (fmt)))\n+    return 0;\n+  arglist = TREE_CHAIN (arglist);\n+\n+  if (! host_integerp (size, 1))\n+    return 0;\n+\n+  len = NULL_TREE;\n+\n+  /* Check whether the format is a literal string constant.  */\n+  fmt_str = c_getstr (fmt);\n+  if (fmt_str != NULL)\n+    {\n+      /* If the format doesn't contain % args or %%, we know the size.  */\n+      if (strchr (fmt_str, '%') == 0)\n+\t{\n+\t  if (fcode != BUILT_IN_SPRINTF_CHK || arglist == NULL_TREE)\n+\t    len = build_int_cstu (size_type_node, strlen (fmt_str));\n+\t}\n+      /* If the format is \"%s\" and first ... argument is a string literal,\n+\t we know the size too.  */\n+      else if (fcode == BUILT_IN_SPRINTF_CHK && strcmp (fmt_str, \"%s\") == 0)\n+\t{\n+\t  tree arg;\n+\n+\t  if (arglist && !TREE_CHAIN (arglist))\n+\t    {\n+\t      arg = TREE_VALUE (arglist);\n+\t      if (POINTER_TYPE_P (TREE_TYPE (arg)))\n+\t\t{\n+\t\t  len = c_strlen (arg, 1);\n+\t\t  if (! len || ! host_integerp (len, 1))\n+\t\t    len = NULL_TREE;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  if (! integer_all_onesp (size))\n+    {\n+      if (! len || ! tree_int_cst_lt (len, size))\n+\treturn 0;\n+    }\n+\n+  /* Only convert __{,v}sprintf_chk to {,v}sprintf if flag is 0\n+     or if format doesn't contain % chars or is \"%s\".  */\n+  if (! integer_zerop (flag))\n+    {\n+      if (fmt_str == NULL)\n+\treturn 0;\n+      if (strchr (fmt_str, '%') != NULL && strcmp (fmt_str, \"%s\"))\n+\treturn 0;\n+    }\n+\n+  arglist = tree_cons (NULL_TREE, fmt, arglist);\n+  arglist = tree_cons (NULL_TREE, dest, arglist);\n+\n+  /* If __builtin_{,v}sprintf_chk is used, assume {,v}sprintf is available.  */\n+  fn = built_in_decls[fcode == BUILT_IN_VSPRINTF_CHK\n+\t\t      ? BUILT_IN_VSPRINTF : BUILT_IN_SPRINTF];\n+  if (!fn)\n+    return 0;\n+\n+  return build_function_call_expr (fn, arglist);\n+}\n+\n+/* Fold a call to {,v}snprintf with argument list ARGLIST.  Return 0 if\n+   a normal call should be emitted rather than expanding the function\n+   inline.  FCODE is either BUILT_IN_SNPRINTF_CHK or\n+   BUILT_IN_VSNPRINTF_CHK.  If MAXLEN is not NULL, it is maximum length\n+   passed as second argument.  */\n+\n+tree\n+fold_builtin_snprintf_chk (tree arglist, tree maxlen,\n+\t\t\t   enum built_in_function fcode)\n+{\n+  tree dest, size, len, fn, fmt, flag;\n+  const char *fmt_str;\n+\n+  /* Verify the required arguments in the original call.  */\n+  if (! arglist)\n+    return 0;\n+  dest = TREE_VALUE (arglist);\n+  if (! POINTER_TYPE_P (TREE_TYPE (dest)))\n+    return 0;\n+  arglist = TREE_CHAIN (arglist);\n+  if (! arglist)\n+    return 0;\n+  len = TREE_VALUE (arglist);\n+  if (TREE_CODE (TREE_TYPE (len)) != INTEGER_TYPE)\n+    return 0;\n+  arglist = TREE_CHAIN (arglist);\n+  if (! arglist)\n+    return 0;\n+  flag = TREE_VALUE (arglist);\n+  if (TREE_CODE (TREE_TYPE (len)) != INTEGER_TYPE)\n+    return 0;\n+  arglist = TREE_CHAIN (arglist);\n+  if (! arglist)\n+    return 0;\n+  size = TREE_VALUE (arglist);\n+  if (TREE_CODE (TREE_TYPE (size)) != INTEGER_TYPE)\n+    return 0;\n+  arglist = TREE_CHAIN (arglist);\n+  if (! arglist)\n+    return 0;\n+  fmt = TREE_VALUE (arglist);\n+  if (! POINTER_TYPE_P (TREE_TYPE (fmt)))\n+    return 0;\n+  arglist = TREE_CHAIN (arglist);\n+\n+  if (! host_integerp (size, 1))\n+    return 0;\n+\n+  if (! integer_all_onesp (size))\n+    {\n+      if (! host_integerp (len, 1))\n+\t{\n+\t  /* If LEN is not constant, try MAXLEN too.\n+\t     For MAXLEN only allow optimizing into non-_ocs function\n+\t     if SIZE is >= MAXLEN, never convert to __ocs_fail ().  */\n+\t  if (maxlen == NULL_TREE || ! host_integerp (maxlen, 1))\n+\t    return 0;\n+\t  len = maxlen;\n+\t}\n+\n+      if (tree_int_cst_lt (size, len))\n+\treturn 0;\n+    }\n+\n+  /* Only convert __{,v}snprintf_chk to {,v}snprintf if flag is 0\n+     or if format doesn't contain % chars or is \"%s\".  */\n+  if (! integer_zerop (flag))\n+    {\n+      fmt_str = c_getstr (fmt);\n+      if (fmt_str == NULL)\n+\treturn 0;\n+      if (strchr (fmt_str, '%') != NULL && strcmp (fmt_str, \"%s\"))\n+\treturn 0;\n+    }\n+\n+  arglist = tree_cons (NULL_TREE, fmt, arglist);\n+  arglist = tree_cons (NULL_TREE, len, arglist);\n+  arglist = tree_cons (NULL_TREE, dest, arglist);\n+\n+  /* If __builtin_{,v}snprintf_chk is used, assume {,v}snprintf is\n+     available.  */\n+  fn = built_in_decls[fcode == BUILT_IN_VSNPRINTF_CHK\n+\t\t      ? BUILT_IN_VSNPRINTF : BUILT_IN_SNPRINTF];\n+  if (!fn)\n+    return 0;\n+\n+  return build_function_call_expr (fn, arglist);\n+}\n+\n+/* Fold a call to the {,v}printf{,_unlocked} and __{,v}printf_chk builtins.\n+\n+   Return 0 if no simplification was possible, otherwise return the\n+   simplified form of the call as a tree.  FCODE is the BUILT_IN_*\n+   code of the function to be simplified.  */\n+\n+static tree\n+fold_builtin_printf (tree fndecl, tree arglist, bool ignore,\n+\t\t     enum built_in_function fcode)\n+{\n+  tree fmt, fn = NULL_TREE, fn_putchar, fn_puts, arg, call;\n+  const char *fmt_str = NULL;\n+\n+  /* If the return value is used, don't do the transformation.  */\n+  if (! ignore)\n+    return 0;\n+\n+  /* Verify the required arguments in the original call.  */\n+  if (fcode == BUILT_IN_PRINTF_CHK || fcode == BUILT_IN_VPRINTF_CHK)\n+    {\n+      tree flag;\n+\n+      if (! arglist)\n+\treturn 0;\n+      flag = TREE_VALUE (arglist);\n+      if (TREE_CODE (TREE_TYPE (flag)) != INTEGER_TYPE\n+\t  || TREE_SIDE_EFFECTS (flag))\n+\treturn 0;\n+      arglist = TREE_CHAIN (arglist);\n+    }\n+\n+  if (! arglist)\n+    return 0;\n+  fmt = TREE_VALUE (arglist);\n+  if (! POINTER_TYPE_P (TREE_TYPE (fmt)))\n+    return 0;\n+  arglist = TREE_CHAIN (arglist);\n+\n+  /* Check whether the format is a literal string constant.  */\n+  fmt_str = c_getstr (fmt);\n+  if (fmt_str == NULL)\n+    return NULL_TREE;\n+\n+  if (fcode == BUILT_IN_PRINTF_UNLOCKED)\n+    {\n+      fn_putchar = implicit_built_in_decls[BUILT_IN_PUTCHAR_UNLOCKED];\n+      fn_puts = implicit_built_in_decls[BUILT_IN_PUTS_UNLOCKED];\n+    }\n+  else\n+    {\n+      fn_putchar = implicit_built_in_decls[BUILT_IN_PUTCHAR];\n+      fn_puts = implicit_built_in_decls[BUILT_IN_PUTS];\n+    }\n+\n+  if (strcmp (fmt_str, \"%s\") == 0 || strchr (fmt_str, '%') == NULL)\n+    {\n+      const char *str;\n+\n+      if (strcmp (fmt_str, \"%s\") == 0)\n+\t{\n+\t  if (fcode == BUILT_IN_VPRINTF || fcode == BUILT_IN_VPRINTF_CHK)\n+\t    return 0;\n+\n+\t  if (! arglist\n+\t      || ! POINTER_TYPE_P (TREE_TYPE (TREE_VALUE (arglist)))\n+\t      || TREE_CHAIN (arglist))\n+\t    return 0;\n+\n+\t  str = c_getstr (TREE_VALUE (arglist));\n+\t  if (str == NULL)\n+\t    return 0;\n+\t}\n+      else\n+\t{\n+\t  /* The format specifier doesn't contain any '%' characters.  */\n+\t  if (fcode != BUILT_IN_VPRINTF && fcode != BUILT_IN_VPRINTF_CHK\n+\t      && arglist)\n+\t    return 0;\n+\t  str = fmt_str;\n+\t}\n+\n+      /* If the string was \"\", printf does nothing.  */\n+      if (str[0] == '\\0')\n+\treturn build_int_cst (TREE_TYPE (TREE_TYPE (fndecl)), 0);\n+\n+      /* If the string has length of 1, call putchar.  */\n+      if (str[1] == '\\0')\n+\t{\n+\t  /* Given printf(\"c\"), (where c is any one character,)\n+\t     convert \"c\"[0] to an int and pass that to the replacement\n+\t     function.  */\n+\t  arg = build_int_cst (NULL_TREE, str[0]);\n+\t  arglist = build_tree_list (NULL_TREE, arg);\n+\t  fn = fn_putchar;\n+\t}\n+      else\n+\t{\n+\t  /* If the string was \"string\\n\", call puts(\"string\").  */\n+\t  size_t len = strlen (str);\n+\t  if (str[len - 1] == '\\n')\n+\t    {\n+\t      /* Create a NUL-terminated string that's one char shorter\n+\t\t than the original, stripping off the trailing '\\n'.  */\n+\t      char *newstr = alloca (len);\n+\t      memcpy (newstr, str, len - 1);\n+\t      newstr[len - 1] = 0;\n+\n+\t      arg = build_string_literal (len, newstr);\n+\t      arglist = build_tree_list (NULL_TREE, arg);\n+\t      fn = fn_puts;\n+\t    }\n+\t  else\n+\t    /* We'd like to arrange to call fputs(string,stdout) here,\n+\t       but we need stdout and don't have a way to get it yet.  */\n+\t    return 0;\n+\t}\n+    }\n+\n+  /* The other optimizations can be done only on the non-va_list variants.  */\n+  else if (fcode == BUILT_IN_VPRINTF || fcode == BUILT_IN_VPRINTF_CHK)\n+    return 0;\n+\n+  /* If the format specifier was \"%s\\n\", call __builtin_puts(arg).  */\n+  else if (strcmp (fmt_str, \"%s\\n\") == 0)\n+    {\n+      if (! arglist\n+\t  || ! POINTER_TYPE_P (TREE_TYPE (TREE_VALUE (arglist)))\n+\t  || TREE_CHAIN (arglist))\n+\treturn 0;\n+      fn = fn_puts;\n+    }\n+\n+  /* If the format specifier was \"%c\", call __builtin_putchar(arg).  */\n+  else if (strcmp (fmt_str, \"%c\") == 0)\n+    {\n+      if (! arglist\n+\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != INTEGER_TYPE\n+\t  || TREE_CHAIN (arglist))\n+\treturn 0;\n+      fn = fn_putchar;\n+    }\n+\n+  if (!fn)\n+    return 0;\n+\n+  call = build_function_call_expr (fn, arglist);\n+  return fold_convert (TREE_TYPE (TREE_TYPE (fndecl)), call);\n+}\n+\n+/* Fold a call to the {,v}fprintf{,_unlocked} and __{,v}printf_chk builtins.\n+\n+   Return 0 if no simplification was possible, otherwise return the\n+   simplified form of the call as a tree.  FCODE is the BUILT_IN_*\n+   code of the function to be simplified.  */\n+\n+static tree\n+fold_builtin_fprintf (tree fndecl, tree arglist, bool ignore,\n+\t\t      enum built_in_function fcode)\n+{\n+  tree fp, fmt, fn = NULL_TREE, fn_fputc, fn_fputs, arg, call;\n+  const char *fmt_str = NULL;\n+\n+  /* If the return value is used, don't do the transformation.  */\n+  if (! ignore)\n+    return 0;\n+\n+  /* Verify the required arguments in the original call.  */\n+  if (! arglist)\n+    return 0;\n+  fp = TREE_VALUE (arglist);\n+  if (! POINTER_TYPE_P (TREE_TYPE (fp)))\n+    return 0;\n+  arglist = TREE_CHAIN (arglist);\n+\n+  if (fcode == BUILT_IN_FPRINTF_CHK || fcode == BUILT_IN_VFPRINTF_CHK)\n+    {\n+      tree flag;\n+\n+      if (! arglist)\n+\treturn 0;\n+      flag = TREE_VALUE (arglist);\n+      if (TREE_CODE (TREE_TYPE (flag)) != INTEGER_TYPE\n+\t  || TREE_SIDE_EFFECTS (flag))\n+\treturn 0;\n+      arglist = TREE_CHAIN (arglist);\n+    }\n+\n+  if (! arglist)\n+    return 0;\n+  fmt = TREE_VALUE (arglist);\n+  if (! POINTER_TYPE_P (TREE_TYPE (fmt)))\n+    return 0;\n+  arglist = TREE_CHAIN (arglist);\n+\n+  /* Check whether the format is a literal string constant.  */\n+  fmt_str = c_getstr (fmt);\n+  if (fmt_str == NULL)\n+    return NULL_TREE;\n+\n+  if (fcode == BUILT_IN_FPRINTF_UNLOCKED)\n+    {\n+      fn_fputc = implicit_built_in_decls[BUILT_IN_FPUTC_UNLOCKED];\n+      fn_fputs = implicit_built_in_decls[BUILT_IN_FPUTS_UNLOCKED];\n+    }\n+  else\n+    {\n+      fn_fputc = implicit_built_in_decls[BUILT_IN_FPUTC];\n+      fn_fputs = implicit_built_in_decls[BUILT_IN_FPUTS];\n+    }\n+\n+  /* If the format doesn't contain % args or %%, use strcpy.  */\n+  if (strchr (fmt_str, '%') == NULL)\n+    {\n+      if (fcode != BUILT_IN_VFPRINTF && fcode != BUILT_IN_VFPRINTF_CHK\n+\t  && arglist)\n+\treturn 0;\n+\n+      /* If the format specifier was \"\", fprintf does nothing.  */\n+      if (fmt_str[0] == '\\0')\n+\t{\n+\t  /* If FP has side-effects, just wait until gimplification is\n+\t     done.  */\n+\t  if (TREE_SIDE_EFFECTS (fp))\n+\t    return 0;\n+\n+\t  return build_int_cst (TREE_TYPE (TREE_TYPE (fndecl)), 0);\n+\t}\n+\n+      /* When \"string\" doesn't contain %, replace all cases of\n+\t fprintf (fp, string) with fputs (string, fp).  The fputs\n+\t builtin will take care of special cases like length == 1.  */\n+      arglist = build_tree_list (NULL_TREE, fp);\n+      arglist = tree_cons (NULL_TREE, fmt, arglist);\n+      fn = fn_fputs;\n+    }\n+\n+  /* The other optimizations can be done only on the non-va_list variants.  */\n+  else if (fcode == BUILT_IN_VFPRINTF || fcode == BUILT_IN_VFPRINTF_CHK)\n+    return 0;\n+\n+  /* If the format specifier was \"%s\", call __builtin_fputs (arg, fp).  */\n+  else if (strcmp (fmt_str, \"%s\") == 0)\n+    {\n+      if (! arglist\n+\t  || ! POINTER_TYPE_P (TREE_TYPE (TREE_VALUE (arglist)))\n+\t  || TREE_CHAIN (arglist))\n+\treturn 0;\n+      arg = TREE_VALUE (arglist);\n+      arglist = build_tree_list (NULL_TREE, fp);\n+      arglist = tree_cons (NULL_TREE, arg, arglist);\n+      fn = fn_fputs;\n+    }\n+\n+  /* If the format specifier was \"%c\", call __builtin_fputc (arg, fp).  */\n+  else if (strcmp (fmt_str, \"%c\") == 0)\n+    {\n+      if (! arglist\n+\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != INTEGER_TYPE\n+\t  || TREE_CHAIN (arglist))\n+\treturn 0;\n+      arg = TREE_VALUE (arglist);\n+      arglist = build_tree_list (NULL_TREE, fp);\n+      arglist = tree_cons (NULL_TREE, arg, arglist);\n+      fn = fn_fputc;\n+    }\n+\n+  if (!fn)\n+    return 0;\n+\n+  call = build_function_call_expr (fn, arglist);\n+  return fold_convert (TREE_TYPE (TREE_TYPE (fndecl)), call);\n+}"}, {"sha": "2f5aa151a4f589aced320af9b233dfe0543b0d51", "filename": "gcc/builtins.def", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -658,6 +658,26 @@ DEF_BUILTIN_STUB (BUILT_IN_NONLOCAL_GOTO, \"__builtin_nonlocal_goto\")\n DEF_BUILTIN_STUB (BUILT_IN_STACK_SAVE, \"__builtin_stack_save\")\n DEF_BUILTIN_STUB (BUILT_IN_STACK_RESTORE, \"__builtin_stack_restore\")\n \n+/* Object size checking builtins.  */\n+DEF_GCC_BUILTIN\t       (BUILT_IN_OBJECT_SIZE, \"object_size\", BT_FN_SIZE_CONST_PTR_INT, ATTR_PURE_NOTHROW_LIST)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_MEMCPY_CHK, \"__memcpy_chk\", BT_FN_PTR_PTR_CONST_PTR_SIZE_SIZE, ATTR_NOTHROW_NONNULL)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_MEMMOVE_CHK, \"__memmove_chk\", BT_FN_PTR_PTR_CONST_PTR_SIZE_SIZE, ATTR_NOTHROW_NONNULL)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_MEMPCPY_CHK, \"__mempcpy_chk\", BT_FN_PTR_PTR_CONST_PTR_SIZE_SIZE, ATTR_NOTHROW_NONNULL)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_MEMSET_CHK, \"__memset_chk\", BT_FN_PTR_PTR_INT_SIZE_SIZE, ATTR_NOTHROW_NONNULL)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_STPCPY_CHK, \"__stpcpy_chk\", BT_FN_STRING_STRING_CONST_STRING_SIZE, ATTR_NOTHROW_NONNULL)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_STRCAT_CHK, \"__strcat_chk\", BT_FN_STRING_STRING_CONST_STRING_SIZE, ATTR_NOTHROW_NONNULL)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_STRCPY_CHK, \"__strcpy_chk\", BT_FN_STRING_STRING_CONST_STRING_SIZE, ATTR_NOTHROW_NONNULL)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_STRNCAT_CHK, \"__strncat_chk\", BT_FN_STRING_STRING_CONST_STRING_SIZE_SIZE, ATTR_NOTHROW_NONNULL)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_STRNCPY_CHK, \"__strncpy_chk\", BT_FN_STRING_STRING_CONST_STRING_SIZE_SIZE, ATTR_NOTHROW_NONNULL)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_SNPRINTF_CHK, \"__snprintf_chk\", BT_FN_INT_STRING_SIZE_INT_SIZE_CONST_STRING_VAR, ATTR_FORMAT_PRINTF_5_6)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_SPRINTF_CHK, \"__sprintf_chk\", BT_FN_INT_STRING_INT_SIZE_CONST_STRING_VAR, ATTR_FORMAT_PRINTF_4_5)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_VSNPRINTF_CHK, \"__vsnprintf_chk\", BT_FN_INT_STRING_SIZE_INT_SIZE_CONST_STRING_VALIST_ARG, ATTR_FORMAT_PRINTF_5_0)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_VSPRINTF_CHK, \"__vsprintf_chk\", BT_FN_INT_STRING_INT_SIZE_CONST_STRING_VALIST_ARG, ATTR_FORMAT_PRINTF_4_0)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_FPRINTF_CHK, \"__fprintf_chk\", BT_FN_INT_FILEPTR_INT_CONST_STRING_VAR, ATTR_FORMAT_PRINTF_3_4)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_PRINTF_CHK, \"__printf_chk\", BT_FN_INT_INT_CONST_STRING_VAR, ATTR_FORMAT_PRINTF_2_3)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_VFPRINTF_CHK, \"__vfprintf_chk\", BT_FN_INT_FILEPTR_INT_CONST_STRING_VALIST_ARG, ATTR_FORMAT_PRINTF_3_0)\n+DEF_EXT_LIB_BUILTIN    (BUILT_IN_VPRINTF_CHK, \"__vprintf_chk\", BT_FN_INT_INT_CONST_STRING_VALIST_ARG, ATTR_FORMAT_PRINTF_2_0)\n+\n /* Profiling hooks.  */\n DEF_BUILTIN_STUB (BUILT_IN_PROFILE_FUNC_ENTER, \"profile_func_enter\")\n DEF_BUILTIN_STUB (BUILT_IN_PROFILE_FUNC_EXIT, \"profile_func_exit\")"}, {"sha": "bcf28090554409bedb079039c3f3ec5659bd8593", "filename": "gcc/c-common.c", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -2924,10 +2924,16 @@ c_common_nodes_and_builtins (void)\n #define DEF_FUNCTION_TYPE_2(NAME, RETURN, ARG1, ARG2) NAME,\n #define DEF_FUNCTION_TYPE_3(NAME, RETURN, ARG1, ARG2, ARG3) NAME,\n #define DEF_FUNCTION_TYPE_4(NAME, RETURN, ARG1, ARG2, ARG3, ARG4) NAME,\n+#define DEF_FUNCTION_TYPE_5(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5) NAME,\n+#define DEF_FUNCTION_TYPE_6(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) \\\n+  NAME,\n #define DEF_FUNCTION_TYPE_VAR_0(NAME, RETURN) NAME,\n #define DEF_FUNCTION_TYPE_VAR_1(NAME, RETURN, ARG1) NAME,\n #define DEF_FUNCTION_TYPE_VAR_2(NAME, RETURN, ARG1, ARG2) NAME,\n #define DEF_FUNCTION_TYPE_VAR_3(NAME, RETURN, ARG1, ARG2, ARG3) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_4(NAME, RETURN, ARG1, ARG2, ARG3, ARG4) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_5(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG6) \\\n+  NAME,\n #define DEF_POINTER_TYPE(NAME, TYPE) NAME,\n #include \"builtin-types.def\"\n #undef DEF_PRIMITIVE_TYPE\n@@ -2936,10 +2942,14 @@ c_common_nodes_and_builtins (void)\n #undef DEF_FUNCTION_TYPE_2\n #undef DEF_FUNCTION_TYPE_3\n #undef DEF_FUNCTION_TYPE_4\n+#undef DEF_FUNCTION_TYPE_5\n+#undef DEF_FUNCTION_TYPE_6\n #undef DEF_FUNCTION_TYPE_VAR_0\n #undef DEF_FUNCTION_TYPE_VAR_1\n #undef DEF_FUNCTION_TYPE_VAR_2\n #undef DEF_FUNCTION_TYPE_VAR_3\n+#undef DEF_FUNCTION_TYPE_VAR_4\n+#undef DEF_FUNCTION_TYPE_VAR_5\n #undef DEF_POINTER_TYPE\n     BT_LAST\n   };\n@@ -3188,6 +3198,42 @@ c_common_nodes_and_builtins (void)\n \t\t\t      tree_cons (NULL_TREE,\t\t\t\\\n \t\t\t\t\t builtin_types[(int) ARG4],\t\\\n \t\t\t\t\t void_list_node)))));\n+#define DEF_FUNCTION_TYPE_5(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5)\t\\\n+  builtin_types[(int) ENUM]\t\t\t\t\t\t\\\n+    = build_function_type\t\t\t\t\t\t\\\n+      (builtin_types[(int) RETURN],\t\t\t\t\t\\\n+       tree_cons (NULL_TREE,\t\t\t\t\t\t\\\n+\t\t  builtin_types[(int) ARG1],\t\t\t\t\\\n+\t\t  tree_cons (NULL_TREE,\t\t\t\t\t\\\n+\t\t\t     builtin_types[(int) ARG2],\t\t\t\\\n+\t\t\t     tree_cons\t\t\t\t\t\\\n+\t\t\t     (NULL_TREE,\t\t\t\t\\\n+\t\t\t      builtin_types[(int) ARG3],\t\t\\\n+\t\t\t      tree_cons (NULL_TREE,\t\t\t\\\n+\t\t\t\t\t builtin_types[(int) ARG4],\t\\\n+\t\t\t\t\t tree_cons (NULL_TREE,\t\t\\\n+\t\t\t\t\t      builtin_types[(int) ARG5],\\\n+\t\t\t\t\t      void_list_node))))));\n+#define DEF_FUNCTION_TYPE_6(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6)\t\t\t\t\t\\\n+  builtin_types[(int) ENUM]\t\t\t\t\t\t\\\n+    = build_function_type\t\t\t\t\t\t\\\n+      (builtin_types[(int) RETURN],\t\t\t\t\t\\\n+       tree_cons (NULL_TREE,\t\t\t\t\t\t\\\n+\t\t  builtin_types[(int) ARG1],\t\t\t\t\\\n+\t\t  tree_cons (NULL_TREE,\t\t\t\t\t\\\n+\t\t\t     builtin_types[(int) ARG2],\t\t\t\\\n+\t\t\t     tree_cons\t\t\t\t\t\\\n+\t\t\t     (NULL_TREE,\t\t\t\t\\\n+\t\t\t      builtin_types[(int) ARG3],\t\t\\\n+\t\t\t      tree_cons\t\t\t\t\t\\\n+\t\t\t      (NULL_TREE,\t\t\t\t\\\n+\t\t\t       builtin_types[(int) ARG4],\t\t\\\n+\t\t\t       tree_cons (NULL_TREE,\t\t\t\\\n+\t\t\t\t\t builtin_types[(int) ARG5],\t\\\n+\t\t\t\t\t tree_cons (NULL_TREE,\t\t\\\n+\t\t\t\t\t      builtin_types[(int) ARG6],\\\n+\t\t\t\t\t      void_list_node)))))));\n #define DEF_FUNCTION_TYPE_VAR_0(ENUM, RETURN)\t\t\t\t\\\n   builtin_types[(int) ENUM]\t\t\t\t\t\t\\\n     = build_function_type (builtin_types[(int) RETURN], NULL_TREE);\n@@ -3220,6 +3266,38 @@ c_common_nodes_and_builtins (void)\n \t\t\t\t\tbuiltin_types[(int) ARG3],\t\\\n \t\t\t\t\tNULL_TREE))));\n \n+#define DEF_FUNCTION_TYPE_VAR_4(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4)\t\\\n+   builtin_types[(int) ENUM]\t\t\t\t\t\t\\\n+    = build_function_type\t\t\t\t\t\t\\\n+      (builtin_types[(int) RETURN],\t\t\t\t\t\\\n+       tree_cons (NULL_TREE,\t\t\t\t\t\t\\\n+\t\t  builtin_types[(int) ARG1],\t\t\t\t\\\n+\t\t  tree_cons (NULL_TREE,\t\t\t\t\t\\\n+\t\t\t     builtin_types[(int) ARG2],\t\t\t\\\n+\t\t\t     tree_cons (NULL_TREE,\t\t\t\\\n+\t\t\t\t\tbuiltin_types[(int) ARG3],\t\\\n+\t\t\t\t\ttree_cons (NULL_TREE,\t\t\\\n+\t\t\t\t\t      builtin_types[(int) ARG4],\\\n+\t\t\t\t\t      NULL_TREE)))));\n+\n+#define DEF_FUNCTION_TYPE_VAR_5(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4,\t\\\n+\t\t\t\tARG5)\t\t\t\t\t\\\n+   builtin_types[(int) ENUM]\t\t\t\t\t\t\\\n+    = build_function_type\t\t\t\t\t\t\\\n+      (builtin_types[(int) RETURN],\t\t\t\t\t\\\n+       tree_cons (NULL_TREE,\t\t\t\t\t\t\\\n+\t\t  builtin_types[(int) ARG1],\t\t\t\t\\\n+\t\t  tree_cons (NULL_TREE,\t\t\t\t\t\\\n+\t\t\t     builtin_types[(int) ARG2],\t\t\t\\\n+\t\t\t     tree_cons\t\t\t\t\t\\\n+\t\t\t     (NULL_TREE,\t\t\t\t\\\n+\t\t\t      builtin_types[(int) ARG3],\t\t\\\n+\t\t\t      tree_cons (NULL_TREE,\t\t\t\\\n+\t\t\t\t\tbuiltin_types[(int) ARG4],\t\\\n+\t\t\t\t\ttree_cons (NULL_TREE,\t\t\\\n+\t\t\t\t\t      builtin_types[(int) ARG5],\\\n+\t\t\t\t\t      NULL_TREE))))));\n+\n #define DEF_POINTER_TYPE(ENUM, TYPE)\t\t\t\\\n   builtin_types[(int) ENUM]\t\t\t\t\\\n     = build_pointer_type (builtin_types[(int) TYPE]);\n@@ -3229,10 +3307,14 @@ c_common_nodes_and_builtins (void)\n #undef DEF_FUNCTION_TYPE_2\n #undef DEF_FUNCTION_TYPE_3\n #undef DEF_FUNCTION_TYPE_4\n+#undef DEF_FUNCTION_TYPE_5\n+#undef DEF_FUNCTION_TYPE_6\n #undef DEF_FUNCTION_TYPE_VAR_0\n #undef DEF_FUNCTION_TYPE_VAR_1\n #undef DEF_FUNCTION_TYPE_VAR_2\n #undef DEF_FUNCTION_TYPE_VAR_3\n+#undef DEF_FUNCTION_TYPE_VAR_4\n+#undef DEF_FUNCTION_TYPE_VAR_5\n #undef DEF_POINTER_TYPE\n \n   c_init_attributes ();"}, {"sha": "b019d3882194680943afbb1408f425b04d364ebc", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -71,6 +71,8 @@ extensions, accepted by GCC in C89 mode and in C++.\n * Vector Extensions::   Using vector instructions through built-in functions.\n * Offsetof::            Special syntax for implementing @code{offsetof}.\n * Atomic Builtins::\tBuilt-in functions for atomic memory access.\n+* Object Size Checking:: Built-in functions for limited buffer overflow\n+                        checking.\n * Other Builtins::      Other built-in functions.\n * Target Builtins::     Built-in functions specific to particular targets.\n * Target Format Checks:: Format checks specific to particular targets.\n@@ -4724,6 +4726,139 @@ previous memory loads have been satisfied, but following memory reads\n are not prevented from being speculated to before the barrier.\n @end table\n \n+@node Object Size Checking\n+@section Object Size Checking Builtins\n+@findex __builtin_object_size\n+@findex __builtin___memcpy_chk\n+@findex __builtin___mempcpy_chk\n+@findex __builtin___memmove_chk\n+@findex __builtin___memset_chk\n+@findex __builtin___strcpy_chk\n+@findex __builtin___stpcpy_chk\n+@findex __builtin___strncpy_chk\n+@findex __builtin___strcat_chk\n+@findex __builtin___strncat_chk\n+@findex __builtin___sprintf_chk\n+@findex __builtin___snprintf_chk\n+@findex __builtin___vsprintf_chk\n+@findex __builtin___vsnprintf_chk\n+@findex __builtin___printf_chk\n+@findex __builtin___vprintf_chk\n+@findex __builtin___fprintf_chk\n+@findex __builtin___vfprintf_chk\n+\n+GCC implements a limited buffer overflow protection mechanism\n+that can prevent some buffer overflow attacks.\n+\n+@deftypefn {Built-in Function} {size_t} __builtin_object_size (void * @var{ptr}, int @var{type})\n+is a built-in construct that returns a constant number of bytes from\n+@var{ptr} to the end of the object @var{ptr} pointer points to\n+(if known at compile time).  @code{__builtin_object_size} never evaluates\n+its arguments for side-effects.  If there are any side-effects in them, it\n+returns @code{(size_t) -1} for @var{type} 0 or 1 and @code{(size_t) 0}\n+for @var{type} 2 or 3.  If there are multiple objects @var{ptr} can\n+point to and all of them are known at compile time, the returned number\n+is the maximum of remaining byte counts in those objects if @var{type} & 2 is\n+0 and minimum if non-zero.  If it is not possible to determine which objects\n+@var{ptr} points to at compile time, @code{__builtin_object_size} should\n+return @code{(size_t) -1} for @var{type} 0 or 1 and @code{(size_t) 0}\n+for @var{type} 2 or 3.\n+\n+@var{type} is an integer constant from 0 to 3.  If the least significant\n+bit is clear, objects are whole variables, if it is set, a closest\n+surrounding subobject is considered the object a pointer points to.\n+The second bit determines if maximum or minimum of remaining bytes\n+is computed.\n+\n+@smallexample\n+struct V @{ char buf1[10]; int b; char buf2[10]; @} var;\n+char *p = &var.buf1[1], *q = &var.b;\n+\n+/* Here the object p points to is var.  */\n+assert (__builtin_object_size (p, 0) == sizeof (var) - 1);\n+/* The subobject p points to is var.buf1.  */\n+assert (__builtin_object_size (p, 1) == sizeof (var.buf1) - 1);\n+/* The object q points to is var.  */\n+assert (__builtin_object_size (q, 0)\n+\t== (char *) (&var + 1) - (char *) &var.b);\n+/* The subobject q points to is var.b.  */\n+assert (__builtin_object_size (q, 1) == sizeof (var.b));\n+@end smallexample\n+@end deftypefn\n+\n+There are built-in functions added for many common string operation\n+functions, e.g. for @code{memcpy} @code{__builtin___memcpy_chk}\n+built-in is provided.  This built-in has an additional last argument,\n+which is the number of bytes remaining in object the @var{dest}\n+argument points to or @code{(size_t) -1} if the size is not known.\n+\n+The built-in functions are optimized into the normal string functions\n+like @code{memcpy} if the last argument is @code{(size_t) -1} or if\n+it is known at compile time that the destination object will not\n+be overflown.  If the compiler can determine at compile time the\n+object will be always overflown, it issues a warning.\n+\n+The intended use can be e.g.\n+\n+@smallexample\n+#undef memcpy\n+#define bos0(dest) __builtin_object_size (dest, 0)\n+#define memcpy(dest, src, n) \\\n+  __builtin___memcpy_chk (dest, src, n, bos0 (dest))\n+\n+char *volatile p;\n+char buf[10];\n+/* It is unknown what object p points to, so this is optimized\n+   into plain memcpy - no checking is possible.  */\n+memcpy (p, \"abcde\", n);\n+/* Destination is known and length too.  It is known at compile\n+   time there will be no overflow.  */\n+memcpy (&buf[5], \"abcde\", 5);\n+/* Destination is known, but the length is not known at compile time.\n+   This will result in __memcpy_chk call that can check for overflow\n+   at runtime.  */\n+memcpy (&buf[5], \"abcde\", n);\n+/* Destination is known and it is known at compile time there will\n+   be overflow.  There will be a warning and __memcpy_chk call that\n+   will abort the program at runtime.  */\n+memcpy (&buf[6], \"abcde\", 5);\n+@end smallexample\n+\n+Such built-in functions are provided for @code{memcpy}, @code{mempcpy},\n+@code{memmove}, @code{memset}, @code{strcpy}, @code{stpcpy}, @code{strncpy},\n+@code{strcat} and @code{strncat}.\n+\n+There are also checking built-in functions for formatted output functions.\n+@smallexample\n+int __builtin___sprintf_chk (char *s, int flag, size_t os, const char *fmt, ...);\n+int __builtin___snprintf_chk (char *s, size_t maxlen, int flag, size_t os,\n+\t\t\t      const char *fmt, ...);\n+int __builtin___vsprintf_chk (char *s, int flag, size_t os, const char *fmt,\n+\t\t\t      va_list ap);\n+int __builtin___vsnprintf_chk (char *s, size_t maxlen, int flag, size_t os,\n+\t\t\t       const char *fmt, va_list ap);\n+@end smallexample\n+\n+The added @var{flag} argument is passed unchanged to @code{__sprintf_chk}\n+etc. functions and can contain implementation specific flags on what\n+additional security measures the checking function might take, such as\n+handling @code{%n} differently.\n+\n+The @var{os} argument is the object size @var{s} points to, like in the\n+other built-in functions.  There is a small difference in the behaviour\n+though, if @var{os} is @code{(size_t) -1}, the built-in functions are\n+optimized into the non-checking functions only if @var{flag} is 0, otherwise\n+the checking function is called with @var{os} argument set to\n+@code{(size_t) -1}.\n+\n+In addition to this, there are checking built-in functions\n+@code{__builtin___printf_chk}, @code{__builtin___vprintf_chk},\n+@code{__builtin___fprintf_chk} and @code{__builtin___vfprintf_chk}.\n+These have just one additional argument, @var{flag}, right before\n+format string @var{fmt}.  If the compiler is able to optimize them to\n+@code{fputc} etc. functions, it will, otherwise the checking function\n+should be called and the @var{flag} argument passed to it.\n+\n @node Other Builtins\n @section Other built-in functions provided by GCC\n @cindex built-in functions"}, {"sha": "31444a40c9a39deeabcb894cd2da4a8d2600085b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -1,3 +1,61 @@\n+2005-06-27  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.c-torture/execute/builtins/lib/main.c (abort): Add prototype.\n+\t* gcc.c-torture/execute/builtins/lib/strncat.c (strncat): Avoid\n+\ttesting uninitialized var.\n+\n+\t* gcc.c-torture/execute/builtins/chk.h: New.\n+\t* gcc.c-torture/execute/builtins/lib/chk.c: New.\n+\t* gcc.c-torture/execute/builtins/memcpy-chk.c: New test.\n+\t* gcc.c-torture/execute/builtins/memcpy-chk-lib.c: New.\n+\t* gcc.c-torture/execute/builtins/memmove-chk.c: New test.\n+\t* gcc.c-torture/execute/builtins/memmove-chk-lib.c: New.\n+\t* gcc.c-torture/execute/builtins/mempcpy-chk.c: New test.\n+\t* gcc.c-torture/execute/builtins/mempcpy-chk-lib.c: New.\n+\t* gcc.c-torture/execute/builtins/memset-chk.c: New test.\n+\t* gcc.c-torture/execute/builtins/memset-chk-lib.c: New.\n+\t* gcc.c-torture/execute/builtins/snprintf-chk.c: New test.\n+\t* gcc.c-torture/execute/builtins/snprintf-chk-lib.c: New.\n+\t* gcc.c-torture/execute/builtins/sprintf-chk.c: New test.\n+\t* gcc.c-torture/execute/builtins/sprintf-chk-lib.c: New.\n+\t* gcc.c-torture/execute/builtins/stpcpy-chk.c: New test.\n+\t* gcc.c-torture/execute/builtins/stpcpy-chk-lib.c: New.\n+\t* gcc.c-torture/execute/builtins/strcat-chk.c: New test.\n+\t* gcc.c-torture/execute/builtins/strcat-chk-lib.c: New.\n+\t* gcc.c-torture/execute/builtins/strcpy-chk.c: New test.\n+\t* gcc.c-torture/execute/builtins/strcpy-chk-lib.c: New.\n+\t* gcc.c-torture/execute/builtins/strncat-chk.c: New test.\n+\t* gcc.c-torture/execute/builtins/strncat-chk-lib.c: New.\n+\t* gcc.c-torture/execute/builtins/strncpy-chk.c: New test.\n+\t* gcc.c-torture/execute/builtins/strncpy-chk-lib.c: New.\n+\t* gcc.c-torture/execute/builtins/vsnprintf-chk.c: New test.\n+\t* gcc.c-torture/execute/builtins/vsnprintf-chk-lib.c: New.\n+\t* gcc.c-torture/execute/builtins/vsprintf-chk.c: New test.\n+\t* gcc.c-torture/execute/builtins/vsprintf-chk-lib.c: New.\n+\t* gcc.dg/builtin-object-size-1.c: New test.\n+\t* gcc.dg/builtin-object-size-2.c: New test.\n+\t* gcc.dg/builtin-object-size-3.c: New test.\n+\t* gcc.dg/builtin-object-size-4.c: New test.\n+\t* gcc.dg/builtin-object-size-5.c: New test.\n+\t* gcc.dg/builtin-stringop-chk-1.c: New test.\n+\t* gcc.dg/builtin-stringop-chk-2.c: New test.\n+\t* gcc.dg/tree-ssa/builtin-fprintf-1.c: New test.\n+\t* gcc.dg/tree-ssa/builtin-fprintf-chk-1.c: New test.\n+\t* gcc.dg/tree-ssa/builtin-printf-1.c: New test.\n+\t* gcc.dg/tree-ssa/builtin-printf-chk-1.c: New test.\n+\t* gcc.dg/tree-ssa/builtin-vfprintf-1.c: New test.\n+\t* gcc.dg/tree-ssa/builtin-vfprintf-chk-1.c: New test.\n+\t* gcc.dg/tree-ssa/builtin-vprintf-1.c: New test.\n+\t* gcc.dg/tree-ssa/builtin-vprintf-chk-1.c: New test.\n+\t* gcc.c-torture/execute/printf-1.c: New test.\n+\t* gcc.c-torture/execute/fprintf-1.c: New test.\n+\t* gcc.c-torture/execute/vprintf-1.c: New test.\n+\t* gcc.c-torture/execute/vfprintf-1.c: New test.\n+\t* gcc.c-torture/execute/printf-chk-1.c: New test.\n+\t* gcc.c-torture/execute/fprintf-chk-1.c: New test.\n+\t* gcc.c-torture/execute/vprintf-chk-1.c: New test.\n+\t* gcc.c-torture/execute/vfprintf-chk-1.c: New test.\n+\n 2005-06-27  Michael Matz  <matz@suse.de>\n \n \t* gcc.target/x86_64/abi/test_struct_returning.c: Adjust as return"}, {"sha": "dfef410c61b858641a34c44183e27c5e5a36785d", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/chk.h", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fchk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fchk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fchk.h?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,81 @@\n+#ifndef os\n+# define os(ptr) __builtin_object_size (ptr, 0)\n+#endif\n+\n+/* This is one of the alternatives for object size checking.\n+   If dst has side-effects, size checking will never be done.  */\n+#undef memcpy\n+#define memcpy(dst, src, len) \\\n+  __builtin___memcpy_chk (dst, src, len, os (dst))\n+#undef mempcpy\n+#define mempcpy(dst, src, len) \\\n+  __builtin___mempcpy_chk (dst, src, len, os (dst))\n+#undef memmove\n+#define memmove(dst, src, len) \\\n+  __builtin___memmove_chk (dst, src, len, os (dst))\n+#undef memset\n+#define memset(dst, val, len) \\\n+  __builtin___memset_chk (dst, val, len, os (dst))\n+#undef strcpy\n+#define strcpy(dst, src) \\\n+  __builtin___strcpy_chk (dst, src, os (dst))\n+#undef stpcpy\n+#define stpcpy(dst, src) \\\n+  __builtin___stpcpy_chk (dst, src, os (dst))\n+#undef strcat\n+#define strcat(dst, src) \\\n+  __builtin___strcat_chk (dst, src, os (dst))\n+#undef strncpy\n+#define strncpy(dst, src, len) \\\n+  __builtin___strncpy_chk (dst, src, len, os (dst))\n+#undef strncat\n+#define strncat(dst, src, len) \\\n+  __builtin___strncat_chk (dst, src, len, os (dst))\n+#undef sprintf\n+#define sprintf(dst, ...) \\\n+  __builtin___sprintf_chk (dst, 0, os (dst), __VA_ARGS__)\n+#undef vsprintf\n+#define vsprintf(dst, fmt, ap) \\\n+  __builtin___vsprintf_chk (dst, 0, os (dst), fmt, ap)\n+#undef snprintf\n+#define snprintf(dst, len, ...) \\\n+  __builtin___snprintf_chk (dst, len, 0, os (dst), __VA_ARGS__)\n+#undef vsnprintf\n+#define vsnprintf(dst, len, fmt, ap) \\\n+  __builtin___vsnprintf_chk (dst, len, 0, os (dst), fmt, ap)\n+\n+/* Now \"redefine\" even builtins for the purpose of testing.  */\n+#undef __builtin_memcpy\n+#define __builtin_memcpy(dst, src, len) memcpy (dst, src, len)\n+#undef __builtin_mempcpy\n+#define __builtin_mempcpy(dst, src, len) mempcpy (dst, src, len)\n+#undef __builtin_memmove\n+#define __builtin_memmove(dst, src, len) memmove (dst, src, len)\n+#undef __builtin_memset\n+#define __builtin_memset(dst, val, len) memset (dst, val, len)\n+#undef __builtin_strcpy\n+#define __builtin_strcpy(dst, src) strcpy (dst, src)\n+#undef __builtin_stpcpy\n+#define __builtin_stpcpy(dst, src) stpcpy (dst, src)\n+#undef __builtin_strcat\n+#define __builtin_strcat(dst, src) strcat (dst, src)\n+#undef __builtin_strncpy\n+#define __builtin_strncpy(dst, src, len) strncpy (dst, src, len)\n+#undef __builtin_strncat\n+#define __builtin_strncat(dst, src, len) strncat (dst, src, len)\n+#undef __builtin_sprintf\n+#define __builtin_sprintf(dst, ...) sprintf (dst, __VA_ARGS__)\n+#undef __builtin_vsprintf\n+#define __builtin_vsprintf(dst, fmt, ap) vsprintf (dst, fmt, ap)\n+#undef __builtin_snprintf\n+#define __builtin_snprintf(dst, len, ...) snprintf (dst, len, __VA_ARGS__)\n+#undef __builtin_vsnprintf\n+#define __builtin_vsnprintf(dst, len, fmt, ap) vsnprintf (dst, len, fmt, ap)\n+\n+extern void *chk_fail_buf[];\n+extern volatile int chk_fail_allowed, chk_calls;\n+extern volatile int memcpy_disallowed, mempcpy_disallowed, memmove_disallowed;\n+extern volatile int memset_disallowed, strcpy_disallowed, stpcpy_disallowed;\n+extern volatile int strncpy_disallowed, strcat_disallowed, strncat_disallowed;\n+extern volatile int sprintf_disallowed, vsprintf_disallowed;\n+extern volatile int snprintf_disallowed, vsnprintf_disallowed;"}, {"sha": "eb305d472299b60d09481b6013298e9ff9288b81", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/lib/chk.c", "status": "added", "additions": 472, "deletions": 0, "changes": 472, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fchk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fchk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fchk.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,472 @@\n+#include <stdarg.h>\n+\n+extern void abort (void);\n+\n+extern int inside_main;\n+void *chk_fail_buf[256] __attribute__((aligned (16)));\n+volatile int chk_fail_allowed, chk_calls;\n+volatile int memcpy_disallowed, mempcpy_disallowed, memmove_disallowed;\n+volatile int memset_disallowed, strcpy_disallowed, stpcpy_disallowed;\n+volatile int strncpy_disallowed, strcat_disallowed, strncat_disallowed;\n+volatile int sprintf_disallowed, vsprintf_disallowed;\n+volatile int snprintf_disallowed, vsnprintf_disallowed;\n+extern __SIZE_TYPE__ strlen (const char *);\n+extern int vsprintf (char *, const char *, va_list);\n+\n+void __attribute__((noreturn))\n+__chk_fail (void)\n+{\n+  if (chk_fail_allowed)\n+    __builtin_longjmp (chk_fail_buf, 1);\n+  abort ();\n+}\n+\n+void *\n+memcpy (void *dst, const void *src, __SIZE_TYPE__ n)\n+{\n+  const char *srcp;\n+  char *dstp;\n+\n+#ifdef __OPTIMIZE__\n+  if (memcpy_disallowed && inside_main)\n+    abort ();\n+#endif\n+\n+  srcp = src;\n+  dstp = dst;\n+  while (n-- != 0)\n+    *dstp++ = *srcp++;\n+\n+  return dst;\n+}\n+\n+void *\n+__memcpy_chk (void *dst, const void *src, __SIZE_TYPE__ n, __SIZE_TYPE__ size)\n+{\n+  /* If size is -1, GCC should always optimize the call into memcpy.  */\n+  if (size == (__SIZE_TYPE__) -1)\n+    abort ();\n+  ++chk_calls;\n+  if (n > size)\n+    __chk_fail ();\n+  return memcpy (dst, src, n);\n+}\n+\n+void *\n+mempcpy (void *dst, const void *src, __SIZE_TYPE__ n)\n+{\n+  const char *srcp;\n+  char *dstp;\n+\n+#ifdef __OPTIMIZE__\n+  if (mempcpy_disallowed && inside_main)\n+    abort ();\n+#endif\n+\n+  srcp = src;\n+  dstp = dst;\n+  while (n-- != 0)\n+    *dstp++ = *srcp++;\n+\n+  return dstp;\n+}\n+\n+void *\n+__mempcpy_chk (void *dst, const void *src, __SIZE_TYPE__ n, __SIZE_TYPE__ size)\n+{\n+  /* If size is -1, GCC should always optimize the call into mempcpy.  */\n+  if (size == (__SIZE_TYPE__) -1)\n+    abort ();\n+  ++chk_calls;\n+  if (n > size)\n+    __chk_fail ();\n+  return mempcpy (dst, src, n);\n+}\n+\n+void *\n+memmove (void *dst, const void *src, __SIZE_TYPE__ n)\n+{\n+  const char *srcp;\n+  char *dstp;\n+\n+#ifdef __OPTIMIZE__\n+  if (memmove_disallowed && inside_main)\n+    abort ();\n+#endif\n+\n+  srcp = src;\n+  dstp = dst;\n+  if (srcp < dstp)\n+    while (n-- != 0)\n+      dstp[n] = srcp[n];\n+  else\n+    while (n-- != 0)\n+      *dstp++ = *srcp++;\n+\n+  return dst;\n+}\n+\n+void *\n+__memmove_chk (void *dst, const void *src, __SIZE_TYPE__ n, __SIZE_TYPE__ size)\n+{\n+  /* If size is -1, GCC should always optimize the call into memmove.  */\n+  if (size == (__SIZE_TYPE__) -1)\n+    abort ();\n+  ++chk_calls;\n+  if (n > size)\n+    __chk_fail ();\n+  return memmove (dst, src, n);\n+}\n+\n+void *\n+memset (void *dst, int c, __SIZE_TYPE__ n)\n+{\n+  /* Single-byte memsets should be done inline when optimisation\n+     is enabled.  */\n+#ifdef __OPTIMIZE__\n+  if (memset_disallowed && inside_main && n < 2)\n+    abort ();\n+#endif\n+\n+  while (n-- != 0)\n+    n[(char *) dst] = c;\n+\n+  return dst;\n+}\n+\n+void *\n+__memset_chk (void *dst, int c, __SIZE_TYPE__ n, __SIZE_TYPE__ size)\n+{\n+  /* If size is -1, GCC should always optimize the call into memset.  */\n+  if (size == (__SIZE_TYPE__) -1)\n+    abort ();\n+  ++chk_calls;\n+  if (n > size)\n+    __chk_fail ();\n+  return memset (dst, c, n);\n+}\n+\n+char *\n+strcpy (char *d, const char *s)\n+{\n+  char *r = d;\n+#ifdef __OPTIMIZE__\n+  if (strcpy_disallowed && inside_main)\n+    abort ();\n+#endif\n+  while ((*d++ = *s++));\n+  return r;\n+}\n+\n+char *\n+__strcpy_chk (char *d, const char *s, __SIZE_TYPE__ size)\n+{\n+  /* If size is -1, GCC should always optimize the call into strcpy.  */\n+  if (size == (__SIZE_TYPE__) -1)\n+    abort ();\n+  ++chk_calls;\n+  if (strlen (s) >= size)\n+    __chk_fail ();\n+  return strcpy (d, s);\n+}\n+\n+char *\n+stpcpy (char *dst, const char *src)\n+{\n+#ifdef __OPTIMIZE__\n+  if (stpcpy_disallowed && inside_main)\n+    abort ();\n+#endif\n+\n+  while (*src != 0)\n+    *dst++ = *src++;\n+\n+  *dst = 0;\n+  return dst;\n+}\n+\n+char *\n+__stpcpy_chk (char *d, const char *s, __SIZE_TYPE__ size)\n+{\n+  /* If size is -1, GCC should always optimize the call into stpcpy.  */\n+  if (size == (__SIZE_TYPE__) -1)\n+    abort ();\n+  ++chk_calls;\n+  if (strlen (s) >= size)\n+    __chk_fail ();\n+  return stpcpy (d, s);\n+}\n+\n+char *\n+strncpy (char *s1, const char *s2, __SIZE_TYPE__ n)\n+{\n+  char *dest = s1;\n+#ifdef __OPTIMIZE__\n+  if (strncpy_disallowed && inside_main)\n+    abort();\n+#endif\n+  for (; *s2 && n; n--)\n+    *s1++ = *s2++;\n+  while (n--)\n+    *s1++ = 0;\n+  return dest;\n+}\n+\n+char *\n+__strncpy_chk (char *s1, const char *s2, __SIZE_TYPE__ n, __SIZE_TYPE__ size)\n+{\n+  /* If size is -1, GCC should always optimize the call into strncpy.  */\n+  if (size == (__SIZE_TYPE__) -1)\n+    abort ();\n+  ++chk_calls;\n+  if (n > size)\n+    __chk_fail ();\n+  return strncpy (s1, s2, n);\n+}\n+\n+char *\n+strcat (char *dst, const char *src)\n+{\n+  char *p = dst;\n+  \n+#ifdef __OPTIMIZE__\n+  if (strcat_disallowed && inside_main)\n+    abort ();\n+#endif\n+\n+  while (*p)\n+    p++;\n+  while ((*p++ = *src++))\n+    ;\n+  return dst;\n+}\n+\n+char *\n+__strcat_chk (char *d, const char *s, __SIZE_TYPE__ size)\n+{\n+  /* If size is -1, GCC should always optimize the call into strcat.  */\n+  if (size == (__SIZE_TYPE__) -1)\n+    abort ();\n+  ++chk_calls;\n+  if (strlen (d) + strlen (s) >= size)\n+    __chk_fail ();\n+  return strcat (d, s);\n+}\n+\n+char *\n+strncat (char *s1, const char *s2, __SIZE_TYPE__ n)\n+{\n+  char *dest = s1;\n+  char c;\n+#ifdef __OPTIMIZE__\n+  if (strncat_disallowed && inside_main)\n+    abort();\n+#endif\n+  while (*s1) s1++;\n+  c = '\\0';\n+  while (n > 0)\n+    {\n+      c = *s2++;\n+      *s1++ = c;\n+      if (c == '\\0')\n+\treturn dest;\n+      n--;\n+    }\n+  if (c != '\\0')\n+    *s1 = '\\0';\n+  return dest;\n+}\n+\n+char *\n+__strncat_chk (char *d, const char *s, __SIZE_TYPE__ n, __SIZE_TYPE__ size)\n+{\n+  __SIZE_TYPE__ len = strlen (d), n1 = n;\n+  const char *s1 = s;\n+\n+  /* If size is -1, GCC should always optimize the call into strncat.  */\n+  if (size == (__SIZE_TYPE__) -1)\n+    abort ();\n+  ++chk_calls;\n+  while (len < size && n1 > 0)\n+    {\n+      if (*s1++ == '\\0')\n+\tbreak;\n+      ++len;\n+      --n1;\n+    }\n+\n+  if (len >= size)\n+    __chk_fail ();\n+  return strncat (d, s, n);\n+}\n+\n+/* No chk test in GCC testsuite needs more bytes than this.\n+   As we can't expect vsnprintf to be available on the target,\n+   assume 4096 bytes is enough.  */\n+static char chk_sprintf_buf[4096];\n+\n+int\n+__sprintf_chk (char *str, int flag, __SIZE_TYPE__ size, const char *fmt, ...)\n+{\n+  int ret;\n+  va_list ap;\n+\n+  /* If size is -1 and flag 0, GCC should always optimize the call into\n+     sprintf.  */\n+  if (size == (__SIZE_TYPE__) -1 && flag == 0)\n+    abort ();\n+  ++chk_calls;\n+#ifdef __OPTIMIZE__\n+  if (sprintf_disallowed && inside_main)\n+    abort();\n+#endif\n+  va_start (ap, fmt);\n+  ret = vsprintf (chk_sprintf_buf, fmt, ap);\n+  va_end (ap);\n+  if (ret >= 0)\n+    {\n+      if (ret >= size)\n+\t__chk_fail ();\n+      memcpy (str, chk_sprintf_buf, ret + 1);\n+    }\n+  return ret;\n+}\n+\n+int\n+__vsprintf_chk (char *str, int flag, __SIZE_TYPE__ size, const char *fmt,\n+\t\tva_list ap)\n+{\n+  int ret;\n+\n+  /* If size is -1 and flag 0, GCC should always optimize the call into\n+     vsprintf.  */\n+  if (size == (__SIZE_TYPE__) -1 && flag == 0)\n+    abort ();\n+  ++chk_calls;\n+#ifdef __OPTIMIZE__\n+  if (vsprintf_disallowed && inside_main)\n+    abort();\n+#endif\n+  ret = vsprintf (chk_sprintf_buf, fmt, ap);\n+  if (ret >= 0)\n+    {\n+      if (ret >= size)\n+\t__chk_fail ();\n+      memcpy (str, chk_sprintf_buf, ret + 1);\n+    }\n+  return ret;\n+}\n+\n+int\n+__snprintf_chk (char *str, __SIZE_TYPE__ len, int flag, __SIZE_TYPE__ size,\n+\t\tconst char *fmt, ...)\n+{\n+  int ret;\n+  va_list ap;\n+\n+  /* If size is -1 and flag 0, GCC should always optimize the call into\n+     snprintf.  */\n+  if (size == (__SIZE_TYPE__) -1 && flag == 0)\n+    abort ();\n+  ++chk_calls;\n+  if (size < len)\n+    __chk_fail ();\n+#ifdef __OPTIMIZE__\n+  if (snprintf_disallowed && inside_main)\n+    abort();\n+#endif\n+  va_start (ap, fmt);\n+  ret = vsprintf (chk_sprintf_buf, fmt, ap);\n+  va_end (ap);\n+  if (ret >= 0)\n+    {\n+      if (ret < len)\n+\tmemcpy (str, chk_sprintf_buf, ret + 1);\n+      else\n+\t{\n+\t  memcpy (str, chk_sprintf_buf, len - 1);\n+\t  str[len - 1] = '\\0';\n+\t}\n+    }\n+  return ret;\n+}\n+\n+int\n+__vsnprintf_chk (char *str, __SIZE_TYPE__ len, int flag, __SIZE_TYPE__ size,\n+\t\t const char *fmt, va_list ap)\n+{\n+  int ret;\n+\n+  /* If size is -1 and flag 0, GCC should always optimize the call into\n+     vsnprintf.  */\n+  if (size == (__SIZE_TYPE__) -1 && flag == 0)\n+    abort ();\n+  ++chk_calls;\n+  if (size < len)\n+    __chk_fail ();\n+#ifdef __OPTIMIZE__\n+  if (vsnprintf_disallowed && inside_main)\n+    abort();\n+#endif\n+  ret = vsprintf (chk_sprintf_buf, fmt, ap);\n+  if (ret >= 0)\n+    {\n+      if (ret < len)\n+\tmemcpy (str, chk_sprintf_buf, ret + 1);\n+      else\n+\t{\n+\t  memcpy (str, chk_sprintf_buf, len - 1);\n+\t  str[len - 1] = '\\0';\n+\t}\n+    }\n+  return ret;\n+}\n+\n+int\n+snprintf (char *str, __SIZE_TYPE__ len, const char *fmt, ...)\n+{\n+  int ret;\n+  va_list ap;\n+\n+#ifdef __OPTIMIZE__\n+  if (snprintf_disallowed && inside_main)\n+    abort();\n+#endif\n+  va_start (ap, fmt);\n+  ret = vsprintf (chk_sprintf_buf, fmt, ap);\n+  va_end (ap);\n+  if (ret >= 0)\n+    {\n+      if (ret < len)\n+\tmemcpy (str, chk_sprintf_buf, ret + 1);\n+      else if (len)\n+\t{\n+\t  memcpy (str, chk_sprintf_buf, len - 1);\n+\t  str[len - 1] = '\\0';\n+\t}\n+    }\n+  return ret;\n+}\n+\n+int\n+vsnprintf (char *str, __SIZE_TYPE__ len, const char *fmt, va_list ap)\n+{\n+  int ret;\n+\n+#ifdef __OPTIMIZE__\n+  if (vsnprintf_disallowed && inside_main)\n+    abort();\n+#endif\n+  ret = vsprintf (chk_sprintf_buf, fmt, ap);\n+  if (ret >= 0)\n+    {\n+      if (ret < len)\n+\tmemcpy (str, chk_sprintf_buf, ret + 1);\n+      else if (len)\n+\t{\n+\t  memcpy (str, chk_sprintf_buf, len - 1);\n+\t  str[len - 1] = '\\0';\n+\t}\n+    }\n+  return ret;\n+}"}, {"sha": "a9bb6c6b890ca929b73f715653943eea5b2d746d", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/lib/main.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fmain.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -1,5 +1,6 @@\n extern void abort(void);\n extern void main_test (void);\n+extern void abort (void);\n int inside_main;\n \n int"}, {"sha": "290d4cf49bb472557e94bae1955957be650b84ca", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/lib/strncat.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrncat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrncat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Flib%2Fstrncat.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -13,11 +13,12 @@ strncat (char *s1, const char *s2, size_t n)\n     abort();\n #endif\n   while (*s1) s1++;\n+  c = '\\0';\n   while (n > 0)\n     {\n       c = *s2++;\n       *s1++ = c;\n-      if (c == 0)\n+      if (c == '\\0')\n \treturn dest;\n       n--;\n     }"}, {"sha": "9daf13e827b5f757f79552f56c57ed55258d8eb3", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/memcpy-chk-lib.c", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fmemcpy-chk-lib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fmemcpy-chk-lib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fmemcpy-chk-lib.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1 @@\n+#include \"lib/chk.c\""}, {"sha": "28f7ae785f6d21a55d42808a95e7b7367cc5eb28", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/memcpy-chk.c", "status": "added", "additions": 479, "deletions": 0, "changes": 479, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fmemcpy-chk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fmemcpy-chk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fmemcpy-chk.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,479 @@\n+/* Copyright (C) 2004, 2005  Free Software Foundation.\n+\n+   Ensure builtin __memcpy_chk performs correctly.  */\n+\n+extern void abort (void);\n+typedef __SIZE_TYPE__ size_t;\n+extern size_t strlen(const char *);\n+extern void *memcpy (void *, const void *, size_t);\n+extern int memcmp (const void *, const void *, size_t);\n+\n+#include \"chk.h\"\n+\n+const char s1[] = \"123\";\n+char p[32] = \"\";\n+char *s2 = \"defg\";\n+char *s3 = \"FGH\";\n+size_t l1 = 1;\n+\n+void\n+__attribute__((noinline))\n+test1 (void)\n+{\n+  int i;\n+\n+#if defined __i386__ || defined __x86_64__\n+  /* The functions below might not be optimized into direct stores on all\n+     arches.  It depends on how many instructions would be generated and\n+     what limits the architecture chooses in STORE_BY_PIECES_P.  */\n+  memcpy_disallowed = 1;\n+#endif\n+\n+  /* All the memcpy calls in this routine except last have fixed length, so\n+     object size checking should be done at compile time if optimizing.  */\n+  chk_calls = 0;\n+\n+  if (memcpy (p, \"ABCDE\", 6) != p || memcmp (p, \"ABCDE\", 6))\n+    abort ();\n+  if (memcpy (p + 16, \"VWX\" + 1, 2) != p + 16\n+      || memcmp (p + 16, \"WX\\0\\0\", 5))\n+    abort ();\n+  if (memcpy (p + 1, \"\", 1) != p + 1 || memcmp (p, \"A\\0CDE\", 6))\n+    abort ();\n+  if (memcpy (p + 3, \"FGHI\", 4) != p + 3 || memcmp (p, \"A\\0CFGHI\", 8))\n+    abort ();\n+\n+  i = 8;\n+  memcpy (p + 20, \"qrstu\", 6);\n+  memcpy (p + 25, \"QRSTU\", 6);\n+  if (memcpy (p + 25 + 1, s1, 3) != p + 25 + 1\n+      || memcmp (p + 25, \"Q123U\", 6))\n+    abort ();\n+\n+  if (memcpy (memcpy (p, \"abcdEFG\", 4) + 4, \"efg\", 4) != p + 4\n+      || memcmp (p, \"abcdefg\", 8))\n+    abort();\n+\n+  /* Test at least one instance of the __builtin_ style.  We do this\n+     to ensure that it works and that the prototype is correct.  */\n+  if (__builtin_memcpy (p, \"ABCDE\", 6) != p || memcmp (p, \"ABCDE\", 6))\n+    abort ();\n+\n+  memcpy (p + 5, s3, 1);\n+  if (memcmp (p, \"ABCDEFg\", 8))\n+    abort ();\n+\n+  memcpy_disallowed = 0;\n+  if (chk_calls)\n+    abort ();\n+  chk_calls = 0;\n+\n+  memcpy (p + 6, s1 + 1, l1);\n+  if (memcmp (p, \"ABCDEF2\", 8))\n+    abort ();\n+\n+  /* The above memcpy copies into an object with known size, but\n+     unknown length, so it should be a __memcpy_chk call.  */\n+  if (chk_calls != 1)\n+    abort ();\n+}\n+\n+long buf1[64];\n+char *buf2 = (char *) (buf1 + 32);\n+long buf5[20];\n+char buf7[20];\n+\n+void\n+__attribute__((noinline))\n+test2_sub (long *buf3, char *buf4, char *buf6, int n)\n+{\n+  int i = 0;\n+\n+  /* All the memcpy/__builtin_memcpy/__builtin___memcpy_chk\n+     calls in this routine are either fixed length, or have\n+     side-effects in __builtin_object_size arguments, or\n+     dst doesn't point into a known object.  */\n+  chk_calls = 0;\n+\n+  /* These should probably be handled by store_by_pieces on most arches.  */\n+  if (memcpy (buf1, \"ABCDEFGHI\", 9) != (char *) buf1\n+      || memcmp (buf1, \"ABCDEFGHI\\0\", 11))\n+    abort ();\n+\n+  if (memcpy (buf1, \"abcdefghijklmnopq\", 17) != (char *) buf1\n+      || memcmp (buf1, \"abcdefghijklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (__builtin_memcpy (buf3, \"ABCDEF\", 6) != (char *) buf1\n+      || memcmp (buf1, \"ABCDEFghijklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (__builtin_memcpy (buf3, \"a\", 1) != (char *) buf1\n+      || memcmp (buf1, \"aBCDEFghijklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (memcpy ((char *) buf3 + 2, \"bcd\" + ++i, 2) != (char *) buf1 + 2\n+      || memcmp (buf1, \"aBcdEFghijklmnopq\\0\", 19)\n+      || i != 1)\n+    abort ();\n+\n+  /* These should probably be handled by move_by_pieces on most arches.  */\n+  if (memcpy ((char *) buf3 + 4, buf5, 6) != (char *) buf1 + 4\n+      || memcmp (buf1, \"aBcdRSTUVWklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (__builtin_memcpy ((char *) buf1 + ++i + 8, (char *) buf5 + 1, 1)\n+      != (char *) buf1 + 10\n+      || memcmp (buf1, \"aBcdRSTUVWSlmnopq\\0\", 19)\n+      || i != 2)\n+    abort ();\n+\n+  if (memcpy ((char *) buf3 + 14, buf6, 2) != (char *) buf1 + 14\n+      || memcmp (buf1, \"aBcdRSTUVWSlmnrsq\\0\", 19))\n+    abort ();\n+\n+  if (memcpy (buf3, buf5, 8) != (char *) buf1\n+      || memcmp (buf1, \"RSTUVWXYVWSlmnrsq\\0\", 19))\n+    abort ();\n+\n+  if (memcpy (buf3, buf5, 17) != (char *) buf1\n+      || memcmp (buf1, \"RSTUVWXYZ01234567\\0\", 19))\n+    abort ();\n+\n+  __builtin_memcpy (buf3, \"aBcdEFghijklmnopq\\0\", 19);\n+\n+  /* These should be handled either by movmemendM or memcpy\n+     call.  */\n+\n+  /* buf3 points to an unknown object, so __memcpy_chk should not be done.  */\n+  if (memcpy ((char *) buf3 + 4, buf5, n + 6) != (char *) buf1 + 4\n+      || memcmp (buf1, \"aBcdRSTUVWklmnopq\\0\", 19))\n+    abort ();\n+\n+  /* This call has side-effects in dst, therefore no checking.  */\n+  if (__builtin___memcpy_chk ((char *) buf1 + ++i + 8, (char *) buf5 + 1,\n+\t\t\t      n + 1, os ((char *) buf1 + ++i + 8))\n+      != (char *) buf1 + 11\n+      || memcmp (buf1, \"aBcdRSTUVWkSmnopq\\0\", 19)\n+      || i != 3)\n+    abort ();\n+\n+  if (memcpy ((char *) buf3 + 14, buf6, n + 2) != (char *) buf1 + 14\n+      || memcmp (buf1, \"aBcdRSTUVWkSmnrsq\\0\", 19))\n+    abort ();\n+\n+  i = 1;\n+\n+  /* These might be handled by store_by_pieces.  */\n+  if (memcpy (buf2, \"ABCDEFGHI\", 9) != buf2\n+      || memcmp (buf2, \"ABCDEFGHI\\0\", 11))\n+    abort ();\n+\n+  if (memcpy (buf2, \"abcdefghijklmnopq\", 17) != buf2\n+      || memcmp (buf2, \"abcdefghijklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (__builtin_memcpy (buf4, \"ABCDEF\", 6) != buf2\n+      || memcmp (buf2, \"ABCDEFghijklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (__builtin_memcpy (buf4, \"a\", 1) != buf2\n+      || memcmp (buf2, \"aBCDEFghijklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (memcpy (buf4 + 2, \"bcd\" + i++, 2) != buf2 + 2\n+      || memcmp (buf2, \"aBcdEFghijklmnopq\\0\", 19)\n+      || i != 2)\n+    abort ();\n+\n+  /* These might be handled by move_by_pieces.  */\n+  if (memcpy (buf4 + 4, buf7, 6) != buf2 + 4\n+      || memcmp (buf2, \"aBcdRSTUVWklmnopq\\0\", 19))\n+    abort ();\n+\n+  /* Side effect.  */\n+  if (__builtin___memcpy_chk (buf2 + i++ + 8, buf7 + 1, 1,\n+\t\t\t      os (buf2 + i++ + 8))\n+      != buf2 + 10\n+      || memcmp (buf2, \"aBcdRSTUVWSlmnopq\\0\", 19)\n+      || i != 3)\n+    abort ();\n+\n+  if (memcpy (buf4 + 14, buf6, 2) != buf2 + 14\n+      || memcmp (buf2, \"aBcdRSTUVWSlmnrsq\\0\", 19))\n+    abort ();\n+\n+  __builtin_memcpy (buf4, \"aBcdEFghijklmnopq\\0\", 19);\n+\n+  /* These should be handled either by movmemendM or memcpy\n+     call.  */\n+  if (memcpy (buf4 + 4, buf7, n + 6) != buf2 + 4\n+      || memcmp (buf2, \"aBcdRSTUVWklmnopq\\0\", 19))\n+    abort ();\n+\n+  /* Side effect.  */\n+  if (__builtin___memcpy_chk (buf2 + i++ + 8, buf7 + 1, n + 1,\n+\t\t\t      os (buf2 + i++ + 8))\n+      != buf2 + 11\n+      || memcmp (buf2, \"aBcdRSTUVWkSmnopq\\0\", 19)\n+      || i != 4)\n+    abort ();\n+\n+  if (memcpy (buf4 + 14, buf6, n + 2) != buf2 + 14\n+      || memcmp (buf2, \"aBcdRSTUVWkSmnrsq\\0\", 19))\n+    abort ();\n+\n+  if (chk_calls)\n+    abort ();\n+}\n+\n+void\n+__attribute__((noinline))\n+test2 (void)\n+{\n+  long *x;\n+  char *y;\n+  int z;\n+  __builtin_memcpy (buf5, \"RSTUVWXYZ0123456789\", 20);\n+  __builtin_memcpy (buf7, \"RSTUVWXYZ0123456789\", 20);\n+ __asm (\"\" : \"=r\" (x) : \"0\" (buf1));\n+ __asm (\"\" : \"=r\" (y) : \"0\" (buf2));\n+ __asm (\"\" : \"=r\" (z) : \"0\" (0));\n+  test2_sub (x, y, \"rstuvwxyz\", z);\n+}\n+\n+/* Test whether compile time checking is done where it should\n+   and so is runtime object size checking.  */\n+void\n+__attribute__((noinline))\n+test3 (void)\n+{\n+  struct A { char buf1[10]; char buf2[10]; } a;\n+  char *r = l1 == 1 ? &a.buf1[5] : &a.buf2[4];\n+  char buf3[20];\n+  int i;\n+  size_t l;\n+\n+  /* The following calls should do runtime checking\n+     - length is not known, but destination is.  */\n+  chk_calls = 0;\n+  memcpy (a.buf1 + 2, s3, l1);\n+  memcpy (r, s3, l1 + 1);\n+  r = l1 == 1 ? __builtin_alloca (4) : &a.buf2[7];\n+  memcpy (r, s2, l1 + 2);\n+  memcpy (r + 2, s3, l1);\n+  r = buf3;\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[1];\n+      else if (i == l1)\n+\tr = &a.buf2[7];\n+      else if (i == l1 + 1)\n+\tr = &buf3[5];\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[9];\n+    }\n+  memcpy (r, s2, l1);\n+  if (chk_calls != 5)\n+    abort ();\n+\n+  /* Following have known destination and known length,\n+     so if optimizing certainly shouldn't result in the checking\n+     variants.  */\n+  chk_calls = 0;\n+  memcpy (a.buf1 + 2, s3, 1);\n+  memcpy (r, s3, 2);\n+  r = l1 == 1 ? __builtin_alloca (4) : &a.buf2[7];\n+  memcpy (r, s2, 3);\n+  r = buf3;\n+  l = 4;\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[1], l = 2;\n+      else if (i == l1)\n+\tr = &a.buf2[7], l = 3;\n+      else if (i == l1 + 1)\n+\tr = &buf3[5], l = 4;\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[9], l = 1;\n+    }\n+  memcpy (r, s2, 1);\n+  /* Here, l is known to be at most 4 and __builtin_object_size (&buf3[16], 0)\n+     is 4, so this doesn't need runtime checking.  */\n+  memcpy (&buf3[16], s2, l);\n+  if (chk_calls)\n+    abort ();\n+  chk_calls = 0;\n+}\n+\n+/* Test whether runtime and/or compile time checking catches\n+   buffer overflows.  */\n+void\n+__attribute__((noinline))\n+test4 (void)\n+{\n+  struct A { char buf1[10]; char buf2[10]; } a;\n+  char buf3[20];\n+\n+  chk_fail_allowed = 1;\n+  /* Runtime checks.  */\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      memcpy (&a.buf2[9], s2, l1 + 1);\n+      abort ();\n+    }\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      memcpy (&a.buf2[7], s3, strlen (s3) + 1);\n+      abort ();\n+    }\n+  /* This should be detectable at compile time already.  */\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      memcpy (&buf3[19], \"ab\", 2);\n+      abort ();\n+    }\n+  chk_fail_allowed = 0;\n+}\n+\n+#ifndef MAX_OFFSET\n+#define MAX_OFFSET (sizeof (long long))\n+#endif\n+\n+#ifndef MAX_COPY\n+#define MAX_COPY (10 * sizeof (long long))\n+#endif\n+\n+#ifndef MAX_EXTRA\n+#define MAX_EXTRA (sizeof (long long))\n+#endif\n+\n+#define MAX_LENGTH (MAX_OFFSET + MAX_COPY + MAX_EXTRA)\n+\n+/* Use a sequence length that is not divisible by two, to make it more\n+   likely to detect when words are mixed up.  */\n+#define SEQUENCE_LENGTH 31\n+\n+static union {\n+  char buf[MAX_LENGTH];\n+  long long align_int;\n+  long double align_fp;\n+} u1, u2;\n+\n+void\n+__attribute__((noinline))\n+test5 (void)\n+{\n+  int off1, off2, len, i;\n+  char *p, *q, c;\n+\n+  for (off1 = 0; off1 < MAX_OFFSET; off1++)\n+    for (off2 = 0; off2 < MAX_OFFSET; off2++)\n+      for (len = 1; len < MAX_COPY; len++)\n+\t{\n+\t  for (i = 0, c = 'A'; i < MAX_LENGTH; i++, c++)\n+\t    {\n+\t      u1.buf[i] = 'a';\n+\t      if (c >= 'A' + SEQUENCE_LENGTH)\n+\t\tc = 'A';\n+\t      u2.buf[i] = c;\n+\t    }\n+\n+\t  p = memcpy (u1.buf + off1, u2.buf + off2, len);\n+\t  if (p != u1.buf + off1)\n+\t    abort ();\n+\n+\t  q = u1.buf;\n+\t  for (i = 0; i < off1; i++, q++)\n+\t    if (*q != 'a')\n+\t      abort ();\n+\n+\t  for (i = 0, c = 'A' + off2; i < len; i++, q++, c++)\n+\t    {\n+\t      if (c >= 'A' + SEQUENCE_LENGTH)\n+\t\tc = 'A';\n+\t      if (*q != c)\n+\t\tabort ();\n+\t    }\n+\n+\t  for (i = 0; i < MAX_EXTRA; i++, q++)\n+\t    if (*q != 'a')\n+\t      abort ();\n+\t}\n+}\n+\n+#define TESTSIZE 80\n+\n+char srcb[TESTSIZE] __attribute__ ((aligned));\n+char dstb[TESTSIZE] __attribute__ ((aligned));\n+\n+void\n+__attribute__((noinline))\n+check (char *test, char *match, int n)\n+{\n+  if (memcmp (test, match, n))\n+    abort ();\n+}\n+\n+#define TN(n) \\\n+{ memset (dstb, 0, n); memcpy (dstb, srcb, n); check (dstb, srcb, n); }\n+#define T(n) \\\n+TN (n) \\\n+TN ((n) + 1) \\\n+TN ((n) + 2) \\\n+TN ((n) + 3)\n+\n+void\n+__attribute__((noinline))\n+test6 (void)\n+{\n+  int i;\n+\n+  chk_calls = 0;\n+\n+  for (i = 0; i < sizeof (srcb); ++i)\n+      srcb[i] = 'a' + i % 26;\n+\n+  T (0);\n+  T (4);\n+  T (8);\n+  T (12);\n+  T (16);\n+  T (20);\n+  T (24);\n+  T (28);\n+  T (32);\n+  T (36);\n+  T (40);\n+  T (44);\n+  T (48);\n+  T (52);\n+  T (56);\n+  T (60);\n+  T (64);\n+  T (68);\n+  T (72);\n+  T (76);\n+\n+  /* All memcpy calls in this routine have constant arguments.  */\n+  if (chk_calls)\n+    abort ();\n+}\n+\n+void\n+main_test (void)\n+{\n+#ifndef __OPTIMIZE__\n+  /* Object size checking is only intended for -O[s123].  */\n+  return;\n+#endif\n+  __asm (\"\" : \"=r\" (l1) : \"0\" (l1));\n+  test1 ();\n+  test2 ();\n+  test3 ();\n+  test4 ();\n+  test5 ();\n+  test6 ();\n+}"}, {"sha": "9daf13e827b5f757f79552f56c57ed55258d8eb3", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/memmove-chk-lib.c", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fmemmove-chk-lib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fmemmove-chk-lib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fmemmove-chk-lib.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1 @@\n+#include \"lib/chk.c\""}, {"sha": "12272272ca6b7db942b5b8e7a971b73abc1fe3e3", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/memmove-chk.c", "status": "added", "additions": 579, "deletions": 0, "changes": 579, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fmemmove-chk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fmemmove-chk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fmemmove-chk.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,579 @@\n+/* Copyright (C) 2004, 2005  Free Software Foundation.\n+\n+   Ensure builtin __memcpy_chk performs correctly.  */\n+\n+extern void abort (void);\n+typedef __SIZE_TYPE__ size_t;\n+extern size_t strlen(const char *);\n+extern void *memcpy (void *, const void *, size_t);\n+extern void *memmove (void *, const void *, size_t);\n+extern int memcmp (const void *, const void *, size_t);\n+\n+#include \"chk.h\"\n+\n+const char s1[] = \"123\";\n+char p[32] = \"\";\n+char *s2 = \"defg\";\n+char *s3 = \"FGH\";\n+size_t l1 = 1;\n+\n+void\n+__attribute__((noinline))\n+test1 (void)\n+{\n+  int i;\n+\n+#if defined __i386__ || defined __x86_64__\n+  /* The functions below might not be optimized into direct stores on all\n+     arches.  It depends on how many instructions would be generated and\n+     what limits the architecture chooses in STORE_BY_PIECES_P.  */\n+  memmove_disallowed = 1;\n+  memcpy_disallowed = 1;\n+#endif\n+\n+  /* All the memmove calls in this routine except last have fixed length, so\n+     object size checking should be done at compile time if optimizing.  */\n+  chk_calls = 0;\n+\n+  if (memmove (p, \"ABCDE\", 6) != p || memcmp (p, \"ABCDE\", 6))\n+    abort ();\n+  if (memmove (p + 16, \"VWX\" + 1, 2) != p + 16\n+      || memcmp (p + 16, \"WX\\0\\0\", 5))\n+    abort ();\n+  if (memmove (p + 1, \"\", 1) != p + 1 || memcmp (p, \"A\\0CDE\", 6))\n+    abort ();\n+  if (memmove (p + 3, \"FGHI\", 4) != p + 3 || memcmp (p, \"A\\0CFGHI\", 8))\n+    abort ();\n+\n+  i = 8;\n+  memmove (p + 20, \"qrstu\", 6);\n+  memmove (p + 25, \"QRSTU\", 6);\n+  if (memmove (p + 25 + 1, s1, 3) != p + 25 + 1\n+      || memcmp (p + 25, \"Q123U\", 6))\n+    abort ();\n+\n+  if (memmove (memmove (p, \"abcdEFG\", 4) + 4, \"efg\", 4) != p + 4\n+      || memcmp (p, \"abcdefg\", 8))\n+    abort();\n+\n+  /* Test at least one instance of the __builtin_ style.  We do this\n+     to ensure that it works and that the prototype is correct.  */\n+  if (__builtin_memmove (p, \"ABCDE\", 6) != p || memcmp (p, \"ABCDE\", 6))\n+    abort ();\n+\n+  memmove (p + 5, s3, 1);\n+  if (memcmp (p, \"ABCDEFg\", 8))\n+    abort ();\n+\n+  memmove_disallowed = 0;\n+  memcpy_disallowed = 0;\n+  if (chk_calls)\n+    abort ();\n+  chk_calls = 0;\n+\n+  memmove (p + 6, s1 + 1, l1);\n+  if (memcmp (p, \"ABCDEF2\", 8))\n+    abort ();\n+\n+  /* The above memmove copies into an object with known size, but\n+     unknown length, so it should be a __memmove_chk call.  */\n+  if (chk_calls != 1)\n+    abort ();\n+}\n+\n+long buf1[64];\n+char *buf2 = (char *) (buf1 + 32);\n+long buf5[20];\n+char buf7[20];\n+\n+void\n+__attribute__((noinline))\n+test2_sub (long *buf3, char *buf4, char *buf6, int n)\n+{\n+  int i = 0;\n+\n+  /* All the memmove/__builtin_memmove/__builtin___memmove_chk\n+     calls in this routine are either fixed length, or have\n+     side-effects in __builtin_object_size arguments, or\n+     dst doesn't point into a known object.  */\n+  chk_calls = 0;\n+\n+  /* These should probably be handled by store_by_pieces on most arches.  */\n+  if (memmove (buf1, \"ABCDEFGHI\", 9) != (char *) buf1\n+      || memcmp (buf1, \"ABCDEFGHI\\0\", 11))\n+    abort ();\n+\n+  if (memmove (buf1, \"abcdefghijklmnopq\", 17) != (char *) buf1\n+      || memcmp (buf1, \"abcdefghijklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (__builtin_memmove (buf3, \"ABCDEF\", 6) != (char *) buf1\n+      || memcmp (buf1, \"ABCDEFghijklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (__builtin_memmove (buf3, \"a\", 1) != (char *) buf1\n+      || memcmp (buf1, \"aBCDEFghijklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (memmove ((char *) buf3 + 2, \"bcd\" + ++i, 2) != (char *) buf1 + 2\n+      || memcmp (buf1, \"aBcdEFghijklmnopq\\0\", 19)\n+      || i != 1)\n+    abort ();\n+\n+  /* These should probably be handled by move_by_pieces on most arches.  */\n+  if (memmove ((char *) buf3 + 4, buf5, 6) != (char *) buf1 + 4\n+      || memcmp (buf1, \"aBcdRSTUVWklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (__builtin_memmove ((char *) buf1 + ++i + 8, (char *) buf5 + 1, 1)\n+      != (char *) buf1 + 10\n+      || memcmp (buf1, \"aBcdRSTUVWSlmnopq\\0\", 19)\n+      || i != 2)\n+    abort ();\n+\n+  if (memmove ((char *) buf3 + 14, buf6, 2) != (char *) buf1 + 14\n+      || memcmp (buf1, \"aBcdRSTUVWSlmnrsq\\0\", 19))\n+    abort ();\n+\n+  if (memmove (buf3, buf5, 8) != (char *) buf1\n+      || memcmp (buf1, \"RSTUVWXYVWSlmnrsq\\0\", 19))\n+    abort ();\n+\n+  if (memmove (buf3, buf5, 17) != (char *) buf1\n+      || memcmp (buf1, \"RSTUVWXYZ01234567\\0\", 19))\n+    abort ();\n+\n+  __builtin_memmove (buf3, \"aBcdEFghijklmnopq\\0\", 19);\n+\n+  /* These should be handled either by movmemendM or memmove\n+     call.  */\n+\n+  /* buf3 points to an unknown object, so __memmove_chk should not be done.  */\n+  if (memmove ((char *) buf3 + 4, buf5, n + 6) != (char *) buf1 + 4\n+      || memcmp (buf1, \"aBcdRSTUVWklmnopq\\0\", 19))\n+    abort ();\n+\n+  /* This call has side-effects in dst, therefore no checking.  */\n+  if (__builtin___memmove_chk ((char *) buf1 + ++i + 8, (char *) buf5 + 1,\n+\t\t\t       n + 1, os ((char *) buf1 + ++i + 8))\n+      != (char *) buf1 + 11\n+      || memcmp (buf1, \"aBcdRSTUVWkSmnopq\\0\", 19)\n+      || i != 3)\n+    abort ();\n+\n+  if (memmove ((char *) buf3 + 14, buf6, n + 2) != (char *) buf1 + 14\n+      || memcmp (buf1, \"aBcdRSTUVWkSmnrsq\\0\", 19))\n+    abort ();\n+\n+  i = 1;\n+\n+  /* These might be handled by store_by_pieces.  */\n+  if (memmove (buf2, \"ABCDEFGHI\", 9) != buf2\n+      || memcmp (buf2, \"ABCDEFGHI\\0\", 11))\n+    abort ();\n+\n+  if (memmove (buf2, \"abcdefghijklmnopq\", 17) != buf2\n+      || memcmp (buf2, \"abcdefghijklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (__builtin_memmove (buf4, \"ABCDEF\", 6) != buf2\n+      || memcmp (buf2, \"ABCDEFghijklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (__builtin_memmove (buf4, \"a\", 1) != buf2\n+      || memcmp (buf2, \"aBCDEFghijklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (memmove (buf4 + 2, \"bcd\" + i++, 2) != buf2 + 2\n+      || memcmp (buf2, \"aBcdEFghijklmnopq\\0\", 19)\n+      || i != 2)\n+    abort ();\n+\n+  /* These might be handled by move_by_pieces.  */\n+  if (memmove (buf4 + 4, buf7, 6) != buf2 + 4\n+      || memcmp (buf2, \"aBcdRSTUVWklmnopq\\0\", 19))\n+    abort ();\n+\n+  /* Side effect.  */\n+  if (__builtin___memmove_chk (buf2 + i++ + 8, buf7 + 1, 1,\n+\t\t\t       os (buf2 + i++ + 8))\n+      != buf2 + 10\n+      || memcmp (buf2, \"aBcdRSTUVWSlmnopq\\0\", 19)\n+      || i != 3)\n+    abort ();\n+\n+  if (memmove (buf4 + 14, buf6, 2) != buf2 + 14\n+      || memcmp (buf2, \"aBcdRSTUVWSlmnrsq\\0\", 19))\n+    abort ();\n+\n+  __builtin_memmove (buf4, \"aBcdEFghijklmnopq\\0\", 19);\n+\n+  /* These should be handled either by movmemendM or memmove\n+     call.  */\n+  if (memmove (buf4 + 4, buf7, n + 6) != buf2 + 4\n+      || memcmp (buf2, \"aBcdRSTUVWklmnopq\\0\", 19))\n+    abort ();\n+\n+  /* Side effect.  */\n+  if (__builtin___memmove_chk (buf2 + i++ + 8, buf7 + 1, n + 1,\n+\t\t\t       os (buf2 + i++ + 8))\n+      != buf2 + 11\n+      || memcmp (buf2, \"aBcdRSTUVWkSmnopq\\0\", 19)\n+      || i != 4)\n+    abort ();\n+\n+  if (memmove (buf4 + 14, buf6, n + 2) != buf2 + 14\n+      || memcmp (buf2, \"aBcdRSTUVWkSmnrsq\\0\", 19))\n+    abort ();\n+\n+  if (chk_calls)\n+    abort ();\n+}\n+\n+void\n+__attribute__((noinline))\n+test2 (void)\n+{\n+  long *x;\n+  char *y;\n+  int z;\n+  __builtin_memmove (buf5, \"RSTUVWXYZ0123456789\", 20);\n+  __builtin_memmove (buf7, \"RSTUVWXYZ0123456789\", 20);\n+ __asm (\"\" : \"=r\" (x) : \"0\" (buf1));\n+ __asm (\"\" : \"=r\" (y) : \"0\" (buf2));\n+ __asm (\"\" : \"=r\" (z) : \"0\" (0));\n+  test2_sub (x, y, \"rstuvwxyz\", z);\n+}\n+\n+static const struct foo\n+{\n+  char *s;\n+  double d;\n+  long l;\n+} foo[] =\n+{\n+  { \"hello world1\", 3.14159, 101L },\n+  { \"hello world2\", 3.14159, 102L },\n+  { \"hello world3\", 3.14159, 103L },\n+  { \"hello world4\", 3.14159, 104L },\n+  { \"hello world5\", 3.14159, 105L },\n+  { \"hello world6\", 3.14159, 106L }\n+};\n+\n+static const struct bar\n+{\n+  char *s;\n+  const struct foo f[3];\n+} bar[] =\n+{\n+  {\n+    \"hello world10\",\n+    {\n+      { \"hello1\", 3.14159, 201L },\n+      { \"hello2\", 3.14159, 202L },\n+      { \"hello3\", 3.14159, 203L },\n+    }\n+  },\n+  {\n+    \"hello world11\",\n+    {\n+      { \"hello4\", 3.14159, 204L },\n+      { \"hello5\", 3.14159, 205L },\n+      { \"hello6\", 3.14159, 206L },\n+    }\n+  }\n+};\n+\n+static const int baz[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n+\n+void\n+__attribute__((noinline))\n+test3 (void)\n+{\n+  const char *s;\n+  struct foo f1[sizeof foo/sizeof*foo];\n+  struct bar b1[sizeof bar/sizeof*bar];\n+  int bz[sizeof baz/sizeof*baz];\n+\n+  /* All the memmove/__builtin_memmove calls in this routine have fixed\n+     length.  */\n+  chk_calls = 0;\n+\n+  /* All the *memmove calls below have src in read-only memory, so all\n+     of them should be optimized into memcpy.  */\n+  memmove_disallowed = 1;\n+  if (memmove (f1, foo, sizeof (foo)) != f1 || memcmp (f1, foo, sizeof (foo)))\n+    abort ();\n+  if (memmove (b1, bar, sizeof (bar)) != b1 || memcmp (b1, bar, sizeof (bar)))\n+    abort ();\n+  memmove (bz, baz, sizeof (baz));\n+  if (memcmp (bz, baz, sizeof (baz)))\n+    abort ();\n+\n+  if (memmove (p, \"abcde\", 6) != p || memcmp (p, \"abcde\", 6))\n+    abort ();\n+  s = s1;\n+  if (memmove (p + 2, ++s, 0) != p + 2 || memcmp (p, \"abcde\", 6) || s != s1 + 1)\n+    abort ();\n+  if (__builtin_memmove (p + 3, \"\", 1) != p + 3 || memcmp (p, \"abc\\0e\", 6))\n+    abort ();\n+  memmove (p + 2, \"fghijk\", 4);\n+  if (memcmp (p, \"abfghi\", 7))\n+    abort ();\n+  s = s1 + 1;\n+  memmove (p + 1, s++, 0);\n+  if (memcmp (p, \"abfghi\", 7) || s != s1 + 2)\n+    abort ();\n+  __builtin_memmove (p + 4, \"ABCDE\", 1);\n+  if (memcmp (p, \"abfgAi\", 7))\n+    abort ();\n+\n+  /* memmove with length 1 can be optimized into memcpy if it can be\n+     expanded inline.  */\n+  if (memmove (p + 2, p + 3, 1) != p + 2)\n+    abort ();\n+  if (memcmp (p, \"abggAi\", 7))\n+    abort ();\n+\n+  if (chk_calls)\n+    abort ();\n+  memmove_disallowed = 0;\n+}\n+\n+/* Test whether compile time checking is done where it should\n+   and so is runtime object size checking.  */\n+void\n+__attribute__((noinline))\n+test4 (void)\n+{\n+  struct A { char buf1[10]; char buf2[10]; } a;\n+  char *r = l1 == 1 ? &a.buf1[5] : &a.buf2[4];\n+  char buf3[20];\n+  int i;\n+  size_t l;\n+\n+  /* The following calls should do runtime checking\n+     - length is not known, but destination is.  */\n+  chk_calls = 0;\n+  memmove (a.buf1 + 2, s3, l1);\n+  memmove (r, s3, l1 + 1);\n+  r = l1 == 1 ? __builtin_alloca (4) : &a.buf2[7];\n+  memmove (r, s2, l1 + 2);\n+  memmove (r + 2, s3, l1);\n+  r = buf3;\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[1];\n+      else if (i == l1)\n+\tr = &a.buf2[7];\n+      else if (i == l1 + 1)\n+\tr = &buf3[5];\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[9];\n+    }\n+  memmove (r, s2, l1);\n+  if (chk_calls != 5)\n+    abort ();\n+\n+  /* Following have known destination and known length,\n+     so if optimizing certainly shouldn't result in the checking\n+     variants.  */\n+  chk_calls = 0;\n+  memmove (a.buf1 + 2, s3, 1);\n+  memmove (r, s3, 2);\n+  r = l1 == 1 ? __builtin_alloca (4) : &a.buf2[7];\n+  memmove (r, s2, 3);\n+  r = buf3;\n+  l = 4;\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[1], l = 2;\n+      else if (i == l1)\n+\tr = &a.buf2[7], l = 3;\n+      else if (i == l1 + 1)\n+\tr = &buf3[5], l = 4;\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[9], l = 1;\n+    }\n+  memmove (r, s2, 1);\n+  /* Here, l is known to be at most 4 and __builtin_object_size (&buf3[16], 0)\n+     is 4, so this doesn't need runtime checking.  */\n+  memmove (&buf3[16], s2, l);\n+  if (chk_calls)\n+    abort ();\n+  chk_calls = 0;\n+}\n+\n+/* Test whether runtime and/or compile time checking catches\n+   buffer overflows.  */\n+void\n+__attribute__((noinline))\n+test5 (void)\n+{\n+  struct A { char buf1[10]; char buf2[10]; } a;\n+  char buf3[20];\n+\n+  chk_fail_allowed = 1;\n+  /* Runtime checks.  */\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      memmove (&a.buf2[9], s2, l1 + 1);\n+      abort ();\n+    }\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      memmove (&a.buf2[7], s3, strlen (s3) + 1);\n+      abort ();\n+    }\n+  /* This should be detectable at compile time already.  */\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      memmove (&buf3[19], \"ab\", 2);\n+      abort ();\n+    }\n+  chk_fail_allowed = 0;\n+}\n+\n+#ifndef MAX_OFFSET\n+#define MAX_OFFSET (sizeof (long long))\n+#endif\n+\n+#ifndef MAX_COPY\n+#define MAX_COPY (10 * sizeof (long long))\n+#endif\n+\n+#ifndef MAX_EXTRA\n+#define MAX_EXTRA (sizeof (long long))\n+#endif\n+\n+#define MAX_LENGTH (MAX_OFFSET + MAX_COPY + MAX_EXTRA)\n+\n+/* Use a sequence length that is not divisible by two, to make it more\n+   likely to detect when words are mixed up.  */\n+#define SEQUENCE_LENGTH 31\n+\n+static union {\n+  char buf[MAX_LENGTH];\n+  long long align_int;\n+  long double align_fp;\n+} u1, u2;\n+\n+void\n+__attribute__((noinline))\n+test6 (void)\n+{\n+  int off1, off2, len, i;\n+  char *p, *q, c;\n+\n+  for (off1 = 0; off1 < MAX_OFFSET; off1++)\n+    for (off2 = 0; off2 < MAX_OFFSET; off2++)\n+      for (len = 1; len < MAX_COPY; len++)\n+\t{\n+\t  for (i = 0, c = 'A'; i < MAX_LENGTH; i++, c++)\n+\t    {\n+\t      u1.buf[i] = 'a';\n+\t      if (c >= 'A' + SEQUENCE_LENGTH)\n+\t\tc = 'A';\n+\t      u2.buf[i] = c;\n+\t    }\n+\n+\t  p = memmove (u1.buf + off1, u2.buf + off2, len);\n+\t  if (p != u1.buf + off1)\n+\t    abort ();\n+\n+\t  q = u1.buf;\n+\t  for (i = 0; i < off1; i++, q++)\n+\t    if (*q != 'a')\n+\t      abort ();\n+\n+\t  for (i = 0, c = 'A' + off2; i < len; i++, q++, c++)\n+\t    {\n+\t      if (c >= 'A' + SEQUENCE_LENGTH)\n+\t\tc = 'A';\n+\t      if (*q != c)\n+\t\tabort ();\n+\t    }\n+\n+\t  for (i = 0; i < MAX_EXTRA; i++, q++)\n+\t    if (*q != 'a')\n+\t      abort ();\n+\t}\n+}\n+\n+#define TESTSIZE 80\n+\n+char srcb[TESTSIZE] __attribute__ ((aligned));\n+char dstb[TESTSIZE] __attribute__ ((aligned));\n+\n+void\n+__attribute__((noinline))\n+check (char *test, char *match, int n)\n+{\n+  if (memcmp (test, match, n))\n+    abort ();\n+}\n+\n+#define TN(n) \\\n+{ memset (dstb, 0, n); memmove (dstb, srcb, n); check (dstb, srcb, n); }\n+#define T(n) \\\n+TN (n) \\\n+TN ((n) + 1) \\\n+TN ((n) + 2) \\\n+TN ((n) + 3)\n+\n+void\n+__attribute__((noinline))\n+test7 (void)\n+{\n+  int i;\n+\n+  chk_calls = 0;\n+\n+  for (i = 0; i < sizeof (srcb); ++i)\n+      srcb[i] = 'a' + i % 26;\n+\n+  T (0);\n+  T (4);\n+  T (8);\n+  T (12);\n+  T (16);\n+  T (20);\n+  T (24);\n+  T (28);\n+  T (32);\n+  T (36);\n+  T (40);\n+  T (44);\n+  T (48);\n+  T (52);\n+  T (56);\n+  T (60);\n+  T (64);\n+  T (68);\n+  T (72);\n+  T (76);\n+\n+  /* All memmove calls in this routine have constant arguments.  */\n+  if (chk_calls)\n+    abort ();\n+}\n+\n+void\n+main_test (void)\n+{\n+#ifndef __OPTIMIZE__\n+  /* Object size checking is only intended for -O[s123].  */\n+  return;\n+#endif\n+  __asm (\"\" : \"=r\" (l1) : \"0\" (l1));\n+  test1 ();\n+  test2 ();\n+  __builtin_memset (p, '\\0', sizeof (p));\n+  test3 ();\n+  test4 ();\n+  test5 ();\n+  test6 ();\n+  test7 ();\n+}"}, {"sha": "9daf13e827b5f757f79552f56c57ed55258d8eb3", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/mempcpy-chk-lib.c", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fmempcpy-chk-lib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fmempcpy-chk-lib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fmempcpy-chk-lib.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1 @@\n+#include \"lib/chk.c\""}, {"sha": "a59d59bd85deacf435c15bcd07510c8523269aef", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/mempcpy-chk.c", "status": "added", "additions": 487, "deletions": 0, "changes": 487, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fmempcpy-chk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fmempcpy-chk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fmempcpy-chk.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,487 @@\n+/* Copyright (C) 2004, 2005  Free Software Foundation.\n+\n+   Ensure builtin __mempcpy_chk performs correctly.  */\n+\n+extern void abort (void);\n+typedef __SIZE_TYPE__ size_t;\n+extern size_t strlen(const char *);\n+extern void *memcpy (void *, const void *, size_t);\n+extern void *mempcpy (void *, const void *, size_t);\n+extern int memcmp (const void *, const void *, size_t);\n+\n+#include \"chk.h\"\n+\n+const char s1[] = \"123\";\n+char p[32] = \"\";\n+char *s2 = \"defg\";\n+char *s3 = \"FGH\";\n+size_t l1 = 1;\n+\n+void\n+__attribute__((noinline))\n+test1 (void)\n+{\n+  int i;\n+\n+#if defined __i386__ || defined __x86_64__\n+  /* The functions below might not be optimized into direct stores on all\n+     arches.  It depends on how many instructions would be generated and\n+     what limits the architecture chooses in STORE_BY_PIECES_P.  */\n+  mempcpy_disallowed = 1;\n+#endif\n+\n+  /* All the mempcpy calls in this routine except last have fixed length, so\n+     object size checking should be done at compile time if optimizing.  */\n+  chk_calls = 0;\n+\n+  if (mempcpy (p, \"ABCDE\", 6) != p + 6 || memcmp (p, \"ABCDE\", 6))\n+    abort ();\n+  if (mempcpy (p + 16, \"VWX\" + 1, 2) != p + 16 + 2\n+      || memcmp (p + 16, \"WX\\0\\0\", 5))\n+    abort ();\n+  if (mempcpy (p + 1, \"\", 1) != p + 1 + 1 || memcmp (p, \"A\\0CDE\", 6))\n+    abort ();\n+  if (mempcpy (p + 3, \"FGHI\", 4) != p + 3 + 4 || memcmp (p, \"A\\0CFGHI\", 8))\n+    abort ();\n+\n+  i = 8;\n+  memcpy (p + 20, \"qrstu\", 6);\n+  memcpy (p + 25, \"QRSTU\", 6);\n+  if (mempcpy (p + 25 + 1, s1, 3) != (p + 25 + 1 + 3)\n+      || memcmp (p + 25, \"Q123U\", 6))\n+    abort ();\n+\n+  if (mempcpy (mempcpy (p, \"abcdEFG\", 4), \"efg\", 4) != p + 8\n+      || memcmp (p, \"abcdefg\", 8))\n+    abort();\n+\n+  /* Test at least one instance of the __builtin_ style.  We do this\n+     to ensure that it works and that the prototype is correct.  */\n+  if (__builtin_mempcpy (p, \"ABCDE\", 6) != p + 6 || memcmp (p, \"ABCDE\", 6))\n+    abort ();\n+\n+  /* If the result of mempcpy is ignored, gcc should use memcpy.\n+     This should be optimized always, so disallow mempcpy calls.  */\n+  mempcpy_disallowed = 1;\n+  mempcpy (p + 5, s3, 1);\n+  if (memcmp (p, \"ABCDEFg\", 8))\n+    abort ();\n+\n+  if (chk_calls)\n+    abort ();\n+  chk_calls = 0;\n+\n+  mempcpy (p + 6, s1 + 1, l1);\n+  if (memcmp (p, \"ABCDEF2\", 8))\n+    abort ();\n+\n+  /* The above mempcpy copies into an object with known size, but\n+     unknown length and with result ignored, so it should be a\n+     __memcpy_chk call.  */\n+  if (chk_calls != 1)\n+    abort ();\n+\n+  mempcpy_disallowed = 0;\n+}\n+\n+long buf1[64];\n+char *buf2 = (char *) (buf1 + 32);\n+long buf5[20];\n+char buf7[20];\n+\n+void\n+__attribute__((noinline))\n+test2_sub (long *buf3, char *buf4, char *buf6, int n)\n+{\n+  int i = 0;\n+\n+  /* All the mempcpy/__builtin_mempcpy/__builtin___mempcpy_chk\n+     calls in this routine are either fixed length, or have\n+     side-effects in __builtin_object_size arguments, or\n+     dst doesn't point into a known object.  */\n+  chk_calls = 0;\n+\n+  /* These should probably be handled by store_by_pieces on most arches.  */\n+  if (mempcpy (buf1, \"ABCDEFGHI\", 9) != (char *) buf1 + 9\n+      || memcmp (buf1, \"ABCDEFGHI\\0\", 11))\n+    abort ();\n+\n+  if (mempcpy (buf1, \"abcdefghijklmnopq\", 17) != (char *) buf1 + 17\n+      || memcmp (buf1, \"abcdefghijklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (__builtin_mempcpy (buf3, \"ABCDEF\", 6) != (char *) buf1 + 6\n+      || memcmp (buf1, \"ABCDEFghijklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (__builtin_mempcpy (buf3, \"a\", 1) != (char *) buf1 + 1\n+      || memcmp (buf1, \"aBCDEFghijklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (mempcpy ((char *) buf3 + 2, \"bcd\" + ++i, 2) != (char *) buf1 + 4\n+      || memcmp (buf1, \"aBcdEFghijklmnopq\\0\", 19)\n+      || i != 1)\n+    abort ();\n+\n+  /* These should probably be handled by move_by_pieces on most arches.  */\n+  if (mempcpy ((char *) buf3 + 4, buf5, 6) != (char *) buf1 + 10\n+      || memcmp (buf1, \"aBcdRSTUVWklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (__builtin_mempcpy ((char *) buf1 + ++i + 8, (char *) buf5 + 1, 1)\n+      != (char *) buf1 + 11\n+      || memcmp (buf1, \"aBcdRSTUVWSlmnopq\\0\", 19)\n+      || i != 2)\n+    abort ();\n+\n+  if (mempcpy ((char *) buf3 + 14, buf6, 2) != (char *) buf1 + 16\n+      || memcmp (buf1, \"aBcdRSTUVWSlmnrsq\\0\", 19))\n+    abort ();\n+\n+  if (mempcpy (buf3, buf5, 8) != (char *) buf1 + 8\n+      || memcmp (buf1, \"RSTUVWXYVWSlmnrsq\\0\", 19))\n+    abort ();\n+\n+  if (mempcpy (buf3, buf5, 17) != (char *) buf1 + 17\n+      || memcmp (buf1, \"RSTUVWXYZ01234567\\0\", 19))\n+    abort ();\n+\n+  __builtin_memcpy (buf3, \"aBcdEFghijklmnopq\\0\", 19);\n+\n+  /* These should be handled either by movmemendM or mempcpy\n+     call.  */\n+\n+  /* buf3 points to an unknown object, so __mempcpy_chk should not be done.  */\n+  if (mempcpy ((char *) buf3 + 4, buf5, n + 6) != (char *) buf1 + 10\n+      || memcmp (buf1, \"aBcdRSTUVWklmnopq\\0\", 19))\n+    abort ();\n+\n+  /* This call has side-effects in dst, therefore no checking.  */\n+  if (__builtin___mempcpy_chk ((char *) buf1 + ++i + 8, (char *) buf5 + 1,\n+\t\t\t       n + 1, os ((char *) buf1 + ++i + 8))\n+      != (char *) buf1 + 12\n+      || memcmp (buf1, \"aBcdRSTUVWkSmnopq\\0\", 19)\n+      || i != 3)\n+    abort ();\n+\n+  if (mempcpy ((char *) buf3 + 14, buf6, n + 2) != (char *) buf1 + 16\n+      || memcmp (buf1, \"aBcdRSTUVWkSmnrsq\\0\", 19))\n+    abort ();\n+\n+  i = 1;\n+\n+  /* These might be handled by store_by_pieces.  */\n+  if (mempcpy (buf2, \"ABCDEFGHI\", 9) != buf2 + 9\n+      || memcmp (buf2, \"ABCDEFGHI\\0\", 11))\n+    abort ();\n+\n+  if (mempcpy (buf2, \"abcdefghijklmnopq\", 17) != buf2 + 17\n+      || memcmp (buf2, \"abcdefghijklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (__builtin_mempcpy (buf4, \"ABCDEF\", 6) != buf2 + 6\n+      || memcmp (buf2, \"ABCDEFghijklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (__builtin_mempcpy (buf4, \"a\", 1) != buf2 + 1\n+      || memcmp (buf2, \"aBCDEFghijklmnopq\\0\", 19))\n+    abort ();\n+\n+  if (mempcpy (buf4 + 2, \"bcd\" + i++, 2) != buf2 + 4\n+      || memcmp (buf2, \"aBcdEFghijklmnopq\\0\", 19)\n+      || i != 2)\n+    abort ();\n+\n+  /* These might be handled by move_by_pieces.  */\n+  if (mempcpy (buf4 + 4, buf7, 6) != buf2 + 10\n+      || memcmp (buf2, \"aBcdRSTUVWklmnopq\\0\", 19))\n+    abort ();\n+\n+  /* Side effect.  */\n+  if (__builtin___mempcpy_chk (buf2 + i++ + 8, buf7 + 1, 1,\n+\t\t\t       os (buf2 + i++ + 8))\n+      != buf2 + 11\n+      || memcmp (buf2, \"aBcdRSTUVWSlmnopq\\0\", 19)\n+      || i != 3)\n+    abort ();\n+\n+  if (mempcpy (buf4 + 14, buf6, 2) != buf2 + 16\n+      || memcmp (buf2, \"aBcdRSTUVWSlmnrsq\\0\", 19))\n+    abort ();\n+\n+  __builtin_memcpy (buf4, \"aBcdEFghijklmnopq\\0\", 19);\n+\n+  /* These should be handled either by movmemendM or mempcpy\n+     call.  */\n+  if (mempcpy (buf4 + 4, buf7, n + 6) != buf2 + 10\n+      || memcmp (buf2, \"aBcdRSTUVWklmnopq\\0\", 19))\n+    abort ();\n+\n+  /* Side effect.  */\n+  if (__builtin___mempcpy_chk (buf2 + i++ + 8, buf7 + 1,\n+\t\t\t       n + 1, os (buf2 + i++ + 8))\n+      != buf2 + 12\n+      || memcmp (buf2, \"aBcdRSTUVWkSmnopq\\0\", 19)\n+      || i != 4)\n+    abort ();\n+\n+  if (mempcpy (buf4 + 14, buf6, n + 2) != buf2 + 16\n+      || memcmp (buf2, \"aBcdRSTUVWkSmnrsq\\0\", 19))\n+    abort ();\n+\n+  if (chk_calls)\n+    abort ();\n+}\n+\n+void\n+__attribute__((noinline))\n+test2 (void)\n+{\n+  long *x;\n+  char *y;\n+  int z;\n+  __builtin_memcpy (buf5, \"RSTUVWXYZ0123456789\", 20);\n+  __builtin_memcpy (buf7, \"RSTUVWXYZ0123456789\", 20);\n+ __asm (\"\" : \"=r\" (x) : \"0\" (buf1));\n+ __asm (\"\" : \"=r\" (y) : \"0\" (buf2));\n+ __asm (\"\" : \"=r\" (z) : \"0\" (0));\n+  test2_sub (x, y, \"rstuvwxyz\", z);\n+}\n+\n+volatile void *vx;\n+\n+/* Test whether compile time checking is done where it should\n+   and so is runtime object size checking.  */\n+void\n+__attribute__((noinline))\n+test3 (void)\n+{\n+  struct A { char buf1[10]; char buf2[10]; } a;\n+  char *r = l1 == 1 ? &a.buf1[5] : &a.buf2[4];\n+  char buf3[20];\n+  int i;\n+  size_t l;\n+\n+  /* The following calls should do runtime checking\n+     - length is not known, but destination is.  */\n+  chk_calls = 0;\n+  vx = mempcpy (a.buf1 + 2, s3, l1);\n+  vx = mempcpy (r, s3, l1 + 1);\n+  r = l1 == 1 ? __builtin_alloca (4) : &a.buf2[7];\n+  vx = mempcpy (r, s2, l1 + 2);\n+  vx = mempcpy (r + 2, s3, l1);\n+  r = buf3;\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[1];\n+      else if (i == l1)\n+\tr = &a.buf2[7];\n+      else if (i == l1 + 1)\n+\tr = &buf3[5];\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[9];\n+    }\n+  vx = mempcpy (r, s2, l1);\n+  if (chk_calls != 5)\n+    abort ();\n+\n+  /* Following have known destination and known length,\n+     so if optimizing certainly shouldn't result in the checking\n+     variants.  */\n+  chk_calls = 0;\n+  vx = mempcpy (a.buf1 + 2, s3, 1);\n+  vx = mempcpy (r, s3, 2);\n+  r = l1 == 1 ? __builtin_alloca (4) : &a.buf2[7];\n+  vx = mempcpy (r, s2, 3);\n+  r = buf3;\n+  l = 4;\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[1], l = 2;\n+      else if (i == l1)\n+\tr = &a.buf2[7], l = 3;\n+      else if (i == l1 + 1)\n+\tr = &buf3[5], l = 4;\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[9], l = 1;\n+    }\n+  vx = mempcpy (r, s2, 1);\n+  /* Here, l is known to be at most 4 and __builtin_object_size (&buf3[16], 0)\n+     is 4, so this doesn't need runtime checking.  */\n+  vx = mempcpy (&buf3[16], s2, l);\n+  if (chk_calls)\n+    abort ();\n+  chk_calls = 0;\n+}\n+\n+/* Test whether runtime and/or compile time checking catches\n+   buffer overflows.  */\n+void\n+__attribute__((noinline))\n+test4 (void)\n+{\n+  struct A { char buf1[10]; char buf2[10]; } a;\n+  char buf3[20];\n+\n+  chk_fail_allowed = 1;\n+  /* Runtime checks.  */\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      vx = mempcpy (&a.buf2[9], s2, l1 + 1);\n+      abort ();\n+    }\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      vx = mempcpy (&a.buf2[7], s3, strlen (s3) + 1);\n+      abort ();\n+    }\n+  /* This should be detectable at compile time already.  */\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      vx = mempcpy (&buf3[19], \"ab\", 2);\n+      abort ();\n+    }\n+  chk_fail_allowed = 0;\n+}\n+\n+#ifndef MAX_OFFSET\n+#define MAX_OFFSET (sizeof (long long))\n+#endif\n+\n+#ifndef MAX_COPY\n+#define MAX_COPY (10 * sizeof (long long))\n+#endif\n+\n+#ifndef MAX_EXTRA\n+#define MAX_EXTRA (sizeof (long long))\n+#endif\n+\n+#define MAX_LENGTH (MAX_OFFSET + MAX_COPY + MAX_EXTRA)\n+\n+/* Use a sequence length that is not divisible by two, to make it more\n+   likely to detect when words are mixed up.  */\n+#define SEQUENCE_LENGTH 31\n+\n+static union {\n+  char buf[MAX_LENGTH];\n+  long long align_int;\n+  long double align_fp;\n+} u1, u2;\n+\n+void\n+__attribute__((noinline))\n+test5 (void)\n+{\n+  int off1, off2, len, i;\n+  char *p, *q, c;\n+\n+  for (off1 = 0; off1 < MAX_OFFSET; off1++)\n+    for (off2 = 0; off2 < MAX_OFFSET; off2++)\n+      for (len = 1; len < MAX_COPY; len++)\n+\t{\n+\t  for (i = 0, c = 'A'; i < MAX_LENGTH; i++, c++)\n+\t    {\n+\t      u1.buf[i] = 'a';\n+\t      if (c >= 'A' + SEQUENCE_LENGTH)\n+\t\tc = 'A';\n+\t      u2.buf[i] = c;\n+\t    }\n+\n+\t  p = mempcpy (u1.buf + off1, u2.buf + off2, len);\n+\t  if (p != u1.buf + off1 + len)\n+\t    abort ();\n+\n+\t  q = u1.buf;\n+\t  for (i = 0; i < off1; i++, q++)\n+\t    if (*q != 'a')\n+\t      abort ();\n+\n+\t  for (i = 0, c = 'A' + off2; i < len; i++, q++, c++)\n+\t    {\n+\t      if (c >= 'A' + SEQUENCE_LENGTH)\n+\t\tc = 'A';\n+\t      if (*q != c)\n+\t\tabort ();\n+\t    }\n+\n+\t  for (i = 0; i < MAX_EXTRA; i++, q++)\n+\t    if (*q != 'a')\n+\t      abort ();\n+\t}\n+}\n+\n+#define TESTSIZE 80\n+\n+char srcb[TESTSIZE] __attribute__ ((aligned));\n+char dstb[TESTSIZE] __attribute__ ((aligned));\n+\n+void\n+__attribute__((noinline))\n+check (char *test, char *match, int n)\n+{\n+  if (memcmp (test, match, n))\n+    abort ();\n+}\n+\n+#define TN(n) \\\n+{ memset (dstb, 0, n); vx = mempcpy (dstb, srcb, n); check (dstb, srcb, n); }\n+#define T(n) \\\n+TN (n) \\\n+TN ((n) + 1) \\\n+TN ((n) + 2) \\\n+TN ((n) + 3)\n+\n+void\n+__attribute__((noinline))\n+test6 (void)\n+{\n+  int i;\n+\n+  chk_calls = 0;\n+\n+  for (i = 0; i < sizeof (srcb); ++i)\n+      srcb[i] = 'a' + i % 26;\n+\n+  T (0);\n+  T (4);\n+  T (8);\n+  T (12);\n+  T (16);\n+  T (20);\n+  T (24);\n+  T (28);\n+  T (32);\n+  T (36);\n+  T (40);\n+  T (44);\n+  T (48);\n+  T (52);\n+  T (56);\n+  T (60);\n+  T (64);\n+  T (68);\n+  T (72);\n+  T (76);\n+\n+  /* All mempcpy calls in this routine have constant arguments.  */\n+  if (chk_calls)\n+    abort ();\n+}\n+\n+void\n+main_test (void)\n+{\n+#ifndef __OPTIMIZE__\n+  /* Object size checking is only intended for -O[s123].  */\n+  return;\n+#endif\n+  __asm (\"\" : \"=r\" (l1) : \"0\" (l1));\n+  test1 ();\n+  test2 ();\n+  test3 ();\n+  test4 ();\n+  test5 ();\n+  test6 ();\n+}"}, {"sha": "9daf13e827b5f757f79552f56c57ed55258d8eb3", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/memset-chk-lib.c", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fmemset-chk-lib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fmemset-chk-lib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fmemset-chk-lib.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1 @@\n+#include \"lib/chk.c\""}, {"sha": "a8f09a739312e83b53da092cd03bbe219df86360", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/memset-chk.c", "status": "added", "additions": 721, "deletions": 0, "changes": 721, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fmemset-chk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fmemset-chk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fmemset-chk.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,721 @@\n+/* Copyright (C) 2004, 2005  Free Software Foundation.\n+\n+   Ensure builtin __memset_chk performs correctly.  */\n+\n+extern void abort (void);\n+typedef __SIZE_TYPE__ size_t;\n+extern size_t strlen(const char *);\n+extern void *memcpy (void *, const void *, size_t);\n+extern void *memset (void *, int, size_t);\n+extern int memcmp (const void *, const void *, size_t);\n+\n+#include \"chk.h\"\n+\n+char buffer[32];\n+int argc = 1;\n+size_t l1 = 1;\n+char *s3 = \"FGH\";\n+char *s4;\n+\n+void\n+__attribute__((noinline))\n+test1 (void)\n+{\n+  memset_disallowed = 1;\n+  chk_calls = 0;\n+  memset (buffer, argc, 0);\n+  memset (buffer, argc, 1);\n+  memset (buffer, argc, 2);\n+  memset (buffer, argc, 3);\n+  memset (buffer, argc, 4);\n+  memset (buffer, argc, 5);\n+  memset (buffer, argc, 6);\n+  memset (buffer, argc, 7);\n+  memset (buffer, argc, 8);\n+  memset (buffer, argc, 9);\n+  memset (buffer, argc, 10);\n+  memset (buffer, argc, 11);\n+  memset (buffer, argc, 12);\n+  memset (buffer, argc, 13);\n+  memset (buffer, argc, 14);\n+  memset (buffer, argc, 15);\n+  memset (buffer, argc, 16);\n+  memset (buffer, argc, 17);\n+  memset_disallowed = 0;\n+  if (chk_calls)\n+    abort ();\n+}\n+\n+/* Test whether compile time checking is done where it should\n+   and so is runtime object size checking.  */\n+void\n+__attribute__((noinline))\n+test2 (void)\n+{\n+  struct A { char buf1[10]; char buf2[10]; } a;\n+  char *r = l1 == 1 ? &a.buf1[5] : &a.buf2[4];\n+  char buf3[20];\n+  int i;\n+  size_t l;\n+\n+  /* The following calls should do runtime checking\n+     - length is not known, but destination is.  */\n+  chk_calls = 0;\n+  memset (a.buf1 + 2, 'a', l1);\n+  memset (r, '\\0', l1 + 1);\n+  r = l1 == 1 ? __builtin_alloca (4) : &a.buf2[7];\n+  memset (r, argc, l1 + 2);\n+  memset (r + 2, 'Q', l1);\n+  r = buf3;\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[1];\n+      else if (i == l1)\n+\tr = &a.buf2[7];\n+      else if (i == l1 + 1)\n+\tr = &buf3[5];\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[9];\n+    }\n+  memset (r, '\\0', l1);\n+  if (chk_calls != 5)\n+    abort ();\n+\n+  /* Following have known destination and known length,\n+     so if optimizing certainly shouldn't result in the checking\n+     variants.  */\n+  chk_calls = 0;\n+  memset (a.buf1 + 2, '\\0', 1);\n+  memset (r, argc, 2);\n+  r = l1 == 1 ? __builtin_alloca (4) : &a.buf2[7];\n+  memset (r, 'N', 3);\n+  r = buf3;\n+  l = 4;\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[1], l = 2;\n+      else if (i == l1)\n+\tr = &a.buf2[7], l = 3;\n+      else if (i == l1 + 1)\n+\tr = &buf3[5], l = 4;\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[9], l = 1;\n+    }\n+  memset (r, 'H', 1);\n+  /* Here, l is known to be at most 4 and __builtin_object_size (&buf3[16], 0)\n+     is 4, so this doesn't need runtime checking.  */\n+  memset (&buf3[16], 'd', l);\n+  /* Neither length nor destination known.  Doesn't need runtime checking.  */\n+  memset (s4, 'a', l1);\n+  memset (s4 + 2, '\\0', l1 + 2);\n+  /* Destination unknown.  */\n+  memset (s4 + 4, 'b', 2);\n+  memset (s4 + 6, '\\0', 4);\n+  if (chk_calls)\n+    abort ();\n+  chk_calls = 0;\n+}\n+\n+/* Test whether runtime and/or compile time checking catches\n+   buffer overflows.  */\n+void\n+__attribute__((noinline))\n+test3 (void)\n+{\n+  struct A { char buf1[10]; char buf2[10]; } a;\n+  char buf3[20];\n+\n+  chk_fail_allowed = 1;\n+  /* Runtime checks.  */\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      memset (&a.buf2[9], '\\0', l1 + 1);\n+      abort ();\n+    }\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      memset (&a.buf2[7], 'T', strlen (s3) + 1);\n+      abort ();\n+    }\n+  /* This should be detectable at compile time already.  */\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      memset (&buf3[19], 'b', 2);\n+      abort ();\n+    }\n+  chk_fail_allowed = 0;\n+}\n+\n+#ifndef MAX_OFFSET\n+#define MAX_OFFSET (sizeof (long long))\n+#endif\n+\n+#ifndef MAX_COPY\n+#define MAX_COPY (10 * sizeof (long long))\n+#define MAX_COPY2 15\n+#else\n+#define MAX_COPY2 MAX_COPY\n+#endif\n+\n+#ifndef MAX_EXTRA\n+#define MAX_EXTRA (sizeof (long long))\n+#endif\n+\n+#define MAX_LENGTH (MAX_OFFSET + MAX_COPY + MAX_EXTRA)\n+#define MAX_LENGTH2 (MAX_OFFSET + MAX_COPY2 + MAX_EXTRA)\n+\n+static union {\n+  char buf[MAX_LENGTH];\n+  long long align_int;\n+  long double align_fp;\n+} u;\n+\n+char A = 'A';\n+\n+void\n+__attribute__((noinline))\n+test4 (void)\n+{\n+  int off, len, i;\n+  char *p, *q;\n+\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    for (len = 1; len < MAX_COPY; len++)\n+      {\n+\tfor (i = 0; i < MAX_LENGTH; i++)\n+\t  u.buf[i] = 'a';\n+\n+\tp = memset (u.buf + off, '\\0', len);\n+\tif (p != u.buf + off)\n+\t  abort ();\n+\n+\tq = u.buf;\n+\tfor (i = 0; i < off; i++, q++)\n+\t  if (*q != 'a')\n+\t    abort ();\n+\n+\tfor (i = 0; i < len; i++, q++)\n+\t  if (*q != '\\0')\n+\t    abort ();\n+\n+\tfor (i = 0; i < MAX_EXTRA; i++, q++)\n+\t  if (*q != 'a')\n+\t    abort ();\n+\n+\tp = memset (u.buf + off, A, len);\n+\tif (p != u.buf + off)\n+\t  abort ();\n+\n+\tq = u.buf;\n+\tfor (i = 0; i < off; i++, q++)\n+\t  if (*q != 'a')\n+\t    abort ();\n+\n+\tfor (i = 0; i < len; i++, q++)\n+\t  if (*q != 'A')\n+\t    abort ();\n+\n+\tfor (i = 0; i < MAX_EXTRA; i++, q++)\n+\t  if (*q != 'a')\n+\t    abort ();\n+\n+\tp = memset (u.buf + off, 'B', len);\n+\tif (p != u.buf + off)\n+\t  abort ();\n+\n+\tq = u.buf;\n+\tfor (i = 0; i < off; i++, q++)\n+\t  if (*q != 'a')\n+\t    abort ();\n+\n+\tfor (i = 0; i < len; i++, q++)\n+\t  if (*q != 'B')\n+\t    abort ();\n+\n+\tfor (i = 0; i < MAX_EXTRA; i++, q++)\n+\t  if (*q != 'a')\n+\t    abort ();\n+      }\n+}\n+\n+static union {\n+  char buf[MAX_LENGTH2];\n+  long long align_int;\n+  long double align_fp;\n+} u2;\n+\n+void reset ()\n+{\n+  int i;\n+\n+  for (i = 0; i < MAX_LENGTH2; i++)\n+    u2.buf[i] = 'a';\n+}\n+\n+void check (int off, int len, int ch)\n+{\n+  char *q;\n+  int i;\n+\n+  q = u2.buf;\n+  for (i = 0; i < off; i++, q++)\n+    if (*q != 'a')\n+      abort ();\n+\n+  for (i = 0; i < len; i++, q++)\n+    if (*q != ch)\n+      abort ();\n+\n+  for (i = 0; i < MAX_EXTRA; i++, q++)\n+    if (*q != 'a')\n+      abort ();\n+}\n+\n+void\n+__attribute__((noinline))\n+test5 (void)\n+{\n+  int off;\n+  char *p;\n+\n+  /* len == 1 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u2.buf + off, '\\0', 1);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 1, '\\0');\n+\n+      p = memset (u2.buf + off, A, 1);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 1, 'A');\n+\n+      p = memset (u2.buf + off, 'B', 1);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 1, 'B');\n+    }\n+\n+  /* len == 2 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u2.buf + off, '\\0', 2);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 2, '\\0');\n+\n+      p = memset (u2.buf + off, A, 2);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 2, 'A');\n+\n+      p = memset (u2.buf + off, 'B', 2);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 2, 'B');\n+    }\n+\n+  /* len == 3 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u2.buf + off, '\\0', 3);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 3, '\\0');\n+\n+      p = memset (u2.buf + off, A, 3);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 3, 'A');\n+\n+      p = memset (u2.buf + off, 'B', 3);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 3, 'B');\n+    }\n+\n+  /* len == 4 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u2.buf + off, '\\0', 4);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 4, '\\0');\n+\n+      p = memset (u2.buf + off, A, 4);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 4, 'A');\n+\n+      p = memset (u2.buf + off, 'B', 4);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 4, 'B');\n+    }\n+\n+  /* len == 5 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u2.buf + off, '\\0', 5);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 5, '\\0');\n+\n+      p = memset (u2.buf + off, A, 5);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 5, 'A');\n+\n+      p = memset (u2.buf + off, 'B', 5);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 5, 'B');\n+    }\n+\n+  /* len == 6 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u2.buf + off, '\\0', 6);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 6, '\\0');\n+\n+      p = memset (u2.buf + off, A, 6);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 6, 'A');\n+\n+      p = memset (u2.buf + off, 'B', 6);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 6, 'B');\n+    }\n+\n+  /* len == 7 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u2.buf + off, '\\0', 7);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 7, '\\0');\n+\n+      p = memset (u2.buf + off, A, 7);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 7, 'A');\n+\n+      p = memset (u2.buf + off, 'B', 7);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 7, 'B');\n+    }\n+\n+  /* len == 8 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u2.buf + off, '\\0', 8);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 8, '\\0');\n+\n+      p = memset (u2.buf + off, A, 8);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 8, 'A');\n+\n+      p = memset (u2.buf + off, 'B', 8);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 8, 'B');\n+    }\n+\n+  /* len == 9 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u2.buf + off, '\\0', 9);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 9, '\\0');\n+\n+      p = memset (u2.buf + off, A, 9);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 9, 'A');\n+\n+      p = memset (u2.buf + off, 'B', 9);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 9, 'B');\n+    }\n+\n+  /* len == 10 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u2.buf + off, '\\0', 10);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 10, '\\0');\n+\n+      p = memset (u2.buf + off, A, 10);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 10, 'A');\n+\n+      p = memset (u2.buf + off, 'B', 10);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 10, 'B');\n+    }\n+\n+  /* len == 11 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u2.buf + off, '\\0', 11);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 11, '\\0');\n+\n+      p = memset (u2.buf + off, A, 11);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 11, 'A');\n+\n+      p = memset (u2.buf + off, 'B', 11);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 11, 'B');\n+    }\n+\n+  /* len == 12 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u2.buf + off, '\\0', 12);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 12, '\\0');\n+\n+      p = memset (u2.buf + off, A, 12);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 12, 'A');\n+\n+      p = memset (u2.buf + off, 'B', 12);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 12, 'B');\n+    }\n+\n+  /* len == 13 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u2.buf + off, '\\0', 13);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 13, '\\0');\n+\n+      p = memset (u2.buf + off, A, 13);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 13, 'A');\n+\n+      p = memset (u2.buf + off, 'B', 13);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 13, 'B');\n+    }\n+\n+  /* len == 14 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u2.buf + off, '\\0', 14);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 14, '\\0');\n+\n+      p = memset (u2.buf + off, A, 14);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 14, 'A');\n+\n+      p = memset (u2.buf + off, 'B', 14);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 14, 'B');\n+    }\n+\n+  /* len == 15 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u2.buf + off, '\\0', 15);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 15, '\\0');\n+\n+      p = memset (u2.buf + off, A, 15);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 15, 'A');\n+\n+      p = memset (u2.buf + off, 'B', 15);\n+      if (p != u2.buf + off) abort ();\n+      check (off, 15, 'B');\n+    }\n+}\n+\n+void\n+__attribute__((noinline))\n+test6 (void)\n+{\n+  int len;\n+  char *p;\n+\n+  /* off == 0 */\n+  for (len = 0; len < MAX_COPY2; len++)\n+    {\n+      reset ();\n+\n+      p = memset (u2.buf, '\\0', len);\n+      if (p != u2.buf) abort ();\n+      check (0, len, '\\0');\n+\n+      p = memset (u2.buf, A, len);\n+      if (p != u2.buf) abort ();\n+      check (0, len, 'A');\n+\n+      p = memset (u2.buf, 'B', len);\n+      if (p != u2.buf) abort ();\n+      check (0, len, 'B');\n+    }\n+\n+  /* off == 1 */\n+  for (len = 0; len < MAX_COPY2; len++)\n+    {\n+      reset ();\n+\n+      p = memset (u2.buf+1, '\\0', len);\n+      if (p != u2.buf+1) abort ();\n+      check (1, len, '\\0');\n+\n+      p = memset (u2.buf+1, A, len);\n+      if (p != u2.buf+1) abort ();\n+      check (1, len, 'A');\n+\n+      p = memset (u2.buf+1, 'B', len);\n+      if (p != u2.buf+1) abort ();\n+      check (1, len, 'B');\n+    }\n+\n+  /* off == 2 */\n+  for (len = 0; len < MAX_COPY2; len++)\n+    {\n+      reset ();\n+\n+      p = memset (u2.buf+2, '\\0', len);\n+      if (p != u2.buf+2) abort ();\n+      check (2, len, '\\0');\n+\n+      p = memset (u2.buf+2, A, len);\n+      if (p != u2.buf+2) abort ();\n+      check (2, len, 'A');\n+\n+      p = memset (u2.buf+2, 'B', len);\n+      if (p != u2.buf+2) abort ();\n+      check (2, len, 'B');\n+    }\n+\n+  /* off == 3 */\n+  for (len = 0; len < MAX_COPY2; len++)\n+    {\n+      reset ();\n+\n+      p = memset (u2.buf+3, '\\0', len);\n+      if (p != u2.buf+3) abort ();\n+      check (3, len, '\\0');\n+\n+      p = memset (u2.buf+3, A, len);\n+      if (p != u2.buf+3) abort ();\n+      check (3, len, 'A');\n+\n+      p = memset (u2.buf+3, 'B', len);\n+      if (p != u2.buf+3) abort ();\n+      check (3, len, 'B');\n+    }\n+\n+  /* off == 4 */\n+  for (len = 0; len < MAX_COPY2; len++)\n+    {\n+      reset ();\n+\n+      p = memset (u2.buf+4, '\\0', len);\n+      if (p != u2.buf+4) abort ();\n+      check (4, len, '\\0');\n+\n+      p = memset (u2.buf+4, A, len);\n+      if (p != u2.buf+4) abort ();\n+      check (4, len, 'A');\n+\n+      p = memset (u2.buf+4, 'B', len);\n+      if (p != u2.buf+4) abort ();\n+      check (4, len, 'B');\n+    }\n+\n+  /* off == 5 */\n+  for (len = 0; len < MAX_COPY2; len++)\n+    {\n+      reset ();\n+\n+      p = memset (u2.buf+5, '\\0', len);\n+      if (p != u2.buf+5) abort ();\n+      check (5, len, '\\0');\n+\n+      p = memset (u2.buf+5, A, len);\n+      if (p != u2.buf+5) abort ();\n+      check (5, len, 'A');\n+\n+      p = memset (u2.buf+5, 'B', len);\n+      if (p != u2.buf+5) abort ();\n+      check (5, len, 'B');\n+    }\n+\n+  /* off == 6 */\n+  for (len = 0; len < MAX_COPY2; len++)\n+    {\n+      reset ();\n+\n+      p = memset (u2.buf+6, '\\0', len);\n+      if (p != u2.buf+6) abort ();\n+      check (6, len, '\\0');\n+\n+      p = memset (u2.buf+6, A, len);\n+      if (p != u2.buf+6) abort ();\n+      check (6, len, 'A');\n+\n+      p = memset (u2.buf+6, 'B', len);\n+      if (p != u2.buf+6) abort ();\n+      check (6, len, 'B');\n+    }\n+\n+  /* off == 7 */\n+  for (len = 0; len < MAX_COPY2; len++)\n+    {\n+      reset ();\n+\n+      p = memset (u2.buf+7, '\\0', len);\n+      if (p != u2.buf+7) abort ();\n+      check (7, len, '\\0');\n+\n+      p = memset (u2.buf+7, A, len);\n+      if (p != u2.buf+7) abort ();\n+      check (7, len, 'A');\n+\n+      p = memset (u2.buf+7, 'B', len);\n+      if (p != u2.buf+7) abort ();\n+      check (7, len, 'B');\n+    }\n+}\n+\n+void\n+main_test (void)\n+{\n+#ifndef __OPTIMIZE__\n+  /* Object size checking is only intended for -O[s123].  */\n+  return;\n+#endif\n+  __asm (\"\" : \"=r\" (l1) : \"0\" (l1));\n+  s4 = buffer;\n+  test1 ();\n+  test2 ();\n+  test3 ();\n+  test4 ();\n+  test5 ();\n+  test6 ();\n+}"}, {"sha": "9daf13e827b5f757f79552f56c57ed55258d8eb3", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/snprintf-chk-lib.c", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fsnprintf-chk-lib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fsnprintf-chk-lib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fsnprintf-chk-lib.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1 @@\n+#include \"lib/chk.c\""}, {"sha": "e6ddc08603861d0ed5d853b74fb4d864d2a0715e", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/snprintf-chk.c", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fsnprintf-chk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fsnprintf-chk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fsnprintf-chk.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,220 @@\n+/* Copyright (C) 2004, 2005  Free Software Foundation.\n+\n+   Ensure builtin __snprintf_chk performs correctly.  */\n+\n+extern void abort (void);\n+typedef __SIZE_TYPE__ size_t;\n+extern size_t strlen(const char *);\n+extern void *memcpy (void *, const void *, size_t);\n+extern char *strcpy (char *, const char *);\n+extern int memcmp (const void *, const void *, size_t);\n+extern void *memset (void *, int, size_t);\n+extern int sprintf (char *, const char *, ...);\n+extern int snprintf (char *, size_t, const char *, ...);\n+\n+#include \"chk.h\"\n+\n+const char s1[] = \"123\";\n+char p[32] = \"\";\n+char *s2 = \"defg\";\n+char *s3 = \"FGH\";\n+char *s4;\n+size_t l1 = 1;\n+static char buffer[32];\n+char *ptr = \"barf\";\n+\n+void\n+__attribute__((noinline))\n+test1 (void)\n+{\n+  chk_calls = 0;\n+  /* snprintf_disallowed = 1; */\n+\n+  memset (buffer, 'A', 32);\n+  snprintf (buffer, 4, \"foo\");\n+  if (memcmp (buffer, \"foo\", 4) || buffer[4] != 'A')\n+    abort ();\n+\n+  memset (buffer, 'A', 32);\n+  if (snprintf (buffer, 4, \"foo bar\") != 7)\n+    abort ();\n+  if (memcmp (buffer, \"foo\", 4) || buffer[4] != 'A')\n+    abort ();\n+\n+  memset (buffer, 'A', 32);\n+  snprintf (buffer, 32, \"%s\", \"bar\");\n+  if (memcmp (buffer, \"bar\", 4) || buffer[4] != 'A')\n+    abort ();\n+\n+  memset (buffer, 'A', 32);\n+  if (snprintf (buffer, 21, \"%s\", \"bar\") != 3)\n+    abort ();\n+  if (memcmp (buffer, \"bar\", 4) || buffer[4] != 'A')\n+    abort ();\n+\n+  snprintf_disallowed = 0;\n+\n+  memset (buffer, 'A', 32);\n+  if (snprintf (buffer, 4, \"%d%d%d\", (int) l1, (int) l1 + 1, (int) l1 + 12)\n+      != 4)\n+    abort ();\n+  if (memcmp (buffer, \"121\", 4) || buffer[4] != 'A')\n+    abort ();\n+\n+  memset (buffer, 'A', 32);\n+  if (snprintf (buffer, 32, \"%d%d%d\", (int) l1, (int) l1 + 1, (int) l1 + 12)\n+      != 4)\n+    abort ();\n+  if (memcmp (buffer, \"1213\", 5) || buffer[5] != 'A')\n+    abort ();\n+\n+  if (chk_calls)\n+    abort ();\n+\n+  memset (buffer, 'A', 32);\n+  snprintf (buffer, strlen (ptr) + 1, \"%s\", ptr);\n+  if (memcmp (buffer, \"barf\", 5) || buffer[5] != 'A')\n+    abort ();\n+\n+  memset (buffer, 'A', 32);\n+  snprintf (buffer, l1 + 31, \"%d - %c\", (int) l1 + 27, *ptr);\n+  if (memcmp (buffer, \"28 - b\\0AAAAA\", 12))\n+    abort ();\n+\n+  if (chk_calls != 2)\n+    abort ();\n+  chk_calls = 0;\n+\n+  memset (s4, 'A', 32);\n+  snprintf (s4, l1 + 6, \"%d - %c\", (int) l1 - 17, ptr[1]);\n+  if (memcmp (s4, \"-16 - \\0AAA\", 10))\n+    abort ();\n+  if (chk_calls)\n+    abort ();\n+}\n+\n+/* Test whether compile time checking is done where it should\n+   and so is runtime object size checking.  */\n+void\n+__attribute__((noinline))\n+test2 (void)\n+{\n+  struct A { char buf1[10]; char buf2[10]; } a;\n+  char *r = l1 == 1 ? &a.buf1[5] : &a.buf2[4];\n+  char buf3[20];\n+  int i;\n+\n+  /* The following calls should do runtime checking\n+     - length is not known, but destination is.  */\n+  chk_calls = 0;\n+  snprintf (a.buf1 + 2, l1, \"%s\", s3 + 3);\n+  snprintf (r, l1 + 4, \"%s%c\", s3 + 3, s3[3]);\n+  r = l1 == 1 ? __builtin_alloca (4) : &a.buf2[7];\n+  snprintf (r, strlen (s2) - 2, \"%c %s\", s2[2], s2 + 4);\n+  snprintf (r + 2, l1, s3 + 3);\n+  r = buf3;\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[1];\n+      else if (i == l1)\n+\tr = &a.buf2[7];\n+      else if (i == l1 + 1)\n+\tr = &buf3[5];\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[9];\n+    }\n+  snprintf (r, l1, s2 + 4);\n+  if (chk_calls != 5)\n+    abort ();\n+\n+  /* Following have known destination and known source length,\n+     so if optimizing certainly shouldn't result in the checking\n+     variants.  */\n+  chk_calls = 0;\n+  /* snprintf_disallowed = 1; */\n+  snprintf (a.buf1 + 2, 4, \"\");\n+  snprintf (r, 1, \"a\");\n+  r = l1 == 1 ? __builtin_alloca (4) : &a.buf2[7];\n+  snprintf (r, 3, \"%s\", s1 + 1);\n+  r = buf3;\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[1];\n+      else if (i == l1)\n+\tr = &a.buf2[7];\n+      else if (i == l1 + 1)\n+\tr = &buf3[5];\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[9];\n+    }\n+  snprintf (r, 1, \"%s\", \"\");\n+  snprintf (r, 0, \"%s\", \"\");\n+  snprintf_disallowed = 0;\n+  /* Unknown destination and source, no checking.  */\n+  snprintf (s4, l1 + 31, \"%s %d\", s3, 0);\n+  if (chk_calls)\n+    abort ();\n+}\n+\n+/* Test whether runtime and/or compile time checking catches\n+   buffer overflows.  */\n+void\n+__attribute__((noinline))\n+test3 (void)\n+{\n+  struct A { char buf1[10]; char buf2[10]; } a;\n+  char buf3[20];\n+\n+  chk_fail_allowed = 1;\n+  /* Runtime checks.  */\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      snprintf (&a.buf2[9], l1 + 1, \"%c%s\", s2[3], s2 + 4);\n+      abort ();\n+    }\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      snprintf (&a.buf2[7], l1 + 30, \"%s%c\", s3 + strlen (s3) - 2, *s3);\n+      abort ();\n+    }\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      snprintf (&a.buf2[7], l1 + 3, \"%d\", (int) l1 + 9999);\n+      abort ();\n+    }\n+  /* This should be detectable at compile time already.  */\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      snprintf (&buf3[19], 2, \"a\");\n+      abort ();\n+    }\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      snprintf (&buf3[17], 4, \"a\");\n+      abort ();\n+    }\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      snprintf (&buf3[17], 4, \"%s\", \"abc\");\n+      abort ();\n+    }\n+  chk_fail_allowed = 0;\n+}\n+\n+void\n+main_test (void)\n+{\n+#ifndef __OPTIMIZE__\n+  /* Object size checking is only intended for -O[s123].  */\n+  return;\n+#endif\n+  __asm (\"\" : \"=r\" (s2) : \"0\" (s2));\n+  __asm (\"\" : \"=r\" (s3) : \"0\" (s3));\n+  __asm (\"\" : \"=r\" (l1) : \"0\" (l1));\n+  s4 = p;\n+  test1 ();\n+  test2 ();\n+  test3 ();\n+}"}, {"sha": "9daf13e827b5f757f79552f56c57ed55258d8eb3", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/sprintf-chk-lib.c", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fsprintf-chk-lib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fsprintf-chk-lib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fsprintf-chk-lib.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1 @@\n+#include \"lib/chk.c\""}, {"sha": "95d2a9d2826b50e3313bcd05d47ba7d320f4926f", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/sprintf-chk.c", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fsprintf-chk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fsprintf-chk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fsprintf-chk.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,197 @@\n+/* Copyright (C) 2004, 2005  Free Software Foundation.\n+\n+   Ensure builtin __sprintf_chk performs correctly.  */\n+\n+extern void abort (void);\n+typedef __SIZE_TYPE__ size_t;\n+extern size_t strlen(const char *);\n+extern void *memcpy (void *, const void *, size_t);\n+extern char *strcpy (char *, const char *);\n+extern int memcmp (const void *, const void *, size_t);\n+extern void *memset (void *, int, size_t);\n+extern int sprintf (char *, const char *, ...);\n+\n+#include \"chk.h\"\n+\n+const char s1[] = \"123\";\n+char p[32] = \"\";\n+char *s2 = \"defg\";\n+char *s3 = \"FGH\";\n+char *s4;\n+size_t l1 = 1;\n+static char buffer[32];\n+char *ptr = \"barf\";\n+\n+void\n+__attribute__((noinline))\n+test1 (void)\n+{\n+  chk_calls = 0;\n+  sprintf_disallowed = 1;\n+\n+  memset (buffer, 'A', 32);\n+  sprintf (buffer, \"foo\");\n+  if (memcmp (buffer, \"foo\", 4) || buffer[4] != 'A')\n+    abort ();\n+\n+  memset (buffer, 'A', 32);\n+  if (sprintf (buffer, \"foo\") != 3)\n+    abort ();\n+  if (memcmp (buffer, \"foo\", 4) || buffer[4] != 'A')\n+    abort ();\n+\n+  memset (buffer, 'A', 32);\n+  sprintf (buffer, \"%s\", \"bar\");\n+  if (memcmp (buffer, \"bar\", 4) || buffer[4] != 'A')\n+    abort ();\n+\n+  memset (buffer, 'A', 32);\n+  if (sprintf (buffer, \"%s\", \"bar\") != 3)\n+    abort ();\n+  if (memcmp (buffer, \"bar\", 4) || buffer[4] != 'A')\n+    abort ();\n+\n+  if (chk_calls)\n+    abort ();\n+  sprintf_disallowed = 0;\n+\n+  memset (buffer, 'A', 32);\n+  sprintf (buffer, \"%s\", ptr);\n+  if (memcmp (buffer, \"barf\", 5) || buffer[5] != 'A')\n+    abort ();\n+\n+  memset (buffer, 'A', 32);\n+  sprintf (buffer, \"%d - %c\", (int) l1 + 27, *ptr);\n+  if (memcmp (buffer, \"28 - b\\0AAAAA\", 12))\n+    abort ();\n+\n+  if (chk_calls != 2)\n+    abort ();\n+  chk_calls = 0;\n+\n+  sprintf (s4, \"%d - %c\", (int) l1 - 17, ptr[1]);\n+  if (memcmp (s4, \"-16 - a\", 8))\n+    abort ();\n+  if (chk_calls)\n+    abort ();\n+}\n+\n+/* Test whether compile time checking is done where it should\n+   and so is runtime object size checking.  */\n+void\n+__attribute__((noinline))\n+test2 (void)\n+{\n+  struct A { char buf1[10]; char buf2[10]; } a;\n+  char *r = l1 == 1 ? &a.buf1[5] : &a.buf2[4];\n+  char buf3[20];\n+  int i;\n+\n+  /* The following calls should do runtime checking\n+     - source length is not known, but destination is.  */\n+  chk_calls = 0;\n+  sprintf (a.buf1 + 2, \"%s\", s3 + 3);\n+  sprintf (r, \"%s%c\", s3 + 3, s3[3]);\n+  r = l1 == 1 ? __builtin_alloca (4) : &a.buf2[7];\n+  sprintf (r, \"%c %s\", s2[2], s2 + 4);\n+  sprintf (r + 2, s3 + 3);\n+  r = buf3;\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[1];\n+      else if (i == l1)\n+\tr = &a.buf2[7];\n+      else if (i == l1 + 1)\n+\tr = &buf3[5];\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[9];\n+    }\n+  sprintf (r, s2 + 4);\n+  if (chk_calls != 5)\n+    abort ();\n+\n+  /* Following have known destination and known source length,\n+     so if optimizing certainly shouldn't result in the checking\n+     variants.  */\n+  chk_calls = 0;\n+  sprintf_disallowed = 1;\n+  sprintf (a.buf1 + 2, \"\");\n+  sprintf (r, \"a\");\n+  r = l1 == 1 ? __builtin_alloca (4) : &a.buf2[7];\n+  sprintf (r, \"%s\", s1 + 1);\n+  r = buf3;\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[1];\n+      else if (i == l1)\n+\tr = &a.buf2[7];\n+      else if (i == l1 + 1)\n+\tr = &buf3[5];\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[9];\n+    }\n+  sprintf (r, \"%s\", \"\");\n+  sprintf_disallowed = 0;\n+  /* Unknown destination and source, no checking.  */\n+  sprintf (s4, \"%s %d\", s3, 0);\n+  if (chk_calls)\n+    abort ();\n+}\n+\n+/* Test whether runtime and/or compile time checking catches\n+   buffer overflows.  */\n+void\n+__attribute__((noinline))\n+test3 (void)\n+{\n+  struct A { char buf1[10]; char buf2[10]; } a;\n+  char buf3[20];\n+\n+  chk_fail_allowed = 1;\n+  /* Runtime checks.  */\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      sprintf (&a.buf2[9], \"%c%s\", s2[3], s2 + 4);\n+      abort ();\n+    }\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      sprintf (&a.buf2[7], \"%s%c\", s3 + strlen (s3) - 2, *s3);\n+      abort ();\n+    }\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      sprintf (&a.buf2[7], \"%d\", (int) l1 + 9999);\n+      abort ();\n+    }\n+  /* This should be detectable at compile time already.  */\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      sprintf (&buf3[19], \"a\");\n+      abort ();\n+    }\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      sprintf (&buf3[17], \"%s\", \"abc\");\n+      abort ();\n+    }\n+  chk_fail_allowed = 0;\n+}\n+\n+void\n+main_test (void)\n+{\n+#ifndef __OPTIMIZE__\n+  /* Object size checking is only intended for -O[s123].  */\n+  return;\n+#endif\n+  __asm (\"\" : \"=r\" (s2) : \"0\" (s2));\n+  __asm (\"\" : \"=r\" (s3) : \"0\" (s3));\n+  __asm (\"\" : \"=r\" (l1) : \"0\" (l1));\n+  s4 = p;\n+  test1 ();\n+  test2 ();\n+  test3 ();\n+}"}, {"sha": "9daf13e827b5f757f79552f56c57ed55258d8eb3", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/stpcpy-chk-lib.c", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstpcpy-chk-lib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstpcpy-chk-lib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstpcpy-chk-lib.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1 @@\n+#include \"lib/chk.c\""}, {"sha": "b292c0aec8733abc39f4191f7d6637509d44aec9", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/stpcpy-chk.c", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstpcpy-chk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstpcpy-chk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstpcpy-chk.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,265 @@\n+/* Copyright (C) 2004, 2005  Free Software Foundation.\n+\n+   Ensure builtin __stpcpy_chk performs correctly.  */\n+\n+extern void abort (void);\n+typedef __SIZE_TYPE__ size_t;\n+extern size_t strlen(const char *);\n+extern void *memcpy (void *, const void *, size_t);\n+extern char *stpcpy (char *, const char *);\n+extern int memcmp (const void *, const void *, size_t);\n+\n+#include \"chk.h\"\n+\n+const char s1[] = \"123\";\n+char p[32] = \"\";\n+char *s2 = \"defg\";\n+char *s3 = \"FGH\";\n+char *s4;\n+size_t l1 = 1;\n+\n+void\n+__attribute__((noinline))\n+test1 (void)\n+{\n+  int i = 8;\n+\n+#if defined __i386__ || defined __x86_64__\n+  /* The functions below might not be optimized into direct stores on all\n+     arches.  It depends on how many instructions would be generated and\n+     what limits the architecture chooses in STORE_BY_PIECES_P.  */\n+  stpcpy_disallowed = 1;\n+#endif\n+  if (stpcpy (p, \"abcde\") != p + 5 || memcmp (p, \"abcde\", 6))\n+    abort ();\n+  if (stpcpy (p + 16, \"vwxyz\" + 1) != p + 16 + 4 || memcmp (p + 16, \"wxyz\", 5))\n+    abort ();\n+  if (stpcpy (p + 1, \"\") != p + 1 + 0 || memcmp (p, \"a\\0cde\", 6))\n+    abort ();\n+  if (stpcpy (p + 3, \"fghij\") != p + 3 + 5 || memcmp (p, \"a\\0cfghij\", 9))\n+    abort ();\n+\n+  if (stpcpy ((i++, p + 20 + 1), \"23\") != (p + 20 + 1 + 2)\n+      || i != 9 || memcmp (p + 19, \"z\\0\"\"23\\0\", 5))\n+    abort ();\n+\n+  if (stpcpy (stpcpy (p, \"ABCD\"), \"EFG\") != p + 7 || memcmp (p, \"ABCDEFG\", 8))\n+    abort();\n+\n+  /* Test at least one instance of the __builtin_ style.  We do this\n+     to ensure that it works and that the prototype is correct.  */\n+  if (__builtin_stpcpy (p, \"abcde\") != p + 5 || memcmp (p, \"abcde\", 6))\n+    abort ();\n+\n+  /* If return value of stpcpy is ignored, it should be optimized into\n+     strcpy call.  */\n+  stpcpy_disallowed = 1;\n+  stpcpy (p + 1, \"abcd\");\n+  stpcpy_disallowed = 0;\n+  if (memcmp (p, \"aabcd\", 6))\n+    abort ();\n+\n+  if (chk_calls)\n+    abort ();\n+\n+  chk_calls = 0;\n+  strcpy_disallowed = 1;\n+  if (stpcpy (p, s2) != p + 4 || memcmp (p, \"defg\\0\", 6))\n+    abort ();\n+  strcpy_disallowed = 0;\n+  stpcpy_disallowed = 1;\n+  stpcpy (p + 2, s3);\n+  stpcpy_disallowed = 0;\n+  if (memcmp (p, \"deFGH\", 6))\n+    abort ();\n+  if (chk_calls != 2)\n+    abort ();\n+}\n+\n+#ifndef MAX_OFFSET\n+#define MAX_OFFSET (sizeof (long long))\n+#endif\n+\n+#ifndef MAX_COPY\n+#define MAX_COPY (10 * sizeof (long long))\n+#endif\n+\n+#ifndef MAX_EXTRA\n+#define MAX_EXTRA (sizeof (long long))\n+#endif\n+\n+#define MAX_LENGTH (MAX_OFFSET + MAX_COPY + 1 + MAX_EXTRA)\n+\n+/* Use a sequence length that is not divisible by two, to make it more\n+   likely to detect when words are mixed up.  */\n+#define SEQUENCE_LENGTH 31\n+\n+static union {\n+  char buf[MAX_LENGTH];\n+  long long align_int;\n+  long double align_fp;\n+} u1, u2;\n+\n+volatile char *vx;\n+\n+void\n+__attribute__((noinline))\n+test2 (void)\n+{\n+  int off1, off2, len, i;\n+  char *p, *q, c;\n+\n+  for (off1 = 0; off1 < MAX_OFFSET; off1++)\n+    for (off2 = 0; off2 < MAX_OFFSET; off2++)\n+      for (len = 1; len < MAX_COPY; len++)\n+\t{\n+\t  for (i = 0, c = 'A'; i < MAX_LENGTH; i++, c++)\n+\t    {\n+\t      u1.buf[i] = 'a';\n+\t      if (c >= 'A' + SEQUENCE_LENGTH)\n+\t\tc = 'A';\n+\t      u2.buf[i] = c;\n+\t    }\n+\t  u2.buf[off2 + len] = '\\0';\n+\n+\t  p = stpcpy (u1.buf + off1, u2.buf + off2);\n+\t  if (p != u1.buf + off1 + len)\n+\t    abort ();\n+\n+\t  q = u1.buf;\n+\t  for (i = 0; i < off1; i++, q++)\n+\t    if (*q != 'a')\n+\t      abort ();\n+\n+\t  for (i = 0, c = 'A' + off2; i < len; i++, q++, c++)\n+\t    {\n+\t      if (c >= 'A' + SEQUENCE_LENGTH)\n+\t\tc = 'A';\n+\t      if (*q != c)\n+\t\tabort ();\n+\t    }\n+\n+\t  if (*q++ != '\\0')\n+\t    abort ();\n+\t  for (i = 0; i < MAX_EXTRA; i++, q++)\n+\t    if (*q != 'a')\n+\t      abort ();\n+\t}\n+}\n+\n+/* Test whether compile time checking is done where it should\n+   and so is runtime object size checking.  */\n+void\n+__attribute__((noinline))\n+test3 (void)\n+{\n+  struct A { char buf1[10]; char buf2[10]; } a;\n+  char *r = l1 == 1 ? &a.buf1[5] : &a.buf2[4];\n+  char buf3[20];\n+  int i;\n+  const char *l;\n+\n+  /* The following calls should do runtime checking\n+     - source length is not known, but destination is.  */\n+  chk_calls = 0;\n+  vx = stpcpy (a.buf1 + 2, s3 + 3);\n+  vx = stpcpy (r, s3 + 2);\n+  r = l1 == 1 ? __builtin_alloca (4) : &a.buf2[7];\n+  vx = stpcpy (r, s2 + 2);\n+  vx = stpcpy (r + 2, s3 + 3);\n+  r = buf3;\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[1];\n+      else if (i == l1)\n+\tr = &a.buf2[7];\n+      else if (i == l1 + 1)\n+\tr = &buf3[5];\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[9];\n+    }\n+  vx = stpcpy (r, s2 + 4);\n+  if (chk_calls != 5)\n+    abort ();\n+\n+  /* Following have known destination and known source length,\n+     so if optimizing certainly shouldn't result in the checking\n+     variants.  */\n+  chk_calls = 0;\n+  vx = stpcpy (a.buf1 + 2, \"\");\n+  vx = stpcpy (r, \"a\");\n+  r = l1 == 1 ? __builtin_alloca (4) : &a.buf2[7];\n+  vx = stpcpy (r, s1 + 1);\n+  r = buf3;\n+  l = \"abc\";\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[1], l = \"e\";\n+      else if (i == l1)\n+\tr = &a.buf2[7], l = \"gh\";\n+      else if (i == l1 + 1)\n+\tr = &buf3[5], l = \"jkl\";\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[9], l = \"\";\n+    }\n+  vx = stpcpy (r, \"\");\n+  /* Here, strlen (l) + 1 is known to be at most 4 and\n+     __builtin_object_size (&buf3[16], 0) is 4, so this doesn't need\n+     runtime checking.  */\n+  vx = stpcpy (&buf3[16], l);\n+  /* Unknown destination and source, no checking.  */\n+  vx = stpcpy (s4, s3);\n+  stpcpy (s4 + 4, s3);\n+  if (chk_calls)\n+    abort ();\n+  chk_calls = 0;\n+}\n+\n+/* Test whether runtime and/or compile time checking catches\n+   buffer overflows.  */\n+void\n+__attribute__((noinline))\n+test4 (void)\n+{\n+  struct A { char buf1[10]; char buf2[10]; } a;\n+  char buf3[20];\n+\n+  chk_fail_allowed = 1;\n+  /* Runtime checks.  */\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      vx = stpcpy (&a.buf2[9], s2 + 3);\n+      abort ();\n+    }\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      vx = stpcpy (&a.buf2[7], s3 + strlen (s3) - 3);\n+      abort ();\n+    }\n+  /* This should be detectable at compile time already.  */\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      vx = stpcpy (&buf3[19], \"a\");\n+      abort ();\n+    }\n+  chk_fail_allowed = 0;\n+}\n+\n+void\n+main_test (void)\n+{\n+#ifndef __OPTIMIZE__\n+  /* Object size checking is only intended for -O[s123].  */\n+  return;\n+#endif\n+  __asm (\"\" : \"=r\" (s2) : \"0\" (s2));\n+  __asm (\"\" : \"=r\" (s3) : \"0\" (s3));\n+  __asm (\"\" : \"=r\" (l1) : \"0\" (l1));\n+  test1 ();\n+  s4 = p;\n+  test2 ();\n+  test3 ();\n+  test4 ();\n+}"}, {"sha": "9daf13e827b5f757f79552f56c57ed55258d8eb3", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/strcat-chk-lib.c", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrcat-chk-lib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrcat-chk-lib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrcat-chk-lib.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1 @@\n+#include \"lib/chk.c\""}, {"sha": "fea3184e8f53cb37c58adb72f353d5c40fdc5482", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/strcat-chk.c", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrcat-chk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrcat-chk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrcat-chk.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,204 @@\n+/* Copyright (C) 2004, 2005  Free Software Foundation.\n+\n+   Ensure builtin __strcat_chk performs correctly.  */\n+\n+extern void abort (void);\n+typedef __SIZE_TYPE__ size_t;\n+extern size_t strlen(const char *);\n+extern void *memcpy (void *, const void *, size_t);\n+extern char *strcat (char *, const char *);\n+extern int memcmp (const void *, const void *, size_t);\n+extern char *strcpy (char *, const char *);\n+extern int strcmp (const char *, const char *);\n+extern void *memset (void *, int, size_t);\n+#define RESET_DST_WITH(FILLER) \\\n+  do { memset (dst, 'X', sizeof (dst)); strcpy (dst, (FILLER)); } while (0)\n+\n+#include \"chk.h\"\n+\n+const char s1[] = \"123\";\n+char p[32] = \"\";\n+char *s2 = \"defg\";\n+char *s3 = \"FGH\";\n+char *s4;\n+size_t l1 = 1;\n+char *s5;\n+\n+void\n+__attribute__((noinline))\n+test1 (void)\n+{\n+  const char *const x1 = \"hello world\";\n+  const char *const x2 = \"\";\n+  char dst[64], *d2;\n+\n+  chk_calls = 0;\n+  strcat_disallowed = 1;\n+  /* Following strcat calls should be optimized out at compile time.  */  \n+  RESET_DST_WITH (x1);\n+  if (strcat (dst, \"\") != dst || strcmp (dst, x1))\n+    abort ();\n+  RESET_DST_WITH (x1);\n+  if (strcat (dst, x2) != dst || strcmp (dst, x1))\n+    abort ();\n+  RESET_DST_WITH (x1); d2 = dst;\n+  if (strcat (++d2, x2) != dst+1 || d2 != dst+1 || strcmp (dst, x1))\n+    abort ();\n+  RESET_DST_WITH (x1); d2 = dst;\n+  if (strcat (++d2+5, x2) != dst+6 || d2 != dst+1 || strcmp (dst, x1))\n+    abort ();\n+  RESET_DST_WITH (x1); d2 = dst;\n+  if (strcat (++d2+5, x1+11) != dst+6 || d2 != dst+1 || strcmp (dst, x1))\n+    abort ();\n+  if (chk_calls)\n+    abort ();\n+  strcat_disallowed = 0;\n+\n+  RESET_DST_WITH (x1);\n+  if (strcat (dst, \" 1111\") != dst\n+      || memcmp (dst, \"hello world 1111\\0XXX\", 20))\n+    abort ();\n+  \n+  RESET_DST_WITH (x1);\n+  if (strcat (dst+5, \" 2222\") != dst+5\n+      || memcmp (dst, \"hello world 2222\\0XXX\", 20))\n+    abort ();\n+  \n+  RESET_DST_WITH (x1); d2 = dst;\n+  if (strcat (++d2+5, \" 3333\") != dst+6 || d2 != dst+1\n+      || memcmp (dst, \"hello world 3333\\0XXX\", 20))\n+    abort ();\n+  \n+  RESET_DST_WITH (x1);\n+  strcat (strcat (strcat (strcat (strcat (strcat (dst, \": this \"), \"\"),\n+\t\t\t\t  \"is \"), \"a \"), \"test\"), \".\");\n+  if (memcmp (dst, \"hello world: this is a test.\\0X\", 30))\n+    abort ();\n+\n+  chk_calls = 0;\n+  strcat_disallowed = 1;\n+  /* Test at least one instance of the __builtin_ style.  We do this\n+     to ensure that it works and that the prototype is correct.  */\n+  RESET_DST_WITH (x1);\n+  if (__builtin_strcat (dst, \"\") != dst || strcmp (dst, x1))\n+    abort ();\n+  if (chk_calls)\n+    abort ();\n+  strcat_disallowed = 0;\n+}\n+\n+\n+/* Test whether compile time checking is done where it should\n+   and so is runtime object size checking.  */\n+void\n+__attribute__((noinline))\n+test2 (void)\n+{\n+  struct A { char buf1[10]; char buf2[10]; } a;\n+  char *r = l1 == 1 ? &a.buf1[5] : &a.buf2[4];\n+  char buf3[20];\n+  int i;\n+\n+  /* The following calls should do runtime checking\n+     - source length is not known, but destination is.  */\n+  memset (&a, '\\0', sizeof (a));\n+  s5 = (char *) &a;\n+  __asm __volatile (\"\" : : \"r\" (s5) : \"memory\");\n+  chk_calls = 0;\n+  strcat (a.buf1 + 2, s3 + 3);\n+  strcat (r, s3 + 2);\n+  r = l1 == 1 ? __builtin_alloca (4) : &a.buf2[7];\n+  memset (r, '\\0', 3);\n+  __asm __volatile (\"\" : : \"r\" (r) : \"memory\");\n+  strcat (r, s2 + 2);\n+  strcat (r + 2, s3 + 3);\n+  r = buf3;\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[1];\n+      else if (i == l1)\n+\tr = &a.buf2[7];\n+      else if (i == l1 + 1)\n+\tr = &buf3[5];\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[9];\n+    }\n+  strcat (r, s2 + 4);\n+  if (chk_calls != 5)\n+    abort ();\n+\n+  /* Following have known destination and known source length,\n+     but we don't know the length of dest string, so runtime checking\n+     is needed too.  */\n+  memset (&a, '\\0', sizeof (a));\n+  chk_calls = 0;\n+  s5 = (char *) &a;\n+  __asm __volatile (\"\" : : \"r\" (s5) : \"memory\");\n+  strcat (a.buf1 + 2, \"a\");\n+  strcat (r, \"\");\n+  r = l1 == 1 ? __builtin_alloca (4) : &a.buf2[7];\n+  memset (r, '\\0', 3);\n+  __asm __volatile (\"\" : : \"r\" (r) : \"memory\");\n+  strcat (r, s1 + 1);\n+  if (chk_calls != 2)\n+    abort ();\n+  chk_calls = 0;\n+  /* Unknown destination and source, no checking.  */\n+  strcat (s4, s3);\n+  if (chk_calls)\n+    abort ();\n+  chk_calls = 0;\n+}\n+\n+/* Test whether runtime and/or compile time checking catches\n+   buffer overflows.  */\n+void\n+__attribute__((noinline))\n+test3 (void)\n+{\n+  struct A { char buf1[10]; char buf2[10]; } a;\n+  char buf3[20];\n+\n+  memset (&a, '\\0', sizeof (a));\n+  memset (buf3, '\\0', sizeof (buf3));\n+  s5 = (char *) &a;\n+  __asm __volatile (\"\" : : \"r\" (s5) : \"memory\");\n+  s5 = buf3;\n+  __asm __volatile (\"\" : : \"r\" (s5) : \"memory\");\n+  chk_fail_allowed = 1;\n+  /* Runtime checks.  */\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      strcat (&a.buf2[9], s2 + 3);\n+      abort ();\n+    }\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      strcat (&a.buf2[7], s3 + strlen (s3) - 3);\n+      abort ();\n+    }\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      strcat (&buf3[19], \"a\");\n+      abort ();\n+    }\n+  chk_fail_allowed = 0;\n+}\n+\n+void\n+main_test (void)\n+{\n+#ifndef __OPTIMIZE__\n+  /* Object size checking is only intended for -O[s123].  */\n+  return;\n+#endif\n+  __asm (\"\" : \"=r\" (s2) : \"0\" (s2));\n+  __asm (\"\" : \"=r\" (s3) : \"0\" (s3));\n+  __asm (\"\" : \"=r\" (l1) : \"0\" (l1));\n+  s4 = p;\n+  test1 ();\n+  memset (p, '\\0', sizeof (p));\n+  test2 ();\n+  test3 ();\n+}"}, {"sha": "9daf13e827b5f757f79552f56c57ed55258d8eb3", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/strcpy-chk-lib.c", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrcpy-chk-lib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrcpy-chk-lib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrcpy-chk-lib.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1 @@\n+#include \"lib/chk.c\""}, {"sha": "002dd19500ed28c52a709f0df9e04cb0f9617344", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/strcpy-chk.c", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrcpy-chk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrcpy-chk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrcpy-chk.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,234 @@\n+/* Copyright (C) 2004, 2005  Free Software Foundation.\n+\n+   Ensure builtin __strcpy_chk performs correctly.  */\n+\n+extern void abort (void);\n+typedef __SIZE_TYPE__ size_t;\n+extern size_t strlen(const char *);\n+extern void *memcpy (void *, const void *, size_t);\n+extern char *strcpy (char *, const char *);\n+extern int memcmp (const void *, const void *, size_t);\n+\n+#include \"chk.h\"\n+\n+const char s1[] = \"123\";\n+char p[32] = \"\";\n+char *s2 = \"defg\";\n+char *s3 = \"FGH\";\n+char *s4;\n+size_t l1 = 1;\n+\n+void\n+__attribute__((noinline))\n+test1 (void)\n+{\n+  chk_calls = 0;\n+#ifndef __OPTIMIZE_SIZE__\n+  strcpy_disallowed = 1;\n+#else\n+  strcpy_disallowed = 0;\n+#endif\n+\n+  if (strcpy (p, \"abcde\") != p || memcmp (p, \"abcde\", 6))\n+    abort ();\n+  if (strcpy (p + 16, \"vwxyz\" + 1) != p + 16 || memcmp (p + 16, \"wxyz\", 5))\n+    abort ();\n+  if (strcpy (p + 1, \"\") != p + 1 || memcmp (p, \"a\\0cde\", 6))\n+    abort ();  \n+  if (strcpy (p + 3, \"fghij\") != p + 3 || memcmp (p, \"a\\0cfghij\", 9))\n+    abort ();\n+\n+  /* Test at least one instance of the __builtin_ style.  We do this\n+     to ensure that it works and that the prototype is correct.  */\n+  if (__builtin_strcpy (p, \"abcde\") != p || memcmp (p, \"abcde\", 6))\n+    abort ();\n+\n+  strcpy_disallowed = 0;\n+  if (chk_calls)\n+    abort ();\n+}\n+\n+#ifndef MAX_OFFSET\n+#define MAX_OFFSET (sizeof (long long))\n+#endif\n+\n+#ifndef MAX_COPY\n+#define MAX_COPY (10 * sizeof (long long))\n+#endif\n+\n+#ifndef MAX_EXTRA\n+#define MAX_EXTRA (sizeof (long long))\n+#endif\n+\n+#define MAX_LENGTH (MAX_OFFSET + MAX_COPY + 1 + MAX_EXTRA)\n+\n+/* Use a sequence length that is not divisible by two, to make it more\n+   likely to detect when words are mixed up.  */\n+#define SEQUENCE_LENGTH 31\n+\n+static union {\n+  char buf[MAX_LENGTH];\n+  long long align_int;\n+  long double align_fp;\n+} u1, u2;\n+\n+void\n+__attribute__((noinline))\n+test2 (void)\n+{\n+  int off1, off2, len, i;\n+  char *p, *q, c;\n+\n+  for (off1 = 0; off1 < MAX_OFFSET; off1++)\n+    for (off2 = 0; off2 < MAX_OFFSET; off2++)\n+      for (len = 1; len < MAX_COPY; len++)\n+\t{\n+\t  for (i = 0, c = 'A'; i < MAX_LENGTH; i++, c++)\n+\t    {\n+\t      u1.buf[i] = 'a';\n+\t      if (c >= 'A' + SEQUENCE_LENGTH)\n+\t\tc = 'A';\n+\t      u2.buf[i] = c;\n+\t    }\n+\t  u2.buf[off2 + len] = '\\0';\n+\n+\t  p = strcpy (u1.buf + off1, u2.buf + off2);\n+\t  if (p != u1.buf + off1)\n+\t    abort ();\n+\n+\t  q = u1.buf;\n+\t  for (i = 0; i < off1; i++, q++)\n+\t    if (*q != 'a')\n+\t      abort ();\n+\n+\t  for (i = 0, c = 'A' + off2; i < len; i++, q++, c++)\n+\t    {\n+\t      if (c >= 'A' + SEQUENCE_LENGTH)\n+\t\tc = 'A';\n+\t      if (*q != c)\n+\t\tabort ();\n+\t    }\n+\n+\t  if (*q++ != '\\0')\n+\t    abort ();\n+\t  for (i = 0; i < MAX_EXTRA; i++, q++)\n+\t    if (*q != 'a')\n+\t      abort ();\n+\t}\n+}\n+\n+/* Test whether compile time checking is done where it should\n+   and so is runtime object size checking.  */\n+void\n+__attribute__((noinline))\n+test3 (void)\n+{\n+  struct A { char buf1[10]; char buf2[10]; } a;\n+  char *r = l1 == 1 ? &a.buf1[5] : &a.buf2[4];\n+  char buf3[20];\n+  int i;\n+  const char *l;\n+\n+  /* The following calls should do runtime checking\n+     - source length is not known, but destination is.  */\n+  chk_calls = 0;\n+  strcpy (a.buf1 + 2, s3 + 3);\n+  strcpy (r, s3 + 2);\n+  r = l1 == 1 ? __builtin_alloca (4) : &a.buf2[7];\n+  strcpy (r, s2 + 2);\n+  strcpy (r + 2, s3 + 3);\n+  r = buf3;\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[1];\n+      else if (i == l1)\n+\tr = &a.buf2[7];\n+      else if (i == l1 + 1)\n+\tr = &buf3[5];\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[9];\n+    }\n+  strcpy (r, s2 + 4);\n+  if (chk_calls != 5)\n+    abort ();\n+\n+  /* Following have known destination and known source length,\n+     so if optimizing certainly shouldn't result in the checking\n+     variants.  */\n+  chk_calls = 0;\n+  strcpy (a.buf1 + 2, \"\");\n+  strcpy (r, \"a\");\n+  r = l1 == 1 ? __builtin_alloca (4) : &a.buf2[7];\n+  strcpy (r, s1 + 1);\n+  r = buf3;\n+  l = \"abc\";\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[1], l = \"e\";\n+      else if (i == l1)\n+\tr = &a.buf2[7], l = \"gh\";\n+      else if (i == l1 + 1)\n+\tr = &buf3[5], l = \"jkl\";\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[9], l = \"\";\n+    }\n+  strcpy (r, \"\");\n+  /* Here, strlen (l) + 1 is known to be at most 4 and\n+     __builtin_object_size (&buf3[16], 0) is 4, so this doesn't need\n+     runtime checking.  */\n+  strcpy (&buf3[16], l);\n+  /* Unknown destination and source, no checking.  */\n+  strcpy (s4, s3);\n+  if (chk_calls)\n+    abort ();\n+  chk_calls = 0;\n+}\n+\n+/* Test whether runtime and/or compile time checking catches\n+   buffer overflows.  */\n+void\n+__attribute__((noinline))\n+test4 (void)\n+{\n+  struct A { char buf1[10]; char buf2[10]; } a;\n+  char buf3[20];\n+\n+  chk_fail_allowed = 1;\n+  /* Runtime checks.  */\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      strcpy (&a.buf2[9], s2 + 3);\n+      abort ();\n+    }\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      strcpy (&a.buf2[7], s3 + strlen (s3) - 3);\n+      abort ();\n+    }\n+  /* This should be detectable at compile time already.  */\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      strcpy (&buf3[19], \"a\");\n+      abort ();\n+    }\n+  chk_fail_allowed = 0;\n+}\n+\n+void\n+main_test (void)\n+{\n+#ifndef __OPTIMIZE__\n+  /* Object size checking is only intended for -O[s123].  */\n+  return;\n+#endif\n+  __asm (\"\" : \"=r\" (s2) : \"0\" (s2));\n+  __asm (\"\" : \"=r\" (s3) : \"0\" (s3));\n+  __asm (\"\" : \"=r\" (l1) : \"0\" (l1));\n+  test1 ();\n+  test2 ();\n+  s4 = p;\n+  test3 ();\n+  test4 ();\n+}"}, {"sha": "9daf13e827b5f757f79552f56c57ed55258d8eb3", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/strncat-chk-lib.c", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrncat-chk-lib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrncat-chk-lib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrncat-chk-lib.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1 @@\n+#include \"lib/chk.c\""}, {"sha": "8904df14aee5c9540af9df944bca3a5d9e9f603b", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/strncat-chk.c", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrncat-chk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrncat-chk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrncat-chk.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,229 @@\n+/* Copyright (C) 2004, 2005  Free Software Foundation.\n+\n+   Ensure builtin __strncat_chk performs correctly.  */\n+\n+extern void abort (void);\n+typedef __SIZE_TYPE__ size_t;\n+extern size_t strlen (const char *);\n+extern void *memcpy (void *, const void *, size_t);\n+extern char *strcat (char *, const char *);\n+extern char *strncat (char *, const char *, size_t);\n+extern int memcmp (const void *, const void *, size_t);\n+extern char *strcpy (char *, const char *);\n+extern int strcmp (const char *, const char *);\n+extern void *memset (void *, int, size_t);\n+\n+#include \"chk.h\"\n+\n+const char s1[] = \"123\";\n+char p[32] = \"\";\n+char *s2 = \"defg\";\n+char *s3 = \"FGH\";\n+char *s4;\n+size_t l1 = 1;\n+char *s5;\n+int x = 123;\n+\n+void\n+__attribute__((noinline))\n+test1 (void)\n+{\n+  const char *const s1 = \"hello world\";\n+  const char *const s2 = \"\";\n+  const char *s3;\n+  char dst[64], *d2;\n+\n+  /* Following strncat calls should be all optimized out.  */\n+  chk_calls = 0;\n+  strncat_disallowed = 1;\n+  strcat_disallowed = 1;\n+  strcpy (dst, s1);\n+  if (strncat (dst, \"\", 100) != dst || strcmp (dst, s1))\n+    abort ();\n+  strcpy (dst, s1);\n+  if (strncat (dst, s2, 100) != dst || strcmp (dst, s1))\n+    abort ();\n+  strcpy (dst, s1); d2 = dst;\n+  if (strncat (++d2, s2, 100) != dst+1 || d2 != dst+1 || strcmp (dst, s1))\n+    abort ();\n+  strcpy (dst, s1); d2 = dst;\n+  if (strncat (++d2+5, s2, 100) != dst+6 || d2 != dst+1 || strcmp (dst, s1))\n+    abort ();\n+  strcpy (dst, s1); d2 = dst;\n+  if (strncat (++d2+5, s1+11, 100) != dst+6 || d2 != dst+1 || strcmp (dst, s1))\n+    abort ();\n+  strcpy (dst, s1); d2 = dst;\n+  if (strncat (++d2+5, s1, 0) != dst+6 || d2 != dst+1 || strcmp (dst, s1))\n+    abort ();\n+  strcpy (dst, s1); d2 = dst; s3 = s1;\n+  if (strncat (++d2+5, ++s3, 0) != dst+6 || d2 != dst+1 || strcmp (dst, s1)\n+      || s3 != s1 + 1)\n+    abort ();\n+  strcpy (dst, s1); d2 = dst;\n+  if (strncat (++d2+5, \"\", ++x) != dst+6 || d2 != dst+1 || x != 124\n+      || strcmp (dst, s1))\n+    abort ();\n+  if (chk_calls)\n+    abort ();\n+  strcat_disallowed = 0;\n+\n+  /* These __strncat_chk calls should be optimized into __strcat_chk,\n+     as strlen (src) <= len.  */\n+  strcpy (dst, s1);\n+  if (strncat (dst, \"foo\", 3) != dst || strcmp (dst, \"hello worldfoo\"))\n+    abort ();\n+  strcpy (dst, s1);\n+  if (strncat (dst, \"foo\", 100) != dst || strcmp (dst, \"hello worldfoo\"))\n+    abort ();\n+  strcpy (dst, s1);\n+  if (strncat (dst, s1, 100) != dst || strcmp (dst, \"hello worldhello world\"))\n+    abort ();\n+  if (chk_calls != 3)\n+    abort ();\n+\n+  chk_calls = 0;\n+  /* The following calls have side-effects in dest, so are not checked.  */\n+  strcpy (dst, s1); d2 = dst;\n+  if (__builtin___strncat_chk (++d2, s1, 100, os (++d2)) != dst+1\n+      || d2 != dst+1 || strcmp (dst, \"hello worldhello world\"))\n+    abort ();\n+  strcpy (dst, s1); d2 = dst;\n+  if (__builtin___strncat_chk (++d2+5, s1, 100, os (++d2+5)) != dst+6\n+      || d2 != dst+1 || strcmp (dst, \"hello worldhello world\"))\n+    abort ();\n+  strcpy (dst, s1); d2 = dst;\n+  if (__builtin___strncat_chk (++d2+5, s1+5, 100, os (++d2+5)) != dst+6\n+      || d2 != dst+1 || strcmp (dst, \"hello world world\"))\n+    abort ();\n+  if (chk_calls)\n+    abort ();\n+\n+  chk_calls = 0;\n+  strcat_disallowed = 1;\n+\n+  /* Test at least one instance of the __builtin_ style.  We do this\n+     to ensure that it works and that the prototype is correct.  */\n+  strcpy (dst, s1);\n+  if (__builtin_strncat (dst, \"\", 100) != dst || strcmp (dst, s1))\n+    abort ();\n+\n+  if (chk_calls)\n+    abort ();\n+  strncat_disallowed = 0;\n+  strcat_disallowed = 0;\n+}\n+\n+/* Test whether compile time checking is done where it should\n+   and so is runtime object size checking.  */\n+void\n+__attribute__((noinline))\n+test2 (void)\n+{\n+  struct A { char buf1[10]; char buf2[10]; } a;\n+  char *r = l1 == 1 ? &a.buf1[5] : &a.buf2[4];\n+  char buf3[20];\n+  int i;\n+\n+  /* The following calls should do runtime checking.  */\n+  memset (&a, '\\0', sizeof (a));\n+  s5 = (char *) &a;\n+  __asm __volatile (\"\" : : \"r\" (s5) : \"memory\");\n+  chk_calls = 0;\n+  strncat (a.buf1 + 2, s3 + 3, l1 - 1);\n+  strncat (r, s3 + 2, l1);\n+  r = l1 == 1 ? __builtin_alloca (4) : &a.buf2[7];\n+  memset (r, '\\0', 3);\n+  __asm __volatile (\"\" : : \"r\" (r) : \"memory\");\n+  strncat (r, s2 + 2, l1 + 1);\n+  strncat (r + 2, s3 + 3, l1 - 1);\n+  r = buf3;\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[1];\n+      else if (i == l1)\n+\tr = &a.buf2[7];\n+      else if (i == l1 + 1)\n+\tr = &buf3[5];\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[9];\n+    }\n+  strncat (r, s2 + 4, l1);\n+  if (chk_calls != 5)\n+    abort ();\n+\n+  /* Following have known destination and known source length,\n+     but we don't know the length of dest string, so runtime checking\n+     is needed too.  */\n+  memset (&a, '\\0', sizeof (a));\n+  chk_calls = 0;\n+  s5 = (char *) &a;\n+  __asm __volatile (\"\" : : \"r\" (s5) : \"memory\");\n+  strncat (a.buf1 + 2, \"a\", 5);\n+  strncat (r, \"def\", 0);\n+  r = l1 == 1 ? __builtin_alloca (4) : &a.buf2[7];\n+  memset (r, '\\0', 3);\n+  __asm __volatile (\"\" : : \"r\" (r) : \"memory\");\n+  strncat (r, s1 + 1, 2);\n+  if (chk_calls != 2)\n+    abort ();\n+  chk_calls = 0;\n+  strcat_disallowed = 1;\n+  /* Unknown destination and source, no checking.  */\n+  strncat (s4, s3, l1 + 1);\n+  strcat_disallowed = 0;\n+  if (chk_calls)\n+    abort ();\n+}\n+\n+/* Test whether runtime and/or compile time checking catches\n+   buffer overflows.  */\n+void\n+__attribute__((noinline))\n+test3 (void)\n+{\n+  struct A { char buf1[10]; char buf2[10]; } a;\n+  char buf3[20];\n+\n+  memset (&a, '\\0', sizeof (a));\n+  memset (buf3, '\\0', sizeof (buf3));\n+  s5 = (char *) &a;\n+  __asm __volatile (\"\" : : \"r\" (s5) : \"memory\");\n+  s5 = buf3;\n+  __asm __volatile (\"\" : : \"r\" (s5) : \"memory\");\n+  chk_fail_allowed = 1;\n+  /* Runtime checks.  */\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      strncat (&a.buf2[9], s2 + 3, 4);\n+      abort ();\n+    }\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      strncat (&a.buf2[7], s3 + strlen (s3) - 3, 3);\n+      abort ();\n+    }\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      strncat (&buf3[19], \"abcde\", 1);\n+      abort ();\n+    }\n+  chk_fail_allowed = 0;\n+}\n+\n+void\n+main_test (void)\n+{\n+#ifndef __OPTIMIZE__\n+  /* Object size checking is only intended for -O[s123].  */\n+  return;\n+#endif\n+  __asm (\"\" : \"=r\" (s2) : \"0\" (s2));\n+  __asm (\"\" : \"=r\" (s3) : \"0\" (s3));\n+  __asm (\"\" : \"=r\" (l1) : \"0\" (l1));\n+  s4 = p;\n+  test1 ();\n+  memset (p, '\\0', sizeof (p));\n+  test2 ();\n+  test3 ();\n+}"}, {"sha": "9daf13e827b5f757f79552f56c57ed55258d8eb3", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/strncpy-chk-lib.c", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrncpy-chk-lib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrncpy-chk-lib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrncpy-chk-lib.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1 @@\n+#include \"lib/chk.c\""}, {"sha": "46f3374c4dd03a2fc896f70df4a4166458beebc0", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/strncpy-chk.c", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrncpy-chk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrncpy-chk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrncpy-chk.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,227 @@\n+/* Copyright (C) 2004, 2005  Free Software Foundation.\n+\n+   Ensure builtin __strncpy_chk performs correctly.  */\n+\n+extern void abort (void);\n+typedef __SIZE_TYPE__ size_t;\n+extern size_t strlen(const char *);\n+extern void *memcpy (void *, const void *, size_t);\n+extern char *strncpy (char *, const char *, size_t);\n+extern int memcmp (const void *, const void *, size_t);\n+extern int strcmp (const char *, const char *);\n+extern int strncmp (const char *, const char *, size_t);\n+extern void *memset (void *, int, size_t);\n+\n+#include \"chk.h\"\n+\n+const char s1[] = \"123\";\n+char p[32] = \"\";\n+char *s2 = \"defg\";\n+char *s3 = \"FGH\";\n+char *s4;\n+size_t l1 = 1;\n+int i;\n+\n+void\n+__attribute__((noinline))\n+test1 (void)\n+{\n+  const char *const src = \"hello world\";\n+  const char *src2;\n+  char dst[64], *dst2;\n+\n+  strncpy_disallowed = 1;\n+  chk_calls = 0;\n+\n+  memset (dst, 0, sizeof (dst));\n+  if (strncpy (dst, src, 4) != dst || strncmp (dst, src, 4))\n+    abort();\n+\n+  memset (dst, 0, sizeof (dst));\n+  if (strncpy (dst+16, src, 4) != dst+16 || strncmp (dst+16, src, 4))\n+    abort();\n+\n+  memset (dst, 0, sizeof (dst));\n+  if (strncpy (dst+32, src+5, 4) != dst+32 || strncmp (dst+32, src+5, 4))\n+    abort();\n+\n+  memset (dst, 0, sizeof (dst));\n+  dst2 = dst;\n+  if (strncpy (++dst2, src+5, 4) != dst+1 || strncmp (dst2, src+5, 4)\n+      || dst2 != dst+1)\n+    abort();\n+\n+  memset (dst, 0, sizeof (dst));\n+  if (strncpy (dst, src, 0) != dst || strcmp (dst, \"\"))\n+    abort();\n+  \n+  memset (dst, 0, sizeof (dst));\n+  dst2 = dst; src2 = src;\n+  if (strncpy (++dst2, ++src2, 0) != dst+1 || strcmp (dst2, \"\")\n+      || dst2 != dst+1 || src2 != src+1)\n+    abort();\n+\n+  memset (dst, 0, sizeof (dst));\n+  dst2 = dst; src2 = src;\n+  if (strncpy (++dst2+5, ++src2+5, 0) != dst+6 || strcmp (dst2+5, \"\")\n+      || dst2 != dst+1 || src2 != src+1)\n+    abort();\n+\n+  memset (dst, 0, sizeof (dst));\n+  if (strncpy (dst, src, 12) != dst || strcmp (dst, src))\n+    abort();\n+\n+  /* Test at least one instance of the __builtin_ style.  We do this\n+     to ensure that it works and that the prototype is correct.  */\n+  memset (dst, 0, sizeof (dst));\n+  if (__builtin_strncpy (dst, src, 4) != dst || strncmp (dst, src, 4))\n+    abort();\n+\n+  memset (dst, 0, sizeof (dst));\n+  if (strncpy (dst, i++ ? \"xfoo\" + 1 : \"bar\", 4) != dst\n+      || strcmp (dst, \"bar\")\n+      || i != 1)\n+    abort ();\n+\n+  if (chk_calls)\n+    abort ();\n+  strncpy_disallowed = 0;\n+}\n+\n+void\n+__attribute__((noinline))\n+test2 (void)\n+{\n+  chk_calls = 0;\n+  /* No runtime checking should be done here, both destination\n+     and length are unknown.  */\n+  strncpy (s4, \"abcd\", l1 + 1);\n+  if (chk_calls)\n+    abort ();\n+}\n+\n+/* Test whether compile time checking is done where it should\n+   and so is runtime object size checking.  */\n+void\n+__attribute__((noinline))\n+test3 (void)\n+{\n+  struct A { char buf1[10]; char buf2[10]; } a;\n+  char *r = l1 == 1 ? &a.buf1[5] : &a.buf2[4];\n+  char buf3[20];\n+  int i;\n+  const char *l;\n+  size_t l2;\n+\n+  /* The following calls should do runtime checking\n+     - source length is not known, but destination is.  */\n+  chk_calls = 0;\n+  strncpy (a.buf1 + 2, s3 + 3, l1);\n+  strncpy (r, s3 + 2, l1 + 2);\n+  r = l1 == 1 ? __builtin_alloca (4) : &a.buf2[7];\n+  strncpy (r, s2 + 2, l1 + 2);\n+  strncpy (r + 2, s3 + 3, l1);\n+  r = buf3;\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[1];\n+      else if (i == l1)\n+\tr = &a.buf2[7];\n+      else if (i == l1 + 1)\n+\tr = &buf3[5];\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[9];\n+    }\n+  strncpy (r, s2 + 4, l1);\n+  if (chk_calls != 5)\n+    abort ();\n+\n+  /* Following have known destination and known length,\n+     so if optimizing certainly shouldn't result in the checking\n+     variants.  */\n+  chk_calls = 0;\n+  strncpy (a.buf1 + 2, \"\", 3);\n+  strncpy (a.buf1 + 2, \"\", 0);\n+  strncpy (r, \"a\", 1);\n+  strncpy (r, \"a\", 3);\n+  r = l1 == 1 ? __builtin_alloca (4) : &a.buf2[7];\n+  strncpy (r, s1 + 1, 3);\n+  strncpy (r, s1 + 1, 2);\n+  r = buf3;\n+  l = \"abc\";\n+  l2 = 4;\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[1], l = \"e\", l2 = 2;\n+      else if (i == l1)\n+\tr = &a.buf2[7], l = \"gh\", l2 = 3;\n+      else if (i == l1 + 1)\n+\tr = &buf3[5], l = \"jkl\", l2 = 4;\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[9], l = \"\", l2 = 1;\n+    }\n+  strncpy (r, \"\", 1);\n+  /* Here, strlen (l) + 1 is known to be at most 4 and\n+     __builtin_object_size (&buf3[16], 0) is 4, so this doesn't need\n+     runtime checking.  */\n+  strncpy (&buf3[16], l, l2);\n+  strncpy (&buf3[15], \"abc\", l2);\n+  strncpy (&buf3[10], \"fghij\", l2);\n+  if (chk_calls)\n+    abort ();\n+  chk_calls = 0;\n+}\n+\n+/* Test whether runtime and/or compile time checking catches\n+   buffer overflows.  */\n+void\n+__attribute__((noinline))\n+test4 (void)\n+{\n+  struct A { char buf1[10]; char buf2[10]; } a;\n+  char buf3[20];\n+\n+  chk_fail_allowed = 1;\n+  /* Runtime checks.  */\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      strncpy (&a.buf2[9], s2 + 4, l1 + 1);\n+      abort ();\n+    }\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      strncpy (&a.buf2[7], s3, l1 + 4);\n+      abort ();\n+    }\n+  /* This should be detectable at compile time already.  */\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      strncpy (&buf3[19], \"abc\", 2);\n+      abort ();\n+    }\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      strncpy (&buf3[18], \"\", 3);\n+      abort ();\n+    }\n+  chk_fail_allowed = 0;\n+}\n+\n+void\n+main_test (void)\n+{\n+#ifndef __OPTIMIZE__\n+  /* Object size checking is only intended for -O[s123].  */\n+  return;\n+#endif\n+  __asm (\"\" : \"=r\" (s2) : \"0\" (s2));\n+  __asm (\"\" : \"=r\" (s3) : \"0\" (s3));\n+  __asm (\"\" : \"=r\" (l1) : \"0\" (l1));\n+  test1 ();\n+  s4 = p;\n+  test2 ();\n+  test3 ();\n+  test4 ();\n+}"}, {"sha": "9daf13e827b5f757f79552f56c57ed55258d8eb3", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/vsnprintf-chk-lib.c", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fvsnprintf-chk-lib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fvsnprintf-chk-lib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fvsnprintf-chk-lib.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1 @@\n+#include \"lib/chk.c\""}, {"sha": "8c7d72f391d4c909ff265d55aa6d3d4b70a68a44", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/vsnprintf-chk.c", "status": "added", "additions": 321, "deletions": 0, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fvsnprintf-chk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fvsnprintf-chk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fvsnprintf-chk.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,321 @@\n+/* Copyright (C) 2004, 2005  Free Software Foundation.\n+\n+   Ensure builtin __vsnprintf_chk performs correctly.  */\n+\n+#include <stdarg.h>\n+\n+extern void abort (void);\n+typedef __SIZE_TYPE__ size_t;\n+extern size_t strlen(const char *);\n+extern void *memcpy (void *, const void *, size_t);\n+extern char *strcpy (char *, const char *);\n+extern int memcmp (const void *, const void *, size_t);\n+extern void *memset (void *, int, size_t);\n+extern int vsnprintf (char *, size_t, const char *, va_list);\n+\n+#include \"chk.h\"\n+\n+const char s1[] = \"123\";\n+char p[32] = \"\";\n+char *s2 = \"defg\";\n+char *s3 = \"FGH\";\n+char *s4;\n+size_t l1 = 1;\n+static char buffer[32];\n+char *ptr = \"barf\";\n+\n+int\n+__attribute__((noinline))\n+test1_sub (int i, ...)\n+{\n+  int ret = 0;\n+  va_list ap;\n+  va_start (ap, i);\n+  switch (i)\n+    {\n+    case 0:\n+      vsnprintf (buffer, 4, \"foo\", ap);\n+      break;\n+    case 1:\n+      ret = vsnprintf (buffer, 4, \"foo bar\", ap);\n+      break;\n+    case 2:\n+      vsnprintf (buffer, 32, \"%s\", ap);\n+      break;\n+    case 3:\n+      ret = vsnprintf (buffer, 21, \"%s\", ap);\n+      break;\n+    case 4:\n+      ret = vsnprintf (buffer, 4, \"%d%d%d\", ap);\n+      break;\n+    case 5:\n+      ret = vsnprintf (buffer, 32, \"%d%d%d\", ap);\n+      break;\n+    case 6:\n+      ret = vsnprintf (buffer, strlen (ptr) + 1, \"%s\", ap);\n+      break;\n+    case 7:\n+      vsnprintf (buffer, l1 + 31, \"%d - %c\", ap);\n+      break;\n+    case 8:\n+      vsnprintf (s4, l1 + 6, \"%d - %c\", ap);\n+      break;\n+    }\n+  va_end (ap);\n+  return ret;\n+}\n+\n+void\n+__attribute__((noinline))\n+test1 (void)\n+{\n+  chk_calls = 0;\n+  /* vsnprintf_disallowed = 1; */\n+\n+  memset (buffer, 'A', 32);\n+  test1_sub (0);\n+  if (memcmp (buffer, \"foo\", 4) || buffer[4] != 'A')\n+    abort ();\n+\n+  memset (buffer, 'A', 32);\n+  if (test1_sub (1) != 7)\n+    abort ();\n+  if (memcmp (buffer, \"foo\", 4) || buffer[4] != 'A')\n+    abort ();\n+\n+  vsnprintf_disallowed = 0;\n+\n+  memset (buffer, 'A', 32);\n+  test1_sub (2, \"bar\");\n+  if (memcmp (buffer, \"bar\", 4) || buffer[4] != 'A')\n+    abort ();\n+\n+  memset (buffer, 'A', 32);\n+  if (test1_sub (3, \"bar\") != 3)\n+    abort ();\n+  if (memcmp (buffer, \"bar\", 4) || buffer[4] != 'A')\n+    abort ();\n+\n+  memset (buffer, 'A', 32);\n+  if (test1_sub (4, (int) l1, (int) l1 + 1, (int) l1 + 12) != 4)\n+    abort ();\n+  if (memcmp (buffer, \"121\", 4) || buffer[4] != 'A')\n+    abort ();\n+\n+  memset (buffer, 'A', 32);\n+  if (test1_sub (5, (int) l1, (int) l1 + 1, (int) l1 + 12) != 4)\n+    abort ();\n+  if (memcmp (buffer, \"1213\", 5) || buffer[5] != 'A')\n+    abort ();\n+\n+  if (chk_calls)\n+    abort ();\n+\n+  memset (buffer, 'A', 32);\n+  test1_sub (6, ptr);\n+  if (memcmp (buffer, \"barf\", 5) || buffer[5] != 'A')\n+    abort ();\n+\n+  memset (buffer, 'A', 32);\n+  test1_sub (7, (int) l1 + 27, *ptr);\n+  if (memcmp (buffer, \"28 - b\\0AAAAA\", 12))\n+    abort ();\n+\n+  if (chk_calls != 2)\n+    abort ();\n+  chk_calls = 0;\n+\n+  memset (s4, 'A', 32);\n+  test1_sub (8, (int) l1 - 17, ptr[1]);\n+  if (memcmp (s4, \"-16 - \\0AAA\", 10))\n+    abort ();\n+  if (chk_calls)\n+    abort ();\n+}\n+\n+void\n+__attribute__((noinline))\n+test2_sub (int i, ...)\n+{\n+  va_list ap;\n+  struct A { char buf1[10]; char buf2[10]; } a;\n+  char *r = l1 == 1 ? &a.buf1[5] : &a.buf2[4];\n+  char buf3[20];\n+  int j;\n+\n+  va_start (ap, i);\n+  /* The following calls should do runtime checking\n+     - length is not known, but destination is.  */\n+  switch (i)\n+    {\n+    case 0:\n+      vsnprintf (a.buf1 + 2, l1, \"%s\", ap);\n+      break;\n+    case 1:\n+      vsnprintf (r, l1 + 4, \"%s%c\", ap);\n+      break;\n+    case 2:\n+      r = l1 == 1 ? __builtin_alloca (4) : &a.buf2[7];\n+      vsnprintf (r, strlen (s2) - 2, \"%c %s\", ap);\n+      break;\n+    case 3:\n+      r = l1 == 1 ? __builtin_alloca (4) : &a.buf2[7];\n+      vsnprintf (r + 2, l1, s3 + 3, ap);\n+      break;\n+    case 4:\n+    case 7:\n+      r = buf3;\n+      for (j = 0; j < 4; ++j)\n+\t{\n+\t  if (j == l1 - 1)\n+\t    r = &a.buf1[1];\n+\t  else if (j == l1)\n+\t    r = &a.buf2[7];\n+\t  else if (j == l1 + 1)\n+\t    r = &buf3[5];\n+\t  else if (j == l1 + 2)\n+\t    r = &a.buf1[9];\n+\t}\n+      if (i == 4)\n+\tvsnprintf (r, l1, s2 + 4, ap);\n+      else\n+\tvsnprintf (r, 1, \"a\", ap);\n+      break;\n+    case 5:\n+      r = l1 == 1 ? __builtin_alloca (4) : &a.buf2[7];\n+      vsnprintf (r, l1 + 3, \"%s\", ap);\n+      break;\n+    case 6:\n+      vsnprintf (a.buf1 + 2, 4, \"\", ap);\n+      break;\n+    case 8:\n+      vsnprintf (s4, 3, \"%s %d\", ap);\n+      break;\n+    }\n+  va_end (ap);\n+}\n+\n+/* Test whether compile time checking is done where it should\n+   and so is runtime object size checking.  */\n+void\n+__attribute__((noinline))\n+test2 (void)\n+{\n+  /* The following calls should do runtime checking\n+     - length is not known, but destination is.  */\n+  chk_calls = 0;\n+  test2_sub (0, s3 + 3);\n+  test2_sub (1, s3 + 3, s3[3]);\n+  test2_sub (2, s2[2], s2 + 4);\n+  test2_sub (3);\n+  test2_sub (4);\n+  test2_sub (5, s1 + 1);\n+  if (chk_calls != 6)\n+    abort ();\n+\n+  /* Following have known destination and known source length,\n+     so if optimizing certainly shouldn't result in the checking\n+     variants.  */\n+  chk_calls = 0;\n+  /* vsnprintf_disallowed = 1; */\n+  test2_sub (6);\n+  test2_sub (7);\n+  vsnprintf_disallowed = 0;\n+  /* Unknown destination and source, no checking.  */\n+  test2_sub (8, s3, 0);\n+  if (chk_calls)\n+    abort ();\n+}\n+\n+void\n+__attribute__((noinline))\n+test3_sub (int i, ...)\n+{\n+  va_list ap;\n+  struct A { char buf1[10]; char buf2[10]; } a;\n+  char buf3[20];\n+\n+  va_start (ap, i);\n+  /* The following calls should do runtime checking\n+     - source length is not known, but destination is.  */\n+  switch (i)\n+    {\n+    case 0:\n+      vsnprintf (&a.buf2[9], l1 + 1, \"%c%s\", ap);\n+      break;\n+    case 1:\n+      vsnprintf (&a.buf2[7], l1 + 30, \"%s%c\", ap);\n+      break;\n+    case 2:\n+      vsnprintf (&a.buf2[7], l1 + 3, \"%d\", ap);\n+      break;\n+    case 3:\n+      vsnprintf (&buf3[17], l1 + 3, \"%s\", ap);\n+      break;\n+    case 4:\n+      vsnprintf (&buf3[19], 2, \"a\", ap);\n+      break;\n+    case 5:\n+      vsnprintf (&buf3[16], 5, \"a\", ap);\n+      break;\n+    }\n+  va_end (ap);\n+}\n+\n+/* Test whether runtime and/or compile time checking catches\n+   buffer overflows.  */\n+void\n+__attribute__((noinline))\n+test3 (void)\n+{\n+  chk_fail_allowed = 1;\n+  /* Runtime checks.  */\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      test3_sub (0, s2[3], s2 + 4);\n+      abort ();\n+    }\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      test3_sub (1, s3 + strlen (s3) - 2, *s3);\n+      abort ();\n+    }\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      test3_sub (2, (int) l1 + 9999);\n+      abort ();\n+    }\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      test3_sub (3, \"abc\");\n+      abort ();\n+    }\n+  /* This should be detectable at compile time already.  */\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      test3_sub (4);\n+      abort ();\n+    }\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      test3_sub (5);\n+      abort ();\n+    }\n+  chk_fail_allowed = 0;\n+}\n+\n+void\n+main_test (void)\n+{\n+#ifndef __OPTIMIZE__\n+  /* Object size checking is only intended for -O[s123].  */\n+  return;\n+#endif\n+  __asm (\"\" : \"=r\" (s2) : \"0\" (s2));\n+  __asm (\"\" : \"=r\" (s3) : \"0\" (s3));\n+  __asm (\"\" : \"=r\" (l1) : \"0\" (l1));\n+  s4 = p;\n+  test1 ();\n+  test2 ();\n+  test3 ();\n+}"}, {"sha": "9daf13e827b5f757f79552f56c57ed55258d8eb3", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/vsprintf-chk-lib.c", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fvsprintf-chk-lib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fvsprintf-chk-lib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fvsprintf-chk-lib.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1 @@\n+#include \"lib/chk.c\""}, {"sha": "5c150901800ef9da78dbf86d001cc0d9667360d4", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/vsprintf-chk.c", "status": "added", "additions": 290, "deletions": 0, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fvsprintf-chk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fvsprintf-chk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fvsprintf-chk.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,290 @@\n+/* Copyright (C) 2004, 2005  Free Software Foundation.\n+\n+   Ensure builtin __vsprintf_chk performs correctly.  */\n+\n+#include <stdarg.h>\n+\n+extern void abort (void);\n+typedef __SIZE_TYPE__ size_t;\n+extern size_t strlen(const char *);\n+extern void *memcpy (void *, const void *, size_t);\n+extern char *strcpy (char *, const char *);\n+extern int memcmp (const void *, const void *, size_t);\n+extern void *memset (void *, int, size_t);\n+extern int vsprintf (char *, const char *, va_list);\n+\n+#include \"chk.h\"\n+\n+const char s1[] = \"123\";\n+char p[32] = \"\";\n+char *s2 = \"defg\";\n+char *s3 = \"FGH\";\n+char *s4;\n+size_t l1 = 1;\n+static char buffer[32];\n+char *ptr = \"barf\";\n+\n+int\n+__attribute__((noinline))\n+test1_sub (int i, ...)\n+{\n+  int ret = 0;\n+  va_list ap;\n+  va_start (ap, i);\n+  switch (i)\n+    {\n+    case 0:\n+      vsprintf (buffer, \"foo\", ap);\n+      break;\n+    case 1:\n+      ret = vsprintf (buffer, \"foo\", ap);\n+      break;\n+    case 2:\n+      vsprintf (buffer, \"%s\", ap);\n+      break;\n+    case 3:\n+      ret = vsprintf (buffer, \"%s\", ap);\n+      break;\n+    case 4:\n+      vsprintf (buffer, \"%d - %c\", ap);\n+      break;\n+    case 5:\n+      vsprintf (s4, \"%d - %c\", ap);\n+      break;\n+    }\n+  va_end (ap);\n+  return ret;\n+}\n+\n+void\n+__attribute__((noinline))\n+test1 (void)\n+{\n+  chk_calls = 0;\n+  vsprintf_disallowed = 1;\n+\n+  memset (buffer, 'A', 32);\n+  test1_sub (0);\n+  if (memcmp (buffer, \"foo\", 4) || buffer[4] != 'A')\n+    abort ();\n+\n+  memset (buffer, 'A', 32);\n+  if (test1_sub (1) != 3)\n+    abort ();\n+  if (memcmp (buffer, \"foo\", 4) || buffer[4] != 'A')\n+    abort ();\n+\n+  if (chk_calls)\n+    abort ();\n+  vsprintf_disallowed = 0;\n+\n+  memset (buffer, 'A', 32);\n+  test1_sub (2, \"bar\");\n+  if (memcmp (buffer, \"bar\", 4) || buffer[4] != 'A')\n+    abort ();\n+\n+  memset (buffer, 'A', 32);\n+  if (test1_sub (3, \"bar\") != 3)\n+    abort ();\n+  if (memcmp (buffer, \"bar\", 4) || buffer[4] != 'A')\n+    abort ();\n+\n+  memset (buffer, 'A', 32);\n+  test1_sub (2, ptr);\n+  if (memcmp (buffer, \"barf\", 5) || buffer[5] != 'A')\n+    abort ();\n+\n+  memset (buffer, 'A', 32);\n+  test1_sub (4, (int) l1 + 27, *ptr);\n+  if (memcmp (buffer, \"28 - b\\0AAAAA\", 12))\n+    abort ();\n+\n+  if (chk_calls != 4)\n+    abort ();\n+  chk_calls = 0;\n+\n+  test1_sub (5, (int) l1 - 17, ptr[1]);\n+  if (memcmp (s4, \"-16 - a\", 8))\n+    abort ();\n+  if (chk_calls)\n+    abort ();\n+}\n+\n+void\n+__attribute__((noinline))\n+test2_sub (int i, ...)\n+{\n+  va_list ap;\n+  struct A { char buf1[10]; char buf2[10]; } a;\n+  char *r = l1 == 1 ? &a.buf1[5] : &a.buf2[4];\n+  char buf3[20];\n+  int j;\n+\n+  va_start (ap, i);\n+  /* The following calls should do runtime checking\n+     - source length is not known, but destination is.  */\n+  switch (i)\n+    {\n+    case 0:\n+      vsprintf (a.buf1 + 2, \"%s\", ap);\n+      break;\n+    case 1:\n+      vsprintf (r, \"%s%c\", ap);\n+      break;\n+    case 2:\n+      r = l1 == 1 ? __builtin_alloca (4) : &a.buf2[7];\n+      vsprintf (r, \"%c %s\", ap);\n+      break;\n+    case 3:\n+      r = l1 == 1 ? __builtin_alloca (4) : &a.buf2[7];\n+      vsprintf (r + 2, s3 + 3, ap);\n+      break;\n+    case 4:\n+    case 7:\n+      r = buf3;\n+      for (j = 0; j < 4; ++j)\n+\t{\n+\t  if (j == l1 - 1)\n+\t    r = &a.buf1[1];\n+\t  else if (j == l1)\n+\t    r = &a.buf2[7];\n+\t  else if (j == l1 + 1)\n+\t    r = &buf3[5];\n+\t  else if (j == l1 + 2)\n+\t    r = &a.buf1[9];\n+\t}\n+      if (i == 4)\n+\tvsprintf (r, s2 + 4, ap);\n+      else\n+\tvsprintf (r, \"a\", ap);\n+      break;\n+    case 5:\n+      r = l1 == 1 ? __builtin_alloca (4) : &a.buf2[7];\n+      vsprintf (r, \"%s\", ap);\n+      break;\n+    case 6:\n+      vsprintf (a.buf1 + 2, \"\", ap);\n+      break;\n+    case 8:\n+      vsprintf (s4, \"%s %d\", ap);\n+      break;\n+    }\n+  va_end (ap);\n+}\n+\n+/* Test whether compile time checking is done where it should\n+   and so is runtime object size checking.  */\n+void\n+__attribute__((noinline))\n+test2 (void)\n+{\n+  /* The following calls should do runtime checking\n+     - source length is not known, but destination is.  */\n+  chk_calls = 0;\n+  test2_sub (0, s3 + 3);\n+  test2_sub (1, s3 + 3, s3[3]);\n+  test2_sub (2, s2[2], s2 + 4);\n+  test2_sub (3);\n+  test2_sub (4);\n+  test2_sub (5, s1 + 1);\n+  if (chk_calls != 6)\n+    abort ();\n+\n+  /* Following have known destination and known source length,\n+     so if optimizing certainly shouldn't result in the checking\n+     variants.  */\n+  chk_calls = 0;\n+  vsprintf_disallowed = 1;\n+  test2_sub (6);\n+  test2_sub (7);\n+  vsprintf_disallowed = 0;\n+  /* Unknown destination and source, no checking.  */\n+  test2_sub (8, s3, 0);\n+  if (chk_calls)\n+    abort ();\n+}\n+\n+void\n+__attribute__((noinline))\n+test3_sub (int i, ...)\n+{\n+  va_list ap;\n+  struct A { char buf1[10]; char buf2[10]; } a;\n+  char buf3[20];\n+\n+  va_start (ap, i);\n+  /* The following calls should do runtime checking\n+     - source length is not known, but destination is.  */\n+  switch (i)\n+    {\n+    case 0:\n+      vsprintf (&a.buf2[9], \"%c%s\", ap);\n+      break;\n+    case 1:\n+      vsprintf (&a.buf2[7], \"%s%c\", ap);\n+      break;\n+    case 2:\n+      vsprintf (&a.buf2[7], \"%d\", ap);\n+      break;\n+    case 3:\n+      vsprintf (&buf3[17], \"%s\", ap);\n+      break;\n+    case 4:\n+      vsprintf (&buf3[19], \"a\", ap);\n+      break;\n+    }\n+  va_end (ap);\n+}\n+\n+/* Test whether runtime and/or compile time checking catches\n+   buffer overflows.  */\n+void\n+__attribute__((noinline))\n+test3 (void)\n+{\n+  chk_fail_allowed = 1;\n+  /* Runtime checks.  */\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      test3_sub (0, s2[3], s2 + 4);\n+      abort ();\n+    }\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      test3_sub (1, s3 + strlen (s3) - 2, *s3);\n+      abort ();\n+    }\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      test3_sub (2, (int) l1 + 9999);\n+      abort ();\n+    }\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      test3_sub (3, \"abc\");\n+      abort ();\n+    }\n+  /* This should be detectable at compile time already.  */\n+  if (__builtin_setjmp (chk_fail_buf) == 0)\n+    {\n+      test3_sub (4);\n+      abort ();\n+    }\n+  chk_fail_allowed = 0;\n+}\n+\n+void\n+main_test (void)\n+{\n+#ifndef __OPTIMIZE__\n+  /* Object size checking is only intended for -O[s123].  */\n+  return;\n+#endif\n+  __asm (\"\" : \"=r\" (s2) : \"0\" (s2));\n+  __asm (\"\" : \"=r\" (s3) : \"0\" (s3));\n+  __asm (\"\" : \"=r\" (l1) : \"0\" (l1));\n+  s4 = p;\n+  test1 ();\n+  test2 ();\n+  test3 ();\n+}"}, {"sha": "f16252b1e8e690c724f6217751017df4e61673ba", "filename": "gcc/testsuite/gcc.c-torture/execute/fprintf-1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Ffprintf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Ffprintf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Ffprintf-1.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,23 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+int\n+main (void)\n+{\n+#define test(ret, args...) \\\n+  fprintf (stdout, args); \t\t\\\n+  if (fprintf (stdout, args) != ret)\t\\\n+    abort ();\n+  test (5, \"hello\");\n+  test (6, \"hello\\n\");\n+  test (1, \"a\");\n+  test (0, \"\");\n+  test (5, \"%s\", \"hello\");\n+  test (6, \"%s\", \"hello\\n\");\n+  test (1, \"%s\", \"a\");\n+  test (0, \"%s\", \"\");\n+  test (1, \"%c\", 'x');\n+  test (7, \"%s\\n\", \"hello\\n\");\n+  test (2, \"%d\\n\", 0);\n+  return 0;\n+}"}, {"sha": "918ff8e5689a84e84ed63654c9a534a5acd9bff0", "filename": "gcc/testsuite/gcc.c-torture/execute/fprintf-chk-1.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Ffprintf-chk-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Ffprintf-chk-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Ffprintf-chk-1.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,49 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stdarg.h>\n+\n+volatile int should_optimize;\n+\n+int\n+__attribute__((noinline))\n+__fprintf_chk (FILE *f, int flag, const char *fmt, ...)\n+{\n+  va_list ap;\n+  int ret;\n+#ifdef __OPTIMIZE__\n+  if (should_optimize)\n+    abort ();\n+#endif\n+  should_optimize = 1;\n+  va_start (ap, fmt);\n+  ret = vfprintf (f, fmt, ap);\n+  va_end (ap);\n+  return ret;\n+}\n+\n+int\n+main (void)\n+{\n+#define test(ret, opt, args...) \\\n+  should_optimize = opt;\t\t\t\\\n+  __fprintf_chk (stdout, 1, args); \t\t\\\n+  if (!should_optimize)\t\t\t\t\\\n+    abort ();\t\t\t\t\t\\\n+  should_optimize = 0;\t\t\t\t\\\n+  if (__fprintf_chk (stdout, 1, args) != ret)\t\\\n+    abort ();\t\t\t\t\t\\\n+  if (!should_optimize)\t\t\t\t\\\n+    abort ();\n+  test (5, 1, \"hello\");\n+  test (6, 1, \"hello\\n\");\n+  test (1, 1, \"a\");\n+  test (0, 1, \"\");\n+  test (5, 1, \"%s\", \"hello\");\n+  test (6, 1, \"%s\", \"hello\\n\");\n+  test (1, 1, \"%s\", \"a\");\n+  test (0, 1, \"%s\", \"\");\n+  test (1, 1, \"%c\", 'x');\n+  test (7, 0, \"%s\\n\", \"hello\\n\");\n+  test (2, 0, \"%d\\n\", 0);\n+  return 0;\n+}"}, {"sha": "0ffcd5d443b662aeefe58c9ea99dfbb5ff10a770", "filename": "gcc/testsuite/gcc.c-torture/execute/printf-1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fprintf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fprintf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fprintf-1.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,23 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+int\n+main (void)\n+{\n+#define test(ret, args...) \\\n+  printf (args); \t\t\\\n+  if (printf (args) != ret)\t\\\n+    abort ();\n+  test (5, \"hello\");\n+  test (6, \"hello\\n\");\n+  test (1, \"a\");\n+  test (0, \"\");\n+  test (5, \"%s\", \"hello\");\n+  test (6, \"%s\", \"hello\\n\");\n+  test (1, \"%s\", \"a\");\n+  test (0, \"%s\", \"\");\n+  test (1, \"%c\", 'x');\n+  test (7, \"%s\\n\", \"hello\\n\");\n+  test (2, \"%d\\n\", 0);\n+  return 0;\n+}"}, {"sha": "8f9a79c5c578a0e78cc730411194c97889da4c77", "filename": "gcc/testsuite/gcc.c-torture/execute/printf-chk-1.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fprintf-chk-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fprintf-chk-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fprintf-chk-1.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,49 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stdarg.h>\n+\n+volatile int should_optimize;\n+\n+int\n+__attribute__((noinline))\n+__printf_chk (int flag, const char *fmt, ...)\n+{\n+  va_list ap;\n+  int ret;\n+#ifdef __OPTIMIZE__\n+  if (should_optimize)\n+    abort ();\n+#endif\n+  should_optimize = 1;\n+  va_start (ap, fmt);\n+  ret = vprintf (fmt, ap);\n+  va_end (ap);\n+  return ret;\n+}\n+\n+int\n+main (void)\n+{\n+#define test(ret, opt, args...) \\\n+  should_optimize = opt;\t\t\\\n+  __printf_chk (1, args); \t\t\\\n+  if (!should_optimize)\t\t\t\\\n+    abort ();\t\t\t\t\\\n+  should_optimize = 0;\t\t\t\\\n+  if (__printf_chk (1, args) != ret)\t\\\n+    abort ();\t\t\t\t\\\n+  if (!should_optimize)\t\t\t\\\n+    abort ();\n+  test (5, 0, \"hello\");\n+  test (6, 1, \"hello\\n\");\n+  test (1, 1, \"a\");\n+  test (0, 1, \"\");\n+  test (5, 0, \"%s\", \"hello\");\n+  test (6, 1, \"%s\", \"hello\\n\");\n+  test (1, 1, \"%s\", \"a\");\n+  test (0, 1, \"%s\", \"\");\n+  test (1, 1, \"%c\", 'x');\n+  test (7, 1, \"%s\\n\", \"hello\\n\");\n+  test (2, 0, \"%d\\n\", 0);\n+  return 0;\n+}"}, {"sha": "c0038042542517cb458e6366b513402708c77970", "filename": "gcc/testsuite/gcc.c-torture/execute/vfprintf-1.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvfprintf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvfprintf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvfprintf-1.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,53 @@\n+#ifndef test\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stdarg.h>\n+\n+void\n+inner (int x, ...)\n+{\n+  va_list ap, ap2;\n+  va_start (ap, x);\n+  va_start (ap2, x);\n+\n+  switch (x)\n+    {\n+#define test(n, ret, fmt, args) \\\n+    case n:\t\t\t\t\t\\\n+      vfprintf (stdout, fmt, ap);\t\t\\\n+      if (vfprintf (stdout, fmt, ap2) != ret)\t\\\n+\tabort ();\t\t\t\t\\\n+      break;\n+#include \"vfprintf-1.c\"\n+#undef test\n+    default:\n+      abort ();\n+    }\n+\n+  va_end (ap);\n+  va_end (ap2);\n+}\n+\n+int\n+main (void)\n+{\n+#define test(n, ret, fmt, args) \\\n+  inner args;\n+#include \"vfprintf-1.c\"\n+#undef test\n+  return 0;\n+}\n+\n+#else\n+  test (0, 5, \"hello\", (0));\n+  test (1, 6, \"hello\\n\", (1));\n+  test (2, 1, \"a\", (2));\n+  test (3, 0, \"\", (3));\n+  test (4, 5, \"%s\", (4, \"hello\"));\n+  test (5, 6, \"%s\", (5, \"hello\\n\"));\n+  test (6, 1, \"%s\", (6, \"a\"));\n+  test (7, 0, \"%s\", (7, \"\"));\n+  test (8, 1, \"%c\", (8, 'x'));\n+  test (9, 7, \"%s\\n\", (9, \"hello\\n\"));\n+  test (10, 2, \"%d\\n\", (10, 0));\n+#endif"}, {"sha": "f8f964c7e9af28828eca817159e666c1fae0fa22", "filename": "gcc/testsuite/gcc.c-torture/execute/vfprintf-chk-1.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvfprintf-chk-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvfprintf-chk-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvfprintf-chk-1.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,73 @@\n+#ifndef test\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stdarg.h>\n+\n+volatile int should_optimize;\n+\n+int\n+__attribute__((noinline))\n+__vfprintf_chk (FILE *f, int flag, const char *fmt, va_list ap)\n+{\n+#ifdef __OPTIMIZE__\n+  if (should_optimize)\n+    abort ();\n+#endif\n+  should_optimize = 1;\n+  return vfprintf (f, fmt, ap);\n+}\n+\n+void\n+inner (int x, ...)\n+{\n+  va_list ap, ap2;\n+  va_start (ap, x);\n+  va_start (ap2, x);\n+\n+  switch (x)\n+    {\n+#define test(n, ret, opt, fmt, args) \\\n+    case n:\t\t\t\t\t\t\\\n+      should_optimize = opt;\t\t\t\t\\\n+      __vfprintf_chk (stdout, 1, fmt, ap);\t\t\\\n+      if (! should_optimize)\t\t\t\t\\\n+\tabort ();\t\t\t\t\t\\\n+      should_optimize = 0;\t\t\t\t\\\n+      if (__vfprintf_chk (stdout, 1, fmt, ap2) != ret)\t\\\n+\tabort ();\t\t\t\t\t\\\n+      if (! should_optimize)\t\t\t\t\\\n+\tabort ();\t\t\t\t\t\\\n+      break;\n+#include \"vfprintf-chk-1.c\"\n+#undef test\n+    default:\n+      abort ();\n+    }\n+\n+  va_end (ap);\n+  va_end (ap2);\n+}\n+\n+int\n+main (void)\n+{\n+#define test(n, ret, opt, fmt, args) \\\n+  inner args;\n+#include \"vfprintf-chk-1.c\"\n+#undef test\n+  return 0;\n+}\n+\n+#else\n+  test (0, 5, 1, \"hello\", (0));\n+  test (1, 6, 1, \"hello\\n\", (1));\n+  test (2, 1, 1, \"a\", (2));\n+  test (3, 0, 1, \"\", (3));\n+  test (4, 5, 0, \"%s\", (4, \"hello\"));\n+  test (5, 6, 0, \"%s\", (5, \"hello\\n\"));\n+  test (6, 1, 0, \"%s\", (6, \"a\"));\n+  test (7, 0, 0, \"%s\", (7, \"\"));\n+  test (8, 1, 0, \"%c\", (8, 'x'));\n+  test (9, 7, 0, \"%s\\n\", (9, \"hello\\n\"));\n+  test (10, 2, 0, \"%d\\n\", (10, 0));\n+#endif"}, {"sha": "9f1b8bf67aa3535aaf5f542f980de9139fa0a369", "filename": "gcc/testsuite/gcc.c-torture/execute/vprintf-1.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvprintf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvprintf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvprintf-1.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,53 @@\n+#ifndef test\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stdarg.h>\n+\n+void\n+inner (int x, ...)\n+{\n+  va_list ap, ap2;\n+  va_start (ap, x);\n+  va_start (ap2, x);\n+\n+  switch (x)\n+    {\n+#define test(n, ret, fmt, args) \\\n+    case n:\t\t\t\t\\\n+      vprintf (fmt, ap);\t\t\\\n+      if (vprintf (fmt, ap2) != ret)\t\\\n+\tabort ();\t\t\t\\\n+      break;\n+#include \"vprintf-1.c\"\n+#undef test\n+    default:\n+      abort ();\n+    }\n+\n+  va_end (ap);\n+  va_end (ap2);\n+}\n+\n+int\n+main (void)\n+{\n+#define test(n, ret, fmt, args) \\\n+  inner args;\n+#include \"vprintf-1.c\"\n+#undef test\n+  return 0;\n+}\n+\n+#else\n+  test (0, 5, \"hello\", (0));\n+  test (1, 6, \"hello\\n\", (1));\n+  test (2, 1, \"a\", (2));\n+  test (3, 0, \"\", (3));\n+  test (4, 5, \"%s\", (4, \"hello\"));\n+  test (5, 6, \"%s\", (5, \"hello\\n\"));\n+  test (6, 1, \"%s\", (6, \"a\"));\n+  test (7, 0, \"%s\", (7, \"\"));\n+  test (8, 1, \"%c\", (8, 'x'));\n+  test (9, 7, \"%s\\n\", (9, \"hello\\n\"));\n+  test (10, 2, \"%d\\n\", (10, 0));\n+#endif"}, {"sha": "ca62f8b9fe24740f3a5028cf77ee59e345a0d226", "filename": "gcc/testsuite/gcc.c-torture/execute/vprintf-chk-1.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvprintf-chk-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvprintf-chk-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvprintf-chk-1.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,73 @@\n+#ifndef test\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stdarg.h>\n+\n+volatile int should_optimize;\n+\n+int\n+__attribute__((noinline))\n+__vprintf_chk (int flag, const char *fmt, va_list ap)\n+{\n+#ifdef __OPTIMIZE__\n+  if (should_optimize)\n+    abort ();\n+#endif\n+  should_optimize = 1;\n+  return vprintf (fmt, ap);\n+}\n+\n+void\n+inner (int x, ...)\n+{\n+  va_list ap, ap2;\n+  va_start (ap, x);\n+  va_start (ap2, x);\n+\n+  switch (x)\n+    {\n+#define test(n, ret, opt, fmt, args) \\\n+    case n:\t\t\t\t\t\\\n+      should_optimize = opt;\t\t\t\\\n+      __vprintf_chk (1, fmt, ap);\t\t\\\n+      if (! should_optimize)\t\t\t\\\n+\tabort ();\t\t\t\t\\\n+      should_optimize = 0;\t\t\t\\\n+      if (__vprintf_chk (1, fmt, ap2) != ret)\t\\\n+\tabort ();\t\t\t\t\\\n+      if (! should_optimize)\t\t\t\\\n+\tabort ();\t\t\t\t\\\n+      break;\n+#include \"vprintf-chk-1.c\"\n+#undef test\n+    default:\n+      abort ();\n+    }\n+\n+  va_end (ap);\n+  va_end (ap2);\n+}\n+\n+int\n+main (void)\n+{\n+#define test(n, ret, opt, fmt, args) \\\n+  inner args;\n+#include \"vprintf-chk-1.c\"\n+#undef test\n+  return 0;\n+}\n+\n+#else\n+  test (0, 5, 0, \"hello\", (0));\n+  test (1, 6, 1, \"hello\\n\", (1));\n+  test (2, 1, 1, \"a\", (2));\n+  test (3, 0, 1, \"\", (3));\n+  test (4, 5, 0, \"%s\", (4, \"hello\"));\n+  test (5, 6, 0, \"%s\", (5, \"hello\\n\"));\n+  test (6, 1, 0, \"%s\", (6, \"a\"));\n+  test (7, 0, 0, \"%s\", (7, \"\"));\n+  test (8, 1, 0, \"%c\", (8, 'x'));\n+  test (9, 7, 0, \"%s\\n\", (9, \"hello\\n\"));\n+  test (10, 2, 0, \"%d\\n\", (10, 0));\n+#endif"}, {"sha": "404b7117f88679017e51fa1c03ddcb98818b6b54", "filename": "gcc/testsuite/gcc.dg/builtin-object-size-1.c", "status": "added", "additions": 436, "deletions": 0, "changes": 436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-1.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,436 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern void abort (void);\n+extern void exit (int);\n+extern void *malloc (size_t);\n+extern void *calloc (size_t, size_t);\n+extern void *alloca (size_t);\n+extern void *memcpy (void *, const void *, size_t);\n+extern void *memset (void *, int, size_t);\n+extern char *strcpy (char *, const char *);\n+\n+struct A\n+{\n+  char a[10];\n+  int b;\n+  char c[10];\n+} y, w[4];\n+\n+extern char exta[];\n+extern char extb[30];\n+extern struct A zerol[0];\n+\n+void\n+__attribute__ ((noinline))\n+test1 (void *q, int x)\n+{\n+  struct A a;\n+  void *p = &a.a[3], *r;\n+  char var[x + 10];\n+  if (x < 0)\n+    r = &a.a[9];\n+  else\n+    r = &a.c[1];\n+  if (__builtin_object_size (p, 0)\n+      != sizeof (a) - __builtin_offsetof (struct A, a) - 3)\n+    abort ();\n+  if (__builtin_object_size (&a.c[9], 0)\n+      != sizeof (a) - __builtin_offsetof (struct A, c) - 9)\n+    abort ();\n+  if (__builtin_object_size (q, 0) != (size_t) -1)\n+    abort ();\n+  if (__builtin_object_size (r, 0)\n+      != sizeof (a) - __builtin_offsetof (struct A, a) - 9)\n+    abort ();\n+  if (x < 6)\n+    r = &w[2].a[1];\n+  else\n+    r = &a.a[6];\n+  if (__builtin_object_size (&y, 0)\n+      != sizeof (y))\n+    abort ();\n+  if (__builtin_object_size (w, 0)\n+      != sizeof (w))\n+    abort ();\n+  if (__builtin_object_size (&y.b, 0)\n+      != sizeof (a) - __builtin_offsetof (struct A, b))\n+    abort ();\n+  if (__builtin_object_size (r, 0)\n+      != 2 * sizeof (w[0]) - __builtin_offsetof (struct A, a) - 1)\n+    abort ();\n+  if (x < 20)\n+    r = malloc (30);\n+  else\n+    r = calloc (2, 16);\n+  if (__builtin_object_size (r, 0) != 2 * 16)\n+    abort ();\n+  if (x < 20)\n+    r = malloc (30);\n+  else\n+    r = calloc (2, 14);\n+  if (__builtin_object_size (r, 0) != 30)\n+    abort ();\n+  if (x < 30)\n+    r = malloc (sizeof (a));\n+  else\n+    r = &a.a[3];\n+  if (__builtin_object_size (r, 0) != sizeof (a))\n+    abort ();\n+  r = memcpy (r, \"a\", 2);\n+  if (__builtin_object_size (r, 0) != sizeof (a))\n+    abort ();\n+  r = memcpy (r + 2, \"b\", 2) + 2;\n+  if (__builtin_object_size (r, 0) != sizeof (a) - 4)\n+    abort ();\n+  r = &a.a[4];\n+  r = memset (r, 'a', 2);\n+  if (__builtin_object_size (r, 0)\n+      != sizeof (a) - __builtin_offsetof (struct A, a) - 4)\n+    abort ();\n+  r = memset (r + 2, 'b', 2) + 2;\n+  if (__builtin_object_size (r, 0)\n+      != sizeof (a) - __builtin_offsetof (struct A, a) - 8)\n+    abort ();\n+  r = &a.a[1];\n+  r = strcpy (r, \"ab\");\n+  if (__builtin_object_size (r, 0)\n+      != sizeof (a) - __builtin_offsetof (struct A, a) - 1)\n+    abort ();\n+  r = strcpy (r + 2, \"cd\") + 2;\n+  if (__builtin_object_size (r, 0)\n+      != sizeof (a) - __builtin_offsetof (struct A, a) - 5)\n+    abort ();\n+  if (__builtin_object_size (exta, 0) != (size_t) -1)\n+    abort ();\n+  if (__builtin_object_size (exta + 10, 0) != (size_t) -1)\n+    abort ();\n+  if (__builtin_object_size (&exta[5], 0) != (size_t) -1)\n+    abort ();\n+  if (__builtin_object_size (extb, 0) != sizeof (extb))\n+    abort ();\n+  if (__builtin_object_size (extb + 10, 0) != sizeof (extb) - 10)\n+    abort ();\n+  if (__builtin_object_size (&extb[5], 0) != sizeof (extb) - 5)\n+    abort ();\n+  if (__builtin_object_size (var, 0) != (size_t) -1)\n+    abort ();\n+  if (__builtin_object_size (var + 10, 0) != (size_t) -1)\n+    abort ();\n+  if (__builtin_object_size (&var[5], 0) != (size_t) -1)\n+    abort ();\n+  if (__builtin_object_size (zerol, 0) != 0)\n+    abort ();\n+  if (__builtin_object_size (&zerol, 0) != 0)\n+    abort ();\n+  if (__builtin_object_size (&zerol[0], 0) != 0)\n+    abort ();\n+  if (__builtin_object_size (zerol[0].a, 0) != 0)\n+    abort ();\n+  if (__builtin_object_size (&zerol[0].a[0], 0) != 0)\n+    abort ();\n+  if (__builtin_object_size (&zerol[0].b, 0) != 0)\n+    abort ();\n+  if (__builtin_object_size (\"abcdefg\", 0) != sizeof (\"abcdefg\"))\n+    abort ();\n+  if (__builtin_object_size (\"abcd\\0efg\", 0) != sizeof (\"abcd\\0efg\"))\n+    abort ();\n+  if (__builtin_object_size (&\"abcd\\0efg\", 0) != sizeof (\"abcd\\0efg\"))\n+    abort ();\n+  if (__builtin_object_size (&\"abcd\\0efg\"[0], 0) != sizeof (\"abcd\\0efg\"))\n+    abort ();\n+  if (__builtin_object_size (&\"abcd\\0efg\"[4], 0) != sizeof (\"abcd\\0efg\") - 4)\n+    abort ();\n+  if (__builtin_object_size (\"abcd\\0efg\" + 5, 0) != sizeof (\"abcd\\0efg\") - 5)\n+    abort ();\n+  if (__builtin_object_size (L\"abcdefg\", 0) != sizeof (L\"abcdefg\"))\n+    abort ();\n+  r = (char *) L\"abcd\\0efg\";\n+  if (__builtin_object_size (r + 2, 0) != sizeof (L\"abcd\\0efg\") - 2)\n+    abort ();\n+}\n+\n+size_t l1 = 1;\n+\n+void\n+__attribute__ ((noinline))\n+test2 (void)\n+{\n+  struct B { char buf1[10]; char buf2[10]; } a;\n+  char *r, buf3[20];\n+  int i;\n+\n+  if (sizeof (a) != 20)\n+    return;\n+\n+  r = buf3;\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[1];\n+      else if (i == l1)\n+\tr = &a.buf2[7];\n+      else if (i == l1 + 1)\n+\tr = &buf3[5];\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[9];\n+    }\n+  if (__builtin_object_size (r, 0) != 20)\n+    abort ();\n+  r = &buf3[20];\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[7];\n+      else if (i == l1)\n+\tr = &a.buf2[7];\n+      else if (i == l1 + 1)\n+\tr = &buf3[5];\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[9];\n+    }\n+  if (__builtin_object_size (r, 0) != 15)\n+    abort ();\n+  r += 8;\n+  if (__builtin_object_size (r, 0) != 7)\n+    abort ();\n+  if (__builtin_object_size (r + 6, 0) != 1)\n+    abort ();\n+  r = &buf3[18];\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[9];\n+      else if (i == l1)\n+\tr = &a.buf2[9];\n+      else if (i == l1 + 1)\n+\tr = &buf3[5];\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[4];\n+    }\n+  if (__builtin_object_size (r + 12, 0) != 4)\n+    abort ();\n+}\n+\n+void\n+__attribute__ ((noinline))\n+test3 (void)\n+{\n+  char buf4[10];\n+  struct B { struct A a[2]; struct A b; char c[4]; char d; double e;\n+\t     _Complex double f; } x;\n+  double y;\n+  _Complex double z;\n+  double *dp;\n+\n+  if (__builtin_object_size (buf4, 0) != sizeof (buf4))\n+    abort ();\n+  if (__builtin_object_size (&buf4, 0) != sizeof (buf4))\n+    abort ();\n+  if (__builtin_object_size (&buf4[0], 0) != sizeof (buf4))\n+    abort ();\n+  if (__builtin_object_size (&buf4[1], 0) != sizeof (buf4) - 1)\n+    abort ();\n+  if (__builtin_object_size (&x, 0) != sizeof (x))\n+    abort ();\n+  if (__builtin_object_size (&x.a, 0) != sizeof (x))\n+    abort ();\n+  if (__builtin_object_size (&x.a[0], 0) != sizeof (x))\n+    abort ();\n+  if (__builtin_object_size (&x.a[0].a, 0) != sizeof (x))\n+    abort ();\n+  if (__builtin_object_size (&x.a[0].a[0], 0) != sizeof (x))\n+    abort ();\n+  if (__builtin_object_size (&x.a[0].a[3], 0) != sizeof (x) - 3)\n+    abort ();\n+  if (__builtin_object_size (&x.a[0].b, 0)\n+      != sizeof (x) - __builtin_offsetof (struct A, b))\n+    abort ();\n+  if (__builtin_object_size (&x.a[1].c, 0)\n+      != sizeof (x) - sizeof (struct A) - __builtin_offsetof (struct A, c))\n+    abort ();\n+  if (__builtin_object_size (&x.a[1].c[0], 0)\n+      != sizeof (x) - sizeof (struct A) - __builtin_offsetof (struct A, c))\n+    abort ();\n+  if (__builtin_object_size (&x.a[1].c[3], 0)\n+      != sizeof (x) - sizeof (struct A) - __builtin_offsetof (struct A, c) - 3)\n+    abort ();\n+  if (__builtin_object_size (&x.b, 0)\n+      != sizeof (x) - __builtin_offsetof (struct B, b))\n+    abort ();\n+  if (__builtin_object_size (&x.b.a, 0)\n+      != sizeof (x) - __builtin_offsetof (struct B, b))\n+    abort ();\n+  if (__builtin_object_size (&x.b.a[0], 0)\n+      != sizeof (x) - __builtin_offsetof (struct B, b))\n+    abort ();\n+  if (__builtin_object_size (&x.b.a[3], 0)\n+      != sizeof (x) - __builtin_offsetof (struct B, b) - 3)\n+    abort ();\n+  if (__builtin_object_size (&x.b.b, 0)\n+      != sizeof (x) - __builtin_offsetof (struct B, b)\n+\t - __builtin_offsetof (struct A, b))\n+    abort ();\n+  if (__builtin_object_size (&x.b.c, 0)\n+      != sizeof (x) - __builtin_offsetof (struct B, b)\n+\t - __builtin_offsetof (struct A, c))\n+    abort ();\n+  if (__builtin_object_size (&x.b.c[0], 0)\n+      != sizeof (x) - __builtin_offsetof (struct B, b)\n+\t - __builtin_offsetof (struct A, c))\n+    abort ();\n+  if (__builtin_object_size (&x.b.c[3], 0)\n+      != sizeof (x) - __builtin_offsetof (struct B, b)\n+\t - __builtin_offsetof (struct A, c) - 3)\n+    abort ();\n+  if (__builtin_object_size (&x.c, 0)\n+      != sizeof (x) - __builtin_offsetof (struct B, c))\n+    abort ();\n+  if (__builtin_object_size (&x.c[0], 0)\n+      != sizeof (x) - __builtin_offsetof (struct B, c))\n+    abort ();\n+  if (__builtin_object_size (&x.c[1], 0)\n+      != sizeof (x) - __builtin_offsetof (struct B, c) - 1)\n+    abort ();\n+  if (__builtin_object_size (&x.d, 0)\n+      != sizeof (x) - __builtin_offsetof (struct B, d))\n+    abort ();\n+  if (__builtin_object_size (&x.e, 0)\n+      != sizeof (x) - __builtin_offsetof (struct B, e))\n+    abort ();\n+  if (__builtin_object_size (&x.f, 0)\n+      != sizeof (x) - __builtin_offsetof (struct B, f))\n+    abort ();\n+  dp = &__real__ x.f;\n+  if (__builtin_object_size (dp, 0)\n+      != sizeof (x) - __builtin_offsetof (struct B, f))\n+    abort ();\n+  dp = &__imag__ x.f;\n+  if (__builtin_object_size (dp, 0)\n+      != sizeof (x) - __builtin_offsetof (struct B, f)\n+\t - sizeof (x.f) / 2)\n+    abort ();\n+  dp = &y;\n+  if (__builtin_object_size (dp, 0) != sizeof (y))\n+    abort ();\n+  if (__builtin_object_size (&z, 0) != sizeof (z))\n+    abort ();\n+  dp = &__real__ z;\n+  if (__builtin_object_size (dp, 0) != sizeof (z))\n+    abort ();\n+  dp = &__imag__ z;\n+  if (__builtin_object_size (dp, 0) != sizeof (z) / 2)\n+    abort ();\n+}\n+\n+struct S { unsigned int a; };\n+\n+char *\n+__attribute__ ((noinline))\n+test4 (char *x, int y)\n+{\n+  register int i;\n+  struct A *p;\n+\n+  for (i = 0; i < y; i++)\n+    {\n+      p = (struct A *) x;\n+      x = (char *) &p[1];\n+      if (__builtin_object_size (p, 0) != (size_t) -1)\n+\tabort ();\n+    }\n+  return x;\n+}\n+\n+void\n+__attribute__ ((noinline))\n+test5 (size_t x)\n+{\n+  char buf[64];\n+  char *p = &buf[8];\n+  size_t i;\n+\n+  for (i = 0; i < x; ++i)\n+    p = p + 4;\n+  /* My understanding of ISO C99 6.5.6 is that a conforming\n+     program will not end up with p equal to &buf[0]\n+     through &buf[7], i.e. calling this function with say\n+     UINTPTR_MAX / 4 results in undefined behaviour.\n+     If that's true, then the maximum number of remaining\n+     bytes from p until end of the object is 56, otherwise\n+     it would be 64 (or conservative (size_t) -1 == unknown).  */\n+  if (__builtin_object_size (p, 0) != sizeof (buf) - 8)\n+    abort ();\n+  memset (p, ' ', sizeof (buf) - 8 - 4 * 4);\n+}\n+\n+void\n+__attribute__ ((noinline))\n+test6 (size_t x)\n+{\n+  struct T { char buf[64]; char buf2[64]; } t;\n+  char *p = &t.buf[8];\n+  size_t i;\n+\n+  for (i = 0; i < x; ++i)\n+    p = p + 4;\n+  if (__builtin_object_size (p, 0) != sizeof (t) - 8)\n+    abort ();\n+  memset (p, ' ', sizeof (t) - 8 - 4 * 4);\n+}\n+\n+void\n+__attribute__ ((noinline))\n+test7 (void)\n+{\n+  char buf[64];\n+  struct T { char buf[64]; char buf2[64]; } t;\n+  char *p = &buf[64], *q = &t.buf[64];\n+\n+  if (__builtin_object_size (p + 64, 0) != 0)\n+    abort ();\n+  if (__builtin_object_size (q + 63, 0) != sizeof (t) - 64 - 63)\n+    abort ();\n+  if (__builtin_object_size (q + 64, 0) != sizeof (t) - 64 - 64)\n+    abort ();\n+  if (__builtin_object_size (q + 256, 0) != 0)\n+    abort ();\n+}\n+\n+void\n+__attribute__ ((noinline))\n+test8 (void)\n+{\n+  struct T { char buf[10]; char buf2[10]; } t;\n+  char *p = &t.buf2[-4];\n+  char *q = &t.buf2[0];\n+  if (__builtin_object_size (p, 0) != sizeof (t) - 10 + 4)\n+    abort ();\n+  if (__builtin_object_size (q, 0) != sizeof (t) - 10)\n+    abort ();\n+  /* GCC only handles additions, not subtractions.  */\n+  q = q - 8;\n+  if (__builtin_object_size (q, 0) != (size_t) -1\n+      && __builtin_object_size (q, 0) != sizeof (t) - 10 + 8)\n+    abort ();\n+  p = &t.buf[-4];\n+  if (__builtin_object_size (p, 0) != 0)\n+    abort ();\n+}\n+\n+int\n+main (void)\n+{\n+  struct S s[10];\n+  __asm (\"\" : \"=r\" (l1) : \"0\" (l1));\n+  test1 (main, 6);\n+  test2 ();\n+  test3 ();\n+  test4 ((char *) s, 10);\n+  test5 (4);\n+  test6 (4);\n+  test7 ();\n+  test8 ();\n+  exit (0);\n+}"}, {"sha": "4071c2516eec3fd3284b043d2e4edd32b7809289", "filename": "gcc/testsuite/gcc.dg/builtin-object-size-2.c", "status": "added", "additions": 393, "deletions": 0, "changes": 393, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-2.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,393 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern void abort (void);\n+extern void exit (int);\n+extern void *malloc (size_t);\n+extern void *calloc (size_t, size_t);\n+extern void *alloca (size_t);\n+extern void *memcpy (void *, const void *, size_t);\n+extern void *memset (void *, int, size_t);\n+extern char *strcpy (char *, const char *);\n+\n+struct A\n+{\n+  char a[10];\n+  int b;\n+  char c[10];\n+} y, w[4];\n+\n+extern char exta[];\n+extern char extb[30];\n+extern struct A extc[];\n+struct A zerol[0];\n+\n+void\n+__attribute__ ((noinline))\n+test1 (void *q, int x)\n+{\n+  struct A a;\n+  void *p = &a.a[3], *r;\n+  char var[x + 10];\n+  struct A vara[x + 10];\n+  if (x < 0)\n+    r = &a.a[9];\n+  else\n+    r = &a.c[1];\n+  if (__builtin_object_size (p, 1) != sizeof (a.a) - 3)\n+    abort ();\n+  if (__builtin_object_size (&a.c[9], 1)\n+      != sizeof (a.c) - 9)\n+    abort ();\n+  if (__builtin_object_size (q, 1) != (size_t) -1)\n+    abort ();\n+  if (__builtin_object_size (r, 1) != sizeof (a.c) - 1)\n+    abort ();\n+  if (x < 6)\n+    r = &w[2].a[1];\n+  else\n+    r = &a.a[6];\n+  if (__builtin_object_size (&y, 1) != sizeof (y))\n+    abort ();\n+  if (__builtin_object_size (w, 1) != sizeof (w))\n+    abort ();\n+  if (__builtin_object_size (&y.b, 1) != sizeof (a.b))\n+    abort ();\n+  if (__builtin_object_size (r, 1) != sizeof (a.a) - 1)\n+    abort ();\n+  if (x < 20)\n+    r = malloc (30);\n+  else\n+    r = calloc (2, 16);\n+  if (__builtin_object_size (r, 1) != 2 * 16)\n+    abort ();\n+  if (x < 20)\n+    r = malloc (30);\n+  else\n+    r = calloc (2, 14);\n+  if (__builtin_object_size (r, 1) != 30)\n+    abort ();\n+  if (x < 30)\n+    r = malloc (sizeof (a));\n+  else\n+    r = &a.a[3];\n+  if (__builtin_object_size (r, 1) != sizeof (a))\n+    abort ();\n+  r = memcpy (r, \"a\", 2);\n+  if (__builtin_object_size (r, 1) != sizeof (a))\n+    abort ();\n+  r = memcpy (r + 2, \"b\", 2) + 2;\n+  if (__builtin_object_size (r, 1) != sizeof (a) - 4)\n+    abort ();\n+  r = &a.a[4];\n+  r = memset (r, 'a', 2);\n+  if (__builtin_object_size (r, 1) != sizeof (a.a) - 4)\n+    abort ();\n+  r = memset (r + 2, 'b', 2) + 2;\n+  if (__builtin_object_size (r, 1) != sizeof (a.a) - 8)\n+    abort ();\n+  r = &a.a[1];\n+  r = strcpy (r, \"ab\");\n+  if (__builtin_object_size (r, 1) != sizeof (a.a) - 1)\n+    abort ();\n+  r = strcpy (r + 2, \"cd\") + 2;\n+  if (__builtin_object_size (r, 1) != sizeof (a.a) - 5)\n+    abort ();\n+  if (__builtin_object_size (exta, 1) != (size_t) -1)\n+    abort ();\n+  if (__builtin_object_size (exta + 10, 1) != (size_t) -1)\n+    abort ();\n+  if (__builtin_object_size (&exta[5], 1) != (size_t) -1)\n+    abort ();\n+  if (__builtin_object_size (extb, 1) != sizeof (extb))\n+    abort ();\n+  if (__builtin_object_size (extb + 10, 1) != sizeof (extb) - 10)\n+    abort ();\n+  if (__builtin_object_size (&extb[5], 1) != sizeof (extb) - 5)\n+    abort ();\n+  if (__builtin_object_size (extc, 1) != (size_t) -1)\n+    abort ();\n+  if (__builtin_object_size (extc + 10, 1) != (size_t) -1)\n+    abort ();\n+  if (__builtin_object_size (&extc[5], 1) != (size_t) -1)\n+    abort ();\n+  if (__builtin_object_size (&extc->a, 1) != (size_t) -1)\n+    abort ();\n+  if (__builtin_object_size (&(extc + 10)->b, 1) != (size_t) -1)\n+    abort ();\n+  if (__builtin_object_size (&extc[5].c[3], 1) != (size_t) -1)\n+    abort ();\n+  if (__builtin_object_size (var, 1) != (size_t) -1)\n+    abort ();\n+  if (__builtin_object_size (var + 10, 1) != (size_t) -1)\n+    abort ();\n+  if (__builtin_object_size (&var[5], 1) != (size_t) -1)\n+    abort ();\n+  if (__builtin_object_size (vara, 1) != (size_t) -1)\n+    abort ();\n+  if (__builtin_object_size (vara + 10, 1) != (size_t) -1)\n+    abort ();    \n+  if (__builtin_object_size (&vara[5], 1) != (size_t) -1)\n+    abort ();\n+  if (__builtin_object_size (&vara[0].a, 1) != (size_t) -1)\n+    abort ();\n+  if (__builtin_object_size (&vara[10].a[0], 1) != (size_t) -1)\n+    abort ();\n+  if (__builtin_object_size (&vara[5].a[4], 1) != (size_t) -1)\n+    abort ();\n+  if (__builtin_object_size (&vara[5].b, 1) != (size_t) -1)\n+    abort ();\n+  if (__builtin_object_size (&vara[7].c[7], 1) != (size_t) -1)\n+    abort ();\n+  if (__builtin_object_size (zerol, 1) != 0)\n+    abort ();\n+  if (__builtin_object_size (&zerol, 1) != 0)\n+    abort ();\n+  if (__builtin_object_size (&zerol[0], 1) != 0)\n+    abort ();\n+  if (__builtin_object_size (zerol[0].a, 1) != 0)\n+    abort ();\n+  if (__builtin_object_size (&zerol[0].a[0], 1) != 0)\n+    abort ();\n+  if (__builtin_object_size (&zerol[0].b, 1) != 0)\n+    abort ();\n+  if (__builtin_object_size (\"abcdefg\", 1) != sizeof (\"abcdefg\"))\n+    abort ();\n+  if (__builtin_object_size (\"abcd\\0efg\", 1) != sizeof (\"abcd\\0efg\"))\n+    abort ();\n+  if (__builtin_object_size (&\"abcd\\0efg\", 1) != sizeof (\"abcd\\0efg\"))\n+    abort ();\n+  if (__builtin_object_size (&\"abcd\\0efg\"[0], 1) != sizeof (\"abcd\\0efg\"))\n+    abort ();\n+  if (__builtin_object_size (&\"abcd\\0efg\"[4], 1) != sizeof (\"abcd\\0efg\") - 4)\n+    abort ();\n+  if (__builtin_object_size (\"abcd\\0efg\" + 5, 1) != sizeof (\"abcd\\0efg\") - 5)\n+    abort ();\n+  if (__builtin_object_size (L\"abcdefg\", 1) != sizeof (L\"abcdefg\"))\n+    abort ();\n+  r = (char *) L\"abcd\\0efg\";\n+  if (__builtin_object_size (r + 2, 1) != sizeof (L\"abcd\\0efg\") - 2)\n+    abort ();\n+}\n+\n+size_t l1 = 1;\n+\n+void\n+__attribute__ ((noinline))\n+test2 (void)\n+{\n+  struct B { char buf1[10]; char buf2[10]; } a;\n+  char *r, buf3[20];\n+  int i;\n+\n+  if (sizeof (a) != 20)\n+    return;\n+\n+  r = buf3;\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[1];\n+      else if (i == l1)\n+\tr = &a.buf2[7];\n+      else if (i == l1 + 1)\n+\tr = &buf3[5];\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[9];\n+    }\n+  if (__builtin_object_size (r, 1) != sizeof (buf3))\n+    abort ();\n+  r = &buf3[20];\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[7];\n+      else if (i == l1)\n+\tr = &a.buf2[7];\n+      else if (i == l1 + 1)\n+\tr = &buf3[5];\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[9];\n+    }\n+  if (__builtin_object_size (r, 1) != sizeof (buf3) - 5)\n+    abort ();\n+  r += 8;\n+  if (__builtin_object_size (r, 1) != sizeof (buf3) - 13)\n+    abort ();\n+  if (__builtin_object_size (r + 6, 1) != sizeof (buf3) - 19)\n+    abort ();\n+}\n+\n+void\n+__attribute__ ((noinline))\n+test3 (void)\n+{\n+  char buf4[10];\n+  struct B { struct A a[2]; struct A b; char c[4]; char d; double e;\n+\t     _Complex double f; } x;\n+  double y;\n+  _Complex double z;\n+  double *dp;\n+\n+  if (__builtin_object_size (buf4, 1) != sizeof (buf4))\n+    abort ();\n+  if (__builtin_object_size (&buf4, 1) != sizeof (buf4))\n+    abort ();\n+  if (__builtin_object_size (&buf4[0], 1) != sizeof (buf4))\n+    abort ();\n+  if (__builtin_object_size (&buf4[1], 1) != sizeof (buf4) - 1)\n+    abort ();\n+  if (__builtin_object_size (&x, 1) != sizeof (x))\n+    abort ();\n+  if (__builtin_object_size (&x.a, 1) != sizeof (x.a))\n+    abort ();\n+  if (__builtin_object_size (&x.a[0], 1) != sizeof (x.a))\n+    abort ();\n+  if (__builtin_object_size (&x.a[0].a, 1) != sizeof (x.a[0].a))\n+    abort ();\n+  if (__builtin_object_size (&x.a[0].a[0], 1) != sizeof (x.a[0].a))\n+    abort ();\n+  if (__builtin_object_size (&x.a[0].a[3], 1) != sizeof (x.a[0].a) - 3)\n+    abort ();\n+  if (__builtin_object_size (&x.a[0].b, 1) != sizeof (x.a[0].b))\n+    abort ();\n+  if (__builtin_object_size (&x.a[1].c, 1) != sizeof (x.a[1].c))\n+    abort ();\n+  if (__builtin_object_size (&x.a[1].c[0], 1) != sizeof (x.a[1].c))\n+    abort ();\n+  if (__builtin_object_size (&x.a[1].c[3], 1) != sizeof (x.a[1].c) - 3)\n+    abort ();\n+  if (__builtin_object_size (&x.b, 1) != sizeof (x.b))\n+    abort ();\n+  if (__builtin_object_size (&x.b.a, 1) != sizeof (x.b.a))\n+    abort ();\n+  if (__builtin_object_size (&x.b.a[0], 1) != sizeof (x.b.a))\n+    abort ();\n+  if (__builtin_object_size (&x.b.a[3], 1) != sizeof (x.b.a) - 3)\n+    abort ();\n+  if (__builtin_object_size (&x.b.b, 1) != sizeof (x.b.b))\n+    abort ();\n+  if (__builtin_object_size (&x.b.c, 1) != sizeof (x.b.c))\n+    abort ();\n+  if (__builtin_object_size (&x.b.c[0], 1) != sizeof (x.b.c))\n+    abort ();\n+  if (__builtin_object_size (&x.b.c[3], 1) != sizeof (x.b.c) - 3)\n+    abort ();\n+  if (__builtin_object_size (&x.c, 1) != sizeof (x.c))\n+    abort ();\n+  if (__builtin_object_size (&x.c[0], 1) != sizeof (x.c))\n+    abort ();\n+  if (__builtin_object_size (&x.c[1], 1) != sizeof (x.c) - 1)\n+    abort ();\n+  if (__builtin_object_size (&x.d, 1) != sizeof (x.d))\n+    abort ();\n+  if (__builtin_object_size (&x.e, 1) != sizeof (x.e))\n+    abort ();\n+  if (__builtin_object_size (&x.f, 1) != sizeof (x.f))\n+    abort ();\n+  dp = &__real__ x.f;\n+  if (__builtin_object_size (dp, 1) != sizeof (x.f) / 2)\n+    abort ();\n+  dp = &__imag__ x.f;\n+  if (__builtin_object_size (dp, 1) != sizeof (x.f) / 2)\n+    abort ();\n+  dp = &y;\n+  if (__builtin_object_size (dp, 1) != sizeof (y))\n+    abort ();\n+  if (__builtin_object_size (&z, 1) != sizeof (z))\n+      abort ();\n+  dp = &__real__ z;\n+  if (__builtin_object_size (dp, 1) != sizeof (z) / 2)\n+    abort ();\n+  dp = &__imag__ z;\n+  if (__builtin_object_size (dp, 1) != sizeof (z) / 2)\n+    abort ();\n+}\n+\n+struct S { unsigned int a; };\n+\n+char *\n+__attribute__ ((noinline))\n+test4 (char *x, int y)\n+{\n+  register int i;\n+  struct A *p;\n+\n+  for (i = 0; i < y; i++)\n+    {\n+      p = (struct A *) x;\n+      x = (char *) &p[1];\n+      if (__builtin_object_size (p, 1) != (size_t) -1)\n+\tabort ();\n+    }\n+  return x;\n+}\n+\n+void\n+__attribute__ ((noinline))\n+test5 (size_t x)\n+{\n+  struct T { char buf[64]; char buf2[64]; } t;\n+  char *p = &t.buf[8];\n+  size_t i;\n+\n+  for (i = 0; i < x; ++i)\n+    p = p + 4;\n+  if (__builtin_object_size (p, 1) != sizeof (t.buf) - 8)\n+    abort ();\n+  memset (p, ' ', sizeof (t.buf) - 8 - 4 * 4);\n+}\n+\n+void\n+__attribute__ ((noinline))\n+test6 (void)\n+{\n+  char buf[64];\n+  struct T { char buf[64]; char buf2[64]; } t;\n+  char *p = &buf[64], *q = &t.buf[64];\n+\n+  if (__builtin_object_size (p + 64, 1) != 0)\n+    abort ();\n+  if (__builtin_object_size (q + 0, 1) != 0)\n+    abort ();\n+  if (__builtin_object_size (q + 64, 1) != 0)\n+    abort ();\n+}\n+\n+void\n+__attribute__ ((noinline))\n+test7 (void)\n+{\n+  struct T { char buf[10]; char buf2[10]; } t;\n+  char *p = &t.buf2[-4];\n+  char *q = &t.buf2[0];\n+  if (__builtin_object_size (p, 1) != 0)\n+    abort ();\n+  if (__builtin_object_size (q, 1) != sizeof (t.buf2))\n+    abort ();\n+  q = &t.buf[10];\n+  if (__builtin_object_size (q, 1) != 0)\n+    abort ();\n+  q = &t.buf[11];\n+  if (__builtin_object_size (q, 1) != 0)\n+    abort ();\n+  p = &t.buf[-4];\n+  if (__builtin_object_size (p, 1) != 0)\n+    abort ();\n+}\n+\n+int\n+main (void)\n+{\n+  struct S s[10];\n+  __asm (\"\" : \"=r\" (l1) : \"0\" (l1));\n+  test1 (main, 6);\n+  test2 ();\n+  test3 ();\n+  test4 ((char *) s, 10);\n+  test5 (4);\n+  test6 ();\n+  test7 ();\n+  exit (0);\n+}"}, {"sha": "572ecda043615509c02221facb7b2d7d79634f3f", "filename": "gcc/testsuite/gcc.dg/builtin-object-size-3.c", "status": "added", "additions": 446, "deletions": 0, "changes": 446, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-3.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,446 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern void abort (void);\n+extern void exit (int);\n+extern void *malloc (size_t);\n+extern void *calloc (size_t, size_t);\n+extern void *alloca (size_t);\n+extern void *memcpy (void *, const void *, size_t);\n+extern void *memset (void *, int, size_t);\n+extern char *strcpy (char *, const char *);\n+\n+struct A\n+{\n+  char a[10];\n+  int b;\n+  char c[10];\n+} y, w[4];\n+\n+extern char exta[];\n+extern char extb[30];\n+extern struct A zerol[0];\n+\n+void\n+__attribute__ ((noinline))\n+test1 (void *q, int x)\n+{\n+  struct A a;\n+  void *p = &a.a[3], *r;\n+  char var[x + 10];\n+  if (x < 0)\n+    r = &a.a[9];\n+  else\n+    r = &a.c[1];\n+  if (__builtin_object_size (p, 2)\n+      != sizeof (a) - __builtin_offsetof (struct A, a) - 3)\n+    abort ();\n+  if (__builtin_object_size (&a.c[9], 2)\n+      != sizeof (a) - __builtin_offsetof (struct A, c) - 9)\n+    abort ();\n+  if (__builtin_object_size (q, 2) != 0)\n+    abort ();\n+  if (__builtin_object_size (r, 2)\n+      != sizeof (a) - __builtin_offsetof (struct A, c) - 1)\n+    abort ();\n+  if (x < 6)\n+    r = &w[2].a[1];\n+  else\n+    r = &a.a[6];\n+  if (__builtin_object_size (&y, 2)\n+      != sizeof (y))\n+    abort ();\n+  if (__builtin_object_size (w, 2)\n+      != sizeof (w))\n+    abort ();\n+  if (__builtin_object_size (&y.b, 2)\n+      != sizeof (a) - __builtin_offsetof (struct A, b))\n+    abort ();\n+  if (__builtin_object_size (r, 2)\n+      != sizeof (a) - __builtin_offsetof (struct A, a) - 6)\n+    abort ();\n+  if (x < 20)\n+    r = malloc (30);\n+  else\n+    r = calloc (2, 16);\n+  if (__builtin_object_size (r, 2) != 30)\n+    abort ();\n+  if (x < 20)\n+    r = malloc (30);\n+  else\n+    r = calloc (2, 14);\n+  if (__builtin_object_size (r, 2) != 2 * 14)\n+    abort ();\n+  if (x < 30)\n+    r = malloc (sizeof (a));\n+  else\n+    r = &a.a[3];\n+  if (__builtin_object_size (r, 2)\n+      != sizeof (a) - __builtin_offsetof (struct A, a) - 3)\n+    abort ();\n+  r = memcpy (r, \"a\", 2);\n+  if (__builtin_object_size (r, 2)\n+      != sizeof (a) - __builtin_offsetof (struct A, a) - 3)\n+    abort ();\n+  r = memcpy (r + 2, \"b\", 2) + 2;\n+  if (__builtin_object_size (r, 2)\n+      != sizeof (a) - __builtin_offsetof (struct A, a) - 3 - 4)\n+    abort ();\n+  r = &a.a[4];\n+  r = memset (r, 'a', 2);\n+  if (__builtin_object_size (r, 2)\n+      != sizeof (a) - __builtin_offsetof (struct A, a) - 4)\n+    abort ();\n+  r = memset (r + 2, 'b', 2) + 2;\n+  if (__builtin_object_size (r, 2)\n+      != sizeof (a) - __builtin_offsetof (struct A, a) - 8)\n+    abort ();\n+  r = &a.a[1];\n+  r = strcpy (r, \"ab\");\n+  if (__builtin_object_size (r, 2)\n+      != sizeof (a) - __builtin_offsetof (struct A, a) - 1)\n+    abort ();\n+  r = strcpy (r + 2, \"cd\") + 2;\n+  if (__builtin_object_size (r, 2)\n+      != sizeof (a) - __builtin_offsetof (struct A, a) - 5)\n+    abort ();\n+  if (__builtin_object_size (exta, 2) != 0)\n+    abort ();\n+  if (__builtin_object_size (exta + 10, 2) != 0)\n+    abort ();\n+  if (__builtin_object_size (&exta[5], 2) != 0)\n+    abort ();\n+  if (__builtin_object_size (extb, 2) != sizeof (extb))\n+    abort ();\n+  if (__builtin_object_size (extb + 10, 2) != sizeof (extb) - 10)\n+    abort ();\n+  if (__builtin_object_size (&extb[5], 2) != sizeof (extb) - 5)\n+    abort ();\n+  if (__builtin_object_size (var, 2) != 0)\n+    abort ();\n+  if (__builtin_object_size (var + 10, 2) != 0)\n+    abort ();\n+  if (__builtin_object_size (&var[5], 2) != 0)\n+    abort ();\n+  if (__builtin_object_size (zerol, 2) != 0)\n+    abort ();\n+  if (__builtin_object_size (&zerol, 2) != 0)\n+    abort ();\n+  if (__builtin_object_size (&zerol[0], 2) != 0)\n+    abort ();\n+  if (__builtin_object_size (zerol[0].a, 2) != 0)\n+    abort ();\n+  if (__builtin_object_size (&zerol[0].a[0], 2) != 0)\n+    abort ();\n+  if (__builtin_object_size (&zerol[0].b, 2) != 0)\n+    abort ();\n+  if (__builtin_object_size (\"abcdefg\", 2) != sizeof (\"abcdefg\"))\n+    abort ();\n+  if (__builtin_object_size (\"abcd\\0efg\", 2) != sizeof (\"abcd\\0efg\"))\n+    abort ();\n+  if (__builtin_object_size (&\"abcd\\0efg\", 2) != sizeof (\"abcd\\0efg\"))\n+    abort ();\n+  if (__builtin_object_size (&\"abcd\\0efg\"[0], 2) != sizeof (\"abcd\\0efg\"))\n+    abort ();\n+  if (__builtin_object_size (&\"abcd\\0efg\"[4], 2) != sizeof (\"abcd\\0efg\") - 4)\n+    abort ();\n+  if (__builtin_object_size (\"abcd\\0efg\" + 5, 2) != sizeof (\"abcd\\0efg\") - 5)\n+    abort ();\n+  if (__builtin_object_size (L\"abcdefg\", 2) != sizeof (L\"abcdefg\"))\n+    abort ();\n+  r = (char *) L\"abcd\\0efg\";\n+  if (__builtin_object_size (r + 2, 2) != sizeof (L\"abcd\\0efg\") - 2)\n+    abort ();\n+}\n+\n+size_t l1 = 1;\n+\n+void\n+__attribute__ ((noinline))\n+test2 (void)\n+{\n+  struct B { char buf1[10]; char buf2[10]; } a;\n+  char *r, buf3[20];\n+  int i;\n+\n+  if (sizeof (a) != 20)\n+    return;\n+\n+  r = buf3;\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[1];\n+      else if (i == l1)\n+\tr = &a.buf2[7];\n+      else if (i == l1 + 1)\n+\tr = &buf3[5];\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[9];\n+    }\n+  if (__builtin_object_size (r, 2) != 3)\n+    abort ();\n+  r = &buf3[20];\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[7];\n+      else if (i == l1)\n+\tr = &a.buf2[7];\n+      else if (i == l1 + 1)\n+\tr = &buf3[5];\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[9];\n+    }\n+  if (__builtin_object_size (r, 2) != 0)\n+    abort ();\n+  r = &buf3[2];\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[1];\n+      else if (i == l1)\n+\tr = &a.buf1[2];\n+      else if (i == l1 + 1)\n+\tr = &buf3[5];\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[4];\n+    }\n+  if (__builtin_object_size (r, 2) != 15)\n+    abort ();\n+  r += 8;\n+  if (__builtin_object_size (r, 2) != 7)\n+    abort ();\n+  if (__builtin_object_size (r + 6, 2) != 1)\n+    abort ();\n+  r = &buf3[18];\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[9];\n+      else if (i == l1)\n+\tr = &a.buf2[9];\n+      else if (i == l1 + 1)\n+\tr = &buf3[5];\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[4];\n+    }\n+  if (__builtin_object_size (r + 12, 2) != 0)\n+    abort ();\n+}\n+\n+void\n+__attribute__ ((noinline))\n+test3 (void)\n+{\n+  char buf4[10];\n+  struct B { struct A a[2]; struct A b; char c[4]; char d; double e;\n+\t     _Complex double f; } x;\n+  double y;\n+  _Complex double z;\n+  double *dp;\n+\n+  if (__builtin_object_size (buf4, 2) != sizeof (buf4))\n+    abort ();\n+  if (__builtin_object_size (&buf4, 2) != sizeof (buf4))\n+    abort ();\n+  if (__builtin_object_size (&buf4[0], 2) != sizeof (buf4))\n+    abort ();\n+  if (__builtin_object_size (&buf4[1], 2) != sizeof (buf4) - 1)\n+    abort ();\n+  if (__builtin_object_size (&x, 2) != sizeof (x))\n+    abort ();\n+  if (__builtin_object_size (&x.a, 2) != sizeof (x))\n+    abort ();\n+  if (__builtin_object_size (&x.a[0], 2) != sizeof (x))\n+    abort ();\n+  if (__builtin_object_size (&x.a[0].a, 2) != sizeof (x))\n+    abort ();\n+  if (__builtin_object_size (&x.a[0].a[0], 2) != sizeof (x))\n+    abort ();\n+  if (__builtin_object_size (&x.a[0].a[3], 2) != sizeof (x) - 3)\n+    abort ();\n+  if (__builtin_object_size (&x.a[0].b, 2)\n+      != sizeof (x) - __builtin_offsetof (struct A, b))\n+    abort ();\n+  if (__builtin_object_size (&x.a[1].c, 2)\n+      != sizeof (x) - sizeof (struct A) - __builtin_offsetof (struct A, c))\n+    abort ();\n+  if (__builtin_object_size (&x.a[1].c[0], 2)\n+      != sizeof (x) - sizeof (struct A) - __builtin_offsetof (struct A, c))\n+    abort ();\n+  if (__builtin_object_size (&x.a[1].c[3], 2)\n+      != sizeof (x) - sizeof (struct A) - __builtin_offsetof (struct A, c) - 3)\n+    abort ();\n+  if (__builtin_object_size (&x.b, 2)\n+      != sizeof (x) - __builtin_offsetof (struct B, b))\n+    abort ();\n+  if (__builtin_object_size (&x.b.a, 2)\n+      != sizeof (x) - __builtin_offsetof (struct B, b))\n+    abort ();\n+  if (__builtin_object_size (&x.b.a[0], 2)\n+      != sizeof (x) - __builtin_offsetof (struct B, b))\n+    abort ();\n+  if (__builtin_object_size (&x.b.a[3], 2)\n+      != sizeof (x) - __builtin_offsetof (struct B, b) - 3)\n+    abort ();\n+  if (__builtin_object_size (&x.b.b, 2)\n+      != sizeof (x) - __builtin_offsetof (struct B, b)\n+\t - __builtin_offsetof (struct A, b))\n+    abort ();\n+  if (__builtin_object_size (&x.b.c, 2)\n+      != sizeof (x) - __builtin_offsetof (struct B, b)\n+\t - __builtin_offsetof (struct A, c))\n+    abort ();\n+  if (__builtin_object_size (&x.b.c[0], 2)\n+      != sizeof (x) - __builtin_offsetof (struct B, b)\n+\t - __builtin_offsetof (struct A, c))\n+    abort ();\n+  if (__builtin_object_size (&x.b.c[3], 2)\n+      != sizeof (x) - __builtin_offsetof (struct B, b)\n+\t - __builtin_offsetof (struct A, c) - 3)\n+    abort ();\n+  if (__builtin_object_size (&x.c, 2)\n+      != sizeof (x) - __builtin_offsetof (struct B, c))\n+    abort ();\n+  if (__builtin_object_size (&x.c[0], 2)\n+      != sizeof (x) - __builtin_offsetof (struct B, c))\n+    abort ();\n+  if (__builtin_object_size (&x.c[1], 2)\n+      != sizeof (x) - __builtin_offsetof (struct B, c) - 1)\n+    abort ();\n+  if (__builtin_object_size (&x.d, 2)\n+      != sizeof (x) - __builtin_offsetof (struct B, d))\n+    abort ();\n+  if (__builtin_object_size (&x.e, 2)\n+      != sizeof (x) - __builtin_offsetof (struct B, e))\n+    abort ();\n+  if (__builtin_object_size (&x.f, 2)\n+      != sizeof (x) - __builtin_offsetof (struct B, f))\n+    abort ();\n+  dp = &__real__ x.f;\n+  if (__builtin_object_size (dp, 2)\n+      != sizeof (x) - __builtin_offsetof (struct B, f))\n+    abort ();\n+  dp = &__imag__ x.f;\n+  if (__builtin_object_size (dp, 2)\n+      != sizeof (x) - __builtin_offsetof (struct B, f)\n+\t - sizeof (x.f) / 2)\n+    abort ();\n+  dp = &y;\n+  if (__builtin_object_size (dp, 2) != sizeof (y))\n+    abort ();\n+  if (__builtin_object_size (&z, 2) != sizeof (z))\n+    abort ();\n+  dp = &__real__ z;\n+  if (__builtin_object_size (dp, 2) != sizeof (z))\n+    abort ();\n+  dp = &__imag__ z;\n+  if (__builtin_object_size (dp, 2) != sizeof (z) / 2)\n+    abort ();\n+}\n+\n+struct S { unsigned int a; };\n+\n+char *\n+__attribute__ ((noinline))\n+test4 (char *x, int y)\n+{\n+  register int i;\n+  struct A *p;\n+\n+  for (i = 0; i < y; i++)\n+    {\n+      p = (struct A *) x;\n+      x = (char *) &p[1];\n+      if (__builtin_object_size (p, 2) != 0)\n+\tabort ();\n+    }\n+  return x;\n+}\n+\n+void\n+__attribute__ ((noinline))\n+test5 (size_t x)\n+{\n+  char buf[64];\n+  char *p = &buf[8];\n+  size_t i;\n+\n+  for (i = 0; i < x; ++i)\n+    p = p + 4;\n+  if (__builtin_object_size (p, 2) != 0)\n+    abort ();\n+  memset (p, ' ', sizeof (buf) - 8 - 4 * 4);\n+}\n+\n+void\n+__attribute__ ((noinline))\n+test6 (size_t x)\n+{\n+  struct T { char buf[64]; char buf2[64]; } t;\n+  char *p = &t.buf[8];\n+  size_t i;\n+\n+  for (i = 0; i < x; ++i)\n+    p = p + 4;\n+  if (__builtin_object_size (p, 2) != 0)\n+    abort ();\n+  memset (p, ' ', sizeof (t) - 8 - 4 * 4);\n+}\n+\n+void\n+__attribute__ ((noinline))\n+test7 (void)\n+{\n+  char buf[64];\n+  struct T { char buf[64]; char buf2[64]; } t;\n+  char *p = &buf[64], *q = &t.buf[64];\n+\n+  if (__builtin_object_size (p + 64, 2) != 0)\n+    abort ();\n+  if (__builtin_object_size (q + 63, 2) != sizeof (t) - 64 - 63)\n+    abort ();\n+  if (__builtin_object_size (q + 64, 2) != sizeof (t) - 64 - 64)\n+    abort ();\n+  if (__builtin_object_size (q + 256, 2) != 0)\n+    abort ();\n+}\n+\n+void\n+__attribute__ ((noinline))\n+test8 (void)\n+{\n+  struct T { char buf[10]; char buf2[10]; } t;\n+  char *p = &t.buf2[-4];\n+  char *q = &t.buf2[0];\n+  if (__builtin_object_size (p, 2) != sizeof (t) - 10 + 4)\n+    abort ();\n+  if (__builtin_object_size (q, 2) != sizeof (t) - 10)\n+    abort ();\n+  /* GCC only handles additions, not subtractions.  */\n+  q = q - 8;\n+  if (__builtin_object_size (q, 2) != 0\n+      && __builtin_object_size (q, 2) != sizeof (t) - 10 + 8)\n+    abort ();\n+  p = &t.buf[-4];\n+  if (__builtin_object_size (p, 2) != 0)\n+    abort ();\n+}\n+\n+int\n+main (void)\n+{\n+  struct S s[10];\n+  __asm (\"\" : \"=r\" (l1) : \"0\" (l1));\n+  test1 (main, 6);\n+  test2 ();\n+  test3 ();\n+  test4 ((char *) s, 10);\n+  test5 (4);\n+  test6 (4);\n+  test7 ();\n+  test8 ();\n+  exit (0);\n+}"}, {"sha": "453c2d01921643691118c6dde18704e99ffe1a94", "filename": "gcc/testsuite/gcc.dg/builtin-object-size-4.c", "status": "added", "additions": 407, "deletions": 0, "changes": 407, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-4.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,407 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern void abort (void);\n+extern void exit (int);\n+extern void *malloc (size_t);\n+extern void *calloc (size_t, size_t);\n+extern void *alloca (size_t);\n+extern void *memcpy (void *, const void *, size_t);\n+extern void *memset (void *, int, size_t);\n+extern char *strcpy (char *, const char *);\n+\n+struct A\n+{\n+  char a[10];\n+  int b;\n+  char c[10];\n+} y, w[4];\n+\n+extern char exta[];\n+extern char extb[30];\n+extern struct A extc[];\n+struct A zerol[0];\n+\n+void\n+__attribute__ ((noinline))\n+test1 (void *q, int x)\n+{\n+  struct A a;\n+  void *p = &a.a[3], *r;\n+  char var[x + 10];\n+  struct A vara[x + 10];\n+  if (x < 0)\n+    r = &a.a[9];\n+  else\n+    r = &a.c[1];\n+  if (__builtin_object_size (p, 3) != sizeof (a.a) - 3)\n+    abort ();\n+  if (__builtin_object_size (&a.c[9], 3)\n+      != sizeof (a.c) - 9)\n+    abort ();\n+  if (__builtin_object_size (q, 3) != 0)\n+    abort ();\n+  if (__builtin_object_size (r, 3) != sizeof (a.a) - 9)\n+    abort ();\n+  if (x < 6)\n+    r = &w[2].a[1];\n+  else\n+    r = &a.a[6];\n+  if (__builtin_object_size (&y, 3) != sizeof (y))\n+    abort ();\n+  if (__builtin_object_size (w, 3) != sizeof (w))\n+    abort ();\n+  if (__builtin_object_size (&y.b, 3) != sizeof (a.b))\n+    abort ();\n+  if (__builtin_object_size (r, 3) != sizeof (a.a) - 6)\n+    abort ();\n+  if (x < 20)\n+    r = malloc (30);\n+  else\n+    r = calloc (2, 16);\n+  if (__builtin_object_size (r, 3) != 30)\n+    abort ();\n+  if (x < 20)\n+    r = malloc (30);\n+  else\n+    r = calloc (2, 14);\n+  if (__builtin_object_size (r, 3) != 2 * 14)\n+    abort ();\n+  if (x < 30)\n+    r = malloc (sizeof (a));\n+  else\n+    r = &a.a[3];\n+  if (__builtin_object_size (r, 3) != sizeof (a.a) - 3)\n+    abort ();\n+  r = memcpy (r, \"a\", 2);\n+  if (__builtin_object_size (r, 3) != sizeof (a.a) - 3)\n+    abort ();\n+  r = memcpy (r + 2, \"b\", 2) + 2;\n+  if (__builtin_object_size (r, 3) != sizeof (a.a) - 3 - 4)\n+    abort ();\n+  r = &a.a[4];\n+  r = memset (r, 'a', 2);\n+  if (__builtin_object_size (r, 3) != sizeof (a.a) - 4)\n+    abort ();\n+  r = memset (r + 2, 'b', 2) + 2;\n+  if (__builtin_object_size (r, 3) != sizeof (a.a) - 8)\n+    abort ();\n+  r = &a.a[1];\n+  r = strcpy (r, \"ab\");\n+  if (__builtin_object_size (r, 3) != sizeof (a.a) - 1)\n+    abort ();\n+  r = strcpy (r + 2, \"cd\") + 2;\n+  if (__builtin_object_size (r, 3) != sizeof (a.a) - 5)\n+    abort ();\n+  if (__builtin_object_size (exta, 3) != 0)\n+    abort ();\n+  if (__builtin_object_size (exta + 10, 3) != 0)\n+    abort ();\n+  if (__builtin_object_size (&exta[5], 3) != 0)\n+    abort ();\n+  if (__builtin_object_size (extb, 3) != sizeof (extb))\n+    abort ();\n+  if (__builtin_object_size (extb + 10, 3) != sizeof (extb) - 10)\n+    abort ();\n+  if (__builtin_object_size (&extb[5], 3) != sizeof (extb) - 5)\n+    abort ();\n+  if (__builtin_object_size (extc, 3) != 0)\n+    abort ();\n+  if (__builtin_object_size (extc + 10, 3) != 0)\n+    abort ();\n+  if (__builtin_object_size (&extc[5], 3) != 0)\n+    abort ();\n+  if (__builtin_object_size (&extc->a, 3) != 0)\n+    abort ();\n+  if (__builtin_object_size (&(extc + 10)->b, 3) != 0)\n+    abort ();\n+  if (__builtin_object_size (&extc[5].c[3], 3) != 0)\n+    abort ();\n+  if (__builtin_object_size (var, 3) != 0)\n+    abort ();\n+  if (__builtin_object_size (var + 10, 3) != 0)\n+    abort ();\n+  if (__builtin_object_size (&var[5], 3) != 0)\n+    abort ();\n+  if (__builtin_object_size (vara, 3) != 0)\n+    abort ();\n+  if (__builtin_object_size (vara + 10, 3) != 0)\n+    abort ();    \n+  if (__builtin_object_size (&vara[5], 3) != 0)\n+    abort ();\n+  if (__builtin_object_size (&vara[0].a, 3) != 0)\n+    abort ();\n+  if (__builtin_object_size (&vara[10].a[0], 3) != 0)\n+    abort ();\n+  if (__builtin_object_size (&vara[5].a[4], 3) != 0)\n+    abort ();\n+  if (__builtin_object_size (&vara[5].b, 3) != 0)\n+    abort ();\n+  if (__builtin_object_size (&vara[7].c[7], 3) != 0)\n+    abort ();\n+  if (__builtin_object_size (zerol, 3) != 0)\n+    abort ();\n+  if (__builtin_object_size (&zerol, 3) != 0)\n+    abort ();\n+  if (__builtin_object_size (&zerol[0], 3) != 0)\n+    abort ();\n+  if (__builtin_object_size (zerol[0].a, 3) != 0)\n+    abort ();\n+  if (__builtin_object_size (&zerol[0].a[0], 3) != 0)\n+    abort ();\n+  if (__builtin_object_size (&zerol[0].b, 3) != 0)\n+    abort ();\n+  if (__builtin_object_size (\"abcdefg\", 3) != sizeof (\"abcdefg\"))\n+    abort ();\n+  if (__builtin_object_size (\"abcd\\0efg\", 3) != sizeof (\"abcd\\0efg\"))\n+    abort ();\n+  if (__builtin_object_size (&\"abcd\\0efg\", 3) != sizeof (\"abcd\\0efg\"))\n+    abort ();\n+  if (__builtin_object_size (&\"abcd\\0efg\"[0], 3) != sizeof (\"abcd\\0efg\"))\n+    abort ();\n+  if (__builtin_object_size (&\"abcd\\0efg\"[4], 3) != sizeof (\"abcd\\0efg\") - 4)\n+    abort ();\n+  if (__builtin_object_size (\"abcd\\0efg\" + 5, 3) != sizeof (\"abcd\\0efg\") - 5)\n+    abort ();\n+  if (__builtin_object_size (L\"abcdefg\", 3) != sizeof (L\"abcdefg\"))\n+    abort ();\n+  r = (char *) L\"abcd\\0efg\";\n+  if (__builtin_object_size (r + 2, 3) != sizeof (L\"abcd\\0efg\") - 2)\n+    abort ();\n+}\n+\n+size_t l1 = 1;\n+\n+void\n+__attribute__ ((noinline))\n+test2 (void)\n+{\n+  struct B { char buf1[10]; char buf2[10]; } a;\n+  char *r, buf3[20];\n+  int i;\n+\n+  if (sizeof (a) != 20)\n+    return;\n+\n+  r = buf3;\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[1];\n+      else if (i == l1)\n+\tr = &a.buf2[7];\n+      else if (i == l1 + 1)\n+\tr = &buf3[5];\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[9];\n+    }\n+  if (__builtin_object_size (r, 3) != sizeof (a.buf1) - 9)\n+    abort ();\n+  r = &buf3[20];\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[7];\n+      else if (i == l1)\n+\tr = &a.buf2[7];\n+      else if (i == l1 + 1)\n+\tr = &buf3[5];\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[9];\n+    }\n+  if (__builtin_object_size (r, 3) != 0)\n+    abort ();\n+  r = &buf3[1];\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if (i == l1 - 1)\n+\tr = &a.buf1[6];\n+      else if (i == l1)\n+\tr = &a.buf2[4];\n+      else if (i == l1 + 1)\n+\tr = &buf3[5];\n+      else if (i == l1 + 2)\n+\tr = &a.buf1[2];\n+    }\n+  if (__builtin_object_size (r, 3) != sizeof (a.buf1) - 6)\n+    abort ();\n+  r += 2;\n+  if (__builtin_object_size (r, 3) != sizeof (a.buf1) - 6 - 2)\n+    abort ();\n+  if (__builtin_object_size (r + 1, 3) != sizeof (a.buf1) - 6 - 3)\n+    abort ();\n+}\n+\n+void\n+__attribute__ ((noinline))\n+test3 (void)\n+{\n+  char buf4[10];\n+  struct B { struct A a[2]; struct A b; char c[4]; char d; double e;\n+\t     _Complex double f; } x;\n+  double y;\n+  _Complex double z;\n+  double *dp;\n+\n+  if (__builtin_object_size (buf4, 3) != sizeof (buf4))\n+    abort ();\n+  if (__builtin_object_size (&buf4, 3) != sizeof (buf4))\n+    abort ();\n+  if (__builtin_object_size (&buf4[0], 3) != sizeof (buf4))\n+    abort ();\n+  if (__builtin_object_size (&buf4[1], 3) != sizeof (buf4) - 1)\n+    abort ();\n+  if (__builtin_object_size (&x, 3) != sizeof (x))\n+    abort ();\n+  if (__builtin_object_size (&x.a, 3) != sizeof (x.a))\n+    abort ();\n+  if (__builtin_object_size (&x.a[0], 3) != sizeof (x.a))\n+    abort ();\n+  if (__builtin_object_size (&x.a[0].a, 3) != sizeof (x.a[0].a))\n+    abort ();\n+  if (__builtin_object_size (&x.a[0].a[0], 3) != sizeof (x.a[0].a))\n+    abort ();\n+  if (__builtin_object_size (&x.a[0].a[3], 3) != sizeof (x.a[0].a) - 3)\n+    abort ();\n+  if (__builtin_object_size (&x.a[0].b, 3) != sizeof (x.a[0].b))\n+    abort ();\n+  if (__builtin_object_size (&x.a[1].c, 3) != sizeof (x.a[1].c))\n+    abort ();\n+  if (__builtin_object_size (&x.a[1].c[0], 3) != sizeof (x.a[1].c))\n+    abort ();\n+  if (__builtin_object_size (&x.a[1].c[3], 3) != sizeof (x.a[1].c) - 3)\n+    abort ();\n+  if (__builtin_object_size (&x.b, 3) != sizeof (x.b))\n+    abort ();\n+  if (__builtin_object_size (&x.b.a, 3) != sizeof (x.b.a))\n+    abort ();\n+  if (__builtin_object_size (&x.b.a[0], 3) != sizeof (x.b.a))\n+    abort ();\n+  if (__builtin_object_size (&x.b.a[3], 3) != sizeof (x.b.a) - 3)\n+    abort ();\n+  if (__builtin_object_size (&x.b.b, 3) != sizeof (x.b.b))\n+    abort ();\n+  if (__builtin_object_size (&x.b.c, 3) != sizeof (x.b.c))\n+    abort ();\n+  if (__builtin_object_size (&x.b.c[0], 3) != sizeof (x.b.c))\n+    abort ();\n+  if (__builtin_object_size (&x.b.c[3], 3) != sizeof (x.b.c) - 3)\n+    abort ();\n+  if (__builtin_object_size (&x.c, 3) != sizeof (x.c))\n+    abort ();\n+  if (__builtin_object_size (&x.c[0], 3) != sizeof (x.c))\n+    abort ();\n+  if (__builtin_object_size (&x.c[1], 3) != sizeof (x.c) - 1)\n+    abort ();\n+  if (__builtin_object_size (&x.d, 3) != sizeof (x.d))\n+    abort ();\n+  if (__builtin_object_size (&x.e, 3) != sizeof (x.e))\n+    abort ();\n+  if (__builtin_object_size (&x.f, 3) != sizeof (x.f))\n+    abort ();\n+  dp = &__real__ x.f;\n+  if (__builtin_object_size (dp, 3) != sizeof (x.f) / 2)\n+    abort ();\n+  dp = &__imag__ x.f;\n+  if (__builtin_object_size (dp, 3) != sizeof (x.f) / 2)\n+    abort ();\n+  dp = &y;\n+  if (__builtin_object_size (dp, 3) != sizeof (y))\n+    abort ();\n+  if (__builtin_object_size (&z, 3) != sizeof (z))\n+      abort ();\n+  dp = &__real__ z;\n+  if (__builtin_object_size (dp, 3) != sizeof (z) / 2)\n+    abort ();\n+  dp = &__imag__ z;\n+  if (__builtin_object_size (dp, 3) != sizeof (z) / 2)\n+    abort ();\n+}\n+\n+struct S { unsigned int a; };\n+\n+char *\n+__attribute__ ((noinline))\n+test4 (char *x, int y)\n+{\n+  register int i;\n+  struct A *p;\n+\n+  for (i = 0; i < y; i++)\n+    {\n+      p = (struct A *) x;\n+      x = (char *) &p[1];\n+      if (__builtin_object_size (p, 3) != 0)\n+\tabort ();\n+    }\n+  return x;\n+}\n+\n+void\n+__attribute__ ((noinline))\n+test5 (size_t x)\n+{\n+  struct T { char buf[64]; char buf2[64]; } t;\n+  char *p = &t.buf[8];\n+  size_t i;\n+\n+  for (i = 0; i < x; ++i)\n+    p = p + 4;\n+  if (__builtin_object_size (p, 3) != 0)\n+    abort ();\n+  memset (p, ' ', sizeof (t.buf) - 8 - 4 * 4);\n+}\n+\n+void\n+__attribute__ ((noinline))\n+test6 (void)\n+{\n+  char buf[64];\n+  struct T { char buf[64]; char buf2[64]; } t;\n+  char *p = &buf[64], *q = &t.buf[64];\n+\n+  if (__builtin_object_size (p + 64, 3) != 0)\n+    abort ();\n+  if (__builtin_object_size (q + 0, 3) != 0)\n+    abort ();\n+  if (__builtin_object_size (q + 64, 3) != 0)\n+    abort ();\n+}\n+\n+void\n+__attribute__ ((noinline))\n+test7 (void)\n+{\n+  struct T { char buf[10]; char buf2[10]; } t;\n+  char *p = &t.buf2[-4];\n+  char *q = &t.buf2[0];\n+  if (__builtin_object_size (p, 3) != 0)\n+    abort ();\n+  if (__builtin_object_size (q, 3) != sizeof (t.buf2))\n+    abort ();\n+  q = &t.buf[10];\n+  if (__builtin_object_size (q, 3) != 0)\n+    abort ();\n+  q = &t.buf[11];\n+  if (__builtin_object_size (q, 3) != 0)\n+    abort ();\n+  p = &t.buf[-4];\n+  if (__builtin_object_size (p, 3) != 0)\n+    abort ();\n+}\n+\n+int\n+main (void)\n+{\n+  struct S s[10];\n+  __asm (\"\" : \"=r\" (l1) : \"0\" (l1));\n+  test1 (main, 6);\n+  test2 ();\n+  test3 ();\n+  test4 ((char *) s, 10);\n+  test5 (4);\n+  test6 ();\n+  test7 ();\n+  exit (0);\n+}"}, {"sha": "4cb580ebc9a71561faef8d0042f7264cf5f9661f", "filename": "gcc/testsuite/gcc.dg/builtin-object-size-5.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-5.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do compile { target i?86-*-linux* x86_64-*-linux* } } */\n+/* { dg-options \"-O2\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern void abort (void);\n+extern char buf[0x40000000];\n+\n+void\n+test1 (size_t x)\n+{\n+  char *p = &buf[8];\n+  size_t i;\n+\n+  for (i = 0; i < x; ++i)\n+    p = p + 4;\n+  if (__builtin_object_size (p, 0) != sizeof (buf) - 8)\n+    abort ();\n+}\n+\n+void\n+test2 (size_t x)\n+{\n+  char *p = &buf[8];\n+  size_t i;\n+\n+  for (i = 0; i < x; ++i)\n+    p = p + 4;\n+  if (__builtin_object_size (p, 1) != sizeof (buf) - 8)\n+    abort ();\n+}\n+\n+void\n+test3 (size_t x)\n+{\n+  char *p = &buf[8];\n+  size_t i;\n+\n+  for (i = 0; i < x; ++i)\n+    p = p + 4;\n+  if (__builtin_object_size (p, 2) != 0)\n+    abort ();\n+}\n+\n+void\n+test4 (size_t x)\n+{\n+  char *p = &buf[8];\n+  size_t i;\n+\n+  for (i = 0; i < x; ++i)\n+    p = p + 4;\n+  if (__builtin_object_size (p, 3) != 0)\n+    abort ();\n+}\n+\n+/* { dg-final { scan-assembler-not \"abort\" } } */"}, {"sha": "aaf32884e509857cc6708422c3b7dadfda328a66", "filename": "gcc/testsuite/gcc.dg/builtin-stringop-chk-1.c", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-1.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,113 @@\n+/* Test whether buffer overflow warnings for __*_chk builtins\n+   are emitted properly.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -std=gnu99\" } */\n+\n+extern void abort (void);\n+\n+#include \"../gcc.c-torture/execute/builtins/chk.h\"\n+#include <stdarg.h>\n+\n+volatile void *vx;\n+char buf1[20];\n+int x;\n+\n+void\n+test (int arg, ...)\n+{\n+  char buf2[20];\n+  va_list ap;\n+  char *p = &buf1[10], *q;\n+\n+  memcpy (&buf2[19], \"ab\", 1);\n+  memcpy (&buf2[19], \"ab\", 2); /* { dg-warning \"will always overflow\" \"memcpy\" } */\n+  vx = mempcpy (&buf2[19], \"ab\", 1);\n+  vx = mempcpy (&buf2[19], \"ab\", 2); /* { dg-warning \"will always overflow\" \"mempcpy\" } */\n+  memmove (&buf2[18], &buf1[10], 2);\n+  memmove (&buf2[18], &buf1[10], 3); /* { dg-warning \"will always overflow\" \"memmove\" } */\n+  memset (&buf2[16], 'a', 4);\n+  memset (&buf2[15], 'b', 6); /* { dg-warning \"will always overflow\" \"memset\" } */\n+  strcpy (&buf2[18], \"a\");\n+  strcpy (&buf2[18], \"ab\"); /* { dg-warning \"will always overflow\" \"strcpy\" } */\n+  vx = stpcpy (&buf2[18], \"a\");\n+  vx = stpcpy (&buf2[18], \"ab\"); /* { dg-warning \"will always overflow\" \"stpcpy\" } */\n+  strncpy (&buf2[18], \"a\", 2);\n+  strncpy (&buf2[18], \"a\", 3); /* { dg-warning \"will always overflow\" \"strncpy\" } */\n+  strncpy (&buf2[18], \"abc\", 2);\n+  strncpy (&buf2[18], \"abc\", 3); /* { dg-warning \"will always overflow\" \"strncpy\" } */\n+  memset (buf2, '\\0', sizeof (buf2));\n+  strcat (&buf2[18], \"a\");\n+  memset (buf2, '\\0', sizeof (buf2));\n+  strcat (&buf2[18], \"ab\"); /* { dg-warning \"will always overflow\" \"strcat\" } */\n+  sprintf (&buf2[18], \"%s\", buf1);\n+  sprintf (&buf2[18], \"%s\", \"a\");\n+  sprintf (&buf2[18], \"%s\", \"ab\"); /* { dg-warning \"will always overflow\" \"sprintf\" } */\n+  sprintf (&buf2[18], \"a\");\n+  sprintf (&buf2[18], \"ab\"); /* { dg-warning \"will always overflow\" \"sprintf\" } */\n+  snprintf (&buf2[18], 2, \"%d\", x);\n+  /* N argument to snprintf is the size of the buffer.\n+     Although this particular call wouldn't overflow buf2,\n+     incorrect buffer size was passed to it and therefore\n+     we want a warning and runtime failure.  */\n+  snprintf (&buf2[18], 3, \"%d\", x); /* { dg-warning \"will always overflow\" \"snprintf\" } */\n+  va_start (ap, arg);\n+  vsprintf (&buf2[18], \"a\", ap);\n+  va_end (ap);\n+  va_start (ap, arg);\n+  vsprintf (&buf2[18], \"ab\", ap); /* { dg-warning \"will always overflow\" \"vsprintf\" } */\n+  va_end (ap);\n+  va_start (ap, arg);\n+  vsnprintf (&buf2[18], 2, \"%s\", ap);\n+  va_end (ap);\n+  va_start (ap, arg);\n+  /* See snprintf above.  */\n+  vsnprintf (&buf2[18], 3, \"%s\", ap); /* { dg-warning \"will always overflow\" \"vsnprintf\" } */\n+  va_end (ap);\n+\n+  p = p + 10;\n+  memset (p, 'd', 0);\n+  q = strcpy (p, \"\"); /* { dg-warning \"will always overflow\" \"strcpy\" } */\n+\n+  /* This invokes undefined behaviour, since we are past the end of buf1.  */\n+  p = p + 10;\n+  memset (p, 'd', 1); /* { dg-warning \"will always overflow\" \"memset\" } */\n+\n+  memset (q, 'd', 0);\n+  memset (q, 'd', 1); /* { dg-warning \"will always overflow\" \"memset\" } */\n+  q = q - 10;\n+  memset (q, 'd', 10);\n+}\n+\n+char *str = \"ABCDEFG\";\n+typedef struct { char b[16]; } H;\n+\n+/* Some brown paper bag bugs found in real applications.\n+   This test is here merely for amusement.  */\n+\n+void\n+test2 (const H h)\n+{\n+  char c;\n+  strncpy (&c, str, 3); /* { dg-warning \"will always overflow\" \"strncpy\" } */\n+\n+  struct { char b[4]; } x;\n+  sprintf (x.b, \"%s\", \"ABCD\"); /* { dg-warning \"will always overflow\" \"sprintf\" } */\n+\n+  unsigned int i;\n+  memcpy (&i, &h, sizeof (h)); /* { dg-warning \"will always overflow\" \"memcpy\" } */\n+\n+  unsigned char buf[21];\n+  memset (buf + 16, 0, 8); /* { dg-warning \"will always overflow\" \"memset\" } */\n+\n+  typedef struct { int i, j, k, l; } S;\n+  S *s[3];\n+  memset (s, 0, sizeof (S) * 3); /* { dg-warning \"will always overflow\" \"memset\" } */\n+\n+  struct T { char a[8]; char b[4]; char c[10]; } t;\n+  stpcpy (t.c,\"Testing...\"); /* { dg-warning \"will always overflow\" \"stpcpy\" } */\n+\n+  char b1[7];\n+  char b2[4];\n+  memset (b1, 0, sizeof (b1));\n+  memset (b2, 0, sizeof (b1)); /* { dg-warning \"will always overflow\" \"memset\" } */\n+}"}, {"sha": "adccd0f444d553f08d8995c003928f4f02d2248a", "filename": "gcc/testsuite/gcc.dg/builtin-stringop-chk-2.c", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-2.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,137 @@\n+/* This file was miscompiled by an earlier version of the object size\n+   checking patch.  Object size in one of the memcpy calls was\n+   incorrectly determined to be 0 while it should be (size_t) -1\n+   (== unknown).  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include \"../gcc.c-torture/execute/builtins/chk.h\"\n+   \n+void *bar (int);\n+extern void *malloc (__SIZE_TYPE__);\n+\n+struct A\n+{\n+  int i, j, k;\n+};\n+\n+/* Here all object sizes are not known at compile time.  There\n+   should be no warning, nor any checker functions called.  */\n+\n+void\n+foo (const struct A *x, int y, const unsigned char *z)\n+{\n+  unsigned int b;\n+  unsigned char *c = 0;\n+\n+  b = (x->i & 0xff) == 1 ? 3 : 4;\n+  if (y)\n+    c = bar (x->j * x->k);\n+\n+  const unsigned char *d = z;\n+  unsigned char *e = c;\n+  unsigned char *f = c + x->j * x->k;\n+  int g = 0;\n+\n+  while (e < f)\n+    {\n+      unsigned int h = *d++;\n+\n+      if (h & 128)\n+\t{\n+\t  h = h - 128;\n+\t  g = e + h * b > f;\n+\t  if (g)\n+\t    h = (f - e) / b;\n+\t  if (b < 4)\n+\t    do\n+\t      {\n+\t\tmemcpy (e, d, 3);\n+\t\te += 3;\n+\t      }\n+\t    while (--h);\n+\t  else\n+\t    do\n+\t      {\n+\t\tmemcpy (e, d, 4);\n+\t\te += 4;\n+\t      }\n+\t    while (--h);\n+\t  d += b;\n+\t}\n+      else\n+\t{\n+\t  h *= b;\n+\t  g = e + h > f;\n+\t  if (g)\n+\t    h = f - e;\n+\t  memcpy (e, d, h);\n+\t  e += h;\n+\t  d += h;\n+\t}\n+    }\n+}\n+\n+/* The same routine, slightly modified:\n+   1) c has known size at compile time\n+   2) e += h was changed into e += 16.\n+      GCC could actually through VRP determine that\n+      in e += h is (h >= 0 && h <= 127), thus know\n+      it is pointer addition and not subtraction and\n+      know e's __builtin_object_size (e, 0) is at 512,\n+      but we are not there yet.  */\n+\n+unsigned char *\n+baz (const struct A *x, const unsigned char *z)\n+{\n+  unsigned int b;\n+  unsigned char *c = 0;\n+\n+  b = (x->i & 0xff) == 1 ? 3 : 4;\n+  c = malloc (512);\n+\n+  const unsigned char *d = z;\n+  unsigned char *e = c;\n+  unsigned char *f = c + x->j * x->k;\n+  int g = 0;\n+\n+  while (e < f)\n+    {\n+      unsigned int h = *d++;\n+\n+      if (h & 128)\n+\t{\n+\t  h = h - 128;\n+\t  g = e + h * b > f;\n+\t  if (g)\n+\t    h = (f - e) / b;\n+\t  if (b < 4)\n+\t    do\n+\t      {\n+\t\tmemcpy (e, d, 3);\n+\t\te += 3;\n+\t      }\n+\t    while (--h);\n+\t  else\n+\t    do\n+\t      {\n+\t\tmemcpy (e, d, 513); /* { dg-warning \"will always overflow\" \"memcpy\" } */\n+\t\te += 4;\n+\t      }\n+\t    while (--h);\n+\t  d += b;\n+\t}\n+      else\n+\t{\n+\t  h *= b;\n+\t  g = e + h > f;\n+\t  if (g)\n+\t    h = f - e;\n+\t  memcpy (e, d, h);\n+\t  /* e += h; */\n+\t  e += 16;\n+\t  d += h;\n+\t}\n+    }\n+  return c;\n+}"}, {"sha": "b00c0a656b1dbeeb33bbf098ca75443be16bd729", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-fprintf-1.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-fprintf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-fprintf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-fprintf-1.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-fab\" } */\n+\n+typedef struct { int i; } FILE;\n+FILE *fp;\n+extern int fprintf (FILE *, const char *, ...);\n+volatile int vi0, vi1, vi2, vi3, vi4, vi5, vi6, vi7, vi8, vi9;\n+\n+void test (void)\n+{\n+  vi0 = 0;\n+  fprintf (fp, \"hello\");\n+  vi1 = 0;\n+  fprintf (fp, \"hello\\n\");\n+  vi2 = 0;\n+  fprintf (fp, \"a\");\n+  vi3 = 0;\n+  fprintf (fp, \"\");\n+  vi4 = 0;\n+  fprintf (fp, \"%s\", \"hello\");\n+  vi5 = 0;\n+  fprintf (fp, \"%s\", \"hello\\n\");\n+  vi6 = 0;\n+  fprintf (fp, \"%s\", \"a\");\n+  vi7 = 0;\n+  fprintf (fp, \"%c\", 'x');\n+  vi8 = 0;\n+  fprintf (fp, \"%d%d\", vi0, vi1);\n+  vi9 = 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"vi0.*fwrite.*\\\"hello\\\".*1, 5, fp.*vi1\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi1.*fwrite.*\\\"hello\\\\\\\\n\\\".*1, 6, fp.*vi2\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi2.*fputc.*fp.*vi3\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi3 = 0\\[^\\(\\)\\]*vi4 = 0\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi4.*fwrite.*\\\"hello\\\".*1, 5, fp.*vi5\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi5.*fwrite.*\\\"hello\\\\\\\\n\\\".*1, 6, fp.*vi6\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi6.*fputc.*fp.*vi7\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi7.*fputc.*fp.*vi8\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi8.*fprintf.*fp.*\\\"%d%d\\\".*vi9\" \"fab\"} } */"}, {"sha": "210bedbb415aa09b33279d89b143a48904c95001", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-fprintf-chk-1.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-fprintf-chk-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-fprintf-chk-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-fprintf-chk-1.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-fab\" } */\n+\n+typedef struct { int i; } FILE;\n+FILE *fp;\n+extern int __fprintf_chk (FILE *, int, const char *, ...);\n+volatile int vi0, vi1, vi2, vi3, vi4, vi5, vi6, vi7, vi8, vi9;\n+\n+void test (void)\n+{\n+  vi0 = 0;\n+  __fprintf_chk (fp, 1, \"hello\");\n+  vi1 = 0;\n+  __fprintf_chk (fp, 1, \"hello\\n\");\n+  vi2 = 0;\n+  __fprintf_chk (fp, 1, \"a\");\n+  vi3 = 0;\n+  __fprintf_chk (fp, 1, \"\");\n+  vi4 = 0;\n+  __fprintf_chk (fp, 1, \"%s\", \"hello\");\n+  vi5 = 0;\n+  __fprintf_chk (fp, 1, \"%s\", \"hello\\n\");\n+  vi6 = 0;\n+  __fprintf_chk (fp, 1, \"%s\", \"a\");\n+  vi7 = 0;\n+  __fprintf_chk (fp, 1, \"%c\", 'x');\n+  vi8 = 0;\n+  __fprintf_chk (fp, 1, \"%d%d\", vi0, vi1);\n+  vi9 = 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"vi0.*fwrite.*\\\"hello\\\".*1, 5, fp.*vi1\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi1.*fwrite.*\\\"hello\\\\\\\\n\\\".*1, 6, fp.*vi2\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi2.*fputc.*fp.*vi3\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi3 = 0\\[^\\(\\)\\]*vi4 = 0\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi4.*fwrite.*\\\"hello\\\".*1, 5, fp.*vi5\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi5.*fwrite.*\\\"hello\\\\\\\\n\\\".*1, 6, fp.*vi6\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi6.*fputc.*fp.*vi7\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi7.*fputc.*fp.*vi8\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi8.*__fprintf_chk.*fp.*1.*\\\"%d%d\\\".*vi9\" \"fab\"} } */"}, {"sha": "a98413446bd69214c81dc5645c28ee87a23ae4b9", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-printf-1.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-printf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-printf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-printf-1.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-fab\" } */\n+\n+extern int printf (const char *, ...);\n+volatile int vi0, vi1, vi2, vi3, vi4, vi5, vi6, vi7, vi8, vi9, via;\n+\n+void test (void)\n+{\n+  vi0 = 0;\n+  printf (\"hello\");\n+  vi1 = 0;\n+  printf (\"hello\\n\");\n+  vi2 = 0;\n+  printf (\"a\");\n+  vi3 = 0;\n+  printf (\"\");\n+  vi4 = 0;\n+  printf (\"%s\", \"hello\");\n+  vi5 = 0;\n+  printf (\"%s\", \"hello\\n\");\n+  vi6 = 0;\n+  printf (\"%s\", \"a\");\n+  vi7 = 0;\n+  printf (\"%s\", \"\");\n+  vi8 = 0;\n+  printf (\"%c\", 'x');\n+  vi9 = 0;\n+  printf (\"%s\\n\", \"hello\\n\");\n+  via = 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"vi0.*printf.*\\\"hello\\\".*vi1\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi1.*puts.*\\\"hello\\\".*vi2\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi2.*putchar.*vi3\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi3 = 0\\[^\\(\\)\\]*vi4 = 0\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi4.*printf.*\\\"hello\\\".*vi5\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi5.*puts.*\\\"hello\\\".*vi6\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi6.*putchar.*vi7\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi7 = 0\\[^\\(\\)\\]*vi8 = 0\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi8.*putchar.*vi9\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi9.*puts.*\\\"hello\\\\\\\\n\\\".*via\" \"fab\"} } */"}, {"sha": "532a3f4deada0ccd70294450c1087fee4fd06cb9", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-printf-chk-1.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-printf-chk-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-printf-chk-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-printf-chk-1.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-fab\" } */\n+\n+extern int __printf_chk (int, const char *, ...);\n+volatile int vi0, vi1, vi2, vi3, vi4, vi5, vi6, vi7, vi8, vi9, via;\n+\n+void test (void)\n+{\n+  vi0 = 0;\n+  __printf_chk (1, \"hello\");\n+  vi1 = 0;\n+  __printf_chk (1, \"hello\\n\");\n+  vi2 = 0;\n+  __printf_chk (1, \"a\");\n+  vi3 = 0;\n+  __printf_chk (1, \"\");\n+  vi4 = 0;\n+  __printf_chk (1, \"%s\", \"hello\");\n+  vi5 = 0;\n+  __printf_chk (1, \"%s\", \"hello\\n\");\n+  vi6 = 0;\n+  __printf_chk (1, \"%s\", \"a\");\n+  vi7 = 0;\n+  __printf_chk (1, \"%s\", \"\");\n+  vi8 = 0;\n+  __printf_chk (1, \"%c\", 'x');\n+  vi9 = 0;\n+  __printf_chk (1, \"%s\\n\", \"hello\\n\");\n+  via = 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"vi0.*__printf_chk.*1.*\\\"hello\\\".*vi1\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi1.*puts.*\\\"hello\\\".*vi2\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi2.*putchar.*vi3\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi3 = 0\\[^\\(\\)\\]*vi4 = 0\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi4.*__printf_chk.*1.*\\\"hello\\\".*vi5\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi5.*puts.*\\\"hello\\\".*vi6\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi6.*putchar.*vi7\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi7 = 0\\[^\\(\\)\\]*vi8 = 0\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi8.*putchar.*vi9\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi9.*puts.*\\\"hello\\\\\\\\n\\\".*via\" \"fab\"} } */"}, {"sha": "d82b311600d5ce012c6a34a8d9d2ddcd74ace1a2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-vfprintf-1.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-vfprintf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-vfprintf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-vfprintf-1.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-fab\" } */\n+\n+#include <stdarg.h>\n+\n+typedef struct { int i; } FILE;\n+FILE *fp;\n+extern int vfprintf (FILE *, const char *, va_list);\n+volatile int vi0, vi1, vi2, vi3, vi4, vi5, vi6, vi7, vi8, vi9, via;\n+\n+void\n+test (va_list ap1, va_list ap2, va_list ap3, va_list ap4, va_list ap5,\n+      va_list ap6, va_list ap7)\n+{\n+  vi0 = 0;\n+  vfprintf (fp, \"hello\", ap1);\n+  vi1 = 0;\n+  vfprintf (fp, \"hello\\n\", ap2);\n+  vi2 = 0;\n+  vfprintf (fp, \"a\", ap3);\n+  vi3 = 0;\n+  vfprintf (fp, \"\", ap4);\n+  vi4 = 0;\n+  vfprintf (fp, \"%s\", ap5);\n+  vi5 = 0;\n+  vfprintf (fp, \"%c\", ap6);\n+  vi6 = 0;\n+  vfprintf (fp, \"%s\\n\", ap7);\n+  vi7 = 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"vi0.*fwrite.*\\\"hello\\\".*1, 5, fp.*vi1\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi1.*fwrite.*\\\"hello\\\\\\\\n\\\".*1, 6, fp.*vi2\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi2.*fputc.*fp.*vi3\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi3 = 0\\[^\\(\\)\\]*vi4 = 0\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi4.*vfprintf.*\\\"%s\\\".*vi5\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi5.*vfprintf.*\\\"%c\\\".*vi6\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi6.*vfprintf.*\\\"%s\\\\\\\\n\\\".*vi7\" \"fab\"} } */"}, {"sha": "60a51aa2888b352f934b223d3a7d2b433779c3ba", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-vfprintf-chk-1.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-vfprintf-chk-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-vfprintf-chk-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-vfprintf-chk-1.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-fab\" } */\n+\n+#include <stdarg.h>\n+\n+typedef struct { int i; } FILE;\n+FILE *fp;\n+extern int __vfprintf_chk (FILE *, int, const char *, va_list);\n+volatile int vi0, vi1, vi2, vi3, vi4, vi5, vi6, vi7, vi8, vi9, via;\n+\n+void\n+test (va_list ap1, va_list ap2, va_list ap3, va_list ap4, va_list ap5,\n+      va_list ap6, va_list ap7)\n+{\n+  vi0 = 0;\n+  __vfprintf_chk (fp, 1, \"hello\", ap1);\n+  vi1 = 0;\n+  __vfprintf_chk (fp, 1, \"hello\\n\", ap2);\n+  vi2 = 0;\n+  __vfprintf_chk (fp, 1, \"a\", ap3);\n+  vi3 = 0;\n+  __vfprintf_chk (fp, 1, \"\", ap4);\n+  vi4 = 0;\n+  __vfprintf_chk (fp, 1, \"%s\", ap5);\n+  vi5 = 0;\n+  __vfprintf_chk (fp, 1, \"%c\", ap6);\n+  vi6 = 0;\n+  __vfprintf_chk (fp, 1, \"%s\\n\", ap7);\n+  vi7 = 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"vi0.*fwrite.*\\\"hello\\\".*1, 5, fp.*vi1\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi1.*fwrite.*\\\"hello\\\\\\\\n\\\".*1, 6, fp.*vi2\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi2.*fputc.*fp.*vi3\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi3 = 0\\[^\\(\\)\\]*vi4 = 0\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi4.*__vfprintf_chk.*fp.*1.*\\\"%s\\\".*vi5\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi5.*__vfprintf_chk.*fp.*1.*\\\"%c\\\".*vi6\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi6.*__vfprintf_chk.*fp.*1.*\\\"%s\\\\\\\\n\\\".*vi7\" \"fab\"} } */"}, {"sha": "9518105915dd8a8c2767bb6d9b643d9bdc47c611", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-vprintf-1.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-vprintf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-vprintf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-vprintf-1.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-fab\" } */\n+\n+#include <stdarg.h>\n+\n+extern int vprintf (const char *, va_list);\n+volatile int vi0, vi1, vi2, vi3, vi4, vi5, vi6, vi7, vi8, vi9, via;\n+\n+void\n+test (va_list ap1, va_list ap2, va_list ap3, va_list ap4, va_list ap5,\n+      va_list ap6, va_list ap7)\n+{\n+  vi0 = 0;\n+  vprintf (\"hello\", ap1);\n+  vi1 = 0;\n+  vprintf (\"hello\\n\", ap2);\n+  vi2 = 0;\n+  vprintf (\"a\", ap3);\n+  vi3 = 0;\n+  vprintf (\"\", ap4);\n+  vi4 = 0;\n+  vprintf (\"%s\", ap5);\n+  vi5 = 0;\n+  vprintf (\"%c\", ap6);\n+  vi6 = 0;\n+  vprintf (\"%s\\n\", ap7);\n+  vi7 = 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"vi0.*vprintf.*\\\"hello\\\".*vi1\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi1.*puts.*\\\"hello\\\".*vi2\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi2.*putchar.*vi3\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi3 = 0\\[^\\(\\)\\]*vi4 = 0\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi4.*vprintf.*\\\"%s\\\".*vi5\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi5.*vprintf.*\\\"%c\\\".*vi6\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi6.*vprintf.*\\\"%s\\\\\\\\n\\\".*vi7\" \"fab\"} } */"}, {"sha": "d95e336730ae316d72a6e5d3e3a539a3e8766263", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-vprintf-chk-1.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-vprintf-chk-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-vprintf-chk-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-vprintf-chk-1.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-fab\" } */\n+\n+#include <stdarg.h>\n+\n+extern int __vprintf_chk (int, const char *, va_list);\n+volatile int vi0, vi1, vi2, vi3, vi4, vi5, vi6, vi7, vi8, vi9, via;\n+\n+void\n+test (va_list ap1, va_list ap2, va_list ap3, va_list ap4, va_list ap5,\n+      va_list ap6, va_list ap7)\n+{\n+  vi0 = 0;\n+  __vprintf_chk (1, \"hello\", ap1);\n+  vi1 = 0;\n+  __vprintf_chk (1, \"hello\\n\", ap2);\n+  vi2 = 0;\n+  __vprintf_chk (1, \"a\", ap3);\n+  vi3 = 0;\n+  __vprintf_chk (1, \"\", ap4);\n+  vi4 = 0;\n+  __vprintf_chk (1, \"%s\", ap5);\n+  vi5 = 0;\n+  __vprintf_chk (1, \"%c\", ap6);\n+  vi6 = 0;\n+  __vprintf_chk (1, \"%s\\n\", ap7);\n+  vi7 = 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"vi0.*__vprintf_chk.*1.*\\\"hello\\\".*vi1\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi1.*puts.*\\\"hello\\\".*vi2\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi2.*putchar.*vi3\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi3 = 0\\[^\\(\\)\\]*vi4 = 0\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi4.*__vprintf_chk.*1.*\\\"%s\\\".*vi5\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi5.*__vprintf_chk.*1.*\\\"%c\\\".*vi6\" \"fab\"} } */\n+/* { dg-final { scan-tree-dump \"vi6.*__vprintf_chk.*1.*\\\"%s\\\\\\\\n\\\".*vi7\" \"fab\"} } */"}, {"sha": "2ba11c0b09c872977385bc05348b13e8b3e1ffff", "filename": "gcc/tree-object-size.c", "status": "added", "additions": 1078, "deletions": 0, "changes": 1078, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -0,0 +1,1078 @@\n+/* __builtin_object_size (ptr, object_size_type) computation\n+   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+   Contributed by Jakub Jelinek <jakub@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-pass.h\"\n+#include \"tree-ssa-propagate.h\"\n+\n+struct object_size_info\n+{\n+  int object_size_type;\n+  bitmap visited, reexamine;\n+  int pass;\n+  bool changed;\n+  unsigned int *depths;\n+  unsigned int *stack, *tos;\n+};\n+\n+static unsigned HOST_WIDE_INT unknown[4] = { -1, -1, 0, 0 };\n+\n+static tree compute_object_offset (tree, tree);\n+static unsigned HOST_WIDE_INT addr_object_size (tree, int);\n+static unsigned HOST_WIDE_INT alloc_object_size (tree, int);\n+static tree pass_through_call (tree);\n+static void collect_object_sizes_for (struct object_size_info *, tree);\n+static void expr_object_size (struct object_size_info *, tree, tree);\n+static bool merge_object_sizes (struct object_size_info *, tree, tree,\n+\t\t\t\tunsigned HOST_WIDE_INT);\n+static bool plus_expr_object_size (struct object_size_info *, tree, tree);\n+static void compute_object_sizes (void);\n+static void init_offset_limit (void);\n+static void check_for_plus_in_loops (struct object_size_info *, tree);\n+static void check_for_plus_in_loops_1 (struct object_size_info *, tree,\n+\t\t\t\t       unsigned int);\n+\n+/* object_sizes[0] is upper bound for number of bytes till the end of\n+   the object.\n+   object_sizes[1] is upper bound for number of bytes till the end of\n+   the subobject (innermost array or field with address taken).\n+   object_sizes[2] is lower bound for number of bytes till the end of\n+   the object and object_sizes[3] lower bound for subobject.  */\n+static unsigned HOST_WIDE_INT *object_sizes[4];\n+\n+/* Bitmaps what object sizes have been computed already.  */\n+static bitmap computed[4];\n+\n+/* Maximum value of offset we consider to be addition.  */\n+static unsigned HOST_WIDE_INT offset_limit;\n+\n+\n+/* Initialize OFFSET_LIMIT variable.  */\n+static void\n+init_offset_limit (void)\n+{\n+  if (host_integerp (TYPE_MAX_VALUE (sizetype), 1))\n+    offset_limit = tree_low_cst (TYPE_MAX_VALUE (sizetype), 1);\n+  else\n+    offset_limit = -1;\n+  offset_limit /= 2;\n+}\n+\n+\n+/* Compute offset of EXPR within VAR.  Return error_mark_node\n+   if unknown.  */\n+\n+static tree\n+compute_object_offset (tree expr, tree var)\n+{\n+  enum tree_code code = PLUS_EXPR;\n+  tree base, off, t;\n+\n+  if (expr == var)\n+    return size_zero_node;\n+\n+  switch (TREE_CODE (expr))\n+    {\n+    case COMPONENT_REF:\n+      base = compute_object_offset (TREE_OPERAND (expr, 0), var);\n+      if (base == error_mark_node)\n+\treturn base;\n+\n+      t = TREE_OPERAND (expr, 1);\n+      off = size_binop (PLUS_EXPR, DECL_FIELD_OFFSET (t),\n+\t\t\tsize_int (tree_low_cst (DECL_FIELD_BIT_OFFSET (t), 1)\n+\t\t\t\t  / BITS_PER_UNIT));\n+      break;\n+\n+    case REALPART_EXPR:\n+    case NOP_EXPR:\n+    case CONVERT_EXPR:\n+    case VIEW_CONVERT_EXPR:\n+    case NON_LVALUE_EXPR:\n+      return compute_object_offset (TREE_OPERAND (expr, 0), var);\n+\n+    case IMAGPART_EXPR:\n+      base = compute_object_offset (TREE_OPERAND (expr, 0), var);\n+      if (base == error_mark_node)\n+\treturn base;\n+\n+      off = TYPE_SIZE_UNIT (TREE_TYPE (expr));\n+      break;\n+\n+    case ARRAY_REF:\n+      base = compute_object_offset (TREE_OPERAND (expr, 0), var);\n+      if (base == error_mark_node)\n+\treturn base;\n+\n+      t = TREE_OPERAND (expr, 1);\n+      if (TREE_CODE (t) == INTEGER_CST && tree_int_cst_sgn (t) < 0)\n+\t{\n+\t  code = MINUS_EXPR;\n+\t  t = fold_build1 (NEGATE_EXPR, TREE_TYPE (t), t);\n+\t}\n+      t = convert (sizetype, t);\n+      off = size_binop (MULT_EXPR, TYPE_SIZE_UNIT (TREE_TYPE (expr)), t);\n+      break;\n+\n+    default:\n+      return error_mark_node;\n+    }\n+\n+  return size_binop (code, base, off);\n+}\n+\n+\n+/* Compute __builtin_object_size for PTR, which is a ADDR_EXPR.\n+   OBJECT_SIZE_TYPE is the second argument from __builtin_object_size.\n+   If unknown, return unknown[object_size_type].  */\n+\n+static unsigned HOST_WIDE_INT\n+addr_object_size (tree ptr, int object_size_type)\n+{\n+  tree pt_var;\n+\n+  gcc_assert (TREE_CODE (ptr) == ADDR_EXPR);\n+\n+  pt_var = TREE_OPERAND (ptr, 0);\n+  if (REFERENCE_CLASS_P (pt_var))\n+    pt_var = get_base_address (pt_var);\n+\n+  if (pt_var\n+      && (SSA_VAR_P (pt_var) || TREE_CODE (pt_var) == STRING_CST)\n+      && TYPE_SIZE_UNIT (TREE_TYPE (pt_var))\n+      && host_integerp (TYPE_SIZE_UNIT (TREE_TYPE (pt_var)), 1)\n+      && (unsigned HOST_WIDE_INT)\n+\t tree_low_cst (TYPE_SIZE_UNIT (TREE_TYPE (pt_var)), 1) < offset_limit)\n+    {\n+      tree bytes;\n+\n+      if (pt_var != TREE_OPERAND (ptr, 0))\n+\t{\n+\t  tree var;\n+\n+\t  if (object_size_type & 1)\n+\t    {\n+\t      var = TREE_OPERAND (ptr, 0);\n+\n+\t      while (var != pt_var\n+\t\t      && TREE_CODE (var) != BIT_FIELD_REF\n+\t\t      && TREE_CODE (var) != COMPONENT_REF\n+\t\t      && TREE_CODE (var) != ARRAY_REF\n+\t\t      && TREE_CODE (var) != ARRAY_RANGE_REF\n+\t\t      && TREE_CODE (var) != REALPART_EXPR\n+\t\t      && TREE_CODE (var) != IMAGPART_EXPR)\n+\t\tvar = TREE_OPERAND (var, 0);\n+\t      if (var != pt_var && TREE_CODE (var) == ARRAY_REF)\n+\t\tvar = TREE_OPERAND (var, 0);\n+\t      if (! TYPE_SIZE_UNIT (TREE_TYPE (var))\n+\t\t  || ! host_integerp (TYPE_SIZE_UNIT (TREE_TYPE (var)), 1)\n+\t\t  || tree_int_cst_lt (TYPE_SIZE_UNIT (TREE_TYPE (pt_var)),\n+\t\t\t\t      TYPE_SIZE_UNIT (TREE_TYPE (var))))\n+\t\tvar = pt_var;\n+\t    }\n+\t  else\n+\t    var = pt_var;\n+\n+\t  bytes = compute_object_offset (TREE_OPERAND (ptr, 0), var);\n+\t  if (bytes != error_mark_node)\n+\t    {\n+\t      if (TREE_CODE (bytes) == INTEGER_CST\n+\t\t  && tree_int_cst_lt (TYPE_SIZE_UNIT (TREE_TYPE (var)), bytes))\n+\t\tbytes = size_zero_node;\n+\t      else\n+\t\tbytes = size_binop (MINUS_EXPR,\n+\t\t\t\t    TYPE_SIZE_UNIT (TREE_TYPE (var)), bytes);\n+\t    }\n+\t}\n+      else\n+\tbytes = TYPE_SIZE_UNIT (TREE_TYPE (pt_var));\n+\n+      if (host_integerp (bytes, 1))\n+\treturn tree_low_cst (bytes, 1);\n+    }\n+\n+  return unknown[object_size_type];\n+}\n+\n+\n+/* Compute __builtin_object_size for CALL, which is a CALL_EXPR.\n+   Handles various allocation calls.  OBJECT_SIZE_TYPE is the second\n+   argument from __builtin_object_size.  If unknown, return\n+   unknown[object_size_type].  */\n+\n+static unsigned HOST_WIDE_INT\n+alloc_object_size (tree call, int object_size_type)\n+{\n+  tree callee, arglist, a, bytes = NULL_TREE;\n+  unsigned int arg_mask = 0;\n+\n+  gcc_assert (TREE_CODE (call) == CALL_EXPR);\n+\n+  callee = get_callee_fndecl (call);\n+  arglist = TREE_OPERAND (call, 1);\n+  if (callee\n+      && DECL_BUILT_IN_CLASS (callee) == BUILT_IN_NORMAL)\n+    switch (DECL_FUNCTION_CODE (callee))\n+      {\n+      case BUILT_IN_MALLOC:\n+      case BUILT_IN_ALLOCA:\n+\targ_mask = 1;\n+\tbreak;\n+      /*\n+      case BUILT_IN_REALLOC:\n+\targ_mask = 2;\n+\tbreak;\n+\t*/\n+      case BUILT_IN_CALLOC:\n+\targ_mask = 3;\n+\tbreak;\n+      default:\n+\tbreak;\n+      }\n+\n+  for (a = arglist; arg_mask && a; arg_mask >>= 1, a = TREE_CHAIN (a))\n+    if (arg_mask & 1)\n+      {\n+\ttree arg = TREE_VALUE (a);\n+\n+\tif (TREE_CODE (arg) != INTEGER_CST)\n+\t  break;\n+\n+\tif (! bytes)\n+\t  bytes = fold_convert (sizetype, arg);\n+\telse\n+\t  bytes = size_binop (MULT_EXPR, bytes,\n+\t\t\t      fold_convert (sizetype, arg));\n+      }\n+\n+  if (! arg_mask && bytes && host_integerp (bytes, 1))\n+    return tree_low_cst (bytes, 1);\n+\n+  return unknown[object_size_type];\n+}\n+\n+\n+/* If object size is propagated from one of function's arguments directly\n+   to its return value, return that argument for CALL_EXPR CALL.\n+   Otherwise return NULL.  */\n+\n+static tree\n+pass_through_call (tree call)\n+{\n+  tree callee = get_callee_fndecl (call);\n+  tree arglist = TREE_OPERAND (call, 1);\n+\n+  if (callee\n+      && DECL_BUILT_IN_CLASS (callee) == BUILT_IN_NORMAL)\n+    switch (DECL_FUNCTION_CODE (callee))\n+      {\n+      case BUILT_IN_MEMCPY:\n+      case BUILT_IN_MEMMOVE:\n+      case BUILT_IN_MEMSET:\n+      case BUILT_IN_STRCPY:\n+      case BUILT_IN_STRNCPY:\n+      case BUILT_IN_STRCAT:\n+      case BUILT_IN_STRNCAT:\n+      case BUILT_IN_MEMCPY_CHK:\n+      case BUILT_IN_MEMMOVE_CHK:\n+      case BUILT_IN_MEMSET_CHK:\n+      case BUILT_IN_STRCPY_CHK:\n+      case BUILT_IN_STRNCPY_CHK:\n+      case BUILT_IN_STRCAT_CHK:\n+      case BUILT_IN_STRNCAT_CHK:\n+\tif (arglist)\n+\t  return TREE_VALUE (arglist);\n+\tbreak;\n+      default:\n+\tbreak;\n+      }\n+\n+  return NULL_TREE;\n+}\n+\n+\n+/* Compute __builtin_object_size value for PTR.  OBJECT_SIZE_TYPE is the\n+   second argument from __builtin_object_size.  */\n+\n+unsigned HOST_WIDE_INT\n+compute_builtin_object_size (tree ptr, int object_size_type)\n+{\n+  gcc_assert (object_size_type >= 0 && object_size_type <= 3);\n+\n+  if (! offset_limit)\n+    init_offset_limit ();\n+\n+  if (TREE_CODE (ptr) == ADDR_EXPR)\n+    return addr_object_size (ptr, object_size_type);\n+  else if (TREE_CODE (ptr) == CALL_EXPR)\n+    {\n+      tree arg = pass_through_call (ptr);\n+\n+      if (arg)\n+\treturn compute_builtin_object_size (arg, object_size_type);\n+      else\n+\treturn alloc_object_size (ptr, object_size_type);\n+    }\n+  else if (TREE_CODE (ptr) == SSA_NAME\n+\t   && POINTER_TYPE_P (TREE_TYPE (ptr))\n+\t   && object_sizes[object_size_type] != NULL)\n+    {\n+      if (!bitmap_bit_p (computed[object_size_type], SSA_NAME_VERSION (ptr)))\n+\t{\n+\t  struct object_size_info osi;\n+\t  bitmap_iterator bi;\n+\t  unsigned int i;\n+\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"Computing %s %sobject size for \",\n+\t\t       (object_size_type & 2) ? \"minimum\" : \"maximum\",\n+\t\t       (object_size_type & 1) ? \"sub\" : \"\");\n+\t      print_generic_expr (dump_file, ptr, dump_flags);\n+\t      fprintf (dump_file, \":\\n\");\n+\t    }\n+\n+\t  osi.visited = BITMAP_ALLOC (NULL);\n+\t  osi.reexamine = BITMAP_ALLOC (NULL);\n+\t  osi.object_size_type = object_size_type;\n+\t  osi.depths = NULL;\n+\t  osi.stack = NULL;\n+\t  osi.tos = NULL;\n+\n+\t  /* First pass: walk UD chains, compute object sizes that\n+\t     can be computed.  osi.reexamine bitmap at the end will\n+\t     contain what variables were found in dependency cycles\n+\t     and therefore need to be reexamined.  */\n+\t  osi.pass = 0;\n+\t  osi.changed = false;\n+\t  collect_object_sizes_for (&osi, ptr);\n+\n+\t  /* Second pass: keep recomputing object sizes of variables\n+\t     that need reexamination, until no object sizes are\n+\t     increased or all object sizes are computed.  */\n+\t  if (! bitmap_empty_p (osi.reexamine))\n+\t    {\n+\t      bitmap reexamine = BITMAP_ALLOC (NULL);\n+\n+\t      /* If looking for minimum instead of maximum object size,\n+\t\t detect cases where a pointer is increased in a loop.\n+\t\t Although even without this detection pass 2 would eventually\n+\t\t terminate, it could take a long time.  If a pointer is\n+\t\t increasing this way, we need to assume 0 object size.\n+\t\t E.g. p = &buf[0]; while (cond) p = p + 4;  */\n+\t      if (object_size_type & 2)\n+\t\t{\n+\t\t  osi.depths = xcalloc (num_ssa_names, sizeof (unsigned int));\n+\t\t  osi.stack = xmalloc (num_ssa_names * sizeof (unsigned int));\n+\t\t  osi.tos = osi.stack;\n+\t\t  osi.pass = 1;\n+\t\t  /* collect_object_sizes_for is changing\n+\t\t     osi.reexamine bitmap, so iterate over a copy.  */\n+\t\t  bitmap_copy (reexamine, osi.reexamine);\n+\t\t  EXECUTE_IF_SET_IN_BITMAP (reexamine, 0, i, bi)\n+\t\t    if (bitmap_bit_p (osi.reexamine, i))\n+\t\t      check_for_plus_in_loops (&osi, ssa_name (i));\n+\n+\t\t  free (osi.depths);\n+\t\t  osi.depths = NULL;\n+\t\t  free (osi.stack);\n+\t\t  osi.stack = NULL;\n+\t\t  osi.tos = NULL;\n+\t\t}\n+\n+\t      do\n+\t\t{\n+\t\t  osi.pass = 2;\n+\t\t  osi.changed = false;\n+\t\t  /* collect_object_sizes_for is changing\n+\t\t     osi.reexamine bitmap, so iterate over a copy.  */\n+\t\t  bitmap_copy (reexamine, osi.reexamine);\n+\t\t  EXECUTE_IF_SET_IN_BITMAP (reexamine, 0, i, bi)\n+\t\t    if (bitmap_bit_p (osi.reexamine, i))\n+\t\t      {\n+\t\t\tcollect_object_sizes_for (&osi, ssa_name (i));\n+\t\t\tif (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t\t  {\n+\t\t\t    fprintf (dump_file, \"Reexamining \");\n+\t\t\t    print_generic_expr (dump_file, ssa_name (i),\n+\t\t\t\t\t\tdump_flags);\n+\t\t\t    fprintf (dump_file, \"\\n\");\n+\t\t\t  }\n+\t\t      }\n+\t\t}\n+\t      while (osi.changed);\n+\n+\t      BITMAP_FREE (reexamine);\n+\t    }\n+\t  EXECUTE_IF_SET_IN_BITMAP (osi.reexamine, 0, i, bi)\n+\t    bitmap_set_bit (computed[object_size_type], i);\n+\n+\t  /* Debugging dumps.  */\n+\t  if (dump_file)\n+\t    {\n+\t      EXECUTE_IF_SET_IN_BITMAP (osi.visited, 0, i, bi)\n+\t\tif (object_sizes[object_size_type][i]\n+\t\t    != unknown[object_size_type])\n+\t\t  {\n+\t\t    print_generic_expr (dump_file, ssa_name (i),\n+\t\t\t\t\tdump_flags);\n+\t\t    fprintf (dump_file,\n+\t\t\t     \": %s %sobject size \"\n+\t\t\t     HOST_WIDE_INT_PRINT_UNSIGNED \"\\n\",\n+\t\t\t     (object_size_type & 2) ? \"minimum\" : \"maximum\",\n+\t\t\t     (object_size_type & 1) ? \"sub\" : \"\",\n+\t\t\t     object_sizes[object_size_type][i]);\n+\t\t  }\n+\t    }\n+\n+\t  BITMAP_FREE (osi.reexamine);\n+\t  BITMAP_FREE (osi.visited);\n+\t}\n+\n+      return object_sizes[object_size_type][SSA_NAME_VERSION (ptr)];\n+    }\n+\n+  return unknown[object_size_type];\n+}\n+\n+\n+/* Compute object_sizes for PTR, defined to VALUE, which is not\n+   a SSA_NAME.  */\n+\n+static void\n+expr_object_size (struct object_size_info *osi, tree ptr, tree value)\n+{\n+  int object_size_type = osi->object_size_type;\n+  unsigned int varno = SSA_NAME_VERSION (ptr);\n+  unsigned HOST_WIDE_INT bytes;\n+\n+  gcc_assert (object_sizes[object_size_type][varno]\n+\t      != unknown[object_size_type]);\n+  gcc_assert (osi->pass == 0);\n+\n+  if (TREE_CODE (value) == WITH_SIZE_EXPR)\n+    value = TREE_OPERAND (value, 0);\n+\n+  /* Pointer variables should have been handled by merge_object_sizes.  */\n+  gcc_assert (TREE_CODE (value) != SSA_NAME\n+\t      || !POINTER_TYPE_P (TREE_TYPE (value)));\n+\n+  if (TREE_CODE (value) == ADDR_EXPR)\n+    bytes = addr_object_size (value, object_size_type);\n+  else if (TREE_CODE (value) == CALL_EXPR)\n+    bytes = alloc_object_size (value, object_size_type);\n+  else\n+    bytes = unknown[object_size_type];\n+\n+  if ((object_size_type & 2) == 0)\n+    {\n+      if (object_sizes[object_size_type][varno] < bytes)\n+\tobject_sizes[object_size_type][varno] = bytes;\n+    }\n+  else\n+    {\n+      if (object_sizes[object_size_type][varno] > bytes)\n+\tobject_sizes[object_size_type][varno] = bytes;\n+    }\n+}\n+\n+\n+/* Merge object sizes of ORIG + OFFSET into DEST.  Return true if\n+   the object size might need reexamination later.  */\n+\n+static bool\n+merge_object_sizes (struct object_size_info *osi, tree dest, tree orig,\n+\t\t    unsigned HOST_WIDE_INT offset)\n+{\n+  int object_size_type = osi->object_size_type;\n+  unsigned int varno = SSA_NAME_VERSION (dest);\n+  unsigned HOST_WIDE_INT orig_bytes;\n+\n+  if (object_sizes[object_size_type][varno] == unknown[object_size_type])\n+    return false;\n+  if (offset >= offset_limit)\n+    {\n+      object_sizes[object_size_type][varno] = unknown[object_size_type];\n+      return false;\n+    }\n+\n+  if (osi->pass == 0)\n+    collect_object_sizes_for (osi, orig);\n+\n+  orig_bytes = object_sizes[object_size_type][SSA_NAME_VERSION (orig)];\n+  if (orig_bytes != unknown[object_size_type])\n+    orig_bytes = (offset > orig_bytes)\n+\t\t ? (unsigned HOST_WIDE_INT) 0 : orig_bytes - offset;\n+\n+  if ((object_size_type & 2) == 0)\n+    {\n+      if (object_sizes[object_size_type][varno] < orig_bytes)\n+\t{\n+\t  object_sizes[object_size_type][varno] = orig_bytes;\n+\t  osi->changed = true;\n+\t}\n+    }\n+  else\n+    {\n+      if (object_sizes[object_size_type][varno] > orig_bytes)\n+\t{\n+\t  object_sizes[object_size_type][varno] = orig_bytes;\n+\t  osi->changed = true;\n+\t}\n+    }\n+  return bitmap_bit_p (osi->reexamine, SSA_NAME_VERSION (orig));\n+}\n+\n+\n+/* Compute object_sizes for PTR, defined to VALUE, which is\n+   a PLUS_EXPR.  Return true if the object size might need reexamination\n+   later.  */\n+\n+static bool\n+plus_expr_object_size (struct object_size_info *osi, tree var, tree value)\n+{\n+  tree op0 = TREE_OPERAND (value, 0);\n+  tree op1 = TREE_OPERAND (value, 1);\n+  bool ptr1_p = POINTER_TYPE_P (TREE_TYPE (op0))\n+\t\t&& TREE_CODE (op0) != INTEGER_CST;\n+  bool ptr2_p = POINTER_TYPE_P (TREE_TYPE (op1))\n+\t\t&& TREE_CODE (op1) != INTEGER_CST;\n+  int object_size_type = osi->object_size_type;\n+  unsigned int varno = SSA_NAME_VERSION (var);\n+  unsigned HOST_WIDE_INT bytes;\n+\n+  gcc_assert (TREE_CODE (value) == PLUS_EXPR);\n+\n+  if (object_sizes[object_size_type][varno] == unknown[object_size_type])\n+    return false;\n+\n+  /* Swap operands if needed.  */\n+  if (ptr2_p && !ptr1_p)\n+    {\n+      tree tem = op0;\n+      op0 = op1;\n+      op1 = tem;\n+      ptr1_p = true;\n+      ptr2_p = false;\n+    }\n+\n+  /* Handle PTR + OFFSET here.  */\n+  if (ptr1_p\n+      && !ptr2_p\n+      && TREE_CODE (op1) == INTEGER_CST\n+      && (TREE_CODE (op0) == SSA_NAME\n+\t  || TREE_CODE (op0) == ADDR_EXPR))\n+    {\n+      if (! host_integerp (op1, 1))\n+\tbytes = unknown[object_size_type];\n+      else if (TREE_CODE (op0) == SSA_NAME)\n+\treturn merge_object_sizes (osi, var, op0, tree_low_cst (op1, 1));\n+      else\n+\t{\n+\t  unsigned HOST_WIDE_INT off = tree_low_cst (op1, 1);\n+\n+\t  bytes = compute_builtin_object_size (value, object_size_type);\n+\t  if (off > offset_limit)\n+\t    bytes = unknown[object_size_type];\n+\t  else if (off > bytes)\n+\t    bytes = 0;\n+\t  else\n+\t    bytes -= off;\n+\t}\n+    }\n+  else\n+    bytes = unknown[object_size_type];\n+\n+  if ((object_size_type & 2) == 0)\n+    {\n+      if (object_sizes[object_size_type][varno] < bytes)\n+\tobject_sizes[object_size_type][varno] = bytes;\n+    }\n+  else\n+    {\n+      if (object_sizes[object_size_type][varno] > bytes)\n+\tobject_sizes[object_size_type][varno] = bytes;\n+    }\n+  return false;\n+}\n+\n+\n+/* Compute object sizes for VAR.\n+   For ADDR_EXPR an object size is the number of remaining bytes\n+   to the end of the object (where what is consindered an object depends on\n+   OSI->object_size_type).\n+   For allocation CALL_EXPR like malloc or calloc object size is the size\n+   of the allocation.\n+   For pointer PLUS_EXPR where second operand is a constant integer,\n+   object size is object size of the first operand minus the constant.\n+   If the constant is bigger than the number of remaining bytes until the\n+   end of the object, object size is 0, but if it is instead a pointer\n+   subtraction, object size is unknown[object_size_type].\n+   To differentiate addition from subtraction, ADDR_EXPR returns\n+   unknown[object_size_type] for all objects bigger than half of the address\n+   space, and constants less than half of the address space are considered\n+   addition, while bigger constants subtraction.\n+   For a memcpy like CALL_EXPR that always returns one of its arguments, the\n+   object size is object size of that argument.\n+   Otherwise, object size is the maximum of object sizes of variables\n+   that it might be set to.  */\n+\n+static void\n+collect_object_sizes_for (struct object_size_info *osi, tree var)\n+{\n+  int object_size_type = osi->object_size_type;\n+  unsigned int varno = SSA_NAME_VERSION (var);\n+  tree stmt;\n+  bool reexamine;\n+\n+  if (bitmap_bit_p (computed[object_size_type], varno))\n+    return;\n+\n+  if (osi->pass == 0)\n+    {\n+      if (! bitmap_bit_p (osi->visited, varno))\n+\t{\n+\t  bitmap_set_bit (osi->visited, varno);\n+\t  object_sizes[object_size_type][varno]\n+\t    = (object_size_type & 2) ? -1 : 0;\n+\t}\n+      else\n+\t{\n+\t  /* Found a dependency loop.  Mark the variable for later\n+\t     re-examination.  */\n+\t  bitmap_set_bit (osi->reexamine, varno);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Found a dependency loop at \");\n+\t      print_generic_expr (dump_file, var, dump_flags);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\t  return;\n+\t}\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Visiting use-def links for \");\n+      print_generic_expr (dump_file, var, dump_flags);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  stmt = SSA_NAME_DEF_STMT (var);\n+  reexamine = false;\n+\n+  switch (TREE_CODE (stmt))\n+    {\n+    case RETURN_EXPR:\n+      if (TREE_CODE (TREE_OPERAND (stmt, 0)) != MODIFY_EXPR)\n+\tabort ();\n+      stmt = TREE_OPERAND (stmt, 0);\n+      /* FALLTHRU  */\n+\n+    case MODIFY_EXPR:\n+      {\n+\ttree rhs = TREE_OPERAND (stmt, 1), arg;\n+\tSTRIP_NOPS (rhs);\n+\n+\tif (TREE_CODE (rhs) == CALL_EXPR)\n+\t  {\n+\t    arg = pass_through_call (rhs);\n+\t    if (arg)\n+\t      rhs = arg;\n+\t  }\n+\n+\tif (TREE_CODE (rhs) == SSA_NAME\n+\t    && POINTER_TYPE_P (TREE_TYPE (rhs)))\n+\t  reexamine = merge_object_sizes (osi, var, rhs, 0);\n+\n+\telse if (TREE_CODE (rhs) == PLUS_EXPR)\n+\t  reexamine = plus_expr_object_size (osi, var, rhs);\n+\n+\telse\n+\t  expr_object_size (osi, var, rhs);\n+\tbreak;\n+      }\n+\n+    case ASM_EXPR:\n+      /* Pointers defined by __asm__ statements can point anywhere.  */\n+      object_sizes[object_size_type][varno] = unknown[object_size_type];\n+      break;\n+\n+    case NOP_EXPR:\n+      {\n+\ttree decl = SSA_NAME_VAR (var);\n+\n+\tgcc_assert (IS_EMPTY_STMT (stmt));\n+\n+\tif (TREE_CODE (decl) != PARM_DECL && DECL_INITIAL (decl))\n+\t  expr_object_size (osi, var, DECL_INITIAL (decl));\n+\telse\n+\t  expr_object_size (osi, var, decl);\n+      }\n+      break;\n+\n+    case PHI_NODE:\n+      {\n+\tint i;\n+\n+\tfor (i = 0; i < PHI_NUM_ARGS (stmt); i++)\n+\t  {\n+\t    tree rhs = PHI_ARG_DEF (stmt, i);\n+\n+\t    if (object_sizes[object_size_type][varno]\n+\t\t== unknown[object_size_type])\n+\t      break;\n+\n+\t    if (TREE_CODE (rhs) == SSA_NAME)\n+\t      reexamine |= merge_object_sizes (osi, var, rhs, 0);\n+\t    else if (osi->pass == 0)\n+\t      expr_object_size (osi, var, rhs);\n+\t  }\n+\tbreak;\n+      }\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (! reexamine\n+      || object_sizes[object_size_type][varno] == unknown[object_size_type])\n+    {\n+      bitmap_set_bit (computed[object_size_type], varno);\n+      bitmap_clear_bit (osi->reexamine, varno);\n+    }\n+  else\n+    {\n+      bitmap_set_bit (osi->reexamine, varno);\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Need to reexamine \");\n+\t  print_generic_expr (dump_file, var, dump_flags);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+    }\n+}\n+\n+\n+/* Helper function for check_for_plus_in_loops.  Called recursively\n+   to detect loops.  */\n+\n+static void\n+check_for_plus_in_loops_1 (struct object_size_info *osi, tree var,\n+\t\t\t   unsigned int depth)\n+{\n+  tree stmt = SSA_NAME_DEF_STMT (var);\n+  unsigned int varno = SSA_NAME_VERSION (var);\n+\n+  if (osi->depths[varno])\n+    {\n+      if (osi->depths[varno] != depth)\n+\t{\n+\t  unsigned int *sp;\n+\n+\t  /* Found a loop involving pointer addition.  */\n+\t  for (sp = osi->tos; sp > osi->stack; )\n+\t    {\n+\t      --sp;\n+\t      bitmap_clear_bit (osi->reexamine, *sp);\n+\t      bitmap_set_bit (computed[osi->object_size_type], *sp);\n+\t      object_sizes[osi->object_size_type][*sp] = 0;\n+\t      if (*sp == varno)\n+\t\tbreak;\n+\t    }\n+\t}\n+      return;\n+    }\n+  else if (! bitmap_bit_p (osi->reexamine, varno))\n+    return;\n+\n+  osi->depths[varno] = depth;\n+  *osi->tos++ = varno;\n+\n+  switch (TREE_CODE (stmt))\n+    {\n+    case RETURN_EXPR:\n+      if (TREE_CODE (TREE_OPERAND (stmt, 0)) != MODIFY_EXPR)\n+\tabort ();\n+      stmt = TREE_OPERAND (stmt, 0);\n+      /* FALLTHRU  */\n+\n+    case MODIFY_EXPR:\n+      {\n+\ttree rhs = TREE_OPERAND (stmt, 1), arg;\n+\tSTRIP_NOPS (rhs);\n+\n+\tif (TREE_CODE (rhs) == CALL_EXPR)\n+\t  {\n+\t    arg = pass_through_call (rhs);\n+\t    if (arg)\n+\t      rhs = arg;\n+\t  }\n+\n+\tif (TREE_CODE (rhs) == SSA_NAME)\n+\t  check_for_plus_in_loops_1 (osi, rhs, depth);\n+\telse if (TREE_CODE (rhs) == PLUS_EXPR)\n+\t  {\n+\t    tree op0 = TREE_OPERAND (rhs, 0);\n+\t    tree op1 = TREE_OPERAND (rhs, 1);\n+\t    tree cst, basevar;\n+\n+\t    if (TREE_CODE (op0) == SSA_NAME)\n+\t      {\n+\t\tbasevar = op0;\n+\t\tcst = op1;\n+\t      }\n+\t    else\n+\t      {\n+\t\tbasevar = op1;\n+\t\tcst = op0;\n+\t\tgcc_assert (TREE_CODE (basevar) == SSA_NAME);\n+\t      }\n+\t    gcc_assert (TREE_CODE (cst) == INTEGER_CST);\n+\n+\t    check_for_plus_in_loops_1 (osi, basevar,\n+\t\t\t\t       depth + !integer_zerop (cst));\n+\t  }\n+\telse\n+\t  gcc_unreachable ();\n+\tbreak;\n+      }\n+    case PHI_NODE:\n+      {\n+\tint i;\n+\n+\tfor (i = 0; i < PHI_NUM_ARGS (stmt); i++)\n+\t  {\n+\t    tree rhs = PHI_ARG_DEF (stmt, i);\n+\n+\t    if (TREE_CODE (rhs) == SSA_NAME)\n+\t      check_for_plus_in_loops_1 (osi, rhs, depth);\n+\t  }\n+\tbreak;\n+      }\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  osi->depths[varno] = 0;\n+  osi->tos--;\n+}\n+\n+\n+/* Check if some pointer we are computing object size of is being increased\n+   within a loop.  If yes, assume all the SSA variables participating in\n+   that loop have minimum object sizes 0.  */\n+\n+static void\n+check_for_plus_in_loops (struct object_size_info *osi, tree var)\n+{\n+  tree stmt = SSA_NAME_DEF_STMT (var);\n+\n+  switch (TREE_CODE (stmt))\n+    {\n+    case RETURN_EXPR:\n+      if (TREE_CODE (TREE_OPERAND (stmt, 0)) != MODIFY_EXPR)\n+\tabort ();\n+      stmt = TREE_OPERAND (stmt, 0);\n+      /* FALLTHRU  */\n+\n+    case MODIFY_EXPR:\n+      {\n+\ttree rhs = TREE_OPERAND (stmt, 1), arg;\n+\tSTRIP_NOPS (rhs);\n+\n+\tif (TREE_CODE (rhs) == CALL_EXPR)\n+\t  {\n+\t    arg = pass_through_call (rhs);\n+\t    if (arg)\n+\t      rhs = arg;\n+\t  }\n+\n+\tif (TREE_CODE (rhs) == PLUS_EXPR)\n+\t  {\n+\t    tree op0 = TREE_OPERAND (rhs, 0);\n+\t    tree op1 = TREE_OPERAND (rhs, 1);\n+\t    tree cst, basevar;\n+\n+\t    if (TREE_CODE (op0) == SSA_NAME)\n+\t      {\n+\t\tbasevar = op0;\n+\t\tcst = op1;\n+\t      }\n+\t    else\n+\t      {\n+\t\tbasevar = op1;\n+\t\tcst = op0;\n+\t\tgcc_assert (TREE_CODE (basevar) == SSA_NAME);\n+\t      }\n+\t    gcc_assert (TREE_CODE (cst) == INTEGER_CST);\n+\n+\t    if (integer_zerop (cst))\n+\t      break;\n+\n+\t    osi->depths[SSA_NAME_VERSION (basevar)] = 1;\n+\t    *osi->tos++ = SSA_NAME_VERSION (basevar);\n+\t    check_for_plus_in_loops_1 (osi, var, 2);\n+\t    osi->depths[SSA_NAME_VERSION (basevar)] = 0;\n+\t    osi->tos--;\n+\t  }\n+\tbreak;\n+      }\n+    default:\n+      break;\n+    }\n+}\n+\n+\n+/* Initialize data structures for the object size computation.  */\n+\n+void\n+init_object_sizes (void)\n+{\n+  int object_size_type;\n+\n+  if (object_sizes[0])\n+    return;\n+\n+  for (object_size_type = 0; object_size_type <= 3; object_size_type++)\n+    {\n+      object_sizes[object_size_type]\n+\t= xmalloc (num_ssa_names * sizeof (HOST_WIDE_INT));\n+      computed[object_size_type] = BITMAP_ALLOC (NULL);\n+    }\n+\n+  init_offset_limit ();\n+}\n+\n+\n+/* Destroy data structures after the object size computation.  */\n+\n+void\n+fini_object_sizes (void)\n+{\n+  int object_size_type;\n+\n+  for (object_size_type = 0; object_size_type <= 3; object_size_type++)\n+    {\n+      free (object_sizes[object_size_type]);\n+      BITMAP_FREE (computed[object_size_type]);\n+      object_sizes[object_size_type] = NULL;\n+    }\n+}\n+\n+\n+/* Simple pass to optimize all __builtin_object_size () builtins.  */\n+\n+static void\n+compute_object_sizes (void)\n+{\n+  basic_block bb;\n+  FOR_EACH_BB (bb)\n+    {\n+      block_stmt_iterator i;\n+      for (i = bsi_start (bb); !bsi_end_p (i); bsi_next (&i))\n+\t{\n+\t  tree *stmtp = bsi_stmt_ptr (i);\n+\t  tree call = get_rhs (*stmtp);\n+\t  tree callee, result;\n+\n+\t  if (!call || TREE_CODE (call) != CALL_EXPR)\n+\t    continue;\n+\n+\t  callee = get_callee_fndecl (call);\n+\t  if (!callee\n+\t      || DECL_BUILT_IN_CLASS (callee) != BUILT_IN_NORMAL\n+\t      || DECL_FUNCTION_CODE (callee) != BUILT_IN_OBJECT_SIZE)\n+\t    continue;\n+\n+\t  init_object_sizes ();\n+\t  result = fold_builtin (callee, TREE_OPERAND (call, 1), false);\n+\t  if (!result)\n+\t    {\n+\t      tree arglist = TREE_OPERAND (call, 1);\n+\n+\t      if (arglist != NULL\n+\t\t  && POINTER_TYPE_P (TREE_TYPE (TREE_VALUE (arglist)))\n+\t\t  && TREE_CHAIN (arglist) != NULL\n+\t\t  && TREE_CHAIN (TREE_CHAIN (arglist)) == NULL)\n+\t\t{\n+\t\t  tree ost = TREE_VALUE (TREE_CHAIN (arglist));\n+\n+\t\t  if (host_integerp (ost, 1))\n+\t\t    {\n+\t\t      unsigned HOST_WIDE_INT object_size_type\n+\t\t\t= tree_low_cst (ost, 1);\n+\n+\t\t      if (object_size_type < 2)\n+\t\t\tresult = fold_convert (size_type_node,\n+\t\t\t\t\t       integer_minus_one_node);\n+\t\t      else if (object_size_type < 4)\n+\t\t\tresult = size_zero_node;\n+\t\t    }\n+\t\t}\n+\n+\t      if (!result)\n+\t\tcontinue;\n+\t    }\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Simplified\\n  \");\n+\t      print_generic_stmt (dump_file, *stmtp, dump_flags);\n+\t    }\n+\n+\t  if (!set_rhs (stmtp, result))\n+\t    abort ();\n+\t  update_stmt (*stmtp);\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"to\\n  \");\n+\t      print_generic_stmt (dump_file, *stmtp, dump_flags);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\t}\n+    }\n+\n+  fini_object_sizes ();\n+}\n+\n+struct tree_opt_pass pass_object_sizes =\n+{\n+  \"objsz\",\t\t\t\t/* name */\n+  NULL,\t\t\t\t\t/* gate */\n+  compute_object_sizes,\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  0,\t\t\t\t\t/* tv_id */\n+  PROP_cfg | PROP_ssa | PROP_alias,\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func | TODO_verify_ssa,\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};"}, {"sha": "4b46c9b7ec5f6320b84496ba53883c4c72282ac7", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -435,6 +435,7 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_may_alias);\n   NEXT_PASS (pass_forwprop);\n   NEXT_PASS (pass_phiopt);\n+  NEXT_PASS (pass_object_sizes);\n   NEXT_PASS (pass_store_ccp);\n   NEXT_PASS (pass_store_copy_prop);\n   NEXT_PASS (pass_fold_builtins);"}, {"sha": "471747bf73ca76f90fae4db317188bfb54f0f13e", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -196,6 +196,7 @@ extern struct tree_opt_pass pass_lower_complex_O0;\n extern struct tree_opt_pass pass_lower_complex;\n extern struct tree_opt_pass pass_lower_vector;\n extern struct tree_opt_pass pass_lower_vector_ssa;\n+extern struct tree_opt_pass pass_object_sizes;\n extern struct tree_opt_pass pass_fold_builtins;\n extern struct tree_opt_pass pass_stdarg;\n extern struct tree_opt_pass pass_early_warn_uninitialized;"}, {"sha": "8bf824250e4871b17db33fd50db1a499bbbe814a", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 134, "deletions": 60, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -1965,24 +1965,49 @@ fold_stmt_r (tree *expr_p, int *walk_subtrees, void *data)\n }\n \n \n-/* Return the string length of ARG in LENGTH.  If ARG is an SSA name variable,\n-   follow its use-def chains.  If LENGTH is not NULL and its value is not\n-   equal to the length we determine, or if we are unable to determine the\n-   length, return false.  VISITED is a bitmap of visited variables.  */\n+/* Return the string length, maximum string length or maximum value of\n+   ARG in LENGTH.\n+   If ARG is an SSA name variable, follow its use-def chains.  If LENGTH\n+   is not NULL and, for TYPE == 0, its value is not equal to the length\n+   we determine or if we are unable to determine the length or value,\n+   return false.  VISITED is a bitmap of visited variables.\n+   TYPE is 0 if string length should be returned, 1 for maximum string\n+   length and 2 for maximum value ARG can have.  */\n \n static bool\n-get_strlen (tree arg, tree *length, bitmap visited)\n+get_maxval_strlen (tree arg, tree *length, bitmap visited, int type)\n {\n   tree var, def_stmt, val;\n   \n   if (TREE_CODE (arg) != SSA_NAME)\n     {\n-      val = c_strlen (arg, 1);\n+      if (type == 2)\n+\t{\n+\t  val = arg;\n+\t  if (TREE_CODE (val) != INTEGER_CST\n+\t      || tree_int_cst_sgn (val) < 0)\n+\t    return false;\n+\t}\n+      else\n+\tval = c_strlen (arg, 1);\n       if (!val)\n \treturn false;\n \n-      if (*length && simple_cst_equal (val, *length) != 1)\n-\treturn false;\n+      if (*length)\n+\t{\n+\t  if (type > 0)\n+\t    {\n+\t      if (TREE_CODE (*length) != INTEGER_CST\n+\t\t  || TREE_CODE (val) != INTEGER_CST)\n+\t\treturn false;\n+\n+\t      if (tree_int_cst_lt (*length, val))\n+\t\t*length = val;\n+\t      return true;\n+\t    }\n+\t  else if (simple_cst_equal (val, *length) != 1)\n+\t    return false;\n+\t}\n \n       *length = val;\n       return true;\n@@ -2000,28 +2025,14 @@ get_strlen (tree arg, tree *length, bitmap visited)\n     {\n       case MODIFY_EXPR:\n \t{\n-\t  tree len, rhs;\n-\t  \n+\t  tree rhs;\n+\n \t  /* The RHS of the statement defining VAR must either have a\n \t     constant length or come from another SSA_NAME with a constant\n \t     length.  */\n \t  rhs = TREE_OPERAND (def_stmt, 1);\n \t  STRIP_NOPS (rhs);\n-\t  if (TREE_CODE (rhs) == SSA_NAME)\n-\t    return get_strlen (rhs, length, visited);\n-\n-\t  /* See if the RHS is a constant length.  */\n-\t  len = c_strlen (rhs, 1);\n-\t  if (len)\n-\t    {\n-\t      if (*length && simple_cst_equal (len, *length) != 1)\n-\t\treturn false;\n-\n-\t      *length = len;\n-\t      return true;\n-\t    }\n-\n-\t  break;\n+\t  return get_maxval_strlen (rhs, length, visited, type);\n \t}\n \n       case PHI_NODE:\n@@ -2043,7 +2054,7 @@ get_strlen (tree arg, tree *length, bitmap visited)\n \t      if (arg == PHI_RESULT (def_stmt))\n \t\tcontinue;\n \n-\t      if (!get_strlen (arg, length, visited))\n+\t      if (!get_maxval_strlen (arg, length, visited, type))\n \t\treturn false;\n \t    }\n \n@@ -2065,9 +2076,9 @@ get_strlen (tree arg, tree *length, bitmap visited)\n static tree\n ccp_fold_builtin (tree stmt, tree fn)\n {\n-  tree result, strlen_val[2];\n+  tree result, val[3];\n   tree callee, arglist, a;\n-  int strlen_arg, i;\n+  int arg_mask, i, type;\n   bitmap visited;\n   bool ignore;\n \n@@ -2079,11 +2090,11 @@ ccp_fold_builtin (tree stmt, tree fn)\n   arglist = TREE_OPERAND (fn, 1);\n   result = fold_builtin (callee, arglist, ignore);\n   if (result)\n-  {\n-    if (ignore)\n-      STRIP_NOPS (result);\n-    return result;\n-  }\n+    {\n+      if (ignore)\n+\tSTRIP_NOPS (result);\n+      return result;\n+    }\n \n   /* Ignore MD builtins.  */\n   if (DECL_BUILT_IN_CLASS (callee) == BUILT_IN_MD)\n@@ -2100,11 +2111,31 @@ ccp_fold_builtin (tree stmt, tree fn)\n     case BUILT_IN_STRLEN:\n     case BUILT_IN_FPUTS:\n     case BUILT_IN_FPUTS_UNLOCKED:\n-      strlen_arg = 1;\n+      arg_mask = 1;\n+      type = 0;\n       break;\n     case BUILT_IN_STRCPY:\n     case BUILT_IN_STRNCPY:\n-      strlen_arg = 2;\n+      arg_mask = 2;\n+      type = 0;\n+      break;\n+    case BUILT_IN_MEMCPY_CHK:\n+    case BUILT_IN_MEMPCPY_CHK:\n+    case BUILT_IN_MEMMOVE_CHK:\n+    case BUILT_IN_MEMSET_CHK:\n+    case BUILT_IN_STRNCPY_CHK:\n+      arg_mask = 4;\n+      type = 2;\n+      break;\n+    case BUILT_IN_STRCPY_CHK:\n+    case BUILT_IN_STPCPY_CHK:\n+      arg_mask = 2;\n+      type = 1;\n+      break;\n+    case BUILT_IN_SNPRINTF_CHK:\n+    case BUILT_IN_VSNPRINTF_CHK:\n+      arg_mask = 2;\n+      type = 2;\n       break;\n     default:\n       return NULL_TREE;\n@@ -2113,15 +2144,15 @@ ccp_fold_builtin (tree stmt, tree fn)\n   /* Try to use the dataflow information gathered by the CCP process.  */\n   visited = BITMAP_ALLOC (NULL);\n \n-  memset (strlen_val, 0, sizeof (strlen_val));\n+  memset (val, 0, sizeof (val));\n   for (i = 0, a = arglist;\n-       strlen_arg;\n-       i++, strlen_arg >>= 1, a = TREE_CHAIN (a))\n-    if (strlen_arg & 1)\n+       arg_mask;\n+       i++, arg_mask >>= 1, a = TREE_CHAIN (a))\n+    if (arg_mask & 1)\n       {\n \tbitmap_clear (visited);\n-\tif (!get_strlen (TREE_VALUE (a), &strlen_val[i], visited))\n-\t  strlen_val[i] = NULL_TREE;\n+\tif (!get_maxval_strlen (TREE_VALUE (a), &val[i], visited, type))\n+\t  val[i] = NULL_TREE;\n       }\n \n   BITMAP_FREE (visited);\n@@ -2130,9 +2161,9 @@ ccp_fold_builtin (tree stmt, tree fn)\n   switch (DECL_FUNCTION_CODE (callee))\n     {\n     case BUILT_IN_STRLEN:\n-      if (strlen_val[0])\n+      if (val[0])\n \t{\n-\t  tree new = fold_convert (TREE_TYPE (fn), strlen_val[0]);\n+\t  tree new = fold_convert (TREE_TYPE (fn), val[0]);\n \n \t  /* If the result is not a valid gimple value, or not a cast\n \t     of a valid gimple value, then we can not use the result.  */\n@@ -2144,33 +2175,53 @@ ccp_fold_builtin (tree stmt, tree fn)\n       break;\n \n     case BUILT_IN_STRCPY:\n-      if (strlen_val[1] && is_gimple_val (strlen_val[1]))\n-\t{\n-\t  tree fndecl = get_callee_fndecl (fn);\n-\t  tree arglist = TREE_OPERAND (fn, 1);\n-\t  result = fold_builtin_strcpy (fndecl, arglist, strlen_val[1]);\n-\t}\n+      if (val[1] && is_gimple_val (val[1]))\n+\tresult = fold_builtin_strcpy (callee, arglist, val[1]);\n       break;\n \n     case BUILT_IN_STRNCPY:\n-      if (strlen_val[1] && is_gimple_val (strlen_val[1]))\n-\t{\n-\t  tree fndecl = get_callee_fndecl (fn);\n-\t  tree arglist = TREE_OPERAND (fn, 1);\n-\t  result = fold_builtin_strncpy (fndecl, arglist, strlen_val[1]);\n-\t}\n+      if (val[1] && is_gimple_val (val[1]))\n+\tresult = fold_builtin_strncpy (callee, arglist, val[1]);\n       break;\n \n     case BUILT_IN_FPUTS:\n       result = fold_builtin_fputs (arglist,\n \t\t\t\t   TREE_CODE (stmt) != MODIFY_EXPR, 0,\n-\t\t\t\t   strlen_val[0]);\n+\t\t\t\t   val[0]);\n       break;\n \n     case BUILT_IN_FPUTS_UNLOCKED:\n       result = fold_builtin_fputs (arglist,\n \t\t\t\t   TREE_CODE (stmt) != MODIFY_EXPR, 1,\n-\t\t\t\t   strlen_val[0]);\n+\t\t\t\t   val[0]);\n+      break;\n+\n+    case BUILT_IN_MEMCPY_CHK:\n+    case BUILT_IN_MEMPCPY_CHK:\n+    case BUILT_IN_MEMMOVE_CHK:\n+    case BUILT_IN_MEMSET_CHK:\n+      if (val[2] && is_gimple_val (val[2]))\n+\tresult = fold_builtin_memory_chk (callee, arglist, val[2], ignore,\n+\t\t\t\t\t  DECL_FUNCTION_CODE (callee));\n+      break;\n+\n+    case BUILT_IN_STRCPY_CHK:\n+    case BUILT_IN_STPCPY_CHK:\n+      if (val[1] && is_gimple_val (val[1]))\n+\tresult = fold_builtin_stxcpy_chk (callee, arglist, val[1], ignore,\n+\t\t\t\t\t  DECL_FUNCTION_CODE (callee));\n+      break;\n+\n+    case BUILT_IN_STRNCPY_CHK:\n+      if (val[2] && is_gimple_val (val[2]))\n+\tresult = fold_builtin_strncpy_chk (arglist, val[2]);\n+      break;\n+\n+    case BUILT_IN_SNPRINTF_CHK:\n+    case BUILT_IN_VSNPRINTF_CHK:\n+      if (val[1] && is_gimple_val (val[1]))\n+\tresult = fold_builtin_snprintf_chk (arglist, val[1],\n+\t\t\t\t\t    DECL_FUNCTION_CODE (callee));\n       break;\n \n     default:\n@@ -2338,18 +2389,26 @@ execute_fold_all_builtins (void)\n   FOR_EACH_BB (bb)\n     {\n       block_stmt_iterator i;\n-      for (i = bsi_start (bb); !bsi_end_p (i); bsi_next (&i))\n+      for (i = bsi_start (bb); !bsi_end_p (i); )\n \t{\n \t  tree *stmtp = bsi_stmt_ptr (i);\n \t  tree old_stmt = *stmtp;\n \t  tree call = get_rhs (*stmtp);\n \t  tree callee, result;\n+\t  enum built_in_function fcode;\n \n \t  if (!call || TREE_CODE (call) != CALL_EXPR)\n-\t    continue;\n+\t    {\n+\t      bsi_next (&i);\n+\t      continue;\n+\t    }\n \t  callee = get_callee_fndecl (call);\n \t  if (!callee || DECL_BUILT_IN_CLASS (callee) != BUILT_IN_NORMAL)\n-\t    continue;\n+\t    {\n+\t      bsi_next (&i);\n+\t      continue;\n+\t    }\n+\t  fcode = DECL_FUNCTION_CODE (callee);\n \n \t  result = ccp_fold_builtin (*stmtp, call);\n \t  if (!result)\n@@ -2363,6 +2422,7 @@ execute_fold_all_builtins (void)\n \t\tbreak;\n \n \t      default:\n+\t\tbsi_next (&i);\n \t\tcontinue;\n \t      }\n \n@@ -2393,6 +2453,20 @@ execute_fold_all_builtins (void)\n \t      print_generic_stmt (dump_file, *stmtp, dump_flags);\n \t      fprintf (dump_file, \"\\n\");\n \t    }\n+\n+\t  /* Retry the same statement if it changed into another\n+\t     builtin, there might be new opportunities now.  */\n+\t  call = get_rhs (*stmtp);\n+\t  if (!call || TREE_CODE (call) != CALL_EXPR)\n+\t    {\n+\t      bsi_next (&i);\n+\t      continue;\n+\t    }\n+\t  callee = get_callee_fndecl (call);\n+\t  if (!callee\n+\t      || DECL_BUILT_IN_CLASS (callee) != BUILT_IN_NORMAL\n+\t      || DECL_FUNCTION_CODE (callee) == fcode)\n+\t    bsi_next (&i);\n \t}\n     }\n "}, {"sha": "a2e9a86f886a52346aef922d429ddb3e669a7f15", "filename": "gcc/tree.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10a0d4957162e39a922341ffbef5a394035cf17c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=10a0d4957162e39a922341ffbef5a394035cf17c", "patch": "@@ -3623,6 +3623,12 @@ extern tree fold_builtin (tree, tree, bool);\n extern tree fold_builtin_fputs (tree, bool, bool, tree);\n extern tree fold_builtin_strcpy (tree, tree, tree);\n extern tree fold_builtin_strncpy (tree, tree, tree);\n+extern tree fold_builtin_memory_chk (tree, tree, tree, bool,\n+\t\t\t\t     enum built_in_function);\n+extern tree fold_builtin_stxcpy_chk (tree, tree, tree, bool,\n+\t\t\t\t     enum built_in_function);\n+extern tree fold_builtin_strncpy_chk (tree, tree);\n+extern tree fold_builtin_snprintf_chk (tree, tree, enum built_in_function);\n extern bool fold_builtin_next_arg (tree);\n extern enum built_in_function builtin_mathfn_code (tree);\n extern tree build_function_call_expr (tree, tree);\n@@ -4010,4 +4016,9 @@ extern void vect_set_verbosity_level (const char *);\n extern tree tree_mem_ref_addr (tree, tree);\n extern void copy_mem_ref_info (tree, tree);\n \n+/* In tree-object-size.c.  */\n+extern void init_object_sizes (void);\n+extern void fini_object_sizes (void);\n+extern unsigned HOST_WIDE_INT compute_builtin_object_size (tree, int);\n+\n #endif  /* GCC_TREE_H  */"}]}