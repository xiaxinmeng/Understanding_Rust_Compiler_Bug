{"sha": "cc099b03c01f74b2b8ddf87f93890bdbde2305f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2MwOTliMDNjMDFmNzRiMmI4ZGRmODdmOTM4OTBiZGJkZTIzMDVmOQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-09-14T09:40:17Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-09-14T09:40:17Z"}, "message": "match-and-simplify.texi: Update for changed syntax of inner ifs and the new switch expression.\n\n2015-09-14  Richard Biener  <rguenther@suse.de>\n\n\t* doc/match-and-simplify.texi: Update for changed syntax\n\tof inner ifs and the new switch expression.\n\nFrom-SVN: r227741", "tree": {"sha": "0c1dd8f5b516a50f05e46cddd6b3b039265277ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c1dd8f5b516a50f05e46cddd6b3b039265277ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc099b03c01f74b2b8ddf87f93890bdbde2305f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc099b03c01f74b2b8ddf87f93890bdbde2305f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc099b03c01f74b2b8ddf87f93890bdbde2305f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc099b03c01f74b2b8ddf87f93890bdbde2305f9/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "64106a1a20775c1ceb07cdb553b9e20402c3e6fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64106a1a20775c1ceb07cdb553b9e20402c3e6fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64106a1a20775c1ceb07cdb553b9e20402c3e6fc"}], "stats": {"total": 57, "additions": 52, "deletions": 5}, "files": [{"sha": "9059ffa23e88806f9c063fb8e332cab580050831", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc099b03c01f74b2b8ddf87f93890bdbde2305f9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc099b03c01f74b2b8ddf87f93890bdbde2305f9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc099b03c01f74b2b8ddf87f93890bdbde2305f9", "patch": "@@ -1,3 +1,8 @@\n+2015-09-14  Richard Biener  <rguenther@suse.de>\n+\n+\t* doc/match-and-simplify.texi: Update for changed syntax\n+\tof inner ifs and the new switch expression.\n+\n 2015-09-14  Yuri Rumyantsev  <ysrumyan@gmail.com>\n \n \t* config/i386/haswell.md: New file describing Haswell pipeline."}, {"sha": "2bf232041511ae3a0dc2213dd3c3b472d8a699f3", "filename": "gcc/doc/match-and-simplify.texi", "status": "modified", "additions": 47, "deletions": 5, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc099b03c01f74b2b8ddf87f93890bdbde2305f9/gcc%2Fdoc%2Fmatch-and-simplify.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc099b03c01f74b2b8ddf87f93890bdbde2305f9/gcc%2Fdoc%2Fmatch-and-simplify.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmatch-and-simplify.texi?ref=cc099b03c01f74b2b8ddf87f93890bdbde2305f9", "patch": "@@ -118,8 +118,8 @@ be a valid GIMPLE operand (so you cannot generate expressions in C code).\n @smallexample\n (simplify\n   (trunc_mod integer_zerop@@0 @@1)\n-  (if (!integer_zerop (@@1)))\n-  @@0)\n+  (if (!integer_zerop (@@1))\n+   @@0))\n @end smallexample\n \n Here @code{@@0} captures the first operand of the trunc_mod expression\n@@ -130,9 +130,11 @@ can be unconstrained or capture expresions or predicates.\n This example introduces an optional operand of simplify,\n the if-expression.  This condition is evaluated after the\n expression matched in the IL and is required to evaluate to true\n-to enable the replacement expression.  The expression operand\n-of the @code{if} is a standard C expression which may contain references\n-to captures.\n+to enable the replacement expression in the second operand\n+position.  The expression operand of the @code{if} is a standard C\n+expression which may contain references to captures.  The @code{if}\n+has an optional third operand which may contain the replacement\n+expression that is enabled when the condition evaluates to false.\n \n A @code{if} expression can be used to specify a common condition\n for multiple simplify patterns, avoiding the need\n@@ -149,8 +151,48 @@ to repeat that multiple times:\n     (negate @@1)))\n @end smallexample\n \n+Note that @code{if}s in outer position do not have the optional\n+else clause but instead have multiple then clauses.\n+\n Ifs can be nested.\n \n+There exists a @code{switch} expression which can be used to\n+chain conditions avoiding nesting @code{if}s too much:\n+\n+@smallexample\n+(simplify\n+ (simple_comparison @@0 REAL_CST@@1)\n+ (switch\n+  /* a CMP (-0) -> a CMP 0  */\n+  (if (REAL_VALUE_MINUS_ZERO (TREE_REAL_CST (@@1)))\n+   (cmp @@0 @{ build_real (TREE_TYPE (@@1), dconst0); @}))\n+  /* x != NaN is always true, other ops are always false.  */\n+  (if (REAL_VALUE_ISNAN (TREE_REAL_CST (@@1))\n+       && ! HONOR_SNANS (@@1))\n+   @{ constant_boolean_node (cmp == NE_EXPR, type); @})))\n+@end smallexample\n+\n+Is equal to\n+\n+@smallexample\n+(simplify\n+ (simple_comparison @@0 REAL_CST@@1)\n+ (switch\n+  /* a CMP (-0) -> a CMP 0  */\n+  (if (REAL_VALUE_MINUS_ZERO (TREE_REAL_CST (@@1)))\n+   (cmp @@0 @{ build_real (TREE_TYPE (@@1), dconst0); @})\n+   /* x != NaN is always true, other ops are always false.  */\n+   (if (REAL_VALUE_ISNAN (TREE_REAL_CST (@@1))\n+        && ! HONOR_SNANS (@@1))\n+    @{ constant_boolean_node (cmp == NE_EXPR, type); @}))))\n+@end smallexample\n+\n+which has the second @code{if} in the else operand of the first.\n+The @code{switch} expression takes @code{if} expressions as\n+operands (which may not have else clauses) and as a last operand\n+a replacement expression which should be enabled by default if\n+no other condition evaluated to true.\n+\n Captures can also be used for capturing results of sub-expressions.\n \n @smallexample"}]}