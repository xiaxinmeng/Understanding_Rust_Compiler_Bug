{"sha": "ae035e3437c1ec7d96773b31e631ec121bb4153f", "node_id": "C_kwDOANBUbNoAKGFlMDM1ZTM0MzdjMWVjN2Q5Njc3M2IzMWU2MzFlYzEyMWJiNDE1M2Y", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-07-17T10:38:15Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-09-05T07:21:01Z"}, "message": "[Ada] Fix crash for Default_Initial_Condition on derived enumeration type\n\nThis fixes a crash on the declaration of a private derived enumeration type\nwith the Default_Initial_Condition aspect and in the process makes a couple\nof related adjustments: 1) removes the early freezing of implicit character\nand numeric base types and 2) fixes an oversight in the implementation of\ndelayed representation aspects.\n\ngcc/ada/\n\n\t* aspects.ads (Delaying Evaluation of Aspect): Fix typos.\n\t* exp_ch3.adb (Freeze_Type): Do not generate Invariant and DIC\n\tprocedures for internal types.\n\t* exp_util.adb (Build_DIC_Procedure_Body): Adjust comment.\n\t* freeze.adb (Freeze_Entity): Call Inherit_Delayed_Rep_Aspects for\n\tsubtypes and derived types only after the base or parent type has\n\tbeen frozen.  Remove useless freezing for first subtype.\n\t(Freeze_Fixed_Point_Type): Call Inherit_Delayed_Rep_Aspects too.\n\t* layout.adb (Set_Elem_Alignment): Deal with private types.\n\t* sem_ch3.adb (Build_Derived_Enumeration_Type): Build the implicit\n\tbase as an itype and do not insert its declaration in the tree.\n\t(Build_Derived_Numeric_Type): Do not freeze the implicit base.\n\t(Derived_Standard_Character): Likewise.\n\t(Constrain_Enumeration): Inherit the chain of representation items\n\tinstead of replacing it.\n\t* sem_ch13.ads (Inherit_Aspects_At_Freeze_Point): Add ??? comment.\n\t(Inherit_Delayed_Rep_Aspects): Declare.\n\t* sem_ch13.adb (Analyze_Aspects_At_Freeze_Point): Do not invoke\n\tInherit_Delayed_Rep_Aspects.\n\t(Inherit_Aspects_At_Freeze_Point): Deal with private types.\n\t(Inherit_Delayed_Rep_Aspects): Move to library level.", "tree": {"sha": "ffa89f6d57401aa54b31a9b09c23e9ec8a343305", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffa89f6d57401aa54b31a9b09c23e9ec8a343305"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae035e3437c1ec7d96773b31e631ec121bb4153f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae035e3437c1ec7d96773b31e631ec121bb4153f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae035e3437c1ec7d96773b31e631ec121bb4153f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae035e3437c1ec7d96773b31e631ec121bb4153f/comments", "author": null, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88fbab0d71bc161aae1353a817594d14d977b0ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88fbab0d71bc161aae1353a817594d14d977b0ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88fbab0d71bc161aae1353a817594d14d977b0ea"}], "stats": {"total": 630, "additions": 319, "deletions": 311}, "files": [{"sha": "2edb6082de708315481526664383c5c444dee2a5", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae035e3437c1ec7d96773b31e631ec121bb4153f/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae035e3437c1ec7d96773b31e631ec121bb4153f/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=ae035e3437c1ec7d96773b31e631ec121bb4153f", "patch": "@@ -822,11 +822,11 @@ package Aspects is\n    --  set on the parent type if it has delayed representation aspects. This\n    --  flag Has_Delayed_Rep_Aspects indicates that if we derive from this type\n    --  we have to worry about making sure we inherit any delayed aspects. The\n-   --  second flag is set on a derived type: May_Have_Inherited_Rep_Aspects\n+   --  second flag is set on a derived type: May_Inherit_Delayed_Rep_Aspects\n    --  is set if the parent type has Has_Delayed_Rep_Aspects set.\n \n-   --  When we freeze a derived type, if the May_Have_Inherited_Rep_Aspects\n-   --  flag is set, then we call Freeze.Inherit_Delayed_Rep_Aspects when\n+   --  When we freeze a derived type, if the May_Inherit_Delayed_Rep_Aspects\n+   --  flag is set, then we call Sem_Ch13.Inherit_Delayed_Rep_Aspects when\n    --  the derived type is frozen, which deals with the necessary copying of\n    --  information from the parent type, which must be frozen at that point\n    --  (since freezing the derived type first freezes the parent type)."}, {"sha": "eee58239a62240259a0a8cce53f282474c720efd", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae035e3437c1ec7d96773b31e631ec121bb4153f/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae035e3437c1ec7d96773b31e631ec121bb4153f/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=ae035e3437c1ec7d96773b31e631ec121bb4153f", "patch": "@@ -9182,9 +9182,12 @@ package body Exp_Ch3 is\n       --  the runtime verification of all invariants that pertain to the type.\n       --  This includes invariants on the partial and full view, inherited\n       --  class-wide invariants from parent types or interfaces, and invariants\n-      --  on array elements or record components.\n+      --  on array elements or record components. But skip internal types.\n \n-      if Is_Interface (Def_Id) then\n+      if Is_Itype (Def_Id) then\n+         null;\n+\n+      elsif Is_Interface (Def_Id) then\n \n          --  Interfaces are treated as the partial view of a private type in\n          --  order to achieve uniformity with the general case. As a result, an"}, {"sha": "2be81a544a8b845d870d5a1d2f7eea1e3183043c", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae035e3437c1ec7d96773b31e631ec121bb4153f/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae035e3437c1ec7d96773b31e631ec121bb4153f/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=ae035e3437c1ec7d96773b31e631ec121bb4153f", "patch": "@@ -2042,7 +2042,7 @@ package body Exp_Util is\n       elsif Is_Underlying_Full_View (Work_Typ) then\n          return;\n \n-      --  Use the first subtype when dealing with various base types\n+      --  Use the first subtype when dealing with implicit base types\n \n       elsif Is_Itype (Work_Typ) then\n          Work_Typ := First_Subtype (Work_Typ);"}, {"sha": "52858e23b333b5670aa4d0c21019c9a3c9a1e669", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae035e3437c1ec7d96773b31e631ec121bb4153f/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae035e3437c1ec7d96773b31e631ec121bb4153f/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=ae035e3437c1ec7d96773b31e631ec121bb4153f", "patch": "@@ -6366,9 +6366,7 @@ package body Freeze is\n          end;\n       end if;\n \n-      if Has_Delayed_Aspects (E)\n-        or else May_Inherit_Delayed_Rep_Aspects (E)\n-      then\n+      if Has_Delayed_Aspects (E) then\n          Analyze_Aspects_At_Freeze_Point (E);\n       end if;\n \n@@ -6799,18 +6797,25 @@ package body Freeze is\n             --  A subtype inherits all the type-related representation aspects\n             --  from its parents (RM 13.1(8)).\n \n+            if May_Inherit_Delayed_Rep_Aspects (E) then\n+               Inherit_Delayed_Rep_Aspects (E);\n+            end if;\n+\n             Inherit_Aspects_At_Freeze_Point (E);\n \n          --  For a derived type, freeze its parent type first (RM 13.14(15))\n \n          elsif Is_Derived_Type (E) then\n             Freeze_And_Append (Etype (E), N, Result);\n-            Freeze_And_Append (First_Subtype (Etype (E)), N, Result);\n \n             --  A derived type inherits each type-related representation aspect\n             --  of its parent type that was directly specified before the\n             --  declaration of the derived type (RM 13.1(15)).\n \n+            if May_Inherit_Delayed_Rep_Aspects (E) then\n+               Inherit_Delayed_Rep_Aspects (E);\n+            end if;\n+\n             Inherit_Aspects_At_Freeze_Point (E);\n          end if;\n \n@@ -9089,6 +9094,11 @@ package body Freeze is\n          Set_Has_Delayed_Aspects (Ftyp, False);\n       end if;\n \n+      if May_Inherit_Delayed_Rep_Aspects (Ftyp) then\n+         Inherit_Delayed_Rep_Aspects (Ftyp);\n+         Set_May_Inherit_Delayed_Rep_Aspects (Ftyp, False);\n+      end if;\n+\n       --  Inherit the Small value from the first subtype in any case\n \n       if Typ /= Ftyp then"}, {"sha": "e4187dd9ce58ca3b50d53806b3fd07740e85a5ad", "filename": "gcc/ada/layout.adb", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae035e3437c1ec7d96773b31e631ec121bb4153f/gcc%2Fada%2Flayout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae035e3437c1ec7d96773b31e631ec121bb4153f/gcc%2Fada%2Flayout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.adb?ref=ae035e3437c1ec7d96773b31e631ec121bb4153f", "patch": "@@ -1053,8 +1053,6 @@ package body Layout is\n             --  derived types.\n \n             declare\n-               FST : constant Entity_Id := First_Subtype (E);\n-\n                function Has_Attribute_Clause\n                  (E  : Entity_Id;\n                   Id : Attribute_Id) return Boolean;\n@@ -1072,7 +1070,17 @@ package body Layout is\n                   return Present (Get_Attribute_Definition_Clause (E, Id));\n                end Has_Attribute_Clause;\n \n+               FST : Entity_Id;\n+\n             begin\n+               FST := First_Subtype (E);\n+\n+               --  Deal with private types\n+\n+               if Is_Private_Type (FST) then\n+                  FST := Full_View (FST);\n+               end if;\n+\n                --  If the alignment comes from a clause, then we respect it.\n                --  Consider for example:\n "}, {"sha": "79add0bd9b70bc0afb8f4182de16dddb37a33c06", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 233, "deletions": 239, "changes": 472, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae035e3437c1ec7d96773b31e631ec121bb4153f/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae035e3437c1ec7d96773b31e631ec121bb4153f/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=ae035e3437c1ec7d96773b31e631ec121bb4153f", "patch": "@@ -944,29 +944,6 @@ package body Sem_Ch13 is\n       --  aspect node N for the given type (entity) of the aspect does not\n       --  appear too late according to the rules in RM 13.1(9) and 13.1(10).\n \n-      procedure Inherit_Delayed_Rep_Aspects (ASN : Node_Id);\n-      --  As discussed in the spec of Aspects (see Aspect_Delay declaration),\n-      --  a derived type can inherit aspects from its parent which have been\n-      --  specified at the time of the derivation using an aspect, as in:\n-      --\n-      --    type A is range 1 .. 10\n-      --      with Size => Not_Defined_Yet;\n-      --    ..\n-      --    type B is new A;\n-      --    ..\n-      --    Not_Defined_Yet : constant := 64;\n-      --\n-      --  In this example, the Size of A is considered to be specified prior\n-      --  to the derivation, and thus inherited, even though the value is not\n-      --  known at the time of derivation. To deal with this, we use two entity\n-      --  flags. The flag Has_Derived_Rep_Aspects is set in the parent type (A\n-      --  here), and then the flag May_Inherit_Delayed_Rep_Aspects is set in\n-      --  the derived type (B here). If this flag is set when the derived type\n-      --  is frozen, then this procedure is called to ensure proper inheritance\n-      --  of all delayed aspects from the parent type. The derived type is E,\n-      --  the argument to Analyze_Aspects_At_Freeze_Point. ASN is the first\n-      --  aspect specification node in the Rep_Item chain for the parent type.\n-\n       procedure Make_Pragma_From_Boolean_Aspect (ASN : Node_Id);\n       --  Given an aspect specification node ASN whose expression is an\n       --  optional Boolean, this routines creates the corresponding pragma\n@@ -1084,199 +1061,6 @@ package body Sem_Ch13 is\n          end if;\n       end Check_Aspect_Too_Late;\n \n-      ---------------------------------\n-      -- Inherit_Delayed_Rep_Aspects --\n-      ---------------------------------\n-\n-      procedure Inherit_Delayed_Rep_Aspects (ASN : Node_Id) is\n-         A_Id : constant Aspect_Id := Get_Aspect_Id (ASN);\n-         P    : constant Entity_Id := Entity (ASN);\n-         --  Entity for parent type\n-\n-         N : Node_Id;\n-         --  Item from Rep_Item chain\n-\n-         A : Aspect_Id;\n-\n-      begin\n-         --  Loop through delayed aspects for the parent type\n-\n-         N := ASN;\n-         while Present (N) loop\n-            if Nkind (N) = N_Aspect_Specification then\n-               exit when Entity (N) /= P;\n-\n-               if Is_Delayed_Aspect (N) then\n-                  A := Get_Aspect_Id (Chars (Identifier (N)));\n-\n-                  --  Process delayed rep aspect. For Boolean attributes it is\n-                  --  not possible to cancel an attribute once set (the attempt\n-                  --  to use an aspect with xxx => False is an error) for a\n-                  --  derived type. So for those cases, we do not have to check\n-                  --  if a clause has been given for the derived type, since it\n-                  --  is harmless to set it again if it is already set.\n-\n-                  case A is\n-\n-                     --  Alignment\n-\n-                     when Aspect_Alignment =>\n-                        if not Has_Alignment_Clause (E) then\n-                           Set_Alignment (E, Alignment (P));\n-                        end if;\n-\n-                     --  Atomic\n-\n-                     when Aspect_Atomic =>\n-                        if Is_Atomic (P) then\n-                           Set_Is_Atomic (E);\n-                        end if;\n-\n-                     --  Atomic_Components\n-\n-                     when Aspect_Atomic_Components =>\n-                        if Has_Atomic_Components (P) then\n-                           Set_Has_Atomic_Components (Base_Type (E));\n-                        end if;\n-\n-                     --  Bit_Order\n-\n-                     when Aspect_Bit_Order =>\n-                        if Is_Record_Type (E)\n-                          and then No (Get_Attribute_Definition_Clause\n-                                         (E, Attribute_Bit_Order))\n-                          and then Reverse_Bit_Order (P)\n-                        then\n-                           Set_Reverse_Bit_Order (Base_Type (E));\n-                        end if;\n-\n-                     --  Component_Size\n-\n-                     when Aspect_Component_Size =>\n-                        if Is_Array_Type (E)\n-                          and then not Has_Component_Size_Clause (E)\n-                        then\n-                           Set_Component_Size\n-                             (Base_Type (E), Component_Size (P));\n-                        end if;\n-\n-                     --  Machine_Radix\n-\n-                     when Aspect_Machine_Radix =>\n-                        if Is_Decimal_Fixed_Point_Type (E)\n-                          and then not Has_Machine_Radix_Clause (E)\n-                        then\n-                           Set_Machine_Radix_10 (E, Machine_Radix_10 (P));\n-                        end if;\n-\n-                     --  Object_Size (also Size which also sets Object_Size)\n-\n-                     when Aspect_Object_Size\n-                        | Aspect_Size\n-                     =>\n-                        if not Has_Size_Clause (E)\n-                          and then\n-                            No (Get_Attribute_Definition_Clause\n-                                  (E, Attribute_Object_Size))\n-                        then\n-                           Set_Esize (E, Esize (P));\n-                        end if;\n-\n-                     --  Pack\n-\n-                     when Aspect_Pack =>\n-                        if not Is_Packed (E) then\n-                           Set_Is_Packed (Base_Type (E));\n-\n-                           if Is_Bit_Packed_Array (P) then\n-                              Set_Is_Bit_Packed_Array (Base_Type (E));\n-                              Set_Packed_Array_Impl_Type\n-                                (E, Packed_Array_Impl_Type (P));\n-                           end if;\n-                        end if;\n-\n-                     --  Scalar_Storage_Order\n-\n-                     when Aspect_Scalar_Storage_Order =>\n-                        if (Is_Record_Type (E) or else Is_Array_Type (E))\n-                          and then No (Get_Attribute_Definition_Clause\n-                                         (E, Attribute_Scalar_Storage_Order))\n-                          and then Reverse_Storage_Order (P)\n-                        then\n-                           Set_Reverse_Storage_Order (Base_Type (E));\n-\n-                           --  Clear default SSO indications, since the aspect\n-                           --  overrides the default.\n-\n-                           Set_SSO_Set_Low_By_Default  (Base_Type (E), False);\n-                           Set_SSO_Set_High_By_Default (Base_Type (E), False);\n-                        end if;\n-\n-                     --  Small\n-\n-                     when Aspect_Small =>\n-                        if Is_Fixed_Point_Type (E)\n-                          and then not Has_Small_Clause (E)\n-                        then\n-                           Set_Small_Value (E, Small_Value (P));\n-                        end if;\n-\n-                     --  Storage_Size\n-\n-                     when Aspect_Storage_Size =>\n-                        if (Is_Access_Type (E) or else Is_Task_Type (E))\n-                          and then not Has_Storage_Size_Clause (E)\n-                        then\n-                           Set_Storage_Size_Variable\n-                             (Base_Type (E), Storage_Size_Variable (P));\n-                        end if;\n-\n-                     --  Value_Size\n-\n-                     when Aspect_Value_Size =>\n-\n-                        --  Value_Size is never inherited, it is either set by\n-                        --  default, or it is explicitly set for the derived\n-                        --  type. So nothing to do here.\n-\n-                        null;\n-\n-                     --  Volatile\n-\n-                     when Aspect_Volatile =>\n-                        if Is_Volatile (P) then\n-                           Set_Is_Volatile (E);\n-                        end if;\n-\n-                     --  Volatile_Full_Access (also Full_Access_Only)\n-\n-                     when Aspect_Volatile_Full_Access\n-                        | Aspect_Full_Access_Only\n-                     =>\n-                        if Is_Volatile_Full_Access (P) then\n-                           Set_Is_Volatile_Full_Access (E);\n-                        end if;\n-\n-                     --  Volatile_Components\n-\n-                     when Aspect_Volatile_Components =>\n-                        if Has_Volatile_Components (P) then\n-                           Set_Has_Volatile_Components (Base_Type (E));\n-                        end if;\n-\n-                     --  That should be all the Rep Aspects\n-\n-                     when others =>\n-                        pragma Assert (Aspect_Delay (A_Id) /= Rep_Aspect);\n-                        null;\n-                  end case;\n-               end if;\n-            end if;\n-\n-            Next_Rep_Item (N);\n-         end loop;\n-      end Inherit_Delayed_Rep_Aspects;\n-\n       -------------------------------------\n       -- Make_Pragma_From_Boolean_Aspect --\n       -------------------------------------\n@@ -1600,15 +1384,6 @@ package body Sem_Ch13 is\n          Next_Rep_Item (ASN);\n       end loop;\n \n-      --  This is where we inherit delayed rep aspects from our parent. Note\n-      --  that if we fell out of the above loop with ASN non-empty, it means\n-      --  we hit an aspect for an entity other than E, and it must be the\n-      --  type from which we were derived.\n-\n-      if May_Inherit_Delayed_Rep_Aspects (E) then\n-         Inherit_Delayed_Rep_Aspects (ASN);\n-      end if;\n-\n       if In_Instance\n         and then E /= Base_Type (E)\n         and then Is_First_Subtype (E)\n@@ -13738,14 +13513,6 @@ package body Sem_Ch13 is\n       --  representation aspect in the rep item chain of Typ, if any, isn't\n       --  directly specified to Typ but to one of its parents.\n \n-      --  ??? Note that, for now, just a limited number of representation\n-      --  aspects have been inherited here so far. Many of them are\n-      --  still inherited in Sem_Ch3. This will be fixed soon. Here is\n-      --  a non- exhaustive list of aspects that likely also need to\n-      --  be moved to this routine: Alignment, Component_Alignment,\n-      --  Component_Size, Machine_Radix, Object_Size, Pack, Predicates,\n-      --  Preelaborable_Initialization, RM_Size and Small.\n-\n       --  In addition, Convention must be propagated from base type to subtype,\n       --  because the subtype may have been declared on an incomplete view.\n \n@@ -13813,9 +13580,21 @@ package body Sem_Ch13 is\n         and then not Has_Rep_Item (Typ, Name_Default_Component_Value, False)\n         and then Has_Rep_Item (Typ, Name_Default_Component_Value)\n       then\n-         Set_Default_Aspect_Component_Value (Typ,\n-           Default_Aspect_Component_Value\n-             (Entity (Get_Rep_Item (Typ, Name_Default_Component_Value))));\n+         declare\n+            E : Entity_Id;\n+\n+         begin\n+            E := Entity (Get_Rep_Item (Typ, Name_Default_Component_Value));\n+\n+            --  Deal with private types\n+\n+            if Is_Private_Type (E) then\n+               E := Full_View (E);\n+            end if;\n+\n+            Set_Default_Aspect_Component_Value (Typ,\n+              Default_Aspect_Component_Value (E));\n+         end;\n       end if;\n \n       --  Default_Value\n@@ -13826,9 +13605,21 @@ package body Sem_Ch13 is\n         and then Has_Rep_Item (Typ, Name_Default_Value)\n       then\n          Set_Has_Default_Aspect (Typ);\n-         Set_Default_Aspect_Value (Typ,\n-           Default_Aspect_Value\n-             (Entity (Get_Rep_Item (Typ, Name_Default_Value))));\n+\n+         declare\n+            E : Entity_Id;\n+\n+         begin\n+            E := Entity (Get_Rep_Item (Typ, Name_Default_Value));\n+\n+            --  Deal with private types\n+\n+            if Is_Private_Type (E) then\n+               E := Full_View (E);\n+            end if;\n+\n+            Set_Default_Aspect_Value (Typ, Default_Aspect_Value (E));\n+         end;\n       end if;\n \n       --  Discard_Names\n@@ -13956,6 +13747,209 @@ package body Sem_Ch13 is\n       end if;\n    end Inherit_Aspects_At_Freeze_Point;\n \n+   ---------------------------------\n+   -- Inherit_Delayed_Rep_Aspects --\n+   ---------------------------------\n+\n+   procedure Inherit_Delayed_Rep_Aspects (Typ : Entity_Id) is\n+      A : Aspect_Id;\n+      N : Node_Id;\n+      P : Entity_Id;\n+\n+   begin\n+      --  Find the first aspect that has been inherited\n+\n+      N := First_Rep_Item (Typ);\n+      while Present (N) loop\n+         if Nkind (N) = N_Aspect_Specification then\n+            exit when Entity (N) /= Typ;\n+         end if;\n+\n+         Next_Rep_Item (N);\n+      end loop;\n+\n+      --  There must be one if we reach here\n+\n+      pragma Assert (Present (N));\n+      P := Entity (N);\n+\n+      --  Loop through delayed aspects for the parent type\n+\n+      while Present (N) loop\n+         if Nkind (N) = N_Aspect_Specification then\n+            exit when Entity (N) /= P;\n+\n+            if Is_Delayed_Aspect (N) then\n+               A := Get_Aspect_Id (N);\n+\n+               --  Process delayed rep aspect. For Boolean attributes it is\n+               --  not possible to cancel an attribute once set (the attempt\n+               --  to use an aspect with xxx => False is an error) for a\n+               --  derived type. So for those cases, we do not have to check\n+               --  if a clause has been given for the derived type, since it\n+               --  is harmless to set it again if it is already set.\n+\n+               case A is\n+\n+                  --  Alignment\n+\n+                  when Aspect_Alignment =>\n+                     if not Has_Alignment_Clause (Typ) then\n+                        Set_Alignment (Typ, Alignment (P));\n+                     end if;\n+\n+                  --  Atomic\n+\n+                  when Aspect_Atomic =>\n+                     if Is_Atomic (P) then\n+                        Set_Is_Atomic (Typ);\n+                     end if;\n+\n+                  --  Atomic_Components\n+\n+                  when Aspect_Atomic_Components =>\n+                     if Has_Atomic_Components (P) then\n+                        Set_Has_Atomic_Components (Base_Type (Typ));\n+                     end if;\n+\n+                  --  Bit_Order\n+\n+                  when Aspect_Bit_Order =>\n+                     if Is_Record_Type (Typ)\n+                       and then No (Get_Attribute_Definition_Clause\n+                                      (Typ, Attribute_Bit_Order))\n+                       and then Reverse_Bit_Order (P)\n+                     then\n+                        Set_Reverse_Bit_Order (Base_Type (Typ));\n+                     end if;\n+\n+                  --  Component_Size\n+\n+                  when Aspect_Component_Size =>\n+                     if Is_Array_Type (Typ)\n+                       and then not Has_Component_Size_Clause (Typ)\n+                     then\n+                        Set_Component_Size\n+                          (Base_Type (Typ), Component_Size (P));\n+                     end if;\n+\n+                  --  Machine_Radix\n+\n+                  when Aspect_Machine_Radix =>\n+                     if Is_Decimal_Fixed_Point_Type (Typ)\n+                       and then not Has_Machine_Radix_Clause (Typ)\n+                     then\n+                        Set_Machine_Radix_10 (Typ, Machine_Radix_10 (P));\n+                     end if;\n+\n+                  --  Object_Size (also Size which also sets Object_Size)\n+\n+                  when Aspect_Object_Size\n+                     | Aspect_Size\n+                  =>\n+                     if not Has_Size_Clause (Typ)\n+                       and then\n+                         No (Get_Attribute_Definition_Clause\n+                               (Typ, Attribute_Object_Size))\n+                     then\n+                        Set_Esize (Typ, Esize (P));\n+                     end if;\n+\n+                  --  Pack\n+\n+                  when Aspect_Pack =>\n+                     if not Is_Packed (Typ) then\n+                        Set_Is_Packed (Base_Type (Typ));\n+\n+                        if Is_Bit_Packed_Array (P) then\n+                           Set_Is_Bit_Packed_Array (Base_Type (Typ));\n+                           Set_Packed_Array_Impl_Type\n+                             (Typ, Packed_Array_Impl_Type (P));\n+                        end if;\n+                     end if;\n+\n+                  --  Scalar_Storage_Order\n+\n+                  when Aspect_Scalar_Storage_Order =>\n+                     if (Is_Record_Type (Typ) or else Is_Array_Type (Typ))\n+                       and then No (Get_Attribute_Definition_Clause\n+                                      (Typ, Attribute_Scalar_Storage_Order))\n+                       and then Reverse_Storage_Order (P)\n+                     then\n+                        Set_Reverse_Storage_Order (Base_Type (Typ));\n+\n+                        --  Clear default SSO indications, since the aspect\n+                        --  overrides the default.\n+\n+                        Set_SSO_Set_Low_By_Default  (Base_Type (Typ), False);\n+                        Set_SSO_Set_High_By_Default (Base_Type (Typ), False);\n+                     end if;\n+\n+                  --  Small\n+\n+                  when Aspect_Small =>\n+                     if Is_Fixed_Point_Type (Typ)\n+                       and then not Has_Small_Clause (Typ)\n+                     then\n+                        Set_Small_Value (Typ, Small_Value (P));\n+                     end if;\n+\n+                  --  Storage_Size\n+\n+                  when Aspect_Storage_Size =>\n+                     if (Is_Access_Type (Typ) or else Is_Task_Type (Typ))\n+                       and then not Has_Storage_Size_Clause (Typ)\n+                     then\n+                        Set_Storage_Size_Variable\n+                          (Base_Type (Typ), Storage_Size_Variable (P));\n+                     end if;\n+\n+                  --  Value_Size\n+\n+                  when Aspect_Value_Size =>\n+\n+                     --  Value_Size is never inherited, it is either set by\n+                     --  default, or it is explicitly set for the derived\n+                     --  type. So nothing to do here.\n+\n+                     null;\n+\n+                  --  Volatile\n+\n+                  when Aspect_Volatile =>\n+                     if Is_Volatile (P) then\n+                        Set_Is_Volatile (Typ);\n+                     end if;\n+\n+                  --  Volatile_Full_Access (also Full_Access_Only)\n+\n+                  when Aspect_Volatile_Full_Access\n+                     | Aspect_Full_Access_Only\n+                  =>\n+                     if Is_Volatile_Full_Access (P) then\n+                        Set_Is_Volatile_Full_Access (Typ);\n+                     end if;\n+\n+                  --  Volatile_Components\n+\n+                  when Aspect_Volatile_Components =>\n+                     if Has_Volatile_Components (P) then\n+                        Set_Has_Volatile_Components (Base_Type (Typ));\n+                     end if;\n+\n+                  --  That should be all the Rep Aspects\n+\n+                  when others =>\n+                     pragma Assert (Aspect_Delay (A) /= Rep_Aspect);\n+                     null;\n+               end case;\n+            end if;\n+         end if;\n+\n+         Next_Rep_Item (N);\n+      end loop;\n+   end Inherit_Delayed_Rep_Aspects;\n+\n    ----------------\n    -- Initialize --\n    ----------------"}, {"sha": "1405f89f598358413da694363e35b9abaf7b4baa", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae035e3437c1ec7d96773b31e631ec121bb4153f/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae035e3437c1ec7d96773b31e631ec121bb4153f/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=ae035e3437c1ec7d96773b31e631ec121bb4153f", "patch": "@@ -324,6 +324,36 @@ package Sem_Ch13 is\n    --  Given an entity Typ that denotes a derived type or a subtype, this\n    --  routine performs the inheritance of aspects at the freeze point.\n \n+   --  ??? Note that, for now, just a limited number of representation aspects\n+   --  have been inherited here so far. Many of them are still inherited in\n+   --  Sem_Ch3 and need to be dealt with. Here is a non-exhaustive list of\n+   --  aspects that likely also need to be moved to this routine: Alignment,\n+   --  Component_Alignment, Component_Size, Machine_Radix, Object_Size, Pack,\n+   --  Predicates, Preelaborable_Initialization, Size and Small.\n+\n+   procedure Inherit_Delayed_Rep_Aspects (Typ : Entity_Id);\n+   --  As discussed in the spec of Aspects (see Aspect_Delay declaration),\n+   --  a derived type can inherit aspects from its parent which have been\n+   --  specified at the time of the derivation using an aspect, as in:\n+   --\n+   --    type A is range 1 .. 10\n+   --      with Size => Not_Defined_Yet;\n+   --    ..\n+   --    type B is new A;\n+   --    ..\n+   --    Not_Defined_Yet : constant := 64;\n+   --\n+   --  In this example, the Size of A is considered to be specified prior\n+   --  to the derivation, and thus inherited, even though the value is not\n+   --  known at the time of derivation. To deal with this, we use two entity\n+   --  flags. The flag Has_Derived_Rep_Aspects is set in the parent type (A\n+   --  here), and then the flag May_Inherit_Delayed_Rep_Aspects is set in\n+   --  the derived type (B here). If this flag is set when the derived type\n+   --  is frozen, then this procedure is called to ensure proper inheritance\n+   --  of all delayed aspects from the parent type.\n+\n+   --  ??? Obviously we ought not to have two mechanisms to do the same thing\n+\n    procedure Resolve_Aspect_Expressions (E : Entity_Id);\n    --  Name resolution of an aspect expression happens at the end of the\n    --  current declarative part or at the freeze point for the entity,"}, {"sha": "00c2e67fa20dd5558df6dd8e511b76347be1d381", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 23, "deletions": 60, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae035e3437c1ec7d96773b31e631ec121bb4153f/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae035e3437c1ec7d96773b31e631ec121bb4153f/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=ae035e3437c1ec7d96773b31e631ec121bb4153f", "patch": "@@ -7412,12 +7412,13 @@ package body Sem_Ch3 is\n             Analyze (High_Bound (Range_Expression (Constraint (Indic))));\n          end if;\n \n-         --  Introduce an implicit base type for the derived type even if there\n+         --  Create an implicit base type for the derived type even if there\n          --  is no constraint attached to it, since this seems closer to the\n-         --  Ada semantics. Build a full type declaration tree for the derived\n-         --  type using the implicit base type as the defining identifier. Then\n-         --  build a subtype declaration tree which applies the constraint (if\n-         --  any) have it replace the derived type declaration.\n+         --  Ada semantics. Use an Itype like for the implicit base type of\n+         --  other kinds of derived type, but build a full type declaration\n+         --  for it so as to analyze the new literals properly. Then build a\n+         --  subtype declaration tree which applies the constraint (if any)\n+         --  and have it replace the derived type declaration.\n \n          Literal := First_Literal (Parent_Type);\n          Literals_List := New_List;\n@@ -7450,8 +7451,7 @@ package body Sem_Ch3 is\n          end loop;\n \n          Implicit_Base :=\n-           Make_Defining_Identifier (Sloc (Derived_Type),\n-             Chars => New_External_Name (Chars (Derived_Type), 'B'));\n+           Create_Itype (E_Enumeration_Type, N, Derived_Type, 'B');\n \n          --  Indicate the proper nature of the derived type. This must be done\n          --  before analysis of the literals, to recognize cases when a literal\n@@ -7464,12 +7464,12 @@ package body Sem_Ch3 is\n          Type_Decl :=\n            Make_Full_Type_Declaration (Loc,\n              Defining_Identifier => Implicit_Base,\n-             Discriminant_Specifications => No_List,\n              Type_Definition =>\n                Make_Enumeration_Type_Definition (Loc, Literals_List));\n \n-         Mark_Rewrite_Insertion (Type_Decl);\n-         Insert_Before (N, Type_Decl);\n+         --  Do not insert the declarationn, just analyze it in the context\n+\n+         Set_Parent (Type_Decl, Parent (N));\n          Analyze (Type_Decl);\n \n          --  The anonymous base now has a full declaration, but this base\n@@ -7770,35 +7770,6 @@ package body Sem_Ch3 is\n       --  must be converted to the derived type.\n \n       Convert_Scalar_Bounds (N, Parent_Type, Derived_Type, Loc);\n-\n-      --  The implicit_base should be frozen when the derived type is frozen,\n-      --  but note that it is used in the conversions of the bounds. For fixed\n-      --  types we delay the determination of the bounds until the proper\n-      --  freezing point. For other numeric types this is rejected by GCC, for\n-      --  reasons that are currently unclear (???), so we choose to freeze the\n-      --  implicit base now. In the case of integers and floating point types\n-      --  this is harmless because subsequent representation clauses cannot\n-      --  affect anything, but it is still baffling that we cannot use the\n-      --  same mechanism for all derived numeric types.\n-\n-      --  There is a further complication: actually some representation\n-      --  clauses can affect the implicit base type. For example, attribute\n-      --  definition clauses for stream-oriented attributes need to set the\n-      --  corresponding TSS entries on the base type, and this normally\n-      --  cannot be done after the base type is frozen, so the circuitry in\n-      --  Sem_Ch13.New_Stream_Subprogram must account for this possibility\n-      --  and not use Set_TSS in this case.\n-\n-      --  There are also consequences for the case of delayed representation\n-      --  aspects for some cases. For example, a Size aspect is delayed and\n-      --  should not be evaluated to the freeze point. This early freezing\n-      --  means that the size attribute evaluation happens too early???\n-\n-      if Is_Fixed_Point_Type (Parent_Type) then\n-         Conditional_Delay (Implicit_Base, Parent_Type);\n-      else\n-         Freeze_Before (N, Implicit_Base);\n-      end if;\n    end Build_Derived_Numeric_Type;\n \n    --------------------------------\n@@ -14443,14 +14414,18 @@ package body Sem_Ch3 is\n    begin\n       Mutate_Ekind (Def_Id, E_Enumeration_Subtype);\n \n-      Set_First_Literal     (Def_Id, First_Literal (Base_Type (T)));\n+      Set_First_Literal            (Def_Id, First_Literal (Base_Type (T)));\n+      Set_Etype                    (Def_Id, Base_Type         (T));\n+      Set_Size_Info                (Def_Id,                   (T));\n+      Set_Is_Character_Type        (Def_Id, Is_Character_Type (T));\n+      Set_Scalar_Range_For_Subtype (Def_Id, Range_Expression (C), T);\n \n-      Set_Etype             (Def_Id, Base_Type         (T));\n-      Set_Size_Info         (Def_Id,                   (T));\n-      Set_First_Rep_Item    (Def_Id, First_Rep_Item    (T));\n-      Set_Is_Character_Type (Def_Id, Is_Character_Type (T));\n+      --  Inherit the chain of representation items instead of replacing it\n+      --  because Build_Derived_Enumeration_Type rewrites the declaration of\n+      --  the derived type as a subtype declaration and the former needs to\n+      --  preserve existing representation items (see Build_Derived_Type).\n \n-      Set_Scalar_Range_For_Subtype (Def_Id, Range_Expression (C), T);\n+      Inherit_Rep_Item_Chain (Def_Id, T);\n \n       Set_Discrete_RM_Size (Def_Id);\n    end Constrain_Enumeration;\n@@ -16992,11 +16967,9 @@ package body Sem_Ch3 is\n           Low_Bound  => Lo,\n           High_Bound => Hi));\n \n-      Conditional_Delay (Derived_Type, Parent_Type);\n-\n-      Mutate_Ekind (Derived_Type, E_Enumeration_Subtype);\n-      Set_Etype (Derived_Type, Implicit_Base);\n-      Set_Size_Info         (Derived_Type, Parent_Type);\n+      Mutate_Ekind  (Derived_Type, E_Enumeration_Subtype);\n+      Set_Etype     (Derived_Type, Implicit_Base);\n+      Set_Size_Info (Derived_Type, Parent_Type);\n \n       if not Known_RM_Size (Derived_Type) then\n          Set_RM_Size (Derived_Type, RM_Size (Parent_Type));\n@@ -17015,16 +16988,6 @@ package body Sem_Ch3 is\n       end if;\n \n       Convert_Scalar_Bounds (N, Parent_Type, Derived_Type, Loc);\n-\n-      --  Because the implicit base is used in the conversion of the bounds, we\n-      --  have to freeze it now. This is similar to what is done for numeric\n-      --  types, and it equally suspicious, but otherwise a nonstatic bound\n-      --  will have a reference to an unfrozen type, which is rejected by Gigi\n-      --  (???). This requires specific care for definition of stream\n-      --  attributes. For details, see comments at the end of\n-      --  Build_Derived_Numeric_Type.\n-\n-      Freeze_Before (N, Implicit_Base);\n    end Derived_Standard_Character;\n \n    ------------------------------"}]}