{"sha": "8c36698e5207d286292375e844faf9c95c35ce42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGMzNjY5OGU1MjA3ZDI4NjI5MjM3NWU4NDRmYWY5Yzk1YzM1Y2U0Mg==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1999-11-05T10:11:40Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1999-11-05T10:11:40Z"}, "message": "If purge_addressof_1 fails to remove addressofs in notes, remove the notes\ninstead.\n\nFrom-SVN: r30414", "tree": {"sha": "430f1e20192cbb2ad005a7f482d2aa53b09d1313", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/430f1e20192cbb2ad005a7f482d2aa53b09d1313"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c36698e5207d286292375e844faf9c95c35ce42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c36698e5207d286292375e844faf9c95c35ce42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c36698e5207d286292375e844faf9c95c35ce42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c36698e5207d286292375e844faf9c95c35ce42/comments", "author": null, "committer": null, "parents": [{"sha": "ce82ff5c170684904ab924965c1ed6e1b4b30853", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce82ff5c170684904ab924965c1ed6e1b4b30853", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce82ff5c170684904ab924965c1ed6e1b4b30853"}], "stats": {"total": 98, "additions": 75, "deletions": 23}, "files": [{"sha": "8be07eae1d4c1105802e5e0189104456b56562c0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c36698e5207d286292375e844faf9c95c35ce42/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c36698e5207d286292375e844faf9c95c35ce42/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8c36698e5207d286292375e844faf9c95c35ce42", "patch": "@@ -1,3 +1,13 @@\n+Fri Nov  5 10:07:25 1999  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* function.c (is_addressof): New function.  Returns true if\n+\tthe given piece of RTL is an ADDRESSOF.\n+\t(purge_addressof_1): Make boolean.  Return false if the\n+\tADDRESSOFs could not be purged.\n+\t(purge_addressof): If ADDRESSOFs could not be purged from the\n+\tnotes attached to an insn, remove the offending note(s),\n+\tunless they are attached to a libcall.\n+\n 1999-11-05  Andreas Jaeger  <aj@suse.de>\n \n \t* genoutput.c (null_operand =): Initialize all fields."}, {"sha": "c9b4e20de86346b2a3b97fbc2e10c43ec1ddffbc", "filename": "gcc/function.c", "status": "modified", "additions": 65, "deletions": 23, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c36698e5207d286292375e844faf9c95c35ce42/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c36698e5207d286292375e844faf9c95c35ce42/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=8c36698e5207d286292375e844faf9c95c35ce42", "patch": "@@ -268,8 +268,9 @@ static int all_blocks\t\tPROTO((tree, tree *));\n static int *record_insns\tPROTO((rtx)) ATTRIBUTE_UNUSED;\n static int contains\t\tPROTO((rtx, int *));\n static void put_addressof_into_stack PROTO((rtx, struct hash_table *));\n-static void purge_addressof_1\tPROTO((rtx *, rtx, int, int, \n+static boolean purge_addressof_1 PROTO((rtx *, rtx, int, int, \n \t\t\t\t       struct hash_table *));\n+static int is_addressof\t\tPROTO ((rtx *, void *));\n static struct hash_entry *insns_for_mem_newfunc PROTO((struct hash_entry *,\n \t\t\t\t\t\t       struct hash_table *,\n \t\t\t\t\t\t       hash_table_key));\n@@ -2765,9 +2766,10 @@ static rtx purge_addressof_replacements;\n \n /* Helper function for purge_addressof.  See if the rtx expression at *LOC\n    in INSN needs to be changed.  If FORCE, always put any ADDRESSOFs into\n-   the stack.  */\n+   the stack.  If the function returns FALSE then the replacement could not\n+   be made.  */\n \n-static void\n+static boolean\n purge_addressof_1 (loc, insn, force, store, ht)\n      rtx *loc;\n      rtx insn;\n@@ -2778,13 +2780,14 @@ purge_addressof_1 (loc, insn, force, store, ht)\n   RTX_CODE code;\n   int i, j;\n   const char *fmt;\n+  boolean result = true;\n \n   /* Re-start here to avoid recursion in common cases.  */\n  restart:\n \n   x = *loc;\n   if (x == 0)\n-    return;\n+    return true;\n \n   code = GET_CODE (x);\n \n@@ -2793,9 +2796,9 @@ purge_addressof_1 (loc, insn, force, store, ht)\n      memory.  */\n   if (code == SET)\n     {\n-      purge_addressof_1 (&SET_DEST (x), insn, force, 1, ht);\n-      purge_addressof_1 (&SET_SRC (x), insn, force, 0, ht);\n-      return;\n+      result = purge_addressof_1 (&SET_DEST (x), insn, force, 1, ht);\n+      result &= purge_addressof_1 (&SET_SRC (x), insn, force, 0, ht);\n+      return result;\n     }\n \n   else if (code == ADDRESSOF && GET_CODE (XEXP (x, 0)) == MEM)\n@@ -2807,7 +2810,7 @@ purge_addressof_1 (loc, insn, force, store, ht)\n \n       if (validate_change (insn, loc, sub, 0)\n \t  || validate_replace_rtx (x, sub, insn))\n-\treturn;\n+\treturn true;\n   \n       start_sequence ();\n       sub = force_operand (sub, NULL_RTX);\n@@ -2818,7 +2821,7 @@ purge_addressof_1 (loc, insn, force, store, ht)\n       insns = gen_sequence ();\n       end_sequence ();\n       emit_insn_before (insns, insn);\n-      return;\n+      return true;\n     }\n \n   else if (code == MEM && GET_CODE (XEXP (x, 0)) == ADDRESSOF && ! force)\n@@ -2853,7 +2856,7 @@ purge_addressof_1 (loc, insn, force, store, ht)\n \t\tif (rtx_equal_p (x, XEXP (tem, 0)))\n \t\t  {\n \t\t    *loc = XEXP (XEXP (tem, 1), 0);\n-\t\t    return;\n+\t\t    return true;\n \t\t  }\n \n \t      /* See comment for purge_addressof_replacements. */\n@@ -2896,8 +2899,14 @@ purge_addressof_1 (loc, insn, force, store, ht)\n \t\t    return;\n \t\t  }\n \n-\t      /* There should always be such a replacement.  */\n-\t      abort ();\n+\t      /* Sometimes we may not be able to find the replacement.  For\n+\t\t example when the original insn was a MEM in a wider mode,\n+\t\t and the note is part of a sign extension of a narrowed\n+\t\t version of that MEM.  Gcc testcase compile/990829-1.c can\n+\t\t generate an example of this siutation.  Rather than complain\n+\t\t we return false, which will prompt our caller to remove the\n+\t\t offending note.  */\n+\t      return false;\n \t    }\n \n \t  size_x = GET_MODE_BITSIZE (GET_MODE (x));\n@@ -2989,7 +2998,7 @@ purge_addressof_1 (loc, insn, force, store, ht)\n \t\t\t\t      purge_bitfield_addressof_replacements));\n \n \t      /* We replaced with a reg -- all done.  */\n-\t      return;\n+\t      return true;\n \t    }\n \t}\n \n@@ -3007,13 +3016,13 @@ purge_addressof_1 (loc, insn, force, store, ht)\n \t\tif (rtx_equal_p (XEXP (x, 0), XEXP (tem, 0)))\n \t\t  {\n \t\t    XEXP (XEXP (tem, 1), 0) = sub;\n-\t\t    return;\n+\t\t    return true;\n \t\t  }\n \t      purge_addressof_replacements\n \t\t= gen_rtx (EXPR_LIST, VOIDmode, XEXP (x, 0),\n \t\t\t   gen_rtx_EXPR_LIST (VOIDmode, sub,\n \t\t\t\t\t      purge_addressof_replacements));\n-\t      return;\n+\t      return true;\n \t    }\n \t  goto restart;\n \t}\n@@ -3028,21 +3037,23 @@ purge_addressof_1 (loc, insn, force, store, ht)\n     }\n   else if (code == SET)\n     {\n-      purge_addressof_1 (&SET_DEST (x), insn, force, 1, ht);\n-      purge_addressof_1 (&SET_SRC (x), insn, force, 0, ht);\n-      return;\n+      result = purge_addressof_1 (&SET_DEST (x), insn, force, 1, ht);\n+      result &= purge_addressof_1 (&SET_SRC (x), insn, force, 0, ht);\n+      return result;\n     }\n \n   /* Scan all subexpressions. */\n   fmt = GET_RTX_FORMAT (code);\n   for (i = 0; i < GET_RTX_LENGTH (code); i++, fmt++)\n     {\n       if (*fmt == 'e')\n-\tpurge_addressof_1 (&XEXP (x, i), insn, force, 0, ht);\n+\tresult &= purge_addressof_1 (&XEXP (x, i), insn, force, 0, ht);\n       else if (*fmt == 'E')\n \tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  purge_addressof_1 (&XVECEXP (x, i, j), insn, force, 0, ht);\n+\t  result &= purge_addressof_1 (&XVECEXP (x, i, j), insn, force, 0, ht);\n     }\n+\n+  return result;\n }\n \n /* Return a new hash table entry in HT.  */\n@@ -3162,6 +3173,16 @@ compute_insns_for_mem (insns, last_insn, ht)\n \t}\n }\n \n+/* Helper function for purge_addressof called through for_each_rtx.\n+   Returns true iff the rtl is an ADDRESSOF.  */\n+static int\n+is_addressof (rtl, data)\n+     rtx * rtl;\n+     void * data ATTRIBUTE_UNUSED;\n+{\n+  return GET_CODE (* rtl) == ADDRESSOF;\n+}\n+\n /* Eliminate all occurrences of ADDRESSOF from INSNS.  Elide any remaining\n    (MEM (ADDRESSOF)) patterns, and force any needed registers into the\n    stack.  */\n@@ -3190,9 +3211,30 @@ purge_addressof (insns)\n     if (GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN\n \t|| GET_CODE (insn) == CALL_INSN)\n       {\n-\tpurge_addressof_1 (&PATTERN (insn), insn,\n-\t\t\t   asm_noperands (PATTERN (insn)) > 0, 0, &ht);\n-\tpurge_addressof_1 (&REG_NOTES (insn), NULL_RTX, 0, 0, &ht);\n+\tif (! purge_addressof_1 (&PATTERN (insn), insn,\n+\t\t\t\t asm_noperands (PATTERN (insn)) > 0, 0, &ht))\n+\t  /* If we could not replace the ADDRESSOFs in the insn,\n+\t     something is wrong.  */\n+\t  abort ();\n+\t\n+\tif (! purge_addressof_1 (&REG_NOTES (insn), NULL_RTX, 0, 0, &ht))\n+\t  {\n+\t    /* If we could not replace the ADDRESSOFs in the insn's notes,\n+\t       we can just remove the offending notes instead.  */\n+\t    rtx note;\n+\n+\t    for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+\t      {\n+\t\t/* If we find a REG_RETVAL note then the insn is a libcall.\n+\t\t   Such insns must have REG_EQUAL notes as well, in order\n+\t\t   for later passes of the compiler to work.  So it is not\n+\t\t   safe to delete the notes here, and instead we abort.  */\n+\t\tif (REG_NOTE_KIND (note) == REG_RETVAL)\n+\t\t  abort ();\n+\t\tif (for_each_rtx (& note, is_addressof, NULL))\n+\t\t  remove_note (insn, note);\n+\t      }\n+\t  }\n       }\n \n   /* Clean up.  */"}]}