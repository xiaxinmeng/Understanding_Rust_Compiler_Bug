{"sha": "8b8f3117263ca79b3febadadb07732588d99d5f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI4ZjMxMTcyNjNjYTc5YjNmZWJhZGFkYjA3NzMyNTg4ZDk5ZDVmNg==", "commit": {"author": {"name": "Alex Coplan", "email": "alex.coplan@arm.com", "date": "2020-05-18T15:29:04Z"}, "committer": {"name": "Alex Coplan", "email": "alex.coplan@arm.com", "date": "2020-05-18T15:31:43Z"}, "message": "[arm] Don't generate invalid LDRD insns\n\nThis fixes a bug in the arm backend where GCC generates invalid LDRD\ninstructions. The LDRD instruction requires the first transfer register to be\neven, but GCC attempts to use odd registers here. For example, with the\nfollowing C code:\n\n    struct c {\n      double a;\n    } __attribute((aligned)) __attribute((packed));\n    struct c d;\n    struct c f(struct c);\n    void e() { f(d); }\n\nThe struct d is passed in registers r1 and r2 to the function f, and GCC\nattempted to do this with a LDRD instruction when compiling with -march=armv7-a\non a soft float toolchain.\n\nThe fix is analogous to the corresponding one for STRD in the same function:\nhttps://gcc.gnu.org/git/?p=gcc.git;a=commit;h=52057dc4ac5295caebf83147f688d769c93cbc8d\n\n2020-05-18  Alex Coplan  <alex.coplan@arm.com>\n\ngcc/:\n\t* config/arm/arm.c (output_move_double): Fix codegen when loading into\n\ta register pair with an odd base register.\n\ngcc/testsuite/:\n\t* gcc.c-torture/compile/packed-aligned-1.c: New test.\n\t* gcc.c-torture/execute/packed-aligned.c: New test.", "tree": {"sha": "d6cebeaf9f743b78ad81dc883005418a59d2172e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6cebeaf9f743b78ad81dc883005418a59d2172e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b8f3117263ca79b3febadadb07732588d99d5f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b8f3117263ca79b3febadadb07732588d99d5f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b8f3117263ca79b3febadadb07732588d99d5f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b8f3117263ca79b3febadadb07732588d99d5f6/comments", "author": {"login": "acoplan-arm", "id": 86676934, "node_id": "MDQ6VXNlcjg2Njc2OTM0", "avatar_url": "https://avatars.githubusercontent.com/u/86676934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/acoplan-arm", "html_url": "https://github.com/acoplan-arm", "followers_url": "https://api.github.com/users/acoplan-arm/followers", "following_url": "https://api.github.com/users/acoplan-arm/following{/other_user}", "gists_url": "https://api.github.com/users/acoplan-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/acoplan-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/acoplan-arm/subscriptions", "organizations_url": "https://api.github.com/users/acoplan-arm/orgs", "repos_url": "https://api.github.com/users/acoplan-arm/repos", "events_url": "https://api.github.com/users/acoplan-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/acoplan-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "acoplan-arm", "id": 86676934, "node_id": "MDQ6VXNlcjg2Njc2OTM0", "avatar_url": "https://avatars.githubusercontent.com/u/86676934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/acoplan-arm", "html_url": "https://github.com/acoplan-arm", "followers_url": "https://api.github.com/users/acoplan-arm/followers", "following_url": "https://api.github.com/users/acoplan-arm/following{/other_user}", "gists_url": "https://api.github.com/users/acoplan-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/acoplan-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/acoplan-arm/subscriptions", "organizations_url": "https://api.github.com/users/acoplan-arm/orgs", "repos_url": "https://api.github.com/users/acoplan-arm/repos", "events_url": "https://api.github.com/users/acoplan-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/acoplan-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94f687bd9ae37ece9391a3c42783c5768d26e81d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94f687bd9ae37ece9391a3c42783c5768d26e81d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94f687bd9ae37ece9391a3c42783c5768d26e81d"}], "stats": {"total": 76, "additions": 64, "deletions": 12}, "files": [{"sha": "dffe88fdcca713d869a4d3d15d727a5c2208c338", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b8f3117263ca79b3febadadb07732588d99d5f6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b8f3117263ca79b3febadadb07732588d99d5f6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b8f3117263ca79b3febadadb07732588d99d5f6", "patch": "@@ -1,3 +1,8 @@\n+2020-05-18  Alex Coplan  <alex.coplan@arm.com>\n+\n+\t* config/arm/arm.c (output_move_double): Fix codegen when loading into\n+\ta register pair with an odd base register.\n+\n 2020-05-18  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386-expand.c (ix86_expand_fp_absneg_operator):"}, {"sha": "635e7adac452ed06b8947747e5d53c04eca324d1", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b8f3117263ca79b3febadadb07732588d99d5f6/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b8f3117263ca79b3febadadb07732588d99d5f6/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=8b8f3117263ca79b3febadadb07732588d99d5f6", "patch": "@@ -19575,6 +19575,7 @@ output_move_double (rtx *operands, bool emit, int *count)\n   if (code0 == REG)\n     {\n       unsigned int reg0 = REGNO (operands[0]);\n+      const bool can_ldrd = TARGET_LDRD && (TARGET_THUMB2 || (reg0 % 2 == 0));\n \n       otherops[0] = gen_rtx_REG (SImode, 1 + reg0);\n \n@@ -19586,7 +19587,7 @@ output_move_double (rtx *operands, bool emit, int *count)\n \n \t  if (emit)\n \t    {\n-\t      if (TARGET_LDRD\n+\t      if (can_ldrd\n \t\t  && !(fix_cm3_ldrd && reg0 == REGNO(XEXP (operands[1], 0))))\n \t\toutput_asm_insn (\"ldrd%?\\t%0, [%m1]\", operands);\n \t      else\n@@ -19595,15 +19596,15 @@ output_move_double (rtx *operands, bool emit, int *count)\n \t  break;\n \n \tcase PRE_INC:\n-\t  gcc_assert (TARGET_LDRD);\n+\t  gcc_assert (can_ldrd);\n \t  if (emit)\n \t    output_asm_insn (\"ldrd%?\\t%0, [%m1, #8]!\", operands);\n \t  break;\n \n \tcase PRE_DEC:\n \t  if (emit)\n \t    {\n-\t      if (TARGET_LDRD)\n+\t      if (can_ldrd)\n \t\toutput_asm_insn (\"ldrd%?\\t%0, [%m1, #-8]!\", operands);\n \t      else\n \t\toutput_asm_insn (\"ldmdb%?\\t%m1!, %M0\", operands);\n@@ -19613,15 +19614,15 @@ output_move_double (rtx *operands, bool emit, int *count)\n \tcase POST_INC:\n \t  if (emit)\n \t    {\n-\t      if (TARGET_LDRD)\n+\t      if (can_ldrd)\n \t\toutput_asm_insn (\"ldrd%?\\t%0, [%m1], #8\", operands);\n \t      else\n \t\toutput_asm_insn (\"ldmia%?\\t%m1!, %M0\", operands);\n \t    }\n \t  break;\n \n \tcase POST_DEC:\n-\t  gcc_assert (TARGET_LDRD);\n+\t  gcc_assert (can_ldrd);\n \t  if (emit)\n \t    output_asm_insn (\"ldrd%?\\t%0, [%m1], #-8\", operands);\n \t  break;\n@@ -19643,6 +19644,7 @@ output_move_double (rtx *operands, bool emit, int *count)\n \t\t  /* Registers overlap so split out the increment.  */\n \t\t  if (emit)\n \t\t    {\n+\t\t      gcc_assert (can_ldrd);\n \t\t      output_asm_insn (\"add%?\\t%1, %1, %2\", otherops);\n \t\t      output_asm_insn (\"ldrd%?\\t%0, [%1] @split\", otherops);\n \t\t    }\n@@ -19654,10 +19656,11 @@ output_move_double (rtx *operands, bool emit, int *count)\n \t\t  /* Use a single insn if we can.\n \t\t     FIXME: IWMMXT allows offsets larger than ldrd can\n \t\t     handle, fix these up with a pair of ldr.  */\n-\t\t  if (TARGET_THUMB2\n+\t\t  if (can_ldrd\n+\t\t      && (TARGET_THUMB2\n \t\t      || !CONST_INT_P (otherops[2])\n \t\t      || (INTVAL (otherops[2]) > -256\n-\t\t\t  && INTVAL (otherops[2]) < 256))\n+\t\t\t  && INTVAL (otherops[2]) < 256)))\n \t\t    {\n \t\t      if (emit)\n \t\t\toutput_asm_insn (\"ldrd%?\\t%0, [%1, %2]!\", otherops);\n@@ -19680,10 +19683,11 @@ output_move_double (rtx *operands, bool emit, int *count)\n \t      /* Use a single insn if we can.\n \t\t FIXME: IWMMXT allows offsets larger than ldrd can handle,\n \t\t fix these up with a pair of ldr.  */\n-\t      if (TARGET_THUMB2\n+\t      if (can_ldrd\n+\t\t  && (TARGET_THUMB2\n \t\t  || !CONST_INT_P (otherops[2])\n \t\t  || (INTVAL (otherops[2]) > -256\n-\t\t      && INTVAL (otherops[2]) < 256))\n+\t\t      && INTVAL (otherops[2]) < 256)))\n \t\t{\n \t\t  if (emit)\n \t\t    output_asm_insn (\"ldrd%?\\t%0, [%1], %2\", otherops);\n@@ -19714,7 +19718,7 @@ output_move_double (rtx *operands, bool emit, int *count)\n \t  operands[1] = otherops[0];\n \t  if (emit)\n \t    {\n-\t      if (TARGET_LDRD)\n+\t      if (can_ldrd)\n \t\toutput_asm_insn (\"ldrd%?\\t%0, [%1]\", operands);\n \t      else\n \t\toutput_asm_insn (\"ldmia%?\\t%1, %M0\", operands);\n@@ -19759,7 +19763,7 @@ output_move_double (rtx *operands, bool emit, int *count)\n \t\t    }\n \t\t  otherops[0] = gen_rtx_REG(SImode, REGNO(operands[0]) + 1);\n \t\t  operands[1] = otherops[0];\n-\t\t  if (TARGET_LDRD\n+\t\t  if (can_ldrd\n \t\t      && (REG_P (otherops[2])\n \t\t\t  || TARGET_THUMB2\n \t\t\t  || (CONST_INT_P (otherops[2])\n@@ -19820,7 +19824,7 @@ output_move_double (rtx *operands, bool emit, int *count)\n \t      if (count)\n \t\t*count = 2;\n \n-\t      if (TARGET_LDRD)\n+\t      if (can_ldrd)\n \t\treturn \"ldrd%?\\t%0, [%1]\";\n \n \t      return \"ldmia%?\\t%1, %M0\";"}, {"sha": "89423f5dfb9967510af0e49f0a2760aa042d7ba7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b8f3117263ca79b3febadadb07732588d99d5f6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b8f3117263ca79b3febadadb07732588d99d5f6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8b8f3117263ca79b3febadadb07732588d99d5f6", "patch": "@@ -1,3 +1,7 @@\n+2020-05-18  Alex Coplan  <alex.coplan@arm.com>\n+\t* gcc.c-torture/compile/packed-aligned-1.c: New test.\n+\t* gcc.c-torture/execute/packed-aligned.c: New test.\n+\n 2020-05-18  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/95171"}, {"sha": "9f0923e29ee5f3e6700519e23dd366448954b501", "filename": "gcc/testsuite/gcc.c-torture/compile/packed-aligned-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b8f3117263ca79b3febadadb07732588d99d5f6/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpacked-aligned-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b8f3117263ca79b3febadadb07732588d99d5f6/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpacked-aligned-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpacked-aligned-1.c?ref=8b8f3117263ca79b3febadadb07732588d99d5f6", "patch": "@@ -0,0 +1,11 @@\n+struct c {\n+  double a;\n+} __attribute((packed)) __attribute((aligned));\n+\n+void f(struct c *, struct c);\n+\n+void g(struct c *ptr)\n+{\n+  ptr++;\n+  f(ptr, *ptr);\n+}"}, {"sha": "f768af0ab024f19f207611ad5b55d1b13dc51ec1", "filename": "gcc/testsuite/gcc.c-torture/execute/packed-aligned.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b8f3117263ca79b3febadadb07732588d99d5f6/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpacked-aligned.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b8f3117263ca79b3febadadb07732588d99d5f6/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpacked-aligned.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpacked-aligned.c?ref=8b8f3117263ca79b3febadadb07732588d99d5f6", "patch": "@@ -0,0 +1,28 @@\n+struct c {\n+  double a;\n+} __attribute((packed)) __attribute((aligned));\n+\n+extern void abort(void);\n+\n+double g_expect = 32.25;\n+\n+void f(unsigned x, struct c y)\n+{\n+  if (x != 0)\n+    abort();\n+\n+  if (y.a != g_expect)\n+    abort();\n+}\n+\n+struct c e = { 64.25 };\n+\n+int main(void)\n+{\n+  struct c d = { 32.25 };\n+  f(0, d);\n+\n+  g_expect = 64.25;\n+  f(0, e);\n+  return 0;\n+}"}]}