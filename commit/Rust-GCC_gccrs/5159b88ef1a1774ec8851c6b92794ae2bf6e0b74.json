{"sha": "5159b88ef1a1774ec8851c6b92794ae2bf6e0b74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE1OWI4OGVmMWExNzc0ZWM4ODUxYzZiOTI3OTRhZTJiZjZlMGI3NA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2021-02-24T16:00:51Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2021-02-24T16:01:08Z"}, "message": "Fortran: Fix memory problems with assumed rank formal args [PR98342].\n\n2021-02-24  Paul Thomas  <pault@gcc.gnu.org>\n\ngcc/fortran\n\tPR fortran/98342\n\t* trans-expr.c (gfc_conv_derived_to_class): Add optional arg.\n\t'derived_array' to hold the fixed, parmse expr in the case of\n\tassumed rank formal arguments. Deal with optional arguments.\n\t(gfc_conv_procedure_call): Null 'derived' array for each actual\n\targument. Add its address to the call to gfc_conv_derived_to_\n\tclass. Access the 'data' field of scalar descriptors before\n\tdeallocating allocatable components. Also strip NOPs before the\n\tcalls to gfc_deallocate_alloc_comp. Use 'derived' array as the\n\tinput to gfc_deallocate_alloc_comp if it is available.\n\t* trans.h : Include the optional argument 'derived_array' to\n\tthe prototype of gfc_conv_derived_to_class. The default value\n\tis NULL_TREE.\n\ngcc/testsuite/\n\tPR fortran/98342\n\t* gfortran.dg/assumed_rank_21.f90 : New test.", "tree": {"sha": "777a8c1edad455148d80dd771ad40a8ac6028d49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/777a8c1edad455148d80dd771ad40a8ac6028d49"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5159b88ef1a1774ec8851c6b92794ae2bf6e0b74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5159b88ef1a1774ec8851c6b92794ae2bf6e0b74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5159b88ef1a1774ec8851c6b92794ae2bf6e0b74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5159b88ef1a1774ec8851c6b92794ae2bf6e0b74/comments", "author": null, "committer": null, "parents": [{"sha": "be30dd89926d5dd19d72f90c1586b0e2557fde43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be30dd89926d5dd19d72f90c1586b0e2557fde43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be30dd89926d5dd19d72f90c1586b0e2557fde43"}], "stats": {"total": 138, "additions": 131, "deletions": 7}, "files": [{"sha": "85c16d7f4c3df97d333818e182235e909f92567e", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5159b88ef1a1774ec8851c6b92794ae2bf6e0b74/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5159b88ef1a1774ec8851c6b92794ae2bf6e0b74/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=5159b88ef1a1774ec8851c6b92794ae2bf6e0b74", "patch": "@@ -613,11 +613,15 @@ class_array_data_assign (stmtblock_t *block, tree lhs_desc, tree rhs_desc,\n    class object of the 'declared' type.  If vptr is not NULL, this is\n    used for the temporary class object.\n    optional_alloc_ptr is false when the dummy is neither allocatable\n-   nor a pointer; that's only relevant for the optional handling.  */\n+   nor a pointer; that's only relevant for the optional handling.\n+   The optional argument 'derived_array' is used to preserve the parmse\n+   expression for deallocation of allocatable components. Assumed rank\n+   formal arguments made this necessary.  */\n void\n gfc_conv_derived_to_class (gfc_se *parmse, gfc_expr *e,\n \t\t\t   gfc_typespec class_ts, tree vptr, bool optional,\n-\t\t\t   bool optional_alloc_ptr)\n+\t\t\t   bool optional_alloc_ptr,\n+\t\t\t   tree *derived_array)\n {\n   gfc_symbol *vtab;\n   tree cond_optional = NULL_TREE;\n@@ -747,6 +751,13 @@ gfc_conv_derived_to_class (gfc_se *parmse, gfc_expr *e,\n \t    {\n \t      gcc_assert (class_ts.u.derived->components->as->type\n \t\t\t  == AS_ASSUMED_RANK);\n+\t      if (derived_array\n+\t\t  && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (parmse->expr)))\n+\t\t{\n+\t\t  *derived_array = gfc_create_var (TREE_TYPE (parmse->expr),\n+\t\t\t\t\t\t   \"array\");\n+\t\t  gfc_add_modify (&block, *derived_array , parmse->expr);\n+\t\t}\n \t      class_array_data_assign (&block, ctree, parmse->expr, false);\n \t    }\n \t  else\n@@ -765,6 +776,9 @@ gfc_conv_derived_to_class (gfc_se *parmse, gfc_expr *e,\n \n \t      gfc_init_block (&block);\n \t      gfc_conv_descriptor_data_set (&block, ctree, null_pointer_node);\n+\t      if (derived_array && *derived_array != NULL_TREE)\n+\t\tgfc_conv_descriptor_data_set (&block, *derived_array,\n+\t\t\t\t\t      null_pointer_node);\n \n \t      tmp = build3_v (COND_EXPR, cond_optional, tmp,\n \t\t\t      gfc_finish_block (&block));\n@@ -5665,6 +5679,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n     {\n       bool finalized = false;\n       bool non_unity_length_string = false;\n+      tree derived_array = NULL_TREE;\n \n       e = arg->expr;\n       fsym = formal ? formal->sym : NULL;\n@@ -5770,7 +5785,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t\t     && e->expr_type == EXPR_VARIABLE\n \t\t\t\t     && e->symtree->n.sym->attr.optional,\n \t\t\t\t     CLASS_DATA (fsym)->attr.class_pointer\n-\t\t\t\t     || CLASS_DATA (fsym)->attr.allocatable);\n+\t\t\t\t     || CLASS_DATA (fsym)->attr.allocatable,\n+\t\t\t\t     &derived_array);\n \t}\n       else if (UNLIMITED_POLY (fsym) && e->ts.type != BT_CLASS\n \t       && gfc_expr_attr (e).flavor != FL_PROCEDURE)\n@@ -6595,6 +6611,12 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t\t\t&& parm_rank == 0\n \t\t\t\t\t&& parmse.loop;\n \n+\t      /* Scalars passed to an assumed rank argument are converted to\n+\t\t a descriptor. Obtain the data field before deallocating any\n+\t\t allocatable components.  */\n+\t      if (parm_rank == 0 && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (tmp)))\n+\t\ttmp = gfc_conv_descriptor_data_get (tmp);\n+\n \t      if (scalar_res_outside_loop)\n \t\t{\n \t\t  /* Go through the ss chain to find the argument and use\n@@ -6610,9 +6632,15 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t      }\n \t\t}\n \n-\t      if ((e->ts.type == BT_CLASS\n-\t\t   && GFC_CLASS_TYPE_P (TREE_TYPE (tmp)))\n-\t\t  || e->ts.type == BT_DERIVED)\n+\t      STRIP_NOPS (tmp);\n+\n+\t      if (derived_array != NULL_TREE)\n+\t\ttmp = gfc_deallocate_alloc_comp (e->ts.u.derived,\n+\t\t\t\t\t\t derived_array,\n+\t\t\t\t\t\t parm_rank);\n+\t      else if ((e->ts.type == BT_CLASS\n+\t\t\t&& GFC_CLASS_TYPE_P (TREE_TYPE (tmp)))\n+\t\t       || e->ts.type == BT_DERIVED)\n \t\ttmp = gfc_deallocate_alloc_comp (e->ts.u.derived, tmp,\n \t\t\t\t\t\t parm_rank);\n \t      else if (e->ts.type == BT_CLASS)"}, {"sha": "44cbfb63f39246e0f145308a82a5b14475548f33", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5159b88ef1a1774ec8851c6b92794ae2bf6e0b74/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5159b88ef1a1774ec8851c6b92794ae2bf6e0b74/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=5159b88ef1a1774ec8851c6b92794ae2bf6e0b74", "patch": "@@ -452,7 +452,7 @@ bool gfc_add_finalizer_call (stmtblock_t *, gfc_expr *);\n bool gfc_add_comp_finalizer_call (stmtblock_t *, tree, gfc_component *, bool);\n \n void gfc_conv_derived_to_class (gfc_se *, gfc_expr *, gfc_typespec, tree, bool,\n-\t\t\t\tbool);\n+\t\t\t\tbool, tree *derived_array = NULL);\n void gfc_conv_class_to_class (gfc_se *, gfc_expr *, gfc_typespec, bool, bool,\n \t\t\t      bool, bool);\n "}, {"sha": "ef5edbfb6ed1bda93beb286a21898e98582af343", "filename": "gcc/testsuite/gfortran.dg/assumed_rank_21.f90", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5159b88ef1a1774ec8851c6b92794ae2bf6e0b74/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_21.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5159b88ef1a1774ec8851c6b92794ae2bf6e0b74/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_21.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_21.f90?ref=5159b88ef1a1774ec8851c6b92794ae2bf6e0b74", "patch": "@@ -0,0 +1,96 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR98342.\n+!\n+! Contributed by Martin Stein  <mscfd@gmx.net>\n+!\n+module mod\n+  implicit none\n+  private\n+  public get_tuple, sel_rank1, sel_rank2, sel_rank3\n+\n+  type, public :: tuple\n+  integer, dimension(:), allocatable :: t\n+end type tuple\n+\n+contains\n+\n+function sel_rank1(x) result(s)\n+  character(len=:), allocatable :: s\n+  type(tuple), dimension(..), intent(in) :: x\n+  select rank (x)\n+    rank (0)\n+      s = '10'\n+    rank (1)\n+      s = '11'\n+    rank default\n+      s = '?'\n+  end select\n+end function sel_rank1\n+\n+function sel_rank2(x) result(s)\n+  character(len=:), allocatable :: s\n+  class(tuple), dimension(..), intent(in) :: x\n+  select rank (x)\n+    rank (0)\n+      s = '20'\n+    rank (1)\n+      s = '21'\n+    rank default\n+      s = '?'\n+  end select\n+end function sel_rank2\n+\n+function sel_rank3(x) result(s)\n+  character(len=:), allocatable :: s\n+  class(*), dimension(..), intent(in) :: x\n+  select rank (x)\n+    rank (0)\n+      s = '30'\n+    rank (1)\n+      s = '31'\n+    rank default\n+      s = '?'\n+  end select\n+end function sel_rank3\n+\n+function get_tuple(t) result(a)\n+  type(tuple) :: a\n+  integer, dimension(:), intent(in) :: t\n+  allocate(a%t, source=t)\n+end function get_tuple\n+\n+end module mod\n+\n+\n+program alloc_rank\n+  use mod\n+  implicit none\n+\n+  integer, dimension(1:3) :: x\n+  character(len=:), allocatable :: output\n+  type(tuple) :: z\n+\n+  x = [1,2,3]\n+  z = get_tuple (x)\n+                                       ! Derived type formal arg\n+  output = sel_rank1(get_tuple (x))    ! runtime: Error in `./alloc_rank.x':\n+  if (output .ne. '10') stop 1\n+  output = sel_rank1([z])              ! This worked OK\n+  if (output .ne. '11') stop 2\n+\n+                                       ! Class formal arg\n+  output = sel_rank2(get_tuple (x))    ! runtime: Error in `./alloc_rank.x':\n+  if (output .ne. '20') stop 3\n+  output = sel_rank2([z])              ! This worked OK\n+  if (output .ne. '21') stop 4\n+\n+                                       ! Unlimited polymorphic formal arg\n+  output = sel_rank3(get_tuple (x))    ! runtime: Error in `./alloc_rank.x':\n+  if (output .ne. '30') stop 5\n+  output = sel_rank3([z])              ! runtime: segmentation fault\n+  if (output .ne. '31') stop 6\n+\n+  deallocate (output)\n+  deallocate (z%t)\n+end program alloc_rank"}]}