{"sha": "60d237aff2b33b61703a1e957aa2dce278858b2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjBkMjM3YWZmMmIzM2I2MTcwM2ExZTk1N2FhMmRjZTI3ODg1OGIyZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-01-31T20:19:25Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-01-31T20:19:25Z"}, "message": "re PR c++/47416 (ICE in build_data_member_initialization, at cp/semantics.c:5509)\n\n\tPR c++/47416\n\t* semantics.c (build_data_member_initialization): Handle\n\tSTATEMENT_LIST always instead of just for CLEANUP_BODY.\n\n\t* g++.dg/cpp0x/pr47416.C: New test.\n\nFrom-SVN: r169447", "tree": {"sha": "f04fee5b74adcb02e3c236b924d90a3b56a770b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f04fee5b74adcb02e3c236b924d90a3b56a770b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60d237aff2b33b61703a1e957aa2dce278858b2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60d237aff2b33b61703a1e957aa2dce278858b2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60d237aff2b33b61703a1e957aa2dce278858b2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60d237aff2b33b61703a1e957aa2dce278858b2e/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "882020aa1c3fe408d66363a1b18e1684e40c4abe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/882020aa1c3fe408d66363a1b18e1684e40c4abe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/882020aa1c3fe408d66363a1b18e1684e40c4abe"}], "stats": {"total": 259, "additions": 247, "deletions": 12}, "files": [{"sha": "673ec6c2b58709cdc2075b72fd03d326f3a89a50", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60d237aff2b33b61703a1e957aa2dce278858b2e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60d237aff2b33b61703a1e957aa2dce278858b2e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=60d237aff2b33b61703a1e957aa2dce278858b2e", "patch": "@@ -1,3 +1,9 @@\n+2011-01-31  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/47416\n+\t* semantics.c (build_data_member_initialization): Handle\n+\tSTATEMENT_LIST always instead of just for CLEANUP_BODY.\n+\n 2011-01-31  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* g++spec.c (lang_specific_driver) [HAVE_LD_STATIC_DYNAMIC] Use"}, {"sha": "6d45fb9b84954e1cbbae91f442fe3186b998817b", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60d237aff2b33b61703a1e957aa2dce278858b2e/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60d237aff2b33b61703a1e957aa2dce278858b2e/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=60d237aff2b33b61703a1e957aa2dce278858b2e", "patch": "@@ -5477,25 +5477,24 @@ build_data_member_initialization (tree t, VEC(constructor_elt,gc) **vec)\n     t = TREE_OPERAND (t, 0);\n   if (t == error_mark_node)\n     return false;\n+  if (TREE_CODE (t) == STATEMENT_LIST)\n+    {\n+      tree_stmt_iterator i;\n+      for (i = tsi_start (t); !tsi_end_p (i); tsi_next (&i))\n+\t{\n+\t  if (! build_data_member_initialization (tsi_stmt (i), vec))\n+\t    return false;\n+\t}\n+      return true;\n+    }\n   if (TREE_CODE (t) == CLEANUP_STMT)\n     {\n       /* We can't see a CLEANUP_STMT in a constructor for a literal class,\n \t but we can in a constexpr constructor for a non-literal class.  Just\n \t ignore it; either all the initialization will be constant, in which\n \t case the cleanup can't run, or it can't be constexpr.\n \t Still recurse into CLEANUP_BODY.  */\n-      t = CLEANUP_BODY (t);\n-      if (TREE_CODE (t) == STATEMENT_LIST)\n-\t{\n-\t  tree_stmt_iterator i;\n-\t  for (i = tsi_start (t); !tsi_end_p (i); tsi_next (&i))\n-\t    {\n-\t      if (! build_data_member_initialization (tsi_stmt (i), vec))\n-\t\treturn false;\n-\t    }\n-\t  return true;\n-\t}\n-      return build_data_member_initialization (t, vec);\n+      return build_data_member_initialization (CLEANUP_BODY (t), vec);\n     }\n   if (TREE_CODE (t) == CONVERT_EXPR)\n     t = TREE_OPERAND (t, 0);"}, {"sha": "7d22d04e6e8d2606aabdede9d192a4438f774e6d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60d237aff2b33b61703a1e957aa2dce278858b2e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60d237aff2b33b61703a1e957aa2dce278858b2e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=60d237aff2b33b61703a1e957aa2dce278858b2e", "patch": "@@ -1,3 +1,8 @@\n+2011-01-31  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/47416\n+\t* g++.dg/cpp0x/pr47416.C: New test.\n+\n 2011-01-31  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/47519"}, {"sha": "a11368a50f0a3572e9736a0a534755529f3934fa", "filename": "gcc/testsuite/g++.dg/cpp0x/pr47416.C", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60d237aff2b33b61703a1e957aa2dce278858b2e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr47416.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60d237aff2b33b61703a1e957aa2dce278858b2e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr47416.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr47416.C?ref=60d237aff2b33b61703a1e957aa2dce278858b2e", "patch": "@@ -0,0 +1,225 @@\n+// PR c++/47416\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+namespace std\n+{\n+  template < typename _Tp, _Tp __v > struct integral_constant\n+  {\n+    static const _Tp value = __v;\n+  };\n+  typedef integral_constant < bool, false > false_type;\n+    template < typename > struct is_array:false_type\n+  {\n+  };\n+    template < typename > struct is_function:false_type\n+  {\n+  };\n+    template < typename _Tp > struct remove_const\n+  {\n+    typedef _Tp type;\n+  };\n+    template < typename _Tp > struct remove_volatile\n+  {\n+    typedef _Tp type;\n+  };\n+    template < typename _Tp > struct remove_cv\n+  {\n+    typedef typename remove_const < typename remove_volatile <\n+      _Tp >::type >::type type;\n+  };\n+    template < typename > struct remove_reference\n+  {\n+  };\n+    template < typename _Tp > struct remove_reference <_Tp & >\n+  {\n+    typedef _Tp type;\n+  };\n+    template < typename _Up, bool = is_array < _Up >::value, bool =\n+    is_function < _Up >::value > struct __decay_selector;\n+    template < typename _Up > struct __decay_selector <_Up, false, false >\n+  {\n+    typedef typename remove_cv < _Up >::type __type;\n+  };\n+    template < typename _Tp > class decay\n+  {\n+    typedef typename remove_reference < _Tp >::type __remove_type;\n+  public:typedef typename __decay_selector <\n+      __remove_type >::__type type;\n+  };\n+  template < typename _Tp > struct __strip_reference_wrapper\n+  {\n+    typedef _Tp __type;\n+  };\n+  template < typename _Tp > struct __decay_and_strip\n+  {\n+    typedef typename __strip_reference_wrapper < typename decay <\n+      _Tp >::type >::__type __type;\n+  };\n+  template < typename _Tp > _Tp forward (typename remove_reference <\n+\t\t\t\t\t _Tp >::type &)\n+  {\n+  }\n+  template < class _T1, class _T2 > struct pair\n+  {\n+    _T1 first;\n+    _T2 second;\n+    constexpr pair (_T1, _T2 &):first (), second (__b)\t// { dg-error \"was not declared in this scope\" }\n+    {\n+    }\n+  };\n+  template < class _T1,\n+    class _T2 > pair < typename __decay_and_strip < _T1 >::__type,\n+    typename __decay_and_strip < _T2 >::__type > make_pair (_T1 && __x, _T2\n+\t\t\t\t\t\t\t    && __y)\n+  {\n+    typedef typename __decay_and_strip < _T1 >::__type __ds_type1;\n+    typedef typename __decay_and_strip < _T2 >::__type __ds_type2;\n+    typedef pair < __ds_type1, __ds_type2 > __pair_type;\n+    __pair_type (forward < _T1 > (__x), std::forward < _T2 > (__y));\n+  }\n+}\n+\n+typedef long size_t;\n+namespace std\n+{\n+  template < typename > class allocator;\n+  template < class > struct char_traits;\n+    template < typename _CharT, typename = char_traits < _CharT >, typename =\n+    allocator < _CharT > >class basic_string;\n+  typedef basic_string < char >string;\n+}\n+namespace __gnu_cxx\n+{\n+  template < bool > class __pool;\n+  template < template < bool > class, bool > struct __common_pool\n+  {\n+  };\n+    template < template < bool > class, bool > struct __common_pool_base;\n+    template < template < bool > class _PoolTp >\n+    struct __common_pool_base <_PoolTp, true >:__common_pool < _PoolTp, true >\n+  {\n+  };\n+    template < template < bool > class _PoolTp,\n+    bool _Thread > struct __common_pool_policy:__common_pool_base < _PoolTp,\n+    _Thread >\n+  {\n+    template < typename, template < bool > class _PoolTp1 =\n+      _PoolTp, bool _Thread1 = _Thread > struct _M_rebind\n+    {\n+      typedef __common_pool_policy < _PoolTp1, _Thread1 > other;\n+    };\n+  };\n+    template < typename _Tp > class __mt_alloc_base\n+  {\n+  };\n+template < typename _Tp, typename _Poolp = __common_pool_policy < __pool, true > >class __mt_alloc:public __mt_alloc_base <\n+    _Tp\n+    >\n+  {\n+  public:size_t size_type;\n+    typedef _Tp value_type;\n+    template < typename _Tp1, typename _Poolp1 = _Poolp > struct rebind\n+    {\n+      typedef typename _Poolp1::template _M_rebind < _Tp1 >::other pol_type;\n+      typedef __mt_alloc < _Tp1, pol_type > other;\n+    };\n+  };\n+}\n+\n+namespace std\n+{\n+  template < typename _Tp > class allocator:public __gnu_cxx::__mt_alloc <\n+    _Tp >\n+  {\n+  };\n+  template < typename, typename > struct unary_function\n+  {\n+  };\n+  template < typename, typename, typename > struct binary_function\n+  {\n+  };\n+  template < typename _Tp > struct equal_to:binary_function < _Tp, _Tp, bool >\n+  {\n+  };\n+}\n+\n+namespace boost\n+{\n+  template < class > struct hash;\n+    template < class K, class T, class = hash < K >, class =\n+    std::equal_to < K >, class =\n+    std::allocator < std::pair < const K, T > >>class unordered_map;\n+    template < >struct hash <std::string >:std::unary_function < std::string,\n+    size_t >\n+  {\n+  };\n+  namespace unordered_detail\n+  {\n+    template < class Alloc, class T > struct rebind_wrap\n+    {\n+      typedef typename Alloc::template rebind < T >::other type;\n+    };\n+  }\n+  namespace unordered_detail\n+  {\n+    size_t default_bucket_count;\n+      template < class, class > struct map_extractor;\n+    struct ungrouped\n+    {\n+    };\n+      template < class T > class hash_table:T::buckets, T::buffered_functions\n+    {\n+    };\n+      template < class, class, class H, class P, class A, class, class G > struct types\n+    {\n+      typedef H hasher;\n+      typedef P key_equal;\n+      typedef A value_allocator;\n+    };\n+      template < class T > class hash_unique_table:T\n+    {\n+    public:typedef typename T::hasher hasher;\n+      typedef typename T::key_equal key_equal;\n+      typedef typename T::value_allocator value_allocator;\n+      typedef typename T::table table;\n+        hash_unique_table (size_t n, hasher, key_equal,\n+\t\t\t   value_allocator & a):table (n, a)\t// { dg-error \"is not a direct base\" }\n+      {\n+      }\n+    };\n+    template < class K, class H, class P, class A > struct map:types < K,\n+      typename A::value_type, H, P, A, map_extractor < K,\n+      typename A::value_type >, ungrouped >\n+    {\n+      typedef hash_unique_table < map < K, H, P, A > >impl;\n+      typedef hash_table < map < K, H, P, A > >table;\n+    };\n+  }\n+  template < class K, class T, class H, class P, class A > class unordered_map\n+  {\n+    typedef std::pair < const K, T > value_type;\n+    typedef H hasher;\n+    typedef P key_equal;\n+    typedef A allocator_type;\n+    typedef typename unordered_detail::rebind_wrap < allocator_type,\n+      value_type >::type value_allocator;\n+    typedef boost::unordered_detail::map < K, H, P, value_allocator > types;\n+    typedef typename types::impl table;\n+    typedef size_t size_type;\n+  private:table table_;\n+  public: unordered_map (size_type n = boost::unordered_detail::default_bucket_count,\n+\t\t\t hasher hf = hasher (), key_equal eql = key_equal (),\n+\t\t\t allocator_type a = allocator_type ()):table_ (n, hf, eql, a)\t// { dg-message \"instantiated\" }\n+    {\n+    }\n+  };\n+};\n+\n+void\n+foo (const int &a)\n+{\n+  typedef boost::unordered_map < std::string, int >Name2Port;\n+  Name2Port b;\t\t\t// { dg-message \"instantiated\" }\n+  std::make_pair (a, b);\n+}"}]}