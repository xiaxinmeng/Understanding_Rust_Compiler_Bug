{"sha": "aa29ea0cd4054b64d9dbc9adba3bfd2db2a86be1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWEyOWVhMGNkNDA1NGI2NGQ5ZGJjOWFkYmEzYmZkMmRiMmE4NmJlMQ==", "commit": {"author": {"name": "Thomas Preud'homme", "email": "thomas.preudhomme@arm.com", "date": "2014-09-24T08:27:21Z"}, "committer": {"name": "Thomas Preud'homme", "email": "thopre01@gcc.gnu.org", "date": "2014-09-24T08:27:21Z"}, "message": "re PR tree-optimization/63266 (Test regression: gcc.target/sh/pr53568-1.c)\n\n2014-09-24  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n\n    gcc/\n    PR tree-optimization/63266\n    * tree-ssa-math-opts.c (struct symbolic_number): Add comment about\n    marker for unknown byte value.\n    (MARKER_MASK): New macro.\n    (MARKER_BYTE_UNKNOWN): New macro.\n    (HEAD_MARKER): New macro.\n    (do_shift_rotate): Mark bytes with unknown values due to sign\n    extension when doing an arithmetic right shift. Replace hardcoded\n    mask for marker by new MARKER_MASK macro.\n    (find_bswap_or_nop_1): Likewise and adjust ORing of two symbolic\n    numbers accordingly.\n\n    gcc/testsuite/\n    PR tree-optimization/63266\n    * gcc.dg/optimize-bswapsi-1.c (swap32_d): New bswap pass test.\n\nFrom-SVN: r215546", "tree": {"sha": "8c575547f3f27f3728029148d26a855925028b06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c575547f3f27f3728029148d26a855925028b06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa29ea0cd4054b64d9dbc9adba3bfd2db2a86be1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa29ea0cd4054b64d9dbc9adba3bfd2db2a86be1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa29ea0cd4054b64d9dbc9adba3bfd2db2a86be1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa29ea0cd4054b64d9dbc9adba3bfd2db2a86be1/comments", "author": {"login": "RoboTux", "id": 272327, "node_id": "MDQ6VXNlcjI3MjMyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/272327?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RoboTux", "html_url": "https://github.com/RoboTux", "followers_url": "https://api.github.com/users/RoboTux/followers", "following_url": "https://api.github.com/users/RoboTux/following{/other_user}", "gists_url": "https://api.github.com/users/RoboTux/gists{/gist_id}", "starred_url": "https://api.github.com/users/RoboTux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RoboTux/subscriptions", "organizations_url": "https://api.github.com/users/RoboTux/orgs", "repos_url": "https://api.github.com/users/RoboTux/repos", "events_url": "https://api.github.com/users/RoboTux/events{/privacy}", "received_events_url": "https://api.github.com/users/RoboTux/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "415ebad0b3ed751ffd1ea991350ac770b66c1a97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/415ebad0b3ed751ffd1ea991350ac770b66c1a97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/415ebad0b3ed751ffd1ea991350ac770b66c1a97"}], "stats": {"total": 80, "additions": 61, "deletions": 19}, "files": [{"sha": "d5f1b1ba5993fe6d5c46018081226be32adb58c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa29ea0cd4054b64d9dbc9adba3bfd2db2a86be1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa29ea0cd4054b64d9dbc9adba3bfd2db2a86be1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aa29ea0cd4054b64d9dbc9adba3bfd2db2a86be1", "patch": "@@ -1,3 +1,17 @@\n+2014-09-24  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\tPR tree-optimization/63266\n+\t* tree-ssa-math-opts.c (struct symbolic_number): Add comment about\n+\tmarker for unknown byte value.\n+\t(MARKER_MASK): New macro.\n+\t(MARKER_BYTE_UNKNOWN): New macro.\n+\t(HEAD_MARKER): New macro.\n+\t(do_shift_rotate): Mark bytes with unknown values due to sign\n+\textension when doing an arithmetic right shift. Replace hardcoded\n+\tmask for marker by new MARKER_MASK macro.\n+\t(find_bswap_or_nop_1): Likewise and adjust ORing of two symbolic\n+\tnumbers accordingly.\n+\n 2014-09-24  Alexander Ivchenko  <alexander.ivchenko@intel.com>\n \t    Maxim Kuznetsov  <maxim.kuznetsov@intel.com>\n \t    Anna Tikhonova  <anna.tikhonova@intel.com>"}, {"sha": "69d9b3d12c0d5d9496d10ef461682453ad7ac861", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa29ea0cd4054b64d9dbc9adba3bfd2db2a86be1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa29ea0cd4054b64d9dbc9adba3bfd2db2a86be1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=aa29ea0cd4054b64d9dbc9adba3bfd2db2a86be1", "patch": "@@ -1,3 +1,8 @@\n+2014-09-24  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\tPR tree-optimization/63266\n+\t* gcc.dg/optimize-bswapsi-1.c (swap32_d): New bswap pass test.\n+\n 2014-09-24  Zhenqiang Chen  <zhenqiang.chen@arm.com>\n \n \t* gcc.target/arm/pr63210.c: New test."}, {"sha": "580e6e0fee2cc5ffbe14f5e688bb86bd66abcbc5", "filename": "gcc/testsuite/gcc.dg/optimize-bswapsi-1.c", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa29ea0cd4054b64d9dbc9adba3bfd2db2a86be1/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapsi-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa29ea0cd4054b64d9dbc9adba3bfd2db2a86be1/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapsi-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapsi-1.c?ref=aa29ea0cd4054b64d9dbc9adba3bfd2db2a86be1", "patch": "@@ -49,5 +49,20 @@ swap32_c (SItype u)\n \t  | (((u) & 0x000000ff) << 24));\n }\n \n-/* { dg-final { scan-tree-dump-times \"32 bit bswap implementation found at\" 3 \"bswap\" } } */\n+/* This variant comes from gcc.target/sh/pr53568-1.c.  It requires to track\n+   which bytes have an unpredictable value (eg. due to sign extension) to\n+   make sure that the final expression have only well defined byte values.  */\n+\n+SItype\n+swap32_d (SItype in)\n+{\n+  /* 1x swap.w\n+     2x swap.b  */\n+  return (((in >> 0) & 0xFF) << 24)\n+\t | (((in >> 8) & 0xFF) << 16)\n+\t | (((in >> 16) & 0xFF) << 8)\n+\t | (((in >> 24) & 0xFF) << 0);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"32 bit bswap implementation found at\" 4 \"bswap\" } } */\n /* { dg-final { cleanup-tree-dump \"bswap\" } } */"}, {"sha": "3c6e9355fff6fa33f69ea5bb1b0d808f8bf5043e", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa29ea0cd4054b64d9dbc9adba3bfd2db2a86be1/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa29ea0cd4054b64d9dbc9adba3bfd2db2a86be1/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=aa29ea0cd4054b64d9dbc9adba3bfd2db2a86be1", "patch": "@@ -1603,6 +1603,7 @@ make_pass_cse_sincos (gcc::context *ctxt)\n    consisting of octet sized markers:\n \n    0    - target byte has the value 0\n+   FF   - target byte has an unknown value (eg. due to sign extension)\n    1..size - marker value is the target byte index minus one.\n \n    To detect permutations on memory sources (arrays and structures), a symbolic\n@@ -1629,6 +1630,10 @@ struct symbolic_number {\n };\n \n #define BITS_PER_MARKER 8\n+#define MARKER_MASK ((1 << BITS_PER_MARKER) - 1)\n+#define MARKER_BYTE_UNKNOWN MARKER_MASK\n+#define HEAD_MARKER(n, size) \\\n+  ((n) & ((uint64_t) MARKER_MASK << (((size) - 1) * BITS_PER_MARKER)))\n \n /* The number which the find_bswap_or_nop_1 result should match in\n    order to have a nop.  The number is masked according to the size of\n@@ -1651,7 +1656,8 @@ do_shift_rotate (enum tree_code code,\n \t\t struct symbolic_number *n,\n \t\t int count)\n {\n-  int size = TYPE_PRECISION (n->type) / BITS_PER_UNIT;\n+  int i, size = TYPE_PRECISION (n->type) / BITS_PER_UNIT;\n+  unsigned head_marker;\n \n   if (count % BITS_PER_UNIT != 0)\n     return false;\n@@ -1668,11 +1674,13 @@ do_shift_rotate (enum tree_code code,\n       n->n <<= count;\n       break;\n     case RSHIFT_EXPR:\n-      /* Arithmetic shift of signed type: result is dependent on the value.  */\n-      if (!TYPE_UNSIGNED (n->type)\n-\t  && (n->n & ((uint64_t) 0xff << ((size - 1) * BITS_PER_MARKER))))\n-\treturn false;\n+      head_marker = HEAD_MARKER (n->n, size);\n       n->n >>= count;\n+      /* Arithmetic shift of signed type: result is dependent on the value.  */\n+      if (!TYPE_UNSIGNED (n->type) && head_marker)\n+\tfor (i = 0; i < count / BITS_PER_MARKER; i++)\n+\t  n->n |= (uint64_t) MARKER_BYTE_UNKNOWN\n+\t\t  << ((size - 1 - i) * BITS_PER_MARKER);\n       break;\n     case LROTATE_EXPR:\n       n->n = (n->n << count) | (n->n >> ((size * BITS_PER_MARKER) - count));\n@@ -1878,7 +1886,7 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n \t      if ((val & tmp) != 0 && (val & tmp) != tmp)\n \t\treturn NULL;\n \t      else if (val & tmp)\n-\t\tmask |= (uint64_t) 0xff << (i * BITS_PER_MARKER);\n+\t\tmask |= (uint64_t) MARKER_MASK << (i * BITS_PER_MARKER);\n \n \t    n->n &= mask;\n \t  }\n@@ -1892,7 +1900,7 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n \t  break;\n \tCASE_CONVERT:\n \t  {\n-\t    int type_size, old_type_size;\n+\t    int i, type_size, old_type_size;\n \t    tree type;\n \n \t    type = gimple_expr_type (stmt);\n@@ -1905,11 +1913,10 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n \n \t    /* Sign extension: result is dependent on the value.  */\n \t    old_type_size = TYPE_PRECISION (n->type) / BITS_PER_UNIT;\n-\t    if (!TYPE_UNSIGNED (n->type)\n-\t\t&& type_size > old_type_size\n-\t\t&& n->n & ((uint64_t) 0xff << ((old_type_size - 1)\n-\t\t\t\t\t       * BITS_PER_MARKER)))\n-\t      return NULL;\n+\t    if (!TYPE_UNSIGNED (n->type) && type_size > old_type_size\n+\t\t&& HEAD_MARKER (n->n, old_type_size))\n+\t      for (i = 0; i < type_size - old_type_size; i++)\n+\t\tn->n |= MARKER_BYTE_UNKNOWN << (type_size - 1 - i);\n \n \t    if (type_size < 64 / BITS_PER_MARKER)\n \t      {\n@@ -1968,7 +1975,7 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n \t  if (gimple_assign_rhs1 (source_stmt1)\n \t      != gimple_assign_rhs1 (source_stmt2))\n \t    {\n-\t      int64_t inc, mask;\n+\t      int64_t inc;\n \t      HOST_WIDE_INT off_sub;\n \t      struct symbolic_number *n_ptr;\n \n@@ -2002,15 +2009,15 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n \t\t bigger weight according to target endianness.  */\n \t      inc = BYTES_BIG_ENDIAN ? off_sub + n2.range - n1.range : off_sub;\n \t      size = TYPE_PRECISION (n1.type) / BITS_PER_UNIT;\n-\t      mask = 0xff;\n \t      if (BYTES_BIG_ENDIAN)\n \t\tn_ptr = &n1;\n \t      else\n \t\tn_ptr = &n2;\n-\t      for (i = 0; i < size; i++, inc <<= BITS_PER_MARKER,\n-\t\t\t\t\t mask <<= BITS_PER_MARKER)\n+\t      for (i = 0; i < size; i++, inc <<= BITS_PER_MARKER)\n \t\t{\n-\t\t  if (n_ptr->n & mask)\n+\t\t  unsigned marker =\n+\t\t    (n_ptr->n >> (i * BITS_PER_MARKER)) & MARKER_MASK;\n+\t\t  if (marker && marker != MARKER_BYTE_UNKNOWN)\n \t\t    n_ptr->n += inc;\n \t\t}\n \t    }\n@@ -2028,7 +2035,8 @@ find_bswap_or_nop_1 (gimple stmt, struct symbolic_number *n, int limit)\n \t  n->bytepos = n1.bytepos;\n \t  n->type = n1.type;\n \t  size = TYPE_PRECISION (n->type) / BITS_PER_UNIT;\n-\t  for (i = 0, mask = 0xff; i < size; i++, mask <<= BITS_PER_MARKER)\n+\t  for (i = 0, mask = MARKER_MASK; i < size;\n+\t       i++, mask <<= BITS_PER_MARKER)\n \t    {\n \t      uint64_t masked1, masked2;\n "}]}