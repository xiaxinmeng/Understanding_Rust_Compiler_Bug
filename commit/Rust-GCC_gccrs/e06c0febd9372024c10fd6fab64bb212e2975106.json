{"sha": "e06c0febd9372024c10fd6fab64bb212e2975106", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTA2YzBmZWJkOTM3MjAyNGMxMGZkNmZhYjY0YmIyMTJlMjk3NTEwNg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-12-01T16:46:25Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-12-01T16:46:25Z"}, "message": "re PR middle-end/18667 (ice with --parm integer-share-limit=0)\n\n\tPR middle-end/18667\n\t* params.c (set_param_value): Add range check.\n\t* params.def: Add min and max values. Reformat long strings.\n\t* params.h (struct param_info): Add min and max fields.\n\t(enum compiler_param): Adjust DEFPARAM.\n\t* toplev.c (lang_independent_params): Likewise.\n\nFrom-SVN: r91567", "tree": {"sha": "68b4dba3e71746f5a25ddc90900e8d44323f79f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68b4dba3e71746f5a25ddc90900e8d44323f79f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e06c0febd9372024c10fd6fab64bb212e2975106", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e06c0febd9372024c10fd6fab64bb212e2975106", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e06c0febd9372024c10fd6fab64bb212e2975106", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e06c0febd9372024c10fd6fab64bb212e2975106/comments", "author": null, "committer": null, "parents": [{"sha": "07c65e005e3c402d07297b9ce4df2e5ef5f433e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07c65e005e3c402d07297b9ce4df2e5ef5f433e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07c65e005e3c402d07297b9ce4df2e5ef5f433e2"}], "stats": {"total": 198, "additions": 105, "deletions": 93}, "files": [{"sha": "35a6bb8636926bfc007bd1f0ec870a34b9b49d0f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e06c0febd9372024c10fd6fab64bb212e2975106/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e06c0febd9372024c10fd6fab64bb212e2975106/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e06c0febd9372024c10fd6fab64bb212e2975106", "patch": "@@ -1,3 +1,12 @@\n+2004-12-01  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR middle-end/18667\n+\t* params.c (set_param_value): Add range check.\n+\t* params.def: Add min and max values. Reformat long strings.\n+\t* params.h (struct param_info): Add min and max fields.\n+\t(enum compiler_param): Adjust DEFPARAM.\n+\t* toplev.c (lang_independent_params): Likewise.\n+\n 2004-12-01  Alan Modra  <amodra@bigpond.net.au>\n \n \tPR target/12817"}, {"sha": "cc55fae6f676fa0c8c08caefed65f0ce33ce6370", "filename": "gcc/params.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e06c0febd9372024c10fd6fab64bb212e2975106/gcc%2Fparams.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e06c0febd9372024c10fd6fab64bb212e2975106/gcc%2Fparams.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.c?ref=e06c0febd9372024c10fd6fab64bb212e2975106", "patch": "@@ -68,7 +68,17 @@ set_param_value (const char *name, int value)\n   for (i = 0; i < num_compiler_params; ++i)\n     if (strcmp (compiler_params[i].option, name) == 0)\n       {\n-\tcompiler_params[i].value = value;\n+\tif (value < compiler_params[i].min_value)\n+\t  error (\"minimum value of parameter %qs is %u\",\n+\t\t compiler_params[i].option,\n+\t\t compiler_params[i].min_value);\n+\telse if (compiler_params[i].max_value > compiler_params[i].min_value\n+\t\t && value > compiler_params[i].max_value)\n+\t  error (\"maximum value of parameter %qs is %u\",\n+\t\t compiler_params[i].option,\n+\t\t compiler_params[i].max_value);\n+\telse\n+\t  compiler_params[i].value = value;\n \treturn;\n       }\n "}, {"sha": "48ad6d7ee1e5e552ee90d427b6b50793110098a2", "filename": "gcc/params.def", "status": "modified", "additions": 74, "deletions": 88, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e06c0febd9372024c10fd6fab64bb212e2975106/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e06c0febd9372024c10fd6fab64bb212e2975106/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=e06c0febd9372024c10fd6fab64bb212e2975106", "patch": "@@ -41,8 +41,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    itself.  */\n DEFPARAM (PARAM_SRA_MAX_STRUCTURE_SIZE,\n \t  \"sra-max-structure-size\",\n-\t  \"The maximum structure size (in bytes) at which GCC will do block copies.\",\n-\t  0)\n+\t  \"The maximum structure size (in bytes) at which GCC will do block copies\",\n+\t  0, 0, 0)\n \n /* The ratio between instantiated fields and the complete structure\n    size.  We say that if the ratio of the number of bytes in\n@@ -51,8 +51,8 @@ DEFPARAM (PARAM_SRA_MAX_STRUCTURE_SIZE,\n    The default is 75%.  */\n DEFPARAM (PARAM_SRA_FIELD_STRUCTURE_RATIO,\n \t  \"sra-field-structure-ratio\",\n-\t  \"The threshold ratio between instantiated fields and the total structure size.\",\n-\t  75)\n+\t  \"The threshold ratio between instantiated fields and the total structure size\",\n+\t  75, 0, 100)\n \n /* The single function inlining limit. This is the maximum size\n    of a function counted in internal gcc instructions (not in\n@@ -70,7 +70,7 @@ DEFPARAM (PARAM_SRA_FIELD_STRUCTURE_RATIO,\n DEFPARAM (PARAM_MAX_INLINE_INSNS_SINGLE,\n \t  \"max-inline-insns-single\",\n \t  \"The maximum number of instructions in a single function eligible for inlining\",\n-\t  500)\n+\t  500, 0, 0)\n \n /* The single function inlining limit for functions that are\n    inlined by virtue of -finline-functions (-O3).\n@@ -82,27 +82,27 @@ DEFPARAM (PARAM_MAX_INLINE_INSNS_SINGLE,\n DEFPARAM (PARAM_MAX_INLINE_INSNS_AUTO,\n \t  \"max-inline-insns-auto\",\n \t  \"The maximum number of instructions when automatically inlining\",\n-\t  120)\n+\t  120, 0, 0)\n \n DEFPARAM (PARAM_MAX_INLINE_INSNS_RECURSIVE,\n \t  \"max-inline-insns-recursive\",\n \t  \"The maximum number of instructions inline function can grow to via recursive inlining\",\n-\t  500)\n+\t  500, 0, 0)\n \n DEFPARAM (PARAM_MAX_INLINE_INSNS_RECURSIVE_AUTO,\n \t  \"max-inline-insns-recursive-auto\",\n \t  \"The maximum number of instructions non-inline function can grow to via recursive inlining\",\n-\t  500)\n+\t  500, 0, 0)\n \n DEFPARAM (PARAM_MAX_INLINE_RECURSIVE_DEPTH,\n \t  \"max-inline-recursive-depth\",\n \t  \"The maximum depth of recursive inlining for inline functions\",\n-\t  8)\n+\t  8, 0, 0)\n \n DEFPARAM (PARAM_MAX_INLINE_RECURSIVE_DEPTH_AUTO,\n \t  \"max-inline-recursive-depth-auto\",\n \t  \"The maximum depth of recursive inlining for non-inline functions\",\n-\t  8)\n+\t  8, 0, 0)\n \n /* Limit the number of expansions created by the variable expansion\n    optimization to avoid register pressure.  */\n@@ -111,7 +111,7 @@ DEFPARAM (PARAM_MAX_VARIABLE_EXPANSIONS,\n \t  \"If -fvariable-expansion-in-unroller is used, the maximum number of \\\n            times that an individual variable will be expanded \\\n            during loop unrolling\",\n-          1)\n+          1, 0, 0)\n      \n /* The maximum number of instructions to consider when looking for an\n    instruction to fill a delay slot.  If more than this arbitrary\n@@ -122,7 +122,7 @@ DEFPARAM (PARAM_MAX_VARIABLE_EXPANSIONS,\n DEFPARAM (PARAM_MAX_DELAY_SLOT_INSN_SEARCH,\n \t  \"max-delay-slot-insn-search\",\n \t  \"The maximum number of instructions to consider to fill a delay slot\",\n-\t  100)\n+\t  100, 0, 0)\n \n /* When trying to fill delay slots, the maximum number of instructions\n    to consider when searching for a block with valid live register\n@@ -133,7 +133,7 @@ DEFPARAM (PARAM_MAX_DELAY_SLOT_INSN_SEARCH,\n DEFPARAM(PARAM_MAX_DELAY_SLOT_LIVE_SEARCH,\n \t \"max-delay-slot-live-search\",\n \t \"The maximum number of instructions to consider to find accurate live register information\",\n-\t 333)\n+\t 333, 0, 0)\n \n /* This parameter limits the number of branch elements that the \n    scheduler will track anti-dependencies through without resetting\n@@ -143,32 +143,32 @@ DEFPARAM(PARAM_MAX_DELAY_SLOT_LIVE_SEARCH,\n DEFPARAM(PARAM_MAX_PENDING_LIST_LENGTH,\n \t \"max-pending-list-length\",\n \t \"The maximum length of scheduling's pending operations list\",\n-\t 32)\n+\t 32, 0, 0)\n \n DEFPARAM(PARAM_LARGE_FUNCTION_INSNS,\n \t \"large-function-insns\",\n \t \"The size of function body to be considered large\",\n-\t 3000)\n+\t 3000, 0, 0)\n DEFPARAM(PARAM_LARGE_FUNCTION_GROWTH,\n \t \"large-function-growth\",\n \t \"Maximal growth due to inlining of large function (in percent)\",\n-\t 100)\n+\t 100, 0, 0)\n DEFPARAM(PARAM_INLINE_UNIT_GROWTH,\n \t \"inline-unit-growth\",\n \t \"how much can given compilation unit grow because of the inlining (in percent)\",\n-\t 50)\n+\t 50, 0, 0)\n \n /* The GCSE optimization will be disabled if it would require\n    significantly more memory than this value.  */\n DEFPARAM(PARAM_MAX_GCSE_MEMORY,\n \t \"max-gcse-memory\",\n \t \"The maximum amount of memory to be allocated by GCSE\",\n-\t 50 * 1024 * 1024)\n+\t 50 * 1024 * 1024, 0, 0)\n /* The number of repetitions of copy/const prop and PRE to run.  */\n DEFPARAM(PARAM_MAX_GCSE_PASSES,\n \t\"max-gcse-passes\",\n \t\"The maximum number of passes to make when doing GCSE\",\n-\t1)\n+\t1, 1, 0)\n /* This is the threshold ratio when to perform partial redundancy\n    elimination after reload. We perform partial redundancy elimination\n    when the following holds:\n@@ -177,17 +177,15 @@ DEFPARAM(PARAM_MAX_GCSE_PASSES,\n    (Added loads execution count)\t\t\t\t\t  */\n DEFPARAM(PARAM_GCSE_AFTER_RELOAD_PARTIAL_FRACTION,\n \t\"gcse-after-reload-partial-fraction\",\n-\t\"The threshold ratio for performing partial redundancy elimination \\\n-         after reload.\",\n-        3)\n+\t\"The threshold ratio for performing partial redundancy elimination after reload.\",\n+        3, 0, 0)\n /* This is the threshold ratio of the critical edges execution count compared to\n    the redundant loads execution count that permits performing the load\n    redundancy elimination in gcse after reload.  */\n DEFPARAM(PARAM_GCSE_AFTER_RELOAD_CRITICAL_FRACTION,\n \t\"gcse-after-reload-critical-fraction\",\n-\t\"The threshold ratio of critical edges execution count that permit \\\n-         performing redundancy elimination after reload.\",\n-        10)\n+\t\"The threshold ratio of critical edges execution count that permit performing redundancy elimination after reload.\",\n+        10, 0, 0)\n /* This parameter limits the number of insns in a loop that will be unrolled,\n    and by how much the loop is unrolled.\n    \n@@ -198,150 +196,139 @@ DEFPARAM(PARAM_GCSE_AFTER_RELOAD_CRITICAL_FRACTION,\n DEFPARAM(PARAM_MAX_UNROLLED_INSNS,\n \t \"max-unrolled-insns\",\n \t \"The maximum number of instructions to consider to unroll in a loop\",\n-\t 200)\n+\t 200, 0, 0)\n /* This parameter limits how many times the loop is unrolled depending\n    on number of insns really executed in each iteration.  */\n DEFPARAM(PARAM_MAX_AVERAGE_UNROLLED_INSNS,\n \t \"max-average-unrolled-insns\",\n \t \"The maximum number of instructions to consider to unroll in a loop on average\",\n-\t 80)\n+\t 80, 0, 0)\n /* The maximum number of unrollings of a single loop.  */\n DEFPARAM(PARAM_MAX_UNROLL_TIMES,\n \t\"max-unroll-times\",\n \t\"The maximum number of unrollings of a single loop\",\n-\t8)\n+\t8, 0, 0)\n /* The maximum number of insns of a peeled loop.  */\n DEFPARAM(PARAM_MAX_PEELED_INSNS,\n \t\"max-peeled-insns\",\n \t\"The maximum number of insns of a peeled loop\",\n-\t400)\n+\t400, 0, 0)\n /* The maximum number of peelings of a single loop.  */\n DEFPARAM(PARAM_MAX_PEEL_TIMES,\n \t\"max-peel-times\",\n \t\"The maximum number of peelings of a single loop\",\n-\t16)\n+\t16, 0, 0)\n /* The maximum number of insns of a peeled loop.  */\n DEFPARAM(PARAM_MAX_COMPLETELY_PEELED_INSNS,\n \t\"max-completely-peeled-insns\",\n \t\"The maximum number of insns of a completely peeled loop\",\n-\t400)\n+\t400, 0, 0)\n /* The maximum number of peelings of a single loop that is peeled completely.  */\n DEFPARAM(PARAM_MAX_COMPLETELY_PEEL_TIMES,\n \t\"max-completely-peel-times\",\n \t\"The maximum number of peelings of a single loop that is peeled completely\",\n-\t16)\n+\t16, 0, 0)\n /* The maximum number of insns of a peeled loop that rolls only once.  */\n DEFPARAM(PARAM_MAX_ONCE_PEELED_INSNS,\n \t\"max-once-peeled-insns\",\n \t\"The maximum number of insns of a peeled loop that rolls only once\",\n-\t400)\n+\t400, 0, 0)\n \n /* The maximum number of insns of an unswitched loop.  */\n DEFPARAM(PARAM_MAX_UNSWITCH_INSNS,\n \t\"max-unswitch-insns\",\n \t\"The maximum number of insns of an unswitched loop\",\n-\t50)\n+\t50, 0, 0)\n /* The maximum level of recursion in unswitch_single_loop.  */\n DEFPARAM(PARAM_MAX_UNSWITCH_LEVEL,\n \t\"max-unswitch-level\",\n \t\"The maximum number of unswitchings in a single loop\",\n-\t3)\n+\t3, 0, 0)\n \n /* The maximum number of iterations of a loop the brute force algorithm\n    for analysis of # of iterations of the loop tries to evaluate.  */\n DEFPARAM(PARAM_MAX_ITERATIONS_TO_TRACK,\n \t\"max-iterations-to-track\",\n-\t\"Bound on the number of iterations the brute force # of iterations \\\n-\t analysis algorithm evaluates\",\n-\t1000)\n+\t\"Bound on the number of iterations the brute force # of iterations analysis algorithm evaluates\",\n+\t1000, 0, 0)\n \n DEFPARAM(PARAM_MAX_SMS_LOOP_NUMBER,\n \t \"max-sms-loop-number\",\n-\t \"Maximum number of loops to perform swing modulo scheduling on \\\n-\t  (mainly for debugging)\",\n-\t -1)\n-\n+\t \"Maximum number of loops to perform swing modulo scheduling on (mainly for debugging)\",\n+\t -1, -1, -1)\n+  \n /* This parameter is used to tune SMS MAX II calculations.  */\n DEFPARAM(PARAM_SMS_MAX_II_FACTOR,\n \t \"sms-max-ii-factor\",\n-\t \"A factor for tuning the upper bound that swing modulo scheduler uses \\\n-\t  for scheduling a loop\",\n-\t 100)\n+\t \"A factor for tuning the upper bound that swing modulo scheduler uses for scheduling a loop\",\n+\t 100, 0, 0)\n DEFPARAM(PARAM_SMS_DFA_HISTORY,\n \t \"sms-dfa-history\",\n \t \"The number of cycles the swing modulo scheduler considers when \\\n \t  checking conflicts using DFA\",\n-\t 0)\n+\t 0, 0, 0)\n DEFPARAM(PARAM_SMS_LOOP_AVERAGE_COUNT_THRESHOLD,\n \t \"sms-loop-average-count-threshold\",\n-\t \"A threshold on the average loop count considered by the swing modulo \\\n-\t  scheduler\",\n-\t 0)\n+\t \"A threshold on the average loop count considered by the swing modulo scheduler\",\n+\t 0, 0, 0)\n \n DEFPARAM(HOT_BB_COUNT_FRACTION,\n \t \"hot-bb-count-fraction\",\n-\t \"Select fraction of the maximal count of repetitions of basic block in \\\n-program given basic block needs to have to be considered hot\",\n-\t 10000)\n+\t \"Select fraction of the maximal count of repetitions of basic block in program given basic block needs to have to be considered hot\",\n+\t 10000, 0, 0)\n DEFPARAM(HOT_BB_FREQUENCY_FRACTION,\n \t \"hot-bb-frequency-fraction\",\n-\t \"Select fraction of the maximal frequency of executions of basic \\\n-block in function given basic block needs to have to be considered hot\",\n-\t 1000)\n+\t \"Select fraction of the maximal frequency of executions of basic block in function given basic block needs to have to be considered hot\",\n+\t 1000, 0, 0)\n DEFPARAM(TRACER_DYNAMIC_COVERAGE_FEEDBACK,\n \t \"tracer-dynamic-coverage-feedback\",\n-\t \"The percentage of function, weighted by execution frequency, that \\\n-must be covered by trace formation. Used when profile feedback is available\",\n-\t 95)\n+\t \"The percentage of function, weighted by execution frequency, that must be covered by trace formation. Used when profile feedback is available\",\n+\t 95, 0, 100)\n DEFPARAM(TRACER_DYNAMIC_COVERAGE,\n \t \"tracer-dynamic-coverage\",\n-\t \"The percentage of function, weighted by execution frequency, that \\\n-must be covered by trace formation. Used when profile feedback is not available\",\n-\t 75)\n+\t \"The percentage of function, weighted by execution frequency, that must be covered by trace formation. Used when profile feedback is not available\",\n+\t 75, 0, 100)\n DEFPARAM(TRACER_MAX_CODE_GROWTH,\n \t \"tracer-max-code-growth\",\n \t \"Maximal code growth caused by tail duplication (in percent)\",\n-\t 100)\n+\t 100, 0, 0)\n DEFPARAM(TRACER_MIN_BRANCH_RATIO,\n \t \"tracer-min-branch-ratio\",\n-\t \"Stop reverse growth if the reverse probability of best edge is less \\\n-than this threshold (in percent)\",\n-\t 10)\n+\t \"Stop reverse growth if the reverse probability of best edge is less than this threshold (in percent)\",\n+\t 10, 0, 100)\n DEFPARAM(TRACER_MIN_BRANCH_PROBABILITY_FEEDBACK,\n \t \"tracer-min-branch-probability-feedback\",\n-\t \"Stop forward growth if the probability of best edge is less than \\\n-this threshold (in percent). Used when profile feedback is available\",\n-\t 80)\n+\t \"Stop forward growth if the probability of best edge is less than this threshold (in percent). Used when profile feedback is available\",\n+\t 80, 0, 100)\n DEFPARAM(TRACER_MIN_BRANCH_PROBABILITY,\n \t \"tracer-min-branch-probability\",\n-\t \"Stop forward growth if the probability of best edge is less than \\\n-this threshold (in percent). Used when profile feedback is not available\",\n-\t 50)\n+\t \"Stop forward growth if the probability of best edge is less than this threshold (in percent). Used when profile feedback is not available\",\n+\t 50, 0, 100)\n \n /* The maximum number of incoming edges to consider for crossjumping.  */\n DEFPARAM(PARAM_MAX_CROSSJUMP_EDGES,\n \t \"max-crossjump-edges\",\n \t \"The maximum number of incoming edges to consider for crossjumping\",\n-\t 100)\n+\t 100, 0, 0)\n \n /* The minimum number of matching instructions to consider for crossjumping.  */\n DEFPARAM(PARAM_MIN_CROSSJUMP_INSNS,\n      \"min-crossjump-insns\",\n      \"The minimum number of matching instructions to consider for crossjumping\",\n-     5)\n+     5, 0, 0)\n \n /* The maximum length of path considered in cse.  */\n DEFPARAM(PARAM_MAX_CSE_PATH_LENGTH,\n \t \"max-cse-path-length\",\n \t \"The maximum length of path considered in cse\",\n-\t 10)\n+\t 10, 0, 0)\n \n /* The cost of expression in loop invariant motion that is considered\n    expensive.  */\n DEFPARAM(PARAM_LIM_EXPENSIVE,\n \t \"lim-expensive\",\n \t \"The minimum cost of an expensive expression in the loop invariant motion\",\n-\t 20)\n+\t 20, 0, 0)\n \n /* Bound on number of candidates for induction variables below that\n    all candidates are considered for each use in induction variable\n@@ -350,27 +337,27 @@ DEFPARAM(PARAM_LIM_EXPENSIVE,\n DEFPARAM(PARAM_IV_CONSIDER_ALL_CANDIDATES_BOUND,\n \t \"iv-consider-all-candidates-bound\",\n \t \"Bound on number of candidates below that all candidates are considered in iv optimizations\",\n-\t 30)\n+\t 30, 0, 0)\n \n /* The induction variable optimizations give up on loops that contain more\n    induction variable uses.  */\n \n DEFPARAM(PARAM_IV_MAX_CONSIDERED_USES,\n \t \"iv-max-considered-uses\",\n \t \"Bound on number of iv uses in loop optimized in iv optimizations\",\n-\t 250)\n+\t 250, 0, 0)\n \n /* The product of the next two is used to decide whether or not to\n    use .GLOBAL_VAR.  See tree-dfa.c.  */\n DEFPARAM(PARAM_GLOBAL_VAR_THRESHOLD,\n \t\"global-var-threshold\",\n \t\"Given N calls and V call-clobbered vars in a function.  Use .GLOBAL_VAR if NxV is larger than this limit\",\n-\t500000)\n+\t500000, 0, 0)\n \n DEFPARAM(PARAM_MAX_CSELIB_MEMORY_LOCATIONS,\n \t \"max-cselib-memory-locations\",\n \t \"The maximum memory locations recorded by cselib\",\n-\t 500)\n+\t 500, 0, 0)\n \n #ifdef ENABLE_GC_ALWAYS_COLLECT\n # define GGC_MIN_EXPAND_DEFAULT 0\n@@ -382,45 +369,44 @@ DEFPARAM(PARAM_MAX_CSELIB_MEMORY_LOCATIONS,\n \n DEFPARAM(GGC_MIN_EXPAND,\n \t \"ggc-min-expand\",\n-\t \"Minimum heap expansion to trigger garbage collection, as \\\n-a percentage of the total size of the heap\",\n-\t GGC_MIN_EXPAND_DEFAULT)\n+\t \"Minimum heap expansion to trigger garbage collection, as a percentage of the total size of the heap\",\n+\t GGC_MIN_EXPAND_DEFAULT, 0, 0)\n \n DEFPARAM(GGC_MIN_HEAPSIZE,\n \t \"ggc-min-heapsize\",\n \t \"Minimum heap size before we start collecting garbage, in kilobytes\",\n-\t GGC_MIN_HEAPSIZE_DEFAULT)\n+\t GGC_MIN_HEAPSIZE_DEFAULT, 0, 0)\n \n #undef GGC_MIN_EXPAND_DEFAULT\n #undef GGC_MIN_HEAPSIZE_DEFAULT\n \n DEFPARAM(PARAM_MAX_RELOAD_SEARCH_INSNS,\n \t \"max-reload-search-insns\",\n \t \"The maximum number of instructions to search backward when looking for equivalent reload\",\n-\t 100)\n+\t 100, 0, 0)\n \n DEFPARAM(PARAM_MAX_ALIASED_VOPS,\n          \"max-aliased-vops\",\n \t \"The maximum number of virtual operands allowed to represent aliases before triggering alias grouping.\",\n-\t 500)\n+\t 500, 0, 0)\n \n DEFPARAM(PARAM_MAX_SCHED_REGION_BLOCKS,\n \t \"max-sched-region-blocks\",\n \t \"The maximum number of blocks in a region to be considered for interblock scheduling\",\n-\t 10)\n+\t 10, 0, 0)\n \n DEFPARAM(PARAM_MAX_SCHED_REGION_INSNS,\n \t \"max-sched-region-insns\",\n \t \"The maximum number of insns in a region to be considered for interblock scheduling\",\n-\t 100)\n+\t 100, 0, 0)\n \n /* INTEGER_CST nodes are shared for values [{-1,0} .. N) for\n    {signed,unsigned} integral types.  This determines N.\n    Experimentation shows 256 to be a good value.  */\n DEFPARAM (PARAM_INTEGER_SHARE_LIMIT,\n \t  \"integer-share-limit\",\n \t  \"The upper bound for sharing integer constants\",\n-\t  256)\n+\t  256, 2, 2)\n \n /*\n Local variables:"}, {"sha": "d1e583245ab62b58ee0fa52994658e908e0ec418", "filename": "gcc/params.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e06c0febd9372024c10fd6fab64bb212e2975106/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e06c0febd9372024c10fd6fab64bb212e2975106/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=e06c0febd9372024c10fd6fab64bb212e2975106", "patch": "@@ -48,6 +48,13 @@ typedef struct param_info\n   const char *const option;\n   /* The associated value.  */\n   int value;\n+\n+  /* Minimum acceptable value.  */\n+  int min_value;\n+  \n+  /* Maxiumum acceptable value, if greater than minimum  */\n+  int max_value;\n+  \n   /* A short description of the option.  */\n   const char *const help;\n } param_info;\n@@ -70,7 +77,7 @@ extern void set_param_value (const char *name, int value);\n \n typedef enum compiler_param\n {\n-#define DEFPARAM(enumerator, option, msgid, default) \\\n+#define DEFPARAM(enumerator, option, msgid, default, min, max) \\\n   enumerator,\n #include \"params.def\"\n #undef DEFPARAM"}, {"sha": "edfc55219b1e5b41c503aace8ed00a6700259912", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e06c0febd9372024c10fd6fab64bb212e2975106/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e06c0febd9372024c10fd6fab64bb212e2975106/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=e06c0febd9372024c10fd6fab64bb212e2975106", "patch": "@@ -367,11 +367,11 @@ int flag_evaluation_order = 0;\n const char *user_label_prefix;\n \n static const param_info lang_independent_params[] = {\n-#define DEFPARAM(ENUM, OPTION, HELP, DEFAULT) \\\n-  { OPTION, DEFAULT, HELP },\n+#define DEFPARAM(ENUM, OPTION, HELP, DEFAULT, MIN, MAX) \\\n+  { OPTION, DEFAULT, MIN, MAX, HELP },\n #include \"params.def\"\n #undef DEFPARAM\n-  { NULL, 0, NULL }\n+  { NULL, 0, 0, 0, NULL }\n };\n \n /* Here is a table, controlled by the tm.h file, listing each -m switch"}]}