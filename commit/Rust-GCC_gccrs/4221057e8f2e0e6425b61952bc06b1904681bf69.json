{"sha": "4221057e8f2e0e6425b61952bc06b1904681bf69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDIyMTA1N2U4ZjJlMGU2NDI1YjYxOTUyYmMwNmIxOTA0NjgxYmY2OQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-02-19T22:39:55Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-02-19T22:39:55Z"}, "message": "Makefile.in (STRICT2_WARN): Add -Wno-variadic-macros.\n\n        * Makefile.in (STRICT2_WARN): Add -Wno-variadic-macros.\n        * tree.c (build0, build1, build2, build3, build4): Split out from...\n        (build): ... here.  Call them.\n        * tree.h (build, _buildN1, _buildN2, _buildC1, _buildC2): New.\n\n        * convert.c (convert_to_integer): Remove extra build argument.\n        * tree-inline.c (expand_call_inline): Likewise.\nada/\n        * misc.c (record_code_position): Add third build arg for RTL_EXPR.\njava/\n        * parse.y (switch_label): Use make_node for DEFAULT_EXPR.\n\nFrom-SVN: r78126", "tree": {"sha": "94df3d1c9f4ce657fd99d4dcc5822e2ca9695645", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94df3d1c9f4ce657fd99d4dcc5822e2ca9695645"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4221057e8f2e0e6425b61952bc06b1904681bf69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4221057e8f2e0e6425b61952bc06b1904681bf69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4221057e8f2e0e6425b61952bc06b1904681bf69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4221057e8f2e0e6425b61952bc06b1904681bf69/comments", "author": null, "committer": null, "parents": [{"sha": "e5b792193379be3beab505f1a72fb4fedaf62e6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5b792193379be3beab505f1a72fb4fedaf62e6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5b792193379be3beab505f1a72fb4fedaf62e6b"}], "stats": {"total": 363, "additions": 243, "deletions": 120}, "files": [{"sha": "554829aa4cbc6e5f003e24f8a17e5d80fc224d7c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4221057e8f2e0e6425b61952bc06b1904681bf69/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4221057e8f2e0e6425b61952bc06b1904681bf69/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4221057e8f2e0e6425b61952bc06b1904681bf69", "patch": "@@ -1,3 +1,13 @@\n+2004-02-19  Richard Henderson  <rth@redhat.com>\n+\n+\t* Makefile.in (STRICT2_WARN): Add -Wno-variadic-macros.\n+\t* tree.c (build0, build1, build2, build3, build4): Split out from...\n+\t(build): ... here.  Call them.\n+\t* tree.h (build, _buildN1, _buildN2, _buildC1, _buildC2): New.\n+\n+\t* convert.c (convert_to_integer): Remove extra build argument.\n+\t* tree-inline.c (expand_call_inline): Likewise.\n+\n 2004-02-19  Richard Henderson  <rth@redhat.com>\n \n \t* c-opts.c (warn_variadic_macros): New."}, {"sha": "3f65e604d4cb4ba0000e7d29511836c9ddaa5bd9", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4221057e8f2e0e6425b61952bc06b1904681bf69/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4221057e8f2e0e6425b61952bc06b1904681bf69/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=4221057e8f2e0e6425b61952bc06b1904681bf69", "patch": "@@ -159,10 +159,12 @@ coverageexts = .{gcda,gcno}\n # STRICT_WARN and STRICT2_WARN are the additional warning flags to\n # apply to the back end and the C front end, which may be compiled\n # with other compilers.  This is partially controlled by configure in\n-# stage1, as not all versions of gcc understand -Wno-long-long.\n+# stage1, as not all versions of gcc understand -Wno-long-long or\n+# -Wno-variadic-macros.\n LOOSE_WARN = -W -Wall -Wwrite-strings -Wstrict-prototypes -Wmissing-prototypes\n STRICT_WARN = @strict1_warn@\n-STRICT2_WARN = -pedantic -Wno-long-long -Wold-style-definition @WERROR@\n+STRICT2_WARN = -pedantic -Wno-long-long -Wold-style-definition \\\n+  -Wno-variadic-macros @WERROR@\n \n # This is set by --enable-checking.  The idea is to catch forgotten\n # \"extern\" tags in header files."}, {"sha": "59bed8f0c8cf03805df2cce61431bccd644f918d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4221057e8f2e0e6425b61952bc06b1904681bf69/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4221057e8f2e0e6425b61952bc06b1904681bf69/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4221057e8f2e0e6425b61952bc06b1904681bf69", "patch": "@@ -1,3 +1,7 @@\n+2004-02-19  Richard Henderson  <rth@redhat.com>\n+\n+\t* misc.c (record_code_position): Add third build arg for RTL_EXPR.\n+\n 2004-02-18  Emmanuel Briot  <briot@act-europe.fr>\n \n \t* ali.ads, ali.adb (First_Sdep_Entry): No longer a constant, so that"}, {"sha": "a87331d23f2fea2262b86e062e0376b5258c4d75", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4221057e8f2e0e6425b61952bc06b1904681bf69/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4221057e8f2e0e6425b61952bc06b1904681bf69/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=4221057e8f2e0e6425b61952bc06b1904681bf69", "patch": "@@ -804,7 +804,7 @@ record_code_position (Node_Id gnat_node)\n        addressable needs some fixups and also for above reason.  */\n     save_gnu_tree (gnat_node,\n \t\t   build (RTL_EXPR, void_type_node, NULL_TREE,\n-\t\t\t  (tree) emit_note (NOTE_INSN_DELETED)),\n+\t\t\t  (tree) emit_note (NOTE_INSN_DELETED), NULL_TREE),\n \t\t   1);\n }\n "}, {"sha": "8fca41579637ffba0834c44298f16d49c9b22765", "filename": "gcc/convert.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4221057e8f2e0e6425b61952bc06b1904681bf69/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4221057e8f2e0e6425b61952bc06b1904681bf69/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=4221057e8f2e0e6425b61952bc06b1904681bf69", "patch": "@@ -523,8 +523,7 @@ convert_to_integer (tree type, tree expr)\n \t\t    return convert (type,\n \t\t\t\t    fold (build (ex_form, typex,\n \t\t\t\t\t\t convert (typex, arg0),\n-\t\t\t\t\t\t convert (typex, arg1),\n-\t\t\t\t\t\t 0)));\n+\t\t\t\t\t\t convert (typex, arg1))));\n \t\t  }\n \t      }\n \t  }"}, {"sha": "a0568c7084ba894c4195ff092daf1d04be26e1cd", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4221057e8f2e0e6425b61952bc06b1904681bf69/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4221057e8f2e0e6425b61952bc06b1904681bf69/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=4221057e8f2e0e6425b61952bc06b1904681bf69", "patch": "@@ -1,3 +1,7 @@\n+2004-02-19  Richard Henderson  <rth@redhat.com>\n+\n+\t* parse.y (switch_label): Use make_node for DEFAULT_EXPR.\n+\n 2004-02-16  Geoffrey Keating  <geoffk@apple.com>\n \n \t* Make-lang.in (java.install-man): Add extra dependencies."}, {"sha": "72cc9f3d103c37f9a4a7dfb969d13ac789d37b5f", "filename": "gcc/java/parse.y", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4221057e8f2e0e6425b61952bc06b1904681bf69/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4221057e8f2e0e6425b61952bc06b1904681bf69/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=4221057e8f2e0e6425b61952bc06b1904681bf69", "patch": "@@ -1635,7 +1635,7 @@ switch_label:\n \t\t}\n |\tDEFAULT_TK REL_CL_TK\n \t\t{\n-\t\t  tree lab = build (DEFAULT_EXPR, NULL_TREE, NULL_TREE);\n+\t\t  tree lab = make_node (DEFAULT_EXPR);\n \t\t  EXPR_WFL_LINECOL (lab) = $1.location;\n \t\t  java_method_add_stmt (current_function_decl, lab);\n \t\t}"}, {"sha": "42da58b29f28c04aa55b54e904e98d1731404c4d", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4221057e8f2e0e6425b61952bc06b1904681bf69/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4221057e8f2e0e6425b61952bc06b1904681bf69/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=4221057e8f2e0e6425b61952bc06b1904681bf69", "patch": "@@ -1377,7 +1377,7 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n      statements within the function to jump to.  The type of the\n      statement expression is the return type of the function call.  */\n   stmt = NULL;\n-  expr = build (BLOCK, TREE_TYPE (TREE_TYPE (fn)), stmt);\n+  expr = build (BLOCK, TREE_TYPE (TREE_TYPE (fn)));\n #endif /* INLINER_FOR_JAVA */\n \n   /* Local declarations will be replaced by their equivalents in this"}, {"sha": "d2b79bcca3cfc211eb4174fc62c73e670fbc4e21", "filename": "gcc/tree.c", "status": "modified", "additions": 199, "deletions": 112, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4221057e8f2e0e6425b61952bc06b1904681bf69/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4221057e8f2e0e6425b61952bc06b1904681bf69/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=4221057e8f2e0e6425b61952bc06b1904681bf69", "patch": "@@ -2286,127 +2286,31 @@ stabilize_reference_1 (tree e)\n \f\n /* Low-level constructors for expressions.  */\n \n-/* Build an expression of code CODE, data type TYPE,\n-   and operands as specified by the arguments ARG1 and following arguments.\n-   Expressions and reference nodes can be created this way.\n-   Constants, decls, types and misc nodes cannot be.  */\n+/* Build an expression of code CODE, data type TYPE, and operands as\n+   specified.  Expressions and reference nodes can be created this way.\n+   Constants, decls, types and misc nodes cannot be.\n+\n+   We define 5 non-variadic functions, from 0 to 4 arguments.  This is\n+   enough for all extant tree codes.  These functions can be called \n+   directly (preferably!), but can also be obtained via GCC preprocessor\n+   magic within the build macro.  */\n \n tree\n-build (enum tree_code code, tree tt, ...)\n+build0 (enum tree_code code, tree tt)\n {\n   tree t;\n-  int length;\n-  int i;\n-  int fro;\n-  int constant;\n-  va_list p;\n-  tree node;\n \n-  va_start (p, tt);\n+#ifdef ENABLE_CHECKING\n+  if (TREE_CODE_LENGTH (code) != 0)\n+    abort ();\n+#endif\n \n   t = make_node (code);\n-  length = TREE_CODE_LENGTH (code);\n   TREE_TYPE (t) = tt;\n \n-  /* Below, we automatically set TREE_SIDE_EFFECTS and TREE_READONLY for the\n-     result based on those same flags for the arguments.  But if the\n-     arguments aren't really even `tree' expressions, we shouldn't be trying\n-     to do this.  */\n-  fro = first_rtl_op (code);\n-\n-  /* Expressions without side effects may be constant if their\n-     arguments are as well.  */\n-  constant = (TREE_CODE_CLASS (code) == '<'\n-\t      || TREE_CODE_CLASS (code) == '1'\n-\t      || TREE_CODE_CLASS (code) == '2'\n-\t      || TREE_CODE_CLASS (code) == 'c');\n-\n-  if (length == 2)\n-    {\n-      /* This is equivalent to the loop below, but faster.  */\n-      tree arg0 = va_arg (p, tree);\n-      tree arg1 = va_arg (p, tree);\n-\n-      TREE_OPERAND (t, 0) = arg0;\n-      TREE_OPERAND (t, 1) = arg1;\n-      TREE_READONLY (t) = 1;\n-      if (arg0 && fro > 0)\n-\t{\n-\t  if (TREE_SIDE_EFFECTS (arg0))\n-\t    TREE_SIDE_EFFECTS (t) = 1;\n-\t  if (!TREE_READONLY (arg0))\n-\t    TREE_READONLY (t) = 0;\n-\t  if (!TREE_CONSTANT (arg0))\n-\t    constant = 0;\n-\t}\n-\n-      if (arg1 && fro > 1)\n-\t{\n-\t  if (TREE_SIDE_EFFECTS (arg1))\n-\t    TREE_SIDE_EFFECTS (t) = 1;\n-\t  if (!TREE_READONLY (arg1))\n-\t    TREE_READONLY (t) = 0;\n-\t  if (!TREE_CONSTANT (arg1))\n-\t    constant = 0;\n-\t}\n-    }\n-  else if (length == 1)\n-    {\n-      tree arg0 = va_arg (p, tree);\n-\n-      /* The only one-operand cases we handle here are those with side-effects.\n-\t Others are handled with build1.  So don't bother checked if the\n-\t arg has side-effects since we'll already have set it.\n-\n-\t ??? This really should use build1 too.  */\n-      if (TREE_CODE_CLASS (code) != 's')\n-\tabort ();\n-      TREE_OPERAND (t, 0) = arg0;\n-    }\n-  else\n-    {\n-      for (i = 0; i < length; i++)\n-\t{\n-\t  tree operand = va_arg (p, tree);\n-\n-\t  TREE_OPERAND (t, i) = operand;\n-\t  if (operand && fro > i)\n-\t    {\n-\t      if (TREE_SIDE_EFFECTS (operand))\n-\t\tTREE_SIDE_EFFECTS (t) = 1;\n-\t      if (!TREE_CONSTANT (operand))\n-\t\tconstant = 0;\n-\t    }\n-\t}\n-    }\n-  va_end (p);\n-\n-  TREE_CONSTANT (t) = constant;\n-  \n-  if (code == CALL_EXPR && !TREE_SIDE_EFFECTS (t))\n-    {\n-      /* Calls have side-effects, except those to const or\n-\t pure functions.  */\n-      i = call_expr_flags (t);\n-      if (!(i & (ECF_CONST | ECF_PURE)))\n-\tTREE_SIDE_EFFECTS (t) = 1;\n-\n-      /* And even those have side-effects if their arguments do.  */\n-      else for (node = TREE_OPERAND (t, 1); node; node = TREE_CHAIN (node))\n-\tif (TREE_SIDE_EFFECTS (TREE_VALUE (node)))\n-\t  {\n-\t    TREE_SIDE_EFFECTS (t) = 1;\n-\t    break;\n-\t  }\n-    }\n-\n   return t;\n }\n \n-/* Same as above, but only builds for unary operators.\n-   Saves lions share of calls to `build'; cuts down use\n-   of varargs, which is expensive for RISC machines.  */\n-\n tree\n build1 (enum tree_code code, tree type, tree node)\n {\n@@ -2435,9 +2339,7 @@ build1 (enum tree_code code, tree type, tree node)\n #endif\n \n #ifdef ENABLE_CHECKING\n-  if (TREE_CODE_CLASS (code) == '2'\n-      || TREE_CODE_CLASS (code) == '<'\n-      || TREE_CODE_LENGTH (code) != 1)\n+  if (TREE_CODE_LENGTH (code) != 1)\n     abort ();\n #endif /* ENABLE_CHECKING */\n \n@@ -2512,6 +2414,191 @@ build1 (enum tree_code code, tree type, tree node)\n   return t;\n }\n \n+#define PROCESS_ARG(N)\t\t\t\\\n+  do {\t\t\t\t\t\\\n+    TREE_OPERAND (t, N) = arg##N;\t\\\n+    if (arg##N && fro > N)\t\t\\\n+      {\t\t\t\t\t\\\n+        if (TREE_SIDE_EFFECTS (arg##N))\t\\\n+\t  side_effects = 1;\t\t\\\n+        if (!TREE_READONLY (arg##N))\t\\\n+\t  read_only = 0;\t\t\\\n+        if (!TREE_CONSTANT (arg##N))\t\\\n+\t  constant = 0;\t\t\t\\\n+      }\t\t\t\t\t\\\n+  } while (0)\n+\n+tree\n+build2 (enum tree_code code, tree tt, tree arg0, tree arg1)\n+{\n+  bool constant, read_only, side_effects;\n+  tree t;\n+  int fro;\n+\n+#ifdef ENABLE_CHECKING\n+  if (TREE_CODE_LENGTH (code) != 2)\n+    abort ();\n+#endif\n+\n+  t = make_node (code);\n+  TREE_TYPE (t) = tt;\n+\n+  /* Below, we automatically set TREE_SIDE_EFFECTS and TREE_READONLY for the\n+     result based on those same flags for the arguments.  But if the\n+     arguments aren't really even `tree' expressions, we shouldn't be trying\n+     to do this.  */\n+  fro = first_rtl_op (code);\n+\n+  /* Expressions without side effects may be constant if their\n+     arguments are as well.  */\n+  constant = (TREE_CODE_CLASS (code) == '<'\n+\t      || TREE_CODE_CLASS (code) == '2');\n+  read_only = 1;\n+  side_effects = TREE_SIDE_EFFECTS (t);\n+\n+  PROCESS_ARG(0);\n+  PROCESS_ARG(1);\n+\n+  if (code == CALL_EXPR && !side_effects)\n+    {\n+      tree node;\n+      int i;\n+\n+      /* Calls have side-effects, except those to const or\n+\t pure functions.  */\n+      i = call_expr_flags (t);\n+      if (!(i & (ECF_CONST | ECF_PURE)))\n+\tside_effects = 1;\n+\n+      /* And even those have side-effects if their arguments do.  */\n+      else for (node = TREE_OPERAND (t, 1); node; node = TREE_CHAIN (node))\n+\tif (TREE_SIDE_EFFECTS (TREE_VALUE (node)))\n+\t  {\n+\t    side_effects = 1;\n+\t    break;\n+\t  }\n+    }\n+\n+  TREE_READONLY (t) = read_only;\n+  TREE_CONSTANT (t) = constant;\n+  TREE_SIDE_EFFECTS (t) = side_effects;  \n+\n+  return t;\n+}\n+\n+tree\n+build3 (enum tree_code code, tree tt, tree arg0, tree arg1, tree arg2)\n+{\n+  bool constant, read_only, side_effects;\n+  tree t;\n+  int fro;\n+\n+  /* ??? Quite a lot of existing code passes one too many arguments to\n+     CALL_EXPR.  Not going to fix them, because CALL_EXPR is about to\n+     grow a new argument, so it would just mean changing them back.  */\n+  if (code == CALL_EXPR)\n+    {\n+      if (arg2 != NULL_TREE)\n+\tabort ();\n+      return build2 (code, tt, arg0, arg1);\n+    }\n+\n+#ifdef ENABLE_CHECKING\n+  if (TREE_CODE_LENGTH (code) != 3)\n+    abort ();\n+#endif\n+\n+  t = make_node (code);\n+  TREE_TYPE (t) = tt;\n+\n+  fro = first_rtl_op (code);\n+\n+  side_effects = TREE_SIDE_EFFECTS (t);\n+\n+  PROCESS_ARG(0);\n+  PROCESS_ARG(1);\n+  PROCESS_ARG(2);\n+\n+  TREE_SIDE_EFFECTS (t) = side_effects;  \n+\n+  return t;\n+}\n+\n+tree\n+build4 (enum tree_code code, tree tt, tree arg0, tree arg1,\n+\ttree arg2, tree arg3)\n+{\n+  bool constant, read_only, side_effects;\n+  tree t;\n+  int fro;\n+\n+#ifdef ENABLE_CHECKING\n+  if (TREE_CODE_LENGTH (code) != 4)\n+    abort ();\n+#endif\n+\n+  t = make_node (code);\n+  TREE_TYPE (t) = tt;\n+\n+  fro = first_rtl_op (code);\n+\n+  side_effects = TREE_SIDE_EFFECTS (t);\n+\n+  PROCESS_ARG(0);\n+  PROCESS_ARG(1);\n+  PROCESS_ARG(2);\n+  PROCESS_ARG(3);\n+\n+  TREE_SIDE_EFFECTS (t) = side_effects;  \n+\n+  return t;\n+}\n+\n+/* Backup definition for non-gcc build compilers.  */\n+\n+tree\n+(build) (enum tree_code code, tree tt, ...)\n+{\n+  tree t, arg0, arg1, arg2, arg3;\n+  int length = TREE_CODE_LENGTH (code);\n+  va_list p;\n+\n+  va_start (p, tt);\n+  switch (length)\n+    {\n+    case 0:\n+      t = build0 (code, tt);\n+      break;\n+    case 1:\n+      arg0 = va_arg (p, tree);\n+      t = build1 (code, tt, arg0);\n+      break;\n+    case 2:\n+      arg0 = va_arg (p, tree);\n+      arg1 = va_arg (p, tree);\n+      t = build2 (code, tt, arg0, arg1);\n+      break;\n+    case 3:\n+      arg0 = va_arg (p, tree);\n+      arg1 = va_arg (p, tree);\n+      arg2 = va_arg (p, tree);\n+      t = build3 (code, tt, arg0, arg1, arg2);\n+      break;\n+    case 4:\n+      arg0 = va_arg (p, tree);\n+      arg1 = va_arg (p, tree);\n+      arg2 = va_arg (p, tree);\n+      arg3 = va_arg (p, tree);\n+      t = build4 (code, tt, arg0, arg1, arg2, arg3);\n+      break;\n+    default:\n+      abort ();\n+    }\n+  va_end (p);\n+\n+  return t;\n+}\n+\n /* Similar except don't specify the TREE_TYPE\n    and leave the TREE_SIDE_EFFECTS as 0.\n    It is permissible for arguments to be null,"}, {"sha": "25ba23a211e56c661fc54dfb516870814d10fb39", "filename": "gcc/tree.h", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4221057e8f2e0e6425b61952bc06b1904681bf69/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4221057e8f2e0e6425b61952bc06b1904681bf69/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=4221057e8f2e0e6425b61952bc06b1904681bf69", "patch": "@@ -2112,13 +2112,30 @@ extern tree maybe_get_identifier (const char *);\n extern tree build (enum tree_code, tree, ...);\n extern tree build_nt (enum tree_code, ...);\n \n+#if GCC_VERSION >= 3000 || __STDC_VERSION__ >= 199901L\n+/* Use preprocessor trickery to map \"build\" to \"buildN\" where N is the\n+   expected number of arguments.  This is used for both efficiency (no\n+   varargs), and checking (verifying number of passed arguments).  */\n+#define build(code, ...) \\\n+  _buildN1(build, _buildC1(__VA_ARGS__))(code, __VA_ARGS__)\n+#define _buildN1(BASE, X)\t_buildN2(BASE, X)\n+#define _buildN2(BASE, X)\tBASE##X\n+#define _buildC1(...)\t\t_buildC2(__VA_ARGS__,9,8,7,6,5,4,3,2,1,0,0)\n+#define _buildC2(x,a1,a2,a3,a4,a5,a6,a7,a8,a9,c,...) c\n+#endif\n+\n+extern tree build0 (enum tree_code, tree);\n+extern tree build1 (enum tree_code, tree, tree);\n+extern tree build2 (enum tree_code, tree, tree, tree);\n+extern tree build3 (enum tree_code, tree, tree, tree, tree);\n+extern tree build4 (enum tree_code, tree, tree, tree, tree, tree);\n+\n extern tree build_int_2_wide (unsigned HOST_WIDE_INT, HOST_WIDE_INT);\n extern tree build_vector (tree, tree);\n extern tree build_constructor (tree, tree);\n extern tree build_real_from_int_cst (tree, tree);\n extern tree build_complex (tree, tree, tree);\n extern tree build_string (int, const char *);\n-extern tree build1 (enum tree_code, tree, tree);\n extern tree build_tree_list (tree, tree);\n extern tree build_decl (enum tree_code, tree, tree);\n extern tree build_block (tree, tree, tree, tree, tree);"}]}