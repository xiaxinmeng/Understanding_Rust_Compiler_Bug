{"sha": "1ef0df4745a48b0ba491b460c041cfb720f0de46", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWVmMGRmNDc0NWE0OGIwYmE0OTFiNDYwYzA0MWNmYjcyMGYwZGU0Ng==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2005-09-09T18:56:16Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2005-09-09T18:56:16Z"}, "message": "re PR c++/22252 (pragma interface/implementation still break synthesized methods)\n\n\tPR c++/22252\n\t* decl.c (start_preparsed_function): Do not pay attention to\n\t#pragma interface for implicitly-defined methods.\n\t* decl2.c (cp_finish_file): Do not complain about uses of inline\n\tfunctions that have bodies, even if we decided not to emit the\n\tbody in this translation unit.\n\t* semantics.c (note_decl_for_pch): Do not mess with linkage.\n\t(expand_or_defer_fn): Make inline, non-template functions COMDAT\n\tat this point.\n\n\tPR c++/22252\n\t* g++.dg/ext/interface1.C: New test.\n\t* g++.dg/ext/interface1.h: Likewise.\n\t* g++.dg/ext/interface1a.cc: Likewise.\n\nFrom-SVN: r104103", "tree": {"sha": "c630c6970630810e37f3912ce9d87453754b14fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c630c6970630810e37f3912ce9d87453754b14fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ef0df4745a48b0ba491b460c041cfb720f0de46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ef0df4745a48b0ba491b460c041cfb720f0de46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ef0df4745a48b0ba491b460c041cfb720f0de46", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ef0df4745a48b0ba491b460c041cfb720f0de46/comments", "author": null, "committer": null, "parents": [{"sha": "7aba8abebf67491594a3b6274d441bcbf47d894b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7aba8abebf67491594a3b6274d441bcbf47d894b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7aba8abebf67491594a3b6274d441bcbf47d894b"}], "stats": {"total": 124, "additions": 89, "deletions": 35}, "files": [{"sha": "ae12c20e2ff817a2a7e75b6ef7c6d0a2e4f90664", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef0df4745a48b0ba491b460c041cfb720f0de46/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef0df4745a48b0ba491b460c041cfb720f0de46/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1ef0df4745a48b0ba491b460c041cfb720f0de46", "patch": "@@ -1,3 +1,15 @@\n+2005-09-09  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/22252\n+\t* decl.c (start_preparsed_function): Do not pay attention to\n+\t#pragma interface for implicitly-defined methods.\n+\t* decl2.c (cp_finish_file): Do not complain about uses of inline\n+\tfunctions that have bodies, even if we decided not to emit the\n+\tbody in this translation unit.\n+\t* semantics.c (note_decl_for_pch): Do not mess with linkage.\n+\t(expand_or_defer_fn): Make inline, non-template functions COMDAT\n+\tat this point.\n+\n 2005-09-08  Richard Henderson  <rth@redhat.com>\n \n \tPR debug/23190"}, {"sha": "f33276144bfbefad543960f32b4587ea4caedc5b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef0df4745a48b0ba491b460c041cfb720f0de46/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef0df4745a48b0ba491b460c041cfb720f0de46/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=1ef0df4745a48b0ba491b460c041cfb720f0de46", "patch": "@@ -10008,6 +10008,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n   tree current_function_parms;\n   struct c_fileinfo *finfo\n     = get_fileinfo (lbasename (LOCATION_FILE (DECL_SOURCE_LOCATION (decl1))));\n+  bool honor_interface;\n \n   /* Sanity check.  */\n   gcc_assert (TREE_CODE (TREE_VALUE (void_list_node)) == VOID_TYPE);\n@@ -10222,6 +10223,15 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n \t}\n     }\n \n+  honor_interface = (!DECL_TEMPLATE_INSTANTIATION (decl1)\n+\t\t     /* Implicitly-defined methods (like the\n+\t\t\tdestructor for a class in which no destructor\n+\t\t\tis explicitly declared) must not be defined\n+\t\t\tuntil their definition is needed.  So, we\n+\t\t\tignore interface specifications for\n+\t\t\tcompiler-generated functions.  */\n+\t\t     && !DECL_ARTIFICIAL (decl1));\n+\t\t     \n   if (DECL_INTERFACE_KNOWN (decl1))\n     {\n       tree ctx = decl_function_context (decl1);\n@@ -10238,8 +10248,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n   /* If this function belongs to an interface, it is public.\n      If it belongs to someone else's interface, it is also external.\n      This only affects inlines and template instantiations.  */\n-  else if (finfo->interface_unknown == 0\n-\t   && ! DECL_TEMPLATE_INSTANTIATION (decl1))\n+  else if (!finfo->interface_unknown && honor_interface)\n     {\n       if (DECL_DECLARED_INLINE_P (decl1)\n \t  || DECL_TEMPLATE_INSTANTIATION (decl1)\n@@ -10256,7 +10265,6 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n \t}\n       else\n \tDECL_EXTERNAL (decl1) = 0;\n-      DECL_NOT_REALLY_EXTERN (decl1) = 0;\n       DECL_INTERFACE_KNOWN (decl1) = 1;\n       /* If this function is in an interface implemented in this file,\n \t make sure that the backend knows to emit this function\n@@ -10265,7 +10273,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n \tmark_needed (decl1);\n     }\n   else if (finfo->interface_unknown && finfo->interface_only\n-\t   && ! DECL_TEMPLATE_INSTANTIATION (decl1))\n+\t   && honor_interface)\n     {\n       /* If MULTIPLE_SYMBOL_SPACES is defined and we saw a #pragma\n \t interface, we will have both finfo->interface_unknown and"}, {"sha": "8a7d7d6145250c1a3b8574f5141f2d592922dcdb", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef0df4745a48b0ba491b460c041cfb720f0de46/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef0df4745a48b0ba491b460c041cfb720f0de46/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=1ef0df4745a48b0ba491b460c041cfb720f0de46", "patch": "@@ -2976,18 +2976,22 @@ cp_finish_file (void)\n \t  if (!DECL_SAVED_TREE (decl))\n \t    continue;\n \n-\t  import_export_decl (decl);\n-\n \t  /* We lie to the back-end, pretending that some functions\n \t     are not defined when they really are.  This keeps these\n \t     functions from being put out unnecessarily.  But, we must\n \t     stop lying when the functions are referenced, or if they\n-\t     are not comdat since they need to be put out now.  This\n-\t     is done in a separate for cycle, because if some deferred\n-\t     function is contained in another deferred function later\n-\t     in deferred_fns varray, rest_of_compilation would skip\n-\t     this function and we really cannot expand the same\n-\t     function twice.  */\n+\t     are not comdat since they need to be put out now.  If\n+\t     DECL_INTERFACE_KNOWN, then we have already set\n+\t     DECL_EXTERNAL appropriately, so there's no need to check\n+\t     again, and we do not want to clear DECL_EXTERNAL if a\n+\t     previous call to import_export_decl set it.\n+\t     \n+\t     This is done in a separate for cycle, because if some\n+\t     deferred function is contained in another deferred\n+\t     function later in deferred_fns varray,\n+\t     rest_of_compilation would skip this function and we\n+\t     really cannot expand the same function twice.  */\n+\t  import_export_decl (decl);\n \t  if (DECL_NOT_REALLY_EXTERN (decl)\n \t      && DECL_INITIAL (decl)\n \t      && decl_needed_p (decl))\n@@ -3047,13 +3051,12 @@ cp_finish_file (void)\n \t  TREE_USED (decl) && DECL_DECLARED_INLINE_P (decl)\n \t  /* But not defined.  */\n \t  && DECL_REALLY_EXTERN (decl)\n-\t  /* If we decided to emit this function in another\n-\t     translation unit, the fact that the definition was\n-\t     missing here likely indicates only that the repository\n-\t     decided to place the function elsewhere.  With -Winline,\n-\t     we will still warn if we could not inline the\n-\t     function.  */\n-\t  && !flag_use_repository\n+\t  /* If the definition actually was available here, then the\n+\t     fact that the function was not defined merely represents\n+\t     that for some reason (use of a template repository,\n+\t     #pragma interface, etc.) we decided not to emit the\n+\t     definition here.  */\n+\t  && !DECL_INITIAL (decl)\n \t  /* An explicit instantiation can be used to specify\n \t     that the body is in another unit. It will have\n \t     already verified there was a definition.  */"}, {"sha": "f78da9338cc2e5007535df2d7e1089c60dde882d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef0df4745a48b0ba491b460c041cfb720f0de46/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef0df4745a48b0ba491b460c041cfb720f0de46/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=1ef0df4745a48b0ba491b460c041cfb720f0de46", "patch": "@@ -5939,8 +5939,8 @@ tsubst_template_arg (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\t\t\t\t tf_error, /*in_decl=*/NULL_TREE,\n \t\t\t\t\t /*function_p=*/false);\n \t      processing_template_decl = saved_processing_template_decl;\n+\t      r = fold (r);\n \t    }\n-\t  r = fold (r);\n \t}\n     }\n   return r;"}, {"sha": "36914573e6e0265ff3702f43e7474e4e45508752", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef0df4745a48b0ba491b460c041cfb720f0de46/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef0df4745a48b0ba491b460c041cfb720f0de46/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=1ef0df4745a48b0ba491b460c041cfb720f0de46", "patch": "@@ -2259,20 +2259,6 @@ note_decl_for_pch (tree decl)\n {\n   gcc_assert (pch_file);\n \n-  /* A non-template inline function with external linkage will always\n-     be COMDAT.  As we must eventually determine the linkage of all\n-     functions, and as that causes writes to the data mapped in from\n-     the PCH file, it's advantageous to mark the functions at this\n-     point.  */\n-  if (TREE_CODE (decl) == FUNCTION_DECL\n-      && TREE_PUBLIC (decl)\n-      && DECL_DECLARED_INLINE_P (decl)\n-      && !DECL_IMPLICIT_INSTANTIATION (decl))\n-    {\n-      comdat_linkage (decl);\n-      DECL_INTERFACE_KNOWN (decl) = 1;\n-    }\n-\n   /* There's a good chance that we'll have to mangle names at some\n      point, even if only for emission in debugging information.  */\n   if (TREE_CODE (decl) == VAR_DECL\n@@ -3041,11 +3027,28 @@ expand_or_defer_fn (tree fn)\n      these functions so that it can inline them as appropriate.  */\n   if (DECL_DECLARED_INLINE_P (fn) || DECL_IMPLICIT_INSTANTIATION (fn))\n     {\n-      if (!at_eof)\n+      if (DECL_INTERFACE_KNOWN (fn))\n+\t/* We've already made a decision as to how this function will\n+\t   be handled.  */;\n+      else if (!at_eof)\n \t{\n \t  DECL_EXTERNAL (fn) = 1;\n \t  DECL_NOT_REALLY_EXTERN (fn) = 1;\n \t  note_vague_linkage_fn (fn);\n+\t  /* A non-template inline function with external linkage will\n+\t     always be COMDAT.  As we must eventually determine the\n+\t     linkage of all functions, and as that causes writes to\n+\t     the data mapped in from the PCH file, it's advantageous\n+\t     to mark the functions at this point.  */\n+\t  if (!DECL_IMPLICIT_INSTANTIATION (fn))\n+\t    {\n+\t      /* This function must have external linkage, as\n+\t\t otherwise DECL_INTERFACE_KNOWN would have been\n+\t\t set.  */\n+\t      gcc_assert (TREE_PUBLIC (fn));\n+\t      comdat_linkage (fn);\n+\t      DECL_INTERFACE_KNOWN (fn) = 1;\n+\t    }\n \t}\n       else\n \timport_export_decl (fn);"}, {"sha": "3942c3348a86daff3801359c08fd59b4ed1a9897", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef0df4745a48b0ba491b460c041cfb720f0de46/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef0df4745a48b0ba491b460c041cfb720f0de46/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1ef0df4745a48b0ba491b460c041cfb720f0de46", "patch": "@@ -1,3 +1,10 @@\n+2005-09-09  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/22252\n+\t* g++.dg/ext/interface1.C: New test.\n+\t* g++.dg/ext/interface1.h: Likewise.\n+\t* g++.dg/ext/interface1a.cc: Likewise.\n+\n 2005-09-09  Thomas Koenig  <Thomas.Koenig@online.de>\n \n \t* gfortran.dg/iomsg_1.f90:  New test case."}, {"sha": "0f803abc492bd99dddeaa27cdaccbc687f193953", "filename": "gcc/testsuite/g++.dg/ext/interface1.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef0df4745a48b0ba491b460c041cfb720f0de46/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Finterface1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef0df4745a48b0ba491b460c041cfb720f0de46/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Finterface1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Finterface1.C?ref=1ef0df4745a48b0ba491b460c041cfb720f0de46", "patch": "@@ -0,0 +1,7 @@\n+// PR c++/22252\n+// { dg-do link }\n+// { dg-additional-sources \"interface1a.cc\" }\n+// { dg-options \"-fno-inline\" }\n+\n+#pragma implementation \n+#include \"interface1.h\""}, {"sha": "ce91527b8b9dd2f84b1259242c6bac460f3f9cc4", "filename": "gcc/testsuite/g++.dg/ext/interface1.h", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef0df4745a48b0ba491b460c041cfb720f0de46/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Finterface1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef0df4745a48b0ba491b460c041cfb720f0de46/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Finterface1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Finterface1.h?ref=1ef0df4745a48b0ba491b460c041cfb720f0de46", "patch": "@@ -0,0 +1,10 @@\n+#pragma interface\n+struct B\n+{\n+  B(){};\n+  ~B(){}\n+};\n+struct A {\n+  B a;\n+\n+};"}, {"sha": "1859d5ce3ab94b9b70381e0d14d73bc97e9f5698", "filename": "gcc/testsuite/g++.dg/ext/interface1a.cc", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef0df4745a48b0ba491b460c041cfb720f0de46/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Finterface1a.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef0df4745a48b0ba491b460c041cfb720f0de46/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Finterface1a.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Finterface1a.cc?ref=1ef0df4745a48b0ba491b460c041cfb720f0de46", "patch": "@@ -0,0 +1,4 @@\n+#include \"interface1.h\"\n+A a;\n+int main() {}\n+"}]}