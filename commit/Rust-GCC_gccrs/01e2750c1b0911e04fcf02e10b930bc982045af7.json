{"sha": "01e2750c1b0911e04fcf02e10b930bc982045af7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFlMjc1MGMxYjA5MTFlMDRmY2YwMmUxMGI5MzBiYzk4MjA0NWFmNw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-15T21:01:40Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-15T21:01:40Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r993", "tree": {"sha": "54b6f37eedfbb85c4c749feb710c882adc580ffd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54b6f37eedfbb85c4c749feb710c882adc580ffd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01e2750c1b0911e04fcf02e10b930bc982045af7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01e2750c1b0911e04fcf02e10b930bc982045af7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01e2750c1b0911e04fcf02e10b930bc982045af7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01e2750c1b0911e04fcf02e10b930bc982045af7/comments", "author": null, "committer": null, "parents": [{"sha": "cebfccda777a908ab801b7359b6c445377ecea0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cebfccda777a908ab801b7359b6c445377ecea0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cebfccda777a908ab801b7359b6c445377ecea0d"}], "stats": {"total": 56, "additions": 45, "deletions": 11}, "files": [{"sha": "0a3b99d72d9f89cb4cf6ed90de8db4005dd9fee4", "filename": "gcc/config/svr4.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01e2750c1b0911e04fcf02e10b930bc982045af7/gcc%2Fconfig%2Fsvr4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01e2750c1b0911e04fcf02e10b930bc982045af7/gcc%2Fconfig%2Fsvr4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsvr4.h?ref=01e2750c1b0911e04fcf02e10b930bc982045af7", "patch": "@@ -249,7 +249,10 @@ do {\t\t\t\t \t\t\t\t\\\n /* #define MULTIBYTE_CHARS */\n \n #undef ASM_BYTE_OP\n-#define ASM_BYTE_OP\t\"\\t.byte\"\n+#define ASM_BYTE_OP\t\".byte\"\n+\n+#undef SET_ASM_OP\n+#define SET_ASM_OP\t\".set\"\n \n /* This is how to begin an assembly language file.  Most svr4 assemblers want\n    at least a .file directive to come first, and some want to see a .version"}, {"sha": "f680465404be220eab170fbaa5f08334345bb87c", "filename": "gcc/dbxout.c", "status": "modified", "additions": 41, "deletions": 10, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01e2750c1b0911e04fcf02e10b930bc982045af7/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01e2750c1b0911e04fcf02e10b930bc982045af7/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=01e2750c1b0911e04fcf02e10b930bc982045af7", "patch": "@@ -94,8 +94,8 @@ extern int errno;\n #define ASM_STABN_OP \".stabn\"\n #endif\n \n-#ifndef DBX_DECL_STABS_CODE\n-#define DBX_DECL_STABS_CODE N_LSYM\n+#ifndef DBX_TYPE_DECL_STABS_CODE\n+#define DBX_TYPE_DECL_STABS_CODE N_LSYM\n #endif\n \n #ifndef DBX_STATIC_CONST_VAR_CODE\n@@ -110,6 +110,10 @@ extern int errno;\n #define DBX_REGPARM_STABS_LETTER 'P'\n #endif\n \n+#ifndef DBX_MEMPARM_STABS_LETTER\n+#define DBX_MEMPARM_STABS_LETTER 'p'\n+#endif\n+\n /* Nonzero means if the type has methods, only output debugging\n    information if methods are actually written to the asm file.  */\n \n@@ -1098,6 +1102,9 @@ dbxout_type (type, full, show_arg_types)\n \t  fprintf (asmfile, \":\");\n \t  return;\n \t}\n+#ifdef DBX_OUTPUT_ENUM\n+      DBX_OUTPUT_ENUM (asmfile, type);\n+#else\n       putc ('e', asmfile);\n       CHARS (1);\n       for (tem = TYPE_VALUES (type); tem; tem = TREE_CHAIN (tem))\n@@ -1110,6 +1117,7 @@ dbxout_type (type, full, show_arg_types)\n \t}\n       putc (';', asmfile);\n       CHARS (1);\n+#endif\n       break;\n \n     case POINTER_TYPE:\n@@ -1367,6 +1375,16 @@ dbxout_symbol (decl, local)\n \t    fprintf (asmfile, \"%s \\\"%s:\", ASM_STABS_OP,\n \t\t     IDENTIFIER_POINTER (DECL_NAME (decl)));\n \n+/* #ifndef DBX_NO_EXTRA_TAGS   rms: I think this is no longer needed.  */\n+\t    /* This section makes absolutely no sense to me. Why would a tag\n+\t       ever be needed at this point? The result of this is that any\n+\t       structure typedef with the tag omitted is treated as if the\n+\t       tag was given to be the same as the typedef name. Probably\n+\t       no harm in it, unless the programmer used the same name for\n+\t       the tag of a *different* structure. At any rate, Alliant's\n+\t       debugger would want the tag output before the typedef, so\n+\t       this code still loses.  -- hyc */\n+\n \t    /* Short cut way to output a tag also.  */\n \t    if ((TREE_CODE (type) == RECORD_TYPE\n \t\t || TREE_CODE (type) == UNION_TYPE)\n@@ -1380,9 +1398,10 @@ dbxout_symbol (decl, local)\n \t\telse\n \t\t  tag_needed = 1;\n \t      }\n+/* #endif */\n \n \t    putc ('t', asmfile);\n-\t    current_sym_code = DBX_DECL_STABS_CODE;\n+\t    current_sym_code = DBX_TYPE_DECL_STABS_CODE;\n \n \t    dbxout_type (type, 1, 0);\n \t    dbxout_finish_symbol (decl);\n@@ -1400,7 +1419,7 @@ dbxout_symbol (decl, local)\n \t    if (TREE_CODE (name) == TYPE_DECL)\n \t      name = DECL_NAME (name);\n \n-\t    current_sym_code = DBX_DECL_STABS_CODE;\n+\t    current_sym_code = DBX_TYPE_DECL_STABS_CODE;\n \t    current_sym_value = 0;\n \t    current_sym_addr = 0;\n \t    current_sym_nchars = 2 + IDENTIFIER_LENGTH (name);\n@@ -1771,13 +1790,15 @@ dbxout_parms (parms)\n \t      {\n \t\tcurrent_sym_nchars = 2 + IDENTIFIER_LENGTH (DECL_NAME (parms));\n \n-\t\tfprintf (asmfile, \"%s \\\"%s:p\", ASM_STABS_OP,\n-\t\t\t IDENTIFIER_POINTER (DECL_NAME (parms)));\n+\t\tfprintf (asmfile, \"%s \\\"%s:%c\", ASM_STABS_OP,\n+\t\t\t IDENTIFIER_POINTER (DECL_NAME (parms)),\n+\t\t\t DBX_MEMPARM_STABS_LETTER);\n \t      }\n \t    else\n \t      {\n \t\tcurrent_sym_nchars = 8;\n-\t\tfprintf (asmfile, \"%s \\\"(anon):p\", ASM_STABS_OP);\n+\t\tfprintf (asmfile, \"%s \\\"(anon):%c\", ASM_STABS_OP,\n+\t\t\t DBX_MEMPARM_STABS_LETTER);\n \t      }\n \n \t    if (GET_CODE (DECL_RTL (parms)) == REG\n@@ -1917,13 +1938,15 @@ dbxout_parms (parms)\n \t      {\n \t\tcurrent_sym_nchars = 2 + strlen (IDENTIFIER_POINTER (DECL_NAME (parms)));\n \n-\t\tfprintf (asmfile, \"%s \\\"%s:p\", ASM_STABS_OP,\n-\t\t\t IDENTIFIER_POINTER (DECL_NAME (parms)));\n+\t\tfprintf (asmfile, \"%s \\\"%s:%c\", ASM_STABS_OP,\n+\t\t\t IDENTIFIER_POINTER (DECL_NAME (parms)),\n+\t\t\t DBX_MEMPARM_STABS_LETTER);\n \t      }\n \t    else\n \t      {\n \t\tcurrent_sym_nchars = 8;\n-\t\tfprintf (asmfile, \"%s \\\"(anon):p\", ASM_STABS_OP);\n+\t\tfprintf (asmfile, \"%s \\\"(anon):%c\", ASM_STABS_OP,\n+\t\tDBX_MEMPARM_STABS_LETTER);\n \t      }\n \n \t    current_sym_value\n@@ -2121,9 +2144,13 @@ dbxout_block (block, depth, args)\n \t\t    }\n \t\t}\n \n+#ifdef DBX_OUTPUT_LBRAC\n+\t      DBX_OUTPUT_LBRAC (asmfile, buf);\n+#else\n \t      fprintf (asmfile, \"%s %d,0,0,\", ASM_STABN_OP, N_LBRAC);\n \t      assemble_name (asmfile, buf);\n \t      fprintf (asmfile, \"\\n\");\n+#endif\n \t    }\n \t  else if (depth > 0)\n \t    /* Count blocks the same way regardless of debug_info_level.  */\n@@ -2146,9 +2173,13 @@ dbxout_block (block, depth, args)\n \t    {\n \t      char buf[20];\n \t      ASM_GENERATE_INTERNAL_LABEL (buf, \"LBE\", blocknum);\n+#ifdef DBX_OUTPUT_RBRAC\n+\t      DBX_OUTPUT_RBRAC (asmfile, buf);\n+#else\n \t      fprintf (asmfile, \"%s %d,0,0,\", ASM_STABN_OP, N_RBRAC);\n \t      assemble_name (asmfile, buf);\n \t      fprintf (asmfile, \"\\n\");\n+#endif\n \t    }\n \t}\n       block = BLOCK_CHAIN (block);"}]}