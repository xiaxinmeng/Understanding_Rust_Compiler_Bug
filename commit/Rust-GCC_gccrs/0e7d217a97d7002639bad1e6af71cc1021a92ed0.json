{"sha": "0e7d217a97d7002639bad1e6af71cc1021a92ed0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU3ZDIxN2E5N2Q3MDAyNjM5YmFkMWU2YWY3MWNjMTAyMWE5MmVkMA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@apple.com", "date": "2004-07-24T00:03:28Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2004-07-24T00:03:28Z"}, "message": "boehm.c (set_bit): Improve type safety wrt unsignedness.\n\n        * boehm.c (set_bit): Improve type safety wrt unsignedness.\n        * gjavah.c (throwable_p, decode_signature_piece,\n        print_full_cxx_name, print_include, add_namelet, add_class_decl,\n        process_file): Likewise.\n        * jcf-dump.c (main): Likewise.\n        * jcf-io.c (read_zip_member): Likewise.\n        * jcf-parse.c (HANDLE_CONSTANT_Utf8, get_constant,\n        give_name_to_class, get_class_constant): Likewise.\n        * jcf-write.c (find_constant_wide, push_long_const,\n        generate_classfile): Likewise.\n        * lex.c (java_new_lexer, java_read_char, cxx_keyword_p): Likewise.\n        * parse.y (read_import_dir): Likewise.\n        * typeck.c (parse_signature_type): Likewise.\n        * verify.c (verify_jvm_instructions): Likewise.\n        * zextract.c (find_zip_file_start, read_zip_archive): Likewise.\n\nFrom-SVN: r85102", "tree": {"sha": "0507a167efbef0282a0fc2a3f187f358cfe9b0a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0507a167efbef0282a0fc2a3f187f358cfe9b0a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e7d217a97d7002639bad1e6af71cc1021a92ed0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e7d217a97d7002639bad1e6af71cc1021a92ed0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e7d217a97d7002639bad1e6af71cc1021a92ed0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e7d217a97d7002639bad1e6af71cc1021a92ed0/comments", "author": null, "committer": null, "parents": [{"sha": "ef05818b76a645f094e89f0804611d19c677f03f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef05818b76a645f094e89f0804611d19c677f03f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef05818b76a645f094e89f0804611d19c677f03f"}], "stats": {"total": 132, "additions": 77, "deletions": 55}, "files": [{"sha": "dc1ae7e19e2cafb4bd83a9978c2d7cfef573e80c", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e7d217a97d7002639bad1e6af71cc1021a92ed0/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e7d217a97d7002639bad1e6af71cc1021a92ed0/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=0e7d217a97d7002639bad1e6af71cc1021a92ed0", "patch": "@@ -1,3 +1,21 @@\n+2004-07-23  Mike Stump  <mrs@apple.com>\n+\n+\t* boehm.c (set_bit): Improve type safety wrt unsignedness.\n+\t* gjavah.c (throwable_p, decode_signature_piece,\n+\tprint_full_cxx_name, print_include, add_namelet, add_class_decl,\n+\tprocess_file): Likewise.\n+\t* jcf-dump.c (main): Likewise.\n+\t* jcf-io.c (read_zip_member): Likewise.\n+\t* jcf-parse.c (HANDLE_CONSTANT_Utf8, get_constant,\n+\tgive_name_to_class, get_class_constant): Likewise.\n+\t* jcf-write.c (find_constant_wide, push_long_const,\n+\tgenerate_classfile): Likewise.\n+\t* lex.c (java_new_lexer, java_read_char, cxx_keyword_p): Likewise.\n+\t* parse.y (read_import_dir): Likewise.\n+\t* typeck.c (parse_signature_type): Likewise.\n+\t* verify.c (verify_jvm_instructions): Likewise.\n+\t* zextract.c (find_zip_file_start, read_zip_archive): Likewise.\n+\n 2004-07-23  Thomas Fitzsimmons  <fitzsim@redhat.com>\n \n \t* Make-lang.in: Replace rmic and rmiregistry references with"}, {"sha": "00dc4904d5aaa2765e333d956aeb6311fe25afa8", "filename": "gcc/java/boehm.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e7d217a97d7002639bad1e6af71cc1021a92ed0/gcc%2Fjava%2Fboehm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e7d217a97d7002639bad1e6af71cc1021a92ed0/gcc%2Fjava%2Fboehm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fboehm.c?ref=0e7d217a97d7002639bad1e6af71cc1021a92ed0", "patch": "@@ -46,7 +46,7 @@ static void\n set_bit (unsigned HOST_WIDE_INT *low, unsigned HOST_WIDE_INT *high,\n \t unsigned int n)\n {\n-  HOST_WIDE_INT *which;\n+  unsigned HOST_WIDE_INT *which;\n \n   if (n >= HOST_BITS_PER_WIDE_INT)\n     {\n@@ -56,7 +56,7 @@ set_bit (unsigned HOST_WIDE_INT *low, unsigned HOST_WIDE_INT *high,\n   else\n     which = low;\n \n-  *which |= (HOST_WIDE_INT) 1 << n;\n+  *which |= (unsigned HOST_WIDE_INT) 1 << n;\n }\n \n /* Recursively mark reference fields.  */"}, {"sha": "8f53df192ff9a299b945f3cec2637f0f5ff9a140", "filename": "gcc/java/gjavah.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e7d217a97d7002639bad1e6af71cc1021a92ed0/gcc%2Fjava%2Fgjavah.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e7d217a97d7002639bad1e6af71cc1021a92ed0/gcc%2Fjava%2Fgjavah.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgjavah.c?ref=0e7d217a97d7002639bad1e6af71cc1021a92ed0", "patch": "@@ -1144,11 +1144,11 @@ throwable_p (const unsigned char *clname)\n \t\t\t\t    (htab_del) free);\n \n       /* Make sure the root classes show up in the tables.  */\n-      str = xstrdup (\"java.lang.Throwable\");\n+      str = (unsigned char *) xstrdup (\"java.lang.Throwable\");\n       slot = htab_find_slot (throw_hash, str, INSERT);\n       *slot = str;\n \n-      str = xstrdup (\"java.lang.Object\");\n+      str = (unsigned char *) xstrdup (\"java.lang.Object\");\n       slot = htab_find_slot (non_throw_hash, str, INSERT);\n       *slot = str;\n \n@@ -1175,7 +1175,7 @@ throwable_p (const unsigned char *clname)\n       void **slot;\n       unsigned char *super, *tmp;\n       int super_length = -1;\n-      const char *classfile_name = find_class (current, strlen (current),\n+      const char *classfile_name = find_class ((char *) current, strlen ((const char *) current),\n \t\t\t\t\t       &jcf, 0);\n \n       if (! classfile_name)\n@@ -1321,10 +1321,10 @@ decode_signature_piece (FILE *stream, const unsigned char *signature,\n       if (flag_jni)\n \t{\n \t  /* We know about certain types and special-case their names.  */\n-\t  if (! strncmp (signature, \"Ljava/lang/String;\",\n+\t  if (! strncmp ((const char *) signature, \"Ljava/lang/String;\",\n \t\t\t sizeof (\"Ljava/lang/String;\") -1))\n \t    ctype = \"jstring\";\n-\t  else if (! strncmp (signature, \"Ljava/lang/Class;\",\n+\t  else if (! strncmp ((const char *) signature, \"Ljava/lang/Class;\",\n \t\t\t      sizeof (\"Ljava/lang/Class;\") - 1))\n \t    ctype = \"jclass\";\n \t  /* Skip leading 'L' for throwable_p call.  */\n@@ -1469,7 +1469,7 @@ print_full_cxx_name (FILE* stream, JCF* jcf, int name_index,\n       int sig_len = JPOOL_UTF_LENGTH (jcf, signature_index);\n       if (overloaded_jni_method_exists_p (JPOOL_UTF_DATA (jcf, name_index),\n \t\t\t\t\t  JPOOL_UTF_LENGTH (jcf, name_index),\n-\t\t\t\t\t  signature, sig_len))\n+\t\t\t\t\t  (const char *) signature, sig_len))\n \t{\n \t  /* If this method is overloaded by another native method,\n \t     then include the argument information in the mangled\n@@ -1743,19 +1743,19 @@ print_include (FILE *out, const unsigned char *utf8, int len)\n     return;\n \n   if (len == -1)\n-    len = strlen (utf8);\n+    len = strlen ((const char *) utf8);\n \n   for (incl = all_includes; incl; incl = incl->next)\n     {\n       /* We check the length because we might have a proper prefix.  */\n       if (len == (int) strlen (incl->name)\n-\t  && ! strncmp (incl->name, utf8, len))\n+\t  && ! strncmp (incl->name, (const char *) utf8, len))\n \treturn;\n     }\n \n   incl = xmalloc (sizeof (struct include));\n   incl->name = xmalloc (len + 1);\n-  strncpy (incl->name, utf8, len);\n+  strncpy (incl->name, (const char *) utf8, len);\n   incl->name[len] = '\\0';\n   incl->next = all_includes;\n   all_includes = incl;\n@@ -1814,11 +1814,11 @@ add_namelet (const unsigned char *name, const unsigned char *name_limit,\n #define JAVAIO \"java/io/\"\n #define JAVAUTIL \"java/util/\"\n       if ((name_limit - name >= (int) sizeof (JAVALANG) - 1\n-\t   && ! strncmp (name, JAVALANG, sizeof (JAVALANG) - 1))\n+\t   && ! strncmp ((const char *) name, JAVALANG, sizeof (JAVALANG) - 1))\n \t  || (name_limit - name >= (int) sizeof (JAVAUTIL) - 1\n-\t      && ! strncmp (name, JAVAUTIL, sizeof (JAVAUTIL) - 1))\n+\t      && ! strncmp ((const char *) name, JAVAUTIL, sizeof (JAVAUTIL) - 1))\n \t  || (name_limit - name >= (int) sizeof (JAVAIO) - 1\n-\t      && ! strncmp (name, JAVAIO, sizeof (JAVAIO) - 1)))\n+\t      && ! strncmp ((const char *) name, JAVAIO, sizeof (JAVAIO) - 1)))\n \treturn;\n     }\n \n@@ -1830,7 +1830,7 @@ add_namelet (const unsigned char *name, const unsigned char *name_limit,\n     {\n       /* We check the length because we might have a proper prefix.  */\n       if ((int) strlen (np->name) == p - name &&\n-\t  ! strncmp (name, np->name, p - name))\n+\t  ! strncmp ((const char *) name, np->name, p - name))\n \t{\n \t  n = np;\n \t  break;\n@@ -1841,7 +1841,7 @@ add_namelet (const unsigned char *name, const unsigned char *name_limit,\n     {\n       n = xmalloc (sizeof (struct namelet));\n       n->name = xmalloc (p - name + 1);\n-      strncpy (n->name, name, p - name);\n+      strncpy (n->name, (const char *) name, p - name);\n       n->name[p - name] = '\\0';\n       n->is_class = (p == name_limit);\n       n->subnamelets = NULL;\n@@ -1923,7 +1923,7 @@ add_class_decl (FILE *out, JCF *jcf, JCF_u2 signature)\n       /* If we see an array, then we include the array header.  */\n       if (s[i] == '[')\n \t{\n-\t  print_include (out, \"gcj/array\", -1);\n+\t  print_include (out, (const unsigned char *) \"gcj/array\", -1);\n \t  continue;\n \t}\n \n@@ -2094,13 +2094,13 @@ process_file (JCF *jcf, FILE *out)\n \t  for (i = 0; i < len; ++i)\n \t    name[i] = jcf->classname[i] == '.' ? '/' : jcf->classname[i];\n \t  name[i] = '\\0';\n-\t  print_include (out, name, len);\n+\t  print_include (out, (const unsigned char *) name, len);\n \t  free (name);\n \n \t  if (! flag_jni)\n \t    {\n-\t      print_include (out, \"gcj/cni\", -1);\n-\t      print_include (out, \"java/lang/UnsupportedOperationException\",\n+\t      print_include (out, (const unsigned char *) \"gcj/cni\", -1);\n+\t      print_include (out, (const unsigned char *) \"java/lang/UnsupportedOperationException\",\n \t\t\t     -1);\n \t    }\n \t}"}, {"sha": "98e5c9248985e6a353a6b195234825189d21817b", "filename": "gcc/java/jcf-dump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e7d217a97d7002639bad1e6af71cc1021a92ed0/gcc%2Fjava%2Fjcf-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e7d217a97d7002639bad1e6af71cc1021a92ed0/gcc%2Fjava%2Fjcf-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-dump.c?ref=0e7d217a97d7002639bad1e6af71cc1021a92ed0", "patch": "@@ -1080,7 +1080,7 @@ main (int argc, char** argv)\n \t\t  if (jcf->read_end - jcf->read_ptr < total_length)\n \t\t    jcf_trim_old_input (jcf);\n \t\t  JCF_FILL (jcf, total_length);\n-\t\t  filename = jcf->read_ptr;\n+\t\t  filename = (const char *) jcf->read_ptr;\n \t\t  JCF_SKIP (jcf, filename_length);\n \t\t  JCF_SKIP (jcf, extra_length);\n \t\t  if (filename_length > 0"}, {"sha": "0b2109294f499810782af84f8dca53ae9a5d6902", "filename": "gcc/java/jcf-io.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e7d217a97d7002639bad1e6af71cc1021a92ed0/gcc%2Fjava%2Fjcf-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e7d217a97d7002639bad1e6af71cc1021a92ed0/gcc%2Fjava%2Fjcf-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-io.c?ref=0e7d217a97d7002639bad1e6af71cc1021a92ed0", "patch": "@@ -215,7 +215,7 @@ read_zip_member (JCF *jcf,  ZipDirectory *zipd, ZipFile *zipf)\n       jcf->read_ptr = jcf->buffer;\n       jcf->read_end = jcf->buffer_end;\n       buffer = ALLOC (zipd->size);\n-      d_stream.next_in = buffer;\n+      d_stream.next_in = (unsigned char *) buffer;\n       d_stream.avail_in = zipd->size;\n       if (lseek (zipf->fd, zipd->filestart, 0) < 0\n \t  || read (zipf->fd, buffer, zipd->size) != (long) zipd->size)"}, {"sha": "4e49b1ffcb1fd7ed5da084f2172cb5bc31786274", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e7d217a97d7002639bad1e6af71cc1021a92ed0/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e7d217a97d7002639bad1e6af71cc1021a92ed0/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=0e7d217a97d7002639bad1e6af71cc1021a92ed0", "patch": "@@ -64,7 +64,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n     text = (JCF)->read_ptr; \\\n     save = text[LENGTH]; \\\n     text[LENGTH] = 0; \\\n-    (JCF)->cpool.data[INDEX].t = get_identifier (text); \\\n+    (JCF)->cpool.data[INDEX].t = get_identifier ((const char *) text); \\\n     text[LENGTH] = save; \\\n     JCF_SKIP (JCF, LENGTH); } while (0)\n \n@@ -273,7 +273,8 @@ get_constant (JCF *jcf, int index)\n     case CONSTANT_Long:\n       {\n \tunsigned HOST_WIDE_INT num = JPOOL_UINT (jcf, index);\n-\tHOST_WIDE_INT lo, hi;\n+\tunsigned HOST_WIDE_INT lo;\n+\tHOST_WIDE_INT hi;\n \tlshift_double (num, 0, 32, 64, &lo, &hi, 0);\n \tnum = JPOOL_UINT (jcf, index+1);\n \tadd_double (lo, hi, num, 0, &lo, &hi);\n@@ -411,7 +412,7 @@ give_name_to_class (JCF *jcf, int i)\n       tree this_class;\n       int j = JPOOL_USHORT1 (jcf, i);\n       /* verify_constant_pool confirmed that j is a CONSTANT_Utf8. */\n-      tree class_name = unmangle_classname (JPOOL_UTF_DATA (jcf, j),\n+      tree class_name = unmangle_classname ((const char *) JPOOL_UTF_DATA (jcf, j),\n \t\t\t\t\t    JPOOL_UTF_LENGTH (jcf, j));\n       this_class = lookup_class (class_name);\n       input_filename = DECL_SOURCE_FILE (TYPE_NAME (this_class));\n@@ -439,11 +440,11 @@ get_class_constant (JCF *jcf, int i)\n     {\n       int name_index = JPOOL_USHORT1 (jcf, i);\n       /* verify_constant_pool confirmed that name_index is a CONSTANT_Utf8. */\n-      const char *name = JPOOL_UTF_DATA (jcf, name_index);\n+      const char *name = (const char *) JPOOL_UTF_DATA (jcf, name_index);\n       int nlength = JPOOL_UTF_LENGTH (jcf, name_index);\n \n       if (name[0] == '[')  /* Handle array \"classes\". */\n-\t  type = TREE_TYPE (parse_signature_string (name, nlength));\n+\t  type = TREE_TYPE (parse_signature_string ((const unsigned char *) name, nlength));\n       else\n         { \n           tree cname = unmangle_classname (name, nlength);"}, {"sha": "d775a816ff2836cffb22d9290a92e4029cffcdbd", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e7d217a97d7002639bad1e6af71cc1021a92ed0/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e7d217a97d7002639bad1e6af71cc1021a92ed0/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=0e7d217a97d7002639bad1e6af71cc1021a92ed0", "patch": "@@ -772,7 +772,8 @@ static int\n find_constant_wide (HOST_WIDE_INT lo, HOST_WIDE_INT hi,\n \t\t    struct jcf_partial *state)\n {\n-  HOST_WIDE_INT w1, w2;\n+  unsigned HOST_WIDE_INT w1;\n+  HOST_WIDE_INT w2;\n   lshift_double (lo, hi, -32, 64, &w1, &w2, 1);\n   return find_constant2 (&state->cpool, CONSTANT_Long,\n \t\t\t (jword)(w1 & 0xFFFFFFFF), (jword)(lo & 0xFFFFFFFF));\n@@ -822,7 +823,8 @@ find_constant_index (tree value, struct jcf_partial *state)\n static void\n push_long_const (HOST_WIDE_INT lo, HOST_WIDE_INT hi, struct jcf_partial *state)\n {\n-  HOST_WIDE_INT highpart, dummy;\n+  unsigned HOST_WIDE_INT highpart;\n+  HOST_WIDE_INT dummy;\n   jint lowpart = WORD_TO_INT (lo);\n \n   rshift_double (lo, hi, 32, 64, &highpart, &dummy, 1);\n@@ -833,7 +835,8 @@ push_long_const (HOST_WIDE_INT lo, HOST_WIDE_INT hi, struct jcf_partial *state)\n       OP1(OPCODE_lconst_0 + lowpart);\n     }\n   else if ((highpart == 0 && lowpart > 0 && lowpart < 32768) \n-\t   || (highpart == -1 && lowpart < 0 && lowpart >= -32768))\n+\t   || (highpart == (unsigned HOST_WIDE_INT)-1\n+\t       && lowpart < 0 && lowpart >= -32768))\n       {\n         push_int_const (lowpart, state);\n         RESERVE (1);\n@@ -2929,11 +2932,11 @@ generate_classfile (tree clas, struct jcf_partial *state)\n {\n   struct chunk *cpool_chunk;\n   const char *source_file, *s;\n-  char *ptr;\n+  unsigned char *ptr;\n   int i;\n-  char *fields_count_ptr;\n+  unsigned char *fields_count_ptr;\n   int fields_count = 0;\n-  char *methods_count_ptr;\n+  unsigned char *methods_count_ptr;\n   int methods_count = 0;\n   tree part;\n   int total_supers\n@@ -3079,7 +3082,7 @@ generate_classfile (tree clas, struct jcf_partial *state)\n \t  int code_attributes_count = 0;\n \t  static tree Code_node = NULL_TREE;\n \t  tree t;\n-\t  char *attr_len_ptr;\n+\t  unsigned char *attr_len_ptr;\n \t  struct jcf_handler *handler;\n \t  if (Code_node == NULL_TREE)\n \t    Code_node = get_identifier (\"Code\");"}, {"sha": "77e38f898485707443b1cdc41d1500e4cb43e1c4", "filename": "gcc/java/lex.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e7d217a97d7002639bad1e6af71cc1021a92ed0/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e7d217a97d7002639bad1e6af71cc1021a92ed0/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=0e7d217a97d7002639bad1e6af71cc1021a92ed0", "patch": "@@ -264,7 +264,7 @@ java_new_lexer (FILE *finput, const char *encoding)\n \t      in[1] = 0xbb;\n \t      in[2] = 0xbf;\n \n-\t      inp = in;\n+\t      inp = (char *) in;\n \t      inc = 3;\n \t      outp = (char *) &result;\n \t      outc = 2;\n@@ -377,7 +377,7 @@ java_read_char (java_lexer *lex)\n \t      in_save = inbytesleft;\n \t      out_save = out_count;\n \t      inp = &lex->buffer[lex->first];\n-\t      outp = &lex->out_buffer[lex->out_last];\n+\t      outp = (char *) &lex->out_buffer[lex->out_last];\n \t      ir = iconv (lex->handle, (ICONV_CONST char **) &inp,\n \t\t\t  &inbytesleft, &outp, &out_count);\n \n@@ -2031,7 +2031,7 @@ cxx_keyword_p (const char *name, int length)\n     {\n       int kwl = strlen (cxx_keywords[mid]);\n       int min_length = kwl > length ? length : kwl;\n-      int r = utf8_cmp (name, min_length, cxx_keywords[mid]);\n+      int r = utf8_cmp ((const unsigned char *) name, min_length, cxx_keywords[mid]);\n \n       if (r == 0)\n \t{"}, {"sha": "63dbf051ef67159ef311a4254cfb9ae96bc3118f", "filename": "gcc/java/parse.y", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e7d217a97d7002639bad1e6af71cc1021a92ed0/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e7d217a97d7002639bad1e6af71cc1021a92ed0/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=0e7d217a97d7002639bad1e6af71cc1021a92ed0", "patch": "@@ -6901,7 +6901,7 @@ read_import_dir (tree wfl)\n \t  buffer_grow (filename, entry_length);\n \t  memcpy (filename->data, entry_name, entry_length - 1);\n \t  filename->data[entry_length-1] = '\\0';\n-\t  zipf = opendir_in_zip (filename->data, jcf_path_is_system (entry));\n+\t  zipf = opendir_in_zip ((const char *) filename->data, jcf_path_is_system (entry));\n \t  if (zipf == NULL)\n \t    error (\"malformed .zip archive in CLASSPATH: %s\", entry_name);\n \t  else\n@@ -6921,7 +6921,7 @@ read_import_dir (tree wfl)\n \t\t  int current_entry_len = zipd->filename_length;\n \n \t\t  if (current_entry_len >= BUFFER_LENGTH (filename)\n-\t\t      && strncmp (filename->data, current_entry,\n+\t\t      && strncmp ((const char *) filename->data, current_entry,\n \t\t\t\t  BUFFER_LENGTH (filename)) != 0)\n \t\t    continue;\n \t\t  found |= note_possible_classname (current_entry,\n@@ -6933,7 +6933,7 @@ read_import_dir (tree wfl)\n \t{\n \t  BUFFER_RESET (filename);\n \t  buffer_grow (filename, entry_length + package_length + 4);\n-\t  strcpy (filename->data, entry_name);\n+\t  strcpy ((char *) filename->data, entry_name);\n \t  filename->ptr = filename->data + entry_length;\n \t  for (k = 0; k < package_length; k++)\n \t    {\n@@ -6942,7 +6942,7 @@ read_import_dir (tree wfl)\n \t    }\n \t  *filename->ptr = '\\0';\n \n-\t  dirp = opendir (filename->data);\n+\t  dirp = opendir ((const char *) filename->data);\n \t  if (dirp == NULL)\n \t    continue;\n \t  *filename->ptr++ = '/';\n@@ -6956,8 +6956,8 @@ read_import_dir (tree wfl)\n \t      d_name = direntp->d_name;\n \t      len = strlen (direntp->d_name);\n \t      buffer_grow (filename, len+1);\n-\t      strcpy (filename->ptr, d_name);\n-\t      found |= note_possible_classname (filename->data + entry_length,\n+\t      strcpy ((char *) filename->ptr, d_name);\n+\t      found |= note_possible_classname ((const char *) filename->data + entry_length,\n \t\t\t\t\t\tpackage_length+len+1);\n \t    }\n \t  if (dirp)"}, {"sha": "1e1620acf523a37d2d8c295d4636870b0e64ecdb", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e7d217a97d7002639bad1e6af71cc1021a92ed0/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e7d217a97d7002639bad1e6af71cc1021a92ed0/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=0e7d217a97d7002639bad1e6af71cc1021a92ed0", "patch": "@@ -504,7 +504,7 @@ parse_signature_type (const unsigned char **ptr, const unsigned char *limit)\n \t      break;\n \t  }\n \t*ptr = str+1;\n-\ttype = lookup_class (unmangle_classname (start, str - start));\n+\ttype = lookup_class (unmangle_classname ((const char *) start, str - start));\n \tbreak;\n       }\n     default:"}, {"sha": "9eae097bd93e8534fd945454066b35d2e573f667", "filename": "gcc/java/verify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e7d217a97d7002639bad1e6af71cc1021a92ed0/gcc%2Fjava%2Fverify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e7d217a97d7002639bad1e6af71cc1021a92ed0/gcc%2Fjava%2Fverify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify.c?ref=0e7d217a97d7002639bad1e6af71cc1021a92ed0", "patch": "@@ -1093,7 +1093,7 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \n \t    self_is_interface = CLASS_INTERFACE (TYPE_NAME (self_type));\n \t    method_name = COMPONENT_REF_NAME (&current_jcf->cpool, index);\n-\t    method_type = parse_signature_string (IDENTIFIER_POINTER (sig),\n+\t    method_type = parse_signature_string ((const unsigned char *) IDENTIFIER_POINTER (sig),\n \t\t\t\t\t\t  IDENTIFIER_LENGTH (sig));\n \n \t    if (TREE_CODE (method_type) != FUNCTION_TYPE)"}, {"sha": "eeea94457950e28ed1bdd43fd2c2f1629d33db34", "filename": "gcc/java/zextract.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e7d217a97d7002639bad1e6af71cc1021a92ed0/gcc%2Fjava%2Fzextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e7d217a97d7002639bad1e6af71cc1021a92ed0/gcc%2Fjava%2Fzextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fzextract.c?ref=0e7d217a97d7002639bad1e6af71cc1021a92ed0", "patch": "@@ -264,7 +264,7 @@ find_zip_file_start (int fd, long offset)\n   if (read (fd, buffer, LREC_SIZE + 4) != LREC_SIZE + 4)\n     return -1;\n \n-  if (buffer[0] != 'P' || strncmp (&buffer[1], LOCAL_HDR_SIG, 3))\n+  if (buffer[0] != 'P' || strncmp ((const char *) &buffer[1], LOCAL_HDR_SIG, 3))\n     return -1;\n \n   filename_length = makeword (&buffer[4 + L_FILENAME_LENGTH]);\n@@ -287,8 +287,8 @@ read_zip_archive (ZipFile *zipf)\n     return -1;\n   if (read (zipf->fd, buffer, ECREC_SIZE+4) != ECREC_SIZE+4)\n     return -2;\n-  zipf->count = makeword(&buffer[TOTAL_ENTRIES_CENTRAL_DIR]);\n-  zipf->dir_size = makelong(&buffer[SIZE_CENTRAL_DIRECTORY]);\n+  zipf->count = makeword((const uch *) &buffer[TOTAL_ENTRIES_CENTRAL_DIR]);\n+  zipf->dir_size = makelong((const uch *) &buffer[SIZE_CENTRAL_DIRECTORY]);\n #define ALLOC xmalloc\n   /* Allocate 1 more to allow appending '\\0' to last filename. */\n   zipf->central_directory = ALLOC (zipf->dir_size+1);\n@@ -306,9 +306,9 @@ read_zip_archive (ZipFile *zipf)\n   printf (\"total_entries_central_dir = %d\\n\",\n         makeword(&buffer[TOTAL_ENTRIES_CENTRAL_DIR]));\n   printf (\"size_central_directory = %d\\n\",\n-        makelong(&buffer[SIZE_CENTRAL_DIRECTORY]));\n+        makelong((const uch *) &buffer[SIZE_CENTRAL_DIRECTORY]));\n   printf (\"offset_start_central_directory = %d\\n\",\n-        makelong(&buffer[OFFSET_START_CENTRAL_DIRECTORY]));\n+        makelong((const uch *) &buffer[OFFSET_START_CENTRAL_DIRECTORY]));\n   printf (\"zipfile_comment_length = %d\\n\",\n         makeword(&buffer[ZIPFILE_COMMENT_LENGTH]));\n #endif\n@@ -319,11 +319,11 @@ read_zip_archive (ZipFile *zipf)\n     {\n       ZipDirectory *zipd = (ZipDirectory*)(dir_ptr + dir_last_pad);\n       int compression_method = (int) dir_ptr[4+C_COMPRESSION_METHOD];\n-      long size = makelong (&dir_ptr[4+C_COMPRESSED_SIZE]);\n-      long uncompressed_size = makelong (&dir_ptr[4+C_UNCOMPRESSED_SIZE]);\n-      long filename_length = makeword (&dir_ptr[4+C_FILENAME_LENGTH]);\n-      long extra_field_length = makeword (&dir_ptr[4+C_EXTRA_FIELD_LENGTH]);\n-      long file_offset = makelong (&dir_ptr[4+C_RELATIVE_OFFSET_LOCAL_HEADER]);\n+      long size = makelong ((const uch *) &dir_ptr[4+C_COMPRESSED_SIZE]);\n+      long uncompressed_size = makelong ((const uch *) &dir_ptr[4+C_UNCOMPRESSED_SIZE]);\n+      long filename_length = makeword ((const uch *) &dir_ptr[4+C_FILENAME_LENGTH]);\n+      long extra_field_length = makeword ((const uch *) &dir_ptr[4+C_EXTRA_FIELD_LENGTH]);\n+      long file_offset = makelong ((const uch *) &dir_ptr[4+C_RELATIVE_OFFSET_LOCAL_HEADER]);\n       int unpadded_direntry_length;\n       if ((dir_ptr-zipf->central_directory)+filename_length+CREC_SIZE+4>zipf->dir_size)\n \treturn -1;"}]}