{"sha": "a16a872d4445cd76105ad315d6cfbd066f1862be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE2YTg3MmQ0NDQ1Y2Q3NjEwNWFkMzE1ZDZjZmJkMDY2ZjE4NjJiZQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2014-03-13T00:11:56Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2014-03-13T00:11:56Z"}, "message": "vector.md (VEC_L): Add V1TI mode to vector types.\n\n[gcc]\n2014-03-12  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/vector.md (VEC_L): Add V1TI mode to vector types.\n\t(VEC_M): Likewise.\n\t(VEC_N): Likewise.\n\t(VEC_R): Likewise.\n\t(VEC_base): Likewise.\n\t(mov<MODE>, VEC_M modes): If we are loading TImode into VSX\n\tregisters, we need to swap double words in little endian mode.\n\n\t* config/rs6000/rs6000-modes.def (V1TImode): Add new vector mode\n\tto be a container mode for 128-bit integer operations added in ISA\n\t2.07.  Unlike TImode and PTImode, the preferred register set is\n\tthe Altivec/VMX registers for the 128-bit operations.\n\n\t* config/rs6000/rs6000-protos.h (rs6000_move_128bit_ok_p): Add\n\tdeclarations.\n\t(rs6000_split_128bit_ok_p): Likewise.\n\n\t* config/rs6000/rs6000-builtin.def (BU_P8V_AV_3): Add new support\n\tmacros for creating ISA 2.07 normal and overloaded builtin\n\tfunctions with 3 arguments.\n\t(BU_P8V_OVERLOAD_3): Likewise.\n\t(VPERM_1T): Add support for V1TImode in 128-bit vector operations\n\tfor use as overloaded functions.\n\t(VPERM_1TI_UNS): Likewise.\n\t(VSEL_1TI): Likewise.\n\t(VSEL_1TI_UNS): Likewise.\n\t(ST_INTERNAL_1ti): Likewise.\n\t(LD_INTERNAL_1ti): Likewise.\n\t(XXSEL_1TI): Likewise.\n\t(XXSEL_1TI_UNS): Likewise.\n\t(VPERM_1TI): Likewise.\n\t(VPERM_1TI_UNS): Likewise.\n\t(XXPERMDI_1TI): Likewise.\n\t(SET_1TI): Likewise.\n\t(LXVD2X_V1TI): Likewise.\n\t(STXVD2X_V1TI): Likewise.\n\t(VEC_INIT_V1TI): Likewise.\n\t(VEC_SET_V1TI): Likewise.\n\t(VEC_EXT_V1TI): Likewise.\n\t(EQV_V1TI): Likewise.\n\t(NAND_V1TI): Likewise.\n\t(ORC_V1TI): Likewise.\n\t(VADDCUQ): Add support for 128-bit integer arithmetic instructions\n\tadded in ISA 2.07.  Add both normal 'altivec' builtins, and the\n\toverloaded builtin.\n\t(VADDUQM): Likewise.\n\t(VSUBCUQ): Likewise.\n\t(VADDEUQM): Likewise.\n\t(VADDECUQ): Likewise.\n\t(VSUBEUQM): Likewise.\n\t(VSUBECUQ): Likewise.\n\n\t* config/rs6000/rs6000-c.c (__int128_type): New static to hold\n\t__int128_t and __uint128_t types.\n\t(__uint128_type): Likewise.\n\t(altivec_categorize_keyword): Add support for vector __int128_t,\n\tvector __uint128_t, vector __int128, and vector unsigned __int128\n\tas a container type for TImode operations that need to be done in\n\tVSX/Altivec registers.\n\t(rs6000_macro_to_expand): Likewise.\n\t(altivec_overloaded_builtins): Add ISA 2.07 overloaded functions\n\tto support 128-bit integer instructions vaddcuq, vadduqm,\n\tvaddecuq, vaddeuqm, vsubcuq, vsubuqm, vsubecuq, vsubeuqm.\n\t(altivec_resolve_overloaded_builtin): Add support for V1TImode.\n\n\t* config/rs6000/rs6000.c (rs6000_hard_regno_mode_ok): Add support\n\tfor V1TImode, and set up preferences to use VSX/Altivec\n\tregisters.  Setup VSX reload handlers.\n\t(rs6000_debug_reg_global): Likewise.\n\t(rs6000_init_hard_regno_mode_ok): Likewise.\n\t(rs6000_preferred_simd_mode): Likewise.\n\t(vspltis_constant): Do not allow V1TImode as easy altivec\n\tconstants.\n\t(easy_altivec_constant): Likewise.\n\t(output_vec_const_move): Likewise.\n\t(rs6000_expand_vector_set): Convert V1TImode set and extract to\n\tsimple move.\n\t(rs6000_expand_vector_extract): Likewise.\n\t(reg_offset_addressing_ok_p): Setup V1TImode to use VSX reg+reg\n\taddressing.\n\t(rs6000_const_vec): Add support for V1TImode.\n\t(rs6000_emit_le_vsx_load): Swap double words when loading or\n\tstoring TImode/V1TImode.\n\t(rs6000_emit_le_vsx_store): Likewise.\n\t(rs6000_emit_le_vsx_move): Likewise.\n\t(rs6000_emit_move): Add support for V1TImode.\n\t(altivec_expand_ld_builtin): Likewise.\n\t(altivec_expand_st_builtin): Likewise.\n\t(altivec_expand_vec_init_builtin): Likewise.\n\t(altivec_expand_builtin): Likewise.\n\t(rs6000_init_builtins): Add support for V1TImode type.  Add\n\tsupport for ISA 2.07 128-bit integer builtins.  Define type names\n\tfor the VSX/Altivec vector types.\n\t(altivec_init_builtins): Add support for overloaded vector\n\tfunctions with V1TImode type.\n\t(rs6000_preferred_reload_class): Prefer Altivec registers for\n\tV1TImode.\n\t(rs6000_move_128bit_ok_p): Move 128-bit move/split validation to\n\texternal function.\n\t(rs6000_split_128bit_ok_p): Likewise.\n\t(rs6000_handle_altivec_attribute): Create V1TImode from vector\n\t__int128_t and vector __uint128_t.\n\n\t* config/rs6000/vsx.md (VSX_L): Add V1TImode to vector iterators\n\tand mode attributes.\n\t(VSX_M): Likewise.\n\t(VSX_M2): Likewise.\n\t(VSm): Likewise.\n\t(VSs): Likewise.\n\t(VSr): Likewise.\n\t(VSv): Likewise.\n\t(VS_scalar): Likewise.\n\t(VS_double): Likewise.\n\t(vsx_set_v1ti): New builtin function to create V1TImode from\n\tTImode.\n\n\t* config/rs6000/rs6000.h (TARGET_VADDUQM): New macro to say\n\twhether we support the ISA 2.07 128-bit integer arithmetic\n\tinstructions.\n\t(ALTIVEC_OR_VSX_VECTOR_MODE): Add V1TImode.\n\t(enum rs6000_builtin_type_index): Add fields to hold V1TImode\n\tand TImode types for use with the builtin functions.\n\t(V1TI_type_node): Likewise.\n\t(unsigned_V1TI_type_node): Likewise.\n\t(intTI_type_internal_node): Likewise.\n\t(uintTI_type_internal_node): Likewise.\n\n\t* config/rs6000/altivec.md (UNSPEC_VADDCUQ): New unspecs for ISA\n\t2.07 128-bit builtin functions.\n\t(UNSPEC_VADDEUQM): Likewise.\n\t(UNSPEC_VADDECUQ): Likewise.\n\t(UNSPEC_VSUBCUQ): Likewise.\n\t(UNSPEC_VSUBEUQM): Likewise.\n\t(UNSPEC_VSUBECUQ): Likewise.\n\t(VM): Add V1TImode to vector mode iterators.\n\t(VM2): Likewise.\n\t(VI_unit): Likewise.\n\t(altivec_vadduqm): Add ISA 2.07 128-bit binary builtins.\n\t(altivec_vaddcuq): Likewise.\n\t(altivec_vsubuqm): Likewise.\n\t(altivec_vsubcuq): Likewise.\n\t(altivec_vaddeuqm): Likewise.\n\t(altivec_vaddecuq): Likewise.\n\t(altivec_vsubeuqm): Likewise.\n\t(altivec_vsubecuq): Likewise.\n\n\t* config/rs6000/rs6000.md (FMOVE128_GPR): Add V1TImode to vector\n\tmode iterators.\n\t(BOOL_128): Likewise.\n\t(BOOL_REGS_OUTPUT): Likewise.\n\t(BOOL_REGS_OP1): Likewise.\n\t(BOOL_REGS_OP2): Likewise.\n\t(BOOL_REGS_UNARY): Likewise.\n\t(BOOL_REGS_AND_CR0): Likewise.\n\n\t* config/rs6000/altivec.h (vec_vaddcuq): Add support for ISA 2.07\n\t128-bit integer builtin support.\n\t(vec_vadduqm): Likewise.\n\t(vec_vaddecuq): Likewise.\n\t(vec_vaddeuqm): Likewise.\n\t(vec_vsubecuq): Likewise.\n\t(vec_vsubeuqm): Likewise.\n\t(vec_vsubcuq): Likewise.\n\t(vec_vsubuqm): Likewise.\n\n\t* doc/extend.texi (PowerPC AltiVec/VSX Built-in Functions):\n\tDocument vec_vaddcuq, vec_vadduqm, vec_vaddecuq, vec_vaddeuqm,\n\tvec_subecuq, vec_subeuqm, vec_vsubcuq, vec_vsubeqm builtins adding\n\t128-bit integer add/subtract to ISA 2.07.\n\n[gcc/testsuite]\n2014-03-12  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/p8vector-int128-1.c: New test to test ISA\n\t2.07 128-bit arithmetic.\n\t* gcc.target/powerpc/p8vector-int128-2.c: Likewise.\n\n\t* gcc.target/powerpc/timode_off.c: Restrict cpu type to power5,\n\tdue to when TImode is allowed in VSX registers, the allowable\n\taddress modes for TImode is just a single indirect address in\n\torder for the value to be loaded and store in either GPR or VSX\n\tregisters.  This affects the generated code, and it would cause\n\tthis test to fail, when such an option is used.\n\nFrom-SVN: r208522", "tree": {"sha": "623a0d5b7a6969afa4c3ab25e724eea83b56abcd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/623a0d5b7a6969afa4c3ab25e724eea83b56abcd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a16a872d4445cd76105ad315d6cfbd066f1862be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a16a872d4445cd76105ad315d6cfbd066f1862be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a16a872d4445cd76105ad315d6cfbd066f1862be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a16a872d4445cd76105ad315d6cfbd066f1862be/comments", "author": null, "committer": null, "parents": [{"sha": "eeac7d151431db59c2c6774c06a5323cc2cd6ae3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eeac7d151431db59c2c6774c06a5323cc2cd6ae3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eeac7d151431db59c2c6774c06a5323cc2cd6ae3"}], "stats": {"total": 1080, "additions": 1029, "deletions": 51}, "files": [{"sha": "c199901dd37c249c68e2a38cdb56f0e626de96cb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a16a872d4445cd76105ad315d6cfbd066f1862be", "patch": "@@ -1,3 +1,175 @@\n+2014-03-12  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/vector.md (VEC_L): Add V1TI mode to vector types.\n+\t(VEC_M): Likewise.\n+\t(VEC_N): Likewise.\n+\t(VEC_R): Likewise.\n+\t(VEC_base): Likewise.\n+\t(mov<MODE>, VEC_M modes): If we are loading TImode into VSX\n+\tregisters, we need to swap double words in little endian mode.\n+\n+\t* config/rs6000/rs6000-modes.def (V1TImode): Add new vector mode\n+\tto be a container mode for 128-bit integer operations added in ISA\n+\t2.07.  Unlike TImode and PTImode, the preferred register set is\n+\tthe Altivec/VMX registers for the 128-bit operations.\n+\n+\t* config/rs6000/rs6000-protos.h (rs6000_move_128bit_ok_p): Add\n+\tdeclarations.\n+\t(rs6000_split_128bit_ok_p): Likewise.\n+\n+\t* config/rs6000/rs6000-builtin.def (BU_P8V_AV_3): Add new support\n+\tmacros for creating ISA 2.07 normal and overloaded builtin\n+\tfunctions with 3 arguments.\n+\t(BU_P8V_OVERLOAD_3): Likewise.\n+\t(VPERM_1T): Add support for V1TImode in 128-bit vector operations\n+\tfor use as overloaded functions.\n+\t(VPERM_1TI_UNS): Likewise.\n+\t(VSEL_1TI): Likewise.\n+\t(VSEL_1TI_UNS): Likewise.\n+\t(ST_INTERNAL_1ti): Likewise.\n+\t(LD_INTERNAL_1ti): Likewise.\n+\t(XXSEL_1TI): Likewise.\n+\t(XXSEL_1TI_UNS): Likewise.\n+\t(VPERM_1TI): Likewise.\n+\t(VPERM_1TI_UNS): Likewise.\n+\t(XXPERMDI_1TI): Likewise.\n+\t(SET_1TI): Likewise.\n+\t(LXVD2X_V1TI): Likewise.\n+\t(STXVD2X_V1TI): Likewise.\n+\t(VEC_INIT_V1TI): Likewise.\n+\t(VEC_SET_V1TI): Likewise.\n+\t(VEC_EXT_V1TI): Likewise.\n+\t(EQV_V1TI): Likewise.\n+\t(NAND_V1TI): Likewise.\n+\t(ORC_V1TI): Likewise.\n+\t(VADDCUQ): Add support for 128-bit integer arithmetic instructions\n+\tadded in ISA 2.07.  Add both normal 'altivec' builtins, and the\n+\toverloaded builtin.\n+\t(VADDUQM): Likewise.\n+\t(VSUBCUQ): Likewise.\n+\t(VADDEUQM): Likewise.\n+\t(VADDECUQ): Likewise.\n+\t(VSUBEUQM): Likewise.\n+\t(VSUBECUQ): Likewise.\n+\n+\t* config/rs6000/rs6000-c.c (__int128_type): New static to hold\n+\t__int128_t and __uint128_t types.\n+\t(__uint128_type): Likewise.\n+\t(altivec_categorize_keyword): Add support for vector __int128_t,\n+\tvector __uint128_t, vector __int128, and vector unsigned __int128\n+\tas a container type for TImode operations that need to be done in\n+\tVSX/Altivec registers.\n+\t(rs6000_macro_to_expand): Likewise.\n+\t(altivec_overloaded_builtins): Add ISA 2.07 overloaded functions\n+\tto support 128-bit integer instructions vaddcuq, vadduqm,\n+\tvaddecuq, vaddeuqm, vsubcuq, vsubuqm, vsubecuq, vsubeuqm.\n+\t(altivec_resolve_overloaded_builtin): Add support for V1TImode.\n+\n+\t* config/rs6000/rs6000.c (rs6000_hard_regno_mode_ok): Add support\n+\tfor V1TImode, and set up preferences to use VSX/Altivec\n+\tregisters.  Setup VSX reload handlers.\n+\t(rs6000_debug_reg_global): Likewise.\n+\t(rs6000_init_hard_regno_mode_ok): Likewise.\n+\t(rs6000_preferred_simd_mode): Likewise.\n+\t(vspltis_constant): Do not allow V1TImode as easy altivec\n+\tconstants.\n+\t(easy_altivec_constant): Likewise.\n+\t(output_vec_const_move): Likewise.\n+\t(rs6000_expand_vector_set): Convert V1TImode set and extract to\n+\tsimple move.\n+\t(rs6000_expand_vector_extract): Likewise.\n+\t(reg_offset_addressing_ok_p): Setup V1TImode to use VSX reg+reg\n+\taddressing.\n+\t(rs6000_const_vec): Add support for V1TImode.\n+\t(rs6000_emit_le_vsx_load): Swap double words when loading or\n+\tstoring TImode/V1TImode.\n+\t(rs6000_emit_le_vsx_store): Likewise.\n+\t(rs6000_emit_le_vsx_move): Likewise.\n+\t(rs6000_emit_move): Add support for V1TImode.\n+\t(altivec_expand_ld_builtin): Likewise.\n+\t(altivec_expand_st_builtin): Likewise.\n+\t(altivec_expand_vec_init_builtin): Likewise.\n+\t(altivec_expand_builtin): Likewise.\n+\t(rs6000_init_builtins): Add support for V1TImode type.  Add\n+\tsupport for ISA 2.07 128-bit integer builtins.  Define type names\n+\tfor the VSX/Altivec vector types.\n+\t(altivec_init_builtins): Add support for overloaded vector\n+\tfunctions with V1TImode type.\n+\t(rs6000_preferred_reload_class): Prefer Altivec registers for\n+\tV1TImode.\n+\t(rs6000_move_128bit_ok_p): Move 128-bit move/split validation to\n+\texternal function.\n+\t(rs6000_split_128bit_ok_p): Likewise.\n+\t(rs6000_handle_altivec_attribute): Create V1TImode from vector\n+\t__int128_t and vector __uint128_t.\n+\n+\t* config/rs6000/vsx.md (VSX_L): Add V1TImode to vector iterators\n+\tand mode attributes.\n+\t(VSX_M): Likewise.\n+\t(VSX_M2): Likewise.\n+\t(VSm): Likewise.\n+\t(VSs): Likewise.\n+\t(VSr): Likewise.\n+\t(VSv): Likewise.\n+\t(VS_scalar): Likewise.\n+\t(VS_double): Likewise.\n+\t(vsx_set_v1ti): New builtin function to create V1TImode from\n+\tTImode.\n+\n+\t* config/rs6000/rs6000.h (TARGET_VADDUQM): New macro to say\n+\twhether we support the ISA 2.07 128-bit integer arithmetic\n+\tinstructions.\n+\t(ALTIVEC_OR_VSX_VECTOR_MODE): Add V1TImode.\n+\t(enum rs6000_builtin_type_index): Add fields to hold V1TImode\n+\tand TImode types for use with the builtin functions.\n+\t(V1TI_type_node): Likewise.\n+\t(unsigned_V1TI_type_node): Likewise.\n+\t(intTI_type_internal_node): Likewise.\n+\t(uintTI_type_internal_node): Likewise.\n+\n+\t* config/rs6000/altivec.md (UNSPEC_VADDCUQ): New unspecs for ISA\n+\t2.07 128-bit builtin functions.\n+\t(UNSPEC_VADDEUQM): Likewise.\n+\t(UNSPEC_VADDECUQ): Likewise.\n+\t(UNSPEC_VSUBCUQ): Likewise.\n+\t(UNSPEC_VSUBEUQM): Likewise.\n+\t(UNSPEC_VSUBECUQ): Likewise.\n+\t(VM): Add V1TImode to vector mode iterators.\n+\t(VM2): Likewise.\n+\t(VI_unit): Likewise.\n+\t(altivec_vadduqm): Add ISA 2.07 128-bit binary builtins.\n+\t(altivec_vaddcuq): Likewise.\n+\t(altivec_vsubuqm): Likewise.\n+\t(altivec_vsubcuq): Likewise.\n+\t(altivec_vaddeuqm): Likewise.\n+\t(altivec_vaddecuq): Likewise.\n+\t(altivec_vsubeuqm): Likewise.\n+\t(altivec_vsubecuq): Likewise.\n+\n+\t* config/rs6000/rs6000.md (FMOVE128_GPR): Add V1TImode to vector\n+\tmode iterators.\n+\t(BOOL_128): Likewise.\n+\t(BOOL_REGS_OUTPUT): Likewise.\n+\t(BOOL_REGS_OP1): Likewise.\n+\t(BOOL_REGS_OP2): Likewise.\n+\t(BOOL_REGS_UNARY): Likewise.\n+\t(BOOL_REGS_AND_CR0): Likewise.\n+\n+\t* config/rs6000/altivec.h (vec_vaddcuq): Add support for ISA 2.07\n+\t128-bit integer builtin support.\n+\t(vec_vadduqm): Likewise.\n+\t(vec_vaddecuq): Likewise.\n+\t(vec_vaddeuqm): Likewise.\n+\t(vec_vsubecuq): Likewise.\n+\t(vec_vsubeuqm): Likewise.\n+\t(vec_vsubcuq): Likewise.\n+\t(vec_vsubuqm): Likewise.\n+\n+\t* doc/extend.texi (PowerPC AltiVec/VSX Built-in Functions):\n+\tDocument vec_vaddcuq, vec_vadduqm, vec_vaddecuq, vec_vaddeuqm,\n+\tvec_subecuq, vec_subeuqm, vec_vsubcuq, vec_vsubeqm builtins adding\n+\t128-bit integer add/subtract to ISA 2.07.\n+\n 2014-03-12  Joern Rennecke  <joern.rennecke@embecosm.com>\n \n \t* config/arc/arc.c (arc_predicate_delay_insns):"}, {"sha": "49c250c84d406702e9c8d9230cf3ac2f1db9d4c4", "filename": "gcc/config/rs6000/altivec.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Fconfig%2Frs6000%2Faltivec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Fconfig%2Frs6000%2Faltivec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.h?ref=a16a872d4445cd76105ad315d6cfbd066f1862be", "patch": "@@ -326,12 +326,18 @@\n #define vec_eqv __builtin_vec_eqv\n #define vec_nand __builtin_vec_nand\n #define vec_orc __builtin_vec_orc\n+#define vec_vaddcuq __builtin_vec_vaddcuq\n #define vec_vaddudm __builtin_vec_vaddudm\n+#define vec_vadduqm __builtin_vec_vadduqm\n #define vec_vclz __builtin_vec_vclz\n #define vec_vclzb __builtin_vec_vclzb\n #define vec_vclzd __builtin_vec_vclzd\n #define vec_vclzh __builtin_vec_vclzh\n #define vec_vclzw __builtin_vec_vclzw\n+#define vec_vaddecuq __builtin_vec_vaddecuq\n+#define vec_vaddeuqm __builtin_vec_vaddeuqm\n+#define vec_vsubecuq __builtin_vec_vsubecuq\n+#define vec_vsubeuqm __builtin_vec_vsubeuqm\n #define vec_vgbbd __builtin_vec_vgbbd\n #define vec_vmaxsd __builtin_vec_vmaxsd\n #define vec_vmaxud __builtin_vec_vmaxud\n@@ -352,7 +358,9 @@\n #define vec_vsld __builtin_vec_vsld\n #define vec_vsrad __builtin_vec_vsrad\n #define vec_vsrd __builtin_vec_vsrd\n+#define vec_vsubcuq __builtin_vec_vsubcuq\n #define vec_vsubudm __builtin_vec_vsubudm\n+#define vec_vsubuqm __builtin_vec_vsubuqm\n #define vec_vupkhsw __builtin_vec_vupkhsw\n #define vec_vupklsw __builtin_vec_vupklsw\n #endif"}, {"sha": "faa88d007c15a7c5837a8865245718ee25a4f8df", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 99, "deletions": 3, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=a16a872d4445cd76105ad315d6cfbd066f1862be", "patch": "@@ -136,6 +136,12 @@\n    UNSPEC_VMRGL_DIRECT\n    UNSPEC_VSPLT_DIRECT\n    UNSPEC_VSUMSWS_DIRECT\n+   UNSPEC_VADDCUQ\n+   UNSPEC_VADDEUQM\n+   UNSPEC_VADDECUQ\n+   UNSPEC_VSUBCUQ\n+   UNSPEC_VSUBEUQM\n+   UNSPEC_VSUBECUQ\n ])\n \n (define_c_enum \"unspecv\"\n@@ -158,17 +164,18 @@\n (define_mode_iterator V [V4SI V8HI V16QI V4SF])\n ;; Vec modes for move/logical/permute ops, include vector types for move not\n ;; otherwise handled by altivec (v2df, v2di, ti)\n-(define_mode_iterator VM [V4SI V8HI V16QI V4SF V2DF V2DI TI])\n+(define_mode_iterator VM [V4SI V8HI V16QI V4SF V2DF V2DI V1TI TI])\n \n ;; Like VM, except don't do TImode\n-(define_mode_iterator VM2 [V4SI V8HI V16QI V4SF V2DF V2DI])\n+(define_mode_iterator VM2 [V4SI V8HI V16QI V4SF V2DF V2DI V1TI])\n \n (define_mode_attr VI_char [(V2DI \"d\") (V4SI \"w\") (V8HI \"h\") (V16QI \"b\")])\n (define_mode_attr VI_scalar [(V2DI \"DI\") (V4SI \"SI\") (V8HI \"HI\") (V16QI \"QI\")])\n (define_mode_attr VI_unit [(V16QI \"VECTOR_UNIT_ALTIVEC_P (V16QImode)\")\n \t\t\t   (V8HI \"VECTOR_UNIT_ALTIVEC_P (V8HImode)\")\n \t\t\t   (V4SI \"VECTOR_UNIT_ALTIVEC_P (V4SImode)\")\n-\t\t\t   (V2DI \"VECTOR_UNIT_P8_VECTOR_P (V2DImode)\")])\n+\t\t\t   (V2DI \"VECTOR_UNIT_P8_VECTOR_P (V2DImode)\")\n+\t\t\t   (V1TI \"VECTOR_UNIT_ALTIVEC_P (V1TImode)\")])\n \n ;; Vector pack/unpack\n (define_mode_iterator VP [V2DI V4SI V8HI])\n@@ -3226,3 +3233,92 @@\n   \"vgbbd %0,%1\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"vecsimple\")])\n+\n+\f\n+;; 128-bit binary integer arithmetic\n+;; We have a special container type (V1TImode) to allow operations using the\n+;; ISA 2.07 128-bit binary support to target the VMX/altivec registers without\n+;; having to worry about the register allocator deciding GPRs are better.\n+\n+(define_insn \"altivec_vadduqm\"\n+  [(set (match_operand:V1TI 0 \"register_operand\" \"=v\")\n+\t(plus:V1TI (match_operand:V1TI 1 \"register_operand\" \"v\")\n+\t\t   (match_operand:V1TI 2 \"register_operand\" \"v\")))]\n+  \"TARGET_VADDUQM\"\n+  \"vadduqm %0,%1,%2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"vecsimple\")])\n+\n+(define_insn \"altivec_vaddcuq\"\n+  [(set (match_operand:V1TI 0 \"register_operand\" \"=v\")\n+\t(unspec:V1TI [(match_operand:V1TI 1 \"register_operand\" \"v\")\n+\t\t      (match_operand:V1TI 2 \"register_operand\" \"v\")]\n+\t\t     UNSPEC_VADDCUQ))]\n+  \"TARGET_VADDUQM\"\n+  \"vaddcuq %0,%1,%2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"vecsimple\")])\n+\n+(define_insn \"altivec_vsubuqm\"\n+  [(set (match_operand:V1TI 0 \"register_operand\" \"=v\")\n+\t(minus:V1TI (match_operand:V1TI 1 \"register_operand\" \"v\")\n+\t\t    (match_operand:V1TI 2 \"register_operand\" \"v\")))]\n+  \"TARGET_VADDUQM\"\n+  \"vsubuqm %0,%1,%2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"vecsimple\")])\n+\n+(define_insn \"altivec_vsubcuq\"\n+  [(set (match_operand:V1TI 0 \"register_operand\" \"=v\")\n+\t(unspec:V1TI [(match_operand:V1TI 1 \"register_operand\" \"v\")\n+\t\t      (match_operand:V1TI 2 \"register_operand\" \"v\")]\n+\t\t     UNSPEC_VSUBCUQ))]\n+  \"TARGET_VADDUQM\"\n+  \"vsubcuq %0,%1,%2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"vecsimple\")])\n+\n+(define_insn \"altivec_vaddeuqm\"\n+  [(set (match_operand:V1TI 0 \"register_operand\" \"=v\")\n+\t(unspec:V1TI [(match_operand:V1TI 1 \"register_operand\" \"v\")\n+\t\t      (match_operand:V1TI 2 \"register_operand\" \"v\")\n+\t\t      (match_operand:V1TI 3 \"register_operand\" \"v\")]\n+\t\t     UNSPEC_VADDEUQM))]\n+  \"TARGET_VADDUQM\"\n+  \"vaddeuqm %0,%1,%2,%3\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"vecsimple\")])\n+\n+(define_insn \"altivec_vaddecuq\"\n+  [(set (match_operand:V1TI 0 \"register_operand\" \"=v\")\n+\t(unspec:V1TI [(match_operand:V1TI 1 \"register_operand\" \"v\")\n+\t\t      (match_operand:V1TI 2 \"register_operand\" \"v\")\n+\t\t      (match_operand:V1TI 3 \"register_operand\" \"v\")]\n+\t\t     UNSPEC_VADDECUQ))]\n+  \"TARGET_VADDUQM\"\n+  \"vaddecuq %0,%1,%2,%3\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"vecsimple\")])\n+\n+(define_insn \"altivec_vsubeuqm\"\n+  [(set (match_operand:V1TI 0 \"register_operand\" \"=v\")\n+\t(unspec:V1TI [(match_operand:V1TI 1 \"register_operand\" \"v\")\n+\t\t      (match_operand:V1TI 2 \"register_operand\" \"v\")\n+\t\t      (match_operand:V1TI 3 \"register_operand\" \"v\")]\n+\t\t   UNSPEC_VSUBEUQM))]\n+  \"TARGET_VADDUQM\"\n+  \"vsubeuqm %0,%1,%2,%3\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"vecsimple\")])\n+\n+(define_insn \"altivec_vsubecuq\"\n+  [(set (match_operand:V1TI 0 \"register_operand\" \"=v\")\n+\t(unspec:V1TI [(match_operand:V1TI 1 \"register_operand\" \"v\")\n+\t\t      (match_operand:V1TI 2 \"register_operand\" \"v\")\n+\t\t      (match_operand:V1TI 3 \"register_operand\" \"v\")]\n+\t\t     UNSPEC_VSUBECUQ))]\n+  \"TARGET_VADDUQM\"\n+  \"vsubecuq %0,%1,%2,%3\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"vecsimple\")])\n+"}, {"sha": "9226035a3fd08822f261e329b52cd6d59511ca26", "filename": "gcc/config/rs6000/rs6000-builtin.def", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def?ref=a16a872d4445cd76105ad315d6cfbd066f1862be", "patch": "@@ -325,6 +325,14 @@\n \t\t     | RS6000_BTC_BINARY),\t\t\t\t\\\n \t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n \n+#define BU_P8V_AV_3(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_3 (P8V_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_altivec_\" NAME,\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_P8_VECTOR,\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_TERNARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n #define BU_P8V_AV_P(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n   RS6000_BUILTIN_P (P8V_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n \t\t    \"__builtin_altivec_\" NAME,\t\t/* NAME */\t\\\n@@ -359,6 +367,14 @@\n \t\t     | RS6000_BTC_BINARY),\t\t\t\t\\\n \t\t    CODE_FOR_nothing)\t\t\t/* ICODE */\n \n+#define BU_P8V_OVERLOAD_3(ENUM, NAME)\t\t\t\t\t\\\n+  RS6000_BUILTIN_3 (P8V_BUILTIN_VEC_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_vec_\" NAME,\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_P8_VECTOR,\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_OVERLOADED\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_TERNARY),\t\t\t\t\\\n+\t\t    CODE_FOR_nothing)\t\t\t/* ICODE */\n+\n /* Crypto convenience macros.  */\n #define BU_CRYPTO_1(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n   RS6000_BUILTIN_1 (CRYPTO_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n@@ -571,12 +587,14 @@ BU_ALTIVEC_3 (VMSUMSHM,       \"vmsumshm\",       CONST, \taltivec_vmsumshm)\n BU_ALTIVEC_3 (VMSUMUHS,       \"vmsumuhs\",       SAT,   \taltivec_vmsumuhs)\n BU_ALTIVEC_3 (VMSUMSHS,       \"vmsumshs\",       SAT,   \taltivec_vmsumshs)\n BU_ALTIVEC_3 (VNMSUBFP,       \"vnmsubfp\",       FP,    \tnfmsv4sf4)\n+BU_ALTIVEC_3 (VPERM_1TI,      \"vperm_1ti\",      CONST, \taltivec_vperm_v1ti)\n BU_ALTIVEC_3 (VPERM_2DF,      \"vperm_2df\",      CONST, \taltivec_vperm_v2df)\n BU_ALTIVEC_3 (VPERM_2DI,      \"vperm_2di\",      CONST, \taltivec_vperm_v2di)\n BU_ALTIVEC_3 (VPERM_4SF,      \"vperm_4sf\",      CONST, \taltivec_vperm_v4sf)\n BU_ALTIVEC_3 (VPERM_4SI,      \"vperm_4si\",      CONST, \taltivec_vperm_v4si)\n BU_ALTIVEC_3 (VPERM_8HI,      \"vperm_8hi\",      CONST, \taltivec_vperm_v8hi)\n BU_ALTIVEC_3 (VPERM_16QI,     \"vperm_16qi\",     CONST, \taltivec_vperm_v16qi_uns)\n+BU_ALTIVEC_3 (VPERM_1TI_UNS,  \"vperm_1ti_uns\",  CONST, \taltivec_vperm_v1ti_uns)\n BU_ALTIVEC_3 (VPERM_2DI_UNS,  \"vperm_2di_uns\",  CONST, \taltivec_vperm_v2di_uns)\n BU_ALTIVEC_3 (VPERM_4SI_UNS,  \"vperm_4si_uns\",  CONST, \taltivec_vperm_v4si_uns)\n BU_ALTIVEC_3 (VPERM_8HI_UNS,  \"vperm_8hi_uns\",  CONST, \taltivec_vperm_v8hi_uns)\n@@ -587,10 +605,12 @@ BU_ALTIVEC_3 (VSEL_8HI,       \"vsel_8hi\",       CONST, \tvector_select_v8hi)\n BU_ALTIVEC_3 (VSEL_16QI,      \"vsel_16qi\",      CONST, \tvector_select_v16qi)\n BU_ALTIVEC_3 (VSEL_2DF,       \"vsel_2df\",       CONST, \tvector_select_v2df)\n BU_ALTIVEC_3 (VSEL_2DI,       \"vsel_2di\",       CONST, \tvector_select_v2di)\n+BU_ALTIVEC_3 (VSEL_1TI,       \"vsel_1ti\",       CONST, \tvector_select_v1ti)\n BU_ALTIVEC_3 (VSEL_4SI_UNS,   \"vsel_4si_uns\",   CONST, \tvector_select_v4si_uns)\n BU_ALTIVEC_3 (VSEL_8HI_UNS,   \"vsel_8hi_uns\",   CONST, \tvector_select_v8hi_uns)\n BU_ALTIVEC_3 (VSEL_16QI_UNS,  \"vsel_16qi_uns\",  CONST, \tvector_select_v16qi_uns)\n BU_ALTIVEC_3 (VSEL_2DI_UNS,   \"vsel_2di_uns\",   CONST, \tvector_select_v2di_uns)\n+BU_ALTIVEC_3 (VSEL_1TI_UNS,   \"vsel_1ti_uns\",   CONST, \tvector_select_v1ti_uns)\n BU_ALTIVEC_3 (VSLDOI_16QI,    \"vsldoi_16qi\",    CONST, \taltivec_vsldoi_v16qi)\n BU_ALTIVEC_3 (VSLDOI_8HI,     \"vsldoi_8hi\",     CONST, \taltivec_vsldoi_v8hi)\n BU_ALTIVEC_3 (VSLDOI_4SI,     \"vsldoi_4si\",     CONST, \taltivec_vsldoi_v4si)\n@@ -783,6 +803,8 @@ BU_ALTIVEC_X (ST_INTERNAL_2df,\t\"st_internal_4sf\",  MEM)\n BU_ALTIVEC_X (LD_INTERNAL_2df,\t\"ld_internal_2df\",  MEM)\n BU_ALTIVEC_X (ST_INTERNAL_2di,\t\"st_internal_2di\",  MEM)\n BU_ALTIVEC_X (LD_INTERNAL_2di,\t\"ld_internal_2di\",  MEM)\n+BU_ALTIVEC_X (ST_INTERNAL_1ti,\t\"st_internal_1ti\",  MEM)\n+BU_ALTIVEC_X (LD_INTERNAL_1ti,\t\"ld_internal_1ti\",  MEM)\n BU_ALTIVEC_X (MTVSCR,\t\t\"mtvscr\",\t    MISC)\n BU_ALTIVEC_X (MFVSCR,\t\t\"mfvscr\",\t    MISC)\n BU_ALTIVEC_X (DSSALL,\t\t\"dssall\",\t    MISC)\n@@ -1085,34 +1107,40 @@ BU_VSX_3 (XVMSUBDP,           \"xvmsubdp\",       CONST, \tfmsv2df4)\n BU_VSX_3 (XVNMADDDP,          \"xvnmadddp\",      CONST, \tnfmav2df4)\n BU_VSX_3 (XVNMSUBDP,          \"xvnmsubdp\",      CONST, \tnfmsv2df4)\n \n+BU_VSX_3 (XXSEL_1TI,          \"xxsel_1ti\",      CONST, \tvector_select_v1ti)\n BU_VSX_3 (XXSEL_2DI,          \"xxsel_2di\",      CONST, \tvector_select_v2di)\n BU_VSX_3 (XXSEL_2DF,          \"xxsel_2df\",      CONST, \tvector_select_v2df)\n BU_VSX_3 (XXSEL_4SF,          \"xxsel_4sf\",      CONST, \tvector_select_v4sf)\n BU_VSX_3 (XXSEL_4SI,          \"xxsel_4si\",      CONST, \tvector_select_v4si)\n BU_VSX_3 (XXSEL_8HI,          \"xxsel_8hi\",      CONST, \tvector_select_v8hi)\n BU_VSX_3 (XXSEL_16QI,         \"xxsel_16qi\",     CONST, \tvector_select_v16qi)\n+BU_VSX_3 (XXSEL_1TI_UNS,      \"xxsel_1ti_uns\",  CONST, \tvector_select_v1ti_uns)\n BU_VSX_3 (XXSEL_2DI_UNS,      \"xxsel_2di_uns\",  CONST, \tvector_select_v2di_uns)\n BU_VSX_3 (XXSEL_4SI_UNS,      \"xxsel_4si_uns\",  CONST, \tvector_select_v4si_uns)\n BU_VSX_3 (XXSEL_8HI_UNS,      \"xxsel_8hi_uns\",  CONST, \tvector_select_v8hi_uns)\n BU_VSX_3 (XXSEL_16QI_UNS,     \"xxsel_16qi_uns\", CONST, \tvector_select_v16qi_uns)\n \n+BU_VSX_3 (VPERM_1TI,          \"vperm_1ti\",      CONST, \taltivec_vperm_v1ti)\n BU_VSX_3 (VPERM_2DI,          \"vperm_2di\",      CONST, \taltivec_vperm_v2di)\n BU_VSX_3 (VPERM_2DF,          \"vperm_2df\",      CONST, \taltivec_vperm_v2df)\n BU_VSX_3 (VPERM_4SF,          \"vperm_4sf\",      CONST, \taltivec_vperm_v4sf)\n BU_VSX_3 (VPERM_4SI,          \"vperm_4si\",      CONST, \taltivec_vperm_v4si)\n BU_VSX_3 (VPERM_8HI,          \"vperm_8hi\",      CONST, \taltivec_vperm_v8hi)\n BU_VSX_3 (VPERM_16QI,         \"vperm_16qi\",     CONST, \taltivec_vperm_v16qi)\n+BU_VSX_3 (VPERM_1TI_UNS,      \"vperm_1ti_uns\",  CONST, \taltivec_vperm_v1ti_uns)\n BU_VSX_3 (VPERM_2DI_UNS,      \"vperm_2di_uns\",  CONST, \taltivec_vperm_v2di_uns)\n BU_VSX_3 (VPERM_4SI_UNS,      \"vperm_4si_uns\",  CONST, \taltivec_vperm_v4si_uns)\n BU_VSX_3 (VPERM_8HI_UNS,      \"vperm_8hi_uns\",  CONST, \taltivec_vperm_v8hi_uns)\n BU_VSX_3 (VPERM_16QI_UNS,     \"vperm_16qi_uns\", CONST, \taltivec_vperm_v16qi_uns)\n \n+BU_VSX_3 (XXPERMDI_1TI,       \"xxpermdi_1ti\",   CONST, \tvsx_xxpermdi_v1ti)\n BU_VSX_3 (XXPERMDI_2DF,       \"xxpermdi_2df\",   CONST, \tvsx_xxpermdi_v2df)\n BU_VSX_3 (XXPERMDI_2DI,       \"xxpermdi_2di\",   CONST, \tvsx_xxpermdi_v2di)\n BU_VSX_3 (XXPERMDI_4SF,       \"xxpermdi_4sf\",   CONST, \tvsx_xxpermdi_v4sf)\n BU_VSX_3 (XXPERMDI_4SI,       \"xxpermdi_4si\",   CONST, \tvsx_xxpermdi_v4si)\n BU_VSX_3 (XXPERMDI_8HI,       \"xxpermdi_8hi\",   CONST, \tvsx_xxpermdi_v8hi)\n BU_VSX_3 (XXPERMDI_16QI,      \"xxpermdi_16qi\",  CONST, \tvsx_xxpermdi_v16qi)\n+BU_VSX_3 (SET_1TI,            \"set_1ti\",        CONST, \tvsx_set_v1ti)\n BU_VSX_3 (SET_2DF,            \"set_2df\",        CONST, \tvsx_set_v2df)\n BU_VSX_3 (SET_2DI,            \"set_2di\",        CONST, \tvsx_set_v2di)\n BU_VSX_3 (XXSLDWI_2DI,        \"xxsldwi_2di\",    CONST, \tvsx_xxsldwi_v2di)\n@@ -1247,6 +1275,7 @@ BU_VSX_P (XVCMPGTDP_P,\t      \"xvcmpgtdp_p\",\tCONST,\tvector_gt_v2df_p)\n \n /* VSX builtins that are handled as special cases.  */\n BU_VSX_X (LXSDX,\t      \"lxsdx\",\t\tMEM)\n+BU_VSX_X (LXVD2X_V1TI,\t      \"lxvd2x_v1ti\",\tMEM)\n BU_VSX_X (LXVD2X_V2DF,\t      \"lxvd2x_v2df\",\tMEM)\n BU_VSX_X (LXVD2X_V2DI,\t      \"lxvd2x_v2di\",\tMEM)\n BU_VSX_X (LXVDSX,\t      \"lxvdsx\",\t\tMEM)\n@@ -1255,6 +1284,7 @@ BU_VSX_X (LXVW4X_V4SI,        \"lxvw4x_v4si\",\tMEM)\n BU_VSX_X (LXVW4X_V8HI,        \"lxvw4x_v8hi\",\tMEM)\n BU_VSX_X (LXVW4X_V16QI,\t      \"lxvw4x_v16qi\",\tMEM)\n BU_VSX_X (STXSDX,\t      \"stxsdx\",\t\tMEM)\n+BU_VSX_X (STXVD2X_V1TI,\t      \"stxsdx_v1ti\",\tMEM)\n BU_VSX_X (STXVD2X_V2DF,\t      \"stxsdx_v2df\",\tMEM)\n BU_VSX_X (STXVD2X_V2DI,\t      \"stxsdx_v2di\",\tMEM)\n BU_VSX_X (STXVW4X_V4SF,\t      \"stxsdx_v4sf\",\tMEM)\n@@ -1285,10 +1315,13 @@ BU_VSX_X (XSNMADDMDP,\t      \"xsnmaddmdp\",\tFP)\n BU_VSX_X (XSNMSUBADP,\t      \"xsnmsubadp\",\tFP)\n BU_VSX_X (XSNMSUBMDP,\t      \"xsnmsubmdp\",\tFP)\n BU_VSX_X (XSSUBDP,\t      \"xssubdp\",\tFP)\n+BU_VSX_X (VEC_INIT_V1TI,      \"vec_init_v1ti\",\tCONST)\n BU_VSX_X (VEC_INIT_V2DF,      \"vec_init_v2df\",\tCONST)\n BU_VSX_X (VEC_INIT_V2DI,      \"vec_init_v2di\",\tCONST)\n+BU_VSX_X (VEC_SET_V1TI,\t      \"vec_set_v1ti\",\tCONST)\n BU_VSX_X (VEC_SET_V2DF,\t      \"vec_set_v2df\",\tCONST)\n BU_VSX_X (VEC_SET_V2DI,\t      \"vec_set_v2di\",\tCONST)\n+BU_VSX_X (VEC_EXT_V1TI,\t      \"vec_ext_v1ti\",\tCONST)\n BU_VSX_X (VEC_EXT_V2DF,\t      \"vec_ext_v2df\",\tCONST)\n BU_VSX_X (VEC_EXT_V2DI,\t      \"vec_ext_v2di\",\tCONST)\n \n@@ -1332,7 +1365,9 @@ BU_P8V_AV_1 (VPOPCNTD,\t      \"vpopcntd\",\tCONST,  popcountv2di2)\n BU_P8V_AV_1 (VGBBD,\t      \"vgbbd\",\t\tCONST,  p8v_vgbbd)\n \n /* 2 argument altivec instructions added in ISA 2.07.  */\n+BU_P8V_AV_2 (VADDCUQ,\t\t\"vaddcuq\",\tCONST,\taltivec_vaddcuq)\n BU_P8V_AV_2 (VADDUDM,\t\t\"vaddudm\",\tCONST,\taddv2di3)\n+BU_P8V_AV_2 (VADDUQM,\t\t\"vadduqm\",\tCONST,\taltivec_vadduqm)\n BU_P8V_AV_2 (VMINSD,\t\t\"vminsd\",\tCONST,\tsminv2di3)\n BU_P8V_AV_2 (VMAXSD,\t\t\"vmaxsd\",\tCONST,\tsmaxv2di3)\n BU_P8V_AV_2 (VMINUD,\t\t\"vminud\",\tCONST,\tuminv2di3)\n@@ -1347,29 +1382,40 @@ BU_P8V_AV_2 (VRLD,\t\t\"vrld\",\t\tCONST,\tvrotlv2di3)\n BU_P8V_AV_2 (VSLD,\t\t\"vsld\",\t\tCONST,\tvashlv2di3)\n BU_P8V_AV_2 (VSRD,\t\t\"vsrd\",\t\tCONST,\tvlshrv2di3)\n BU_P8V_AV_2 (VSRAD,\t\t\"vsrad\",\tCONST,\tvashrv2di3)\n+BU_P8V_AV_2 (VSUBCUQ,\t\t\"vsubcuq\",\tCONST,\taltivec_vsubcuq)\n BU_P8V_AV_2 (VSUBUDM,\t\t\"vsubudm\",\tCONST,\tsubv2di3)\n+BU_P8V_AV_2 (VSUBUQM,\t\t\"vsubuqm\",\tCONST,\taltivec_vsubuqm)\n \n BU_P8V_AV_2 (EQV_V16QI,\t\t\"eqv_v16qi\",\tCONST,\teqvv16qi3)\n BU_P8V_AV_2 (EQV_V8HI,\t\t\"eqv_v8hi\",\tCONST,\teqvv8hi3)\n BU_P8V_AV_2 (EQV_V4SI,\t\t\"eqv_v4si\",\tCONST,\teqvv4si3)\n BU_P8V_AV_2 (EQV_V2DI,\t\t\"eqv_v2di\",\tCONST,\teqvv2di3)\n+BU_P8V_AV_2 (EQV_V1TI,\t\t\"eqv_v1ti\",\tCONST,\teqvv1ti3)\n BU_P8V_AV_2 (EQV_V4SF,\t\t\"eqv_v4sf\",\tCONST,\teqvv4sf3)\n BU_P8V_AV_2 (EQV_V2DF,\t\t\"eqv_v2df\",\tCONST,\teqvv2df3)\n \n BU_P8V_AV_2 (NAND_V16QI,\t\"nand_v16qi\",\tCONST,\tnandv16qi3)\n BU_P8V_AV_2 (NAND_V8HI,\t\t\"nand_v8hi\",\tCONST,\tnandv8hi3)\n BU_P8V_AV_2 (NAND_V4SI,\t\t\"nand_v4si\",\tCONST,\tnandv4si3)\n BU_P8V_AV_2 (NAND_V2DI,\t\t\"nand_v2di\",\tCONST,\tnandv2di3)\n+BU_P8V_AV_2 (NAND_V1TI,\t\t\"nand_v1ti\",\tCONST,\tnandv1ti3)\n BU_P8V_AV_2 (NAND_V4SF,\t\t\"nand_v4sf\",\tCONST,\tnandv4sf3)\n BU_P8V_AV_2 (NAND_V2DF,\t\t\"nand_v2df\",\tCONST,\tnandv2df3)\n \n BU_P8V_AV_2 (ORC_V16QI,\t\t\"orc_v16qi\",\tCONST,\torcv16qi3)\n BU_P8V_AV_2 (ORC_V8HI,\t\t\"orc_v8hi\",\tCONST,\torcv8hi3)\n BU_P8V_AV_2 (ORC_V4SI,\t\t\"orc_v4si\",\tCONST,\torcv4si3)\n BU_P8V_AV_2 (ORC_V2DI,\t\t\"orc_v2di\",\tCONST,\torcv2di3)\n+BU_P8V_AV_2 (ORC_V1TI,\t\t\"orc_v1ti\",\tCONST,\torcv1ti3)\n BU_P8V_AV_2 (ORC_V4SF,\t\t\"orc_v4sf\",\tCONST,\torcv4sf3)\n BU_P8V_AV_2 (ORC_V2DF,\t\t\"orc_v2df\",\tCONST,\torcv2df3)\n \n+/* 3 argument altivec instructions added in ISA 2.07.  */\n+BU_P8V_AV_3 (VADDEUQM,\t\t\"vaddeuqm\",\t CONST,\taltivec_vaddeuqm)\n+BU_P8V_AV_3 (VADDECUQ,\t\t\"vaddecuq\",\t CONST,\taltivec_vaddecuq)\n+BU_P8V_AV_3 (VSUBEUQM,\t\t\"vsubeuqm\",\t CONST,\taltivec_vsubeuqm)\n+BU_P8V_AV_3 (VSUBECUQ,\t\t\"vsubecuq\",\t CONST,\taltivec_vsubecuq)\n+\n /* Vector comparison instructions added in ISA 2.07.  */\n BU_P8V_AV_2 (VCMPEQUD,\t\t\"vcmpequd\",\tCONST,\tvector_eqv2di)\n BU_P8V_AV_2 (VCMPGTSD,\t\t\"vcmpgtsd\",\tCONST,\tvector_gtv2di)\n@@ -1399,7 +1445,9 @@ BU_P8V_OVERLOAD_1 (VGBBD,\t\"vgbbd\")\n BU_P8V_OVERLOAD_2 (EQV,\t\t\"eqv\")\n BU_P8V_OVERLOAD_2 (NAND,\t\"nand\")\n BU_P8V_OVERLOAD_2 (ORC,\t\t\"orc\")\n+BU_P8V_OVERLOAD_2 (VADDCUQ,\t\"vaddcuq\")\n BU_P8V_OVERLOAD_2 (VADDUDM,\t\"vaddudm\")\n+BU_P8V_OVERLOAD_2 (VADDUQM,\t\"vadduqm\")\n BU_P8V_OVERLOAD_2 (VMAXSD,\t\"vmaxsd\")\n BU_P8V_OVERLOAD_2 (VMAXUD,\t\"vmaxud\")\n BU_P8V_OVERLOAD_2 (VMINSD,\t\"vminsd\")\n@@ -1414,7 +1462,15 @@ BU_P8V_OVERLOAD_2 (VRLD,\t\"vrld\")\n BU_P8V_OVERLOAD_2 (VSLD,\t\"vsld\")\n BU_P8V_OVERLOAD_2 (VSRAD,\t\"vsrad\")\n BU_P8V_OVERLOAD_2 (VSRD,\t\"vsrd\")\n+BU_P8V_OVERLOAD_2 (VSUBCUQ,\t\"vsubcuq\")\n BU_P8V_OVERLOAD_2 (VSUBUDM,\t\"vsubudm\")\n+BU_P8V_OVERLOAD_2 (VSUBUQM,\t\"vsubuqm\")\n+\n+/* ISA 2.07 vector overloaded 3 argument functions.  */\n+BU_P8V_OVERLOAD_3 (VADDECUQ,\t\"vaddecuq\")\n+BU_P8V_OVERLOAD_3 (VADDEUQM,\t\"vaddeuqm\")\n+BU_P8V_OVERLOAD_3 (VSUBECUQ,\t\"vsubecuq\")\n+BU_P8V_OVERLOAD_3 (VSUBEUQM,\t\"vsubeuqm\")\n \n \f\n /* 1 argument crypto functions.  */"}, {"sha": "0f1dafc5a03c5afdb336364fef1fd7bee8019be6", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 102, "deletions": 4, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=a16a872d4445cd76105ad315d6cfbd066f1862be", "patch": "@@ -92,6 +92,8 @@ static GTY(()) tree pixel_keyword;\n static GTY(()) tree __bool_keyword;\n static GTY(()) tree bool_keyword;\n static GTY(()) tree _Bool_keyword;\n+static GTY(()) tree __int128_type;\n+static GTY(()) tree __uint128_type;\n \n /* Preserved across calls.  */\n static tree expand_bool_pixel;\n@@ -124,9 +126,10 @@ altivec_categorize_keyword (const cpp_token *tok)\n static void\n init_vector_keywords (void)\n {\n-  /* Keywords without two leading underscores are context-sensitive,\n-     and hence implemented as conditional macros, controlled by the\n-     rs6000_macro_to_expand() function below.  */\n+  /* Keywords without two leading underscores are context-sensitive, and hence\n+     implemented as conditional macros, controlled by the\n+     rs6000_macro_to_expand() function below.  If we have ISA 2.07 64-bit\n+     support, record the __int128_t and __uint128_t types.  */\n \n   __vector_keyword = get_identifier (\"__vector\");\n   C_CPP_HASHNODE (__vector_keyword)->flags |= NODE_CONDITIONAL;\n@@ -148,6 +151,12 @@ init_vector_keywords (void)\n \n   _Bool_keyword = get_identifier (\"_Bool\");\n   C_CPP_HASHNODE (_Bool_keyword)->flags |= NODE_CONDITIONAL;\n+\n+  if (TARGET_VADDUQM)\n+    {\n+      __int128_type = get_identifier (\"__int128_t\");\n+      __uint128_type = get_identifier (\"__uint128_t\");\n+    }\n }\n \n /* Called to decide whether a conditional macro should be expanded.\n@@ -223,7 +232,8 @@ rs6000_macro_to_expand (cpp_reader *pfile, const cpp_token *tok)\n \t      || rid_code == RID_SHORT || rid_code == RID_SIGNED\n \t      || rid_code == RID_INT || rid_code == RID_CHAR\n \t      || rid_code == RID_FLOAT\n-\t      || (rid_code == RID_DOUBLE && TARGET_VSX))\n+\t      || (rid_code == RID_DOUBLE && TARGET_VSX)\n+\t      || (rid_code == RID_INT128 && TARGET_VADDUQM))\n \t    {\n \t      expand_this = C_CPP_HASHNODE (__vector_keyword);\n \t      /* If the next keyword is bool or pixel, it\n@@ -250,6 +260,13 @@ rs6000_macro_to_expand (cpp_reader *pfile, const cpp_token *tok)\n \t\t    expand_bool_pixel = __bool_keyword;\n \t\t}\n \t    }\n+\n+\t  /* Support vector __int128_t, but we don't need to worry about bool\n+\t     or pixel on this type.  */\n+\t  else if (TARGET_VADDUQM\n+\t\t   && (ident == C_CPP_HASHNODE (__int128_type)\n+\t\t       || ident == C_CPP_HASHNODE (__uint128_type)))\n+\t    expand_this = C_CPP_HASHNODE (__vector_keyword);\n \t}\n     }\n   else if (expand_bool_pixel && ident == C_CPP_HASHNODE (__pixel_keyword))\n@@ -706,6 +723,11 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },\n   { ALTIVEC_BUILTIN_VEC_ADD, VSX_BUILTIN_XVADDDP,\n     RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0 },\n+  { ALTIVEC_BUILTIN_VEC_ADD, P8V_BUILTIN_VADDUQM,\n+    RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_V1TI, 0 },\n+  { ALTIVEC_BUILTIN_VEC_ADD, P8V_BUILTIN_VADDUQM,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI,\n+    RS6000_BTI_unsigned_V1TI, 0 },\n   { ALTIVEC_BUILTIN_VEC_VADDFP, ALTIVEC_BUILTIN_VADDFP,\n     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },\n   { ALTIVEC_BUILTIN_VEC_VADDUWM, ALTIVEC_BUILTIN_VADDUWM,\n@@ -2327,6 +2349,11 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },\n   { ALTIVEC_BUILTIN_VEC_SUB, VSX_BUILTIN_XVSUBDP,\n     RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0 },\n+  { ALTIVEC_BUILTIN_VEC_SUB, P8V_BUILTIN_VSUBUQM,\n+    RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_V1TI, 0 },\n+  { ALTIVEC_BUILTIN_VEC_SUB, P8V_BUILTIN_VSUBUQM,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI,\n+    RS6000_BTI_unsigned_V1TI, 0 },\n   { ALTIVEC_BUILTIN_VEC_VSUBFP, ALTIVEC_BUILTIN_VSUBFP,\n     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },\n   { ALTIVEC_BUILTIN_VEC_VSUBUWM, ALTIVEC_BUILTIN_VSUBUWM,\n@@ -3726,6 +3753,12 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n   { P8V_BUILTIN_VEC_ORC, P8V_BUILTIN_ORC_V2DF,\n     RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0 },\n \n+  { P8V_BUILTIN_VEC_VADDCUQ, P8V_BUILTIN_VADDCUQ,\n+    RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_V1TI, 0 },\n+  { P8V_BUILTIN_VEC_VADDCUQ, P8V_BUILTIN_VADDCUQ,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI,\n+    RS6000_BTI_unsigned_V1TI, 0 },\n+\n   { P8V_BUILTIN_VEC_VADDUDM, P8V_BUILTIN_VADDUDM,\n     RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },\n   { P8V_BUILTIN_VEC_VADDUDM, P8V_BUILTIN_VADDUDM,\n@@ -3739,6 +3772,12 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n   { P8V_BUILTIN_VEC_VADDUDM, P8V_BUILTIN_VADDUDM,\n     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n \n+  { P8V_BUILTIN_VEC_VADDUQM, P8V_BUILTIN_VADDUQM,\n+    RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_V1TI, 0 },\n+  { P8V_BUILTIN_VEC_VADDUQM, P8V_BUILTIN_VADDUQM,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI,\n+    RS6000_BTI_unsigned_V1TI, 0 },\n+\n   { P8V_BUILTIN_VEC_VCLZ, P8V_BUILTIN_VCLZB,\n     RS6000_BTI_V16QI, RS6000_BTI_V16QI, 0, 0 },\n   { P8V_BUILTIN_VEC_VCLZ, P8V_BUILTIN_VCLZB,\n@@ -3781,6 +3820,30 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n   { P8V_BUILTIN_VEC_VGBBD, P8V_BUILTIN_VGBBD,\n     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, 0, 0 },\n \n+  { P8V_BUILTIN_VEC_VADDECUQ, P8V_BUILTIN_VADDECUQ,\n+    RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_V1TI },\n+  { P8V_BUILTIN_VEC_VADDECUQ, P8V_BUILTIN_VADDECUQ,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI },\n+\n+  { P8V_BUILTIN_VEC_VADDEUQM, P8V_BUILTIN_VADDEUQM,\n+    RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_V1TI },\n+  { P8V_BUILTIN_VEC_VADDEUQM, P8V_BUILTIN_VADDEUQM,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI },\n+\n+  { P8V_BUILTIN_VEC_VSUBECUQ, P8V_BUILTIN_VSUBECUQ,\n+    RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_V1TI },\n+  { P8V_BUILTIN_VEC_VSUBECUQ, P8V_BUILTIN_VSUBECUQ,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI },\n+\n+  { P8V_BUILTIN_VEC_VSUBEUQM, P8V_BUILTIN_VSUBEUQM,\n+    RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_V1TI },\n+  { P8V_BUILTIN_VEC_VSUBEUQM, P8V_BUILTIN_VSUBEUQM,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI },\n+\n   { P8V_BUILTIN_VEC_VMINSD, P8V_BUILTIN_VMINSD,\n     RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },\n   { P8V_BUILTIN_VEC_VMINSD, P8V_BUILTIN_VMINSD,\n@@ -3900,6 +3963,12 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n   { P8V_BUILTIN_VEC_VSRAD, P8V_BUILTIN_VSRD,\n     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n \n+  { P8V_BUILTIN_VEC_VSUBCUQ, P8V_BUILTIN_VSUBCUQ,\n+    RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_V1TI, 0 },\n+  { P8V_BUILTIN_VEC_VSUBCUQ, P8V_BUILTIN_VSUBCUQ,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI,\n+    RS6000_BTI_unsigned_V1TI, 0 },\n+\n   { P8V_BUILTIN_VEC_VSUBUDM, P8V_BUILTIN_VSUBUDM,\n     RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },\n   { P8V_BUILTIN_VEC_VSUBUDM, P8V_BUILTIN_VSUBUDM,\n@@ -3913,6 +3982,12 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n   { P8V_BUILTIN_VEC_VSUBUDM, P8V_BUILTIN_VSUBUDM,\n     RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n \n+  { P8V_BUILTIN_VEC_VSUBUQM, P8V_BUILTIN_VSUBUQM,\n+    RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_V1TI, 0 },\n+  { P8V_BUILTIN_VEC_VSUBUQM, P8V_BUILTIN_VSUBUQM,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI,\n+    RS6000_BTI_unsigned_V1TI, 0 },\n+\n   { P8V_BUILTIN_VEC_VUPKHSW, P8V_BUILTIN_VUPKHSW,\n     RS6000_BTI_V2DI, RS6000_BTI_V4SI, 0, 0 },\n   { P8V_BUILTIN_VEC_VUPKHSW, P8V_BUILTIN_VUPKHSW,\n@@ -4145,6 +4220,10 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n       unsigned_p = TYPE_UNSIGNED (type);\n       switch (TYPE_MODE (type))\n \t{\n+\t  case TImode:\n+\t    type = (unsigned_p ? unsigned_V1TI_type_node : V1TI_type_node);\n+\t    size = 1;\n+\t    break;\n \t  case DImode:\n \t    type = (unsigned_p ? unsigned_V2DI_type_node : V2DI_type_node);\n \t    size = 2;\n@@ -4232,6 +4311,14 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t  if (call)\n \t    return build_call_expr (call, 2, arg1, arg2);\n \t}\n+      else if (mode == V1TImode && VECTOR_MEM_VSX_P (mode)\n+\t       && TREE_CODE (arg2) == INTEGER_CST\n+\t       && TREE_INT_CST_HIGH (arg2) == 0\n+\t       && TREE_INT_CST_LOW (arg2) == 0)\n+\t{\n+\t  tree call = rs6000_builtin_decls[VSX_BUILTIN_VEC_EXT_V1TI];\n+\t  return build_call_expr (call, 2, arg1, arg2);\n+\t}\n \n       /* Build *(((arg1_inner_type*)&(vector type){arg1})+arg2). */\n       arg1_inner_type = TREE_TYPE (arg1_type);\n@@ -4331,6 +4418,17 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t  if (call)\n \t    return build_call_expr (call, 3, arg1, arg0, arg2);\n \t}\n+      else if (mode == V1TImode && VECTOR_UNIT_VSX_P (mode)\n+\t       && TREE_CODE (arg2) == INTEGER_CST\n+\t       && TREE_INT_CST_HIGH (arg2) == 0\n+\t       && TREE_INT_CST_LOW (arg2) == 0)\n+\t{\n+\t  tree call = rs6000_builtin_decls[VSX_BUILTIN_VEC_SET_V1TI];\n+\n+\t  /* Note, __builtin_vec_insert_<xxx> has vector and scalar types\n+\t     reversed.  */\n+\t  return build_call_expr (call, 3, arg1, arg0, arg2);\n+\t}\n \n       /* Build *(((arg1_inner_type*)&(vector type){arg1})+arg2) = arg0. */\n       arg1_inner_type = TREE_TYPE (arg1_type);"}, {"sha": "30a4dd3786e443a229da13e01f496670c1bcebf8", "filename": "gcc/config/rs6000/rs6000-modes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def?ref=a16a872d4445cd76105ad315d6cfbd066f1862be", "patch": "@@ -38,6 +38,7 @@ VECTOR_MODES (INT, 8);        /*       V8QI  V4HI V2SI */\n VECTOR_MODES (INT, 16);       /* V16QI V8HI  V4SI V2DI */\n VECTOR_MODES (INT, 32);       /* V32QI V16HI V8SI V4DI */\n VECTOR_MODE (INT, DI, 1);\n+VECTOR_MODE (INT, TI, 1);\n VECTOR_MODES (FLOAT, 8);      /*             V4HF V2SF */\n VECTOR_MODES (FLOAT, 16);     /*       V8HF  V4SF V2DF */\n VECTOR_MODES (FLOAT, 32);     /*       V16HF V8SF V4DF */"}, {"sha": "69bb26331f38a7456fdc656b1d8a5b89f625cda7", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=a16a872d4445cd76105ad315d6cfbd066f1862be", "patch": "@@ -51,6 +51,8 @@ extern rtx find_addr_reg (rtx);\n extern rtx gen_easy_altivec_constant (rtx);\n extern const char *output_vec_const_move (rtx *);\n extern const char *rs6000_output_move_128bit (rtx *);\n+extern bool rs6000_move_128bit_ok_p (rtx []);\n+extern bool rs6000_split_128bit_ok_p (rtx []);\n extern void rs6000_expand_vector_init (rtx, rtx);\n extern void paired_expand_vector_init (rtx, rtx);\n extern void rs6000_expand_vector_set (rtx, rtx, int);"}, {"sha": "036a2af3bd274d9cefaa86668fb12bde0d53bc1d", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 206, "deletions": 26, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=a16a872d4445cd76105ad315d6cfbd066f1862be", "patch": "@@ -1725,7 +1725,8 @@ rs6000_hard_regno_mode_ok (int regno, enum machine_mode mode)\n       && (VECTOR_MEM_VSX_P (mode)\n \t  || (TARGET_VSX_SCALAR_FLOAT && mode == SFmode)\n \t  || (TARGET_VSX_SCALAR_DOUBLE && (mode == DFmode || mode == DImode))\n-\t  || (TARGET_VSX_TIMODE && mode == TImode)))\n+\t  || (TARGET_VSX_TIMODE && mode == TImode)\n+\t  || (TARGET_VADDUQM && mode == V1TImode)))\n     {\n       if (FP_REGNO_P (regno))\n \treturn FP_REGNO_P (last_regno);\n@@ -1776,7 +1777,8 @@ rs6000_hard_regno_mode_ok (int regno, enum machine_mode mode)\n \n   /* AltiVec only in AldyVec registers.  */\n   if (ALTIVEC_REGNO_P (regno))\n-    return VECTOR_MEM_ALTIVEC_OR_VSX_P (mode);\n+    return (VECTOR_MEM_ALTIVEC_OR_VSX_P (mode)\n+\t    || mode == V1TImode);\n \n   /* ...but GPRs can hold SIMD data on the SPE in one register.  */\n   if (SPE_SIMD_REGNO_P (regno) && TARGET_SPE && SPE_VECTOR_MODE (mode))\n@@ -1971,10 +1973,12 @@ rs6000_debug_reg_global (void)\n     V8HImode,\n     V4SImode,\n     V2DImode,\n+    V1TImode,\n     V32QImode,\n     V16HImode,\n     V8SImode,\n     V4DImode,\n+    V2TImode,\n     V2SFmode,\n     V4SFmode,\n     V2DFmode,\n@@ -2553,6 +2557,11 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n       rs6000_vector_unit[V2DImode]\n \t= (TARGET_P8_VECTOR) ? VECTOR_P8_VECTOR : VECTOR_NONE;\n       rs6000_vector_align[V2DImode] = align64;\n+\n+      rs6000_vector_mem[V1TImode] = VECTOR_VSX;\n+      rs6000_vector_unit[V1TImode]\n+\t= (TARGET_P8_VECTOR) ? VECTOR_P8_VECTOR : VECTOR_NONE;\n+      rs6000_vector_align[V1TImode] = 128;\n     }\n \n   /* DFmode, see if we want to use the VSX unit.  */\n@@ -2676,6 +2685,8 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \t  reg_addr[V4SImode].reload_load   = CODE_FOR_reload_v4si_di_load;\n \t  reg_addr[V2DImode].reload_store  = CODE_FOR_reload_v2di_di_store;\n \t  reg_addr[V2DImode].reload_load   = CODE_FOR_reload_v2di_di_load;\n+\t  reg_addr[V1TImode].reload_store  = CODE_FOR_reload_v1ti_di_store;\n+\t  reg_addr[V1TImode].reload_load   = CODE_FOR_reload_v1ti_di_load;\n \t  reg_addr[V4SFmode].reload_store  = CODE_FOR_reload_v4sf_di_store;\n \t  reg_addr[V4SFmode].reload_load   = CODE_FOR_reload_v4sf_di_load;\n \t  reg_addr[V2DFmode].reload_store  = CODE_FOR_reload_v2df_di_store;\n@@ -2704,6 +2715,7 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \t      if (TARGET_POWERPC64)\n \t\t{\n \t\t  reg_addr[TImode].reload_gpr_vsx    = CODE_FOR_reload_gpr_from_vsxti;\n+\t\t  reg_addr[V1TImode].reload_gpr_vsx  = CODE_FOR_reload_gpr_from_vsxv1ti;\n \t\t  reg_addr[V2DFmode].reload_gpr_vsx  = CODE_FOR_reload_gpr_from_vsxv2df;\n \t\t  reg_addr[V2DImode].reload_gpr_vsx  = CODE_FOR_reload_gpr_from_vsxv2di;\n \t\t  reg_addr[V4SFmode].reload_gpr_vsx  = CODE_FOR_reload_gpr_from_vsxv4sf;\n@@ -2713,6 +2725,7 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \t\t  reg_addr[SFmode].reload_gpr_vsx    = CODE_FOR_reload_gpr_from_vsxsf;\n \n \t\t  reg_addr[TImode].reload_vsx_gpr    = CODE_FOR_reload_vsx_from_gprti;\n+\t\t  reg_addr[V1TImode].reload_vsx_gpr  = CODE_FOR_reload_vsx_from_gprv1ti;\n \t\t  reg_addr[V2DFmode].reload_vsx_gpr  = CODE_FOR_reload_vsx_from_gprv2df;\n \t\t  reg_addr[V2DImode].reload_vsx_gpr  = CODE_FOR_reload_vsx_from_gprv2di;\n \t\t  reg_addr[V4SFmode].reload_vsx_gpr  = CODE_FOR_reload_vsx_from_gprv4sf;\n@@ -2739,6 +2752,8 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \t  reg_addr[V4SImode].reload_load   = CODE_FOR_reload_v4si_si_load;\n \t  reg_addr[V2DImode].reload_store  = CODE_FOR_reload_v2di_si_store;\n \t  reg_addr[V2DImode].reload_load   = CODE_FOR_reload_v2di_si_load;\n+\t  reg_addr[V1TImode].reload_store  = CODE_FOR_reload_v1ti_si_store;\n+\t  reg_addr[V1TImode].reload_load   = CODE_FOR_reload_v1ti_si_load;\n \t  reg_addr[V4SFmode].reload_store  = CODE_FOR_reload_v4sf_si_store;\n \t  reg_addr[V4SFmode].reload_load   = CODE_FOR_reload_v4sf_si_load;\n \t  reg_addr[V2DFmode].reload_store  = CODE_FOR_reload_v2df_si_store;\n@@ -4250,6 +4265,8 @@ rs6000_preferred_simd_mode (enum machine_mode mode)\n       {\n       case SFmode:\n \treturn V4SFmode;\n+      case TImode:\n+\treturn V1TImode;\n       case DImode:\n \treturn V2DImode;\n       case SImode:\n@@ -5011,7 +5028,7 @@ vspltis_constant (rtx op, unsigned step, unsigned copies)\n   HOST_WIDE_INT splat_val;\n   HOST_WIDE_INT msb_val;\n \n-  if (mode == V2DImode || mode == V2DFmode)\n+  if (mode == V2DImode || mode == V2DFmode || mode == V1TImode)\n     return false;\n \n   nunits = GET_MODE_NUNITS (mode);\n@@ -5090,7 +5107,7 @@ easy_altivec_constant (rtx op, enum machine_mode mode)\n   if (mode == V2DFmode)\n     return zero_constant (op, mode);\n \n-  if (mode == V2DImode)\n+  else if (mode == V2DImode)\n     {\n       /* In case the compiler is built 32-bit, CONST_DOUBLE constants are not\n \t easy.  */\n@@ -5108,6 +5125,10 @@ easy_altivec_constant (rtx op, enum machine_mode mode)\n       return false;\n     }\n \n+  /* V1TImode is a special container for TImode.  Ignore for now.  */\n+  else if (mode == V1TImode)\n+    return false;\n+\n   /* Start with a vspltisw.  */\n   step = GET_MODE_NUNITS (mode) / 4;\n   copies = 1;\n@@ -5189,7 +5210,7 @@ output_vec_const_move (rtx *operands)\n       if (zero_constant (vec, mode))\n \treturn \"xxlxor %x0,%x0,%x0\";\n \n-      if (mode == V2DImode\n+      if ((mode == V2DImode || mode == V1TImode)\n \t  && INTVAL (CONST_VECTOR_ELT (vec, 0)) == -1\n \t  && INTVAL (CONST_VECTOR_ELT (vec, 1)) == -1)\n \treturn \"vspltisw %0,-1\";\n@@ -5575,6 +5596,13 @@ rs6000_expand_vector_set (rtx target, rtx val, int elt)\n       return;\n     }\n \n+  /* Simplify setting single element vectors like V1TImode.  */\n+  if (GET_MODE_SIZE (mode) == GET_MODE_SIZE (inner_mode) && elt == 0)\n+    {\n+      emit_move_insn (target, gen_lowpart (mode, val));\n+      return;\n+    }\n+\n   /* Load single variable value.  */\n   mem = assign_stack_temp (mode, GET_MODE_SIZE (inner_mode));\n   emit_move_insn (adjust_address_nv (mem, inner_mode, 0), val);\n@@ -5635,6 +5663,10 @@ rs6000_expand_vector_extract (rtx target, rtx vec, int elt)\n \t{\n \tdefault:\n \t  break;\n+\tcase V1TImode:\n+\t  gcc_assert (elt == 0 && inner_mode == TImode);\n+\t  emit_move_insn (target, gen_lowpart (TImode, vec));\n+\t  break;\n \tcase V2DFmode:\n \t  emit_insn (gen_vsx_extract_v2df (target, vec, GEN_INT (elt)));\n \t  return;\n@@ -6076,6 +6108,7 @@ reg_offset_addressing_ok_p (enum machine_mode mode)\n     case V4SImode:\n     case V2DFmode:\n     case V2DImode:\n+    case V1TImode:\n     case TImode:\n       /* AltiVec/VSX vector modes.  Only reg+reg addressing is valid.  While\n \t TImode is not a vector mode, if we want to use the VSX registers to\n@@ -7960,6 +7993,9 @@ rs6000_const_vec (enum machine_mode mode)\n \n   switch (mode)\n     {\n+    case V1TImode:\n+      subparts = 1;\n+      break;\n     case V2DFmode:\n     case V2DImode:\n       subparts = 2;\n@@ -8003,9 +8039,20 @@ rs6000_gen_le_vsx_permute (rtx source, enum machine_mode mode)\n void\n rs6000_emit_le_vsx_load (rtx dest, rtx source, enum machine_mode mode)\n {\n-  rtx tmp = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (dest) : dest;\n-  rtx permute_mem = rs6000_gen_le_vsx_permute (source, mode);\n-  rtx permute_reg = rs6000_gen_le_vsx_permute (tmp, mode);\n+  rtx tmp, permute_mem, permute_reg;\n+\n+  /* Use V2DImode to do swaps of types with 128-bit scalare parts (TImode,\n+     V1TImode).  */\n+  if (mode == TImode || mode == V1TImode)\n+    {\n+      mode = V2DImode;\n+      dest = gen_lowpart (V2DImode, dest);\n+      source = adjust_address (source, V2DImode, 0);\n+    }\n+\n+  tmp = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (dest) : dest;\n+  permute_mem = rs6000_gen_le_vsx_permute (source, mode);\n+  permute_reg = rs6000_gen_le_vsx_permute (tmp, mode);\n   emit_insn (gen_rtx_SET (VOIDmode, tmp, permute_mem));\n   emit_insn (gen_rtx_SET (VOIDmode, dest, permute_reg));\n }\n@@ -8016,9 +8063,20 @@ rs6000_emit_le_vsx_load (rtx dest, rtx source, enum machine_mode mode)\n void\n rs6000_emit_le_vsx_store (rtx dest, rtx source, enum machine_mode mode)\n {\n-  rtx tmp = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (source) : source;\n-  rtx permute_src = rs6000_gen_le_vsx_permute (source, mode);\n-  rtx permute_tmp = rs6000_gen_le_vsx_permute (tmp, mode);\n+  rtx tmp, permute_src, permute_tmp;\n+\n+  /* Use V2DImode to do swaps of types with 128-bit scalare parts (TImode,\n+     V1TImode).  */\n+  if (mode == TImode || mode == V1TImode)\n+    {\n+      mode = V2DImode;\n+      dest = adjust_address (dest, V2DImode, 0);\n+      source = gen_lowpart (V2DImode, source);\n+    }\n+\n+  tmp = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (source) : source;\n+  permute_src = rs6000_gen_le_vsx_permute (source, mode);\n+  permute_tmp = rs6000_gen_le_vsx_permute (tmp, mode);\n   emit_insn (gen_rtx_SET (VOIDmode, tmp, permute_src));\n   emit_insn (gen_rtx_SET (VOIDmode, dest, permute_tmp));\n }\n@@ -8034,7 +8092,6 @@ rs6000_emit_le_vsx_move (rtx dest, rtx source, enum machine_mode mode)\n {\n   gcc_assert (!BYTES_BIG_ENDIAN\n \t      && VECTOR_MEM_VSX_P (mode)\n-\t      && mode != TImode\n \t      && !gpr_or_gpr_p (dest, source)\n \t      && (MEM_P (source) ^ MEM_P (dest)));\n \n@@ -8318,6 +8375,7 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n     case V1DImode:\n     case V2DFmode:\n     case V2DImode:\n+    case V1TImode:\n       if (CONSTANT_P (operands[1])\n \t  && !easy_vector_constant (operands[1], mode))\n \toperands[1] = force_const_mem (mode, operands[1]);\n@@ -12403,6 +12461,8 @@ altivec_expand_ld_builtin (tree exp, rtx target, bool *expandedp)\n       break;\n     case ALTIVEC_BUILTIN_LD_INTERNAL_2di:\n       icode = CODE_FOR_vector_altivec_load_v2di;\n+    case ALTIVEC_BUILTIN_LD_INTERNAL_1ti:\n+      icode = CODE_FOR_vector_altivec_load_v1ti;\n       break;\n     default:\n       *expandedp = false;\n@@ -12462,6 +12522,8 @@ altivec_expand_st_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n       break;\n     case ALTIVEC_BUILTIN_ST_INTERNAL_2di:\n       icode = CODE_FOR_vector_altivec_store_v2di;\n+    case ALTIVEC_BUILTIN_ST_INTERNAL_1ti:\n+      icode = CODE_FOR_vector_altivec_store_v1ti;\n       break;\n     default:\n       *expandedp = false;\n@@ -12554,21 +12616,33 @@ altivec_expand_vec_init_builtin (tree type, tree exp, rtx target)\n   enum machine_mode tmode = TYPE_MODE (type);\n   enum machine_mode inner_mode = GET_MODE_INNER (tmode);\n   int i, n_elt = GET_MODE_NUNITS (tmode);\n-  rtvec v = rtvec_alloc (n_elt);\n \n   gcc_assert (VECTOR_MODE_P (tmode));\n   gcc_assert (n_elt == call_expr_nargs (exp));\n \n-  for (i = 0; i < n_elt; ++i)\n+  if (!target || !register_operand (target, tmode))\n+    target = gen_reg_rtx (tmode);\n+\n+  /* If we have a vector compromised of a single element, such as V1TImode, do\n+     the initialization directly.  */\n+  if (n_elt == 1 && GET_MODE_SIZE (tmode) == GET_MODE_SIZE (inner_mode))\n     {\n-      rtx x = expand_normal (CALL_EXPR_ARG (exp, i));\n-      RTVEC_ELT (v, i) = gen_lowpart (inner_mode, x);\n+      rtx x = expand_normal (CALL_EXPR_ARG (exp, 0));\n+      emit_move_insn (target, gen_lowpart (tmode, x));\n     }\n+  else\n+    {\n+      rtvec v = rtvec_alloc (n_elt);\n \n-  if (!target || !register_operand (target, tmode))\n-    target = gen_reg_rtx (tmode);\n+      for (i = 0; i < n_elt; ++i)\n+\t{\n+\t  rtx x = expand_normal (CALL_EXPR_ARG (exp, i));\n+\t  RTVEC_ELT (v, i) = gen_lowpart (inner_mode, x);\n+\t}\n+\n+      rs6000_expand_vector_init (target, gen_rtx_PARALLEL (tmode, v));\n+    }\n \n-  rs6000_expand_vector_init (target, gen_rtx_PARALLEL (tmode, v));\n   return target;\n }\n \n@@ -12733,6 +12807,8 @@ altivec_expand_builtin (tree exp, rtx target, bool *expandedp)\n     case ALTIVEC_BUILTIN_STVRXL:\n       return altivec_expand_stv_builtin (CODE_FOR_altivec_stvrxl, exp);\n \n+    case VSX_BUILTIN_STXVD2X_V1TI:\n+      return altivec_expand_stv_builtin (CODE_FOR_vsx_store_v1ti, exp);\n     case VSX_BUILTIN_STXVD2X_V2DF:\n       return altivec_expand_stv_builtin (CODE_FOR_vsx_store_v2df, exp);\n     case VSX_BUILTIN_STXVD2X_V2DI:\n@@ -12813,6 +12889,7 @@ altivec_expand_builtin (tree exp, rtx target, bool *expandedp)\n     case ALTIVEC_BUILTIN_VEC_INIT_V4SF:\n     case VSX_BUILTIN_VEC_INIT_V2DF:\n     case VSX_BUILTIN_VEC_INIT_V2DI:\n+    case VSX_BUILTIN_VEC_INIT_V1TI:\n       return altivec_expand_vec_init_builtin (TREE_TYPE (exp), exp, target);\n \n     case ALTIVEC_BUILTIN_VEC_SET_V4SI:\n@@ -12821,6 +12898,7 @@ altivec_expand_builtin (tree exp, rtx target, bool *expandedp)\n     case ALTIVEC_BUILTIN_VEC_SET_V4SF:\n     case VSX_BUILTIN_VEC_SET_V2DF:\n     case VSX_BUILTIN_VEC_SET_V2DI:\n+    case VSX_BUILTIN_VEC_SET_V1TI:\n       return altivec_expand_vec_set_builtin (exp);\n \n     case ALTIVEC_BUILTIN_VEC_EXT_V4SI:\n@@ -12829,6 +12907,7 @@ altivec_expand_builtin (tree exp, rtx target, bool *expandedp)\n     case ALTIVEC_BUILTIN_VEC_EXT_V4SF:\n     case VSX_BUILTIN_VEC_EXT_V2DF:\n     case VSX_BUILTIN_VEC_EXT_V2DI:\n+    case VSX_BUILTIN_VEC_EXT_V1TI:\n       return altivec_expand_vec_ext_builtin (exp, target);\n \n     default:\n@@ -12916,6 +12995,9 @@ altivec_expand_builtin (tree exp, rtx target, bool *expandedp)\n     case ALTIVEC_BUILTIN_LVRXL:\n       return altivec_expand_lv_builtin (CODE_FOR_altivec_lvrxl,\n \t\t\t\t\texp, target, true);\n+    case VSX_BUILTIN_LXVD2X_V1TI:\n+      return altivec_expand_lv_builtin (CODE_FOR_vsx_load_v1ti,\n+\t\t\t\t\texp, target, false);\n     case VSX_BUILTIN_LXVD2X_V2DF:\n       return altivec_expand_lv_builtin (CODE_FOR_vsx_load_v2df,\n \t\t\t\t\texp, target, false);\n@@ -13640,6 +13722,14 @@ rs6000_init_builtins (void)\n   opaque_p_V2SI_type_node = build_pointer_type (opaque_V2SI_type_node);\n   opaque_V4SI_type_node = build_opaque_vector_type (intSI_type_node, 4);\n \n+  /* We use V1TI mode as a special container to hold __int128_t items that\n+     must live in VSX registers.  */\n+  if (intTI_type_node)\n+    {\n+      V1TI_type_node = build_vector_type (intTI_type_node, 1);\n+      unsigned_V1TI_type_node = build_vector_type (unsigned_intTI_type_node, 1);\n+    }\n+\n   /* The 'vector bool ...' types must be kept distinct from 'vector unsigned ...'\n      types, especially in C++ land.  Similarly, 'vector pixel' is distinct from\n      'vector unsigned short'.  */\n@@ -13662,6 +13752,8 @@ rs6000_init_builtins (void)\n   uintSI_type_internal_node = unsigned_intSI_type_node;\n   intDI_type_internal_node = intDI_type_node;\n   uintDI_type_internal_node = unsigned_intDI_type_node;\n+  intTI_type_internal_node = intTI_type_node;\n+  uintTI_type_internal_node = unsigned_intTI_type_node;\n   float_type_internal_node = float_type_node;\n   double_type_internal_node = double_type_node;\n   void_type_internal_node = void_type_node;\n@@ -13674,8 +13766,12 @@ rs6000_init_builtins (void)\n   builtin_mode_to_type[SImode][1] = unsigned_intSI_type_node;\n   builtin_mode_to_type[DImode][0] = intDI_type_node;\n   builtin_mode_to_type[DImode][1] = unsigned_intDI_type_node;\n+  builtin_mode_to_type[TImode][0] = intTI_type_node;\n+  builtin_mode_to_type[TImode][1] = unsigned_intTI_type_node;\n   builtin_mode_to_type[SFmode][0] = float_type_node;\n   builtin_mode_to_type[DFmode][0] = double_type_node;\n+  builtin_mode_to_type[V1TImode][0] = V1TI_type_node;\n+  builtin_mode_to_type[V1TImode][1] = unsigned_V1TI_type_node;\n   builtin_mode_to_type[V2SImode][0] = V2SI_type_node;\n   builtin_mode_to_type[V2SFmode][0] = V2SF_type_node;\n   builtin_mode_to_type[V2DImode][0] = V2DI_type_node;\n@@ -13744,14 +13840,41 @@ rs6000_init_builtins (void)\n   tdecl = add_builtin_type (\"__vector double\", V2DF_type_node);\n   TYPE_NAME (V2DF_type_node) = tdecl;\n \n-  tdecl = add_builtin_type (\"__vector long\", V2DI_type_node);\n-  TYPE_NAME (V2DI_type_node) = tdecl;\n+  if (TARGET_POWERPC64)\n+    {\n+      tdecl = add_builtin_type (\"__vector long\", V2DI_type_node);\n+      TYPE_NAME (V2DI_type_node) = tdecl;\n+\n+      tdecl = add_builtin_type (\"__vector unsigned long\",\n+\t\t\t\tunsigned_V2DI_type_node);\n+      TYPE_NAME (unsigned_V2DI_type_node) = tdecl;\n \n-  tdecl = add_builtin_type (\"__vector unsigned long\", unsigned_V2DI_type_node);\n-  TYPE_NAME (unsigned_V2DI_type_node) = tdecl;\n+      tdecl = add_builtin_type (\"__vector __bool long\", bool_V2DI_type_node);\n+      TYPE_NAME (bool_V2DI_type_node) = tdecl;\n+    }\n+  else\n+    {\n+      tdecl = add_builtin_type (\"__vector long long\", V2DI_type_node);\n+      TYPE_NAME (V2DI_type_node) = tdecl;\n \n-  tdecl = add_builtin_type (\"__vector __bool long\", bool_V2DI_type_node);\n-  TYPE_NAME (bool_V2DI_type_node) = tdecl;\n+      tdecl = add_builtin_type (\"__vector unsigned long long\",\n+\t\t\t\tunsigned_V2DI_type_node);\n+      TYPE_NAME (unsigned_V2DI_type_node) = tdecl;\n+\n+      tdecl = add_builtin_type (\"__vector __bool long long\",\n+\t\t\t\tbool_V2DI_type_node);\n+      TYPE_NAME (bool_V2DI_type_node) = tdecl;\n+    }\n+\n+  if (V1TI_type_node)\n+    {\n+      tdecl = add_builtin_type (\"__vector __int128\", V1TI_type_node);\n+      TYPE_NAME (V1TI_type_node) = tdecl;\n+\n+      tdecl = add_builtin_type (\"__vector unsigned __int128\",\n+\t\t\t\tunsigned_V1TI_type_node);\n+      TYPE_NAME (unsigned_V1TI_type_node) = tdecl;\n+    }\n \n   /* Paired and SPE builtins are only available if you build a compiler with\n      the appropriate options, so only create those builtins with the\n@@ -14560,6 +14683,34 @@ altivec_init_builtins (void)\n   ftype = build_function_type_list (intDI_type_node, V2DI_type_node,\n \t\t\t\t    integer_type_node, NULL_TREE);\n   def_builtin (\"__builtin_vec_ext_v2di\", ftype, VSX_BUILTIN_VEC_EXT_V2DI);\n+\n+\n+  if (V1TI_type_node)\n+    {\n+      tree v1ti_ftype_long_pcvoid\n+\t= build_function_type_list (V1TI_type_node,\n+\t\t\t\t    long_integer_type_node, pcvoid_type_node,\n+\t\t\t\t    NULL_TREE);\n+      tree void_ftype_v1ti_long_pvoid\n+\t= build_function_type_list (void_type_node,\n+\t\t\t\t    V1TI_type_node, long_integer_type_node,\n+\t\t\t\t    pvoid_type_node, NULL_TREE);\n+      def_builtin (\"__builtin_vsx_lxvd2x_v1ti\", v1ti_ftype_long_pcvoid,\n+\t\t   VSX_BUILTIN_LXVD2X_V1TI);\n+      def_builtin (\"__builtin_vsx_stxvd2x_v1ti\", void_ftype_v1ti_long_pvoid,\n+\t\t   VSX_BUILTIN_STXVD2X_V1TI);\n+      ftype = build_function_type_list (V1TI_type_node, intTI_type_node,\n+\t\t\t\t\tNULL_TREE, NULL_TREE);\n+      def_builtin (\"__builtin_vec_init_v1ti\", ftype, VSX_BUILTIN_VEC_INIT_V1TI);\n+      ftype = build_function_type_list (V1TI_type_node, V1TI_type_node,\n+\t\t\t\t\tintTI_type_node,\n+\t\t\t\t\tinteger_type_node, NULL_TREE);\n+      def_builtin (\"__builtin_vec_set_v1ti\", ftype, VSX_BUILTIN_VEC_SET_V1TI);\n+      ftype = build_function_type_list (intTI_type_node, V1TI_type_node,\n+\t\t\t\t\tinteger_type_node, NULL_TREE);\n+      def_builtin (\"__builtin_vec_ext_v1ti\", ftype, VSX_BUILTIN_VEC_EXT_V1TI);\n+    }\n+\n }\n \n static void\n@@ -16772,7 +16923,8 @@ rs6000_preferred_reload_class (rtx x, enum reg_class rclass)\n       if (GET_MODE_SIZE (mode) <= 8)\n \treturn FLOAT_REGS;\n \n-      if (VECTOR_UNIT_ALTIVEC_P (mode) || VECTOR_MEM_ALTIVEC_P (mode))\n+      if (VECTOR_UNIT_ALTIVEC_P (mode) || VECTOR_MEM_ALTIVEC_P (mode)\n+\t  || mode == V1TImode)\n \treturn ALTIVEC_REGS;\n \n       return rclass;\n@@ -17209,6 +17361,31 @@ rs6000_output_move_128bit (rtx operands[])\n   gcc_unreachable ();\n }\n \n+/* Validate a 128-bit move.  */\n+bool\n+rs6000_move_128bit_ok_p (rtx operands[])\n+{\n+  enum machine_mode mode = GET_MODE (operands[0]);\n+  return (gpc_reg_operand (operands[0], mode)\n+\t  || gpc_reg_operand (operands[1], mode));\n+}\n+\n+/* Return true if a 128-bit move needs to be split.  */\n+bool\n+rs6000_split_128bit_ok_p (rtx operands[])\n+{\n+  if (!reload_completed)\n+    return false;\n+\n+  if (!gpr_or_gpr_p (operands[0], operands[1]))\n+    return false;\n+\n+  if (quad_load_store_p (operands[0], operands[1]))\n+    return false;\n+\n+  return true;\n+}\n+\n \f\n /* Given a comparison operation, return the bit number in CCR to test.  We\n    know this is a valid comparison.\n@@ -27796,6 +27973,9 @@ rs6000_handle_altivec_attribute (tree *node,\n       unsigned_p = TYPE_UNSIGNED (type);\n       switch (mode)\n \t{\n+\tcase TImode:\n+\t  result = (unsigned_p ? unsigned_V1TI_type_node : V1TI_type_node);\n+\t  break;\n \tcase DImode:\n \t  result = (unsigned_p ? unsigned_V2DI_type_node : V2DI_type_node);\n \t  break;"}, {"sha": "a6afb6c3750ddec40d70e614272c97d8fec7a365", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=a16a872d4445cd76105ad315d6cfbd066f1862be", "patch": "@@ -529,6 +529,7 @@ extern int rs6000_vector_align[];\n \n #define TARGET_XSCVDPSPN\t(TARGET_DIRECT_MOVE || TARGET_P8_VECTOR)\n #define TARGET_XSCVSPDPN\t(TARGET_DIRECT_MOVE || TARGET_P8_VECTOR)\n+#define TARGET_VADDUQM\t\t(TARGET_P8_VECTOR && TARGET_POWERPC64)\n \n /* Byte/char syncs were added as phased in for ISA 2.06B, but are not present\n    in power7, so conditionalize them on p8 features.  TImode syncs need quad\n@@ -1194,7 +1195,7 @@ enum data_align { align_abi, align_opt, align_both };\n \n #define ALTIVEC_OR_VSX_VECTOR_MODE(MODE)\t\t\t\t\\\n   (ALTIVEC_VECTOR_MODE (MODE) || VSX_VECTOR_MODE (MODE)\t\t\t\\\n-   || (MODE) == V2DImode)\n+   || (MODE) == V2DImode || (MODE) == V1TImode)\n \n #define SPE_VECTOR_MODE(MODE)\t\t\\\n \t((MODE) == V4HImode          \t\\\n@@ -2577,6 +2578,7 @@ enum rs6000_builtin_type_index\n   RS6000_BTI_opaque_p_V2SI,\n   RS6000_BTI_opaque_V4SI,\n   RS6000_BTI_V16QI,\n+  RS6000_BTI_V1TI,\n   RS6000_BTI_V2SI,\n   RS6000_BTI_V2SF,\n   RS6000_BTI_V2DI,\n@@ -2586,6 +2588,7 @@ enum rs6000_builtin_type_index\n   RS6000_BTI_V4SF,\n   RS6000_BTI_V8HI,\n   RS6000_BTI_unsigned_V16QI,\n+  RS6000_BTI_unsigned_V1TI,\n   RS6000_BTI_unsigned_V8HI,\n   RS6000_BTI_unsigned_V4SI,\n   RS6000_BTI_unsigned_V2DI,\n@@ -2611,6 +2614,8 @@ enum rs6000_builtin_type_index\n   RS6000_BTI_UINTSI,\t\t /* unsigned_intSI_type_node */\n   RS6000_BTI_INTDI,\t\t /* intDI_type_node */\n   RS6000_BTI_UINTDI,\t\t /* unsigned_intDI_type_node */\n+  RS6000_BTI_INTTI,\t\t /* intTI_type_node */\n+  RS6000_BTI_UINTTI,\t\t /* unsigned_intTI_type_node */\n   RS6000_BTI_float,\t         /* float_type_node */\n   RS6000_BTI_double,\t         /* double_type_node */\n   RS6000_BTI_void,\t         /* void_type_node */\n@@ -2623,6 +2628,7 @@ enum rs6000_builtin_type_index\n #define opaque_p_V2SI_type_node       (rs6000_builtin_types[RS6000_BTI_opaque_p_V2SI])\n #define opaque_V4SI_type_node         (rs6000_builtin_types[RS6000_BTI_opaque_V4SI])\n #define V16QI_type_node               (rs6000_builtin_types[RS6000_BTI_V16QI])\n+#define V1TI_type_node                (rs6000_builtin_types[RS6000_BTI_V1TI])\n #define V2DI_type_node                (rs6000_builtin_types[RS6000_BTI_V2DI])\n #define V2DF_type_node                (rs6000_builtin_types[RS6000_BTI_V2DF])\n #define V2SI_type_node                (rs6000_builtin_types[RS6000_BTI_V2SI])\n@@ -2632,6 +2638,7 @@ enum rs6000_builtin_type_index\n #define V4SF_type_node                (rs6000_builtin_types[RS6000_BTI_V4SF])\n #define V8HI_type_node                (rs6000_builtin_types[RS6000_BTI_V8HI])\n #define unsigned_V16QI_type_node      (rs6000_builtin_types[RS6000_BTI_unsigned_V16QI])\n+#define unsigned_V1TI_type_node       (rs6000_builtin_types[RS6000_BTI_unsigned_V1TI])\n #define unsigned_V8HI_type_node       (rs6000_builtin_types[RS6000_BTI_unsigned_V8HI])\n #define unsigned_V4SI_type_node       (rs6000_builtin_types[RS6000_BTI_unsigned_V4SI])\n #define unsigned_V2DI_type_node       (rs6000_builtin_types[RS6000_BTI_unsigned_V2DI])\n@@ -2658,6 +2665,8 @@ enum rs6000_builtin_type_index\n #define uintSI_type_internal_node\t (rs6000_builtin_types[RS6000_BTI_UINTSI])\n #define intDI_type_internal_node\t (rs6000_builtin_types[RS6000_BTI_INTDI])\n #define uintDI_type_internal_node\t (rs6000_builtin_types[RS6000_BTI_UINTDI])\n+#define intTI_type_internal_node\t (rs6000_builtin_types[RS6000_BTI_INTTI])\n+#define uintTI_type_internal_node\t (rs6000_builtin_types[RS6000_BTI_UINTTI])\n #define float_type_internal_node\t (rs6000_builtin_types[RS6000_BTI_float])\n #define double_type_internal_node\t (rs6000_builtin_types[RS6000_BTI_double])\n #define void_type_internal_node\t\t (rs6000_builtin_types[RS6000_BTI_void])"}, {"sha": "4bab9591e9f4bb77557e14c3691f8c253288d201", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=a16a872d4445cd76105ad315d6cfbd066f1862be", "patch": "@@ -288,7 +288,8 @@\n \t\t\t\t    (V4SI  \"\")\n \t\t\t\t    (V4SF  \"\")\n \t\t\t\t    (V2DI  \"\")\n-\t\t\t\t    (V2DF  \"\")])\n+\t\t\t\t    (V2DF  \"\")\n+\t\t\t\t    (V1TI  \"\")])\n \n ; Whether a floating point move is ok, don't allow SD without hardware FP\n (define_mode_attr fmove_ok [(SF \"\")\n@@ -412,7 +413,8 @@\n \t\t\t\t\t (V4SI\t\"TARGET_ALTIVEC\")\n \t\t\t\t\t (V4SF\t\"TARGET_ALTIVEC\")\n \t\t\t\t\t (V2DI\t\"TARGET_ALTIVEC\")\n-\t\t\t\t\t (V2DF\t\"TARGET_ALTIVEC\")])\n+\t\t\t\t\t (V2DF\t\"TARGET_ALTIVEC\")\n+\t\t\t\t\t (V1TI  \"TARGET_ALTIVEC\")])\n \n ;; For the GPRs we use 3 constraints for register outputs, two that are the\n ;; same as the output register, and a third where the output register is an\n@@ -428,7 +430,8 @@\n \t\t\t\t\t (V4SI\t\"wa,v,&?r,?r,?r\")\n \t\t\t\t\t (V4SF\t\"wa,v,&?r,?r,?r\")\n \t\t\t\t\t (V2DI\t\"wa,v,&?r,?r,?r\")\n-\t\t\t\t\t (V2DF\t\"wa,v,&?r,?r,?r\")])\n+\t\t\t\t\t (V2DF\t\"wa,v,&?r,?r,?r\")\n+\t\t\t\t\t (V1TI\t\"wa,v,&?r,?r,?r\")])\n \n ;; Mode attribute for boolean operation register constraints for operand1\n (define_mode_attr BOOL_REGS_OP1\t\t[(TI\t\"r,0,r,wa,v\")\n@@ -438,7 +441,8 @@\n \t\t\t\t\t (V4SI\t\"wa,v,r,0,r\")\n \t\t\t\t\t (V4SF\t\"wa,v,r,0,r\")\n \t\t\t\t\t (V2DI\t\"wa,v,r,0,r\")\n-\t\t\t\t\t (V2DF\t\"wa,v,r,0,r\")])\n+\t\t\t\t\t (V2DF\t\"wa,v,r,0,r\")\n+\t\t\t\t\t (V1TI\t\"wa,v,r,0,r\")])\n \n ;; Mode attribute for boolean operation register constraints for operand2\n (define_mode_attr BOOL_REGS_OP2\t\t[(TI\t\"r,r,0,wa,v\")\n@@ -448,7 +452,8 @@\n \t\t\t\t\t (V4SI\t\"wa,v,r,r,0\")\n \t\t\t\t\t (V4SF\t\"wa,v,r,r,0\")\n \t\t\t\t\t (V2DI\t\"wa,v,r,r,0\")\n-\t\t\t\t\t (V2DF\t\"wa,v,r,r,0\")])\n+\t\t\t\t\t (V2DF\t\"wa,v,r,r,0\")\n+\t\t\t\t\t (V1TI\t\"wa,v,r,r,0\")])\n \n ;; Mode attribute for boolean operation register constraints for operand1\n ;; for one_cmpl.  To simplify things, we repeat the constraint where 0\n@@ -460,7 +465,8 @@\n \t\t\t\t\t (V4SI\t\"wa,v,r,0,0\")\n \t\t\t\t\t (V4SF\t\"wa,v,r,0,0\")\n \t\t\t\t\t (V2DI\t\"wa,v,r,0,0\")\n-\t\t\t\t\t (V2DF\t\"wa,v,r,0,0\")])\n+\t\t\t\t\t (V2DF\t\"wa,v,r,0,0\")\n+\t\t\t\t\t (V1TI\t\"wa,v,r,0,0\")])\n \n ;; Mode attribute for the clobber of CC0 for AND expansion.\n ;; For the 128-bit types, we never do AND immediate, but we need to\n@@ -472,7 +478,8 @@\n \t\t\t\t\t (V4SI\t\"X,X,X,X,X\")\n \t\t\t\t\t (V4SF\t\"X,X,X,X,X\")\n \t\t\t\t\t (V2DI\t\"X,X,X,X,X\")\n-\t\t\t\t\t (V2DF\t\"X,X,X,X,X\")])\n+\t\t\t\t\t (V2DF\t\"X,X,X,X,X\")\n+\t\t\t\t\t (V1TI\t\"X,X,X,X,X\")])\n \n \f\n ;; Start with fixed-point load and store insns.  Here we put only the more"}, {"sha": "edbb83161d142b1a562735635fe90ef65b09fbbf", "filename": "gcc/config/rs6000/vector.md", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Fconfig%2Frs6000%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Fconfig%2Frs6000%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvector.md?ref=a16a872d4445cd76105ad315d6cfbd066f1862be", "patch": "@@ -36,13 +36,13 @@\n (define_mode_iterator VEC_K [V16QI V8HI V4SI V4SF])\n \n ;; Vector logical modes\n-(define_mode_iterator VEC_L [V16QI V8HI V4SI V2DI V4SF V2DF TI])\n+(define_mode_iterator VEC_L [V16QI V8HI V4SI V2DI V4SF V2DF V1TI TI])\n \n ;; Vector modes for moves.  Don't do TImode here.\n-(define_mode_iterator VEC_M [V16QI V8HI V4SI V2DI V4SF V2DF])\n+(define_mode_iterator VEC_M [V16QI V8HI V4SI V2DI V4SF V2DF V1TI])\n \n ;; Vector modes for types that don't need a realignment under VSX\n-(define_mode_iterator VEC_N [V4SI V4SF V2DI V2DF])\n+(define_mode_iterator VEC_N [V4SI V4SF V2DI V2DF V1TI])\n \n ;; Vector comparison modes\n (define_mode_iterator VEC_C [V16QI V8HI V4SI V2DI V4SF V2DF])\n@@ -54,7 +54,8 @@\n (define_mode_iterator VEC_64 [V2DI V2DF])\n \n ;; Vector reload iterator\n-(define_mode_iterator VEC_R [V16QI V8HI V4SI V2DI V4SF V2DF SF SD SI DF DD DI TI])\n+(define_mode_iterator VEC_R [V16QI V8HI V4SI V2DI V4SF V2DF V1TI\n+\t\t\t     SF SD SI DF DD DI TI])\n \n ;; Base type from vector mode\n (define_mode_attr VEC_base [(V16QI \"QI\")\n@@ -63,6 +64,7 @@\n \t\t\t    (V2DI  \"DI\")\n \t\t\t    (V4SF  \"SF\")\n \t\t\t    (V2DF  \"DF\")\n+\t\t\t    (V1TI  \"TI\")\n \t\t\t    (TI    \"TI\")])\n \n ;; Same size integer type for floating point data\n@@ -107,7 +109,6 @@\n     }\n   if (!BYTES_BIG_ENDIAN\n       && VECTOR_MEM_VSX_P (<MODE>mode)\n-      && <MODE>mode != TImode\n       && !gpr_or_gpr_p (operands[0], operands[1])\n       && (memory_operand (operands[0], <MODE>mode)\n           ^ memory_operand (operands[1], <MODE>mode)))"}, {"sha": "93c8c3b2928f96547561a323d62e4c464e33d433", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=a16a872d4445cd76105ad315d6cfbd066f1862be", "patch": "@@ -34,18 +34,19 @@\n (define_mode_iterator VSX_F [V4SF V2DF])\n \n ;; Iterator for logical types supported by VSX\n-(define_mode_iterator VSX_L [V16QI V8HI V4SI V2DI V4SF V2DF TI])\n+(define_mode_iterator VSX_L [V16QI V8HI V4SI V2DI V4SF V2DF V1TI TI])\n \n ;; Iterator for memory move.  Handle TImode specially to allow\n ;; it to use gprs as well as vsx registers.\n-(define_mode_iterator VSX_M [V16QI V8HI V4SI V2DI V4SF V2DF])\n+(define_mode_iterator VSX_M [V16QI V8HI V4SI V2DI V4SF V2DF V1TI])\n \n (define_mode_iterator VSX_M2 [V16QI\n \t\t\t      V8HI\n \t\t\t      V4SI\n \t\t\t      V2DI\n \t\t\t      V4SF\n \t\t\t      V2DF\n+\t\t\t      V1TI\n \t\t\t      (TI\t\"TARGET_VSX_TIMODE\")])\n \n ;; Map into the appropriate load/store name based on the type\n@@ -56,6 +57,7 @@\n \t\t\t(V2DF  \"vd2\")\n \t\t\t(V2DI  \"vd2\")\n \t\t\t(DF    \"d\")\n+\t\t\t(V1TI  \"vd2\")\n \t\t\t(TI    \"vd2\")])\n \n ;; Map into the appropriate suffix based on the type\n@@ -67,6 +69,7 @@\n \t\t\t (V2DI  \"dp\")\n \t\t\t (DF    \"dp\")\n \t\t\t (SF\t\"sp\")\n+\t\t\t (V1TI  \"dp\")\n \t\t\t (TI    \"dp\")])\n \n ;; Map the register class used\n@@ -78,6 +81,7 @@\n \t\t\t (V2DF  \"wd\")\n \t\t\t (DF    \"ws\")\n \t\t\t (SF\t\"d\")\n+\t\t\t (V1TI  \"v\")\n \t\t\t (TI    \"wt\")])\n \n ;; Map the register class used for float<->int conversions\n@@ -123,6 +127,7 @@\n \t\t\t (V4SF  \"v\")\n \t\t\t (V2DI  \"v\")\n \t\t\t (V2DF  \"v\")\n+\t\t\t (V1TI  \"v\")\n \t\t\t (DF    \"s\")])\n \n ;; Appropriate type for add ops (and other simple FP ops)\n@@ -180,7 +185,8 @@\n \t\t\t\t(V2DF\t\"vecdouble\")])\n \n ;; Map the scalar mode for a vector type\n-(define_mode_attr VS_scalar [(V2DF\t\"DF\")\n+(define_mode_attr VS_scalar [(V1TI\t\"TI\")\n+\t\t\t     (V2DF\t\"DF\")\n \t\t\t     (V2DI\t\"DI\")\n \t\t\t     (V4SF\t\"SF\")\n \t\t\t     (V4SI\t\"SI\")\n@@ -191,7 +197,8 @@\n (define_mode_attr VS_double [(V4SI\t\"V8SI\")\n \t\t\t     (V4SF\t\"V8SF\")\n \t\t\t     (V2DI\t\"V4DI\")\n-\t\t\t     (V2DF\t\"V4DF\")])\n+\t\t\t     (V2DF\t\"V4DF\")\n+\t\t\t     (V1TI\t\"V2TI\")])\n \n ;; Constants for creating unspecs\n (define_c_enum \"unspec\"\n@@ -1489,6 +1496,21 @@\n   \"stxvd2x %x1,%y0\"\n   [(set_attr \"type\" \"vecstore\")])\n \n+;; Convert a TImode value into V1TImode\n+(define_expand \"vsx_set_v1ti\"\n+  [(match_operand:V1TI 0 \"nonimmediate_operand\" \"\")\n+   (match_operand:V1TI 1 \"nonimmediate_operand\" \"\")\n+   (match_operand:TI 2 \"input_operand\" \"\")\n+   (match_operand:QI 3 \"u5bit_cint_operand\" \"\")]\n+  \"VECTOR_MEM_VSX_P (V1TImode)\"\n+{\n+  if (operands[3] != const0_rtx)\n+    gcc_unreachable ();\n+\n+  emit_move_insn (operands[0], gen_lowpart (V1TImode, operands[1]));\n+  DONE;\n+})\n+\n ;; Set the element of a V2DI/VD2F mode\n (define_insn \"vsx_set_<mode>\"\n   [(set (match_operand:VSX_D 0 \"vsx_register_operand\" \"=wd,?wa\")"}, {"sha": "986cc94e360ea029710578825f639841d5b46c6b", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=a16a872d4445cd76105ad315d6cfbd066f1862be", "patch": "@@ -15127,6 +15127,51 @@ vector long long vec_vupklsw (vector int);\n vector unsigned long long vec_vupklsw (vector int);\n @end smallexample\n \n+If the ISA 2.07 additions to the vector/scalar (power8-vector)\n+instruction set is available, the following additional functions are\n+available for 64-bit targets.  New vector types\n+(@var{vector __int128_t} and @var{vector __uint128_t}) are available\n+to hold the @var{__int128_t} and @var{__uint128_t} types to use these\n+builtins.\n+\n+The normal vector extract, and set operations work on\n+@var{vector __int128_t} and @var{vector __uint128_t} types,\n+but the index value must be 0.\n+\n+@smallexample\n+vector __int128_t vec_vaddcuq (vector __int128_t, vector __int128_t);\n+vector __uint128_t vec_vaddcuq (vector __uint128_t, vector __uint128_t);\n+\n+vector __int128_t vec_vadduqm (vector __int128_t, vector __int128_t);\n+vector __uint128_t vec_vadduqm (vector __uint128_t, vector __uint128_t);\n+\n+vector __int128_t vec_vaddecuq (vector __int128_t, vector __int128_t,\n+                                vector __int128_t);\n+vector __uint128_t vec_vaddecuq (vector __uint128_t, vector __uint128_t, \n+                                 vector __uint128_t);\n+\n+vector __int128_t vec_vaddeuqm (vector __int128_t, vector __int128_t,\n+                                vector __int128_t);\n+vector __uint128_t vec_vaddeuqm (vector __uint128_t, vector __uint128_t, \n+                                 vector __uint128_t);\n+\n+vector __int128_t vec_vsubecuq (vector __int128_t, vector __int128_t,\n+                                vector __int128_t);\n+vector __uint128_t vec_vsubecuq (vector __uint128_t, vector __uint128_t, \n+                                 vector __uint128_t);\n+\n+vector __int128_t vec_vsubeuqm (vector __int128_t, vector __int128_t,\n+                                vector __int128_t);\n+vector __uint128_t vec_vsubeuqm (vector __uint128_t, vector __uint128_t,\n+                                 vector __uint128_t);\n+\n+vector __int128_t vec_vsubcuq (vector __int128_t, vector __int128_t);\n+vector __uint128_t vec_vsubcuq (vector __uint128_t, vector __uint128_t);\n+\n+__int128_t vec_vsubuqm (__int128_t, __int128_t);\n+__uint128_t vec_vsubuqm (__uint128_t, __uint128_t);\n+@end smallexample\n+\n If the cryptographic instructions are enabled (@option{-mcrypto} or\n @option{-mcpu=power8}), the following builtins are enabled.\n "}, {"sha": "38910704d3edd8accd02dbcd4678e951f23da015", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a16a872d4445cd76105ad315d6cfbd066f1862be", "patch": "@@ -1,3 +1,16 @@\n+2014-03-12  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/p8vector-int128-1.c: New test to test ISA\n+\t2.07 128-bit arithmetic.\n+\t* gcc.target/powerpc/p8vector-int128-2.c: Likewise.\n+\n+\t* gcc.target/powerpc/timode_off.c: Restrict cpu type to power5,\n+\tdue to when TImode is allowed in VSX registers, the allowable\n+\taddress modes for TImode is just a single indirect address in\n+\torder for the value to be loaded and store in either GPR or VSX\n+\tregisters.  This affects the generated code, and it would cause\n+\tthis test to fail, when such an option is used.\n+\n 2014-03-12  Marcus Shawcroft  <marcus.shawcroft@arm.com>\n \n \t* lib/profopt.exp (profopt-execute): Use $testcase in"}, {"sha": "86bde32419c55230d0f512bf0f9d11fb137cb8cc", "filename": "gcc/testsuite/gcc.target/powerpc/p8vector-int128-1.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp8vector-int128-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp8vector-int128-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp8vector-int128-1.c?ref=a16a872d4445cd76105ad315d6cfbd066f1862be", "patch": "@@ -0,0 +1,85 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-options \"-mcpu=power8 -O3 -mvsx-timode\" } */\n+\n+#include <altivec.h>\n+\n+#ifndef TYPE\n+#define TYPE vector __int128_t\n+#endif\n+\n+TYPE\n+do_addcuq (TYPE p, TYPE q)\n+{\n+  return __builtin_vec_vaddcuq (p, q);\n+}\n+\n+TYPE\n+do_adduqm (TYPE p, TYPE q)\n+{\n+  return __builtin_vec_add (p, q);\n+}\n+\n+TYPE\n+do_addeuqm (TYPE p, TYPE q, TYPE r)\n+{\n+  return __builtin_vec_vaddeuqm (p, q, r);\n+}\n+\n+TYPE\n+do_addecuq (TYPE p, TYPE q, TYPE r)\n+{\n+  return __builtin_vec_vaddecuq (p, q, r);\n+}\n+\n+TYPE\n+do_subeuqm (TYPE p, TYPE q, TYPE r)\n+{\n+  return __builtin_vec_vsubeuqm (p, q, r);\n+}\n+\n+TYPE\n+do_subecuq (TYPE p, TYPE q, TYPE r)\n+{\n+  return __builtin_vec_vsubecuq (p, q, r);\n+}\n+\n+TYPE\n+do_subcuq (TYPE p, TYPE q)\n+{\n+  return __builtin_vec_vsubcuq (p, q);\n+}\n+\n+TYPE\n+do_subuqm (TYPE p, TYPE q)\n+{\n+  return __builtin_vec_vsubuqm (p, q);\n+}\n+\n+TYPE\n+do_zero (void)\n+{\n+  return (TYPE) { 0 };\n+}\n+\n+TYPE\n+do_minus_one (void)\n+{\n+  return (TYPE) { -1 };\n+}\n+\n+/* { dg-final { scan-assembler\t   \"vaddcuq\"   } } */\n+/* { dg-final { scan-assembler\t   \"vadduqm\"   } } */\n+/* { dg-final { scan-assembler\t   \"vaddecuq\"  } } */\n+/* { dg-final { scan-assembler\t   \"vaddeuqm\"  } } */\n+/* { dg-final { scan-assembler\t   \"vsubecuq\"  } } */\n+/* { dg-final { scan-assembler\t   \"vsubeuqm\"  } } */\n+/* { dg-final { scan-assembler\t   \"vsubcuq\"   } } */\n+/* { dg-final { scan-assembler\t   \"vsubuqm\"   } } */\n+/* { dg-final { scan-assembler-not \"mtvsrd\"    } } */\n+/* { dg-final { scan-assembler-not \"mfvsrd\"    } } */\n+/* { dg-final { scan-assembler-not \"ori 2,2,0\" } } */\n+/* { dg-final { scan-assembler-not \"xxpermdi\"  } } */\n+/* { dg-final { scan-assembler-not \"stxvd2x\"   } } */\n+/* { dg-final { scan-assembler-not \"stxvw4x\"   } } */"}, {"sha": "1064894dc4cde25862abea751f100d30257cb564", "filename": "gcc/testsuite/gcc.target/powerpc/p8vector-int128-2.c", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp8vector-int128-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp8vector-int128-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp8vector-int128-2.c?ref=a16a872d4445cd76105ad315d6cfbd066f1862be", "patch": "@@ -0,0 +1,177 @@\n+/* { dg-do run { target { powerpc*-*-linux* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-skip-if \"\" { powerpc*-*-*spe* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target p8vector_hw } */\n+/* { dg-options \"-mcpu=power8 -O2\" } */\n+\n+#include <stddef.h>\n+#include <stdlib.h>\n+#include <altivec.h>\n+\n+#ifdef DEBUG\n+#include <stdio.h>\n+#define UNUSED\n+\n+#ifdef __LITTLE_ENDIAN__\n+#define HI_WORD 1\n+#define LO_WORD 0\n+#else\n+#define HI_WORD 0\n+#define LO_WORD 1\n+#endif\n+\n+#else\n+#define UNUSED __attribute__((__unused__))\n+#endif\n+\n+#ifndef S_TYPE\n+#define S_TYPE __uint128_t\n+#endif\n+\n+#ifndef V_TYPE\n+#define V_TYPE vector S_TYPE\n+#endif\n+\n+static int compare (S_TYPE, V_TYPE, const char *, const char *)\n+  __attribute__((__noinline__));\n+\n+static int\n+compare (S_TYPE scalar,\n+\t V_TYPE vect,\n+\t const char *nl    UNUSED,\n+\t const char *which UNUSED)\n+{\n+  unsigned long scalar_lo = (unsigned long) scalar;\n+  unsigned long scalar_hi = (unsigned long) (scalar >> 64);\n+  unsigned long vect_lo;\n+  unsigned long vect_hi;\n+  vector long long tmp;\n+  int ret;\n+\n+  __asm__ (\"mfvsrd %0,%x3\\n\\t\"\n+\t   \"xxpermdi %x2,%x3,%x3,3\\n\\t\"\n+\t   \"mfvsrd %1,%x2\"\n+\t   : \"=r\" (vect_hi),\n+\t     \"=r\" (vect_lo),\n+\t     \"=wa\" (tmp)\n+\t   : \"wa\" (vect));\n+\n+  ret = (scalar_lo != vect_lo) || (scalar_hi != vect_hi);\n+\n+#ifdef DEBUG\n+  printf (\"%s%s: 0x%.16lx %.16lx %s 0x%.16lx %.16lx\\n\",\n+\t  nl, which,\n+\t  scalar_hi, scalar_lo,\n+\t  (ret) ? \"!=\" : \"==\",\n+\t  vect_hi, vect_lo);\n+\n+  fflush (stdout);\n+#endif\n+\n+  return ret;\n+}\n+\n+static void convert_via_mem (V_TYPE *, S_TYPE *)\n+  __attribute__((__noinline__));\n+\n+static void\n+convert_via_mem (V_TYPE *v, S_TYPE *s)\n+{\n+  *v = (V_TYPE) { *s };\n+  __asm__ volatile (\"nop\"\n+\t\t    : \"+m\" (*s), \"+m\" (*v)\n+\t\t    :\n+\t\t    : \"memory\");\n+\n+}\n+\n+\n+/* Check if vadduqm returns the same values as normal 128-bit add.  */\n+\n+/* Values to add together.  */\n+const static struct {\n+  unsigned long hi_1;\n+  unsigned long lo_1;\n+  unsigned long hi_2;\n+  unsigned long lo_2;\n+} values[] = {\n+  { 0x0000000000000000UL, 0xfffffffffffffffeUL,\n+    0x0000000000000000UL, 0x0000000000000002UL },\n+  { 0x0000000000000000UL, 0x0000000000000002UL,\n+    0x0000000000000000UL, 0xfffffffffffffffeUL },\n+  { 0xffffffffffffffffUL, 0xfffffffffffffffeUL,\n+    0x0000000000000000UL, 0x0000000000000002UL },\n+  { 0xfffffffffffffff2UL, 0xffffffffffffffffUL,\n+    0x0000000000000002UL, 0x0000000000000000UL },\n+  { 0x7fffffffffffffffUL, 0xfffffffffffffffeUL,\n+    0x0000000000000000UL, 0x0000000000000002UL },\n+  { 0x7ffffffffffffff2UL, 0xffffffffffffffffUL,\n+    0x0000000000000002UL, 0x0000000000000000UL },\n+};\n+\n+int\n+main (void)\n+{\n+  int reg_errors = 0;\n+  int mem_errors = 0;\n+  size_t i;\n+  const char *nl = \"\";\n+\n+  for (i = 0; i < sizeof (values) / sizeof (values[0]); i++)\n+    {\n+      S_TYPE s_reg_res, s_reg_in1, s_reg_in2, s_mem_res, s_mem_in1, s_mem_in2;\n+      V_TYPE v_reg_res, v_reg_in1, v_reg_in2, v_mem_res, v_mem_in1, v_mem_in2;\n+\n+      s_reg_in1 = ((((S_TYPE)values[i].hi_1 << 64)) + ((S_TYPE)values[i].lo_1));\n+      reg_errors += compare (s_reg_in1, (V_TYPE) { s_reg_in1 }, nl, \"reg, in1\");\n+\n+      s_reg_in2 = ((((S_TYPE)values[i].hi_2 << 64)) + ((S_TYPE)values[i].lo_2));\n+      reg_errors += compare (s_reg_in2, (V_TYPE) { s_reg_in2 }, \"\", \"reg, in2\");\n+\n+      s_reg_res = s_reg_in1 + s_reg_in2;\n+\n+      v_reg_in1 = (V_TYPE) { s_reg_in1 };\n+      v_reg_in2 = (V_TYPE) { s_reg_in2 };\n+      v_reg_res = vec_vadduqm (v_reg_in1, v_reg_in2);\n+      reg_errors += compare (s_reg_res, v_reg_res, \"\", \"reg, res\");\n+\n+      s_mem_in1 = s_reg_in1;\n+      convert_via_mem (&v_mem_in1, &s_mem_in1);\n+      mem_errors += compare (s_mem_in1, (V_TYPE) { s_mem_in1 }, \"\\n\", \"mem, in1\");\n+\n+      s_mem_in2 = s_reg_in2;\n+      convert_via_mem (&v_mem_in2, &s_mem_in2);\n+      mem_errors += compare (s_mem_in2, (V_TYPE) { s_mem_in2 }, \"\", \"mem, in2\");\n+\n+      s_mem_res = s_mem_in1 + s_mem_in2;\n+      v_mem_res = vec_vadduqm (v_mem_in1, v_mem_in2);\n+      mem_errors += compare (s_mem_res, v_mem_res, \"\", \"mem, res\");\n+\n+      nl = \"\\n\";\n+    }\n+\n+#ifdef DEBUG\n+  putchar ('\\n');\n+\n+  if (!reg_errors)\n+    fputs (\"no errors found on register operations\\n\", stdout);\n+  else\n+    printf (\"%d error%s found on register operations\\n\",\n+\t    reg_errors,\n+\t    (reg_errors == 1) ? \"s\" : \"\");\n+\n+  if (!mem_errors)\n+    fputs (\"no errors found on memory operations\\n\", stdout);\n+  else\n+    printf (\"%d error%s found on memory operations\\n\",\n+\t    mem_errors,\n+\t    (mem_errors == 1) ? \"s\" : \"\");\n+\n+  fflush (stdout);\n+#endif\n+\n+  if ((reg_errors + mem_errors) != 0)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "c169e503e80d9358f1973e3f35db275c0053ef14", "filename": "gcc/testsuite/gcc.target/powerpc/timode_off.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ftimode_off.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a16a872d4445cd76105ad315d6cfbd066f1862be/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ftimode_off.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ftimode_off.c?ref=a16a872d4445cd76105ad315d6cfbd066f1862be", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do assemble { target { lp64 } } } */\n-/* { dg-options \"-O2 -fno-align-functions -mtraceback=no -save-temps\" } */\n+/* { dg-options \"-O2 -fno-align-functions -mtraceback=no -save-temps -mcpu=power5\" } */\n \n typedef int TImode __attribute__ ((mode (TI)));\n \n@@ -46,6 +46,12 @@ TImode r19 (void *x) { return *(TImode *) (x + 32749); }\n TImode r20 (void *x) { return *(TImode *) (x + 32748); }\n \n /* test should really be == 616, see pr54110 */\n+/* When TImode is allowed in VSX registers, the allowable address modes for\n+   TImode is just a single indirect address in order for the value to be loaded\n+   and store in either GPR or VSX registers.  This affects the generated code,\n+   and it would cause this test to fail, when such an option is used.  Fall\n+   back to power5 to test the code.  */\n+\n /* { dg-final { object-size text <= 700 } } */\n /* { dg-final { scan-assembler-not \"(st|l)fd\" } } */\n /* { dg-final { cleanup-saved-temps \"timode_off\" } } */"}]}