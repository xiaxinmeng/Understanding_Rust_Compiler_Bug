{"sha": "fddfd3ce555965864b6116cf541f6355d2057d3d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRkZmQzY2U1NTU5NjU4NjRiNjExNmNmNTQxZjYzNTVkMjA1N2QzZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-03-24T22:25:17Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-03-24T22:25:18Z"}, "message": "c++: Improve handling of ill-formed constraints [PR94186].\n\nIt would have been trivial to make the error for non-bool constraint in\nsatisfy_atom unconditional, but that didn't give context for the error or\nprinting with the dependent form and template arguments.  So I changed a\ncouple of places so that, when a hard error is encountered during quiet\nsubstitution/satisfaction, we go through again noisily; this builds up the\nnecessary context.\n\nThe similar change to tsubst_nested_requirement does not build up the\nnecessary context; rather than try to fix that now I changed\nget_constraint_error_location to give up and use input_location if there's\nno CONSTR_CONTEXT.  In the case of concepts-pr67697.C, we still have a good\nsource location because the NESTED_REQ has a correct EXPR_LOCATION, but this\npatch doesn't improve context printing for this case as it does for the\nabove.\n\ngcc/cp/ChangeLog\n2020-03-24  Jason Merrill  <jason@redhat.com>\n\n\tPR c++/94186\n\t* constraint.cc (constraint_satisfaction_value): Repeat noisily on\n\terror.\n\t(tsubst_nested_requirement): Likewise.\n\t(get_constraint_error_location): Allow missing context.\n\t(diagnose_atomic_constraint): Diagnose non-bool constraint here.\n\t(satisfy_atom): Not here.  Only diagnose non-constant when noisy.", "tree": {"sha": "59426fff8e2a75642580e04b299ca9fd727e783f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59426fff8e2a75642580e04b299ca9fd727e783f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fddfd3ce555965864b6116cf541f6355d2057d3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fddfd3ce555965864b6116cf541f6355d2057d3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fddfd3ce555965864b6116cf541f6355d2057d3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fddfd3ce555965864b6116cf541f6355d2057d3d/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c1617418432466f3f91d282d356bdec91e9dbd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c1617418432466f3f91d282d356bdec91e9dbd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c1617418432466f3f91d282d356bdec91e9dbd2"}], "stats": {"total": 127, "additions": 96, "deletions": 31}, "files": [{"sha": "f867d0e4e1aa853eaf490658ce8f2c5ce320d7d8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fddfd3ce555965864b6116cf541f6355d2057d3d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fddfd3ce555965864b6116cf541f6355d2057d3d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fddfd3ce555965864b6116cf541f6355d2057d3d", "patch": "@@ -1,3 +1,13 @@\n+2020-03-24  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/94186\n+\t* constraint.cc (constraint_satisfaction_value): Repeat noisily on\n+\terror.\n+\t(tsubst_nested_requirement): Likewise.\n+\t(get_constraint_error_location): Allow missing context.\n+\t(diagnose_atomic_constraint): Diagnose non-bool constraint here.\n+\t(satisfy_atom): Not here.  Only diagnose non-constant when noisy.\n+\n 2020-03-24  Jason Merrill  <jason@redhat.com>\n \n \t* pt.c (any_template_parm_r): Look into the type of a non-type"}, {"sha": "a86bcdf603a6a2905960658f48ec0a9092d1972a", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 57, "deletions": 22, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fddfd3ce555965864b6116cf541f6355d2057d3d/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fddfd3ce555965864b6116cf541f6355d2057d3d/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=fddfd3ce555965864b6116cf541f6355d2057d3d", "patch": "@@ -2004,6 +2004,11 @@ tsubst_nested_requirement (tree t, tree args, subst_info info)\n   /* Ensure that we're in an evaluation context prior to satisfaction.  */\n   tree norm = TREE_VALUE (TREE_TYPE (t));\n   tree result = satisfy_constraint (norm, args, info);\n+  if (result == error_mark_node && info.quiet ())\n+    {\n+      subst_info noisy (tf_warning_or_error, info.in_decl);\n+      satisfy_constraint (norm, args, noisy);\n+    }\n   if (result != boolean_true_node)\n     return error_mark_node;\n   return result;\n@@ -2489,7 +2494,7 @@ get_mapped_args (tree map)\n   return args;\n }\n \n-static void diagnose_atomic_constraint (tree, tree, subst_info);\n+static void diagnose_atomic_constraint (tree, tree, tree, subst_info);\n \n /* Compute the satisfaction of an atomic constraint.  */\n \n@@ -2534,8 +2539,6 @@ satisfy_atom (tree t, tree args, subst_info info)\n       return cache.save (boolean_false_node);\n     }\n \n-  location_t loc = cp_expr_loc_or_input_loc (expr);\n-\n   /* [17.4.1.2] ... lvalue-to-rvalue conversion is performed as necessary,\n      and EXPR shall be a constant expression of type bool.  */\n   result = force_rvalue (result, info.complain);\n@@ -2544,14 +2547,22 @@ satisfy_atom (tree t, tree args, subst_info info)\n   if (!same_type_p (TREE_TYPE (result), boolean_type_node))\n     {\n       if (info.noisy ())\n-\terror_at (loc, \"constraint does not have type %<bool%>\");\n+\tdiagnose_atomic_constraint (t, map, result, info);\n       return cache.save (error_mark_node);\n     }\n \n   /* Compute the value of the constraint.  */\n-  result = satisfaction_value (cxx_constant_value (result));\n+  if (info.noisy ())\n+    result = cxx_constant_value (result);\n+  else\n+    {\n+      result = maybe_constant_value (result);\n+      if (!TREE_CONSTANT (result))\n+\tresult = error_mark_node;\n+    }\n+  result = satisfaction_value (result);\n   if (result == boolean_false_node && info.noisy ())\n-    diagnose_atomic_constraint (t, map, info);\n+    diagnose_atomic_constraint (t, map, result, info);\n \n   return cache.save (result);\n }\n@@ -2733,20 +2744,34 @@ static tree\n constraint_satisfaction_value (tree t, tsubst_flags_t complain)\n {\n   subst_info info (complain, NULL_TREE);\n+  tree r;\n   if (DECL_P (t))\n-    return satisfy_declaration_constraints (t, info);\n+    r = satisfy_declaration_constraints (t, info);\n   else\n-    return satisfy_constraint_expression (t, NULL_TREE, info);\n+    r = satisfy_constraint_expression (t, NULL_TREE, info);\n+  if (r == error_mark_node && info.quiet ()\n+      && !(DECL_P (t) && TREE_NO_WARNING (t)))\n+      {\n+\tconstraint_satisfaction_value (t, tf_warning_or_error);\n+\tif (DECL_P (t))\n+\t  /* Avoid giving these errors again.  */\n+\t  TREE_NO_WARNING (t) = true;\n+      }\n+  return r;\n }\n \n static tree\n constraint_satisfaction_value (tree t, tree args, tsubst_flags_t complain)\n {\n   subst_info info (complain, NULL_TREE);\n+  tree r;\n   if (DECL_P (t))\n-    return satisfy_declaration_constraints (t, args, info);\n+    r = satisfy_declaration_constraints (t, args, info);\n   else\n-    return satisfy_constraint_expression (t, args, info);\n+    r = satisfy_constraint_expression (t, args, info);\n+  if (r == error_mark_node && info.quiet ())\n+    constraint_satisfaction_value (t, args, tf_warning_or_error);\n+  return r;\n }\n \n /* True iff the result of satisfying T is BOOLEAN_TRUE_NODE and false\n@@ -3033,6 +3058,9 @@ at_least_as_constrained (tree d1, tree d2)\n static location_t\n get_constraint_error_location (tree t)\n {\n+  if (location_t loc = cp_expr_location (t))\n+    return loc;\n+\n   /* If we have a specific location give it.  */\n   tree expr = CONSTR_EXPR (t);\n   if (location_t loc = cp_expr_location (expr))\n@@ -3041,20 +3069,23 @@ get_constraint_error_location (tree t)\n   /* If the constraint is normalized from a requires-clause, give\n      the location as that of the constrained declaration.  */\n   tree cxt = CONSTR_CONTEXT (t);\n-  tree src = TREE_VALUE (cxt);\n+  tree src = cxt ? TREE_VALUE (cxt) : NULL_TREE;\n   if (!src)\n     /* TODO: This only happens for constrained non-template declarations.  */\n-    return input_location;\n-  if (DECL_P (src))\n+    ;\n+  else if (DECL_P (src))\n     return DECL_SOURCE_LOCATION (src);\n-\n   /* Otherwise, give the location as the defining concept.  */\n-  gcc_assert (concept_check_p (src));\n-  tree id = unpack_concept_check (src);\n-  tree tmpl = TREE_OPERAND (id, 0);\n-  if (OVL_P (tmpl))\n-    tmpl = OVL_FIRST (tmpl);\n-  return DECL_SOURCE_LOCATION (tmpl);\n+  else if (concept_check_p (src))\n+    {\n+      tree id = unpack_concept_check (src);\n+      tree tmpl = TREE_OPERAND (id, 0);\n+      if (OVL_P (tmpl))\n+\ttmpl = OVL_FIRST (tmpl);\n+      return DECL_SOURCE_LOCATION (tmpl);\n+    }\n+\n+  return input_location;\n }\n \n /* Emit a diagnostic for a failed trait.  */\n@@ -3302,7 +3333,7 @@ diagnose_requires_expr (tree expr, tree map, tree in_decl)\n    with the instantiated parameter mapping MAP.  */\n \n static void\n-diagnose_atomic_constraint (tree t, tree map, subst_info info)\n+diagnose_atomic_constraint (tree t, tree map, tree result, subst_info info)\n {\n   /* If the constraint is already ill-formed, we've previously diagnosed\n      the reason. We should still say why the constraints aren't satisfied.  */\n@@ -3338,7 +3369,11 @@ diagnose_atomic_constraint (tree t, tree map, subst_info info)\n     default:\n       tree a = copy_node (t);\n       ATOMIC_CONSTR_MAP (a) = map;\n-      inform (loc, \"the expression %qE evaluated to %<false%>\", a);\n+      if (!same_type_p (TREE_TYPE (result), boolean_type_node))\n+\terror_at (loc, \"constraint %qE has type %qT, not %<bool%>\",\n+\t\t  a, TREE_TYPE (result));\n+      else\n+\tinform (loc, \"the expression %qE evaluated to %<false%>\", a);\n       ggc_free (a);\n     }\n }"}, {"sha": "3f5b1f405a1b84e3b89ae6284dd2d991803f828a", "filename": "gcc/testsuite/g++.dg/concepts/pr84330.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fddfd3ce555965864b6116cf541f6355d2057d3d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr84330.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fddfd3ce555965864b6116cf541f6355d2057d3d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr84330.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr84330.C?ref=fddfd3ce555965864b6116cf541f6355d2057d3d", "patch": "@@ -5,7 +5,7 @@\n struct A\n {\n   template<typename T>\n-    requires (sizeof(T) >> 0) // { dg-error \"constraint does not have type 'bool'\" }\n+    requires (sizeof(T) >> 0) // { dg-error \"bool\" }\n   void foo(T);\n \n   void bar()"}, {"sha": "8be365dfa974779c8a68d527b68dd86eef7df415", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-nonbool1.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fddfd3ce555965864b6116cf541f6355d2057d3d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-nonbool1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fddfd3ce555965864b6116cf541f6355d2057d3d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-nonbool1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-nonbool1.C?ref=fddfd3ce555965864b6116cf541f6355d2057d3d", "patch": "@@ -0,0 +1,20 @@\n+// PR c++/94186\n+// { dg-do compile { target concepts } }\n+\n+template <typename T>\n+struct is_small\n+{\n+  enum { value = sizeof(T) <= 4 };\n+};\n+\n+template <typename T>\n+  requires is_small<T>::value\t// { dg-error \"bool\" }\n+void fun(T) {}\n+\n+template <typename T>\n+void fun(T) {}\n+\n+int main()\n+{\n+  fun(1);  // { dg-message \"\" }\n+}"}, {"sha": "7afd34d11fda77a71ba42ad74fb9697b95b3b0d5", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fddfd3ce555965864b6116cf541f6355d2057d3d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fddfd3ce555965864b6116cf541f6355d2057d3d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires1.C?ref=fddfd3ce555965864b6116cf541f6355d2057d3d", "patch": "@@ -41,8 +41,8 @@ template<int N> requires N == 0 struct S2 { }; // { dg-error \"does not have type\n \n template<int N> requires (N == 0) struct S3 { }; // OK\n \n-template<typename T, T X> requires X struct S4 { }; // OK\n-S4<int, 0> x1;      // { dg-error \"template constraint failure|does not have type\" }\n+template<typename T, T X> requires X struct S4 { }; // { dg-error \"bool\" }\n+S4<int, 0> x1;      // { dg-error \"template constraint failure\" }\n S4<bool, true> x2; // OK\n S4<bool, false> x3; // { dg-error \"template constraint failure\" }\n "}, {"sha": "282dba63e293a69269ca3d512f2bc61809950d08", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires2.C", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fddfd3ce555965864b6116cf541f6355d2057d3d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fddfd3ce555965864b6116cf541f6355d2057d3d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires2.C?ref=fddfd3ce555965864b6116cf541f6355d2057d3d", "patch": "@@ -12,24 +12,24 @@ template<typename T> constexpr fool p1() { return {}; }\n template<typename T> constexpr fool p2() { return {}; }\n \n template<typename T>\n-concept Bad = p1<T>() && p2<T>(); // { dg-error \"does not have type 'bool'\" }\n+concept Bad = p1<T>() && p2<T>(); // { dg-error \"bool\" }\n \n template<typename T> requires Bad<T> void bad(T x) { }\n \n void driver_2()\n {\n-  bad(0); // { dg-error \"\" }\n+  bad(0); // { dg-message \"\" }\n }\n \n // req6.C\n struct X { };\n int operator==(X, X) { return 0; }\n \n template<typename T>\n-concept C1 = (X()); // { dg-error \"does not have type 'bool'\" }\n+concept C1 = (X()); // { dg-error \"bool\" }\n \n template<typename T>\n-concept C2 = (X() == X()); // { dg-error \"does not have type 'bool'\" }\n+concept C2 = (X() == X()); // { dg-error \"bool\" }\n \n template<typename T>\n   requires C1<T>\n@@ -41,8 +41,8 @@ void h2(T);\n \n void driver_3()\n {\n-  h1(0); // { dg-error \"\" }\n-  h2(0); // { dg-error \"\" }\n+  h1(0); // { dg-message \"\" }\n+  h2(0); // { dg-message \"\" }\n }\n \n // req7.C"}]}