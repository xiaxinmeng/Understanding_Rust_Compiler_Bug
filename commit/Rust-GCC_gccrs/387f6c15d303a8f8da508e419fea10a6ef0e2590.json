{"sha": "387f6c15d303a8f8da508e419fea10a6ef0e2590", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzg3ZjZjMTVkMzAzYThmOGRhNTA4ZTQxOWZlYTEwYTZlZjBlMjU5MA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-01-14T22:02:28Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-01-14T22:02:28Z"}, "message": "Handle fancy_abort before diagnostic initialization [PR98586]\n\nIf fancy_abort is called before the diagnostic subsystem is initialized,\ninternal_error will crash internally in a way that prevents a useful\nmessage reaching the user.\n\nThis can happen with libgccjit in the case of gcc_assert failures\nthat occur outside of the libgccjit mutex that guards the rest of\ngcc's state, including global_dc (when global_dc may not be\ninitialized yet, or might be in use by another thread).\n\nI tried a few approaches to fixing this as noted in PR jit/98586\ne.g. using a temporary diagnostic_context and initializing it for\nthe call to internal_error, however the more code that runs, the\nmore chance there is for other errors to occur.\n\nThe best fix appears to be to simply fall back to a minimal abort\nimplementation that only relies on i18n, as implemented by this\npatch.\n\ngcc/ChangeLog:\n\tPR jit/98586\n\t* diagnostic.c (diagnostic_kind_text): Break out this array\n\tfrom...\n\t(diagnostic_build_prefix): ...here.\n\t(fancy_abort): Detect when diagnostic_initialize has not yet been\n\tcalled and fall back to a minimal implementation of printing the\n\tICE, rather than segfaulting in internal_error.", "tree": {"sha": "fcf14c994b578c9faaec264b1f7bbb60cf36ec32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fcf14c994b578c9faaec264b1f7bbb60cf36ec32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/387f6c15d303a8f8da508e419fea10a6ef0e2590", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/387f6c15d303a8f8da508e419fea10a6ef0e2590", "html_url": "https://github.com/Rust-GCC/gccrs/commit/387f6c15d303a8f8da508e419fea10a6ef0e2590", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/387f6c15d303a8f8da508e419fea10a6ef0e2590/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02e7af1122c1aae7c4c764aaa078f72a54645c06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02e7af1122c1aae7c4c764aaa078f72a54645c06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02e7af1122c1aae7c4c764aaa078f72a54645c06"}], "stats": {"total": 45, "additions": 39, "deletions": 6}, "files": [{"sha": "a024bc206f3468eeefbdc7f511510d35956f61c3", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 39, "deletions": 6, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/387f6c15d303a8f8da508e419fea10a6ef0e2590/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/387f6c15d303a8f8da508e419fea10a6ef0e2590/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=387f6c15d303a8f8da508e419fea10a6ef0e2590", "patch": "@@ -449,19 +449,20 @@ diagnostic_get_location_text (diagnostic_context *context,\n \t\t\t       line_col, locus_ce);\n }\n \n+static const char *const diagnostic_kind_text[] = {\n+#define DEFINE_DIAGNOSTIC_KIND(K, T, C) (T),\n+#include \"diagnostic.def\"\n+#undef DEFINE_DIAGNOSTIC_KIND\n+  \"must-not-happen\"\n+};\n+\n /* Return a malloc'd string describing a location and the severity of the\n    diagnostic, e.g. \"foo.c:42:10: error: \".  The caller is responsible for\n    freeing the memory.  */\n char *\n diagnostic_build_prefix (diagnostic_context *context,\n \t\t\t const diagnostic_info *diagnostic)\n {\n-  static const char *const diagnostic_kind_text[] = {\n-#define DEFINE_DIAGNOSTIC_KIND(K, T, C) (T),\n-#include \"diagnostic.def\"\n-#undef DEFINE_DIAGNOSTIC_KIND\n-    \"must-not-happen\"\n-  };\n   gcc_assert (diagnostic->kind < DK_LAST_DIAGNOSTIC_KIND);\n \n   const char *text = _(diagnostic_kind_text[diagnostic->kind]);\n@@ -1871,6 +1872,38 @@ error_recursion (diagnostic_context *context)\n void\n fancy_abort (const char *file, int line, const char *function)\n {\n+  /* If fancy_abort is called before the diagnostic subsystem is initialized,\n+     internal_error will crash internally in a way that prevents a\n+     useful message reaching the user.\n+     This can happen with libgccjit in the case of gcc_assert failures\n+     that occur outside of the libgccjit mutex that guards the rest of\n+     gcc's state, including global_dc (when global_dc may not be\n+     initialized yet, or might be in use by another thread).\n+     Handle such cases as gracefully as possible by falling back to a\n+     minimal abort handler that only relies on i18n.  */\n+  if (global_dc->printer == NULL)\n+    {\n+      /* Print the error message.  */\n+      fnotice (stderr, diagnostic_kind_text[DK_ICE]);\n+      fnotice (stderr, \"in %s, at %s:%d\", function, trim_filename (file), line);\n+      fputc ('\\n', stderr);\n+\n+      /* Attempt to print a backtrace.  */\n+      struct backtrace_state *state\n+\t= backtrace_create_state (NULL, 0, bt_err_callback, NULL);\n+      int count = 0;\n+      if (state != NULL)\n+\tbacktrace_full (state, 2, bt_callback, bt_err_callback,\n+\t\t\t(void *) &count);\n+\n+      /* We can't call warn_if_plugins or emergency_dump_function as these\n+\t rely on GCC state that might not be initialized, or might be in\n+\t use by another thread.  */\n+\n+      /* Abort the process.  */\n+      real_abort ();\n+    }\n+\n   internal_error (\"in %s, at %s:%d\", function, trim_filename (file), line);\n }\n "}]}