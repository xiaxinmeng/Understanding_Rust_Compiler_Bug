{"sha": "8b8e6c64afcc492a3b124a229e9b7774e032fdb9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI4ZTZjNjRhZmNjNDkyYTNiMTI0YTIyOWU5Yjc3NzRlMDMyZmRiOQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2003-03-11T20:37:02Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-03-11T20:37:02Z"}, "message": "parse.y (resolve_field_access): Initialize class if field is found in another static field.\n\n\t* parse.y (resolve_field_access): Initialize class if field is\n\tfound in another static field.\n\t* expr.c (build_class_init): Don't optimize out initialization of\n\timplemented interface.\n\nFrom-SVN: r64185", "tree": {"sha": "fa514899cdd4ebb3ba4558eb16c3f0be370427be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa514899cdd4ebb3ba4558eb16c3f0be370427be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b8e6c64afcc492a3b124a229e9b7774e032fdb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b8e6c64afcc492a3b124a229e9b7774e032fdb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b8e6c64afcc492a3b124a229e9b7774e032fdb9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b8e6c64afcc492a3b124a229e9b7774e032fdb9/comments", "author": null, "committer": null, "parents": [{"sha": "218d1401afae50f7ec94e61f75d0ce397c22e944", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/218d1401afae50f7ec94e61f75d0ce397c22e944", "html_url": "https://github.com/Rust-GCC/gccrs/commit/218d1401afae50f7ec94e61f75d0ce397c22e944"}], "stats": {"total": 29, "additions": 28, "deletions": 1}, "files": [{"sha": "0c9bc9b182af6adf26b0297ba10cfd5d6a2420d0", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b8e6c64afcc492a3b124a229e9b7774e032fdb9/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b8e6c64afcc492a3b124a229e9b7774e032fdb9/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=8b8e6c64afcc492a3b124a229e9b7774e032fdb9", "patch": "@@ -1,3 +1,10 @@\n+2003-03-11  Tom Tromey  <tromey@redhat.com>\n+\n+\t* parse.y (resolve_field_access): Initialize class if field is\n+\tfound in another static field.\n+\t* expr.c (build_class_init): Don't optimize out initialization of\n+\timplemented interface.\n+\n 2003-03-11  Andrew Haley  <aph@redhat.com>\n \n \t* jcf-io.c (caching_stat): Initialize origsep to remove compiler"}, {"sha": "11748238fd751c37e29ee790d32d4d464413109b", "filename": "gcc/java/expr.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b8e6c64afcc492a3b124a229e9b7774e032fdb9/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b8e6c64afcc492a3b124a229e9b7774e032fdb9/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=8b8e6c64afcc492a3b124a229e9b7774e032fdb9", "patch": "@@ -1672,7 +1672,14 @@ tree\n build_class_init (tree clas, tree expr)\n {\n   tree init;\n-  if (inherits_from_p (current_class, clas))\n+\n+  /* An optimization: if CLAS is a superclass of the class we're\n+     compiling, we don't need to initialize it.  However, if CLAS is\n+     an interface, it won't necessarily be initialized, even if we\n+     implement it.  */\n+  if ((! CLASS_INTERFACE (TYPE_NAME (clas))\n+       && inherits_from_p (current_class, clas))\n+      || current_class == clas)\n     return expr;\n \n   if (always_initialize_class_p)"}, {"sha": "82293edfc724a139badf3d4fc288223c0258dc7c", "filename": "gcc/java/parse.y", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b8e6c64afcc492a3b124a229e9b7774e032fdb9/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b8e6c64afcc492a3b124a229e9b7774e032fdb9/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=8b8e6c64afcc492a3b124a229e9b7774e032fdb9", "patch": "@@ -9301,6 +9301,19 @@ resolve_field_access (tree qual_wfl, tree *field_decl, tree *field_type)\n \treturn error_mark_node;\n       if (is_static)\n \tfield_ref = maybe_build_class_init_for_field (decl, field_ref);\n+\n+      /* If we're looking at a static field, we may need to generate a\n+\t class initialization for it.  This can happen when the access\n+\t looks like `field.ref', where `field' is a static field in an\n+\t interface we implement.  */\n+      if (!flag_emit_class_files\n+\t  && !flag_emit_xref\n+\t  && TREE_CODE (where_found) == VAR_DECL\n+\t  && FIELD_STATIC (where_found))\n+\t{\n+\t  build_static_field_ref (where_found);\n+\t  field_ref = build_class_init (DECL_CONTEXT (where_found), field_ref);\n+\t}\n     }\n   else\n     field_ref = decl;"}]}