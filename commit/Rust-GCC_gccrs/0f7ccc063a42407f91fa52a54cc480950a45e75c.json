{"sha": "0f7ccc063a42407f91fa52a54cc480950a45e75c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY3Y2NjMDYzYTQyNDA3ZjkxZmE1MmE1NGNjNDgwOTUwYTQ1ZTc1Yw==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-06-17T17:39:02Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-06-22T12:11:45Z"}, "message": "Add relation between LHS and op1 for casts and copies.\n\n\t* range-op.cc (operator_cast::lhs_op1_relation): New.\n\t(operator_identity::lhs_op1_relation): Mew.", "tree": {"sha": "9d0e5337cd18f98cb5fffde84d5f9675601f0be9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d0e5337cd18f98cb5fffde84d5f9675601f0be9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f7ccc063a42407f91fa52a54cc480950a45e75c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f7ccc063a42407f91fa52a54cc480950a45e75c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f7ccc063a42407f91fa52a54cc480950a45e75c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f7ccc063a42407f91fa52a54cc480950a45e75c/comments", "author": null, "committer": null, "parents": [{"sha": "ae6b830f31a47aca7ca24c4fea245c29214eef3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae6b830f31a47aca7ca24c4fea245c29214eef3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae6b830f31a47aca7ca24c4fea245c29214eef3a"}], "stats": {"total": 41, "additions": 41, "deletions": 0}, "files": [{"sha": "92b314df9dd4de79a1146662ebb13cfafe24571c", "filename": "gcc/range-op.cc", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f7ccc063a42407f91fa52a54cc480950a45e75c/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f7ccc063a42407f91fa52a54cc480950a45e75c/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=0f7ccc063a42407f91fa52a54cc480950a45e75c", "patch": "@@ -2115,6 +2115,10 @@ class operator_cast: public range_operator\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n \t\t\t  relation_kind rel = VREL_NONE) const;\n+  virtual enum tree_code lhs_op1_relation (const irange &lhs,\n+\t\t\t\t\t   const irange &op1,\n+\t\t\t\t\t   const irange &op2) const;\n+\n private:\n   bool truncating_cast_p (const irange &inner, const irange &outer) const;\n   bool inside_domain_p (const wide_int &min, const wide_int &max,\n@@ -2123,6 +2127,27 @@ class operator_cast: public range_operator\n \t\t\t   const irange &outer) const;\n } op_convert;\n \n+// Determine if there is a relationship between LHS and OP1.\n+\n+enum tree_code\n+operator_cast::lhs_op1_relation (const irange &lhs,\n+\t\t\t\t const irange &op1,\n+\t\t\t\t const irange &op2 ATTRIBUTE_UNUSED) const\n+{\n+  if (op1.undefined_p ())\n+    return VREL_NONE;\n+  // We can't make larger types equivalent to smaller types because we can\n+  // miss sign extensions in a chain of casts.\n+  // u32 = 0xfffff\n+  // s32 = (s32) u32\n+  // s64 = (s64) s32\n+  // we cant simply \"convert\" s64 = (s64)u32  or we get positive 0xffff\n+  // value instead of sign extended negative value.\n+  if (TYPE_PRECISION (lhs.type ()) == TYPE_PRECISION (op1.type ()))\n+    return EQ_EXPR;\n+  return VREL_NONE;\n+}\n+\n // Return TRUE if casting from INNER to OUTER is a truncating cast.\n \n inline bool\n@@ -3325,8 +3350,24 @@ class operator_identity : public range_operator\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n \t\t\t  relation_kind rel = VREL_NONE) const;\n+  virtual enum tree_code lhs_op1_relation (const irange &lhs,\n+\t\t\t\t\t   const irange &op1,\n+\t\t\t\t\t   const irange &op2) const;\n } op_identity;\n \n+// Determine if there is a relationship between LHS and OP1.\n+\n+enum tree_code\n+operator_identity::lhs_op1_relation (const irange &lhs,\n+\t\t\t\t     const irange &op1 ATTRIBUTE_UNUSED,\n+\t\t\t\t     const irange &op2 ATTRIBUTE_UNUSED) const\n+{\n+  if (lhs.undefined_p ())\n+    return VREL_NONE;\n+  // Simply a copy, so they are equivalent.\n+  return EQ_EXPR;\n+}\n+\n bool\n operator_identity::fold_range (irange &r, tree type ATTRIBUTE_UNUSED,\n \t\t\t       const irange &lh,"}]}