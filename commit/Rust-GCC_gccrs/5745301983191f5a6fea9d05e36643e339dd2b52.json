{"sha": "5745301983191f5a6fea9d05e36643e339dd2b52", "node_id": "C_kwDOANBUbNoAKDU3NDUzMDE5ODMxOTFmNWE2ZmVhOWQwNWUzNjY0M2UzMzlkZDJiNTI", "commit": {"author": {"name": "Dimitar Dimitrov", "email": "dimitar@dinux.eu", "date": "2022-04-03T19:27:12Z"}, "committer": {"name": "Dimitar Dimitrov", "email": "dimitar@dinux.eu", "date": "2022-06-28T15:45:40Z"}, "message": "testsuite: Add new target check for no_alignment_constraints\n\nA few testcases were marked for avr target, which has no alignment\nrequirements.  But those tests in fact should filter for any\ntarget having __BIGGEST_ALIGNMENT__=1.\n\nA new effective target check is introduced: no_alignment_constraints.\nIt checks whether __BIGGEST_ALIGNMENT__ is declared as 1.\n\nThis change fixes the testsuite cases for PRU target.\n\nIt was regression-tested on x86_64-pc-linux-gnu.\n\nThe following two existing macros were considered, but they check for\nsubtly different target behaviour:\n 1. non_strict_align\n    If true, non-aligned access is permitted. But it also allows\n    variables to be naturally aligned, which is not true for\n    no_alignment_constraints.\n\n 2. default_packed\n    Whether structures are packed by default is not necessarily\n    the same as lacking constraints for non-aggregate types.\n    For example, BIGGEST_FIELD_ALIGNMENT or ADJUST_FIELD_ALIGN\n    could be defined for a target as something other than\n    BIGGEST_ALIGNMENT.\n\ngcc/ChangeLog:\n\n\t* doc/sourcebuild.texi: Document new no_alignment_constraints\n\teffective target check.\n\ngcc/testsuite/ChangeLog:\n\n\t* c-c++-common/Wcast-align.c: Silence warnings for targets with\n\tno_alignment_constraints.\n\t* gcc.dg/c11-align-4.c: Skip for no_alignment_constraints.\n\t* gcc.dg/strlenopt-10.c: Replace checks for avr with checks for\n\tany target with no_alignment_constraints.\n\t* gcc.dg/strlenopt-11.c: Ditto.\n\t* gcc.dg/strlenopt-13.c: Ditto.\n\t* lib/target-supports.exp\n\t(check_effective_target_no_alignment_constraints): New.\n\nSigned-off-by: Dimitar Dimitrov <dimitar@dinux.eu>", "tree": {"sha": "f4e4bbdd88faf2dd2223d4f4d86e9982731cc530", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4e4bbdd88faf2dd2223d4f4d86e9982731cc530"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5745301983191f5a6fea9d05e36643e339dd2b52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5745301983191f5a6fea9d05e36643e339dd2b52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5745301983191f5a6fea9d05e36643e339dd2b52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5745301983191f5a6fea9d05e36643e339dd2b52/comments", "author": null, "committer": null, "parents": [{"sha": "243b5396106c4b1eb813fd06c2bc6f0a3009bae8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/243b5396106c4b1eb813fd06c2bc6f0a3009bae8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/243b5396106c4b1eb813fd06c2bc6f0a3009bae8"}], "stats": {"total": 64, "additions": 43, "deletions": 21}, "files": [{"sha": "760ff9559a657089c7f8047ca0431997e49ccda5", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5745301983191f5a6fea9d05e36643e339dd2b52/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5745301983191f5a6fea9d05e36643e339dd2b52/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=5745301983191f5a6fea9d05e36643e339dd2b52", "patch": "@@ -2716,6 +2716,7 @@ Target supports @option{-branch-cost=N}.\n Target uses @code{__cxa_atexit}.\n \n @item default_packed\n+@anchor{default_packed}\n Target has packed layout of structure members by default.\n \n @item exceptions\n@@ -2786,6 +2787,14 @@ Target uses natural alignment (aligned to type size) for types of\n Target uses natural alignment (aligned to type size) for types of\n 64 bits or less.\n \n+@item no_alignment_constraints\n+Target defines __BIGGEST_ALIGNMENT__=1.  Hence target imposes\n+no alignment constraints.  This is similar, but not necessarily\n+the same as @ref{default_packed}.  Although @code{BIGGEST_FIELD_ALIGNMENT}\n+defaults to @code{BIGGEST_ALIGNMENT} for most targets, it is possible\n+for a target to set those two with different values and have different\n+alignment constraints for aggregate and non-aggregate types.\n+\n @item noinit\n Target supports the @code{noinit} variable attribute.\n "}, {"sha": "1087b10fd99d946c4626b762f59c3f9f8829051c", "filename": "gcc/testsuite/c-c++-common/Wcast-align.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5745301983191f5a6fea9d05e36643e339dd2b52/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWcast-align.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5745301983191f5a6fea9d05e36643e339dd2b52/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWcast-align.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWcast-align.c?ref=5745301983191f5a6fea9d05e36643e339dd2b52", "patch": "@@ -16,8 +16,8 @@ struct t { double x; } *q;\n void\n foo (void)\n {\n-  y = (c *) x;  /* { dg-warning \"7:cast \\[^\\n\\r]* required alignment of target type\" } */\n-  z = (d *) x;  /* { dg-warning \"7:cast \\[^\\n\\r]* required alignment of target type\" } */\n+  y = (c *) x;  /* { dg-warning \"7:cast \\[^\\n\\r]* required alignment of target type\" \"\" { target { ! no_alignment_constraints } } } */\n+  z = (d *) x;  /* { dg-warning \"7:cast \\[^\\n\\r]* required alignment of target type\" \"\" { target { ! no_alignment_constraints } } } */\n   (long long *) p;  /* { dg-bogus \"alignment\" } */\n   (double *) q;     /* { dg-bogus \"alignment\" } */\n }"}, {"sha": "eb9071b91496a82d9c0df18c7fb89a9aec035d96", "filename": "gcc/testsuite/gcc.dg/c11-align-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5745301983191f5a6fea9d05e36643e339dd2b52/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-align-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5745301983191f5a6fea9d05e36643e339dd2b52/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-align-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-align-4.c?ref=5745301983191f5a6fea9d05e36643e339dd2b52", "patch": "@@ -2,7 +2,7 @@\n    are at least some alignment constraints).  */\n /* { dg-do compile } */\n /* { dg-options \"-std=c11 -pedantic-errors\" } */\n-/* { dg-skip-if \"no alignment constraints\" { \"avr-*-*\" } } */\n+/* { dg-skip-if \"no alignment constraints\" { no_alignment_constraints } } */\n \n #include <stddef.h>\n "}, {"sha": "6e2c2597b27f81b487897d167e6f3c36d5507a0a", "filename": "gcc/testsuite/gcc.dg/strlenopt-10.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5745301983191f5a6fea9d05e36643e339dd2b52/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5745301983191f5a6fea9d05e36643e339dd2b52/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-10.c?ref=5745301983191f5a6fea9d05e36643e339dd2b52", "patch": "@@ -70,10 +70,10 @@ main ()\n }\n \n /* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 2 \"strlen1\" } } */\n-/* avr has BIGGEST_ALIGNMENT 8, allowing fold_builtin_memory_op\n+/* Some targets have BIGGEST_ALIGNMENT 8-bits, allowing fold_builtin_memory_op\n    to expand the memcpy call at the end of fn2.  */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 8 \"strlen1\" { target { ! avr-*-* } } } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 7 \"strlen1\" { target { avr-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 8 \"strlen1\" { target { ! no_alignment_constraints } } } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 7 \"strlen1\" { target { no_alignment_constraints} } } } */\n /* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen1\" } } */\n /* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen1\" } } */\n /* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */"}, {"sha": "952de0730f198097b415c39ad4c1028c43f02f97", "filename": "gcc/testsuite/gcc.dg/strlenopt-11.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5745301983191f5a6fea9d05e36643e339dd2b52/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5745301983191f5a6fea9d05e36643e339dd2b52/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-11.c?ref=5745301983191f5a6fea9d05e36643e339dd2b52", "patch": "@@ -59,17 +59,17 @@ main ()\n }\n \n /* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 3 \"strlen1\" } } */\n-/* avr has BIGGEST_ALIGNMENT 8, allowing fold_builtin_memory_op\n+/* Some targets have BIGGEST_ALIGNMENT 8-bits, allowing fold_builtin_memory_op\n    to expand the memcpy call at the end of fn1.  */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 7 \"strlen1\" { target { ! avr-*-* } } } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 6 \"strlen1\" { target { avr-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 7 \"strlen1\" { target { ! no_alignment_constraints } } } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 6 \"strlen1\" { target { no_alignment_constraints } } } } */\n /* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen1\" } } */\n /* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen1\" } } */\n /* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */\n /* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen1\" } } */\n /* Where the memcpy is expanded, the assignemts to elements of l are\n    propagated.  */\n-/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.0. = \" 1 \"strlen1\" { target { ! avr-*-* } } } } */\n-/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.6. = \" 1 \"strlen1\" { target { ! avr-*-* } } } } */\n-/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.9. = \" 1 \"strlen1\" { target { ! avr-*-* } } } } */\n-/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\" 3 \"strlen1\" { target { avr-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.0. = \" 1 \"strlen1\" { target { ! no_alignment_constraints } } } } */\n+/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.6. = \" 1 \"strlen1\" { target { ! no_alignment_constraints } } } } */\n+/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.9. = \" 1 \"strlen1\" { target { ! no_alignment_constraints } } } } */\n+/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\" 3 \"strlen1\" { target { no_alignment_constraints } } } } */"}, {"sha": "4c6d52667807d104eec32bad85d72439d8471d46", "filename": "gcc/testsuite/gcc.dg/strlenopt-13.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5745301983191f5a6fea9d05e36643e339dd2b52/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5745301983191f5a6fea9d05e36643e339dd2b52/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-13.c?ref=5745301983191f5a6fea9d05e36643e339dd2b52", "patch": "@@ -56,18 +56,18 @@ main ()\n }\n \n /* { dg-final { scan-tree-dump-times \"strlen \\\\(\" 4 \"strlen1\" } } */\n-/* avr has BIGGEST_ALIGNMENT 8, allowing fold_builtin_memory_op\n+/* Some targets have BIGGEST_ALIGNMENT 8-bits, allowing fold_builtin_memory_op\n    to expand the memcpy call at the end of fn1.  */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 7 \"strlen1\" { target { ! avr-*-* } } } } */\n-/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 6 \"strlen1\" { target { avr-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 7 \"strlen1\" { target { ! no_alignment_constraints } } } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 6 \"strlen1\" { target { no_alignment_constraints } } } } */\n /* { dg-final { scan-tree-dump-times \"strcpy \\\\(\" 0 \"strlen1\" } } */\n /* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen1\" } } */\n /* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen1\" } } */\n /* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen1\" } } */\n /* Where the memcpy is expanded, the assignemts to elements of l are\n    propagated.  */\n-/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.0. = \" 1 \"strlen1\" { target { ! avr-*-* } } } } */\n-/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.1. = \" 1 \"strlen1\" { target { ! avr-*-* } } } } */\n-/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.5. = \" 1 \"strlen1\" { target { ! avr-*-* } } } } */\n-/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.6. = \" 1 \"strlen1\" { target { ! avr-*-* } } } } */\n-/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\" 4 \"strlen1\" { target { avr-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.0. = \" 1 \"strlen1\" { target { ! no_alignment_constraints } } } } */\n+/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.1. = \" 1 \"strlen1\" { target { ! no_alignment_constraints } } } } */\n+/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.5. = \" 1 \"strlen1\" { target { ! no_alignment_constraints } } } } */\n+/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.6. = \" 1 \"strlen1\" { target { ! no_alignment_constraints } } } } */\n+/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\" 4 \"strlen1\" { target { no_alignment_constraints } } } } */"}, {"sha": "48c5dda6a12782c52db5634adb5bc90e25e93d1a", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5745301983191f5a6fea9d05e36643e339dd2b52/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5745301983191f5a6fea9d05e36643e339dd2b52/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=5745301983191f5a6fea9d05e36643e339dd2b52", "patch": "@@ -7549,6 +7549,19 @@ proc check_effective_target_vect_aligned_arrays { } {\n     return $et_vect_aligned_arrays\n }\n \n+# Return 1 if the biggest alignment required by target is 1 * BITS_PER_UNIT.\n+# In such case the target does not impose any alignment constraints.\n+\n+proc check_effective_target_no_alignment_constraints { } {\n+    return [check_runtime_nocache no_alignment_constraints {\n+        int\n+        main (void)\n+        {\n+          return __BIGGEST_ALIGNMENT__ == 1 ? 0 : 1;\n+        }\n+    }]\n+}\n+\n # Return 1 if types of size 32 bit or less are naturally aligned\n # (aligned to their type-size), 0 otherwise.\n #"}]}