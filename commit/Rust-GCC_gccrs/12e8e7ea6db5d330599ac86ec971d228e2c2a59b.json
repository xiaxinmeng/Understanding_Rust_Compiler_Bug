{"sha": "12e8e7ea6db5d330599ac86ec971d228e2c2a59b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJlOGU3ZWE2ZGI1ZDMzMDU5OWFjODZlYzk3MWQyMjhlMmMyYTU5Yg==", "commit": {"author": {"name": "Jerry Quinn", "email": "jlquinn@gcc.gnu.org", "date": "2004-07-14T22:58:30Z"}, "committer": {"name": "Jerry Quinn", "email": "jlquinn@gcc.gnu.org", "date": "2004-07-14T22:58:30Z"}, "message": "EventHandler.java: New file.\n\n2004-07-14  Jerry Quinn  <jlquinn@optonline.net>\n\n\t* java/beans/EventHandler.java: New file.\n\t* Makefile.am (awt_java_source_files): Add EventHandler.java.\n\t* Makefile.in, gcj/Makefile.in, include/Makefile.in,\n\ttestsuite/Makefile.in: Regenerate.\n\nFrom-SVN: r84714", "tree": {"sha": "7c44e660e32d252e2f041e2f9a3a74d9fa12a630", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c44e660e32d252e2f041e2f9a3a74d9fa12a630"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12e8e7ea6db5d330599ac86ec971d228e2c2a59b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12e8e7ea6db5d330599ac86ec971d228e2c2a59b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12e8e7ea6db5d330599ac86ec971d228e2c2a59b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12e8e7ea6db5d330599ac86ec971d228e2c2a59b/comments", "author": null, "committer": null, "parents": [{"sha": "08b0dc1be57ef0eca483f684c76e3add21fbd507", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08b0dc1be57ef0eca483f684c76e3add21fbd507", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08b0dc1be57ef0eca483f684c76e3add21fbd507"}], "stats": {"total": 427, "additions": 415, "deletions": 12}, "files": [{"sha": "172c3721d8ae92ab042167d3fe52901dea8b33ea", "filename": "libjava/ChangeLog", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e8e7ea6db5d330599ac86ec971d228e2c2a59b/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e8e7ea6db5d330599ac86ec971d228e2c2a59b/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=12e8e7ea6db5d330599ac86ec971d228e2c2a59b", "patch": "@@ -1,3 +1,10 @@\n+2004-07-14  Jerry Quinn  <jlquinn@optonline.net>\n+\n+\t* java/beans/EventHandler.java: New file.\n+\t* Makefile.am (awt_java_source_files): Add EventHandler.java.\n+\t* Makefile.in, gcj/Makefile.in, include/Makefile.in,\n+\ttestsuite/Makefile.in: Regenerate.\n+\n 2004-07-14  Andreas Tobler  <a.tobler@schweiz.ch>\n \n \t* testsuite/libjava.jacks/jacks.exp (gcj_jacks_write): Add deprecation\n@@ -20,7 +27,7 @@\n 2004-07-14  Michael Koch  <konqueror@gmx.de> \n \t    Matthias Klose  <doko@debian.org> \n \n-\t* java/awt/im/InputContext.java: Initialze in, line.\n+\t* java/awt/im/InputContext.java: Initialize in, line.\n \n 2004-07-13  Ulrich Weigand  <uweigand@de.ibm.com>\n "}, {"sha": "fb7756131953521b7bb40c3befe11015d216bfe8", "filename": "libjava/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e8e7ea6db5d330599ac86ec971d228e2c2a59b/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e8e7ea6db5d330599ac86ec971d228e2c2a59b/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=12e8e7ea6db5d330599ac86ec971d228e2c2a59b", "patch": "@@ -1284,6 +1284,7 @@ java/beans/BeanInfo.java \\\n java/beans/Beans.java \\\n java/beans/Customizer.java \\\n java/beans/DesignMode.java \\\n+java/beans/EventHandler.java \\\n java/beans/EventSetDescriptor.java \\\n java/beans/ExceptionListener.java \\\n java/beans/Expression.java \\"}, {"sha": "d9c8a5fe1c808520052d1beb05e1075e3993db53", "filename": "libjava/Makefile.in", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e8e7ea6db5d330599ac86ec971d228e2c2a59b/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e8e7ea6db5d330599ac86ec971d228e2c2a59b/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=12e8e7ea6db5d330599ac86ec971d228e2c2a59b", "patch": "@@ -963,6 +963,7 @@ java/beans/BeanInfo.java \\\n java/beans/Beans.java \\\n java/beans/Customizer.java \\\n java/beans/DesignMode.java \\\n+java/beans/EventHandler.java \\\n java/beans/EventSetDescriptor.java \\\n java/beans/ExceptionListener.java \\\n java/beans/Expression.java \\\n@@ -3075,7 +3076,7 @@ libgcj-test.spec.in libgcj.pc.in libgcj.spec.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = gtar\n+TAR = tar\n GZIP_ENV = --best\n DIST_SUBDIRS =  @DIRLTDL@ testsuite gcj include @DIRLTDL@ gcj include\n DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n@@ -3732,7 +3733,8 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/awt/print/PrinterJob.P .deps/java/beans/AppletInitializer.P \\\n .deps/java/beans/BeanDescriptor.P .deps/java/beans/BeanInfo.P \\\n .deps/java/beans/Beans.P .deps/java/beans/Customizer.P \\\n-.deps/java/beans/DesignMode.P .deps/java/beans/EventSetDescriptor.P \\\n+.deps/java/beans/DesignMode.P .deps/java/beans/EventHandler.P \\\n+.deps/java/beans/EventSetDescriptor.P \\\n .deps/java/beans/ExceptionListener.P .deps/java/beans/Expression.P \\\n .deps/java/beans/FeatureDescriptor.P \\\n .deps/java/beans/IndexedPropertyDescriptor.P \\"}, {"sha": "1e4e84a41b38842f0eec84375c38c33bc78a1a33", "filename": "libjava/gcj/Makefile.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e8e7ea6db5d330599ac86ec971d228e2c2a59b/libjava%2Fgcj%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e8e7ea6db5d330599ac86ec971d228e2c2a59b/libjava%2Fgcj%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2FMakefile.in?ref=12e8e7ea6db5d330599ac86ec971d228e2c2a59b", "patch": "@@ -1,6 +1,6 @@\n-# Makefile.in generated automatically by automake 1.4-p6 from Makefile.am\n+# Makefile.in generated automatically by automake 1.4 from Makefile.am\n \n-# Copyright (C) 1994, 1995-8, 1999, 2001 Free Software Foundation, Inc.\n+# Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n@@ -172,7 +172,7 @@ DIST_COMMON =  ./stamp-h2.in Makefile.am Makefile.in libgcj-config.h.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = gtar\n+TAR = tar\n GZIP_ENV = --best\n all: all-redirect\n .SUFFIXES:\n@@ -260,7 +260,7 @@ TAGS:  $(HEADERS) $(SOURCES) libgcj-config.h.in $(TAGS_DEPENDENCIES) $(LISP)\n \t  awk '    { files[$$0] = 1; } \\\n \t       END { for (i in files) print i; }'`; \\\n \ttest -z \"$(ETAGS_ARGS)libgcj-config.h.in$$unique$(LISP)$$tags\" \\\n-\t  || (cd $(srcdir) && etags -o $$here/TAGS $(ETAGS_ARGS) $$tags libgcj-config.h.in $$unique $(LISP))\n+\t  || (cd $(srcdir) && etags $(ETAGS_ARGS) $$tags libgcj-config.h.in $$unique $(LISP) -o $$here/TAGS)\n \n mostlyclean-tags:\n "}, {"sha": "72e0a25af00ad099f0723e990ddff67cb448b6f4", "filename": "libjava/include/Makefile.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e8e7ea6db5d330599ac86ec971d228e2c2a59b/libjava%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e8e7ea6db5d330599ac86ec971d228e2c2a59b/libjava%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2FMakefile.in?ref=12e8e7ea6db5d330599ac86ec971d228e2c2a59b", "patch": "@@ -1,6 +1,6 @@\n-# Makefile.in generated automatically by automake 1.4-p6 from Makefile.am\n+# Makefile.in generated automatically by automake 1.4 from Makefile.am\n \n-# Copyright (C) 1994, 1995-8, 1999, 2001 Free Software Foundation, Inc.\n+# Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n@@ -168,7 +168,7 @@ DIST_COMMON =  ./stamp-h1.in Makefile.am Makefile.in config.h.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = gtar\n+TAR = tar\n GZIP_ENV = --best\n all: all-redirect\n .SUFFIXES:\n@@ -241,7 +241,7 @@ TAGS:  $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) $(LISP)\n \t  awk '    { files[$$0] = 1; } \\\n \t       END { for (i in files) print i; }'`; \\\n \ttest -z \"$(ETAGS_ARGS)config.h.in$$unique$(LISP)$$tags\" \\\n-\t  || (cd $(srcdir) && etags -o $$here/TAGS $(ETAGS_ARGS) $$tags config.h.in $$unique $(LISP))\n+\t  || (cd $(srcdir) && etags $(ETAGS_ARGS) $$tags config.h.in $$unique $(LISP) -o $$here/TAGS)\n \n mostlyclean-tags:\n "}, {"sha": "6a7d1850de514bfaa349e94dbcec4bbc4a59ecaf", "filename": "libjava/java/beans/EventHandler.java", "status": "added", "additions": 393, "deletions": 0, "changes": 393, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e8e7ea6db5d330599ac86ec971d228e2c2a59b/libjava%2Fjava%2Fbeans%2FEventHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e8e7ea6db5d330599ac86ec971d228e2c2a59b/libjava%2Fjava%2Fbeans%2FEventHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FEventHandler.java?ref=12e8e7ea6db5d330599ac86ec971d228e2c2a59b", "patch": "@@ -0,0 +1,393 @@\n+/* java.beans.EventHandler\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.beans;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+\n+/**\n+ * class EventHandler\n+ *\n+ * EventHandler forms a bridge between dynamically created listeners and\n+ * arbitrary properties and methods.  The idea is that a Proxy that implements\n+ * a listener class calls the EventHandler when a listener method is called.\n+ * The Proxy calls invoke(), which dispatches the event to a method, called\n+ * the action, in another object, called the target.\n+ *\n+ * The event passed to the listener method is used to access a prespecified\n+ * property, which in turn is passed to the action method.\n+ * \n+ * Normally, call EventHandler.create(), which constructs an EventHandler and\n+ * a Proxy for the listener interface.  When the listenerMethod gets called on\n+ * the proxy, it in turn calls invoke on the attached EventHandler.  The\n+ * invoke call extracts the bean property from the event object and passes it\n+ * to the action method of target object.\n+ *\n+ * TODO: Add examples of using this thing.\n+ * \n+ * @author Jerry Quinn (jlquinn@optonline.net)\n+ * @since 1.4\n+ */\n+public class EventHandler implements InvocationHandler\n+{\n+  // The name of the method that will be implemented.  If null, any method.\n+  private String listenerMethod;\n+\n+  // The object to call action on.\n+  private Object target;\n+\n+  // The name of the method or property setter in target.\n+  private String action;\n+\n+  // The property to extract from an event passed to listenerMethod.\n+  private String property;\n+\n+  // String class doesn't already have a capitalize routine.\n+  final private String capitalize(String s)\n+  {\n+    return s.substring(0, 1).toUpperCase() + s.substring(1);\n+  }\n+\n+  /**\n+   * Creates a new <code>EventHandler</code> instance.\n+   *\n+   * Typical creation is done with the create method, not by newing an\n+   * EventHandler.\n+   *\n+   * This constructs an EventHandler that will connect the method\n+   * listenerMethodName to target.action, extracting eventPropertyName from\n+   * the first argument of listenerMethodName. and sending it to action.\n+   *\n+   *\n+   *\n+   * @param target Object that will perform the action.\n+   * @param action A property or method of the target.\n+   * @param eventPropertyName A readable property of the inbound event.\n+   * @param listenerMethodName The listener method name triggering the action.\n+   */\n+  public EventHandler(Object target, String action, String eventPropertyName,\n+\t\t      String listenerMethodName)\n+  {\n+    this.target = target;\n+    this.action = action;\t// Turn this into a method or do we wait till\n+\t\t\t\t// runtime\n+    property = eventPropertyName;\n+    listenerMethod = listenerMethodName;\n+  }\n+\n+  /**\n+   * Return the event property name.\n+   */\n+  public String getEventPropertyName()\n+  {\n+    return property;\n+  }\n+\n+  /**\n+   * Return the listener's method name.\n+   */\n+  public String getListenerMethodName()\n+  {\n+    return listenerMethod;\n+  }\n+\n+  /**\n+   * Return the target object.\n+   */\n+  public Object getTarget()\n+  {\n+    return target;\n+  }\n+\n+  /**\n+   * Return the action method name.\n+   */\n+  public String getAction()\n+  {\n+    return action;\n+  }\n+\n+  // Fetch a qualified property like a.b.c from object o.  The properties can\n+  // be boolean isProp or object getProp properties.\n+  //\n+  // Returns a length 2 array with the first entry containing the value\n+  // extracted from the property, and the second entry contains the class of\n+  // the method return type.\n+  //\n+  // We play this game because if the method returns a native type, the return\n+  // value will be a wrapper.  If we then take the type of the wrapper and use\n+  // it to locate the action method that takes the native type, it won't match.\n+  private Object[] getProperty(Object o, String prop)\n+    throws NoSuchMethodException, IllegalAccessException, InvocationTargetException\n+  {\n+    // Use the event object when the property name to extract is null.\n+    if (prop == null)\n+      return new Object[] {o, o.getClass()};\n+\n+    // Isolate the first property name from a.b.c.\n+    int pos;\n+    String rest = null;\n+    if ((pos = prop.indexOf('.')) != -1)\n+      {\n+\trest = prop.substring(pos + 1);\n+\tprop = prop.substring(0, pos);\n+      }\n+\n+    // Find a method named getProp.  It could be isProp instead.\n+    Method getter;\n+    try\n+      {\n+\t// Look for boolean property getter isProperty\n+\tgetter = o.getClass().getMethod(\"is\" + capitalize(prop),\n+\t\t\t\t\t\t null);\n+      }\n+    catch (NoSuchMethodException e)\n+      {\n+\t// Look for regular property getter getProperty\n+\tgetter = o.getClass().getMethod(\"get\" + capitalize(prop),\n+\t\t\t\t\t\t null);\n+      }\n+    Object val = getter.invoke(o, null);\n+\n+    if (rest != null)\n+      return getProperty(val, rest);\n+\n+    return new Object[] {val, getter.getReturnType()};\n+  }\n+\n+\n+  /**\n+   * Invoke the event handler.\n+   *\n+   * Proxy is the object that was used, method is the method that was invoked\n+   * on object, and arguments is the set of arguments passed to this method.\n+   * We assume that the first argument is the event to extract a property\n+   * from.\n+   *\n+   * Assuming that method matches the listener method specified when creating\n+   * this EventHandler, the desired property is extracted from this argument.\n+   * The property is passed to target.setAction(), if possible.  Otherwise\n+   * target.action() is called, where action is the string fed to the\n+   * constructor.\n+   *\n+   * For now we punt on indexed properties.  Sun docs are not clear to me\n+   * about this.\n+   *\n+   * @param proxy The proxy object that had method invoked on it.\n+   * @param method The method that was invoked.\n+   * @param arguments Arguments to method.\n+   * @return Result of invoking target.action on the event property\n+   */\n+  public Object invoke(Object proxy, Method method, Object[] arguments)\n+    throws Exception\n+  {\n+    // Do we actually need the proxy?\n+    if (method == null)\n+      throw new RuntimeException(\"Invoking null method\");\n+\n+    // Listener methods that weren't specified are ignored.  If listenerMethod\n+    // is null, then all listener methods are processed.\n+    if (listenerMethod != null && !method.getName().equals(listenerMethod))\n+      return null;\n+\n+    // Extract the first arg from arguments and do getProperty on arg\n+    if (arguments == null || arguments.length == 0)\n+      return null;\n+    Object event = arguments[0]; // We hope :-)\n+\n+    // Obtain the property XXX propertyType keeps showing up null - why?\n+    // because the object inside getProperty changes, but the ref variable\n+    // can't change this way, dolt!  need a better way to get both values out\n+    // - need method and object to do the invoke and get return type\n+    Object v[] = getProperty(event, property);\n+    Object val = v[0];\n+    Class propertyType = (Class) v[1];\n+\n+    System.out.println(\"ptype=\"+propertyType.getName());\n+    System.out.println(\" val=\"+((val==null)?\"null\":val.toString()));\n+    \n+    // Find the actual method of target to invoke.  We can't do this in the\n+    // constructor since we don't know the type of the property we extracted\n+    // from the event then.\n+    //\n+    // action can be either a property or a method.  Sun's docs seem to imply\n+    // that action should be treated as a property first, and then a method,\n+    // but don't specifically say it.\n+    //\n+    // XXX check what happens with native type wrappers.  The better thing to\n+    // do is look at the return type of the method\n+    Method actionMethod;\n+    try\n+      {\n+\t// Look for a property setter for action.\n+\tactionMethod = \n+\t  target.getClass().getMethod(\"set\" + capitalize(action),\n+\t\t\t\t      new Class[] {propertyType});\n+      }\n+    catch (NoSuchMethodException e)\n+      {\n+\t// If action as property didn't work, try as method.\n+\ttry\n+\t  {\n+\t    actionMethod = \n+\t      target.getClass().getMethod(action, new Class[] {propertyType});\n+\t  }\n+\tcatch (NoSuchMethodException e1)\n+\t  {\n+\t    // When event property is null, we may call action with no args\n+\t    if (property == null)\n+\t      {\n+\t\tactionMethod =\n+\t\t  target.getClass().getMethod(action, null);\n+\t\treturn actionMethod.invoke(target, null);\n+\t      }\n+\t    else\n+\t      throw e1;\n+\t  }\n+      }\n+\n+    // Invoke target.action(property)\n+    return actionMethod.invoke(target, new Object[] {val});\n+  }\n+\n+  /**\n+   * Construct a new object to dispatch events.\n+   *\n+   * Equivalent to:\n+   * create(listenerInterface, target, action, null, null)\n+   *\n+   * I.e. all listenerInterface methods are mapped to\n+   * target.action(EventObject) or target.action(), if the first doesn't\n+   * exist.\n+   *\n+   * @param listenerInterface Listener interface to implement.\n+   * @param target Object to invoke action on.\n+   * @param action Target property or method to invoke.\n+   * @return A constructed proxy object.\n+   */\n+  public static Object create(Class listenerInterface, Object target, String action)\n+  {\n+    return create(listenerInterface, target, action, null, null);\n+  }\n+\n+  /**\n+   * Construct a new object to dispatch events.\n+   *\n+   * Equivalent to:\n+   * create(listenerInterface, target, action, eventPropertyName, null)\n+   *\n+   * I.e. all listenerInterface methods are mapped to\n+   * target.action(event.getEventPropertyName)\n+   * \n+   *\n+   * @param listenerInterface Listener interface to implement.\n+   * @param target Object to invoke action on.\n+   * @param action Target property or method to invoke.\n+   * @param eventPropertyName Name of property to extract from event.\n+   * @return A constructed proxy object.\n+   */\n+  public static Object create(Class listenerInterface, Object target,\n+\t\t\t      String action, String eventPropertyName)\n+  {\n+    return create(listenerInterface, target, action, eventPropertyName, null);\n+  }\n+\n+\n+  /**\n+   * Construct a new object to dispatch events.\n+   *\n+   * This creates an object that acts as a proxy for the method\n+   * listenerMethodName in listenerInterface.  When the listener method is\n+   * activated, the object extracts eventPropertyName from the event.  Then it\n+   * passes the property to the method target.setAction, or target.action if\n+   * action is not a property with a setter.\n+   *\n+   * For example, EventHandler.create(MouseListener.class, test, \"pushed\",\n+   * \"button\", \"mouseClicked\") generates a proxy object that implements\n+   * MouseListener, at least for the method mouseClicked().  The other methods\n+   * of MouseListener are null operations.  When mouseClicked is invoked, the\n+   * generated object extracts the button property from the MouseEvent,\n+   * i.e. event.getButton(), and calls test.setPushed() with the result.  So under\n+   * the covers the following happens:\n+   *\n+   * <CODE>\n+   * object.mouseClicked(MouseEvent e) { test.setPushed(e.getButton()); }\n+   * </CODE>\n+   *\n+   * The Sun spec specifies a hierarchical property naming scheme.  Generally\n+   * if the property is a.b.c, this corresponds to event.getA().getB().getC()\n+   * or event.getA().getB().isC().  I don't see how you specify an indexed\n+   * property, though.  This may be a limitation of the Sun implementation as\n+   * well.  The spec doesn't seem to address it.\n+   * \n+   * If eventPropertyName is null, EventHandler instead uses the event object\n+   * in place of a property, i.e. it calls target.action(EventObject).  If\n+   * there is no method named action taking an EventObject argument,\n+   * EventHandler looks for a method target.action() taking no arguments.\n+   *\n+   * If listenerMethodName is null, every method in listenerInterface gets\n+   * mapped to target.action, rather than the specified listener method.\n+   * \n+   * @param listenerInterface Listener interface to implement.\n+   * @param target Object to invoke action on.\n+   * @param action Target method name to invoke.\n+   * @param eventPropertyName Name of property to extract from event.\n+   * @param listenerMethodName Listener method to implement.\n+   * @return A constructed proxy object.\n+   */\n+  public static Object create(Class listenerInterface, Object target,\n+\t\t\t      String action, String eventPropertyName,\n+\t\t\t      String listenerMethodName)\n+  {\n+    // Create EventHandler instance\n+    EventHandler eh = new EventHandler(target, action, eventPropertyName,\n+\t\t\t\t       listenerMethodName);\n+\n+    // Create proxy object passing in the event handler\n+    Object proxy = Proxy.newProxyInstance(listenerInterface.getClassLoader(),\n+\t\t\t\t\t  new Class[] {listenerInterface},\n+\t\t\t\t\t  eh);\n+\n+    return proxy;\n+  }\n+\n+}"}, {"sha": "79a8283762189cc64686572e01b23925fe741573", "filename": "libjava/testsuite/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e8e7ea6db5d330599ac86ec971d228e2c2a59b/libjava%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e8e7ea6db5d330599ac86ec971d228e2c2a59b/libjava%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2FMakefile.in?ref=12e8e7ea6db5d330599ac86ec971d228e2c2a59b", "patch": "@@ -177,7 +177,7 @@ DIST_COMMON =  Makefile.am Makefile.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = gtar\n+TAR = tar\n GZIP_ENV = --best\n all: all-redirect\n .SUFFIXES:"}]}