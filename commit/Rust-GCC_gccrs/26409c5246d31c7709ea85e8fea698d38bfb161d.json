{"sha": "26409c5246d31c7709ea85e8fea698d38bfb161d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY0MDljNTI0NmQzMWM3NzA5ZWE4NWU4ZmVhNjk4ZDM4YmZiMTYxZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2011-04-21T22:54:23Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-04-21T22:54:23Z"}, "message": "Define go_assert to replace gcc_assert\n\nThis is defined in go-system.h in the backend.\n\n\t* go-system.h (go_assert, go_unreachable): Define.\n\nFrom-SVN: r172846", "tree": {"sha": "333b76ad2a9f76196ed6057be0e17646cc4eddd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/333b76ad2a9f76196ed6057be0e17646cc4eddd5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26409c5246d31c7709ea85e8fea698d38bfb161d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26409c5246d31c7709ea85e8fea698d38bfb161d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26409c5246d31c7709ea85e8fea698d38bfb161d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26409c5246d31c7709ea85e8fea698d38bfb161d/comments", "author": null, "committer": null, "parents": [{"sha": "3a6448ea919d0118ae5f4b65121e2d2042b917c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a6448ea919d0118ae5f4b65121e2d2042b917c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a6448ea919d0118ae5f4b65121e2d2042b917c7"}], "stats": {"total": 1200, "additions": 605, "deletions": 595}, "files": [{"sha": "aa713dbb0a8be5dbb3016cfa5dd6ab1db16bad06", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=26409c5246d31c7709ea85e8fea698d38bfb161d", "patch": "@@ -1,3 +1,7 @@\n+2011-04-21  Ian Lance Taylor  <iant@google.com>\n+\n+\t* go-system.h (go_assert, go_unreachable): Define.\n+\n 2011-04-19  Ian Lance Taylor  <iant@google.com>\n \n \t* go-system.h: Include \"intl.h\"."}, {"sha": "08aac6a0f720355edb2657b308d8e9d12dbd6341", "filename": "gcc/go/go-system.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgo-system.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgo-system.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-system.h?ref=26409c5246d31c7709ea85e8fea698d38bfb161d", "patch": "@@ -151,4 +151,10 @@ extern \"C\"\n } // End extern \"C\"\n #endif\n \n+// When using gcc, go_assert is just gcc_assert.\n+#define go_assert(EXPR) gcc_assert(EXPR)\n+\n+// When using gcc, go_unreachable is just gcc_unreachable.\n+#define go_unreachable() gcc_unreachable()\n+\n #endif // !defined(GO_SYSTEM_H)"}, {"sha": "c2c9e76fd70b149d99f3d07253b150832873ab83", "filename": "gcc/go/gofrontend/README", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FREADME?ref=26409c5246d31c7709ea85e8fea698d38bfb161d", "patch": "@@ -24,7 +24,7 @@ Issues to be faced in this transition:\n     features such as %<%> for appropriate quoting.\n   + Localization may be an issue.\n \n-* Use of gcc_assert and gcc_unreachable.\n+* Use of gcc_unreachable.\n \n This compiler works, but the code is a work in progress.  Notably, the\n support for garbage collection is ineffective and needs a complete"}, {"sha": "94f26286b50032b0efadd5d0a3a21660d3827c78", "filename": "gcc/go/gofrontend/dataflow.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Fdataflow.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Fdataflow.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fdataflow.cc?ref=26409c5246d31c7709ea85e8fea698d38bfb161d", "patch": "@@ -49,7 +49,7 @@ get_var(Expression* expr)\n   if (ve == NULL)\n     return NULL;\n   Named_object* no = ve->named_object();\n-  gcc_assert(no->is_variable() || no->is_result_variable());\n+  go_assert(no->is_variable() || no->is_result_variable());\n   if (no->is_variable() && no->var_value()->is_global())\n     return NULL;\n   return no;\n@@ -103,7 +103,7 @@ Dataflow_traverse_assignment::initialize_variable(Named_object* var)\n     {\n       Expression* e = init;\n       this->value(&e, true, true);\n-      gcc_assert(e == init);\n+      go_assert(e == init);\n     }\n }\n "}, {"sha": "538fb97ce6806f63b94bdacee512616d01d171f8", "filename": "gcc/go/gofrontend/export.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.cc?ref=26409c5246d31c7709ea85e8fea698d38bfb161d", "patch": "@@ -266,7 +266,7 @@ Export::write_type(const Type* type)\n     {\n       // This type was already in the table.\n       int index = p->second;\n-      gcc_assert(index != 0);\n+      go_assert(index != 0);\n       char buf[30];\n       snprintf(buf, sizeof buf, \"<type %d>\", index);\n       this->write_c_string(buf);\n@@ -289,7 +289,7 @@ Export::write_type(const Type* type)\n       if (named_type != NULL)\n \t{\n \t  // The builtin types should have been predefined.\n-\t  gcc_assert(named_type->location() != BUILTINS_LOCATION\n+\t  go_assert(named_type->location() != BUILTINS_LOCATION\n \t\t     || (named_type->named_object()->package()->name()\n \t\t\t == \"unsafe\"));\n \t  named_object = named_type->named_object();\n@@ -355,16 +355,16 @@ void\n Export::register_builtin_type(Gogo* gogo, const char* name, Builtin_code code)\n {\n   Named_object* named_object = gogo->lookup_global(name);\n-  gcc_assert(named_object != NULL && named_object->is_type());\n+  go_assert(named_object != NULL && named_object->is_type());\n   std::pair<Type_refs::iterator, bool> ins =\n     this->type_refs_.insert(std::make_pair(named_object->type_value(), code));\n-  gcc_assert(ins.second);\n+  go_assert(ins.second);\n \n   // We also insert the underlying type.  We can see the underlying\n   // type at least for string and bool.\n   Type* real_type = named_object->type_value()->real_type();\n   ins = this->type_refs_.insert(std::make_pair(real_type, code));\n-  gcc_assert(ins.second);\n+  go_assert(ins.second);\n }\n \n // Class Export::Stream.\n@@ -428,7 +428,7 @@ Stream_to_section::do_write(const char* bytes, size_t length)\n   section* sec = (section*) this->section_;\n   if (sec == NULL)\n     {\n-      gcc_assert(targetm.have_named_sections);\n+      go_assert(targetm.have_named_sections);\n \n       sec = get_section(\".go_export\", SECTION_DEBUG, NULL);\n       this->section_ = (void*) sec;"}, {"sha": "ee065bfefab11311bddca006fbadd7fb2e356018", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 143, "deletions": 143, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=26409c5246d31c7709ea85e8fea698d38bfb161d", "patch": "@@ -236,27 +236,27 @@ Expression::convert_for_assignment(Translate_context* context, Type* lhs_type,\n \t   && rhs_type->is_nil_type())\n     {\n       // Assigning nil to an open array.\n-      gcc_assert(TREE_CODE(lhs_type_tree) == RECORD_TYPE);\n+      go_assert(TREE_CODE(lhs_type_tree) == RECORD_TYPE);\n \n       VEC(constructor_elt,gc)* init = VEC_alloc(constructor_elt, gc, 3);\n \n       constructor_elt* elt = VEC_quick_push(constructor_elt, init, NULL);\n       tree field = TYPE_FIELDS(lhs_type_tree);\n-      gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)),\n+      go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)),\n \t\t\t\"__values\") == 0);\n       elt->index = field;\n       elt->value = fold_convert(TREE_TYPE(field), null_pointer_node);\n \n       elt = VEC_quick_push(constructor_elt, init, NULL);\n       field = DECL_CHAIN(field);\n-      gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)),\n+      go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)),\n \t\t\t\"__count\") == 0);\n       elt->index = field;\n       elt->value = fold_convert(TREE_TYPE(field), integer_zero_node);\n \n       elt = VEC_quick_push(constructor_elt, init, NULL);\n       field = DECL_CHAIN(field);\n-      gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)),\n+      go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)),\n \t\t\t\"__capacity\") == 0);\n       elt->index = field;\n       elt->value = fold_convert(TREE_TYPE(field), integer_zero_node);\n@@ -270,7 +270,7 @@ Expression::convert_for_assignment(Translate_context* context, Type* lhs_type,\n     {\n       // The left hand side should be a pointer type at the tree\n       // level.\n-      gcc_assert(POINTER_TYPE_P(lhs_type_tree));\n+      go_assert(POINTER_TYPE_P(lhs_type_tree));\n       return fold_convert(lhs_type_tree, null_pointer_node);\n     }\n   else if (lhs_type_tree == TREE_TYPE(rhs_tree))\n@@ -288,14 +288,14 @@ Expression::convert_for_assignment(Translate_context* context, Type* lhs_type,\n     {\n       // This conversion must be permitted by Go, or we wouldn't have\n       // gotten here.\n-      gcc_assert(int_size_in_bytes(lhs_type_tree)\n+      go_assert(int_size_in_bytes(lhs_type_tree)\n \t\t == int_size_in_bytes(TREE_TYPE(rhs_tree)));\n       return fold_build1_loc(location, VIEW_CONVERT_EXPR, lhs_type_tree,\n \t\t\t     rhs_tree);\n     }\n   else\n     {\n-      gcc_assert(useless_type_conversion_p(lhs_type_tree, TREE_TYPE(rhs_tree)));\n+      go_assert(useless_type_conversion_p(lhs_type_tree, TREE_TYPE(rhs_tree)));\n       return rhs_tree;\n     }\n }\n@@ -321,7 +321,7 @@ Expression::convert_type_to_interface(Translate_context* context,\n     return lhs_type->get_init_tree(gogo, false);\n \n   // This should have been checked already.\n-  gcc_assert(lhs_interface_type->implements_interface(rhs_type, NULL));\n+  go_assert(lhs_interface_type->implements_interface(rhs_type, NULL));\n \n   tree lhs_type_tree = lhs_type->get_tree(gogo);\n   if (lhs_type_tree == error_mark_node)\n@@ -364,14 +364,14 @@ Expression::convert_type_to_interface(Translate_context* context,\n \n   constructor_elt* elt = VEC_quick_push(constructor_elt, init, NULL);\n   tree field = TYPE_FIELDS(lhs_type_tree);\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)),\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)),\n \t\t    (lhs_is_empty ? \"__type_descriptor\" : \"__methods\")) == 0);\n   elt->index = field;\n   elt->value = fold_convert_loc(location, TREE_TYPE(field), first_field_value);\n \n   elt = VEC_quick_push(constructor_elt, init, NULL);\n   field = DECL_CHAIN(field);\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__object\") == 0);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__object\") == 0);\n   elt->index = field;\n \n   if (rhs_type->points_to() != NULL)\n@@ -413,25 +413,25 @@ Expression::get_interface_type_descriptor(Translate_context*,\n \t\t\t\t\t  source_location location)\n {\n   tree rhs_type_tree = TREE_TYPE(rhs_tree);\n-  gcc_assert(TREE_CODE(rhs_type_tree) == RECORD_TYPE);\n+  go_assert(TREE_CODE(rhs_type_tree) == RECORD_TYPE);\n   tree rhs_field = TYPE_FIELDS(rhs_type_tree);\n   tree v = build3(COMPONENT_REF, TREE_TYPE(rhs_field), rhs_tree, rhs_field,\n \t\t  NULL_TREE);\n   if (rhs_type->interface_type()->is_empty())\n     {\n-      gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(rhs_field)),\n+      go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(rhs_field)),\n \t\t\t\"__type_descriptor\") == 0);\n       return v;\n     }\n \n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(rhs_field)), \"__methods\")\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(rhs_field)), \"__methods\")\n \t     == 0);\n-  gcc_assert(POINTER_TYPE_P(TREE_TYPE(v)));\n+  go_assert(POINTER_TYPE_P(TREE_TYPE(v)));\n   v = save_expr(v);\n   tree v1 = build_fold_indirect_ref_loc(location, v);\n-  gcc_assert(TREE_CODE(TREE_TYPE(v1)) == RECORD_TYPE);\n+  go_assert(TREE_CODE(TREE_TYPE(v1)) == RECORD_TYPE);\n   tree f = TYPE_FIELDS(TREE_TYPE(v1));\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(f)), \"__type_descriptor\")\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(f)), \"__type_descriptor\")\n \t     == 0);\n   v1 = build3(COMPONENT_REF, TREE_TYPE(f), v1, f, NULL_TREE);\n \n@@ -510,16 +510,16 @@ Expression::convert_interface_to_interface(Translate_context* context,\n     {\n       // A convertion to an empty interface always succeeds, and the\n       // first field is just the type descriptor of the object.\n-      gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)),\n+      go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)),\n \t\t\t\"__type_descriptor\") == 0);\n-      gcc_assert(TREE_TYPE(field) == TREE_TYPE(rhs_type_descriptor));\n+      go_assert(TREE_TYPE(field) == TREE_TYPE(rhs_type_descriptor));\n       elt->value = rhs_type_descriptor;\n     }\n   else\n     {\n       // A conversion to a non-empty interface may fail, but unlike a\n       // type assertion converting nil will always succeed.\n-      gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__methods\")\n+      go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__methods\")\n \t\t == 0);\n       tree lhs_type_descriptor = lhs_type->type_descriptor_pointer(gogo);\n       static tree convert_interface_decl;\n@@ -543,13 +543,13 @@ Expression::convert_interface_to_interface(Translate_context* context,\n \n   elt = VEC_quick_push(constructor_elt, init, NULL);\n   field = DECL_CHAIN(field);\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__object\") == 0);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__object\") == 0);\n   elt->index = field;\n \n   tree rhs_type_tree = TREE_TYPE(rhs_tree);\n-  gcc_assert(TREE_CODE(rhs_type_tree) == RECORD_TYPE);\n+  go_assert(TREE_CODE(rhs_type_tree) == RECORD_TYPE);\n   tree rhs_field = DECL_CHAIN(TYPE_FIELDS(rhs_type_tree));\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(rhs_field)), \"__object\") == 0);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(rhs_field)), \"__object\") == 0);\n   elt->value = build3(COMPONENT_REF, TREE_TYPE(rhs_field), rhs_tree, rhs_field,\n \t\t      NULL_TREE);\n \n@@ -604,9 +604,9 @@ Expression::convert_interface_to_type(Translate_context* context,\n   TREE_NOTHROW(check_interface_type_decl) = 0;\n \n   // If the call succeeds, pull out the value.\n-  gcc_assert(TREE_CODE(rhs_type_tree) == RECORD_TYPE);\n+  go_assert(TREE_CODE(rhs_type_tree) == RECORD_TYPE);\n   tree rhs_field = DECL_CHAIN(TYPE_FIELDS(rhs_type_tree));\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(rhs_field)), \"__object\") == 0);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(rhs_field)), \"__object\") == 0);\n   tree val = build3(COMPONENT_REF, TREE_TYPE(rhs_field), rhs_tree, rhs_field,\n \t\t    NULL_TREE);\n \n@@ -902,7 +902,7 @@ Parser_expression::do_type()\n   // However, it can happen, at least when we have an invalid const\n   // whose initializer refers to the const itself.  In that case we\n   // may ask for the type when lowering the const itself.\n-  gcc_assert(saw_errors());\n+  go_assert(saw_errors());\n   return Type::make_error_type();\n }\n \n@@ -1118,7 +1118,7 @@ Sink_expression::do_get_tree(Translate_context* context)\n {\n   if (this->var_ == NULL_TREE)\n     {\n-      gcc_assert(this->type_ != NULL && !this->type_->is_sink_type());\n+      go_assert(this->type_ != NULL && !this->type_->is_sink_type());\n       this->var_ = create_tmp_var(this->type_->get_tree(context->gogo()),\n \t\t\t\t  \"blank\");\n     }\n@@ -1219,15 +1219,15 @@ Func_expression::do_get_tree(Translate_context* context)\n   if (fnaddr == error_mark_node)\n     return error_mark_node;\n \n-  gcc_assert(TREE_CODE(fnaddr) == ADDR_EXPR\n+  go_assert(TREE_CODE(fnaddr) == ADDR_EXPR\n \t     && TREE_CODE(TREE_OPERAND(fnaddr, 0)) == FUNCTION_DECL);\n   TREE_ADDRESSABLE(TREE_OPERAND(fnaddr, 0)) = 1;\n \n   // For a normal non-nested function call, that is all we have to do.\n   if (!this->function_->is_function()\n       || this->function_->func_value()->enclosing() == NULL)\n     {\n-      gcc_assert(this->closure_ == NULL);\n+      go_assert(this->closure_ == NULL);\n       return fnaddr;\n     }\n \n@@ -1245,7 +1245,7 @@ Func_expression::do_get_tree(Translate_context* context)\n       closure_tree = closure->get_tree(context);\n       if (closure_tree == error_mark_node)\n \treturn error_mark_node;\n-      gcc_assert(POINTER_TYPE_P(TREE_TYPE(closure_tree)));\n+      go_assert(POINTER_TYPE_P(TREE_TYPE(closure_tree)));\n     }\n \n   // Now we need to build some code on the heap.  This code will load\n@@ -1330,7 +1330,7 @@ Unknown_expression::do_lower(Gogo*, Named_object*, int)\n Expression*\n Expression::make_unknown_reference(Named_object* no, source_location location)\n {\n-  gcc_assert(no->resolve()->is_unknown());\n+  go_assert(no->resolve()->is_unknown());\n   return new Unknown_expression(no, location);\n }\n \n@@ -2009,7 +2009,7 @@ Float_expression::do_check_types(Gogo*)\n \tthis->report_error(_(\"floating point constant truncated to integer\"));\n       else\n \t{\n-\t  gcc_assert(!integer_type->is_abstract());\n+\t  go_assert(!integer_type->is_abstract());\n \t  mpz_t ival;\n \t  mpz_init(ival);\n \t  mpfr_get_z(ival, this->val_, GMP_RNDN);\n@@ -3422,7 +3422,7 @@ Type_conversion_expression::do_get_tree(Translate_context* context)\n \texpr_tree = save_expr(expr_tree);\n       Array_type* a = t->array_type();\n       Type* e = a->element_type()->forwarded();\n-      gcc_assert(e->integer_type() != NULL);\n+      go_assert(e->integer_type() != NULL);\n       tree valptr = fold_convert(const_ptr_type_node,\n \t\t\t\t a->value_pointer_tree(gogo, expr_tree));\n       tree len = a->length_tree(gogo, expr_tree);\n@@ -3443,7 +3443,7 @@ Type_conversion_expression::do_get_tree(Translate_context* context)\n \t}\n       else\n \t{\n-\t  gcc_assert(e == Type::lookup_integer_type(\"int\"));\n+\t  go_assert(e == Type::lookup_integer_type(\"int\"));\n \t  static tree int_array_to_string_fndecl;\n \t  ret = Gogo::call_builtin(&int_array_to_string_fndecl,\n \t\t\t\t   this->location(),\n@@ -3459,7 +3459,7 @@ Type_conversion_expression::do_get_tree(Translate_context* context)\n   else if (type->is_open_array_type() && expr_type->is_string_type())\n     {\n       Type* e = type->array_type()->element_type()->forwarded();\n-      gcc_assert(e->integer_type() != NULL);\n+      go_assert(e->integer_type() != NULL);\n       if (e->integer_type()->is_unsigned()\n \t  && e->integer_type()->bits() == 8)\n \t{\n@@ -3474,7 +3474,7 @@ Type_conversion_expression::do_get_tree(Translate_context* context)\n \t}\n       else\n \t{\n-\t  gcc_assert(e == Type::lookup_integer_type(\"int\"));\n+\t  go_assert(e == Type::lookup_integer_type(\"int\"));\n \t  static tree string_to_int_array_fndecl;\n \t  ret = Gogo::call_builtin(&string_to_int_array_fndecl,\n \t\t\t\t   this->location(),\n@@ -3611,36 +3611,36 @@ Unsafe_type_conversion_expression::do_get_tree(Translate_context* context)\n   bool use_view_convert = false;\n   if (t->is_open_array_type())\n     {\n-      gcc_assert(et->is_open_array_type());\n+      go_assert(et->is_open_array_type());\n       use_view_convert = true;\n     }\n   else if (t->map_type() != NULL)\n-    gcc_assert(et->map_type() != NULL);\n+    go_assert(et->map_type() != NULL);\n   else if (t->channel_type() != NULL)\n-    gcc_assert(et->channel_type() != NULL);\n+    go_assert(et->channel_type() != NULL);\n   else if (t->points_to() != NULL && t->points_to()->channel_type() != NULL)\n-    gcc_assert((et->points_to() != NULL\n+    go_assert((et->points_to() != NULL\n \t\t&& et->points_to()->channel_type() != NULL)\n \t       || et->is_nil_type());\n   else if (t->is_unsafe_pointer_type())\n-    gcc_assert(et->points_to() != NULL || et->is_nil_type());\n+    go_assert(et->points_to() != NULL || et->is_nil_type());\n   else if (et->is_unsafe_pointer_type())\n-    gcc_assert(t->points_to() != NULL);\n+    go_assert(t->points_to() != NULL);\n   else if (t->interface_type() != NULL && !t->interface_type()->is_empty())\n     {\n-      gcc_assert(et->interface_type() != NULL\n+      go_assert(et->interface_type() != NULL\n \t\t && !et->interface_type()->is_empty());\n       use_view_convert = true;\n     }\n   else if (t->interface_type() != NULL && t->interface_type()->is_empty())\n     {\n-      gcc_assert(et->interface_type() != NULL\n+      go_assert(et->interface_type() != NULL\n \t\t && et->interface_type()->is_empty());\n       use_view_convert = true;\n     }\n   else if (t->integer_type() != NULL)\n     {\n-      gcc_assert(et->is_boolean_type()\n+      go_assert(et->is_boolean_type()\n \t\t || et->integer_type() != NULL\n \t\t || et->function_type() != NULL\n \t\t || et->points_to() != NULL\n@@ -3690,7 +3690,7 @@ class Unary_expression : public Expression\n   void\n   set_does_not_escape()\n   {\n-    gcc_assert(this->op_ == OPERATOR_AND);\n+    go_assert(this->op_ == OPERATOR_AND);\n     this->escapes_ = false;\n   }\n \n@@ -3950,15 +3950,15 @@ Unary_expression::eval_integer(Operator op, Type* utype, mpz_t uval, mpz_t val,\n \n \t  size_t ecount;\n \t  mpz_export(phwi, &ecount, -1, sizeof(HOST_WIDE_INT), 0, 0, uval);\n-\t  gcc_assert(ecount <= count);\n+\t  go_assert(ecount <= count);\n \n \t  // Trim down to the number of words required by the type.\n \t  size_t obits = utype->integer_type()->bits();\n \t  if (!utype->integer_type()->is_unsigned())\n \t    ++obits;\n \t  size_t ocount = ((obits + HOST_BITS_PER_WIDE_INT - 1)\n \t\t\t   / HOST_BITS_PER_WIDE_INT);\n-\t  gcc_assert(ocount <= count);\n+\t  go_assert(ocount <= count);\n \n \t  for (size_t i = 0; i < ocount; ++i)\n \t    phwi[i] = ~phwi[i];\n@@ -4252,8 +4252,8 @@ Unary_expression::do_get_tree(Translate_context* context)\n       // where we would see one should have been moved onto the heap\n       // at parse time.  Taking the address of a nonconstant\n       // constructor will not do what the programmer expects.\n-      gcc_assert(TREE_CODE(expr) != CONSTRUCTOR || TREE_CONSTANT(expr));\n-      gcc_assert(TREE_CODE(expr) != ADDR_EXPR);\n+      go_assert(TREE_CODE(expr) != CONSTRUCTOR || TREE_CONSTANT(expr));\n+      go_assert(TREE_CODE(expr) != ADDR_EXPR);\n \n       // Build a decl for a constant constructor.\n       if (TREE_CODE(expr) == CONSTRUCTOR && TREE_CONSTANT(expr))\n@@ -4276,7 +4276,7 @@ Unary_expression::do_get_tree(Translate_context* context)\n \n     case OPERATOR_MULT:\n       {\n-\tgcc_assert(POINTER_TYPE_P(TREE_TYPE(expr)));\n+\tgo_assert(POINTER_TYPE_P(TREE_TYPE(expr)));\n \n \t// If we are dereferencing the pointer to a large struct, we\n \t// need to check for nil.  We don't bother to check for small\n@@ -5156,7 +5156,7 @@ Binary_expression::do_lower(Gogo*, Named_object*, int)\n \t\t\t\t\t\tright_type, right_val,\n \t\t\t\t\t\tlocation, val))\n \t      {\n-\t\tgcc_assert(op != OPERATOR_OROR && op != OPERATOR_ANDAND);\n+\t\tgo_assert(op != OPERATOR_OROR && op != OPERATOR_ANDAND);\n \t\tType* type;\n \t\tif (op == OPERATOR_LSHIFT || op == OPERATOR_RSHIFT)\n \t\t  type = left_type;\n@@ -5240,7 +5240,7 @@ Binary_expression::do_lower(Gogo*, Named_object*, int)\n \t\t\t\t\t      right_type, right_val, val,\n \t\t\t\t\t      location))\n \t      {\n-\t\tgcc_assert(op != OPERATOR_OROR && op != OPERATOR_ANDAND\n+\t\tgo_assert(op != OPERATOR_OROR && op != OPERATOR_ANDAND\n \t\t\t   && op != OPERATOR_LSHIFT && op != OPERATOR_RSHIFT);\n \t\tType* type;\n \t\tif (left_type == NULL)\n@@ -5331,7 +5331,7 @@ Binary_expression::do_lower(Gogo*, Named_object*, int)\n \t\t\t\t\t\treal, imag,\n \t\t\t\t\t\tlocation))\n \t      {\n-\t\tgcc_assert(op != OPERATOR_OROR && op != OPERATOR_ANDAND\n+\t\tgo_assert(op != OPERATOR_OROR && op != OPERATOR_ANDAND\n \t\t\t   && op != OPERATOR_LSHIFT && op != OPERATOR_RSHIFT);\n \t\tType* type;\n \t\tif (left_type == NULL)\n@@ -5983,7 +5983,7 @@ Binary_expression::do_get_tree(Translate_context* context)\n \n   if (this->left_->type()->is_string_type())\n     {\n-      gcc_assert(this->op_ == OPERATOR_PLUS);\n+      go_assert(this->op_ == OPERATOR_PLUS);\n       tree string_type = Type::make_string_type()->get_tree(context->gogo());\n       static tree string_plus_decl;\n       return Gogo::call_builtin(&string_plus_decl,\n@@ -6036,8 +6036,8 @@ Binary_expression::do_get_tree(Translate_context* context)\n   // This is not true in GENERIC, so we need to insert a conditional.\n   if (is_shift_op)\n     {\n-      gcc_assert(INTEGRAL_TYPE_P(TREE_TYPE(left)));\n-      gcc_assert(this->left_->type()->integer_type() != NULL);\n+      go_assert(INTEGRAL_TYPE_P(TREE_TYPE(left)));\n+      go_assert(this->left_->type()->integer_type() != NULL);\n       int bits = TYPE_PRECISION(TREE_TYPE(left));\n \n       tree compare = fold_build2(LT_EXPR, boolean_type_node, right,\n@@ -6458,12 +6458,12 @@ Expression::comparison_tree(Translate_context* context, Operator op,\n \t{\n \t  if (left_type->interface_type()->is_empty())\n \t    {\n-\t      gcc_assert(op == OPERATOR_EQEQ || op == OPERATOR_NOTEQ);\n+\t      go_assert(op == OPERATOR_EQEQ || op == OPERATOR_NOTEQ);\n \t      std::swap(left_type, right_type);\n \t      std::swap(left_tree, right_tree);\n \t    }\n-\t  gcc_assert(!left_type->interface_type()->is_empty());\n-\t  gcc_assert(right_type->interface_type()->is_empty());\n+\t  go_assert(!left_type->interface_type()->is_empty());\n+\t  go_assert(right_type->interface_type()->is_empty());\n \t  static tree interface_empty_compare_decl;\n \t  left_tree = Gogo::call_builtin(&interface_empty_compare_decl,\n \t\t\t\t\t location,\n@@ -6503,15 +6503,15 @@ Expression::comparison_tree(Translate_context* context, Operator op,\n \t{\n \t  // An interface is nil if the first field is nil.\n \t  tree left_type_tree = TREE_TYPE(left_tree);\n-\t  gcc_assert(TREE_CODE(left_type_tree) == RECORD_TYPE);\n+\t  go_assert(TREE_CODE(left_type_tree) == RECORD_TYPE);\n \t  tree field = TYPE_FIELDS(left_type_tree);\n \t  left_tree = build3(COMPONENT_REF, TREE_TYPE(field), left_tree,\n \t\t\t     field, NULL_TREE);\n \t  right_tree = fold_convert(TREE_TYPE(left_tree), null_pointer_node);\n \t}\n       else\n \t{\n-\t  gcc_assert(POINTER_TYPE_P(TREE_TYPE(left_tree)));\n+\t  go_assert(POINTER_TYPE_P(TREE_TYPE(left_tree)));\n \t  right_tree = fold_convert(TREE_TYPE(left_tree), null_pointer_node);\n \t}\n     }\n@@ -6723,7 +6723,7 @@ Builtin_call_expression::Builtin_call_expression(Gogo* gogo,\n     gogo_(gogo), code_(BUILTIN_INVALID), seen_(false)\n {\n   Func_expression* fnexp = this->fn()->func_expression();\n-  gcc_assert(fnexp != NULL);\n+  go_assert(fnexp != NULL);\n   const std::string& name(fnexp->named_object()->name());\n   if (name == \"append\")\n     this->code_ = BUILTIN_APPEND;\n@@ -6780,7 +6780,7 @@ void\n Builtin_call_expression::do_set_recover_arg(Expression* arg)\n {\n   const Expression_list* args = this->args();\n-  gcc_assert(args == NULL || args->empty());\n+  go_assert(args == NULL || args->empty());\n   Expression_list* new_args = new Expression_list();\n   new_args->push_back(arg);\n   this->set_args(new_args);\n@@ -7158,7 +7158,7 @@ Builtin_call_expression::do_integer_constant_value(bool iota_is_constant,\n       if (this->code_ == BUILTIN_SIZEOF)\n \t{\n \t  tree type_size = TYPE_SIZE_UNIT(arg_type_tree);\n-\t  gcc_assert(TREE_CODE(type_size) == INTEGER_CST);\n+\t  go_assert(TREE_CODE(type_size) == INTEGER_CST);\n \t  if (TREE_INT_CST_HIGH(type_size) != 0)\n \t    return false;\n \t  unsigned HOST_WIDE_INT val_wide = TREE_INT_CST_LOW(type_size);\n@@ -7198,12 +7198,12 @@ Builtin_call_expression::do_integer_constant_value(bool iota_is_constant,\n       if (st->named_type() != NULL)\n \tst->named_type()->convert(this->gogo_);\n       tree struct_tree = st->get_tree(this->gogo_);\n-      gcc_assert(TREE_CODE(struct_tree) == RECORD_TYPE);\n+      go_assert(TREE_CODE(struct_tree) == RECORD_TYPE);\n       tree field = TYPE_FIELDS(struct_tree);\n       for (unsigned int index = farg->field_index(); index > 0; --index)\n \t{\n \t  field = DECL_CHAIN(field);\n-\t  gcc_assert(field != NULL_TREE);\n+\t  go_assert(field != NULL_TREE);\n \t}\n       HOST_WIDE_INT offset_wide = int_byte_position (field);\n       if (offset_wide < 0)\n@@ -7747,13 +7747,13 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n     case BUILTIN_CAP:\n       {\n \tconst Expression_list* args = this->args();\n-\tgcc_assert(args != NULL && args->size() == 1);\n+\tgo_assert(args != NULL && args->size() == 1);\n \tExpression* arg = *args->begin();\n \tType* arg_type = arg->type();\n \n \tif (this->seen_)\n \t  {\n-\t    gcc_assert(saw_errors());\n+\t    go_assert(saw_errors());\n \t    return error_mark_node;\n \t  }\n \tthis->seen_ = true;\n@@ -7768,9 +7768,9 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \tif (arg_type->points_to() != NULL)\n \t  {\n \t    arg_type = arg_type->points_to();\n-\t    gcc_assert(arg_type->array_type() != NULL\n+\t    go_assert(arg_type->array_type() != NULL\n \t\t       && !arg_type->is_open_array_type());\n-\t    gcc_assert(POINTER_TYPE_P(TREE_TYPE(arg_tree)));\n+\t    go_assert(POINTER_TYPE_P(TREE_TYPE(arg_tree)));\n \t    arg_tree = build_fold_indirect_ref(arg_tree);\n \t  }\n \n@@ -7783,7 +7783,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t      {\n \t\tif (this->seen_)\n \t\t  {\n-\t\t    gcc_assert(saw_errors());\n+\t\t    go_assert(saw_errors());\n \t\t    return error_mark_node;\n \t\t  }\n \t\tthis->seen_ = true;\n@@ -7821,7 +7821,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t      {\n \t\tif (this->seen_)\n \t\t  {\n-\t\t    gcc_assert(saw_errors());\n+\t\t    go_assert(saw_errors());\n \t\t    return error_mark_node;\n \t\t  }\n \t\tthis->seen_ = true;\n@@ -8000,7 +8000,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n     case BUILTIN_PANIC:\n       {\n \tconst Expression_list* args = this->args();\n-\tgcc_assert(args != NULL && args->size() == 1);\n+\tgo_assert(args != NULL && args->size() == 1);\n \tExpression* arg = args->front();\n \ttree arg_tree = arg->get_tree(context);\n \tif (arg_tree == error_mark_node)\n@@ -8031,7 +8031,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t// The argument is set when building recover thunks.  It's a\n \t// boolean value which is true if we can recover a value now.\n \tconst Expression_list* args = this->args();\n-\tgcc_assert(args != NULL && args->size() == 1);\n+\tgo_assert(args != NULL && args->size() == 1);\n \tExpression* arg = args->front();\n \ttree arg_tree = arg->get_tree(context);\n \tif (arg_tree == error_mark_node)\n@@ -8080,7 +8080,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n     case BUILTIN_CLOSE:\n       {\n \tconst Expression_list* args = this->args();\n-\tgcc_assert(args != NULL && args->size() == 1);\n+\tgo_assert(args != NULL && args->size() == 1);\n \tExpression* arg = args->front();\n \ttree arg_tree = arg->get_tree(context);\n \tif (arg_tree == error_mark_node)\n@@ -8105,7 +8105,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \tbool b = this->integer_constant_value(true, val, &dummy);\n \tif (!b)\n \t  {\n-\t    gcc_assert(saw_errors());\n+\t    go_assert(saw_errors());\n \t    return error_mark_node;\n \t  }\n \ttree type = Type::lookup_integer_type(\"int\")->get_tree(gogo);\n@@ -8117,7 +8117,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n     case BUILTIN_COPY:\n       {\n \tconst Expression_list* args = this->args();\n-\tgcc_assert(args != NULL && args->size() == 2);\n+\tgo_assert(args != NULL && args->size() == 2);\n \tExpression* arg1 = args->front();\n \tExpression* arg2 = args->back();\n \n@@ -8199,7 +8199,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n     case BUILTIN_APPEND:\n       {\n \tconst Expression_list* args = this->args();\n-\tgcc_assert(args != NULL && args->size() == 2);\n+\tgo_assert(args != NULL && args->size() == 2);\n \tExpression* arg1 = args->front();\n \tExpression* arg2 = args->back();\n \n@@ -8255,12 +8255,12 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n     case BUILTIN_IMAG:\n       {\n \tconst Expression_list* args = this->args();\n-\tgcc_assert(args != NULL && args->size() == 1);\n+\tgo_assert(args != NULL && args->size() == 1);\n \tExpression* arg = args->front();\n \ttree arg_tree = arg->get_tree(context);\n \tif (arg_tree == error_mark_node)\n \t  return error_mark_node;\n-\tgcc_assert(COMPLEX_FLOAT_TYPE_P(TREE_TYPE(arg_tree)));\n+\tgo_assert(COMPLEX_FLOAT_TYPE_P(TREE_TYPE(arg_tree)));\n \tif (this->code_ == BUILTIN_REAL)\n \t  return fold_build1_loc(location, REALPART_EXPR,\n \t\t\t\t TREE_TYPE(TREE_TYPE(arg_tree)),\n@@ -8274,14 +8274,14 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n     case BUILTIN_COMPLEX:\n       {\n \tconst Expression_list* args = this->args();\n-\tgcc_assert(args != NULL && args->size() == 2);\n+\tgo_assert(args != NULL && args->size() == 2);\n \ttree r = args->front()->get_tree(context);\n \ttree i = args->back()->get_tree(context);\n \tif (r == error_mark_node || i == error_mark_node)\n \t  return error_mark_node;\n-\tgcc_assert(TYPE_MAIN_VARIANT(TREE_TYPE(r))\n+\tgo_assert(TYPE_MAIN_VARIANT(TREE_TYPE(r))\n \t\t   == TYPE_MAIN_VARIANT(TREE_TYPE(i)));\n-\tgcc_assert(SCALAR_FLOAT_TYPE_P(TREE_TYPE(r)));\n+\tgo_assert(SCALAR_FLOAT_TYPE_P(TREE_TYPE(r)));\n \treturn fold_build2_loc(location, COMPLEX_EXPR,\n \t\t\t       build_complex_type(TREE_TYPE(r)),\n \t\t\t       r, i);\n@@ -8418,7 +8418,7 @@ Call_expression::do_lower(Gogo* gogo, Named_object* function, int)\n     {\n       Function_type* fntype = this->fn_->type()->function_type();\n       const Typed_identifier_list* parameters = fntype->parameters();\n-      gcc_assert(parameters != NULL && !parameters->empty());\n+      go_assert(parameters != NULL && !parameters->empty());\n       Type* varargs_type = parameters->back().type();\n       return this->lower_varargs(gogo, function, varargs_type,\n \t\t\t\t parameters->size());\n@@ -8443,8 +8443,8 @@ Call_expression::lower_varargs(Gogo* gogo, Named_object* function,\n \n   source_location loc = this->location();\n \n-  gcc_assert(param_count > 0);\n-  gcc_assert(varargs_type->is_open_array_type());\n+  go_assert(param_count > 0);\n+  go_assert(varargs_type->is_open_array_type());\n \n   size_t arg_count = this->args_ == NULL ? 0 : this->args_->size();\n   if (arg_count < param_count - 1)\n@@ -8458,7 +8458,7 @@ Call_expression::lower_varargs(Gogo* gogo, Named_object* function,\n   bool push_empty_arg = false;\n   if (old_args == NULL || old_args->empty())\n     {\n-      gcc_assert(param_count == 1);\n+      go_assert(param_count == 1);\n       push_empty_arg = true;\n     }\n   else\n@@ -8517,7 +8517,7 @@ Call_expression::lower_varargs(Gogo* gogo, Named_object* function,\n   // Lower all the new subexpressions.\n   Expression* ret = this;\n   gogo->lower_expression(function, &ret);\n-  gcc_assert(ret == this);\n+  go_assert(ret == this);\n   return ret;\n }\n \n@@ -8868,7 +8868,7 @@ Call_expression::do_get_tree(Translate_context* context)\n     this->fn_->interface_field_reference_expression();\n   const bool has_closure = func != NULL && func->closure() != NULL;\n   const bool is_method = bound_method != NULL || interface_method != NULL;\n-  gcc_assert(!fntype->is_method() || is_method);\n+  go_assert(!fntype->is_method() || is_method);\n \n   int nargs;\n   tree* args;\n@@ -8880,7 +8880,7 @@ Call_expression::do_get_tree(Translate_context* context)\n   else\n     {\n       const Typed_identifier_list* params = fntype->parameters();\n-      gcc_assert(params != NULL);\n+      go_assert(params != NULL);\n \n       nargs = this->args_->size();\n       int i = is_method ? 1 : 0;\n@@ -8893,7 +8893,7 @@ Call_expression::do_get_tree(Translate_context* context)\n \t   pe != this->args_->end();\n \t   ++pe, ++pp, ++i)\n \t{\n-\t  gcc_assert(pp != params->end());\n+\t  go_assert(pp != params->end());\n \t  tree arg_val = (*pe)->get_tree(context);\n \t  args[i] = Expression::convert_for_assignment(context,\n \t\t\t\t\t\t       pp->type(),\n@@ -8906,8 +8906,8 @@ Call_expression::do_get_tree(Translate_context* context)\n \t      return error_mark_node;\n \t    }\n \t}\n-      gcc_assert(pp == params->end());\n-      gcc_assert(i == nargs);\n+      go_assert(pp == params->end());\n+      go_assert(i == nargs);\n     }\n \n   tree rettype = TREE_TYPE(TREE_TYPE(fntype->get_tree(gogo)));\n@@ -9155,16 +9155,16 @@ Call_result_expression::do_get_tree(Translate_context* context)\n     return error_mark_node;\n   if (TREE_CODE(TREE_TYPE(call_tree)) != RECORD_TYPE)\n     {\n-      gcc_assert(saw_errors());\n+      go_assert(saw_errors());\n       return error_mark_node;\n     }\n   tree field = TYPE_FIELDS(TREE_TYPE(call_tree));\n   for (unsigned int i = 0; i < this->index_; ++i)\n     {\n-      gcc_assert(field != NULL_TREE);\n+      go_assert(field != NULL_TREE);\n       field = DECL_CHAIN(field);\n     }\n-  gcc_assert(field != NULL_TREE);\n+  go_assert(field != NULL_TREE);\n   return build3(COMPONENT_REF, TREE_TYPE(field), call_tree, field, NULL_TREE);\n }\n \n@@ -9380,7 +9380,7 @@ Array_index_expression::do_check_types(Gogo*)\n   Array_type* array_type = this->array_->type()->array_type();\n   if (array_type == NULL)\n     {\n-      gcc_assert(this->array_->type()->is_error());\n+      go_assert(this->array_->type()->is_error());\n       return;\n     }\n \n@@ -9465,7 +9465,7 @@ Array_index_expression::do_get_tree(Translate_context* context)\n   Array_type* array_type = this->array_->type()->array_type();\n   if (array_type == NULL)\n     {\n-      gcc_assert(this->array_->type()->is_error());\n+      go_assert(this->array_->type()->is_error());\n       return error_mark_node;\n     }\n \n@@ -9609,25 +9609,25 @@ Array_index_expression::do_get_tree(Translate_context* context)\n \t\t\t\t\t      capacity_tree, start_tree);\n \n   tree struct_tree = this->type()->get_tree(gogo);\n-  gcc_assert(TREE_CODE(struct_tree) == RECORD_TYPE);\n+  go_assert(TREE_CODE(struct_tree) == RECORD_TYPE);\n \n   VEC(constructor_elt,gc)* init = VEC_alloc(constructor_elt, gc, 3);\n \n   constructor_elt* elt = VEC_quick_push(constructor_elt, init, NULL);\n   tree field = TYPE_FIELDS(struct_tree);\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__values\") == 0);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__values\") == 0);\n   elt->index = field;\n   elt->value = value_pointer;\n \n   elt = VEC_quick_push(constructor_elt, init, NULL);\n   field = DECL_CHAIN(field);\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__count\") == 0);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__count\") == 0);\n   elt->index = field;\n   elt->value = fold_convert_loc(loc, TREE_TYPE(field), result_length_tree);\n \n   elt = VEC_quick_push(constructor_elt, init, NULL);\n   field = DECL_CHAIN(field);\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__capacity\") == 0);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__capacity\") == 0);\n   elt->index = field;\n   elt->value = fold_convert_loc(loc, TREE_TYPE(field), result_capacity_tree);\n \n@@ -9916,7 +9916,7 @@ Map_index_expression::get_map_type() const\n {\n   Map_type* mt = this->map_->type()->deref()->map_type();\n   if (mt == NULL)\n-    gcc_assert(saw_errors());\n+    go_assert(saw_errors());\n   return mt;\n }\n \n@@ -10129,7 +10129,7 @@ Field_reference_expression::do_type()\n   if (type->is_error())\n     return type;\n   Struct_type* struct_type = type->struct_type();\n-  gcc_assert(struct_type != NULL);\n+  go_assert(struct_type != NULL);\n   return struct_type->field(this->field_index_)->type();\n }\n \n@@ -10142,8 +10142,8 @@ Field_reference_expression::do_check_types(Gogo*)\n   if (type->is_error())\n     return;\n   Struct_type* struct_type = type->struct_type();\n-  gcc_assert(struct_type != NULL);\n-  gcc_assert(struct_type->field(this->field_index_) != NULL);\n+  go_assert(struct_type != NULL);\n+  go_assert(struct_type->field(this->field_index_) != NULL);\n }\n \n // Get a tree for a field reference.\n@@ -10155,19 +10155,19 @@ Field_reference_expression::do_get_tree(Translate_context* context)\n   if (struct_tree == error_mark_node\n       || TREE_TYPE(struct_tree) == error_mark_node)\n     return error_mark_node;\n-  gcc_assert(TREE_CODE(TREE_TYPE(struct_tree)) == RECORD_TYPE);\n+  go_assert(TREE_CODE(TREE_TYPE(struct_tree)) == RECORD_TYPE);\n   tree field = TYPE_FIELDS(TREE_TYPE(struct_tree));\n   if (field == NULL_TREE)\n     {\n       // This can happen for a type which refers to itself indirectly\n       // and then turns out to be erroneous.\n-      gcc_assert(saw_errors());\n+      go_assert(saw_errors());\n       return error_mark_node;\n     }\n   for (unsigned int i = this->field_index_; i > 0; --i)\n     {\n       field = DECL_CHAIN(field);\n-      gcc_assert(field != NULL_TREE);\n+      go_assert(field != NULL_TREE);\n     }\n   if (TREE_TYPE(field) == error_mark_node)\n     return error_mark_node;\n@@ -10196,16 +10196,16 @@ Interface_field_reference_expression::get_function_tree(Translate_context*,\n     expr = build_fold_indirect_ref(expr);\n \n   tree expr_type = TREE_TYPE(expr);\n-  gcc_assert(TREE_CODE(expr_type) == RECORD_TYPE);\n+  go_assert(TREE_CODE(expr_type) == RECORD_TYPE);\n \n   tree field = TYPE_FIELDS(expr_type);\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__methods\") == 0);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__methods\") == 0);\n \n   tree table = build3(COMPONENT_REF, TREE_TYPE(field), expr, field, NULL_TREE);\n-  gcc_assert(POINTER_TYPE_P(TREE_TYPE(table)));\n+  go_assert(POINTER_TYPE_P(TREE_TYPE(table)));\n \n   table = build_fold_indirect_ref(table);\n-  gcc_assert(TREE_CODE(TREE_TYPE(table)) == RECORD_TYPE);\n+  go_assert(TREE_CODE(TREE_TYPE(table)) == RECORD_TYPE);\n \n   std::string name = Gogo::unpack_hidden_name(this->name_);\n   for (field = DECL_CHAIN(TYPE_FIELDS(TREE_TYPE(table)));\n@@ -10215,7 +10215,7 @@ Interface_field_reference_expression::get_function_tree(Translate_context*,\n       if (name == IDENTIFIER_POINTER(DECL_NAME(field)))\n \tbreak;\n     }\n-  gcc_assert(field != NULL_TREE);\n+  go_assert(field != NULL_TREE);\n \n   return build3(COMPONENT_REF, TREE_TYPE(field), table, field, NULL_TREE);\n }\n@@ -10232,10 +10232,10 @@ Interface_field_reference_expression::get_underlying_object_tree(\n     expr = build_fold_indirect_ref(expr);\n \n   tree expr_type = TREE_TYPE(expr);\n-  gcc_assert(TREE_CODE(expr_type) == RECORD_TYPE);\n+  go_assert(TREE_CODE(expr_type) == RECORD_TYPE);\n \n   tree field = DECL_CHAIN(TYPE_FIELDS(expr_type));\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__object\") == 0);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__object\") == 0);\n \n   return build3(COMPONENT_REF, TREE_TYPE(field), expr, field, NULL_TREE);\n }\n@@ -10447,12 +10447,12 @@ Selector_expression::lower_method_expression(Gogo* gogo)\n   if (method != NULL)\n     {\n       method_type = method->type();\n-      gcc_assert(method_type->is_method());\n+      go_assert(method_type->is_method());\n     }\n   else\n     {\n       method_type = imethod->type()->function_type();\n-      gcc_assert(method_type != NULL && !method_type->is_method());\n+      go_assert(method_type != NULL && !method_type->is_method());\n     }\n \n   const char* const receiver_name = \"$this\";\n@@ -10509,7 +10509,7 @@ Selector_expression::lower_method_expression(Gogo* gogo)\n \t\t\t\t\t  location);\n \n   Named_object* vno = gogo->lookup(receiver_name, NULL);\n-  gcc_assert(vno != NULL);\n+  go_assert(vno != NULL);\n   Expression* ve = Expression::make_var_reference(vno, location);\n   Expression* bm;\n   if (method != NULL)\n@@ -10536,7 +10536,7 @@ Selector_expression::lower_method_expression(Gogo* gogo)\n \t   ++p)\n \t{\n \t  vno = gogo->lookup(p->name(), NULL);\n-\t  gcc_assert(vno != NULL);\n+\t  go_assert(vno != NULL);\n \t  args->push_back(Expression::make_var_reference(vno, location));\n \t}\n     }\n@@ -10920,7 +10920,7 @@ Struct_construction_expression::do_check_types(Gogo*)\n \t  this->set_is_error();\n \t}\n     }\n-  gcc_assert(pv == this->vals_->end());\n+  go_assert(pv == this->vals_->end());\n }\n \n // Return a tree for constructing a struct.\n@@ -10936,7 +10936,7 @@ Struct_construction_expression::do_get_tree(Translate_context* context)\n   tree type_tree = this->type_->get_tree(gogo);\n   if (type_tree == error_mark_node)\n     return error_mark_node;\n-  gcc_assert(TREE_CODE(type_tree) == RECORD_TYPE);\n+  go_assert(TREE_CODE(type_tree) == RECORD_TYPE);\n \n   bool is_constant = true;\n   const Struct_field_list* fields = this->type_->struct_type()->fields();\n@@ -10948,7 +10948,7 @@ Struct_construction_expression::do_get_tree(Translate_context* context)\n        field != NULL_TREE;\n        field = DECL_CHAIN(field), ++pf)\n     {\n-      gcc_assert(pf != fields->end());\n+      go_assert(pf != fields->end());\n \n       tree val;\n       if (pv == this->vals_->end())\n@@ -10976,7 +10976,7 @@ Struct_construction_expression::do_get_tree(Translate_context* context)\n       if (!TREE_CONSTANT(val))\n \tis_constant = false;\n     }\n-  gcc_assert(pf == fields->end());\n+  go_assert(pf == fields->end());\n \n   tree ret = build_constructor(type_tree, elts);\n   if (is_constant)\n@@ -11008,7 +11008,7 @@ Expression*\n Expression::make_struct_composite_literal(Type* type, Expression_list* vals,\n \t\t\t\t\t  source_location location)\n {\n-  gcc_assert(type->struct_type() != NULL);\n+  go_assert(type->struct_type() != NULL);\n   return new Struct_construction_expression(type, vals, location);\n }\n \n@@ -11245,7 +11245,7 @@ class Fixed_array_construction_expression :\n     : Array_construction_expression(EXPRESSION_FIXED_ARRAY_CONSTRUCTION,\n \t\t\t\t    type, vals, location)\n   {\n-    gcc_assert(type->array_type() != NULL\n+    go_assert(type->array_type() != NULL\n \t       && type->array_type()->length() != NULL);\n   }\n \n@@ -11283,7 +11283,7 @@ class Open_array_construction_expression : public Array_construction_expression\n     : Array_construction_expression(EXPRESSION_OPEN_ARRAY_CONSTRUCTION,\n \t\t\t\t    type, vals, location)\n   {\n-    gcc_assert(type->array_type() != NULL\n+    go_assert(type->array_type() != NULL\n \t       && type->array_type()->length() == NULL);\n   }\n \n@@ -11312,7 +11312,7 @@ Open_array_construction_expression::do_get_tree(Translate_context* context)\n   Array_type* array_type = this->type()->array_type();\n   if (array_type == NULL)\n     {\n-      gcc_assert(this->type()->is_error());\n+      go_assert(this->type()->is_error());\n       return error_mark_node;\n     }\n \n@@ -11413,25 +11413,25 @@ Open_array_construction_expression::do_get_tree(Translate_context* context)\n   tree type_tree = this->type()->get_tree(context->gogo());\n   if (type_tree == error_mark_node)\n     return error_mark_node;\n-  gcc_assert(TREE_CODE(type_tree) == RECORD_TYPE);\n+  go_assert(TREE_CODE(type_tree) == RECORD_TYPE);\n \n   VEC(constructor_elt,gc)* init = VEC_alloc(constructor_elt, gc, 3);\n \n   constructor_elt* elt = VEC_quick_push(constructor_elt, init, NULL);\n   tree field = TYPE_FIELDS(type_tree);\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__values\") == 0);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__values\") == 0);\n   elt->index = field;\n   elt->value = fold_convert(TREE_TYPE(field), space);\n \n   elt = VEC_quick_push(constructor_elt, init, NULL);\n   field = DECL_CHAIN(field);\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__count\") == 0);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__count\") == 0);\n   elt->index = field;\n   elt->value = fold_convert(TREE_TYPE(field), length_tree);\n \n   elt = VEC_quick_push(constructor_elt, init, NULL);\n   field = DECL_CHAIN(field);\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)),\"__capacity\") == 0);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)),\"__capacity\") == 0);\n   elt->index = field;\n   elt->value = fold_convert(TREE_TYPE(field), length_tree);\n \n@@ -11454,7 +11454,7 @@ Expression*\n Expression::make_slice_composite_literal(Type* type, Expression_list* vals,\n \t\t\t\t\t source_location location)\n {\n-  gcc_assert(type->is_open_array_type());\n+  go_assert(type->is_open_array_type());\n   return new Open_array_construction_expression(type, vals, location);\n }\n \n@@ -11467,7 +11467,7 @@ class Map_construction_expression : public Expression\n \t\t\t      source_location location)\n     : Expression(EXPRESSION_MAP_CONSTRUCTION, location),\n       type_(type), vals_(vals)\n-  { gcc_assert(vals == NULL || vals->size() % 2 == 0); }\n+  { go_assert(vals == NULL || vals->size() % 2 == 0); }\n \n  protected:\n   int\n@@ -11874,7 +11874,7 @@ Composite_literal_expression::lower_struct(Gogo* gogo, Type* type)\n       Expression* name_expr = *p;\n \n       ++p;\n-      gcc_assert(p != this->vals_->end());\n+      go_assert(p != this->vals_->end());\n       Expression* val = *p;\n \n       ++p;\n@@ -12030,7 +12030,7 @@ Composite_literal_expression::lower_array(Type* type)\n       Expression* index_expr = *p;\n \n       ++p;\n-      gcc_assert(p != this->vals_->end());\n+      go_assert(p != this->vals_->end());\n       Expression* val = *p;\n \n       ++p;\n@@ -12179,7 +12179,7 @@ Composite_literal_expression::lower_map(Gogo* gogo, Named_object* function,\n \t    {\n \t      (*p)->unknown_expression()->clear_is_composite_literal_key();\n \t      gogo->lower_expression(function, &*p);\n-\t      gcc_assert((*p)->is_error_expression());\n+\t      go_assert((*p)->is_error_expression());\n \t      return Expression::make_error(location);\n \t    }\n \t}\n@@ -12425,7 +12425,7 @@ Heap_composite_expression::do_get_tree(Translate_context* context)\n   if (expr_tree == error_mark_node)\n     return error_mark_node;\n   tree expr_size = TYPE_SIZE_UNIT(TREE_TYPE(expr_tree));\n-  gcc_assert(TREE_CODE(expr_size) == INTEGER_CST);\n+  go_assert(TREE_CODE(expr_size) == INTEGER_CST);\n   tree space = context->gogo()->allocate_memory(this->expr_->type(),\n \t\t\t\t\t\texpr_size, this->location());\n   space = fold_convert(build_pointer_type(TREE_TYPE(expr_tree)), space);\n@@ -12491,7 +12491,7 @@ Receive_expression::do_get_tree(Translate_context* context)\n   Channel_type* channel_type = this->channel_->type()->channel_type();\n   if (channel_type == NULL)\n     {\n-      gcc_assert(this->channel_->type()->is_error());\n+      go_assert(this->channel_->type()->is_error());\n       return error_mark_node;\n     }\n   Type* element_type = channel_type->element_type();\n@@ -12618,7 +12618,7 @@ Type_info_expression::do_get_tree(Translate_context* context)\n     return error_mark_node;\n \n   tree val_type_tree = this->type()->get_tree(context->gogo());\n-  gcc_assert(val_type_tree != error_mark_node);\n+  go_assert(val_type_tree != error_mark_node);\n \n   if (this->type_info_ == TYPE_INFO_SIZE)\n     return fold_convert_loc(BUILTINS_LOCATION, val_type_tree,\n@@ -12687,7 +12687,7 @@ Struct_field_offset_expression::do_get_tree(Translate_context* context)\n     return error_mark_node;\n \n   tree val_type_tree = this->type()->get_tree(context->gogo());\n-  gcc_assert(val_type_tree != error_mark_node);\n+  go_assert(val_type_tree != error_mark_node);\n \n   const Struct_field_list* fields = this->type_->fields();\n   tree struct_field_tree = TYPE_FIELDS(type_tree);\n@@ -12696,11 +12696,11 @@ Struct_field_offset_expression::do_get_tree(Translate_context* context)\n        p != fields->end();\n        ++p, struct_field_tree = DECL_CHAIN(struct_field_tree))\n     {\n-      gcc_assert(struct_field_tree != NULL_TREE);\n+      go_assert(struct_field_tree != NULL_TREE);\n       if (&*p == this->field_)\n \tbreak;\n     }\n-  gcc_assert(&*p == this->field_);\n+  go_assert(&*p == this->field_);\n \n   return fold_convert_loc(BUILTINS_LOCATION, val_type_tree,\n \t\t\t  byte_position(struct_field_tree));"}, {"sha": "a09d09a41ba64e1ba8a80fceb66820a53f74de13", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=26409c5246d31c7709ea85e8fea698d38bfb161d", "patch": "@@ -1641,7 +1641,7 @@ class Field_reference_expression : public Expression\n   void\n   set_struct_expression(Expression* expr)\n   {\n-    gcc_assert(this->expr_ == NULL);\n+    go_assert(this->expr_ == NULL);\n     this->expr_ = expr;\n   }\n "}, {"sha": "3da1404129bed55d9a38f1513d1c094e09f4473f", "filename": "gcc/go/gofrontend/go.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo.cc?ref=26409c5246d31c7709ea85e8fea698d38bfb161d", "patch": "@@ -27,7 +27,7 @@ GO_EXTERN_C\n void\n go_create_gogo(int int_type_size, int pointer_size)\n {\n-  gcc_assert(::gogo == NULL);\n+  go_assert(::gogo == NULL);\n   ::gogo = new Gogo(go_get_backend(), int_type_size, pointer_size);\n   if (!unique_prefix.empty())\n     ::gogo->set_unique_prefix(unique_prefix);\n@@ -60,7 +60,7 @@ void\n go_parse_input_files(const char** filenames, unsigned int filename_count,\n \t\t     bool only_check_syntax, bool require_return_statement)\n {\n-  gcc_assert(filename_count > 0);\n+  go_assert(filename_count > 0);\n   for (unsigned int i = 0; i < filename_count; ++i)\n     {\n       if (i > 0)"}, {"sha": "608f1665d8366af4fcee2d495ec8c3052b4c862a", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=26409c5246d31c7709ea85e8fea698d38bfb161d", "patch": "@@ -162,7 +162,7 @@ Gogo::get_init_fn_name()\n {\n   if (this->init_fn_name_.empty())\n     {\n-      gcc_assert(this->package_ != NULL);\n+      go_assert(this->package_ != NULL);\n       if (this->is_main_package())\n \t{\n \t  // Use a name which the runtime knows.\n@@ -188,7 +188,7 @@ Gogo::get_init_fn_name()\n void\n Gogo::init_imports(tree* init_stmt_list)\n {\n-  gcc_assert(this->is_main_package());\n+  go_assert(this->is_main_package());\n \n   if (this->imported_init_fns_.empty())\n     return;\n@@ -280,7 +280,7 @@ Gogo::register_gc_vars(const std::vector<Named_object*>& var_gc,\n       elt->index = field;\n       Bvariable* bvar = (*p)->get_backend_variable(this, NULL);\n       tree decl = var_to_tree(bvar);\n-      gcc_assert(TREE_CODE(decl) == VAR_DECL);\n+      go_assert(TREE_CODE(decl) == VAR_DECL);\n       elt->value = build_fold_addr_expr(decl);\n \n       elt = VEC_quick_push(constructor_elt, init, NULL);\n@@ -387,7 +387,7 @@ Gogo::write_initialization_function(tree fndecl, tree init_stmt_list)\n {\n   // Make sure that we thought we needed an initialization function,\n   // as otherwise we will not have reported it in the export data.\n-  gcc_assert(this->is_main_package() || this->need_init_fn_);\n+  go_assert(this->is_main_package() || this->need_init_fn_);\n \n   if (fndecl == NULL_TREE)\n     fndecl = this->initialization_function_decl();\n@@ -673,7 +673,7 @@ Gogo::write_globals()\n     {\n       Named_object* no = *p;\n \n-      gcc_assert(!no->is_type_declaration() && !no->is_function_declaration());\n+      go_assert(!no->is_type_declaration() && !no->is_function_declaration());\n       // There is nothing to do for a package.\n       if (no->is_package())\n \t{\n@@ -711,7 +711,7 @@ Gogo::write_globals()\n \t  vec[i] = no->get_tree(this, NULL);\n \t  if (vec[i] == error_mark_node)\n \t    {\n-\t      gcc_assert(saw_errors());\n+\t      go_assert(saw_errors());\n \t      --i;\n \t      --count;\n \t      continue;\n@@ -723,7 +723,7 @@ Gogo::write_globals()\n \t  vec[i] = var_to_tree(var);\n \t  if (vec[i] == error_mark_node)\n \t    {\n-\t      gcc_assert(saw_errors());\n+\t      go_assert(saw_errors());\n \t      --i;\n \t      --count;\n \t      continue;\n@@ -738,7 +738,7 @@ Gogo::write_globals()\n \t    {\n \t      tree init = no->var_value()->get_init_tree(this, NULL);\n \t      if (init == error_mark_node)\n-\t\tgcc_assert(saw_errors());\n+\t\tgo_assert(saw_errors());\n \t      else if (init == NULL_TREE)\n \t\t;\n \t      else if (TREE_CONSTANT(init))\n@@ -838,7 +838,7 @@ Gogo::write_globals()\n tree\n Named_object::get_id(Gogo* gogo)\n {\n-  gcc_assert(!this->is_variable() && !this->is_result_variable());\n+  go_assert(!this->is_variable() && !this->is_result_variable());\n   std::string decl_name;\n   if (this->is_function_declaration()\n       && !this->func_declaration_value()->asm_name().empty())\n@@ -945,7 +945,7 @@ Named_object::get_tree(Gogo* gogo, Named_object* function)\n \telse\n \t  {\n \t    decl = TYPE_NAME(type_tree);\n-\t    gcc_assert(decl != NULL_TREE);\n+\t    go_assert(decl != NULL_TREE);\n \n \t    // We need to produce a type descriptor for every named\n \t    // type, and for a pointer to every named type, since\n@@ -1028,10 +1028,10 @@ Named_object::get_tree(Gogo* gogo, Named_object* function)\n tree\n Variable::get_init_tree(Gogo* gogo, Named_object* function)\n {\n-  gcc_assert(this->preinit_ == NULL);\n+  go_assert(this->preinit_ == NULL);\n   if (this->init_ == NULL)\n     {\n-      gcc_assert(!this->is_parameter_);\n+      go_assert(!this->is_parameter_);\n       return this->type_->get_init_tree(gogo,\n \t\t\t\t\t(this->is_global_\n \t\t\t\t\t || this->is_in_heap()));\n@@ -1052,7 +1052,7 @@ Variable::get_init_tree(Gogo* gogo, Named_object* function)\n tree\n Variable::get_init_block(Gogo* gogo, Named_object* function, tree var_decl)\n {\n-  gcc_assert(this->preinit_ != NULL);\n+  go_assert(this->preinit_ != NULL);\n \n   // We want to add the variable assignment to the end of the preinit\n   // block.  The preinit block may have a TRY_FINALLY_EXPR and a\n@@ -1064,7 +1064,7 @@ Variable::get_init_block(Gogo* gogo, Named_object* function, tree var_decl)\n   tree block_tree = block_to_tree(bblock);\n   if (block_tree == error_mark_node)\n     return error_mark_node;\n-  gcc_assert(TREE_CODE(block_tree) == BIND_EXPR);\n+  go_assert(TREE_CODE(block_tree) == BIND_EXPR);\n   tree statements = BIND_EXPR_BODY(block_tree);\n   while (statements != NULL_TREE\n \t && (TREE_CODE(statements) == TRY_FINALLY_EXPR\n@@ -1111,7 +1111,7 @@ Function::get_or_make_decl(Gogo* gogo, Named_object* no, tree id)\n \t{\n \t  // The type of a function comes back as a pointer, but we\n \t  // want the real function type for a function declaration.\n-\t  gcc_assert(POINTER_TYPE_P(functype));\n+\t  go_assert(POINTER_TYPE_P(functype));\n \t  functype = TREE_TYPE(functype);\n \t  tree decl = build_decl(this->location(), FUNCTION_DECL, id, functype);\n \n@@ -1225,7 +1225,7 @@ Function_declaration::get_or_make_decl(Gogo* gogo, Named_object* no, tree id)\n \t{\n \t  // The type of a function comes back as a pointer, but we\n \t  // want the real function type for a function declaration.\n-\t  gcc_assert(POINTER_TYPE_P(functype));\n+\t  go_assert(POINTER_TYPE_P(functype));\n \t  functype = TREE_TYPE(functype);\n \t  decl = build_decl(this->location(), FUNCTION_DECL, id, functype);\n \t  TREE_PUBLIC(decl) = 1;\n@@ -1259,12 +1259,12 @@ Function::make_receiver_parm_decl(Gogo* gogo, Named_object* no, tree var_decl)\n {\n   if (var_decl == error_mark_node)\n     return error_mark_node;\n-  gcc_assert(TREE_CODE(var_decl) == VAR_DECL);\n+  go_assert(TREE_CODE(var_decl) == VAR_DECL);\n   tree val_type = TREE_TYPE(var_decl);\n   bool is_in_heap = no->var_value()->is_in_heap();\n   if (is_in_heap)\n     {\n-      gcc_assert(POINTER_TYPE_P(val_type));\n+      go_assert(POINTER_TYPE_P(val_type));\n       val_type = TREE_TYPE(val_type);\n     }\n \n@@ -1276,7 +1276,7 @@ Function::make_receiver_parm_decl(Gogo* gogo, Named_object* no, tree var_decl)\n   DECL_CONTEXT(parm_decl) = current_function_decl;\n   DECL_ARG_TYPE(parm_decl) = TREE_TYPE(parm_decl);\n \n-  gcc_assert(DECL_INITIAL(var_decl) == NULL_TREE);\n+  go_assert(DECL_INITIAL(var_decl) == NULL_TREE);\n   // The receiver might be passed as a null pointer.\n   tree check = fold_build2_loc(loc, NE_EXPR, boolean_type_node, parm_decl,\n \t\t\t       fold_convert_loc(loc, TREE_TYPE(parm_decl),\n@@ -1324,15 +1324,15 @@ Function::copy_parm_to_heap(Gogo* gogo, Named_object* no, tree var_decl)\n {\n   if (var_decl == error_mark_node)\n     return error_mark_node;\n-  gcc_assert(TREE_CODE(var_decl) == VAR_DECL);\n+  go_assert(TREE_CODE(var_decl) == VAR_DECL);\n   source_location loc = DECL_SOURCE_LOCATION(var_decl);\n \n   std::string name = IDENTIFIER_POINTER(DECL_NAME(var_decl));\n   name += \".param\";\n   tree id = get_identifier_from_string(name);\n \n   tree type = TREE_TYPE(var_decl);\n-  gcc_assert(POINTER_TYPE_P(type));\n+  go_assert(POINTER_TYPE_P(type));\n   type = TREE_TYPE(type);\n \n   tree parm_decl = build_decl(loc, PARM_DECL, id, type);\n@@ -1359,7 +1359,7 @@ void\n Function::build_tree(Gogo* gogo, Named_object* named_function)\n {\n   tree fndecl = this->fndecl_;\n-  gcc_assert(fndecl != NULL_TREE);\n+  go_assert(fndecl != NULL_TREE);\n \n   tree params = NULL_TREE;\n   tree* pp = &params;\n@@ -1385,7 +1385,7 @@ Function::build_tree(Gogo* gogo, Named_object* named_function)\n \t      tree var = *pp;\n \t      if (var != error_mark_node)\n \t\t{\n-\t\t  gcc_assert(TREE_CODE(var) == VAR_DECL);\n+\t\t  go_assert(TREE_CODE(var) == VAR_DECL);\n \t\t  DECL_CHAIN(var) = declare_vars;\n \t\t  declare_vars = var;\n \t\t}\n@@ -1399,7 +1399,7 @@ Function::build_tree(Gogo* gogo, Named_object* named_function)\n \t      tree var = *pp;\n \t      if (var != error_mark_node)\n \t\t{\n-\t\t  gcc_assert(TREE_CODE(var) == VAR_DECL);\n+\t\t  go_assert(TREE_CODE(var) == VAR_DECL);\n \t\t  DECL_CHAIN(var) = declare_vars;\n \t\t  declare_vars = var;\n \t\t}\n@@ -1408,7 +1408,7 @@ Function::build_tree(Gogo* gogo, Named_object* named_function)\n \n \t  if (*pp != error_mark_node)\n \t    {\n-\t      gcc_assert(TREE_CODE(*pp) == PARM_DECL);\n+\t      go_assert(TREE_CODE(*pp) == PARM_DECL);\n \t      pp = &DECL_CHAIN(*pp);\n \t    }\n \t}\n@@ -1447,7 +1447,7 @@ Function::build_tree(Gogo* gogo, Named_object* named_function)\n \n \t  if (var_decl != error_mark_node)\n \t    {\n-\t      gcc_assert(TREE_CODE(var_decl) == VAR_DECL);\n+\t      go_assert(TREE_CODE(var_decl) == VAR_DECL);\n \t      DECL_INITIAL(var_decl) = init;\n \t      DECL_CHAIN(var_decl) = declare_vars;\n \t      declare_vars = var_decl;\n@@ -1460,7 +1460,7 @@ Function::build_tree(Gogo* gogo, Named_object* named_function)\n \n   if (this->block_ != NULL)\n     {\n-      gcc_assert(DECL_INITIAL(fndecl) == NULL_TREE);\n+      go_assert(DECL_INITIAL(fndecl) == NULL_TREE);\n \n       // Declare variables if necessary.\n       tree bind = NULL_TREE;\n@@ -1571,7 +1571,7 @@ Function::build_defer_wrapper(Gogo* gogo, Named_object* named_function,\n   tree ret_stmt = fold_build1_loc(end_loc, RETURN_EXPR, void_type_node, set);\n   append_to_statement_list(ret_stmt, &stmt_list);\n \n-  gcc_assert(*except == NULL_TREE);\n+  go_assert(*except == NULL_TREE);\n   *except = stmt_list;\n \n   // Add some finally code to run the defer functions.  This is used\n@@ -1623,7 +1623,7 @@ Function::build_defer_wrapper(Gogo* gogo, Named_object* named_function,\n       append_to_statement_list(ret_stmt, &stmt_list);\n     }\n   \n-  gcc_assert(*fini == NULL_TREE);\n+  go_assert(*fini == NULL_TREE);\n   *fini = stmt_list;\n }\n \n@@ -1640,10 +1640,10 @@ Function::return_value(Gogo* gogo, Named_object* named_function,\n   if (results == NULL || results->empty())\n     return NULL_TREE;\n \n-  gcc_assert(this->results_ != NULL);\n+  go_assert(this->results_ != NULL);\n   if (this->results_->size() != results->size())\n     {\n-      gcc_assert(saw_errors());\n+      go_assert(saw_errors());\n       return error_mark_node;\n     }\n \n@@ -1668,7 +1668,7 @@ Function::return_value(Gogo* gogo, Named_object* named_function,\n \t   pr != results->end();\n \t   ++pr, ++index, field = DECL_CHAIN(field))\n \t{\n-\t  gcc_assert(field != NULL);\n+\t  go_assert(field != NULL);\n \t  Named_object* no = (*this->results_)[index];\n \t  Bvariable* bvar = no->get_backend_variable(gogo, named_function);\n \t  tree val = var_to_tree(bvar);\n@@ -1893,15 +1893,15 @@ Gogo::go_string_constant_tree(const std::string& val)\n \n   constructor_elt* elt = VEC_quick_push(constructor_elt, init, NULL);\n   tree field = TYPE_FIELDS(string_type);\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__data\") == 0);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__data\") == 0);\n   elt->index = field;\n   tree str = Gogo::string_constant_tree(val);\n   elt->value = fold_convert(TREE_TYPE(field),\n \t\t\t    build_fold_addr_expr(str));\n \n   elt = VEC_quick_push(constructor_elt, init, NULL);\n   field = DECL_CHAIN(field);\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__length\") == 0);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__length\") == 0);\n   elt->index = field;\n   elt->value = build_int_cst_type(TREE_TYPE(field), val.length());\n \n@@ -1963,7 +1963,7 @@ Gogo::slice_type_tree(tree element_type_tree)\n tree\n Gogo::slice_element_type_tree(tree slice_type_tree)\n {\n-  gcc_assert(TREE_CODE(slice_type_tree) == RECORD_TYPE\n+  go_assert(TREE_CODE(slice_type_tree) == RECORD_TYPE\n \t     && POINTER_TYPE_P(TREE_TYPE(TYPE_FIELDS(slice_type_tree))));\n   return TREE_TYPE(TREE_TYPE(TYPE_FIELDS(slice_type_tree)));\n }\n@@ -1977,15 +1977,15 @@ tree\n Gogo::slice_constructor(tree slice_type_tree, tree values, tree count,\n \t\t\ttree capacity)\n {\n-  gcc_assert(TREE_CODE(slice_type_tree) == RECORD_TYPE);\n+  go_assert(TREE_CODE(slice_type_tree) == RECORD_TYPE);\n \n   VEC(constructor_elt,gc)* init = VEC_alloc(constructor_elt, gc, 3);\n \n   tree field = TYPE_FIELDS(slice_type_tree);\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__values\") == 0);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__values\") == 0);\n   constructor_elt* elt = VEC_quick_push(constructor_elt, init, NULL);\n   elt->index = field;\n-  gcc_assert(TYPE_MAIN_VARIANT(TREE_TYPE(field))\n+  go_assert(TYPE_MAIN_VARIANT(TREE_TYPE(field))\n \t     == TYPE_MAIN_VARIANT(TREE_TYPE(values)));\n   elt->value = values;\n \n@@ -1997,13 +1997,13 @@ Gogo::slice_constructor(tree slice_type_tree, tree values, tree count,\n     }\n \n   field = DECL_CHAIN(field);\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__count\") == 0);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__count\") == 0);\n   elt = VEC_quick_push(constructor_elt, init, NULL);\n   elt->index = field;\n   elt->value = fold_convert(TREE_TYPE(field), count);\n \n   field = DECL_CHAIN(field);\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__capacity\") == 0);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__capacity\") == 0);\n   elt = VEC_quick_push(constructor_elt, init, NULL);\n   elt->index = field;\n   elt->value = fold_convert(TREE_TYPE(field), capacity);\n@@ -2042,7 +2042,7 @@ Gogo::map_descriptor(Map_type* maptype)\n     {\n       if (p->second == error_mark_node)\n \treturn error_mark_node;\n-      gcc_assert(p->second != NULL_TREE && DECL_P(p->second));\n+      go_assert(p->second != NULL_TREE && DECL_P(p->second));\n       return build_fold_addr_expr(p->second);\n     }\n \n@@ -2077,26 +2077,26 @@ Gogo::map_descriptor(Map_type* maptype)\n     }\n \n   tree map_entry_key_field = DECL_CHAIN(TYPE_FIELDS(map_entry_type));\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(map_entry_key_field)),\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(map_entry_key_field)),\n \t\t    \"__key\") == 0);\n \n   tree map_entry_val_field = DECL_CHAIN(map_entry_key_field);\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(map_entry_val_field)),\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(map_entry_val_field)),\n \t\t    \"__val\") == 0);\n \n   // Initialize the entries.\n \n   tree map_descriptor_field = TYPE_FIELDS(struct_type);\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(map_descriptor_field)),\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(map_descriptor_field)),\n \t\t    \"__map_descriptor\") == 0);\n   tree entry_size_field = DECL_CHAIN(map_descriptor_field);\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(entry_size_field)),\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(entry_size_field)),\n \t\t    \"__entry_size\") == 0);\n   tree key_offset_field = DECL_CHAIN(entry_size_field);\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(key_offset_field)),\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(key_offset_field)),\n \t\t    \"__key_offset\") == 0);\n   tree val_offset_field = DECL_CHAIN(key_offset_field);\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(val_offset_field)),\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(val_offset_field)),\n \t\t    \"__val_offset\") == 0);\n \n   VEC(constructor_elt, gc)* descriptor = VEC_alloc(constructor_elt, gc, 6);\n@@ -2177,7 +2177,7 @@ Gogo::type_descriptor_decl_name(const Named_object* no,\n {\n   std::string ret = \"__go_tdn_\";\n   if (no->type_value()->is_builtin())\n-    gcc_assert(in_function == NULL);\n+    go_assert(in_function == NULL);\n   else\n     {\n       const std::string& unique_prefix(no->package() == NULL\n@@ -2325,15 +2325,15 @@ Gogo::build_type_descriptor_decl(const Type* type, Expression* initializer,\n   tree constructor = initializer->get_tree(&context);\n \n   if (constructor == error_mark_node)\n-    gcc_assert(saw_errors());\n+    go_assert(saw_errors());\n \n   DECL_INITIAL(decl) = constructor;\n \n   if (type_descriptor_location == TYPE_DESCRIPTOR_DEFINED)\n     TREE_PUBLIC(decl) = 1;\n   else\n     {\n-      gcc_assert(type_descriptor_location == TYPE_DESCRIPTOR_COMMON);\n+      go_assert(type_descriptor_location == TYPE_DESCRIPTOR_COMMON);\n       make_decl_one_only(decl, DECL_ASSEMBLER_NAME(decl));\n       resolve_unique_section(decl, 1, 0);\n     }\n@@ -2351,7 +2351,7 @@ Gogo::interface_method_table_for_type(const Interface_type* interface,\n \t\t\t\t      bool is_pointer)\n {\n   const Typed_identifier_list* interface_methods = interface->methods();\n-  gcc_assert(!interface_methods->empty());\n+  go_assert(!interface_methods->empty());\n \n   std::string mangled_name = ((is_pointer ? \"__go_pimt__\" : \"__go_imt_\")\n \t\t\t      + interface->mangled_name(this)\n@@ -2411,7 +2411,7 @@ Gogo::interface_method_table_for_type(const Interface_type* interface,\n     {\n       bool is_ambiguous;\n       Method* m = type->method_function(p->name(), &is_ambiguous);\n-      gcc_assert(m != NULL);\n+      go_assert(m != NULL);\n \n       Named_object* no = m->named_object();\n \n@@ -2431,7 +2431,7 @@ Gogo::interface_method_table_for_type(const Interface_type* interface,\n       elt->index = size_int(i);\n       elt->value = fold_convert(const_ptr_type_node, fndecl);\n     }\n-  gcc_assert(i == count + 1);\n+  go_assert(i == count + 1);\n \n   tree array_type = build_array_type(const_ptr_type_node,\n \t\t\t\t     build_index_type(size_int(count)));"}, {"sha": "2ea6c5cf9679e80a9efce5282ed205e109d5a482", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=26409c5246d31c7709ea85e8fea698d38bfb161d", "patch": "@@ -220,7 +220,7 @@ Gogo::message_name(const std::string& name)\n const std::string&\n Gogo::package_name() const\n {\n-  gcc_assert(this->package_ != NULL);\n+  go_assert(this->package_ != NULL);\n   return this->package_->name();\n }\n \n@@ -465,8 +465,8 @@ Gogo::lookup(const std::string& name, Named_object** pfunction) const\n Named_object*\n Gogo::lookup_in_block(const std::string& name) const\n {\n-  gcc_assert(!this->functions_.empty());\n-  gcc_assert(!this->functions_.back().blocks.empty());\n+  go_assert(!this->functions_.empty());\n+  go_assert(!this->functions_.back().blocks.empty());\n   return this->functions_.back().blocks.back()->bindings()->lookup_local(name);\n }\n \n@@ -537,7 +537,7 @@ Named_object*\n Gogo::add_package(const std::string& real_name, const std::string& alias,\n \t\t  const std::string& unique_prefix, source_location location)\n {\n-  gcc_assert(this->in_global_scope());\n+  go_assert(this->in_global_scope());\n \n   // Register the package.  Note that we might have already seen it in\n   // an earlier import.\n@@ -555,7 +555,7 @@ Gogo::register_package(const std::string& package_name,\n \t\t       const std::string& unique_prefix,\n \t\t       source_location location)\n {\n-  gcc_assert(!unique_prefix.empty() && !package_name.empty());\n+  go_assert(!unique_prefix.empty() && !package_name.empty());\n   std::string name = unique_prefix + '.' + package_name;\n   Package* package = NULL;\n   std::pair<Packages::iterator, bool> ins =\n@@ -564,8 +564,8 @@ Gogo::register_package(const std::string& package_name,\n     {\n       // We have seen this package name before.\n       package = ins.first->second;\n-      gcc_assert(package != NULL);\n-      gcc_assert(package->name() == package_name\n+      go_assert(package != NULL);\n+      go_assert(package->name() == package_name\n \t\t && package->unique_prefix() == unique_prefix);\n       if (package->location() == UNKNOWN_LOCATION)\n \tpackage->set_location(location);\n@@ -574,7 +574,7 @@ Gogo::register_package(const std::string& package_name,\n     {\n       // First time we have seen this package name.\n       package = new Package(package_name, unique_prefix, location);\n-      gcc_assert(ins.first->second == NULL);\n+      go_assert(ins.first->second == NULL);\n       ins.first->second = package;\n     }\n \n@@ -707,7 +707,7 @@ Gogo::start_function(const std::string& name, Function_type* type,\n \tret = Named_object::make_function(name, NULL, function);\n       else\n \t{\n-\t  gcc_assert(at_top_level);\n+\t  go_assert(at_top_level);\n \t  Type* rtype = type->receiver()->type();\n \n \t  // We want to look through the pointer created by the\n@@ -741,7 +741,7 @@ Gogo::start_function(const std::string& name, Function_type* type,\n \t\t  Named_object* declared =\n \t\t    this->declare_package_type(type_no->name(),\n \t\t\t\t\t       type_no->location());\n-\t\t  gcc_assert(declared\n+\t\t  go_assert(declared\n \t\t\t     == type_no->unknown_value()->real_named_object());\n \t\t}\n \t      ret = rtype->forward_declaration_type()->add_method(name,\n@@ -773,7 +773,7 @@ void\n Gogo::finish_function(source_location location)\n {\n   this->finish_block(location);\n-  gcc_assert(this->functions_.back().blocks.empty());\n+  go_assert(this->functions_.back().blocks.empty());\n   this->functions_.pop_back();\n }\n \n@@ -782,7 +782,7 @@ Gogo::finish_function(source_location location)\n Named_object*\n Gogo::current_function() const\n {\n-  gcc_assert(!this->functions_.empty());\n+  go_assert(!this->functions_.empty());\n   return this->functions_.back().function;\n }\n \n@@ -791,7 +791,7 @@ Gogo::current_function() const\n void\n Gogo::start_block(source_location location)\n {\n-  gcc_assert(!this->functions_.empty());\n+  go_assert(!this->functions_.empty());\n   Block* block = new Block(this->current_block(), location);\n   this->functions_.back().blocks.push_back(block);\n }\n@@ -801,8 +801,8 @@ Gogo::start_block(source_location location)\n Block*\n Gogo::finish_block(source_location location)\n {\n-  gcc_assert(!this->functions_.empty());\n-  gcc_assert(!this->functions_.back().blocks.empty());\n+  go_assert(!this->functions_.empty());\n+  go_assert(!this->functions_.back().blocks.empty());\n   Block* block = this->functions_.back().blocks.back();\n   this->functions_.back().blocks.pop_back();\n   block->set_end_location(location);\n@@ -859,7 +859,7 @@ Label*\n Gogo::add_label_definition(const std::string& label_name,\n \t\t\t   source_location location)\n {\n-  gcc_assert(!this->functions_.empty());\n+  go_assert(!this->functions_.empty());\n   Function* func = this->functions_.back().function->func_value();\n   Label* label = func->add_label_definition(label_name, location);\n   this->add_statement(Statement::make_label_statement(label, location));\n@@ -871,7 +871,7 @@ Gogo::add_label_definition(const std::string& label_name,\n Label*\n Gogo::add_label_reference(const std::string& label_name)\n {\n-  gcc_assert(!this->functions_.empty());\n+  go_assert(!this->functions_.empty());\n   Function* func = this->functions_.back().function->func_value();\n   return func->add_label_reference(label_name);\n }\n@@ -881,7 +881,7 @@ Gogo::add_label_reference(const std::string& label_name)\n void\n Gogo::add_statement(Statement* statement)\n {\n-  gcc_assert(!this->functions_.empty()\n+  go_assert(!this->functions_.empty()\n \t     && !this->functions_.back().blocks.empty());\n   this->functions_.back().blocks.back()->add_statement(statement);\n }\n@@ -891,7 +891,7 @@ Gogo::add_statement(Statement* statement)\n void\n Gogo::add_block(Block* block, source_location location)\n {\n-  gcc_assert(!this->functions_.empty()\n+  go_assert(!this->functions_.empty()\n \t     && !this->functions_.back().blocks.empty());\n   Statement* statement = Statement::make_block_statement(block, location);\n   this->functions_.back().blocks.back()->add_statement(statement);\n@@ -922,7 +922,7 @@ Gogo::add_type(const std::string& name, Type* type, source_location location)\n void\n Gogo::add_named_type(Named_type* type)\n {\n-  gcc_assert(this->in_global_scope());\n+  go_assert(this->in_global_scope());\n   this->current_bindings()->add_named_type(type);\n }\n \n@@ -1206,7 +1206,7 @@ Lower_parse_tree::constant(Named_object* no, bool)\n     return TRAVERSE_CONTINUE;\n   nc->set_lowering();\n \n-  gcc_assert(this->iota_value_ == -1);\n+  go_assert(this->iota_value_ == -1);\n   this->iota_value_ = nc->iota_value();\n   nc->traverse_expression(this);\n   this->iota_value_ = -1;\n@@ -1227,7 +1227,7 @@ Lower_parse_tree::function(Named_object* no)\n {\n   no->func_value()->set_closure_type();\n \n-  gcc_assert(this->function_ == NULL);\n+  go_assert(this->function_ == NULL);\n   this->function_ = no;\n   int t = no->func_value()->traverse(this);\n   this->function_ = NULL;\n@@ -1324,7 +1324,7 @@ Gogo::lower_expression(Named_object* function, Expression** pexpr)\n void\n Gogo::lower_constant(Named_object* no)\n {\n-  gcc_assert(no->is_const());\n+  go_assert(no->is_const());\n   Lower_parse_tree lower(this, NULL);\n   lower.constant(no, false);\n }\n@@ -1644,7 +1644,7 @@ Find_shortcut::expression(Expression** pexpr)\n   Operator op = be->op();\n   if (op != OPERATOR_OROR && op != OPERATOR_ANDAND)\n     return TRAVERSE_CONTINUE;\n-  gcc_assert(this->found_ == NULL);\n+  go_assert(this->found_ == NULL);\n   this->found_ = pexpr;\n   return TRAVERSE_EXIT;\n }\n@@ -2173,7 +2173,7 @@ Build_recover_thunks::function(Named_object* orig_no)\n \t   ++p)\n \t{\n \t  Named_object* p_no = gogo->lookup(p->name(), NULL);\n-\t  gcc_assert(p_no != NULL\n+\t  go_assert(p_no != NULL\n \t\t     && p_no->is_variable()\n \t\t     && p_no->var_value()->is_parameter());\n \t  args->push_back(Expression::make_var_reference(p_no, location));\n@@ -2217,18 +2217,18 @@ Build_recover_thunks::function(Named_object* orig_no)\n       // We changed the receiver to be a regular parameter.  We have\n       // to update the binding accordingly in both functions.\n       Named_object* orig_rec_no = orig_bindings->lookup_local(receiver_name);\n-      gcc_assert(orig_rec_no != NULL\n+      go_assert(orig_rec_no != NULL\n \t\t && orig_rec_no->is_variable()\n \t\t && !orig_rec_no->var_value()->is_receiver());\n       orig_rec_no->var_value()->set_is_receiver();\n \n       const std::string& new_receiver_name(orig_fntype->receiver()->name());\n       Named_object* new_rec_no = new_bindings->lookup_local(new_receiver_name);\n       if (new_rec_no == NULL)\n-\tgcc_assert(saw_errors());\n+\tgo_assert(saw_errors());\n       else\n \t{\n-\t  gcc_assert(new_rec_no->is_variable()\n+\t  go_assert(new_rec_no->is_variable()\n \t\t     && new_rec_no->var_value()->is_receiver());\n \t  new_rec_no->var_value()->set_is_not_receiver();\n \t}\n@@ -2238,7 +2238,7 @@ Build_recover_thunks::function(Named_object* orig_no)\n   // parameter appears in the (now) old bindings as a parameter.\n   // Change it to a local variable, whereupon it will be discarded.\n   Named_object* can_recover_no = orig_bindings->lookup_local(can_recover_name);\n-  gcc_assert(can_recover_no != NULL\n+  go_assert(can_recover_no != NULL\n \t     && can_recover_no->is_variable()\n \t     && can_recover_no->var_value()->is_parameter());\n   orig_bindings->remove_binding(can_recover_no);\n@@ -2488,7 +2488,7 @@ Gogo::check_return_statements()\n const std::string&\n Gogo::unique_prefix() const\n {\n-  gcc_assert(!this->unique_prefix_.empty());\n+  go_assert(!this->unique_prefix_.empty());\n   return this->unique_prefix_;\n }\n \n@@ -2498,7 +2498,7 @@ Gogo::unique_prefix() const\n void\n Gogo::set_unique_prefix(const std::string& arg)\n {\n-  gcc_assert(this->unique_prefix_.empty());\n+  go_assert(this->unique_prefix_.empty());\n   this->unique_prefix_ = arg;\n   this->unique_prefix_specified_ = true;\n }\n@@ -2672,7 +2672,7 @@ Function::create_result_variables(Gogo* gogo)\n \t  ++dummy_result_count;\n \t  name = gogo->pack_hidden_name(buf, false);\n \t  no = block->bindings()->add_result_variable(name, result);\n-\t  gcc_assert(no->is_result_variable());\n+\t  go_assert(no->is_result_variable());\n \t  this->results_->push_back(no);\n \t}\n     }\n@@ -2803,7 +2803,7 @@ Function::add_label_reference(const std::string& label_name)\n     }\n   else\n     {\n-      gcc_assert(ins.first->second == NULL);\n+      go_assert(ins.first->second == NULL);\n       Label* label = new Label(label_name);\n       ins.first->second = label;\n       label->set_is_used();\n@@ -2834,13 +2834,13 @@ Function::check_labels() const\n void\n Function::swap_for_recover(Function *x)\n {\n-  gcc_assert(this->enclosing_ == x->enclosing_);\n+  go_assert(this->enclosing_ == x->enclosing_);\n   std::swap(this->results_, x->results_);\n   std::swap(this->closure_var_, x->closure_var_);\n   std::swap(this->block_, x->block_);\n-  gcc_assert(this->location_ == x->location_);\n-  gcc_assert(this->fndecl_ == NULL && x->fndecl_ == NULL);\n-  gcc_assert(this->defer_stack_ == NULL && x->defer_stack_ == NULL);\n+  go_assert(this->location_ == x->location_);\n+  go_assert(this->fndecl_ == NULL && x->fndecl_ == NULL);\n+  go_assert(this->defer_stack_ == NULL && x->defer_stack_ == NULL);\n }\n \n // Traverse the tree.\n@@ -3032,7 +3032,7 @@ Function::import_func(Import* imp, std::string* pname,\n \t\t\t\t\t\t ptype, imp->location()));\n \t  if (imp->peek_char() != ',')\n \t    break;\n-\t  gcc_assert(!*is_varargs);\n+\t  go_assert(!*is_varargs);\n \t  imp->require_c_string(\", \");\n \t}\n     }\n@@ -3105,7 +3105,7 @@ Block::add_statement_at_front(Statement* statement)\n void\n Block::replace_statement(size_t index, Statement* s)\n {\n-  gcc_assert(index < this->statements_.size());\n+  go_assert(index < this->statements_.size());\n   this->statements_[index] = s;\n }\n \n@@ -3114,7 +3114,7 @@ Block::replace_statement(size_t index, Statement* s)\n void\n Block::insert_statement_before(size_t index, Statement* s)\n {\n-  gcc_assert(index < this->statements_.size());\n+  go_assert(index < this->statements_.size());\n   this->statements_.insert(this->statements_.begin() + index, s);\n }\n \n@@ -3123,7 +3123,7 @@ Block::insert_statement_before(size_t index, Statement* s)\n void\n Block::insert_statement_after(size_t index, Statement* s)\n {\n-  gcc_assert(index < this->statements_.size());\n+  go_assert(index < this->statements_.size());\n   this->statements_.insert(this->statements_.begin() + index + 1, s);\n }\n \n@@ -3340,8 +3340,8 @@ Variable::Variable(Type* type, Expression* init, bool is_global,\n     type_from_range_value_(false), type_from_chan_element_(false),\n     is_type_switch_var_(false), determined_type_(false)\n {\n-  gcc_assert(type != NULL || init != NULL);\n-  gcc_assert(!is_parameter || init == NULL);\n+  go_assert(type != NULL || init != NULL);\n+  go_assert(!is_parameter || init == NULL);\n }\n \n // Traverse the initializer expression.\n@@ -3390,7 +3390,7 @@ Variable::lower_init_expression(Gogo* gogo, Named_object* function)\n Block*\n Variable::preinit_block(Gogo* gogo)\n {\n-  gcc_assert(this->is_global_);\n+  go_assert(this->is_global_);\n   if (this->preinit_ == NULL)\n     this->preinit_ = new Block(NULL, this->location());\n \n@@ -3519,7 +3519,7 @@ Variable::type()\n       && this->type_->is_nil_constant_as_type())\n     {\n       Type_guard_expression* tge = this->init_->type_guard_expression();\n-      gcc_assert(tge != NULL);\n+      go_assert(tge != NULL);\n       init = tge->expr();\n       type = NULL;\n     }\n@@ -3546,9 +3546,9 @@ Variable::type()\n     type = this->type_from_chan_element(init, false);\n   else\n     {\n-      gcc_assert(init != NULL);\n+      go_assert(init != NULL);\n       type = init->type();\n-      gcc_assert(type != NULL);\n+      go_assert(type != NULL);\n \n       // Variables should not have abstract types.\n       if (type->is_abstract())\n@@ -3569,7 +3569,7 @@ Variable::type()\n Type*\n Variable::type() const\n {\n-  gcc_assert(this->type_ != NULL);\n+  go_assert(this->type_ != NULL);\n   return this->type_;\n }\n \n@@ -3592,13 +3592,13 @@ Variable::determine_type()\n   if (this->is_type_switch_var_ && this->type_->is_nil_constant_as_type())\n     {\n       Type_guard_expression* tge = this->init_->type_guard_expression();\n-      gcc_assert(tge != NULL);\n+      go_assert(tge != NULL);\n       this->type_ = NULL;\n       this->init_ = tge->expr();\n     }\n \n   if (this->init_ == NULL)\n-    gcc_assert(this->type_ != NULL && !this->type_->is_abstract());\n+    go_assert(this->type_ != NULL && !this->type_->is_abstract());\n   else if (this->type_from_init_tuple_)\n     {\n       Expression *init = this->init_;\n@@ -3628,7 +3628,7 @@ Variable::determine_type()\n       if (this->type_ == NULL)\n \t{\n \t  Type* type = this->init_->type();\n-\t  gcc_assert(type != NULL);\n+\t  go_assert(type != NULL);\n \t  if (type->is_abstract())\n \t    type = type->make_non_abstract_type();\n \n@@ -3659,7 +3659,7 @@ Variable::determine_type()\n void\n Variable::export_var(Export* exp, const std::string& name) const\n {\n-  gcc_assert(this->is_global_);\n+  go_assert(this->is_global_);\n   exp->write_c_string(\"var \");\n   exp->write_string(name);\n   exp->write_c_string(\" \");\n@@ -3792,7 +3792,7 @@ Named_constant::determine_type()\n       Type_context context(NULL, true);\n       this->expr_->determine_type(&context);\n       this->type_ = this->expr_->type();\n-      gcc_assert(this->type_ != NULL);\n+      go_assert(this->type_ != NULL);\n     }\n }\n \n@@ -3903,8 +3903,8 @@ Type_declaration::using_type()\n void\n Unknown_name::set_real_named_object(Named_object* no)\n {\n-  gcc_assert(this->real_named_object_ == NULL);\n-  gcc_assert(!no->is_unknown());\n+  go_assert(this->real_named_object_ == NULL);\n+  go_assert(!no->is_unknown());\n   this->real_named_object_ = no;\n }\n \n@@ -3917,7 +3917,7 @@ Named_object::Named_object(const std::string& name,\n     tree_(NULL)\n {\n   if (Gogo::is_sink_name(name))\n-    gcc_assert(classification == NAMED_OBJECT_SINK);\n+    go_assert(classification == NAMED_OBJECT_SINK);\n }\n \n // Make an unknown name.  This is used by the parser.  The name must\n@@ -4066,7 +4066,7 @@ Named_object::message_name() const\n void\n Named_object::set_type_value(Named_type* named_type)\n {\n-  gcc_assert(this->classification_ == NAMED_OBJECT_TYPE_DECLARATION);\n+  go_assert(this->classification_ == NAMED_OBJECT_TYPE_DECLARATION);\n   Type_declaration* td = this->u_.type_declaration;\n   td->define_methods(named_type);\n   Named_object* in_function = td->in_function();\n@@ -4082,7 +4082,7 @@ Named_object::set_type_value(Named_type* named_type)\n void\n Named_object::set_function_value(Function* function)\n {\n-  gcc_assert(this->classification_ == NAMED_OBJECT_FUNC_DECLARATION);\n+  go_assert(this->classification_ == NAMED_OBJECT_FUNC_DECLARATION);\n   this->classification_ = NAMED_OBJECT_FUNC;\n   // FIXME: We should free the old value.\n   this->u_.func_value = function;\n@@ -4093,7 +4093,7 @@ Named_object::set_function_value(Function* function)\n void\n Named_object::declare_as_type()\n {\n-  gcc_assert(this->classification_ == NAMED_OBJECT_UNKNOWN);\n+  go_assert(this->classification_ == NAMED_OBJECT_UNKNOWN);\n   Unknown_name* unk = this->u_.unknown_value;\n   this->classification_ = NAMED_OBJECT_TYPE_DECLARATION;\n   this->u_.type_declaration = new Type_declaration(unk->location());\n@@ -4268,7 +4268,7 @@ void\n Bindings::remove_binding(Named_object* no)\n {\n   Contour::iterator pb = this->bindings_.find(no->name());\n-  gcc_assert(pb != this->bindings_.end());\n+  go_assert(pb != this->bindings_.end());\n   this->bindings_.erase(pb);\n   for (std::vector<Named_object*>::iterator pn = this->named_objects_.begin();\n        pn != this->named_objects_.end();\n@@ -4300,9 +4300,9 @@ Named_object*\n Bindings::add_named_object_to_contour(Contour* contour,\n \t\t\t\t      Named_object* named_object)\n {\n-  gcc_assert(named_object == named_object->resolve());\n+  go_assert(named_object == named_object->resolve());\n   const std::string& name(named_object->name());\n-  gcc_assert(!Gogo::is_sink_name(name));\n+  go_assert(!Gogo::is_sink_name(name));\n \n   std::pair<Contour::iterator, bool> ins =\n     contour->insert(std::make_pair(name, named_object));\n@@ -4353,7 +4353,7 @@ Bindings::new_definition(Named_object* old_object, Named_object* new_object)\n \tNamed_object* real = old_object->unknown_value()->real_named_object();\n \tif (real != NULL)\n \t  return this->new_definition(real, new_object);\n-\tgcc_assert(!new_object->is_unknown());\n+\tgo_assert(!new_object->is_unknown());\n \told_object->unknown_value()->set_real_named_object(new_object);\n \tif (!new_object->is_type_declaration()\n \t    && !new_object->is_function_declaration())\n@@ -4576,7 +4576,7 @@ Bindings::traverse(Traverse* traverse, bool is_global)\n \n \tcase Named_object::NAMED_OBJECT_PACKAGE:\n \t  // These are traversed in Gogo::traverse.\n-\t  gcc_assert(is_global);\n+\t  go_assert(is_global);\n \t  break;\n \n \tcase Named_object::NAMED_OBJECT_TYPE:\n@@ -4673,7 +4673,7 @@ Package::Package(const std::string& name, const std::string& unique_prefix,\n     priority_(0), location_(location), used_(false), is_imported_(false),\n     uses_sink_alias_(false)\n {\n-  gcc_assert(!name.empty() && !unique_prefix.empty());\n+  go_assert(!name.empty() && !unique_prefix.empty());\n }\n \n // Set the priority.  We may see multiple priorities for an imported\n@@ -4723,7 +4723,7 @@ Traverse::remember_type(const Type* type)\n {\n   if (type->is_error_type())\n     return true;\n-  gcc_assert((this->traverse_mask() & traverse_types) != 0\n+  go_assert((this->traverse_mask() & traverse_types) != 0\n \t     || (this->traverse_mask() & traverse_expressions) != 0);\n   // We only have to remember named types, as they are the only ones\n   // we can see multiple times in a traversal.\n@@ -4741,7 +4741,7 @@ Traverse::remember_type(const Type* type)\n bool\n Traverse::remember_expression(const Expression* expression)\n {\n-  gcc_assert((this->traverse_mask() & traverse_types) != 0\n+  go_assert((this->traverse_mask() & traverse_types) != 0\n \t     || (this->traverse_mask() & traverse_expressions) != 0);\n   if (this->expressions_seen_ == NULL)\n     this->expressions_seen_ = new Expressions_seen();"}, {"sha": "788c80a454d218bce14da9edcd437cc29d3974c6", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=26409c5246d31c7709ea85e8fea698d38bfb161d", "patch": "@@ -156,7 +156,7 @@ class Gogo\n   static std::string\n   hidden_name_prefix(const std::string& name)\n   {\n-    gcc_assert(Gogo::is_hidden_name(name));\n+    go_assert(Gogo::is_hidden_name(name));\n     return name.substr(1, name.rfind('.') - 1);\n   }\n \n@@ -819,7 +819,7 @@ class Function\n   void\n   set_enclosing(Function* enclosing)\n   {\n-    gcc_assert(this->enclosing_ == NULL);\n+    go_assert(this->enclosing_ == NULL);\n     this->enclosing_ = enclosing;\n   }\n \n@@ -865,7 +865,7 @@ class Function\n   void\n   set_closure_var(Named_object* v)\n   {\n-    gcc_assert(this->closure_var_ == NULL);\n+    go_assert(this->closure_var_ == NULL);\n     this->closure_var_ = v;\n   }\n \n@@ -874,7 +874,7 @@ class Function\n   Named_object*\n   enclosing_var(unsigned int index)\n   {\n-    gcc_assert(index < this->closure_fields_.size());\n+    go_assert(index < this->closure_fields_.size());\n     return closure_fields_[index].first;\n   }\n \n@@ -961,7 +961,7 @@ class Function\n   tree\n   get_decl() const\n   {\n-    gcc_assert(this->fndecl_ != NULL);\n+    go_assert(this->fndecl_ != NULL);\n     return this->fndecl_;\n   }\n \n@@ -1147,7 +1147,7 @@ class Variable\n   void\n   set_is_receiver()\n   {\n-    gcc_assert(this->is_parameter_);\n+    go_assert(this->is_parameter_);\n     this->is_receiver_ = true;\n   }\n \n@@ -1156,7 +1156,7 @@ class Variable\n   void\n   set_is_not_receiver()\n   {\n-    gcc_assert(this->is_parameter_);\n+    go_assert(this->is_parameter_);\n     this->is_receiver_ = false;\n   }\n \n@@ -1184,7 +1184,7 @@ class Variable\n   void\n   set_is_varargs_parameter()\n   {\n-    gcc_assert(this->is_parameter_);\n+    go_assert(this->is_parameter_);\n     this->is_varargs_parameter_ = true;\n   }\n \n@@ -1250,7 +1250,7 @@ class Variable\n   void\n   clear_type_from_chan_element()\n   {\n-    gcc_assert(this->type_from_chan_element_);\n+    go_assert(this->type_from_chan_element_);\n     this->type_from_chan_element_ = false;\n   }\n \n@@ -1722,126 +1722,126 @@ class Named_object\n   Unknown_name*\n   unknown_value()\n   {\n-    gcc_assert(this->classification_ == NAMED_OBJECT_UNKNOWN);\n+    go_assert(this->classification_ == NAMED_OBJECT_UNKNOWN);\n     return this->u_.unknown_value;\n   }\n \n   const Unknown_name*\n   unknown_value() const\n   {\n-    gcc_assert(this->classification_ == NAMED_OBJECT_UNKNOWN);\n+    go_assert(this->classification_ == NAMED_OBJECT_UNKNOWN);\n     return this->u_.unknown_value;\n   }\n \n   Named_constant*\n   const_value()\n   {\n-    gcc_assert(this->classification_ == NAMED_OBJECT_CONST);\n+    go_assert(this->classification_ == NAMED_OBJECT_CONST);\n     return this->u_.const_value;\n   }\n \n   const Named_constant*\n   const_value() const\n   {\n-    gcc_assert(this->classification_ == NAMED_OBJECT_CONST);\n+    go_assert(this->classification_ == NAMED_OBJECT_CONST);\n     return this->u_.const_value;\n   }\n \n   Named_type*\n   type_value()\n   {\n-    gcc_assert(this->classification_ == NAMED_OBJECT_TYPE);\n+    go_assert(this->classification_ == NAMED_OBJECT_TYPE);\n     return this->u_.type_value;\n   }\n \n   const Named_type*\n   type_value() const\n   {\n-    gcc_assert(this->classification_ == NAMED_OBJECT_TYPE);\n+    go_assert(this->classification_ == NAMED_OBJECT_TYPE);\n     return this->u_.type_value;\n   }\n \n   Type_declaration*\n   type_declaration_value()\n   {\n-    gcc_assert(this->classification_ == NAMED_OBJECT_TYPE_DECLARATION);\n+    go_assert(this->classification_ == NAMED_OBJECT_TYPE_DECLARATION);\n     return this->u_.type_declaration;\n   }\n \n   const Type_declaration*\n   type_declaration_value() const\n   {\n-    gcc_assert(this->classification_ == NAMED_OBJECT_TYPE_DECLARATION);\n+    go_assert(this->classification_ == NAMED_OBJECT_TYPE_DECLARATION);\n     return this->u_.type_declaration;\n   }\n \n   Variable*\n   var_value()\n   {\n-    gcc_assert(this->classification_ == NAMED_OBJECT_VAR);\n+    go_assert(this->classification_ == NAMED_OBJECT_VAR);\n     return this->u_.var_value;\n   }\n \n   const Variable*\n   var_value() const\n   {\n-    gcc_assert(this->classification_ == NAMED_OBJECT_VAR);\n+    go_assert(this->classification_ == NAMED_OBJECT_VAR);\n     return this->u_.var_value;\n   }\n \n   Result_variable*\n   result_var_value()\n   {\n-    gcc_assert(this->classification_ == NAMED_OBJECT_RESULT_VAR);\n+    go_assert(this->classification_ == NAMED_OBJECT_RESULT_VAR);\n     return this->u_.result_var_value;\n   }\n \n   const Result_variable*\n   result_var_value() const\n   {\n-    gcc_assert(this->classification_ == NAMED_OBJECT_RESULT_VAR);\n+    go_assert(this->classification_ == NAMED_OBJECT_RESULT_VAR);\n     return this->u_.result_var_value;\n   }\n \n   Function*\n   func_value()\n   {\n-    gcc_assert(this->classification_ == NAMED_OBJECT_FUNC);\n+    go_assert(this->classification_ == NAMED_OBJECT_FUNC);\n     return this->u_.func_value;\n   }\n \n   const Function*\n   func_value() const\n   {\n-    gcc_assert(this->classification_ == NAMED_OBJECT_FUNC);\n+    go_assert(this->classification_ == NAMED_OBJECT_FUNC);\n     return this->u_.func_value;\n   }\n \n   Function_declaration*\n   func_declaration_value()\n   {\n-    gcc_assert(this->classification_ == NAMED_OBJECT_FUNC_DECLARATION);\n+    go_assert(this->classification_ == NAMED_OBJECT_FUNC_DECLARATION);\n     return this->u_.func_declaration_value;\n   }\n \n   const Function_declaration*\n   func_declaration_value() const\n   {\n-    gcc_assert(this->classification_ == NAMED_OBJECT_FUNC_DECLARATION);\n+    go_assert(this->classification_ == NAMED_OBJECT_FUNC_DECLARATION);\n     return this->u_.func_declaration_value;\n   }\n \n   Package*\n   package_value()\n   {\n-    gcc_assert(this->classification_ == NAMED_OBJECT_PACKAGE);\n+    go_assert(this->classification_ == NAMED_OBJECT_PACKAGE);\n     return this->u_.package_value;\n   }\n \n   const Package*\n   package_value() const\n   {\n-    gcc_assert(this->classification_ == NAMED_OBJECT_PACKAGE);\n+    go_assert(this->classification_ == NAMED_OBJECT_PACKAGE);\n     return this->u_.package_value;\n   }\n \n@@ -2174,7 +2174,7 @@ class Label\n   void\n   define(source_location location)\n   {\n-    gcc_assert(this->location_ == 0);\n+    go_assert(this->location_ == 0);\n     this->location_ = location;\n   }\n \n@@ -2263,7 +2263,7 @@ class Package\n   const std::string&\n   unique_prefix() const\n   {\n-    gcc_assert(!this->unique_prefix_.empty());\n+    go_assert(!this->unique_prefix_.empty());\n     return this->unique_prefix_;\n   }\n "}, {"sha": "4aca1a3f9cb44dc07f988ee17e1b198ad4bcaa05", "filename": "gcc/go/gofrontend/import.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport.cc?ref=26409c5246d31c7709ea85e8fea698d38bfb161d", "patch": "@@ -456,7 +456,7 @@ Import::import_func(Package* package)\n       if (rtype->is_error_type())\n \treturn NULL;\n       Named_type* named_rtype = rtype->named_type();\n-      gcc_assert(named_rtype != NULL);\n+      go_assert(named_rtype != NULL);\n       no = named_rtype->add_method_declaration(name, package, fntype, loc);\n     }\n   else\n@@ -617,7 +617,7 @@ Import::read_type()\n       return Type::make_error_type();\n     }\n   else\n-    gcc_assert(no->package() == package);\n+    go_assert(no->package() == package);\n \n   if (this->types_[index] == NULL)\n     {\n@@ -628,7 +628,7 @@ Import::read_type()\n \t}\n       else\n \t{\n-\t  gcc_assert(no->is_type());\n+\t  go_assert(no->is_type());\n \t  this->types_[index] = no->type_value();\n \t}\n     }\n@@ -714,9 +714,9 @@ void\n Import::register_builtin_type(Gogo* gogo, const char* name, Builtin_code code)\n {\n   Named_object* named_object = gogo->lookup_global(name);\n-  gcc_assert(named_object != NULL && named_object->is_type());\n+  go_assert(named_object != NULL && named_object->is_type());\n   int index = - static_cast<int>(code);\n-  gcc_assert(index > 0\n+  go_assert(index > 0\n \t     && static_cast<size_t>(index) < this->builtin_types_.size());\n   this->builtin_types_[index] = named_object->type_value();\n }\n@@ -842,7 +842,7 @@ Stream_from_file::do_peek(size_t length, const char** bytes)\n       return true;\n     }\n   // Don't bother to handle the general case, since we don't need it.\n-  gcc_assert(length < 64);\n+  go_assert(length < 64);\n   char buf[64];\n   ssize_t got = read(this->fd_, buf, length);\n "}, {"sha": "ce68582f945a7b8a5f8bf45ba02e721a8ea582dc", "filename": "gcc/go/gofrontend/lex.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Flex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Flex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Flex.cc?ref=26409c5246d31c7709ea85e8fea698d38bfb161d", "patch": "@@ -132,9 +132,9 @@ Keywords::keyword_to_code(const char* keyword, size_t len) const\n const char*\n Keywords::keyword_to_string(Keyword code) const\n {\n-  gcc_assert(code > KEYWORD_INVALID && code < this->count_);\n+  go_assert(code > KEYWORD_INVALID && code < this->count_);\n   const Mapping* map = &this->mapping_[code];\n-  gcc_assert(map->keycode == code);\n+  go_assert(map->keycode == code);\n   return map->keystring;\n }\n \n@@ -1005,7 +1005,7 @@ Lex::gather_number()\n \t  std::string s(pnum, p - pnum);\n \t  mpz_t val;\n \t  int r = mpz_init_set_str(val, s.c_str(), base);\n-\t  gcc_assert(r == 0);\n+\t  go_assert(r == 0);\n \n \t  if (neg)\n \t    mpz_neg(val, val);\n@@ -1029,7 +1029,7 @@ Lex::gather_number()\n       std::string s(pnum, p - pnum);\n       mpz_t val;\n       int r = mpz_init_set_str(val, s.c_str(), 10);\n-      gcc_assert(r == 0);\n+      go_assert(r == 0);\n \n       if (neg)\n \tmpz_neg(val, val);\n@@ -1076,7 +1076,7 @@ Lex::gather_number()\n   std::string s(pnum, p - pnum);\n   mpfr_t val;\n   int r = mpfr_init_set_str(val, s.c_str(), 10, GMP_RNDN);\n-  gcc_assert(r == 0);\n+  go_assert(r == 0);\n \n   if (neg)\n     mpfr_neg(val, val, GMP_RNDN);"}, {"sha": "bda07f1f8b0a27b97a24311bed6bf649834bc491", "filename": "gcc/go/gofrontend/lex.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Flex.h?ref=26409c5246d31c7709ea85e8fea698d38bfb161d", "patch": "@@ -183,7 +183,7 @@ class Token\n   Keyword\n   keyword() const\n   {\n-    gcc_assert(this->classification_ == TOKEN_KEYWORD);\n+    go_assert(this->classification_ == TOKEN_KEYWORD);\n     return this->u_.keyword;\n   }\n \n@@ -196,15 +196,15 @@ class Token\n   const std::string&\n   identifier() const\n   {\n-    gcc_assert(this->classification_ == TOKEN_IDENTIFIER);\n+    go_assert(this->classification_ == TOKEN_IDENTIFIER);\n     return *this->u_.identifier_value.name;\n   }\n \n   // Return whether the identifier is exported.\n   bool\n   is_identifier_exported() const\n   {\n-    gcc_assert(this->classification_ == TOKEN_IDENTIFIER);\n+    go_assert(this->classification_ == TOKEN_IDENTIFIER);\n     return this->u_.identifier_value.is_exported;\n   }\n \n@@ -220,39 +220,39 @@ class Token\n   std::string\n   string_value() const\n   {\n-    gcc_assert(this->classification_ == TOKEN_STRING);\n+    go_assert(this->classification_ == TOKEN_STRING);\n     return *this->u_.string_value;\n   }\n \n   // Return the value of an integer.\n   const mpz_t*\n   integer_value() const\n   {\n-    gcc_assert(this->classification_ == TOKEN_INTEGER);\n+    go_assert(this->classification_ == TOKEN_INTEGER);\n     return &this->u_.integer_value;\n   }\n \n   // Return the value of a float.\n   const mpfr_t*\n   float_value() const\n   {\n-    gcc_assert(this->classification_ == TOKEN_FLOAT);\n+    go_assert(this->classification_ == TOKEN_FLOAT);\n     return &this->u_.float_value;\n   }\n \n   // Return the value of an imaginary number.\n   const mpfr_t*\n   imaginary_value() const\n   {\n-    gcc_assert(this->classification_ == TOKEN_IMAGINARY);\n+    go_assert(this->classification_ == TOKEN_IMAGINARY);\n     return &this->u_.float_value;\n   }\n \n   // Return the operator value for an operator token.\n   Operator\n   op() const\n   {\n-    gcc_assert(this->classification_ == TOKEN_OPERATOR);\n+    go_assert(this->classification_ == TOKEN_OPERATOR);\n     return this->u_.op;\n   }\n "}, {"sha": "b2a1715660f6b82b6ccaa02a5f6fb66960c561ba", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=26409c5246d31c7709ea85e8fea698d38bfb161d", "patch": "@@ -85,7 +85,7 @@ Parse::advance_token()\n void\n Parse::unget_token(const Token& token)\n {\n-  gcc_assert(!this->unget_token_valid_);\n+  go_assert(!this->unget_token_valid_);\n   this->unget_token_ = token;\n   this->unget_token_valid_ = true;\n }\n@@ -372,7 +372,7 @@ Parse::type_name(bool issue_error)\n Type*\n Parse::array_type(bool may_use_ellipsis)\n {\n-  gcc_assert(this->peek_token()->is_op(OPERATOR_LSQUARE));\n+  go_assert(this->peek_token()->is_op(OPERATOR_LSQUARE));\n   const Token* token = this->advance_token();\n \n   Expression* length = NULL;\n@@ -419,7 +419,7 @@ Type*\n Parse::map_type()\n {\n   source_location location = this->location();\n-  gcc_assert(this->peek_token()->is_keyword(KEYWORD_MAP));\n+  go_assert(this->peek_token()->is_keyword(KEYWORD_MAP));\n   if (!this->advance_token()->is_op(OPERATOR_LSQUARE))\n     {\n       error_at(this->location(), \"expected %<[%>\");\n@@ -449,7 +449,7 @@ Parse::map_type()\n Type*\n Parse::struct_type()\n {\n-  gcc_assert(this->peek_token()->is_keyword(KEYWORD_STRUCT));\n+  go_assert(this->peek_token()->is_keyword(KEYWORD_STRUCT));\n   source_location location = this->location();\n   if (!this->advance_token()->is_op(OPERATOR_LCURLY))\n     {\n@@ -618,7 +618,7 @@ Parse::field_decl(Struct_field_list* sfl)\n Type*\n Parse::pointer_type()\n {\n-  gcc_assert(this->peek_token()->is_op(OPERATOR_MULT));\n+  go_assert(this->peek_token()->is_op(OPERATOR_MULT));\n   this->advance_token();\n   Type* type = this->type();\n   if (type->is_error_type())\n@@ -649,7 +649,7 @@ Parse::channel_type()\n     }\n   else\n     {\n-      gcc_assert(token->is_keyword(KEYWORD_CHAN));\n+      go_assert(token->is_keyword(KEYWORD_CHAN));\n       if (this->advance_token()->is_op(OPERATOR_CHANOP))\n \t{\n \t  receive = false;\n@@ -870,7 +870,7 @@ Parse::parameter_list(bool* is_varargs)\n \n \t  if (parameters_have_names)\n \t    {\n-\t      gcc_assert(!just_saw_comma);\n+\t      go_assert(!just_saw_comma);\n \t      // We have just seen ID1, ID2 xxx.\n \t      Type* type;\n \t      if (!this->peek_token()->is_op(OPERATOR_ELLIPSIS))\n@@ -1119,7 +1119,7 @@ Parse::block()\n Type*\n Parse::interface_type()\n {\n-  gcc_assert(this->peek_token()->is_keyword(KEYWORD_INTERFACE));\n+  go_assert(this->peek_token()->is_keyword(KEYWORD_INTERFACE));\n   source_location location = this->location();\n \n   if (!this->advance_token()->is_op(OPERATOR_LCURLY))\n@@ -1307,7 +1307,7 @@ Parse::list(void (Parse::*pfn)(void*), void* varg, bool follow_is_paren)\n void\n Parse::const_decl()\n {\n-  gcc_assert(this->peek_token()->is_keyword(KEYWORD_CONST));\n+  go_assert(this->peek_token()->is_keyword(KEYWORD_CONST));\n   this->advance_token();\n   this->reset_iota();\n \n@@ -1408,7 +1408,7 @@ Parse::const_spec(Type** last_type, Expression_list** last_expr_list)\n void\n Parse::type_decl()\n {\n-  gcc_assert(this->peek_token()->is_keyword(KEYWORD_TYPE));\n+  go_assert(this->peek_token()->is_keyword(KEYWORD_TYPE));\n   this->advance_token();\n   this->decl(&Parse::type_spec, NULL);\n }\n@@ -1473,7 +1473,7 @@ Parse::type_spec(void*)\n \t  this->gogo_->define_type(named_type,\n \t\t\t\t   Type::make_named_type(named_type, type,\n \t\t\t\t\t\t\t location));\n-\t  gcc_assert(named_type->package() == NULL);\n+\t  go_assert(named_type->package() == NULL);\n \t}\n       else\n \t{\n@@ -1488,7 +1488,7 @@ Parse::type_spec(void*)\n void\n Parse::var_decl()\n {\n-  gcc_assert(this->peek_token()->is_keyword(KEYWORD_VAR));\n+  go_assert(this->peek_token()->is_keyword(KEYWORD_VAR));\n   this->advance_token();\n   this->decl(&Parse::var_spec, NULL);\n }\n@@ -1583,14 +1583,14 @@ Parse::init_vars(const Typed_identifier_list* til, Type* type,\n        ++p)\n     {\n       if (init != NULL)\n-\tgcc_assert(pexpr != init->end());\n+\tgo_assert(pexpr != init->end());\n       this->init_var(*p, type, init == NULL ? NULL : *pexpr, is_coloneq,\n \t\t     false, &any_new);\n       if (init != NULL)\n \t++pexpr;\n     }\n   if (init != NULL)\n-    gcc_assert(pexpr == init->end());\n+    go_assert(pexpr == init->end());\n   if (is_coloneq && !any_new)\n     error_at(location, \"variables redeclared but no variable is new\");\n }\n@@ -1921,7 +1921,7 @@ Parse::simple_var_decl_or_assignment(const std::string& name,\n   // \"a, *p = 1, 2\".\n   if (this->peek_token()->is_op(OPERATOR_COMMA))\n     {\n-      gcc_assert(p_type_switch == NULL);\n+      go_assert(p_type_switch == NULL);\n       while (true)\n \t{\n \t  const Token* token = this->advance_token();\n@@ -1979,7 +1979,7 @@ Parse::simple_var_decl_or_assignment(const std::string& name,\n \t}\n     }\n \n-  gcc_assert(this->peek_token()->is_op(OPERATOR_COLONEQ));\n+  go_assert(this->peek_token()->is_op(OPERATOR_COLONEQ));\n   const Token* token = this->advance_token();\n \n   if (p_range_clause != NULL && token->is_keyword(KEYWORD_RANGE))\n@@ -2032,7 +2032,7 @@ Parse::simple_var_decl_or_assignment(const std::string& name,\n void\n Parse::function_decl()\n {\n-  gcc_assert(this->peek_token()->is_keyword(KEYWORD_FUNC));\n+  go_assert(this->peek_token()->is_keyword(KEYWORD_FUNC));\n   source_location location = this->location();\n   const Token* token = this->advance_token();\n \n@@ -2120,7 +2120,7 @@ Parse::function_decl()\n Typed_identifier*\n Parse::receiver()\n {\n-  gcc_assert(this->peek_token()->is_op(OPERATOR_LPAREN));\n+  go_assert(this->peek_token()->is_op(OPERATOR_LPAREN));\n \n   std::string name;\n   const Token* token = this->advance_token();\n@@ -2249,7 +2249,7 @@ Parse::operand(bool may_be_sink)\n \t    packed = this->gogo_->pack_hidden_name(id, is_exported);\n \t    named_object = package->lookup(packed);\n \t    location = this->location();\n-\t    gcc_assert(in_function == NULL);\n+\t    go_assert(in_function == NULL);\n \t  }\n \n \tthis->advance_token();\n@@ -2258,7 +2258,7 @@ Parse::operand(bool may_be_sink)\n \t    && named_object->is_type()\n \t    && !named_object->type_value()->is_visible())\n \t  {\n-\t    gcc_assert(package != NULL);\n+\t    go_assert(package != NULL);\n \t    error_at(location, \"invalid reference to hidden type %<%s.%s%>\",\n \t\t     Gogo::message_name(package->name()).c_str(),\n \t\t     Gogo::message_name(id).c_str());\n@@ -2411,7 +2411,7 @@ Expression*\n Parse::enclosing_var_reference(Named_object* in_function, Named_object* var,\n \t\t\t       source_location location)\n {\n-  gcc_assert(var->is_variable() || var->is_result_variable());\n+  go_assert(var->is_variable() || var->is_result_variable());\n \n   Named_object* this_function = this->gogo_->current_function();\n   Named_object* closure = this_function->func_value()->closure_var();\n@@ -2459,7 +2459,7 @@ Parse::enclosing_var_reference(Named_object* in_function, Named_object* var,\n Expression*\n Parse::composite_lit(Type* type, int depth, source_location location)\n {\n-  gcc_assert(this->peek_token()->is_op(OPERATOR_LCURLY));\n+  go_assert(this->peek_token()->is_op(OPERATOR_LCURLY));\n   this->advance_token();\n \n   if (this->peek_token()->is_op(OPERATOR_RCURLY))\n@@ -2583,7 +2583,7 @@ Expression*\n Parse::function_lit()\n {\n   source_location location = this->location();\n-  gcc_assert(this->peek_token()->is_keyword(KEYWORD_FUNC));\n+  go_assert(this->peek_token()->is_keyword(KEYWORD_FUNC));\n   this->advance_token();\n \n   Enclosing_vars hold_enclosing_vars;\n@@ -2653,7 +2653,7 @@ Parse::create_closure(Named_object* function, Enclosing_vars* enclosing_vars,\n   Expression_list* initializer = new Expression_list;\n   for (size_t i = 0; i < enclosing_var_count; ++i)\n     {\n-      gcc_assert(ev[i].index() == i);\n+      go_assert(ev[i].index() == i);\n       Named_object* var = ev[i].var();\n       Expression* ref;\n       if (ev[i].in_function() == enclosing_function)\n@@ -2771,7 +2771,7 @@ Parse::primary_expr(bool may_be_sink, bool may_be_composite_lit,\n Expression*\n Parse::selector(Expression* left, bool* is_type_switch)\n {\n-  gcc_assert(this->peek_token()->is_op(OPERATOR_DOT));\n+  go_assert(this->peek_token()->is_op(OPERATOR_DOT));\n   source_location location = this->location();\n \n   const Token* token = this->advance_token();\n@@ -2831,7 +2831,7 @@ Expression*\n Parse::index(Expression* expr)\n {\n   source_location location = this->location();\n-  gcc_assert(this->peek_token()->is_op(OPERATOR_LSQUARE));\n+  go_assert(this->peek_token()->is_op(OPERATOR_LSQUARE));\n   this->advance_token();\n \n   Expression* start;\n@@ -2867,7 +2867,7 @@ Parse::index(Expression* expr)\n Expression*\n Parse::call(Expression* func)\n {\n-  gcc_assert(this->peek_token()->is_op(OPERATOR_LPAREN));\n+  go_assert(this->peek_token()->is_op(OPERATOR_LPAREN));\n   Expression_list* args = NULL;\n   bool is_varargs = false;\n   const Token* token = this->advance_token();\n@@ -3469,7 +3469,7 @@ Parse::expression_stat(Expression* exp)\n void\n Parse::send_stmt(Expression* channel)\n {\n-  gcc_assert(this->peek_token()->is_op(OPERATOR_CHANOP));\n+  go_assert(this->peek_token()->is_op(OPERATOR_CHANOP));\n   source_location loc = this->location();\n   this->advance_token();\n   Expression* val = this->expression(PRECEDENCE_NORMAL, false, true, NULL);\n@@ -3694,7 +3694,7 @@ Parse::tuple_assignment(Expression_list* lhs, Range_clause* p_range_clause)\n void\n Parse::go_or_defer_stat()\n {\n-  gcc_assert(this->peek_token()->is_keyword(KEYWORD_GO)\n+  go_assert(this->peek_token()->is_keyword(KEYWORD_GO)\n \t     || this->peek_token()->is_keyword(KEYWORD_DEFER));\n   bool is_go = this->peek_token()->is_keyword(KEYWORD_GO);\n   source_location stat_location = this->location();\n@@ -3726,7 +3726,7 @@ Parse::go_or_defer_stat()\n void\n Parse::return_stat()\n {\n-  gcc_assert(this->peek_token()->is_keyword(KEYWORD_RETURN));\n+  go_assert(this->peek_token()->is_keyword(KEYWORD_RETURN));\n   source_location location = this->location();\n   this->advance_token();\n   Expression_list* vals = NULL;\n@@ -3740,7 +3740,7 @@ Parse::return_stat()\n void\n Parse::if_stat()\n {\n-  gcc_assert(this->peek_token()->is_keyword(KEYWORD_IF));\n+  go_assert(this->peek_token()->is_keyword(KEYWORD_IF));\n   source_location location = this->location();\n   this->advance_token();\n \n@@ -3830,7 +3830,7 @@ Parse::if_stat()\n void\n Parse::switch_stat(Label* label)\n {\n-  gcc_assert(this->peek_token()->is_keyword(KEYWORD_SWITCH));\n+  go_assert(this->peek_token()->is_keyword(KEYWORD_SWITCH));\n   source_location location = this->location();\n   this->advance_token();\n \n@@ -4152,7 +4152,7 @@ Parse::type_case_clause(Named_object* switch_no, Type_case_clauses* clauses,\n \n   if (is_default)\n     {\n-      gcc_assert(types.empty());\n+      go_assert(types.empty());\n       if (*saw_default)\n \t{\n \t  error_at(location, \"multiple defaults in type switch\");\n@@ -4212,7 +4212,7 @@ Parse::type_switch_case(std::vector<Type*>* types, bool* is_default)\n void\n Parse::select_stat(Label* label)\n {\n-  gcc_assert(this->peek_token()->is_keyword(KEYWORD_SELECT));\n+  go_assert(this->peek_token()->is_keyword(KEYWORD_SELECT));\n   source_location location = this->location();\n   const Token* token = this->advance_token();\n \n@@ -4530,7 +4530,7 @@ Parse::send_or_recv_stmt(bool* is_send, Expression** channel, Expression** val,\n void\n Parse::for_stat(Label* label)\n {\n-  gcc_assert(this->peek_token()->is_keyword(KEYWORD_FOR));\n+  go_assert(this->peek_token()->is_keyword(KEYWORD_FOR));\n   source_location location = this->location();\n   const Token* token = this->advance_token();\n \n@@ -4650,7 +4650,7 @@ Parse::for_stat(Label* label)\n void\n Parse::for_clause(Expression** cond, Block** post)\n {\n-  gcc_assert(this->peek_token()->is_op(OPERATOR_SEMICOLON));\n+  go_assert(this->peek_token()->is_op(OPERATOR_SEMICOLON));\n   this->advance_token();\n   if (this->peek_token()->is_op(OPERATOR_SEMICOLON))\n     *cond = NULL;\n@@ -4687,12 +4687,12 @@ void\n Parse::range_clause_decl(const Typed_identifier_list* til,\n \t\t\t Range_clause* p_range_clause)\n {\n-  gcc_assert(this->peek_token()->is_keyword(KEYWORD_RANGE));\n+  go_assert(this->peek_token()->is_keyword(KEYWORD_RANGE));\n   source_location location = this->location();\n \n   p_range_clause->found = true;\n \n-  gcc_assert(til->size() >= 1);\n+  go_assert(til->size() >= 1);\n   if (til->size() > 2)\n     error_at(this->location(), \"too many variables for range clause\");\n \n@@ -4733,11 +4733,11 @@ void\n Parse::range_clause_expr(const Expression_list* vals,\n \t\t\t Range_clause* p_range_clause)\n {\n-  gcc_assert(this->peek_token()->is_keyword(KEYWORD_RANGE));\n+  go_assert(this->peek_token()->is_keyword(KEYWORD_RANGE));\n \n   p_range_clause->found = true;\n \n-  gcc_assert(vals->size() >= 1);\n+  go_assert(vals->size() >= 1);\n   if (vals->size() > 2)\n     error_at(this->location(), \"too many variables for range clause\");\n \n@@ -4813,7 +4813,7 @@ Parse::find_bc_statement(const Bc_stack* bc_stack, const std::string& label)\n void\n Parse::break_stat()\n {\n-  gcc_assert(this->peek_token()->is_keyword(KEYWORD_BREAK));\n+  go_assert(this->peek_token()->is_keyword(KEYWORD_BREAK));\n   source_location location = this->location();\n \n   const Token* token = this->advance_token();\n@@ -4869,7 +4869,7 @@ Parse::break_stat()\n void\n Parse::continue_stat()\n {\n-  gcc_assert(this->peek_token()->is_keyword(KEYWORD_CONTINUE));\n+  go_assert(this->peek_token()->is_keyword(KEYWORD_CONTINUE));\n   source_location location = this->location();\n \n   const Token* token = this->advance_token();\n@@ -4918,7 +4918,7 @@ Parse::continue_stat()\n void\n Parse::goto_stat()\n {\n-  gcc_assert(this->peek_token()->is_keyword(KEYWORD_GOTO));\n+  go_assert(this->peek_token()->is_keyword(KEYWORD_GOTO));\n   source_location location = this->location();\n   const Token* token = this->advance_token();\n   if (!token->is_identifier())\n@@ -4972,7 +4972,7 @@ Parse::package_clause()\n void\n Parse::import_decl()\n {\n-  gcc_assert(this->peek_token()->is_keyword(KEYWORD_IMPORT));\n+  go_assert(this->peek_token()->is_keyword(KEYWORD_IMPORT));\n   this->advance_token();\n   this->decl(&Parse::import_spec, NULL);\n }"}, {"sha": "fe9b099eeaa16dd95b78cd0d91a7fb0624dc84ed", "filename": "gcc/go/gofrontend/runtime.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Fruntime.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Fruntime.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.cc?ref=26409c5246d31c7709ea85e8fea698d38bfb161d", "patch": "@@ -77,7 +77,7 @@ static Type* runtime_function_types[NUMBER_OF_RUNTIME_FUNCTION_TYPES];\n static Type*\n runtime_function_type(Runtime_function_type bft)\n {\n-  gcc_assert(bft < NUMBER_OF_RUNTIME_FUNCTION_TYPES);\n+  go_assert(bft < NUMBER_OF_RUNTIME_FUNCTION_TYPES);\n   if (runtime_function_types[bft] == NULL)\n     {\n       const source_location bloc = BUILTINS_LOCATION;\n@@ -223,7 +223,7 @@ convert_to_runtime_function_type(Runtime_function_type bft, Expression* e,\n       return Expression::make_unsafe_cast(runtime_function_type(bft), e, loc);\n \n     case RFT_TYPE:\n-      gcc_assert(e->type() == Type::make_type_descriptor_ptr_type());\n+      go_assert(e->type() == Type::make_type_descriptor_ptr_type());\n       return e;\n     }\n }\n@@ -240,7 +240,7 @@ Runtime::convert_types(Gogo* gogo)\n       if (t != NULL && t->named_type() != NULL)\n \t{\n \t  bool r = t->verify();\n-\t  gcc_assert(r);\n+\t  go_assert(r);\n \t  t->named_type()->convert(gogo);\n \t}\n     }\n@@ -279,7 +279,7 @@ runtime_function_declarations[Runtime::NUMBER_OF_FUNCTIONS];\n Named_object*\n Runtime::runtime_declaration(Function code)\n {\n-  gcc_assert(code < Runtime::NUMBER_OF_FUNCTIONS);\n+  go_assert(code < Runtime::NUMBER_OF_FUNCTIONS);\n   if (runtime_function_declarations[code] == NULL)\n     {\n       const Runtime_function* pb = &runtime_functions[code];\n@@ -339,11 +339,11 @@ Call_expression*\n Runtime::make_call(Runtime::Function code, source_location loc,\n \t\t   int param_count, ...)\n {\n-  gcc_assert(code < Runtime::NUMBER_OF_FUNCTIONS);\n+  go_assert(code < Runtime::NUMBER_OF_FUNCTIONS);\n \n   const Runtime_function* pb = &runtime_functions[code];\n \n-  gcc_assert(static_cast<size_t>(param_count)\n+  go_assert(static_cast<size_t>(param_count)\n \t     <= sizeof(pb->parameter_types) / sizeof(pb->parameter_types[0]));\n \n   Named_object* no = runtime_declaration(code);"}, {"sha": "2fe02780aebfbbd07daa5705b0d3eadc2ebb4d60", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=26409c5246d31c7709ea85e8fea698d38bfb161d", "patch": "@@ -230,7 +230,7 @@ Variable_declaration_statement::do_get_backend(Translate_context* context)\n \n   if (!var->is_in_heap())\n     {\n-      gcc_assert(binit != NULL);\n+      go_assert(binit != NULL);\n       return context->backend()->init_statement(bvar, binit);\n     }\n \n@@ -239,7 +239,7 @@ Variable_declaration_statement::do_get_backend(Translate_context* context)\n   // space, and assign the initial value to the new space.\n   source_location loc = this->location();\n   Named_object* newfn = context->gogo()->lookup_global(\"new\");\n-  gcc_assert(newfn != NULL && newfn->is_function_declaration());\n+  go_assert(newfn != NULL && newfn->is_function_declaration());\n   Expression* func = Expression::make_func_reference(newfn, NULL, loc);\n   Expression_list* params = new Expression_list();\n   params->push_back(Expression::make_type(var->type(), loc));\n@@ -335,7 +335,7 @@ Temporary_statement::do_determine_types()\n   if (this->type_ == NULL)\n     {\n       this->type_ = this->init_->type();\n-      gcc_assert(!this->type_->is_abstract());\n+      go_assert(!this->type_->is_abstract());\n     }\n }\n \n@@ -364,7 +364,7 @@ Temporary_statement::do_check_types(Gogo*)\n Bstatement*\n Temporary_statement::do_get_backend(Translate_context* context)\n {\n-  gcc_assert(this->bvariable_ == NULL);\n+  go_assert(this->bvariable_ == NULL);\n \n   // FIXME: Permitting FUNCTION to be NULL here is a temporary measure\n   // until we have a better representation of the init function.\n@@ -406,7 +406,7 @@ Temporary_statement::get_backend_variable(Translate_context* context) const\n {\n   if (this->bvariable_ == NULL)\n     {\n-      gcc_assert(saw_errors());\n+      go_assert(saw_errors());\n       return context->backend()->error_variable();\n     }\n   return this->bvariable_;\n@@ -774,7 +774,7 @@ Tuple_assignment_statement::do_lower(Gogo*, Named_object*, Block* enclosing)\n        plhs != this->lhs_->end();\n        ++plhs, ++prhs)\n     {\n-      gcc_assert(prhs != this->rhs_->end());\n+      go_assert(prhs != this->rhs_->end());\n \n       if ((*plhs)->is_error_expression()\n \t  || (*plhs)->type()->is_error()\n@@ -794,7 +794,7 @@ Tuple_assignment_statement::do_lower(Gogo*, Named_object*, Block* enclosing)\n       temps.push_back(temp);\n \n     }\n-  gcc_assert(prhs == this->rhs_->end());\n+  go_assert(prhs == this->rhs_->end());\n \n   prhs = this->rhs_->begin();\n   std::vector<Temporary_statement*>::const_iterator ptemp = temps.begin();\n@@ -816,7 +816,7 @@ Tuple_assignment_statement::do_lower(Gogo*, Named_object*, Block* enclosing)\n       b->add_statement(s);\n       ++ptemp;\n     }\n-  gcc_assert(ptemp == temps.end());\n+  go_assert(ptemp == temps.end());\n \n   return Statement::make_block_statement(b, loc);\n }\n@@ -1709,7 +1709,7 @@ class Simplify_thunk_traverse : public Traverse\n int\n Simplify_thunk_traverse::function(Named_object* no)\n {\n-  gcc_assert(this->function_ == NULL);\n+  go_assert(this->function_ == NULL);\n   this->function_ = no;\n   int t = no->func_value()->traverse(this);\n   this->function_ = NULL;\n@@ -1773,7 +1773,7 @@ Thunk_statement::simplify_statement(Gogo* gogo, Named_object* function,\n   Function_type* fntype = ce->get_function_type();\n   if (fntype == NULL)\n     {\n-      gcc_assert(saw_errors());\n+      go_assert(saw_errors());\n       this->set_is_error();\n       return false;\n     }\n@@ -1850,7 +1850,7 @@ Thunk_statement::simplify_statement(Gogo* gogo, Named_object* function,\n \n   // Look up the thunk.\n   Named_object* named_thunk = gogo->lookup(thunk_name, NULL);\n-  gcc_assert(named_thunk != NULL && named_thunk->is_function());\n+  go_assert(named_thunk != NULL && named_thunk->is_function());\n \n   // Build the call.\n   Expression* func = Expression::make_func_reference(named_thunk, NULL,\n@@ -1869,8 +1869,8 @@ Thunk_statement::simplify_statement(Gogo* gogo, Named_object* function,\n     gcc_unreachable();\n \n   // The current block should end with the go statement.\n-  gcc_assert(block->statements()->size() >= 1);\n-  gcc_assert(block->statements()->back() == this);\n+  go_assert(block->statements()->size() >= 1);\n+  go_assert(block->statements()->back() == this);\n   block->replace_statement(block->statements()->size() - 1, s);\n \n   // We already ran the determine_types pass, so we need to run it now\n@@ -1934,7 +1934,7 @@ Thunk_statement::build_struct(Function_type* fntype)\n \n   if (fn->bound_method_expression() != NULL)\n     {\n-      gcc_assert(fntype->is_method());\n+      go_assert(fntype->is_method());\n       Type* rtype = fntype->receiver()->type();\n       // We always pass the receiver as a pointer.\n       if (rtype->points_to() == NULL)\n@@ -2043,7 +2043,7 @@ Thunk_statement::build_thunk(Gogo* gogo, const std::string& thunk_name,\n \n   // Get a reference to the parameter.\n   Named_object* named_parameter = gogo->lookup(parameter_name, NULL);\n-  gcc_assert(named_parameter != NULL && named_parameter->is_variable());\n+  go_assert(named_parameter != NULL && named_parameter->is_variable());\n \n   // Build the call.  Note that the field names are the same as the\n   // ones used in build_struct.\n@@ -2066,7 +2066,7 @@ Thunk_statement::build_thunk(Gogo* gogo, const std::string& thunk_name,\n     }\n   else\n     {\n-      gcc_assert(bound_method == NULL && interface_method == NULL);\n+      go_assert(bound_method == NULL && interface_method == NULL);\n       func_to_call = ce->fn();\n       next_index = 0;\n     }\n@@ -2111,7 +2111,7 @@ Thunk_statement::build_thunk(Gogo* gogo, const std::string& thunk_name,\n \tcall_params->push_back(param);\n       else\n \t{\n-\t  gcc_assert(call_params->empty());\n+\t  go_assert(call_params->empty());\n \t  recover_arg = param;\n \t}\n     }\n@@ -2176,7 +2176,7 @@ Thunk_statement::get_fn_and_arg(Expression** pfn, Expression** parg)\n     *parg = Expression::make_nil(this->location());\n   else\n     {\n-      gcc_assert(args->size() == 1);\n+      go_assert(args->size() == 1);\n       *parg = args->front();\n     }\n \n@@ -2362,7 +2362,7 @@ Return_statement::do_lower(Gogo*, Named_object* function, Block* enclosing)\n \t\t     i, reason.c_str());\n \t}\n     }\n-  gcc_assert(lhs->size() == rhs->size());\n+  go_assert(lhs->size() == rhs->size());\n \n   if (lhs->empty())\n     ;\n@@ -2713,7 +2713,7 @@ If_statement::do_may_fall_through() const\n Bstatement*\n If_statement::do_get_backend(Translate_context* context)\n {\n-  gcc_assert(this->cond_->type()->is_boolean_type()\n+  go_assert(this->cond_->type()->is_boolean_type()\n \t     || this->cond_->type()->is_error());\n   tree cond_tree = this->cond_->get_tree(context);\n   Bexpression* cond_expr = tree_to_expr(cond_tree);\n@@ -2835,7 +2835,7 @@ Case_clauses::Case_clause::lower(Block* b, Temporary_statement* val_temp,\n   Unnamed_label* next_case_label;\n   if (this->cases_ == NULL || this->cases_->empty())\n     {\n-      gcc_assert(this->is_default_);\n+      go_assert(this->is_default_);\n       next_case_label = NULL;\n     }\n   else\n@@ -2955,7 +2955,7 @@ Case_clauses::Case_clause::get_backend(Translate_context* context,\n {\n   if (this->cases_ != NULL)\n     {\n-      gcc_assert(!this->is_default_);\n+      go_assert(!this->is_default_);\n       for (Expression_list::const_iterator p = this->cases_->begin();\n \t   p != this->cases_->end();\n \t   ++p)\n@@ -2970,10 +2970,10 @@ Case_clauses::Case_clause::get_backend(Translate_context* context,\n \t\t{\n \t\t  // Something went wrong.  This can happen with a\n \t\t  // negative constant and an unsigned switch value.\n-\t\t  gcc_assert(saw_errors());\n+\t\t  go_assert(saw_errors());\n \t\t  continue;\n \t\t}\n-\t      gcc_assert(itype != NULL);\n+\t      go_assert(itype != NULL);\n \t      e = Expression::make_integer(&ival, itype, e->location());\n \t      mpz_clear(ival);\n \t    }\n@@ -3434,7 +3434,7 @@ Type_case_clauses::Type_case_clause::lower(Block* b,\n       else\n \t{\n \t  // if COND { goto STMTS_LABEL }\n-\t  gcc_assert(stmts_label != NULL);\n+\t  go_assert(stmts_label != NULL);\n \t  if (*stmts_label == NULL)\n \t    *stmts_label = new Unnamed_label(UNKNOWN_LOCATION);\n \t  dest = *stmts_label;\n@@ -3451,10 +3451,10 @@ Type_case_clauses::Type_case_clause::lower(Block* b,\n \t  && stmts_label != NULL\n \t  && *stmts_label != NULL))\n     {\n-      gcc_assert(!this->is_fallthrough_);\n+      go_assert(!this->is_fallthrough_);\n       if (stmts_label != NULL && *stmts_label != NULL)\n \t{\n-\t  gcc_assert(!this->is_default_);\n+\t  go_assert(!this->is_default_);\n \t  if (this->statements_ != NULL)\n \t    (*stmts_label)->set_location(this->statements_->start_location());\n \t  Statement* s = Statement::make_unnamed_label_statement(*stmts_label);\n@@ -3467,7 +3467,7 @@ Type_case_clauses::Type_case_clause::lower(Block* b,\n     }\n \n   if (this->is_fallthrough_)\n-    gcc_assert(next_case_label == NULL);\n+    go_assert(next_case_label == NULL);\n   else\n     {\n       source_location gloc = (this->statements_ == NULL\n@@ -3548,7 +3548,7 @@ Type_case_clauses::lower(Block* b, Temporary_statement* descriptor_temp,\n \t  default_case = &*p;\n \t}\n     }\n-  gcc_assert(stmts_label == NULL);\n+  go_assert(stmts_label == NULL);\n \n   if (default_case != NULL)\n     default_case->lower(b, descriptor_temp, break_label, NULL);\n@@ -3770,7 +3770,7 @@ Send_statement::do_get_backend(Translate_context* context)\n     case Type::TYPE_NIL:\n     case Type::TYPE_NAMED:\n     case Type::TYPE_FORWARD:\n-      gcc_assert(saw_errors());\n+      go_assert(saw_errors());\n       return context->backend()->error_statement();\n     }\n \n@@ -3879,7 +3879,7 @@ Select_clauses::Select_clause::lower(Gogo* gogo, Named_object* function,\n {\n   if (this->is_default_)\n     {\n-      gcc_assert(this->channel_ == NULL && this->val_ == NULL);\n+      go_assert(this->channel_ == NULL && this->val_ == NULL);\n       this->is_lowered_ = true;\n       return;\n     }\n@@ -3918,7 +3918,7 @@ Select_clauses::Select_clause::lower(Gogo* gogo, Named_object* function,\n     }\n   else if (this->closed_ != NULL && !this->closed_->is_sink_expression())\n     {\n-      gcc_assert(this->var_ == NULL && this->closedvar_ == NULL);\n+      go_assert(this->var_ == NULL && this->closedvar_ == NULL);\n       if (this->val_ == NULL)\n \tthis->val_ = Expression::make_sink(loc);\n       Statement* s = Statement::make_tuple_receive_assignment(this->val_,\n@@ -3928,7 +3928,7 @@ Select_clauses::Select_clause::lower(Gogo* gogo, Named_object* function,\n     }\n   else if (this->closedvar_ != NULL)\n     {\n-      gcc_assert(this->val_ == NULL);\n+      go_assert(this->val_ == NULL);\n       Expression* val;\n       if (this->var_ == NULL)\n \tval = Expression::make_sink(loc);\n@@ -3940,7 +3940,7 @@ Select_clauses::Select_clause::lower(Gogo* gogo, Named_object* function,\n \t\t\t\t\t\t\t      true, loc);\n       // We have to put S in STATEMENTS_, because that is where the\n       // variables are declared.\n-      gcc_assert(this->statements_ != NULL);\n+      go_assert(this->statements_ != NULL);\n       this->statements_->add_statement_at_front(s);\n       // We have to lower STATEMENTS_ again, to lower the tuple\n       // receive assignment we just added.\n@@ -3952,7 +3952,7 @@ Select_clauses::Select_clause::lower(Gogo* gogo, Named_object* function,\n       recv->set_for_select();\n       if (this->val_ != NULL)\n \t{\n-\t  gcc_assert(this->var_ == NULL);\n+\t  go_assert(this->var_ == NULL);\n \t  init->add_statement(Statement::make_assignment(this->val_, recv,\n \t\t\t\t\t\t\t loc));\n \t}\n@@ -3988,7 +3988,7 @@ Select_clauses::Select_clause::lower(Gogo* gogo, Named_object* function,\n void\n Select_clauses::Select_clause::determine_types()\n {\n-  gcc_assert(this->is_lowered_);\n+  go_assert(this->is_lowered_);\n   if (this->statements_ != NULL)\n     this->statements_->determine_types();\n }\n@@ -4118,7 +4118,7 @@ Select_clauses::get_backend(Translate_context* context,\n \t{\n \t  // We should have given an error in the send or receive\n \t  // statement we created via lowering.\n-\t  gcc_assert(saw_errors());\n+\t  go_assert(saw_errors());\n \t  return context->backend()->error_statement();\n \t}\n \n@@ -4132,7 +4132,7 @@ Select_clauses::get_backend(Translate_context* context,\n \n   if (chan_init->empty())\n     {\n-      gcc_assert(count == 0);\n+      go_assert(count == 0);\n       Bstatement* s;\n       Bstatement* ldef = break_label->get_definition(context);\n       if (default_clause != NULL)\n@@ -4162,7 +4162,7 @@ Select_clauses::get_backend(Translate_context* context,\n \treturn ldef;\n       return context->backend()->compound_statement(s, ldef);\n     }\n-  gcc_assert(count > 0);\n+  go_assert(count > 0);\n \n   std::vector<Bstatement*> statements;\n \n@@ -4458,7 +4458,7 @@ void\n For_statement::set_break_continue_labels(Unnamed_label* break_label,\n \t\t\t\t\t Unnamed_label* continue_label)\n {\n-  gcc_assert(this->break_label_ == NULL && this->continue_label_ == NULL);\n+  go_assert(this->break_label_ == NULL && this->continue_label_ == NULL);\n   this->break_label_ = break_label;\n   this->continue_label_ = continue_label;\n }\n@@ -4659,7 +4659,7 @@ For_range_statement::call_builtin(Gogo* gogo, const char* funcname,\n \t\t\t\t  source_location loc)\n {\n   Named_object* no = gogo->lookup_global(funcname);\n-  gcc_assert(no != NULL && no->is_function_declaration());\n+  go_assert(no != NULL && no->is_function_declaration());\n   Expression* func = Expression::make_func_reference(no, NULL, loc);\n   Expression_list* params = new Expression_list();\n   params->push_back(arg);\n@@ -4990,7 +4990,7 @@ For_range_statement::lower_range_channel(Gogo*,\n \t\t\t\t\t Block** piter_init,\n \t\t\t\t\t Block** ppost)\n {\n-  gcc_assert(value_temp == NULL);\n+  go_assert(value_temp == NULL);\n \n   source_location loc = this->location();\n "}, {"sha": "7f6401b0313d5af217799baa72f543862b8a09e8", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=26409c5246d31c7709ea85e8fea698d38bfb161d", "patch": "@@ -690,7 +690,7 @@ class Select_clauses\n       : channel_(channel), val_(val), closed_(closed), var_(var),\n \tclosedvar_(closedvar), statements_(statements), location_(location),\n \tis_send_(is_send), is_default_(is_default), is_lowered_(false)\n-    { gcc_assert(is_default ? channel == NULL : channel != NULL); }\n+    { go_assert(is_default ? channel == NULL : channel != NULL); }\n \n     // Traverse the select clause.\n     int\n@@ -719,7 +719,7 @@ class Select_clauses\n     bool\n     is_send() const\n     {\n-      gcc_assert(!this->is_default_);\n+      go_assert(!this->is_default_);\n       return this->is_send_;\n     }\n \n@@ -792,7 +792,7 @@ class Select_statement : public Statement\n   void\n   add_clauses(Select_clauses* clauses)\n   {\n-    gcc_assert(this->clauses_ == NULL);\n+    go_assert(this->clauses_ == NULL);\n     this->clauses_ = clauses;\n   }\n \n@@ -967,7 +967,7 @@ class For_statement : public Statement\n   void\n   add_statements(Block* statements)\n   {\n-    gcc_assert(this->statements_ == NULL);\n+    go_assert(this->statements_ == NULL);\n     this->statements_ = statements;\n   }\n \n@@ -1030,7 +1030,7 @@ class For_range_statement : public Statement\n   void\n   add_statements(Block* statements)\n   {\n-    gcc_assert(this->statements_ == NULL);\n+    go_assert(this->statements_ == NULL);\n     this->statements_ = statements;\n   }\n \n@@ -1267,7 +1267,7 @@ class Switch_statement : public Statement\n   void\n   add_clauses(Case_clauses* clauses)\n   {\n-    gcc_assert(this->clauses_ == NULL);\n+    go_assert(this->clauses_ == NULL);\n     this->clauses_ = clauses;\n   }\n \n@@ -1407,13 +1407,13 @@ class Type_switch_statement : public Statement\n \t\t\tsource_location location)\n     : Statement(STATEMENT_TYPE_SWITCH, location),\n       var_(var), expr_(expr), clauses_(NULL), break_label_(NULL)\n-  { gcc_assert(var == NULL || expr == NULL); }\n+  { go_assert(var == NULL || expr == NULL); }\n \n   // Add the clauses.\n   void\n   add_clauses(Type_case_clauses* clauses)\n   {\n-    gcc_assert(this->clauses_ == NULL);\n+    go_assert(this->clauses_ == NULL);\n     this->clauses_ = clauses;\n   }\n "}, {"sha": "0107c15bf8d46393fbaae29ac8547bd4ac3bce37", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 160, "deletions": 160, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=26409c5246d31c7709ea85e8fea698d38bfb161d", "patch": "@@ -188,7 +188,7 @@ Type::is_abstract() const\n Type*\n Type::make_non_abstract_type()\n {\n-  gcc_assert(this->is_abstract());\n+  go_assert(this->is_abstract());\n   switch (this->classification())\n     {\n     case TYPE_INTEGER:\n@@ -270,7 +270,7 @@ Type::is_nil_constant_as_type() const\n int\n Type::traverse(Type* type, Traverse* traverse)\n {\n-  gcc_assert((traverse->traverse_mask() & Traverse::traverse_types) != 0\n+  go_assert((traverse->traverse_mask() & Traverse::traverse_types) != 0\n \t     || (traverse->traverse_mask()\n \t\t & Traverse::traverse_expressions) != 0);\n   if (traverse->remember_type(type))\n@@ -942,7 +942,7 @@ Type::type_descriptor_pointer(Gogo* gogo)\n     {\n       Expression* e = t->do_type_descriptor(gogo, NULL);\n       gogo->build_type_descriptor_decl(t, e, &t->type_descriptor_decl_);\n-      gcc_assert(t->type_descriptor_decl_ != NULL_TREE\n+      go_assert(t->type_descriptor_decl_ != NULL_TREE\n \t\t && (t->type_descriptor_decl_ == error_mark_node\n \t\t     || DECL_P(t->type_descriptor_decl_)));\n     }\n@@ -964,7 +964,7 @@ Type::type_descriptor(Gogo* gogo, Type* type)\n Expression*\n Type::named_type_descriptor(Gogo* gogo, Type* type, Named_type* name)\n {\n-  gcc_assert(name != NULL && type->named_type() != name);\n+  go_assert(name != NULL && type->named_type() != name);\n   return type->do_type_descriptor(gogo, name);\n }\n \n@@ -1018,7 +1018,7 @@ Type::convert_builtin_named_types(Gogo* gogo)\n        ++p)\n     {\n       bool r = (*p)->verify();\n-      gcc_assert(r);\n+      go_assert(r);\n       (*p)->convert(gogo);\n     }\n }\n@@ -1218,28 +1218,28 @@ Type::type_descriptor_constructor(Gogo* gogo, int runtime_type_kind,\n   vals->reserve(9);\n \n   Struct_field_list::const_iterator p = fields->begin();\n-  gcc_assert(p->field_name() == \"Kind\");\n+  go_assert(p->field_name() == \"Kind\");\n   mpz_t iv;\n   mpz_init_set_ui(iv, runtime_type_kind);\n   vals->push_back(Expression::make_integer(&iv, p->type(), bloc));\n \n   ++p;\n-  gcc_assert(p->field_name() == \"align\");\n+  go_assert(p->field_name() == \"align\");\n   Expression::Type_info type_info = Expression::TYPE_INFO_ALIGNMENT;\n   vals->push_back(Expression::make_type_info(this, type_info));\n \n   ++p;\n-  gcc_assert(p->field_name() == \"fieldAlign\");\n+  go_assert(p->field_name() == \"fieldAlign\");\n   type_info = Expression::TYPE_INFO_FIELD_ALIGNMENT;\n   vals->push_back(Expression::make_type_info(this, type_info));\n \n   ++p;\n-  gcc_assert(p->field_name() == \"size\");\n+  go_assert(p->field_name() == \"size\");\n   type_info = Expression::TYPE_INFO_SIZE;\n   vals->push_back(Expression::make_type_info(this, type_info));\n \n   ++p;\n-  gcc_assert(p->field_name() == \"hash\");\n+  go_assert(p->field_name() == \"hash\");\n   mpz_set_ui(iv, this->hash_for_method(gogo));\n   vals->push_back(Expression::make_integer(&iv, p->type(), bloc));\n \n@@ -1248,7 +1248,7 @@ Type::type_descriptor_constructor(Gogo* gogo, int runtime_type_kind,\n   this->type_functions(&hash_fn, &equal_fn);\n \n   ++p;\n-  gcc_assert(p->field_name() == \"hashfn\");\n+  go_assert(p->field_name() == \"hashfn\");\n   Function_type* fntype = p->type()->function_type();\n   Named_object* no = Named_object::make_function_declaration(hash_fn, NULL,\n \t\t\t\t\t\t\t     fntype,\n@@ -1257,22 +1257,22 @@ Type::type_descriptor_constructor(Gogo* gogo, int runtime_type_kind,\n   vals->push_back(Expression::make_func_reference(no, NULL, bloc));\n \n   ++p;\n-  gcc_assert(p->field_name() == \"equalfn\");\n+  go_assert(p->field_name() == \"equalfn\");\n   fntype = p->type()->function_type();\n   no = Named_object::make_function_declaration(equal_fn, NULL, fntype, bloc);\n   no->func_declaration_value()->set_asm_name(equal_fn);\n   vals->push_back(Expression::make_func_reference(no, NULL, bloc));\n \n   ++p;\n-  gcc_assert(p->field_name() == \"string\");\n+  go_assert(p->field_name() == \"string\");\n   Expression* s = Expression::make_string((name != NULL\n \t\t\t\t\t   ? name->reflection(gogo)\n \t\t\t\t\t   : this->reflection(gogo)),\n \t\t\t\t\t  bloc);\n   vals->push_back(Expression::make_unary(OPERATOR_AND, s, bloc));\n \n   ++p;\n-  gcc_assert(p->field_name() == \"uncommonType\");\n+  go_assert(p->field_name() == \"uncommonType\");\n   if (name == NULL && methods == NULL)\n     vals->push_back(Expression::make_nil(bloc));\n   else\n@@ -1286,7 +1286,7 @@ Type::type_descriptor_constructor(Gogo* gogo, int runtime_type_kind,\n     }\n \n   ++p;\n-  gcc_assert(p->field_name() == \"ptrToThis\");\n+  go_assert(p->field_name() == \"ptrToThis\");\n   if (name == NULL)\n     vals->push_back(Expression::make_nil(bloc));\n   else\n@@ -1296,7 +1296,7 @@ Type::type_descriptor_constructor(Gogo* gogo, int runtime_type_kind,\n     }\n \n   ++p;\n-  gcc_assert(p == fields->end());\n+  go_assert(p == fields->end());\n \n   mpz_clear(iv);\n \n@@ -1323,10 +1323,10 @@ Type::uncommon_type_constructor(Gogo* gogo, Type* uncommon_type,\n   vals->reserve(3);\n \n   Struct_field_list::const_iterator p = fields->begin();\n-  gcc_assert(p->field_name() == \"name\");\n+  go_assert(p->field_name() == \"name\");\n \n   ++p;\n-  gcc_assert(p->field_name() == \"pkgPath\");\n+  go_assert(p->field_name() == \"pkgPath\");\n \n   if (name == NULL)\n     {\n@@ -1365,12 +1365,12 @@ Type::uncommon_type_constructor(Gogo* gogo, Type* uncommon_type,\n     }\n \n   ++p;\n-  gcc_assert(p->field_name() == \"methods\");\n+  go_assert(p->field_name() == \"methods\");\n   vals->push_back(this->methods_constructor(gogo, p->type(), methods,\n \t\t\t\t\t    only_value_methods));\n \n   ++p;\n-  gcc_assert(p == fields->end());\n+  go_assert(p == fields->end());\n \n   Expression* r = Expression::make_struct_composite_literal(uncommon_type,\n \t\t\t\t\t\t\t    vals, bloc);\n@@ -1452,13 +1452,13 @@ Type::method_constructor(Gogo*, Type* method_type,\n   vals->reserve(5);\n \n   Struct_field_list::const_iterator p = fields->begin();\n-  gcc_assert(p->field_name() == \"name\");\n+  go_assert(p->field_name() == \"name\");\n   const std::string n = Gogo::unpack_hidden_name(method_name);\n   Expression* s = Expression::make_string(n, bloc);\n   vals->push_back(Expression::make_unary(OPERATOR_AND, s, bloc));\n \n   ++p;\n-  gcc_assert(p->field_name() == \"pkgPath\");\n+  go_assert(p->field_name() == \"pkgPath\");\n   if (!Gogo::is_hidden_name(method_name))\n     vals->push_back(Expression::make_nil(bloc));\n   else\n@@ -1476,23 +1476,23 @@ Type::method_constructor(Gogo*, Type* method_type,\n     mtype = no->func_value()->type();\n   else\n     mtype = no->func_declaration_value()->type();\n-  gcc_assert(mtype->is_method());\n+  go_assert(mtype->is_method());\n   Type* nonmethod_type = mtype->copy_without_receiver();\n \n   ++p;\n-  gcc_assert(p->field_name() == \"mtyp\");\n+  go_assert(p->field_name() == \"mtyp\");\n   vals->push_back(Expression::make_type_descriptor(nonmethod_type, bloc));\n \n   ++p;\n-  gcc_assert(p->field_name() == \"typ\");\n+  go_assert(p->field_name() == \"typ\");\n   vals->push_back(Expression::make_type_descriptor(mtype, bloc));\n \n   ++p;\n-  gcc_assert(p->field_name() == \"tfn\");\n+  go_assert(p->field_name() == \"tfn\");\n   vals->push_back(Expression::make_func_reference(no, NULL, bloc));\n \n   ++p;\n-  gcc_assert(p == fields->end());\n+  go_assert(p == fields->end());\n \n   return Expression::make_struct_composite_literal(method_type, vals, bloc);\n }\n@@ -1597,7 +1597,7 @@ class Error_type : public Type\n \n   void\n   do_reflection(Gogo*, std::string*) const\n-  { gcc_assert(saw_errors()); }\n+  { go_assert(saw_errors()); }\n \n   void\n   do_mangled_name(Gogo*, std::string* ret) const\n@@ -1690,7 +1690,7 @@ Boolean_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n   else\n     {\n       Named_object* no = gogo->lookup_global(\"bool\");\n-      gcc_assert(no != NULL);\n+      go_assert(no != NULL);\n       return Type::type_descriptor(gogo, no->type_value());\n     }\n }\n@@ -1748,7 +1748,7 @@ Integer_type::create_integer_type(const char* name, bool is_unsigned,\n   Named_type* named_type = named_object->type_value();\n   std::pair<Named_integer_types::iterator, bool> ins =\n     Integer_type::named_integer_types.insert(std::make_pair(sname, named_type));\n-  gcc_assert(ins.second);\n+  go_assert(ins.second);\n   return named_type;\n }\n \n@@ -1759,7 +1759,7 @@ Integer_type::lookup_integer_type(const char* name)\n {\n   Named_integer_types::const_iterator p =\n     Integer_type::named_integer_types.find(name);\n-  gcc_assert(p != Integer_type::named_integer_types.end());\n+  go_assert(p != Integer_type::named_integer_types.end());\n   return p->second;\n }\n \n@@ -1802,7 +1802,7 @@ Integer_type::do_get_tree(Gogo*)\n {\n   if (this->is_abstract_)\n     {\n-      gcc_assert(saw_errors());\n+      go_assert(saw_errors());\n       return error_mark_node;\n     }\n \n@@ -1850,7 +1850,7 @@ Integer_type::do_get_init_tree(Gogo*, tree type_tree, bool is_clear)\n Expression*\n Integer_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n {\n-  gcc_assert(name != NULL);\n+  go_assert(name != NULL);\n   return this->plain_type_descriptor(gogo, this->runtime_type_kind_, name);\n }\n \n@@ -1859,7 +1859,7 @@ Integer_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n void\n Integer_type::do_reflection(Gogo*, std::string*) const\n {\n-  gcc_assert(saw_errors());\n+  go_assert(saw_errors());\n }\n \n // Mangled name.\n@@ -1919,7 +1919,7 @@ Float_type::create_float_type(const char* name, int bits,\n   Named_type* named_type = named_object->type_value();\n   std::pair<Named_float_types::iterator, bool> ins =\n     Float_type::named_float_types.insert(std::make_pair(sname, named_type));\n-  gcc_assert(ins.second);\n+  go_assert(ins.second);\n   return named_type;\n }\n \n@@ -1930,7 +1930,7 @@ Float_type::lookup_float_type(const char* name)\n {\n   Named_float_types::const_iterator p =\n     Float_type::named_float_types.find(name);\n-  gcc_assert(p != Float_type::named_float_types.end());\n+  go_assert(p != Float_type::named_float_types.end());\n   return p->second;\n }\n \n@@ -2006,7 +2006,7 @@ Float_type::do_get_init_tree(Gogo*, tree type_tree, bool is_clear)\n Expression*\n Float_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n {\n-  gcc_assert(name != NULL);\n+  go_assert(name != NULL);\n   return this->plain_type_descriptor(gogo, this->runtime_type_kind_, name);\n }\n \n@@ -2015,7 +2015,7 @@ Float_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n void\n Float_type::do_reflection(Gogo*, std::string*) const\n {\n-  gcc_assert(saw_errors());\n+  go_assert(saw_errors());\n }\n \n // Mangled name.\n@@ -2075,7 +2075,7 @@ Complex_type::create_complex_type(const char* name, int bits,\n   std::pair<Named_complex_types::iterator, bool> ins =\n     Complex_type::named_complex_types.insert(std::make_pair(sname,\n \t\t\t\t\t\t\t    named_type));\n-  gcc_assert(ins.second);\n+  go_assert(ins.second);\n   return named_type;\n }\n \n@@ -2086,7 +2086,7 @@ Complex_type::lookup_complex_type(const char* name)\n {\n   Named_complex_types::const_iterator p =\n     Complex_type::named_complex_types.find(name);\n-  gcc_assert(p != Complex_type::named_complex_types.end());\n+  go_assert(p != Complex_type::named_complex_types.end());\n   return p->second;\n }\n \n@@ -2166,7 +2166,7 @@ Complex_type::do_get_init_tree(Gogo*, tree type_tree, bool is_clear)\n Expression*\n Complex_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n {\n-  gcc_assert(name != NULL);\n+  go_assert(name != NULL);\n   return this->plain_type_descriptor(gogo, this->runtime_type_kind_, name);\n }\n \n@@ -2175,7 +2175,7 @@ Complex_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n void\n Complex_type::do_reflection(Gogo*, std::string*) const\n {\n-  gcc_assert(saw_errors());\n+  go_assert(saw_errors());\n }\n \n // Mangled name.\n@@ -2236,9 +2236,9 @@ tree\n String_type::length_tree(Gogo*, tree string)\n {\n   tree string_type = TREE_TYPE(string);\n-  gcc_assert(TREE_CODE(string_type) == RECORD_TYPE);\n+  go_assert(TREE_CODE(string_type) == RECORD_TYPE);\n   tree length_field = DECL_CHAIN(TYPE_FIELDS(string_type));\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(length_field)),\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(length_field)),\n \t\t    \"__length\") == 0);\n   return fold_build3(COMPONENT_REF, integer_type_node, string,\n \t\t     length_field, NULL_TREE);\n@@ -2250,9 +2250,9 @@ tree\n String_type::bytes_tree(Gogo*, tree string)\n {\n   tree string_type = TREE_TYPE(string);\n-  gcc_assert(TREE_CODE(string_type) == RECORD_TYPE);\n+  go_assert(TREE_CODE(string_type) == RECORD_TYPE);\n   tree bytes_field = TYPE_FIELDS(string_type);\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(bytes_field)),\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(bytes_field)),\n \t\t    \"__data\") == 0);\n   return fold_build3(COMPONENT_REF, TREE_TYPE(bytes_field), string,\n \t\t     bytes_field, NULL_TREE);\n@@ -2266,7 +2266,7 @@ String_type::do_get_init_tree(Gogo*, tree type_tree, bool is_clear)\n   if (is_clear)\n     return NULL_TREE;\n \n-  gcc_assert(TREE_CODE(type_tree) == RECORD_TYPE);\n+  go_assert(TREE_CODE(type_tree) == RECORD_TYPE);\n \n   VEC(constructor_elt, gc)* init = VEC_alloc(constructor_elt, gc, 2);\n \n@@ -2294,7 +2294,7 @@ String_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n   else\n     {\n       Named_object* no = gogo->lookup_global(\"string\");\n-      gcc_assert(no != NULL);\n+      go_assert(no != NULL);\n       return Type::type_descriptor(gogo, no->type_value());\n     }\n }\n@@ -2780,27 +2780,27 @@ Function_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n   vals->reserve(4);\n \n   Struct_field_list::const_iterator p = fields->begin();\n-  gcc_assert(p->field_name() == \"commonType\");\n+  go_assert(p->field_name() == \"commonType\");\n   vals->push_back(this->type_descriptor_constructor(gogo,\n \t\t\t\t\t\t    RUNTIME_TYPE_KIND_FUNC,\n \t\t\t\t\t\t    name, NULL, true));\n \n   ++p;\n-  gcc_assert(p->field_name() == \"dotdotdot\");\n+  go_assert(p->field_name() == \"dotdotdot\");\n   vals->push_back(Expression::make_boolean(this->is_varargs(), bloc));\n \n   ++p;\n-  gcc_assert(p->field_name() == \"in\");\n+  go_assert(p->field_name() == \"in\");\n   vals->push_back(this->type_descriptor_params(p->type(), this->receiver(),\n \t\t\t\t\t       this->parameters()));\n \n   ++p;\n-  gcc_assert(p->field_name() == \"out\");\n+  go_assert(p->field_name() == \"out\");\n   vals->push_back(this->type_descriptor_params(p->type(), NULL,\n \t\t\t\t\t       this->results()));\n \n   ++p;\n-  gcc_assert(p == fields->end());\n+  go_assert(p == fields->end());\n \n   return Expression::make_struct_composite_literal(ftdt, vals, bloc);\n }\n@@ -2850,7 +2850,7 @@ Function_type::do_reflection(Gogo* gogo, std::string* ret) const\n {\n   // FIXME: Turn this off until we straighten out the type of the\n   // struct field used in a go statement which calls a method.\n-  // gcc_assert(this->receiver_ == NULL);\n+  // go_assert(this->receiver_ == NULL);\n \n   ret->append(\"func\");\n \n@@ -3032,7 +3032,7 @@ Function_type::do_import(Import* imp)\n \t\t\t\t\t\t ptype, imp->location()));\n \t  if (imp->peek_char() != ',')\n \t    break;\n-\t  gcc_assert(!is_varargs);\n+\t  go_assert(!is_varargs);\n \t  imp->require_c_string(\", \");\n \t}\n     }\n@@ -3079,7 +3079,7 @@ Function_type::do_import(Import* imp)\n Function_type*\n Function_type::copy_without_receiver() const\n {\n-  gcc_assert(this->is_method());\n+  go_assert(this->is_method());\n   Function_type *ret = Type::make_function_type(NULL, this->parameters_,\n \t\t\t\t\t\tthis->results_,\n \t\t\t\t\t\tthis->location_);\n@@ -3095,7 +3095,7 @@ Function_type::copy_without_receiver() const\n Function_type*\n Function_type::copy_with_receiver(Type* receiver_type) const\n {\n-  gcc_assert(!this->is_method());\n+  go_assert(!this->is_method());\n   Typed_identifier* receiver = new Typed_identifier(\"\", receiver_type,\n \t\t\t\t\t\t    this->location_);\n   return Type::make_function_type(receiver, this->parameters_,\n@@ -3177,7 +3177,7 @@ Pointer_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n {\n   if (this->is_unsafe_pointer_type())\n     {\n-      gcc_assert(name != NULL);\n+      go_assert(name != NULL);\n       return this->plain_type_descriptor(gogo,\n \t\t\t\t\t RUNTIME_TYPE_KIND_UNSAFE_POINTER,\n \t\t\t\t\t name);\n@@ -3203,13 +3203,13 @@ Pointer_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n       vals->reserve(2);\n \n       Struct_field_list::const_iterator p = fields->begin();\n-      gcc_assert(p->field_name() == \"commonType\");\n+      go_assert(p->field_name() == \"commonType\");\n       vals->push_back(this->type_descriptor_constructor(gogo,\n \t\t\t\t\t\t\tRUNTIME_TYPE_KIND_PTR,\n \t\t\t\t\t\t\tname, methods, false));\n \n       ++p;\n-      gcc_assert(p->field_name() == \"elem\");\n+      go_assert(p->field_name() == \"elem\");\n       vals->push_back(Expression::make_type_descriptor(deref, bloc));\n \n       return Expression::make_struct_composite_literal(ptr_tdt, vals, bloc);\n@@ -3335,7 +3335,7 @@ class Call_multiple_result_type : public Type\n   bool\n   do_has_pointer() const\n   {\n-    gcc_assert(saw_errors());\n+    go_assert(saw_errors());\n     return false;\n   }\n \n@@ -3345,24 +3345,24 @@ class Call_multiple_result_type : public Type\n   tree\n   do_get_init_tree(Gogo*, tree, bool)\n   {\n-    gcc_assert(saw_errors());\n+    go_assert(saw_errors());\n     return error_mark_node;\n   }\n \n   Expression*\n   do_type_descriptor(Gogo*, Named_type*)\n   {\n-    gcc_assert(saw_errors());\n+    go_assert(saw_errors());\n     return Expression::make_error(UNKNOWN_LOCATION);\n   }\n \n   void\n   do_reflection(Gogo*, std::string*) const\n-  { gcc_assert(saw_errors()); }\n+  { go_assert(saw_errors()); }\n \n   void\n   do_mangled_name(Gogo*, std::string*) const\n-  { gcc_assert(saw_errors()); }\n+  { go_assert(saw_errors()); }\n \n  private:\n   // The expression being called.\n@@ -3375,9 +3375,9 @@ tree\n Call_multiple_result_type::do_get_tree(Gogo* gogo)\n {\n   Function_type* fntype = this->call_->get_function_type();\n-  gcc_assert(fntype != NULL);\n+  go_assert(fntype != NULL);\n   const Typed_identifier_list* results = fntype->results();\n-  gcc_assert(results != NULL && results->size() > 1);\n+  go_assert(results != NULL && results->size() > 1);\n   tree fntype_tree = fntype->get_tree(gogo);\n   if (fntype_tree == error_mark_node)\n     return error_mark_node;\n@@ -3428,7 +3428,7 @@ Struct_field::field_name() const\n \t{\n \t  // Avoid crashing in the erroneous case where T is named but\n \t  // DT is not.\n-\t  gcc_assert(t != dt);\n+\t  go_assert(t != dt);\n \t  if (t->forward_declaration_type() != NULL)\n \t    return t->forward_declaration_type()->name();\n \t  else if (t->named_type() != NULL)\n@@ -3748,7 +3748,7 @@ Struct_type::field_reference_depth(Expression* struct_expr,\n \t  while (sub->expr() != NULL)\n \t    {\n \t      sub = sub->expr()->deref()->field_reference_expression();\n-\t      gcc_assert(sub != NULL);\n+\t      go_assert(sub != NULL);\n \t    }\n \t  sub->set_struct_expression(here);\n \t}\n@@ -3859,7 +3859,7 @@ Struct_type::fill_in_tree(Gogo* gogo, tree type)\n       tree field_type_tree = p->type()->get_tree(gogo);\n       if (field_type_tree == error_mark_node)\n \treturn error_mark_node;\n-      gcc_assert(TYPE_SIZE(field_type_tree) != NULL_TREE);\n+      go_assert(TYPE_SIZE(field_type_tree) != NULL_TREE);\n \n       tree field = build_decl(p->location(), FIELD_DECL, name_tree,\n \t\t\t      field_type_tree);\n@@ -3906,7 +3906,7 @@ Struct_type::do_get_init_tree(Gogo* gogo, tree type_tree, bool is_clear)\n       tree value = p->type()->get_init_tree(gogo, is_clear);\n       if (value == error_mark_node)\n \treturn error_mark_node;\n-      gcc_assert(field != NULL_TREE);\n+      go_assert(field != NULL_TREE);\n       if (value != NULL)\n \t{\n \t  constructor_elt* elt = VEC_quick_push(constructor_elt, init, NULL);\n@@ -3917,11 +3917,11 @@ Struct_type::do_get_init_tree(Gogo* gogo, tree type_tree, bool is_clear)\n \t    is_constant = false;\n \t}\n     }\n-  gcc_assert(field == NULL_TREE);\n+  go_assert(field == NULL_TREE);\n \n   if (!any_fields_set)\n     {\n-      gcc_assert(is_clear);\n+      go_assert(is_clear);\n       VEC_free(constructor_elt, gc, init);\n       return NULL;\n     }\n@@ -3985,16 +3985,16 @@ Struct_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n   const Methods* methods = this->methods();\n   // A named struct should not have methods--the methods should attach\n   // to the named type.\n-  gcc_assert(methods == NULL || name == NULL);\n+  go_assert(methods == NULL || name == NULL);\n \n   Struct_field_list::const_iterator ps = fields->begin();\n-  gcc_assert(ps->field_name() == \"commonType\");\n+  go_assert(ps->field_name() == \"commonType\");\n   vals->push_back(this->type_descriptor_constructor(gogo,\n \t\t\t\t\t\t    RUNTIME_TYPE_KIND_STRUCT,\n \t\t\t\t\t\t    name, methods, true));\n \n   ++ps;\n-  gcc_assert(ps->field_name() == \"fields\");\n+  go_assert(ps->field_name() == \"fields\");\n \n   Expression_list* elements = new Expression_list();\n   elements->reserve(this->fields_->size());\n@@ -4009,7 +4009,7 @@ Struct_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n       fvals->reserve(5);\n \n       Struct_field_list::const_iterator q = f->begin();\n-      gcc_assert(q->field_name() == \"name\");\n+      go_assert(q->field_name() == \"name\");\n       if (pf->is_anonymous())\n \tfvals->push_back(Expression::make_nil(bloc));\n       else\n@@ -4020,7 +4020,7 @@ Struct_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n \t}\n \n       ++q;\n-      gcc_assert(q->field_name() == \"pkgPath\");\n+      go_assert(q->field_name() == \"pkgPath\");\n       if (!Gogo::is_hidden_name(pf->field_name()))\n \tfvals->push_back(Expression::make_nil(bloc));\n       else\n@@ -4031,11 +4031,11 @@ Struct_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n \t}\n \n       ++q;\n-      gcc_assert(q->field_name() == \"typ\");\n+      go_assert(q->field_name() == \"typ\");\n       fvals->push_back(Expression::make_type_descriptor(pf->type(), bloc));\n \n       ++q;\n-      gcc_assert(q->field_name() == \"tag\");\n+      go_assert(q->field_name() == \"tag\");\n       if (!pf->has_tag())\n \tfvals->push_back(Expression::make_nil(bloc));\n       else\n@@ -4045,7 +4045,7 @@ Struct_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n \t}\n \n       ++q;\n-      gcc_assert(q->field_name() == \"offset\");\n+      go_assert(q->field_name() == \"offset\");\n       fvals->push_back(Expression::make_struct_field_offset(this, &*pf));\n \n       Expression* v = Expression::make_struct_composite_literal(element_type,\n@@ -4170,7 +4170,7 @@ Struct_type::do_export(Export* exp) const\n {\n   exp->write_c_string(\"struct { \");\n   const Struct_field_list* fields = this->fields_;\n-  gcc_assert(fields != NULL);\n+  go_assert(fields != NULL);\n   for (Struct_field_list::const_iterator p = fields->begin();\n        p != fields->end();\n        ++p)\n@@ -4226,7 +4226,7 @@ Struct_type::do_import(Import* imp)\n \t      imp->advance(1);\n \t      Expression* expr = Expression::import_expression(imp);\n \t      String_expression* sexpr = expr->string_expression();\n-\t      gcc_assert(sexpr != NULL);\n+\t      go_assert(sexpr != NULL);\n \t      sf.set_tag(sexpr->val());\n \t      delete sexpr;\n \t    }\n@@ -4413,7 +4413,7 @@ bool\n Array_type::do_check_make_expression(Expression_list* args,\n \t\t\t\t     source_location location)\n {\n-  gcc_assert(this->length_ == NULL);\n+  go_assert(this->length_ == NULL);\n   if (args == NULL || args->empty())\n     {\n       error_at(location, \"length required when allocating a slice\");\n@@ -4448,7 +4448,7 @@ Array_type::do_check_make_expression(Expression_list* args,\n tree\n Array_type::get_length_tree(Gogo* gogo)\n {\n-  gcc_assert(this->length_ != NULL);\n+  go_assert(this->length_ != NULL);\n   if (this->length_tree_ == NULL_TREE)\n     {\n       mpz_t val;\n@@ -4509,15 +4509,15 @@ Array_type::do_get_tree(Gogo* gogo)\n tree\n Array_type::fill_in_array_tree(Gogo* gogo, tree array_type)\n {\n-  gcc_assert(this->length_ != NULL);\n+  go_assert(this->length_ != NULL);\n \n   tree element_type_tree = this->element_type_->get_tree(gogo);\n   tree length_tree = this->get_length_tree(gogo);\n   if (element_type_tree == error_mark_node\n       || length_tree == error_mark_node)\n     return error_mark_node;\n \n-  gcc_assert(TYPE_SIZE(element_type_tree) != NULL_TREE);\n+  go_assert(TYPE_SIZE(element_type_tree) != NULL_TREE);\n \n   length_tree = fold_convert(sizetype, length_tree);\n \n@@ -4550,14 +4550,14 @@ Array_type::fill_in_array_tree(Gogo* gogo, tree array_type)\n tree\n Array_type::fill_in_slice_tree(Gogo* gogo, tree struct_type)\n {\n-  gcc_assert(this->length_ == NULL);\n+  go_assert(this->length_ == NULL);\n \n   tree element_type_tree = this->element_type_->get_tree(gogo);\n   if (element_type_tree == error_mark_node)\n     return error_mark_node;\n   tree field = TYPE_FIELDS(struct_type);\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__values\") == 0);\n-  gcc_assert(POINTER_TYPE_P(TREE_TYPE(field))\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__values\") == 0);\n+  go_assert(POINTER_TYPE_P(TREE_TYPE(field))\n \t     && TREE_TYPE(TREE_TYPE(field)) == void_type_node);\n   TREE_TYPE(field) = build_pointer_type(element_type_tree);\n \n@@ -4576,7 +4576,7 @@ Array_type::do_get_init_tree(Gogo* gogo, tree type_tree, bool is_clear)\n       if (is_clear)\n \treturn NULL;\n \n-      gcc_assert(TREE_CODE(type_tree) == RECORD_TYPE);\n+      go_assert(TREE_CODE(type_tree) == RECORD_TYPE);\n \n       VEC(constructor_elt,gc)* init = VEC_alloc(constructor_elt, gc, 3);\n \n@@ -4626,19 +4626,19 @@ Array_type::do_make_expression_tree(Translate_context* context,\n \t\t\t\t    Expression_list* args,\n \t\t\t\t    source_location location)\n {\n-  gcc_assert(this->length_ == NULL);\n+  go_assert(this->length_ == NULL);\n \n   Gogo* gogo = context->gogo();\n   tree type_tree = this->get_tree(gogo);\n   if (type_tree == error_mark_node)\n     return error_mark_node;\n \n   tree values_field = TYPE_FIELDS(type_tree);\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(values_field)),\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(values_field)),\n \t\t    \"__values\") == 0);\n \n   tree count_field = DECL_CHAIN(values_field);\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(count_field)),\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(count_field)),\n \t\t    \"__count\") == 0);\n \n   tree element_type_tree = this->element_type_->get_tree(gogo);\n@@ -4652,7 +4652,7 @@ Array_type::do_make_expression_tree(Translate_context* context,\n \n   // The first argument is the number of elements, the optional second\n   // argument is the capacity.\n-  gcc_assert(args != NULL && args->size() >= 1 && args->size() <= 2);\n+  go_assert(args != NULL && args->size() >= 1 && args->size() <= 2);\n \n   tree length_tree = args->front()->get_tree(context);\n   if (length_tree == error_mark_node)\n@@ -4795,7 +4795,7 @@ Array_type::value_pointer_tree(Gogo*, tree array) const\n     {\n       // Open array.\n       tree field = TYPE_FIELDS(TREE_TYPE(array));\n-      gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)),\n+      go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)),\n \t\t\t\"__values\") == 0);\n       ret = fold_build3(COMPONENT_REF, TREE_TYPE(field), array, field,\n \t\t\tNULL_TREE);\n@@ -4823,10 +4823,10 @@ Array_type::length_tree(Gogo* gogo, tree array)\n   // This is an open array.  We need to read the length field.\n \n   tree type = TREE_TYPE(array);\n-  gcc_assert(TREE_CODE(type) == RECORD_TYPE);\n+  go_assert(TREE_CODE(type) == RECORD_TYPE);\n \n   tree field = DECL_CHAIN(TYPE_FIELDS(type));\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__count\") == 0);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__count\") == 0);\n \n   tree ret = build3(COMPONENT_REF, TREE_TYPE(field), array, field, NULL_TREE);\n   if (TREE_CONSTANT(array))\n@@ -4846,10 +4846,10 @@ Array_type::capacity_tree(Gogo* gogo, tree array)\n   // This is an open array.  We need to read the capacity field.\n \n   tree type = TREE_TYPE(array);\n-  gcc_assert(TREE_CODE(type) == RECORD_TYPE);\n+  go_assert(TREE_CODE(type) == RECORD_TYPE);\n \n   tree field = DECL_CHAIN(DECL_CHAIN(TYPE_FIELDS(type)));\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__capacity\") == 0);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__capacity\") == 0);\n \n   return build3(COMPONENT_REF, TREE_TYPE(field), array, field, NULL_TREE);\n }\n@@ -4955,21 +4955,21 @@ Array_type::array_type_descriptor(Gogo* gogo, Named_type* name)\n   vals->reserve(3);\n \n   Struct_field_list::const_iterator p = fields->begin();\n-  gcc_assert(p->field_name() == \"commonType\");\n+  go_assert(p->field_name() == \"commonType\");\n   vals->push_back(this->type_descriptor_constructor(gogo,\n \t\t\t\t\t\t    RUNTIME_TYPE_KIND_ARRAY,\n \t\t\t\t\t\t    name, NULL, true));\n \n   ++p;\n-  gcc_assert(p->field_name() == \"elem\");\n+  go_assert(p->field_name() == \"elem\");\n   vals->push_back(Expression::make_type_descriptor(this->element_type_, bloc));\n \n   ++p;\n-  gcc_assert(p->field_name() == \"len\");\n+  go_assert(p->field_name() == \"len\");\n   vals->push_back(Expression::make_cast(p->type(), this->length_, bloc));\n \n   ++p;\n-  gcc_assert(p == fields->end());\n+  go_assert(p == fields->end());\n \n   return Expression::make_struct_composite_literal(atdt, vals, bloc);\n }\n@@ -4989,17 +4989,17 @@ Array_type::slice_type_descriptor(Gogo* gogo, Named_type* name)\n   vals->reserve(2);\n \n   Struct_field_list::const_iterator p = fields->begin();\n-  gcc_assert(p->field_name() == \"commonType\");\n+  go_assert(p->field_name() == \"commonType\");\n   vals->push_back(this->type_descriptor_constructor(gogo,\n \t\t\t\t\t\t    RUNTIME_TYPE_KIND_SLICE,\n \t\t\t\t\t\t    name, NULL, true));\n \n   ++p;\n-  gcc_assert(p->field_name() == \"elem\");\n+  go_assert(p->field_name() == \"elem\");\n   vals->push_back(Expression::make_type_descriptor(this->element_type_, bloc));\n \n   ++p;\n-  gcc_assert(p == fields->end());\n+  go_assert(p == fields->end());\n \n   return Expression::make_struct_composite_literal(stdt, vals, bloc);\n }\n@@ -5303,21 +5303,21 @@ Map_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n   vals->reserve(3);\n \n   Struct_field_list::const_iterator p = fields->begin();\n-  gcc_assert(p->field_name() == \"commonType\");\n+  go_assert(p->field_name() == \"commonType\");\n   vals->push_back(this->type_descriptor_constructor(gogo,\n \t\t\t\t\t\t    RUNTIME_TYPE_KIND_MAP,\n \t\t\t\t\t\t    name, NULL, true));\n \n   ++p;\n-  gcc_assert(p->field_name() == \"key\");\n+  go_assert(p->field_name() == \"key\");\n   vals->push_back(Expression::make_type_descriptor(this->key_type_, bloc));\n \n   ++p;\n-  gcc_assert(p->field_name() == \"elem\");\n+  go_assert(p->field_name() == \"elem\");\n   vals->push_back(Expression::make_type_descriptor(this->val_type_, bloc));\n \n   ++p;\n-  gcc_assert(p == fields->end());\n+  go_assert(p == fields->end());\n \n   return Expression::make_struct_composite_literal(mtdt, vals, bloc);\n }\n@@ -5557,17 +5557,17 @@ Channel_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n   vals->reserve(3);\n \n   Struct_field_list::const_iterator p = fields->begin();\n-  gcc_assert(p->field_name() == \"commonType\");\n+  go_assert(p->field_name() == \"commonType\");\n   vals->push_back(this->type_descriptor_constructor(gogo,\n \t\t\t\t\t\t    RUNTIME_TYPE_KIND_CHAN,\n \t\t\t\t\t\t    name, NULL, true));\n \n   ++p;\n-  gcc_assert(p->field_name() == \"elem\");\n+  go_assert(p->field_name() == \"elem\");\n   vals->push_back(Expression::make_type_descriptor(this->element_type_, bloc));\n \n   ++p;\n-  gcc_assert(p->field_name() == \"dir\");\n+  go_assert(p->field_name() == \"dir\");\n   // These bits must match the ones in libgo/runtime/go-type.h.\n   int val = 0;\n   if (this->may_receive_)\n@@ -5580,7 +5580,7 @@ Channel_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n   mpz_clear(iv);\n \n   ++p;\n-  gcc_assert(p == fields->end());\n+  go_assert(p == fields->end());\n \n   return Expression::make_struct_composite_literal(ctdt, vals, bloc);\n }\n@@ -5830,7 +5830,7 @@ Interface_type::find_method(const std::string& name) const\n size_t\n Interface_type::method_index(const std::string& name) const\n {\n-  gcc_assert(this->methods_ != NULL);\n+  go_assert(this->methods_ != NULL);\n   size_t ret = 0;\n   for (Typed_identifier_list::const_iterator p = this->methods_->begin();\n        p != this->methods_->end();\n@@ -6053,7 +6053,7 @@ Interface_type::implements_interface(const Type* t, std::string* reason) const\n \n       Function_type *p_fn_type = p->type()->function_type();\n       Function_type* m_fn_type = m->type()->function_type();\n-      gcc_assert(p_fn_type != NULL && m_fn_type != NULL);\n+      go_assert(p_fn_type != NULL && m_fn_type != NULL);\n       std::string subreason;\n       if (!p_fn_type->is_identical(m_fn_type, true, true, &subreason))\n \t{\n@@ -6170,7 +6170,7 @@ Interface_type::non_empty_type_tree(source_location location)\n tree\n Interface_type::fill_in_tree(Gogo* gogo, tree type)\n {\n-  gcc_assert(this->methods_ != NULL);\n+  go_assert(this->methods_ != NULL);\n \n   // Build the type of the table of methods.\n \n@@ -6200,15 +6200,15 @@ Interface_type::fill_in_tree(Gogo* gogo, tree type)\n       *pp = field;\n       pp = &DECL_CHAIN(field);\n       // Sanity check: the names should be sorted.\n-      gcc_assert(p->name() > last_name);\n+      go_assert(p->name() > last_name);\n       last_name = p->name();\n     }\n   layout_type(method_table);\n \n   // Update the type of the __methods field from a generic pointer to\n   // a pointer to the method table.\n   field = TYPE_FIELDS(type);\n-  gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__methods\") == 0);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__methods\") == 0);\n \n   TREE_TYPE(field) = build_pointer_type(method_table);\n \n@@ -6287,13 +6287,13 @@ Interface_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n   ivals->reserve(2);\n \n   Struct_field_list::const_iterator pif = ifields->begin();\n-  gcc_assert(pif->field_name() == \"commonType\");\n+  go_assert(pif->field_name() == \"commonType\");\n   ivals->push_back(this->type_descriptor_constructor(gogo,\n \t\t\t\t\t\t     RUNTIME_TYPE_KIND_INTERFACE,\n \t\t\t\t\t\t     name, NULL, true));\n \n   ++pif;\n-  gcc_assert(pif->field_name() == \"methods\");\n+  go_assert(pif->field_name() == \"methods\");\n \n   Expression_list* methods = new Expression_list();\n   if (this->methods_ != NULL && !this->methods_->empty())\n@@ -6311,13 +6311,13 @@ Interface_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n \t  mvals->reserve(3);\n \n \t  Struct_field_list::const_iterator pmf = mfields->begin();\n-\t  gcc_assert(pmf->field_name() == \"name\");\n+\t  go_assert(pmf->field_name() == \"name\");\n \t  std::string s = Gogo::unpack_hidden_name(pm->name());\n \t  Expression* e = Expression::make_string(s, bloc);\n \t  mvals->push_back(Expression::make_unary(OPERATOR_AND, e, bloc));\n \n \t  ++pmf;\n-\t  gcc_assert(pmf->field_name() == \"pkgPath\");\n+\t  go_assert(pmf->field_name() == \"pkgPath\");\n \t  if (!Gogo::is_hidden_name(pm->name()))\n \t    mvals->push_back(Expression::make_nil(bloc));\n \t  else\n@@ -6328,11 +6328,11 @@ Interface_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n \t    }\n \n \t  ++pmf;\n-\t  gcc_assert(pmf->field_name() == \"typ\");\n+\t  go_assert(pmf->field_name() == \"typ\");\n \t  mvals->push_back(Expression::make_type_descriptor(pm->type(), bloc));\n \n \t  ++pmf;\n-\t  gcc_assert(pmf == mfields->end());\n+\t  go_assert(pmf == mfields->end());\n \n \t  e = Expression::make_struct_composite_literal(elemtype, mvals,\n \t\t\t\t\t\t\tbloc);\n@@ -6344,7 +6344,7 @@ Interface_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n \t\t\t\t\t\t\t    methods, bloc));\n \n   ++pif;\n-  gcc_assert(pif == ifields->end());\n+  go_assert(pif == ifields->end());\n \n   return Expression::make_struct_composite_literal(itdt, ivals, bloc);\n }\n@@ -6366,7 +6366,7 @@ Interface_type::do_reflection(Gogo* gogo, std::string* ret) const\n \t  ret->push_back(' ');\n \t  ret->append(Gogo::unpack_hidden_name(p->name()));\n \t  std::string sub = p->type()->reflection(gogo);\n-\t  gcc_assert(sub.compare(0, 4, \"func\") == 0);\n+\t  go_assert(sub.compare(0, 4, \"func\") == 0);\n \t  sub = sub.substr(4);\n \t  ret->append(sub);\n \t}\n@@ -6514,7 +6514,7 @@ Interface_type::do_import(Import* imp)\n \t\t\t\t\t\t     ptype, imp->location()));\n \t      if (imp->peek_char() != ',')\n \t\tbreak;\n-\t      gcc_assert(!is_varargs);\n+\t      go_assert(!is_varargs);\n \t      imp->require_c_string(\", \");\n \t    }\n \t}\n@@ -6647,7 +6647,7 @@ Named_method::do_bind_method(Expression* expr, source_location location) const\n   if (this->depth() > 0 && !this->needs_stub_method())\n     {\n       Function_type* ftype = this->do_type();\n-      gcc_assert(ftype->is_method());\n+      go_assert(ftype->is_method());\n       Type* frtype = ftype->receiver()->type();\n       bme->set_first_argument_type(frtype);\n     }\n@@ -6880,7 +6880,7 @@ tree\n Named_type::interface_method_table(Gogo* gogo, const Interface_type* interface,\n \t\t\t\t   bool is_pointer)\n {\n-  gcc_assert(!interface->is_empty());\n+  go_assert(!interface->is_empty());\n \n   Interface_method_tables** pimt = (is_pointer\n \t\t\t\t    ? &this->interface_method_tables_\n@@ -6895,7 +6895,7 @@ Named_type::interface_method_table(Gogo* gogo, const Interface_type* interface,\n   if (ins.second)\n     {\n       // This is a new entry in the hash table.\n-      gcc_assert(ins.first->second == NULL_TREE);\n+      go_assert(ins.first->second == NULL_TREE);\n       ins.first->second = gogo->interface_method_table_for_type(interface,\n \t\t\t\t\t\t\t\tthis,\n \t\t\t\t\t\t\t\tis_pointer);\n@@ -6904,7 +6904,7 @@ Named_type::interface_method_table(Gogo* gogo, const Interface_type* interface,\n   tree decl = ins.first->second;\n   if (decl == error_mark_node)\n     return error_mark_node;\n-  gcc_assert(decl != NULL_TREE && TREE_CODE(decl) == VAR_DECL);\n+  go_assert(decl != NULL_TREE && TREE_CODE(decl) == VAR_DECL);\n   return build_fold_addr_expr(decl);\n }\n \n@@ -7198,7 +7198,7 @@ Named_type::convert(Gogo* gogo)\n   if (t == error_mark_node)\n     this->is_error_ = true;\n   else\n-    gcc_assert(TYPE_SIZE(t) != NULL_TREE);\n+    go_assert(TYPE_SIZE(t) != NULL_TREE);\n \n   this->is_converted_ = true;\n }\n@@ -7330,19 +7330,19 @@ Named_type::do_get_tree(Gogo* gogo)\n       // converting types.\n       this->create_placeholder(gogo);\n       t = this->named_tree_;\n-      gcc_assert(t != NULL_TREE);\n+      go_assert(t != NULL_TREE);\n       return t;\n     }\n \n   // We are not converting types.  This should only be called if the\n   // type has already been converted.\n   if (!this->is_converted_)\n     {\n-      gcc_assert(saw_errors());\n+      go_assert(saw_errors());\n       return error_mark_node;\n     }\n \n-  gcc_assert(t != NULL_TREE && TYPE_SIZE(t) != NULL_TREE);\n+  go_assert(t != NULL_TREE && TYPE_SIZE(t) != NULL_TREE);\n \n   // Complete the tree.\n   Type* base = this->type_->base();\n@@ -7380,8 +7380,8 @@ Named_type::do_get_tree(Gogo* gogo)\n \treturn error_mark_node;\n       if (this->is_circular_)\n \tt1 = ptr_type_node;\n-      gcc_assert(t != NULL_TREE && TREE_CODE(t) == POINTER_TYPE);\n-      gcc_assert(TREE_CODE(t1) == POINTER_TYPE);\n+      go_assert(t != NULL_TREE && TREE_CODE(t) == POINTER_TYPE);\n+      go_assert(TREE_CODE(t1) == POINTER_TYPE);\n       TREE_TYPE(t) = TREE_TYPE(t1);\n       return t;\n \n@@ -7400,8 +7400,8 @@ Named_type::do_get_tree(Gogo* gogo)\n \treturn error_mark_node;\n       if (this->is_circular_)\n \tt1 = ptr_type_node;\n-      gcc_assert(t != NULL_TREE && TREE_CODE(t) == POINTER_TYPE);\n-      gcc_assert(TREE_CODE(t1) == POINTER_TYPE);\n+      go_assert(t != NULL_TREE && TREE_CODE(t) == POINTER_TYPE);\n+      go_assert(TREE_CODE(t1) == POINTER_TYPE);\n       TREE_TYPE(t) = TREE_TYPE(t1);\n       return t;\n \n@@ -7474,7 +7474,7 @@ Named_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n   Named_object* no = this->named_object_;\n   std::string name;\n   if (this->location() == BUILTINS_LOCATION)\n-    gcc_assert(this->in_function_ == NULL);\n+    go_assert(this->in_function_ == NULL);\n   else\n     {\n       const std::string& unique_prefix(no->package() == NULL\n@@ -7520,7 +7520,7 @@ Named_type::import_named_type(Import* imp, Named_type** ptype)\n   imp->require_c_string(\"type \");\n   Type *type = imp->read_type();\n   *ptype = type->named_type();\n-  gcc_assert(*ptype != NULL);\n+  go_assert(*ptype != NULL);\n   imp->require_c_string(\";\\n\");\n }\n \n@@ -7755,7 +7755,7 @@ Type::add_interface_methods_for_type(const Type* type,\n \t  // when we look at the methods for IT.\n \t  continue;\n \t}\n-      gcc_assert(!fntype->is_method());\n+      go_assert(!fntype->is_method());\n       fntype = fntype->copy_with_receiver(const_cast<Type*>(type));\n       Method* m = new Interface_method(pm->name(), pm->location(), fntype,\n \t\t\t\t       field_indexes, depth);\n@@ -7882,7 +7882,7 @@ Type::build_one_stub_method(Gogo* gogo, Method* method,\n \t\t\t    source_location location)\n {\n   Named_object* receiver_object = gogo->lookup(receiver_name, NULL);\n-  gcc_assert(receiver_object != NULL);\n+  go_assert(receiver_object != NULL);\n \n   Expression* expr = Expression::make_var_reference(receiver_object, location);\n   expr = Type::apply_field_indexes(expr, method->field_indexes(), location);\n@@ -7900,15 +7900,15 @@ Type::build_one_stub_method(Gogo* gogo, Method* method,\n \t   ++p)\n \t{\n \t  Named_object* param = gogo->lookup(p->name(), NULL);\n-\t  gcc_assert(param != NULL);\n+\t  go_assert(param != NULL);\n \t  Expression* param_ref = Expression::make_var_reference(param,\n \t\t\t\t\t\t\t\t location);\n \t  arguments->push_back(param_ref);\n \t}\n     }\n \n   Expression* func = method->bind_method(expr, location);\n-  gcc_assert(func != NULL);\n+  go_assert(func != NULL);\n   Call_expression* call = Expression::make_call(func, arguments, is_varargs,\n \t\t\t\t\t\tlocation);\n   size_t count = call->result_count();\n@@ -7941,13 +7941,13 @@ Type::apply_field_indexes(Expression* expr,\n     return expr;\n   expr = Type::apply_field_indexes(expr, field_indexes->next, location);\n   Struct_type* stype = expr->type()->deref()->struct_type();\n-  gcc_assert(stype != NULL\n+  go_assert(stype != NULL\n \t     && field_indexes->field_index < stype->field_count());\n   if (expr->type()->struct_type() == NULL)\n     {\n-      gcc_assert(expr->type()->points_to() != NULL);\n+      go_assert(expr->type()->points_to() != NULL);\n       expr = Expression::make_unary(OPERATOR_MULT, expr, location);\n-      gcc_assert(expr->type()->struct_type() == stype);\n+      go_assert(expr->type()->struct_type() == stype);\n     }\n   return Expression::make_field_reference(expr, field_indexes->field_index,\n \t\t\t\t\t  location);\n@@ -8040,13 +8040,13 @@ Type::bind_field_or_method(Gogo* gogo, const Type* type, Expression* expr,\n       Expression* ret;\n       if (!is_method)\n \t{\n-\t  gcc_assert(st != NULL);\n+\t  go_assert(st != NULL);\n \t  if (type->struct_type() == NULL)\n \t    {\n-\t      gcc_assert(type->points_to() != NULL);\n+\t      go_assert(type->points_to() != NULL);\n \t      expr = Expression::make_unary(OPERATOR_MULT, expr,\n \t\t\t\t\t    location);\n-\t      gcc_assert(expr->type()->struct_type() == st);\n+\t      go_assert(expr->type()->struct_type() == st);\n \t    }\n \t  ret = st->field_reference(expr, name, location);\n \t}\n@@ -8062,12 +8062,12 @@ Type::bind_field_or_method(Gogo* gogo, const Type* type, Expression* expr,\n \t    m = st->method_function(name, NULL);\n \t  else\n \t    gcc_unreachable();\n-\t  gcc_assert(m != NULL);\n+\t  go_assert(m != NULL);\n \t  if (!m->is_value_method() && expr->type()->points_to() == NULL)\n \t    expr = Expression::make_unary(OPERATOR_AND, expr, location);\n \t  ret = m->bind_method(expr, location);\n \t}\n-      gcc_assert(ret != NULL);\n+      go_assert(ret != NULL);\n       return ret;\n     }\n   else\n@@ -8222,7 +8222,7 @@ Type::find_field_or_method(const Type* type,\n       Named_type* fnt = pf->type()->named_type();\n       if (fnt == NULL)\n \tfnt = pf->type()->deref()->named_type();\n-      gcc_assert(fnt != NULL);\n+      go_assert(fnt != NULL);\n \n       int sublevel = level == NULL ? 1 : *level + 1;\n       bool sub_is_method;\n@@ -8271,7 +8271,7 @@ Type::find_field_or_method(const Type* type,\n \t  else if (found_ambig1.empty())\n \t    {\n \t      // We found an ambiguity.\n-\t      gcc_assert(found_parent != NULL);\n+\t      go_assert(found_parent != NULL);\n \t      found_ambig1 = found_parent->field_name();\n \t      found_ambig2 = pf->field_name();\n \t    }\n@@ -8295,7 +8295,7 @@ Type::find_field_or_method(const Type* type,\n     return false;\n   else if (!found_ambig1.empty())\n     {\n-      gcc_assert(!found_ambig1.empty());\n+      go_assert(!found_ambig1.empty());\n       ambig1->assign(found_ambig1);\n       ambig2->assign(found_ambig2);\n       if (level != NULL)\n@@ -8395,7 +8395,7 @@ Forward_declaration_type::Forward_declaration_type(Named_object* named_object)\n   : Type(TYPE_FORWARD),\n     named_object_(named_object->resolve()), warned_(false)\n {\n-  gcc_assert(this->named_object_->is_unknown()\n+  go_assert(this->named_object_->is_unknown()\n \t     || this->named_object_->is_type_declaration());\n }\n \n@@ -8615,7 +8615,7 @@ void\n Forward_declaration_type::do_export(Export*) const\n {\n   // If there is a base type, that should be exported instead of this.\n-  gcc_assert(!this->is_defined());\n+  go_assert(!this->is_defined());\n \n   // We don't output anything.\n }"}, {"sha": "80593793802dd66cef3d9fe6af26a238575f31de", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=26409c5246d31c7709ea85e8fea698d38bfb161d", "patch": "@@ -160,15 +160,15 @@ class Method\n   Named_object*\n   stub_object() const\n   {\n-    gcc_assert(this->stub_ != NULL);\n+    go_assert(this->stub_ != NULL);\n     return this->stub_;\n   }\n \n   // Set the stub object.\n   void\n   set_stub_object(Named_object* no)\n   {\n-    gcc_assert(this->stub_ == NULL);\n+    go_assert(this->stub_ == NULL);\n     this->stub_ = no;\n   }\n \n@@ -1167,7 +1167,7 @@ class Typed_identifier\n   void\n   set_type(Type* type)\n   {\n-    gcc_assert(this->type_ == NULL || type->is_error_type());\n+    go_assert(this->type_ == NULL || type->is_error_type());\n     this->type_ = type;\n   }\n \n@@ -1213,7 +1213,7 @@ class Typed_identifier_list\n   void\n   set_type(size_t i, Type* type)\n   {\n-    gcc_assert(i < this->entries_.size());\n+    go_assert(i < this->entries_.size());\n     this->entries_[i].set_type(type);\n   }\n \n@@ -1253,7 +1253,7 @@ class Typed_identifier_list\n   void\n   resize(size_t c)\n   {\n-    gcc_assert(c <= this->entries_.size());\n+    go_assert(c <= this->entries_.size());\n     this->entries_.resize(c, Typed_identifier(\"\", NULL, UNKNOWN_LOCATION));\n   }\n \n@@ -1777,7 +1777,7 @@ class Struct_field\n   const std::string&\n   tag() const\n   {\n-    gcc_assert(this->tag_ != NULL);\n+    go_assert(this->tag_ != NULL);\n     return *this->tag_;\n   }\n \n@@ -2228,7 +2228,7 @@ class Channel_type : public Type\n     : Type(TYPE_CHANNEL),\n       may_send_(may_send), may_receive_(may_receive),\n       element_type_(element_type)\n-  { gcc_assert(may_send || may_receive); }\n+  { go_assert(may_send || may_receive); }\n \n   // Whether this channel can send data.\n   bool\n@@ -2312,7 +2312,7 @@ class Interface_type : public Type\n   Interface_type(Typed_identifier_list* methods, source_location location)\n     : Type(TYPE_INTERFACE),\n       methods_(methods), location_(location)\n-  { gcc_assert(methods == NULL || !methods->empty()); }\n+  { go_assert(methods == NULL || !methods->empty()); }\n \n   // The location where the interface type was defined.\n   source_location"}, {"sha": "80b367cc46d4b6fc03cfc44236e00a99a642bf8d", "filename": "gcc/go/gofrontend/unsafe.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Funsafe.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26409c5246d31c7709ea85e8fea698d38bfb161d/gcc%2Fgo%2Fgofrontend%2Funsafe.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Funsafe.cc?ref=26409c5246d31c7709ea85e8fea698d38bfb161d", "patch": "@@ -27,7 +27,7 @@ Gogo::import_unsafe(const std::string& local_name, bool is_local_name_exported,\n \n   if (package == NULL)\n     {\n-      gcc_assert(saw_errors());\n+      go_assert(saw_errors());\n       return;\n     }\n \n@@ -44,9 +44,9 @@ Gogo::import_unsafe(const std::string& local_name, bool is_local_name_exported,\n     }\n   else\n     {\n-      gcc_assert(no->package() == package);\n-      gcc_assert(no->is_type());\n-      gcc_assert(no->type_value()->is_unsafe_pointer_type());\n+      go_assert(no->package() == package);\n+      go_assert(no->is_type());\n+      go_assert(no->type_value()->is_unsafe_pointer_type());\n       no->type_value()->set_is_visible();\n     }\n   Named_type* pointer_type = no->type_value();"}]}