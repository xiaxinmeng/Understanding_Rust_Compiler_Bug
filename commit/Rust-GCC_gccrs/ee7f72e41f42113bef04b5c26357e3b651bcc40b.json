{"sha": "ee7f72e41f42113bef04b5c26357e3b651bcc40b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWU3ZjcyZTQxZjQyMTEzYmVmMDRiNWMyNjM1N2UzYjY1MWJjYzQwYg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-02-01T17:36:05Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-02-01T17:36:05Z"}, "message": "jni.cc (_Jv_JNI_PopLocalFrame): Leave loop when `n == NULL'.\n\n\t* jni.cc (_Jv_JNI_PopLocalFrame): Leave loop when `n == NULL'.\n\t(_Jv_JNI_conversion_call): _Jv_JNI_PopLocalFrame will never leave\n\t`locals == NULL'.\n\t(wrap_value): New function.\n\t(_Jv_JNI_CallAnyMethodV): Use it.\n\t(_Jv_JNI_CallAnyMethodA): Likewise.\n\t(_Jv_JNI_GetField): Use wrap_value; removed specialized version.\n\t(_Jv_JNI_GetStaticField): Likewise.\n\nFrom-SVN: r31736", "tree": {"sha": "1d07bd7858af523a73c4b6acc2cd121afc2c7b69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d07bd7858af523a73c4b6acc2cd121afc2c7b69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee7f72e41f42113bef04b5c26357e3b651bcc40b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee7f72e41f42113bef04b5c26357e3b651bcc40b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee7f72e41f42113bef04b5c26357e3b651bcc40b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee7f72e41f42113bef04b5c26357e3b651bcc40b/comments", "author": null, "committer": null, "parents": [{"sha": "5dc489c1909701811d19e2ad2e63550ee5548082", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dc489c1909701811d19e2ad2e63550ee5548082", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dc489c1909701811d19e2ad2e63550ee5548082"}], "stats": {"total": 87, "additions": 43, "deletions": 44}, "files": [{"sha": "906db9d78034899fb00c69363b841aec3f47f26b", "filename": "libjava/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7f72e41f42113bef04b5c26357e3b651bcc40b/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7f72e41f42113bef04b5c26357e3b651bcc40b/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=ee7f72e41f42113bef04b5c26357e3b651bcc40b", "patch": "@@ -1,5 +1,14 @@\n 2000-02-01  Tom Tromey  <tromey@cygnus.com>\n \n+\t* jni.cc (_Jv_JNI_PopLocalFrame): Leave loop when `n == NULL'.\n+\t(_Jv_JNI_conversion_call): _Jv_JNI_PopLocalFrame will never leave\n+\t`locals == NULL'.\n+\t(wrap_value): New function.\n+\t(_Jv_JNI_CallAnyMethodV): Use it.\n+\t(_Jv_JNI_CallAnyMethodA): Likewise.\n+\t(_Jv_JNI_GetField): Use wrap_value; removed specialized version.\n+\t(_Jv_JNI_GetStaticField): Likewise.\n+\n \t* jni.cc (_Jv_JNI_GetField): Specialize for jobject.\n \t(_Jv_JNI_GetStaticField): Likewise.\n "}, {"sha": "1d8ee5560146ea0b89e25abc897869eb2a23a1d8", "filename": "libjava/jni.cc", "status": "modified", "additions": 34, "deletions": 44, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee7f72e41f42113bef04b5c26357e3b651bcc40b/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee7f72e41f42113bef04b5c26357e3b651bcc40b/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=ee7f72e41f42113bef04b5c26357e3b651bcc40b", "patch": "@@ -255,15 +255,35 @@ _Jv_JNI_PopLocalFrame (JNIEnv *env, jobject result)\n       // must not free it.  However, we must be sure to clear all its\n       // elements, since we might conceivably reuse it.\n       if (n == NULL)\n-\tmemset (&rf->vec[0], 0, rf->size * sizeof (jobject));\n-      else\n-\t_Jv_Free (rf);\n+\t{\n+\t  memset (&rf->vec[0], 0, rf->size * sizeof (jobject));\n+\t  break;\n+\t}\n+\n+      _Jv_Free (rf);\n       rf = n;\n     }\n \n   return result == NULL ? NULL : _Jv_JNI_NewLocalRef (env, result);\n }\n \n+// This function is used from other template functions.  It wraps the\n+// return value appropriately; we specialize it so that object returns\n+// are turned into local references.\n+template<typename T>\n+static T\n+wrap_value (JNIEnv *, T value)\n+{\n+  return value;\n+}\n+\n+template<>\n+static jobject\n+wrap_value (JNIEnv *env, jobject value)\n+{\n+  return _Jv_JNI_NewLocalRef (env, value);\n+}\n+\n \f\n \n static jint\n@@ -533,16 +553,8 @@ _Jv_JNI_CallAnyMethodV (JNIEnv *env, jobject obj, jclass klass,\n   if (ex != NULL)\n     env->ex = ex;\n \n-  if (! return_type->isPrimitive ())\n-    {\n-      // Make sure we create a local reference.  The cast hackery is\n-      // to avoid problems for template instantations we know won't be\n-      // used.\n-      return (T) (long long) _Jv_JNI_NewLocalRef (env, result.l);\n-    }\n-\n   // We cheat a little here.  FIXME.\n-  return * (T *) &result;\n+  return wrap_value (env, * (T *) &result);\n }\n \n template<typename T, invocation_type style>\n@@ -585,16 +597,8 @@ _Jv_JNI_CallAnyMethodA (JNIEnv *env, jobject obj, jclass klass,\n   if (ex != NULL)\n     env->ex = ex;\n \n-  if (! return_type->isPrimitive ())\n-    {\n-      // Make sure we create a local reference.  The cast hackery is\n-      // to avoid problems for template instantations we know won't be\n-      // used.\n-      return (T) (long long) _Jv_JNI_NewLocalRef (env, result.l);\n-    }\n-\n   // We cheat a little here.  FIXME.\n-  return * (T *) &result;\n+  return wrap_value (env, * (T *) &result);\n }\n \n template<invocation_type style>\n@@ -813,18 +817,10 @@ _Jv_JNI_NewObjectA (JNIEnv *env, jclass klass, jmethodID id,\n \n template<typename T>\n static T\n-_Jv_JNI_GetField (JNIEnv *, jobject obj, jfieldID field) \n+_Jv_JNI_GetField (JNIEnv *env, jobject obj, jfieldID field) \n {\n   T *ptr = (T *) ((char *) obj + field->getOffset ());\n-  return *ptr;\n-}\n-\n-template<>\n-static jobject\n-_Jv_JNI_GetField<jobject> (JNIEnv *env, jobject obj, jfieldID field)\n-{\n-  jobject *ptr = (jobject *) ((char *) obj + field->getOffset ());\n-  return _Jv_JNI_NewLocalRef (env, *ptr);\n+  return wrap_value (env, *ptr);\n }\n \n template<typename T>\n@@ -886,21 +882,12 @@ _Jv_JNI_GetAnyFieldID (JNIEnv *env, jclass clazz,\n   return NULL;\n }\n \n-// FIXME: local reference\n template<typename T>\n static T\n-_Jv_JNI_GetStaticField (JNIEnv *, jclass, jfieldID field)\n+_Jv_JNI_GetStaticField (JNIEnv *env, jclass, jfieldID field)\n {\n   T *ptr = (T *) field->u.addr;\n-  return *ptr;\n-}\n-\n-template<>\n-static jobject\n-_Jv_JNI_GetStaticField<jobject> (JNIEnv *env, jclass, jfieldID field)\n-{\n-  jobject *ptr = (jobject *) field->u.addr;\n-  return _Jv_JNI_NewLocalRef (env, *ptr);\n+  return wrap_value (env, *ptr);\n }\n \n template<typename T>\n@@ -1240,8 +1227,11 @@ _Jv_JNI_conversion_call (fixme)\n \n   T result = FIXME_ffi_call (args);\n \n-  while (env.locals != NULL)\n-    _Jv_JNI_PopLocalFrame (&env, result);\n+  do\n+    {\n+      _Jv_JNI_PopLocalFrame (&env, result);\n+    }\n+  while (env.locals != frame);\n \n   if (env.ex)\n     JvThrow (env.ex);"}]}