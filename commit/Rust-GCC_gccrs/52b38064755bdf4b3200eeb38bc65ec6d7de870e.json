{"sha": "52b38064755bdf4b3200eeb38bc65ec6d7de870e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJiMzgwNjQ3NTViZGY0YjMyMDBlZWIzOGJjNjVlYzZkN2RlODcwZQ==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "2000-01-25T00:38:09Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2000-01-25T00:38:09Z"}, "message": "loop.h (LOOP_INFO): New accessor macro.\n\n2000-01-25  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n\n\t* loop.h (LOOP_INFO): New accessor macro.\n\t* basic-block.h (struct loop): Rename field `info' to `aux'.\n\t* loop.c (scan_loop): Replace loop->info with LOOP_INFO (loop).\n\t(prescan_loop, strength_reduce, check_dbra_loop, insert_bct): Likewise.\n\t* unroll.c (loop_iterations, unroll_loop): Likewise.\n\nFrom-SVN: r31596", "tree": {"sha": "c49627cb58a453d050405ec2e4b537b3fd07b649", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c49627cb58a453d050405ec2e4b537b3fd07b649"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52b38064755bdf4b3200eeb38bc65ec6d7de870e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52b38064755bdf4b3200eeb38bc65ec6d7de870e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52b38064755bdf4b3200eeb38bc65ec6d7de870e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52b38064755bdf4b3200eeb38bc65ec6d7de870e/comments", "author": null, "committer": null, "parents": [{"sha": "a1e3399aef401eeaf607e8f4f1aa026cd3835209", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1e3399aef401eeaf607e8f4f1aa026cd3835209", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1e3399aef401eeaf607e8f4f1aa026cd3835209"}], "stats": {"total": 33, "additions": 22, "deletions": 11}, "files": [{"sha": "9c1c1b3d7129bd7d323d4dbfa4ae4d7b7228a1b6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52b38064755bdf4b3200eeb38bc65ec6d7de870e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52b38064755bdf4b3200eeb38bc65ec6d7de870e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=52b38064755bdf4b3200eeb38bc65ec6d7de870e", "patch": "@@ -1,3 +1,11 @@\n+2000-01-25  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* loop.h (LOOP_INFO): New accessor macro.\n+\t* basic-block.h (struct loop): Rename field `info' to `aux'.\n+\t* loop.c (scan_loop): Replace loop->info with LOOP_INFO (loop).\n+\t(prescan_loop, strength_reduce, check_dbra_loop, insert_bct): Likewise.\n+\t* unroll.c (loop_iterations, unroll_loop): Likewise.\n+\n 2000-01-24  Christopher Faylor <cgf@cygnus.com>\n \n \t* config/i386/t-cygwin: Accomodate new winsup directory layout"}, {"sha": "a4e970d9b83d3aa7620799333ed8a32dd2ba45bf", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52b38064755bdf4b3200eeb38bc65ec6d7de870e/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52b38064755bdf4b3200eeb38bc65ec6d7de870e/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=52b38064755bdf4b3200eeb38bc65ec6d7de870e", "patch": "@@ -274,7 +274,7 @@ struct loop\n   int invalid;\n \n   /* Auxiliary info specific to a pass.  */\n-  void *info;\n+  void *aux;\n \n   /* The following are currently used by loop.c but they are likely to\n      disappear as loop.c is converted to use the CFG.  */"}, {"sha": "b297504d2f39cb144e4201430b5acbdbebad0feb", "filename": "gcc/loop.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52b38064755bdf4b3200eeb38bc65ec6d7de870e/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52b38064755bdf4b3200eeb38bc65ec6d7de870e/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=52b38064755bdf4b3200eeb38bc65ec6d7de870e", "patch": "@@ -467,7 +467,7 @@ loop_optimize (f, dumpfile, unroll_p, bct_p)\n   /* Allocate and initialize auxiliary loop information.  */\n   loops_info = xcalloc (loops->num, sizeof (struct loop_info));\n   for (i = 0; i < loops->num; i++)\n-    loops->array[i].info = loops_info + i;\n+    loops->array[i].aux = loops_info + i;\n \n   /* Now find all register lifetimes.  This must be done after\n      find_and_verify_loops, because it might reorder the insns in the\n@@ -590,7 +590,7 @@ scan_loop (loop, unroll_p, bct_p)\n   register int i;\n   rtx loop_start = loop->start;\n   rtx loop_end = loop->end;\n-  struct loop_info *loop_info = loop->info;\n+  struct loop_info *loop_info = LOOP_INFO (loop);\n   rtx p;\n   /* 1 if we are scanning insns that could be executed zero times.  */\n   int maybe_never = 0;\n@@ -2366,7 +2366,7 @@ constant_high_bytes (p, loop_start)\n #endif\n \f\n /* Scan a loop setting the elements `cont', `vtop', `loops_enclosed',\n-   `has_call', `has_volatile', and `has_tablejump' within LOOP_INFO.\n+   `has_call', `has_volatile', and `has_tablejump' within LOOP.\n    Set the global variables `unknown_address_altered',\n    `unknown_constant_address_altered', and `num_mem_sets'.  Also, fill\n    in the array `loop_mems' and the list `loop_store_mems'.  */\n@@ -2377,7 +2377,7 @@ prescan_loop (loop)\n {\n   register int level = 1;\n   rtx insn;\n-  struct loop_info *loop_info = loop->info;\n+  struct loop_info *loop_info = LOOP_INFO (loop);\n   rtx start = loop->start;\n   rtx end = loop->end;\n   /* The label after END.  Jumping here is just like falling off the\n@@ -3716,7 +3716,7 @@ strength_reduce (loop, insn_count, unroll_p, bct_p)\n   int past_loop_latch = 0;\n   /* Temporary list pointers for traversing loop_iv_list.  */\n   struct iv_class *bl, **backbl;\n-  struct loop_info *loop_info = loop->info;\n+  struct loop_info *loop_info = LOOP_INFO (loop);\n   /* Ratio of extra register life span we can justify\n      for saving an instruction.  More if loop doesn't call subroutines\n      since in that case saving an insn makes more difference\n@@ -7854,7 +7854,7 @@ check_dbra_loop (loop, insn_count)\n   int compare_and_branch;\n   rtx loop_start = loop->start;\n   rtx loop_end = loop->end;\n-  struct loop_info *loop_info = loop->info;\n+  struct loop_info *loop_info = LOOP_INFO (loop);\n \n   /* If last insn is a conditional branch, and the insn before tests a\n      register value, try to optimize it.  Otherwise, we can't do anything.  */\n@@ -9278,7 +9278,7 @@ insert_bct (loop)\n   unsigned HOST_WIDE_INT n_iterations;\n   rtx loop_start = loop->start;\n   rtx loop_end = loop->end;\n-  struct loop_info *loop_info = loop->info;  \n+  struct loop_info *loop_info = LOOP_INFO (loop);  \n   int loop_num = loop->num;\n \n #if 0\n@@ -9374,7 +9374,7 @@ insert_bct (loop)\n       /* Mark all enclosing loops that they cannot use count register.  */\n       for (outer_loop = loop; outer_loop; outer_loop = outer_loop->outer)\n \t{\n-\t  outer_loop_info = outer_loop->info;\n+\t  outer_loop_info = LOOP_INFO (outer_loop);\n \t  outer_loop_info->used_count_register = 1;\n \t}\n       instrument_loop_bct (loop_start, loop_end, GEN_INT (n_iterations));"}, {"sha": "10a7131685aff02ac63bb9fbe84bfb310493b7c9", "filename": "gcc/loop.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52b38064755bdf4b3200eeb38bc65ec6d7de870e/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52b38064755bdf4b3200eeb38bc65ec6d7de870e/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=52b38064755bdf4b3200eeb38bc65ec6d7de870e", "patch": "@@ -21,6 +21,9 @@ Boston, MA 02111-1307, USA.  */\n #include \"varray.h\"\n #include \"basic-block.h\"\n \n+/* Get the loop info pointer of a loop.  */\n+#define LOOP_INFO(LOOP) ((struct loop_info *) (LOOP)->aux) \n+\n /* Get the luid of an insn.  Catch the error of trying to reference the LUID\n    of an insn added during loop, since these don't have LUIDs.  */\n "}, {"sha": "f325ceaacfbd1684c26cf18677a4feb7bed19948", "filename": "gcc/unroll.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52b38064755bdf4b3200eeb38bc65ec6d7de870e/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52b38064755bdf4b3200eeb38bc65ec6d7de870e/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=52b38064755bdf4b3200eeb38bc65ec6d7de870e", "patch": "@@ -256,7 +256,7 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n   rtx last_loop_insn;\n   rtx loop_start = loop->start;\n   rtx loop_end = loop->end;\n-  struct loop_info *loop_info = loop->info;\n+  struct loop_info *loop_info = LOOP_INFO (loop);\n \n   /* Don't bother unrolling huge loops.  Since the minimum factor is\n      two, loops greater than one half of MAX_UNROLLED_INSNS will never\n@@ -3635,7 +3635,7 @@ loop_iterations (loop)\n   int unsigned_p, compare_dir, final_larger;\n   rtx last_loop_insn;\n   rtx reg_term;\n-  struct loop_info *loop_info = loop->info;\n+  struct loop_info *loop_info = LOOP_INFO (loop);\n \n   loop_info->n_iterations = 0;\n   loop_info->initial_value = 0;"}]}