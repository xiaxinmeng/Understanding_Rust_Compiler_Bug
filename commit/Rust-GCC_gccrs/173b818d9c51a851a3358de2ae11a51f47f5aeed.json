{"sha": "173b818d9c51a851a3358de2ae11a51f47f5aeed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTczYjgxOGQ5YzUxYTg1MWEzMzU4ZGUyYWUxMWE1MWY0N2Y1YWVlZA==", "commit": {"author": {"name": "Brian Booth", "email": "bbooth@gcc.gnu.org", "date": "2004-07-22T18:33:20Z"}, "committer": {"name": "Brian Booth", "email": "bbooth@gcc.gnu.org", "date": "2004-07-22T18:33:20Z"}, "message": "tree-ssa-ccp.c (latticevalue): Add UNKNOWN_VAL.\n\n\n\t* tree-ssa-ccp.c (latticevalue): Add UNKNOWN_VAL.\n\t(substitute_and_fold): Propigate into VUSE operands when possible.\n\t(visit_phi_node): Handle UNKNOWN_VAL latticevalue.\n\t(cp_lattice_meet): Handle merging of latticevalues when\n\tUNKNOWN_VAL is present.\n\t(visit_stmt): Visit assignments with V_MUST_DEFs.\n\t(visit_assignment): Gather ccp information for V_MUST_DEF operands.\n\t(ccp_fold): Deal with RHS' that are constant and virtual.\n\t(evaluate_stmt): Handle UNKNOWN_VAL likely values.\n\t(dump_lattice_value): Dump UNKNOWN_VAL latticevalues.\n\t(initialize): Mark statements with V_MUST_DEFs as VARYING only if the\n\tV_MUST_DEF operand is VARYING. Fix comment and include VOPS when\n\tcomputing immediate uses.\n\t(set_lattice_value): Disallow a UNKNOWN_VAL->UNDEFINED state\n\ttransition.\n\t(replace_vuse_in): New function.\n\t(likely_value): Add check of vuse operands.\n\t(get_default_value): Set the default value of virtually defined\n\tvariables to UKNOWN_VAL instead of VARYING.\n\ntestsuite:\n\n\t* gcc.dg/tree-ssa/20040721-1.c: New test.\n\nFrom-SVN: r85055", "tree": {"sha": "fa1b2308821180c3a5c2ca8c6e99270c2c793d16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa1b2308821180c3a5c2ca8c6e99270c2c793d16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/173b818d9c51a851a3358de2ae11a51f47f5aeed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/173b818d9c51a851a3358de2ae11a51f47f5aeed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/173b818d9c51a851a3358de2ae11a51f47f5aeed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/173b818d9c51a851a3358de2ae11a51f47f5aeed/comments", "author": null, "committer": null, "parents": [{"sha": "2bb16349067f9dd8feea38c3e1d689042bcbebd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bb16349067f9dd8feea38c3e1d689042bcbebd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bb16349067f9dd8feea38c3e1d689042bcbebd7"}], "stats": {"total": 285, "additions": 244, "deletions": 41}, "files": [{"sha": "3672398b9cc4d7453b8bc60c25b6b05ed5f1167b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/173b818d9c51a851a3358de2ae11a51f47f5aeed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/173b818d9c51a851a3358de2ae11a51f47f5aeed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=173b818d9c51a851a3358de2ae11a51f47f5aeed", "patch": "@@ -1,3 +1,25 @@\n+2004-07-22  Brian Booth  <bbooth@redhat.com>\n+\n+\t* tree-ssa-ccp.c (latticevalue): Add UNKNOWN_VAL.\n+\t(substitute_and_fold): Propigate into VUSE operands when possible.\n+\t(visit_phi_node): Handle UNKNOWN_VAL latticevalue.\n+\t(cp_lattice_meet): Handle merging of latticevalues when \n+\tUNKNOWN_VAL is present.\n+\t(visit_stmt): Visit assignments with V_MUST_DEFs.\n+\t(visit_assignment): Gather ccp information for V_MUST_DEF operands.\n+\t(ccp_fold): Deal with RHS' that are constant and virtual.\n+\t(evaluate_stmt): Handle UNKNOWN_VAL likely values.\n+\t(dump_lattice_value): Dump UNKNOWN_VAL latticevalues.\n+\t(initialize): Mark statements with V_MUST_DEFs as VARYING only if the\n+\tV_MUST_DEF operand is VARYING. Fix comment and include VOPS when \n+\tcomputing immediate uses.\n+\t(set_lattice_value): Disallow a UNKNOWN_VAL->UNDEFINED state \n+\ttransition.\n+\t(replace_vuse_in): New function.\n+\t(likely_value): Add check of vuse operands.\n+\t(get_default_value): Set the default value of virtually defined \n+\tvariables to UKNOWN_VAL instead of VARYING.\n+\n 2004-07-22  Richard Henderson  <rth@redhat.com>\n \n \t* expr.c (emit_push_insn): Don't use set_mem_attributes.\n@@ -1492,6 +1514,7 @@\n \n \t* collect2.c (main):  Handle --no-demangle and --demangle flags.\n \n+>>>>>>> 2.4547\n 2004-07-13  Sebastian Pop  <pop@cri.ensmp.fr>\n \n \t* Makefile.in (OBJS-common): Add tree-data-ref.o."}, {"sha": "9003d1387842e21696d0b321043dca73172ea158", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/173b818d9c51a851a3358de2ae11a51f47f5aeed/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/173b818d9c51a851a3358de2ae11a51f47f5aeed/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=173b818d9c51a851a3358de2ae11a51f47f5aeed", "patch": "@@ -1,3 +1,7 @@\n+2004-07-22  Brian Booth  <bbooth@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/20040721-1.c: New test.\n+\n 2004-07-22  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* g++.dg/template/crash20.c: New."}, {"sha": "2c3ffb1b8e5ce72b5e9a095e9fd31cfe08c83828", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20040721-1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/173b818d9c51a851a3358de2ae11a51f47f5aeed/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040721-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/173b818d9c51a851a3358de2ae11a51f47f5aeed/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040721-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20040721-1.c?ref=173b818d9c51a851a3358de2ae11a51f47f5aeed", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-tree-ccp-vops\" } */\n+\n+/* Test to check whether global variables are being\n+   constant propagated. */\n+\n+int G;\n+\n+foo (int i)\n+{\n+   if (i > 0)\n+     G = 3;\n+   else\n+     G = 3;\n+\n+   if (G != 3)\n+     link_error ();\n+}\n+\n+main ()\n+{\n+   foo (0);\n+   return 0;\n+}\n+\n+/* There should be no G on the RHS of an assignment. */\n+/* { dg-final { scan-tree-dump-times \"= G;\" 0 \"ccp\"} } */"}, {"sha": "38bd64a44a7295cd3a162b17ca7f4713a55bff83", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 190, "deletions": 41, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/173b818d9c51a851a3358de2ae11a51f47f5aeed/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/173b818d9c51a851a3358de2ae11a51f47f5aeed/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=173b818d9c51a851a3358de2ae11a51f47f5aeed", "patch": "@@ -64,6 +64,7 @@ typedef enum\n {\n   UNINITIALIZED = 0,\n   UNDEFINED,\n+  UNKNOWN_VAL,\n   CONSTANT,\n   VARYING\n } latticevalue;\n@@ -139,6 +140,7 @@ static void substitute_and_fold (void);\n static value evaluate_stmt (tree);\n static void dump_lattice_value (FILE *, const char *, value);\n static bool replace_uses_in (tree, bool *);\n+static bool replace_vuse_in (tree, bool *);\n static latticevalue likely_value (tree);\n static tree get_rhs (tree);\n static bool set_rhs (tree *, tree);\n@@ -420,7 +422,8 @@ substitute_and_fold (void)\n \t      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n \t    }\n \n-\t  if (replace_uses_in (stmt, &replaced_address))\n+\t  if (replace_uses_in (stmt, &replaced_address)\n+\t      || replace_vuse_in (stmt, &replaced_address))\n \t    {\n \t      bool changed = fold_stmt (bsi_stmt_ptr (i));\n \t      stmt = bsi_stmt(i);\n@@ -482,6 +485,19 @@ visit_phi_node (tree phi)\n       phi_val = *curr_val;\n       break;\n \n+    case UNKNOWN_VAL:\n+      /* To avoid the default value of UNKNOWN_VAL overriding\n+         that of its possible constant arguments, temporarily\n+\t set the phi node's default lattice value to be \n+\t UNDEFINED. At the same time, place something other\n+\t than NULL_TREE in phi_val.const_val as a flag to\n+\t check when setting a new state for this phi node to\n+\t ensure that we avoid incorrect state transitions from\n+\t UNKNOWN_VAL to UNDEFINED. */\n+      phi_val.lattice_val = UNDEFINED;\n+      phi_val.const_val = phi;\n+      break;\n+\n     case UNDEFINED:\n     case UNINITIALIZED:\n       phi_val.lattice_val = UNDEFINED;\n@@ -550,18 +566,23 @@ visit_phi_node (tree phi)\n       fprintf (dump_file, \"\\n\\n\");\n     }\n \n-  set_lattice_value (PHI_RESULT (phi), phi_val);\n-  if (phi_val.lattice_val == VARYING)\n-    DONT_SIMULATE_AGAIN (phi) = 1;\n+  /* Check for an invalid change from UNKNOWN_VAL to UNDEFINED. */\n+  if (phi_val.lattice_val != UNDEFINED || phi_val.const_val == NULL_TREE)\n+    {\n+      set_lattice_value (PHI_RESULT (phi), phi_val);\n+      if (phi_val.lattice_val == VARYING)\n+        DONT_SIMULATE_AGAIN (phi) = 1;\n+    }\n }\n \n \n /* Compute the meet operator between VAL1 and VAL2:\n \n-   \t\tany M UNDEFINED = any\n-\t\tany M VARYING\t= VARYING\n-\t\tCi  M Cj\t= Ci\t\tif (i == j)\n-\t\tCi  M Cj\t= VARYING\tif (i != j)  */\n+   \t\tany  M UNDEFINED     = any\n+\t\tany  M VARYING       = VARYING\n+\t\tany  M UNKNOWN_VAL   = UNKNOWN_VAL\n+\t\tCi   M Cj\t     = Ci\tif (i == j)\n+\t\tCi   M Cj\t     = VARYING\tif (i != j)  */\n static value\n cp_lattice_meet (value val1, value val2)\n {\n@@ -581,6 +602,15 @@ cp_lattice_meet (value val1, value val2)\n       return result;\n     }\n \n+  /* any M UNKNOWN_VAL = UNKNOWN_VAL.  */\n+  if (val1.lattice_val == UNKNOWN_VAL \n+      || val2.lattice_val == UNKNOWN_VAL)\n+    {\n+      result.lattice_val = UNKNOWN_VAL;\n+      result.const_val = NULL_TREE;\n+      return result;\n+    }\n+\n   /* Ci M Cj = Ci\tif (i == j)\n      Ci M Cj = VARYING\tif (i != j)  */\n   if (simple_cst_equal (val1.const_val, val2.const_val) == 1)\n@@ -643,8 +673,12 @@ visit_stmt (tree stmt)\n   /* Now examine the statement.  If the statement is an assignment that\n      produces a single output value, evaluate its RHS to see if the lattice\n      value of its output has changed.  */\n+  v_must_defs = V_MUST_DEF_OPS (ann);\n+  v_may_defs = V_MAY_DEF_OPS (ann);\n   if (TREE_CODE (stmt) == MODIFY_EXPR\n-      && TREE_CODE (TREE_OPERAND (stmt, 0)) == SSA_NAME)\n+      && NUM_V_MAY_DEFS (v_may_defs) == 0\n+      && (NUM_V_MUST_DEFS (v_must_defs) == 1\n+          || TREE_CODE (TREE_OPERAND (stmt, 0)) == SSA_NAME))\n     visit_assignment (stmt);\n \n   /* Definitions made by statements other than assignments to SSA_NAMEs\n@@ -681,10 +715,6 @@ visit_stmt (tree stmt)\n   for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n     def_to_varying (V_MAY_DEF_RESULT (v_may_defs, i));\n     \n-  /* Mark all V_MUST_DEF operands VARYING.  */\n-  v_must_defs = V_MUST_DEF_OPS (ann);\n-  for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n-    def_to_varying (V_MUST_DEF_OP (v_must_defs, i));\n }\n \n \n@@ -696,21 +726,50 @@ visit_assignment (tree stmt)\n {\n   value val;\n   tree lhs, rhs;\n+  vuse_optype vuses;\n+  v_must_def_optype v_must_defs;\n \n   lhs = TREE_OPERAND (stmt, 0);\n   rhs = TREE_OPERAND (stmt, 1);\n+  vuses = STMT_VUSE_OPS (stmt);\n+  v_must_defs = STMT_V_MUST_DEF_OPS (stmt);\n+\n+#if defined ENABLE_CHECKING\n+  if (NUM_V_MAY_DEFS (STMT_V_MAY_DEF_OPS (stmt)) > 0\n+      || (NUM_V_MUST_DEFS (v_must_defs) != 1\n+          && TREE_CODE (lhs) != SSA_NAME))\n+    abort ();\n+#endif\n \n-  if (TREE_THIS_VOLATILE (SSA_NAME_VAR (lhs)))\n+  /* We require the SSA version number of the lhs for the value_vector.\n+     Make sure we have it.  */\n+  if (TREE_CODE (lhs) != SSA_NAME)\n     {\n-      /* Volatile variables are always VARYING.  */\n-      val.lattice_val = VARYING;\n-      val.const_val = NULL_TREE;\n+      /* If we make it here, then stmt only has one definition:\n+         a V_MUST_DEF.  */\n+      lhs = V_MUST_DEF_OP (v_must_defs, 0);\n     }\n-  else if (TREE_CODE (rhs) == SSA_NAME)\n+\n+  if (TREE_CODE (rhs) == SSA_NAME)\n     {\n       /* For a simple copy operation, we copy the lattice values.  */\n       value *nval = get_value (rhs);\n       val = *nval;\n+      \n+      /* If lhs is not a gimple register, then it cannot take on\n+         an undefined value. */\n+      if (!is_gimple_reg (SSA_NAME_VAR (lhs)) \n+          && val.lattice_val == UNDEFINED)\n+        val.lattice_val = UNKNOWN_VAL;      \n+    }\n+  else if (DECL_P (rhs) \n+           && NUM_VUSES (vuses) == 1\n+           && rhs == SSA_NAME_VAR (VUSE_OP (vuses, 0)))\n+    {\n+      /* Same as above, but the rhs is not a gimple register and yet\n+        has a known VUSE.  */\n+      value *nval = get_value (VUSE_OP (vuses, 0));\n+      val = *nval;\n     }\n   else\n     {\n@@ -827,11 +886,18 @@ ccp_fold (tree stmt)\n   enum tree_code code = TREE_CODE (rhs);\n   int kind = TREE_CODE_CLASS (code);\n   tree retval = NULL_TREE;\n+  vuse_optype vuses;\n+  \n+  vuses = STMT_VUSE_OPS (stmt);\n \n   /* If the RHS is just a variable, then that variable must now have\n      a constant value that we can return directly.  */\n   if (TREE_CODE (rhs) == SSA_NAME)\n     return get_value (rhs)->const_val;\n+  else if (DECL_P (rhs) \n+           && NUM_VUSES (vuses) == 1\n+           && rhs == SSA_NAME_VAR (VUSE_OP (vuses, 0)))\n+    return get_value (VUSE_OP (vuses, 0))->const_val;\n \n   /* Unary operators.  Note that we know the single operand must\n      be a constant.  So this should almost always return a\n@@ -1001,9 +1067,12 @@ evaluate_stmt (tree stmt)\n   else\n     {\n       /* The statement produced a nonconstant value.  If the statement\n-         had undefined operands, then the result of the statement should\n-\t be undefined.  Else the result of the statement is VARYING.  */\n+         had undefined or virtual operands, then the result of the \n+\t statement should be undefined or virtual respectively.  \n+\t Else the result of the statement is VARYING.  */\n       val.lattice_val = (likelyvalue == UNDEFINED ? UNDEFINED : VARYING);\n+      val.lattice_val = (likelyvalue == UNKNOWN_VAL \n+                           ? UNKNOWN_VAL : val.lattice_val);\n       val.const_val = NULL_TREE;\n     }\n \n@@ -1024,6 +1093,9 @@ dump_lattice_value (FILE *outf, const char *prefix, value val)\n     case VARYING:\n       fprintf (outf, \"%sVARYING\", prefix);\n       break;\n+    case UNKNOWN_VAL:\n+      fprintf (outf, \"%sUNKNOWN_VAL\", prefix);\n+      break;\n     case CONSTANT:\n       fprintf (outf, \"%sCONSTANT \", prefix);\n       print_generic_expr (outf, val.const_val, dump_flags);\n@@ -1157,6 +1229,16 @@ initialize (void)\n \t      if (get_value (def)->lattice_val == VARYING)\n \t\tvary = 1;\n \t    }\n+\t  \n+\t  /* Get the default value for each V_MUST_DEF.  */\n+\t  v_must_defs = V_MUST_DEF_OPS (ann);\n+\t  for (x = 0; x < NUM_V_MUST_DEFS (v_must_defs); x++)\n+\t    {\n+\t      tree v_must_def = V_MUST_DEF_OP (v_must_defs, x);\n+\t      if (get_value (v_must_def)->lattice_val == VARYING)\n+\t        vary = 1;\n+\t    }\n+\t  \n \t  DONT_SIMULATE_AGAIN (stmt) = vary;\n \n \t  /* Mark all V_MAY_DEF operands VARYING.  */\n@@ -1167,15 +1249,6 @@ initialize (void)\n \t      get_value (res)->lattice_val = VARYING;\n \t      SET_BIT (virtual_var, SSA_NAME_VERSION (res));\n \t    }\n-\t    \n-\t  /* Mark all V_MUST_DEF operands VARYING.  */\n-\t  v_must_defs = V_MUST_DEF_OPS (ann);\n-\t  for (x = 0; x < NUM_V_MUST_DEFS (v_must_defs); x++)\n-\t    {\n-\t      tree v_must_def = V_MUST_DEF_OP (v_must_defs, x);\n-\t      get_value (v_must_def)->lattice_val = VARYING;\n-\t      SET_BIT (virtual_var, SSA_NAME_VERSION (v_must_def));\n-\t    }\n \t}\n \n       for (e = bb->succ; e; e = e->succ_next)\n@@ -1196,8 +1269,8 @@ initialize (void)\n \t      for (x = 0; x < PHI_NUM_ARGS (phi); x++)\n \t        {\n \t\t  var = PHI_ARG_DEF (phi, x);\n-\t\t  /* If one argument is virtual, the result is virtual, and\n-\t\t     therefore varying.  */\n+\t\t  /* If one argument has a V_MAY_DEF, \n+\t\t     the result is varying.  */\n \t\t  if (TREE_CODE (var) == SSA_NAME)\n \t\t    {\n \t\t      if (TEST_BIT (virtual_var, SSA_NAME_VERSION (var)))\n@@ -1216,7 +1289,7 @@ initialize (void)\n \n   sbitmap_free (virtual_var);\n   /* Compute immediate uses for variables we care about.  */\n-  compute_immediate_uses (TDFA_USE_OPS, need_imm_uses_for);\n+  compute_immediate_uses (TDFA_USE_OPS | TDFA_USE_VOPS, need_imm_uses_for);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_immediate_uses (dump_file);\n@@ -1366,6 +1439,10 @@ set_lattice_value (tree var, value val)\n       /* CONSTANT->UNDEFINED is never a valid state transition.  */\n       if (old->lattice_val == CONSTANT)\n \tabort ();\n+\t\n+      /* UNKNOWN_VAL->UNDEFINED is never a valid state transition.  */\n+      if (old->lattice_val == UNKNOWN_VAL)\n+\tabort ();\n \n       /* VARYING->UNDEFINED is generally not a valid state transition,\n \t except for values which are initialized to VARYING.  */\n@@ -1441,6 +1518,47 @@ replace_uses_in (tree stmt, bool *replaced_addresses_p)\n   return replaced;\n }\n \n+/* Replace the VUSE references in statement STMT with its immediate reaching\n+   definition.  Return true if the reference was replaced.  If\n+   REPLACED_ADDRESSES_P is given, it will be set to true if an address\n+   constant was replaced.  */\n+\n+static bool\n+replace_vuse_in (tree stmt, bool *replaced_addresses_p)\n+{\n+  bool replaced = false;\n+  vuse_optype vuses;\n+  use_operand_p vuse;\n+  value *val;\n+\n+  if (replaced_addresses_p)\n+    *replaced_addresses_p = false;\n+\n+  get_stmt_operands (stmt);\n+\n+  vuses = STMT_VUSE_OPS (stmt);\n+\n+  if (NUM_VUSES (vuses) != 1)\n+    return false;\n+\n+  vuse = VUSE_OP_PTR (vuses, 0);\n+  val = get_value (USE_FROM_PTR (vuse));\n+\n+  if (val->lattice_val == CONSTANT\n+      && TREE_CODE (stmt) == MODIFY_EXPR\n+      && DECL_P (TREE_OPERAND (stmt, 1))\n+      && TREE_OPERAND (stmt, 1) == SSA_NAME_VAR (USE_FROM_PTR (vuse)))\n+    {\n+      TREE_OPERAND (stmt, 1) = val->const_val;\n+      replaced = true;\n+      if (POINTER_TYPE_P (TREE_TYPE (USE_FROM_PTR (vuse))) \n+          && replaced_addresses_p)\n+        *replaced_addresses_p = true;\n+    }\n+\n+  return replaced;\n+}\n+\n /* Return the likely latticevalue for STMT.\n \n    If STMT has no operands, then return CONSTANT.\n@@ -1455,6 +1573,7 @@ static latticevalue\n likely_value (tree stmt)\n {\n   use_optype uses;\n+  vuse_optype vuses;\n   size_t i;\n   int found_constant = 0;\n   stmt_ann_t ann;\n@@ -1484,8 +1603,28 @@ likely_value (tree stmt)\n       if (val->lattice_val == CONSTANT)\n \tfound_constant = 1;\n     }\n+    \n+  vuses = VUSE_OPS (ann);\n+  \n+  if (NUM_VUSES (vuses))\n+    {\n+      tree vuse = VUSE_OP (vuses, 0);\n+      value *val = get_value (vuse);\n+      \n+      if (val->lattice_val == UNKNOWN_VAL)\n+        return UNKNOWN_VAL;\n+\t\n+#ifdef ENABLE_CHECKING\n+  /* There should be no VUSE operands that are UNDEFINED. */\n+  if (val->lattice_val == UNDEFINED)\n+    abort ();\n+#endif\n+\t\n+      if (val->lattice_val == CONSTANT)\n+\tfound_constant = 1;\n+    }\n \n-  return ((found_constant || !uses) ? CONSTANT : VARYING);\n+  return ((found_constant || (!uses && !vuses)) ? CONSTANT : VARYING);\n }\n \n /* A subroutine of fold_stmt_r.  Attempts to fold *(A+O) to A[X].\n@@ -2214,12 +2353,14 @@ set_rhs (tree *stmt_p, tree expr)\n \n /* Return a default value for variable VAR using the following rules:\n \n-   1- Global and static variables are considered VARYING, unless they are\n-      declared const.\n+   1- Function arguments are considered VARYING.\n+   \n+   2- Global and static variables that are declared constant are\n+      considered CONSTANT.\n \n-   2- Function arguments are considered VARYING.\n+   3- Any other virtually defined variable is considered UNKNOWN_VAL.\n \n-   3- Any other value is considered UNDEFINED.  This is useful when\n+   4- Any other value is considered UNDEFINED.  This is useful when\n       considering PHI nodes.  PHI arguments that are undefined do not\n       change the constant value of the PHI node, which allows for more\n       constants to be propagated.  */\n@@ -2252,17 +2393,25 @@ get_default_value (tree var)\n   else if (decl_function_context (sym) != current_function_decl\n            || TREE_STATIC (sym))\n     {\n-      /* Globals and static variables are considered VARYING, unless they\n-\t are declared 'const'.  */\n-      val.lattice_val = VARYING;\n-\n+      /* Globals and static variables are considered UNKNOWN_VAL,\n+         unless they are declared 'const'.  */\n       if (TREE_READONLY (sym)\n \t  && DECL_INITIAL (sym)\n \t  && is_gimple_min_invariant (DECL_INITIAL (sym)))\n \t{\n \t  val.lattice_val = CONSTANT;\n \t  val.const_val = DECL_INITIAL (sym);\n \t}\n+      else\n+        {\n+          val.const_val = NULL_TREE;\n+\t  val.lattice_val = UNKNOWN_VAL;\n+\t}\n+    }\n+  else if (!is_gimple_reg (sym))\n+    {\n+      val.const_val = NULL_TREE;\n+      val.lattice_val = UNKNOWN_VAL;\n     }\n   else\n     {"}]}