{"sha": "1e3cabd45d499652abc3bfe28f82a363ed70390d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWUzY2FiZDQ1ZDQ5OTY1MmFiYzNiZmUyOGY4MmEzNjNlZDcwMzkwZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-05-09T21:04:38Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-05-09T21:06:26Z"}, "message": "Fix small issues with -fgnat-encodings=minimal\n\nThis is the mode where the GNAT compiler does not use special encodings\nin the debug info to describe some Ada constructs, for example packed\narray types.\n\n\t* gcc-interface/ada-tree.h (TYPE_PACKED_ARRAY_TYPE_P): Rename into...\n\t(TYPE_BIT_PACKED_ARRAY_TYPE_P): ...this.\n\t(TYPE_IS_PACKED_ARRAY_TYPE_P): Rename into...\n\t(BIT_PACKED_ARRAY_TYPE_P): ...this.\n\t(TYPE_IMPL_PACKED_ARRAY_P): Adjust to above renaming.\n\t* gcc-interface/gigi.h (maybe_pad_type): Remove IS_USER_TYPE..\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Variable>: Adjust\n\tcall to maybe_pad_type.\n\t<E_Ordinary_Fixed_Point_Type>: Remove const qualifiers for tree.\n\t<E_Signed_Integer_Subtype>: Remove redundant test and redundant call\n\tto associate_original_type_to_packed_array.  Turn into assertion.\n\tCall associate_original_type_to_packed_array and modify\n\tgnu_entity_name accordingly.  Explicitly set the parallel type\n\tfor GNAT encodings.\n\tCall create_type_decl in the misaligned case before maybe_pad_type.\n\t<E_Array_Type>: Do not use the name of the implementation type for\n\ta packed array when not using GNAT encodings.\n\t<E_Array_Subtype>: Move around setting flags. Use the result of the\n\tcall to associate_original_type_to_packed_array for gnu_entity_name.\n\t<E_Record_Subtype>: Create XVS type and XVZ variable only if debug\n\tinfo is requested for the type.\n\tCall create_type_decl if a padded type was created for a type entity\n\t(gnat_to_gnu_component_type): Use local variable and adjust calls to\n\tmaybe_pad_type.\n\t(gnat_to_gnu_subprog_type): Adjust call to maybe_pad_type.\n\t(gnat_to_gnu_field): Likewise.\n\t(validate_size): Adjust to renaming of macro.\n\t(set_rm_size): Likewise.\n\t(associate_original_type_to_packed_array): Adjust return type and\n\treturn the name of the original type if GNAT encodings are not used\n\t* gcc-interface/misc.c (gnat_get_debug_typ): Remove obsolete stuff.\n\t(gnat_get_fixed_point_type_info): Remove const qualifiers for tree.\n\t(gnat_get_array_descr_info): Likewise and set variables lazily.\n\tRemove call to maybe_debug_type.  Simplify a few computations.\n\t(enumerate_modes): Remove const qualifier for tree.\n\t* gcc-interface/utils.c (make_type_from_size): Adjust to renaming.\n\t(maybe_pad_type): Remove IS_USER_TYPE parameter and adjust.  Remove\n\tspecific code for implementation types for packed arrays.\n\t(compute_deferred_decl_context): Remove const qualifier for tree.\n\t(convert): Adjust call to maybe_pad_type.\n\t(unchecked_convert): Likewise.\n\t* gcc-interface/utils2.c (is_simple_additive_expressio): Likewise.", "tree": {"sha": "be260f6939c2fd83660d66e17a0ebcd621d80654", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be260f6939c2fd83660d66e17a0ebcd621d80654"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e3cabd45d499652abc3bfe28f82a363ed70390d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e3cabd45d499652abc3bfe28f82a363ed70390d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e3cabd45d499652abc3bfe28f82a363ed70390d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e3cabd45d499652abc3bfe28f82a363ed70390d/comments", "author": null, "committer": null, "parents": [{"sha": "2448ee85a89f313e48ee40eaed0d645c4c027944", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2448ee85a89f313e48ee40eaed0d645c4c027944", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2448ee85a89f313e48ee40eaed0d645c4c027944"}], "stats": {"total": 455, "additions": 247, "deletions": 208}, "files": [{"sha": "538973eac9adbebed77a7e38b8305618de11c493", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e3cabd45d499652abc3bfe28f82a363ed70390d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e3cabd45d499652abc3bfe28f82a363ed70390d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1e3cabd45d499652abc3bfe28f82a363ed70390d", "patch": "@@ -1,3 +1,47 @@\n+2020-05-09  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/ada-tree.h (TYPE_PACKED_ARRAY_TYPE_P): Rename into...\n+\t(TYPE_BIT_PACKED_ARRAY_TYPE_P): ...this.\n+\t(TYPE_IS_PACKED_ARRAY_TYPE_P): Rename into...\n+\t(BIT_PACKED_ARRAY_TYPE_P): ...this.\n+\t(TYPE_IMPL_PACKED_ARRAY_P): Adjust to above renaming.\n+\t* gcc-interface/gigi.h (maybe_pad_type): Remove IS_USER_TYPE parameter.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Variable>: Adjust call\n+\tto maybe_pad_type.\n+\t<E_Ordinary_Fixed_Point_Type>: Remove const qualifiers for tree.\n+\t<E_Signed_Integer_Subtype>: Remove redundant test and redundant call\n+\tto associate_original_type_to_packed_array.  Turn test into assertion.\n+\tCall associate_original_type_to_packed_array and modify gnu_entity_name\n+\taccordingly.  Explicitly set the parallel type for GNAT encodings.\n+\tCall create_type_decl in the misaligned case before maybe_pad_type.\n+\t<E_Array_Type>: Do not use the name of the implementation type for a\n+\tpacked array when not using GNAT encodings.\n+\t<E_Array_Subtype>: Move around setting flags. Use the result of the\n+\tcall to associate_original_type_to_packed_array for gnu_entity_name.\n+\t<E_Record_Subtype>: Create XVS type and XVZ variable only if debug\n+\tinfo is requested for the type.\n+\tCall create_type_decl if a padded type was created for a type entity.\n+\t(gnat_to_gnu_component_type): Use local variable and adjust calls to\n+\tmaybe_pad_type.\n+\t(gnat_to_gnu_subprog_type): Adjust call to maybe_pad_type.\n+\t(gnat_to_gnu_field): Likewise.\n+\t(validate_size): Adjust to renaming of macro.\n+\t(set_rm_size): Likewise.\n+\t(associate_original_type_to_packed_array): Adjust return type and\n+\treturn the name of the original type if GNAT encodings are not used.\n+\t* gcc-interface/misc.c (gnat_get_debug_typ): Remove obsolete stuff.\n+\t(gnat_get_fixed_point_type_info): Remove const qualifiers for tree.\n+\t(gnat_get_array_descr_info): Likewise and set variables lazily.\n+\tRemove call to maybe_debug_type.  Simplify a few computations.\n+\t(enumerate_modes): Remove const qualifier for tree.\n+\t* gcc-interface/utils.c (make_type_from_size): Adjust to renaming.\n+\t(maybe_pad_type): Remove IS_USER_TYPE parameter and adjust.  Remove\n+\tspecific code for implementation types for packed arrays.\n+\t(compute_deferred_decl_context): Remove const qualifier for tree.\n+\t(convert): Adjust call to maybe_pad_type.\n+\t(unchecked_convert): Likewise.\n+\t* gcc-interface/utils2.c (is_simple_additive_expressio): Likewise.\n+\n 2020-05-09  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/utils2.c (build_binary_op) <ARRAY_RANGE_REF>: Use"}, {"sha": "47c2e1406668c00ad41afa92f0ad64e375ec0f66", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e3cabd45d499652abc3bfe28f82a363ed70390d/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e3cabd45d499652abc3bfe28f82a363ed70390d/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=1e3cabd45d499652abc3bfe28f82a363ed70390d", "patch": "@@ -73,15 +73,15 @@ do {\t\t\t\t\t\t\t \\\n #define TYPE_IS_FAT_POINTER_P(NODE) \\\n   (TREE_CODE (NODE) == RECORD_TYPE && TYPE_FAT_POINTER_P (NODE))\n \n-/* For integral types and array types, nonzero if this is a packed array type\n-   used for bit-packed types.  Such types should not be extended to a larger\n-   size or validated against a specified size.  */\n-#define TYPE_PACKED_ARRAY_TYPE_P(NODE) \\\n+/* For integral types and array types, nonzero if this is an implementation\n+   type for a bit-packed array type.  Such types should not be extended to a\n+   larger size or validated against a specified size.  */\n+#define TYPE_BIT_PACKED_ARRAY_TYPE_P(NODE) \\\n   TYPE_LANG_FLAG_0 (TREE_CHECK2 (NODE, INTEGER_TYPE, ARRAY_TYPE))\n \n-#define TYPE_IS_PACKED_ARRAY_TYPE_P(NODE) \\\n+#define BIT_PACKED_ARRAY_TYPE_P(NODE) \\\n   ((TREE_CODE (NODE) == INTEGER_TYPE || TREE_CODE (NODE) == ARRAY_TYPE) \\\n-   && TYPE_PACKED_ARRAY_TYPE_P (NODE))\n+   && TYPE_BIT_PACKED_ARRAY_TYPE_P (NODE))\n \n /* For FUNCTION_TYPE and METHOD_TYPE, nonzero if the function returns by\n    direct reference, i.e. the callee returns a pointer to a memory location\n@@ -196,7 +196,7 @@ do {\t\t\t\t\t\t\t \\\n    types.  */\n #define TYPE_IMPL_PACKED_ARRAY_P(NODE) \\\n   ((TREE_CODE (NODE) == ARRAY_TYPE && TYPE_PACKED (NODE)) \\\n-   || (TREE_CODE (NODE) == INTEGER_TYPE && TYPE_PACKED_ARRAY_TYPE_P (NODE)))\n+   || (TREE_CODE (NODE) == INTEGER_TYPE && TYPE_BIT_PACKED_ARRAY_TYPE_P (NODE)))\n \n /* True for types that can hold a debug type.  */\n #define TYPE_CAN_HAVE_DEBUG_TYPE_P(NODE) (!TYPE_IMPL_PACKED_ARRAY_P (NODE))"}, {"sha": "0393198f84ffef44b1e8419822d28bd3b0a9672e", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 130, "deletions": 103, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e3cabd45d499652abc3bfe28f82a363ed70390d/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e3cabd45d499652abc3bfe28f82a363ed70390d/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=1e3cabd45d499652abc3bfe28f82a363ed70390d", "patch": "@@ -248,7 +248,7 @@ static tree create_variant_part_from (tree, vec<variant_desc>, tree,\n static void copy_and_substitute_in_size (tree, tree, vec<subst_pair>);\n static void copy_and_substitute_in_layout (Entity_Id, Entity_Id, tree, tree,\n \t\t\t\t\t   vec<subst_pair>, bool);\n-static void associate_original_type_to_packed_array (tree, Entity_Id);\n+static tree associate_original_type_to_packed_array (tree, Entity_Id);\n static const char *get_entity_char (Entity_Id);\n \n /* The relevant constituents of a subprogram binding to a GCC builtin.  Used\n@@ -987,7 +987,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t    tree orig_type = gnu_type;\n \n \t    gnu_type = maybe_pad_type (gnu_type, gnu_size, align, gnat_entity,\n-\t\t\t\t       false, false, definition, true);\n+\t\t\t\t       false, definition, true);\n \n \t    /* If the nominal subtype of the object is unconstrained and its\n \t       size is not fixed, compute the Ada size from the Ada size of\n@@ -1754,9 +1754,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t  {\n \t    /* Given RM restrictions on 'Small values, we assume here that\n \t       the denominator fits in an int.  */\n-\t    const tree base = build_int_cst (integer_type_node,\n-\t\t\t\t\t     Rbase (gnat_small_value));\n-\t    const tree exponent\n+\t    tree base\n+\t      = build_int_cst (integer_type_node, Rbase (gnat_small_value));\n+\t    tree exponent\n \t      = build_int_cst (integer_type_node,\n \t\t\t       UI_To_Int (Denominator (gnat_small_value)));\n \t    scale_factor\n@@ -1774,10 +1774,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \n \t    if (UI_Is_In_Int_Range (num) && UI_Is_In_Int_Range (den))\n \t      {\n-\t\tconst tree gnu_num\n+\t\ttree gnu_num\n \t\t  = build_int_cst (integer_type_node,\n \t\t\t\t   UI_To_Int (Norm_Num (gnat_small_value)));\n-\t\tconst tree gnu_den\n+\t\ttree gnu_den\n \t\t  = build_int_cst (integer_type_node,\n \t\t\t\t   UI_To_Int (Norm_Den (gnat_small_value)));\n \t\tscale_factor = build2 (RDIV_EXPR, integer_type_node,\n@@ -1856,8 +1856,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \tgnat_to_gnu_entity (Ancestor_Subtype (gnat_entity), gnu_expr, false);\n \n       /* Set the precision to the Esize except for bit-packed arrays.  */\n-      if (Is_Packed_Array_Impl_Type (gnat_entity)\n-\t  && Is_Bit_Packed_Array (Original_Array_Type (gnat_entity)))\n+      if (Is_Packed_Array_Impl_Type (gnat_entity))\n \tesize = UI_To_Int (RM_Size (gnat_entity));\n \n       /* Boolean types with foreign convention have precision 1.  */\n@@ -1934,11 +1933,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n       TYPE_STUB_DECL (gnu_type)\n \t= create_type_stub_decl (gnu_entity_name, gnu_type);\n \n-      /* For a packed array, make the original array type a parallel/debug\n-\t type.  */\n-      if (debug_info_p && Is_Packed_Array_Impl_Type (gnat_entity))\n-\tassociate_original_type_to_packed_array (gnu_type, gnat_entity);\n-\n     discrete_type:\n \n       /* We have to handle clauses that under-align the type specially.  */\n@@ -1960,19 +1954,30 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t such values), we only get the good bits, since the unused bits\n \t are uninitialized.  Both goals are accomplished by wrapping up\n \t the modular type in an enclosing record type.  */\n-      if (Is_Packed_Array_Impl_Type (gnat_entity)\n-\t  && Is_Bit_Packed_Array (Original_Array_Type (gnat_entity)))\n+      if (Is_Packed_Array_Impl_Type (gnat_entity))\n \t{\n-\t  tree gnu_field_type, gnu_field;\n+\t  tree gnu_field_type, gnu_field, t;\n+\n+\t  gcc_assert (Is_Bit_Packed_Array (Original_Array_Type (gnat_entity)));\n+\t  TYPE_BIT_PACKED_ARRAY_TYPE_P (gnu_type) = 1;\n+\n+\t  /* Make the original array type a parallel/debug type.  */\n+\t  if (debug_info_p)\n+\t    {\n+\t      tree gnu_name\n+\t\t= associate_original_type_to_packed_array (gnu_type,\n+\t\t\t\t\t\t\t   gnat_entity);\n+\t      if (gnu_name)\n+\t\tgnu_entity_name = gnu_name;\n+\t    }\n \n \t  /* Set the RM size before wrapping up the original type.  */\n \t  SET_TYPE_RM_SIZE (gnu_type,\n \t\t\t    UI_To_gnu (RM_Size (gnat_entity), bitsizetype));\n-\t  TYPE_PACKED_ARRAY_TYPE_P (gnu_type) = 1;\n \n \t  /* Create a stripped-down declaration, mainly for debugging.  */\n-\t  create_type_decl (gnu_entity_name, gnu_type, true, debug_info_p,\n-\t\t\t    gnat_entity);\n+\t  t = create_type_decl (gnu_entity_name, gnu_type, true, debug_info_p,\n+\t\t\t\tgnat_entity);\n \n \t  /* Now save it and build the enclosing record type.  */\n \t  gnu_field_type = gnu_type;\n@@ -2011,15 +2016,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t  finish_record_type (gnu_type, gnu_field, 2, false);\n \t  TYPE_JUSTIFIED_MODULAR_P (gnu_type) = 1;\n \n+\t  /* Make the original array type a parallel/debug type.  Note that\n+\t     gnat_get_array_descr_info needs a TYPE_IMPL_PACKED_ARRAY_P type\n+\t     so we use an intermediate step for standard DWARF.  */\n \t  if (debug_info_p)\n \t    {\n-\t      /* Make the original array type a parallel/debug type.  */\n-\t      associate_original_type_to_packed_array (gnu_type, gnat_entity);\n-\n-\t      /* Since GNU_TYPE is a padding type around the packed array\n-\t\t implementation type, the padded type is its debug type.  */\n \t      if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n \t\tSET_TYPE_DEBUG_TYPE (gnu_type, gnu_field_type);\n+\t      else if (DECL_PARALLEL_TYPE (t))\n+\t\tadd_parallel_type (gnu_type, DECL_PARALLEL_TYPE (t));\n \t    }\n \t}\n \n@@ -2033,9 +2038,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t  /* Set the RM size before wrapping the type.  */\n \t  SET_TYPE_RM_SIZE (gnu_type, gnu_size);\n \n+\t  /* Create a stripped-down declaration, mainly for debugging.  */\n+\t  create_type_decl (gnu_entity_name, gnu_type, true, debug_info_p,\n+\t\t\t    gnat_entity);\n+\n \t  gnu_type\n \t    = maybe_pad_type (gnu_type, TYPE_SIZE (gnu_type), align,\n-\t\t\t      gnat_entity, false, true, definition, false);\n+\t\t\t      gnat_entity, false, definition, false);\n \n \t  TYPE_PACKED (gnu_type) = 1;\n \t  SET_TYPE_ADA_SIZE (gnu_type, gnu_size);\n@@ -2112,7 +2121,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \ttree *gnu_index_types = XALLOCAVEC (tree, ndim);\n \ttree *gnu_temp_fields = XALLOCAVEC (tree, ndim);\n \ttree gnu_max_size = size_one_node, tem, t;\n-\tEntity_Id gnat_index, gnat_name;\n+\tEntity_Id gnat_index;\n \tint index;\n \ttree comp_type;\n \n@@ -2378,13 +2387,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \tcreate_type_decl (create_concat_name (gnat_entity, \"XUA\"), tem,\n \t\t\t  artificial_p, debug_info_p, gnat_entity);\n \n-\t/* If told to generate GNAT encodings for them (GDB rely on them at the\n-\t   moment): give the fat pointer type a name.  If this is a packed\n-\t   array, tell the debugger how to interpret the underlying bits.  */\n-\tif (Present (Packed_Array_Impl_Type (gnat_entity)))\n-\t  gnat_name = Packed_Array_Impl_Type (gnat_entity);\n-\telse\n-\t  gnat_name = gnat_entity;\n+\t/* If the GNAT encodings are used, give the fat pointer type a name.\n+\t   If this is a packed array, tell the debugger how to interpret the\n+\t   underlying bits by fetching that of the implementation type.  */\n+\tconst Entity_Id gnat_name\n+\t  = (Present (Packed_Array_Impl_Type (gnat_entity))\n+\t     && gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n+\t    ? Packed_Array_Impl_Type (gnat_entity)\n+\t    : gnat_entity;\n+\n \ttree xup_name\n \t  = (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n \t    ? get_entity_name (gnat_name)\n@@ -2752,6 +2763,24 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t}\n \t    }\n \n+\t  /* Set the TYPE_PACKED flag on packed array types and also on their\n+\t     implementation types, so that the DWARF back-end can output the\n+\t     appropriate description for them.  */\n+\t  TYPE_PACKED (gnu_type)\n+\t    = (Is_Packed (gnat_entity)\n+\t       || Is_Packed_Array_Impl_Type (gnat_entity));\n+\n+\t  TYPE_BIT_PACKED_ARRAY_TYPE_P (gnu_type)\n+\t    = (Is_Packed_Array_Impl_Type (gnat_entity)\n+\t       && Is_Bit_Packed_Array (Original_Array_Type (gnat_entity)));\n+\n+\t  /* If the maximum size doesn't overflow, use it.  */\n+\t  if (gnu_max_size\n+\t      && TREE_CODE (gnu_max_size) == INTEGER_CST\n+\t      && !TREE_OVERFLOW (gnu_max_size)\n+\t      && compare_tree_int (gnu_max_size, TYPE_ARRAY_SIZE_LIMIT) <= 0)\n+\t    TYPE_ARRAY_MAX_SIZE (gnu_type) = gnu_max_size;\n+\n \t  /* If we need to write out a record type giving the names of the\n \t     bounds for debugging purposes, do it now and make the record\n \t     type a parallel type.  This is not needed for a packed array\n@@ -2786,44 +2815,32 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t    }\n \n \t  /* If this is a packed array type, make the original array type a\n-\t     parallel/debug type.  Otherwise, if such GNAT encodings are\n-\t     required, do it for the base array type if it isn't artificial to\n-\t     make sure it is kept in the debug info.  */\n+\t     parallel/debug type.  Otherwise, if GNAT encodings are used, do\n+\t     it for the base array type if it is not artificial to make sure\n+\t     that it is kept in the debug info.  */\n \t  if (debug_info_p)\n \t    {\n \t      if (Is_Packed_Array_Impl_Type (gnat_entity))\n-\t\tassociate_original_type_to_packed_array (gnu_type,\n-\t\t\t\t\t\t\t gnat_entity);\n-\t      else\n+\t\t{\n+\t\t  tree gnu_name\n+\t\t    = associate_original_type_to_packed_array (gnu_type,\n+\t\t\t\t\t\t\t       gnat_entity);\n+\t\t  if (gnu_name)\n+\t\t    gnu_entity_name = gnu_name;\n+\t\t}\n+\n+\t      else if (gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n \t\t{\n \t\t  tree gnu_base_decl\n \t\t    = gnat_to_gnu_entity (Etype (gnat_entity), NULL_TREE,\n \t\t\t\t\t  false);\n-\t\t  if (!DECL_ARTIFICIAL (gnu_base_decl)\n-\t\t      && gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n+\n+\t\t  if (!DECL_ARTIFICIAL (gnu_base_decl))\n \t\t    add_parallel_type (gnu_type,\n \t\t\t\t       TREE_TYPE (TREE_TYPE (gnu_base_decl)));\n \t\t}\n \t    }\n \n-\t  TYPE_PACKED_ARRAY_TYPE_P (gnu_type)\n-\t    = (Is_Packed_Array_Impl_Type (gnat_entity)\n-\t       && Is_Bit_Packed_Array (Original_Array_Type (gnat_entity)));\n-\n-\t/* Tag top-level ARRAY_TYPE nodes for packed arrays and their\n-\t   implementation types as such so that the debug information back-end\n-\t   can output the appropriate description for them.  */\n-\t  TYPE_PACKED (gnu_type)\n-\t    = (Is_Packed (gnat_entity)\n-\t       || Is_Packed_Array_Impl_Type (gnat_entity));\n-\n-\t  /* If the maximum size doesn't overflow, use it.  */\n-\t  if (gnu_max_size\n-\t      && TREE_CODE (gnu_max_size) == INTEGER_CST\n-\t      && !TREE_OVERFLOW (gnu_max_size)\n-\t      && compare_tree_int (gnu_max_size, TYPE_ARRAY_SIZE_LIMIT) <= 0)\n-\t    TYPE_ARRAY_MAX_SIZE (gnu_type) = gnu_max_size;\n-\n \t  /* Set our alias set to that of our base type.  This gives all\n \t     array subtypes the same alias set.  */\n \t  relate_alias_sets (gnu_type, gnu_base_type, ALIAS_SET_COPY);\n@@ -3511,7 +3528,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t we are asked to output such encodings, write a record that\n \t\t shows what we are a subtype of and also make a variable that\n \t\t indicates our size, if still variable.  */\n-\t      if (gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n+\t      if (debug_info_p\n+\t\t  && gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n \t\t{\n \t\t  tree gnu_subtype_marker = make_node (RECORD_TYPE);\n \t\t  tree gnu_unpad_base_name\n@@ -4352,15 +4370,20 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t       && integer_pow2p (gnu_size))\n \talign = MIN (BIGGEST_ALIGNMENT, tree_to_uhwi (gnu_size));\n \n-      /* See if we need to pad the type.  If we did, and made a record,\n-\t the name of the new type may be changed.  So get it back for\n-\t us when we make the new TYPE_DECL below.  */\n+      /* See if we need to pad the type.  If we did and built a new type,\n+\t then create a stripped-down declaration for the original type,\n+\t mainly for debugging, unless there was already one.  */\n       if (gnu_size || align > 0)\n-\tgnu_type = maybe_pad_type (gnu_type, gnu_size, align, gnat_entity,\n-\t\t\t\t   false, !gnu_decl, definition, false);\n+\t{\n+\t  tree orig_type = gnu_type;\n+\n+\t  gnu_type = maybe_pad_type (gnu_type, gnu_size, align, gnat_entity,\n+\t\t\t\t     false, definition, false);\n \n-      if (TYPE_IS_PADDING_P (gnu_type))\n-\tgnu_entity_name = TYPE_IDENTIFIER (gnu_type);\n+\t  if (gnu_type != orig_type && !gnu_decl)\n+\t    create_type_decl (gnu_entity_name, orig_type, true, debug_info_p,\n+\t\t\t      gnat_entity);\n+\t}\n \n       /* Now set the RM size of the type.  We cannot do it before padding\n \t because we need to accept arbitrary RM sizes on integral types.  */\n@@ -5107,9 +5130,10 @@ gnat_to_gnu_component_type (Entity_Id gnat_array, bool definition,\n \t\t\t    bool debug_info_p)\n {\n   const Entity_Id gnat_type = Component_Type (gnat_array);\n+  const bool is_bit_packed = Is_Bit_Packed_Array (gnat_array);\n   tree gnu_type = gnat_to_gnu_type (gnat_type);\n-  bool has_packed_components = Is_Bit_Packed_Array (gnat_array);\n   tree gnu_comp_size;\n+  bool has_packed_components;\n   unsigned int max_align;\n \n   /* If an alignment is specified, use it as a cap on the component type\n@@ -5123,16 +5147,18 @@ gnat_to_gnu_component_type (Entity_Id gnat_array, bool definition,\n \n   /* Try to get a packable form of the component if needed.  */\n   if ((Is_Packed (gnat_array) || Has_Component_Size_Clause (gnat_array))\n+      && !is_bit_packed\n       && !Has_Aliased_Components (gnat_array)\n       && !Strict_Alignment (gnat_type)\n-      && !has_packed_components\n       && RECORD_OR_UNION_TYPE_P (gnu_type)\n       && !TYPE_FAT_POINTER_P (gnu_type)\n       && tree_fits_uhwi_p (TYPE_SIZE (gnu_type)))\n     {\n       gnu_type = make_packable_type (gnu_type, false, max_align);\n       has_packed_components = true;\n     }\n+  else\n+    has_packed_components = is_bit_packed;\n \n   /* Get and validate any specified Component_Size.  */\n   gnu_comp_size\n@@ -5155,7 +5181,7 @@ gnat_to_gnu_component_type (Entity_Id gnat_array, bool definition,\n     gnu_comp_size = bitsize_unit_node;\n \n   /* Honor the component size.  This is not needed for bit-packed arrays.  */\n-  if (gnu_comp_size && !Is_Bit_Packed_Array (gnat_array))\n+  if (gnu_comp_size && !is_bit_packed)\n     {\n       tree orig_type = gnu_type;\n \n@@ -5166,7 +5192,7 @@ gnat_to_gnu_component_type (Entity_Id gnat_array, bool definition,\n \torig_type = gnu_type;\n \n       gnu_type = maybe_pad_type (gnu_type, gnu_comp_size, 0, gnat_array,\n-\t\t\t\t true, false, definition, true);\n+\t\t\t\t true, definition, true);\n \n       /* If a padding record was made, declare it now since it will never be\n \t declared otherwise.  This is necessary to ensure that its subtrees\n@@ -5193,7 +5219,7 @@ gnat_to_gnu_component_type (Entity_Id gnat_array, bool definition,\n \t    = size_binop (MAX_EXPR, TYPE_SIZE (gnu_type), bitsize_unit_node);\n \t  TYPE_PADDING_FOR_COMPONENT (gnu_type)\n \t    = maybe_pad_type (gnu_type, gnu_comp_size, 0, gnat_array,\n-\t\t\t      true, false, definition, true);\n+\t\t\t      true, definition, true);\n \t  gnu_type = TYPE_PADDING_FOR_COMPONENT (gnu_type);\n \t  create_type_decl (TYPE_NAME (gnu_type), gnu_type, true, debug_info_p,\n \t\t\t    gnat_array);\n@@ -5209,8 +5235,8 @@ gnat_to_gnu_component_type (Entity_Id gnat_array, bool definition,\n      storage order to the padding type since it is the innermost enclosing\n      aggregate type around the scalar.  */\n   if (TYPE_IS_PADDING_P (gnu_type)\n+      && !is_bit_packed\n       && Reverse_Storage_Order (gnat_array)\n-      && !Is_Bit_Packed_Array (gnat_array)\n       && Is_Scalar_Type (gnat_type))\n     gnu_type = set_reverse_storage_order_on_pad_type (gnu_type);\n \n@@ -5846,8 +5872,8 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \t    }\n \n \t  gnu_return_type = maybe_pad_type (gnu_return_type, max_return_size,\n-\t\t\t\t\t    0, gnat_subprog, false, false,\n-\t\t\t\t\t    definition, true);\n+\t\t\t\t\t    0, gnat_subprog, false, definition,\n+\t\t\t\t\t    true);\n \n \t  /* Declare it now since it will never be declared otherwise.  This\n \t     is necessary to ensure that its subtrees are properly marked.  */\n@@ -7193,7 +7219,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n       if (align > 0)\n \tgnu_field_type\n \t  = maybe_pad_type (gnu_field_type, NULL_TREE, align, gnat_field,\n-\t\t\t    false, false, definition, true);\n+\t\t\t    false, definition, true);\n       check_ok_for_atomic_type (gnu_field_type, gnat_field, false);\n     }\n \n@@ -7354,7 +7380,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n \n       orig_field_type = gnu_field_type;\n       gnu_field_type = maybe_pad_type (gnu_field_type, gnu_size, 0, gnat_field,\n-\t\t\t\t       false, false, definition, true);\n+\t\t\t\t       false, definition, true);\n \n       /* If a padding record was made, declare it now since it will never be\n \t declared otherwise.  This is necessary to ensure that its subtrees\n@@ -8959,11 +8985,11 @@ validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,\n       return NULL_TREE;\n     }\n \n-  /* If this is an integral type or a packed array type, the front-end has\n-     already verified the size, so we need not do it here (which would mean\n-     checking against the bounds).  However, if this is an aliased object,\n-     it may not be smaller than the type of the object.  */\n-  if ((INTEGRAL_TYPE_P (gnu_type) || TYPE_IS_PACKED_ARRAY_TYPE_P (gnu_type))\n+  /* If this is an integral type or a bit-packed array type, the front-end has\n+     already verified the size, so we need not do it again (which would mean\n+     checking against the bounds).  However, if this is an aliased object, it\n+     may not be smaller than the type of the object.  */\n+  if ((INTEGRAL_TYPE_P (gnu_type) || BIT_PACKED_ARRAY_TYPE_P (gnu_type))\n       && !(kind == VAR_DECL && Is_Aliased (gnat_object)))\n     return size;\n \n@@ -9061,16 +9087,13 @@ set_rm_size (Uint uint_size, tree gnu_type, Entity_Id gnat_entity)\n \n   /* Issue an error either if the old size of the object isn't a constant or\n      if the new size is smaller than it.  The front-end has already verified\n-     this for scalar and packed array types.  */\n+     this for scalar and bit-packed array types.  */\n   if (TREE_CODE (old_size) != INTEGER_CST\n       || TREE_OVERFLOW (old_size)\n       || (AGGREGATE_TYPE_P (gnu_type)\n-\t  && !(TREE_CODE (gnu_type) == ARRAY_TYPE\n-\t       && TYPE_PACKED_ARRAY_TYPE_P (gnu_type))\n+\t  && !BIT_PACKED_ARRAY_TYPE_P (gnu_type)\n \t  && !(TYPE_IS_PADDING_P (gnu_type)\n-\t       && TREE_CODE (TREE_TYPE (TYPE_FIELDS (gnu_type))) == ARRAY_TYPE\n-\t       && TYPE_PACKED_ARRAY_TYPE_P\n-\t\t  (TREE_TYPE (TYPE_FIELDS (gnu_type))))\n+\t       && BIT_PACKED_ARRAY_TYPE_P (TREE_TYPE (TYPE_FIELDS (gnu_type))))\n \t  && tree_int_cst_lt (size, old_size)))\n     {\n       if (Present (gnat_attr_node))\n@@ -10025,39 +10048,43 @@ copy_and_substitute_in_layout (Entity_Id gnat_new_type,\n       gnat_to_gnu_entity (Etype (gnat_field), NULL_TREE, false);\n }\n \n-/* Associate to GNU_TYPE, the translation of GNAT_ENTITY, which is\n-   the implementation type of a packed array type (Is_Packed_Array_Impl_Type),\n-   the original array type if it has been translated.  This association is a\n-   parallel type for GNAT encodings or a debug type for standard DWARF.  Note\n-   that for standard DWARF, we also want to get the original type name.  */\n+/* Associate to the implementation type of a packed array type specified by\n+   GNU_TYPE, which is the translation of GNAT_ENTITY, the original array type\n+   if it has been translated.  This association is a parallel type for GNAT\n+   encodings or a debug type for standard DWARF.  Note that for standard DWARF,\n+   we also want to get the original type name and therefore we return it.  */\n \n-static void\n+static tree\n associate_original_type_to_packed_array (tree gnu_type, Entity_Id gnat_entity)\n {\n-  Entity_Id gnat_original_array_type\n+  const Entity_Id gnat_original_array_type\n     = Underlying_Type (Original_Array_Type (gnat_entity));\n   tree gnu_original_array_type;\n \n   if (!present_gnu_tree (gnat_original_array_type))\n-    return;\n+    return NULL_TREE;\n \n   gnu_original_array_type = gnat_to_gnu_type (gnat_original_array_type);\n \n   if (TYPE_IS_DUMMY_P (gnu_original_array_type))\n-    return;\n+    return NULL_TREE;\n+\n+  gcc_assert (TYPE_IMPL_PACKED_ARRAY_P (gnu_type));\n \n   if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n     {\n-      tree original_name = TYPE_NAME (gnu_original_array_type);\n+      SET_TYPE_ORIGINAL_PACKED_ARRAY (gnu_type, gnu_original_array_type);\n \n+      tree original_name = TYPE_NAME (gnu_original_array_type);\n       if (TREE_CODE (original_name) == TYPE_DECL)\n \toriginal_name = DECL_NAME (original_name);\n-\n-      SET_TYPE_ORIGINAL_PACKED_ARRAY (gnu_type, gnu_original_array_type);\n-      TYPE_NAME (gnu_type) = original_name;\n+      return original_name;\n     }\n   else\n-    add_parallel_type (gnu_type, gnu_original_array_type);\n+    {\n+      add_parallel_type (gnu_type, gnu_original_array_type);\n+      return NULL_TREE;\n+    }\n }\n \f\n /* Given a type T, a FIELD_DECL F, and a replacement value R, return an"}, {"sha": "1adf62789ac16016d2c591f14b4f86c62c3f7d0e", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e3cabd45d499652abc3bfe28f82a363ed70390d/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e3cabd45d499652abc3bfe28f82a363ed70390d/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=1e3cabd45d499652abc3bfe28f82a363ed70390d", "patch": "@@ -138,14 +138,12 @@ extern tree make_type_from_size (tree type, tree size_tree, bool for_biased);\n    if needed.  We have already verified that SIZE and ALIGN are large enough.\n    GNAT_ENTITY is used to name the resulting record and to issue a warning.\n    IS_COMPONENT_TYPE is true if this is being done for the component type of\n-   an array.  IS_USER_TYPE is true if the original type needs to be completed.\n-   DEFINITION is true if this type is being defined.  SET_RM_SIZE is true if\n-   the RM size of the resulting type is to be set to SIZE too; in this case,\n-   the padded type is canonicalized before being returned.  */\n+   an array.  DEFINITION is true if this type is being defined.  SET_RM_SIZE\n+   is true if the RM size of the resulting type is to be set to SIZE too; in\n+   this case, the padded type is canonicalized before being returned.  */\n extern tree maybe_pad_type (tree type, tree size, unsigned int align,\n \t\t\t    Entity_Id gnat_entity, bool is_component_type,\n-\t\t\t    bool is_user_type, bool definition,\n-\t\t\t    bool set_rm_size);\n+\t\t\t    bool definition, bool set_rm_size);\n \n /* Return true if padded TYPE was built with an RM size.  */\n extern bool pad_type_has_rm_size (tree type);"}, {"sha": "0867125b2fba162997f9a644eaabee2663184299", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 44, "deletions": 56, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e3cabd45d499652abc3bfe28f82a363ed70390d/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e3cabd45d499652abc3bfe28f82a363ed70390d/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=1e3cabd45d499652abc3bfe28f82a363ed70390d", "patch": "@@ -602,20 +602,10 @@ gnat_enum_underlying_base_type (const_tree)\n static tree\n gnat_get_debug_type (const_tree type)\n {\n-  if (TYPE_CAN_HAVE_DEBUG_TYPE_P (type) && TYPE_DEBUG_TYPE (type))\n-    {\n-      type = TYPE_DEBUG_TYPE (type);\n-\n-      /* ??? The get_debug_type language hook is processed after the array\n-\t descriptor language hook, so if there is an array behind this type,\n-\t the latter is supposed to handle it.  Still, we can get here with\n-\t a type we are not supposed to handle (e.g. when the DWARF back-end\n-\t processes the type of a variable), so keep this guard.  */\n-      if (type && TYPE_CAN_HAVE_DEBUG_TYPE_P (type))\n-\treturn const_cast<tree> (type);\n-    }\n-\n-  return NULL_TREE;\n+  if (TYPE_CAN_HAVE_DEBUG_TYPE_P (type))\n+    return TYPE_DEBUG_TYPE (type);\n+  else\n+    return NULL_TREE;\n }\n \n /* Provide information in INFO for debugging output about the TYPE fixed-point\n@@ -650,14 +640,14 @@ gnat_get_fixed_point_type_info (const_tree type,\n \n   if (TREE_CODE (scale_factor) == RDIV_EXPR)\n     {\n-      const tree num = TREE_OPERAND (scale_factor, 0);\n-      const tree den = TREE_OPERAND (scale_factor, 1);\n+      tree num = TREE_OPERAND (scale_factor, 0);\n+      tree den = TREE_OPERAND (scale_factor, 1);\n \n       /* See if we have a binary or decimal scale.  */\n       if (TREE_CODE (den) == POWER_EXPR)\n \t{\n-\t  const tree base = TREE_OPERAND (den, 0);\n-\t  const tree exponent = TREE_OPERAND (den, 1);\n+\t  tree base = TREE_OPERAND (den, 0);\n+\t  tree exponent = TREE_OPERAND (den, 1);\n \n \t  /* We expect the scale factor to be 1 / 2 ** N or 1 / 10 ** N.  */\n \t  gcc_assert (num == integer_one_node\n@@ -786,14 +776,9 @@ static bool\n gnat_get_array_descr_info (const_tree const_type,\n \t\t\t   struct array_descr_info *info)\n {\n-  bool convention_fortran_p;\n-  bool is_array = false;\n-  bool is_fat_ptr = false;\n-  bool is_packed_array = false;\n   tree type = const_cast<tree> (const_type);\n-  const_tree first_dimen = NULL_TREE;\n-  const_tree last_dimen = NULL_TREE;\n-  const_tree dimen;\n+  tree first_dimen, dimen;\n+  bool is_packed_array, is_array, is_fat_ptr;\n   int i;\n \n   /* Temporaries created in the first pass and used in the second one for thin\n@@ -803,16 +788,15 @@ gnat_get_array_descr_info (const_tree const_type,\n   tree thinptr_template_expr = NULL_TREE;\n   tree thinptr_bound_field = NULL_TREE;\n \n-  /* ??? See gnat_get_debug_type.  */\n-  type = maybe_debug_type (type);\n-\n   /* If we have an implementation type for a packed array, get the orignial\n      array type.  */\n   if (TYPE_IMPL_PACKED_ARRAY_P (type) && TYPE_ORIGINAL_PACKED_ARRAY (type))\n     {\n       type = TYPE_ORIGINAL_PACKED_ARRAY (type);\n       is_packed_array = true;\n     }\n+  else\n+    is_packed_array = false;\n \n   /* First pass: gather all information about this array except everything\n      related to dimensions.  */\n@@ -823,25 +807,27 @@ gnat_get_array_descr_info (const_tree const_type,\n       && TYPE_INDEX_TYPE (TYPE_DOMAIN (type)))\n     {\n       is_array = true;\n+      is_fat_ptr = false;\n       first_dimen = type;\n       info->data_location = NULL_TREE;\n     }\n \n   else if (TYPE_IS_FAT_POINTER_P (type)\n \t   && gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n     {\n-      const tree ua_type = TYPE_UNCONSTRAINED_ARRAY (type);\n+      tree ua_type = TYPE_UNCONSTRAINED_ARRAY (type);\n \n       /* This will be our base object address.  */\n-      const tree placeholder_expr = build0 (PLACEHOLDER_EXPR, type);\n+      tree placeholder_expr = build0 (PLACEHOLDER_EXPR, type);\n \n       /* We assume below that maybe_unconstrained_array returns an INDIRECT_REF\n \t node.  */\n-      const tree ua_val\n+      tree ua_val\n         = maybe_unconstrained_array (build_unary_op (INDIRECT_REF,\n \t\t\t\t\t\t     ua_type,\n \t\t\t\t\t\t     placeholder_expr));\n \n+      is_array = false;\n       is_fat_ptr = true;\n       first_dimen = TREE_TYPE (ua_val);\n \n@@ -861,24 +847,26 @@ gnat_get_array_descr_info (const_tree const_type,\n       /* This will be our base object address.  Note that we assume that\n \t pointers to these will actually point to the array field (thin\n \t pointers are shifted).  */\n-      const tree placeholder_expr = build0 (PLACEHOLDER_EXPR, type);\n-      const tree placeholder_addr\n-        = build_unary_op (ADDR_EXPR, NULL_TREE, placeholder_expr);\n+      tree placeholder_expr = build0 (PLACEHOLDER_EXPR, type);\n+      tree placeholder_addr\n+\t= build_unary_op (ADDR_EXPR, NULL_TREE, placeholder_expr);\n \n-      const tree bounds_field = TYPE_FIELDS (type);\n-      const tree bounds_type = TREE_TYPE (bounds_field);\n-      const tree array_field = DECL_CHAIN (bounds_field);\n-      const tree array_type = TREE_TYPE (array_field);\n+      tree bounds_field = TYPE_FIELDS (type);\n+      tree bounds_type = TREE_TYPE (bounds_field);\n+      tree array_field = DECL_CHAIN (bounds_field);\n+      tree array_type = TREE_TYPE (array_field);\n \n       /* Shift the thin pointer address to get the address of the template.  */\n-      const tree shift_amount\n+      tree shift_amount\n \t= fold_build1 (NEGATE_EXPR, sizetype, byte_position (array_field));\n       tree template_addr\n \t= build_binary_op (POINTER_PLUS_EXPR, TREE_TYPE (placeholder_addr),\n \t\t\t   placeholder_addr, shift_amount);\n       template_addr\n \t= fold_convert (TYPE_POINTER_TO (bounds_type), template_addr);\n \n+      is_array = false;\n+      is_fat_ptr = false;\n       first_dimen = array_type;\n \n       /* The thin pointer is already the pointer to the array data, so there's\n@@ -890,35 +878,37 @@ gnat_get_array_descr_info (const_tree const_type,\n \t\t\t\t\t      template_addr);\n       thinptr_bound_field = TYPE_FIELDS (bounds_type);\n     }\n+\n   else\n     return false;\n \n   /* Second pass: compute the remaining information: dimensions and\n      corresponding bounds.  */\n \n-  if (TYPE_PACKED (first_dimen))\n-    is_packed_array = true;\n   /* If this array has fortran convention, it's arranged in column-major\n      order, so our view here has reversed dimensions.  */\n-  convention_fortran_p = TYPE_CONVENTION_FORTRAN_P (first_dimen);\n+  const bool convention_fortran_p = TYPE_CONVENTION_FORTRAN_P (first_dimen);\n+\n+  if (TYPE_PACKED (first_dimen))\n+    is_packed_array = true;\n+\n   /* ??? For row major ordering, we probably want to emit nothing and\n      instead specify it as the default in Dw_TAG_compile_unit.  */\n   info->ordering = (convention_fortran_p\n \t\t    ? array_descr_ordering_column_major\n \t\t    : array_descr_ordering_row_major);\n+  info->rank = NULL_TREE;\n \n-  /* Count how many dimensions this array has.  */\n-  for (i = 0, dimen = first_dimen; ; ++i, dimen = TREE_TYPE (dimen))\n+  /* Count the number of dimensions and determine the element type.  */\n+  i = 1;\n+  dimen = TREE_TYPE (first_dimen);\n+  while (TREE_CODE (dimen) == ARRAY_TYPE && TYPE_MULTI_ARRAY_P (dimen))\n     {\n-      if (i > 0\n-\t  && (TREE_CODE (dimen) != ARRAY_TYPE\n-\t      || !TYPE_MULTI_ARRAY_P (dimen)))\n-\tbreak;\n-      last_dimen = dimen;\n+      i++;\n+      dimen = TREE_TYPE (dimen);\n     }\n-\n   info->ndimensions = i;\n-  info->rank = NULL_TREE;\n+  info->element_type = dimen;\n \n   /* Too many dimensions?  Give up generating proper description: yield instead\n      nested arrays.  Note that in this case, this hook is invoked once on each\n@@ -928,12 +918,10 @@ gnat_get_array_descr_info (const_tree const_type,\n       || TYPE_MULTI_ARRAY_P (first_dimen))\n     {\n       info->ndimensions = 1;\n-      last_dimen = first_dimen;\n+      info->element_type = TREE_TYPE (first_dimen);\n     }\n \n-  info->element_type = TREE_TYPE (last_dimen);\n-\n-  /* Now iterate over all dimensions in source-order and fill the info\n+  /* Now iterate over all dimensions in source order and fill the info\n      structure.  */\n   for (i = (convention_fortran_p ? info->ndimensions - 1 : 0),\n        dimen = first_dimen;\n@@ -1186,7 +1174,7 @@ must_pass_by_ref (tree gnu_type)\n void\n enumerate_modes (void (*f) (const char *, int, int, int, int, int, int, int))\n {\n-  const tree c_types[]\n+  tree const c_types[]\n     = { float_type_node, double_type_node, long_double_type_node };\n   const char *const c_names[]\n     = { \"float\", \"double\", \"long double\" };"}, {"sha": "1b320f5c629d2b2b306f66d969894befa08fbef1", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 17, "deletions": 35, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e3cabd45d499652abc3bfe28f82a363ed70390d/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e3cabd45d499652abc3bfe28f82a363ed70390d/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=1e3cabd45d499652abc3bfe28f82a363ed70390d", "patch": "@@ -1332,9 +1332,9 @@ make_type_from_size (tree type, tree size_tree, bool for_biased)\n       if (size == 0)\n \tsize = 1;\n \n-      /* Only do something if the type isn't a packed array type and doesn't\n-\t already have the proper size and the size isn't too large.  */\n-      if (TYPE_IS_PACKED_ARRAY_TYPE_P (type)\n+      /* Only do something if the type is not a bit-packed array type and does\n+\t not already have the proper size and the size is not too large.  */\n+      if (BIT_PACKED_ARRAY_TYPE_P (type)\n \t  || (TYPE_PRECISION (type) == size && biased_p == for_biased)\n \t  || size > LONG_LONG_TYPE_SIZE)\n \tbreak;\n@@ -1457,15 +1457,14 @@ canonicalize_pad_type (tree type)\n    if needed.  We have already verified that SIZE and ALIGN are large enough.\n    GNAT_ENTITY is used to name the resulting record and to issue a warning.\n    IS_COMPONENT_TYPE is true if this is being done for the component type of\n-   an array.  IS_USER_TYPE is true if the original type needs to be completed.\n-   DEFINITION is true if this type is being defined.  SET_RM_SIZE is true if\n-   the RM size of the resulting type is to be set to SIZE too; in this case,\n-   the padded type is canonicalized before being returned.  */\n+   an array.  DEFINITION is true if this type is being defined.  SET_RM_SIZE\n+   is true if the RM size of the resulting type is to be set to SIZE too; in\n+   this case, the padded type is canonicalized before being returned.  */\n \n tree\n maybe_pad_type (tree type, tree size, unsigned int align,\n \t\tEntity_Id gnat_entity, bool is_component_type,\n-\t\tbool is_user_type, bool definition, bool set_rm_size)\n+\t\tbool definition, bool set_rm_size)\n {\n   tree orig_size = TYPE_SIZE (type);\n   unsigned int orig_align = TYPE_ALIGN (type);\n@@ -1509,31 +1508,13 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n   if (align == 0 && !size)\n     return type;\n \n-  /* If requested, complete the original type and give it a name.  */\n-  if (is_user_type)\n-    create_type_decl (get_entity_name (gnat_entity), type,\n-\t\t      !Comes_From_Source (gnat_entity),\n-\t\t      !(TYPE_NAME (type)\n-\t\t\t&& TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n-\t\t\t&& DECL_IGNORED_P (TYPE_NAME (type))),\n-\t\t      gnat_entity);\n-\n   /* We used to modify the record in place in some cases, but that could\n      generate incorrect debugging information.  So make a new record\n      type and name.  */\n   record = make_node (RECORD_TYPE);\n   TYPE_PADDING_P (record) = 1;\n \n-  /* ??? Padding types around packed array implementation types will be\n-     considered as root types in the array descriptor language hook (see\n-     gnat_get_array_descr_info). Give them the original packed array type\n-     name so that the one coming from sources appears in the debugging\n-     information.  */\n-  if (TYPE_IMPL_PACKED_ARRAY_P (type)\n-      && TYPE_ORIGINAL_PACKED_ARRAY (type)\n-      && gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n-    TYPE_NAME (record) = TYPE_NAME (TYPE_ORIGINAL_PACKED_ARRAY (type));\n-  else if (Present (gnat_entity))\n+  if (Present (gnat_entity))\n     TYPE_NAME (record) = create_concat_name (gnat_entity, \"PAD\");\n \n   SET_TYPE_ALIGN (record, align ? align : orig_align);\n@@ -1601,6 +1582,7 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n \t}\n     }\n \n+  /* Make the inner type the debug type of the padded type.  */\n   if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n     SET_TYPE_DEBUG_TYPE (record, maybe_debug_type (type));\n \n@@ -3229,7 +3211,7 @@ compute_deferred_decl_context (Entity_Id gnat_scope)\n \n   if (TREE_CODE (context) == TYPE_DECL)\n     {\n-      const tree context_type = TREE_TYPE (context);\n+      tree context_type = TREE_TYPE (context);\n \n       /* Skip dummy types: only the final ones can appear in the context\n \t chain.  */\n@@ -4875,7 +4857,7 @@ convert (tree type, tree expr)\n \t   && smaller_form_type_p (etype, type))\n     {\n       expr = convert (maybe_pad_type (etype, TYPE_SIZE (type), 0, Empty,\n-\t\t\t\t      false, false, false, true),\n+\t\t\t\t      false, false, true),\n \t\t      expr);\n       return build1 (VIEW_CONVERT_EXPR, type, expr);\n     }\n@@ -5495,14 +5477,14 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n       if (c < 0)\n \t{\n \t  expr = convert (maybe_pad_type (etype, TYPE_SIZE (type), 0, Empty,\n-\t\t\t\t\t  false, false, false, true),\n+\t\t\t\t\t  false, false, true),\n \t\t\t  expr);\n \t  expr = unchecked_convert (type, expr, notrunc_p);\n \t}\n       else\n \t{\n \t  tree rec_type = maybe_pad_type (type, TYPE_SIZE (etype), 0, Empty,\n-\t\t\t\t\t  false, false, false, true);\n+\t\t\t\t\t  false, false, true);\n \t  expr = unchecked_convert (rec_type, expr, notrunc_p);\n \t  expr = build_component_ref (expr, TYPE_FIELDS (rec_type), false);\n \t}\n@@ -5520,14 +5502,14 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n       if (c < 0)\n \t{\n \t  expr = convert (maybe_pad_type (etype, new_size, 0, Empty,\n-\t\t\t\t\t  false, false, false, true),\n+\t\t\t\t\t  false, false, true),\n \t\t\t  expr);\n \t  expr = unchecked_convert (type, expr, notrunc_p);\n \t}\n       else\n \t{\n \t  tree rec_type = maybe_pad_type (type, TYPE_SIZE (etype), 0, Empty,\n-\t\t\t\t\t  false, false, false, true);\n+\t\t\t\t\t  false, false, true);\n \t  expr = unchecked_convert (rec_type, expr, notrunc_p);\n \t  expr = build_component_ref (expr, TYPE_FIELDS (rec_type), false);\n \t}\n@@ -5572,7 +5554,7 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n \t   && TYPE_ALIGN (etype) < TYPE_ALIGN (type))\n     {\n       expr = convert (maybe_pad_type (etype, NULL_TREE, TYPE_ALIGN (type),\n-\t\t\t\t      Empty, false, false, false, true),\n+\t\t\t\t      Empty, false, false, true),\n \t\t      expr);\n       return unchecked_convert (type, expr, notrunc_p);\n     }\n@@ -5589,7 +5571,7 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n \t       || tree_int_cst_lt (TYPE_SIZE (etype), TYPE_SIZE (type))))\n     {\n       expr = convert (maybe_pad_type (etype, TYPE_SIZE (type), 0,\n-\t\t\t\t      Empty, false, false, false, true),\n+\t\t\t\t      Empty, false, false, true),\n \t\t      expr);\n       return unchecked_convert (type, expr, notrunc_p);\n     }"}, {"sha": "edbb8161fea1c3a81cef594fd0d25f1eabc770f9", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e3cabd45d499652abc3bfe28f82a363ed70390d/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e3cabd45d499652abc3bfe28f82a363ed70390d/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=1e3cabd45d499652abc3bfe28f82a363ed70390d", "patch": "@@ -2927,7 +2927,7 @@ is_simple_additive_expression (tree expr, tree *add, tree *cst, bool *minus_p)\n tree\n gnat_invariant_expr (tree expr)\n {\n-  const tree type = TREE_TYPE (expr);\n+  tree type = TREE_TYPE (expr);\n   tree add, cst;\n   bool minus_p;\n "}]}