{"sha": "50ed9cea9d0b76c02e87d9c9c2643f43f25eed10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBlZDljZWE5ZDBiNzZjMDJlODdkOWM5YzI2NDNmNDNmMjVlZWQxMA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-08-19T17:02:03Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-08-19T17:02:03Z"}, "message": "arm.c (arm_gen_load_multiple): Use adjust_automodify_address.\n\n        * config/arm/arm.c (arm_gen_load_multiple): Use\n        adjust_automodify_address.  Take base memory and offset instead\n        of unchanging/struct/scalar bits.\n        (arm_gen_store_multiple): Likewise.\n        (arm_gen_movmemqi): Use adjust_automodify_address.\n        * config/arm/arm-protos.h: Update decls.\n        * config/arm/arm.md (load_multiple): Update arm_gen_load_multiple call.\n        (store_multiple): Similarly.\n\nFrom-SVN: r86257", "tree": {"sha": "38652e7a970e34ba4e2923e6923759a3cfa83697", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38652e7a970e34ba4e2923e6923759a3cfa83697"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50ed9cea9d0b76c02e87d9c9c2643f43f25eed10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50ed9cea9d0b76c02e87d9c9c2643f43f25eed10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50ed9cea9d0b76c02e87d9c9c2643f43f25eed10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50ed9cea9d0b76c02e87d9c9c2643f43f25eed10/comments", "author": null, "committer": null, "parents": [{"sha": "ec53454bff00bb25f035e7cd2b96f934af1530ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec53454bff00bb25f035e7cd2b96f934af1530ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec53454bff00bb25f035e7cd2b96f934af1530ff"}], "stats": {"total": 183, "additions": 84, "deletions": 99}, "files": [{"sha": "bca0f90125c3419711981ace6be0c55f95766e64", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ed9cea9d0b76c02e87d9c9c2643f43f25eed10/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ed9cea9d0b76c02e87d9c9c2643f43f25eed10/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=50ed9cea9d0b76c02e87d9c9c2643f43f25eed10", "patch": "@@ -1,3 +1,14 @@\n+2004-08-19  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/arm/arm.c (arm_gen_load_multiple): Use\n+\tadjust_automodify_address.  Take base memory and offset instead\n+\tof unchanging/struct/scalar bits.\n+\t(arm_gen_store_multiple): Likewise.\n+\t(arm_gen_movmemqi): Use adjust_automodify_address.\n+\t* config/arm/arm-protos.h: Update decls.\n+\t* config/arm/arm.md (load_multiple): Update arm_gen_load_multiple call.\n+\t(store_multiple): Similarly.\n+\n 2004-08-19  J\"orn Rennecke <joern.rennecke@superh.com>\n \n \t* regclass.c (globalize_reg): Update call_really_used_regs."}, {"sha": "b2a29a506a4f41d635f47916cf178754c1f1840b", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ed9cea9d0b76c02e87d9c9c2643f43f25eed10/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ed9cea9d0b76c02e87d9c9c2643f43f25eed10/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=50ed9cea9d0b76c02e87d9c9c2643f43f25eed10", "patch": "@@ -116,8 +116,10 @@ extern int load_multiple_sequence (rtx *, int, int *, int *, HOST_WIDE_INT *);\n extern const char *emit_ldm_seq (rtx *, int);\n extern int store_multiple_sequence (rtx *, int, int *, int *, HOST_WIDE_INT *);\n extern const char * emit_stm_seq (rtx *, int);\n-extern rtx arm_gen_load_multiple (int, int, rtx, int, int, int, int, int);\n-extern rtx arm_gen_store_multiple (int, int, rtx, int, int, int, int, int);\n+extern rtx arm_gen_load_multiple (int, int, rtx, int, int,\n+\t\t\t\t  rtx, HOST_WIDE_INT *);\n+extern rtx arm_gen_store_multiple (int, int, rtx, int, int,\n+\t\t\t\t   rtx, HOST_WIDE_INT *);\n extern int arm_gen_movmemqi (rtx *);\n extern rtx arm_gen_rotated_half_load (rtx);\n extern enum machine_mode arm_select_cc_mode (RTX_CODE, rtx, rtx);"}, {"sha": "19a63bfcfc3a69046356731d72f47c56de68d49e", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 59, "deletions": 85, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ed9cea9d0b76c02e87d9c9c2643f43f25eed10/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ed9cea9d0b76c02e87d9c9c2643f43f25eed10/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=50ed9cea9d0b76c02e87d9c9c2643f43f25eed10", "patch": "@@ -6118,13 +6118,13 @@ multi_register_push (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n \n rtx\n arm_gen_load_multiple (int base_regno, int count, rtx from, int up,\n-\t\t       int write_back, int unchanging_p, int in_struct_p,\n-\t\t       int scalar_p)\n+\t\t       int write_back, rtx basemem, HOST_WIDE_INT *offsetp)\n {\n+  HOST_WIDE_INT offset = *offsetp;\n   int i = 0, j;\n   rtx result;\n   int sign = up ? 1 : -1;\n-  rtx mem;\n+  rtx mem, addr;\n \n   /* XScale has load-store double instructions, but they have stricter\n      alignment requirements than load-store multiple, so we cannot\n@@ -6162,15 +6162,17 @@ arm_gen_load_multiple (int base_regno, int count, rtx from, int up,\n       \n       for (i = 0; i < count; i++)\n \t{\n-\t  mem = gen_rtx_MEM (SImode, plus_constant (from, i * 4 * sign));\n-\t  MEM_READONLY_P (mem) = unchanging_p;\n-\t  MEM_IN_STRUCT_P (mem) = in_struct_p;\n-\t  MEM_SCALAR_P (mem) = scalar_p;\n+\t  addr = plus_constant (from, i * 4 * sign);\n+\t  mem = adjust_automodify_address (basemem, SImode, addr, offset);\n \t  emit_move_insn (gen_rtx_REG (SImode, base_regno + i), mem);\n+\t  offset += 4 * sign;\n \t}\n \n       if (write_back)\n-\temit_move_insn (from, plus_constant (from, count * 4 * sign));\n+\t{\n+\t  emit_move_insn (from, plus_constant (from, count * 4 * sign));\n+\t  *offsetp = offset;\n+\t}\n \n       seq = get_insns ();\n       end_sequence ();\n@@ -6191,26 +6193,28 @@ arm_gen_load_multiple (int base_regno, int count, rtx from, int up,\n \n   for (j = 0; i < count; i++, j++)\n     {\n-      mem = gen_rtx_MEM (SImode, plus_constant (from, j * 4 * sign));\n-      MEM_READONLY_P (mem) = unchanging_p;\n-      MEM_IN_STRUCT_P (mem) = in_struct_p;\n-      MEM_SCALAR_P (mem) = scalar_p;\n+      addr = plus_constant (from, j * 4 * sign);\n+      mem = adjust_automodify_address_nv (basemem, SImode, addr, offset);\n       XVECEXP (result, 0, i)\n \t= gen_rtx_SET (VOIDmode, gen_rtx_REG (SImode, base_regno + j), mem);\n+      offset += 4 * sign;\n     }\n \n+  if (write_back)\n+    *offsetp = offset;\n+\n   return result;\n }\n \n rtx\n arm_gen_store_multiple (int base_regno, int count, rtx to, int up,\n-\t\t\tint write_back, int unchanging_p, int in_struct_p,\n-\t\t\tint scalar_p)\n+\t\t\tint write_back, rtx basemem, HOST_WIDE_INT *offsetp)\n {\n+  HOST_WIDE_INT offset = *offsetp;\n   int i = 0, j;\n   rtx result;\n   int sign = up ? 1 : -1;\n-  rtx mem;\n+  rtx mem, addr;\n \n   /* See arm_gen_load_multiple for discussion of\n      the pros/cons of ldm/stm usage for XScale.  */\n@@ -6222,15 +6226,17 @@ arm_gen_store_multiple (int base_regno, int count, rtx to, int up,\n       \n       for (i = 0; i < count; i++)\n \t{\n-\t  mem = gen_rtx_MEM (SImode, plus_constant (to, i * 4 * sign));\n-\t  MEM_READONLY_P (mem) = unchanging_p;\n-\t  MEM_IN_STRUCT_P (mem) = in_struct_p;\n-\t  MEM_SCALAR_P (mem) = scalar_p;\n+\t  addr = plus_constant (to, i * 4 * sign);\n+\t  mem = adjust_automodify_address (basemem, SImode, addr, offset);\n \t  emit_move_insn (mem, gen_rtx_REG (SImode, base_regno + i));\n+\t  offset += 4 * sign;\n \t}\n \n       if (write_back)\n-\temit_move_insn (to, plus_constant (to, count * 4 * sign));\n+\t{\n+\t  emit_move_insn (to, plus_constant (to, count * 4 * sign));\n+\t  *offsetp = offset;\n+\t}\n \n       seq = get_insns ();\n       end_sequence ();\n@@ -6251,52 +6257,45 @@ arm_gen_store_multiple (int base_regno, int count, rtx to, int up,\n \n   for (j = 0; i < count; i++, j++)\n     {\n-      mem = gen_rtx_MEM (SImode, plus_constant (to, j * 4 * sign));\n-      MEM_READONLY_P (mem) = unchanging_p;\n-      MEM_IN_STRUCT_P (mem) = in_struct_p;\n-      MEM_SCALAR_P (mem) = scalar_p;\n-\n+      addr = plus_constant (to, j * 4 * sign);\n+      mem = adjust_automodify_address_nv (basemem, SImode, addr, offset);\n       XVECEXP (result, 0, i)\n \t= gen_rtx_SET (VOIDmode, mem, gen_rtx_REG (SImode, base_regno + j));\n+      offset += 4 * sign;\n     }\n \n+  if (write_back)\n+    *offsetp = offset;\n+\n   return result;\n }\n \n int\n arm_gen_movmemqi (rtx *operands)\n {\n   HOST_WIDE_INT in_words_to_go, out_words_to_go, last_bytes;\n+  HOST_WIDE_INT srcoffset, dstoffset;\n   int i;\n-  rtx src, dst;\n-  rtx st_src, st_dst, fin_src, fin_dst;\n+  rtx src, dst, srcbase, dstbase;\n   rtx part_bytes_reg = NULL;\n   rtx mem;\n-  int dst_unchanging_p, dst_in_struct_p, src_unchanging_p, src_in_struct_p;\n-  int dst_scalar_p, src_scalar_p;\n \n   if (GET_CODE (operands[2]) != CONST_INT\n       || GET_CODE (operands[3]) != CONST_INT\n       || INTVAL (operands[2]) > 64\n       || INTVAL (operands[3]) & 3)\n     return 0;\n \n-  st_dst = XEXP (operands[0], 0);\n-  st_src = XEXP (operands[1], 0);\n+  dstbase = operands[0];\n+  srcbase = operands[1];\n \n-  dst_unchanging_p = MEM_READONLY_P (operands[0]);\n-  dst_in_struct_p = MEM_IN_STRUCT_P (operands[0]);\n-  dst_scalar_p = MEM_SCALAR_P (operands[0]);\n-  src_unchanging_p = MEM_READONLY_P (operands[1]);\n-  src_in_struct_p = MEM_IN_STRUCT_P (operands[1]);\n-  src_scalar_p = MEM_SCALAR_P (operands[1]);\n-\n-  fin_dst = dst = copy_to_mode_reg (SImode, st_dst);\n-  fin_src = src = copy_to_mode_reg (SImode, st_src);\n+  dst = copy_to_mode_reg (SImode, XEXP (dstbase, 0));\n+  src = copy_to_mode_reg (SImode, XEXP (srcbase, 0));\n \n   in_words_to_go = ARM_NUM_INTS (INTVAL (operands[2]));\n   out_words_to_go = INTVAL (operands[2]) / 4;\n   last_bytes = INTVAL (operands[2]) & 3;\n+  dstoffset = srcoffset = 0;\n \n   if (out_words_to_go != in_words_to_go && ((in_words_to_go - 1) & 3) != 0)\n     part_bytes_reg = gen_rtx_REG (SImode, (in_words_to_go - 1) & 3);\n@@ -6305,38 +6304,31 @@ arm_gen_movmemqi (rtx *operands)\n     {\n       if (in_words_to_go > 4)\n \temit_insn (arm_gen_load_multiple (0, 4, src, TRUE, TRUE,\n-\t\t\t\t\t  src_unchanging_p,\n-\t\t\t\t\t  src_in_struct_p,\n-\t\t\t\t\t  src_scalar_p));\n+\t\t\t\t\t  srcbase, &srcoffset));\n       else\n \temit_insn (arm_gen_load_multiple (0, in_words_to_go, src, TRUE, \n-\t\t\t\t\t  FALSE, src_unchanging_p,\n-\t\t\t\t\t  src_in_struct_p, src_scalar_p));\n+\t\t\t\t\t  FALSE, srcbase, &srcoffset));\n \n       if (out_words_to_go)\n \t{\n \t  if (out_words_to_go > 4)\n \t    emit_insn (arm_gen_store_multiple (0, 4, dst, TRUE, TRUE,\n-\t\t\t\t\t       dst_unchanging_p,\n-\t\t\t\t\t       dst_in_struct_p,\n-\t\t\t\t\t       dst_scalar_p));\n+\t\t\t\t\t       dstbase, &dstoffset));\n \t  else if (out_words_to_go != 1)\n \t    emit_insn (arm_gen_store_multiple (0, out_words_to_go,\n \t\t\t\t\t       dst, TRUE, \n \t\t\t\t\t       (last_bytes == 0\n \t\t\t\t\t\t? FALSE : TRUE),\n-\t\t\t\t\t       dst_unchanging_p,\n-\t\t\t\t\t       dst_in_struct_p,\n-\t\t\t\t\t       dst_scalar_p));\n+\t\t\t\t\t       dstbase, &dstoffset));\n \t  else\n \t    {\n-\t      mem = gen_rtx_MEM (SImode, dst);\n-\t      MEM_READONLY_P (mem) = dst_unchanging_p;\n-\t      MEM_IN_STRUCT_P (mem) = dst_in_struct_p;\n-\t      MEM_SCALAR_P (mem) = dst_scalar_p;\n+\t      mem = adjust_automodify_address (dstbase, SImode, dst, dstoffset);\n \t      emit_move_insn (mem, gen_rtx_REG (SImode, 0));\n \t      if (last_bytes != 0)\n-\t\temit_insn (gen_addsi3 (dst, dst, GEN_INT (4)));\n+\t\t{\n+\t\t  emit_insn (gen_addsi3 (dst, dst, GEN_INT (4)));\n+\t\t  dstoffset += 4;\n+\t\t}\n \t    }\n \t}\n \n@@ -6349,19 +6341,11 @@ arm_gen_movmemqi (rtx *operands)\n     {\n       rtx sreg;\n       \n-      mem = gen_rtx_MEM (SImode, src);\n-      MEM_READONLY_P (mem) = src_unchanging_p;\n-      MEM_IN_STRUCT_P (mem) = src_in_struct_p;\n-      MEM_SCALAR_P (mem) = src_scalar_p;\n-      emit_move_insn (sreg = gen_reg_rtx (SImode), mem);\n-      emit_move_insn (fin_src = gen_reg_rtx (SImode), plus_constant (src, 4));\n-      \n-      mem = gen_rtx_MEM (SImode, dst);\n-      MEM_READONLY_P (mem) = dst_unchanging_p;\n-      MEM_IN_STRUCT_P (mem) = dst_in_struct_p;\n-      MEM_SCALAR_P (mem) = dst_scalar_p;\n+      mem = adjust_automodify_address (srcbase, SImode, src, srcoffset);\n+      sreg = copy_to_reg (mem);\n+\n+      mem = adjust_automodify_address (dstbase, SImode, dst, dstoffset);\n       emit_move_insn (mem, sreg);\n-      emit_move_insn (fin_dst = gen_reg_rtx (SImode), plus_constant (dst, 4));\n       in_words_to_go--;\n       \n       if (in_words_to_go)\t/* Sanity check */\n@@ -6373,10 +6357,7 @@ arm_gen_movmemqi (rtx *operands)\n       if (in_words_to_go < 0)\n \tabort ();\n \n-      mem = gen_rtx_MEM (SImode, src);\n-      MEM_READONLY_P (mem) = src_unchanging_p;\n-      MEM_IN_STRUCT_P (mem) = src_in_struct_p;\n-      MEM_SCALAR_P (mem) = src_scalar_p;\n+      mem = adjust_automodify_address (srcbase, SImode, src, srcoffset);\n       part_bytes_reg = copy_to_mode_reg (SImode, mem);\n     }\n \n@@ -6394,10 +6375,9 @@ arm_gen_movmemqi (rtx *operands)\n       \n       while (last_bytes)\n \t{\n-\t  mem = gen_rtx_MEM (QImode, plus_constant (dst, last_bytes - 1));\n-\t  MEM_READONLY_P (mem) = dst_unchanging_p;\n-\t  MEM_IN_STRUCT_P (mem) = dst_in_struct_p;\n-\t  MEM_SCALAR_P (mem) = dst_scalar_p;\n+\t  mem = adjust_automodify_address (dstbase, QImode,\n+\t\t\t\t\t   plus_constant (dst, last_bytes - 1),\n+\t\t\t\t\t   dstoffset + last_bytes - 1);\n \t  emit_move_insn (mem, gen_lowpart (QImode, part_bytes_reg));\n \n \t  if (--last_bytes)\n@@ -6413,28 +6393,22 @@ arm_gen_movmemqi (rtx *operands)\n     {\n       if (last_bytes > 1)\n \t{\n-\t  mem = gen_rtx_MEM (HImode, dst);\n-\t  MEM_READONLY_P (mem) = dst_unchanging_p;\n-\t  MEM_IN_STRUCT_P (mem) = dst_in_struct_p;\n-\t  MEM_SCALAR_P (mem) = dst_scalar_p;\n+\t  mem = adjust_automodify_address (dstbase, HImode, dst, dstoffset);\n \t  emit_move_insn (mem, gen_lowpart (HImode, part_bytes_reg));\n \t  last_bytes -= 2;\n \t  if (last_bytes)\n \t    {\n \t      rtx tmp = gen_reg_rtx (SImode);\n-\n \t      emit_insn (gen_addsi3 (dst, dst, const2_rtx));\n \t      emit_insn (gen_lshrsi3 (tmp, part_bytes_reg, GEN_INT (16)));\n \t      part_bytes_reg = tmp;\n+\t      dstoffset += 2;\n \t    }\n \t}\n       \n       if (last_bytes)\n \t{\n-\t  mem = gen_rtx_MEM (QImode, dst);\n-\t  MEM_READONLY_P (mem) = dst_unchanging_p;\n-\t  MEM_IN_STRUCT_P (mem) = dst_in_struct_p;\n-\t  MEM_SCALAR_P (mem) = dst_scalar_p;\n+\t  mem = adjust_automodify_address (dstbase, QImode, dst, dstoffset);\n \t  emit_move_insn (mem, gen_lowpart (QImode, part_bytes_reg));\n \t}\n     }"}, {"sha": "e6e72db9525641ef7f3c5e838544f001c5ae1354", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ed9cea9d0b76c02e87d9c9c2643f43f25eed10/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ed9cea9d0b76c02e87d9c9c2643f43f25eed10/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=50ed9cea9d0b76c02e87d9c9c2643f43f25eed10", "patch": "@@ -5244,7 +5244,9 @@\n                           (match_operand:SI 1 \"\" \"\"))\n                      (use (match_operand:SI 2 \"\" \"\"))])]\n   \"TARGET_ARM\"\n-  \"\n+{\n+  HOST_WIDE_INT offset = 0;\n+\n   /* Support only fixed point registers.  */\n   if (GET_CODE (operands[2]) != CONST_INT\n       || INTVAL (operands[2]) > 14\n@@ -5258,11 +5260,8 @@\n   operands[3]\n     = arm_gen_load_multiple (REGNO (operands[0]), INTVAL (operands[2]),\n \t\t\t     force_reg (SImode, XEXP (operands[1], 0)),\n-\t\t\t     TRUE, FALSE, MEM_READONLY_P (operands[1]),\n-\t\t\t     MEM_IN_STRUCT_P (operands[1]),\n-\t                     MEM_SCALAR_P (operands[1]));\n-  \"\n-)\n+\t\t\t     TRUE, FALSE, operands[1], &offset);\n+})\n \n ;; Load multiple with write-back\n \n@@ -5366,7 +5365,9 @@\n                           (match_operand:SI 1 \"\" \"\"))\n                      (use (match_operand:SI 2 \"\" \"\"))])]\n   \"TARGET_ARM\"\n-  \"\n+{\n+  HOST_WIDE_INT offset = 0;\n+\n   /* Support only fixed point registers.  */\n   if (GET_CODE (operands[2]) != CONST_INT\n       || INTVAL (operands[2]) > 14\n@@ -5380,11 +5381,8 @@\n   operands[3]\n     = arm_gen_store_multiple (REGNO (operands[1]), INTVAL (operands[2]),\n \t\t\t      force_reg (SImode, XEXP (operands[0], 0)),\n-\t\t\t      TRUE, FALSE, MEM_READONLY_P (operands[0]),\n-\t\t\t      MEM_IN_STRUCT_P (operands[0]), \n-\t                      MEM_SCALAR_P (operands[0]));\n-  \"\n-)\n+\t\t\t      TRUE, FALSE, operands[0], &offset);\n+})\n \n ;; Store multiple with write-back\n "}]}