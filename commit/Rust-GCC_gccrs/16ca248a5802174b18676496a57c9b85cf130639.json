{"sha": "16ca248a5802174b18676496a57c9b85cf130639", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTZjYTI0OGE1ODAyMTc0YjE4Njc2NDk2YTU3YzliODVjZjEzMDYzOQ==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2007-04-06T09:27:02Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:27:02Z"}, "message": "sem_ch8.adb (Has_Components): If the argument is an incomplete type that is a limited view...\n\n2007-04-06  Ed Schonberg  <schonberg@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch8.adb (Has_Components): If the argument is an incomplete type\n\tthat is a limited view, check the non-limited view if available.\n\t(Undefined): Refine error message for missing with of Text_IO\n\t(Find_Expanded_Name): Use Is_Known_Unit for more accurate error message\n\tto distinguish real missing with cases.\n\tFix format of all missing with messages\n\t(Analyze_Subprogram_Renaming): Emit proper error message on illegal\n\trenaming as body when renamed entity is abstract.\n\nFrom-SVN: r123597", "tree": {"sha": "2cf7d06f72f5c9ed92e6e79fc38d77a35e0658a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2cf7d06f72f5c9ed92e6e79fc38d77a35e0658a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16ca248a5802174b18676496a57c9b85cf130639", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16ca248a5802174b18676496a57c9b85cf130639", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16ca248a5802174b18676496a57c9b85cf130639", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16ca248a5802174b18676496a57c9b85cf130639/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "13bbad84b1148a52cc2c130ddce42958aad23483", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13bbad84b1148a52cc2c130ddce42958aad23483", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13bbad84b1148a52cc2c130ddce42958aad23483"}], "stats": {"total": 596, "additions": 290, "deletions": 306}, "files": [{"sha": "982fa76c4d1c4cf9c4d53a594047012381c6af8d", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 290, "deletions": 306, "changes": 596, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16ca248a5802174b18676496a57c9b85cf130639/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16ca248a5802174b18676496a57c9b85cf130639/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=16ca248a5802174b18676496a57c9b85cf130639", "patch": "@@ -33,6 +33,7 @@ with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Fname;    use Fname;\n with Freeze;   use Freeze;\n+with Impunit;  use Impunit;\n with Lib;      use Lib;\n with Lib.Load; use Lib.Load;\n with Lib.Xref; use Lib.Xref;\n@@ -229,23 +230,22 @@ package body Sem_Ch8 is\n    -- Compiling subunits --\n    ------------------------\n \n-   --  Subunits must be compiled in the environment of the corresponding\n-   --  stub, that is to say with the same visibility into the parent (and its\n+   --  Subunits must be compiled in the environment of the corresponding stub,\n+   --  that is to say with the same visibility into the parent (and its\n    --  context) that is available at the point of the stub declaration, but\n    --  with the additional visibility provided by the context clause of the\n    --  subunit itself. As a result, compilation of a subunit forces compilation\n    --  of the parent (see description in lib-). At the point of the stub\n-   --  declaration, Analyze is called recursively to compile the proper body\n-   --  of the subunit, but without reinitializing the names table, nor the\n-   --  scope stack (i.e. standard is not pushed on the stack). In this fashion\n-   --  the context of the subunit is added to the context of the parent, and\n-   --  the subunit is compiled in the correct environment. Note that in the\n-   --  course of processing the context of a subunit, Standard will appear\n-   --  twice on the scope stack: once for the parent of the subunit, and\n-   --  once for the unit in the context clause being compiled. However, the\n-   --  two sets of entities are not linked by homonym chains, so that the\n-   --  compilation of any context unit happens in a fresh visibility\n-   --  environment.\n+   --  declaration, Analyze is called recursively to compile the proper body of\n+   --  the subunit, but without reinitializing the names table, nor the scope\n+   --  stack (i.e. standard is not pushed on the stack). In this fashion the\n+   --  context of the subunit is added to the context of the parent, and the\n+   --  subunit is compiled in the correct environment. Note that in the course\n+   --  of processing the context of a subunit, Standard will appear twice on\n+   --  the scope stack: once for the parent of the subunit, and once for the\n+   --  unit in the context clause being compiled. However, the two sets of\n+   --  entities are not linked by homonym chains, so that the compilation of\n+   --  any context unit happens in a fresh visibility environment.\n \n    -------------------------------\n    -- Processing of USE Clauses --\n@@ -292,8 +292,8 @@ package body Sem_Ch8 is\n    --  contains the full declaration. To simplify the swap, the defining\n    --  occurrence that currently holds the private declaration points to the\n    --  full declaration. During semantic processing the defining occurrence\n-   --  also points to a list of private dependents, that is to say access\n-   --  types or composite types whose designated types or component types are\n+   --  also points to a list of private dependents, that is to say access types\n+   --  or composite types whose designated types or component types are\n    --  subtypes or derived types of the private type in question. After the\n    --  full declaration has been seen, the private dependents are updated to\n    --  indicate that they have full definitions.\n@@ -457,12 +457,11 @@ package body Sem_Ch8 is\n \n    function Has_Implicit_Operator (N : Node_Id) return Boolean;\n    --  N is an expanded name whose selector is an operator name (eg P.\"+\").\n-   --  A declarative part contains an implicit declaration of an operator\n-   --  if it has a declaration of a type to which one of the predefined\n-   --  operators apply. The existence of this routine is an artifact of\n-   --  our implementation: a more straightforward but more space-consuming\n-   --  choice would be to make all inherited operators explicit in the\n-   --  symbol table.\n+   --  declarative part contains an implicit declaration of an operator if it\n+   --  has a declaration of a type to which one of the predefined operators\n+   --  apply. The existence of this routine is an implementation artifact. A\n+   --  more straightforward but more space-consuming choice would be to make\n+   --  all inherited operators explicit in the symbol table.\n \n    procedure Inherit_Renamed_Profile (New_S : Entity_Id; Old_S : Entity_Id);\n    --  A subprogram defined by a renaming declaration inherits the parameter\n@@ -471,17 +470,17 @@ package body Sem_Ch8 is\n    --  subprogram, which are then used to recheck the default values.\n \n    function Is_Appropriate_For_Record (T : Entity_Id) return Boolean;\n-   --  Prefix is appropriate for record if it is of a record type, or\n-   --  an access to such.\n+   --  Prefix is appropriate for record if it is of a record type, or an access\n+   --  to such.\n \n    function Is_Appropriate_For_Entry_Prefix (T : Entity_Id) return Boolean;\n-   --  True if it is of a task type, a protected type, or else an access\n-   --  to one of these types.\n+   --  True if it is of a task type, a protected type, or else an access to one\n+   --  of these types.\n \n    procedure Note_Redundant_Use (Clause : Node_Id);\n-   --  Mark the name in a use clause  as redundant if the corresponding\n-   --  entity is already use-visible. Emit a warning if the use clause\n-   --  comes from source and the proper warnings are enabled.\n+   --  Mark the name in a use clause as redundant if the corresponding entity\n+   --  is already use-visible. Emit a warning if the use clause comes from\n+   --  source and the proper warnings are enabled.\n \n    procedure Premature_Usage (N : Node_Id);\n    --  Diagnose usage of an entity before it is visible\n@@ -507,9 +506,9 @@ package body Sem_Ch8 is\n    -- Analyze_Exception_Renaming --\n    --------------------------------\n \n-   --  The language only allows a single identifier, but the tree holds\n-   --  an identifier list. The parser has already issued an error message\n-   --  if there is more than one element in the list.\n+   --  The language only allows a single identifier, but the tree holds an\n+   --  identifier list. The parser has already issued an error message if\n+   --  there is more than one element in the list.\n \n    procedure Analyze_Exception_Renaming (N : Node_Id) is\n       Id  : constant Node_Id := Defining_Identifier (N);\n@@ -543,10 +542,10 @@ package body Sem_Ch8 is\n \n    procedure Analyze_Expanded_Name (N : Node_Id) is\n    begin\n-      --  If the entity pointer is already set, this is an internal node, or\n-      --  a node that is analyzed more than once, after a tree modification.\n-      --  In such a case there is no resolution to perform, just set the type.\n-      --  For completeness, analyze prefix as well.\n+      --  If the entity pointer is already set, this is an internal node, or a\n+      --  node that is analyzed more than once, after a tree modification. In\n+      --  such a case there is no resolution to perform, just set the type. For\n+      --  completeness, analyze prefix as well.\n \n       if Present (Entity (N)) then\n          if Is_Type (Entity (N)) then\n@@ -577,8 +576,8 @@ package body Sem_Ch8 is\n \n    procedure Analyze_Generic_Package_Renaming   (N : Node_Id) is\n    begin\n-      --  Apply the Text_IO Kludge here, since we may be renaming\n-      --  one of the subpackages of Text_IO, then join common routine.\n+      --  Apply the Text_IO Kludge here, since we may be renaming one of the\n+      --  subpackages of Text_IO, then join common routine.\n \n       Text_IO_Kludge (Name (N));\n \n@@ -704,11 +703,11 @@ package body Sem_Ch8 is\n       Set_Is_Pure (Id, Is_Pure (Current_Scope));\n       Enter_Name (Id);\n \n-      --  The renaming of a component that depends on a discriminant\n-      --  requires an actual subtype, because in subsequent use of the object\n-      --  Gigi will be unable to locate the actual bounds. This explicit step\n-      --  is required when the renaming is generated in removing side effects\n-      --  of an already-analyzed expression.\n+      --  The renaming of a component that depends on a discriminant requires\n+      --  an actual subtype, because in subsequent use of the object Gigi will\n+      --  be unable to locate the actual bounds. This explicit step is required\n+      --  when the renaming is generated in removing side effects of an\n+      --  already-analyzed expression.\n \n       if Nkind (Nam) = N_Selected_Component\n         and then Analyzed (Nam)\n@@ -749,8 +748,8 @@ package body Sem_Ch8 is\n          end if;\n       end if;\n \n-      --  An object renaming requires an exact match of the type;\n-      --  class-wide matching is not allowed.\n+      --  An object renaming requires an exact match of the type. Class-wide\n+      --  matching is not allowed.\n \n       if Is_Class_Wide_Type (T)\n         and then Base_Type (Etype (Nam)) /= Base_Type (T)\n@@ -822,8 +821,8 @@ package body Sem_Ch8 is\n                   Error_Msg_N (\"null-exclusion required in formal \" &\n                                \"object declaration\", Error_Node);\n \n-               --  Ada 2005 (AI-423): Otherwise, the subtype of the object\n-               --  name shall exclude null.\n+               --  Ada 2005 (AI-423): Otherwise, the subtype of the object name\n+               --  shall exclude null.\n \n                elsif Nkind (Subtyp_Decl) = N_Subtype_Declaration\n                  and then not Has_Null_Exclusion (Subtyp_Decl)\n@@ -932,6 +931,7 @@ package body Sem_Ch8 is\n \n       Enter_Name (New_P);\n       Analyze (Name (N));\n+\n       if Is_Entity_Name (Name (N)) then\n          Old_P := Entity (Name (N));\n       else\n@@ -1007,8 +1007,10 @@ package body Sem_Ch8 is\n            and then Chars (New_P) = Chars (Generic_Parent (Spec))\n          then\n             declare\n-               E : Entity_Id := First_Entity (Old_P);\n+               E : Entity_Id;\n+\n             begin\n+               E := First_Entity (Old_P);\n                while Present (E)\n                  and then E /= New_P\n                loop\n@@ -1136,8 +1138,7 @@ package body Sem_Ch8 is\n          return;\n       end if;\n \n-      --  Otherwise, find renamed entity, and build body of New_S as a call\n-      --  to it.\n+      --  Otherwise find renamed entity and build body of New_S as a call to it\n \n       Old_S := Find_Renamed_Entity (N, Selector_Name (Nam), New_S);\n \n@@ -1199,6 +1200,7 @@ package body Sem_Ch8 is\n             Generate_Reference (New_S, Defining_Entity (N), 'b');\n             Style.Check_Identifier (Defining_Entity (N), New_S);\n          end if;\n+\n       else\n          Error_Msg_N (\"no entry family matches specification\", N);\n       end if;\n@@ -1231,21 +1233,23 @@ package body Sem_Ch8 is\n          Sub : Entity_Id);\n       --  Ada 2005 (AI-423): Given renaming Ren of subprogram Sub, check the\n       --  following AI rules:\n-      --     o If Ren is a renaming of a formal subprogram and one of its\n-      --       parameters has a null exclusion, then the corresponding formal\n-      --       in Sub must also have one. Otherwise the subtype of the Sub's\n-      --       formal parameter must exclude null.\n-      --     o If Ren is a renaming of a formal function and its retrun\n-      --       profile has a null exclusion, then Sub's return profile must\n-      --       have one. Otherwise the subtype of Sub's return profile must\n-      --       exclude null.\n+      --\n+      --    If Ren is a renaming of a formal subprogram and one of its\n+      --    parameters has a null exclusion, then the corresponding formal\n+      --    in Sub must also have one. Otherwise the subtype of the Sub's\n+      --    formal parameter must exclude null.\n+      --\n+      --    If Ren is a renaming of a formal function and its retrun\n+      --    profile has a null exclusion, then Sub's return profile must\n+      --    have one. Otherwise the subtype of Sub's return profile must\n+      --    exclude null.\n \n       function Original_Subprogram (Subp : Entity_Id) return Entity_Id;\n-      --  Find renamed entity when the declaration is a renaming_as_body\n-      --  and the renamed entity may itself be a renaming_as_body. Used to\n-      --  enforce rule that a renaming_as_body is illegal if the declaration\n-      --  occurs before the subprogram it completes is frozen, and renaming\n-      --  indirectly renames the subprogram itself.(Defect Report 8652/0027).\n+      --  Find renamed entity when the declaration is a renaming_as_body and\n+      --  the renamed entity may itself be a renaming_as_body. Used to enforce\n+      --  rule that a renaming_as_body is illegal if the declaration occurs\n+      --  before the subprogram it completes is frozen, and renaming indirectly\n+      --  renames the subprogram itself.(Defect Report 8652/0027).\n \n       --------------------------\n       -- Check_Null_Exclusion --\n@@ -1255,12 +1259,14 @@ package body Sem_Ch8 is\n         (Ren : Entity_Id;\n          Sub : Entity_Id)\n       is\n-         Ren_Formal : Entity_Id := First_Formal (Ren);\n-         Sub_Formal : Entity_Id := First_Formal (Sub);\n+         Ren_Formal : Entity_Id;\n+         Sub_Formal : Entity_Id;\n \n       begin\n          --  Parameter check\n \n+         Ren_Formal := First_Formal (Ren);\n+         Sub_Formal := First_Formal (Sub);\n          while Present (Ren_Formal)\n            and then Present (Sub_Formal)\n          loop\n@@ -1345,15 +1351,15 @@ package body Sem_Ch8 is\n \n       if Nkind (Nam) = N_Attribute_Reference then\n \n-         --  In the case of an abstract formal subprogram association,\n-         --  rewrite an actual given by a stream attribute as the name\n-         --  of the corresponding stream primitive of the type.\n+         --  In the case of an abstract formal subprogram association, rewrite\n+         --  an actual given by a stream attribute as the name of the\n+         --  corresponding stream primitive of the type.\n \n-         --  In a generic context the stream operations are not generated,\n-         --  and this must be treated as a normal attribute reference, to\n-         --  be expanded in subsequent instantiations.\n+         --  In a generic context the stream operations are not generated, and\n+         --  this must be treated as a normal attribute reference, to be\n+         --  expanded in subsequent instantiations.\n \n-         if Is_Actual and then Is_Abstract (Formal_Spec)\n+         if Is_Actual and then Is_Abstract_Subprogram (Formal_Spec)\n            and then Expander_Active\n          then\n             declare\n@@ -1373,10 +1379,10 @@ package body Sem_Ch8 is\n                end if;\n \n                --  Retrieve the primitive subprogram associated with the\n-               --  attribute. This can only be a stream attribute, since\n-               --  those are the only ones that are dispatching (and the\n-               --  actual for an abstract formal subprogram must be a\n-               --  dispatching operation).\n+               --  attribute. This can only be a stream attribute, since those\n+               --  are the only ones that are dispatching (and the actual for\n+               --  an abstract formal subprogram must be dispatching\n+               --  operation).\n \n                case Attribute_Name (Nam) is\n                   when Name_Input  =>\n@@ -1424,13 +1430,13 @@ package body Sem_Ch8 is\n       --  Check whether this declaration corresponds to the instantiation\n       --  of a formal subprogram.\n \n-      --  If this is an instantiation, the corresponding actual is frozen\n-      --  and error messages can be made more precise. If this is a default\n-      --  subprogram, the entity is already established in the generic, and\n-      --  is not retrieved by visibility. If it is a default with a box, the\n+      --  If this is an instantiation, the corresponding actual is frozen and\n+      --  error messages can be made more precise. If this is a default\n+      --  subprogram, the entity is already established in the generic, and is\n+      --  not retrieved by visibility. If it is a default with a box, the\n       --  candidate interpretations, if any, have been collected when building\n-      --  the renaming declaration. If overloaded, the proper interpretation\n-      --  is determined in Find_Renamed_Entity. If the entity is an operator,\n+      --  the renaming declaration. If overloaded, the proper interpretation is\n+      --  determined in Find_Renamed_Entity. If the entity is an operator,\n       --  Find_Renamed_Entity applies additional visibility checks.\n \n       if Is_Actual then\n@@ -1456,9 +1462,9 @@ package body Sem_Ch8 is\n                --  If there is an immediately visible homonym of the operator\n                --  and the declaration has a default, this is worth a warning\n                --  because the user probably did not intend to get the pre-\n-               --  defined operator, visible in the generic declaration.\n-               --  To find if there is an intended candidate, analyze the\n-               --  renaming again in the current context.\n+               --  defined operator, visible in the generic declaration. To\n+               --  find if there is an intended candidate, analyze the renaming\n+               --  again in the current context.\n \n                elsif Scope (Old_S) = Standard_Standard\n                  and then Present (Default_Name (Inst_Node))\n@@ -1545,7 +1551,7 @@ package body Sem_Ch8 is\n             begin\n                Remove (Old_Decl);\n                Insert_After (N, New_Decl);\n-               Set_Is_Abstract (Rename_Spec, False);\n+               Set_Is_Abstract_Subprogram (Rename_Spec, False);\n                Set_Analyzed (New_Decl);\n             end;\n          end if;\n@@ -1638,7 +1644,6 @@ package body Sem_Ch8 is\n       then\n          Error_Msg_N (\"expect valid subprogram name in renaming\", N);\n          return;\n-\n       end if;\n \n       --  Most common case: subprogram renames subprogram. No body is generated\n@@ -1785,12 +1790,13 @@ package body Sem_Ch8 is\n             --  indicate that the renaming is an abstract dispatching operation\n             --  with a controlling type.\n \n-            if Is_Actual and then Is_Abstract (Formal_Spec) then\n+            if Is_Actual and then Is_Abstract_Subprogram (Formal_Spec) then\n+\n                --  Mark the renaming as abstract here, so Find_Dispatching_Type\n                --  see it as corresponding to a generic association for a\n                --  formal abstract subprogram\n \n-               Set_Is_Abstract (New_S);\n+               Set_Is_Abstract_Subprogram (New_S);\n \n                declare\n                   New_S_Ctrl_Type : constant Entity_Id :=\n@@ -1808,10 +1814,9 @@ package body Sem_Ch8 is\n                      Set_Is_Dispatching_Operation (New_S);\n                      Check_Controlling_Formals (New_S_Ctrl_Type, New_S);\n \n-                     --  In the case where the actual in the formal subprogram\n-                     --  is itself a formal abstract subprogram association,\n-                     --  there's no dispatch table component or position to\n-                     --  inherit.\n+                     --  If the actual in the formal subprogram is itself a\n+                     --  formal abstract subprogram association, there's no\n+                     --  dispatch table component or position to inherit.\n \n                      if Present (DTC_Entity (Old_S)) then\n                         Set_DTC_Entity  (New_S, DTC_Entity (Old_S));\n@@ -1831,7 +1836,18 @@ package body Sem_Ch8 is\n          end if;\n \n          Set_Convention (New_S, Convention (Old_S));\n-         Set_Is_Abstract (New_S, Is_Abstract (Old_S));\n+\n+         if Is_Abstract_Subprogram (Old_S) then\n+            if Present (Rename_Spec) then\n+               Error_Msg_N\n+                 (\"a renaming-as-body cannot rename an abstract subprogram\",\n+                  N);\n+               Set_Has_Completion (Rename_Spec);\n+            else\n+               Set_Is_Abstract_Subprogram (New_S);\n+            end if;\n+         end if;\n+\n          Check_Library_Unit_Renaming (N, Old_S);\n \n          --  Pathological case: procedure renames entry in the scope of its\n@@ -1852,8 +1868,8 @@ package body Sem_Ch8 is\n             --  where the formal subprogram is also abstract.\n \n             if (Ekind (Old_S) = E_Procedure or else Ekind (Old_S) = E_Function)\n-              and then Is_Abstract (Old_S)\n-              and then not Is_Abstract (Formal_Spec)\n+              and then Is_Abstract_Subprogram (Old_S)\n+              and then not Is_Abstract_Subprogram (Formal_Spec)\n             then\n                Error_Msg_N\n                  (\"abstract subprogram not allowed as generic actual\", Nam);\n@@ -1874,7 +1890,6 @@ package body Sem_Ch8 is\n             declare\n                T : constant Entity_Id :=\n                      Base_Type (Etype (First_Formal (New_S)));\n-\n             begin\n                Error_Msg_Node_2 := Prefix (Nam);\n                Error_Msg_NE\n@@ -2008,17 +2023,17 @@ package body Sem_Ch8 is\n       --  Loop through package names to identify referenced packages\n \n       Pack_Name := First (Names (N));\n-\n       while Present (Pack_Name) loop\n          Analyze (Pack_Name);\n \n          if Nkind (Parent (N)) = N_Compilation_Unit\n            and then Nkind (Pack_Name) = N_Expanded_Name\n          then\n             declare\n-               Pref : Node_Id := Prefix (Pack_Name);\n+               Pref : Node_Id;\n \n             begin\n+               Pref := Prefix (Pack_Name);\n                while Nkind (Pref) = N_Expanded_Name loop\n                   Pref := Prefix (Pref);\n                end loop;\n@@ -2038,9 +2053,7 @@ package body Sem_Ch8 is\n       --  use visible.\n \n       Pack_Name := First (Names (N));\n-\n       while Present (Pack_Name) loop\n-\n          if Is_Entity_Name (Pack_Name) then\n             Pack := Entity (Pack_Name);\n \n@@ -2068,7 +2081,6 @@ package body Sem_Ch8 is\n \n          Next (Pack_Name);\n       end loop;\n-\n    end Analyze_Use_Package;\n \n    ----------------------\n@@ -2088,7 +2100,6 @@ package body Sem_Ch8 is\n       end if;\n \n       Id := First (Subtype_Marks (N));\n-\n       while Present (Id) loop\n          Find_Type (Id);\n \n@@ -2173,7 +2184,6 @@ package body Sem_Ch8 is\n \n       else\n          Param_Spec := First (Parameter_Specifications (Spec));\n-\n          while Present (Param_Spec) loop\n             Form_Num := Form_Num + 1;\n \n@@ -2248,7 +2258,6 @@ package body Sem_Ch8 is\n       --  Note that there is no Expr_List in this case anyway\n \n       if Aname = Name_AST_Entry then\n-\n          declare\n             Ent  : Entity_Id;\n             Decl : Node_Id;\n@@ -2288,7 +2297,6 @@ package body Sem_Ch8 is\n       --  Case of renaming a function\n \n       if Nkind (Spec) = N_Function_Specification then\n-\n          if Is_Procedure_Attribute_Name (Aname) then\n             Error_Msg_N (\"attribute can only be renamed as procedure\", Nam);\n             return;\n@@ -2448,8 +2456,7 @@ package body Sem_Ch8 is\n       loop\n          if Nkind (Item) = N_With_Clause\n \n-            --  Protect the frontend against previously reported\n-            --  critical errors\n+            --  Protect the frontend against previous critical errors\n \n            and then Nkind (Name (Item)) /= N_Selected_Component\n            and then Entity (Name (Item)) = Pack\n@@ -2549,7 +2556,6 @@ package body Sem_Ch8 is\n \n    begin\n       Id := First_Entity (Current_Scope);\n-\n       while Present (Id) loop\n          --  An entity in the current scope is not necessarily the first one\n          --  on its homonym chain. Find its predecessor if any,\n@@ -2575,9 +2581,9 @@ package body Sem_Ch8 is\n             Prev := Empty;\n          end if;\n \n-         Outer := Homonym (Id);\n          Set_Is_Immediately_Visible (Id, False);\n \n+         Outer := Homonym (Id);\n          while Present (Outer) and then Scope (Outer) = Current_Scope loop\n             Outer := Homonym (Outer);\n          end loop;\n@@ -2692,7 +2698,6 @@ package body Sem_Ch8 is\n          F  : Entity_Id) return Boolean\n       is\n          T : constant Entity_Id := Etype (F);\n-\n       begin\n          return In_Use (T)\n            and then Scope (T) = Scope (Op);\n@@ -2702,20 +2707,18 @@ package body Sem_Ch8 is\n \n    begin\n       Pack_Name := First (Names (N));\n-\n       while Present (Pack_Name) loop\n          Pack := Entity (Pack_Name);\n \n          if Ekind (Pack) = E_Package then\n-\n             if In_Open_Scopes (Pack) then\n                null;\n \n             elsif not Redundant_Use (Pack_Name) then\n                Set_In_Use (Pack, False);\n                Set_Current_Use_Clause (Pack, Empty);\n-               Id := First_Entity (Pack);\n \n+               Id := First_Entity (Pack);\n                while Present (Id) loop\n \n                   --  Preserve use-visibility of operators that are primitive\n@@ -2756,7 +2759,6 @@ package body Sem_Ch8 is\n                  and then Present_System_Aux\n                then\n                   Id := First_Entity (System_Aux_Id);\n-\n                   while Present (Id) loop\n                      Set_Is_Potentially_Use_Visible (Id, False);\n \n@@ -2775,15 +2777,13 @@ package body Sem_Ch8 is\n             else\n                Set_Redundant_Use (Pack_Name, False);\n             end if;\n-\n          end if;\n \n          Next (Pack_Name);\n       end loop;\n \n       if Present (Hidden_By_Use_Clause (N)) then\n          Elmt := First_Elmt (Hidden_By_Use_Clause (N));\n-\n          while Present (Elmt) loop\n             Set_Is_Immediately_Visible (Node (Elmt));\n             Next_Elmt (Elmt);\n@@ -2805,7 +2805,6 @@ package body Sem_Ch8 is\n \n    begin\n       Id := First (Subtype_Marks (N));\n-\n       while Present (Id) loop\n \n          --  A call to rtsfind may occur while analyzing a use_type clause,\n@@ -2825,9 +2824,9 @@ package body Sem_Ch8 is\n          then\n             null;\n \n-         --  Note that the use_Type clause may mention a subtype of the\n-         --  type whose primitive operations have been made visible. Here\n-         --  as elsewhere, it is the base type that matters for visibility.\n+         --  Note that the use_Type clause may mention a subtype of the type\n+         --  whose primitive operations have been made visible. Here as\n+         --  elsewhere, it is the base type that matters for visibility.\n \n          elsif In_Open_Scopes (Scope (Base_Type (T))) then\n             null;\n@@ -2836,10 +2835,9 @@ package body Sem_Ch8 is\n             Set_In_Use (T, False);\n             Set_In_Use (Base_Type (T), False);\n             Op_List := Collect_Primitive_Operations (T);\n-            Elmt := First_Elmt (Op_List);\n \n+            Elmt := First_Elmt (Op_List);\n             while Present (Elmt) loop\n-\n                if Nkind (Node (Elmt)) = N_Defining_Operator_Symbol then\n                   Set_Is_Potentially_Use_Visible (Node (Elmt), False);\n                end if;\n@@ -2924,7 +2922,6 @@ package body Sem_Ch8 is\n             return False;\n          else\n             Inst := Current_Scope;\n-\n             while Present (Inst)\n               and then Ekind (Inst) /= E_Package\n               and then not Is_Generic_Instance (Inst)\n@@ -2937,7 +2934,6 @@ package body Sem_Ch8 is\n             end if;\n \n             Act := First_Entity (Inst);\n-\n             while Present (Act) loop\n                if Ekind (Act) = E_Package then\n \n@@ -3051,16 +3047,16 @@ package body Sem_Ch8 is\n          if Nvis_Is_Private_Subprg then\n \n             pragma Assert (Nkind (E2) = N_Defining_Identifier\n-                           and then Ekind (E2) = E_Function\n-                           and then Scope (E2) = Standard_Standard\n-                           and then Has_Private_With (E2));\n+                            and then Ekind (E2) = E_Function\n+                            and then Scope (E2) = Standard_Standard\n+                            and then Has_Private_With (E2));\n \n             --  Find the sloc corresponding to the private with'ed unit\n \n-            Comp_Unit      := Cunit (Current_Sem_Unit);\n-            Item           := First (Context_Items (Comp_Unit));\n+            Comp_Unit := Cunit (Current_Sem_Unit);\n             Error_Msg_Sloc := No_Location;\n \n+            Item := First (Context_Items (Comp_Unit));\n             while Present (Item) loop\n                if Nkind (Item) = N_With_Clause\n                  and then Private_Present (Item)\n@@ -3088,7 +3084,6 @@ package body Sem_Ch8 is\n             Ent := Homonyms;\n             while Present (Ent) loop\n                if Is_Potentially_Use_Visible (Ent) then\n-\n                   if not Hidden then\n                      Error_Msg_N (\"multiple use clauses cause hiding!\", N);\n                      Hidden := True;\n@@ -3134,8 +3129,9 @@ package body Sem_Ch8 is\n                        and then\n                          Nkind (Parent (Parent (N))) = N_Use_Package_Clause\n                      then\n-                        Error_Msg_NE\n-                         (\"\\possible missing with_clause for&\", N, Ent);\n+                        Error_Msg_Qual_Level := 99;\n+                        Error_Msg_NE (\"\\\\missing `WITH &;`\", N, Ent);\n+                        Error_Msg_Qual_Level := 0;\n                      end if;\n                   end if;\n \n@@ -3152,7 +3148,6 @@ package body Sem_Ch8 is\n                <<Continue>>\n                Ent := Homonym (Ent);\n             end loop;\n-\n          end if;\n       end Nvis_Messages;\n \n@@ -3275,7 +3270,20 @@ package body Sem_Ch8 is\n             --  this is a very common error for beginners to make).\n \n             if Chars (N) = Name_Put or else Chars (N) = Name_Put_Line then\n-               Error_Msg_N (\"\\possible missing with of 'Text_'I'O!\", N);\n+               Error_Msg_N\n+                 (\"\\\\possible missing `WITH Ada.Text_'I'O; \" &\n+                  \"USE Ada.Text_'I'O`!\", N);\n+\n+            --  Another special check if N is the prefix of a selected\n+            --  component which is a known unit, add message complaining\n+            --  about missingw with for this unit.\n+\n+            elsif Nkind (Parent (N)) = N_Selected_Component\n+              and then N = Prefix (Parent (N))\n+              and then Is_Known_Unit (Parent (N))\n+            then\n+               Error_Msg_Node_2 := Selector_Name (Parent (N));\n+               Error_Msg_N (\"\\\\missing `WITH &.&;`\", Prefix (Parent (N)));\n             end if;\n \n             --  Now check for possible misspellings\n@@ -3319,10 +3327,10 @@ package body Sem_Ch8 is\n             end;\n          end if;\n \n-         --  Make entry in undefined references table unless the full\n-         --  errors switch is set, in which case by refraining from\n-         --  generating the table entry, we guarantee that we get an\n-         --  error message for every undefined reference.\n+         --  Make entry in undefined references table unless the full errors\n+         --  switch is set, in which case by refraining from generating the\n+         --  table entry, we guarantee that we get an error message for every\n+         --  undefined reference.\n \n          if not All_Errors_Mode then\n             Urefs.Increment_Last;\n@@ -3440,7 +3448,6 @@ package body Sem_Ch8 is\n \n       begin\n          E2 := Homonym (E);\n-\n          while Present (E2) loop\n             if Is_Immediately_Visible (E2) then\n \n@@ -3509,10 +3516,10 @@ package body Sem_Ch8 is\n \n          else\n             if In_Instance then\n-               Inst := Current_Scope;\n \n                --  Find current instance\n \n+               Inst := Current_Scope;\n                while Present (Inst)\n                  and then Inst /= Standard_Standard\n                loop\n@@ -3524,7 +3531,6 @@ package body Sem_Ch8 is\n                end loop;\n \n                E2 := E;\n-\n                while Present (E2) loop\n                   if From_Actual_Package (E2)\n                     or else\n@@ -3687,10 +3693,10 @@ package body Sem_Ch8 is\n          then\n             Premature_Usage (N);\n \n-         --  If the entity is overloadable, collect all interpretations\n-         --  of the name for subsequent overload resolution. We optimize\n-         --  a bit here to do this only if we have an overloadable entity\n-         --  that is not on its own on the homonym chain.\n+         --  If the entity is overloadable, collect all interpretations of the\n+         --  name for subsequent overload resolution. We optimize a bit here to\n+         --  do this only if we have an overloadable entity that is not on its\n+         --  own on the homonym chain.\n \n          elsif Is_Overloadable (E)\n            and then (Present (Homonym (E)) or else Current_Entity (N) /= E)\n@@ -3710,11 +3716,11 @@ package body Sem_Ch8 is\n          --  to the discriminant in the initialization procedure.\n \n          else\n-            --  Entity is unambiguous, indicate that it is referenced here\n-            --  One slightly odd case is that we do not want to set the\n-            --  Referenced flag if the entity is a label, and the identifier\n-            --  is the label in the source, since this is not a reference\n-            --  from the point of view of the user\n+            --  Entity is unambiguous, indicate that it is referenced here One\n+            --  slightly odd case is that we do not want to set the Referenced\n+            --  flag if the entity is a label, and the identifier is the label\n+            --  in the source, since this is not a reference from the point of\n+            --  view of the user\n \n             if Nkind (Parent (N)) = N_Label then\n                declare\n@@ -3731,11 +3737,10 @@ package body Sem_Ch8 is\n                Generate_Reference (E, N);\n             end if;\n \n-            --  Set Entity, with style check if need be. If this is a\n-            --  discriminant reference, it must be replaced by the\n-            --  corresponding discriminal, that is to say the parameter\n-            --  of the initialization procedure that corresponds to the\n-            --  discriminant. If this replacement is being performed, there\n+            --  Set Entity, with style check if need be. For a discriminant\n+            --  reference, replace by the corresponding discriminal, i.e. the\n+            --  parameter of the initialization procedure that corresponds to\n+            --  the discriminant. If this replacement is being performed, there\n             --  is no style check to perform.\n \n             --  This replacement must not be done if we are currently\n@@ -3754,9 +3759,10 @@ package body Sem_Ch8 is\n \n             elsif Is_Concurrent_Type (Scope (E)) then\n                declare\n-                  P : Node_Id := Parent (N);\n+                  P : Node_Id;\n \n                begin\n+                  P := Parent (N);\n                   while Present (P)\n                     and then Nkind (P) /= N_Parameter_Specification\n                     and then Nkind (P) /= N_Component_Declaration\n@@ -3946,33 +3952,43 @@ package body Sem_Ch8 is\n \n             if Present (Candidate) then\n \n+               --  If we know that the unit is a child unit we can give a more\n+               --  accurate error message.\n+\n                if Is_Child_Unit (Candidate) then\n \n-                  --  If the candidate is a private child unit and we are\n-                  --  in the visible part of a public unit, specialize the\n-                  --  error message. There might be a private with_clause for\n-                  --  it, but it is not currently active.\n+                  --  If the candidate is a private child unit and we are in\n+                  --  the visible part of a public unit, specialize the error\n+                  --  message. There might be a private with_clause for it,\n+                  --  but it is not currently active.\n \n                   if Is_Private_Descendant (Candidate)\n                     and then Ekind (Current_Scope) = E_Package\n                     and then not In_Private_Part (Current_Scope)\n                     and then not Is_Private_Descendant (Current_Scope)\n                   then\n                      Error_Msg_N (\"private child unit& is not visible here\",\n-                       Selector);\n+                                  Selector);\n+\n+                  --  Normal case where we have a missing with for a child unit\n+\n                   else\n-                     Error_Msg_N\n-                       (\"missing with_clause for child unit &\", Selector);\n+                     Error_Msg_Qual_Level := 99;\n+                     Error_Msg_NE (\"missing `WITH &;`\", Selector, Candidate);\n+                     Error_Msg_Qual_Level := 0;\n                   end if;\n+\n+                  --  Here we don't know that this is a child unit\n+\n                else\n                   Error_Msg_NE (\"& is not a visible entity of&\", N, Selector);\n                end if;\n \n             else\n                --  Within the instantiation of a child unit, the prefix may\n-               --  denote the parent instance, but the selector has the\n-               --  name of the original child. Find whether we are within\n-               --  the corresponding instance, and get the proper entity, which\n+               --  denote the parent instance, but the selector has the name\n+               --  of the original child. Find whether we are within the\n+               --  corresponding instance, and get the proper entity, which\n                --  can only be an enclosing scope.\n \n                if O_Name /= P_Name\n@@ -4009,23 +4025,23 @@ package body Sem_Ch8 is\n                   end;\n                end if;\n \n-               if Chars (P_Name) = Name_Ada\n-                 and then Scope (P_Name) = Standard_Standard\n-               then\n+               --  If this is a selection from Ada, System or Interfaces, then\n+               --  we assume a missing with for the corresponding package.\n+\n+               if Is_Known_Unit (N) then\n                   Error_Msg_Node_2 := Selector;\n-                  Error_Msg_NE (\"missing with for `&.&`\", N, P_Name);\n+                  Error_Msg_N (\"missing `WITH &.&;`\", Prefix (N));\n \n-               --  If this is a selection from a dummy package, then\n-               --  suppress the error message, of course the entity\n-               --  is missing if the package is missing!\n+               --  If this is a selection from a dummy package, then suppress\n+               --  the error message, of course the entity is missing if the\n+               --  package is missing!\n \n                elsif Sloc (Error_Msg_Node_2) = No_Location then\n                   null;\n \n                --  Here we have the case of an undefined component\n \n                else\n-\n                   Error_Msg_NE (\"& not declared in&\", N, Selector);\n \n                   --  Check for misspelling of some entity in prefix\n@@ -4060,9 +4076,8 @@ package body Sem_Ch8 is\n                     and then Is_Compilation_Unit\n                      (Generic_Parent (Parent (Entity (Prefix (N)))))\n                   then\n-                     Error_Msg_NE\n-                      (\"\\possible missing with clause on child unit&\",\n-                        N, Selector);\n+                     Error_Msg_Node_2 := Selector;\n+                     Error_Msg_N (\"\\missing `WITH &.&;`\", Prefix (N));\n                   end if;\n                end if;\n             end if;\n@@ -4076,10 +4091,10 @@ package body Sem_Ch8 is\n         and then Is_Remote_Access_To_Subprogram_Type (Id)\n         and then Present (Equivalent_Type (Id))\n       then\n-         --  If we are not actually generating distribution code (i.e.\n-         --  the current PCS is the dummy non-distributed version), then\n-         --  the Equivalent_Type will be missing, and Id should be treated\n-         --  as a regular access-to-subprogram type.\n+         --  If we are not actually generating distribution code (i.e. the\n+         --  current PCS is the dummy non-distributed version), then the\n+         --  Equivalent_Type will be missing, and Id should be treated as\n+         --  a regular access-to-subprogram type.\n \n          Id := Equivalent_Type (Id);\n          Set_Chars (Selector, Chars (Id));\n@@ -4111,8 +4126,8 @@ package body Sem_Ch8 is\n                     and then\n                       Nkind (Parent (Parent (N))) /= N_Attribute_Reference))\n       then\n-         --  It is an entry call after all, either to the current task\n-         --  (which will deadlock) or to an enclosing task.\n+         --  It is an entry call after all, either to the current task (which\n+         --  will deadlock) or to an enclosing task.\n \n          Analyze_Selected_Component (N);\n          return;\n@@ -4121,8 +4136,8 @@ package body Sem_Ch8 is\n       Change_Selected_Component_To_Expanded_Name (N);\n \n       --  Do style check and generate reference, but skip both steps if this\n-      --  entity has homonyms, since we may not have the right homonym set\n-      --  yet. The proper homonym will be set during the resolve phase.\n+      --  entity has homonyms, since we may not have the right homonym set yet.\n+      --  The proper homonym will be set during the resolve phase.\n \n       if Has_Homonym (Id) then\n          Set_Entity (N, Id);\n@@ -4137,8 +4152,8 @@ package body Sem_Ch8 is\n          Set_Etype (N, Get_Full_View (Etype (Id)));\n       end if;\n \n-      --  If the Ekind of the entity is Void, it means that all homonyms\n-      --  are hidden from all visibility (RM 8.3(5,14-20)).\n+      --  If the Ekind of the entity is Void, it means that all homonyms are\n+      --  hidden from all visibility (RM 8.3(5,14-20)).\n \n       if Ekind (Id) = E_Void then\n          Premature_Usage (N);\n@@ -4163,8 +4178,8 @@ package body Sem_Ch8 is\n                H := Homonym (H);\n             end loop;\n \n-            --  If an extension of System is present, collect possible\n-            --  explicit overloadings declared in the extension.\n+            --  If an extension of System is present, collect possible explicit\n+            --  overloadings declared in the extension.\n \n             if Chars (P_Name) = Name_System\n               and then Scope (P_Name) = Standard_Standard\n@@ -4187,11 +4202,11 @@ package body Sem_Ch8 is\n       if Nkind (Selector_Name (N)) = N_Operator_Symbol\n         and then Scope (Id) /= Standard_Standard\n       then\n-         --  In addition to user-defined operators in the given scope,\n-         --  there may be an implicit instance of the predefined\n-         --  operator. The operator (defined in Standard) is found\n-         --  in Has_Implicit_Operator, and added to the interpretations.\n-         --  Procedure Add_One_Interp will determine which hides which.\n+         --  In addition to user-defined operators in the given scope, there\n+         --  may be an implicit instance of the predefined operator. The\n+         --  operator (defined in Standard) is found in Has_Implicit_Operator,\n+         --  and added to the interpretations. Procedure Add_One_Interp will\n+         --  determine which hides which.\n \n          if Has_Implicit_Operator (N) then\n             null;\n@@ -4224,24 +4239,23 @@ package body Sem_Ch8 is\n       --  to this enclosing instance, we know that the default was properly\n       --  resolved when analyzing the generic, so we prefer the local\n       --  candidates to those that are external. This is not always the case\n-      --  but is a reasonable heuristic on the use of nested generics.\n-      --  The proper solution requires a full renaming model.\n+      --  but is a reasonable heuristic on the use of nested generics. The\n+      --  proper solution requires a full renaming model.\n \n       function Is_Visible_Operation (Op : Entity_Id) return Boolean;\n       --  If the renamed entity is an implicit operator, check whether it is\n-      --  visible because its operand type is properly visible. This\n-      --  check applies to explicit renamed entities that appear in the\n-      --  source in a renaming declaration or a formal subprogram instance,\n-      --  but not to default generic actuals with a name.\n+      --  visible because its operand type is properly visible. This check\n+      --  applies to explicit renamed entities that appear in the source in a\n+      --  renaming declaration or a formal subprogram instance, but not to\n+      --  default generic actuals with a name.\n \n       function Report_Overload return Entity_Id;\n       --  List possible interpretations, and specialize message in the\n       --  case of a generic actual.\n \n       function Within (Inner, Outer : Entity_Id) return Boolean;\n-      --  Determine whether a candidate subprogram is defined within\n-      --  the enclosing instance. If yes, it has precedence over outer\n-      --  candidates.\n+      --  Determine whether a candidate subprogram is defined within the\n+      --  enclosing instance. If yes, it has precedence over outer candidates.\n \n       ------------------------\n       -- Enclosing_Instance --\n@@ -4258,9 +4272,7 @@ package body Sem_Ch8 is\n          end if;\n \n          S := Scope (Current_Scope);\n-\n          while S /= Standard_Standard loop\n-\n             if Is_Generic_Instance (S) then\n                return S;\n             end if;\n@@ -4335,9 +4347,10 @@ package body Sem_Ch8 is\n       ------------\n \n       function Within (Inner, Outer : Entity_Id) return Boolean is\n-         Sc : Entity_Id := Scope (Inner);\n+         Sc : Entity_Id;\n \n       begin\n+         Sc := Scope (Inner);\n          while Sc /= Standard_Standard loop\n             if Sc = Outer then\n                return True;\n@@ -4392,9 +4405,7 @@ package body Sem_Ch8 is\n \n       else\n          Get_First_Interp (Nam, Ind, It);\n-\n          while Present (It.Nam) loop\n-\n             if Entity_Matches_Spec (It.Nam, New_S)\n                and then Is_Visible_Operation (It.Nam)\n             then\n@@ -4407,17 +4418,13 @@ package body Sem_Ch8 is\n                   It1 := Disambiguate (Nam, I1, Ind, Etype (Old_S));\n \n                   if It1 = No_Interp then\n-\n                      Inst := Enclosing_Instance;\n \n                      if Present (Inst) then\n-\n                         if Within (It.Nam, Inst) then\n                            return (It.Nam);\n-\n                         elsif Within (Old_S, Inst) then\n                            return (Old_S);\n-\n                         else\n                            return Report_Overload;\n                         end if;\n@@ -4476,10 +4483,10 @@ package body Sem_Ch8 is\n       if Nkind (P) = N_Error then\n          return;\n \n-      --  If the selector already has an entity, the node has been\n-      --  constructed in the course of expansion, and is known to be\n-      --  valid. Do not verify that it is defined for the type (it may\n-      --  be a private component used in the expansion of record equality).\n+      --  If the selector already has an entity, the node has been constructed\n+      --  in the course of expansion, and is known to be valid. Do not verify\n+      --  that it is defined for the type (it may be a private component used\n+      --  in the expansion of record equality).\n \n       elsif Present (Entity (Selector_Name (N))) then\n \n@@ -4566,7 +4573,6 @@ package body Sem_Ch8 is\n             declare\n                Typ  : constant Entity_Id := Etype (N);\n                Decl : constant Node_Id   := Declaration_Node (Typ);\n-\n             begin\n                if Nkind (Decl) = N_Subtype_Declaration\n                  and then not Analyzed (Decl)\n@@ -4660,9 +4666,7 @@ package body Sem_Ch8 is\n \n                begin\n                   Get_First_Interp (P, Ind, It);\n-\n                   while Present (It.Nam) loop\n-\n                      if In_Open_Scopes (It.Nam) then\n                         if Found then\n                            Error_Msg_N (\n@@ -4690,16 +4694,15 @@ package body Sem_Ch8 is\n             else\n                --  If no interpretation as an expanded name is possible, it\n                --  must be a selected component of a record returned by a\n-               --  function call. Reformat prefix as a function call, the\n-               --  rest is done by type resolution. If the prefix is a\n-               --  procedure or entry, as is P.X;  this is an error.\n+               --  function call. Reformat prefix as a function call, the rest\n+               --  is done by type resolution. If the prefix is procedure or\n+               --  entry, as is P.X; this is an error.\n \n                if Ekind (P_Name) /= E_Function\n                  and then (not Is_Overloaded (P)\n                              or else\n                            Nkind (Parent (N)) = N_Procedure_Call_Statement)\n                then\n-\n                   --  Prefix may mention a package that is hidden by a local\n                   --  declaration: let the user know. Scan the full homonym\n                   --  chain, the candidate package may be anywhere on it.\n@@ -4824,9 +4827,9 @@ package body Sem_Ch8 is\n \n             T := Base_Type (Entity (Prefix (N)));\n \n-            --  Case type is not known to be tagged. Its appearance in\n-            --  the prefix of the 'Class attribute indicates that the full\n-            --  view will be tagged.\n+            --  Case type is not known to be tagged. Its appearance in the\n+            --  prefix of the 'Class attribute indicates that the full view\n+            --  will be tagged.\n \n             if not Is_Tagged_Type (T) then\n                if Ekind (T) = E_Incomplete_Type then\n@@ -4844,14 +4847,13 @@ package body Sem_Ch8 is\n                  and then not Is_Generic_Type (T)\n                  and then In_Private_Part (Scope (T))\n                then\n-                  --  The Class attribute can be applied to an untagged\n-                  --  private type fulfilled by a tagged type prior to\n-                  --  the full type declaration (but only within the\n-                  --  parent package's private part). Create the class-wide\n-                  --  type now and check that the full type is tagged\n-                  --  later during its analysis. Note that we do not\n-                  --  mark the private type as tagged, unlike the case\n-                  --  of incomplete types, because the type must still\n+                  --  The Class attribute can be applied to an untagged private\n+                  --  type fulfilled by a tagged type prior to the full type\n+                  --  declaration (but only within the parent package's private\n+                  --  part). Create the class-wide type now and check that the\n+                  --  full type is tagged later during its analysis. Note that\n+                  --  we do not mark the private type as tagged, unlike the\n+                  --  case of incomplete types, because the type must still\n                   --  appear untagged to outside units.\n \n                   if No (Class_Wide_Type (T)) then\n@@ -4862,8 +4864,8 @@ package body Sem_Ch8 is\n                   Set_Etype  (N, Class_Wide_Type (T));\n \n                else\n-                  --  Should we introduce a type Any_Tagged and use\n-                  --  Wrong_Type here, it would be a bit more consistent???\n+                  --  Should we introduce a type Any_Tagged and use Wrong_Type\n+                  --  here, it would be a bit more consistent???\n \n                   Error_Msg_NE\n                     (\"tagged type required, found}\",\n@@ -5198,7 +5200,6 @@ package body Sem_Ch8 is\n    --  Start of processing for Has_Implicit_Operator\n \n    begin\n-\n       if Ekind (P) = E_Package\n         and then not In_Open_Scopes (P)\n       then\n@@ -5214,9 +5215,7 @@ package body Sem_Ch8 is\n          --  array of Boolean type.\n \n          when Name_Op_And | Name_Op_Not | Name_Op_Or  | Name_Op_Xor =>\n-\n             while Id  /= Priv_Id loop\n-\n                if Valid_Boolean_Arg (Id)\n                  and then Id = Base_Type (Id)\n                then\n@@ -5230,9 +5229,7 @@ package body Sem_Ch8 is\n          --  Equality: look for any non-limited type (result is Boolean)\n \n          when Name_Op_Eq | Name_Op_Ne =>\n-\n             while Id  /= Priv_Id loop\n-\n                if Is_Type (Id)\n                  and then not Is_Limited_Type (Id)\n                  and then Id = Base_Type (Id)\n@@ -5247,7 +5244,6 @@ package body Sem_Ch8 is\n          --  Comparison operators: scalar type, or array of scalar\n \n          when Name_Op_Lt | Name_Op_Le | Name_Op_Gt | Name_Op_Ge =>\n-\n             while Id  /= Priv_Id loop\n                if (Is_Scalar_Type (Id)\n                  or else (Is_Array_Type (Id)\n@@ -5271,7 +5267,6 @@ package body Sem_Ch8 is\n               Name_Op_Multiply |\n               Name_Op_Divide   |\n               Name_Op_Expon    =>\n-\n             while Id  /= Priv_Id loop\n                if Is_Numeric_Type (Id)\n                  and then Id = Base_Type (Id)\n@@ -5286,7 +5281,6 @@ package body Sem_Ch8 is\n          --  Concatenation: any one-dimensional array type\n \n          when Name_Op_Concat =>\n-\n             while Id  /= Priv_Id loop\n                if Is_Array_Type (Id) and then Number_Dimensions (Id) = 1\n                  and then Id = Base_Type (Id)\n@@ -5302,7 +5296,6 @@ package body Sem_Ch8 is\n          --  subtype of Name_Id that would restrict to operators ???\n \n          when others => null;\n-\n       end case;\n \n       --  If we fall through, then we do not have an implicit operator\n@@ -5354,7 +5347,6 @@ package body Sem_Ch8 is\n \n    begin\n       if Ekind (Old_S) = E_Operator then\n-\n          New_F := First_Formal (New_S);\n \n          while Present (New_F) loop\n@@ -5414,23 +5406,22 @@ package body Sem_Ch8 is\n      (Clause             : Node_Id;\n       Force_Installation : Boolean := False)\n    is\n-      U  : Node_Id := Clause;\n+      U  : Node_Id;\n       P  : Node_Id;\n       Id : Entity_Id;\n \n    begin\n+      U := Clause;\n       while Present (U) loop\n \n          --  Case of USE package\n \n          if Nkind (U) = N_Use_Package_Clause then\n             P := First (Names (U));\n-\n             while Present (P) loop\n                Id := Entity (P);\n \n                if Ekind (Id) = E_Package then\n-\n                   if In_Use (Id) then\n                      Note_Redundant_Use (P);\n \n@@ -5448,11 +5439,10 @@ package body Sem_Ch8 is\n                Next (P);\n             end loop;\n \n-         --  case of USE TYPE\n+         --  Case of USE TYPE\n \n          else\n             P := First (Subtype_Marks (U));\n-\n             while Present (P) loop\n                if not Is_Entity_Name (P)\n                  or else No (Entity (P))\n@@ -5496,11 +5486,19 @@ package body Sem_Ch8 is\n       --  Determine if given type has components (i.e. is either a record\n       --  type or a type that has discriminants).\n \n+      --------------------\n+      -- Has_Components --\n+      --------------------\n+\n       function Has_Components (T1 : Entity_Id) return Boolean is\n       begin\n          return Is_Record_Type (T1)\n            or else (Is_Private_Type (T1) and then Has_Discriminants (T1))\n-           or else (Is_Task_Type (T1) and then Has_Discriminants (T1));\n+           or else (Is_Task_Type (T1) and then Has_Discriminants (T1))\n+           or else (Is_Incomplete_Type (T1)\n+                     and then From_With_Type (T1)\n+                     and then Present (Non_Limited_View (T1))\n+                     and then Is_Record_Type (Non_Limited_View (T1)));\n       end Has_Components;\n \n    --  Start of processing for Is_Appropriate_For_Record\n@@ -5509,9 +5507,8 @@ package body Sem_Ch8 is\n       return\n         Present (T)\n           and then (Has_Components (T)\n-                      or else (Is_Access_Type (T)\n-                                 and then\n-                                   Has_Components (Designated_Type (T))));\n+                     or else (Is_Access_Type (T)\n+                               and then Has_Components (Designated_Type (T))));\n    end Is_Appropriate_For_Record;\n \n    ---------------\n@@ -5845,10 +5842,10 @@ package body Sem_Ch8 is\n \n    begin\n       --  Within an instance, the analysis of the actual for a formal object\n-      --  does not see the name of the object itself. This is significant\n-      --  only if the object is an aggregate, where its analysis does not do\n-      --  any name resolution on component associations. (see 4717-008). In\n-      --  such a case, look for the visible homonym on the chain.\n+      --  does not see the name of the object itself. This is significant only\n+      --  if the object is an aggregate, where its analysis does not do any\n+      --  name resolution on component associations. (see 4717-008). In such a\n+      --  case, look for the visible homonym on the chain.\n \n       if In_Instance\n         and then Present (Homonym (E))\n@@ -5907,7 +5904,7 @@ package body Sem_Ch8 is\n       The_Unit : Node_Id;\n \n       function Find_System (C_Unit : Node_Id) return Entity_Id;\n-      --  Scan context clause of compilation unit to find a with_clause\n+      --  Scan context clause of compilation unit to find with_clause\n       --  for System.\n \n       -----------------\n@@ -5919,7 +5916,6 @@ package body Sem_Ch8 is\n \n       begin\n          With_Clause := First (Context_Items (C_Unit));\n-\n          while Present (With_Clause) loop\n             if (Nkind (With_Clause) = N_With_Clause\n               and then Chars (Name (With_Clause)) = Name_System)\n@@ -6007,21 +6003,20 @@ package body Sem_Ch8 is\n             System_Aux_Id :=\n               Defining_Entity (Specification (Unit (Cunit (Unum))));\n \n-            Withn := Make_With_Clause (Loc,\n-              Name =>\n-                Make_Expanded_Name (Loc,\n-                  Chars  => Chars (System_Aux_Id),\n-                  Prefix =>\n-                    New_Reference_To (Scope (System_Aux_Id), Loc),\n-                  Selector_Name =>\n-                    New_Reference_To (System_Aux_Id, Loc)));\n+            Withn :=\n+              Make_With_Clause (Loc,\n+                Name =>\n+                  Make_Expanded_Name (Loc,\n+                    Chars  => Chars (System_Aux_Id),\n+                    Prefix => New_Reference_To (Scope (System_Aux_Id), Loc),\n+                    Selector_Name => New_Reference_To (System_Aux_Id, Loc)));\n \n             Set_Entity (Name (Withn), System_Aux_Id);\n \n-            Set_Library_Unit          (Withn, Cunit (Unum));\n-            Set_Corresponding_Spec    (Withn, System_Aux_Id);\n-            Set_First_Name            (Withn, True);\n-            Set_Implicit_With         (Withn, True);\n+            Set_Library_Unit       (Withn, Cunit (Unum));\n+            Set_Corresponding_Spec (Withn, System_Aux_Id);\n+            Set_First_Name         (Withn, True);\n+            Set_Implicit_With      (Withn, True);\n \n             Insert_After (With_Sys, Withn);\n             Mark_Rewrite_Insertion (Withn);\n@@ -6077,7 +6072,6 @@ package body Sem_Ch8 is\n             end if;\n \n             E := First_Entity (S);\n-\n             while Present (E) loop\n                if Is_Child_Unit (E) then\n                   Set_Is_Immediately_Visible (E,\n@@ -6097,9 +6091,7 @@ package body Sem_Ch8 is\n             --  must be restored in any case. Their declarations may appear\n             --  after the private part of the parent.\n \n-            if not Full_Vis\n-              and then Present (E)\n-            then\n+            if not Full_Vis then\n                while Present (E) loop\n                   if Is_Child_Unit (E) then\n                      Set_Is_Immediately_Visible (E,\n@@ -6171,18 +6163,18 @@ package body Sem_Ch8 is\n             End_Use_Clauses (Scope_Stack.Table (SS_Last).First_Use_Clause);\n          end if;\n \n-         --  If the call is from within a compilation unit, as when\n-         --  called from Rtsfind, make current entries in scope stack\n-         --  invisible while we analyze the new unit.\n+         --  If the call is from within a compilation unit, as when called from\n+         --  Rtsfind, make current entries in scope stack invisible while we\n+         --  analyze the new unit.\n \n          for J in reverse 0 .. SS_Last loop\n             exit when  Scope_Stack.Table (J).Entity = Standard_Standard\n                or else No (Scope_Stack.Table (J).Entity);\n \n             S := Scope_Stack.Table (J).Entity;\n             Set_Is_Immediately_Visible (S, False);\n-            E := First_Entity (S);\n \n+            E := First_Entity (S);\n             while Present (E) loop\n                Set_Is_Immediately_Visible (E, False);\n                Next_Entity (E);\n@@ -6205,12 +6197,11 @@ package body Sem_Ch8 is\n    begin\n       if Present (L) then\n          Decl := First (L);\n-\n          while Present (Decl) loop\n             if Nkind (Decl) = N_Use_Package_Clause then\n                Chain_Use_Clause (Decl);\n-               Pack_Name := First (Names (Decl));\n \n+               Pack_Name := First (Names (Decl));\n                while Present (Pack_Name) loop\n                   Pack := Entity (Pack_Name);\n \n@@ -6225,8 +6216,8 @@ package body Sem_Ch8 is\n \n             elsif Nkind (Decl) = N_Use_Type_Clause  then\n                Chain_Use_Clause (Decl);\n-               Id := First (Subtype_Marks (Decl));\n \n+               Id := First (Subtype_Marks (Decl));\n                while Present (Id) loop\n                   if Entity (Id) /= Any_Type then\n                      Use_One_Type (Id);\n@@ -6270,7 +6261,6 @@ package body Sem_Ch8 is\n \n       if In_Instance then\n          Current_Instance := Current_Scope;\n-\n          while not Is_Generic_Instance (Current_Instance) loop\n             Current_Instance := Scope (Current_Instance);\n          end loop;\n@@ -6314,7 +6304,6 @@ package body Sem_Ch8 is\n                     or else Private_With_OK) -- Ada 2005 (AI-262)\n       loop\n          Prev := Current_Entity (Id);\n-\n          while Present (Prev) loop\n             if Is_Immediately_Visible (Prev)\n               and then (not Is_Overloadable (Prev)\n@@ -6327,13 +6316,12 @@ package body Sem_Ch8 is\n \n                   goto Next_Usable_Entity;\n \n-               --  A use clause within an instance hides outer global\n-               --  entities, which are not used to resolve local entities\n-               --  in the instance. Note that the predefined entities in\n-               --  Standard could not have been hidden in the generic by\n-               --  a use clause, and therefore remain visible. Other\n-               --  compilation units whose entities appear in Standard must\n-               --  be hidden in an instance.\n+               --  A use clause within an instance hides outer global entities,\n+               --  which are not used to resolve local entities in the\n+               --  instance. Note that the predefined entities in Standard\n+               --  could not have been hidden in the generic by a use clause,\n+               --  and therefore remain visible. Other compilation units whose\n+               --  entities appear in Standard must be hidden in an instance.\n \n                --  To determine whether an entity is external to the instance\n                --  we compare the scope depth of its scope with that of the\n@@ -6359,13 +6347,12 @@ package body Sem_Ch8 is\n                   Append_Elmt (Prev, Hidden_By_Use_Clause (N));\n                end if;\n \n-            --  A user-defined operator is not use-visible if the\n-            --  predefined operator for the type is immediately visible,\n-            --  which is the case if the type of the operand is in an open\n-            --  scope. This does not apply to user-defined operators that\n-            --  have operands of different types, because the predefined\n-            --  mixed mode operations (multiplication and division) apply to\n-            --  universal types and do not hide anything.\n+            --  A user-defined operator is not use-visible if the predefined\n+            --  operator for the type is immediately visible, which is the case\n+            --  if the type of the operand is in an open scope. This does not\n+            --  apply to user-defined operators that have operands of different\n+            --  types, because the predefined mixed mode operations (multiply\n+            --  and divide) apply to universal types and do not hide anything.\n \n             elsif Ekind (Prev) = E_Operator\n               and then Operator_Matches_Spec (Prev, Id)\n@@ -6401,11 +6388,10 @@ package body Sem_Ch8 is\n             Next_Entity (Id);\n       end loop;\n \n-      --  Child units are also made use-visible by a use clause, but they\n-      --  may appear after all visible declarations in the parent entity list.\n+      --  Child units are also made use-visible by a use clause, but they may\n+      --  appear after all visible declarations in the parent entity list.\n \n       while Present (Id) loop\n-\n          if Is_Child_Unit (Id)\n            and then Is_Visible_Child_Unit (Id)\n          then\n@@ -6460,10 +6446,9 @@ package body Sem_Ch8 is\n       elsif not Redundant_Use (Id) then\n          Set_In_Use (T);\n          Op_List := Collect_Primitive_Operations (T);\n-         Elmt := First_Elmt (Op_List);\n \n+         Elmt := First_Elmt (Op_List);\n          while Present (Elmt) loop\n-\n             if (Nkind (Node (Elmt)) = N_Defining_Operator_Symbol\n                  or else Chars (Node (Elmt)) in Any_Operator_Name)\n               and then not Is_Hidden (Node (Elmt))\n@@ -6525,7 +6510,6 @@ package body Sem_Ch8 is\n \n    procedure Write_Scopes is\n       S : Entity_Id;\n-\n    begin\n       for J in reverse 1 .. Scope_Stack.Last loop\n          S :=  Scope_Stack.Table (J).Entity;"}]}