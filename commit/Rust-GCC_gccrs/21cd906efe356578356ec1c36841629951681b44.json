{"sha": "21cd906efe356578356ec1c36841629951681b44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjFjZDkwNmVmZTM1NjU3ODM1NmVjMWMzNjg0MTYyOTk1MTY4MWI0NA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-09-07T15:20:58Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-07T15:20:58Z"}, "message": "emit-rtl.c (free_emit_status): Take decl as a parameter.\n\n\t* emit-rtl.c (free_emit_status): Take decl as a parameter.\n\t(init_emit_once): Add more GC roots.\n\t* except.c (mark_func_eh_entry): New function.\n\t(mark_eh_node): Mark false_label and rethrow_label.\n\t(init_eh): Add more GC roots.\n\t* function.c (free_after_compilation): Take decl as a paramter.\n\tCall free_stmt_status.\n\t(mark_function_state): Don't assume x_parm_reg_stack_loc is\n\tnon-NULL.\n\t* function.h (free_after_compilation): Change prototype.\n\t(free_varasm_status): Likewise.\n\t(free_emit_status): Likewise.\n\t(free_stmt_status): New function.\n\t* ggc-simple.c (rtx, vecs, trees, strings, bytes_alloced_since_gc):\n\tRemove, replacing with ...\n\t(ggc_status): New structure.\n\t(ggc_chain): New variable.\n\t(init_gcc): Define.\n\t(ggc_push_context): New function.\n\t(ggc_pop_context): Likewise.\n\t(ggc_alloc_rtx): Adjust for use of ggc_chain.\n\t(ggc_alloc_rtvec): Likewise.\n\t(ggc_alloc_tree): Likewise.\n\t(ggc_alloc_string): Likewise.\n\t(ggc_mark_rtx): Mark NOTE_SOURCE_FILE and NOTE_RANGE_INFO.\n\t(ggc_mark_tree): Give language-dependent code a chance to mark\n\t`x' nodes.\n\t(ggc_mark_tree_varray): Handle empty arrays.\n\t(ggc_collect): Adjust for use of ggc_chain.  Clear\n\tbytes_alloced_since_last_gc.\n\t* ggc.h (ggc_pop_context): New function.\n\t(ggc_push_context): Likewise.\n\t* print-tree.c (print_node): Don't print obstacks when GC'ing.\n\t* stmt.c (free_stmt_status): New function.\n\t(init_stmt_for_function): Clear last_expr_value.\n\t* toplev.c (rest_of_compilation): Always call free_after_compilation.\n\tConditionalize call to ggc_collect.\n\t(main): Call init_ggc.\n\t* tree.c (push_obstacks): Do the push, even when GC'ing.\n\t(push_obstacks_nochange): Likewise.\n\t(pop_obstacks): Liekwise.\n\t* varasm.c (free_varasm_status): Take decl as a parameter.\n\nFrom-SVN: r29170", "tree": {"sha": "ebef7e81648f072e4f956a33a801979f7a35c649", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebef7e81648f072e4f956a33a801979f7a35c649"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21cd906efe356578356ec1c36841629951681b44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21cd906efe356578356ec1c36841629951681b44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21cd906efe356578356ec1c36841629951681b44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21cd906efe356578356ec1c36841629951681b44/comments", "author": null, "committer": null, "parents": [{"sha": "498ffa68acb51d998126df401a801b8cdf55f152", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/498ffa68acb51d998126df401a801b8cdf55f152", "html_url": "https://github.com/Rust-GCC/gccrs/commit/498ffa68acb51d998126df401a801b8cdf55f152"}], "stats": {"total": 390, "additions": 317, "deletions": 73}, "files": [{"sha": "5bc407cec5789b40e334c160c270cb43324b560e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 2, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21cd906efe356578356ec1c36841629951681b44/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21cd906efe356578356ec1c36841629951681b44/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=21cd906efe356578356ec1c36841629951681b44", "patch": "@@ -1,3 +1,48 @@\n+Tue Sep  7 00:47:52 1999  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* emit-rtl.c (free_emit_status): Take decl as a parameter.\n+\t(init_emit_once): Add more GC roots.\n+\t* except.c (mark_func_eh_entry): New function.\n+\t(mark_eh_node): Mark false_label and rethrow_label.\n+\t(init_eh): Add more GC roots.\n+\t* function.c (free_after_compilation): Take decl as a paramter.\n+\tCall free_stmt_status.\n+\t(mark_function_state): Don't assume x_parm_reg_stack_loc is\n+\tnon-NULL.\n+\t* function.h (free_after_compilation): Change prototype.\n+\t(free_varasm_status): Likewise.\n+\t(free_emit_status): Likewise.\n+\t(free_stmt_status): New function.\n+\t* ggc-simple.c (rtx, vecs, trees, strings, bytes_alloced_since_gc): \n+\tRemove, replacing with ...\n+\t(ggc_status): New structure.\n+\t(ggc_chain): New variable.\n+\t(init_gcc): Define.\n+\t(ggc_push_context): New function.\n+\t(ggc_pop_context): Likewise.\n+\t(ggc_alloc_rtx): Adjust for use of ggc_chain.\n+\t(ggc_alloc_rtvec): Likewise.\n+\t(ggc_alloc_tree): Likewise.\n+\t(ggc_alloc_string): Likewise.\n+\t(ggc_mark_rtx): Mark NOTE_SOURCE_FILE and NOTE_RANGE_INFO.\n+\t(ggc_mark_tree): Give language-dependent code a chance to mark\n+\t`x' nodes.\n+\t(ggc_mark_tree_varray): Handle empty arrays.\n+\t(ggc_collect): Adjust for use of ggc_chain.  Clear\n+\tbytes_alloced_since_last_gc.\n+\t* ggc.h (ggc_pop_context): New function.\n+\t(ggc_push_context): Likewise.\n+\t* print-tree.c (print_node): Don't print obstacks when GC'ing.\n+\t* stmt.c (free_stmt_status): New function.\n+\t(init_stmt_for_function): Clear last_expr_value.\n+\t* toplev.c (rest_of_compilation): Always call free_after_compilation.\n+\tConditionalize call to ggc_collect.\n+\t(main): Call init_ggc.\n+\t* tree.c (push_obstacks): Do the push, even when GC'ing.\n+\t(push_obstacks_nochange): Likewise.\n+\t(pop_obstacks): Liekwise.\n+\t* varasm.c (free_varasm_status): Take decl as a parameter.\n+\t\n Tue Sep  7 08:15:49 1999  Gavin Romig-Koch  <gavin@cygnus.com>\n \n \t* config/mips/mips.h (MULTILIB_ENDIAN_DEFAULT) : New macro.\n@@ -155,7 +200,6 @@ Mon Sep  6 14:30:13 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t(ix86_mark_machine_status): New function.\n \t(override_options): Set mark_machine_status.\n \n->>>>>>> 1.4290\n Mon Sep  6 15:26:23 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \t* tree.c (copy_node): Copy node contents also if doing GC.\n@@ -166,7 +210,6 @@ Mon Sep  6 08:42:06 1999  Alexandre Oliva  <oliva@dcc.unicamp.br>\n \n Mon Sep  6 02:42:36 1999  Jeffrey A Law  (law@cygnus.com)\n \n->>>>>>> 1.4287\n \t* collect2.c (scan_libraries): Fix thinko.\n \n \t* cse.c (delete_trivially_dead_insns): Do not skip the last"}, {"sha": "9837b6811b0d3b3b2acf769e25f3d104aa38ca4c", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21cd906efe356578356ec1c36841629951681b44/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21cd906efe356578356ec1c36841629951681b44/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=21cd906efe356578356ec1c36841629951681b44", "patch": "@@ -1607,13 +1607,19 @@ restore_emit_status (p)\n   clear_emit_caches ();\n }\n \n-/* Clear out all parts of our state in F that can safely be discarded\n+/* Clear out all parts of the state in F that can safely be discarded\n    after the function has been compiled, to let garbage collection\n-   reclaim the memory.  */\n+   reclaim the memory.  D is the declaration for the function just\n+   compiled.  Its output may have been deferred.  */\n+\n void\n-free_emit_status (f)\n+free_emit_status (f, d)\n      struct function *f;\n+     tree d;\n {\n+  if (DECL_DEFER_OUTPUT (d))\n+    return;\n+\n   free (f->emit->x_regno_reg_rtx);\n   free (f->emit->regno_pointer_flag);\n   free (f->emit->regno_pointer_align);\n@@ -3693,6 +3699,7 @@ init_emit_once (line_numbers)\n \n   ggc_add_rtx_root (&const_tiny_rtx[0][0], sizeof(const_tiny_rtx)/sizeof(rtx));\n \n+  ggc_add_rtx_root (&const_true_rtx, 1);\n   ggc_add_rtx_root (&pic_offset_table_rtx, 1);\n   ggc_add_rtx_root (&struct_value_rtx, 1);\n   ggc_add_rtx_root (&struct_value_incoming_rtx, 1);"}, {"sha": "4bb2adb9e705012b43d23b7ab168a94d828ee4ab", "filename": "gcc/except.c", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21cd906efe356578356ec1c36841629951681b44/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21cd906efe356578356ec1c36841629951681b44/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=21cd906efe356578356ec1c36841629951681b44", "patch": "@@ -472,6 +472,7 @@ static void mark_eh_node        PROTO((struct eh_node *));\n static void mark_eh_stack       PROTO((struct eh_stack *));\n static void mark_eh_queue       PROTO((struct eh_queue *));\n static void mark_tree_label_node PROTO ((struct label_node *));\n+static void mark_func_eh_entry PROTO ((void *));\n \n rtx expand_builtin_return_addr\tPROTO((enum built_in_function, int, rtx));\n \f\n@@ -2347,6 +2348,8 @@ mark_eh_node (node)\n \t  ggc_mark_rtx (node->entry->outer_context);\n \t  ggc_mark_rtx (node->entry->exception_handler_label);\n \t  ggc_mark_tree (node->entry->finalization);\n+\t  ggc_mark_rtx (node->entry->false_label);\n+\t  ggc_mark_rtx (node->entry->rethrow_label);\n \t}\n       node = node ->chain;\n     }\n@@ -2405,6 +2408,33 @@ mark_eh_state (eh)\n   ggc_mark_rtx (eh->x_eh_return_stub_label);\n }\n \n+/* Mark ARG (which is really a struct func_eh_entry**) for GC.  */\n+\n+static void \n+mark_func_eh_entry (arg)\n+     void *arg;\n+{\n+  struct func_eh_entry *fee;\n+  struct handler_info *h;\n+  int i;\n+\n+  fee = *((struct func_eh_entry **) arg);\n+\n+  for (i = 0; i < current_func_eh_entry; ++i)\n+    {\n+      ggc_mark_rtx (fee->rethrow_label);\n+      for (h = fee->handlers; h; h = h->next)\n+\t{\n+\t  ggc_mark_rtx (h->handler_label);\n+\t  if (h->type_info != CATCH_ALL_TYPE)\n+\t    ggc_mark_tree ((tree) h->type_info);\n+\t}\n+\n+      /* Skip to the next entry in the array.  */\n+      ++fee;\n+    }\n+}\n+\n /* This group of functions initializes the exception handling data\n    structures at the start of the compilation, initializes the data\n    structures at the start of a function, and saves and restores the\n@@ -2419,8 +2449,18 @@ init_eh ()\n   first_rethrow_symbol = create_rethrow_ref (0);\n   final_rethrow = gen_exception_label ();\n   last_rethrow_symbol = create_rethrow_ref (CODE_LABEL_NUMBER (final_rethrow));\n-}\n \n+  ggc_add_rtx_root (&exception_handler_labels, 1);\n+  ggc_add_rtx_root (&eh_return_context, 1);\n+  ggc_add_rtx_root (&eh_return_stack_adjust, 1);\n+  ggc_add_rtx_root (&eh_return_handler, 1);\n+  ggc_add_rtx_root (&first_rethrow_symbol, 1);\n+  ggc_add_rtx_root (&final_rethrow, 1);\n+  ggc_add_rtx_root (&last_rethrow_symbol, 1);\n+  ggc_add_root (&function_eh_regions, 1, sizeof (function_eh_regions),\n+\t\tmark_func_eh_entry);\n+}\n+  \n /* Initialize the per-function EH information.  */\n \n void"}, {"sha": "4ce2dd5591bbb0f656bf56b77cc934f62a404d6e", "filename": "gcc/function.c", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21cd906efe356578356ec1c36841629951681b44/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21cd906efe356578356ec1c36841629951681b44/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=21cd906efe356578356ec1c36841629951681b44", "patch": "@@ -390,17 +390,23 @@ pop_function_context ()\n \n /* Clear out all parts of the state in F that can safely be discarded\n    after the function has been compiled, to let garbage collection\n-   reclaim the memory.  */\n+   reclaim the memory.  D is the declaration for the function just\n+   compiled.  Its output may have been deferred.  */\n+\n void\n-free_after_compilation (f)\n+free_after_compilation (f, d)\n      struct function *f;\n+     tree d;\n {\n-  free_emit_status (f);\n-  free_varasm_status (f);\n-\n-  free (f->x_parm_reg_stack_loc);\n+  free_emit_status (f, d);\n+  free_varasm_status (f, d);\n+  free_stmt_status (f, d);\n \n-  f->can_garbage_collect = 1;\n+  if (!DECL_DEFER_OUTPUT (d))\n+    {\n+      free (f->x_parm_reg_stack_loc);\n+      f->can_garbage_collect = 1;\n+    }\n }\n \f\n /* Allocate fixed slots in the stack frame of the current function.  */\n@@ -6682,9 +6688,10 @@ mark_function_state (p)\n \n   ggc_mark_rtx (p->arg_offset_rtx);\n \n-  for (i = p->x_max_parm_reg, r = p->x_parm_reg_stack_loc;\n-       i > 0; --i, ++r)\n-    ggc_mark_rtx (*r);\n+  if (p->x_parm_reg_stack_loc)\n+    for (i = p->x_max_parm_reg, r = p->x_parm_reg_stack_loc;\n+\t i > 0; --i, ++r)\n+      ggc_mark_rtx (*r);\n \n   ggc_mark_rtx (p->return_rtx);\n   ggc_mark_rtx (p->x_cleanup_label);"}, {"sha": "76ee362734d490fcdecbcb6b5a8e6874fb3249a4", "filename": "gcc/function.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21cd906efe356578356ec1c36841629951681b44/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21cd906efe356578356ec1c36841629951681b44/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=21cd906efe356578356ec1c36841629951681b44", "patch": "@@ -549,11 +549,16 @@ extern void (*restore_lang_status)\tPROTO((struct function *));\n extern void save_tree_status\t\tPROTO((struct function *));\n extern void restore_tree_status\t\tPROTO((struct function *));\n extern void restore_emit_status\t\tPROTO((struct function *));\n-extern void free_after_compilation\tPROTO((struct function *));\n+extern void free_after_compilation\tPROTO((struct function *,\n+\t\t\t\t\t       tree));\n \n extern void init_varasm_status\t\tPROTO((struct function *));\n-extern void free_varasm_status\t\tPROTO((struct function *));\n-extern void free_emit_status\t\tPROTO((struct function *));\n+extern void free_varasm_status\t\tPROTO((struct function *,\n+\t\t\t\t\t       tree));\n+extern void free_emit_status\t\tPROTO((struct function *,\n+\t\t\t\t\t       tree));\n+extern void free_stmt_status            PROTO((struct function *,\n+\t\t\t\t\t       tree));\n extern rtx get_first_block_beg\t\tPROTO((void));\n \n extern void init_virtual_regs\t\tPROTO((struct emit_status *));"}, {"sha": "41363bc6d309abba29ffddc6a08b520376193326", "filename": "gcc/ggc-simple.c", "status": "modified", "additions": 150, "deletions": 36, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21cd906efe356578356ec1c36841629951681b44/gcc%2Fggc-simple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21cd906efe356578356ec1c36841629951681b44/gcc%2Fggc-simple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-simple.c?ref=21cd906efe356578356ec1c36841629951681b44", "patch": "@@ -50,24 +50,18 @@ struct ggc_rtx\n   struct rtx_def rtx;\n };\n \n-static struct ggc_rtx *rtxs;\n-\n struct ggc_rtvec\n {\n   struct ggc_rtvec *chain;\n   struct rtvec_def vec;\n };\n \n-static struct ggc_rtvec *vecs;\n-\n struct ggc_tree\n {\n   struct ggc_tree *chain;\n   union tree_node tree;\n };\n \n-static struct ggc_tree *trees;\n-\n struct ggc_string\n {\n   struct ggc_string *chain;\n@@ -77,15 +71,26 @@ struct ggc_string\n \n #define GGC_STRING_MAGIC\t((unsigned int)0xa1b2c3d4)\n \n-static struct ggc_string *strings;\n+struct ggc_status\n+{\n+  struct ggc_status *next;\n+  struct ggc_rtx *rtxs;\n+  struct ggc_rtvec *vecs;\n+  struct ggc_tree *trees;\n+  struct ggc_string *strings;\n+  size_t bytes_alloced_since_gc;\n+};\n+\n+/* A chain of GGC contexts.  The currently active context is at the\n+   front of the chain.  */\n+static struct ggc_status *ggc_chain;\n \n /* Some statistics.  */\n \n static int n_rtxs_collected;\n static int n_vecs_collected;\n static int n_trees_collected;\n static int n_strings_collected;\n-static int bytes_alloced_since_gc;\n extern int gc_time;\n \n #ifdef GGC_DUMP\n@@ -103,6 +108,81 @@ static void ggc_mark_tree_hash_table_ptr PROTO ((void *elt));\n static boolean ggc_mark_tree_hash_table_entry PROTO ((struct hash_entry *,\n \t\t\t\t\t\t      hash_table_key));\n \n+/* Called once to initialize the garbage collector.  */\n+\n+void \n+init_ggc PROTO ((void))\n+{\n+  /* Initialize the global context.  */\n+  ggc_push_context ();\n+}\n+\n+/* Start a new GGC context.  Memory allocated in previous contexts\n+   will not be collected while the new context is active.  */\n+\n+void\n+ggc_push_context PROTO ((void))\n+{\n+  struct ggc_status *gs = (struct ggc_status *) xmalloc (sizeof (*gs));\n+  bzero (gs, sizeof (*gs));\n+  gs->next = ggc_chain;\n+  ggc_chain = gs;\n+}\n+\n+/* Finish a GC context.  Any uncollected memory in the new context\n+   will be merged with the old context.  */\n+\n+void \n+ggc_pop_context PROTO ((void))\n+{\n+  struct ggc_rtx *r;\n+  struct ggc_rtvec *v;\n+  struct ggc_tree *t;\n+  struct ggc_string *s;\n+  struct ggc_status *gs;\n+\n+  gs = ggc_chain;\n+\n+  r = gs->rtxs;\n+  if (r)\n+    {\n+      while (r->chain)\n+\tr = r->chain;\n+      r->chain = gs->next->rtxs;\n+      gs->next->rtxs = gs->rtxs;\n+    }\n+      \n+  v = gs->vecs;\n+  if (v)\n+    {\n+      while (v->chain)\n+\tv = v->chain;\n+      v->chain = gs->next->vecs;\n+      gs->next->vecs = gs->vecs;\n+    }\n+\n+  t = gs->trees;\n+  if (t)\n+    {\n+      while (t->chain)\n+\tt = t->chain;\n+      t->chain = gs->next->trees;\n+      gs->next->trees = gs->trees;\n+    }\n+\n+  s = gs->strings;\n+  if (s)\n+    {\n+      while (s->chain)\n+\ts = s->chain;\n+      s->chain = gs->next->strings;\n+      gs->next->strings = gs->strings;\n+    }\n+\n+  ggc_chain = gs->next;\n+  free (gs);\n+}\n+\n /* These allocators are dreadfully simple, with no caching whatsoever so\n    that Purify-like tools that do allocation versioning can catch errors.\n    This collector is never going to go fast anyway.  */\n@@ -116,14 +196,14 @@ ggc_alloc_rtx (nslots)\n \n   n = (struct ggc_rtx *) xmalloc (size);\n   bzero ((char *) n, size);\n-  n->chain = rtxs;\n-  rtxs = n;\n+  n->chain = ggc_chain->rtxs;\n+  ggc_chain->rtxs = n;\n \n #ifdef GGC_DUMP\n   fprintf (dump, \"alloc rtx %p\\n\", &n->rtx);\n #endif\n \n-  bytes_alloced_since_gc += size;\n+  ggc_chain->bytes_alloced_since_gc += size;\n \n   return &n->rtx;\n }\n@@ -137,14 +217,14 @@ ggc_alloc_rtvec (nelt)\n \n   v = (struct ggc_rtvec *) xmalloc (size);\n   bzero ((char *) v, size);\n-  v->chain = vecs;\n-  vecs = v;\n+  v->chain = ggc_chain->vecs;\n+  ggc_chain->vecs = v;\n \n #ifdef GGC_DUMP\n   fprintf(dump, \"alloc vec %p\\n\", &v->vec);\n #endif\n \n-  bytes_alloced_since_gc += size;\n+  ggc_chain->bytes_alloced_since_gc += size;\n \n   return &v->vec;\n }\n@@ -158,14 +238,14 @@ ggc_alloc_tree (length)\n \n   n = (struct ggc_tree *) xmalloc (size);\n   bzero ((char *) n, size);\n-  n->chain = trees;\n-  trees = n;\n+  n->chain = ggc_chain->trees;\n+  ggc_chain->trees = n;\n \n #ifdef GGC_DUMP\n   fprintf(dump, \"alloc tree %p\\n\", &n->tree);\n #endif\n \n-  bytes_alloced_since_gc += size;\n+  ggc_chain->bytes_alloced_since_gc += size;\n \n   return &n->tree;\n }\n@@ -187,18 +267,18 @@ ggc_alloc_string (contents, length)\n \n   size = (s->string - (char *)s) + length + 1;\n   s = (struct ggc_string *) xmalloc(size);\n-  s->chain = strings;\n+  s->chain = ggc_chain->strings;\n   s->magic_mark = GGC_STRING_MAGIC;\n   if (contents)\n     bcopy (contents, s->string, length);\n   s->string[length] = 0;\n-  strings = s;\n+  ggc_chain->strings = s;\n \n #ifdef GGC_DUMP\n   fprintf(dump, \"alloc string %p\\n\", &s->string);\n #endif\n \n-  bytes_alloced_since_gc += size;\n+  ggc_chain->bytes_alloced_since_gc += size;\n \n   return s->string;\n }\n@@ -313,6 +393,21 @@ ggc_mark_rtx (r)\n     case CONST_DOUBLE:\n       ggc_mark_rtx (CONST_DOUBLE_CHAIN (r));\n       break;\n+    case NOTE:\n+      switch (NOTE_LINE_NUMBER (r))\n+\t{\n+\tcase NOTE_INSN_RANGE_START:\n+\tcase NOTE_INSN_RANGE_END:\n+\tcase NOTE_INSN_LIVE:\n+\t  ggc_mark_rtx (NOTE_RANGE_INFO (r));\n+\t  break;\n+\n+\tdefault:\n+\t  if (NOTE_LINE_NUMBER (r) >= 0)\n+\t    ggc_mark_string (NOTE_SOURCE_FILE (r));\n+\t  break;\n+\t}\n+      break;\n \n     default:\n       break;\n@@ -475,6 +570,10 @@ ggc_mark_tree (t)\n \t  ggc_mark_tree (TREE_OPERAND (t, i));\n \tbreak;\n       }\n+\n+    case 'x':\n+      lang_mark_tree (t);\n+      break;\n     }\n }\n \n@@ -486,8 +585,9 @@ ggc_mark_tree_varray (v)\n {\n   int i;\n \n-  for (i = v->num_elements - 1; i >= 0; --i) \n-    ggc_mark_tree (VARRAY_TREE (v, i));\n+  if (v)\n+    for (i = v->num_elements - 1; i >= 0; --i) \n+      ggc_mark_tree (VARRAY_TREE (v, i));\n }\n \n /* Mark the hash table-entry HE.  It's key field is really a tree.  */\n@@ -534,11 +634,12 @@ ggc_collect ()\n   struct ggc_tree *t, **tp;\n   struct ggc_string *s, **sp;\n   struct ggc_root *x;\n+  struct ggc_status *gs;\n   int time, n_rtxs, n_trees, n_vecs, n_strings;\n \n #ifndef ENABLE_CHECKING\n   /* See if it's even worth our while.  */\n-  if (bytes_alloced_since_gc < 64*1024)\n+  if (ggc_chain->bytes_alloced_since_gc < 64*1024)\n     return;\n #endif\n \n@@ -548,14 +649,17 @@ ggc_collect ()\n   time = get_run_time ();\n \n   /* Clean out all of the GC marks.  */\n-  for (r = rtxs; r != NULL; r = r->chain)\n-    r->rtx.gc_mark = 0;\n-  for (v = vecs; v != NULL; v = v->chain)\n-    v->vec.gc_mark = 0;\n-  for (t = trees; t != NULL; t = t->chain)\n-    t->tree.common.gc_mark = 0;\n-  for (s = strings; s != NULL; s = s->chain)\n-    s->magic_mark = GGC_STRING_MAGIC;\n+  for (gs = ggc_chain; gs; gs = gs->next)\n+    {\n+      for (r = gs->rtxs; r != NULL; r = r->chain)\n+\tr->rtx.gc_mark = 0;\n+      for (v = gs->vecs; v != NULL; v = v->chain)\n+\tv->vec.gc_mark = 0;\n+      for (t = gs->trees; t != NULL; t = t->chain)\n+\tt->tree.common.gc_mark = 0;\n+      for (s = gs->strings; s != NULL; s = s->chain)\n+\ts->magic_mark = GGC_STRING_MAGIC;\n+    }\n \n   /* Mark through all the roots.  */\n   for (x = roots; x != NULL; x = x->next)\n@@ -570,7 +674,9 @@ ggc_collect ()\n     }\n \n   /* Sweep the resulting dead nodes.  */\n-  rp = &rtxs, r = rtxs, n_rtxs = 0;\n+  rp = &ggc_chain->rtxs;\n+  r = ggc_chain->rtxs;\n+  n_rtxs = 0;\n   while (r != NULL)\n     {\n       struct ggc_rtx *chain = r->chain;\n@@ -587,7 +693,9 @@ ggc_collect ()\n   *rp = NULL;\n   n_rtxs_collected += n_rtxs;\n \n-  vp = &vecs, v = vecs, n_vecs = 0;\n+  vp = &ggc_chain->vecs;\n+  v = ggc_chain->vecs;\n+  n_vecs = 0;\n   while (v != NULL)\n     {\n       struct ggc_rtvec *chain = v->chain;\n@@ -604,7 +712,9 @@ ggc_collect ()\n   *vp = NULL;\n   n_vecs_collected += n_vecs;\n \n-  tp = &trees, t = trees, n_trees = 0;\n+  tp = &ggc_chain->trees;\n+  t = ggc_chain->trees;\n+  n_trees = 0;\n   while (t != NULL)\n     {\n       struct ggc_tree *chain = t->chain;\n@@ -621,7 +731,9 @@ ggc_collect ()\n   *tp = NULL;\n   n_trees_collected += n_trees;\n \n-  sp = &strings, s = strings, n_strings = 0;\n+  sp = &ggc_chain->strings;\n+  s = ggc_chain->strings;\n+  n_strings = 0;\n   while (s != NULL)\n     {\n       struct ggc_string *chain = s->chain;\n@@ -637,8 +749,10 @@ ggc_collect ()\n     }\n   *sp = NULL;\n   n_strings_collected += n_strings;\n+  ggc_chain->bytes_alloced_since_gc = 0;\n \n-  gc_time += time = get_run_time () - time;\n+  time = get_run_time () - time;\n+  gc_time += time;\n \n   if (!quiet_flag)\n     {"}, {"sha": "785e25bf80fd2725ee796628da9b6d5320480c00", "filename": "gcc/ggc.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21cd906efe356578356ec1c36841629951681b44/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21cd906efe356578356ec1c36841629951681b44/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=21cd906efe356578356ec1c36841629951681b44", "patch": "@@ -43,6 +43,13 @@ struct hash_table;\n \n extern void init_ggc PROTO ((void));\n \n+/* Start a new GGC context.  Memory allocated in previous contexts\n+   will not be collected while the new context is active.  */\n+extern void ggc_pop_context PROTO ((void));\n+/* Finish a GC context.  Any uncollected memory in the new context\n+   will be merged with the old context.  */\n+extern void ggc_push_context PROTO ((void));\n+\n /* Allocation.  */\n \n struct rtx_def *ggc_alloc_rtx PROTO ((int nslots));"}, {"sha": "df653371326161cbe98007b15da605cffbe158d2", "filename": "gcc/print-tree.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21cd906efe356578356ec1c36841629951681b44/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21cd906efe356578356ec1c36841629951681b44/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=21cd906efe356578356ec1c36841629951681b44", "patch": "@@ -270,7 +270,8 @@ print_node (file, prefix, node, indent)\n       if (TREE_TYPE (node))\n \tindent_to (file, indent + 3);\n \n-      print_obstack_name ((char *) node, file, \"\");\n+      if (!ggc_p)\n+\tprint_obstack_name ((char *) node, file, \"\");\n       indent_to (file, indent + 3);\n     }\n "}, {"sha": "aef2b70ef2e5b65be24ca3530ddee952543202bc", "filename": "gcc/stmt.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21cd906efe356578356ec1c36841629951681b44/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21cd906efe356578356ec1c36841629951681b44/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=21cd906efe356578356ec1c36841629951681b44", "patch": "@@ -550,6 +550,22 @@ mark_goto_fixup (g)\n     }\n }\n \n+/* Clear out all parts of the state in F that can safely be discarded\n+   after the function has been compiled, to let garbage collection\n+   reclaim the memory.  D is the declaration for the function just\n+   compiled.  Its output may have been deferred.  */\n+\n+void\n+free_stmt_status (f, d)\n+     struct function *f;\n+     tree d ATTRIBUTE_UNUSED;\n+{\n+  /* We're about to free the function obstack.  If we hold pointers to\n+     things allocated there, then we'll try to mark them when we do\n+     GC.  So, we clear them out here explicitly.  */\n+  f->stmt->x_goto_fixup_chain = 0;\n+}\n+\n /* Mark P for GC.  */\n \n void\n@@ -602,6 +618,7 @@ init_stmt_for_function ()\n   /* We are not processing a ({...}) grouping.  */\n   expr_stmts_for_value = 0;\n   last_expr_type = 0;\n+  last_expr_value = NULL_RTX;\n \n   init_eh_for_function ();\n }"}, {"sha": "73a77bca838588e9e07f41e73e1539e80984b070", "filename": "gcc/toplev.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21cd906efe356578356ec1c36841629951681b44/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21cd906efe356578356ec1c36841629951681b44/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=21cd906efe356578356ec1c36841629951681b44", "patch": "@@ -4466,13 +4466,13 @@ rest_of_compilation (decl)\n \n   init_recog_no_volatile ();\n \n-  /* We're done with this function.  */\n-  if (! DECL_DEFER_OUTPUT (decl))\n-    free_after_compilation (current_function);\n+  /* We're done with this function.  Free up memory if we can.  */\n+  free_after_compilation (current_function, decl);\n \n   current_function = 0;\n \n-  ggc_collect ();\n+  if (ggc_p)\n+    ggc_collect ();\n \n   /* The parsing time is all the time spent in yyparse\n      *except* what is spent in this function.  */\n@@ -4793,6 +4793,9 @@ main (argc, argv)\n   flag_short_enums = DEFAULT_SHORT_ENUMS;\n #endif\n \n+  /* Initialize the garbage-collector.  */\n+  if (ggc_p)\n+    init_ggc ();\n   ggc_add_root (&input_file_stack, 1, sizeof input_file_stack,\n \t\t&mark_file_stack);\n "}, {"sha": "f79512311fed6779ca672fb59215cedc7a44c81d", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21cd906efe356578356ec1c36841629951681b44/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21cd906efe356578356ec1c36841629951681b44/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=21cd906efe356578356ec1c36841629951681b44", "patch": "@@ -476,9 +476,6 @@ push_obstacks (current, saveable)\n {\n   struct obstack_stack *p;\n \n-  if (ggc_p)\n-    return;\n-\n   p = (struct obstack_stack *) obstack_alloc (&obstack_stack_obstack,\n \t\t\t\t\t      (sizeof (struct obstack_stack)));\n \n@@ -501,9 +498,6 @@ push_obstacks_nochange ()\n {\n   struct obstack_stack *p;\n   \n-  if (ggc_p)\n-    return;\n-\n   p = (struct obstack_stack *) obstack_alloc (&obstack_stack_obstack,\n \t\t\t\t\t      (sizeof (struct obstack_stack)));\n \n@@ -522,9 +516,6 @@ pop_obstacks ()\n {\n   struct obstack_stack *p;\n \n-  if (ggc_p)\n-    return;\n-\n   p = obstack_stack;\n   obstack_stack = p->next;\n "}, {"sha": "8c0b5a16faba24d4906669dda9a95e3c3ce71219", "filename": "gcc/varasm.c", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21cd906efe356578356ec1c36841629951681b44/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21cd906efe356578356ec1c36841629951681b44/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=21cd906efe356578356ec1c36841629951681b44", "patch": "@@ -3210,13 +3210,22 @@ mark_varasm_state (p)\n   ggc_mark_rtx (p->x_const_double_chain);\n }\n \n-/* Clear out all parts of our state in F that can safely be discarded\n-   after the function has been compiled.  */\n+/* Clear out all parts of the state in F that can safely be discarded\n+   after the function has been compiled, to let garbage collection\n+   reclaim the memory.  D is the declaration for the function just\n+   compiled.  Its output may have been deferred.  */\n+\n void\n-free_varasm_status (f)\n+free_varasm_status (f, d)\n      struct function *f;\n+     tree d;\n {\n-  struct varasm_status *p = f->varasm;\n+  struct varasm_status *p;\n+\n+  if (DECL_DEFER_OUTPUT (d))\n+    return;\n+\n+  p = f->varasm;\n   free (p->x_const_rtx_hash_table);\n   free (p->x_const_rtx_sym_hash_table);\n "}]}