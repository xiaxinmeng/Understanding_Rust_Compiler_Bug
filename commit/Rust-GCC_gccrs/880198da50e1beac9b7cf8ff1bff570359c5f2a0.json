{"sha": "880198da50e1beac9b7cf8ff1bff570359c5f2a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODgwMTk4ZGE1MGUxYmVhYzliN2NmOGZmMWJmZjU3MDM1OWM1ZjJhMA==", "commit": {"author": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2021-06-09T16:00:01Z"}, "committer": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2021-06-09T16:00:01Z"}, "message": "arm: Auto-vectorization for MVE and Neon: vhadd/vrhadd\n\nThis patch adds support for auto-vectorization of average value\ncomputation using vhadd or vrhadd, for both MVE and Neon.\n\nThe patch adds the needed [u]avg<mode>3_[floor|ceil] patterns to\nvec-common.md, I'm not sure how to factorize them without introducing\nan unspec iterator?\n\nIt also adds tests for 'floor' and for 'ceil', each for MVE and Neon.\n\n2021-06-09  Christophe Lyon  <christophe.lyon@linaro.org>\n\n\tgcc/\n\t* config/arm/mve.md (mve_vhaddq_<supf><mode>): Prefix with '@'.\n\t(@mve_vrhaddq_<supf><mode): Likewise.\n\t* config/arm/neon.md (neon_v<r>hadd<sup><mode>): Likewise.\n\t* config/arm/vec-common.md (avg<mode>3_floor, uavg<mode>3_floor)\n\t(avg<mode>3_ceil\", uavg<mode>3_ceil): New patterns.\n\n\tgcc/testsuite/\n\t* gcc.target/arm/simd/mve-vhadd-1.c: New test.\n\t* gcc.target/arm/simd/mve-vhadd-2.c: New test.\n\t* gcc.target/arm/simd/neon-vhadd-1.c: New test.\n\t* gcc.target/arm/simd/neon-vhadd-2.c: New test.", "tree": {"sha": "9fa9c1b21616638233e1432ccb16f9e94d4fe43b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fa9c1b21616638233e1432ccb16f9e94d4fe43b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/880198da50e1beac9b7cf8ff1bff570359c5f2a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/880198da50e1beac9b7cf8ff1bff570359c5f2a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/880198da50e1beac9b7cf8ff1bff570359c5f2a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/880198da50e1beac9b7cf8ff1bff570359c5f2a0/comments", "author": null, "committer": null, "parents": [{"sha": "5d8321127704ed0cca6d6008eafce2e9b8adf96c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d8321127704ed0cca6d6008eafce2e9b8adf96c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d8321127704ed0cca6d6008eafce2e9b8adf96c"}], "stats": {"total": 195, "additions": 192, "deletions": 3}, "files": [{"sha": "04aa612331a6ffe66e7a3107dcd549e87df97bfe", "filename": "gcc/config/arm/mve.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/880198da50e1beac9b7cf8ff1bff570359c5f2a0/gcc%2Fconfig%2Farm%2Fmve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/880198da50e1beac9b7cf8ff1bff570359c5f2a0/gcc%2Fconfig%2Farm%2Fmve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fmve.md?ref=880198da50e1beac9b7cf8ff1bff570359c5f2a0", "patch": "@@ -1030,7 +1030,7 @@\n ;;\n ;; [vhaddq_s, vhaddq_u])\n ;;\n-(define_insn \"mve_vhaddq_<supf><mode>\"\n+(define_insn \"@mve_vhaddq_<supf><mode>\"\n   [\n    (set (match_operand:MVE_2 0 \"s_register_operand\" \"=w\")\n \t(unspec:MVE_2 [(match_operand:MVE_2 1 \"s_register_operand\" \"w\")\n@@ -1652,7 +1652,7 @@\n ;;\n ;; [vrhaddq_s, vrhaddq_u])\n ;;\n-(define_insn \"mve_vrhaddq_<supf><mode>\"\n+(define_insn \"@mve_vrhaddq_<supf><mode>\"\n   [\n    (set (match_operand:MVE_2 0 \"s_register_operand\" \"=w\")\n \t(unspec:MVE_2 [(match_operand:MVE_2 1 \"s_register_operand\" \"w\")"}, {"sha": "18571d819eb0d00a45be9b12e9d301c9a4751211", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/880198da50e1beac9b7cf8ff1bff570359c5f2a0/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/880198da50e1beac9b7cf8ff1bff570359c5f2a0/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=880198da50e1beac9b7cf8ff1bff570359c5f2a0", "patch": "@@ -1488,7 +1488,7 @@\n \n ; vhadd and vrhadd.\n \n-(define_insn \"neon_v<r>hadd<sup><mode>\"\n+(define_insn \"@neon_v<r>hadd<sup><mode>\"\n   [(set (match_operand:VDQIW 0 \"s_register_operand\" \"=w\")\n         (unspec:VDQIW [(match_operand:VDQIW 1 \"s_register_operand\" \"w\")\n \t\t       (match_operand:VDQIW 2 \"s_register_operand\" \"w\")]"}, {"sha": "2779c1a8aaa21bb70961d36d0f2792b7966a2658", "filename": "gcc/config/arm/vec-common.md", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/880198da50e1beac9b7cf8ff1bff570359c5f2a0/gcc%2Fconfig%2Farm%2Fvec-common.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/880198da50e1beac9b7cf8ff1bff570359c5f2a0/gcc%2Fconfig%2Farm%2Fvec-common.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvec-common.md?ref=880198da50e1beac9b7cf8ff1bff570359c5f2a0", "patch": "@@ -565,3 +565,63 @@\n \n   DONE;\n })\n+\n+(define_expand \"avg<mode>3_floor\"\n+  [(match_operand:MVE_2 0 \"s_register_operand\")\n+   (match_operand:MVE_2 1 \"s_register_operand\")\n+   (match_operand:MVE_2 2 \"s_register_operand\")]\n+  \"ARM_HAVE_<MODE>_ARITH\"\n+{\n+  if (TARGET_HAVE_MVE)\n+    emit_insn (gen_mve_vhaddq (VHADDQ_S, <MODE>mode,\n+\t\t\t       operands[0], operands[1], operands[2]));\n+  else\n+    emit_insn (gen_neon_vhadd (UNSPEC_VHADD_S, UNSPEC_VHADD_S, <MODE>mode,\n+\t\t\t       operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"uavg<mode>3_floor\"\n+  [(match_operand:MVE_2 0 \"s_register_operand\")\n+   (match_operand:MVE_2 1 \"s_register_operand\")\n+   (match_operand:MVE_2 2 \"s_register_operand\")]\n+  \"ARM_HAVE_<MODE>_ARITH\"\n+{\n+  if (TARGET_HAVE_MVE)\n+    emit_insn (gen_mve_vhaddq (VHADDQ_U, <MODE>mode,\n+\t\t\t       operands[0], operands[1], operands[2]));\n+  else\n+    emit_insn (gen_neon_vhadd (UNSPEC_VHADD_U, UNSPEC_VHADD_U, <MODE>mode,\n+\t\t\t       operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"avg<mode>3_ceil\"\n+  [(match_operand:MVE_2 0 \"s_register_operand\")\n+   (match_operand:MVE_2 1 \"s_register_operand\")\n+   (match_operand:MVE_2 2 \"s_register_operand\")]\n+  \"ARM_HAVE_<MODE>_ARITH\"\n+{\n+  if (TARGET_HAVE_MVE)\n+    emit_insn (gen_mve_vrhaddq (VRHADDQ_S, <MODE>mode,\n+\t\t\t\toperands[0], operands[1], operands[2]));\n+  else\n+    emit_insn (gen_neon_vhadd (UNSPEC_VRHADD_S, UNSPEC_VRHADD_S, <MODE>mode,\n+\t\t\t       operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"uavg<mode>3_ceil\"\n+  [(match_operand:MVE_2 0 \"s_register_operand\")\n+   (match_operand:MVE_2 1 \"s_register_operand\")\n+   (match_operand:MVE_2 2 \"s_register_operand\")]\n+  \"ARM_HAVE_<MODE>_ARITH\"\n+{\n+  if (TARGET_HAVE_MVE)\n+    emit_insn (gen_mve_vrhaddq (VRHADDQ_U, <MODE>mode,\n+\t\t\t\toperands[0], operands[1], operands[2]));\n+  else\n+    emit_insn (gen_neon_vhadd (UNSPEC_VRHADD_U, UNSPEC_VRHADD_U, <MODE>mode,\n+\t\t\t       operands[0], operands[1], operands[2]));\n+  DONE;\n+})"}, {"sha": "19d5f5aa44f9ce47f63654100b6c9b6b9eb0a442", "filename": "gcc/testsuite/gcc.target/arm/simd/mve-vhadd-1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/880198da50e1beac9b7cf8ff1bff570359c5f2a0/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vhadd-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/880198da50e1beac9b7cf8ff1bff570359c5f2a0/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vhadd-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vhadd-1.c?ref=880198da50e1beac9b7cf8ff1bff570359c5f2a0", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_v8_1m_mve_ok } */\n+/* { dg-add-options arm_v8_1m_mve } */\n+/* { dg-additional-options \"-O3\" } */\n+\n+#include <stdint.h>\n+\n+/* We force a cast to int64_t to enable the vectorizer when dealing with 32-bit\n+   inputs.  */\n+#define FUNC(SIGN, TYPE, BITS, OP, NAME)\t\t\t\t\\\n+  void test_ ## NAME ##_ ## SIGN ## BITS (TYPE##BITS##_t * __restrict__ dest, \\\n+\t\t\t\t\t  TYPE##BITS##_t *a, TYPE##BITS##_t *b) { \\\n+    int i;\t\t\t\t\t\t\t\t\\\n+    for (i=0; i < (128 / BITS); i++) {\t\t\t\t\t\\\n+      dest[i] = ((int64_t)a[i] OP b[i]) >> 1;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+FUNC(s, int, 32, +, vhadd)\n+FUNC(u, uint, 32, +, vhadd)\n+FUNC(s, int, 16, +, vhadd)\n+FUNC(u, uint, 16, +, vhadd)\n+FUNC(s, int, 8, +, vhadd)\n+FUNC(u, uint, 8, +, vhadd)\n+\n+/* { dg-final { scan-assembler-times {vhadd\\.s32\\tq[0-9]+, q[0-9]+, q[0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {vhadd\\.u32\\tq[0-9]+, q[0-9]+, q[0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {vhadd\\.s16\\tq[0-9]+, q[0-9]+, q[0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {vhadd\\.u16\\tq[0-9]+, q[0-9]+, q[0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {vhadd\\.s8\\tq[0-9]+, q[0-9]+, q[0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {vhadd\\.u8\\tq[0-9]+, q[0-9]+, q[0-9]+} 1 } } */"}, {"sha": "30029fc86b32ed075e960c0899def7523e8a29a9", "filename": "gcc/testsuite/gcc.target/arm/simd/mve-vhadd-2.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/880198da50e1beac9b7cf8ff1bff570359c5f2a0/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vhadd-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/880198da50e1beac9b7cf8ff1bff570359c5f2a0/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vhadd-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vhadd-2.c?ref=880198da50e1beac9b7cf8ff1bff570359c5f2a0", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_v8_1m_mve_ok } */\n+/* { dg-add-options arm_v8_1m_mve } */\n+/* { dg-additional-options \"-O3\" } */\n+\n+#include <stdint.h>\n+\n+/* We force a cast to int64_t to enable the vectorizer when dealing with 32-bit\n+   inputs.  */\n+#define FUNC(SIGN, TYPE, BITS, OP, NAME)\t\t\t\t\\\n+  void test_ ## NAME ##_ ## SIGN ## BITS (TYPE##BITS##_t * __restrict__ dest, \\\n+\t\t\t\t\t  TYPE##BITS##_t *a, TYPE##BITS##_t *b) { \\\n+    int i;\t\t\t\t\t\t\t\t\\\n+    for (i=0; i < (128 / BITS); i++) {\t\t\t\t\t\\\n+      dest[i] = ((int64_t)a[i] OP b[i] + 1) >> 1;\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+FUNC(s, int, 32, +, vrhadd)\n+FUNC(u, uint, 32, +, vrhadd)\n+FUNC(s, int, 16, +, vrhadd)\n+FUNC(u, uint, 16, +, vrhadd)\n+FUNC(s, int, 8, +, vrhadd)\n+FUNC(u, uint, 8, +, vrhadd)\n+\n+/* { dg-final { scan-assembler-times {vrhadd\\.s32\\tq[0-9]+, q[0-9]+, q[0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {vrhadd\\.u32\\tq[0-9]+, q[0-9]+, q[0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {vrhadd\\.s16\\tq[0-9]+, q[0-9]+, q[0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {vrhadd\\.u16\\tq[0-9]+, q[0-9]+, q[0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {vrhadd\\.s8\\tq[0-9]+, q[0-9]+, q[0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {vrhadd\\.u8\\tq[0-9]+, q[0-9]+, q[0-9]+} 1 } } */"}, {"sha": "ce577849f0391498344437b512b876f7eb6df4da", "filename": "gcc/testsuite/gcc.target/arm/simd/neon-vhadd-1.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/880198da50e1beac9b7cf8ff1bff570359c5f2a0/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fneon-vhadd-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/880198da50e1beac9b7cf8ff1bff570359c5f2a0/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fneon-vhadd-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fneon-vhadd-1.c?ref=880198da50e1beac9b7cf8ff1bff570359c5f2a0", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-add-options arm_neon } */\n+/* { dg-additional-options \"-O3\" } */\n+\n+#include <stdint.h>\n+\n+/* Since we have implemented the avg* optabs for 128-bit vectors only, use\n+   enough iterations to check that vectorization works as expected.  */\n+\n+/* We force a cast to int64_t to enable the vectorizer when dealing with 32-bit\n+   inputs.  */\n+#define FUNC(SIGN, TYPE, BITS, OP, NAME)\t\t\t\t\\\n+  void test_ ## NAME ##_ ## SIGN ## BITS (TYPE##BITS##_t * __restrict__ dest, \\\n+\t\t\t\t\t  TYPE##BITS##_t *a, TYPE##BITS##_t *b) { \\\n+    int i;\t\t\t\t\t\t\t\t\\\n+    for (i=0; i < (128 / BITS); i++) {\t\t\t\t\t\\\n+      dest[i] = ((int64_t)a[i] OP b[i]) >> 1;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+FUNC(s, int, 32, +, vhadd)\n+FUNC(u, uint, 32, +, vhadd)\n+FUNC(s, int, 16, +, vhadd)\n+FUNC(u, uint, 16, +, vhadd)\n+FUNC(s, int, 8, +, vhadd)\n+FUNC(u, uint, 8, +, vhadd)\n+  \n+/* { dg-final { scan-assembler-times {vhadd\\.s32\\tq[0-9]+, q[0-9]+, q[0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {vhadd\\.u32\\tq[0-9]+, q[0-9]+, q[0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {vhadd\\.s16\\tq[0-9]+, q[0-9]+, q[0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {vhadd\\.u16\\tq[0-9]+, q[0-9]+, q[0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {vhadd\\.s8\\tq[0-9]+, q[0-9]+, q[0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {vhadd\\.u8\\tq[0-9]+, q[0-9]+, q[0-9]+} 1 } } */"}, {"sha": "f2692542f9b564788050ef55077795140552e833", "filename": "gcc/testsuite/gcc.target/arm/simd/neon-vhadd-2.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/880198da50e1beac9b7cf8ff1bff570359c5f2a0/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fneon-vhadd-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/880198da50e1beac9b7cf8ff1bff570359c5f2a0/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fneon-vhadd-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fneon-vhadd-2.c?ref=880198da50e1beac9b7cf8ff1bff570359c5f2a0", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-add-options arm_neon } */\n+/* { dg-additional-options \"-O3\" } */\n+\n+#include <stdint.h>\n+\n+/* Since we default to -mvectorize-with-neon-quad, use enough iterations so that\n+   we can vectorize using 128-bit vectors.  */\n+/* We force a cast to int64_t to enable the vectorizer when dealing with 32-bit\n+   inputs.  */\n+#define FUNC(SIGN, TYPE, BITS, OP, NAME)\t\t\t\t\\\n+  void test_ ## NAME ##_ ## SIGN ## BITS (TYPE##BITS##_t * __restrict__ dest, \\\n+\t\t\t\t\t  TYPE##BITS##_t *a, TYPE##BITS##_t *b) { \\\n+    int i;\t\t\t\t\t\t\t\t\\\n+    for (i=0; i < (128 / BITS); i++) {\t\t\t\t\t\\\n+      dest[i] = ((int64_t)a[i] OP b[i] + 1) >> 1;\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+FUNC(s, int, 32, +, vrhadd)\n+FUNC(u, uint, 32, +, vrhadd)\n+FUNC(s, int, 16, +, vrhadd)\n+FUNC(u, uint, 16, +, vrhadd)\n+FUNC(s, int, 8, +, vrhadd)\n+FUNC(u, uint, 8, +, vrhadd)\n+\n+/* { dg-final { scan-assembler-times {vrhadd\\.s32\\tq[0-9]+, q[0-9]+, q[0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {vrhadd\\.u32\\tq[0-9]+, q[0-9]+, q[0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {vrhadd\\.s16\\tq[0-9]+, q[0-9]+, q[0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {vrhadd\\.u16\\tq[0-9]+, q[0-9]+, q[0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {vrhadd\\.s8\\tq[0-9]+, q[0-9]+, q[0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {vrhadd\\.u8\\tq[0-9]+, q[0-9]+, q[0-9]+} 1 } } */"}]}