{"sha": "1855915abe6888b17861d36e8174bf954eb8ed86", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTg1NTkxNWFiZTY4ODhiMTc4NjFkMzZlODE3NGJmOTU0ZWI4ZWQ4Ng==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-07-04T20:15:52Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-07-04T20:15:52Z"}, "message": "re PR fortran/28174 (Corruption of multiple character arrays when passing array sections)\n\n2006-07-04  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/28174\n\t* trans-array.c (gfc_conv_expr_descriptor): When building temp,\n\tensure that the substring reference uses a new charlen.\n\t* trans-expr.c (gfc_conv_aliased_arg): Add the formal intent to\n\tthe argument list, lift the treatment of missing string lengths\n\tfrom the above and implement the use of the intent.\n\t(gfc_conv_function_call): Add the extra argument to the call to\n\tthe above.\n\n\tPR fortran/28167\n\t* trans-array.c (get_array_ctor_var_strlen): Treat a constant\n\tsubstring reference.\n\t* array.c (gfc_resolve_character_array_constructor): Remove \n\tstatic attribute and add the gfc_ prefix, make use of element\n\tcharlens for the expression and pick up constant string lengths\n\tfor expressions that are not themselves constant.\n\t* gfortran.h : resolve_character_array_constructor prototype\n\tadded.\n\t* resolve.c (gfc_resolve_expr): Call resolve_character_array_\n\tconstructor again after expanding the constructor, to ensure\n\tthat the character length is passed to the expression.\n\n2006-07-04  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/28174\n\t* gfortran.dg/actual_array_substr_2.f90: New test.\n\n\tPR fortran/28167\n\t* gfortran.dg/actual_array_constructor_2.f90: New test.\n\nFrom-SVN: r115182", "tree": {"sha": "2463384e73151c98e251c62c5a975477a2bbcc92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2463384e73151c98e251c62c5a975477a2bbcc92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1855915abe6888b17861d36e8174bf954eb8ed86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1855915abe6888b17861d36e8174bf954eb8ed86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1855915abe6888b17861d36e8174bf954eb8ed86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1855915abe6888b17861d36e8174bf954eb8ed86/comments", "author": null, "committer": null, "parents": [{"sha": "6215885d43d8ebe55454794cedfe092604f62718", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6215885d43d8ebe55454794cedfe092604f62718", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6215885d43d8ebe55454794cedfe092604f62718"}], "stats": {"total": 242, "additions": 219, "deletions": 23}, "files": [{"sha": "efa31400c5d68dc2018acd221c0cdd89565de73c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1855915abe6888b17861d36e8174bf954eb8ed86/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1855915abe6888b17861d36e8174bf954eb8ed86/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1855915abe6888b17861d36e8174bf954eb8ed86", "patch": "@@ -1,3 +1,27 @@\n+2006-07-04  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/28174\n+\t* trans-array.c (gfc_conv_expr_descriptor): When building temp,\n+\tensure that the substring reference uses a new charlen.\n+\t* trans-expr.c (gfc_conv_aliased_arg): Add the formal intent to\n+\tthe argument list, lift the treatment of missing string lengths\n+\tfrom the above and implement the use of the intent.\n+\t(gfc_conv_function_call): Add the extra argument to the call to\n+\tthe above.\n+\n+\tPR fortran/28167\n+\t* trans-array.c (get_array_ctor_var_strlen): Treat a constant\n+\tsubstring reference.\n+\t* array.c (gfc_resolve_character_array_constructor): Remove \n+\tstatic attribute and add the gfc_ prefix, make use of element\n+\tcharlens for the expression and pick up constant string lengths\n+\tfor expressions that are not themselves constant.\n+\t* gfortran.h : resolve_character_array_constructor prototype\n+\tadded.\n+\t* resolve.c (gfc_resolve_expr): Call resolve_character_array_\n+\tconstructor again after expanding the constructor, to ensure\n+\tthat the character length is passed to the expression.\n+\n 2006-07-04  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \t    Daniel Franke  <franke.daniel@gmail.com>\n "}, {"sha": "fa38ab9c956fd8fad5d072727092873afd2f1d9e", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 43, "deletions": 9, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1855915abe6888b17861d36e8174bf954eb8ed86/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1855915abe6888b17861d36e8174bf954eb8ed86/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=1855915abe6888b17861d36e8174bf954eb8ed86", "patch": "@@ -1518,8 +1518,8 @@ resolve_array_list (gfc_constructor * p)\n    not specified character length, update character length to the maximum of\n    its element constructors' length.  */\n \n-static void\n-resolve_character_array_constructor (gfc_expr * expr)\n+void\n+gfc_resolve_character_array_constructor (gfc_expr * expr)\n {\n   gfc_constructor * p;\n   int max_length;\n@@ -1531,28 +1531,62 @@ resolve_character_array_constructor (gfc_expr * expr)\n \n   if (expr->ts.cl == NULL)\n     {\n+      for (p = expr->value.constructor; p; p = p->next)\n+\tif (p->expr->ts.cl != NULL)\n+\t  {\n+\t    /* Ensure that if there is a char_len around that it is\n+\t       used; otherwise the middle-end confuses them!  */\n+\t    expr->ts.cl = p->expr->ts.cl;\n+\t    goto got_charlen;\n+\t  }\n+\n       expr->ts.cl = gfc_get_charlen ();\n       expr->ts.cl->next = gfc_current_ns->cl_list;\n       gfc_current_ns->cl_list = expr->ts.cl;\n     }\n \n+got_charlen:\n+\n   if (expr->ts.cl->length == NULL)\n     {\n       /* Find the maximum length of the elements. Do nothing for variable array\n-\t constructor.  */\n+\t constructor, unless the character length is constant or there is a\n+\tconstant substring reference.  */\n+\n       for (p = expr->value.constructor; p; p = p->next)\n-\tif (p->expr->expr_type == EXPR_CONSTANT)\n-\t  max_length = MAX (p->expr->value.character.length, max_length);\n-\telse\n-\t  return;\n+\t{\n+\t  gfc_ref *ref;\n+\t  for (ref = p->expr->ref; ref; ref = ref->next)\n+\t    if (ref->type == REF_SUBSTRING\n+\t\t  && ref->u.ss.start->expr_type == EXPR_CONSTANT\n+\t\t  && ref->u.ss.end->expr_type == EXPR_CONSTANT)\n+\t      break;\n+\n+\t  if (p->expr->expr_type == EXPR_CONSTANT)\n+\t    max_length = MAX (p->expr->value.character.length, max_length);\n+\n+\t  else if (ref)\n+\t    max_length = MAX ((int)(mpz_get_ui (ref->u.ss.end->value.integer)\n+\t\t\t      - mpz_get_ui (ref->u.ss.start->value.integer))\n+\t\t\t      + 1, max_length);\n+\n+\t  else if (p->expr->ts.cl && p->expr->ts.cl->length\n+\t\t     && p->expr->ts.cl->length->expr_type == EXPR_CONSTANT)\n+\t    max_length = MAX ((int)mpz_get_si (p->expr->ts.cl->length->value.integer),\n+\t\t\t      max_length);\n+\n+\t  else\n+\t    return;\n+\t}\n \n       if (max_length != -1)\n \t{\n \t  /* Update the character length of the array constructor.  */\n \t  expr->ts.cl->length = gfc_int_expr (max_length);\n \t  /* Update the element constructors.  */\n \t  for (p = expr->value.constructor; p; p = p->next)\n-\t    gfc_set_constant_character_len (max_length, p->expr);\n+\t    if (p->expr->expr_type == EXPR_CONSTANT)\n+\t      gfc_set_constant_character_len (max_length, p->expr);\n \t}\n     }\n }\n@@ -1568,7 +1602,7 @@ gfc_resolve_array_constructor (gfc_expr * expr)\n   if (t == SUCCESS)\n     t = gfc_check_constructor_type (expr);\n   if (t == SUCCESS && expr->ts.type == BT_CHARACTER)\n-    resolve_character_array_constructor (expr);\n+    gfc_resolve_character_array_constructor (expr);\n \n   return t;\n }"}, {"sha": "21b0d09b06610b1ad50597c48c09f0506ae19feb", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1855915abe6888b17861d36e8174bf954eb8ed86/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1855915abe6888b17861d36e8174bf954eb8ed86/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=1855915abe6888b17861d36e8174bf954eb8ed86", "patch": "@@ -2028,6 +2028,7 @@ void gfc_simplify_iterator_var (gfc_expr *);\n try gfc_expand_constructor (gfc_expr *);\n int gfc_constant_ac (gfc_expr *);\n int gfc_expanded_ac (gfc_expr *);\n+void gfc_resolve_character_array_constructor (gfc_expr *);\n try gfc_resolve_array_constructor (gfc_expr *);\n try gfc_check_constructor_type (gfc_expr *);\n try gfc_check_iter_variable (gfc_expr *);"}, {"sha": "c3aaf87c0c91c70e784387690bf8f1b196377be1", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1855915abe6888b17861d36e8174bf954eb8ed86/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1855915abe6888b17861d36e8174bf954eb8ed86/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=1855915abe6888b17861d36e8174bf954eb8ed86", "patch": "@@ -2942,6 +2942,11 @@ gfc_resolve_expr (gfc_expr * e)\n \t  gfc_expand_constructor (e);\n \t}\n \n+      /* This provides the opportunity for the length of constructors with character\n+\tvalued function elements to propogate the string length to the expression.  */\n+      if (e->ts.type == BT_CHARACTER)\n+        gfc_resolve_character_array_constructor (e);\n+\n       break;\n \n     case EXPR_STRUCTURE:"}, {"sha": "01c78d4049683993eb2d3a70efb537605b4d0f31", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1855915abe6888b17861d36e8174bf954eb8ed86/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1855915abe6888b17861d36e8174bf954eb8ed86/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=1855915abe6888b17861d36e8174bf954eb8ed86", "patch": "@@ -1341,6 +1341,7 @@ get_array_ctor_var_strlen (gfc_expr * expr, tree * len)\n {\n   gfc_ref *ref;\n   gfc_typespec *ts;\n+  mpz_t char_len;\n \n   /* Don't bother if we already know the length is a constant.  */\n   if (*len && INTEGER_CST_P (*len))\n@@ -1360,6 +1361,19 @@ get_array_ctor_var_strlen (gfc_expr * expr, tree * len)\n \t  ts = &ref->u.c.component->ts;\n \t  break;\n \n+\tcase REF_SUBSTRING:\n+\t  if (ref->u.ss.start->expr_type != EXPR_CONSTANT\n+\t\t|| ref->u.ss.start->expr_type != EXPR_CONSTANT)\n+\t    break;\n+\t  mpz_init_set_ui (char_len, 1);\n+\t  mpz_add (char_len, char_len, ref->u.ss.end->value.integer);\n+\t  mpz_sub (char_len, char_len, ref->u.ss.start->value.integer);\n+\t  *len = gfc_conv_mpz_to_tree (char_len,\n+\t\t\t\t       gfc_default_character_kind);\n+\t  *len = convert (gfc_charlen_type_node, *len);\n+\t  mpz_clear (char_len);\n+\t  return;\n+\n \tdefault:\n \t  /* TODO: Substrings are tricky because we can't evaluate the\n \t     expression more than once.  For now we just give up, and hope\n@@ -4192,7 +4206,10 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t\tif (char_ref->type == REF_SUBSTRING)\n \t\t  {\n \t\t    mpz_t char_len;\n-\t\t    expr->ts.cl = char_ref->u.ss.length;\n+\t\t    expr->ts.cl = gfc_get_charlen ();\n+\t\t    expr->ts.cl->next = char_ref->u.ss.length->next;\n+\t\t    char_ref->u.ss.length->next = expr->ts.cl;\n+\n \t\t    mpz_init_set_ui (char_len, 1);\n \t\t    mpz_add (char_len, char_len,\n \t\t\t     char_ref->u.ss.end->value.integer);"}, {"sha": "30cf80a4390fe52f675cc28657e2b93284bfdaf0", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1855915abe6888b17861d36e8174bf954eb8ed86/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1855915abe6888b17861d36e8174bf954eb8ed86/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=1855915abe6888b17861d36e8174bf954eb8ed86", "patch": "@@ -1591,7 +1591,8 @@ gfc_apply_interface_mapping (gfc_interface_mapping * mapping,\n    handling aliased arrays.  */\n \n static void\n-gfc_conv_aliased_arg (gfc_se * parmse, gfc_expr * expr, int g77)\n+gfc_conv_aliased_arg (gfc_se * parmse, gfc_expr * expr,\n+\t\t      int g77, sym_intent intent)\n {\n   gfc_se lse;\n   gfc_se rse;\n@@ -1635,7 +1636,37 @@ gfc_conv_aliased_arg (gfc_se * parmse, gfc_expr * expr, int g77)\n   loop.temp_ss->data.temp.type = base_type;\n \n   if (expr->ts.type == BT_CHARACTER)\n-    loop.temp_ss->string_length = expr->ts.cl->backend_decl;\n+    {\n+      gfc_ref *char_ref = expr->ref;\n+\n+      for (; expr->ts.cl == NULL && char_ref; char_ref = char_ref->next)\n+\tif (char_ref->type == REF_SUBSTRING)\n+\t  {\n+\t    gfc_se tmp_se;\n+\n+\t    expr->ts.cl = gfc_get_charlen ();\n+\t    expr->ts.cl->next = char_ref->u.ss.length->next;\n+\t    char_ref->u.ss.length->next = expr->ts.cl;\n+\n+\t    gfc_init_se (&tmp_se, NULL);\n+\t    gfc_conv_expr_type (&tmp_se, char_ref->u.ss.end,\n+\t\t\t\tgfc_array_index_type);\n+\t    tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t       tmp_se.expr, gfc_index_one_node);\n+\t    tmp = gfc_evaluate_now (tmp, &parmse->pre);\n+\t    gfc_init_se (&tmp_se, NULL);\n+\t    gfc_conv_expr_type (&tmp_se, char_ref->u.ss.start,\n+\t\t\t\tgfc_array_index_type);\n+\t    tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t       tmp, tmp_se.expr);\n+\t    expr->ts.cl->backend_decl = tmp;\n+\n+\t    break;\n+\t  }\n+      loop.temp_ss->data.temp.type\n+\t\t= gfc_typenode_for_spec (&expr->ts);\n+      loop.temp_ss->string_length = expr->ts.cl->backend_decl;\n+    }\n \n   loop.temp_ss->data.temp.dimen = loop.dimen;\n   loop.temp_ss->next = gfc_ss_terminator;\n@@ -1668,12 +1699,13 @@ gfc_conv_aliased_arg (gfc_se * parmse, gfc_expr * expr, int g77)\n   gfc_conv_tmp_array_ref (&lse);\n   gfc_advance_se_ss_chain (&lse);\n \n-  tmp = gfc_trans_scalar_assign (&lse, &rse, expr->ts.type);\n-  gfc_add_expr_to_block (&body, tmp);\n-\n-  gcc_assert (rse.ss == gfc_ss_terminator);\n-\n-  gfc_trans_scalarizing_loops (&loop, &body);\n+  if (intent != INTENT_OUT)\n+    {\n+      tmp = gfc_trans_scalar_assign (&lse, &rse, expr->ts.type);\n+      gfc_add_expr_to_block (&body, tmp);\n+      gcc_assert (rse.ss == gfc_ss_terminator);\n+      gfc_trans_scalarizing_loops (&loop, &body);\n+    }\n \n   /* Add the post block after the second loop, so that any\n      freeing of allocated memory is done at the right time.  */\n@@ -1761,10 +1793,13 @@ gfc_conv_aliased_arg (gfc_se * parmse, gfc_expr * expr, int g77)\n   gfc_trans_scalarizing_loops (&loop2, &body);\n \n   /* Wrap the whole thing up by adding the second loop to the post-block\n-     and following it by the post-block of the fist loop.  In this way,\n+     and following it by the post-block of the first loop.  In this way,\n      if the temporary needs freeing, it is done after use!  */\n-  gfc_add_block_to_block (&parmse->post, &loop2.pre);\n-  gfc_add_block_to_block (&parmse->post, &loop2.post);\n+  if (intent != INTENT_IN)\n+    {\n+      gfc_add_block_to_block (&parmse->post, &loop2.pre);\n+      gfc_add_block_to_block (&parmse->post, &loop2.post);\n+    }\n \n   gfc_add_block_to_block (&parmse->post, &loop.post);\n \n@@ -1799,7 +1834,8 @@ is_aliased_array (gfc_expr * e)\n       if (ref->type == REF_ARRAY)\n \tseen_array = true;\n \n-      if (ref->next == NULL && ref->type == REF_COMPONENT)\n+      if (ref->next == NULL\n+\t    && ref->type != REF_ARRAY)\n \treturn seen_array;\n     }\n   return false;\n@@ -1937,13 +1973,14 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t\t  && !(fsym->attr.pointer || fsym->attr.allocatable)\n \t\t  && fsym->as->type != AS_ASSUMED_SHAPE;\n \t      f = f || !sym->attr.always_explicit;\n+\n \t      if (e->expr_type == EXPR_VARIABLE\n \t\t    && is_aliased_array (e))\n \t\t/* The actual argument is a component reference to an\n \t\t   array of derived types.  In this case, the argument\n \t\t   is converted to a temporary, which is passed and then\n \t\t   written back after the procedure call.  */\n-\t\tgfc_conv_aliased_arg (&parmse, e, f);\n+\t\tgfc_conv_aliased_arg (&parmse, e, f, fsym->attr.intent);\n \t      else\n \t        gfc_conv_array_parameter (&parmse, e, argss, f);\n "}, {"sha": "0a86b70d7bf14b88dcc93a1caba30a981c9633f1", "filename": "gcc/testsuite/gfortran.dg/actual_array_constructor_2.f90", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1855915abe6888b17861d36e8174bf954eb8ed86/gcc%2Ftestsuite%2Fgfortran.dg%2Factual_array_constructor_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1855915abe6888b17861d36e8174bf954eb8ed86/gcc%2Ftestsuite%2Fgfortran.dg%2Factual_array_constructor_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Factual_array_constructor_2.f90?ref=1855915abe6888b17861d36e8174bf954eb8ed86", "patch": "@@ -0,0 +1,34 @@\n+! { dg-do run }\n+! Tests the fix for pr28167, in which character array constructors\r\n+! with an implied do loop would cause an ICE, when used as actual\r\n+! arguments.\n+!\n+! Based on the testscase by Harald Anlauf  <anlauf@gmx.de>\n+!\n+  character(4), dimension(4) :: c1, c2\r\n+  integer m\r\n+  m = 4\r\n+! Test the original problem\r\n+  call foo ((/( 'abcd',i=1,m )/), c2)\r\n+  if (any(c2(:) .ne. (/'abcd','abcd', &\r\n+                            'abcd','abcd'/))) call abort ()\r\n+\r\n+! Now get a bit smarter\r\n+  call foo ((/\"abcd\", \"efgh\", \"ijkl\", \"mnop\"/), c1) ! worked previously\r\n+  call foo ((/(c1(i), i = m,1,-1)/), c2)            ! was broken\r\n+  if (any(c2(4:1:-1) .ne. c1)) call abort ()\r\n+\r\n+! gfc_todo: Not Implemented: complex character array constructors\r\n+  call foo ((/(c1(i)(i/2+1:i/2+2), i = 1,4)/), c2)  ! Ha! take that..!\n+  if (any (c2 .ne. (/\"ab  \",\"fg  \",\"jk  \",\"op  \"/))) call abort ()\n+\r\n+! Check functions in the constructor\r\n+  call foo ((/(achar(64+i)//achar(68+i)//achar(72+i)// &\r\n+               achar(76+i),i=1,4 )/), c1)           ! was broken\r\n+  if (any (c1 .ne. (/\"AEIM\",\"BFJN\",\"CGKO\",\"DHLP\"/))) call abort ()\r\n+contains\r\n+  subroutine foo (chr1, chr2)\r\n+    character(*), dimension(:) :: chr1, chr2\r\n+    chr2 = chr1\r\n+  end subroutine foo\r\n+end\n\\ No newline at end of file"}, {"sha": "365557d6f57d359fbe2e1444c684e59e700ae27a", "filename": "gcc/testsuite/gfortran.dg/actual_array_substr_2.f90", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1855915abe6888b17861d36e8174bf954eb8ed86/gcc%2Ftestsuite%2Fgfortran.dg%2Factual_array_substr_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1855915abe6888b17861d36e8174bf954eb8ed86/gcc%2Ftestsuite%2Fgfortran.dg%2Factual_array_substr_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Factual_array_substr_2.f90?ref=1855915abe6888b17861d36e8174bf954eb8ed86", "patch": "@@ -0,0 +1,44 @@\n+! { dg-do run }\n+! Tests the fix for pr28174, in which the fix for pr28118 was\n+! corrupting the character lengths of arrays that shared a\n+! character length structure.  In addition, in developing the\n+! fix, it was noted that intent(out/inout) arguments were not\n+! getting written back to the calling scope.\n+!\n+! Based on the testscase by Harald Anlauf  <anlauf@gmx.de>\n+!\n+program pr28174\r\n+  implicit none\r\n+  character(len=12) :: teststring(2) = (/ \"abc def ghij\", &\n+                                          \"klm nop qrst\" /)\r\n+  character(len=12) :: a(2), b(2), c(2), d(2)\n+  integer :: m = 7, n\r\n+  a = teststring\r\n+  b = a\r\n+  c = a\r\n+  d = a\n+  n = m - 4\n+\n+! Make sure that variable substring references work.\r\n+  call foo (a(:)(m:m+5), c(:)(n:m+2), d(:)(5:9))\r\n+  if (any (a .ne. teststring)) call abort ()\n+  if (any (b .ne. teststring)) call abort ()\n+  if (any (c .ne. (/\"ab456789#hij\", &\n+                    \"kl7654321rst\"/))) call abort ()\n+  if (any (d .ne. (/\"abc 23456hij\", &\n+                    \"klm 98765rst\"/))) call abort ()\r\n+contains\r\n+  subroutine foo (w, x, y)\r\n+    character(len=*), intent(in) :: w(:)\r\n+    character(len=*), intent(inOUT) :: x(:)\r\n+    character(len=*), intent(OUT) :: y(:)\n+    character(len=12) :: foostring(2) = (/\"0123456789#$\" , &\n+                                          \"$#9876543210\"/)\n+! This next is not required by the standard but tests the\n+! functioning of the gfortran implementation.\r\n+!   if (all (x(:)(3:7) .eq. y)) call abort ()\n+    x = foostring (:)(5 : 4 + len (x))\n+    y = foostring (:)(3 : 2 + len (y))\n+  end subroutine foo\r\n+end program pr28174\r\n+\r"}]}