{"sha": "f3e1097bc643f476d5cd0d697c186c15b23ae702", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjNlMTA5N2JjNjQzZjQ3NmQ1Y2QwZDY5N2MxODZjMTViMjNhZTcwMg==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2016-12-15T20:54:18Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2016-12-15T20:54:18Z"}, "message": "re PR fortran/78798 ([cleanup] some int-valued functions should be bool)\n\n2016-12-15  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/78798\n\t* gfortran.h (gfc_compare_derived_types,gfc_compare_types,\n\tgfc_compare_interfaces,gfc_has_vector_subscript): Return bool instead\n\tof int.\n\t* interface.c (compare_components): Ditto.\n\t(gfc_compare_union_types): Rename to compare_union_types, declare as\n\tstatic, return bool.\n\t(gfc_compare_derived_types): Return bool instead of int.\n\t(gfc_compare_types): Ditto.\n\t(compare_type): Ditto.\n\t(compare_rank): Ditto.\n\t(compare_type_rank): Ditto.\n\t(compare_type_rank_if): Ditto.\n\t(count_types_test): Ditto.\n\t(generic_correspondence): Ditto.\n\t(gfc_compare_interfaces): Ditto.\n\t(check_interface0): Ditto.\n\t(check_interface1): Ditto.\n\t(compare_allocatable): Ditto.\n\t(compare_parameter): Ditto.\n\t(gfc_has_vector_subscript): Ditto.\n\t(compare_actual_formal): Ditto.\n\nFrom-SVN: r243726", "tree": {"sha": "3983fb89987513e136eb9e6c434a8ff3ae320a1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3983fb89987513e136eb9e6c434a8ff3ae320a1e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3e1097bc643f476d5cd0d697c186c15b23ae702", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3e1097bc643f476d5cd0d697c186c15b23ae702", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3e1097bc643f476d5cd0d697c186c15b23ae702", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3e1097bc643f476d5cd0d697c186c15b23ae702/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "155c9907017722a07f215f57b5717209a9f203f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/155c9907017722a07f215f57b5717209a9f203f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/155c9907017722a07f215f57b5717209a9f203f6"}], "stats": {"total": 388, "additions": 205, "deletions": 183}, "files": [{"sha": "7f66ed5f5abb20db7dc6d1e0d1a76bd6814b321d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3e1097bc643f476d5cd0d697c186c15b23ae702/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3e1097bc643f476d5cd0d697c186c15b23ae702/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f3e1097bc643f476d5cd0d697c186c15b23ae702", "patch": "@@ -1,3 +1,28 @@\n+2016-12-15  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/78798\n+\t* gfortran.h (gfc_compare_derived_types,gfc_compare_types,\n+\tgfc_compare_interfaces,gfc_has_vector_subscript): Return bool instead\n+\tof int.\n+\t* interface.c (compare_components): Ditto.\n+\t(gfc_compare_union_types): Rename to compare_union_types, declare as\n+\tstatic, return bool.\n+\t(gfc_compare_derived_types): Return bool instead of int.\n+\t(gfc_compare_types): Ditto.\n+\t(compare_type): Ditto.\n+\t(compare_rank): Ditto.\n+\t(compare_type_rank): Ditto.\n+\t(compare_type_rank_if): Ditto.\n+\t(count_types_test): Ditto.\n+\t(generic_correspondence): Ditto.\n+\t(gfc_compare_interfaces): Ditto.\n+\t(check_interface0): Ditto.\n+\t(check_interface1): Ditto.\n+\t(compare_allocatable): Ditto.\n+\t(compare_parameter): Ditto.\n+\t(gfc_has_vector_subscript): Ditto.\n+\t(compare_actual_formal): Ditto.\n+\n 2016-12-15  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/78800"}, {"sha": "b303189b7c667e515c02d9d3774b1ec01c3eb42d", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3e1097bc643f476d5cd0d697c186c15b23ae702/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3e1097bc643f476d5cd0d697c186c15b23ae702/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=f3e1097bc643f476d5cd0d697c186c15b23ae702", "patch": "@@ -3225,14 +3225,14 @@ bool gfc_ref_dimen_size (gfc_array_ref *, int dimen, mpz_t *, mpz_t *);\n \n /* interface.c -- FIXME: some of these should be in symbol.c */\n void gfc_free_interface (gfc_interface *);\n-int gfc_compare_derived_types (gfc_symbol *, gfc_symbol *);\n-int gfc_compare_types (gfc_typespec *, gfc_typespec *);\n+bool gfc_compare_derived_types (gfc_symbol *, gfc_symbol *);\n+bool gfc_compare_types (gfc_typespec *, gfc_typespec *);\n bool gfc_check_dummy_characteristics (gfc_symbol *, gfc_symbol *,\n \t\t\t\t      bool, char *, int);\n bool gfc_check_result_characteristics (gfc_symbol *, gfc_symbol *,\n \t\t\t\t       char *, int);\n-int gfc_compare_interfaces (gfc_symbol*, gfc_symbol*, const char *, int, int,\n-\t\t\t    char *, int, const char *, const char *);\n+bool gfc_compare_interfaces (gfc_symbol*, gfc_symbol*, const char *, int, int,\n+\t\t\t     char *, int, const char *, const char *);\n void gfc_check_interfaces (gfc_namespace *);\n bool gfc_procedure_use (gfc_symbol *, gfc_actual_arglist **, locus *);\n void gfc_ppc_use (gfc_component *, gfc_actual_arglist **, locus *);\n@@ -3248,7 +3248,7 @@ void gfc_set_current_interface_head (gfc_interface *);\n gfc_symtree* gfc_find_sym_in_symtree (gfc_symbol*);\n bool gfc_arglist_matches_symbol (gfc_actual_arglist**, gfc_symbol*);\n bool gfc_check_operator_interface (gfc_symbol*, gfc_intrinsic_op, locus);\n-int gfc_has_vector_subscript (gfc_expr*);\n+bool gfc_has_vector_subscript (gfc_expr*);\n gfc_intrinsic_op gfc_equivalent_op (gfc_intrinsic_op);\n bool gfc_check_typebound_override (gfc_symtree*, gfc_symtree*);\n void gfc_check_dtio_interfaces (gfc_symbol*);"}, {"sha": "6e61aec1d01210986e486d7b30c69027aebc12cc", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 175, "deletions": 178, "changes": 353, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3e1097bc643f476d5cd0d697c186c15b23ae702/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3e1097bc643f476d5cd0d697c186c15b23ae702/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=f3e1097bc643f476d5cd0d697c186c15b23ae702", "patch": "@@ -471,29 +471,29 @@ is_anonymous_dt (gfc_symbol *derived)\n \n /* Compare components according to 4.4.2 of the Fortran standard.  */\n \n-static int\n+static bool\n compare_components (gfc_component *cmp1, gfc_component *cmp2,\n     gfc_symbol *derived1, gfc_symbol *derived2)\n {\n   /* Compare names, but not for anonymous components such as UNION or MAP.  */\n   if (!is_anonymous_component (cmp1) && !is_anonymous_component (cmp2)\n       && strcmp (cmp1->name, cmp2->name) != 0)\n-    return 0;\n+    return false;\n \n   if (cmp1->attr.access != cmp2->attr.access)\n-    return 0;\n+    return false;\n \n   if (cmp1->attr.pointer != cmp2->attr.pointer)\n-    return 0;\n+    return false;\n \n   if (cmp1->attr.dimension != cmp2->attr.dimension)\n-    return 0;\n+    return false;\n \n   if (cmp1->attr.allocatable != cmp2->attr.allocatable)\n-    return 0;\n+    return false;\n \n   if (cmp1->attr.dimension && gfc_compare_array_spec (cmp1->as, cmp2->as) == 0)\n-    return 0;\n+    return false;\n \n   if (cmp1->ts.type == BT_CHARACTER && cmp2->ts.type == BT_CHARACTER)\n     {\n@@ -503,25 +503,25 @@ compare_components (gfc_component *cmp1, gfc_component *cmp2,\n           && l1->length->expr_type == EXPR_CONSTANT\n           && l2->length->expr_type == EXPR_CONSTANT\n           && gfc_dep_compare_expr (l1->length, l2->length) != 0)\n-        return 0;\n+        return false;\n     }\n \n   /* Make sure that link lists do not put this function into an\n      endless recursive loop!  */\n   if (!(cmp1->ts.type == BT_DERIVED && derived1 == cmp1->ts.u.derived)\n       && !(cmp2->ts.type == BT_DERIVED && derived2 == cmp2->ts.u.derived)\n-      && gfc_compare_types (&cmp1->ts, &cmp2->ts) == 0)\n-    return 0;\n+      && !gfc_compare_types (&cmp1->ts, &cmp2->ts))\n+    return false;\n \n   else if ( (cmp1->ts.type == BT_DERIVED && derived1 == cmp1->ts.u.derived)\n         && !(cmp2->ts.type == BT_DERIVED && derived2 == cmp2->ts.u.derived))\n-    return 0;\n+    return false;\n \n   else if (!(cmp1->ts.type == BT_DERIVED && derived1 == cmp1->ts.u.derived)\n         &&  (cmp2->ts.type == BT_DERIVED && derived2 == cmp2->ts.u.derived))\n-    return 0;\n+    return false;\n \n-  return 1;\n+  return true;\n }\n \n \n@@ -533,20 +533,20 @@ compare_components (gfc_component *cmp1, gfc_component *cmp2,\n    gfc_compare_derived_types, 'equal' is closer to meaning 'duplicate\n    definitions' than 'equivalent structure'. */\n \n-int\n-gfc_compare_union_types (gfc_symbol *un1, gfc_symbol *un2)\n+static bool\n+compare_union_types (gfc_symbol *un1, gfc_symbol *un2)\n {\n   gfc_component *map1, *map2, *cmp1, *cmp2;\n   gfc_symbol *map1_t, *map2_t;\n \n   if (un1->attr.flavor != FL_UNION || un2->attr.flavor != FL_UNION)\n-    return 0;\n+    return false;\n \n   if (un1->attr.zero_comp != un2->attr.zero_comp)\n-    return 0;\n+    return false;\n \n   if (un1->attr.zero_comp)\n-    return 1;\n+    return true;\n \n   map1 = un1->components;\n   map2 = un2->components;\n@@ -567,27 +567,27 @@ gfc_compare_union_types (gfc_symbol *un1, gfc_symbol *un2)\n \n       /* Protect against null components.  */\n       if (map1_t->attr.zero_comp != map2_t->attr.zero_comp)\n-\treturn 0;\n+\treturn false;\n \n       if (map1_t->attr.zero_comp)\n-\treturn 1;\n+\treturn true;\n \n       for (;;)\n \t{\n \t  /* No two fields will ever point to the same map type unless they are\n \t     the same component, because one map field is created with its type\n \t     declaration. Therefore don't worry about recursion here. */\n \t  /* TODO: worry about recursion into parent types of the unions? */\n-\t  if (compare_components (cmp1, cmp2, map1_t, map2_t) == 0)\n-\t    return 0;\n+\t  if (!compare_components (cmp1, cmp2, map1_t, map2_t))\n+\t    return false;\n \n \t  cmp1 = cmp1->next;\n \t  cmp2 = cmp2->next;\n \n \t  if (cmp1 == NULL && cmp2 == NULL)\n \t    break;\n \t  if (cmp1 == NULL || cmp2 == NULL)\n-\t    return 0;\n+\t    return false;\n \t}\n \n       map1 = map1->next;\n@@ -596,39 +596,39 @@ gfc_compare_union_types (gfc_symbol *un1, gfc_symbol *un2)\n       if (map1 == NULL && map2 == NULL)\n \tbreak;\n       if (map1 == NULL || map2 == NULL)\n-\treturn 0;\n+\treturn false;\n     }\n \n-  return 1;\n+  return true;\n }\n \n \n \n /* Compare two derived types using the criteria in 4.4.2 of the standard,\n    recursing through gfc_compare_types for the components.  */\n \n-int\n+bool\n gfc_compare_derived_types (gfc_symbol *derived1, gfc_symbol *derived2)\n {\n   gfc_component *cmp1, *cmp2;\n \n   if (derived1 == derived2)\n-    return 1;\n+    return true;\n \n   if (!derived1 || !derived2)\n     gfc_internal_error (\"gfc_compare_derived_types: invalid derived type\");\n \n   /* Compare UNION types specially.  */\n   if (derived1->attr.flavor == FL_UNION || derived2->attr.flavor == FL_UNION)\n-    return gfc_compare_union_types (derived1, derived2);\n+    return compare_union_types (derived1, derived2);\n \n   /* Special case for comparing derived types across namespaces.  If the\n      true names and module names are the same and the module name is\n      nonnull, then they are equal.  */\n   if (strcmp (derived1->name, derived2->name) == 0\n       && derived1->module != NULL && derived2->module != NULL\n       && strcmp (derived1->module, derived2->module) == 0)\n-    return 1;\n+    return true;\n \n   /* Compare type via the rules of the standard.  Both types must have\n      the SEQUENCE or BIND(C) attribute to be equal. STRUCTUREs are special\n@@ -638,22 +638,22 @@ gfc_compare_derived_types (gfc_symbol *derived1, gfc_symbol *derived2)\n   /* Compare names, but not for anonymous types such as UNION or MAP.  */\n   if (!is_anonymous_dt (derived1) && !is_anonymous_dt (derived2)\n       && strcmp (derived1->name, derived2->name) != 0)\n-    return 0;\n+    return false;\n \n   if (derived1->component_access == ACCESS_PRIVATE\n       || derived2->component_access == ACCESS_PRIVATE)\n-    return 0;\n+    return false;\n \n   if (!(derived1->attr.sequence && derived2->attr.sequence)\n       && !(derived1->attr.is_bind_c && derived2->attr.is_bind_c))\n-    return 0;\n+    return false;\n \n   /* Protect against null components.  */\n   if (derived1->attr.zero_comp != derived2->attr.zero_comp)\n-    return 0;\n+    return false;\n \n   if (derived1->attr.zero_comp)\n-    return 1;\n+    return true;\n \n   cmp1 = derived1->components;\n   cmp2 = derived2->components;\n@@ -664,32 +664,32 @@ gfc_compare_derived_types (gfc_symbol *derived1, gfc_symbol *derived2)\n   for (;;)\n     {\n       if (!compare_components (cmp1, cmp2, derived1, derived2))\n-        return 0;\n+        return false;\n \n       cmp1 = cmp1->next;\n       cmp2 = cmp2->next;\n \n       if (cmp1 == NULL && cmp2 == NULL)\n \tbreak;\n       if (cmp1 == NULL || cmp2 == NULL)\n-\treturn 0;\n+\treturn false;\n     }\n \n-  return 1;\n+  return true;\n }\n \n \n /* Compare two typespecs, recursively if necessary.  */\n \n-int\n+bool\n gfc_compare_types (gfc_typespec *ts1, gfc_typespec *ts2)\n {\n   /* See if one of the typespecs is a BT_VOID, which is what is being used\n      to allow the funcs like c_f_pointer to accept any pointer type.\n      TODO: Possibly should narrow this to just the one typespec coming in\n      that is for the formal arg, but oh well.  */\n   if (ts1->type == BT_VOID || ts2->type == BT_VOID)\n-    return 1;\n+    return true;\n \n   /* The _data component is not always present, therefore check for its\n      presence before assuming, that its derived->attr is available.\n@@ -700,7 +700,7 @@ gfc_compare_types (gfc_typespec *ts1, gfc_typespec *ts2)\n \t   && ts1->u.derived->components->ts.u.derived->attr\n \t\t\t\t\t\t  .unlimited_polymorphic)\n \t  || ts1->u.derived->attr.unlimited_polymorphic))\n-    return 1;\n+    return true;\n \n   /* F2003: C717  */\n   if (ts2->type == BT_CLASS && ts1->type == BT_DERIVED\n@@ -710,15 +710,15 @@ gfc_compare_types (gfc_typespec *ts1, gfc_typespec *ts2)\n \t\t\t\t\t\t  .unlimited_polymorphic)\n \t  || ts2->u.derived->attr.unlimited_polymorphic)\n       && (ts1->u.derived->attr.sequence || ts1->u.derived->attr.is_bind_c))\n-    return 1;\n+    return true;\n \n   if (ts1->type != ts2->type\n       && ((ts1->type != BT_DERIVED && ts1->type != BT_CLASS)\n \t  || (ts2->type != BT_DERIVED && ts2->type != BT_CLASS)))\n-    return 0;\n+    return false;\n \n   if (ts1->type == BT_UNION)\n-    return gfc_compare_union_types (ts1->u.derived, ts2->u.derived);\n+    return compare_union_types (ts1->u.derived, ts2->u.derived);\n \n   if (ts1->type != BT_DERIVED && ts1->type != BT_CLASS)\n     return (ts1->kind == ts2->kind);\n@@ -728,30 +728,30 @@ gfc_compare_types (gfc_typespec *ts1, gfc_typespec *ts2)\n }\n \n \n-static int\n+static bool\n compare_type (gfc_symbol *s1, gfc_symbol *s2)\n {\n   if (s2->attr.ext_attr & (1 << EXT_ATTR_NO_ARG_CHECK))\n-    return 1;\n+    return true;\n \n   /* TYPE and CLASS of the same declared type are type compatible,\n      but have different characteristics.  */\n   if ((s1->ts.type == BT_CLASS && s2->ts.type == BT_DERIVED)\n       || (s1->ts.type == BT_DERIVED && s2->ts.type == BT_CLASS))\n-    return 0;\n+    return false;\n \n   return gfc_compare_types (&s1->ts, &s2->ts) || s2->ts.type == BT_ASSUMED;\n }\n \n \n-static int\n+static bool\n compare_rank (gfc_symbol *s1, gfc_symbol *s2)\n {\n   gfc_array_spec *as1, *as2;\n   int r1, r2;\n \n   if (s2->attr.ext_attr & (1 << EXT_ATTR_NO_ARG_CHECK))\n-    return 1;\n+    return true;\n \n   as1 = (s1->ts.type == BT_CLASS) ? CLASS_DATA (s1)->as : s1->as;\n   as2 = (s2->ts.type == BT_CLASS) ? CLASS_DATA (s2)->as : s2->as;\n@@ -760,17 +760,17 @@ compare_rank (gfc_symbol *s1, gfc_symbol *s2)\n   r2 = as2 ? as2->rank : 0;\n \n   if (r1 != r2 && (!as2 || as2->type != AS_ASSUMED_RANK))\n-    return 0;\t\t\t/* Ranks differ.  */\n+    return false;  /* Ranks differ.  */\n \n-  return 1;\n+  return true;\n }\n \n \n /* Given two symbols that are formal arguments, compare their ranks\n-   and types.  Returns nonzero if they have the same rank and type,\n-   zero otherwise.  */\n+   and types.  Returns true if they have the same rank and type,\n+   false otherwise.  */\n \n-static int\n+static bool\n compare_type_rank (gfc_symbol *s1, gfc_symbol *s2)\n {\n   return compare_type (s1, s2) && compare_rank (s1, s2);\n@@ -779,44 +779,44 @@ compare_type_rank (gfc_symbol *s1, gfc_symbol *s2)\n \n /* Given two symbols that are formal arguments, compare their types\n    and rank and their formal interfaces if they are both dummy\n-   procedures.  Returns nonzero if the same, zero if different.  */\n+   procedures.  Returns true if the same, false if different.  */\n \n-static int\n+static bool\n compare_type_rank_if (gfc_symbol *s1, gfc_symbol *s2)\n {\n   if (s1 == NULL || s2 == NULL)\n-    return s1 == s2 ? 1 : 0;\n+    return (s1 == s2);\n \n   if (s1 == s2)\n-    return 1;\n+    return true;\n \n   if (s1->attr.flavor != FL_PROCEDURE && s2->attr.flavor != FL_PROCEDURE)\n     return compare_type_rank (s1, s2);\n \n   if (s1->attr.flavor != FL_PROCEDURE || s2->attr.flavor != FL_PROCEDURE)\n-    return 0;\n+    return false;\n \n   /* At this point, both symbols are procedures.  It can happen that\n      external procedures are compared, where one is identified by usage\n      to be a function or subroutine but the other is not.  Check TKR\n      nonetheless for these cases.  */\n   if (s1->attr.function == 0 && s1->attr.subroutine == 0)\n-    return s1->attr.external == 1 ? compare_type_rank (s1, s2) : 0;\n+    return s1->attr.external ? compare_type_rank (s1, s2) : false;\n \n   if (s2->attr.function == 0 && s2->attr.subroutine == 0)\n-    return s2->attr.external == 1 ? compare_type_rank (s1, s2) : 0;\n+    return s2->attr.external ? compare_type_rank (s1, s2) : false;\n \n   /* Now the type of procedure has been identified.  */\n   if (s1->attr.function != s2->attr.function\n       || s1->attr.subroutine != s2->attr.subroutine)\n-    return 0;\n+    return false;\n \n-  if (s1->attr.function && compare_type_rank (s1, s2) == 0)\n-    return 0;\n+  if (s1->attr.function && !compare_type_rank (s1, s2))\n+    return false;\n \n   /* Originally, gfortran recursed here to check the interfaces of passed\n      procedures.  This is explicitly not required by the standard.  */\n-  return 1;\n+  return true;\n }\n \n \n@@ -1089,11 +1089,11 @@ gfc_check_operator_interface (gfc_symbol *sym, gfc_intrinsic_op op,\n    by this test. This subroutine implements rule 1 of section F03:16.2.3.\n    'p1' and 'p2' are the PASS arguments of both procedures (if applicable).  */\n \n-static int\n+static bool\n count_types_test (gfc_formal_arglist *f1, gfc_formal_arglist *f2,\n \t\t  const char *p1, const char *p2)\n {\n-  int rc, ac1, ac2, i, j, k, n1;\n+  int ac1, ac2, i, j, k, n1;\n   gfc_formal_arglist *f;\n \n   typedef struct\n@@ -1148,7 +1148,7 @@ count_types_test (gfc_formal_arglist *f1, gfc_formal_arglist *f2,\n \n   /* Now loop over each distinct type found in f1.  */\n   k = 0;\n-  rc = 0;\n+  bool rc = false;\n \n   for (i = 0; i < n1; i++)\n     {\n@@ -1172,7 +1172,7 @@ count_types_test (gfc_formal_arglist *f1, gfc_formal_arglist *f2,\n \n       if (ac1 > ac2)\n \t{\n-\t  rc = 1;\n+\t  rc = true;\n \t  break;\n \t}\n \n@@ -1206,7 +1206,7 @@ count_types_test (gfc_formal_arglist *f1, gfc_formal_arglist *f2,\n \n    At this point, 'CALL FOO(A=1, B=1.0)' is ambiguous.  */\n \n-static int\n+static bool\n generic_correspondence (gfc_formal_arglist *f1, gfc_formal_arglist *f2,\n \t\t\tconst char *p1, const char *p2)\n {\n@@ -1244,7 +1244,7 @@ generic_correspondence (gfc_formal_arglist *f1, gfc_formal_arglist *f2,\n \t      || ((gfc_option.allow_std & GFC_STD_F2008)\n \t\t  && ((sym->attr.allocatable && g->sym->attr.pointer)\n \t\t      || (sym->attr.pointer && g->sym->attr.allocatable))))\n-\t    return 1;\n+\t    return true;\n \t}\n \n     next:\n@@ -1254,7 +1254,7 @@ generic_correspondence (gfc_formal_arglist *f1, gfc_formal_arglist *f2,\n \tf2 = f2->next;\n     }\n \n-  return 0;\n+  return false;\n }\n \n \n@@ -1638,13 +1638,13 @@ gfc_check_result_characteristics (gfc_symbol *s1, gfc_symbol *s2,\n \n \n /* 'Compare' two formal interfaces associated with a pair of symbols.\n-   We return nonzero if there exists an actual argument list that\n+   We return true if there exists an actual argument list that\n    would be ambiguous between the two interfaces, zero otherwise.\n    'strict_flag' specifies whether all the characteristics are\n    required to match, which is not the case for ambiguity checks.\n    'p1' and 'p2' are the PASS arguments of both procedures (if applicable).  */\n \n-int\n+bool\n gfc_compare_interfaces (gfc_symbol *s1, gfc_symbol *s2, const char *name2,\n \t\t\tint generic_flag, int strict_flag,\n \t\t\tchar *errmsg, int err_len,\n@@ -1660,14 +1660,14 @@ gfc_compare_interfaces (gfc_symbol *s1, gfc_symbol *s2, const char *name2,\n     {\n       if (errmsg != NULL)\n \tsnprintf (errmsg, err_len, \"'%s' is not a function\", name2);\n-      return 0;\n+      return false;\n     }\n \n   if (s1->attr.subroutine && s2->attr.function)\n     {\n       if (errmsg != NULL)\n \tsnprintf (errmsg, err_len, \"'%s' is not a subroutine\", name2);\n-      return 0;\n+      return false;\n     }\n \n   /* Do strict checks on all characteristics\n@@ -1679,48 +1679,48 @@ gfc_compare_interfaces (gfc_symbol *s1, gfc_symbol *s2, const char *name2,\n \t  /* If both are functions, check result characteristics.  */\n \t  if (!gfc_check_result_characteristics (s1, s2, errmsg, err_len)\n \t      || !gfc_check_result_characteristics (s2, s1, errmsg, err_len))\n-\t    return 0;\n+\t    return false;\n \t}\n \n       if (s1->attr.pure && !s2->attr.pure)\n \t{\n \t  snprintf (errmsg, err_len, \"Mismatch in PURE attribute\");\n-\t  return 0;\n+\t  return false;\n \t}\n       if (s1->attr.elemental && !s2->attr.elemental)\n \t{\n \t  snprintf (errmsg, err_len, \"Mismatch in ELEMENTAL attribute\");\n-\t  return 0;\n+\t  return false;\n \t}\n     }\n \n   if (s1->attr.if_source == IFSRC_UNKNOWN\n       || s2->attr.if_source == IFSRC_UNKNOWN)\n-    return 1;\n+    return true;\n \n   f1 = gfc_sym_get_dummy_args (s1);\n   f2 = gfc_sym_get_dummy_args (s2);\n \n   /* Special case: No arguments.  */\n   if (f1 == NULL && f2 == NULL)\n-    return 1;\n+    return true;\n \n   if (generic_flag)\n     {\n       if (count_types_test (f1, f2, p1, p2)\n \t  || count_types_test (f2, f1, p2, p1))\n-\treturn 0;\n+\treturn false;\n \n       /* Special case: alternate returns.  If both f1->sym and f2->sym are\n \t NULL, then the leading formal arguments are alternate returns.\n \t The previous conditional should catch argument lists with\n \t different number of argument.  */\n       if (f1 && f1->sym == NULL && f2 && f2->sym == NULL)\n-\treturn 1;\n+\treturn true;\n \n       if (generic_correspondence (f1, f2, p1, p2)\n \t  || generic_correspondence (f2, f1, p2, p1))\n-\treturn 0;\n+\treturn false;\n     }\n   else\n     /* Perform the abbreviated correspondence test for operators (the\n@@ -1736,15 +1736,15 @@ gfc_compare_interfaces (gfc_symbol *s1, gfc_symbol *s2, const char *name2,\n \t    if (errmsg != NULL)\n \t      snprintf (errmsg, err_len, \"'%s' has the wrong number of \"\n \t\t\t\"arguments\", name2);\n-\t    return 0;\n+\t    return false;\n \t  }\n \n \tif (strict_flag)\n \t  {\n \t    /* Check all characteristics.  */\n \t    if (!gfc_check_dummy_characteristics (f1->sym, f2->sym, true,\n \t\t\t\t\t      errmsg, err_len))\n-\t      return 0;\n+\t      return false;\n \t  }\n \telse\n \t  {\n@@ -1756,29 +1756,29 @@ gfc_compare_interfaces (gfc_symbol *s1, gfc_symbol *s2, const char *name2,\n \t\t\t    \"(%s/%s)\", f1->sym->name,\n \t\t\t    gfc_typename (&f1->sym->ts),\n \t\t\t    gfc_typename (&f2->sym->ts));\n-\t\treturn 0;\n+\t\treturn false;\n \t      }\n \t    if (!compare_rank (f2->sym, f1->sym))\n \t      {\n \t\tif (errmsg != NULL)\n \t\t  snprintf (errmsg, err_len, \"Rank mismatch in argument '%s' \"\n \t\t\t    \"(%i/%i)\", f1->sym->name, symbol_rank (f1->sym),\n \t\t\t    symbol_rank (f2->sym));\n-\t\treturn 0;\n+\t\treturn false;\n \t      }\n \t  }\n       }\n \n-  return 1;\n+  return true;\n }\n \n \n /* Given a pointer to an interface pointer, remove duplicate\n    interfaces and make sure that all symbols are either functions\n-   or subroutines, and all of the same kind.  Returns nonzero if\n+   or subroutines, and all of the same kind.  Returns true if\n    something goes wrong.  */\n \n-static int\n+static bool\n check_interface0 (gfc_interface *p, const char *interface_name)\n {\n   gfc_interface *psave, *q, *qlast;\n@@ -1799,7 +1799,7 @@ check_interface0 (gfc_interface *p, const char *interface_name)\n \t    gfc_error (\"Procedure %qs in %s at %L is neither function nor \"\n \t\t       \"subroutine\", p->sym->name, interface_name,\n \t\t      &p->sym->declared_at);\n-\t  return 1;\n+\t  return true;\n \t}\n \n       /* Verify that procedures are either all SUBROUTINEs or all FUNCTIONs.  */\n@@ -1815,15 +1815,15 @@ check_interface0 (gfc_interface *p, const char *interface_name)\n \t    gfc_error (\"In %s at %L procedures must be all FUNCTIONs as the \"\n \t\t       \"generic name is also the name of a derived type\",\n \t\t       interface_name, &p->sym->declared_at);\n-\t  return 1;\n+\t  return true;\n \t}\n \n       /* F2003, C1207. F2008, C1207.  */\n       if (p->sym->attr.proc == PROC_INTERNAL\n \t  && !gfc_notify_std (GFC_STD_F2008, \"Internal procedure \"\n \t\t\t      \"%qs in %s at %L\", p->sym->name,\n \t\t\t      interface_name, &p->sym->declared_at))\n-\treturn 1;\n+\treturn true;\n     }\n   p = psave;\n \n@@ -1849,14 +1849,14 @@ check_interface0 (gfc_interface *p, const char *interface_name)\n \t}\n     }\n \n-  return 0;\n+  return false;\n }\n \n \n /* Check lists of interfaces to make sure that no two interfaces are\n    ambiguous.  Duplicate interfaces (from the same symbol) are OK here.  */\n \n-static int\n+static bool\n check_interface1 (gfc_interface *p, gfc_interface *q0,\n \t\t  int generic_flag, const char *interface_name,\n \t\t  bool referenced)\n@@ -1889,10 +1889,10 @@ check_interface1 (gfc_interface *p, gfc_interface *q0,\n \t    else\n \t      gfc_warning (0, \"Although not referenced, %qs has ambiguous \"\n \t\t\t   \"interfaces at %L\", interface_name, &p->where);\n-\t    return 1;\n+\t    return true;\n \t  }\n       }\n-  return 0;\n+  return false;\n }\n \n \n@@ -2070,22 +2070,22 @@ gfc_check_interfaces (gfc_namespace *ns)\n \n /* Given a symbol of a formal argument list and an expression, if the\n    formal argument is allocatable, check that the actual argument is\n-   allocatable. Returns nonzero if compatible, zero if not compatible.  */\n+   allocatable. Returns true if compatible, zero if not compatible.  */\n \n-static int\n+static bool\n compare_allocatable (gfc_symbol *formal, gfc_expr *actual)\n {\n   if (formal->attr.allocatable\n       || (formal->ts.type == BT_CLASS && CLASS_DATA (formal)->attr.allocatable))\n     {\n       symbol_attribute attr = gfc_expr_attr (actual);\n       if (actual->ts.type == BT_CLASS && !attr.class_ok)\n-\treturn 1;\n+\treturn true;\n       else if (!attr.allocatable)\n-\treturn 0;\n+\treturn false;\n     }\n \n-  return 1;\n+  return true;\n }\n \n \n@@ -2148,10 +2148,10 @@ argument_rank_mismatch (const char *name, locus *where,\n \n \n /* Given a symbol of a formal argument list and an expression, see if\n-   the two are compatible as arguments.  Returns nonzero if\n-   compatible, zero if not compatible.  */\n+   the two are compatible as arguments.  Returns true if\n+   compatible, false if not compatible.  */\n \n-static int\n+static bool\n compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t\t   int ranks_must_agree, int is_elemental, locus *where)\n {\n@@ -2164,13 +2164,13 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n      procs c_f_pointer or c_f_procpointer, and we need to accept most\n      pointers the user could give us.  This should allow that.  */\n   if (formal->ts.type == BT_VOID)\n-    return 1;\n+    return true;\n \n   if (formal->ts.type == BT_DERIVED\n       && formal->ts.u.derived && formal->ts.u.derived->ts.is_iso_c\n       && actual->ts.type == BT_DERIVED\n       && actual->ts.u.derived && actual->ts.u.derived->ts.is_iso_c)\n-    return 1;\n+    return true;\n \n   if (formal->ts.type == BT_CLASS && actual->ts.type == BT_DERIVED)\n     /* Make sure the vtab symbol is present when\n@@ -2185,7 +2185,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t{\n \t  if (where)\n \t    gfc_error (\"Invalid procedure argument at %L\", &actual->where);\n-\t  return 0;\n+\t  return false;\n \t}\n \n       if (!gfc_compare_interfaces (formal, act_sym, act_sym->name, 0, 1, err,\n@@ -2195,7 +2195,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t    gfc_error (OPT_Wargument_mismatch,\n \t\t       \"Interface mismatch in dummy procedure %qs at %L: %s\",\n \t\t       formal->name, &actual->where, err);\n-\t  return 0;\n+\t  return false;\n \t}\n \n       if (formal->attr.function && !act_sym->attr.function)\n@@ -2204,13 +2204,13 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t  &act_sym->declared_at);\n \t  if (act_sym->ts.type == BT_UNKNOWN\n \t      && !gfc_set_default_type (act_sym, 1, act_sym->ns))\n-\t    return 0;\n+\t    return false;\n \t}\n       else if (formal->attr.subroutine && !act_sym->attr.subroutine)\n \tgfc_add_subroutine (&act_sym->attr, act_sym->name,\n \t\t\t    &act_sym->declared_at);\n \n-      return 1;\n+      return true;\n     }\n \n   ppc = gfc_get_proc_ptr_comp (actual);\n@@ -2223,7 +2223,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t    gfc_error (OPT_Wargument_mismatch,\n \t\t       \"Interface mismatch in dummy procedure %qs at %L: %s\",\n \t\t       formal->name, &actual->where, err);\n-\t  return 0;\n+\t  return false;\n \t}\n     }\n \n@@ -2234,12 +2234,12 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n       if (where)\n \tgfc_error (\"Actual argument to contiguous pointer dummy %qs at %L \"\n \t\t   \"must be simply contiguous\", formal->name, &actual->where);\n-      return 0;\n+      return false;\n     }\n \n   symbol_attribute actual_attr = gfc_expr_attr (actual);\n   if (actual->ts.type == BT_CLASS && !actual_attr.class_ok)\n-    return 1;\n+    return true;\n \n   if ((actual->expr_type != EXPR_NULL || actual->ts.type != BT_UNKNOWN)\n       && actual->ts.type != BT_HOLLERITH\n@@ -2255,7 +2255,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t\t   \"Type mismatch in argument %qs at %L; passed %s to %s\",\n \t\t   formal->name, where, gfc_typename (&actual->ts),\n \t\t   gfc_typename (&formal->ts));\n-      return 0;\n+      return false;\n     }\n \n   if (actual->ts.type == BT_ASSUMED && formal->ts.type != BT_ASSUMED)\n@@ -2264,7 +2264,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \tgfc_error (\"Assumed-type actual argument at %L requires that dummy \"\n \t\t   \"argument %qs is of assumed type\", &actual->where,\n \t\t   formal->name);\n-      return 0;\n+      return false;\n     }\n \n   /* F2008, 12.5.2.5; IR F08/0073.  */\n@@ -2279,7 +2279,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t  if (where)\n \t    gfc_error (\"Actual argument to %qs at %L must be polymorphic\",\n \t\t\tformal->name, &actual->where);\n-\t  return 0;\n+\t  return false;\n \t}\n \n       if ((!UNLIMITED_POLY (formal) || !UNLIMITED_POLY(actual))\n@@ -2289,7 +2289,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t  if (where)\n \t    gfc_error (\"Actual argument to %qs at %L must have the same \"\n \t\t       \"declared type\", formal->name, &actual->where);\n-\t  return 0;\n+\t  return false;\n \t}\n     }\n \n@@ -2307,15 +2307,15 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t\t   \"pointer or allocatable unlimited polymorphic \"\n \t\t   \"entity [F2008: 12.5.2.5]\", formal->name,\n \t\t   &actual->where);\n-      return 0;\n+      return false;\n     }\n \n   if (formal->attr.codimension && !gfc_is_coarray (actual))\n     {\n       if (where)\n \tgfc_error (\"Actual argument to %qs at %L must be a coarray\",\n \t\t       formal->name, &actual->where);\n-      return 0;\n+      return false;\n     }\n \n   if (formal->attr.codimension && formal->attr.allocatable)\n@@ -2336,7 +2336,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t\t   formal->name, &actual->where, formal->as->corank,\n \t\t   last ? last->u.c.component->as->corank\n \t\t\t: actual->symtree->n.sym->as->corank);\n-\t  return 0;\n+\t  return false;\n \t}\n     }\n \n@@ -2353,7 +2353,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t    gfc_error (\"Actual argument to %qs at %L must be simply \"\n \t\t       \"contiguous or an element of such an array\",\n \t\t       formal->name, &actual->where);\n-\t  return 0;\n+\t  return false;\n \t}\n \n       /* F2008, C1303 and C1304.  */\n@@ -2368,7 +2368,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t    gfc_error (\"Actual argument to non-INTENT(INOUT) dummy %qs at %L, \"\n \t\t       \"which is LOCK_TYPE or has a LOCK_TYPE component\",\n \t\t       formal->name, &actual->where);\n-\t  return 0;\n+\t  return false;\n \t}\n \n       /* TS18508, C702/C703.  */\n@@ -2383,7 +2383,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t    gfc_error (\"Actual argument to non-INTENT(INOUT) dummy %qs at %L, \"\n \t\t       \"which is EVENT_TYPE or has a EVENT_TYPE component\",\n \t\t       formal->name, &actual->where);\n-\t  return 0;\n+\t  return false;\n \t}\n     }\n \n@@ -2403,7 +2403,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t\t   \"assumed-rank array without CONTIGUOUS attribute - as actual\"\n \t\t   \" argument at %L is not simply contiguous and both are \"\n \t\t   \"ASYNCHRONOUS or VOLATILE\", formal->name, &actual->where);\n-      return 0;\n+      return false;\n     }\n \n   if (formal->attr.allocatable && !formal->attr.codimension\n@@ -2415,7 +2415,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t    gfc_error (\"Passing coarray at %L to allocatable, noncoarray, \"\n \t\t       \"INTENT(OUT) dummy argument %qs\", &actual->where,\n \t\t       formal->name);\n-\t  return 0;\n+\t  return false;\n \t}\n       else if (warn_surprising && where && formal->attr.intent != INTENT_IN)\n \tgfc_warning (OPT_Wsurprising,\n@@ -2426,7 +2426,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \n   /* If the rank is the same or the formal argument has assumed-rank.  */\n   if (symbol_rank (formal) == actual->rank || symbol_rank (formal) == -1)\n-    return 1;\n+    return true;\n \n   rank_check = where != NULL && !is_elemental && formal->as\n \t       && (formal->as->type == AS_ASSUMED_SHAPE\n@@ -2435,7 +2435,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \n   /* Skip rank checks for NO_ARG_CHECK.  */\n   if (formal->attr.ext_attr & (1 << EXT_ATTR_NO_ARG_CHECK))\n-    return 1;\n+    return true;\n \n   /* Scalar & coindexed, see: F2008, Section 12.5.2.4.  */\n   if (rank_check || ranks_must_agree\n@@ -2453,10 +2453,10 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n       if (where)\n \targument_rank_mismatch (formal->name, &actual->where,\n \t\t\t\tsymbol_rank (formal), actual->rank);\n-      return 0;\n+      return false;\n     }\n   else if (actual->rank != 0 && (is_elemental || formal->attr.dimension))\n-    return 1;\n+    return true;\n \n   /* At this point, we are considering a scalar passed to an array.   This\n      is valid (cf. F95 12.4.1.1, F2003 12.4.1.2, and F2008 12.5.2.4),\n@@ -2484,7 +2484,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n       if (where)\n \tgfc_error (\"Polymorphic scalar passed to array dummy argument %qs \"\n \t\t   \"at %L\", formal->name, &actual->where);\n-      return 0;\n+      return false;\n     }\n \n   if (actual->expr_type != EXPR_NULL && ref && actual->ts.type != BT_CHARACTER\n@@ -2494,7 +2494,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \tgfc_error (\"Element of assumed-shaped or pointer \"\n \t\t   \"array passed to array dummy argument %qs at %L\",\n \t\t   formal->name, &actual->where);\n-      return 0;\n+      return false;\n     }\n \n   if (actual->ts.type == BT_CHARACTER && actual->expr_type != EXPR_NULL\n@@ -2506,31 +2506,29 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t    gfc_error (\"Extension: Scalar non-default-kind, non-C_CHAR-kind \"\n \t\t       \"CHARACTER actual argument with array dummy argument \"\n \t\t       \"%qs at %L\", formal->name, &actual->where);\n-\t  return 0;\n+\t  return false;\n \t}\n \n       if (where && (gfc_option.allow_std & GFC_STD_F2003) == 0)\n \t{\n \t  gfc_error (\"Fortran 2003: Scalar CHARACTER actual argument with \"\n \t\t     \"array dummy argument %qs at %L\",\n \t\t     formal->name, &actual->where);\n-\t  return 0;\n+\t  return false;\n \t}\n-      else if ((gfc_option.allow_std & GFC_STD_F2003) == 0)\n-\treturn 0;\n       else\n-\treturn 1;\n+\treturn ((gfc_option.allow_std & GFC_STD_F2003) != 0);\n     }\n \n   if (ref == NULL && actual->expr_type != EXPR_NULL)\n     {\n       if (where)\n \targument_rank_mismatch (formal->name, &actual->where,\n \t\t\t\tsymbol_rank (formal), actual->rank);\n-      return 0;\n+      return false;\n     }\n \n-  return 1;\n+  return true;\n }\n \n \n@@ -2754,25 +2752,24 @@ get_expr_storage_size (gfc_expr *e)\n \n \n /* Given an expression, check whether it is an array section\n-   which has a vector subscript. If it has, one is returned,\n-   otherwise zero.  */\n+   which has a vector subscript.  */\n \n-int\n+bool\n gfc_has_vector_subscript (gfc_expr *e)\n {\n   int i;\n   gfc_ref *ref;\n \n   if (e == NULL || e->rank == 0 || e->expr_type != EXPR_VARIABLE)\n-    return 0;\n+    return false;\n \n   for (ref = e->ref; ref; ref = ref->next)\n     if (ref->type == REF_ARRAY && ref->u.ar.type == AR_SECTION)\n       for (i = 0; i < ref->u.ar.dimen; i++)\n \tif (ref->u.ar.dimen_type[i] == DIMEN_VECTOR)\n-\t  return 1;\n+\t  return true;\n \n-  return 0;\n+  return false;\n }\n \n \n@@ -2795,7 +2792,7 @@ is_procptr_result (gfc_expr *expr)\n    errors when things don't match instead of just returning the status\n    code.  */\n \n-static int\n+static bool\n compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t \t       int ranks_must_agree, int is_elemental, locus *where)\n {\n@@ -2809,7 +2806,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n   actual = *ap;\n \n   if (actual == NULL && formal == NULL)\n-    return 1;\n+    return true;\n \n   n = 0;\n   for (f = formal; f; f = f->next)\n@@ -2843,7 +2840,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t      if (where)\n \t\tgfc_error (\"Keyword argument %qs at %L is not in \"\n \t\t\t   \"the procedure\", a->name, &a->expr->where);\n-\t      return 0;\n+\t      return false;\n \t    }\n \n \t  if (new_arg[i] != NULL)\n@@ -2852,7 +2849,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t\tgfc_error (\"Keyword argument %qs at %L is already associated \"\n \t\t\t   \"with another actual argument\", a->name,\n \t\t\t   &a->expr->where);\n-\t      return 0;\n+\t      return false;\n \t    }\n \t}\n \n@@ -2862,7 +2859,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t    gfc_error (\"More actual than formal arguments in procedure \"\n \t\t       \"call at %L\", where);\n \n-\t  return 0;\n+\t  return false;\n \t}\n \n       if (f->sym == NULL && a->expr == NULL)\n@@ -2873,15 +2870,15 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t  if (where)\n \t    gfc_error (\"Missing alternate return spec in subroutine call \"\n \t\t       \"at %L\", where);\n-\t  return 0;\n+\t  return false;\n \t}\n \n       if (a->expr == NULL)\n \t{\n \t  if (where)\n \t    gfc_error (\"Unexpected alternate return spec in subroutine \"\n \t\t       \"call at %L\", where);\n-\t  return 0;\n+\t  return false;\n \t}\n \n       /* Make sure that intrinsic vtables exist for calls to unlimited\n@@ -2912,12 +2909,12 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t    gfc_error (\"Fortran 2008: Null pointer at %L to non-pointer \"\n \t\t       \"dummy %qs\", where, f->sym->name);\n \n-\t  return 0;\n+\t  return false;\n \t}\n \n       if (!compare_parameter (f->sym, a->expr, ranks_must_agree,\n \t\t\t      is_elemental, where))\n-\treturn 0;\n+\treturn false;\n \n       /* TS 29113, 6.3p2.  */\n       if (f->sym->ts.type == BT_ASSUMED\n@@ -2970,7 +2967,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t\t\t mpz_get_si (a->expr->ts.u.cl->length->value.integer),\n \t\t\t mpz_get_si (f->sym->ts.u.cl->length->value.integer),\n \t\t\t f->sym->name, &a->expr->where);\n-\t  return 0;\n+\t  return false;\n \t}\n \n       if ((f->sym->attr.pointer || f->sym->attr.allocatable)\n@@ -2982,7 +2979,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t\t       \"pointer dummy argument %qs must have a deferred \"\n \t\t       \"length type parameter if and only if the dummy has one\",\n \t\t       &a->expr->where, f->sym->name);\n-\t  return 0;\n+\t  return false;\n \t}\n \n       if (f->sym->ts.type == BT_CLASS)\n@@ -3006,7 +3003,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t\t\t \"elements for dummy argument %qs (%lu/%lu) at %L\",\n \t\t\t f->sym->name, actual_size, formal_size,\n \t\t\t &a->expr->where);\n-\t  return  0;\n+\t  return false;\n \t}\n \n      skip_size_check:\n@@ -3023,7 +3020,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t  if (where)\n \t    gfc_error (\"Expected a procedure pointer for argument %qs at %L\",\n \t\t       f->sym->name, &a->expr->where);\n-\t  return 0;\n+\t  return false;\n \t}\n \n       /* Satisfy F03:12.4.1.3 by ensuring that a procedure actual argument is\n@@ -3039,7 +3036,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t  if (where)\n \t    gfc_error (\"Expected a procedure for argument %qs at %L\",\n \t\t       f->sym->name, &a->expr->where);\n-\t  return 0;\n+\t  return false;\n \t}\n \n       if (f->sym->as && f->sym->as->type == AS_ASSUMED_SHAPE\n@@ -3053,7 +3050,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t  if (where)\n \t    gfc_error (\"Actual argument for %qs cannot be an assumed-size\"\n \t\t       \" array at %L\", f->sym->name, where);\n-\t  return 0;\n+\t  return false;\n \t}\n \n       if (a->expr->expr_type != EXPR_NULL\n@@ -3062,7 +3059,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t  if (where)\n \t    gfc_error (\"Actual argument for %qs must be a pointer at %L\",\n \t\t       f->sym->name, &a->expr->where);\n-\t  return 0;\n+\t  return false;\n \t}\n \n       if (a->expr->expr_type != EXPR_NULL\n@@ -3072,7 +3069,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t  if (where)\n \t    gfc_error (\"Fortran 2008: Non-pointer actual argument at %L to \"\n \t\t       \"pointer dummy %qs\", &a->expr->where,f->sym->name);\n-\t  return 0;\n+\t  return false;\n \t}\n \n \n@@ -3083,7 +3080,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t    gfc_error (\"Coindexed actual argument at %L to pointer \"\n \t\t       \"dummy %qs\",\n \t\t       &a->expr->where, f->sym->name);\n-\t  return 0;\n+\t  return false;\n \t}\n \n       /* Fortran 2008, 12.5.2.5 (no constraint).  */\n@@ -3096,7 +3093,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t    gfc_error (\"Coindexed actual argument at %L to allocatable \"\n \t\t       \"dummy %qs requires INTENT(IN)\",\n \t\t       &a->expr->where, f->sym->name);\n-\t  return 0;\n+\t  return false;\n \t}\n \n       /* Fortran 2008, C1237.  */\n@@ -3111,7 +3108,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t\t       \"%L requires that dummy %qs has neither \"\n \t\t       \"ASYNCHRONOUS nor VOLATILE\", &a->expr->where,\n \t\t       f->sym->name);\n-\t  return 0;\n+\t  return false;\n \t}\n \n       /* Fortran 2008, 12.5.2.4 (no constraint).  */\n@@ -3124,7 +3121,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t    gfc_error (\"Coindexed actual argument at %L with allocatable \"\n \t\t       \"ultimate component to dummy %qs requires either VALUE \"\n \t\t       \"or INTENT(IN)\", &a->expr->where, f->sym->name);\n-\t  return 0;\n+\t  return false;\n \t}\n \n      if (f->sym->ts.type == BT_CLASS\n@@ -3135,17 +3132,17 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t  if (where)\n \t    gfc_error (\"Actual CLASS array argument for %qs must be a full \"\n \t\t       \"array at %L\", f->sym->name, &a->expr->where);\n-\t  return 0;\n+\t  return false;\n \t}\n \n \n       if (a->expr->expr_type != EXPR_NULL\n-\t  && compare_allocatable (f->sym, a->expr) == 0)\n+\t  && !compare_allocatable (f->sym, a->expr))\n \t{\n \t  if (where)\n \t    gfc_error (\"Actual argument for %qs must be ALLOCATABLE at %L\",\n \t\t       f->sym->name, &a->expr->where);\n-\t  return 0;\n+\t  return false;\n \t}\n \n       /* Check intent = OUT/INOUT for definable actual argument.  */\n@@ -3160,9 +3157,9 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t\t&& CLASS_DATA (f->sym)->attr.class_pointer)\n \t       || (f->sym->ts.type != BT_CLASS && f->sym->attr.pointer))\n \t      && !gfc_check_vardef_context (a->expr, true, false, false, context))\n-\t    return 0;\n+\t    return false;\n \t  if (!gfc_check_vardef_context (a->expr, false, false, false, context))\n-\t    return 0;\n+\t    return false;\n \t}\n \n       if ((f->sym->attr.intent == INTENT_OUT\n@@ -3177,7 +3174,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t\t       \"INTENT(INOUT), VOLATILE or ASYNCHRONOUS attribute \"\n \t\t       \"of the dummy argument %qs\",\n \t\t       &a->expr->where, f->sym->name);\n-\t  return 0;\n+\t  return false;\n \t}\n \n       /* C1232 (R1221) For an actual argument which is an array section or\n@@ -3195,7 +3192,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t\t       \"incompatible with the non-assumed-shape \"\n \t\t       \"dummy argument %qs due to VOLATILE attribute\",\n \t\t       &a->expr->where,f->sym->name);\n-\t  return 0;\n+\t  return false;\n \t}\n \n       /* Find the last array_ref.  */\n@@ -3212,7 +3209,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t\t       \"incompatible with the non-assumed-shape \"\n \t\t       \"dummy argument %qs due to VOLATILE attribute\",\n \t\t       &a->expr->where, f->sym->name);\n-\t  return 0;\n+\t  return false;\n \t}\n \n       /* C1233 (R1221) For an actual argument which is a pointer array, the\n@@ -3232,7 +3229,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t\t       \"an assumed-shape or pointer-array dummy \"\n \t\t       \"argument %qs due to VOLATILE attribute\",\n \t\t       &a->expr->where,f->sym->name);\n-\t  return 0;\n+\t  return false;\n \t}\n \n     match:\n@@ -3253,14 +3250,14 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t  if (where)\n \t    gfc_error (\"Missing alternate return spec in subroutine call \"\n \t\t       \"at %L\", where);\n-\t  return 0;\n+\t  return false;\n \t}\n       if (!f->sym->attr.optional)\n \t{\n \t  if (where)\n \t    gfc_error (\"Missing actual argument for argument %qs at %L\",\n \t\t       f->sym->name, where);\n-\t  return 0;\n+\t  return false;\n \t}\n     }\n \n@@ -3290,7 +3287,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n     if (a->expr == NULL && a->label == NULL)\n       a->missing_arg_type = f->sym->ts.type;\n \n-  return 1;\n+  return true;\n }\n \n "}]}