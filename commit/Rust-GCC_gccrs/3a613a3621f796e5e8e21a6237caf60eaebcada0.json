{"sha": "3a613a3621f796e5e8e21a6237caf60eaebcada0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E2MTNhMzYyMWY3OTZlNWU4ZTIxYTYyMzdjYWY2MGVhZWJjYWRhMA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-29T14:07:24Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-29T14:07:24Z"}, "message": "[multiple changes]\n\n2011-08-29  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch5.adb (Expand_Iterator_Loop): Handle properly a loop over a\n\tcontainer of a derived type.\n\n2011-08-29  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* impunit.adb, s-stposu.adb, s-stposu.ads, exp_ch4.adb, s-finmas.adb,\n\ts-finmas.ads: Revert previous change.\n\n2011-08-29  Ed Schonberg  <schonberg@adacore.com>\n\n\t* a-cidlli.adb, a-cidlli.ads, a-cihama.adb, a-cihama.ads,\n\ta-ciorse.adb, a-ciorse.ads: Add iterator machinery to containers.\n\nFrom-SVN: r178237", "tree": {"sha": "ad2c626c4e1e4b8d2efe3dd7f4aedb0ad37a2408", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad2c626c4e1e4b8d2efe3dd7f4aedb0ad37a2408"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a613a3621f796e5e8e21a6237caf60eaebcada0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a613a3621f796e5e8e21a6237caf60eaebcada0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a613a3621f796e5e8e21a6237caf60eaebcada0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a613a3621f796e5e8e21a6237caf60eaebcada0/comments", "author": null, "committer": null, "parents": [{"sha": "14848f57e0e43eab05b198f1406f4515816096bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14848f57e0e43eab05b198f1406f4515816096bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14848f57e0e43eab05b198f1406f4515816096bb"}], "stats": {"total": 1022, "additions": 636, "deletions": 386}, "files": [{"sha": "1c72508894a440db7518cf6edecc5b1e27fcedef", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a613a3621f796e5e8e21a6237caf60eaebcada0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a613a3621f796e5e8e21a6237caf60eaebcada0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3a613a3621f796e5e8e21a6237caf60eaebcada0", "patch": "@@ -1,3 +1,18 @@\n+2011-08-29  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch5.adb (Expand_Iterator_Loop): Handle properly a loop over a\n+\tcontainer of a derived type.\n+\n+2011-08-29  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* impunit.adb, s-stposu.adb, s-stposu.ads, exp_ch4.adb, s-finmas.adb,\n+\ts-finmas.ads: Revert previous change.\n+\n+2011-08-29  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* a-cidlli.adb, a-cidlli.ads, a-cihama.adb, a-cihama.ads,\n+\ta-ciorse.adb, a-ciorse.ads: Add iterator machinery to containers.\n+\n 2011-08-29  Pascal Obry  <obry@adacore.com>\n \n \t* exp_disp.adb: Minor comment fix."}, {"sha": "780efad4f41f3ea0434ba3dc9c73f3b60cf12657", "filename": "gcc/ada/a-cidlli.adb", "status": "modified", "additions": 124, "deletions": 1, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a613a3621f796e5e8e21a6237caf60eaebcada0/gcc%2Fada%2Fa-cidlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a613a3621f796e5e8e21a6237caf60eaebcada0/gcc%2Fada%2Fa-cidlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cidlli.adb?ref=3a613a3621f796e5e8e21a6237caf60eaebcada0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,6 +35,19 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    procedure Free is\n      new Ada.Unchecked_Deallocation (Element_Type, Element_Access);\n \n+   type Iterator is new\n+     List_Iterator_Interfaces.Reversible_Iterator with record\n+        Container : List_Access;\n+        Node      : Node_Access;\n+   end record;\n+\n+   overriding function First    (Object : Iterator) return Cursor;\n+   overriding function Last     (Object : Iterator) return Cursor;\n+   overriding function Next     (Object : Iterator; Position : Cursor)\n+     return Cursor;\n+   overriding function Previous (Object : Iterator; Position : Cursor)\n+     return Cursor;\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -431,6 +444,11 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       return Cursor'(Container'Unchecked_Access, Container.First);\n    end First;\n \n+   function First (Object : Iterator) return Cursor is\n+   begin\n+      return Cursor'(Object.Container, Object.Container.First);\n+   end First;\n+\n    -------------------\n    -- First_Element --\n    -------------------\n@@ -820,6 +838,22 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       B := B - 1;\n    end Iterate;\n \n+   function Iterate (Container : List)\n+     return List_Iterator_Interfaces.Reversible_Iterator'class\n+   is\n+      It : constant Iterator := (Container'Unchecked_Access, Container.First);\n+   begin\n+      return It;\n+   end Iterate;\n+\n+   function Iterate (Container : List; Start : Cursor)\n+     return List_Iterator_Interfaces.Reversible_Iterator'class\n+   is\n+      It : constant Iterator := (Container'Unchecked_Access, Start.Node);\n+   begin\n+      return It;\n+   end Iterate;\n+\n    ----------\n    -- Last --\n    ----------\n@@ -833,6 +867,15 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       return Cursor'(Container'Unchecked_Access, Container.Last);\n    end Last;\n \n+   function Last (Object : Iterator) return Cursor is\n+   begin\n+      if Object.Container.Last = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Object.Container, Object.Container.Last);\n+   end Last;\n+\n    ------------------\n    -- Last_Element --\n    ------------------\n@@ -910,6 +953,16 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       end;\n    end Next;\n \n+   function Next (Object : Iterator; Position : Cursor) return Cursor is\n+   begin\n+      if Position.Node = Object.Container.Last then\n+         return No_Element;\n+\n+      else\n+         return (Object.Container, Position.Node.Next);\n+      end if;\n+   end Next;\n+\n    -------------\n    -- Prepend --\n    -------------\n@@ -951,6 +1004,16 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       end;\n    end Previous;\n \n+   function Previous (Object : Iterator; Position : Cursor) return Cursor is\n+   begin\n+      if Position.Node = Position.Container.First then\n+         return No_Element;\n+\n+      else\n+         return (Object.Container, Position.Node.Prev);\n+      end if;\n+   end Previous;\n+\n    -------------------\n    -- Query_Element --\n    -------------------\n@@ -1056,6 +1119,50 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       raise Program_Error with \"attempt to stream list cursor\";\n    end Read;\n \n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Reference_Type)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream reference\";\n+   end Read;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Constant_Reference_Type)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream reference\";\n+   end Read;\n+\n+   ---------------\n+   -- Reference --\n+   ---------------\n+\n+   function Constant_Reference (Container : List; Position : Cursor)\n+   return Constant_Reference_Type is\n+   begin\n+      pragma Unreferenced (Container);\n+\n+      if Position.Container = null then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      return (Element => Position.Node.Element.all'Access);\n+   end Constant_Reference;\n+\n+   function Reference (Container : List; Position : Cursor)\n+   return Reference_Type is\n+   begin\n+      pragma Unreferenced (Container);\n+\n+      if Position.Container = null then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      return (Element => Position.Node.Element.all'Access);\n+   end Reference;\n+\n    ---------------------\n    -- Replace_Element --\n    ---------------------\n@@ -1907,4 +2014,20 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       raise Program_Error with \"attempt to stream list cursor\";\n    end Write;\n \n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Reference_Type)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream reference\";\n+   end Write;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Constant_Reference_Type)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream reference\";\n+   end Write;\n+\n end Ada.Containers.Indefinite_Doubly_Linked_Lists;"}, {"sha": "a6fd7106321c0a4bd73f02ef84c6822791391040", "filename": "gcc/ada/a-cidlli.ads", "status": "modified", "additions": 68, "deletions": 7, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a613a3621f796e5e8e21a6237caf60eaebcada0/gcc%2Fada%2Fa-cidlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a613a3621f796e5e8e21a6237caf60eaebcada0/gcc%2Fada%2Fa-cidlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cidlli.ads?ref=3a613a3621f796e5e8e21a6237caf60eaebcada0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -31,8 +31,9 @@\n -- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n+with Ada.Iterator_Interfaces;\n+with Ada.Streams; use Ada.Streams;\n private with Ada.Finalization;\n-private with Ada.Streams;\n \n generic\n    type Element_Type (<>) is private;\n@@ -44,7 +45,13 @@ package Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    pragma Preelaborate;\n    pragma Remote_Types;\n \n-   type List is tagged private;\n+   type List is tagged private\n+   with\n+      Constant_Indexing => Constant_Reference,\n+      Variable_Indexing => Reference,\n+      Default_Iterator  => Iterate,\n+      Iterator_Element  => Element_Type;\n+\n    pragma Preelaborable_Initialization (List);\n \n    type Cursor is private;\n@@ -53,6 +60,10 @@ package Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    Empty_List : constant List;\n \n    No_Element : constant Cursor;\n+   function Has_Element (Position : Cursor) return Boolean;\n+\n+   package List_Iterator_Interfaces is new\n+     Ada.Iterator_Interfaces (Cursor, Has_Element);\n \n    function \"=\" (Left, Right : List) return Boolean;\n \n@@ -170,8 +181,6 @@ package Ada.Containers.Indefinite_Doubly_Linked_Lists is\n      (Container : List;\n       Item      : Element_Type) return Boolean;\n \n-   function Has_Element (Position : Cursor) return Boolean;\n-\n    procedure Iterate\n      (Container : List;\n       Process   : not null access procedure (Position : Cursor));\n@@ -180,6 +189,54 @@ package Ada.Containers.Indefinite_Doubly_Linked_Lists is\n      (Container : List;\n       Process   : not null access procedure (Position : Cursor));\n \n+   function Iterate (Container : List)\n+      return List_Iterator_Interfaces.Reversible_Iterator'class;\n+\n+   function Iterate (Container : List; Start : Cursor)\n+      return List_Iterator_Interfaces.Reversible_Iterator'class;\n+\n+   type Constant_Reference_Type\n+      (Element : not null access constant Element_Type) is private\n+   with\n+      Implicit_Dereference => Element;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Write use Write;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Read use Read;\n+\n+   type Reference_Type (Element : not null access Element_Type) is\n+   private\n+   with\n+      Implicit_Dereference => Element;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Reference_Type);\n+\n+   for Reference_Type'Write use Write;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Reference_Type);\n+\n+   for Reference_Type'Read use Read;\n+\n+   function Constant_Reference\n+     (Container : List; Position : Cursor)    --  SHOULD BE ALIASED\n+   return Constant_Reference_Type;\n+\n+   function Reference\n+     (Container : List; Position : Cursor)    --  SHOULD BE ALIASED\n+   return Reference_Type;\n+\n    generic\n       with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n    package Generic_Sorting is\n@@ -220,12 +277,16 @@ private\n         Lock   : Natural := 0;\n      end record;\n \n+   type Constant_Reference_Type\n+      (Element : not null access constant Element_Type) is null record;\n+\n+   type Reference_Type\n+      (Element : not null access Element_Type) is null record;\n+\n    overriding procedure Adjust (Container : in out List);\n \n    overriding procedure Finalize (Container : in out List) renames Clear;\n \n-   use Ada.Streams;\n-\n    procedure Read\n      (Stream : not null access Root_Stream_Type'Class;\n       Item   : out List);"}, {"sha": "783fdf421b13e6ad5bce2842a689cce749c9dad0", "filename": "gcc/ada/a-cihama.adb", "status": "modified", "additions": 91, "deletions": 1, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a613a3621f796e5e8e21a6237caf60eaebcada0/gcc%2Fada%2Fa-cihama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a613a3621f796e5e8e21a6237caf60eaebcada0/gcc%2Fada%2Fa-cihama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihama.adb?ref=3a613a3621f796e5e8e21a6237caf60eaebcada0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -43,6 +43,16 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n    procedure Free_Element is\n       new Ada.Unchecked_Deallocation (Element_Type, Element_Access);\n \n+   type Iterator is new\n+     Map_Iterator_Interfaces.Forward_Iterator with record\n+      Container : Map_Access;\n+      Node      : Node_Access;\n+   end record;\n+\n+   overriding function First (Object : Iterator) return Cursor;\n+   overriding function Next  (Object : Iterator; Position : Cursor)\n+     return Cursor;\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -398,6 +408,17 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       return Cursor'(Container'Unchecked_Access, Node);\n    end First;\n \n+   function First (Object : Iterator) return Cursor is\n+      M : constant Map_Access  := Object.Container;\n+      N : constant Node_Access := HT_Ops.First (M.HT);\n+   begin\n+      if N = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(Object.Container.all'Unchecked_Access, N);\n+   end First;\n+\n    ----------\n    -- Free --\n    ----------\n@@ -626,6 +647,15 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       B := B - 1;\n    end Iterate;\n \n+   function Iterate (Container : Map)\n+      return Map_Iterator_Interfaces.Forward_Iterator'class\n+   is\n+      Node : constant Node_Access := HT_Ops.First (Container.HT);\n+      It   : constant Iterator := (Container'Unrestricted_Access, Node);\n+   begin\n+      return It;\n+   end Iterate;\n+\n    ---------\n    -- Key --\n    ---------\n@@ -709,6 +739,16 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       end;\n    end Next;\n \n+   function Next (Object : Iterator; Position : Cursor) return Cursor is\n+   begin\n+      if Position.Node = null then\n+         return No_Element;\n+\n+      else\n+         return (Object.Container, Next (Position).Node);\n+      end if;\n+   end Next;\n+\n    -------------------\n    -- Query_Element --\n    -------------------\n@@ -784,6 +824,22 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       raise Program_Error with \"attempt to stream map cursor\";\n    end Read;\n \n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Reference_Type)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream reference\";\n+   end Read;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Constant_Reference_Type)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream reference\";\n+   end Read;\n+\n    ---------------\n    -- Read_Node --\n    ---------------\n@@ -814,6 +870,24 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       return Node;\n    end Read_Node;\n \n+   ---------------\n+   -- Reference --\n+   ---------------\n+\n+   function Constant_Reference (Container : Map; Key : Key_Type)\n+   return Constant_Reference_Type is\n+   begin\n+      return (Element =>\n+        Container.Find (Key).Node.Element.all'Unrestricted_Access);\n+   end Constant_Reference;\n+\n+   function Reference (Container : Map; Key : Key_Type)\n+   return Reference_Type is\n+   begin\n+      return (Element =>\n+         Container.Find (Key).Node.Element.all'Unrestricted_Access);\n+   end Reference;\n+\n    -------------\n    -- Replace --\n    -------------\n@@ -1064,6 +1138,22 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n       raise Program_Error with \"attempt to stream map cursor\";\n    end Write;\n \n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Reference_Type)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream reference\";\n+   end Write;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Constant_Reference_Type)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream reference\";\n+   end Write;\n+\n    ----------------\n    -- Write_Node --\n    ----------------"}, {"sha": "2e08967711273e4f2f9b83cb74ebb7e19bd2d147", "filename": "gcc/ada/a-cihama.ads", "status": "modified", "additions": 65, "deletions": 7, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a613a3621f796e5e8e21a6237caf60eaebcada0/gcc%2Fada%2Fa-cihama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a613a3621f796e5e8e21a6237caf60eaebcada0/gcc%2Fada%2Fa-cihama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihama.ads?ref=3a613a3621f796e5e8e21a6237caf60eaebcada0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -32,8 +32,9 @@\n ------------------------------------------------------------------------------\n \n private with Ada.Containers.Hash_Tables;\n-private with Ada.Streams;\n private with Ada.Finalization;\n+with Ada.Streams; use Ada.Streams;\n+with Ada.Iterator_Interfaces;\n \n generic\n    type Key_Type (<>) is private;\n@@ -47,7 +48,13 @@ package Ada.Containers.Indefinite_Hashed_Maps is\n    pragma Preelaborate;\n    pragma Remote_Types;\n \n-   type Map is tagged private;\n+   type Map is tagged private\n+   with\n+      Constant_Indexing => Constant_Reference,\n+      Variable_Indexing => Reference,\n+      Default_Iterator  => Iterate,\n+      Iterator_Element  => Element_Type;\n+\n    pragma Preelaborable_Initialization (Map);\n \n    type Cursor is private;\n@@ -61,6 +68,12 @@ package Ada.Containers.Indefinite_Hashed_Maps is\n    --  Cursor objects declared without an initialization expression are\n    --  initialized to the value No_Element.\n \n+   function Has_Element (Position : Cursor) return Boolean;\n+   --  Equivalent to Position /= No_Element\n+\n+   package Map_Iterator_Interfaces is new\n+     Ada.Iterator_Interfaces (Cursor, Has_Element);\n+\n    overriding function \"=\" (Left, Right : Map) return Boolean;\n    --  For each key/element pair in Left, equality attempts to find the key in\n    --  Right; if a search fails the equality returns False. The search works by\n@@ -227,9 +240,6 @@ package Ada.Containers.Indefinite_Hashed_Maps is\n    function Element (Container : Map; Key : Key_Type) return Element_Type;\n    --  Equivalent to Element (Find (Container, Key))\n \n-   function Has_Element (Position : Cursor) return Boolean;\n-   --  Equivalent to Position /= No_Element\n-\n    function Equivalent_Keys (Left, Right : Cursor) return Boolean;\n    --  Returns the result of calling Equivalent_Keys with the keys of the nodes\n    --  designated by cursors Left and Right.\n@@ -242,11 +252,54 @@ package Ada.Containers.Indefinite_Hashed_Maps is\n    --  Returns the result of calling Equivalent_Keys with key Left and the node\n    --  designated by Right.\n \n+   type Constant_Reference_Type\n+      (Element : not null access constant Element_Type) is private\n+   with\n+      Implicit_Dereference => Element;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Write use Write;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Read use Read;\n+\n+   type Reference_Type (Element : not null access Element_Type) is private\n+   with\n+      Implicit_Dereference => Element;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Reference_Type);\n+\n+   for Reference_Type'Write use Write;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Reference_Type);\n+\n+   for Reference_Type'Read use Read;\n+\n+   function Constant_Reference\n+     (Container : Map; Key : Key_Type)    --  SHOULD BE ALIASED\n+   return Constant_Reference_Type;\n+\n+   function Reference (Container : Map; Key : Key_Type)\n+   return Reference_Type;\n+\n    procedure Iterate\n      (Container : Map;\n       Process   : not null access procedure (Position : Cursor));\n    --  Calls Process for each node in the map\n \n+   function Iterate (Container : Map)\n+      return Map_Iterator_Interfaces.Forward_Iterator'class;\n+\n private\n    pragma Inline (\"=\");\n    pragma Inline (Length);\n@@ -283,7 +336,6 @@ private\n \n    use HT_Types;\n    use Ada.Finalization;\n-   use Ada.Streams;\n \n    overriding procedure Adjust (Container : in out Map);\n \n@@ -303,6 +355,12 @@ private\n \n    for Cursor'Write use Write;\n \n+   type Constant_Reference_Type\n+      (Element : not null access constant Element_Type) is null record;\n+\n+   type Reference_Type\n+      (Element : not null access Element_Type) is null record;\n+\n    procedure Read\n      (Stream : not null access Root_Stream_Type'Class;\n       Item   : out Cursor);"}, {"sha": "7a782189708fa08f21e16e228679f58fe29862a3", "filename": "gcc/ada/a-ciorse.adb", "status": "modified", "additions": 123, "deletions": 1, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a613a3621f796e5e8e21a6237caf60eaebcada0/gcc%2Fada%2Fa-ciorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a613a3621f796e5e8e21a6237caf60eaebcada0/gcc%2Fada%2Fa-ciorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorse.adb?ref=3a613a3621f796e5e8e21a6237caf60eaebcada0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -40,6 +40,19 @@ with Ada.Unchecked_Deallocation;\n \n package body Ada.Containers.Indefinite_Ordered_Sets is\n \n+   type Iterator is new\n+     Ordered_Set_Iterator_Interfaces.Reversible_Iterator with record\n+      Container : access constant Set;\n+      Node      : Node_Access;\n+   end record;\n+\n+   overriding function First (Object : Iterator) return Cursor;\n+   overriding function Last  (Object : Iterator) return Cursor;\n+   overriding function Next  (Object : Iterator; Position : Cursor)\n+     return Cursor;\n+   overriding function Previous (Object : Iterator; Position : Cursor)\n+     return Cursor;\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -566,6 +579,12 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       return Cursor'(Container'Unrestricted_Access, Container.Tree.First);\n    end First;\n \n+   function First (Object : Iterator) return Cursor is\n+   begin\n+      return Cursor'(\n+       Object.Container.all'Unrestricted_Access, Object.Container.Tree.First);\n+   end First;\n+\n    -------------------\n    -- First_Element --\n    -------------------\n@@ -1190,6 +1209,23 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       B := B - 1;\n    end Iterate;\n \n+   function Iterate (Container : Set)\n+     return Ordered_Set_Iterator_Interfaces.Reversible_Iterator'class\n+   is\n+      It : constant Iterator :=\n+             (Container'Unchecked_Access, Container.Tree.First);\n+   begin\n+      return It;\n+   end Iterate;\n+\n+   function Iterate (Container : Set; Start : Cursor)\n+     return Ordered_Set_Iterator_Interfaces.Reversible_Iterator'class\n+   is\n+      It : constant Iterator := (Container'Unchecked_Access, Start.Node);\n+   begin\n+      return It;\n+   end Iterate;\n+\n    ----------\n    -- Last --\n    ----------\n@@ -1203,6 +1239,16 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       return Cursor'(Container'Unrestricted_Access, Container.Tree.Last);\n    end Last;\n \n+   function Last (Object : Iterator) return Cursor is\n+   begin\n+      if Object.Container.Tree.Last = null then\n+         return No_Element;\n+      end if;\n+\n+      return Cursor'(\n+        Object.Container.all'Unrestricted_Access, Object.Container.Tree.Last);\n+   end Last;\n+\n    ------------------\n    -- Last_Element --\n    ------------------\n@@ -1281,6 +1327,14 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       end;\n    end Next;\n \n+   function Next  (Object : Iterator; Position : Cursor)\n+   return Cursor\n+   is\n+      pragma Unreferenced (Object);\n+   begin\n+      return Next (Position);\n+   end Next;\n+\n    -------------\n    -- Overlap --\n    -------------\n@@ -1334,6 +1388,14 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       end;\n    end Previous;\n \n+   function Previous (Object : Iterator; Position : Cursor)\n+   return Cursor\n+   is\n+      pragma Unreferenced (Object);\n+   begin\n+      return Previous (Position);\n+   end Previous;\n+\n    -------------------\n    -- Query_Element --\n    -------------------\n@@ -1426,6 +1488,50 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       raise Program_Error with \"attempt to stream set cursor\";\n    end Read;\n \n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Reference_Type)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream reference\";\n+   end Read;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Constant_Reference_Type)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream reference\";\n+   end Read;\n+\n+   ---------------\n+   -- Reference --\n+   ---------------\n+\n+   function Constant_Reference (Container : Set; Position : Cursor)\n+   return Constant_Reference_Type\n+   is\n+      pragma Unreferenced (Container);\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      return (Element => Position.Node.Element.all'Access);\n+   end Constant_Reference;\n+\n+   function Reference (Container : Set; Position : Cursor)\n+   return Reference_Type\n+   is\n+      pragma Unreferenced (Container);\n+   begin\n+      if Position.Container = null then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      return (Element => Position.Node.Element.all'Access);\n+   end Reference;\n+\n    -------------\n    -- Replace --\n    -------------\n@@ -1758,4 +1864,20 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       raise Program_Error with \"attempt to stream set cursor\";\n    end Write;\n \n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Reference_Type)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream reference\";\n+   end Write;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Constant_Reference_Type)\n+   is\n+   begin\n+      raise Program_Error with \"attempt to stream reference\";\n+   end Write;\n+\n end Ada.Containers.Indefinite_Ordered_Sets;"}, {"sha": "3700c15e6b398ef5005441762d9ae20b0df9d3c3", "filename": "gcc/ada/a-ciorse.ads", "status": "modified", "additions": 68, "deletions": 6, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a613a3621f796e5e8e21a6237caf60eaebcada0/gcc%2Fada%2Fa-ciorse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a613a3621f796e5e8e21a6237caf60eaebcada0/gcc%2Fada%2Fa-ciorse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorse.ads?ref=3a613a3621f796e5e8e21a6237caf60eaebcada0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -33,7 +33,8 @@\n \n private with Ada.Containers.Red_Black_Trees;\n private with Ada.Finalization;\n-private with Ada.Streams;\n+with Ada.Streams; use Ada.Streams;\n+with Ada.Iterator_Interfaces;\n \n generic\n    type Element_Type (<>) is private;\n@@ -47,7 +48,13 @@ package Ada.Containers.Indefinite_Ordered_Sets is\n \n    function Equivalent_Elements (Left, Right : Element_Type) return Boolean;\n \n-   type Set is tagged private;\n+   type Set is tagged private\n+   with\n+     Constant_Indexing => Constant_Reference,\n+     Variable_Indexing => Reference,\n+     Default_Iterator  => Iterate,\n+     Iterator_Element  => Element_Type;\n+\n    pragma Preelaborable_Initialization (Set);\n \n    type Cursor is private;\n@@ -56,6 +63,52 @@ package Ada.Containers.Indefinite_Ordered_Sets is\n    Empty_Set : constant Set;\n \n    No_Element : constant Cursor;\n+   function Has_Element (Position : Cursor) return Boolean;\n+\n+   package Ordered_Set_Iterator_Interfaces is new\n+     Ada.Iterator_Interfaces (Cursor, Has_Element);\n+\n+   type Constant_Reference_Type\n+      (Element : not null access constant Element_Type) is\n+   private\n+   with\n+      Implicit_Dereference => Element;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Read use Read;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Constant_Reference_Type);\n+\n+   for Constant_Reference_Type'Write use Write;\n+\n+   function Constant_Reference\n+     (Container : Set; Position : Cursor)\n+   return Constant_Reference_Type;\n+\n+   type Reference_Type (Element : not null access Element_Type) is private\n+   with\n+      Implicit_Dereference => Element;\n+\n+   procedure Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : Reference_Type);\n+\n+   for Reference_Type'Write use Write;\n+\n+   procedure Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      Item   : out Reference_Type);\n+\n+   for Reference_Type'Read use Read;\n+\n+   function Reference\n+     (Container : Set; Position : Cursor)\n+   return Reference_Type;\n \n    function \"=\" (Left, Right : Set) return Boolean;\n \n@@ -168,8 +221,6 @@ package Ada.Containers.Indefinite_Ordered_Sets is\n \n    function Contains (Container : Set; Item : Element_Type) return Boolean;\n \n-   function Has_Element (Position : Cursor) return Boolean;\n-\n    function \"<\" (Left, Right : Cursor) return Boolean;\n \n    function \">\" (Left, Right : Cursor) return Boolean;\n@@ -190,6 +241,12 @@ package Ada.Containers.Indefinite_Ordered_Sets is\n      (Container : Set;\n       Process   : not null access procedure (Position : Cursor));\n \n+   function Iterate (Container : Set)\n+      return Ordered_Set_Iterator_Interfaces.Reversible_Iterator'class;\n+\n+   function Iterate (Container : Set; Start : Cursor)\n+      return Ordered_Set_Iterator_Interfaces.Reversible_Iterator'class;\n+\n    generic\n       type Key_Type (<>) is private;\n \n@@ -271,7 +328,6 @@ private\n    use Red_Black_Trees;\n    use Tree_Types;\n    use Ada.Finalization;\n-   use Ada.Streams;\n \n    type Set_Access is access all Set;\n    for Set_Access'Storage_Size use 0;\n@@ -307,6 +363,12 @@ private\n \n    for Set'Read use Read;\n \n+   type Constant_Reference_Type\n+      (Element : not null access constant Element_Type) is null record;\n+\n+   type Reference_Type\n+      (Element : not null access Element_Type) is null record;\n+\n    Empty_Set : constant Set :=\n                  (Controlled with Tree => (First  => null,\n                                            Last   => null,"}, {"sha": "8ac78ac1f5e0da031ee858ee6460313fa9d74f53", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a613a3621f796e5e8e21a6237caf60eaebcada0/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a613a3621f796e5e8e21a6237caf60eaebcada0/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=3a613a3621f796e5e8e21a6237caf60eaebcada0", "patch": "@@ -1137,8 +1137,6 @@ package body Exp_Ch4 is\n             Rewrite (Exp, New_Copy (Expression (Exp)));\n          end if;\n       else\n-         Build_Allocate_Deallocate_Proc (N, True);\n-\n          --  If we have:\n          --    type A is access T1;\n          --    X : A := new T2'(...);"}, {"sha": "4da232e5f9d24085a5bad159e5710192941e156e", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a613a3621f796e5e8e21a6237caf60eaebcada0/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a613a3621f796e5e8e21a6237caf60eaebcada0/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=3a613a3621f796e5e8e21a6237caf60eaebcada0", "patch": "@@ -2952,9 +2952,12 @@ package body Exp_Ch5 is\n \n             if Of_Present (I_Spec) then\n                declare\n-                  Default_Iter : constant Entity_Id :=\n-                    Find_Aspect (Etype (Container), Aspect_Default_Iterator);\n-                  Ent : Entity_Id;\n+                  Default_Iter  : constant Entity_Id :=\n+                    Entity (\n+                      Find_Aspect\n+                         (Etype (Container), Aspect_Default_Iterator));\n+                  Container_Arg : Node_Id;\n+                  Ent           : Entity_Id;\n \n                begin\n                   Cursor := Make_Temporary (Loc, 'I');\n@@ -2963,23 +2966,39 @@ package body Exp_Ch5 is\n                      null;\n \n                   else\n-                     Iter_Type :=\n-                        Etype\n-                         (Find_Aspect\n-                              (Etype (Container), Aspect_Default_Iterator));\n+                     Iter_Type := Etype (Default_Iter);\n \n                      --  Rewrite domain of iteration as a call to the default\n-                     --  iterator for the container type.\n+                     --  iterator for the container type. If the container is\n+                     --  a derived type and the aspect is inherited, convert\n+                     --  container to parent type. The Cursor type is also\n+                     --  inherited from the scope of the parent.\n+\n+                     if Base_Type (Etype (Container)) =\n+                       Base_Type (Etype (First_Formal (Default_Iter)))\n+                     then\n+                        Container_Arg := New_Copy_Tree (Container);\n+\n+                     else\n+                        Pack := Scope (Default_Iter);\n+\n+                        Container_Arg :=\n+                          Make_Type_Conversion (Loc,\n+                            Subtype_Mark =>\n+                              New_Occurrence_Of (\n+                                Etype (First_Formal (Default_Iter)), Loc),\n+                            Expression => New_Copy_Tree (Container));\n+                     end if;\n \n                      Rewrite (Name (I_Spec),\n                        Make_Function_Call (Loc,\n-                         Name => Default_Iter,\n+                         Name => New_Occurrence_Of (Default_Iter, Loc),\n                          Parameter_Associations =>\n-                           New_List (Relocate_Node (Name (I_Spec)))));\n+                           New_List (Container_Arg)));\n                      Analyze_And_Resolve (Name (I_Spec));\n                   end if;\n \n-                  --  Find cursor type in container package.\n+                  --  Find cursor type in proper container package.\n \n                   Ent := First_Entity (Pack);\n                   while Present (Ent) loop"}, {"sha": "ea636fe8b0ad9088140ac353efc78a112e1689d5", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a613a3621f796e5e8e21a6237caf60eaebcada0/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a613a3621f796e5e8e21a6237caf60eaebcada0/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=3a613a3621f796e5e8e21a6237caf60eaebcada0", "patch": "@@ -346,6 +346,7 @@ package body Impunit is\n \n      \"s-addima\",    -- System.Address_Image\n      \"s-assert\",    -- System.Assertions\n+     \"s-finmas\",    -- System.Finalization_Masters\n      \"s-memory\",    -- System.Memory\n      \"s-parint\",    -- System.Partition_Interface\n      \"s-pooglo\",    -- System.Pool_Global\n@@ -528,6 +529,7 @@ package body Impunit is\n    -- GNAT Defined Additions to Ada 20012 --\n    -----------------------------------------\n \n+     \"s-spsufi\",    -- System.Storage_Pools.Subpools.Finalization\n      \"a-cofove\",    -- Ada.Containers.Formal_Vectors\n      \"a-cfdlli\",    -- Ada.Containers.Formal_Doubly_Linked_Lists\n      \"a-cforse\",    -- Ada.Containers.Formal_Ordered_Sets"}, {"sha": "857db696b009bff1ec18ae80484688b8855ac361", "filename": "gcc/ada/s-finmas.adb", "status": "modified", "additions": 28, "deletions": 122, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a613a3621f796e5e8e21a6237caf60eaebcada0/gcc%2Fada%2Fs-finmas.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a613a3621f796e5e8e21a6237caf60eaebcada0/gcc%2Fada%2Fs-finmas.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-finmas.adb?ref=3a613a3621f796e5e8e21a6237caf60eaebcada0", "patch": "@@ -31,32 +31,12 @@\n \n with Ada.Exceptions;          use Ada.Exceptions;\n with System.Address_Image;\n-with System.HTable;           use System.HTable;\n with System.IO;               use System.IO;\n with System.Soft_Links;       use System.Soft_Links;\n with System.Storage_Elements; use System.Storage_Elements;\n \n package body System.Finalization_Masters is\n \n-   --  Finalize_Address hash table types. In general, masters are homogeneous\n-   --  collections of controlled objects. Rare cases such as allocations on a\n-   --  subpool require heterogeneous masters. The following table provides a\n-   --  relation between object address and its Finalize_Address routine.\n-\n-   type Header_Num is range 0 .. 127;\n-\n-   function Hash (Key : System.Address) return Header_Num;\n-\n-   --  Address --> Finalize_Address_Ptr\n-\n-   package Finalize_Address_Table is new Simple_HTable\n-     (Header_Num => Header_Num,\n-      Element    => Finalize_Address_Ptr,\n-      No_Element => null,\n-      Key        => System.Address,\n-      Hash       => Hash,\n-      Equal      => \"=\");\n-\n    ---------------------------\n    -- Add_Offset_To_Address --\n    ---------------------------\n@@ -99,17 +79,6 @@ package body System.Finalization_Masters is\n       return Master.Base_Pool;\n    end Base_Pool;\n \n-   -----------------------------\n-   -- Delete_Finalize_Address --\n-   -----------------------------\n-\n-   procedure Delete_Finalize_Address (Obj : System.Address) is\n-   begin\n-      Lock_Task.all;\n-      Finalize_Address_Table.Remove (Obj);\n-      Unlock_Task.all;\n-   end Delete_Finalize_Address;\n-\n    ------------\n    -- Detach --\n    ------------\n@@ -125,18 +94,17 @@ package body System.Finalization_Masters is\n          N.Next := null;\n \n          Unlock_Task.all;\n-\n-         --  Note: No need to unlock in case of an exception because the above\n-         --  code can never raise one.\n       end if;\n+\n+      --  Note: No need to unlock in case of an exception because the above\n+      --  code can never raise one.\n    end Detach;\n \n    --------------\n    -- Finalize --\n    --------------\n \n    overriding procedure Finalize (Master : in out Finalization_Master) is\n-      Cleanup  : Finalize_Address_Ptr;\n       Curr_Ptr : FM_Node_Ptr;\n       Ex_Occur : Exception_Occurrence;\n       Obj_Addr : Address;\n@@ -176,41 +144,23 @@ package body System.Finalization_Masters is\n \n          Detach (Curr_Ptr);\n \n-         --  Skip the list header in order to offer proper object layout for\n-         --  finalization.\n-\n-         Obj_Addr := Curr_Ptr.all'Address + Header_Offset;\n-\n-         --  Retrieve TSS primitive Finalize_Address depending on the master's\n-         --  mode of operation.\n-\n-         if Master.Is_Homogeneous then\n-            Cleanup := Master.Finalize_Address;\n-         else\n-            Cleanup := Get_Finalize_Address (Obj_Addr);\n-         end if;\n-\n-         --  If Finalize_Address is not available, then this is most likely an\n-         --  error in the expansion of the designated type or the allocator.\n-\n-         pragma Assert (Cleanup /= null);\n+         if Master.Finalize_Address /= null then\n \n-         begin\n-            Cleanup (Obj_Addr);\n+            --  Skip the list header in order to offer proper object layout for\n+            --  finalization and call Finalize_Address.\n \n-         exception\n-            when Fin_Occur : others =>\n-               if not Raised then\n-                  Raised := True;\n-                  Save_Occurrence (Ex_Occur, Fin_Occur);\n-               end if;\n-         end;\n+            Obj_Addr := Curr_Ptr.all'Address + Header_Offset;\n \n-         --  When the master is a heterogeneous collection, destroy the object\n-         --  - Finalize_Address pair since it is no longer needed.\n+            begin\n+               Master.Finalize_Address (Obj_Addr);\n \n-         if not Master.Is_Homogeneous then\n-            Delete_Finalize_Address (Obj_Addr);\n+            exception\n+               when Fin_Occur : others =>\n+                  if not Raised then\n+                     Raised := True;\n+                     Save_Occurrence (Ex_Occur, Fin_Occur);\n+                  end if;\n+            end;\n          end if;\n       end loop;\n \n@@ -222,23 +172,6 @@ package body System.Finalization_Masters is\n       end if;\n    end Finalize;\n \n-   --------------------------\n-   -- Get_Finalize_Address --\n-   --------------------------\n-\n-   function Get_Finalize_Address\n-     (Obj : System.Address) return Finalize_Address_Ptr\n-   is\n-      Result : Finalize_Address_Ptr;\n-\n-   begin\n-      Lock_Task.all;\n-      Result := Finalize_Address_Table.Get (Obj);\n-      Unlock_Task.all;\n-\n-      return Result;\n-   end Get_Finalize_Address;\n-\n    -----------------\n    -- Header_Size --\n    -----------------\n@@ -248,17 +181,6 @@ package body System.Finalization_Masters is\n       return FM_Node'Size / Storage_Unit;\n    end Header_Size;\n \n-   ----------\n-   -- Hash --\n-   ----------\n-\n-   function Hash (Key : System.Address) return Header_Num is\n-   begin\n-      return\n-        Header_Num\n-          (To_Integer (Key) mod Integer_Address (Header_Num'Range_Length));\n-   end Hash;\n-\n    -------------------\n    -- Header_Offset --\n    -------------------\n@@ -280,11 +202,11 @@ package body System.Finalization_Masters is\n       Master.Objects.Prev := Master.Objects'Unchecked_Access;\n    end Initialize;\n \n-   ------------------\n-   -- Print_Master --\n-   ------------------\n+   --------\n+   -- pm --\n+   --------\n \n-   procedure Print_Master (Master : Finalization_Master) is\n+   procedure pm (Master : Finalization_Master) is\n       Head      : constant FM_Node_Ptr := Master.Objects'Unrestricted_Access;\n       Head_Seen : Boolean := False;\n       N_Ptr     : FM_Node_Ptr;\n@@ -293,25 +215,23 @@ package body System.Finalization_Masters is\n       --  Output the basic contents of a master\n \n       --    Master   : 0x123456789\n-      --    Is_Hmgen : TURE <or> FALSE\n       --    Base_Pool: null <or> 0x123456789\n       --    Fin_Addr : null <or> 0x123456789\n       --    Fin_Start: TRUE <or> FALSE\n \n       Put (\"Master   : \");\n       Put_Line (Address_Image (Master'Address));\n \n-      Put (\"Is_Hmgen : \");\n-      Put_Line (Master.Is_Homogeneous'Img);\n-\n       Put (\"Base_Pool: \");\n+\n       if Master.Base_Pool = null then\n-         Put_Line (\"null\");\n+         Put_Line (\" null\");\n       else\n          Put_Line (Address_Image (Master.Base_Pool'Address));\n       end if;\n \n       Put (\"Fin_Addr : \");\n+\n       if Master.Finalize_Address = null then\n          Put_Line (\"null\");\n       else\n@@ -335,17 +255,17 @@ package body System.Finalization_Masters is\n \n       --  Header - the address of the list header\n       --  Prev   - the address of the list header which the current element\n-      --           points back to\n+      --         - points back to\n       --  Next   - the address of the list header which the current element\n-      --           points to\n+      --         - points to\n       --  (dummy head) - present if dummy head\n \n       N_Ptr := Head;\n-      while N_Ptr /= null loop  --  Should never be null\n+      while N_Ptr /= null loop -- Should never be null; we being defensive\n          Put_Line (\"V\");\n \n          --  We see the head initially; we want to exit when we see the head a\n-         --  second time.\n+         --  SECOND time.\n \n          if N_Ptr = Head then\n             exit when Head_Seen;\n@@ -401,7 +321,7 @@ package body System.Finalization_Masters is\n \n          N_Ptr := N_Ptr.Next;\n       end loop;\n-   end Print_Master;\n+   end pm;\n \n    -------------------\n    -- Set_Base_Pool --\n@@ -427,18 +347,4 @@ package body System.Finalization_Masters is\n       Master.Finalize_Address := Fin_Addr_Ptr;\n    end Set_Finalize_Address;\n \n-   --------------------------\n-   -- Set_Finalize_Address --\n-   --------------------------\n-\n-   procedure Set_Finalize_Address\n-     (Obj          : System.Address;\n-      Fin_Addr_Ptr : Finalize_Address_Ptr)\n-   is\n-   begin\n-      Lock_Task.all;\n-      Finalize_Address_Table.Set (Obj, Fin_Addr_Ptr);\n-      Unlock_Task.all;\n-   end Set_Finalize_Address;\n-\n end System.Finalization_Masters;"}, {"sha": "87a607678bcc3556844be6cf99aa46ec4d73d722", "filename": "gcc/ada/s-finmas.ads", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a613a3621f796e5e8e21a6237caf60eaebcada0/gcc%2Fada%2Fs-finmas.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a613a3621f796e5e8e21a6237caf60eaebcada0/gcc%2Fada%2Fs-finmas.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-finmas.ads?ref=3a613a3621f796e5e8e21a6237caf60eaebcada0", "patch": "@@ -31,6 +31,7 @@\n \n with Ada.Finalization;\n with Ada.Unchecked_Conversion;\n+\n with System.Storage_Elements;\n with System.Storage_Pools;\n \n@@ -68,10 +69,9 @@ package System.Finalization_Masters is\n \n    --  Finalization master type structure. A unique master is associated with\n    --  each access-to-controlled or access-to-class-wide type. Masters also act\n-   --  as components of subpools. By default, a master contains objects of the\n-   --  same designated type but it may also accomodate heterogeneous objects.\n+   --  as components of subpools.\n \n-   type Finalization_Master (Is_Homogeneous : Boolean := True) is\n+   type Finalization_Master is\n      new Ada.Finalization.Limited_Controlled with\n    record\n       Base_Pool : Any_Storage_Pool_Ptr := null;\n@@ -83,8 +83,7 @@ package System.Finalization_Masters is\n       --  objects allocated in a [sub]pool.\n \n       Finalize_Address : Finalize_Address_Ptr := null;\n-      --  A reference to the routine reponsible for object finalization. This\n-      --  is used only when the master is in homogeneous mode.\n+      --  A reference to the routine reponsible for object finalization\n \n       Finalization_Started : Boolean := False;\n       pragma Atomic (Finalization_Started);\n@@ -115,10 +114,6 @@ package System.Finalization_Masters is\n    --  Return a reference to the underlying storage pool on which the master\n    --  operates.\n \n-   procedure Delete_Finalize_Address (Obj : System.Address);\n-   --  Destroy the relation pair object - Finalize_Address from the internal\n-   --  hash table.\n-\n    procedure Detach (N : not null FM_Node_Ptr);\n    --  Remove a node from an arbitrary finalization master\n \n@@ -127,11 +122,6 @@ package System.Finalization_Masters is\n    --  the list of allocated controlled objects, finalizing each one by calling\n    --  its specific Finalize_Address. In the end, deallocate the dummy head.\n \n-   function Get_Finalize_Address\n-     (Obj : System.Address) return Finalize_Address_Ptr;\n-   --  Retrieve the Finalize_Address primitive associated with a particular\n-   --  object.\n-\n    function Header_Offset return System.Storage_Elements.Storage_Offset;\n    --  Return the size of type FM_Node as Storage_Offset\n \n@@ -141,7 +131,7 @@ package System.Finalization_Masters is\n    overriding procedure Initialize (Master : in out Finalization_Master);\n    --  Initialize the dummy head of a finalization master\n \n-   procedure Print_Master (Master : Finalization_Master);\n+   procedure pm (Master : Finalization_Master);\n    --  Debug routine, outputs the contents of a master\n \n    procedure Set_Base_Pool\n@@ -154,9 +144,4 @@ package System.Finalization_Masters is\n       Fin_Addr_Ptr : Finalize_Address_Ptr);\n    --  Set the clean up routine of a finalization master\n \n-   procedure Set_Finalize_Address\n-     (Obj          : System.Address;\n-      Fin_Addr_Ptr : Finalize_Address_Ptr);\n-   --  Add a relation pair object - Finalize_Address to the internal hash table\n-\n end System.Finalization_Masters;"}, {"sha": "bf3a87e662f9b5812a551727c834d7b630098776", "filename": "gcc/ada/s-stposu.adb", "status": "modified", "additions": 14, "deletions": 200, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a613a3621f796e5e8e21a6237caf60eaebcada0/gcc%2Fada%2Fs-stposu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a613a3621f796e5e8e21a6237caf60eaebcada0/gcc%2Fada%2Fs-stposu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stposu.adb?ref=3a613a3621f796e5e8e21a6237caf60eaebcada0", "patch": "@@ -31,19 +31,13 @@\n \n with Ada.Exceptions;              use Ada.Exceptions;\n with Ada.Unchecked_Deallocation;\n-with System.Address_Image;\n+\n with System.Finalization_Masters; use System.Finalization_Masters;\n-with System.IO;                   use System.IO;\n with System.Soft_Links;           use System.Soft_Links;\n with System.Storage_Elements;     use System.Storage_Elements;\n \n package body System.Storage_Pools.Subpools is\n \n-   Finalize_Address_Table_In_Use : Boolean := False;\n-   --  This flag should be set only when a successfull allocation on a subpool\n-   --  has been performed and the associated Finalize_Address has been added to\n-   --  the hash table in System.Finalization_Masters.\n-\n    procedure Attach (N : not null SP_Node_Ptr; L : not null SP_Node_Ptr);\n    --  Attach a subpool node to a pool\n \n@@ -254,40 +248,21 @@ package body System.Storage_Pools.Subpools is\n          --     +- Header_And_Padding --+\n \n          N_Ptr := Address_To_FM_Node_Ptr\n-                    (N_Addr + Header_And_Padding - Header_Offset);\n+                   (N_Addr + Header_And_Padding - Header_Offset);\n \n          --  Prepend the allocated object to the finalization master\n \n          Attach (N_Ptr, Master.Objects'Unchecked_Access);\n \n+         if Master.Finalize_Address = null then\n+            Master.Finalize_Address := Fin_Address;\n+         end if;\n+\n          --  Move the address from the hidden list header to the start of the\n          --  object. This operation effectively hides the list header.\n \n          Addr := N_Addr + Header_And_Padding;\n \n-         --  Subpool allocations use heterogeneous masters to manage various\n-         --  controlled objects. Associate a Finalize_Address with the object.\n-         --  This relation pair is deleted when the object is deallocated or\n-         --  when the associated master is finalized.\n-\n-         if Is_Subpool_Allocation then\n-            pragma Assert (not Master.Is_Homogeneous);\n-\n-            Set_Finalize_Address (Addr, Fin_Address);\n-            Finalize_Address_Table_In_Use := True;\n-\n-         --  Normal allocations chain objects on homogeneous collections\n-\n-         else\n-            pragma Assert (Master.Is_Homogeneous);\n-\n-            if Master.Finalize_Address = null then\n-               Master.Finalize_Address := Fin_Address;\n-            end if;\n-         end if;\n-\n-      --  Non-controlled allocation\n-\n       else\n          Addr := N_Addr;\n       end if;\n@@ -340,13 +315,6 @@ package body System.Storage_Pools.Subpools is\n \n       if Is_Controlled then\n \n-         --  Destroy the relation pair object - Finalize_Address since it is no\n-         --  longer needed.\n-\n-         if Finalize_Address_Table_In_Use then\n-            Delete_Finalize_Address (Addr);\n-         end if;\n-\n          --  Account for possible padding space before the header due to a\n          --  larger alignment.\n \n@@ -414,8 +382,6 @@ package body System.Storage_Pools.Subpools is\n \n       N.Prev.Next := N.Next;\n       N.Next.Prev := N.Prev;\n-      N.Prev := null;\n-      N.Next := null;\n \n       Unlock_Task.all;\n \n@@ -439,22 +405,9 @@ package body System.Storage_Pools.Subpools is\n    procedure Finalize_Pool (Pool : in out Root_Storage_Pool_With_Subpools) is\n       Curr_Ptr : SP_Node_Ptr;\n       Ex_Occur : Exception_Occurrence;\n+      Next_Ptr : SP_Node_Ptr;\n       Raised   : Boolean := False;\n \n-      function Is_Empty_List (L : not null SP_Node_Ptr) return Boolean;\n-      --  Determine whether a list contains only one element, the dummy head\n-\n-      -------------------\n-      -- Is_Empty_List --\n-      -------------------\n-\n-      function Is_Empty_List (L : not null SP_Node_Ptr) return Boolean is\n-      begin\n-         return L.Next = L and then L.Prev = L;\n-      end Is_Empty_List;\n-\n-   --  Start of processing for Finalize_Pool\n-\n    begin\n       --  It is possible for multiple tasks to cause the finalization of a\n       --  common pool. Allow only one task to finalize the contents.\n@@ -470,8 +423,11 @@ package body System.Storage_Pools.Subpools is\n \n       Pool.Finalization_Started := True;\n \n-      while not Is_Empty_List (Pool.Subpools'Unchecked_Access) loop\n-         Curr_Ptr := Pool.Subpools.Next;\n+      --  Skip the dummy head\n+\n+      Curr_Ptr := Pool.Subpools.Next;\n+      while Curr_Ptr /= Pool.Subpools'Unchecked_Access loop\n+         Next_Ptr := Curr_Ptr.Next;\n \n          --  Perform the following actions:\n \n@@ -490,6 +446,8 @@ package body System.Storage_Pools.Subpools is\n                   Save_Occurrence (Ex_Occur, Fin_Occur);\n                end if;\n          end;\n+\n+         Curr_Ptr := Next_Ptr;\n       end loop;\n \n       --  If the finalization of a particular master failed, reraise the\n@@ -579,150 +537,6 @@ package body System.Storage_Pools.Subpools is\n       return Subpool.Owner;\n    end Pool_Of_Subpool;\n \n-   ----------------\n-   -- Print_Pool --\n-   ----------------\n-\n-   procedure Print_Pool (Pool : Root_Storage_Pool_With_Subpools) is\n-      Head      : constant SP_Node_Ptr := Pool.Subpools'Unrestricted_Access;\n-      Head_Seen : Boolean := False;\n-      SP_Ptr    : SP_Node_Ptr;\n-\n-   begin\n-      --  Output the contents of the pool\n-\n-      --    Pool      : 0x123456789\n-      --    Subpools  : 0x123456789\n-      --    Fin_Start : TRUE <or> FALSE\n-      --    Controller: OK <or> NOK\n-\n-      Put (\"Pool      : \");\n-      Put_Line (Address_Image (Pool'Address));\n-\n-      Put (\"Subpools  : \");\n-      Put_Line (Address_Image (Pool.Subpools'Address));\n-\n-      Put (\"Fin_Start : \");\n-      Put_Line (Pool.Finalization_Started'Img);\n-\n-      Put (\"Controlled: \");\n-      if Pool.Controller.Enclosing_Pool = Pool'Unrestricted_Access then\n-         Put_Line (\"OK\");\n-      else\n-         Put_Line (\"NOK (ERROR)\");\n-      end if;\n-\n-      SP_Ptr := Head;\n-      while SP_Ptr /= null loop  --  Should never be null\n-         Put_Line (\"V\");\n-\n-         --  We see the head initially; we want to exit when we see the head a\n-         --  second time.\n-\n-         if SP_Ptr = Head then\n-            exit when Head_Seen;\n-\n-            Head_Seen := True;\n-         end if;\n-\n-         --  The current element is null. This should never happend since the\n-         --  list is circular.\n-\n-         if SP_Ptr.Prev = null then\n-            Put_Line (\"null (ERROR)\");\n-\n-         --  The current element points back to the correct element\n-\n-         elsif SP_Ptr.Prev.Next = SP_Ptr then\n-            Put_Line (\"^\");\n-\n-         --  The current element points to an erroneous element\n-\n-         else\n-            Put_Line (\"? (ERROR)\");\n-         end if;\n-\n-         --  Output the contents of the node\n-\n-         Put (\"|Header: \");\n-         Put (Address_Image (SP_Ptr.all'Address));\n-         if SP_Ptr = Head then\n-            Put_Line (\" (dummy head)\");\n-         else\n-            Put_Line (\"\");\n-         end if;\n-\n-         Put (\"|  Prev: \");\n-\n-         if SP_Ptr.Prev = null then\n-            Put_Line (\"null\");\n-         else\n-            Put_Line (Address_Image (SP_Ptr.Prev.all'Address));\n-         end if;\n-\n-         Put (\"|  Next: \");\n-\n-         if SP_Ptr.Next = null then\n-            Put_Line (\"null\");\n-         else\n-            Put_Line (Address_Image (SP_Ptr.Next.all'Address));\n-         end if;\n-\n-         Put (\"|  Subp: \");\n-\n-         if SP_Ptr.Subpool = null then\n-            Put_Line (\"null\");\n-         else\n-            Put_Line (Address_Image (SP_Ptr.Subpool.all'Address));\n-         end if;\n-\n-         SP_Ptr := SP_Ptr.Next;\n-      end loop;\n-   end Print_Pool;\n-\n-   -------------------\n-   -- Print_Subpool --\n-   -------------------\n-\n-   procedure Print_Subpool (Subpool : Subpool_Handle) is\n-   begin\n-      if Subpool = null then\n-         Put_Line (\"null\");\n-         return;\n-      end if;\n-\n-      --  Output the contents of a subpool\n-\n-      --    Owner : 0x123456789\n-      --    Master: 0x123456789\n-      --    Node  : 0x123456789\n-\n-      Put (\"Owner : \");\n-      if Subpool.Owner = null then\n-         Put_Line (\"null\");\n-      else\n-         Put_Line (Address_Image (Subpool.Owner'Address));\n-      end if;\n-\n-      Put (\"Master: \");\n-      Put_Line (Address_Image (Subpool.Master'Address));\n-\n-      Put (\"Node  : \");\n-      if Subpool.Node = null then\n-         Put (\"null\");\n-\n-         if Subpool.Owner = null then\n-            Put_Line (\" OK\");\n-         else\n-            Put_Line (\" (ERROR)\");\n-         end if;\n-      else\n-         Put_Line (Address_Image (Subpool.Node'Address));\n-      end if;\n-\n-      Print_Master (Subpool.Master);\n-   end Print_Subpool;\n-\n    -------------------------\n    -- Set_Pool_Of_Subpool --\n    -------------------------"}, {"sha": "bd2681869264a43444d8e750ff7c0c43b1eb99ae", "filename": "gcc/ada/s-stposu.ads", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a613a3621f796e5e8e21a6237caf60eaebcada0/gcc%2Fada%2Fs-stposu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a613a3621f796e5e8e21a6237caf60eaebcada0/gcc%2Fada%2Fs-stposu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stposu.ads?ref=3a613a3621f796e5e8e21a6237caf60eaebcada0", "patch": "@@ -34,6 +34,7 @@\n ------------------------------------------------------------------------------\n \n with Ada.Finalization;\n+\n with System.Finalization_Masters;\n with System.Storage_Elements;\n \n@@ -240,8 +241,8 @@ private\n       Owner : Any_Storage_Pool_With_Subpools_Ptr := null;\n       --  A reference to the master pool_with_subpools\n \n-      Master : aliased System.Finalization_Masters.Finalization_Master (False);\n-      --  A heterogeneous collection of controlled objects\n+      Master : aliased System.Finalization_Masters.Finalization_Master;\n+      --  A collection of controlled objects\n \n       Node : SP_Node_Ptr := null;\n       --  A link to the doubly linked list node which contains the subpool.\n@@ -335,10 +336,4 @@ private\n    procedure Initialize_Pool (Pool : in out Root_Storage_Pool_With_Subpools);\n    --  Setup the doubly linked list of subpools\n \n-   procedure Print_Pool (Pool : Root_Storage_Pool_With_Subpools);\n-   --  Debug routine, output the contents of a pool_with_subpools\n-\n-   procedure Print_Subpool (Subpool : Subpool_Handle);\n-   --  Debug routine, output the contents of a subpool\n-\n end System.Storage_Pools.Subpools;"}]}