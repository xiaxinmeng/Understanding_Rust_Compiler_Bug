{"sha": "b52a3881f04799d410f7ec70d022179c8d734459", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjUyYTM4ODFmMDQ3OTlkNDEwZjdlYzcwZDAyMjE3OWM4ZDczNDQ1OQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-02-01T21:55:38Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-02-01T21:55:38Z"}, "message": "runtime, sync: use __atomic intrinsics instead of __sync\n    \n    GCC has supported the __atomic intrinsics since 4.7.  They are better\n    than the __sync intrinsics in that they specify a memory model and,\n    more importantly for our purposes, they are reliably implemented\n    either in the compiler or in libatomic.\n    \n    Fixes https://gcc.gnu.org/PR52084\n    \n    Reviewed-on: https://go-review.googlesource.com/c/160820\n\nFrom-SVN: r268458", "tree": {"sha": "eace57a9fb5df73173371815f0a0e1a5913a77a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eace57a9fb5df73173371815f0a0e1a5913a77a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b52a3881f04799d410f7ec70d022179c8d734459", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b52a3881f04799d410f7ec70d022179c8d734459", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b52a3881f04799d410f7ec70d022179c8d734459", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b52a3881f04799d410f7ec70d022179c8d734459/comments", "author": null, "committer": null, "parents": [{"sha": "a53a893b4fe04ec966a4ec178ee8f394426a5dad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a53a893b4fe04ec966a4ec178ee8f394426a5dad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a53a893b4fe04ec966a4ec178ee8f394426a5dad"}], "stats": {"total": 532, "additions": 42, "deletions": 490}, "files": [{"sha": "a9041c3c2cadafb7a41632a6ca381525260b637f", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a3881f04799d410f7ec70d022179c8d734459/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a3881f04799d410f7ec70d022179c8d734459/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=b52a3881f04799d410f7ec70d022179c8d734459", "patch": "@@ -1,4 +1,4 @@\n-cbcc538adc5177778da5788d1101e16f106a1514\n+c49ad6c4e66fa7ca992d947a5f0377090abadf6b\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "1d62f11b69c79b37f2e9ab2618b4f613abbcb634", "filename": "libgo/Makefile.am", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a3881f04799d410f7ec70d022179c8d734459/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a3881f04799d410f7ec70d022179c8d734459/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=b52a3881f04799d410f7ec70d022179c8d734459", "patch": "@@ -471,7 +471,6 @@ runtime_files = \\\n \truntime/proc.c \\\n \truntime/runtime_c.c \\\n \truntime/stack.c \\\n-\truntime/thread.c \\\n \truntime/yield.c \\\n \t$(rtems_task_variable_add_file) \\\n \t$(runtime_getncpu_file)"}, {"sha": "04cce1406644164302bcaec8d4e88fc91e589787", "filename": "libgo/Makefile.in", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a3881f04799d410f7ec70d022179c8d734459/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a3881f04799d410f7ec70d022179c8d734459/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=b52a3881f04799d410f7ec70d022179c8d734459", "patch": "@@ -252,8 +252,8 @@ am__objects_3 = runtime/aeshash.lo runtime/go-assert.lo \\\n \truntime/go-unsetenv.lo runtime/go-unwind.lo \\\n \truntime/go-varargs.lo runtime/env_posix.lo runtime/panic.lo \\\n \truntime/print.lo runtime/proc.lo runtime/runtime_c.lo \\\n-\truntime/stack.lo runtime/thread.lo runtime/yield.lo \\\n-\t$(am__objects_1) $(am__objects_2)\n+\truntime/stack.lo runtime/yield.lo $(am__objects_1) \\\n+\t$(am__objects_2)\n am_libgo_llgo_la_OBJECTS = $(am__objects_3)\n libgo_llgo_la_OBJECTS = $(am_libgo_llgo_la_OBJECTS)\n AM_V_lt = $(am__v_lt_@AM_V@)\n@@ -897,7 +897,6 @@ runtime_files = \\\n \truntime/proc.c \\\n \truntime/runtime_c.c \\\n \truntime/stack.c \\\n-\truntime/thread.c \\\n \truntime/yield.c \\\n \t$(rtems_task_variable_add_file) \\\n \t$(runtime_getncpu_file)\n@@ -1373,8 +1372,6 @@ runtime/runtime_c.lo: runtime/$(am__dirstamp) \\\n \truntime/$(DEPDIR)/$(am__dirstamp)\n runtime/stack.lo: runtime/$(am__dirstamp) \\\n \truntime/$(DEPDIR)/$(am__dirstamp)\n-runtime/thread.lo: runtime/$(am__dirstamp) \\\n-\truntime/$(DEPDIR)/$(am__dirstamp)\n runtime/yield.lo: runtime/$(am__dirstamp) \\\n \truntime/$(DEPDIR)/$(am__dirstamp)\n runtime/rtems-task-variable-add.lo: runtime/$(am__dirstamp) \\\n@@ -1449,7 +1446,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@runtime/$(DEPDIR)/rtems-task-variable-add.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@runtime/$(DEPDIR)/runtime_c.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@runtime/$(DEPDIR)/stack.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@runtime/$(DEPDIR)/thread.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@runtime/$(DEPDIR)/yield.Plo@am__quote@\n \n .c.o:"}, {"sha": "bbb2516bbbf89409b6e6e979c7c6e4e69e6593bf", "filename": "libgo/config.h.in", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a3881f04799d410f7ec70d022179c8d734459/libgo%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a3881f04799d410f7ec70d022179c8d734459/libgo%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfig.h.in?ref=b52a3881f04799d410f7ec70d022179c8d734459", "patch": "@@ -246,22 +246,6 @@\n /* Define to 1 if <math.h> defines struct exception */\n #undef HAVE_STRUCT_EXCEPTION\n \n-/* Define to 1 if the compiler provides the __sync_add_and_fetch function for\n-   uint64 */\n-#undef HAVE_SYNC_ADD_AND_FETCH_8\n-\n-/* Define to 1 if the compiler provides the __sync_bool_compare_and_swap\n-   function for uint32 */\n-#undef HAVE_SYNC_BOOL_COMPARE_AND_SWAP_4\n-\n-/* Define to 1 if the compiler provides the __sync_bool_compare_and_swap\n-   function for uint64 */\n-#undef HAVE_SYNC_BOOL_COMPARE_AND_SWAP_8\n-\n-/* Define to 1 if the compiler provides the __sync_fetch_and_add function for\n-   uint32 */\n-#undef HAVE_SYNC_FETCH_AND_ADD_4\n-\n /* Define to 1 if you have the `sync_file_range' function. */\n #undef HAVE_SYNC_FILE_RANGE\n "}, {"sha": "138a9c6a6a8980f95c2756304a12381eec0abb8e", "filename": "libgo/configure", "status": "modified", "additions": 0, "deletions": 116, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a3881f04799d410f7ec70d022179c8d734459/libgo%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a3881f04799d410f7ec70d022179c8d734459/libgo%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure?ref=b52a3881f04799d410f7ec70d022179c8d734459", "patch": "@@ -15135,122 +15135,6 @@ done\n \n LIBS=\"$LIBS_hold\"\n \n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for __sync_bool_compare_and_swap_4\" >&5\n-$as_echo_n \"checking for __sync_bool_compare_and_swap_4... \" >&6; }\n-if ${libgo_cv_func___sync_bool_compare_and_swap_4+:} false; then :\n-  $as_echo_n \"(cached) \" >&6\n-else\n-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n-/* end confdefs.h.  */\n-\n-typedef unsigned int uint32  __attribute__ ((mode (SI)));\n-uint32 i;\n-int main() { return __sync_bool_compare_and_swap (&i, 0, 1); }\n-\n-_ACEOF\n-if ac_fn_c_try_link \"$LINENO\"; then :\n-  libgo_cv_func___sync_bool_compare_and_swap_4=yes\n-else\n-  libgo_cv_func___sync_bool_compare_and_swap_4=no\n-fi\n-rm -f core conftest.err conftest.$ac_objext \\\n-    conftest$ac_exeext conftest.$ac_ext\n-fi\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $libgo_cv_func___sync_bool_compare_and_swap_4\" >&5\n-$as_echo \"$libgo_cv_func___sync_bool_compare_and_swap_4\" >&6; }\n-if test \"$libgo_cv_func___sync_bool_compare_and_swap_4\" = \"yes\"; then\n-\n-$as_echo \"#define HAVE_SYNC_BOOL_COMPARE_AND_SWAP_4 1\" >>confdefs.h\n-\n-fi\n-\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for __sync_bool_compare_and_swap_8\" >&5\n-$as_echo_n \"checking for __sync_bool_compare_and_swap_8... \" >&6; }\n-if ${libgo_cv_func___sync_bool_compare_and_swap_8+:} false; then :\n-  $as_echo_n \"(cached) \" >&6\n-else\n-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n-/* end confdefs.h.  */\n-\n-typedef unsigned int uint64  __attribute__ ((mode (DI)));\n-uint64 i;\n-int main() { return __sync_bool_compare_and_swap (&i, 0, 1); }\n-\n-_ACEOF\n-if ac_fn_c_try_link \"$LINENO\"; then :\n-  libgo_cv_func___sync_bool_compare_and_swap_8=yes\n-else\n-  libgo_cv_func___sync_bool_compare_and_swap_8=no\n-fi\n-rm -f core conftest.err conftest.$ac_objext \\\n-    conftest$ac_exeext conftest.$ac_ext\n-fi\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $libgo_cv_func___sync_bool_compare_and_swap_8\" >&5\n-$as_echo \"$libgo_cv_func___sync_bool_compare_and_swap_8\" >&6; }\n-if test \"$libgo_cv_func___sync_bool_compare_and_swap_8\" = \"yes\"; then\n-\n-$as_echo \"#define HAVE_SYNC_BOOL_COMPARE_AND_SWAP_8 1\" >>confdefs.h\n-\n-fi\n-\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for __sync_fetch_and_add_4\" >&5\n-$as_echo_n \"checking for __sync_fetch_and_add_4... \" >&6; }\n-if ${libgo_cv_func___sync_fetch_and_add_4+:} false; then :\n-  $as_echo_n \"(cached) \" >&6\n-else\n-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n-/* end confdefs.h.  */\n-\n-typedef unsigned int uint32  __attribute__ ((mode (SI)));\n-uint32 i;\n-int main() { return __sync_fetch_and_add (&i, 1); }\n-\n-_ACEOF\n-if ac_fn_c_try_link \"$LINENO\"; then :\n-  libgo_cv_func___sync_fetch_and_add_4=yes\n-else\n-  libgo_cv_func___sync_fetch_and_add_4=no\n-fi\n-rm -f core conftest.err conftest.$ac_objext \\\n-    conftest$ac_exeext conftest.$ac_ext\n-fi\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $libgo_cv_func___sync_fetch_and_add_4\" >&5\n-$as_echo \"$libgo_cv_func___sync_fetch_and_add_4\" >&6; }\n-if test \"$libgo_cv_func___sync_fetch_and_add_4\" = \"yes\"; then\n-\n-$as_echo \"#define HAVE_SYNC_FETCH_AND_ADD_4 1\" >>confdefs.h\n-\n-fi\n-\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for __sync_add_and_fetch_8\" >&5\n-$as_echo_n \"checking for __sync_add_and_fetch_8... \" >&6; }\n-if ${libgo_cv_func___sync_add_and_fetch_8+:} false; then :\n-  $as_echo_n \"(cached) \" >&6\n-else\n-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n-/* end confdefs.h.  */\n-\n-typedef unsigned int uint64  __attribute__ ((mode (DI)));\n-uint64 i;\n-int main() { return __sync_add_and_fetch (&i, 1); }\n-\n-_ACEOF\n-if ac_fn_c_try_link \"$LINENO\"; then :\n-  libgo_cv_func___sync_add_and_fetch_8=yes\n-else\n-  libgo_cv_func___sync_add_and_fetch_8=no\n-fi\n-rm -f core conftest.err conftest.$ac_objext \\\n-    conftest$ac_exeext conftest.$ac_ext\n-fi\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $libgo_cv_func___sync_add_and_fetch_8\" >&5\n-$as_echo \"$libgo_cv_func___sync_add_and_fetch_8\" >&6; }\n-if test \"$libgo_cv_func___sync_add_and_fetch_8\" = \"yes\"; then\n-\n-$as_echo \"#define HAVE_SYNC_ADD_AND_FETCH_8 1\" >>confdefs.h\n-\n-fi\n-\n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether compiler supports -minline-all-stringops\" >&5\n $as_echo_n \"checking whether compiler supports -minline-all-stringops... \" >&6; }\n if ${libgo_cv_c_stringops+:} false; then :"}, {"sha": "2b452ec9de8c55722514668b75806aef3928f8bf", "filename": "libgo/configure.ac", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a3881f04799d410f7ec70d022179c8d734459/libgo%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a3881f04799d410f7ec70d022179c8d734459/libgo%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure.ac?ref=b52a3881f04799d410f7ec70d022179c8d734459", "patch": "@@ -578,62 +578,6 @@ LIBS=\"$LIBS $MATH_LIBS\"\n AC_CHECK_FUNCS(matherr)\n LIBS=\"$LIBS_hold\"\n \n-AC_CACHE_CHECK([for __sync_bool_compare_and_swap_4],\n-[libgo_cv_func___sync_bool_compare_and_swap_4],\n-[AC_LINK_IFELSE([AC_LANG_SOURCE([\n-typedef unsigned int uint32  __attribute__ ((mode (SI)));\n-uint32 i;\n-int main() { return __sync_bool_compare_and_swap (&i, 0, 1); }\n-])],\n-[libgo_cv_func___sync_bool_compare_and_swap_4=yes],\n-[libgo_cv_func___sync_bool_compare_and_swap_4=no])])\n-if test \"$libgo_cv_func___sync_bool_compare_and_swap_4\" = \"yes\"; then\n-  AC_DEFINE(HAVE_SYNC_BOOL_COMPARE_AND_SWAP_4, 1,\n-    [Define to 1 if the compiler provides the __sync_bool_compare_and_swap function for uint32])\n-fi\n-\n-AC_CACHE_CHECK([for __sync_bool_compare_and_swap_8],\n-[libgo_cv_func___sync_bool_compare_and_swap_8],\n-[AC_LINK_IFELSE([AC_LANG_SOURCE([\n-typedef unsigned int uint64  __attribute__ ((mode (DI)));\n-uint64 i;\n-int main() { return __sync_bool_compare_and_swap (&i, 0, 1); }\n-])],\n-[libgo_cv_func___sync_bool_compare_and_swap_8=yes],\n-[libgo_cv_func___sync_bool_compare_and_swap_8=no])])\n-if test \"$libgo_cv_func___sync_bool_compare_and_swap_8\" = \"yes\"; then\n-  AC_DEFINE(HAVE_SYNC_BOOL_COMPARE_AND_SWAP_8, 1,\n-    [Define to 1 if the compiler provides the __sync_bool_compare_and_swap function for uint64])\n-fi\n-\n-AC_CACHE_CHECK([for __sync_fetch_and_add_4],\n-[libgo_cv_func___sync_fetch_and_add_4],\n-[AC_LINK_IFELSE([AC_LANG_SOURCE([\n-typedef unsigned int uint32  __attribute__ ((mode (SI)));\n-uint32 i;\n-int main() { return __sync_fetch_and_add (&i, 1); }\n-])],\n-[libgo_cv_func___sync_fetch_and_add_4=yes],\n-[libgo_cv_func___sync_fetch_and_add_4=no])])\n-if test \"$libgo_cv_func___sync_fetch_and_add_4\" = \"yes\"; then\n-  AC_DEFINE(HAVE_SYNC_FETCH_AND_ADD_4, 1,\n-    [Define to 1 if the compiler provides the __sync_fetch_and_add function for uint32])\n-fi\n-\n-AC_CACHE_CHECK([for __sync_add_and_fetch_8],\n-[libgo_cv_func___sync_add_and_fetch_8],\n-[AC_LINK_IFELSE([AC_LANG_SOURCE([\n-typedef unsigned int uint64  __attribute__ ((mode (DI)));\n-uint64 i;\n-int main() { return __sync_add_and_fetch (&i, 1); }\n-])],\n-[libgo_cv_func___sync_add_and_fetch_8=yes],\n-[libgo_cv_func___sync_add_and_fetch_8=no])])\n-if test \"$libgo_cv_func___sync_add_and_fetch_8\" = \"yes\"; then\n-  AC_DEFINE(HAVE_SYNC_ADD_AND_FETCH_8, 1,\n-    [Define to 1 if the compiler provides the __sync_add_and_fetch function for uint64])\n-fi\n-\n dnl For x86 we want to use the -minline-all-stringops option to avoid\n dnl forcing a stack split when calling memcpy and friends.\n AC_CACHE_CHECK([whether compiler supports -minline-all-stringops],"}, {"sha": "9a8c057761e8f114120ca5055a38d04b55c18cd0", "filename": "libgo/go/runtime/testdata/testprogcgo/lockosthread.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a3881f04799d410f7ec70d022179c8d734459/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Flockosthread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a3881f04799d410f7ec70d022179c8d734459/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Flockosthread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Flockosthread.c?ref=b52a3881f04799d410f7ec70d022179c8d734459", "patch": "@@ -9,5 +9,5 @@\n uint32_t threadExited;\n \n void setExited(void *x) {\n-\t__sync_fetch_and_add(&threadExited, 1);\n+\t__atomic_add_fetch(&threadExited, 1, __ATOMIC_SEQ_CST);\n }"}, {"sha": "28b094ff75861f3fdfc609bdcc0e805ebd003023", "filename": "libgo/go/runtime/testdata/testprogcgo/threadpprof.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a3881f04799d410f7ec70d022179c8d734459/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Fthreadpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a3881f04799d410f7ec70d022179c8d734459/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Fthreadpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Fthreadpprof.go?ref=b52a3881f04799d410f7ec70d022179c8d734459", "patch": "@@ -50,13 +50,13 @@ void pprofCgoThreadTraceback(void* parg) {\n \targ->buf[0] = (uintptr_t)(cpuHogThread) + 0x10;\n \targ->buf[1] = (uintptr_t)(cpuHogThread2) + 0x4;\n \targ->buf[2] = 0;\n-\t__sync_add_and_fetch(&cpuHogThreadCount, 1);\n+\t__atomic_add_fetch(&cpuHogThreadCount, 1, __ATOMIC_SEQ_CST);\n }\n \n // getCPUHogThreadCount fetches the number of times we've seen cpuHogThread\n // in the traceback.\n int getCPUHogThreadCount() {\n-\treturn __sync_add_and_fetch(&cpuHogThreadCount, 0);\n+\treturn __atomic_load(&cpuHogThreadCount, __ATOMIC_SEQ_CST);\n }\n \n static void* cpuHogDriver(void* arg __attribute__ ((unused))) {"}, {"sha": "ff6895e637c1af4b2bf6293b451f3f4adea29371", "filename": "libgo/go/runtime/testdata/testprogcgo/tracebackctxt_c.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a3881f04799d410f7ec70d022179c8d734459/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Ftracebackctxt_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a3881f04799d410f7ec70d022179c8d734459/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Ftracebackctxt_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Ftracebackctxt_c.c?ref=b52a3881f04799d410f7ec70d022179c8d734459", "patch": "@@ -49,18 +49,18 @@ struct cgoSymbolizerArg {\n static int contextCount;\n \n int getContextCount() {\n-\treturn __sync_add_and_fetch(&contextCount, 0);\n+\treturn __atomic_load_n(&contextCount, __ATOMIC_SEQ_CST);\n }\n \n void tcContext(void* parg) {\n \tstruct cgoContextArg* arg = (struct cgoContextArg*)(parg);\n \tif (arg->context == 0) {\n-\t\targ->context = __sync_add_and_fetch(&contextCount, 1);\n+\t\targ->context = __atomic_add_fetch(&contextCount, 1, __ATOMIC_SEQ_CST);\n \t} else {\n-\t\tif (arg->context != __sync_add_and_fetch(&contextCount, 0)) {\n+\t\tif (arg->context != __atomic_load_n(&contextCount, __ATOMIC_SEQ_CST))\n \t\t\tabort();\n \t\t}\n-\t\t__sync_sub_and_fetch(&contextCount, 1);\n+\t\t__atomic_sub_fetch(&contextCount, 1, __ATOMIC_SEQ_CST);\n \t}\n }\n "}, {"sha": "25e439dac2b313353d9dbba0ae36762cc0fce658", "filename": "libgo/go/sync/atomic/atomic.c", "status": "modified", "additions": 26, "deletions": 71, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a3881f04799d410f7ec70d022179c8d734459/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a3881f04799d410f7ec70d022179c8d734459/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic.c?ref=b52a3881f04799d410f7ec70d022179c8d734459", "patch": "@@ -69,7 +69,8 @@ _Bool CompareAndSwapInt32 (int32_t *, int32_t, int32_t)\n _Bool\n CompareAndSwapInt32 (int32_t *val, int32_t old, int32_t new)\n {\n-  return __sync_bool_compare_and_swap (val, old, new);\n+  return __atomic_compare_exchange_n (val, &old, new, true, __ATOMIC_SEQ_CST,\n+\t\t\t\t      __ATOMIC_RELAXED);\n }\n \n _Bool CompareAndSwapInt64 (int64_t *, int64_t, int64_t)\n@@ -81,7 +82,8 @@ CompareAndSwapInt64 (int64_t *val, int64_t old, int64_t new)\n {\n   if (((uintptr_t) val & 7) != 0)\n     val = NULL;\n-  return __sync_bool_compare_and_swap (val, old, new);\n+  return __atomic_compare_exchange_n (val, &old, new, true, __ATOMIC_SEQ_CST,\n+\t\t\t\t      __ATOMIC_RELAXED);\n }\n \n _Bool CompareAndSwapUint32 (uint32_t *, uint32_t, uint32_t)\n@@ -91,7 +93,8 @@ _Bool CompareAndSwapUint32 (uint32_t *, uint32_t, uint32_t)\n _Bool\n CompareAndSwapUint32 (uint32_t *val, uint32_t old, uint32_t new)\n {\n-  return __sync_bool_compare_and_swap (val, old, new);\n+  return __atomic_compare_exchange_n (val, &old, new, true, __ATOMIC_SEQ_CST,\n+\t\t\t\t      __ATOMIC_RELAXED);\n }\n \n _Bool CompareAndSwapUint64 (uint64_t *, uint64_t, uint64_t)\n@@ -103,7 +106,8 @@ CompareAndSwapUint64 (uint64_t *val, uint64_t old, uint64_t new)\n {\n   if (((uintptr_t) val & 7) != 0)\n     val = NULL;\n-  return __sync_bool_compare_and_swap (val, old, new);\n+  return __atomic_compare_exchange_n (val, &old, new, true, __ATOMIC_SEQ_CST,\n+\t\t\t\t      __ATOMIC_RELAXED);\n }\n \n _Bool CompareAndSwapUintptr (uintptr_t *, uintptr_t, uintptr_t)\n@@ -113,7 +117,8 @@ _Bool CompareAndSwapUintptr (uintptr_t *, uintptr_t, uintptr_t)\n _Bool\n CompareAndSwapUintptr (uintptr_t *val, uintptr_t old, uintptr_t new)\n {\n-  return __sync_bool_compare_and_swap (val, old, new);\n+  return __atomic_compare_exchange_n (val, &old, new, true, __ATOMIC_SEQ_CST,\n+\t\t\t\t      __ATOMIC_RELAXED);\n }\n \n int32_t AddInt32 (int32_t *, int32_t)\n@@ -123,7 +128,7 @@ int32_t AddInt32 (int32_t *, int32_t)\n int32_t\n AddInt32 (int32_t *val, int32_t delta)\n {\n-  return __sync_add_and_fetch (val, delta);\n+  return __atomic_add_fetch (val, delta, __ATOMIC_SEQ_CST);\n }\n \n uint32_t AddUint32 (uint32_t *, uint32_t)\n@@ -133,7 +138,7 @@ uint32_t AddUint32 (uint32_t *, uint32_t)\n uint32_t\n AddUint32 (uint32_t *val, uint32_t delta)\n {\n-  return __sync_add_and_fetch (val, delta);\n+  return __atomic_add_fetch (val, delta, __ATOMIC_SEQ_CST);\n }\n \n int64_t AddInt64 (int64_t *, int64_t)\n@@ -145,7 +150,7 @@ AddInt64 (int64_t *val, int64_t delta)\n {\n   if (((uintptr_t) val & 7) != 0)\n     val = NULL;\n-  return __sync_add_and_fetch (val, delta);\n+  return __atomic_add_fetch (val, delta, __ATOMIC_SEQ_CST);\n }\n \n uint64_t AddUint64 (uint64_t *, uint64_t)\n@@ -157,7 +162,7 @@ AddUint64 (uint64_t *val, uint64_t delta)\n {\n   if (((uintptr_t) val & 7) != 0)\n     val = NULL;\n-  return __sync_add_and_fetch (val, delta);\n+  return __atomic_add_fetch (val, delta, __ATOMIC_SEQ_CST);\n }\n \n uintptr_t AddUintptr (uintptr_t *, uintptr_t)\n@@ -167,7 +172,7 @@ uintptr_t AddUintptr (uintptr_t *, uintptr_t)\n uintptr_t\n AddUintptr (uintptr_t *val, uintptr_t delta)\n {\n-  return __sync_add_and_fetch (val, delta);\n+  return __atomic_add_fetch (val, delta, __ATOMIC_SEQ_CST);\n }\n \n int32_t LoadInt32 (int32_t *addr)\n@@ -177,12 +182,7 @@ int32_t LoadInt32 (int32_t *addr)\n int32_t\n LoadInt32 (int32_t *addr)\n {\n-  int32_t v;\n-\n-  v = *addr;\n-  while (! __sync_bool_compare_and_swap (addr, v, v))\n-    v = *addr;\n-  return v;\n+  return __atomic_load_n (addr, __ATOMIC_SEQ_CST);\n }\n \n int64_t LoadInt64 (int64_t *addr)\n@@ -192,14 +192,9 @@ int64_t LoadInt64 (int64_t *addr)\n int64_t\n LoadInt64 (int64_t *addr)\n {\n-  int64_t v;\n-\n   if (((uintptr_t) addr & 7) != 0)\n     panicmem ();\n-  v = *addr;\n-  while (! __sync_bool_compare_and_swap (addr, v, v))\n-    v = *addr;\n-  return v;\n+  return __atomic_load_n (addr, __ATOMIC_SEQ_CST);\n }\n \n uint32_t LoadUint32 (uint32_t *addr)\n@@ -209,12 +204,7 @@ uint32_t LoadUint32 (uint32_t *addr)\n uint32_t\n LoadUint32 (uint32_t *addr)\n {\n-  uint32_t v;\n-\n-  v = *addr;\n-  while (! __sync_bool_compare_and_swap (addr, v, v))\n-    v = *addr;\n-  return v;\n+  return __atomic_load_n (addr, __ATOMIC_SEQ_CST);\n }\n \n uint64_t LoadUint64 (uint64_t *addr)\n@@ -224,14 +214,9 @@ uint64_t LoadUint64 (uint64_t *addr)\n uint64_t\n LoadUint64 (uint64_t *addr)\n {\n-  uint64_t v;\n-\n   if (((uintptr_t) addr & 7) != 0)\n     panicmem ();\n-  v = *addr;\n-  while (! __sync_bool_compare_and_swap (addr, v, v))\n-    v = *addr;\n-  return v;\n+  return __atomic_load_n (addr, __ATOMIC_SEQ_CST);\n }\n \n uintptr_t LoadUintptr (uintptr_t *addr)\n@@ -241,12 +226,7 @@ uintptr_t LoadUintptr (uintptr_t *addr)\n uintptr_t\n LoadUintptr (uintptr_t *addr)\n {\n-  uintptr_t v;\n-\n-  v = *addr;\n-  while (! __sync_bool_compare_and_swap (addr, v, v))\n-    v = *addr;\n-  return v;\n+  return __atomic_load_n (addr, __ATOMIC_SEQ_CST);\n }\n \n void *LoadPointer (void **addr)\n@@ -256,12 +236,7 @@ void *LoadPointer (void **addr)\n void *\n LoadPointer (void **addr)\n {\n-  void *v;\n-\n-  v = *addr;\n-  while (! __sync_bool_compare_and_swap (addr, v, v))\n-    v = *addr;\n-  return v;\n+  return __atomic_load_n (addr, __ATOMIC_SEQ_CST);\n }\n \n void StoreInt32 (int32_t *addr, int32_t val)\n@@ -271,11 +246,7 @@ void StoreInt32 (int32_t *addr, int32_t val)\n void\n StoreInt32 (int32_t *addr, int32_t val)\n {\n-  int32_t v;\n-\n-  v = *addr;\n-  while (! __sync_bool_compare_and_swap (addr, v, val))\n-    v = *addr;\n+  __atomic_store_n (addr, val, __ATOMIC_SEQ_CST);\n }\n \n void StoreInt64 (int64_t *addr, int64_t val)\n@@ -285,13 +256,9 @@ void StoreInt64 (int64_t *addr, int64_t val)\n void\n StoreInt64 (int64_t *addr, int64_t val)\n {\n-  int64_t v;\n-\n   if (((uintptr_t) addr & 7) != 0)\n     panicmem ();\n-  v = *addr;\n-  while (! __sync_bool_compare_and_swap (addr, v, val))\n-    v = *addr;\n+  __atomic_store_n (addr, val, __ATOMIC_SEQ_CST);\n }\n \n void StoreUint32 (uint32_t *addr, uint32_t val)\n@@ -301,11 +268,7 @@ void StoreUint32 (uint32_t *addr, uint32_t val)\n void\n StoreUint32 (uint32_t *addr, uint32_t val)\n {\n-  uint32_t v;\n-\n-  v = *addr;\n-  while (! __sync_bool_compare_and_swap (addr, v, val))\n-    v = *addr;\n+  __atomic_store_n (addr, val, __ATOMIC_SEQ_CST);\n }\n \n void StoreUint64 (uint64_t *addr, uint64_t val)\n@@ -315,13 +278,9 @@ void StoreUint64 (uint64_t *addr, uint64_t val)\n void\n StoreUint64 (uint64_t *addr, uint64_t val)\n {\n-  uint64_t v;\n-\n   if (((uintptr_t) addr & 7) != 0)\n     panicmem ();\n-  v = *addr;\n-  while (! __sync_bool_compare_and_swap (addr, v, val))\n-    v = *addr;\n+  __atomic_store_n (addr, val, __ATOMIC_SEQ_CST);\n }\n \n void StoreUintptr (uintptr_t *addr, uintptr_t val)\n@@ -331,9 +290,5 @@ void StoreUintptr (uintptr_t *addr, uintptr_t val)\n void\n StoreUintptr (uintptr_t *addr, uintptr_t val)\n {\n-  uintptr_t v;\n-\n-  v = *addr;\n-  while (! __sync_bool_compare_and_swap (addr, v, val))\n-    v = *addr;\n+  __atomic_store_n (addr, val, __ATOMIC_SEQ_CST);\n }"}, {"sha": "7571c64ddc4c4730a6a863495f62dc83174a3bef", "filename": "libgo/go/sync/cas.c", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a53a893b4fe04ec966a4ec178ee8f394426a5dad/libgo%2Fgo%2Fsync%2Fcas.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a53a893b4fe04ec966a4ec178ee8f394426a5dad/libgo%2Fgo%2Fsync%2Fcas.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fcas.c?ref=a53a893b4fe04ec966a4ec178ee8f394426a5dad", "patch": "@@ -1,17 +0,0 @@\n-/* cas.c -- implement sync.cas for Go.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <stdint.h>\n-\n-#include \"runtime.h\"\n-\n-_Bool cas (int32_t *, int32_t, int32_t) __asm__ (GOSYM_PREFIX \"libgo_sync.sync.cas\");\n-\n-_Bool\n-cas (int32_t *ptr, int32_t old, int32_t new)\n-{\n-  return __sync_bool_compare_and_swap (ptr, old, new);\n-}"}, {"sha": "f0809d35d8091ec434ceb80c7a4ba25fbb71425c", "filename": "libgo/misc/cgo/test/issue7978.go", "status": "modified", "additions": 5, "deletions": 23, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a3881f04799d410f7ec70d022179c8d734459/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue7978.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a3881f04799d410f7ec70d022179c8d734459/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue7978.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue7978.go?ref=b52a3881f04799d410f7ec70d022179c8d734459", "patch": "@@ -12,33 +12,18 @@ package cgotest\n \n void issue7978cb(void);\n \n-#if defined(__APPLE__) && defined(__arm__)\n-// on Darwin/ARM, libSystem doesn't provide implementation of the __sync_fetch_and_add\n-// primitive, and although gcc supports it, it doesn't inline its definition.\n-// Clang could inline its definition, so we require clang on Darwin/ARM.\n-#if defined(__clang__)\n-#define HAS_SYNC_FETCH_AND_ADD 1\n-#else\n-#define HAS_SYNC_FETCH_AND_ADD 0\n-#endif\n-#else\n-#define HAS_SYNC_FETCH_AND_ADD 1\n-#endif\n-\n // use ugly atomic variable sync since that doesn't require calling back into\n // Go code or OS dependencies\n static void issue7978c(uint32_t *sync) {\n-#if HAS_SYNC_FETCH_AND_ADD\n-\twhile(__sync_fetch_and_add(sync, 0) != 0)\n+\twhile(__atomic_load_n(sync, __ATOMIC_SEQ_CST) != 0)\n \t\t;\n-\t__sync_fetch_and_add(sync, 1);\n-\twhile(__sync_fetch_and_add(sync, 0) != 2)\n+\t__atomic_add_fetch(sync, 1, __ATOMIC_SEQ_CST);\n+\twhile(__atomic_load_n(sync, __ATOMIC_SEQ_CST) != 2)\n \t\t;\n \tissue7978cb();\n-\t__sync_fetch_and_add(sync, 1);\n-\twhile(__sync_fetch_and_add(sync, 0) != 6)\n+\t__atomic_add_fetch(sync, 1, __ATOMIC_SEQ_CST);\n+\twhile(__atomic_load_n(sync, __ATOMIC_SEQ_CST) != 6)\n \t\t;\n-#endif\n }\n */\n import \"C\"\n@@ -111,9 +96,6 @@ func test7978(t *testing.T) {\n \tif runtime.Compiler == \"gccgo\" {\n \t\tt.Skip(\"gccgo can not do stack traces of C code\")\n \t}\n-\tif C.HAS_SYNC_FETCH_AND_ADD == 0 {\n-\t\tt.Skip(\"clang required for __sync_fetch_and_add support on darwin/arm\")\n-\t}\n \tdebug.SetTraceback(\"2\")\n \tissue7978sync = 0\n \tgo issue7978go()"}, {"sha": "5da34fbc4a3c58e3d0d0cc68c5145152a0bd739e", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b52a3881f04799d410f7ec70d022179c8d734459/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b52a3881f04799d410f7ec70d022179c8d734459/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=b52a3881f04799d410f7ec70d022179c8d734459", "patch": "@@ -276,22 +276,8 @@ int32\truntime_timediv(int64, int32, int32*)\n int32\truntime_round2(int32 x); // round x up to a power of 2.\n \n // atomic operations\n-#define runtime_cas(pval, old, new) __sync_bool_compare_and_swap (pval, old, new)\n-#define runtime_cas64(pval, old, new) __sync_bool_compare_and_swap (pval, old, new)\n-#define runtime_casp(pval, old, new) __sync_bool_compare_and_swap (pval, old, new)\n-// Don't confuse with XADD x86 instruction,\n-// this one is actually 'addx', that is, add-and-fetch.\n-#define runtime_xadd(p, v) __sync_add_and_fetch (p, v)\n-#define runtime_xadd64(p, v) __sync_add_and_fetch (p, v)\n-#define runtime_xchg(p, v) __atomic_exchange_n (p, v, __ATOMIC_SEQ_CST)\n-#define runtime_xchg64(p, v) __atomic_exchange_n (p, v, __ATOMIC_SEQ_CST)\n-#define runtime_xchgp(p, v) __atomic_exchange_n (p, v, __ATOMIC_SEQ_CST)\n+#define runtime_xadd(p, v) __atomic_add_fetch (p, v, __ATOMIC_SEQ_CST)\n #define runtime_atomicload(p) __atomic_load_n (p, __ATOMIC_SEQ_CST)\n-#define runtime_atomicstore(p, v) __atomic_store_n (p, v, __ATOMIC_SEQ_CST)\n-#define runtime_atomicstore64(p, v) __atomic_store_n (p, v, __ATOMIC_SEQ_CST)\n-#define runtime_atomicload64(p) __atomic_load_n (p, __ATOMIC_SEQ_CST)\n-#define runtime_atomicloadp(p) __atomic_load_n (p, __ATOMIC_SEQ_CST)\n-#define runtime_atomicstorep(p, v) __atomic_store_n (p, v, __ATOMIC_SEQ_CST)\n \n void runtime_setg(G*)\n   __asm__ (GOSYM_PREFIX \"runtime.setg\");"}, {"sha": "83ee006b555c18b396429849ab79facc68a8d7c4", "filename": "libgo/runtime/thread.c", "status": "removed", "additions": 0, "deletions": 161, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a53a893b4fe04ec966a4ec178ee8f394426a5dad/libgo%2Fruntime%2Fthread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a53a893b4fe04ec966a4ec178ee8f394426a5dad/libgo%2Fruntime%2Fthread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fthread.c?ref=a53a893b4fe04ec966a4ec178ee8f394426a5dad", "patch": "@@ -1,161 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-#include <errno.h>\n-#include <signal.h>\n-#include <sys/time.h>\n-#include <sys/resource.h>\n-\n-#include \"runtime.h\"\n-#include \"go-assert.h\"\n-\n-/* For targets which don't have the required sync support.  Really\n-   these should be provided by gcc itself.  FIXME.  */\n-\n-#if !defined (HAVE_SYNC_BOOL_COMPARE_AND_SWAP_4) || !defined (HAVE_SYNC_BOOL_COMPARE_AND_SWAP_8) || !defined (HAVE_SYNC_FETCH_AND_ADD_4) || !defined (HAVE_SYNC_ADD_AND_FETCH_8)\n-\n-static pthread_mutex_t sync_lock = PTHREAD_MUTEX_INITIALIZER;\n-\n-#endif\n-\n-#ifndef HAVE_SYNC_BOOL_COMPARE_AND_SWAP_4\n-\n-_Bool\n-__sync_bool_compare_and_swap_4 (uint32*, uint32, uint32)\n-  __attribute__ ((visibility (\"hidden\")));\n-\n-_Bool\n-__sync_bool_compare_and_swap_4 (uint32* ptr, uint32 old, uint32 new)\n-{\n-  int i;\n-  _Bool ret;\n-\n-  i = pthread_mutex_lock (&sync_lock);\n-  __go_assert (i == 0);\n-\n-  if (*ptr != old)\n-    ret = 0;\n-  else\n-    {\n-      *ptr = new;\n-      ret = 1;\n-    }\n-\n-  i = pthread_mutex_unlock (&sync_lock);\n-  __go_assert (i == 0);\n-\n-  return ret;\n-}\n-\n-#endif\n-\n-#ifndef HAVE_SYNC_BOOL_COMPARE_AND_SWAP_8\n-\n-_Bool\n-__sync_bool_compare_and_swap_8 (uint64*, uint64, uint64)\n-  __attribute__ ((visibility (\"hidden\")));\n-\n-_Bool\n-__sync_bool_compare_and_swap_8 (uint64* ptr, uint64 old, uint64 new)\n-{\n-  int i;\n-  _Bool ret;\n-\n-  i = pthread_mutex_lock (&sync_lock);\n-  __go_assert (i == 0);\n-\n-  if (*ptr != old)\n-    ret = 0;\n-  else\n-    {\n-      *ptr = new;\n-      ret = 1;\n-    }\n-\n-  i = pthread_mutex_unlock (&sync_lock);\n-  __go_assert (i == 0);\n-\n-  return ret;\n-}\n-\n-#endif\n-\n-#ifndef HAVE_SYNC_FETCH_AND_ADD_4\n-\n-uint32\n-__sync_fetch_and_add_4 (uint32*, uint32)\n-  __attribute__ ((visibility (\"hidden\")));\n-\n-uint32\n-__sync_fetch_and_add_4 (uint32* ptr, uint32 add)\n-{\n-  int i;\n-  uint32 ret;\n-\n-  i = pthread_mutex_lock (&sync_lock);\n-  __go_assert (i == 0);\n-\n-  ret = *ptr;\n-  *ptr += add;\n-\n-  i = pthread_mutex_unlock (&sync_lock);\n-  __go_assert (i == 0);\n-\n-  return ret;\n-}\n-\n-#endif\n-\n-#ifndef HAVE_SYNC_ADD_AND_FETCH_8\n-\n-uint64\n-__sync_add_and_fetch_8 (uint64*, uint64)\n-  __attribute__ ((visibility (\"hidden\")));\n-\n-uint64\n-__sync_add_and_fetch_8 (uint64* ptr, uint64 add)\n-{\n-  int i;\n-  uint64 ret;\n-\n-  i = pthread_mutex_lock (&sync_lock);\n-  __go_assert (i == 0);\n-\n-  *ptr += add;\n-  ret = *ptr;\n-\n-  i = pthread_mutex_unlock (&sync_lock);\n-  __go_assert (i == 0);\n-\n-  return ret;\n-}\n-\n-#endif\n-\n-uintptr\n-runtime_memlimit(void)\n-{\n-\tstruct rlimit rl;\n-\tuintptr used;\n-\n-\tif(getrlimit(RLIMIT_AS, &rl) != 0)\n-\t\treturn 0;\n-\tif(rl.rlim_cur >= 0x7fffffff)\n-\t\treturn 0;\n-\n-\t// Estimate our VM footprint excluding the heap.\n-\t// Not an exact science: use size of binary plus\n-\t// some room for thread stacks.\n-\tused = (64<<20);\n-\tif(used >= rl.rlim_cur)\n-\t\treturn 0;\n-\n-\t// If there's not at least 16 MB left, we're probably\n-\t// not going to be able to do much.  Treat as no limit.\n-\trl.rlim_cur -= used;\n-\tif(rl.rlim_cur < (16<<20))\n-\t\treturn 0;\n-\n-\treturn rl.rlim_cur - used;\n-}"}]}