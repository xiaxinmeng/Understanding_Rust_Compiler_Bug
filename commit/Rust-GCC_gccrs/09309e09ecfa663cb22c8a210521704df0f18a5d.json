{"sha": "09309e09ecfa663cb22c8a210521704df0f18a5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDkzMDllMDllY2ZhNjYzY2IyMmM4YTIxMDUyMTcwNGRmMGYxOGE1ZA==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2016-08-19T14:19:51Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2016-08-19T14:19:51Z"}, "message": "Use a XOR cipher instead of byte shuffling to protect against bad seeds.\n\nlibgfortran:\n2016-08-19  Janne Blomqvist  <jb@gcc.gnu.org>\n\n        * intrinsics/random.c (xor_keys): New array with \"secret\" keys.\n        (scramble_seed): XOR given seed with xor_keys array rather than\n        shuffling bytes.\n        (unscramble_seed): Remove function.\n        (random_seed_i4): Use new scramble_seed.\n        (random_seed_i8): Likewise.\n\nfrontend:\n2016-08-19  Janne Blomqvist  <jb@gcc.gnu.org>\n\n        * intrinsics.texi (RANDOM_NUMBER): Remove reference to\n        init_random_seed in example.\n        (RANDOM_SEED): Remove warning to not set all seed values to 0.\n\nFrom-SVN: r239613", "tree": {"sha": "90867836565b9d525c6d273b63d2397a7a3ebed6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90867836565b9d525c6d273b63d2397a7a3ebed6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09309e09ecfa663cb22c8a210521704df0f18a5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09309e09ecfa663cb22c8a210521704df0f18a5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09309e09ecfa663cb22c8a210521704df0f18a5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09309e09ecfa663cb22c8a210521704df0f18a5d/comments", "author": null, "committer": null, "parents": [{"sha": "91151a7334543817f1f790310a1bfc4589889cad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91151a7334543817f1f790310a1bfc4589889cad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91151a7334543817f1f790310a1bfc4589889cad"}], "stats": {"total": 74, "additions": 47, "deletions": 27}, "files": [{"sha": "cfc70c1b9e85a988898b351095ffe344a9993f10", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09309e09ecfa663cb22c8a210521704df0f18a5d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09309e09ecfa663cb22c8a210521704df0f18a5d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=09309e09ecfa663cb22c8a210521704df0f18a5d", "patch": "@@ -1,3 +1,9 @@\n+2016-08-19  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+        * intrinsics.texi (RANDOM_NUMBER): Remove reference to\n+        init_random_seed in example.\n+        (RANDOM_SEED): Remove warning to not set all seed values to 0.\n+\n 2016-08-18  David Malcolm  <dmalcolm@redhat.com>\n \n \t* error.c (gfc_diagnostic_starter): Update for change to"}, {"sha": "8cca9b162bfe1e4479a8e94c7d39c87c87bdf4cc", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09309e09ecfa663cb22c8a210521704df0f18a5d/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09309e09ecfa663cb22c8a210521704df0f18a5d/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=09309e09ecfa663cb22c8a210521704df0f18a5d", "patch": "@@ -11155,7 +11155,6 @@ Subroutine\n @smallexample\n program test_random_number\n   REAL :: r(5,5)\n-  CALL init_random_seed()         ! see example of RANDOM_SEED\n   CALL RANDOM_NUMBER(r)\n end program\n @end smallexample\n@@ -11192,9 +11191,6 @@ alias any other stream in the system, where @var{N} is the number of\n threads that have used @code{RANDOM_NUMBER} so far during the program\n execution.\n \n-Note that setting any of the seed values to zero should be avoided as\n-it can result in poor quality random numbers being generated.\n-\n @item @emph{Standard}:\n Fortran 95 and later\n "}, {"sha": "10dc07af130fa9e13e2899ff62763d16858bad5b", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09309e09ecfa663cb22c8a210521704df0f18a5d/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09309e09ecfa663cb22c8a210521704df0f18a5d/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=09309e09ecfa663cb22c8a210521704df0f18a5d", "patch": "@@ -1,4 +1,13 @@\n-2016-08-16  Janne Blomqvist  <jb@gcc.gnu.org>\n+2016-08-19  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+        * intrinsics/random.c (xor_keys): New array with \"secret\" keys.\n+        (scramble_seed): XOR given seed with xor_keys array rather than\n+        shuffling bytes.\n+        (unscramble_seed): Remove function.\n+        (random_seed_i4): Use new scramble_seed.\n+        (random_seed_i8): Likewise.\n+\n+2016-08-19  Janne Blomqvist  <jb@gcc.gnu.org>\n \n         * intrinsics/random.c (master_init): New variable.\n         (init_rand_state): Move below getosrandom (), maybe initialize"}, {"sha": "739dbeb1e9862f1fd5411d4ed6cec5f28ac8229e", "filename": "libgfortran/intrinsics/random.c", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09309e09ecfa663cb22c8a210521704df0f18a5d/libgfortran%2Fintrinsics%2Frandom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09309e09ecfa663cb22c8a210521704df0f18a5d/libgfortran%2Fintrinsics%2Frandom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Frandom.c?ref=09309e09ecfa663cb22c8a210521704df0f18a5d", "patch": "@@ -722,36 +722,41 @@ arandom_r16 (gfc_array_r16 *x)\n #endif\n \n \n+/* Number of elements in master_state array.  */\n+#define SZU64 (sizeof (master_state) / sizeof (uint64_t))\n \n-static void\n-scramble_seed (unsigned char *dest, unsigned char *src, int size)\n-{\n-  int i;\n \n-  for (i = 0; i < size; i++)\n-    dest[(i % 2) * (size / 2) + i / 2] = src[i];\n-}\n+/* Keys for scrambling the seed in order to avoid poor seeds.  */\n \n+static const uint64_t xor_keys[] = {\n+  0xbd0c5b6e50c2df49ULL, 0xd46061cd46e1df38ULL, 0xbb4f4d4ed6103544ULL,\n+  0x114a583d0756ad39ULL, 0x4b5ad8623d0aaab6ULL, 0x3f2ed7afbe0c0f21ULL,\n+  0xdec83fd65f113445ULL, 0x3824f8fbc4f10d24ULL, 0x5d9025af05878911ULL,\n+  0x500bc46b540340e9ULL, 0x8bd53298e0d00530ULL, 0x57886e40a952e06aULL,\n+  0x926e76c88e31cdb6ULL, 0xbd0724dac0a3a5f9ULL, 0xc5c8981b858ab796ULL,\n+  0xbb12ab2694c2b32cULL\n+};\n+\n+\n+/* Since a XOR cipher is symmetric, we need only one routine, and we\n+   can use it both for encryption and decryption.  */\n \n static void\n-unscramble_seed (unsigned char *dest, unsigned char *src, int size)\n+scramble_seed (uint64_t *dest, const uint64_t *src)\n {\n-  int i;\n-\n-  for (i = 0; i < size; i++)\n-    dest[i] = src[(i % 2) * (size / 2) + i / 2];\n+  for (int i = 0; i < (int) SZU64; i++)\n+    dest[i] = src[i] ^ xor_keys[i];\n }\n \n \n-\n /* random_seed is used to seed the PRNG with either a default\n    set of seeds or user specified set of seeds.  random_seed\n    must be called with no argument or exactly one argument.  */\n \n void\n random_seed_i4 (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n {\n-  unsigned char seed[sizeof (master_state)];\n+  uint64_t seed[SZU64];\n #define SZ (sizeof (master_state) / sizeof (GFC_INTEGER_4))\n \n   /* Check that we only have one argument present.  */\n@@ -778,12 +783,12 @@ random_seed_i4 (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n \tinit_rand_state (rs, false);\n \n       /* Unscramble the seed.  */\n-      unscramble_seed (seed, (unsigned char *) rs->s, sizeof seed);\n+      scramble_seed (seed, rs->s);\n \n       /*  Then copy it back to the user variable.  */\n       for (size_t i = 0; i < SZ ; i++)\n \tmemcpy (&(get->base_addr[(SZ - 1 - i) * GFC_DESCRIPTOR_STRIDE(get,0)]),\n-               seed + i * sizeof(GFC_UINTEGER_4),\n+\t\t(unsigned char*) seed + i * sizeof(GFC_UINTEGER_4),\n                sizeof(GFC_UINTEGER_4));\n \n       /* Finally copy the value of p after the seed.  */\n@@ -814,22 +819,20 @@ random_seed_i4 (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n \n       /*  We copy the seed given by the user.  */\n       for (size_t i = 0; i < SZ; i++)\n-\tmemcpy (seed + i * sizeof(GFC_UINTEGER_4),\n+\tmemcpy ((unsigned char*) seed + i * sizeof(GFC_UINTEGER_4),\n \t\t&(put->base_addr[(SZ - 1 - i) * GFC_DESCRIPTOR_STRIDE(put,0)]),\n \t\tsizeof(GFC_UINTEGER_4));\n \n       /* We put it after scrambling the bytes, to paper around users who\n \t provide seeds with quality only in the lower or upper part.  */\n-      scramble_seed ((unsigned char *) master_state, seed, sizeof seed);\n+      scramble_seed (master_state, seed);\n       njumps = 0;\n       master_init = true;\n       init_rand_state (rs, true);\n \n       rs->p = put->base_addr[SZ * GFC_DESCRIPTOR_STRIDE(put, 0)] & 15;\n     }\n \n-\n-\n   __gthread_mutex_unlock (&random_lock);\n     }\n #undef SZ\n@@ -840,6 +843,8 @@ iexport(random_seed_i4);\n void\n random_seed_i8 (GFC_INTEGER_8 *size, gfc_array_i8 *put, gfc_array_i8 *get)\n {\n+  uint64_t seed[SZU64];\n+\n   /* Check that we only have one argument present.  */\n   if ((size ? 1 : 0) + (put ? 1 : 0) + (get ? 1 : 0) > 1)\n     runtime_error (\"RANDOM_SEED should have at most one argument present.\");\n@@ -864,9 +869,12 @@ random_seed_i8 (GFC_INTEGER_8 *size, gfc_array_i8 *put, gfc_array_i8 *get)\n       if (!rs->init)\n \tinit_rand_state (rs, false);\n \n+      /* Unscramble the seed.  */\n+      scramble_seed (seed, rs->s);\n+\n       /*  This code now should do correct strides.  */\n       for (size_t i = 0; i < SZ; i++)\n-\tmemcpy (&(get->base_addr[i * GFC_DESCRIPTOR_STRIDE(get,0)]), &rs->s[i],\n+\tmemcpy (&(get->base_addr[i * GFC_DESCRIPTOR_STRIDE(get,0)]), &seed[i],\n \t\tsizeof (GFC_UINTEGER_8));\n \n       get->base_addr[SZ * GFC_DESCRIPTOR_STRIDE(get, 0)] = rs->p;\n@@ -896,9 +904,10 @@ random_seed_i8 (GFC_INTEGER_8 *size, gfc_array_i8 *put, gfc_array_i8 *get)\n \n       /*  This code now should do correct strides.  */\n       for (size_t i = 0; i < SZ; i++)\n-\tmemcpy (&master_state[i], &(put->base_addr[i * GFC_DESCRIPTOR_STRIDE(put,0)]),\n+\tmemcpy (&seed[i], &(put->base_addr[i * GFC_DESCRIPTOR_STRIDE(put,0)]),\n \t\tsizeof (GFC_UINTEGER_8));\n \n+      scramble_seed (master_state, seed);\n       njumps = 0;\n       master_init = true;\n       init_rand_state (rs, true);"}]}