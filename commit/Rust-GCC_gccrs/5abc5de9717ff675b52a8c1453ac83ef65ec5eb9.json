{"sha": "5abc5de9717ff675b52a8c1453ac83ef65ec5eb9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFiYzVkZTk3MTdmZjY3NWI1MmE4YzE0NTNhYzgzZWY2NWVjNWViOQ==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2007-05-30T17:07:58Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2007-05-30T17:07:58Z"}, "message": "genrecog.c: Include regs.h in generated file.\n\n2007-05-30  Eric Christopher  <echristo@gmail.com>\n\n\t* genrecog.c: Include regs.h in generated file.\n\t* genemit.c: Ditto. Fix up formatting.\n\t* config/mn10300/constraints.md: New.\n\t* config/mn10300/mn10300.md: Include.\n\t* config/mn10300/mn10300.c(mn10300_secondary_reload_class):\n\tFix up for removed macro.\n\t* config/mn10300/predicates.md (call_address_operand):  Ditto.\n\t* config/mn10300/mn10300.h (REG_CLASS_FROM_LETTER): Delete.\n\t(CONST_OK_FOR_I): Ditto.\n\t(CONST_OK_FOR_J): Ditto.\n\t(CONST_OK_FOR_K): Ditto.\n\t(CONST_OK_FOR_L): Ditto.\n\t(CONST_OK_FOR_M): Ditto.\n\t(CONST_OK_FOR_N): Ditto.\n\t(CONST_DOUBLE_OK_FOR_LETTER_P): Ditto.\n\t(OK_FOR_Q): Ditto.\n\t(OK_FOR_R): Ditto.\n\t(OK_FOR_T): Ditto.\n\t(EXTRA_CONSTRAINT): Ditto.\n\nFrom-SVN: r125192", "tree": {"sha": "3b9aef34a6b628dab5cc6f58b4996f9ad460c29e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b9aef34a6b628dab5cc6f58b4996f9ad460c29e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5abc5de9717ff675b52a8c1453ac83ef65ec5eb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5abc5de9717ff675b52a8c1453ac83ef65ec5eb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5abc5de9717ff675b52a8c1453ac83ef65ec5eb9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5abc5de9717ff675b52a8c1453ac83ef65ec5eb9/comments", "author": null, "committer": null, "parents": [{"sha": "9dd3cc811b08e532cef582472222f2543e980940", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dd3cc811b08e532cef582472222f2543e980940", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dd3cc811b08e532cef582472222f2543e980940"}], "stats": {"total": 310, "additions": 185, "deletions": 125}, "files": [{"sha": "1d68df0d2dea62ea5df8e18e9eb3e9f328ca8980", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5abc5de9717ff675b52a8c1453ac83ef65ec5eb9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5abc5de9717ff675b52a8c1453ac83ef65ec5eb9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5abc5de9717ff675b52a8c1453ac83ef65ec5eb9", "patch": "@@ -1,3 +1,25 @@\n+2007-05-30  Eric Christopher  <echristo@gmail.com>\n+\n+\t* genrecog.c: Include regs.h in generated file.\n+\t* genemit.c: Ditto. Fix up formatting.\n+\t* config/mn10300/constraints.md: New.\n+\t* config/mn10300/mn10300.md: Include.\n+\t* config/mn10300/mn10300.c(mn10300_secondary_reload_class):\n+\tFix up for removed macro.\n+\t* config/mn10300/predicates.md (call_address_operand):  Ditto.\n+\t* config/mn10300/mn10300.h (REG_CLASS_FROM_LETTER): Delete.\n+\t(CONST_OK_FOR_I): Ditto.\n+\t(CONST_OK_FOR_J): Ditto.\n+\t(CONST_OK_FOR_K): Ditto.\n+\t(CONST_OK_FOR_L): Ditto.\n+\t(CONST_OK_FOR_M): Ditto.\n+\t(CONST_OK_FOR_N): Ditto.\n+\t(CONST_DOUBLE_OK_FOR_LETTER_P): Ditto.\n+\t(OK_FOR_Q): Ditto.\n+\t(OK_FOR_R): Ditto.\n+\t(OK_FOR_T): Ditto.\n+\t(EXTRA_CONSTRAINT): Ditto.\n+\n 2007-05-30 Uros Bizjak <ubizjak@gmail.com>\n \n \t* config/i386/i386.h (MASK_64BIT, MASK_MMX, MASK_3DNOW*, MASK_SSE*):\n@@ -97,7 +119,7 @@\n \tNOTE_INSN_PROLOGUE_END at beginning of the thunk.\n \n 2007-05-29  Hui-May Chang  <hm.chang@apple.com>\n-\t* config/i386/i386.c (ix86_function_regparm): Added checking of \n+\t* config/i386/i386.c (ix86_function_regparm): Added checking of\n \tix86_force_align_arg_pointer to determine the number of\n \tregister parameters.\n \n@@ -199,9 +221,9 @@\n \t* target/i386/i386.c (ix86_expand_vector_move): Expand unaligned\n \tmemory access via x86_expand_vector_move_misalign() only for\n \tTImode values on 32-bit targets.\n-\t\n-2007-05-28  Razya Ladelsky  <razya@il.ibm.com>  \n-        \n+\n+2007-05-28  Razya Ladelsky  <razya@il.ibm.com>\n+\n \t* matrix-reorg.c: New file. Implement matrix flattening and\n \ttransposing optimization.\n \t* tree-pass.h: Add matrix reorg pass."}, {"sha": "c6888264965af12d6a8556382f10c58614f1f563", "filename": "gcc/config/mn10300/constraints.md", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5abc5de9717ff675b52a8c1453ac83ef65ec5eb9/gcc%2Fconfig%2Fmn10300%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5abc5de9717ff675b52a8c1453ac83ef65ec5eb9/gcc%2Fconfig%2Fmn10300%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fconstraints.md?ref=5abc5de9717ff675b52a8c1453ac83ef65ec5eb9", "patch": "@@ -0,0 +1,112 @@\n+;; Constraint definitions for the MN10300.\n+;; Copyright (C) 2007 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+;; Boston, MA 02110-1301, USA.\n+\n+(define_register_constraint \"d\" \"DATA_REGS\"\n+  \"A data register.\")\n+\n+(define_register_constraint \"a\" \"ADDRESS_REGS\"\n+  \"An address register.\")\n+\n+(define_register_constraint \"y\" \"SP_REGS\"\n+  \"An SP register (if available).\")\n+\n+(define_register_constraint \"x\" \"TARGET_AM33 ? EXTENDED_REGS : NO_REGS\"\n+  \"An extended register.\")\n+\n+(define_register_constraint \"f\" \"TARGET_AM33_2 ? FP_REGS : NO_REGS\"\n+  \"A floating point register.\")\n+\n+(define_register_constraint \"A\" \"TARGET_AM33_2 ? FP_ACC_REGS : NO_REGS\"\n+  \"A floating point accumulator register.\")\n+\n+(define_memory_constraint \"Q\"\n+  \"@internal\"\n+  (and (match_code \"mem\")\n+       (match_test \"!CONSTANT_ADDRESS_P (XEXP (op, 0))\")))\n+\n+(define_memory_constraint \"R\"\n+  \"@internal\"\n+  (and (match_code \"mem\")\n+       (match_test \"mode == QImode\")\n+       (ior (match_test \"CONSTANT_ADDRESS_P (XEXP (op, 0))\")\n+\t    (and (match_test \"GET_CODE (XEXP (op, 0)) == REG\")\n+\t\t (match_test \"REG_OK_FOR_BIT_BASE_P (XEXP (op, 0))\")\n+\t\t (match_test \"XEXP (op, 0) != stack_pointer_rtx\"))\n+\t    (and (match_test \"GET_CODE (XEXP (op, 0)) == PLUS\")\n+\t\t (match_test \"GET_CODE (XEXP (XEXP (op, 0), 0)) == REG\")\n+\t\t (match_test \"REG_OK_FOR_BIT_BASE_P (XEXP (XEXP (op, 0), 0))\")\n+\t\t (match_test \"XEXP (XEXP (op, 0), 0) != stack_pointer_rtx\")\n+\t\t (match_test \"GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT\")\n+\t\t (match_test \"INT_8_BITS (INTVAL (XEXP (XEXP (op, 0), 1)))\")))))\n+\n+(define_memory_constraint \"T\"\n+  \"@internal\"\n+  (and (match_code \"mem\")\n+       (match_test \"mode == QImode\")\n+       (and (match_test \"GET_CODE (XEXP (op, 0)) == REG\")\n+\t    (match_test \"REG_OK_FOR_BIT_BASE_P (XEXP (op, 0))\")\n+\t    (match_test \"XEXP (op, 0) != stack_pointer_rtx\"))))\n+\n+(define_constraint \"S\"\n+  \"@internal\"\n+  (if_then_else (match_test \"flag_pic\")\n+\t(and (match_test \"GET_CODE (op) == UNSPEC\")\n+\t     (ior (match_test \"XINT (op, 1) == UNSPEC_PLT\")\n+\t\t  (match_test \"XINT (op, 1) == UNSPEC_PIC\")))\n+\t(match_test \"GET_CODE (op) == SYMBOL_REF\")))\n+\n+;; Integer constraints\n+\n+(define_constraint \"I\"\n+  \"An integer zero.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 0\")))\n+\n+(define_constraint \"J\"\n+  \"An integer one.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 1\")))\n+\n+(define_constraint \"K\"\n+  \"An integer two.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 2\")))\n+\n+(define_constraint \"L\"\n+  \"An integer four.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 4\")))\n+\n+(define_constraint \"M\"\n+  \"An integer three.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 3\")))\n+\n+(define_constraint \"N\"\n+  \"An integer of either 255 or 65535.\"\n+  (and (match_code \"const_int\")\n+       (ior (match_test \"ival == 255\")\n+\t    (match_test \"ival == 65535\"))))\n+\n+;; Floating-point constraints\n+(define_constraint \"G\"\n+  \"Floating-point zero.\"\n+  (and (match_code \"const_double\")\n+       (match_test \"op == CONST0_RTX (mode)\")))"}, {"sha": "d7b792445897d588b6d90c7b4f895247503f3b0a", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5abc5de9717ff675b52a8c1453ac83ef65ec5eb9/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5abc5de9717ff675b52a8c1453ac83ef65ec5eb9/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=5abc5de9717ff675b52a8c1453ac83ef65ec5eb9", "patch": "@@ -274,7 +274,7 @@ print_operand (FILE *file, rtx x, int code)\n \telse\n \t  print_operand (file, x, 0);\n \tbreak;\n-     \n+\n       case 'D':\n \tswitch (GET_CODE (x))\n \t  {\n@@ -387,7 +387,7 @@ print_operand (FILE *file, rtx x, int code)\n \t\t      gcc_unreachable ();\n \t\t    case VOIDmode:\n \t\t    case DImode:\n-\t\t      print_operand_address (file, \n+\t\t      print_operand_address (file,\n \t\t\t\t\t     GEN_INT (CONST_DOUBLE_HIGH (x)));\n \t\t      break;\n \t\t    default:\n@@ -882,7 +882,7 @@ expand_prologue (void)\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-\t  \n+\n       /* Now prepare register a0, if we have decided to use it.  */\n       switch (strategy)\n \t{\n@@ -900,11 +900,11 @@ expand_prologue (void)\n \t    emit_insn (gen_addsi3 (reg, reg, GEN_INT (xsize)));\n \t  reg = gen_rtx_POST_INC (SImode, reg);\n \t  break;\n-\t  \n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-      \n+\n       /* Now actually save the FP registers.  */\n       for (i = FIRST_FP_REGNUM; i <= LAST_FP_REGNUM; ++i)\n \tif (regs_ever_live[i] && ! call_used_regs[i])\n@@ -924,7 +924,7 @@ expand_prologue (void)\n \t\t  }\n \t\telse\n \t\t  addr = stack_pointer_rtx;\n-\t\t\n+\n \t\txsize += 4;\n \t      }\n \n@@ -1109,7 +1109,7 @@ expand_epilogue (void)\n \t\t\t\t\t      + REG_SAVE_BYTES - 252)));\n \t      size = 252 - REG_SAVE_BYTES - 4 * num_regs_to_save;\n \t      break;\n-\t      \n+\n \t    case restore_a1:\n \t      reg = gen_rtx_REG (SImode, FIRST_ADDRESS_REGNUM + 1);\n \t      emit_insn (gen_movsi (reg, stack_pointer_rtx));\n@@ -1130,7 +1130,7 @@ expand_epilogue (void)\n \tif (regs_ever_live[i] && ! call_used_regs[i])\n \t  {\n \t    rtx addr;\n-\t    \n+\n \t    if (reg)\n \t      addr = reg;\n \t    else if (size)\n@@ -1167,7 +1167,7 @@ expand_epilogue (void)\n \n      If the stack size + register save area is more than 255 bytes,\n      then the stack must be cut back here since the size + register\n-     save size is too big for a ret/retf instruction. \n+     save size is too big for a ret/retf instruction.\n \n      Else leave it alone, it will be cut back as part of the\n      ret/retf instruction, or there wasn't any stack to begin with.\n@@ -1333,7 +1333,7 @@ store_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n }\n \n /* What (if any) secondary registers are needed to move IN with mode\n-   MODE into a register in register class CLASS. \n+   MODE into a register in register class CLASS.\n \n    We might be able to simplify this.  */\n enum reg_class\n@@ -1380,9 +1380,10 @@ mn10300_secondary_reload_class (enum reg_class class, enum machine_mode mode,\n \treturn DATA_OR_EXTENDED_REGS;\n       return DATA_REGS;\n     }\n- \n+\n   if (TARGET_AM33_2 && class == FP_REGS\n-      && GET_CODE (in) == MEM && ! OK_FOR_Q (in))\n+      && GET_CODE (in) == MEM\n+      && ! (GET_CODE (in) == MEM && !CONSTANT_ADDRESS_P (XEXP (in, 0))))\n     {\n       if (TARGET_AM33)\n \treturn DATA_OR_EXTENDED_REGS;\n@@ -1426,11 +1427,11 @@ initial_offset (int from, int to)\n \treturn (get_frame_size () + REG_SAVE_BYTES\n \t\t+ 4 * fp_regs_to_save ()\n \t\t+ (current_function_outgoing_args_size\n-\t\t   ? current_function_outgoing_args_size + 4 : 0)); \n+\t\t   ? current_function_outgoing_args_size + 4 : 0));\n       else\n \treturn (get_frame_size ()\n \t\t+ (current_function_outgoing_args_size\n-\t\t   ? current_function_outgoing_args_size + 4 : 0)); \n+\t\t   ? current_function_outgoing_args_size + 4 : 0));\n     }\n \n   /* The difference between the frame pointer and stack pointer is the sum\n@@ -1439,7 +1440,7 @@ initial_offset (int from, int to)\n   if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n     return (get_frame_size ()\n \t    + (current_function_outgoing_args_size\n-\t       ? current_function_outgoing_args_size + 4 : 0)); \n+\t       ? current_function_outgoing_args_size + 4 : 0));\n \n   gcc_unreachable ();\n }\n@@ -1624,7 +1625,7 @@ mn10300_function_value (tree valtype, tree func, int outgoing)\n     = gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t gen_rtx_REG (mode, FIRST_ADDRESS_REGNUM),\n \t\t\t GEN_INT (0));\n-  \n+\n   XVECEXP (rv, 0, 1)\n     = gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t gen_rtx_REG (mode, FIRST_DATA_REGNUM),\n@@ -1672,7 +1673,7 @@ output_tst (rtx operand, rtx insn)\n \t}\n \n       /* Are we setting a data register to zero (this does not win for\n-\t address registers)? \n+\t address registers)?\n \n \t If it's a call clobbered register, have we past a call?\n \n@@ -1688,7 +1689,7 @@ output_tst (rtx operand, rtx insn)\n \t      == REGNO_REG_CLASS (REGNO (operand)))\n \t  && REGNO_REG_CLASS (REGNO (SET_DEST (set))) != EXTENDED_REGS\n \t  && REGNO (SET_DEST (set)) != REGNO (operand)\n-\t  && (!past_call \n+\t  && (!past_call\n \t      || !call_used_regs[REGNO (SET_DEST (set))]))\n \t{\n \t  rtx xoperands[2];\n@@ -1707,7 +1708,7 @@ output_tst (rtx operand, rtx insn)\n \t      != REGNO_REG_CLASS (REGNO (operand)))\n \t  && REGNO_REG_CLASS (REGNO (SET_DEST (set))) == EXTENDED_REGS\n \t  && REGNO (SET_DEST (set)) != REGNO (operand)\n-\t  && (!past_call \n+\t  && (!past_call\n \t      || !call_used_regs[REGNO (SET_DEST (set))]))\n \t{\n \t  rtx xoperands[2];\n@@ -2087,7 +2088,7 @@ mn10300_wide_const_load_uses_clr (rtx operands[2])\n \tval[1] = INTVAL (high);\n       }\n       break;\n-      \n+\n     case CONST_DOUBLE:\n       if (GET_MODE (operands[1]) == DFmode)\n \t{\n@@ -2103,7 +2104,7 @@ mn10300_wide_const_load_uses_clr (rtx operands[2])\n \t  val[1] = CONST_DOUBLE_HIGH (operands[1]);\n \t}\n       break;\n-      \n+\n     default:\n       return false;\n     }"}, {"sha": "21939f92d85cc443a2a4860df39f3dc68625c438", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 7, "deletions": 85, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5abc5de9717ff675b52a8c1453ac83ef65ec5eb9/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5abc5de9717ff675b52a8c1453ac83ef65ec5eb9/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=5abc5de9717ff675b52a8c1453ac83ef65ec5eb9", "patch": "@@ -251,12 +251,12 @@ extern enum processor_type mn10300_processor;\n \n    For any two classes, it is very desirable that there be another\n    class that represents their union.  */\n-   \n+\n enum reg_class {\n   NO_REGS, DATA_REGS, ADDRESS_REGS, SP_REGS,\n-  DATA_OR_ADDRESS_REGS, SP_OR_ADDRESS_REGS, \n+  DATA_OR_ADDRESS_REGS, SP_OR_ADDRESS_REGS,\n   EXTENDED_REGS, DATA_OR_EXTENDED_REGS, ADDRESS_OR_EXTENDED_REGS,\n-  SP_OR_EXTENDED_REGS, SP_OR_ADDRESS_OR_EXTENDED_REGS, \n+  SP_OR_EXTENDED_REGS, SP_OR_ADDRESS_OR_EXTENDED_REGS,\n   FP_REGS, FP_ACC_REGS,\n   GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES\n };\n@@ -313,19 +313,6 @@ enum reg_class {\n #define INDEX_REG_CLASS DATA_OR_EXTENDED_REGS\n #define BASE_REG_CLASS  SP_OR_ADDRESS_REGS\n \n-/* Get reg_class from a letter such as appears in the machine description.  */\n-\n-#define REG_CLASS_FROM_LETTER(C) \\\n-  ((C) == 'd' ? DATA_REGS : \\\n-   (C) == 'a' ? ADDRESS_REGS : \\\n-   (C) == 'y' ? SP_REGS : \\\n-   ! TARGET_AM33 ? NO_REGS : \\\n-   (C) == 'x' ? EXTENDED_REGS : \\\n-   ! TARGET_AM33_2 ? NO_REGS : \\\n-   (C) == 'f' ? FP_REGS : \\\n-   (C) == 'A' ? FP_ACC_REGS : \\\n-   NO_REGS)\n-\n /* Macros to check register numbers against specific register classes.  */\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n@@ -440,40 +427,11 @@ enum reg_class {\n    loaded the register.  */\n #define CLASS_CANNOT_CHANGE_SIZE FP_REGS\n \n-/* The letters I, J, K, L, M, N, O, P in a register constraint string\n-   can be used to stand for particular ranges of immediate operands.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C.  */\n+/* Return 1 if VALUE is in the range specified.  */\n \n #define INT_8_BITS(VALUE) ((unsigned) (VALUE) + 0x80 < 0x100)\n #define INT_16_BITS(VALUE) ((unsigned) (VALUE) + 0x8000 < 0x10000)\n \n-#define CONST_OK_FOR_I(VALUE) ((VALUE) == 0)\n-#define CONST_OK_FOR_J(VALUE) ((VALUE) == 1)\n-#define CONST_OK_FOR_K(VALUE) ((VALUE) == 2)\n-#define CONST_OK_FOR_L(VALUE) ((VALUE) == 4)\n-#define CONST_OK_FOR_M(VALUE) ((VALUE) == 3)\n-#define CONST_OK_FOR_N(VALUE) ((VALUE) == 255 || (VALUE) == 65535)\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C) \\\n-  ((C) == 'I' ? CONST_OK_FOR_I (VALUE) : \\\n-   (C) == 'J' ? CONST_OK_FOR_J (VALUE) : \\\n-   (C) == 'K' ? CONST_OK_FOR_K (VALUE) : \\\n-   (C) == 'L' ? CONST_OK_FOR_L (VALUE) : \\\n-   (C) == 'M' ? CONST_OK_FOR_M (VALUE) : \\\n-   (C) == 'N' ? CONST_OK_FOR_N (VALUE) : 0)\n-\n-\n-/* Similar, but for floating constants, and defining letters G and H.\n-   Here VALUE is the CONST_DOUBLE rtx itself. \n-     \n-  `G' is a floating-point zero.  */\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) \\\n-  ((C) == 'G' ? (GET_MODE_CLASS (GET_MODE (VALUE)) == MODE_FLOAT\t\\\n-\t\t && (VALUE) == CONST0_RTX (GET_MODE (VALUE))) : 0)\n-\n \f\n /* Stack layout; function entry, exit and calling.  */\n \n@@ -585,7 +543,7 @@ struct cum_arg {int nbytes; };\n    NAMED is nonzero if this argument is a named parameter\n     (otherwise it is an extra parameter matching an ellipsis).  */\n \n-/* On the MN10300 all args are pushed.  */   \n+/* On the MN10300 all args are pushed.  */\n \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n   function_arg (&CUM, MODE, TYPE, NAMED)\n@@ -676,42 +634,6 @@ struct cum_arg {int nbytes; };\n \n #define CONSTANT_ADDRESS_P(X)   CONSTANT_P (X)\n \n-/* Extra constraints.  */\n- \n-#define OK_FOR_Q(OP) \\\n-   (GET_CODE (OP) == MEM && ! CONSTANT_ADDRESS_P (XEXP (OP, 0)))\n-\n-#define OK_FOR_R(OP) \\\n-   (GET_CODE (OP) == MEM\t\t\t\t\t\\\n-    && GET_MODE (OP) == QImode\t\t\t\t\t\\\n-    && (CONSTANT_ADDRESS_P (XEXP (OP, 0))\t\t\t\\\n-\t|| (GET_CODE (XEXP (OP, 0)) == REG\t\t\t\\\n-\t    && REG_OK_FOR_BIT_BASE_P (XEXP (OP, 0))\t\t\\\n-\t    && XEXP (OP, 0) != stack_pointer_rtx)\t\t\\\n-\t|| (GET_CODE (XEXP (OP, 0)) == PLUS\t\t\t\\\n-\t    && GET_CODE (XEXP (XEXP (OP, 0), 0)) == REG\t\t\\\n-\t    && REG_OK_FOR_BIT_BASE_P (XEXP (XEXP (OP, 0), 0))\t\\\n-\t    && XEXP (XEXP (OP, 0), 0) != stack_pointer_rtx\t\\\n-\t    && GET_CODE (XEXP (XEXP (OP, 0), 1)) == CONST_INT\t\\\n-\t    && INT_8_BITS (INTVAL (XEXP (XEXP (OP, 0), 1))))))\n-\t \n-#define OK_FOR_T(OP) \\\n-   (GET_CODE (OP) == MEM\t\t\t\t\t\\\n-    && GET_MODE (OP) == QImode\t\t\t\t\t\\\n-    && (GET_CODE (XEXP (OP, 0)) == REG\t\t\t\t\\\n-\t&& REG_OK_FOR_BIT_BASE_P (XEXP (OP, 0))\t\t\t\\\n-\t&& XEXP (OP, 0) != stack_pointer_rtx))\n-\n-#define EXTRA_CONSTRAINT(OP, C) \\\n- ((C) == 'R' ? OK_FOR_R (OP) \\\n-  : (C) == 'Q' ? OK_FOR_Q (OP) \\\n-  : (C) == 'S' && flag_pic \\\n-  ? GET_CODE (OP) == UNSPEC && (XINT (OP, 1) == UNSPEC_PLT \\\n-\t\t\t\t|| XINT (OP, 1) == UNSPEC_PIC) \\\n-  : (C) == 'S' ? GET_CODE (OP) == SYMBOL_REF \\\n-  : (C) == 'T' ? OK_FOR_T (OP) \\\n-  : 0)\n-\n /* Maximum number of registers that can appear in a valid memory address.  */\n \n #define MAX_REGS_PER_ADDRESS 2\n@@ -740,7 +662,7 @@ struct cum_arg {int nbytes; };\n    function record_unscaled_index_insn_codes.  */\n \n /* Accept either REG or SUBREG where a register is valid.  */\n-  \n+\n #define RTX_OK_FOR_BASE_P(X, strict)\t\t\t\t\\\n   ((REG_P (X) && REGNO_STRICT_OK_FOR_BASE_P (REGNO (X),\t\t\\\n  \t\t\t\t\t     (strict))) \t\\\n@@ -754,7 +676,7 @@ do\t\t\t\t\t\t\t\\\n     if (legitimate_address_p ((MODE), (X), REG_STRICT))\t\\\n       goto ADDR;\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\\\n-while (0) \n+while (0)\n \n \f\n /* Try machine-dependent ways of modifying an illegitimate address"}, {"sha": "c1b2ee8c87d87e4690f22e977c6d9f8bf48147fe", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5abc5de9717ff675b52a8c1453ac83ef65ec5eb9/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5abc5de9717ff675b52a8c1453ac83ef65ec5eb9/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=5abc5de9717ff675b52a8c1453ac83ef65ec5eb9", "patch": "@@ -49,6 +49,7 @@\n ])\n \n (include \"predicates.md\")\n+(include \"constraints.md\")\n \f\n ;; ----------------------------------------------------------------------\n ;; MOVE INSTRUCTIONS\n@@ -516,7 +517,7 @@\n \t      return \\\"mov %H1,%H0\\;mov %L1,%L0\\\";\n \t    else\n \t      return \\\"mov %L1,%L0\\;mov %H1,%H0\\\";\n-\t      \n+\n \t  }\n \telse if (GET_CODE (operands[1]) == MEM\n \t\t && CONSTANT_ADDRESS_P (XEXP (operands[1], 0))\n@@ -727,7 +728,7 @@\n \t      return \\\"mov %H1,%H0\\;mov %L1,%L0\\\";\n \t    else\n \t      return \\\"mov %L1,%L0\\;mov %H1,%H0\\\";\n-\t      \n+\n \t  }\n \telse if (GET_CODE (operands[1]) == MEM\n \t\t && CONSTANT_ADDRESS_P (XEXP (operands[1], 0))\n@@ -920,7 +921,7 @@\n \tsrc1_class = REGNO_REG_CLASS (true_regnum (operands[1]));\n \tsrc2_class = REGNO_REG_CLASS (true_regnum (operands[2]));\n \tdst_class = REGNO_REG_CLASS (true_regnum (operands[0]));\n-\t\n+\n \t/* I'm not sure if this can happen or not.  Might as well be prepared\n \t  and generate the best possible code if it does happen.  */\n \tif (true_regnum (operands[0]) == true_regnum (operands[1]))\n@@ -938,7 +939,7 @@\n \t       add the other source to the destination.\n \n \t       Carefully select which source to copy to the destination; a naive\n-\t       implementation will waste a byte when the source classes are \n+\t       implementation will waste a byte when the source classes are\n \t       different and the destination is an address register.  Selecting\n \t       the lowest cost register copy will optimize this sequence.  */\n \t    if (REGNO_REG_CLASS (true_regnum (operands[1]))\n@@ -1119,7 +1120,7 @@\n     return \\\"mul %2,%0\\\";\n }\"\n   [(set_attr \"cc\" \"set_zn\")])\n-  \n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=dx\")\n \t(mult:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n@@ -1561,7 +1562,7 @@\n       else if (mask & 0xff000000)\n \tmask = (mask >> 24) & 0xff;\n     }\n-  \n+\n   xoperands[0] = operands[0];\n   xoperands[1] = GEN_INT (trunc_int_for_mode (mask, SImode));\n   if (GET_CODE (operands[0]) == REG)\n@@ -2462,7 +2463,7 @@\n   return \\\"\\\";\n }\"\n   [(set_attr \"cc\" \"clobber\")])\n-  \n+\n (define_insn \"return\"\n   [(return)]\n   \"can_use_return_insn ()\""}, {"sha": "3944c7eea173d29828b6299fa2ff372af8c53874", "filename": "gcc/config/mn10300/predicates.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5abc5de9717ff675b52a8c1453ac83ef65ec5eb9/gcc%2Fconfig%2Fmn10300%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5abc5de9717ff675b52a8c1453ac83ef65ec5eb9/gcc%2Fconfig%2Fmn10300%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fpredicates.md?ref=5abc5de9717ff675b52a8c1453ac83ef65ec5eb9", "patch": "@@ -44,7 +44,7 @@\n   (match_code \"symbol_ref,reg,unspec\")\n {\n   if (flag_pic)\n-    return (EXTRA_CONSTRAINT (op, 'S') || GET_CODE (op) == REG);\n+    return (satisfies_constraint_S (op) || GET_CODE (op) == REG);\n \n   return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == REG);\n })"}, {"sha": "cf231c937e06845d1b2993077befd31332ca76bf", "filename": "gcc/genemit.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5abc5de9717ff675b52a8c1453ac83ef65ec5eb9/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5abc5de9717ff675b52a8c1453ac83ef65ec5eb9/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=5abc5de9717ff675b52a8c1453ac83ef65ec5eb9", "patch": "@@ -621,7 +621,7 @@ gen_split (rtx split)\n   else\n     {\n       printf (\"extern rtx gen_split_%d (rtx, rtx *);\\n\", insn_code_number);\n-      printf (\"rtx\\ngen_split_%d (rtx curr_insn ATTRIBUTE_UNUSED, rtx *operands%s)\\n\", \n+      printf (\"rtx\\ngen_split_%d (rtx curr_insn ATTRIBUTE_UNUSED, rtx *operands%s)\\n\",\n \t      insn_code_number, unused);\n     }\n   printf (\"{\\n\");\n@@ -854,9 +854,10 @@ from the machine description file `md'.  */\\n\\n\");\n   printf (\"#include \\\"resource.h\\\"\\n\");\n   printf (\"#include \\\"reload.h\\\"\\n\");\n   printf (\"#include \\\"toplev.h\\\"\\n\");\n+  printf (\"#include \\\"regs.h\\\"\\n\");\n   printf (\"#include \\\"tm-constrs.h\\\"\\n\");\n-  printf (\"#include \\\"ggc.h\\\"\\n\\n\");\n-  printf (\"#include \\\"basic-block.h\\\"\\n\\n\");\n+  printf (\"#include \\\"ggc.h\\\"\\n\");\n+  printf (\"#include \\\"basic-block.h\\\"\\n\");\n   printf (\"#include \\\"integrate.h\\\"\\n\\n\");\n   printf (\"#define FAIL return (end_sequence (), _val)\\n\");\n   printf (\"#define DONE return (_val = get_insns (), end_sequence (), _val)\\n\\n\");"}, {"sha": "0b7280a9361ef370103ab9278f1c47c56c278da8", "filename": "gcc/genrecog.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5abc5de9717ff675b52a8c1453ac83ef65ec5eb9/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5abc5de9717ff675b52a8c1453ac83ef65ec5eb9/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=5abc5de9717ff675b52a8c1453ac83ef65ec5eb9", "patch": "@@ -171,7 +171,7 @@ static int pattern_lineno;\n /* Count of errors.  */\n static int error_count;\n \f\n-/* Predicate handling. \n+/* Predicate handling.\n \n    We construct from the machine description a table mapping each\n    predicate to a list of the rtl codes it can possibly match.  The\n@@ -259,7 +259,7 @@ compute_predicate_codes (rtx exp, char codes[NUM_RTX_CODE])\n       break;\n \n     case IF_THEN_ELSE:\n-      /* a ? b : c  accepts the same codes as (a & b) | (!a & c).  */ \n+      /* a ? b : c  accepts the same codes as (a & b) | (!a & c).  */\n       compute_predicate_codes (XEXP (exp, 0), op0_codes);\n       compute_predicate_codes (XEXP (exp, 1), op1_codes);\n       compute_predicate_codes (XEXP (exp, 2), op2_codes);\n@@ -295,7 +295,7 @@ compute_predicate_codes (rtx exp, char codes[NUM_RTX_CODE])\n \t  {\n \t    size_t n = next_code - code;\n \t    int found_it = 0;\n-\t    \n+\n \t    for (i = 0; i < NUM_RTX_CODE; i++)\n \t      if (!strncmp (code, GET_RTX_NAME (i), n)\n \t\t  && GET_RTX_NAME (i)[n] == '\\0')\n@@ -1088,7 +1088,7 @@ add_to_sequence (rtx pattern, struct decision_head *last, const char *position,\n       if (fmt[i] == 'i')\n \t{\n \t  gcc_assert (i < 2);\n-\t  \n+\n \t  if (!i)\n \t    {\n \t      test = new_decision_test (DT_elt_zero_int, &place);\n@@ -2496,6 +2496,7 @@ write_header (void)\n #include \\\"resource.h\\\"\\n\\\n #include \\\"toplev.h\\\"\\n\\\n #include \\\"reload.h\\\"\\n\\\n+#include \\\"regs.h\\\"\\n\\\n #include \\\"tm-constrs.h\\\"\\n\\\n \\n\");\n "}]}