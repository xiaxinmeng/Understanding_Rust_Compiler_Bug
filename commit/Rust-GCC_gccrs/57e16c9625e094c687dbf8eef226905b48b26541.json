{"sha": "57e16c9625e094c687dbf8eef226905b48b26541", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTdlMTZjOTYyNWUwOTRjNjg3ZGJmOGVlZjIyNjkwNWI0OGIyNjU0MQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-07-23T20:17:54Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-07-23T20:17:54Z"}, "message": "dwarf2cfi: Implement change_cfi_row.\n\nAdd a generic function to adjust cfi state from one row to another.\nUse this to implement text section switching.  This will also be\nusable for arbitrary changes around a cfg for shrink-wrapping.\n\n        * dwarf2cfi.c (add_cfi_args_size): Split out from...\n        (dwarf2out_args_size): ... here.\n        (add_cfi_restore): Split out from ...\n        (dwarf2out_frame_debug_cfa_restore): ... here.\n        (def_cfa_0): Split out from ...\n        (def_cfa_1): ... here.\n        (cfi_oprnd_equal_p, cfi_equal_p): New.\n        (change_cfi_row): New.\n        (add_cfis_to_fde): Set fde->dw_fde_switch_cfi_index.\n        (create_cfi_notes): Use change_cfi_row at SWITCH_TEXT note.\n        (output_cfis): Remove.\n        * dwarf2out.c (output_fde): Simplify output_cfi loop.\n        (dwarf2out_switch_text_section): Don't call output_cfis.\n        (dw_val_equal_p, loc_descr_equal_p_1, loc_descr_equal_p): New.\n        * dwarf2out.h: Update decls.\n        (enum dw_val_class): Add dw_val_class_none.\n\nFrom-SVN: r176700", "tree": {"sha": "b4bce59406cfba4cec2473ceaacbd2e3ea2d99fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4bce59406cfba4cec2473ceaacbd2e3ea2d99fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57e16c9625e094c687dbf8eef226905b48b26541", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57e16c9625e094c687dbf8eef226905b48b26541", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57e16c9625e094c687dbf8eef226905b48b26541", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57e16c9625e094c687dbf8eef226905b48b26541/comments", "author": null, "committer": null, "parents": [{"sha": "f1a0e8300d7ee346adb69555ec4c930c89fb3997", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1a0e8300d7ee346adb69555ec4c930c89fb3997", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1a0e8300d7ee346adb69555ec4c930c89fb3997"}], "stats": {"total": 557, "additions": 309, "deletions": 248}, "files": [{"sha": "89fc46a7f12a19e8e30124c085d198b39edf6a58", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57e16c9625e094c687dbf8eef226905b48b26541/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57e16c9625e094c687dbf8eef226905b48b26541/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=57e16c9625e094c687dbf8eef226905b48b26541", "patch": "@@ -1,3 +1,22 @@\n+2011-07-23  Richard Henderson  <rth@redhat.com>\n+\n+\t* dwarf2cfi.c (add_cfi_args_size): Split out from...\n+\t(dwarf2out_args_size): ... here.\n+\t(add_cfi_restore): Split out from ...\n+\t(dwarf2out_frame_debug_cfa_restore): ... here.\n+\t(def_cfa_0): Split out from ...\n+\t(def_cfa_1): ... here.\n+\t(cfi_oprnd_equal_p, cfi_equal_p): New.\n+\t(change_cfi_row): New.\n+\t(add_cfis_to_fde): Set fde->dw_fde_switch_cfi_index.\n+\t(create_cfi_notes): Use change_cfi_row at SWITCH_TEXT note.\n+\t(output_cfis): Remove.\n+\t* dwarf2out.c (output_fde): Simplify output_cfi loop.\n+\t(dwarf2out_switch_text_section): Don't call output_cfis.\n+\t(dw_val_equal_p, loc_descr_equal_p_1, loc_descr_equal_p): New.\n+\t* dwarf2out.h: Update decls.\n+\t(enum dw_val_class): Add dw_val_class_none.\n+\n 2011-07-23  Richard Henderson  <rth@redhat.com>\n \n \t* dwarf2cfi.c (update_row_reg_save): New."}, {"sha": "745e137d26913b46c8853dd8018941c108533a33", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 168, "deletions": 208, "changes": 376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57e16c9625e094c687dbf8eef226905b48b26541/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57e16c9625e094c687dbf8eef226905b48b26541/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=57e16c9625e094c687dbf8eef226905b48b26541", "patch": "@@ -285,6 +285,28 @@ add_cfi (dw_cfi_ref cfi)\n     VEC_safe_push (dw_cfi_ref, gc, *add_cfi_vec, cfi);\n }\n \n+static void\n+add_cfi_args_size (HOST_WIDE_INT size)\n+{\n+  dw_cfi_ref cfi = new_cfi ();\n+\n+  cfi->dw_cfi_opc = DW_CFA_GNU_args_size;\n+  cfi->dw_cfi_oprnd1.dw_cfi_offset = size;\n+\n+  add_cfi (cfi);\n+}\n+\n+static void\n+add_cfi_restore (unsigned reg)\n+{\n+  dw_cfi_ref cfi = new_cfi ();\n+\n+  cfi->dw_cfi_opc = (reg & ~0x3f ? DW_CFA_restore_extended : DW_CFA_restore);\n+  cfi->dw_cfi_oprnd1.dw_cfi_reg_num = reg;\n+\n+  add_cfi (cfi);\n+}\n+\n /* Perform ROW->REG_SAVE[COLUMN] = CFI.  CFI may be null, indicating\n    that the register column is no longer saved.  */\n \n@@ -474,64 +496,109 @@ cfa_equal_p (const dw_cfa_location *loc1, const dw_cfa_location *loc2)\n \t      || loc1->base_offset == loc2->base_offset));\n }\n \n-/* This routine does the actual work.  The CFA is now calculated from\n-   the dw_cfa_location structure.  */\n+/* Determine if two CFI operands are identical.  */\n \n-static void\n-def_cfa_1 (dw_cfa_location *loc_p)\n+static bool\n+cfi_oprnd_equal_p (enum dw_cfi_oprnd_type t, dw_cfi_oprnd *a, dw_cfi_oprnd *b)\n {\n-  dw_cfi_ref cfi;\n-  dw_cfa_location loc = *loc_p;\n+  switch (t)\n+    {\n+    case dw_cfi_oprnd_unused:\n+      return true;\n+    case dw_cfi_oprnd_reg_num:\n+      return a->dw_cfi_reg_num == b->dw_cfi_reg_num;\n+    case dw_cfi_oprnd_offset:\n+      return a->dw_cfi_offset == b->dw_cfi_offset;\n+    case dw_cfi_oprnd_addr:\n+      return (a->dw_cfi_addr == b->dw_cfi_addr\n+\t      || strcmp (a->dw_cfi_addr, b->dw_cfi_addr) == 0);\n+    case dw_cfi_oprnd_loc:\n+      return loc_descr_equal_p (a->dw_cfi_loc, b->dw_cfi_loc);\n+    }\n+  gcc_unreachable ();\n+}\n \n-  if (cfa_store.reg == loc.reg && loc.indirect == 0)\n-    cfa_store.offset = loc.offset;\n+/* Determine if two CFI entries are identical.  */\n+\n+static bool\n+cfi_equal_p (dw_cfi_ref a, dw_cfi_ref b)\n+{\n+  enum dwarf_call_frame_info opc;\n+\n+  /* Make things easier for our callers, including missing operands.  */\n+  if (a == b)\n+    return true;\n+  if (a == NULL || b == NULL)\n+    return false;\n+\n+  /* Obviously, the opcodes must match.  */\n+  opc = a->dw_cfi_opc;\n+  if (opc != b->dw_cfi_opc)\n+    return false;\n+\n+  /* Compare the two operands, re-using the type of the operands as\n+     already exposed elsewhere.  */\n+  return (cfi_oprnd_equal_p (dw_cfi_oprnd1_desc (opc),\n+\t\t\t     &a->dw_cfi_oprnd1, &b->dw_cfi_oprnd1)\n+\t  && cfi_oprnd_equal_p (dw_cfi_oprnd2_desc (opc),\n+\t\t\t\t&a->dw_cfi_oprnd2, &b->dw_cfi_oprnd2));\n+}\n+\n+/* The CFA is now calculated from NEW_CFA.  Consider OLD_CFA in determining\n+   what opcode to emit.  Returns the CFI opcode to effect the change, or\n+   NULL if NEW_CFA == OLD_CFA.  */\n+\n+static dw_cfi_ref\n+def_cfa_0 (dw_cfa_location *old_cfa, dw_cfa_location *new_cfa)\n+{\n+  dw_cfi_ref cfi;\n \n   /* If nothing changed, no need to issue any call frame instructions.  */\n-  if (cfa_equal_p (&loc, &cur_row->cfa))\n-    return;\n+  if (cfa_equal_p (old_cfa, new_cfa))\n+    return NULL;\n \n   cfi = new_cfi ();\n \n-  if (loc.reg == cur_row->cfa.reg && !loc.indirect && !cur_row->cfa.indirect)\n+  if (new_cfa->reg == old_cfa->reg && !new_cfa->indirect && !old_cfa->indirect)\n     {\n       /* Construct a \"DW_CFA_def_cfa_offset <offset>\" instruction, indicating\n \t the CFA register did not change but the offset did.  The data\n \t factoring for DW_CFA_def_cfa_offset_sf happens in output_cfi, or\n \t in the assembler via the .cfi_def_cfa_offset directive.  */\n-      if (loc.offset < 0)\n+      if (new_cfa->offset < 0)\n \tcfi->dw_cfi_opc = DW_CFA_def_cfa_offset_sf;\n       else\n \tcfi->dw_cfi_opc = DW_CFA_def_cfa_offset;\n-      cfi->dw_cfi_oprnd1.dw_cfi_offset = loc.offset;\n+      cfi->dw_cfi_oprnd1.dw_cfi_offset = new_cfa->offset;\n     }\n \n #ifndef MIPS_DEBUGGING_INFO  /* SGI dbx thinks this means no offset.  */\n-  else if (loc.offset == cur_row->cfa.offset\n-\t   && cur_row->cfa.reg != INVALID_REGNUM\n-\t   && !loc.indirect\n-\t   && !cur_row->cfa.indirect)\n+  else if (new_cfa->offset == old_cfa->offset\n+\t   && old_cfa->reg != INVALID_REGNUM\n+\t   && !new_cfa->indirect\n+\t   && !old_cfa->indirect)\n     {\n       /* Construct a \"DW_CFA_def_cfa_register <register>\" instruction,\n \t indicating the CFA register has changed to <register> but the\n \t offset has not changed.  */\n       cfi->dw_cfi_opc = DW_CFA_def_cfa_register;\n-      cfi->dw_cfi_oprnd1.dw_cfi_reg_num = loc.reg;\n+      cfi->dw_cfi_oprnd1.dw_cfi_reg_num = new_cfa->reg;\n     }\n #endif\n \n-  else if (loc.indirect == 0)\n+  else if (new_cfa->indirect == 0)\n     {\n       /* Construct a \"DW_CFA_def_cfa <register> <offset>\" instruction,\n \t indicating the CFA register has changed to <register> with\n \t the specified offset.  The data factoring for DW_CFA_def_cfa_sf\n \t happens in output_cfi, or in the assembler via the .cfi_def_cfa\n \t directive.  */\n-      if (loc.offset < 0)\n+      if (new_cfa->offset < 0)\n \tcfi->dw_cfi_opc = DW_CFA_def_cfa_sf;\n       else\n \tcfi->dw_cfi_opc = DW_CFA_def_cfa;\n-      cfi->dw_cfi_oprnd1.dw_cfi_reg_num = loc.reg;\n-      cfi->dw_cfi_oprnd2.dw_cfi_offset = loc.offset;\n+      cfi->dw_cfi_oprnd1.dw_cfi_reg_num = new_cfa->reg;\n+      cfi->dw_cfi_oprnd2.dw_cfi_offset = new_cfa->offset;\n     }\n   else\n     {\n@@ -541,14 +608,32 @@ def_cfa_1 (dw_cfa_location *loc_p)\n       struct dw_loc_descr_struct *loc_list;\n \n       cfi->dw_cfi_opc = DW_CFA_def_cfa_expression;\n-      loc_list = build_cfa_loc (&loc, 0);\n+      loc_list = build_cfa_loc (new_cfa, 0);\n       cfi->dw_cfi_oprnd1.dw_cfi_loc = loc_list;\n-\n-      cur_row->cfa_cfi = cfi;\n     }\n \n-  add_cfi (cfi);\n-  cur_row->cfa = loc;\n+  return cfi;\n+}\n+\n+/* Similarly, but take OLD_CFA from CUR_ROW, and update it after the fact.  */\n+\n+static void\n+def_cfa_1 (dw_cfa_location *new_cfa)\n+{\n+  dw_cfi_ref cfi;\n+\n+  if (cfa_store.reg == new_cfa->reg && new_cfa->indirect == 0)\n+    cfa_store.offset = new_cfa->offset;\n+\n+  cfi = def_cfa_0 (&cur_row->cfa, new_cfa);\n+  if (cfi)\n+    {\n+      cur_row->cfa = *new_cfa;\n+      if (cfi->dw_cfi_opc == DW_CFA_def_cfa_expression)\n+        cur_row->cfa_cfi = cfi;\n+\n+      add_cfi (cfi);\n+    }\n }\n \n /* Add the CFI for saving a register.  REG is the CFA column number.\n@@ -871,17 +956,11 @@ compute_barrier_args_size (void)\n static void\n dwarf2out_args_size (HOST_WIDE_INT size)\n {\n-  dw_cfi_ref cfi;\n-\n   if (size == cur_row->args_size)\n     return;\n \n   cur_row->args_size = size;\n-\n-  cfi = new_cfi ();\n-  cfi->dw_cfi_opc = DW_CFA_GNU_args_size;\n-  cfi->dw_cfi_oprnd1.dw_cfi_offset = size;\n-  add_cfi (cfi);\n+  add_cfi_args_size (size);\n }\n \n /* Record a stack adjustment of OFFSET bytes.  */\n@@ -1385,13 +1464,9 @@ dwarf2out_frame_debug_cfa_expression (rtx set)\n static void\n dwarf2out_frame_debug_cfa_restore (rtx reg)\n {\n-  dw_cfi_ref cfi = new_cfi ();\n   unsigned int regno = dwf_regno (reg);\n \n-  cfi->dw_cfi_opc = (regno & ~0x3f ? DW_CFA_restore_extended : DW_CFA_restore);\n-  cfi->dw_cfi_oprnd1.dw_cfi_reg_num = regno;\n-\n-  add_cfi (cfi);\n+  add_cfi_restore (regno);\n   update_row_reg_save (cur_row, regno, NULL);\n }\n \n@@ -2238,6 +2313,48 @@ dwarf2out_frame_debug (rtx insn, bool after_p)\n     dwarf2out_flush_queued_reg_saves ();\n }\n \n+/* Emit CFI info to change the state from OLD_ROW to NEW_ROW.  */\n+\n+static void\n+change_cfi_row (dw_cfi_row_ref old_row, dw_cfi_row_ref new_row)\n+{\n+  size_t i, n_old, n_new, n_max;\n+  dw_cfi_ref cfi;\n+\n+  if (new_row->cfa_cfi && !cfi_equal_p (old_row->cfa_cfi, new_row->cfa_cfi))\n+    add_cfi (new_row->cfa_cfi);\n+  else\n+    {\n+      cfi = def_cfa_0 (&old_row->cfa, &new_row->cfa);\n+      if (cfi)\n+\tadd_cfi (cfi);\n+    }\n+\n+  if (old_row->args_size != new_row->args_size)\n+    add_cfi_args_size (new_row->args_size);\n+\n+  n_old = VEC_length (dw_cfi_ref, old_row->reg_save);\n+  n_new = VEC_length (dw_cfi_ref, new_row->reg_save);\n+  n_max = MAX (n_old, n_new);\n+\n+  for (i = 0; i < n_max; ++i)\n+    {\n+      dw_cfi_ref r_old = NULL, r_new = NULL;\n+\n+      if (i < n_old)\n+\tr_old = VEC_index (dw_cfi_ref, old_row->reg_save, i);\n+      if (i < n_new)\n+\tr_new = VEC_index (dw_cfi_ref, new_row->reg_save, i);\n+\n+      if (r_old == r_new)\n+\t;\n+      else if (r_new == NULL)\n+\tadd_cfi_restore (i);\n+      else if (!cfi_equal_p (r_old, r_new))\n+        add_cfi (r_new);\n+    }\n+}\n+\n /* Examine CFI and return true if a cfi label and set_loc is needed\n    beforehand.  Even when generating CFI assembler instructions, we\n    still have to add the cfi to the list so that lookup_cfa_1 works\n@@ -2291,6 +2408,8 @@ add_cfis_to_fde (void)\n \n       if (NOTE_P (insn) && NOTE_KIND (insn) == NOTE_INSN_SWITCH_TEXT_SECTIONS)\n \t{\n+\t  fde->dw_fde_switch_cfi_index\n+\t    = VEC_length (dw_cfi_ref, fde->dw_fde_cfi);\n \t  /* Don't attempt to advance_loc4 between labels\n \t     in different sections.  */\n \t  first = true;\n@@ -2370,6 +2489,16 @@ create_cfi_notes (void)\n \t      add_cfi_insn = insn;\n \t      dwarf2out_frame_debug_restore_state ();\n \t      break;\n+\n+\t    case NOTE_INSN_SWITCH_TEXT_SECTIONS:\n+\t      /* In dwarf2out_switch_text_section, we'll begin a new FDE\n+\t\t for the portion of the function in the alternate text\n+\t\t section.  The row state at the very beginning of that\n+\t\t new FDE will be exactly the row state from the CIE.\n+\t\t Emit whatever CFIs are necessary to make CUR_ROW current.  */\n+\t      add_cfi_insn = insn;\n+\t      change_cfi_row (cie_cfi_row, cur_row);\n+\t      break;\n \t    }\n \t  continue;\n \t}\n@@ -3047,175 +3176,6 @@ dwarf2out_emit_cfi (dw_cfi_ref cfi)\n   if (dwarf2out_do_cfi_asm ())\n     output_cfi_directive (asm_out_file, cfi);\n }\n-\n-/* Output CFIs from VEC, up to index UPTO, to bring current FDE to the\n-   same state as after executing CFIs in CFI chain.  DO_CFI_ASM is\n-   true if .cfi_* directives shall be emitted, false otherwise.  If it\n-   is false, FDE and FOR_EH are the other arguments to pass to\n-   output_cfi.  */\n-\n-void\n-output_cfis (cfi_vec vec, int upto, bool do_cfi_asm,\n-\t     dw_fde_ref fde, bool for_eh)\n-{\n-  int ix;\n-  struct dw_cfi_struct cfi_buf;\n-  dw_cfi_ref cfi2;\n-  dw_cfi_ref cfi_args_size = NULL, cfi_cfa = NULL, cfi_cfa_offset = NULL;\n-  VEC(dw_cfi_ref, heap) *regs = VEC_alloc (dw_cfi_ref, heap, 32);\n-  unsigned int len, idx;\n-\n-  for (ix = 0; ix < upto + 1; ix++)\n-    {\n-      dw_cfi_ref cfi = ix < upto ? VEC_index (dw_cfi_ref, vec, ix) : NULL;\n-      switch (cfi ? cfi->dw_cfi_opc : DW_CFA_nop)\n-\t{\n-\tcase DW_CFA_advance_loc:\n-\tcase DW_CFA_advance_loc1:\n-\tcase DW_CFA_advance_loc2:\n-\tcase DW_CFA_advance_loc4:\n-\tcase DW_CFA_MIPS_advance_loc8:\n-\tcase DW_CFA_set_loc:\n-\t  /* All advances should be ignored.  */\n-\t  break;\n-\tcase DW_CFA_remember_state:\n-\t  {\n-\t    dw_cfi_ref args_size = cfi_args_size;\n-\n-\t    /* Skip everything between .cfi_remember_state and\n-\t       .cfi_restore_state.  */\n-\t    ix++;\n-\t    if (ix == upto)\n-\t      goto flush_all;\n-\n-\t    for (; ix < upto; ix++)\n-\t      {\n-\t\tcfi2 = VEC_index (dw_cfi_ref, vec, ix);\n-\t\tif (cfi2->dw_cfi_opc == DW_CFA_restore_state)\n-\t\t  break;\n-\t\telse if (cfi2->dw_cfi_opc == DW_CFA_GNU_args_size)\n-\t\t  args_size = cfi2;\n-\t\telse\n-\t\t  gcc_assert (cfi2->dw_cfi_opc != DW_CFA_remember_state);\n-\t      }\n-\n-\t    cfi_args_size = args_size;\n-\t    break;\n-\t  }\n-\tcase DW_CFA_GNU_args_size:\n-\t  cfi_args_size = cfi;\n-\t  break;\n-\tcase DW_CFA_GNU_window_save:\n-\t  goto flush_all;\n-\tcase DW_CFA_offset:\n-\tcase DW_CFA_offset_extended:\n-\tcase DW_CFA_offset_extended_sf:\n-\tcase DW_CFA_restore:\n-\tcase DW_CFA_restore_extended:\n-\tcase DW_CFA_undefined:\n-\tcase DW_CFA_same_value:\n-\tcase DW_CFA_register:\n-\tcase DW_CFA_val_offset:\n-\tcase DW_CFA_val_offset_sf:\n-\tcase DW_CFA_expression:\n-\tcase DW_CFA_val_expression:\n-\tcase DW_CFA_GNU_negative_offset_extended:\n-\t  if (VEC_length (dw_cfi_ref, regs)\n-\t      <= cfi->dw_cfi_oprnd1.dw_cfi_reg_num)\n-\t    VEC_safe_grow_cleared (dw_cfi_ref, heap, regs,\n-\t\t\t\t   cfi->dw_cfi_oprnd1.dw_cfi_reg_num + 1);\n-\t  VEC_replace (dw_cfi_ref, regs, cfi->dw_cfi_oprnd1.dw_cfi_reg_num,\n-\t\t       cfi);\n-\t  break;\n-\tcase DW_CFA_def_cfa:\n-\tcase DW_CFA_def_cfa_sf:\n-\tcase DW_CFA_def_cfa_expression:\n-\t  cfi_cfa = cfi;\n-\t  cfi_cfa_offset = cfi;\n-\t  break;\n-\tcase DW_CFA_def_cfa_register:\n-\t  cfi_cfa = cfi;\n-\t  break;\n-\tcase DW_CFA_def_cfa_offset:\n-\tcase DW_CFA_def_cfa_offset_sf:\n-\t  cfi_cfa_offset = cfi;\n-\t  break;\n-\tcase DW_CFA_nop:\n-\t  gcc_assert (cfi == NULL);\n-\tflush_all:\n-\t  len = VEC_length (dw_cfi_ref, regs);\n-\t  for (idx = 0; idx < len; idx++)\n-\t    {\n-\t      cfi2 = VEC_replace (dw_cfi_ref, regs, idx, NULL);\n-\t      if (cfi2 != NULL\n-\t\t  && cfi2->dw_cfi_opc != DW_CFA_restore\n-\t\t  && cfi2->dw_cfi_opc != DW_CFA_restore_extended)\n-\t\t{\n-\t\t  if (do_cfi_asm)\n-\t\t    output_cfi_directive (asm_out_file, cfi2);\n-\t\t  else\n-\t\t    output_cfi (cfi2, fde, for_eh);\n-\t\t}\n-\t    }\n-\t  if (cfi_cfa && cfi_cfa_offset && cfi_cfa_offset != cfi_cfa)\n-\t    {\n-\t      gcc_assert (cfi_cfa->dw_cfi_opc != DW_CFA_def_cfa_expression);\n-\t      cfi_buf = *cfi_cfa;\n-\t      switch (cfi_cfa_offset->dw_cfi_opc)\n-\t\t{\n-\t\tcase DW_CFA_def_cfa_offset:\n-\t\t  cfi_buf.dw_cfi_opc = DW_CFA_def_cfa;\n-\t\t  cfi_buf.dw_cfi_oprnd2 = cfi_cfa_offset->dw_cfi_oprnd1;\n-\t\t  break;\n-\t\tcase DW_CFA_def_cfa_offset_sf:\n-\t\t  cfi_buf.dw_cfi_opc = DW_CFA_def_cfa_sf;\n-\t\t  cfi_buf.dw_cfi_oprnd2 = cfi_cfa_offset->dw_cfi_oprnd1;\n-\t\t  break;\n-\t\tcase DW_CFA_def_cfa:\n-\t\tcase DW_CFA_def_cfa_sf:\n-\t\t  cfi_buf.dw_cfi_opc = cfi_cfa_offset->dw_cfi_opc;\n-\t\t  cfi_buf.dw_cfi_oprnd2 = cfi_cfa_offset->dw_cfi_oprnd2;\n-\t\t  break;\n-\t\tdefault:\n-\t\t  gcc_unreachable ();\n-\t\t}\n-\t      cfi_cfa = &cfi_buf;\n-\t    }\n-\t  else if (cfi_cfa_offset)\n-\t    cfi_cfa = cfi_cfa_offset;\n-\t  if (cfi_cfa)\n-\t    {\n-\t      if (do_cfi_asm)\n-\t\toutput_cfi_directive (asm_out_file, cfi_cfa);\n-\t      else\n-\t\toutput_cfi (cfi_cfa, fde, for_eh);\n-\t    }\n-\t  cfi_cfa = NULL;\n-\t  cfi_cfa_offset = NULL;\n-\t  if (cfi_args_size\n-\t      && cfi_args_size->dw_cfi_oprnd1.dw_cfi_offset)\n-\t    {\n-\t      if (do_cfi_asm)\n-\t\toutput_cfi_directive (asm_out_file, cfi_args_size);\n-\t      else\n-\t\toutput_cfi (cfi_args_size, fde, for_eh);\n-\t    }\n-\t  cfi_args_size = NULL;\n-\t  if (cfi == NULL)\n-\t    {\n-\t      VEC_free (dw_cfi_ref, heap, regs);\n-\t      return;\n-\t    }\n-\t  else if (do_cfi_asm)\n-\t    output_cfi_directive (asm_out_file, cfi);\n-\t  else\n-\t    output_cfi (cfi, fde, for_eh);\n-\t  break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n-}\n \f\n \n /* Save the result of dwarf2out_do_frame across PCH."}, {"sha": "d430753bfe5644c2fc65841807ae53c65fa213da", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 120, "deletions": 39, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57e16c9625e094c687dbf8eef226905b48b26541/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57e16c9625e094c687dbf8eef226905b48b26541/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=57e16c9625e094c687dbf8eef226905b48b26541", "patch": "@@ -519,11 +519,9 @@ output_fde (dw_fde_ref fde, bool for_eh, bool second,\n \t    char *section_start_label, int fde_encoding, char *augmentation,\n \t    bool any_lsda_needed, int lsda_encoding)\n {\n-  int ix;\n   const char *begin, *end;\n   static unsigned int j;\n   char l1[20], l2[20];\n-  dw_cfi_ref cfi;\n \n   targetm.asm_out.emit_unwind_label (asm_out_file, fde->decl, for_eh,\n \t\t\t\t     /* empty */ 0);\n@@ -603,36 +601,24 @@ output_fde (dw_fde_ref fde, bool for_eh, bool second,\n \tdw2_asm_output_data_uleb128 (0, \"Augmentation size\");\n     }\n \n-  /* Loop through the Call Frame Instructions associated with\n-     this FDE.  */\n+  /* Loop through the Call Frame Instructions associated with this FDE.  */\n   fde->dw_fde_current_label = begin;\n-  if (fde->dw_fde_second_begin == NULL)\n-    FOR_EACH_VEC_ELT (dw_cfi_ref, fde->dw_fde_cfi, ix, cfi)\n-      output_cfi (cfi, fde, for_eh);\n-  else if (!second)\n-    {\n-      if (fde->dw_fde_switch_cfi_index > 0)\n-\tFOR_EACH_VEC_ELT (dw_cfi_ref, fde->dw_fde_cfi, ix, cfi)\n-\t  {\n-\t    if (ix == fde->dw_fde_switch_cfi_index)\n-\t      break;\n-\t    output_cfi (cfi, fde, for_eh);\n-\t  }\n-    }\n-  else\n-    {\n-      int i, from = 0;\n-      int until = VEC_length (dw_cfi_ref, fde->dw_fde_cfi);\n+  {\n+    size_t from, until, i;\n \n-      if (fde->dw_fde_switch_cfi_index > 0)\n-\t{\n-\t  from = fde->dw_fde_switch_cfi_index;\n-\t  output_cfis (fde->dw_fde_cfi, from, false, fde, for_eh);\n-\t}\n-      for (i = from; i < until; i++)\n-\toutput_cfi (VEC_index (dw_cfi_ref, fde->dw_fde_cfi, i),\n-\t\t    fde, for_eh);\n-    }\n+    from = 0;\n+    until = VEC_length (dw_cfi_ref, fde->dw_fde_cfi);\n+\n+    if (fde->dw_fde_second_begin == NULL)\n+      ;\n+    else if (!second)\n+      until = fde->dw_fde_switch_cfi_index;\n+    else\n+      from = fde->dw_fde_switch_cfi_index;\n+\n+    for (i = from; i < until; i++)\n+      output_cfi (VEC_index (dw_cfi_ref, fde->dw_fde_cfi, i), fde, for_eh);\n+  }\n \n   /* If we are to emit a ref/link from function bodies to their frame tables,\n      do it now.  This is typically performed to make sure that tables\n@@ -1184,16 +1170,8 @@ dwarf2out_switch_text_section (void)\n     = (sect == text_section\n        || (cold_text_section && sect == cold_text_section));\n \n-  fde->dw_fde_switch_cfi_index = VEC_length (dw_cfi_ref, fde->dw_fde_cfi);\n-\n   if (dwarf2out_do_cfi_asm ())\n-    {\n-      dwarf2out_do_cfi_startproc (true);\n-      /* As this is a different FDE, insert all current CFI instructions\n-\t again.  */\n-      output_cfis (fde->dw_fde_cfi, fde->dw_fde_switch_cfi_index,\n-\t\t   true, fde, true);\n-    }\n+    dwarf2out_do_cfi_startproc (true);\n \n   var_location_switch_text_section ();\n \n@@ -1639,6 +1617,109 @@ add_loc_descr (dw_loc_descr_ref *list_head, dw_loc_descr_ref descr)\n   *d = descr;\n }\n \n+/* Compare two location operands for exact equality.  */\n+\n+static bool\n+dw_val_equal_p (dw_val_node *a, dw_val_node *b)\n+{\n+  if (a->val_class != b->val_class)\n+    return false;\n+  switch (a->val_class)\n+    {\n+    case dw_val_class_none:\n+      return true;\n+    case dw_val_class_addr:\n+      return rtx_equal_p (a->v.val_addr, b->v.val_addr);\n+\n+    case dw_val_class_offset:\n+    case dw_val_class_unsigned_const:\n+    case dw_val_class_const:\n+    case dw_val_class_range_list:\n+    case dw_val_class_lineptr:\n+    case dw_val_class_macptr:\n+      /* These are all HOST_WIDE_INT, signed or unsigned.  */\n+      return a->v.val_unsigned == b->v.val_unsigned;\n+\n+    case dw_val_class_loc:\n+      return a->v.val_loc == b->v.val_loc;\n+    case dw_val_class_loc_list:\n+      return a->v.val_loc_list == b->v.val_loc_list;\n+    case dw_val_class_die_ref:\n+      return a->v.val_die_ref.die == b->v.val_die_ref.die;\n+    case dw_val_class_fde_ref:\n+      return a->v.val_fde_index == b->v.val_fde_index;\n+    case dw_val_class_lbl_id:\n+      return strcmp (a->v.val_lbl_id, b->v.val_lbl_id) == 0;\n+    case dw_val_class_str:\n+      return a->v.val_str == b->v.val_str;\n+    case dw_val_class_flag:\n+      return a->v.val_flag == b->v.val_flag;\n+    case dw_val_class_file:\n+      return a->v.val_file == b->v.val_file;\n+    case dw_val_class_decl_ref:\n+      return a->v.val_decl_ref == b->v.val_decl_ref;\n+    \n+    case dw_val_class_const_double:\n+      return (a->v.val_double.high == b->v.val_double.high\n+\t      && a->v.val_double.low == b->v.val_double.low);\n+\n+    case dw_val_class_vec:\n+      {\n+\tsize_t a_len = a->v.val_vec.elt_size * a->v.val_vec.length;\n+\tsize_t b_len = b->v.val_vec.elt_size * b->v.val_vec.length;\n+\n+\treturn (a_len == b_len\n+\t\t&& !memcmp (a->v.val_vec.array, b->v.val_vec.array, a_len));\n+      }\n+\n+    case dw_val_class_data8:\n+      return memcmp (a->v.val_data8, b->v.val_data8, 8) == 0;\n+\n+    case dw_val_class_vms_delta:\n+      return (!strcmp (a->v.val_vms_delta.lbl1, b->v.val_vms_delta.lbl1)\n+              && !strcmp (a->v.val_vms_delta.lbl1, b->v.val_vms_delta.lbl1));\n+    }\n+  gcc_unreachable ();\n+}\n+\n+/* Compare two location atoms for exact equality.  */\n+\n+static bool\n+loc_descr_equal_p_1 (dw_loc_descr_ref a, dw_loc_descr_ref b)\n+{\n+  if (a->dw_loc_opc != b->dw_loc_opc)\n+    return false;\n+\n+  /* ??? This is only ever set for DW_OP_constNu, for N equal to the\n+     address size, but since we always allocate cleared storage it\n+     should be zero for other types of locations.  */\n+  if (a->dtprel != b->dtprel)\n+    return false;\n+\n+  return (dw_val_equal_p (&a->dw_loc_oprnd1, &b->dw_loc_oprnd1)\n+\t  && dw_val_equal_p (&a->dw_loc_oprnd2, &b->dw_loc_oprnd2));\n+}\n+\n+/* Compare two complete location expressions for exact equality.  */\n+\n+bool\n+loc_descr_equal_p (dw_loc_descr_ref a, dw_loc_descr_ref b)\n+{\n+  while (1)\n+    {\n+      if (a == b)\n+\treturn true;\n+      if (a == NULL || b == NULL)\n+\treturn false;\n+      if (!loc_descr_equal_p_1 (a, b))\n+\treturn false;\n+\n+      a = a->dw_loc_next;\n+      b = b->dw_loc_next;\n+    }\n+}\n+\n+\n /* Add a constant OFFSET to a location expression.  */\n \n static void"}, {"sha": "711e8ab0d5ede91cbfef5e691730d43f11afedce", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57e16c9625e094c687dbf8eef226905b48b26541/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57e16c9625e094c687dbf8eef226905b48b26541/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=57e16c9625e094c687dbf8eef226905b48b26541", "patch": "@@ -134,6 +134,7 @@ typedef struct GTY(()) cfa_loc {\n \n enum dw_val_class\n {\n+  dw_val_class_none,\n   dw_val_class_addr,\n   dw_val_class_offset,\n   dw_val_class_loc,\n@@ -226,6 +227,7 @@ extern struct dw_loc_descr_struct *build_cfa_aligned_loc\n extern struct dw_loc_descr_struct *mem_loc_descriptor\n   (rtx, enum machine_mode mode, enum machine_mode mem_mode,\n    enum var_init_status);\n+extern bool loc_descr_equal_p (dw_loc_descr_ref, dw_loc_descr_ref);\n extern enum machine_mode get_address_mode (rtx mem);\n extern dw_fde_ref dwarf2out_alloc_current_fde (void);\n \n@@ -239,7 +241,6 @@ extern void lookup_cfa_1 (dw_cfi_ref cfi, dw_cfa_location *loc,\n extern bool cfa_equal_p (const dw_cfa_location *, const dw_cfa_location *);\n \n extern void output_cfi (dw_cfi_ref, dw_fde_ref, int);\n-extern void output_cfis (cfi_vec, int, bool, dw_fde_ref, bool);\n \n extern GTY(()) cfi_vec cie_cfi_vec;\n "}]}