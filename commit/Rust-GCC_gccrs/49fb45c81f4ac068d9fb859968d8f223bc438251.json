{"sha": "49fb45c81f4ac068d9fb859968d8f223bc438251", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDlmYjQ1YzgxZjRhYzA2OGQ5ZmI4NTk5NjhkOGYyMjNiYzQzODI1MQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-11-01T21:09:20Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-11-01T21:09:20Z"}, "message": "PR middle-end/91679 - missing -Warray-bounds accessing a member array in a local buffer\n\nPR middle-end/91679 - missing -Warray-bounds accessing a member array in a local buffer\nPR middle-end/91647 - new FAILs for Warray-bounds-8 and Wstringop-overflow-3.C\nPR middle-end/91463 - missing -Warray-bounds accessing past the end of a statically initialized flexible array member\nPR middle-end/92312 - bogus -Wstringop-overflow storing into a trailing array backed by larger buffer\n\ngcc/ChangeLog:\n\n\tPR middle-end/91679\n\tPR middle-end/91647\n\tPR middle-end/91463\n\tPR middle-end/92312\n\t* c-family/c-pretty-print.c (direct_abstract_declarator): Print\n\tbound in zero-length arrays.\n\t* gcc/c-family/c.opt (-Wzero-length-bounds): New option.\n\t* gcc/doc/invoke.texi (-Wzero-length-bounds): Document.\n\t* gimple-match-head.c (try_conditional_simplification): Use memcpy\n\tinstead of a hand-rolled loop to avoid PR 92323.\n\t* tree-vrp.c (vrp_prop::check_array_ref): Handle trailing arrays\n\twith initializers.\n\t(vrp_prop::check_mem_ref): Handle declared struct objects.\n\t* tree.c (last_field): New function.\n\t(array_at_struct_end_p): Handle MEM_REF.\n\t(get_initializer_for): New helper.\n\t(component_ref_size): Add argument.  Rename locals.  Call\n\tget_initializer_for instead of fold_ctor_reference.  Correct handling\n\tof flexible array members.\n\t* wide-int.h (generic_wide_int <storage>::sign_mask): Assert invariant.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/91679\n\tPR middle-end/91647\n\tPR middle-end/91463\n\tPR middle-end/92312\n\t* c-c++-common/Warray-bounds-2.c: Disable VRP.  Adjust expected messages.\n\t* g++.dg/warn/Warray-bounds-8.C: Remove xfails.\n\t* gcc.dg/Warray-bounds-48.c: New test.\n\t* gcc.dg/Warray-bounds-49.c: New test.\n\t* gcc.dg/Wstringop-overflow-16.c: Adjust text of expected messages.\n\t* gcc.dg/Wstringop-overflow-21.c: New test.\n\t* gcc.dg/Wzero-length-array-bounds.c: New test.\n\t* gcc.dg/pr36902.c: Remove xfail.\n\t* gcc.dg/strlenopt-57.c: Add an expected warning.\n\nFrom-SVN: r277728", "tree": {"sha": "56f91e1dcae71841b97747d2342eacce4c35592e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56f91e1dcae71841b97747d2342eacce4c35592e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49fb45c81f4ac068d9fb859968d8f223bc438251", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49fb45c81f4ac068d9fb859968d8f223bc438251", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49fb45c81f4ac068d9fb859968d8f223bc438251", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49fb45c81f4ac068d9fb859968d8f223bc438251/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8dc56a2244cfe35cbdb53e0f586c16f90a2677e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dc56a2244cfe35cbdb53e0f586c16f90a2677e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dc56a2244cfe35cbdb53e0f586c16f90a2677e4"}], "stats": {"total": 1128, "additions": 1020, "deletions": 108}, "files": [{"sha": "796f5e9ec9110c5ceb6347a60e2d1f8917080d51", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=49fb45c81f4ac068d9fb859968d8f223bc438251", "patch": "@@ -1,3 +1,26 @@\n+2019-11-01  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/91679\n+\tPR middle-end/91647\n+\tPR middle-end/91463\n+\tPR middle-end/92312\n+\t* c-family/c-pretty-print.c (direct_abstract_declarator): Print\n+\tbound in zero-length arrays.\n+\t* gcc/c-family/c.opt (-Wzero-length-bounds): New option.\n+\t* gcc/doc/invoke.texi (-Wzero-length-bounds): Document.\n+\t* gimple-match-head.c (try_conditional_simplification): Use memcpy\n+\tinstead of a hand-rolled loop to avoid PR 92323.\n+\t* tree-vrp.c (vrp_prop::check_array_ref): Handle trailing arrays\n+\twith initializers.\n+\t(vrp_prop::check_mem_ref): Handle declared struct objects.\n+\t* tree.c (last_field): New function.\n+\t(array_at_struct_end_p): Handle MEM_REF.\n+\t(get_initializer_for): New helper.\n+\t(component_ref_size): Add argument.  Rename locals.  Call\n+\tget_initializer_for instead of fold_ctor_reference.  Correct handling\n+\tof flexible array members.\n+\t* wide-int.h (generic_wide_int <storage>::sign_mask): Assert invariant.\n+\n 2019-11-01  Kewen Lin  <linkw@gcc.gnu.org>\n \n \t* config/rs6000/rs6000-modes.def (V2SF, V2SI): New modes."}, {"sha": "bc7354559ba58d4740175b4c04fb6ca296a0e729", "filename": "gcc/c-family/c-pretty-print.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Fc-family%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Fc-family%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pretty-print.c?ref=49fb45c81f4ac068d9fb859968d8f223bc438251", "patch": "@@ -581,16 +581,20 @@ c_pretty_printer::direct_abstract_declarator (tree t)\n \n     case ARRAY_TYPE:\n       pp_c_left_bracket (this);\n-      if (TYPE_DOMAIN (t) && TYPE_MAX_VALUE (TYPE_DOMAIN (t)))\n+      if (tree dom = TYPE_DOMAIN (t))\n \t{\n-\t  tree maxval = TYPE_MAX_VALUE (TYPE_DOMAIN (t));\n-\t  tree type = TREE_TYPE (maxval);\n+\t  if (tree maxval = TYPE_MAX_VALUE (dom))\n+\t    {\n+\t      tree type = TREE_TYPE (maxval);\n \n-\t  if (tree_fits_shwi_p (maxval))\n-\t    pp_wide_integer (this, tree_to_shwi (maxval) + 1);\n+\t      if (tree_fits_shwi_p (maxval))\n+\t\tpp_wide_integer (this, tree_to_shwi (maxval) + 1);\n+\t      else\n+\t\texpression (fold_build2 (PLUS_EXPR, type, maxval,\n+\t\t\t\t\t build_int_cst (type, 1)));\n+\t    }\n \t  else\n-\t    expression (fold_build2 (PLUS_EXPR, type, maxval,\n-                                     build_int_cst (type, 1)));\n+\t    pp_string (this, \"0\");\n \t}\n       pp_c_right_bracket (this);\n       direct_abstract_declarator (TREE_TYPE (t));"}, {"sha": "bb6eeaf1523bcd2385a0efc627c7d3173c565afb", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=49fb45c81f4ac068d9fb859968d8f223bc438251", "patch": "@@ -338,6 +338,10 @@ Warray-bounds=\n LangEnabledBy(C ObjC C++ LTO ObjC++,Wall,1,0)\n ; in common.opt\n \n+Wzero-length-bounds\n+C ObjC C++ ObjC++ Var(warn_zero_length_bounds) Warning LangEnabledBy(C ObjC C++ ObjC++,Wall)\n+Warn about accesses to interior zero-length array members.\n+\n Wassign-intercept\n ObjC ObjC++ Var(warn_assign_intercept) Warning\n Warn whenever an Objective-C assignment is being intercepted by the garbage collector."}, {"sha": "faa7fa95a0eb02d897423a0d4d43be66e2dc8969", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=49fb45c81f4ac068d9fb859968d8f223bc438251", "patch": "@@ -325,6 +325,7 @@ Objective-C and Objective-C++ Dialects}.\n -Winaccessible-base @gol\n -Winit-self  -Winline  -Wno-int-conversion  -Wint-in-bool-context @gol\n -Wno-int-to-pointer-cast  -Winvalid-memory-model  -Wno-invalid-offsetof @gol\n+-Wzero-length-bounds @gol\n -Winvalid-pch  -Wlarger-than=@var{byte-size} @gol\n -Wlogical-op  -Wlogical-not-parentheses  -Wlong-long @gol\n -Wmain  -Wmaybe-uninitialized  -Wmemset-elt-size  -Wmemset-transposed-args @gol\n@@ -4438,6 +4439,7 @@ Options} and @ref{Objective-C and Objective-C++ Dialect Options}.\n -Wimplicit-int @r{(C and Objective-C only)} @gol\n -Wimplicit-function-declaration @r{(C and Objective-C only)} @gol\n -Winit-self @r{(only for C++)} @gol\n+-Wzero-length-bounds @gol\n -Wlogical-not-parentheses @gol\n -Wmain @r{(only for C/ObjC and unless} @option{-ffreestanding}@r{)}  @gol\n -Wmaybe-uninitialized @gol\n@@ -6330,6 +6332,33 @@ conversions.  This warning is about implicit conversions; for explicit\n conversions the warnings @option{-Wno-int-to-pointer-cast} and\n @option{-Wno-pointer-to-int-cast} may be used.\n \n+@item -Wzero-length-bounds\n+@opindex Wzero-length-bounds\n+@opindex Wzero-length-bounds\n+Warn about accesses to elements of zero-length array members that might\n+overlap other members of the same object.  Declaring interior zero-length\n+arrays is discouraged because accesses to them are undefined.  See\n+@xref{Zero Length}.\n+\n+For example, the first two stores in function @code{bad} are diagnosed\n+because the array elements overlap the subsequent members @code{b} and\n+@code{c}.  The third store is diagnosed by @option{-Warray-bounds}\n+because it is beyond the bounds of the enclosing object.\n+\n+@smallexample\n+struct X @{ int a[0]; int b, c; @};\n+struct X x;\n+\n+void bad (void)\n+@{\n+  x.a[0] = 0;   // -Wzero-length-bounds\n+  x.a[1] = 1;   // -Wzero-length-bounds\n+  x.a[2] = 2;   // -Warray-bounds\n+@}\n+@end smallexample\n+\n+Option @option{-Wzero-length-bounds} is enabled by @option{-Warray-bounds}.\n+\n @item -Wno-div-by-zero\n @opindex Wno-div-by-zero\n @opindex Wdiv-by-zero"}, {"sha": "d7c74a1865ae4afc8c2da7a3d562a41b8242ccd8", "filename": "gcc/gimple-match-head.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Fgimple-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Fgimple-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match-head.c?ref=49fb45c81f4ac068d9fb859968d8f223bc438251", "patch": "@@ -837,8 +837,8 @@ try_conditional_simplification (internal_fn ifn, gimple_match_op *res_op,\n   gimple_match_op cond_op (gimple_match_cond (res_op->ops[0],\n \t\t\t\t\t      res_op->ops[num_ops - 1]),\n \t\t\t   op, res_op->type, num_ops - 2);\n-  for (unsigned int i = 1; i < num_ops - 1; ++i)\n-    cond_op.ops[i - 1] = res_op->ops[i];\n+\n+  memcpy (cond_op.ops, res_op->ops + 1, (num_ops - 1) * sizeof *cond_op.ops);\n   switch (num_ops - 2)\n     {\n     case 2:"}, {"sha": "f4e18db61117bd4b35f83753eb168ef6798ee3e2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=49fb45c81f4ac068d9fb859968d8f223bc438251", "patch": "@@ -1,3 +1,19 @@\n+2019-11-01  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/91679\n+\tPR middle-end/91647\n+\tPR middle-end/91463\n+\tPR middle-end/92312\n+\t* c-c++-common/Warray-bounds-2.c: Disable VRP.  Adjust expected messages.\n+\t* g++.dg/warn/Warray-bounds-8.C: Remove xfails.\n+\t* gcc.dg/Warray-bounds-48.c: New test.\n+\t* gcc.dg/Warray-bounds-49.c: New test.\n+\t* gcc.dg/Wstringop-overflow-16.c: Adjust text of expected messages.\n+\t* gcc.dg/Wstringop-overflow-21.c: New test.\n+\t* gcc.dg/Wzero-length-array-bounds.c: New test.\n+\t* gcc.dg/pr36902.c: Remove xfail.\n+\t* gcc.dg/strlenopt-57.c: Add an expected warning.\n+\n 2019-11-01  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \t* gfortran.dg/byte_3.f: New test."}, {"sha": "7f925c34baeb6d0b58a4969d7e6c2b4121da8baa", "filename": "gcc/testsuite/c-c++-common/Warray-bounds-2.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-2.c?ref=49fb45c81f4ac068d9fb859968d8f223bc438251", "patch": "@@ -6,7 +6,7 @@\n    source of the excessive array bound is in a different function than\n    the call.\n    { dg-do compile }\n-   { dg-options \"-O2 -Warray-bounds -Wno-stringop-overflow\" } */\n+   { dg-options \"-O2 -Warray-bounds -Wno-stringop-overflow -fno-tree-vrp\" } */\n \n #if __has_include (<stddef.h>)\n #  include <stddef.h>\n@@ -216,13 +216,13 @@ void call_strncpy_dst_diff_max (const char *s, size_t n)\n static void\n wrap_strncpy_dstarray_diff_neg (char *d, const char *s, ptrdiff_t i, size_t n)\n {\n-  strncpy (d + i, s, n);   /* { dg-bogus \"offset -\\[0-9\\]+ is out of the bounds \\\\\\[0, 90] of object .ar10. with type .(struct )?Array ?\\\\\\[2].\" \"strncpy\" } */\n-}\t\t\t   /* { dg-warning \"array subscript -1 is outside array bounds\" \"\" { target *-*-* } .-1 } */\n+  strncpy (d + i, s, n);   /* { dg-warning \"offset -\\[0-9\\]+ is out of the bounds \\\\\\[0, 90] of object .ar10. with type .(struct )?Array ?\\\\\\[2].\" \"strncpy\" } */\n+}\n \n void call_strncpy_dstarray_diff_neg (const char *s, size_t n)\n {\n-  struct Array ar10[2];    /* { dg-bogus \".ar10. declared here\" } */\n-  sink (&ar10);\t\t   /* { dg-message \"while referencing\" \"\" { target *-*-* } .-1 } */\n+  struct Array ar10[2];    /* { dg-message \".ar10. declared here\" } */\n+  sink (&ar10);\n \n   int off = (char*)ar10[1].a17 - (char*)ar10 + 1;\n   wrap_strncpy_dstarray_diff_neg (ar10[1].a17, s, -off, n);"}, {"sha": "6db20135668defc3027a69d432a28e527d7b930c", "filename": "gcc/testsuite/g++.dg/warn/Warray-bounds-8.C", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-8.C?ref=49fb45c81f4ac068d9fb859968d8f223bc438251", "patch": "@@ -13,17 +13,17 @@ void sink (void*);\n struct Ax\n {\n   char n;\n-  char a[];                     // { dg-message \"while referencing .Ax::a.\" \"pr91463\" { xfail *-*-* } }\n+  char a[];                     // { dg-message \"while referencing .Ax::a.\" }\n };\n \n // Verify warning for a definition with no initializer.\n Ax ax_;\n \n void gax_ ()\n {\n-  ax_.a[0] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr91463\" { xfail *-*-* } }\n-  ax_.a[1] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr91463\" { xfail *-*-* } }\n-  ax_.a[2] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr91463\" { xfail *-*-* } }\n+  ax_.a[0] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  ax_.a[1] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  ax_.a[2] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n }\n \n // Verify warning for access to a definition with an initializer that doesn't\n@@ -32,9 +32,9 @@ Ax ax0 = { 0 };\n \n void gax0 ()\n {\n-  ax0.a[0] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr91463\" { xfail *-*-* } }\n-  ax0.a[1] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr91463\" { xfail *-*-* } }\n-  ax0.a[2] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr91463\" { xfail *-*-* } }\n+  ax0.a[0] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  ax0.a[1] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  ax0.a[2] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n }\n \n // Verify warning for access to a definition with an initializer that\n@@ -43,9 +43,9 @@ Ax ax0_ = { 0, { } };\n \n void gax0_ ()\n {\n-  ax0_.a[0] = 0;                // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr91463\" { xfail *-*-* } }\n-  ax0_.a[1] = 0;                // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr91463\" { xfail *-*-* } }\n-  ax0_.a[2] = 0;                // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr91463\" { xfail *-*-* } }\n+  ax0_.a[0] = 0;                // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  ax0_.a[1] = 0;                // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  ax0_.a[2] = 0;                // { dg-warning \"\\\\\\[-Warray-bounds\" }\n }\n \n // Verify warning for out-of-bounds accesses to a definition with\n@@ -55,8 +55,8 @@ Ax ax1 = { 1, { 0 } };\n void gax1 ()\n {\n   ax1.a[0] = 0;\n-  ax1.a[1] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr91463\" { xfail *-*-* } }\n-  ax1.a[2] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr91463\" { xfail *-*-* } }\n+  ax1.a[1] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  ax1.a[2] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n }\n \n Ax ax2 = { 2, { 1, 0 } };\n@@ -65,7 +65,7 @@ void gax2 ()\n {\n   ax2.a[0] = 0;\n   ax2.a[1] = 0;\n-  ax2.a[2] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr91463\" { xfail *-*-* } }\n+  ax2.a[2] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds\" }\n }\n \n \n@@ -308,14 +308,14 @@ void ga1ix ()\n struct Bx\n {\n   char n;\n-  char a[];                     // { dg-message \"while referencing .Bx::a.\" \"pr91463\" { xfail *-*-* } }\n+  char a[];                     // { dg-message \"while referencing .Bx::a.\" }\n \n   // Verify the warning for a constant.\n-  Bx () { a[0] = 0; }           // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr91463\" { xfail *-*-* } }\n+  Bx () { a[0] = 0; }           // { dg-warning \"\\\\\\[-Warray-bounds\" }\n \n   // And also for a non-constant.  Regardless of the subscript, the array\n   // of the object in function gxi() below has a zero size.\n-  Bx (int i) { a[i] = 0; }      // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr91463\" { xfail *-*-* } }\n+  Bx (int i) { a[i] = 0; }      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n };\n \n void gbx (void)"}, {"sha": "4980f93a4707466bf4d4e3e78adfd1214e67e961", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-46.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-46.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-46.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-46.c?ref=49fb45c81f4ac068d9fb859968d8f223bc438251", "patch": "@@ -67,7 +67,7 @@ void strcpy_global (void)\n \n   SA (__builtin_offsetof (struct MA17, ax) == 157);\n \n-  T (gma.ax, 0);          // { dg-warning \"'strcpy' offset 157 is out of the bounds \\\\\\[0, 157] of object 'gma' with type 'struct MA17'\" }\n+  T (gma.ax, 0);          // { dg-warning \"'strcpy' offset 157 from the object at 'gma' is out of the bounds of referenced subobject 'ax' with type 'char[]' at offset 157|'strcpy' offset 157 is out of the bounds \\\\\\[0, 157] of object 'gma' with type 'struct MA17'\" }\n }\n \n \n@@ -92,16 +92,16 @@ void strcpy_global_array (void)\n   T (gma2[0].a17, 16);\n   T (gma2[0].a17, 17);    // { dg-warning \"'strcpy' offset 157 from the object at 'gma2' is out of the bounds of referenced subobject 'a17' with type 'char\\\\\\[17]' at offset 140\" }\n \n-  /* GMA2 is external buts because it's an array its definition in another\n+  /* GMA2 is external but because it's an array its definition in another\n      translation unit may not provide an initializer for the flexible array\n      member.  Verify that a warning is issued for access to it.  */\n-  T (gma2[0].ax, 1);      // { dg-warning \"'strcpy' offset \\\\\\[157, 158] from the object at 'gma2' is out of the bounds of referenced subobject 'ax' with type 'char\\\\\\[]' at offset 157\" }\n-  T (gma2[0].ax, 7);      // { dg-warning \"'strcpy' offset \\\\\\[157, 164] from the object at 'gma2' is out of the bounds of referenced subobject 'ax' with type 'char\\\\\\[]' at offset 157\" }\n+  T (gma2[0].ax, 1);      // { dg-warning \"'strcpy' offset \\\\\\[157, 158] from the object at 'gma2' is out of the bounds of referenced subobject 'ax' with type 'char\\\\\\[0]' at offset 157\" }\n+  T (gma2[0].ax, 7);      // { dg-warning \"'strcpy' offset \\\\\\[157, 164] from the object at 'gma2' is out of the bounds of referenced subobject 'ax' with type 'char\\\\\\[0]' at offset 157\" }\n \n   /* IGMA_ is internal and provides on definition for the flexible array\n      member.  Verify that a warnin is issued for out-of-bounds accesses\n      to it.  */\n-  T (igma2_[0].ax, 1);    // { dg-warning \"'strcpy' offset \\\\\\[157, 158] from the object at 'igma2_' is out of the bounds of referenced subobject 'ax' with type 'char\\\\\\[]' at offset 157\" }\n+  T (igma2_[0].ax, 1);    // { dg-warning \"'strcpy' offset \\\\\\[157, 158] from the object at 'igma2_' is out of the bounds of referenced subobject 'ax' with type 'char\\\\\\[0]' at offset 157\" }\n \n   T (igma_3.ax, 0);\n   T (igma_3.ax, 1);\n@@ -134,7 +134,7 @@ void strcpy_local (void)\n   T (lma.a17, 16);\n   T (lma.a17, 17);        // { dg-warning \"'strcpy' offset 157 from the object at 'lma' is out of the bounds of referenced subobject 'a17' with type 'char\\\\\\[17]' at offset 140\" }\n \n-  T (lma.ax, 0);          // { dg-warning \"'strcpy' offset 157 from the object at 'lma' is out of the bounds of referenced subobject 'ax' with type 'char\\\\\\[]' at offset 157\" }\n+  T (lma.ax, 0);          // { dg-warning \"'strcpy' offset 157 from the object at 'lma' is out of the bounds of referenced subobject 'ax' with type 'char\\\\\\[0]' at offset 157\" }\n }\n \n \n@@ -191,11 +191,11 @@ void strcpy_ref (struct MA17 *pma)\n      array.  The warning assumes that PMA doesn't point to the last element\n      of the array which could in theory have nonzero elements without\n      overlapping other objects.  */\n-  T (pma[1].ax, 0);       // { dg-warning \"'strcpy' offset 314 from the object at 'pma' is out of the bounds of referenced subobject 'ax' with type 'char\\\\\\[]' at offset 314\" }\n-  T ((pma + 1)->ax, 1);   // { dg-warning \"'strcpy' offset \\\\\\[314, 315] from the object at 'pma' is out of the bounds of referenced subobject 'ax' with type 'char\\\\\\[]' at offset 314\" }\n-  T ((pma + 1)[1].ax, 2); // { dg-warning \"'strcpy' offset \\\\\\[471, 473] from the object at 'pma' is out of the bounds of referenced subobject 'ax' with type 'char\\\\\\[]' at offset 471\" }\n-  T ((*(pma + 2)).ax, 2); // { dg-warning \"'strcpy' offset \\\\\\[471, 473] from the object at 'pma' is out of the bounds of referenced subobject 'ax' with type 'char\\\\\\[]' at offset 471\" }\n-  T (pma[3].ax, 9);       // { dg-warning \"'strcpy' offset \\\\\\[628, 637] from the object at 'pma' is out of the bounds of referenced subobject 'ax' with type 'char\\\\\\[]' at offset 628\" }\n+  T (pma[1].ax, 0);       // { dg-warning \"'strcpy' offset 314 from the object at 'pma' is out of the bounds of referenced subobject 'ax' with type 'char\\\\\\[0]' at offset 314\" }\n+  T ((pma + 1)->ax, 1);   // { dg-warning \"'strcpy' offset \\\\\\[314, 315] from the object at 'pma' is out of the bounds of referenced subobject 'ax' with type 'char\\\\\\[0]' at offset 314\" }\n+  T ((pma + 1)[1].ax, 2); // { dg-warning \"'strcpy' offset \\\\\\[471, 473] from the object at 'pma' is out of the bounds of referenced subobject 'ax' with type 'char\\\\\\[0]' at offset 471\" }\n+  T ((*(pma + 2)).ax, 2); // { dg-warning \"'strcpy' offset \\\\\\[471, 473] from the object at 'pma' is out of the bounds of referenced subobject 'ax' with type 'char\\\\\\[0]' at offset 471\" }\n+  T (pma[3].ax, 9);       // { dg-warning \"'strcpy' offset \\\\\\[628, 637] from the object at 'pma' is out of the bounds of referenced subobject 'ax' with type 'char\\\\\\[0]' at offset 628\" }\n \n   T (pma[-1].a1, 0);\n   T (pma[-1].a1, 1);      // { dg-warning \"'strcpy' offset -152 from the object at 'pma' is out of the bounds of referenced subobject 'a1' with type 'char\\\\\\[1]' at offset -153\" }"}, {"sha": "d6a327e36894d0c8974fdd36c9eb9597bff41cbb", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-48.c", "status": "added", "additions": 363, "deletions": 0, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-48.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-48.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-48.c?ref=49fb45c81f4ac068d9fb859968d8f223bc438251", "patch": "@@ -0,0 +1,363 @@\n+/* PR middle-end/91647 - missing -Warray-bounds accessing a zero-length array\n+   of a declared object\n+   { dg-do \"compile\" }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+typedef __INT16_TYPE__ int16_t;\n+typedef __INT32_TYPE__ int32_t;\n+\n+void sink (void*);\n+\n+/* Exercise a true flexible member.  */\n+\n+struct AX\n+{\n+  int32_t n;\n+  int16_t ax[];     // { dg-message \"while referencing 'ax'\" \"member\" }\n+};\n+\n+static void warn_ax_local (struct AX *p)\n+{\n+  p->ax[0] = 0;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->ax[1] = 1;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+static void nowarn_ax_extern (struct AX *p)\n+{\n+  p->ax[0] = 0; p->ax[99] = 99; p->ax[999] = 999; p->ax[9999] = 9999;\n+}\n+\n+static void warn_ax_local_buf (struct AX *p)\n+{\n+  p->ax[0] = 4; p->ax[1] = 5;\n+\n+  p->ax[2] = 6;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->ax[3] = 7;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->ax[4] = 8;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+static void warn_ax_extern_buf (struct AX *p)\n+{\n+  p->ax[0] = 9; p->ax[1] = 10; p->ax[2] = 11;\n+\n+  p->ax[3] = 12;    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->ax[4] = 13;    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->ax[5] = 14;    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+static void nowarn_ax_extern_bufx (struct AX *p)\n+{\n+  p->ax[0] = 0; p->ax[99] = 99; p->ax[999] = 999; p->ax[9999] = 9999;\n+}\n+\n+static void nowarn_ax_ref (struct AX *p)\n+{\n+  p->ax[0] = 0; p->ax[99] = 99; p->ax[999] = 999; p->ax[9999] = 9999;\n+}\n+\n+void test_ax (struct AX *p, unsigned n)\n+{\n+  {\n+    struct AX sax;  // { dg-message \"defined here\" \"struct definition\" }\n+    warn_ax_local (&sax);\n+    sink (&sax);\n+  }\n+\n+  {\n+    extern\n+      struct AX xsax;\n+    nowarn_ax_extern (&xsax);\n+    sink (&xsax);\n+  }\n+\n+  {\n+    /* Verify out-of-bounds access to the local BUF is diagnosed.  */\n+    char ax_buf_p2[sizeof (struct AX) + 2 * sizeof (int16_t)];\n+    warn_ax_local_buf ((struct AX*) ax_buf_p2);\n+    sink (ax_buf_p2);\n+  }\n+\n+  {\n+    /* Verify out-of-bounds access to the extern BUF with a known\n+       bound is diagnosed.  */\n+    extern char ax_buf_p3[sizeof (struct AX) + 3 * sizeof (int16_t)];\n+    warn_ax_extern_buf ((struct AX*) ax_buf_p3);\n+    sink (ax_buf_p3);\n+  }\n+\n+  {\n+    /* Verify that accesses to BUFX with an unknown bound are not\n+       diagnosed.  */\n+    extern char bufx[];\n+    nowarn_ax_extern_bufx ((struct AX*) bufx);\n+    sink (bufx);\n+  }\n+\n+  {\n+    /* Verify that accesses to BUFN with a runtime bound are not\n+       diagnosed.  */\n+    char bufn[n];\n+    nowarn_ax_extern_bufx ((struct AX*) bufn);\n+    sink (bufn);\n+  }\n+\n+  nowarn_ax_ref (p);\n+}\n+\n+\n+/* Exercise a zero-length trailing member array.  It's the same as above\n+   except that extern declarations with no definitions are considered to\n+   have zero elements (they can't be initialized to have any).  */\n+\n+struct A0\n+{\n+  int32_t n;\n+  int16_t a0[0];    // { dg-message \"while referencing 'a0'\" \"member\" }\n+};\n+\n+static void warn_a0_local (struct A0 *p)\n+{\n+  p->a0[0] = 0;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->a0[1] = 1;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+static void warn_a0_extern (struct A0 *p)\n+{\n+  p->a0[0] = 2;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->a0[1] = 3;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+static void warn_a0_local_buf (struct A0 *p)\n+{\n+  p->a0[0] = 4; p->a0[1] = 5;\n+\n+  p->a0[2] = 6;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->a0[3] = 7;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->a0[4] = 8;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+static void warn_a0_extern_buf (struct A0 *p)\n+{\n+  p->a0[0] = 9; p->a0[1] = 10; p->a0[2] = 11;\n+\n+  p->a0[3] = 12;    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->a0[4] = 13;    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->a0[5] = 14;    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+static void nowarn_a0_extern_bufx (struct A0 *p)\n+{\n+  p->a0[0] = 0; p->a0[99] = 99; p->a0[999] = 999; p->a0[9999] = 9999;\n+}\n+\n+static void nowarn_a0_ref (struct A0 *p)\n+{\n+  p->a0[0] = 0; p->a0[99] = 99; p->a0[999] = 999; p->a0[9999] = 9999;\n+}\n+\n+void test_a0 (struct A0 *p, unsigned n)\n+{\n+  {\n+    struct A0 sa0;  // { dg-message \"defined here\" \"struct definition\" }\n+    warn_a0_local (&sa0);\n+    sink (&sa0);\n+  }\n+\n+  {\n+    extern\n+      struct A0 xsa0;  // { dg-message \"defined here\" \"struct definition\" }\n+    warn_a0_extern (&xsa0);\n+    sink (&xsa0);\n+  }\n+\n+  {\n+    /* Verify out-of-bounds access to the local BUF is diagnosed.  */\n+    char a0_buf_p2[sizeof (struct A0) + 2 * sizeof (int16_t)];\n+    warn_a0_local_buf ((struct A0*) a0_buf_p2);\n+    sink (a0_buf_p2);\n+  }\n+\n+  {\n+    /* Verify out-of-bounds access to the extern BUF with a known\n+       bound is diagnosed.  */\n+    extern char a0_buf_p3[sizeof (struct A0) + 3 * sizeof (int16_t)];\n+    warn_a0_extern_buf ((struct A0*) a0_buf_p3);\n+    sink (a0_buf_p3);\n+  }\n+\n+  {\n+    /* Verify that accesses to BUFX with an unknown bound are not\n+       diagnosed.  */\n+    extern char bufx[];\n+    nowarn_a0_extern_bufx ((struct A0*) bufx);\n+    sink (bufx);\n+  }\n+\n+  {\n+    /* Verify that accesses to BUFN with a runtime bound are not\n+       diagnosed.  */\n+    char bufn[n];\n+    nowarn_a0_extern_bufx ((struct A0*) bufn);\n+    sink (bufn);\n+  }\n+\n+  nowarn_a0_ref (p);\n+}\n+\n+\n+/* Exercise a one-element trailing member array.  It's the same as above\n+   except that it has exactly one element.  */\n+\n+struct A1\n+{\n+  int32_t n;\n+  int16_t a1[1];    // { dg-message \"while referencing 'a1'\" }\n+};\n+\n+static void warn_a1_local_noinit (struct A1 *p)\n+{\n+  p->a1[0] = 0;\n+  p->a1[1] = 1;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->a1[2] = 2;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+static void warn_a1_extern (struct A1 *p)\n+{\n+  p->a1[0] = 0;\n+  p->a1[1] = 1;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->a1[2] = 2;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+static void warn_a1_init (struct A1 *p)\n+{\n+  p->a1[0] = 0;\n+  p->a1[1] = 1;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->a1[2] = 2;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+static void warn_a1_local_buf (struct A1 *p)\n+{\n+  p->a1[0] = 0; p->a1[1] = 1; p->a1[2] = 2; p->a1[3] = 3;\n+\n+  p->a1[4] = 4;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+static void warn_a1_extern_buf (struct A1 *p)\n+{\n+  p->a1[0] = 0; p->a1[1] = 1; p->a1[2] = 2; p->a1[3] = 3; p->a1[4] = 4;\n+\n+  p->a1[5] = 5;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+static void nowarn_a1_extern_bufx (struct A1 *p)\n+{\n+  p->a1[0] = 0; p->a1[99] = 99; p->a1[999] = 999; p->a1[9999] = 9999;\n+}\n+\n+static void nowarn_a1_ref (struct A1 *p)\n+{\n+  p->a1[0] = 0; p->a1[99] = 99; p->a1[999] = 999; p->a1[9999] = 9999;\n+}\n+\n+void test_a1 (struct A1 *p, unsigned n)\n+{\n+  {\n+    struct A1 a1;\n+    warn_a1_local_noinit (&a1);\n+    sink (&a1);\n+  }\n+\n+  {\n+    extern struct A1 a1x;\n+    warn_a1_extern (&a1x);\n+    sink (&a1x);\n+}\n+  {\n+    struct A1 a1 = { 0, { 1 } };\n+    warn_a1_init (&a1);\n+    sink (&a1);\n+  }\n+\n+  {\n+    /* Verify out-of-bounds access to the local BUF is diagnosed.  */\n+    char buf_p2[sizeof (struct A1) + 2 * sizeof (int16_t)];\n+    warn_a1_local_buf ((struct A1*) buf_p2);\n+    sink (buf_p2);\n+  }\n+\n+  {\n+    /* Verify out-of-bounds access to the extern BUF with a known\n+       bound is diagnosed.  */\n+    extern char a1_buf_p3[sizeof (struct A1) + 3 * sizeof (int16_t)];\n+    warn_a1_extern_buf ((struct A1*) a1_buf_p3);\n+    sink (a1_buf_p3);\n+  }\n+\n+  {\n+    /* Verify that accesses to BUFX with an unknown bound are not\n+       diagnosed.  */\n+    extern char bufx[];\n+    nowarn_a1_extern_bufx ((struct A1*) bufx);\n+    sink (bufx);\n+  }\n+\n+  {\n+    /* Verify that accesses to BUFN with a runtime bound are not\n+       diagnosed.  */\n+    char bufn[n];\n+    nowarn_a1_extern_bufx ((struct A1*) bufn);\n+    sink (bufn);\n+  }\n+\n+  nowarn_a1_ref (p);\n+}\n+\n+\n+/* Exercise a two-element trailing member array.  It's treated\n+   the same as an interior array member.  */\n+\n+struct A2\n+{\n+  int32_t n;\n+  int16_t a2[2];    // { dg-message \"while referencing 'a2'\" }\n+};\n+\n+static void warn_a2_noinit (struct A2 *p)\n+{\n+  p->a2[0] = 0; p->a2[1] = 1;\n+\n+  p->a2[2] = 2;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+static void warn_a2_init (struct A2 *p)\n+{\n+  p->a2[0] = 0; p->a2[1] = 1;\n+\n+  p->a2[2] = 2;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->a2[9] = 9;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+static void warn_a2_ref (struct A2 *p)\n+{\n+  p->a2[0] = 0; p->a2[1] = 1;\n+\n+  p->a2[2] = 2;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->a2[9] = 9;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+void test_a2 (struct A2 *p)\n+{\n+  {\n+    struct A2 a2;\n+    warn_a2_noinit (&a2);\n+    sink (&a2);\n+  }\n+\n+  {\n+    struct A2 a2 = { 0, { 1, 2 } };\n+    warn_a2_init (&a2);\n+    sink (&a2);\n+  }\n+\n+  warn_a2_ref (p);\n+}"}, {"sha": "7a847acf4d219970ef2cba3ae3bca2df6519716c", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-49.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-49.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-49.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-49.c?ref=49fb45c81f4ac068d9fb859968d8f223bc438251", "patch": "@@ -0,0 +1,115 @@\n+/* PR middle-end/91647 - missing -Warray-bounds accessing a zero-length array\n+   of a declared object\n+   { dg-do \"compile\" }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+struct __attribute__ ((aligned (16))) A16\n+{\n+  __INT64_TYPE__ i8;\n+  __INT16_TYPE__ i2;\n+  __INT16_TYPE__ a2[];\n+};\n+\n+struct A16 a0 = { };\n+\n+void test_a0 (void)\n+{\n+  // The first three elements fit in the tail padding.\n+  a0.a2[0] = 0; a0.a2[1] = 1; a0.a2[2] = 2;\n+\n+  a0.a2[3] = 3;     // { dg-warning \"array subscript 3 is above array bounds of 'short int\\\\\\[0]'\" }\n+}\n+\n+\n+struct A16 a1 = { .a2 = { 1 } };\n+\n+void test_a1 (void)\n+{\n+  a1.a2[0] = 0; a1.a2[1] = 1; a1.a2[2] = 2;\n+\n+  a1.a2[3] = 3;     // { dg-warning \"array subscript 3 is above array bounds of 'short int\\\\\\[0]'\" }\n+}\n+\n+\n+struct A16 a2 = { .a2 = { 1, 2 } };\n+\n+void test_a2 (void)\n+{\n+  a2.a2[0] = 0; a2.a2[1] = 1; a2.a2[2] = 2;\n+\n+  a2.a2[3] = 3;     // { dg-warning \"array subscript 3 is above array bounds of 'short int\\\\\\[0]'\" }\n+}\n+\n+\n+struct A16 a3 = { .a2 = { 1, 2, 3 } };\n+\n+void test_a3 (void)\n+{\n+  a3.a2[0] = 0; a3.a2[1] = 1; a3.a2[2] = 2;\n+\n+  a3.a2[3] = 3;     // { dg-warning \"array subscript 3 is above array bounds of 'short int\\\\\\[0]'\" }\n+}\n+\n+\n+struct A16 a4 = { .a2 = { 1, 2, 3, 4 } };\n+\n+void test_a4 (void)\n+{\n+  a4.a2[0] = 0; a4.a2[1] = 1; a4.a2[2] = 2; a4.a2[3] = 3;\n+\n+  a4.a2[4] = 4;     // { dg-warning \"array subscript 4 is above array bounds of 'short int\\\\\\[0]'\" }\n+}\n+\n+\n+struct A16 a5 = { .a2 = { 1, 2, 3, 4, 5 } };\n+\n+void test_a5 (void)\n+{\n+  a5.a2[0] = 0; a5.a2[1] = 1; a5.a2[2] = 2; a5.a2[3] = 3; a5.a2[4] = 4;\n+\n+  a5.a2[5] = 5;     // { dg-warning \"array subscript 5 is above array bounds of 'short int\\\\\\[0]'\" }\n+}\n+\n+\n+struct A16 a6 = { .a2 = { 1, 2, 3, 4, 5, 6 } };\n+\n+void test_a6 (void)\n+{\n+  a6.a2[0] = 0; a6.a2[1] = 1; a6.a2[2] = 2; a6.a2[3] = 3; a6.a2[4] = 4;\n+  a6.a2[5] = 5;\n+\n+  a6.a2[6] = 6;     // { dg-warning \"array subscript 6 is above array bounds of 'short int\\\\\\[0]'\" }\n+}\n+\n+\n+struct A16 a7 = { .a2 = { 1, 2, 3, 4, 5, 6, 7 } };\n+\n+void test_a7 (void)\n+{\n+  a7.a2[0] = 0; a7.a2[1] = 1; a7.a2[2] = 2; a7.a2[3] = 3; a7.a2[4] = 4;\n+  a7.a2[5] = 5; a7.a2[5] = 5; a7.a2[6] = 6;\n+\n+  a7.a2[7] = 7;     // { dg-warning \"array subscript 7 is above array bounds of 'short int\\\\\\[0]'\" }\n+}\n+\n+\n+struct A16 a8 = { .a2 = { 1, 2, 3, 4, 5, 6, 7, 8 } };\n+\n+void test_a8 (void)\n+{\n+  a8.a2[0] = 0; a8.a2[1] = 1; a8.a2[2] = 2; a8.a2[3] = 3; a8.a2[4] = 4;\n+  a8.a2[5] = 5; a8.a2[5] = 5; a8.a2[6] = 6; a8.a2[7] = 7;\n+\n+  a8.a2[8] = 8;     // { dg-warning \"array subscript 8 is above array bounds of 'short int\\\\\\[0]'\" }\n+}\n+\n+\n+struct A16 a9 = { .a2 = { 1, 2, 3, 4, 5, 6, 7, 8, 9 } };\n+\n+void test_a9 (void)\n+{\n+  a8.a2[0] = 8; a8.a2[1] = 7; a8.a2[2] = 6; a8.a2[3] = 5; a8.a2[4] = 4;\n+  a8.a2[5] = 3; a8.a2[5] = 2; a8.a2[6] = 1; a8.a2[7] = 0;\n+\n+  a8.a2[9] = 8;     // { dg-warning \"array subscript 9 is above array bounds of 'short int\\\\\\[0]'\" }\n+}"}, {"sha": "11fb05e730a799f58075e0031257df25ca994792", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-16.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-16.c?ref=49fb45c81f4ac068d9fb859968d8f223bc438251", "patch": "@@ -3,7 +3,7 @@\n    { dg-options \"-O2 -Wall\" } */\n \n struct charseq {\n-  unsigned char bytes[0];         // { dg-message \"object declared here\" }\n+  unsigned char bytes[0];         // { dg-message \"while referencing|object declared here\" }\n };\n \n struct locale_ctype_t {\n@@ -15,7 +15,7 @@ void ctype_finish (struct locale_ctype_t *ctype)\n   long unsigned int cnt;\n   for (cnt = 0; cnt < 20; ++cnt) {\n     static struct charseq replace[2];\n-    replace[0].bytes[1] = '\\0';   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+    replace[0].bytes[1] = '\\0';   // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" }\n     ctype->mboutdigits[cnt] = &replace[0];\n   }\n }"}, {"sha": "3a27460220c0dbb8c7bf72342cb9536deef6c6f7", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-21.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-21.c?ref=49fb45c81f4ac068d9fb859968d8f223bc438251", "patch": "@@ -0,0 +1,59 @@\n+/* PR middle-end/92312 - bogus -Wstringop-overflow storing into a trailing\n+   array backed by larger buffer\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-array-bounds\" } */\n+\n+struct S0 { char a, b[0]; };\n+\n+void sink (void*);\n+\n+void test_memset_zero_length (void)\n+{\n+  char a[3];\n+  struct S0 *p = (struct S0*)a;\n+  p->a = 0;\n+  __builtin_memset (p->b, 0, 2);\n+  sink (p);\n+\n+  __builtin_memset (p->b, 0, 3);    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  sink (p);\n+}\n+\n+void test_store_zero_length (int i)\n+{\n+  char a[3];\n+  struct S0 *p = (struct S0*)a;\n+  p->a = 0;\n+  p->b[0] = 0;\n+  p->b[1] = 1;                      // { dg-bogus \"\\\\\\[-Wstringop-overflow\" }\n+  p->b[2] = 2;                      // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  p->b[i] = 2;\n+  sink (p);\n+}\n+\n+\n+struct Sx { char a, b[]; };\n+\n+void test_memset_flexarray (int i)\n+{\n+  char a[3];\n+  struct Sx *p = (struct Sx*)a;\n+  p->a = 0;\n+  __builtin_memset (p->b, 0, 2);\n+  sink (p);\n+\n+  __builtin_memset (p->b, 0, 3);    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  sink (p);\n+}\n+\n+void test_store_flexarray (int i)\n+{\n+  char a[3];\n+  struct Sx *p = (struct Sx*)a;\n+  p->a = 0;\n+  p->b[0] = 0;\n+  p->b[1] = 1;                      // { dg-bogus \"\\\\\\[-Wstringop-overflow\" }\n+  p->b[2] = 1;                      // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  p->b[i] = 2;\n+  sink (p);\n+}"}, {"sha": "8e880d92dead380ca012db6a50710cd4f0e70b95", "filename": "gcc/testsuite/gcc.dg/Wzero-length-array-bounds.c", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Ftestsuite%2Fgcc.dg%2FWzero-length-array-bounds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Ftestsuite%2Fgcc.dg%2FWzero-length-array-bounds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWzero-length-array-bounds.c?ref=49fb45c81f4ac068d9fb859968d8f223bc438251", "patch": "@@ -0,0 +1,88 @@\n+/* PR middle-end/91647 - missing -Warray-bounds accessing a zero-length array\n+   of a declared object\n+   Test to exercise -Wzero-length-bounds.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+void sink (void*);\n+\n+struct X { int a[0]; int b, c; };\n+\n+extern struct X x;\n+\n+void bad (int i, int j)\n+{\n+  x.a[0] = 0;           // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  x.a[1] = 1;           // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  x.a[2] = 2;           // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  x.a[i] = 3;           // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  x.a[j] = 4;           // { dg-warning \"array subscript 'j' is outside the bounds of an interior zero-length array\" }\n+}\n+\n+void access_by_reference (struct X *p, int i)\n+{\n+  p->a[0] = 0;          // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  p->a[1] = 0;          // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  p->a[2] = 0;          // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  p->a[i] = 0;          // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+}\n+\n+\n+extern struct X a[2];\n+\n+void access_to_array (int i)\n+{\n+  a[0].a[0] = 0;        // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  a[0].a[1] = 1;        // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  /* Accesses to a subsequent element of the enclosing array seem like\n+     a more sever problem than those to the next member of the same\n+     struct and so might perhaps be better diagnosed by -Warray-bounds.\n+     Then again, code that does this sort of crap might as well get what\n+     it deserves if it disables -Wzero-length-bounds.  */\n+  a[0].a[2] = 2;        // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+\n+  a[0].a[i] = 3;        // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  sink (a);\n+\n+  a[1].a[0] = 4;        // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  a[1].a[1] = 5;        // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  a[1].a[2] = 6;        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  a[1].a[i] = 7;        // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  sink (a);\n+\n+  a[i].a[0] = 8;        // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  a[i].a[1] = 9;        // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  a[i].a[2] = 0;        // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+}\n+\n+\n+struct Y\n+{\n+  struct X a[2], b;\n+  int c;\n+};\n+\n+extern struct Y y;\n+\n+void access_to_member (int i)\n+{\n+  y.a[0].a[0] = 0;      // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  y.a[0].a[1] = 0;      // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  y.a[0].a[2] = 0;      // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  sink (a);\n+\n+  y.a[1].a[0] = 0;      // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  y.a[1].a[1] = 0;      // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  /* Similar to the array case above, accesses to a subsequent member\n+     of the \"parent\" struct seem like a more severe problem than those\n+     to the next member of the same struct.  */\n+  y.a[1].a[2] = 0;      // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  sink (a);\n+\n+  y.b.a[0] = 0;         // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  y.b.a[1] = 0;         // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  y.b.a[2] = 0;         // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  y.b.a[3] = 0;         // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}"}, {"sha": "cc8650ccb3b0a7fcfe317116168060054c73388f", "filename": "gcc/testsuite/gcc.dg/pr36902.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Ftestsuite%2Fgcc.dg%2Fpr36902.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Ftestsuite%2Fgcc.dg%2Fpr36902.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr36902.c?ref=49fb45c81f4ac068d9fb859968d8f223bc438251", "patch": "@@ -44,7 +44,7 @@ foo2(unsigned char * to, const unsigned char * from, int n)\n       *to = *from;\n       break;\n     case 5:\n-      to[4] = from [4]; /* { dg-warning \"array subscript is above array bounds\" \"\" { xfail *-*-* } } */\n+      to[4] = from [4]; /* { dg-warning \"\\\\\\[-Warray-bounds } */\n       break;\n     }\n   return to;"}, {"sha": "b7212bcf7957da946b3ea6add25e8d9c50c72d86", "filename": "gcc/testsuite/gcc.dg/strlenopt-57.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-57.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-57.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-57.c?ref=49fb45c81f4ac068d9fb859968d8f223bc438251", "patch": "@@ -21,7 +21,7 @@ void test_var_flexarray_cst_off (void)\n {\n   /* Use arbitrary constants greater than 16 in case GCC ever starts\n      unrolling strlen() calls with small array arguments.  */\n-  a[0] = 17 < strlen (a0.a + 1);\n+  a[0] = 17 < strlen (a0.a + 1);        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n   a[1] = 19 < strlen (a1.a + 1);\n   a[2] = 23 < strlen (a9.a + 9);\n   a[3] = 29 < strlen (ax.a + 3);"}, {"sha": "31258615247c8ed7a74745bab09095955ecd635a", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 77, "deletions": 31, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=49fb45c81f4ac068d9fb859968d8f223bc438251", "patch": "@@ -4122,7 +4122,6 @@ bool\n vrp_prop::check_array_ref (location_t location, tree ref,\n \t\t\t   bool ignore_off_by_one)\n {\n-  const value_range *vr = NULL;\n   tree low_sub, up_sub;\n   tree low_bound, up_bound, up_bound_p1;\n \n@@ -4132,6 +4131,9 @@ vrp_prop::check_array_ref (location_t location, tree ref,\n   low_sub = up_sub = TREE_OPERAND (ref, 1);\n   up_bound = array_ref_up_bound (ref);\n \n+  /* Set for accesses to interior zero-length arrays.  */\n+  bool interior_zero_len = false;\n+\n   if (!up_bound\n       || TREE_CODE (up_bound) != INTEGER_CST\n       || (warn_array_bounds < 2\n@@ -4152,11 +4154,22 @@ vrp_prop::check_array_ref (location_t location, tree ref,\n \t}\n       else\n \t{\n-\t  tree maxbound = TYPE_MAX_VALUE (ptrdiff_type_node);\n+\t  tree ptrdiff_max = TYPE_MAX_VALUE (ptrdiff_type_node);\n+\t  tree maxbound = ptrdiff_max;\n \t  tree arg = TREE_OPERAND (ref, 0);\n \t  poly_int64 off;\n \n-\t  if (get_addr_base_and_unit_offset (arg, &off) && known_gt (off, 0))\n+\t  if (TREE_CODE (arg) == COMPONENT_REF)\n+\t    {\n+\t      /* Try to determine the size of the trailing array from\n+\t\t its initializer (if it has one).  */\n+\t      if (tree refsize = component_ref_size (arg, &interior_zero_len))\n+\t\tmaxbound = refsize;\n+\t    }\n+\n+\t  if (maxbound == ptrdiff_max\n+\t      && get_addr_base_and_unit_offset (arg, &off)\n+\t      && known_gt (off, 0))\n \t    maxbound = wide_int_to_tree (sizetype,\n \t\t\t\t\t wi::sub (wi::to_wide (maxbound),\n \t\t\t\t\t\t  off));\n@@ -4185,6 +4198,7 @@ vrp_prop::check_array_ref (location_t location, tree ref,\n \t\t\t \"array subscript %E is above array bounds of %qT\",\n \t\t\t low_bound, artype);\n \n+  const value_range *vr = NULL;\n   if (TREE_CODE (low_sub) == SSA_NAME)\n     {\n       vr = get_value_range (low_sub);\n@@ -4195,7 +4209,9 @@ vrp_prop::check_array_ref (location_t location, tree ref,\n         }\n     }\n \n-  if (vr && vr->kind () == VR_ANTI_RANGE)\n+  if (warned)\n+    ; /* Do nothing.  */\n+  else if (vr && vr->kind () == VR_ANTI_RANGE)\n     {\n       if (up_bound\n \t  && TREE_CODE (up_sub) == INTEGER_CST\n@@ -4214,39 +4230,51 @@ vrp_prop::check_array_ref (location_t location, tree ref,\n \t   && (ignore_off_by_one\n \t       ? !tree_int_cst_le (up_sub, up_bound_p1)\n \t       : !tree_int_cst_le (up_sub, up_bound)))\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"Array bound warning for \");\n-\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, ref);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-      warned = warning_at (location, OPT_Warray_bounds,\n-\t\t\t   \"array subscript %E is above array bounds of %qT\",\n-\t\t\t   up_sub, artype);\n-    }\n+    warned = warning_at (location, OPT_Warray_bounds,\n+\t\t\t \"array subscript %E is above array bounds of %qT\",\n+\t\t\t up_sub, artype);\n   else if (TREE_CODE (low_sub) == INTEGER_CST\n            && tree_int_cst_lt (low_sub, low_bound))\n+    warned = warning_at (location, OPT_Warray_bounds,\n+\t\t\t \"array subscript %E is below array bounds of %qT\",\n+\t\t\t low_sub, artype);\n+\n+  if (!warned && interior_zero_len)\n+    warned = warning_at (location, OPT_Wzero_length_bounds,\n+\t\t\t (TREE_CODE (low_sub) == INTEGER_CST\n+\t\t\t  ? G_(\"array subscript %E is outside the bounds \"\n+\t\t\t       \"of an interior zero-length array %qT\")\n+\t\t\t  : G_(\"array subscript %qE is outside the bounds \"\n+\t\t\t       \"of an interior zero-length array %qT\")),\n+\t\t\t low_sub, artype);\n+\n+  if (warned)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"Array bound warning for \");\n \t  dump_generic_expr (MSG_NOTE, TDF_SLIM, ref);\n \t  fprintf (dump_file, \"\\n\");\n \t}\n-      warned = warning_at (location, OPT_Warray_bounds,\n-\t\t\t   \"array subscript %E is below array bounds of %qT\",\n-\t\t\t   low_sub, artype);\n-    }\n \n-  if (warned)\n-    {\n       ref = TREE_OPERAND (ref, 0);\n+\n+      tree rec = NULL_TREE;\n       if (TREE_CODE (ref) == COMPONENT_REF)\n-\tref = TREE_OPERAND (ref, 1);\n+\t{\n+\t  /* For a reference to a member of a struct object also mention\n+\t     the object if it's known.  It may be defined in a different\n+\t     function than the out-of-bounds access.  */\n+\t  rec = TREE_OPERAND (ref, 0);\n+\t  if (!VAR_P (rec))\n+\t    rec = NULL_TREE;\n+\t  ref = TREE_OPERAND (ref, 1);\n+\t}\n \n       if (DECL_P (ref))\n \tinform (DECL_SOURCE_LOCATION (ref), \"while referencing %qD\", ref);\n+      if (rec && DECL_P (rec))\n+\tinform (DECL_SOURCE_LOCATION (rec), \"defined here %qD\", rec);\n \n       TREE_NO_WARNING (ref) = 1;\n     }\n@@ -4391,16 +4419,21 @@ vrp_prop::check_mem_ref (location_t location, tree ref,\n   /* The type of the object being referred to.  It can be an array,\n      string literal, or a non-array type when the MEM_REF represents\n      a reference/subscript via a pointer to an object that is not\n-     an element of an array.  References to members of structs and\n-     unions are excluded because MEM_REF doesn't make it possible\n-     to identify the member where the reference originated.\n-     Incomplete types are excluded as well because their size is\n-     not known.  */\n+     an element of an array.  Incomplete types are excluded as well\n+     because their size is not known.  */\n   tree reftype = TREE_TYPE (arg);\n   if (POINTER_TYPE_P (reftype)\n       || !COMPLETE_TYPE_P (reftype)\n-      || TREE_CODE (TYPE_SIZE_UNIT (reftype)) != INTEGER_CST\n-      || RECORD_OR_UNION_TYPE_P (reftype))\n+      || TREE_CODE (TYPE_SIZE_UNIT (reftype)) != INTEGER_CST)\n+    return false;\n+\n+  /* Except in declared objects, references to trailing array members\n+     of structs and union objects are excluded because MEM_REF doesn't\n+     make it possible to identify the member where the reference\n+     originated.  */\n+  if (RECORD_OR_UNION_TYPE_P (reftype)\n+      && (!VAR_P (arg)\n+\t  || (DECL_EXTERNAL (arg) && array_at_struct_end_p (ref))))\n     return false;\n \n   arrbounds[0] = 0;\n@@ -4412,7 +4445,14 @@ vrp_prop::check_mem_ref (location_t location, tree ref,\n       if (tree dom = TYPE_DOMAIN (reftype))\n \t{\n \t  tree bnds[] = { TYPE_MIN_VALUE (dom), TYPE_MAX_VALUE (dom) };\n-\t  if (array_at_struct_end_p (arg) || !bnds[0] || !bnds[1])\n+\t  if (TREE_CODE (arg) == COMPONENT_REF)\n+\t    {\n+\t      offset_int size = maxobjsize;\n+\t      if (tree fldsize = component_ref_size (arg))\n+\t\tsize = wi::to_offset (fldsize);\n+\t      arrbounds[1] = wi::lrshift (size, wi::floor_log2 (eltsize));\n+\t    }\n+\t  else if (array_at_struct_end_p (arg) || !bnds[0] || !bnds[1])\n \t    arrbounds[1] = wi::lrshift (maxobjsize, wi::floor_log2 (eltsize));\n \t  else\n \t    arrbounds[1] = (wi::to_offset (bnds[1]) - wi::to_offset (bnds[0])\n@@ -4434,7 +4474,13 @@ vrp_prop::check_mem_ref (location_t location, tree ref,\n   else\n     {\n       eltsize = 1;\n-      arrbounds[1] = wi::to_offset (TYPE_SIZE_UNIT (reftype));\n+      tree size = TYPE_SIZE_UNIT (reftype);\n+      if (VAR_P (arg))\n+\tif (tree initsize = DECL_SIZE_UNIT (arg))\n+\t  if (tree_int_cst_lt (size, initsize))\n+\t    size = initsize;\n+\n+      arrbounds[1] = wi::to_offset (size);\n     }\n \n   offrange[0] += ioff;"}, {"sha": "3299b344ea609b129c2e448e2cb8e21e73cec823", "filename": "gcc/tree.c", "status": "modified", "additions": 194, "deletions": 31, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=49fb45c81f4ac068d9fb859968d8f223bc438251", "patch": "@@ -3089,6 +3089,25 @@ first_field (const_tree type)\n   return t;\n }\n \n+/* Returns the last FIELD_DECL in the TYPE_FIELDS of the RECORD_TYPE or\n+   UNION_TYPE TYPE, or NULL_TREE if none.  */\n+\n+tree\n+last_field (const_tree type)\n+{\n+  tree last = NULL_TREE;\n+\n+  for (tree fld = TYPE_FIELDS (type); fld; fld = TREE_CHAIN (fld))\n+    {\n+      if (TREE_CODE (fld) != FIELD_DECL)\n+\tcontinue;\n+\n+      last = fld;\n+    }\n+\n+  return last;\n+}\n+\n /* Concatenate two chains of nodes (chained through TREE_CHAIN)\n    by modifying the last node in chain 1 to point to chain 2.\n    This is the Lisp primitive `nconc'.  */\n@@ -13363,8 +13382,8 @@ array_ref_up_bound (tree exp)\n   return NULL_TREE;\n }\n \n-/* Returns true if REF is an array reference or a component reference\n-   to an array at the end of a structure.\n+/* Returns true if REF is an array reference, component reference,\n+   or memory reference to an array at the end of a structure.\n    If this is the case, the array may be allocated larger\n    than its upper bound implies.  */\n \n@@ -13382,6 +13401,28 @@ array_at_struct_end_p (tree ref)\n   else if (TREE_CODE (ref) == COMPONENT_REF\n \t   && TREE_CODE (TREE_TYPE (TREE_OPERAND (ref, 1))) == ARRAY_TYPE)\n     atype = TREE_TYPE (TREE_OPERAND (ref, 1));\n+  else if (TREE_CODE (ref) == MEM_REF)\n+    {\n+      tree arg = TREE_OPERAND (ref, 0);\n+      if (TREE_CODE (arg) == ADDR_EXPR)\n+\targ = TREE_OPERAND (arg, 0);\n+      tree argtype = TREE_TYPE (arg);\n+      if (TREE_CODE (argtype) == RECORD_TYPE)\n+\t{\n+\t  if (tree fld = last_field (argtype))\n+\t    {\n+\t      atype = TREE_TYPE (fld);\n+\t      if (TREE_CODE (atype) != ARRAY_TYPE)\n+\t\treturn false;\n+\t      if (VAR_P (arg) && DECL_SIZE (fld))\n+\t\treturn false;\n+\t    }\n+\t  else\n+\t    return false;\n+\t}\n+      else\n+\treturn false;\n+    }\n   else\n     return false;\n \n@@ -13498,33 +13539,72 @@ component_ref_field_offset (tree exp)\n     return SUBSTITUTE_PLACEHOLDER_IN_EXPR (DECL_FIELD_OFFSET (field), exp);\n }\n \n+/* Given the initializer INIT, return the initializer for the field\n+   DECL if it exists, otherwise null.  Used to obtain the initializer\n+   for a flexible array member and determine its size.  */\n+\n+static tree\n+get_initializer_for (tree init, tree decl)\n+{\n+  STRIP_NOPS (init);\n+\n+  tree fld, fld_init;\n+  unsigned HOST_WIDE_INT i;\n+  FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (init), i, fld, fld_init)\n+    {\n+      if (decl == fld)\n+\treturn fld_init;\n+\n+      if (TREE_CODE (fld) == CONSTRUCTOR)\n+\t{\n+\t  fld_init = get_initializer_for (fld_init, decl);\n+\t  if (fld_init)\n+\t    return fld_init;\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Determines the size of the member referenced by the COMPONENT_REF\n    REF, using its initializer expression if necessary in order to\n    determine the size of an initialized flexible array member.\n+   If non-null, *INTERIOR_ZERO_LENGTH is set when REF refers to\n+   an interior zero-length array.\n    Returns the size (which might be zero for an object with\n    an uninitialized flexible array member) or null if the size\n    cannot be determined.  */\n \n tree\n-component_ref_size (tree ref)\n+component_ref_size (tree ref, bool *interior_zero_length /* = NULL */)\n {\n   gcc_assert (TREE_CODE (ref) == COMPONENT_REF);\n \n+  bool int_0_len = false;\n+  if (!interior_zero_length)\n+    interior_zero_length = &int_0_len;\n+\n   tree member = TREE_OPERAND (ref, 1);\n \n-  /* If the member is not an array, or is not last, or is an array with\n-     more than one element, return its size.  Otherwise it's either\n-     a bona fide flexible array member, or a zero-length array member,\n-     or an array of length one treated as such.  */\n-  tree size = DECL_SIZE_UNIT (member);\n-  if (size)\n+  tree memsize = DECL_SIZE_UNIT (member);\n+  if (memsize)\n     {\n       tree memtype = TREE_TYPE (member);\n-      if (TREE_CODE (memtype) != ARRAY_TYPE\n-\t  || !array_at_struct_end_p (ref))\n-\treturn size;\n+      if (TREE_CODE (memtype) != ARRAY_TYPE)\n+\treturn memsize;\n+\n+      bool trailing = array_at_struct_end_p (ref);\n+      bool zero_length = integer_zerop (memsize);\n+      if (!trailing && (!interior_zero_length || !zero_length))\n+\t/* MEMBER is either an interior array or is an array with\n+\t   more than one element.  */\n+\treturn memsize;\n+\n+      *interior_zero_length = zero_length && !trailing;\n+      if (*interior_zero_length)\n+\tmemsize = NULL_TREE;\n \n-      if (!integer_zerop (size))\n+      if (!zero_length)\n \tif (tree dom = TYPE_DOMAIN (memtype))\n \t  if (tree min = TYPE_MIN_VALUE (dom))\n \t    if (tree max = TYPE_MAX_VALUE (dom))\n@@ -13533,37 +13613,120 @@ component_ref_size (tree ref)\n \t\t{\n \t\t  offset_int minidx = wi::to_offset (min);\n \t\t  offset_int maxidx = wi::to_offset (max);\n-\t\t  if (maxidx - minidx > 1)\n-\t\t    return size;\n+\t\t  if (maxidx - minidx > 0)\n+\t\t    /* MEMBER is an array with more than 1 element.  */\n+\t\t    return memsize;\n \t\t}\n     }\n \n+  /* MEMBER is either a bona fide flexible array member, or a zero-length\n+     array member, or an array of length one treated as such.  */\n+\n   /* If the reference is to a declared object and the member a true\n      flexible array, try to determine its size from its initializer.  */\n-  poly_int64 off = 0;\n-  tree base = get_addr_base_and_unit_offset (ref, &off);\n+  poly_int64 baseoff = 0;\n+  tree base = get_addr_base_and_unit_offset (ref, &baseoff);\n   if (!base || !VAR_P (base))\n-    return NULL_TREE;\n+    {\n+      if (!*interior_zero_length)\n+\treturn NULL_TREE;\n \n-  /* The size of any member of a declared object other than a flexible\n-     array member is that obtained above.  */\n-  if (size)\n-    return size;\n+      if (TREE_CODE (TREE_OPERAND (ref, 0)) != COMPONENT_REF)\n+\treturn NULL_TREE;\n \n-  if (tree init = DECL_INITIAL (base))\n-    if (TREE_CODE (init) == CONSTRUCTOR)\n-      {\n-\toff <<= LOG2_BITS_PER_UNIT;\n-\tinit = fold_ctor_reference (NULL_TREE, init, off, 0, base);\n-\tif (init)\n-\t  return TYPE_SIZE_UNIT (TREE_TYPE (init));\n-      }\n+      base = TREE_OPERAND (ref, 0);\n+      baseoff = tree_to_poly_int64 (byte_position (TREE_OPERAND (ref, 1)));\n+    }\n+\n+  /* BASE is the declared object of which MEMBER is either a member\n+     or that is is cast to REFTYPE (e.g., a char buffer used to store\n+     a REFTYPE object).  */\n+  tree reftype = TREE_TYPE (TREE_OPERAND (ref, 0));\n+  tree basetype = TREE_TYPE (base);\n+\n+  /* Determine the base type of the referenced object.  If it's\n+     the same as REFTYPE and MEMBER has a known size, return it.  */\n+  tree bt = basetype;\n+  if (!*interior_zero_length)\n+    while (TREE_CODE (bt) == ARRAY_TYPE)\n+      bt = TREE_TYPE (bt);\n+  bool typematch = useless_type_conversion_p (reftype, bt);\n+  if (memsize && typematch)\n+    return memsize;\n+\n+  memsize = NULL_TREE;\n+\n+  /* MEMBER is a true flexible array member.  Compute its size from\n+     the initializer of the BASE object if it has one.  */\n+  if (tree init = DECL_P (base) ? DECL_INITIAL (base) : NULL_TREE)\n+    {\n+      init = get_initializer_for (init, member);\n+      if (init)\n+\t{\n+\t  memsize = TYPE_SIZE_UNIT (TREE_TYPE (init));\n+\t  if (tree refsize = TYPE_SIZE_UNIT (reftype))\n+\t    {\n+\t      /* Use the larger of the initializer size and the tail\n+\t\t padding in the enclosing struct.  */\n+\t      poly_int64 rsz = tree_to_poly_int64 (refsize);\n+\t      rsz -= baseoff;\n+\t      if (known_lt (tree_to_poly_int64 (memsize), rsz))\n+\t\tmemsize = wide_int_to_tree (TREE_TYPE (memsize), rsz);\n+\t    }\n+\n+\t  baseoff = 0;\n+\t}\n+    }\n+\n+  if (!memsize)\n+    {\n+      if (typematch)\n+\t{\n+\t  if (DECL_P (base)\n+\t      && DECL_EXTERNAL (base)\n+\t      && bt == basetype\n+\t      && !*interior_zero_length)\n+\t    /* The size of a flexible array member of an extern struct\n+\t       with no initializer cannot be determined (it's defined\n+\t       in another translation unit and can have an initializer\n+\t       witth an arbitrary number of elements).  */\n+\t    return NULL_TREE;\n+\n+\t  /* Use the size of the base struct or, for interior zero-length\n+\t     arrays, the size of the enclosing type.  */\n+\t  memsize = TYPE_SIZE_UNIT (bt);\n+\t}\n+      else\n+\t/* Use the size of the BASE object (possibly an array of some\n+\t   other type such as char used to store the struct).  */\n+\tmemsize = DECL_SIZE_UNIT (base);\n+    }\n+\n+  /* If the flexible array member has a known size use the greater\n+     of it and the tail padding in the enclosing struct.\n+     Otherwise, when the size of the flexible array member is unknown\n+     and the referenced object is not a struct, use the size of its\n+     type when known.  This detects sizes of array buffers when cast\n+     to struct types with flexible array members.  */\n+  if (memsize)\n+    {\n+      poly_int64 memsz64 = memsize ? tree_to_poly_int64 (memsize) : 0;\n+      if (known_lt (baseoff, memsz64))\n+\t{\n+\t  memsz64 -= baseoff;\n+\t  return wide_int_to_tree (TREE_TYPE (memsize), memsz64);\n+\t}\n+      return integer_zero_node;\n+    }\n \n   /* Return \"don't know\" for an external non-array object since its\n      flexible array member can be initialized to have any number of\n      elements.  Otherwise, return zero because the flexible array\n      member has no elements.  */\n-  return (DECL_EXTERNAL (base) && TREE_CODE (TREE_TYPE (base)) != ARRAY_TYPE\n+  return (DECL_P (base)\n+\t  && DECL_EXTERNAL (base)\n+\t  && (!typematch\n+\t      || TREE_CODE (basetype) != ARRAY_TYPE)\n \t  ? NULL_TREE : integer_zero_node);\n }\n "}, {"sha": "2ce001d546862b4cb2a9e7eaa4b9f89b9752e31a", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=49fb45c81f4ac068d9fb859968d8f223bc438251", "patch": "@@ -5262,7 +5262,7 @@ extern tree component_ref_field_offset (tree);\n    of an initialized flexible array member.  The size might be zero for\n    an object with an uninitialized flexible array member or null if it\n    cannot be determined.  */\n-extern tree component_ref_size (tree);\n+extern tree component_ref_size (tree, bool * = NULL);\n \n extern int tree_map_base_eq (const void *, const void *);\n extern unsigned int tree_map_base_hash (const void *);"}, {"sha": "5e0f444f9a6d050718c4ab0c6dea88c01ef88e6a", "filename": "gcc/wide-int.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Fwide-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49fb45c81f4ac068d9fb859968d8f223bc438251/gcc%2Fwide-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int.h?ref=49fb45c81f4ac068d9fb859968d8f223bc438251", "patch": "@@ -852,6 +852,8 @@ inline HOST_WIDE_INT\n generic_wide_int <storage>::sign_mask () const\n {\n   unsigned int len = this->get_len ();\n+  gcc_assert (len > 0);\n+\n   unsigned HOST_WIDE_INT high = this->get_val ()[len - 1];\n   if (!is_sign_extended)\n     {"}]}