{"sha": "cb0dee885cb30b4e9beeef070cf000baa7d09abe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2IwZGVlODg1Y2IzMGI0ZTliZWVlZjA3MGNmMDAwYmFhN2QwOWFiZQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2008-10-11T17:57:20Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2008-10-11T17:57:20Z"}, "message": "cpuid.h (__cpuid_count): New defines.\n\n\t* config/i386/cpuid.h (__cpuid_count): New defines.\n\t* config/i386/driver-i386.c (struct cache_desc): New structure.\n\t(describe_cache): Use struct cache_desc to pass cache descriptions.\n\t(detect_l2_cache): Ditto. Rename from decode_l2_cache.\n\t(detect_caches_amd): Use struct cache_desc to describe caches.\n\t(decode_caches_intel): Use struct cache_desc to pass cache\n\tdescriptions.  Update descriptions to match latest (rev -032,\n\tDecember 2007) CPUID documentation.  Do not check valid bit here.\n\tCheck for Xeon MP value 0x49 problems.\n\t(detect_caches_cpuid2): New function, split from detect_caches_intel.\n\tCheck valid bit before calling decode_caches_intel.  Detect number\n\tof times to repeat CPUID instruction.\n\t(detect_caches_cpuid4): New function.\n\t(detect_caches_intel): Depending on max_level, call\n\tdetect_caches_cpuid2 or detect_caches_cpuid4.  Call detect_l2_cache\n\tonly when other methods fail to provide valid L2 cache description.\n\nFrom-SVN: r141064", "tree": {"sha": "82b88e121092e9168fd4b16c14c94fd32cfccb64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82b88e121092e9168fd4b16c14c94fd32cfccb64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb0dee885cb30b4e9beeef070cf000baa7d09abe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb0dee885cb30b4e9beeef070cf000baa7d09abe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb0dee885cb30b4e9beeef070cf000baa7d09abe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb0dee885cb30b4e9beeef070cf000baa7d09abe/comments", "author": null, "committer": null, "parents": [{"sha": "e40375e0e23145c3140d375d3cf8f164800983ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e40375e0e23145c3140d375d3cf8f164800983ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e40375e0e23145c3140d375d3cf8f164800983ee"}], "stats": {"total": 527, "additions": 300, "deletions": 227}, "files": [{"sha": "a16fb6a82d1a76fa51394db5440e94ba26da1b5d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb0dee885cb30b4e9beeef070cf000baa7d09abe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb0dee885cb30b4e9beeef070cf000baa7d09abe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cb0dee885cb30b4e9beeef070cf000baa7d09abe", "patch": "@@ -1,3 +1,23 @@\n+2008-10-11  Uros Bizjak  <ubizjak@gmail.com>\n+\t    Andi Kleen  <ak@linux.intel.com>\n+\n+\t* config/i386/cpuid.h (__cpuid_count): New defines.\n+\t* config/i386/driver-i386.c (struct cache_desc): New structure.\n+\t(describe_cache): Use struct cache_desc to pass cache descriptions.\n+\t(detect_l2_cache): Ditto. Rename from decode_l2_cache.\n+\t(detect_caches_amd): Use struct cache_desc to describe caches.\n+\t(decode_caches_intel): Use struct cache_desc to pass cache\n+\tdescriptions.  Update descriptions to match latest (rev -032,\n+\tDecember 2007) CPUID documentation.  Do not check valid bit here.\n+\tCheck for Xeon MP value 0x49 problems.\n+\t(detect_caches_cpuid2): New function, split from detect_caches_intel.\n+\tCheck valid bit before calling decode_caches_intel.  Detect number\n+\tof times to repeat CPUID instruction.\n+\t(detect_caches_cpuid4): New function.\n+\t(detect_caches_intel): Depending on max_level, call\n+\tdetect_caches_cpuid2 or detect_caches_cpuid4.  Call detect_l2_cache\n+\tonly when other methods fail to provide valid L2 cache description.\n+\n 2008-10-11  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR middle-end/37608\n@@ -13,10 +33,10 @@\n \n 2008-10-11  David Edelsohn  <edelsohn@gnu.org>\n \n-        * config/rs6000/rs6000.md (aux_truncdfsf2): Remove TARGET_SINGLE_FLOAT.\n-        (addsf3, subsf3, mulsf3 ! TARGET_POWERPC): Remove TARGET_SINGLE_FLOAT\n-        and fp_type.\n-        (divdf3): Reformat long line.\n+\t* config/rs6000/rs6000.md (aux_truncdfsf2): Remove TARGET_SINGLE_FLOAT.\n+\t(addsf3, subsf3, mulsf3 ! TARGET_POWERPC): Remove TARGET_SINGLE_FLOAT\n+\tand fp_type.\n+\t(divdf3): Reformat long line.\n \n 2008-10-11  Michael J. Eager  <eager@eagercon.com>\n \n@@ -25,8 +45,7 @@\n \t(rs6000_handle_option): Process -mfpu options.\n \t* config/rs6000/rs6000.h: (TARGET_XILINX_FPU): New.\n \t(enum fpu_type_t): New.\n-\t* config/rs6000/rs6000.md (attr fp_type): New.\n-\tInclude xfpu.md.\n+\t* config/rs6000/rs6000.md (attr fp_type): New.  Include xfpu.md.\n \t(addsf3, subsf3, mulsf3, adddf3, subdf3, muldf3, trunctfdf2): Set\n \tfp_type.\n \t(floatsisf2): Remove TARGET_SINGLE_FPU condition."}, {"sha": "69d25a2fe1d0188c7d66cac9d4653295eefa2214", "filename": "gcc/config/i386/cpuid.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb0dee885cb30b4e9beeef070cf000baa7d09abe/gcc%2Fconfig%2Fi386%2Fcpuid.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb0dee885cb30b4e9beeef070cf000baa7d09abe/gcc%2Fconfig%2Fi386%2Fcpuid.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcpuid.h?ref=cb0dee885cb30b4e9beeef070cf000baa7d09abe", "patch": "@@ -74,6 +74,13 @@\n \t   \"xchg{l}\\t{%%}ebx, %1\\n\\t\"\t\t\t\\\n \t   : \"=a\" (a), \"=r\" (b), \"=c\" (c), \"=d\" (d)\t\\\n \t   : \"0\" (level))\n+\n+#define __cpuid_count(level, count, a, b, c, d)\t\t\\\n+  __asm__ (\"xchg{l}\\t{%%}ebx, %1\\n\\t\"\t\t\t\\\n+\t   \"cpuid\\n\\t\"\t\t\t\t\t\\\n+\t   \"xchg{l}\\t{%%}ebx, %1\\n\\t\"\t\t\t\\\n+\t   : \"=a\" (a), \"=r\" (b), \"=c\" (c), \"=d\" (d)\t\\\n+\t   : \"0\" (level), \"2\" (count))\n #else\n /* Host GCCs older than 3.0 weren't supporting Intel asm syntax\n    nor alternatives in i386 code.  */\n@@ -83,12 +90,24 @@\n \t   \"xchgl\\t%%ebx, %1\\n\\t\"\t\t\t\\\n \t   : \"=a\" (a), \"=r\" (b), \"=c\" (c), \"=d\" (d)\t\\\n \t   : \"0\" (level))\n+\n+#define __cpuid_count(level, count, a, b, c, d)\t\t\\\n+  __asm__ (\"xchgl\\t%%ebx, %1\\n\\t\"\t\t\t\\\n+\t   \"cpuid\\n\\t\"\t\t\t\t\t\\\n+\t   \"xchgl\\t%%ebx, %1\\n\\t\"\t\t\t\\\n+\t   : \"=a\" (a), \"=r\" (b), \"=c\" (c), \"=d\" (d)\t\\\n+\t   : \"0\" (level), \"2\" (count))\n #endif\n #else\n #define __cpuid(level, a, b, c, d)\t\t\t\\\n   __asm__ (\"cpuid\\n\\t\"\t\t\t\t\t\\\n \t   : \"=a\" (a), \"=b\" (b), \"=c\" (c), \"=d\" (d)\t\\\n \t   : \"0\" (level))\n+\n+#define __cpuid_count(level, count, a, b, c, d)\t\t\\\n+  __asm__ (\"cpuid\\n\\t\"\t\t\t\t\t\\\n+\t   : \"=a\" (a), \"=b\" (b), \"=c\" (c), \"=d\" (d)\t\\\n+\t   : \"0\" (level), \"2\" (count))\n #endif\n \n /* Return highest supported input value for cpuid instruction.  ext can"}, {"sha": "72e2c48d385b459f9d957fb4071f50eac9f611fd", "filename": "gcc/config/i386/driver-i386.c", "status": "modified", "additions": 256, "deletions": 221, "changes": 477, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb0dee885cb30b4e9beeef070cf000baa7d09abe/gcc%2Fconfig%2Fi386%2Fdriver-i386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb0dee885cb30b4e9beeef070cf000baa7d09abe/gcc%2Fconfig%2Fi386%2Fdriver-i386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fdriver-i386.c?ref=cb0dee885cb30b4e9beeef070cf000baa7d09abe", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for the gcc driver.\n-   Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2006, 2007, 2008 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -28,34 +28,45 @@ const char *host_detect_local_cpu (int argc, const char **argv);\n #ifdef __GNUC__\n #include \"cpuid.h\"\n \n-/* Returns parameters that describe L1_ASSOC associative cache of size\n-   L1_SIZEKB with lines of size L1_LINE.  */\n+struct cache_desc\n+{\n+  unsigned sizekb;\n+  unsigned assoc;\n+  unsigned line;\n+};\n+\n+/* Returns command line parameters that describe size and\n+   cache line size of the processor caches.  */\n \n static char *\n-describe_cache (unsigned l1_sizekb, unsigned l1_line,\n-\t\tunsigned l1_assoc ATTRIBUTE_UNUSED, unsigned l2_sizekb)\n+describe_cache (struct cache_desc level1, struct cache_desc level2)\n {\n   char size[100], line[100], size2[100];\n \n-  /* At the moment, gcc middle-end does not use the information about the\n-     associativity of the cache.  */\n+  /* At the moment, gcc does not use the information\n+     about the associativity of the cache.  */\n+\n+  sprintf (size, \"--param l1-cache-size=%u\", level1.sizekb);\n+  sprintf (line, \"--param l1-cache-line-size=%u\", level1.line);\n \n-  sprintf (size, \"--param l1-cache-size=%u\", l1_sizekb);\n-  sprintf (line, \"--param l1-cache-line-size=%u\", l1_line);\n-  sprintf (size2, \"--param l2-cache-size=%u\", l2_sizekb);\n+  sprintf (size2, \"--param l2-cache-size=%u\", level2.sizekb);\n \n   return concat (size, \" \", line, \" \", size2, \" \", NULL);\n }\n \n+/* Detect L2 cache parameters using CPUID extended function 0x80000006.  */\n+\n static void\n-decode_l2_cache (unsigned *l2_size, unsigned *l2_line, unsigned *l2_assoc)\n+detect_l2_cache (struct cache_desc *level2)\n {\n-  unsigned eax, ebx, ecx, edx, assoc;\n+  unsigned eax, ebx, ecx, edx;\n+  unsigned assoc;\n \n   __cpuid (0x80000006, eax, ebx, ecx, edx);\n \n-  *l2_size = (ecx >> 16) & 0xffff;\n-  *l2_line = ecx & 0xff;\n+  level2->sizekb = (ecx >> 16) & 0xffff;\n+  level2->line = ecx & 0xff;\n+\n   assoc = (ecx >> 12) & 0xf;\n   if (assoc == 6)\n     assoc = 8;\n@@ -65,7 +76,8 @@ decode_l2_cache (unsigned *l2_size, unsigned *l2_line, unsigned *l2_assoc)\n     assoc = 32 + (assoc - 0xa) * 16;\n   else if (assoc >= 0xd && assoc <= 0xe)\n     assoc = 96 + (assoc - 0xd) * 32;\n-  *l2_assoc = assoc;\n+\n+  level2->assoc = assoc;\n }\n \n /* Returns the description of caches for an AMD processor.  */\n@@ -74,243 +86,261 @@ static const char *\n detect_caches_amd (unsigned max_ext_level)\n {\n   unsigned eax, ebx, ecx, edx;\n-  unsigned l1_sizekb, l1_line, l1_assoc;\n-  unsigned l2_sizekb = 0, l2_line = 0, l2_assoc = 0;\n+\n+  struct cache_desc level1, level2 = {0, 0, 0};\n \n   if (max_ext_level < 0x80000005)\n     return \"\";\n \n   __cpuid (0x80000005, eax, ebx, ecx, edx);\n \n-  l1_line = ecx & 0xff;\n-  l1_sizekb = (ecx >> 24) & 0xff;\n-  l1_assoc = (ecx >> 16) & 0xff;\n+  level1.sizekb = (ecx >> 24) & 0xff;\n+  level1.assoc = (ecx >> 16) & 0xff;\n+  level1.line = ecx & 0xff;\n \n   if (max_ext_level >= 0x80000006)\n-    decode_l2_cache (&l2_sizekb, &l2_line, &l2_assoc);\n+    detect_l2_cache (&level2);\n \n-  return describe_cache (l1_sizekb, l1_line, l1_assoc, l2_sizekb);\n+  return describe_cache (level1, level2);\n }\n \n-/* Stores the size of the L1/2 cache and cache line, and the associativity\n-   of the cache according to REG to L1_SIZEKB, L1_LINE, L1_ASSOC and\n-   L2_SIZEKB. */\n+/* Decodes the size, the associativity and the cache line size of\n+   L1/L2 caches of an Intel processor.  Values are based on\n+   \"Intel Processor Identification and the CPUID Instruction\"\n+   [Application Note 485], revision -032, December 2007.  */\n \n static void\n-decode_caches_intel (unsigned reg, unsigned *l1_sizekb, unsigned *l1_line,\n-\t\t     unsigned *l1_assoc, unsigned *l2_sizekb,\n-\t\t     unsigned *l2_line, unsigned *l2_assoc)\n+decode_caches_intel (unsigned reg, bool xeon_mp,\n+\t\t     struct cache_desc *level1, struct cache_desc *level2)\n {\n-  unsigned i, val;\n+  int i;\n+\n+  for (i = 24; i >= 0; i -= 8)\n+    switch ((reg >> i) & 0xff)\n+      {\n+      case 0x0a:\n+\tlevel1->sizekb = 8; level1->assoc = 2; level1->line = 32;\n+\tbreak;\n+      case 0x0c:\n+\tlevel1->sizekb = 16; level1->assoc = 4; level1->line = 32;\n+\tbreak;\n+      case 0x2c:\n+\tlevel1->sizekb = 32; level1->assoc = 8; level1->line = 64;\n+\tbreak;\n+      case 0x39:\n+\tlevel2->sizekb = 128; level2->assoc = 4; level2->line = 64;\n+\tbreak;\n+      case 0x3a:\n+\tlevel2->sizekb = 192; level2->assoc = 6; level2->line = 64;\n+\tbreak;\n+      case 0x3b:\n+\tlevel2->sizekb = 128; level2->assoc = 2; level2->line = 64;\n+\tbreak;\n+      case 0x3c:\n+\tlevel2->sizekb = 256; level2->assoc = 4; level2->line = 64;\n+\tbreak;\n+      case 0x3d:\n+\tlevel2->sizekb = 384; level2->assoc = 6; level2->line = 64;\n+\tbreak;\n+      case 0x3e:\n+\tlevel2->sizekb = 512; level2->assoc = 4; level2->line = 64;\n+\tbreak;\n+      case 0x41:\n+\tlevel2->sizekb = 128; level2->assoc = 4; level2->line = 32;\n+\tbreak;\n+      case 0x42:\n+\tlevel2->sizekb = 256; level2->assoc = 4; level2->line = 32;\n+\tbreak;\n+      case 0x43:\n+\tlevel2->sizekb = 512; level2->assoc = 4; level2->line = 32;\n+\tbreak;\n+      case 0x44:\n+\tlevel2->sizekb = 1024; level2->assoc = 4; level2->line = 32;\n+\tbreak;\n+      case 0x45:\n+\tlevel2->sizekb = 2048; level2->assoc = 4; level2->line = 32;\n+\tbreak;\n+      case 0x49:\n+\tif (xeon_mp)\n+\t  break;\n+\tlevel2->sizekb = 4096; level2->assoc = 16; level2->line = 64;\n+\tbreak;\n+      case 0x4e:\n+\tlevel2->sizekb = 6144; level2->assoc = 24; level2->line = 64;\n+\tbreak;\n+      case 0x60:\n+\tlevel1->sizekb = 16; level1->assoc = 8; level1->line = 64;\n+\tbreak;\n+      case 0x66:\n+\tlevel1->sizekb = 8; level1->assoc = 4; level1->line = 64;\n+\tbreak;\n+      case 0x67:\n+\tlevel1->sizekb = 16; level1->assoc = 4; level1->line = 64;\n+\tbreak;\n+      case 0x68:\n+\tlevel1->sizekb = 32; level1->assoc = 4; level1->line = 64;\n+\tbreak;\n+      case 0x78:\n+\tlevel2->sizekb = 1024; level2->assoc = 4; level2->line = 64;\n+\tbreak;\n+      case 0x79:\n+\tlevel2->sizekb = 128; level2->assoc = 8; level2->line = 64;\n+\tbreak;\n+      case 0x7a:\n+\tlevel2->sizekb = 256; level2->assoc = 8; level2->line = 64;\n+\tbreak;\n+      case 0x7b:\n+\tlevel2->sizekb = 512; level2->assoc = 8; level2->line = 64;\n+\tbreak;\n+      case 0x7c:\n+\tlevel2->sizekb = 1024; level2->assoc = 8; level2->line = 64;\n+\tbreak;\n+      case 0x7d:\n+\tlevel2->sizekb = 2048; level2->assoc = 8; level2->line = 64;\n+\tbreak;\n+      case 0x7f:\n+\tlevel2->sizekb = 512; level2->assoc = 2; level2->line = 64;\n+\tbreak;\n+      case 0x82:\n+\tlevel2->sizekb = 256; level2->assoc = 8; level2->line = 32;\n+\tbreak;\n+      case 0x83:\n+\tlevel2->sizekb = 512; level2->assoc = 8; level2->line = 32;\n+\tbreak;\n+      case 0x84:\n+\tlevel2->sizekb = 1024; level2->assoc = 8; level2->line = 32;\n+\tbreak;\n+      case 0x85:\n+\tlevel2->sizekb = 2048; level2->assoc = 8; level2->line = 32;\n+\tbreak;\n+      case 0x86:\n+\tlevel2->sizekb = 512; level2->assoc = 4; level2->line = 64;\n+\tbreak;\n+      case 0x87:\n+\tlevel2->sizekb = 1024; level2->assoc = 8; level2->line = 64;\n+\n+      default:\n+\tbreak;\n+      }\n+}\n \n-  if (((reg >> 31) & 1) != 0)\n-    return;\n+/* Detect cache parameters using CPUID function 2.  */\n \n-  for (i = 0; i < 4; i++)\n+static void\n+detect_caches_cpuid2 (bool xeon_mp, \n+\t\t      struct cache_desc *level1, struct cache_desc *level2)\n+{\n+  unsigned eax, ebx, ecx, edx;\n+  int nreps;\n+\n+  __cpuid (2, eax, ebx, ecx, edx);\n+\n+  nreps = eax & 0x0f;\n+  eax &= ~0x0f;\n+\n+  while (--nreps >= 0)\n     {\n-      val = reg & 0xff;\n-      reg >>= 8;\n+      if (!((eax >> 31) & 1))\n+\tdecode_caches_intel (eax, xeon_mp, level1, level2);\n+      if (!((ebx >> 31) & 1))\n+\tdecode_caches_intel (ebx, xeon_mp, level1, level2);\n+      if (!((ecx >> 31) & 1))\n+\tdecode_caches_intel (ecx, xeon_mp, level1, level2);\n+      if (!((edx >> 31) & 1))\n+\tdecode_caches_intel (edx, xeon_mp, level1, level2);\n+\n+      if (nreps)\n+\t__cpuid (2, eax, ebx, ecx, edx);\n+    }\n+}\n \n-      switch (val)\n-\t{\n-\tcase 0xa:\n-\t  *l1_sizekb = 8;\n-\t  *l1_line = 32;\n-\t  *l1_assoc = 2;\n-\t  break;\n-\tcase 0xc:\n-\t  *l1_sizekb = 16;\n-\t  *l1_line = 32;\n-\t  *l1_assoc = 4;\n-\t  break;\n-\tcase 0x2c:\n-\t  *l1_sizekb = 32;\n-\t  *l1_line = 64;\n-\t  *l1_assoc = 8;\n-\t  break;\n-\tcase 0x39:\n-\t  *l2_sizekb = 128;\n-\t  *l2_line = 64;\n-\t  *l2_assoc = 4;\n-\t  break;\n-\tcase 0x3a:\n-\t  *l2_sizekb = 192;\n-\t  *l2_line = 64;\n-\t  *l2_assoc = 6;\n-\t  break;\n-\tcase 0x3b:\n-\t  *l2_sizekb = 128;\n-\t  *l2_line = 64;\n-\t  *l2_assoc = 2;\n-\t  break;\n-\tcase 0x3c:\n-\t  *l2_sizekb = 256;\n-\t  *l2_line = 64;\n-\t  *l2_assoc = 4;\n-\t  break;\n-\tcase 0x3d:\n-\t  *l2_sizekb = 384;\n-\t  *l2_line = 64;\n-\t  *l2_assoc = 6;\n-\t  break;\n-\tcase 0x3e:\n-\t  *l2_sizekb = 512;\n-\t  *l2_line = 64;\n-\t  *l2_assoc = 4;\n-\t  break;\n-\tcase 0x41:\n-\t  *l2_sizekb = 128;\n-\t  *l2_line = 32;\n-\t  *l2_assoc = 4;\n-\t  break;\n-\tcase 0x42:\n-\t  *l2_sizekb = 256;\n-\t  *l2_line = 32;\n-\t  *l2_assoc = 4;\n-\t  break;\n-\tcase 0x43:\n-\t  *l2_sizekb = 512;\n-\t  *l2_line = 32;\n-\t  *l2_assoc = 4;\n-\t  break;\n-\tcase 0x44:\n-\t  *l2_sizekb = 1024;\n-\t  *l2_line = 32;\n-\t  *l2_assoc = 4;\n-\t  break;\n-\tcase 0x45:\n-\t  *l2_sizekb = 2048;\n-\t  *l2_line = 32;\n-\t  *l2_assoc = 4;\n-\t  break;\n-\tcase 0x49:\n-\t  *l2_sizekb = 4096;\n-\t  *l2_line = 64;\n-\t  *l2_assoc = 16;\n-\t  break;\n-\tcase 0x60:\n-\t  *l1_sizekb = 16;\n-\t  *l1_line = 64;\n-\t  *l1_assoc = 8;\n-\t  break;\n-\tcase 0x66:\n-\t  *l1_sizekb = 8;\n-\t  *l1_line = 64;\n-\t  *l1_assoc = 4;\n-\t  break;\n-\tcase 0x67:\n-\t  *l1_sizekb = 16;\n-\t  *l1_line = 64;\n-\t  *l1_assoc = 4;\n-\t  break;\n-\tcase 0x68:\n-\t  *l1_sizekb = 32;\n-\t  *l1_line = 64;\n-\t  *l1_assoc = 4;\n-\t  break;\n-\tcase 0x78:\n-\t  *l2_sizekb = 1024;\n-\t  *l2_line = 64;\n-\t  *l2_assoc = 4;\n-\t  break;\n-\tcase 0x79:\n-\t  *l2_sizekb = 128;\n-\t  *l2_line = 64;\n-\t  *l2_assoc = 8;\n-\t  break;\n-\tcase 0x7a:\n-\t  *l2_sizekb = 256;\n-\t  *l2_line = 64;\n-\t  *l2_assoc = 8;\n-\t  break;\n-\tcase 0x7b:\n-\t  *l2_sizekb = 512;\n-\t  *l2_line = 64;\n-\t  *l2_assoc = 8;\n-\t  break;\n-\tcase 0x7c:\n-\t  *l2_sizekb = 1024;\n-\t  *l2_line = 64;\n-\t  *l2_assoc = 8;\n-\t  break;\n-\tcase 0x7d:\n-\t  *l2_sizekb = 2048;\n-\t  *l2_line = 64;\n-\t  *l2_assoc = 8;\n-\t  break;\n-\tcase 0x7f:\n-\t  *l2_sizekb = 512;\n-\t  *l2_line = 64;\n-\t  *l2_assoc = 2;\n-\t  break;\n-\tcase 0x82:\n-\t  *l2_sizekb = 256;\n-\t  *l2_line = 32;\n-\t  *l2_assoc = 8;\n-\t  break;\n-\tcase 0x83:\n-\t  *l2_sizekb = 512;\n-\t  *l2_line = 32;\n-\t  *l2_assoc = 8;\n-\t  break;\n-\tcase 0x84:\n-\t  *l2_sizekb = 1024;\n-\t  *l2_line = 32;\n-\t  *l2_assoc = 8;\n-\t  break;\n-\tcase 0x85:\n-\t  *l2_sizekb = 2048;\n-\t  *l2_line = 32;\n-\t  *l2_assoc = 8;\n-\t  break;\n-\tcase 0x86:\n-\t  *l2_sizekb = 512;\n-\t  *l2_line = 64;\n-\t  *l2_assoc = 4;\n-\t  break;\n-\tcase 0x87:\n-\t  *l2_sizekb = 1024;\n-\t  *l2_line = 64;\n-\t  *l2_assoc = 8;\n-\t  break;\n+/* Detect cache parameters using CPUID function 4. This\n+   method doesn't require hardcoded tables.  */\n \n+enum cache_type\n+{\n+  CACHE_END = 0,\n+  CACHE_DATA = 1,\n+  CACHE_INST = 2,\n+  CACHE_UNIFIED = 3\n+};\n+\n+static void\n+detect_caches_cpuid4 (struct cache_desc *level1, struct cache_desc *level2)\n+{\n+  struct cache_desc *cache;\n+\n+  unsigned eax, ebx, ecx, edx;\n+  int count;\n+\n+  for (count = 0;; count++)\n+    { \n+      __cpuid_count(4, count, eax, ebx, ecx, edx);\n+      switch (eax & 0x1f)\n+\t{\n+\tcase CACHE_END:\n+\t  return;\n+\tcase CACHE_DATA:\n+\tcase CACHE_UNIFIED:\n+\t  {\n+\t    switch ((eax >> 5) & 0x07)\n+\t      {\n+\t      case 1:\n+\t\tcache = level1;\n+\t\tbreak;\n+\t      case 2:\n+\t\tcache = level2;\n+\t\tbreak;\n+\t      default:\n+\t\tcache = NULL;\n+\t      }\n+\n+\t    if (cache)\n+\t      {\n+\t\tunsigned sets = ecx + 1;\n+\t\tunsigned part;\n+\n+\t\tcache->line = (ebx & 0x0fff) + 1;\n+\t\tebx >>= 12;\n+\n+\t\tpart = (ebx & 0x03ff) + 1;\n+\t\tebx >>= 10;\n+\n+\t\tcache->assoc = (ebx & 0x03ff) + 1;\n+\n+\t\tcache->sizekb = (cache->assoc * part\n+\t\t\t\t * cache->line * sets) / 1024;\n+\t      }\t       \n+\t  }\n \tdefault:\n \t  break;\n \t}\n     }\n }\n \n-/* Returns the description of caches for an intel processor.  */\n+/* Returns the description of caches for an Intel processor.  */\n \n static const char *\n-detect_caches_intel (unsigned max_level, unsigned max_ext_level)\n+detect_caches_intel (bool xeon_mp, unsigned max_level, unsigned max_ext_level)\n {\n-  unsigned eax, ebx, ecx, edx;\n-  unsigned l1_sizekb = 0, l1_line = 0, assoc = 0;\n-  unsigned l2_sizekb = 0, l2_line = 0, l2_assoc = 0;\n+  struct cache_desc level1 = {0, 0, 0}, level2 = {0, 0, 0};\n \n-  if (max_level < 2)\n+  if (max_level >= 4)\n+    detect_caches_cpuid4 (&level1, &level2);\n+  else if (max_level >= 2)\n+    detect_caches_cpuid2 (xeon_mp, &level1, &level2);\n+  else\n     return \"\";\n \n-  __cpuid (2, eax, ebx, ecx, edx);\n-\n-  decode_caches_intel (eax, &l1_sizekb, &l1_line, &assoc,\n-      &l2_sizekb, &l2_line, &l2_assoc);\n-  decode_caches_intel (ebx, &l1_sizekb, &l1_line, &assoc,\n-      &l2_sizekb, &l2_line, &l2_assoc);\n-  decode_caches_intel (ecx, &l1_sizekb, &l1_line, &assoc,\n-      &l2_sizekb, &l2_line, &l2_assoc);\n-  decode_caches_intel (edx, &l1_sizekb, &l1_line, &assoc,\n-      &l2_sizekb, &l2_line, &l2_assoc);\n-\n-  if (!l1_sizekb)\n+  if (level1.sizekb == 0)\n     return \"\";\n \n-  /* Newer Intel CPUs are equipped with AMD style L2 cache info */\n-  if (max_ext_level >= 0x80000006)\n-    decode_l2_cache (&l2_sizekb, &l2_line, &l2_assoc);\n+  /* Intel CPUs are equipped with AMD style L2 cache info.  Try this\n+     method if other methods fail to provide L2 cache parameters.  */\n+  if (level2.sizekb == 0 && max_ext_level >= 0x80000006)\n+    detect_l2_cache (&level2);\n \n-  return describe_cache (l1_sizekb, l1_line, assoc, l2_sizekb);\n+  return describe_cache (level1, level2);\n }\n \n /* This will be called by the spec parser in gcc.c when it sees\n@@ -334,11 +364,12 @@ const char *host_detect_local_cpu (int argc, const char **argv)\n   const char *cache = \"\";\n   const char *options = \"\";\n \n- unsigned int eax, ebx, ecx, edx;\n+  unsigned int eax, ebx, ecx, edx;\n \n   unsigned int max_level, ext_level;\n+\n   unsigned int vendor;\n-  unsigned int family;\n+  unsigned int model, family;\n \n   unsigned int has_sse3, has_ssse3, has_cmpxchg16b;\n   unsigned int has_cmpxchg8b, has_cmov, has_mmx, has_sse, has_sse2;\n@@ -364,6 +395,7 @@ const char *host_detect_local_cpu (int argc, const char **argv)\n   __cpuid (1, eax, ebx, ecx, edx);\n \n   /* We don't care for extended family.  */\n+  model = (eax >> 4) & 0x0f;\n   family = (eax >> 8) & 0x0f;\n \n   has_sse3 = ecx & bit_SSE3;\n@@ -396,7 +428,10 @@ const char *host_detect_local_cpu (int argc, const char **argv)\n       if (vendor == *(const unsigned int*) \"Auth\")\n \tcache = detect_caches_amd (ext_level);\n       else if (vendor == *(const unsigned int*) \"Genu\")\n-\tcache = detect_caches_intel (max_level, ext_level);\n+\t{\n+\t  bool xeon_mp = (family == 15 && model == 6);\n+\t  cache = detect_caches_intel (xeon_mp, max_level, ext_level);\n+\t}\n     }\n \n   if (vendor == *(const unsigned int*) \"Auth\")"}]}