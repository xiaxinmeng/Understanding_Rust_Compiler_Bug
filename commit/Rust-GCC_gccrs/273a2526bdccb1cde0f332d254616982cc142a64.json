{"sha": "273a2526bdccb1cde0f332d254616982cc142a64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjczYTI1MjZiZGNjYjFjZGUwZjMzMmQyNTQ2MTY5ODJjYzE0MmE2NA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-09-04T08:50:36Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-09-04T08:50:36Z"}, "message": "md.texi (shift patterns): New anchor.\n\n\t* doc/md.texi (shift patterns): New anchor.  Add reference to\n\tTARGET_SHIFT_TRUNCATION_MASK.\n\t* doc/tm.texi (TARGET_SHIFT_TRUNCATION_MASK): Document.\n\t* target.h (shift_truncation_mask): New target hook.\n\t* targhook.h (default_shift_truncation_mask): Declare.\n\t* targhook.c (default_shift_truncation_mask): Define.\n\t* target-def.h (TARGET_SHIFT_TRUNCATION_MASK): Define.\n\t(TARGET_INITIALIZER): Include it.\n\t* simplify-rtx.c (simplify_binary_operation): Combine ASHIFT, ASHIFTRT\n\tand LSHIFTRT cases.  Truncate arg1 if SHIFT_COUNT_TRUNCATED, otherwise\n\treject all out-of-range values.  Fix sign-extension code for modes\n\twhose width is smaller than HOST_BITS_PER_WIDE_INT.\n\t* optabs.c (simplify_expand_binop, force_expand_binop): New functions.\n\t(expand_superword_shift, expand_subword_shift): Likewise.\n\t(expand_doubleword_shift_condmove, expand_doubleword_shift): Likewise.\n\t(expand_binop): Use them to implement double-word shifts.\n\t* config/arm/arm.c (arm_shift_truncation_mask): New function.\n\t(TARGET_SHIFT_TRUNCATION_MASK): Define.\n\nFrom-SVN: r87079", "tree": {"sha": "4320b41f468e28f9439feab3f57dff953085081c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4320b41f468e28f9439feab3f57dff953085081c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/273a2526bdccb1cde0f332d254616982cc142a64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/273a2526bdccb1cde0f332d254616982cc142a64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/273a2526bdccb1cde0f332d254616982cc142a64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/273a2526bdccb1cde0f332d254616982cc142a64/comments", "author": null, "committer": null, "parents": [{"sha": "caf29de78e1a609a86f4f883db628e97f51b96c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caf29de78e1a609a86f4f883db628e97f51b96c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/caf29de78e1a609a86f4f883db628e97f51b96c8"}], "stats": {"total": 620, "additions": 494, "deletions": 126}, "files": [{"sha": "19d3faef6818502e7eea5035cabd0e0fe1885674", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273a2526bdccb1cde0f332d254616982cc142a64/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273a2526bdccb1cde0f332d254616982cc142a64/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=273a2526bdccb1cde0f332d254616982cc142a64", "patch": "@@ -1,3 +1,24 @@\n+2004-09-04  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* doc/md.texi (shift patterns): New anchor.  Add reference to\n+\tTARGET_SHIFT_TRUNCATION_MASK.\n+\t* doc/tm.texi (TARGET_SHIFT_TRUNCATION_MASK): Document.\n+\t* target.h (shift_truncation_mask): New target hook.\n+\t* targhook.h (default_shift_truncation_mask): Declare.\n+\t* targhook.c (default_shift_truncation_mask): Define.\n+\t* target-def.h (TARGET_SHIFT_TRUNCATION_MASK): Define.\n+\t(TARGET_INITIALIZER): Include it.\n+\t* simplify-rtx.c (simplify_binary_operation): Combine ASHIFT, ASHIFTRT\n+\tand LSHIFTRT cases.  Truncate arg1 if SHIFT_COUNT_TRUNCATED, otherwise\n+\treject all out-of-range values.  Fix sign-extension code for modes\n+\twhose width is smaller than HOST_BITS_PER_WIDE_INT.\n+\t* optabs.c (simplify_expand_binop, force_expand_binop): New functions.\n+\t(expand_superword_shift, expand_subword_shift): Likewise.\n+\t(expand_doubleword_shift_condmove, expand_doubleword_shift): Likewise.\n+\t(expand_binop): Use them to implement double-word shifts.\n+\t* config/arm/arm.c (arm_shift_truncation_mask): New function.\n+\t(TARGET_SHIFT_TRUNCATION_MASK): Define.\n+\n 2004-09-04  Jan Hubicka  <jh@suse.cz>\n \n \t* tree.c (iterate_hash_expr): Optimize, avoid use of iterative_hash_object."}, {"sha": "38ead5d3c3524cabc9ba4a2818e6397e41cc2943", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273a2526bdccb1cde0f332d254616982cc142a64/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273a2526bdccb1cde0f332d254616982cc142a64/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=273a2526bdccb1cde0f332d254616982cc142a64", "patch": "@@ -175,7 +175,7 @@ static bool arm_cxx_cdtor_returns_this (void);\n static bool arm_cxx_key_method_may_be_inline (void);\n static bool arm_cxx_export_class_data (void);\n static void arm_init_libfuncs (void);\n-\n+static unsigned HOST_WIDE_INT arm_shift_truncation_mask (enum machine_mode);\n \f\n /* Initialize the GCC target structure.  */\n #if TARGET_DLLIMPORT_DECL_ATTRIBUTES\n@@ -248,6 +248,8 @@ static void arm_init_libfuncs (void);\n #undef  TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST arm_address_cost\n \n+#undef TARGET_SHIFT_TRUNCATION_MASK\n+#define TARGET_SHIFT_TRUNCATION_MASK arm_shift_truncation_mask\n #undef TARGET_VECTOR_MODE_SUPPORTED_P\n #define TARGET_VECTOR_MODE_SUPPORTED_P arm_vector_mode_supported_p\n \n@@ -14334,3 +14336,14 @@ arm_vector_mode_supported_p (enum machine_mode mode)\n \n   return false;\n }\n+\n+/* Implement TARGET_SHIFT_TRUNCATION_MASK.  SImode shifts use normal\n+   ARM insns and therefore guarantee that the shift count is modulo 256.\n+   DImode shifts (those implemented by lib1funcs.asm or by optabs.c)\n+   guarantee no particular behavior for out-of-range counts.  */\n+\n+static unsigned HOST_WIDE_INT\n+arm_shift_truncation_mask (enum machine_mode mode)\n+{\n+  return mode == SImode ? 255 : 0;\n+}"}, {"sha": "0fe7c50eb8d26d15e076e0fa6536dd1743f7882e", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273a2526bdccb1cde0f332d254616982cc142a64/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273a2526bdccb1cde0f332d254616982cc142a64/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=273a2526bdccb1cde0f332d254616982cc142a64", "patch": "@@ -2884,13 +2884,16 @@ quotient or remainder and generate the appropriate instruction.\n @item @samp{udivmod@var{m}4}\n Similar, but does unsigned division.\n \n+@anchor{shift patterns}\n @cindex @code{ashl@var{m}3} instruction pattern\n @item @samp{ashl@var{m}3}\n Arithmetic-shift operand 1 left by a number of bits specified by operand\n 2, and store the result in operand 0.  Here @var{m} is the mode of\n operand 0 and operand 1; operand 2's mode is specified by the\n instruction pattern, and the compiler will convert the operand to that\n-mode before generating the instruction.\n+mode before generating the instruction.  The meaning of out-of-range shift\n+counts can optionally be specified by @code{TARGET_SHIFT_TRUNCATION_MASK}.\n+@xref{TARGET_SHIFT_TRUNCATION_MASK}.\n \n @cindex @code{ashr@var{m}3} instruction pattern\n @cindex @code{lshr@var{m}3} instruction pattern"}, {"sha": "e21f72747ed34e248db30f92cd080d788e928115", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273a2526bdccb1cde0f332d254616982cc142a64/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273a2526bdccb1cde0f332d254616982cc142a64/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=273a2526bdccb1cde0f332d254616982cc142a64", "patch": "@@ -8749,6 +8749,31 @@ the implied truncation of the shift instructions.\n You need not define this macro if it would always have the value of zero.\n @end defmac\n \n+@anchor{TARGET_SHIFT_TRUNCATION_MASK}\n+@deftypefn {Target Hook} int TARGET_SHIFT_TRUNCATION_MASK (enum machine_mode @var{mode})\n+This function describes how the standard shift patterns for @var{mode}\n+deal with shifts by negative amounts or by more than the width of the mode.\n+@xref{shift patterns}.\n+\n+On many machines, the shift patterns will apply a mask @var{m} to the\n+shift count, meaning that a fixed-width shift of @var{x} by @var{y} is\n+equivalent to an arbitrary-width shift of @var{x} by @var{y & m}.  If\n+this is true for mode @var{mode}, the function should return @var{m},\n+otherwise it should return 0.  A return value of 0 indicates that no\n+particular behavior is guaranteed.\n+\n+Note that, unlike @code{SHIFT_COUNT_TRUNCATED}, this function does\n+@emph{not} apply to general shift rtxes; it applies only to instructions\n+that are generated by the named shift patterns.\n+\n+The default implementation of this function returns\n+@code{GET_MODE_BITSIZE (@var{mode}) - 1} if @code{SHIFT_COUNT_TRUNCATED}\n+and 0 otherwise.  This definition is always safe, but if\n+@code{SHIFT_COUNT_TRUNCATED} is false, and some shift patterns\n+nevertheless truncate the shift count, you may get better code\n+by overriding it.\n+@end deftypefn\n+\n @defmac TRULY_NOOP_TRUNCATION (@var{outprec}, @var{inprec})\n A C expression which is nonzero if on this machine it is safe to\n ``convert'' an integer of @var{inprec} bits to one of @var{outprec}"}, {"sha": "22c0b3479468035764c7c0eaa72629eafe4a3747", "filename": "gcc/optabs.c", "status": "modified", "additions": 396, "deletions": 94, "changes": 490, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273a2526bdccb1cde0f332d254616982cc142a64/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273a2526bdccb1cde0f332d254616982cc142a64/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=273a2526bdccb1cde0f332d254616982cc142a64", "patch": "@@ -312,7 +312,356 @@ optab_for_tree_code (enum tree_code code, tree type)\n       return NULL;\n     }\n }\n+\f\n+/* Like expand_binop, but return a constant rtx if the result can be\n+   calculated at compile time.  The arguments and return value are\n+   otherwise the same as for expand_binop.  */\n+\n+static rtx\n+simplify_expand_binop (enum machine_mode mode, optab binoptab,\n+\t\t       rtx op0, rtx op1, rtx target, int unsignedp,\n+\t\t       enum optab_methods methods)\n+{\n+  if (CONSTANT_P (op0) && CONSTANT_P (op1))\n+    return simplify_gen_binary (binoptab->code, mode, op0, op1);\n+  else\n+    return expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods);\n+}\n+\n+/* Like simplify_expand_binop, but always put the result in TARGET.\n+   Return true if the expansion succeeded.  */\n+\n+static bool\n+force_expand_binop (enum machine_mode mode, optab binoptab,\n+\t\t    rtx op0, rtx op1, rtx target, int unsignedp,\n+\t\t    enum optab_methods methods)\n+{\n+  rtx x = simplify_expand_binop (mode, binoptab, op0, op1,\n+\t\t\t\t target, unsignedp, methods);\n+  if (x == 0)\n+    return false;\n+  if (x != target)\n+    emit_move_insn (target, x);\n+  return true;\n+}\n+\n+/* This subroutine of expand_doubleword_shift handles the cases in which\n+   the effective shift value is >= BITS_PER_WORD.  The arguments and return\n+   value are the same as for the parent routine, except that SUPERWORD_OP1\n+   is the shift count to use when shifting OUTOF_INPUT into INTO_TARGET.\n+   INTO_TARGET may be null if the caller has decided to calculate it.  */\n+\n+static bool\n+expand_superword_shift (optab binoptab, rtx outof_input, rtx superword_op1,\n+\t\t\trtx outof_target, rtx into_target,\n+\t\t\tint unsignedp, enum optab_methods methods)\n+{\n+  if (into_target != 0)\n+    if (!force_expand_binop (word_mode, binoptab, outof_input, superword_op1,\n+\t\t\t     into_target, unsignedp, methods))\n+      return false;\n+\n+  if (outof_target != 0)\n+    {\n+      /* For a signed right shift, we must fill OUTOF_TARGET with copies\n+\t of the sign bit, otherwise we must fill it with zeros.  */\n+      if (binoptab != ashr_optab)\n+\temit_move_insn (outof_target, CONST0_RTX (word_mode));\n+      else\n+\tif (!force_expand_binop (word_mode, binoptab,\n+\t\t\t\t outof_input, GEN_INT (BITS_PER_WORD - 1),\n+\t\t\t\t outof_target, unsignedp, methods))\n+\t  return false;\n+    }\n+  return true;\n+}\n+\n+/* This subroutine of expand_doubleword_shift handles the cases in which\n+   the effective shift value is < BITS_PER_WORD.  The arguments and return\n+   value are the same as for the parent routine.  */\n+\n+static bool\n+expand_subword_shift (enum machine_mode op1_mode, optab binoptab,\n+\t\t      rtx outof_input, rtx into_input, rtx op1,\n+\t\t      rtx outof_target, rtx into_target,\n+\t\t      int unsignedp, enum optab_methods methods,\n+\t\t      unsigned HOST_WIDE_INT shift_mask)\n+{\n+  optab reverse_unsigned_shift, unsigned_shift;\n+  rtx tmp, carries;\n+\n+  reverse_unsigned_shift = (binoptab == ashl_optab ? lshr_optab : ashl_optab);\n+  unsigned_shift = (binoptab == ashl_optab ? ashl_optab : lshr_optab);\n+\n+  /* The low OP1 bits of INTO_TARGET come from the high bits of OUTOF_INPUT.\n+     We therefore need to shift OUTOF_INPUT by (BITS_PER_WORD - OP1) bits in\n+     the opposite direction to BINOPTAB.  */\n+  if (CONSTANT_P (op1) || shift_mask >= BITS_PER_WORD)\n+    {\n+      carries = outof_input;\n+      tmp = immed_double_const (BITS_PER_WORD, 0, op1_mode);\n+      tmp = simplify_expand_binop (op1_mode, sub_optab, tmp, op1,\n+\t\t\t\t   0, true, methods);\n+    }\n+  else\n+    {\n+      /* We must avoid shifting by BITS_PER_WORD bits since that is either\n+\t the same as a zero shift (if shift_mask == BITS_PER_WORD - 1) or\n+\t has unknown behaviour.  Do a single shift first, then shift by the\n+\t remainder.  It's OK to use ~OP1 as the remainder if shift counts\n+\t are truncated to the mode size.  */\n+      carries = expand_binop (word_mode, reverse_unsigned_shift,\n+\t\t\t      outof_input, const1_rtx, 0, unsignedp, methods);\n+      if (shift_mask == BITS_PER_WORD - 1)\n+\t{\n+\t  tmp = immed_double_const (-1, -1, op1_mode);\n+\t  tmp = simplify_expand_binop (op1_mode, xor_optab, op1, tmp,\n+\t\t\t\t       0, true, methods);\n+\t}\n+      else\n+\t{\n+\t  tmp = immed_double_const (BITS_PER_WORD - 1, 0, op1_mode);\n+\t  tmp = simplify_expand_binop (op1_mode, sub_optab, tmp, op1,\n+\t\t\t\t       0, true, methods);\n+\t}\n+    }\n+  if (tmp == 0 || carries == 0)\n+    return false;\n+  carries = expand_binop (word_mode, reverse_unsigned_shift,\n+\t\t\t  carries, tmp, 0, unsignedp, methods);\n+  if (carries == 0)\n+    return false;\n+\n+  /* Shift INTO_INPUT logically by OP1.  This is the last use of INTO_INPUT\n+     so the result can go directly into INTO_TARGET if convenient.  */\n+  tmp = expand_binop (word_mode, unsigned_shift, into_input, op1,\n+\t\t      into_target, unsignedp, methods);\n+  if (tmp == 0)\n+    return false;\n+\n+  /* Now OR in the bits carried over from OUTOF_INPUT.  */\n+  if (!force_expand_binop (word_mode, ior_optab, tmp, carries,\n+\t\t\t   into_target, unsignedp, methods))\n+    return false;\n+\n+  /* Use a standard word_mode shift for the out-of half.  */\n+  if (outof_target != 0)\n+    if (!force_expand_binop (word_mode, binoptab, outof_input, op1,\n+\t\t\t     outof_target, unsignedp, methods))\n+      return false;\n+\n+  return true;\n+}\n+\n+\n+#ifdef HAVE_conditional_move\n+/* Try implementing expand_doubleword_shift using conditional moves.\n+   The shift is by < BITS_PER_WORD if (CMP_CODE CMP1 CMP2) is true,\n+   otherwise it is by >= BITS_PER_WORD.  SUBWORD_OP1 and SUPERWORD_OP1\n+   are the shift counts to use in the former and latter case.  All other\n+   arguments are the same as the parent routine.  */\n+\n+static bool\n+expand_doubleword_shift_condmove (enum machine_mode op1_mode, optab binoptab,\n+\t\t\t\t  enum rtx_code cmp_code, rtx cmp1, rtx cmp2,\n+\t\t\t\t  rtx outof_input, rtx into_input,\n+\t\t\t\t  rtx subword_op1, rtx superword_op1,\n+\t\t\t\t  rtx outof_target, rtx into_target,\n+\t\t\t\t  int unsignedp, enum optab_methods methods,\n+\t\t\t\t  unsigned HOST_WIDE_INT shift_mask)\n+{\n+  rtx outof_superword, into_superword;\n+\n+  /* Put the superword version of the output into OUTOF_SUPERWORD and\n+     INTO_SUPERWORD.  */\n+  outof_superword = outof_target != 0 ? gen_reg_rtx (word_mode) : 0;\n+  if (outof_target != 0 && subword_op1 == superword_op1)\n+    {\n+      /* The value INTO_TARGET >> SUBWORD_OP1, which we later store in\n+\t OUTOF_TARGET, is the same as the value of INTO_SUPERWORD.  */\n+      into_superword = outof_target;\n+      if (!expand_superword_shift (binoptab, outof_input, superword_op1,\n+\t\t\t\t   outof_superword, 0, unsignedp, methods))\n+\treturn false;\n+    }\n+  else\n+    {\n+      into_superword = gen_reg_rtx (word_mode);\n+      if (!expand_superword_shift (binoptab, outof_input, superword_op1,\n+\t\t\t\t   outof_superword, into_superword,\n+\t\t\t\t   unsignedp, methods))\n+\treturn false;\n+    }\n+\n+  /* Put the subword version directly in OUTOF_TARGET and INTO_TARGET.  */\n+  if (!expand_subword_shift (op1_mode, binoptab,\n+\t\t\t     outof_input, into_input, subword_op1,\n+\t\t\t     outof_target, into_target,\n+\t\t\t     unsignedp, methods, shift_mask))\n+    return false;\n+\n+  /* Select between them.  Do the INTO half first because INTO_SUPERWORD\n+     might be the current value of OUTOF_TARGET.  */\n+  if (!emit_conditional_move (into_target, cmp_code, cmp1, cmp2, op1_mode,\n+\t\t\t      into_target, into_superword, word_mode, false))\n+    return false;\n+\n+  if (outof_target != 0)\n+    if (!emit_conditional_move (outof_target, cmp_code, cmp1, cmp2, op1_mode,\n+\t\t\t\toutof_target, outof_superword,\n+\t\t\t\tword_mode, false))\n+      return false;\n+\n+  return true;\n+}\n+#endif\n+\n+/* Expand a doubleword shift (ashl, ashr or lshr) using word-mode shifts.\n+   OUTOF_INPUT and INTO_INPUT are the two word-sized halves of the first\n+   input operand; the shift moves bits in the direction OUTOF_INPUT->\n+   INTO_TARGET.  OUTOF_TARGET and INTO_TARGET are the equivalent words\n+   of the target.  OP1 is the shift count and OP1_MODE is its mode.\n+   If OP1 is constant, it will have been truncated as appropriate\n+   and is known to be nonzero.\n+\n+   If SHIFT_MASK is zero, the result of word shifts is undefined when the\n+   shift count is outside the range [0, BITS_PER_WORD).  This routine must\n+   avoid generating such shifts for OP1s in the range [0, BITS_PER_WORD * 2).\n+\n+   If SHIFT_MASK is nonzero, all word-mode shift counts are effectively\n+   masked by it and shifts in the range [BITS_PER_WORD, SHIFT_MASK) will\n+   fill with zeros or sign bits as appropriate.\n+\n+   If SHIFT_MASK is BITS_PER_WORD - 1, this routine will synthesise\n+   a doubleword shift whose equivalent mask is BITS_PER_WORD * 2 - 1.\n+   Doing this preserves semantics required by SHIFT_COUNT_TRUNCATED.\n+   In all other cases, shifts by values outside [0, BITS_PER_UNIT * 2)\n+   are undefined.\n+\n+   BINOPTAB, UNSIGNEDP and METHODS are as for expand_binop.  This function\n+   may not use INTO_INPUT after modifying INTO_TARGET, and similarly for\n+   OUTOF_INPUT and OUTOF_TARGET.  OUTOF_TARGET can be null if the parent\n+   function wants to calculate it itself.\n+\n+   Return true if the shift could be successfully synthesized.  */\n+\n+static bool\n+expand_doubleword_shift (enum machine_mode op1_mode, optab binoptab,\n+\t\t\t rtx outof_input, rtx into_input, rtx op1,\n+\t\t\t rtx outof_target, rtx into_target,\n+\t\t\t int unsignedp, enum optab_methods methods,\n+\t\t\t unsigned HOST_WIDE_INT shift_mask)\n+{\n+  rtx superword_op1, tmp, cmp1, cmp2;\n+  rtx subword_label, done_label;\n+  enum rtx_code cmp_code;\n+\n+  /* See if word-mode shifts by BITS_PER_WORD...BITS_PER_WORD * 2 - 1 will\n+     fill the result with sign or zero bits as appropriate.  If so, the value\n+     of OUTOF_TARGET will always be (SHIFT OUTOF_INPUT OP1).   Recursively call\n+     this routine to calculate INTO_TARGET (which depends on both OUTOF_INPUT\n+     and INTO_INPUT), then emit code to set up OUTOF_TARGET.\n+\n+     This isn't worthwhile for constant shifts since the optimizers will\n+     cope better with in-range shift counts.  */\n+  if (shift_mask >= BITS_PER_WORD\n+      && outof_target != 0\n+      && !CONSTANT_P (op1))\n+    {\n+      if (!expand_doubleword_shift (op1_mode, binoptab,\n+\t\t\t\t    outof_input, into_input, op1,\n+\t\t\t\t    0, into_target,\n+\t\t\t\t    unsignedp, methods, shift_mask))\n+\treturn false;\n+      if (!force_expand_binop (word_mode, binoptab, outof_input, op1,\n+\t\t\t       outof_target, unsignedp, methods))\n+\treturn false;\n+      return true;\n+    }\n+\n+  /* Set CMP_CODE, CMP1 and CMP2 so that the rtx (CMP_CODE CMP1 CMP2)\n+     is true when the effective shift value is less than BITS_PER_WORD.\n+     Set SUPERWORD_OP1 to the shift count that should be used to shift\n+     OUTOF_INPUT into INTO_TARGET when the condition is false.  */\n+  tmp = immed_double_const (BITS_PER_WORD, 0, op1_mode);\n+  if (!CONSTANT_P (op1) && shift_mask == BITS_PER_WORD - 1)\n+    {\n+      /* Set CMP1 to OP1 & BITS_PER_WORD.  The result is zero iff OP1\n+\t is a subword shift count.  */\n+      cmp1 = simplify_expand_binop (op1_mode, and_optab, op1, tmp,\n+\t\t\t\t    0, true, methods);\n+      cmp2 = CONST0_RTX (op1_mode);\n+      cmp_code = EQ;\n+      superword_op1 = op1;\n+    }\n+  else\n+    {\n+      /* Set CMP1 to OP1 - BITS_PER_WORD.  */\n+      cmp1 = simplify_expand_binop (op1_mode, sub_optab, op1, tmp,\n+\t\t\t\t    0, true, methods);\n+      cmp2 = CONST0_RTX (op1_mode);\n+      cmp_code = LT;\n+      superword_op1 = cmp1;\n+    }\n+  if (cmp1 == 0)\n+    return false;\n+\n+  /* If we can compute the condition at compile time, pick the\n+     appropriate subroutine.  */\n+  tmp = simplify_relational_operation (cmp_code, SImode, op1_mode, cmp1, cmp2);\n+  if (tmp != 0 && GET_CODE (tmp) == CONST_INT)\n+    {\n+      if (tmp == const0_rtx)\n+\treturn expand_superword_shift (binoptab, outof_input, superword_op1,\n+\t\t\t\t       outof_target, into_target,\n+\t\t\t\t       unsignedp, methods);\n+      else\n+\treturn expand_subword_shift (op1_mode, binoptab,\n+\t\t\t\t     outof_input, into_input, op1,\n+\t\t\t\t     outof_target, into_target,\n+\t\t\t\t     unsignedp, methods, shift_mask);\n+    }\n+\n+#ifdef HAVE_conditional_move\n+  /* Try using conditional moves to generate straight-line code.  */\n+  {\n+    rtx start = get_last_insn ();\n+    if (expand_doubleword_shift_condmove (op1_mode, binoptab,\n+\t\t\t\t\t  cmp_code, cmp1, cmp2,\n+\t\t\t\t\t  outof_input, into_input,\n+\t\t\t\t\t  op1, superword_op1,\n+\t\t\t\t\t  outof_target, into_target,\n+\t\t\t\t\t  unsignedp, methods, shift_mask))\n+      return true;\n+    delete_insns_since (start);\n+  }\n+#endif\n+\n+  /* As a last resort, use branches to select the correct alternative.  */\n+  subword_label = gen_label_rtx ();\n+  done_label = gen_label_rtx ();\n+\n+  do_compare_rtx_and_jump (cmp1, cmp2, cmp_code, false, op1_mode,\n+\t\t\t   0, 0, subword_label);\n+\n+  if (!expand_superword_shift (binoptab, outof_input, superword_op1,\n+\t\t\t       outof_target, into_target,\n+\t\t\t       unsignedp, methods))\n+    return false;\n \n+  emit_jump_insn (gen_jump (done_label));\n+  emit_barrier ();\n+  emit_label (subword_label);\n+\n+  if (!expand_subword_shift (op1_mode, binoptab,\n+\t\t\t     outof_input, into_input, op1,\n+\t\t\t     outof_target, into_target,\n+\t\t\t     unsignedp, methods, shift_mask))\n+    return false;\n+\n+  emit_label (done_label);\n+  return true;\n+}\n \f\n /* Wrapper around expand_binop which takes an rtx code to specify\n    the operation to perform, not an optab pointer.  All other\n@@ -638,118 +987,71 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n   if ((binoptab == lshr_optab || binoptab == ashl_optab\n        || binoptab == ashr_optab)\n       && class == MODE_INT\n-      && GET_CODE (op1) == CONST_INT\n+      && (GET_CODE (op1) == CONST_INT || !optimize_size)\n       && GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n       && binoptab->handlers[(int) word_mode].insn_code != CODE_FOR_nothing\n       && ashl_optab->handlers[(int) word_mode].insn_code != CODE_FOR_nothing\n       && lshr_optab->handlers[(int) word_mode].insn_code != CODE_FOR_nothing)\n     {\n-      rtx insns, inter, equiv_value;\n-      rtx into_target, outof_target;\n-      rtx into_input, outof_input;\n-      int shift_count, left_shift, outof_word;\n+      unsigned HOST_WIDE_INT shift_mask, double_shift_mask;\n+      enum machine_mode op1_mode;\n \n-      /* If TARGET is the same as one of the operands, the REG_EQUAL note\n-\t won't be accurate, so use a new target.  */\n-      if (target == 0 || target == op0 || target == op1)\n-\ttarget = gen_reg_rtx (mode);\n-\n-      start_sequence ();\n+      double_shift_mask = targetm.shift_truncation_mask (mode);\n+      shift_mask = targetm.shift_truncation_mask (word_mode);\n+      op1_mode = GET_MODE (op1) != VOIDmode ? GET_MODE (op1) : word_mode;\n \n-      shift_count = INTVAL (op1);\n+      /* Apply the truncation to constant shifts.  */\n+      if (double_shift_mask > 0 && GET_CODE (op1) == CONST_INT)\n+\top1 = GEN_INT (INTVAL (op1) & double_shift_mask);\n \n-      /* OUTOF_* is the word we are shifting bits away from, and\n-\t INTO_* is the word that we are shifting bits towards, thus\n-\t they differ depending on the direction of the shift and\n-\t WORDS_BIG_ENDIAN.  */\n-\n-      left_shift = binoptab == ashl_optab;\n-      outof_word = left_shift ^ ! WORDS_BIG_ENDIAN;\n-\n-      outof_target = operand_subword (target, outof_word, 1, mode);\n-      into_target = operand_subword (target, 1 - outof_word, 1, mode);\n-\n-      outof_input = operand_subword_force (op0, outof_word, mode);\n-      into_input = operand_subword_force (op0, 1 - outof_word, mode);\n+      if (op1 == CONST0_RTX (op1_mode))\n+\treturn op0;\n \n-      if (shift_count >= BITS_PER_WORD)\n+      /* Make sure that this is a combination that expand_doubleword_shift\n+\t can handle.  See the comments there for details.  */\n+      if (double_shift_mask == 0\n+\t  || (shift_mask == BITS_PER_WORD - 1\n+\t      && double_shift_mask == BITS_PER_WORD * 2 - 1))\n \t{\n-\t  inter = expand_binop (word_mode, binoptab,\n-\t\t\t       outof_input,\n-\t\t\t       GEN_INT (shift_count - BITS_PER_WORD),\n-\t\t\t       into_target, unsignedp, next_methods);\n+\t  rtx insns, equiv_value;\n+\t  rtx into_target, outof_target;\n+\t  rtx into_input, outof_input;\n+\t  int left_shift, outof_word;\n \n-\t  if (inter != 0 && inter != into_target)\n-\t    emit_move_insn (into_target, inter);\n-\n-\t  /* For a signed right shift, we must fill the word we are shifting\n-\t     out of with copies of the sign bit.  Otherwise it is zeroed.  */\n-\t  if (inter != 0 && binoptab != ashr_optab)\n-\t    inter = CONST0_RTX (word_mode);\n-\t  else if (inter != 0)\n-\t    inter = expand_binop (word_mode, binoptab,\n-\t\t\t\t  outof_input,\n-\t\t\t\t  GEN_INT (BITS_PER_WORD - 1),\n-\t\t\t\t  outof_target, unsignedp, next_methods);\n-\n-\t  if (inter != 0 && inter != outof_target)\n-\t    emit_move_insn (outof_target, inter);\n-\t}\n-      else\n-\t{\n-\t  rtx carries;\n-\t  optab reverse_unsigned_shift, unsigned_shift;\n-\n-\t  /* For a shift of less then BITS_PER_WORD, to compute the carry,\n-\t     we must do a logical shift in the opposite direction of the\n-\t     desired shift.  */\n-\n-\t  reverse_unsigned_shift = (left_shift ? lshr_optab : ashl_optab);\n-\n-\t  /* For a shift of less than BITS_PER_WORD, to compute the word\n-\t     shifted towards, we need to unsigned shift the orig value of\n-\t     that word.  */\n-\n-\t  unsigned_shift = (left_shift ? ashl_optab : lshr_optab);\n-\n-\t  carries = expand_binop (word_mode, reverse_unsigned_shift,\n-\t\t\t\t  outof_input,\n-\t\t\t\t  GEN_INT (BITS_PER_WORD - shift_count),\n-\t\t\t\t  0, unsignedp, next_methods);\n-\n-\t  if (carries == 0)\n-\t    inter = 0;\n-\t  else\n-\t    inter = expand_binop (word_mode, unsigned_shift, into_input,\n-\t\t\t\t  op1, 0, unsignedp, next_methods);\n+\t  /* If TARGET is the same as one of the operands, the REG_EQUAL note\n+\t     won't be accurate, so use a new target.  */\n+\t  if (target == 0 || target == op0 || target == op1)\n+\t    target = gen_reg_rtx (mode);\n \n-\t  if (inter != 0)\n-\t    inter = expand_binop (word_mode, ior_optab, carries, inter,\n-\t\t\t\t  into_target, unsignedp, next_methods);\n+\t  start_sequence ();\n \n-\t  if (inter != 0 && inter != into_target)\n-\t    emit_move_insn (into_target, inter);\n+\t  /* OUTOF_* is the word we are shifting bits away from, and\n+\t     INTO_* is the word that we are shifting bits towards, thus\n+\t     they differ depending on the direction of the shift and\n+\t     WORDS_BIG_ENDIAN.  */\n \n-\t  if (inter != 0)\n-\t    inter = expand_binop (word_mode, binoptab, outof_input,\n-\t\t\t\t  op1, outof_target, unsignedp, next_methods);\n+\t  left_shift = binoptab == ashl_optab;\n+\t  outof_word = left_shift ^ ! WORDS_BIG_ENDIAN;\n \n-\t  if (inter != 0 && inter != outof_target)\n-\t    emit_move_insn (outof_target, inter);\n-\t}\n+\t  outof_target = operand_subword (target, outof_word, 1, mode);\n+\t  into_target = operand_subword (target, 1 - outof_word, 1, mode);\n \n-      insns = get_insns ();\n-      end_sequence ();\n+\t  outof_input = operand_subword_force (op0, outof_word, mode);\n+\t  into_input = operand_subword_force (op0, 1 - outof_word, mode);\n \n-      if (inter != 0)\n-\t{\n-\t  if (binoptab->code != UNKNOWN)\n-\t    equiv_value = gen_rtx_fmt_ee (binoptab->code, mode, op0, op1);\n-\t  else\n-\t    equiv_value = 0;\n+\t  if (expand_doubleword_shift (op1_mode, binoptab,\n+\t\t\t\t       outof_input, into_input, op1,\n+\t\t\t\t       outof_target, into_target,\n+\t\t\t\t       unsignedp, methods, shift_mask))\n+\t    {\n+\t      insns = get_insns ();\n+\t      end_sequence ();\n \n-\t  emit_no_conflict_block (insns, target, op0, op1, equiv_value);\n-\t  return target;\n+\t      equiv_value = gen_rtx_fmt_ee (binoptab->code, mode, op0, op1);\n+\t      emit_no_conflict_block (insns, target, op0, op1, equiv_value);\n+\t      return target;\n+\t    }\n+\t  end_sequence ();\n \t}\n     }\n "}, {"sha": "285f898de80b86043cf9626044b9c832fde78ad3", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 15, "deletions": 30, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273a2526bdccb1cde0f332d254616982cc142a64/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273a2526bdccb1cde0f332d254616982cc142a64/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=273a2526bdccb1cde0f332d254616982cc142a64", "patch": "@@ -2343,41 +2343,26 @@ simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n       break;\n \n     case LSHIFTRT:\n-      /* If shift count is undefined, don't fold it; let the machine do\n-\t what it wants.  But truncate it if the machine will do that.  */\n-      if (arg1 < 0)\n-\treturn 0;\n-\n-      if (SHIFT_COUNT_TRUNCATED)\n-\targ1 %= width;\n-\n-      val = ((unsigned HOST_WIDE_INT) arg0) >> arg1;\n-      break;\n-\n     case ASHIFT:\n-      if (arg1 < 0)\n-\treturn 0;\n-\n-      if (SHIFT_COUNT_TRUNCATED)\n-\targ1 %= width;\n-\n-      val = ((unsigned HOST_WIDE_INT) arg0) << arg1;\n-      break;\n-\n     case ASHIFTRT:\n-      if (arg1 < 0)\n-\treturn 0;\n-\n+      /* Truncate the shift if SHIFT_COUNT_TRUNCATED, otherwise make sure the\n+\t value is in range.  We can't return any old value for out-of-range\n+\t arguments because either the middle-end (via shift_truncation_mask)\n+\t or the back-end might be relying on target-specific knowledge.\n+\t Nor can we rely on shift_truncation_mask, since the shift might\n+\t not be part of an ashlM3, lshrM3 or ashrM3 instruction.  */\n       if (SHIFT_COUNT_TRUNCATED)\n-\targ1 %= width;\n-\n-      val = arg0s >> arg1;\n+\targ1 = (unsigned HOST_WIDE_INT) arg1 % width;\n+      else if (arg1 < 0 || arg1 >= GET_MODE_BITSIZE (mode))\n+\treturn 0;\n \n-      /* Bootstrap compiler may not have sign extended the right shift.\n-\t Manually extend the sign to insure bootstrap cc matches gcc.  */\n-      if (arg0s < 0 && arg1 > 0)\n-\tval |= ((HOST_WIDE_INT) -1) << (HOST_BITS_PER_WIDE_INT - arg1);\n+      val = (code == ASHIFT\n+\t     ? ((unsigned HOST_WIDE_INT) arg0) << arg1\n+\t     : ((unsigned HOST_WIDE_INT) arg0) >> arg1);\n \n+      /* Sign-extend the result for arithmetic right shifts.  */\n+      if (code == ASHIFTRT && arg0s < 0 && arg1 > 0)\n+\tval |= ((HOST_WIDE_INT) -1) << (width - arg1);\n       break;\n \n     case ROTATERT:"}, {"sha": "01837efd60460c62b43887eda23f4ef371c4ac3f", "filename": "gcc/target-def.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273a2526bdccb1cde0f332d254616982cc142a64/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273a2526bdccb1cde0f332d254616982cc142a64/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=273a2526bdccb1cde0f332d254616982cc142a64", "patch": "@@ -301,6 +301,10 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #define TARGET_BINDS_LOCAL_P default_binds_local_p\n #endif\n \n+#ifndef TARGET_SHIFT_TRUNCATION_MASK\n+#define TARGET_SHIFT_TRUNCATION_MASK default_shift_truncation_mask\n+#endif\n+\n #ifndef TARGET_VALID_POINTER_MODE\n #define TARGET_VALID_POINTER_MODE default_valid_pointer_mode\n #endif\n@@ -488,6 +492,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n   TARGET_BINDS_LOCAL_P,\t\t\t\t\\\n   TARGET_ENCODE_SECTION_INFO,\t\t\t\\\n   TARGET_STRIP_NAME_ENCODING,\t\t\t\\\n+  TARGET_SHIFT_TRUNCATION_MASK,\t\t\t\\\n   TARGET_VALID_POINTER_MODE,                    \\\n   TARGET_SCALAR_MODE_SUPPORTED_P,\t\t\\\n   TARGET_VECTOR_MODE_SUPPORTED_P,               \\"}, {"sha": "735a85d11dd00e0be28343ab054b45062e4ac20c", "filename": "gcc/target.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273a2526bdccb1cde0f332d254616982cc142a64/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273a2526bdccb1cde0f332d254616982cc142a64/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=273a2526bdccb1cde0f332d254616982cc142a64", "patch": "@@ -378,6 +378,10 @@ struct gcc_target\n   /* Undo the effects of encode_section_info on the symbol string.  */\n   const char * (* strip_name_encoding) (const char *);\n \n+  /* If shift optabs for MODE are known to always truncate the shift count,\n+     return the mask that they apply.  Return 0 otherwise.  */\n+  unsigned HOST_WIDE_INT (* shift_truncation_mask) (enum machine_mode mode);\n+\n   /* True if MODE is valid for a pointer in __attribute__((mode(\"MODE\"))).  */\n   bool (* valid_pointer_mode) (enum machine_mode mode);\n "}, {"sha": "5ecb6d8370d5010283840609c5b8c835e1941579", "filename": "gcc/targhooks.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273a2526bdccb1cde0f332d254616982cc142a64/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273a2526bdccb1cde0f332d254616982cc142a64/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=273a2526bdccb1cde0f332d254616982cc142a64", "patch": "@@ -135,6 +135,14 @@ default_eh_return_filter_mode (void)\n   return word_mode;\n }\n \n+/* The default implementation of TARGET_SHIFT_TRUNCATION_MASK.  */\n+\n+unsigned HOST_WIDE_INT\n+default_shift_truncation_mask (enum machine_mode mode)\n+{\n+  return SHIFT_COUNT_TRUNCATED ? GET_MODE_BITSIZE (mode) - 1 : 0;\n+}\n+\n /* Generic hook that takes a CUMULATIVE_ARGS pointer and returns true.  */\n \n bool"}, {"sha": "8745f7eb5b7ec02b4eab886519d981c0ac4a842c", "filename": "gcc/targhooks.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273a2526bdccb1cde0f332d254616982cc142a64/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273a2526bdccb1cde0f332d254616982cc142a64/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=273a2526bdccb1cde0f332d254616982cc142a64", "patch": "@@ -32,6 +32,8 @@ extern bool hook_bool_CUMULATIVE_ARGS_false (CUMULATIVE_ARGS *);\n extern bool default_pretend_outgoing_varargs_named (CUMULATIVE_ARGS *);\n \n extern enum machine_mode default_eh_return_filter_mode (void);\n+extern unsigned HOST_WIDE_INT default_shift_truncation_mask\n+  (enum machine_mode);\n \n extern bool hook_bool_CUMULATIVE_ARGS_true (CUMULATIVE_ARGS *);\n extern tree default_cxx_guard_type (void);"}]}