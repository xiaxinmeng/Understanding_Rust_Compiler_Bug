{"sha": "b63b1f862611aa41662d7cd7027d040dc6682f57", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjYzYjFmODYyNjExYWE0MTY2MmQ3Y2Q3MDI3ZDA0MGRjNjY4MmY1Nw==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2012-07-26T08:53:56Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2012-07-26T08:53:56Z"}, "message": "re PR fortran/44354 (implied do loop with its own variable name as upper bound)\n\nfortran/\n\tPR fortran/44354\n\t* trans-array.c (gfc_trans_array_constructor_value):\n\tEvaluate the iteration bounds before the inner variable shadows\n\tthe outer.\n\ntestsuite/\n\tPR fortran/44354\n\t* gfortran.dg/array_constructor_39.f90: New test.\n\nFrom-SVN: r189883", "tree": {"sha": "d21fdd8c66cb49708b7bfb8eb3be677f1dec8cb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d21fdd8c66cb49708b7bfb8eb3be677f1dec8cb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b63b1f862611aa41662d7cd7027d040dc6682f57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b63b1f862611aa41662d7cd7027d040dc6682f57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b63b1f862611aa41662d7cd7027d040dc6682f57", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b63b1f862611aa41662d7cd7027d040dc6682f57/comments", "author": null, "committer": null, "parents": [{"sha": "ca27d5aebd6c4a4fb2776f2924da621c26b5fd1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca27d5aebd6c4a4fb2776f2924da621c26b5fd1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca27d5aebd6c4a4fb2776f2924da621c26b5fd1a"}], "stats": {"total": 71, "additions": 53, "deletions": 18}, "files": [{"sha": "0c0ffe054589ea899a6bbaf3ab35f56b826e3299", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b63b1f862611aa41662d7cd7027d040dc6682f57/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b63b1f862611aa41662d7cd7027d040dc6682f57/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b63b1f862611aa41662d7cd7027d040dc6682f57", "patch": "@@ -1,3 +1,10 @@\n+2012-07-26  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/44354\n+\t* trans-array.c (gfc_trans_array_constructor_value):\n+\tEvaluate the iteration bounds before the inner variable shadows\n+\tthe outer.\n+\n 2012-07-26  Mikael Morin  <mikael@gcc.gnu.org>\n \n \tPR fortran/44354"}, {"sha": "555d69696bb829d51409f9b23a6a51b7959d4e2b", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b63b1f862611aa41662d7cd7027d040dc6682f57/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b63b1f862611aa41662d7cd7027d040dc6682f57/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=b63b1f862611aa41662d7cd7027d040dc6682f57", "patch": "@@ -1520,6 +1520,9 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t\t\t\t   bool dynamic)\n {\n   tree tmp;\n+  tree start = NULL_TREE;\n+  tree end = NULL_TREE;\n+  tree step = NULL_TREE;\n   stmtblock_t body;\n   gfc_se se;\n   mpz_t size;\n@@ -1542,8 +1545,30 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t expression in an interface mapping.  */\n       if (c->iterator)\n \t{\n-\t  gfc_symbol *sym = c->iterator->var->symtree->n.sym;\n-\t  tree type = gfc_typenode_for_spec (&sym->ts);\n+\t  gfc_symbol *sym;\n+\t  tree type;\n+\n+\t  /* Evaluate loop bounds before substituting the loop variable\n+\t     in case they depend on it.  Such a case is invalid, but it is\n+\t     not more expensive to do the right thing here.\n+\t     See PR 44354.  */\n+\t  gfc_init_se (&se, NULL);\n+\t  gfc_conv_expr_val (&se, c->iterator->start);\n+\t  gfc_add_block_to_block (pblock, &se.pre);\n+\t  start = gfc_evaluate_now (se.expr, pblock);\n+\n+\t  gfc_init_se (&se, NULL);\n+\t  gfc_conv_expr_val (&se, c->iterator->end);\n+\t  gfc_add_block_to_block (pblock, &se.pre);\n+\t  end = gfc_evaluate_now (se.expr, pblock);\n+\n+\t  gfc_init_se (&se, NULL);\n+\t  gfc_conv_expr_val (&se, c->iterator->step);\n+\t  gfc_add_block_to_block (pblock, &se.pre);\n+\t  step = gfc_evaluate_now (se.expr, pblock);\n+\n+\t  sym = c->iterator->var->symtree->n.sym;\n+\t  type = gfc_typenode_for_spec (&sym->ts);\n \n \t  shadow_loopvar = gfc_create_var (type, \"shadow_loopvar\");\n \t  gfc_shadow_sym (sym, shadow_loopvar, &saved_loopvar);\n@@ -1678,8 +1703,6 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t  /* Build the implied do-loop.  */\n \t  stmtblock_t implied_do_block;\n \t  tree cond;\n-\t  tree end;\n-\t  tree step;\n \t  tree exit_label;\n \t  tree loopbody;\n \t  tree tmp2;\n@@ -1691,20 +1714,7 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t  gfc_start_block(&implied_do_block);\n \n \t  /* Initialize the loop.  */\n-\t  gfc_init_se (&se, NULL);\n-\t  gfc_conv_expr_val (&se, c->iterator->start);\n-\t  gfc_add_block_to_block (&implied_do_block, &se.pre);\n-\t  gfc_add_modify (&implied_do_block, shadow_loopvar, se.expr);\n-\n-\t  gfc_init_se (&se, NULL);\n-\t  gfc_conv_expr_val (&se, c->iterator->end);\n-\t  gfc_add_block_to_block (&implied_do_block, &se.pre);\n-\t  end = gfc_evaluate_now (se.expr, &implied_do_block);\n-\n-\t  gfc_init_se (&se, NULL);\n-\t  gfc_conv_expr_val (&se, c->iterator->step);\n-\t  gfc_add_block_to_block (&implied_do_block, &se.pre);\n-\t  step = gfc_evaluate_now (se.expr, &implied_do_block);\n+\t  gfc_add_modify (&implied_do_block, shadow_loopvar, start);\n \n \t  /* If this array expands dynamically, and the number of iterations\n \t     is not constant, we won't have allocated space for the static"}, {"sha": "254bf802d8da2f5e5364ceaf232056f0466159f9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b63b1f862611aa41662d7cd7027d040dc6682f57/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b63b1f862611aa41662d7cd7027d040dc6682f57/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b63b1f862611aa41662d7cd7027d040dc6682f57", "patch": "@@ -1,3 +1,8 @@\n+2012-07-26  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/44354\n+\t* gfortran.dg/array_constructor_39.f90: New test.\n+\n 2012-07-26  Mikael Morin  <mikael@gcc.gnu.org>\n \n \tPR fortran/44354"}, {"sha": "83eff05ddca1955882f935d0f739abb8b140106e", "filename": "gcc/testsuite/gfortran.dg/array_constructor_39.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b63b1f862611aa41662d7cd7027d040dc6682f57/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_39.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b63b1f862611aa41662d7cd7027d040dc6682f57/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_39.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_39.f90?ref=b63b1f862611aa41662d7cd7027d040dc6682f57", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do run }\n+!\n+! PR fortran/44354\n+! array constructors were giving unexpected results when the ac-implied-do\n+! variable was used in one of the ac-implied-do bounds.\n+!\n+! Original testcase by Vittorio Zecca <zeccav@gmail.com>\n+!\n+      I=5\n+      if (any((/(i,i=1,I)/) /= (/1,2,3,4,5/))) call abort ! { dg-warning \"final expression references control variable\" }\n+      if (I /= 5) call abort\n+      end\n+"}]}