{"sha": "728557fda26f7ffa540bb2e614e4debae366d2ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI4NTU3ZmRhMjZmN2ZmYTU0MGJiMmU2MTRlNGRlYmFlMzY2ZDJhZA==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2016-03-29T16:54:24Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2016-03-29T16:54:24Z"}, "message": "re PR fortran/70397 (ice while allocating ultimate polymorphic)\n\ngcc/fortran/ChangeLog:\n\n2016-03-29  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\tPR fortran/70397\n\t* trans-expr.c (gfc_class_len_or_zero_get): Add function to return a\n\tconstant zero tree, when the class to get the _len component from is\n\tnot unlimited polymorphic.\n\t(gfc_copy_class_to_class): Use the new function.\n\t* trans.h: Added interface of new function gfc_class_len_or_zero_get.\n\ngcc/testsuite/ChangeLog:\n\n2016-03-29  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\tPR fortran/70397\n\t* gfortran.dg/unlimited_polymorphic_25.f90: New test.\n\t* gfortran.dg/unlimited_polymorphic_26.f90: New test.\n\nFrom-SVN: r234528", "tree": {"sha": "e4e0a9b1cd9f9d0b25895fe00681f2f8dc699f04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4e0a9b1cd9f9d0b25895fe00681f2f8dc699f04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/728557fda26f7ffa540bb2e614e4debae366d2ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/728557fda26f7ffa540bb2e614e4debae366d2ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/728557fda26f7ffa540bb2e614e4debae366d2ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/728557fda26f7ffa540bb2e614e4debae366d2ad/comments", "author": null, "committer": null, "parents": [{"sha": "da178d566a0731534f369273fa9480e1210cb01c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da178d566a0731534f369273fa9480e1210cb01c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da178d566a0731534f369273fa9480e1210cb01c"}], "stats": {"total": 129, "additions": 128, "deletions": 1}, "files": [{"sha": "5ab7d3ff285368e11d50cd0801a7fffb7c84ec87", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/728557fda26f7ffa540bb2e614e4debae366d2ad/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/728557fda26f7ffa540bb2e614e4debae366d2ad/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=728557fda26f7ffa540bb2e614e4debae366d2ad", "patch": "@@ -1,3 +1,12 @@\n+2016-03-29  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\tPR fortran/70397\n+\t* trans-expr.c (gfc_class_len_or_zero_get): Add function to return a\n+\tconstant zero tree, when the class to get the _len component from is\n+\tnot unlimited polymorphic.\n+\t(gfc_copy_class_to_class): Use the new function.\n+\t* trans.h: Added interface of new function gfc_class_len_or_zero_get.\n+\n 2016-03-28  Alessandro Fanfarillo  <fanfarillo.gcc@gmail.com>\n \n \t* trans-decl.c (gfc_build_builtin_function_decls):"}, {"sha": "8d039a670b56b7da084e64eb274385afe827dc65", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/728557fda26f7ffa540bb2e614e4debae366d2ad/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/728557fda26f7ffa540bb2e614e4debae366d2ad/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=728557fda26f7ffa540bb2e614e4debae366d2ad", "patch": "@@ -173,6 +173,29 @@ gfc_class_len_get (tree decl)\n }\n \n \n+/* Try to get the _len component of a class.  When the class is not unlimited\n+   poly, i.e. no _len field exists, then return a zero node.  */\n+\n+tree\n+gfc_class_len_or_zero_get (tree decl)\n+{\n+  tree len;\n+  /* For class arrays decl may be a temporary descriptor handle, the vptr is\n+     then available through the saved descriptor.  */\n+  if (TREE_CODE (decl) == VAR_DECL && DECL_LANG_SPECIFIC (decl)\n+      && GFC_DECL_SAVED_DESCRIPTOR (decl))\n+    decl = GFC_DECL_SAVED_DESCRIPTOR (decl);\n+  if (POINTER_TYPE_P (TREE_TYPE (decl)))\n+    decl = build_fold_indirect_ref_loc (input_location, decl);\n+  len = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (decl)),\n+\t\t\t   CLASS_LEN_FIELD);\n+  return len != NULL_TREE ? fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t\t     TREE_TYPE (len), decl, len,\n+\t\t\t\t\t     NULL_TREE)\n+\t\t\t  : integer_zero_node;\n+}\n+\n+\n /* Get the specified FIELD from the VPTR.  */\n \n static tree\n@@ -250,6 +273,7 @@ gfc_vptr_size_get (tree vptr)\n \n #undef CLASS_DATA_FIELD\n #undef CLASS_VPTR_FIELD\n+#undef CLASS_LEN_FIELD\n #undef VTABLE_HASH_FIELD\n #undef VTABLE_SIZE_FIELD\n #undef VTABLE_EXTENDS_FIELD\n@@ -1120,7 +1144,7 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)\n   if (unlimited)\n     {\n       if (from != NULL_TREE && unlimited)\n-\tfrom_len = gfc_class_len_get (from);\n+\tfrom_len = gfc_class_len_or_zero_get (from);\n       else\n \tfrom_len = integer_zero_node;\n     }"}, {"sha": "512615ab1e4cc60d65fa7ac444a19b9326fbb0ce", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/728557fda26f7ffa540bb2e614e4debae366d2ad/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/728557fda26f7ffa540bb2e614e4debae366d2ad/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=728557fda26f7ffa540bb2e614e4debae366d2ad", "patch": "@@ -365,6 +365,7 @@ tree gfc_class_set_static_fields (tree, tree, tree);\n tree gfc_class_data_get (tree);\n tree gfc_class_vptr_get (tree);\n tree gfc_class_len_get (tree);\n+tree gfc_class_len_or_zero_get (tree);\n gfc_expr * gfc_find_and_cut_at_last_class_ref (gfc_expr *);\n /* Get an accessor to the class' vtab's * field, when a class handle is\n    available.  */"}, {"sha": "b7335a842d5cf688be8e0d2a1ac4f2e4569f9a54", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/728557fda26f7ffa540bb2e614e4debae366d2ad/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/728557fda26f7ffa540bb2e614e4debae366d2ad/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=728557fda26f7ffa540bb2e614e4debae366d2ad", "patch": "@@ -1,3 +1,9 @@\n+2016-03-29  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\tPR fortran/70397\n+\t* gfortran.dg/unlimited_polymorphic_25.f90: New test.\n+\t* gfortran.dg/unlimited_polymorphic_26.f90: New test.\n+\n 2016-03-29  Thomas Schwinge  <thomas@codesourcery.com>\n \n \tPR testsuite/64177"}, {"sha": "d0b2a2e32d1783d2e280da017afe884c18eefcaf", "filename": "gcc/testsuite/gfortran.dg/unlimited_polymorphic_25.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/728557fda26f7ffa540bb2e614e4debae366d2ad/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_25.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/728557fda26f7ffa540bb2e614e4debae366d2ad/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_25.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_25.f90?ref=728557fda26f7ffa540bb2e614e4debae366d2ad", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do run }\n+!\n+! Test contributed by Valery Weber  <valeryweber@hotmail.com>\n+\n+module mod\n+\n+  TYPE, PUBLIC :: base_type\n+  END TYPE base_type\n+\n+  TYPE, PUBLIC :: dict_entry_type\n+     CLASS( * ), ALLOCATABLE :: key\n+     CLASS( * ), ALLOCATABLE :: val\n+  END TYPE dict_entry_type\n+\n+\n+contains\n+\n+  SUBROUTINE dict_put ( this, key, val )\n+    CLASS(dict_entry_type), INTENT(INOUT)     :: this\n+    CLASS(base_type), INTENT(IN)             :: key, val\n+    INTEGER                                  :: istat\n+    ALLOCATE( this%key, SOURCE=key, STAT=istat )\n+  end SUBROUTINE dict_put\n+end module mod\n+\n+program test\n+  use mod\n+  type(dict_entry_type) :: t\n+  type(base_type) :: a, b\n+  call dict_put(t, a, b)\n+\n+  if (.NOT. allocated(t%key)) call abort()\n+  select type (x => t%key)\n+    type is (base_type)\n+    class default\n+      call abort()\n+  end select\n+  deallocate(t%key)\n+end\n+"}, {"sha": "130006907a90b2ebd8e5db99e9740ca6024fc767", "filename": "gcc/testsuite/gfortran.dg/unlimited_polymorphic_26.f90", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/728557fda26f7ffa540bb2e614e4debae366d2ad/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_26.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/728557fda26f7ffa540bb2e614e4debae366d2ad/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_26.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_26.f90?ref=728557fda26f7ffa540bb2e614e4debae366d2ad", "patch": "@@ -0,0 +1,47 @@\n+! { dg-do run }\n+!\n+! Test contributed by Valery Weber  <valeryweber@hotmail.com>\n+\n+module mod\n+\n+  TYPE, PUBLIC :: dict_entry_type\n+     CLASS( * ), ALLOCATABLE :: key\n+     CLASS( * ), ALLOCATABLE :: val\n+  END TYPE dict_entry_type\n+\n+\n+contains\n+\n+  SUBROUTINE dict_put ( this, key, val )\n+    CLASS(dict_entry_type), INTENT(INOUT)     :: this\n+    CLASS(*), INTENT(IN)                     :: key, val\n+    INTEGER                                  :: istat\n+    ALLOCATE( this%key, SOURCE=key, STAT=istat )\n+    ALLOCATE( this%val, SOURCE=val, STAT=istat )\n+  end SUBROUTINE dict_put\n+end module mod\n+\n+program test\n+  use mod\n+  type(dict_entry_type) :: t\n+  call dict_put(t, \"foo\", 42)\n+\n+  if (.NOT. allocated(t%key)) call abort()\n+  select type (x => t%key)\n+    type is (CHARACTER(*))\n+      if (x /= \"foo\") call abort()\n+    class default\n+      call abort()\n+  end select\n+  deallocate(t%key)\n+\n+  if (.NOT. allocated(t%val)) call abort()\n+  select type (x => t%val)\n+    type is (INTEGER)\n+      if (x /= 42) call abort()\n+    class default\n+      call abort()\n+  end select\n+  deallocate(t%val)\n+end\n+"}]}