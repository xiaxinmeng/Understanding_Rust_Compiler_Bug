{"sha": "989037420d10d9dcd81032ccf8d5e4307f6d9a40", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg5MDM3NDIwZDEwZDlkY2Q4MTAzMmNjZjhkNWU0MzA3ZjZkOWE0MA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-11-03T22:44:10Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-11-03T22:44:10Z"}, "message": "haifa-sched.c (find_rgns): Replace uses of alloca with xmalloc.\n\n\t* haifa-sched.c (find_rgns): Replace uses of alloca with xmalloc.\n\t(split_edges): Likewise.\n\t(schedule_block): Likewise.\n\t(compute_block_backward_dependencies): Likewise.\n\t(schedule_region): Likewise.\n\t(schedule_insns): Likewise.\n\nFrom-SVN: r30383", "tree": {"sha": "06975e6d390cd3d8960435ed0a00170228afe0da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06975e6d390cd3d8960435ed0a00170228afe0da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/989037420d10d9dcd81032ccf8d5e4307f6d9a40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/989037420d10d9dcd81032ccf8d5e4307f6d9a40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/989037420d10d9dcd81032ccf8d5e4307f6d9a40", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/989037420d10d9dcd81032ccf8d5e4307f6d9a40/comments", "author": null, "committer": null, "parents": [{"sha": "8cd0faaf3206d06e32552108f6e66674730d2e7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cd0faaf3206d06e32552108f6e66674730d2e7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cd0faaf3206d06e32552108f6e66674730d2e7d"}], "stats": {"total": 238, "additions": 149, "deletions": 89}, "files": [{"sha": "bdf63379f12e97bceecc096aeae225faeadf6d2a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/989037420d10d9dcd81032ccf8d5e4307f6d9a40/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/989037420d10d9dcd81032ccf8d5e4307f6d9a40/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=989037420d10d9dcd81032ccf8d5e4307f6d9a40", "patch": "@@ -1,3 +1,12 @@\n+Wed Nov  3 14:51:59 1999  Mark P. Mitchell  <mark@codesourcery.com>\n+\n+\t* haifa-sched.c (find_rgns): Replace uses of alloca with xmalloc.\n+\t(split_edges): Likewise.\n+\t(schedule_block): Likewise.\n+\t(compute_block_backward_dependencies): Likewise.\n+\t(schedule_region): Likewise.\n+\t(schedule_insns): Likewise.\n+\t\n Wed Nov  3 15:40:23 1999  Catherine Moore  <clm@cygnus.com>\n \n         * defaults.h (ASM_OUTPUT_ALTERNATE_LABEL_NAME): Provide default.\n@@ -155,7 +164,8 @@ Mon Nov  1 15:41:01 1999  Mark P. Mitchell  <mark@codesourcery.com>\n \t(combine_givs): Likewise.\n \t(recombine_givs): Likewise.\n \t* reorg.c (dbr_schedule): Likewise.\n-\n+\t* unroll.c (unroll_loop): Likewise.\n+\t\n \t* combine.c (combine_instructions): Use xmalloc instead of alloca.\n \n Mon Nov  1 13:22:30 1999  Richard Henderson  <rth@cygnus.com>"}, {"sha": "e76a5cd00fadcd947ce7f5bc570228b26d197b4e", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 138, "deletions": 88, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/989037420d10d9dcd81032ccf8d5e4307f6d9a40/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/989037420d10d9dcd81032ccf8d5e4307f6d9a40/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=989037420d10d9dcd81032ccf8d5e4307f6d9a40", "patch": "@@ -1386,7 +1386,7 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n      int *num_succs;\n      sbitmap *dom;\n {\n-  int *max_hdr, *dfs_nr, *stack, *queue, *degree;\n+  int *max_hdr, *dfs_nr, *stack, *degree;\n   char no_loops = 1;\n   int node, child, loop_head, i, head, tail;\n   int count = 0, sp, idx = 0, current_edge = out_edges[0];\n@@ -1418,10 +1418,9 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n      STACK, SP and DFS_NR are only used during the first traversal.  */\n \n   /* Allocate and initialize variables for the first traversal.  */\n-  max_hdr = (int *) alloca (n_basic_blocks * sizeof (int));\n-  dfs_nr = (int *) alloca (n_basic_blocks * sizeof (int));\n-  bzero ((char *) dfs_nr, n_basic_blocks * sizeof (int));\n-  stack = (int *) alloca (nr_edges * sizeof (int));\n+  max_hdr = (int *) xmalloc (n_basic_blocks * sizeof (int));\n+  dfs_nr = (int *) xcalloc (n_basic_blocks, sizeof (int));\n+  stack = (int *) xmalloc (nr_edges * sizeof (int));\n \n   inner = sbitmap_alloc (n_basic_blocks);\n   sbitmap_ones (inner);\n@@ -1551,13 +1550,15 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n      blocks.  */\n   if (!unreachable)\n     {\n+      int *queue;\n+\n       if (no_loops)\n \tSET_BIT (header, 0);\n \n       /* Second travsersal:find reducible inner loops and topologically sort\n \t block of each region.  */\n \n-      queue = (int *) alloca (n_basic_blocks * sizeof (int));\n+      queue = (int *) xmalloc (n_basic_blocks * sizeof (int));\n \n       /* Find blocks which are inner loop headers.  We still have non-reducible\n \t loops to consider at this point.  */\n@@ -1769,6 +1770,7 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n \t\t}\n \t    }\n \t}\n+      free (queue);\n     }\n \n   /* Any block that did not end up in a region is placed into a region\n@@ -1783,6 +1785,9 @@ find_rgns (s_preds, s_succs, num_preds, num_succs, dom)\n \tBLOCK_TO_BB (i) = 0;\n       }\n \n+  free (max_hdr);\n+  free (dfs_nr);\n+  free (stack);\n   free (passed);\n   free (header);\n   free (inner);\n@@ -1883,12 +1888,13 @@ split_edges (bb_src, bb_trg, bl)\n      edgelst *bl;\n {\n   int es = edgeset_size;\n-  edgeset src = (edgeset) alloca (es * sizeof (HOST_WIDE_INT));\n+  edgeset src = (edgeset) xmalloc (es * sizeof (HOST_WIDE_INT));\n \n   while (es--)\n     src[es] = (pot_split[bb_src])[es];\n   BITSET_DIFFER (src, pot_split[bb_trg], edgeset_size);\n   extract_bitlst (src, edgeset_size, bl);\n+  free (src);\n }\n \n \n@@ -5795,8 +5801,8 @@ schedule_block (bb, rgn_n_insns)\n   /* Prepare current target block info.  */\n   if (current_nr_blocks > 1)\n     {\n-      candidate_table = (candidate *) alloca (current_nr_blocks \n-\t\t\t\t\t      * sizeof (candidate));\n+      candidate_table = (candidate *) xmalloc (current_nr_blocks \n+\t\t\t\t\t       * sizeof (candidate));\n \n       bblst_last = 0;\n       /* ??? It is not clear why bblst_size is computed this way.  The original\n@@ -5805,19 +5811,19 @@ schedule_block (bb, rgn_n_insns)\n \t members) seems to be a reasonable solution.  */\n       /* ??? Or perhaps there is a bug somewhere else in this file?  */\n       bblst_size = (current_nr_blocks - bb) * rgn_nr_edges * 2;\n-      bblst_table = (int *) alloca (bblst_size * sizeof (int));\n+      bblst_table = (int *) xmalloc (bblst_size * sizeof (int));\n \n       bitlst_table_last = 0;\n       bitlst_table_size = rgn_nr_edges;\n-      bitlst_table = (int *) alloca (rgn_nr_edges * sizeof (int));\n+      bitlst_table = (int *) xmalloc (rgn_nr_edges * sizeof (int));\n \n       compute_trg_info (bb);\n     }\n \n   clear_units ();\n \n   /* Allocate the ready list.  */\n-  ready = (rtx *) alloca ((rgn_n_insns + 1) * sizeof (rtx));\n+  ready = (rtx *) xmalloc ((rgn_n_insns + 1) * sizeof (rtx));\n \n   /* Print debugging information.  */\n   if (sched_verbose >= 5)\n@@ -6099,6 +6105,15 @@ schedule_block (bb, rgn_n_insns)\n \t       INSN_UID (BLOCK_END (b)));\n     }\n \n+  /* Clean up.  */\n+  if (current_nr_blocks > 1)\n+    {\n+      free (candidate_table);\n+      free (bblst_table);\n+      free (bitlst_table);\n+    }\n+  free (ready);\n+\n   return (sched_n_insns);\n }\t\t\t\t/* schedule_block () */\n \f\n@@ -6312,13 +6327,9 @@ compute_block_backward_dependences (bb)\n \n   if (current_nr_blocks == 1)\n     {\n-      reg_last_uses = (rtx *) alloca (max_reg * sizeof (rtx));\n-      reg_last_sets = (rtx *) alloca (max_reg * sizeof (rtx));\n-      reg_last_clobbers = (rtx *) alloca (max_reg * sizeof (rtx));\n-\n-      bzero ((char *) reg_last_uses, max_reg * sizeof (rtx));\n-      bzero ((char *) reg_last_sets, max_reg * sizeof (rtx));\n-      bzero ((char *) reg_last_clobbers, max_reg * sizeof (rtx));\n+      reg_last_uses = (rtx *) xcalloc (max_reg, sizeof (rtx));\n+      reg_last_sets = (rtx *) xcalloc (max_reg, sizeof (rtx));\n+      reg_last_clobbers = (rtx *) xcalloc (max_reg, sizeof (rtx));\n \n       pending_read_insns = 0;\n       pending_read_mems = 0;\n@@ -6515,6 +6526,12 @@ compute_block_backward_dependences (bb)\n       bb_reg_last_sets[bb] = (rtx *) NULL_RTX;\n       bb_reg_last_clobbers[bb] = (rtx *) NULL_RTX;\n     }\n+  else if (current_nr_blocks == 1)\n+    {\n+      free (reg_last_uses);\n+      free (reg_last_sets);\n+      free (reg_last_clobbers);\n+    }\n }\n \n /* Print dependences for debugging, callable from debugger.  */\n@@ -6660,6 +6677,9 @@ schedule_region (rgn)\n   int bb;\n   int rgn_n_insns = 0;\n   int sched_rgn_n_insns = 0;\n+  rtx *bb_reg_last_uses_space = NULL;\n+  rtx *bb_reg_last_sets_space = NULL;\n+  rtx *bb_reg_last_clobbers_space = NULL;\n \n   /* Set variables for the current region.  */\n   current_nr_blocks = RGN_NR_BLOCKS (rgn);\n@@ -6675,37 +6695,41 @@ schedule_region (rgn)\n       rtx *space;\n       int maxreg = max_reg_num ();\n \n-      bb_reg_last_uses = (rtx **) alloca (current_nr_blocks * sizeof (rtx *));\n-      space = (rtx *) alloca (current_nr_blocks * maxreg * sizeof (rtx));\n-      bzero ((char *) space, current_nr_blocks * maxreg * sizeof (rtx));\n-      init_rtx_vector (bb_reg_last_uses, space, current_nr_blocks,\n-\t\t       maxreg * sizeof (rtx *));\n+      bb_reg_last_uses = (rtx **) xmalloc (current_nr_blocks * sizeof (rtx *));\n+      bb_reg_last_uses_space \n+\t= (rtx *) xcalloc (current_nr_blocks * maxreg, sizeof (rtx));\n+      init_rtx_vector (bb_reg_last_uses, bb_reg_last_uses_space, \n+\t\t       current_nr_blocks, maxreg * sizeof (rtx *));\n \n-      bb_reg_last_sets = (rtx **) alloca (current_nr_blocks * sizeof (rtx *));\n-      space = (rtx *) alloca (current_nr_blocks * maxreg * sizeof (rtx));\n-      bzero ((char *) space, current_nr_blocks * maxreg * sizeof (rtx));\n-      init_rtx_vector (bb_reg_last_sets, space, current_nr_blocks,\n-\t\t       maxreg * sizeof (rtx *));\n+      bb_reg_last_sets = (rtx **) xmalloc (current_nr_blocks * sizeof (rtx *));\n+      bb_reg_last_sets_space \n+\t= (rtx *) xcalloc (current_nr_blocks * maxreg, sizeof (rtx));\n+      init_rtx_vector (bb_reg_last_sets, bb_reg_last_sets_space, \n+\t\t       current_nr_blocks, maxreg * sizeof (rtx *));\n \n       bb_reg_last_clobbers =\n-\t(rtx **) alloca (current_nr_blocks * sizeof (rtx *));\n-      space = (rtx *) alloca (current_nr_blocks * maxreg * sizeof (rtx));\n-      bzero ((char *) space, current_nr_blocks * maxreg * sizeof (rtx));\n-      init_rtx_vector (bb_reg_last_clobbers, space, current_nr_blocks,\n-\t\t       maxreg * sizeof (rtx *));\n-\n-      bb_pending_read_insns = (rtx *) alloca (current_nr_blocks * sizeof (rtx));\n-      bb_pending_read_mems = (rtx *) alloca (current_nr_blocks * sizeof (rtx));\n+\t(rtx **) xmalloc (current_nr_blocks * sizeof (rtx *));\n+      bb_reg_last_clobbers_space \n+\t= (rtx *) xcalloc (current_nr_blocks * maxreg, sizeof (rtx));\n+      init_rtx_vector (bb_reg_last_clobbers, bb_reg_last_clobbers_space, \n+\t\t       current_nr_blocks, maxreg * sizeof (rtx *));\n+\n+      bb_pending_read_insns \n+\t= (rtx *) xmalloc (current_nr_blocks * sizeof (rtx));\n+      bb_pending_read_mems \n+\t= (rtx *) xmalloc (current_nr_blocks * sizeof (rtx));\n       bb_pending_write_insns =\n-\t(rtx *) alloca (current_nr_blocks * sizeof (rtx));\n-      bb_pending_write_mems = (rtx *) alloca (current_nr_blocks * sizeof (rtx));\n+\t(rtx *) xmalloc (current_nr_blocks * sizeof (rtx));\n+      bb_pending_write_mems \n+\t= (rtx *) xmalloc (current_nr_blocks * sizeof (rtx));\n       bb_pending_lists_length =\n-\t(int *) alloca (current_nr_blocks * sizeof (int));\n+\t(int *) xmalloc (current_nr_blocks * sizeof (int));\n       bb_last_pending_memory_flush =\n-\t(rtx *) alloca (current_nr_blocks * sizeof (rtx));\n-      bb_last_function_call = (rtx *) alloca (current_nr_blocks * sizeof (rtx));\n+\t(rtx *) xmalloc (current_nr_blocks * sizeof (rtx));\n+      bb_last_function_call \n+\t= (rtx *) xmalloc (current_nr_blocks * sizeof (rtx));\n       bb_sched_before_next_call =\n-\t(rtx *) alloca (current_nr_blocks * sizeof (rtx));\n+\t(rtx *) xmalloc (current_nr_blocks * sizeof (rtx));\n \n       init_rgn_data_dependences (current_nr_blocks);\n     }\n@@ -6735,23 +6759,20 @@ schedule_region (rgn)\n     {\n       int i;\n \n-      prob = (float *) alloca ((current_nr_blocks) * sizeof (float));\n+      prob = (float *) xmalloc ((current_nr_blocks) * sizeof (float));\n \n       bbset_size = current_nr_blocks / HOST_BITS_PER_WIDE_INT + 1;\n-      dom = (bbset *) alloca (current_nr_blocks * sizeof (bbset));\n+      dom = (bbset *) xmalloc (current_nr_blocks * sizeof (bbset));\n       for (i = 0; i < current_nr_blocks; i++)\n-\t{\n-\t  dom[i] = (bbset) alloca (bbset_size * sizeof (HOST_WIDE_INT));\n-\t  bzero ((char *) dom[i], bbset_size * sizeof (HOST_WIDE_INT));\n-\t}\n+\tdom[i] = (bbset) xcalloc (bbset_size, sizeof (HOST_WIDE_INT));\n \n       /* Edge to bit.  */\n       rgn_nr_edges = 0;\n-      edge_to_bit = (int *) alloca (nr_edges * sizeof (int));\n+      edge_to_bit = (int *) xmalloc (nr_edges * sizeof (int));\n       for (i = 1; i < nr_edges; i++)\n \tif (CONTAINING_RGN (FROM_BLOCK (i)) == rgn)\n \t  EDGE_TO_BIT (i) = rgn_nr_edges++;\n-      rgn_edges = (int *) alloca (rgn_nr_edges * sizeof (int));\n+      rgn_edges = (int *) xmalloc (rgn_nr_edges * sizeof (int));\n \n       rgn_nr_edges = 0;\n       for (i = 1; i < nr_edges; i++)\n@@ -6760,19 +6781,15 @@ schedule_region (rgn)\n \n       /* Split edges.  */\n       edgeset_size = rgn_nr_edges / HOST_BITS_PER_WIDE_INT + 1;\n-      pot_split = (edgeset *) alloca (current_nr_blocks * sizeof (edgeset));\n-      ancestor_edges = (edgeset *) alloca (current_nr_blocks \n-\t\t\t\t\t   * sizeof (edgeset));\n+      pot_split = (edgeset *) xmalloc (current_nr_blocks * sizeof (edgeset));\n+      ancestor_edges \n+\t= (edgeset *) xmalloc (current_nr_blocks * sizeof (edgeset));\n       for (i = 0; i < current_nr_blocks; i++)\n \t{\n \t  pot_split[i] =\n-\t    (edgeset) alloca (edgeset_size * sizeof (HOST_WIDE_INT));\n-\t  bzero ((char *) pot_split[i],\n-\t\t edgeset_size * sizeof (HOST_WIDE_INT));\n+\t    (edgeset) xcalloc (edgeset_size, sizeof (HOST_WIDE_INT));\n \t  ancestor_edges[i] =\n-\t    (edgeset) alloca (edgeset_size * sizeof (HOST_WIDE_INT));\n-\t  bzero ((char *) ancestor_edges[i],\n-\t\t edgeset_size * sizeof (HOST_WIDE_INT));\n+\t    (edgeset) xcalloc (edgeset_size, sizeof (HOST_WIDE_INT));\n \t}\n \n       /* Compute probabilities, dominators, split_edges.  */\n@@ -6782,13 +6799,7 @@ schedule_region (rgn)\n \n   /* Now we can schedule all blocks.  */\n   for (bb = 0; bb < current_nr_blocks; bb++)\n-    {\n-      sched_rgn_n_insns += schedule_block (bb, rgn_n_insns);\n-\n-#ifdef USE_C_ALLOCA\n-      alloca (0);\n-#endif\n-    }\n+    sched_rgn_n_insns += schedule_block (bb, rgn_n_insns);\n \n   /* Sanity check: verify that all region insns were scheduled.  */\n   if (sched_rgn_n_insns != rgn_n_insns)\n@@ -6806,6 +6817,38 @@ schedule_region (rgn)\n \n   FREE_REG_SET (reg_pending_sets);\n   FREE_REG_SET (reg_pending_clobbers);\n+\n+  if (current_nr_blocks > 1)\n+    {\n+      int i;\n+\n+      free (bb_reg_last_uses_space);\n+      free (bb_reg_last_uses);\n+      free (bb_reg_last_sets_space);\n+      free (bb_reg_last_sets);\n+      free (bb_reg_last_clobbers_space);\n+      free (bb_reg_last_clobbers);\n+      free (bb_pending_read_insns);\n+      free (bb_pending_read_mems);\n+      free (bb_pending_write_insns);\n+      free (bb_pending_write_mems);\n+      free (bb_pending_lists_length);\n+      free (bb_last_pending_memory_flush);\n+      free (bb_last_function_call);\n+      free (bb_sched_before_next_call);\n+      free (prob);\n+      for (i = 0; i < current_nr_blocks; ++i)\n+\t{\n+\t  free (dom[i]);\n+\t  free (pot_split[i]);\n+\t  free (ancestor_edges[i]);\n+\t}\n+      free (dom);\n+      free (edge_to_bit);\n+      free (rgn_edges);\n+      free (pot_split);\n+      free (ancestor_edges);\n+    }\n }\n \n /* The one entry point in this file.  DUMP_FILE is the dump file for\n@@ -6892,10 +6935,10 @@ schedule_insns (dump_file)\n     }\n \n   nr_regions = 0;\n-  rgn_table = (region *) alloca ((n_basic_blocks) * sizeof (region));\n-  rgn_bb_table = (int *) alloca ((n_basic_blocks) * sizeof (int));\n-  block_to_bb = (int *) alloca ((n_basic_blocks) * sizeof (int));\n-  containing_rgn = (int *) alloca ((n_basic_blocks) * sizeof (int));\n+  rgn_table = (region *) xmalloc ((n_basic_blocks) * sizeof (region));\n+  rgn_bb_table = (int *) xmalloc ((n_basic_blocks) * sizeof (int));\n+  block_to_bb = (int *) xmalloc ((n_basic_blocks) * sizeof (int));\n+  containing_rgn = (int *) xmalloc ((n_basic_blocks) * sizeof (int));\n \n   blocks = sbitmap_alloc (n_basic_blocks);\n   large_region_blocks = sbitmap_alloc (n_basic_blocks);\n@@ -6922,12 +6965,12 @@ schedule_insns (dump_file)\n \t  int *num_preds, *num_succs;\n \t  sbitmap *dom, *pdom;\n \n-\t  s_preds = (int_list_ptr *) alloca (n_basic_blocks\n-\t\t\t\t\t     * sizeof (int_list_ptr));\n-\t  s_succs = (int_list_ptr *) alloca (n_basic_blocks\n-\t\t\t\t\t     * sizeof (int_list_ptr));\n-\t  num_preds = (int *) alloca (n_basic_blocks * sizeof (int));\n-\t  num_succs = (int *) alloca (n_basic_blocks * sizeof (int));\n+\t  s_preds = (int_list_ptr *) xmalloc (n_basic_blocks\n+\t\t\t\t\t      * sizeof (int_list_ptr));\n+\t  s_succs = (int_list_ptr *) xmalloc (n_basic_blocks\n+\t\t\t\t\t      * sizeof (int_list_ptr));\n+\t  num_preds = (int *) xmalloc (n_basic_blocks * sizeof (int));\n+\t  num_succs = (int *) xmalloc (n_basic_blocks * sizeof (int));\n \t  dom = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n \t  pdom = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n \n@@ -6966,6 +7009,10 @@ schedule_insns (dump_file)\n \t  free_bb_mem ();\n \t  free (dom);\n \t  free (pdom);\n+\t  free (s_preds);\n+\t  free (s_succs);\n+\t  free (num_preds);\n+\t  free (num_succs);\n \t}\n     }\n \n@@ -6987,7 +7034,7 @@ schedule_insns (dump_file)\n   insn_dep_count = (int *) xcalloc (max_uid, sizeof (int));\n   insn_depend = (rtx *) xcalloc (max_uid, sizeof (rtx));\n \n-  deaths_in_region = (int *) alloca (sizeof(int) * nr_regions);\n+  deaths_in_region = (int *) xmalloc (sizeof(int) * nr_regions);\n \n   init_alias_analysis ();\n \n@@ -6996,8 +7043,7 @@ schedule_insns (dump_file)\n       rtx line;\n \n       line_note = (rtx *) xcalloc (max_uid, sizeof (rtx));\n-      line_note_head = (rtx *) alloca (n_basic_blocks * sizeof (rtx));\n-      bzero ((char *) line_note_head, n_basic_blocks * sizeof (rtx));\n+      line_note_head = (rtx *) xcalloc (n_basic_blocks, sizeof (rtx));\n \n       /* Save-line-note-head:\n          Determine the line-number at the start of each basic block.\n@@ -7048,13 +7094,7 @@ schedule_insns (dump_file)\n \n   /* Schedule every region in the subroutine.  */\n   for (rgn = 0; rgn < nr_regions; rgn++)\n-    {\n-      schedule_region (rgn);\n-\n-#ifdef USE_C_ALLOCA\n-      alloca (0);\n-#endif\n-    }\n+    schedule_region (rgn);\n \n   /* Update life analysis for the subroutine.  Do single block regions\n      first so that we can verify that live_at_start didn't change.  Then\n@@ -7131,6 +7171,10 @@ schedule_insns (dump_file)\n       free (true_dependency_cache);\n       true_dependency_cache = NULL;\n     }\n+  free (rgn_table);\n+  free (rgn_bb_table);\n+  free (block_to_bb);\n+  free (containing_rgn);\n   free (cant_move);\n   free (fed_by_spec_load);\n   free (is_load_insn);\n@@ -7148,7 +7192,10 @@ schedule_insns (dump_file)\n   free (insn_depend);\n \n   if (write_symbols != NO_DEBUG)\n-    free (line_note);\n+    {\n+      free (line_note);\n+      free (line_note_head);\n+    }\n \n   if (edge_table)\n     {\n@@ -7169,5 +7216,8 @@ schedule_insns (dump_file)\n \n   sbitmap_free (blocks);\n   sbitmap_free (large_region_blocks);\n+\n+  free (deaths_in_region);\n }\n+\n #endif /* INSN_SCHEDULING */"}]}