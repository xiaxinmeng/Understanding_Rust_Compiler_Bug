{"sha": "5a431b60d1f221992e5e9f7a5c032df3b5fa35a5", "node_id": "C_kwDOANBUbNoAKDVhNDMxYjYwZDFmMjIxOTkyZTVlOWY3YTVjMDMyZGYzYjVmYTM1YTU", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2022-01-04T20:44:23Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2022-01-04T20:44:23Z"}, "message": "Eenable -Winvalid-memory-order for C++ [PR99612].\n\nResolves:\nPR middle-end/99612 - Remove \"#pragma GCC system_header\" from atomic file to warn on incorrect memory order\n\ngcc/ChangeLog:\n\n\tPR middle-end/99612\n\t* builtins.c (get_memmodel): Move warning code to\n\tgimple-ssa-warn-access.cc.\n\t(expand_builtin_atomic_compare_exchange): Same.\n\t(expand_ifn_atomic_compare_exchange): Same.\n\t(expand_builtin_atomic_load): Same.\n\t(expand_builtin_atomic_store): Same.\n\t(expand_builtin_atomic_clear): Same.\n\t* doc/extend.texi (__atomic_exchange_n): Update valid memory\n\tmodels.\n\t* gimple-ssa-warn-access.cc (memmodel_to_uhwi): New function.\n\t(struct memmodel_pair): New struct.\n\t(memmodel_name): New function.\n\t(pass_waccess::maybe_warn_memmodel): New function.\n\t(pass_waccess::check_atomic_memmodel): New function.\n\t(pass_waccess::check_atomic_builtin): Handle memory model.\n\t* input.c (expansion_point_location_if_in_system_header): Return\n\toriginal location if expansion location is in a system header.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/99612\n\t* c-c++-common/pr83059.c: Adjust text of expected diagnostics.\n\t* gcc.dg/atomic-invalid-2.c: Same.\n\t* gcc.dg/atomic-invalid.c: Same.\n\t* c-c++-common/Winvalid-memory-model.c: New test.\n\t* g++.dg/warn/Winvalid-memory-model-2.C: New test.\n\t* g++.dg/warn/Winvalid-memory-model.C: New test.", "tree": {"sha": "319fb92e6b01d318b29a1db210bf8b649cd65951", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/319fb92e6b01d318b29a1db210bf8b649cd65951"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a431b60d1f221992e5e9f7a5c032df3b5fa35a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a431b60d1f221992e5e9f7a5c032df3b5fa35a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a431b60d1f221992e5e9f7a5c032df3b5fa35a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a431b60d1f221992e5e9f7a5c032df3b5fa35a5/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "708b87dcb6e48cb48d170a4b3625088995377a5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/708b87dcb6e48cb48d170a4b3625088995377a5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/708b87dcb6e48cb48d170a4b3625088995377a5c"}], "stats": {"total": 856, "additions": 736, "deletions": 120}, "files": [{"sha": "51d3635bd57c7240f4385117c4c6206e34445313", "filename": "gcc/builtins.c", "status": "modified", "additions": 29, "deletions": 95, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a431b60d1f221992e5e9f7a5c032df3b5fa35a5/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a431b60d1f221992e5e9f7a5c032df3b5fa35a5/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=5a431b60d1f221992e5e9f7a5c032df3b5fa35a5", "patch": "@@ -5791,35 +5791,22 @@ expand_builtin_sync_lock_release (machine_mode mode, tree exp)\n static enum memmodel\n get_memmodel (tree exp)\n {\n-  rtx op;\n-  unsigned HOST_WIDE_INT val;\n-  location_t loc\n-    = expansion_point_location_if_in_system_header (input_location);\n-\n   /* If the parameter is not a constant, it's a run time value so we'll just\n      convert it to MEMMODEL_SEQ_CST to avoid annoying runtime checking.  */\n   if (TREE_CODE (exp) != INTEGER_CST)\n     return MEMMODEL_SEQ_CST;\n \n-  op = expand_normal (exp);\n+  rtx op = expand_normal (exp);\n \n-  val = INTVAL (op);\n+  unsigned HOST_WIDE_INT val = INTVAL (op);\n   if (targetm.memmodel_check)\n     val = targetm.memmodel_check (val);\n   else if (val & ~MEMMODEL_MASK)\n-    {\n-      warning_at (loc, OPT_Winvalid_memory_model,\n-\t\t  \"unknown architecture specifier in memory model to builtin\");\n-      return MEMMODEL_SEQ_CST;\n-    }\n+    return MEMMODEL_SEQ_CST;\n \n   /* Should never see a user explicit SYNC memodel model, so >= LAST works. */\n   if (memmodel_base (val) >= MEMMODEL_LAST)\n-    {\n-      warning_at (loc, OPT_Winvalid_memory_model,\n-\t\t  \"invalid memory model argument to builtin\");\n-      return MEMMODEL_SEQ_CST;\n-    }\n+    return MEMMODEL_SEQ_CST;\n \n   /* Workaround for Bugzilla 59448. GCC doesn't track consume properly, so\n      be conservative and promote consume to acquire.  */\n@@ -5866,28 +5853,17 @@ expand_builtin_atomic_compare_exchange (machine_mode mode, tree exp,\n {\n   rtx expect, desired, mem, oldval;\n   rtx_code_label *label;\n-  enum memmodel success, failure;\n   tree weak;\n   bool is_weak;\n-  location_t loc\n-    = expansion_point_location_if_in_system_header (input_location);\n \n-  success = get_memmodel (CALL_EXPR_ARG (exp, 4));\n-  failure = get_memmodel (CALL_EXPR_ARG (exp, 5));\n+  memmodel success = get_memmodel (CALL_EXPR_ARG (exp, 4));\n+  memmodel failure = get_memmodel (CALL_EXPR_ARG (exp, 5));\n \n   if (failure > success)\n-    {\n-      warning_at (loc, OPT_Winvalid_memory_model,\n-\t\t  \"failure memory model cannot be stronger than success \"\n-\t\t  \"memory model for %<__atomic_compare_exchange%>\");\n-      success = MEMMODEL_SEQ_CST;\n-    }\n+    success = MEMMODEL_SEQ_CST;\n  \n   if (is_mm_release (failure) || is_mm_acq_rel (failure))\n     {\n-      warning_at (loc, OPT_Winvalid_memory_model,\n-\t\t  \"invalid failure memory model for \"\n-\t\t  \"%<__atomic_compare_exchange%>\");\n       failure = MEMMODEL_SEQ_CST;\n       success = MEMMODEL_SEQ_CST;\n     }\n@@ -5992,29 +5968,15 @@ expand_ifn_atomic_compare_exchange (gcall *call)\n   int size = tree_to_shwi (gimple_call_arg (call, 3)) & 255;\n   gcc_assert (size == 1 || size == 2 || size == 4 || size == 8 || size == 16);\n   machine_mode mode = int_mode_for_size (BITS_PER_UNIT * size, 0).require ();\n-  rtx expect, desired, mem, oldval, boolret;\n-  enum memmodel success, failure;\n-  tree lhs;\n-  bool is_weak;\n-  location_t loc\n-    = expansion_point_location_if_in_system_header (gimple_location (call));\n \n-  success = get_memmodel (gimple_call_arg (call, 4));\n-  failure = get_memmodel (gimple_call_arg (call, 5));\n+  memmodel success = get_memmodel (gimple_call_arg (call, 4));\n+  memmodel failure = get_memmodel (gimple_call_arg (call, 5));\n \n   if (failure > success)\n-    {\n-      warning_at (loc, OPT_Winvalid_memory_model,\n-\t\t  \"failure memory model cannot be stronger than success \"\n-\t\t  \"memory model for %<__atomic_compare_exchange%>\");\n-      success = MEMMODEL_SEQ_CST;\n-    }\n+    success = MEMMODEL_SEQ_CST;\n \n   if (is_mm_release (failure) || is_mm_acq_rel (failure))\n     {\n-      warning_at (loc, OPT_Winvalid_memory_model,\n-\t\t  \"invalid failure memory model for \"\n-\t\t  \"%<__atomic_compare_exchange%>\");\n       failure = MEMMODEL_SEQ_CST;\n       success = MEMMODEL_SEQ_CST;\n     }\n@@ -6026,15 +5988,15 @@ expand_ifn_atomic_compare_exchange (gcall *call)\n     }\n \n   /* Expand the operands.  */\n-  mem = get_builtin_sync_mem (gimple_call_arg (call, 0), mode);\n+  rtx mem = get_builtin_sync_mem (gimple_call_arg (call, 0), mode);\n \n-  expect = expand_expr_force_mode (gimple_call_arg (call, 1), mode);\n-  desired = expand_expr_force_mode (gimple_call_arg (call, 2), mode);\n+  rtx expect = expand_expr_force_mode (gimple_call_arg (call, 1), mode);\n+  rtx desired = expand_expr_force_mode (gimple_call_arg (call, 2), mode);\n \n-  is_weak = (tree_to_shwi (gimple_call_arg (call, 3)) & 256) != 0;\n+  bool is_weak = (tree_to_shwi (gimple_call_arg (call, 3)) & 256) != 0;\n \n-  boolret = NULL;\n-  oldval = NULL;\n+  rtx boolret = NULL;\n+  rtx oldval = NULL;\n \n   if (!expand_atomic_compare_and_swap (&boolret, &oldval, mem, expect, desired,\n \t\t\t\t       is_weak, success, failure))\n@@ -6043,7 +6005,7 @@ expand_ifn_atomic_compare_exchange (gcall *call)\n       return;\n     }\n \n-  lhs = gimple_call_lhs (call);\n+  tree lhs = gimple_call_lhs (call);\n   if (lhs)\n     {\n       rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n@@ -6062,24 +6024,15 @@ expand_ifn_atomic_compare_exchange (gcall *call)\n static rtx\n expand_builtin_atomic_load (machine_mode mode, tree exp, rtx target)\n {\n-  rtx mem;\n-  enum memmodel model;\n-\n-  model = get_memmodel (CALL_EXPR_ARG (exp, 1));\n+  memmodel model = get_memmodel (CALL_EXPR_ARG (exp, 1));\n   if (is_mm_release (model) || is_mm_acq_rel (model))\n-    {\n-      location_t loc\n-\t= expansion_point_location_if_in_system_header (input_location);\n-      warning_at (loc, OPT_Winvalid_memory_model,\n-\t\t  \"invalid memory model for %<__atomic_load%>\");\n-      model = MEMMODEL_SEQ_CST;\n-    }\n+    model = MEMMODEL_SEQ_CST;\n \n   if (!flag_inline_atomics)\n     return NULL_RTX;\n \n   /* Expand the operand.  */\n-  mem = get_builtin_sync_mem (CALL_EXPR_ARG (exp, 0), mode);\n+  rtx mem = get_builtin_sync_mem (CALL_EXPR_ARG (exp, 0), mode);\n \n   return expand_atomic_load (target, mem, model);\n }\n@@ -6093,26 +6046,17 @@ expand_builtin_atomic_load (machine_mode mode, tree exp, rtx target)\n static rtx\n expand_builtin_atomic_store (machine_mode mode, tree exp)\n {\n-  rtx mem, val;\n-  enum memmodel model;\n-\n-  model = get_memmodel (CALL_EXPR_ARG (exp, 2));\n+  memmodel model = get_memmodel (CALL_EXPR_ARG (exp, 2));\n   if (!(is_mm_relaxed (model) || is_mm_seq_cst (model)\n \t|| is_mm_release (model)))\n-    {\n-      location_t loc\n-\t= expansion_point_location_if_in_system_header (input_location);\n-      warning_at (loc, OPT_Winvalid_memory_model,\n-\t\t  \"invalid memory model for %<__atomic_store%>\");\n-      model = MEMMODEL_SEQ_CST;\n-    }\n+    model = MEMMODEL_SEQ_CST;\n \n   if (!flag_inline_atomics)\n     return NULL_RTX;\n \n   /* Expand the operands.  */\n-  mem = get_builtin_sync_mem (CALL_EXPR_ARG (exp, 0), mode);\n-  val = expand_expr_force_mode (CALL_EXPR_ARG (exp, 1), mode);\n+  rtx mem = get_builtin_sync_mem (CALL_EXPR_ARG (exp, 0), mode);\n+  rtx val = expand_expr_force_mode (CALL_EXPR_ARG (exp, 1), mode);\n \n   return expand_atomic_store (mem, val, model, false);\n }\n@@ -6370,29 +6314,19 @@ expand_ifn_atomic_op_fetch_cmp_0 (gcall *call)\n static rtx\n expand_builtin_atomic_clear (tree exp) \n {\n-  machine_mode mode;\n-  rtx mem, ret;\n-  enum memmodel model;\n-\n-  mode = int_mode_for_size (BOOL_TYPE_SIZE, 0).require ();\n-  mem = get_builtin_sync_mem (CALL_EXPR_ARG (exp, 0), mode);\n-  model = get_memmodel (CALL_EXPR_ARG (exp, 1));\n+  machine_mode mode = int_mode_for_size (BOOL_TYPE_SIZE, 0).require ();\n+  rtx mem = get_builtin_sync_mem (CALL_EXPR_ARG (exp, 0), mode);\n+  memmodel model = get_memmodel (CALL_EXPR_ARG (exp, 1));\n \n   if (is_mm_consume (model) || is_mm_acquire (model) || is_mm_acq_rel (model))\n-    {\n-      location_t loc\n-\t= expansion_point_location_if_in_system_header (input_location);\n-      warning_at (loc, OPT_Winvalid_memory_model,\n-\t\t  \"invalid memory model for %<__atomic_store%>\");\n-      model = MEMMODEL_SEQ_CST;\n-    }\n+    model = MEMMODEL_SEQ_CST;\n \n   /* Try issuing an __atomic_store, and allow fallback to __sync_lock_release.\n      Failing that, a store is issued by __atomic_store.  The only way this can\n      fail is if the bool type is larger than a word size.  Unlikely, but\n      handle it anyway for completeness.  Assume a single threaded model since\n      there is no atomic support in this case, and no barriers are required.  */\n-  ret = expand_atomic_store (mem, const0_rtx, model, true);\n+  rtx ret = expand_atomic_store (mem, const0_rtx, model, true);\n   if (!ret)\n     emit_move_insn (mem, const0_rtx);\n   return const0_rtx;"}, {"sha": "637124a717229a06fd3e9b49b06acbb6e2453cbc", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a431b60d1f221992e5e9f7a5c032df3b5fa35a5/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a431b60d1f221992e5e9f7a5c032df3b5fa35a5/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=5a431b60d1f221992e5e9f7a5c032df3b5fa35a5", "patch": "@@ -12457,9 +12457,7 @@ This built-in function implements an atomic exchange operation.  It writes\n @var{val} into @code{*@var{ptr}}, and returns the previous contents of\n @code{*@var{ptr}}.\n \n-The valid memory order variants are\n-@code{__ATOMIC_RELAXED}, @code{__ATOMIC_SEQ_CST}, @code{__ATOMIC_ACQUIRE},\n-@code{__ATOMIC_RELEASE}, and @code{__ATOMIC_ACQ_REL}.\n+All memory order variants are valid.\n \n @end deftypefn\n "}, {"sha": "9f06ee80a80930274197260d412a28975746e54d", "filename": "gcc/gimple-ssa-warn-access.cc", "status": "modified", "additions": 279, "deletions": 3, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a431b60d1f221992e5e9f7a5c032df3b5fa35a5/gcc%2Fgimple-ssa-warn-access.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a431b60d1f221992e5e9f7a5c032df3b5fa35a5/gcc%2Fgimple-ssa-warn-access.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-access.cc?ref=5a431b60d1f221992e5e9f7a5c032df3b5fa35a5", "patch": "@@ -29,6 +29,7 @@\n #include \"gimple.h\"\n #include \"tree-pass.h\"\n #include \"builtins.h\"\n+#include \"diagnostic.h\"\n #include \"ssa.h\"\n #include \"gimple-pretty-print.h\"\n #include \"gimple-ssa-warn-access.h\"\n@@ -38,6 +39,8 @@\n #include \"gimple-fold.h\"\n #include \"gimple-iterator.h\"\n #include \"langhooks.h\"\n+#include \"memmodel.h\"\n+#include \"target.h\"\n #include \"tree-dfa.h\"\n #include \"tree-ssa.h\"\n #include \"tree-cfg.h\"\n@@ -2103,6 +2106,8 @@ class pass_waccess : public gimple_opt_pass\n \n   void maybe_check_dealloc_call (gcall *);\n   void maybe_check_access_sizes (rdwr_map *, tree, tree, gimple *);\n+  bool maybe_warn_memmodel (gimple *, tree, tree, const unsigned char *);\n+  void check_atomic_memmodel (gimple *, tree, tree, const unsigned char *);\n \n   /* A pointer_query object and its cache to store information about\n      pointers and their targets in.  */\n@@ -2686,6 +2691,237 @@ pass_waccess::check_read_access (gimple *stmt, tree src,\n \t\t&data, m_ptr_qry.rvals);\n }\n \n+/* Return true if memory model ORD is constant in the context of STMT and\n+   set *CSTVAL to the constant value.  Otherwise return false.  Warn for\n+   invalid ORD.  */\n+\n+bool\n+memmodel_to_uhwi (tree ord, gimple *stmt, unsigned HOST_WIDE_INT *cstval)\n+{\n+  unsigned HOST_WIDE_INT val;\n+\n+  if (TREE_CODE (ord) == INTEGER_CST)\n+    {\n+      if (!tree_fits_uhwi_p (ord))\n+\treturn false;\n+      val = tree_to_uhwi (ord);\n+    }\n+  else\n+    {\n+      /* Use the range query to determine constant values in the absence\n+\t of constant proppagation (such as at -O0).  */\n+      value_range rng;\n+      if (!get_range_query (cfun)->range_of_expr (rng, ord, stmt)\n+\t  || !rng.constant_p ()\n+\t  || !rng.singleton_p (&ord))\n+\treturn false;\n+\n+      wide_int lob = rng.lower_bound ();\n+      if (!wi::fits_uhwi_p (lob))\n+\treturn false;\n+\n+      val = lob.to_shwi ();\n+    }\n+\n+  if (targetm.memmodel_check)\n+    /* This might warn for an invalid VAL but return a conservatively\n+       valid result.  */\n+    val = targetm.memmodel_check (val);\n+  else if (val & ~MEMMODEL_MASK)\n+    {\n+      tree fndecl = gimple_call_fndecl (stmt);\n+      location_t loc = gimple_location (stmt);\n+      loc = expansion_point_location_if_in_system_header (loc);\n+\n+      warning_at (loc, OPT_Winvalid_memory_model,\n+\t\t  \"unknown architecture specifier in memory model \"\n+\t\t  \"%wi for %qD\", val, fndecl);\n+      return false;\n+    }\n+\n+  *cstval = val;\n+\n+  return true;\n+}\n+\n+/* Valid memory model for each set of atomic built-in functions.  */\n+\n+struct memmodel_pair\n+{\n+  memmodel modval;\n+  const char* modname;\n+\n+#define MEMMODEL_PAIR(val, str)\t\t\t\\\n+  { MEMMODEL_ ## val, \"memory_order_\" str }\n+};\n+\n+/* Valid memory models in the order of increasing strength.  */\n+\n+static const memmodel_pair memory_models[] =\n+  { MEMMODEL_PAIR (RELAXED, \"relaxed\"),\n+    MEMMODEL_PAIR (SEQ_CST, \"seq_cst\"),\n+    MEMMODEL_PAIR (ACQUIRE, \"acquire\"),\n+    MEMMODEL_PAIR (CONSUME, \"consume\"),\n+    MEMMODEL_PAIR (RELEASE, \"release\"),\n+    MEMMODEL_PAIR (ACQ_REL, \"acq_rel\")\n+  };\n+\n+/* Return the name of the memory model VAL.  */\n+\n+static const char*\n+memmodel_name (unsigned HOST_WIDE_INT val)\n+{\n+  val = memmodel_base (val);\n+\n+  for (unsigned i = 0; i != sizeof memory_models / sizeof *memory_models; ++i)\n+    {\n+      if (val == memory_models[i].modval)\n+\treturn memory_models[i].modname;\n+    }\n+  return NULL;\n+}\n+\n+/* Indices of valid MEMORY_MODELS above for corresponding atomic operations.  */\n+static const unsigned char load_models[] = { 0, 1, 2, 3, UCHAR_MAX };\n+static const unsigned char store_models[] = { 0, 1, 4, UCHAR_MAX };\n+static const unsigned char xchg_models[] = { 0, 1, 3, 4, 5, UCHAR_MAX };\n+static const unsigned char flag_clr_models[] = { 0, 1, 4, UCHAR_MAX };\n+static const unsigned char all_models[] = { 0, 1, 2, 3, 4, 5, UCHAR_MAX };\n+\n+/* Check the success memory model argument ORD_SUCS to the call STMT to\n+   an atomic function and warn if it's invalid.  If nonnull, also check\n+   the failure memory model ORD_FAIL and warn if it's invalid.  Return\n+   true if a warning has been issued.  */\n+\n+bool\n+pass_waccess::maybe_warn_memmodel (gimple *stmt, tree ord_sucs,\n+\t\t\t\t   tree ord_fail, const unsigned char *valid)\n+{\n+  unsigned HOST_WIDE_INT sucs, fail = 0;\n+  if (!memmodel_to_uhwi (ord_sucs, stmt, &sucs)\n+      || (ord_fail && !memmodel_to_uhwi (ord_fail, stmt, &fail)))\n+    return false;\n+\n+  bool is_valid = false;\n+  if (valid)\n+    for (unsigned i = 0; valid[i] != UCHAR_MAX; ++i)\n+      {\n+\tmemmodel model = memory_models[valid[i]].modval;\n+\tif (memmodel_base (sucs) == model)\n+\t  {\n+\t    is_valid = true;\n+\t    break;\n+\t  }\n+      }\n+  else\n+    is_valid = true;\n+\n+  tree fndecl = gimple_call_fndecl (stmt);\n+  location_t loc = gimple_location (stmt);\n+  loc = expansion_point_location_if_in_system_header (loc);\n+\n+  if (!is_valid)\n+    {\n+      bool warned = false;\n+      if (const char *modname = memmodel_name (sucs))\n+\twarned = warning_at (loc, OPT_Winvalid_memory_model,\n+\t\t\t     \"invalid memory model %qs for %qD\",\n+\t\t\t     modname, fndecl);\n+      else\n+\twarned = warning_at (loc, OPT_Winvalid_memory_model,\n+\t\t\t     \"invalid memory model %wi for %qD\",\n+\t\t\t     sucs, fndecl);\n+\n+      if (!warned)\n+\treturn false;\n+\n+      /* Print a note with the valid memory models.  */\n+      pretty_printer pp;\n+      pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+      for (unsigned i = 0; valid[i] != UCHAR_MAX; ++i)\n+\t{\n+\t  const char *modname = memory_models[valid[i]].modname;\n+\t  pp_printf (&pp, \"%s%<%s%>\", i ? \", \" : \"\", modname);\n+\t}\n+\n+      inform (loc, \"valid models are %s\", pp_formatted_text (&pp));\n+      return true;\n+    }\n+\n+  if (!ord_fail)\n+    return false;\n+\n+  if (fail == MEMMODEL_RELEASE || fail == MEMMODEL_ACQ_REL)\n+    if (const char *failname = memmodel_name (fail))\n+      {\n+\t/* If both memory model arguments are valid but their combination\n+\t   is not, use their names in the warning.  */\n+\tif (!warning_at (loc, OPT_Winvalid_memory_model,\n+\t\t\t \"invalid failure memory model %qs for %qD\",\n+\t\t\t failname, fndecl))\n+\t  return false;\n+\n+\tinform (loc,\n+\t\t\"valid failure models are %qs, %qs, %qs, %qs\",\n+\t\t\"memory_order_relaxed\", \"memory_order_seq_cst\",\n+\t\t\"memory_order_acquire\", \"memory_order_consume\");\n+\treturn true;\n+      }\n+\n+  if (memmodel_base (fail) <= memmodel_base (sucs))\n+    return false;\n+\n+  if (const char *sucsname = memmodel_name (sucs))\n+    if (const char *failname = memmodel_name (fail))\n+      {\n+\t/* If both memory model arguments are valid but their combination\n+\t   is not, use their names in the warning.  */\n+\tif (!warning_at (loc, OPT_Winvalid_memory_model,\n+\t\t\t \"failure memory model %qs cannot be stronger \"\n+\t\t\t \"than success memory model %qs for %qD\",\n+\t\t\t failname, sucsname, fndecl))\n+\t  return false;\n+\n+\t/* Print a note with the valid failure memory models which are\n+\t   those with a value less than or equal to the success mode.  */\n+\tchar buf[120];\n+\t*buf = '\\0';\n+\tfor (unsigned i = 0;\n+\t     memory_models[i].modval <= memmodel_base (sucs); ++i)\n+\t  {\n+\t    if (*buf)\n+\t      strcat (buf, \", \");\n+\n+\t    const char *modname = memory_models[valid[i]].modname;\n+\t    sprintf (buf + strlen (buf), \"'%s'\", modname);\n+\t  }\n+\n+\tinform (loc, \"valid models are %s\", buf);\n+\treturn true;\n+      }\n+\n+  /* If either memory model argument value is invalid use the numerical\n+     value of both in the message.  */\n+  return warning_at (loc, OPT_Winvalid_memory_model,\n+\t\t     \"failure memory model %wi cannot be stronger \"\n+\t\t     \"than success memory model %wi for %qD\",\n+\t\t     fail, sucs, fndecl);\n+}\n+\n+/* Wrapper for the above.  */\n+\n+void\n+pass_waccess::check_atomic_memmodel (gimple *stmt, tree ord_sucs,\n+\t\t\t\t     tree ord_fail, const unsigned char *valid)\n+{\n+  if (warning_suppressed_p (stmt, OPT_Winvalid_memory_model))\n+    return;\n+\n+  if (maybe_warn_memmodel (stmt, ord_sucs, ord_fail, valid))\n+    return;\n+\n+  suppress_warning (stmt, OPT_Winvalid_memory_model);\n+}\n \n /* Check a call STMT to an atomic or sync built-in.  */\n \n@@ -2699,12 +2935,14 @@ pass_waccess::check_atomic_builtin (gcall *stmt)\n   /* The size in bytes of the access by the function, and the number\n      of the second argument to check (if any).  */\n   unsigned bytes = 0, arg2 = UINT_MAX;\n+  unsigned sucs_arg = UINT_MAX, fail_arg = UINT_MAX;\n+  /* Points to the array of indices of valid memory models.  */\n+  const unsigned char *pvalid_models = NULL;\n \n   switch (DECL_FUNCTION_CODE (callee))\n     {\n #define BUILTIN_ACCESS_SIZE_FNSPEC(N)\t\t\t\\\n-      BUILT_IN_ATOMIC_LOAD_ ## N:\t\t\t\\\n-    case BUILT_IN_SYNC_FETCH_AND_ADD_ ## N:\t\t\\\n+      BUILT_IN_SYNC_FETCH_AND_ADD_ ## N:\t\t\\\n     case BUILT_IN_SYNC_FETCH_AND_SUB_ ## N:\t\t\\\n     case BUILT_IN_SYNC_FETCH_AND_OR_ ## N:\t\t\\\n     case BUILT_IN_SYNC_FETCH_AND_AND_ ## N:\t\t\\\n@@ -2720,8 +2958,16 @@ pass_waccess::check_atomic_builtin (gcall *stmt)\n     case BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_ ## N:\t\\\n     case BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_ ## N:\t\\\n     case BUILT_IN_SYNC_LOCK_RELEASE_ ## N:\t\t\\\n-    case BUILT_IN_ATOMIC_EXCHANGE_ ## N:\t\t\\\n+      bytes = N;\t\t\t\t\t\\\n+      break;\t\t\t\t\t\t\\\n+    case BUILT_IN_ATOMIC_LOAD_ ## N:\t\t\t\\\n+      pvalid_models = load_models;\t\t\t\\\n+      sucs_arg = 1;\t\t\t\t\t\\\n+      /* FALLTHROUGH */\t\t\t\t\t\\\n     case BUILT_IN_ATOMIC_STORE_ ## N:\t\t\t\\\n+      if (!pvalid_models)\t\t\t\t\\\n+\tpvalid_models = store_models;\t\t\t\\\n+      /* FALLTHROUGH */\t\t\t\t\t\\\n     case BUILT_IN_ATOMIC_ADD_FETCH_ ## N:\t\t\\\n     case BUILT_IN_ATOMIC_SUB_FETCH_ ## N:\t\t\\\n     case BUILT_IN_ATOMIC_AND_FETCH_ ## N:\t\t\\\n@@ -2735,9 +2981,21 @@ pass_waccess::check_atomic_builtin (gcall *stmt)\n     case BUILT_IN_ATOMIC_FETCH_OR_ ## N:\t\t\\\n     case BUILT_IN_ATOMIC_FETCH_XOR_ ## N:\t\t\\\n \tbytes = N;\t\t\t\t\t\\\n+\tif (sucs_arg == UINT_MAX)\t\t\t\\\n+\t  sucs_arg = 2;\t\t\t\t\t\\\n+\tif (!pvalid_models)\t\t\t\t\\\n+\t  pvalid_models = all_models;\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\\\n+    case BUILT_IN_ATOMIC_EXCHANGE_ ## N:\t\t\\\n+\tbytes = N;\t\t\t\t\t\\\n+\tsucs_arg = 3;\t\t\t\t\t\\\n+\tpvalid_models = xchg_models;\t\t\t\\\n \tbreak;\t\t\t\t\t\t\\\n     case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_ ## N:\t\\\n \tbytes = N;\t\t\t\t\t\\\n+\tsucs_arg = 4;\t\t\t\t\t\\\n+\tfail_arg = 5;\t\t\t\t\t\\\n+\tpvalid_models = all_models;\t\t\t\\\n \targ2 = 1\n \n     case BUILTIN_ACCESS_SIZE_FNSPEC (1);\n@@ -2751,10 +3009,28 @@ pass_waccess::check_atomic_builtin (gcall *stmt)\n     case BUILTIN_ACCESS_SIZE_FNSPEC (16);\n       break;\n \n+    case BUILT_IN_ATOMIC_CLEAR:\n+      sucs_arg = 1;\n+      pvalid_models = flag_clr_models;\n+      break;\n+\n     default:\n       return false;\n     }\n \n+  unsigned nargs = gimple_call_num_args (stmt);\n+  if (sucs_arg < nargs)\n+    {\n+      tree ord_sucs = gimple_call_arg (stmt, sucs_arg);\n+      tree ord_fail = NULL_TREE;\n+      if (fail_arg < nargs)\n+\tord_fail = gimple_call_arg (stmt, fail_arg);\n+      check_atomic_memmodel (stmt, ord_sucs, ord_fail, pvalid_models);\n+    }\n+\n+  if (!bytes)\n+    return true;\n+\n   tree size = build_int_cstu (sizetype, bytes);\n   tree dst = gimple_call_arg (stmt, 0);\n   check_memop_access (stmt, dst, NULL_TREE, size);"}, {"sha": "82e79beab1409e83bb765944477dddf05e60fb04", "filename": "gcc/input.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a431b60d1f221992e5e9f7a5c032df3b5fa35a5/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a431b60d1f221992e5e9f7a5c032df3b5fa35a5/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=5a431b60d1f221992e5e9f7a5c032df3b5fa35a5", "patch": "@@ -986,10 +986,11 @@ linemap_client_expand_location_to_spelling_point (location_t loc,\n }\n \n \n-/* If LOCATION is in a system header and if it is a virtual location for\n-   a token coming from the expansion of a macro, unwind it to the\n-   location of the expansion point of the macro.  Otherwise, just return\n-   LOCATION.\n+/* If LOCATION is in a system header and if it is a virtual location\n+   for a token coming from the expansion of a macro, unwind it to\n+   the location of the expansion point of the macro.  If the expansion\n+   point is also in a system header return the original LOCATION.\n+   Otherwise, return the location of the expansion point.\n \n    This is used for instance when we want to emit diagnostics about a\n    token that may be located in a macro that is itself defined in a\n@@ -1001,11 +1002,13 @@ linemap_client_expand_location_to_spelling_point (location_t loc,\n location_t\n expansion_point_location_if_in_system_header (location_t location)\n {\n-  if (in_system_header_at (location))\n-    location = linemap_resolve_location (line_table, location,\n-\t\t\t\t\t LRK_MACRO_EXPANSION_POINT,\n-\t\t\t\t\t NULL);\n-  return location;\n+  if (!in_system_header_at (location))\n+    return location;\n+\n+  location_t xloc = linemap_resolve_location (line_table, location,\n+\t\t\t\t\t      LRK_MACRO_EXPANSION_POINT,\n+\t\t\t\t\t      NULL);\n+  return in_system_header_at (xloc) ? location : xloc;\n }\n \n /* If LOCATION is a virtual location for a token coming from the expansion"}, {"sha": "474ea5621dc6ba7da4f621c7a410b552edb0b460", "filename": "gcc/testsuite/c-c++-common/Winvalid-memory-model.c", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a431b60d1f221992e5e9f7a5c032df3b5fa35a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWinvalid-memory-model.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a431b60d1f221992e5e9f7a5c032df3b5fa35a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWinvalid-memory-model.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWinvalid-memory-model.c?ref=5a431b60d1f221992e5e9f7a5c032df3b5fa35a5", "patch": "@@ -0,0 +1,239 @@\n+/* PR middle-end/99612 - Missing warning on incorrect memory order without\n+   -Wsystem-headers\n+   Verify that constants are propagated through calls to inline functions\n+   even at -O0.\n+   Also verify that the informational notes after each warning mention\n+   the valid memore models for each function.\n+   { dg-do compile }\n+   { dg-options \"-O0 -ftrack-macro-expansion=0\" } */\n+\n+#if !__cplusplus\n+# define bool _Bool\n+#endif\n+\n+extern int ei;\n+\n+static __attribute__ ((always_inline)) inline\n+int retval (int val)\n+{\n+  return val;\n+}\n+\n+void test_load (int *pi)\n+{\n+  int relaxed = retval (__ATOMIC_RELAXED);\n+  *pi++ = __atomic_load_n (&ei, relaxed);\n+\n+  int consume = retval (__ATOMIC_CONSUME);\n+  *pi++ = __atomic_load_n (&ei, consume);\n+\n+  int acquire = retval (__ATOMIC_ACQUIRE);\n+  *pi++ = __atomic_load_n (&ei, acquire);\n+\n+  int release = retval (__ATOMIC_RELEASE);\n+  *pi++ = __atomic_load_n (&ei, release);   // { dg-warning \"invalid memory model 'memory_order_release'\" }\n+  // { dg-message \"valid models are 'memory_order_relaxed', 'memory_order_seq_cst', 'memory_order_acquire', 'memory_order_consume'\" \"note\" { target *-*-* } .-1 }\n+\n+  int acq_rel = retval (__ATOMIC_ACQ_REL);\n+  *pi++ = __atomic_load_n (&ei, acq_rel);   // { dg-warning \"invalid memory model 'memory_order_acq_rel'\" }\n+\n+  int seq_cst = retval (__ATOMIC_SEQ_CST);\n+  *pi++ = __atomic_load_n (&ei, seq_cst);\n+\n+  /* Verify a nonconstant range.  */\n+  int r0_1 = *pi++;\n+  if (r0_1 < 0 || 1 < r0_1)\n+    r0_1 = 0;\n+  *pi++ = __atomic_load_n (&ei, r0_1);\n+\n+  /* Verify an unbounded range.  */\n+  int unknown = *pi++;\n+  *pi++ = __atomic_load_n (&ei, unknown);\n+}\n+\n+\n+void test_store (int *pi, int x)\n+{\n+  int relaxed = retval (__ATOMIC_RELAXED);\n+  __atomic_store_n (pi++, x, relaxed);\n+\n+  int consume = retval (__ATOMIC_CONSUME);\n+  __atomic_store_n (pi++, x, consume);      // { dg-warning \"invalid memory model 'memory_order_consume'\" }\n+  // { dg-message \"valid models are 'memory_order_relaxed', 'memory_order_seq_cst', 'memory_order_release'\" \"note\" { target *-*-* } .-1 }\n+\n+  int acquire = retval (__ATOMIC_ACQUIRE);\n+  __atomic_store_n (pi++, x, acquire);      // { dg-warning \"invalid memory model 'memory_order_acquire'\" }\n+\n+  int release = retval (__ATOMIC_RELEASE);\n+  __atomic_store_n (pi++, x, release);\n+\n+  int acq_rel = retval (__ATOMIC_ACQ_REL);\n+  __atomic_store_n (pi++, x, acq_rel);      // { dg-warning \"invalid memory model 'memory_order_acq_rel'\" }\n+\n+  int seq_cst = retval (__ATOMIC_SEQ_CST);\n+  __atomic_store_n (pi++, x, seq_cst);\n+\n+  int unknown = *pi++;\n+  __atomic_store_n (pi++, x, unknown);\n+}\n+\n+\n+/* All memory models are valid.  */\n+\n+void test_exchange (int *pi, int x)\n+{\n+  int relaxed = retval (__ATOMIC_RELAXED);\n+  __atomic_exchange_n (pi++, x, relaxed);\n+\n+  int consume = retval (__ATOMIC_CONSUME);\n+  __atomic_exchange_n (pi++, x, consume);\n+\n+  int acquire = retval (__ATOMIC_ACQUIRE);\n+  __atomic_exchange_n (pi++, x, acquire);\n+\n+  int release = retval (__ATOMIC_RELEASE);\n+  __atomic_exchange_n (pi++, x, release);\n+\n+  int acq_rel = retval (__ATOMIC_ACQ_REL);\n+  __atomic_exchange_n (pi++, x, acq_rel);\n+\n+  int seq_cst = retval (__ATOMIC_SEQ_CST);\n+  __atomic_exchange_n (pi++, x, seq_cst);\n+\n+  int unknown = *pi++;\n+  __atomic_exchange_n (pi++, x, unknown);\n+}\n+\n+\n+void test_compare_exchange (int *pi, int *pj, bool weak)\n+{\n+#define cmpxchg(x, expect, desire, sucs_ord, fail_ord) \\\n+  __atomic_compare_exchange_n (x, expect, desire, weak, sucs_ord, fail_ord)\n+\n+  int relaxed = retval (__ATOMIC_RELAXED);\n+  cmpxchg (&ei, pi++, *pj++, relaxed, relaxed);\n+\n+  int consume = retval (__ATOMIC_CONSUME);\n+  cmpxchg (&ei, pi++, *pj++, relaxed, consume);   // { dg-warning \"failure memory model 'memory_order_consume' cannot be stronger than success memory model 'memory_order_relaxed'\" }\n+\n+  int acquire = retval (__ATOMIC_ACQUIRE);\n+  cmpxchg (&ei, pi++, *pj++, relaxed, acquire);   // { dg-warning \"failure memory model 'memory_order_acquire' cannot be stronger than success memory model 'memory_order_relaxed'\" }\n+\n+  int release = retval (__ATOMIC_RELEASE);\n+  cmpxchg (&ei, pi++, *pj++, relaxed, release);   // { dg-warning \"invalid failure memory model 'memory_order_release'\" }\n+\n+  int acq_rel = retval (__ATOMIC_ACQ_REL);\n+  cmpxchg (&ei, pi++, *pj++, relaxed, acq_rel);   // { dg-warning \"invalid failure memory model 'memory_order_acq_rel'\" }\n+\n+  int seq_cst = retval (__ATOMIC_SEQ_CST);\n+  cmpxchg (&ei, pi++, *pj++, relaxed, seq_cst);   // { dg-warning \"failure memory model 'memory_order_seq_cst' cannot be stronger than success memory model 'memory_order_relaxed'\" }\n+\n+\n+  cmpxchg (&ei, pi++, *pj++, consume, relaxed);\n+  cmpxchg (&ei, pi++, *pj++, consume, consume);\n+  cmpxchg (&ei, pi++, *pj++, consume, acquire);   // { dg-warning \"failure memory model 'memory_order_acquire' cannot be stronger than success memory model 'memory_order_consume'\" }\n+  cmpxchg (&ei, pi++, *pj++, consume, release);   // { dg-warning \"invalid failure memory model 'memory_order_release'\" }\n+  cmpxchg (&ei, pi++, *pj++, consume, acq_rel);   // { dg-warning \"invalid failure memory model 'memory_order_acq_rel'\" }\n+  cmpxchg (&ei, pi++, *pj++, consume, seq_cst);   // { dg-warning \"failure memory model 'memory_order_seq_cst' cannot be stronger than success memory model 'memory_order_consume'\" }\n+\n+  cmpxchg (&ei, pi++, *pj++, acquire, relaxed);\n+  cmpxchg (&ei, pi++, *pj++, acquire, consume);\n+  cmpxchg (&ei, pi++, *pj++, acquire, acquire);\n+  cmpxchg (&ei, pi++, *pj++, acquire, release);   // { dg-warning \"invalid failure memory model 'memory_order_release'\" }\n+  cmpxchg (&ei, pi++, *pj++, acquire, acq_rel);   // { dg-warning \"invalid failure memory model 'memory_order_acq_rel'\" }\n+  cmpxchg (&ei, pi++, *pj++, acquire, seq_cst);   // { dg-warning \"failure memory model 'memory_order_seq_cst' cannot be stronger than success memory model 'memory_order_acquire'\" }\n+\n+  cmpxchg (&ei, pi++, *pj++, release, relaxed);\n+  cmpxchg (&ei, pi++, *pj++, release, consume);\n+  cmpxchg (&ei, pi++, *pj++, release, acquire);\n+  cmpxchg (&ei, pi++, *pj++, release, release);   // { dg-warning \"invalid failure memory model 'memory_order_release'\" }\n+  cmpxchg (&ei, pi++, *pj++, release, acq_rel);   // { dg-warning \"invalid failure memory model 'memory_order_acq_rel'\" }\n+  cmpxchg (&ei, pi++, *pj++, release, seq_cst);   // { dg-warning \"failure memory model 'memory_order_seq_cst' cannot be stronger than success memory model 'memory_order_release'\" }\n+\n+  cmpxchg (&ei, pi++, *pj++, acq_rel, relaxed);\n+  cmpxchg (&ei, pi++, *pj++, acq_rel, consume);\n+  cmpxchg (&ei, pi++, *pj++, acq_rel, acquire);\n+  cmpxchg (&ei, pi++, *pj++, acq_rel, release);   // { dg-warning \"invalid failure memory model 'memory_order_release'\" }\n+  cmpxchg (&ei, pi++, *pj++, acq_rel, acq_rel);   // { dg-warning \"invalid failure memory model 'memory_order_acq_rel'\" }\n+  cmpxchg (&ei, pi++, *pj++, acq_rel, seq_cst);   // { dg-warning \"failure memory model 'memory_order_seq_cst' cannot be stronger than success memory model 'memory_order_acq_rel'\" }\n+\n+  cmpxchg (&ei, pi++, *pj++, seq_cst, relaxed);\n+  cmpxchg (&ei, pi++, *pj++, seq_cst, consume);\n+  cmpxchg (&ei, pi++, *pj++, seq_cst, acquire);\n+  cmpxchg (&ei, pi++, *pj++, seq_cst, release);   // { dg-warning \"invalid failure memory model 'memory_order_release'\" }\n+  cmpxchg (&ei, pi++, *pj++, seq_cst, acq_rel);   // { dg-warning \"invalid failure memory model 'memory_order_acq_rel'\" }\n+  cmpxchg (&ei, pi++, *pj++, seq_cst, seq_cst);\n+\n+  int unknown = *pi++;\n+  cmpxchg (&ei, pi++, *pj++, unknown, seq_cst);\n+  cmpxchg (&ei, pi++, *pj++, relaxed, unknown);\n+}\n+\n+\n+/* All memory models are valid.  */\n+\n+void test_add_fetch (unsigned *pi, unsigned x)\n+{\n+  int relaxed = retval (__ATOMIC_RELAXED);\n+  __atomic_add_fetch (pi++, x, relaxed);\n+\n+  int consume = retval (__ATOMIC_CONSUME);\n+  __atomic_add_fetch (pi++, x, consume);\n+\n+  int acquire = retval (__ATOMIC_ACQUIRE);\n+  __atomic_add_fetch (pi++, x, acquire);\n+\n+  int release = retval (__ATOMIC_RELEASE);\n+  __atomic_add_fetch (pi++, x, release);\n+\n+  int acq_rel = retval (__ATOMIC_ACQ_REL);\n+  __atomic_add_fetch (pi++, x, acq_rel);\n+\n+  int seq_cst = retval (__ATOMIC_SEQ_CST);\n+  __atomic_add_fetch (pi++, x, seq_cst);\n+\n+  int invalid;\n+  if (x & 1)\n+    {\n+      invalid = retval (123);\n+      __atomic_add_fetch (pi++, x, invalid);  // { dg-warning \"invalid memory model 123 for '\\(unsigned int \\)?__atomic_add_fetch\" }\n+    }\n+  else\n+    {\n+      invalid = retval (456);\n+      __atomic_add_fetch (pi++, x, invalid);  // { dg-warning \"invalid memory model 456 for '\\(unsigned int \\)?__atomic_add_fetch\" }\n+    }\n+}\n+\n+void test_sub_fetch (unsigned *pi, unsigned x)\n+{\n+  int relaxed = retval (__ATOMIC_RELAXED);\n+  __atomic_sub_fetch (pi++, x, relaxed);\n+\n+  int consume = retval (__ATOMIC_CONSUME);\n+  __atomic_sub_fetch (pi++, x, consume);\n+\n+  int acquire = retval (__ATOMIC_ACQUIRE);\n+  __atomic_sub_fetch (pi++, x, acquire);\n+\n+  int release = retval (__ATOMIC_RELEASE);\n+  __atomic_sub_fetch (pi++, x, release);\n+\n+  int acq_rel = retval (__ATOMIC_ACQ_REL);\n+  __atomic_sub_fetch (pi++, x, acq_rel);\n+\n+  int seq_cst = retval (__ATOMIC_SEQ_CST);\n+  __atomic_sub_fetch (pi++, x, seq_cst);\n+\n+  int invalid;\n+  if (x & 1)\n+    {\n+      invalid = retval (123);\n+      __atomic_sub_fetch (pi++, x, invalid);  // { dg-warning \"invalid memory model 123 for '\\(unsigned int \\)?__atomic_sub_fetch\" }\n+    }\n+  else\n+    {\n+      invalid = retval (456);\n+      __atomic_sub_fetch (pi++, x, invalid);  // { dg-warning \"invalid memory model 456 for '\\(unsigned int \\)?__atomic_sub_fetch\" }\n+    }\n+}"}, {"sha": "795faa519ec043841e2e405cc439a2add3a3fa2a", "filename": "gcc/testsuite/c-c++-common/pr83059.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a431b60d1f221992e5e9f7a5c032df3b5fa35a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr83059.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a431b60d1f221992e5e9f7a5c032df3b5fa35a5/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr83059.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr83059.c?ref=5a431b60d1f221992e5e9f7a5c032df3b5fa35a5", "patch": "@@ -1,10 +1,13 @@\n-/* PR c++/83059 */\n+/* PR c++/83059 - ICE on invalid C++ code: in tree_to_uhwi, at tree.c:6633 */\n /* { dg-do compile } */\n \n void\n foo (int *p, int *q, int *r)\n {\n   __atomic_compare_exchange (p, q, r, 0, 0, -1);\t/* { dg-warning \"invalid memory model argument 6\" } */\n-  /* { dg-warning \"unknown architecture specifi\" \"\" { target *-*-* } .-1 } */\n-  /* { dg-warning \"failure memory model cannot be stronger than success memory model\" \"\" { target *-*-* } .-2 } */\n }\n+\n+/* The test triggers several distinct instance of the warning.  Prune\n+   them out; they're not relevant to its main purpose -- to verify\n+   there's no ICE.\n+   { dg-prune-output \"-Winvalid-memory-model\" } */"}, {"sha": "a15706159aafacb28706f89a612c76d4ee0b0105", "filename": "gcc/testsuite/g++.dg/warn/Winvalid-memory-model-2.C", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a431b60d1f221992e5e9f7a5c032df3b5fa35a5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWinvalid-memory-model-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a431b60d1f221992e5e9f7a5c032df3b5fa35a5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWinvalid-memory-model-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWinvalid-memory-model-2.C?ref=5a431b60d1f221992e5e9f7a5c032df3b5fa35a5", "patch": "@@ -0,0 +1,79 @@\n+/* PR middle-end/99612 - Missing warning on incorrect memory order without\n+   -Wsystem-headers\n+   Verify warnings for atomic functions with optimization.\n+   { dg-do compile { target c++11 } }\n+   { dg-options \"-O1\" } */\n+\n+#include <atomic>\n+\n+static const std::memory_order relaxed = std::memory_order_relaxed;\n+static const std::memory_order consume = std::memory_order_consume;\n+static const std::memory_order acquire = std::memory_order_acquire;\n+static const std::memory_order release = std::memory_order_release;\n+static const std::memory_order acq_rel = std::memory_order_acq_rel;\n+static const std::memory_order seq_cst = std::memory_order_seq_cst;\n+\n+extern std::atomic<int> eai;\n+\n+void test_load (int *pi)\n+{\n+  *pi++ = eai.load (relaxed);\n+  *pi++ = eai.load (consume);\n+  *pi++ = eai.load (acquire);\n+  *pi++ = eai.load (release);       // warning\n+  *pi++ = eai.load (acq_rel);       // warning\n+  *pi++ = eai.load (seq_cst);\n+}\n+\n+/* { dg-regexp \" *inlined from \\[^\\n\\r\\]+.C:23:.*\" \"\" { target *-*-* } 0 }\n+   { dg-regexp \" *inlined from \\[^\\n\\r\\]+.C:24:.*\" \"\" { target *-*-* } 0 }\n+   { dg-warning \"__atomic_load\\[^\\n\\r\\]* \\\\\\[-Winvalid-memory-model\" \"warning\" { target *-*-* } 0 } */\n+\n+\n+void test_store (int *pi)\n+{\n+  eai.store (*pi++, relaxed);\n+  eai.store (*pi++, consume);       // warning\n+  eai.store (*pi++, acquire);       // warning\n+  eai.store (*pi++, release);\n+  eai.store (*pi++, acq_rel);       // warning\n+  eai.store (*pi++, seq_cst);\n+}\n+\n+/* { dg-regexp \" *inlined from \\[^\\n\\r\\]+.C:36:.*\" \"\" { target *-*-* } 0 }\n+   { dg-regexp \" *inlined from \\[^\\n\\r\\]+.C:37:.*\" \"\" { target *-*-* } 0 }\n+   { dg-regexp \" *inlined from \\[^\\n\\r\\]+.C:39:.*\" \"\" { target *-*-* } 0 }\n+   { dg-warning \"__atomic_store\\[^\\n\\r]* \\\\\\[-Winvalid-memory-model\" \"warning\" { target *-*-* } 0 } */\n+\n+\n+void test_exchange (const int *pi)\n+{\n+  eai.exchange (*pi++, relaxed);\n+  eai.exchange (*pi++, consume);\n+  eai.exchange (*pi++, acquire);\n+  eai.exchange (*pi++, release);\n+  eai.exchange (*pi++, acq_rel);\n+  eai.exchange (*pi++, seq_cst);\n+}\n+\n+\n+void test_compare_exchange (int *pi, int *pj)\n+{\n+#define cmpxchg(x, y, z, o1, o2) \\\n+  std::atomic_compare_exchange_weak_explicit (x, y, z, o1, o2)\n+\n+  cmpxchg (&eai, pi++, *pj++, relaxed, relaxed);\n+  cmpxchg (&eai, pi++, *pj++, relaxed, consume);  // warning\n+  cmpxchg (&eai, pi++, *pj++, relaxed, acquire);  // warning\n+  cmpxchg (&eai, pi++, *pj++, relaxed, release);  // warning\n+  cmpxchg (&eai, pi++, *pj++, relaxed, acq_rel);  // warning\n+  cmpxchg (&eai, pi++, *pj++, relaxed, seq_cst);  // warning\n+  cmpxchg (&eai, pi++, *pj++, relaxed, relaxed);\n+\n+  /* { dg-regexp \" *inlined from \\[^\\n\\r\\]+.C:66:.*\" \"\" { target *-*-* } 0 }\n+     { dg-regexp \" *inlined from \\[^\\n\\r\\]+.C:67:.*\" \"\" { target *-*-* } 0 }\n+     { dg-regexp \" *inlined from \\[^\\n\\r\\]+.C:68:.*\" \"\" { target *-*-* } 0 }\n+     { dg-regexp \" *inlined from \\[^\\n\\r\\]+.C:69:.*\" \"\" { target *-*-* } 0 }\n+     { dg-regexp \" *inlined from \\[^\\n\\r\\]+.C:70:.*\" \"\" { target *-*-* } 0 }\n+     { dg-warning \"__atomic_compare_exchange\\[^\\n\\r\\]* \\\\\\[-Winvalid-memory-model\" \"cmpxchg 1\" { target *-*-* } 0 } */\n+}"}, {"sha": "5357d540e503dac6196b22683bdb27b67e58dbc1", "filename": "gcc/testsuite/g++.dg/warn/Winvalid-memory-model.C", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a431b60d1f221992e5e9f7a5c032df3b5fa35a5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWinvalid-memory-model.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a431b60d1f221992e5e9f7a5c032df3b5fa35a5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWinvalid-memory-model.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWinvalid-memory-model.C?ref=5a431b60d1f221992e5e9f7a5c032df3b5fa35a5", "patch": "@@ -0,0 +1,84 @@\n+/* PR middle-end/99612 - Missing warning on incorrect memory order without\n+   -Wsystem-headers\n+   Verify warings for basic atomic functions with no optimization.\n+   { dg-do compile { target c++11 } }\n+   { dg-options \"-O0 -Wall\" } */\n+\n+#include <atomic>\n+\n+static const std::memory_order relaxed = std::memory_order_relaxed;\n+static const std::memory_order consume = std::memory_order_consume;\n+static const std::memory_order acquire = std::memory_order_acquire;\n+static const std::memory_order release = std::memory_order_release;\n+static const std::memory_order acq_rel = std::memory_order_acq_rel;\n+static const std::memory_order seq_cst = std::memory_order_seq_cst;\n+\n+extern std::atomic<int> eai;\n+\n+void test_load (int *pi)\n+{\n+  *pi++ = eai.load (relaxed);\n+  *pi++ = eai.load (consume);\n+  *pi++ = eai.load (acquire);\n+  *pi++ = eai.load (release);       // warning\n+  *pi++ = eai.load (acq_rel);       // warning\n+  *pi++ = eai.load (seq_cst);\n+}\n+\n+/* { dg-regexp \" *inlined from \\[^\\n\\r\\]+.C:23:.*\" \"\" { target *-*-* } 0 }\n+   { dg-regexp \" *inlined from \\[^\\n\\r\\]+.C:24:.*\" \"\" { target *-*-* } 0 }\n+   { dg-warning \"__atomic_load\\[^\\n\\r\\]* \\\\\\[-Winvalid-memory-model\" \"warning\" { target *-*-* } 0 } */\n+\n+\n+void test_store (int *pi)\n+{\n+  eai.store (*pi++, relaxed);\n+  eai.store (*pi++, consume);       // warning\n+  eai.store (*pi++, acquire);       // warning\n+  eai.store (*pi++, release);\n+  eai.store (*pi++, acq_rel);       // warning\n+  eai.store (*pi++, seq_cst);\n+}\n+\n+/* { dg-regexp \" *inlined from \\[^\\n\\r\\]+.C:36:.*\" \"\" { target *-*-* } 0 }\n+   { dg-regexp \" *inlined from \\[^\\n\\r\\]+.C:37:.*\" \"\" { target *-*-* } 0 }\n+   { dg-regexp \" *inlined from \\[^\\n\\r\\]+.C:39:.*\" \"\" { target *-*-* } 0 }\n+   { dg-warning \"__atomic_store\\[^\\n\\r]* \\\\\\[-Winvalid-memory-model\" \"warning\" { target *-*-* } 0 } */\n+\n+\n+void test_exchange (const int *pi)\n+{\n+  eai.exchange (*pi++, relaxed);\n+  eai.exchange (*pi++, consume);\n+  eai.exchange (*pi++, acquire);\n+  eai.exchange (*pi++, release);\n+  eai.exchange (*pi++, acq_rel);\n+  eai.exchange (*pi++, seq_cst);\n+}\n+\n+/* The following tests fail because std::atomic_compare_exchange_weak_explicit\n+   is not declared with attribute always_inline (like the member functions\n+   above are).  */\n+\n+void test_compare_exchange (int *pi, int *pj)\n+{\n+#define cmpxchg(x, y, z, o1, o2) \\\n+  std::atomic_compare_exchange_weak_explicit (x, y, z, o1, o2)\n+\n+  cmpxchg (&eai, pi++, *pj++, relaxed, relaxed);\n+  cmpxchg (&eai, pi++, *pj++, relaxed, consume);  // warning\n+  cmpxchg (&eai, pi++, *pj++, relaxed, acquire);  // warning\n+  cmpxchg (&eai, pi++, *pj++, relaxed, release);  // warning\n+  cmpxchg (&eai, pi++, *pj++, relaxed, acq_rel);  // warning\n+  cmpxchg (&eai, pi++, *pj++, relaxed, seq_cst);  // warning\n+  cmpxchg (&eai, pi++, *pj++, relaxed, relaxed);\n+\n+  /* HACK: xfail doesn't seem to work for the dg-regexp directives below,\n+     so disable them by prepending an X to their names...\n+    { Xdg-regexp \" *inlined from \\[^\\n\\r\\]+.C:66:.*\" \"\" { xfail *-*-* } 0 }\n+    { Xdg-regexp \" *inlined from \\[^\\n\\r\\]+.C:67:.*\" \"\" { xfail *-*-* } 0 }\n+    { Xdg-regexp \" *inlined from \\[^\\n\\r\\]+.C:68:.*\" \"\" { xfail *-*-* } 0 }\n+    { Xdg-regexp \" *inlined from \\[^\\n\\r\\]+.C:69:.*\" \"\" { xfail *-*-* } 0 }\n+    { Xdg-regexp \" *inlined from \\[^\\n\\r\\]+.C:70:.*\" \"\" { xfail *-*-* } 0 }\n+    { dg-warning \"__atomic_compare_exchange\\[^\\n\\r\\]* \\\\\\[-Winvalid-memory-model\" \"cmpxchg 1\" { xfail *-*-* } 0 } */\n+}"}, {"sha": "220432c34d318f5cc7cc031e8f61b826aaad8b52", "filename": "gcc/testsuite/gcc.dg/atomic-invalid-2.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a431b60d1f221992e5e9f7a5c032df3b5fa35a5/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-invalid-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a431b60d1f221992e5e9f7a5c032df3b5fa35a5/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-invalid-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-invalid-2.c?ref=5a431b60d1f221992e5e9f7a5c032df3b5fa35a5", "patch": "@@ -38,13 +38,13 @@ exchange (atomic_int *i)\n {\n   int r;\n \n-  atomic_compare_exchange_strong_explicit (i, &r, 0, memory_order_seq_cst, memory_order_release); /* { dg-warning \"invalid failure memory\" } */\n-  atomic_compare_exchange_strong_explicit (i, &r, 0, memory_order_seq_cst, memory_order_acq_rel); /* { dg-warning \"invalid failure memory\" } */\n-  atomic_compare_exchange_strong_explicit (i, &r, 0, memory_order_relaxed, memory_order_consume); /* { dg-warning \"failure memory model cannot be stronger\" } */\n+  atomic_compare_exchange_strong_explicit (i, &r, 0, memory_order_seq_cst, memory_order_release); /* { dg-warning \"invalid failure memory model 'memory_order_release'\" } */\n+  atomic_compare_exchange_strong_explicit (i, &r, 0, memory_order_seq_cst, memory_order_acq_rel); /* { dg-warning \"invalid failure memory model 'memory_order_acq_rel'\" } */\n+  atomic_compare_exchange_strong_explicit (i, &r, 0, memory_order_relaxed, memory_order_consume); /* { dg-warning \"failure memory model 'memory_order_consume' cannot be stronger than success memory model 'memory_order_relaxed'\" } */\n \n-  atomic_compare_exchange_weak_explicit (i, &r, 0, memory_order_seq_cst, memory_order_release); /* { dg-warning \"invalid failure memory\" } */\n-  atomic_compare_exchange_weak_explicit (i, &r, 0, memory_order_seq_cst, memory_order_acq_rel); /* { dg-warning \"invalid failure memory\" } */\n-  atomic_compare_exchange_weak_explicit (i, &r, 0, memory_order_relaxed, memory_order_consume); /* { dg-warning \"failure memory model cannot be stronger\" } */\n+  atomic_compare_exchange_weak_explicit (i, &r, 0, memory_order_seq_cst, memory_order_release); /* { dg-warning \"invalid failure memory model 'memory_order_release'\" } */\n+  atomic_compare_exchange_weak_explicit (i, &r, 0, memory_order_seq_cst, memory_order_acq_rel); /* { dg-warning \"invalid failure memory model 'memory_order_acq_rel'\" } */\n+  atomic_compare_exchange_weak_explicit (i, &r, 0, memory_order_relaxed, memory_order_consume); /* { dg-warning \"failure memory model 'memory_order_consume' cannot be stronger than success memory model 'memory_order_relaxed'\" } */\n }\n \n /* atomic_flag_clear():"}, {"sha": "26da5b725e3e923f4e11cf0e488dd4337e1f97ad", "filename": "gcc/testsuite/gcc.dg/atomic-invalid.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a431b60d1f221992e5e9f7a5c032df3b5fa35a5/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-invalid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a431b60d1f221992e5e9f7a5c032df3b5fa35a5/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-invalid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-invalid.c?ref=5a431b60d1f221992e5e9f7a5c032df3b5fa35a5", "patch": "@@ -13,7 +13,7 @@ bool x;\n int\n main ()\n {\n-  __atomic_compare_exchange_n (&i, &e, 1, 0, __ATOMIC_RELAXED, __ATOMIC_SEQ_CST); /* { dg-warning \"failure memory model cannot be stronger\" } */\n+  __atomic_compare_exchange_n (&i, &e, 1, 0, __ATOMIC_RELAXED, __ATOMIC_SEQ_CST); /* { dg-warning \"failure memory model 'memory_order_seq_cst' cannot be stronger\" } */\n   __atomic_compare_exchange_n (&i, &e, 1, 0, __ATOMIC_SEQ_CST, __ATOMIC_RELEASE); /* { dg-warning \"invalid failure memory\" } */\n   __atomic_compare_exchange_n (&i, &e, 1, 1, __ATOMIC_SEQ_CST, __ATOMIC_ACQ_REL); /* { dg-warning \"invalid failure memory\" } */\n "}]}