{"sha": "2ecf4eca922c12a93918f2c4b7c3b3b962d63e98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVjZjRlY2E5MjJjMTJhOTM5MThmMmM0YjdjM2IzYjk2MmQ2M2U5OA==", "commit": {"author": {"name": "Aditya Kumar", "email": "aditya.k7@samsung.com", "date": "2015-11-18T21:08:33Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2015-11-18T21:08:33Z"}, "message": "Move codegen related functions to graphite-isl-ast-to-gimple.c\n\nNo functional changes intended.\nThis patch passes regtest and bootstrap on linux-x86-64 with\nBOOT_CFLAGS='-O2 -fgraphite-identity -floop-nest-optimize'\n\ngcc/ChangeLog:\n\n2015-11-14  hiraditya  <hiraditya@msn.com>\n\n\t* graphite-isl-ast-to-gimple.c (struct ast_build_info): Remove semicolon.\n\t(class translate_isl_ast_to_gimple): Indentation.\n        (translate_pending_phi_nodes): Comment.\n        (add_parameters_to_ivs_params): Moved from sese.c inside class translate_isl_ast_to_gimple.\n        (get_max_schedule_dimensions): Same.\n        (generate_isl_context): Same.\n        (extend_schedule): Same.\n        (generate_isl_schedule): Same.\n        (set_options): Same.\n        (scop_to_isl_ast): Same.\n        (is_valid_rename): Same.\n        (get_rename): Same.\n        (get_rename_from_scev): Same.\n        (get_def_bb_for_const): Same.\n        (get_new_name): Same.\n        (collect_all_ssa_names): Same.\n        (copy_loop_phi_args): Same.\n        (copy_loop_phi_nodes): Same.\n        (copy_loop_close_phi_args): Same.\n        (copy_loop_close_phi_nodes): Same.\n        (copy_cond_phi_args): Same.\n        (copy_cond_phi_nodes): Same.\n        (graphite_copy_stmts_from_block): Same.\n        (copy_bb_and_scalar_dependences): Same.\n        (add_phi_arg_for_new_expr): Same.\n        (rename_uses): Same.\n        (set_rename): Same.\n        (set_rename_for_each_def): Same.\n        (gsi_insert_earliest): Same.\n        (rename_all_uses): Same.\n        (codegen_error_p): Same.\n        (print_isl_ast_node): Same.\n\t(translate_isl_ast_for_loop): Call function codegen_error_p.\n\t(translate_isl_ast_to_gimple::translate_isl_ast): Same.\n        (translate_isl_ast_node_user): Make nb_loops const and release iv_map before exit.\n\t(get_true_edge_from_guard_bb): Move all free-functions early.\n\t(get_false_edge_from_guard_bb): Same.\n\t(bb_contains_loop_close_phi_nodes): Same.\n\t(bb_contains_loop_phi_nodes): Same.\n\t(is_loop_closed_ssa_use):  Same.\n\t(number_of_phi_nodes): Same.\n\t(phi_uses_name): Same.\n\t(later_of_the_two): Same.\n\t(substitute_ssa_name):\n\t(get_edges): Same.\n\t(get_loc): Same.\n\t(get_loop_init_value): Same.\n\t(find_init_value): Same.\n\t(find_init_value_close_phi): Same.\n\t(ast_build_before_for): Same.\n\t(graphite_regenerate_ast_isl): Formatting changes.\n\t* graphite-scop-detection.c (build_cross_bb_scalars_use): Same.\n\t* sese.c (get_rename): Move to graphite-isl-ast-to-gimple.c\n\t(set_rename): Same.\n\t(gsi_insert_earliest): Same.\n\t(collect_all_ssa_names): Same.\n\t(rename_all_uses): Same.\n\t(rename_uses): Same.\n\t(get_def_bb_for_const): Same.\n\t(copy_loop_phi_nodes): Same.\n\t(copy_loop_close_phi_args): Same.\n\t(copy_loop_close_phi_nodes): Same.\n\t(copy_cond_phi_args): Same.\n\t(copy_cond_phi_nodes): Same.\n\t(set_rename_for_each_def): Same.\n\t(graphite_copy_stmts_from_block): Same.\n\t(copy_bb_and_scalar_dependences): Same.\n\t(if_region_set_false_region): Same.\n\t(scev_analyzable_p): Same.\n\t* sese.h: Delete extern functions moved to graphite-isl-ast-to-gimple.c\n\nFrom-SVN: r230566", "tree": {"sha": "63b5b8bc4e8aefb6393afd67b19ea1a78dd450bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63b5b8bc4e8aefb6393afd67b19ea1a78dd450bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ecf4eca922c12a93918f2c4b7c3b3b962d63e98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ecf4eca922c12a93918f2c4b7c3b3b962d63e98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ecf4eca922c12a93918f2c4b7c3b3b962d63e98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ecf4eca922c12a93918f2c4b7c3b3b962d63e98/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "159e0d3b269d3cf48375b3984c6d10d806d4fa70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/159e0d3b269d3cf48375b3984c6d10d806d4fa70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/159e0d3b269d3cf48375b3984c6d10d806d4fa70"}], "stats": {"total": 3931, "additions": 2113, "deletions": 1818}, "files": [{"sha": "521c3aebe389400c7efb2ca41f54b8ba0fe1bc76", "filename": "gcc/ChangeLog", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ecf4eca922c12a93918f2c4b7c3b3b962d63e98/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ecf4eca922c12a93918f2c4b7c3b3b962d63e98/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ecf4eca922c12a93918f2c4b7c3b3b962d63e98", "patch": "@@ -1,3 +1,78 @@\n+2015-11-18  Aditya Kumar  <aditya.k7@samsung.com>\n+\n+\t* graphite-isl-ast-to-gimple.c (struct ast_build_info): Remove semicolon.\n+\t(class translate_isl_ast_to_gimple): Indentation.\n+\t(translate_pending_phi_nodes): Comment.\n+\t(add_parameters_to_ivs_params): Moved from sese.c inside class\n+\ttranslate_isl_ast_to_gimple.\n+\t(get_max_schedule_dimensions): Same.\n+\t(generate_isl_context): Same.\n+\t(extend_schedule): Same.\n+\t(generate_isl_schedule): Same.\n+\t(set_options): Same.\n+\t(scop_to_isl_ast): Same.\n+\t(is_valid_rename): Same.\n+\t(get_rename): Same.\n+\t(get_rename_from_scev): Same.\n+\t(get_def_bb_for_const): Same.\n+\t(get_new_name): Same.\n+\t(collect_all_ssa_names): Same.\n+\t(copy_loop_phi_args): Same.\n+\t(copy_loop_phi_nodes): Same.\n+\t(copy_loop_close_phi_args): Same.\n+\t(copy_loop_close_phi_nodes): Same.\n+\t(copy_cond_phi_args): Same.\n+\t(copy_cond_phi_nodes): Same.\n+\t(graphite_copy_stmts_from_block): Same.\n+\t(copy_bb_and_scalar_dependences): Same.\n+\t(add_phi_arg_for_new_expr): Same.\n+\t(rename_uses): Same.\n+\t(set_rename): Same.\n+\t(set_rename_for_each_def): Same.\n+\t(gsi_insert_earliest): Same.\n+\t(rename_all_uses): Same.\n+\t(codegen_error_p): Same.\n+\t(print_isl_ast_node): Same.\n+\t(translate_isl_ast_for_loop): Call function codegen_error_p.\n+\t(translate_isl_ast_to_gimple::translate_isl_ast): Same.\n+\t(translate_isl_ast_node_user): Make nb_loops const and release\n+\tiv_map before exit.\n+\t(get_true_edge_from_guard_bb): Move all free-functions early.\n+\t(get_false_edge_from_guard_bb): Same.\n+\t(bb_contains_loop_close_phi_nodes): Same.\n+\t(bb_contains_loop_phi_nodes): Same.\n+\t(is_loop_closed_ssa_use):  Same.\n+\t(number_of_phi_nodes): Same.\n+\t(phi_uses_name): Same.\n+\t(later_of_the_two): Same.\n+\t(substitute_ssa_name):\n+\t(get_edges): Same.\n+\t(get_loc): Same.\n+\t(get_loop_init_value): Same.\n+\t(find_init_value): Same.\n+\t(find_init_value_close_phi): Same.\n+\t(ast_build_before_for): Same.\n+\t(graphite_regenerate_ast_isl): Formatting changes.\n+\t* graphite-scop-detection.c (build_cross_bb_scalars_use): Same.\n+\t* sese.c (get_rename): Move to graphite-isl-ast-to-gimple.c\n+\t(set_rename): Same.\n+\t(gsi_insert_earliest): Same.\n+\t(collect_all_ssa_names): Same.\n+\t(rename_all_uses): Same.\n+\t(rename_uses): Same.\n+\t(get_def_bb_for_const): Same.\n+\t(copy_loop_phi_nodes): Same.\n+\t(copy_loop_close_phi_args): Same.\n+\t(copy_loop_close_phi_nodes): Same.\n+\t(copy_cond_phi_args): Same.\n+\t(copy_cond_phi_nodes): Same.\n+\t(set_rename_for_each_def): Same.\n+\t(graphite_copy_stmts_from_block): Same.\n+\t(copy_bb_and_scalar_dependences): Same.\n+\t(if_region_set_false_region): Same.\n+\t(scev_analyzable_p): Same.\n+\t* sese.h: Delete extern functions moved to graphite-isl-ast-to-gimple.c.\n+\n 2015-11-18  Andreas Tobler  <andreast@gcc.gnu.org>\n \n \t* config/i386/freebsd.h (ASM_OUTPUT_MAX_SKIP_ALIGN): Bring in the"}, {"sha": "b9e0a4e417bf972c479cac516ac21edfd956b4de", "filename": "gcc/graphite-isl-ast-to-gimple.c", "status": "modified", "additions": 2001, "deletions": 232, "changes": 2233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ecf4eca922c12a93918f2c4b7c3b3b962d63e98/gcc%2Fgraphite-isl-ast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ecf4eca922c12a93918f2c4b7c3b3b962d63e98/gcc%2Fgraphite-isl-ast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-isl-ast-to-gimple.c?ref=2ecf4eca922c12a93918f2c4b7c3b3b962d63e98", "patch": "@@ -48,8 +48,14 @@ extern \"C\" {\n #include \"gimple.h\"\n #include \"params.h\"\n #include \"fold-const.h\"\n+#include \"gimple-fold.h\"\n #include \"gimple-iterator.h\"\n+#include \"gimplify.h\"\n+#include \"gimplify-me.h\"\n+#include \"tree-eh.h\"\n #include \"tree-ssa-loop.h\"\n+#include \"tree-ssa-operands.h\"\n+#include \"tree-ssa-propagate.h\"\n #include \"tree-pass.h\"\n #include \"cfgloop.h\"\n #include \"tree-data-ref.h\"\n@@ -60,10 +66,13 @@ extern \"C\" {\n #include \"tree-phinodes.h\"\n #include \"tree-into-ssa.h\"\n #include \"ssa-iterators.h\"\n-#include <map>\n #include \"graphite-isl-ast-to-gimple.h\"\n #include \"tree-cfg.h\"\n #include \"gimple-pretty-print.h\"\n+#include \"cfganal.h\"\n+#include \"value-prof.h\"\n+\n+#include <map>\n \n /* We always try to use signed 128 bit types, but fall back to smaller types\n    in case a platform does not provide types of these sizes. In the future we\n@@ -78,7 +87,7 @@ struct ast_build_info\n {\n   ast_build_info()\n     : is_parallelizable(false)\n-  { };\n+  { }\n   bool is_parallelizable;\n };\n \n@@ -129,7 +138,7 @@ class translate_isl_ast_to_gimple\n  public:\n   translate_isl_ast_to_gimple (sese_info_p r)\n     : region (r), codegen_error (false)\n-  { }\n+    { }\n \n   /* Translates an ISL AST node NODE to GCC representation in the\n      context of a SESE.  */\n@@ -258,9 +267,193 @@ class translate_isl_ast_to_gimple\n \t\t\t __isl_keep isl_ast_expr *user_expr, ivs_params &ip,\n \t\t\t sese_l &region);\n \n+  /* Patch the missing arguments of the phi nodes.  */\n+\n   void translate_pending_phi_nodes (void);\n \n-  bool codegen_error_p () { return codegen_error; }\n+  /* Add ISL's parameter identifiers and corresponding trees to ivs_params.  */\n+\n+  void add_parameters_to_ivs_params (scop_p scop, ivs_params &ip);\n+\n+  /* Get the maximal number of schedule dimensions in the scop SCOP.  */\n+\n+  int get_max_schedule_dimensions (scop_p scop);\n+\n+  /* Generates a build, which specifies the constraints on the parameters.  */\n+\n+  __isl_give isl_ast_build *generate_isl_context (scop_p scop);\n+\n+  /* Extend the schedule to NB_SCHEDULE_DIMS schedule dimensions.\n+\n+     For schedules with different dimensionality, the isl AST generator can not\n+     define an order and will just randomly choose an order.  The solution to\n+     this problem is to extend all schedules to the maximal number of schedule\n+     dimensions (using '0's for the remaining values).  */\n+\n+  __isl_give isl_map *extend_schedule (__isl_take isl_map *schedule,\n+\t\t\t\t       int nb_schedule_dims);\n+\n+  /* Generates a schedule, which specifies an order used to\n+     visit elements in a domain.  */\n+\n+  __isl_give isl_union_map *generate_isl_schedule (scop_p scop);\n+\n+  /* Set the separate option for all dimensions.\n+     This helps to reduce control overhead.  */\n+\n+  __isl_give isl_ast_build * set_options (__isl_take isl_ast_build *control,\n+\t\t\t\t\t  __isl_keep isl_union_map *schedule);\n+\n+  /* Generate isl AST from schedule of SCOP.  Also, collects IVS_PARAMS in\n+     IP.  */\n+\n+  __isl_give isl_ast_node * scop_to_isl_ast (scop_p scop, ivs_params &ip);\n+\n+\n+  /* Return true if RENAME (defined in BB) is a valid use in NEW_BB.  The\n+     definition should flow into use, and the use should respect the loop-closed\n+     SSA form.  */\n+\n+  bool is_valid_rename (tree rename, basic_block def_bb, basic_block use_bb,\n+\t\t\tbool loop_phi, tree old_name, basic_block old_bb) const;\n+\n+  /* Returns the expression associated to OLD_NAME (which is used in OLD_BB), in\n+     NEW_BB from RENAME_MAP.  LOOP_PHI is true when we want to rename OLD_NAME\n+     within a loop PHI instruction.  */\n+\n+  tree get_rename (basic_block new_bb, tree old_name,\n+\t\t   basic_block old_bb, bool loop_phi) const;\n+\n+  /* For ops which are scev_analyzeable, we can regenerate a new name from\n+  its scalar evolution around LOOP.  */\n+\n+  tree get_rename_from_scev (tree old_name, gimple_seq *stmts, loop_p loop,\n+\t\t\t     basic_block new_bb, basic_block old_bb,\n+\t\t\t     vec<tree> iv_map);\n+\n+  /* Returns a basic block that could correspond to where a constant was defined\n+     in the original code.  In the original code OLD_BB had the definition, we\n+     need to find which basic block out of the copies of old_bb, in the new\n+     region, should a definition correspond to if it has to reach BB.  */\n+\n+  basic_block get_def_bb_for_const (basic_block bb, basic_block old_bb) const;\n+\n+  /* Get the new name of OP (from OLD_BB) to be used in NEW_BB.  LOOP_PHI is\n+     true when we want to rename an OP within a loop PHI instruction.  */\n+\n+  tree get_new_name (basic_block new_bb, tree op,\n+\t\t     basic_block old_bb, bool loop_phi) const;\n+\n+  /* Collect all the operands of NEW_EXPR by recursively visiting each\n+     operand.  */\n+\n+  void collect_all_ssa_names (tree new_expr, vec<tree> *vec_ssa);\n+\n+  /* Copy the PHI arguments from OLD_PHI to the NEW_PHI.  The arguments to\n+     NEW_PHI must be found unless they can be POSTPONEd for later.  */\n+\n+  void copy_loop_phi_args (gphi *old_phi, init_back_edge_pair_t &ibp_old_bb,\n+\t\t\t   gphi *new_phi, init_back_edge_pair_t &ibp_new_bb,\n+\t\t\t   bool postpone);\n+\n+  /* Copy loop phi nodes from BB to NEW_BB.  */\n+\n+  bool copy_loop_phi_nodes (basic_block bb, basic_block new_bb);\n+\n+  /* Copy all the loop-close phi args from BB to NEW_BB.  */\n+\n+  bool copy_loop_close_phi_args (basic_block old_bb, basic_block new_bb,\n+\t\t\t\t bool postpone);\n+\n+  /* Copy loop close phi nodes from BB to NEW_BB.  */\n+\n+  bool copy_loop_close_phi_nodes (basic_block old_bb, basic_block new_bb);\n+\n+  /* Copy the arguments of cond-phi node PHI, to NEW_PHI in the codegenerated\n+     region.  If postpone is true and it isn't possible to copy any arg of PHI,\n+     the PHI is added to the REGION->INCOMPLETE_PHIS to be codegenerated later.\n+     Returns false if the copying was unsuccessful.  */\n+\n+  bool copy_cond_phi_args (gphi *phi, gphi *new_phi, vec<tree> iv_map,\n+\t\t\t   bool postpone);\n+\n+  /* Copy cond phi nodes from BB to NEW_BB.  A cond-phi node is a basic block\n+  containing phi nodes coming from two predecessors, and none of them are back\n+  edges.  */\n+\n+  bool copy_cond_phi_nodes (basic_block bb, basic_block new_bb,\n+\t\t\t    vec<tree> iv_map);\n+\n+  /* Duplicates the statements of basic block BB into basic block NEW_BB\n+     and compute the new induction variables according to the IV_MAP.\n+     CODEGEN_ERROR is set when the code generation cannot continue.  */\n+\n+  bool graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb,\n+\t\t\t\t       vec<tree> iv_map);\n+\n+  /* Copies BB and includes in the copied BB all the statements that can\n+     be reached following the use-def chains from the memory accesses,\n+     and returns the next edge following this new block.  codegen_error is\n+     set when the code generation cannot continue.  */\n+\n+  edge copy_bb_and_scalar_dependences (basic_block bb, edge next_e,\n+\t\t\t\t       vec<tree> iv_map);\n+\n+  /* Add NEW_NAME as the ARGNUM-th arg of NEW_PHI which is in NEW_BB.\n+     DOMINATING_PRED is the predecessor basic block of OLD_BB which dominates\n+     the other pred of OLD_BB as well.  If no such basic block exists then it is\n+     NULL.  NON_DOMINATING_PRED is a pred which does not dominate OLD_BB, it\n+     cannot be NULL.\n+\n+     Case1: OLD_BB->preds {BB1, BB2} and BB1 does not dominate BB2 and vice\n+     versa.  In this case DOMINATING_PRED = NULL.\n+\n+     Case2: OLD_BB->preds {BB1, BB2} and BB1 dominates BB2.\n+\n+     Returns true on successful copy of the args, false otherwise.  */\n+\n+  bool add_phi_arg_for_new_expr (tree old_phi_args[2], tree new_phi_args[2],\n+\t\t\t\t edge old_bb_dominating_edge,\n+\t\t\t\t edge old_bb_non_dominating_edge,\n+\t\t\t\t gphi *phi, gphi *new_phi,\n+\t\t\t\t basic_block new_bb);\n+\n+  /* Renames the scalar uses of the statement COPY, using the substitution map\n+     RENAME_MAP, inserting the gimplification code at GSI_TGT, for the\n+     translation REGION, with the original copied statement in LOOP, and using\n+     the induction variable renaming map IV_MAP.  Returns true when something\n+     has been renamed.  codegen_error is set when the code generation cannot\n+     continue.  */\n+\n+  bool rename_uses (gimple *copy, gimple_stmt_iterator *gsi_tgt,\n+\t\t    basic_block old_bb, loop_p loop, vec<tree> iv_map);\n+\n+  /* Register in RENAME_MAP the rename tuple (OLD_NAME, EXPR).\n+     When OLD_NAME and EXPR are the same we assert.  */\n+\n+  void set_rename (tree old_name, tree expr);\n+\n+  /* Create new names for all the definitions created by COPY and add\n+     replacement mappings for each new name.  */\n+\n+  void set_rename_for_each_def (gimple *stmt);\n+\n+  /* Insert each statement from SEQ at its earliest insertion p.  */\n+\n+  void gsi_insert_earliest (gimple_seq seq);\n+\n+  /* Rename all the operands of NEW_EXPR by recursively visiting each\n+     operand.  */\n+\n+  tree rename_all_uses (tree new_expr, basic_block new_bb, basic_block old_bb);\n+\n+  bool codegen_error_p () const\n+  { return codegen_error; }\n+\n+  /* Prints NODE to FILE.  */\n+\n+  void print_isl_ast_node (FILE *file, __isl_keep isl_ast_node *node,\n+\t\t\t   __isl_keep isl_ctx *ctx) const;\n \n private:\n   sese_info_p region;\n@@ -586,21 +779,21 @@ translate_isl_ast_for_loop (loop_p context_loop,\n   isl_ast_node_free (for_body);\n \n   /* Early return if we failed to translate loop body.  */\n-  if (!next_e || codegen_error)\n+  if (!next_e || codegen_error_p ())\n     return NULL;\n \n   redirect_edge_succ_nodup (next_e, after);\n   set_immediate_dominator (CDI_DOMINATORS, next_e->dest, next_e->src);\n \n   if (flag_loop_parallelize_all)\n-  {\n-    isl_id *id = isl_ast_node_get_annotation (node_for);\n-    gcc_assert (id);\n-    ast_build_info *for_info = (ast_build_info *) isl_id_get_user (id);\n-    loop->can_be_parallel = for_info->is_parallelizable;\n-    free (for_info);\n-    isl_id_free (id);\n-  }\n+    {\n+      isl_id *id = isl_ast_node_get_annotation (node_for);\n+      gcc_assert (id);\n+      ast_build_info *for_info = (ast_build_info *) isl_id_get_user (id);\n+      loop->can_be_parallel = for_info->is_parallelizable;\n+      free (for_info);\n+      isl_id_free (id);\n+    }\n \n   return last_e;\n }\n@@ -612,7 +805,7 @@ translate_isl_ast_for_loop (loop_p context_loop,\n \n    {\n \n-     ...\n+   ...\n \n    }\n \n@@ -646,7 +839,7 @@ get_upper_bound (__isl_keep isl_ast_node *node_for)\n \n     case isl_ast_op_lt:\n       {\n-        // (iterator < ub) => (iterator <= ub - 1)\n+\t/* (iterator < ub) => (iterator <= ub - 1).  */\n         isl_val *one =\n           isl_val_int_from_si (isl_ast_expr_get_ctx (for_cond), 1);\n         isl_ast_expr *ub = isl_ast_expr_get_op_arg (for_cond, 1);\n@@ -794,7 +987,7 @@ translate_isl_ast_node_user (__isl_keep isl_ast_node *node,\n   gcc_assert (GBB_BB (gbb) != ENTRY_BLOCK_PTR_FOR_FN (cfun) &&\n \t      \"The entry block should not even appear within a scop\");\n \n-  int nb_loops = number_of_loops (cfun);\n+  const int nb_loops = number_of_loops (cfun);\n   vec<tree> iv_map;\n   iv_map.create (nb_loops);\n   iv_map.safe_grow_cleared (nb_loops);\n@@ -810,11 +1003,12 @@ translate_isl_ast_node_user (__isl_keep isl_ast_node *node,\n       print_loops_bb (dump_file, next_e->src, 0, 3);\n     }\n \n-  next_e = copy_bb_and_scalar_dependences (GBB_BB (gbb),\n-\t\t\t\t\t   pbb->scop->scop_info, next_e,\n-\t\t\t\t\t   iv_map,\n-\t\t\t\t\t   &codegen_error);\n-  if (codegen_error)\n+  next_e = copy_bb_and_scalar_dependences (GBB_BB (gbb), next_e,\n+\t\t\t\t\t   iv_map);\n+\n+  iv_map.release ();\n+\n+  if (codegen_error_p ())\n     return NULL;\n \n   if (dump_file)\n@@ -823,7 +1017,6 @@ translate_isl_ast_node_user (__isl_keep isl_ast_node *node,\n       print_loops_bb (dump_file, next_e->src, 0, 3);\n     }\n \n-  iv_map.release ();\n   mark_virtual_operands_for_renaming (cfun);\n   update_ssa (TODO_update_ssa);\n \n@@ -904,7 +1097,7 @@ translate_isl_ast_to_gimple::translate_isl_ast (loop_p context_loop,\n \t\t\t\t\t\t__isl_keep isl_ast_node *node,\n \t\t\t\t\t\tedge next_e, ivs_params &ip)\n {\n-  if (codegen_error)\n+  if (codegen_error_p ())\n     return NULL;\n \n   switch (isl_ast_node_get_type (node))\n@@ -932,272 +1125,1847 @@ translate_isl_ast_to_gimple::translate_isl_ast (loop_p context_loop,\n     }\n }\n \n-/* Patch the missing arguments of the phi nodes.  */\n+/* Returns the first successor edge of BB with EDGE_TRUE_VALUE flag set.  */\n \n-void\n-translate_isl_ast_to_gimple::translate_pending_phi_nodes ()\n+edge\n+get_true_edge_from_guard_bb (basic_block bb)\n {\n-  int i;\n-  phi_rename *rename;\n-  FOR_EACH_VEC_ELT (region->incomplete_phis, i, rename)\n-    {\n-      gphi *old_phi = rename->first;\n-      gphi *new_phi = rename->second;\n-      basic_block old_bb = gimple_bb (old_phi);\n-      basic_block new_bb = gimple_bb (new_phi);\n-\n-      /* First edge is the init edge and second is the back edge.  */\n-      init_back_edge_pair_t ibp_old_bb = get_edges (old_bb);\n-      init_back_edge_pair_t ibp_new_bb = get_edges (new_bb);\n-\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"\\n[codegen] translating pending old-phi: \");\n-\t  print_gimple_stmt (dump_file, old_phi, 0, 0);\n-\t}\n+  edge e;\n+  edge_iterator ei;\n \n-      auto_vec <tree, 1> iv_map;\n-      if (bb_contains_loop_phi_nodes (new_bb))\n-\tcopy_loop_phi_args (old_phi, ibp_old_bb, new_phi,\n-\t\t\t    ibp_new_bb, region, false);\n-      else if (bb_contains_loop_close_phi_nodes (new_bb))\n-\tcopy_loop_close_phi_args (old_bb, new_bb, region, false);\n-      else if (!copy_cond_phi_args (old_phi, new_phi, iv_map, region, false))\n-\tgcc_unreachable ();\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    if (e->flags & EDGE_TRUE_VALUE)\n+      return e;\n \n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"[codegen] to new-phi: \");\n-\t  print_gimple_stmt (dump_file, new_phi, 0, 0);\n-\t}\n-    }\n+  gcc_unreachable ();\n+  return NULL;\n }\n \n-/* Prints NODE to FILE.  */\n+/* Returns the first successor edge of BB with EDGE_TRUE_VALUE flag cleared.  */\n \n-void\n-print_isl_ast_node (FILE *file, __isl_keep isl_ast_node *node, \n-\t\t    __isl_keep isl_ctx *ctx)\n+edge\n+get_false_edge_from_guard_bb (basic_block bb)\n {\n-  isl_printer *prn = isl_printer_to_file (ctx, file);\n-  prn = isl_printer_set_output_format (prn, ISL_FORMAT_C);\n-  prn = isl_printer_print_ast_node (prn, node);\n-  prn = isl_printer_print_str (prn, \"\\n\");\n-  isl_printer_free (prn);\n-}\n+  edge e;\n+  edge_iterator ei;\n \n-/* Add ISL's parameter identifiers and corresponding.trees to ivs_params  */\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    if (!(e->flags & EDGE_TRUE_VALUE))\n+      return e;\n \n-static void\n-add_parameters_to_ivs_params (scop_p scop, ivs_params &ip)\n-{\n-  sese_info_p region = scop->scop_info;\n-  unsigned nb_parameters = isl_set_dim (scop->param_context, isl_dim_param);\n-  gcc_assert (nb_parameters == region->params.length ());\n-  unsigned i;\n-  for (i = 0; i < nb_parameters; i++)\n-    {\n-      isl_id *tmp_id = isl_set_get_dim_id (scop->param_context,\n-                                           isl_dim_param, i);\n-      ip[tmp_id] = region->params[i];\n-    }\n+  gcc_unreachable ();\n+  return NULL;\n }\n \n+/* Return true when BB contains loop close phi nodes.  A loop close phi node is\n+   at the exit of loop which takes one argument that is the last value of the\n+   variable being used out of the loop.  */\n \n-/* Generates a build, which specifies the constraints on the parameters.  */\n-\n-static __isl_give isl_ast_build *\n-generate_isl_context (scop_p scop)\n+bool\n+bb_contains_loop_close_phi_nodes (basic_block bb)\n {\n-  isl_set *context_isl = isl_set_params (isl_set_copy (scop->param_context));\n-  return isl_ast_build_from_context (context_isl);\n+  return single_pred_p (bb)\n+    && bb->loop_father != single_pred_edge (bb)->src->loop_father;\n }\n \n-/* Get the maximal number of schedule dimensions in the scop SCOP.  */\n+/* Return true when BB contains loop phi nodes.  A loop phi node is the loop\n+   header containing phi nodes which has one init-edge and one back-edge.  */\n \n-static\n-int get_max_schedule_dimensions (scop_p scop)\n+bool\n+bb_contains_loop_phi_nodes (basic_block bb)\n {\n-  int i;\n-  poly_bb_p pbb;\n-  int schedule_dims = 0;\n+  gcc_assert (EDGE_COUNT (bb->preds) <= 2);\n \n-  FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)\n-    {\n-      int pbb_schedule_dims = isl_map_dim (pbb->transformed, isl_dim_out);\n-      if (pbb_schedule_dims > schedule_dims)\n-\tschedule_dims = pbb_schedule_dims;\n-    }\n+  if (bb->preds->length () == 1)\n+    return false;\n \n-  return schedule_dims;\n-}\n+  unsigned depth = loop_depth (bb->loop_father);\n \n-/* Extend the schedule to NB_SCHEDULE_DIMS schedule dimensions.\n+  edge preds[2] = { (*bb->preds)[0], (*bb->preds)[1] };\n \n-   For schedules with different dimensionality, the isl AST generator can not\n-   define an order and will just randomly choose an order. The solution to this\n-   problem is to extend all schedules to the maximal number of schedule\n-   dimensions (using '0's for the remaining values).  */\n+  if (depth > loop_depth (preds[0]->src->loop_father)\n+      || depth > loop_depth (preds[1]->src->loop_father))\n+    return true;\n \n-static __isl_give isl_map *\n-extend_schedule (__isl_take isl_map *schedule, int nb_schedule_dims)\n-{\n-  int tmp_dims = isl_map_dim (schedule, isl_dim_out);\n-  schedule =\n-    isl_map_add_dims (schedule, isl_dim_out, nb_schedule_dims - tmp_dims);\n-  isl_val *zero =\n-    isl_val_int_from_si (isl_map_get_ctx (schedule), 0);\n-  int i;\n-  for (i = tmp_dims; i < nb_schedule_dims; i++)\n-    {\n-      schedule =\n-        isl_map_fix_val (schedule, isl_dim_out, i, isl_val_copy (zero));\n-    }\n-  isl_val_free (zero);\n-  return schedule;\n+  /* When one of the edges correspond to the same loop father and other\n+     doesn't.  */\n+  if (bb->loop_father != preds[0]->src->loop_father\n+      && bb->loop_father == preds[1]->src->loop_father)\n+    return true;\n+\n+  if (bb->loop_father != preds[1]->src->loop_father\n+      && bb->loop_father == preds[0]->src->loop_father)\n+    return true;\n+\n+  return false;\n }\n \n-/* Generates a schedule, which specifies an order used to\n-   visit elements in a domain.  */\n+/* Check if USE is defined in a basic block from where the definition of USE can\n+   propagate from all the paths.  FIXME: Verify checks for virtual operands.  */\n \n-static __isl_give isl_union_map *\n-generate_isl_schedule (scop_p scop)\n+static bool\n+is_loop_closed_ssa_use (basic_block bb, tree use)\n {\n-  int nb_schedule_dims = get_max_schedule_dimensions (scop);\n-  int i;\n-  poly_bb_p pbb;\n-  isl_union_map *schedule_isl =\n-    isl_union_map_empty (isl_set_get_space (scop->param_context));\n+  if (TREE_CODE (use) != SSA_NAME || virtual_operand_p (use))\n+    return true;\n \n-  FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)\n-    {\n-      /* Dead code elimination: when the domain of a PBB is empty,\n-\t don't generate code for the PBB.  */\n-      if (isl_set_is_empty (pbb->domain))\n-\tcontinue;\n+  /* For close-phi nodes def always comes from a loop which has a back-edge.  */\n+  if (bb_contains_loop_close_phi_nodes (bb))\n+    return true;\n \n-      isl_map *bb_schedule = isl_map_copy (pbb->transformed);\n-      bb_schedule = isl_map_intersect_domain (bb_schedule,\n-\t\t\t\t\t      isl_set_copy (pbb->domain));\n-      bb_schedule = extend_schedule (bb_schedule, nb_schedule_dims);\n-      schedule_isl =\n-        isl_union_map_union (schedule_isl,\n-\t\t\t     isl_union_map_from_map (bb_schedule));\n-    }\n-  return schedule_isl;\n+  gimple *def = SSA_NAME_DEF_STMT (use);\n+  basic_block def_bb = gimple_bb (def);\n+  return (!def_bb\n+\t  || flow_bb_inside_loop_p (def_bb->loop_father, bb));\n }\n \n-/* This method is executed before the construction of a for node.  */\n-static __isl_give isl_id *\n-ast_build_before_for (__isl_keep isl_ast_build *build, void *user)\n+/* Return the number of phi nodes in BB.  */\n+\n+static int\n+number_of_phi_nodes (basic_block bb)\n {\n-  isl_union_map *dependences = (isl_union_map *) user;\n-  ast_build_info *for_info = XNEW (struct ast_build_info);\n-  isl_union_map *schedule = isl_ast_build_get_schedule (build);\n-  isl_space *schedule_space = isl_ast_build_get_schedule_space (build);\n-  int dimension = isl_space_dim (schedule_space, isl_dim_out);\n-  for_info->is_parallelizable =\n-    !carries_deps (schedule, dependences, dimension);\n-  isl_union_map_free (schedule);\n-  isl_space_free (schedule_space);\n-  isl_id *id = isl_id_alloc (isl_ast_build_get_ctx (build), \"\", for_info);\n-  return id;\n+  int num_phis = 0;\n+  for (gphi_iterator psi = gsi_start_phis (bb); !gsi_end_p (psi);\n+       gsi_next (&psi))\n+    num_phis++;\n+  return num_phis;\n }\n \n-/* Set the separate option for all dimensions.\n-   This helps to reduce control overhead.  */\n+/* Returns true if BB uses name in one of its PHIs.  */\n \n-static __isl_give isl_ast_build *\n-set_options (__isl_take isl_ast_build *control,\n-\t     __isl_keep isl_union_map *schedule)\n+static bool\n+phi_uses_name (basic_block bb, tree name)\n {\n-  isl_ctx *ctx = isl_union_map_get_ctx (schedule);\n-  isl_space *range_space = isl_space_set_alloc (ctx, 0, 1);\n-  range_space =\n-    isl_space_set_tuple_name (range_space, isl_dim_set, \"separate\");\n-  isl_union_set *range =\n-    isl_union_set_from_set (isl_set_universe (range_space));  \n-  isl_union_set *domain = isl_union_map_range (isl_union_map_copy (schedule));\n-  domain = isl_union_set_universe (domain);\n-  isl_union_map *options = isl_union_map_from_domain_and_range (domain, range);\n-  return isl_ast_build_set_options (control, options);\n+  for (gphi_iterator psi = gsi_start_phis (bb); !gsi_end_p (psi);\n+       gsi_next (&psi))\n+    {\n+      gphi *phi = psi.phi ();\n+      for (unsigned i = 0; i < gimple_phi_num_args (phi); i++)\n+\t{\n+\t  tree use_arg = gimple_phi_arg_def (phi, i);\n+\t  if (use_arg == name)\n+\t    return true;\n+\t}\n+    }\n+  return false;\n }\n \n-static __isl_give isl_ast_node *\n-scop_to_isl_ast (scop_p scop, ivs_params &ip)\n+/* Return true if RENAME (defined in BB) is a valid use in NEW_BB.  The\n+   definition should flow into use, and the use should respect the loop-closed\n+   SSA form.  */\n+\n+bool\n+translate_isl_ast_to_gimple::\n+is_valid_rename (tree rename, basic_block def_bb, basic_block use_bb,\n+\t\t bool loop_phi, tree old_name, basic_block old_bb) const\n {\n-  /* Generate loop upper bounds that consist of the current loop iterator,\n-  an operator (< or <=) and an expression not involving the iterator.\n-  If this option is not set, then the current loop iterator may appear several\n-  times in the upper bound. See the isl manual for more details.  */\n-  isl_options_set_ast_build_atomic_upper_bound (scop->isl_context, true);\n+  /* The def of the rename must either dominate the uses or come from a\n+     back-edge.  Also the def must respect the loop closed ssa form.  */\n+  if (!is_loop_closed_ssa_use (use_bb, rename))\n+    {\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"\\n[codegen] rename not in loop closed ssa:\");\n+\t  print_generic_expr (dump_file, rename, 0);\n+\t}\n+      return false;\n+    }\n \n-  add_parameters_to_ivs_params (scop, ip);\n-  isl_union_map *schedule_isl = generate_isl_schedule (scop);\n-  isl_ast_build *context_isl = generate_isl_context (scop);\n-  context_isl = set_options (context_isl, schedule_isl);\n-  isl_union_map *dependences = NULL;\n-  if (flag_loop_parallelize_all)\n-  {\n-    dependences = scop_get_dependences (scop);\n-    context_isl =\n-      isl_ast_build_set_before_each_for (context_isl, ast_build_before_for,\n-\t\t\t\t\t dependences);\n-  }\n-  isl_ast_node *ast_isl = isl_ast_build_ast_from_schedule (context_isl,\n-\t\t\t\t\t\t\t   schedule_isl);\n-  if(dependences)\n-    isl_union_map_free (dependences);\n-  isl_ast_build_free (context_isl);\n-  return ast_isl;\n-}\n+  if (dominated_by_p (CDI_DOMINATORS, use_bb, def_bb))\n+    return true;\n \n-/* GIMPLE Loop Generator: generates loops from STMT in GIMPLE form for\n-   the given SCOP.  Return true if code generation succeeded.\n+  if (bb_contains_loop_phi_nodes (use_bb) && loop_phi)\n+    {\n+      /* The loop-header dominates the loop-body.  */\n+      if (!dominated_by_p (CDI_DOMINATORS, def_bb, use_bb))\n+\treturn false;\n+\n+      /* RENAME would be used in loop-phi.  */\n+      gcc_assert (number_of_phi_nodes (use_bb));\n+\n+      /* For definitions coming from back edges, we should check that\n+\t old_name is used in a loop PHI node.\n+\t FIXME: Verify if this is true.  */\n+      if (phi_uses_name (old_bb, old_name))\n+\treturn true;\n+    }\n+  return false;\n+}\n \n-   FIXME: This is not yet a full implementation of the code generator\n-          with ISL ASTs. Generation of GIMPLE code has to be completed.  */\n+/* Returns the expression associated to OLD_NAME (which is used in OLD_BB), in\n+   NEW_BB from RENAME_MAP.  LOOP_PHI is true when we want to rename OLD_NAME\n+   within a loop PHI instruction.  */\n \n-bool\n-graphite_regenerate_ast_isl (scop_p scop)\n+tree\n+translate_isl_ast_to_gimple::get_rename (basic_block new_bb,\n+\t\t\t\t\t tree old_name,\n+\t\t\t\t\t basic_block old_bb,\n+\t\t\t\t\t bool loop_phi) const\n {\n-  loop_p context_loop;\n-  sese_info_p region = scop->scop_info;\n-  ifsese if_region = NULL;\n-  isl_ast_node *root_node;\n-  ivs_params ip;\n+  gcc_assert (TREE_CODE (old_name) == SSA_NAME);\n+  vec <tree> *renames = region->rename_map->get (old_name);\n \n-  timevar_push (TV_GRAPHITE_CODE_GEN);\n-  root_node = scop_to_isl_ast (scop, ip);\n+  if (!renames || renames->is_empty ())\n+    return NULL_TREE;\n \n-  if (dump_file && (dump_flags & TDF_DETAILS))\n+  if (1 == renames->length ())\n     {\n-      fprintf (dump_file, \"\\nISL AST generated by ISL: \\n\");\n-      print_isl_ast_node (dump_file, root_node, scop->isl_context);\n-      fprintf (dump_file, \"\\n\");\n+      tree rename = (*renames)[0];\n+      basic_block bb = gimple_bb (SSA_NAME_DEF_STMT (rename));\n+      if (is_valid_rename (rename, bb, new_bb, loop_phi, old_name, old_bb))\n+\treturn rename;\n+      return NULL_TREE;\n     }\n \n-  recompute_all_dominators ();\n-  graphite_verify ();\n+  /* More than one renames corresponding to the old_name.  Find the rename for\n+     which the definition flows into usage at new_bb.  */\n+  int i;\n+  tree t1 = NULL_TREE, t2;\n+  basic_block t1_bb = NULL;\n+  FOR_EACH_VEC_ELT (*renames, i, t2)\n+    {\n+      basic_block t2_bb = gimple_bb (SSA_NAME_DEF_STMT (t2));\n \n-  if_region = move_sese_in_condition (region);\n-  region->if_region = if_region;\n-  recompute_all_dominators ();\n+      /* Defined in the same basic block as used.  */\n+      if (t2_bb == new_bb)\n+\treturn t2;\n \n-  context_loop = region->region.entry->src->loop_father;\n+      /* NEW_BB and T2_BB are in two unrelated if-clauses.  */\n+      if (!dominated_by_p (CDI_DOMINATORS, new_bb, t2_bb))\n+\tcontinue;\n+\n+      /* Compute the nearest dominator.  */\n+      if (!t1 || dominated_by_p (CDI_DOMINATORS, t2_bb, t1_bb))\n+\t{\n+\t  t1_bb = t2_bb;\n+\t  t1 = t2;\n+\t}\n+    }\n+\n+  return t1;\n+}\n+\n+/* Register in RENAME_MAP the rename tuple (OLD_NAME, EXPR).\n+   When OLD_NAME and EXPR are the same we assert.  */\n+\n+void\n+translate_isl_ast_to_gimple::set_rename (tree old_name, tree expr)\n+{\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\n[codegen] setting rename: old_name = \");\n+      print_generic_expr (dump_file, old_name, 0);\n+      fprintf (dump_file, \", new_name = \");\n+      print_generic_expr (dump_file, expr, 0);\n+    }\n+\n+  if (old_name == expr)\n+    return;\n+\n+  vec <tree> *renames = region->rename_map->get (old_name);\n+\n+  if (renames)\n+    renames->safe_push (expr);\n+  else\n+    {\n+      vec<tree> r;\n+      r.create (2);\n+      r.safe_push (expr);\n+      region->rename_map->put (old_name, r);\n+    }\n+}\n+\n+/* Return an iterator to the instructions comes last in the execution order.\n+   Either GSI1 and GSI2 should belong to the same basic block or one of their\n+   respective basic blocks should dominate the other.  */\n+\n+gimple_stmt_iterator\n+later_of_the_two (gimple_stmt_iterator gsi1, gimple_stmt_iterator gsi2)\n+{\n+  basic_block bb1 = gsi_bb (gsi1);\n+  basic_block bb2 = gsi_bb (gsi2);\n+\n+  /* Find the iterator which is the latest.  */\n+  if (bb1 == bb2)\n+    {\n+      /* For empty basic blocks gsis point to the end of the sequence.  Since\n+\t there is no operator== defined for gimple_stmt_iterator and for gsis\n+\t not pointing to a valid statement gsi_next would assert.  */\n+      gimple_stmt_iterator gsi = gsi1;\n+      do {\n+\tif (gsi_stmt (gsi) == gsi_stmt (gsi2))\n+\t  return gsi2;\n+\tgsi_next (&gsi);\n+      } while (!gsi_end_p (gsi));\n+\n+      return gsi1;\n+    }\n+\n+  /* Find the basic block closest to the basic block which defines stmt.  */\n+  if (dominated_by_p (CDI_DOMINATORS, bb1, bb2))\n+    return gsi1;\n+\n+  gcc_assert (dominated_by_p (CDI_DOMINATORS, bb2, bb1));\n+  return gsi2;\n+}\n+\n+/* Insert each statement from SEQ at its earliest insertion p.  */\n+\n+void\n+translate_isl_ast_to_gimple::gsi_insert_earliest (gimple_seq seq)\n+{\n+  update_modified_stmts (seq);\n+  sese_l &codegen_region = region->if_region->true_region->region;\n+  basic_block begin_bb = get_entry_bb (codegen_region);\n+\n+  /* Inserting the gimple statements in a vector because gimple_seq behave\n+     in strage ways when inserting the stmts from it into different basic\n+     blocks one at a time.  */\n+  auto_vec<gimple *, 3> stmts;\n+  for (gimple_stmt_iterator gsi = gsi_start (seq); !gsi_end_p (gsi);\n+       gsi_next (&gsi))\n+    stmts.safe_push (gsi_stmt (gsi));\n+\n+  int i;\n+  gimple *use_stmt;\n+  FOR_EACH_VEC_ELT (stmts, i, use_stmt)\n+    {\n+      gcc_assert (gimple_code (use_stmt) != GIMPLE_PHI);\n+      gimple_stmt_iterator gsi_def_stmt = gsi_start_bb_nondebug (begin_bb);\n+\n+      use_operand_p use_p;\n+      ssa_op_iter op_iter;\n+      FOR_EACH_SSA_USE_OPERAND (use_p, use_stmt, op_iter, SSA_OP_USE)\n+\t{\n+\t  /* Iterator to the current def of use_p.  For function parameters or\n+\t     anything where def is not found, insert at the beginning of the\n+\t     generated region.  */\n+\t  gimple_stmt_iterator gsi_stmt = gsi_def_stmt;\n+\n+\t  tree op = USE_FROM_PTR (use_p);\n+\t  gimple *stmt = SSA_NAME_DEF_STMT (op);\n+\t  if (stmt && (gimple_code (stmt) != GIMPLE_NOP))\n+\t    gsi_stmt = gsi_for_stmt (stmt);\n+\n+\t  /* For region parameters, insert at the beginning of the generated\n+\t     region.  */\n+\t  if (!bb_in_sese_p (gsi_bb (gsi_stmt), codegen_region))\n+\t    gsi_stmt = gsi_def_stmt;\n+\n+\t  gsi_def_stmt = later_of_the_two (gsi_stmt, gsi_def_stmt);\n+\t}\n+\n+      if (!gsi_stmt (gsi_def_stmt))\n+\t{\n+\t  gimple_stmt_iterator gsi = gsi_after_labels (gsi_bb (gsi_def_stmt));\n+\t  gsi_insert_before (&gsi, use_stmt, GSI_NEW_STMT);\n+\t}\n+      else if (gimple_code (gsi_stmt (gsi_def_stmt)) == GIMPLE_PHI)\n+\t{\n+\t  gimple_stmt_iterator bsi\n+\t    = gsi_start_bb_nondebug (gsi_bb (gsi_def_stmt));\n+\t  /* Insert right after the PHI statements.  */\n+\t  gsi_insert_before (&bsi, use_stmt, GSI_NEW_STMT);\n+\t}\n+      else\n+\tgsi_insert_after (&gsi_def_stmt, use_stmt, GSI_NEW_STMT);\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"\\n[codegen] inserting statement: \");\n+\t  print_gimple_stmt (dump_file, use_stmt, 0, TDF_VOPS | TDF_MEMSYMS);\n+\t  print_loops_bb (dump_file, gimple_bb (use_stmt), 0, 3);\n+\t}\n+    }\n+}\n+\n+/* Collect all the operands of NEW_EXPR by recursively visiting each\n+   operand.  */\n+\n+void\n+translate_isl_ast_to_gimple::collect_all_ssa_names (tree new_expr,\n+\t\t\t\t\t\t    vec<tree> *vec_ssa)\n+{\n+\n+  /* Rename all uses in new_expr.  */\n+  if (TREE_CODE (new_expr) == SSA_NAME)\n+    {\n+      vec_ssa->safe_push (new_expr);\n+      return;\n+    }\n+\n+  /* Iterate over SSA_NAMES in NEW_EXPR.  */\n+  for (int i = 0; i < (TREE_CODE_LENGTH (TREE_CODE (new_expr))); i++)\n+    {\n+      tree op = TREE_OPERAND (new_expr, i);\n+      collect_all_ssa_names (op, vec_ssa);\n+    }\n+}\n+\n+/* This is abridged version of the function:\n+   tree.c:substitute_in_expr (tree exp, tree f, tree r). */\n+\n+static tree\n+substitute_ssa_name (tree exp, tree f, tree r)\n+{\n+  enum tree_code code = TREE_CODE (exp);\n+  tree op0, op1, op2, op3;\n+  tree new_tree;\n+\n+  /* We handle TREE_LIST and COMPONENT_REF separately.  */\n+  if (code == TREE_LIST)\n+    {\n+      op0 = substitute_ssa_name (TREE_CHAIN (exp), f, r);\n+      op1 = substitute_ssa_name (TREE_VALUE (exp), f, r);\n+      if (op0 == TREE_CHAIN (exp) && op1 == TREE_VALUE (exp))\n+\treturn exp;\n+\n+      return tree_cons (TREE_PURPOSE (exp), op1, op0);\n+    }\n+  else if (code == COMPONENT_REF)\n+    {\n+      tree inner;\n+\n+      /* If this expression is getting a value from a PLACEHOLDER_EXPR\n+\t and it is the right field, replace it with R.  */\n+      for (inner = TREE_OPERAND (exp, 0);\n+\t   REFERENCE_CLASS_P (inner);\n+\t   inner = TREE_OPERAND (inner, 0))\n+\t;\n+\n+      /* The field.  */\n+      op1 = TREE_OPERAND (exp, 1);\n+\n+      if (TREE_CODE (inner) == PLACEHOLDER_EXPR && op1 == f)\n+\treturn r;\n+\n+      /* If this expression hasn't been completed let, leave it alone.  */\n+      if (TREE_CODE (inner) == PLACEHOLDER_EXPR && !TREE_TYPE (inner))\n+\treturn exp;\n+\n+      op0 = substitute_ssa_name (TREE_OPERAND (exp, 0), f, r);\n+      if (op0 == TREE_OPERAND (exp, 0))\n+\treturn exp;\n+\n+      new_tree\n+\t= fold_build3 (COMPONENT_REF, TREE_TYPE (exp), op0, op1, NULL_TREE);\n+    }\n+  else\n+    switch (TREE_CODE_CLASS (code))\n+      {\n+      case tcc_constant:\n+\treturn exp;\n+\n+      case tcc_declaration:\n+\tif (exp == f)\n+\t  return r;\n+\telse\n+\t  return exp;\n+\n+      case tcc_expression:\n+\tif (exp == f)\n+\t  return r;\n+\n+\t/* Fall through...  */\n+\n+      case tcc_exceptional:\n+      case tcc_unary:\n+      case tcc_binary:\n+      case tcc_comparison:\n+      case tcc_reference:\n+\tswitch (TREE_CODE_LENGTH (code))\n+\t  {\n+\t  case 0:\n+\t    if (exp == f)\n+\t      return r;\n+\t    return exp;\n+\n+\t  case 1:\n+\t    op0 = substitute_ssa_name (TREE_OPERAND (exp, 0), f, r);\n+\t    if (op0 == TREE_OPERAND (exp, 0))\n+\t      return exp;\n+\n+\t    new_tree = fold_build1 (code, TREE_TYPE (exp), op0);\n+\t    break;\n+\n+\t  case 2:\n+\t    op0 = substitute_ssa_name (TREE_OPERAND (exp, 0), f, r);\n+\t    op1 = substitute_ssa_name (TREE_OPERAND (exp, 1), f, r);\n+\n+\t    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1))\n+\t      return exp;\n+\n+\t    new_tree = fold_build2 (code, TREE_TYPE (exp), op0, op1);\n+\t    break;\n+\n+\t  case 3:\n+\t    op0 = substitute_ssa_name (TREE_OPERAND (exp, 0), f, r);\n+\t    op1 = substitute_ssa_name (TREE_OPERAND (exp, 1), f, r);\n+\t    op2 = substitute_ssa_name (TREE_OPERAND (exp, 2), f, r);\n+\n+\t    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1)\n+\t\t&& op2 == TREE_OPERAND (exp, 2))\n+\t      return exp;\n+\n+\t    new_tree = fold_build3 (code, TREE_TYPE (exp), op0, op1, op2);\n+\t    break;\n+\n+\t  case 4:\n+\t    op0 = substitute_ssa_name (TREE_OPERAND (exp, 0), f, r);\n+\t    op1 = substitute_ssa_name (TREE_OPERAND (exp, 1), f, r);\n+\t    op2 = substitute_ssa_name (TREE_OPERAND (exp, 2), f, r);\n+\t    op3 = substitute_ssa_name (TREE_OPERAND (exp, 3), f, r);\n+\n+\t    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1)\n+\t\t&& op2 == TREE_OPERAND (exp, 2)\n+\t\t&& op3 == TREE_OPERAND (exp, 3))\n+\t      return exp;\n+\n+\t    new_tree\n+\t      = fold (build4 (code, TREE_TYPE (exp), op0, op1, op2, op3));\n+\t    break;\n+\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+\tbreak;\n+\n+      case tcc_vl_exp:\n+      default:\n+\tgcc_unreachable ();\n+      }\n+\n+  TREE_READONLY (new_tree) |= TREE_READONLY (exp);\n+\n+  if (code == INDIRECT_REF || code == ARRAY_REF || code == ARRAY_RANGE_REF)\n+    TREE_THIS_NOTRAP (new_tree) |= TREE_THIS_NOTRAP (exp);\n+\n+  return new_tree;\n+}\n+\n+/* Rename all the operands of NEW_EXPR by recursively visiting each operand.  */\n+\n+tree\n+translate_isl_ast_to_gimple::rename_all_uses (tree new_expr, basic_block new_bb,\n+\t\t\t\t\t      basic_block old_bb)\n+{\n+  auto_vec<tree, 2> ssa_names;\n+  collect_all_ssa_names (new_expr, &ssa_names);\n+  tree t;\n+  int i;\n+  FOR_EACH_VEC_ELT (ssa_names, i, t)\n+    if (tree r = get_rename (new_bb, t, old_bb, false))\n+      new_expr = substitute_ssa_name (new_expr, t, r);\n+\n+  return new_expr;\n+}\n+\n+/* For ops which are scev_analyzeable, we can regenerate a new name from\n+its scalar evolution around LOOP.  */\n+\n+tree\n+translate_isl_ast_to_gimple::\n+get_rename_from_scev (tree old_name, gimple_seq *stmts, loop_p loop,\n+\t\t      basic_block new_bb, basic_block old_bb,\n+\t\t      vec<tree> iv_map)\n+{\n+  tree scev = scalar_evolution_in_region (region->region, loop, old_name);\n+\n+  /* At this point we should know the exact scev for each\n+     scalar SSA_NAME used in the scop: all the other scalar\n+     SSA_NAMEs should have been translated out of SSA using\n+     arrays with one element.  */\n+  tree new_expr;\n+  if (chrec_contains_undetermined (scev))\n+    {\n+      codegen_error = true;\n+      return build_zero_cst (TREE_TYPE (old_name));\n+    }\n+\n+  new_expr = chrec_apply_map (scev, iv_map);\n+\n+  /* The apply should produce an expression tree containing\n+     the uses of the new induction variables.  We should be\n+     able to use new_expr instead of the old_name in the newly\n+     generated loop nest.  */\n+  if (chrec_contains_undetermined (new_expr)\n+      || tree_contains_chrecs (new_expr, NULL))\n+    {\n+      codegen_error = true;\n+      return build_zero_cst (TREE_TYPE (old_name));\n+    }\n+\n+  /* We should check all the operands and all of them should dominate the use at\n+     new_expr.  */\n+  if (TREE_CODE (new_expr) == SSA_NAME)\n+    {\n+      basic_block bb = gimple_bb (SSA_NAME_DEF_STMT (new_expr));\n+      if (bb && !dominated_by_p (CDI_DOMINATORS, new_bb, bb))\n+\t{\n+\t  /* FIXME: Remove if bootstrap passes.  */\n+\t  codegen_error = true;\n+\t  gcc_unreachable ();\n+\t  return build_zero_cst (TREE_TYPE (old_name));\n+\t}\n+    }\n+\n+  new_expr = rename_all_uses (new_expr, new_bb, old_bb);\n+  /* We should check all the operands and all of them should dominate the use at\n+     new_expr.  */\n+  if (TREE_CODE (new_expr) == SSA_NAME)\n+    {\n+      basic_block bb = gimple_bb (SSA_NAME_DEF_STMT (new_expr));\n+      if (bb && !dominated_by_p (CDI_DOMINATORS, new_bb, bb))\n+\t{\n+\t  /* FIXME: Remove if bootstrap passes.  */\n+\t  codegen_error = true;\n+\t  gcc_unreachable ();\n+\t  return build_zero_cst (TREE_TYPE (old_name));\n+\t}\n+    }\n+\n+  /* Replace the old_name with the new_expr.  */\n+  return force_gimple_operand (unshare_expr (new_expr), stmts,\n+\t\t\t       true, NULL_TREE);\n+}\n+\n+/* Renames the scalar uses of the statement COPY, using the\n+   substitution map RENAME_MAP, inserting the gimplification code at\n+   GSI_TGT, for the translation REGION, with the original copied\n+   statement in LOOP, and using the induction variable renaming map\n+   IV_MAP.  Returns true when something has been renamed.  codegen_error\n+   is set when the code generation cannot continue.  */\n+\n+bool\n+translate_isl_ast_to_gimple::rename_uses (gimple *copy,\n+\t\t\t\t\t  gimple_stmt_iterator *gsi_tgt,\n+\t\t\t\t\t  basic_block old_bb,\n+\t\t\t\t\t  loop_p loop, vec<tree> iv_map)\n+{\n+  bool changed = false;\n+\n+  if (is_gimple_debug (copy))\n+    {\n+      if (gimple_debug_bind_p (copy))\n+\tgimple_debug_bind_reset_value (copy);\n+      else if (gimple_debug_source_bind_p (copy))\n+\treturn false;\n+      else\n+\tgcc_unreachable ();\n+\n+      return false;\n+    }\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\n[codegen] renaming uses of stmt: \");\n+      print_gimple_stmt (dump_file, copy, 0, 0);\n+    }\n+\n+  use_operand_p use_p;\n+  ssa_op_iter op_iter;\n+  FOR_EACH_SSA_USE_OPERAND (use_p, copy, op_iter, SSA_OP_USE)\n+    {\n+      tree old_name = USE_FROM_PTR (use_p);\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"\\n[codegen] renaming old_name = \");\n+\t  print_generic_expr (dump_file, old_name, 0);\n+\t}\n+\n+      if (TREE_CODE (old_name) != SSA_NAME\n+\t  || SSA_NAME_IS_DEFAULT_DEF (old_name))\n+\tcontinue;\n+\n+      changed = true;\n+      tree new_expr = get_rename (gsi_tgt->bb, old_name,\n+\t\t\t\t  old_bb, false);\n+\n+      if (new_expr)\n+\t{\n+\t  tree type_old_name = TREE_TYPE (old_name);\n+\t  tree type_new_expr = TREE_TYPE (new_expr);\n+\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"\\n[codegen] from rename_map: new_name = \");\n+\t      print_generic_expr (dump_file, new_expr, 0);\n+\t    }\n+\n+\t  if (type_old_name != type_new_expr\n+\t      || TREE_CODE (new_expr) != SSA_NAME)\n+\t    {\n+\t      tree var = create_tmp_var (type_old_name, \"var\");\n+\n+\t      if (!useless_type_conversion_p (type_old_name, type_new_expr))\n+\t\tnew_expr = fold_convert (type_old_name, new_expr);\n+\n+\t      gimple_seq stmts;\n+\t      new_expr = force_gimple_operand (new_expr, &stmts, true, var);\n+\t      gsi_insert_earliest (stmts);\n+\t    }\n+\n+\t  replace_exp (use_p, new_expr);\n+\t  continue;\n+\t}\n+\n+      gimple_seq stmts;\n+      new_expr = get_rename_from_scev (old_name, &stmts, loop, gimple_bb (copy),\n+\t\t\t\t       old_bb, iv_map);\n+      if (!new_expr || codegen_error_p ())\n+\treturn false;\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"\\n[codegen] not in rename map, scev: \");\n+\t  print_generic_expr (dump_file, new_expr, 0);\n+\t}\n+\n+      gsi_insert_earliest (stmts);\n+      replace_exp (use_p, new_expr);\n+\n+      if (TREE_CODE (new_expr) == INTEGER_CST\n+\t  && is_gimple_assign (copy))\n+\t{\n+\t  tree rhs = gimple_assign_rhs1 (copy);\n+\n+\t  if (TREE_CODE (rhs) == ADDR_EXPR)\n+\t    recompute_tree_invariant_for_addr_expr (rhs);\n+\t}\n+\n+      set_rename (old_name, new_expr);\n+    }\n+\n+  return changed;\n+}\n+\n+/* Returns a basic block that could correspond to where a constant was defined\n+   in the original code.  In the original code OLD_BB had the definition, we\n+   need to find which basic block out of the copies of old_bb, in the new\n+   region, should a definition correspond to if it has to reach BB.  */\n+\n+basic_block\n+translate_isl_ast_to_gimple::get_def_bb_for_const (basic_block bb,\n+\t\t\t\t\t\t   basic_block old_bb) const\n+{\n+  vec <basic_block> *bbs = region->copied_bb_map->get (old_bb);\n+\n+  if (!bbs || bbs->is_empty ())\n+    return NULL;\n+\n+  if (1 == bbs->length ())\n+    return (*bbs)[0];\n+\n+  int i;\n+  basic_block b1 = NULL, b2;\n+  FOR_EACH_VEC_ELT (*bbs, i, b2)\n+    {\n+      if (b2 == bb)\n+\treturn bb;\n+\n+      /* BB and B2 are in two unrelated if-clauses.  */\n+      if (!dominated_by_p (CDI_DOMINATORS, bb, b2))\n+\tcontinue;\n+\n+      /* Compute the nearest dominator.  */\n+      if (!b1 || dominated_by_p (CDI_DOMINATORS, b2, b1))\n+\tb1 = b2;\n+    }\n+\n+  gcc_assert (b1);\n+  return b1;\n+}\n+\n+/* Get the new name of OP (from OLD_BB) to be used in NEW_BB.  LOOP_PHI is true\n+   when we want to rename an OP within a loop PHI instruction.  */\n+\n+tree\n+translate_isl_ast_to_gimple::\n+get_new_name (basic_block new_bb, tree op,\n+\t      basic_block old_bb, bool loop_phi) const\n+{\n+  /* For constants the names are the same.  */\n+  if (TREE_CODE (op) == INTEGER_CST\n+      || TREE_CODE (op) == REAL_CST\n+      || TREE_CODE (op) == COMPLEX_CST\n+      || TREE_CODE (op) == VECTOR_CST)\n+    return op;\n+\n+  return get_rename (new_bb, op, old_bb, loop_phi);\n+}\n+\n+/* Return a debug location for OP.  */\n+\n+static location_t\n+get_loc (tree op)\n+{\n+  location_t loc = UNKNOWN_LOCATION;\n+\n+  if (TREE_CODE (op) == SSA_NAME)\n+    loc = gimple_location (SSA_NAME_DEF_STMT (op));\n+  return loc;\n+}\n+\n+/* Returns the incoming edges of basic_block BB in the pair.  The first edge is\n+   the init edge (from outside the loop) and the second one is the back edge\n+   from the same loop.  */\n+\n+std::pair<edge, edge>\n+get_edges (basic_block bb)\n+{\n+  std::pair<edge, edge> edges;\n+  edge e;\n+  edge_iterator ei;\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    if (bb->loop_father != e->src->loop_father)\n+      edges.first = e;\n+    else\n+      edges.second = e;\n+  return edges;\n+}\n+\n+/* Copy the PHI arguments from OLD_PHI to the NEW_PHI.  The arguments to NEW_PHI\n+   must be found unless they can be POSTPONEd for later.  */\n+\n+void\n+translate_isl_ast_to_gimple::\n+copy_loop_phi_args (gphi *old_phi, init_back_edge_pair_t &ibp_old_bb,\n+\t\t    gphi *new_phi, init_back_edge_pair_t &ibp_new_bb,\n+\t\t    bool postpone)\n+{\n+  gcc_assert (gimple_phi_num_args (old_phi) == gimple_phi_num_args (new_phi));\n+\n+  basic_block new_bb = gimple_bb (new_phi);\n+  for (unsigned i = 0; i < gimple_phi_num_args (old_phi); i++)\n+    {\n+      edge e;\n+      if (gimple_phi_arg_edge (old_phi, i) == ibp_old_bb.first)\n+\te = ibp_new_bb.first;\n+      else\n+\te = ibp_new_bb.second;\n+\n+      tree old_name = gimple_phi_arg_def (old_phi, i);\n+      tree new_name = get_new_name (new_bb, old_name,\n+\t\t\t\t    gimple_bb (old_phi), true);\n+      if (new_name)\n+\t{\n+\t  add_phi_arg (new_phi, new_name, e, get_loc (old_name));\n+\t  continue;\n+\t}\n+\n+      gimple *old_def_stmt = SSA_NAME_DEF_STMT (old_name);\n+      if (!old_def_stmt || gimple_code (old_def_stmt) == GIMPLE_NOP)\n+\t/* If the phi arg was a function arg, or wasn't defined, just use the\n+\t   old name.  */\n+\tadd_phi_arg (new_phi, old_name, e, get_loc (old_name));\n+      else if (postpone)\n+\t{\n+\t  /* Postpone code gen for later for those back-edges we don't have the\n+\t     names yet.  */\n+\t  region->incomplete_phis.safe_push (std::make_pair (old_phi, new_phi));\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"\\n[codegen] postpone loop phi nodes: \");\n+\t}\n+      else\n+\t/* Either we should add the arg to phi or, we should postpone.  */\n+\tgcc_unreachable ();\n+    }\n+}\n+\n+/* Copy loop phi nodes from BB to NEW_BB.  */\n+\n+bool\n+translate_isl_ast_to_gimple::copy_loop_phi_nodes (basic_block bb,\n+\t\t\t\t\t\t  basic_block new_bb)\n+{\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n[codegen] copying loop phi nodes in bb_%d.\",\n+\t     new_bb->index);\n+\n+  /* Loop phi nodes should have only two arguments.  */\n+  gcc_assert (2 == EDGE_COUNT (bb->preds));\n+\n+  /* First edge is the init edge and second is the back edge.  */\n+  init_back_edge_pair_t ibp_old_bb = get_edges (bb);\n+\n+  /* First edge is the init edge and second is the back edge.  */\n+  init_back_edge_pair_t ibp_new_bb = get_edges (new_bb);\n+\n+  for (gphi_iterator psi = gsi_start_phis (bb); !gsi_end_p (psi);\n+       gsi_next (&psi))\n+    {\n+      gphi *phi = psi.phi ();\n+      tree res = gimple_phi_result (phi);\n+      if (virtual_operand_p (res))\n+\tcontinue;\n+      if (is_gimple_reg (res) && scev_analyzable_p (res, region->region))\n+\tcontinue;\n+\n+      gphi *new_phi = create_phi_node (SSA_NAME_VAR (res), new_bb);\n+      tree new_res = create_new_def_for (res, new_phi,\n+\t\t\t\t\t gimple_phi_result_ptr (new_phi));\n+      set_rename (res, new_res);\n+      copy_loop_phi_args (phi, ibp_old_bb, new_phi, ibp_new_bb, true);\n+      update_stmt (new_phi);\n+    }\n+\n+  return true;\n+}\n+\n+/* Return the init value of PHI, the value coming from outside the loop.  */\n+\n+static tree\n+get_loop_init_value (gphi *phi)\n+{\n+\n+  loop_p loop = gimple_bb (phi)->loop_father;\n+\n+  edge e;\n+  edge_iterator ei;\n+  FOR_EACH_EDGE (e, ei, gimple_bb (phi)->preds)\n+    if (e->src->loop_father != loop)\n+      return gimple_phi_arg_def (phi, e->dest_idx);\n+\n+  return NULL_TREE;\n+}\n+\n+/* Find the init value (the value which comes from outside the loop), of one of\n+   the operands of DEF which is defined by a loop phi.  */\n+\n+static tree\n+find_init_value (gimple *def)\n+{\n+  if (gimple_code (def) == GIMPLE_PHI)\n+    return get_loop_init_value (as_a <gphi*> (def));\n+\n+  if (gimple_vuse (def))\n+    return NULL_TREE;\n+\n+  ssa_op_iter iter;\n+  use_operand_p use_p;\n+  FOR_EACH_SSA_USE_OPERAND (use_p, def, iter, SSA_OP_USE)\n+    {\n+      tree use = USE_FROM_PTR (use_p);\n+      if (TREE_CODE (use) == SSA_NAME)\n+\t{\n+\t  if (tree res = find_init_value (SSA_NAME_DEF_STMT (use)))\n+\t    return res;\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Return the init value, the value coming from outside the loop.  */\n+\n+static tree\n+find_init_value_close_phi (gphi *phi)\n+{\n+  gcc_assert (gimple_phi_num_args (phi) == 1);\n+  tree use_arg = gimple_phi_arg_def (phi, 0);\n+  gimple *def = SSA_NAME_DEF_STMT (use_arg);\n+  return find_init_value (def);\n+}\n+\n+/* Copy all the loop-close phi args from BB to NEW_BB.  */\n+\n+bool\n+translate_isl_ast_to_gimple::copy_loop_close_phi_args (basic_block old_bb,\n+\t\t\t\t\t\t       basic_block new_bb,\n+\t\t\t\t\t\t       bool postpone)\n+{\n+  /* The successor of bb having close phi should be a merge of the diamond\n+     inserted to guard the loop during codegen.  */\n+  basic_block close_phi_merge_bb = single_succ (new_bb);\n+\n+  for (gphi_iterator psi = gsi_start_phis (old_bb); !gsi_end_p (psi);\n+       gsi_next (&psi))\n+    {\n+      gphi *phi = psi.phi ();\n+      tree res = gimple_phi_result (phi);\n+      if (virtual_operand_p (res))\n+\tcontinue;\n+\n+      if (is_gimple_reg (res) && scev_analyzable_p (res, region->region))\n+\t/* Loop close phi nodes should not be scev_analyzable_p.  */\n+\tgcc_unreachable ();\n+\n+      gphi *new_phi = create_phi_node (SSA_NAME_VAR (res), new_bb);\n+      tree new_res = create_new_def_for (res, new_phi,\n+\t\t\t\t\t gimple_phi_result_ptr (new_phi));\n+      set_rename (res, new_res);\n+\n+      tree old_name = gimple_phi_arg_def (phi, 0);\n+      tree new_name = get_new_name (new_bb, old_name, old_bb, false);\n+\n+      /* Predecessor basic blocks of a loop close phi should have been code\n+\t generated before.  FIXME: This is fixable by merging PHIs from inner\n+\t loops as well.  See: gfortran.dg/graphite/interchange-3.f90.  */\n+      if (!new_name)\n+\treturn false;\n+\n+      add_phi_arg (new_phi, new_name, single_pred_edge (new_bb),\n+\t\t   get_loc (old_name));\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"\\n[codegen] Adding loop-closed phi: \");\n+\t  print_gimple_stmt (dump_file, new_phi, 0, 0);\n+\t}\n+\n+      update_stmt (new_phi);\n+\n+      /* When there is no loop guard around this codegenerated loop, there is no\n+\t need to collect the close-phi arg.  */\n+      if (2 != EDGE_COUNT (close_phi_merge_bb->preds))\n+\tcontinue;\n+\n+      /* Add a PHI in the close_phi_merge_bb for each close phi of the loop.  */\n+      tree init = find_init_value_close_phi (new_phi);\n+\n+      /* A close phi must come from a loop-phi having an init value.  */\n+      if (!init)\n+\t{\n+\t  gcc_assert (postpone);\n+\t  region->incomplete_phis.safe_push (std::make_pair (phi, new_phi));\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"\\n[codegen] postpone close phi nodes: \");\n+\t      print_gimple_stmt (dump_file, new_phi, 0, 0);\n+\t    }\n+\t  continue;\n+\t}\n+\n+      gphi *merge_phi = create_phi_node (SSA_NAME_VAR (res),\n+\t\t\t  \t\t close_phi_merge_bb);\n+      tree merge_res = create_new_def_for (res, merge_phi,\n+\t\t\t\t\t   gimple_phi_result_ptr (merge_phi));\n+      set_rename (res, merge_res);\n+\n+      edge from_loop = single_succ_edge (new_bb);\n+      add_phi_arg (merge_phi, new_res, from_loop, get_loc (old_name));\n+\n+      /* The edge coming from loop guard.  */\n+      edge other = from_loop == (*close_phi_merge_bb->preds)[0]\n+\t? (*close_phi_merge_bb->preds)[1] : (*close_phi_merge_bb->preds)[0];\n+\n+      add_phi_arg (merge_phi, init, other, get_loc (old_name));\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"\\n[codegen] Adding guard-phi: \");\n+\t  print_gimple_stmt (dump_file, merge_phi, 0, 0);\n+\t}\n+\n+      update_stmt (new_phi);\n+    }\n+\n+  return true;\n+}\n+\n+/* Copy loop close phi nodes from BB to NEW_BB.  */\n+\n+bool\n+translate_isl_ast_to_gimple::copy_loop_close_phi_nodes (basic_block old_bb,\n+\t\t\t\t\t\t\tbasic_block new_bb)\n+{\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n[codegen] copying loop closed phi nodes in bb_%d.\",\n+\t     new_bb->index);\n+  /* Loop close phi nodes should have only one argument.  */\n+  gcc_assert (1 == EDGE_COUNT (old_bb->preds));\n+\n+  return copy_loop_close_phi_args (old_bb, new_bb, true);\n+}\n+\n+\n+/* Add NEW_NAME as the ARGNUM-th arg of NEW_PHI which is in NEW_BB.\n+   DOMINATING_PRED is the predecessor basic block of OLD_BB which dominates the\n+   other pred of OLD_BB as well.  If no such basic block exists then it is NULL.\n+   NON_DOMINATING_PRED is a pred which does not dominate OLD_BB, it cannot be\n+   NULL.\n+\n+   Case1: OLD_BB->preds {BB1, BB2} and BB1 does not dominate BB2 and vice versa.\n+   In this case DOMINATING_PRED = NULL.\n+\n+   Case2: OLD_BB->preds {BB1, BB2} and BB1 dominates BB2.\n+\n+   Returns true on successful copy of the args, false otherwise.  */\n+\n+bool\n+translate_isl_ast_to_gimple::\n+add_phi_arg_for_new_expr (tree old_phi_args[2], tree new_phi_args[2],\n+\t\t\t  edge old_bb_dominating_edge,\n+\t\t\t  edge old_bb_non_dominating_edge,\n+\t\t\t  gphi *phi, gphi *new_phi,\n+\t\t\t  basic_block new_bb)\n+{\n+  basic_block def_pred[2];\n+  int not_found_bb_index = -1;\n+  for (int i = 0; i < 2; i++)\n+    {\n+      /* If the corresponding def_bb could not be found the entry will be\n+\t NULL.  */\n+      if (TREE_CODE (old_phi_args[i]) == INTEGER_CST)\n+\tdef_pred[i] = get_def_bb_for_const (new_bb,\n+\t\t\t\t\t    gimple_phi_arg_edge (phi, i)->src);\n+      else\n+\tdef_pred[i] = gimple_bb (SSA_NAME_DEF_STMT (new_phi_args[i]));\n+      if (!def_pred[i])\n+\t{\n+\t  gcc_assert (not_found_bb_index == -1);\n+\t  not_found_bb_index = i;\n+\t}\n+    }\n+\n+  /* Here we are pattern matching on the structure of CFG w.r.t. old one.  */\n+  if (old_bb_dominating_edge)\n+    {\n+      return false;\n+      basic_block new_pred1 = (*new_bb->preds)[0]->src;\n+      basic_block new_pred2 = (*new_bb->preds)[1]->src;\n+      vec <basic_block> *bbs\n+\t= region->copied_bb_map->get (old_bb_non_dominating_edge->src);\n+      gcc_assert (bbs);\n+      basic_block new_pred = NULL;\n+      basic_block b;\n+      int i;\n+      FOR_EACH_VEC_ELT (*bbs, i, b)\n+\tif (new_pred1 == b || new_pred2 == b)\n+\t  {\n+\t    gcc_assert (!new_pred);\n+\t    new_pred = b;\n+\t  }\n+\n+      gcc_assert (new_pred);\n+\n+      edge new_non_dominating_edge = find_edge (new_pred, new_bb);\n+      /* By the process of elimination we first insert insert phi-edge for\n+\t non-dominating pred which is computed above and then we insert the\n+\t remaining one.  */\n+      int inserted_edge = 0;\n+      for (; inserted_edge < 2; inserted_edge++)\n+\t{\n+\t  edge new_bb_pred_edge = gimple_phi_arg_edge (phi, inserted_edge);\n+\t  if (new_non_dominating_edge == new_bb_pred_edge)\n+\t    {\n+\t      add_phi_arg (new_phi, new_phi_args[inserted_edge],\n+\t\t\t   new_non_dominating_edge,\n+\t\t\t   get_loc (old_phi_args[inserted_edge]));\n+\t      break;\n+\t    }\n+\t}\n+\n+      int edge_dominating = 0;\n+      if (inserted_edge == 0)\n+\tedge_dominating = 1;\n+\n+      edge new_dominating_edge = NULL;\n+      for (int i; i < 2; i++)\n+\t{\n+\t  edge e = gimple_phi_arg_edge (new_phi, i);\n+\t  if (e != new_non_dominating_edge)\n+\t    new_dominating_edge = e;\n+\t}\n+\n+      add_phi_arg (new_phi, new_phi_args[edge_dominating], new_dominating_edge,\n+\t\t   get_loc (old_phi_args[inserted_edge]));\n+    }\n+  else\n+    {\n+      /* Classic diamond structure: both edges are non-dominating.  We need to\n+\t find one unique edge then the other can be found be elimination.  If\n+\t any definition (def_pred) dominates both the preds of new_bb then we\n+\t bail out.  Entries of def_pred maybe NULL, in that case we must\n+\t uniquely find pred with help of only one entry.  */\n+      edge new_e[2] = { NULL, NULL };\n+      for (int i = 0; i < 2; i++)\n+\t{\n+\t  edge e;\n+\t  edge_iterator ei;\n+\t  FOR_EACH_EDGE (e, ei, new_bb->preds)\n+\t    if (def_pred[i]\n+\t\t&& dominated_by_p (CDI_DOMINATORS, e->src, def_pred[i]))\n+\t      {\n+\t\tif (new_e[i])\n+\t\t  /* We do not know how to handle the case when def_pred\n+\t\t     dominates more than a predecessor.  */\n+\t\t  return false;\n+\t\tnew_e[i] = e;\n+\t      }\n+\t}\n+\n+      gcc_assert (new_e[0] || new_e[1]);\n+\n+      /* Find the other edge by process of elimination.  */\n+      if (not_found_bb_index != -1)\n+\t{\n+\t  gcc_assert (!new_e[not_found_bb_index]);\n+\t  int found_bb_index = not_found_bb_index == 1 ? 0 : 1;\n+\t  edge e;\n+\t  edge_iterator ei;\n+\t  FOR_EACH_EDGE (e, ei, new_bb->preds)\n+\t    {\n+\t      if (new_e[found_bb_index] == e)\n+\t\tcontinue;\n+\t      new_e[not_found_bb_index] = e;\n+\t    }\n+\t}\n+\n+      /* Add edges to phi args.  */\n+      for (int i = 0; i < 2; i++)\n+\tadd_phi_arg (new_phi, new_phi_args[i], new_e[i],\n+\t\t     get_loc (old_phi_args[i]));\n+    }\n+\n+  return true;\n+}\n+\n+/* Copy the arguments of cond-phi node PHI, to NEW_PHI in the codegenerated\n+   region.  If postpone is true and it isn't possible to copy any arg of PHI,\n+   the PHI is added to the REGION->INCOMPLETE_PHIS to be codegenerated later.\n+   Returns false if the copying was unsuccessful.  */\n+\n+bool\n+translate_isl_ast_to_gimple::copy_cond_phi_args (gphi *phi, gphi *new_phi,\n+\t\t\t\t\t\t vec<tree> iv_map,\n+\t\t\t\t\t\t bool postpone)\n+{\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n[codegen] copying cond phi args: \");\n+  gcc_assert (2 == gimple_phi_num_args (phi));\n+\n+  basic_block new_bb = gimple_bb (new_phi);\n+  loop_p loop = gimple_bb (phi)->loop_father;\n+\n+  basic_block old_bb = gimple_bb (phi);\n+  edge old_bb_non_dominating_edge = NULL, old_bb_dominating_edge = NULL;\n+\n+  edge e;\n+  edge_iterator ei;\n+  FOR_EACH_EDGE (e, ei, old_bb->preds)\n+    if (!dominated_by_p (CDI_DOMINATORS, old_bb, e->src))\n+      old_bb_non_dominating_edge = e;\n+    else\n+      old_bb_dominating_edge = e;\n+\n+  gcc_assert (!dominated_by_p (CDI_DOMINATORS, old_bb,\n+\t\t\t       old_bb_non_dominating_edge->src));\n+\n+  tree new_phi_args[2];\n+  tree old_phi_args[2];\n+\n+  for (unsigned i = 0; i < gimple_phi_num_args (phi); i++)\n+    {\n+      tree old_name = gimple_phi_arg_def (phi, i);\n+      tree new_name = get_new_name (new_bb, old_name, old_bb, false);\n+      old_phi_args[i] = old_name;\n+      if (new_name)\n+\t{\n+\t  new_phi_args [i] = new_name;\n+\t  continue;\n+\t}\n+\n+      /* If the phi-arg was a parameter.  */\n+      if (vec_find (region->params, old_name))\n+\t{\n+\t  new_phi_args [i] = old_name;\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file,\n+\t\t       \"\\n[codegen] parameter argument to phi, new_expr: \");\n+\t      print_gimple_stmt (dump_file, new_phi, 0, 0);\n+\t    }\n+\t  continue;\n+\t}\n+\n+      /* If the phi-arg is scev-analyzeable but only in the first stage.  */\n+      if (postpone && is_gimple_reg (old_name)\n+\t  && scev_analyzable_p (old_name, region->region))\n+\t{\n+\t  gimple_seq stmts;\n+\t  tree new_expr = get_rename_from_scev (old_name, &stmts, loop, new_bb,\n+\t\t\t\t\t\told_bb, iv_map);\n+\t  if (codegen_error_p ())\n+\t    return false;\n+\n+\t  gcc_assert (new_expr);\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"\\n[codegen] scev analyzeable, new_expr: \");\n+\t      print_generic_expr (dump_file, new_expr, 0);\n+\t    }\n+\t  gsi_insert_earliest (stmts);\n+\t  new_phi_args [i] = new_name;\n+\t  continue;\n+\t}\n+\n+      gimple *old_def_stmt = SSA_NAME_DEF_STMT (old_name);\n+      if (!old_def_stmt || gimple_code (old_def_stmt) == GIMPLE_NOP)\n+\t/* If the phi arg was a function arg, or wasn't defined, just use the\n+\t   old name.  */\n+\tgcc_unreachable ();\n+      //add_phi_arg (new_phi, old_name, new_e, get_loc (old_name));\n+      else if (postpone)\n+\t{\n+\t  /* Postpone code gen for later for back-edges.  */\n+\t  region->incomplete_phis.safe_push (std::make_pair (phi, new_phi));\n+\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"\\n[codegen] postpone cond phi nodes: \");\n+\t      print_gimple_stmt (dump_file, new_phi, 0, 0);\n+\t    }\n+\n+\t  new_phi_args [i] = NULL_TREE;\n+\t  continue;\n+\t}\n+      else\n+\tgcc_unreachable ();\n+    }\n+\n+  return add_phi_arg_for_new_expr (old_phi_args, new_phi_args,\n+\t\t\t\t   old_bb_dominating_edge,\n+\t\t\t\t   old_bb_non_dominating_edge,\n+\t\t\t\t   phi, new_phi, new_bb);\n+}\n+\n+/* Copy cond phi nodes from BB to NEW_BB.  A cond-phi node is a basic block\n+   containing phi nodes coming from two predecessors, and none of them are back\n+   edges.  */\n+\n+bool\n+translate_isl_ast_to_gimple::copy_cond_phi_nodes (basic_block bb,\n+\t\t\t\t\t\t  basic_block new_bb,\n+\t\t\t\t\t\t  vec<tree> iv_map)\n+{\n+\n+  gcc_assert (!bb_contains_loop_close_phi_nodes (bb));\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n[codegen] copying cond phi nodes in bb_%d:\",\n+\t     new_bb->index);\n+\n+  /* Cond phi nodes should have exactly two arguments.  */\n+  gcc_assert (2 == EDGE_COUNT (bb->preds));\n+\n+  for (gphi_iterator psi = gsi_start_phis (bb); !gsi_end_p (psi);\n+       gsi_next (&psi))\n+    {\n+      gphi *phi = psi.phi ();\n+      tree res = gimple_phi_result (phi);\n+      if (virtual_operand_p (res))\n+\tcontinue;\n+      if (is_gimple_reg (res) && scev_analyzable_p (res, region->region))\n+\t/* Cond phi nodes should not be scev_analyzable_p.  */\n+\tgcc_unreachable ();\n+\n+      gphi *new_phi = create_phi_node (SSA_NAME_VAR (res), new_bb);\n+      tree new_res = create_new_def_for (res, new_phi,\n+\t\t\t\t\t gimple_phi_result_ptr (new_phi));\n+      set_rename (res, new_res);\n+\n+      if (!copy_cond_phi_args (phi, new_phi, iv_map, true))\n+\treturn false;\n+\n+      update_stmt (new_phi);\n+    }\n+\n+  return true;\n+}\n+\n+/* Return true if STMT should be copied from region to the new code-generated\n+   region.  LABELs, CONDITIONS, induction-variables and region parameters need\n+   not be copied.  */\n+\n+static bool\n+should_copy_to_new_region (gimple *stmt, sese_info_p region)\n+{\n+  /* Do not copy labels or conditions.  */\n+  if (gimple_code (stmt) == GIMPLE_LABEL\n+      || gimple_code (stmt) == GIMPLE_COND)\n+    return false;\n+\n+  tree lhs;\n+  /* Do not copy induction variables.  */\n+  if (is_gimple_assign (stmt)\n+      && (lhs = gimple_assign_lhs (stmt))\n+      && TREE_CODE (lhs) == SSA_NAME\n+      && is_gimple_reg (lhs)\n+      && scev_analyzable_p (lhs, region->region))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Create new names for all the definitions created by COPY and add replacement\n+   mappings for each new name.  */\n+\n+void\n+translate_isl_ast_to_gimple::set_rename_for_each_def (gimple *stmt)\n+{\n+  def_operand_p def_p;\n+  ssa_op_iter op_iter;\n+  FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, op_iter, SSA_OP_ALL_DEFS)\n+    {\n+      tree old_name = DEF_FROM_PTR (def_p);\n+      tree new_name = create_new_def_for (old_name, stmt, def_p);\n+      set_rename (old_name, new_name);\n+    }\n+}\n+\n+/* Duplicates the statements of basic block BB into basic block NEW_BB\n+   and compute the new induction variables according to the IV_MAP.\n+   CODEGEN_ERROR is set when the code generation cannot continue.  */\n+\n+bool\n+translate_isl_ast_to_gimple::graphite_copy_stmts_from_block (basic_block bb,\n+\t\t\t\t\t\t\t     basic_block new_bb,\n+\t\t\t\t\t\t\t     vec<tree> iv_map)\n+{\n+  /* Iterator poining to the place where new statement (s) will be inserted.  */\n+  gimple_stmt_iterator gsi_tgt = gsi_last_bb (new_bb);\n+\n+  for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n+       gsi_next (&gsi))\n+    {\n+      gimple *stmt = gsi_stmt (gsi);\n+      if (!should_copy_to_new_region (stmt, region))\n+\tcontinue;\n+\n+      /* Create a new copy of STMT and duplicate STMT's virtual\n+\t operands.  */\n+      gimple *copy = gimple_copy (stmt);\n+      gsi_insert_after (&gsi_tgt, copy, GSI_NEW_STMT);\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"\\n[codegen] inserting statement: \");\n+\t  print_gimple_stmt (dump_file, copy, 0, 0);\n+\t}\n+\n+      maybe_duplicate_eh_stmt (copy, stmt);\n+      gimple_duplicate_stmt_histograms (cfun, copy, cfun, stmt);\n+\n+      /* Crete new names for each def in the copied stmt.  */\n+      set_rename_for_each_def (copy);\n+\n+      loop_p loop = bb->loop_father;\n+      if (rename_uses (copy, &gsi_tgt, bb, loop, iv_map))\n+\t{\n+\t  fold_stmt_inplace (&gsi_tgt);\n+\t  gcc_assert (gsi_stmt (gsi_tgt) == copy);\n+\t}\n+\n+      if (codegen_error_p ())\n+\treturn false;\n+\n+      update_stmt (copy);\n+    }\n+\n+  return true;\n+}\n+\n+/* Copies BB and includes in the copied BB all the statements that can\n+   be reached following the use-def chains from the memory accesses,\n+   and returns the next edge following this new block.  codegen_error is\n+   set when the code generation cannot continue.  */\n+\n+edge\n+translate_isl_ast_to_gimple::copy_bb_and_scalar_dependences (basic_block bb,\n+\t\t\t\t\t\t\t     edge next_e,\n+\t\t\t\t\t\t\t     vec<tree> iv_map)\n+{\n+  int num_phis = number_of_phi_nodes (bb);\n+\n+  if (region->copied_bb_map->get (bb))\n+    {\n+      /* FIXME: we should be able to handle phi nodes with args coming from\n+\t outside the region.  */\n+      if (num_phis)\n+\t{\n+\t  codegen_error = true;\n+\t  return NULL;\n+\t}\n+    }\n+\n+  basic_block new_bb = split_edge (next_e);\n+  if (num_phis > 0 && bb_contains_loop_phi_nodes (bb))\n+    {\n+      basic_block phi_bb = next_e->dest->loop_father->header;\n+\n+      /* At this point we are unable to codegenerate by still preserving the SSA\n+\t structure because maybe the loop is completely unrolled and the PHIs\n+\t and cross-bb scalar dependencies are untrackable w.r.t. the original\n+\t code.  See gfortran.dg/graphite/pr29832.f90.  */\n+      if (EDGE_COUNT (bb->preds) != EDGE_COUNT (phi_bb->preds))\n+\t{\n+\t  codegen_error = true;\n+\t  return NULL;\n+\t}\n+\n+      if (dump_file)\n+\tfprintf (dump_file, \"\\n[codegen] bb_%d contains loop phi nodes\",\n+\t\t bb->index);\n+      if (!copy_loop_phi_nodes (bb, phi_bb))\n+\t{\n+\t  codegen_error = true;\n+\t  return NULL;\n+\t}\n+    }\n+  else if (bb_contains_loop_close_phi_nodes (bb))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"\\n[codegen] bb_%d contains close phi nodes\",\n+\t\t bb->index);\n+\n+      /* Make sure that NEW_BB is the loop->exit->dest.  */\n+      edge e = single_pred_edge (new_bb);\n+      basic_block phi_bb = new_bb;\n+      if (e->src->loop_father == e->dest->loop_father)\n+\t{\n+\t  /* This is one of the places which shows preserving original structure\n+\t     is not always possible, as we may need to insert close PHI for a\n+\t     loop where the latch does not have any mapping, or the mapping is\n+\t     ambiguous.  */\n+\t  basic_block old_loop_bb = single_pred_edge (bb)->src;\n+\t  vec <basic_block> *bbs = region->copied_bb_map->get (old_loop_bb);\n+\t  if (!bbs || bbs->length () != 1)\n+\t    {\n+\t      codegen_error = true;\n+\t      return NULL;\n+\t    }\n+\n+\t  basic_block new_loop_bb = (*bbs)[0];\n+\t  loop_p new_loop = new_loop_bb->loop_father;\n+\t  phi_bb = single_exit (new_loop)->dest;\n+\t  e = single_pred_edge (phi_bb);\n+\t}\n+\n+      gcc_assert (e->src->loop_father != e->dest->loop_father);\n+\n+      if (!copy_loop_close_phi_nodes (bb, phi_bb))\n+\t{\n+\t  codegen_error = true;\n+\t  return NULL;\n+\t}\n+    }\n+  else if (num_phis > 0)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"\\n[codegen] bb_%d contains cond phi nodes\",\n+\t\t bb->index);\n+\n+      basic_block phi_bb = single_pred (new_bb);\n+      loop_p loop_father = new_bb->loop_father;\n+\n+      /* Move back until we find the block with two predecessors.  */\n+      while (single_pred_p (phi_bb))\n+\tphi_bb = single_pred_edge (phi_bb)->src;\n+\n+      /* If a corresponding merge-point was not found, then abort codegen.  */\n+      if (phi_bb->loop_father != loop_father\n+\t  || !copy_cond_phi_nodes (bb, phi_bb, iv_map))\n+\t{\n+\t  codegen_error = true;\n+\t  return NULL;\n+\t}\n+    }\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n[codegen] copying from bb_%d to bb_%d\",\n+\t     bb->index, new_bb->index);\n+\n+  vec <basic_block> *copied_bbs = region->copied_bb_map->get (bb);\n+  if (copied_bbs)\n+    copied_bbs->safe_push (new_bb);\n+  else\n+    {\n+      vec<basic_block> bbs;\n+      bbs.create (2);\n+      bbs.safe_push (new_bb);\n+      region->copied_bb_map->put (bb, bbs);\n+    }\n+\n+  if (!graphite_copy_stmts_from_block (bb, new_bb, iv_map))\n+    {\n+      codegen_error = true;\n+      return NULL;\n+    }\n+\n+  return single_succ_edge (new_bb);\n+}\n+\n+/* Patch the missing arguments of the phi nodes.  */\n+\n+void\n+translate_isl_ast_to_gimple::translate_pending_phi_nodes ()\n+{\n+  int i;\n+  phi_rename *rename;\n+  FOR_EACH_VEC_ELT (region->incomplete_phis, i, rename)\n+    {\n+      gphi *old_phi = rename->first;\n+      gphi *new_phi = rename->second;\n+      basic_block old_bb = gimple_bb (old_phi);\n+      basic_block new_bb = gimple_bb (new_phi);\n+\n+      /* First edge is the init edge and second is the back edge.  */\n+      init_back_edge_pair_t ibp_old_bb = get_edges (old_bb);\n+      init_back_edge_pair_t ibp_new_bb = get_edges (new_bb);\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"\\n[codegen] translating pending old-phi: \");\n+\t  print_gimple_stmt (dump_file, old_phi, 0, 0);\n+\t}\n+\n+      auto_vec <tree, 1> iv_map;\n+      if (bb_contains_loop_phi_nodes (new_bb))\n+\tcopy_loop_phi_args (old_phi, ibp_old_bb, new_phi,\n+\t\t\t    ibp_new_bb, false);\n+      else if (bb_contains_loop_close_phi_nodes (new_bb))\n+\tcopy_loop_close_phi_args (old_bb, new_bb, false);\n+      else if (!copy_cond_phi_args (old_phi, new_phi, iv_map, false))\n+\tgcc_unreachable ();\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"[codegen] to new-phi: \");\n+\t  print_gimple_stmt (dump_file, new_phi, 0, 0);\n+\t}\n+    }\n+}\n+\n+/* Prints NODE to FILE.  */\n+\n+void\n+translate_isl_ast_to_gimple::print_isl_ast_node (FILE *file,\n+\t\t\t\t\t\t __isl_keep isl_ast_node *node,\n+\t\t\t\t\t\t __isl_keep isl_ctx *ctx) const\n+{\n+  isl_printer *prn = isl_printer_to_file (ctx, file);\n+  prn = isl_printer_set_output_format (prn, ISL_FORMAT_C);\n+  prn = isl_printer_print_ast_node (prn, node);\n+  prn = isl_printer_print_str (prn, \"\\n\");\n+  isl_printer_free (prn);\n+}\n+\n+/* Add ISL's parameter identifiers and corresponding trees to ivs_params.  */\n+\n+void\n+translate_isl_ast_to_gimple::add_parameters_to_ivs_params (scop_p scop,\n+\t\t\t\t\t\t\t   ivs_params &ip)\n+{\n+  sese_info_p region = scop->scop_info;\n+  unsigned nb_parameters = isl_set_dim (scop->param_context, isl_dim_param);\n+  gcc_assert (nb_parameters == region->params.length ());\n+  unsigned i;\n+  for (i = 0; i < nb_parameters; i++)\n+    {\n+      isl_id *tmp_id = isl_set_get_dim_id (scop->param_context,\n+\t\t\t\t\t   isl_dim_param, i);\n+      ip[tmp_id] = region->params[i];\n+    }\n+}\n+\n+\n+/* Generates a build, which specifies the constraints on the parameters.  */\n+\n+__isl_give isl_ast_build *\n+translate_isl_ast_to_gimple::generate_isl_context (scop_p scop)\n+{\n+  isl_set *context_isl = isl_set_params (isl_set_copy (scop->param_context));\n+  return isl_ast_build_from_context (context_isl);\n+}\n+\n+/* Get the maximal number of schedule dimensions in the scop SCOP.  */\n+\n+int\n+translate_isl_ast_to_gimple::get_max_schedule_dimensions (scop_p scop)\n+{\n+  int i;\n+  poly_bb_p pbb;\n+  int schedule_dims = 0;\n+\n+  FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)\n+    {\n+      int pbb_schedule_dims = isl_map_dim (pbb->transformed, isl_dim_out);\n+      if (pbb_schedule_dims > schedule_dims)\n+\tschedule_dims = pbb_schedule_dims;\n+    }\n+\n+  return schedule_dims;\n+}\n+\n+/* Extend the schedule to NB_SCHEDULE_DIMS schedule dimensions.\n+\n+   For schedules with different dimensionality, the isl AST generator can not\n+   define an order and will just randomly choose an order.  The solution to this\n+   problem is to extend all schedules to the maximal number of schedule\n+   dimensions (using '0's for the remaining values).  */\n+\n+__isl_give isl_map *\n+translate_isl_ast_to_gimple::extend_schedule (__isl_take isl_map *schedule,\n+\t\t\t\t\t      int nb_schedule_dims)\n+{\n+  int tmp_dims = isl_map_dim (schedule, isl_dim_out);\n+  schedule =\n+    isl_map_add_dims (schedule, isl_dim_out, nb_schedule_dims - tmp_dims);\n+  isl_val *zero =\n+    isl_val_int_from_si (isl_map_get_ctx (schedule), 0);\n+  int i;\n+  for (i = tmp_dims; i < nb_schedule_dims; i++)\n+    {\n+      schedule\n+\t= isl_map_fix_val (schedule, isl_dim_out, i, isl_val_copy (zero));\n+    }\n+  isl_val_free (zero);\n+  return schedule;\n+}\n+\n+/* Generates a schedule, which specifies an order used to\n+   visit elements in a domain.  */\n+\n+__isl_give isl_union_map *\n+translate_isl_ast_to_gimple::generate_isl_schedule (scop_p scop)\n+{\n+  int nb_schedule_dims = get_max_schedule_dimensions (scop);\n+  int i;\n+  poly_bb_p pbb;\n+  isl_union_map *schedule_isl =\n+    isl_union_map_empty (isl_set_get_space (scop->param_context));\n+\n+  FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)\n+    {\n+      /* Dead code elimination: when the domain of a PBB is empty,\n+\t don't generate code for the PBB.  */\n+      if (isl_set_is_empty (pbb->domain))\n+\tcontinue;\n+\n+      isl_map *bb_schedule = isl_map_copy (pbb->transformed);\n+      bb_schedule = isl_map_intersect_domain (bb_schedule,\n+\t\t\t\t\t      isl_set_copy (pbb->domain));\n+      bb_schedule = extend_schedule (bb_schedule, nb_schedule_dims);\n+      schedule_isl\n+\t= isl_union_map_union (schedule_isl,\n+\t\t\t       isl_union_map_from_map (bb_schedule));\n+    }\n+  return schedule_isl;\n+}\n+\n+/* This method is executed before the construction of a for node.  */\n+__isl_give isl_id *\n+ast_build_before_for (__isl_keep isl_ast_build *build, void *user)\n+{\n+  isl_union_map *dependences = (isl_union_map *) user;\n+  ast_build_info *for_info = XNEW (struct ast_build_info);\n+  isl_union_map *schedule = isl_ast_build_get_schedule (build);\n+  isl_space *schedule_space = isl_ast_build_get_schedule_space (build);\n+  int dimension = isl_space_dim (schedule_space, isl_dim_out);\n+  for_info->is_parallelizable =\n+    !carries_deps (schedule, dependences, dimension);\n+  isl_union_map_free (schedule);\n+  isl_space_free (schedule_space);\n+  isl_id *id = isl_id_alloc (isl_ast_build_get_ctx (build), \"\", for_info);\n+  return id;\n+}\n+\n+/* Set the separate option for all dimensions.\n+   This helps to reduce control overhead.  */\n+\n+__isl_give isl_ast_build *\n+translate_isl_ast_to_gimple::set_options (__isl_take isl_ast_build *control,\n+\t\t\t\t\t  __isl_keep isl_union_map *schedule)\n+{\n+  isl_ctx *ctx = isl_union_map_get_ctx (schedule);\n+  isl_space *range_space = isl_space_set_alloc (ctx, 0, 1);\n+  range_space =\n+    isl_space_set_tuple_name (range_space, isl_dim_set, \"separate\");\n+  isl_union_set *range =\n+    isl_union_set_from_set (isl_set_universe (range_space));\n+  isl_union_set *domain = isl_union_map_range (isl_union_map_copy (schedule));\n+  domain = isl_union_set_universe (domain);\n+  isl_union_map *options = isl_union_map_from_domain_and_range (domain, range);\n+  return isl_ast_build_set_options (control, options);\n+}\n+\n+/* Generate isl AST from schedule of SCOP.  Also, collects IVS_PARAMS in IP.  */\n+\n+__isl_give isl_ast_node *\n+translate_isl_ast_to_gimple::scop_to_isl_ast (scop_p scop, ivs_params &ip)\n+{\n+  /* Generate loop upper bounds that consist of the current loop iterator, an\n+     operator (< or <=) and an expression not involving the iterator.  If this\n+     option is not set, then the current loop iterator may appear several times\n+     in the upper bound.  See the isl manual for more details.  */\n+  isl_options_set_ast_build_atomic_upper_bound (scop->isl_context, true);\n+\n+  add_parameters_to_ivs_params (scop, ip);\n+  isl_union_map *schedule_isl = generate_isl_schedule (scop);\n+  isl_ast_build *context_isl = generate_isl_context (scop);\n+  context_isl = set_options (context_isl, schedule_isl);\n+  isl_union_map *dependences = NULL;\n+  if (flag_loop_parallelize_all)\n+    {\n+      dependences = scop_get_dependences (scop);\n+      context_isl =\n+\tisl_ast_build_set_before_each_for (context_isl, ast_build_before_for,\n+\t\t\t\t\t   dependences);\n+    }\n+  isl_ast_node *ast_isl = isl_ast_build_ast_from_schedule (context_isl,\n+\t\t\t\t\t\t\t   schedule_isl);\n+  if (dependences)\n+    isl_union_map_free (dependences);\n+  isl_ast_build_free (context_isl);\n+  return ast_isl;\n+}\n+\n+/* GIMPLE Loop Generator: generates loops from STMT in GIMPLE form for\n+   the given SCOP.  Return true if code generation succeeded.\n+\n+   FIXME: This is not yet a full implementation of the code generator\n+   with ISL ASTs.  Generation of GIMPLE code has to be completed.  */\n+\n+bool\n+graphite_regenerate_ast_isl (scop_p scop)\n+{\n+  sese_info_p region = scop->scop_info;\n+  translate_isl_ast_to_gimple t (region);\n+\n+  ifsese if_region = NULL;\n+  isl_ast_node *root_node;\n+  ivs_params ip;\n+\n+  timevar_push (TV_GRAPHITE_CODE_GEN);\n+  root_node = t.scop_to_isl_ast (scop, ip);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"\\nISL AST generated by ISL: \\n\");\n+      t.print_isl_ast_node (dump_file, root_node, scop->isl_context);\n+    }\n+\n+  recompute_all_dominators ();\n+  graphite_verify ();\n+\n+  if_region = move_sese_in_condition (region);\n+  region->if_region = if_region;\n+  recompute_all_dominators ();\n+\n+  loop_p context_loop = region->region.entry->src->loop_father;\n+\n+  edge e = single_succ_edge (if_region->true_region->region.entry->dest);\n+  basic_block bb = split_edge (e);\n \n-  translate_isl_ast_to_gimple t(region);\n-  edge e = single_succ_edge (if_region->true_region->region.entry->dest);\n-  basic_block bb = split_edge (e);\n   /* Update the true_region exit edge.  */\n   region->if_region->true_region->region.exit = single_succ_edge (bb);\n \n   t.translate_isl_ast (context_loop, root_node, e, ip);\n   if (t.codegen_error_p ())\n     {\n       if (dump_file)\n-\tfprintf (dump_file, \"\\n[codegen] unsuccessful, \"\n-\t\t \"reverting back to the original code.\");\n+\tfprintf (dump_file, \"\\n[codegen] unsuccessful,\"\n+\t\t \" reverting back to the original code.\");\n       set_ifsese_condition (if_region, integer_zero_node);\n     }\n   else\n@@ -1219,8 +2987,8 @@ graphite_regenerate_ast_isl (scop_p scop)\n \t  graphite_verify ();\n \t}\n       else if (dump_file)\n-\tfprintf (dump_file, \"\\n[codegen] unsuccessful in translating \"\n-\t\t \"pending phis, reverting back to the original code.\");\n+\tfprintf (dump_file, \"\\n[codegen] unsuccessful in translating\"\n+\t\t \" pending phis, reverting back to the original code.\");\n     }\n \n   free (if_region->true_region);\n@@ -1246,4 +3014,5 @@ graphite_regenerate_ast_isl (scop_p scop)\n \n   return !t.codegen_error_p ();\n }\n+\n #endif  /* HAVE_isl */"}, {"sha": "e42b9bf9c41c852d366a0b5657ba9d1339965a5c", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ecf4eca922c12a93918f2c4b7c3b3b962d63e98/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ecf4eca922c12a93918f2c4b7c3b3b962d63e98/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=2ecf4eca922c12a93918f2c4b7c3b3b962d63e98", "patch": "@@ -1717,9 +1717,9 @@ build_cross_bb_scalars_use (scop_p scop, tree use, gimple *use_stmt,\n   gimple *def_stmt = SSA_NAME_DEF_STMT (use);\n   if (gimple_bb (def_stmt) != gimple_bb (use_stmt))\n     {\n-      DEBUG_PRINT (dp << \"Adding scalar read:\\n\";\n+      DEBUG_PRINT (dp << \"\\nAdding scalar read:\";\n \t\t   print_generic_expr (dump_file, use, 0);\n-\t\t   dp << \"From stmt:\\n\";\n+\t\t   dp << \"\\nFrom stmt:\";\n \t\t   print_gimple_stmt (dump_file, use_stmt, 0, 0));\n       reads->safe_push (std::make_pair (use_stmt, use));\n     }"}, {"sha": "94fcc114499d6d951bbdbb718e3b94dc9aabdccd", "filename": "gcc/sese.c", "status": "modified", "additions": 34, "deletions": 1541, "changes": 1575, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ecf4eca922c12a93918f2c4b7c3b3b962d63e98/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ecf4eca922c12a93918f2c4b7c3b3b962d63e98/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=2ecf4eca922c12a93918f2c4b7c3b3b962d63e98", "patch": "@@ -25,14 +25,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"backend.h\"\n #include \"tree.h\"\n #include \"gimple.h\"\n-#include \"cfganal.h\"\n #include \"cfghooks.h\"\n #include \"tree-pass.h\"\n #include \"ssa.h\"\n #include \"tree-pretty-print.h\"\n #include \"fold-const.h\"\n-#include \"gimple-fold.h\"\n-#include \"tree-eh.h\"\n #include \"gimplify.h\"\n #include \"gimple-iterator.h\"\n #include \"gimple-pretty-print.h\"\n@@ -43,7 +40,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"tree-data-ref.h\"\n #include \"tree-scalar-evolution.h\"\n-#include \"value-prof.h\"\n #include \"sese.h\"\n #include \"tree-ssa-propagate.h\"\n \n@@ -178,7 +174,8 @@ sese_bad_liveouts_use (sese_info_p region, bitmap liveouts, basic_block bb,\n    are not marked as liveouts.  */\n \n static void\n-sese_reset_debug_liveouts_bb (sese_info_p region, bitmap liveouts, basic_block bb)\n+sese_reset_debug_liveouts_bb (sese_info_p region, bitmap liveouts,\n+\t\t\t      basic_block bb)\n {\n   gimple_stmt_iterator bsi;\n   ssa_op_iter iter;\n@@ -317,1541 +314,6 @@ sese_insert_phis_for_liveouts (sese_info_p region, basic_block bb,\n   update_ssa (TODO_update_ssa);\n }\n \n-/* Returns the first successor edge of BB with EDGE_TRUE_VALUE flag set.  */\n-\n-edge\n-get_true_edge_from_guard_bb (basic_block bb)\n-{\n-  edge e;\n-  edge_iterator ei;\n-\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    if (e->flags & EDGE_TRUE_VALUE)\n-      return e;\n-\n-  gcc_unreachable ();\n-  return NULL;\n-}\n-\n-/* Returns the first successor edge of BB with EDGE_TRUE_VALUE flag cleared.  */\n-\n-edge\n-get_false_edge_from_guard_bb (basic_block bb)\n-{\n-  edge e;\n-  edge_iterator ei;\n-\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    if (!(e->flags & EDGE_TRUE_VALUE))\n-      return e;\n-\n-  gcc_unreachable ();\n-  return NULL;\n-}\n-\n-/* Check if USE is defined in a basic block from where the definition of USE can\n- propagate from all the paths.  */\n-\n-static bool\n-is_loop_closed_ssa_use (basic_block bb, tree use)\n-{\n-  if (TREE_CODE (use) != SSA_NAME)\n-    return true;\n-\n-  /* We should not have a rename for virtual operands.  */\n-  gcc_assert (!virtual_operand_p (use));\n-\n-  /* For close-phi nodes def always comes from a loop which has a back-edge.  */\n-  if (bb_contains_loop_close_phi_nodes (bb))\n-    return true;\n-\n-  gimple *def = SSA_NAME_DEF_STMT (use);\n-  basic_block def_bb = gimple_bb (def);\n-  return (!def_bb\n-\t  || flow_bb_inside_loop_p (def_bb->loop_father, bb));\n-}\n-\n-/* Return the number of phi nodes in BB.  */\n-\n-static int\n-number_of_phi_nodes (basic_block bb)\n-{\n-  int num_phis = 0;\n-  for (gphi_iterator psi = gsi_start_phis (bb); !gsi_end_p (psi);\n-       gsi_next (&psi))\n-    num_phis++;\n-  return num_phis;\n-}\n-\n-/* Return true when BB contains loop close phi nodes.  */\n-\n-bool\n-bb_contains_loop_close_phi_nodes (basic_block bb)\n-{\n-  return single_pred_p (bb)\n-    && bb->loop_father != single_pred_edge (bb)->src->loop_father;\n-}\n-\n-/* Return true when BB contains loop phi nodes.  */\n-\n-bool\n-bb_contains_loop_phi_nodes (basic_block bb)\n-{\n-  gcc_assert (EDGE_COUNT (bb->preds) <= 2);\n-\n-  if (bb->preds->length () == 1)\n-    return false;\n-\n-  unsigned depth = loop_depth (bb->loop_father);\n-\n-  edge preds[2] = { (*bb->preds)[0], (*bb->preds)[1] };\n-\n-  if (depth > loop_depth (preds[0]->src->loop_father)\n-      || depth > loop_depth (preds[1]->src->loop_father))\n-    return true;\n-\n-  /* When one of the edges correspond to the same loop father and other\n-     doesn't.  */\n-  if (bb->loop_father != preds[0]->src->loop_father\n-      && bb->loop_father == preds[1]->src->loop_father)\n-    return true;\n-\n-  if (bb->loop_father != preds[1]->src->loop_father\n-      && bb->loop_father == preds[0]->src->loop_father)\n-    return true;\n-\n-  return false;\n-}\n-\n-/* Returns true if BB uses name in one of its PHIs.  */\n-\n-static bool\n-phi_uses_name (basic_block bb, tree name)\n-{\n-  for (gphi_iterator psi = gsi_start_phis (bb); !gsi_end_p (psi);\n-       gsi_next (&psi))\n-    {\n-      gphi *phi = psi.phi ();\n-      for (unsigned i = 0; i < gimple_phi_num_args (phi); i++)\n-\t{\n-\t  tree use_arg = gimple_phi_arg_def (phi, i);\n-\t  if (use_arg == name)\n-\t    return true;\n-\t}\n-    }\n-  return false;\n-}\n-\n-/* Return true if RENAME (defined in BB) is a valid use in NEW_BB.  The\n-definition should flow into use, and the use should respect the loop-closed SSA\n-form.  */\n-\n-static bool\n-is_valid_rename (tree rename, basic_block def_bb,\n-\t\t basic_block use_bb, bool loop_phi,\n-\t\t tree old_name, basic_block old_bb)\n-{\n-  /* The def of the rename must either dominate the uses or come from a\n-     back-edge.  Also the def must respect the loop closed ssa form.  */\n-  if (!is_loop_closed_ssa_use (use_bb, rename))\n-    {\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"\\n[codegen] rename not in loop closed ssa:\");\n-\t  print_generic_expr (dump_file, rename, 0);\n-\t}\n-      return false;\n-    }\n-\n-  if (dominated_by_p (CDI_DOMINATORS, use_bb, def_bb))\n-    return true;\n-\n-  if (bb_contains_loop_phi_nodes (use_bb) && loop_phi)\n-    {\n-      /* The loop-header dominates the loop-body.  */\n-      if (!dominated_by_p (CDI_DOMINATORS, def_bb, use_bb))\n-\treturn false;\n-\n-      /* RENAME would be used in loop-phi.  */\n-      gcc_assert (number_of_phi_nodes (use_bb));\n-\n-      /* For definitions coming from back edges, we should check that\n-\t old_name is used in a loop PHI node.  */\n-      if (phi_uses_name (old_bb, old_name))\n-\treturn true;\n-    }\n-  return false;\n-}\n-\n-/* Returns the expression associated to OLD_NAME (which is used in OLD_BB), in\n-   NEW_BB from RENAME_MAP.  LOOP_PHI is true when we want to rename OLD_NAME\n-   within a loop PHI instruction.  */\n-\n-static tree\n-get_rename (rename_map_t *rename_map, basic_block new_bb, tree old_name,\n-\t    basic_block old_bb, bool loop_phi)\n-{\n-  gcc_assert (TREE_CODE (old_name) == SSA_NAME);\n-  vec <tree> *renames = rename_map->get (old_name);\n-\n-  if (!renames || renames->is_empty ())\n-    return NULL_TREE;\n-\n-  if (1 == renames->length ())\n-    {\n-      tree rename = (*renames)[0];\n-      basic_block bb = gimple_bb (SSA_NAME_DEF_STMT (rename));\n-      if (is_valid_rename (rename, bb, new_bb, loop_phi, old_name, old_bb))\n-\treturn rename;\n-      return NULL_TREE;\n-    }\n-\n-  /* More than one renames corresponding to the old_name.  Find the rename for\n-     which the definition flows into usage at new_bb.  */\n-  int i;\n-  tree t1 = NULL_TREE, t2;\n-  basic_block t1_bb = NULL;\n-  FOR_EACH_VEC_ELT (*renames, i, t2)\n-    {\n-      basic_block t2_bb = gimple_bb (SSA_NAME_DEF_STMT (t2));\n-\n-      /* Defined in the same basic block as used.  */\n-      if (t2_bb == new_bb)\n-\treturn t2;\n-\n-      /* NEW_BB and T2_BB are in two unrelated if-clauses.  */\n-      if (!dominated_by_p (CDI_DOMINATORS, new_bb, t2_bb))\n-\tcontinue;\n-\n-      /* Compute the nearest dominator.  */\n-      if (!t1 || dominated_by_p (CDI_DOMINATORS, t2_bb, t1_bb))\n-\t{\n-\t  t1_bb = t2_bb;\n-\t  t1 = t2;\n-\t}\n-      //if (is_valid_rename (rename, bb, new_bb, loop_phi, old_name, old_bb))\n-      //return rename;\n-    }\n-\n-  return t1;\n-}\n-\n-/* Register in RENAME_MAP the rename tuple (OLD_NAME, EXPR).\n-   When OLD_NAME and EXPR are the same we assert.  */\n-\n-static void\n-set_rename (tree old_name, tree expr, sese_info_p region)\n-{\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"\\n[codegen] setting rename: old_name = \");\n-      print_generic_expr (dump_file, old_name, 0);\n-      fprintf (dump_file, \", new_name = \");\n-      print_generic_expr (dump_file, expr, 0);\n-    }\n-\n-  if (old_name == expr)\n-    return;\n-\n-  vec <tree> *renames = region->rename_map->get (old_name);\n-\n-  if (renames)\n-    renames->safe_push (expr);\n-  else\n-    {\n-      vec<tree> r;\n-      r.create (2);\n-      r.safe_push (expr);\n-      region->rename_map->put (old_name, r);\n-    }\n-}\n-\n-/* Return an iterator to the instructions comes\n-   last in the execution order.  Either GSI1 and GSI2 should belong\n-   to the same basic block or one of their respective basic blocks\n-   should dominate the other.  */\n-\n-gimple_stmt_iterator\n-later_of_the_two (gimple_stmt_iterator gsi1, gimple_stmt_iterator gsi2)\n-{\n-  basic_block bb1 = gsi_bb (gsi1);\n-  basic_block bb2 = gsi_bb (gsi2);\n-\n-  /* Find the iterator which is the latest.  */\n-  if (bb1 == bb2)\n-    {\n-      /* For empty basic blocks gsis point to the end of the sequence.  Since\n-\t there is no operator== defined for gimple_stmt_iterator and for gsis\n-\t not pointing to a valid statement gsi_next would assert.  */\n-      gimple_stmt_iterator gsi = gsi1;\n-      do {\n-\tif (gsi_stmt (gsi) == gsi_stmt (gsi2))\n-\t  return gsi2;\n-\tgsi_next (&gsi);\n-      } while (!gsi_end_p (gsi));\n-\n-      return gsi1;\n-    }\n-\n-  /* Find the basic block closest to the basic block which defines stmt.  */\n-  if (dominated_by_p (CDI_DOMINATORS, bb1, bb2))\n-    return gsi1;\n-\n-  gcc_assert (dominated_by_p (CDI_DOMINATORS, bb2, bb1));\n-  return gsi2;\n-}\n-\n-/* Insert each statement from SEQ at its earliest insertion p.  */\n-\n-static void\n-gsi_insert_earliest (gimple_seq seq, sese_info_p region)\n-{\n-  update_modified_stmts (seq);\n-  sese_l &codegen_region = region->if_region->true_region->region;\n-  basic_block begin_bb = get_entry_bb (codegen_region);\n-\n-  /* Inserting the gimple statements in a vector because gimple_seq behave\n-     in strage ways when inserting the stmts from it into different basic\n-     blocks one at a time.  */\n-  auto_vec<gimple *, 3> stmts;\n-  for (gimple_stmt_iterator gsi = gsi_start (seq); !gsi_end_p (gsi);\n-       gsi_next (&gsi))\n-    stmts.safe_push (gsi_stmt (gsi));\n-\n-  int i;\n-  gimple *use_stmt;\n-  FOR_EACH_VEC_ELT (stmts, i, use_stmt)\n-    {\n-      gcc_assert (gimple_code (use_stmt) != GIMPLE_PHI);\n-      gimple_stmt_iterator gsi_def_stmt = gsi_start_bb_nondebug (begin_bb);\n-\n-      use_operand_p use_p;\n-      ssa_op_iter op_iter;\n-      FOR_EACH_SSA_USE_OPERAND (use_p, use_stmt, op_iter, SSA_OP_USE)\n-\t{\n-\t  /* Iterator to the current def of use_p.  For function parameters or\n-\t     anything where def is not found, insert at the beginning of the\n-\t     generated region.  */\n-\t  gimple_stmt_iterator gsi_stmt = gsi_def_stmt;\n-\n-\t  tree op = USE_FROM_PTR (use_p);\n-\t  gimple *stmt = SSA_NAME_DEF_STMT (op);\n-\t  if (stmt && (gimple_code (stmt) != GIMPLE_NOP))\n-\t    gsi_stmt = gsi_for_stmt (stmt);\n-\n-\t  /* For region parameters, insert at the beginning of the generated\n-\t     region.  */\n-\t  if (!bb_in_sese_p (gsi_bb (gsi_stmt), codegen_region))\n-\t    {\n-\t      /* The parameter should have been inserted in the parameter\n-\t\t map or it must have a scev.  */\n-\t      gsi_stmt = gsi_def_stmt;\n-\t    }\n-\n-\t  gsi_def_stmt = later_of_the_two (gsi_stmt, gsi_def_stmt);\n-\t}\n-\n-      if (!gsi_stmt (gsi_def_stmt))\n-\t{\n-\t  gimple_stmt_iterator gsi = gsi_after_labels (gsi_bb (gsi_def_stmt));\n-\t  gsi_insert_before (&gsi, use_stmt, GSI_NEW_STMT);\n-\t}\n-      else if (gimple_code (gsi_stmt (gsi_def_stmt)) == GIMPLE_PHI)\n-\t{\n-\t  gimple_stmt_iterator bsi\n-\t    = gsi_start_bb_nondebug (gsi_bb (gsi_def_stmt));\n-\t  /* Insert right after the PHI statements.  */\n-\t  gsi_insert_before (&bsi, use_stmt, GSI_NEW_STMT);\n-\t}\n-      else\n-\tgsi_insert_after (&gsi_def_stmt, use_stmt, GSI_NEW_STMT);\n-\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"\\n[codegen] inserting statement: \");\n-\t  print_gimple_stmt (dump_file, use_stmt, 0, TDF_VOPS | TDF_MEMSYMS);\n-\t  print_loops_bb (dump_file, gimple_bb (use_stmt), 0, 3);\n-\t}\n-    }\n-}\n-\n-/* Collect all the operands of NEW_EXPR by recursively visiting each\n-   operand.  */\n-\n-static void\n-collect_all_ssa_names (tree new_expr, vec<tree> *vec_ssa, sese_info_p region)\n-{\n-\n-  /* Rename all uses in new_expr.  */\n-  if (TREE_CODE (new_expr) == SSA_NAME)\n-    {\n-      vec_ssa->safe_push (new_expr);\n-      return;\n-    }\n-\n-  /* Iterate over SSA_NAMES in NEW_EXPR.  */\n-  for (int i = 0; i < (TREE_CODE_LENGTH (TREE_CODE (new_expr))); i++)\n-    {\n-      tree op = TREE_OPERAND (new_expr, i);\n-      collect_all_ssa_names (op, vec_ssa, region);\n-    }\n-}\n-\n-static tree\n-substitute_ssa_name (tree exp, tree f, tree r)\n-{\n-  enum tree_code code = TREE_CODE (exp);\n-  tree op0, op1, op2, op3;\n-  tree new_tree;\n-\n-  /* We handle TREE_LIST and COMPONENT_REF separately.  */\n-  if (code == TREE_LIST)\n-    {\n-      op0 = substitute_ssa_name (TREE_CHAIN (exp), f, r);\n-      op1 = substitute_ssa_name (TREE_VALUE (exp), f, r);\n-      if (op0 == TREE_CHAIN (exp) && op1 == TREE_VALUE (exp))\n-\treturn exp;\n-\n-      return tree_cons (TREE_PURPOSE (exp), op1, op0);\n-    }\n-  else if (code == COMPONENT_REF)\n-    {\n-      tree inner;\n-\n-      /* If this expression is getting a value from a PLACEHOLDER_EXPR\n-\t and it is the right field, replace it with R.  */\n-      for (inner = TREE_OPERAND (exp, 0);\n-\t   REFERENCE_CLASS_P (inner);\n-\t   inner = TREE_OPERAND (inner, 0))\n-\t;\n-\n-      /* The field.  */\n-      op1 = TREE_OPERAND (exp, 1);\n-\n-      if (TREE_CODE (inner) == PLACEHOLDER_EXPR && op1 == f)\n-\treturn r;\n-\n-      /* If this expression hasn't been completed let, leave it alone.  */\n-      if (TREE_CODE (inner) == PLACEHOLDER_EXPR && !TREE_TYPE (inner))\n-\treturn exp;\n-\n-      op0 = substitute_ssa_name (TREE_OPERAND (exp, 0), f, r);\n-      if (op0 == TREE_OPERAND (exp, 0))\n-\treturn exp;\n-\n-      new_tree\n-\t= fold_build3 (COMPONENT_REF, TREE_TYPE (exp), op0, op1, NULL_TREE);\n-   }\n-  else\n-    switch (TREE_CODE_CLASS (code))\n-      {\n-      case tcc_constant:\n-\treturn exp;\n-\n-      case tcc_declaration:\n-\tif (exp == f)\n-\t  return r;\n-\telse\n-\t  return exp;\n-\n-      case tcc_expression:\n-\tif (exp == f)\n-\t  return r;\n-\n-\t/* Fall through...  */\n-\n-      case tcc_exceptional:\n-      case tcc_unary:\n-      case tcc_binary:\n-      case tcc_comparison:\n-      case tcc_reference:\n-\tswitch (TREE_CODE_LENGTH (code))\n-\t  {\n-\t  case 0:\n-\t    if (exp == f)\n-\t      return r;\n-\t    return exp;\n-\n-\t  case 1:\n-\t    op0 = substitute_ssa_name (TREE_OPERAND (exp, 0), f, r);\n-\t    if (op0 == TREE_OPERAND (exp, 0))\n-\t      return exp;\n-\n-\t    new_tree = fold_build1 (code, TREE_TYPE (exp), op0);\n-\t    break;\n-\n-\t  case 2:\n-\t    op0 = substitute_ssa_name (TREE_OPERAND (exp, 0), f, r);\n-\t    op1 = substitute_ssa_name (TREE_OPERAND (exp, 1), f, r);\n-\n-\t    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1))\n-\t      return exp;\n-\n-\t    new_tree = fold_build2 (code, TREE_TYPE (exp), op0, op1);\n-\t    break;\n-\n-\t  case 3:\n-\t    op0 = substitute_ssa_name (TREE_OPERAND (exp, 0), f, r);\n-\t    op1 = substitute_ssa_name (TREE_OPERAND (exp, 1), f, r);\n-\t    op2 = substitute_ssa_name (TREE_OPERAND (exp, 2), f, r);\n-\n-\t    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1)\n-\t\t&& op2 == TREE_OPERAND (exp, 2))\n-\t      return exp;\n-\n-\t    new_tree = fold_build3 (code, TREE_TYPE (exp), op0, op1, op2);\n-\t    break;\n-\n-\t  case 4:\n-\t    op0 = substitute_ssa_name (TREE_OPERAND (exp, 0), f, r);\n-\t    op1 = substitute_ssa_name (TREE_OPERAND (exp, 1), f, r);\n-\t    op2 = substitute_ssa_name (TREE_OPERAND (exp, 2), f, r);\n-\t    op3 = substitute_ssa_name (TREE_OPERAND (exp, 3), f, r);\n-\n-\t    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1)\n-\t\t&& op2 == TREE_OPERAND (exp, 2)\n-\t\t&& op3 == TREE_OPERAND (exp, 3))\n-\t      return exp;\n-\n-\t    new_tree\n-\t      = fold (build4 (code, TREE_TYPE (exp), op0, op1, op2, op3));\n-\t    break;\n-\n-\t  default:\n-\t    gcc_unreachable ();\n-\t  }\n-\tbreak;\n-\n-      case tcc_vl_exp:\n-      default:\n-\tgcc_unreachable ();\n-      }\n-\n-  TREE_READONLY (new_tree) |= TREE_READONLY (exp);\n-\n-  if (code == INDIRECT_REF || code == ARRAY_REF || code == ARRAY_RANGE_REF)\n-    TREE_THIS_NOTRAP (new_tree) |= TREE_THIS_NOTRAP (exp);\n-\n-  return new_tree;\n-}\n-\n-/* Rename all the operands of NEW_EXPR by recursively visiting each operand.  */\n-\n-static tree\n-rename_all_uses (tree new_expr, basic_block new_bb, basic_block old_bb,\n-\t\t sese_info_p region)\n-{\n-  vec<tree> ssa_names;\n-  ssa_names.create (2);\n-  collect_all_ssa_names (new_expr, &ssa_names, region);\n-  tree t;\n-  int i;\n-  FOR_EACH_VEC_ELT (ssa_names, i, t)\n-    {\n-      if (tree r = get_rename (region->rename_map, new_bb, t, old_bb, false))\n-\tnew_expr = substitute_ssa_name (new_expr, t, r);\n-      /* else\n-\t return NULL_TREE;*/\n-    }\n-\n-  return new_expr;\n-}\n-\n-static tree\n-get_rename_from_scev (tree old_name, gimple_seq *stmts, loop_p loop,\n-\t\t      basic_block new_bb, basic_block old_bb,\n-\t\t      vec<tree> iv_map, sese_info_p region, bool *gloog_error)\n-{\n-  tree scev = scalar_evolution_in_region (region->region, loop, old_name);\n-\n-  /* At this point we should know the exact scev for each\n-     scalar SSA_NAME used in the scop: all the other scalar\n-     SSA_NAMEs should have been translated out of SSA using\n-     arrays with one element.  */\n-  tree new_expr;\n-  if (chrec_contains_undetermined (scev))\n-    {\n-      *gloog_error = true;\n-      return build_zero_cst (TREE_TYPE (old_name));\n-    }\n-\n-    new_expr = chrec_apply_map (scev, iv_map);\n-\n-  /* The apply should produce an expression tree containing\n-     the uses of the new induction variables.  We should be\n-     able to use new_expr instead of the old_name in the newly\n-     generated loop nest.  */\n-  if (chrec_contains_undetermined (new_expr)\n-      || tree_contains_chrecs (new_expr, NULL))\n-    {\n-      *gloog_error = true;\n-      return build_zero_cst (TREE_TYPE (old_name));\n-    }\n-\n-  new_expr = rename_all_uses (new_expr, new_bb, old_bb, region);\n-\n-  /* Replace the old_name with the new_expr.  */\n-  return force_gimple_operand (unshare_expr (new_expr), stmts,\n-\t\t\t       true, NULL_TREE);\n-}\n-\n-/* Renames the scalar uses of the statement COPY, using the\n-   substitution map RENAME_MAP, inserting the gimplification code at\n-   GSI_TGT, for the translation REGION, with the original copied\n-   statement in LOOP, and using the induction variable renaming map\n-   IV_MAP.  Returns true when something has been renamed.  GLOOG_ERROR\n-   is set when the code generation cannot continue.  */\n-\n-static bool\n-rename_uses (gimple *copy, gimple_stmt_iterator *gsi_tgt,\n-\t     basic_block old_bb, sese_info_p region,\n-\t     loop_p loop, vec<tree> iv_map, bool *gloog_error)\n-{\n-  bool changed = false;\n-\n-  if (is_gimple_debug (copy))\n-    {\n-      if (gimple_debug_bind_p (copy))\n-\tgimple_debug_bind_reset_value (copy);\n-      else if (gimple_debug_source_bind_p (copy))\n-\treturn false;\n-      else\n-\tgcc_unreachable ();\n-\n-      return false;\n-    }\n-\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"\\n[codegen] renaming uses of stmt: \");\n-      print_gimple_stmt (dump_file, copy, 0, 0);\n-    }\n-\n-  use_operand_p use_p;\n-  ssa_op_iter op_iter;\n-  FOR_EACH_SSA_USE_OPERAND (use_p, copy, op_iter, SSA_OP_USE)\n-    {\n-      tree old_name = USE_FROM_PTR (use_p);\n-\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"\\n[codegen] renaming old_name = \");\n-\t  print_generic_expr (dump_file, old_name, 0);\n-\t}\n-\n-      if (TREE_CODE (old_name) != SSA_NAME\n-\t  || SSA_NAME_IS_DEFAULT_DEF (old_name))\n-\tcontinue;\n-\n-      changed = true;\n-      tree new_expr = get_rename (region->rename_map, gsi_tgt->bb, old_name,\n-\t\t\t\t  old_bb, false);\n-\n-      if (new_expr)\n-\t{\n-\t  tree type_old_name = TREE_TYPE (old_name);\n-\t  tree type_new_expr = TREE_TYPE (new_expr);\n-\n-\t  if (dump_file)\n-\t    {\n-\t      fprintf (dump_file, \"\\n[codegen] from rename_map: new_name = \");\n-\t      print_generic_expr (dump_file, new_expr, 0);\n-\t    }\n-\n-\t  if (type_old_name != type_new_expr\n-\t      || TREE_CODE (new_expr) != SSA_NAME)\n-\t    {\n-\t      tree var = create_tmp_var (type_old_name, \"var\");\n-\n-\t      if (!useless_type_conversion_p (type_old_name, type_new_expr))\n-\t\tnew_expr = fold_convert (type_old_name, new_expr);\n-\n-\t      gimple_seq stmts;\n-\t      new_expr = force_gimple_operand (new_expr, &stmts, true, var);\n-\t      gsi_insert_earliest (stmts, region);\n-\t    }\n-\n-\t  replace_exp (use_p, new_expr);\n-\t  continue;\n-\t}\n-\n-      gimple_seq stmts;\n-      new_expr = get_rename_from_scev (old_name, &stmts, loop, gimple_bb (copy),\n-\t\t\t\t       old_bb, iv_map, region, gloog_error);\n-      if (!new_expr || *gloog_error)\n-\treturn false;\n-\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"\\n[codegen] not in rename map, scev: \");\n-\t  print_generic_expr (dump_file, new_expr, 0);\n-\t}\n-\n-      gsi_insert_earliest (stmts, region);\n-      replace_exp (use_p, new_expr);\n-\n-      if (TREE_CODE (new_expr) == INTEGER_CST\n-\t  && is_gimple_assign (copy))\n-\t{\n-\t  tree rhs = gimple_assign_rhs1 (copy);\n-\n-\t  if (TREE_CODE (rhs) == ADDR_EXPR)\n-\t    recompute_tree_invariant_for_addr_expr (rhs);\n-\t}\n-\n-      set_rename (old_name, new_expr, region);\n-    }\n-\n-  return changed;\n-}\n-\n-/* Returns a basic block that could correspond to where a constant was defined\n-   in the original code.  In the original code OLD_BB had the definition, we\n-   need to find which basic block out of the copies of old_bb, in the new\n-   region, should a definition correspond to if it has to reach BB.  */\n-\n-static basic_block\n-get_def_bb_for_const (sese_info_p region, basic_block bb, basic_block old_bb)\n-{\n-  vec <basic_block> *bbs = region->copied_bb_map->get (old_bb);\n-\n-  if (!bbs || bbs->is_empty ())\n-    return NULL;\n-\n-  if (1 == bbs->length ())\n-    return (*bbs)[0];\n-\n-  int i;\n-  basic_block b1 = NULL, b2;\n-  FOR_EACH_VEC_ELT (*bbs, i, b2)\n-    {\n-      if (b2 == bb)\n-\treturn bb;\n-\n-      /* BB and B2 are in two unrelated if-clauses.  */\n-      if (!dominated_by_p (CDI_DOMINATORS, bb, b2))\n-\tcontinue;\n-\n-      /* Compute the nearest dominator.  */\n-      if (!b1 || dominated_by_p (CDI_DOMINATORS, b2, b1))\n-\tb1 = b2;\n-    }\n-\n-  gcc_assert (b1);\n-  return b1;\n-}\n-\n-/* LOOP_PHI is true when we want to rename an OP within a loop PHI\n-   instruction.  */\n-\n-static tree\n-get_new_name (sese_info_p region, basic_block new_bb, tree op,\n-\t      basic_block old_bb, bool loop_phi)\n-{\n-  if (TREE_CODE (op) == INTEGER_CST\n-      || TREE_CODE (op) == REAL_CST\n-      || TREE_CODE (op) == COMPLEX_CST\n-      || TREE_CODE (op) == VECTOR_CST)\n-    return op;\n-\n-  return get_rename (region->rename_map, new_bb, op, old_bb, loop_phi);\n-}\n-\n-/* Return a debug location for OP.  */\n-\n-static location_t\n-get_loc (tree op)\n-{\n-  location_t loc = UNKNOWN_LOCATION;\n-\n-  if (TREE_CODE (op) == SSA_NAME)\n-    loc = gimple_location (SSA_NAME_DEF_STMT (op));\n-  return loc;\n-}\n-\n-/* Returns the incoming edges of basic_block BB in the pair.  The first edge is\n-   the init edge (from outside the loop) and the second one is the back edge\n-   from the same loop.  */\n-\n-std::pair<edge, edge>\n-get_edges (basic_block bb)\n-{\n-  std::pair<edge, edge> edges;\n-  edge e;\n-  edge_iterator ei;\n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    if (bb->loop_father != e->src->loop_father)\n-      edges.first = e;\n-    else\n-      edges.second = e;\n-  return edges;\n-}\n-\n-/* Copy the PHI arguments from OLD_PHI to the NEW_PHI.  The arguments to NEW_PHI\n-   must be found unless they can be POSTPONEd for later.  */\n-\n-void\n-copy_loop_phi_args (gphi *old_phi, init_back_edge_pair_t &ibp_old_bb,\n-\t\t    gphi *new_phi, init_back_edge_pair_t &ibp_new_bb,\n-\t\t    sese_info_p region, bool postpone)\n-{\n-  gcc_assert (gimple_phi_num_args (old_phi) == gimple_phi_num_args (new_phi));\n-\n-  basic_block new_bb = gimple_bb (new_phi);\n-  for (unsigned i = 0; i < gimple_phi_num_args (old_phi); i++)\n-    {\n-      edge e;\n-      if (gimple_phi_arg_edge (old_phi, i) == ibp_old_bb.first)\n-\te = ibp_new_bb.first;\n-      else\n-\te = ibp_new_bb.second;\n-\n-      tree old_name = gimple_phi_arg_def (old_phi, i);\n-      tree new_name = get_new_name (region, new_bb, old_name,\n-\t\t\t\t    gimple_bb (old_phi), true);\n-      if (new_name)\n-\t{\n-\t  add_phi_arg (new_phi, new_name, e, get_loc (old_name));\n-\t  continue;\n-\t}\n-\n-      gimple *old_def_stmt = SSA_NAME_DEF_STMT (old_name);\n-      if (!old_def_stmt || gimple_code (old_def_stmt) == GIMPLE_NOP)\n-      /* If the phi arg was a function arg, or wasn't defined, just use the old\n-\t name.  */\n-\tadd_phi_arg (new_phi, old_name, e, get_loc (old_name));\n-      else if (postpone)\n-\t{\n-\t  /* Postpone code gen for later for those back-edges we don't have the\n-\t     names yet.  */\n-\t  region->incomplete_phis.safe_push (std::make_pair (old_phi, new_phi));\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"\\n[codegen] postpone loop phi nodes: \");\n-\t}\n-      else\n-\t/* Either we should add the arg to phi or, we should postpone.  */\n-\tgcc_unreachable ();\n-    }\n-}\n-\n-/* Copy loop phi nodes from BB to NEW_BB.  */\n-\n-static bool\n-copy_loop_phi_nodes (basic_block bb, basic_block new_bb, sese_info_p region)\n-{\n-  if (dump_file)\n-    fprintf (dump_file, \"\\n[codegen] copying loop phi nodes in bb_%d.\",\n-\t     new_bb->index);\n-\n-  /* Loop phi nodes should have only two arguments.  */\n-  gcc_assert (2 == EDGE_COUNT (bb->preds));\n-\n-  /* First edge is the init edge and second is the back edge.  */\n-  init_back_edge_pair_t ibp_old_bb = get_edges (bb);\n-\n-  /* First edge is the init edge and second is the back edge.  */\n-  init_back_edge_pair_t ibp_new_bb = get_edges (new_bb);\n-\n-  for (gphi_iterator psi = gsi_start_phis (bb); !gsi_end_p (psi);\n-       gsi_next (&psi))\n-    {\n-      gphi *phi = psi.phi ();\n-      tree res = gimple_phi_result (phi);\n-      if (virtual_operand_p (res))\n-\tcontinue;\n-      if (is_gimple_reg (res) && scev_analyzable_p (res, region->region))\n-\tcontinue;\n-\n-      gphi *new_phi = create_phi_node (SSA_NAME_VAR (res), new_bb);\n-      tree new_res = create_new_def_for (res, new_phi,\n-\t\t\t\t\t gimple_phi_result_ptr (new_phi));\n-      set_rename (res, new_res, region);\n-      copy_loop_phi_args (phi, ibp_old_bb, new_phi, ibp_new_bb, region, true);\n-      update_stmt (new_phi);\n-    }\n-\n-  return true;\n-}\n-\n-/* Return the init value of PHI, the value coming from outside the loop.  */\n-\n-static tree\n-get_loop_init_value (gphi *phi)\n-{\n-\n-  loop_p loop = gimple_bb (phi)->loop_father;\n-\n-  edge e;\n-  edge_iterator ei;\n-  FOR_EACH_EDGE (e, ei, gimple_bb (phi)->preds)\n-    if (e->src->loop_father != loop)\n-      return gimple_phi_arg_def (phi, e->dest_idx);\n-\n-  return NULL_TREE;\n-}\n-\n-/* Find the init value (the value which comes from outside the loop), of one of\n-   the operands of DEF which is defined by a loop phi.  */\n-\n-static tree\n-find_init_value (gimple *def)\n-{\n-  if (gimple_code (def) == GIMPLE_PHI)\n-    return get_loop_init_value (as_a <gphi*> (def));\n-\n-  if (gimple_vuse (def))\n-    return NULL_TREE;\n-\n-  ssa_op_iter iter;\n-  use_operand_p use_p;\n-  FOR_EACH_SSA_USE_OPERAND (use_p, def, iter, SSA_OP_USE)\n-    {\n-      tree use = USE_FROM_PTR (use_p);\n-      if (TREE_CODE (use) == SSA_NAME)\n-\t{\n-\t  if (tree res = find_init_value (SSA_NAME_DEF_STMT (use)))\n-\t    return res;\n-\t}\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Return the init value, the value coming from outside the loop.  */\n-\n-static tree\n-find_init_value_close_phi (gphi *phi)\n-{\n-  gcc_assert (gimple_phi_num_args (phi) == 1);\n-  tree use_arg = gimple_phi_arg_def (phi, 0);\n-  gimple *def = SSA_NAME_DEF_STMT (use_arg);\n-  return find_init_value (def);\n-}\n-\n-/* Copy all the loop-close phi args from BB to NEW_BB.  */\n-\n-bool\n-copy_loop_close_phi_args (basic_block old_bb, basic_block new_bb,\n-\t\t\t  sese_info_p region, bool postpone)\n-{\n-  /* The successor of bb having close phi should be a merge of the diamond\n-     inserted to guard the loop during codegen.  */\n-  basic_block close_phi_merge_bb = single_succ (new_bb);\n-\n-  for (gphi_iterator psi = gsi_start_phis (old_bb); !gsi_end_p (psi);\n-       gsi_next (&psi))\n-    {\n-      gphi *phi = psi.phi ();\n-      tree res = gimple_phi_result (phi);\n-      if (virtual_operand_p (res))\n-\tcontinue;\n-\n-      if (is_gimple_reg (res) && scev_analyzable_p (res, region->region))\n-\t/* Loop close phi nodes should not be scev_analyzable_p.  */\n-\tgcc_unreachable ();\n-\n-      gphi *new_phi = create_phi_node (SSA_NAME_VAR (res), new_bb);\n-      tree new_res = create_new_def_for (res, new_phi,\n-\t\t\t\t\t gimple_phi_result_ptr (new_phi));\n-      set_rename (res, new_res, region);\n-\n-      tree old_name = gimple_phi_arg_def (phi, 0);\n-      tree new_name = get_new_name (region, new_bb, old_name, old_bb, false);\n-\n-      /* Predecessor basic blocks of a loop close phi should have been code\n-\t generated before.  FIXME: This is fixable by merging PHIs from inner\n-\t loops as well.  When we are looking at close-phi of an outer loop, and\n-\t arguments flowing out of inner loop as not been collected by the\n-\t outer-loop close phi, we will hit this situation.  For now we just bail\n-\t out.  See: gfortran.dg/graphite/interchange-3.f90.  */\n-      if (!new_name)\n-\treturn false;\n-\n-      add_phi_arg (new_phi, new_name, single_pred_edge (new_bb),\n-\t\t   get_loc (old_name));\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"\\n[codegen] Adding loop-closed phi: \");\n-\t  print_gimple_stmt (dump_file, new_phi, 0, 0);\n-\t}\n-\n-      update_stmt (new_phi);\n-\n-      /* When there is no loop guard around this codegenerated loop, there is no\n-\t need to collect the close-phi arg.  */\n-      if (2 != EDGE_COUNT (close_phi_merge_bb->preds))\n-\tcontinue;\n-\n-      /* Add a PHI in the close_phi_merge_bb for each close phi of the loop.  */\n-      tree init = find_init_value_close_phi (new_phi);\n-\n-      /* A close phi must come from a loop-phi having an init value.  */\n-      if (!init)\n-\t{\n-\t  gcc_assert (postpone);\n-\t  region->incomplete_phis.safe_push (std::make_pair (phi, new_phi));\n-\t  if (dump_file)\n-\t    {\n-\t      fprintf (dump_file, \"\\n[codegen] postpone close phi nodes: \");\n-\t      print_gimple_stmt (dump_file, new_phi, 0, 0);\n-\t    }\n-\t  continue;\n-\t}\n-\n-      gphi *merge_phi = create_phi_node (SSA_NAME_VAR (res),\n-\t\t\t\t\t close_phi_merge_bb);\n-      tree merge_res = create_new_def_for (res, merge_phi,\n-\t\t\t\t\t   gimple_phi_result_ptr (merge_phi));\n-      set_rename (res, merge_res, region);\n-\n-      edge from_loop = single_succ_edge (new_bb);\n-      add_phi_arg (merge_phi, new_res, from_loop, get_loc (old_name));\n-\n-      /* The edge coming from loop guard.  */\n-      edge other = from_loop == (*close_phi_merge_bb->preds)[0]\n-\t? (*close_phi_merge_bb->preds)[1] : (*close_phi_merge_bb->preds)[0];\n-\n-      add_phi_arg (merge_phi, init, other, get_loc (old_name));\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"\\n[codegen] Adding guard-phi: \");\n-\t  print_gimple_stmt (dump_file, merge_phi, 0, 0);\n-\t}\n-\n-      update_stmt (new_phi);\n-    }\n-\n-  return true;\n-}\n-\n-/* Copy loop close phi nodes from BB to NEW_BB.  */\n-\n-static bool\n-copy_loop_close_phi_nodes (basic_block old_bb, basic_block new_bb,\n-\t\t\t   sese_info_p region)\n-{\n-  if (dump_file)\n-    fprintf (dump_file, \"\\n[codegen] copying loop closed phi nodes in bb_%d.\",\n-\t     new_bb->index);\n-  /* Loop close phi nodes should have only one argument.  */\n-  gcc_assert (1 == EDGE_COUNT (old_bb->preds));\n-\n-  return copy_loop_close_phi_args (old_bb, new_bb, region, true);\n-}\n-\n-\n-/* Add NEW_NAME as the ARGNUM-th arg of NEW_PHI which is in NEW_BB.\n-   DOMINATING_PRED is the predecessor basic block of OLD_BB which dominates the\n-   other pred of OLD_BB as well.  If no such basic block exists then it is NULL.\n-   NON_DOMINATING_PRED is a pred which does not dominate OLD_BB, it cannot be\n-   NULL.\n-\n-   Case1: OLD_BB->preds {BB1, BB2} and BB1 does not dominate BB2 and vice versa.\n-   In this case DOMINATING_PRED = NULL.\n-\n-   Case2: OLD_BB->preds {BB1, BB2} and BB1 dominates BB2.\n-\n-   Returns true on successful copy of the args, false otherwise.  */\n-\n-static bool\n-add_phi_arg_for_new_expr (tree old_phi_args[2], tree new_phi_args[2],\n-\t\t\t  edge old_bb_dominating_edge,\n-\t\t\t  edge old_bb_non_dominating_edge,\n-\t\t\t  gphi *phi, gphi *new_phi,\n-\t\t\t  basic_block new_bb, sese_info_p region)\n-{\n-  basic_block def_pred[2];\n-  int not_found_bb_index = -1;\n-  for (int i = 0; i < 2; i++)\n-    {\n-      /* If the corresponding def_bb could not be found the entry will be\n-\t NULL.  */\n-      if (TREE_CODE (old_phi_args[i]) == INTEGER_CST)\n-\tdef_pred[i] = get_def_bb_for_const (region, new_bb,\n-\t\t\t\t\t gimple_phi_arg_edge (phi, i)->src);\n-      else\n-\tdef_pred[i] = gimple_bb (SSA_NAME_DEF_STMT (new_phi_args[i]));\n-      if (!def_pred[i])\n-\t{\n-\t  gcc_assert (not_found_bb_index == -1);\n-\t  not_found_bb_index = i;\n-\t}\n-    }\n-\n-  /* Here we are pattern matching on the structure of CFG w.r.t. old one.  */\n-  if (old_bb_dominating_edge)\n-    {\n-      return false;\n-      basic_block new_pred1 = (*new_bb->preds)[0]->src;\n-      basic_block new_pred2 = (*new_bb->preds)[1]->src;\n-      vec <basic_block> *bbs\n-\t= region->copied_bb_map->get (old_bb_non_dominating_edge->src);\n-      gcc_assert (bbs);\n-      basic_block new_pred = NULL;\n-      basic_block b;\n-      int i;\n-      FOR_EACH_VEC_ELT (*bbs, i, b)\n-\tif (new_pred1 == b || new_pred2 == b)\n-\t  {\n-\t    gcc_assert (!new_pred);\n-\t    new_pred = b;\n-\t  }\n-\n-      gcc_assert (new_pred);\n-\n-      edge new_non_dominating_edge = find_edge (new_pred, new_bb);\n-      /* By the process of elimination we first insert insert phi-edge for\n-\t non-dominating pred which is computed above and then we insert the\n-\t remaining one.  */\n-      int inserted_edge = 0;\n-      for (; inserted_edge < 2; inserted_edge++)\n-\t{\n-\t  edge new_bb_pred_edge = gimple_phi_arg_edge (phi, inserted_edge);\n-\t  if (new_non_dominating_edge == new_bb_pred_edge)\n-\t    {\n-\t      add_phi_arg (new_phi, new_phi_args[inserted_edge],\n-\t\t\t   new_non_dominating_edge,\n-\t\t\t   get_loc (old_phi_args[inserted_edge]));\n-\t      break;\n-\t    }\n-\t}\n-\n-      int edge_dominating = 0;\n-      if (inserted_edge == 0)\n-\tedge_dominating = 1;\n-\n-      edge new_dominating_edge = NULL;\n-      for (int i; i < 2; i++)\n-\t{\n-\t  edge e = gimple_phi_arg_edge (new_phi, i);\n-\t  if (e != new_non_dominating_edge)\n-\t    new_dominating_edge = e;\n-\t}\n-\n-      add_phi_arg (new_phi, new_phi_args[edge_dominating], new_dominating_edge,\n-\t\t   get_loc (old_phi_args[inserted_edge]));\n-    }\n-  else\n-    {\n-      /* Classic diamond structure: both edges are non-dominating.  We need to\n-\t find one unique edge then the other can be found be elimination.  If\n-\t any definition (def_pred) dominates both the preds of new_bb then we\n-\t bail out.  Entries of def_pred maybe NULL, in that case we must\n-\t uniquely find pred with help of only one entry.  */\n-      edge new_e[2] = { NULL, NULL };\n-      for (int i = 0; i < 2; i++)\n-\t{\n-\t  edge e;\n-\t  edge_iterator ei;\n-\t  FOR_EACH_EDGE (e, ei, new_bb->preds)\n-\t    if (def_pred[i]\n-\t\t&& dominated_by_p (CDI_DOMINATORS, e->src, def_pred[i]))\n-\t      {\n-\t\tif (new_e[i])\n-\t\t  /* We do not know how to handle the case when def_pred\n-\t\t     dominates more than a predecessor.  */\n-\t\t  return false;\n-\t\tnew_e[i] = e;\n-\t      }\n-\t}\n-\n-      gcc_assert (new_e[0] || new_e[1]);\n-\n-      /* Find the other edge by process of elimination.  */\n-      if (not_found_bb_index != -1)\n-\t{\n-\t  gcc_assert (!new_e[not_found_bb_index]);\n-\t  int found_bb_index = not_found_bb_index == 1 ? 0 : 1;\n-\t  edge e;\n-\t  edge_iterator ei;\n-\t  FOR_EACH_EDGE (e, ei, new_bb->preds)\n-\t    {\n-\t      if (new_e[found_bb_index] == e)\n-\t\tcontinue;\n-\t      new_e[not_found_bb_index] = e;\n-\t    }\n-\t}\n-\n-      /* Add edges to phi args.  */\n-      for (int i = 0; i < 2; i++)\n-\tadd_phi_arg (new_phi, new_phi_args[i], new_e[i],\n-\t\t     get_loc (old_phi_args[i]));\n-    }\n-\n-  return true;\n-}\n-\n-/* Copy the arguments of cond-phi node PHI, to NEW_PHI in the codegenerated\n-   region.  If postpone is true and it isn't possible to copy any arg of PHI,\n-   the PHI is added to the REGION->INCOMPLETE_PHIS to be codegenerated\n-   later.  Returns false if the copying was unsuccessful.  */\n-\n-bool\n-copy_cond_phi_args (gphi *phi, gphi *new_phi, vec<tree> iv_map,\n-\t\t    sese_info_p region, bool postpone)\n-{\n-  if (dump_file)\n-    fprintf (dump_file, \"\\n[codegen] copying cond phi args: \");\n-  gcc_assert (2 == gimple_phi_num_args (phi));\n-\n-  basic_block new_bb = gimple_bb (new_phi);\n-  loop_p loop = gimple_bb (phi)->loop_father;\n-\n-  basic_block old_bb = gimple_bb (phi);\n-  edge old_bb_non_dominating_edge = NULL, old_bb_dominating_edge = NULL;\n-\n-  edge e;\n-  edge_iterator ei;\n-  FOR_EACH_EDGE (e, ei, old_bb->preds)\n-    if (!dominated_by_p (CDI_DOMINATORS, old_bb, e->src))\n-      old_bb_non_dominating_edge = e;\n-    else\n-      old_bb_dominating_edge = e;\n-\n-  gcc_assert (!dominated_by_p (CDI_DOMINATORS, old_bb,\n-\t\t\t       old_bb_non_dominating_edge->src));\n-\n-  tree new_phi_args[2];\n-  tree old_phi_args[2];\n-\n-  for (unsigned i = 0; i < gimple_phi_num_args (phi); i++)\n-    {\n-      tree old_name = gimple_phi_arg_def (phi, i);\n-      tree new_name = get_new_name (region, new_bb, old_name, old_bb, false);\n-      old_phi_args[i] = old_name;\n-      if (new_name)\n-\t{\n-\t  new_phi_args [i] = new_name;\n-\t  continue;\n-\t}\n-\n-      if (vec_find (region->params, old_name))\n-\t{\n-\t  new_phi_args [i] = old_name;\n-\t  if (dump_file)\n-\t    {\n-\t      fprintf (dump_file,\n-\t\t       \"\\n[codegen] parameter argument to phi, new_expr: \");\n-\t      print_gimple_stmt (dump_file, new_phi, 0, 0);\n-\t    }\n-\t  continue;\n-\t}\n-\n-      /* If the phi-arg is scev-analyzeable but only in the first stage.  */\n-      if (postpone && is_gimple_reg (old_name)\n-\t  && scev_analyzable_p (old_name, region->region))\n-\t{\n-\t  gimple_seq stmts;\n-\t  bool gloog_error = false;\n-\t  tree new_expr\n-\t    = get_rename_from_scev (old_name, &stmts, loop, new_bb,\n-\t\t\t\t    old_bb, iv_map, region, &gloog_error);\n-\t  if (gloog_error)\n-\t    return false;\n-\n-\t  gcc_assert (new_expr);\n-\t  if (dump_file)\n-\t    {\n-\t      fprintf (dump_file, \"\\n[codegen] scev analyzeable, new_expr: \");\n-\t      print_generic_expr (dump_file, new_expr, 0);\n-\t    }\n-\t  gsi_insert_earliest (stmts, region);\n-\t  new_phi_args [i] = new_name;\n-\t  continue;\n-\t}\n-\n-      gimple *old_def_stmt = SSA_NAME_DEF_STMT (old_name);\n-      if (!old_def_stmt || gimple_code (old_def_stmt) == GIMPLE_NOP)\n-\t/* If the phi arg was a function arg, or wasn't defined, just use the\n-\t   old name.  */\n-\tgcc_unreachable ();\n-      else if (postpone)\n-\t{\n-\t  /* Postpone code gen for later for back-edges.  */\n-\t  region->incomplete_phis.safe_push (std::make_pair (phi, new_phi));\n-\n-\t  if (dump_file)\n-\t    {\n-\t      fprintf (dump_file, \"\\n[codegen] postpone cond phi nodes: \");\n-\t      print_gimple_stmt (dump_file, new_phi, 0, 0);\n-\t    }\n-\n-\t  new_phi_args [i] = NULL_TREE;\n-\t  continue;\n-\t}\n-      else\n-\tgcc_unreachable ();\n-    }\n-\n-  return add_phi_arg_for_new_expr (old_phi_args, new_phi_args,\n-\t\t\t\t   old_bb_dominating_edge,\n-\t\t\t\t   old_bb_non_dominating_edge,\n-\t\t\t\t   phi, new_phi, new_bb, region);\n-}\n-\n-/* Copy cond phi nodes from BB to NEW_BB.  */\n-\n-static bool\n-copy_cond_phi_nodes (basic_block bb, basic_block new_bb, vec<tree> iv_map,\n-\t\t     sese_info_p region)\n-{\n-\n-  gcc_assert (!bb_contains_loop_close_phi_nodes (bb));\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"\\n[codegen] copying cond phi nodes in bb_%d:\",\n-\t     new_bb->index);\n-\n-  /* Cond phi nodes should have exactly two arguments.  */\n-  gcc_assert (2 == EDGE_COUNT (bb->preds));\n-\n-  for (gphi_iterator psi = gsi_start_phis (bb); !gsi_end_p (psi);\n-       gsi_next (&psi))\n-    {\n-      gphi *phi = psi.phi ();\n-      tree res = gimple_phi_result (phi);\n-      if (virtual_operand_p (res))\n-\tcontinue;\n-      if (is_gimple_reg (res) && scev_analyzable_p (res, region->region))\n-\t/* Cond phi nodes should not be scev_analyzable_p.  */\n-\tgcc_unreachable ();\n-\n-      gphi *new_phi = create_phi_node (SSA_NAME_VAR (res), new_bb);\n-      tree new_res = create_new_def_for (res, new_phi,\n-\t\t\t\t\t gimple_phi_result_ptr (new_phi));\n-      set_rename (res, new_res, region);\n-\n-      if (!copy_cond_phi_args (phi, new_phi, iv_map, region, true))\n-\treturn false;\n-\n-      update_stmt (new_phi);\n-    }\n-\n-  return true;\n-}\n-\n-/* Return true if STMT should be copied from region to the\n-   new code-generated region.  LABELs, CONDITIONS, induction-variables\n-   and region parameters need not be copied.  */\n-\n-static bool\n-should_copy_to_new_region (gimple *stmt, sese_info_p region)\n-{\n-  /* Do not copy labels or conditions.  */\n-  if (gimple_code (stmt) == GIMPLE_LABEL\n-      || gimple_code (stmt) == GIMPLE_COND)\n-    return false;\n-\n-  tree lhs;\n-  /* Do not copy induction variables.  */\n-  if (is_gimple_assign (stmt)\n-      && (lhs = gimple_assign_lhs (stmt))\n-      && TREE_CODE (lhs) == SSA_NAME\n-      && is_gimple_reg (lhs)\n-      && scev_analyzable_p (lhs, region->region))\n-    return false;\n-\n-  return true;\n-}\n-\n-/* Create new names for all the definitions created by COPY and\n-   add replacement mappings for each new name.  */\n-\n-static void\n-set_rename_for_each_def (gimple *stmt, sese_info_p region)\n-{\n-  def_operand_p def_p;\n-  ssa_op_iter op_iter;\n-  FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, op_iter, SSA_OP_ALL_DEFS)\n-    {\n-      tree old_name = DEF_FROM_PTR (def_p);\n-      tree new_name = create_new_def_for (old_name, stmt, def_p);\n-      set_rename (old_name, new_name, region);\n-    }\n-}\n-\n-/* Duplicates the statements of basic block BB into basic block NEW_BB\n-   and compute the new induction variables according to the IV_MAP.\n-   GLOOG_ERROR is set when the code generation cannot continue.  */\n-static bool\n-graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb,\n-\t\t\t\tvec<tree> iv_map, sese_info_p region,\n-\t\t\t\tbool *gloog_error)\n-{\n-  /* Iterator poining to the place where new statement (s) will be inserted.  */\n-  gimple_stmt_iterator gsi_tgt = gsi_last_bb (new_bb);\n-\n-  for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n-       gsi_next (&gsi))\n-    {\n-      gimple *stmt = gsi_stmt (gsi);\n-      if (!should_copy_to_new_region (stmt, region))\n-\tcontinue;\n-\n-      /* Create a new copy of STMT and duplicate STMT's virtual\n-\t operands.  */\n-      gimple *copy = gimple_copy (stmt);\n-      gsi_insert_after (&gsi_tgt, copy, GSI_NEW_STMT);\n-\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"\\n[codegen] inserting statement: \");\n-\t  print_gimple_stmt (dump_file, copy, 0, 0);\n-\t}\n-\n-      maybe_duplicate_eh_stmt (copy, stmt);\n-      gimple_duplicate_stmt_histograms (cfun, copy, cfun, stmt);\n-\n-      /* Crete new names for each def in the copied stmt.  */\n-      set_rename_for_each_def (copy, region);\n-\n-      loop_p loop = bb->loop_father;\n-      if (rename_uses (copy, &gsi_tgt, bb, region, loop, iv_map, gloog_error))\n-\t{\n-\t  fold_stmt_inplace (&gsi_tgt);\n-\t  gcc_assert (gsi_stmt (gsi_tgt) == copy);\n-\t}\n-\n-      if (*gloog_error)\n-\treturn false;\n-\n-      update_stmt (copy);\n-    }\n-\n-  return true;\n-}\n-\n-/* Copies BB and includes in the copied BB all the statements that can\n-   be reached following the use-def chains from the memory accesses,\n-   and returns the next edge following this new block.  GLOOG_ERROR is\n-   set when the code generation cannot continue.  */\n-\n-edge\n-copy_bb_and_scalar_dependences (basic_block bb, sese_info_p region,\n-\t\t\t\tedge next_e, vec<tree> iv_map,\n-\t\t\t\tbool *codegen_err)\n-{\n-  int num_phis = number_of_phi_nodes (bb);\n-\n-  if (region->copied_bb_map->get (bb))\n-    {\n-      /* FIXME: We do not handle inner loop unrolling when the inner loop has\n-\t phi-nodes.  In that case inner loop will be copied multiple times\n-\t outside the region.  */\n-      if (num_phis)\n-\t{\n-\t  *codegen_err = true;\n-\t  return NULL;\n-\t}\n-    }\n-\n-  basic_block new_bb = split_edge (next_e);\n-  if (num_phis > 0 && bb_contains_loop_phi_nodes (bb))\n-    {\n-      basic_block phi_bb = next_e->dest->loop_father->header;\n-\n-      /* At this point we are unable to codegenerate by still preserving the SSA\n-\t structure because maybe the loop is completely unrolled and the PHIs\n-\t and cross-bb scalar dependencies are untrackable w.r.t. the original\n-\t code.  See gfortran.dg/graphite/pr29832.f90.  */\n-      if (EDGE_COUNT (bb->preds) != EDGE_COUNT (phi_bb->preds))\n-\t{\n-\t  *codegen_err = true;\n-\t  return NULL;\n-\t}\n-\n-      if (dump_file)\n-\tfprintf (dump_file, \"\\n[codegen] bb_%d contains loop phi nodes\",\n-\t\t bb->index);\n-      if (!copy_loop_phi_nodes (bb, phi_bb, region))\n-\t{\n-\t  *codegen_err = true;\n-\t  return NULL;\n-\t}\n-    }\n-  else if (bb_contains_loop_close_phi_nodes (bb))\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"\\n[codegen] bb_%d contains close phi nodes\",\n-\t\t bb->index);\n-\n-      /* Make sure that NEW_BB is the loop->exit->dest.  */\n-      edge e = single_pred_edge (new_bb);\n-      basic_block phi_bb = new_bb;\n-      if (e->src->loop_father == e->dest->loop_father)\n-\t{\n-\t  /* This is one of the places which shows preserving original structure\n-\t     is not always possible, as we may need to insert close PHI for a\n-\t     loop where the latch does not have any mapping, or the mapping is\n-\t     ambiguous.  */\n-\t  basic_block old_loop_bb = single_pred_edge (bb)->src;\n-\t  vec <basic_block> *bbs = region->copied_bb_map->get (old_loop_bb);\n-\t  if (!bbs || bbs->length () != 1)\n-\t    {\n-\t      *codegen_err = true;\n-\t      return NULL;\n-\t    }\n-\n-\t  basic_block new_loop_bb = (*bbs)[0];\n-\t  loop_p new_loop = new_loop_bb->loop_father;\n-\t  phi_bb = single_exit (new_loop)->dest;\n-\t  e = single_pred_edge (phi_bb);\n-\t}\n-\n-      gcc_assert (e->src->loop_father != e->dest->loop_father);\n-\n-      if (!copy_loop_close_phi_nodes (bb, phi_bb, region))\n-\t{\n-\t  *codegen_err = true;\n-\t  return NULL;\n-\t}\n-    }\n-  else if (num_phis > 0)\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"\\n[codegen] bb_%d contains cond phi nodes\",\n-\t\t bb->index);\n-\n-      basic_block phi_bb = single_pred (new_bb);\n-      loop_p loop_father = new_bb->loop_father;\n-\n-      /* Move back until we find the block with two predecessors.  */\n-      while (single_pred_p (phi_bb))\n-\tphi_bb = single_pred_edge (phi_bb)->src;\n-\n-      /* If a corresponding merge-point was not found, then abort codegen.  */\n-      if (phi_bb->loop_father != loop_father\n-\t  || !copy_cond_phi_nodes (bb, phi_bb, iv_map, region))\n-\t{\n-\t  *codegen_err = true;\n-\t  return NULL;\n-\t}\n-    }\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"\\n[codegen] copying from bb_%d to bb_%d\",\n-\t     bb->index, new_bb->index);\n-\n-  vec <basic_block> *copied_bbs = region->copied_bb_map->get (bb);\n-  if (copied_bbs)\n-    copied_bbs->safe_push (new_bb);\n-  else\n-    {\n-      vec<basic_block> bbs;\n-      bbs.create (2);\n-      bbs.safe_push (new_bb);\n-      region->copied_bb_map->put (bb, bbs);\n-    }\n-\n-  if (!graphite_copy_stmts_from_block (bb, new_bb, iv_map, region, codegen_err))\n-    {\n-      *codegen_err = true;\n-      return NULL;\n-    }\n-\n-  return single_succ_edge (new_bb);\n-}\n-\n /* Returns the outermost loop in SCOP that contains BB.  */\n \n struct loop *\n@@ -1930,7 +392,8 @@ if_region_set_false_region (ifsese if_region, sese_info_p region)\n     {\n       struct loop_exit *loop_exit = ggc_cleared_alloc<struct loop_exit> ();\n \n-      memcpy (loop_exit, *((struct loop_exit **) slot), sizeof (struct loop_exit));\n+      memcpy (loop_exit, *((struct loop_exit **) slot),\n+\t      sizeof (struct loop_exit));\n       current_loops->exits->clear_slot (slot);\n \n       hashval_t hash = htab_hash_pointer (false_edge);\n@@ -2071,6 +534,36 @@ invariant_in_sese_p_rec (tree t, sese_l &region, bool *has_vdefs)\n   return true;\n }\n \n+/* Return true when DEF can be analyzed in REGION by the scalar\n+   evolution analyzer.  */\n+\n+bool\n+scev_analyzable_p (tree def, sese_l &region)\n+{\n+  loop_p loop;\n+  tree scev;\n+  tree type = TREE_TYPE (def);\n+\n+  /* When Graphite generates code for a scev, the code generator\n+     expresses the scev in function of a single induction variable.\n+     This is unsafe for floating point computations, as it may replace\n+     a floating point sum reduction with a multiplication.  The\n+     following test returns false for non integer types to avoid such\n+     problems.  */\n+  if (!INTEGRAL_TYPE_P (type)\n+      && !POINTER_TYPE_P (type))\n+    return false;\n+\n+  loop = loop_containing_stmt (SSA_NAME_DEF_STMT (def));\n+  scev = scalar_evolution_in_region (region, loop, def);\n+\n+  return !chrec_contains_undetermined (scev)\n+    && (TREE_CODE (scev) != SSA_NAME\n+\t|| !defined_in_sese_p (scev, region))\n+    && (tree_does_not_contain_chrecs (scev)\n+\t|| evolution_function_is_affine_p (scev));\n+}\n+\n /* Returns the scalar evolution of T in REGION.  Every variable that\n    is not defined in the REGION is considered a parameter.  */\n "}, {"sha": "c3d4c9adae5fddc781a0b2979aa30448bf25e6a0", "filename": "gcc/sese.h", "status": "modified", "additions": 1, "deletions": 43, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ecf4eca922c12a93918f2c4b7c3b3b962d63e98/gcc%2Fsese.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ecf4eca922c12a93918f2c4b7c3b3b962d63e98/gcc%2Fsese.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.h?ref=2ecf4eca922c12a93918f2c4b7c3b3b962d63e98", "patch": "@@ -59,7 +59,6 @@ get_exit_bb (sese_l &s)\n }\n \n /* Returns the index of V where ELEM can be found. -1 Otherwise.  */\n-\n template<typename T>\n int\n vec_find (const vec<T> &v, const T &elem)\n@@ -109,21 +108,10 @@ extern sese_info_p new_sese_info (edge, edge);\n extern void free_sese_info (sese_info_p);\n extern void sese_insert_phis_for_liveouts (sese_info_p, basic_block, edge, edge);\n extern void build_sese_loop_nests (sese_info_p);\n-extern edge copy_bb_and_scalar_dependences (basic_block, sese_info_p, edge,\n-\t\t\t\t\t    vec<tree> , bool *);\n extern struct loop *outermost_loop_in_sese (sese_l &, basic_block);\n extern tree scalar_evolution_in_region (sese_l &, loop_p, tree);\n+extern bool scev_analyzable_p (tree, sese_l &);\n extern bool invariant_in_sese_p_rec (tree, sese_l &, bool *);\n-extern bool bb_contains_loop_phi_nodes (basic_block);\n-extern bool bb_contains_loop_close_phi_nodes (basic_block);\n-extern std::pair<edge, edge> get_edges (basic_block bb);\n-extern void copy_loop_phi_args (gphi *, init_back_edge_pair_t &,\n-\t\t\t\tgphi *, init_back_edge_pair_t &,\n-\t\t\t\tsese_info_p, bool);\n-extern bool copy_loop_close_phi_args (basic_block, basic_block,\n-\t\t\t\t      sese_info_p, bool);\n-extern bool copy_cond_phi_args (gphi *, gphi *, vec<tree>,\n-\t\t\t\tsese_info_p, bool);\n \n /* Check that SESE contains LOOP.  */\n \n@@ -360,34 +348,4 @@ nb_common_loops (sese_l &region, gimple_poly_bb_p gbb1, gimple_poly_bb_p gbb2)\n   return sese_loop_depth (region, common);\n }\n \n-/* Return true when DEF can be analyzed in REGION by the scalar\n-   evolution analyzer.  */\n-\n-static inline bool\n-scev_analyzable_p (tree def, sese_l &region)\n-{\n-  loop_p loop;\n-  tree scev;\n-  tree type = TREE_TYPE (def);\n-\n-  /* When Graphite generates code for a scev, the code generator\n-     expresses the scev in function of a single induction variable.\n-     This is unsafe for floating point computations, as it may replace\n-     a floating point sum reduction with a multiplication.  The\n-     following test returns false for non integer types to avoid such\n-     problems.  */\n-  if (!INTEGRAL_TYPE_P (type)\n-      && !POINTER_TYPE_P (type))\n-    return false;\n-\n-  loop = loop_containing_stmt (SSA_NAME_DEF_STMT (def));\n-  scev = scalar_evolution_in_region (region, loop, def);\n-\n-  return !chrec_contains_undetermined (scev)\n-    && (TREE_CODE (scev) != SSA_NAME\n-\t|| !defined_in_sese_p (scev, region))\n-    && (tree_does_not_contain_chrecs (scev)\n-\t|| evolution_function_is_affine_p (scev));\n-}\n-\n #endif"}]}