{"sha": "24778dbb9a732e8c626807b1a5f4bfe8cec09a58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQ3NzhkYmI5YTczMmU4YzYyNjgwN2IxYTVmNGJmZThjZWMwOWE1OA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-24T14:38:50Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-24T14:38:50Z"}, "message": "[multiple changes]\n\n2013-04-24  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch7.adb (Swap_Private_Dependents): New internal routine\n\tto Install_Private_Declarations, to make the installation of\n\tprivate dependents recursive in the presence of child units.\n\t* sem_ch3.adb (Build_Discriminated_Subtype): Initialize properly\n\tthe Private_Dependents of a private subtype.\n\n2013-04-24  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_attr.adb (Expand_Loop_Entry_Attribute): Update the\n\tretrieval of the block declarations.\n\t* par-ch4.adb (P_Name): Let the name parsing machinery create\n\ta sequence of nested indexed components for attribute Loop_Entry.\n\t* sem_attr.adb (Analyze_Attribute): Add local constant\n\tContext. Reimplement part of the analysis of attribute Loop_Entry.\n\t(Convert_To_Indexed_Component): Removed.\n\t* sem_ch4.adb (Analyze_Indexed_Component_Form): Do not analyze\n\tan indexed component after it has been rewritten into attribute\n\tLoop_Entry.\n\nFrom-SVN: r198240", "tree": {"sha": "5d9560ad2ff07bd6a8cc33c873fd6dcf04cff4a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d9560ad2ff07bd6a8cc33c873fd6dcf04cff4a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24778dbb9a732e8c626807b1a5f4bfe8cec09a58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24778dbb9a732e8c626807b1a5f4bfe8cec09a58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24778dbb9a732e8c626807b1a5f4bfe8cec09a58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24778dbb9a732e8c626807b1a5f4bfe8cec09a58/comments", "author": null, "committer": null, "parents": [{"sha": "8a8ac7e3bd0d316ec3f809e29574e9900847d26a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a8ac7e3bd0d316ec3f809e29574e9900847d26a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a8ac7e3bd0d316ec3f809e29574e9900847d26a"}], "stats": {"total": 290, "additions": 172, "deletions": 118}, "files": [{"sha": "345f9d2c73e042460a58acf12ecc005429be3e7a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24778dbb9a732e8c626807b1a5f4bfe8cec09a58/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24778dbb9a732e8c626807b1a5f4bfe8cec09a58/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=24778dbb9a732e8c626807b1a5f4bfe8cec09a58", "patch": "@@ -1,3 +1,24 @@\n+2013-04-24  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch7.adb (Swap_Private_Dependents): New internal routine\n+\tto Install_Private_Declarations, to make the installation of\n+\tprivate dependents recursive in the presence of child units.\n+\t* sem_ch3.adb (Build_Discriminated_Subtype): Initialize properly\n+\tthe Private_Dependents of a private subtype.\n+\n+2013-04-24  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_attr.adb (Expand_Loop_Entry_Attribute): Update the\n+\tretrieval of the block declarations.\n+\t* par-ch4.adb (P_Name): Let the name parsing machinery create\n+\ta sequence of nested indexed components for attribute Loop_Entry.\n+\t* sem_attr.adb (Analyze_Attribute): Add local constant\n+\tContext. Reimplement part of the analysis of attribute Loop_Entry.\n+\t(Convert_To_Indexed_Component): Removed.\n+\t* sem_ch4.adb (Analyze_Indexed_Component_Form): Do not analyze\n+\tan indexed component after it has been rewritten into attribute\n+\tLoop_Entry.\n+\n 2013-04-24  Yannick Moy  <moy@adacore.com>\n \n \t* snames.ads-tmpl: Minor change to list"}, {"sha": "f904707178db4ff6f27f7038e7d7c78f3b840322", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24778dbb9a732e8c626807b1a5f4bfe8cec09a58/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24778dbb9a732e8c626807b1a5f4bfe8cec09a58/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=24778dbb9a732e8c626807b1a5f4bfe8cec09a58", "patch": "@@ -782,7 +782,15 @@ package body Exp_Attr is\n       --  'Loop_Entry attribute. Retrieve the declarative list of the block.\n \n       if Has_Loop_Entry_Attributes (Loop_Id) then\n-         Decls  := Declarations (Parent (Parent (Loop_Stmt)));\n+         if Nkind (Loop_Stmt) = N_Block_Statement then\n+            Decls := Declarations (Loop_Stmt);\n+         else\n+            --  What is going on here??? comments/assertions needed to explain\n+            --  the assumption being made about the tree???\n+\n+            Decls := Declarations (Parent (Parent (Loop_Stmt)));\n+         end if;\n+\n          Result := Empty;\n \n       --  Transform the loop into a conditional block"}, {"sha": "e1e634a9e9669193662eb6eb450d68fb2f806c64", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24778dbb9a732e8c626807b1a5f4bfe8cec09a58/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24778dbb9a732e8c626807b1a5f4bfe8cec09a58/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=24778dbb9a732e8c626807b1a5f4bfe8cec09a58", "patch": "@@ -698,25 +698,16 @@ package body Ch4 is\n \n          if Token = Tok_Arrow then\n             Error_Msg\n-              (\"expect identifier in parameter association\",\n-                Sloc (Expr_Node));\n+              (\"expect identifier in parameter association\", Sloc (Expr_Node));\n             Scan;  -- past arrow\n \n          elsif not Comma_Present then\n             T_Right_Paren;\n \n-            --  Do not convert Prefix'Loop_Entry (Expr1, ..., ExprN) into an\n-            --  indexed component now. Let the analysis determine whether the\n-            --  attribute is legal and perform the transformation if needed.\n-\n-            if Attr_Name = Name_Loop_Entry then\n-               Set_Expressions (Name_Node, Arg_List);\n-            else\n-               Prefix_Node := Name_Node;\n-               Name_Node := New_Node (N_Indexed_Component, Sloc (Prefix_Node));\n-               Set_Prefix (Name_Node, Prefix_Node);\n-               Set_Expressions (Name_Node, Arg_List);\n-            end if;\n+            Prefix_Node := Name_Node;\n+            Name_Node := New_Node (N_Indexed_Component, Sloc (Prefix_Node));\n+            Set_Prefix (Name_Node, Prefix_Node);\n+            Set_Expressions (Name_Node, Arg_List);\n \n             goto Scan_Name_Extension;\n          end if;"}, {"sha": "30509dc3873c6ac56c523ffe70e9ec318be8d166", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 60, "deletions": 67, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24778dbb9a732e8c626807b1a5f4bfe8cec09a58/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24778dbb9a732e8c626807b1a5f4bfe8cec09a58/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=24778dbb9a732e8c626807b1a5f4bfe8cec09a58", "patch": "@@ -2136,20 +2136,6 @@ package body Sem_Attr is\n          E1 := Empty;\n          E2 := Empty;\n \n-      --  Do not analyze the expressions of attribute Loop_Entry. Depending on\n-      --  the number of arguments and/or the nature of the first argument, the\n-      --  whole attribute reference may be rewritten into an indexed component.\n-      --  In the case of two or more arguments, the expressions are analyzed\n-      --  when the indexed component is analyzed, otherwise the sole argument\n-      --  is preanalyzed to determine whether it is a loop name.\n-\n-      elsif Aname = Name_Loop_Entry then\n-         E1 := First (Exprs);\n-\n-         if Present (E1) then\n-            E2 := Next (E1);\n-         end if;\n-\n       else\n          E1 := First (Exprs);\n          Analyze (E1);\n@@ -3641,11 +3627,6 @@ package body Sem_Attr is\n          --  Inspect the prefix for any uses of entities declared within the\n          --  related loop. Loop_Id denotes the loop identifier.\n \n-         procedure Convert_To_Indexed_Component;\n-         --  Transform the attribute reference into an indexed component where\n-         --  the prefix is Prefix'Loop_Entry and the expressions are associated\n-         --  with the indexed component.\n-\n          --------------------------------\n          -- Check_References_In_Prefix --\n          --------------------------------\n@@ -3712,27 +3693,9 @@ package body Sem_Attr is\n             Check_References (P);\n          end Check_References_In_Prefix;\n \n-         ----------------------------------\n-         -- Convert_To_Indexed_Component --\n-         ----------------------------------\n-\n-         procedure Convert_To_Indexed_Component is\n-            New_Loop_Entry : constant Node_Id := Relocate_Node (N);\n-\n-         begin\n-            --  The new Loop_Entry loses its arguments. They will be converted\n-            --  into the expressions of the indexed component.\n-\n-            Set_Expressions (New_Loop_Entry, No_List);\n-\n-            Rewrite (N,\n-              Make_Indexed_Component (Loc,\n-                Prefix      => New_Loop_Entry,\n-                Expressions => Exprs));\n-         end Convert_To_Indexed_Component;\n-\n          --  Local variables\n \n+         Context           : constant Node_Id := Parent (N);\n          Enclosing_Loop    : Node_Id;\n          In_Loop_Assertion : Boolean   := False;\n          Loop_Id           : Entity_Id := Empty;\n@@ -3742,47 +3705,77 @@ package body Sem_Attr is\n       --  Start of processing for Loop_Entry\n \n       begin\n-         S14_Attribute;\n+         --  Attribute 'Loop_Entry may appear in several flavors:\n \n-         --  The attribute reference appears as\n-         --    Prefix'Loop_Entry (Expr1, Expr2, ... ExprN)\n+         --    * Prefix'Loop_Entry - in this form, the attribute applies to the\n+         --        nearest enclosing loop.\n \n-         --  In this case, the loop name is omitted and the arguments are part\n-         --  of an indexed component. Transform the whole attribute reference\n-         --  to reflect this scenario.\n+         --    * Prefix'Loop_Entry (Expr) - depending on what Expr denotes, the\n+         --        attribute may be related to a loop denoted by label Expr or\n+         --        the prefix may denote an array object and Expr may act as an\n+         --        indexed component.\n \n-         if Present (E2) then\n-            Convert_To_Indexed_Component;\n-            Analyze (N);\n-            return;\n+         --    * Prefix'Loop_Entry (Expr1, ..., ExprN) - the attribute applies\n+         --        to the nearest enclosing loop, all expressions are part of\n+         --        an indexed component.\n \n-         --  The attribute reference appears as\n-         --    Prefix'Loop_Entry (Loop_Name)\n-         --      or\n-         --    Prefix'Loop_Entry (Expr1)\n+         --    * Prefix'Loop_Entry (Expr) (...) (...) - depending on what Expr\n+         --        denotes, the attribute may be related to a loop denoted by\n+         --        label Expr or the prefix may denote a multidimensional array\n+         --        array object and Expr along with the rest of the expressions\n+         --        may act as indexed components.\n \n-         --  Depending on what Expr1 resolves to, either rewrite the reference\n-         --  into an indexed component or continue with the analysis.\n+         --  Regardless of variations, the attribute reference does not have an\n+         --  expression list. Instead, all available expressions are stored as\n+         --  indexed components.\n \n-         elsif Present (E1) then\n+         S14_Attribute;\n \n-            --  Do not expand the argument as it may have side effects. Simply\n-            --  preanalyze to determine whether it is a loop or something else.\n+         --  When the attribute is part of an indexed component, find the first\n+         --  expression as it will determine the semantics of 'Loop_Entry.\n \n-            Preanalyze_And_Resolve (E1);\n+         if Nkind (Context) = N_Indexed_Component then\n+            E1 := First (Expressions (Context));\n+            E2 := Next (E1);\n \n-            if Is_Entity_Name (E1)\n-              and then Present (Entity (E1))\n-              and then Ekind (Entity (E1)) = E_Loop\n-            then\n-               Loop_Id := Entity (E1);\n+            --  The attribute reference appears in the following form:\n+\n+            --    Prefix'Loop_Entry (Exp1, Expr2, ..., ExprN) [(...)]\n+\n+            --  In this case, the loop name is omitted and no rewriting is\n+            --  required.\n+\n+            if Present (E2) then\n+               null;\n+\n+            --  The form of the attribute is:\n+\n+            --    Prefix'Loop_Entry (Expr) [(...)]\n \n-            --  The argument is not a loop name\n+            --  If Expr denotes a loop entry, the whole attribute and indexed\n+            --  component will have to be rewritten to reflect this relation.\n \n             else\n-               Convert_To_Indexed_Component;\n-               Analyze (N);\n-               return;\n+               pragma Assert (Present (E1));\n+\n+               --  Do not expand the expression as it may have side effects.\n+               --  Simply preanalyze to determine whether it is a loop name or\n+               --  something else.\n+\n+               Preanalyze_And_Resolve (E1);\n+\n+               if Is_Entity_Name (E1)\n+                 and then Present (Entity (E1))\n+                 and then Ekind (Entity (E1)) = E_Loop\n+               then\n+                  Loop_Id := Entity (E1);\n+\n+                  --  Transform the attribute and enclosing indexed component\n+\n+                  Set_Expressions (N, Expressions (Context));\n+                  Rewrite   (Context, N);\n+                  Set_Etype (Context, P_Type);\n+               end if;\n             end if;\n          end if;\n "}, {"sha": "8e874af85caf101b7da8080acaff205042b2eb19", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24778dbb9a732e8c626807b1a5f4bfe8cec09a58/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24778dbb9a732e8c626807b1a5f4bfe8cec09a58/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=24778dbb9a732e8c626807b1a5f4bfe8cec09a58", "patch": "@@ -8659,6 +8659,10 @@ package body Sem_Ch3 is\n          Set_Known_To_Have_Preelab_Init\n            (Def_Id, Known_To_Have_Preelab_Init (T));\n \n+         --  private subtypes may have private dependents.\n+\n+         Set_Private_Dependents (Def_Id, New_Elmt_List);\n+\n       elsif Is_Class_Wide_Type (T) then\n          Set_Ekind (Def_Id, E_Class_Wide_Subtype);\n "}, {"sha": "ae6980506acd02072dee778a1fe822d908a14807", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24778dbb9a732e8c626807b1a5f4bfe8cec09a58/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24778dbb9a732e8c626807b1a5f4bfe8cec09a58/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=24778dbb9a732e8c626807b1a5f4bfe8cec09a58", "patch": "@@ -2388,12 +2388,20 @@ package body Sem_Ch4 is\n \n       Analyze (P);\n \n+      --  If P is an explicit dereference whose prefix is of a remote access-\n+      --  to-subprogram type, then N has already been rewritten as a subprogram\n+      --  call and analyzed.\n+\n       if Nkind (N) in N_Subprogram_Call then\n+         return;\n \n-         --  If P is an explicit dereference whose prefix is of a\n-         --  remote access-to-subprogram type, then N has already\n-         --  been rewritten as a subprogram call and analyzed.\n+      --  When the prefix is attribute 'Loop_Entry and the sole expression of\n+      --  the indexed component denotes a loop name, the indexed form is turned\n+      --  into an attribute reference.\n \n+      elsif Nkind (N) = N_Attribute_Reference\n+        and then Attribute_Name (N) = Name_Loop_Entry\n+      then\n          return;\n       end if;\n "}, {"sha": "c21874d284b7edaa7434b4ac67fc9176fe31fef6", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 62, "deletions": 33, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24778dbb9a732e8c626807b1a5f4bfe8cec09a58/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24778dbb9a732e8c626807b1a5f4bfe8cec09a58/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=24778dbb9a732e8c626807b1a5f4bfe8cec09a58", "patch": "@@ -1812,9 +1812,63 @@ package body Sem_Ch7 is\n \n    procedure Install_Private_Declarations (P : Entity_Id) is\n       Id        : Entity_Id;\n-      Priv_Elmt : Elmt_Id;\n-      Priv      : Entity_Id;\n       Full      : Entity_Id;\n+      Priv_Deps : Elist_Id;\n+\n+      procedure Swap_Private_Dependents (Priv_Deps : Elist_Id);\n+      --  When the full view of a private type is made available, we do the\n+      --  same for its private dependents under proper visibility conditions.\n+      --  When compiling a grand-chid unit this needs to be done recursively.\n+\n+      procedure Swap_Private_Dependents (Priv_Deps : Elist_Id) is\n+         Deps      : Elist_Id;\n+         Priv      : Entity_Id;\n+         Priv_Elmt : Elmt_Id;\n+         Is_Priv   : Boolean;\n+\n+      begin\n+         Priv_Elmt := First_Elmt (Priv_Deps);\n+\n+         while Present (Priv_Elmt) loop\n+            Priv := Node (Priv_Elmt);\n+\n+            --  Before the exchange, verify that the presence of the\n+            --  Full_View field. It will be empty if the entity has already\n+            --  been installed due to a previous call.\n+\n+            if Present (Full_View (Priv))\n+              and then Is_Visible_Dependent (Priv)\n+            then\n+               if Is_Private_Type (Priv) then\n+                  Deps := Private_Dependents (Priv);\n+                  Is_Priv := True;\n+               else\n+                  Is_Priv := False;\n+               end if;\n+\n+               --  For each subtype that is swapped, we also swap the\n+               --  reference to it in Private_Dependents, to allow access\n+               --  to it when we swap them out in End_Package_Scope.\n+\n+               Replace_Elmt (Priv_Elmt, Full_View (Priv));\n+               Exchange_Declarations (Priv);\n+               Set_Is_Immediately_Visible\n+                 (Priv, In_Open_Scopes (Scope (Priv)));\n+               Set_Is_Potentially_Use_Visible\n+                 (Priv, Is_Potentially_Use_Visible (Node (Priv_Elmt)));\n+\n+               --  Within a child unit, recurse.\n+\n+               if Is_Priv\n+                 and then Is_Child_Unit (Cunit_Entity (Current_Sem_Unit))\n+               then\n+                  Swap_Private_Dependents (Deps);\n+               end if;\n+            end if;\n+\n+            Next_Elmt (Priv_Elmt);\n+         end loop;\n+      end Swap_Private_Dependents;\n \n    begin\n       --  First exchange declarations for private types, so that the full\n@@ -1869,36 +1923,10 @@ package body Sem_Ch7 is\n                end if;\n             end if;\n \n-            Priv_Elmt := First_Elmt (Private_Dependents (Id));\n-\n+            Priv_Deps := Private_Dependents (Id);\n             Exchange_Declarations (Id);\n             Set_Is_Immediately_Visible (Id);\n-\n-            while Present (Priv_Elmt) loop\n-               Priv := Node (Priv_Elmt);\n-\n-               --  Before the exchange, verify that the presence of the\n-               --  Full_View field. It will be empty if the entity has already\n-               --  been installed due to a previous call.\n-\n-               if Present (Full_View (Priv))\n-                 and then Is_Visible_Dependent (Priv)\n-               then\n-\n-                  --  For each subtype that is swapped, we also swap the\n-                  --  reference to it in Private_Dependents, to allow access\n-                  --  to it when we swap them out in End_Package_Scope.\n-\n-                  Replace_Elmt (Priv_Elmt, Full_View (Priv));\n-                  Exchange_Declarations (Priv);\n-                  Set_Is_Immediately_Visible\n-                    (Priv, In_Open_Scopes (Scope (Priv)));\n-                  Set_Is_Potentially_Use_Visible\n-                    (Priv, Is_Potentially_Use_Visible (Node (Priv_Elmt)));\n-               end if;\n-\n-               Next_Elmt (Priv_Elmt);\n-            end loop;\n+            Swap_Private_Dependents (Priv_Deps);\n          end if;\n \n          Next_Entity (Id);\n@@ -2035,12 +2063,13 @@ package body Sem_Ch7 is\n       if Ada_Version < Ada_2012 then\n          Enter_Name (Id);\n \n-      --  Ada 2012 (AI05-0162): Enter the name in the current scope handling\n-      --  private type that completes an incomplete type.\n+      --  Ada 2012 (AI05-0162): Enter the name in the current scope. Note that\n+      --  there may be an incomplete previous view.\n \n       else\n          declare\n             Prev : Entity_Id;\n+\n          begin\n             Prev := Find_Type_Name (N);\n             pragma Assert (Prev = Id\n@@ -2093,7 +2122,7 @@ package body Sem_Ch7 is\n \n          --  Create a class-wide type with the same attributes\n \n-         Make_Class_Wide_Type     (Id);\n+         Make_Class_Wide_Type (Id);\n \n       elsif Abstract_Present (Def) then\n          Error_Msg_N (\"only a tagged type can be abstract\", N);"}]}