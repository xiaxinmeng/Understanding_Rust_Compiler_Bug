{"sha": "05dde071b32f815dc9f84bae2bcb71093e4633fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDVkZGUwNzFiMzJmODE1ZGM5Zjg0YmFlMmJjYjcxMDkzZTQ2MzNmZQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2004-11-28T12:01:20Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2004-11-28T12:01:20Z"}, "message": "vax.h (CASE_DROPS_THROUGH): Don't define.\n\n\t* config/vax/vax.h (CASE_DROPS_THROUGH): Don't define.\n\t* config/vax/vax.md (casesi): Emit a test-and-branch to make sure\n\tthat the case is in range, to make sure the casesi insn is always\n\tin range and never falls through.\n\t(casesi1): Add comment to explain why casesi never falls through.\n\tRemove the unnamed special case casesi pattern.\n\nFrom-SVN: r91417", "tree": {"sha": "cbc410ed8e447946a1d8d0de3c7e6ff94ce0b213", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cbc410ed8e447946a1d8d0de3c7e6ff94ce0b213"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05dde071b32f815dc9f84bae2bcb71093e4633fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05dde071b32f815dc9f84bae2bcb71093e4633fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05dde071b32f815dc9f84bae2bcb71093e4633fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05dde071b32f815dc9f84bae2bcb71093e4633fe/comments", "author": null, "committer": null, "parents": [{"sha": "69ffa7aa5a5eaf6b8525bd86ff2479bd09448c51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69ffa7aa5a5eaf6b8525bd86ff2479bd09448c51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69ffa7aa5a5eaf6b8525bd86ff2479bd09448c51"}], "stats": {"total": 120, "additions": 60, "deletions": 60}, "files": [{"sha": "85003883e7246983108007e1fedcb0a88f7f93c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05dde071b32f815dc9f84bae2bcb71093e4633fe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05dde071b32f815dc9f84bae2bcb71093e4633fe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=05dde071b32f815dc9f84bae2bcb71093e4633fe", "patch": "@@ -1,3 +1,13 @@\n+2004-11-28  Steven Bosscher\n+\t    John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\t* config/vax/vax.h (CASE_DROPS_THROUGH): Don't define.\n+\t* config/vax/vax.md (casesi): Emit a test-and-branch to make sure\n+\tthat the case is in range, to make sure the casesi insn is always\n+\tin range and never falls through.\n+\t(casesi1): Add comment to explain why casesi never falls through.\n+\tRemove the unnamed special case casesi pattern.\n+\n 2004-11-28  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \tPR target/18331"}, {"sha": "5efd790dde42d3c05171e7594d03bbe22fcdaa85", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05dde071b32f815dc9f84bae2bcb71093e4633fe/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05dde071b32f815dc9f84bae2bcb71093e4633fe/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=05dde071b32f815dc9f84bae2bcb71093e4633fe", "patch": "@@ -784,11 +784,6 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n    Do not define this if the table should contain absolute addresses.  */\n #define CASE_VECTOR_PC_RELATIVE 1\n \n-/* Define this if the case instruction drops through after the table\n-   when the index is out of range.  Don't define it if the case insn\n-   jumps to the default label instead.  */\n-#define CASE_DROPS_THROUGH\n-\n /* Indicate that jump tables go in the text section.  This is\n    necessary when compiling PIC code.  */\n #define JUMP_TABLES_IN_TEXT_SECTION 1"}, {"sha": "bd25875ecdb070c882240f273485f1ce1f6fea6d", "filename": "gcc/config/vax/vax.md", "status": "modified", "additions": 50, "deletions": 55, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05dde071b32f815dc9f84bae2bcb71093e4633fe/gcc%2Fconfig%2Fvax%2Fvax.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05dde071b32f815dc9f84bae2bcb71093e4633fe/gcc%2Fconfig%2Fvax%2Fvax.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.md?ref=05dde071b32f815dc9f84bae2bcb71093e4633fe", "patch": "@@ -1960,68 +1960,63 @@\n   \"jmp (%0)\")\n \n ;; This is here to accept 5 arguments (as passed by expand_end_case)\n-;; and pass the first 4 along to the casesi1 pattern that really does the work.\n+;; and pass the first 4 along to the casesi1 pattern that really does\n+;; the actual casesi work.  We emit a jump here to the default label\n+;; _before_ the casesi so that we can be sure that the casesi never\n+;; drops through.\n+;; This is suboptimal perhaps, but so is much of the rest of this\n+;; machine description.  For what it's worth, HPPA uses the same trick.\n+;;\n+;; operand 0 is index\n+;; operand 1 is the minimum bound (a const_int)\n+;; operand 2 is the maximum bound - minimum bound + 1 (also a const_int)\n+;; operand 3 is CODE_LABEL for the table;\n+;; operand 4 is the CODE_LABEL to go to if index out of range (ie. default).\n+;;\n+;; We emit:\n+;;\ti = index - minimum_bound\n+;;\tif (i > (maximum_bound - minimum_bound + 1) goto default;\n+;;\tcasesi (i, 0, table);\n+;;\n (define_expand \"casesi\"\n-  [(match_operand:SI 0 \"general_operand\" \"\")\t; index\n-   (match_operand:SI 1 \"general_operand\" \"\")\t; lower\n-   (match_operand:SI 2 \"general_operand\" \"\")\t; upper-lower\n-   (match_operand 3 \"\" \"\")\t\t\t; table label\n-   (match_operand 4 \"\" \"\")]\t\t\t; default label\n+  [(match_operand:SI 0 \"general_operand\" \"\")\n+   (match_operand:SI 1 \"general_operand\" \"\")\n+   (match_operand:SI 2 \"general_operand\" \"\")\n+   (match_operand 3 \"\" \"\")\n+   (match_operand 4 \"\" \"\")]\n   \"\"\n {\n-  emit_jump_insn (gen_casesi1 (operands[0], operands[1],\n-\t\t\t       operands[2], operands[3]));\n+  /* i = index - minimum_bound;\n+     But only if the lower bound is not already zero.  */\n+  if (operands[1] != const0_rtx)\n+    {\n+      rtx index = gen_reg_rtx (SImode);\n+      emit_insn (gen_addsi3 (index,\n+\t\t\t     operands[0],\n+\t\t\t     GEN_INT (-INTVAL (operands[1]))));\n+      operands[0] = index;\n+    }\n+\n+  /* if (i > (maximum_bound - minimum_bound + 1) goto default;  */\n+  emit_insn (gen_cmpsi (operands[0], operands[2]));\n+  emit_jump_insn (gen_bgtu (operands[4]));\n+\n+  /* casesi (i, 0, table);  */\n+  emit_jump_insn (gen_casesi1 (operands[0], operands[2], operands[3]));\n   DONE;\n })\n \n+;; This insn is a bit of a lier.  It actually falls through if no case\n+;; matches.  But, we prevent that from ever happening by emiting a jump\n+;; before this, see the define_expand above.\n (define_insn \"casesi1\"\n-  [(set (pc)\n-\t(if_then_else\n-\t (leu (minus:SI (match_operand:SI 0 \"general_operand\" \"g\")\n-\t\t\t(match_operand:SI 1 \"general_operand\" \"g\"))\n-\t      (match_operand:SI 2 \"general_operand\" \"g\"))\n-\t (plus:SI (sign_extend:SI\n-\t\t   (mem:HI (plus:SI (mult:SI (minus:SI (match_dup 0)\n-\t\t\t\t\t\t       (match_dup 1))\n-\t\t\t\t\t     (const_int 2))\n-\t\t\t\t    (pc))))\n-\t\t  (label_ref:SI (match_operand 3 \"\" \"\")))\n-\t (pc)))]\n-  \"\"\n-  \"casel %0,%1,%2\")\n-\n-;; This can arise by simplification when operand 1 is a constant int.\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else\n-\t (leu (plus:SI (match_operand:SI 0 \"general_operand\" \"g\")\n-\t\t       (match_operand:SI 1 \"const_int_operand\" \"n\"))\n-\t      (match_operand:SI 2 \"general_operand\" \"g\"))\n-\t (plus:SI (sign_extend:SI\n-\t\t   (mem:HI (plus:SI (mult:SI (plus:SI (match_dup 0)\n-\t\t\t\t\t\t      (match_dup 1))\n-\t\t\t\t\t     (const_int 2))\n-\t\t\t\t    (pc))))\n-\t\t  (label_ref:SI (match_operand 3 \"\" \"\")))\n-\t (pc)))]\n-  \"\"\n-  \"*\n-{\n-  operands[1] = GEN_INT (-INTVAL (operands[1]));\n-  return \\\"casel %0,%1,%2\\\";\n-}\")\n-\n-;; This can arise by simplification when the base for the case insn is zero.\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (leu (match_operand:SI 0 \"general_operand\" \"g\")\n-\t\t\t   (match_operand:SI 1 \"general_operand\" \"g\"))\n-\t\t      (plus:SI (sign_extend:SI\n-\t\t\t\t(mem:HI (plus:SI (mult:SI (match_dup 0)\n-\t\t\t\t\t\t\t  (const_int 2))\n-\t\t\t\t\t(pc))))\n-\t\t\t       (label_ref:SI (match_operand 2 \"\" \"\")))\n-\t\t      (pc)))]\n+  [(match_operand:SI 1 \"const_int_operand\" \"n\")\n+   (set (pc)\n+\t(plus:SI (sign_extend:SI\n+\t\t  (mem:HI (plus:SI (mult:SI (match_operand:SI 0 \"general_operand\" \"g\")\n+\t\t\t\t\t    (const_int 2))\n+\t\t\t  (pc))))\n+\t\t (label_ref:SI (match_operand 2 \"\" \"\"))))]\n   \"\"\n   \"casel %0,$0,%1\")\n \f"}]}