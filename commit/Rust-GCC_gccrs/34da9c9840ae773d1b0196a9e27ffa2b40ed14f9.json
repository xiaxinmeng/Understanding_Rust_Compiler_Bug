{"sha": "34da9c9840ae773d1b0196a9e27ffa2b40ed14f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRkYTljOTg0MGFlNzczZDFiMDE5NmE5ZTI3ZmZhMmI0MGVkMTRmOQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-05-16T10:14:19Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-05-16T10:14:19Z"}, "message": "exp_util.adb (Remove_Side_Effects): Also make a constant if we need to capture the value for a small not...\n\n\t* exp_util.adb (Remove_Side_Effects): Also make a constant if we need\n\tto capture the value for a small not by-reference record type.\n\t* freeze.ads (Check_Compile_Time_Size): Adjust comment.\n\t* freeze.adb (Set_Small_Size): Likewise.  Accept a size in the range\n\tof 33 .. 64 bits.\n\t(Check_Compile_Time_Size): Merge scalar and access type cases. Change\n\tvariable name in array type case.  For the computation of the packed\n\tsize, deal with record components and remove redundant test.\n\t(Freeze_Array_Type): Also adjust packing status when the size of the\n\tcomponent type is in the range 33 .. 64 bits.\n\t* doc/gnat_rm/representation_clauses_and_pragmas.rst: Turn primitive\n\tinto elementary type throughout.  Minor tweaks.\n\t(Alignment Clauses): Document actual alignment of packed array types.\n\t(Pragma Pack for Arrays): List only the 3 main cases and adjust.  Add\n\t\"simple\" to the record case.  Document effect on non packable types.\n\t(Pragma Pack for Records): Likewise.  Add record case and adjust.\n\nFrom-SVN: r236275", "tree": {"sha": "333707cabd2d46ece30f6143925f4c1d23645f49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/333707cabd2d46ece30f6143925f4c1d23645f49"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34da9c9840ae773d1b0196a9e27ffa2b40ed14f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34da9c9840ae773d1b0196a9e27ffa2b40ed14f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34da9c9840ae773d1b0196a9e27ffa2b40ed14f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34da9c9840ae773d1b0196a9e27ffa2b40ed14f9/comments", "author": null, "committer": null, "parents": [{"sha": "0b9004ed5642ab56f97347cc9c5ca9a59a2fb6bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b9004ed5642ab56f97347cc9c5ca9a59a2fb6bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b9004ed5642ab56f97347cc9c5ca9a59a2fb6bb"}], "stats": {"total": 206, "additions": 103, "deletions": 103}, "files": [{"sha": "fc8fe944bf6526dbef4525771bb8ece74d7d8e1a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34da9c9840ae773d1b0196a9e27ffa2b40ed14f9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34da9c9840ae773d1b0196a9e27ffa2b40ed14f9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=34da9c9840ae773d1b0196a9e27ffa2b40ed14f9", "patch": "@@ -1,3 +1,22 @@\n+2016-05-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_util.adb (Remove_Side_Effects): Also make a constant if we need\n+\tto capture the value for a small not by-reference record type.\n+\t* freeze.ads (Check_Compile_Time_Size): Adjust comment.\n+\t* freeze.adb (Set_Small_Size): Likewise.  Accept a size in the range\n+\tof 33 .. 64 bits.\n+\t(Check_Compile_Time_Size): Merge scalar and access type cases. Change\n+\tvariable name in array type case.  For the computation of the packed\n+\tsize, deal with record components and remove redundant test.\n+\t(Freeze_Array_Type): Also adjust packing status when the size of the\n+\tcomponent type is in the range 33 .. 64 bits.\n+\t* doc/gnat_rm/representation_clauses_and_pragmas.rst: Turn primitive\n+\tinto elementary type throughout.  Minor tweaks.\n+\t(Alignment Clauses): Document actual alignment of packed array types.\n+\t(Pragma Pack for Arrays): List only the 3 main cases and adjust.  Add\n+\t\"simple\" to the record case.  Document effect on non packable types.\n+\t(Pragma Pack for Records): Likewise.  Add record case and adjust.\n+\n 2016-05-16  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/Make-lang.in (GNATMAKE_FOR_HOST): In the canadian"}, {"sha": "0a3dd4a91123938d1ee7e24713d7a4042229b80a", "filename": "gcc/ada/doc/gnat_rm/representation_clauses_and_pragmas.rst", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34da9c9840ae773d1b0196a9e27ffa2b40ed14f9/gcc%2Fada%2Fdoc%2Fgnat_rm%2Frepresentation_clauses_and_pragmas.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34da9c9840ae773d1b0196a9e27ffa2b40ed14f9/gcc%2Fada%2Fdoc%2Fgnat_rm%2Frepresentation_clauses_and_pragmas.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Frepresentation_clauses_and_pragmas.rst?ref=34da9c9840ae773d1b0196a9e27ffa2b40ed14f9", "patch": "@@ -32,9 +32,9 @@ GNAT requires that all alignment clauses specify a power of 2, and all\n default alignments are always a power of 2.  The default alignment\n values are as follows:\n \n-* *Primitive Types*.\n+* *Elementary Types*.\n \n-  For primitive types, the alignment is the minimum of the actual size of\n+  For elementary types, the alignment is the minimum of the actual size of\n   objects of the type divided by `Storage_Unit`,\n   and the maximum alignment supported by the target.\n   (This maximum alignment is given by the GNAT-specific attribute\n@@ -53,10 +53,11 @@ values are as follows:\n   For arrays, the alignment is equal to the alignment of the component type\n   for the normal case where no packing or component size is given.  If the\n   array is packed, and the packing is effective (see separate section on\n-  packed arrays), then the alignment will be one for long packed arrays,\n-  or arrays whose length is not known at compile time.  For short packed\n+  packed arrays), then the alignment will be either 4, 2 or 1 for long packed\n+  arrays or arrays whose length is not known at compile time, depending on\n+  whether the component size is divisible by 4, 2 or is odd.  For short packed\n   arrays, which are handled internally as modular types, the alignment\n-  will be as described for primitive types, e.g., a packed array of length\n+  will be as described for elementary types, e.g. a packed array of length\n   31 bits will have an object size of four bytes, and an alignment of 4.\n \n * *Records*.\n@@ -789,7 +790,7 @@ restrictions placed on component clauses as follows:\n   little-endian machines, this must be explicitly programmed.  This capability\n   is not provided by `Bit_Order`.\n \n-* Components that are positioned across byte boundaries\n+* Components that are positioned across byte boundaries.\n \n   but do not occupy an integral number of bytes.  Given that bytes are not\n   reordered, such fields would occupy a non-contiguous sequence of bits\n@@ -1069,22 +1070,23 @@ Pragma Pack for Arrays\n \n .. index:: Pragma Pack (for arrays)\n \n-Pragma `Pack` applied to an array has no effect unless the component type\n-is packable.  For a component type to be packable, it must be one of the\n-following cases:\n+Pragma `Pack` applied to an array has an effect that depends upon whether the\n+component type is *packable*.  For a component type to be *packable*, it must\n+be one of the following cases:\n \n-*\n-  Any scalar type\n-*\n-  Any type whose size is specified with a size clause\n-*\n-  Any packed array type with a static size\n-*\n-  Any record type padded because of its default alignment\n+* Any elementary type.\n+\n+* Any small packed array type with a static size.\n+\n+* Any small simple record type with a static size.\n \n For all these cases, if the component subtype size is in the range\n-1 through 63, then the effect of the pragma `Pack` is exactly as though a\n+1 through 64, then the effect of the pragma `Pack` is exactly as though a\n component size were specified giving the component subtype size.\n+\n+All other types are non-packable, they occupy an integral number of storage\n+units and the only effect of pragma Pack is to remove alignment gaps.\n+\n For example if we have:\n \n .. code-block:: ada\n@@ -1095,7 +1097,7 @@ For example if we have:\n      pragma Pack (ar);\n \n Then the component size of `ar` will be set to 5 (i.e., to `r'size`,\n-and the size of the array `ar` will be exactly 40 bits.\n+and the size of the array `ar` will be exactly 40 bits).\n \n Note that in some cases this rather fierce approach to packing can produce\n unexpected effects.  For example, in Ada 95 and Ada 2005,\n@@ -1184,23 +1186,21 @@ taken by components.  We distinguish between *packable* components and\n *non-packable* components.\n Components of the following types are considered packable:\n \n-*\n-  Components of a primitive type are packable unless they are aliased\n-  or of an atomic type.\n+* Components of an elementary type are packable unless they are aliased,\n+  independent or of an atomic type.\n \n-*\n-  Small packed arrays, whose size does not exceed 64 bits, and where the\n-  size is statically known at compile time, are represented internally\n-  as modular integers, and so they are also packable.\n+* Small packed arrays, where the size is statically known, are represented\n+  internally as modular integers, and so they are also packable.\n \n+* Small simple records, where the size is statically known, are also packable.\n \n-All packable components occupy the exact number of bits corresponding to\n-their `Size` value, and are packed with no padding bits, i.e., they\n-can start on an arbitrary bit boundary.\n+For all these cases, if the 'Size value is in the range 1 through 64, the\n+components occupy the exact number of bits corresponding to this value\n+and are packed with no padding bits, i.e. they can start on an arbitrary\n+bit boundary.\n \n-All other types are non-packable, they occupy an integral number of\n-storage units, and\n-are placed at a boundary corresponding to their alignment requirements.\n+All other types are non-packable, they occupy an integral number of storage\n+units and the only effect of pragma Pack is to remove alignment gaps.\n \n For example, consider the record\n \n@@ -1331,7 +1331,7 @@ so for example, the following is permitted:\n \n Note: the above rules apply to recent releases of GNAT 5.\n In GNAT 3, there are more severe restrictions on larger components.\n-For non-primitive types, including packed arrays with a size greater than\n+For composite types, including packed arrays with a size greater than\n 64 bits, component clauses must respect the alignment requirement of the\n type, in particular, always starting on a byte boundary, and the length\n must be a multiple of the storage unit."}, {"sha": "7dbf44acfe8f15d837aa44544509a4d609ca8078", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34da9c9840ae773d1b0196a9e27ffa2b40ed14f9/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34da9c9840ae773d1b0196a9e27ffa2b40ed14f9/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=34da9c9840ae773d1b0196a9e27ffa2b40ed14f9", "patch": "@@ -7711,15 +7711,22 @@ package body Exp_Util is\n \n       Scope_Suppress.Suppress := (others => True);\n \n-      --  If it is an elementary type and we need to capture the value, just\n-      --  make a constant. Likewise if this is not a name reference, except\n-      --  for a type conversion because we would enter an infinite recursion\n-      --  with Checks.Apply_Predicate_Check if the target type has predicates.\n-      --  And type conversions need a specific treatment anyway, see below.\n-      --  Also do it if we have a volatile reference and Name_Req is not set\n-      --  (see comments for Side_Effect_Free).\n-\n-      if Is_Elementary_Type (Exp_Type)\n+      --  If this is an elementary or a small not by-reference record type, and\n+      --  we need to capture the value, just make a constant; this is cheap and\n+      --  objects of both kinds of types can be bit aligned, so it might not be\n+      --  possible to generate a reference to them. Likewise if this is not a\n+      --  name reference, except for a type conversion because we would enter\n+      --  an infinite recursion with Checks.Apply_Predicate_Check if the target\n+      --  type has predicates (and type conversions need a specific treatment\n+      --  anyway, see below). Also do it if we have a volatile reference and\n+      --  Name_Req is not set (see comments for Side_Effect_Free).\n+\n+      if (Is_Elementary_Type (Exp_Type)\n+           or else (Is_Record_Type (Exp_Type)\n+                     and then Known_Static_RM_Size (Exp_Type)\n+                     and then RM_Size (Exp_Type) <= 64\n+                     and then not Has_Discriminants (Exp_Type)\n+                     and then not Is_By_Reference_Type (Exp_Type)))\n         and then (Variable_Ref\n                    or else (not Is_Name_Reference (Exp)\n                              and then Nkind (Exp) /= N_Type_Conversion)"}, {"sha": "d7d9b36045085809aed9385b1f3942012ee54669", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 29, "deletions": 55, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34da9c9840ae773d1b0196a9e27ffa2b40ed14f9/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34da9c9840ae773d1b0196a9e27ffa2b40ed14f9/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=34da9c9840ae773d1b0196a9e27ffa2b40ed14f9", "patch": "@@ -745,9 +745,9 @@ package body Freeze is\n    procedure Check_Compile_Time_Size (T : Entity_Id) is\n \n       procedure Set_Small_Size (T : Entity_Id; S : Uint);\n-      --  Sets the compile time known size (32 bits or less) in the Esize\n-      --  field, of T checking for a size clause that was given which attempts\n-      --  to give a smaller size, and also checking for an alignment clause.\n+      --  Sets the compile time known size (64 bits or less) in the RM_Size\n+      --  field of T, checking for a size clause that was given which attempts\n+      --  to give a smaller size.\n \n       function Size_Known (T : Entity_Id) return Boolean;\n       --  Recursive function that does all the work\n@@ -765,7 +765,7 @@ package body Freeze is\n \n       procedure Set_Small_Size (T : Entity_Id; S : Uint) is\n       begin\n-         if S > 32 then\n+         if S > 64 then\n             return;\n \n          --  Check for bad size clause given\n@@ -800,14 +800,12 @@ package body Freeze is\n          if Size_Known_At_Compile_Time (T) then\n             return True;\n \n-         --  Always True for scalar types. This is true even for generic formal\n-         --  scalar types. We used to return False in the latter case, but the\n-         --  size is known at compile time, even in the template, we just do\n-         --  not know the exact size but that's not the point of this routine.\n+         --  Always True for elementary types, even generic formal elementary\n+         --  types. We used to return False in the latter case, but the size\n+         --  is known at compile time, even in the template, we just do not\n+         --  know the exact size but that's not the point of this routine.\n \n-         elsif Is_Scalar_Type (T)\n-           or else Is_Task_Type (T)\n-         then\n+         elsif Is_Elementary_Type (T) or else Is_Task_Type (T) then\n             return True;\n \n          --  Array types\n@@ -817,8 +815,8 @@ package body Freeze is\n             --  String literals always have known size, and we can set it\n \n             if Ekind (T) = E_String_Literal_Subtype then\n-               Set_Small_Size (T, Component_Size (T)\n-                               * String_Literal_Length (T));\n+               Set_Small_Size\n+                 (T, Component_Size (T) * String_Literal_Length (T));\n                return True;\n \n             --  Unconstrained types never have known at compile time size\n@@ -839,10 +837,10 @@ package body Freeze is\n             end if;\n \n             --  Check for all indexes static, and also compute possible size\n-            --  (in case it is less than 32 and may be packable).\n+            --  (in case it is not greater than 64 and may be packable).\n \n             declare\n-               Esiz : Uint := Component_Size (T);\n+               Size : Uint := Component_Size (T);\n                Dim  : Uint;\n \n             begin\n@@ -869,24 +867,19 @@ package body Freeze is\n                      Dim := Expr_Value (High) - Expr_Value (Low) + 1;\n \n                      if Dim >= 0 then\n-                        Esiz := Esiz * Dim;\n+                        Size := Size * Dim;\n                      else\n-                        Esiz := Uint_0;\n+                        Size := Uint_0;\n                      end if;\n                   end if;\n \n                   Next_Index (Index);\n                end loop;\n \n-               Set_Small_Size (T, Esiz);\n+               Set_Small_Size (T, Size);\n                return True;\n             end;\n \n-         --  Access types always have known at compile time sizes\n-\n-         elsif Is_Access_Type (T) then\n-            return True;\n-\n          --  For non-generic private types, go to underlying type if present\n \n          elsif Is_Private_Type (T)\n@@ -1074,45 +1067,25 @@ package body Freeze is\n \n                   if Packed_Size_Known then\n \n-                     --  We can only deal with elementary types, since for\n-                     --  non-elementary components, alignment enters into the\n-                     --  picture, and we don't know enough to handle proper\n-                     --  alignment in this context. Packed arrays count as\n-                     --  elementary if the representation is a modular type.\n+                     --  We can deal with elementary types, small packed arrays\n+                     --  if the representation is a modular type and also small\n+                     --  record types (if the size is not greater than 64, but\n+                     --  the condition is checked by Set_Small_Size).\n \n                      if Is_Elementary_Type (Ctyp)\n                        or else (Is_Array_Type (Ctyp)\n                                  and then Present\n                                             (Packed_Array_Impl_Type (Ctyp))\n                                  and then Is_Modular_Integer_Type\n                                             (Packed_Array_Impl_Type (Ctyp)))\n+                       or else Is_Record_Type (Ctyp)\n                      then\n-                        --  Packed size unknown if we have an atomic/VFA type\n-                        --  or a by-reference type, since the back end knows\n-                        --  how these are layed out.\n-\n-                        if Is_Atomic_Or_VFA (Ctyp)\n-                          or else Is_By_Reference_Type (Ctyp)\n-                        then\n-                           Packed_Size_Known := False;\n-\n                         --  If RM_Size is known and static, then we can keep\n-                        --  accumulating the packed size\n-\n-                        elsif Known_Static_RM_Size (Ctyp) then\n-\n-                           --  A little glitch, to be removed sometime ???\n-                           --  gigi does not understand zero sizes yet.\n+                        --  accumulating the packed size.\n \n-                           if RM_Size (Ctyp) = Uint_0 then\n-                              Packed_Size_Known := False;\n+                        if Known_Static_RM_Size (Ctyp) then\n \n-                           --  Normal case where we can keep accumulating the\n-                           --  packed array size.\n-\n-                           else\n-                              Packed_Size := Packed_Size + RM_Size (Ctyp);\n-                           end if;\n+                           Packed_Size := Packed_Size + RM_Size (Ctyp);\n \n                         --  If we have a field whose RM_Size is not known then\n                         --  we can't figure out the packed size here.\n@@ -1121,8 +1094,7 @@ package body Freeze is\n                            Packed_Size_Known := False;\n                         end if;\n \n-                     --  If we have a non-elementary type we can't figure out\n-                     --  the packed array size (alignment issues).\n+                     --  For other types we can't figure out the packed size\n \n                      else\n                         Packed_Size_Known := False;\n@@ -2475,13 +2447,15 @@ package body Freeze is\n                      end if;\n \n                      --  Actual packing is not needed for 8, 16, 32, 64. Also\n-                     --  not needed for 24 if alignment is 1.\n+                     --  not needed for multiples of 8 if alignment is 1, and\n+                     --  for multiples of 16 (i.e. only 48) if alignment is 2.\n \n                      if        Csiz = 8\n                        or else Csiz = 16\n                        or else Csiz = 32\n                        or else Csiz = 64\n-                       or else (Csiz = 24 and then Alignment (Ctyp) = 1)\n+                       or else (Csiz mod 8 = 0 and then Alignment (Ctyp) = 1)\n+                       or else (Csiz = 48 and then Alignment (Ctyp) = 2)\n                      then\n                         --  Here the array was requested to be packed, but\n                         --  the packing request had no effect, so Is_Packed"}, {"sha": "079d7132abe9b343930f38ab19376c56f9288cd7", "filename": "gcc/ada/freeze.ads", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34da9c9840ae773d1b0196a9e27ffa2b40ed14f9/gcc%2Fada%2Ffreeze.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34da9c9840ae773d1b0196a9e27ffa2b40ed14f9/gcc%2Fada%2Ffreeze.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.ads?ref=34da9c9840ae773d1b0196a9e27ffa2b40ed14f9", "patch": "@@ -151,15 +151,15 @@ package Freeze is\n    --    fact Gigi decides it is known, but the opposite situation can never\n    --    occur.\n    --\n-   --    Size is known at compile time, but the actual value of the size is\n-   --    not known to the front end or is definitely 32 or more. In this case\n-   --    Size_Known_At_Compile_Time is set, but the Esize field is left set\n+   --    Size is known at compile time, but the actual value of the size is not\n+   --    known to the front end or is definitely greater than 64. In this case,\n+   --    Size_Known_At_Compile_Time is set, but the RM_Size field is left set\n    --    to zero (to be set by Gigi).\n    --\n    --    Size is known at compile time, and the actual value of the size is\n-   --    known to the front end and is less than 32. In this case, the flag\n-   --    Size_Known_At_Compile_Time is set, and in addition Esize is set to\n-   --    the required size, allowing for possible front end packing of an\n+   --    known to the front end and is not greater than 64. In this case, the\n+   --    flag Size_Known_At_Compile_Time is set, and in addition RM_Size is set\n+   --    to the required size, allowing for possible front end packing of an\n    --    array using this type as a component type.\n    --\n    --  Note: the flag Size_Known_At_Compile_Time is used to determine if the"}]}