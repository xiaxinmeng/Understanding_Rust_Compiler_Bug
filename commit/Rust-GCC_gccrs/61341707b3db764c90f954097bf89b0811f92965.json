{"sha": "61341707b3db764c90f954097bf89b0811f92965", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjEzNDE3MDdiM2RiNzY0YzkwZjk1NDA5N2JmODliMDgxMWY5Mjk2NQ==", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@gcc.gnu.org", "date": "2004-09-02T06:58:08Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@gcc.gnu.org", "date": "2004-09-02T06:58:08Z"}, "message": "missing added files from merge\n\nFrom-SVN: r86958", "tree": {"sha": "57dc5b899889b3288ee8c497478f985857cfcd2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57dc5b899889b3288ee8c497478f985857cfcd2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61341707b3db764c90f954097bf89b0811f92965", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61341707b3db764c90f954097bf89b0811f92965", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61341707b3db764c90f954097bf89b0811f92965", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61341707b3db764c90f954097bf89b0811f92965/comments", "author": null, "committer": null, "parents": [{"sha": "9969aaf67e4c806bc58a5b110f6a0849365eee05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9969aaf67e4c806bc58a5b110f6a0849365eee05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9969aaf67e4c806bc58a5b110f6a0849365eee05"}], "stats": {"total": 10202, "additions": 10202, "deletions": 0}, "files": [{"sha": "111c9a801cb5a1b00d8e034eb0bbd70a600a11ad", "filename": "libjava/gnu/java/awt/peer/gtk/GThreadMutex.java", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGThreadMutex.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGThreadMutex.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGThreadMutex.java?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,109 @@\n+/* GThreadMutex.java -- Implements a mutex object for glib's gthread\n+   abstraction, for use with GNU Classpath's --portable-native-sync option.\n+   This is used in gthread-jni.c\n+   \n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.awt.peer.gtk;\n+\n+/** Implements a mutex object for glib's gthread\n+    abstraction, for use with GNU Classpath's --portable-native-sync option.\n+    This is used in gthread-jni.c.\n+\n+    We use this object to implement the POSIX semantics for Mutexes.  They are\n+    needed are needed for the function vector that is passed to glib's\n+    g_thread subpackage's initialization function.\n+\n+    The GThreadMutex object itself serves as the Real Lock; if code has\n+    entered the monitor for this GThreadMutex object (in Java language, if\n+    it's synchronized on this object) then it holds the lock that this object\n+    represents.\n+\n+    @author Steven Augart\n+    May, 2004\n+\n+    \n+*/\n+   \n+class GThreadMutex \n+{\n+  /** Might \"lock\" be locked?  Is anyone waiting\n+      to get that lock?  How long is the queue?\n+\n+      If zero, nobody holds a lock on this GThreadMutex object, and nobody is\n+      trying to get one.   Before someone attempts to acquire a lock on this\n+      object, they must increment potentialLockers.  After they release their\n+      lock on this object, they must decrement potentialLockers.\n+\n+      Access to this field is guarded by synchronizing on the object\n+      <code>lockForPotentialLockers</code>.\n+\n+      After construction, we only access this field via JNI.\n+  */\n+  volatile int potentialLockers;\n+\n+  /** An object to synchronize to if you want to examine or modify the\n+      <code>potentialLockers</code> field.  Only hold this lock for brief\n+      moments, just long enough to check or set the value of\n+      <code>lockForPotentialLockers</code>.  \n+      \n+      We use this representation so that g_thread_mutex_trylock() will work\n+      with the POSIX semantics.  This is the only case in which you ever hold a\n+      lock on <code>lockForPotentialLockers</code> while trying to get another\n+      lock -- if you are the mutex_trylock() implementation, and you have just\n+      checked that <code>potentialLockers</code> has the value zero.  In that\n+      case, mutex_trylock() holds the lock on lockForPotentialLockers so that\n+      another thread calling mutex_trylock() or mutex_lock() won't increment\n+      potentialLockers after we've checked it and before we've gained the lock\n+      on the POSIX mutex.   Of course, in that case the operation of gaining\n+      the POSIX lock itself will succeed immediately, and once it has\n+      succeeded, trylock releases lockForPotentialLockers right away,\n+      incremented to 1 (one).\n+\n+      After construction, we only access this field via JNI.\n+  */     \n+  Object lockForPotentialLockers;\n+\n+  GThreadMutex() \n+  {\n+    potentialLockers = 0;\n+    lockForPotentialLockers = new Object();\n+  }\n+}\n+// Local Variables:\n+// c-file-style: \"gnu\"\n+// End:"}, {"sha": "a4cb35a4fff1ea20ee4d7239f0d86e189154ab50", "filename": "libjava/gnu/java/awt/peer/gtk/GThreadNativeMethodRunner.java", "status": "added", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGThreadNativeMethodRunner.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGThreadNativeMethodRunner.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGThreadNativeMethodRunner.java?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,302 @@\n+/* GThreadNativeMethodRunner.java -- Implements pthread_create(), under\n+   glib's gthread abstraction, for use with GNU Classpath's\n+   --portable-native-sync option. \n+   This is used by gthread-jni.c\n+   \n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.awt.peer.gtk;\n+import java.lang.ref.WeakReference;\n+import java.util.Set;\n+import java.util.Collections;\n+import java.util.HashSet;\n+\n+/** Implements pthread_create(), under glib's gthread abstraction, for use\n+    with GNU Classpath's --portable-native-sync option.  This is used in\n+    gthread-jni.c\n+\n+    Also implements a registry for threads, mapping Thread objects to small\n+    integers.  The registry uses weak references for threads that aren't\n+    joinable, so that they will be garbage collected.\n+\n+    There are a number of possible alternative implementations.\n+    \n+    \n+    The rest of this comment consists of an answer to a question that was\n+    raised on the commit-classpath mailing list:\n+\n+    Mark Wielaard wrote:\n+\n+    > Can't we assume that jobject and gpointer are both (void *) so we don't\n+    > need the int <-> Thread (global jobject ref) mapping?\n+    > Maybe there are platforms where jobject and gpointer aren't the same,\n+    > but I guess that is pretty unlikely.\n+\n+\n+    I agree with you on the pointer size issues.  A gpointer is a void *, so\n+    it's certainly guaranteed to be at least as large as any other\n+    pointer. And a jobject is implicitly an opaque pointer (in Jikes RVM, we\n+    use small integers, but we coerce them into the representation of a\n+    pointer).\n+\n+    The int <==> Thread mapping addresses a different issue.  I realize that I\n+    did not document this properly (two and a half lines in thread_create),\n+    and the point is subtle (at least to me; took me a while to figure out).\n+\n+    The int => Thread mapping always returns jobjects that are local\n+    references, not global ones.  This is because Thread objects need to be\n+    able to go away and be garbage collected after the thread they refer to\n+    has died.\n+\n+    If we keep a global object reference to a thread, then when do we delete\n+    that global object reference?  We have an answer in the case of GThread\n+    objects that were explicitly created with the joinable attribute.  It is\n+    safe for us to maintain a global reference to any joinable thread, since\n+    the joinable thread must linger (even if only in a zombie state)\n+    until it's explicitly joined via a g_thread_join() call.  The global ref\n+    could be cleaned up at that point too.\n+\n+    However, in the case of GThreads that were created non-joinable by\n+    g_thread_create(), and in the case of Java threads that were created\n+    within pure Java code (not via g_thread_create()), we don't want them to\n+    linger forever, and there is no way to tell when the last reference\n+    to such threads needs to expire.  In the case of this application -- AWT\n+    with GTK peers -- it would probably be safe anyway, since there are not\n+    very many threads we create, but I was going for correctness even in the\n+    case of long-running programs that might set up and tear down AWT\n+    interfaces many times.\n+\n+    So, I duplicated the POSIX thread-ID semantics.  The thread ID of a\n+    non-joinable thread remains valid as long as that thread is still alive.\n+    Once that thread dies, the old thread ID may be reused at any moment.  And\n+    that's why the array indexed by thread ID numbers is an array of weak\n+    references.\n+\n+    That's also why the int => Thread jobject mapping function always returns\n+    local references, since global references would lock the Thread in memory\n+    forever.\n+\n+    I would dearly love there to be a cleaner solution.  I dislike the\n+    repeated dips from C code into Java that are necessary to look up thread\n+    ID numbers.  If anyone can think of one, I'm all ears.\n+*/\n+\n+class GThreadNativeMethodRunner \n+  extends Thread \n+{\n+  /** The C function pointer that was passed to g_thread_create().\n+      Specifically, this the numeric address of an object of \n+      C type \"void *(*funcPtr)(void *funcArg)\".   \n+  */\n+  private final long funcPtr;\n+\n+  /** The argument for the function \"funcPtr(funcArg)\". */\n+  private final long funcArg;\n+  \n+  GThreadNativeMethodRunner(long funcPtr, long funcArg, boolean joinable) \n+  {\n+    this.funcPtr = funcPtr;\n+    this.funcArg = funcArg;\n+\n+    if (joinable)\n+      registerSelfJoinable();\n+  }\n+\n+  public void run() \n+  {\n+    nativeRun(funcPtr, funcArg);\n+  }\n+\n+  private native void nativeRun(long funcPtr, long funcArg);\n+\n+  /** THREADS is an array of threads, indexed by thread ID codes.  Not sure\n+      whether this is the \"best\" approach but it does make it O(1) to look up a\n+      thread by its ID. \n+\n+      Zero is a valid thread ID code.  Any negative number is invalid.\n+\n+      Possible future fixes (TODO?)\n+\n+     - The THREADS array will only grow. probably not a problem.\n+        But we could keep count when nulling entries and shrink when we have\n+        lots of nulls at the end. Probably not worth it. --mjw\n+\n+     - Could make this a set of Object; see the comment on \"joinable\" below.\n+\n+     The initial size of 17 is just a starting point.  Any number will do,\n+     including zero.\n+  */ \n+  private static WeakReference[] threads = new WeakReference[17]; \n+\n+  /**  Used by threadToThreadID, below.  Returns the registration number of\n+       the newly-registered thread.  \n+  */\n+  private static synchronized int registerThread(Thread t) \n+  {\n+    int i;\n+\n+    for (i = 0; i < threads.length; ++i) \n+      {\n+\tWeakReference ref = threads[i];\n+\tif (ref == null)\n+\t  break;                  // found an empty spot.\n+      }\n+\n+    if (i == threads.length) \n+      {\n+\t/* expand the array */\n+\tWeakReference[] bigger = new WeakReference[threads.length * 2];\n+        System.arraycopy(threads, 0, bigger, 0, threads.length);\n+\tthreads = bigger;\n+      }\n+\n+    threads[i] = new WeakReference(t);\n+\n+    return i;\n+  }\n+  \n+  /**  Look up the Thread ID # for a Thread.  Assign a Thread ID # if none\n+       exists.  This is a general routine for handling all threads, including\n+       the VM's main thread, if appropriate.\n+\n+\n+       Runs in O(n/2) time.\n+\n+       We can't just issue a threadID upon thread creation.  If we were to do\n+       that, not all threads would have a threadID, because not all threads\n+       are launched by GThreadNativeMethodRunner.\n+  */ \n+  static synchronized int threadToThreadID(Thread t) \n+  {\n+    for (int i = 0; i < threads.length; ++i ) \n+      {\n+\tif (threads[i] == null)\n+\t  continue;\n+\tThread referent = (Thread) threads[i].get();\n+\tif (referent == null) \n+\t  {\n+\t    threads[i] = null;      // Purge the dead WeakReference.\n+\t    continue;\n+\t  }\n+\tif (referent.equals(t))\n+\t  return i;\n+      } // for()\n+\n+    /* No match found. */\n+    return registerThread(t);\n+  }\n+\n+  /** @param threadID Must be a non-negative integer.\n+\n+      Used to return null if the thread number was out of range or if\n+      the thread was unregistered.   Now we throw an exception.\n+\n+      Possible Alternative Interface:  We could go back to returning null in\n+           some sort of check-free mode, so code that calls this function must\n+           be prepared to get null. \n+  */ \n+  static Thread threadIDToThread(int threadID) \n+    throws IllegalArgumentException\n+  {\n+    if (threadID < 0)\n+      throw new IllegalArgumentException(\"Received a negative threadID, \" \n+\t\t\t\t\t + threadID); \n+    if (threadID >= threads.length)\n+      throw new IllegalArgumentException(\"Received a threadID (\" + threadID \n+\t\t\t\t\t + \") higher than was\" \n+\t\t\t\t\t + \" ever issued\"); \n+    \n+    /* Note: if the user is using a stale reference, things will just\n+       break.    We might end up getting a different thread than the one\n+       expected. \n+       \n+       TODO: Add an error-checking mode where the user's problems with threads\n+          are announced.  For instance, if the user asks for the thread\n+          associated with a threadID that was never issued, we could print a\n+          warning or even abort.\n+       \n+       TODO: Consider optionally disabling all of the error-checking we\n+          already have; it probably slows down the implementation.  We could\n+          just return NULL.  This is just the reverse of the above TODO item.\n+    */ \n+\n+    WeakReference threadRef = threads[threadID];\n+\n+    if (threadRef == null)\n+      throw new IllegalArgumentException(\"Asked to look up a stale or unissued\"\n+\t\t\t\t\t + \"threadID (\" + threadID + \")\" );\n+    \n+      \n+    Thread referent = (Thread) threadRef.get();\n+    if (referent == null)\n+      throw new IllegalArgumentException (\"Asked to look up a stale threadID (\"\n+\t\t\t\t\t  + threadID + \")\");\n+    return referent;\n+  }\n+  \n+  /** Joinable threads need a hard reference, so that they won't go away when\n+      they die.  That is because their thread IDs need to stay valid until the\n+      thread is joined via thread_join(threadID).  Joinable threads have to be\n+      explicitly joined before they are allowed to go away completely.\n+\n+      Possible Alternative Implementation: Eliminate the Joinable set.  When\n+          calling getThreadIDFromThread() you know whether or not the thread\n+          is joinable.  So just store the Thread itself in the threads array?\n+          Make that array an Object array and check with instanceof.  This\n+          looks cleaner and more robust to me and it saves a native -> Java\n+          call. But instanceof might be expensive.  --mjw\n+  */\n+  private static final Set joinable = \n+       Collections.synchronizedSet(new HashSet()); \n+  \n+  /** Only called from the constructor. */\n+  private void registerSelfJoinable() \n+  {\n+    joinable.add(this);\n+  }\n+  \n+  /** This method is only called from JNI, and only after we have succeeded in\n+      a thread_join() operation.  */\n+  static void deRegisterJoinable(Thread thread) \n+  {\n+    joinable.remove(thread);\n+  }\n+}\n+\f\n+// Local Variables:\n+// c-file-style: \"gnu\"\n+// End:"}, {"sha": "d2d345b8e14dec82bc243390bf3abce72f3b5e53", "filename": "libjava/javax/swing/AbstractSpinnerModel.java", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2FAbstractSpinnerModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2FAbstractSpinnerModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FAbstractSpinnerModel.java?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,115 @@\n+/* AbstractSpinnerModel.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing;\n+\n+import java.util.EventListener;\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n+import javax.swing.event.EventListenerList;\n+\n+/**\n+ * AbstractSpinnerModel\n+ * @author\tKa-Hing Cheung\n+ * @version\t1.0\n+ */\n+public abstract class AbstractSpinnerModel implements SpinnerModel\n+{\n+  private ChangeEvent changeEvent = new ChangeEvent(this);\n+  \n+  protected EventListenerList listenerList = new EventListenerList();\n+\n+  /**\n+   * Creates an <code>AbstractSpinnerModel</code>.\n+   */\n+  public AbstractSpinnerModel()\n+  {\n+  }\n+\n+  /**\n+   * Adds a <code>ChangeListener</code>.\n+   *\n+   * @param listener the listener to add\n+   */\n+  public void addChangeListener(ChangeListener listener)\n+  {\n+    listenerList.add(ChangeListener.class, listener);\n+  }\n+\n+  /**\n+   * Gets all the listeners that are of a particular type.\n+   *\n+   * @param c the type of listener\n+   * @return the listeners that are of the specific type\n+   */\n+  public EventListener[] getListeners(Class c)\n+  {\n+    return listenerList.getListeners(c);\n+  }\n+\n+  /**\n+   * Gets all the <code>ChangeListener</code>s.\n+   *\n+   * @return all the <code>ChangeListener</code>s\n+   */\n+  public ChangeListener[] getChangeListeners()\n+  {\n+    return (ChangeListener[]) listenerList.getListeners(ChangeListener.class);\n+  }\n+\n+  /**\n+   * Remove a particular listener.\n+   *\n+   * @param listener the listener to remove\n+   */\n+  public void removeChangeListener(ChangeListener listener)\n+  {\n+    listenerList.remove(ChangeListener.class, listener);\n+  }\n+\n+  /**\n+   * Fires a <code>ChangeEvent</code> to all the <code>ChangeListener</code>s\n+   * added to this model\n+   */\n+  protected void fireStateChanged()\n+  {\n+    ChangeListener[] listeners = getChangeListeners();\n+\n+    for(int i = 0; i < listeners.length; ++i)\n+      listeners[i].stateChanged(changeEvent);\n+  }\n+}"}, {"sha": "00b22d5a6704248f19ac8091e27061cfcc299cbe", "filename": "libjava/javax/swing/JSpinner.java", "status": "added", "additions": 482, "deletions": 0, "changes": 482, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2FJSpinner.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2FJSpinner.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJSpinner.java?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,482 @@\n+/* JSpinner.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing;\n+\n+import java.awt.BorderLayout;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.LayoutManager;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.text.DecimalFormat;\n+import java.text.ParseException;\n+import java.util.EventListener;\n+import javax.swing.border.EtchedBorder;\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n+import javax.swing.event.EventListenerList;\n+import javax.swing.plaf.SpinnerUI;\n+\n+\n+/**\n+ * A JSpinner is a component which typically contains a numeric value and a\n+ * way to manipulate the value.\n+ *\n+ * @author Ka-Hing Cheung\n+ * @version 1.0\n+ */\n+public class JSpinner extends JComponent\n+{\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  public static class StubEditor extends JLabel implements ChangeListener\n+  {\n+    /** DOCUMENT ME! */\n+    private JLabel label;\n+\n+    /** DOCUMENT ME! */\n+    private JButton up;\n+\n+    /** DOCUMENT ME! */\n+    private JButton down;\n+\n+    /** DOCUMENT ME! */\n+    private JSpinner spinner;\n+\n+    /**\n+     * Creates a new StubEditor object.\n+     *\n+     * @param spinner DOCUMENT ME!\n+     */\n+    public StubEditor(JSpinner spinner)\n+    {\n+      this.spinner = spinner;\n+      setBorder(new EtchedBorder());\n+      setHorizontalAlignment(SwingConstants.TRAILING);\n+      stateChanged(null); /* fill in the label */\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param evt DOCUMENT ME!\n+     */\n+    public void stateChanged(ChangeEvent evt)\n+    {\n+      setText(String.valueOf(spinner.getValue()));\n+    }\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  public static class DefaultEditor extends JPanel implements ChangeListener,\n+                                                              PropertyChangeListener,\n+                                                              LayoutManager\n+  {\n+    /**\n+     * Creates a new DefaultEditor object.\n+     *\n+     * @param spinner DOCUMENT ME!\n+     */\n+    public DefaultEditor(JSpinner spinner)\n+    {\n+      spinner.addChangeListener(this);\n+    } /* TODO */\n+    /**\n+     * DOCUMENT ME!\n+     */\n+    public void commitEdit()\n+    {\n+    } /* TODO */\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param spinner DOCUMENT ME!\n+     */\n+    public void dismiss(JSpinner spinner)\n+    {\n+      spinner.removeChangeListener(this);\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public JFormattedTextField getTextField()\n+    {\n+      return null;\n+    } /* TODO */\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param parent DOCUMENT ME!\n+     */\n+    public void layoutContainer(Container parent)\n+    {\n+    } /* TODO */\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param parent DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public Dimension minimumLayoutSize(Container parent)\n+    {\n+      return null;\n+    } /* TODO */\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param parent DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public Dimension preferredLayoutSize(Container parent)\n+    {\n+      return null;\n+    } /* TODO */\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param evt DOCUMENT ME!\n+     */\n+    public void propertyChange(PropertyChangeEvent evt)\n+    {\n+    } /* TODO */\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param evt DOCUMENT ME!\n+     */\n+    public void stateChanged(ChangeEvent evt)\n+    {\n+    } /* TODO */\n+    /* no-ops */\n+    public void removeLayoutComponent(Component child)\n+    {\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param name DOCUMENT ME!\n+     * @param child DOCUMENT ME!\n+     */\n+    public void addLayoutComponent(String name, Component child)\n+    {\n+    }\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  public static class NumberEditor extends DefaultEditor\n+  {\n+    /**\n+     * Creates a new NumberEditor object.\n+     *\n+     * @param spinner DOCUMENT ME!\n+     */\n+    public NumberEditor(JSpinner spinner)\n+    {\n+      super(spinner);\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public DecimalFormat getFormat()\n+    {\n+      return null;\n+    }\n+  }\n+\n+  /** DOCUMENT ME! */\n+  private SpinnerModel model;\n+\n+  /** DOCUMENT ME! */\n+  private JComponent editor;\n+\n+  /** DOCUMENT ME! */\n+  private EventListenerList listenerList = new EventListenerList();\n+\n+  /** DOCUMENT ME! */\n+  private ChangeListener listener = new ChangeListener()\n+    {\n+      public void stateChanged(ChangeEvent evt)\n+      {\n+\tfireStateChanged();\n+      }\n+    };\n+\n+  /**\n+   * Creates a JSpinner with <code>SpinnerNumberModel</code>\n+   *\n+   * @see javax.swing.SpinnerNumberModel\n+   */\n+  public JSpinner()\n+  {\n+    this(new SpinnerNumberModel());\n+  }\n+\n+  /**\n+   * Creates a JSpinner with the specific model and sets the default editor\n+   *\n+   * @param model DOCUMENT ME!\n+   */\n+  public JSpinner(SpinnerModel model)\n+  {\n+    this.model = model;\n+    model.addChangeListener(listener);\n+    setEditor(createEditor(model));\n+    updateUI();\n+  }\n+\n+  /**\n+   * If the editor is <code>JSpinner.DefaultEditor</code>, then forwards the\n+   * call to it, otherwise do nothing.\n+   *\n+   * @throws ParseException DOCUMENT ME!\n+   */\n+  public void commitEdit() throws ParseException\n+  {\n+    if (editor instanceof DefaultEditor)\n+      ((DefaultEditor) editor).commitEdit();\n+  }\n+\n+  /**\n+   * Gets the current editor\n+   *\n+   * @return the current editor\n+   *\n+   * @see #setEditor\n+   */\n+  public JComponent getEditor()\n+  {\n+    return editor;\n+  }\n+\n+  /**\n+   * Changes the current editor to the new editor. This methods should remove\n+   * the old listeners (if any) and adds the new listeners (if any).\n+   *\n+   * @param editor the new editor\n+   *\n+   * @throws IllegalArgumentException DOCUMENT ME!\n+   *\n+   * @see #getEditor\n+   */\n+  public void setEditor(JComponent editor)\n+  {\n+    if (editor == null)\n+      throw new IllegalArgumentException(\"editor may not be null\");\n+\n+    if (this.editor instanceof DefaultEditor)\n+      ((DefaultEditor) editor).dismiss(this);\n+    else if (this.editor instanceof ChangeListener)\n+      removeChangeListener((ChangeListener) this.editor);\n+\n+    if (editor instanceof ChangeListener)\n+      addChangeListener((ChangeListener) editor);\n+\n+    this.editor = editor;\n+  }\n+\n+  /**\n+   * Gets the underly model.\n+   *\n+   * @return the underly model\n+   */\n+  public SpinnerModel getModel()\n+  {\n+    return model;\n+  }\n+\n+  /**\n+   * Gets the next value without changing the current value.\n+   *\n+   * @return the next value\n+   *\n+   * @see javax.swing.SpinnerModel#getNextValue\n+   */\n+  public Object getNextValue()\n+  {\n+    return model.getNextValue();\n+  }\n+\n+  /**\n+   * Gets the previous value without changing the current value.\n+   *\n+   * @return the previous value\n+   *\n+   * @see javax.swing.SpinnerModel#getPreviousValue\n+   */\n+  public Object getPreviousValue()\n+  {\n+    return model.getPreviousValue();\n+  }\n+\n+  /**\n+   * Gets the <code>SpinnerUI</code> that handles this spinner\n+   *\n+   * @return the <code>SpinnerUI</code>\n+   */\n+  public SpinnerUI getUI()\n+  {\n+    return (SpinnerUI) ui;\n+  }\n+\n+  /**\n+   * Gets the current value of the spinner, according to the underly model,\n+   * not the UI.\n+   *\n+   * @return the current value\n+   *\n+   * @see javax.swing.SpinnerModel#getValue\n+   */\n+  public Object getValue()\n+  {\n+    return model.getValue();\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param value DOCUMENT ME!\n+   */\n+  public void setValue(Object value)\n+  {\n+    model.setValue(value);\n+  }\n+\n+  /**\n+   * This method returns a name to identify which look and feel class will be\n+   * the UI delegate for this spinner.\n+   *\n+   * @return The UIClass identifier. \"SpinnerUI\"\n+   */\n+  public String getUIClassID()\n+  {\n+    return \"SpinnerUI\";\n+  }\n+\n+  /**\n+   * This method resets the spinner's UI delegate to the default UI for the\n+   * current look and feel.\n+   */\n+  public void updateUI()\n+  {\n+    setUI((SpinnerUI) UIManager.getUI(this));\n+  }\n+\n+  /**\n+   * This method sets the spinner's UI delegate.\n+   *\n+   * @param ui The spinner's UI delegate.\n+   */\n+  public void setUI(SpinnerUI ui)\n+  {\n+    super.setUI(ui);\n+  }\n+\n+  /**\n+   * Adds a <code>ChangeListener</code>\n+   *\n+   * @param listener the listener to add\n+   */\n+  public void addChangeListener(ChangeListener listener)\n+  {\n+    listenerList.add(ChangeListener.class, listener);\n+  }\n+\n+  /**\n+   * Remove a particular listener\n+   *\n+   * @param listener the listener to remove\n+   */\n+  public void removeChangeListener(ChangeListener listener)\n+  {\n+    listenerList.remove(ChangeListener.class, listener);\n+  }\n+\n+  /**\n+   * Gets all the <code>ChangeListener</code>s\n+   *\n+   * @return all the <code>ChangeListener</code>s\n+   */\n+  public ChangeListener[] getChangeListeners()\n+  {\n+    return (ChangeListener[]) listenerList.getListeners(ChangeListener.class);\n+  }\n+\n+  /**\n+   * Fires a <code>ChangeEvent</code> to all the <code>ChangeListener</code>s\n+   * added to this <code>JSpinner</code>\n+   */\n+  protected void fireStateChanged()\n+  {\n+    ChangeEvent evt = new ChangeEvent(this);\n+    ChangeListener[] listeners = getChangeListeners();\n+\n+    for (int i = 0; i < listeners.length; ++i)\n+      listeners[i].stateChanged(evt);\n+  }\n+\n+  /**\n+   * Creates an editor for this <code>JSpinner</code>. Really, it should be a\n+   * <code>JSpinner.DefaultEditor</code>, but since that should be\n+   * implemented by a JFormattedTextField, and one is not written, I am just\n+   * using a dummy one backed by a JLabel.\n+   *\n+   * @param model DOCUMENT ME!\n+   *\n+   * @return the default editor\n+   */\n+  protected JComponent createEditor(SpinnerModel model)\n+  {\n+    return new StubEditor(this);\n+  } /* TODO */}"}, {"sha": "18588b51b76ada3b91f4ab85b8d2e47597655a59", "filename": "libjava/javax/swing/SpinnerNumberModel.java", "status": "added", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2FSpinnerNumberModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2FSpinnerNumberModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FSpinnerNumberModel.java?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,241 @@\n+/* SpinnerNumberModel.java --\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing;\n+\n+/**\n+ * SpinnerNumberModel\n+ *\n+ * @author Ka-Hing Cheung\n+ * @version 1.0\n+ */\n+public class SpinnerNumberModel extends AbstractSpinnerModel\n+{\n+  /** DOCUMENT ME! */\n+  private Number value;\n+\n+  /** DOCUMENT ME! */\n+  private Comparable minimum;\n+\n+  /** DOCUMENT ME! */\n+  private Comparable maximum;\n+\n+  /** DOCUMENT ME! */\n+  private Number stepSize;\n+\n+  /**\n+   * Creates a <code>SpinnerNumberModel</code> with initial value 0, step 1,\n+   * and no maximum nor minimum.\n+   */\n+  public SpinnerNumberModel()\n+  {\n+    this(new Integer(0), null, null, new Integer(1));\n+  }\n+\n+  /**\n+   * Creates a <code>SpinnerNumberModel</code> with double precision\n+   *\n+   * @param value the initial value\n+   * @param minimum the minimum value\n+   * @param maximum the maximum value\n+   * @param stepSize the step size\n+   */\n+  public SpinnerNumberModel(double value, double minimum, double maximum,\n+                            double stepSize)\n+  {\n+    this(new Double(value), new Double(minimum), new Double(maximum),\n+         new Double(stepSize));\n+  }\n+\n+  /**\n+   * Creates a <code>SpinnerNumberModel</code> with integer precision\n+   *\n+   * @param value the initial value\n+   * @param minimum the minimum value\n+   * @param maximum the maximum value\n+   * @param stepSize the step size\n+   */\n+  public SpinnerNumberModel(int value, int minimum, int maximum, int stepSize)\n+  {\n+    this(new Integer(value), new Integer(minimum), new Integer(maximum),\n+         new Integer(stepSize));\n+  }\n+\n+  /**\n+   * Creates a <code>SpinnerNumberModel</code> with <code>Number</code>s and\n+   * <code>Comparable</code>s.\n+   *\n+   * @param value the initial value\n+   * @param minimum the minimum value, if null there's no minimum\n+   * @param maximum the maximum value, if null there's no maximum\n+   * @param stepSize the step size\n+   *\n+   * @throws IllegalArgumentException if minimum &lt;= value &lt;= maximum\n+   *         does not hold\n+   */\n+  public SpinnerNumberModel(Number value, Comparable minimum,\n+                            Comparable maximum, Number stepSize)\n+  {\n+    if (stepSize == null)\n+      throw new IllegalArgumentException(\"stepSize may not be null\");\n+    if (value == null)\n+      throw new IllegalArgumentException(\"value may not be null\");\n+    if (minimum != null)\n+      {\n+\tif (minimum.compareTo(value) > 0)\n+\t  throw new IllegalArgumentException(\"minimum is not <= value\");\n+      }\n+    else\n+      minimum = new Comparable()\n+\t  {\n+\t    public int compareTo(Object obj)\n+\t    {\n+\t      return -1;\n+\t    }\n+\t  };\n+\n+\n+    if (maximum != null)\n+      {\n+\tif (maximum.compareTo(value) < 0)\n+\t  throw new IllegalArgumentException(\"maximum is not >= value\");\n+      }\n+    else\n+      maximum = new Comparable()\n+\t  {\n+\t    public int compareTo(Object obj)\n+\t    {\n+\t      return 1;\n+\t    }\n+\t  };\n+\n+\n+    this.value = value;\n+    this.stepSize = stepSize;\n+    this.minimum = minimum;\n+    this.maximum = maximum;\n+  }\n+\n+  /**\n+   * Sets the new value and fire a change event\n+   *\n+   * @param value the new value\n+   *\n+   * @throws IllegalArgumentException if minimum &lt;= value &lt;= maximum\n+   *         does not hold\n+   */\n+  public void setValue(Object value)\n+  {\n+    if (! (value instanceof Number))\n+      throw new IllegalArgumentException(\"value must be a Number\");\n+\n+    this.value = (Number) value;\n+    fireStateChanged();\n+  }\n+\n+  /**\n+   * Gets the current value\n+   *\n+   * @return the current value\n+   */\n+  public Object getValue()\n+  {\n+    return value;\n+  }\n+\n+  /**\n+   * Gets the next value without changing the current value, or null if the\n+   * current value is maximum.\n+   *\n+   * @return the next value\n+   */\n+  public Object getNextValue()\n+  {\n+    Number num;\n+\n+    if (value instanceof Double)\n+      num = new Double(value.doubleValue() + stepSize.doubleValue());\n+    else if (value instanceof Float)\n+      num = new Double(value.floatValue() + stepSize.floatValue());\n+    else if (value instanceof Long)\n+      num = new Long(value.longValue() + stepSize.longValue());\n+    else if (value instanceof Integer)\n+      num = new Integer(value.intValue() + stepSize.intValue());\n+    else if (value instanceof Short)\n+      num = new Short((short) (value.shortValue() + stepSize.shortValue()));\n+    else\n+      num = new Byte((byte) (value.byteValue() + stepSize.byteValue()));\n+\n+    return maximum.compareTo(num) >= 0 ? num : null;\n+  }\n+\n+  /**\n+   * Gets the previous value without changing the current value, or null if\n+   * the current value is minimum.\n+   *\n+   * @return the previous value\n+   */\n+  public Object getPreviousValue()\n+  {\n+    Number num;\n+\n+    if (value instanceof Double)\n+      num = new Double(value.doubleValue() - stepSize.doubleValue());\n+    else if (value instanceof Float)\n+      num = new Double(value.floatValue() - stepSize.floatValue());\n+    else if (value instanceof Long)\n+      num = new Long(value.longValue() - stepSize.longValue());\n+    else if (value instanceof Integer)\n+      num = new Integer(value.intValue() - stepSize.intValue());\n+    else if (value instanceof Short)\n+      num = new Short((short) (value.shortValue() - stepSize.shortValue()));\n+    else\n+      num = new Byte((byte) (value.byteValue() - stepSize.byteValue()));\n+\n+    return minimum.compareTo(num) <= 0 ? num : null;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public Number getNumber()\n+  {\n+    return value;\n+  }\n+}"}, {"sha": "e64df9c4cb3b18dd7ea6c6aa2bf5240410a6c6d3", "filename": "libjava/javax/swing/TransferHandler.java", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2FTransferHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2FTransferHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FTransferHandler.java?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,55 @@\n+/* TransferHandler.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing;\n+\n+import java.io.Serializable;\n+\n+public class TransferHandler implements Serializable\n+{\n+  private static final long serialVersionUID = -7908749299918704233L;\n+\n+  public static final int NONE = 0;\n+  public static final int COPY = 1;\n+  public static final int MOVE = 2;\n+  public static final int COPY_OR_MOVE = 3;\n+\n+  protected TransferHandler()\n+  {\n+    // Do nothing here.\n+  }\n+}"}, {"sha": "dcd795a743368cd0bfa76d624dbe688b47201898", "filename": "libjava/javax/swing/colorchooser/DefaultHSBChooserPanel.java", "status": "added", "additions": 860, "deletions": 0, "changes": 860, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fcolorchooser%2FDefaultHSBChooserPanel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fcolorchooser%2FDefaultHSBChooserPanel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fcolorchooser%2FDefaultHSBChooserPanel.java?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,860 @@\n+/* DefaultHSBChooserPanel.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.colorchooser;\n+\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.ComponentOrientation;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.GridLayout;\n+import java.awt.Image;\n+import java.awt.LayoutManager;\n+import java.awt.Point;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseMotionListener;\n+import java.awt.image.MemoryImageSource;\n+import javax.swing.AbstractButton;\n+import javax.swing.ButtonGroup;\n+import javax.swing.Icon;\n+import javax.swing.JColorChooser;\n+import javax.swing.JLabel;\n+import javax.swing.JPanel;\n+import javax.swing.JRadioButton;\n+import javax.swing.JSlider;\n+import javax.swing.JSpinner;\n+import javax.swing.SpinnerNumberModel;\n+import javax.swing.SwingConstants;\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n+\n+\n+/**\n+ * This is the Default HSB Panel displayed in the JColorChooser.\n+ */\n+class DefaultHSBChooserPanel extends AbstractColorChooserPanel\n+{\n+  /** The gradient image displayed. */\n+  private transient Image gradientImage;\n+\n+  /** The Panel that holds the gradient image. */\n+  private transient JPanel gradientPanel;\n+\n+  /** The track gradient image. */\n+  private transient Image trackImage;\n+\n+  /** The panel that holds the track. */\n+  private transient JPanel trackPanel;\n+\n+  /** The slider for the locked HSB value. */\n+  private transient JSlider slider;\n+\n+  /** The RadioButton that controls the Hue. */\n+  private transient JRadioButton hRadio;\n+\n+  /** The RadioButton that controls the Saturation. */\n+  private transient JRadioButton sRadio;\n+\n+  /** The RadioButton that controls the Brightness. */\n+  private transient JRadioButton bRadio;\n+\n+  /** The JSpinner that controls the Hue. */\n+  private transient JSpinner hSpinner;\n+\n+  /** The JSpinner that controls the Saturation. */\n+  private transient JSpinner sSpinner;\n+\n+  /** The JSpinner that controls the Brightness. */\n+  private transient JSpinner bSpinner;\n+\n+  /** The default width of the gradient image. */\n+  private static final int imgWidth = 200;\n+\n+  /** The default height of the gradient image. */\n+  private static final int imgHeight = 200;\n+\n+  /** The default width of the track gradient. */\n+  private static final int trackWidth = 30;\n+\n+  /** The JLabel for Red. */\n+  private static final JLabel R = new JLabel(\"R\");\n+\n+  /** The JLabel for Green. */\n+  private static final JLabel G = new JLabel(\"G\");\n+\n+  /** The JLabel for Blue. */\n+  private static final JLabel B = new JLabel(\"B\");\n+\n+  // FIXME: Should be textfields.\n+\n+  /** The JLabel that displays the value of Red. */\n+  private transient JLabel rFull;\n+\n+  /** The JLabel that displays the value of Green. */\n+  private transient JLabel gFull;\n+\n+  /** The JLabel that displays the value of Blue. */\n+  private transient JLabel bFull;\n+\n+  /** The point that is displayed in the gradient image. */\n+  private transient Point gradientPoint = new Point();\n+\n+  /**\n+   * This indicates that the change to the slider or point is triggered\n+   * internally.\n+   */\n+  private transient boolean internalChange = false;\n+\n+  /** This indicates that the change to the spinner is triggered internally. */\n+  private transient boolean spinnerTrigger = false;\n+\n+  /** This int identifies which spinner is currently locked. */\n+  private transient int locked = -1;\n+\n+  /** This value indicates that the Hue spinner is locked. */\n+  static final int HLOCKED = 0;\n+\n+  /** This value indicates that the Saturation spinner is locked. */\n+  static final int SLOCKED = 1;\n+\n+  /** This value indicates that the Brightness spinner is locked. */\n+  static final int BLOCKED = 2;\n+\n+  /**\n+   * This method indicates that the mouse event is in the process of being\n+   * handled.\n+   */\n+  private transient boolean handlingMouse;\n+\n+  /**\n+   * This helper class handles mouse events on the gradient image.\n+   */\n+  class MainGradientMouseListener extends MouseAdapter\n+    implements MouseMotionListener\n+  {\n+    /**\n+     * This method is called when the mouse is pressed over the gradient\n+     * image. The JColorChooser is then updated with new HSB values.\n+     *\n+     * @param e The MouseEvent.\n+     */\n+    public void mousePressed(MouseEvent e)\n+    {\n+      gradientPoint = e.getPoint();\n+      update(e.getPoint());\n+    }\n+\n+    /**\n+     * This method is called when the mouse is dragged over the gradient\n+     * image. The JColorChooser is then updated with the new HSB values.\n+     *\n+     * @param e The MouseEvent.\n+     */\n+    public void mouseDragged(MouseEvent e)\n+    {\n+      Point p = e.getPoint();\n+      if (p.x < 0 || p.y < 0 || p.y > imgHeight || p.x > imgWidth)\n+\treturn;\n+\n+      gradientPoint = p;\n+      update(p);\n+    }\n+\n+    /**\n+     * This method is called when the mouse is moved over the gradient image.\n+     *\n+     * @param e The MouseEvent.\n+     */\n+    public void mouseMoved(MouseEvent e)\n+    {\n+      // Do nothing.\n+    }\n+\n+    /**\n+     * This method updates the JColorChooser with the new values.\n+     *\n+     * @param p The Point where the MouseEvent occurred.\n+     */\n+    private void update(Point p)\n+    {\n+      handlingMouse = true;\n+      if (hSpinner.isEnabled())\n+\tupdateH(p);\n+      else if (sSpinner.isEnabled())\n+\tupdateS(p);\n+      else\n+\tupdateB(p);\n+      handlingMouse = false;\n+    }\n+\n+    /**\n+     * This method updates the SB values if Hue is locked.\n+     *\n+     * @param p The point where the MouseEvent occurred.\n+     */\n+    private void updateH(Point p)\n+    {\n+      float s = (imgWidth - p.x * 1f) / imgWidth;\n+      float b = (imgHeight - p.y * 1f) / imgHeight;\n+\n+      // Avoid two changes to the model by changing internalChange to true.\n+      internalChange = true;\n+      sSpinner.setValue(new Integer((int) (s * 100)));\n+      internalChange = false;\n+      bSpinner.setValue(new Integer((int) (b * 100)));\n+\n+      revalidate();\n+    }\n+\n+    /**\n+     * This method updates the HB values if Saturation is locked.\n+     *\n+     * @param p The point where the MouseEvent occurred.\n+     */\n+    private void updateS(Point p)\n+    {\n+      float h = p.x * 1f / imgWidth;\n+      float b = (imgHeight - p.y * 1f) / imgHeight;\n+\n+      internalChange = true;\n+      hSpinner.setValue(new Integer((int) (h * 365)));\n+      internalChange = false;\n+      bSpinner.setValue(new Integer((int) (b * 100)));\n+\n+      revalidate();\n+    }\n+\n+    /**\n+     * This method updates the HS values if Brightness is locked.\n+     *\n+     * @param p The point where the MouseEvent occurred.\n+     */\n+    private void updateB(Point p)\n+    {\n+      float h = p.x * 1f / imgWidth;\n+      float s = (imgHeight - p.y * 1f) / imgHeight;\n+\n+      internalChange = true;\n+      hSpinner.setValue(new Integer((int) (h * 365)));\n+      internalChange = false;\n+      sSpinner.setValue(new Integer((int) (s * 100)));\n+\n+      revalidate();\n+    }\n+  }\n+\n+  /**\n+   * This method listens for slider value changes.\n+   */\n+  class SliderChangeListener implements ChangeListener\n+  {\n+    /**\n+     * This method is called when the slider value changes. It should change\n+     * the color of the JColorChooser.\n+     *\n+     * @param e The ChangeEvent.\n+     */\n+    public void stateChanged(ChangeEvent e)\n+    {\n+      if (internalChange)\n+\treturn;\n+\n+      Integer value = new Integer(slider.getValue());\n+\n+      switch (locked)\n+        {\n+\tcase HLOCKED:\n+\t  hSpinner.setValue(value);\n+\t  break;\n+\tcase SLOCKED:\n+\t  sSpinner.setValue(value);\n+\t  break;\n+\tcase BLOCKED:\n+\t  bSpinner.setValue(value);\n+\t  break;\n+        }\n+    }\n+  }\n+\n+  /**\n+   * This helper class determines the active JSpinner.\n+   */\n+  class RadioStateListener implements ChangeListener\n+  {\n+    /**\n+     * This method is called when there is a new JRadioButton that was\n+     * selected. As a result, it should activate the associated JSpinner.\n+     *\n+     * @param e The ChangeEvent.\n+     */\n+    public void stateChanged(ChangeEvent e)\n+    {\n+      JSpinner change;\n+      if (e.getSource() == hRadio)\n+        {\n+\t  locked = HLOCKED;\n+\t  change = hSpinner;\n+        }\n+      else if (e.getSource() == sRadio)\n+        {\n+\t  locked = SLOCKED;\n+\t  change = sSpinner;\n+        }\n+      else\n+        {\n+\t  locked = BLOCKED;\n+\t  change = bSpinner;\n+        }\n+\n+      change.setEnabled(((AbstractButton) e.getSource()).isSelected());\n+      updateSlider();\n+      updateTrack();\n+      updateImage();\n+      repaint();\n+    }\n+  }\n+\n+  /**\n+   * This class listens to the JSpinners for changes.\n+   */\n+  class ImageScrollListener implements ChangeListener\n+  {\n+    /**\n+     * This method is called whenever one of the JSpinner values change. The\n+     * JColorChooser should be updated with the new HSB values.\n+     *\n+     * @param e The ChangeEvent.\n+     */\n+    public void stateChanged(ChangeEvent e)\n+    {\n+      if (internalChange)\n+\treturn;\n+\n+      float h = ((Number) hSpinner.getValue()).intValue() / 360f;\n+      float s = ((Number) sSpinner.getValue()).intValue() / 100f;\n+      float b = ((Number) bSpinner.getValue()).intValue() / 100f;\n+\n+      spinnerTrigger = true;\n+      getColorSelectionModel().setSelectedColor(new Color(Color.HSBtoRGB(h, s,\n+                                                                         b)));\n+      spinnerTrigger = false;\n+\n+      if (! handlingMouse)\n+        {\n+\t  updateImage();\n+\t  updateTrack();\n+        }\n+      repaint();\n+    }\n+  }\n+\n+  /**\n+   * Creates a new DefaultHSBChooserPanel object.\n+   */\n+  DefaultHSBChooserPanel()\n+  {\n+    super();\n+  }\n+\n+  /**\n+   * This method returns the name displayed by the JColorChooser tab that\n+   * holds this panel.\n+   *\n+   * @return The name displayed in the JColorChooser tab.\n+   */\n+  public String getDisplayName()\n+  {\n+    return \"HSB\";\n+  }\n+\n+  /**\n+   * This method updates the various components inside the HSBPanel (the\n+   * JSpinners, the JSlider, and the gradient image point) with updated\n+   * values when the JColorChooser color value changes.\n+   */\n+  public void updateChooser()\n+  {\n+    Color c = getColorSelectionModel().getSelectedColor();\n+\n+    float[] hsbVals = Color.RGBtoHSB(c.getRed(), c.getGreen(), c.getBlue(),\n+                                     null);\n+\n+    internalChange = true;\n+\n+    // spinnerTrigger, internalChange, and handlingMouse are used because of the\n+    // we don't want things like: change spinner -> update chooser -> change spinner\n+    // That's because the value from before and after the update can differ\n+    // slightly because of the conversion.\n+    // FIXME: Think of better way to deal with this.\n+    if (! spinnerTrigger)\n+      {\n+\thSpinner.setValue(new Integer((int) (hsbVals[0] * 360)));\n+\tsSpinner.setValue(new Integer((int) (hsbVals[1] * 100)));\n+\tbSpinner.setValue(new Integer((int) (hsbVals[2] * 100)));\n+      }\n+\n+    switch (locked)\n+      {\n+      case HLOCKED:\n+\tif (slider != null)\n+\t  slider.setValue(((Number) hSpinner.getValue()).intValue());\n+\tif (! handlingMouse)\n+\t  {\n+\t    gradientPoint.x = (int) ((1 - hsbVals[1]) * imgWidth);\n+\t    gradientPoint.y = (int) ((1 - hsbVals[2]) * imgHeight);\n+\t  }\n+\tbreak;\n+      case SLOCKED:\n+\tif (slider != null)\n+\t  slider.setValue(((Number) sSpinner.getValue()).intValue());\n+\tif (! handlingMouse)\n+\t  {\n+\t    gradientPoint.x = (int) (hsbVals[0] * imgWidth);\n+\t    gradientPoint.y = (int) ((1 - hsbVals[2]) * imgHeight);\n+\t  }\n+\tbreak;\n+      case BLOCKED:\n+\tif (slider != null)\n+\t  slider.setValue(((Number) bSpinner.getValue()).intValue());\n+\tif (! handlingMouse)\n+\t  {\n+\t    gradientPoint.x = (int) (hsbVals[0] * imgWidth);\n+\t    gradientPoint.y = (int) ((1 - hsbVals[1]) * imgHeight);\n+\t  }\n+\tbreak;\n+      }\n+    internalChange = false;\n+\n+    updateImage();\n+    updateTrack();\n+    updateTextFields();\n+  }\n+\n+  /**\n+   * This method builds the DefaultHSBChooserPanel.\n+   */\n+  protected void buildChooser()\n+  {\n+    setLayout(new BorderLayout());\n+\n+    add(buildRightPanel(), BorderLayout.EAST);\n+\n+    JPanel container = new JPanel();\n+    container.setLayout(new BorderLayout());\n+\n+    gradientPanel = new JPanel()\n+        {\n+\t  public Dimension getPreferredSize()\n+\t  {\n+\t    return new Dimension(imgWidth, imgHeight);\n+\t  }\n+\n+\t  public void paint(Graphics g)\n+\t  {\n+\t    if (gradientImage != null)\n+\t      g.drawImage(gradientImage, 0, 0, this);\n+\n+\t    Color saved = g.getColor();\n+\t    g.setColor(Color.WHITE);\n+\t    g.drawOval(gradientPoint.x - 3, gradientPoint.y - 3, 6, 6);\n+\t    g.setColor(saved);\n+\t  }\n+        };\n+\n+    MouseAdapter ml = new MainGradientMouseListener();\n+    gradientPanel.addMouseListener(ml);\n+    gradientPanel.addMouseMotionListener((MouseMotionListener) ml);\n+\n+    trackPanel = new JPanel()\n+        {\n+\t  public Dimension getPreferredSize()\n+\t  {\n+\t    return new Dimension(trackWidth, imgHeight);\n+\t  }\n+\n+\t  public void paint(Graphics g)\n+\t  {\n+\t    if (trackImage != null)\n+\t      g.drawImage(trackImage, 0, 0, this);\n+\t  }\n+        };\n+\n+    slider = new JSlider();\n+    slider.setPaintTrack(false);\n+    slider.setPaintTicks(false);\n+\n+    slider.setOrientation(SwingConstants.VERTICAL);\n+\n+    updateSlider();\n+\n+    container.add(gradientPanel, BorderLayout.WEST);\n+    container.add(slider, BorderLayout.CENTER);\n+    container.add(trackPanel, BorderLayout.EAST);\n+\n+    add(container, BorderLayout.WEST);\n+    slider.addChangeListener(new SliderChangeListener());\n+    repaint();\n+  }\n+\n+  /**\n+   * This method uninstalls the DefaultHSBPanel.\n+   *\n+   * @param chooser The JColorChooser to remove this panel from.\n+   */\n+  public void uninstallChooserPanel(JColorChooser chooser)\n+  {\n+    trackImage = null;\n+    gradientImage = null;\n+    gradientPanel = null;\n+    slider = null;\n+\n+    hSpinner = null;\n+    sSpinner = null;\n+    bSpinner = null;\n+\n+    hRadio = null;\n+    sRadio = null;\n+    bRadio = null;\n+\n+    removeAll();\n+    super.uninstallChooserPanel(chooser);\n+  }\n+\n+  /**\n+   * This helper method creates the right side panel (the panel with the\n+   * Spinners and TextFields).\n+   *\n+   * @return The right side panel.\n+   */\n+  private Container buildRightPanel()\n+  {\n+    JPanel container = new JPanel();\n+    container.setLayout(new GridLayout(6, 2));\n+\n+    hRadio = new JRadioButton(\"H\");\n+    sRadio = new JRadioButton(\"S\");\n+    bRadio = new JRadioButton(\"B\");\n+\n+    ButtonGroup group = new ButtonGroup();\n+    group.add(hRadio);\n+    group.add(sRadio);\n+    group.add(bRadio);\n+\n+    hSpinner = new JSpinner(new SpinnerNumberModel(0, 0, 359, 1));\n+    sSpinner = new JSpinner(new SpinnerNumberModel(0, 0, 100, 1));\n+    bSpinner = new JSpinner(new SpinnerNumberModel(100, 0, 100, 1));\n+\n+    hSpinner.setEnabled(false);\n+    sSpinner.setEnabled(false);\n+    bSpinner.setEnabled(false);\n+\n+    ChangeListener cl = new RadioStateListener();\n+    ChangeListener scroll = new ImageScrollListener();\n+\n+    hRadio.addChangeListener(cl);\n+    sRadio.addChangeListener(cl);\n+    bRadio.addChangeListener(cl);\n+\n+    hSpinner.addChangeListener(scroll);\n+    sSpinner.addChangeListener(scroll);\n+    bSpinner.addChangeListener(scroll);\n+\n+    hRadio.setSelected(true);\n+\n+    container.add(hRadio);\n+    container.add(hSpinner);\n+\n+    container.add(sRadio);\n+    container.add(sSpinner);\n+\n+    container.add(bRadio);\n+    container.add(bSpinner);\n+\n+    rFull = new JLabel(\"red full\");\n+    gFull = new JLabel(\"green full\");\n+    bFull = new JLabel(\"blue full\");\n+\n+    container.add(R);\n+    container.add(rFull);\n+\n+    container.add(G);\n+    container.add(gFull);\n+\n+    container.add(B);\n+    container.add(bFull);\n+\n+    return container;\n+  }\n+\n+  /**\n+   * This method returns the small display icon.\n+   *\n+   * @return The small display icon.\n+   */\n+  public Icon getSmallDisplayIcon()\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * This method returns the large display icon.\n+   *\n+   * @return The large display icon.\n+   */\n+  public Icon getLargeDisplayIcon()\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * This method paints the chooser panel.\n+   *\n+   * @param g The graphics object to paint with.\n+   */\n+  public void paint(Graphics g)\n+  {\n+    super.paint(g);\n+  }\n+\n+  /**\n+   * This method updates the gradient image with a new one taking the Hue\n+   * value as the constant.\n+   */\n+  private void updateHLockImage()\n+  {\n+    int index = 0;\n+    int[] pix = new int[imgWidth * imgHeight];\n+    float hValue = ((Number) hSpinner.getValue()).intValue() / 360f;\n+\n+    for (int j = 0; j < imgHeight; j++)\n+      for (int i = 0; i < imgWidth; i++)\n+\tpix[index++] = Color.HSBtoRGB(hValue, (imgWidth - i * 1f) / imgWidth,\n+\t                              (imgHeight - j * 1f) / imgHeight)\n+\t               | (255 << 24);\n+\n+    gradientImage = createImage(new MemoryImageSource(imgWidth, imgHeight,\n+                                                      pix, 0, imgWidth));\n+  }\n+\n+  /**\n+   * This method updates the gradient image with a new one taking the\n+   * Brightness value as the constant.\n+   */\n+  private void updateBLockImage()\n+  {\n+    int[] pix = new int[imgWidth * imgHeight];\n+    float bValue = ((Number) bSpinner.getValue()).intValue() / 100f;\n+\n+    int index = 0;\n+    for (int j = 0; j < imgHeight; j++)\n+      for (int i = 0; i < imgWidth; i++)\n+\tpix[index++] = Color.HSBtoRGB(i * 1f / imgWidth,\n+\t                              (imgHeight - j * 1f) / imgHeight, bValue)\n+\t               | (255 << 24);\n+\n+    gradientImage = createImage(new MemoryImageSource(imgWidth, imgHeight,\n+                                                      pix, 0, imgWidth));\n+  }\n+\n+  /**\n+   * This method updates the gradient image with a new one taking the\n+   * Saturation value as the constant.\n+   */\n+  private void updateSLockImage()\n+  {\n+    int[] pix = new int[imgWidth * imgHeight];\n+    float sValue = ((Number) sSpinner.getValue()).intValue() / 100f;\n+\n+    int index = 0;\n+    for (int j = 0; j < imgHeight; j++)\n+      for (int i = 0; i < imgWidth; i++)\n+\tpix[index++] = Color.HSBtoRGB(i * 1f / imgWidth, sValue,\n+\t                              (imgHeight - j * 1f) / imgHeight)\n+\t               | (255 << 24);\n+    gradientImage = createImage(new MemoryImageSource(imgWidth, imgHeight,\n+                                                      pix, 0, imgWidth));\n+  }\n+\n+  /**\n+   * This method calls the appropriate method to update the gradient image\n+   * depending on which HSB value is constant.\n+   */\n+  private void updateImage()\n+  {\n+    switch (locked)\n+      {\n+      case HLOCKED:\n+\tupdateHLockImage();\n+\tbreak;\n+      case SLOCKED:\n+\tupdateSLockImage();\n+\tbreak;\n+      case BLOCKED:\n+\tupdateBLockImage();\n+\tbreak;\n+      }\n+  }\n+\n+  /**\n+   * This method updates the TextFields with the correct RGB values.\n+   */\n+  private void updateTextFields()\n+  {\n+    int c = getColorSelectionModel().getSelectedColor().getRGB();\n+\n+    rFull.setText(\"\" + (c >> 16 & 0xff));\n+    gFull.setText(\"\" + (c >> 8 & 0xff));\n+    bFull.setText(\"\" + (c & 0xff));\n+\n+    repaint();\n+  }\n+\n+  /**\n+   * This method updates the slider in response to making a different HSB\n+   * property the constant.\n+   */\n+  private void updateSlider()\n+  {\n+    if (slider == null)\n+      return;\n+\n+    slider.setMinimum(0);\n+    if (locked == HLOCKED)\n+      {\n+\tslider.setMaximum(359);\n+\t;\n+\tslider.setValue(((Number) hSpinner.getValue()).intValue());\n+\tslider.setInverted(true);\n+      }\n+    else\n+      {\n+\tslider.setMaximum(100);\n+\tslider.setInverted(false);\n+\tif (sRadio.isSelected())\n+\t  slider.setValue(((Number) sSpinner.getValue()).intValue());\n+\telse\n+\t  slider.setValue(((Number) bSpinner.getValue()).intValue());\n+      }\n+    repaint();\n+  }\n+\n+  /**\n+   * This method updates the track gradient image depending on which HSB\n+   * property is constant.\n+   */\n+  private void updateTrack()\n+  {\n+    switch (locked)\n+      {\n+      case HLOCKED:\n+\tupdateHTrack();\n+\tbreak;\n+      case SLOCKED:\n+\tupdateSTrack();\n+\tbreak;\n+      case BLOCKED:\n+\tupdateBTrack();\n+\tbreak;\n+      }\n+  }\n+\n+  /**\n+   * This method updates the track gradient image if the Hue value is allowed\n+   * to change (according to the JRadioButtons).\n+   */\n+  private void updateHTrack()\n+  {\n+    int trackIndex = 0;\n+    int[] trackPix = new int[trackWidth * imgHeight];\n+\n+    for (int j = 0; j < imgHeight; j++)\n+      for (int i = 0; i < trackWidth; i++)\n+\ttrackPix[trackIndex++] = Color.HSBtoRGB(j * 1f / imgHeight, 1f, 1f)\n+\t                         | (255 << 24);\n+\n+    trackImage = createImage(new MemoryImageSource(trackWidth, imgHeight,\n+                                                   trackPix, 0, trackWidth));\n+  }\n+\n+  /**\n+   * This method updates the track gradient image if the Saturation value is\n+   * allowed to change (according to the JRadioButtons).\n+   */\n+  private void updateSTrack()\n+  {\n+    int[] trackPix = new int[trackWidth * imgHeight];\n+\n+    float hValue = ((Number) hSpinner.getValue()).intValue() / 360f;\n+    float bValue = ((Number) bSpinner.getValue()).intValue() / 100f;\n+\n+    int trackIndex = 0;\n+    for (int j = 0; j < imgHeight; j++)\n+      for (int i = 0; i < trackWidth; i++)\n+\ttrackPix[trackIndex++] = Color.HSBtoRGB(hValue,\n+\t                                        (imgHeight - j * 1f) / imgHeight,\n+\t                                        bValue) | (255 << 24);\n+\n+    trackImage = createImage(new MemoryImageSource(trackWidth, imgHeight,\n+                                                   trackPix, 0, trackWidth));\n+  }\n+\n+  /**\n+   * This method updates the track gradient image if the Brightness value is\n+   * allowed to change (according to the JRadioButtons).\n+   */\n+  private void updateBTrack()\n+  {\n+    int[] trackPix = new int[trackWidth * imgHeight];\n+\n+    float hValue = ((Number) hSpinner.getValue()).intValue() / 360f;\n+    float sValue = ((Number) sSpinner.getValue()).intValue() / 100f;\n+\n+    int trackIndex = 0;\n+    for (int j = 0; j < imgHeight; j++)\n+      for (int i = 0; i < trackWidth; i++)\n+\ttrackPix[trackIndex++] = Color.HSBtoRGB(hValue, sValue,\n+\t                                        (imgHeight - j * 1f) / imgHeight)\n+\t                         | (255 << 24);\n+\n+    trackImage = createImage(new MemoryImageSource(trackWidth, imgHeight,\n+                                                   trackPix, 0, trackWidth));\n+  }\n+}"}, {"sha": "93ecfc39a54ade1bd0e3c33f97c310ed2a3611b1", "filename": "libjava/javax/swing/colorchooser/DefaultPreviewPanel.java", "status": "added", "additions": 317, "deletions": 0, "changes": 317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fcolorchooser%2FDefaultPreviewPanel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fcolorchooser%2FDefaultPreviewPanel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fcolorchooser%2FDefaultPreviewPanel.java?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,317 @@\n+/* DefaultPreviewPanel.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.colorchooser;\n+\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n+import javax.swing.JColorChooser;\n+import javax.swing.JPanel;\n+import javax.swing.SwingUtilities;\n+import javax.swing.border.Border;\n+\n+\n+/**\n+ * This is the default preview panel for the JColorChooser. The default\n+ * preview panel is responsible for displaying the currently selected color\n+ * of the JColorChooser.\n+ */\n+class DefaultPreviewPanel extends JPanel\n+{\n+  /**\n+   * This is the border around the preview panel.\n+   */\n+  class PreviewBorder implements Border\n+  {\n+    /** This is the value of the top, bottom, top, and right inset. */\n+    private static final int edge = 20;\n+\n+    /**\n+     * This is the distance from the top left corner of the border to the\n+     * text.\n+     */\n+    private static final int lead = 5;\n+\n+    /** This is the horizontal gap between the text and the border. */\n+    private static final int gap = 3;\n+\n+    /**\n+     * This method returns the border insets for the given Component.\n+     *\n+     * @param c The Component to retrieve insets for.\n+     *\n+     * @return The insets for the given Component.\n+     */\n+    public Insets getBorderInsets(Component c)\n+    {\n+      return new Insets(edge, edge, edge, edge);\n+    }\n+\n+    /**\n+     * This method returns whether the border is responsible for painting its\n+     * own background.\n+     *\n+     * @return Whether the border is responsible for painting its own\n+     *         background.\n+     */\n+    public boolean isBorderOpaque()\n+    {\n+      return true;\n+    }\n+\n+    /**\n+     * This method paints the border for the given component with the graphics\n+     * object using the given properties.\n+     *\n+     * @param c The Component to paint the border for.\n+     * @param g The Graphics object to paint with.\n+     * @param x The x location to paint at.\n+     * @param y The y location to paint at.\n+     * @param width The width of the component.\n+     * @param height The height of the component.\n+     */\n+    public void paintBorder(Component c, Graphics g, int x, int y, int width,\n+                            int height)\n+    {\n+      Color saved = g.getColor();\n+      FontMetrics fm = g.getFontMetrics();\n+\n+      g.setColor(Color.BLACK);\n+      g.drawLine(x + edge / 2, y + edge / 2, x + edge / 2,\n+                 y + height - edge / 2);\n+      g.drawLine(x + edge / 2, y + height - edge / 2, x + width - edge / 2,\n+                 y + height - edge / 2);\n+      g.drawLine(x + width - edge / 2, y + edge / 2, x + width - edge / 2,\n+                 y + height - edge / 2);\n+      g.drawLine(x + edge / 2, y + edge / 2, x + edge / 2 + lead, y + edge / 2);\n+\n+      int strwidth = fm.stringWidth(\"Preview\");\n+\n+      g.drawString(\"Preview\", x + edge / 2 + lead + gap,\n+                   y + edge / 2 + fm.getAscent() / 2);\n+\n+      g.drawLine(x + lead + edge / 2 + strwidth + gap * 2, y + edge / 2,\n+                 x + width - edge / 2, y + edge / 2);\n+\n+      g.setColor(saved);\n+    }\n+  }\n+\n+  /** A standard large gap size. */\n+  private static int largeGap = 6;\n+\n+  /** A standard small gap size. */\n+  private static int smallGap = 2;\n+\n+  /** The size of each side of the square. */\n+  private static int squareSize = 36;\n+\n+  /** This padding between the text and the edge of its box. */\n+  private static int textPadding = 4;\n+\n+  /** The width of the right most rectangles. */\n+  private static int rightSideRectWidth = 60;\n+\n+  /** The sample text. */\n+  private static String sample = \"Sample Text   Sample Text\";\n+\n+  /**\n+   * Creates a new DefaultPreviewPanel object.\n+   */\n+  DefaultPreviewPanel()\n+  {\n+    super();\n+    setBorder(new PreviewBorder());\n+  }\n+\n+  /**\n+   * This method paints the default preview panel with the given Graphics\n+   * object.\n+   *\n+   * @param g The Graphics object.\n+   */\n+  public void paint(Graphics g)\n+  {\n+    super.paint(g);\n+    Color currentColor = null;\n+    JColorChooser chooser = (JColorChooser) SwingUtilities.getAncestorOfClass(JColorChooser.class,\n+                                                                              this);\n+    if (chooser != null)\n+      currentColor = chooser.getColor();\n+\n+    Color saved = g.getColor();\n+    Insets insets = getInsets();\n+\n+    int down = insets.top + squareSize + largeGap;\n+    int currX = insets.left;\n+\n+    paintSquare(g, currX, insets.top, Color.WHITE, currentColor, Color.WHITE,\n+                -1, -1, -1);\n+    paintSquare(g, currX, down, currentColor, null, null, -1, -1, -1);\n+\n+    currX += squareSize + largeGap;\n+\n+    paintSquare(g, currX, insets.top, Color.BLACK, currentColor, Color.WHITE,\n+                -1, -1, -1);\n+    paintSquare(g, currX, down, Color.WHITE, currentColor, null, -1, -1, -1);\n+\n+    currX += squareSize + largeGap;\n+\n+    paintSquare(g, currX, insets.top, Color.WHITE, currentColor, Color.BLACK,\n+                -1, -1, -1);\n+    paintSquare(g, currX, down, Color.BLACK, currentColor, null, -1, -1, -1);\n+\n+    FontMetrics fm = g.getFontMetrics();\n+    int strWidth = fm.stringWidth(sample);\n+    int strHeight = fm.getHeight();\n+\n+    currX += squareSize + largeGap;\n+\n+    int boxWidth = 2 * textPadding + strWidth;\n+    int boxHeight = 2 * textPadding + strHeight;\n+\n+    int first = insets.top + textPadding;\n+    int second = insets.top + boxHeight + smallGap;\n+    int third = insets.top + 2 * (boxHeight + smallGap);\n+\n+    g.setColor(Color.WHITE);\n+    g.fillRect(currX, third, boxWidth, boxHeight);\n+\n+    g.setColor(currentColor);\n+    g.drawString(sample, currX + textPadding,\n+                 first + textPadding + fm.getAscent());\n+\n+    g.fillRect(currX, second, boxWidth, boxHeight);\n+\n+    g.drawString(sample, currX + textPadding,\n+                 third + textPadding + fm.getAscent());\n+\n+    g.setColor(Color.BLACK);\n+    g.drawString(sample, currX + textPadding,\n+                 second + textPadding + fm.getAscent());\n+\n+    currX += boxWidth + largeGap;\n+\n+    g.setColor(Color.WHITE);\n+    g.fillRect(currX, insets.top, rightSideRectWidth, squareSize\n+               + largeGap / 2);\n+\n+    g.setColor(currentColor);\n+    g.fillRect(currX, insets.top + squareSize + largeGap / 2,\n+               rightSideRectWidth, squareSize + largeGap / 2);\n+\n+    g.setColor(saved);\n+  }\n+\n+  /**\n+   * This method creates and paints a square. The square has two smaller\n+   * squares inside of it. Each of the three squares has their sizes\n+   * determined by the size arguments. If the size is not given (by passing\n+   * in -1), then the size is determined automatically.\n+   *\n+   * @param g The Graphics object to paint with.\n+   * @param x The x location to paint at.\n+   * @param y The y location to paint at.\n+   * @param first The color of the first square.\n+   * @param second The color of the second square.\n+   * @param third The color of the third square.\n+   * @param firstSize The size of the first square.\n+   * @param secondSize The size of the second square.\n+   * @param thirdSize The size of the third square.\n+   */\n+  private void paintSquare(Graphics g, int x, int y, Color first,\n+                           Color second, Color third, int firstSize,\n+                           int secondSize, int thirdSize)\n+  {\n+    Color saved = g.getColor();\n+    if (firstSize == -1)\n+      firstSize = squareSize;\n+    if (secondSize == -1)\n+      secondSize = squareSize * 2 / 3;\n+    if (thirdSize == -1)\n+      thirdSize = squareSize / 3;\n+    int secondOffset = (firstSize - secondSize) / 2;\n+    int thirdOffset = (firstSize - thirdSize) / 2;\n+\n+    if (first == null)\n+      return;\n+    g.setColor(first);\n+    g.fillRect(x, y, firstSize, firstSize);\n+    if (second == null)\n+      return;\n+    g.setColor(second);\n+    g.fillRect(x + secondOffset, y + secondOffset, secondSize, secondSize);\n+    if (third == null)\n+      return;\n+    g.setColor(third);\n+    g.fillRect(x + thirdOffset, y + thirdOffset, thirdSize, thirdSize);\n+\n+    g.setColor(saved);\n+  }\n+\n+  /**\n+   * This method returns the preferred size of the default preview panel.\n+   *\n+   * @return The preferred size of the default preview panel.\n+   */\n+  public Dimension getPreferredSize()\n+  {\n+    Graphics g = getGraphics();\n+    FontMetrics fm = g.getFontMetrics();\n+    g.dispose();\n+\n+    int strWidth = fm.stringWidth(sample);\n+    int strHeight = fm.getHeight();\n+\n+    int h1 = (strHeight + 2 * textPadding) * 3 + 2 * smallGap;\n+    int h2 = 2 * squareSize + largeGap;\n+\n+    int height = Math.max(h1, h2);\n+\n+    int width = 3 * (squareSize + largeGap) + strWidth + 2 * textPadding\n+                + largeGap + rightSideRectWidth;\n+\n+    Insets insets = getInsets();\n+\n+    return new Dimension(width + insets.right + insets.left,\n+                         height + insets.top + insets.bottom);\n+  }\n+}"}, {"sha": "f6c22e88577ec5c9d80c46b1260567566cb3d287", "filename": "libjava/javax/swing/colorchooser/DefaultRGBChooserPanel.java", "status": "added", "additions": 377, "deletions": 0, "changes": 377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fcolorchooser%2FDefaultRGBChooserPanel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fcolorchooser%2FDefaultRGBChooserPanel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fcolorchooser%2FDefaultRGBChooserPanel.java?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,377 @@\n+/* DefaultRGHChooserPanel.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.colorchooser;\n+\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.FlowLayout;\n+import java.awt.Graphics;\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import javax.swing.Icon;\n+import javax.swing.JColorChooser;\n+import javax.swing.JLabel;\n+import javax.swing.JPanel;\n+import javax.swing.JSlider;\n+import javax.swing.JSpinner;\n+import javax.swing.SpinnerNumberModel;\n+import javax.swing.SwingConstants;\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n+\n+\n+/**\n+ * This is the default RGB panel for the JColorChooser. The color is selected\n+ * using three sliders that represent the RGB values.\n+ */\n+public class DefaultRGBChooserPanel extends AbstractColorChooserPanel\n+{\n+  /**\n+   * This class handles the slider value changes for all three sliders.\n+   */\n+  class SliderHandler implements ChangeListener\n+  {\n+    /**\n+     * This method is called whenever any of the slider values change.\n+     *\n+     * @param e The ChangeEvent.\n+     */\n+    public void stateChanged(ChangeEvent e)\n+    {\n+      if (internalChange)\n+\treturn;\n+      int color = R.getValue() << 16 | G.getValue() << 8 | B.getValue();\n+\n+      getColorSelectionModel().setSelectedColor(new Color(color));\n+    }\n+  }\n+\n+  /**\n+   * This class handles the Spinner values changing.\n+   */\n+  class SpinnerHandler implements ChangeListener\n+  {\n+    /**\n+     * This method is called whenever any of the JSpinners change values.\n+     *\n+     * @param e The ChangeEvent.\n+     */\n+    public void stateChanged(ChangeEvent e)\n+    {\n+      if (internalChange)\n+\treturn;\n+      int red = ((Number) RSpinner.getValue()).intValue();\n+      int green = ((Number) GSpinner.getValue()).intValue();\n+      int blue = ((Number) BSpinner.getValue()).intValue();\n+\n+      int color = red << 16 | green << 8 | blue;\n+\n+      getColorSelectionModel().setSelectedColor(new Color(color));\n+    }\n+  }\n+\n+  /**\n+   * Whether the color change was initiated from the slider or spinner rather\n+   * than externally.\n+   */\n+  private transient boolean internalChange = false;\n+\n+  /** The ChangeListener for the sliders. */\n+  private transient ChangeListener colorChanger;\n+\n+  /** The ChangeListener for the spinners. */\n+  private transient ChangeListener spinnerHandler;\n+\n+  /** The slider that handles the red values. */\n+  private transient JSlider R;\n+\n+  /** The slider that handles the green values. */\n+  private transient JSlider G;\n+\n+  /** The slider that handles the blue values. */\n+  private transient JSlider B;\n+\n+  /** The label for the red slider. */\n+  private transient JLabel RLabel;\n+\n+  /** The label for the green slider. */\n+  private transient JLabel GLabel;\n+\n+  /** The label for the blue slider. */\n+  private transient JLabel BLabel;\n+\n+  /** The spinner that handles the red values. */\n+  private transient JSpinner RSpinner;\n+\n+  /** The spinner that handles the green values. */\n+  private transient JSpinner GSpinner;\n+\n+  /** The spinner that handles the blue values. */\n+  private transient JSpinner BSpinner;\n+\n+  /**\n+   * Creates a new DefaultRGBChooserPanel object.\n+   */\n+  public DefaultRGBChooserPanel()\n+  {\n+    super();\n+  }\n+\n+  /**\n+   * This method returns the name displayed in the JTabbedPane.\n+   *\n+   * @return The name displayed in the JTabbedPane.\n+   */\n+  public String getDisplayName()\n+  {\n+    return \"RGB\";\n+  }\n+\n+  /**\n+   * This method updates the chooser panel with the new color chosen in the\n+   * JColorChooser.\n+   */\n+  public void updateChooser()\n+  {\n+    Color c = getColorFromModel();\n+    int rgb = c.getRGB();\n+\n+    int red = rgb >> 16 & 0xff;\n+    int green = rgb >> 8 & 0xff;\n+    int blue = rgb & 0xff;\n+\n+    internalChange = true;\n+\n+    if (R != null)\n+      R.setValue(red);\n+    if (RSpinner != null)\n+      RSpinner.setValue(new Integer(red));\n+    if (G != null)\n+      G.setValue(green);\n+    if (GSpinner != null)\n+      GSpinner.setValue(new Integer(green));\n+    if (B != null)\n+      B.setValue(blue);\n+    if (BSpinner != null)\n+      BSpinner.setValue(new Integer(blue));\n+\n+    internalChange = false;\n+\n+    revalidate();\n+    repaint();\n+  }\n+\n+  /**\n+   * This method builds the chooser panel.\n+   */\n+  protected void buildChooser()\n+  {\n+    setLayout(new GridBagLayout());\n+\n+    RLabel = new JLabel(\"Red\");\n+    RLabel.setDisplayedMnemonic('d');\n+    GLabel = new JLabel(\"Green\");\n+    GLabel.setDisplayedMnemonic('n');\n+    BLabel = new JLabel(\"Blue\");\n+    BLabel.setDisplayedMnemonic('B');\n+\n+    R = new JSlider(SwingConstants.HORIZONTAL, 0, 255, 255);\n+    G = new JSlider(SwingConstants.HORIZONTAL, 0, 255, 255);\n+    B = new JSlider(SwingConstants.HORIZONTAL, 0, 255, 255);\n+\n+    R.setPaintTicks(true);\n+    R.setSnapToTicks(false);\n+    G.setPaintTicks(true);\n+    G.setSnapToTicks(false);\n+    B.setPaintTicks(true);\n+    B.setSnapToTicks(false);\n+\n+    R.setLabelTable(R.createStandardLabels(85));\n+    R.setPaintLabels(true);\n+    G.setLabelTable(G.createStandardLabels(85));\n+    G.setPaintLabels(true);\n+    B.setLabelTable(B.createStandardLabels(85));\n+    B.setPaintLabels(true);\n+\n+    R.setMajorTickSpacing(85);\n+    G.setMajorTickSpacing(85);\n+    B.setMajorTickSpacing(85);\n+\n+    R.setMinorTickSpacing(17);\n+    G.setMinorTickSpacing(17);\n+    B.setMinorTickSpacing(17);\n+\n+    RSpinner = new JSpinner(new SpinnerNumberModel(R.getValue(),\n+                                                   R.getMinimum(),\n+                                                   R.getMaximum(), 1));\n+    GSpinner = new JSpinner(new SpinnerNumberModel(G.getValue(),\n+                                                   G.getMinimum(),\n+                                                   G.getMaximum(), 1));\n+    BSpinner = new JSpinner(new SpinnerNumberModel(B.getValue(),\n+                                                   B.getMinimum(),\n+                                                   B.getMaximum(), 1));\n+\n+    RLabel.setLabelFor(R);\n+    GLabel.setLabelFor(G);\n+    BLabel.setLabelFor(B);\n+\n+    GridBagConstraints bag = new GridBagConstraints();\n+    bag.fill = GridBagConstraints.VERTICAL;\n+\n+    bag.gridx = 0;\n+    bag.gridy = 0;\n+    add(RLabel, bag);\n+\n+    bag.gridx = 1;\n+    add(R, bag);\n+\n+    bag.gridx = 2;\n+    add(RSpinner, bag);\n+\n+    bag.gridx = 0;\n+    bag.gridy = 1;\n+    add(GLabel, bag);\n+\n+    bag.gridx = 1;\n+    add(G, bag);\n+\n+    bag.gridx = 2;\n+    add(GSpinner, bag);\n+\n+    bag.gridx = 0;\n+    bag.gridy = 2;\n+    add(BLabel, bag);\n+\n+    bag.gridx = 1;\n+    add(B, bag);\n+\n+    bag.gridx = 2;\n+    add(BSpinner, bag);\n+\n+    installListeners();\n+  }\n+\n+  /**\n+   * This method uninstalls the chooser panel from the JColorChooser.\n+   *\n+   * @param chooser The JColorChooser to remove this chooser panel from.\n+   */\n+  public void uninstallChooserPanel(JColorChooser chooser)\n+  {\n+    uninstallListeners();\n+    removeAll();\n+\n+    R = null;\n+    G = null;\n+    B = null;\n+\n+    RSpinner = null;\n+    GSpinner = null;\n+    BSpinner = null;\n+\n+    super.uninstallChooserPanel(chooser);\n+  }\n+\n+  /**\n+   * This method uninstalls any listeners that were added by the chooser\n+   * panel.\n+   */\n+  private void uninstallListeners()\n+  {\n+    R.removeChangeListener(colorChanger);\n+    G.removeChangeListener(colorChanger);\n+    B.removeChangeListener(colorChanger);\n+\n+    colorChanger = null;\n+\n+    RSpinner.removeChangeListener(spinnerHandler);\n+    GSpinner.removeChangeListener(spinnerHandler);\n+    BSpinner.removeChangeListener(spinnerHandler);\n+\n+    spinnerHandler = null;\n+  }\n+\n+  /**\n+   * This method installs any listeners that the chooser panel needs to\n+   * operate.\n+   */\n+  private void installListeners()\n+  {\n+    colorChanger = new SliderHandler();\n+\n+    R.addChangeListener(colorChanger);\n+    G.addChangeListener(colorChanger);\n+    B.addChangeListener(colorChanger);\n+\n+    spinnerHandler = new SpinnerHandler();\n+\n+    RSpinner.addChangeListener(spinnerHandler);\n+    GSpinner.addChangeListener(spinnerHandler);\n+    BSpinner.addChangeListener(spinnerHandler);\n+  }\n+\n+  /**\n+   * This method returns the small display icon.\n+   *\n+   * @return The small display icon.\n+   */\n+  public Icon getSmallDisplayIcon()\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * This method returns the large display icon.\n+   *\n+   * @return The large display icon.\n+   */\n+  public Icon getLargeDisplayIcon()\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * This method paints the default RGB chooser panel.\n+   *\n+   * @param g The Graphics object to paint with.\n+   */\n+  public void paint(Graphics g)\n+  {\n+    super.paint(g);\n+  }\n+}"}, {"sha": "1413a5b2d5b8a9a1d67acb2ff4fb6c063a8358d0", "filename": "libjava/javax/swing/colorchooser/DefaultSwatchChooserPanel.java", "status": "added", "additions": 891, "deletions": 0, "changes": 891, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fcolorchooser%2FDefaultSwatchChooserPanel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fcolorchooser%2FDefaultSwatchChooserPanel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fcolorchooser%2FDefaultSwatchChooserPanel.java?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,891 @@\n+/* DefaultSwatchChooserPanel.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.colorchooser;\n+\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseListener;\n+import javax.swing.Icon;\n+import javax.swing.JColorChooser;\n+import javax.swing.JLabel;\n+import javax.swing.JPanel;\n+\n+\n+/**\n+ * This class is the DefaultSwatchChooserPanel. This chooser panel displays a\n+ * set of colors that can be picked. Recently picked items will go into a\n+ * side panel so the user can see the history of the chosen colors.\n+ */\n+class DefaultSwatchChooserPanel extends AbstractColorChooserPanel\n+{\n+  /** The main panel that holds the set of choosable colors. */\n+  MainSwatchPanel mainPalette;\n+\n+  /** A panel that holds the recent colors. */\n+  RecentSwatchPanel recentPalette;\n+\n+  /** The mouse handlers for the panels. */\n+  MouseListener mouseHandler;\n+\n+  /**\n+   * This the base class for all swatch panels. Swatch panels are panels that\n+   * hold a set of blocks where colors are displayed.\n+   */\n+  abstract static class SwatchPanel extends JPanel\n+  {\n+    /** The width of each block. */\n+    protected int cellWidth = 10;\n+\n+    /** The height of each block. */\n+    protected int cellHeight = 10;\n+\n+    /** The gap between blocks. */\n+    protected int gap = 1;\n+\n+    /** The number of rows in the swatch panel. */\n+    protected int numRows;\n+\n+    /** The number of columns in the swatch panel. */\n+    protected int numCols;\n+\n+    /**\n+     * Creates a new SwatchPanel object.\n+     */\n+    SwatchPanel()\n+    {\n+      super();\n+      setBackground(Color.WHITE);\n+    }\n+\n+    /**\n+     * This method returns the preferred size of the swatch panel based on the\n+     * number of rows and columns and the size of each cell.\n+     *\n+     * @return The preferred size of the swatch panel.\n+     */\n+    public Dimension getPreferredSize()\n+    {\n+      int height = numRows * cellHeight + (numRows - 1) * gap;\n+      int width = numCols * cellWidth + (numCols - 1) * gap;\n+      Insets insets = getInsets();\n+\n+      return new Dimension(width + insets.left + insets.right,\n+                           height + insets.top + insets.bottom);\n+    }\n+\n+    /**\n+     * This method returns the color for the given position.\n+     *\n+     * @param x The x coordinate of the position.\n+     * @param y The y coordinate of the position.\n+     *\n+     * @return The color at the given position.\n+     */\n+    public abstract Color getColorForPosition(int x, int y);\n+\n+    /**\n+     * This method initializes the colors for the swatch panel.\n+     */\n+    protected abstract void initializeColors();\n+  }\n+\n+  /**\n+   * This is the main swatch panel. This panel sits in the middle and allows a\n+   * set of colors to be picked which will move to the recent swatch panel.\n+   */\n+  static class MainSwatchPanel extends SwatchPanel\n+  {\n+    /** The color describing (204, 255, 255) */\n+    public static final Color C204255255 = new Color(204, 204, 255);\n+\n+    /** The color describing (255, 204, 204) */\n+    public static final Color C255204204 = new Color(255, 204, 204);\n+\n+    /** The color describing (204, 255, 204) */\n+    public static final Color C204255204 = new Color(204, 255, 204);\n+\n+    /** The color describing (204, 204, 204) */\n+    public static final Color C204204204 = new Color(204, 204, 204);\n+\n+    /** The color (153, 153, 255). */\n+    public static final Color C153153255 = new Color(153, 153, 255);\n+\n+    /** The color (51, 51, 255). */\n+    public static final Color C051051255 = new Color(51, 51, 255);\n+\n+    /** The color (153, 0, 153). */\n+    public static final Color C153000153 = new Color(153, 0, 153);\n+\n+    /** The color (0, 51, 51). */\n+    public static final Color C000051051 = new Color(0, 51, 51);\n+\n+    /** The color (51, 0, 51). */\n+    public static final Color C051000051 = new Color(51, 0, 51);\n+\n+    /** The color (51, 51, 0). */\n+    public static final Color C051051000 = new Color(51, 51, 0);\n+\n+    /** The color (102, 102, 0). */\n+    public static final Color C102102000 = new Color(102, 102, 0);\n+\n+    /** The color (153, 255, 153). */\n+    public static final Color C153255153 = new Color(153, 255, 153);\n+\n+    /** The color (102, 255, 102). */\n+    public static final Color C102255102 = new Color(102, 255, 102);\n+\n+    /** The color (0, 102, 102). */\n+    public static final Color C000102102 = new Color(0, 102, 102);\n+\n+    /** The color (102, 0, 102). */\n+    public static final Color C102000102 = new Color(102, 0, 102);\n+\n+    /** The color (0, 153, 153). */\n+    public static final Color C000153153 = new Color(0, 153, 153);\n+\n+    /** The color (153, 153, 0). */\n+    public static final Color C153153000 = new Color(153, 153, 0);\n+\n+    /** The color (204, 204, 0). */\n+    public static final Color C204204000 = new Color(204, 204, 0);\n+\n+    /** The color (204, 0, 204). */\n+    public static final Color C204000204 = new Color(204, 0, 204);\n+\n+    /** The color (0, 204, 204). */\n+    public static final Color C000204204 = new Color(0, 204, 204);\n+\n+    /** The color (51, 255, 51). */\n+    public static final Color C051255051 = new Color(51, 255, 51);\n+\n+    /** The color (255, 51, 51). */\n+    public static final Color C255051051 = new Color(255, 51, 51);\n+\n+    /** The color (255, 102, 102). */\n+    public static final Color C255102102 = new Color(255, 102, 102);\n+\n+    /** The color (102, 102, 255). */\n+    public static final Color C102102255 = new Color(102, 102, 255);\n+\n+    /** The color (255, 153, 153). */\n+    public static final Color C255153153 = new Color(255, 153, 153);\n+    static Color[] colors = \n+                            {\n+                              // Row 1\n+    Color.WHITE, new Color(204, 255, 255), C204255255, C204255255, C204255255,\n+                              C204255255, C204255255, C204255255, C204255255,\n+                              C204255255, C204255255, new Color(255, 204, 255),\n+                              C255204204, C255204204, C255204204, C255204204,\n+                              C255204204, C255204204, C255204204, C255204204,\n+                              C255204204, new Color(255, 255, 204), C204255204,\n+                              C204255204, C204255204, C204255204, C204255204,\n+                              C204255204, C204255204, C204255204, C204255204,\n+                              \n+    // Row 2\n+    C204204204, new Color(153, 255, 255), new Color(153, 204, 255), C153153255,\n+                              C153153255, C153153255, C153153255, C153153255,\n+                              C153153255, C153153255, new Color(204, 153, 255),\n+                              new Color(255, 153, 255),\n+                              new Color(255, 153, 204), C255153153, C255153153,\n+                              C255153153, C255153153, C255153153, C255153153,\n+                              C255153153, new Color(255, 204, 153),\n+                              new Color(255, 255, 153),\n+                              new Color(204, 255, 153), C153255153, C153255153,\n+                              C153255153, C153255153, C153255153, C153255153,\n+                              C153255153, new Color(153, 255, 204),\n+                              \n+    // Row 3\n+    C204204204, new Color(102, 255, 255), new Color(102, 204, 255),\n+                              new Color(102, 153, 255), C102102255, C102102255,\n+                              C102102255, C102102255, C102102255,\n+                              new Color(153, 102, 255),\n+                              new Color(204, 102, 255),\n+                              new Color(255, 102, 255),\n+                              new Color(255, 102, 204),\n+                              new Color(255, 102, 153), C255102102, C255102102,\n+                              C255102102, C255102102, C255102102,\n+                              new Color(255, 153, 102),\n+                              new Color(255, 204, 102),\n+                              new Color(255, 255, 102),\n+                              new Color(204, 255, 102),\n+                              new Color(153, 255, 102), C102255102, C102255102,\n+                              C102255102, C102255102, C102255102,\n+                              new Color(102, 255, 153),\n+                              new Color(102, 255, 204),\n+                              \n+    // Row 4\n+    new Color(153, 153, 153), new Color(51, 255, 255), new Color(51, 204, 255),\n+                              new Color(51, 153, 255), new Color(51, 102, 255),\n+                              C051051255, C051051255, C051051255,\n+                              new Color(102, 51, 255), new Color(153, 51, 255),\n+                              new Color(204, 51, 255), new Color(255, 51, 255),\n+                              new Color(255, 51, 204), new Color(255, 51, 153),\n+                              new Color(255, 51, 102), C255051051, C255051051,\n+                              C255051051, new Color(255, 102, 51),\n+                              new Color(255, 153, 51), new Color(255, 204, 51),\n+                              new Color(255, 255, 51), new Color(204, 255, 51),\n+                              new Color(153, 255, 51), new Color(102, 255, 51),\n+                              C051255051, C051255051, C051255051,\n+                              new Color(51, 255, 102), new Color(51, 255, 153),\n+                              new Color(51, 255, 204),\n+                              \n+    // Row 5\n+    new Color(153, 153, 153), new Color(0, 255, 255), new Color(0, 204, 255),\n+                              new Color(0, 153, 255), new Color(0, 102, 255),\n+                              new Color(0, 51, 255), new Color(0, 0, 255),\n+                              new Color(51, 0, 255), new Color(102, 0, 255),\n+                              new Color(153, 0, 255), new Color(204, 0, 255),\n+                              new Color(255, 0, 255), new Color(255, 0, 204),\n+                              new Color(255, 0, 153), new Color(255, 0, 102),\n+                              new Color(255, 0, 51), new Color(255, 0, 0),\n+                              new Color(255, 51, 0), new Color(255, 102, 0),\n+                              new Color(255, 153, 0), new Color(255, 204, 0),\n+                              new Color(255, 255, 0), new Color(204, 255, 0),\n+                              new Color(153, 255, 0), new Color(102, 255, 0),\n+                              new Color(51, 255, 0), new Color(0, 255, 0),\n+                              new Color(0, 255, 51), new Color(0, 255, 102),\n+                              new Color(0, 255, 153), new Color(0, 255, 204),\n+                              \n+    // Row 6\n+    new Color(102, 102, 102), C000204204, C000204204, new Color(0, 153, 204),\n+                              new Color(0, 102, 204), new Color(0, 51, 204),\n+                              new Color(0, 0, 204), new Color(51, 0, 204),\n+                              new Color(102, 0, 204), new Color(153, 0, 204),\n+                              C204000204, C204000204, C204000204,\n+                              new Color(204, 0, 153), new Color(204, 0, 102),\n+                              new Color(204, 0, 51), new Color(204, 0, 0),\n+                              new Color(204, 51, 0), new Color(204, 102, 0),\n+                              new Color(204, 153, 0), C204204000, C204204000,\n+                              C204204000, new Color(153, 204, 0),\n+                              new Color(102, 204, 0), new Color(51, 204, 0),\n+                              new Color(0, 204, 0), new Color(0, 204, 51),\n+                              new Color(0, 204, 102), new Color(0, 204, 153),\n+                              new Color(0, 204, 204),\n+                              \n+    // Row 7\n+    new Color(102, 102, 102), C000153153, C000153153, C000153153,\n+                              new Color(0, 102, 153), new Color(0, 51, 153),\n+                              new Color(0, 0, 153), new Color(51, 0, 153),\n+                              new Color(102, 0, 153), C153000153, C153000153,\n+                              C153000153, C153000153, C153000153,\n+                              new Color(153, 0, 102), new Color(153, 0, 51),\n+                              new Color(153, 0, 0), new Color(153, 51, 0),\n+                              new Color(153, 102, 0), C153153000, C153153000,\n+                              C153153000, C153153000, C153153000,\n+                              new Color(102, 153, 0), new Color(51, 153, 0),\n+                              new Color(0, 153, 0), new Color(0, 153, 51),\n+                              new Color(0, 153, 102), C000153153, C000153153,\n+                              \n+    // Row 8\n+    new Color(51, 51, 51), C000102102, C000102102, C000102102, C000102102,\n+                              new Color(0, 51, 102), new Color(0, 0, 102),\n+                              new Color(51, 0, 102), C102000102, C102000102,\n+                              C102000102, C102000102, C102000102, C102000102,\n+                              C102000102, new Color(102, 0, 51),\n+                              new Color(102, 0, 0), new Color(102, 51, 0),\n+                              C102102000, C102102000, C102102000, C102102000,\n+                              C102102000, C102102000, C102102000,\n+                              new Color(51, 102, 0), new Color(0, 102, 0),\n+                              new Color(0, 102, 51), C000102102, C000102102,\n+                              C000102102,\n+                              \n+    // Row 9.\n+    Color.BLACK, C000051051, C000051051, C000051051, C000051051, C000051051,\n+                              new Color(0, 0, 51), C051000051, C051000051,\n+                              C051000051, C051000051, C051000051, C051000051,\n+                              C051000051, C051000051, C051000051,\n+                              new Color(51, 0, 0), C051051000, C051051000,\n+                              C051051000, C051051000, C051051000, C051051000,\n+                              C051051000, C051051000, new Color(0, 51, 0),\n+                              C000051051, C000051051, C000051051, C000051051,\n+                              new Color(51, 51, 51)\n+                            };\n+\n+    /**\n+     * Creates a new MainSwatchPanel object.\n+     */\n+    MainSwatchPanel()\n+    {\n+      super();\n+      numCols = 31;\n+      numRows = 9;\n+      initializeColors();\n+      revalidate();\n+    }\n+\n+    /**\n+     * This method returns the color for the given position.\n+     *\n+     * @param x The x location for the position.\n+     * @param y The y location for the position.\n+     *\n+     * @return The color for the given position.\n+     */\n+    public Color getColorForPosition(int x, int y)\n+    {\n+      if (x % (cellWidth + gap) > cellWidth\n+          || y % (cellHeight + gap) > cellHeight)\n+\t// position is located in gap.\n+\treturn null;\n+\n+      int row = y / (cellHeight + gap);\n+      int col = x / (cellWidth + gap);\n+      return colors[row * numCols + col];\n+    }\n+\n+    /**\n+     * This method initializes the colors for the main swatch panel.\n+     */\n+    protected void initializeColors()\n+    {\n+      // Unnecessary\n+    }\n+\n+    /**\n+     * This method paints the main graphics panel with the given Graphics\n+     * object.\n+     *\n+     * @param graphics The Graphics object to paint with.\n+     */\n+    public void paint(Graphics graphics)\n+    {\n+      int index = 0;\n+      Insets insets = getInsets();\n+      int currX = insets.left;\n+      int currY = insets.top;\n+      Color saved = graphics.getColor();\n+\n+      for (int i = 0; i < numRows; i++)\n+        {\n+\t  for (int j = 0; j < numCols; j++)\n+\t    {\n+\t      graphics.setColor(colors[index++]);\n+\t      graphics.fill3DRect(currX, currY, cellWidth, cellHeight, true);\n+\t      currX += gap + cellWidth;\n+\t    }\n+\t  currX = insets.left;\n+\t  currY += gap + cellHeight;\n+        }\n+      graphics.setColor(saved);\n+    }\n+\n+    /**\n+     * This method returns the tooltip text for the given MouseEvent.\n+     *\n+     * @param e The MouseEvent to find tooltip text for.\n+     *\n+     * @return The tooltip text.\n+     */\n+    public String getToolTipText(MouseEvent e)\n+    {\n+      Color c = getColorForPosition(e.getX(), e.getY());\n+      if (c == null)\n+\treturn null;\n+      return (c.getRed() + \",\" + c.getGreen() + \",\" + c.getBlue());\n+    }\n+  }\n+\n+  /**\n+   * This class is the recent swatch panel. It holds recently selected colors.\n+   */\n+  public static class RecentSwatchPanel extends SwatchPanel\n+  {\n+    /** The array for storing recently stored colors. */\n+    Color[] colors;\n+\n+    /** The default color. */\n+    public static final Color defaultColor = Color.GRAY;\n+\n+    /** The index of the array that is the start. */\n+    int start = 0;\n+\n+    /**\n+     * Creates a new RecentSwatchPanel object.\n+     */\n+    RecentSwatchPanel()\n+    {\n+      super();\n+      numCols = 5;\n+      numRows = 7;\n+      initializeColors();\n+      revalidate();\n+    }\n+\n+    /**\n+     * This method returns the color for the given position.\n+     *\n+     * @param x The x coordinate of the position.\n+     * @param y The y coordinate of the position.\n+     *\n+     * @return The color for the given position.\n+     */\n+    public Color getColorForPosition(int x, int y)\n+    {\n+      if (x % (cellWidth + gap) > cellWidth\n+          || y % (cellHeight + gap) > cellHeight)\n+\t// position is located in gap.\n+\treturn null;\n+\n+      int row = y / (cellHeight + gap);\n+      int col = x / (cellWidth + gap);\n+\n+      return colors[getIndexForCell(row, col)];\n+    }\n+\n+    /**\n+     * This method initializes the colors for the recent swatch panel.\n+     */\n+    protected void initializeColors()\n+    {\n+      colors = new Color[numRows * numCols];\n+      for (int i = 0; i < colors.length; i++)\n+\tcolors[i] = defaultColor;\n+    }\n+\n+    /**\n+     * This method returns the array index for the given row and column.\n+     *\n+     * @param row The row.\n+     * @param col The column.\n+     *\n+     * @return The array index for the given row and column.\n+     */\n+    private int getIndexForCell(int row, int col)\n+    {\n+      return ((row * numCols) + col + start) % (numRows * numCols);\n+    }\n+\n+    /**\n+     * This method adds the given color to the beginning of the swatch panel.\n+     *\n+     * @param c The color to add.\n+     */\n+    private void addColorToQueue(Color c)\n+    {\n+      if (--start == -1)\n+\tstart = numRows * numCols - 1;\n+\n+      colors[start] = c;\n+    }\n+\n+    /**\n+     * This method paints the panel with the given Graphics object.\n+     *\n+     * @param g The Graphics object to paint with.\n+     */\n+    public void paint(Graphics g)\n+    {\n+      Color saved = g.getColor();\n+      Insets insets = getInsets();\n+      int currX = insets.left;\n+      int currY = insets.top;\n+\n+      for (int i = 0; i < numRows; i++)\n+        {\n+\t  for (int j = 0; j < numCols; j++)\n+\t    {\n+\t      g.setColor(colors[getIndexForCell(i, j)]);\n+\t      g.fill3DRect(currX, currY, cellWidth, cellHeight, true);\n+\t      currX += cellWidth + gap;\n+\t    }\n+\t  currX = insets.left;\n+\t  currY += cellWidth + gap;\n+        }\n+    }\n+\n+    /**\n+     * This method returns the tooltip text for the given MouseEvent.\n+     *\n+     * @param e The MouseEvent.\n+     *\n+     * @return The tooltip text.\n+     */\n+    public String getToolTipText(MouseEvent e)\n+    {\n+      Color c = getColorForPosition(e.getX(), e.getY());\n+      if (c == null)\n+\treturn null;\n+      return c.getRed() + \",\" + c.getGreen() + \",\" + c.getBlue();\n+    }\n+  }\n+\n+  /**\n+   * This class handles mouse events for the two swatch panels.\n+   */\n+  class MouseHandler extends MouseAdapter\n+  {\n+    /**\n+     * This method is called whenever the mouse is pressed.\n+     *\n+     * @param e The MouseEvent.\n+     */\n+    public void mousePressed(MouseEvent e)\n+    {\n+      SwatchPanel panel = (SwatchPanel) e.getSource();\n+      Color c = panel.getColorForPosition(e.getX(), e.getY());\n+      recentPalette.addColorToQueue(c);\n+      DefaultSwatchChooserPanel.this.getColorSelectionModel().setSelectedColor(c);\n+      DefaultSwatchChooserPanel.this.repaint();\n+    }\n+  }\n+\n+  /**\n+   * This is the layout manager for the main panel.\n+   */\n+  static class MainPanelLayout implements LayoutManager\n+  {\n+    /**\n+     * This method is called when a new component is added to the container.\n+     *\n+     * @param name The name of the component.\n+     * @param comp The added component.\n+     */\n+    public void addLayoutComponent(String name, Component comp)\n+    {\n+    }\n+\n+    /**\n+     * This method is called to set the size and position of the child\n+     * components for the given container.\n+     *\n+     * @param parent The container to lay out.\n+     */\n+    public void layoutContainer(Container parent)\n+    {\n+      Component[] comps = parent.getComponents();\n+      Insets insets = parent.getInsets();\n+      Dimension[] pref = new Dimension[comps.length];\n+\n+      int xpos = 0;\n+      int ypos = 0;\n+      int maxHeight = 0;\n+      int totalWidth = 0;\n+\n+      for (int i = 0; i < comps.length; i++)\n+        {\n+\t  pref[i] = comps[i].getPreferredSize();\n+\t  if (pref[i] == null)\n+\t    return;\n+\t  maxHeight = Math.max(maxHeight, pref[i].height);\n+\t  totalWidth += pref[i].width;\n+        }\n+\n+      ypos = (parent.getSize().height - maxHeight) / 2 + insets.top;\n+      xpos = insets.left + (parent.getSize().width - totalWidth) / 2;\n+\n+      for (int i = 0; i < comps.length; i++)\n+        {\n+\t  if (pref[i] == null)\n+\t    continue;\n+\t  comps[i].setBounds(xpos, ypos, pref[i].width, pref[i].height);\n+\t  xpos += pref[i].width;\n+        }\n+    }\n+\n+    /**\n+     * This method is called when a component is removed from the container.\n+     *\n+     * @param comp The component that was removed.\n+     */\n+    public void removeLayoutComponent(Component comp)\n+    {\n+    }\n+\n+    /**\n+     * This methods calculates the minimum layout size for the container.\n+     *\n+     * @param parent The container.\n+     *\n+     * @return The minimum layout size.\n+     */\n+    public Dimension minimumLayoutSize(Container parent)\n+    {\n+      return preferredLayoutSize(parent);\n+    }\n+\n+    /**\n+     * This method returns the preferred layout size for the given container.\n+     *\n+     * @param parent The container.\n+     *\n+     * @return The preferred layout size.\n+     */\n+    public Dimension preferredLayoutSize(Container parent)\n+    {\n+      int xmax = 0;\n+      int ymax = 0;\n+\n+      Component[] comps = parent.getComponents();\n+      Dimension pref;\n+\n+      for (int i = 0; i < comps.length; i++)\n+        {\n+\t  pref = comps[i].getPreferredSize();\n+\t  if (pref == null)\n+\t    continue;\n+\t  xmax += pref.width;\n+\t  ymax = Math.max(ymax, pref.height);\n+        }\n+\n+      Insets insets = parent.getInsets();\n+\n+      return new Dimension(insets.left + insets.right + xmax,\n+                           insets.top + insets.bottom + ymax);\n+    }\n+  }\n+\n+  /**\n+   * This is the layout manager for the recent swatch panel.\n+   */\n+  static class RecentPanelLayout implements LayoutManager\n+  {\n+    /**\n+     * This method is called when a component is added to the container.\n+     *\n+     * @param name The name of the component.\n+     * @param comp The added component.\n+     */\n+    public void addLayoutComponent(String name, Component comp)\n+    {\n+      // Nothing needs to be done.\n+    }\n+\n+    /**\n+     * This method sets the size and position of the child components of the\n+     * given container.\n+     *\n+     * @param parent The container to lay out.\n+     */\n+    public void layoutContainer(Container parent)\n+    {\n+      Component[] comps = parent.getComponents();\n+      Dimension parentSize = parent.getSize();\n+      Insets insets = parent.getInsets();\n+      int currY = insets.top;\n+      Dimension pref;\n+\n+      for (int i = 0; i < comps.length; i++)\n+        {\n+\t  pref = comps[i].getPreferredSize();\n+\t  if (pref == null)\n+\t    continue;\n+\t  comps[i].setBounds(insets.left, currY, pref.width, pref.height);\n+\t  currY += pref.height;\n+        }\n+    }\n+\n+    /**\n+     * This method calculates the minimum layout size for the given container.\n+     *\n+     * @param parent The container.\n+     *\n+     * @return The minimum layout size.\n+     */\n+    public Dimension minimumLayoutSize(Container parent)\n+    {\n+      return preferredLayoutSize(parent);\n+    }\n+\n+    /**\n+     * This method calculates the preferred layout size for the given\n+     * container.\n+     *\n+     * @param parent The container.\n+     *\n+     * @return The preferred layout size.\n+     */\n+    public Dimension preferredLayoutSize(Container parent)\n+    {\n+      int width = 0;\n+      int height = 0;\n+      Insets insets = parent.getInsets();\n+      Component[] comps = parent.getComponents();\n+      Dimension pref;\n+      for (int i = 0; i < comps.length; i++)\n+        {\n+\t  pref = comps[i].getPreferredSize();\n+\t  if (pref != null)\n+\t    {\n+\t      width = Math.max(width, pref.width);\n+\t      height += pref.height;\n+\t    }\n+        }\n+\n+      return new Dimension(width + insets.left + insets.right,\n+                           height + insets.top + insets.bottom);\n+    }\n+\n+    /**\n+     * This method is called whenever a component is removed from the\n+     * container.\n+     *\n+     * @param comp The removed component.\n+     */\n+    public void removeLayoutComponent(Component comp)\n+    {\n+      // Nothing needs to be done.\n+    }\n+  }\n+\n+  /**\n+   * Creates a new DefaultSwatchChooserPanel object.\n+   */\n+  DefaultSwatchChooserPanel()\n+  {\n+    super();\n+  }\n+\n+  /**\n+   * This method updates the chooser panel with the new value from the\n+   * JColorChooser.\n+   */\n+  public void updateChooser()\n+  {\n+  }\n+\n+  /**\n+   * This method builds the chooser panel.\n+   */\n+  protected void buildChooser()\n+  {\n+    // The structure of the swatch panel is:\n+    // One large panel (minus the insets).\n+    // Inside that panel, there are two panels, one holds the palette.\n+    // The other holds the label and the recent colors palette.\n+    // The two palettes are two custom swatch panels.\n+    setLayout(new MainPanelLayout());\n+\n+    JPanel mainPaletteHolder = new JPanel();\n+    JPanel recentPaletteHolder = new JPanel();\n+\n+    mainPalette = new MainSwatchPanel();\n+    recentPalette = new RecentSwatchPanel();\n+    JLabel label = new JLabel(\"Recent:\");\n+\n+    mouseHandler = new MouseHandler();\n+    mainPalette.addMouseListener(mouseHandler);\n+    recentPalette.addMouseListener(mouseHandler);\n+\n+    mainPaletteHolder.setLayout(new BorderLayout());\n+    mainPaletteHolder.add(mainPalette, BorderLayout.CENTER);\n+\n+    recentPaletteHolder.setLayout(new RecentPanelLayout());\n+    recentPaletteHolder.add(label);\n+    recentPaletteHolder.add(recentPalette);\n+\n+    JPanel main = new JPanel();\n+    main.add(mainPaletteHolder);\n+    main.add(recentPaletteHolder);\n+\n+    this.add(main);\n+  }\n+\n+  /**\n+   * This method removes the chooser panel from the JColorChooser.\n+   *\n+   * @param chooser The JColorChooser this panel is being removed from.\n+   */\n+  public void uninstallChooserPanel(JColorChooser chooser)\n+  {\n+    recentPalette = null;\n+    mainPalette = null;\n+\n+    removeAll();\n+    super.uninstallChooserPanel(chooser);\n+  }\n+\n+  /**\n+   * This method returns the JTabbedPane displayed name.\n+   *\n+   * @return The name displayed in the JTabbedPane.\n+   */\n+  public String getDisplayName()\n+  {\n+    return \"Swatches\";\n+  }\n+\n+  /**\n+   * This method returns the small display icon.\n+   *\n+   * @return The small display icon.\n+   */\n+  public Icon getSmallDisplayIcon()\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * This method returns the large display icon.\n+   *\n+   * @return The large display icon.\n+   */\n+  public Icon getLargeDisplayIcon()\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * This method paints the chooser panel with the given Graphics object.\n+   *\n+   * @param g The Graphics object to paint with.\n+   */\n+  public void paint(Graphics g)\n+  {\n+    super.paint(g);\n+  }\n+\n+  /**\n+   * This method returns the tooltip text for the given MouseEvent.\n+   *\n+   * @param e The MouseEvent.\n+   *\n+   * @return The tooltip text.\n+   */\n+  public String getToolTipText(MouseEvent e)\n+  {\n+    return null;\n+  }\n+}"}, {"sha": "1c2dcd69545f7a2a569bc77fc0b316631bb26da3", "filename": "libjava/javax/swing/plaf/basic/BasicColorChooserUI.java", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicColorChooserUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicColorChooserUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicColorChooserUI.java?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,338 @@\n+/* BasicColorChooserUI.java\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.plaf.basic;\n+\n+import java.awt.BorderLayout;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.awt.Rectangle;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import javax.swing.JColorChooser;\n+import javax.swing.JComponent;\n+import javax.swing.JPanel;\n+import javax.swing.JTabbedPane;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n+import javax.swing.colorchooser.AbstractColorChooserPanel;\n+import javax.swing.colorchooser.ColorChooserComponentFactory;\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n+import javax.swing.plaf.ColorChooserUI;\n+import javax.swing.plaf.ComponentUI;\n+\n+\n+/**\n+ * This is the UI Class for the JColorChooser in the Basic Look and Feel.\n+ */\n+public class BasicColorChooserUI extends ColorChooserUI\n+{\n+  /**\n+   * This helper class handles property changes from the JColorChooser.\n+   */\n+  public class PropertyHandler implements PropertyChangeListener\n+  {\n+    /**\n+     * This method is called when any of the properties of the JColorChooser\n+     * change.\n+     *\n+     * @param e The PropertyChangeEvent.\n+     */\n+    public void propertyChange(PropertyChangeEvent e)\n+    {\n+      if (e.getPropertyName() == JColorChooser.CHOOSER_PANELS_PROPERTY)\n+\tmakeTabs(chooser.getChooserPanels());\n+      else if (e.getPropertyName() == JColorChooser.PREVIEW_PANEL_PROPERTY)\n+\tupdatePreviewPanel(chooser.getPreviewPanel());\n+      else if (e.getPropertyName() == JColorChooser.SELECTION_MODEL_PROPERTY)\n+\t((AbstractColorChooserPanel) pane.getSelectedComponent())\n+\t.updateChooser();\n+\n+      chooser.repaint();\n+    }\n+  }\n+\n+  /**\n+   * This is a helper class that listens to the Model of the JColorChooser for\n+   * color change events so it can update the preview panel.\n+   */\n+  private class PreviewListener implements ChangeListener\n+  {\n+    /**\n+     * This method is called whenever the JColorChooser's color changes.\n+     *\n+     * @param e The ChangeEvent.\n+     */\n+    public void stateChanged(ChangeEvent e)\n+    {\n+      if (pane != null)\n+        {\n+\t  AbstractColorChooserPanel panel = (AbstractColorChooserPanel) pane\n+\t                                    .getSelectedComponent();\n+\t  if (panel != null)\n+\t    panel.updateChooser();\n+        }\n+      chooser.repaint();\n+    }\n+  }\n+\n+  /**\n+   * This helper class listens to the JTabbedPane that is used for tab\n+   * changes.\n+   */\n+  private class TabPaneListener implements ChangeListener\n+  {\n+    /**\n+     * This method is called whenever a different tab is selected in the\n+     * JTabbedPane.\n+     *\n+     * @param e The ChangeEvent.\n+     */\n+    public void stateChanged(ChangeEvent e)\n+    {\n+      // Need to do this because we don't update all the tabs when they're not\n+      // visible, so they are not informed of new colors when they're hidden.\n+      AbstractColorChooserPanel comp = (AbstractColorChooserPanel) pane\n+                                       .getSelectedComponent();\n+      comp.updateChooser();\n+    }\n+  }\n+\n+  /** An array of default choosers to use in the JColorChooser. */\n+  protected AbstractColorChooserPanel[] defaultChoosers;\n+\n+  /** The listener for the preview panel. */\n+  protected ChangeListener previewListener;\n+\n+  /** The PropertyChangeListener for the JColorChooser. */\n+  protected PropertyChangeListener propertyChangeListener;\n+\n+  /** The JColorChooser. */\n+  private JColorChooser chooser;\n+\n+  /** The JTabbedPane that is used. */\n+  private JTabbedPane pane;\n+\n+  /** The Container that holds the preview panel. */\n+  private Container prevContainer;\n+\n+  /**\n+   * Creates a new BasicColorChooserUI object.\n+   */\n+  public BasicColorChooserUI()\n+  {\n+    super();\n+  }\n+\n+  /**\n+   * This method creates a new UI Component for the given JComponent.\n+   *\n+   * @param c The JComponent to create an UI for.\n+   *\n+   * @return A new BasicColorChooserUI.\n+   */\n+  public static ComponentUI createUI(JComponent c)\n+  {\n+    return new BasicColorChooserUI();\n+  }\n+\n+  /**\n+   * This method creates the default chooser panels for the JColorChooser.\n+   *\n+   * @return The default chooser panels.\n+   */\n+  protected AbstractColorChooserPanel[] createDefaultChoosers()\n+  {\n+    return ColorChooserComponentFactory.getDefaultChooserPanels();\n+  }\n+\n+  /**\n+   * This method installs the UI Component for the given JComponent.\n+   *\n+   * @param c The JComponent to install this UI for.\n+   */\n+  public void installUI(JComponent c)\n+  {\n+    if (c instanceof JColorChooser)\n+      {\n+\tchooser = (JColorChooser) c;\n+\tchooser.setLayout(new BorderLayout());\n+\n+\t// Do this first, so we avoid doing work for property change events.\n+\tdefaultChoosers = createDefaultChoosers();\n+\tchooser.setChooserPanels(defaultChoosers);\n+\tpane = new JTabbedPane();\n+\n+\tpane.addChangeListener(new ChangeListener()\n+\t    {\n+\t      public void stateChanged(ChangeEvent e)\n+\t      {\n+\t\tpane.repaint();\n+\t      }\n+\t    });\n+\n+\tmakeTabs(defaultChoosers);\n+\n+\tchooser.add(pane, BorderLayout.NORTH);\n+\n+\tinstallPreviewPanel();\n+\n+\tinstallDefaults();\n+\tinstallListeners();\n+      }\n+  }\n+\n+  /**\n+   * This method adds tabs to the JTabbedPane for the chooserPanels defined in\n+   * the JColorChooser.\n+   *\n+   * @param panels The Panels that need tabs to be made for them.\n+   */\n+  private void makeTabs(AbstractColorChooserPanel[] panels)\n+  {\n+    pane.removeAll();\n+    for (int i = 0; i < panels.length; i++)\n+      pane.addTab(panels[i].getDisplayName(), panels[i].getSmallDisplayIcon(),\n+                  panels[i]);\n+  }\n+\n+  /**\n+   * This method uninstalls this UI for the given JComponent.\n+   *\n+   * @param c The JComponent that will have this UI removed.\n+   */\n+  public void uninstallUI(JComponent c)\n+  {\n+    uninstallListeners();\n+    uninstallDefaults();\n+\n+    pane = null;\n+    chooser = null;\n+  }\n+\n+  /**\n+   * This method installs the preview panel for the JColorChooser.\n+   */\n+  protected void installPreviewPanel()\n+  {\n+    updatePreviewPanel(ColorChooserComponentFactory.getPreviewPanel());\n+  }\n+\n+  /**\n+   * This is a helper method that swaps the existing preview panel with the\n+   * given panel.\n+   *\n+   * @param preview The new preview panel.\n+   */\n+  private void updatePreviewPanel(JComponent preview)\n+  {\n+    if (prevContainer == null)\n+      {\n+\tprevContainer = new JPanel();\n+\tprevContainer.setLayout(new BorderLayout());\n+\tchooser.add(prevContainer, BorderLayout.CENTER);\n+      }\n+    prevContainer.removeAll();\n+    prevContainer.add(preview, BorderLayout.CENTER);\n+  }\n+\n+  /**\n+   * This method installs the default properties given by the Basic Look and\n+   * Feel.\n+   */\n+  protected void installDefaults()\n+  {\n+    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n+\n+    chooser.setFont(defaults.getFont(\"ColorChooser.font\"));\n+    chooser.setForeground(defaults.getColor(\"ColorChooser.foreground\"));\n+    chooser.setBackground(defaults.getColor(\"ColorChooser.background\"));\n+  }\n+\n+  /**\n+   * This method uninstalls the default properties given by the Basic Look and\n+   * Feel.\n+   */\n+  protected void uninstallDefaults()\n+  {\n+    chooser.setBackground(null);\n+    chooser.setForeground(null);\n+    chooser.setFont(null);\n+  }\n+\n+  /**\n+   * This method installs any listeners required for this UI to function.\n+   */\n+  protected void installListeners()\n+  {\n+    propertyChangeListener = createPropertyChangeListener();\n+    previewListener = new PreviewListener();\n+\n+    chooser.addPropertyChangeListener(propertyChangeListener);\n+    chooser.getSelectionModel().addChangeListener(previewListener);\n+\n+    pane.addChangeListener(new TabPaneListener());\n+  }\n+\n+  /**\n+   * This method creates the PropertyChangeListener used for listening to the\n+   * JColorChooser.\n+   *\n+   * @return A PropertyChangeListener.\n+   */\n+  protected PropertyChangeListener createPropertyChangeListener()\n+  {\n+    return new PropertyHandler();\n+  }\n+\n+  /**\n+   * This method uninstalls any listeners that were previously installed by\n+   * the UI.\n+   */\n+  protected void uninstallListeners()\n+  {\n+    chooser.removePropertyChangeListener(propertyChangeListener);\n+    chooser.getSelectionModel().removeChangeListener(previewListener);\n+\n+    previewListener = null;\n+    propertyChangeListener = null;\n+  }\n+}"}, {"sha": "a465ff9492b9fedc7fa2c41622e868f5bc83e672", "filename": "libjava/javax/swing/plaf/basic/BasicComboBoxEditor.java", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicComboBoxEditor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicComboBoxEditor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicComboBoxEditor.java?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,170 @@\n+/* BasicComboBoxEditor.java --\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.plaf.basic;\n+\n+import java.awt.Component;\n+import java.awt.event.ActionListener;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.FocusListener;\n+import javax.swing.ComboBoxEditor;\n+import javax.swing.JTextField;\n+import javax.swing.border.EmptyBorder;\n+import javax.swing.plaf.UIResource;\n+\n+\n+/**\n+ * This is a component that is responsible for displaying/editting  selected\n+ * item in comboBox. By default, the  JTextField is returned as\n+ * BasicComboBoxEditor.\n+ *\n+ * @author Olga Rodimina\n+ */\n+public class BasicComboBoxEditor extends Object implements ComboBoxEditor,\n+                                                           FocusListener\n+{\n+  protected JTextField editor;\n+\n+  /**\n+   * Creates a new BasicComboBoxEditor object.\n+   */\n+  public BasicComboBoxEditor()\n+  {\n+    editor = new JTextField();\n+    editor.setBorder(new EmptyBorder(1, 1, 1, 1));\n+  }\n+\n+  /**\n+   * This method returns textfield that will be used by the combo  box to\n+   * display/edit currently selected item in the combo box.\n+   *\n+   * @return textfield that will be used by the combo box to  display/edit\n+   *         currently selected item\n+   */\n+  public Component getEditorComponent()\n+  {\n+    return editor;\n+  }\n+\n+  /**\n+   * Sets item that should be editted when any editting operation is performed\n+   * by the user. The value is always equal to the currently selected value\n+   * in the combo box. Thus whenever a different value is selected from the\n+   * combo box list then this method should be  called to change editting\n+   * item to the new selected item.\n+   *\n+   * @param selectedItem item that is currently selected in the combo box\n+   */\n+  public void setItem(Object item)\n+  {\n+    editor.setText(item.toString());\n+  }\n+\n+  /**\n+   * This method returns item that is currently editable.\n+   *\n+   * @return item in the combo box that is currently editable\n+   */\n+  public Object getItem()\n+  {\n+    return editor.getText();\n+  }\n+\n+  public void selectAll()\n+  {\n+    editor.selectAll();\n+  }\n+\n+  /**\n+   * This method is called when textfield gains focus. This will enable\n+   * editing of the selected item.\n+   *\n+   * @param e the FocusEvent describing change in focus.\n+   */\n+  public void focusGained(FocusEvent e)\n+  {\n+    // FIXME: Need to implement\n+  }\n+\n+  /**\n+   * This method is called when textfield loses focus. If during this time any\n+   * editting operation was performed by the user, then it will be cancelled\n+   * and selected item will not be changed.\n+   *\n+   * @param e the FocusEvent describing change in focus\n+   */\n+  public void focusLost(FocusEvent e)\n+  {\n+    // FIXME: Need to implement\n+  }\n+\n+  /**\n+   * This method adds actionListener to the editor. If the user will edit\n+   * currently selected item in the textfield and pressEnter, then action\n+   * will be performed. The actionPerformed of this ActionListener should\n+   * change the selected item of the comboBox to the newly editted  selected\n+   * item.\n+   *\n+   * @param l the ActionListener responsible for changing selected item of the\n+   *        combo box when it is editted by the user.\n+   */\n+  public void addActionListener(ActionListener l)\n+  {\n+    // FIXME: Need to implement\n+  }\n+\n+  /**\n+   * This method removes actionListener from the textfield.\n+   *\n+   * @param l the ActionListener to remove from the textfield.\n+   */\n+  public void removeActionListener(ActionListener l)\n+  {\n+    // FIXME: Need to implement\n+  }\n+\n+  public static class UIResource extends BasicComboBoxEditor\n+    implements javax.swing.plaf.UIResource\n+  {\n+    /**\n+     * Creates a new UIResource object.\n+     */\n+    public UIResource()\n+    {\n+    }\n+  }\n+}"}, {"sha": "6bf6a74d5c944f3a105ffa601c4e0d4466cec3d6", "filename": "libjava/javax/swing/plaf/basic/BasicComboBoxRenderer.java", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicComboBoxRenderer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicComboBoxRenderer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicComboBoxRenderer.java?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,143 @@\n+/* BasicComboBoxRenderer.java --\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.plaf.basic;\n+\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.io.Serializable;\n+import javax.swing.JLabel;\n+import javax.swing.JList;\n+import javax.swing.ListCellRenderer;\n+import javax.swing.SwingConstants;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n+import javax.swing.border.Border;\n+import javax.swing.border.EmptyBorder;\n+import javax.swing.plaf.UIResource;\n+\n+\n+/**\n+ * This class is renderer for the combo box. \n+ *\n+ * @author Olga Rodimina\n+ */\n+public class BasicComboBoxRenderer extends JLabel implements ListCellRenderer,\n+                                                             Serializable\n+{\n+  /**\n+   * This border is used whenever renderer doesn't have a focus.\n+   */\n+  protected static Border noFocusBorder = new EmptyBorder(0, 0, 0, 0);\n+\n+  /**\n+   * Creates a new BasicComboBoxRenderer object.\n+   */\n+  public BasicComboBoxRenderer()\n+  {\n+    setHorizontalAlignment(SwingConstants.LEFT);\n+  }\n+\n+  /**\n+   * Returns preferredSize of the renderer\n+   *\n+   * @return preferredSize of the renderer\n+   */\n+  public Dimension getPreferredSize()\n+  {\n+    return super.getPreferredSize();\n+  }\n+\n+  /**\n+   * getListCellRendererComponent\n+   *\n+   * @param list List of items for which to the background and foreground\n+   *        colors\n+   * @param value object that should be rendered in the cell\n+   * @param index index of the cell in the list of items.\n+   * @param isSelected draw cell highlighted if isSelected is true\n+   * @param cellHasFocus draw focus rectangle around cell if the cell has\n+   *        focus\n+   *\n+   * @return Component that will be used to draw the desired cell.\n+   */\n+  public Component getListCellRendererComponent(JList list, Object value,\n+                                                int index, boolean isSelected,\n+                                                boolean cellHasFocus)\n+  {\n+    String s = value.toString();\n+    setText(s);\n+    setOpaque(true);\n+\n+    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n+\n+    if (isSelected)\n+      {\n+\tsetBackground(list.getSelectionBackground());\n+\tsetForeground(list.getSelectionForeground());\n+      }\n+    else\n+      {\n+\tsetBackground(list.getBackground());\n+\tsetForeground(list.getForeground());\n+      }\n+\n+    setEnabled(list.isEnabled());\n+    setFont(list.getFont());\n+\n+    // Use focusCellHighlightBorder when renderer has focus and \n+    // noFocusBorder otherwise\n+    if (cellHasFocus)\n+      setBorder(UIManager.getBorder(\"List.focusCellHighlightBorder\"));\n+    else\n+      setBorder(noFocusBorder);\n+\n+    return this;\n+  }\n+\n+  public static class UIResource extends BasicComboBoxRenderer\n+    implements javax.swing.plaf.UIResource\n+  {\n+    /**\n+     * Creates a new UIResource object.\n+     */\n+    public UIResource()\n+    {\n+    }\n+  }\n+}"}, {"sha": "851392a0f9f159aa6701597c7da0401f0b528a21", "filename": "libjava/javax/swing/plaf/basic/BasicComboBoxUI.java", "status": "added", "additions": 1227, "deletions": 0, "changes": 1227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicComboBoxUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicComboBoxUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicComboBoxUI.java?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,1227 @@\n+/* BasicComboBoxUI.java --\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.plaf.basic;\n+\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.awt.Rectangle;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.FocusListener;\n+import java.awt.event.ItemEvent;\n+import java.awt.event.ItemListener;\n+import java.awt.event.KeyAdapter;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.KeyListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseListener;\n+import java.awt.event.MouseMotionListener;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.EventListener;\n+import javax.accessibility.Accessible;\n+import javax.swing.CellRendererPane;\n+import javax.swing.ComboBoxEditor;\n+import javax.swing.ComboBoxModel;\n+import javax.swing.JButton;\n+import javax.swing.JComboBox;\n+import javax.swing.JComponent;\n+import javax.swing.JLabel;\n+import javax.swing.JList;\n+import javax.swing.ListCellRenderer;\n+import javax.swing.SwingConstants;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n+import javax.swing.event.ListDataEvent;\n+import javax.swing.event.ListDataListener;\n+import javax.swing.event.PopupMenuEvent;\n+import javax.swing.event.PopupMenuListener;\n+import javax.swing.plaf.ComboBoxUI;\n+import javax.swing.plaf.ComponentUI;\n+import javax.swing.plaf.basic.BasicComboPopup;\n+import javax.swing.plaf.basic.BasicGraphicsUtils;\n+\n+\n+/**\n+ * UI Delegate for JComboBox\n+ *\n+ * @author Olga Rodimina\n+ */\n+public class BasicComboBoxUI extends ComboBoxUI\n+{\n+  /**\n+   * This arrow button that is displayed in the rigth side of JComboBox. This\n+   * button is used to hide and show combo box's list of items\n+   */\n+  protected JButton arrowButton;\n+\n+  /**\n+   * The combo box for which this UI delegate is for\n+   */\n+  protected JComboBox comboBox;\n+\n+  /**\n+   * Component that is responsible for displaying/editting  selected item of\n+   * the combo box. By default JTextField is used as an editor for the\n+   * JComboBox\n+   */\n+  protected Component editor;\n+\n+  /**\n+   * Listener listening to focus events occuring in the JComboBox\n+   */\n+  protected FocusListener focusListener;\n+\n+  /**\n+   * tells whether JComboBox currently has focus\n+   */\n+  protected boolean hasFocus;\n+\n+  /**\n+   * Listener listening to item events fired by the JComboBox\n+   */\n+  protected ItemListener itemListener;\n+\n+  /**\n+   * KeyListener listening to key events that occur while JComboBox has focus\n+   */\n+  protected KeyListener keyListener;\n+\n+  /**\n+   * MouseListener listening to mouse events occuring in the combo box\n+   */\n+  private MouseListener mouseListener;\n+\n+  /**\n+   * List used when rendering selected item of the combo box. The selection\n+   * and foreground colors for combo box renderer  are configured from this\n+   * list\n+   */\n+  protected JList listBox;\n+\n+  /**\n+   * ListDataListener listening to JComboBox model\n+   */\n+  protected ListDataListener listDataListener;\n+\n+  /**\n+   * Popup list containing combo box's menu items\n+   */\n+  protected ComboPopup popup;\n+  protected KeyListener popupKeyListener;\n+  protected MouseListener popupMouseListener;\n+  protected MouseMotionListener popupMouseMotionListener;\n+\n+  /**\n+   * Listener listening to changes in the bound properties of JComboBox\n+   */\n+  protected PropertyChangeListener propertyChangeListener;\n+\n+  /**\n+   * Colors that are used to render selected item in the combo box.\n+   */\n+  private Color shadow;\n+  private Color darkShadow;\n+  private Color highlight;\n+  private Color lightHighlight;\n+\n+  /* Size of the largest item in the comboBox */\n+  private Dimension largestItemSize;\n+\n+  // It seems that JComboBox doesn't have a border set explicitely. So we just\n+  // paint the border everytime combo box is displayed. \n+\n+  /* border insets for this JComboBox*/\n+  private static final Insets borderInsets = new Insets(2, 2, 2, 2);\n+\n+  // Width of the arrow button  \n+  private static int arrowButtonWidth = 15;\n+\n+  // FIXME: This fields aren't used anywhere at this moment.\n+  protected Dimension cachedMinimumSize;\n+  protected CellRendererPane currentValuePane;\n+  protected boolean isMinimumSizeDirty;\n+\n+  /**\n+   * Creates a new BasicComboBoxUI object.\n+   */\n+  public BasicComboBoxUI()\n+  {\n+  }\n+\n+  /**\n+   * Factory method to create a BasicComboBoxUI for the given {@link\n+   * JComponent}, which should be a {@link JComboBox}.\n+   *\n+   * @param c The {@link JComponent} a UI is being created for.\n+   *\n+   * @return A BasicComboBoxUI for the {@link JComponent}.\n+   */\n+  public static ComponentUI createUI(JComponent c)\n+  {\n+    return new BasicComboBoxUI();\n+  }\n+\n+  /**\n+   * This method installs the UI for the given JComponent.\n+   *\n+   * @param c The JComponent to install a UI for.\n+   */\n+  public void installUI(JComponent c)\n+  {\n+    super.installUI(c);\n+\n+    if (c instanceof JComboBox)\n+      {\n+\tcomboBox = (JComboBox) c;\n+\tcomboBox.setOpaque(true);\n+\tcomboBox.setLayout(createLayoutManager());\n+\tinstallDefaults();\n+\tinstallComponents();\n+\tinstallListeners();\n+\tinstallKeyboardActions();\n+      }\n+  }\n+\n+  /**\n+   * This method uninstalls the UI.\n+   *\n+   * @param c The JComponent that is having this UI removed.\n+   */\n+  public void uninstallUI(JComponent c)\n+  {\n+    uninstallKeyboardActions();\n+    uninstallListeners();\n+    uninstallComponents();\n+    uninstallDefaults();\n+    comboBox = null;\n+  }\n+\n+  /**\n+   * This method installs the defaults that are defined in  the Basic look and\n+   * feel for this {@link JComboBox}.\n+   */\n+  protected void installDefaults()\n+  {\n+    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n+\n+    comboBox.setBackground(defaults.getColor(\"ComboBox.background\"));\n+    comboBox.setFont(defaults.getFont(\"ComboBox.font\"));\n+    comboBox.setForeground(defaults.getColor(\"ComboBox.foreground\"));\n+\n+    // Set default color that should be used to to render selected item\n+    // of the combo box.\n+    shadow = defaults.getColor(\"Button.shadow\");\n+    darkShadow = defaults.getColor(\"Button.darkShadow\");\n+    lightHighlight = defaults.getColor(\"Button.light\");\n+    highlight = defaults.getColor(\"Button.highlight\");\n+  }\n+\n+  /**\n+   * This method creates and installs the listeners for this UI.\n+   */\n+  protected void installListeners()\n+  {\n+    // install combo box's listeners\n+    propertyChangeListener = createPropertyChangeListener();\n+    comboBox.addPropertyChangeListener(propertyChangeListener);\n+\n+    focusListener = createFocusListener();\n+    comboBox.addFocusListener(focusListener);\n+\n+    itemListener = createItemListener();\n+    comboBox.addItemListener(itemListener);\n+\n+    keyListener = createKeyListener();\n+    comboBox.addKeyListener(keyListener);\n+\n+    mouseListener = createMouseListener();\n+    comboBox.addMouseListener(mouseListener);\n+\n+    // install listeners that listen to combo box model\n+    listDataListener = createListDataListener();\n+    comboBox.getModel().addListDataListener(listDataListener);\n+\n+    configureArrowButton();\n+  }\n+\n+  /**\n+   * This method uninstalls the defaults and sets any objects created during\n+   * install to null\n+   */\n+  protected void uninstallDefaults()\n+  {\n+    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n+\n+    comboBox.setBackground(null);\n+    comboBox.setFont(null);\n+    comboBox.setForeground(null);\n+\n+    shadow = null;\n+    darkShadow = null;\n+    lightHighlight = null;\n+    highlight = null;\n+  }\n+\n+  /**\n+   * Detaches all the listeners we attached in {@link #installListeners}.\n+   */\n+  protected void uninstallListeners()\n+  {\n+    comboBox.removePropertyChangeListener(propertyChangeListener);\n+    propertyChangeListener = null;\n+\n+    comboBox.removeFocusListener(focusListener);\n+    focusListener = null;\n+\n+    comboBox.removeItemListener(itemListener);\n+    itemListener = null;\n+\n+    comboBox.removeKeyListener(keyListener);\n+    keyListener = null;\n+\n+    comboBox.removeMouseListener(mouseListener);\n+    mouseListener = null;\n+\n+    comboBox.getModel().removeListDataListener(listDataListener);\n+    listDataListener = null;\n+\n+    unconfigureArrowButton();\n+  }\n+\n+  /**\n+   * This method creates popup that will contain list of combo box's items\n+   *\n+   * @return popup containing list of combo box's items\n+   */\n+  protected ComboPopup createPopup()\n+  {\n+    return new BasicComboPopup(comboBox);\n+  }\n+\n+  /**\n+   * Creates KeyListener to listen to key events.\n+   *\n+   * @return KeyListener that listens to key events.\n+   */\n+  protected KeyListener createKeyListener()\n+  {\n+    return new KeyHandler();\n+  }\n+\n+  /**\n+   * This method create MouseListener that will listen to mouse event occuring\n+   * in combo box.\n+   *\n+   * @return the MouseListener\n+   */\n+  private MouseListener createMouseListener()\n+  {\n+    return new MouseHandler();\n+  }\n+\n+  /**\n+   * This method create FocusListener that will listen to changes in this\n+   * JComboBox's focus.\n+   *\n+   * @return theFocusListener\n+   */\n+  protected FocusListener createFocusListener()\n+  {\n+    return new FocusHandler();\n+  }\n+\n+  /**\n+   * This method create ListDataListener to listen to ComboBox's  data model\n+   *\n+   * @return ListDataListener\n+   */\n+  protected ListDataListener createListDataListener()\n+  {\n+    return new ListDataHandler();\n+  }\n+\n+  /**\n+   * This method creates ItemListener that will listen to to the changes in\n+   * the JComboBox's selection.\n+   *\n+   * @return the ItemListener\n+   */\n+  protected ItemListener createItemListener()\n+  {\n+    return new ItemHandler();\n+  }\n+\n+  /**\n+   * This method creates PropertyChangeListener to listen to  the changes in\n+   * the JComboBox's bound properties.\n+   *\n+   * @return the PropertyChangeListener\n+   */\n+  protected PropertyChangeListener createPropertyChangeListener()\n+  {\n+    return new PropertyChangeHandler();\n+  }\n+\n+  /**\n+   * This method returns layout manager for the combo box.\n+   *\n+   * @return layout manager for the combo box\n+   */\n+  protected LayoutManager createLayoutManager()\n+  {\n+    return new ComboBoxLayoutManager();\n+  }\n+\n+  /**\n+   * This method creates component that will be responsible for rendering the\n+   * selected component in the combo box.\n+   *\n+   * @return render for the combo box\n+   */\n+  protected ListCellRenderer createRenderer()\n+  {\n+    return new BasicComboBoxRenderer();\n+  }\n+\n+  /**\n+   * Creates component that will be responsible for displaying/editting\n+   * selected item in the combo box. This editor is used only when combo box\n+   * is editable.\n+   *\n+   * @return component that will be responsible for  displaying/editting\n+   *         selected item in the combo box.\n+   */\n+  protected ComboBoxEditor createEditor()\n+  {\n+    return new BasicComboBoxEditor();\n+  }\n+\n+  /**\n+   * This method installs components for this JComboBox. ArrowButton, main\n+   * part of combo box (upper part) and  popup list of items are created and\n+   * configured here.\n+   */\n+  protected void installComponents()\n+  {\n+    // create and install arrow button\n+    arrowButton = createArrowButton();\n+\n+    comboBox.add(arrowButton);\n+\n+    // Set list that will be used by BasicComboBoxRender \n+    // in order to determine the right colors when rendering\n+    listBox = new JList();\n+\n+    Color background = arrowButton.getBackground();\n+    listBox.setBackground(background);\n+    listBox.setSelectionBackground(background.darker());\n+\n+    Color foreground = arrowButton.getForeground();\n+    listBox.setForeground(foreground);\n+    listBox.setSelectionForeground(foreground);\n+\n+    // set editor and renderer for the combo box. Editor is used\n+    // only if combo box becomes editable, otherwise renderer is used\n+    // to paint the selected item; combobox is not editable by default. \n+    comboBox.setRenderer(createRenderer());\n+\n+    comboBox.setEditor(createEditor());\n+    editor = comboBox.getEditor().getEditorComponent();\n+\n+    // create drop down list of items\n+    popup = createPopup();\n+\n+    comboBox.revalidate();\n+  }\n+\n+  /**\n+   * This method uninstalls components from this JComboBox\n+   */\n+  protected void uninstallComponents()\n+  {\n+    // uninstall arrow button\n+    unconfigureArrowButton();\n+    comboBox.remove(arrowButton);\n+    arrowButton = null;\n+\n+    listBox = null;\n+    popup = null;\n+\n+    comboBox.setRenderer(null);\n+\n+    comboBox.setEditor(null);\n+    editor = null;\n+  }\n+\n+  /**\n+   * This method adds editor to the combo box\n+   */\n+  public void addEditor()\n+  {\n+    comboBox.add(editor);\n+  }\n+\n+  /**\n+   * This method removes editor from the combo box\n+   */\n+  public void removeEditor()\n+  {\n+    comboBox.remove(editor);\n+  }\n+\n+  /**\n+   * This method configures editor for this combo box.\n+   */\n+  protected void configureEditor()\n+  {\n+    // FIXME: Need to implement. Set font and add listeners.\n+  }\n+\n+  /**\n+   * This method removes all the listeners for the editor.\n+   */\n+  protected void unconfigureEditor()\n+  {\n+    // FIXME: Need to implement    \n+  }\n+\n+  /**\n+   * This method adds listeners to the arrow button part of the combo box.\n+   */\n+  public void configureArrowButton()\n+  {\n+    arrowButton.addMouseListener(mouseListener);\n+  }\n+\n+  /**\n+   * This method removes listeners from the arrow button part of the combo\n+   * box.\n+   */\n+  public void unconfigureArrowButton()\n+  {\n+    arrowButton.removeMouseListener(mouseListener);\n+  }\n+\n+  /**\n+   * This method create arrow button for this JComboBox. Arrow button is\n+   * responsible for displaying / hiding drop down list of items  when it is\n+   * clicked.\n+   *\n+   * @return JButton arrow button for this JComboBox.\n+   */\n+  protected JButton createArrowButton()\n+  {\n+    return new BasicArrowButton(BasicArrowButton.SOUTH);\n+  }\n+\n+  /**\n+   * This method checks if popup part of the combo box is visible on the\n+   * screen\n+   *\n+   * @param c The JComboBox to check\n+   *\n+   * @return true if popup part of the JComboBox is visible and false\n+   *         otherwise.\n+   */\n+  public boolean isPopupVisible(JComboBox c)\n+  {\n+    return popup.isVisible();\n+  }\n+\n+  /**\n+   * Displays/Hides JComboBox's list of items on the screen.\n+   *\n+   * @param c The combo box, for which list of items should be\n+   *        displayed/hidden\n+   * @param v true if show popup part of the jcomboBox and false to hide.\n+   */\n+  public void setPopupVisible(JComboBox c, boolean v)\n+  {\n+    if (v)\n+      popup.show();\n+    else\n+      popup.hide();\n+  }\n+\n+  /**\n+   * JComboBox is focus traversable if it is editable and not otherwise.\n+   *\n+   * @param c combo box for which to check whether it is focus traversable\n+   *\n+   * @return true if focus tranversable and false otherwise\n+   */\n+  public boolean isFocusTraversable(JComboBox c)\n+  {\n+    if (comboBox.isEditable())\n+      return true;\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Paints given menu item using specified graphics context\n+   *\n+   * @param g The graphics context used to paint this combo box\n+   * @param c comboBox which needs to be painted.\n+   */\n+  public void paint(Graphics g, JComponent c)\n+  {\n+    if (c instanceof JComboBox)\n+      {\n+\tJComboBox cb = (JComboBox) c;\n+\n+\tpaintBorder(g, comboBox.getBounds(), hasFocus);\n+\n+\tRectangle rect = rectangleForCurrentValue();\n+\tpaintCurrentValueBackground(g, rect, hasFocus);\n+\tpaintCurrentValue(g, rect, hasFocus);\n+      }\n+  }\n+\n+  private void paintBorder(Graphics g, Rectangle bounds, boolean hasFocus)\n+  {\n+    int x = 0;\n+    int y = 0;\n+    int width = bounds.width;\n+    int height = bounds.height;\n+\n+    Color oldColor = g.getColor();\n+\n+    if (! arrowButton.getModel().isPressed())\n+      BasicGraphicsUtils.drawEtchedRect(g, x, y, width, height, Color.gray,\n+                                        Color.white, Color.gray, Color.white);\n+    else\n+      {\n+\tg.setColor(darkShadow);\n+\tg.drawRect(x, y, width, height);\n+\tg.setColor(shadow);\n+\tg.drawRect(x + 1, y + 1, width - 3, height - 3);\n+      }\n+    g.setColor(oldColor);\n+  }\n+\n+  /**\n+   * Returns preferred size for the given menu item.\n+   *\n+   * @param c comboBox for which to get preferred size\n+   *\n+   * @return $Dimension$ preferred size for the given combo box\n+   */\n+  public Dimension getPreferredSize(JComponent c)\n+  {\n+    // return null to indicate that combo box's layout will determin its\n+    // preferred size\n+    return null;\n+  }\n+\n+  /**\n+   * This method returns the minimum size for this {@link JComboBox} for this\n+   * look and feel.\n+   *\n+   * @param c The {@link JComponent} to find the minimum size for.\n+   *\n+   * @return The dimensions of the minimum size.\n+   */\n+  public Dimension getMinimumSize(JComponent c)\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * This method returns the maximum size for this {@link JComboBox} for this\n+   * look and feel.\n+   *\n+   * @param c The {@link JComponent} to find the maximum size for\n+   *\n+   * @return The dimensions of the minimum size.\n+   */\n+  public Dimension getMaximumSize(JComponent c)\n+  {\n+    return null;\n+  }\n+\n+  public int getAccessibleChildrenCount(JComponent c)\n+  {\n+    // FIXME: Need to implement\n+    return 0;\n+  }\n+\n+  public Accessible getAccessibleChild(JComponent c, int i)\n+  {\n+    // FIXME: Need to implement\n+    return null;\n+  }\n+\n+  /**\n+   * Returns true if the specified key is a navigation key and false otherwise\n+   *\n+   * @param keyCode a key for which to check whether it is navigation key or\n+   *        not.\n+   *\n+   * @return true if the specified key is a navigation key and false otherwis\n+   */\n+  protected boolean isNavigationKey(int keyCode)\n+  {\n+    return false;\n+  }\n+\n+  /**\n+   * This method selects next possible item relative to the current selection\n+   * to be next selected item in the combo box.\n+   */\n+  protected void selectNextPossibleValue()\n+  {\n+    int index = comboBox.getSelectedIndex();\n+    if (index != comboBox.getItemCount() - 1)\n+      comboBox.setSelectedIndex(index + 1);\n+  }\n+\n+  /**\n+   * This method selects previous item relative to current selection to be\n+   * next selected item.\n+   */\n+  protected void selectPreviousPossibleValue()\n+  {\n+    int index = comboBox.getSelectedIndex();\n+    if (index != 0)\n+      comboBox.setSelectedIndex(index - 1);\n+  }\n+\n+  /**\n+   * This method displays combo box popup if the popup is not currently shown\n+   * on the screen and hides it if it is  currently shown\n+   */\n+  protected void toggleOpenClose()\n+  {\n+    setPopupVisible(comboBox, ! isPopupVisible(comboBox));\n+  }\n+\n+  /**\n+   * This method returns bounds in which comboBox's selected Item will be\n+   * displayed\n+   *\n+   * @return rectangle bounds in which comboBox's selected Item will be\n+   *         displayed\n+   */\n+  protected Rectangle rectangleForCurrentValue()\n+  {\n+    Rectangle cbBounds = comboBox.getBounds();\n+\n+    // Subtract width or the arrow button and border insets\t    \n+    Rectangle rectForCurrentValue = new Rectangle(cbBounds.x\n+                                                  + borderInsets.left,\n+                                                  cbBounds.y\n+                                                  + borderInsets.top,\n+                                                  cbBounds.width\n+                                                  - arrowButtonWidth\n+                                                  - borderInsets.left\n+                                                  - borderInsets.right,\n+                                                  cbBounds.height\n+                                                  - borderInsets.top\n+                                                  - borderInsets.bottom);\n+\n+    return rectForCurrentValue;\n+  }\n+\n+  /**\n+   * This method returns insets of the current border.\n+   *\n+   * @return Insets representing space between combo box and its border\n+   */\n+  protected Insets getInsets()\n+  {\n+    return new Insets(0, 0, 0, 0);\n+  }\n+\n+  /**\n+   * This method paints currently selected value in the main part of the combo\n+   * box (part without popup).\n+   *\n+   * @param g graphics context\n+   * @param bounds Rectangle representing the size of the area in which\n+   *        selected item should be drawn\n+   * @param hasFocus true if combo box has focus and false otherwise\n+   */\n+  public void paintCurrentValue(Graphics g, Rectangle bounds, boolean hasFocus)\n+  {\n+    if (! comboBox.isEditable())\n+      {\n+\tObject currentValue = comboBox.getSelectedItem();\n+\tboolean isPressed = arrowButton.getModel().isPressed();\n+\tif (currentValue != null)\n+\t  {\n+\t    Component comp = comboBox.getRenderer()\n+\t                             .getListCellRendererComponent(listBox,\n+\t                                                           currentValue,\n+\t                                                           -1,\n+\t                                                           isPressed,\n+\t                                                           isPressed);\n+\t    if (! comboBox.isEnabled())\n+\t      comp.setEnabled(false);\n+\n+\t    g.translate(borderInsets.left, borderInsets.top);\n+\t    comp.setBounds(0, 0, bounds.width, bounds.height);\n+\t    comp.paint(g);\n+\t    g.translate(-borderInsets.left, -borderInsets.top);\n+\t  }\n+\tcomboBox.revalidate();\n+      }\n+    else\n+      comboBox.getEditor().setItem(comboBox.getSelectedItem());\n+  }\n+\n+  /**\n+   * This method paints background of part of the combo box, where currently\n+   * selected value is displayed. If the combo box has focus this method\n+   * should also paint focus rectangle around the combo box.\n+   *\n+   * @param g graphics context\n+   * @param bounds Rectangle representing the size of the largest item  in the\n+   *        comboBox\n+   * @param hasFocus true if combo box has fox and false otherwise\n+   */\n+  public void paintCurrentValueBackground(Graphics g, Rectangle bounds,\n+                                          boolean hasFocus)\n+  {\n+    // background is painted by renderer, so it seems that nothing\n+    // should be done here.\n+  }\n+\n+  /**\n+   * Returns default size for the combo box that doesn't contain any elements\n+   * in it\n+   *\n+   * @return Default size of the combo box with no elements in it.\n+   */\n+  protected Dimension getDefaultSize()\n+  {\n+    return new Dimension(6, 17);\n+  }\n+\n+  /**\n+   * Returns size of the largest item in the combo box. This size will be the\n+   * size of the combo box, not including the arrowButton.\n+   *\n+   * @return dimensions of the largest item in the combo box.\n+   */\n+  protected Dimension getLargestItemSize()\n+  {\n+    ComboBoxModel model = comboBox.getModel();\n+    int numItems = model.getSize();\n+\n+    // if combo box doesn't have any items then simply\n+    // return its default size\n+    if (numItems == 0)\n+      {\n+\tlargestItemSize = getDefaultSize();\n+\treturn largestItemSize;\n+      }\n+\n+    Dimension size = new Dimension(0, 0);\n+\n+    // ComboBox's display size should be equal to the \n+    // size of the largest item in the combo box. \n+    ListCellRenderer renderer = comboBox.getRenderer();\n+\n+    for (int i = 0; i < numItems; i++)\n+      {\n+\tObject item = model.getElementAt(i);\n+\tString s = item.toString();\n+\tComponent comp = renderer.getListCellRendererComponent(listBox, item,\n+\t                                                       -1, false, false);\n+\n+\tif (comp.getPreferredSize().getWidth() > size.getWidth())\n+\t  size = comp.getPreferredSize();\n+      }\n+\n+    largestItemSize = size;\n+    return largestItemSize;\n+  }\n+\n+  /**\n+   * This method installs the keyboard actions for the JComboBox as specified\n+   * by the look and feel.\n+   */\n+  protected void installKeyboardActions()\n+  {\n+    // FIXME: Need to implement.\n+  }\n+\n+  /**\n+   * This method uninstalls the keyboard actions for the JComboBox there were\n+   * installed by in {@link #installListeners}.\n+   */\n+  protected void uninstallKeyboardActions()\n+  {\n+    // FIXME: Need to implement.\n+  }\n+\n+  /**\n+   * This class is Layout Manager for this combo box.\n+   */\n+  public class ComboBoxLayoutManager extends Object implements LayoutManager\n+  {\n+    /**\n+     * Creates a new ComboBoxLayoutManager object.\n+     */\n+    public ComboBoxLayoutManager()\n+    {\n+    }\n+\n+    public void addLayoutComponent(String name, Component comp)\n+    {\n+      // Do nothing\n+    }\n+\n+    public void removeLayoutComponent(Component comp)\n+    {\n+      // Do nothing\n+    }\n+\n+    /**\n+     * Returns preferred layout size of the JComboBox.\n+     *\n+     * @param parent Container for which preferred size should be calculated\n+     *\n+     * @return preferred size for the given container\n+     */\n+    public Dimension preferredLayoutSize(Container parent)\n+    {\n+      Dimension d = new Dimension(0, 0);\n+\n+      if (largestItemSize == null)\n+\tlargestItemSize = getLargestItemSize();\n+\n+      // add size for the area that will display selected item\n+      d.width += largestItemSize.getWidth();\n+      d.height += largestItemSize.getHeight();\n+\n+      // add size of the arrow button\n+      d.width += arrowButtonWidth;\n+\n+      // add width and height of the border\n+      d.width += borderInsets.left + borderInsets.right;\n+      d.height += borderInsets.left + borderInsets.right;\n+\n+      // Add combo box's insets \t\n+      Insets insets = parent.getInsets();\n+      d.width += insets.left + insets.right;\n+      d.width += insets.left + insets.right;\n+\n+      return d;\n+    }\n+\n+    public Dimension minimumLayoutSize(Container parent)\n+    {\n+      return preferredLayoutSize(parent);\n+    }\n+\n+    /**\n+     * This method layouts out the components in the container.  It puts arrow\n+     * button right end part of the comboBox. If the comboBox is editable\n+     * then editor is placed to the left of arrow  button, starting from the\n+     * beginning.\n+     *\n+     * @param parent Container that should be layed out.\n+     */\n+    public void layoutContainer(Container parent)\n+    {\n+      // Position editor component to the left of arrow button if combo box is \n+      // editable\n+      int editorWidth = comboBox.getBounds().width - arrowButtonWidth - 2;\n+\n+      if (comboBox.isEditable())\n+\teditor.setBounds(borderInsets.left, borderInsets.top, editorWidth,\n+\t                 comboBox.getBounds().height - borderInsets.left\n+\t                 - borderInsets.top);\n+\n+      arrowButton.setBounds(editorWidth, 2, arrowButtonWidth,\n+                            comboBox.getBounds().height - 4);\n+      comboBox.revalidate();\n+    }\n+  }\n+\n+  /**\n+   * This class handles focus changes occuring in the combo box. This class is\n+   * responsible for repainting combo box whenever focus is gained or lost\n+   * and also for hiding popup list of items whenever combo box loses its\n+   * focus.\n+   */\n+  public class FocusHandler extends Object implements FocusListener\n+  {\n+    /**\n+     * Creates a new FocusHandler object.\n+     */\n+    public FocusHandler()\n+    {\n+    }\n+\n+    /**\n+     * This mehtod is invoked when combo box gains focus. It repaints main\n+     * part of combo box  accordingally.\n+     *\n+     * @param e the FocusEvent\n+     */\n+    public void focusGained(FocusEvent e)\n+    {\n+      hasFocus = true;\n+      comboBox.repaint();\n+    }\n+\n+    /**\n+     * This method is invoked when combo box loses focus It repaint main part\n+     * of combo box accordingally and  hides popup list of items.\n+     *\n+     * @param e the FocusEvent\n+     */\n+    public void focusLost(FocusEvent e)\n+    {\n+      hasFocus = false;\n+      comboBox.repaint();\n+      popup.hide();\n+    }\n+  }\n+\n+  /**\n+   * This class handles ItemEvent fired by the JComboBox when its selected\n+   * item changes.\n+   */\n+  public class ItemHandler extends Object implements ItemListener\n+  {\n+    /**\n+     * Creates a new ItemHandler object.\n+     */\n+    public ItemHandler()\n+    {\n+    }\n+\n+    /**\n+     * This method is invoked when selected item becomes deselected or when\n+     * new item becomes selected.\n+     *\n+     * @param e the ItemEvent representing item's state change.\n+     */\n+    public void itemStateChanged(ItemEvent e)\n+    {\n+      comboBox.repaint();\n+    }\n+  }\n+\n+  /**\n+   * KeyHandler handles key events occuring while JComboBox has focus.\n+   */\n+  public class KeyHandler extends KeyAdapter\n+  {\n+    public KeyHandler()\n+    {\n+    }\n+\n+    /*\n+     * This method is invoked whenever key is pressed while JComboBox is in\n+     * focus.\n+     */\n+    public void keyPressed(KeyEvent e)\n+    {\n+      // FIXME: This method calls JComboBox.selectWithKeyChar if the key that was \n+      // pressed is not a navigation key. \n+    }\n+  }\n+\n+  /**\n+   * This class handles to the changes occuring in the JComboBox's data model\n+   */\n+  public class ListDataHandler extends Object implements ListDataListener\n+  {\n+    /**\n+     * Creates a new ListDataHandler object.\n+     */\n+    public ListDataHandler()\n+    {\n+    }\n+\n+    /**\n+     * This method is invoked content's of JComboBox's data model  are changed\n+     *\n+     * @param e ListDataEvent describing the change.\n+     */\n+    public void contentsChanged(ListDataEvent e)\n+    {\n+      // if the item is selected or deselected\n+    }\n+\n+    /**\n+     * This method is invoked when items were added to the JComboBox's data\n+     * model.\n+     *\n+     * @param e ListDataEvent describing the change.\n+     */\n+    public void intervalAdded(ListDataEvent e)\n+    {\n+      // must determine if the size of the combo box should change\n+      int start = e.getIndex0();\n+      int end = e.getIndex1();\n+\n+      ComboBoxModel model = comboBox.getModel();\n+      ListCellRenderer renderer = comboBox.getRenderer();\n+\n+      if (largestItemSize == null)\n+\tlargestItemSize = new Dimension(0, 0);\n+\n+      for (int i = start - 1; i < end; i++)\n+        {\n+\t  Object item = model.getElementAt(i);\n+\t  Component comp = renderer.getListCellRendererComponent(new JList(),\n+\t                                                         item, -1,\n+\t                                                         false, false);\n+\t  if (comp.getPreferredSize().getWidth() > largestItemSize.getWidth())\n+\t    largestItemSize = comp.getPreferredSize();\n+        }\n+    }\n+\n+    /**\n+     * This method is invoked when items were removed from the JComboBox's\n+     * data model.\n+     *\n+     * @param e ListDataEvent describing the change.\n+     */\n+    public void intervalRemoved(ListDataEvent e)\n+    {\n+      // must determine if the size of the combo box should change\n+      // FIXME: need to implement\n+    }\n+  }\n+\n+  /**\n+   * This class handles PropertyChangeEvents fired by JComboBox.\n+   */\n+  public class PropertyChangeHandler extends Object\n+    implements PropertyChangeListener\n+  {\n+    public PropertyChangeHandler()\n+    {\n+    }\n+\n+    public void propertyChange(PropertyChangeEvent e)\n+    {\n+      if (e.getPropertyName().equals(JComboBox.ENABLED_CHANGED_PROPERTY))\n+        {\n+\t  // disable arrow button\t\n+\t  arrowButton.setEnabled(comboBox.isEnabled());\n+\n+\t  if (comboBox.isEditable())\n+\t    comboBox.getEditor().getEditorComponent().setEnabled(comboBox\n+\t                                                         .isEnabled());\n+        }\n+      else if (e.getPropertyName().equals(JComboBox.EDITABLE_CHANGED_PROPERTY))\n+        {\n+\t  if (comboBox.isEditable())\n+\t    {\n+\t      configureEditor();\n+\t      addEditor();\n+\t    }\n+\t  else\n+\t    {\n+\t      unconfigureEditor();\n+\t      removeEditor();\n+\t    }\n+\n+\t  comboBox.revalidate();\n+\t  comboBox.repaint();\n+        }\n+\n+      // FIXME: Need to handle changes in other bound properties.\t\n+    }\n+  }\n+\n+  /**\n+   * MouseHandler listens to mouse events occuring in the combo box. This\n+   * class is responsible for repainting this JComboBox whenever the mouse is\n+   * being pressed or released over it.\n+   */\n+  private class MouseHandler extends MouseAdapter\n+  {\n+    /**\n+     * This method is invoked when mouse is pressed over the combo box. It\n+     * repaints the combo box accordinglly\n+     *\n+     * @param e the MouseEvent\n+     */\n+    public void mousePressed(MouseEvent e)\n+    {\n+      if (comboBox.isEnabled())\n+        {\n+\t  if (e.getSource() instanceof JComboBox)\n+\t    {\n+\t      arrowButton.getModel().setPressed(true);\n+\t      arrowButton.getModel().setArmed(true);\n+\t    }\n+\n+\t  comboBox.repaint();\n+\n+\t  if (e.getSource() instanceof BasicArrowButton)\n+\t    toggleOpenClose();\n+        }\n+    }\n+\n+    /**\n+     * This method is invoked when mouse is released over the combo box. It\n+     * repaints the combo box accordinglly\n+     *\n+     * @param e the MouseEvent\n+     */\n+    public void mouseReleased(MouseEvent e)\n+    {\n+      if (comboBox.isEnabled())\n+        {\n+\t  if (e.getSource() instanceof JComboBox)\n+\t    {\n+\t      arrowButton.getModel().setPressed(false);\n+\t      arrowButton.getModel().setArmed(false);\n+\t    }\n+\n+\t  comboBox.repaint();\n+        }\n+    }\n+  }\n+}"}, {"sha": "61d2dfbcdad92ec84a116789bb0a761050ebf792", "filename": "libjava/javax/swing/plaf/basic/BasicComboPopup.java", "status": "added", "additions": 933, "deletions": 0, "changes": 933, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicComboPopup.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicComboPopup.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicComboPopup.java?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,933 @@\n+/* BasicComboPopup.java --\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.plaf.basic;\n+\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.Rectangle;\n+import java.awt.event.ItemEvent;\n+import java.awt.event.ItemListener;\n+import java.awt.event.KeyAdapter;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.KeyListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseListener;\n+import java.awt.event.MouseMotionAdapter;\n+import java.awt.event.MouseMotionListener;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import javax.swing.ComboBoxModel;\n+import javax.swing.JComboBox;\n+import javax.swing.JComponent;\n+import javax.swing.JLabel;\n+import javax.swing.JList;\n+import javax.swing.JPopupMenu;\n+import javax.swing.JScrollPane;\n+import javax.swing.ListCellRenderer;\n+import javax.swing.ListSelectionModel;\n+import javax.swing.SwingConstants;\n+import javax.swing.Timer;\n+import javax.swing.event.ListDataEvent;\n+import javax.swing.event.ListDataListener;\n+import javax.swing.event.ListSelectionEvent;\n+import javax.swing.event.ListSelectionListener;\n+import javax.swing.event.PopupMenuEvent;\n+import javax.swing.event.PopupMenuListener;\n+\n+\n+/**\n+ * UI Delegate for ComboPopup\n+ *\n+ * @author Olga Rodimina\n+ */\n+public class BasicComboPopup extends JPopupMenu implements ComboPopup\n+{\n+  protected Timer autoscrollTimer;\n+\n+  /**\n+   * ComboBox associated with this popup\n+   */\n+  protected JComboBox comboBox;\n+\n+  /*\n+   * FIXME: Document fields below\n+   */\n+  protected boolean hasEntered;\n+  protected boolean isAutoScrolling;\n+\n+  /**\n+   * ItemListener listening to the selection changes in the combo box\n+   */\n+  protected ItemListener itemListener;\n+\n+  /**\n+   * This listener is not used\n+   */\n+  protected KeyListener keyListener;\n+\n+  /**\n+   * JList which is used to display item is the combo box\n+   */\n+  protected JList list;\n+\n+  /**\n+   * This listener is not used\n+   */\n+  protected ListDataListener listDataListener;\n+\n+  /**\n+   * MouseListener listening to mouse events occuring in the  combo box's\n+   * list.\n+   */\n+  protected MouseListener listMouseListener;\n+\n+  /**\n+   * MouseMotionListener listening to mouse motion events occuring  in the\n+   * combo box's list\n+   */\n+  protected MouseMotionListener listMouseMotionListener;\n+\n+  /**\n+   * This listener is not used\n+   */\n+  protected ListSelectionListener listSelectionListener;\n+\n+  /**\n+   * MouseListener listening to mouse events occuring in the combo box\n+   */\n+  protected MouseListener mouseListener;\n+\n+  /**\n+   * MouseMotionListener listening to mouse motion events occuring in the\n+   * combo box\n+   */\n+  protected MouseMotionListener mouseMotionListener;\n+\n+  /**\n+   * PropertyChangeListener listening to changes occuring in the bound\n+   * properties of the combo box\n+   */\n+  protected PropertyChangeListener propertyChangeListener;\n+\n+  /*\n+   * FIXME: Document fields below\n+   */\n+  protected static int SCROLL_DOWN = 1;\n+  protected static int SCROLL_UP = 0;\n+  protected int scrollDirection;\n+\n+  /**\n+   * JScrollPane that contains list portion of the combo box\n+   */\n+  protected JScrollPane scroller;\n+\n+  /**\n+   * This field is not used\n+   */\n+  protected boolean valueIsAdjusting;\n+\n+  /**\n+   * Creates a new BasicComboPopup object.\n+   *\n+   * @param comboBox the combo box with which this popup should be associated\n+   */\n+  public BasicComboPopup(JComboBox comboBox)\n+  {\n+    this.comboBox = comboBox;\n+    installComboBoxListeners();\n+\n+    // initialize list that will be used to display elements of the combo box\t\n+    this.list = createList();\n+    ((JLabel) list.getCellRenderer()).setHorizontalAlignment(SwingConstants.LEFT);\n+    configureList();\n+\n+    // initialize scroller. Add list to the scroller.\t\n+    scroller = createScroller();\n+    configureScroller();\n+\n+    // add scroller with list inside of it to JPopupMenu\n+    super.add(scroller);\n+\n+    setLightWeightPopupEnabled(comboBox.isLightWeightPopupEnabled());\n+  }\n+\n+  /**\n+   * This method displays drow down list of combo box items on the screen.\n+   */\n+  public void show()\n+  {\n+    Rectangle cbBounds = comboBox.getBounds();\n+\n+    // popup should have same width as the comboBox and should be hight anough\n+    // to display number of rows equal to 'maximumRowCount' property\n+    int popupHeight = getPopupHeightForRowCount(comboBox.getMaximumRowCount())\n+                      + 4;\n+\n+    super.setPopupSize(cbBounds.width, popupHeight);\n+\n+    // location specified is relative to comboBox\n+    super.show(comboBox, 0, cbBounds.height);\n+  }\n+\n+  /**\n+   * This method hides drop down list of items\n+   */\n+  public void hide()\n+  {\n+    super.setVisible(false);\n+  }\n+\n+  /**\n+   * Return list cointaining JComboBox's items\n+   *\n+   * @return list cointaining JComboBox's items\n+   */\n+  public JList getList()\n+  {\n+    return list;\n+  }\n+\n+  /**\n+   * Returns MouseListener that is listening to mouse events occuring in the\n+   * combo box.\n+   *\n+   * @return MouseListener\n+   */\n+  public MouseListener getMouseListener()\n+  {\n+    return mouseListener;\n+  }\n+\n+  /**\n+   * Returns MouseMotionListener that is listening to mouse  motion events\n+   * occuring in the combo box.\n+   *\n+   * @return MouseMotionListener\n+   */\n+  public MouseMotionListener getMouseMotionListener()\n+  {\n+    return mouseMotionListener;\n+  }\n+\n+  /**\n+   * Returns KeyListener listening to key events occuring in the combo box.\n+   * This method returns null because KeyHandler is not longer used.\n+   *\n+   * @return KeyListener\n+   */\n+  public KeyListener getKeyListener()\n+  {\n+    return keyListener;\n+  }\n+\n+  /**\n+   * This method uninstalls the UI for the  given JComponent.\n+   */\n+  public void uninstallingUI()\n+  {\n+    uninstallComboBoxModelListeners(comboBox.getModel());\n+\n+    uninstallListeners();\n+    uninstallKeyboardActions();\n+  }\n+\n+  /**\n+   * This method uninstalls listeners that were listening to changes occuring\n+   * in the comb box's data model\n+   *\n+   * @param model data model for the combo box from which to uninstall\n+   *        listeners\n+   */\n+  protected void uninstallComboBoxModelListeners(ComboBoxModel model)\n+  {\n+    model.removeListDataListener(listDataListener);\n+  }\n+\n+  /**\n+   * This method uninstalls keyboard actions installed by the UI.\n+   */\n+  protected void uninstallKeyboardActions()\n+  {\n+    // FIXME: Need to implement\n+  }\n+\n+  /**\n+   * This method fires PopupMenuEvent indicating that combo box's popup list\n+   * of items will become visible\n+   */\n+  protected void firePopupMenuWillBecomeVisible()\n+  {\n+    // FIXME: Need to implement\n+  }\n+\n+  /**\n+   * This method fires PopupMenuEvent indicating that combo box's popup list\n+   * of items will become invisible.\n+   */\n+  protected void firePopupMenuWillBecomeInvisible()\n+  {\n+    // FIXME: Need to implement\n+  }\n+\n+  /**\n+   * This method fires PopupMenuEvent indicating that combo box's popup list\n+   * of items was closed without selection.\n+   */\n+  protected void firePopupMenuCanceled()\n+  {\n+    // FIXME: Need to implement\n+  }\n+\n+  /**\n+   * Creates MouseListener to listen to mouse events occuring in the combo\n+   * box. Note that this listener doesn't listen to mouse events occuring in\n+   * the popup portion of the combo box, it only listens to main combo box\n+   * part.\n+   *\n+   * @return new MouseMotionListener that listens to mouse events occuring in\n+   *         the combo box\n+   */\n+  protected MouseListener createMouseListener()\n+  {\n+    return new InvocationMouseHandler();\n+  }\n+\n+  /**\n+   * Create Mouse listener that listens to mouse dragging events occuring in\n+   * the combo box. This listener is responsible for changing the selection\n+   * in the combo box list to the component over which mouse is being\n+   * currently dragged\n+   *\n+   * @return new MouseMotionListener that listens to mouse dragging events\n+   *         occuring in the combo box\n+   */\n+  protected MouseMotionListener createMouseMotionListener()\n+  {\n+    return new InvocationMouseMotionHandler();\n+  }\n+\n+  /**\n+   * KeyListener created in this method is not used anymore.\n+   *\n+   * @return KeyListener that does nothing\n+   */\n+  protected KeyListener createKeyListener()\n+  {\n+    return new InvocationKeyHandler();\n+  }\n+\n+  /**\n+   * ListSelectionListener created in this method is not used anymore\n+   *\n+   * @return ListSelectionListener that does nothing\n+   */\n+  protected ListSelectionListener createListSelectionListener()\n+  {\n+    return new ListSelectionHandler();\n+  }\n+\n+  /**\n+   * Creates ListDataListener. This method returns null, because\n+   * ListDataHandler class is obsolete and is no longer used.\n+   *\n+   * @return null\n+   */\n+  protected ListDataListener createListDataListener()\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * This method creates ListMouseListener to listen to mouse events occuring\n+   * in the combo box's item list.\n+   *\n+   * @return MouseListener to listen to mouse events occuring in the combo\n+   *         box's items list.\n+   */\n+  protected MouseListener createListMouseListener()\n+  {\n+    return new ListMouseHandler();\n+  }\n+\n+  /**\n+   * Creates ListMouseMotionlistener to listen to mouse motion events occuring\n+   * in the combo box's list. This listener is responsible for highlighting\n+   * items in the list when mouse is moved over them.\n+   *\n+   * @return MouseMotionListener that handles mouse motion events occuring in\n+   *         the list of the combo box.\n+   */\n+  protected MouseMotionListener createListMouseMotionListener()\n+  {\n+    return new ListMouseMotionHandler();\n+  }\n+\n+  /**\n+   * Creates PropertyChangeListener to handle changes in the JComboBox's bound\n+   * properties.\n+   *\n+   * @return PropertyChangeListener to handle changes in the JComboBox's bound\n+   *         properties.\n+   */\n+  protected PropertyChangeListener createPropertyChangeListener()\n+  {\n+    return new PropertyChangeHandler();\n+  }\n+\n+  /**\n+   * Creates new ItemListener that will listen to ItemEvents occuring in the\n+   * combo box.\n+   *\n+   * @return ItemListener to listen to ItemEvents occuring in the combo box.\n+   */\n+  protected ItemListener createItemListener()\n+  {\n+    return new ItemHandler();\n+  }\n+\n+  /**\n+   * Creates JList that will be used to display items in the combo box.\n+   *\n+   * @return JList that will be used to display items in the combo box.\n+   */\n+  protected JList createList()\n+  {\n+    JList l = new JList(comboBox.getModel());\n+    l.setSelectionMode(ListSelectionModel.SINGLE_INTERVAL_SELECTION);\n+    return l;\n+  }\n+\n+  /**\n+   * This method configures the list of comboBox's items by setting  default\n+   * properties and installing listeners.\n+   */\n+  protected void configureList()\n+  {\n+    list.setModel(comboBox.getModel());\n+\n+    if (comboBox.getItemCount() < comboBox.getMaximumRowCount())\n+      list.setVisibleRowCount(comboBox.getItemCount());\n+    else\n+      list.setVisibleRowCount(comboBox.getMaximumRowCount());\n+    installListListeners();\n+  }\n+\n+  /**\n+   * This method installs list listeners.\n+   */\n+  protected void installListListeners()\n+  {\n+    // mouse listener listening to mouse events occuring in the \n+    // combo box's list of items.\n+    listMouseListener = createListMouseListener();\n+    list.addMouseListener(listMouseListener);\n+\n+    // mouse listener listening to mouse motion events occuring in the\n+    // combo box's list of items\n+    listMouseMotionListener = createListMouseMotionListener();\n+    list.addMouseMotionListener(listMouseMotionListener);\n+\n+    listSelectionListener = createListSelectionListener();\n+    list.addListSelectionListener(listSelectionListener);\n+  }\n+\n+  /**\n+   * This method creates scroll pane that will contain the list of comboBox's\n+   * items inside of it.\n+   *\n+   * @return JScrollPane\n+   */\n+  protected JScrollPane createScroller()\n+  {\n+    return new JScrollPane();\n+  }\n+\n+  /**\n+   * This method configures scroll pane to contain list of comboBox's  items\n+   */\n+  protected void configureScroller()\n+  {\n+    scroller.getViewport().setView(list);\n+    scroller.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n+  }\n+\n+  /**\n+   * This method configures popup menu that will be used to display Scrollpane\n+   * with list of items inside of it.\n+   */\n+  protected void configurePopup()\n+  {\n+    // FIXME: Need to implement\n+  }\n+\n+  /*\n+   * This method installs listeners that will listen to changes occuring\n+   * in the combo box.\n+   */\n+  protected void installComboBoxListeners()\n+  {\n+    // mouse listener that listens to mouse event in combo box\n+    mouseListener = createMouseListener();\n+    comboBox.addMouseListener(mouseListener);\n+\n+    // mouse listener that listens to mouse dragging events in the combo box\n+    mouseMotionListener = createMouseMotionListener();\n+    comboBox.addMouseMotionListener(mouseMotionListener);\n+\n+    // item listener listenening to selection events in the combo box\n+    itemListener = createItemListener();\n+    comboBox.addItemListener(itemListener);\n+\n+    propertyChangeListener = createPropertyChangeListener();\n+    comboBox.addPropertyChangeListener(propertyChangeListener);\n+  }\n+\n+  /**\n+   * This method installs listeners that will listen to changes occuring in\n+   * the comb box's data model\n+   *\n+   * @param model data model for the combo box for which to install listeners\n+   */\n+  protected void installComboBoxModelListeners(ComboBoxModel model)\n+  {\n+    // list data listener to listen for ListDataEvents in combo box.\n+    // This listener is now obsolete and nothing is done here\n+    listDataListener = createListDataListener();\n+    comboBox.getModel().addListDataListener(listDataListener);\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  protected void installKeyboardActions()\n+  {\n+    // FIXME: Need to implement\n+  }\n+\n+  /**\n+   * This method always returns false to indicate that  items in the combo box\n+   * list are not focus traversable.\n+   *\n+   * @return false\n+   */\n+  public boolean isFocusTraversable()\n+  {\n+    return false;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param direction DOCUMENT ME!\n+   */\n+  protected void startAutoScrolling(int direction)\n+  {\n+    // FIXME: Need to implement\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  protected void stopAutoScrolling()\n+  {\n+    // FIXME: Need to implement\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  protected void autoScrollUp()\n+  {\n+    // FIXME: Need to implement\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  protected void autoScrollDown()\n+  {\n+    // FIXME: Need to implement\n+  }\n+\n+  /**\n+   * This method helps to delegate focus to the right component in the\n+   * JComboBox. If the comboBox is editable then focus is sent to\n+   * ComboBoxEditor, otherwise it is delegated to JComboBox.\n+   *\n+   * @param e MouseEvent\n+   */\n+  protected void delegateFocus(MouseEvent e)\n+  {\n+    // FIXME: Need to implement\n+  }\n+\n+  /**\n+   * This method displays combo box popup if the popup is  not currently shown\n+   * on the screen and hides it if it is  currently visible\n+   */\n+  protected void togglePopup()\n+  {\n+    if (BasicComboPopup.this.isVisible())\n+      hide();\n+    else\n+      show();\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param e DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  protected MouseEvent convertMouseEvent(MouseEvent e)\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * Returns required height of the popup such that number of items visible in\n+   * it are equal to the maximum row count.  By default\n+   * comboBox.maximumRowCount=8\n+   *\n+   * @param maxRowCount number of maximum visible rows in the  combo box's\n+   *        popup list of items\n+   *\n+   * @return height of the popup required to fit number of items  equal to\n+   *         JComboBox.maximumRowCount.\n+   */\n+  protected int getPopupHeightForRowCount(int maxRowCount)\n+  {\n+    int totalHeight = 0;\n+    ListCellRenderer rend = list.getCellRenderer();\n+\n+    if (comboBox.getItemCount() < maxRowCount)\n+      maxRowCount = comboBox.getItemCount();\n+\n+    for (int i = 0; i < maxRowCount; i++)\n+      {\n+\tComponent comp = rend.getListCellRendererComponent(list,\n+\t                                                   list.getModel()\n+\t                                                       .getElementAt(i),\n+\t                                                   -1, false, false);\n+\tDimension dim = comp.getPreferredSize();\n+\ttotalHeight += dim.height;\n+      }\n+\n+    return totalHeight;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @param px DOCUMENT ME!\n+   * @param py DOCUMENT ME!\n+   * @param pw DOCUMENT ME!\n+   * @param ph DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  protected Rectangle computePopupBounds(int px, int py, int pw, int ph)\n+  {\n+    return new Rectangle(px, py, pw, ph);\n+  }\n+\n+  /**\n+   * This method changes the selection in the list to the item over which  the\n+   * mouse is currently located.\n+   *\n+   * @param anEvent MouseEvent\n+   * @param shouldScroll DOCUMENT ME!\n+   */\n+  protected void updateListBoxSelectionForEvent(MouseEvent anEvent,\n+                                                boolean shouldScroll)\n+  {\n+    // FIXME: Need to implement\n+  }\n+\n+  /**\n+   * InvocationMouseHandler is a listener that listens to mouse events\n+   * occuring in the combo box. Note that this listener doesn't listen to\n+   * mouse events occuring in the popup portion of the combo box, it only\n+   * listens to main combo box part(area that displays selected item).  This\n+   * listener is responsible for showing and hiding popup portion  of the\n+   * combo box.\n+   */\n+  protected class InvocationMouseHandler extends MouseAdapter\n+  {\n+    /**\n+     * Creates a new InvocationMouseHandler object.\n+     */\n+    protected InvocationMouseHandler()\n+    {\n+    }\n+\n+    /**\n+     * This method is invoked whenever mouse is being pressed over the main\n+     * part of the combo box. This method will show popup if  the popup is\n+     * not shown on the screen right now, and it will hide popup otherwise.\n+     *\n+     * @param e MouseEvent that should be handled\n+     */\n+    public void mousePressed(MouseEvent e)\n+    {\n+      if (comboBox.isEnabled())\n+\ttogglePopup();\n+    }\n+\n+    /**\n+     * This method is invoked whenever mouse is released\n+     *\n+     * @param e MouseEvent that should be handled\n+     */\n+    public void mouseReleased(MouseEvent e)\n+    {\n+      // FIXME: should handle dragging events here, if\n+      // mouse was dragged and released over the list of combobox's items,\n+      // then item over which it was released should be selected.\n+    }\n+  }\n+\n+  /**\n+   * InvocationMouseMotionListener is a mouse listener that listens to mouse\n+   * dragging events occuring in the combo box.\n+   */\n+  protected class InvocationMouseMotionHandler extends MouseMotionAdapter\n+  {\n+    /**\n+     * Creates a new InvocationMouseMotionHandler object.\n+     */\n+    protected InvocationMouseMotionHandler()\n+    {\n+    }\n+\n+    public void mouseDragged(MouseEvent e)\n+    {\n+    }\n+  }\n+\n+  /**\n+   * ItemHandler is an item listener that listens to selection event occuring\n+   * in the combo box. FIXME: should specify here what it does when item is\n+   * selected or deselected in the combo box list.\n+   */\n+  protected class ItemHandler extends Object implements ItemListener\n+  {\n+    /**\n+     * Creates a new ItemHandler object.\n+     */\n+    protected ItemHandler()\n+    {\n+    }\n+\n+    /**\n+     * This method responds to the selection events occuring in the combo box.\n+     *\n+     * @param e ItemEvent specifying the combo box's selection\n+     */\n+    public void itemStateChanged(ItemEvent e)\n+    {\n+    }\n+  }\n+\n+  /**\n+   * ListMouseHandler is a listener that listens to mouse events occuring in\n+   * the combo box's list of items. This class is responsible for hiding\n+   * popup portion of the combo box if the mouse is released inside the combo\n+   * box's list.\n+   */\n+  protected class ListMouseHandler extends MouseAdapter\n+  {\n+    protected ListMouseHandler()\n+    {\n+    }\n+\n+    public void mousePressed(MouseEvent e)\n+    {\n+    }\n+\n+    public void mouseReleased(MouseEvent anEvent)\n+    {\n+      int index = list.locationToIndex(anEvent.getPoint());\n+      comboBox.setSelectedIndex(index);\n+      hide();\n+    }\n+  }\n+\n+  /**\n+   * ListMouseMotionHandler listens to mouse motion events occuring in the\n+   * combo box's list. This class is responsible for highlighting items in\n+   * the list when mouse is moved over them\n+   */\n+  protected class ListMouseMotionHandler extends MouseMotionAdapter\n+  {\n+    protected ListMouseMotionHandler()\n+    {\n+    }\n+\n+    public void mouseMoved(MouseEvent anEvent)\n+    {\n+      // FIXME: Need to implement\n+      // NOTE: the change isn't reflected in data model of the combo box.\n+      // The items are only highlited, but not selected\n+    }\n+  }\n+\n+  /**\n+   * This class listens to changes occuring in the bound properties of the\n+   * combo box\n+   */\n+  protected class PropertyChangeHandler extends Object\n+    implements PropertyChangeListener\n+  {\n+    protected PropertyChangeHandler()\n+    {\n+    }\n+\n+    public void propertyChange(PropertyChangeEvent e)\n+    {\n+      if (e.getPropertyName().equals(JComboBox.RENDERER_CHANGED_PROPERTY))\n+        {\n+\t  list.setCellRenderer((ListCellRenderer) e.getNewValue());\n+\t  revalidate();\n+\t  repaint();\n+        }\n+    }\n+  }\n+\n+  // ------ private helper methods --------------------\n+\n+  /**\n+   * This method uninstalls listeners installed by the UI\n+   */\n+  private void uninstallListeners()\n+  {\n+    uninstallListListeners();\n+    uninstallComboBoxListeners();\n+    uninstallComboBoxModelListeners(comboBox.getModel());\n+  }\n+\n+  /**\n+   * This method uninstalls Listeners registered with combo boxes list of\n+   * items\n+   */\n+  private void uninstallListListeners()\n+  {\n+    list.removeMouseListener(listMouseListener);\n+    listMouseListener = null;\n+\n+    list.removeMouseMotionListener(listMouseMotionListener);\n+    listMouseMotionListener = null;\n+  }\n+\n+  /**\n+   * This method uninstalls listeners listening to combo box  associated with\n+   * this popup menu\n+   */\n+  private void uninstallComboBoxListeners()\n+  {\n+    comboBox.removeMouseListener(mouseListener);\n+    mouseListener = null;\n+\n+    comboBox.removeMouseMotionListener(mouseMotionListener);\n+    mouseMotionListener = null;\n+\n+    comboBox.removeItemListener(itemListener);\n+    itemListener = null;\n+\n+    comboBox.removePropertyChangeListener(propertyChangeListener);\n+    propertyChangeListener = null;\n+  }\n+\n+  // --------------------------------------------------------------------\n+  //  The following classes are here only for backwards API compatibility\n+  //  They aren't used.\n+  // --------------------------------------------------------------------\n+\n+  /**\n+   * This class is not used any more.\n+   */\n+  public class ListDataHandler extends Object implements ListDataListener\n+  {\n+    public ListDataHandler()\n+    {\n+    }\n+\n+    public void contentsChanged(ListDataEvent e)\n+    {\n+    }\n+\n+    public void intervalAdded(ListDataEvent e)\n+    {\n+    }\n+\n+    public void intervalRemoved(ListDataEvent e)\n+    {\n+    }\n+  }\n+\n+  /**\n+   * This class is not used anymore\n+   */\n+  protected class ListSelectionHandler extends Object\n+    implements ListSelectionListener\n+  {\n+    protected ListSelectionHandler()\n+    {\n+    }\n+\n+    public void valueChanged(ListSelectionEvent e)\n+    {\n+    }\n+  }\n+\n+  /**\n+   * This class is not used anymore\n+   */\n+  public class InvocationKeyHandler extends KeyAdapter\n+  {\n+    public InvocationKeyHandler()\n+    {\n+    }\n+\n+    public void keyReleased(KeyEvent e)\n+    {\n+    }\n+  }\n+}"}, {"sha": "c61dc40a5d24acafbb6e6df01a7b8cf15669ba3f", "filename": "libjava/javax/swing/plaf/basic/BasicFormattedTextFieldUI.java", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicFormattedTextFieldUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicFormattedTextFieldUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicFormattedTextFieldUI.java?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,62 @@\n+/* BasicFormattedTextFieldUI.java\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.swing.plaf.basic;\n+\n+import javax.swing.JComponent;\n+import javax.swing.plaf.ComponentUI;\n+\n+/**\n+ * @since 1.4\n+ */\n+public class BasicFormattedTextFieldUI extends BasicTextFieldUI\n+{\n+  public BasicFormattedTextFieldUI()\n+  {\n+  }\n+\n+  public static ComponentUI createUI(JComponent c)\n+  {\n+    return new BasicFormattedTextFieldUI();\n+  }\n+\n+  protected String getPropertyPrefix()\n+  {\n+    return \"FormattedTextField\";\n+  }\n+}\n\\ No newline at end of file"}, {"sha": "fe1c4902ac6776841e9f34dbba69e0fe2cb11c9c", "filename": "libjava/javax/swing/plaf/basic/BasicPasswordFieldUI.java", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicPasswordFieldUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicPasswordFieldUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicPasswordFieldUI.java?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,61 @@\n+/* BasicPasswordFieldUI.java\n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.swing.plaf.basic;\n+\n+import javax.swing.JComponent;\n+import javax.swing.plaf.ComponentUI;\n+import javax.swing.text.Element;\n+import javax.swing.text.View;\n+\n+public class BasicPasswordFieldUI extends BasicTextFieldUI\n+{\n+  public BasicPasswordFieldUI()\n+  {\n+  }\n+\n+  public static ComponentUI createUI(JComponent c)\n+  {\n+    return new BasicPasswordFieldUI();\n+  }\n+\n+  protected String getPropertyPrefix()\n+  {\n+    return \"PasswordField\";\n+  }\n+}"}, {"sha": "0f5e761d3d70bb21938d87c90159f1dbd7c4f890", "filename": "libjava/javax/swing/plaf/basic/BasicSpinnerUI.java", "status": "added", "additions": 572, "deletions": 0, "changes": 572, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSpinnerUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSpinnerUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSpinnerUI.java?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,572 @@\n+/* SpinnerUI.java --\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.plaf.basic;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import javax.swing.JButton;\n+import javax.swing.JComponent;\n+import javax.swing.JSpinner;\n+import javax.swing.Timer;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n+import javax.swing.plaf.ComponentUI;\n+import javax.swing.plaf.SpinnerUI;\n+\n+\n+/**\n+ * DOCUMENT ME!\n+ *\n+ * @author Ka-Hing Cheung\n+ *\n+ * @see javax.swing.JSpinner\n+ * @since 1.4\n+ */\n+public class BasicSpinnerUI extends SpinnerUI\n+{\n+  /**\n+   * Creates a new <code>ComponentUI</code> for the specified\n+   * <code>JComponent</code>\n+   *\n+   * @param c DOCUMENT ME!\n+   *\n+   * @return a ComponentUI\n+   */\n+  public static ComponentUI createUI(JComponent c)\n+  {\n+    return new BasicSpinnerUI();\n+  }\n+\n+  /**\n+   * Creates an editor component. Really, it just returns\n+   * <code>JSpinner.getEditor()</code>\n+   *\n+   * @return a JComponent as an editor\n+   *\n+   * @see javax.swing.JSpinner#getEditor\n+   */\n+  protected JComponent createEditor()\n+  {\n+    return spinner.getEditor();\n+  }\n+\n+  /**\n+   * Creates a <code>LayoutManager</code> that layouts the sub components. The\n+   * subcomponents are identifies by the constraint \"Next\", \"Previous\" and\n+   * \"Editor\"\n+   *\n+   * @return a LayoutManager\n+   *\n+   * @see java.awt.LayoutManager\n+   */\n+  protected LayoutManager createLayout()\n+  {\n+    return new DefaultLayoutManager();\n+  }\n+\n+  /**\n+   * Creates the \"Next\" button\n+   *\n+   * @return the next button component\n+   */\n+  protected Component createNextButton()\n+  {\n+    JButton button = new BasicArrowButton(BasicArrowButton.NORTH);\n+    return button;\n+  }\n+\n+  /**\n+   * Creates the \"Previous\" button\n+   *\n+   * @return the previous button component\n+   */\n+  protected Component createPreviousButton()\n+  {\n+    JButton button = new BasicArrowButton(BasicArrowButton.SOUTH);\n+    return button;\n+  }\n+\n+  /**\n+   * Creates the <code>PropertyChangeListener</code> that will be attached by\n+   * <code>installListeners</code>. It should watch for the \"editor\"\n+   * property, when it's changed, replace the old editor with the new one,\n+   * probably by calling <code>replaceEditor</code>\n+   *\n+   * @return a PropertyChangeListener\n+   *\n+   * @see #replaceEditor\n+   */\n+  protected PropertyChangeListener createPropertyChangeListener()\n+  {\n+    return new PropertyChangeListener()\n+      {\n+\tpublic void propertyChange(PropertyChangeEvent evt)\n+\t{\n+\t  // FIXME: Add check for enabled property change. Need to\n+\t  // disable the buttons.\n+\t  if (\"editor\".equals(evt.getPropertyName()))\n+\t    BasicSpinnerUI.this.replaceEditor((JComponent) evt.getOldValue(),\n+\t                                      (JComponent) evt.getNewValue());\n+\t}\n+      };\n+  }\n+\n+  /**\n+   * Called by <code>installUI</code>. This should set various defaults\n+   * obtained from <code>UIManager.getLookAndFeelDefaults</code>, as well as\n+   * set the layout obtained from <code>createLayout</code>\n+   *\n+   * @see #javax.swing.UIManager#getLookAndFeelDefaults\n+   * @see #createLayout\n+   * @see #installUI\n+   */\n+  protected void installDefaults()\n+  {\n+    /* most of it copied from BasicLabelUI, I don't know what keys are\n+       available, so someone may want to update this. Hence: TODO\n+    */\n+    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n+    /*\n+    spinner.setForeground(defaults.getColor(\"Spinner.foreground\"));\n+    spinner.setBackground(defaults.getColor(\"Spinner.background\"));\n+    spinner.setFont(defaults.getFont(\"Spinner.font\"));\n+    spinner.setBorder(defaults.getBorder(\"Spinner.border\"));\n+    */\n+    spinner.setLayout(createLayout());\n+  }\n+\n+  /*\n+   * Called by <code>installUI</code>, which basically adds the\n+   * <code>PropertyChangeListener</code> created by\n+   * <code>createPropertyChangeListener</code>\n+   *\n+   * @see #createPropertyChangeListener\n+   * @see #installUI\n+   */\n+  protected void installListeners()\n+  {\n+    spinner.addPropertyChangeListener(listener);\n+  }\n+\n+  /*\n+   * Install listeners to the next button so that it increments the model\n+   */\n+  protected void installNextButtonListeners(Component c)\n+  {\n+    c.addMouseListener(new MouseAdapter()\n+        {\n+\t  public void mousePressed(MouseEvent evt)\n+\t  {\n+\t    if (! spinner.isEnabled())\n+\t      return;\n+\t    increment();\n+\t    timer.setInitialDelay(500);\n+\t    timer.start();\n+\t  }\n+\n+\t  public void mouseReleased(MouseEvent evt)\n+\t  {\n+\t    timer.stop();\n+\t  }\n+\n+\t  void increment()\n+\t  {\n+\t    Object next = BasicSpinnerUI.this.spinner.getNextValue();\n+\t    if (next != null)\n+\t      BasicSpinnerUI.this.spinner.getModel().setValue(next);\n+\t  }\n+\n+\t  volatile boolean mouseDown = false;\n+\t  Timer timer = new Timer(50,\n+\t                          new ActionListener()\n+\t      {\n+\t\tpublic void actionPerformed(ActionEvent event)\n+\t\t{\n+\t\t  increment();\n+\t\t}\n+\t      });\n+        });\n+  }\n+\n+  /*\n+   * Install listeners to the previous button so that it decrements the model\n+   */\n+  protected void installPreviousButtonListeners(Component c)\n+  {\n+    c.addMouseListener(new MouseAdapter()\n+        {\n+\t  public void mousePressed(MouseEvent evt)\n+\t  {\n+\t    if (! spinner.isEnabled())\n+\t      return;\n+\t    decrement();\n+\t    timer.setInitialDelay(500);\n+\t    timer.start();\n+\t  }\n+\n+\t  public void mouseReleased(MouseEvent evt)\n+\t  {\n+\t    timer.stop();\n+\t  }\n+\n+\t  void decrement()\n+\t  {\n+\t    Object prev = BasicSpinnerUI.this.spinner.getPreviousValue();\n+\t    if (prev != null)\n+\t      BasicSpinnerUI.this.spinner.getModel().setValue(prev);\n+\t  }\n+\n+\t  volatile boolean mouseDown = false;\n+\t  Timer timer = new Timer(50,\n+\t                          new ActionListener()\n+\t      {\n+\t\tpublic void actionPerformed(ActionEvent event)\n+\t\t{\n+\t\t  decrement();\n+\t\t}\n+\t      });\n+        });\n+  }\n+\n+  /**\n+   * Install this UI to the <code>JComponent</code>, which in reality, is a\n+   * <code>JSpinner</code>. Calls <code>installDefaults</code>,\n+   * <code>installListeners</code>, and also adds the buttons and editor.\n+   *\n+   * @param c DOCUMENT ME!\n+   *\n+   * @see #installDefaults\n+   * @see #installListeners\n+   * @see #createNextButton\n+   * @see #createPreviousButton\n+   * @see #createEditor\n+   */\n+  public void installUI(JComponent c)\n+  {\n+    super.installUI(c);\n+\n+    spinner = (JSpinner) c;\n+\n+    installDefaults();\n+    installListeners();\n+\n+    Component next = createNextButton();\n+    Component previous = createPreviousButton();\n+\n+    installNextButtonListeners(next);\n+    installPreviousButtonListeners(previous);\n+\n+    c.add(createEditor(), \"Editor\");\n+    c.add(next, \"Next\");\n+    c.add(previous, \"Previous\");\n+  }\n+\n+  /**\n+   * Replace the old editor with the new one\n+   *\n+   * @param oldEditor the old editor\n+   * @param newEditor the new one to replace with\n+   */\n+  protected void replaceEditor(JComponent oldEditor, JComponent newEditor)\n+  {\n+    spinner.remove(oldEditor);\n+    spinner.add(newEditor);\n+  }\n+\n+  /**\n+   * The reverse of <code>installDefaults</code>. Called by\n+   * <code>uninstallUI</code>\n+   */\n+  protected void uninstallDefaults()\n+  {\n+    spinner.setLayout(null);\n+  }\n+\n+  /**\n+   * The reverse of <code>installListeners</code>, called by\n+   * <code>uninstallUI</code>\n+   */\n+  protected void uninstallListeners()\n+  {\n+    spinner.removePropertyChangeListener(listener);\n+  }\n+\n+  /**\n+   * Called when the current L&F is replaced with another one, should call\n+   * <code>uninstallDefaults</code> and <code>uninstallListeners</code> as\n+   * well as remove the next/previous buttons and the editor\n+   *\n+   * @param c DOCUMENT ME!\n+   */\n+  public void uninstallUI(JComponent c)\n+  {\n+    super.uninstallUI(c);\n+\n+    uninstallDefaults();\n+    uninstallListeners();\n+    c.removeAll();\n+  }\n+\n+  /** The spinner for this UI */\n+  protected JSpinner spinner;\n+\n+  /** DOCUMENT ME! */\n+  private PropertyChangeListener listener = createPropertyChangeListener();\n+\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  private class DefaultLayoutManager implements LayoutManager\n+  {\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param parent DOCUMENT ME!\n+     */\n+    public void layoutContainer(Container parent)\n+    {\n+      synchronized (parent.getTreeLock())\n+        {\n+\t  Insets i = parent.getInsets();\n+\t  boolean l2r = parent.getComponentOrientation().isLeftToRight();\n+\t  /*\n+\t    --------------    --------------\n+\t    |        | n |    | n |        |\n+\t    |   e    | - | or | - |   e    |\n+\t    |        | p |    | p |        |\n+\t    --------------    --------------\n+\t  */\n+\t  Dimension e = minSize(editor);\n+\t  Dimension n = minSize(next);\n+\t  Dimension p = minSize(previous);\n+\t  Dimension s = spinner.getPreferredSize();\n+\n+\t  int x = l2r ? i.left : i.right;\n+\t  int y = i.top;\n+\t  int w = Math.max(p.width, n.width);\n+\t  int h = Math.max(p.height, n.height);\n+\t  h = Math.max(h, e.height / 2);\n+\t  int e_width = s.width - w;\n+\n+\t  if (l2r)\n+\t    {\n+\t      setBounds(editor, x, y + (s.height - e.height) / 2, e_width,\n+\t                e.height);\n+\t      x += e_width;\n+\n+\t      setBounds(next, x, y, w, h);\n+\t      y += h;\n+\n+\t      setBounds(previous, x, y, w, h);\n+\t    }\n+\t  else\n+\t    {\n+\t      setBounds(next, x, y + (s.height - e.height) / 2, w, h);\n+\t      y += h;\n+\n+\t      setBounds(previous, x, y, w, h);\n+\t      x += w;\n+\t      y -= h;\n+\n+\t      setBounds(editor, x, y, e_width, e.height);\n+\t    }\n+        }\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param parent DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public Dimension minimumLayoutSize(Container parent)\n+    {\n+      Dimension d = new Dimension();\n+\n+      if (editor != null)\n+        {\n+\t  Dimension tmp = editor.getMinimumSize();\n+\t  d.width += tmp.width;\n+\t  d.height = tmp.height;\n+        }\n+\n+      int nextWidth = 0;\n+      int previousWidth = 0;\n+      int otherHeight = 0;\n+\n+      if (next != null)\n+        {\n+\t  Dimension tmp = next.getMinimumSize();\n+\t  nextWidth = tmp.width;\n+\t  otherHeight += tmp.height;\n+        }\n+      if (previous != null)\n+        {\n+\t  Dimension tmp = previous.getMinimumSize();\n+\t  previousWidth = tmp.width;\n+\t  otherHeight += tmp.height;\n+        }\n+\n+      d.height = Math.max(d.height, otherHeight);\n+      d.width += Math.max(nextWidth, previousWidth);\n+\n+      return d;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param parent DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public Dimension preferredLayoutSize(Container parent)\n+    {\n+      Dimension d = new Dimension();\n+\n+      if (editor != null)\n+        {\n+\t  Dimension tmp = editor.getPreferredSize();\n+\t  d.width += Math.max(tmp.width, 40);\n+\t  d.height = tmp.height;\n+        }\n+\n+      int nextWidth = 0;\n+      int previousWidth = 0;\n+      int otherHeight = 0;\n+\n+      if (next != null)\n+        {\n+\t  Dimension tmp = next.getPreferredSize();\n+\t  nextWidth = tmp.width;\n+\t  otherHeight += tmp.height;\n+        }\n+      if (previous != null)\n+        {\n+\t  Dimension tmp = previous.getPreferredSize();\n+\t  previousWidth = tmp.width;\n+\t  otherHeight += tmp.height;\n+        }\n+\n+      d.height = Math.max(d.height, otherHeight);\n+      d.width += Math.max(nextWidth, previousWidth);\n+\n+      return d;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param child DOCUMENT ME!\n+     */\n+    public void removeLayoutComponent(Component child)\n+    {\n+      if (child == editor)\n+\teditor = null;\n+      else if (child == next)\n+\tnext = null;\n+      else if (previous == child)\n+\tprevious = null;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param name DOCUMENT ME!\n+     * @param child DOCUMENT ME!\n+     */\n+    public void addLayoutComponent(String name, Component child)\n+    {\n+      if (\"Editor\".equals(name))\n+\teditor = child;\n+      else if (\"Next\".equals(name))\n+\tnext = child;\n+      else if (\"Previous\".equals(name))\n+\tprevious = child;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param c DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    private Dimension minSize(Component c)\n+    {\n+      if (c == null)\n+\treturn new Dimension();\n+      else\n+\treturn c.getMinimumSize();\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @param c DOCUMENT ME!\n+     * @param x DOCUMENT ME!\n+     * @param y DOCUMENT ME!\n+     * @param w DOCUMENT ME!\n+     * @param h DOCUMENT ME!\n+     */\n+    private void setBounds(Component c, int x, int y, int w, int h)\n+    {\n+      if (c != null)\n+\tc.setBounds(x, y, w, h);\n+    }\n+\n+    /** DOCUMENT ME! */\n+    private Component editor;\n+\n+    /** DOCUMENT ME! */\n+    private Component next;\n+\n+    /** DOCUMENT ME! */\n+    private Component previous;\n+  }\n+}"}, {"sha": "c55c9400fa260e90e7d240ea55651c6975a6f8f1", "filename": "libjava/javax/swing/plaf/basic/BasicTableHeaderUI.java", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTableHeaderUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTableHeaderUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTableHeaderUI.java?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,301 @@\n+/* BasicTableHeaderUI.java\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.plaf.basic;\n+\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Rectangle;\n+import java.awt.event.MouseEvent;\n+import javax.swing.CellRendererPane;\n+import javax.swing.JComponent;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n+import javax.swing.border.Border;\n+import javax.swing.event.MouseInputListener;\n+import javax.swing.plaf.ComponentUI;\n+import javax.swing.plaf.TableHeaderUI;\n+import javax.swing.table.JTableHeader;\n+import javax.swing.table.TableCellRenderer;\n+import javax.swing.table.TableColumn;\n+import javax.swing.table.TableColumnModel;\n+\n+\n+public class BasicTableHeaderUI\n+  extends TableHeaderUI\n+{\n+\n+  public static ComponentUI createUI(JComponent h)\n+  {\n+    return new BasicTableHeaderUI();\n+  }\n+\n+  protected JTableHeader header;\n+  protected MouseInputListener mouseInputListener;\n+  protected CellRendererPane rendererPane;\n+  protected Border cellBorder;\n+\n+  class MouseInputHandler\n+    implements MouseInputListener\n+  {\n+    public void mouseClicked(MouseEvent e) {}\n+    public void mouseDragged(MouseEvent e) {}\n+    public void mouseEntered(MouseEvent e) {}\n+    public void mouseExited(MouseEvent e) {}\n+    public void mouseMoved(MouseEvent e) {}\n+    public void mousePressed(MouseEvent e) {}\n+    public void mouseReleased(MouseEvent e) {}\n+  }\n+\n+  protected MouseInputListener createMouseInputListener()\n+  {\n+    return new MouseInputHandler();\n+  }\n+\n+  public BasicTableHeaderUI()\n+  {\n+    mouseInputListener = createMouseInputListener();\n+  }\n+\n+  protected void installDefaults()\n+  {\n+    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n+    header.setBackground(defaults.getColor(\"TableHeader.background\"));\n+    header.setForeground(defaults.getColor(\"TableHeader.foreground\"));\n+    header.setFont(defaults.getFont(\"TableHeader.font\"));\n+    cellBorder = defaults.getBorder(\"TableHeader.cellBorder\");\n+  }\n+\n+  protected void installKeyboardActions()\n+  {\n+  }\n+\n+  protected void installListeners()\n+  {\n+    header.addMouseListener(mouseInputListener);\n+  }\n+\n+  public void installUI(JComponent c)\n+  {\n+    header = (JTableHeader) c;\n+    installDefaults();\n+    installKeyboardActions();\n+    installListeners();\n+  }\n+\n+  protected void uninstallDefaults()\n+  {\n+    header.setBackground(null);\n+    header.setForeground(null);\n+    header.setFont(null);\n+  }\n+\n+  protected void uninstallKeyboardActions()\n+  {\n+  }\n+\n+  protected void uninstallListeners()\n+  {\n+    header.removeMouseListener(mouseInputListener);\n+  }\n+\n+  public void uninstallUI(JComponent c)\n+  {\n+    uninstallListeners();\n+    uninstallKeyboardActions();\n+    uninstallDefaults();\n+  }\n+\n+  public void paint(Graphics gfx, JComponent c)\n+  {\n+    TableColumnModel cmod = header.getColumnModel();\n+    int ncols = cmod.getColumnCount();\n+    if (ncols == 0)\n+      return;\n+    \n+    Rectangle clip = gfx.getClipBounds();\n+    TableCellRenderer defaultRend = header.getDefaultRenderer();\n+\n+    for (int i = 0; i < ncols; ++i)\n+      {\n+        Rectangle bounds = header.getHeaderRect(i);\n+        if (bounds.intersects(clip))\n+          {\n+            TableColumn col = cmod.getColumn(i);\n+            TableCellRenderer rend = col.getHeaderRenderer();\n+            if (rend == null)\n+              rend = defaultRend;\n+            Object val = col.getHeaderValue();\n+            Component comp = rend.getTableCellRendererComponent(header.getTable(),\n+                                                                val,\n+                                                                false, // isSelected\n+                                                                false, // isFocused\n+                                                                -1, i);\n+            comp.setFont(header.getFont());\n+            comp.setBackground(header.getBackground());\n+            comp.setForeground(header.getForeground());\n+            if (comp instanceof JComponent)\n+              ((JComponent)comp).setBorder(cellBorder);\n+            gfx.translate(bounds.x, bounds.y);\n+            comp.setSize(bounds.width, bounds.height);\n+            comp.setLocation(0,0);\n+            comp.paint(gfx);\n+            gfx.translate(-bounds.x, -bounds.y);\n+          }\n+      }\n+\n+  }\n+\n+  public Dimension getMaximumSize(JComponent c)\n+  {\n+    TableColumnModel cmod = header.getColumnModel();\n+    TableCellRenderer defaultRend = header.getDefaultRenderer();\n+    int ncols = cmod.getColumnCount();    \n+    int spacing = 0;\n+    Dimension ret = getPreferredSize(c);\n+    \n+    if (header.getTable() != null \n+        && header.getTable().getInterCellSpacing() != null)\n+      spacing = header.getTable().getInterCellSpacing().width;\n+\n+    ret.width = 0;\n+    for (int i = 0; i < ncols; ++i)      \n+      {\n+        TableColumn col = cmod.getColumn(i);\n+        TableCellRenderer rend = col.getHeaderRenderer();\n+        if (rend == null)\n+          rend = defaultRend;\n+        Object val = col.getHeaderValue();\n+        Component comp = rend.getTableCellRendererComponent(header.getTable(),\n+                                                            val,\n+                                                            false, // isSelected\n+                                                            false, // isFocused\n+                                                            -1, i);\n+        comp.setFont(header.getFont());\n+        comp.setBackground(header.getBackground());\n+        comp.setForeground(header.getForeground());\n+        if (comp instanceof JComponent)\n+          ((JComponent)comp).setBorder(cellBorder);\n+\n+        Dimension d = comp.getMaximumSize();\n+        ret.width += col.getMaxWidth();\n+        ret.height = Math.max(ret.height, d.height);\n+        ret.width += spacing;\n+      }\n+    return ret;\n+  }\n+\n+  public Dimension getMinimumSize(JComponent c)\n+  {\n+    TableColumnModel cmod = header.getColumnModel();\n+    TableCellRenderer defaultRend = header.getDefaultRenderer();\n+    int ncols = cmod.getColumnCount();    \n+    int spacing = 0;\n+    Dimension ret = getPreferredSize(c);\n+\n+    if (header.getTable() != null \n+        && header.getTable().getInterCellSpacing() != null)\n+      spacing = header.getTable().getInterCellSpacing().width;\n+\n+    ret.width = 0;\n+    for (int i = 0; i < ncols; ++i)      \n+      {\n+        TableColumn col = cmod.getColumn(i);\n+        TableCellRenderer rend = col.getHeaderRenderer();\n+        if (rend == null)\n+          rend = defaultRend;\n+        Object val = col.getHeaderValue();\n+        Component comp = rend.getTableCellRendererComponent(header.getTable(),\n+                                                            val,\n+                                                            false, // isSelected\n+                                                            false, // isFocused\n+                                                            -1, i);\n+        comp.setFont(header.getFont());\n+        comp.setBackground(header.getBackground());\n+        comp.setForeground(header.getForeground());\n+        if (comp instanceof JComponent)\n+          ((JComponent)comp).setBorder(cellBorder);\n+\n+        Dimension d = comp.getMinimumSize();\n+        ret.width += col.getMinWidth();\n+        ret.width += spacing;\n+        ret.height = Math.max(ret.height, d.height);\n+      }\n+    return ret;\n+  }\n+  \n+  public Dimension getPreferredSize(JComponent c)\n+  {\n+    TableColumnModel cmod = header.getColumnModel();\n+    TableCellRenderer defaultRend = header.getDefaultRenderer();\n+    int ncols = cmod.getColumnCount();    \n+    Dimension ret = new Dimension(0,0);\n+    int spacing = 0;\n+\n+    if (header.getTable() != null \n+        && header.getTable().getInterCellSpacing() != null)\n+      spacing = header.getTable().getInterCellSpacing().width;\n+    \n+    for (int i = 0; i < ncols; ++i)      \n+      {\n+        TableColumn col = cmod.getColumn(i);\n+        TableCellRenderer rend = col.getHeaderRenderer();\n+        if (rend == null)\n+          rend = defaultRend;\n+        Object val = col.getHeaderValue();\n+        Component comp = rend.getTableCellRendererComponent(header.getTable(),\n+                                                            val,\n+                                                            false, // isSelected\n+                                                            false, // isFocused\n+                                                            -1, i);\n+        comp.setFont(header.getFont());\n+        comp.setBackground(header.getBackground());\n+        comp.setForeground(header.getForeground());\n+        if (comp instanceof JComponent)\n+          ((JComponent)comp).setBorder(cellBorder);\n+\n+        Dimension d = comp.getPreferredSize();\n+        ret.width += d.width;\n+        ret.width += spacing;\n+        ret.height = Math.max(d.height, ret.height);        \n+      }\n+    return ret;\n+  }\n+  \n+  \n+}"}, {"sha": "5fa8fb713123a30f81a44059da64051ea23f5905", "filename": "libjava/javax/swing/plaf/basic/BasicTableUI.java", "status": "added", "additions": 374, "deletions": 0, "changes": 374, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTableUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTableUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTableUI.java?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,374 @@\n+/* BasicTableUI.java\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.plaf.basic;\n+\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.KeyListener;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.FocusListener;\n+import java.awt.event.MouseEvent;\n+import javax.swing.CellRendererPane;\n+import javax.swing.JComponent;\n+import javax.swing.JTable;\n+import javax.swing.ListSelectionModel;\n+import javax.swing.event.MouseInputListener;\n+import javax.swing.plaf.ComponentUI;\n+import javax.swing.plaf.TableUI;\n+import javax.swing.table.TableCellRenderer;\n+import javax.swing.table.TableColumn;\n+import javax.swing.table.TableColumnModel;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n+\n+\n+public class BasicTableUI\n+  extends TableUI\n+{\n+\n+  public static ComponentUI createUI(JComponent comp) \n+  {\n+    return new BasicTableUI();\n+  }\n+\n+  protected FocusListener focusListener;  \n+  protected KeyListener keyListener;   \n+  protected MouseInputListener\tmouseInputListener;   \n+  protected CellRendererPane rendererPane;   \n+  protected JTable table;\n+\n+  class FocusHandler implements FocusListener\n+  {\n+    public void focusGained(FocusEvent e) \n+    {\n+    }\n+    public void focusLost(FocusEvent e) \n+    {\n+    }\n+  }\n+\n+  class KeyHandler implements KeyListener\n+  {\n+    public void keyPressed(KeyEvent e) \n+    {\n+    }\n+    public void keyReleased(KeyEvent e) \n+    {\n+    }\n+    public void keyTyped(KeyEvent e) \n+    {\n+    }\n+  }\n+\n+  class MouseInputHandler implements MouseInputListener\n+  {\n+    Point begin, curr;\n+\n+    private int getRowForPoint(Point p)\n+    {      \n+      int y0 = table.getLocation().y;\n+      int nrows = table.getRowCount();\n+      Dimension gap = table.getInterCellSpacing();\n+      int height = table.getRowHeight() + (gap == null ? 0 : gap.height);\n+      int y = p.y;\n+      for (int i = 0; i < nrows; ++i)\n+        {\n+          if (0 <= y && y < height)\n+            return i;\n+          y -= height;\n+        }\n+      return -1;\n+    }\n+\n+    private int getColForPoint(Point p)\n+    {\n+      int x0 = table.getLocation().x;\n+      int ncols = table.getColumnCount();\n+      Dimension gap = table.getInterCellSpacing();\n+      TableColumnModel cols = table.getColumnModel();      \n+      int x = p.x;\n+      for (int i = 0; i < ncols; ++i)\n+        {\n+          int width = cols.getColumn(i).getWidth() + (gap == null ? 0 : gap.width);\n+          if (0 <= x && x < width)\n+            return i;\n+          x -= width;\n+        }\n+      return -1;\n+    }\n+\n+    private void updateSelection()\n+    {\n+      if (table.getRowSelectionAllowed())\n+        {\n+          int lo_row = getRowForPoint(begin);\n+          int hi_row  = getRowForPoint(curr);\n+          ListSelectionModel rowModel = table.getSelectionModel();\n+          if (lo_row != -1 && hi_row != -1)\n+            rowModel.setSelectionInterval(lo_row, hi_row);\n+        }\n+\n+      if (table.getColumnSelectionAllowed())\n+        {\n+          int lo_col = getColForPoint(begin);\n+          int hi_col = getColForPoint(curr);\n+          ListSelectionModel colModel = table.getColumnModel().getSelectionModel();\n+          if (lo_col != -1 && hi_col != -1)\n+            colModel.setSelectionInterval(lo_col, hi_col);\n+        }\n+    }\n+\n+    public void mouseClicked(MouseEvent e) \n+    {\n+    }\n+    public void mouseDragged(MouseEvent e) \n+    {\n+      curr = new Point(e.getX(), e.getY());\n+      updateSelection();      \n+    }\n+    public void mouseEntered(MouseEvent e) \n+    {\n+    }\n+    public void mouseExited(MouseEvent e) \n+    {\n+    }\n+    public void mouseMoved(MouseEvent e) \n+    {\n+    }\n+    public void mousePressed(MouseEvent e) \n+    {\n+      begin = new Point(e.getX(), e.getY());\n+      curr = new Point(e.getX(), e.getY());\n+      updateSelection();\n+    }\n+    public void mouseReleased(MouseEvent e) \n+    {\n+      begin = null;\n+      curr = null;\n+    }\n+  }\n+\n+  protected FocusListener createFocusListener() \n+  {\n+    return new FocusHandler();\n+  }\n+  protected KeyListener createKeyListener() \n+  {\n+    return new KeyHandler();\n+  }\n+  protected MouseInputListener createMouseInputListener() \n+  {\n+    return new MouseInputHandler();\n+  }\n+\n+  public Dimension getMaximumSize(JComponent comp) \n+  {\n+    return getPreferredSize(comp);\n+  }\n+\n+  public Dimension getMinimumSize(JComponent comp) \n+  {\n+    return getPreferredSize(comp);\n+  }\n+\n+  public Dimension getPreferredSize(JComponent comp) \n+  {\n+    int width = table.getColumnModel().getTotalColumnWidth();\n+    int height = table.getRowCount() * table.getRowHeight();\n+    return new Dimension(width, height);\n+  }\n+\n+  protected void installDefaults() \n+  {\n+    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n+    table.setFont(defaults.getFont(\"Table.font\"));\n+    table.setGridColor(defaults.getColor(\"Table.gridColor\"));\n+    table.setForeground(defaults.getColor(\"Table.foreground\"));\n+    table.setBackground(defaults.getColor(\"Table.background\"));\n+    table.setSelectionForeground(defaults.getColor(\"Table.selectionForeground\"));\n+    table.setSelectionBackground(defaults.getColor(\"Table.selectionBackground\"));\n+    table.setOpaque(true);\n+  }\n+  protected void installKeyboardActions() \n+  {\n+  }\n+\n+  protected void installListeners() \n+  {\n+    table.addFocusListener(focusListener);  \n+    table.addKeyListener(keyListener);\n+    table.addMouseListener(mouseInputListener);    \n+  }\n+\n+  protected void uninstallDefaults() \n+  {\n+    table.setFont(null);\n+    table.setGridColor(null);\n+    table.setForeground(null);\n+    table.setBackground(null);\n+    table.setSelectionForeground(null);\n+    table.setSelectionBackground(null);\n+  }\n+\n+  protected void uninstallKeyboardActions() \n+  {\n+  }\n+\n+  protected void uninstallListeners() \n+  {\n+    table.removeFocusListener(focusListener);  \n+    table.removeKeyListener(keyListener);\n+    table.removeMouseListener(mouseInputListener);    \n+  }\n+\n+  public void installUI(JComponent comp) \n+  {\n+    table = (JTable)comp;\n+    focusListener = createFocusListener();  \n+    keyListener = createKeyListener();\n+    mouseInputListener = createMouseInputListener();\n+    installDefaults();\n+    installKeyboardActions();\n+    installListeners();\n+  }\n+\n+  public void uninstallUI(JComponent c) \n+  {\n+    uninstallListeners();\n+    uninstallKeyboardActions();\n+    uninstallDefaults();    \n+  }\n+\n+  public void paint(Graphics gfx, JComponent ignored) \n+  {\n+    int ncols = table.getColumnCount();\n+    int nrows = table.getRowCount();\n+    if (nrows == 0 || ncols == 0)\n+      return;\n+\n+    Rectangle clip = gfx.getClipBounds();\n+    TableColumnModel cols = table.getColumnModel();\n+\n+    int height = table.getRowHeight();\n+    int x0 = 0, y0 = 0;\n+    int x = x0;\n+    int y = y0;\n+\n+    Dimension gap = table.getInterCellSpacing();\n+    int ymax = clip.y + clip.height;\n+    int xmax = clip.x + clip.width;\n+\n+    // paint the cell contents\n+    for (int c = 0; c < ncols && x < xmax; ++c)\n+      {\n+        y = y0;\n+        TableColumn col = cols.getColumn(c);\n+        int width = col.getWidth();\n+        int modelCol = col.getModelIndex();\n+\n+        for (int r = 0; r < nrows && y < ymax; ++r)\n+          {\n+            Rectangle bounds = new Rectangle(x, y, width, height);\n+              if (bounds.intersects(clip))\n+              {\n+                TableCellRenderer rend = table.getCellRenderer(r, c);\n+                Component comp = table.prepareRenderer(rend, r, c);\n+                gfx.translate(x, y);\n+                comp.setBounds(new Rectangle(0, 0, width, height));\n+                comp.paint(gfx);\n+                gfx.translate(-x, -y);\n+              }\n+              y += height;\n+              if (gap != null)\n+                y += gap.height;\n+          }\n+        x += width;\n+        if (gap != null)\n+          x += gap.width;\n+      }\n+\n+    // tighten up the x and y max bounds\n+    ymax = y;\n+    xmax = x;\n+\n+    Color grid = table.getGridColor();    \n+\n+    // paint vertical grid lines    \n+    if (grid != null && table.getShowVerticalLines())\n+      {    \n+        x = x0;\n+        Color save = gfx.getColor();\n+        gfx.setColor(grid);\n+        boolean paintedLine = false;\n+        for (int c = 0; c < ncols && x < xmax; ++c)\n+          {\n+            x += cols.getColumn(c).getWidth();;\n+            if (gap != null)\n+              x += gap.width;\n+            gfx.drawLine(x, y0, x, ymax);\n+            paintedLine = true;\n+          }\n+        gfx.setColor(save);\n+      }\n+\n+    // paint horizontal grid lines    \n+    if (grid != null && table.getShowHorizontalLines())\n+      {    \n+        y = y0;\n+        Color save = gfx.getColor();\n+        gfx.setColor(grid);\n+        boolean paintedLine = false;\n+        for (int r = 0; r < nrows && y < ymax; ++r)\n+          {\n+            y += height;\n+            if (gap != null)\n+              y += gap.height;\n+            gfx.drawLine(x0, y, xmax, y);\n+            paintedLine = true;\n+          }\n+        gfx.setColor(save);\n+      }\n+\n+  }\n+\n+}"}, {"sha": "f1714c20d35e577d64a24381a82610df1453fc67", "filename": "libjava/javax/swing/plaf/basic/BasicTextAreaUI.java", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTextAreaUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTextAreaUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTextAreaUI.java?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,69 @@\n+/* BasicTextAreaUI.java -- \n+   Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.swing.plaf.basic;\n+\n+import java.beans.PropertyChangeEvent;\n+\n+import javax.swing.JComponent;\n+import javax.swing.plaf.ComponentUI;\n+import javax.swing.text.Element;\n+import javax.swing.text.PlainView;\n+import javax.swing.text.View;\n+\n+public class BasicTextAreaUI extends BasicTextUI\n+{\n+  public static ComponentUI createUI(JComponent comp)\n+  {\n+    return new BasicTextAreaUI();\n+  }\n+\n+  public BasicTextAreaUI()\n+  {\n+  }\n+\n+  public View create(Element elem)\n+  {\n+    return new PlainView(elem);\n+  }\n+\n+  protected String getPropertyPrefix()\n+  {\n+    return \"TextArea\";\n+  }\n+}"}, {"sha": "3b5941f1bef0087960a1aebcf61a97b5df3a3aa0", "filename": "libjava/javax/swing/plaf/basic/BasicToolTipUI.java", "status": "added", "additions": 287, "deletions": 0, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicToolTipUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicToolTipUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicToolTipUI.java?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,287 @@\n+/* BasicToolTipUI.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+   This file is part of GNU Classpath.\n+\n+   GNU Classpath is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU Classpath is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU Classpath; see the file COPYING.  If not, write to the\n+   Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+   02111-1307 USA.\n+\n+   Linking this library statically or dynamically with other modules is\n+   making a combined work based on this library.  Thus, the terms and\n+   conditions of the GNU General Public License cover the whole\n+   combination.\n+\n+   As a special exception, the copyright holders of this library give you\n+   permission to link this library with independent modules to produce an\n+   executable, regardless of the license terms of these independent\n+   modules, and to copy and distribute the resulting executable under\n+   terms of your choice, provided that you also meet, for each linked\n+   independent module, the terms and conditions of the license of that\n+   module.  An independent module is a module which is not derived from\n+   or based on this library.  If you modify this library, you may extend\n+   this exception to your version of the library, but you are not\n+   obligated to do so.  If you do not wish to do so, delete this\n+   exception statement from your version. */\n+\n+package javax.swing.plaf.basic;\n+\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n+import java.awt.Rectangle;\n+import javax.swing.JComponent;\n+import javax.swing.JToolTip;\n+import javax.swing.SwingConstants;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n+import javax.swing.border.Border;\n+import javax.swing.plaf.ComponentUI;\n+import javax.swing.plaf.ToolTipUI;\n+\n+\n+/**\n+ * This is the Basic Look and Feel UI class for JToolTip.\n+ */\n+public class BasicToolTipUI extends ToolTipUI\n+{\n+  /** The default Border around the JToolTip. */\n+  private static Border defaultBorder = new Border()\n+    {\n+      // FIXME: This needs to go into Basic Look and Feel\n+      // defaults.\n+\n+\t\t\t/**\n+\t\t\t * This method returns the border insets.\n+\t\t\t *\n+\t\t\t * @param c The Component to find Border insets for.\n+\t\t\t *\n+\t\t\t * @return The Border insets.\n+\t\t\t */\t\t \n+      public Insets getBorderInsets(Component c)\n+      {\n+\treturn new Insets(4, 4, 4, 4);\n+      }\n+\n+\t\t\t/**\n+\t\t\t * This method returns whether the border is opaque.\n+\t\t\t *\n+\t\t\t * @return Whether the border is opaque.\n+\t\t\t */\n+      public boolean isBorderOpaque()\n+      {\n+\treturn false;\n+      }\n+\n+\t\t\t/**\n+\t\t\t * This method paints the border.\n+\t\t\t *\n+\t\t\t * @param c The Component to paint this border around.\n+\t\t\t * @param g The Graphics object to paint with.\n+\t\t\t * @param x The x coordinate to start painting at.\n+\t\t\t * @param y The y coordinate to start painting at.\n+\t\t\t * @param w The width of the Component.\n+\t\t\t * @param y The height of the Component.\n+\t\t\t */\n+      public void paintBorder(Component c, Graphics g, int x, int y, int w,\n+                              int h)\n+      {\n+\tColor saved = g.getColor();\n+\tg.setColor(Color.BLACK);\n+\n+\tg.drawRect(0, 0, w - 1, h - 1);\n+\n+\tg.setColor(saved);\n+      }\n+    };\n+\n+\t/** The shared instance of BasicToolTipUI used for all ToolTips. */\n+\tprivate static BasicToolTipUI shared;\n+\n+  /**\n+   * Creates a new BasicToolTipUI object.\n+   */\n+  public BasicToolTipUI()\n+  {\n+    super();\n+  }\n+\n+  /**\n+   * This method creates a new BasicToolTip UI for the given \n+\t * JComponent.\n+   *\n+   * @param c The JComponent to create a UI for.\n+   *\n+   * @return A BasicToolTipUI that can be used by the given JComponent.\n+   */\n+  public static ComponentUI createUI(JComponent c)\n+  {\n+\t\tif (shared == null)\n+\t\t\tshared = new BasicToolTipUI();\n+\t\treturn shared;\n+  }\n+\n+  /**\n+   * This method returns the msximum size of the given JComponent.\n+   *\n+   * @param c The JComponent to find a maximum size for.\n+   *\n+   * @return The maximum size.\n+   */\n+  public Dimension getMaximumSize(JComponent c)\n+  {\n+    return getPreferredSize(c);\n+  }\n+\n+  /**\n+   * This method returns the minimum size of the given JComponent.\n+   *\n+   * @param c The JComponent to find a minimum size for.\n+   *\n+   * @return The minimum size.\n+   */\n+  public Dimension getMinimumSize(JComponent c)\n+  {\n+    return getPreferredSize(c);\n+  }\n+\n+  /**\n+   * This method returns the preferred size of the given JComponent.\n+   *\n+   * @param c The JComponent to find a preferred size for.\n+   *\n+   * @return The preferred size.\n+   */\n+  public Dimension getPreferredSize(JComponent c)\n+  {\n+    JToolTip tip = (JToolTip) c;\n+    Rectangle vr = new Rectangle();\n+    Rectangle ir = new Rectangle();\n+    Rectangle tr = new Rectangle();\n+    Insets insets = tip.getInsets();\n+    FontMetrics fm = tip.getToolkit().getFontMetrics(tip.getFont());\n+    SwingUtilities.layoutCompoundLabel(tip, fm, tip.getTipText(), null,\n+                                       SwingConstants.CENTER,\n+                                       SwingConstants.CENTER,\n+                                       SwingConstants.CENTER,\n+                                       SwingConstants.CENTER, vr, ir, tr, 0);\n+    return new Dimension(insets.left + tr.width + insets.right,\n+                         insets.top + tr.height + insets.bottom);\n+  }\n+\n+  /**\n+   * This method installs the defaults for the given JComponent.\n+   *\n+   * @param c The JComponent to install defaults for.\n+   */\n+  protected void installDefaults(JComponent c)\n+  {\n+    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n+    c.setBackground(defaults.getColor(\"ToolTip.background\"));\n+    c.setForeground(defaults.getColor(\"ToolTip.foreground\"));\n+    c.setFont(defaults.getFont(\"ToolTip.font\"));\n+    c.setBorder(defaultBorder);\n+  }\n+\n+  /**\n+   * This method installs the listeners for the given JComponent.\n+   *\n+   * @param c The JComponent to install listeners for.\n+   */\n+  protected void installListeners(JComponent c)\n+  {\n+  }\n+\n+  /**\n+   * This method installs the UI for the given JComponent.\n+   *\n+   * @param c The JComponent to install the UI for.\n+   */\n+  public void installUI(JComponent c)\n+  {\n+    c.setOpaque(true);\n+    installDefaults(c);\n+    installListeners(c);\n+  }\n+\n+  /**\n+   * This method paints the given JComponent with the given Graphics object.\n+   *\n+   * @param g The Graphics object to paint with.\n+   * @param c The JComponent to paint.\n+   */\n+  public void paint(Graphics g, JComponent c)\n+  {\n+    JToolTip tip = (JToolTip) c;\n+\n+    String text = tip.getTipText();\n+    if (text == null)\n+      return;\n+\n+    Rectangle vr = new Rectangle();\n+    vr = SwingUtilities.calculateInnerArea(tip, vr);\n+    Rectangle ir = new Rectangle();\n+    Rectangle tr = new Rectangle();\n+    FontMetrics fm = tip.getToolkit().getFontMetrics(tip.getFont());\n+    SwingUtilities.layoutCompoundLabel(tip, fm, tip.getTipText(), null,\n+                                       SwingConstants.CENTER,\n+                                       SwingConstants.CENTER,\n+                                       SwingConstants.CENTER,\n+                                       SwingConstants.CENTER, vr, ir, tr, 0);\n+\n+    Color saved = g.getColor();\n+    g.setColor(Color.BLACK);\n+\n+    g.drawString(text, vr.x, vr.y + fm.getAscent());\n+\n+    g.setColor(saved);\n+  }\n+\n+  /**\n+   * This method uninstalls the defaults for the given JComponent.\n+   *\n+   * @param c The JComponent to uninstall defaults for.\n+   */\n+  protected void uninstallDefaults(JComponent c)\n+  {\n+    c.setForeground(null);\n+    c.setBackground(null);\n+    c.setFont(null);\n+    c.setBorder(null);\n+  }\n+\n+  /**\n+   * This method uninstalls listeners for the given JComponent.\n+   *\n+   * @param c The JComponent to uninstall listeners for.\n+   */\n+  protected void uninstallListeners(JComponent c)\n+  {\n+  }\n+\n+  /**\n+   * This method uninstalls the UI for the given JComponent.\n+   *\n+   * @param c The JComponent to uninstall.\n+   */\n+  public void uninstallUI(JComponent c)\n+  {\n+    uninstallDefaults(c);\n+    uninstallListeners(c);\n+  }\n+}"}, {"sha": "d4ef1f2e5987632e05372d48b8b1a0ad6bf15d3c", "filename": "libjava/javax/swing/plaf/basic/ComboPopup.java", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FComboPopup.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FComboPopup.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FComboPopup.java?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,103 @@\n+/* ComboPopup.java\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.plaf.basic;\n+\n+import java.awt.event.KeyListener;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseListener;\n+import java.awt.event.MouseMotionListener;\n+import javax.swing.JList;\n+\n+\n+public interface ComboPopup\n+{\n+  /**\n+   * This method display popup menu containing list of JComboBox's items to\n+   * the screen\n+   */\n+  void show();\n+\n+  /**\n+   * This method hides popup menu with list of JComboBox's item from the\n+   * screen\n+   */\n+  void hide();\n+\n+  /**\n+   * Retursn true if popup menu with JComboBOx's item is currently visible on\n+   * the screen and false otherwise\n+   *\n+   * @return true if JComboBox's popup menu with list of items is currently\n+   *         visible on the screen and false otherwise.\n+   */\n+  boolean isVisible();\n+\n+  /**\n+   * Return JList that is used to draw cells of the JComboBox.\n+   *\n+   * @return JList that is used to draw cells of the JcomboBox\n+   */\n+  JList getList();\n+\n+  /**\n+   * This method returns MouseListener that listen's to mouse events occuring\n+   * in the combo box\n+   *\n+   * @return MouseListenere\n+   */\n+  MouseListener getMouseListener();\n+\n+  /**\n+   * This method returns MouseListener that listen's to mouse events occuring\n+   * in the combo box.\n+   *\n+   * @return MouseMotionListener\n+   */\n+  MouseMotionListener getMouseMotionListener();\n+\n+  /**\n+   * This method returns KeyListener that listen's to key events  occuring in\n+   * the combo box.\n+   *\n+   * @return KeyListener\n+   */\n+  KeyListener getKeyListener();\n+\n+  /* This method removes any listeners that were installed */\n+  void uninstallingUI();\n+}"}, {"sha": "746056dfe7a8f836d562ac379f0991c636445201", "filename": "libjava/javax/swing/text/SimpleAttributeSet.java", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Ftext%2FSimpleAttributeSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Ftext%2FSimpleAttributeSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FSimpleAttributeSet.java?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,192 @@\n+/* SimpleAttributeSet.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.text;\n+\n+import java.io.Serializable;\n+import java.util.Enumeration;\n+import java.util.Hashtable;\n+import java.lang.Cloneable;\n+\n+public class SimpleAttributeSet\n+  implements MutableAttributeSet, Serializable, Cloneable\n+{\n+  Hashtable tab;\n+\n+  static AttributeSet EMPTY = new SimpleAttributeSet();\n+\n+  public SimpleAttributeSet()\n+  {\n+    this(null);\n+  }\n+  \n+  public SimpleAttributeSet(AttributeSet a)\n+  {\n+    tab = new Hashtable();\n+    addAttributes(a);\n+  }\n+\n+  public void addAttribute(Object name, Object value)\n+  {\n+    tab.put(name, value);\n+  }\n+\n+  public void addAttributes(AttributeSet attributes)\n+  {\n+    Enumeration e = attributes.getAttributeNames();\n+    while (e.hasMoreElements())\n+      {\n+        Object name = e.nextElement();\n+        Object val = attributes.getAttribute(name);\n+        tab.put(name, val);\n+      }\n+  }\n+\n+  public Object clone()\n+  {\n+    SimpleAttributeSet s = new SimpleAttributeSet();\n+    s.tab = (Hashtable) tab.clone();\n+    return s;\n+  }\n+\n+  public boolean containsAttribute(Object name, Object value)\n+  {\n+    return tab.containsKey(name) \n+      && tab.get(name).equals(value);\n+  }\n+    \n+  public boolean containsAttributes(AttributeSet attributes)\n+  {\n+    Enumeration e = attributes.getAttributeNames();\n+    while (e.hasMoreElements())\n+      {\n+        Object name = e.nextElement();\n+        Object val = attributes.getAttribute(name);\n+        if (! containsAttribute(name, val))\n+          return false;\t\t\n+      }\n+    return true;\n+  }\n+\n+  public AttributeSet copyAttributes()\n+  {\n+    return (AttributeSet) clone();\n+  }\n+\n+  public boolean equals(Object obj)\n+  {\n+    return (obj != null) \n+      && (obj instanceof SimpleAttributeSet)\n+      && ((SimpleAttributeSet)obj).tab.equals(this.tab);\n+  }\n+\n+  public Object getAttribute(Object name)\n+  {\n+    Object val = tab.get(name);\n+    if (val != null) \n+      return val;\n+\n+    Object p = getResolveParent();\n+    if (p != null && p instanceof AttributeSet)\n+      return (((AttributeSet)p).getAttribute(name));\n+\n+    return null;\n+  }\n+\n+  public int getAttributeCount()\n+  {\n+    return tab.size();\n+  }\n+\n+  public Enumeration getAttributeNames()\n+  {\n+    return tab.keys();\n+  }\n+\n+  public AttributeSet getResolveParent()\n+  {\n+    return (AttributeSet) tab.get(ResolveAttribute);\n+  }\n+\n+  public int hashCode()\n+  {\n+    return tab.hashCode();\n+  }\n+\n+  public boolean isDefined(Object attrName)\n+  {\n+    return tab.containsKey(attrName);\n+  }\n+\n+  public boolean isEmpty()\n+  {\n+    return tab.isEmpty();\t\n+  }\n+        \n+  public boolean isEqual(AttributeSet attr)\n+  {\n+    return this.equals(attr);\n+  }\n+    \n+  public void removeAttribute(Object name)\n+  {\n+    tab.remove(name);\n+  }\n+\n+  public void removeAttributes(AttributeSet attributes)\n+  {\n+    removeAttributes(attributes.getAttributeNames());\n+  }\n+\n+  public void removeAttributes(Enumeration names)\n+  {\n+    while (names.hasMoreElements())\n+      {\n+        removeAttribute(names.nextElement());\n+      }\t\n+  }\n+\n+  public void setResolveParent(AttributeSet parent)\n+  {\n+    addAttribute(ResolveAttribute, parent);\n+  }\n+    \n+  public String toString()\n+  {\n+    return tab.toString();\n+  }    \n+}"}, {"sha": "2201c47b5b986bf1f680a8c29daa9500eee172de", "filename": "libjava/javax/swing/text/StyleConstants.java", "status": "added", "additions": 439, "deletions": 0, "changes": 439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Ftext%2FStyleConstants.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Ftext%2FStyleConstants.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FStyleConstants.java?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,439 @@\n+/* StyleConstants.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.text;\n+\n+import java.awt.Color;\n+import java.awt.Component;\n+import javax.swing.Icon;\n+\n+public class StyleConstants\n+{\n+\n+  String keyname;\n+  private StyleConstants(String k) \n+  {\n+    keyname = k;\n+  }\n+\n+  public String toString()\n+  {\n+    return keyname;\n+  }\n+\n+  public static int ALIGN_CENTER;\n+  public static int ALIGN_JUSTIFIED;\n+  public static int ALIGN_LEFT;\n+  public static int ALIGN_RIGHT;\n+\n+  public static Object Background = CharacterConstants.Background;\n+  public static Object BidiLevel = CharacterConstants.BidiLevel;\n+  public static Object Bold = CharacterConstants.Bold;\n+  public static Object ComponentAttribute = CharacterConstants.ComponentAttribute;\n+  public static Object FontFamily = CharacterConstants.Family;\n+  public static Object FontSize = CharacterConstants.Size;\n+  public static Object Foreground = CharacterConstants.Foreground;\n+  public static Object IconAttribute = CharacterConstants.IconAttribute;\n+  public static Object Italic = CharacterConstants.Italic;\n+  public static Object StrikeThrough = CharacterConstants.StrikeThrough;\n+  public static Object Subscript = CharacterConstants.Subscript;\n+  public static Object Superscript = CharacterConstants.Superscript;\n+  public static Object Underline = CharacterConstants.Underline;\n+\n+  public static Object Alignment = ParagraphConstants.Alignment;\n+  public static Object FirstLineIndent = ParagraphConstants.FirstLineIndent;\n+  public static Object LeftIndent = ParagraphConstants.LeftIndent;\n+  public static Object LineSpacing = ParagraphConstants.LineSpacing;\n+  public static Object Orientation = ParagraphConstants.Orientation;\n+  public static Object RightIndent = ParagraphConstants.RightIndent;\n+  public static Object SpaceAbove = ParagraphConstants.SpaceAbove;\n+  public static Object SpaceBelow = ParagraphConstants.SpaceBelow;\n+  public static Object TabSet = ParagraphConstants.TabSet;\n+\n+  public static String ComponentElementName = new String(\"component\");\n+  public static String IconElementName = new String(\"icon\");\n+\n+  public static Object ComposedTextAttribute = new StyleConstants(\"composed text\");\n+  public static Object ModelAttribute = new StyleConstants(\"model\");\n+  public static Object NameAttribute = new StyleConstants(\"name\");\n+  public static Object ResolveAttribute = new StyleConstants(\"resolver\");\n+\n+  public static int getAlignment(AttributeSet a)\n+  {\n+    if (a.isDefined(Alignment))\n+      return ((Integer)a.getAttribute(Alignment)).intValue();\n+    else\n+      return ALIGN_LEFT;      \n+  } \n+\n+  public static Color getBackground(AttributeSet a)\n+  {\n+    if (a.isDefined(Background))\n+      return (Color) a.getAttribute(Background);\n+    else\n+      return Color.BLACK;\n+  } \n+  \n+  public static int getBidiLevel(AttributeSet a)\n+  {\n+    if (a.isDefined(BidiLevel))\n+      return ((Integer)a.getAttribute(BidiLevel)).intValue();\n+    else\n+      return 0;\n+  } \n+\n+  public static Component getComponent(AttributeSet a)\n+  {\n+    if (a.isDefined(ComponentAttribute))\n+      return (Component) a.getAttribute(ComponentAttribute);\n+    else\n+      return (Component) null;\n+  } \n+\n+  public static float getFirstLineIndent(AttributeSet a)\n+  {\n+    if (a.isDefined(FirstLineIndent))\n+      return ((Float)a.getAttribute(FirstLineIndent)).floatValue();\n+    else\n+      return 0.f;\n+  } \n+\n+  public static String getFontFamily(AttributeSet a)\n+  {\n+    if (a.isDefined(FontFamily))\n+      return (String) a.getAttribute(FontFamily);\n+    else\n+      return \"Monospaced\";\n+  } \n+\n+  public static int getFontSize(AttributeSet a)\n+  {\n+    if (a.isDefined(FontSize))\n+      return ((Integer)a.getAttribute(FontSize)).intValue();\n+    else\n+      return 12;\n+  } \n+\n+  public static Color getForeground(AttributeSet a)\n+  {\n+    if (a.isDefined(Foreground))\n+      return (Color) a.getAttribute(Foreground);\n+    else\n+      return Color.BLACK;\n+  } \n+\n+  public static Icon getIcon(AttributeSet a)\n+  {\n+    if (a.isDefined(IconAttribute))\n+      return (Icon) a.getAttribute(IconAttribute);\n+    else\n+      return (Icon) null;\n+  } \n+\n+  public static float getLeftIndent(AttributeSet a)\n+  {\n+    if (a.isDefined(LeftIndent))\n+      return ((Float)a.getAttribute(LeftIndent)).floatValue();\n+    else\n+      return 0.f;  \n+  } \n+\n+  public static float getLineSpacing(AttributeSet a)\n+  {\n+    if (a.isDefined(LineSpacing))\n+      return ((Float)a.getAttribute(LineSpacing)).floatValue();\n+    else\n+      return 0.f;  \n+  } \n+\n+  public static float getRightIndent(AttributeSet a)\n+  {\n+    if (a.isDefined(RightIndent))\n+      return ((Float)a.getAttribute(RightIndent)).floatValue();\n+    else\n+      return 0.f;  \n+  } \n+\n+  public static float getSpaceAbove(AttributeSet a)\n+  {\n+    if (a.isDefined(SpaceAbove))\n+      return ((Float)a.getAttribute(SpaceAbove)).floatValue();\n+    else\n+      return 0.f;  \n+  } \n+\n+  public static float getSpaceBelow(AttributeSet a)\n+  {\n+    if (a.isDefined(SpaceBelow))\n+      return ((Float)a.getAttribute(SpaceBelow)).floatValue();\n+    else\n+      return 0.f;  \n+  } \n+\n+  public static javax.swing.text.TabSet getTabSet(AttributeSet a)\n+  {\n+    if (a.isDefined(StyleConstants.TabSet))\n+      return (javax.swing.text.TabSet) a.getAttribute(StyleConstants.TabSet);\n+    else\n+      return (javax.swing.text.TabSet) null;\n+  } \n+\n+  public static boolean isBold(AttributeSet a)\n+  {\n+    if (a.isDefined(Bold))\n+      return ((Boolean) a.getAttribute(Bold)).booleanValue();\n+    else\n+      return false;    \n+  } \n+\n+  public static boolean isItalic(AttributeSet a)\n+  {\n+    if (a.isDefined(Italic))\n+      return ((Boolean) a.getAttribute(Italic)).booleanValue();\n+    else\n+      return false;    \n+  } \n+\n+  public static boolean isStrikeThrough(AttributeSet a)\n+  {\n+    if (a.isDefined(StrikeThrough))\n+      return ((Boolean) a.getAttribute(StrikeThrough)).booleanValue();\n+    else\n+      return false;    \n+  } \n+\n+  public static boolean isSubscript(AttributeSet a)\n+  {\n+    if (a.isDefined(Subscript))\n+      return ((Boolean) a.getAttribute(Subscript)).booleanValue();\n+    else\n+      return false;    \n+  } \n+\n+  public static boolean isSuperscript(AttributeSet a)\n+  {\n+    if (a.isDefined(Superscript))\n+      return ((Boolean) a.getAttribute(Superscript)).booleanValue();\n+    else\n+      return false;    \n+  } \n+\n+  public static boolean isUnderline(AttributeSet a)\n+  {\n+    if (a.isDefined(Underline))\n+      return ((Boolean) a.getAttribute(Underline)).booleanValue();\n+    else\n+      return false;    \n+  } \n+\n+  public static void setAlignment(MutableAttributeSet a, int align)\n+  {\n+    a.addAttribute(Alignment, new Integer(align));\n+  } \n+\n+  public static void setBackground(MutableAttributeSet a, Color fg)\n+  {\n+    a.addAttribute(Background, fg);\n+  } \n+\n+  public static void setBidiLevel(MutableAttributeSet a, int lev)\n+  {\n+    a.addAttribute(BidiLevel, new Integer(lev));\n+  } \n+\n+  public static void setBold(MutableAttributeSet a, boolean b)\n+  {\n+    a.addAttribute(Bold, new Boolean(b));\n+  } \n+  \n+  public static void setComponent(MutableAttributeSet a, Component c)\n+  {\n+    a.addAttribute(ComponentAttribute, c);\n+  } \n+\n+  public static void setFirstLineIndent(MutableAttributeSet a, float i)\n+  {\n+    a.addAttribute(FirstLineIndent, new Float(i));\n+  } \n+\n+  public static void setFontFamily(MutableAttributeSet a, String fam)\n+  {\n+    a.addAttribute(FontFamily, fam);\n+  } \n+\n+  public static void setFontSize(MutableAttributeSet a, int s)\n+  {\n+    a.addAttribute(FontSize, new Integer(s));\n+  } \n+\n+  public static void setForeground(MutableAttributeSet a, Color fg)\n+  {\n+    a.addAttribute(Foreground, fg);\n+  }\n+\n+  public static void setIcon(MutableAttributeSet a, Icon c)\n+  {\n+    a.addAttribute(IconAttribute, c);\n+  }\n+ \n+  public static void setItalic(MutableAttributeSet a, boolean b)\n+  {\n+    a.addAttribute(Italic, new Boolean(b));\n+  }\n+ \n+  public static void setLeftIndent(MutableAttributeSet a, float i)\n+  {\n+    a.addAttribute(LeftIndent, new Float(i));\n+  } \n+\n+  public static void setLineSpacing(MutableAttributeSet a, float i)\n+  {\n+    a.addAttribute(LineSpacing, new Float(i));\n+  } \n+\n+  public static void setRightIndent(MutableAttributeSet a, float i)\n+  {\n+    a.addAttribute(RightIndent, new Float(i));\n+  } \n+\n+  public static void setSpaceAbove(MutableAttributeSet a, float i)\n+  {\n+    a.addAttribute(SpaceAbove, new Float(i));\n+  } \n+\n+  public static void setSpaceBelow(MutableAttributeSet a, float i)\n+  {\n+    a.addAttribute(SpaceBelow, new Float(i));\n+  } \n+\n+  public static void setStrikeThrough(MutableAttributeSet a, boolean b)\n+  {\n+    a.addAttribute(StrikeThrough, new Boolean(b));\n+  } \n+\n+  public static void setSubscript(MutableAttributeSet a, boolean b)\n+  {\n+    a.addAttribute(Subscript, new Boolean(b));\n+  } \n+\n+  public static void setSuperscript(MutableAttributeSet a, boolean b)\n+  {\n+    a.addAttribute(Superscript, new Boolean(b));\n+  } \n+\n+  public static void setTabSet(MutableAttributeSet a, javax.swing.text.TabSet tabs)\n+  {\n+    a.addAttribute(StyleConstants.TabSet, tabs);\n+  } \n+\n+  public static void setUnderline(MutableAttributeSet a, boolean b)\n+  {\n+    a.addAttribute(Underline, new Boolean(b));\n+  } \n+\n+  // The remainder are so-called \"typesafe enumerations\" which \n+  // alias subsets of the above constants.\n+  public static class CharacterConstants\n+    extends StyleConstants\n+    implements AttributeSet.CharacterAttribute\n+  {\n+    private CharacterConstants(String k) \n+    {\n+      super(k);\n+    }\n+    \n+    public static Object Background = ColorConstants.Background;\n+    public static Object BidiLevel = new CharacterConstants(\"bidiLevel\");\n+    public static Object Bold = FontConstants.Bold;\n+    public static Object ComponentAttribute = new CharacterConstants(\"component\");\n+    public static Object Family = FontConstants.Family;\n+    public static Object Size = FontConstants.Size;\n+    public static Object Foreground = ColorConstants.Foreground;\n+    public static Object IconAttribute = new CharacterConstants(\"icon\");\n+    public static Object Italic = FontConstants.Italic;\n+    public static Object StrikeThrough = new CharacterConstants(\"strikethrough\");\n+    public static Object Subscript = new CharacterConstants(\"subscript\");\n+    public static Object Superscript = new CharacterConstants(\"superscript\");\n+    public static Object Underline = new CharacterConstants(\"underline\");\n+  }\n+\n+  public static class ColorConstants\n+    extends StyleConstants\n+    implements AttributeSet.ColorAttribute, AttributeSet.CharacterAttribute\n+  {\n+    private ColorConstants(String k) \n+    {\n+      super(k);\n+    }\n+    public static Object Foreground = new ColorConstants(\"foreground\");\n+    public static Object Background = new ColorConstants(\"background\");\n+  }\n+\n+  public static class FontConstants\n+    extends StyleConstants\n+    implements AttributeSet.FontAttribute, AttributeSet.CharacterAttribute\n+  {\n+    private FontConstants(String k) \n+    {\n+      super(k);\n+    }\n+    public static Object Bold = new FontConstants(\"bold\");\n+    public static Object Family = new FontConstants(\"family\");\n+    public static Object Italic = new FontConstants(\"italic\");\n+    public static Object Size = new FontConstants(\"size\");\n+  }\n+\n+  public static class ParagraphConstants\n+    extends StyleConstants\n+    implements AttributeSet.ParagraphAttribute\n+  {\n+    private ParagraphConstants(String k) \n+    {\n+      super(k);\n+    }\n+    public static Object Alignment = new ParagraphConstants(\"Alignment\");\n+    public static Object FirstLineIndent = new ParagraphConstants(\"FirstLineIndent\");\n+    public static Object LeftIndent = new ParagraphConstants(\"LeftIndent\");\n+    public static Object LineSpacing = new ParagraphConstants(\"LineSpacing\");\n+    public static Object Orientation = new ParagraphConstants(\"Orientation\");\n+    public static Object RightIndent = new ParagraphConstants(\"RightIndent\");\n+    public static Object SpaceAbove = new ParagraphConstants(\"SpaceAbove\");\n+    public static Object SpaceBelow = new ParagraphConstants(\"SpaceBelow\");\n+    public static Object TabSet = new ParagraphConstants(\"TabSet\");\n+  }\n+\n+}"}, {"sha": "8accd9b905bd91c519c1023051666dc87e32090c", "filename": "libjava/javax/swing/text/StyleContext.java", "status": "added", "additions": 697, "deletions": 0, "changes": 697, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Ftext%2FStyleContext.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Ftext%2FStyleContext.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FStyleContext.java?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,697 @@\n+/* StyleContext.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.text;\n+\n+import java.awt.Color;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Toolkit;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import javax.swing.event.EventListenerList;\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.Hashtable;\n+\n+public class StyleContext \n+    implements Serializable, AbstractDocument.AttributeContext\n+{\n+  public class NamedStyle\n+    implements Serializable, Style\n+  {\n+    protected ChangeEvent changeEvent;\n+    protected EventListenerList listenerList;\n+      \n+    AttributeSet attributes;\n+    String name;\n+\n+    public NamedStyle()\n+    {\n+      this(null, null);\n+    }\n+\n+    public NamedStyle(Style parent)\n+    {\n+      this(null, parent);\n+    }\n+\n+    public NamedStyle(String name, Style parent)\n+    {\n+      this.name = name;\n+      this.attributes = getEmptySet();\n+      this.changeEvent = new ChangeEvent(this);\n+      this.listenerList = new EventListenerList();\n+      setResolveParent(parent);\n+    }\n+\n+    public String getName()\n+    {\n+      return name;\n+    }\n+\n+    public void setName(String n)\n+    {\n+      name = n;\n+      fireStateChanged();\n+    }\n+\n+    public void addChangeListener(ChangeListener l)\n+    {\n+      listenerList.add(ChangeListener.class, l);\n+    }\n+      \n+    public void removeChangeListener(ChangeListener l)\n+    {\n+      listenerList.remove(ChangeListener.class, l);\n+    }\n+      \n+    public EventListener[] getListeners(Class listenerType)\n+    {\n+      return listenerList.getListeners(listenerType);\n+    }\n+\n+    public ChangeListener[] getChangeListeners()\n+    {\n+      return (ChangeListener[]) getListeners(ChangeListener.class);\n+    }\n+\n+    protected  void fireStateChanged()\n+    {\n+      ChangeListener[] listeners = getChangeListeners();\n+      for (int i = 0; i < listeners.length; ++i)\n+        {\n+          listeners[i].stateChanged(changeEvent);\n+        }\n+    }\n+\n+    public void addAttribute(Object name, Object value)\n+    {\n+      attributes = StyleContext.this.addAttribute(attributes, name, value);\n+      fireStateChanged();\n+    }\n+\n+    public void addAttributes(AttributeSet attr)\n+    {\n+      attributes = StyleContext.this.addAttributes(attributes, attr);\n+      fireStateChanged();\n+    }\n+\n+    public boolean containsAttribute(Object name, Object value)\n+    {\n+      return attributes.containsAttribute(name, value);\n+    }\n+      \n+    public boolean containsAttributes(AttributeSet attrs)\n+    {\n+      return attributes.containsAttributes(attrs);\n+    }\n+\n+    public AttributeSet copyAttributes()\n+    {\n+      return attributes.copyAttributes();\n+    }\n+            \n+    public Object getAttribute(Object attrName)\n+    {\n+      return attributes.getAttribute(attrName);\n+    }\n+\n+    public int getAttributeCount()\n+    {\n+      return attributes.getAttributeCount();\n+    }\n+\n+    public Enumeration getAttributeNames()\n+    {\n+      return attributes.getAttributeNames();\n+    }\n+      \n+    public boolean isDefined(Object attrName)\n+    {\n+      return attributes.isDefined(attrName);        \n+    }\n+\n+    public boolean isEqual(AttributeSet attr)\n+    {\n+      return attributes.isEqual(attr);\n+    }\n+\n+    public void removeAttribute(Object name)\n+    {\n+      attributes = StyleContext.this.removeAttribute(attributes, name);\n+      fireStateChanged();\n+    }\n+\n+    public void removeAttributes(AttributeSet attrs)\n+    {\n+      attributes = StyleContext.this.removeAttributes(attributes, attrs);\n+      fireStateChanged();\n+    }\n+\n+    public void removeAttributes(Enumeration names)\n+    {\n+      attributes = StyleContext.this.removeAttributes(attributes, names);\n+      fireStateChanged();\n+    }\n+\n+\n+    public AttributeSet getResolveParent()\n+    {\n+      return attributes.getResolveParent();        \n+    }\n+\n+    public void setResolveParent(AttributeSet parent)\n+    {\n+      attributes = StyleContext.this.addAttribute(attributes, ResolveAttribute, parent);\n+      fireStateChanged();\n+    }\n+      \n+    public String toString()\n+    {\n+      return (\"[NamedStyle: name=\" + name + \", attrs=\" + attributes.toString() + \"]\");\n+    }      \n+  }\n+  \n+  public class SmallAttributeSet\n+    implements AttributeSet\n+  {\n+    final Object [] attrs;\n+    public SmallAttributeSet(AttributeSet a)\n+    {\n+      if (a == null)\n+        attrs = new Object[0];\n+      else\n+        {\n+          int n = a.getAttributeCount();\n+          int i = 0;\n+          attrs = new Object[n * 2];\n+          Enumeration e = a.getAttributeNames();\n+          while (e.hasMoreElements())\n+            {\n+              Object name = e.nextElement();\n+              attrs[i++] = name;\n+              attrs[i++] = a.getAttribute(name);\n+            }\n+        }\n+    }\n+\n+    public SmallAttributeSet(Object [] a)\n+    {\n+      if (a == null)\n+        attrs = new Object[0];\n+      else\n+        {\n+          attrs = new Object[a.length];\n+          System.arraycopy(a, 0, attrs, 0, a.length);\n+        }\n+    }\n+\n+    public Object clone()\n+    {\n+      return new SmallAttributeSet(this.attrs);\n+    }\n+\n+    public boolean containsAttribute(Object name, Object value)\n+    {\n+      for (int i = 0; i < attrs.length; i += 2)\n+        {\n+          if (attrs[i].equals(name) &&\n+              attrs[i+1].equals(value))\n+            return true;\n+        }\n+      return false;\n+    }\n+\n+    public boolean containsAttributes(AttributeSet a)\n+    {\n+      Enumeration e = a.getAttributeNames();\n+      while (e.hasMoreElements())\n+        {\n+          Object name = e.nextElement();\n+          Object val = a.getAttribute(name);\n+          if (!containsAttribute(name, val))\n+            return false;\n+        }\n+      return true;\t\t\t\n+    }\n+\n+    public AttributeSet copyAttributes()\n+    {\n+      return (AttributeSet) clone();\n+    }\n+\n+    public boolean equals(Object obj)\n+    {\n+      return \n+        (obj instanceof SmallAttributeSet)\n+        && this.isEqual((AttributeSet)obj);\n+    }\n+ \n+    public Object getAttribute(Object key)\n+    {\n+      for (int i = 0; i < attrs.length; i += 2)\n+        {\n+          if (attrs[i].equals(key))\n+            return attrs[i+1];\n+        }\n+            \n+      Object p = getResolveParent();\n+      if (p != null && p instanceof AttributeSet)\n+        return (((AttributeSet)p).getAttribute(key));\n+      \n+      return null;\n+    }\n+\n+    public int getAttributeCount()\n+    {\n+      return attrs.length / 2;\n+    }\n+\n+    public Enumeration getAttributeNames()\n+    {      \n+      return new Enumeration() \n+        {\n+          int i = 0;\n+          public boolean hasMoreElements() \n+          { \n+            return i < attrs.length; \n+          }\n+          public Object nextElement() \n+          { \n+            i += 2; \n+            return attrs[i-2]; \n+          }\n+        };\n+    }\n+\n+    public AttributeSet getResolveParent()\n+    {\n+      return (AttributeSet) getAttribute(ResolveAttribute);\n+    }\n+\n+    public int hashCode()\n+    {\n+      return java.util.Arrays.asList(attrs).hashCode();\n+    }\n+\n+    public boolean isDefined(Object key)\n+    {\n+      for (int i = 0; i < attrs.length; i += 2)\n+        {\n+          if (attrs[i].equals(key))\n+            return true;\n+        }\n+      return false;\n+    }\n+\t\n+    public boolean isEqual(AttributeSet attr)\n+    {\n+      return attr != null \n+        && attr.containsAttributes(this)\n+        && this.containsAttributes(attr);\n+    }\n+\t\n+    public String toString()\n+    {\n+      StringBuffer sb = new StringBuffer();\n+      sb.append(\"[StyleContext.SmallattributeSet:\");\n+      for (int i = 0; i < attrs.length; ++i)\n+        {\n+          sb.append(\" (\");\n+          sb.append(attrs[i].toString());\n+          sb.append(\"=\");\n+          sb.append(attrs[i+1].toString());\n+          sb.append(\")\");\n+        }\n+      sb.append(\"]\");\n+      return sb.toString();\n+    }\n+  }\n+\n+  // FIXME: official javadocs suggest that these might be more usefully\n+  // implemented using a WeakHashMap, but not sure if that works most\n+  // places or whether it really matters anyways.\n+  //\n+  // FIXME: also not sure if these tables ought to be static (singletons),\n+  // shared across all StyleContexts. I think so, but it's not clear in\n+  // docs. revert to non-shared if you think it matters.\n+\n+  public static final String DEFAULT_STYLE = \"default\";\n+  \n+  static Hashtable sharedAttributeSets = new Hashtable();\n+  static Hashtable sharedFonts = new Hashtable();\n+\n+  static StyleContext defaultStyleContext = new StyleContext();\n+  static final int compressionThreshold = 9;\n+  \n+  EventListenerList listenerList;\n+  Hashtable styleTable;\n+  \n+  public StyleContext()\n+  {\n+    listenerList = new EventListenerList();\n+    styleTable = new Hashtable();\n+  }\n+\n+  protected SmallAttributeSet createSmallAttributeSet(AttributeSet a)\n+  {\n+    return new SmallAttributeSet(a);\n+  }\n+  \n+  protected MutableAttributeSet createLargeAttributeSet(AttributeSet a)\n+  {\n+    return new SimpleAttributeSet(a);\n+  }\n+\n+  public void addChangeListener(ChangeListener listener)\n+  {\n+    listenerList.add(ChangeListener.class, listener);\n+  }\n+\n+  public void removeChangeListener(ChangeListener listener)\n+  {\n+    listenerList.remove(ChangeListener.class, listener);\n+  }\n+\n+  public ChangeListener[] getChangeListeners()\n+  {\n+    return (ChangeListener[]) listenerList.getListeners(ChangeListener.class);\n+  }\n+    \n+  public Style addStyle(String name, Style parent)\n+  {\n+    Style newStyle = new NamedStyle(name, parent);\n+    if (name != null)\n+      styleTable.put(name, newStyle);\n+    return newStyle;\n+  }\n+\n+  public void removeStyle(String name)\n+  {\n+    styleTable.remove(name);\n+  }\n+\n+  public Style getStyle(String name)\n+  {\n+    return (Style) styleTable.get(name);\n+  }\n+\n+  public Enumeration getStyleNames()\n+  {\n+    return styleTable.keys();\n+  }\n+\n+  //\n+  // StyleContexts only understand the \"simple\" model of fonts present in\n+  // pre-java2d systems: fonts are a family name, a size (integral number\n+  // of points), and a mask of style parameters (plain, bold, italic, or\n+  // bold|italic). We have an inner class here called SimpleFontSpec which\n+  // holds such triples.\n+  //\n+  // A SimpleFontSpec can be built for *any* AttributeSet because the size,\n+  // family, and style keys in an AttributeSet have default values (defined\n+  // over in StyleConstants).\n+  //\n+  // We keep a static cache mapping SimpleFontSpecs to java.awt.Fonts, so\n+  // that we reuse Fonts between styles and style contexts.\n+  // \n+\n+  private static class SimpleFontSpec\n+  {\n+    String family;\n+    int style;\n+    int size;\n+    public SimpleFontSpec(String family,\n+                          int style,\n+                          int size)\n+    {\n+      this.family = family;\n+      this.style = style;\n+      this.size = size;\n+    }\n+    public boolean equals(Object obj)\n+    {\n+      return (obj != null)\n+        && (obj instanceof SimpleFontSpec)\n+        && (((SimpleFontSpec)obj).family.equals(this.family))\n+        && (((SimpleFontSpec)obj).style == this.style)\n+        && (((SimpleFontSpec)obj).size == this.size);\n+    }\n+    public int hashCode()\n+    {\n+      return family.hashCode() + style + size;\n+    }\n+  }\n+  \n+  public Font getFont(AttributeSet attr)\n+  {\n+    String family = StyleConstants.getFontFamily(attr);\n+    int style = Font.PLAIN;\n+    if (StyleConstants.isBold(attr))\n+      style += Font.BOLD;\n+    if (StyleConstants.isItalic(attr))\n+      style += Font.ITALIC;      \n+    int size = StyleConstants.getFontSize(attr);\n+    return getFont(family, style, size);\n+  }\n+\n+  public Font getFont(String family, int style, int size)\n+  {\n+    SimpleFontSpec spec = new SimpleFontSpec(family, style, size);\n+    if (sharedFonts.containsKey(spec))\n+      return (Font) sharedFonts.get(spec);\n+    else\n+      {\n+        Font tmp = new Font(family, style, size);\n+        sharedFonts.put(spec, tmp);\n+        return tmp;\n+      }\n+  }\n+  \n+  public FontMetrics getFontMetrics(Font f)\n+  {\n+    return Toolkit.getDefaultToolkit().getFontMetrics(f);\n+  }\n+\n+  public Color getForeground(AttributeSet a)\n+  {\n+    return StyleConstants.getForeground(a);\n+  }\n+\n+  public Color getBackground(AttributeSet a)\n+  {\n+    return StyleConstants.getBackground(a);\n+  }\n+\n+  protected int getCompressionThreshold() \n+  {\n+    return compressionThreshold;\n+  }\n+\n+  public static StyleContext getDefaultStyleContext()\n+  {\n+    return defaultStyleContext;\n+  }\n+\n+  public AttributeSet addAttribute(AttributeSet old, Object name, Object value)\n+  {\n+    if (old instanceof MutableAttributeSet)\n+      {\n+        ((MutableAttributeSet)old).addAttribute(name, value);\n+        return old;\n+      }\n+    else \n+      {\n+        MutableAttributeSet mutable = createLargeAttributeSet(old);\n+        mutable.addAttribute(name, value);\n+        if (mutable.getAttributeCount() >= getCompressionThreshold())\n+          return mutable;\n+        else\n+          {\n+            SmallAttributeSet small = createSmallAttributeSet(mutable);\n+            if (sharedAttributeSets.containsKey(small))\n+              small = (SmallAttributeSet) sharedAttributeSets.get(small);\n+            else\n+              sharedAttributeSets.put(small,small);\n+            return small;\n+          }\n+      }\n+  }\n+\n+  public AttributeSet addAttributes(AttributeSet old, AttributeSet attributes)\n+  {\n+    if (old instanceof MutableAttributeSet)\n+      {\n+        ((MutableAttributeSet)old).addAttributes(attributes);\n+        return old;\n+      }\n+    else \n+      {\n+        MutableAttributeSet mutable = createLargeAttributeSet(old);\n+        mutable.addAttributes(attributes);\n+        if (mutable.getAttributeCount() >= getCompressionThreshold())\n+          return mutable;\n+        else\n+          {\n+            SmallAttributeSet small = createSmallAttributeSet(mutable);\n+            if (sharedAttributeSets.containsKey(small))\n+              small = (SmallAttributeSet) sharedAttributeSets.get(small);\n+            else\n+              sharedAttributeSets.put(small,small);\n+            return small;\n+          }\n+      }\n+  }\n+\n+  public AttributeSet getEmptySet()\n+  {\n+    AttributeSet e = createSmallAttributeSet(null);\n+    if (sharedAttributeSets.containsKey(e))\n+      e = (AttributeSet) sharedAttributeSets.get(e);\n+    else\n+      sharedAttributeSets.put(e, e);\n+    return e;\n+  }\n+\n+  public void reclaim(AttributeSet attributes)\n+  {\n+    if (sharedAttributeSets.containsKey(attributes))\n+      sharedAttributeSets.remove(attributes);\n+  }\n+\n+  public AttributeSet removeAttribute(AttributeSet old, Object name)\n+  {\n+    if (old instanceof MutableAttributeSet)\n+      {\n+        ((MutableAttributeSet)old).removeAttribute(name);\n+        if (old.getAttributeCount() < getCompressionThreshold())\n+          {\n+            SmallAttributeSet small = createSmallAttributeSet(old);\n+            if (!sharedAttributeSets.containsKey(small))\n+              sharedAttributeSets.put(small,small);\n+            old = (AttributeSet) sharedAttributeSets.get(small);\n+          }\n+        return old;\n+      }\n+    else \n+      {          \n+        MutableAttributeSet mutable = createLargeAttributeSet(old);\n+        mutable.removeAttribute(name);\n+        SmallAttributeSet small = createSmallAttributeSet(mutable);\n+        if (sharedAttributeSets.containsKey(small))\n+          small = (SmallAttributeSet) sharedAttributeSets.get(small);\n+        else\n+          sharedAttributeSets.put(small,small);\n+        return small;\n+      }\n+  }\n+\n+  public AttributeSet removeAttributes(AttributeSet old, AttributeSet attributes)\n+  {\n+    return removeAttributes(old, attributes.getAttributeNames());\n+  }\n+\n+  public AttributeSet removeAttributes(AttributeSet old, Enumeration names)\n+  {\n+    if (old instanceof MutableAttributeSet)\n+      {\n+        ((MutableAttributeSet)old).removeAttributes(names);\n+        if (old.getAttributeCount() < getCompressionThreshold())\n+          {\n+            SmallAttributeSet small = createSmallAttributeSet(old);\n+            if (!sharedAttributeSets.containsKey(small))\n+              sharedAttributeSets.put(small,small);\n+            old = (AttributeSet) sharedAttributeSets.get(small);\n+          }\n+        return old;\n+      }\n+    else \n+      {          \n+        MutableAttributeSet mutable = createLargeAttributeSet(old);\n+        mutable.removeAttributes(names);\n+        SmallAttributeSet small = createSmallAttributeSet(mutable);\n+        if (sharedAttributeSets.containsKey(small))\n+          small = (SmallAttributeSet) sharedAttributeSets.get(small);\n+        else\n+          sharedAttributeSets.put(small,small);\n+        return small;\n+      }\t\n+  }\n+\n+\n+  // FIXME: there's some sort of quasi-serialization stuff in here which I\n+  // have left incomplete; I'm not sure I understand the intent properly.\n+\n+  public static Object getStaticAttribute(Object key)\n+  {\n+    throw new InternalError(\"not implemented\");\n+  }\n+  \n+  public static Object getStaticAttributeKey(Object key)\n+  {\n+    throw new InternalError(\"not implemented\");\n+  }\n+\n+  public static void readAttributeSet(ObjectInputStream in, MutableAttributeSet a)\n+    throws ClassNotFoundException, IOException\n+  {\n+    throw new InternalError(\"not implemented\");\n+  }\n+  \n+  public static void writeAttributeSet(ObjectOutputStream out, AttributeSet a)\n+    throws IOException\n+  {\n+    throw new InternalError(\"not implemented\");\n+  }\n+\n+  public void readAttributes(ObjectInputStream in, MutableAttributeSet a)\n+    throws ClassNotFoundException, IOException \n+  {\n+    throw new InternalError(\"not implemented\");\n+  }\n+\n+  public void writeAttributes(ObjectOutputStream out, AttributeSet a)\n+    throws IOException\n+  {\n+    throw new InternalError(\"not implemented\");\n+  }\n+}"}, {"sha": "58ae65ef096aa5be0b36278ec264d1b08c7cdb4a", "filename": "libjava/javax/swing/text/TabSet.java", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Ftext%2FTabSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Ftext%2FTabSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FTabSet.java?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,102 @@\n+/* TabSet.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.text;\n+\n+import java.io.Serializable;\n+\n+public class TabSet implements Serializable\n+{\n+  TabStop[] tabs;\n+\n+  public TabSet(TabStop[] t) \n+  {\n+    tabs = t;\n+  }\n+ \n+  public TabStop getTab(int i) \n+  {\n+    return tabs[i];\n+  }\n+\n+  public TabStop getTabAfter(float location) \n+  {\n+    int idx = getTabIndexAfter(location);\n+    if (idx == -1)\n+      return null;\n+    else\n+      return tabs[idx];        \n+  }\n+\n+  public int getTabCount() \n+  {\n+    return tabs.length;\n+  }\n+\n+  public int getTabIndex(TabStop tab) \n+  {\n+    for (int i = 0; i < tabs.length; ++i)\n+      if (tabs[i] == tab)\n+        return i;\n+    return -1;\n+  }\n+\n+  public int getTabIndexAfter(float location) \n+  {\n+    int idx = -1;\n+    for (int i = 0; i < tabs.length; ++i)\n+      {\n+        if (location < tabs[i].getPosition())\n+          idx = i;\n+      }\n+    return idx;\n+  }\n+\n+  public String toString()\n+  {\n+    StringBuffer sb = new StringBuffer();\n+    sb.append(\"[\");\n+    for (int i = 0; i < tabs.length; ++i)\n+      {\n+        if (i != 0)\n+          sb.append(\" - \");\n+        sb.append(tabs[i].toString());\n+      }\n+    sb.append(\"]\");\n+    return sb.toString();\n+  }\n+}"}, {"sha": "2c95a63e4b7f2a75b6e466f2611ca5b5ca6d66fc", "filename": "libjava/javax/swing/text/TabStop.java", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Ftext%2FTabStop.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Ftext%2FTabStop.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FTabStop.java?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,133 @@\n+/* TabSet.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.text;\n+\n+import java.io.Serializable;\n+\n+public class TabStop implements Serializable\n+{\n+  public static final int ALIGN_LEFT = 0;\n+  public static final int ALIGN_RIGHT = 1;\n+  public static final int ALIGN_CENTER = 2;\n+  public static final int ALIGN_DECIMAL = 4;\n+  public static final int ALIGN_BAR = 5;\n+\n+  public static final int LEAD_NONE = 0;\n+  public static final int LEAD_DOTS = 1;\n+  public static final int LEAD_HYPHENS = 2;\n+  public static final int LEAD_UNDERLINE = 3;\n+  public static final int LEAD_THICKLINE = 4;\n+  public static final int LEAD_EQUALS = 5;\n+\n+  float pos;\n+  int align;\n+  int leader;\n+\n+  public TabStop(float pos) \n+  {\n+    this(pos, ALIGN_LEFT, LEAD_NONE);\n+  }\n+  \n+  public TabStop(float pos, int align, int leader)\n+  {\n+    this.pos = pos;\n+    this.align = align;\n+    this.leader = leader;\n+  }\n+    \n+  public boolean equals(Object other) \n+  {\n+    return (other != null)\n+      && (other instanceof TabStop)\n+      && (((TabStop)other).getPosition() == this.getPosition())\n+      && (((TabStop)other).getLeader() == this.getLeader())\n+      && (((TabStop)other).getAlignment() == this.getAlignment());\n+  }\n+\n+  public int getAlignment() \n+  {\n+    return align;\n+  }\n+\n+  public int getLeader() \n+  {\n+    return leader;\n+  }\n+\n+  public float getPosition() \n+  {\n+    return pos;\n+  }\n+\n+  public int hashCode() \n+  {\n+    return (int) pos + (int) leader + (int) align;\n+  }\n+\n+  public String toString() \n+  {\n+    String prefix = \"\";\n+    switch (align)\n+      {\n+      case ALIGN_LEFT:\n+        prefix = \"left \";\n+        break;\n+      case ALIGN_RIGHT:\n+        prefix = \"right \";\n+        break;\n+\n+      case ALIGN_CENTER:\n+        prefix = \"center \";\n+        break;\n+\n+      case ALIGN_DECIMAL:\n+        prefix = \"decimal \";\n+        break;\n+        \n+      case ALIGN_BAR:\n+        prefix = \"bar \";\n+        break;\n+\n+      default:\n+        break;\n+      }\n+    \n+    return (prefix + \"tab @\" + pos + ((leader == LEAD_NONE) ? \"\" : \"(w/leaders)\"));\n+  }\n+\n+}"}, {"sha": "61c13eef509e10efb2d93dc146ef56676b30dddd", "filename": "libjava/javax/swing/text/Utilities.java", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Ftext%2FUtilities.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjavax%2Fswing%2Ftext%2FUtilities.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Ftext%2FUtilities.java?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,182 @@\n+/* Utilities.java --\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package javax.swing.text;\n+\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+\n+/**\n+ * A set of utilities to deal with text. This is used by several other classes\n+ * inside this package.\n+ *\n+ * @author Roman Kennke <roman@ontographics.com>\n+ */\n+public class Utilities\n+{\n+  /**\n+   * The length of the char buffer that holds the characters to be drawn.\n+   */\n+  private static final int BUF_LENGTH = 64;\n+\n+  /**\n+   * Creates a new <code>Utilities</code> object.\n+   */\n+  public Utilities()\n+  {\n+    // Nothing to be done here.\n+  }\n+\n+  /**\n+   * Draws the given text segment. Contained tabs and newline characters\n+   * are taken into account. Tabs are expanded using the\n+   * specified {@link TabExpander}.\n+   *\n+   * @param s the text fragment to be drawn.\n+   * @param x the x position for drawing.\n+   * @param y the y position for drawing.\n+   * @param g the {@link Graphics} context for drawing.\n+   * @param e the {@link TabExpander} which specifies the Tab-expanding\n+   *     technique.\n+   * @param startOffset starting offset in the text.\n+   * @return the x coordinate at the end of the drawn text.\n+   */\n+  public static final int drawTabbedText(Segment s, int x, int y, Graphics g,\n+                                         TabExpander e, int startOffset)\n+  {\n+    // This buffers the chars to be drawn.\n+    char[] buffer = s.array;\n+\n+\n+    // The current x and y pixel coordinates.\n+    int pixelX = x;\n+    int pixelY = y;\n+\n+    // The font metrics of the current selected font.\n+    FontMetrics metrics = g.getFontMetrics();\n+    int ascent = metrics.getAscent();\n+\n+    for (int offset = s.offset; offset < (s.offset + s.count); ++offset)\n+      {\n+\tswitch (buffer[offset])\n+\t  {\n+\t  case '\\t':\n+\t    // In case we have a tab, we just 'jump' over the tab.\n+\t    // When we have no tab expander we just use the width of 'm'.\n+\t    if (e != null)\n+\t      pixelX = (int) e.nextTabStop((float) pixelX,\n+\t\t\t\t\t   startOffset + offset - s.offset);\n+\t    else\n+\t      pixelX += metrics.charWidth(' ');\n+\t    break;\n+\t  case '\\n':\n+\t    // In case we have a newline, we must draw\n+\t    // the buffer and jump on the next line.\n+\t    g.drawChars(buffer, offset, 1, pixelX, y);\n+\t    pixelY += metrics.getHeight();\n+\t    pixelX = x;\n+\t    break;\n+\t  default:\n+\t    // Here we draw the char.\n+\t    g.drawChars(buffer, offset, 1, pixelX, pixelY + ascent);\n+\t    pixelX += metrics.charWidth(buffer[offset]);\n+\t    break;\n+\t  }\n+      }\n+\n+    return pixelX;\n+  }\n+\n+  /**\n+   * Determines the width, that the given text <code>s</code> would take\n+   * if it was printed with the given {@link java.awt.FontMetrics} on the\n+   * specified screen position.\n+   * @param s the text fragment\n+   * @param metrics the font metrics of the font to be used\n+   * @param x the x coordinate of the point at which drawing should be done\n+   * @param e the {@link TabExpander} to be used\n+   * @param startOffset the index in <code>s</code> where to start\n+   * @returns the width of the given text s. This takes tabs and newlines\n+   * into account.\n+   */\n+  public static final int getTabbedTextWidth(Segment s, FontMetrics metrics,\n+                                             int x, TabExpander e,\n+                                             int startOffset)\n+  {\n+    // This buffers the chars to be drawn.\n+    char[] buffer = s.array;\n+\n+    // The current x coordinate.\n+    int pixelX = x;\n+\n+    // The current maximum width.\n+    int maxWidth = 0;\n+\n+    for (int offset = s.offset; offset < (s.offset + s.count); ++offset)\n+      {\n+\tswitch (buffer[offset])\n+\t  {\n+\t  case '\\t':\n+\t    // In case we have a tab, we just 'jump' over the tab.\n+\t    // When we have no tab expander we just use the width of 'm'.\n+\t    if (e != null)\n+\t      pixelX = (int) e.nextTabStop((float) pixelX,\n+\t\t\t\t\t   startOffset + offset - s.offset);\n+\t    else\n+\t      pixelX += metrics.charWidth(' ');\n+\t    break;\n+\t  case '\\n':\n+\t    // In case we have a newline, we must 'draw'\n+\t    // the buffer and jump on the next line.\n+\t    pixelX += metrics.charWidth(buffer[offset]);\n+\t    maxWidth = Math.max(maxWidth, pixelX - x);\n+\t    pixelX = x;\n+\t    break;\n+\t  default:\n+\t    // Here we draw the char.\n+\t    pixelX += metrics.charWidth(buffer[offset]);\n+\t    break;\n+\t  }\n+      }\n+\n+    // Take the last line into account.\n+    maxWidth = Math.max(maxWidth, pixelX - x);\n+\n+    return maxWidth;\n+  }\n+}"}, {"sha": "44f2c3994383f2252fe1f33d549b39614216818f", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GThreadNativeMethodRunner.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GThreadNativeMethodRunner.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61341707b3db764c90f954097bf89b0811f92965/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GThreadNativeMethodRunner.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GThreadNativeMethodRunner.c?ref=61341707b3db764c90f954097bf89b0811f92965", "patch": "@@ -0,0 +1,68 @@\n+/* Native implementation of functions in GThreadNativeMethodRunner\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+#include \"gnu_java_awt_peer_gtk_GThreadNativeMethodRunner.h\"\n+#include \"gthread-jni.h\"\n+\n+/*\n+ * Class:     GThreadNativeMethodRunner\n+ * Method:    nativeRun\n+ * Signature: (J)V\n+ *\n+ * Purpose: Run the C function whose function pointer is\n+ * \n+ */\n+JNIEXPORT void JNICALL \n+Java_gnu_java_awt_peer_gtk_GThreadNativeMethodRunner_nativeRun(JNIEnv *gdk_env, jobject lcl_obj, \n+\t\t\t\t\t jlong funcAddr, jlong funcArg)\n+{\n+  /* Convert the function's address back into a pointer to a C function. */\n+  void *(*funcPtr)(void *) = (void *(*)(void *)) funcAddr;\n+  \n+  /* We do not need to worry about the return value from funcPtr(); it's\n+     just thrown away.  That is part of the g_threads spec, so no reason\n+     to worry about returning it.  */\n+  (void) funcPtr((void *) funcArg);\n+  /* Fall off the end and terminate the thread of control. */\n+}\n+\f\n+/* Local Variables: */\n+/* c-file-style: \"gnu\" */\n+/* End: */\n+\n+"}]}