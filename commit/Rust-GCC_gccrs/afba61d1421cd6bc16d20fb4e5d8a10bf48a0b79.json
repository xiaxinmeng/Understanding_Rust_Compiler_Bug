{"sha": "afba61d1421cd6bc16d20fb4e5d8a10bf48a0b79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWZiYTYxZDE0MjFjZDZiYzE2ZDIwZmI0ZTVkOGExMGJmNDhhMGI3OQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@cygnus.com", "date": "1997-12-19T16:55:53Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-12-19T16:55:53Z"}, "message": "* mips16.S: New file.\n\nFrom-SVN: r17157", "tree": {"sha": "e59a4ee5e3633c77e27680db1fc5687b3a1a6205", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e59a4ee5e3633c77e27680db1fc5687b3a1a6205"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/afba61d1421cd6bc16d20fb4e5d8a10bf48a0b79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afba61d1421cd6bc16d20fb4e5d8a10bf48a0b79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afba61d1421cd6bc16d20fb4e5d8a10bf48a0b79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afba61d1421cd6bc16d20fb4e5d8a10bf48a0b79/comments", "author": null, "committer": null, "parents": [{"sha": "6003a6bf7579b9e600e5ec539fad7a8122f98fac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6003a6bf7579b9e600e5ec539fad7a8122f98fac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6003a6bf7579b9e600e5ec539fad7a8122f98fac"}], "stats": {"total": 689, "additions": 689, "deletions": 0}, "files": [{"sha": "aed4461221c3d52fff117c08c668d2b2838c14cf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afba61d1421cd6bc16d20fb4e5d8a10bf48a0b79/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afba61d1421cd6bc16d20fb4e5d8a10bf48a0b79/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=afba61d1421cd6bc16d20fb4e5d8a10bf48a0b79", "patch": "@@ -1,5 +1,9 @@\n Fri Dec 19 17:31:11 1997  Ian Lance Taylor  <ian@cygnus.com>\n \n+        * mips16.S: New file.\n+\n+\t* libgcc2.c (varargs): Handle mips16.\n+\n \t* expr.c (do_tablejump): Let CASE_VECTOR_PC_RELATIVE be an\n \texpression.\n \t* stmt.c (expand_end_case): Likewise."}, {"sha": "eb4fe37fadc4bd9d0910cd1270e48c90fb713bc0", "filename": "gcc/config/mips/mips16.S", "status": "added", "additions": 685, "deletions": 0, "changes": 685, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afba61d1421cd6bc16d20fb4e5d8a10bf48a0b79/gcc%2Fconfig%2Fmips%2Fmips16.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afba61d1421cd6bc16d20fb4e5d8a10bf48a0b79/gcc%2Fconfig%2Fmips%2Fmips16.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips16.S?ref=afba61d1421cd6bc16d20fb4e5d8a10bf48a0b79", "patch": "@@ -0,0 +1,685 @@\n+/* mips16 floating point support code\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   Contributed by Cygnus Support\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file with other programs, and to distribute\n+those programs without any restriction coming from the use of this\n+file.  (The General Public License restrictions do apply in other\n+respects; for example, they cover modification of the file, and\n+distribution when not linked into another program.)\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with other files,\n+   some of which are compiled with GCC, to produce an executable,\n+   this library does not by itself cause the resulting executable\n+   to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+/* This file contains mips16 floating point support functions.  These\n+   functions are called by mips16 code to handle floating point when\n+   -msoft-float is not used.  They accept the arguments and return\n+   values using the soft-float calling convention, but do the actual\n+   operation using the hard floating point instructions.  */\n+\n+/* This file contains 32 bit assembly code.  */\n+\t.set nomips16\n+\n+/* Start a function. */\n+\n+#define STARTFN(NAME) .globl NAME; .ent NAME; NAME:\n+\n+/* Finish a function.  */\n+\n+#define ENDFN(NAME) .end NAME\n+\n+/* Single precision math.  */\n+\n+/* This macro defines a function which loads two single precision\n+   values, performs an operation, and returns the single precision\n+   result.  */\n+\n+#define SFOP(NAME, OPCODE)\t\\\n+STARTFN (NAME);\t\t\t\\\n+\t.set\tnoreorder;\t\\\n+\tmtc1\t$4,$f0;\t\t\\\n+\tmtc1\t$5,$f2;\t\t\\\n+\tnop;\t\t\t\\\n+\tOPCODE\t$f0,$f0,$f2;\t\\\n+\tmfc1\t$2,$f0;\t\t\\\n+\tj\t$31;\t\t\\\n+\tnop;\t\t\t\\\n+\t.set\treorder;\t\\\n+\tENDFN (NAME)\n+\n+#ifdef L_m16addsf3\n+SFOP(__mips16_addsf3, add.s)\n+#endif\n+#ifdef L_m16subsf3\n+SFOP(__mips16_subsf3, sub.s)\n+#endif\n+#ifdef L_m16mulsf3\n+SFOP(__mips16_mulsf3, mul.s)\n+#endif\n+#ifdef L_m16divsf3\n+SFOP(__mips16_divsf3, div.s)\n+#endif\n+\n+/* Single precision comparisons.  */\n+\n+/* This macro defines a function which loads two single precision\n+   values, performs a floating point comparison, and returns the\n+   specified values according to whether the comparison is true or\n+   false.  */\n+\n+#define SFCMP(NAME, OPCODE, TRUE, FALSE)\t\\\n+STARTFN (NAME);\t\t\t\t\t\\\n+\tmtc1\t$4,$f0;\t\t\t\t\\\n+\tmtc1\t$5,$f2;\t\t\t\t\\\n+\tOPCODE\t$f0,$f2;\t\t\t\\\n+\tli\t$2,TRUE;\t\t\t\\\n+\tbc1t\t1f;\t\t\t\t\\\n+\tli\t$2,FALSE;\t\t\t\\\n+1:;\t\t\t\t\t\t\\\n+\tj\t$31;\t\t\t\t\\\n+\tENDFN (NAME)\n+\n+/* This macro is like SFCMP, but it reverses the comparison.  */\n+\n+#define SFREVCMP(NAME, OPCODE, TRUE, FALSE)\t\\\n+STARTFN (NAME);\t\t\t\t\t\\\n+\tmtc1\t$4,$f0;\t\t\t\t\\\n+\tmtc1\t$5,$f2;\t\t\t\t\\\n+\tOPCODE\t$f2,$f0;\t\t\t\\\n+\tli\t$2,TRUE;\t\t\t\\\n+\tbc1t\t1f;\t\t\t\t\\\n+\tli\t$2,FALSE;\t\t\t\\\n+1:;\t\t\t\t\t\t\\\n+\tj\t$31;\t\t\t\t\\\n+\tENDFN (NAME)\n+\n+#ifdef L_m16eqsf2\n+SFCMP(__mips16_eqsf2, c.eq.s, 0, 1)\n+#endif\n+#ifdef L_m16nesf2\n+SFCMP(__mips16_nesf2, c.eq.s, 0, 1)\n+#endif\n+#ifdef L_m16gtsf2\n+SFREVCMP(__mips16_gtsf2, c.lt.s, 1, 0)\n+#endif\n+#ifdef L_m16gesf2\n+SFREVCMP(__mips16_gesf2, c.le.s, 0, -1)\n+#endif\n+#ifdef L_m16lesf2\n+SFCMP(__mips16_lesf2, c.le.s, 0, 1)\n+#endif\n+#ifdef L_m16ltsf2\n+SFCMP(__mips16_ltsf2, c.lt.s, -1, 0)\n+#endif\n+\n+/* Single precision conversions.  */\n+\n+#ifdef L_m16fltsisf\n+STARTFN (__mips16_floatsisf)\n+\t.set\tnoreorder\n+\tmtc1\t$4,$f0\n+\tnop\n+\tcvt.s.w\t$f0,$f0\n+\tmfc1\t$2,$f0\n+\tj\t$31\n+\tnop\n+\t.set\treorder\n+\tENDFN (__mips16_floatsisf)\n+#endif\n+\n+#ifdef L_m16fixsfsi\n+STARTFN (__mips16_fixsfsi)\n+\t.set\tnoreorder\n+\tmtc1\t$4,$f0\n+\tnop\n+\ttrunc.w.s $f0,$f0,$4\n+\tmfc1\t$2,$f0\n+\tj\t$31\n+\tnop\t\n+\t.set\treorder\n+\tENDFN (__mips16_fixsfsi)\n+#endif\n+\n+/* The double precision operations.  We need to use different code\n+   based on the preprocessor symbol __mips64, because the way in which\n+   double precision values will change.  Without __mips64, the value\n+   is passed in two 32 bit registers.  With __mips64, the value is\n+   passed in a single 64 bit register.  */\n+\n+/* Load the first double precision operand.  */\n+\n+#ifdef __mips64\n+#define LDDBL1 dmtc1 $4,$f0\n+#else\n+#define LDDBL1 mtc1 $4,$f1; mtc1 $5,$f0\n+#endif\n+\n+/* Load the second double precision operand.  */\n+\n+#ifdef __mips64\n+#define LDDBL2 dmtc1 $5,$f2\n+#else\n+#define LDDBL2 mtc1 $6,$f3; mtc1 $7,$f2\n+#endif\n+\n+/* Move the double precision return value to the right place.  */\n+\n+#ifdef __mips64\n+#define RETDBL dmfc1 $2,$f0\n+#else\n+#define RETDBL mfc1 $2,$f1; mfc1 $3,$f0\n+#endif\n+\n+/* Double precision math.  */\n+\n+/* This macro defines a function which loads two double precision\n+   values, performs an operation, and returns the double precision\n+   result.  */\n+\n+#define DFOP(NAME, OPCODE)\t\\\n+STARTFN (NAME);\t\t\t\\\n+\t.set\tnoreorder;\t\\\n+\tLDDBL1;\t\t\t\\\n+\tLDDBL2;\t\t\t\\\n+\tnop;\t\t\t\\\n+\tOPCODE\t$f0,$f0,$f2;\t\\\n+\tRETDBL;\t\t\t\\\n+\tj\t$31;\t\t\\\n+\tnop;\t\t\t\\\n+\t.set\treorder;\t\\\n+\tENDFN (NAME)\n+\n+#ifdef L_m16adddf3\n+DFOP(__mips16_adddf3, add.d)\n+#endif\n+#ifdef L_m16subdf3\n+DFOP(__mips16_subdf3, sub.d)\n+#endif\n+#ifdef L_m16muldf3\n+DFOP(__mips16_muldf3, mul.d)\n+#endif\n+#ifdef L_m16divdf3\n+DFOP(__mips16_divdf3, div.d)\n+#endif\n+\n+/* Conversions between single and double precision.  */\n+\n+#ifdef L_m16extsfdf2\n+STARTFN (__mips16_extendsfdf2)\n+\t.set\tnoreorder\n+\tmtc1\t$4,$f0\n+\tnop\n+\tcvt.d.s\t$f0,$f0\n+\tRETDBL\n+\tj\t$31\n+\tnop\n+\t.set\treorder\n+\tENDFN (__mips16_extendsfdf2)\n+#endif\n+\n+#ifdef L_m16trdfsf2\n+STARTFN (__mips16_truncdfsf2)\n+\t.set\tnoreorder\n+\tLDDBL1\n+\tnop\n+\tcvt.s.d\t$f0,$f0\n+\tmfc1\t$2,$f0\n+\tj\t$31\n+\tnop\n+\t.set\treorder\n+\tENDFN (__mips16_truncdfsf2)\n+#endif\n+\n+/* Double precision comparisons.  */\n+\n+/* This macro defines a function which loads two double precision\n+   values, performs a floating point comparison, and returns the\n+   specified values according to whether the comparison is true or\n+   false.  */\n+\n+#define DFCMP(NAME, OPCODE, TRUE, FALSE)\t\\\n+STARTFN (NAME);\t\t\t\t\t\\\n+\tLDDBL1;\t\t\t\t\t\\\n+\tLDDBL2;\t\t\t\t\t\\\n+\tOPCODE\t$f0,$f2;\t\t\t\\\n+\tli\t$2,TRUE;\t\t\t\\\n+\tbc1t\t1f;\t\t\t\t\\\n+\tli\t$2,FALSE;\t\t\t\\\n+1:;\t\t\t\t\t\t\\\n+\tj\t$31;\t\t\t\t\\\n+\tENDFN (NAME)\n+\n+/* This macro is like DFCMP, but it reverses the comparison.  */\n+\n+#define DFREVCMP(NAME, OPCODE, TRUE, FALSE)\t\\\n+STARTFN (NAME);\t\t\t\t\t\\\n+\tLDDBL1;\t\t\t\t\t\\\n+\tLDDBL2;\t\t\t\t\t\\\n+\tOPCODE\t$f2,$f0;\t\t\t\\\n+\tli\t$2,TRUE;\t\t\t\\\n+\tbc1t\t1f;\t\t\t\t\\\n+\tli\t$2,FALSE;\t\t\t\\\n+1:;\t\t\t\t\t\t\\\n+\tj\t$31;\t\t\t\t\\\n+\tENDFN (NAME)\n+\n+#ifdef L_m16eqdf2\n+DFCMP(__mips16_eqdf2, c.eq.d, 0, 1)\n+#endif\n+#ifdef L_m16nedf2\n+DFCMP(__mips16_nedf2, c.eq.d, 0, 1)\n+#endif\n+#ifdef L_m16gtdf2\n+DFREVCMP(__mips16_gtdf2, c.lt.d, 1, 0)\n+#endif\n+#ifdef L_m16gedf2\n+DFREVCMP(__mips16_gedf2, c.le.d, 0, -1)\n+#endif\n+#ifdef L_m16ledf2\n+DFCMP(__mips16_ledf2, c.le.d, 0, 1)\n+#endif\n+#ifdef L_m16ltdf2\n+DFCMP(__mips16_ltdf2, c.lt.d, -1, 0)\n+#endif\n+\n+/* Double precision conversions.  */\n+\n+#ifdef L_m16fltsidf\n+STARTFN (__mips16_floatsidf)\n+\t.set\tnoreorder\n+\tmtc1\t$4,$f0\n+\tnop\n+\tcvt.d.w\t$f0,$f0\n+\tRETDBL\n+\tj\t$31\n+\tnop\n+\t.set\treorder\n+\tENDFN (__mips16_floatsidf)\n+#endif\n+\n+#ifdef L_m16fixdfsi\n+STARTFN (__mips16_fixdfsi)\n+\t.set\tnoreorder\n+\tLDDBL1\n+\tnop\n+\ttrunc.w.d $f0,$f0,$4\n+\tmfc1\t$2,$f0\n+\tj\t$31\n+\tnop\n+\t.set\treorder\n+\tENDFN (__mips16_fixdfsi)\n+#endif\n+\n+/* These functions are used to return floating point values from\n+   mips16 functions which do not use -mentry.  In this case we can\n+   put mtc1 in a jump delay slot, because we know that the next\n+   instruction will not refer to a floating point register.  */\n+\n+#ifdef L_m16retsf\n+STARTFN (__mips16_ret_sf)\n+\t.set\tnoreorder\n+\tj\t$31\n+\tmtc1\t$2,$f0\n+\t.set\treorder\n+\tENDFN (__mips16_ret_sf)\n+#endif\n+\n+#ifdef L_m16retdf\n+STARTFN (__mips16_ret_df)\n+\t.set\tnoreorder\n+\tmtc1\t$2,$f1\n+\tj\t$31\n+\tmtc1\t$3,$f0\n+\tENDFN (__mips16_ret_df)\n+#endif\n+\n+/* These functions are used by 16 bit code when calling via a function\n+   pointer.  They must copy the floating point arguments from the gp\n+   regs into the fp regs.  The function to call will be in $2.  The\n+   exact set of floating point arguments to copy is encoded in the\n+   function name; the final number is an fp_code, as described in\n+   mips.h in the comment about CUMULATIVE_ARGS.  */\n+\n+#ifdef L_m16stub1\n+/* (float) */\n+STARTFN (__mips16_call_stub_1)\n+\t.set\tnoreorder\n+\tmtc1\t$4,$f12\n+\tj\t$2\n+\tnop\n+\t.set\treorder\n+\tENDFN (__mips16_call_stub_1)\n+#endif\n+\n+#ifdef L_m16stub2\n+/* (double) */\n+STARTFN (__mips16_call_stub_2)\n+\t.set\tnoreorder\n+\tmtc1\t$5,$f12\n+\tmtc1\t$4,$f13\n+\tj\t$2\n+\tnop\n+\t.set\treorder\n+\tENDFN (__mips16_call_stub_2)\n+#endif\n+\n+#ifdef L_m16stub5\n+/* (float, float) */\n+STARTFN (__mips16_call_stub_5)\n+\t.set\tnoreorder\n+\tmtc1\t$4,$f12\n+\tmtc1\t$5,$f14\n+\tj\t$2\n+\tnop\n+\t.set\treorder\n+\tENDFN (__mips16_call_stub_5)\n+#endif\n+\n+#ifdef L_m16stub6\n+/* (double, float) */\n+STARTFN (__mips16_call_stub_6)\n+\t.set\tnoreorder\n+\tmtc1\t$5,$f12\n+\tmtc1\t$4,$f13\n+\tmtc1\t$6,$f14\n+\tj\t$2\n+\tnop\n+\t.set\treorder\n+\tENDFN (__mips16_call_stub_6)\n+#endif\n+\n+#ifdef L_m16stub9\n+/* (float, double) */\n+STARTFN (__mips16_call_stub_9)\n+\t.set\tnoreorder\n+\tmtc1\t$4,$f12\n+\tmtc1\t$7,$f14\n+\tmtc1\t$6,$f15\n+\tj\t$2\n+\tnop\n+\t.set\treorder\n+\tENDFN (__mips16_call_stub_9)\n+#endif\n+\n+#ifdef L_m16stub10\n+/* (double, double) */\n+STARTFN (__mips16_call_stub_10)\n+\t.set\tnoreorder\n+\tmtc1\t$5,$f12\n+\tmtc1\t$4,$f13\n+\tmtc1\t$7,$f14\n+\tmtc1\t$6,$f15\n+\tj\t$2\n+\tnop\n+\t.set\treorder\n+\tENDFN (__mips16_call_stub_10)\n+#endif\n+\n+/* Now we have the same set of functions, except that this time the\n+   function being called returns an SFmode value.  The calling\n+   function will arrange to preserve $18, so these functions are free\n+   to use it to hold the return address.\n+\n+   Note that we do not know whether the function we are calling is 16\n+   bit or 32 bit.  However, it does not matter, because 16 bit\n+   functions always return floating point values in both the gp and\n+   the fp regs.  It would be possible to check whether the function\n+   being called is 16 bits, in which case the copy is unnecessary;\n+   however, it's faster to always do the copy.  */\n+\n+#ifdef L_m16stubsf0\n+/* () */\n+STARTFN (__mips16_call_stub_sf_0)\n+\t.set\tnoreorder\n+\tmove\t$18,$31\n+\tjal\t$2\n+\tnop\n+\tmfc1\t$4,$f0\n+\tj\t$18\n+\tnop\n+\t.set\treorder\n+\tENDFN (__mips16_call_stub_sf_0)\n+#endif\n+\n+#ifdef L_m16stubsf1\n+/* (float) */\n+STARTFN (__mips16_call_stub_sf_1)\n+\t.set\tnoreorder\n+\tmtc1\t$4,$f12\n+\tmove\t$18,$31\n+\tjal\t$2\n+\tnop\n+\tmfc1\t$4,$f0\n+\tj\t$18\n+\tnop\n+\t.set\treorder\n+\tENDFN (__mips16_call_stub_sf_1)\n+#endif\n+\n+#ifdef L_m16stubsf2\n+/* (double) */\n+STARTFN (__mips16_call_stub_sf_2)\n+\t.set\tnoreorder\n+\tmtc1\t$5,$f12\n+\tmtc1\t$4,$f13\n+\tmove\t$18,$31\n+\tjal\t$2\n+\tnop\n+\tmfc1\t$4,$f0\n+\tj\t$18\n+\tnop\n+\t.set\treorder\n+\tENDFN (__mips16_call_stub_sf_2)\n+#endif\n+\n+#ifdef L_m16stubsf5\n+/* (float, float) */\n+STARTFN (__mips16_call_stub_sf_5)\n+\t.set\tnoreorder\n+\tmtc1\t$4,$f12\n+\tmtc1\t$5,$f14\n+\tmove\t$18,$31\n+\tjal\t$2\n+\tnop\n+\tmfc1\t$4,$f0\n+\tj\t$18\n+\tnop\n+\t.set\treorder\n+\tENDFN (__mips16_call_stub_sf_5)\n+#endif\n+\n+#ifdef L_m16stubsf6\n+/* (double, float) */\n+STARTFN (__mips16_call_stub_sf_6)\n+\t.set\tnoreorder\n+\tmtc1\t$5,$f12\n+\tmtc1\t$4,$f13\n+\tmtc1\t$6,$f14\n+\tmove\t$18,$31\n+\tjal\t$2\n+\tnop\n+\tmfc1\t$4,$f0\n+\tj\t$18\n+\tnop\n+\t.set\treorder\n+\tENDFN (__mips16_call_stub_sf_6)\n+#endif\n+\n+#ifdef L_m16stubsf9\n+/* (float, double) */\n+STARTFN (__mips16_call_stub_sf_9)\n+\t.set\tnoreorder\n+\tmtc1\t$4,$f12\n+\tmtc1\t$7,$f14\n+\tmtc1\t$6,$f15\n+\tmove\t$18,$31\n+\tjal\t$2\n+\tnop\n+\tmfc1\t$4,$f0\n+\tj\t$18\n+\tnop\n+\t.set\treorder\n+\tENDFN (__mips16_call_stub_sf_9)\n+#endif\n+\n+#ifdef L_m16stubsf10\n+/* (double, double) */\n+STARTFN (__mips16_call_stub_sf_10)\n+\t.set\tnoreorder\n+\tmtc1\t$5,$f12\n+\tmtc1\t$4,$f13\n+\tmtc1\t$7,$f14\n+\tmtc1\t$6,$f15\n+\tmove\t$18,$31\n+\tjal\t$2\n+\tnop\n+\tmfc1\t$4,$f0\n+\tj\t$18\n+\tnop\n+\t.set\treorder\n+\tENDFN (__mips16_call_stub_sf_10)\n+#endif\n+\n+/* Now we have the same set of functions again, except that this time\n+   the function being called returns an DFmode value.  */\n+\n+#ifdef L_m16stubdf0\n+/* () */\n+STARTFN (__mips16_call_stub_df_0)\n+\t.set\tnoreorder\n+\tmove\t$18,$31\n+\tjal\t$2\n+\tnop\n+\tmfc1\t$5,$f0\n+\tmfc1\t$4,$f1\n+\tj\t$18\n+\tnop\n+\t.set\treorder\n+\tENDFN (__mips16_call_stub_df_0)\n+#endif\n+\n+#ifdef L_m16stubdf1\n+/* (float) */\n+STARTFN (__mips16_call_stub_df_1)\n+\t.set\tnoreorder\n+\tmtc1\t$4,$f12\n+\tmove\t$18,$31\n+\tjal\t$2\n+\tnop\n+\tmfc1\t$5,$f0\n+\tmfc1\t$4,$f1\n+\tj\t$18\n+\tnop\n+\t.set\treorder\n+\tENDFN (__mips16_call_stub_df_1)\n+#endif\n+\n+#ifdef L_m16stubdf2\n+/* (double) */\n+STARTFN (__mips16_call_stub_df_2)\n+\t.set\tnoreorder\n+\tmtc1\t$5,$f12\n+\tmtc1\t$4,$f13\n+\tmove\t$18,$31\n+\tjal\t$2\n+\tnop\n+\tmfc1\t$5,$f0\n+\tmfc1\t$4,$f1\n+\tj\t$18\n+\tnop\n+\t.set\treorder\n+\tENDFN (__mips16_call_stub_df_2)\n+#endif\n+\n+#ifdef L_m16stubdf5\n+/* (float, float) */\n+STARTFN (__mips16_call_stub_df_5)\n+\t.set\tnoreorder\n+\tmtc1\t$4,$f12\n+\tmtc1\t$5,$f14\n+\tmove\t$18,$31\n+\tjal\t$2\n+\tnop\n+\tmfc1\t$5,$f0\n+\tmfc1\t$4,$f1\n+\tj\t$18\n+\tnop\n+\t.set\treorder\n+\tENDFN (__mips16_call_stub_df_5)\n+#endif\n+\n+#ifdef L_m16stubdf6\n+/* (double, float) */\n+STARTFN (__mips16_call_stub_df_6)\n+\t.set\tnoreorder\n+\tmtc1\t$5,$f12\n+\tmtc1\t$4,$f13\n+\tmtc1\t$6,$f14\n+\tmove\t$18,$31\n+\tjal\t$2\n+\tnop\n+\tmfc1\t$5,$f0\n+\tmfc1\t$4,$f1\n+\tj\t$18\n+\tnop\n+\t.set\treorder\n+\tENDFN (__mips16_call_stub_df_6)\n+#endif\n+\n+#ifdef L_m16stubdf9\n+/* (float, double) */\n+STARTFN (__mips16_call_stub_df_9)\n+\t.set\tnoreorder\n+\tmtc1\t$4,$f12\n+\tmtc1\t$7,$f14\n+\tmtc1\t$6,$f15\n+\tmove\t$18,$31\n+\tjal\t$2\n+\tnop\n+\tmfc1\t$5,$f0\n+\tmfc1\t$4,$f1\n+\tj\t$18\n+\tnop\n+\t.set\treorder\n+\tENDFN (__mips16_call_stub_df_9)\n+#endif\n+\n+#ifdef L_m16stubdf10\n+/* (double, double) */\n+STARTFN (__mips16_call_stub_df_10)\n+\t.set\tnoreorder\n+\tmtc1\t$5,$f12\n+\tmtc1\t$4,$f13\n+\tmtc1\t$7,$f14\n+\tmtc1\t$6,$f15\n+\tmove\t$18,$31\n+\tjal\t$2\n+\tnop\n+\tmfc1\t$5,$f0\n+\tmfc1\t$4,$f1\n+\tj\t$18\n+\tnop\n+\t.set\treorder\n+\tENDFN (__mips16_call_stub_df_10)\n+#endif"}]}