{"sha": "5fb79e4c29afffae11b32f374ee8b120264305e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZiNzllNGMyOWFmZmZhZTExYjMyZjM3NGVlOGIxMjAyNjQzMDVlOQ==", "commit": {"author": {"name": "Adam Nemet", "email": "anemet@caviumnetworks.com", "date": "2008-04-10T18:28:45Z"}, "committer": {"name": "Adam Nemet", "email": "nemet@gcc.gnu.org", "date": "2008-04-10T18:28:45Z"}, "message": "mips.md (GPR2): New mode iterator.\n\n\t* config/mips/mips.md (GPR2): New mode iterator.\n\t(seq): Add comment.\n\t(*seq_<mode>, *seq_<mode>_mips16, *sne_<mode>, *sgt<u>_<mode>,\n\t*sgt<u>_<mode>_mips16, *sge<u>_<mode>, *slt<u>_<mode>,\n\t*slt<u>_<mode>_mips16 *sle<u>_<mode>, *sle<u>_<mode>_mips16):\n\tRewrite these to take two modes, the mode of comparison and the\n\tmode of the destination.\n\t* config/mips/mips.c (mips_expand_scc): Instead of having\n\tparadoxical subreg as destination, expand \"narrowing\" scc if mode\n\tof comparison is SI and target is requested in DI mode.\n\t(mips_emit_int_order_test): Update comment.  Make mode of\n\tcomparison match CMP0 rather than TARGET.  When creating inverse\n\ttarget use mode of TARGET.\n\ntestsuite/\n\n\t* gcc.target/mips/scc-2.c: New test.\n\t* gcc.target/mips/scc-3.c: New test.\n\t* gcc.target/mips/scc-4.c: New test.\n\nFrom-SVN: r134167", "tree": {"sha": "cfc57e17ab56b580908b71d4f44b183d01ef784c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cfc57e17ab56b580908b71d4f44b183d01ef784c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5fb79e4c29afffae11b32f374ee8b120264305e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fb79e4c29afffae11b32f374ee8b120264305e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fb79e4c29afffae11b32f374ee8b120264305e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fb79e4c29afffae11b32f374ee8b120264305e9/comments", "author": null, "committer": null, "parents": [{"sha": "63d628b2fe6292f5a67eb68ede05b14d52dd4265", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63d628b2fe6292f5a67eb68ede05b14d52dd4265", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63d628b2fe6292f5a67eb68ede05b14d52dd4265"}], "stats": {"total": 188, "additions": 131, "deletions": 57}, "files": [{"sha": "d2599353201cc12f64490447d833d28439be67de", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fb79e4c29afffae11b32f374ee8b120264305e9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fb79e4c29afffae11b32f374ee8b120264305e9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5fb79e4c29afffae11b32f374ee8b120264305e9", "patch": "@@ -1,3 +1,19 @@\n+2008-04-10  Adam Nemet  <anemet@caviumnetworks.com>\n+\n+\t* config/mips/mips.md (GPR2): New mode iterator.\n+\t(seq): Add comment.\n+\t(*seq_<mode>, *seq_<mode>_mips16, *sne_<mode>, *sgt<u>_<mode>,\n+\t*sgt<u>_<mode>_mips16, *sge<u>_<mode>, *slt<u>_<mode>,\n+\t*slt<u>_<mode>_mips16 *sle<u>_<mode>, *sle<u>_<mode>_mips16):\n+\tRewrite these to take two modes, the mode of comparison and the\n+\tmode of the destination.\n+\t* config/mips/mips.c (mips_expand_scc): Instead of having\n+\tparadoxical subreg as destination, expand \"narrowing\" scc if mode\n+\tof comparison is SI and target is requested in DI mode.\n+\t(mips_emit_int_order_test): Update comment.  Make mode of\n+\tcomparison match CMP0 rather than TARGET.  When creating inverse\n+\ttarget use mode of TARGET.\n+\n 2008-04-10  Adam Nemet  <anemet@caviumnetworks.com>\n \n \t* gcov-dump.c (tag_summary): Only print summaries for the first"}, {"sha": "d69169f13a748e977713c3071120c23ea405d931", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fb79e4c29afffae11b32f374ee8b120264305e9/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fb79e4c29afffae11b32f374ee8b120264305e9/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=5fb79e4c29afffae11b32f374ee8b120264305e9", "patch": "@@ -3715,9 +3715,9 @@ mips_canonicalize_int_order_test (enum rtx_code *code, rtx *cmp1,\n }\n \n /* Compare CMP0 and CMP1 using ordering test CODE and store the result\n-   in TARGET.  CMP0 and TARGET are register_operands that have the same\n-   integer mode.  If INVERT_PTR is nonnull, it's OK to set TARGET to the\n-   inverse of the result and flip *INVERT_PTR instead.  */\n+   in TARGET.  CMP0 and TARGET are register_operands.  If INVERT_PTR\n+   is nonnull, it's OK to set TARGET to the inverse of the result and\n+   flip *INVERT_PTR instead.  */\n \n static void\n mips_emit_int_order_test (enum rtx_code code, bool *invert_ptr,\n@@ -3728,7 +3728,7 @@ mips_emit_int_order_test (enum rtx_code code, bool *invert_ptr,\n   /* First see if there is a MIPS instruction that can do this operation.\n      If not, try doing the same for the inverse operation.  If that also\n      fails, force CMP1 into a register and try again.  */\n-  mode = GET_MODE (target);\n+  mode = GET_MODE (cmp0);\n   if (mips_canonicalize_int_order_test (&code, &cmp1, mode))\n     mips_emit_binary (code, target, cmp0, cmp1);\n   else\n@@ -3741,7 +3741,7 @@ mips_emit_int_order_test (enum rtx_code code, bool *invert_ptr,\n \t}\n       else if (invert_ptr == 0)\n \t{\n-\t  rtx inv_target = gen_reg_rtx (mode);\n+\t  rtx inv_target = gen_reg_rtx (GET_MODE (target));\n \t  mips_emit_binary (inv_code, inv_target, cmp0, cmp1);\n \t  mips_emit_binary (XOR, target, inv_target, const1_rtx);\n \t}\n@@ -3868,15 +3868,14 @@ mips_emit_compare (enum rtx_code *code, rtx *op0, rtx *op1, bool need_eq_ne_p)\n /* Try comparing cmp_operands[0] and cmp_operands[1] using rtl code CODE.\n    Store the result in TARGET and return true if successful.\n \n-   On 64-bit targets, TARGET may be wider than cmp_operands[0].  */\n+   On 64-bit targets, TARGET may be narrower than cmp_operands[0].  */\n \n bool\n mips_expand_scc (enum rtx_code code, rtx target)\n {\n   if (GET_MODE_CLASS (GET_MODE (cmp_operands[0])) != MODE_INT)\n     return false;\n \n-  target = gen_lowpart (GET_MODE (cmp_operands[0]), target);\n   if (code == EQ || code == NE)\n     {\n       rtx zie = mips_zero_if_equal (cmp_operands[0], cmp_operands[1]);"}, {"sha": "cbdcdc6ed13193334b3b330e26fb0e9e709ea504", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 56, "deletions": 50, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fb79e4c29afffae11b32f374ee8b120264305e9/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fb79e4c29afffae11b32f374ee8b120264305e9/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=5fb79e4c29afffae11b32f374ee8b120264305e9", "patch": "@@ -476,6 +476,10 @@\n ;; from the same template.\n (define_mode_iterator GPR [SI (DI \"TARGET_64BIT\")])\n \n+;; A copy of GPR that can be used when a pattern has two independent\n+;; modes.\n+(define_mode_iterator GPR2 [SI (DI \"TARGET_64BIT\")])\n+\n ;; This mode iterator allows :P to be used for patterns that operate on\n ;; pointer-sized quantities.  Exactly one of the two alternatives will match.\n (define_mode_iterator P [(SI \"Pmode == SImode\") (DI \"Pmode == DImode\")])\n@@ -5065,30 +5069,32 @@\n ;;\n ;;  ....................\n \n+;; Destination is always set in SI mode.\n+\n (define_expand \"seq\"\n   [(set (match_operand:SI 0 \"register_operand\")\n \t(eq:SI (match_dup 1)\n \t       (match_dup 2)))]\n   \"\"\n   { if (mips_expand_scc (EQ, operands[0])) DONE; else FAIL; })\n \n-(define_insn \"*seq_<mode>\"\n-  [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n-\t(eq:GPR (match_operand:GPR 1 \"register_operand\" \"d\")\n-\t\t(const_int 0)))]\n+(define_insn \"*seq_<GPR:mode><GPR2:mode>\"\n+  [(set (match_operand:GPR2 0 \"register_operand\" \"=d\")\n+\t(eq:GPR2 (match_operand:GPR 1 \"register_operand\" \"d\")\n+\t\t (const_int 0)))]\n   \"!TARGET_MIPS16\"\n   \"sltu\\t%0,%1,1\"\n   [(set_attr \"type\" \"slt\")\n-   (set_attr \"mode\" \"<MODE>\")])\n+   (set_attr \"mode\" \"<GPR:MODE>\")])\n \n-(define_insn \"*seq_<mode>_mips16\"\n-  [(set (match_operand:GPR 0 \"register_operand\" \"=t\")\n-\t(eq:GPR (match_operand:GPR 1 \"register_operand\" \"d\")\n-\t\t(const_int 0)))]\n+(define_insn \"*seq_<GPR:mode><GPR2:mode>_mips16\"\n+  [(set (match_operand:GPR2 0 \"register_operand\" \"=t\")\n+\t(eq:GPR2 (match_operand:GPR 1 \"register_operand\" \"d\")\n+\t\t (const_int 0)))]\n   \"TARGET_MIPS16\"\n   \"sltu\\t%1,1\"\n   [(set_attr \"type\" \"slt\")\n-   (set_attr \"mode\" \"<MODE>\")])\n+   (set_attr \"mode\" \"<GPR:MODE>\")])\n \n ;; \"sne\" uses sltu instructions in which the first operand is $0.\n ;; This isn't possible in mips16 code.\n@@ -5100,14 +5106,14 @@\n   \"!TARGET_MIPS16\"\n   { if (mips_expand_scc (NE, operands[0])) DONE; else FAIL; })\n \n-(define_insn \"*sne_<mode>\"\n-  [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n-\t(ne:GPR (match_operand:GPR 1 \"register_operand\" \"d\")\n-\t\t(const_int 0)))]\n+(define_insn \"*sne_<GPR:mode><GPR2:mode>\"\n+  [(set (match_operand:GPR2 0 \"register_operand\" \"=d\")\n+\t(ne:GPR2 (match_operand:GPR 1 \"register_operand\" \"d\")\n+\t\t (const_int 0)))]\n   \"!TARGET_MIPS16\"\n   \"sltu\\t%0,%.,%1\"\n   [(set_attr \"type\" \"slt\")\n-   (set_attr \"mode\" \"<MODE>\")])\n+   (set_attr \"mode\" \"<GPR:MODE>\")])\n \n (define_expand \"sgt<u>\"\n   [(set (match_operand:SI 0 \"register_operand\")\n@@ -5116,23 +5122,23 @@\n   \"\"\n   { if (mips_expand_scc (<CODE>, operands[0])) DONE; else FAIL; })\n \n-(define_insn \"*sgt<u>_<mode>\"\n-  [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n-\t(any_gt:GPR (match_operand:GPR 1 \"register_operand\" \"d\")\n-\t\t    (match_operand:GPR 2 \"reg_or_0_operand\" \"dJ\")))]\n+(define_insn \"*sgt<u>_<GPR:mode><GPR2:mode>\"\n+  [(set (match_operand:GPR2 0 \"register_operand\" \"=d\")\n+\t(any_gt:GPR2 (match_operand:GPR 1 \"register_operand\" \"d\")\n+\t\t     (match_operand:GPR 2 \"reg_or_0_operand\" \"dJ\")))]\n   \"!TARGET_MIPS16\"\n   \"slt<u>\\t%0,%z2,%1\"\n   [(set_attr \"type\" \"slt\")\n-   (set_attr \"mode\" \"<MODE>\")])\n+   (set_attr \"mode\" \"<GPR:MODE>\")])\n \n-(define_insn \"*sgt<u>_<mode>_mips16\"\n-  [(set (match_operand:GPR 0 \"register_operand\" \"=t\")\n-\t(any_gt:GPR (match_operand:GPR 1 \"register_operand\" \"d\")\n-\t\t    (match_operand:GPR 2 \"register_operand\" \"d\")))]\n+(define_insn \"*sgt<u>_<GPR:mode><GPR2:mode>_mips16\"\n+  [(set (match_operand:GPR2 0 \"register_operand\" \"=t\")\n+\t(any_gt:GPR2 (match_operand:GPR 1 \"register_operand\" \"d\")\n+\t\t     (match_operand:GPR 2 \"register_operand\" \"d\")))]\n   \"TARGET_MIPS16\"\n   \"slt<u>\\t%2,%1\"\n   [(set_attr \"type\" \"slt\")\n-   (set_attr \"mode\" \"<MODE>\")])\n+   (set_attr \"mode\" \"<GPR:MODE>\")])\n \n (define_expand \"sge<u>\"\n   [(set (match_operand:SI 0 \"register_operand\")\n@@ -5141,14 +5147,14 @@\n   \"\"\n   { if (mips_expand_scc (<CODE>, operands[0])) DONE; else FAIL; })\n \n-(define_insn \"*sge<u>_<mode>\"\n-  [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n-\t(any_ge:GPR (match_operand:GPR 1 \"register_operand\" \"d\")\n-\t\t    (const_int 1)))]\n+(define_insn \"*sge<u>_<GPR:mode><GPR2:mode>\"\n+  [(set (match_operand:GPR2 0 \"register_operand\" \"=d\")\n+\t(any_ge:GPR2 (match_operand:GPR 1 \"register_operand\" \"d\")\n+\t\t     (const_int 1)))]\n   \"!TARGET_MIPS16\"\n   \"slt<u>\\t%0,%.,%1\"\n   [(set_attr \"type\" \"slt\")\n-   (set_attr \"mode\" \"<MODE>\")])\n+   (set_attr \"mode\" \"<GPR:MODE>\")])\n \n (define_expand \"slt<u>\"\n   [(set (match_operand:SI 0 \"register_operand\")\n@@ -5157,23 +5163,23 @@\n   \"\"\n   { if (mips_expand_scc (<CODE>, operands[0])) DONE; else FAIL; })\n \n-(define_insn \"*slt<u>_<mode>\"\n-  [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n-\t(any_lt:GPR (match_operand:GPR 1 \"register_operand\" \"d\")\n-\t\t    (match_operand:GPR 2 \"arith_operand\" \"dI\")))]\n+(define_insn \"*slt<u>_<GPR:mode><GPR2:mode>\"\n+  [(set (match_operand:GPR2 0 \"register_operand\" \"=d\")\n+\t(any_lt:GPR2 (match_operand:GPR 1 \"register_operand\" \"d\")\n+\t\t     (match_operand:GPR 2 \"arith_operand\" \"dI\")))]\n   \"!TARGET_MIPS16\"\n   \"slt<u>\\t%0,%1,%2\"\n   [(set_attr \"type\" \"slt\")\n-   (set_attr \"mode\" \"<MODE>\")])\n+   (set_attr \"mode\" \"<GPR:MODE>\")])\n \n-(define_insn \"*slt<u>_<mode>_mips16\"\n-  [(set (match_operand:GPR 0 \"register_operand\" \"=t,t\")\n-\t(any_lt:GPR (match_operand:GPR 1 \"register_operand\" \"d,d\")\n-\t\t    (match_operand:GPR 2 \"arith_operand\" \"d,I\")))]\n+(define_insn \"*slt<u>_<GPR:mode><GPR2:mode>_mips16\"\n+  [(set (match_operand:GPR2 0 \"register_operand\" \"=t,t\")\n+\t(any_lt:GPR2 (match_operand:GPR 1 \"register_operand\" \"d,d\")\n+\t\t     (match_operand:GPR 2 \"arith_operand\" \"d,I\")))]\n   \"TARGET_MIPS16\"\n   \"slt<u>\\t%1,%2\"\n   [(set_attr \"type\" \"slt\")\n-   (set_attr \"mode\" \"<MODE>\")\n+   (set_attr \"mode\" \"<GPR:MODE>\")\n    (set_attr_alternative \"length\"\n \t\t[(const_int 4)\n \t\t (if_then_else (match_operand 2 \"m16_uimm8_1\")\n@@ -5187,29 +5193,29 @@\n   \"\"\n   { if (mips_expand_scc (<CODE>, operands[0])) DONE; else FAIL; })\n \n-(define_insn \"*sle<u>_<mode>\"\n-  [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n-\t(any_le:GPR (match_operand:GPR 1 \"register_operand\" \"d\")\n-\t\t    (match_operand:GPR 2 \"sle_operand\" \"\")))]\n+(define_insn \"*sle<u>_<GPR:mode><GPR2:mode>\"\n+  [(set (match_operand:GPR2 0 \"register_operand\" \"=d\")\n+\t(any_le:GPR2 (match_operand:GPR 1 \"register_operand\" \"d\")\n+\t\t     (match_operand:GPR 2 \"sle_operand\" \"\")))]\n   \"!TARGET_MIPS16\"\n {\n   operands[2] = GEN_INT (INTVAL (operands[2]) + 1);\n   return \"slt<u>\\t%0,%1,%2\";\n }\n   [(set_attr \"type\" \"slt\")\n-   (set_attr \"mode\" \"<MODE>\")])\n+   (set_attr \"mode\" \"<GPR:MODE>\")])\n \n-(define_insn \"*sle<u>_<mode>_mips16\"\n-  [(set (match_operand:GPR 0 \"register_operand\" \"=t\")\n-\t(any_le:GPR (match_operand:GPR 1 \"register_operand\" \"d\")\n-\t\t    (match_operand:GPR 2 \"sle_operand\" \"\")))]\n+(define_insn \"*sle<u>_<GPR:mode><GPR2:mode>_mips16\"\n+  [(set (match_operand:GPR2 0 \"register_operand\" \"=t\")\n+\t(any_le:GPR2 (match_operand:GPR 1 \"register_operand\" \"d\")\n+\t\t     (match_operand:GPR 2 \"sle_operand\" \"\")))]\n   \"TARGET_MIPS16\"\n {\n   operands[2] = GEN_INT (INTVAL (operands[2]) + 1);\n   return \"slt<u>\\t%1,%2\";\n }\n   [(set_attr \"type\" \"slt\")\n-   (set_attr \"mode\" \"<MODE>\")\n+   (set_attr \"mode\" \"<GPR:MODE>\")\n    (set (attr \"length\") (if_then_else (match_operand 2 \"m16_uimm8_m1_1\")\n \t\t\t\t      (const_int 4)\n \t\t\t\t      (const_int 8)))])"}, {"sha": "b22bcd48bc42f84d54cdae3bbd59eb6a6e7d5d93", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fb79e4c29afffae11b32f374ee8b120264305e9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fb79e4c29afffae11b32f374ee8b120264305e9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5fb79e4c29afffae11b32f374ee8b120264305e9", "patch": "@@ -1,3 +1,9 @@\n+2008-04-10  Adam Nemet  <anemet@caviumnetworks.com>\n+\n+\t* gcc.target/mips/scc-2.c: New test.\n+\t* gcc.target/mips/scc-3.c: New test.\n+\t* gcc.target/mips/scc-4.c: New test.\n+\n 2008-04-10  Ira Rosen  <irar@il.ibm.com>\n \n \tPR tree-optimization/35821"}, {"sha": "7964227a8d774d9810f3ad0b2e0052af77118de9", "filename": "gcc/testsuite/gcc.target/mips/scc-2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fb79e4c29afffae11b32f374ee8b120264305e9/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fscc-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fb79e4c29afffae11b32f374ee8b120264305e9/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fscc-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fscc-2.c?ref=5fb79e4c29afffae11b32f374ee8b120264305e9", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-mips-options \"-O -mgp64\" } */\n+\n+/* { dg-final { scan-assembler-not \"and\\t\\|andi\\t\\|ext\\t\\|sll\\t\\|srl\\t\" } } */\n+/* { dg-final { scan-assembler-times \"slt\\t\\|sltu\\t\" 12 } } */\n+\n+\n+#define TEST(N, LHS, REL, RHS) \\\n+  NOMIPS16 long long w##N (int a, int b) {return LHS REL RHS;} \\\n+  NOMIPS16 int n##N (long long a, long long b) {return LHS REL RHS;} \\\n+\n+TEST (eq, a, ==, 0);\n+TEST (ne, a, !=, 0);\n+TEST (gt, a, >, b);\n+TEST (ge, a, >=, 1);\n+TEST (lt, a, <, b);\n+TEST (le, a, <=, 11);"}, {"sha": "e496d401dd45330f51fd1fcd02999b14e31f1ef5", "filename": "gcc/testsuite/gcc.target/mips/scc-3.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fb79e4c29afffae11b32f374ee8b120264305e9/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fscc-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fb79e4c29afffae11b32f374ee8b120264305e9/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fscc-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fscc-3.c?ref=5fb79e4c29afffae11b32f374ee8b120264305e9", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-mips-options \"-O -mabi=o64\" } */\n+\n+/* { dg-final { scan-assembler-not \"and\\t\\|andi\\t\\|ext\\t\\|sll\\t\\|srl\\t\" } } */\n+/* { dg-final { scan-assembler-times \"slt\\t\\|sltu\\t\" 8 } } */\n+\n+\n+#define TEST(N, LHS, REL, RHS) \\\n+  MIPS16 long long w##N (int a, int b) {return LHS REL RHS;} \\\n+  MIPS16 int n##N (long long a, long long b) {return LHS REL RHS;} \\\n+\n+TEST (eq, a, ==, 0);\n+\n+TEST (gt, a, >, b);\n+\n+TEST (lt, a, <, b);\n+TEST (le, a, <=, 11);"}, {"sha": "fd6e9326789a50f0e7265e1340b0c5f3dc3ed25f", "filename": "gcc/testsuite/gcc.target/mips/scc-4.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fb79e4c29afffae11b32f374ee8b120264305e9/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fscc-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fb79e4c29afffae11b32f374ee8b120264305e9/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fscc-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fscc-4.c?ref=5fb79e4c29afffae11b32f374ee8b120264305e9", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-mips-options \"-O -mabi=o64\" } */\n+\n+/* { dg-final { scan-assembler \"slt\\t\" } } */\n+/* { dg-final { scan-assembler \"sltu\\t\\|xor\\t\\|xori\\t\" } } */\n+\n+/* This test should work both in mips16 and non-mips16 mode.  */\n+\n+int\n+f (long long a, long long b)\n+{\n+  return a > 5;\n+}"}]}