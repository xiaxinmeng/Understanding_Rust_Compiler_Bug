{"sha": "6413dd818096d3d76b6da424f454da7638bfe847", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQxM2RkODE4MDk2ZDNkNzZiNmRhNDI0ZjQ1NGRhNzYzOGJmZTg0Nw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-05-21T10:52:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-05-21T10:52:48Z"}, "message": "[multiple changes]\n\n2014-05-21  Bob Duff  <duff@adacore.com>\n\n\t* sem_util.adb (Is_Dependent_Component_Of_Mutable_Object):\n\tThis was returning False if the Object is a constant view. Fix\n\tit to return True in that case, because it might be a view of\n\ta variable.\n\t(Has_Discriminant_Dependent_Constraint): Fix latent\n\tbug; this function was crashing when passed a discriminant.\n\n2014-05-21  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_ugn.texi: Remove misplaced section that is now obsolete.\n\t* s-arit64.adb: Minor code reorganization.\n\t* sem_prag.adb: Minor comment fix (remove erroneous use of the\n\tterm erroneous).\n\n2014-05-21  Robert Dewar  <dewar@adacore.com>\n\n\t* g-table.adb, g-dyntab.adb (Reallocate): Fix possible overflow in\n\tcomputing new table size.\n\nFrom-SVN: r210690", "tree": {"sha": "a4c5ef63a6f4bff40cee7c54bc04bbb6b0aaffc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4c5ef63a6f4bff40cee7c54bc04bbb6b0aaffc9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6413dd818096d3d76b6da424f454da7638bfe847", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6413dd818096d3d76b6da424f454da7638bfe847", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6413dd818096d3d76b6da424f454da7638bfe847", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6413dd818096d3d76b6da424f454da7638bfe847/comments", "author": null, "committer": null, "parents": [{"sha": "2735b82d096137ab53517510fd3669e60a663915", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2735b82d096137ab53517510fd3669e60a663915", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2735b82d096137ab53517510fd3669e60a663915"}], "stats": {"total": 204, "additions": 126, "deletions": 78}, "files": [{"sha": "b605eca8317260296ca620603581aa62a5d6a12d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6413dd818096d3d76b6da424f454da7638bfe847/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6413dd818096d3d76b6da424f454da7638bfe847/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6413dd818096d3d76b6da424f454da7638bfe847", "patch": "@@ -1,3 +1,24 @@\n+2014-05-21  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_util.adb (Is_Dependent_Component_Of_Mutable_Object):\n+\tThis was returning False if the Object is a constant view. Fix\n+\tit to return True in that case, because it might be a view of\n+\ta variable.\n+\t(Has_Discriminant_Dependent_Constraint): Fix latent\n+\tbug; this function was crashing when passed a discriminant.\n+\n+2014-05-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat_ugn.texi: Remove misplaced section that is now obsolete.\n+\t* s-arit64.adb: Minor code reorganization.\n+\t* sem_prag.adb: Minor comment fix (remove erroneous use of the\n+\tterm erroneous).\n+\n+2014-05-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* g-table.adb, g-dyntab.adb (Reallocate): Fix possible overflow in\n+\tcomputing new table size.\n+\n 2014-05-21  Robert Dewar  <dewar@adacore.com>\n \n \t* einfo.ads: Minor reformatting."}, {"sha": "e5e41c927a0607d5461a1aa6abb32375f9efc007", "filename": "gcc/ada/g-dyntab.adb", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6413dd818096d3d76b6da424f454da7638bfe847/gcc%2Fada%2Fg-dyntab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6413dd818096d3d76b6da424f454da7638bfe847/gcc%2Fada%2Fg-dyntab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-dyntab.adb?ref=6413dd818096d3d76b6da424f454da7638bfe847", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 2000-2013, AdaCore                     --\n+--                     Copyright (C) 2000-2014, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -187,13 +187,24 @@ package body GNAT.Dynamic_Tables is\n \n    begin\n       if T.P.Max < T.P.Last_Val then\n+\n+         --  Now increment table length until it is sufficiently large. Use\n+         --  the increment value or 10, which ever is larger (the reason\n+         --  for the use of 10 here is to ensure that the table does really\n+         --  increase in size (which would not be the case for a table of\n+         --  length 10 increased by 3% for instance). Do the intermediate\n+         --  calculation in Long_Long_Integer to avoid overflow.\n+\n          while T.P.Max < T.P.Last_Val loop\n-            New_Length := T.P.Length * (100 + Table_Increment) / 100;\n+            New_Length :=\n+              Integer\n+                (Long_Long_Integer (T.P.Length) *\n+                  (100 + Long_Long_Integer (Table_Increment)) / 100);\n \n             if New_Length > T.P.Length then\n                T.P.Length := New_Length;\n             else\n-               T.P.Length := T.P.Length + 1;\n+               T.P.Length := T.P.Length + 10;\n             end if;\n \n             T.P.Max := Min + T.P.Length - 1;"}, {"sha": "e12e84f7578a5e84e9893aa1c8ff6f7f55416c68", "filename": "gcc/ada/g-table.adb", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6413dd818096d3d76b6da424f454da7638bfe847/gcc%2Fada%2Fg-table.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6413dd818096d3d76b6da424f454da7638bfe847/gcc%2Fada%2Fg-table.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-table.adb?ref=6413dd818096d3d76b6da424f454da7638bfe847", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 1998-2013, AdaCore                     --\n+--                     Copyright (C) 1998-2014, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -196,21 +196,25 @@ package body GNAT.Table is\n    ----------------\n \n    procedure Reallocate is\n-      New_Size : size_t;\n+      New_Size   : size_t;\n+      New_Length : Long_Long_Integer;\n \n    begin\n       if Max < Last_Val then\n          pragma Assert (not Locked);\n \n-         while Max < Last_Val loop\n-\n-            --  Increase length using the table increment factor, but make\n-            --  sure that we add at least ten elements (this avoids a loop\n-            --  for silly small increment values)\n+         --  Now increment table length until it is sufficiently large. Use\n+         --  the increment value or 10, which ever is larger (the reason\n+         --  for the use of 10 here is to ensure that the table does really\n+         --  increase in size (which would not be the case for a table of\n+         --  length 10 increased by 3% for instance). Do the intermediate\n+         --  calculation in Long_Long_Integer to avoid overflow.\n \n-            Length := Integer'Max\n-                        (Length * (100 + Table_Increment) / 100,\n-                         Length + 10);\n+         while Max < Last_Val loop\n+            New_Length :=\n+              Long_Long_Integer (Length) *\n+                (100 + Long_Long_Integer (Table_Increment)) / 100;\n+            Length := Integer'Max (Integer (New_Length), Length + 10);\n             Max := Min + Length - 1;\n          end loop;\n       end if;"}, {"sha": "78d682b36b67efb0ca1bfea94a0fe6b49013040e", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6413dd818096d3d76b6da424f454da7638bfe847/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6413dd818096d3d76b6da424f454da7638bfe847/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=6413dd818096d3d76b6da424f454da7638bfe847", "patch": "@@ -8369,11 +8369,6 @@ limit, then a message is output and the bind is abandoned.\n A value of zero means that no limit is enforced. The equal\n sign is optional.\n \n-@ifset unw\n-Furthermore, under Windows, the sources pointed to by the libraries path\n-set in the registry are not searched for.\n-@end ifset\n-\n @item ^-n^/NOMAIN^\n @cindex @option{^-n^/NOMAIN^} (@command{gnatbind})\n No main program."}, {"sha": "51b05f9a235366020455201dcea0bc851a5dc08b", "filename": "gcc/ada/s-arit64.adb", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6413dd818096d3d76b6da424f454da7638bfe847/gcc%2Fada%2Fs-arit64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6413dd818096d3d76b6da424f454da7638bfe847/gcc%2Fada%2Fs-arit64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-arit64.adb?ref=6413dd818096d3d76b6da424f454da7638bfe847", "patch": "@@ -49,22 +49,17 @@ package body System.Arith_64 is\n    -----------------------\n \n    function \"+\" (A, B : Uns32) return Uns64 is (Uns64 (A) + Uns64 (B));\n-   function \"+\" (A : Uns64; B : Uns32) return Uns64 is\n-     (A + Uns64 (B));\n-   pragma Inline (\"+\");\n+   function \"+\" (A : Uns64; B : Uns32) return Uns64 is (A + Uns64 (B));\n    --  Length doubling additions\n \n    function \"*\" (A, B : Uns32) return Uns64 is (Uns64 (A) * Uns64 (B));\n-   pragma Inline (\"*\");\n    --  Length doubling multiplication\n \n    function \"/\" (A : Uns64; B : Uns32) return Uns64 is (A / Uns64 (B));\n-   pragma Inline (\"/\");\n    --  Length doubling division\n \n    function \"&\" (Hi, Lo : Uns32) return Uns64 is\n      (Shift_Left (Uns64 (Hi), 32) or Uns64 (Lo));\n-   pragma Inline (\"&\");\n    --  Concatenate hi, lo values to form 64-bit result\n \n    function \"abs\" (X : Int64) return Uns64 is\n@@ -73,35 +68,32 @@ package body System.Arith_64 is\n    --  the expression of the Else, because it overflows for X = Int64'First.\n \n    function \"rem\" (A : Uns64; B : Uns32) return Uns64 is (A rem Uns64 (B));\n-   pragma Inline (\"rem\");\n    --  Length doubling remainder\n \n    function Le3 (X1, X2, X3 : Uns32; Y1, Y2, Y3 : Uns32) return Boolean;\n    --  Determines if 96 bit value X1&X2&X3 <= Y1&Y2&Y3\n \n    function Lo (A : Uns64) return Uns32 is (Uns32 (A and 16#FFFF_FFFF#));\n-   pragma Inline (Lo);\n    --  Low order half of 64-bit value\n \n    function Hi (A : Uns64) return Uns32 is (Uns32 (Shift_Right (A, 32)));\n-   pragma Inline (Hi);\n    --  High order half of 64-bit value\n \n    procedure Sub3 (X1, X2, X3 : in out Uns32; Y1, Y2, Y3 : Uns32);\n    --  Computes X1&X2&X3 := X1&X2&X3 - Y1&Y1&Y3 with mod 2**96 wrap\n \n-   function To_Neg_Int (A : Uns64) return Int64;\n+   function To_Neg_Int (A : Uns64) return Int64 with Inline;\n    --  Convert to negative integer equivalent. If the input is in the range\n    --  0 .. 2 ** 63, then the corresponding negative signed integer (obtained\n    --  by negating the given value) is returned, otherwise constraint error\n    --  is raised.\n \n-   function To_Pos_Int (A : Uns64) return Int64;\n+   function To_Pos_Int (A : Uns64) return Int64 with Inline;\n    --  Convert to positive integer equivalent. If the input is in the range\n    --  0 .. 2 ** 63-1, then the corresponding non-negative signed integer is\n    --  returned, otherwise constraint error is raised.\n \n-   procedure Raise_Error;\n+   procedure Raise_Error with Inline;\n    pragma No_Return (Raise_Error);\n    --  Raise constraint error with appropriate message\n \n@@ -586,7 +578,6 @@ package body System.Arith_64 is\n \n    function To_Neg_Int (A : Uns64) return Int64 is\n       R : constant Int64 := -To_Int (A);\n-\n    begin\n       if R <= 0 then\n          return R;\n@@ -601,7 +592,6 @@ package body System.Arith_64 is\n \n    function To_Pos_Int (A : Uns64) return Int64 is\n       R : constant Int64 := To_Int (A);\n-\n    begin\n       if R >= 0 then\n          return R;"}, {"sha": "f5a507401a0bbd16fafc57b0336f456349f72b12", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6413dd818096d3d76b6da424f454da7638bfe847/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6413dd818096d3d76b6da424f454da7638bfe847/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=6413dd818096d3d76b6da424f454da7638bfe847", "patch": "@@ -1239,7 +1239,7 @@ package body Sem_Prag is\n          Is_Input   : Boolean)\n       is\n          procedure Usage_Error (Item : Node_Id; Item_Id : Entity_Id);\n-         --  Emit an error concerning the erroneous usage of an item\n+         --  Emit an error concerning the illegal usage of an item\n \n          -----------------\n          -- Usage_Error --\n@@ -1783,10 +1783,11 @@ package body Sem_Prag is\n                      Is_Last => Clause = Last_Clause);\n                end if;\n \n-               --  Do not normalize an erroneous clause because the inputs\n-               --  and/or outputs may denote illegal items. Normalization is\n-               --  disabled in ASIS mode as it alters the tree by introducing\n-               --  new nodes similar to expansion.\n+               --  Do not normalize a clause if errors were detected (count\n+               --  of Serious_Errors has increased) because the inputs and/or\n+               --  outputs may denote illegal items. Normalization is disabled\n+               --  in ASIS mode as it alters the tree by introducing new nodes\n+               --  similar to expansion.\n \n                if Serious_Errors_Detected = Errors and then not ASIS_Mode then\n                   Normalize_Clause (Clause);\n@@ -2288,7 +2289,7 @@ package body Sem_Prag is\n                raise Program_Error;\n             end if;\n \n-         --  Any other attempt to declare a global item is erroneous\n+         --  Any other attempt to declare a global item is illegal\n \n          else\n             Error_Msg_N (\"malformed global list\", List);\n@@ -4700,7 +4701,7 @@ package body Sem_Prag is\n                               Prag := Stmt;\n \n                            --  A non-pragma is separating the group from the\n-                           --  current pragma, the placement is erroneous.\n+                           --  current pragma, the placement is illegal.\n \n                            else\n                               Grouping_Error (Prag);\n@@ -10584,7 +10585,7 @@ package body Sem_Prag is\n                      then\n                         Analyze_External_Option (Opt);\n \n-                     --  When an erroneous option Part_Of is without a parent\n+                     --  When an illegal option Part_Of is without a parent\n                      --  state, it appears in the list of expression of the\n                      --  aggregate rather than the component associations\n                      --  (SPARK RM 7.1.4(9)).\n@@ -10627,7 +10628,7 @@ package body Sem_Prag is\n                      Next (Opt);\n                   end loop;\n \n-               --  Any other attempt to declare a state is erroneous\n+               --  Any other attempt to declare a state is illegal\n \n                else\n                   Error_Msg_N (\"malformed abstract state declaration\", State);\n@@ -25515,7 +25516,7 @@ package body Sem_Prag is\n       elsif N = Name_Off then\n          return Off;\n \n-      --  Any other argument is erroneous\n+      --  Any other argument is illegal\n \n       else\n          raise Program_Error;"}, {"sha": "13e74daf95205c7dc97b3a0f544decba96215eb2", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 62, "deletions": 36, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6413dd818096d3d76b6da424f454da7638bfe847/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6413dd818096d3d76b6da424f454da7638bfe847/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=6413dd818096d3d76b6da424f454da7638bfe847", "patch": "@@ -7300,39 +7300,46 @@ package body Sem_Util is\n      (Comp : Entity_Id) return Boolean\n    is\n       Comp_Decl  : constant Node_Id := Parent (Comp);\n-      Subt_Indic : constant Node_Id :=\n-                     Subtype_Indication (Component_Definition (Comp_Decl));\n+      Subt_Indic : Node_Id;\n       Constr     : Node_Id;\n       Assn       : Node_Id;\n \n    begin\n-      if Nkind (Subt_Indic) = N_Subtype_Indication then\n-         Constr := Constraint (Subt_Indic);\n+      --  Discriminants can't depend on discriminants\n \n-         if Nkind (Constr) = N_Index_Or_Discriminant_Constraint then\n-            Assn := First (Constraints (Constr));\n-            while Present (Assn) loop\n-               case Nkind (Assn) is\n-                  when N_Subtype_Indication |\n-                       N_Range              |\n-                       N_Identifier\n-                  =>\n-                     if Depends_On_Discriminant (Assn) then\n-                        return True;\n-                     end if;\n+      if Ekind (Comp) = E_Discriminant then\n+         return False;\n \n-                  when N_Discriminant_Association =>\n-                     if Depends_On_Discriminant (Expression (Assn)) then\n-                        return True;\n-                     end if;\n+      else\n+         Subt_Indic := Subtype_Indication (Component_Definition (Comp_Decl));\n \n-                  when others =>\n-                     null;\n+         if Nkind (Subt_Indic) = N_Subtype_Indication then\n+            Constr := Constraint (Subt_Indic);\n \n-               end case;\n+            if Nkind (Constr) = N_Index_Or_Discriminant_Constraint then\n+               Assn := First (Constraints (Constr));\n+               while Present (Assn) loop\n+                  case Nkind (Assn) is\n+                     when N_Subtype_Indication |\n+                          N_Range              |\n+                          N_Identifier\n+                       =>\n+                        if Depends_On_Discriminant (Assn) then\n+                           return True;\n+                        end if;\n \n-               Next (Assn);\n-            end loop;\n+                     when N_Discriminant_Association =>\n+                        if Depends_On_Discriminant (Expression (Assn)) then\n+                           return True;\n+                        end if;\n+\n+                     when others =>\n+                        null;\n+                  end case;\n+\n+                  Next (Assn);\n+               end loop;\n+            end if;\n          end if;\n       end if;\n \n@@ -9740,11 +9747,6 @@ package body Sem_Util is\n    function Is_Dependent_Component_Of_Mutable_Object\n      (Object : Node_Id) return Boolean\n    is\n-      P           : Node_Id;\n-      Prefix_Type : Entity_Id;\n-      P_Aliased   : Boolean := False;\n-      Comp        : Entity_Id;\n-\n       function Is_Declared_Within_Variant (Comp : Entity_Id) return Boolean;\n       --  Returns True if and only if Comp is declared within a variant part\n \n@@ -9759,17 +9761,41 @@ package body Sem_Util is\n          return Nkind (Parent (Comp_List)) = N_Variant;\n       end Is_Declared_Within_Variant;\n \n+      P           : Node_Id;\n+      Prefix_Type : Entity_Id;\n+      P_Aliased   : Boolean := False;\n+      Comp        : Entity_Id;\n+\n+      Deref : Node_Id := Object;\n+      --  Dereference node, in something like X.all.Y(2)\n+\n    --  Start of processing for Is_Dependent_Component_Of_Mutable_Object\n \n    begin\n-      if Is_Variable (Object) then\n+      --  Find the dereference node if any\n \n+      while Nkind_In (Deref, N_Indexed_Component,\n+                             N_Selected_Component,\n+                             N_Slice)\n+      loop\n+         Deref := Prefix (Deref);\n+      end loop;\n+\n+      --  Ada 2005: If we have a component or slice of a dereference,\n+      --  something like X.all.Y (2), and the type of X is access-to-constant,\n+      --  Is_Variable will return False, because it is indeed a constant\n+      --  view. But it might be a view of a variable object, so we want the\n+      --  following condition to be True in that case.\n+\n+      if Is_Variable (Object)\n+        or else (Ada_Version >= Ada_2005\n+                   and then Nkind (Deref) = N_Explicit_Dereference)\n+      then\n          if Nkind (Object) = N_Selected_Component then\n             P := Prefix (Object);\n             Prefix_Type := Etype (P);\n \n             if Is_Entity_Name (P) then\n-\n                if Ekind (Entity (P)) = E_Generic_In_Out_Parameter then\n                   Prefix_Type := Base_Type (Prefix_Type);\n                end if;\n@@ -9801,10 +9827,10 @@ package body Sem_Util is\n             --  the dereferenced case, since the access value might denote an\n             --  unconstrained aliased object, whereas in Ada 95 the designated\n             --  object is guaranteed to be constrained. A worst-case assumption\n-            --  has to apply in Ada 2005 because we can't tell at compile time\n-            --  whether the object is \"constrained by its initial value\"\n-            --  (despite the fact that 3.10.2(26/2) and 8.5.1(5/2) are\n-            --  semantic rules -- these rules are acknowledged to need fixing).\n+            --  has to apply in Ada 2005 because we can't tell at compile\n+            --  time whether the object is \"constrained by its initial value\"\n+            --  (despite the fact that 3.10.2(26/2) and 8.5.1(5/2) are semantic\n+            --  rules (these rules are acknowledged to need fixing).\n \n             if Ada_Version < Ada_2005 then\n                if Is_Access_Type (Prefix_Type)\n@@ -9813,7 +9839,7 @@ package body Sem_Util is\n                   return False;\n                end if;\n \n-            elsif Ada_Version >= Ada_2005 then\n+            else pragma Assert (Ada_Version >= Ada_2005);\n                if Is_Access_Type (Prefix_Type) then\n \n                   --  If the access type is pool-specific, and there is no"}]}