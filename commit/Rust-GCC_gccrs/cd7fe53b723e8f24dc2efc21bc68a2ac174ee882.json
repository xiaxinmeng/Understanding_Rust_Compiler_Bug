{"sha": "cd7fe53b723e8f24dc2efc21bc68a2ac174ee882", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Q3ZmU1M2I3MjNlOGYyNGRjMmVmYzIxYmM2OGEyYWMxNzRlZTg4Mg==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2010-06-21T20:58:57Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2010-06-21T20:58:57Z"}, "message": "diagnostic.h (diagnostic_classification_change_t): New.\n\n* diagnostic.h (diagnostic_classification_change_t): New.\n(diagnostic_context): Add history and push/pop list.\n(diagnostic_push_diagnostics): Declare.\n(diagnostic_pop_diagnostics): Declare.\n* diagnostic.c (diagnostic_classify_diagnostic): Store changes\nfrom pragmas in a history chain instead of the global table.\n(diagnostic_push_diagnostics): New.\n(diagnostic_pop_diagnostics): New.\n(diagnostic_report_diagnostic): Scan history chain to find state\nof diagnostics as of the diagnostic location.\n* opts.c (set_option): Pass UNKNOWN_LOCATION to\ndiagnostic_classify_diagnostic.\n(enable_warning_as_error): Likewise.\n* diagnostic-core.h (DK_POP): Add after \"real\" diagnostics, for\nuse in the history chain.\n* c-family/c-pragma.c (handle_pragma_diagnostic): Add push/pop,\nallow these pragmas anywhere.\n* doc/extend.texi: Document pragma GCC diagnostic changes.\n\n* gcc.dg/pragma-diag-1.c: New.\n\nFrom-SVN: r161115", "tree": {"sha": "bed45f50f0a58fddadbef5bd923786107ade4104", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bed45f50f0a58fddadbef5bd923786107ade4104"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd7fe53b723e8f24dc2efc21bc68a2ac174ee882", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd7fe53b723e8f24dc2efc21bc68a2ac174ee882", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd7fe53b723e8f24dc2efc21bc68a2ac174ee882", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd7fe53b723e8f24dc2efc21bc68a2ac174ee882/comments", "author": null, "committer": null, "parents": [{"sha": "fa188ff0f28cb5fe194837825d41dea4e5aa3cdc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa188ff0f28cb5fe194837825d41dea4e5aa3cdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa188ff0f28cb5fe194837825d41dea4e5aa3cdc"}], "stats": {"total": 230, "additions": 206, "deletions": 24}, "files": [{"sha": "85041a1ac82b35425116c26604fcd467612e0b57", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd7fe53b723e8f24dc2efc21bc68a2ac174ee882/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd7fe53b723e8f24dc2efc21bc68a2ac174ee882/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cd7fe53b723e8f24dc2efc21bc68a2ac174ee882", "patch": "@@ -1,3 +1,24 @@\n+2010-06-21  DJ Delorie  <dj@redhat.com>\n+\n+\t* diagnostic.h (diagnostic_classification_change_t): New.\n+\t(diagnostic_context): Add history and push/pop list.\n+\t(diagnostic_push_diagnostics): Declare.\n+\t(diagnostic_pop_diagnostics): Declare.\n+\t* diagnostic.c (diagnostic_classify_diagnostic): Store changes\n+\tfrom pragmas in a history chain instead of the global table.\n+\t(diagnostic_push_diagnostics): New.\n+\t(diagnostic_pop_diagnostics): New.\n+\t(diagnostic_report_diagnostic): Scan history chain to find state\n+\tof diagnostics as of the diagnostic location.\n+\t* opts.c (set_option): Pass UNKNOWN_LOCATION to\n+\tdiagnostic_classify_diagnostic.\n+\t(enable_warning_as_error): Likewise.\n+\t* diagnostic-core.h (DK_POP): Add after \"real\" diagnostics, for\n+\tuse in the history chain.\n+\t* c-family/c-pragma.c (handle_pragma_diagnostic): Add push/pop,\n+\tallow these pragmas anywhere.\n+\t* doc/extend.texi: Document pragma GCC diagnostic changes.\n+\n 2010-06-21  Jakub Jelinek  <jakub@redhat.com>\n \n \t* dwarf2out.c (add_linkage_name): New function.  Don't add"}, {"sha": "cea0b267b9259dfe2b640b4abd41ceb3d3a7f723", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd7fe53b723e8f24dc2efc21bc68a2ac174ee882/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd7fe53b723e8f24dc2efc21bc68a2ac174ee882/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=cd7fe53b723e8f24dc2efc21bc68a2ac174ee882", "patch": "@@ -706,12 +706,6 @@ handle_pragma_diagnostic(cpp_reader *ARG_UNUSED(dummy))\n   diagnostic_t kind;\n   tree x;\n \n-  if (cfun)\n-    {\n-      error (\"#pragma GCC diagnostic not allowed inside functions\");\n-      return;\n-    }\n-\n   token = pragma_lex (&x);\n   if (token != CPP_NAME)\n     GCC_BAD (\"missing [error|warning|ignored] after %<#pragma GCC diagnostic%>\");\n@@ -722,8 +716,18 @@ handle_pragma_diagnostic(cpp_reader *ARG_UNUSED(dummy))\n     kind = DK_WARNING;\n   else if (strcmp (kind_string, \"ignored\") == 0)\n     kind = DK_IGNORED;\n+  else if (strcmp (kind_string, \"push\") == 0)\n+    {\n+      diagnostic_push_diagnostics (global_dc, input_location);\n+      return;\n+    }\n+  else if (strcmp (kind_string, \"pop\") == 0)\n+    {\n+      diagnostic_pop_diagnostics (global_dc, input_location);\n+      return;\n+    }\n   else\n-    GCC_BAD (\"expected [error|warning|ignored] after %<#pragma GCC diagnostic%>\");\n+    GCC_BAD (\"expected [error|warning|ignored|push|pop] after %<#pragma GCC diagnostic%>\");\n \n   token = pragma_lex (&x);\n   if (token != CPP_STRING)\n@@ -733,7 +737,7 @@ handle_pragma_diagnostic(cpp_reader *ARG_UNUSED(dummy))\n     if (strcmp (cl_options[option_index].opt_text, option_string) == 0)\n       {\n \t/* This overrides -Werror, for example.  */\n-\tdiagnostic_classify_diagnostic (global_dc, option_index, kind);\n+\tdiagnostic_classify_diagnostic (global_dc, option_index, kind, input_location);\n \t/* This makes sure the option is enabled, like -Wfoo would do.  */\n \tif (cl_options[option_index].var_type == CLVC_BOOLEAN\n \t    && cl_options[option_index].flag_var"}, {"sha": "674bad608aaedd126cdbbd9e69197674ca9e5e57", "filename": "gcc/diagnostic-core.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd7fe53b723e8f24dc2efc21bc68a2ac174ee882/gcc%2Fdiagnostic-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd7fe53b723e8f24dc2efc21bc68a2ac174ee882/gcc%2Fdiagnostic-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-core.h?ref=cd7fe53b723e8f24dc2efc21bc68a2ac174ee882", "patch": "@@ -32,7 +32,10 @@ typedef enum\n #define DEFINE_DIAGNOSTIC_KIND(K, msgid) K,\n #include \"diagnostic.def\"\n #undef DEFINE_DIAGNOSTIC_KIND\n-  DK_LAST_DIAGNOSTIC_KIND\n+  DK_LAST_DIAGNOSTIC_KIND,\n+  /* This is used for tagging pragma pops in the diagnostic\n+     classification history chain.  */\n+  DK_POP\n } diagnostic_t;\n \n extern const char *progname;"}, {"sha": "34e9679693fe5835d6d0bf55f635b0f6e180ed7b", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 88, "deletions": 3, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd7fe53b723e8f24dc2efc21bc68a2ac174ee882/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd7fe53b723e8f24dc2efc21bc68a2ac174ee882/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=cd7fe53b723e8f24dc2efc21bc68a2ac174ee882", "patch": "@@ -306,7 +306,8 @@ default_diagnostic_finalizer (diagnostic_context *context,\n diagnostic_t\n diagnostic_classify_diagnostic (diagnostic_context *context,\n \t\t\t\tint option_index,\n-\t\t\t\tdiagnostic_t new_kind)\n+\t\t\t\tdiagnostic_t new_kind,\n+\t\t\t\tlocation_t where)\n {\n   diagnostic_t old_kind;\n \n@@ -316,10 +317,66 @@ diagnostic_classify_diagnostic (diagnostic_context *context,\n     return DK_UNSPECIFIED;\n \n   old_kind = context->classify_diagnostic[option_index];\n-  context->classify_diagnostic[option_index] = new_kind;\n+\n+  /* Handle pragmas separately, since we need to keep track of *where*\n+     the pragmas were.  */\n+  if (where != UNKNOWN_LOCATION)\n+    {\n+      int i;\n+\n+      for (i = context->n_classification_history - 1; i >= 0; i --)\n+\tif (context->classification_history[i].option == option_index)\n+\t  {\n+\t    old_kind = context->classification_history[i].kind;\n+\t    break;\n+\t  }\n+\n+      i = context->n_classification_history;\n+      context->classification_history =\n+\t(diagnostic_classification_change_t *) xrealloc (context->classification_history, (i + 1)\n+\t\t\t\t\t\t\t * sizeof (diagnostic_classification_change_t));\n+      context->classification_history[i].location = where;\n+      context->classification_history[i].option = option_index;\n+      context->classification_history[i].kind = new_kind;\n+      context->n_classification_history ++;\n+    }\n+  else\n+    context->classify_diagnostic[option_index] = new_kind;\n+\n   return old_kind;\n }\n \n+/* Save all diagnostic classifications in a stack.  */\n+void\n+diagnostic_push_diagnostics (diagnostic_context *context, location_t where ATTRIBUTE_UNUSED)\n+{\n+  context->push_list = (int *) xrealloc (context->push_list, (context->n_push + 1) * sizeof (int));\n+  context->push_list[context->n_push ++] = context->n_classification_history;\n+}\n+\n+/* Restore the topmost classification set off the stack.  If the stack\n+   is empty, revert to the state based on command line parameters.  */\n+void\n+diagnostic_pop_diagnostics (diagnostic_context *context, location_t where)\n+{\n+  int jump_to;\n+  int i;\n+\n+  if (context->n_push)\n+    jump_to = context->push_list [-- context->n_push];\n+  else\n+    jump_to = 0;\n+\n+  i = context->n_classification_history;\n+  context->classification_history =\n+    (diagnostic_classification_change_t *) xrealloc (context->classification_history, (i + 1)\n+\t\t\t\t\t\t     * sizeof (diagnostic_classification_change_t));\n+  context->classification_history[i].location = where;\n+  context->classification_history[i].option = jump_to;\n+  context->classification_history[i].kind = DK_POP;\n+  context->n_classification_history ++;\n+}\n+\n /* Report a diagnostic message (an error or a warning) as specified by\n    DC.  This function is *the* subroutine in terms of which front-ends\n    should implement their specific diagnostic handling modules.  The\n@@ -374,13 +431,41 @@ diagnostic_report_diagnostic (diagnostic_context *context,\n \n   if (diagnostic->option_index)\n     {\n+      diagnostic_t diag_class = DK_UNSPECIFIED;\n+\n       /* This tests if the user provided the appropriate -Wfoo or\n \t -Wno-foo option.  */\n       if (! context->option_enabled (diagnostic->option_index))\n \treturn false;\n+\n+      /* This tests for #pragma diagnostic changes.  */\n+      if (context->n_classification_history > 0)\n+\t{\n+\t  int i;\n+\t  /* FIXME: Stupid search.  Optimize later. */\n+\t  for (i = context->n_classification_history - 1; i >= 0; i --)\n+\t    {\n+\t      if (context->classification_history[i].location <= location)\n+\t\t{\n+\t\t  if (context->classification_history[i].kind == (int) DK_POP)\n+\t\t    {\n+\t\t      i = context->classification_history[i].option;\n+\t\t      continue;\n+\t\t    }\n+\t\t  if (context->classification_history[i].option == diagnostic->option_index)\n+\t\t    {\n+\t\t      diag_class = context->classification_history[i].kind;\n+\t\t      if (diag_class != DK_UNSPECIFIED)\n+\t\t\tdiagnostic->kind = diag_class;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n       /* This tests if the user provided the appropriate -Werror=foo\n \t option.  */\n-      if (context->classify_diagnostic[diagnostic->option_index] != DK_UNSPECIFIED)\n+      if (diag_class == DK_UNSPECIFIED\n+\t  && context->classify_diagnostic[diagnostic->option_index] != DK_UNSPECIFIED)\n \t{\n \t  diagnostic->kind = context->classify_diagnostic[diagnostic->option_index];\n \t}"}, {"sha": "d3840749e91394a5c202eb55f2f36c23a8fa0f32", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd7fe53b723e8f24dc2efc21bc68a2ac174ee882/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd7fe53b723e8f24dc2efc21bc68a2ac174ee882/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=cd7fe53b723e8f24dc2efc21bc68a2ac174ee882", "patch": "@@ -41,6 +41,16 @@ typedef struct diagnostic_info\n   int option_index;\n } diagnostic_info;\n \n+/* Each time a diagnostic's classification is changed with a pragma,\n+   we record the change and the location of the change in an array of\n+   these structs.  */\n+typedef struct diagnostic_classification_change_t\n+{\n+  location_t location;\n+  int option;\n+  diagnostic_t kind;\n+} diagnostic_classification_change_t;\n+\n /*  Forward declarations.  */\n typedef struct diagnostic_context diagnostic_context;\n typedef void (*diagnostic_starter_fn) (diagnostic_context *,\n@@ -76,6 +86,20 @@ struct diagnostic_context\n      all.  */\n   diagnostic_t *classify_diagnostic;\n \n+  /* History of all changes to the classifications above.  This list\n+     is stored in location-order, so we can search it, either\n+     binary-wise or end-to-front, to find the most recent\n+     classification for a given diagnostic, given the location of the\n+     diagnostic.  */\n+  diagnostic_classification_change_t *classification_history;\n+\n+  /* The size of the above array.  */\n+  int n_classification_history;\n+\n+  /* For pragma push/pop.  */\n+  int *push_list;\n+  int n_push;\n+\n   /* True if we should print the command line option which controls\n      each diagnostic, if known.  */\n   bool show_option_requested;\n@@ -228,7 +252,10 @@ extern void diagnostic_report_current_module (diagnostic_context *);\n /* Force diagnostics controlled by OPTIDX to be kind KIND.  */\n extern diagnostic_t diagnostic_classify_diagnostic (diagnostic_context *,\n \t\t\t\t\t\t    int /* optidx */,\n-\t\t\t\t\t\t    diagnostic_t /* kind */);\n+\t\t\t\t\t\t    diagnostic_t /* kind */,\n+\t\t\t\t\t\t    location_t);\n+extern void diagnostic_push_diagnostics (diagnostic_context *, location_t);\n+extern void diagnostic_pop_diagnostics (diagnostic_context *, location_t);\n extern bool diagnostic_report_diagnostic (diagnostic_context *,\n \t\t\t\t\t  diagnostic_info *);\n #ifdef ATTRIBUTE_GCC_DIAG"}, {"sha": "795b6bf7a342ae134d181ff3b534a9a23cf8e456", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd7fe53b723e8f24dc2efc21bc68a2ac174ee882/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd7fe53b723e8f24dc2efc21bc68a2ac174ee882/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=cd7fe53b723e8f24dc2efc21bc68a2ac174ee882", "patch": "@@ -12590,15 +12590,30 @@ option.\n #pragma GCC diagnostic ignored \"-Wformat\"\n @end example\n \n-Note that these pragmas override any command-line options.  Also,\n-while it is syntactically valid to put these pragmas anywhere in your\n-sources, the only supported location for them is before any data or\n-functions are defined.  Doing otherwise may result in unpredictable\n-results depending on how the optimizer manages your sources.  If the\n-same option is listed multiple times, the last one specified is the\n-one that is in effect.  This pragma is not intended to be a general\n-purpose replacement for command-line options, but for implementing\n-strict control over project policies.\n+Note that these pragmas override any command-line options.  GCC keeps\n+track of the location of each pragma, and issues diagnostics according\n+to the state as of that point in the source file.  Thus, pragmas occurring\n+after a line do not affect diagnostics caused by that line.\n+\n+@item #pragma GCC diagnostic push\n+@itemx #pragma GCC diagnostic pop\n+\n+Causes GCC to remember the state of the diagnostics as of each\n+@code{push}, and restore to that point at each @code{pop}.  If a\n+@code{pop} has no matching @code{push}, the command line options are\n+restored.\n+\n+@example\n+#pragma GCC diagnostic error \"-Wuninitialized\"\n+  foo(a);\t\t\t/* error is given for this one */\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wuninitialized\"\n+  foo(b);\t\t\t/* no diagnostic for this one */\n+#pragma GCC diagnostic pop\n+  foo(c);\t\t\t/* error is given for this one */\n+#pragma GCC diagnostic pop\n+  foo(d);\t\t\t/* depends on command line options */\n+@end example\n \n @end table\n "}, {"sha": "55f8c77d7f1f849544bb622a1b0ae383e91f52dd", "filename": "gcc/opts.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd7fe53b723e8f24dc2efc21bc68a2ac174ee882/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd7fe53b723e8f24dc2efc21bc68a2ac174ee882/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=cd7fe53b723e8f24dc2efc21bc68a2ac174ee882", "patch": "@@ -2396,7 +2396,8 @@ set_option (int opt_index, int value, const char *arg, int kind)\n     }\n \n   if ((diagnostic_t)kind != DK_UNSPECIFIED)\n-    diagnostic_classify_diagnostic (global_dc, opt_index, (diagnostic_t)kind);\n+    diagnostic_classify_diagnostic (global_dc, opt_index, (diagnostic_t)kind,\n+\t\t\t\t    UNKNOWN_LOCATION);\n }\n \n \n@@ -2434,7 +2435,8 @@ enable_warning_as_error (const char *arg, int value, unsigned int lang_mask)\n     {\n       const diagnostic_t kind = value ? DK_ERROR : DK_WARNING;\n \n-      diagnostic_classify_diagnostic (global_dc, option_index, kind);\n+      diagnostic_classify_diagnostic (global_dc, option_index, kind,\n+\t\t\t\t      UNKNOWN_LOCATION);\n       if (kind == DK_ERROR)\n \t{\n \t  const struct cl_option * const option = cl_options + option_index;"}, {"sha": "77228c14ff1aec9f174f66a1366decfcf786ff6f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd7fe53b723e8f24dc2efc21bc68a2ac174ee882/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd7fe53b723e8f24dc2efc21bc68a2ac174ee882/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cd7fe53b723e8f24dc2efc21bc68a2ac174ee882", "patch": "@@ -1,3 +1,7 @@\n+2010-06-21  DJ Delorie  <dj@redhat.com>\n+\n+\t* gcc.dg/pragma-diag-1.c: New.\n+\n 2010-06-21  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/44615"}, {"sha": "b6d294d9ab5de5929917f9a911b149bce14e718f", "filename": "gcc/testsuite/gcc.dg/pragma-diag-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd7fe53b723e8f24dc2efc21bc68a2ac174ee882/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-diag-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd7fe53b723e8f24dc2efc21bc68a2ac174ee882/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-diag-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-diag-1.c?ref=cd7fe53b723e8f24dc2efc21bc68a2ac174ee882", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+/* { dg-message \"warnings being treated as errors\" \"\" {target \"*-*-*\"} 0 } */\n+\n+main()\n+{\n+  int a;\n+  int b;\n+  int c;\n+  int d;\n+\n+#pragma GCC diagnostic error \"-Wuninitialized\"\n+  foo(a);\t\t\t/* { dg-error \"uninitialized\" } */\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wuninitialized\"\n+  foo(b);\n+#pragma GCC diagnostic pop\n+  foo(c);\t\t\t/* { dg-error \"uninitialized\" } */\n+#pragma GCC diagnostic pop\n+  foo(d);\t\t\t/* { dg-warning \"uninitialized\" } */\n+}"}]}