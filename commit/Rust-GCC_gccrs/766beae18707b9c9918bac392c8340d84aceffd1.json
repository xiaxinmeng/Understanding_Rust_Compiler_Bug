{"sha": "766beae18707b9c9918bac392c8340d84aceffd1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY2YmVhZTE4NzA3YjljOTkxOGJhYzM5MmM4MzQwZDg0YWNlZmZkMQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@codesourcery.com", "date": "2003-08-30T21:24:19Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-08-30T21:24:19Z"}, "message": "c-tree.h: Delete COMPARE_DIFFERENT_TU from enumeration.\n\n\t* c-tree.h: Delete COMPARE_DIFFERENT_TU from enumeration.\n\t* c-typeck.c (same_translation_unit_p): New function.\n\t(comptypes): Use it instead of flags parameter to identify\n\tstructure types from different translation units.\n\t* c-decl.c (duplicate_decls): Always call comptypes with\n\tCOMPTYPE_STRICT flags argument.\n\t(c_reset_state): Set BLOCK_SUPERCONTEXT of the block formed\n\tto file_scope_decl.\n\nFrom-SVN: r70953", "tree": {"sha": "224ec6b140b0764f4f59fa98e93fdcd681438b8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/224ec6b140b0764f4f59fa98e93fdcd681438b8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/766beae18707b9c9918bac392c8340d84aceffd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/766beae18707b9c9918bac392c8340d84aceffd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/766beae18707b9c9918bac392c8340d84aceffd1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/766beae18707b9c9918bac392c8340d84aceffd1/comments", "author": null, "committer": null, "parents": [{"sha": "bf7a697f0ad4399b6ef6abc542520c9be858356e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf7a697f0ad4399b6ef6abc542520c9be858356e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf7a697f0ad4399b6ef6abc542520c9be858356e"}], "stats": {"total": 58, "additions": 48, "deletions": 10}, "files": [{"sha": "4856f1d4d58379bc9fcd9ad6f20c2d99396013fd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/766beae18707b9c9918bac392c8340d84aceffd1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/766beae18707b9c9918bac392c8340d84aceffd1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=766beae18707b9c9918bac392c8340d84aceffd1", "patch": "@@ -1,3 +1,14 @@\n+2003-08-30  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* c-tree.h: Delete COMPARE_DIFFERENT_TU from enumeration.\n+\t* c-typeck.c (same_translation_unit_p): New function.\n+\t(comptypes): Use it instead of flags parameter to identify\n+\tstructure types from different translation units.\n+\t* c-decl.c (duplicate_decls): Always call comptypes with\n+\tCOMPTYPE_STRICT flags argument.\n+\t(c_reset_state): Set BLOCK_SUPERCONTEXT of the block formed\n+\tto file_scope_decl.\n+\n 2003-08-30  Zack Weinberg  <zack@codesourcery.com>\n \n \t* c-tree.h (C_TYPE_INCOMPLETE_VARS): New macro."}, {"sha": "20b9b67a071dbaf0f5aa2294525262cb63749588", "filename": "gcc/c-decl.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/766beae18707b9c9918bac392c8340d84aceffd1/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/766beae18707b9c9918bac392c8340d84aceffd1/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=766beae18707b9c9918bac392c8340d84aceffd1", "patch": "@@ -775,10 +775,8 @@ static int\n duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \t\t int different_tu)\n {\n-  int comptype_flags = (different_tu ? COMPARE_DIFFERENT_TU\n-\t\t\t: COMPARE_STRICT);\n   int types_match = comptypes (TREE_TYPE (newdecl), TREE_TYPE (olddecl),\n-\t\t\t       comptype_flags);\n+\t\t\t       COMPARE_STRICT);\n   int new_is_definition = (TREE_CODE (newdecl) == FUNCTION_DECL\n \t\t\t   && DECL_INITIAL (newdecl) != 0);\n   tree oldtype = TREE_TYPE (olddecl);\n@@ -897,7 +895,7 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \n \t  if (trytype)\n \t    {\n-\t      types_match = comptypes (newtype, trytype, comptype_flags);\n+\t      types_match = comptypes (newtype, trytype, COMPARE_STRICT);\n \t      if (types_match)\n \t\toldtype = trytype;\n \t      if (! different_binding_level)\n@@ -983,7 +981,7 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \t\t && ! pedantic\n \t\t /* Return types must still match.  */\n \t\t && comptypes (TREE_TYPE (oldtype),\n-\t\t\t       TREE_TYPE (newtype), comptype_flags)\n+\t\t\t       TREE_TYPE (newtype), COMPARE_STRICT)\n \t\t && TYPE_ARG_TYPES (newtype) == 0))\n     {\n       error (\"%Hconflicting types for '%D'\",\n@@ -992,7 +990,7 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \t involving an empty arglist vs a nonempty one.  */\n       if (TREE_CODE (olddecl) == FUNCTION_DECL\n \t  && comptypes (TREE_TYPE (oldtype),\n-\t\t\tTREE_TYPE (newtype), comptype_flags)\n+\t\t\tTREE_TYPE (newtype), COMPARE_STRICT)\n \t  && ((TYPE_ARG_TYPES (oldtype) == 0\n \t       && DECL_INITIAL (olddecl) == 0)\n \t      ||\n@@ -1135,7 +1133,7 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \t      /* Type for passing arg must be consistent\n \t\t with that declared for the arg.  */\n \t      if (! comptypes (TREE_VALUE (parm), TREE_VALUE (type),\n-\t\t\t       comptype_flags))\n+\t\t\t       COMPARE_STRICT))\n \t\t{\n                   const location_t *locus = &DECL_SOURCE_LOCATION (newdecl);\n \t\t  error (\"%Hprototype for '%D' follows and argument %d \"\n@@ -6701,6 +6699,7 @@ c_reset_state (void)\n       current_scope = global_scope;\n   file_scope_decl = current_file_decl;\n   DECL_INITIAL (file_scope_decl) = poplevel (1, 0, 0);\n+  BLOCK_SUPERCONTEXT (DECL_INITIAL (file_scope_decl)) = file_scope_decl;\n   truly_local_externals = NULL_TREE;\n \n   /* Start a new global binding level.  */"}, {"sha": "f85e5d0965540eb4a6bf35ed47b2b5eff0f1c193", "filename": "gcc/c-tree.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/766beae18707b9c9918bac392c8340d84aceffd1/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/766beae18707b9c9918bac392c8340d84aceffd1/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=766beae18707b9c9918bac392c8340d84aceffd1", "patch": "@@ -244,8 +244,7 @@ extern bool c_warn_unused_global_decl (tree);\n \n /* For use with comptypes.  */\n enum {\n-  COMPARE_STRICT = 0,\n-  COMPARE_DIFFERENT_TU = 1\n+  COMPARE_STRICT = 0\n };\n \n extern tree require_complete_type (tree);"}, {"sha": "530ac750cd12f6b7e288b8c9796e099e36810842", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/766beae18707b9c9918bac392c8340d84aceffd1/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/766beae18707b9c9918bac392c8340d84aceffd1/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=766beae18707b9c9918bac392c8340d84aceffd1", "patch": "@@ -50,6 +50,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n static int missing_braces_mentioned;\n \n static tree qualify_type (tree, tree);\n+static int same_translation_unit_p (tree, tree);\n static int tagged_types_tu_compatible_p (tree, tree, int);\n static int comp_target_types (tree, tree, int);\n static int function_types_compatible_p (tree, tree, int);\n@@ -564,7 +565,7 @@ comptypes (tree type1, tree type2, int flags)\n \n     case ENUMERAL_TYPE:\n     case UNION_TYPE:\n-      if (val != 1 && (flags & COMPARE_DIFFERENT_TU))\n+      if (val != 1 && !same_translation_unit_p (t1, t2))\n \tval = tagged_types_tu_compatible_p (t1, t2, flags);\n       break;\n \n@@ -606,6 +607,34 @@ comp_target_types (tree ttl, tree ttr, int reflexive)\n \f\n /* Subroutines of `comptypes'.  */\n \n+/* Determine whether two types derive from the same translation unit.\n+   If the CONTEXT chain ends in a null, that type's context is still\n+   being parsed, so if two types have context chains ending in null,\n+   they're in the same translation unit.  */\n+static int\n+same_translation_unit_p (tree t1, tree t2)\n+{\n+  while (t1 && TREE_CODE (t1) != TRANSLATION_UNIT_DECL)\n+    switch (TREE_CODE_CLASS (TREE_CODE (t1)))\n+      {\n+      case 'd': t1 = DECL_CONTEXT (t1); break;\n+      case 't': t1 = TYPE_CONTEXT (t1); break;\n+      case 'b': t1 = BLOCK_SUPERCONTEXT (t1); break;\n+      default: abort ();\n+      }\n+\n+  while (t2 && TREE_CODE (t2) != TRANSLATION_UNIT_DECL)\n+    switch (TREE_CODE_CLASS (TREE_CODE (t2)))\n+      {\n+      case 'd': t2 = DECL_CONTEXT (t1); break;\n+      case 't': t2 = TYPE_CONTEXT (t2); break;\n+      case 'b': t2 = BLOCK_SUPERCONTEXT (t2); break;\n+      default: abort ();\n+      }\n+\n+  return t1 == t2;\n+}\n+\n /* The C standard says that two structures in different translation\n    units are compatible with each other only if the types of their\n    fields are compatible (among other things).  So, consider two copies"}]}