{"sha": "d3e0da54c16e5383b9b969b7b40f7eadb35b0b8e", "node_id": "C_kwDOANBUbNoAKGQzZTBkYTU0YzE2ZTUzODNiOWI5NjliN2I0MGY3ZWFkYjM1YjBiOGU", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-06-16T21:36:38Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-06-16T21:36:38Z"}, "message": "c-decl: fix \"inform\" grouping and conditionalization\n\nWhilst working on SARIF output I noticed some places where followup notes\nweren't being properly associated with their errors/warnings in c-decl.cc.\n\nWhilst fixing those I noticed some places where we \"inform\" after a\n\"warning\" without checking that the warning was actually emitted.\n\nFixed the various issues seen in gcc/c/c-decl.cc thusly.\n\ngcc/c/ChangeLog:\n\t* c-decl.cc (implicitly_declare): Add auto_diagnostic_group to\n\tgroup the warning with any note.\n\t(warn_about_goto): Likewise to group error or warning with note.\n\tBail out if the warning wasn't emitted, to avoid emitting orphan\n\tnotes.\n\t(lookup_label_for_goto): Add auto_diagnostic_group to\n\tgroup the error with the note.\n\t(check_earlier_gotos): Likewise.\n\t(c_check_switch_jump_warnings): Likewise for any error/warning.\n\tConditionalize emission of the notes.\n\t(diagnose_uninitialized_cst_member): Likewise for warning,\n\tconditionalizing emission of the note.\n\t(grokdeclarator): Add auto_diagnostic_group to group the \"array\n\ttype has incomplete element type\" error with any note.\n\t(parser_xref_tag): Add auto_diagnostic_group to group warnings\n\twith their notes.  Conditionalize emission of notes.\n\t(start_struct): Add auto_diagnostic_group to group the\n\t\"redefinition of\" errors with any note.\n\t(start_enum): Likewise for \"redeclaration of %<enum %E%>\" error.\n\t(check_for_loop_decls): Likewise for pre-C99 error.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "526c8a2985cb0b4992061eb522a97dc96075f8fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/526c8a2985cb0b4992061eb522a97dc96075f8fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3e0da54c16e5383b9b969b7b40f7eadb35b0b8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3e0da54c16e5383b9b969b7b40f7eadb35b0b8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3e0da54c16e5383b9b969b7b40f7eadb35b0b8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3e0da54c16e5383b9b969b7b40f7eadb35b0b8e/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0da5f0a3161310f2180cccc42a26e0bd02030f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0da5f0a3161310f2180cccc42a26e0bd02030f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0da5f0a3161310f2180cccc42a26e0bd02030f0"}], "stats": {"total": 65, "additions": 42, "deletions": 23}, "files": [{"sha": "ae8990c138fd28fdd31e74f119510bcfb0b9c906", "filename": "gcc/c/c-decl.cc", "status": "modified", "additions": 42, "deletions": 23, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3e0da54c16e5383b9b969b7b40f7eadb35b0b8e/gcc%2Fc%2Fc-decl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3e0da54c16e5383b9b969b7b40f7eadb35b0b8e/gcc%2Fc%2Fc-decl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.cc?ref=d3e0da54c16e5383b9b969b7b40f7eadb35b0b8e", "patch": "@@ -3697,6 +3697,7 @@ implicitly_declare (location_t loc, tree functionid)\n \t\t\t\t\t\t      (TREE_TYPE (decl)));\n \t      if (!comptypes (newtype, TREE_TYPE (decl)))\n \t\t{\n+\t\t  auto_diagnostic_group d;\n \t\t  bool warned = warning_at (loc,\n \t\t\t\t\t    OPT_Wbuiltin_declaration_mismatch,\n \t\t\t\t\t    \"incompatible implicit \"\n@@ -3890,12 +3891,14 @@ lookup_label (tree name)\n static void\n warn_about_goto (location_t goto_loc, tree label, tree decl)\n {\n+  auto_diagnostic_group d;\n   if (variably_modified_type_p (TREE_TYPE (decl), NULL_TREE))\n     error_at (goto_loc,\n \t      \"jump into scope of identifier with variably modified type\");\n   else\n-    warning_at (goto_loc, OPT_Wjump_misses_init,\n-\t\t\"jump skips variable initialization\");\n+    if (!warning_at (goto_loc, OPT_Wjump_misses_init,\n+\t\t     \"jump skips variable initialization\"))\n+      return;\n   inform (DECL_SOURCE_LOCATION (label), \"label %qD defined here\", label);\n   inform (DECL_SOURCE_LOCATION (decl), \"%qD declared here\", decl);\n }\n@@ -3950,6 +3953,7 @@ lookup_label_for_goto (location_t loc, tree name)\n \n   if (label_vars->label_bindings.left_stmt_expr)\n     {\n+      auto_diagnostic_group d;\n       error_at (loc, \"jump into statement expression\");\n       inform (DECL_SOURCE_LOCATION (label), \"label %qD defined here\", label);\n     }\n@@ -4040,6 +4044,7 @@ check_earlier_gotos (tree label, struct c_label_vars* label_vars)\n \n       if (g->goto_bindings.stmt_exprs > 0)\n \t{\n+\t  auto_diagnostic_group d;\n \t  error_at (g->loc, \"jump into statement expression\");\n \t  inform (DECL_SOURCE_LOCATION (label), \"label %qD defined here\",\n \t\t  label);\n@@ -4159,26 +4164,34 @@ c_check_switch_jump_warnings (struct c_spot_bindings *switch_bindings,\n \t{\n \t  if (decl_jump_unsafe (b->decl))\n \t    {\n+\t      auto_diagnostic_group d;\n+\t      bool emitted;\n \t      if (variably_modified_type_p (TREE_TYPE (b->decl), NULL_TREE))\n \t\t{\n \t\t  saw_error = true;\n \t\t  error_at (case_loc,\n \t\t\t    (\"switch jumps into scope of identifier with \"\n \t\t\t     \"variably modified type\"));\n+\t\t  emitted = true;\n \t\t}\n \t      else\n-\t\twarning_at (case_loc, OPT_Wjump_misses_init,\n-\t\t\t    \"switch jumps over variable initialization\");\n-\t      inform (switch_loc, \"switch starts here\");\n-\t      inform (DECL_SOURCE_LOCATION (b->decl), \"%qD declared here\",\n-\t\t      b->decl);\n+\t\temitted\n+\t\t  = warning_at (case_loc, OPT_Wjump_misses_init,\n+\t\t\t\t\"switch jumps over variable initialization\");\n+\t      if (emitted)\n+\t\t{\n+\t\t  inform (switch_loc, \"switch starts here\");\n+\t\t  inform (DECL_SOURCE_LOCATION (b->decl), \"%qD declared here\",\n+\t\t\t  b->decl);\n+\t\t}\n \t    }\n \t}\n     }\n \n   if (switch_bindings->stmt_exprs > 0)\n     {\n       saw_error = true;\n+      auto_diagnostic_group d;\n       error_at (case_loc, \"switch jumps into statement expression\");\n       inform (switch_loc, \"switch starts here\");\n     }\n@@ -5317,10 +5330,11 @@ diagnose_uninitialized_cst_member (tree decl, tree type)\n \n       if (TYPE_QUALS (field_type) & TYPE_QUAL_CONST)\n       \t{\n-\t  warning_at (DECL_SOURCE_LOCATION (decl), OPT_Wc___compat,\n-\t  \t      \"uninitialized const member in %qT is invalid in C++\",\n-\t\t      strip_array_types (TREE_TYPE (decl)));\n-\t  inform (DECL_SOURCE_LOCATION (field), \"%qD should be initialized\", field);\n+\t  auto_diagnostic_group d;\n+\t  if (warning_at (DECL_SOURCE_LOCATION (decl), OPT_Wc___compat,\n+\t\t\t  \"uninitialized const member in %qT is invalid in C++\",\n+\t\t\t  strip_array_types (TREE_TYPE (decl))))\n+\t    inform (DECL_SOURCE_LOCATION (field), \"%qD should be initialized\", field);\n \t}\n \n       if (RECORD_OR_UNION_TYPE_P (field_type))\n@@ -6942,6 +6956,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t    /* Complain about arrays of incomplete types.  */\n \t    if (!COMPLETE_TYPE_P (type))\n \t      {\n+\t\tauto_diagnostic_group d;\n \t\terror_at (loc, \"array type has incomplete element type %qT\",\n \t\t\t  type);\n \t\t/* See if we can be more helpful.  */\n@@ -8201,25 +8216,26 @@ parser_xref_tag (location_t loc, enum tree_code code, tree name,\n \t  && loc != UNKNOWN_LOCATION\n \t  && warn_cxx_compat)\n \t{\n+\t  auto_diagnostic_group d;\n \t  switch (code)\n \t    {\n \t    case ENUMERAL_TYPE:\n-\t      warning_at (loc, OPT_Wc___compat,\n-\t\t\t  (\"enum type defined in struct or union \"\n-\t\t\t   \"is not visible in C++\"));\n-\t      inform (refloc, \"enum type defined here\");\n+\t      if (warning_at (loc, OPT_Wc___compat,\n+\t\t\t      (\"enum type defined in struct or union \"\n+\t\t\t       \"is not visible in C++\")))\n+\t\t  inform (refloc, \"enum type defined here\");\n \t      break;\n \t    case RECORD_TYPE:\n-\t      warning_at (loc, OPT_Wc___compat,\n-\t\t\t  (\"struct defined in struct or union \"\n-\t\t\t   \"is not visible in C++\"));\n-\t      inform (refloc, \"struct defined here\");\n+\t      if (warning_at (loc, OPT_Wc___compat,\n+\t\t\t      (\"struct defined in struct or union \"\n+\t\t\t       \"is not visible in C++\")))\n+\t\tinform (refloc, \"struct defined here\");\n \t      break;\n \t    case UNION_TYPE:\n-\t      warning_at (loc, OPT_Wc___compat,\n-\t\t\t  (\"union defined in struct or union \"\n-\t\t\t   \"is not visible in C++\"));\n-\t      inform (refloc, \"union defined here\");\n+\t      if (warning_at (loc, OPT_Wc___compat,\n+\t\t\t      (\"union defined in struct or union \"\n+\t\t\t       \"is not visible in C++\")))\n+\t\tinform (refloc, \"union defined here\");\n \t      break;\n \t    default:\n \t      gcc_unreachable();\n@@ -8295,6 +8311,7 @@ start_struct (location_t loc, enum tree_code code, tree name,\n \n       if (TYPE_SIZE (ref))\n \t{\n+\t  auto_diagnostic_group d;\n \t  if (code == UNION_TYPE)\n \t    error_at (loc, \"redefinition of %<union %E%>\", name);\n \t  else\n@@ -9121,6 +9138,7 @@ start_enum (location_t loc, struct c_enum_contents *the_enum, tree name)\n   if (TYPE_VALUES (enumtype) != NULL_TREE)\n     {\n       /* This enum is a named one that has been declared already.  */\n+      auto_diagnostic_group d;\n       error_at (loc, \"redeclaration of %<enum %E%>\", name);\n       if (enumloc != UNKNOWN_LOCATION)\n \tinform (enumloc, \"originally defined here\");\n@@ -10428,6 +10446,7 @@ check_for_loop_decls (location_t loc, bool turn_off_iso_c99_error)\n       /* If we get here, declarations have been used in a for loop without\n \t the C99 for loop scope.  This doesn't make much sense, so don't\n \t allow it.  */\n+      auto_diagnostic_group d;\n       error_at (loc, \"%<for%> loop initial declarations \"\n \t\t\"are only allowed in C99 or C11 mode\");\n       if (hint)"}]}