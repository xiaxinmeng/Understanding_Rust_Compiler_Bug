{"sha": "08c2951c86934a764347fc5929ab6e4f06ea66cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhjMjk1MWM4NjkzNGE3NjQzNDdmYzU5MjlhYjZlNGYwNmVhNjZjZA==", "commit": {"author": {"name": "Stan Cox", "email": "scox@cygnus.com", "date": "1998-12-01T16:52:56Z"}, "committer": {"name": "Stan Cox", "email": "scox@gcc.gnu.org", "date": "1998-12-01T16:52:56Z"}, "message": "mips.md (divmodsi4*, [...]): Add -mcheck-range-division/ -mcheck-zero-division checking.\n\n* mips.md (divmodsi4*, divmoddi4*, udivmodsi4*, udivmoddi4): Add -mcheck-range-division/\n-mcheck-zero-division checking.  Avoid as macro expansion.  Use hi/lo as destination\nregister.\n(div_trap): New.\n(divsi3*, divdi3*, modsi3*, moddi3*, udivsi3*, udivdi3*, umodsi3*,\numoddi3*): Add -mcheck-range-division/-mcheck-zero-division checking.\nAvoid as macro expansion.  Use hi/lo as destination register.\n* mips.h (MASK_CHECK_RANGE_DIV): New.\n(MASK_NO_CHECK_ZERO_DIV): New.\n(ELIMINABLE_REGS): Added GP_REG_FIRST + 31.\n(CAN_ELIMINATE, INITIAL_ELIMINATION_OFFSET): Allow for getting\nreturn address for leaf functions out of r31 to support\nbuiltin_return_address.\n\nFrom-SVN: r24047", "tree": {"sha": "39eb2e0c7c345f15e1b7b803b6069bed1e5a46d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39eb2e0c7c345f15e1b7b803b6069bed1e5a46d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08c2951c86934a764347fc5929ab6e4f06ea66cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08c2951c86934a764347fc5929ab6e4f06ea66cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08c2951c86934a764347fc5929ab6e4f06ea66cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08c2951c86934a764347fc5929ab6e4f06ea66cd/comments", "author": null, "committer": null, "parents": [{"sha": "1f5fb51fab42df42da3117a9fcaebff33294a6e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f5fb51fab42df42da3117a9fcaebff33294a6e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f5fb51fab42df42da3117a9fcaebff33294a6e9"}], "stats": {"total": 526, "additions": 388, "deletions": 138}, "files": [{"sha": "c239f45e906fdbd194b288ec6b6977ca4bb1b827", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c2951c86934a764347fc5929ab6e4f06ea66cd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c2951c86934a764347fc5929ab6e4f06ea66cd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=08c2951c86934a764347fc5929ab6e4f06ea66cd", "patch": "@@ -1,3 +1,20 @@\n+Tue Dec  1 16:45:49 1998  Stan Cox  <scox@cygnus.com>\n+\n+\t* mips.md (divmodsi4*, divmoddi4*, udivmodsi4*, udivmoddi4): Add\n+\t-mcheck-range-division/-mcheck-zero-division checking.  Avoid as macro\n+\texpansion.  Use hi/lo as destination register.\n+\t(div_trap): New.\n+\t(divsi3*, divdi3*, modsi3*, moddi3*, udivsi3*, udivdi3*, umodsi3*,\n+\tumoddi3*): Add -mcheck-range-division/-mcheck-zero-division checking.\n+\tAvoid as macro expansion.  Use hi/lo as destination register. \n+\n+\t* mips.h (MASK_CHECK_RANGE_DIV): New.\n+\t(MASK_NO_CHECK_ZERO_DIV): New.\n+\t(ELIMINABLE_REGS): Added GP_REG_FIRST + 31.\n+\t(CAN_ELIMINATE, INITIAL_ELIMINATION_OFFSET): Allow for getting\n+\treturn address for leaf functions out of r31 to support\n+\tbuiltin_return_address. \n+\t\n Tue Dec  1 15:03:30 1998  Herman A.J. ten Brugge <Haj.Ten.Brugge@net.HCC.nl>\n \n \t* jump.c (jump_optimize): Call regs_set_between_p with PREV_INSN(x),"}, {"sha": "13f1b7bd227db9a22cf8d8758f9527eee95b4134", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c2951c86934a764347fc5929ab6e4f06ea66cd/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c2951c86934a764347fc5929ab6e4f06ea66cd/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=08c2951c86934a764347fc5929ab6e4f06ea66cd", "patch": "@@ -336,16 +336,18 @@ extern void\t\tmips_select_section ();\n #define MASK_4300_MUL_FIX 0x00080000    /* Work-around early Vr4300 CPU bug */\n #define MASK_MIPS3900\t0x00100000\t/* like -mips1 only 3900 */\n #define MASK_MIPS16\t0x01000000\t/* Generate mips16 code */\n+#define MASK_NO_CHECK_ZERO_DIV 0x04000000\t/* divide by zero checking */\n+#define MASK_CHECK_RANGE_DIV 0x08000000\t/* divide result range checking */\n \n \t\t\t\t\t/* Dummy switches used only in spec's*/\n #define MASK_MIPS_TFILE\t0x00000000\t/* flag for mips-tfile usage */\n \n \t\t\t\t\t/* Debug switches, not documented */\n-#define MASK_DEBUG\t0x40000000\t/* Eliminate version # in .s file */\n-#define MASK_DEBUG_A\t0x20000000\t/* don't allow <label>($reg) addrs */\n-#define MASK_DEBUG_B\t0x10000000\t/* GO_IF_LEGITIMATE_ADDRESS debug */\n-#define MASK_DEBUG_C\t0x08000000\t/* don't expand seq, etc. */\n-#define MASK_DEBUG_D\t0x04000000\t/* don't do define_split's */\n+#define MASK_DEBUG\t0\t\t/* Eliminate version # in .s file */\n+#define MASK_DEBUG_A\t0x40000000\t/* don't allow <label>($reg) addrs */\n+#define MASK_DEBUG_B\t0x20000000\t/* GO_IF_LEGITIMATE_ADDRESS debug */\n+#define MASK_DEBUG_C\t0x10000000\t/* don't expand seq, etc. */\n+#define MASK_DEBUG_D\t0\t\t/* don't do define_split's */\n #define MASK_DEBUG_E\t0\t\t/* function_arg debug */\n #define MASK_DEBUG_F\t0\n #define MASK_DEBUG_G\t0\t\t/* don't support 64 bit arithmetic */\n@@ -425,6 +427,9 @@ extern void\t\tmips_select_section ();\n \n #define TARGET_4300_MUL_FIX     (target_flags & MASK_4300_MUL_FIX)\n \n+#define TARGET_NO_CHECK_ZERO_DIV (target_flags & MASK_NO_CHECK_ZERO_DIV)\n+#define TARGET_CHECK_RANGE_DIV  (target_flags & MASK_CHECK_RANGE_DIV)\n+\n /* This is true if we must enable the assembly language file switching\n    code.  */\n \n@@ -490,6 +495,10 @@ extern void\t\tmips_select_section ();\n   {\"no-fix4300\",         -MASK_4300_MUL_FIX},\t\t\t\t\\\n   {\"4650\",\t\t  MASK_MAD | MASK_SINGLE_FLOAT},\t\t\\\n   {\"3900\",\t\t  MASK_MIPS3900},                               \\\n+  {\"check-zero-division\",-MASK_NO_CHECK_ZERO_DIV},\t\t\t\\\n+  {\"no-check-zero-division\", MASK_NO_CHECK_ZERO_DIV},\t\t\t\\\n+  {\"check-range-division\",MASK_CHECK_RANGE_DIV},\t\t\t\\\n+  {\"no-check-range-division\",-MASK_CHECK_RANGE_DIV},\t\t\t\\\n   {\"debug\",\t\t  MASK_DEBUG},\t\t\t\t\t\\\n   {\"debuga\",\t\t  MASK_DEBUG_A},\t\t\t\t\\\n   {\"debugb\",\t\t  MASK_DEBUG_B},\t\t\t\t\\\n@@ -2144,6 +2153,7 @@ extern struct mips_frame_info current_frame_info;\n  { RETURN_ADDRESS_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n  { RETURN_ADDRESS_POINTER_REGNUM, GP_REG_FIRST + 30},\t\t\t\\\n  { RETURN_ADDRESS_POINTER_REGNUM, GP_REG_FIRST + 17},\t\t\t\\\n+ { RETURN_ADDRESS_POINTER_REGNUM, GP_REG_FIRST + 31},\t\t\t\\\n  { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\t\t\\\n  { FRAME_POINTER_REGNUM, GP_REG_FIRST + 30},\t\t\t\t\\\n  { FRAME_POINTER_REGNUM, GP_REG_FIRST + 17}}\n@@ -2169,11 +2179,14 @@ extern struct mips_frame_info current_frame_info;\n    */\n \n #define CAN_ELIMINATE(FROM, TO)\t\t\t\t\t\t\\\n-  ((TO) == HARD_FRAME_POINTER_REGNUM\t\t\t\t\t\\\n+  (((FROM) == RETURN_ADDRESS_POINTER_REGNUM && (! leaf_function_p ()\t\\\n+   || TO == GP_REG_FIRST + 31 && leaf_function_p))   \t\t\t\\\n+  || ((FROM) != RETURN_ADDRESS_POINTER_REGNUM\t\t\t\t\\\n+   && ((TO) == HARD_FRAME_POINTER_REGNUM \t\t\t\t\\\n    || ((TO) == STACK_POINTER_REGNUM && ! frame_pointer_needed\t\t\\\n        && ! (TARGET_MIPS16 && TARGET_64BIT)                             \\\n        && (! TARGET_MIPS16\t\t\t\t\t\t\\\n-\t   || compute_frame_size (get_frame_size ()) < 32768)))\n+\t   || compute_frame_size (get_frame_size ()) < 32768)))))\n \n /* This macro is similar to `INITIAL_FRAME_POINTER_OFFSET'.  It\n    specifies the initial difference between the specified pair of\n@@ -2206,7 +2219,9 @@ extern struct mips_frame_info current_frame_info;\n   /* Some ABIs store 64 bits to the stack, but Pmode is 32 bits,\t \\\n      so we must add 4 bytes to the offset to get the right value.  */\t \\\n   else if ((FROM) == RETURN_ADDRESS_POINTER_REGNUM)\t\t\t \\\n-    (OFFSET) = current_frame_info.gp_sp_offset\t\t\t\t \\\n+   if (leaf_function_p ()) \t\t\t\t\t\t \\\n+      (OFFSET) = 0;\t\t\t\t \t\t\t \\\n+   else (OFFSET) = current_frame_info.gp_sp_offset\t\t\t \\\n \t       + ((UNITS_PER_WORD - (POINTER_SIZE / BITS_PER_UNIT))\t \\\n \t\t  * (BYTES_BIG_ENDIAN != 0));\t\t\t\t \\\n }"}, {"sha": "14c4457a76e997599b35ab5543fadd88ae70d6af", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 348, "deletions": 130, "changes": 478, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c2951c86934a764347fc5929ab6e4f06ea66cd/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c2951c86934a764347fc5929ab6e4f06ea66cd/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=08c2951c86934a764347fc5929ab6e4f06ea66cd", "patch": "@@ -2228,7 +2228,7 @@\n ;; a divide by power of 2 with a shift, and then the remainder is no longer\n ;; available.\n \n-(define_insn \"divmodsi4\"\n+(define_expand \"divmodsi4\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(div:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t(match_operand:SI 2 \"register_operand\" \"d\")))\n@@ -2239,21 +2239,46 @@\n    (clobber (match_scratch:SI 5 \"=h\"))\n    (clobber (match_scratch:SI 6 \"=a\"))]\n   \"optimize\"\n-  \"*\n+  \"\n {\n-  if (find_reg_note (insn, REG_UNUSED, operands[3]))\n-    return \\\"div\\\\t%0,%1,%2\\\";\n+  rtx label;\n \n-  if (find_reg_note (insn, REG_UNUSED, operands[0]))\n-    return \\\"rem\\\\t%3,%1,%2\\\";\n+  emit_insn (gen_divmodsi4_internal (operands[0], operands[1], operands[2],\n+\t     operands[3]));\n+  if (!TARGET_NO_CHECK_ZERO_DIV)\n+    {\n+      emit_insn (gen_div_trap (operands[2],\n+\t\t\t       copy_to_mode_reg (SImode, GEN_INT (0)),\n+\t\t\t       GEN_INT (0x7)));\n+    }\n+  if (TARGET_CHECK_RANGE_DIV)\n+    {\n+      emit_insn (gen_div_trap (operands[2],\n+\t\t\t       copy_to_mode_reg (SImode, GEN_INT (-1)),\n+\t\t\t       GEN_INT (0x6)));\n+      emit_insn (gen_div_trap (operands[2],\n+\t\t\t       copy_to_mode_reg (SImode, GEN_INT (0x80000000)),\n+\t\t\t       GEN_INT (0x6)));\n+    }\n+  \n+  DONE;\n+}\")\n \n-  return \\\"div\\\\t%0,%1,%2\\;mfhi\\\\t%3\\\";\n-}\"\n+(define_insn \"divmodsi4_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n+\t(div:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"d\")))\n+   (set (match_operand:SI 3 \"register_operand\" \"=h\")\n+\t(mod:SI (match_dup 1)\n+\t\t(match_dup 2)))\n+   (clobber (match_scratch:SI 6 \"=a\"))]\n+  \"optimize\"\n+  \"div\\\\t$0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"14\")])\t\t;; various tests for dividing by 0 and such\n+   (set_attr \"length\"\t\"1\")])\n \n-(define_insn \"divmoddi4\"\n+(define_expand \"divmoddi4\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(div:DI (match_operand:DI 1 \"se_register_operand\" \"d\")\n \t\t(match_operand:DI 2 \"se_register_operand\" \"d\")))\n@@ -2264,21 +2289,46 @@\n    (clobber (match_scratch:DI 5 \"=h\"))\n    (clobber (match_scratch:DI 6 \"=a\"))]\n   \"TARGET_64BIT && optimize\"\n-  \"*\n+  \"\n {\n-  if (find_reg_note (insn, REG_UNUSED, operands[3]))\n-    return \\\"ddiv\\\\t%0,%1,%2\\\";\n+  rtx label;\n \n-  if (find_reg_note (insn, REG_UNUSED, operands[0]))\n-    return \\\"drem\\\\t%3,%1,%2\\\";\n+  emit_insn (gen_divmoddi4_internal (operands[0], operands[1], operands[2],\n+             operands[3]));\n+  if (!TARGET_NO_CHECK_ZERO_DIV)\n+    {\n+      emit_insn (gen_div_trap (operands[2],\n+\t\t\t       copy_to_mode_reg (DImode, GEN_INT (0)),\n+\t\t\t       GEN_INT (0x7)));\n+    }\n+  if (TARGET_CHECK_RANGE_DIV)\n+    {\n+      emit_insn (gen_div_trap (operands[2],\n+\t\t\t       copy_to_mode_reg (DImode, GEN_INT (-1)),\n+\t\t\t       GEN_INT (0x6)));\n+      emit_insn (gen_div_trap (operands[2],\n+\t\t\t       copy_to_mode_reg (DImode, GEN_INT (0x80000000)),\n+\t\t\t       GEN_INT (0x6)));\n+    }\n+  \n+  DONE;\n+}\")\n \n-  return \\\"ddiv\\\\t%0,%1,%2\\;mfhi\\\\t%3\\\";\n-}\"\n+(define_insn \"divmoddi4_internal\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=l\")\n+\t(div:DI (match_operand:DI 1 \"se_register_operand\" \"d\")\n+\t\t(match_operand:DI 2 \"se_register_operand\" \"d\")))\n+   (set (match_operand:DI 3 \"register_operand\" \"=h\")\n+\t(mod:DI (match_dup 1)\n+\t\t(match_dup 2)))\n+   (clobber (match_scratch:DI 6 \"=a\"))]\n+  \"TARGET_64BIT && optimize\"\n+  \"ddiv\\\\t$0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"15\")])\t\t;; various tests for dividing by 0 and such\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"1\")])\n \n-(define_insn \"udivmodsi4\"\n+(define_expand \"udivmodsi4\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(udiv:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n@@ -2289,21 +2339,37 @@\n    (clobber (match_scratch:SI 5 \"=h\"))\n    (clobber (match_scratch:SI 6 \"=a\"))]\n   \"optimize\"\n-  \"*\n+  \"\n {\n-  if (find_reg_note (insn, REG_UNUSED, operands[3]))\n-    return \\\"divu\\\\t%0,%1,%2\\\";\n+  rtx label;\n \n-  if (find_reg_note (insn, REG_UNUSED, operands[0]))\n-    return \\\"remu\\\\t%3,%1,%2\\\";\n+  emit_insn (gen_udivmodsi4_internal (operands[0], operands[1], operands[2],\n+                                      operands[3]));\n+  if (!TARGET_NO_CHECK_ZERO_DIV)\n+    {\n+      emit_insn (gen_div_trap (operands[2],\n+\t\t\t       copy_to_mode_reg (SImode, GEN_INT (0)),\n+\t\t\t       GEN_INT (0x7)));\n+    }\n+  \n+  DONE;\n+}\")\n \n-  return \\\"divu\\\\t%0,%1,%2\\;mfhi\\\\t%3\\\";\n-}\"\n+(define_insn \"udivmodsi4_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n+\t(udiv:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n+   (set (match_operand:SI 3 \"register_operand\" \"=h\")\n+\t(umod:SI (match_dup 1)\n+\t\t (match_dup 2)))\n+   (clobber (match_scratch:SI 6 \"=a\"))]\n+  \"optimize\"\n+  \"divu\\\\t$0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"8\")])\t\t;; various tests for dividing by 0 and such\n+   (set_attr \"length\"\t\"1\")])\n \n-(define_insn \"udivmoddi4\"\n+(define_expand \"udivmoddi4\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(udiv:DI (match_operand:DI 1 \"se_register_operand\" \"d\")\n \t\t (match_operand:DI 2 \"se_register_operand\" \"d\")))\n@@ -2314,220 +2380,372 @@\n    (clobber (match_scratch:DI 5 \"=h\"))\n    (clobber (match_scratch:DI 6 \"=a\"))]\n   \"TARGET_64BIT && optimize\"\n+  \"\n+{\n+  rtx label;\n+\n+  emit_insn (gen_udivmoddi4_internal (operands[0], operands[1], operands[2],\n+                                      operands[3]));\n+  if (!TARGET_NO_CHECK_ZERO_DIV)\n+    {\n+      emit_insn (gen_div_trap (operands[2],\n+\t\t\t       copy_to_mode_reg (DImode, GEN_INT (0)),\n+\t\t\t       GEN_INT (0x7)));\n+    }\n+  \n+  DONE;\n+}\")\n+\n+(define_insn \"udivmoddi4_internal\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=l\")\n+\t(udiv:DI (match_operand:DI 1 \"se_register_operand\" \"d\")\n+\t\t (match_operand:DI 2 \"se_register_operand\" \"d\")))\n+   (set (match_operand:DI 3 \"register_operand\" \"=h\")\n+\t(umod:DI (match_dup 1)\n+\t\t (match_dup 2)))\n+   (clobber (match_scratch:DI 6 \"=a\"))]\n+  \"TARGET_64BIT && optimize\"\n+  \"ddivu\\\\t$0,%1,%2\"\n+  [(set_attr \"type\"\t\"idiv\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"1\")])\n+\n+;; Division trap\n+\n+(define_insn \"div_trap\"\n+  [(trap_if (eq (match_operand 0 \"register_operand\" \"d\")\n+\t\t(match_operand 1 \"reg_or_0_operand\" \"dJ\"))\n+            (match_operand 2 \"immediate_operand\" \"\"))]\n+  \"\"\n   \"*\n {\n-  if (find_reg_note (insn, REG_UNUSED, operands[3]))\n-    return \\\"ddivu\\\\t%0,%1,%2\\\";\n+  rtx link;\n+  int have_dep_anti = 0;\n \n-  if (find_reg_note (insn, REG_UNUSED, operands[0]))\n-    return \\\"dremu\\\\t%3,%1,%2\\\";\n+  /* For divmod if one division is not needed then we don't need an extra\n+     divide by zero trap, which is anti dependent on previous trap */\n+  for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n \n-  return \\\"ddivu\\\\t%0,%1,%2\\;mfhi\\\\t%3\\\";\n+    if ((int) REG_DEP_ANTI == (int) REG_NOTE_KIND (link)\n+        && GET_CODE (PATTERN (XEXP (link, 0))) == TRAP_IF\n+\t&& REGNO (operands[1]) == 0)\n+      have_dep_anti = 1;\n+  if (! have_dep_anti)\n+    if (GENERATE_BRANCHLIKELY)\n+      return \\\"%(beql\\\\t%0,%1,.+8\\\\n\\\\tbreak\\\\t%2%)\\\";\n+    else\n+      return \\\"%(bne\\\\t%0,%1,.+12\\\\n\\\\tnop\\\\n\\\\tbreak\\\\t%2%)\\\";\n }\"\n-  [(set_attr \"type\"\t\"idiv\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"8\")])\t\t;; various tests for dividing by 0 and such\n+  [(set_attr \"type\" \"unknown\")\n+   (set_attr \"length\" \"2\")])\n \n (define_expand \"divsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n \t(div:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"di\")))\n-   (clobber (match_scratch:SI 3 \"=l\"))\n-   (clobber (match_scratch:SI 4 \"=h\"))\n-   (clobber (match_scratch:SI 6 \"=a\"))]\n+\t\t(match_operand:SI 2 \"register_operand\" \"d\")))\n+   (clobber (match_scratch:SI 3 \"=h\"))\n+   (clobber (match_scratch:SI 4 \"=a\"))]\n   \"!optimize\"\n   \"\n {\n-  /* MIPS16 needs div/rem ops in registers. */\n-  if (TARGET_MIPS16)\n-    operands[2] = force_reg (SImode, operands[2]);\n+  rtx label;\n+\n+  emit_insn (gen_divsi3_internal (operands[0], operands[1], operands[2]));\n+  if (!TARGET_NO_CHECK_ZERO_DIV)\n+    {\n+      emit_insn (gen_div_trap (operands[2],\n+\t\t\t       copy_to_mode_reg (SImode, GEN_INT (0)),\n+\t\t\t       GEN_INT (0x7)));\n+    }\n+  if (TARGET_CHECK_RANGE_DIV)\n+    {\n+      emit_insn (gen_div_trap (operands[2],\n+\t\t\t       copy_to_mode_reg (SImode, GEN_INT (-1)),\n+\t\t\t       GEN_INT (0x6)));\n+      emit_insn (gen_div_trap (operands[2],\n+\t\t\t       copy_to_mode_reg (SImode, GEN_INT (0x80000000)),\n+\t\t\t       GEN_INT (0x6)));\n+    }\n+  \n+  DONE;\n }\")\n \n (define_insn \"divsi3_internal\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n \t(div:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"di\")))]\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"di\")))\n+   (clobber (match_scratch:SI 3 \"=h\"))\n+   (clobber (match_scratch:SI 4 \"=a\"))]\n   \"!optimize\"\n-  \"div\\\\t%0,%1,%2\"\n+  \"div\\\\t$0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"13\")])\t;; various tests for dividing by 0 and such\n+   (set_attr \"length\"\t\"1\")])\n \n (define_expand \"divdi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=l\")\n \t(div:DI (match_operand:DI 1 \"se_register_operand\" \"d\")\n-\t\t(match_operand:DI 2 \"se_nonmemory_operand\" \"di\")))\n-   (clobber (match_scratch:DI 3 \"=l\"))\n-   (clobber (match_scratch:DI 4 \"=h\"))\n-   (clobber (match_scratch:DI 6 \"=a\"))]\n+\t\t(match_operand:DI 2 \"se_register_operand\" \"d\"))) \n+   (clobber (match_scratch:DI 3 \"=h\"))\n+   (clobber (match_scratch:DI 4 \"=a\"))]\n   \"TARGET_64BIT && !optimize\"\n   \"\n {\n-  /* MIPS16 needs div/rem ops in registers. */\n-  if (TARGET_MIPS16)\n-    operands[2] = force_reg (DImode, operands[2]);\n+  rtx label;\n+\n+  emit_insn (gen_divdi3_internal (operands[0], operands[1], operands[2]));\n+  if (!TARGET_NO_CHECK_ZERO_DIV)\n+    {\n+      emit_insn (gen_div_trap (operands[2],\n+\t\t\t       copy_to_mode_reg (DImode, GEN_INT (0)),\n+\t\t\t       GEN_INT (0x7)));\n+    }\n+  if (TARGET_CHECK_RANGE_DIV)\n+    {\n+      emit_insn (gen_div_trap (operands[2],\n+\t\t\t       copy_to_mode_reg (DImode, GEN_INT (-1)),\n+\t\t\t       GEN_INT (0x6)));\n+      emit_insn (gen_div_trap (operands[2],\n+\t\t\t       copy_to_mode_reg (DImode, GEN_INT (0x80000000)),\n+\t\t\t       GEN_INT (0x6)));\n+    }\n+  \n+  DONE;\n }\")\n \n (define_insn \"divdi3_internal\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=l\")\n \t(div:DI (match_operand:DI 1 \"se_register_operand\" \"d\")\n-\t\t(match_operand:DI 2 \"se_nonmemory_operand\" \"di\")))]\n+\t\t(match_operand:DI 2 \"se_nonmemory_operand\" \"di\")))\n+   (clobber (match_scratch:SI 3 \"=h\"))\n+   (clobber (match_scratch:SI 4 \"=a\"))]\n   \"TARGET_64BIT && !optimize\"\n-  \"ddiv\\\\t%0,%1,%2\"\n+  \"ddiv\\\\t$0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n    (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"14\")])\t;; various tests for dividing by 0 and such\n+   (set_attr \"length\"\t\"1\")])\n \n (define_expand \"modsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=h\")\n \t(mod:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"di\")))\n+\t\t(match_operand:SI 2 \"register_operand\" \"d\")))\n    (clobber (match_scratch:SI 3 \"=l\"))\n-   (clobber (match_scratch:SI 4 \"=h\"))\n-   (clobber (match_scratch:SI 6 \"=a\"))]\n+   (clobber (match_scratch:SI 4 \"=a\"))]\n   \"!optimize\"\n   \"\n {\n-  /* MIPS16 needs div/rem ops in registers. */\n-  if (TARGET_MIPS16)\n-    operands[2] = force_reg (SImode, operands[2]);\n+  rtx label;\n+\n+  emit_insn (gen_modsi3_internal (operands[0], operands[1], operands[2]));\n+  if (!TARGET_NO_CHECK_ZERO_DIV)\n+    {\n+      emit_insn (gen_div_trap (operands[2],\n+\t\t\t       copy_to_mode_reg (SImode, GEN_INT (0)),\n+\t\t\t       GEN_INT (0x7)));\n+    }\n+  if (TARGET_CHECK_RANGE_DIV)\n+    {\n+      emit_insn (gen_div_trap (operands[2],\n+\t\t\t       copy_to_mode_reg (SImode, GEN_INT (-1)),\n+\t\t\t       GEN_INT (0x6)));\n+      emit_insn (gen_div_trap (operands[2],\n+\t\t\t       copy_to_mode_reg (SImode, GEN_INT (0x80000000)),\n+\t\t\t       GEN_INT (0x6)));\n+    }\n+  \n+  DONE;\n }\")\n \n (define_insn \"modsi3_internal\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=h\")\n \t(mod:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"di\")))]\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"di\")))\n+   (clobber (match_scratch:SI 3 \"=l\"))\n+   (clobber (match_scratch:SI 4 \"=a\"))]\n   \"!optimize\"\n-  \"rem\\\\t%0,%1,%2\"\n+  \"div\\\\t$0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"13\")])\t;; various tests for dividing by 0 and such\n+   (set_attr \"length\"\t\"1\")])\n \n (define_expand \"moddi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=h\")\n \t(mod:DI (match_operand:DI 1 \"se_register_operand\" \"d\")\n-\t\t(match_operand:DI 2 \"se_nonmemory_operand\" \"di\")))\n+\t\t(match_operand:DI 2 \"se_register_operand\" \"d\")))\n    (clobber (match_scratch:DI 3 \"=l\"))\n-   (clobber (match_scratch:DI 4 \"=h\"))\n-   (clobber (match_scratch:DI 6 \"=a\"))]\n+   (clobber (match_scratch:DI 4 \"=a\"))]\n   \"TARGET_64BIT && !optimize\"\n   \"\n {\n-  /* MIPS16 needs div/rem ops in registers. */\n-  if (TARGET_MIPS16)\n-    operands[2] = force_reg (DImode, operands[2]);\n+  rtx label;\n+\n+  emit_insn (gen_moddi3_internal (operands[0], operands[1], operands[2]));\n+  if (!TARGET_NO_CHECK_ZERO_DIV)\n+    {\n+      emit_insn (gen_div_trap (operands[2],\n+\t\t\t       copy_to_mode_reg (DImode, GEN_INT (0)),\n+\t\t\t       GEN_INT (0x7)));\n+    }\n+  if (TARGET_CHECK_RANGE_DIV)\n+    {\n+      emit_insn (gen_div_trap (operands[2],\n+\t\t\t       copy_to_mode_reg (DImode, GEN_INT (-1)),\n+\t\t\t       GEN_INT (0x6)));\n+      emit_insn (gen_div_trap (operands[2],\n+\t\t\t       copy_to_mode_reg (DImode, GEN_INT (0x80000000)),\n+\t\t\t       GEN_INT (0x6)));\n+    }\n+  \n+  DONE;\n }\")\n \n (define_insn \"moddi3_internal\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=h\")\n \t(mod:DI (match_operand:DI 1 \"se_register_operand\" \"d\")\n-\t\t(match_operand:DI 2 \"se_nonmemory_operand\" \"di\")))]\n+\t\t(match_operand:DI 2 \"se_nonmemory_operand\" \"di\")))\n+   (clobber (match_scratch:SI 3 \"=l\"))\n+   (clobber (match_scratch:SI 4 \"=a\"))]\n   \"TARGET_64BIT && !optimize\"\n-  \"drem\\\\t%0,%1,%2\"\n+  \"ddiv\\\\t$0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n    (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"14\")])\t;; various tests for dividing by 0 and such\n+   (set_attr \"length\"\t\"1\")])\n \n (define_expand \"udivsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n \t(udiv:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"di\")))\n-   (clobber (match_scratch:SI 3 \"=l\"))\n-   (clobber (match_scratch:SI 4 \"=h\"))\n-   (clobber (match_scratch:SI 6 \"=a\"))]\n+\t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n+   (clobber (match_scratch:SI 3 \"=h\"))\n+   (clobber (match_scratch:SI 4 \"=a\"))]\n   \"!optimize\"\n   \"\n {\n-  /* MIPS16 needs div/rem ops in registers. */\n-  if (TARGET_MIPS16)\n-    operands[2] = force_reg (SImode, operands[2]);\n+  rtx label;\n+\n+  emit_insn (gen_udivsi3_internal (operands[0], operands[1], operands[2]));\n+  if (!TARGET_NO_CHECK_ZERO_DIV)\n+    {\n+      emit_insn (gen_div_trap (operands[2],\n+\t\t\t       copy_to_mode_reg (SImode, GEN_INT (0)),\n+\t\t\t       GEN_INT (0x7)));\n+    }\n+  \n+  DONE;\n }\")\n \n (define_insn \"udivsi3_internal\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n \t(udiv:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"di\")))]\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"di\")))\n+   (clobber (match_scratch:SI 3 \"=h\"))\n+   (clobber (match_scratch:SI 4 \"=a\"))]\n   \"!optimize\"\n-  \"divu\\\\t%0,%1,%2\"\n+  \"divu\\\\t$0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"7\")])\t;; various tests for dividing by 0 and such\n+   (set_attr \"length\"\t\"1\")])\n \n (define_expand \"udivdi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=l\")\n \t(udiv:DI (match_operand:DI 1 \"se_register_operand\" \"d\")\n-\t\t (match_operand:DI 2 \"se_nonmemory_operand\" \"di\")))\n-   (clobber (match_scratch:DI 3 \"=l\"))\n-   (clobber (match_scratch:DI 4 \"=h\"))\n-   (clobber (match_scratch:DI 6 \"=a\"))]\n+\t\t (match_operand:DI 2 \"se_register_operand\" \"di\")))\n+   (clobber (match_scratch:DI 3 \"=h\"))\n+   (clobber (match_scratch:DI 4 \"=a\"))]\n   \"TARGET_64BIT && !optimize\"\n   \"\n {\n-  /* MIPS16 needs div/rem ops in registers. */\n-  if (TARGET_MIPS16)\n-    operands[2] = force_reg (DImode, operands[2]);\n+  rtx label;\n+\n+  emit_insn (gen_udivdi3_internal (operands[0], operands[1], operands[2]));\n+  if (!TARGET_NO_CHECK_ZERO_DIV)\n+    {\n+      emit_insn (gen_div_trap (operands[2],\n+\t\t\t       copy_to_mode_reg (DImode, GEN_INT (0)),\n+\t\t\t       GEN_INT (0x7)));\n+    }\n+  \n+  DONE;\n }\")\n \n (define_insn \"udivdi3_internal\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=l\")\n \t(udiv:DI (match_operand:DI 1 \"se_register_operand\" \"d\")\n-\t\t (match_operand:DI 2 \"se_nonmemory_operand\" \"di\")))]\n+\t\t (match_operand:DI 2 \"se_nonmemory_operand\" \"di\")))\n+   (clobber (match_scratch:SI 3 \"=h\"))\n+   (clobber (match_scratch:SI 4 \"=a\"))]\n   \"TARGET_64BIT && !optimize\"\n-  \"ddivu\\\\t%0,%1,%2\"\n+  \"ddivu\\\\t$0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n    (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"7\")])\t;; various tests for dividing by 0 and such\n+   (set_attr \"length\"\t\"1\")])\n \n (define_expand \"umodsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=h\")\n \t(umod:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"di\")))\n+\t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n    (clobber (match_scratch:SI 3 \"=l\"))\n-   (clobber (match_scratch:SI 4 \"=h\"))\n-   (clobber (match_scratch:SI 6 \"=a\"))]\n+   (clobber (match_scratch:SI 4 \"=a\"))]\n   \"!optimize\"\n   \"\n {\n-  /* MIPS16 needs div/rem ops in registers. */\n-  if (TARGET_MIPS16)\n-    operands[2] = force_reg (SImode, operands[2]);\n+  rtx label;\n+\n+  emit_insn (gen_umodsi3_internal (operands[0], operands[1], operands[2]));\n+  if (!TARGET_NO_CHECK_ZERO_DIV)\n+    {\n+      emit_insn (gen_div_trap (operands[2],\n+\t\t\t       copy_to_mode_reg (SImode, GEN_INT (0)),\n+\t\t\t       GEN_INT (0x7)));\n+    }\n+  \n+  DONE;\n }\")\n \n (define_insn \"umodsi3_internal\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=h\")\n \t(umod:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"di\")))]\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"di\")))\n+   (clobber (match_scratch:SI 3 \"=l\"))\n+   (clobber (match_scratch:SI 4 \"=a\"))]\n   \"!optimize\"\n-  \"remu\\\\t%0,%1,%2\"\n+  \"divu\\\\t$0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"7\")])\t;; various tests for dividing by 0 and such\n+   (set_attr \"length\"\t\"1\")])\n \n (define_expand \"umoddi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=h\")\n \t(umod:DI (match_operand:DI 1 \"se_register_operand\" \"d\")\n-\t\t (match_operand:DI 2 \"se_nonmemory_operand\" \"di\")))\n+\t\t (match_operand:DI 2 \"se_register_operand\" \"di\")))\n    (clobber (match_scratch:DI 3 \"=l\"))\n-   (clobber (match_scratch:DI 4 \"=h\"))\n-   (clobber (match_scratch:DI 6 \"=a\"))]\n+   (clobber (match_scratch:DI 4 \"=a\"))]\n   \"TARGET_64BIT && !optimize\"\n   \"\n {\n-  /* MIPS16 needs div/rem ops in registers. */\n-  if (TARGET_MIPS16)\n-    operands[2] = force_reg (DImode, operands[2]);\n+  rtx label;\n+\n+  emit_insn (gen_umoddi3_internal (operands[0], operands[1], operands[2]));\n+  if (!TARGET_NO_CHECK_ZERO_DIV)\n+    {\n+      emit_insn (gen_div_trap (operands[2],\n+\t\t\t       copy_to_mode_reg (DImode, GEN_INT (0)),\n+\t\t\t       GEN_INT (0x7)));\n+    }\n+  \n+  DONE;\n }\")\n \n (define_insn \"umoddi3_internal\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=h\")\n \t(umod:DI (match_operand:DI 1 \"se_register_operand\" \"d\")\n-\t\t (match_operand:DI 2 \"se_nonmemory_operand\" \"di\")))]\n+\t\t (match_operand:DI 2 \"se_nonmemory_operand\" \"di\")))\n+   (clobber (match_scratch:SI 3 \"=l\"))\n+   (clobber (match_scratch:SI 4 \"=a\"))]\n   \"TARGET_64BIT && !optimize\"\n-  \"dremu\\\\t%0,%1,%2\"\n+  \"ddivu\\\\t$0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n    (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"7\")])\t;; various tests for dividing by 0 and such\n-\n+   (set_attr \"length\"\t\"1\")])\n \f\n ;;\n ;;  ...................."}]}