{"sha": "c00e272ed3f6c7cb31b9f6777a9f0753ed414340", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAwZTI3MmVkM2Y2YzdjYjMxYjlmNjc3N2E5ZjA3NTNlZDQxNDM0MA==", "commit": {"author": {"name": "Joel Sherrill", "email": "joel@OARcorp.com", "date": "2004-04-08T17:54:03Z"}, "committer": {"name": "Joel Sherrill", "email": "joel@gcc.gnu.org", "date": "2004-04-08T17:54:03Z"}, "message": "re PR ada/14538 (*-rtems broken for gnat)\n\n2004-04-08  Joel Sherrill <joel@oarcorp.com>\n\n\tPR ada/14538\n\t* ada/5rosinte.adb: Remove fake mprotect() body.\n\t* ada/5rosinte.ads: Add SA_SIGINFO.\n\t* ada/5rtpopsp.adb: Rewrite to use new interface.\n\t* ada/init.c: Reorder so the simple single OS conditional __rtems__\n\tis tested before more complex ones which mix UNIX and embedded\n\tsystems in the conditional.\n\nFrom-SVN: r80517", "tree": {"sha": "ac68fae9acea022241c01614bfabb10c23c1bec3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac68fae9acea022241c01614bfabb10c23c1bec3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c00e272ed3f6c7cb31b9f6777a9f0753ed414340", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c00e272ed3f6c7cb31b9f6777a9f0753ed414340", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c00e272ed3f6c7cb31b9f6777a9f0753ed414340", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c00e272ed3f6c7cb31b9f6777a9f0753ed414340/comments", "author": null, "committer": null, "parents": [{"sha": "4afae4b9c87a32dd832f2b28670a8e074982db98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4afae4b9c87a32dd832f2b28670a8e074982db98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4afae4b9c87a32dd832f2b28670a8e074982db98"}], "stats": {"total": 264, "additions": 60, "deletions": 204}, "files": [{"sha": "ac6a4119438b46195bf57fefabd30e99160a8985", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c00e272ed3f6c7cb31b9f6777a9f0753ed414340/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c00e272ed3f6c7cb31b9f6777a9f0753ed414340/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c00e272ed3f6c7cb31b9f6777a9f0753ed414340", "patch": "@@ -1,3 +1,13 @@\n+2004-04-08  Joel Sherrill <joel@oarcorp.com>\n+\n+\tPR ada/14538\n+\t* ada/5rosinte.adb: Remove fake mprotect() body.\n+\t* ada/5rosinte.ads: Add SA_SIGINFO.\n+\t* ada/5rtpopsp.adb: Rewrite to use new interface.\n+\t* ada/init.c: Reorder so the simple single OS conditional __rtems__\n+\tis tested before more complex ones which mix UNIX and embedded\n+\tsystems in the conditional.\n+\n 2004-04-08  Joel Sherrill  <joel@oarcorp.com>\n \n \tPR ada/14665"}, {"sha": "1bb1ae50a8b63d8b802b641edb08eaf274fbc0fb", "filename": "gcc/ada/5rosinte.adb", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c00e272ed3f6c7cb31b9f6777a9f0753ed414340/gcc%2Fada%2F5rosinte.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c00e272ed3f6c7cb31b9f6777a9f0753ed414340/gcc%2Fada%2F5rosinte.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5rosinte.adb?ref=c00e272ed3f6c7cb31b9f6777a9f0753ed414340", "patch": "@@ -118,10 +118,4 @@ package body System.OS_Interface is\n       return 0;\n    end Get_Page_Size;\n \n-   function mprotect\n-     (addr : Address; len : size_t; prot : int) return int is\n-   begin\n-      return 0;\n-   end mprotect;\n-\n end System.OS_Interface;"}, {"sha": "c82ea1559ec1dd439f04c792743fb55c2610bbdd", "filename": "gcc/ada/5rosinte.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c00e272ed3f6c7cb31b9f6777a9f0753ed414340/gcc%2Fada%2F5rosinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c00e272ed3f6c7cb31b9f6777a9f0753ed414340/gcc%2Fada%2F5rosinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5rosinte.ads?ref=c00e272ed3f6c7cb31b9f6777a9f0753ed414340", "patch": "@@ -139,6 +139,8 @@ package System.OS_Interface is\n    pragma Convention (C, struct_sigaction);\n    type struct_sigaction_ptr is access all struct_sigaction;\n \n+   SA_SIGINFO  : constant := 16#02#;\n+\n    SIG_BLOCK   : constant := 1;\n    SIG_UNBLOCK : constant := 2;\n    SIG_SETMASK : constant := 3;\n@@ -261,7 +263,7 @@ package System.OS_Interface is\n    PROT_OFF : constant := 0;\n \n    function mprotect (addr : Address; len : size_t; prot : int) return int;\n-   --  Do nothing on RTEMS.\n+   pragma Import (C, mprotect);\n \n    -----------------------------------------\n    --  Nonstandard Thread Initialization  --"}, {"sha": "c75356fdaebd3a60a4bb82a6d81a5fbdfd0fdcda", "filename": "gcc/ada/5rtpopsp.adb", "status": "modified", "additions": 31, "deletions": 181, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c00e272ed3f6c7cb31b9f6777a9f0753ed414340/gcc%2Fada%2F5rtpopsp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c00e272ed3f6c7cb31b9f6777a9f0753ed414340/gcc%2Fada%2F5rtpopsp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5rtpopsp.adb?ref=c00e272ed3f6c7cb31b9f6777a9f0753ed414340", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---                             $Revision: 1.7 $\n+--                             $Revision: 1.2 $\n --                                                                          --\n --            Copyright (C) 1991-2003, Florida State University             --\n --                                                                          --\n@@ -35,183 +35,48 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is a POSIX version of this package where foreign threads are\n---  recognized.\n---  Currently, DEC Unix, SCO UnixWare 7 and RTEMS use this version.\n-\n-with System.Soft_Links;\n---  used to initialize TSD for a C thread, in function Self\n+--  This is a RTEMS version of this package which uses a special\n+--  variable for Ada self which is contexted switch implicitly by RTEMS.\n+--\n+--  This is the same as the POSIX version except that an RTEMS variable\n+--  is used instead of a POSIX key.\n \n separate (System.Task_Primitives.Operations)\n package body Specific is\n \n-   ------------------\n-   --  Local Data  --\n-   ------------------\n-\n-   --  The followings are logically constants, but need to be initialized\n-   --  at run time.\n-\n    --  The following gives the Ada run-time direct access to a variable\n    --  context switched by RTEMS at the lowest level.\n \n    RTEMS_Ada_Self : System.Address;\n    pragma Import (C, RTEMS_Ada_Self, \"rtems_ada_self\");\n \n-   --  The following are used to allow the Self function to\n-   --  automatically generate ATCB's for C threads that happen to call\n-   --  Ada procedure, which in turn happen to call the Ada runtime system.\n-\n-   type Fake_ATCB;\n-   type Fake_ATCB_Ptr is access Fake_ATCB;\n-   type Fake_ATCB is record\n-      Stack_Base : Interfaces.C.unsigned := 0;\n-      --  A value of zero indicates the node is not in use.\n-      Next : Fake_ATCB_Ptr;\n-      Real_ATCB : aliased Ada_Task_Control_Block (0);\n-   end record;\n-\n-   Fake_ATCB_List : Fake_ATCB_Ptr;\n-   --  A linear linked list.\n-   --  The list is protected by All_Tasks_L;\n-   --  Nodes are added to this list from the front.\n-   --  Once a node is added to this list, it is never removed.\n-\n-   Fake_Task_Elaborated : aliased Boolean := True;\n-   --  Used to identified fake tasks (i.e., non-Ada Threads).\n-\n-   Next_Fake_ATCB : Fake_ATCB_Ptr;\n-   --  Used to allocate one Fake_ATCB in advance. See comment in New_Fake_ATCB\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   ---------------------------------\n-   --  Support for New_Fake_ATCB  --\n-   ---------------------------------\n-\n-   function New_Fake_ATCB return Task_ID;\n-   --  Allocate and Initialize a new ATCB. This code can safely be called from\n-   --  a foreign thread, as it doesn't access implicitely or explicitely\n-   --  \"self\" before having initialized the new ATCB.\n-\n-   -------------------\n-   -- New_Fake_ATCB --\n-   -------------------\n-\n-   function New_Fake_ATCB return Task_ID is\n-      Self_ID   : Task_ID;\n-      P, Q      : Fake_ATCB_Ptr;\n-      Succeeded : Boolean;\n-\n-   begin\n-      --  This section is ticklish.\n-      --  We dare not call anything that might require an ATCB, until\n-      --  we have the new ATCB in place.\n-\n-      Write_Lock (All_Tasks_L'Access);\n-      Q := null;\n-      P := Fake_ATCB_List;\n-\n-      while P /= null loop\n-         if P.Stack_Base = 0 then\n-            Q := P;\n-         end if;\n-\n-         P := P.Next;\n-      end loop;\n-\n-      if Q = null then\n-\n-         --  Create a new ATCB with zero entries.\n-\n-         Self_ID := Next_Fake_ATCB.Real_ATCB'Access;\n-         Next_Fake_ATCB.Stack_Base := 1;\n-         Next_Fake_ATCB.Next := Fake_ATCB_List;\n-         Fake_ATCB_List := Next_Fake_ATCB;\n-         Next_Fake_ATCB := null;\n-\n-      else\n-         --  Reuse an existing fake ATCB.\n-\n-         Self_ID := Q.Real_ATCB'Access;\n-         Q.Stack_Base := 1;\n-      end if;\n-\n-      --  Record this as the Task_ID for the current thread.\n-\n-      Self_ID.Common.LL.Thread := pthread_self;\n-\n-      RTEMS_Ada_Self := To_Address (Self_ID);\n-\n-      --  Do the standard initializations\n-\n-      System.Tasking.Initialize_ATCB\n-        (Self_ID, null, Null_Address, Null_Task, Fake_Task_Elaborated'Access,\n-         System.Priority'First, Task_Info.Unspecified_Task_Info, 0, Self_ID,\n-         Succeeded);\n-      pragma Assert (Succeeded);\n-\n-      --  Finally, it is safe to use an allocator in this thread.\n-\n-      if Next_Fake_ATCB = null then\n-         Next_Fake_ATCB := new Fake_ATCB;\n-      end if;\n-\n-      Self_ID.Common.State := Runnable;\n-      Self_ID.Awake_Count := 1;\n-\n-      --  Since this is not an ordinary Ada task, we will start out undeferred\n-\n-      Self_ID.Deferral_Level := 0;\n-\n-      System.Soft_Links.Create_TSD (Self_ID.Common.Compiler_Data);\n-\n-      --  ????\n-      --  The following call is commented out to avoid dependence on\n-      --  the System.Tasking.Initialization package.\n-      --  It seems that if we want Ada.Task_Attributes to work correctly\n-      --  for C threads we will need to raise the visibility of this soft\n-      --  link to System.Soft_Links.\n-      --  We are putting that off until this new functionality is otherwise\n-      --  stable.\n-      --  System.Tasking.Initialization.Initialize_Attributes_Link.all (T);\n-\n-      for J in Known_Tasks'Range loop\n-         if Known_Tasks (J) = null then\n-            Known_Tasks (J) := Self_ID;\n-            Self_ID.Known_Tasks_Index := J;\n-            exit;\n-         end if;\n-      end loop;\n-\n-      --  Must not unlock until Next_ATCB is again allocated.\n-\n-      Unlock (All_Tasks_L'Access);\n-      return Self_ID;\n-   end New_Fake_ATCB;\n-\n    ----------------\n    -- Initialize --\n    ----------------\n \n    procedure Initialize (Environment_Task : Task_ID) is\n+      pragma Warnings (Off, Environment_Task);\n+      Result : Interfaces.C.int;\n \n    begin\n       RTEMS_Ada_Self := To_Address (Environment_Task);\n+   end Initialize;\n \n-      --  Create a free ATCB for use on the Fake_ATCB_List.\n+   -------------------\n+   -- Is_Valid_Task --\n+   -------------------\n \n-      Next_Fake_ATCB := new Fake_ATCB;\n-   end Initialize;\n+   function Is_Valid_Task return Boolean is\n+   begin\n+      return RTEMS_Ada_Self /= System.Null_Address;\n+   end Is_Valid_Task;\n \n    ---------\n    -- Set --\n    ---------\n \n    procedure Set (Self_Id : Task_ID) is\n-\n+      Result : Interfaces.C.int;\n    begin\n       RTEMS_Ada_Self := To_Address (Self_Id);\n    end Set;\n@@ -220,33 +85,18 @@ package body Specific is\n    -- Self --\n    ----------\n \n-   --  To make Ada tasks and C threads interoperate better, we have\n-   --  added some functionality to Self.  Suppose a C main program\n-   --  (with threads) calls an Ada procedure and the Ada procedure\n-   --  calls the tasking runtime system.  Eventually, a call will be\n-   --  made to self.  Since the call is not coming from an Ada task,\n-   --  there will be no corresponding ATCB.\n-\n-   --  (The entire Ada run-time system may not have been elaborated,\n-   --  either, but that is a different problem, that we will need to\n-   --  solve another way.)\n-\n-   --  What we do in Self is to catch references that do not come\n-   --  from recognized Ada tasks, and create an ATCB for the calling\n-   --  thread.\n+   --  To make Ada tasks and C threads interoperate better, we have added some\n+   --  functionality to Self. Suppose a C main program (with threads) calls an\n+   --  Ada procedure and the Ada procedure calls the tasking runtime system.\n+   --  Eventually, a call will be made to self. Since the call is not coming\n+   --  from an Ada task, there will be no corresponding ATCB.\n \n-   --  The new ATCB will be \"detached\" from the normal Ada task\n-   --  master hierarchy, much like the existing implicitly created\n-   --  signal-server tasks.\n+   --  What we do in Self is to catch references that do not come from\n+   --  recognized Ada tasks, and create an ATCB for the calling thread.\n \n-   --  We will also use such points to poll for disappearance of the\n-   --  threads associated with any implicit ATCBs that we created\n-   --  earlier, and take the opportunity to recover them.\n-\n-   --  A nasty problem here is the limitations of the compilation\n-   --  order dependency, and in particular the GNARL/GNULLI layering.\n-   --  To initialize an ATCB we need to assume System.Tasking has\n-   --  been elaborated.\n+   --  The new ATCB will be \"detached\" from the normal Ada task master\n+   --  hierarchy, much like the existing implicitly created signal-server\n+   --  tasks.\n \n    function Self return Task_ID is\n       Result : System.Address;\n@@ -256,11 +106,11 @@ package body Specific is\n \n       --  If the key value is Null, then it is a non-Ada task.\n \n-      if Result = System.Null_Address then\n-         return New_Fake_ATCB;\n+      if Result /= System.Null_Address then\n+         return To_Task_Id (Result);\n+      else\n+         return Register_Foreign_Thread;\n       end if;\n-\n-      return To_Task_ID (Result);\n    end Self;\n \n end Specific;"}, {"sha": "efc1a25fc2a47c0f706466b8e8a671a09c9d34c7", "filename": "gcc/ada/init.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c00e272ed3f6c7cb31b9f6777a9f0753ed414340/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c00e272ed3f6c7cb31b9f6777a9f0753ed414340/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=c00e272ed3f6c7cb31b9f6777a9f0753ed414340", "patch": "@@ -359,6 +359,22 @@ __gnat_initialize (void)\n {\n }\n \n+/***************************************/\n+/* __gnat_initialize (RTEMS version) */\n+/***************************************/\n+\n+#elif defined(__rtems__)\n+\n+extern void __gnat_install_handler (void);\n+\n+/* For RTEMS, each bsp will provide a custom __gnat_install_handler (). */\n+\n+void\n+__gnat_initialize (void)\n+{\n+   __gnat_install_handler ();\n+}\n+\n /****************************************/\n /* __gnat_initialize (Dec Unix Version) */\n /****************************************/\n@@ -1887,22 +1903,6 @@ __gnat_initialize (void)\n   __gnat_init_float ();\n }\n \n-/***************************************/\n-/* __gnat_initialize (RTEMS version) */\n-/***************************************/\n-\n-#elif defined(__rtems__)\n-\n-extern void __gnat_install_handler (void);\n-\n-/* For RTEMS, each bsp will provide a custom __gnat_install_handler (). */\n-\n-void\n-__gnat_initialize (void)\n-{\n-   __gnat_install_handler ();\n-}\n-\n #else\n \n /* For all other versions of GNAT, the initialize routine and handler"}]}