{"sha": "d8f7b976d7f6ba52d1b71770c6d03ff408294b18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDhmN2I5NzZkN2Y2YmE1MmQxYjcxNzcwYzZkMDNmZjQwODI5NGIxOA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2006-02-15T09:37:33Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-02-15T09:37:33Z"}, "message": "exp_aggr.adb (Build_Array_Aggr_Code): Rename variable \"Others_Mbox_Present\" to \"Others_Box_Present\" because the mbox...\n\n2006-02-13  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_aggr.adb (Build_Array_Aggr_Code): Rename variable\n\t\"Others_Mbox_Present\" to \"Others_Box_Present\" because the mbox concept\n\tdoes not exist in the Ada RM.\n\t(Compatible_Int_Bounds): Determine whether two integer range bounds\n\tare of equal length and have the same start and end values.\n\t(Is_Int_Range_Bounds): Determine whether a node is an integer range.\n\t(Build_Record_Aggr_Code): Perform proper sliding of a nested array\n\taggregate when it is part of an object declaration.\n\t(Build_Record_Aggr_Code)  If the aggregate ttype is a derived type that\n\tconstrains discriminants of its parent, add explicitly the discriminant\n\tconstraints of the ancestor by retrieving them from the\n\tstored_constraint of the parent.\n\nFrom-SVN: r111057", "tree": {"sha": "d267110108382a32072ef46ea1481ea04c204e4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d267110108382a32072ef46ea1481ea04c204e4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8f7b976d7f6ba52d1b71770c6d03ff408294b18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8f7b976d7f6ba52d1b71770c6d03ff408294b18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8f7b976d7f6ba52d1b71770c6d03ff408294b18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8f7b976d7f6ba52d1b71770c6d03ff408294b18/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2c351f04f4026e765c15fcb5a74c809573dc666a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c351f04f4026e765c15fcb5a74c809573dc666a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c351f04f4026e765c15fcb5a74c809573dc666a"}], "stats": {"total": 236, "additions": 212, "deletions": 24}, "files": [{"sha": "f4fb029cfe52246e1d15d38a68d78e7a2e7fb651", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 212, "deletions": 24, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8f7b976d7f6ba52d1b71770c6d03ff408294b18/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8f7b976d7f6ba52d1b71770c6d03ff408294b18/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=d8f7b976d7f6ba52d1b71770c6d03ff408294b18", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -850,7 +850,7 @@ package body Exp_Aggr is\n             --  Ada 2005 (AI-287): Do nothing else in case of default\n             --  initialized component.\n \n-            if not Present (Expr) then\n+            if No (Expr) then\n                return Lis;\n \n             elsif Nkind (Parent (Expr)) = N_Component_Association\n@@ -918,7 +918,7 @@ package body Exp_Aggr is\n          --  Ada 2005 (AI-287): In case of default initialized component, Expr\n          --  is not present (and therefore we also initialize Expr_Q to empty).\n \n-         if not Present (Expr) then\n+         if No (Expr) then\n             Expr_Q := Empty;\n          elsif Nkind (Expr) = N_Qualified_Expression then\n             Expr_Q := Expression (Expr);\n@@ -1018,8 +1018,7 @@ package body Exp_Aggr is\n          --  Ada 2005 (AI-287): In case of default initialized component, call\n          --  the initialization subprogram associated with the component type.\n \n-         if not Present (Expr) then\n-\n+         if No (Expr) then\n             if Present (Base_Init_Proc (Etype (Ctype)))\n               or else Has_Task (Base_Type (Ctype))\n             then\n@@ -1143,7 +1142,7 @@ package body Exp_Aggr is\n             --  Ada 2005 (AI-287): Nothing else need to be done in case of\n             --  default initialized component.\n \n-            if not Present (Expr) then\n+            if No (Expr) then\n                null;\n \n             else\n@@ -1376,8 +1375,8 @@ package body Exp_Aggr is\n       Expr   : Node_Id;\n       Typ    : Entity_Id;\n \n-      Others_Expr         : Node_Id := Empty;\n-      Others_Mbox_Present : Boolean := False;\n+      Others_Expr        : Node_Id := Empty;\n+      Others_Box_Present : Boolean := False;\n \n       Aggr_L : constant Node_Id := Low_Bound (Aggregate_Bounds (N));\n       Aggr_H : constant Node_Id := High_Bound (Aggregate_Bounds (N));\n@@ -1439,7 +1438,7 @@ package body Exp_Aggr is\n                   Set_Loop_Actions (Assoc, New_List);\n \n                   if Box_Present (Assoc) then\n-                     Others_Mbox_Present := True;\n+                     Others_Box_Present := True;\n                   else\n                      Others_Expr := Expression (Assoc);\n                   end if;\n@@ -1489,7 +1488,7 @@ package body Exp_Aggr is\n          --  We don't need to generate loops over empty gaps, but if there is\n          --  a single empty range we must analyze the expression for semantics\n \n-         if Present (Others_Expr) or else Others_Mbox_Present then\n+         if Present (Others_Expr) or else Others_Box_Present then\n             declare\n                First : Boolean := True;\n \n@@ -1621,10 +1620,6 @@ package body Exp_Aggr is\n       Attach   : Node_Id;\n       Ctrl_Stuff_Done : Boolean := False;\n \n-      function Get_Constraint_Association (T : Entity_Id) return Node_Id;\n-      --  Returns the first discriminant association in the constraint\n-      --  associated with T, if any, otherwise returns Empty.\n-\n       function Ancestor_Discriminant_Value (Disc : Entity_Id) return Node_Id;\n       --  Returns the value that the given discriminant of an ancestor\n       --  type should receive (in the absence of a conflict with the\n@@ -1636,6 +1631,20 @@ package body Exp_Aggr is\n       --  values provided by either an association of the aggregate or\n       --  by the constraint imposed by a parent type (RM95-4.3.2(8)).\n \n+      function Compatible_Int_Bounds\n+        (Agg_Bounds : Node_Id;\n+         Typ_Bounds : Node_Id) return Boolean;\n+      --  Return true if Agg_Bounds are equal or within Typ_Bounds. It is\n+      --  assumed that both bounds are integer ranges.\n+\n+      procedure Gen_Ctrl_Actions_For_Aggr;\n+      --  Deal with the various controlled type data structure\n+      --  initializations.\n+\n+      function Get_Constraint_Association (T : Entity_Id) return Node_Id;\n+      --  Returns the first discriminant association in the constraint\n+      --  associated with T, if any, otherwise returns Empty.\n+\n       function Init_Controller\n         (Target  : Node_Id;\n          Typ     : Entity_Id;\n@@ -1647,9 +1656,9 @@ package body Exp_Aggr is\n       --  it to finalization list F. Init_Pr conditions the call to the\n       --  init proc since it may already be done due to ancestor initialization\n \n-      procedure Gen_Ctrl_Actions_For_Aggr;\n-      --  Deal with the various controlled type data structure\n-      --  initializations\n+      function Is_Int_Range_Bounds (Bounds : Node_Id) return Boolean;\n+      --  Check whether Bounds is a range node and its lower and higher bounds\n+      --  are integers literals.\n \n       ---------------------------------\n       -- Ancestor_Discriminant_Value --\n@@ -1811,6 +1820,22 @@ package body Exp_Aggr is\n          end loop;\n       end Check_Ancestor_Discriminants;\n \n+      ---------------------------\n+      -- Compatible_Int_Bounds --\n+      ---------------------------\n+\n+      function Compatible_Int_Bounds\n+        (Agg_Bounds : Node_Id;\n+         Typ_Bounds : Node_Id) return Boolean\n+      is\n+         Agg_Lo : constant Uint := Intval (Low_Bound  (Agg_Bounds));\n+         Agg_Hi : constant Uint := Intval (High_Bound (Agg_Bounds));\n+         Typ_Lo : constant Uint := Intval (Low_Bound  (Typ_Bounds));\n+         Typ_Hi : constant Uint := Intval (High_Bound (Typ_Bounds));\n+      begin\n+         return Typ_Lo <= Agg_Lo and then Agg_Hi <= Typ_Hi;\n+      end Compatible_Int_Bounds;\n+\n       --------------------------------\n       -- Get_Constraint_Association --\n       --------------------------------\n@@ -1909,6 +1934,17 @@ package body Exp_Aggr is\n          return L;\n       end Init_Controller;\n \n+      -------------------------\n+      -- Is_Int_Range_Bounds --\n+      -------------------------\n+\n+      function Is_Int_Range_Bounds (Bounds : Node_Id) return Boolean is\n+      begin\n+         return Nkind (Bounds) = N_Range\n+           and then Nkind (Low_Bound  (Bounds)) = N_Integer_Literal\n+           and then Nkind (High_Bound (Bounds)) = N_Integer_Literal;\n+      end Is_Int_Range_Bounds;\n+\n       -------------------------------\n       -- Gen_Ctrl_Actions_For_Aggr --\n       -------------------------------\n@@ -2307,12 +2343,62 @@ package body Exp_Aggr is\n          if Has_Discriminants (Typ)\n            and then not Is_Unchecked_Union (Base_Type (Typ))\n          then\n-            --  ??? The discriminants of the object not inherited in the type\n-            --  of the object should be initialized here\n+            --  If the type is derived, and constrains discriminants of the\n+            --  parent type, these discriminants are not components of the\n+            --  aggregate, and must be initialized explicitly. They are not\n+            --  visible components of the object, but can become visible with\n+            --  a view conversion to the ancestor.\n \n-            null;\n+            declare\n+               Btype      : Entity_Id;\n+               Parent_Type : Entity_Id;\n+               Disc        : Entity_Id;\n+               Discr_Val   : Elmt_Id;\n+\n+            begin\n+               Btype := Base_Type (Typ);\n+\n+               while Is_Derived_Type (Btype)\n+                  and then Present (Stored_Constraint (Btype))\n+               loop\n+                  Parent_Type := Etype (Btype);\n+\n+                  Disc := First_Discriminant (Parent_Type);\n+                  Discr_Val :=\n+                    First_Elmt (Stored_Constraint (Base_Type (Typ)));\n+                  while Present (Discr_Val) loop\n \n-            --  Generate discriminant init values\n+                     --  Only those discriminants of the parent that are not\n+                     --  renamed by discriminants of the derived type need to\n+                     --  be added explicitly.\n+\n+                     if not Is_Entity_Name (Node (Discr_Val))\n+                       or else\n+                         Ekind (Entity (Node (Discr_Val))) /= E_Discriminant\n+                     then\n+                        Comp_Expr :=\n+                          Make_Selected_Component (Loc,\n+                            Prefix        => New_Copy_Tree (Target),\n+                            Selector_Name => New_Occurrence_Of (Disc, Loc));\n+\n+                        Instr :=\n+                          Make_OK_Assignment_Statement (Loc,\n+                            Name       => Comp_Expr,\n+                            Expression => New_Copy_Tree (Node (Discr_Val)));\n+\n+                        Set_No_Ctrl_Actions (Instr);\n+                        Append_To (L, Instr);\n+                     end if;\n+\n+                     Next_Discriminant (Disc);\n+                     Next_Elmt (Discr_Val);\n+                  end loop;\n+\n+                  Btype := Base_Type (Parent_Type);\n+               end loop;\n+            end;\n+\n+            --  Generate discriminant init values for the visible discriminants\n \n             declare\n                Discriminant : Entity_Id;\n@@ -2461,9 +2547,111 @@ package body Exp_Aggr is\n             --  inner aggregate top-down.\n \n             if Is_Delayed_Aggregate (Expr_Q) then\n-               Append_List_To (L,\n-                 Late_Expansion (Expr_Q, Comp_Type, Comp_Expr,\n-                   Internal_Final_List));\n+\n+               --  We have the following case of aggregate nesting inside\n+               --  an object declaration:\n+\n+               --    type Arr_Typ is array (Integer range <>) of ...;\n+               --\n+               --    type Rec_Typ (...) is record\n+               --       Obj_Arr_Typ : Arr_Typ (A .. B);\n+               --    end record;\n+               --\n+               --    Obj_Rec_Typ : Rec_Typ := (...,\n+               --      Obj_Arr_Typ => (X => (...), Y => (...)));\n+\n+               --  The length of the ranges of the aggregate and Obj_Add_Typ\n+               --  are equal (B - A = Y - X), but they do not coincide (X /=\n+               --  A and B /= Y). This case requires array sliding which is\n+               --  performed in the following manner:\n+\n+               --    subtype Arr_Sub is Arr_Typ (X .. Y);\n+               --    Temp : Arr_Sub;\n+               --    Temp (X) := (...);\n+               --    ...\n+               --    Temp (Y) := (...);\n+               --    Obj_Rec_Typ.Obj_Arr_Typ := Temp;\n+\n+               if Present (Obj)\n+                 and then Ekind (Comp_Type) = E_Array_Subtype\n+                 and then Is_Int_Range_Bounds (Aggregate_Bounds (Expr_Q))\n+                 and then Is_Int_Range_Bounds (First_Index (Comp_Type))\n+                 and then not\n+                   Compatible_Int_Bounds (\n+                     Agg_Bounds => Aggregate_Bounds (Expr_Q),\n+                     Typ_Bounds => First_Index (Comp_Type))\n+               then\n+                  declare\n+                     --  Create the array subtype with bounds equal to those\n+                     --  of the corresponding aggregate.\n+\n+                     SubE : constant Entity_Id :=\n+                              Make_Defining_Identifier (Loc,\n+                                New_Internal_Name ('T'));\n+\n+                     SubD : constant Node_Id :=\n+                              Make_Subtype_Declaration (Loc,\n+                                Defining_Identifier =>\n+                                  SubE,\n+                                Subtype_Indication  =>\n+                                  Make_Subtype_Indication (Loc,\n+                                    Subtype_Mark => New_Reference_To (\n+                                      Etype (Comp_Type), Loc),\n+                                    Constraint =>\n+                                      Make_Index_Or_Discriminant_Constraint (\n+                                        Loc, Constraints => New_List (\n+                                          New_Copy_Tree (Aggregate_Bounds (\n+                                            Expr_Q))))));\n+\n+                     --  Create a temporary array of the above subtype which\n+                     --  will be used to capture the aggregate assignments.\n+\n+                     TmpE : constant Entity_Id :=\n+                              Make_Defining_Identifier (Loc,\n+                                New_Internal_Name ('A'));\n+\n+                     TmpD : constant Node_Id :=\n+                              Make_Object_Declaration (Loc,\n+                                Defining_Identifier =>\n+                                  TmpE,\n+                                Object_Definition   =>\n+                                  New_Reference_To (SubE, Loc));\n+\n+                  begin\n+                     Set_No_Initialization (TmpD);\n+                     Append_To (L, SubD);\n+                     Append_To (L, TmpD);\n+\n+                     --  Expand the aggregate into assignments to the temporary\n+                     --  array.\n+\n+                     Append_List_To (L,\n+                       Late_Expansion (Expr_Q, Comp_Type,\n+                         New_Reference_To (TmpE, Loc), Internal_Final_List));\n+\n+                     --  Slide\n+\n+                     Append_To (L,\n+                       Make_Assignment_Statement (Loc,\n+                         Name       => New_Copy_Tree (Comp_Expr),\n+                         Expression => New_Reference_To (TmpE, Loc)));\n+\n+                     --  Do not pass the original aggregate to Gigi as is\n+                     --  since it will potentially clobber the front or the\n+                     --  end of the array. Setting the expression to empty\n+                     --  is safe since all aggregates will be expanded into\n+                     --  assignments.\n+\n+                     Set_Expression (Parent (Obj), Empty);\n+                  end;\n+\n+               --  Normal case (sliding not required)\n+\n+               else\n+                  Append_List_To (L,\n+                    Late_Expansion (Expr_Q, Comp_Type, Comp_Expr,\n+                      Internal_Final_List));\n+               end if;\n \n             else\n                Instr :="}]}