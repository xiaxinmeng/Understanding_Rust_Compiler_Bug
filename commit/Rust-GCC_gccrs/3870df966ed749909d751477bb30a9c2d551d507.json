{"sha": "3870df966ed749909d751477bb30a9c2d551d507", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzg3MGRmOTY2ZWQ3NDk5MDlkNzUxNDc3YmIzMGE5YzJkNTUxZDUwNw==", "commit": {"author": {"name": "Steve Ellcey", "email": "sje@cup.hp.com", "date": "2002-12-09T18:07:58Z"}, "committer": {"name": "Steve Ellcey", "email": "sje@gcc.gnu.org", "date": "2002-12-09T18:07:58Z"}, "message": "hpux.h (TARGET_STRUCT_ARG_REG_LITTLE_ENDIAN): Remove definition\n\n\t* config/ia64/hpux.h (TARGET_STRUCT_ARG_REG_LITTLE_ENDIAN): Remove\n\tdefinition\n\t(MEMBER_TYPE_FORCES_BLK): Move.\n\t* config/ia64/ia64.c (ia64_function_arg): Use PARALLEL to pass\n\taggregate arguments.\n\t(ia64_function_value): Use PARALLEL to return aggregate values.\n\nFrom-SVN: r59963", "tree": {"sha": "18286932865028aec84c30868c4c358fb8204e2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18286932865028aec84c30868c4c358fb8204e2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3870df966ed749909d751477bb30a9c2d551d507", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3870df966ed749909d751477bb30a9c2d551d507", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3870df966ed749909d751477bb30a9c2d551d507", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3870df966ed749909d751477bb30a9c2d551d507/comments", "author": null, "committer": null, "parents": [{"sha": "9ac3e73b400c1a03a03977294c6331d59380fc42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ac3e73b400c1a03a03977294c6331d59380fc42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ac3e73b400c1a03a03977294c6331d59380fc42"}], "stats": {"total": 72, "additions": 55, "deletions": 17}, "files": [{"sha": "cef27a9144b08f84aeae03574c9d3ecd84dc349f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3870df966ed749909d751477bb30a9c2d551d507/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3870df966ed749909d751477bb30a9c2d551d507/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3870df966ed749909d751477bb30a9c2d551d507", "patch": "@@ -1,3 +1,12 @@\n+2002-12-09  Steve Ellcey  <sje@cup.hp.com>\n+\n+\t* config/ia64/hpux.h (TARGET_STRUCT_ARG_REG_LITTLE_ENDIAN): Remove\n+\tdefinition\n+\t(MEMBER_TYPE_FORCES_BLK): Move.\n+\t* config/ia64/ia64.c (ia64_function_arg): Use PARALLEL to pass\n+\taggregate arguments.\n+\t(ia64_function_value): Use PARALLEL to return aggregate values.\n+\n 2002-12-09  Steve Ellcey  <sje@cup.hp.com>\n \n \t* doc/tm.texi (FUNCTION_ARG_REG_LITTLE_ENDIAN): Remove definition."}, {"sha": "1e6f699835bdd6000b3464b2dc52f5be476f3007", "filename": "gcc/config/ia64/hpux.h", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3870df966ed749909d751477bb30a9c2d551d507/gcc%2Fconfig%2Fia64%2Fhpux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3870df966ed749909d751477bb30a9c2d551d507/gcc%2Fconfig%2Fia64%2Fhpux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fhpux.h?ref=3870df966ed749909d751477bb30a9c2d551d507", "patch": "@@ -108,9 +108,9 @@ do {\t\t\t\t\t\t\t\\\n    field to be treated as structures and not as the type of their\n    field.  Without this a structure with a single char will be\n    returned just like a char variable and that is wrong on HP-UX\n-   IA64.  TARGET_STRUCT_ARG_REG_LITTLE_ENDIAN triggers the special\n-   structure handling, this macro simply ensures that single field\n-   structures are always treated like structures.  */\n+   IA64.  */\n+\n+#define MEMBER_TYPE_FORCES_BLK(FIELD, MODE) (TREE_CODE (TREE_TYPE (FIELD)) != REAL_TYPE || (MODE == TFmode && !INTEL_EXTENDED_IEEE_FORMAT))\n \n /* ASM_OUTPUT_EXTERNAL_LIBCALL defaults to just a globalize_label call,\n    but that doesn't put out the @function type information which causes\n@@ -123,18 +123,6 @@ do {\t\t\t\t\t\t\t\t\\\n   ASM_OUTPUT_TYPE_DIRECTIVE (FILE, XSTR (FUN, 0), \"function\");\t\\\n } while (0)\n \n-#define MEMBER_TYPE_FORCES_BLK(FIELD, MODE) (TREE_CODE (TREE_TYPE (FIELD)) != REAL_TYPE || (MODE == TFmode && !INTEL_EXTENDED_IEEE_FORMAT))\n-\n-/* Override the setting of FUNCTION_ARG_REG_LITTLE_ENDIAN in\n-   defaults.h.  Setting this to true means that we are not passing\n-   structures in registers in the \"normal\" big-endian way.  See\n-   See section 8.5 of the \"Itanium Software Conventions and Runtime\n-   Architecture\", specifically Table 8-1 and the explanation of Byte 0\n-   alignment and LSB alignment and a description of how structures\n-   are passed.  */\n-\n-#define FUNCTION_ARG_REG_LITTLE_ENDIAN 1\n-\n #undef FUNCTION_ARG_PADDING\n #define FUNCTION_ARG_PADDING(MODE, TYPE) \\\n \tia64_hpux_function_arg_padding ((MODE), (TYPE))"}, {"sha": "daddb86a5531b1223f1935b6db522bce286831ca", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3870df966ed749909d751477bb30a9c2d551d507/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3870df966ed749909d751477bb30a9c2d551d507/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=3870df966ed749909d751477bb30a9c2d551d507", "patch": "@@ -3309,7 +3309,25 @@ ia64_function_arg (cum, mode, type, named, incoming)\n      happen when we have a SFmode HFA.  */\n   else if (((mode == TFmode) && ! INTEL_EXTENDED_IEEE_FORMAT)\n           || (! FLOAT_MODE_P (mode) || cum->fp_regs == MAX_ARGUMENT_SLOTS))\n-    return gen_rtx_REG (mode, basereg + cum->words + offset);\n+    {\n+      int byte_size = ((mode == BLKmode)\n+                       ? int_size_in_bytes (type) : GET_MODE_SIZE (mode));\n+      if (BYTES_BIG_ENDIAN\n+\t&& (mode == BLKmode || (type && AGGREGATE_TYPE_P (type)))\n+\t&& byte_size < UNITS_PER_WORD\n+\t&& byte_size > 0)\n+\t{\n+\t  rtx gr_reg = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t  gen_rtx_REG (DImode,\n+\t\t\t\t\t\t       (basereg + cum->words\n+\t\t\t\t\t\t\t+ offset)),\n+\t\t\t\t\t  const0_rtx);\n+\t  return gen_rtx_PARALLEL (mode, gen_rtvec (1, gr_reg));\n+\t}\n+      else\n+\treturn gen_rtx_REG (mode, basereg + cum->words + offset);\n+\n+    }\n \n   /* If there is a prototype, then FP values go in a FR register when\n      named, and in a GR registeer when unnamed.  */\n@@ -3596,7 +3614,30 @@ ia64_function_value (valtype, func)\n            ((mode != TFmode) || INTEL_EXTENDED_IEEE_FORMAT))\n     return gen_rtx_REG (mode, FR_ARG_FIRST);\n   else\n-    return gen_rtx_REG (mode, GR_RET_FIRST);\n+    {\n+      if (BYTES_BIG_ENDIAN\n+\t  && (mode == BLKmode || (valtype && AGGREGATE_TYPE_P (valtype))))\n+\t{\n+\t  rtx loc[8];\n+\t  int offset;\n+\t  int bytesize;\n+\t  int i;\n+\n+\t  offset = 0;\n+\t  bytesize = int_size_in_bytes (valtype);\n+\t  for (i = 0; offset < bytesize; i++)\n+\t    {\n+\t      loc[i] = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t  gen_rtx_REG (DImode,\n+\t\t\t\t\t\t       GR_RET_FIRST + i),\n+\t\t\t\t\t  GEN_INT (offset));\n+\t      offset += UNITS_PER_WORD;\n+\t    }\n+\t  return gen_rtx_PARALLEL (mode, gen_rtvec_v (i, loc));\n+\t}\n+      else\n+\treturn gen_rtx_REG (mode, GR_RET_FIRST);\n+    }\n }\n \n /* Print a memory address as an operand to reference that memory location.  */"}]}