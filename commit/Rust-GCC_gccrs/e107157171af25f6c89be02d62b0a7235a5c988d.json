{"sha": "e107157171af25f6c89be02d62b0a7235a5c988d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTEwNzE1NzE3MWFmMjVmNmM4OWJlMDJkNjJiMGE3MjM1YTVjOTg4ZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-05-19T12:02:04Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-05-19T12:08:11Z"}, "message": "openmp: Add basic library allocator support.\n\nThis patch adds very basic allocator support (omp_{init,destroy}_allocator,\nomp_{alloc,free}, omp_[sg]et_default_allocator).\nThe plan is to use memkind (likely dlopened) for high bandwidth memory, but\nthat part isn't implemented yet, probably mlock for pinned memory and see\nwhat other options there are for other kinds of memory.\nFor offloading targets, we need to decide if we want to support the\ndynamic allocators (and on which targets), or if e.g. all we do is at compile\ntime replace omp_alloc/omp_free calls with constexpr predefined allocators\nwith something special.\n\nAnd allocate directive and allocator/uses_allocators clauses are future work\ntoo.\n\n2020-05-19  Jakub Jelinek  <jakub@redhat.com>\n\n\t* allocator.c: New file.", "tree": {"sha": "eb61f48565760dba8914fe6820c35c367c0fd205", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb61f48565760dba8914fe6820c35c367c0fd205"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e107157171af25f6c89be02d62b0a7235a5c988d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e107157171af25f6c89be02d62b0a7235a5c988d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e107157171af25f6c89be02d62b0a7235a5c988d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e107157171af25f6c89be02d62b0a7235a5c988d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f85a52c9424bb9ac606ec0f6f3da30e020161ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f85a52c9424bb9ac606ec0f6f3da30e020161ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f85a52c9424bb9ac606ec0f6f3da30e020161ad"}], "stats": {"total": 354, "additions": 354, "deletions": 0}, "files": [{"sha": "8592de6e2b5b3a763a8c1280c2c310d140779499", "filename": "libgomp/allocator.c", "status": "added", "additions": 354, "deletions": 0, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e107157171af25f6c89be02d62b0a7235a5c988d/libgomp%2Fallocator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e107157171af25f6c89be02d62b0a7235a5c988d/libgomp%2Fallocator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fallocator.c?ref=e107157171af25f6c89be02d62b0a7235a5c988d", "patch": "@@ -0,0 +1,354 @@\n+/* Copyright (C) 2020 Free Software Foundation, Inc.\n+   Contributed by Jakub Jelinek <jakub@redhat.com>.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file contains wrappers for the system allocation routines.  Most\n+   places in the OpenMP API do not make any provision for failure, so in\n+   general we cannot allow memory allocation to fail.  */\n+\n+#define _GNU_SOURCE\n+#include \"libgomp.h\"\n+#include <stdlib.h>\n+\n+#define omp_max_predefined_alloc omp_thread_mem_alloc\n+\n+struct omp_allocator_data\n+{\n+  omp_memspace_handle_t memspace;\n+  omp_uintptr_t alignment;\n+  omp_uintptr_t pool_size;\n+  omp_uintptr_t used_pool_size;\n+  omp_allocator_handle_t fb_data;\n+  unsigned int sync_hint : 8;\n+  unsigned int access : 8;\n+  unsigned int fallback : 8;\n+  unsigned int pinned : 1;\n+  unsigned int partition : 7;\n+#ifndef HAVE_SYNC_BUILTINS\n+  gomp_mutex_t lock;\n+#endif\n+};\n+\n+struct omp_mem_header\n+{\n+  void *ptr;\n+  size_t size;\n+  omp_allocator_handle_t allocator;\n+  void *pad;\n+};\n+\n+omp_allocator_handle_t\n+omp_init_allocator (omp_memspace_handle_t memspace, int ntraits,\n+\t\t    const omp_alloctrait_t traits[])\n+{\n+  struct omp_allocator_data data\n+    = { memspace, 1, ~(uintptr_t) 0, 0, 0, omp_atv_contended, omp_atv_all,\n+\tomp_atv_default_mem_fb, omp_atv_false, omp_atv_environment };\n+  struct omp_allocator_data *ret;\n+  int i;\n+\n+  if (memspace > omp_low_lat_mem_space)\n+    return omp_null_allocator;\n+  for (i = 0; i < ntraits; i++)\n+    switch (traits[i].key)\n+      {\n+      case omp_atk_sync_hint:\n+\tswitch (traits[i].value)\n+\t  {\n+\t  case omp_atv_default:\n+\t    data.sync_hint = omp_atv_contended;\n+\t    break;\n+\t  case omp_atv_contended:\n+\t  case omp_atv_uncontended:\n+\t  case omp_atv_sequential:\n+\t  case omp_atv_private:\n+\t    data.sync_hint = traits[i].value;\n+\t    break;\n+\t  default:\n+\t    return omp_null_allocator;\n+\t  }\n+\tbreak;\n+      case omp_atk_alignment:\n+\tif ((traits[i].value & (traits[i].value - 1)) != 0\n+\t    || !traits[i].value)\n+\t  return omp_null_allocator;\n+\tdata.alignment = traits[i].value;\n+\tbreak;\n+      case omp_atk_access:\n+\tswitch (traits[i].value)\n+\t  {\n+\t  case omp_atv_default:\n+\t    data.access = omp_atv_all;\n+\t    break;\n+\t  case omp_atv_all:\n+\t  case omp_atv_cgroup:\n+\t  case omp_atv_pteam:\n+\t  case omp_atv_thread:\n+\t    data.access = traits[i].value;\n+\t    break;\n+\t  default:\n+\t    return omp_null_allocator;\n+\t  }\n+\tbreak;\n+      case omp_atk_pool_size:\n+\tdata.pool_size = traits[i].value;\n+\tbreak;\n+      case omp_atk_fallback:\n+\tswitch (traits[i].value)\n+\t  {\n+\t  case omp_atv_default:\n+\t    data.fallback = omp_atv_default_mem_fb;\n+\t    break;\n+\t  case omp_atv_default_mem_fb:\n+\t  case omp_atv_null_fb:\n+\t  case omp_atv_abort_fb:\n+\t  case omp_atv_allocator_fb:\n+\t    data.fallback = traits[i].value;\n+\t    break;\n+\t  default:\n+\t    return omp_null_allocator;\n+\t  }\n+\tbreak;\n+      case omp_atk_fb_data:\n+\tdata.fb_data = traits[i].value;\n+\tbreak;\n+      case omp_atk_pinned:\n+\tswitch (traits[i].value)\n+\t  {\n+\t  case omp_atv_default:\n+\t  case omp_atv_false:\n+\t    data.pinned = omp_atv_false;\n+\t    break;\n+\t  case omp_atv_true:\n+\t    data.pinned = omp_atv_true;\n+\t    break;\n+\t  default:\n+\t    return omp_null_allocator;\n+\t  }\n+\tbreak;\n+      case omp_atk_partition:\n+\tswitch (traits[i].value)\n+\t  {\n+\t  case omp_atv_default:\n+\t    data.partition = omp_atv_environment;\n+\t    break;\n+\t  case omp_atv_environment:\n+\t  case omp_atv_nearest:\n+\t  case omp_atv_blocked:\n+\t  case omp_atv_interleaved:\n+\t    data.partition = traits[i].value;\n+\t    break;\n+\t  default:\n+\t    return omp_null_allocator;\n+\t  }\n+\tbreak;\n+      default:\n+\treturn omp_null_allocator;\n+      }\n+\n+  if (data.alignment < sizeof (void *))\n+    data.alignment = sizeof (void *);\n+\n+  /* No support for these so far (for hbw will use memkind).  */\n+  if (data.pinned || data.memspace == omp_high_bw_mem_space)\n+    return omp_null_allocator;\n+\n+  ret = gomp_malloc (sizeof (struct omp_allocator_data));\n+  *ret = data;\n+#ifndef HAVE_SYNC_BUILTINS\n+  gomp_mutex_init (&ret->lock);\n+#endif\n+  return (omp_allocator_handle_t) ret;\n+}\n+\n+void\n+omp_destroy_allocator (omp_allocator_handle_t allocator)\n+{\n+  if (allocator != omp_null_allocator)\n+    {\n+#ifndef HAVE_SYNC_BUILTINS\n+      gomp_mutex_destroy (&((struct omp_allocator_data *) allocator)->lock);\n+#endif\n+      free ((void *) allocator);\n+    }\n+}\n+\n+void *\n+omp_alloc (size_t size, omp_allocator_handle_t allocator)\n+{\n+  struct omp_allocator_data *allocator_data;\n+  size_t alignment, new_size;\n+  void *ptr, *ret;\n+\n+retry:\n+  if (allocator == omp_null_allocator)\n+    {\n+      struct gomp_thread *thr = gomp_thread ();\n+      if (thr->ts.def_allocator == omp_null_allocator)\n+\tthr->ts.def_allocator = gomp_def_allocator;\n+      allocator = (omp_allocator_handle_t) thr->ts.def_allocator;\n+    }\n+\n+  if (allocator > omp_max_predefined_alloc)\n+    {\n+      allocator_data = (struct omp_allocator_data *) allocator;\n+      alignment = allocator_data->alignment;\n+    }\n+  else\n+    {\n+      allocator_data = NULL;\n+      alignment = sizeof (void *);\n+    }\n+\n+  new_size = sizeof (struct omp_mem_header);\n+  if (alignment > sizeof (void *))\n+    new_size += alignment - sizeof (void *);\n+  if (__builtin_add_overflow (size, new_size, &new_size))\n+    goto fail;\n+\n+  if (__builtin_expect (allocator_data\n+\t\t\t&& allocator_data->pool_size < ~(uintptr_t) 0, 0))\n+    {\n+      uintptr_t used_pool_size;\n+      if (new_size > allocator_data->pool_size)\n+\tgoto fail;\n+#ifdef HAVE_SYNC_BUILTINS\n+      used_pool_size = __atomic_load_n (&allocator_data->used_pool_size,\n+\t\t\t\t\tMEMMODEL_RELAXED);\n+      do\n+\t{\n+\t  uintptr_t new_pool_size;\n+\t  if (__builtin_add_overflow (used_pool_size, new_size,\n+\t\t\t\t      &new_pool_size)\n+\t      || new_pool_size > allocator_data->pool_size)\n+\t    goto fail;\n+\t  if (__atomic_compare_exchange_n (&allocator_data->used_pool_size,\n+\t\t\t\t\t   &used_pool_size, new_pool_size,\n+\t\t\t\t\t   true, MEMMODEL_RELAXED,\n+\t\t\t\t\t   MEMMODEL_RELAXED))\n+\t    break;\n+\t}\n+      while (1);\n+#else\n+      gomp_mutex_lock (&allocator_data->lock);\n+      if (__builtin_add_overflow (allocator_data->used_pool_size, new_size,\n+\t\t\t\t  &used_pool_size)\n+\t  || used_pool_size > allocator_data->pool_size)\n+\t{\n+\t  gomp_mutex_unlock (&allocator_data->lock);\n+\t  goto fail;\n+\t}\n+      allocator_data->used_pool_size = used_pool_size;\n+      gomp_mutex_unlock (&allocator_data->lock);\n+#endif\n+      ptr = malloc (new_size);\n+      if (ptr == NULL)\n+\t{\n+#ifdef HAVE_SYNC_BUILTINS\n+\t  __atomic_add_fetch (&allocator_data->used_pool_size, -new_size,\n+\t\t\t      MEMMODEL_RELAXED);\n+#else\n+\t  gomp_mutex_lock (&allocator_data->lock);\n+\t  allocator_data->used_pool_size -= new_size;\n+\t  gomp_mutex_unlock (&allocator_data->lock);\n+#endif\n+\t  goto fail;\n+\t}\n+    }\n+  else\n+    {\n+      ptr = malloc (new_size);\n+      if (ptr == NULL)\n+\tgoto fail;\n+    }\n+\n+  if (alignment > sizeof (void *))\n+    ret = (void *) (((uintptr_t) ptr\n+\t\t     + sizeof (struct omp_mem_header)\n+\t\t     + alignment - sizeof (void *)) & ~(alignment - 1));\n+  else\n+    ret = (char *) ptr + sizeof (struct omp_mem_header);\n+  ((struct omp_mem_header *) ret)[-1].ptr = ptr;\n+  ((struct omp_mem_header *) ret)[-1].size = new_size;\n+  ((struct omp_mem_header *) ret)[-1].allocator = allocator;\n+  return ret;\n+\n+fail:\n+  if (allocator_data)\n+    {\n+      switch (allocator_data->fallback)\n+\t{\n+\tcase omp_atv_default_mem_fb:\n+\t  if (alignment > sizeof (void *)\n+\t      || (allocator_data\n+\t\t  && allocator_data->pool_size < ~(uintptr_t) 0))\n+\t    {\n+\t      allocator = omp_default_mem_alloc;\n+\t      goto retry;\n+\t    }\n+\t  /* Otherwise, we've already performed default mem allocation\n+\t     and if that failed, it won't succeed again (unless it was\n+\t     intermitent.  Return NULL then, as that is the fallback.  */\n+\t  break;\n+\tcase omp_atv_null_fb:\n+\t  break;\n+\tdefault:\n+\tcase omp_atv_abort_fb:\n+\t  gomp_fatal (\"Out of memory allocating %lu bytes\",\n+\t\t      (unsigned long) size);\n+\tcase omp_atv_allocator_fb:\n+\t  allocator = allocator_data->fb_data;\n+\t  goto retry;\n+\t}\n+    }\n+  return NULL;\n+}\n+\n+void\n+omp_free (void *ptr, omp_allocator_handle_t allocator)\n+{\n+  struct omp_mem_header *data;\n+\n+  if (ptr == NULL)\n+    return;\n+  (void) allocator;\n+  data = &((struct omp_mem_header *) ptr)[-1];\n+  if (data->allocator > omp_max_predefined_alloc)\n+    {\n+      struct omp_allocator_data *allocator_data\n+\t= (struct omp_allocator_data *) (data->allocator);\n+      if (allocator_data->pool_size < ~(uintptr_t) 0)\n+\t{\n+#ifdef HAVE_SYNC_BUILTINS\n+\t  __atomic_add_fetch (&allocator_data->used_pool_size, -data->size,\n+\t\t\t      MEMMODEL_RELAXED);\n+#else\n+\t  gomp_mutex_lock (&allocator_data->lock);\n+\t  allocator_data->used_pool_size -= data->new_size;\n+\t  gomp_mutex_unlock (&allocator_data->lock);\n+#endif\n+\t}\n+    }\n+  free (data->ptr);\n+}"}]}