{"sha": "10b76d739543e54113cdb8755ba624c03bae4239", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBiNzZkNzM5NTQzZTU0MTEzY2RiODc1NWJhNjI0YzAzYmFlNDIzOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-10-25T12:55:16Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-10-25T12:55:16Z"}, "message": "alias.c (can_address_p): No longer static.\n\n\t* alias.c (can_address_p): No longer static.\n\t* emit-rtl.c (get_mem_attrs): New parameter, MODE; all callers changed.\n\tReturn 0 if all parameters are default values.\n\t(set_mem_attributes): Set MEM_KEEP_ALIAS_SET_P.\n\t(adjust_address_1): Try harder to compute a size.\n\t* expr.c (expand_assignment, store_constructor): If can't address,\n\tset MEM_KEEP_ALIAS_SET_P.\n\t(store_constructor_field): Don't change set if MEM_KEEP_ALIAS_SET_P.\n\t(store_field): Likewise.\n\t(store_constructor): Simplify call to store_constructor_field.\n\t* expr.h (can_address_p): New declaration.\n\t* gensupport.c (gen_rtx_CONST_INT): New function.\n\t* rtl.h (MEM_KEEP_ALIAS_SET_P): New macro.\n\t(MEM_SIZE): Get size from mode, if not set and not BLKmode.\n\t(MEM_COPY_ATTRIBUTES): Copy MEM_KEEP_ALIAS_SET_P.\n\nFrom-SVN: r46487", "tree": {"sha": "0f9f09ded135324a3c1a35af13611e762d6e0cf3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f9f09ded135324a3c1a35af13611e762d6e0cf3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10b76d739543e54113cdb8755ba624c03bae4239", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10b76d739543e54113cdb8755ba624c03bae4239", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10b76d739543e54113cdb8755ba624c03bae4239", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10b76d739543e54113cdb8755ba624c03bae4239/comments", "author": null, "committer": null, "parents": [{"sha": "9fb60a0d1a7af546cce200d38315019b1e026a89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fb60a0d1a7af546cce200d38315019b1e026a89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fb60a0d1a7af546cce200d38315019b1e026a89"}], "stats": {"total": 155, "additions": 123, "deletions": 32}, "files": [{"sha": "c65ba8075aafa482fa72365311bd234eaaa46591", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b76d739543e54113cdb8755ba624c03bae4239/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b76d739543e54113cdb8755ba624c03bae4239/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10b76d739543e54113cdb8755ba624c03bae4239", "patch": "@@ -1,5 +1,21 @@\n Thu Oct 25 08:46:06 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* alias.c (can_address_p): No longer static.\n+\t* emit-rtl.c (get_mem_attrs): New parameter, MODE; all callers changed.\n+\tReturn 0 if all parameters are default values.\n+\t(set_mem_attributes): Set MEM_KEEP_ALIAS_SET_P.\n+\t(adjust_address_1): Try harder to compute a size.\n+\t* expr.c (expand_assignment, store_constructor): If can't address,\n+\tset MEM_KEEP_ALIAS_SET_P.\n+\t(store_constructor_field): Don't change set if MEM_KEEP_ALIAS_SET_P.\n+\t(store_field): Likewise.\n+\t(store_constructor): Simplify call to store_constructor_field.\n+\t* expr.h (can_address_p): New declaration.\n+\t* gensupport.c (gen_rtx_CONST_INT): New function.\n+\t* rtl.h (MEM_KEEP_ALIAS_SET_P): New macro.\n+\t(MEM_SIZE): Get size from mode, if not set and not BLKmode.\n+\t(MEM_COPY_ATTRIBUTES): Copy MEM_KEEP_ALIAS_SET_P.\n+\n \t* stmt.c (expand_end_case): Remove orig_minval and use tree_low_cst.\n \n 2001-10-24  Christopher Faylor  <cgf@redhat.com>"}, {"sha": "c754e6e50a14cb3db02f065b7f00e7a0c9a6dd03", "filename": "gcc/alias.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b76d739543e54113cdb8755ba624c03bae4239/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b76d739543e54113cdb8755ba624c03bae4239/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=10b76d739543e54113cdb8755ba624c03bae4239", "patch": "@@ -95,7 +95,6 @@ static rtx find_base_term\t\tPARAMS ((rtx));\n static int base_alias_check\t\tPARAMS ((rtx, rtx, enum machine_mode,\n \t\t\t\t\t\t enum machine_mode));\n static int handled_component_p\t\tPARAMS ((tree));\n-static int can_address_p\t\tPARAMS ((tree));\n static rtx find_base_value\t\tPARAMS ((rtx));\n static int mems_in_disjoint_alias_sets_p PARAMS ((rtx, rtx));\n static int insert_subset_children       PARAMS ((splay_tree_node, void*));\n@@ -426,7 +425,7 @@ handled_component_p (t)\n /* Return 1 if all the nested component references handled by\n    get_inner_reference in T are such that we can address the object in T.  */\n \n-static int\n+int\n can_address_p (t)\n      tree t;\n {"}, {"sha": "008ceaadcbaa31dee4431dfa472f3548a4de9e82", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b76d739543e54113cdb8755ba624c03bae4239/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b76d739543e54113cdb8755ba624c03bae4239/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=10b76d739543e54113cdb8755ba624c03bae4239", "patch": "@@ -192,7 +192,8 @@ static int mem_attrs_htab_eq            PARAMS ((const void *,\n \t\t\t\t\t\t const void *));\n static void mem_attrs_mark\t\tPARAMS ((const void *));\n static mem_attrs *get_mem_attrs\t\tPARAMS ((HOST_WIDE_INT, tree, rtx,\n-\t\t\t\t\t\t rtx, unsigned int));\n+\t\t\t\t\t\t rtx, unsigned int,\n+\t\t\t\t\t\t enum machine_mode));\n \n /* Probability of the conditional branch currently proceeded by try_split.\n    Set to -1 otherwise.  */\n@@ -269,19 +270,29 @@ mem_attrs_mark (x)\n }\n \n /* Allocate a new mem_attrs structure and insert it into the hash table if\n-   one identical to it is not already in the table.  */\n+   one identical to it is not already in the table.  We are doing this for\n+   MEM of mode MODE.  */\n \n static mem_attrs *\n-get_mem_attrs (alias, decl, offset, size, align)\n+get_mem_attrs (alias, decl, offset, size, align, mode)\n      HOST_WIDE_INT alias;\n      tree decl;\n      rtx offset;\n      rtx size;\n      unsigned int align;\n+     enum machine_mode mode;\n {\n   mem_attrs attrs;\n   void **slot;\n \n+  /* If everything is the default, we can just return zero.  */\n+  if (alias == 0 && decl == 0 && offset == 0\n+      && (size == 0\n+\t  || (mode != BLKmode && GET_MODE_SIZE (mode) == INTVAL (size)))\n+      && (align == 1\n+\t  || (mode != BLKmode && align == GET_MODE_ALIGNMENT (mode))))\n+    return 0;\n+\n   attrs.alias = alias;\n   attrs.decl = decl;\n   attrs.offset = offset;\n@@ -1706,6 +1717,11 @@ set_mem_attributes (ref, t, objectp)\n \t     || TREE_CODE (t) == NON_LVALUE_EXPR || TREE_CODE (t) == SAVE_EXPR)\n \tt = TREE_OPERAND (t, 0);\n \n+      /* If this expression can't be addressed (e.g., it contains a reference\n+\t to a non-addressable field), show we don't change its alias set.  */\n+      if (! can_address_p (t))\n+\tMEM_KEEP_ALIAS_SET_P (ref) = 1;\n+\n       /* If this is a decl, set the attributes of the MEM from it.  */\n       if (DECL_P (t))\n \t{\n@@ -1723,7 +1739,8 @@ set_mem_attributes (ref, t, objectp)\n     }\n \n   /* Now set the attributes we computed above.  */\n-  MEM_ATTRS (ref) = get_mem_attrs (alias, decl, offset, size, align);\n+  MEM_ATTRS (ref)\n+    = get_mem_attrs (alias, decl, offset, size, align, GET_MODE (ref));\n \n   /* If this is already known to be a scalar or aggregate, we are done.  */\n   if (MEM_IN_STRUCT_P (ref) || MEM_SCALAR_P (ref))\n@@ -1751,7 +1768,8 @@ set_mem_alias_set (mem, set)\n #endif\n \n   MEM_ATTRS (mem) = get_mem_attrs (set, MEM_DECL (mem), MEM_OFFSET (mem),\n-\t\t\t\t   MEM_SIZE (mem), MEM_ALIGN (mem));\n+\t\t\t\t   MEM_SIZE (mem), MEM_ALIGN (mem),\n+\t\t\t\t   GET_MODE (mem));\n }\n \n /* Set the alignment of MEM to ALIGN bits.  */\n@@ -1762,7 +1780,8 @@ set_mem_align (mem, align)\n      unsigned int align;\n {\n   MEM_ATTRS (mem) = get_mem_attrs (MEM_ALIAS_SET (mem), MEM_DECL (mem),\n-\t\t\t\t   MEM_OFFSET (mem), MEM_SIZE (mem), align);\n+\t\t\t\t   MEM_OFFSET (mem), MEM_SIZE (mem), align,\n+\t\t\t\t   GET_MODE (mem));\n }\n \f\n /* Return a memory reference like MEMREF, but with its mode changed to MODE\n@@ -1822,7 +1841,8 @@ change_address (memref, mode, addr)\n     = get_mem_attrs (MEM_ALIAS_SET (memref), 0, 0,\n \t\t     mmode == BLKmode ? 0 : GEN_INT (GET_MODE_SIZE (mmode)),\n \t\t     (mmode == BLKmode ? 1\n-\t\t      : GET_MODE_ALIGNMENT (mmode) / BITS_PER_UNIT));\n+\t\t      : GET_MODE_ALIGNMENT (mmode) / BITS_PER_UNIT),\n+\t\t     mmode);\n \n   return new;\n }\n@@ -1841,6 +1861,7 @@ adjust_address_1 (memref, mode, offset, validate)\n   rtx addr = XEXP (memref, 0);\n   rtx new;\n   rtx memoffset = MEM_OFFSET (memref);\n+  rtx size = 0;\n   unsigned int memalign = MEM_ALIGN (memref);\n \n   /* If MEMREF is a LO_SUM and the offset is within the alignment of the\n@@ -1870,10 +1891,14 @@ adjust_address_1 (memref, mode, offset, validate)\n   if (offset != 0)\n     memalign = MIN (memalign, (offset & -offset) * BITS_PER_UNIT);\n \n-  MEM_ATTRS (new)\n-    = get_mem_attrs (MEM_ALIAS_SET (memref), MEM_DECL (memref), memoffset,\n-\t\t     mode == BLKmode\n-\t\t     ? 0 : GEN_INT (GET_MODE_SIZE (mode)), memalign);\n+  /* We can compute the size in a number of ways.  */\n+  if (mode != BLKmode)\n+    size = GEN_INT (GET_MODE_SIZE (mode));\n+  else if (MEM_SIZE (memref))\n+    size = plus_constant (MEM_SIZE (memref), -offset);\n+\n+  MEM_ATTRS (new) = get_mem_attrs (MEM_ALIAS_SET (memref), MEM_DECL (memref),\n+\t\t\t\t   memoffset, size, memalign, GET_MODE (new));\n \n   /* At some point, we should validate that this offset is within the object,\n      if all the appropriate values are known.  */\n@@ -1898,7 +1923,8 @@ offset_address (memref, offset, pow2)\n      we don't know.  */\n   MEM_ATTRS (new) = get_mem_attrs (MEM_ALIAS_SET (memref), MEM_DECL (memref),\n \t\t\t\t   0, 0, MIN (MEM_ALIGN (memref),\n-\t\t\t\t\t      pow2 * BITS_PER_UNIT));\n+\t\t\t\t\t      pow2 * BITS_PER_UNIT),\n+\t\t\t\t   GET_MODE (new));\n   return new;\n }\n   "}, {"sha": "d738d2d4c7521ed18a2996adf84cb99a91d9588a", "filename": "gcc/expr.c", "status": "modified", "additions": 37, "deletions": 12, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b76d739543e54113cdb8755ba624c03bae4239/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b76d739543e54113cdb8755ba624c03bae4239/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=10b76d739543e54113cdb8755ba624c03bae4239", "patch": "@@ -3841,6 +3841,12 @@ expand_assignment (to, from, want_value, suggest_reg)\n \t}\n       else\n \t{\n+\t  if (! can_address_p (to))\n+\t    {\n+\t      to_rtx = copy_rtx (to_rtx);\n+\t      MEM_KEEP_ALIAS_SET_P (to_rtx) = 1;\n+\t    }\n+\n \t  result = store_field (to_rtx, bitsize, bitpos, mode1, from,\n \t\t\t\t(want_value\n \t\t\t\t /* Spurious cast for HPUX compiler.  */\n@@ -4479,7 +4485,9 @@ store_constructor_field (target, bitsize, bitpos,\n \t set, if required.  */\n       if (bitpos != 0)\n \talign = MIN (align, (unsigned int) bitpos & - bitpos);\n-      if (GET_CODE (target) == MEM)\n+\n+      if (GET_CODE (target) == MEM && ! MEM_KEEP_ALIAS_SET_P (target)\n+\t  && MEM_ALIAS_SET (target) != 0)\n \tset_mem_alias_set (target, alias_set);\n \n       store_constructor (exp, target, align, cleared, bitsize / BITS_PER_UNIT);\n@@ -4681,12 +4689,17 @@ store_constructor (exp, target, align, cleared, size)\n \t      mode = word_mode;\n \t    }\n #endif\n+\n+\t  if (GET_CODE (to_rtx) == MEM && !MEM_KEEP_ALIAS_SET_P (to_rtx)\n+\t      && DECL_NONADDRESSABLE_P (field))\n+\t    {\n+\t      to_rtx = copy_rtx (to_rtx);\n+\t      MEM_KEEP_ALIAS_SET_P (to_rtx) = 1;\n+\t    }\n+\n \t  store_constructor_field (to_rtx, bitsize, bitpos, mode,\n \t\t\t\t   TREE_VALUE (elt), type, align, cleared,\n-\t\t\t\t   (DECL_NONADDRESSABLE_P (field)\n-\t\t\t\t    && GET_CODE (to_rtx) == MEM)\n-\t\t\t\t   ? MEM_ALIAS_SET (to_rtx)\n-\t\t\t\t   : get_alias_set (TREE_TYPE (field)));\n+\t\t\t\t   get_alias_set (TREE_TYPE (field)));\n \t}\n     }\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n@@ -4824,11 +4837,18 @@ store_constructor (exp, target, align, cleared, size)\n \t\t  for (; lo <= hi; lo++)\n \t\t    {\n \t\t      bitpos = lo * tree_low_cst (TYPE_SIZE (elttype), 0);\n+\n+\t\t      if (GET_CODE (target) == MEM\n+\t\t\t  && !MEM_KEEP_ALIAS_SET_P (target)\n+\t\t\t  && TYPE_NONALIASED_COMPONENT (type))\n+\t\t\t{\n+\t\t\t  target = copy_rtx (target);\n+\t\t\t  MEM_KEEP_ALIAS_SET_P (target) = 1;\n+\t\t\t}\n+\n \t\t      store_constructor_field\n \t\t\t(target, bitsize, bitpos, mode, value, type, align,\n-\t\t\t cleared,\n-\t\t\t TYPE_NONALIASED_COMPONENT (type)\n-\t\t\t ? MEM_ALIAS_SET (target) : get_alias_set (elttype));\n+\t\t\t cleared, get_alias_set (elttype));\n \t\t    }\n \t\t}\n \t      else\n@@ -4916,11 +4936,15 @@ store_constructor (exp, target, align, cleared, size)\n \t      else\n \t\tbitpos = (i * tree_low_cst (TYPE_SIZE (elttype), 1));\n \n+\t      if (GET_CODE (target) == MEM && !MEM_KEEP_ALIAS_SET_P (target)\n+\t\t  && TYPE_NONALIASED_COMPONENT (type))\n+\t\t{\n+\t\t  target = copy_rtx (target);\n+\t\t  MEM_KEEP_ALIAS_SET_P (target) = 1;\n+\t\t}\n+\n \t      store_constructor_field (target, bitsize, bitpos, mode, value,\n \t\t\t\t       type, align, cleared,\n-\t\t\t\t       TYPE_NONALIASED_COMPONENT (type)\n-\t\t\t\t       && GET_CODE (target) == MEM\n-\t\t\t\t       ? MEM_ALIAS_SET (target) :\n \t\t\t\t       get_alias_set (elttype));\n \n \t    }\n@@ -5329,7 +5353,8 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n \t\t\t\t\t bitpos / BITS_PER_UNIT));\n \n       MEM_SET_IN_STRUCT_P (to_rtx, 1);\n-      set_mem_alias_set (to_rtx, alias_set);\n+      if (!MEM_KEEP_ALIAS_SET_P (to_rtx) && MEM_ALIAS_SET (to_rtx) != 0)\n+\tset_mem_alias_set (to_rtx, alias_set);\n \n       return store_expr (exp, to_rtx, value_mode != VOIDmode);\n     }"}, {"sha": "6680476c8dc6c3d328c14ede8b3e52a95c5b0a97", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b76d739543e54113cdb8755ba624c03bae4239/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b76d739543e54113cdb8755ba624c03bae4239/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=10b76d739543e54113cdb8755ba624c03bae4239", "patch": "@@ -371,6 +371,7 @@ extern void record_base_value\t\tPARAMS ((unsigned int, rtx, int));\n extern void record_alias_subset         PARAMS ((HOST_WIDE_INT,\n \t\t\t\t\t\t HOST_WIDE_INT));\n extern HOST_WIDE_INT new_alias_set\t\tPARAMS ((void));\n+extern int can_address_p\t\tPARAMS ((tree));\n \f\n /* Functions from expr.c:  */\n "}, {"sha": "83be3c76e3250696301f3f424165272821fb030e", "filename": "gcc/gensupport.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b76d739543e54113cdb8755ba624c03bae4239/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b76d739543e54113cdb8755ba624c03bae4239/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=10b76d739543e54113cdb8755ba624c03bae4239", "patch": "@@ -92,6 +92,20 @@ message_with_line VPARAMS ((int lineno, const char *msg, ...))\n \n   VA_CLOSE (ap);\n }\n+\n+/* Make a version of gen_rtx_CONST_INT so that GEN_INT can be used in\n+   the gensupport programs.  */\n+\n+rtx\n+gen_rtx_CONST_INT (mode, arg)\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+     HOST_WIDE_INT arg;\n+{\n+  rtx rt = rtx_alloc (CONST_INT);\n+\n+  XWINT (rt, 0) = arg;\n+  return rt;\n+}\n \f\n /* Queue PATTERN on LIST_TAIL.  */\n "}, {"sha": "1985f98ea4b7adccfbed43b17745331afe10244e", "filename": "gcc/rtl.h", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b76d739543e54113cdb8755ba624c03bae4239/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b76d739543e54113cdb8755ba624c03bae4239/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=10b76d739543e54113cdb8755ba624c03bae4239", "patch": "@@ -129,6 +129,7 @@ struct rtx_def\n \n   /* 1 in an INSN if it can alter flow of control\n      within this function.\n+     MEM_KEEP_ALIAS_SET_P in a MEM.\n      LINK_COST_ZERO in an INSN_LIST.  */\n   unsigned int jump : 1;\n   /* 1 in an INSN if it can call another function.\n@@ -855,6 +856,11 @@ extern unsigned int subreg_regno \tPARAMS ((rtx));\n #define ASM_OPERANDS_SOURCE_FILE(RTX) XCSTR ((RTX), 5, ASM_OPERANDS)\n #define ASM_OPERANDS_SOURCE_LINE(RTX) XCINT ((RTX), 6, ASM_OPERANDS)\n \n+/* For a MEM RTX, 1 if we should keep the alias set for this mem\n+   unchanged when we access a component.  Set to 1, or example, when we\n+   are already in a non-addressable component of an aggregate.  */\n+#define MEM_KEEP_ALIAS_SET_P(RTX) ((RTX)->jump)\n+\n /* For a MEM rtx, 1 if it's a volatile reference.\n    Also in an ASM_OPERANDS rtx.  */\n #define MEM_VOLATILE_P(RTX) ((RTX)->volatil)\n@@ -910,7 +916,10 @@ extern unsigned int subreg_regno \tPARAMS ((rtx));\n \n /* For a MEM rtx, the size in bytes of the MEM, if known, as an RTX that\n    is always a CONST_INT.  */\n-#define MEM_SIZE(RTX) (MEM_ATTRS (RTX) == 0 ? 0 : MEM_ATTRS (RTX)->size)\n+#define MEM_SIZE(RTX)\t\t\t\t\t\t\t\\\n+(MEM_ATTRS (RTX) != 0 ? MEM_ATTRS (RTX)->size\t\t\t\t\\\n+ : GET_MODE (RTX) != BLKmode ? GEN_INT (GET_MODE_SIZE (GET_MODE (RTX)))\t\\\n+ : 0)\n \n /* For a MEM rtx, the alignment in bits.  */\n #define MEM_ALIGN(RTX)\t\t\t\t\t\t\t\\\n@@ -920,11 +929,12 @@ extern unsigned int subreg_regno \tPARAMS ((rtx));\n \n \n /* Copy the attributes that apply to memory locations from RHS to LHS.  */\n-#define MEM_COPY_ATTRIBUTES(LHS, RHS)\t\t\t\\\n-  (MEM_VOLATILE_P (LHS) = MEM_VOLATILE_P (RHS),\t\t\\\n-   MEM_IN_STRUCT_P (LHS) = MEM_IN_STRUCT_P (RHS),\t\\\n-   MEM_SCALAR_P (LHS) = MEM_SCALAR_P (RHS),\t\t\\\n-   RTX_UNCHANGING_P (LHS) = RTX_UNCHANGING_P (RHS),\t\\\n+#define MEM_COPY_ATTRIBUTES(LHS, RHS)\t\t\t\t\\\n+  (MEM_VOLATILE_P (LHS) = MEM_VOLATILE_P (RHS),\t\t\t\\\n+   MEM_IN_STRUCT_P (LHS) = MEM_IN_STRUCT_P (RHS),\t\t\\\n+   MEM_SCALAR_P (LHS) = MEM_SCALAR_P (RHS),\t\t\t\\\n+   RTX_UNCHANGING_P (LHS) = RTX_UNCHANGING_P (RHS),\t\t\\\n+   MEM_KEEP_ALIAS_SET_P (LHS) = MEM_KEEP_ALIAS_SET_P (RHS),\t\\\n    MEM_ATTRS (LHS) = MEM_ATTRS (RHS))\n \n /* For a LABEL_REF, 1 means that this reference is to a label outside the"}]}