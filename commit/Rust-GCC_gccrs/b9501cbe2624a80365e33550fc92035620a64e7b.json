{"sha": "b9501cbe2624a80365e33550fc92035620a64e7b", "node_id": "C_kwDOANBUbNoAKGI5NTAxY2JlMjYyNGE4MDM2NWUzMzU1MGZjOTIwMzU2MjBhNjRlN2I", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2023-01-18T11:23:03Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2023-02-08T11:02:41Z"}, "message": "macro: Allow builtin `MacroInvocation`s within the AST\n\nThis commit turns AST::MacroInvocation into a sum type.\nThe class can now represent a regular macro invocation (lazily expanded)\nor a builtin one (eagerly expanded)\n\ngcc/rust/ChangeLog:\n\n\t* expand/rust-macro-builtins.cc (make_macro_invocation): Add short hand\n\tfunction for returning fragments containing macro invocations.\n\t(MacroBuiltin::compile_error_handler): Add explanation for eager\n\tinvocation", "tree": {"sha": "2c614cb8667353d323ad6c5c04305d20e5af08bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c614cb8667353d323ad6c5c04305d20e5af08bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9501cbe2624a80365e33550fc92035620a64e7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9501cbe2624a80365e33550fc92035620a64e7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9501cbe2624a80365e33550fc92035620a64e7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9501cbe2624a80365e33550fc92035620a64e7b/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1de4bb869845c6c7dadbc1cf84626e922e80ab9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1de4bb869845c6c7dadbc1cf84626e922e80ab9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1de4bb869845c6c7dadbc1cf84626e922e80ab9"}], "stats": {"total": 72, "additions": 71, "deletions": 1}, "files": [{"sha": "11b5d5fbc9dd06a128bb82aa6778cdf6438e714b", "filename": "gcc/rust/expand/rust-macro-builtins.cc", "status": "modified", "additions": 71, "deletions": 1, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9501cbe2624a80365e33550fc92035620a64e7b/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9501cbe2624a80365e33550fc92035620a64e7b/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc?ref=b9501cbe2624a80365e33550fc92035620a64e7b", "patch": "@@ -37,8 +37,39 @@ make_string (Location locus, std::string value)\n \t\t\t  PrimitiveCoreType::CORETYPE_STR, {}, locus));\n }\n \n-/* Match the end token of a macro given the start delimiter of the macro */\n+// TODO: Is this correct?\n+static std::unique_ptr<AST::Expr>\n+make_macro_invocation (AST::BuiltinMacro kind, AST::DelimTokenTree arguments)\n+{\n+  std::string path_str;\n+\n+  switch (kind)\n+    {\n+    case AST::BuiltinMacro::Assert:\n+    case AST::BuiltinMacro::File:\n+    case AST::BuiltinMacro::Line:\n+    case AST::BuiltinMacro::Column:\n+    case AST::BuiltinMacro::IncludeBytes:\n+    case AST::BuiltinMacro::IncludeStr:\n+    case AST::BuiltinMacro::CompileError:\n+    case AST::BuiltinMacro::Concat:\n+      path_str = \"concat\";\n+      break;\n+    case AST::BuiltinMacro::Env:\n+    case AST::BuiltinMacro::Cfg:\n+    case AST::BuiltinMacro::Include:\n+      break;\n+    }\n \n+  return AST::MacroInvocation::builtin (\n+    kind,\n+    AST::MacroInvocData (AST::SimplePath (\n+\t\t\t   {AST::SimplePathSegment (path_str, Location ())}),\n+\t\t\t std::move (arguments)),\n+    {}, Location ());\n+}\n+\n+/* Match the end token of a macro given the start delimiter of the macro */\n static inline TokenId\n macro_end_token (AST::DelimTokenTree &invoc_token_tree,\n \t\t Parser<MacroInvocLexer> &parser)\n@@ -386,6 +417,45 @@ MacroBuiltin::compile_error_handler (Location invoc_locus,\n /* Expand builtin macro concat!(), which joins all the literal parameters\n    into a string with no delimiter. */\n \n+// This is a weird one. We want to do something where, if something cannot be\n+// expanded yet (i.e. macro invocation?) we return the whole MacroInvocation\n+// node again but expanded as much as possible.\n+// Is that possible? How do we do that?\n+//\n+// Let's take a few examples:\n+//\n+// 1. concat!(1, 2, true);\n+// 2. concat!(a!(), 2, true);\n+// 3. concat!(concat!(1, false), 2, true);\n+// 4. concat!(concat!(1, a!()), 2, true);\n+//\n+// 1. We simply want to return the new fragment: \"12true\"\n+// 2. We want to return `concat!(a_expanded, 2, true)` as a fragment\n+// 3. We want to return `concat!(1, false, 2, true)`\n+// 4. We want to return `concat!(concat!(1, a_expanded), 2, true);\n+//\n+// How do we do that?\n+//\n+// For each (un)expanded fragment: we check if it is expanded fully\n+//\n+// 1. What is expanded fully?\n+// 2. How to check?\n+//\n+// If it is expanded fully and not a literal, then we error out.\n+// Otherwise we simply emplace it back and keep going.\n+//\n+// In the second case, we must mark that this concat invocation still has some\n+// expansion to do: This allows us to return a `MacroInvocation { ... }` as an\n+// AST fragment, instead of a completed string.\n+//\n+// This means that we must change all the `try_expand_many_*` APIs and so on to\n+// return some sort of index or way to signify that we might want to reuse some\n+// bits and pieces of the original token tree.\n+//\n+// Now, before that: How do we resolve the names used in a builtin macro\n+// invocation?\n+// Do we split the two passes of parsing the token tree and then expanding it?\n+// Can we do that easily?\n AST::Fragment\n MacroBuiltin::concat_handler (Location invoc_locus, AST::MacroInvocData &invoc)\n {"}]}