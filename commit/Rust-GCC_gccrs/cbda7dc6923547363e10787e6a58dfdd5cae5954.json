{"sha": "cbda7dc6923547363e10787e6a58dfdd5cae5954", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JkYTdkYzY5MjM1NDczNjNlMTA3ODdlNmE1OGRmZGQ1Y2FlNTk1NA==", "commit": {"author": {"name": "Anatoly Sokolov", "email": "aesok@post.ru", "date": "2010-05-12T19:08:31Z"}, "committer": {"name": "Anatoly Sokolov", "email": "aesok@gcc.gnu.org", "date": "2010-05-12T19:08:31Z"}, "message": "target.h (struct gcc_target): Add mode_dependent_address_p field.\n\n\t* target.h (struct gcc_target): Add mode_dependent_address_p field.\n\t* target-def.h (TARGET_MODE_DEPENDENT_ADDRESS_P): New.\n\t(TARGET_INITIALIZER): Use TARGET_MODE_DEPENDENT_ADDRESS_P.\n\t* targhooks.c (default_mode_dependent_address_p): New function.\n\t* targhooks.h (default_mode_dependent_address_p): Declare function.\n\t* doc/tm.texi (TARGET_MODE_DEPENDENT_ADDRESS_P): New.\n\t(GO_IF_MODE_DEPENDENT_ADDRESS): Update.\n\t* recog.c: (mode_dependent_address_p): Call mode_dependent_address_p\n\ttarget hook. Change return type to bool.\n\t* recog.h: (mode_dependent_address_p): Change return type to bool.\n\nFrom-SVN: r159339", "tree": {"sha": "ab0664b99a156d91a202d107ee413a933ccb1249", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab0664b99a156d91a202d107ee413a933ccb1249"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbda7dc6923547363e10787e6a58dfdd5cae5954", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbda7dc6923547363e10787e6a58dfdd5cae5954", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbda7dc6923547363e10787e6a58dfdd5cae5954", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbda7dc6923547363e10787e6a58dfdd5cae5954/comments", "author": null, "committer": null, "parents": [{"sha": "dfe5f5b2b36092f0e07f3e7e58293c5e0565ced4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfe5f5b2b36092f0e07f3e7e58293c5e0565ced4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfe5f5b2b36092f0e07f3e7e58293c5e0565ced4"}], "stats": {"total": 76, "additions": 67, "deletions": 9}, "files": [{"sha": "43d9e9ed2ec72f56d5ddacc027a88b2b25dce2cc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbda7dc6923547363e10787e6a58dfdd5cae5954/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbda7dc6923547363e10787e6a58dfdd5cae5954/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cbda7dc6923547363e10787e6a58dfdd5cae5954", "patch": "@@ -1,3 +1,16 @@\n+2010-05-12  Anatoly Sokolov  <aesok@post.ru>\n+\n+\t* target.h (struct gcc_target): Add mode_dependent_address_p field.\n+\t* target-def.h (TARGET_MODE_DEPENDENT_ADDRESS_P): New.\n+\t(TARGET_INITIALIZER): Use TARGET_MODE_DEPENDENT_ADDRESS_P.\n+\t* targhooks.c (default_mode_dependent_address_p): New function.\n+\t* targhooks.h (default_mode_dependent_address_p): Declare function.\n+\t* doc/tm.texi (TARGET_MODE_DEPENDENT_ADDRESS_P): New.\n+\t(GO_IF_MODE_DEPENDENT_ADDRESS): Update.\n+\t* recog.c: (mode_dependent_address_p): Call mode_dependent_address_p\n+\ttarget hook. Change return type to bool.\n+\t* recog.h: (mode_dependent_address_p): Change return type to bool.\n+\n 2010-05-12  Kazu Hirata  <kazu@codesourcery.com>\n \t    Nathan Froyd  <froydnj@codesourcery.com>\n "}, {"sha": "6a998ed71a48fb4bdeb8ec10f0c73ffdcdf1e050", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbda7dc6923547363e10787e6a58dfdd5cae5954/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbda7dc6923547363e10787e6a58dfdd5cae5954/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=cbda7dc6923547363e10787e6a58dfdd5cae5954", "patch": "@@ -5609,6 +5609,22 @@ It is not necessary for this macro to come up with a legitimate\n address;  but often a machine-dependent strategy can generate better code.\n @end defmac\n \n+@deftypefn {Target Hook} bool TARGET_MODE_DEPENDENT_ADDRESS_P (const_rtx @var{addr})\n+This hook returns @code{true} if memory address @var{addr} can have\n+different meanings depending on the machine mode of the memory\n+reference it is used for or if the address is valid for some modes\n+but not others.\n+\n+Autoincrement and autodecrement addresses typically have mode-dependent\n+effects because the amount of the increment or decrement is the size\n+of the operand being addressed.  Some machines have other mode-dependent\n+addresses.  Many RISC machines have no mode-dependent addresses.\n+\n+You may assume that @var{addr} is a valid address for the machine.\n+\n+The default version of this hook returns @code{false}.\n+@end deftypefn\n+\n @defmac GO_IF_MODE_DEPENDENT_ADDRESS (@var{addr}, @var{label})\n A C statement or compound statement with a conditional @code{goto\n @var{label};} executed if memory address @var{x} (an RTX) can have\n@@ -5622,6 +5638,9 @@ of the operand being addressed.  Some machines have other mode-dependent\n addresses.  Many RISC machines have no mode-dependent addresses.\n \n You may assume that @var{addr} is a valid address for the machine.\n+\n+These are obsolete macros, replaced by the\n+@code{TARGET_MODE_DEPENDENT_ADDRESS_P} target hook.\n @end defmac\n \n @defmac LEGITIMATE_CONSTANT_P (@var{x})"}, {"sha": "e8f918c7102d024556fd8aea36d6e0301008b9d8", "filename": "gcc/recog.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbda7dc6923547363e10787e6a58dfdd5cae5954/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbda7dc6923547363e10787e6a58dfdd5cae5954/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=cbda7dc6923547363e10787e6a58dfdd5cae5954", "patch": "@@ -1978,7 +1978,7 @@ offsettable_address_addr_space_p (int strictp, enum machine_mode mode, rtx y,\n    Autoincrement addressing is a typical example of mode-dependence\n    because the amount of the increment depends on the mode.  */\n \n-int\n+bool\n mode_dependent_address_p (rtx addr)\n {\n   /* Auto-increment addressing with anything other than post_modify\n@@ -1988,13 +1988,9 @@ mode_dependent_address_p (rtx addr)\n       || GET_CODE (addr) == POST_INC\n       || GET_CODE (addr) == PRE_DEC\n       || GET_CODE (addr) == POST_DEC)\n-    return 1;\n+    return true;\n \n-  GO_IF_MODE_DEPENDENT_ADDRESS (addr, win);\n-  return 0;\n-  /* Label `win' might (not) be used via GO_IF_MODE_DEPENDENT_ADDRESS.  */\n- win: ATTRIBUTE_UNUSED_LABEL\n-  return 1;\n+  return targetm.mode_dependent_address_p (addr);\n }\n \f\n /* Like extract_insn, but save insn extracted and don't extract again, when"}, {"sha": "5e820cc0103f8a237ab8f9e022e53bbbcb71ef68", "filename": "gcc/recog.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbda7dc6923547363e10787e6a58dfdd5cae5954/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbda7dc6923547363e10787e6a58dfdd5cae5954/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=cbda7dc6923547363e10787e6a58dfdd5cae5954", "patch": "@@ -1,6 +1,6 @@\n /* Declarations for interface to insn recognizer and insn-output.c.\n    Copyright (C) 1987, 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004,\n-   2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n+   2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -111,7 +111,7 @@ extern int offsettable_address_addr_space_p (int, enum machine_mode, rtx,\n #define offsettable_address_p(strict,mode,addr) \\\n \toffsettable_address_addr_space_p ((strict), (mode), (addr), \\\n \t\t\t\t\t  ADDR_SPACE_GENERIC)\n-extern int mode_dependent_address_p (rtx);\n+extern bool mode_dependent_address_p (rtx);\n \n extern int recog (rtx, rtx, int *);\n #ifndef GENERATOR_FILE"}, {"sha": "3ead37020470ed7b456cb619ee3df3a9cef69987", "filename": "gcc/target-def.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbda7dc6923547363e10787e6a58dfdd5cae5954/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbda7dc6923547363e10787e6a58dfdd5cae5954/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=cbda7dc6923547363e10787e6a58dfdd5cae5954", "patch": "@@ -599,6 +599,10 @@\n #define TARGET_IN_SMALL_DATA_P hook_bool_const_tree_false\n #endif\n \n+#ifndef TARGET_MODE_DEPENDENT_ADDRESS_P\n+#define TARGET_MODE_DEPENDENT_ADDRESS_P default_mode_dependent_address_p\n+#endif\n+\n #ifndef TARGET_MANGLE_DECL_ASSEMBLER_NAME\n #define TARGET_MANGLE_DECL_ASSEMBLER_NAME default_mangle_decl_assembler_name\n #endif\n@@ -970,6 +974,7 @@\n   TARGET_CANNOT_FORCE_CONST_MEM,\t\t\\\n   TARGET_CANNOT_COPY_INSN_P,\t\t\t\\\n   TARGET_COMMUTATIVE_P,\t\t\t\t\\\n+  TARGET_MODE_DEPENDENT_ADDRESS_P,\t\t\\\n   TARGET_LEGITIMIZE_ADDRESS,\t\t\t\\\n   TARGET_DELEGITIMIZE_ADDRESS,\t\t\t\\\n   TARGET_LEGITIMATE_ADDRESS_P,\t\t\t\\"}, {"sha": "29ec84f1a48a6861b41e00ada5f09b9393d7882e", "filename": "gcc/target.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbda7dc6923547363e10787e6a58dfdd5cae5954/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbda7dc6923547363e10787e6a58dfdd5cae5954/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=cbda7dc6923547363e10787e6a58dfdd5cae5954", "patch": "@@ -663,6 +663,10 @@ struct gcc_target\n \n   /* True if X is considered to be commutative.  */\n   bool (* commutative_p) (const_rtx, int);\n+  \n+  /* True if ADDR is an address-expression whose effect depends\n+     on the mode of the memory reference it is used in.  */\n+  bool (* mode_dependent_address_p) (const_rtx addr);\n \n   /* Given an invalid address X for a given machine mode, try machine-specific\n      ways to make it legitimate.  Return X or an invalid address on failure.  */"}, {"sha": "5e1831cd8259d291a9ff5d009f011ff971eff75f", "filename": "gcc/targhooks.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbda7dc6923547363e10787e6a58dfdd5cae5954/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbda7dc6923547363e10787e6a58dfdd5cae5954/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=cbda7dc6923547363e10787e6a58dfdd5cae5954", "patch": "@@ -958,6 +958,26 @@ default_hard_regno_scratch_ok (unsigned int regno ATTRIBUTE_UNUSED)\n   return true;\n }\n \n+/* The default implementation of TARGET_MODE_DEPENDENT_ADDRESS_P.  */\n+\n+bool\n+default_mode_dependent_address_p (const_rtx addr ATTRIBUTE_UNUSED)\n+{\n+#ifdef GO_IF_MODE_DEPENDENT_ADDRESS\n+\n+  GO_IF_MODE_DEPENDENT_ADDRESS (addr, win);\n+  return false;\n+  /* Label `win' might (not) be used via GO_IF_MODE_DEPENDENT_ADDRESS.  */\n+ win: ATTRIBUTE_UNUSED_LABEL\n+  return true;\n+\n+#else\n+\n+  return false;\n+\n+#endif\n+}\n+\n bool\n default_target_option_valid_attribute_p (tree ARG_UNUSED (fndecl),\n \t\t\t\t\t tree ARG_UNUSED (name),"}, {"sha": "be167e5e0dbc06a3a46e1f08686fc856cea70c41", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbda7dc6923547363e10787e6a58dfdd5cae5954/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbda7dc6923547363e10787e6a58dfdd5cae5954/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=cbda7dc6923547363e10787e6a58dfdd5cae5954", "patch": "@@ -117,6 +117,7 @@ extern tree default_mangle_decl_assembler_name (tree, tree);\n extern tree default_emutls_var_fields (tree, tree *);\n extern tree default_emutls_var_init (tree, tree, tree);\n extern bool default_hard_regno_scratch_ok (unsigned int);\n+extern bool default_mode_dependent_address_p (const_rtx addr);\n extern bool default_target_option_valid_attribute_p (tree, tree, tree, int);\n extern bool default_target_option_pragma_parse (tree, tree);\n extern bool default_target_can_inline_p (tree, tree);"}]}