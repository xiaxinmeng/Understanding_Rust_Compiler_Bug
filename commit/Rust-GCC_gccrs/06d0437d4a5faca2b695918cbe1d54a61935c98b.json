{"sha": "06d0437d4a5faca2b695918cbe1d54a61935c98b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZkMDQzN2Q0YTVmYWNhMmI2OTU5MThjYmUxZDU0YTYxOTM1Yzk4Yg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-08-01T02:28:51Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-08-02T20:56:28Z"}, "message": "compiler, runtime: support unsafe.Add and unsafe.Slice\n\nFor golang/go#19367\nFor golang/go#40481\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/338949", "tree": {"sha": "81cc666b16c30384b39469f246c1ec304a4a4e72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81cc666b16c30384b39469f246c1ec304a4a4e72"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06d0437d4a5faca2b695918cbe1d54a61935c98b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06d0437d4a5faca2b695918cbe1d54a61935c98b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06d0437d4a5faca2b695918cbe1d54a61935c98b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06d0437d4a5faca2b695918cbe1d54a61935c98b/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14d8a5ae472ca5743016f37da2dd4770d83dea21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14d8a5ae472ca5743016f37da2dd4770d83dea21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14d8a5ae472ca5743016f37da2dd4770d83dea21"}], "stats": {"total": 348, "additions": 346, "deletions": 2}, "files": [{"sha": "19fbd64784077faaa58f7e8c8eb8c313181f00cd", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d0437d4a5faca2b695918cbe1d54a61935c98b/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d0437d4a5faca2b695918cbe1d54a61935c98b/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=06d0437d4a5faca2b695918cbe1d54a61935c98b", "patch": "@@ -1,4 +1,4 @@\n-920549b6382a2623538d31001271941f0e9e5a51\n+ad667e7c70cea9fa5730660d72ad891b5753eb62\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "46e71e5a13b73be7981483a8fe29816f7d45eb7f", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d0437d4a5faca2b695918cbe1d54a61935c98b/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d0437d4a5faca2b695918cbe1d54a61935c98b/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=06d0437d4a5faca2b695918cbe1d54a61935c98b", "patch": "@@ -8252,12 +8252,16 @@ Builtin_call_expression::Builtin_call_expression(Gogo* gogo,\n     this->code_ = BUILTIN_REAL;\n   else if (name == \"recover\")\n     this->code_ = BUILTIN_RECOVER;\n+  else if (name == \"Add\")\n+    this->code_ = BUILTIN_ADD;\n   else if (name == \"Alignof\")\n     this->code_ = BUILTIN_ALIGNOF;\n   else if (name == \"Offsetof\")\n     this->code_ = BUILTIN_OFFSETOF;\n   else if (name == \"Sizeof\")\n     this->code_ = BUILTIN_SIZEOF;\n+  else if (name == \"Slice\")\n+    this->code_ = BUILTIN_SLICE;\n   else\n     go_unreachable();\n }\n@@ -8694,6 +8698,119 @@ Builtin_call_expression::do_flatten(Gogo* gogo, Named_object* function,\n \n         return Runtime::make_call(code, loc, 3, e1, e2, e3);\n       }\n+\n+    case BUILTIN_ADD:\n+      {\n+\tExpression* ptr = this->args()->front();\n+\tType* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+\tptr = Expression::make_cast(uintptr_type, ptr, loc);\n+\tExpression* len = this->args()->back();\n+\tlen = Expression::make_cast(uintptr_type, len, loc);\n+\tExpression* add = Expression::make_binary(OPERATOR_PLUS, ptr, len,\n+\t\t\t\t\t\t  loc);\n+\treturn Expression::make_cast(this->args()->front()->type(), add, loc);\n+      }\n+\n+    case BUILTIN_SLICE:\n+      {\n+\tExpression* ptr = this->args()->front();\n+\tTemporary_statement* ptr_temp = NULL;\n+\tif (!ptr->is_multi_eval_safe())\n+\t  {\n+\t    ptr_temp = Statement::make_temporary(NULL, ptr, loc);\n+\t    inserter->insert(ptr_temp);\n+\t    ptr = Expression::make_temporary_reference(ptr_temp, loc);\n+\t  }\n+\n+\tExpression* len = this->args()->back();\n+\tTemporary_statement* len_temp = NULL;\n+\tif (!len->is_multi_eval_safe())\n+\t  {\n+\t    len_temp = Statement::make_temporary(NULL, len, loc);\n+\t    inserter->insert(len_temp);\n+\t    len = Expression::make_temporary_reference(len_temp, loc);\n+\t  }\n+\n+\tbool fits_in_int;\n+\tNumeric_constant nc;\n+\tif (this->args()->back()->numeric_constant_value(&nc))\n+\t  {\n+\t    // We gave an error for constants that don't fit in int in\n+\t    // check_types.\n+\t    fits_in_int = true;\n+\t  }\n+\telse\n+\t  {\n+\t    Integer_type* itype = this->args()->back()->type()->integer_type();\n+\t    go_assert(itype != NULL);\n+\t    int ebits = itype->bits();\n+\t    int intbits =\n+\t      Type::lookup_integer_type(\"int\")->integer_type()->bits();\n+\n+\t    // We can treat ebits == intbits as small even for an\n+\t    // unsigned integer type, because we will convert the\n+\t    // value to int and then reject it in the runtime if it is\n+\t    // negative.\n+\n+\t    fits_in_int = ebits <= intbits;\n+\t  }\n+\n+\tRuntime::Function code = (fits_in_int\n+\t\t\t\t  ? Runtime::UNSAFESLICE\n+\t\t\t\t  : Runtime::UNSAFESLICE64);\n+\tExpression* td =\n+\t  Expression::make_type_descriptor(ptr->type()->points_to(), loc);\n+\tExpression* check = Runtime::make_call(code, loc, 3,\n+\t\t\t\t\t       td, ptr, len);\n+\n+\tif (ptr_temp == NULL)\n+\t  ptr = ptr->copy();\n+\telse\n+\t  ptr = Expression::make_temporary_reference(ptr_temp, loc);\n+\tExpression* nil = Expression::make_nil(loc);\n+\tnil = Expression::make_cast(ptr->type(), nil, loc);\n+\tExpression* is_nil = Expression::make_binary(OPERATOR_EQEQ, ptr, nil,\n+\t\t\t\t\t\t     loc);\n+\n+\tif (len_temp == NULL)\n+\t  len = len->copy();\n+\telse\n+\t  len = Expression::make_temporary_reference(len_temp, loc);\n+\tExpression* zero = Expression::make_integer_ul(0, len->type(), loc);\n+\tExpression* is_zero = Expression::make_binary(OPERATOR_EQEQ, len, zero,\n+\t\t\t\t\t\t      loc);\n+\n+\tExpression* cond = Expression::make_binary(OPERATOR_ANDAND, is_nil,\n+\t\t\t\t\t\t   is_zero, loc);\n+\n+\tType* slice_type = Type::make_array_type(ptr->type()->points_to(),\n+\t\t\t\t\t\t NULL);\n+\tnil = Expression::make_nil(loc);\n+\tExpression* nil_slice = Expression::make_cast(slice_type, nil, loc);\n+\n+\tif (ptr_temp == NULL)\n+\t  ptr = ptr->copy();\n+\telse\n+\t  ptr = Expression::make_temporary_reference(ptr_temp, loc);\n+\n+\tif (len_temp == NULL)\n+\t  len = len->copy();\n+\telse\n+\t  len = Expression::make_temporary_reference(len_temp, loc);\n+\n+\tExpression* cap;\n+\tif (len_temp == NULL)\n+\t  cap = len->copy();\n+\telse\n+\t  cap = Expression::make_temporary_reference(len_temp, loc);\n+\n+\tExpression* slice = Expression::make_slice_value(slice_type, ptr,\n+\t\t\t\t\t\t\t len, cap, loc);\n+\n+\tslice = Expression::make_conditional(cond, nil_slice, slice, loc);\n+\n+\treturn Expression::make_compound(check, slice, loc);\n+      }\n     }\n \n   return this;\n@@ -9781,9 +9898,11 @@ Builtin_call_expression::do_discarding_value()\n     case BUILTIN_MAKE:\n     case BUILTIN_NEW:\n     case BUILTIN_REAL:\n+    case BUILTIN_ADD:\n     case BUILTIN_ALIGNOF:\n     case BUILTIN_OFFSETOF:\n     case BUILTIN_SIZEOF:\n+    case BUILTIN_SLICE:\n       this->unused_value_error();\n       return false;\n \n@@ -9890,6 +10009,18 @@ Builtin_call_expression::do_type()\n \t  t = Type::make_error_type();\n \treturn t;\n       }\n+\n+    case BUILTIN_ADD:\n+      return Type::make_pointer_type(Type::make_void_type());\n+\n+    case BUILTIN_SLICE:\n+      const Expression_list* args = this->args();\n+      if (args == NULL || args->size() != 2)\n+\treturn Type::make_error_type();\n+      Type* pt = args->front()->type()->points_to();\n+      if (pt == NULL)\n+\treturn Type::make_error_type();\n+      return Type::make_array_type(pt, NULL);\n     }\n }\n \n@@ -9954,6 +10085,28 @@ Builtin_call_expression::do_determine_type(const Type_context* context)\n       is_print = false;\n       break;\n \n+    case BUILTIN_ADD:\n+    case BUILTIN_SLICE:\n+      // Both unsafe.Add and unsafe.Slice take two arguments, and the\n+      // second arguments defaults to \"int\".\n+      if (args != NULL && args->size() == 2)\n+\t{\n+\t  if (this->code_ == BUILTIN_SLICE)\n+\t    args->front()->determine_type_no_context();\n+\t  else\n+\t    {\n+\t      Type* pointer = Type::make_pointer_type(Type::make_void_type());\n+\t      Type_context subcontext(pointer, false);\n+\t      args->front()->determine_type(&subcontext);\n+\t    }\n+\t  Type* int_type = Type::lookup_integer_type(\"int\");\n+\t  Type_context subcontext(int_type, false);\n+\t  args->back()->determine_type(&subcontext);\n+\t  return;\n+\t}\n+      is_print = false;\n+      break;\n+\n     default:\n       is_print = false;\n       break;\n@@ -10353,6 +10506,78 @@ Builtin_call_expression::do_check_types(Gogo*)\n       }\n       break;\n \n+    case BUILTIN_ADD:\n+    case BUILTIN_SLICE:\n+      {\n+\tNumeric_constant nc;\n+\tunsigned long v;\n+\tconst Expression_list* args = this->args();\n+\tif (args == NULL || args->size() < 2)\n+\t  this->report_error(_(\"not enough arguments\"));\n+\telse if (args->size() > 2)\n+\t  this->report_error(_(\"too many arguments\"));\n+\telse if (args->front()->is_error_expression()\n+\t\t || args->front()->type()->is_error()\n+\t\t || args->back()->is_error_expression()\n+\t\t || args->back()->type()->is_error())\n+\t  this->set_is_error();\n+\telse if (args->back()->type()->integer_type() == NULL\n+\t\t && (!args->back()->type()->is_abstract()\n+\t\t     || !args->back()->numeric_constant_value(&nc)\n+\t\t     || (nc.to_unsigned_long(&v)\n+\t\t\t == Numeric_constant::NC_UL_NOTINT)))\n+\t  {\n+\t    if (this->code_ == BUILTIN_ADD)\n+\t      go_error_at(args->back()->location(), \"non-integer offset\");\n+\t    else\n+\t      go_error_at(args->back()->location(), \"non-integer size\");\n+\t  }\n+\telse if (this->code_ == BUILTIN_ADD)\n+\t  {\n+\t    Type* pointer_type =\n+\t      Type::make_pointer_type(Type::make_void_type());\n+\t    std::string reason;\n+\t    if (!Type::are_assignable(pointer_type, args->front()->type(),\n+\t\t\t\t      &reason))\n+\t      {\n+\t\tif (reason.empty())\n+\t\t  go_error_at(args->front()->location(),\n+\t\t\t      \"argument 1 has incompatible type\");\n+\t\telse\n+\t\t  go_error_at(args->front()->location(),\n+\t\t\t      \"argument 1 has incompatible type (%s)\",\n+\t\t\t      reason.c_str());\n+\t\tthis->set_is_error();\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    if (args->front()->type()->points_to() == NULL)\n+\t      {\n+\t\tgo_error_at(args->front()->location(),\n+\t\t\t    \"argument 1 must be a pointer\");\n+\t\tthis->set_is_error();\n+\t      }\n+\n+\t    unsigned int int_bits =\n+\t      Type::lookup_integer_type(\"int\")->integer_type()->bits();\n+\n+\t    mpz_t ival;\n+\t    if (args->back()->numeric_constant_value(&nc) && nc.to_int(&ival))\n+\t      {\n+\t\tif (mpz_sgn(ival) < 0\n+\t\t    || mpz_sizeinbase(ival, 2) >= int_bits)\n+\t\t  {\n+\t\t    go_error_at(args->back()->location(),\n+\t\t\t\t\"slice length out of range\");\n+\t\t    this->set_is_error();\n+\t\t  }\n+\t\tmpz_clear(ival);\n+\t      }\n+\t  }\n+      }\n+      break;\n+\n     default:\n       go_unreachable();\n     }\n@@ -10397,6 +10622,8 @@ Builtin_call_expression::do_get_backend(Translate_context* context)\n     case BUILTIN_INVALID:\n     case BUILTIN_NEW:\n     case BUILTIN_MAKE:\n+    case BUILTIN_ADD:\n+    case BUILTIN_SLICE:\n       go_unreachable();\n \n     case BUILTIN_LEN:"}, {"sha": "492849bb33ed39e00ce7a087d75925762470b465", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d0437d4a5faca2b695918cbe1d54a61935c98b/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d0437d4a5faca2b695918cbe1d54a61935c98b/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=06d0437d4a5faca2b695918cbe1d54a61935c98b", "patch": "@@ -2608,9 +2608,11 @@ class Builtin_call_expression : public Call_expression\n       BUILTIN_RECOVER,\n \n       // Builtin functions from the unsafe package.\n+      BUILTIN_ADD,\n       BUILTIN_ALIGNOF,\n       BUILTIN_OFFSETOF,\n-      BUILTIN_SIZEOF\n+      BUILTIN_SIZEOF,\n+      BUILTIN_SLICE\n     };\n \n   Builtin_function_code"}, {"sha": "231d92d2661ad7752bd6a46668953123a1ad98f5", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d0437d4a5faca2b695918cbe1d54a61935c98b/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d0437d4a5faca2b695918cbe1d54a61935c98b/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=06d0437d4a5faca2b695918cbe1d54a61935c98b", "patch": "@@ -489,6 +489,12 @@ DEF_GO_RUNTIME(ATOMIC_OR_FETCH_1, \"__atomic_or_fetch_1\",\n                P3(POINTER, UINT8, INT32),\n                R1(UINT8))\n \n+// Check the length of an unsafe slice.\n+DEF_GO_RUNTIME(UNSAFESLICE, \"runtime.unsafeslice\",\n+\t       P3(TYPE, POINTER, INT), R0())\n+DEF_GO_RUNTIME(UNSAFESLICE64, \"runtime.unsafeslice64\",\n+\t       P3(TYPE, POINTER, INT64), R0())\n+\n // Panic reporting a division by zero.\n DEF_GO_RUNTIME(PANIC_DIVIDE, \"runtime.panicdivide\", P0(), R0())\n "}, {"sha": "18bd99eca15af451f66dae8c969d34164392f1b1", "filename": "gcc/go/gofrontend/unsafe.cc", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d0437d4a5faca2b695918cbe1d54a61935c98b/gcc%2Fgo%2Fgofrontend%2Funsafe.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d0437d4a5faca2b695918cbe1d54a61935c98b/gcc%2Fgo%2Fgofrontend%2Funsafe.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Funsafe.cc?ref=06d0437d4a5faca2b695918cbe1d54a61935c98b", "patch": "@@ -86,6 +86,22 @@ Gogo::import_unsafe(const std::string& local_name, bool is_local_name_exported,\n   if (add_to_globals)\n     this->add_dot_import_object(no);\n \n+  // Add.\n+  results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", pointer_type, bloc));\n+  fntype = Type::make_function_type(NULL, NULL, results, bloc);\n+  fntype->set_is_builtin();\n+  no = bindings->add_function_declaration(\"Add\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_dot_import_object(no);\n+\n+  // Slice.\n+  fntype = Type::make_function_type(NULL, NULL, NULL, bloc);\n+  fntype->set_is_builtin();\n+  no = bindings->add_function_declaration(\"Slice\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_dot_import_object(no);\n+\n   if (!this->imported_unsafe_)\n     {\n       go_imported_unsafe();"}, {"sha": "4c940aa85599c12c4b4300744983ae769d43da49", "filename": "gcc/testsuite/go.test/test/unsafebuiltins.go", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d0437d4a5faca2b695918cbe1d54a61935c98b/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Funsafebuiltins.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d0437d4a5faca2b695918cbe1d54a61935c98b/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Funsafebuiltins.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Funsafebuiltins.go?ref=06d0437d4a5faca2b695918cbe1d54a61935c98b", "patch": "@@ -0,0 +1,64 @@\n+// run\n+\n+// Copyright 2021 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"math\"\n+\t\"unsafe\"\n+)\n+\n+const maxUintptr = 1 << (8 * unsafe.Sizeof(uintptr(0)))\n+\n+func main() {\n+\tvar p [10]byte\n+\n+\t// unsafe.Add\n+\t{\n+\t\tp1 := unsafe.Pointer(&p[1])\n+\t\tassert(unsafe.Add(p1, 1) == unsafe.Pointer(&p[2]))\n+\t\tassert(unsafe.Add(p1, -1) == unsafe.Pointer(&p[0]))\n+\t}\n+\n+\t// unsafe.Slice\n+\t{\n+\t\ts := unsafe.Slice(&p[0], len(p))\n+\t\tassert(&s[0] == &p[0])\n+\t\tassert(len(s) == len(p))\n+\t\tassert(cap(s) == len(p))\n+\n+\t\t// nil pointer with zero length returns nil\n+\t\tassert(unsafe.Slice((*int)(nil), 0) == nil)\n+\n+\t\t// nil pointer with positive length panics\n+\t\tmustPanic(func() { _ = unsafe.Slice((*int)(nil), 1) })\n+\n+\t\t// negative length\n+\t\tvar neg int = -1\n+\t\tmustPanic(func() { _ = unsafe.Slice(new(byte), neg) })\n+\n+\t\t// length too large\n+\t\tvar tooBig uint64 = math.MaxUint64\n+\t\tmustPanic(func() { _ = unsafe.Slice(new(byte), tooBig) })\n+\n+\t\t// size overflows address space\n+\t\tmustPanic(func() { _ = unsafe.Slice(new(uint64), maxUintptr/8) })\n+\t\tmustPanic(func() { _ = unsafe.Slice(new(uint64), maxUintptr/8+1) })\n+\t}\n+}\n+\n+func assert(ok bool) {\n+\tif !ok {\n+\t\tpanic(\"FAIL\")\n+\t}\n+}\n+\n+func mustPanic(f func()) {\n+\tdefer func() {\n+\t\tassert(recover() != nil)\n+\t}()\n+\tf()\n+}"}, {"sha": "d4c0e9028b7607fb540990fbda0fa5600dfffa6f", "filename": "libgo/go/runtime/slice.go", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d0437d4a5faca2b695918cbe1d54a61935c98b/libgo%2Fgo%2Fruntime%2Fslice.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d0437d4a5faca2b695918cbe1d54a61935c98b/libgo%2Fgo%2Fruntime%2Fslice.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fslice.go?ref=06d0437d4a5faca2b695918cbe1d54a61935c98b", "patch": "@@ -18,6 +18,8 @@ import (\n //go:linkname checkMakeSlice\n //go:linkname makeslice64\n //go:linkname growslice\n+//go:linkname unsafeslice\n+//go:linkname unsafeslice64\n \n type slice struct {\n \tarray unsafe.Pointer\n@@ -127,6 +129,33 @@ func makeslice64(et *_type, len64, cap64 int64) unsafe.Pointer {\n \treturn makeslice(et, len, cap)\n }\n \n+func unsafeslice(et *_type, ptr unsafe.Pointer, len int) {\n+\tif len == 0 {\n+\t\treturn\n+\t}\n+\n+\tif ptr == nil {\n+\t\tpanic(errorString(\"unsafe.Slice: ptr is nil and len is not zero\"))\n+\t}\n+\n+\tmem, overflow := math.MulUintptr(et.size, uintptr(len))\n+\tif overflow || mem > maxAlloc || len < 0 {\n+\t\tpanicunsafeslicelen()\n+\t}\n+}\n+\n+func unsafeslice64(et *_type, ptr unsafe.Pointer, len64 int64) {\n+\tlen := int(len64)\n+\tif int64(len) != len64 {\n+\t\tpanicunsafeslicelen()\n+\t}\n+\tunsafeslice(et, ptr, len)\n+}\n+\n+func panicunsafeslicelen() {\n+\tpanic(errorString(\"unsafe.Slice: len out of range\"))\n+}\n+\n // growslice handles slice growth during append.\n // It is passed the slice element type, the old slice, and the desired new minimum capacity,\n // and it returns a new slice with at least that capacity, with the old data"}]}