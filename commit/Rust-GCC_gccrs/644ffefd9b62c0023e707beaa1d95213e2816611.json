{"sha": "644ffefd9b62c0023e707beaa1d95213e2816611", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ0ZmZlZmQ5YjYyYzAwMjNlNzA3YmVhYTFkOTUyMTNlMjgxNjYxMQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2012-05-03T15:48:56Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2012-05-03T15:48:56Z"}, "message": "builtins.c (get_object_alignment_1): Return whether we can determine the alignment or conservatively assume byte...\n\n2012-05-03  Martin Jambor  <mjambor@suse.cz>\n\n\t* builtins.c (get_object_alignment_1): Return whether we can determine\n\tthe alignment or conservatively assume byte alignment.  Return the\n\talignment by reference.  Use get_pointer_alignment_1 for dereference\n\talignment.\n\t(get_pointer_alignment_1): Return whether we can determine the\n\talignment or conservatively assume byte alignment.  Return the\n\talignment by reference.  Use get_ptr_info_alignment to get SSA name\n\talignment.\n\t(get_object_alignment): Update call to get_object_alignment_1.\n\t(get_object_or_type_alignment): Likewise, fall back to type alignment\n\tonly when it returned false.\n\t(get_pointer_alignment): Update call to get_pointer_alignment_1.\n\t* fold-const.c (get_pointer_modulus_and_residue): Update call to\n\tget_object_alignment_1.\n\t* ipa-prop.c (ipa_modify_call_arguments): Update call to\n\tget_pointer_alignment_1.\n\t* tree-sra.c (build_ref_for_offset): Likewise, fall back to the type\n\tof MEM_REF or TARGET_MEM_REF only when it returns false.\n\t* tree-ssa-ccp.c (get_value_from_alignment): Update call to\n\tget_object_alignment_1.\n\t(ccp_finalize): Use set_ptr_info_alignment.\n\t* tree.h (get_object_alignment_1): Update declaration.\n\t(get_pointer_alignment_1): Likewise.\n\t* gimple-pretty-print.c (dump_gimple_phi): Use get_ptr_info_alignment.\n\t(dump_gimple_stmt): Likewise.\n\t* tree-flow.h (ptr_info_def): Updated comments of fields align and\n\tmisalign.\n\t(get_ptr_info_alignment): Declared.\n\t(mark_ptr_info_alignment_unknown): Likewise.\n\t(set_ptr_info_alignment): Likewise.\n\t(adjust_ptr_info_misalignment): Likewise.\n\t* tree-ssa-address.c (copy_ref_info): Use new access functions to get\n\tand set alignment of SSA names.\n\t* tree-ssa-loop-ivopts.c (rewrite_use_nonlinear_expr): Call\n\tmark_ptr_info_alignment_unknown.\n\t* tree-ssanames.c (get_ptr_info_alignment): New function.\n\t(mark_ptr_info_alignment_unknown): Likewise.\n\t(set_ptr_info_alignment): Likewise.\n\t(adjust_ptr_info_misalignment): Likewise.\n\t(get_ptr_info): Call mark_ptr_info_alignment_unknown.\n\t* tree-vect-data-refs.c (vect_create_addr_base_for_vector_ref):\n\tLikewise.\n\t(bump_vector_ptr): Likewise.\n\t* tree-vect-stmts.c (create_array_ref): Use set_ptr_info_alignment.\n\t(vectorizable_store): Likewise.\n\t(vectorizable_load): Likewise.\n\nFrom-SVN: r187101", "tree": {"sha": "e8950dc74bb16dd5c134d58dd1c869b0d3b374f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8950dc74bb16dd5c134d58dd1c869b0d3b374f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/644ffefd9b62c0023e707beaa1d95213e2816611", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/644ffefd9b62c0023e707beaa1d95213e2816611", "html_url": "https://github.com/Rust-GCC/gccrs/commit/644ffefd9b62c0023e707beaa1d95213e2816611", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/644ffefd9b62c0023e707beaa1d95213e2816611/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "445db530c33d3949c69b3d525e8d889a9a896306", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/445db530c33d3949c69b3d525e8d889a9a896306", "html_url": "https://github.com/Rust-GCC/gccrs/commit/445db530c33d3949c69b3d525e8d889a9a896306"}], "stats": {"total": 395, "additions": 271, "deletions": 124}, "files": [{"sha": "c7eb3b04f55ad82948668013640cc71109a31d92", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644ffefd9b62c0023e707beaa1d95213e2816611/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644ffefd9b62c0023e707beaa1d95213e2816611/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=644ffefd9b62c0023e707beaa1d95213e2816611", "patch": "@@ -1,3 +1,52 @@\n+2012-05-03  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* builtins.c (get_object_alignment_1): Return whether we can determine\n+\tthe alignment or conservatively assume byte alignment.  Return the\n+\talignment by reference.  Use get_pointer_alignment_1 for dereference\n+\talignment.\n+\t(get_pointer_alignment_1): Return whether we can determine the\n+\talignment or conservatively assume byte alignment.  Return the\n+\talignment by reference.  Use get_ptr_info_alignment to get SSA name\n+\talignment.\n+\t(get_object_alignment): Update call to get_object_alignment_1.\n+\t(get_object_or_type_alignment): Likewise, fall back to type alignment\n+\tonly when it returned false.\n+\t(get_pointer_alignment): Update call to get_pointer_alignment_1.\n+\t* fold-const.c (get_pointer_modulus_and_residue): Update call to\n+\tget_object_alignment_1.\n+\t* ipa-prop.c (ipa_modify_call_arguments): Update call to\n+\tget_pointer_alignment_1.\n+\t* tree-sra.c (build_ref_for_offset): Likewise, fall back to the type\n+\tof MEM_REF or TARGET_MEM_REF only when it returns false.\n+\t* tree-ssa-ccp.c (get_value_from_alignment): Update call to\n+\tget_object_alignment_1.\n+\t(ccp_finalize): Use set_ptr_info_alignment.\n+\t* tree.h (get_object_alignment_1): Update declaration.\n+\t(get_pointer_alignment_1): Likewise.\n+\t* gimple-pretty-print.c (dump_gimple_phi): Use get_ptr_info_alignment.\n+\t(dump_gimple_stmt): Likewise.\n+\t* tree-flow.h (ptr_info_def): Updated comments of fields align and\n+\tmisalign.\n+\t(get_ptr_info_alignment): Declared.\n+\t(mark_ptr_info_alignment_unknown): Likewise.\n+\t(set_ptr_info_alignment): Likewise.\n+\t(adjust_ptr_info_misalignment): Likewise.\n+\t* tree-ssa-address.c (copy_ref_info): Use new access functions to get\n+\tand set alignment of SSA names.\n+\t* tree-ssa-loop-ivopts.c (rewrite_use_nonlinear_expr): Call\n+\tmark_ptr_info_alignment_unknown.\n+\t* tree-ssanames.c (get_ptr_info_alignment): New function.\n+\t(mark_ptr_info_alignment_unknown): Likewise.\n+\t(set_ptr_info_alignment): Likewise.\n+\t(adjust_ptr_info_misalignment): Likewise.\n+\t(get_ptr_info): Call mark_ptr_info_alignment_unknown.\n+\t* tree-vect-data-refs.c (vect_create_addr_base_for_vector_ref):\n+\tLikewise.\n+\t(bump_vector_ptr): Likewise.\n+\t* tree-vect-stmts.c (create_array_ref): Use set_ptr_info_alignment.\n+\t(vectorizable_store): Likewise.\n+\t(vectorizable_load): Likewise.\n+\n 2012-05-03  Michael Matz  <matz@suse.de>\n \n \t* basic-block.h (struct rtl_bb_info, struct gimple_bb_info): Move"}, {"sha": "1ce9ac1db0ee901e4465e802401b43c7630e62f0", "filename": "gcc/builtins.c", "status": "modified", "additions": 95, "deletions": 59, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644ffefd9b62c0023e707beaa1d95213e2816611/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644ffefd9b62c0023e707beaa1d95213e2816611/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=644ffefd9b62c0023e707beaa1d95213e2816611", "patch": "@@ -263,8 +263,10 @@ called_as_built_in (tree node)\n   return is_builtin_name (name);\n }\n \n-/* Compute values M and N such that M divides (address of EXP - N) and\n-   such that N < M.  Store N in *BITPOSP and return M.\n+/* Compute values M and N such that M divides (address of EXP - N) and such\n+   that N < M.  If these numbers can be determined, store M in alignp and N in\n+   *BITPOSP and return true.  Otherwise return false and store BITS_PER_UNIT to\n+   *alignp and any bit-offset to *bitposp.\n \n    Note that the address (and thus the alignment) computed here is based\n    on the address to which a symbol resolves, whereas DECL_ALIGN is based\n@@ -273,14 +275,16 @@ called_as_built_in (tree node)\n    the address &foo of a Thumb function foo() has the lowest bit set,\n    whereas foo() itself starts on an even address.  */\n \n-unsigned int\n-get_object_alignment_1 (tree exp, unsigned HOST_WIDE_INT *bitposp)\n+bool\n+get_object_alignment_1 (tree exp, unsigned int *alignp,\n+\t\t\tunsigned HOST_WIDE_INT *bitposp)\n {\n   HOST_WIDE_INT bitsize, bitpos;\n   tree offset;\n   enum machine_mode mode;\n   int unsignedp, volatilep;\n-  unsigned int align, inner;\n+  unsigned int inner, align = BITS_PER_UNIT;\n+  bool known_alignment = false;\n \n   /* Get the innermost object and the constant (bitpos) and possibly\n      variable (offset) offset of the access.  */\n@@ -301,84 +305,97 @@ get_object_alignment_1 (tree exp, unsigned HOST_WIDE_INT *bitposp)\n \t     allows the low bit to be used as a virtual bit, we know\n \t     that the address itself must be 2-byte aligned.  */\n \t  if (TARGET_PTRMEMFUNC_VBIT_LOCATION == ptrmemfunc_vbit_in_pfn)\n-\t    align = 2 * BITS_PER_UNIT;\n-\t  else\n-\t    align = BITS_PER_UNIT;\n+\t    {\n+\t      known_alignment = true;\n+\t      align = 2 * BITS_PER_UNIT;\n+\t    }\n \t}\n       else\n-\talign = DECL_ALIGN (exp);\n+\t{\n+\t  known_alignment = true;\n+\t  align = DECL_ALIGN (exp);\n+\t}\n     }\n   else if (CONSTANT_CLASS_P (exp))\n     {\n+      known_alignment = true;\n       align = TYPE_ALIGN (TREE_TYPE (exp));\n #ifdef CONSTANT_ALIGNMENT\n       align = (unsigned)CONSTANT_ALIGNMENT (exp, align);\n #endif\n     }\n   else if (TREE_CODE (exp) == VIEW_CONVERT_EXPR)\n-    align = TYPE_ALIGN (TREE_TYPE (exp));\n+    {\n+      known_alignment = true;\n+      align = TYPE_ALIGN (TREE_TYPE (exp));\n+    }\n   else if (TREE_CODE (exp) == INDIRECT_REF)\n-    align = TYPE_ALIGN (TREE_TYPE (exp));\n+    {\n+      known_alignment = true;\n+      align = TYPE_ALIGN (TREE_TYPE (exp));\n+    }\n   else if (TREE_CODE (exp) == MEM_REF)\n     {\n       tree addr = TREE_OPERAND (exp, 0);\n-      struct ptr_info_def *pi;\n+      unsigned ptr_align;\n+      unsigned HOST_WIDE_INT ptr_bitpos;\n+\n       if (TREE_CODE (addr) == BIT_AND_EXPR\n \t  && TREE_CODE (TREE_OPERAND (addr, 1)) == INTEGER_CST)\n \t{\n+\t  known_alignment = true;\n \t  align = (TREE_INT_CST_LOW (TREE_OPERAND (addr, 1))\n \t\t    & -TREE_INT_CST_LOW (TREE_OPERAND (addr, 1)));\n \t  align *= BITS_PER_UNIT;\n \t  addr = TREE_OPERAND (addr, 0);\n \t}\n-      else\n-\talign = BITS_PER_UNIT;\n-      if (TREE_CODE (addr) == SSA_NAME\n-\t  && (pi = SSA_NAME_PTR_INFO (addr)))\n+\n+      if (get_pointer_alignment_1 (addr, &ptr_align, &ptr_bitpos))\n \t{\n-\t  bitpos += (pi->misalign * BITS_PER_UNIT) & ~(align - 1);\n-\t  align = MAX (pi->align * BITS_PER_UNIT, align);\n+\t  known_alignment = true;\n+\t  bitpos += ptr_bitpos & ~(align - 1);\n+\t  align = MAX (ptr_align, align);\n \t}\n-      else if (TREE_CODE (addr) == ADDR_EXPR)\n-\talign = MAX (align, get_object_alignment (TREE_OPERAND (addr, 0)));\n+\n       bitpos += mem_ref_offset (exp).low * BITS_PER_UNIT;\n     }\n   else if (TREE_CODE (exp) == TARGET_MEM_REF)\n     {\n-      struct ptr_info_def *pi;\n+      unsigned ptr_align;\n+      unsigned HOST_WIDE_INT ptr_bitpos;\n       tree addr = TMR_BASE (exp);\n+\n       if (TREE_CODE (addr) == BIT_AND_EXPR\n \t  && TREE_CODE (TREE_OPERAND (addr, 1)) == INTEGER_CST)\n \t{\n+\t  known_alignment = true;\n \t  align = (TREE_INT_CST_LOW (TREE_OPERAND (addr, 1))\n \t\t   & -TREE_INT_CST_LOW (TREE_OPERAND (addr, 1)));\n \t  align *= BITS_PER_UNIT;\n \t  addr = TREE_OPERAND (addr, 0);\n \t}\n-      else\n-\talign = BITS_PER_UNIT;\n-      if (TREE_CODE (addr) == SSA_NAME\n-\t  && (pi = SSA_NAME_PTR_INFO (addr)))\n+\n+      if (get_pointer_alignment_1 (addr, &ptr_align, &ptr_bitpos))\n \t{\n-\t  bitpos += (pi->misalign * BITS_PER_UNIT) & ~(align - 1);\n-\t  align = MAX (pi->align * BITS_PER_UNIT, align);\n+\t  known_alignment = true;\n+\t  bitpos += ptr_bitpos & ~(align - 1);\n+\t  align = MAX (ptr_align, align);\n \t}\n-      else if (TREE_CODE (addr) == ADDR_EXPR)\n-\talign = MAX (align, get_object_alignment (TREE_OPERAND (addr, 0)));\n+\n       if (TMR_OFFSET (exp))\n \tbitpos += TREE_INT_CST_LOW (TMR_OFFSET (exp)) * BITS_PER_UNIT;\n       if (TMR_INDEX (exp) && TMR_STEP (exp))\n \t{\n \t  unsigned HOST_WIDE_INT step = TREE_INT_CST_LOW (TMR_STEP (exp));\n \t  align = MIN (align, (step & -step) * BITS_PER_UNIT);\n+\t  known_alignment = true;\n \t}\n       else if (TMR_INDEX (exp))\n-\talign = BITS_PER_UNIT;\n+\tknown_alignment = false;\n+\n       if (TMR_INDEX2 (exp))\n-\talign = BITS_PER_UNIT;\n+\tknown_alignment = false;\n     }\n-  else\n-    align = BITS_PER_UNIT;\n \n   /* If there is a non-constant offset part extract the maximum\n      alignment that can prevail.  */\n@@ -418,19 +435,27 @@ get_object_alignment_1 (tree exp, unsigned HOST_WIDE_INT *bitposp)\n \t}\n       else\n \t{\n-\t  inner = MIN (inner, BITS_PER_UNIT);\n+\t  known_alignment = false;\n \t  break;\n \t}\n       offset = next_offset;\n     }\n \n-  /* Alignment is innermost object alignment adjusted by the constant\n-     and non-constant offset parts.  */\n-  align = MIN (align, inner);\n-  bitpos = bitpos & (align - 1);\n-\n+  if (known_alignment)\n+    {\n+      /* Alignment is innermost object alignment adjusted by the constant\n+\t and non-constant offset parts.  */\n+      align = MIN (align, inner);\n+      bitpos = bitpos & (align - 1);\n+      *alignp = align;\n+    }\n+  else\n+    {\n+      bitpos = bitpos & (BITS_PER_UNIT - 1);\n+      *alignp = BITS_PER_UNIT;\n+    }\n   *bitposp = bitpos;\n-  return align;\n+  return known_alignment;\n }\n \n /* Return the alignment in bits of EXP, an object.  */\n@@ -441,14 +466,13 @@ get_object_alignment (tree exp)\n   unsigned HOST_WIDE_INT bitpos = 0;\n   unsigned int align;\n \n-  align = get_object_alignment_1 (exp, &bitpos);\n+  get_object_alignment_1 (exp, &align, &bitpos);\n \n   /* align and bitpos now specify known low bits of the pointer.\n      ptr & (align - 1) == bitpos.  */\n \n   if (bitpos != 0)\n     align = (bitpos & -bitpos);\n-\n   return align;\n }\n \n@@ -465,45 +489,57 @@ unsigned int\n get_object_or_type_alignment (tree exp)\n {\n   unsigned HOST_WIDE_INT misalign;\n-  unsigned int align = get_object_alignment_1 (exp, &misalign);\n+  unsigned int align;\n+  bool known_alignment;\n \n   gcc_assert (TREE_CODE (exp) == MEM_REF || TREE_CODE (exp) == TARGET_MEM_REF);\n-\n+  known_alignment = get_object_alignment_1 (exp, &align, &misalign);\n   if (misalign != 0)\n     align = (misalign & -misalign);\n-  else\n-    align = MAX (TYPE_ALIGN (TREE_TYPE (exp)), align);\n+  else if (!known_alignment)\n+    align = TYPE_ALIGN (TREE_TYPE (exp));\n \n   return align;\n }\n \n-/* For a pointer valued expression EXP compute values M and N such that\n-   M divides (EXP - N) and such that N < M.  Store N in *BITPOSP and return M.\n+/* For a pointer valued expression EXP compute values M and N such that M\n+   divides (EXP - N) and such that N < M.  If these numbers can be determined,\n+   store M in alignp and N in *BITPOSP and return true.  Otherwise return false\n+   and store BITS_PER_UNIT to *alignp and any bit-offset to *bitposp.\n \n-   If EXP is not a pointer, 0 is returned.  */\n+   If EXP is not a pointer, false is returned too.  */\n \n-unsigned int\n-get_pointer_alignment_1 (tree exp, unsigned HOST_WIDE_INT *bitposp)\n+bool\n+get_pointer_alignment_1 (tree exp, unsigned int *alignp,\n+\t\t\t unsigned HOST_WIDE_INT *bitposp)\n {\n   STRIP_NOPS (exp);\n \n   if (TREE_CODE (exp) == ADDR_EXPR)\n-    return get_object_alignment_1 (TREE_OPERAND (exp, 0), bitposp);\n+    return get_object_alignment_1 (TREE_OPERAND (exp, 0), alignp, bitposp);\n   else if (TREE_CODE (exp) == SSA_NAME\n \t   && POINTER_TYPE_P (TREE_TYPE (exp)))\n     {\n+      unsigned int ptr_align, ptr_misalign;\n       struct ptr_info_def *pi = SSA_NAME_PTR_INFO (exp);\n-      if (!pi)\n+\n+      if (pi && get_ptr_info_alignment (pi, &ptr_align, &ptr_misalign))\n+\t{\n+\t  *bitposp = ptr_misalign * BITS_PER_UNIT;\n+\t  *alignp = ptr_align * BITS_PER_UNIT;\n+\t  return true;\n+\t}\n+      else\n \t{\n \t  *bitposp = 0;\n-\t  return BITS_PER_UNIT;\n+\t  *alignp = BITS_PER_UNIT;\n+\t  return false;\n \t}\n-      *bitposp = pi->misalign * BITS_PER_UNIT;\n-      return pi->align * BITS_PER_UNIT;\n     }\n \n   *bitposp = 0;\n-  return POINTER_TYPE_P (TREE_TYPE (exp)) ? BITS_PER_UNIT : 0;\n+  *alignp = BITS_PER_UNIT;\n+  return false;\n }\n \n /* Return the alignment in bits of EXP, a pointer valued expression.\n@@ -518,8 +554,8 @@ get_pointer_alignment (tree exp)\n {\n   unsigned HOST_WIDE_INT bitpos = 0;\n   unsigned int align;\n-  \n-  align = get_pointer_alignment_1 (exp, &bitpos);\n+\n+  get_pointer_alignment_1 (exp, &align, &bitpos);\n \n   /* align and bitpos now specify known low bits of the pointer.\n      ptr & (align - 1) == bitpos.  */"}, {"sha": "f8b31b7d1134d969dbb3d0beb58458cb7a54adfb", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644ffefd9b62c0023e707beaa1d95213e2816611/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644ffefd9b62c0023e707beaa1d95213e2816611/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=644ffefd9b62c0023e707beaa1d95213e2816611", "patch": "@@ -9536,7 +9536,7 @@ get_pointer_modulus_and_residue (tree expr, unsigned HOST_WIDE_INT *residue,\n   if (code == ADDR_EXPR)\n     {\n       unsigned int bitalign;\n-      bitalign = get_object_alignment_1 (TREE_OPERAND (expr, 0), residue);\n+      get_object_alignment_1 (TREE_OPERAND (expr, 0), &bitalign, residue);\n       *residue /= BITS_PER_UNIT;\n       return bitalign / BITS_PER_UNIT;\n     }"}, {"sha": "2e3cb0ca8722295985cde16effbc1d25e710de41", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644ffefd9b62c0023e707beaa1d95213e2816611/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644ffefd9b62c0023e707beaa1d95213e2816611/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=644ffefd9b62c0023e707beaa1d95213e2816611", "patch": "@@ -1590,14 +1590,14 @@ dump_gimple_phi (pretty_printer *buffer, gimple phi, int spc, int flags)\n       && POINTER_TYPE_P (TREE_TYPE (lhs))\n       && SSA_NAME_PTR_INFO (lhs))\n     {\n+      unsigned int align, misalign;\n       struct ptr_info_def *pi = SSA_NAME_PTR_INFO (lhs);\n       pp_string (buffer, \"PT = \");\n       pp_points_to_solution (buffer, &pi->pt);\n       newline_and_indent (buffer, spc);\n-      if (pi->align != 1)\n+      if (get_ptr_info_alignment (pi, &align, &misalign))\n \t{\n-\t  pp_printf (buffer, \"# ALIGN = %u, MISALIGN = %u\",\n-\t\t     pi->align, pi->misalign);\n+\t  pp_printf (buffer, \"# ALIGN = %u, MISALIGN = %u\", align, misalign);\n \t  newline_and_indent (buffer, spc);\n \t}\n       pp_string (buffer, \"# \");\n@@ -1889,14 +1889,15 @@ dump_gimple_stmt (pretty_printer *buffer, gimple gs, int spc, int flags)\n \t  && POINTER_TYPE_P (TREE_TYPE (lhs))\n \t  && SSA_NAME_PTR_INFO (lhs))\n \t{\n+\t  unsigned int align, misalign;\n \t  struct ptr_info_def *pi = SSA_NAME_PTR_INFO (lhs);\n \t  pp_string (buffer, \"# PT = \");\n \t  pp_points_to_solution (buffer, &pi->pt);\n \t  newline_and_indent (buffer, spc);\n-\t  if (pi->align != 1)\n+\t  if (get_ptr_info_alignment (pi, &align, &misalign))\n \t    {\n \t      pp_printf (buffer, \"# ALIGN = %u, MISALIGN = %u\",\n-\t\t\t pi->align, pi->misalign);\n+\t\t\t align, misalign);\n \t      newline_and_indent (buffer, spc);\n \t    }\n \t}"}, {"sha": "af0f335a993f85e9b3388893332629c083cac89d", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644ffefd9b62c0023e707beaa1d95213e2816611/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644ffefd9b62c0023e707beaa1d95213e2816611/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=644ffefd9b62c0023e707beaa1d95213e2816611", "patch": "@@ -2513,7 +2513,8 @@ ipa_modify_call_arguments (struct cgraph_edge *cs, gimple stmt,\n \t      tree type = adj->type;\n \t      unsigned int align;\n \t      unsigned HOST_WIDE_INT misalign;\n-\t      align = get_pointer_alignment_1 (base, &misalign);\n+\n+\t      get_pointer_alignment_1 (base, &align, &misalign);\n \t      misalign += (double_int_sext (tree_to_double_int (off),\n \t\t\t\t\t    TYPE_PRECISION (TREE_TYPE (off))).low\n \t\t\t   * BITS_PER_UNIT);"}, {"sha": "315d9558d14e1f86275b3f0fd9daed00926d5775", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644ffefd9b62c0023e707beaa1d95213e2816611/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644ffefd9b62c0023e707beaa1d95213e2816611/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=644ffefd9b62c0023e707beaa1d95213e2816611", "patch": "@@ -136,12 +136,17 @@ struct GTY(()) ptr_info_def\n      align and misalign specify low known bits of the pointer.\n      ptr & (align - 1) == misalign.  */\n \n-  /* The power-of-two byte alignment of the object this pointer\n-     points into.  This is usually DECL_ALIGN_UNIT for decls and\n-     MALLOC_ABI_ALIGNMENT for allocated storage.  */\n+  /* When known, this is the power-of-two byte alignment of the object this\n+     pointer points into.  This is usually DECL_ALIGN_UNIT for decls and\n+     MALLOC_ABI_ALIGNMENT for allocated storage.  When the alignment is not\n+     known, it is zero.  Do not access directly but use functions\n+     get_ptr_info_alignment, set_ptr_info_alignment,\n+     mark_ptr_info_alignment_unknown and similar.  */\n   unsigned int align;\n \n-  /* The byte offset this pointer differs from the above alignment.  */\n+  /* When alignment is known, the byte offset this pointer differs from the\n+     above alignment.  Access only through the same helper functions as align\n+     above.  */\n   unsigned int misalign;\n };\n \n@@ -593,6 +598,13 @@ extern void duplicate_ssa_name_ptr_info (tree, struct ptr_info_def *);\n extern void release_ssa_name (tree);\n extern void release_defs (gimple);\n extern void replace_ssa_name_symbol (tree, tree);\n+extern bool get_ptr_info_alignment (struct ptr_info_def *, unsigned int *,\n+\t\t\t\t    unsigned int *);\n+extern void mark_ptr_info_alignment_unknown (struct ptr_info_def *);\n+extern void set_ptr_info_alignment (struct ptr_info_def *, unsigned int,\n+\t\t\t\t    unsigned int);\n+extern void adjust_ptr_info_misalignment (struct ptr_info_def *,\n+\t\t\t\t\t  unsigned int);\n \n #ifdef GATHER_STATISTICS\n extern void ssanames_print_statistics (void);"}, {"sha": "3f84f6b22fb4dc64d135f4123b1e20296df5e6a7", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644ffefd9b62c0023e707beaa1d95213e2816611/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644ffefd9b62c0023e707beaa1d95213e2816611/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=644ffefd9b62c0023e707beaa1d95213e2816611", "patch": "@@ -1472,11 +1472,13 @@ build_ref_for_offset (location_t loc, tree base, HOST_WIDE_INT offset,\n      by looking at the access mode.  That would constrain the\n      alignment of base + base_offset which we would need to\n      adjust according to offset.  */\n-  align = get_pointer_alignment_1 (base, &misalign);\n-  if (misalign == 0\n-      && (TREE_CODE (prev_base) == MEM_REF\n-\t  || TREE_CODE (prev_base) == TARGET_MEM_REF))\n-    align = MAX (align, TYPE_ALIGN (TREE_TYPE (prev_base)));\n+  if (!get_pointer_alignment_1 (base, &align, &misalign))\n+    {\n+      gcc_assert (misalign == 0);\n+      if (TREE_CODE (prev_base) == MEM_REF\n+\t  || TREE_CODE (prev_base) == TARGET_MEM_REF)\n+\talign = TYPE_ALIGN (TREE_TYPE (prev_base));\n+    }\n   misalign += (double_int_sext (tree_to_double_int (off),\n \t\t\t\tTYPE_PRECISION (TREE_TYPE (off))).low\n \t       * BITS_PER_UNIT);"}, {"sha": "e11da3eb86943edc3a3da99430f6bb4e4a5b0c56", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644ffefd9b62c0023e707beaa1d95213e2816611/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644ffefd9b62c0023e707beaa1d95213e2816611/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=644ffefd9b62c0023e707beaa1d95213e2816611", "patch": "@@ -863,26 +863,26 @@ copy_ref_info (tree new_ref, tree old_ref)\n \t       && SSA_NAME_PTR_INFO (TREE_OPERAND (base, 0)))\n \t{\n \t  struct ptr_info_def *new_pi;\n+\t  unsigned int align, misalign;\n+\n \t  duplicate_ssa_name_ptr_info\n \t    (new_ptr_base, SSA_NAME_PTR_INFO (TREE_OPERAND (base, 0)));\n \t  new_pi = SSA_NAME_PTR_INFO (new_ptr_base);\n \t  /* We have to be careful about transfering alignment information.  */\n-\t  if (TREE_CODE (old_ref) == MEM_REF\n+\t  if (get_ptr_info_alignment (new_pi, &align, &misalign)\n+\t      && TREE_CODE (old_ref) == MEM_REF\n \t      && !(TREE_CODE (new_ref) == TARGET_MEM_REF\n \t\t   && (TMR_INDEX2 (new_ref)\n \t\t       || (TMR_STEP (new_ref)\n \t\t\t   && (TREE_INT_CST_LOW (TMR_STEP (new_ref))\n-\t\t\t       < new_pi->align)))))\n+\t\t\t       < align)))))\n \t    {\n-\t      new_pi->misalign += double_int_sub (mem_ref_offset (old_ref),\n-\t\t\t\t\t\t  mem_ref_offset (new_ref)).low;\n-\t      new_pi->misalign &= (new_pi->align - 1);\n+\t      unsigned int inc = double_int_sub (mem_ref_offset (old_ref),\n+\t\t\t\t\t\t mem_ref_offset (new_ref)).low;\n+\t      adjust_ptr_info_misalignment (new_pi, inc);\n \t    }\n \t  else\n-\t    {\n-\t      new_pi->align = 1;\n-\t      new_pi->misalign = 0;\n-\t    }\n+\t    mark_ptr_info_alignment_unknown (new_pi);\n \t}\n       else if (TREE_CODE (base) == VAR_DECL\n \t       || TREE_CODE (base) == PARM_DECL"}, {"sha": "feded5bfab87f6f2a5932b7e9b87b7b07060b28a", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644ffefd9b62c0023e707beaa1d95213e2816611/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644ffefd9b62c0023e707beaa1d95213e2816611/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=644ffefd9b62c0023e707beaa1d95213e2816611", "patch": "@@ -513,7 +513,7 @@ get_value_from_alignment (tree expr)\n \n   gcc_assert (TREE_CODE (expr) == ADDR_EXPR);\n \n-  align = get_object_alignment_1 (TREE_OPERAND (expr, 0), &bitpos);\n+  get_object_alignment_1 (TREE_OPERAND (expr, 0), &align, &bitpos);\n   val.mask\n     = double_int_and_not (POINTER_TYPE_P (type) || TYPE_UNSIGNED (type)\n \t\t\t  ? double_int_mask (TYPE_PRECISION (type))\n@@ -807,7 +807,6 @@ ccp_finalize (void)\n     {\n       tree name = ssa_name (i);\n       prop_value_t *val;\n-      struct ptr_info_def *pi;\n       unsigned int tem, align;\n \n       if (!name\n@@ -823,12 +822,9 @@ ccp_finalize (void)\n \t bits the misalignment.  */\n       tem = val->mask.low;\n       align = (tem & -tem);\n-      if (align == 1)\n-\tcontinue;\n-\n-      pi = get_ptr_info (name);\n-      pi->align = align;\n-      pi->misalign = TREE_INT_CST_LOW (val->value) & (align - 1);\n+      if (align > 1)\n+\tset_ptr_info_alignment (get_ptr_info (name), align,\n+\t\t\t\tTREE_INT_CST_LOW (val->value) & (align - 1));\n     }\n \n   /* Perform substitutions based on the known constant values.  */"}, {"sha": "af7a1cf1d5e6c517914cc8c684b7b0d7dcb9811f", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644ffefd9b62c0023e707beaa1d95213e2816611/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644ffefd9b62c0023e707beaa1d95213e2816611/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=644ffefd9b62c0023e707beaa1d95213e2816611", "patch": "@@ -6259,10 +6259,7 @@ rewrite_use_nonlinear_expr (struct ivopts_data *data,\n \t  /* As this isn't a plain copy we have to reset alignment\n \t     information.  */\n \t  if (SSA_NAME_PTR_INFO (comp))\n-\t    {\n-\t      SSA_NAME_PTR_INFO (comp)->align = 1;\n-\t      SSA_NAME_PTR_INFO (comp)->misalign = 0;\n-\t    }\n+\t    mark_ptr_info_alignment_unknown (SSA_NAME_PTR_INFO (comp));\n \t}\n     }\n "}, {"sha": "64455af96040a41ec56e9c2ade40efb8736771e8", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 57, "deletions": 2, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644ffefd9b62c0023e707beaa1d95213e2816611/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644ffefd9b62c0023e707beaa1d95213e2816611/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=644ffefd9b62c0023e707beaa1d95213e2816611", "patch": "@@ -238,6 +238,62 @@ release_ssa_name (tree var)\n     }\n }\n \n+/* If the alignment of the pointer described by PI is known, return true and\n+   store the alignment and the deviation from it into *ALIGNP and *MISALIGNP\n+   respectively.  Otherwise return false.  */\n+\n+bool\n+get_ptr_info_alignment (struct ptr_info_def *pi, unsigned int *alignp,\n+\t\t\tunsigned int *misalignp)\n+{\n+  if (pi->align)\n+    {\n+      *alignp = pi->align;\n+      *misalignp = pi->misalign;\n+      return true;\n+    }\n+  else\n+    return false;\n+}\n+\n+/* State that the pointer described by PI has unknown alignment.  */\n+\n+void\n+mark_ptr_info_alignment_unknown (struct ptr_info_def *pi)\n+{\n+  pi->align = 0;\n+  pi->misalign = 0;\n+}\n+\n+/* Store the the power-of-two byte alignment and the deviation from that\n+   alignment of pointer described by PI to ALIOGN and MISALIGN\n+   respectively.  */\n+\n+void\n+set_ptr_info_alignment (struct ptr_info_def *pi, unsigned int align,\n+\t\t\t    unsigned int misalign)\n+{\n+  gcc_checking_assert (align != 0);\n+  gcc_assert ((align & (align - 1)) == 0);\n+  gcc_assert ((misalign & ~(align - 1)) == 0);\n+\n+  pi->align = align;\n+  pi->misalign = misalign;\n+}\n+\n+/* If pointer decribed by PI has known alignment, increase its known\n+   misalignment by INCREMENT modulo its current alignment.  */\n+\n+void\n+adjust_ptr_info_misalignment (struct ptr_info_def *pi,\n+\t\t\t      unsigned int increment)\n+{\n+  if (pi->align != 0)\n+    {\n+      pi->misalign += increment;\n+      pi->misalign &= (pi->align - 1);\n+    }\n+}\n \n /* Return the alias information associated with pointer T.  It creates a\n    new instance if none existed.  */\n@@ -254,8 +310,7 @@ get_ptr_info (tree t)\n     {\n       pi = ggc_alloc_cleared_ptr_info_def ();\n       pt_solution_reset (&pi->pt);\n-      pi->align = 1;\n-      pi->misalign = 0;\n+      mark_ptr_info_alignment_unknown (pi);\n       SSA_NAME_PTR_INFO (t) = pi;\n     }\n "}, {"sha": "74640345915f453f6e0ac705fc5fbbeb94375abd", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644ffefd9b62c0023e707beaa1d95213e2816611/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644ffefd9b62c0023e707beaa1d95213e2816611/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=644ffefd9b62c0023e707beaa1d95213e2816611", "patch": "@@ -3397,10 +3397,7 @@ vect_create_addr_base_for_vector_ref (gimple stmt,\n     {\n       duplicate_ssa_name_ptr_info (vec_stmt, DR_PTR_INFO (dr));\n       if (offset)\n-\t{\n-\t  SSA_NAME_PTR_INFO (vec_stmt)->align = 1;\n-\t  SSA_NAME_PTR_INFO (vec_stmt)->misalign = 0;\n-\t}\n+\tmark_ptr_info_alignment_unknown (SSA_NAME_PTR_INFO (vec_stmt));\n     }\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n@@ -3799,8 +3796,7 @@ bump_vector_ptr (tree dataref_ptr, gimple ptr_incr, gimple_stmt_iterator *gsi,\n   if (DR_PTR_INFO (dr))\n     {\n       duplicate_ssa_name_ptr_info (new_dataref_ptr, DR_PTR_INFO (dr));\n-      SSA_NAME_PTR_INFO (new_dataref_ptr)->align = 1;\n-      SSA_NAME_PTR_INFO (new_dataref_ptr)->misalign = 0;\n+      mark_ptr_info_alignment_unknown (SSA_NAME_PTR_INFO (new_dataref_ptr));\n     }\n \n   if (!ptr_incr)"}, {"sha": "a0368d83e949e6b1e817821e263d214b96e0de53", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644ffefd9b62c0023e707beaa1d95213e2816611/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644ffefd9b62c0023e707beaa1d95213e2816611/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=644ffefd9b62c0023e707beaa1d95213e2816611", "patch": "@@ -106,15 +106,12 @@ write_vector_array (gimple stmt, gimple_stmt_iterator *gsi, tree vect,\n static tree\n create_array_ref (tree type, tree ptr, struct data_reference *first_dr)\n {\n-  struct ptr_info_def *pi;\n   tree mem_ref, alias_ptr_type;\n \n   alias_ptr_type = reference_alias_ptr_type (DR_REF (first_dr));\n   mem_ref = build2 (MEM_REF, type, ptr, build_int_cst (alias_ptr_type, 0));\n   /* Arrays have the same alignment as their type.  */\n-  pi = get_ptr_info (ptr);\n-  pi->align = TYPE_ALIGN_UNIT (type);\n-  pi->misalign = 0;\n+  set_ptr_info_alignment (get_ptr_info (ptr), TYPE_ALIGN_UNIT (type), 0);\n   return mem_ref;\n }\n \n@@ -4029,7 +4026,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t  next_stmt = first_stmt;\n \t  for (i = 0; i < vec_num; i++)\n \t    {\n-\t      struct ptr_info_def *pi;\n+\t      unsigned align, misalign;\n \n \t      if (i > 0)\n \t\t/* Bump the vector pointer.  */\n@@ -4046,25 +4043,26 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t      data_ref = build2 (MEM_REF, TREE_TYPE (vec_oprnd), dataref_ptr,\n \t\t\t\t build_int_cst (reference_alias_ptr_type\n \t\t\t\t\t\t(DR_REF (first_dr)), 0));\n-\t      pi = get_ptr_info (dataref_ptr);\n-\t      pi->align = TYPE_ALIGN_UNIT (vectype);\n+\t      align = TYPE_ALIGN_UNIT (vectype);\n \t      if (aligned_access_p (first_dr))\n-\t\tpi->misalign = 0;\n+\t\tmisalign = 0;\n \t      else if (DR_MISALIGNMENT (first_dr) == -1)\n \t\t{\n \t\t  TREE_TYPE (data_ref)\n \t\t    = build_aligned_type (TREE_TYPE (data_ref),\n \t\t\t\t\t  TYPE_ALIGN (elem_type));\n-\t\t  pi->align = TYPE_ALIGN_UNIT (elem_type);\n-\t\t  pi->misalign = 0;\n+\t\t  align = TYPE_ALIGN_UNIT (elem_type);\n+\t\t  misalign = 0;\n \t\t}\n \t      else\n \t\t{\n \t\t  TREE_TYPE (data_ref)\n \t\t    = build_aligned_type (TREE_TYPE (data_ref),\n \t\t\t\t\t  TYPE_ALIGN (elem_type));\n-\t\t  pi->misalign = DR_MISALIGNMENT (first_dr);\n+\t\t  misalign = DR_MISALIGNMENT (first_dr);\n \t\t}\n+\t      set_ptr_info_alignment (get_ptr_info (dataref_ptr), align,\n+\t\t\t\t      misalign);\n \n \t      /* Arguments are ready.  Create the new vector stmt.  */\n \t      new_stmt = gimple_build_assign (data_ref, vec_oprnd);\n@@ -4860,33 +4858,35 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\tcase dr_aligned:\n \t\tcase dr_unaligned_supported:\n \t\t  {\n-\t\t    struct ptr_info_def *pi;\n+\t\t    unsigned int align, misalign;\n+\n \t\t    data_ref\n \t\t      = build2 (MEM_REF, vectype, dataref_ptr,\n \t\t\t\tbuild_int_cst (reference_alias_ptr_type\n \t\t\t\t\t       (DR_REF (first_dr)), 0));\n-\t\t    pi = get_ptr_info (dataref_ptr);\n-\t\t    pi->align = TYPE_ALIGN_UNIT (vectype);\n+\t\t    align = TYPE_ALIGN_UNIT (vectype);\n \t\t    if (alignment_support_scheme == dr_aligned)\n \t\t      {\n \t\t\tgcc_assert (aligned_access_p (first_dr));\n-\t\t\tpi->misalign = 0;\n+\t\t\tmisalign = 0;\n \t\t      }\n \t\t    else if (DR_MISALIGNMENT (first_dr) == -1)\n \t\t      {\n \t\t\tTREE_TYPE (data_ref)\n \t\t\t  = build_aligned_type (TREE_TYPE (data_ref),\n \t\t\t\t\t\tTYPE_ALIGN (elem_type));\n-\t\t\tpi->align = TYPE_ALIGN_UNIT (elem_type);\n-\t\t\tpi->misalign = 0;\n+\t\t\talign = TYPE_ALIGN_UNIT (elem_type);\n+\t\t\tmisalign = 0;\n \t\t      }\n \t\t    else\n \t\t      {\n \t\t\tTREE_TYPE (data_ref)\n \t\t\t  = build_aligned_type (TREE_TYPE (data_ref),\n \t\t\t\t\t\tTYPE_ALIGN (elem_type));\n-\t\t\tpi->misalign = DR_MISALIGNMENT (first_dr);\n+\t\t\tmisalign = DR_MISALIGNMENT (first_dr);\n \t\t      }\n+\t\t    set_ptr_info_alignment (get_ptr_info (dataref_ptr),\n+\t\t\t\t\t    align, misalign);\n \t\t    break;\n \t\t  }\n \t\tcase dr_explicit_realign:"}, {"sha": "9d53a14dd7b07bf08379462dac43ca51e0ace354", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/644ffefd9b62c0023e707beaa1d95213e2816611/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/644ffefd9b62c0023e707beaa1d95213e2816611/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=644ffefd9b62c0023e707beaa1d95213e2816611", "patch": "@@ -5465,10 +5465,12 @@ extern tree build_string_literal (int, const char *);\n extern bool validate_arglist (const_tree, ...);\n extern rtx builtin_memset_read_str (void *, HOST_WIDE_INT, enum machine_mode);\n extern bool is_builtin_fn (tree);\n-extern unsigned int get_object_alignment_1 (tree, unsigned HOST_WIDE_INT *);\n+extern bool get_object_alignment_1 (tree, unsigned int *,\n+\t\t\t\t    unsigned HOST_WIDE_INT *);\n extern unsigned int get_object_alignment (tree);\n extern unsigned int get_object_or_type_alignment (tree);\n-extern unsigned int get_pointer_alignment_1 (tree, unsigned HOST_WIDE_INT *);\n+extern bool get_pointer_alignment_1 (tree, unsigned int *,\n+\t\t\t\t     unsigned HOST_WIDE_INT *);\n extern unsigned int get_pointer_alignment (tree);\n extern tree fold_call_stmt (gimple, bool);\n extern tree gimple_fold_builtin_snprintf_chk (gimple, tree, enum built_in_function);"}]}