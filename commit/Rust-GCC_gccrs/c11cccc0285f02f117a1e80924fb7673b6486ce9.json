{"sha": "c11cccc0285f02f117a1e80924fb7673b6486ce9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzExY2NjYzAyODVmMDJmMTE3YTFlODA5MjRmYjc2NzNiNjQ4NmNlOQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-10-17T17:30:49Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-10-17T17:30:49Z"}, "message": "tree-vectorizer.h (_stmt_vec_info::cond_reduc_code): Remove.\n\n2019-10-17  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (_stmt_vec_info::cond_reduc_code): Remove.\n\t(STMT_VINFO_VEC_COND_REDUC_CODE): Likewise.\n\t* tree-vectorizer.c (vec_info::new_stmt_vec_info): Do not\n\tinitialize STMT_VINFO_VEC_COND_REDUC_CODE.\n\t* tree-vect-loop.c (vect_is_simple_reduction): Set\n\tSTMT_VINFO_REDUC_CODE.\n\t(vectorizable_reduction): Remove dead and redundant code, use\n\tSTMT_VINFO_REDUC_CODE instead of STMT_VINFO_VEC_COND_REDUC_CODE.\n\nFrom-SVN: r277126", "tree": {"sha": "4ed96a0431768a8a2c260e0ebf69a75015d9ff8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ed96a0431768a8a2c260e0ebf69a75015d9ff8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c11cccc0285f02f117a1e80924fb7673b6486ce9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c11cccc0285f02f117a1e80924fb7673b6486ce9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c11cccc0285f02f117a1e80924fb7673b6486ce9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c11cccc0285f02f117a1e80924fb7673b6486ce9/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1a456495015d3be8d49751031ce58b4991ab6f50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a456495015d3be8d49751031ce58b4991ab6f50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a456495015d3be8d49751031ce58b4991ab6f50"}], "stats": {"total": 152, "additions": 43, "deletions": 109}, "files": [{"sha": "0f3720194bd763dd85dc842744eedcfb3a355b09", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11cccc0285f02f117a1e80924fb7673b6486ce9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11cccc0285f02f117a1e80924fb7673b6486ce9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c11cccc0285f02f117a1e80924fb7673b6486ce9", "patch": "@@ -1,3 +1,14 @@\n+2019-10-17  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (_stmt_vec_info::cond_reduc_code): Remove.\n+\t(STMT_VINFO_VEC_COND_REDUC_CODE): Likewise.\n+\t* tree-vectorizer.c (vec_info::new_stmt_vec_info): Do not\n+\tinitialize STMT_VINFO_VEC_COND_REDUC_CODE.\n+\t* tree-vect-loop.c (vect_is_simple_reduction): Set\n+\tSTMT_VINFO_REDUC_CODE.\n+\t(vectorizable_reduction): Remove dead and redundant code, use\n+\tSTMT_VINFO_REDUC_CODE instead of STMT_VINFO_VEC_COND_REDUC_CODE.\n+\n 2019-10-17  Georg-Johann Lay  <avr@gjlay.de>\n \n \tFix breakage introduced by r276985."}, {"sha": "80db6abe49021b6c0eb04df109148d7ce1f82393", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 32, "deletions": 103, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11cccc0285f02f117a1e80924fb7673b6486ce9/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11cccc0285f02f117a1e80924fb7673b6486ce9/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=c11cccc0285f02f117a1e80924fb7673b6486ce9", "patch": "@@ -2893,6 +2893,7 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n   if (check_reduction_path (vect_location, loop, phi, latch_def, &code,\n \t\t\t    path))\n     {\n+      STMT_VINFO_REDUC_CODE (phi_info) = code;\n       if (code == COND_EXPR && !nested_in_vect_loop)\n \tSTMT_VINFO_REDUC_TYPE (phi_info) = COND_REDUCTION;\n \n@@ -5571,17 +5572,13 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n   tree vectype_in = NULL_TREE;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  enum tree_code code;\n-  int op_type;\n-  enum vect_def_type dt, cond_reduc_dt = vect_unknown_def_type;\n+  enum vect_def_type cond_reduc_dt = vect_unknown_def_type;\n   stmt_vec_info cond_stmt_vinfo = NULL;\n   tree scalar_type;\n   int i;\n   int ncopies;\n   bool single_defuse_cycle = false;\n-  tree ops[3];\n-  enum vect_def_type dts[3];\n-  bool nested_cycle = false, found_nested_cycle_def = false;\n+  bool nested_cycle = false;\n   bool double_reduc = false;\n   int vec_num;\n   tree tem;\n@@ -5688,25 +5685,10 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n         which is defined by the loop-header-phi.  */\n \n   gassign *stmt = as_a <gassign *> (stmt_info->stmt);\n-\n-  /* Flatten RHS.  */\n   switch (get_gimple_rhs_class (gimple_assign_rhs_code (stmt)))\n     {\n     case GIMPLE_BINARY_RHS:\n-      code = gimple_assign_rhs_code (stmt);\n-      op_type = TREE_CODE_LENGTH (code);\n-      gcc_assert (op_type == binary_op);\n-      ops[0] = gimple_assign_rhs1 (stmt);\n-      ops[1] = gimple_assign_rhs2 (stmt);\n-      break;\n-\n     case GIMPLE_TERNARY_RHS:\n-      code = gimple_assign_rhs_code (stmt);\n-      op_type = TREE_CODE_LENGTH (code);\n-      gcc_assert (op_type == ternary_op);\n-      ops[0] = gimple_assign_rhs1 (stmt);\n-      ops[1] = gimple_assign_rhs2 (stmt);\n-      ops[2] = gimple_assign_rhs3 (stmt);\n       break;\n \n     case GIMPLE_UNARY_RHS:\n@@ -5716,9 +5698,8 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n     default:\n       gcc_unreachable ();\n     }\n-\n-  if (code == COND_EXPR && slp_node)\n-    return false;\n+  enum tree_code code = gimple_assign_rhs_code (stmt);\n+  int op_type = TREE_CODE_LENGTH (code);\n \n   scalar_dest = gimple_assign_lhs (stmt);\n   scalar_type = TREE_TYPE (scalar_dest);\n@@ -5742,57 +5723,48 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n   int reduc_index = -1;\n   for (i = 0; i < op_type; i++)\n     {\n+      tree op = gimple_op (stmt, i + 1);\n       /* The condition of COND_EXPR is checked in vectorizable_condition().  */\n       if (i == 0 && code == COND_EXPR)\n         continue;\n \n       stmt_vec_info def_stmt_info;\n-      if (!vect_is_simple_use (ops[i], loop_vinfo, &dts[i], &tem,\n+      enum vect_def_type dt;\n+      if (!vect_is_simple_use (op, loop_vinfo, &dt, &tem,\n \t\t\t       &def_stmt_info))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"use not simple.\\n\");\n \t  return false;\n \t}\n-      dt = dts[i];\n-      if (dt == vect_reduction_def\n-\t  && ops[i] == reduc_def)\n+      if ((dt == vect_reduction_def || dt == vect_nested_cycle)\n+\t  && op == reduc_def)\n \t{\n \t  reduc_index = i;\n \t  continue;\n \t}\n-      else if (tem)\n-\t{\n-\t  /* To properly compute ncopies we are interested in the widest\n-\t     input type in case we're looking at a widening accumulation.  */\n-\t  if (!vectype_in\n-\t      || (GET_MODE_SIZE (SCALAR_TYPE_MODE (TREE_TYPE (vectype_in)))\n-\t\t  < GET_MODE_SIZE (SCALAR_TYPE_MODE (TREE_TYPE (tem)))))\n-\t    vectype_in = tem;\n-\t}\n \n-      if (dt != vect_internal_def\n-\t  && dt != vect_external_def\n-\t  && dt != vect_constant_def\n-\t  && dt != vect_induction_def\n-          && !(dt == vect_nested_cycle && nested_cycle))\n+      /* There should be only one cycle def in the stmt, the one\n+         leading to reduc_def.  */\n+      if (VECTORIZABLE_CYCLE_DEF (dt))\n \treturn false;\n \n-      if (dt == vect_nested_cycle\n-\t  && ops[i] == reduc_def)\n-\t{\n-\t  found_nested_cycle_def = true;\n-\t  reduc_index = i;\n-\t}\n+      /* To properly compute ncopies we are interested in the widest\n+\t input type in case we're looking at a widening accumulation.  */\n+      if (tem\n+\t  && (!vectype_in\n+\t      || (GET_MODE_SIZE (SCALAR_TYPE_MODE (TREE_TYPE (vectype_in)))\n+\t\t  < GET_MODE_SIZE (SCALAR_TYPE_MODE (TREE_TYPE (tem))))))\n+\tvectype_in = tem;\n \n       if (code == COND_EXPR)\n \t{\n \t  /* Record how the non-reduction-def value of COND_EXPR is defined.  */\n \t  if (dt == vect_constant_def)\n \t    {\n \t      cond_reduc_dt = dt;\n-\t      cond_reduc_val = ops[i];\n+\t      cond_reduc_val = op;\n \t    }\n \t  if (dt == vect_induction_def\n \t      && def_stmt_info\n@@ -5811,27 +5783,14 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n      operation in the reduction meta.  */\n   STMT_VINFO_REDUC_IDX (reduc_info) = reduc_index;\n \n-  if (!(reduc_index == -1\n-\t|| dts[reduc_index] == vect_reduction_def\n-\t|| dts[reduc_index] == vect_nested_cycle\n-\t|| ((dts[reduc_index] == vect_internal_def\n-\t     || dts[reduc_index] == vect_external_def\n-\t     || dts[reduc_index] == vect_constant_def\n-\t     || dts[reduc_index] == vect_induction_def)\n-\t    && nested_cycle && found_nested_cycle_def)))\n-    {\n-      /* For pattern recognized stmts, orig_stmt might be a reduction,\n-\t but some helper statements for the pattern might not, or\n-\t might be COND_EXPRs with reduction uses in the condition.  */\n-      gcc_assert (orig_stmt_info);\n-      return false;\n-    }\n-\n   enum vect_reduction_type v_reduc_type = STMT_VINFO_REDUC_TYPE (phi_info);\n   STMT_VINFO_REDUC_TYPE (reduc_info) = v_reduc_type;\n   /* If we have a condition reduction, see if we can simplify it further.  */\n   if (v_reduc_type == COND_REDUCTION)\n     {\n+      if (slp_node)\n+\treturn false;\n+\n       /* TODO: We can't yet handle reduction chains, since we need to treat\n \t each COND_EXPR in the chain specially, not just the last one.\n \t E.g. for:\n@@ -5912,7 +5871,7 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n \t\tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t\t \"condition expression based on \"\n \t\t\t\t \"integer induction.\\n\");\n-\t      STMT_VINFO_VEC_COND_REDUC_CODE (reduc_info) = cond_reduc_op_code;\n+\t      STMT_VINFO_REDUC_CODE (reduc_info) = cond_reduc_op_code;\n \t      STMT_VINFO_VEC_INDUC_COND_INITIAL_VAL (reduc_info)\n \t\t= cond_reduc_val;\n \t      STMT_VINFO_REDUC_TYPE (reduc_info) = INTEGER_INDUC_COND_REDUCTION;\n@@ -5921,9 +5880,8 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n       else if (cond_reduc_dt == vect_constant_def)\n \t{\n \t  enum vect_def_type cond_initial_dt;\n-\t  gimple *def_stmt = SSA_NAME_DEF_STMT (ops[reduc_index]);\n \t  tree cond_initial_val\n-\t    = PHI_ARG_DEF_FROM_EDGE (def_stmt, loop_preheader_edge (loop));\n+\t    = PHI_ARG_DEF_FROM_EDGE (reduc_def_phi, loop_preheader_edge (loop));\n \n \t  gcc_assert (cond_reduc_val != NULL_TREE);\n \t  vect_is_simple_use (cond_initial_val, loop_vinfo, &cond_initial_dt);\n@@ -5940,7 +5898,7 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n \t\t\t\t     \"condition expression based on \"\n \t\t\t\t     \"compile time constant.\\n\");\n \t\t  /* Record reduction code at analysis stage.  */\n-\t\t  STMT_VINFO_VEC_COND_REDUC_CODE (reduc_info)\n+\t\t  STMT_VINFO_REDUC_CODE (reduc_info)\n \t\t    = integer_onep (e) ? MAX_EXPR : MIN_EXPR;\n \t\t  STMT_VINFO_REDUC_TYPE (reduc_info) = CONST_COND_REDUCTION;\n \t\t}\n@@ -6008,31 +5966,10 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n           (and also the same tree-code) when generating the epilog code and\n           when generating the code inside the loop.  */\n \n-  vect_reduction_type reduction_type = STMT_VINFO_REDUC_TYPE (reduc_info);\n-  enum tree_code orig_code = ERROR_MARK;\n-  if (reduction_type == CONST_COND_REDUCTION\n-      || reduction_type == INTEGER_INDUC_COND_REDUCTION)\n-    {\n-      /* For simple condition reductions, replace with the actual expression\n-\t we want to base our reduction around.  */\n-      orig_code = STMT_VINFO_VEC_COND_REDUC_CODE (reduc_info);\n-      gcc_assert (orig_code == MAX_EXPR || orig_code == MIN_EXPR);\n-    }\n-  else if (reduction_type == COND_REDUCTION)\n-    orig_code = COND_EXPR;\n-  else if (reduction_type == TREE_CODE_REDUCTION\n-\t   || reduction_type == FOLD_LEFT_REDUCTION)\n-    {\n-      if (orig_stmt_info)\n-\torig_code = gimple_assign_rhs_code (orig_stmt_info->stmt);\n-      else\n-\torig_code = code;\n-      gcc_assert (vectype_out);\n-      if (orig_code == MINUS_EXPR)\n-\torig_code = PLUS_EXPR;\n-    }\n+  enum tree_code orig_code = STMT_VINFO_REDUC_CODE (phi_info);\n   STMT_VINFO_REDUC_CODE (reduc_info) = orig_code;\n \n+  vect_reduction_type reduction_type = STMT_VINFO_REDUC_TYPE (reduc_info);\n   if (reduction_type == TREE_CODE_REDUCTION)\n     {\n       /* Check whether it's ok to change the order of the computation.\n@@ -6139,7 +6076,7 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n   tree neutral_op = NULL_TREE;\n   if (slp_node)\n     neutral_op = neutral_op_for_slp_reduction\n-      (slp_node_instance->reduc_phis, code,\n+      (slp_node_instance->reduc_phis, orig_code,\n        REDUC_GROUP_FIRST_ELEMENT (stmt_info) != NULL);\n \n   if (double_reduc && reduction_type == FOLD_LEFT_REDUCTION)\n@@ -6230,14 +6167,6 @@ vectorizable_reduction (stmt_vec_info stmt_info, slp_tree slp_node,\n \t}\n     }\n \n-  /* In case of widenning multiplication by a constant, we update the type\n-     of the constant to be the type of the other operand.  We check that the\n-     constant fits the type in the pattern recognition pass.  */\n-  if (code == DOT_PROD_EXPR\n-      && !types_compatible_p (TREE_TYPE (ops[0]), TREE_TYPE (ops[1])))\n-    /* No testcase for this.  PR49478.  */\n-    gcc_unreachable ();\n-\n   if (reduction_type == COND_REDUCTION)\n     {\n       widest_int ni;\n@@ -6761,9 +6690,9 @@ vect_transform_cycle_phi (stmt_vec_info stmt_info, stmt_vec_info *vec_stmt,\n \t  tree induc_val = STMT_VINFO_VEC_INDUC_COND_INITIAL_VAL (reduc_info);\n \t  if (TREE_CODE (initial_def) == INTEGER_CST\n \t      && !integer_zerop (induc_val)\n-\t      && (((STMT_VINFO_VEC_COND_REDUC_CODE (reduc_info) == MAX_EXPR)\n+\t      && ((STMT_VINFO_REDUC_CODE (reduc_info) == MAX_EXPR\n \t\t   && tree_int_cst_lt (initial_def, induc_val))\n-\t\t  || ((STMT_VINFO_VEC_COND_REDUC_CODE (reduc_info) == MIN_EXPR)\n+\t\t  || (STMT_VINFO_REDUC_CODE (reduc_info) == MIN_EXPR\n \t\t      && tree_int_cst_lt (induc_val, initial_def))))\n \t    {\n \t      induc_val = initial_def;"}, {"sha": "512e2e001da748bf36a8a8e211f52d06862f107a", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11cccc0285f02f117a1e80924fb7673b6486ce9/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11cccc0285f02f117a1e80924fb7673b6486ce9/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=c11cccc0285f02f117a1e80924fb7673b6486ce9", "patch": "@@ -638,7 +638,6 @@ vec_info::new_stmt_vec_info (gimple *stmt)\n   STMT_VINFO_RELEVANT (res) = vect_unused_in_scope;\n   STMT_VINFO_VECTORIZABLE (res) = true;\n   STMT_VINFO_REDUC_TYPE (res) = TREE_CODE_REDUCTION;\n-  STMT_VINFO_VEC_COND_REDUC_CODE (res) = ERROR_MARK;\n   STMT_VINFO_REDUC_CODE (res) = ERROR_MARK;\n   STMT_VINFO_REDUC_FN (res) = IFN_LAST;\n   STMT_VINFO_REDUC_IDX (res) = -1;"}, {"sha": "d59ba13bc4ec85e204c2c785267ad0ad659d18b8", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11cccc0285f02f117a1e80924fb7673b6486ce9/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11cccc0285f02f117a1e80924fb7673b6486ce9/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=c11cccc0285f02f117a1e80924fb7673b6486ce9", "patch": "@@ -933,10 +933,6 @@ class _stmt_vec_info {\n      for loop vectorization.  */\n   vect_memory_access_type memory_access_type;\n \n-  /* For CONST_COND_REDUCTION and INTEGER_INDUC_COND_REDUCTION, the\n-     reduction code.  */\n-  enum tree_code cond_reduc_code;\n-\n   /* For INTEGER_INDUC_COND_REDUCTION, the initial value to be used.  */\n   tree induc_cond_initial_val;\n \n@@ -1052,7 +1048,6 @@ STMT_VINFO_BB_VINFO (stmt_vec_info stmt_vinfo)\n #define STMT_VINFO_STRIDED_P(S)\t   \t   (S)->strided_p\n #define STMT_VINFO_MEMORY_ACCESS_TYPE(S)   (S)->memory_access_type\n #define STMT_VINFO_SIMD_LANE_ACCESS_P(S)   (S)->simd_lane_access_p\n-#define STMT_VINFO_VEC_COND_REDUC_CODE(S)  (S)->cond_reduc_code\n #define STMT_VINFO_VEC_INDUC_COND_INITIAL_VAL(S) (S)->induc_cond_initial_val\n #define STMT_VINFO_REDUC_EPILOGUE_ADJUSTMENT(S) (S)->reduc_epilogue_adjustment\n #define STMT_VINFO_REDUC_IDX(S)\t\t   (S)->reduc_idx"}]}