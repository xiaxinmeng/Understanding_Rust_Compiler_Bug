{"sha": "6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njk0NmIzZjdmNWE5ZjZjMzNiMzU2M2E1OTIzYjc4ZDljOTFhOTNlMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2006-12-13T13:02:06Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2006-12-13T13:02:06Z"}, "message": "Makefile.in: Add dependencies.\n\n\t\n\t* Makefile.in: Add dependencies.\n\t* tree-pretty-print.c: Include value-prof.h\n\t(dump_generic_bb_buff): Dump histograms\n\t* value-prof.c: Include pointer-set.h\n\t(gimple_alloc_histogram_value, histogram_hash, histogram_eq,\n\tset_histogram_value, gimple_histogram_value,\n\tgimple_add_histogram_value, gimple_remove_histogram_value,\n\tgimple_histogram_value_of_type, dump_histogram_value,\n\tdump_histograms_for_stmt, gimple_remove_stmt_histograms,\n\tgimple_duplicate_stmt_histograms, visit_hist,\n\tverify_histograms): New functions.\n\t(tree_value_profile_transformations): Update for new histogram API.\n\t(tree_divmod_fixed_value): Update for new histogram API.\n\t(tree_divmod_fixed_value_transform): Update for new histogram API.\n\t(tree_mod_pow2): Update for new histogram API.\n\t(tree_mod_pow2_value_transform): Update for new histogram API.\n\t(tree_mod_subtract): Update for new histogram API.\n\t(tree_mod_subtract_transform): Update for new histogram API.\n\t(tree_stringops_transform): Update for new histogram API.\n\t(tree_divmod_values_to_profile): Update for new histogram API.\n\t(tree_stringops_values_to_profile): Update for new histogram API.\n\t(tree_find_values_to_profile): Update for new histogram API.\n\t* value-prof.h (gimple_histogram_value): Declare.\n\t(gimple_histogram_value_of_type): Declare.\n\t(gimple_add_histogram_value): Declare.\n\t(gimple_remove_histogram_value): Declare.\n\t(dump_histograms_for_stmt): Declare.\n\t(gimple_remove_histogram_value): Declare.\n\t(gimple_remove_stmt_histograms): Declare.\n\t(gimple_duplicate_stmt_histograms): Declare.\n\t(verify_histograms): Declare.\n\t* function.h\n\t(struct funrction): Add value_histograms hash.\n\t(VALUE_HISTOGRAMS): New macro.\n\t* profile.c (compute_value_histograms): update for new API.\n\t* tree-inline.c: Include value-prof.h\n\t(copy_bb): Update histograms.\n\t* tree-flow.h (struct stmt_ann_d): Do not contain pointer to histograms;\n\treorder to get smaller memory layout.\n\t* tree-cfg.c: Include value-prof.h\n\t(bsi_remove): Update histograms.\n\t(bsi_replace): Update histograms.\n\t(verify_stmts): Call histogram verifier.\n\t(tree_duplicate_bb): Update histograms.\n\t(move_block_to_fn): Update histograms.\n\nFrom-SVN: r119829", "tree": {"sha": "00bc2fa411be3a6cb147ee807dd73158ea8f60d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00bc2fa411be3a6cb147ee807dd73158ea8f60d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1/comments", "author": null, "committer": null, "parents": [{"sha": "a22831b13c3aa9d3cecad957175b1d3b9491d161", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a22831b13c3aa9d3cecad957175b1d3b9491d161", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a22831b13c3aa9d3cecad957175b1d3b9491d161"}], "stats": {"total": 587, "additions": 449, "deletions": 138}, "files": [{"sha": "c49997d3dde6b4435841b7ec071617e52c5484dc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1", "patch": "@@ -1,3 +1,51 @@\n+2006-12-13  Jan Hubicka  <jh@suse.cz>\n+\n+\t* Makefile.in: Add dependencies.\n+\t* tree-pretty-print.c: Include value-prof.h\n+\t(dump_generic_bb_buff): Dump histograms\n+\t* value-prof.c: Include pointer-set.h\n+\t(gimple_alloc_histogram_value, histogram_hash, histogram_eq,\n+\tset_histogram_value, gimple_histogram_value,\n+\tgimple_add_histogram_value, gimple_remove_histogram_value,\n+\tgimple_histogram_value_of_type, dump_histogram_value,\n+\tdump_histograms_for_stmt, gimple_remove_stmt_histograms,\n+\tgimple_duplicate_stmt_histograms, visit_hist,\n+\tverify_histograms): New functions.\n+\t(tree_value_profile_transformations): Update for new histogram API.\n+\t(tree_divmod_fixed_value): Update for new histogram API.\n+\t(tree_divmod_fixed_value_transform): Update for new histogram API.\n+\t(tree_mod_pow2): Update for new histogram API.\n+\t(tree_mod_pow2_value_transform): Update for new histogram API.\n+\t(tree_mod_subtract): Update for new histogram API.\n+\t(tree_mod_subtract_transform): Update for new histogram API.\n+\t(tree_stringops_transform): Update for new histogram API.\n+\t(tree_divmod_values_to_profile): Update for new histogram API.\n+\t(tree_stringops_values_to_profile): Update for new histogram API.\n+\t(tree_find_values_to_profile): Update for new histogram API.\n+\t* value-prof.h (gimple_histogram_value): Declare.\n+\t(gimple_histogram_value_of_type): Declare.\n+\t(gimple_add_histogram_value): Declare.\n+\t(gimple_remove_histogram_value): Declare.\n+\t(dump_histograms_for_stmt): Declare.\n+\t(gimple_remove_histogram_value): Declare.\n+\t(gimple_remove_stmt_histograms): Declare.\n+\t(gimple_duplicate_stmt_histograms): Declare.\n+\t(verify_histograms): Declare.\n+\t* function.h\n+\t(struct funrction): Add value_histograms hash.\n+\t(VALUE_HISTOGRAMS): New macro.\n+\t* profile.c (compute_value_histograms): update for new API.\n+\t* tree-inline.c: Include value-prof.h\n+\t(copy_bb): Update histograms.\n+\t* tree-flow.h (struct stmt_ann_d): Do not contain pointer to histograms;\n+\treorder to get smaller memory layout.\n+\t* tree-cfg.c: Include value-prof.h\n+\t(bsi_remove): Update histograms.\n+\t(bsi_replace): Update histograms.\n+\t(verify_stmts): Call histogram verifier.\n+\t(tree_duplicate_bb): Update histograms.\n+\t(move_block_to_fn): Update histograms.\n+\n 2006-12-13  Richard Guenther  <rguenther@suse.de>\n \n \t* ipa-inline.c (cgraph_flatten_node): Replace leafify with"}, {"sha": "b2916097214268108e2065256d1c28baeadfcd0f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1", "patch": "@@ -1828,7 +1828,7 @@ tree-inline.o : tree-inline.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(VARRAY_H) $(HASHTAB_H) $(SPLAY_TREE_H) toplev.h \\\n    langhooks.h $(TREE_INLINE_H) $(CGRAPH_H) intl.h $(FUNCTION_H) $(TREE_GIMPLE_H) \\\n    debug.h $(DIAGNOSTIC_H) $(TREE_FLOW_H) tree-iterator.h tree-mudflap.h \\\n-   ipa-prop.h\n+   ipa-prop.h value-prof.h\n print-tree.o : print-tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(GGC_H) langhooks.h $(REAL_H) tree-iterator.h\n stor-layout.o : stor-layout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n@@ -2127,7 +2127,8 @@ tree-nomudflap.o : $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TREE_INLINE_H) \\\n    $(GGC_H) gt-tree-mudflap.h tree-pass.h toplev.h\n tree-pretty-print.o : tree-pretty-print.c $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_H) $(DIAGNOSTIC_H) $(REAL_H) $(HASHTAB_H) $(TREE_FLOW_H) \\\n-   $(TM_H) coretypes.h tree-iterator.h tree-chrec.h langhooks.h tree-pass.h\n+   $(TM_H) coretypes.h tree-iterator.h tree-chrec.h langhooks.h tree-pass.h \\\n+   value-prof.h\n fold-const.o : fold-const.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(FLAGS_H) $(REAL_H) toplev.h $(HASHTAB_H) $(EXPR_H) $(RTL_H) \\\n    $(GGC_H) $(TM_P_H) langhooks.h $(MD5_H)\n@@ -2438,7 +2439,8 @@ cfghooks.o: cfghooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n cfgexpand.o : cfgexpand.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) \\\n    coretypes.h $(TREE_DUMP_H) except.h langhooks.h tree-pass.h $(RTL_H) \\\n-   $(DIAGNOSTIC_H) toplev.h $(BASIC_BLOCK_H) $(FLAGS_H) debug.h $(PARAMS_H)\n+   $(DIAGNOSTIC_H) toplev.h $(BASIC_BLOCK_H) $(FLAGS_H) debug.h $(PARAMS_H) \\\n+   value-prof.h\n cfgrtl.o : cfgrtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h \\\n    output.h toplev.h $(FUNCTION_H) except.h $(TM_P_H) insn-config.h $(EXPR_H) \\"}, {"sha": "b8d44a65e0cf92f0da62d5c55eea0a03f0264d03", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1", "patch": "@@ -40,6 +40,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"debug.h\"\n #include \"params.h\"\n #include \"tree-inline.h\"\n+#include \"value-prof.h\"\n \n /* Verify that there is exactly single jump instruction since last and attach\n    REG_BR_PROB note specifying probability.\n@@ -1860,6 +1861,7 @@ tree_expand_cfg (void)\n   /* After expanding, the return labels are no longer needed. */\n   return_label = NULL;\n   naked_return_label = NULL;\n+  free_histograms ();\n   return 0;\n }\n "}, {"sha": "27e5c02cbba8d51fb9a61456d3c58c21514a98cf", "filename": "gcc/function.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1", "patch": "@@ -195,6 +195,9 @@ struct function GTY(())\n   /* The loops in this function.  */\n   struct loops * GTY((skip)) x_current_loops;\n \n+  /* Value histograms attached to particular statements.  */\n+  htab_t GTY((skip)) value_histograms;\n+\n   /* For function.c.  */\n \n   /* Points to the FUNCTION_DECL of this function.  */\n@@ -532,6 +535,7 @@ extern int trampolines_created;\n #define temp_slot_level (cfun->x_temp_slot_level)\n #define nonlocal_goto_handler_labels (cfun->x_nonlocal_goto_handler_labels)\n #define current_loops (cfun->x_current_loops)\n+#define VALUE_HISTOGRAMS(fun) (fun)->value_histograms\n \n /* Given a function decl for a containing function,\n    return the `struct function' for it.  */"}, {"sha": "7c38b7fe149fcfb60b476792e76ca275f0accad9", "filename": "gcc/profile.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1", "patch": "@@ -648,15 +648,13 @@ compute_value_histograms (histogram_values values)\n     {\n       histogram_value hist = VEC_index (histogram_value, values, i);\n       tree stmt = hist->hvalue.stmt;\n-      stmt_ann_t ann = get_stmt_ann (stmt);\n \n       t = (int) hist->type;\n \n       aact_count = act_count[t];\n       act_count[t] += hist->n_counters;\n \n-      hist->hvalue.next = ann->histograms;\n-      ann->histograms = hist;\n+      gimple_add_histogram_value (cfun, stmt, hist);\n       hist->hvalue.counters =  XNEWVEC (gcov_type, hist->n_counters);\n       for (j = 0; j < hist->n_counters; j++)\n \thist->hvalue.counters[j] = aact_count[j];"}, {"sha": "b85e38e8dce8007b71c3699539891a1201fccd09", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1", "patch": "@@ -46,6 +46,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"cfglayout.h\"\n #include \"hashtab.h\"\n #include \"tree-ssa-propagate.h\"\n+#include \"value-prof.h\"\n \n /* This file contains functions for building the Control Flow Graph (CFG)\n    for a function tree.  */\n@@ -2871,7 +2872,10 @@ bsi_remove (block_stmt_iterator *i, bool remove_eh_info)\n   tsi_delink (&i->tsi);\n   mark_stmt_modified (t);\n   if (remove_eh_info)\n-    remove_stmt_from_eh_region (t);\n+    {\n+      remove_stmt_from_eh_region (t);\n+      gimple_remove_stmt_histograms (cfun, t);\n+    }\n }\n \n \n@@ -2934,6 +2938,8 @@ bsi_replace (const block_stmt_iterator *bsi, tree stmt, bool update_eh_info)\n \t{\n \t  remove_stmt_from_eh_region (orig_stmt);\n \t  add_stmt_to_eh_region (stmt, eh_region);\n+\t  gimple_duplicate_stmt_histograms (cfun, stmt, cfun, orig_stmt);\n+          gimple_remove_stmt_histograms (cfun, orig_stmt);\n \t}\n     }\n \n@@ -3671,6 +3677,7 @@ verify_stmts (void)\n     internal_error (\"verify_stmts failed\");\n \n   htab_delete (htab);\n+  verify_histograms ();\n   timevar_pop (TV_TREE_STMT_VERIFY);\n }\n \n@@ -4342,6 +4349,7 @@ tree_duplicate_bb (basic_block bb)\n       region = lookup_stmt_eh_region (stmt);\n       if (region >= 0)\n \tadd_stmt_to_eh_region (copy, region);\n+      gimple_duplicate_stmt_histograms (cfun, copy, cfun, stmt);\n \n       /* Create new names for all the definitions created by COPY and\n \t add replacement mappings for each new name.  */\n@@ -4785,6 +4793,8 @@ move_block_to_fn (struct function *dest_cfun, basic_block bb,\n \t{\n \t  add_stmt_to_eh_region_fn (dest_cfun, stmt, region + eh_offset);\n \t  remove_stmt_from_eh_region (stmt);\n+\t  gimple_duplicate_stmt_histograms (dest_cfun, stmt, cfun, stmt);\n+          gimple_remove_stmt_histograms (cfun, stmt);\n \t}\n     }\n }"}, {"sha": "e0ef809bd0824ce0892117a27d831fba73df9c14", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1", "patch": "@@ -356,17 +356,6 @@ struct stmt_ann_d GTY(())\n {\n   struct tree_ann_common_d common;\n \n-  /* Nonzero if the statement has been modified (meaning that the operands\n-     need to be scanned again).  */\n-  unsigned modified : 1;\n-\n-  /* Nonzero if the statement makes references to volatile storage.  */\n-  unsigned has_volatile_ops : 1;\n-\n-  /* Nonzero if the statement makes a function call that may clobber global\n-     and local addressable variables.  */\n-  unsigned makes_clobbering_call : 1;\n-\n   /* Nonzero if the statement references memory (at least one of its\n      expressions contains a non-register operand).  */\n   unsigned references_memory : 1;\n@@ -385,11 +374,16 @@ struct stmt_ann_d GTY(())\n      pass which needs statement UIDs.  */\n   unsigned int uid;\n \n-  /* Linked list of histograms for value-based profiling.  This is really a\n-     struct histogram_value*.  We use void* to avoid having to export that\n-     everywhere, and to avoid having to put it in GC memory.  */\n-  \n-  void * GTY ((skip (\"\"))) histograms;\n+  /* Nonzero if the statement has been modified (meaning that the operands\n+     need to be scanned again).  */\n+  unsigned modified : 1;\n+\n+  /* Nonzero if the statement makes references to volatile storage.  */\n+  unsigned has_volatile_ops : 1;\n+\n+  /* Nonzero if the statement makes a function call that may clobber global\n+     and local addressable variables.  */\n+  unsigned makes_clobbering_call : 1;\n };\n \n union tree_ann_d GTY((desc (\"ann_type ((tree_ann_t)&%h)\")))"}, {"sha": "4e0913e4efc12e231a904c82a17d2cd33bcfff4f", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1", "patch": "@@ -49,6 +49,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"debug.h\"\n #include \"pointer-set.h\"\n #include \"ipa-prop.h\"\n+#include \"value-prof.h\"\n \n /* I'm not real happy about this, but we need to handle gimple and\n    non-gimple trees.  */\n@@ -707,6 +708,8 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale, int count_scal\n \t{\n \t  tree call, decl;\n \n+\t  gimple_duplicate_stmt_histograms (cfun, stmt, id->src_cfun, orig_stmt);\n+\n \t  /* With return slot optimization we can end up with\n \t     non-gimple (foo *)&this->m, fix that here.  */\n \t  if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT"}, {"sha": "e78b95c4f3b6c36b11a47dc6e3e0ef9c7bc7b77e", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1", "patch": "@@ -33,6 +33,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"tree-iterator.h\"\n #include \"tree-chrec.h\"\n #include \"tree-pass.h\"\n+#include \"value-prof.h\"\n \n /* Local functions, macros and variables.  */\n static int op_prio (tree);\n@@ -3000,6 +3001,7 @@ dump_generic_bb_buff (pretty_printer *buffer, basic_block bb,\n       INDENT (curr_indent);\n       dump_generic_node (buffer, stmt, curr_indent, flags, true);\n       pp_newline (buffer);\n+      dump_histograms_for_stmt (cfun, buffer->buffer->stream, stmt);\n     }\n \n   dump_implicit_edges (buffer, bb, indent, flags);"}, {"sha": "2b2bb1b6c1e3bcc5390e9b1866b0907a952da754", "filename": "gcc/value-prof.c", "status": "modified", "additions": 352, "deletions": 115, "changes": 467, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1", "patch": "@@ -43,6 +43,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"timevar.h\"\n #include \"tree-pass.h\"\n #include \"toplev.h\"\n+#include \"pointer-set.h\"\n \n static struct value_prof_hooks *value_prof_hooks;\n \n@@ -81,6 +82,302 @@ static bool tree_mod_pow2_value_transform (tree);\n static bool tree_mod_subtract_transform (tree);\n static bool tree_stringops_transform (block_stmt_iterator *);\n \n+/* Allocate histogram value.  */\n+\n+static histogram_value\n+gimple_alloc_histogram_value (struct function *fun ATTRIBUTE_UNUSED,\n+\t\t\t      enum hist_type type, tree stmt, tree value)\n+{\n+   histogram_value hist = (histogram_value) xcalloc (1, sizeof (*hist));\n+   hist->hvalue.value = value;\n+   hist->hvalue.stmt = stmt;\n+   hist->type = type;\n+   return hist;\n+}\n+\n+/* Hash value for histogram.  */\n+\n+static hashval_t\n+histogram_hash (const void *x)\n+{\n+  return htab_hash_pointer (((histogram_value)x)->hvalue.stmt);\n+}\n+\n+/* Return nonzero if decl_id of die_struct X is the same as UID of decl *Y.  */\n+\n+static int\n+histogram_eq (const void *x, const void *y)\n+{\n+  return ((histogram_value) x)->hvalue.stmt == (tree)y;\n+}\n+\n+/* Set histogram for STMT.  */\n+\n+static void\n+set_histogram_value (struct function *fun, tree stmt, histogram_value hist)\n+{\n+  void **loc;\n+  if (!hist && !VALUE_HISTOGRAMS (fun))\n+    return;\n+  if (!VALUE_HISTOGRAMS (fun))\n+    VALUE_HISTOGRAMS (fun) = htab_create (1, histogram_hash,\n+\t\t\t\t           histogram_eq, NULL);\n+  loc = htab_find_slot_with_hash (VALUE_HISTOGRAMS (fun), stmt,\n+                                  htab_hash_pointer (stmt),\n+\t\t\t\t  hist ? INSERT : NO_INSERT);\n+  if (!hist)\n+    {\n+      if (loc)\n+\thtab_clear_slot (VALUE_HISTOGRAMS (fun), loc);\n+      return;\n+    }\n+  *loc = hist;\n+}\n+\n+/* Get histogram list for STMT.  */\n+\n+histogram_value\n+gimple_histogram_value (struct function *fun, tree stmt)\n+{\n+  if (!VALUE_HISTOGRAMS (fun))\n+    return NULL;\n+  return htab_find_with_hash (VALUE_HISTOGRAMS (fun), stmt,\n+                              htab_hash_pointer (stmt));\n+}\n+\n+/* Add histogram for STMT.  */\n+\n+void\n+gimple_add_histogram_value (struct function *fun, tree stmt, histogram_value hist)\n+{\n+  hist->hvalue.next = gimple_histogram_value (fun, stmt);\n+  set_histogram_value (fun, stmt, hist);\n+}\n+\n+/* Remove histogram HIST from STMT's histogram list.  */\n+\n+void\n+gimple_remove_histogram_value (struct function *fun, tree stmt, histogram_value hist)\n+{\n+  histogram_value hist2 = gimple_histogram_value (fun, stmt);\n+  if (hist == hist2)\n+    {\n+      set_histogram_value (fun, stmt, hist->hvalue.next);\n+    }\n+  else\n+    {\n+      while (hist2->hvalue.next != hist)\n+\thist2 = hist2->hvalue.next;\n+      hist2->hvalue.next = hist->hvalue.next;\n+    }\n+  free (hist->hvalue.counters);\n+#ifdef ENABLE_CHECKING\n+  memset (hist, 0xab, sizeof (*hist));\n+#endif\n+  free (hist);\n+}\n+\n+/* Lookup histogram of type TYPE in the STMT.  */\n+\n+histogram_value\n+gimple_histogram_value_of_type (struct function *fun, tree stmt, enum hist_type type)\n+{\n+  histogram_value hist;\n+  for (hist = gimple_histogram_value (fun, stmt); hist; hist = hist->hvalue.next)\n+    if (hist->type == type)\n+      return hist;\n+  return NULL;\n+}\n+\n+/* Dump information about HIST to DUMP_FILE.  */\n+\n+static void\n+dump_histogram_value (FILE *dump_file, histogram_value hist)\n+{\n+  switch (hist->type)\n+    {\n+    case HIST_TYPE_INTERVAL:\n+      fprintf (dump_file, \"Interval counter range %d -- %d\",\n+\t       hist->hdata.intvl.int_start,\n+\t       (hist->hdata.intvl.int_start\n+\t        + hist->hdata.intvl.steps - 1));\n+      if (hist->hvalue.counters)\n+\t{\n+\t   unsigned int i;\n+\t   fprintf(dump_file, \" [\");\n+           for (i = 0; i < hist->hdata.intvl.steps; i++)\n+\t     fprintf (dump_file, \" %d:\"HOST_WIDEST_INT_PRINT_DEC,\n+\t\t      hist->hdata.intvl.int_start + i,\n+\t\t      (HOST_WIDEST_INT) hist->hvalue.counters[i]);\n+\t   fprintf (dump_file, \" ] outside range:\"HOST_WIDEST_INT_PRINT_DEC,\n+\t\t    (HOST_WIDEST_INT) hist->hvalue.counters[i]);\n+\t}\n+      fprintf (dump_file, \".\\n\");\n+      break;\n+\n+    case HIST_TYPE_POW2:\n+      fprintf (dump_file, \"Pow2 counter \");\n+      if (hist->hvalue.counters)\n+\t{\n+\t   fprintf (dump_file, \"pow2:\"HOST_WIDEST_INT_PRINT_DEC\n+\t\t    \" nonpow2:\"HOST_WIDEST_INT_PRINT_DEC,\n+\t\t    (HOST_WIDEST_INT) hist->hvalue.counters[0],\n+\t\t    (HOST_WIDEST_INT) hist->hvalue.counters[1]);\n+\t}\n+      fprintf (dump_file, \".\\n\");\n+      break;\n+\n+    case HIST_TYPE_SINGLE_VALUE:\n+      fprintf (dump_file, \"Single value \");\n+      if (hist->hvalue.counters)\n+\t{\n+\t   fprintf (dump_file, \"value:\"HOST_WIDEST_INT_PRINT_DEC\n+\t\t    \" match:\"HOST_WIDEST_INT_PRINT_DEC\n+\t\t    \" wrong:\"HOST_WIDEST_INT_PRINT_DEC,\n+\t\t    (HOST_WIDEST_INT) hist->hvalue.counters[0],\n+\t\t    (HOST_WIDEST_INT) hist->hvalue.counters[1],\n+\t\t    (HOST_WIDEST_INT) hist->hvalue.counters[2]);\n+\t}\n+      fprintf (dump_file, \".\\n\");\n+      break;\n+\n+    case HIST_TYPE_CONST_DELTA:\n+      fprintf (dump_file, \"Constant delta \");\n+      if (hist->hvalue.counters)\n+\t{\n+\t   fprintf (dump_file, \"value:\"HOST_WIDEST_INT_PRINT_DEC\n+\t\t    \" match:\"HOST_WIDEST_INT_PRINT_DEC\n+\t\t    \" wrong:\"HOST_WIDEST_INT_PRINT_DEC,\n+\t\t    (HOST_WIDEST_INT) hist->hvalue.counters[0],\n+\t\t    (HOST_WIDEST_INT) hist->hvalue.counters[1],\n+\t\t    (HOST_WIDEST_INT) hist->hvalue.counters[2]);\n+\t}\n+      fprintf (dump_file, \".\\n\");\n+      break;\n+   }\n+}\n+\n+/* Dump all histograms attached to STMT to DUMP_FILE.  */\n+\n+void\n+dump_histograms_for_stmt (struct function *fun, FILE *dump_file, tree stmt)\n+{\n+  histogram_value hist;\n+  for (hist = gimple_histogram_value (fun, stmt); hist; hist = hist->hvalue.next)\n+   dump_histogram_value (dump_file, hist);\n+}\n+\n+/* Remove all histograms associated with STMT.  */\n+\n+void\n+gimple_remove_stmt_histograms (struct function *fun, tree stmt)\n+{\n+  histogram_value val;\n+  while ((val = gimple_histogram_value (fun, stmt)) != NULL)\n+    gimple_remove_histogram_value (fun, stmt, val);\n+}\n+\n+/* Duplicate all histograms associates with OSTMT to STMT.  */\n+\n+void\n+gimple_duplicate_stmt_histograms (struct function *fun, tree stmt,\n+\t\t\t\t  struct function *ofun, tree ostmt)\n+{\n+  histogram_value val;\n+  for (val = gimple_histogram_value (ofun, ostmt); val != NULL; val = val->hvalue.next)\n+    {\n+      histogram_value new = gimple_alloc_histogram_value (fun, val->type, NULL, NULL);\n+      memcpy (new, val, sizeof (*val));\n+      new->hvalue.stmt = stmt;\n+      new->hvalue.counters = xmalloc (sizeof (*new->hvalue.counters) * new->n_counters);\n+      memcpy (new->hvalue.counters, val->hvalue.counters, sizeof (*new->hvalue.counters) * new->n_counters);\n+      gimple_add_histogram_value (fun, stmt, new);\n+    }\n+}\n+\n+static bool error_found = false;\n+\n+/* Helper function for verify_histograms.  For each histogram reachable via htab\n+   walk verify that it was reached via statement walk.  */\n+\n+static int\n+visit_hist (void **slot, void *data)\n+{\n+  struct pointer_set_t *visited = (struct pointer_set_t *) data;\n+  histogram_value hist = *(histogram_value *) slot;\n+  if (!pointer_set_contains (visited, hist))\n+    {\n+      error (\"Dead histogram\");\n+      dump_histogram_value (stderr, hist);\n+      debug_generic_stmt (hist->hvalue.stmt);\n+      error_found = true;\n+    }\n+  return 0;\n+}\n+\n+/* Verify sanity of the histograms.  */\n+\n+void\n+verify_histograms (void)\n+{\n+  basic_block bb;\n+  block_stmt_iterator bsi;\n+  histogram_value hist;\n+  struct pointer_set_t *visited_hists;\n+\n+  error_found = false;\n+  visited_hists = pointer_set_create ();\n+  FOR_EACH_BB (bb)\n+    for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+      {\n+\ttree stmt = bsi_stmt (bsi);\n+\n+\tfor (hist = gimple_histogram_value (cfun, stmt); hist; hist = hist->hvalue.next)\n+\t  {\n+\t    if (hist->hvalue.stmt != stmt)\n+\t      {\n+\t\terror (\"Histogram value statement does not correspond to statement\"\n+\t\t       \" it is associated with\");\n+\t\tdebug_generic_stmt (stmt);\n+\t\tdump_histogram_value (stderr, hist);\n+\t\terror_found = true;\n+\t      }\n+            pointer_set_insert (visited_hists, hist);\n+\t  }\n+      }\n+  if (VALUE_HISTOGRAMS (cfun))\n+    htab_traverse (VALUE_HISTOGRAMS (cfun), visit_hist, visited_hists);\n+  pointer_set_destroy (visited_hists);\n+  if (error_found)\n+    internal_error (\"verify_histograms failed\");\n+}\n+\n+/* Helper function for verify_histograms.  For each histogram reachable via htab\n+   walk verify that it was reached via statement walk.  */\n+\n+static int\n+free_hist (void **slot, void *data ATTRIBUTE_UNUSED)\n+{\n+  histogram_value hist = *(histogram_value *) slot;\n+  free (hist->hvalue.counters);\n+#ifdef ENABLE_CHECKING\n+  memset (hist, 0xab, sizeof (*hist));\n+#endif\n+  free (hist);\n+  return 0;\n+}\n+\n+void\n+free_histograms (void)\n+{\n+  if (VALUE_HISTOGRAMS (cfun))\n+    {\n+      htab_traverse (VALUE_HISTOGRAMS (cfun), free_hist, NULL);\n+      htab_delete (VALUE_HISTOGRAMS (cfun));\n+      VALUE_HISTOGRAMS (cfun) = NULL;\n+    }\n+}\n+\n /* The overall number of invocations of the counter should match execution count\n    of basic block.  Report it as error rather than internal error as it might\n    mean that user has misused the profile somehow.  */\n@@ -110,22 +407,18 @@ tree_value_profile_transformations (void)\n \n   FOR_EACH_BB (bb)\n     {\n-      /* Ignore cold areas -- we are enlarging the code.  */\n-      if (!bb->count || !maybe_hot_bb_p (bb))\n-\tcontinue;\n-\n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n \t{\n \t  tree stmt = bsi_stmt (bsi);\n-\t  stmt_ann_t ann = get_stmt_ann (stmt);\n-\t  histogram_value th = ann->histograms;\n+\t  histogram_value th = gimple_histogram_value (cfun, stmt);\n \t  if (!th)\n \t    continue;\n \n \t  if (dump_file)\n \t    {\n-\t      fprintf (dump_file, \"Trying transformations on insn \");\n+\t      fprintf (dump_file, \"Trying transformations on stmt \");\n \t      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n+\t      dump_histograms_for_stmt (cfun, dump_file, stmt);\n \t    }\n \n \t  /* Transformations:  */\n@@ -150,14 +443,6 @@ tree_value_profile_transformations (void)\n \t\t  bsi = bsi_for_stmt (stmt);\n \t\t}\n \t    }\n-\n-\t  /* Free extra storage from compute_value_histograms.  */\n-\t  while (th)\n-\t    {\n-\t      free (th->hvalue.counters);\n-\t      th = th->hvalue.next;\n-\t    }\n-\t  ann->histograms = 0;\n         }\n     }\n \n@@ -259,7 +544,6 @@ tree_divmod_fixed_value (tree stmt, tree operation,\n static bool\n tree_divmod_fixed_value_transform (tree stmt)\n {\n-  stmt_ann_t ann = get_stmt_ann (stmt);\n   histogram_value histogram;\n   enum tree_code code;\n   gcov_type val, count, all;\n@@ -283,25 +567,22 @@ tree_divmod_fixed_value_transform (tree stmt)\n \n   op1 = TREE_OPERAND (op, 0);\n   op2 = TREE_OPERAND (op, 1);\n-  if (!ann->histograms)\n-    return false;\n-\n-  for (histogram = ann->histograms; histogram; histogram = histogram->hvalue.next)\n-    if (histogram->type == HIST_TYPE_SINGLE_VALUE)\n-      break;\n \n+  histogram = gimple_histogram_value_of_type (cfun, stmt, HIST_TYPE_SINGLE_VALUE);\n   if (!histogram)\n     return false;\n \n   value = histogram->hvalue.value;\n   val = histogram->hvalue.counters[0];\n   count = histogram->hvalue.counters[1];\n   all = histogram->hvalue.counters[2];\n+  gimple_remove_histogram_value (cfun, stmt, histogram);\n \n   /* We require that count is at least half of all; this means\n      that for the transformation to fire the value must be constant\n      at least 50% of time (and 75% gives the guarantee of usage).  */\n-  if (simple_cst_equal (op2, value) != 1 || 2 * count < all)\n+  if (simple_cst_equal (op2, value) != 1 || 2 * count < all\n+      || !maybe_hot_bb_p (bb_for_stmt (stmt)))\n     return false;\n \n   if (check_counter (stmt, \"value\", all, bb_for_stmt (stmt)->count))\n@@ -422,7 +703,6 @@ tree_mod_pow2 (tree stmt, tree operation, tree op1, tree op2, int prob,\n static bool\n tree_mod_pow2_value_transform (tree stmt)\n {\n-  stmt_ann_t ann = get_stmt_ann (stmt);\n   histogram_value histogram;\n   enum tree_code code;\n   gcov_type count, wrong_values, all;\n@@ -446,22 +726,20 @@ tree_mod_pow2_value_transform (tree stmt)\n \n   op1 = TREE_OPERAND (op, 0);\n   op2 = TREE_OPERAND (op, 1);\n-  if (!ann->histograms)\n-    return false;\n-\n-  for (histogram = ann->histograms; histogram; histogram = histogram->hvalue.next)\n-    if (histogram->type == HIST_TYPE_POW2)\n-      break;\n \n+  histogram = gimple_histogram_value_of_type (cfun, stmt, HIST_TYPE_POW2);\n   if (!histogram)\n     return false;\n \n   value = histogram->hvalue.value;\n   wrong_values = histogram->hvalue.counters[0];\n   count = histogram->hvalue.counters[1];\n \n+  gimple_remove_histogram_value (cfun, stmt, histogram);\n+\n   /* We require that we hit a power of 2 at least half of all evaluations.  */\n-  if (simple_cst_equal (op2, value) != 1 || count < wrong_values)\n+  if (simple_cst_equal (op2, value) != 1 || count < wrong_values\n+      || !maybe_hot_bb_p (bb_for_stmt (stmt)))\n     return false;\n \n   if (dump_file)\n@@ -472,6 +750,7 @@ tree_mod_pow2_value_transform (tree stmt)\n \n   /* Compute probability of taking the optimal path.  */\n   all = count + wrong_values;\n+\n   if (check_counter (stmt, \"pow2\", all, bb_for_stmt (stmt)->count))\n     return false;\n \n@@ -604,13 +883,13 @@ tree_mod_subtract (tree stmt, tree operation, tree op1, tree op2,\n static bool\n tree_mod_subtract_transform (tree stmt)\n {\n-  stmt_ann_t ann = get_stmt_ann (stmt);\n   histogram_value histogram;\n   enum tree_code code;\n   gcov_type count, wrong_values, all;\n   tree modify, op, op1, op2, result, value;\n   int prob1, prob2;\n-  unsigned int i;\n+  unsigned int i, steps;\n+  gcov_type count1, count2;\n \n   modify = stmt;\n   if (TREE_CODE (stmt) == RETURN_EXPR\n@@ -629,13 +908,8 @@ tree_mod_subtract_transform (tree stmt)\n \n   op1 = TREE_OPERAND (op, 0);\n   op2 = TREE_OPERAND (op, 1);\n-  if (!ann->histograms)\n-    return false;\n-\n-  for (histogram = ann->histograms; histogram; histogram = histogram->hvalue.next)\n-    if (histogram->type == HIST_TYPE_INTERVAL)\n-      break;\n \n+  histogram = gimple_histogram_value_of_type (cfun, stmt, HIST_TYPE_INTERVAL);\n   if (!histogram)\n     return false;\n \n@@ -647,11 +921,17 @@ tree_mod_subtract_transform (tree stmt)\n \n   wrong_values += histogram->hvalue.counters[i];\n   wrong_values += histogram->hvalue.counters[i+1];\n+  steps = histogram->hdata.intvl.steps;\n   all += wrong_values;\n+  count1 = histogram->hvalue.counters[0];\n+  count2 = histogram->hvalue.counters[1];\n \n   /* Compute probability of taking the optimal path.  */\n   if (check_counter (stmt, \"interval\", all, bb_for_stmt (stmt)->count))\n-    return false;\n+    {\n+      gimple_remove_histogram_value (cfun, stmt, histogram);\n+      return false;\n+    }\n \n   /* We require that we use just subtractions in at least 50% of all\n      evaluations.  */\n@@ -662,24 +942,25 @@ tree_mod_subtract_transform (tree stmt)\n       if (count * 2 >= all)\n \tbreak;\n     }\n-  if (i == histogram->hdata.intvl.steps)\n+  if (i == steps\n+      || !maybe_hot_bb_p (bb_for_stmt (stmt)))\n     return false;\n \n+  gimple_remove_histogram_value (cfun, stmt, histogram);\n   if (dump_file)\n     {\n       fprintf (dump_file, \"Mod subtract transformation on insn \");\n       print_generic_stmt (dump_file, stmt, TDF_SLIM);\n     }\n \n   /* Compute probability of taking the optimal path(s).  */\n-  prob1 = (histogram->hvalue.counters[0] * REG_BR_PROB_BASE + all / 2) / all;\n-  prob2 = (histogram->hvalue.counters[1] * REG_BR_PROB_BASE + all / 2) / all;\n+  prob1 = (count1 * REG_BR_PROB_BASE + all / 2) / all;\n+  prob2 = (count2 * REG_BR_PROB_BASE + all / 2) / all;\n \n   /* In practice, \"steps\" is always 2.  This interface reflects this,\n      and will need to be changed if \"steps\" can change.  */\n   result = tree_mod_subtract (stmt, op, op1, op2, prob1, prob2, i,\n-\t\t\t    histogram->hvalue.counters[0], \n-\t\t\t    histogram->hvalue.counters[1], all);\n+\t\t\t      count1, count2, all);\n \n   GIMPLE_STMT_OPERAND (modify, 1) = result;\n \n@@ -826,7 +1107,6 @@ tree_stringops_transform (block_stmt_iterator *bsi)\n   tree arglist;\n   tree blck_size;\n   enum built_in_function fcode;\n-  stmt_ann_t ann = get_stmt_ann (stmt);\n   histogram_value histogram;\n   gcov_type count, all, val;\n   tree value;\n@@ -852,26 +1132,18 @@ tree_stringops_transform (block_stmt_iterator *bsi)\n   if (TREE_CODE (blck_size) == INTEGER_CST)\n     return false;\n \n-  if (!ann->histograms)\n-    return false;\n-\n-  all = bb_for_stmt (stmt)->count;\n-  if (!all)\n-    return false;\n-  for (histogram = ann->histograms; histogram;\n-       histogram = histogram->hvalue.next)\n-    if (histogram->type == HIST_TYPE_SINGLE_VALUE)\n-      break;\n+  histogram = gimple_histogram_value_of_type (cfun, stmt, HIST_TYPE_SINGLE_VALUE);\n   if (!histogram)\n     return false;\n   value = histogram->hvalue.value;\n   val = histogram->hvalue.counters[0];\n   count = histogram->hvalue.counters[1];\n   all = histogram->hvalue.counters[2];\n+  gimple_remove_histogram_value (cfun, stmt, histogram);\n   /* We require that count is at least half of all; this means\n      that for the transformation to fire the value must be constant\n      at least 80% of time.  */\n-  if ((6 * count / 5) < all)\n+  if ((6 * count / 5) < all || !maybe_hot_bb_p (bb_for_stmt (stmt)))\n     return false;\n   if (check_counter (stmt, \"value\", all, bb_for_stmt (stmt)->count))\n     return false;\n@@ -957,33 +1229,26 @@ tree_divmod_values_to_profile (tree stmt, histogram_values *values)\n       VEC_reserve (histogram_value, heap, *values, 3);\n \n       if (is_gimple_reg (divisor))\n-\t{\n-\t  /* Check for the case where the divisor is the same value most\n-\t     of the time.  */\n-\t  hist = ggc_alloc (sizeof (*hist));\n-\t  hist->hvalue.value = divisor;\n-\t  hist->hvalue.stmt = stmt;\n-\t  hist->type = HIST_TYPE_SINGLE_VALUE;\n-\t  VEC_quick_push (histogram_value, *values, hist);\n-\t}\n+\t/* Check for the case where the divisor is the same value most\n+\t   of the time.  */\n+\tVEC_quick_push (histogram_value, *values,\n+\t\t\tgimple_alloc_histogram_value (cfun, HIST_TYPE_SINGLE_VALUE,\n+\t\t\t\t\t\t      stmt, divisor));\n \n       /* For mod, check whether it is not often a noop (or replaceable by\n \t a few subtractions).  */\n       if (TREE_CODE (rhs) == TRUNC_MOD_EXPR\n \t  && TYPE_UNSIGNED (type))\n \t{\n+          tree val;\n           /* Check for a special case where the divisor is power of 2.  */\n-\t  hist = ggc_alloc (sizeof (*hist));\n-\t  hist->hvalue.value = divisor;\n-\t  hist->hvalue.stmt = stmt;\n-\t  hist->type = HIST_TYPE_POW2;\n-\t  VEC_quick_push (histogram_value, *values, hist);\n+\t  VEC_quick_push (histogram_value, *values,\n+\t\t\t  gimple_alloc_histogram_value (cfun, HIST_TYPE_POW2,\n+\t\t\t\t\t\t\tstmt, divisor));\n \n-\t  hist = ggc_alloc (sizeof (*hist));\n-\t  hist->hvalue.stmt = stmt;\n-\t  hist->hvalue.value\n-\t\t  = build2 (TRUNC_DIV_EXPR, type, op0, divisor);\n-\t  hist->type = HIST_TYPE_INTERVAL;\n+\t  val = build2 (TRUNC_DIV_EXPR, type, op0, divisor);\n+\t  hist = gimple_alloc_histogram_value (cfun, HIST_TYPE_INTERVAL,\n+\t\t\t\t\t       stmt, val);\n \t  hist->hdata.intvl.int_start = 0;\n \t  hist->hdata.intvl.steps = 2;\n \t  VEC_quick_push (histogram_value, *values, hist);\n@@ -996,7 +1261,7 @@ tree_divmod_values_to_profile (tree stmt, histogram_values *values)\n }\n \n /* Find values inside STMT for that we want to measure histograms for\n-   division/modulo optimization.  */\n+   string operations.  */\n static void\n tree_stringops_values_to_profile (tree stmt, histogram_values *values)\n {\n@@ -1005,7 +1270,6 @@ tree_stringops_values_to_profile (tree stmt, histogram_values *values)\n   tree arglist;\n   tree blck_size;\n   enum built_in_function fcode;\n-  histogram_value hist;\n \n   if (!call)\n     return;\n@@ -1024,14 +1288,9 @@ tree_stringops_values_to_profile (tree stmt, histogram_values *values)\n     blck_size = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n \n   if (TREE_CODE (blck_size) != INTEGER_CST)\n-    {\n-      VEC_reserve (histogram_value, heap, *values, 3);\n-      hist = ggc_alloc (sizeof (*hist));\n-      hist->hvalue.value = blck_size;\n-      hist->hvalue.stmt = stmt;\n-      hist->type = HIST_TYPE_SINGLE_VALUE;\n-      VEC_quick_push (histogram_value, *values, hist);\n-    }\n+    VEC_safe_push (histogram_value, heap, *values,\n+\t\t   gimple_alloc_histogram_value (cfun, HIST_TYPE_SINGLE_VALUE,\n+\t\t\t\t\t\t stmt, blck_size));\n }\n \n /* Find values inside STMT for that we want to measure histograms and adds\n@@ -1053,7 +1312,7 @@ tree_find_values_to_profile (histogram_values *values)\n   basic_block bb;\n   block_stmt_iterator bsi;\n   unsigned i;\n-  histogram_value hist;\n+  histogram_value hist = NULL;\n \n   *values = NULL;\n   FOR_EACH_BB (bb)\n@@ -1065,52 +1324,30 @@ tree_find_values_to_profile (histogram_values *values)\n       switch (hist->type)\n         {\n \tcase HIST_TYPE_INTERVAL:\n-\t  if (dump_file)\n-\t    {\n-\t      fprintf (dump_file, \"Interval counter for tree \");\n-\t      print_generic_expr (dump_file, hist->hvalue.stmt, \n-\t\t\t\t  TDF_SLIM);\n-\t      fprintf (dump_file, \", range %d -- %d.\\n\",\n-\t\t     hist->hdata.intvl.int_start,\n-\t\t     (hist->hdata.intvl.int_start\n-\t\t      + hist->hdata.intvl.steps - 1));\n-\t    }\n \t  hist->n_counters = hist->hdata.intvl.steps + 2;\n \t  break;\n \n \tcase HIST_TYPE_POW2:\n-\t  if (dump_file)\n-\t    {\n-\t      fprintf (dump_file, \"Pow2 counter for tree \");\n-\t      print_generic_expr (dump_file, hist->hvalue.stmt, TDF_SLIM);\n-\t      fprintf (dump_file, \".\\n\");\n-\t    }\n \t  hist->n_counters = 2;\n \t  break;\n \n \tcase HIST_TYPE_SINGLE_VALUE:\n-\t  if (dump_file)\n-\t    {\n-\t      fprintf (dump_file, \"Single value counter for tree \");\n-\t      print_generic_expr (dump_file, hist->hvalue.stmt, TDF_SLIM);\n-\t      fprintf (dump_file, \".\\n\");\n-\t    }\n \t  hist->n_counters = 3;\n \t  break;\n \n \tcase HIST_TYPE_CONST_DELTA:\n-\t  if (dump_file)\n-\t    {\n-\t      fprintf (dump_file, \"Constant delta counter for tree \");\n-\t      print_generic_expr (dump_file, hist->hvalue.stmt, TDF_SLIM);\n-\t      fprintf (dump_file, \".\\n\");\n-\t    }\n \t  hist->n_counters = 4;\n \t  break;\n \n \tdefault:\n \t  gcc_unreachable ();\n \t}\n+      if (dump_file)\n+        {\n+\t  fprintf (dump_file, \"Stmt \");\n+          print_generic_expr (dump_file, hist->hvalue.stmt, TDF_SLIM);\n+\t  dump_histogram_value (dump_file, hist);\n+        }\n     }\n }\n "}, {"sha": "33670da4856c9f62aee49654128d2e8e098346eb", "filename": "gcc/value-prof.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1/gcc%2Fvalue-prof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1/gcc%2Fvalue-prof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.h?ref=6946b3f7f5a9f6c33b3563a5923b78d9c91a93e1", "patch": "@@ -96,6 +96,17 @@ struct profile_hooks {\n   void (*gen_const_delta_profiler) (histogram_value, unsigned, unsigned);\n };\n \n+histogram_value gimple_histogram_value (struct function *, tree);\n+histogram_value gimple_histogram_value_of_type (struct function *, tree, enum hist_type);\n+void gimple_add_histogram_value (struct function *, tree, histogram_value);\n+void gimple_remove_histogram_value (struct function *, tree, histogram_value);\n+void dump_histograms_for_stmt (struct function *, FILE *, tree);\n+void gimple_remove_histogram_value (struct function *, tree, histogram_value);\n+void gimple_remove_stmt_histograms (struct function *, tree);\n+void gimple_duplicate_stmt_histograms (struct function *, tree, struct function *, tree);\n+void verify_histograms (void);\n+void free_histograms (void);\n+\n /* In profile.c.  */\n extern void init_branch_prob (void);\n extern void branch_prob (void);"}]}