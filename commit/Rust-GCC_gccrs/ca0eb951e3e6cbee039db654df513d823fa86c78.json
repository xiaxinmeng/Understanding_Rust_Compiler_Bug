{"sha": "ca0eb951e3e6cbee039db654df513d823fa86c78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2EwZWI5NTFlM2U2Y2JlZTAzOWRiNjU0ZGY1MTNkODIzZmE4NmM3OA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-12T16:01:16Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-12T16:01:16Z"}, "message": "[multiple changes]\n\n2017-01-12  Tristan Gingold  <gingold@adacore.com>\n\n\t* s-mmap.ads, s-mmap.adb, s-mmosin-unix.ads, s-mmosin-unix.adb,\n\ts-mmauni-long.ads, s-mmosin-mingw.ads, s-mmosin-mingw.adb: New files.\n\n2017-01-12  Yannick Moy  <moy@adacore.com>\n\n\t* errout.adb, errout.ads (Initialize): Factor common treatment\n\tin Reset_Warnings.\n\t(Reset_Warnings): New procedure to reset counts related to warnings.\n\t(Record_Compilation_Errors): New variable to store the presence of an\n\terror, used in gnat2why to allow changing the Warning_Mode.\n\t(Compilation_Errors): Use new variable Record_Compilation_Errors to\n\tstore the presence of an error.\n\n2017-01-12  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch13.adb (Analyze_Aspect_Specifications):\n\tFor Interrupt_Handler and Attach_ Handler aspects, decorate the\n\tinternally built reference to the protected procedure as coming\n\tfrom sources and force its analysis.\n\n2017-01-12  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Build_Derived_Type): For a scalar derived type,\n\tinherit predicates if any from the first_subtype of the parent,\n\tnot from the anonymous parent type.\n\t* sem_eval.adb (Is_Static_Subtype): A type that inherits a dynamic\n\tpredicate is not a static subtype.\n\n2017-01-12  Gary Dismukes  <dismukes@adacore.com>\n\n\t* freeze.adb (Check_Suspicious_Convention): New procedure\n\tperforming a warning check on discriminated record types with\n\tconvention C or C++. Factored out of procedure Freeze_Record_Type,\n\tand changed to only apply to base types (to avoid spurious\n\twarnings on subtypes). Minor improvement of warning messages\n\tto refer to discriminated rather than variant record types.\n\t(Freeze_Record_Type): Remove code for performing a suspicious\n\tconvention check.\n\t(Freeze_Entity): Only call Freeze_Record_Type\n\ton types that aren't declared within any enclosing generic units\n\t(rather than just excluding the type when the innermost scope\n\tis generic). Call Check_Suspicious_Convention whether or not\n\tthe type is declared within a generic unit.\n\t* sem_ch8.adb (In_Generic_Scope): Move this function to Sem_Util.\n\t* sem_util.ads, sem_util.adb (In_Generic_Scope): New function (moved\n\tfrom Sem_Ch8).\n\n2017-01-12  Tristan Gingold  <gingold@adacore.com>\n\n\t* sysdep.c, adaint.c, rtinit.c, ming32.h:\n\t(__gnat_current_codepage): Renamed from CurrentCodePage\n\t(__gnat_current_ccs_encoding): Renamed from CurrentCCSEncoding\n\n2017-01-12  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Fully_Conformant_Expressions): Handle properly\n\tquantified expressions, following AI12-050: the loop parameters\n\tof two quantified expressions are conformant if they have the\n\tsame identifier.\n\nFrom-SVN: r244369", "tree": {"sha": "6947b25f5f34c7ae96aa0a29be8ed4aed928a2e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6947b25f5f34c7ae96aa0a29be8ed4aed928a2e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca0eb951e3e6cbee039db654df513d823fa86c78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca0eb951e3e6cbee039db654df513d823fa86c78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca0eb951e3e6cbee039db654df513d823fa86c78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca0eb951e3e6cbee039db654df513d823fa86c78/comments", "author": null, "committer": null, "parents": [{"sha": "661131664980c54b72c6223a53a464f23b8ec0a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/661131664980c54b72c6223a53a464f23b8ec0a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/661131664980c54b72c6223a53a464f23b8ec0a3"}], "stats": {"total": 2165, "additions": 2061, "deletions": 104}, "files": [{"sha": "9af0589b60c9ff4e5fc61ca296f9ea6756c21ed3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ca0eb951e3e6cbee039db654df513d823fa86c78", "patch": "@@ -1,3 +1,65 @@\n+2017-01-12  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* s-mmap.ads, s-mmap.adb, s-mmosin-unix.ads, s-mmosin-unix.adb,\n+\ts-mmauni-long.ads, s-mmosin-mingw.ads, s-mmosin-mingw.adb: New files.\n+\n+2017-01-12  Yannick Moy  <moy@adacore.com>\n+\n+\t* errout.adb, errout.ads (Initialize): Factor common treatment\n+\tin Reset_Warnings.\n+\t(Reset_Warnings): New procedure to reset counts related to warnings.\n+\t(Record_Compilation_Errors): New variable to store the presence of an\n+\terror, used in gnat2why to allow changing the Warning_Mode.\n+\t(Compilation_Errors): Use new variable Record_Compilation_Errors to\n+\tstore the presence of an error.\n+\n+2017-01-12  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications):\n+\tFor Interrupt_Handler and Attach_ Handler aspects, decorate the\n+\tinternally built reference to the protected procedure as coming\n+\tfrom sources and force its analysis.\n+\n+2017-01-12  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Build_Derived_Type): For a scalar derived type,\n+\tinherit predicates if any from the first_subtype of the parent,\n+\tnot from the anonymous parent type.\n+\t* sem_eval.adb (Is_Static_Subtype): A type that inherits a dynamic\n+\tpredicate is not a static subtype.\n+\n+2017-01-12  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* freeze.adb (Check_Suspicious_Convention): New procedure\n+\tperforming a warning check on discriminated record types with\n+\tconvention C or C++. Factored out of procedure Freeze_Record_Type,\n+\tand changed to only apply to base types (to avoid spurious\n+\twarnings on subtypes). Minor improvement of warning messages\n+\tto refer to discriminated rather than variant record types.\n+\t(Freeze_Record_Type): Remove code for performing a suspicious\n+\tconvention check.\n+\t(Freeze_Entity): Only call Freeze_Record_Type\n+\ton types that aren't declared within any enclosing generic units\n+\t(rather than just excluding the type when the innermost scope\n+\tis generic). Call Check_Suspicious_Convention whether or not\n+\tthe type is declared within a generic unit.\n+\t* sem_ch8.adb (In_Generic_Scope): Move this function to Sem_Util.\n+\t* sem_util.ads, sem_util.adb (In_Generic_Scope): New function (moved\n+\tfrom Sem_Ch8).\n+\n+2017-01-12  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* sysdep.c, adaint.c, rtinit.c, ming32.h:\n+\t(__gnat_current_codepage): Renamed from CurrentCodePage\n+\t(__gnat_current_ccs_encoding): Renamed from CurrentCCSEncoding\n+\n+2017-01-12  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Fully_Conformant_Expressions): Handle properly\n+\tquantified expressions, following AI12-050: the loop parameters\n+\tof two quantified expressions are conformant if they have the\n+\tsame identifier.\n+\n 2017-01-12  Arnaud Charlet  <charlet@adacore.com>\n \n \t* gcc-interface/Makefile.in: Clean up VxWorks targets."}, {"sha": "54a1d6e25c3196bd5ac91d190d5ba964545fd913", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=ca0eb951e3e6cbee039db654df513d823fa86c78", "patch": "@@ -128,8 +128,8 @@ extern \"C\" {\n #include \"mingw32.h\"\n \n /* Current code page and CCS encoding to use, set in initialize.c.  */\n-UINT CurrentCodePage;\n-UINT CurrentCCSEncoding;\n+UINT __gnat_current_codepage;\n+UINT __gnat_current_ccs_encoding;\n \n #include <sys/utime.h>\n "}, {"sha": "001072d5b8f97ae00c181aa4d041e3683d114a09", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=ca0eb951e3e6cbee039db654df513d823fa86c78", "patch": "@@ -60,6 +60,13 @@ package body Errout is\n    Finalize_Called : Boolean := False;\n    --  Set True if the Finalize routine has been called\n \n+   Record_Compilation_Errors : Boolean := False;\n+   --  Record that a compilation error was witnessed during a given phase of\n+   --  analysis for gnat2why. This is needed as Warning_Mode is modified twice\n+   --  in gnat2why, hence Erroutc.Compilation_Errors can only return a suitable\n+   --  value for each phase of analysis separately. This is updated at each\n+   --  call to Compilation_Errors.\n+\n    Warn_On_Instance : Boolean;\n    --  Flag set true for warning message to be posted on instance\n \n@@ -236,8 +243,17 @@ package body Errout is\n    begin\n       if not Finalize_Called then\n          raise Program_Error;\n+\n+      --  Record that a compilation error was witnessed during a given phase of\n+      --  analysis for gnat2why. This is needed as Warning_Mode is modified\n+      --  twice in gnat2why, hence Erroutc.Compilation_Errors can only return a\n+      --  suitable value for each phase of analysis separately.\n+\n       else\n-         return Erroutc.Compilation_Errors;\n+         Record_Compilation_Errors := Record_Compilation_Errors or else\n+           Erroutc.Compilation_Errors;\n+\n+         return Record_Compilation_Errors;\n       end if;\n    end Compilation_Errors;\n \n@@ -1615,13 +1631,13 @@ package body Errout is\n       Last_Error_Msg := No_Error_Msg;\n       Serious_Errors_Detected := 0;\n       Total_Errors_Detected := 0;\n-      Warnings_Treated_As_Errors := 0;\n-      Warnings_Detected := 0;\n-      Info_Messages := 0;\n-      Warnings_As_Errors_Count := 0;\n       Cur_Msg := No_Error_Msg;\n       List_Pragmas.Init;\n \n+      --  Reset counts for warnings\n+\n+      Reset_Warnings;\n+\n       --  Initialize warnings tables\n \n       Warnings.Init;\n@@ -2357,6 +2373,18 @@ package body Errout is\n       end if;\n    end Remove_Warning_Messages;\n \n+   --------------------\n+   -- Reset_Warnings --\n+   --------------------\n+\n+   procedure Reset_Warnings is\n+   begin\n+      Warnings_Treated_As_Errors := 0;\n+      Warnings_Detected := 0;\n+      Info_Messages := 0;\n+      Warnings_As_Errors_Count := 0;\n+   end Reset_Warnings;\n+\n    ----------------------\n    -- Adjust_Name_Case --\n    ----------------------"}, {"sha": "a8e4d6c15afdb43dd20ded65e8cad184aafdef0a", "filename": "gcc/ada/errout.ads", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Ferrout.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Ferrout.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.ads?ref=ca0eb951e3e6cbee039db654df513d823fa86c78", "patch": "@@ -803,6 +803,11 @@ package Errout is\n    --  Remove warnings on all elements of a list (Calls Remove_Warning_Messages\n    --  on each element of the list, see above).\n \n+   procedure Reset_Warnings;\n+   --  Reset the counts related to warnings. This is used both to initialize\n+   --  these counts and to reset them after each phase of analysis for a given\n+   --  value of Opt.Warning_Mode in gnat2why.\n+\n    procedure Set_Ignore_Errors (To : Boolean);\n    --  Following a call to this procedure with To=True, all error calls are\n    --  ignored. A call with To=False restores the default treatment in which\n@@ -852,9 +857,9 @@ package Errout is\n    function Compilation_Errors return Boolean;\n    --  Returns True if errors have been detected, or warnings in -gnatwe (treat\n    --  warnings as errors) mode. Note that it is mandatory to call Finalize\n-   --  before calling this routine. Always returns False in formal verification\n-   --  mode, because errors issued when analyzing code are not compilation\n-   --  errors, and should not result in exiting with an error status.\n+   --  before calling this routine. To account for changes to Warning_Mode in\n+   --  gnat2why between phases, the past or current presence of an error is\n+   --  recorded in a global variable at each call.\n \n    procedure Error_Msg_CRT (Feature : String; N : Node_Id);\n    --  Posts a non-fatal message on node N saying that the feature identified"}, {"sha": "0cc588102e2b80da585699be9911a24e10d5ae9d", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 63, "deletions": 45, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=ca0eb951e3e6cbee039db654df513d823fa86c78", "patch": "@@ -2035,6 +2035,13 @@ package body Freeze is\n       --  which is the current instance type can only be applied when the type\n       --  is limited.\n \n+      procedure Check_Suspicious_Convention (Rec_Type : Entity_Id);\n+      --  Give a warning for pragma Convention with language C or C++ applied\n+      --  to a discriminated record type. This is suppressed for the unchecked\n+      --  union case, since the whole point in this case is interface C. We\n+      --  also do not generate this within instantiations, since we will have\n+      --  generated a message on the template.\n+\n       procedure Check_Suspicious_Modulus (Utype : Entity_Id);\n       --  Give warning for modulus of 8, 16, 32, or 64 given as an explicit\n       --  integer literal without an explicit corresponding size clause. The\n@@ -2249,6 +2256,51 @@ package body Freeze is\n          end if;\n       end Check_Current_Instance;\n \n+      ---------------------------------\n+      -- Check_Suspicious_Convention --\n+      ---------------------------------\n+\n+      procedure Check_Suspicious_Convention (Rec_Type : Entity_Id) is\n+      begin\n+         if Has_Discriminants (Rec_Type)\n+           and then Is_Base_Type (Rec_Type)\n+           and then not Is_Unchecked_Union (Rec_Type)\n+           and then (Convention (Rec_Type) = Convention_C\n+                       or else\n+                     Convention (Rec_Type) = Convention_CPP)\n+           and then Comes_From_Source (Rec_Type)\n+           and then not In_Instance\n+           and then not Has_Warnings_Off (Rec_Type)\n+         then\n+            declare\n+               Cprag : constant Node_Id :=\n+                         Get_Rep_Pragma (Rec_Type, Name_Convention);\n+               A2    : Node_Id;\n+\n+            begin\n+               if Present (Cprag) then\n+                  A2 := Next (First (Pragma_Argument_Associations (Cprag)));\n+\n+                  if Convention (Rec_Type) = Convention_C then\n+                     Error_Msg_N\n+                       (\"?x?discriminated record has no direct \" &\n+                        \"equivalent in C\",\n+                        A2);\n+                  else\n+                     Error_Msg_N\n+                       (\"?x?discriminated record has no direct \" &\n+                        \"equivalent in C++\",\n+                        A2);\n+                  end if;\n+\n+                  Error_Msg_NE\n+                    (\"\\?x?use of convention for type& is dubious\",\n+                     A2, Rec_Type);\n+               end if;\n+            end;\n+         end if;\n+      end Check_Suspicious_Convention;\n+\n       ------------------------------\n       -- Check_Suspicious_Modulus --\n       ------------------------------\n@@ -4348,46 +4400,6 @@ package body Freeze is\n             end loop;\n          end if;\n \n-         --  Generate warning for applying C or C++ convention to a record\n-         --  with discriminants. This is suppressed for the unchecked union\n-         --  case, since the whole point in this case is interface C. We also\n-         --  do not generate this within instantiations, since we will have\n-         --  generated a message on the template.\n-\n-         if Has_Discriminants (E)\n-           and then not Is_Unchecked_Union (E)\n-           and then (Convention (E) = Convention_C\n-                       or else\n-                     Convention (E) = Convention_CPP)\n-           and then Comes_From_Source (E)\n-           and then not In_Instance\n-           and then not Has_Warnings_Off (E)\n-           and then not Has_Warnings_Off (Base_Type (E))\n-         then\n-            declare\n-               Cprag : constant Node_Id := Get_Rep_Pragma (E, Name_Convention);\n-               A2    : Node_Id;\n-\n-            begin\n-               if Present (Cprag) then\n-                  A2 := Next (First (Pragma_Argument_Associations (Cprag)));\n-\n-                  if Convention (E) = Convention_C then\n-                     Error_Msg_N\n-                       (\"?x?variant record has no direct equivalent in C\",\n-                        A2);\n-                  else\n-                     Error_Msg_N\n-                       (\"?x?variant record has no direct equivalent in C++\",\n-                        A2);\n-                  end if;\n-\n-                  Error_Msg_NE\n-                    (\"\\?x?use of convention for type& is dubious\", A2, E);\n-               end if;\n-            end;\n-         end if;\n-\n          --  See if Size is too small as is (and implicit packing might help)\n \n          if not Is_Packed (Rec)\n@@ -5643,11 +5655,17 @@ package body Freeze is\n          --  for the case of a private type with record extension (we will do\n          --  that later when the full type is frozen).\n \n-         elsif Ekind_In (E, E_Record_Type, E_Record_Subtype)\n-           and then not (Present (Scope (E))\n-                          and then Is_Generic_Unit (Scope (E)))\n-         then\n-            Freeze_Record_Type (E);\n+         elsif Ekind_In (E, E_Record_Type, E_Record_Subtype) then\n+            if not In_Generic_Scope (E) then\n+               Freeze_Record_Type (E);\n+            end if;\n+\n+            --  Report a warning if a discriminated record base type has a\n+            --  convention with language C or C++ applied to it. This check is\n+            --  done even within generic scopes (but not in instantiations),\n+            --  which is why we don't do it as part of Freeze_Record_Type.\n+\n+            Check_Suspicious_Convention (E);\n \n          --  For a concurrent type, freeze corresponding record type. This does\n          --  not correspond to any specific rule in the RM, but the record type"}, {"sha": "cf2d9de1715cf1f8ad73eb1a0cadf64810189fc0", "filename": "gcc/ada/mingw32.h", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fmingw32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fmingw32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmingw32.h?ref=ca0eb951e3e6cbee039db654df513d823fa86c78", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 2002-2014, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 2002-2016, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -78,14 +78,15 @@\n \n #ifdef GNAT_UNICODE_SUPPORT\n \n-extern UINT CurrentCodePage;\n-extern UINT CurrentCCSEncoding;\n+extern UINT __gnat_current_codepage;\n+extern UINT __gnat_current_ccs_encoding;\n \n-/*  Macros to convert to/from the code page specified in CurrentCodePage.  */\n+/*  Macros to convert to/from the code page specified in\n+    __gnat_current_codepage.  */\n #define S2WSC(wstr,str,len) \\\n-   MultiByteToWideChar (CurrentCodePage,0,str,-1,wstr,len)\n+   MultiByteToWideChar (__gnat_current_codepage,0,str,-1,wstr,len)\n #define WS2SC(str,wstr,len) \\\n-   WideCharToMultiByte (CurrentCodePage,0,wstr,-1,str,len,NULL,NULL)\n+   WideCharToMultiByte (__gnat_current_codepage,0,wstr,-1,str,len,NULL,NULL)\n \n /*  Macros to convert to/from UTF-8 code page.  */\n #define S2WSU(wstr,str,len) \\"}, {"sha": "42defa8ca134e84f6eeeead7f0a9d41abbb91db2", "filename": "gcc/ada/rtinit.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Frtinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Frtinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtinit.c?ref=ca0eb951e3e6cbee039db654df513d823fa86c78", "patch": "@@ -169,14 +169,14 @@ __gnat_runtime_initialize(int install_handler)\n      char *codepage = getenv (\"GNAT_CODE_PAGE\");\n \n      /* Default code page is UTF-8.  */\n-     CurrentCodePage = CP_UTF8;\n+     __gnat_current_codepage = CP_UTF8;\n \n      if (codepage != NULL)\n        {\n \t if (strcmp (codepage, \"CP_ACP\") == 0)\n-\t   CurrentCodePage = CP_ACP;\n+\t   __gnat_current_codepage = CP_ACP;\n \t else if (strcmp (codepage, \"CP_UTF8\") == 0)\n-\t   CurrentCodePage = CP_UTF8;\n+\t   __gnat_current_codepage = CP_UTF8;\n        }\n    }\n \n@@ -185,29 +185,29 @@ __gnat_runtime_initialize(int install_handler)\n      char *ccsencoding = getenv (\"GNAT_CCS_ENCODING\");\n \n      /* Default CCS Encoding.  */\n-     CurrentCCSEncoding = _O_TEXT;\n+     __gnat_current_ccs_encoding = _O_TEXT;\n      __gnat_wide_text_translation_required = 0;\n \n      if (ccsencoding != NULL)\n        {\n \t if (strcmp (ccsencoding, \"U16TEXT\") == 0)\n            {\n-             CurrentCCSEncoding = _O_U16TEXT;\n+             __gnat_current_ccs_encoding = _O_U16TEXT;\n              __gnat_wide_text_translation_required = 1;\n            }\n \t else if (strcmp (ccsencoding, \"TEXT\") == 0)\n            {\n-             CurrentCCSEncoding = _O_TEXT;\n+             __gnat_current_ccs_encoding = _O_TEXT;\n              __gnat_wide_text_translation_required = 0;\n            }\n \t else if (strcmp (ccsencoding, \"WTEXT\") == 0)\n            {\n-             CurrentCCSEncoding = _O_WTEXT;\n+             __gnat_current_ccs_encoding = _O_WTEXT;\n              __gnat_wide_text_translation_required = 1;\n            }\n \t else if (strcmp (ccsencoding, \"U8TEXT\") == 0)\n            {\n-             CurrentCCSEncoding = _O_U8TEXT;\n+             __gnat_current_ccs_encoding = _O_U8TEXT;\n              __gnat_wide_text_translation_required = 1;\n            }\n        }"}, {"sha": "e9b2aff4201de01053e4c8cde5fa630d445f71d6", "filename": "gcc/ada/s-mmap.adb", "status": "added", "additions": 548, "deletions": 0, "changes": 548, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fs-mmap.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fs-mmap.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mmap.adb?ref=ca0eb951e3e6cbee039db654df513d823fa86c78", "patch": "@@ -0,0 +1,548 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                          S Y S T E M . M M A P                           --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                     Copyright (C) 2007-2016, AdaCore                     --\n+--                                                                          --\n+-- This library is free software;  you can redistribute it and/or modify it --\n+-- under terms of the  GNU General Public License  as published by the Free --\n+-- Software  Foundation;  either version 3,  or (at your  option) any later --\n+-- version. This library is distributed in the hope that it will be useful, --\n+-- but WITHOUT ANY WARRANTY;  without even the implied warranty of MERCHAN- --\n+-- TABILITY or FITNESS FOR A PARTICULAR PURPOSE.                            --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.IO_Exceptions;\n+with Ada.Unchecked_Conversion;\n+with Ada.Unchecked_Deallocation;\n+\n+with System.Strings; use System.Strings;\n+\n+with System.Mmap.OS_Interface; use System.Mmap.OS_Interface;\n+\n+package body System.Mmap is\n+\n+   type Mapped_File_Record is record\n+      Current_Region     : Mapped_Region;\n+      --  The legacy API enables only one region to be mapped, directly\n+      --  associated with the mapped file. This references this region.\n+\n+      File               : System_File;\n+      --  Underlying OS-level file\n+   end record;\n+\n+   type Mapped_Region_Record is record\n+      File          : Mapped_File;\n+      --  The file this region comes from. Be careful: for reading file, it is\n+      --  valid to have it closed before one of its regions is free'd.\n+\n+      Write         : Boolean;\n+      --  Whether the file this region comes from is open for writing.\n+\n+      Data          : Str_Access;\n+      --  Unbounded access to the mapped content.\n+\n+      System_Offset : File_Size;\n+      --  Position in the file of the first byte actually mapped in memory\n+\n+      User_Offset   : File_Size;\n+      --  Position in the file of the first byte requested by the user\n+\n+      System_Size   : File_Size;\n+      --  Size of the region actually mapped in memory\n+\n+      User_Size     : File_Size;\n+      --  Size of the region requested by the user\n+\n+      Mapped        : Boolean;\n+      --  Whether this region is actually memory mapped\n+\n+      Mutable       : Boolean;\n+      --  If the file is opened for reading, wheter this region is writable\n+\n+      Buffer        : System.Strings.String_Access;\n+      --  When this region is not actually memory mapped, contains the\n+      --  requested bytes.\n+\n+      Mapping       : System_Mapping;\n+      --  Underlying OS-level data for the mapping, if any\n+   end record;\n+\n+   Invalid_Mapped_Region_Record : constant Mapped_Region_Record :=\n+     (null, False, null, 0, 0, 0, 0, False, False, null,\n+      Invalid_System_Mapping);\n+   Invalid_Mapped_File_Record : constant Mapped_File_Record :=\n+     (Invalid_Mapped_Region, Invalid_System_File);\n+\n+   Empty_String : constant String := \"\";\n+   --  Used to provide a valid empty Data for empty files, for instanc.\n+\n+   procedure Dispose is new Ada.Unchecked_Deallocation\n+     (Mapped_File_Record, Mapped_File);\n+   procedure Dispose is new Ada.Unchecked_Deallocation\n+     (Mapped_Region_Record, Mapped_Region);\n+\n+   function Convert is new Ada.Unchecked_Conversion\n+     (Standard.System.Address, Str_Access);\n+\n+   procedure Compute_Data (Region : Mapped_Region);\n+   --  Fill the Data field according to system and user offsets. The region\n+   --  must actually be mapped or bufferized.\n+\n+   procedure From_Disk (Region : Mapped_Region);\n+   --  Read a region of some file from the disk\n+\n+   procedure To_Disk (Region : Mapped_Region);\n+   --  Write the region of the file back to disk if necessary, and free memory\n+\n+   ---------------\n+   -- Open_Read --\n+   ---------------\n+\n+   function Open_Read\n+     (Filename              : String;\n+      Use_Mmap_If_Available : Boolean := True) return Mapped_File\n+   is\n+      File : constant System_File :=\n+         Open_Read (Filename, Use_Mmap_If_Available);\n+   begin\n+      return new Mapped_File_Record'\n+        (Current_Region => Invalid_Mapped_Region,\n+         File           => File);\n+   end Open_Read;\n+\n+   ----------------\n+   -- Open_Write --\n+   ----------------\n+\n+   function Open_Write\n+     (Filename              : String;\n+      Use_Mmap_If_Available : Boolean := True) return Mapped_File\n+   is\n+      File : constant System_File :=\n+         Open_Write (Filename, Use_Mmap_If_Available);\n+   begin\n+      return new Mapped_File_Record'\n+        (Current_Region => Invalid_Mapped_Region,\n+         File           => File);\n+   end Open_Write;\n+\n+   -----------\n+   -- Close --\n+   -----------\n+\n+   procedure Close (File : in out Mapped_File) is\n+   begin\n+      --  Closing a closed file is allowed and should do nothing\n+\n+      if File = Invalid_Mapped_File then\n+         return;\n+      end if;\n+\n+      if File.Current_Region /= null then\n+         Free (File.Current_Region);\n+      end if;\n+\n+      if File.File /= Invalid_System_File then\n+         Close (File.File);\n+      end if;\n+\n+      Dispose (File);\n+   end Close;\n+\n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free (Region : in out Mapped_Region) is\n+      Ignored : Integer;\n+      pragma Unreferenced (Ignored);\n+   begin\n+      --  Freeing an already free'd file is allowed and should do nothing\n+\n+      if Region = Invalid_Mapped_Region then\n+         return;\n+      end if;\n+\n+      if Region.Mapping /= Invalid_System_Mapping then\n+         Dispose_Mapping (Region.Mapping);\n+      end if;\n+      To_Disk (Region);\n+      Dispose (Region);\n+   end Free;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (File    : Mapped_File;\n+      Region  : in out Mapped_Region;\n+      Offset  : File_Size := 0;\n+      Length  : File_Size := 0;\n+      Mutable : Boolean := False)\n+   is\n+      File_Length      : constant File_Size := Mmap.Length (File);\n+\n+      Req_Offset       : constant File_Size := Offset;\n+      Req_Length       : File_Size := Length;\n+      --  Offset and Length of the region to map, used to adjust mapping\n+      --  bounds, reflecting what the user will see.\n+\n+      Region_Allocated : Boolean := False;\n+   begin\n+      --  If this region comes from another file, or simply if the file is\n+      --  writeable, we cannot re-use this mapping: free it first.\n+\n+      if Region /= Invalid_Mapped_Region\n+        and then\n+          (Region.File /= File or else File.File.Write)\n+      then\n+         Free (Region);\n+      end if;\n+\n+      if Region = Invalid_Mapped_Region then\n+         Region := new Mapped_Region_Record'(Invalid_Mapped_Region_Record);\n+         Region_Allocated := True;\n+      end if;\n+\n+      Region.File := File;\n+\n+      if Req_Offset >= File_Length then\n+         --  If the requested offset goes beyond file size, map nothing\n+\n+         Req_Length := 0;\n+\n+      elsif Length = 0\n+        or else\n+          Length > File_Length - Req_Offset\n+      then\n+         --  If Length is 0 or goes beyond file size, map till end of file\n+\n+         Req_Length := File_Length - Req_Offset;\n+\n+      else\n+         Req_Length := Length;\n+      end if;\n+\n+      --  Past this point, the offset/length the user will see is fixed. On the\n+      --  other hand, the system offset/length is either already defined, from\n+      --  a previous mapping, or it is set to 0. In the latter case, the next\n+      --  step will set them according to the mapping.\n+\n+      Region.User_Offset := Req_Offset;\n+      Region.User_Size := Req_Length;\n+\n+      --  If the requested region is inside an already mapped region, adjust\n+      --  user-requested data and do nothing else.\n+\n+      if (File.File.Write or else Region.Mutable = Mutable)\n+        and then\n+        Req_Offset >= Region.System_Offset\n+        and then\n+            (Req_Offset + Req_Length\n+             <= Region.System_Offset + Region.System_Size)\n+      then\n+         Region.User_Offset := Req_Offset;\n+         Compute_Data (Region);\n+         return;\n+\n+      elsif Region.Buffer /= null then\n+         --  Otherwise, as we are not going to re-use the buffer, free it\n+\n+         System.Strings.Free (Region.Buffer);\n+         Region.Buffer := null;\n+\n+      elsif Region.Mapping /= Invalid_System_Mapping then\n+         --  Otherwise, there is a memory mapping that we need to unmap.\n+         Dispose_Mapping (Region.Mapping);\n+      end if;\n+\n+      --  mmap() will sometimes return NULL when the file exists but is empty,\n+      --  which is not what we want, so in the case of a zero length file we\n+      --  fall back to read(2)/write(2)-based mode.\n+\n+      if File_Length > 0 and then File.File.Mapped then\n+\n+         Region.System_Offset := Req_Offset;\n+         Region.System_Size := Req_Length;\n+         Create_Mapping\n+           (File.File,\n+            Region.System_Offset, Region.System_Size,\n+            Mutable,\n+            Region.Mapping);\n+         Region.Mapped := True;\n+         Region.Mutable := Mutable;\n+\n+      else\n+         --  There is no alignment requirement when manually reading the file.\n+\n+         Region.System_Offset := Req_Offset;\n+         Region.System_Size := Req_Length;\n+         Region.Mapped := False;\n+         Region.Mutable := True;\n+         From_Disk (Region);\n+      end if;\n+\n+      Region.Write := File.File.Write;\n+      Compute_Data (Region);\n+\n+   exception\n+      when others =>\n+         --  Before propagating any exception, free any region we allocated\n+         --  here.\n+\n+         if Region_Allocated then\n+            Dispose (Region);\n+         end if;\n+         raise;\n+   end Read;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   procedure Read\n+     (File    : Mapped_File;\n+      Offset  : File_Size := 0;\n+      Length  : File_Size := 0;\n+      Mutable : Boolean := False)\n+   is\n+   begin\n+      Read (File, File.Current_Region, Offset, Length, Mutable);\n+   end Read;\n+\n+   ----------\n+   -- Read --\n+   ----------\n+\n+   function Read\n+     (File    : Mapped_File;\n+      Offset  : File_Size := 0;\n+      Length  : File_Size := 0;\n+      Mutable : Boolean := False) return Mapped_Region\n+   is\n+      Region  : Mapped_Region := Invalid_Mapped_Region;\n+   begin\n+      Read (File, Region, Offset, Length, Mutable);\n+      return Region;\n+   end Read;\n+\n+   ------------\n+   -- Length --\n+   ------------\n+\n+   function Length (File : Mapped_File) return File_Size is\n+   begin\n+      return File.File.Length;\n+   end Length;\n+\n+   ------------\n+   -- Offset --\n+   ------------\n+\n+   function Offset (Region : Mapped_Region) return File_Size is\n+   begin\n+      return Region.User_Offset;\n+   end Offset;\n+\n+   ------------\n+   -- Offset --\n+   ------------\n+\n+   function Offset (File : Mapped_File) return File_Size is\n+   begin\n+      return Offset (File.Current_Region);\n+   end Offset;\n+\n+   ----------\n+   -- Last --\n+   ----------\n+\n+   function Last (Region : Mapped_Region) return Integer is\n+   begin\n+      return Integer (Region.User_Size);\n+   end Last;\n+\n+   ----------\n+   -- Last --\n+   ----------\n+\n+   function Last (File : Mapped_File) return Integer is\n+   begin\n+      return Last (File.Current_Region);\n+   end Last;\n+\n+   -------------------\n+   -- To_Str_Access --\n+   -------------------\n+\n+   function To_Str_Access\n+     (Str : System.Strings.String_Access) return Str_Access is\n+   begin\n+      if Str = null then\n+         return null;\n+      else\n+         return Convert (Str.all'Address);\n+      end if;\n+   end To_Str_Access;\n+\n+   ----------\n+   -- Data --\n+   ----------\n+\n+   function Data (Region : Mapped_Region) return Str_Access is\n+   begin\n+      return Region.Data;\n+   end Data;\n+\n+   ----------\n+   -- Data --\n+   ----------\n+\n+   function Data (File : Mapped_File) return Str_Access is\n+   begin\n+      return Data (File.Current_Region);\n+   end Data;\n+\n+   ----------------\n+   -- Is_Mutable --\n+   ----------------\n+\n+   function Is_Mutable (Region : Mapped_Region) return Boolean is\n+   begin\n+      return Region.Mutable or Region.Write;\n+   end Is_Mutable;\n+\n+   ----------------\n+   -- Is_Mmapped --\n+   ----------------\n+\n+   function Is_Mmapped (File : Mapped_File) return Boolean is\n+   begin\n+      return File.File.Mapped;\n+   end Is_Mmapped;\n+\n+   -------------------\n+   -- Get_Page_Size --\n+   -------------------\n+\n+   function Get_Page_Size return Integer is\n+      Result : constant File_Size := Get_Page_Size;\n+   begin\n+      return Integer (Result);\n+   end Get_Page_Size;\n+\n+   ---------------------\n+   -- Read_Whole_File --\n+   ---------------------\n+\n+   function Read_Whole_File\n+     (Filename           : String;\n+      Empty_If_Not_Found : Boolean := False)\n+     return System.Strings.String_Access\n+   is\n+      File   : Mapped_File := Open_Read (Filename);\n+      Region : Mapped_Region renames File.Current_Region;\n+      Result : String_Access;\n+   begin\n+      Read (File);\n+\n+      if Region.Data /= null then\n+         Result := new String'(String\n+                               (Region.Data (1 .. Last (Region))));\n+\n+      elsif Region.Buffer /= null then\n+         Result := Region.Buffer;\n+         Region.Buffer := null;  --  So that it is not deallocated\n+      end if;\n+\n+      Close (File);\n+\n+      return Result;\n+\n+   exception\n+      when Ada.IO_Exceptions.Name_Error =>\n+         if Empty_If_Not_Found then\n+            return new String'(\"\");\n+         else\n+            return null;\n+         end if;\n+\n+      when others =>\n+         Close (File);\n+         return null;\n+   end Read_Whole_File;\n+\n+   ---------------\n+   -- From_Disk --\n+   ---------------\n+\n+   procedure From_Disk (Region : Mapped_Region) is\n+   begin\n+      pragma Assert (Region.File.all /= Invalid_Mapped_File_Record);\n+      pragma Assert (Region.Buffer = null);\n+\n+      Region.Buffer := Read_From_Disk\n+        (Region.File.File, Region.User_Offset, Region.User_Size);\n+      Region.Mapped := False;\n+   end From_Disk;\n+\n+   -------------\n+   -- To_Disk --\n+   -------------\n+\n+   procedure To_Disk (Region : Mapped_Region) is\n+   begin\n+      if Region.Write and then Region.Buffer /= null then\n+         pragma Assert (Region.File.all /= Invalid_Mapped_File_Record);\n+         Write_To_Disk\n+           (Region.File.File,\n+            Region.User_Offset, Region.User_Size,\n+            Region.Buffer);\n+      end if;\n+\n+      System.Strings.Free (Region.Buffer);\n+      Region.Buffer := null;\n+   end To_Disk;\n+\n+   ------------------\n+   -- Compute_Data --\n+   ------------------\n+\n+   procedure Compute_Data (Region : Mapped_Region) is\n+      Base_Data : Str_Access;\n+      --  Address of the first byte actually mapped in memory\n+\n+      Data_Shift : constant Integer :=\n+        Integer (Region.User_Offset - Region.System_Offset);\n+   begin\n+      if Region.User_Size = 0 then\n+         Region.Data := Convert (Empty_String'Address);\n+         return;\n+      elsif Region.Mapped then\n+         Base_Data := Convert (Region.Mapping.Address);\n+      else\n+         Base_Data := Convert (Region.Buffer.all'Address);\n+      end if;\n+      Region.Data := Convert (Base_Data (Data_Shift + 1)'Address);\n+   end Compute_Data;\n+\n+end System.Mmap;"}, {"sha": "8eed3666949cedc708893360e9af71a9496abdd9", "filename": "gcc/ada/s-mmap.ads", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fs-mmap.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fs-mmap.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mmap.ads?ref=ca0eb951e3e6cbee039db654df513d823fa86c78", "patch": "@@ -0,0 +1,276 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                          S Y S T E M . M M A P                           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                     Copyright (C) 2007-2016, AdaCore                     --\n+--                                                                          --\n+-- This library is free software;  you can redistribute it and/or modify it --\n+-- under terms of the  GNU General Public License  as published by the Free --\n+-- Software  Foundation;  either version 3,  or (at your  option) any later --\n+-- version. This library is distributed in the hope that it will be useful, --\n+-- but WITHOUT ANY WARRANTY;  without even the implied warranty of MERCHAN- --\n+-- TABILITY or FITNESS FOR A PARTICULAR PURPOSE.                            --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides memory mapping of files. Depending on your operating\n+--  system, this might provide a more efficient method for accessing the\n+--  contents of files.\n+--  A description of memory-mapping is available on the sqlite page, at:\n+--      http://www.sqlite.org/mmap.html\n+--\n+--  The traditional method for reading a file is to allocate a buffer in the\n+--  application address space, then open the file and copy its contents. When\n+--  memory mapping is available though, the application asks the operating\n+--  system to return a pointer to the requested page, if possible. If the\n+--  requested page has been or can be mapped into the application address\n+--  space, the system returns a pointer to that page for the application to\n+--  use without having to copy anything. Skipping the copy step is what makes\n+--  memory mapped I/O faster.\n+--\n+--  When memory mapping is not available, this package automatically falls\n+--  back to the traditional copy method.\n+--\n+--  Example of use for this package, when reading a file that can be fully\n+--  mapped\n+--\n+--  declare\n+--     File : Mapped_File;\n+--     Str  : Str_Access;\n+--  begin\n+--     File := Open_Read (\"/tmp/file_on_disk\");\n+--     Read (File);  --  read the whole file\n+--     Str := Data (File);\n+--     for S in 1 .. Last (File) loop\n+--         Put (Str (S));\n+--     end loop;\n+--     Close (File);\n+--  end;\n+--\n+--  When the file is big, or you only want to access part of it at a given\n+--  time, you can use the following type of code.\n+\n+--  declare\n+--     File   : Mapped_File;\n+--     Str    : Str_Access;\n+--     Offs   : File_Size := 0;\n+--     Page   : constant Integer := Get_Page_Size;\n+--  begin\n+--     File := Open_Read (\"/tmp/file_on_disk\");\n+--     while Offs < Length (File) loop\n+--         Read (File, Offs, Length => Long_Integer (Page) * 4);\n+--         Str := Data (File);\n+--\n+--         --  Print characters for this chunk:\n+--         for S in Integer (Offs - Offset (File)) + 1 .. Last (File) loop\n+--            Put (Str (S));\n+--         end loop;\n+--\n+--         --  Since we are reading multiples of Get_Page_Size, we can simplify\n+--         --  with\n+--         --    for S in 1 .. Last (File) loop ...\n+--\n+--         Offs := Offs + Long_Integer (Last (File));\n+--     end loop;\n+\n+with Interfaces.C;\n+\n+with System.Strings;\n+\n+package System.Mmap is\n+\n+   type Mapped_File is private;\n+   --  File to be mapped in memory.\n+\n+   --  This package will use the fastest possible algorithm to load the\n+   --  file in memory. On systems that support it, the file is not really\n+   --  loaded in memory. Instead, a call to the mmap() system call (or\n+   --  CreateFileMapping()) will keep the file on disk, but make it\n+   --  accessible as if it was in memory.\n+\n+   --  When the system does not support it, the file is actually loaded in\n+   --  memory through calls to read(), and written back with write() when you\n+   --  close it. This is of course much slower.\n+\n+   --  Legacy: each mapped file has a \"default\" mapped region in it.\n+\n+   type Mapped_Region is private;\n+   --  A representation of part of a file in memory. Actual reading/writing\n+   --  is done through a mapped region. After being returned by Read, a mapped\n+   --  region must be free'd when done. If the original Mapped_File was open\n+   --  for reading, it can be closed before the mapped region is free'd.\n+\n+   Invalid_Mapped_File : constant Mapped_File;\n+   Invalid_Mapped_Region : constant Mapped_Region;\n+\n+   type Unconstrained_String is new String (Positive);\n+   type Str_Access is access all Unconstrained_String;\n+   pragma No_Strict_Aliasing (Str_Access);\n+\n+   type File_Size is new Interfaces.C.size_t;\n+\n+   function To_Str_Access\n+     (Str : System.Strings.String_Access) return Str_Access;\n+   --  Convert Str. The returned value points to the same memory block, but no\n+   --  longer includes the bounds, which you need to manage yourself\n+\n+   function Open_Read\n+     (Filename              : String;\n+      Use_Mmap_If_Available : Boolean := True) return Mapped_File;\n+   --  Open a file for reading. The same file can be shared by multiple\n+   --  processes, that will see each others's changes as they occur.\n+   --  Any attempt to write the data might result in a segmentation fault,\n+   --  depending on how the file is open.\n+   --  Name_Error is raised if the file does not exist.\n+   --  Filename should be compatible with the filesystem.\n+\n+   function Open_Write\n+     (Filename              : String;\n+      Use_Mmap_If_Available : Boolean := True) return Mapped_File;\n+   --  Open a file for writing.\n+   --  You cannot change the length of the file.\n+   --  Name_Error is raised if the file does not exist\n+   --  Filename should be compatible with the filesystem.\n+\n+   procedure Close (File : in out Mapped_File);\n+   --  Close the file, and unmap the memory that is used for the region\n+   --  contained in File. If the system does not support the unmmap() system\n+   --  call or equivalent, or these were not available for the file itself,\n+   --  then the file is written back to the disk if it was opened for writing.\n+\n+   procedure Free (Region : in out Mapped_Region);\n+   --  Unmap the memory that is used for this region and deallocate the region\n+\n+   procedure Read\n+     (File   : Mapped_File;\n+      Region : in out Mapped_Region;\n+      Offset : File_Size := 0;\n+      Length : File_Size := 0;\n+      Mutable : Boolean := False);\n+   --  Read a specific part of File and set Region to the corresponding mapped\n+   --  region, or re-use it if possible.\n+   --  Offset is the number of bytes since the beginning of the file at which\n+   --  we should start reading. Length is the number of bytes that should be\n+   --  read. If set to 0, as much of the file as possible is read (presumably\n+   --  the whole file unless you are reading a _huge_ file).\n+   --  Note that no (un)mapping is is done if that part of the file is already\n+   --  available through Region.\n+   --  If the file was opened for writing, any modification you do to the\n+   --  data stored in File will be stored on disk (either immediately when the\n+   --  file is opened through a mmap() system call, or when the file is closed\n+   --  otherwise).\n+   --  Mutable is processed only for reading files. If set to True, the\n+   --  data can be modified, even through it will not be carried through the\n+   --  underlying file, nor it is guaranteed to be carried through remapping.\n+   --  This function takes care of page size alignment issues. The accessors\n+   --  below only expose the region that has been requested by this call, even\n+   --  if more bytes were actually mapped by this function.\n+   --  TODO??? Enable to have a private copy for readable files\n+\n+   function Read\n+     (File    : Mapped_File;\n+      Offset  : File_Size := 0;\n+      Length  : File_Size := 0;\n+      Mutable : Boolean := False) return Mapped_Region;\n+   --  Likewise, return a new mapped region\n+\n+   procedure Read\n+     (File    : Mapped_File;\n+      Offset  : File_Size := 0;\n+      Length  : File_Size := 0;\n+      Mutable : Boolean := False);\n+   --  Likewise, use the legacy \"default\" region in File\n+\n+   function Length (File : Mapped_File) return File_Size;\n+   --  Size of the file on the disk\n+\n+   function Offset (Region : Mapped_Region) return File_Size;\n+   --  Return the offset, in the physical file on disk, corresponding to the\n+   --  requested mapped region. The first byte in the file has offest 0.\n+\n+   function Offset (File : Mapped_File) return File_Size;\n+   --  Likewise for the region contained in File\n+\n+   function Last (Region : Mapped_Region) return Integer;\n+   --  Return the number of requested bytes mapped in this region. It is\n+   --  erroneous to access Data for indices outside 1 .. Last (Region).\n+   --  Such accesses may cause Storage_Error to be raised.\n+\n+   function Last (File : Mapped_File) return Integer;\n+   --  Return the number of requested bytes mapped in the region contained in\n+   --  File. It is erroneous to access Data for indices outside of 1 .. Last\n+   --  (File); such accesses may cause Storage_Error to be raised.\n+\n+   function Data (Region : Mapped_Region) return Str_Access;\n+   --  The data mapped in Region as requested. The result is an unconstrained\n+   --  string, so you cannot use the usual 'First and 'Last attributes.\n+   --  Instead, these are respectively 1 and Size.\n+\n+   function Data (File : Mapped_File) return Str_Access;\n+   --  Likewise for the region contained in File\n+\n+   function Is_Mutable (Region : Mapped_Region) return Boolean;\n+   --  Return whether it is safe to change bytes in Data (Region). This is true\n+   --  for regions from writeable files, for regions mapped with the \"Mutable\"\n+   --  flag set, and for regions that are copied in a buffer. Note that it is\n+   --  not specified whether empty regions are mutable or not, since there is\n+   --  no byte no modify.\n+\n+   function Is_Mmapped (File : Mapped_File) return Boolean;\n+   --  Whether regions for this file are opened through an mmap() system call\n+   --  or equivalent. This is in general irrelevant to your application, unless\n+   --  the file can be accessed by multiple concurrent processes or tasks. In\n+   --  such a case, and if the file is indeed mmap-ed, then the various parts\n+   --  of the file can be written simulatenously, and thus you cannot ensure\n+   --  the integrity of the file. If the file is not mmapped, the latest\n+   --  process to Close it overwrite what other processes have done.\n+\n+   function Get_Page_Size return Integer;\n+   --  Returns the number of bytes in a page. Once a file is mapped from the\n+   --  disk, its offset and Length should be multiples of this page size (which\n+   --  is ensured by this package in any case). Knowing this page size allows\n+   --  you to map as much memory as possible at once, thus potentially reducing\n+   --  the number of system calls to read the file by chunks.\n+\n+   function Read_Whole_File\n+     (Filename           : String;\n+      Empty_If_Not_Found : Boolean := False)\n+     return System.Strings.String_Access;\n+   --  Returns the whole contents of the file.\n+   --  The returned string must be freed by the user.\n+   --  This is a convenience function, which is of course slower than the ones\n+   --  above since we also need to allocate some memory, actually read the file\n+   --  and copy the bytes.\n+   --  If the file does not exist, null is returned. However, if\n+   --  Empty_If_Not_Found is True, then the empty string is returned instead.\n+   --  Filename should be compatible with the filesystem.\n+\n+private\n+   pragma Inline (Data, Length, Last, Offset, Is_Mmapped, To_Str_Access);\n+\n+   type Mapped_File_Record;\n+   type Mapped_File is access Mapped_File_Record;\n+\n+   type Mapped_Region_Record;\n+   type Mapped_Region is access Mapped_Region_Record;\n+\n+   Invalid_Mapped_File   : constant Mapped_File := null;\n+   Invalid_Mapped_Region : constant Mapped_Region := null;\n+\n+end System.Mmap;"}, {"sha": "f7fa0bda6f9c9479d784e5706bc393dfbcaed486", "filename": "gcc/ada/s-mmauni-long.ads", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fs-mmauni-long.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fs-mmauni-long.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mmauni-long.ads?ref=ca0eb951e3e6cbee039db654df513d823fa86c78", "patch": "@@ -0,0 +1,69 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                      S Y S T E M . M M A P . U N I X                     --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                     Copyright (C) 2007-2016, AdaCore                     --\n+--                                                                          --\n+-- This library is free software;  you can redistribute it and/or modify it --\n+-- under terms of the  GNU General Public License  as published by the Free --\n+-- Software  Foundation;  either version 3,  or (at your  option) any later --\n+-- version. This library is distributed in the hope that it will be useful, --\n+-- but WITHOUT ANY WARRANTY;  without even the implied warranty of MERCHAN- --\n+-- TABILITY or FITNESS FOR A PARTICULAR PURPOSE.                            --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Declaration of off_t/mmap/munmap. This particular implementation\n+--  supposes off_t is long.\n+\n+with System.OS_Lib;\n+with Interfaces.C;\n+\n+package System.Mmap.Unix is\n+\n+   type Mmap_Prot is new Interfaces.C.int;\n+--     PROT_NONE  : constant Mmap_Prot := 16#00#;\n+--     PROT_EXEC  : constant Mmap_Prot := 16#04#;\n+   PROT_READ  : constant Mmap_Prot := 16#01#;\n+   PROT_WRITE : constant Mmap_Prot := 16#02#;\n+\n+   type Mmap_Flags is new Interfaces.C.int;\n+--     MAP_NONE    : constant Mmap_Flags := 16#00#;\n+--     MAP_FIXED   : constant Mmap_Flags := 16#10#;\n+   MAP_SHARED  : constant Mmap_Flags := 16#01#;\n+   MAP_PRIVATE : constant Mmap_Flags := 16#02#;\n+\n+   type off_t is new Long_Integer;\n+\n+   function Mmap (Start  : Address := Null_Address;\n+                  Length : Interfaces.C.size_t;\n+                  Prot   : Mmap_Prot := PROT_READ;\n+                  Flags  : Mmap_Flags := MAP_PRIVATE;\n+                  Fd     : System.OS_Lib.File_Descriptor;\n+                  Offset : off_t) return Address;\n+   pragma Import (C, Mmap, \"mmap\");\n+\n+   function Munmap (Start  : Address;\n+                    Length : Interfaces.C.size_t) return Integer;\n+   pragma Import (C, Munmap, \"munmap\");\n+\n+   function Is_Mapping_Available return Boolean is (True);\n+   --  Wheter memory mapping is actually available on this system. It is an\n+   --  error to use Create_Mapping and Dispose_Mapping if this is False.\n+end System.Mmap.Unix;"}, {"sha": "0785f3c89f6e173ff99b8cdd6089b8683000759a", "filename": "gcc/ada/s-mmosin-mingw.adb", "status": "added", "additions": 341, "deletions": 0, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fs-mmosin-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fs-mmosin-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mmosin-mingw.adb?ref=ca0eb951e3e6cbee039db654df513d823fa86c78", "patch": "@@ -0,0 +1,341 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--              S Y S T E M . M M A P . O S _ I N T E R F A C E             --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                     Copyright (C) 2007-2016, AdaCore                     --\n+--                                                                          --\n+-- This library is free software;  you can redistribute it and/or modify it --\n+-- under terms of the  GNU General Public License  as published by the Free --\n+-- Software  Foundation;  either version 3,  or (at your  option) any later --\n+-- version. This library is distributed in the hope that it will be useful, --\n+-- but WITHOUT ANY WARRANTY;  without even the implied warranty of MERCHAN- --\n+-- TABILITY or FITNESS FOR A PARTICULAR PURPOSE.                            --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.IO_Exceptions;\n+with System.Strings; use System.Strings;\n+\n+package body System.Mmap.OS_Interface is\n+\n+   use Win;\n+\n+   function Align\n+     (Addr : File_Size) return File_Size;\n+   --  Align some offset/length to the lowest page boundary\n+\n+   function Open_Common\n+     (Filename              : String;\n+      Use_Mmap_If_Available : Boolean;\n+      Write                 : Boolean) return System_File;\n+\n+   function From_UTF8 (Path : String) return Wide_String;\n+   --  Convert from UTF-8 to Wide_String\n+\n+   ---------------\n+   -- From_UTF8 --\n+   ---------------\n+\n+   function From_UTF8 (Path : String) return Wide_String is\n+      function MultiByteToWideChar\n+        (Codepage : Interfaces.C.unsigned;\n+         Flags    : Interfaces.C.unsigned;\n+         Mbstr    : Address;\n+         Mb       : Natural;\n+         Wcstr    : Address;\n+         Wc       : Natural) return Integer;\n+      pragma Import (C, MultiByteToWideChar);\n+\n+      Current_Codepage : Interfaces.C.unsigned;\n+      pragma Import (C, Current_Codepage, \"__gnat_current_codepage\");\n+\n+      Len : Natural;\n+   begin\n+      --  Compute length of the result\n+      Len := MultiByteToWideChar\n+        (Current_Codepage, 0, Path'Address, Path'Length, Null_Address, 0);\n+      if Len = 0 then\n+         raise Constraint_Error;\n+      end if;\n+\n+      declare\n+         --  Declare result\n+         Res : Wide_String (1 .. Len);\n+      begin\n+         --  And compute it\n+         Len := MultiByteToWideChar\n+           (Current_Codepage, 0,\n+            Path'Address, Path'Length,\n+            Res'Address, Len);\n+         if Len = 0 then\n+            raise Constraint_Error;\n+         end if;\n+         return Res;\n+      end;\n+   end From_UTF8;\n+\n+   -----------------\n+   -- Open_Common --\n+   -----------------\n+\n+   function Open_Common\n+     (Filename              : String;\n+      Use_Mmap_If_Available : Boolean;\n+      Write                 : Boolean) return System_File\n+   is\n+      dwDesiredAccess, dwShareMode : DWORD;\n+      PageFlags                    : DWORD;\n+\n+      W_Filename                   : constant Wide_String :=\n+         From_UTF8 (Filename) & Wide_Character'Val (0);\n+      File_Handle, Mapping_Handle  : HANDLE;\n+\n+      SizeH                        : aliased DWORD;\n+      Size                         : File_Size;\n+   begin\n+      if Write then\n+         dwDesiredAccess := GENERIC_READ + GENERIC_WRITE;\n+         dwShareMode     := 0;\n+         PageFlags       := Win.PAGE_READWRITE;\n+      else\n+         dwDesiredAccess := GENERIC_READ;\n+         dwShareMode     := Win.FILE_SHARE_READ;\n+         PageFlags       := Win.PAGE_READONLY;\n+      end if;\n+\n+      --  Actually open the file\n+\n+      File_Handle := CreateFile\n+        (W_Filename'Address, dwDesiredAccess, dwShareMode,\n+         null, OPEN_EXISTING, Win.FILE_ATTRIBUTE_NORMAL, 0);\n+\n+      if File_Handle = Win.INVALID_HANDLE_VALUE then\n+         raise Ada.IO_Exceptions.Name_Error\n+           with \"Cannot open \" & Filename;\n+      end if;\n+\n+      --  Compute its size\n+\n+      Size := File_Size (Win.GetFileSize (File_Handle, SizeH'Access));\n+\n+      if Size = Win.INVALID_FILE_SIZE then\n+         raise Ada.IO_Exceptions.Use_Error;\n+      end if;\n+\n+      if SizeH /= 0 and then File_Size'Size > 32 then\n+         Size := Size + (File_Size (SizeH) * 2 ** 32);\n+      end if;\n+\n+      --  Then create a mapping object, if needed. On Win32, file memory\n+      --  mapping is always available.\n+\n+      if Use_Mmap_If_Available then\n+         Mapping_Handle :=\n+            Win.CreateFileMapping\n+              (File_Handle, null, PageFlags,\n+               0, DWORD (Size), Standard.System.Null_Address);\n+      else\n+         Mapping_Handle := Win.INVALID_HANDLE_VALUE;\n+      end if;\n+\n+      return\n+        (Handle         => File_Handle,\n+         Mapped         => Use_Mmap_If_Available,\n+         Mapping_Handle => Mapping_Handle,\n+         Write          => Write,\n+         Length         => Size);\n+   end Open_Common;\n+\n+   ---------------\n+   -- Open_Read --\n+   ---------------\n+\n+   function Open_Read\n+     (Filename              : String;\n+      Use_Mmap_If_Available : Boolean := True) return System_File is\n+   begin\n+      return Open_Common (Filename, Use_Mmap_If_Available, False);\n+   end Open_Read;\n+\n+   ----------------\n+   -- Open_Write --\n+   ----------------\n+\n+   function Open_Write\n+     (Filename              : String;\n+      Use_Mmap_If_Available : Boolean := True) return System_File is\n+   begin\n+      return Open_Common (Filename, Use_Mmap_If_Available, True);\n+   end Open_Write;\n+\n+   -----------\n+   -- Close --\n+   -----------\n+\n+   procedure Close (File : in out System_File) is\n+      Ignored : BOOL;\n+      pragma Unreferenced (Ignored);\n+   begin\n+      Ignored := CloseHandle (File.Mapping_Handle);\n+      Ignored := CloseHandle (File.Handle);\n+      File.Handle := Win.INVALID_HANDLE_VALUE;\n+      File.Mapping_Handle := Win.INVALID_HANDLE_VALUE;\n+   end Close;\n+\n+   --------------------\n+   -- Read_From_Disk --\n+   --------------------\n+\n+   function Read_From_Disk\n+     (File           : System_File;\n+      Offset, Length : File_Size) return System.Strings.String_Access\n+   is\n+      Buffer : String_Access := new String (1 .. Integer (Length));\n+\n+      Pos    : DWORD;\n+      NbRead : aliased DWORD;\n+      pragma Unreferenced (Pos);\n+   begin\n+      Pos := Win.SetFilePointer\n+        (File.Handle, LONG (Offset), null, Win.FILE_BEGIN);\n+\n+      if Win.ReadFile\n+         (File.Handle, Buffer.all'Address,\n+          DWORD (Length), NbRead'Unchecked_Access, null) = Win.FALSE\n+      then\n+         System.Strings.Free (Buffer);\n+         raise Ada.IO_Exceptions.Device_Error;\n+      end if;\n+      return Buffer;\n+   end Read_From_Disk;\n+\n+   -------------------\n+   -- Write_To_Disk --\n+   -------------------\n+\n+   procedure Write_To_Disk\n+     (File           : System_File;\n+      Offset, Length : File_Size;\n+      Buffer         : System.Strings.String_Access)\n+   is\n+      Pos       : DWORD;\n+      NbWritten : aliased DWORD;\n+      pragma Unreferenced (Pos);\n+   begin\n+      pragma Assert (File.Write);\n+      Pos := Win.SetFilePointer\n+        (File.Handle, LONG (Offset), null, Win.FILE_BEGIN);\n+\n+      if Win.WriteFile\n+         (File.Handle, Buffer.all'Address,\n+          DWORD (Length), NbWritten'Unchecked_Access, null) = Win.FALSE\n+      then\n+         raise Ada.IO_Exceptions.Device_Error;\n+      end if;\n+   end Write_To_Disk;\n+\n+   --------------------\n+   -- Create_Mapping --\n+   --------------------\n+\n+   procedure Create_Mapping\n+     (File           : System_File;\n+      Offset, Length : in out File_Size;\n+      Mutable        : Boolean;\n+      Mapping        : out System_Mapping)\n+   is\n+      Flags : DWORD;\n+   begin\n+      if File.Write then\n+         Flags := Win.FILE_MAP_WRITE;\n+      elsif Mutable then\n+         Flags := Win.FILE_MAP_COPY;\n+      else\n+         Flags := Win.FILE_MAP_READ;\n+      end if;\n+\n+      --  Adjust offset and mapping length to account for the required\n+      --  alignment of offset on page boundary.\n+\n+      declare\n+         Queried_Offset : constant File_Size := Offset;\n+      begin\n+         Offset := Align (Offset);\n+\n+         --  First extend the length to compensate the offset shift, then align\n+         --  it on the upper page boundary, so that the whole queried area is\n+         --  covered.\n+\n+         Length := Length + Queried_Offset - Offset;\n+         Length := Align (Length + Get_Page_Size - 1);\n+\n+         --  But do not exceed the length of the file\n+         if Offset + Length > File.Length then\n+            Length := File.Length - Offset;\n+         end if;\n+      end;\n+\n+      if Length > File_Size (Integer'Last) then\n+         raise Ada.IO_Exceptions.Device_Error;\n+      else\n+         Mapping := Invalid_System_Mapping;\n+         Mapping.Address :=\n+            Win.MapViewOfFile\n+              (File.Mapping_Handle, Flags,\n+               0, DWORD (Offset), SIZE_T (Length));\n+         Mapping.Length := Length;\n+      end if;\n+   end Create_Mapping;\n+\n+   ---------------------\n+   -- Dispose_Mapping --\n+   ---------------------\n+\n+   procedure Dispose_Mapping\n+     (Mapping : in out System_Mapping)\n+   is\n+      Ignored : BOOL;\n+      pragma Unreferenced (Ignored);\n+   begin\n+      Ignored := Win.UnmapViewOfFile (Mapping.Address);\n+      Mapping := Invalid_System_Mapping;\n+   end Dispose_Mapping;\n+\n+   -------------------\n+   -- Get_Page_Size --\n+   -------------------\n+\n+   function Get_Page_Size return File_Size is\n+      SystemInfo : aliased SYSTEM_INFO;\n+   begin\n+      GetSystemInfo (SystemInfo'Unchecked_Access);\n+      return File_Size (SystemInfo.dwAllocationGranularity);\n+   end Get_Page_Size;\n+\n+   -----------\n+   -- Align --\n+   -----------\n+\n+   function Align\n+     (Addr : File_Size) return File_Size is\n+   begin\n+      return Addr - Addr mod Get_Page_Size;\n+   end Align;\n+\n+end System.Mmap.OS_Interface;"}, {"sha": "76874a8fd8f8cf7b374221d2d04bc99d3a6c6812", "filename": "gcc/ada/s-mmosin-mingw.ads", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fs-mmosin-mingw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fs-mmosin-mingw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mmosin-mingw.ads?ref=ca0eb951e3e6cbee039db654df513d823fa86c78", "patch": "@@ -0,0 +1,235 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--              S Y S T E M . M M A P . O S _ I N T E R F A C E             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                     Copyright (C) 2007-2016, AdaCore                     --\n+--                                                                          --\n+-- This library is free software;  you can redistribute it and/or modify it --\n+-- under terms of the  GNU General Public License  as published by the Free --\n+-- Software  Foundation;  either version 3,  or (at your  option) any later --\n+-- version. This library is distributed in the hope that it will be useful, --\n+-- but WITHOUT ANY WARRANTY;  without even the implied warranty of MERCHAN- --\n+-- TABILITY or FITNESS FOR A PARTICULAR PURPOSE.                            --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  OS pecularities abstraction package for Win32 systems.\n+\n+package System.Mmap.OS_Interface is\n+\n+   --  The Win package contains copy of definition found in recent System.Win32\n+   --  unit provided with the GNAT compiler. The copy is needed to be able to\n+   --  compile this unit with older compilers. Note that this internal Win\n+   --  package can be removed when GNAT 6.1.0 is not supported anymore.\n+\n+   package Win is\n+\n+      subtype PVOID is Standard.System.Address;\n+\n+      type HANDLE is new Interfaces.C.ptrdiff_t;\n+\n+      type WORD   is new Interfaces.C.unsigned_short;\n+      type DWORD  is new Interfaces.C.unsigned_long;\n+      type LONG   is new Interfaces.C.long;\n+      type SIZE_T is new Interfaces.C.size_t;\n+\n+      type BOOL   is new Interfaces.C.int;\n+      for BOOL'Size use Interfaces.C.int'Size;\n+\n+      FALSE : constant := 0;\n+\n+      GENERIC_READ  : constant := 16#80000000#;\n+      GENERIC_WRITE : constant := 16#40000000#;\n+      OPEN_EXISTING : constant := 3;\n+\n+      type OVERLAPPED is record\n+         Internal     : DWORD;\n+         InternalHigh : DWORD;\n+         Offset       : DWORD;\n+         OffsetHigh   : DWORD;\n+         hEvent       : HANDLE;\n+      end record;\n+\n+      type SECURITY_ATTRIBUTES is record\n+         nLength             : DWORD;\n+         pSecurityDescriptor : PVOID;\n+         bInheritHandle      : BOOL;\n+      end record;\n+\n+      type SYSTEM_INFO is record\n+         dwOemId : DWORD;\n+         dwPageSize : DWORD;\n+         lpMinimumApplicationAddress : PVOID;\n+         lpMaximumApplicationAddress : PVOID;\n+         dwActiveProcessorMask       : PVOID;\n+         dwNumberOfProcessors        : DWORD;\n+         dwProcessorType             : DWORD;\n+         dwAllocationGranularity     : DWORD;\n+         wProcessorLevel             : WORD;\n+         wProcessorRevision          : WORD;\n+      end record;\n+      type LP_SYSTEM_INFO is access all SYSTEM_INFO;\n+\n+      INVALID_HANDLE_VALUE  : constant HANDLE := -1;\n+      FILE_BEGIN            : constant := 0;\n+      FILE_SHARE_READ       : constant := 16#00000001#;\n+      FILE_ATTRIBUTE_NORMAL : constant := 16#00000080#;\n+      FILE_MAP_COPY         : constant := 1;\n+      FILE_MAP_READ         : constant := 4;\n+      FILE_MAP_WRITE        : constant := 2;\n+      PAGE_READONLY         : constant := 16#0002#;\n+      PAGE_READWRITE        : constant := 16#0004#;\n+      INVALID_FILE_SIZE     : constant := 16#FFFFFFFF#;\n+\n+      function CreateFile\n+        (lpFileName            : Standard.System.Address;\n+         dwDesiredAccess       : DWORD;\n+         dwShareMode           : DWORD;\n+         lpSecurityAttributes  : access SECURITY_ATTRIBUTES;\n+         dwCreationDisposition : DWORD;\n+         dwFlagsAndAttributes  : DWORD;\n+         hTemplateFile         : HANDLE) return HANDLE;\n+      pragma Import (Stdcall, CreateFile, \"CreateFileW\");\n+\n+      function WriteFile\n+        (hFile                  : HANDLE;\n+         lpBuffer               : Standard.System.Address;\n+         nNumberOfBytesToWrite  : DWORD;\n+         lpNumberOfBytesWritten : access DWORD;\n+         lpOverlapped           : access OVERLAPPED) return BOOL;\n+      pragma Import (Stdcall, WriteFile, \"WriteFile\");\n+\n+      function ReadFile\n+        (hFile                : HANDLE;\n+         lpBuffer             : Standard.System.Address;\n+         nNumberOfBytesToRead : DWORD;\n+         lpNumberOfBytesRead  : access DWORD;\n+         lpOverlapped         : access OVERLAPPED) return BOOL;\n+      pragma Import (Stdcall, ReadFile, \"ReadFile\");\n+\n+      function CloseHandle (hObject : HANDLE) return BOOL;\n+      pragma Import (Stdcall, CloseHandle, \"CloseHandle\");\n+\n+      function GetFileSize\n+        (hFile : HANDLE; lpFileSizeHigh : access DWORD) return DWORD;\n+      pragma Import (Stdcall, GetFileSize, \"GetFileSize\");\n+\n+      function SetFilePointer\n+        (hFile                : HANDLE;\n+         lDistanceToMove      : LONG;\n+         lpDistanceToMoveHigh : access LONG;\n+         dwMoveMethod         : DWORD) return DWORD;\n+      pragma Import (Stdcall, SetFilePointer, \"SetFilePointer\");\n+\n+      function CreateFileMapping\n+        (hFile                : HANDLE;\n+         lpSecurityAttributes : access SECURITY_ATTRIBUTES;\n+         flProtect            : DWORD;\n+         dwMaximumSizeHigh    : DWORD;\n+         dwMaximumSizeLow     : DWORD;\n+         lpName               : Standard.System.Address) return HANDLE;\n+      pragma Import (Stdcall, CreateFileMapping, \"CreateFileMappingW\");\n+\n+      function MapViewOfFile\n+        (hFileMappingObject   : HANDLE;\n+         dwDesiredAccess      : DWORD;\n+         dwFileOffsetHigh     : DWORD;\n+         dwFileOffsetLow      : DWORD;\n+         dwNumberOfBytesToMap : SIZE_T) return Standard.System.Address;\n+      pragma Import (Stdcall, MapViewOfFile, \"MapViewOfFile\");\n+\n+      function UnmapViewOfFile\n+         (lpBaseAddress : Standard.System.Address) return BOOL;\n+      pragma Import (Stdcall, UnmapViewOfFile, \"UnmapViewOfFile\");\n+\n+      procedure GetSystemInfo (lpSystemInfo : LP_SYSTEM_INFO);\n+      pragma Import (Stdcall, GetSystemInfo, \"GetSystemInfo\");\n+\n+   end Win;\n+\n+   type System_File is record\n+      Handle         : Win.HANDLE;\n+\n+      Mapped         : Boolean;\n+      --  Whether mapping is requested by the user and available on the system\n+\n+      Mapping_Handle : Win.HANDLE;\n+\n+      Write          : Boolean;\n+      --  Whether this file can be written to\n+\n+      Length         : File_Size;\n+      --  Length of the file. Used to know what can be mapped in the file\n+   end record;\n+\n+   type System_Mapping is record\n+      Address        : Standard.System.Address;\n+      Length         : File_Size;\n+   end record;\n+\n+   Invalid_System_File    : constant System_File :=\n+     (Win.INVALID_HANDLE_VALUE, False, Win.INVALID_HANDLE_VALUE, False, 0);\n+   Invalid_System_Mapping : constant System_Mapping :=\n+     (Standard.System.Null_Address, 0);\n+\n+   function Open_Read\n+     (Filename              : String;\n+      Use_Mmap_If_Available : Boolean := True) return System_File;\n+   --  Open a file for reading and return the corresponding System_File. Raise\n+   --  a Ada.IO_Exceptions.Name_Error if unsuccessful.\n+\n+   function Open_Write\n+     (Filename              : String;\n+      Use_Mmap_If_Available : Boolean := True) return System_File;\n+   --  Likewise for writing to a file\n+\n+   procedure Close (File : in out System_File);\n+   --  Close a system file\n+\n+   function Read_From_Disk\n+     (File           : System_File;\n+      Offset, Length : File_Size) return System.Strings.String_Access;\n+   --  Read a fragment of a file. It is up to the caller to free the result\n+   --  when done with it.\n+\n+   procedure Write_To_Disk\n+     (File           : System_File;\n+      Offset, Length : File_Size;\n+      Buffer         : System.Strings.String_Access);\n+   --  Write some content to a fragment of a file\n+\n+   procedure Create_Mapping\n+     (File           : System_File;\n+      Offset, Length : in out File_Size;\n+      Mutable        : Boolean;\n+      Mapping        : out System_Mapping);\n+   --  Create a memory mapping for the given File, for the area starting at\n+   --  Offset and containing Length bytes. Store it to Mapping.\n+   --  Note that Offset and Length may be modified according to the system\n+   --  needs (for boudaries, for instance). The caller must cope with actually\n+   --  wider mapped areas.\n+\n+   procedure Dispose_Mapping\n+     (Mapping : in out System_Mapping);\n+   --  Unmap a previously-created mapping\n+\n+   function Get_Page_Size return File_Size;\n+   --  Return the number of bytes in a system page.\n+\n+end System.Mmap.OS_Interface;"}, {"sha": "a68c59f395ea31d6f770e045c35bf75f27bd5dfa", "filename": "gcc/ada/s-mmosin-unix.adb", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fs-mmosin-unix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fs-mmosin-unix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mmosin-unix.adb?ref=ca0eb951e3e6cbee039db654df513d823fa86c78", "patch": "@@ -0,0 +1,231 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--              S Y S T E M . M M A P . O S _ I N T E R F A C E             --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                     Copyright (C) 2007-2016, AdaCore                     --\n+--                                                                          --\n+-- This library is free software;  you can redistribute it and/or modify it --\n+-- under terms of the  GNU General Public License  as published by the Free --\n+-- Software  Foundation;  either version 3,  or (at your  option) any later --\n+-- version. This library is distributed in the hope that it will be useful, --\n+-- but WITHOUT ANY WARRANTY;  without even the implied warranty of MERCHAN- --\n+-- TABILITY or FITNESS FOR A PARTICULAR PURPOSE.                            --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.IO_Exceptions;\n+with System; use System;\n+\n+with System.OS_Lib; use System.OS_Lib;\n+with System.Mmap.Unix; use System.Mmap.Unix;\n+\n+package body System.Mmap.OS_Interface is\n+\n+   function Align\n+     (Addr : File_Size) return File_Size;\n+   --  Align some offset/length to the lowest page boundary\n+\n+   function Is_Mapping_Available return Boolean renames\n+     System.Mmap.Unix.Is_Mapping_Available;\n+   --  Wheter memory mapping is actually available on this system. It is an\n+   --  error to use Create_Mapping and Dispose_Mapping if this is False.\n+\n+   ---------------\n+   -- Open_Read --\n+   ---------------\n+\n+   function Open_Read\n+     (Filename              : String;\n+      Use_Mmap_If_Available : Boolean := True) return System_File is\n+      Fd : constant File_Descriptor :=\n+        Open_Read (Filename, Binary);\n+   begin\n+      if Fd = Invalid_FD then\n+         raise Ada.IO_Exceptions.Name_Error\n+           with \"Cannot open \" & Filename;\n+      end if;\n+      return\n+        (Fd     => Fd,\n+         Mapped => Use_Mmap_If_Available and then Is_Mapping_Available,\n+         Write  => False,\n+         Length => File_Size (File_Length (Fd)));\n+   end Open_Read;\n+\n+   ----------------\n+   -- Open_Write --\n+   ----------------\n+\n+   function Open_Write\n+     (Filename              : String;\n+      Use_Mmap_If_Available : Boolean := True) return System_File is\n+      Fd : constant File_Descriptor :=\n+        Open_Read_Write (Filename, Binary);\n+   begin\n+      if Fd = Invalid_FD then\n+         raise Ada.IO_Exceptions.Name_Error\n+         with \"Cannot open \" & Filename;\n+      end if;\n+      return\n+        (Fd     => Fd,\n+         Mapped => Use_Mmap_If_Available and then Is_Mapping_Available,\n+         Write  => True,\n+         Length => File_Size (File_Length (Fd)));\n+   end Open_Write;\n+\n+   -----------\n+   -- Close --\n+   -----------\n+\n+   procedure Close (File : in out System_File) is\n+   begin\n+      Close (File.Fd);\n+      File.Fd := Invalid_FD;\n+   end Close;\n+\n+   --------------------\n+   -- Read_From_Disk --\n+   --------------------\n+\n+   function Read_From_Disk\n+     (File           : System_File;\n+      Offset, Length : File_Size) return System.Strings.String_Access\n+   is\n+      Buffer : String_Access := new String (1 .. Integer (Length));\n+   begin\n+      --  ??? Lseek offset should be a size_t instead of a Long_Integer\n+\n+      Lseek (File.Fd, Long_Integer (Offset), Seek_Set);\n+      if System.OS_Lib.Read (File.Fd, Buffer.all'Address, Integer (Length))\n+        /= Integer (Length)\n+      then\n+         System.Strings.Free (Buffer);\n+         raise Ada.IO_Exceptions.Device_Error;\n+      end if;\n+      return Buffer;\n+   end Read_From_Disk;\n+\n+   -------------------\n+   -- Write_To_Disk --\n+   -------------------\n+\n+   procedure Write_To_Disk\n+     (File           : System_File;\n+      Offset, Length : File_Size;\n+      Buffer         : System.Strings.String_Access) is\n+   begin\n+      pragma Assert (File.Write);\n+      Lseek (File.Fd, Long_Integer (Offset), Seek_Set);\n+      if System.OS_Lib.Write (File.Fd, Buffer.all'Address, Integer (Length))\n+        /= Integer (Length)\n+      then\n+         raise Ada.IO_Exceptions.Device_Error;\n+      end if;\n+   end Write_To_Disk;\n+\n+   --------------------\n+   -- Create_Mapping --\n+   --------------------\n+\n+   procedure Create_Mapping\n+     (File           : System_File;\n+      Offset, Length : in out File_Size;\n+      Mutable        : Boolean;\n+      Mapping        : out System_Mapping)\n+   is\n+      Prot  : Mmap_Prot;\n+      Flags : Mmap_Flags;\n+   begin\n+      if File.Write then\n+         Prot  := PROT_READ + PROT_WRITE;\n+         Flags := MAP_SHARED;\n+      else\n+         Prot := PROT_READ;\n+         if Mutable then\n+            Prot := Prot + PROT_WRITE;\n+         end if;\n+         Flags := MAP_PRIVATE;\n+      end if;\n+\n+      --  Adjust offset and mapping length to account for the required\n+      --  alignment of offset on page boundary.\n+\n+      declare\n+         Queried_Offset : constant File_Size := Offset;\n+      begin\n+         Offset := Align (Offset);\n+\n+         --  First extend the length to compensate the offset shift, then align\n+         --  it on the upper page boundary, so that the whole queried area is\n+         --  covered.\n+\n+         Length := Length + Queried_Offset - Offset;\n+         Length := Align (Length + Get_Page_Size - 1);\n+      end;\n+\n+      if Length > File_Size (Integer'Last) then\n+         raise Ada.IO_Exceptions.Device_Error;\n+      else\n+         Mapping :=\n+           (Address => System.Mmap.Unix.Mmap\n+              (Offset => off_t (Offset),\n+               Length => Interfaces.C.size_t (Length),\n+               Prot   => Prot,\n+               Flags  => Flags,\n+               Fd     => File.Fd),\n+            Length  => Length);\n+      end if;\n+   end Create_Mapping;\n+\n+   ---------------------\n+   -- Dispose_Mapping --\n+   ---------------------\n+\n+   procedure Dispose_Mapping\n+     (Mapping : in out System_Mapping)\n+   is\n+      Ignored : Integer;\n+      pragma Unreferenced (Ignored);\n+   begin\n+      Ignored := Munmap\n+        (Mapping.Address, Interfaces.C.size_t (Mapping.Length));\n+      Mapping := Invalid_System_Mapping;\n+   end Dispose_Mapping;\n+\n+   -------------------\n+   -- Get_Page_Size --\n+   -------------------\n+\n+   function Get_Page_Size return File_Size is\n+      function Internal return Integer;\n+      pragma Import (C, Internal, \"getpagesize\");\n+   begin\n+      return File_Size (Internal);\n+   end Get_Page_Size;\n+\n+   -----------\n+   -- Align --\n+   -----------\n+\n+   function Align\n+     (Addr : File_Size) return File_Size is\n+   begin\n+      return Addr - Addr mod Get_Page_Size;\n+   end Align;\n+\n+end System.Mmap.OS_Interface;"}, {"sha": "01576390b65015b2e3ed70b3415c71b3135a10b5", "filename": "gcc/ada/s-mmosin-unix.ads", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fs-mmosin-unix.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fs-mmosin-unix.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mmosin-unix.ads?ref=ca0eb951e3e6cbee039db654df513d823fa86c78", "patch": "@@ -0,0 +1,105 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--              S Y S T E M . M M A P . O S _ I N T E R F A C E             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                     Copyright (C) 2007-2016, AdaCore                     --\n+--                                                                          --\n+-- This library is free software;  you can redistribute it and/or modify it --\n+-- under terms of the  GNU General Public License  as published by the Free --\n+-- Software  Foundation;  either version 3,  or (at your  option) any later --\n+-- version. This library is distributed in the hope that it will be useful, --\n+-- but WITHOUT ANY WARRANTY;  without even the implied warranty of MERCHAN- --\n+-- TABILITY or FITNESS FOR A PARTICULAR PURPOSE.                            --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.OS_Lib;\n+\n+--  OS pecularities abstraction package for Unix systems.\n+\n+package System.Mmap.OS_Interface is\n+\n+   type System_File is record\n+      Fd     : System.OS_Lib.File_Descriptor;\n+\n+      Mapped : Boolean;\n+      --  Whether mapping is requested by the user and available on the system\n+\n+      Write  : Boolean;\n+      --  Whether this file can be written to\n+\n+      Length : File_Size;\n+      --  Length of the file. Used to know what can be mapped in the file\n+   end record;\n+\n+   type System_Mapping is record\n+      Address : Standard.System.Address;\n+      Length  : File_Size;\n+   end record;\n+\n+   Invalid_System_File    : constant System_File :=\n+     (System.OS_Lib.Invalid_FD, False, False, 0);\n+   Invalid_System_Mapping : constant System_Mapping :=\n+     (Standard.System.Null_Address, 0);\n+\n+   function Open_Read\n+     (Filename              : String;\n+      Use_Mmap_If_Available : Boolean := True) return System_File;\n+   --  Open a file for reading and return the corresponding System_File. Raise\n+   --  a Ada.IO_Exceptions.Name_Error if unsuccessful.\n+\n+   function Open_Write\n+     (Filename              : String;\n+      Use_Mmap_If_Available : Boolean := True) return System_File;\n+   --  Likewise for writing to a file\n+\n+   procedure Close (File : in out System_File);\n+   --  Close a system file\n+\n+   function Read_From_Disk\n+     (File           : System_File;\n+      Offset, Length : File_Size) return System.Strings.String_Access;\n+   --  Read a fragment of a file. It is up to the caller to free the result\n+   --  when done with it.\n+\n+   procedure Write_To_Disk\n+     (File           : System_File;\n+      Offset, Length : File_Size;\n+      Buffer         : System.Strings.String_Access);\n+   --  Write some content to a fragment of a file\n+\n+   procedure Create_Mapping\n+     (File           : System_File;\n+      Offset, Length : in out File_Size;\n+      Mutable        : Boolean;\n+      Mapping        : out System_Mapping);\n+   --  Create a memory mapping for the given File, for the area starting at\n+   --  Offset and containing Length bytes. Store it to Mapping.\n+   --  Note that Offset and Length may be modified according to the system\n+   --  needs (for boudaries, for instance). The caller must cope with actually\n+   --  wider mapped areas.\n+\n+   procedure Dispose_Mapping\n+     (Mapping : in out System_Mapping);\n+   --  Unmap a previously-created mapping\n+\n+   function Get_Page_Size return File_Size;\n+   --  Return the number of bytes in a system page.\n+\n+end System.Mmap.OS_Interface;"}, {"sha": "a88f8486d80db36bd09de50bccc078e640aab623", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=ca0eb951e3e6cbee039db654df513d823fa86c78", "patch": "@@ -59,10 +59,10 @@ with Sem_Res;  use Sem_Res;\n with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n with Sem_Warn; use Sem_Warn;\n+with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stand;    use Stand;\n-with Sinfo;    use Sinfo;\n with Targparm; use Targparm;\n with Ttypes;   use Ttypes;\n with Tbuild;   use Tbuild;\n@@ -1888,7 +1888,7 @@ package body Sem_Ch13 is\n                Set_From_Aspect_Specification (Aitem);\n             end Make_Aitem_Pragma;\n \n-         --  Start of processing for Analyze_Aspect_Specifications\n+         --  Start of processing for Analyze_One_Aspect\n \n          begin\n             --  Skip aspect if already analyzed, to avoid looping in some cases\n@@ -1934,8 +1934,25 @@ package body Sem_Ch13 is\n \n             Set_Analyzed (Aspect);\n             Set_Entity (Aspect, E);\n+\n+            --  Build the reference to E that will be used in the built pragmas\n+\n             Ent := New_Occurrence_Of (E, Sloc (Id));\n \n+            if A_Id = Aspect_Attach_Handler\n+              or else A_Id = Aspect_Interrupt_Handler\n+            then\n+               --  Decorate the reference as comming from the sources and force\n+               --  its reanalysis to generate the reference to E; required to\n+               --  avoid reporting spurious warning on E as unreferenced entity\n+               --  (because aspects are not fully analyzed).\n+\n+               Set_Comes_From_Source (Ent, Comes_From_Source (Id));\n+               Set_Entity (Ent, Empty);\n+\n+               Analyze (Ent);\n+            end if;\n+\n             --  Check for duplicate aspect. Note that the Comes_From_Source\n             --  test allows duplicate Pre/Post's that we generate internally\n             --  to escape being flagged here."}, {"sha": "ec47142644e2e03c6011ad42b1d277dbbd558f8e", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=ca0eb951e3e6cbee039db654df513d823fa86c78", "patch": "@@ -9127,9 +9127,13 @@ package body Sem_Ch3 is\n          end if;\n       end if;\n \n-      --  We similarly inherit predicates\n+      --  We similarly inherit predicates. Note that for scalar derived types\n+      --  the predicate is inherited from the first subtype, and not from its\n+      --  (anonymous) base type.\n \n-      if Has_Predicates (Parent_Type) then\n+      if Has_Predicates (Parent_Type)\n+        or else  Has_Predicates (First_Subtype (Parent_Type))\n+      then\n          Set_Has_Predicates (Derived_Type);\n       end if;\n "}, {"sha": "b3e597f3d09256e311f7f4a76e535bd03bd6947b", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=ca0eb951e3e6cbee039db654df513d823fa86c78", "patch": "@@ -8476,9 +8476,21 @@ package body Sem_Ch6 is\n       elsif Is_Entity_Name (E1) and then Is_Entity_Name (E2) then\n          if Present (Entity (E1)) then\n             return Entity (E1) = Entity (E2)\n+\n+              --  One may be a discriminant that has been replaced by\n+              --  the correspondding discriminal\n+\n               or else (Chars (Entity (E1)) = Chars (Entity (E2))\n                         and then Ekind (Entity (E1)) = E_Discriminant\n-                        and then Ekind (Entity (E2)) = E_In_Parameter);\n+                        and then Ekind (Entity (E2)) = E_In_Parameter)\n+\n+             --  AI12-050 : the loop variables of quantified expressions\n+             --  match if the have the same identifier, even though they\n+             --  are different entities.\n+\n+              or else (Chars (Entity (E1)) = Chars (Entity (E2))\n+                       and then Ekind (Entity (E1)) = E_Loop_Parameter\n+                       and then Ekind (Entity (E2)) = E_Loop_Parameter);\n \n          elsif Nkind (E1) = N_Expanded_Name\n            and then Nkind (E2) = N_Expanded_Name"}, {"sha": "1a81cbfc4497e64e8be9d323f9fffc811168e117", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=ca0eb951e3e6cbee039db654df513d823fa86c78", "patch": "@@ -760,9 +760,6 @@ package body Sem_Ch8 is\n       --  has already established its actual subtype. This is only relevant\n       --  if the renamed object is an explicit dereference.\n \n-      function In_Generic_Scope (E : Entity_Id) return Boolean;\n-      --  Determine whether entity E is inside a generic cope\n-\n       ------------------------------\n       -- Check_Constrained_Object --\n       ------------------------------\n@@ -824,26 +821,6 @@ package body Sem_Ch8 is\n          end if;\n       end Check_Constrained_Object;\n \n-      ----------------------\n-      -- In_Generic_Scope --\n-      ----------------------\n-\n-      function In_Generic_Scope (E : Entity_Id) return Boolean is\n-         S : Entity_Id;\n-\n-      begin\n-         S := Scope (E);\n-         while Present (S) and then S /= Standard_Standard loop\n-            if Is_Generic_Unit (S) then\n-               return True;\n-            end if;\n-\n-            S := Scope (S);\n-         end loop;\n-\n-         return False;\n-      end In_Generic_Scope;\n-\n    --  Start of processing for Analyze_Object_Renaming\n \n    begin"}, {"sha": "531dd70a388dc401432598ae871aac744dad1adf", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=ca0eb951e3e6cbee039db654df513d823fa86c78", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Checks;   use Checks;\n with Debug;    use Debug;\n@@ -4989,7 +4990,13 @@ package body Sem_Eval is\n       then\n          return False;\n \n-      elsif Has_Dynamic_Predicate_Aspect (Typ) then\n+      --  If there is a dynamic predicate for the type (declared or inherited)\n+      --  the expression is not static.\n+\n+      elsif Has_Dynamic_Predicate_Aspect (Typ)\n+        or else (Is_Derived_Type (Typ)\n+                  and then Has_Aspect (Typ, Aspect_Dynamic_Predicate))\n+      then\n          return False;\n \n       --  String types"}, {"sha": "58a157bdd5aea571e5e325f1f62af7225694feab", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=ca0eb951e3e6cbee039db654df513d823fa86c78", "patch": "@@ -10518,6 +10518,26 @@ package body Sem_Util is\n           and then Assertion_Expression_Pragma (Get_Pragma_Id (Prag));\n    end In_Assertion_Expression_Pragma;\n \n+   ----------------------\n+   -- In_Generic_Scope --\n+   ----------------------\n+\n+   function In_Generic_Scope (E : Entity_Id) return Boolean is\n+      S : Entity_Id;\n+\n+   begin\n+      S := Scope (E);\n+      while Present (S) and then S /= Standard_Standard loop\n+         if Is_Generic_Unit (S) then\n+            return True;\n+         end if;\n+\n+         S := Scope (S);\n+      end loop;\n+\n+      return False;\n+   end In_Generic_Scope;\n+\n    -----------------\n    -- In_Instance --\n    -----------------"}, {"sha": "a1e79b1c330b9cb89c9a6e10c99eb4e2799b8f0e", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=ca0eb951e3e6cbee039db654df513d823fa86c78", "patch": "@@ -556,13 +556,11 @@ package Sem_Util is\n    --  Returns the declaration node enclosing N (including possibly N itself),\n    --  if any, or Empty otherwise.\n \n-   function Enclosing_Generic_Body\n-     (N : Node_Id) return Node_Id;\n+   function Enclosing_Generic_Body (N : Node_Id) return Node_Id;\n    --  Returns the Node_Id associated with the innermost enclosing generic\n    --  body, if any. If none, then returns Empty.\n \n-   function Enclosing_Generic_Unit\n-     (N : Node_Id) return Node_Id;\n+   function Enclosing_Generic_Unit (N : Node_Id) return Node_Id;\n    --  Returns the Node_Id associated with the innermost enclosing generic\n    --  unit, if any. If none, then returns Empty.\n \n@@ -1193,6 +1191,9 @@ package Sem_Util is\n    --  Returns True if node N appears within a pragma that acts as an assertion\n    --  expression. See Sem_Prag for the list of qualifying pragmas.\n \n+   function In_Generic_Scope (E : Entity_Id) return Boolean;\n+   --  Returns True if entity E is inside a generic scope\n+\n    function In_Instance return Boolean;\n    --  Returns True if the current scope is within a generic instance\n "}, {"sha": "679c70a77f788eaff32233eb210805858b281342", "filename": "gcc/ada/sysdep.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fsysdep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca0eb951e3e6cbee039db654df513d823fa86c78/gcc%2Fada%2Fsysdep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsysdep.c?ref=ca0eb951e3e6cbee039db654df513d823fa86c78", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *         Copyright (C) 1992-2015, Free Software Foundation, Inc.          *\n+ *         Copyright (C) 1992-2016, Free Software Foundation, Inc.          *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -193,7 +193,7 @@ __gnat_set_mode (int handle, int mode)\n \n  switch (mode) {\n     case 0 : WIN_SETMODE (handle, _O_BINARY);          break;\n-    case 1 : WIN_SETMODE (handle, CurrentCCSEncoding); break;\n+    case 1 : WIN_SETMODE (handle, __gnat_current_ccs_encoding); break;\n     case 2 : WIN_SETMODE (handle, _O_TEXT);            break;\n     case 3 : WIN_SETMODE (handle, _O_U8TEXT);          break;\n     case 4 : WIN_SETMODE (handle, _O_WTEXT);           break;"}]}