{"sha": "13d563f0742f043e94666965709462d1de456048", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTNkNTYzZjA3NDJmMDQzZTk0NjY2OTY1NzA5NDYyZDFkZTQ1NjA0OA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2011-10-10T18:32:07Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2011-10-10T18:32:07Z"}, "message": "simulate-thread.gdb: Call wrappers for *other_threads() and *final_verify().\n\n        * gcc.dg/simulate-thread/simulate-thread.gdb: Call\n        wrappers for *other_threads() and *final_verify().\n        * gcc.dg/simulate-thread/simulate-thread.h\n        (simulate_thread_wrapper_other_threads): New.\n        (simulate_thread_wrapper_final_verify): New.\n\n\nCo-Authored-By: Andrew MacLeod <amacleod@redhat.com>\n\nFrom-SVN: r179768", "tree": {"sha": "fa03215149018aa1220886091f1712884567ee0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa03215149018aa1220886091f1712884567ee0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13d563f0742f043e94666965709462d1de456048", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13d563f0742f043e94666965709462d1de456048", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13d563f0742f043e94666965709462d1de456048", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13d563f0742f043e94666965709462d1de456048/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fa6963330dc6edccda21ca2af39bc40f9fda3094", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa6963330dc6edccda21ca2af39bc40f9fda3094", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa6963330dc6edccda21ca2af39bc40f9fda3094"}], "stats": {"total": 117, "additions": 115, "deletions": 2}, "files": [{"sha": "faa52acc03c55a730c165dbdb4c5e30cc3f88c8e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13d563f0742f043e94666965709462d1de456048/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13d563f0742f043e94666965709462d1de456048/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=13d563f0742f043e94666965709462d1de456048", "patch": "@@ -1,3 +1,12 @@\n+2011-10-10  Aldy Hernandez  <aldyh@redhat.com>\n+\t    Andrew Macleod  <amacleod@redhat.com>\n+\n+\t* gcc.dg/simulate-thread/simulate-thread.gdb: Call\n+\twrappers for *other_threads() and *final_verify().\n+\t* gcc.dg/simulate-thread/simulate-thread.h\n+\t(simulate_thread_wrapper_other_threads): New.\n+\t(simulate_thread_wrapper_final_verify): New.\n+\n 2011-10-10  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* lib/gcc-gdb-test.exp (gdb-test): Delete $cmd_file before return."}, {"sha": "c7bac73f4f4cbe096e44e0a82b77a21f741b00a9", "filename": "gcc/testsuite/gcc.dg/simulate-thread/simulate-thread.gdb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13d563f0742f043e94666965709462d1de456048/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fsimulate-thread.gdb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13d563f0742f043e94666965709462d1de456048/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fsimulate-thread.gdb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fsimulate-thread.gdb?ref=13d563f0742f043e94666965709462d1de456048", "patch": "@@ -5,13 +5,13 @@ run\n \n set $ret = 0\n while (simulate_thread_fini != 1) && (! $ret)\n-  call simulate_thread_other_threads()\n+  call simulate_thread_wrapper_other_threads()\n   stepi\n   set $ret |= simulate_thread_step_verify()\n end\n \n if (! $ret)\n-  set $ret |= simulate_thread_final_verify()\n+  set $ret |= simulate_thread_wrapper_final_verify()\n end\n continue\n quit $ret"}, {"sha": "9e2361faa0623336a7452311de76a93c6b960113", "filename": "gcc/testsuite/gcc.dg/simulate-thread/simulate-thread.h", "status": "modified", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13d563f0742f043e94666965709462d1de456048/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fsimulate-thread.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13d563f0742f043e94666965709462d1de456048/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fsimulate-thread.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsimulate-thread%2Fsimulate-thread.h?ref=13d563f0742f043e94666965709462d1de456048", "patch": "@@ -5,3 +5,107 @@ simulate_thread_done ()\n {\n   simulate_thread_fini = 1;\n }\n+\n+/* A hostile thread is one which changes a memory location so quickly\n+   that another thread may never see the same value again.  This is\n+   simulated when simulate_thread_other_thread() is defined to modify\n+   a memory location every cycle.\n+\n+   A process implementing a dependency on this value can run into\n+   difficulties with such a hostile thread.  For instance,\n+   implementing an add with a compare_and_swap loop goes something\n+   like:\n+\n+     expected = *mem;\n+   loop:\n+     new = expected += value;\n+     if (!succeed (expected = compare_and_swap (mem, expected, new)))\n+       goto loop;\n+\n+   If the content of 'mem' are changed every cycle by\n+   simulate_thread_other_thread () this will become an infinite loop\n+   since the value *mem will never be 'expected' by the time the\n+   compare_and_swap is executed.\n+\n+   HOSTILE_THREAD_THRESHOLD defines the number of intructions which a\n+   program will execute before triggering the hostile thread\n+   pause. The pause will last for HOSTILE_THREAD_PAUSE instructions,\n+   and then the counter will reset and begin again.  During the pause\n+   period, simulate_thread_other_thread will not be called.\n+\n+   This provides a chance for forward progress to be made and the\n+   infinite loop to be avoided.\n+\n+   If the testcase defines HOSTILE_PAUSE_ERROR, then it will be\n+   considered an RUNTIME FAILURE if the hostile pause is triggered.\n+   This will allow to test for guaranteed forward progress routines.\n+\n+   If the default values for HOSTILE_THREAD_THRESHOLD or\n+   HOSTILE_THREAD_PAUSE are insufficient, then the testcase may\n+   override these by defining the values before including this file.\n+\n+   Most testcase are intended to run for very short periods of time,\n+   so these defaults are considered to be high enough to not trigger\n+   on a typical case, but not drag the test time out too much if a\n+   hostile condition is interferring.  */\n+\n+  \n+/* Define the threshold to start pausing the hostile thread.  */\n+#if !defined (HOSTILE_THREAD_THRESHOLD)\n+#define HOSTILE_THREAD_THRESHOLD \t500\n+#endif\n+\n+/* Define the length of pause in cycles for the hostile thread to pause to\n+   allow forward progress to be made.  */\n+#if !defined (HOSTILE_THREAD_PAUSE)\n+#define HOSTILE_THREAD_PAUSE\t20\n+#endif\n+\n+void simulate_thread_other_threads (void);\n+int simulate_thread_final_verify (void);\n+\n+static int simulate_thread_hostile_pause = 0;\n+\n+/* This function wraps simulate_thread_other_threads an monitors for\n+   an infinite loop.  If the threshold value HOSTILE_THREAD_THRESHOLD\n+   is reached, the other_thread process is paused for\n+   HOSTILE_THREAD_PAUSE cycles before resuming, and the counters start\n+   again.  */\n+void\n+simulate_thread_wrapper_other_threads()\n+{\n+  static int count = 0;\n+  static int pause = 0;\n+\n+  if (++count >= HOSTILE_THREAD_THRESHOLD)\n+    {\n+      if (!simulate_thread_hostile_pause)\n+        simulate_thread_hostile_pause = 1;\n+\n+      /* Count cycles before calling the hostile thread again.  */\n+      if (pause++ < HOSTILE_THREAD_PAUSE)\n+\treturn;\n+\n+      /* Reset the pause counter, as well as the thread counter.  */\n+      pause = 0;\n+      count = 0;\n+    }\n+  simulate_thread_other_threads ();\n+}\n+\n+\n+/* If the test case defines HOSTILE_PAUSE_ERROR, then the test case\n+   will fail execution if it had a hostile pause.  */\n+int\n+simulate_thread_wrapper_final_verify ()\n+{\n+  int ret = simulate_thread_final_verify ();\n+#if defined (HOSTILE_PAUSE_ERROR)\n+  if (simulate_thread_hostile_pause)\n+    {\n+      printf (\"FAIL: Forward progress made only by pausing hostile thread\\n\");\n+      ret = ret | 1;    /* 0 indicates proper comnpletion.  */\n+    }\n+#endif\n+  return ret;\n+}"}]}