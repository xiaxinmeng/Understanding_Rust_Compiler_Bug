{"sha": "9975741b27426b78b51adcbe8395c26ae0ad8690", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk3NTc0MWIyNzQyNmI3OGI1MWFkY2JlODM5NWMyNmFlMGFkODY5MA==", "commit": {"author": {"name": "Trevor Saunders", "email": "tbsaunde+gcc@tbsaunde.org", "date": "2015-09-13T16:53:42Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2015-09-13T16:53:42Z"}, "message": "var-tracking.c: remove typedef of location_chain\n\ngcc/ChangeLog:\n\n2015-09-13  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n\n\t* var-tracking.c (struct location_chain): Rename from\n\tlocation_chain_def.\n\t(struct variable_part): Adjust.\n\t(variable_htab_free): Likewise.\n\t(unshare_variable): Likewise.\n\t(get_init_value): Likewise.\n\t(get_addr_from_local_cache): Likewise.\n\t(drop_overlapping_mem_locs): Likewise.\n\t(val_reset): Likewise.\n\t\t\t(struct variable_union_info): Likewise.\n\t\t\t\t\t\t\t\t(variable_union): Likewise.\n\t\t\t\t\t\t\t(find_loc_in_1pdv): Likewise.\n\t\t(insert_into_intersection): Likewise.\n\t\t\t(intersect_loc_chains): Likewise.\n\t\t\t(canonicalize_loc_order_check): Likewise.\n\t(canonicalize_values_mark): Likewise.\n\t(canonicalize_values_star): Likewise.\n\t(canonicalize_vars_star): Likewise.\n\t(variable_merge_over_cur): Likewise.\n\t(remove_duplicate_values): Likewise.\n\t(variable_post_merge_new_vals): Likewise.\n\t(variable_post_merge_perm_vals): Likewise.\n\t(find_mem_expr_in_1pdv): Likewise.\n\t(dataflow_set_preserve_mem_locs): Likewise.\n\t(dataflow_set_remove_mem_locs): Likewise.\n\t(variable_part_different_p): Likewise.\n\t(onepart_variable_different_p): Likewise.\n\t(find_src_set_src): Likewise.\n\t(dump_var): Likewise.\n\t(set_slot_part): Likewise.\n\t(clobber_slot_part): Likewise.\n\t(delete_slot_part): Likewise.\n\t(vt_expand_var_loc_chain): Likewise.\n\t(emit_note_insn_var_location): Likewise.\n\t(vt_finalize): Likewise.\n\nFrom-SVN: r227720", "tree": {"sha": "8e0ec475f5637bce456b8b018df60a6c1f0cd88a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e0ec475f5637bce456b8b018df60a6c1f0cd88a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9975741b27426b78b51adcbe8395c26ae0ad8690", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9975741b27426b78b51adcbe8395c26ae0ad8690", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9975741b27426b78b51adcbe8395c26ae0ad8690", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9975741b27426b78b51adcbe8395c26ae0ad8690/comments", "author": null, "committer": null, "parents": [{"sha": "fd6daec9735879205ee5a3902af19a58dfde0b81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd6daec9735879205ee5a3902af19a58dfde0b81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd6daec9735879205ee5a3902af19a58dfde0b81"}], "stats": {"total": 174, "additions": 106, "deletions": 68}, "files": [{"sha": "37e3f0e6df06687e046d23c23cec6e63a86d91ec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9975741b27426b78b51adcbe8395c26ae0ad8690/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9975741b27426b78b51adcbe8395c26ae0ad8690/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9975741b27426b78b51adcbe8395c26ae0ad8690", "patch": "@@ -1,3 +1,41 @@\n+2015-09-13  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n+\n+\t* var-tracking.c (struct location_chain): Rename from\n+\tlocation_chain_def.\n+\t(struct variable_part): Adjust.\n+\t(variable_htab_free): Likewise.\n+\t(unshare_variable): Likewise.\n+\t(get_init_value): Likewise.\n+\t(get_addr_from_local_cache): Likewise.\n+\t(drop_overlapping_mem_locs): Likewise.\n+\t(val_reset): Likewise.\n+\t\t\t(struct variable_union_info): Likewise.\n+\t\t\t\t\t\t\t\t(variable_union): Likewise.\n+\t\t\t\t\t\t\t(find_loc_in_1pdv): Likewise.\n+\t\t(insert_into_intersection): Likewise.\n+\t\t\t(intersect_loc_chains): Likewise.\n+\t\t\t(canonicalize_loc_order_check): Likewise.\n+\t(canonicalize_values_mark): Likewise.\n+\t(canonicalize_values_star): Likewise.\n+\t(canonicalize_vars_star): Likewise.\n+\t(variable_merge_over_cur): Likewise.\n+\t(remove_duplicate_values): Likewise.\n+\t(variable_post_merge_new_vals): Likewise.\n+\t(variable_post_merge_perm_vals): Likewise.\n+\t(find_mem_expr_in_1pdv): Likewise.\n+\t(dataflow_set_preserve_mem_locs): Likewise.\n+\t(dataflow_set_remove_mem_locs): Likewise.\n+\t(variable_part_different_p): Likewise.\n+\t(onepart_variable_different_p): Likewise.\n+\t(find_src_set_src): Likewise.\n+\t(dump_var): Likewise.\n+\t(set_slot_part): Likewise.\n+\t(clobber_slot_part): Likewise.\n+\t(delete_slot_part): Likewise.\n+\t(vt_expand_var_loc_chain): Likewise.\n+\t(emit_note_insn_var_location): Likewise.\n+\t(vt_finalize): Likewise.\n+\n 2015-09-13  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n \n \t* dse.c (store_info_t): Remove typedef."}, {"sha": "5a53a4a40591c8fd154eaf34099b47b2bb5ab752", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9975741b27426b78b51adcbe8395c26ae0ad8690/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9975741b27426b78b51adcbe8395c26ae0ad8690/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=9975741b27426b78b51adcbe8395c26ae0ad8690", "patch": "@@ -264,10 +264,10 @@ typedef struct attrs_def\n } *attrs;\n \n /* Structure for chaining the locations.  */\n-typedef struct location_chain_def\n+struct location_chain\n {\n   /* Next element in the chain.  */\n-  struct location_chain_def *next;\n+  location_chain *next;\n \n   /* The location (REG, MEM or VALUE).  */\n   rtx loc;\n@@ -277,7 +277,7 @@ typedef struct location_chain_def\n \n   /* Initialized? */\n   enum var_init_status init;\n-} *location_chain;\n+};\n \n /* A vector of loc_exp_dep holds the active dependencies of a one-part\n    DV on VALUEs, i.e., the VALUEs expanded so as to form the current\n@@ -337,7 +337,7 @@ struct onepart_aux\n struct variable_part\n {\n   /* Chain of locations of the part.  */\n-  location_chain loc_chain;\n+  location_chain *loc_chain;\n \n   /* Location which was last emitted to location list.  */\n   rtx cur_loc;\n@@ -589,8 +589,8 @@ static pool_allocator valvar_pool\n   (\"small variable_def pool\", 256, sizeof (variable_def));\n \n /* Alloc pool for struct location_chain_def.  */\n-static object_allocator<location_chain_def> location_chain_def_pool\n-  (\"location_chain_def pool\", 1024);\n+static object_allocator<location_chain> location_chain_pool\n+  (\"location_chain pool\", 1024);\n \n /* Alloc pool for struct shared_hash_def.  */\n static object_allocator<shared_hash_def> shared_hash_def_pool\n@@ -663,7 +663,7 @@ static void dataflow_set_clear (dataflow_set *);\n static void dataflow_set_copy (dataflow_set *, dataflow_set *);\n static int variable_union_info_cmp_pos (const void *, const void *);\n static void dataflow_set_union (dataflow_set *, dataflow_set *);\n-static location_chain find_loc_in_1pdv (rtx, variable, variable_table_type *);\n+static location_chain *find_loc_in_1pdv (rtx, variable, variable_table_type *);\n static bool canon_value_cmp (rtx, rtx);\n static int loc_cmp (rtx, rtx);\n static bool variable_part_different_p (variable_part *, variable_part *);\n@@ -1435,7 +1435,7 @@ variable_htab_free (void *elem)\n {\n   int i;\n   variable var = (variable) elem;\n-  location_chain node, next;\n+  location_chain *node, *next;\n \n   gcc_checking_assert (var->refcount > 0);\n \n@@ -1738,8 +1738,8 @@ unshare_variable (dataflow_set *set, variable_def **slot, variable var,\n \n   for (i = 0; i < var->n_var_parts; i++)\n     {\n-      location_chain node;\n-      location_chain *nextp;\n+      location_chain *node;\n+      location_chain **nextp;\n \n       if (i == 0 && var->onepart)\n \t{\n@@ -1756,9 +1756,9 @@ unshare_variable (dataflow_set *set, variable_def **slot, variable var,\n       nextp = &new_var->var_part[i].loc_chain;\n       for (node = var->var_part[i].loc_chain; node; node = node->next)\n \t{\n-\t  location_chain new_lc;\n+\t  location_chain *new_lc;\n \n-\t  new_lc = new location_chain_def;\n+\t  new_lc = new location_chain;\n \t  new_lc->next = NULL;\n \t  if (node->init > initialized)\n \t    new_lc->init = node->init;\n@@ -1882,7 +1882,7 @@ get_init_value (dataflow_set *set, rtx loc, decl_or_value dv)\n     {\n       for (i = 0; i < var->n_var_parts && ret_val == VAR_INIT_STATUS_UNKNOWN; i++)\n \t{\n-\t  location_chain nextp;\n+\t  location_chain *nextp;\n \t  for (nextp = var->var_part[i].loc_chain; nextp; nextp = nextp->next)\n \t    if (rtx_equal_p (nextp->loc, loc))\n \t      {\n@@ -2069,7 +2069,7 @@ get_addr_from_local_cache (dataflow_set *set, rtx const loc)\n   rtx x;\n   decl_or_value dv;\n   variable var;\n-  location_chain l;\n+  location_chain *l;\n \n   gcc_checking_assert (GET_CODE (loc) == VALUE);\n \n@@ -2246,7 +2246,7 @@ drop_overlapping_mem_locs (variable_def **slot, overlapping_mems *coms)\n \n   if (var->onepart == ONEPART_VALUE)\n     {\n-      location_chain loc, *locp;\n+      location_chain *loc, **locp;\n       bool changed = false;\n       rtx cur_loc;\n \n@@ -2514,7 +2514,7 @@ static void\n val_reset (dataflow_set *set, decl_or_value dv)\n {\n   variable var = shared_hash_find (set->vars, dv) ;\n-  location_chain node;\n+  location_chain *node;\n   rtx cval;\n \n   if (!var || !var->n_var_parts)\n@@ -2695,7 +2695,7 @@ dataflow_set_copy (dataflow_set *dst, dataflow_set *src)\n struct variable_union_info\n {\n   /* Node of the location chain.  */\n-  location_chain lc;\n+  location_chain *lc;\n \n   /* The sum of positions in the input chains.  */\n   int pos;\n@@ -2765,7 +2765,7 @@ variable_union (variable src, dataflow_set *set)\n      entries are in canonical order.  */\n   if (src->onepart)\n     {\n-      location_chain *nodep, dnode, snode;\n+      location_chain **nodep, *dnode, *snode;\n \n       gcc_assert (src->n_var_parts == 1\n \t\t  && dst->n_var_parts == 1);\n@@ -2784,7 +2784,7 @@ variable_union (variable src, dataflow_set *set)\n \n \t  if (r > 0)\n \t    {\n-\t      location_chain nnode;\n+\t      location_chain *nnode;\n \n \t      if (shared_var_p (dst, set->vars))\n \t\t{\n@@ -2794,7 +2794,7 @@ variable_union (variable src, dataflow_set *set)\n \t\t  goto restart_onepart_unshared;\n \t\t}\n \n-\t      *nodep = nnode = new location_chain_def;\n+\t      *nodep = nnode = new location_chain;\n \t      nnode->loc = snode->loc;\n \t      nnode->init = snode->init;\n \t      if (!snode->set_src || MEM_P (snode->set_src))\n@@ -2852,7 +2852,7 @@ variable_union (variable src, dataflow_set *set)\n \n   for (k--; k >= 0; k--)\n     {\n-      location_chain node, node2;\n+      location_chain *node, *node2;\n \n       if (i >= 0 && j >= 0\n \t  && VAR_PART_OFFSET (src, i) == VAR_PART_OFFSET (dst, j))\n@@ -2901,7 +2901,7 @@ variable_union (variable src, dataflow_set *set)\n \t  if (dst_l == 1)\n \t    {\n \t      /* The most common case, much simpler, no qsort is needed.  */\n-\t      location_chain dstnode = dst->var_part[j].loc_chain;\n+\t      location_chain *dstnode = dst->var_part[j].loc_chain;\n \t      dst->var_part[k].loc_chain = dstnode;\n \t      VAR_PART_OFFSET (dst, k) = VAR_PART_OFFSET (dst, j);\n \t      node2 = dstnode;\n@@ -2911,10 +2911,10 @@ variable_union (variable src, dataflow_set *set)\n \t\t       && REGNO (dstnode->loc) == REGNO (node->loc))\n \t\t      || rtx_equal_p (dstnode->loc, node->loc)))\n \t\t  {\n-\t\t    location_chain new_node;\n+\t\t    location_chain *new_node;\n \n \t\t    /* Copy the location from SRC.  */\n-\t\t    new_node = new location_chain_def;\n+\t\t    new_node = new location_chain;\n \t\t    new_node->loc = node->loc;\n \t\t    new_node->init = node->init;\n \t\t    if (!node->set_src || MEM_P (node->set_src))\n@@ -2966,10 +2966,10 @@ variable_union (variable src, dataflow_set *set)\n \t\t    }\n \t\t  if (jj >= dst_l)\t/* The location has not been found.  */\n \t\t    {\n-\t\t      location_chain new_node;\n+\t\t      location_chain *new_node;\n \n \t\t      /* Copy the location from SRC.  */\n-\t\t      new_node = new location_chain_def;\n+\t\t      new_node = new location_chain;\n \t\t      new_node->loc = node->loc;\n \t\t      new_node->init = node->init;\n \t\t      if (!node->set_src || MEM_P (node->set_src))\n@@ -3057,15 +3057,15 @@ variable_union (variable src, dataflow_set *set)\n \t\t&& VAR_PART_OFFSET (src, i) > VAR_PART_OFFSET (dst, j))\n \t       || j < 0)\n \t{\n-\t  location_chain *nextp;\n+\t  location_chain **nextp;\n \n \t  /* Copy the chain from SRC.  */\n \t  nextp = &dst->var_part[k].loc_chain;\n \t  for (node = src->var_part[i].loc_chain; node; node = node->next)\n \t    {\n-\t      location_chain new_lc;\n+\t      location_chain *new_lc;\n \n-\t      new_lc = new location_chain_def;\n+\t      new_lc = new location_chain;\n \t      new_lc->next = NULL;\n \t      new_lc->init = node->init;\n \t      if (!node->set_src || MEM_P (node->set_src))\n@@ -3087,7 +3087,7 @@ variable_union (variable src, dataflow_set *set)\n   if (flag_var_tracking_uninit)\n     for (i = 0; i < src->n_var_parts && i < dst->n_var_parts; i++)\n       {\n-\tlocation_chain node, node2;\n+\tlocation_chain *node, *node2;\n \tfor (node = src->var_part[i].loc_chain; node; node = node->next)\n \t  for (node2 = dst->var_part[i].loc_chain; node2; node2 = node2->next)\n \t    if (rtx_equal_p (node->loc, node2->loc))\n@@ -3184,10 +3184,10 @@ dv_changed_p (decl_or_value dv)\n    any values recursively mentioned in the location lists.  VARS must\n    be in star-canonical form.  */\n \n-static location_chain\n+static location_chain *\n find_loc_in_1pdv (rtx loc, variable var, variable_table_type *vars)\n {\n-  location_chain node;\n+  location_chain *node;\n   enum rtx_code loc_code;\n \n   if (!var)\n@@ -3268,10 +3268,10 @@ struct dfset_merge\n    loc_cmp order, and it is maintained as such.  */\n \n static void\n-insert_into_intersection (location_chain *nodep, rtx loc,\n+insert_into_intersection (location_chain **nodep, rtx loc,\n \t\t\t  enum var_init_status status)\n {\n-  location_chain node;\n+  location_chain *node;\n   int r;\n \n   for (node = *nodep; node; nodep = &node->next, node = *nodep)\n@@ -3283,7 +3283,7 @@ insert_into_intersection (location_chain *nodep, rtx loc,\n     else if (r > 0)\n       break;\n \n-  node = new location_chain_def;\n+  node = new location_chain;\n \n   node->loc = loc;\n   node->set_src = NULL;\n@@ -3298,16 +3298,16 @@ insert_into_intersection (location_chain *nodep, rtx loc,\n    DSM->dst.  */\n \n static void\n-intersect_loc_chains (rtx val, location_chain *dest, struct dfset_merge *dsm,\n-\t\t      location_chain s1node, variable s2var)\n+intersect_loc_chains (rtx val, location_chain **dest, struct dfset_merge *dsm,\n+\t\t      location_chain *s1node, variable s2var)\n {\n   dataflow_set *s1set = dsm->cur;\n   dataflow_set *s2set = dsm->src;\n-  location_chain found;\n+  location_chain *found;\n \n   if (s2var)\n     {\n-      location_chain s2node;\n+      location_chain *s2node;\n \n       gcc_checking_assert (s2var->onepart);\n \n@@ -3580,7 +3580,7 @@ canonicalize_loc_order_check (variable_def **slot,\n \t\t\t      dataflow_set *data ATTRIBUTE_UNUSED)\n {\n   variable var = *slot;\n-  location_chain node, next;\n+  location_chain *node, *next;\n \n #ifdef ENABLE_RTL_CHECKING\n   int i;\n@@ -3617,7 +3617,7 @@ canonicalize_values_mark (variable_def **slot, dataflow_set *set)\n   variable var = *slot;\n   decl_or_value dv = var->dv;\n   rtx val;\n-  location_chain node;\n+  location_chain *node;\n \n   if (!dv_is_value_p (dv))\n     return 1;\n@@ -3655,7 +3655,7 @@ canonicalize_values_star (variable_def **slot, dataflow_set *set)\n {\n   variable var = *slot;\n   decl_or_value dv = var->dv;\n-  location_chain node;\n+  location_chain *node;\n   decl_or_value cdv;\n   rtx val, cval;\n   variable_def **cslot;\n@@ -3876,12 +3876,12 @@ canonicalize_vars_star (variable_def **slot, dataflow_set *set)\n {\n   variable var = *slot;\n   decl_or_value dv = var->dv;\n-  location_chain node;\n+  location_chain *node;\n   rtx cval;\n   decl_or_value cdv;\n   variable_def **cslot;\n   variable cvar;\n-  location_chain cnode;\n+  location_chain *cnode;\n \n   if (!var->onepart || var->onepart == ONEPART_VALUE)\n     return 1;\n@@ -3939,7 +3939,7 @@ variable_merge_over_cur (variable s1var, struct dfset_merge *dsm)\n   onepart_enum_t onepart = s1var->onepart;\n   rtx val;\n   hashval_t dvhash;\n-  location_chain node, *nodep;\n+  location_chain *node, **nodep;\n \n   /* If the incoming onepart variable has an empty location list, then\n      the intersection will be just as empty.  For other variables,\n@@ -4030,7 +4030,7 @@ variable_merge_over_cur (variable s1var, struct dfset_merge *dsm)\n   nodep = &dvar->var_part[0].loc_chain;\n   while ((node = *nodep))\n     {\n-      location_chain *nextp = &node->next;\n+      location_chain **nextp = &node->next;\n \n       if (GET_CODE (node->loc) == REG)\n \t{\n@@ -4338,7 +4338,7 @@ dataflow_set_equiv_regs (dataflow_set *set)\n static void\n remove_duplicate_values (variable var)\n {\n-  location_chain node, *nodep;\n+  location_chain *node, **nodep;\n \n   gcc_assert (var->onepart);\n   gcc_assert (var->n_var_parts == 1);\n@@ -4388,7 +4388,7 @@ variable_post_merge_new_vals (variable_def **slot, dfset_post_merge *dfpm)\n {\n   dataflow_set *set = dfpm->set;\n   variable var = *slot;\n-  location_chain node;\n+  location_chain *node;\n \n   if (!var->onepart || !var->n_var_parts)\n     return 1;\n@@ -4524,7 +4524,7 @@ variable_post_merge_perm_vals (variable_def **pslot, dfset_post_merge *dfpm)\n {\n   dataflow_set *set = dfpm->set;\n   variable pvar = *pslot, var;\n-  location_chain pnode;\n+  location_chain *pnode;\n   decl_or_value dv;\n   attrs att;\n \n@@ -4602,13 +4602,13 @@ dataflow_post_merge_adjust (dataflow_set *set, dataflow_set **permp)\n    location list of a one-part variable or value VAR, or in that of\n    any values recursively mentioned in the location lists.  */\n \n-static location_chain\n+static location_chain *\n find_mem_expr_in_1pdv (tree expr, rtx val, variable_table_type *vars)\n {\n-  location_chain node;\n+  location_chain *node;\n   decl_or_value dv;\n   variable var;\n-  location_chain where = NULL;\n+  location_chain *where = NULL;\n \n   if (!val)\n     return NULL;\n@@ -4682,7 +4682,7 @@ dataflow_set_preserve_mem_locs (variable_def **slot, dataflow_set *set)\n   if (var->onepart == ONEPART_VDECL || var->onepart == ONEPART_DEXPR)\n     {\n       tree decl = dv_as_decl (var->dv);\n-      location_chain loc, *locp;\n+      location_chain *loc, **locp;\n       bool changed = false;\n \n       if (!var->n_var_parts)\n@@ -4721,7 +4721,7 @@ dataflow_set_preserve_mem_locs (variable_def **slot, dataflow_set *set)\n \t  rtx old_loc = loc->loc;\n \t  if (GET_CODE (old_loc) == VALUE)\n \t    {\n-\t      location_chain mem_node\n+\t      location_chain *mem_node\n \t\t= find_mem_expr_in_1pdv (decl, loc->loc,\n \t\t\t\t\t shared_hash_htab (set->vars));\n \n@@ -4790,7 +4790,7 @@ dataflow_set_remove_mem_locs (variable_def **slot, dataflow_set *set)\n \n   if (var->onepart == ONEPART_VALUE)\n     {\n-      location_chain loc, *locp;\n+      location_chain *loc, **locp;\n       bool changed = false;\n       rtx cur_loc;\n \n@@ -4883,7 +4883,7 @@ dataflow_set_clear_at_call (dataflow_set *set, rtx_insn *call_insn)\n static bool\n variable_part_different_p (variable_part *vp1, variable_part *vp2)\n {\n-  location_chain lc1, lc2;\n+  location_chain *lc1, *lc2;\n \n   for (lc1 = vp1->loc_chain; lc1; lc1 = lc1->next)\n     {\n@@ -4909,7 +4909,7 @@ variable_part_different_p (variable_part *vp1, variable_part *vp2)\n static bool\n onepart_variable_different_p (variable var1, variable var2)\n {\n-  location_chain lc1, lc2;\n+  location_chain *lc1, *lc2;\n \n   if (var1 == var2)\n     return false;\n@@ -6591,7 +6591,7 @@ find_src_set_src (dataflow_set *set, rtx src)\n   tree decl = NULL_TREE;   /* The variable being copied around.          */\n   rtx set_src = NULL_RTX;  /* The value for \"decl\" stored in \"src\".      */\n   variable var;\n-  location_chain nextp;\n+  location_chain *nextp;\n   int i;\n   bool found;\n \n@@ -7179,7 +7179,7 @@ static void\n dump_var (variable var)\n {\n   int i;\n-  location_chain node;\n+  location_chain *node;\n \n   if (dv_is_decl_p (var->dv))\n     {\n@@ -7499,8 +7499,8 @@ set_slot_part (dataflow_set *set, rtx loc, variable_def **slot,\n \t       enum var_init_status initialized, rtx set_src)\n {\n   int pos;\n-  location_chain node, next;\n-  location_chain *nextp;\n+  location_chain *node, *next;\n+  location_chain **nextp;\n   variable var;\n   onepart_enum_t onepart;\n \n@@ -7727,7 +7727,7 @@ set_slot_part (dataflow_set *set, rtx loc, variable_def **slot,\n     }\n \n   /* Add the location to the beginning.  */\n-  node = new location_chain_def;\n+  node = new location_chain;\n   node->loc = loc;\n   node->init = initialized;\n   node->set_src = set_src;\n@@ -7780,7 +7780,7 @@ clobber_slot_part (dataflow_set *set, rtx loc, variable_def **slot,\n \n   if (pos >= 0)\n     {\n-      location_chain node, next;\n+      location_chain *node, *next;\n \n       /* Remove the register locations from the dataflow set.  */\n       next = var->var_part[pos].loc_chain;\n@@ -7860,8 +7860,8 @@ delete_slot_part (dataflow_set *set, rtx loc, variable_def **slot,\n \n   if (pos >= 0)\n     {\n-      location_chain node, next;\n-      location_chain *nextp;\n+      location_chain *node, *next;\n+      location_chain **nextp;\n       bool changed;\n       rtx cur_loc;\n \n@@ -8220,7 +8220,7 @@ vt_expand_var_loc_chain (variable var, bitmap regs, void *data, bool *pendrecp)\n {\n   struct expand_loc_callback_data *elcd\n     = (struct expand_loc_callback_data *) data;\n-  location_chain loc, next;\n+  location_chain *loc, *next;\n   rtx result = NULL;\n   int first_child, result_first_child, last_child;\n   bool pending_recursion;\n@@ -8577,7 +8577,7 @@ emit_note_insn_var_location (variable_def **varp, emit_note_data *data)\n   HOST_WIDE_INT offsets[MAX_VAR_PARTS];\n   rtx loc[MAX_VAR_PARTS];\n   tree decl;\n-  location_chain lc;\n+  location_chain *lc;\n \n   gcc_checking_assert (var->onepart == NOT_ONEPART\n \t\t       || var->onepart == ONEPART_VDECL);\n@@ -10219,7 +10219,7 @@ vt_finalize (void)\n   changed_variables = NULL;\n   attrs_def_pool.release ();\n   var_pool.release ();\n-  location_chain_def_pool.release ();\n+  location_chain_pool.release ();\n   shared_hash_def_pool.release ();\n \n   if (MAY_HAVE_DEBUG_INSNS)"}]}