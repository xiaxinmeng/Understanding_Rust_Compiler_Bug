{"sha": "2f928c1b63e67155f4b3c194e3a9cc53fb6fb107", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY5MjhjMWI2M2U2NzE1NWY0YjNjMTk0ZTNhOWNjNTNmYjZmYjEwNw==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-06-20T08:52:35Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-06-20T08:52:35Z"}, "message": "Enable clustering for switch statements.\n\n2018-06-20  Martin Liska  <mliska@suse.cz>\n\n\t* tree-switch-conversion.c (jump_table_cluster::find_jump_tables):\n        New.\n\t(bit_test_cluster::find_bit_tests): Likewise.\n\t(switch_decision_tree::analyze_switch_statement): Find clusters.\n\t* tree-switch-conversion.h (struct jump_table_cluster): Document\n        hierarchy.\n\nFrom-SVN: r261794", "tree": {"sha": "3ee984a0b04610c608331e71554ad3b54cb70c9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ee984a0b04610c608331e71554ad3b54cb70c9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f928c1b63e67155f4b3c194e3a9cc53fb6fb107", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f928c1b63e67155f4b3c194e3a9cc53fb6fb107", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f928c1b63e67155f4b3c194e3a9cc53fb6fb107", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f928c1b63e67155f4b3c194e3a9cc53fb6fb107/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dc223ad48971b2d2b1e4bcfbbb47a96354e3d2ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc223ad48971b2d2b1e4bcfbbb47a96354e3d2ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc223ad48971b2d2b1e4bcfbbb47a96354e3d2ea"}], "stats": {"total": 204, "additions": 184, "deletions": 20}, "files": [{"sha": "4106e0415980607af63b389426aea0a3d5c4fa89", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f928c1b63e67155f4b3c194e3a9cc53fb6fb107/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f928c1b63e67155f4b3c194e3a9cc53fb6fb107/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f928c1b63e67155f4b3c194e3a9cc53fb6fb107", "patch": "@@ -1,3 +1,12 @@\n+2018-06-20  Martin Liska  <mliska@suse.cz>\n+\n+\t* tree-switch-conversion.c (jump_table_cluster::find_jump_tables):\n+        New.\n+\t(bit_test_cluster::find_bit_tests): Likewise.\n+\t(switch_decision_tree::analyze_switch_statement): Find clusters.\n+\t* tree-switch-conversion.h (struct jump_table_cluster): Document\n+        hierarchy.\n+\n 2018-06-20  Martin Liska  <mliska@suse.cz>\n \n \t* tree-switch-conversion.c (switch_conversion::collect):"}, {"sha": "a438960f8bfc3eb697789753939c009d51cec078", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 157, "deletions": 19, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f928c1b63e67155f4b3c194e3a9cc53fb6fb107/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f928c1b63e67155f4b3c194e3a9cc53fb6fb107/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=2f928c1b63e67155f4b3c194e3a9cc53fb6fb107", "patch": "@@ -1088,6 +1088,67 @@ jump_table_cluster::emit (tree index_expr, tree,\n   gsi_insert_after (&gsi, s, GSI_NEW_STMT);\n }\n \n+/* Find jump tables of given CLUSTERS, where all members of the vector\n+   are of type simple_cluster.  New clusters are returned.  */\n+\n+vec<cluster *>\n+jump_table_cluster::find_jump_tables (vec<cluster *> &clusters)\n+{\n+  unsigned l = clusters.length ();\n+  auto_vec<min_cluster_item> min;\n+  min.reserve (l + 1);\n+\n+  min.quick_push (min_cluster_item (0, 0, 0));\n+\n+  for (unsigned i = 1; i <= l; i++)\n+    {\n+      /* Set minimal # of clusters with i-th item to infinite.  */\n+      min.quick_push (min_cluster_item (INT_MAX, INT_MAX, INT_MAX));\n+\n+      for (unsigned j = 0; j < i; j++)\n+\t{\n+\t  unsigned HOST_WIDE_INT s = min[j].m_non_jt_cases;\n+\t  if (i - j < case_values_threshold ())\n+\t    s += i - j;\n+\n+\t  /* Prefer clusters with smaller number of numbers covered.  */\n+\t  if ((min[j].m_count + 1 < min[i].m_count\n+\t       || (min[j].m_count + 1 == min[i].m_count\n+\t\t   && s < min[i].m_non_jt_cases))\n+\t      && can_be_handled (clusters, j, i - 1))\n+\t    min[i] = min_cluster_item (min[j].m_count + 1, j, s);\n+\t}\n+    }\n+\n+  /* No result.  */\n+  if (min[l].m_count == INT_MAX)\n+    return clusters.copy ();\n+\n+  vec<cluster *> output;\n+  output.create (4);\n+\n+  /* Find and build the clusters.  */\n+  for (int end = l;;)\n+    {\n+      int start = min[end].m_start;\n+\n+      /* Do not allow clusters with small number of cases.  */\n+      if (is_beneficial (clusters, start, end - 1))\n+\toutput.safe_push (new jump_table_cluster (clusters, start, end - 1));\n+      else\n+\tfor (int i = end - 1; i >= start; i--)\n+\t  output.safe_push (clusters[i]);\n+\n+      end = start;\n+\n+      if (start <= 0)\n+\tbreak;\n+    }\n+\n+  output.reverse ();\n+  return output;\n+}\n+\n /* Return true when cluster starting at START and ending at END (inclusive)\n    can build a jump-table.  */\n \n@@ -1142,6 +1203,59 @@ jump_table_cluster::is_beneficial (const vec<cluster *> &,\n   return end - start + 1 >= case_values_threshold ();\n }\n \n+/* Find bit tests of given CLUSTERS, where all members of the vector\n+   are of type simple_cluster.  New clusters are returned.  */\n+\n+vec<cluster *>\n+bit_test_cluster::find_bit_tests (vec<cluster *> &clusters)\n+{\n+  vec<cluster *> output;\n+  output.create (4);\n+\n+  unsigned l = clusters.length ();\n+  auto_vec<min_cluster_item> min;\n+  min.reserve (l + 1);\n+\n+  min.quick_push (min_cluster_item (0, 0, 0));\n+\n+  for (unsigned i = 1; i <= l; i++)\n+    {\n+      /* Set minimal # of clusters with i-th item to infinite.  */\n+      min.quick_push (min_cluster_item (INT_MAX, INT_MAX, INT_MAX));\n+\n+      for (unsigned j = 0; j < i; j++)\n+\t{\n+\t  if (min[j].m_count + 1 < min[i].m_count\n+\t      && can_be_handled (clusters, j, i - 1))\n+\t    min[i] = min_cluster_item (min[j].m_count + 1, j, INT_MAX);\n+\t}\n+    }\n+\n+  /* No result.  */\n+  if (min[l].m_count == INT_MAX)\n+    return clusters.copy ();\n+\n+  /* Find and build the clusters.  */\n+  for (int end = l;;)\n+    {\n+      int start = min[end].m_start;\n+\n+      if (is_beneficial (clusters, start, end - 1))\n+\toutput.safe_push (new bit_test_cluster (clusters, start, end - 1));\n+      else\n+\tfor (int i = end - 1; i >=  start; i--)\n+\t  output.safe_push (clusters[i]);\n+\n+      end = start;\n+\n+      if (start <= 0)\n+\tbreak;\n+    }\n+\n+  output.reverse ();\n+  return output;\n+}\n+\n /* Return true when RANGE of case values with UNIQ labels\n    can build a bit test.  */\n \n@@ -1485,33 +1599,57 @@ switch_decision_tree::analyze_switch_statement ()\n \n   reset_out_edges_aux ();\n \n-  vec<cluster *> output;\n-  output.create (1);\n-\n-  /* Find whether the switch statement can be expanded with a method\n-     different from decision tree.  */\n-  unsigned end = clusters.length () - 1;\n-  if (jump_table_cluster::can_be_handled (clusters, 0, end)\n-      && jump_table_cluster::is_beneficial (clusters, 0, end))\n-    output.safe_push (new jump_table_cluster (clusters, 0, end));\n-  else if (bit_test_cluster::can_be_handled (clusters, 0, end)\n-\t   && bit_test_cluster::is_beneficial (clusters, 0, end))\n-    output.safe_push (new bit_test_cluster (clusters, 0, end));\n-  else\n-    output = clusters;\n+  /* Find jump table clusters.  */\n+  vec<cluster *> output = jump_table_cluster::find_jump_tables (clusters);\n+\n+  /* Find jump table clusters.  */\n+  vec<cluster *> output2;\n+  auto_vec<cluster *> tmp;\n+  output2.create (1);\n+  tmp.create (1);\n+\n+  for (unsigned i = 0; i < output.length (); i++)\n+    {\n+      cluster *c = output[i];\n+      if (c->get_type () != SIMPLE_CASE)\n+\t{\n+\t  if (!tmp.is_empty ())\n+\t    {\n+\t      vec<cluster *> n = bit_test_cluster::find_bit_tests (tmp);\n+\t      output2.safe_splice (n);\n+\t      n.release ();\n+\t      tmp.truncate (0);\n+\t    }\n+\t  output2.safe_push (c);\n+\t}\n+      else\n+\ttmp.safe_push (c);\n+    }\n+\n+  /* We still can have a temporary vector to test.  */\n+  if (!tmp.is_empty ())\n+    {\n+      vec<cluster *> n = bit_test_cluster::find_bit_tests (tmp);\n+      output2.safe_splice (n);\n+      n.release ();\n+    }\n \n   if (dump_file)\n     {\n       fprintf (dump_file, \";; GIMPLE switch case clusters: \");\n-      for (unsigned i = 0; i < output.length (); i++)\n-\toutput[i]->dump (dump_file, dump_flags & TDF_DETAILS);\n+      for (unsigned i = 0; i < output2.length (); i++)\n+\toutput2[i]->dump (dump_file, dump_flags & TDF_DETAILS);\n       fprintf (dump_file, \"\\n\");\n     }\n \n-  bool expanded = try_switch_expansion (output);\n+  output.release ();\n \n-  for (unsigned i = 0; i < output.length (); i++)\n-    delete output[i];\n+  bool expanded = try_switch_expansion (output2);\n+\n+  for (unsigned i = 0; i < output2.length (); i++)\n+    delete output2[i];\n+\n+  output2.release ();\n \n   return expanded;\n }"}, {"sha": "03352832cb46d35b6138b4dc38c72d87685dba18", "filename": "gcc/tree-switch-conversion.h", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f928c1b63e67155f4b3c194e3a9cc53fb6fb107/gcc%2Ftree-switch-conversion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f928c1b63e67155f4b3c194e3a9cc53fb6fb107/gcc%2Ftree-switch-conversion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.h?ref=2f928c1b63e67155f4b3c194e3a9cc53fb6fb107", "patch": "@@ -33,7 +33,16 @@ enum cluster_type\n \n #define PRINT_CASE(f,c) print_generic_expr (f, c)\n \n-/* Abstract base class for representing a cluster of cases.  */\n+/* Abstract base class for representing a cluster of cases.\n+\n+   Here is the inheritance hierarachy, and the enum_cluster_type\n+   values for the concrete subclasses:\n+\n+   cluster\n+   |-simple_cluster (SIMPLE_CASE)\n+   `-group_cluster\n+     |-jump_table_cluster (JUMP_TABLE)\n+     `-bit_test_cluster   (BIT_TEST).  */\n \n struct cluster\n {\n@@ -228,6 +237,10 @@ struct jump_table_cluster: public group_cluster\n   void emit (tree index_expr, tree index_type,\n \t     tree default_label_expr, basic_block default_bb);\n \n+  /* Find jump tables of given CLUSTERS, where all members of the vector\n+     are of type simple_cluster.  New clusters are returned.  */\n+  static vec<cluster *> find_jump_tables (vec<cluster *> &clusters);\n+\n   /* Return true when cluster starting at START and ending at END (inclusive)\n      can build a jump-table.  */\n   static bool can_be_handled (const vec<cluster *> &clusters, unsigned start,\n@@ -336,6 +349,10 @@ struct bit_test_cluster: public group_cluster\n   void emit (tree index_expr, tree index_type,\n \t     tree default_label_expr, basic_block default_bb);\n \n+  /* Find bit tests of given CLUSTERS, where all members of the vector\n+     are of type simple_cluster.  New clusters are returned.  */\n+  static vec<cluster *> find_bit_tests (vec<cluster *> &clusters);\n+\n   /* Return true when RANGE of case values with UNIQ labels\n      can build a bit test.  */\n   static bool can_be_handled (unsigned HOST_WIDE_INT range, unsigned uniq);"}]}