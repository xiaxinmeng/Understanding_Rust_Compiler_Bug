{"sha": "bdf69d333e4c6d080e8be3ad9d71fb1895e85d03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmRmNjlkMzMzZTRjNmQwODBlOGJlM2FkOWQ3MWZiMTg5NWU4NWQwMw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-11-21T11:22:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-11-21T11:22:47Z"}, "message": "[multiple changes]\n\n2011-11-21  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch6.adb (Expand_Actuals): In Ada 2012, a function call\n\twith out parameters may generate assignments to force constraint\n\tchecks. These checks must be properly placed in the code after the\n\tdeclaration or statement that contains the call.\n\n2011-11-21  Fedor Rybin  <frybin@adacore.com>\n\n\t* gnat_ugn.texi: Adding info on current gnattest limitations an\n\tsupport of -X option.\n\n2011-11-21  Robert Dewar  <dewar@adacore.com>\n\n\t* a-cfdlli.adb, a-cbdlli.adb: Minor reformatting.\n\nFrom-SVN: r181559", "tree": {"sha": "d7c262a43cb5289678f60e01f197e231069e0715", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7c262a43cb5289678f60e01f197e231069e0715"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bdf69d333e4c6d080e8be3ad9d71fb1895e85d03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdf69d333e4c6d080e8be3ad9d71fb1895e85d03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdf69d333e4c6d080e8be3ad9d71fb1895e85d03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdf69d333e4c6d080e8be3ad9d71fb1895e85d03/comments", "author": null, "committer": null, "parents": [{"sha": "f3670c001ceb35a4922552aaf7be7fe47c2c7c07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3670c001ceb35a4922552aaf7be7fe47c2c7c07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3670c001ceb35a4922552aaf7be7fe47c2c7c07"}], "stats": {"total": 131, "additions": 89, "deletions": 42}, "files": [{"sha": "003a23e22ab6c54658af6df5fca33b3ff5451112", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdf69d333e4c6d080e8be3ad9d71fb1895e85d03/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdf69d333e4c6d080e8be3ad9d71fb1895e85d03/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=bdf69d333e4c6d080e8be3ad9d71fb1895e85d03", "patch": "@@ -1,3 +1,19 @@\n+2011-11-21  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_Actuals): In Ada 2012, a function call\n+\twith out parameters may generate assignments to force constraint\n+\tchecks. These checks must be properly placed in the code after the\n+\tdeclaration or statement that contains the call.\n+\n+2011-11-21  Fedor Rybin  <frybin@adacore.com>\n+\n+\t* gnat_ugn.texi: Adding info on current gnattest limitations an\n+\tsupport of -X option.\n+\n+2011-11-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-cfdlli.adb, a-cbdlli.adb: Minor reformatting.\n+\n 2011-11-20  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_ch6.adb, exp_util.adb: Minor reformatting"}, {"sha": "5a3169eee501555e4e4348492a6177cb16aa6be1", "filename": "gcc/ada/a-cbdlli.adb", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdf69d333e4c6d080e8be3ad9d71fb1895e85d03/gcc%2Fada%2Fa-cbdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdf69d333e4c6d080e8be3ad9d71fb1895e85d03/gcc%2Fada%2Fa-cbdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbdlli.adb?ref=bdf69d333e4c6d080e8be3ad9d71fb1895e85d03", "patch": "@@ -1164,10 +1164,11 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n            \"attempt to tamper with cursors of Source (list is busy)\";\n       end if;\n \n-      Clear (Target);  -- checks busy bit of Target\n+      --  Clear target, note that this checks busy bits of Target\n \n-      while Source.Length > 1 loop\n+      Clear (Target);\n \n+      while Source.Length > 1 loop\n          pragma Assert (Source.First in 1 .. Source.Capacity);\n          pragma Assert (Source.Last /= Source.First);\n          pragma Assert (N (Source.First).Prev = 0);\n@@ -1193,18 +1194,16 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          --  in the unbounded form of the doubly-linked list container. In that\n          --  case, Free is an instantation of Unchecked_Deallocation, which can\n          --  fail (because PE will be raised if controlled Finalize fails), so\n-         --  we must defer the call until the very last step. Here in the\n-         --  bounded form, Free merely links the node we have just\n-         --  \"deallocated\" onto a list of inactive nodes, so technically Free\n-         --  cannot fail. However, for consistency, we handle Free the same way\n-         --  here as we do for the unbounded form, with the pessimistic\n-         --  assumption that it can fail.\n+         --  we must defer the call until the last step. Here in the bounded\n+         --  form, Free merely links the node we have just \"deallocated\" onto a\n+         --  list of inactive nodes, so technically Free cannot fail. However,\n+         --  for consistency, we handle Free the same way here as we do for the\n+         --  unbounded form, with the pessimistic assumption that it can fail.\n \n          Free (Source, X);\n       end loop;\n \n       if Source.Length = 1 then\n-\n          pragma Assert (Source.First in 1 .. Source.Capacity);\n          pragma Assert (Source.Last = Source.First);\n          pragma Assert (N (Source.First).Prev = 0);\n@@ -1247,6 +1246,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       declare\n          Nodes : Node_Array renames Position.Container.Nodes;\n          Node  : constant Count_Type := Nodes (Position.Node).Next;\n+\n       begin\n          if Node = 0 then\n             return No_Element;"}, {"sha": "3c73c0467aa3a82cbfb3ee17a888c2e9fe222cda", "filename": "gcc/ada/a-cfdlli.adb", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdf69d333e4c6d080e8be3ad9d71fb1895e85d03/gcc%2Fada%2Fa-cfdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdf69d333e4c6d080e8be3ad9d71fb1895e85d03/gcc%2Fada%2Fa-cfdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.adb?ref=bdf69d333e4c6d080e8be3ad9d71fb1895e85d03", "patch": "@@ -743,7 +743,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n    begin\n \n       if Before.Node /= 0 then\n-         null;\n          pragma Assert (Vet (Container, Before), \"bad cursor in Insert\");\n       end if;\n \n@@ -793,7 +792,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n    begin\n \n       if Before.Node /= 0 then\n-         null;\n          pragma Assert (Vet (Container, Before), \"bad cursor in Insert\");\n       end if;\n \n@@ -1008,7 +1006,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       Clear (Target);\n \n       while Source.Length > 1 loop\n-\n          pragma Assert (Source.First in 1 .. Source.Capacity);\n          pragma Assert (Source.Last /= Source.First);\n          pragma Assert (N (Source.First).Prev = 0);\n@@ -1034,18 +1031,16 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n          --  in the unbounded form of the doubly-linked list container. In that\n          --  case, Free is an instantation of Unchecked_Deallocation, which can\n          --  fail (because PE will be raised if controlled Finalize fails), so\n-         --  we must defer the call until the very last step. Here in the\n-         --  bounded form, Free merely links the node we have just\n-         --  \"deallocated\" onto a list of inactive nodes, so technically Free\n-         --  cannot fail. However, for consistency, we handle Free the same way\n-         --  here as we do for the unbounded form, with the pessimistic\n-         --  assumption that it can fail.\n+         --  we must defer the call until the last step. Here in the bounded\n+         --  form, Free merely links the node we have just \"deallocated\" onto a\n+         --  list of inactive nodes, so technically Free cannot fail. However,\n+         --  for consistency, we handle Free the same way here as we do for the\n+         --  unbounded form, with the pessimistic assumption that it can fail.\n \n          Free (Source, X);\n       end loop;\n \n       if Source.Length = 1 then\n-\n          pragma Assert (Source.First in 1 .. Source.Capacity);\n          pragma Assert (Source.Last = Source.First);\n          pragma Assert (N (Source.First).Prev = 0);\n@@ -1221,8 +1216,8 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n            \"attempt to tamper with cursors (list is locked)\";\n       end if;\n \n-      pragma Assert (Vet (Container, Position),\n-                     \"bad cursor in Replace_Element\");\n+      pragma Assert\n+        (Vet (Container, Position), \"bad cursor in Replace_Element\");\n \n       declare\n          N : Node_Array renames Container.Nodes;\n@@ -1421,7 +1416,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n \n    begin\n       if Before.Node /= 0 then\n-         null;\n          pragma Assert (Vet (Target, Before), \"bad cursor in Splice\");\n       end if;\n \n@@ -1513,17 +1507,16 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n \n    begin\n       if Before.Node /= 0 then\n-         null;\n-         pragma Assert (Vet (Container, Before),\n-                        \"bad Before cursor in Splice\");\n+         pragma Assert\n+           (Vet (Container, Before), \"bad Before cursor in Splice\");\n       end if;\n \n       if Position.Node = 0 then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      pragma Assert (Vet (Container, Position),\n-                     \"bad Position cursor in Splice\");\n+      pragma Assert\n+        (Vet (Container, Position), \"bad Position cursor in Splice\");\n \n       if Position.Node = Before.Node\n         or else N (Position.Node).Next = Before.Node\n@@ -1732,8 +1725,8 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      pragma Assert (Vet (Container, Position),\n-                     \"bad cursor in Update_Element\");\n+      pragma Assert\n+        (Vet (Container, Position), \"bad cursor in Update_Element\");\n \n       declare\n          B : Natural renames Container.Busy;"}, {"sha": "b68fb8af909c042069962201ba0a8ddf879f11d2", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 39, "deletions": 13, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdf69d333e4c6d080e8be3ad9d71fb1895e85d03/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdf69d333e4c6d080e8be3ad9d71fb1895e85d03/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=bdf69d333e4c6d080e8be3ad9d71fb1895e85d03", "patch": "@@ -1750,24 +1750,50 @@ package body Exp_Ch6 is\n \n       if not Is_Empty_List (Post_Call) then\n \n-         --  If call is not a list member, it must be the triggering statement\n-         --  of a triggering alternative or an entry call alternative, and we\n-         --  can add the post call stuff to the corresponding statement list.\n+         --  Cases where the call is not a member of a statement list\n \n          if not Is_List_Member (N) then\n             declare\n-               P : constant Node_Id := Parent (N);\n+               P :  Node_Id := Parent (N);\n \n             begin\n-               pragma Assert (Nkind_In (P, N_Triggering_Alternative,\n-                                           N_Entry_Call_Alternative));\n+               --  In Ada 2012 the call may be a function call in an expression\n+               --  (since OUT and IN OUT parameters are now allowed for such\n+               --  calls. The write-back of (in)-out parameters is handled\n+               --  by the back-end, but the constraint checks generated when\n+               --  subtypes of formal and actual don't match must be inserted\n+               --  in the form of assignments, at the nearest point after the\n+               --  declaration or statement that contains the call.\n+\n+               if Ada_Version >= Ada_2012\n+                 and then Nkind (N) = N_Function_Call\n+               then\n+                  while Nkind (P) not in N_Declaration\n+                    and then\n+                      Nkind (P) not in N_Statement_Other_Than_Procedure_Call\n+                  loop\n+                     P := Parent (P);\n+                  end loop;\n+\n+                  Insert_Actions_After (P, Post_Call);\n+\n+               --  If not the special Ada 2012 case of a function call, then\n+               --  we must have the triggering statement of a triggering\n+               --  alternative or an entry call alternative, and we can add\n+               --  the post call stuff to the corresponding statement list.\n \n-               if Is_Non_Empty_List (Statements (P)) then\n-                  Insert_List_Before_And_Analyze\n-                    (First (Statements (P)), Post_Call);\n                else\n-                  Set_Statements (P, Post_Call);\n+                  pragma Assert (Nkind_In (P, N_Triggering_Alternative,\n+                                              N_Entry_Call_Alternative));\n+\n+                  if Is_Non_Empty_List (Statements (P)) then\n+                     Insert_List_Before_And_Analyze\n+                       (First (Statements (P)), Post_Call);\n+                  else\n+                     Set_Statements (P, Post_Call);\n+                  end if;\n                end if;\n+\n             end;\n \n          --  Otherwise, normal case where N is in a statement sequence,\n@@ -2764,7 +2790,7 @@ package body Exp_Ch6 is\n          Next_Formal (Formal);\n       end loop;\n \n-      --  If we are calling an Ada2012 function which needs to have the\n+      --  If we are calling an Ada 2012 function which needs to have the\n       --  \"accessibility level determined by the point of call\" (AI05-0234)\n       --  passed in to it, then pass it in.\n \n@@ -8506,8 +8532,8 @@ package body Exp_Ch6 is\n          return False;\n \n       --  Handle a corner case, a cross-dialect subp renaming. For example,\n-      --  an Ada2012 renaming of an Ada05 subprogram. This can occur when a\n-      --  non-Ada2012 unit references predefined runtime units.\n+      --  an Ada 2012 renaming of an Ada 05 subprogram. This can occur when a\n+      --  non-Ada 2012 unit references predefined run-time units.\n \n       elsif Present (Alias (Func_Id)) then\n "}, {"sha": "b30136d8e4035cf6640408027462bbf64f2aebb2", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdf69d333e4c6d080e8be3ad9d71fb1895e85d03/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdf69d333e4c6d080e8be3ad9d71fb1895e85d03/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=bdf69d333e4c6d080e8be3ad9d71fb1895e85d03", "patch": "@@ -17889,6 +17889,9 @@ gnatmake -P<harness-dir>/test_driver\n test_runner\n @end smallexample\n \n+Note that you might need to specify the necessary values of scenario variables\n+when you are not using the AUnit defaults.\n+\n @item actual unit test stubs\n a test stub for each visible subprogram is created in a separate file, if it\n doesn't exist already. By default, those separate test files are located in a\n@@ -17899,6 +17902,9 @@ file my_unit.ads in directory src contains a visible subprogram Proc, then\n the corresponding unit test will be found in file\n src/tests/my_unit-tests-proc_<code>.adb. <code> is a signature encoding used to\n differentiate test names in cases of overloading.\n+\n+Note that if the project already has both my_unit.ads and my_unit-tests.ads this\n+will cause name a conflict with generated test package.\n @end itemize\n \n @node Switches for gnattest\n@@ -17921,6 +17927,10 @@ manual tests to be added to the test suite.\n @cindex @option{-r} (@command{gnattest})\n Recursively consider all sources from all projects.\n \n+@item -X@var{name=value}\n+@cindex @option{-X} (@command{gnattest})\n+Indicate that external variable @var{name} has the value @var{value}.\n+\n @item -q\n @cindex @option{-q} (@command{gnattest})\n Suppresses noncritical output messages.\n@@ -18311,6 +18321,8 @@ The tool currently does not support following features:\n @item generic tests for generic packages and package instantiations\n @item tests for protected subprograms and entries\n @item aspects Precondition, Postcondition, and Test_Case\n+@item generating test packages for code that is not conformant with ada 2005\n+\n @end itemize\n \n @c *********************************"}]}