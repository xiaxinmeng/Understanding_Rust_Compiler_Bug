{"sha": "d12b8c85a9c84502436fdea354e99bcd9c03338a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDEyYjhjODVhOWM4NDUwMjQzNmZkZWEzNTRlOTliY2Q5YzAzMzM4YQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2002-10-01T10:14:35Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2002-10-01T10:14:35Z"}, "message": "mips-protos.h (mips_emit_fcc_reload): Declare.\n\n\t* config/mips/mips-protos.h (mips_emit_fcc_reload): Declare.\n\t* config/mips/mips.h (PREDICATE_CODES): Add fcc_register_operand.\n\t* config/mips/mips.c (fcc_register_operand): New function.\n\t(mips_emit_fcc_reload): New function, extracted from reload_incc.\n\t(override_options): Allow TFmode values in float registers\n\tif ISA_HAS_8CC.\n\t* cnfig/mips/mips.md (reload_incc): Change destination prediate\n\tto fcc_register_operand.  Remove misleading source constraint.\n\tUse mips_emit_fcc_reload.\n\t(reload_outcc): Duplicate reload_incc.\n\nFrom-SVN: r57683", "tree": {"sha": "f69c789a027f4f0baede901d54b871c4a8488d62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f69c789a027f4f0baede901d54b871c4a8488d62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d12b8c85a9c84502436fdea354e99bcd9c03338a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d12b8c85a9c84502436fdea354e99bcd9c03338a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d12b8c85a9c84502436fdea354e99bcd9c03338a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d12b8c85a9c84502436fdea354e99bcd9c03338a/comments", "author": null, "committer": null, "parents": [{"sha": "73bff0644500d63d67e70d753784bbc83525b938", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73bff0644500d63d67e70d753784bbc83525b938", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73bff0644500d63d67e70d753784bbc83525b938"}], "stats": {"total": 144, "additions": 84, "deletions": 60}, "files": [{"sha": "301d1d778b0151029c07dc9e88544db7d69097eb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d12b8c85a9c84502436fdea354e99bcd9c03338a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d12b8c85a9c84502436fdea354e99bcd9c03338a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d12b8c85a9c84502436fdea354e99bcd9c03338a", "patch": "@@ -1,3 +1,16 @@\n+2002-10-01  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips-protos.h (mips_emit_fcc_reload): Declare.\n+\t* config/mips/mips.h (PREDICATE_CODES): Add fcc_register_operand.\n+\t* config/mips/mips.c (fcc_register_operand): New function.\n+\t(mips_emit_fcc_reload): New function, extracted from reload_incc.\n+\t(override_options): Allow TFmode values in float registers\n+\tif ISA_HAS_8CC.\n+\t* cnfig/mips/mips.md (reload_incc): Change destination prediate\n+\tto fcc_register_operand.  Remove misleading source constraint.\n+\tUse mips_emit_fcc_reload.\n+\t(reload_outcc): Duplicate reload_incc.\n+\n 2002-09-30  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* longlong.h: Partially synchronize with GMP-4.1 version:"}, {"sha": "df943afb3f54decb71f95c65bc5363d2ca587235", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d12b8c85a9c84502436fdea354e99bcd9c03338a/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d12b8c85a9c84502436fdea354e99bcd9c03338a/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=d12b8c85a9c84502436fdea354e99bcd9c03338a", "patch": "@@ -87,6 +87,7 @@ extern void\t\tinit_cumulative_args PARAMS ((CUMULATIVE_ARGS *,\n \t\t\t\t\t\t      tree, rtx));\n extern void\t\tgen_conditional_move PARAMS ((rtx *));\n extern void\t\tmips_gen_conditional_trap PARAMS ((rtx *));\n+extern void\t\tmips_emit_fcc_reload PARAMS ((rtx, rtx, rtx));\n extern void\t\tmips_set_return_address PARAMS ((rtx, rtx));\n extern void\t\tmachine_dependent_reorg PARAMS ((rtx));\n extern int\t\tmips_address_cost PARAMS ((rtx));"}, {"sha": "ae578b0677e01d90997be01f763fb91758b6b3c1", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d12b8c85a9c84502436fdea354e99bcd9c03338a/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d12b8c85a9c84502436fdea354e99bcd9c03338a/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=d12b8c85a9c84502436fdea354e99bcd9c03338a", "patch": "@@ -3522,6 +3522,51 @@ mips_gen_conditional_trap (operands)\n \t\t\t      operands[1]));\n }\n \f\n+/* Return true if operand OP is a condition code register.\n+   Only for use during or after reload.  */\n+\n+int\n+fcc_register_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return ((mode == VOIDmode || mode == GET_MODE (op))\n+\t  && (reload_in_progress || reload_completed)\n+\t  && (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n+\t  && ST_REG_P (true_regnum (op)));\n+}\n+\n+/* Emit code to move general operand SRC into condition-code\n+   register DEST.  SCRATCH is a scratch TFmode float register.\n+   The sequence is:\n+\n+\tFP1 = SRC\n+\tFP2 = 0.0f\n+\tDEST = FP2 < FP1\n+\n+   where FP1 and FP2 are single-precision float registers\n+   taken from SCRATCH.  */\n+\n+void\n+mips_emit_fcc_reload (dest, src, scratch)\n+     rtx dest, src, scratch;\n+{\n+  rtx fp1, fp2;\n+\n+  /* Change the source to SFmode.  */\n+  if (GET_CODE (src) == MEM)\n+    src = adjust_address (src, SFmode, 0);\n+  else if (GET_CODE (src) == REG || GET_CODE (src) == SUBREG)\n+    src = gen_rtx_REG (SFmode, true_regnum (src));\n+\n+  fp1 = gen_rtx_REG (SFmode, REGNO (scratch));\n+  fp2 = gen_rtx_REG (SFmode, REGNO (scratch) + FP_INC);\n+\n+  emit_move_insn (copy_rtx (fp1), src);\n+  emit_move_insn (copy_rtx (fp2), CONST0_RTX (SFmode));\n+  emit_insn (gen_slt_sf (dest, fp2, fp1));\n+}\n+\f\n /* Emit code to change the current function's return address to\n    ADDRESS.  SCRATCH is available as a scratch register, if needed.\n    ADDRESS and SCRATCH are both word-mode GPRs.  */\n@@ -5362,7 +5407,9 @@ override_options ()\n \t\t\t/* Allow integer modes that fit into a single\n \t\t\t   register.  We need to put integers into FPRs\n \t\t\t   when using instructions like cvt and trunc.  */\n-\t\t\t|| (class == MODE_INT && size <= UNITS_PER_FPREG)));\n+\t\t\t|| (class == MODE_INT && size <= UNITS_PER_FPREG)\n+\t\t\t/* Allow TFmode for CCmode reloads.  */\n+\t\t\t|| (ISA_HAS_8CC && mode == TFmode)));\n \n \t  else if (MD_REG_P (regno))\n \t    temp = (class == MODE_INT"}, {"sha": "8d8b401f7a7a6d1bf1d6d01a7699ffa106a14191", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d12b8c85a9c84502436fdea354e99bcd9c03338a/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d12b8c85a9c84502436fdea354e99bcd9c03338a/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=d12b8c85a9c84502436fdea354e99bcd9c03338a", "patch": "@@ -3824,6 +3824,7 @@ typedef struct mips_args {\n \t\t\t\t  REG, SIGN_EXTEND }},\t\t\t\\\n   {\"consttable_operand\",\t{ LABEL_REF, SYMBOL_REF, CONST_INT,\t\\\n \t\t\t\t  CONST_DOUBLE, CONST }},\t\t\\\n+  {\"fcc_register_operand\",\t{ REG, SUBREG }},\t\t\t\\\n   {\"extend_operator\",           { SIGN_EXTEND, ZERO_EXTEND }},          \\\n   {\"highpart_shift_operator\",   { ASHIFTRT, LSHIFTRT, ROTATERT, ROTATE }},\n "}, {"sha": "a351add1e3057243ef20683a934a2fb79946834e", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 21, "deletions": 59, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d12b8c85a9c84502436fdea354e99bcd9c03338a/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d12b8c85a9c84502436fdea354e99bcd9c03338a/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=d12b8c85a9c84502436fdea354e99bcd9c03338a", "patch": "@@ -6025,77 +6025,39 @@ move\\\\t%0,%z4\\\\n\\\\\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"\t\"8,4,4,8,4,8,4,4,4,4,8,4,8\")])\n \n-;; Reload condition code registers.  These need scratch registers.\n-\n+;; Reload condition code registers.  reload_incc and reload_outcc\n+;; both handle moves from arbitrary operands into condition code\n+;; registers.  reload_incc handles the more common case in which\n+;; a source operand is constrained to be in a condition-code\n+;; register, but has not been allocated to one.\n+;;\n+;; Sometimes, such as in movcc, we have a CCmode destination whose\n+;; constraints do not include 'z'.  reload_outcc handles the case\n+;; when such an operand is allocated to a condition-code register.\n+;;\n+;; Note that reloads from a condition code register to some\n+;; other location can be done using ordinary moves.  Moving\n+;; into a GPR takes a single movcc, moving elsewhere takes\n+;; two.  We can leave these cases to the generic reload code.\n (define_expand \"reload_incc\"\n-  [(set (match_operand:CC 0 \"register_operand\" \"=z\")\n-\t(match_operand:CC 1 \"general_operand\" \"z\"))\n+  [(set (match_operand:CC 0 \"fcc_register_operand\" \"=z\")\n+\t(match_operand:CC 1 \"general_operand\" \"\"))\n    (clobber (match_operand:TF 2 \"register_operand\" \"=&f\"))]\n   \"ISA_HAS_8CC && TARGET_HARD_FLOAT\"\n   \"\n {\n-  rtx source;\n-  rtx fp1, fp2;\n-  int regno;\n-\n-  /* This is called when are copying some value into a condition code\n-     register.  Operand 0 is the condition code register.  Operand 1\n-     is the source.  Operand 2 is a scratch register; we use TFmode\n-     because we actually need two floating point registers.  */\n-  if (! ST_REG_P (true_regnum (operands[0]))\n-      || ! FP_REG_P (true_regnum (operands[2])))\n-    abort ();\n-\n-  /* We need to get the source in SFmode so that the insn is\n-     recognized.  */\n-  if (GET_CODE (operands[1]) == MEM)\n-    source = adjust_address (operands[1], SFmode, 0);\n-  else if (GET_CODE (operands[1]) == REG || GET_CODE (operands[1]) == SUBREG)\n-    source = gen_rtx_REG (SFmode, true_regnum (operands[1]));\n-  else\n-    source = operands[1];\n-\n-  /* FP1 and FP2 are the two halves of the TFmode scratch operand.  They\n-     will be single registers in 64-bit mode and register pairs in 32-bit\n-     mode.  SOURCE is loaded into FP1 and zero is loaded into FP2.  */\n-  regno = REGNO (operands[2]);\n-  fp1 = gen_rtx_REG (SFmode, regno);\n-  fp2 = gen_rtx_REG (SFmode, regno + HARD_REGNO_NREGS (regno, DFmode));\n-\n-  emit_insn (gen_move_insn (fp1, source));\n-  emit_insn (gen_move_insn (fp2, gen_rtx_REG (SFmode, 0)));\n-  emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t  gen_rtx_LT (CCmode, fp2, fp1)));\n-\n+  mips_emit_fcc_reload (operands[0], operands[1], operands[2]);\n   DONE;\n }\")\n \n (define_expand \"reload_outcc\"\n-  [(set (match_operand:CC 0 \"general_operand\" \"=z\")\n-\t(match_operand:CC 1 \"register_operand\" \"z\"))\n-   (clobber (match_operand:CC 2 \"register_operand\" \"=&d\"))]\n+  [(set (match_operand:CC 0 \"fcc_register_operand\" \"=z\")\n+\t(match_operand:CC 1 \"register_operand\" \"\"))\n+   (clobber (match_operand:TF 2 \"register_operand\" \"=&f\"))]\n   \"ISA_HAS_8CC && TARGET_HARD_FLOAT\"\n   \"\n {\n-  /* This is called when we are copying a condition code register out\n-     to save it somewhere.  Operand 0 should be the location we are\n-     going to save it to.  Operand 1 should be the condition code\n-     register.  Operand 2 should be a scratch general purpose register\n-     created for us by reload.  The mips_secondary_reload_class\n-     function should have told reload that we don't need a scratch\n-     register if the destination is a general purpose register anyhow.  */\n-  if (ST_REG_P (true_regnum (operands[0]))\n-      || GP_REG_P (true_regnum (operands[0]))\n-      || ! ST_REG_P (true_regnum (operands[1]))\n-      || ! GP_REG_P (true_regnum (operands[2])))\n-    abort ();\n-\n-  /* All we have to do is copy the value from the condition code to\n-     the data register, which movcc can handle, and then store the\n-     value into the real final destination.  */\n-  emit_insn (gen_move_insn (operands[2], operands[1]));\n-  emit_insn (gen_move_insn (operands[0], operands[2]));\n-\n+  mips_emit_fcc_reload (operands[0], operands[1], operands[2]);\n   DONE;\n }\")\n "}]}