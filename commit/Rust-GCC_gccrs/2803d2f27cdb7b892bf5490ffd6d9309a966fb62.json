{"sha": "2803d2f27cdb7b892bf5490ffd6d9309a966fb62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjgwM2QyZjI3Y2RiN2I4OTJiZjU0OTBmZmQ2ZDkzMDlhOTY2ZmI2Mg==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-06-02T14:29:26Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-06-04T16:19:59Z"}, "message": "d: Split up d-frontend.cc into multiple parts.\n\ngcc/d/ChangeLog:\n\n\t* Make-lang.in (D_OBJS): Add d-compiler.o, d-ctfloat.o, d-port.o.\n\t* d-frontend.cc (Port::memicmp): Move to d-port.cc.\n\t(Port::strupr): Likewise.\n\t(Port::isFloat32LiteralOutOfRange): Likewise.\n\t(Port::isFloat64LiteralOutOfRange): Likewise.\n\t(Port::readwordLE): Likewise.\n\t(Port::readwordBE): Likewise.\n\t(Port::readlongLE): Likewise.\n\t(Port::readlongBE): Likewise.\n\t(Port::valcpy): Likewise.\n\t(CTFloat::fabs): Move to d-ctfloat.cc.\n\t(CTFloat::ldexp): Likewise.\n\t(CTFloat::isIdentical): Likewise.\n\t(CTFloat::isNaN): Likewise.\n\t(CTFloat::isSNaN): Likewise.\n\t(CTFloat::isInfinity): Likewise.\n\t(CTFloat::parse): Likewise.\n\t(CTFloat::sprint): Likewise.\n\t(CTFloat::hash): Likewise.\n\t(Compiler::genCmain): Move to d-compiler.cc.\n\t(Compiler::paintAsType): Likewise.\n\t(Compiler::loadModule): Likewise.\n\t* d-compiler.cc: New file.\n\t* d-ctfloat.cc: New file.\n\t* d-port.cc: New file.", "tree": {"sha": "0f7396c0473fd0c2b9a3e93ea67037973cedac41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f7396c0473fd0c2b9a3e93ea67037973cedac41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2803d2f27cdb7b892bf5490ffd6d9309a966fb62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2803d2f27cdb7b892bf5490ffd6d9309a966fb62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2803d2f27cdb7b892bf5490ffd6d9309a966fb62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2803d2f27cdb7b892bf5490ffd6d9309a966fb62/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5261cf8ce824bfc75eb6f12ad5e3716c085b6f9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5261cf8ce824bfc75eb6f12ad5e3716c085b6f9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5261cf8ce824bfc75eb6f12ad5e3716c085b6f9a"}], "stats": {"total": 936, "additions": 516, "deletions": 420}, "files": [{"sha": "6c8c611a0f7f78abbf673ad7f7954ebf1669fc43", "filename": "gcc/d/Make-lang.in", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2803d2f27cdb7b892bf5490ffd6d9309a966fb62/gcc%2Fd%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2803d2f27cdb7b892bf5490ffd6d9309a966fb62/gcc%2Fd%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2FMake-lang.in?ref=2803d2f27cdb7b892bf5490ffd6d9309a966fb62", "patch": "@@ -133,10 +133,28 @@ D_GENERATED_OBJS = d/id.o d/impcnvtab.o\n \n # Language-specific object files for D.\n D_OBJS = \\\n-\td/d-attribs.o d/d-builtins.o d/d-codegen.o d/d-convert.o \\\n-\td/d-diagnostic.o d/d-frontend.o d/d-incpath.o d/d-lang.o \\\n-\td/d-longdouble.o d/d-target.o d/decl.o d/expr.o d/imports.o \\\n-\td/intrinsics.o d/modules.o d/runtime.o d/toir.o d/typeinfo.o d/types.o\n+\td/d-attribs.o \\\n+\td/d-builtins.o \\\n+\td/d-codegen.o \\\n+\td/d-compiler.o \\\n+\td/d-convert.o \\\n+\td/d-ctfloat.o \\\n+\td/d-diagnostic.o \\\n+\td/d-frontend.o \\\n+\td/d-incpath.o \\\n+\td/d-lang.o \\\n+\td/d-longdouble.o \\\n+\td/d-port.o \\\n+\td/d-target.o \\\n+\td/decl.o \\\n+\td/expr.o \\\n+\td/imports.o \\\n+\td/intrinsics.o \\\n+\td/modules.o \\\n+\td/runtime.o \\\n+\td/toir.o \\\n+\td/typeinfo.o \\\n+\td/types.o\n \n # All language-specific object files for D.\n D_ALL_OBJS = $(D_FRONTEND_OBJS) $(D_GENERATED_OBJS) $(D_OBJS) $(D_TARGET_OBJS)"}, {"sha": "a27261fb94ebc942dc3d1d2d7e7421100a38b49f", "filename": "gcc/d/d-compiler.cc", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2803d2f27cdb7b892bf5490ffd6d9309a966fb62/gcc%2Fd%2Fd-compiler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2803d2f27cdb7b892bf5490ffd6d9309a966fb62/gcc%2Fd%2Fd-compiler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-compiler.cc?ref=2803d2f27cdb7b892bf5490ffd6d9309a966fb62", "patch": "@@ -0,0 +1,182 @@\n+/* d-compiler.cc -- D frontend interface to the gcc back-end.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+\n+#include \"dmd/compiler.h\"\n+#include \"dmd/scope.h\"\n+#include \"dmd/expression.h\"\n+#include \"dmd/identifier.h\"\n+#include \"dmd/module.h\"\n+#include \"dmd/mtype.h\"\n+\n+#include \"tree.h\"\n+#include \"fold-const.h\"\n+\n+#include \"d-tree.h\"\n+\n+\n+/* Implements the Compiler interface used by the frontend.  */\n+\n+/* Generate C main() in response to seeing D main().  This used to be in\n+   libdruntime, but contained a reference to _Dmain which didn't work when\n+   druntime was made into a shared library and was linked to a program, such\n+   as a C++ program, that didn't have a _Dmain.  */\n+\n+void\n+Compiler::genCmain (Scope *sc)\n+{\n+  static bool initialized = false;\n+\n+  if (initialized)\n+    return;\n+\n+  /* The D code to be generated is provided by __entrypoint.di, try to load it,\n+     but don't fail if unfound.  */\n+  unsigned errors = global.startGagging ();\n+  Module *m = Module::load (Loc (), NULL, Identifier::idPool (\"__entrypoint\"));\n+\n+  if (global.endGagging (errors))\n+    m = NULL;\n+\n+  if (m != NULL)\n+    {\n+      m->importedFrom = m;\n+      m->importAll (NULL);\n+      m->semantic (NULL);\n+      m->semantic2 (NULL);\n+      m->semantic3 (NULL);\n+      d_add_entrypoint_module (m, sc->_module);\n+    }\n+\n+  initialized = true;\n+}\n+\n+/* Perform a reinterpret cast of EXPR to type TYPE for use in CTFE.\n+   The front end should have already ensured that EXPR is a constant,\n+   so we just lower the value to GCC and return the converted CST.  */\n+\n+Expression *\n+Compiler::paintAsType (UnionExp *, Expression *expr, Type *type)\n+{\n+  /* We support up to 512-bit values.  */\n+  unsigned char buffer[64];\n+  tree cst;\n+\n+  Type *tb = type->toBasetype ();\n+\n+  if (expr->type->isintegral ())\n+    cst = build_integer_cst (expr->toInteger (), build_ctype (expr->type));\n+  else if (expr->type->isfloating ())\n+    cst = build_float_cst (expr->toReal (), expr->type);\n+  else if (expr->op == TOKarrayliteral)\n+    {\n+      /* Build array as VECTOR_CST, assumes EXPR is constant.  */\n+      Expressions *elements = ((ArrayLiteralExp *) expr)->elements;\n+      vec<constructor_elt, va_gc> *elms = NULL;\n+\n+      vec_safe_reserve (elms, elements->dim);\n+      for (size_t i = 0; i < elements->dim; i++)\n+\t{\n+\t  Expression *e = (*elements)[i];\n+\t  if (e->type->isintegral ())\n+\t    {\n+\t      tree value = build_integer_cst (e->toInteger (),\n+\t\t\t\t\t      build_ctype (e->type));\n+\t      CONSTRUCTOR_APPEND_ELT (elms, size_int (i), value);\n+\t    }\n+\t  else if (e->type->isfloating ())\n+\t    {\n+\t      tree value = build_float_cst (e->toReal (), e->type);\n+\t      CONSTRUCTOR_APPEND_ELT (elms, size_int (i), value);\n+\t    }\n+\t  else\n+\t    gcc_unreachable ();\n+\t}\n+\n+      /* Build vector type.  */\n+      int nunits = ((TypeSArray *) expr->type)->dim->toUInteger ();\n+      Type *telem = expr->type->nextOf ();\n+      tree vectype = build_vector_type (build_ctype (telem), nunits);\n+\n+      cst = build_vector_from_ctor (vectype, elms);\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  /* Encode CST to buffer.  */\n+  int len = native_encode_expr (cst, buffer, sizeof (buffer));\n+\n+  if (tb->ty == Tsarray)\n+    {\n+      /* Interpret value as a vector of the same size,\n+\t then return the array literal.  */\n+      int nunits = ((TypeSArray *) type)->dim->toUInteger ();\n+      Type *elem = type->nextOf ();\n+      tree vectype = build_vector_type (build_ctype (elem), nunits);\n+\n+      cst = native_interpret_expr (vectype, buffer, len);\n+\n+      Expression *e = d_eval_constant_expression (cst);\n+      gcc_assert (e != NULL && e->op == TOKvector);\n+\n+      return ((VectorExp *) e)->e1;\n+    }\n+  else\n+    {\n+      /* Normal interpret cast.  */\n+      cst = native_interpret_expr (build_ctype (type), buffer, len);\n+\n+      Expression *e = d_eval_constant_expression (cst);\n+      gcc_assert (e != NULL);\n+\n+      return e;\n+    }\n+}\n+\n+/* Check imported module M for any special processing.\n+   Modules we look out for are:\n+    - object: For D runtime type information.\n+    - gcc.builtins: For all gcc builtins.\n+    - core.stdc.*: For all gcc library builtins.  */\n+\n+void\n+Compiler::loadModule (Module *m)\n+{\n+  ModuleDeclaration *md = m->md;\n+\n+  if (!md || !md->id || !md->packages)\n+    {\n+      Identifier *id = (md && md->id) ? md->id : m->ident;\n+      if (!strcmp (id->toChars (), \"object\"))\n+\tcreate_tinfo_types (m);\n+    }\n+  else if (md->packages->dim == 1)\n+    {\n+      if (!strcmp ((*md->packages)[0]->toChars (), \"gcc\")\n+\t  && !strcmp (md->id->toChars (), \"builtins\"))\n+\td_build_builtins_module (m);\n+    }\n+  else if (md->packages->dim == 2)\n+    {\n+      if (!strcmp ((*md->packages)[0]->toChars (), \"core\")\n+\t  && !strcmp ((*md->packages)[1]->toChars (), \"stdc\"))\n+\td_add_builtin_module (m);\n+    }\n+}"}, {"sha": "f2243d4a45e0b54db82e8a4397488df8074f1184", "filename": "gcc/d/d-ctfloat.cc", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2803d2f27cdb7b892bf5490ffd6d9309a966fb62/gcc%2Fd%2Fd-ctfloat.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2803d2f27cdb7b892bf5490ffd6d9309a966fb62/gcc%2Fd%2Fd-ctfloat.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-ctfloat.cc?ref=2803d2f27cdb7b892bf5490ffd6d9309a966fb62", "patch": "@@ -0,0 +1,143 @@\n+/* d-ctfloat.cc -- D frontend interface to the gcc back-end.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+\n+#include \"dmd/root/ctfloat.h\"\n+#include \"dmd/target.h\"\n+\n+#include \"tree.h\"\n+\n+\n+/* Implements the CTFloat interface defined by the frontend.\n+   Compile-time floating-pointer helper functions.  */\n+\n+/* Return the absolute value of R.  */\n+\n+real_t\n+CTFloat::fabs (real_t r)\n+{\n+  real_t x;\n+  real_arithmetic (&x.rv (), ABS_EXPR, &r.rv (), NULL);\n+  return x.normalize ();\n+}\n+\n+/* Return the value of R * 2 ^^ EXP.  */\n+\n+real_t\n+CTFloat::ldexp (real_t r, int exp)\n+{\n+  real_t x;\n+  real_ldexp (&x.rv (), &r.rv (), exp);\n+  return x.normalize ();\n+}\n+\n+/* Return true if longdouble value X is identical to Y.  */\n+\n+bool\n+CTFloat::isIdentical (real_t x, real_t y)\n+{\n+  real_value rx = x.rv ();\n+  real_value ry = y.rv ();\n+  return (REAL_VALUE_ISNAN (rx) && REAL_VALUE_ISNAN (ry))\n+    || real_identical (&rx, &ry);\n+}\n+\n+/* Return true if real_t value R is NaN.  */\n+\n+bool\n+CTFloat::isNaN (real_t r)\n+{\n+  return REAL_VALUE_ISNAN (r.rv ());\n+}\n+\n+/* Same as isNaN, but also check if is signalling.  */\n+\n+bool\n+CTFloat::isSNaN (real_t r)\n+{\n+  return REAL_VALUE_ISSIGNALING_NAN (r.rv ());\n+}\n+\n+/* Return true if real_t value is +Inf.  */\n+\n+bool\n+CTFloat::isInfinity (real_t r)\n+{\n+  return REAL_VALUE_ISINF (r.rv ());\n+}\n+\n+/* Return a real_t value from string BUFFER rounded to long double mode.  */\n+\n+real_t\n+CTFloat::parse (const char *buffer, bool *overflow)\n+{\n+  real_t r;\n+  real_from_string3 (&r.rv (), buffer, TYPE_MODE (long_double_type_node));\n+\n+  /* Front-end checks overflow to see if the value is representable.  */\n+  if (overflow && r == Target::RealProperties::infinity)\n+    *overflow = true;\n+\n+  return r;\n+}\n+\n+/* Format the real_t value R to string BUFFER as a decimal or hexadecimal,\n+   converting the result to uppercase if FMT requests it.  */\n+\n+int\n+CTFloat::sprint (char *buffer, char fmt, real_t r)\n+{\n+  if (fmt == 'a' || fmt == 'A')\n+    {\n+      /* Converting to a hexadecimal string.  */\n+      real_to_hexadecimal (buffer, &r.rv (), 32, 0, 1);\n+      int buflen;\n+\n+      switch (fmt)\n+\t{\n+\tcase 'A':\n+\t  buflen = strlen (buffer);\n+\t  for (int i = 0; i < buflen; i++)\n+\t    buffer[i] = TOUPPER (buffer[i]);\n+\n+\t  return buflen;\n+\n+\tcase 'a':\n+\t  return strlen (buffer);\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+  else\n+    {\n+      /* Note: restricting the precision of significant digits to 18.  */\n+      real_to_decimal (buffer, &r.rv (), 32, 18, 1);\n+      return strlen (buffer);\n+    }\n+}\n+\n+/* Return a hash value for real_t value R.  */\n+\n+size_t\n+CTFloat::hash (real_t r)\n+{\n+  return real_hash (&r.rv ());\n+}"}, {"sha": "28756161b93867233988128549bc691e3264ef78", "filename": "gcc/d/d-frontend.cc", "status": "modified", "additions": 0, "deletions": 416, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2803d2f27cdb7b892bf5490ffd6d9309a966fb62/gcc%2Fd%2Fd-frontend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2803d2f27cdb7b892bf5490ffd6d9309a966fb62/gcc%2Fd%2Fd-frontend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-frontend.cc?ref=2803d2f27cdb7b892bf5490ffd6d9309a966fb62", "patch": "@@ -20,22 +20,16 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n \n #include \"dmd/aggregate.h\"\n-#include \"dmd/compiler.h\"\n #include \"dmd/declaration.h\"\n-#include \"dmd/errors.h\"\n #include \"dmd/expression.h\"\n-#include \"dmd/identifier.h\"\n #include \"dmd/module.h\"\n #include \"dmd/mtype.h\"\n #include \"dmd/scope.h\"\n-#include \"dmd/statement.h\"\n-#include \"dmd/target.h\"\n \n #include \"tree.h\"\n #include \"options.h\"\n #include \"fold-const.h\"\n #include \"diagnostic.h\"\n-#include \"stor-layout.h\"\n \n #include \"d-tree.h\"\n \n@@ -144,416 +138,6 @@ Loc::equals (const Loc& loc)\n }\n \n \n-/* Implements the Port interface defined by the frontend.\n-   A mini library for doing compiler/system specific things.  */\n-\n-/* Compare the first N bytes of S1 and S2 without regard to the case.  */\n-\n-int\n-Port::memicmp (const char *s1, const char *s2, size_t n)\n-{\n-  int result = 0;\n-\n-  for (size_t i = 0; i < n; i++)\n-    {\n-      char c1 = s1[i];\n-      char c2 = s2[i];\n-\n-      result = c1 - c2;\n-      if (result)\n-\t{\n-\t  result = TOUPPER (c1) - TOUPPER (c2);\n-\t  if (result)\n-\t    break;\n-\t}\n-    }\n-\n-  return result;\n-}\n-\n-/* Convert all characters in S to uppercase.  */\n-\n-char *\n-Port::strupr (char *s)\n-{\n-  char *t = s;\n-\n-  while (*s)\n-    {\n-      *s = TOUPPER (*s);\n-      s++;\n-    }\n-\n-  return t;\n-}\n-\n-/* Return true if the real_t value from string BUFFER overflows\n-   as a result of rounding down to float mode.  */\n-\n-bool\n-Port::isFloat32LiteralOutOfRange (const char *buffer)\n-{\n-  real_t r;\n-\n-  real_from_string3 (&r.rv (), buffer, TYPE_MODE (float_type_node));\n-\n-  return r == Target::RealProperties::infinity;\n-}\n-\n-/* Return true if the real_t value from string BUFFER overflows\n-   as a result of rounding down to double mode.  */\n-\n-bool\n-Port::isFloat64LiteralOutOfRange (const char *buffer)\n-{\n-  real_t r;\n-\n-  real_from_string3 (&r.rv (), buffer, TYPE_MODE (double_type_node));\n-\n-  return r == Target::RealProperties::infinity;\n-}\n-\n-/* Fetch a little-endian 16-bit value from BUFFER.  */\n-\n-unsigned\n-Port::readwordLE (void *buffer)\n-{\n-  unsigned char *p = (unsigned char*) buffer;\n-\n-  return ((unsigned) p[1] << 8) | (unsigned) p[0];\n-}\n-\n-/* Fetch a big-endian 16-bit value from BUFFER.  */\n-\n-unsigned\n-Port::readwordBE (void *buffer)\n-{\n-  unsigned char *p = (unsigned char*) buffer;\n-\n-  return ((unsigned) p[0] << 8) | (unsigned) p[1];\n-}\n-\n-/* Fetch a little-endian 32-bit value from BUFFER.  */\n-\n-unsigned\n-Port::readlongLE (void *buffer)\n-{\n-  unsigned char *p = (unsigned char*) buffer;\n-\n-  return (((unsigned) p[3] << 24)\n-\t  | ((unsigned) p[2] << 16)\n-\t  | ((unsigned) p[1] << 8)\n-\t  | (unsigned) p[0]);\n-}\n-\n-/* Fetch a big-endian 32-bit value from BUFFER.  */\n-\n-unsigned\n-Port::readlongBE (void *buffer)\n-{\n-  unsigned char *p = (unsigned char*) buffer;\n-\n-  return (((unsigned) p[0] << 24)\n-\t  | ((unsigned) p[1] << 16)\n-\t  | ((unsigned) p[2] << 8)\n-\t  | (unsigned) p[3]);\n-}\n-\n-/* Write an SZ-byte sized VALUE to BUFFER, ignoring endian-ness.  */\n-\n-void\n-Port::valcpy (void *buffer, uint64_t value, size_t sz)\n-{\n-  switch (sz)\n-    {\n-    case 1:\n-      *(uint8_t *) buffer = (uint8_t) value;\n-      break;\n-\n-    case 2:\n-      *(uint16_t *) buffer = (uint16_t) value;\n-      break;\n-\n-    case 4:\n-      *(uint32_t *) buffer = (uint32_t) value;\n-      break;\n-\n-    case 8:\n-      *(uint64_t *) buffer = (uint64_t) value;\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-\n-/* Implements the CTFloat interface defined by the frontend.\n-   Compile-time floating-pointer helper functions.  */\n-\n-/* Return the absolute value of R.  */\n-\n-real_t\n-CTFloat::fabs (real_t r)\n-{\n-  real_t x;\n-  real_arithmetic (&x.rv (), ABS_EXPR, &r.rv (), NULL);\n-  return x.normalize ();\n-}\n-\n-/* Return the value of R * 2 ^^ EXP.  */\n-\n-real_t\n-CTFloat::ldexp (real_t r, int exp)\n-{\n-  real_t x;\n-  real_ldexp (&x.rv (), &r.rv (), exp);\n-  return x.normalize ();\n-}\n-\n-/* Return true if longdouble value X is identical to Y.  */\n-\n-bool\n-CTFloat::isIdentical (real_t x, real_t y)\n-{\n-  real_value rx = x.rv ();\n-  real_value ry = y.rv ();\n-  return (REAL_VALUE_ISNAN (rx) && REAL_VALUE_ISNAN (ry))\n-    || real_identical (&rx, &ry);\n-}\n-\n-/* Return true if real_t value R is NaN.  */\n-\n-bool\n-CTFloat::isNaN (real_t r)\n-{\n-  return REAL_VALUE_ISNAN (r.rv ());\n-}\n-\n-/* Same as isNaN, but also check if is signalling.  */\n-\n-bool\n-CTFloat::isSNaN (real_t r)\n-{\n-  return REAL_VALUE_ISSIGNALING_NAN (r.rv ());\n-}\n-\n-/* Return true if real_t value is +Inf.  */\n-\n-bool\n-CTFloat::isInfinity (real_t r)\n-{\n-  return REAL_VALUE_ISINF (r.rv ());\n-}\n-\n-/* Return a real_t value from string BUFFER rounded to long double mode.  */\n-\n-real_t\n-CTFloat::parse (const char *buffer, bool *overflow)\n-{\n-  real_t r;\n-  real_from_string3 (&r.rv (), buffer, TYPE_MODE (long_double_type_node));\n-\n-  /* Front-end checks overflow to see if the value is representable.  */\n-  if (overflow && r == Target::RealProperties::infinity)\n-    *overflow = true;\n-\n-  return r;\n-}\n-\n-/* Format the real_t value R to string BUFFER as a decimal or hexadecimal,\n-   converting the result to uppercase if FMT requests it.  */\n-\n-int\n-CTFloat::sprint (char *buffer, char fmt, real_t r)\n-{\n-  if (fmt == 'a' || fmt == 'A')\n-    {\n-      /* Converting to a hexadecimal string.  */\n-      real_to_hexadecimal (buffer, &r.rv (), 32, 0, 1);\n-      int buflen;\n-\n-      switch (fmt)\n-\t{\n-\tcase 'A':\n-\t  buflen = strlen (buffer);\n-\t  for (int i = 0; i < buflen; i++)\n-\t    buffer[i] = TOUPPER (buffer[i]);\n-\n-\t  return buflen;\n-\n-\tcase 'a':\n-\t  return strlen (buffer);\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n-  else\n-    {\n-      /* Note: restricting the precision of significant digits to 18.  */\n-      real_to_decimal (buffer, &r.rv (), 32, 18, 1);\n-      return strlen (buffer);\n-    }\n-}\n-\n-/* Return a hash value for real_t value R.  */\n-\n-size_t\n-CTFloat::hash (real_t r)\n-{\n-  return real_hash (&r.rv ());\n-}\n-\n-/* Implements the Compiler interface used by the frontend.  */\n-\n-/* Generate C main() in response to seeing D main().  This used to be in\n-   libdruntime, but contained a reference to _Dmain which didn't work when\n-   druntime was made into a shared library and was linked to a program, such\n-   as a C++ program, that didn't have a _Dmain.  */\n-\n-void\n-Compiler::genCmain (Scope *sc)\n-{\n-  static bool initialized = false;\n-\n-  if (initialized)\n-    return;\n-\n-  /* The D code to be generated is provided by __entrypoint.di, try to load it,\n-     but don't fail if unfound.  */\n-  unsigned errors = global.startGagging ();\n-  Module *m = Module::load (Loc (), NULL, Identifier::idPool (\"__entrypoint\"));\n-\n-  if (global.endGagging (errors))\n-    m = NULL;\n-\n-  if (m != NULL)\n-    {\n-      m->importedFrom = m;\n-      m->importAll (NULL);\n-      m->semantic (NULL);\n-      m->semantic2 (NULL);\n-      m->semantic3 (NULL);\n-      d_add_entrypoint_module (m, sc->_module);\n-    }\n-\n-  initialized = true;\n-}\n-\n-/* Perform a reinterpret cast of EXPR to type TYPE for use in CTFE.\n-   The front end should have already ensured that EXPR is a constant,\n-   so we just lower the value to GCC and return the converted CST.  */\n-\n-Expression *\n-Compiler::paintAsType (UnionExp *, Expression *expr, Type *type)\n-{\n-  /* We support up to 512-bit values.  */\n-  unsigned char buffer[64];\n-  tree cst;\n-\n-  Type *tb = type->toBasetype ();\n-\n-  if (expr->type->isintegral ())\n-    cst = build_integer_cst (expr->toInteger (), build_ctype (expr->type));\n-  else if (expr->type->isfloating ())\n-    cst = build_float_cst (expr->toReal (), expr->type);\n-  else if (expr->op == TOKarrayliteral)\n-    {\n-      /* Build array as VECTOR_CST, assumes EXPR is constant.  */\n-      Expressions *elements = ((ArrayLiteralExp *) expr)->elements;\n-      vec<constructor_elt, va_gc> *elms = NULL;\n-\n-      vec_safe_reserve (elms, elements->dim);\n-      for (size_t i = 0; i < elements->dim; i++)\n-\t{\n-\t  Expression *e = (*elements)[i];\n-\t  if (e->type->isintegral ())\n-\t    {\n-\t      tree value = build_integer_cst (e->toInteger (),\n-\t\t\t\t\t      build_ctype (e->type));\n-\t      CONSTRUCTOR_APPEND_ELT (elms, size_int (i), value);\n-\t    }\n-\t  else if (e->type->isfloating ())\n-\t    {\n-\t      tree value = build_float_cst (e->toReal (), e->type);\n-\t      CONSTRUCTOR_APPEND_ELT (elms, size_int (i), value);\n-\t    }\n-\t  else\n-\t    gcc_unreachable ();\n-\t}\n-\n-      /* Build vector type.  */\n-      int nunits = ((TypeSArray *) expr->type)->dim->toUInteger ();\n-      Type *telem = expr->type->nextOf ();\n-      tree vectype = build_vector_type (build_ctype (telem), nunits);\n-\n-      cst = build_vector_from_ctor (vectype, elms);\n-    }\n-  else\n-    gcc_unreachable ();\n-\n-  /* Encode CST to buffer.  */\n-  int len = native_encode_expr (cst, buffer, sizeof (buffer));\n-\n-  if (tb->ty == Tsarray)\n-    {\n-      /* Interpret value as a vector of the same size,\n-\t then return the array literal.  */\n-      int nunits = ((TypeSArray *) type)->dim->toUInteger ();\n-      Type *elem = type->nextOf ();\n-      tree vectype = build_vector_type (build_ctype (elem), nunits);\n-\n-      cst = native_interpret_expr (vectype, buffer, len);\n-\n-      Expression *e = d_eval_constant_expression (cst);\n-      gcc_assert (e != NULL && e->op == TOKvector);\n-\n-      return ((VectorExp *) e)->e1;\n-    }\n-  else\n-    {\n-      /* Normal interpret cast.  */\n-      cst = native_interpret_expr (build_ctype (type), buffer, len);\n-\n-      Expression *e = d_eval_constant_expression (cst);\n-      gcc_assert (e != NULL);\n-\n-      return e;\n-    }\n-}\n-\n-/* Check imported module M for any special processing.\n-   Modules we look out for are:\n-    - object: For D runtime type information.\n-    - gcc.builtins: For all gcc builtins.\n-    - core.stdc.*: For all gcc library builtins.  */\n-\n-void\n-Compiler::loadModule (Module *m)\n-{\n-  ModuleDeclaration *md = m->md;\n-\n-  if (!md || !md->id || !md->packages)\n-    {\n-      Identifier *id = (md && md->id) ? md->id : m->ident;\n-      if (!strcmp (id->toChars (), \"object\"))\n-\tcreate_tinfo_types (m);\n-    }\n-  else if (md->packages->dim == 1)\n-    {\n-      if (!strcmp ((*md->packages)[0]->toChars (), \"gcc\")\n-\t  && !strcmp (md->id->toChars (), \"builtins\"))\n-\td_build_builtins_module (m);\n-    }\n-  else if (md->packages->dim == 2)\n-    {\n-      if (!strcmp ((*md->packages)[0]->toChars (), \"core\")\n-\t  && !strcmp ((*md->packages)[1]->toChars (), \"stdc\"))\n-\td_add_builtin_module (m);\n-    }\n-}\n-\n /* Implements back-end specific interfaces used by the frontend.  */\n \n /* Determine return style of function - whether in registers or through a"}, {"sha": "12208a9039f4d3eb340ea45d695d5c43fdc6bf6f", "filename": "gcc/d/d-port.cc", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2803d2f27cdb7b892bf5490ffd6d9309a966fb62/gcc%2Fd%2Fd-port.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2803d2f27cdb7b892bf5490ffd6d9309a966fb62/gcc%2Fd%2Fd-port.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-port.cc?ref=2803d2f27cdb7b892bf5490ffd6d9309a966fb62", "patch": "@@ -0,0 +1,169 @@\n+/* d-port.cc -- D frontend interface to the gcc back-end.\n+   Copyright (C) 2013-2020 Free Software Foundation, Inc.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+\n+#include \"dmd/root/port.h\"\n+#include \"dmd/target.h\"\n+\n+#include \"tree.h\"\n+\n+\n+/* Implements the Port interface defined by the frontend.\n+   A mini library for doing compiler/system specific things.  */\n+\n+/* Compare the first N bytes of S1 and S2 without regard to the case.  */\n+\n+int\n+Port::memicmp (const char *s1, const char *s2, size_t n)\n+{\n+  int result = 0;\n+\n+  for (size_t i = 0; i < n; i++)\n+    {\n+      char c1 = s1[i];\n+      char c2 = s2[i];\n+\n+      result = c1 - c2;\n+      if (result)\n+\t{\n+\t  result = TOUPPER (c1) - TOUPPER (c2);\n+\t  if (result)\n+\t    break;\n+\t}\n+    }\n+\n+  return result;\n+}\n+\n+/* Convert all characters in S to uppercase.  */\n+\n+char *\n+Port::strupr (char *s)\n+{\n+  char *t = s;\n+\n+  while (*s)\n+    {\n+      *s = TOUPPER (*s);\n+      s++;\n+    }\n+\n+  return t;\n+}\n+\n+/* Return true if the real_t value from string BUFFER overflows\n+   as a result of rounding down to float mode.  */\n+\n+bool\n+Port::isFloat32LiteralOutOfRange (const char *buffer)\n+{\n+  real_t r;\n+\n+  real_from_string3 (&r.rv (), buffer, TYPE_MODE (float_type_node));\n+\n+  return r == Target::RealProperties::infinity;\n+}\n+\n+/* Return true if the real_t value from string BUFFER overflows\n+   as a result of rounding down to double mode.  */\n+\n+bool\n+Port::isFloat64LiteralOutOfRange (const char *buffer)\n+{\n+  real_t r;\n+\n+  real_from_string3 (&r.rv (), buffer, TYPE_MODE (double_type_node));\n+\n+  return r == Target::RealProperties::infinity;\n+}\n+\n+/* Fetch a little-endian 16-bit value from BUFFER.  */\n+\n+unsigned\n+Port::readwordLE (void *buffer)\n+{\n+  unsigned char *p = (unsigned char*) buffer;\n+\n+  return ((unsigned) p[1] << 8) | (unsigned) p[0];\n+}\n+\n+/* Fetch a big-endian 16-bit value from BUFFER.  */\n+\n+unsigned\n+Port::readwordBE (void *buffer)\n+{\n+  unsigned char *p = (unsigned char*) buffer;\n+\n+  return ((unsigned) p[0] << 8) | (unsigned) p[1];\n+}\n+\n+/* Fetch a little-endian 32-bit value from BUFFER.  */\n+\n+unsigned\n+Port::readlongLE (void *buffer)\n+{\n+  unsigned char *p = (unsigned char*) buffer;\n+\n+  return (((unsigned) p[3] << 24)\n+\t  | ((unsigned) p[2] << 16)\n+\t  | ((unsigned) p[1] << 8)\n+\t  | (unsigned) p[0]);\n+}\n+\n+/* Fetch a big-endian 32-bit value from BUFFER.  */\n+\n+unsigned\n+Port::readlongBE (void *buffer)\n+{\n+  unsigned char *p = (unsigned char*) buffer;\n+\n+  return (((unsigned) p[0] << 24)\n+\t  | ((unsigned) p[1] << 16)\n+\t  | ((unsigned) p[2] << 8)\n+\t  | (unsigned) p[3]);\n+}\n+\n+/* Write an SZ-byte sized VALUE to BUFFER, ignoring endian-ness.  */\n+\n+void\n+Port::valcpy (void *buffer, uint64_t value, size_t sz)\n+{\n+  switch (sz)\n+    {\n+    case 1:\n+      *(uint8_t *) buffer = (uint8_t) value;\n+      break;\n+\n+    case 2:\n+      *(uint16_t *) buffer = (uint16_t) value;\n+      break;\n+\n+    case 4:\n+      *(uint32_t *) buffer = (uint32_t) value;\n+      break;\n+\n+    case 8:\n+      *(uint64_t *) buffer = (uint64_t) value;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}"}]}