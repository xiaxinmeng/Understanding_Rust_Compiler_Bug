{"sha": "607cf13135fdf7c664bb26f7cf2c5b3c18204f96", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA3Y2YxMzEzNWZkZjdjNjY0YmIyNmY3Y2YyYzViM2MxODIwNGY5Ng==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-12-16T22:18:22Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-12-16T22:18:22Z"}, "message": "class.c (check_field_decls): Don't return a value.\n\n1999-12-16  Mark Mitchell  <mark@codesourcery.com>\n\n\t* class.c (check_field_decls): Don't return a value.\n\t(avoid_overlap): Moved here from tree.c.\n\t(build_base_fields): Likewise.\n\t(check_bases): New function, split out from finish_base_struct.\n\t(check_bases_and_members): New function, split out from finish_struct_1.\n\t(struct base_info): Remove cant_have_default_ctor,\n\tcant_have_const_ctor, cant_have_asn_ref.\n\t(finish_base_struct): Split semantic analysis into check_bases.\n\t(finish_struct_methods): Fix bogus assertion.\n\t(check_field_decls): Call finish_struct_anon here.\n\t(build_vbase_pointer_fields): Use CLASSTYPE_N_BASECLASSES.\n\t(finish_struct_1): Use check_bases_and_members.  Reorganize.\n\t* cp-tree.h (CLASSTYPE_VBASECLASSES): Improve documentation.\n\t(build_base_fields): Don't declare.\n\t* tree.c (avoid_overlap): Remove.\n\t(build_base_fields): Likewise.\n\nFrom-SVN: r30983", "tree": {"sha": "418097af1b72d5c3400d623aa2be1b3611051d92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/418097af1b72d5c3400d623aa2be1b3611051d92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/607cf13135fdf7c664bb26f7cf2c5b3c18204f96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/607cf13135fdf7c664bb26f7cf2c5b3c18204f96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/607cf13135fdf7c664bb26f7cf2c5b3c18204f96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/607cf13135fdf7c664bb26f7cf2c5b3c18204f96/comments", "author": null, "committer": null, "parents": [{"sha": "a97901e608d0e3233e28a6d8e39d3124d661a650", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a97901e608d0e3233e28a6d8e39d3124d661a650", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a97901e608d0e3233e28a6d8e39d3124d661a650"}], "stats": {"total": 660, "additions": 365, "deletions": 295}, "files": [{"sha": "2fe8bd30b9be034635bd1d49b35c0f62ab33ad9e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/607cf13135fdf7c664bb26f7cf2c5b3c18204f96/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/607cf13135fdf7c664bb26f7cf2c5b3c18204f96/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=607cf13135fdf7c664bb26f7cf2c5b3c18204f96", "patch": "@@ -1,5 +1,22 @@\n 1999-12-16  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* class.c (check_field_decls): Don't return a value.\n+\t(avoid_overlap): Moved here from tree.c.\n+\t(build_base_fields): Likewise.\n+\t(check_bases): New function, split out from finish_base_struct.\n+\t(check_bases_and_members): New function, split out from finish_struct_1.\n+\t(struct base_info): Remove cant_have_default_ctor,\n+\tcant_have_const_ctor, cant_have_asn_ref.\n+\t(finish_base_struct): Split semantic analysis into check_bases.\n+\t(finish_struct_methods): Fix bogus assertion.\n+\t(check_field_decls): Call finish_struct_anon here.\n+\t(build_vbase_pointer_fields): Use CLASSTYPE_N_BASECLASSES.\n+\t(finish_struct_1): Use check_bases_and_members.  Reorganize.\n+\t* cp-tree.h (CLASSTYPE_VBASECLASSES): Improve documentation.\n+\t(build_base_fields): Don't declare.\n+\t* tree.c (avoid_overlap): Remove.\n+\t(build_base_fields): Likewise.\n+\t\n \t* optimize.c (struct inline_data): Remove scope_stmt.\n \t(remap_block): Don't use insert_block_after_note.  Don't update\n \tscope_stmt."}, {"sha": "f0a4b92a9749b0a06ea3ab17688df098ad7ee5f6", "filename": "gcc/cp/class.c", "status": "modified", "additions": 318, "deletions": 145, "changes": 463, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/607cf13135fdf7c664bb26f7cf2c5b3c18204f96/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/607cf13135fdf7c664bb26f7cf2c5b3c18204f96/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=607cf13135fdf7c664bb26f7cf2c5b3c18204f96", "patch": "@@ -123,12 +123,16 @@ static int count_fields PROTO((tree));\n static int add_fields_to_vec PROTO((tree, tree, int));\n static void check_bitfield_decl PROTO((tree));\n static void check_field_decl PROTO((tree, tree, int *, int *, int *, int *));\n-static tree* check_field_decls PROTO((tree, tree *, int *, int *, int *, \n-\t\t\t\t      int *));\n+static void check_field_decls PROTO((tree, tree *, int *, int *, int *, \n+\t\t\t\t     int *));\n+static int avoid_overlap PROTO((tree, tree, int *));\n+static tree build_base_fields PROTO((tree, int *));\n static tree build_vbase_pointer_fields PROTO((tree, int *));\n static tree build_vtbl_or_vbase_field PROTO((tree, tree, tree, tree, int *));\n static void check_methods PROTO((tree));\n static void remove_zero_width_bit_fields PROTO((tree));\n+static void check_bases PROTO((tree, int *, int *, int *));\n+static void check_bases_and_members PROTO((tree, int *));\n \n /* Variables shared between class.c and call.c.  */\n \n@@ -1486,52 +1490,43 @@ struct base_info\n   tree vfield;\n   tree vfields;\n   tree rtti;\n-  char cant_have_default_ctor;\n-  char cant_have_const_ctor;\n-  char no_const_asn_ref;\n };\n \n-/* Record information about type T derived from its base classes.\n-   Store most of that information in T itself, and place the\n-   remaining information in the struct BASE_INFO.\n-\n-   Propagate basetype offsets throughout the lattice.  Note that the\n-   lattice topped by T is really a pair: it's a DAG that gives the\n-   structure of the derivation hierarchy, and it's a list of the\n-   virtual baseclasses that appear anywhere in the DAG.  When a vbase\n-   type appears in the DAG, it's offset is 0, and it's children start\n-   their offsets from that point.  When a vbase type appears in the list,\n-   its offset is the offset it has in the hierarchy, and its children's\n-   offsets include that offset in theirs.\n+/* Run through the base clases of T, updating\n+   CANT_HAVE_DEFAULT_CTOR_P, CANT_HAVE_CONST_CTOR_P, and\n+   NO_CONST_ASN_REF_P.  Also set flag bits in T based on properties of\n+   the bases.  */\n \n-   Returns the index of the first base class to have virtual functions,\n-   or -1 if no such base class.  */\n-\n-static int\n-finish_base_struct (t, b)\n+static void\n+check_bases (t, cant_have_default_ctor_p, cant_have_const_ctor_p,\n+\t     no_const_asn_ref_p)\n      tree t;\n-     struct base_info *b;\n+     int *cant_have_default_ctor_p;\n+     int *cant_have_const_ctor_p;\n+     int *no_const_asn_ref_p;\n {\n-  tree binfos = TYPE_BINFO_BASETYPES (t);\n-  int i, n_baseclasses = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-  int first_vfn_base_index = -1;\n-  bzero ((char *) b, sizeof (struct base_info));\n+  int n_baseclasses;\n+  int i;\n+  tree binfos;\n \n-  for (i = 0; i < n_baseclasses; i++)\n+  binfos = TYPE_BINFO_BASETYPES (t);\n+  n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n+\n+  /* An aggregate cannot have baseclasses.  */\n+  CLASSTYPE_NON_AGGREGATE (t) |= (n_baseclasses != 0);\n+\n+  for (i = 0; i < n_baseclasses; ++i) \n     {\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      tree basetype = BINFO_TYPE (base_binfo);\n+      tree base_binfo;\n+      tree basetype;\n \n-      /* Effective C++ rule 14.  We only need to check TYPE_VIRTUAL_P\n-\t here because the case of virtual functions but non-virtual\n-\t dtor is handled in finish_struct_1.  */\n-      if (warn_ecpp && ! TYPE_VIRTUAL_P (basetype)\n-\t  && TYPE_HAS_DESTRUCTOR (basetype))\n-\tcp_warning (\"base class `%#T' has a non-virtual destructor\", basetype);\n+      /* Figure out what base we're looking at.  */\n+      base_binfo = TREE_VEC_ELT (binfos, i);\n+      basetype = TREE_TYPE (base_binfo);\n \n-      /* If the type of basetype is incomplete, then\n-\t we already complained about that fact\n-\t (and we should have fixed it up as well).  */\n+      /* If the type of basetype is incomplete, then we already\n+\t complained about that fact (and we should have fixed it up as\n+\t well).  */\n       if (TYPE_SIZE (basetype) == 0)\n \t{\n \t  int j;\n@@ -1544,15 +1539,33 @@ finish_base_struct (t, b)\n \t  n_baseclasses -= 1;\n \t  for (j = i; j+1 < n_baseclasses; j++)\n \t    TREE_VEC_ELT (binfos, j) = TREE_VEC_ELT (binfos, j+1);\n+\t  continue;\n \t}\n \n-      if (! TYPE_HAS_CONST_INIT_REF (basetype))\n-\tb->cant_have_const_ctor = 1;\n+      /* Effective C++ rule 14.  We only need to check TYPE_VIRTUAL_P\n+\t here because the case of virtual functions but non-virtual\n+\t dtor is handled in finish_struct_1.  */\n+      if (warn_ecpp && ! TYPE_VIRTUAL_P (basetype)\n+\t  && TYPE_HAS_DESTRUCTOR (basetype))\n+\tcp_warning (\"base class `%#T' has a non-virtual destructor\",\n+\t\t    basetype);\n \n+      /* If the base class doesn't have copy constructors or\n+\t assignment operators that take const references, then the\n+\t derived class cannot have such a member automatically\n+\t generated.  */\n+      if (! TYPE_HAS_CONST_INIT_REF (basetype))\n+\t*cant_have_const_ctor_p = 1;\n+      if (TYPE_HAS_ASSIGN_REF (basetype)\n+\t  && !TYPE_HAS_CONST_ASSIGN_REF (basetype))\n+\t*no_const_asn_ref_p = 1;\n+      /* Similarly, if the base class doesn't have a default\n+\t constructor, then the derived class won't have an\n+\t automatically generated default constructor.  */\n       if (TYPE_HAS_CONSTRUCTOR (basetype)\n \t  && ! TYPE_HAS_DEFAULT_CONSTRUCTOR (basetype))\n \t{\n-\t  b->cant_have_default_ctor = 1;\n+\t  *cant_have_default_ctor_p = 1;\n \t  if (! TYPE_HAS_CONSTRUCTOR (t))\n \t    {\n \t      cp_pedwarn (\"base `%T' with only non-default constructor\",\n@@ -1561,30 +1574,61 @@ finish_base_struct (t, b)\n \t    }\n \t}\n \n-      if (TYPE_HAS_ASSIGN_REF (basetype)\n-\t  && !TYPE_HAS_CONST_ASSIGN_REF (basetype))\n-\tb->no_const_asn_ref = 1;\n-\n+      /* A lot of properties from the bases also apply to the derived\n+\t class.  */\n       TYPE_NEEDS_CONSTRUCTING (t) |= TYPE_NEEDS_CONSTRUCTING (basetype);\n       TYPE_NEEDS_DESTRUCTOR (t) |= TYPE_NEEDS_DESTRUCTOR (basetype);\n-      TYPE_HAS_COMPLEX_ASSIGN_REF (t) |= TYPE_HAS_COMPLEX_ASSIGN_REF (basetype);\n+      TYPE_HAS_COMPLEX_ASSIGN_REF (t) \n+\t|= TYPE_HAS_COMPLEX_ASSIGN_REF (basetype);\n       TYPE_HAS_COMPLEX_INIT_REF (t) |= TYPE_HAS_COMPLEX_INIT_REF (basetype);\n-\n       TYPE_OVERLOADS_CALL_EXPR (t) |= TYPE_OVERLOADS_CALL_EXPR (basetype);\n       TYPE_OVERLOADS_ARRAY_REF (t) |= TYPE_OVERLOADS_ARRAY_REF (basetype);\n       TYPE_OVERLOADS_ARROW (t) |= TYPE_OVERLOADS_ARROW (basetype);\n \n+      /* Derived classes can implicitly become COMified if their bases\n+\t are COM.  */\n       if (CLASSTYPE_COM_INTERFACE (basetype))\n-\t{\n-\t  CLASSTYPE_COM_INTERFACE (t) = 1;\n-\t}\n-      else if (CLASSTYPE_COM_INTERFACE (t) && i == 0)\n+\tCLASSTYPE_COM_INTERFACE (t) = 1;\n+      else if (i == 0 && CLASSTYPE_COM_INTERFACE (t))\n \t{\n \t  cp_error \n \t    (\"COM interface type `%T' with non-COM leftmost base class `%T'\",\n \t     t, basetype);\n \t  CLASSTYPE_COM_INTERFACE (t) = 0;\n \t}\n+    }\n+}\n+\n+/* Record information about type T derived from its base classes.\n+   Store most of that information in T itself, and place the\n+   remaining information in the struct BASE_INFO.\n+\n+   Propagate basetype offsets throughout the lattice.  Note that the\n+   lattice topped by T is really a pair: it's a DAG that gives the\n+   structure of the derivation hierarchy, and it's a list of the\n+   virtual baseclasses that appear anywhere in the DAG.  When a vbase\n+   type appears in the DAG, it's offset is 0, and it's children start\n+   their offsets from that point.  When a vbase type appears in the list,\n+   its offset is the offset it has in the hierarchy, and its children's\n+   offsets include that offset in theirs.\n+\n+   Returns the index of the first base class to have virtual functions,\n+   or -1 if no such base class.  */\n+\n+static int\n+finish_base_struct (t, b)\n+     tree t;\n+     struct base_info *b;\n+{\n+  tree binfos = TYPE_BINFO_BASETYPES (t);\n+  int i, n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n+  int first_vfn_base_index = -1;\n+  bzero ((char *) b, sizeof (struct base_info));\n+\n+  for (i = 0; i < n_baseclasses; i++)\n+    {\n+      tree base_binfo = TREE_VEC_ELT (binfos, i);\n+      tree basetype = BINFO_TYPE (base_binfo);\n \n       if (TYPE_VIRTUAL_P (basetype))\n \t{\n@@ -2009,8 +2053,8 @@ finish_struct_methods (t)\n       return;\n     }\n \n-  my_friendly_assert (method_vec != NULL_TREE, 19991215);\n   method_vec = CLASSTYPE_METHOD_VEC (t);\n+  my_friendly_assert (method_vec != NULL_TREE, 19991215);\n   len = TREE_VEC_LENGTH (method_vec);\n \n   /* First fill in entry 0 with the constructors, entry 1 with destructors,\n@@ -3387,7 +3431,7 @@ check_field_decl (field, t, cant_have_const_ctor,\n    Returns a pointer to the end of the TYPE_FIELDs chain; additional\n    fields can be added by adding to this chain.  */\n \n-static tree*\n+static void\n check_field_decls (t, access_decls, empty_p, \n \t\t   cant_have_default_ctor_p, cant_have_const_ctor_p,\n \t\t   no_const_asn_ref_p)\n@@ -3606,12 +3650,13 @@ check_field_decls (t, access_decls, empty_p,\n \tcp_warning (\"  but does not override `operator=(const %T&)'\", t);\n     }\n \n+\n+  /* Check anonymous struct/anonymous union fields.  */\n+  finish_struct_anon (t);\n+\n   /* We've built up the list of access declarations in reverse order.\n      Fix that now.  */\n   *access_decls = nreverse (*access_decls);\n-\n-  /* Return the last field.  */\n-  return field;\n }\n \n /* Return a FIELD_DECL for a pointer-to-virtual-table or\n@@ -3662,7 +3707,7 @@ build_vbase_pointer_fields (rec, empty_p)\n      base classes.  */\n   tree vbase_decls = NULL_TREE;\n   tree binfos = TYPE_BINFO_BASETYPES (rec);\n-  int n_baseclasses = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n+  int n_baseclasses = CLASSTYPE_N_BASECLASSES (rec);\n   tree decl;\n   int i;\n \n@@ -3725,6 +3770,129 @@ build_vbase_pointer_fields (rec, empty_p)\n   return vbase_decls;\n }\n \n+/* If the empty base field in DECL overlaps with a base of the same type in\n+   NEWDECL, which is either another base field or the first data field of\n+   the class, pad the base just before NEWDECL and return 1.  Otherwise,\n+   return 0.  */\n+\n+static int\n+avoid_overlap (decl, newdecl, empty_p)\n+     tree decl, newdecl;\n+     int *empty_p;\n+{\n+  tree field;\n+\n+  if (newdecl == NULL_TREE\n+      || ! types_overlap_p (TREE_TYPE (decl), TREE_TYPE (newdecl)))\n+    return 0;\n+\n+  for (field = decl; TREE_CHAIN (field) && TREE_CHAIN (field) != newdecl;\n+       field = TREE_CHAIN (field))\n+    ;\n+\n+  DECL_SIZE (field) = integer_one_node;\n+  /* The containing class cannot be empty; this field takes up space.  */\n+  *empty_p = 0;\n+\n+  return 1;\n+}\n+\n+/* Returns a list of fields to stand in for the base class subobjects\n+   of REC.  These fields are later removed by layout_basetypes.  */\n+\n+static tree\n+build_base_fields (rec, empty_p)\n+     tree rec;\n+     int *empty_p;\n+{\n+  /* Chain to hold all the new FIELD_DECLs which stand in for base class\n+     subobjects.  */\n+  tree base_decls = NULL_TREE;\n+  tree binfos = TYPE_BINFO_BASETYPES (rec);\n+  int n_baseclasses = CLASSTYPE_N_BASECLASSES (rec);\n+  tree decl, nextdecl;\n+  int i, saw_empty = 0;\n+  unsigned int base_align = 0;\n+\n+  for (i = 0; i < n_baseclasses; ++i)\n+    {\n+      register tree base_binfo = TREE_VEC_ELT (binfos, i);\n+      register tree basetype = BINFO_TYPE (base_binfo);\n+\n+      if (TYPE_SIZE (basetype) == 0)\n+\t/* This error is now reported in xref_tag, thus giving better\n+\t   location information.  */\n+\tcontinue;\n+\n+      if (TREE_VIA_VIRTUAL (base_binfo))\n+\tcontinue;\n+\n+      decl = build_lang_decl (FIELD_DECL, NULL_TREE, basetype);\n+      DECL_ARTIFICIAL (decl) = 1;\n+      DECL_FIELD_CONTEXT (decl) = DECL_CLASS_CONTEXT (decl) = rec;\n+      DECL_SIZE (decl) = CLASSTYPE_SIZE (basetype);\n+      DECL_ALIGN (decl) = CLASSTYPE_ALIGN (basetype);\n+      TREE_CHAIN (decl) = base_decls;\n+      base_decls = decl;\n+\n+      if (flag_new_abi && DECL_SIZE (decl) == integer_zero_node)\n+\tsaw_empty = 1;\n+      else\n+\t{\n+\t  /* The containing class is non-empty because it has a\n+\t     non-empty base class.  */\n+\t  *empty_p = 0;\n+\n+\t  if (! flag_new_abi)\n+\t    {\n+\t      /* Brain damage for backwards compatibility.  For no\n+\t\t good reason, the old layout_basetypes made every base\n+\t\t at least as large as the alignment for the bases up\n+\t\t to that point, gratuitously wasting space.  So we do\n+\t\t the same thing here.  */\n+\t      base_align = MAX (base_align, DECL_ALIGN (decl));\n+\t      DECL_SIZE (decl)\n+\t\t= size_int (MAX (TREE_INT_CST_LOW (DECL_SIZE (decl)),\n+\t\t\t\t (int) base_align));\n+\t    }\n+\t}\n+    }\n+\n+  /* Reverse the list of fields so we allocate the bases in the proper\n+     order.  */\n+  base_decls = nreverse (base_decls);\n+\n+  /* In the presence of empty base classes, we run the risk of allocating\n+     two objects of the same class on top of one another.  Avoid that.  */\n+  if (flag_new_abi && saw_empty)\n+    for (decl = base_decls; decl; decl = TREE_CHAIN (decl))\n+      {\n+\tif (DECL_SIZE (decl) == integer_zero_node)\n+\t  {\n+\t    /* First step through the following bases until we find\n+\t       an overlap or a non-empty base.  */\n+\t    for (nextdecl = TREE_CHAIN (decl); nextdecl;\n+\t\t nextdecl = TREE_CHAIN (nextdecl))\n+\t      {\n+\t\tif (avoid_overlap (decl, nextdecl, empty_p)\n+\t\t    || DECL_SIZE (nextdecl) != integer_zero_node)\n+\t\t  goto nextbase;\n+\t      }\n+\n+\t    /* If we're still looking, also check against the first\n+\t       field.  */\n+\t    for (nextdecl = TYPE_FIELDS (rec);\n+\t\t nextdecl && TREE_CODE (nextdecl) != FIELD_DECL;\n+\t\t nextdecl = TREE_CHAIN (nextdecl))\n+\t      /* keep looking */;\n+\t    avoid_overlap (decl, nextdecl, empty_p);\n+\t  }\n+      nextbase:;\n+      }\n+\n+  return base_decls;\n+}\n+\n /* Go through the TYPE_METHODS of T issuing any appropriate\n    diagnostics, figuring out which methods override which other\n    methods, and so forth.  Returns non-zero if this class has any\n@@ -3800,6 +3968,80 @@ remove_zero_width_bit_fields (t)\n     }\n }\n \n+/* Check the validity of the bases and members declared in T.  Add any\n+   implicitly-generated functions (like copy-constructors and\n+   assignment operators).  Compute various flag bits (like\n+   CLASSTYPE_NON_POD_T) for T.  This routine works purely at the C++\n+   level: i.e., independently of the ABI in use.  */\n+\n+static void\n+check_bases_and_members (t, empty_p)\n+     tree t;\n+     int *empty_p;\n+{\n+  /* Nonzero if we are not allowed to generate a default constructor\n+     for this case.  */\n+  int cant_have_default_ctor;\n+  /* Nonzero if the implicitly generated copy constructor should take\n+     a non-const reference argument.  */\n+  int cant_have_const_ctor;\n+  /* Nonzero if the the implicitly generated assignment operator\n+     should take a non-const reference argument.  */\n+  int no_const_asn_ref;\n+  tree access_decls;\n+\n+  /* By default, we use const reference arguments and generate default\n+     constructors.  */\n+  cant_have_default_ctor = 0;\n+  cant_have_const_ctor = 0;\n+  no_const_asn_ref = 0;\n+\n+  /* Check all the base-classes. */\n+  check_bases (t, &cant_have_default_ctor, &cant_have_const_ctor,\n+\t       &no_const_asn_ref);\n+\n+  /* Check all the data member declarations.  */\n+  check_field_decls (t, &access_decls, empty_p,\n+\t\t     &cant_have_default_ctor,\n+\t\t     &cant_have_const_ctor,\n+\t\t     &no_const_asn_ref);\n+\n+  /* Check all the method declarations.  */\n+  check_methods (t);\n+\n+  /* Do some bookkeeping that will guide the generation of implicitly\n+     declared member functions.  */\n+  TYPE_HAS_COMPLEX_INIT_REF (t)\n+    |= (TYPE_HAS_INIT_REF (t) || TYPE_USES_VIRTUAL_BASECLASSES (t));\n+  TYPE_NEEDS_CONSTRUCTING (t)\n+    |= (TYPE_HAS_CONSTRUCTOR (t) || TYPE_USES_VIRTUAL_BASECLASSES (t));\n+  CLASSTYPE_NON_AGGREGATE (t) |= TYPE_HAS_CONSTRUCTOR (t);\n+  CLASSTYPE_NON_POD_P (t)\n+    |= (CLASSTYPE_NON_AGGREGATE (t) || TYPE_HAS_DESTRUCTOR (t) \n+\t|| TYPE_HAS_ASSIGN_REF (t));\n+  TYPE_HAS_REAL_ASSIGN_REF (t) |= TYPE_HAS_ASSIGN_REF (t);\n+  TYPE_HAS_COMPLEX_ASSIGN_REF (t)\n+    |= TYPE_HAS_ASSIGN_REF (t) || TYPE_USES_VIRTUAL_BASECLASSES (t);\n+\n+  /* Synthesize any needed methods.  Note that methods will be synthesized\n+     for anonymous unions; grok_x_components undoes that.  */\n+  add_implicitly_declared_members (t, cant_have_default_ctor,\n+\t\t\t\t   cant_have_const_ctor,\n+\t\t\t\t   no_const_asn_ref);\n+\n+  /* Build and sort the CLASSTYPE_METHOD_VEC.  */\n+  finish_struct_methods (t);\n+\n+  /* Process the access-declarations.  We wait until now to do this\n+     because handle_using_decls requires that the CLASSTYPE_METHOD_VEC\n+     be set up correctly.  */\n+  while (access_decls)\n+    {\n+      handle_using_decl (TREE_VALUE (access_decls), t);\n+      access_decls = TREE_CHAIN (access_decls);\n+    }\n+}\n+\n /* Create a RECORD_TYPE or UNION_TYPE node for a C struct or union declaration\n    (or C++ class declaration).\n \n@@ -3831,28 +4073,20 @@ void\n finish_struct_1 (t)\n      tree t;\n {\n-  tree fields;\n   tree x;\n-  tree *next_field;\n   int has_virtual;\n   int max_has_virtual;\n   tree pending_virtuals = NULL_TREE;\n   tree pending_hard_virtuals = NULL_TREE;\n   tree vfield;\n   tree vfields;\n-  tree virtual_dtor;\n-  int cant_have_default_ctor;\n-  int cant_have_const_ctor;\n-  int no_const_asn_ref;\n   int n_fields = 0;\n \n   /* The index of the first base class which has virtual\n      functions.  Only applied to non-virtual baseclasses.  */\n   int first_vfn_base_index;\n \n   int n_baseclasses;\n-  tree access_decls;\n-  int aggregate = 1;\n   int empty = 1;\n   tree inline_friends;\n \n@@ -3874,8 +4108,25 @@ finish_struct_1 (t)\n   TYPE_SIZE (t) = NULL_TREE;\n   CLASSTYPE_GOT_SEMICOLON (t) = 0;\n \n+  first_vfn_base_index = -1;\n+  has_virtual = 0;\n+  max_has_virtual = 0;\n+  vfield = NULL_TREE;\n+  vfields = NULL_TREE;\n+  CLASSTYPE_RTTI (t) = NULL_TREE;\n   n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n \n+  /* Do end-of-class semantic processing: checking the validity of the\n+     bases and members and adding implicitly generated methods.  */\n+  check_bases_and_members (t, &empty);\n+\n+  /* Add pointers to all of our virtual base-classes.  */\n+  TYPE_FIELDS (t) = chainon (build_vbase_pointer_fields (t, &empty),\n+\t\t\t     TYPE_FIELDS (t));\n+  /* Build FIELD_DECLs for all of the non-virtual base-types.  */\n+  TYPE_FIELDS (t) = chainon (build_base_fields (t, &empty), \n+\t\t\t     TYPE_FIELDS (t));\n+\n   if (n_baseclasses > 0)\n     {\n       struct base_info base_info;\n@@ -3890,91 +4141,15 @@ finish_struct_1 (t)\n       vfields = base_info.vfields;\n       CLASSTYPE_VFIELDS (t) = vfields;\n       CLASSTYPE_RTTI (t) = base_info.rtti;\n-      cant_have_default_ctor = base_info.cant_have_default_ctor;\n-      cant_have_const_ctor = base_info.cant_have_const_ctor;\n-      no_const_asn_ref = base_info.no_const_asn_ref;\n-      aggregate = 0;\n-    }\n-  else\n-    {\n-      first_vfn_base_index = -1;\n-      has_virtual = 0;\n-      max_has_virtual = 0;\n-      vfield = NULL_TREE;\n-      vfields = NULL_TREE;\n-      CLASSTYPE_RTTI (t) = NULL_TREE;\n-      cant_have_default_ctor = 0;\n-      cant_have_const_ctor = 0;\n-      no_const_asn_ref = 0;\n-    }\n-\n-  /* Check all the data member declarations.  */\n-  next_field = check_field_decls (t, &access_decls, &empty,\n-\t\t\t\t  &cant_have_default_ctor,\n-\t\t\t\t  &cant_have_const_ctor,\n-\t\t\t\t  &no_const_asn_ref);\n-\n-  /* Add pointers to all of our virtual base-classes.  */\n-  if (n_baseclasses)\n-    TYPE_FIELDS (t) = chainon (build_vbase_pointer_fields (t, &empty),\n-\t\t\t       TYPE_FIELDS (t));\n-\n-  /* Build FIELD_DECLs for all of the non-virtual base-types.  */\n-  fields = TYPE_FIELDS (t);\n-  if (n_baseclasses)\n-    {\n-      TYPE_FIELDS (t) = chainon (build_base_fields (t), TYPE_FIELDS (t));\n-\n-      /* If any base is non-empty, then we are non-empty.  */\n-      for (x = TYPE_FIELDS (t); empty && x != fields; x = TREE_CHAIN (x))\n-\tif (DECL_SIZE (x) != integer_zero_node)\n-\t  empty = 0;\n-\n-      fields = TYPE_FIELDS (t);\n     }\n \n-  /* Check all the method declarations.  */\n-  check_methods (t);\n-\n-  /* Do some bookkeeping that will guide the generation of implicitly\n-     declared member functions.  */\n-  TYPE_HAS_COMPLEX_INIT_REF (t)\n-    |= (TYPE_HAS_INIT_REF (t) || TYPE_USES_VIRTUAL_BASECLASSES (t));\n-  TYPE_NEEDS_CONSTRUCTING (t)\n-    |= (TYPE_HAS_CONSTRUCTOR (t) || TYPE_USES_VIRTUAL_BASECLASSES (t));\n-  CLASSTYPE_NON_AGGREGATE (t)\n-      = ! aggregate || TYPE_HAS_CONSTRUCTOR (t);\n-  CLASSTYPE_NON_POD_P (t)\n-    |= (CLASSTYPE_NON_AGGREGATE (t) || TYPE_HAS_DESTRUCTOR (t) \n-\t|| TYPE_HAS_ASSIGN_REF (t));\n-  TYPE_HAS_REAL_ASSIGN_REF (t) |= TYPE_HAS_ASSIGN_REF (t);\n-  TYPE_HAS_COMPLEX_ASSIGN_REF (t)\n-    |= TYPE_HAS_ASSIGN_REF (t) || TYPE_USES_VIRTUAL_BASECLASSES (t);\n-\n-  /* Synthesize any needed methods.  Note that methods will be synthesized\n-     for anonymous unions; grok_x_components undoes that.  */\n-  virtual_dtor \n-    = add_implicitly_declared_members (t, cant_have_default_ctor,\n-\t\t\t\t       cant_have_const_ctor,\n-\t\t\t\t       no_const_asn_ref);\n-\n   /* Loop over the virtual functions, adding them to our various\n      vtables.  */\n   for (x = TYPE_METHODS (t); x; x = TREE_CHAIN (x))\n     if (DECL_VINDEX (x))\n       add_virtual_function (&pending_virtuals, &pending_hard_virtuals,\n \t\t\t    &has_virtual, x, t);\n \n-  /* Build and sort the CLASSTYPE_METHOD_VEC.  */\n-  finish_struct_methods (t);\n-\n-  /* Process the access-declarations.  */\n-  while (access_decls)\n-    {\n-      handle_using_decl (TREE_VALUE (access_decls), t);\n-      access_decls = TREE_CHAIN (access_decls);\n-    }\n-\n   if (vfield == NULL_TREE && has_virtual)\n     {\n       /* We build this decl with vtbl_ptr_type_node, which is a\n@@ -4002,7 +4177,7 @@ finish_struct_1 (t)\n \t\t\t\t\t  t,\n \t\t\t\t\t  &empty);\n       TYPE_VFIELD (t) = vfield;\n-      *next_field = vfield;\n+      TYPE_FIELDS (t) = chainon (TYPE_FIELDS (t), vfield);\n       vfields = chainon (vfields, build_tree_list (NULL_TREE, t));\n     }\n \n@@ -4046,8 +4221,6 @@ finish_struct_1 (t)\n     CLASSTYPE_SIZE (t) = TYPE_SIZE (t);\n   CLASSTYPE_ALIGN (t) = TYPE_ALIGN (t);\n \n-  finish_struct_anon (t);\n-\n   /* Set the TYPE_DECL for this type to contain the right\n      value for DECL_OFFSET, so that we can use it as part\n      of a COMPONENT_REF for multiple inheritance.  */"}, {"sha": "0fefc7d7fcd089d93658a5e9461a16c8483db966", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/607cf13135fdf7c664bb26f7cf2c5b3c18204f96/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/607cf13135fdf7c664bb26f7cf2c5b3c18204f96/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=607cf13135fdf7c664bb26f7cf2c5b3c18204f96", "patch": "@@ -1388,7 +1388,8 @@ struct lang_type\n /* The number of virtual functions defined for this\n    _CLASSTYPE node.  */\n #define CLASSTYPE_VSIZE(NODE) (TYPE_LANG_SPECIFIC(NODE)->vsize)\n-/* The virtual base classes that this type uses.  */\n+/* The direct and indirect virtual base classes that this type uses in\n+   depth-first left-to-right order.  */\n #define CLASSTYPE_VBASECLASSES(NODE) (TYPE_LANG_SPECIFIC(NODE)->vbases)\n /* The virtual function pointer fields that this type contains.  */\n #define CLASSTYPE_VFIELDS(NODE) (TYPE_LANG_SPECIFIC(NODE)->vfields)\n@@ -4012,7 +4013,6 @@ extern tree build_cplus_method_type\t\tPROTO((tree, tree, tree));\n extern tree build_cplus_staticfn_type\t\tPROTO((tree, tree, tree));\n extern tree build_cplus_array_type\t\tPROTO((tree, tree));\n extern int layout_basetypes\t\t\tPROTO((tree, int));\n-extern tree build_base_fields\t\t\tPROTO((tree));\n extern tree hash_tree_cons\t\t\tPROTO((tree, tree, tree));\n extern tree hash_tree_chain\t\t\tPROTO((tree, tree));\n extern tree hash_chainon\t\t\tPROTO((tree, tree));"}, {"sha": "48732850a95302f74ed2c0d9ef5b44b4ca58f15a", "filename": "gcc/cp/method.c", "status": "modified", "additions": 28, "deletions": 36, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/607cf13135fdf7c664bb26f7cf2c5b3c18204f96/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/607cf13135fdf7c664bb26f7cf2c5b3c18204f96/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=607cf13135fdf7c664bb26f7cf2c5b3c18204f96", "patch": "@@ -98,6 +98,7 @@ static int is_back_referenceable_type PROTO((tree));\n static int check_btype PROTO((tree));\n static void build_mangled_name_for_type PROTO((tree));\n static void build_mangled_name_for_type_with_Gcode PROTO((tree, int));\n+static void fixup_pending_inline PROTO((struct pending_inline *));\n \n # define OB_INIT() (scratch_firstobj ? (obstack_free (&scratch_obstack, scratch_firstobj), 0) : 0)\n # define OB_PUTC(C) (obstack_1grow (&scratch_obstack, (C)))\n@@ -142,6 +143,27 @@ init_method ()\n    value.  */\n static char digit_buffer[128];\n \n+/* Fixup the inline function given by INFO now that the class is\n+   complete.  */\n+\n+static void\n+fixup_pending_inline (info)\n+     struct pending_inline *info;\n+{\n+  if (info)\n+    {\n+      tree args;\n+      tree fn = info->fndecl;\n+\n+      args = DECL_ARGUMENTS (fn);\n+      while (args)\n+\t{\n+\t  DECL_CONTEXT (args) = fn;\n+\t  args = TREE_CHAIN (args);\n+\t}\n+    }\n+}\n+\n /* Move inline function definitions out of structure so that they\n    can be processed normally.  CNAME is the name of the class\n    we are working from, METHOD_LIST is the list of method lists\n@@ -164,43 +186,13 @@ do_inline_function_hair (type, friend_list)\n \tmethod = TREE_VEC_ELT (method, 2);\n     }\n \n-  while (method)\n-    {\n-      /* Do inline member functions.  */\n-      struct pending_inline *info = DECL_PENDING_INLINE_INFO (method);\n-      if (info)\n-\t{\n-\t  tree args;\n-\n-\t  my_friendly_assert (info->fndecl == method, 238);\n-\t  args = DECL_ARGUMENTS (method);\n-\t  while (args)\n-\t    {\n-\t      DECL_CONTEXT (args) = method;\n-\t      args = TREE_CHAIN (args);\n-\t    }\n-\t}\n-      method = TREE_CHAIN (method);\n-    }\n-  while (friend_list)\n-    {\n-      tree fndecl = TREE_VALUE (friend_list);\n-      struct pending_inline *info = DECL_PENDING_INLINE_INFO (fndecl);\n-      if (info)\n-\t{\n-\t  tree args;\n-\n-\t  my_friendly_assert (info->fndecl == fndecl, 239);\n-\t  args = DECL_ARGUMENTS (fndecl);\n-\t  while (args)\n-\t    {\n-\t      DECL_CONTEXT (args) = fndecl;\n-\t      args = TREE_CHAIN (args);\n-\t    }\n-\t}\n+  /* Do inline member functions.  */\n+  for (; method; method = TREE_CHAIN (method))\n+    fixup_pending_inline (DECL_PENDING_INLINE_INFO (method));\n \n-      friend_list = TREE_CHAIN (friend_list);\n-    }\n+  /* Do friends.  */\n+  for (; friend_list; friend_list = TREE_CHAIN (friend_list))\n+    fixup_pending_inline (DECL_PENDING_INLINE_INFO (TREE_VALUE (friend_list)));\n }\n \f\n /* Here is where overload code starts.  */"}, {"sha": "cd837e68a5c8677f9669c64d2a66cc36c6abf21c", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 112, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/607cf13135fdf7c664bb26f7cf2c5b3c18204f96/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/607cf13135fdf7c664bb26f7cf2c5b3c18204f96/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=607cf13135fdf7c664bb26f7cf2c5b3c18204f96", "patch": "@@ -38,7 +38,6 @@ static void list_hash_add PROTO((int, tree));\n static int list_hash PROTO((tree, tree, tree));\n static tree list_hash_lookup PROTO((int, tree, tree, tree));\n static void propagate_binfo_offsets PROTO((tree, tree));\n-static int avoid_overlap PROTO((tree, tree));\n static cp_lvalue_kind lvalue_p_1 PROTO((tree, int));\n static tree no_linkage_helper PROTO((tree *, int *, void *));\n static tree build_srcloc PROTO((char *, int));\n@@ -878,117 +877,6 @@ layout_basetypes (rec, max)\n   return max;\n }\n \n-/* If the empty base field in DECL overlaps with a base of the same type in\n-   NEWDECL, which is either another base field or the first data field of\n-   the class, pad the base just before NEWDECL and return 1.  Otherwise,\n-   return 0.  */\n-\n-static int\n-avoid_overlap (decl, newdecl)\n-     tree decl, newdecl;\n-{\n-  tree field;\n-\n-  if (newdecl == NULL_TREE\n-      || ! types_overlap_p (TREE_TYPE (decl), TREE_TYPE (newdecl)))\n-    return 0;\n-\n-  for (field = decl; TREE_CHAIN (field) && TREE_CHAIN (field) != newdecl;\n-       field = TREE_CHAIN (field))\n-    ;\n-\n-  DECL_SIZE (field) = integer_one_node;\n-\n-  return 1;\n-}\n-\n-/* Returns a list of fields to stand in for the base class subobjects\n-   of REC.  These fields are later removed by layout_basetypes.  */\n-\n-tree\n-build_base_fields (rec)\n-     tree rec;\n-{\n-  /* Chain to hold all the new FIELD_DECLs which stand in for base class\n-     subobjects.  */\n-  tree base_decls = NULL_TREE;\n-  tree binfos = TYPE_BINFO_BASETYPES (rec);\n-  int n_baseclasses = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-  tree decl, nextdecl;\n-  int i, saw_empty = 0;\n-  unsigned int base_align = 0;\n-\n-  for (i = 0; i < n_baseclasses; ++i)\n-    {\n-      register tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      register tree basetype = BINFO_TYPE (base_binfo);\n-\n-      if (TYPE_SIZE (basetype) == 0)\n-\t/* This error is now reported in xref_tag, thus giving better\n-\t   location information.  */\n-\tcontinue;\n-\n-      if (TREE_VIA_VIRTUAL (base_binfo))\n-\tcontinue;\n-\n-      decl = build_lang_decl (FIELD_DECL, NULL_TREE, basetype);\n-      DECL_ARTIFICIAL (decl) = 1;\n-      DECL_FIELD_CONTEXT (decl) = DECL_CLASS_CONTEXT (decl) = rec;\n-      DECL_SIZE (decl) = CLASSTYPE_SIZE (basetype);\n-      DECL_ALIGN (decl) = CLASSTYPE_ALIGN (basetype);\n-      TREE_CHAIN (decl) = base_decls;\n-      base_decls = decl;\n-\n-      if (! flag_new_abi)\n-\t{\n-\t  /* Brain damage for backwards compatibility.  For no good reason,\n-\t     the old layout_basetypes made every base at least as large as\n-\t     the alignment for the bases up to that point, gratuitously\n-\t     wasting space.  So we do the same thing here.  */\n-\t  base_align = MAX (base_align, DECL_ALIGN (decl));\n-\t  DECL_SIZE (decl)\n-\t    = size_int (MAX (TREE_INT_CST_LOW (DECL_SIZE (decl)),\n-\t\t\t     (int) base_align));\n-\t}\n-      else if (DECL_SIZE (decl) == integer_zero_node)\n-\tsaw_empty = 1;\n-    }\n-\n-  /* Reverse the list of fields so we allocate the bases in the proper\n-     order.  */\n-  base_decls = nreverse (base_decls);\n-\n-  /* In the presence of empty base classes, we run the risk of allocating\n-     two objects of the same class on top of one another.  Avoid that.  */\n-  if (flag_new_abi && saw_empty)\n-    for (decl = base_decls; decl; decl = TREE_CHAIN (decl))\n-      {\n-\tif (DECL_SIZE (decl) == integer_zero_node)\n-\t  {\n-\t    /* First step through the following bases until we find\n-\t       an overlap or a non-empty base.  */\n-\t    for (nextdecl = TREE_CHAIN (decl); nextdecl;\n-\t\t nextdecl = TREE_CHAIN (nextdecl))\n-\t      {\n-\t\tif (avoid_overlap (decl, nextdecl)\n-\t\t    || DECL_SIZE (nextdecl) != integer_zero_node)\n-\t\t  goto nextbase;\n-\t      }\n-\n-\t    /* If we're still looking, also check against the first\n-\t       field.  */\n-\t    for (nextdecl = TYPE_FIELDS (rec);\n-\t\t nextdecl && TREE_CODE (nextdecl) != FIELD_DECL;\n-\t\t nextdecl = TREE_CHAIN (nextdecl))\n-\t      /* keep looking */;\n-\t    avoid_overlap (decl, nextdecl);\n-\t  }\n-      nextbase:;\n-      }\n-\n-  return base_decls;\n-}\n-\n \f\n /* Hashing of lists so that we don't make duplicates.\n    The entry point is `list_hash_canon'.  */"}]}