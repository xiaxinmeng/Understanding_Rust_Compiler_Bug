{"sha": "0a5cbff6d4d8aaae40d37e526e1fcbfdc42c12b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGE1Y2JmZjZkNGQ4YWFhZTQwZDM3ZTUyNmUxZmNiZmRjNDJjMTJiMw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-11T10:39:54Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-11T10:39:54Z"}, "message": "(make_compound_operation, case xSHIFTRT):\n\nClean up code so more readable and don't restrict to case where C2 >= C1.\nPass correct (inner) code to recursive call.\n(make_compound_operation, case SUBREG): Pass the code of our operand\nto recursive call, not SUBREG, and make another recursive call after\ncalling force_to_mode.\n\nFrom-SVN: r4082", "tree": {"sha": "6b5b83cb7d0004f56d16d4e1fb7f15055106eacd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b5b83cb7d0004f56d16d4e1fb7f15055106eacd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a5cbff6d4d8aaae40d37e526e1fcbfdc42c12b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a5cbff6d4d8aaae40d37e526e1fcbfdc42c12b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a5cbff6d4d8aaae40d37e526e1fcbfdc42c12b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a5cbff6d4d8aaae40d37e526e1fcbfdc42c12b3/comments", "author": null, "committer": null, "parents": [{"sha": "f2dd837227913a70e3cd839c850c0346e7706950", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2dd837227913a70e3cd839c850c0346e7706950", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2dd837227913a70e3cd839c850c0346e7706950"}], "stats": {"total": 51, "additions": 37, "deletions": 14}, "files": [{"sha": "a33bcc1e2930c8f375d13e077d167b844ef3c78c", "filename": "gcc/combine.c", "status": "modified", "additions": 37, "deletions": 14, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a5cbff6d4d8aaae40d37e526e1fcbfdc42c12b3/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a5cbff6d4d8aaae40d37e526e1fcbfdc42c12b3/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=0a5cbff6d4d8aaae40d37e526e1fcbfdc42c12b3", "patch": "@@ -5134,25 +5134,38 @@ make_compound_operation (x, in_code)\n \t      || GET_CODE (XEXP (x, 0)) == PLUS)\n \t  && GET_CODE (XEXP (XEXP (x, 0), 0)) == ASHIFT\n \t  && GET_CODE (XEXP (XEXP (XEXP (x, 0), 0), 1)) == CONST_INT\n-\t  && INTVAL (XEXP (x, 1)) >= INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1))\n \t  && INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1)) < HOST_BITS_PER_WIDE_INT\n \t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n-\t  && (INTVAL (XEXP (XEXP (x, 0), 1))\n-\t      & (((HOST_WIDE_INT) 1\n-\t\t  << INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1))) - 1)) == 0)\n+\t  && 0 == (INTVAL (XEXP (XEXP (x, 0), 1))\n+\t\t   & (((HOST_WIDE_INT) 1\n+\t\t       << (MIN (INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1)),\n+\t\t\t\tINTVAL (XEXP (x, 1)))\n+\t\t\t   - 1)))))\n \t{\n-\t  HOST_WIDE_INT newop1\n-\t    = (INTVAL (XEXP (XEXP (x, 0), 1))\n-\t       >> INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1)));\n+\t  rtx c1 = XEXP (XEXP (XEXP (x, 0), 0), 1);\n+\t  rtx c2 = XEXP (x, 1);\n+\t  rtx c3 = XEXP (XEXP (x, 0), 1);\n+\t  HOST_WIDE_INT newop1;\n+\t  rtx inner = XEXP (XEXP (XEXP (x, 0), 0), 0);\n+\n+\t  /* If C1 > C2, INNER needs to have the shift performed on it\n+\t     for C1-C2 bits.  */\n+\t  if (INTVAL (c1) > INTVAL (c2))\n+\t    {\n+\t      inner = gen_binary (ASHIFT, mode, inner,\n+\t\t\t\t  GEN_INT (INTVAL (c1) - INTVAL (c2)));\n+\t      c1 = c2;\n+\t    }\n \n-\t  new = make_compound_operation (XEXP (XEXP (XEXP (x, 0), 0), 0),\n-\t\t\t\t\t next_code);\n+\t  newop1 = INTVAL (c3) >> INTVAL (c1);\n+\t  new = make_compound_operation (inner,\n+\t\t\t\t\t GET_CODE (XEXP (x, 0)) == PLUS\n+\t\t\t\t\t ? MEM : GET_CODE (XEXP (x, 0)));\n \t  new = make_extraction (mode,\n \t\t\t\t gen_binary (GET_CODE (XEXP (x, 0)), mode, new,\n \t\t\t\t\t     GEN_INT (newop1)),\n-\t\t\t\t (INTVAL (XEXP (x, 1))\n-\t\t\t\t  - INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1))),\n-\t\t\t\t NULL_RTX, mode_width - INTVAL (XEXP (x, 1)),\n+\t\t\t\t INTVAL (c2) - INTVAL (c1),\n+\t\t\t\t NULL_RTX, mode_width - INTVAL (c1),\n \t\t\t\t code == LSHIFTRT, 0, in_code == COMPARE);\n \t}\n \n@@ -5180,11 +5193,21 @@ make_compound_operation (x, in_code)\n \t narrowing the object and it has a different RTL code from\n \t what it originally did, do this SUBREG as a force_to_mode.  */\n \n-      tem = make_compound_operation (SUBREG_REG (x), next_code);\n+      tem = make_compound_operation (SUBREG_REG (x), in_code);\n       if (GET_CODE (tem) != GET_CODE (SUBREG_REG (x))\n \t  && GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (tem))\n \t  && subreg_lowpart_p (x))\n-\treturn force_to_mode (tem, mode, GET_MODE_BITSIZE (mode), NULL_RTX);\n+\t{\n+\t  rtx newer = force_to_mode (tem, mode,\n+\t\t\t\t     GET_MODE_BITSIZE (mode), NULL_RTX);\n+\n+\t  /* If we have something other than a SUBREG, we might have\n+\t     done an expansion, so rerun outselves.  */\n+\t  if (GET_CODE (newer) != SUBREG)\n+\t    newer = make_compound_operation (newer, in_code);\n+\n+\t  return newer;\n+\t}\n     }\n \n   if (new)"}]}