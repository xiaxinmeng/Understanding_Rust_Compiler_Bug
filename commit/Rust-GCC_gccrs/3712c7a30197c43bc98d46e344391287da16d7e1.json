{"sha": "3712c7a30197c43bc98d46e344391287da16d7e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzcxMmM3YTMwMTk3YzQzYmM5OGQ0NmUzNDQzOTEyODdkYTE2ZDdlMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2016-11-15T18:13:56Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2016-11-15T18:13:56Z"}, "message": "Add a load_extend_op wrapper\n\nLOAD_EXTEND_OP only applies to scalar integer modes that are narrower\nthan a word.  However, callers weren't consistent about which of these\nchecks they made beforehand, and also weren't consistent about whether\n\"smaller\" was based on (bit)size or precision (IMO it's the latter).\nThis patch adds a wrapper to try to make the macro easier to use.\n\nLOAD_EXTEND_OP is often used to disable transformations that aren't\nbeneficial when extends from memory are free, so being stricter about\nthe check accidentally exposed more optimisation opportunities.\n\n\"SUBREG_BYTE (...) == 0\" and subreg_lowpart_p are implied by\nparadoxical_subreg_p, so the patch also removes some redundant tests.\n\nThe patch doesn't change reload, since different checks could have\nunforeseen consequences.\n\ngcc/\n2016-11-15  Richard Sandiford  <richard.sandiford@arm.com>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\n\t* rtl.h (load_extend_op): Declare.\n\t* rtlanal.c (load_extend_op): New function.\n\t(nonzero_bits1): Use it.\n\t(num_sign_bit_copies1): Likewise.\n\t* cse.c (cse_insn): Likewise.\n\t* fold-const.c (fold_single_bit_test): Likewise.\n\t(fold_unary_loc): Likewise.\n\t* fwprop.c (free_load_extend): Likewise.\n\t* postreload.c (reload_cse_simplify_set): Likewise.\n\t(reload_cse_simplify_operands): Likewise.\n\t* combine.c (try_combine): Likewise.\n\t(simplify_set): Likewise.  Remove redundant SUBREG_BYTE and\n\tsubreg_lowpart_p checks.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r242444", "tree": {"sha": "63471b5de9227424f4f00e145e723c459b6e6b3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63471b5de9227424f4f00e145e723c459b6e6b3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3712c7a30197c43bc98d46e344391287da16d7e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3712c7a30197c43bc98d46e344391287da16d7e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3712c7a30197c43bc98d46e344391287da16d7e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3712c7a30197c43bc98d46e344391287da16d7e1/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ba3c3dc0702eca06bde4841e3bbdf0d428b71968", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba3c3dc0702eca06bde4841e3bbdf0d428b71968", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba3c3dc0702eca06bde4841e3bbdf0d428b71968"}], "stats": {"total": 89, "additions": 56, "deletions": 33}, "files": [{"sha": "0a2dd3cd71e39fb6b32af15167e1e6040f65ae6e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3712c7a30197c43bc98d46e344391287da16d7e1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3712c7a30197c43bc98d46e344391287da16d7e1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3712c7a30197c43bc98d46e344391287da16d7e1", "patch": "@@ -1,3 +1,21 @@\n+2016-11-15  Richard Sandiford  <richard.sandiford@arm.com>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* rtl.h (load_extend_op): Declare.\n+\t* rtlanal.c (load_extend_op): New function.\n+\t(nonzero_bits1): Use it.\n+\t(num_sign_bit_copies1): Likewise.\n+\t* cse.c (cse_insn): Likewise.\n+\t* fold-const.c (fold_single_bit_test): Likewise.\n+\t(fold_unary_loc): Likewise.\n+\t* fwprop.c (free_load_extend): Likewise.\n+\t* postreload.c (reload_cse_simplify_set): Likewise.\n+\t(reload_cse_simplify_operands): Likewise.\n+\t* combine.c (try_combine): Likewise.\n+\t(simplify_set): Likewise.  Remove redundant SUBREG_BYTE and\n+\tsubreg_lowpart_p checks.\n+\n 2016-11-15  Richard Sandiford  <richard.sandiford@arm.com>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "19ef52f70dda440c1a36032993b14fc914c4287f", "filename": "gcc/combine.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3712c7a30197c43bc98d46e344391287da16d7e1/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3712c7a30197c43bc98d46e344391287da16d7e1/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=3712c7a30197c43bc98d46e344391287da16d7e1", "patch": "@@ -3738,7 +3738,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t    {\n \t      /* Or as a SIGN_EXTEND if LOAD_EXTEND_OP says that that's\n \t\t what it really is.  */\n-\t      if (LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (*split)))\n+\t      if (load_extend_op (GET_MODE (SUBREG_REG (*split)))\n \t\t  == SIGN_EXTEND)\n \t\tSUBST (*split, gen_rtx_SIGN_EXTEND (split_mode,\n \t\t\t\t\t\t    SUBREG_REG (*split)));\n@@ -6785,16 +6785,13 @@ simplify_set (rtx x)\n      would require a paradoxical subreg.  Replace the subreg with a\n      zero_extend to avoid the reload that would otherwise be required.  */\n \n-  if (GET_CODE (src) == SUBREG && subreg_lowpart_p (src)\n-      && INTEGRAL_MODE_P (GET_MODE (SUBREG_REG (src)))\n-      && LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (src))) != UNKNOWN\n-      && SUBREG_BYTE (src) == 0\n-      && paradoxical_subreg_p (src)\n-      && MEM_P (SUBREG_REG (src)))\n+  enum rtx_code extend_op;\n+  if (paradoxical_subreg_p (src)\n+      && MEM_P (SUBREG_REG (src))\n+      && (extend_op = load_extend_op (GET_MODE (SUBREG_REG (src)))) != UNKNOWN)\n     {\n       SUBST (SET_SRC (x),\n-\t     gen_rtx_fmt_e (LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (src))),\n-\t\t\t    GET_MODE (src), SUBREG_REG (src)));\n+\t     gen_rtx_fmt_e (extend_op, GET_MODE (src), SUBREG_REG (src)));\n \n       src = SET_SRC (x);\n     }"}, {"sha": "72f1c4f6a9e378a71429b335c7a2e5b112ac76c0", "filename": "gcc/cse.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3712c7a30197c43bc98d46e344391287da16d7e1/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3712c7a30197c43bc98d46e344391287da16d7e1/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=3712c7a30197c43bc98d46e344391287da16d7e1", "patch": "@@ -4915,11 +4915,10 @@ cse_insn (rtx_insn *insn)\n \t also have such operations, but this is only likely to be\n \t beneficial on these machines.  */\n \n+      rtx_code extend_op;\n       if (flag_expensive_optimizations && src_related == 0\n-\t  && (GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n-\t  && GET_MODE_CLASS (mode) == MODE_INT\n \t  && MEM_P (src) && ! do_not_record\n-\t  && LOAD_EXTEND_OP (mode) != UNKNOWN)\n+\t  && (extend_op = load_extend_op (mode)) != UNKNOWN)\n \t{\n \t  struct rtx_def memory_extend_buf;\n \t  rtx memory_extend_rtx = &memory_extend_buf;\n@@ -4928,7 +4927,7 @@ cse_insn (rtx_insn *insn)\n \t  /* Set what we are trying to extend and the operation it might\n \t     have been extended with.  */\n \t  memset (memory_extend_rtx, 0, sizeof (*memory_extend_rtx));\n-\t  PUT_CODE (memory_extend_rtx, LOAD_EXTEND_OP (mode));\n+\t  PUT_CODE (memory_extend_rtx, extend_op);\n \t  XEXP (memory_extend_rtx, 0) = src;\n \n \t  for (tmode = GET_MODE_WIDER_MODE (mode);"}, {"sha": "c59741440afb41adf488142e6fd36de33a6cdb4c", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3712c7a30197c43bc98d46e344391287da16d7e1/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3712c7a30197c43bc98d46e344391287da16d7e1/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=3712c7a30197c43bc98d46e344391287da16d7e1", "patch": "@@ -6725,7 +6725,7 @@ fold_single_bit_test (location_t loc, enum tree_code code,\n       /* If we are going to be able to omit the AND below, we must do our\n \t operations as unsigned.  If we must use the AND, we have a choice.\n \t Normally unsigned is faster, but for some machines signed is.  */\n-      ops_unsigned = (LOAD_EXTEND_OP (operand_mode) == SIGN_EXTEND\n+      ops_unsigned = (load_extend_op (operand_mode) == SIGN_EXTEND\n \t\t      && !flag_syntax_only) ? 0 : 1;\n \n       signed_type = lang_hooks.types.type_for_mode (operand_mode, 0);\n@@ -7775,7 +7775,7 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n \t      change = (cst == 0);\n \t      if (change\n \t\t  && !flag_syntax_only\n-\t\t  && (LOAD_EXTEND_OP (TYPE_MODE (TREE_TYPE (and0)))\n+\t\t  && (load_extend_op (TYPE_MODE (TREE_TYPE (and0)))\n \t\t      == ZERO_EXTEND))\n \t\t{\n \t\t  tree uns = unsigned_type_for (TREE_TYPE (and0));"}, {"sha": "a3fbb3433ae30c19b75001a7bdba8d4b1d98ed54", "filename": "gcc/fwprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3712c7a30197c43bc98d46e344391287da16d7e1/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3712c7a30197c43bc98d46e344391287da16d7e1/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=3712c7a30197c43bc98d46e344391287da16d7e1", "patch": "@@ -1051,7 +1051,7 @@ free_load_extend (rtx src, rtx_insn *insn)\n   df_ref def, use;\n \n   reg = XEXP (src, 0);\n-  if (LOAD_EXTEND_OP (GET_MODE (reg)) != GET_CODE (src))\n+  if (load_extend_op (GET_MODE (reg)) != GET_CODE (src))\n     return false;\n \n   FOR_EACH_INSN_USE (use, insn)"}, {"sha": "a11d2705dab147ff68d90f1d0a2502f3cbb3703e", "filename": "gcc/postreload.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3712c7a30197c43bc98d46e344391287da16d7e1/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3712c7a30197c43bc98d46e344391287da16d7e1/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=3712c7a30197c43bc98d46e344391287da16d7e1", "patch": "@@ -256,8 +256,7 @@ reload_cse_simplify_set (rtx set, rtx_insn *insn)\n      generating an extend instruction instead of a reg->reg copy.  Thus\n      the destination must be a register that we can widen.  */\n   if (MEM_P (src)\n-      && GET_MODE_BITSIZE (GET_MODE (src)) < BITS_PER_WORD\n-      && (extend_op = LOAD_EXTEND_OP (GET_MODE (src))) != UNKNOWN\n+      && (extend_op = load_extend_op (GET_MODE (src))) != UNKNOWN\n       && !REG_P (SET_DEST (set)))\n     return 0;\n \n@@ -330,8 +329,7 @@ reload_cse_simplify_set (rtx set, rtx_insn *insn)\n \t      && REG_P (this_rtx)\n \t      && !REG_P (SET_SRC (set))))\n \t{\n-\t  if (GET_MODE_BITSIZE (GET_MODE (SET_DEST (set))) < BITS_PER_WORD\n-\t      && extend_op != UNKNOWN\n+\t  if (extend_op != UNKNOWN\n #ifdef CANNOT_CHANGE_MODE_CLASS\n \t      && !CANNOT_CHANGE_MODE_CLASS (GET_MODE (SET_DEST (set)),\n \t\t\t\t\t    word_mode,\n@@ -414,9 +412,7 @@ reload_cse_simplify_operands (rtx_insn *insn, rtx testreg)\n \tcontinue;\n \n       op = recog_data.operand[i];\n-      if (MEM_P (op)\n-\t  && GET_MODE_BITSIZE (GET_MODE (op)) < BITS_PER_WORD\n-\t  && LOAD_EXTEND_OP (GET_MODE (op)) != UNKNOWN)\n+      if (MEM_P (op) && load_extend_op (GET_MODE (op)) != UNKNOWN)\n \t{\n \t  rtx set = single_set (insn);\n \n@@ -449,7 +445,7 @@ reload_cse_simplify_operands (rtx_insn *insn, rtx testreg)\n \t\t   && SET_DEST (set) == recog_data.operand[1-i])\n \t    {\n \t      validate_change (insn, recog_data.operand_loc[i],\n-\t\t\t       gen_rtx_fmt_e (LOAD_EXTEND_OP (GET_MODE (op)),\n+\t\t\t       gen_rtx_fmt_e (load_extend_op (GET_MODE (op)),\n \t\t\t\t\t      word_mode, op),\n \t\t\t       1);\n \t      validate_change (insn, recog_data.operand_loc[1-i],"}, {"sha": "df5172b776901d483c48cd7a90a45d6243a9b759", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3712c7a30197c43bc98d46e344391287da16d7e1/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3712c7a30197c43bc98d46e344391287da16d7e1/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=3712c7a30197c43bc98d46e344391287da16d7e1", "patch": "@@ -2954,6 +2954,7 @@ extern void set_insn_deleted (rtx);\n \n /* Functions in rtlanal.c */\n \n+extern rtx_code load_extend_op (machine_mode);\n extern rtx single_set_2 (const rtx_insn *, const_rtx);\n extern bool contains_symbol_ref_p (const_rtx);\n extern bool contains_symbolic_reference_p (const_rtx);"}, {"sha": "ded337b2ac9671fe373126075c440c5613c758ed", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3712c7a30197c43bc98d46e344391287da16d7e1/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3712c7a30197c43bc98d46e344391287da16d7e1/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=3712c7a30197c43bc98d46e344391287da16d7e1", "patch": "@@ -3861,6 +3861,18 @@ subreg_nregs_with_regno (unsigned int regno, const_rtx x)\n   return info.nregs;\n }\n \n+/* If loads from memories of mode MODE always sign or zero extend,\n+   return SIGN_EXTEND or ZERO_EXTEND as appropriate.  Return UNKNOWN\n+   otherwise.  */\n+\n+rtx_code\n+load_extend_op (machine_mode mode)\n+{\n+  if (SCALAR_INT_MODE_P (mode)\n+      && GET_MODE_PRECISION (mode) < BITS_PER_WORD)\n+    return LOAD_EXTEND_OP (mode);\n+  return UNKNOWN;\n+}\n \n struct parms_set_data\n {\n@@ -4378,7 +4390,7 @@ nonzero_bits1 (const_rtx x, machine_mode mode, const_rtx known_x,\n       /* In many, if not most, RISC machines, reading a byte from memory\n \t zeros the rest of the register.  Noticing that fact saves a lot\n \t of extra zero-extends.  */\n-      if (LOAD_EXTEND_OP (GET_MODE (x)) == ZERO_EXTEND)\n+      if (load_extend_op (GET_MODE (x)) == ZERO_EXTEND)\n \tnonzero &= GET_MODE_MASK (GET_MODE (x));\n       break;\n \n@@ -4581,13 +4593,14 @@ nonzero_bits1 (const_rtx x, machine_mode mode, const_rtx known_x,\n           /* On many CISC machines, accessing an object in a wider mode\n \t     causes the high-order bits to become undefined.  So they are\n \t     not known to be zero.  */\n+\t  rtx_code extend_op;\n \t  if ((!WORD_REGISTER_OPERATIONS\n \t       /* If this is a typical RISC machine, we only have to worry\n \t\t  about the way loads are extended.  */\n-\t\t|| (LOAD_EXTEND_OP (inner_mode) == SIGN_EXTEND\n-\t\t    ? val_signbit_known_set_p (inner_mode, nonzero)\n-\t\t    : LOAD_EXTEND_OP (inner_mode) != ZERO_EXTEND)\n-\t\t|| (!MEM_P (SUBREG_REG (x)) && !REG_P (SUBREG_REG (x))))\n+\t       || ((extend_op = load_extend_op (inner_mode)) == SIGN_EXTEND\n+\t\t   ? val_signbit_known_set_p (inner_mode, nonzero)\n+\t\t   : extend_op != ZERO_EXTEND)\n+\t       || (!MEM_P (SUBREG_REG (x)) && !REG_P (SUBREG_REG (x))))\n \t      && GET_MODE_PRECISION (GET_MODE (x))\n \t\t  > GET_MODE_PRECISION (inner_mode))\n \t    nonzero\n@@ -4832,7 +4845,7 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \t than a word and loads of that size don't sign extend, we can say\n \t nothing about the high order bits.  */\n       if (GET_MODE_PRECISION (GET_MODE (x)) < BITS_PER_WORD\n-\t  && LOAD_EXTEND_OP (GET_MODE (x)) != SIGN_EXTEND)\n+\t  && load_extend_op (GET_MODE (x)) != SIGN_EXTEND)\n \treturn 1;\n     }\n \n@@ -4874,7 +4887,7 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \n     case MEM:\n       /* Some RISC machines sign-extend all loads of smaller than a word.  */\n-      if (LOAD_EXTEND_OP (GET_MODE (x)) == SIGN_EXTEND)\n+      if (load_extend_op (GET_MODE (x)) == SIGN_EXTEND)\n \treturn MAX (1, ((int) bitwidth\n \t\t\t- (int) GET_MODE_PRECISION (GET_MODE (x)) + 1));\n       break;\n@@ -4924,8 +4937,7 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \t to the stack.  */\n \n       if (WORD_REGISTER_OPERATIONS\n-\t  && GET_MODE_PRECISION (inner_mode) <= BITS_PER_WORD\n-\t  && LOAD_EXTEND_OP (inner_mode) == SIGN_EXTEND\n+\t  && load_extend_op (inner_mode) == SIGN_EXTEND\n \t  && paradoxical_subreg_p (x)\n \t  && (MEM_P (SUBREG_REG (x)) || REG_P (SUBREG_REG (x))))\n \treturn cached_num_sign_bit_copies (SUBREG_REG (x), mode,"}]}