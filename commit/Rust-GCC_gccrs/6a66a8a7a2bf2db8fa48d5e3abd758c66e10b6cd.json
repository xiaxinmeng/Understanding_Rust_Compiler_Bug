{"sha": "6a66a8a7a2bf2db8fa48d5e3abd758c66e10b6cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE2NmE4YTdhMmJmMmRiOGZhNDhkNWUzYWJkNzU4YzY2ZTEwYjZjZA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-11-26T06:54:13Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-11-26T06:54:13Z"}, "message": "cfgrtl.c (try_redirect_by_replacing_jump): Speed up the check that tests if all edges go to the same destination.\n\n\t* cfgrtl.c (try_redirect_by_replacing_jump): Speed up the\n\tcheck that tests if all edges go to the same destination.\n\nFrom-SVN: r91334", "tree": {"sha": "9f87a6a1db8557e68bd95fa7b6de583a88b9a66c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f87a6a1db8557e68bd95fa7b6de583a88b9a66c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a66a8a7a2bf2db8fa48d5e3abd758c66e10b6cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a66a8a7a2bf2db8fa48d5e3abd758c66e10b6cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a66a8a7a2bf2db8fa48d5e3abd758c66e10b6cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a66a8a7a2bf2db8fa48d5e3abd758c66e10b6cd/comments", "author": null, "committer": null, "parents": [{"sha": "87c111349fcd0848f506f20fc6d392eca93b8ef5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87c111349fcd0848f506f20fc6d392eca93b8ef5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87c111349fcd0848f506f20fc6d392eca93b8ef5"}], "stats": {"total": 22, "additions": 15, "deletions": 7}, "files": [{"sha": "6ed23714c4bfee6e929b281e758bd599dab37d29", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a66a8a7a2bf2db8fa48d5e3abd758c66e10b6cd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a66a8a7a2bf2db8fa48d5e3abd758c66e10b6cd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6a66a8a7a2bf2db8fa48d5e3abd758c66e10b6cd", "patch": "@@ -1,3 +1,8 @@\n+2004-11-26  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* cfgrtl.c (try_redirect_by_replacing_jump): Speed up the\n+\tcheck that tests if all edges go to the same destination.\n+\n 2004-11-25  Jeff Law  <law@redhat.com>\n \n \t* timevar.def (TV_TREE_LOOP_INIT, TV_TREE_LOOP_FINI): New timevars."}, {"sha": "3ba3265e6830741c898ca0041aa1e76dbd20b020", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a66a8a7a2bf2db8fa48d5e3abd758c66e10b6cd/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a66a8a7a2bf2db8fa48d5e3abd758c66e10b6cd/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=6a66a8a7a2bf2db8fa48d5e3abd758c66e10b6cd", "patch": "@@ -662,10 +662,8 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n {\n   basic_block src = e->src;\n   rtx insn = BB_END (src), kill_from;\n-  edge tmp;\n   rtx set;\n   int fallthru = 0;\n-  edge_iterator ei;\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n@@ -682,12 +680,17 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n \t  || BB_PARTITION (src) != BB_PARTITION (target)))\n     return NULL;\n \n-  /* Verify that all targets will be TARGET.  */\n-  FOR_EACH_EDGE (tmp, ei, src->succs)\n-    if (tmp->dest != target && tmp != e)\n-      break;\n+  /* We can replace or remove a complex jump only when we have exactly\n+     two edges.  Also, if we have exactly one outgoing edge, we can\n+     redirect that.  */\n+  if (EDGE_COUNT (src->succs) >= 3\n+      /* Verify that all targets will be TARGET.  Specifically, the\n+\t edge that is not E must also go to TARGET.  */\n+      || (EDGE_COUNT (src->succs) == 2\n+\t  && EDGE_SUCC (src, EDGE_SUCC (src, 0) == e)->dest != target))\n+    return NULL;\n \n-  if (tmp || !onlyjump_p (insn))\n+  if (!onlyjump_p (insn))\n     return NULL;\n   if ((!optimize || reload_completed) && tablejump_p (insn, NULL, NULL))\n     return NULL;"}]}