{"sha": "58c8adc12700ffb0a3fe9406863c869afe67b99d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NThjOGFkYzEyNzAwZmZiMGEzZmU5NDA2ODYzYzg2OWFmZTY3Yjk5ZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2004-09-29T09:47:56Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2004-09-29T09:47:56Z"}, "message": "tree.h (enum tree_index): Add TI_VA_LIST_GPR_COUNTER_FIELD and TI_VA_LIST_FPR_COUNTER_FIELD.\n\n\t* tree.h (enum tree_index): Add TI_VA_LIST_GPR_COUNTER_FIELD\n\tand TI_VA_LIST_FPR_COUNTER_FIELD.\n\t(va_list_gpr_counter_field, va_list_fpr_counter_field): Define.\n\t* tree-pass.h (pass_stdarg): Add.\n\t* tree-optimize.c (init_tree_optimization_passes): Add pass_stdarg.\n\t* tree-stdarg.c: New file.\n\t* Makefile.in (OBJS-common): Add tree-stdarg.o.\n\t(tree-stdarg.o): Add dependencies.\n\t* function.h (struct function): Add va_list_gpr_size and\n\tva_list_fpr_size fields.\n\t* function.c (allocate_struct_function): Initialize them.\n\n\t* config/i386/i386.c (ix86_build_builtin_va_list): Initialize\n\tva_list_{g,f}pr_counter_field.\n\t(ix86_setup_incoming_varargs): Don't do anything if reg_save\n\tarea will not be used.  Only save registers that tree-stdarg.c\n\tdetected they need saving.\n\t(ix86_va_start): Don't set up fields that won't be used.\n\n\t* config/rs6000/rs6000.c (rs6000_build_builtin_va_list): Initialize\n\tva_list_{g,f}pr_counter_field.\n\t(setup_incoming_varargs): Don't do anything if reg_save\n\tarea will not be used.  Only save registers that tree-stdarg.c\n\tdetected they need saving.\n\t(rs6000_va_start): Don't set up fields that won't be used.\n\n\t* gcc.c-torture/execute/stdarg-1.c: New test.\n\t* gcc.c-torture/execute/stdarg-2.c: New test.\n\t* gcc.c-torture/execute/stdarg-3.c: New test.\n\t* gcc.dg/tree-ssa/stdarg-1.c: New test.\n\t* gcc.dg/tree-ssa/stdarg-2.c: New test.\n\t* gcc.dg/tree-ssa/stdarg-3.c: New test.\n\t* gcc.dg/tree-ssa/stdarg-4.c: New test.\n\t* gcc.dg/tree-ssa/stdarg-5.c: New test.\n\nFrom-SVN: r88279", "tree": {"sha": "2f5e57535f35e97c09560fb2d4e01fcb060d2ad1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f5e57535f35e97c09560fb2d4e01fcb060d2ad1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58c8adc12700ffb0a3fe9406863c869afe67b99d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58c8adc12700ffb0a3fe9406863c869afe67b99d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58c8adc12700ffb0a3fe9406863c869afe67b99d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58c8adc12700ffb0a3fe9406863c869afe67b99d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0d5b215ca1121e4cb99336e48b66be539e137ad9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d5b215ca1121e4cb99336e48b66be539e137ad9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d5b215ca1121e4cb99336e48b66be539e137ad9"}], "stats": {"total": 1542, "additions": 1509, "deletions": 33}, "files": [{"sha": "e4974136b1ed2c03bde002846a681b9a0538ebdf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=58c8adc12700ffb0a3fe9406863c869afe67b99d", "patch": "@@ -1,3 +1,31 @@\n+2004-09-29  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* tree.h (enum tree_index): Add TI_VA_LIST_GPR_COUNTER_FIELD\n+\tand TI_VA_LIST_FPR_COUNTER_FIELD.\n+\t(va_list_gpr_counter_field, va_list_fpr_counter_field): Define.\n+\t* tree-pass.h (pass_stdarg): Add.\n+\t* tree-optimize.c (init_tree_optimization_passes): Add pass_stdarg.\n+\t* tree-stdarg.c: New file.\n+\t* Makefile.in (OBJS-common): Add tree-stdarg.o.\n+\t(tree-stdarg.o): Add dependencies.\n+\t* function.h (struct function): Add va_list_gpr_size and\n+\tva_list_fpr_size fields.\n+\t* function.c (allocate_struct_function): Initialize them.\n+\n+\t* config/i386/i386.c (ix86_build_builtin_va_list): Initialize\n+\tva_list_{g,f}pr_counter_field.\n+\t(ix86_setup_incoming_varargs): Don't do anything if reg_save\n+\tarea will not be used.  Only save registers that tree-stdarg.c\n+\tdetected they need saving.\n+\t(ix86_va_start): Don't set up fields that won't be used.\n+\n+\t* config/rs6000/rs6000.c (rs6000_build_builtin_va_list): Initialize\n+\tva_list_{g,f}pr_counter_field.\n+\t(setup_incoming_varargs): Don't do anything if reg_save\n+\tarea will not be used.  Only save registers that tree-stdarg.c\n+\tdetected they need saving.\n+\t(rs6000_va_start): Don't set up fields that won't be used.\n+\n 2004-09-29  Jakub Jelinek  <jakub@redhat.com>\n \n \t* builtins.def (BUILT_IN_FPUTC, BUILT_IN_FPUTC_UNLOCKED,"}, {"sha": "1f26066519b0d9cf2be0e7706712127952185955", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=58c8adc12700ffb0a3fe9406863c869afe67b99d", "patch": "@@ -925,7 +925,7 @@ OBJS-common = \\\n  varasm.o varray.o vec.o version.o vmsdbgout.o xcoffout.o alloc-pool.o\t   \\\n  et-forest.o cfghooks.o bt-load.o pretty-print.o $(GGC) web.o passes.o\t   \\\n  rtl-profile.o tree-profile.o rtlhooks.o cfgexpand.o lambda-mat.o          \\\n- lambda-trans.o\tlambda-code.o tree-loop-linear.o\n+ lambda-trans.o\tlambda-code.o tree-loop-linear.o tree-stdarg.o\n \n OBJS-md = $(out_object_file)\n OBJS-archive = $(EXTRA_OBJS) $(host_hook_obj) tree-inline.o\t\t   \\\n@@ -1772,6 +1772,8 @@ tree-loop-linear.o: tree-loop-linear.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_\n    errors.h $(GGC_H) $(OPTABS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) diagnostic.h \\\n    $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) cfgloop.h tree-pass.h \\\n    $(TREE_DATA_REF_H) $(SCEV_H)\n+tree-stdarg.o: tree-stdarg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(TREE_H) function.h diagnostic.h $(TREE_FLOW_H) tree-pass.h\n tree-gimple.o : tree-gimple.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(EXPR_H) \\\n \t$(RTL_H) $(TREE_GIMPLE_H) $(TM_H) coretypes.h bitmap.h $(GGC_H)\n tree-mudflap.o : $(CONFIG_H) errors.h $(SYSTEM_H) $(TREE_H) tree-inline.h \\"}, {"sha": "3d43cdd645f31bd54bc73f2df2b25bc7d7675847", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 34, "deletions": 16, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=58c8adc12700ffb0a3fe9406863c869afe67b99d", "patch": "@@ -3097,6 +3097,9 @@ ix86_build_builtin_va_list (void)\n   f_sav = build_decl (FIELD_DECL, get_identifier (\"reg_save_area\"),\n \t\t      ptr_type_node);\n \n+  va_list_gpr_counter_field = f_gpr;\n+  va_list_fpr_counter_field = f_fpr;\n+\n   DECL_FIELD_CONTEXT (f_gpr) = record;\n   DECL_FIELD_CONTEXT (f_fpr) = record;\n   DECL_FIELD_CONTEXT (f_ovf) = record;\n@@ -3136,6 +3139,9 @@ ix86_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   if (!TARGET_64BIT)\n     return;\n \n+  if (! cfun->va_list_gpr_size && ! cfun->va_list_fpr_size)\n+    return;\n+\n   /* Indicate to allocate space on the stack for varargs save area.  */\n   ix86_save_varrargs_registers = 1;\n \n@@ -3157,7 +3163,10 @@ ix86_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \n   set = get_varargs_alias_set ();\n \n-  for (i = next_cum.regno; i < ix86_regparm; i++)\n+  for (i = next_cum.regno;\n+       i < ix86_regparm\n+       && i < next_cum.regno + cfun->va_list_gpr_size / UNITS_PER_WORD;\n+       i++)\n     {\n       mem = gen_rtx_MEM (Pmode,\n \t\t\t plus_constant (save_area, i * UNITS_PER_WORD));\n@@ -3166,7 +3175,7 @@ ix86_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t\t\t\tx86_64_int_parameter_registers[i]));\n     }\n \n-  if (next_cum.sse_nregs)\n+  if (next_cum.sse_nregs && cfun->va_list_fpr_size)\n     {\n       /* Now emit code to save SSE registers.  The AX parameter contains number\n \t of SSE parameter registers used to call this function.  We use\n@@ -3249,15 +3258,21 @@ ix86_va_start (tree valist, rtx nextarg)\n     fprintf (stderr, \"va_start: words = %d, n_gpr = %d, n_fpr = %d\\n\",\n \t     (int) words, (int) n_gpr, (int) n_fpr);\n \n-  t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr,\n-\t     build_int_cst (NULL_TREE, n_gpr * 8));\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+  if (cfun->va_list_gpr_size)\n+    {\n+      t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr,\n+\t\t build_int_cst (NULL_TREE, n_gpr * 8));\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+    }\n \n-  t = build (MODIFY_EXPR, TREE_TYPE (fpr), fpr,\n-\t     build_int_cst (NULL_TREE, n_fpr * 16 + 8*REGPARM_MAX));\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+  if (cfun->va_list_fpr_size)\n+    {\n+      t = build (MODIFY_EXPR, TREE_TYPE (fpr), fpr,\n+\t\t build_int_cst (NULL_TREE, n_fpr * 16 + 8*REGPARM_MAX));\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+    }\n \n   /* Find the overflow area.  */\n   t = make_tree (TREE_TYPE (ovf), virtual_incoming_args_rtx);\n@@ -3268,12 +3283,15 @@ ix86_va_start (tree valist, rtx nextarg)\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-  /* Find the register save area.\n-     Prologue of the function save it right above stack frame.  */\n-  t = make_tree (TREE_TYPE (sav), frame_pointer_rtx);\n-  t = build (MODIFY_EXPR, TREE_TYPE (sav), sav, t);\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+  if (cfun->va_list_gpr_size || cfun->va_list_fpr_size)\n+    {\n+      /* Find the register save area.\n+\t Prologue of the function save it right above stack frame.  */\n+      t = make_tree (TREE_TYPE (sav), frame_pointer_rtx);\n+      t = build (MODIFY_EXPR, TREE_TYPE (sav), sav, t);\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+    }\n }\n \n /* Implement va_arg.  */"}, {"sha": "c5407b29860686042049d3fd350ca04d63a65902", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 40, "deletions": 16, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=58c8adc12700ffb0a3fe9406863c869afe67b99d", "patch": "@@ -5384,25 +5384,32 @@ setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n     }\n \n   set = get_varargs_alias_set ();\n-  if (! no_rtl && first_reg_offset < GP_ARG_NUM_REG)\n+  if (! no_rtl && first_reg_offset < GP_ARG_NUM_REG\n+      && cfun->va_list_gpr_size)\n     {\n+      int nregs = GP_ARG_NUM_REG - first_reg_offset;\n+\n+      if (nregs > cfun->va_list_gpr_size)\n+        nregs = cfun->va_list_gpr_size;\n+\n       mem = gen_rtx_MEM (BLKmode,\n \t\t         plus_constant (save_area,\n \t\t\t\t\tfirst_reg_offset * reg_size)),\n       set_mem_alias_set (mem, set);\n       set_mem_align (mem, BITS_PER_WORD);\n \n       rs6000_move_block_from_reg (GP_ARG_MIN_REG + first_reg_offset, mem,\n-\t\t\t          GP_ARG_NUM_REG - first_reg_offset);\n+\t\t\t          nregs);\n     }\n \n   /* Save FP registers if needed.  */\n   if (DEFAULT_ABI == ABI_V4\n       && TARGET_HARD_FLOAT && TARGET_FPRS\n       && ! no_rtl\n-      && next_cum.fregno <= FP_ARG_V4_MAX_REG)\n+      && next_cum.fregno <= FP_ARG_V4_MAX_REG\n+      && cfun->va_list_fpr_size)\n     {\n-      int fregno = next_cum.fregno;\n+      int fregno = next_cum.fregno, nregs;\n       rtx cr1 = gen_rtx_REG (CCmode, CR1_REGNO);\n       rtx lab = gen_label_rtx ();\n       int off = (GP_ARG_NUM_REG * reg_size) + ((fregno - FP_ARG_MIN_REG) * 8);\n@@ -5415,13 +5422,14 @@ setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t\t\t\t    gen_rtx_LABEL_REF (VOIDmode, lab),\n \t\t\t\t\t    pc_rtx)));\n \n-      while (fregno <= FP_ARG_V4_MAX_REG)\n+      for (nregs = 0;\n+           fregno <= FP_ARG_V4_MAX_REG && nregs < cfun->va_list_fpr_size;\n+           fregno++, off += 8, nregs++)\n \t{\n-\t  mem = gen_rtx_MEM (DFmode, plus_constant (save_area, off));\n+\t  mem = gen_rtx_MEM (DFmode,\n+\t                     plus_constant (save_area, off));\n           set_mem_alias_set (mem, set);\n \t  emit_move_insn (mem, gen_rtx_REG (DFmode, fregno));\n-\t  fregno++;\n-\t  off += 8;\n \t}\n \n       emit_label (lab);\n@@ -5456,6 +5464,9 @@ rs6000_build_builtin_va_list (void)\n   f_sav = build_decl (FIELD_DECL, get_identifier (\"reg_save_area\"),\n \t\t      ptr_type_node);\n \n+  va_list_gpr_counter_field = f_gpr;\n+  va_list_fpr_counter_field = f_fpr;\n+\n   DECL_FIELD_CONTEXT (f_gpr) = record;\n   DECL_FIELD_CONTEXT (f_fpr) = record;\n   DECL_FIELD_CONTEXT (f_res) = record;\n@@ -5514,15 +5525,28 @@ rs6000_va_start (tree valist, rtx nextarg)\n \t     HOST_WIDE_INT_PRINT_DEC\", n_fpr = \"HOST_WIDE_INT_PRINT_DEC\"\\n\",\n \t     words, n_gpr, n_fpr);\n \n-  t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr,\n-\t     build_int_cst (NULL_TREE, n_gpr));\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+  if (cfun->va_list_gpr_size)\n+    {\n+      t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr,\n+                 build_int_cst (NULL_TREE, n_gpr));\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+    }\n \n-  t = build (MODIFY_EXPR, TREE_TYPE (fpr), fpr,\n-\t     build_int_cst (NULL_TREE, n_fpr));\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+  if (cfun->va_list_fpr_size)\n+    {\n+      t = build (MODIFY_EXPR, TREE_TYPE (fpr), fpr,\n+\t         build_int_cst (NULL_TREE, n_fpr));\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+    }\n+\n+  /* If there were no va_arg invocations, don't set up anything.  */\n+  if (!cfun->va_list_gpr_size\n+      && !cfun->va_list_fpr_size\n+      && n_gpr < GP_ARG_NUM_REG\n+      && n_fpr < FP_ARG_V4_MAX_REG)\n+    return;\n \n   /* Find the overflow area.  */\n   t = make_tree (TREE_TYPE (ovf), virtual_incoming_args_rtx);"}, {"sha": "611589d7ae84105727cead863548800ec6c01e42", "filename": "gcc/function.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=58c8adc12700ffb0a3fe9406863c869afe67b99d", "patch": "@@ -3798,6 +3798,10 @@ allocate_struct_function (tree fndecl)\n        && TYPE_ARG_TYPES (fntype) != 0\n        && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))\n \t   != void_type_node));\n+\n+  /* Assume all registers in stdarg functions need to be saved.  */\n+  cfun->va_list_gpr_size = VA_LIST_MAX_GPR_SIZE;\n+  cfun->va_list_fpr_size = VA_LIST_MAX_FPR_SIZE;\n }\n \n /* Reset cfun, and other non-struct-function variables to defaults as"}, {"sha": "12b56bd9d0718e3dc485912d36a3290d1649480c", "filename": "gcc/function.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=58c8adc12700ffb0a3fe9406863c869afe67b99d", "patch": "@@ -428,8 +428,22 @@ struct function GTY(())\n \n   /* Nonzero if code to initialize arg_pointer_save_area has been emitted.  */\n   unsigned int arg_pointer_save_area_init : 1;\n+\n+  /* Number of units of general registers that need saving in stdarg\n+     function.  What unit is depends on the backend, either it is number\n+     of bytes, or it can be number of registers.  */\n+  unsigned int va_list_gpr_size : 8;\n+\n+  /* Number of units of floating point registers that need saving in stdarg\n+     function.  */\n+  unsigned int va_list_fpr_size : 8;\n };\n \n+/* If va_list_[gf]pr_size is set to this, it means we don't know how\n+   many units need to be saved.  */\n+#define VA_LIST_MAX_GPR_SIZE\t255\n+#define VA_LIST_MAX_FPR_SIZE\t255\n+\n /* The function currently being compiled.  */\n extern GTY(()) struct function *cfun;\n "}, {"sha": "05c6e3f4cbce66c7aa1575b3eea573aaf8b7db2c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=58c8adc12700ffb0a3fe9406863c869afe67b99d", "patch": "@@ -1,3 +1,14 @@\n+2004-09-29  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.c-torture/execute/stdarg-1.c: New test.\n+\t* gcc.c-torture/execute/stdarg-2.c: New test.\n+\t* gcc.c-torture/execute/stdarg-3.c: New test.\n+\t* gcc.dg/tree-ssa/stdarg-1.c: New test.\n+\t* gcc.dg/tree-ssa/stdarg-2.c: New test.\n+\t* gcc.dg/tree-ssa/stdarg-3.c: New test.\n+\t* gcc.dg/tree-ssa/stdarg-4.c: New test.\n+\t* gcc.dg/tree-ssa/stdarg-5.c: New test.\n+\n 2004-09-29  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/17697"}, {"sha": "0ff9759e959cc17b6af158d4f830f1376e975e6f", "filename": "gcc/testsuite/gcc.c-torture/execute/stdarg-1.c", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstdarg-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstdarg-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstdarg-1.c?ref=58c8adc12700ffb0a3fe9406863c869afe67b99d", "patch": "@@ -0,0 +1,156 @@\n+#include <stdarg.h>\n+\n+extern void abort (void);\n+\n+int foo_arg, bar_arg;\n+long x;\n+double d;\n+va_list gap;\n+va_list *pap;\n+\n+void\n+foo (int v, va_list ap)\n+{\n+  switch (v)\n+    {\n+    case 5: foo_arg = va_arg (ap, int); break;\n+    default: abort ();\n+    }\n+}\n+\n+void\n+bar (int v)\n+{\n+  if (v == 0x4006)\n+    {\n+      if (va_arg (gap, double) != 17.0\n+\t  || va_arg (gap, long) != 129L)\n+\tabort ();\n+    }\n+  else if (v == 0x4008)\n+    {\n+      if (va_arg (*pap, long long) != 14LL\n+\t  || va_arg (*pap, long double) != 131.0L\n+\t  || va_arg (*pap, int) != 17)\n+\tabort ();\n+    }\n+  bar_arg = v;\n+}\n+\n+void\n+f0 (int i, ...)\n+{\n+}\n+\n+void\n+f1 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  va_end (ap);\n+}\n+\n+void\n+f2 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  bar (d);\n+  x = va_arg (ap, long);\n+  bar (x);\n+  va_end (ap);\n+}\n+\n+void\n+f3 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  d = va_arg (ap, double);\n+  va_end (ap);\n+}\n+\n+void\n+f4 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  x = va_arg (ap, double);\n+  foo (i, ap);\n+  va_end (ap);\n+}\n+\n+void\n+f5 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  va_copy (gap, ap);\n+  bar (i);\n+  va_end (ap);\n+  va_end (gap);\n+}\n+\n+void\n+f6 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  bar (d);\n+  va_arg (ap, long);\n+  va_arg (ap, long);\n+  x = va_arg (ap, long);\n+  bar (x);\n+  va_end (ap);\n+}\n+\n+void\n+f7 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  pap = &ap;\n+  bar (i);\n+  va_end (ap);\n+}\n+\n+void\n+f8 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  pap = &ap;\n+  bar (i);\n+  d = va_arg (ap, double);\n+  va_end (ap);\n+}\n+\n+int\n+main (void)\n+{\n+  f0 (1);\n+  f1 (2);\n+  d = 31.0;\n+  f2 (3, 28L);\n+  if (bar_arg != 28 || x != 28)\n+    abort ();\n+  f3 (4, 131.0);\n+  if (d != 131.0)\n+    abort ();\n+  f4 (5, 16.0, 128);\n+  if (x != 16 || foo_arg != 128)\n+    abort ();\n+  f5 (0x4006, 17.0, 129L);\n+  if (bar_arg != 0x4006)\n+    abort ();\n+  f6 (7, 12L, 14L, -31L);\n+  if (bar_arg != -31)\n+    abort ();\n+  f7 (0x4008, 14LL, 131.0L, 17, 26.0);\n+  if (bar_arg != 0x4008)\n+    abort ();\n+  f8 (0x4008, 14LL, 131.0L, 17, 27.0);\n+  if (bar_arg != 0x4008 || d != 27.0)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "24ba732438cdf17586d41d19bfa18dfad023ddff", "filename": "gcc/testsuite/gcc.c-torture/execute/stdarg-2.c", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstdarg-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstdarg-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstdarg-2.c?ref=58c8adc12700ffb0a3fe9406863c869afe67b99d", "patch": "@@ -0,0 +1,177 @@\n+#include <stdarg.h>\n+\n+extern void abort (void);\n+\n+int foo_arg, bar_arg;\n+long x;\n+double d;\n+va_list gap;\n+\n+void\n+foo (int v, va_list ap)\n+{\n+  switch (v)\n+    {\n+    case 5:\n+      foo_arg = va_arg (ap, int) + va_arg (ap, double);\n+      foo_arg += va_arg (ap, long long);\n+      break;\n+    case 8:\n+      foo_arg = va_arg (ap, long long) + va_arg (ap, double);\n+      break;\n+    case 11:\n+      foo_arg = va_arg (ap, int) + va_arg (ap, long double);\n+      break;\n+    default:\n+      abort ();\n+    }\n+}\n+\n+void\n+bar (int v)\n+{\n+  if (v == 0x4002)\n+    {\n+      if (va_arg (gap, int) != 13 || va_arg (gap, double) != -14.0)\n+\tabort ();\n+    }\n+  bar_arg = v;\n+}\n+\n+void\n+f1 (int i, ...)\n+{\n+  va_start (gap, i);\n+  x = va_arg (gap, long);\n+  va_end (gap);\n+}\n+\n+void\n+f2 (int i, ...)\n+{\n+  va_start (gap, i);\n+  bar (i);\n+  va_end (gap);\n+}\n+\n+void\n+f3 (int i, ...)\n+{\n+  va_list aps[10];\n+  va_start (aps[4], i);\n+  x = va_arg (aps[4], long);\n+  va_end (aps[4]);\n+}\n+\n+void\n+f4 (int i, ...)\n+{\n+  va_list aps[10];\n+  va_start (aps[4], i);\n+  bar (i);\n+  va_end (aps[4]);\n+}\n+\n+void\n+f5 (int i, ...)\n+{\n+  va_list aps[10];\n+  va_start (aps[4], i);\n+  foo (i, aps[4]);\n+  va_end (aps[4]);\n+}\n+\n+struct A { int i; va_list g; va_list h[2]; };\n+\n+void\n+f6 (int i, ...)\n+{\n+  struct A a;\n+  va_start (a.g, i);\n+  x = va_arg (a.g, long);\n+  va_end (a.g);\n+}\n+\n+void\n+f7 (int i, ...)\n+{\n+  struct A a;\n+  va_start (a.g, i);\n+  bar (i);\n+  va_end (a.g);\n+}\n+\n+void\n+f8 (int i, ...)\n+{\n+  struct A a;\n+  va_start (a.g, i);\n+  foo (i, a.g);\n+  va_end (a.g);\n+}\n+\n+void\n+f10 (int i, ...)\n+{\n+  struct A a;\n+  va_start (a.h[1], i);\n+  x = va_arg (a.h[1], long);\n+  va_end (a.h[1]);\n+}\n+\n+void\n+f11 (int i, ...)\n+{\n+  struct A a;\n+  va_start (a.h[1], i);\n+  bar (i);\n+  va_end (a.h[1]);\n+}\n+\n+void\n+f12 (int i, ...)\n+{\n+  struct A a;\n+  va_start (a.h[1], i);\n+  foo (i, a.h[1]);\n+  va_end (a.h[1]);\n+}\n+\n+int\n+main (void)\n+{\n+  f1 (1, 79);\n+  if (x != 79)\n+    abort ();\n+  f2 (0x4002, 13, -14.0);\n+  if (bar_arg != 0x4002)\n+    abort ();\n+  f3 (3, 2031L);\n+  if (x != 2031)\n+    abort ();\n+  f4 (4, 18);\n+  if (bar_arg != 4)\n+    abort ();\n+  f5 (5, 1, 19.0, 18LL);\n+  if (foo_arg != 38)\n+    abort ();\n+  f6 (6, 18L);\n+  if (x != 18L)\n+    abort ();\n+  f7 (7);\n+  if (bar_arg != 7)\n+    abort ();\n+  f8 (8, 2031LL, 13.0);\n+  if (foo_arg != 2044)\n+    abort ();\n+  f10 (9, 180L);\n+  if (x != 180L)\n+    abort ();\n+  f11 (10);\n+  if (bar_arg != 10)\n+    abort ();\n+  f12 (11, 2030, 12.0L);\n+  if (foo_arg != 2042)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "ccc79e00123bcc4bbd500430526428cd4a26f95c", "filename": "gcc/testsuite/gcc.c-torture/execute/stdarg-3.c", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstdarg-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstdarg-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstdarg-3.c?ref=58c8adc12700ffb0a3fe9406863c869afe67b99d", "patch": "@@ -0,0 +1,166 @@\n+#include <stdarg.h>\n+\n+extern void abort (void);\n+\n+int foo_arg, bar_arg;\n+long x;\n+double d;\n+va_list gap;\n+struct S1 { int i; double d; int j; double e; } s1;\n+struct S2 { double d; long i; } s2;\n+int y;\n+\n+void\n+bar (int v)\n+{\n+  bar_arg = v;\n+}\n+\n+void\n+f1 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  while (i-- > 0)\n+    x = va_arg (ap, long);\n+  va_end (ap);\n+}\n+\n+void\n+f2 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  while (i-- > 0)\n+    d = va_arg (ap, double);\n+  va_end (ap);\n+}\n+\n+void\n+f3 (int i, ...)\n+{\n+  va_list ap;\n+  int j = i;\n+  while (j-- > 0)\n+    {\n+      va_start (ap, i);\n+      x = va_arg (ap, long);\n+      va_end (ap);\n+      bar (x);\n+    }\n+}\n+\n+void\n+f4 (int i, ...)\n+{\n+  va_list ap;\n+  int j = i;\n+  while (j-- > 0)\n+    {\n+      va_start (ap, i);\n+      d = va_arg (ap, double);\n+      va_end (ap);\n+      bar (d + 4.0);\n+    }\n+}\n+\n+void\n+f5 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  while (i-- > 0)\n+    s1 = va_arg (ap, struct S1);\n+  va_end (ap);\n+}\n+\n+void\n+f6 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  while (i-- > 0)\n+    s2 = va_arg (ap, struct S2);\n+  va_end (ap);\n+}\n+\n+void\n+f7 (int i, ...)\n+{\n+  va_list ap;\n+  int j = i;\n+  while (j-- > 0)\n+    {\n+      va_start (ap, i);\n+      s1 = va_arg (ap, struct S1);\n+      va_end (ap);\n+      bar (s1.i);\n+    }\n+}\n+\n+void\n+f8 (int i, ...)\n+{\n+  va_list ap;\n+  int j = i;\n+  while (j-- > 0)\n+    {\n+      va_start (ap, i);\n+      s2 = va_arg (ap, struct S2);\n+      y = va_arg (ap, int);\n+      va_end (ap);\n+      bar (s2.i);\n+    }\n+}\n+\n+int\n+main (void)\n+{\n+  struct S1 a1, a3;\n+  struct S2 a2, a4;\n+\n+  f1 (7, 1L, 2L, 3L, 5L, 7L, 9L, 11L, 13L);\n+  if (x != 11L)\n+    abort ();\n+  f2 (6, 1.0, 2.0, 4.0, 8.0, 16.0, 32.0, 64.0);\n+  if (d != 32.0)\n+    abort ();\n+  f3 (2, 1L, 3L);\n+  if (bar_arg != 1L || x != 1L)\n+    abort ();\n+  f4 (2, 17.0, 19.0);\n+  if (bar_arg != 21 || d != 17.0)\n+    abort ();\n+  a1.i = 131;\n+  a1.j = 251;\n+  a1.d = 15.0;\n+  a1.e = 191.0;\n+  a3 = a1;\n+  a3.j = 254;\n+  a3.e = 178.0;\n+  f5 (2, a1, a3, a1);\n+  if (s1.i != 131 || s1.j != 254 || s1.d != 15.0 || s1.e != 178.0)\n+    abort ();\n+  f5 (3, a1, a3, a1);\n+  if (s1.i != 131 || s1.j != 251 || s1.d != 15.0 || s1.e != 191.0)\n+    abort ();\n+  a2.i = 138;\n+  a2.d = 16.0;\n+  a4.i = 257;\n+  a4.d = 176.0;\n+  f6 (2, a2, a4, a2);\n+  if (s2.i != 257 || s2.d != 176.0)\n+    abort ();\n+  f6 (3, a2, a4, a2);\n+  if (s2.i != 138 || s2.d != 16.0)\n+    abort ();\n+  f7 (2, a3, a1, a1);\n+  if (s1.i != 131 || s1.j != 254 || s1.d != 15.0 || s1.e != 178.0)\n+    abort ();\n+  if (bar_arg != 131)\n+    abort ();\n+  f8 (3, a4, a2, a2);\n+  if (s2.i != 257 || s2.d != 176.0)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "39b61c9eb8df52d22029c5b202b27e35e667b396", "filename": "gcc/testsuite/gcc.dg/tree-ssa/stdarg-1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-1.c?ref=58c8adc12700ffb0a3fe9406863c869afe67b99d", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-stdarg\" } */\n+\n+#include <stdarg.h>\n+\n+/* This can be handled on all arches.  If there is no va_start, registers don't need\n+   to be saved.  */\n+void\n+f1 (int i, ...)\n+{\n+}\n+/* { dg-final { scan-tree-dump \"f1: va_list escapes 0, needs to save 0 GPR units and 0 FPR units\" \"stdarg\" } } */"}, {"sha": "3a8c0394fe4f67f50ea108a431e932c62ac4cbdf", "filename": "gcc/testsuite/gcc.dg/tree-ssa/stdarg-2.c", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-2.c?ref=58c8adc12700ffb0a3fe9406863c869afe67b99d", "patch": "@@ -0,0 +1,131 @@\n+/* This test is only for architectures that save general and floating point\n+   registers separately in stdarg functions.  */\n+/* { dg-do compile { target x86_64-*-* powerpc-*-* } } */\n+/* { dg-options \"-O2 -fdump-tree-stdarg\" } */\n+\n+#include <stdarg.h>\n+\n+extern void foo (int, va_list);\n+extern void bar (int);\n+long x;\n+double d;\n+va_list gap;\n+va_list *pap;\n+\n+void\n+f1 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  va_end (ap);\n+}\n+/* { dg-final { scan-tree-dump \"f1: va_list escapes 0, needs to save 0 GPR units and 0 FPR units\" \"stdarg\" } } */\n+\n+void\n+f2 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  bar (d);\n+  x = va_arg (ap, long);\n+  bar (x);\n+  va_end (ap);\n+}\n+/* Assume the counters can be number of registers or bytes on 32-bit\n+   architecture or bytes on 64-bit architecture.  */\n+/* { dg-final { scan-tree-dump \"f2: va_list escapes 0, needs to save \\[148\\] GPR units and 0 FPR units\" \"stdarg\" } } */\n+\n+void\n+f3 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  d = va_arg (ap, double);\n+  va_end (ap);\n+}\n+/* { dg-final { scan-tree-dump \"f3: va_list escapes 0, needs to save 0 GPR units and \\[1-9\\]\\[0-9\\]* FPR units\" \"stdarg\" } } */\n+\n+void\n+f4 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  x = va_arg (ap, double);\n+  foo (i, ap);\n+  va_end (ap);\n+}\n+/* { dg-final { scan-tree-dump \"f4: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n+\n+void\n+f5 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  va_copy (gap, ap);\n+  bar (i);\n+  va_end (ap);\n+  va_end (gap);\n+}\n+/* { dg-final { scan-tree-dump \"f5: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n+\n+void\n+f6 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  bar (d);\n+  va_arg (ap, long);\n+  va_arg (ap, long);\n+  x = va_arg (ap, long);\n+  bar (x);\n+  va_end (ap);\n+}\n+/* { dg-final { scan-tree-dump \"f6: va_list escapes 0, needs to save (3|12|24) GPR units and 0 FPR units\" \"stdarg\" } } */\n+\n+void\n+f7 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  pap = &ap;\n+  bar (6);\n+  va_end (ap);\n+}\n+/* { dg-final { scan-tree-dump \"f7: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n+\n+void\n+f8 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  pap = &ap;\n+  bar (d);\n+  x = va_arg (ap, long);\n+  bar (x);\n+  va_end (ap);\n+}\n+/* { dg-final { scan-tree-dump \"f8: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n+\n+void\n+f9 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  __asm __volatile (\"\" : \"=r\" (pap) : \"0\" (&ap));\n+  bar (6);\n+  va_end (ap);\n+}\n+/* { dg-final { scan-tree-dump \"f9: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n+\n+void\n+f10 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  __asm __volatile (\"\" : \"=r\" (pap) : \"0\" (&ap));\n+  bar (d);\n+  x = va_arg (ap, long);\n+  bar (x);\n+  va_end (ap);\n+}\n+/* { dg-final { scan-tree-dump \"f10: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */"}, {"sha": "cf68fe8dfc926b8372f5ff6794afc67097caa9ea", "filename": "gcc/testsuite/gcc.dg/tree-ssa/stdarg-3.c", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-3.c?ref=58c8adc12700ffb0a3fe9406863c869afe67b99d", "patch": "@@ -0,0 +1,124 @@\n+/* This test is only for architectures that save general and floating point\n+   registers separately in stdarg functions.  */\n+/* { dg-do compile { target x86_64-*-* powerpc-*-* } } */\n+/* { dg-options \"-O2 -fdump-tree-stdarg\" } */\n+\n+#include <stdarg.h>\n+\n+extern void foo (int, va_list);\n+extern void bar (int);\n+long x;\n+va_list gap;\n+\n+/* If va_list is not local variable, it escapes the function.  */\n+void\n+f1 (int i, ...)\n+{\n+  va_start (gap, i);\n+  x = va_arg (gap, long);\n+  va_end (gap);\n+}\n+/* { dg-final { scan-tree-dump \"f1: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n+\n+void\n+f2 (int i, ...)\n+{\n+  va_start (gap, i);\n+  bar (i);\n+  va_end (gap);\n+}\n+/* { dg-final { scan-tree-dump \"f2: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n+\n+/* tree-stdarg.c only handles va_list variables, not arrays of them or\n+   va_list fields embedded in structures.  */\n+void\n+f3 (int i, ...)\n+{\n+  va_list aps[10];\n+  va_start (aps[4], i);\n+  x = va_arg (aps[4], long);\n+  va_end (aps[4]);\n+}\n+/* { dg-final { scan-tree-dump \"f3: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n+\n+void\n+f4 (int i, ...)\n+{\n+  va_list aps[10];\n+  va_start (aps[4], i);\n+  bar (i);\n+  va_end (aps[4]);\n+}\n+/* { dg-final { scan-tree-dump \"f4: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n+\n+void\n+f5 (int i, ...)\n+{\n+  va_list aps[10];\n+  va_start (aps[4], i);\n+  foo (i, aps[4]);\n+  va_end (aps[4]);\n+}\n+/* { dg-final { scan-tree-dump \"f5: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n+\n+struct A { int i; va_list g; va_list h[2]; };\n+\n+void\n+f6 (int i, ...)\n+{\n+  struct A a;\n+  va_start (a.g, i);\n+  x = va_arg (a.g, long);\n+  va_end (a.g);\n+}\n+/* { dg-final { scan-tree-dump \"f6: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n+\n+void\n+f7 (int i, ...)\n+{\n+  struct A a;\n+  va_start (a.g, i);\n+  bar (i);\n+  va_end (a.g);\n+}\n+/* { dg-final { scan-tree-dump \"f7: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n+\n+void\n+f8 (int i, ...)\n+{\n+  struct A a;\n+  va_start (a.g, i);\n+  foo (i, a.g);\n+  va_end (a.g);\n+}\n+/* { dg-final { scan-tree-dump \"f8: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n+\n+void\n+f10 (int i, ...)\n+{\n+  struct A a;\n+  va_start (a.h[1], i);\n+  x = va_arg (a.h[1], long);\n+  va_end (a.h[1]);\n+}\n+/* { dg-final { scan-tree-dump \"f10: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n+\n+void\n+f11 (int i, ...)\n+{\n+  struct A a;\n+  va_start (a.h[1], i);\n+  bar (i);\n+  va_end (a.h[1]);\n+}\n+/* { dg-final { scan-tree-dump \"f11: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n+\n+void\n+f12 (int i, ...)\n+{\n+  struct A a;\n+  va_start (a.h[1], i);\n+  foo (i, a.h[1]);\n+  va_end (a.h[1]);\n+}\n+/* { dg-final { scan-tree-dump \"f12: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" } } */"}, {"sha": "5b4b86896f38844f7ef6e40dab7d019f969ffb49", "filename": "gcc/testsuite/gcc.dg/tree-ssa/stdarg-4.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-4.c?ref=58c8adc12700ffb0a3fe9406863c869afe67b99d", "patch": "@@ -0,0 +1,67 @@\n+/* This test is only for architectures that save general and floating point\n+   registers separately in stdarg functions.  */\n+/* { dg-do compile { target x86_64-*-* powerpc-*-* } } */\n+/* { dg-options \"-O2 -fdump-tree-stdarg\" } */\n+\n+#include <stdarg.h>\n+\n+extern void foo (int, va_list);\n+extern void bar (int);\n+long x;\n+double d;\n+\n+/* Here va_arg can be executed more than once for one va_start.  All GPR\n+   registers needs to be saved.  */\n+void\n+f1 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  while (i-- > 0)\n+    x = va_arg (ap, long);\n+  va_end (ap);\n+}\n+/* { dg-final { scan-tree-dump \"f1: va_list escapes 0, needs to save all GPR units and 0 FPR units\" \"stdarg\" } } */\n+\n+void\n+f2 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  while (i-- > 0)\n+    d = va_arg (ap, double);\n+  va_end (ap);\n+}\n+/* { dg-final { scan-tree-dump \"f2: va_list escapes 0, needs to save 0 GPR units and all FPR units\" \"stdarg\" } } */\n+\n+/* Here va_arg can be executed at most as many times as va_start.\n+   Only one GPR needs to be saved.  */\n+void\n+f3 (int i, ...)\n+{\n+  va_list ap;\n+  int j = i;\n+  while (j-- > 0)\n+    {\n+      va_start (ap, i);\n+      x = va_arg (ap, long);\n+      va_end (ap);\n+      bar (x);\n+    }\n+}\n+/* { dg-final { scan-tree-dump \"f3: va_list escapes 0, needs to save \\[148\\] GPR units and 0 FPR units\" \"stdarg\" } } */\n+\n+void\n+f4 (int i, ...)\n+{\n+  va_list ap;\n+  int j = i;\n+  while (j-- > 0)\n+    {\n+      va_start (ap, i);\n+      d = va_arg (ap, double);\n+      va_end (ap);\n+      bar (d + 2.5);\n+    }\n+}\n+/* { dg-final { scan-tree-dump \"f4: va_list escapes 0, needs to save 0 GPR units and \\[1-9\\]\\[0-9\\]* FPR units\" \"stdarg\" } } */"}, {"sha": "33d00e6dbbb00684561c8b5d0353e431304e831d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/stdarg-5.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-5.c?ref=58c8adc12700ffb0a3fe9406863c869afe67b99d", "patch": "@@ -0,0 +1,66 @@\n+/* This test is specific to x86-64 function passing.  */\n+/* { dg-do compile { target x86_64-*-* } } */\n+/* { dg-options \"-O2 -fdump-tree-stdarg\" } */\n+\n+#include <stdarg.h>\n+\n+extern void foo (int, va_list);\n+extern void bar (int);\n+struct S1 { int i; double d; int j; double e; } s1;\n+struct S2 { double d; long i; } s2;\n+int y;\n+\n+/* Here va_arg can be executed more than once for one va_start.  */\n+void\n+f1 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  while (i-- > 0)\n+    s1 = va_arg (ap, struct S1);\n+  va_end (ap);\n+}\n+/* { dg-final { scan-tree-dump \"f1: va_list escapes 0, needs to save 0 GPR units and 0 FPR units\" \"stdarg\" } } */\n+\n+void\n+f2 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  while (i-- > 0)\n+    s2 = va_arg (ap, struct S2);\n+  va_end (ap);\n+}\n+/* { dg-final { scan-tree-dump \"f2: va_list escapes 0, needs to save all GPR units and all FPR units\" \"stdarg\" } } */\n+\n+/* Here va_arg can be executed at most as many times as va_start.  */\n+void\n+f3 (int i, ...)\n+{\n+  va_list ap;\n+  int j = i;\n+  while (j-- > 0)\n+    {\n+      va_start (ap, i);\n+      s1 = va_arg (ap, struct S1);\n+      va_end (ap);\n+      bar (s1.i);\n+    }\n+}\n+/* { dg-final { scan-tree-dump \"f3: va_list escapes 0, needs to save 0 GPR units and 0 FPR units\" \"stdarg\" } } */\n+\n+void\n+f4 (int i, ...)\n+{\n+  va_list ap;\n+  int j = i;\n+  while (j-- > 0)\n+    {\n+      va_start (ap, i);\n+      s2 = va_arg (ap, struct S2);\n+      y = va_arg (ap, int);\n+      va_end (ap);\n+      bar (s2.i);\n+    }\n+}\n+/* { dg-final { scan-tree-dump \"f4: va_list escapes 0, needs to save 16 GPR units and 16 FPR units\" \"stdarg\" } } */"}, {"sha": "073618968fd6e4d3a4363e3b86c3d09334746677", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=58c8adc12700ffb0a3fe9406863c869afe67b99d", "patch": "@@ -371,6 +371,7 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_ccp);\n   NEXT_PASS (pass_redundant_phi);\n   NEXT_PASS (pass_fold_builtins);\n+  NEXT_PASS (pass_stdarg);\n   NEXT_PASS (pass_split_crit_edges);\n   NEXT_PASS (pass_pre);\n   NEXT_PASS (pass_loop);"}, {"sha": "07486c6c85bd773af254c0f42d9540b206025d3c", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=58c8adc12700ffb0a3fe9406863c869afe67b99d", "patch": "@@ -147,6 +147,7 @@ extern struct tree_opt_pass pass_profile;\n extern struct tree_opt_pass pass_pre_expand;\n extern struct tree_opt_pass pass_lower_vector_ssa;\n extern struct tree_opt_pass pass_fold_builtins;\n+extern struct tree_opt_pass pass_stdarg;\n extern struct tree_opt_pass pass_early_warn_uninitialized;\n extern struct tree_opt_pass pass_late_warn_uninitialized;\n extern struct tree_opt_pass pass_warn_function_return;"}, {"sha": "926563793ca780b69fbf2c9a86eb7d38ec26e777", "filename": "gcc/tree-stdarg.c", "status": "added", "additions": 470, "deletions": 0, "changes": 470, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=58c8adc12700ffb0a3fe9406863c869afe67b99d", "patch": "@@ -0,0 +1,470 @@\n+/* Pass computing data for optimizing stdarg functions.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Contributed by Jakub Jelinek <jakub@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"langhooks.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-pass.h\"\n+\n+/* A simple pass that attempts to optimize stdarg functions on architectures\n+   that need to save register arguments to stack on entry to stdarg functions.\n+   If the function doesn't use any va_start macros, no registers need to\n+   be saved.  If va_start macros are used, the va_list variables don't escape\n+   the function, it is only necessary to save registers that will be used\n+   in va_arg macros.  E.g. if va_arg is only used with integral types\n+   in the function, floating point registers don't need to be saved, etc.  */\n+\n+struct stdarg_info\n+{\n+  bitmap va_list_vars;\n+  basic_block va_start_bb, bb;\n+  int compute_sizes, va_start_count;\n+};\n+\n+/* Return true if basic block VA_ARG_BB is dominated by VA_START_BB and\n+   is executed at most as many times as VA_START_BB.  */\n+\n+static bool\n+reachable_at_most_once (basic_block va_arg_bb, basic_block va_start_bb)\n+{\n+  edge *stack, e;\n+  edge_iterator ei;\n+  int sp;\n+  sbitmap visited;\n+  bool ret;\n+\n+  if (va_arg_bb == va_start_bb)\n+    return true;\n+\n+  if (! dominated_by_p (CDI_DOMINATORS, va_arg_bb, va_start_bb))\n+    return false;\n+\n+  stack = xmalloc ((n_basic_blocks + 1) * sizeof (edge));\n+  sp = 0;\n+\n+  visited = sbitmap_alloc (last_basic_block);\n+  sbitmap_zero (visited);\n+  ret = true;\n+\n+  FOR_EACH_EDGE (e, ei, va_arg_bb->preds)\n+    stack[sp++] = e;\n+\n+  while (sp)\n+    {\n+      basic_block src;\n+\n+      --sp;\n+      e = stack[sp];\n+      src = e->src;\n+\n+      if (e->flags & EDGE_COMPLEX)\n+\t{\n+\t  ret = false;\n+\t  break;\n+\t}\n+\n+      if (src == va_start_bb)\n+\tcontinue;\n+\n+      /* va_arg_bb can be executed more times than va_start_bb.  */\n+      if (src == va_arg_bb)\n+\t{\n+\t  ret = false;\n+\t  break;\n+\t}\n+\n+      gcc_assert (src != ENTRY_BLOCK_PTR);\n+\n+      if (! TEST_BIT (visited, src->index))\n+\t{\n+\t  SET_BIT (visited, src->index);\n+\t  FOR_EACH_EDGE (e, ei, src->preds)\n+\t    stack[sp++] = e;\n+\t}\n+    }\n+\n+  free (stack);\n+  sbitmap_free (visited);\n+  return ret;\n+}\n+\n+\n+/* For statement COUNTER = RHS, if RHS is COUNTER + constant,\n+   return constant, otherwise return 0.  */\n+\n+static unsigned HOST_WIDE_INT\n+va_list_counter_bump (tree counter, tree rhs)\n+{\n+  tree plus_stmt = SSA_NAME_DEF_STMT (rhs);\n+  tree rhs1, addend, load_stmt, counter1;\n+\n+  if (TREE_CODE (plus_stmt) != MODIFY_EXPR\n+      || TREE_OPERAND (plus_stmt, 0) != rhs)\n+    return 0;\n+\n+  rhs1 = TREE_OPERAND (plus_stmt, 1);\n+\n+  if (TREE_CODE (rhs1) != PLUS_EXPR\n+      || TREE_CODE (TREE_OPERAND (rhs1, 0)) != SSA_NAME\n+      || TREE_CODE (TREE_OPERAND (rhs1, 1)) != INTEGER_CST\n+      || !host_integerp (TREE_OPERAND (rhs1, 1), 1))\n+    return 0;\n+\n+  addend = TREE_OPERAND (rhs1, 0);\n+  load_stmt = SSA_NAME_DEF_STMT (addend);\n+\n+  if (TREE_CODE (load_stmt) != MODIFY_EXPR\n+      || TREE_OPERAND (load_stmt, 0) != addend)\n+    return 0;\n+\n+  counter1 = TREE_OPERAND (load_stmt, 1);\n+  if (TREE_CODE (counter) != TREE_CODE (counter1))\n+    return 0;\n+\n+  if (TREE_CODE (counter) == COMPONENT_REF)\n+    {\n+      if (get_base_address (counter) != get_base_address (counter1)\n+\t  || TREE_CODE (TREE_OPERAND (counter1, 1)) != FIELD_DECL\n+\t  || TREE_OPERAND (counter, 1) != TREE_OPERAND (counter1, 1))\n+\treturn 0;\n+    }\n+  else\n+    return 0;\n+\n+  return tree_low_cst (TREE_OPERAND (rhs1, 1), 1);\n+}\n+\n+\n+/* Called by walk_tree to look for references to va_list variables.  */\n+\n+static tree\n+find_va_list_reference (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t\t\tvoid *data)\n+{\n+  bitmap va_list_vars = (bitmap) data;\n+  tree var = *tp;\n+\n+  if (TREE_CODE (var) == SSA_NAME)\n+    var = SSA_NAME_VAR (var);\n+\n+  if (TREE_CODE (var) == VAR_DECL\n+      && bitmap_bit_p (va_list_vars, var_ann (var)->uid))\n+    return var;\n+\n+  return NULL_TREE;\n+}\n+\n+\n+/* Helper function of va_list_counter_struct_op.  Compute\n+  cfun->va_list_{g,f}pr_size.  AP is a va_list GPR/FPR counter,\n+  if WRITE_P is true, seen in AP = VAR, otherwise seen in VAR = AP\n+  statement.  GPR_P is true if AP is a GPR counter, false if it is\n+  a FPR counter.  */\n+\n+static void\n+va_list_counter_op (struct stdarg_info *si, tree ap, tree var, bool gpr_p,\n+\t\t    bool write_p)\n+{\n+  unsigned HOST_WIDE_INT increment;\n+\n+  if (si->compute_sizes < 0)\n+    {\n+      si->compute_sizes = 0;\n+      if (si->va_start_count == 1\n+\t  && reachable_at_most_once (si->bb, si->va_start_bb))\n+\tsi->compute_sizes = 1;\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"bb%d will %sbe executed at most once for each va_start \"\n+\t\t \"in bb%d\\n\", si->bb->index, si->compute_sizes ? \"\" : \"not \",\n+\t\t si->va_start_bb->index);\n+    }\n+\n+  if (write_p\n+      && si->compute_sizes\n+      && (increment = va_list_counter_bump (ap, var)) != 0)\n+    {\n+      if (gpr_p && cfun->va_list_gpr_size + increment < VA_LIST_MAX_GPR_SIZE)\n+\t{\n+\t  cfun->va_list_gpr_size += increment;\n+\t  return;\n+\t}\n+\n+      if (!gpr_p && cfun->va_list_fpr_size + increment < VA_LIST_MAX_FPR_SIZE)\n+\t{\n+\t  cfun->va_list_fpr_size += increment;\n+\t  return;\n+\t}\n+    }\n+\n+  if (write_p || !si->compute_sizes)\n+    {\n+      if (gpr_p)\n+\tcfun->va_list_gpr_size = VA_LIST_MAX_GPR_SIZE;\n+      else\n+\tcfun->va_list_fpr_size = VA_LIST_MAX_FPR_SIZE;\n+    }\n+}\n+\n+\n+/* If AP is a va_list GPR/FPR counter, compute cfun->va_list_{g,f}pr_size.\n+   If WRITE_P is true, AP has been seen in AP = VAR assignment, if WRITE_P\n+   is false, AP has been seen in VAR = AP assignment.\n+   Return true if the AP = VAR (resp. VAR = AP) statement is a recognized\n+   va_arg operation that doesn't cause the va_list variable to escape\n+   current function.  */\n+\n+static bool\n+va_list_counter_struct_op (struct stdarg_info *si, tree ap, tree var,\n+\t\t\t   bool write_p)\n+{\n+  tree base;\n+\n+  if (TREE_CODE (ap) != COMPONENT_REF\n+      || TREE_CODE (TREE_OPERAND (ap, 1)) != FIELD_DECL)\n+    return false;\n+\n+  if (TREE_CODE (var) != SSA_NAME\n+      || bitmap_bit_p (si->va_list_vars, var_ann (SSA_NAME_VAR (var))->uid))\n+    return false;\n+\n+  base = get_base_address (ap);\n+  if (TREE_CODE (base) != VAR_DECL\n+      || !bitmap_bit_p (si->va_list_vars, var_ann (base)->uid))\n+    return false;\n+\n+  if (TREE_OPERAND (ap, 1) == va_list_gpr_counter_field)\n+    va_list_counter_op (si, ap, var, true, write_p);\n+  else if (TREE_OPERAND (ap, 1) == va_list_fpr_counter_field)\n+    va_list_counter_op (si, ap, var, false, write_p);\n+\n+  return true;\n+}\n+\n+\n+/* Return true if this optimization pass should be done.\n+   It makes only sense for stdarg functions.  */\n+\n+static bool\n+gate_optimize_stdarg (void)\n+{\n+  /* This optimization is only for stdarg functions.  */\n+  return current_function_stdarg != 0;\n+}  \n+\n+\n+/* Entry point to the stdarg optimization pass.  */\n+\n+static void\n+execute_optimize_stdarg (void)\n+{\n+  basic_block bb;\n+  bool va_list_escapes = false;\n+  struct stdarg_info si;\n+  const char *funcname = NULL;\n+\n+  cfun->va_list_gpr_size = 0;\n+  cfun->va_list_fpr_size = 0;\n+  memset (&si, 0, sizeof (si));\n+  si.va_list_vars = BITMAP_XMALLOC ();\n+\n+  if (dump_file)\n+    funcname = lang_hooks.decl_printable_name (current_function_decl, 2);\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      block_stmt_iterator i;\n+\n+      for (i = bsi_start (bb); !bsi_end_p (i); bsi_next (&i))\n+\t{\n+\t  tree stmt = bsi_stmt (i);\n+\t  tree call = get_call_expr_in (stmt), callee;\n+\t  tree ap;\n+\n+\t  if (!call)\n+\t    continue;\n+\n+\t  callee = get_callee_fndecl (call);\n+\t  if (!callee\n+\t      || DECL_BUILT_IN_CLASS (callee) != BUILT_IN_NORMAL\n+\t      || DECL_FUNCTION_CODE (callee) != BUILT_IN_VA_START)\n+\t    continue;\n+\n+\t  si.va_start_count++;\n+\t  ap = TREE_VALUE (TREE_OPERAND (call, 1));\n+\t  if (TREE_CODE (ap) != ADDR_EXPR\n+\t      || TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (ap, 0)))\n+\t\t != TYPE_MAIN_VARIANT (va_list_type_node)\n+\t      || TREE_CODE (TREE_OPERAND (ap, 0)) != VAR_DECL)\n+\t    {\n+\t      va_list_escapes = true;\n+\t      break;\n+\t    }\n+\n+\t  ap = TREE_OPERAND (ap, 0);\t    \n+\t  if (is_global_var (ap))\n+\t    {\n+\t      va_list_escapes = true;\n+\t      break;\n+\t    }\n+\n+\t  bitmap_set_bit (si.va_list_vars, var_ann (ap)->uid);\n+\n+\t  /* VA_START_BB will be only used if there is just one\n+\t     va_start in the function.  */\n+\t  si.va_start_bb = bb;\n+\t}\n+\n+      if (va_list_escapes)\n+\tbreak;\n+    }\n+\n+  /* If there were no va_start uses in the function, there is no need to\n+     save anything.  */\n+  if (si.va_start_count == 0)\n+    goto finish;\n+\n+  /* If some va_list arguments weren't local, we can't optimize.  */\n+  if (va_list_escapes)\n+    goto finish;\n+\n+  /* If the backend didn't tell us what the counter fields are, there is\n+     nothing more we can do.  */\n+  if (va_list_gpr_counter_field == NULL_TREE\n+      && va_list_fpr_counter_field == NULL_TREE)\n+    {\n+      va_list_escapes = true;\n+      goto finish;\n+    }\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      block_stmt_iterator i;\n+\n+      si.compute_sizes = -1;\n+      si.bb = bb;\n+      for (i = bsi_start (bb);\n+\t   !bsi_end_p (i) && !va_list_escapes;\n+\t   bsi_next (&i))\n+\t{\n+\t  tree stmt = bsi_stmt (i);\n+\t  tree call;\n+\n+\t  /* Don't look at __builtin_va_{start,end}, they are ok.  */\n+\t  call = get_call_expr_in (stmt);\n+\t  if (call)\n+\t    {\n+\t      tree callee = get_callee_fndecl (call);\n+\n+\t      if (callee\n+\t\t  && DECL_BUILT_IN_CLASS (callee) == BUILT_IN_NORMAL\n+\t\t  && (DECL_FUNCTION_CODE (callee) == BUILT_IN_VA_START\n+\t\t      || DECL_FUNCTION_CODE (callee) == BUILT_IN_VA_END))\n+\t\tcontinue;\n+\t    }\n+\n+\t  if (TREE_CODE (stmt) == MODIFY_EXPR)\n+\t    {\n+\t      tree lhs = TREE_OPERAND (stmt, 0);\n+\t      tree rhs = TREE_OPERAND (stmt, 1);\n+\n+\t      if (TREE_CODE (rhs) == WITH_SIZE_EXPR)\n+\t\trhs = TREE_OPERAND (rhs, 0);\n+\n+\t      /* Check for ap[0].field = temp.  */\n+\t      if (va_list_counter_struct_op (&si, lhs, rhs, true))\n+\t\tcontinue;\n+\n+\t      /* Check for temp = ap[0].field.  */\n+\t      else if (va_list_counter_struct_op (&si, rhs, lhs, false))\n+\t\tcontinue;\n+\t    }\n+\n+\t  /* All other uses of va_list are either va_copy (that is not handled\n+\t     in this optimization), taking address of va_list variable or\n+\t     passing va_list to other functions (in that case va_list might\n+\t     escape the function and therefore va_start needs to set it up\n+\t     fully), or some unexpected use of va_list.  None of these should\n+\t     happen in a gimplified VA_ARG_EXPR.  */\n+\t  if (walk_tree (&stmt, find_va_list_reference, si.va_list_vars, NULL))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fputs (\"va_list escapes in \", dump_file);\n+\t\t  print_generic_expr (dump_file, stmt, dump_flags);\n+\t\t  fputc ('\\n', dump_file);\n+\t\t}\n+\t      va_list_escapes = true;\n+\t    }\n+\t}\n+\n+      if (va_list_escapes)\n+\tbreak;\n+    }\n+\n+finish:\n+  if (va_list_escapes)\n+    {\n+      cfun->va_list_gpr_size = VA_LIST_MAX_GPR_SIZE;\n+      cfun->va_list_fpr_size = VA_LIST_MAX_FPR_SIZE;\n+    }\n+  BITMAP_XFREE (si.va_list_vars);\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"%s: va_list escapes %d, needs to save \",\n+\t       funcname, (int) va_list_escapes);\n+      if (cfun->va_list_gpr_size >= VA_LIST_MAX_GPR_SIZE)\n+\tfputs (\"all\", dump_file);\n+      else\n+\tfprintf (dump_file, \"%d\", cfun->va_list_gpr_size);\n+      fputs (\" GPR units and \", dump_file);\n+      if (cfun->va_list_fpr_size >= VA_LIST_MAX_FPR_SIZE)\n+\tfputs (\"all\", dump_file);\n+      else\n+\tfprintf (dump_file, \"%d\", cfun->va_list_fpr_size);\n+      fputs (\" FPR units.\\n\", dump_file);\n+    }\n+}\n+\n+\n+struct tree_opt_pass pass_stdarg =\n+{\n+  \"stdarg\",\t\t\t\t/* name */\n+  gate_optimize_stdarg,\t\t\t/* gate */\n+  execute_optimize_stdarg,\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  0,\t\t\t\t\t/* tv_id */\n+  PROP_cfg | PROP_ssa | PROP_alias,\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func,\t\t\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};"}, {"sha": "b1f8e3a87417de67f7d43986c8f4a407b1a01818", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c8adc12700ffb0a3fe9406863c869afe67b99d/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=58c8adc12700ffb0a3fe9406863c869afe67b99d", "patch": "@@ -2568,6 +2568,8 @@ enum tree_index\n   TI_PID_TYPE,\n   TI_PTRDIFF_TYPE,\n   TI_VA_LIST_TYPE,\n+  TI_VA_LIST_GPR_COUNTER_FIELD,\n+  TI_VA_LIST_FPR_COUNTER_FIELD,\n   TI_BOOLEAN_TYPE,\n   TI_FILEPTR_TYPE,\n \n@@ -2634,6 +2636,8 @@ extern GTY(()) tree global_trees[TI_MAX];\n #define pid_type_node                   global_trees[TI_PID_TYPE]\n #define ptrdiff_type_node\t\tglobal_trees[TI_PTRDIFF_TYPE]\n #define va_list_type_node\t\tglobal_trees[TI_VA_LIST_TYPE]\n+#define va_list_gpr_counter_field\tglobal_trees[TI_VA_LIST_GPR_COUNTER_FIELD]\n+#define va_list_fpr_counter_field\tglobal_trees[TI_VA_LIST_FPR_COUNTER_FIELD]\n /* The C type `FILE *'.  */\n #define fileptr_type_node\t\tglobal_trees[TI_FILEPTR_TYPE]\n "}]}