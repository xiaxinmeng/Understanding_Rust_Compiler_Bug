{"sha": "f1355c8ddab619f0e5fae40cbdca33d468780b58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjEzNTVjOGRkYWI2MTlmMGU1ZmFlNDBjYmRjYTMzZDQ2ODc4MGI1OA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-12-05T12:46:50Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-12-05T12:46:50Z"}, "message": "libstdc++: Define std::lexicographical_compare_three_way for C++20\n\n\t* include/bits/stl_algobase.h (lexicographical_compare_three_way):\n\tDefine for C++20.\n\t* testsuite/25_algorithms/lexicographical_compare_three_way/1.cc: New\n\ttest.\n\t* testsuite/25_algorithms/lexicographical_compare_three_way/\n\tconstexpr.cc: New test.\n\nFrom-SVN: r278996", "tree": {"sha": "961dfd9f3bcd12e6cefd86477fda23cf144354bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/961dfd9f3bcd12e6cefd86477fda23cf144354bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1355c8ddab619f0e5fae40cbdca33d468780b58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1355c8ddab619f0e5fae40cbdca33d468780b58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1355c8ddab619f0e5fae40cbdca33d468780b58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1355c8ddab619f0e5fae40cbdca33d468780b58/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16e81d5193f6067be90abfa0cbcb15328ce16e2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16e81d5193f6067be90abfa0cbcb15328ce16e2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16e81d5193f6067be90abfa0cbcb15328ce16e2a"}], "stats": {"total": 302, "additions": 302, "deletions": 0}, "files": [{"sha": "a5ed14528df87acf263f3cdf2a80decfedbbe593", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1355c8ddab619f0e5fae40cbdca33d468780b58/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1355c8ddab619f0e5fae40cbdca33d468780b58/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=f1355c8ddab619f0e5fae40cbdca33d468780b58", "patch": "@@ -1,5 +1,12 @@\n 2019-12-05  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* include/bits/stl_algobase.h (lexicographical_compare_three_way):\n+\tDefine for C++20.\n+\t* testsuite/25_algorithms/lexicographical_compare_three_way/1.cc: New\n+\ttest.\n+\t* testsuite/25_algorithms/lexicographical_compare_three_way/\n+\tconstexpr.cc: New test.\n+\n \t* python/libstdcxx/v6/printers.py (StdCmpCatPrinter): New printer.\n \t* testsuite/libstdc++-prettyprinters/cxx20.cc: New test.\n "}, {"sha": "a2fd306e6d0cca579b510148ba1a7089e2b2f3a2", "filename": "libstdc++-v3/include/bits/stl_algobase.h", "status": "modified", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1355c8ddab619f0e5fae40cbdca33d468780b58/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1355c8ddab619f0e5fae40cbdca33d468780b58/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h?ref=f1355c8ddab619f0e5fae40cbdca33d468780b58", "patch": "@@ -72,6 +72,9 @@\n #if __cplusplus >= 201103L\n # include <type_traits>\n #endif\n+#if __cplusplus > 201703L\n+# include <compare>\n+#endif\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n@@ -1456,6 +1459,104 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO\n \t __gnu_cxx::__ops::__iter_comp_iter(__comp));\n     }\n \n+#if __cpp_lib_three_way_comparison\n+#if __cpp_lib_concepts\n+  // Iter points to a contiguous range of unsigned narrow character type\n+  // or std::byte, suitable for comparison by memcmp.\n+  template<typename _Iter>\n+    concept __is_byte_iter = contiguous_iterator<_Iter>\n+      && __is_byte<iter_value_t<_Iter>>::__value != 0\n+      && !__gnu_cxx::__numeric_traits<iter_value_t<_Iter>>::__is_signed;\n+\n+  // Return a struct with two members, initialized to the smaller of x and y\n+  // (or x if they compare equal) and the result of the comparison x <=> y.\n+  template<typename _Tp>\n+    constexpr auto\n+    __min_cmp(_Tp __x, _Tp __y)\n+    {\n+      struct _Res {\n+\t_Tp _M_min;\n+\tdecltype(__x <=> __y) _M_cmp;\n+      };\n+      auto __c = __x <=> __y;\n+      if (__c > 0)\n+\treturn _Res{__y, __c};\n+      return _Res{__x, __c};\n+    }\n+#endif\n+\n+  /**\n+   *  @brief Performs dictionary comparison on ranges.\n+   *  @ingroup sorting_algorithms\n+   *  @param  __first1  An input iterator.\n+   *  @param  __last1   An input iterator.\n+   *  @param  __first2  An input iterator.\n+   *  @param  __last2   An input iterator.\n+   *  @param  __comp  A @link comparison_functors comparison functor@endlink.\n+   *  @return   The comparison category that `__comp(*__first1, *__first2)`\n+   *\t\treturns.\n+  */\n+  template<typename _InputIter1, typename _InputIter2, typename _Comp>\n+    constexpr auto\n+    lexicographical_compare_three_way(_InputIter1 __first1,\n+\t\t\t\t      _InputIter1 __last1,\n+\t\t\t\t      _InputIter2 __first2,\n+\t\t\t\t      _InputIter2 __last2,\n+\t\t\t\t      _Comp __comp)\n+    -> decltype(__comp(*__first1, *__first2))\n+    {\n+      // concept requirements\n+      __glibcxx_function_requires(_InputIteratorConcept<_InputIter1>)\n+      __glibcxx_function_requires(_InputIteratorConcept<_InputIter2>)\n+      __glibcxx_requires_valid_range(__first1, __last1);\n+      __glibcxx_requires_valid_range(__first2, __last2);\n+\n+#if __cpp_lib_concepts && __cpp_lib_is_constant_evaluated\n+      using _Cat = decltype(__comp(*__first1, *__first2));\n+      static_assert(same_as<common_comparison_category_t<_Cat>, _Cat>);\n+\n+      if (!std::is_constant_evaluated())\n+\tif constexpr (same_as<_Comp, __detail::_Synth3way>\n+\t\t      || same_as<_Comp, compare_three_way>)\n+\t  if constexpr (__is_byte_iter<_InputIter1>)\n+\t    if constexpr (__is_byte_iter<_InputIter2>)\n+\t      {\n+\t\tconst auto [__len, __lencmp]\n+\t\t  = std::__min_cmp(__last1 - __first1, __last2 - __first2);\n+\t\tif (__len)\n+\t\t  {\n+\t\t    const auto __c\n+\t\t      = __builtin_memcmp(&*__first1, &*__first2, __len) <=> 0;\n+\t\t    if (__c != 0)\n+\t\t      return __c;\n+\t\t  }\n+\t\treturn __lencmp;\n+\t      }\n+#endif // concepts && is_constant_evaluated\n+      while (__first1 != __last1 && __first2 != __last2)\n+\t{\n+\t  if (auto __cmp = __comp(*__first1, *__first2); __cmp != 0)\n+\t    return __cmp;\n+\t  ++__first1;\n+\t  ++__first2;\n+\t}\n+      return __first1 != __last1 ? strong_ordering::greater\n+\t: __first2 != __last2 ? strong_ordering::less : strong_ordering::equal;\n+    }\n+\n+  template<typename _InputIter1, typename _InputIter2>\n+    constexpr auto\n+    lexicographical_compare_three_way(_InputIter1 __first1,\n+\t\t\t\t      _InputIter1 __last1,\n+\t\t\t\t      _InputIter2 __first2,\n+\t\t\t\t      _InputIter2 __last2)\n+    {\n+      return std::lexicographical_compare_three_way(__first1, __last1,\n+\t\t\t\t\t\t    __first2, __last2,\n+\t\t\t\t\t\t    compare_three_way{});\n+    }\n+#endif // three_way_comparison\n+\n   template<typename _InputIterator1, typename _InputIterator2,\n \t   typename _BinaryPredicate>\n     _GLIBCXX20_CONSTEXPR"}, {"sha": "b1e70e80de7ff496a9778e287a7d4fe7dd13baf6", "filename": "libstdc++-v3/testsuite/25_algorithms/lexicographical_compare_three_way/1.cc", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1355c8ddab619f0e5fae40cbdca33d468780b58/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Flexicographical_compare_three_way%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1355c8ddab619f0e5fae40cbdca33d468780b58/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Flexicographical_compare_three_way%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Flexicographical_compare_three_way%2F1.cc?ref=f1355c8ddab619f0e5fae40cbdca33d468780b58", "patch": "@@ -0,0 +1,129 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+// Lambda that calls lexicographical_compare_three_way on two ranges.\n+// Arguments are passed by value intentionally, so that a copy of the range\n+// is traversed and the original is not modified. Otherwise when the range\n+// has input iterators the range will be consumed after the first comparison.\n+auto lexicomp3 = [](auto r1, auto r2) {\n+  return std::lexicographical_compare_three_way(r1.begin(), r1.end(),\n+\t\t\t\t\t\tr2.begin(), r2.end());\n+};\n+\n+void\n+test01()\n+{\n+  using __gnu_test::test_container;\n+  using __gnu_test::input_iterator_wrapper;\n+  using __gnu_test::forward_iterator_wrapper;\n+  int arr1[] = { 0, 1, 2, 3, 4, 5, 6, 7 };\n+  int arr2[] = { 0, 1, 2, 3, 4, 5, 6, 777 };\n+\n+  {\n+    test_container<int, input_iterator_wrapper> c1(arr1);\n+    test_container<int, input_iterator_wrapper> c2(arr2);\n+    VERIFY( lexicomp3(c1, c1) == 0 );\n+    VERIFY( lexicomp3(c1, c2) < 0 );\n+    VERIFY( lexicomp3(c2, c1) > 0 );\n+  }\n+\n+  {\n+    test_container<int, input_iterator_wrapper> c1(arr1, arr1+6);\n+    test_container<int, input_iterator_wrapper> c2(arr2, arr2+6);\n+    VERIFY( lexicomp3(c1, c1) == 0 );\n+    VERIFY( lexicomp3(c1, c2) == 0 );\n+    VERIFY( lexicomp3(c2, c1) == 0 );\n+  }\n+\n+  {\n+    test_container<int, input_iterator_wrapper> c1(arr1);\n+    test_container<int, input_iterator_wrapper> c2(arr2, arr2+7);\n+    VERIFY( lexicomp3(c1, c1) == 0 );\n+    VERIFY( lexicomp3(c1, c2) > 0 );\n+    VERIFY( lexicomp3(c2, c1) < 0 );\n+  }\n+\n+  {\n+    test_container<int, input_iterator_wrapper> c1(arr1);\n+    test_container<int, forward_iterator_wrapper> c2(arr2);\n+    VERIFY( lexicomp3(c1, c1) == 0 );\n+    VERIFY( lexicomp3(c1, c2) < 0 );\n+    VERIFY( lexicomp3(c2, c1) > 0 );\n+  }\n+\n+  {\n+    test_container<int, input_iterator_wrapper> c1(arr1);\n+    test_container<int, forward_iterator_wrapper> c2(arr2, arr2+7);\n+    VERIFY( lexicomp3(c1, c1) == 0 );\n+    VERIFY( lexicomp3(c2, c2) == 0 );\n+    VERIFY( lexicomp3(c1, c2) > 0 );\n+    VERIFY( lexicomp3(c2, c1) < 0 );\n+  }\n+\n+  {\n+    test_container<int, forward_iterator_wrapper> c1(arr1, arr1+7);\n+    test_container<int, input_iterator_wrapper> c2(arr2);\n+    VERIFY( lexicomp3(c1, c1) == 0 );\n+    VERIFY( lexicomp3(c2, c2) == 0 );\n+    VERIFY( lexicomp3(c1, c2) < 0 );\n+    VERIFY( lexicomp3(c2, c1) > 0 );\n+  }\n+}\n+\n+void\n+test02()\n+{\n+  using __gnu_test::test_container;\n+  using __gnu_test::input_iterator_wrapper;\n+  using __gnu_test::forward_iterator_wrapper;\n+  std::array<unsigned char, 8> c1 = { 0, 1, 2, 3, 4, 5, 6, 7 };\n+  std::array<unsigned char, 8> c2 = { 0, 1, 2, 3, 4, 5, 6, 77 };\n+\n+  VERIFY( lexicomp3(c1, c1) == 0 );\n+  VERIFY( lexicomp3(c1, c2) < 0 );\n+  VERIFY( lexicomp3(c2, c1) > 0 );\n+\n+  std::array<unsigned char, 7> c3 = { 0, 1, 2, 3, 4, 5, 6 };\n+  VERIFY( lexicomp3(c3, c3) == 0 );\n+  VERIFY( lexicomp3(c1, c3) > 0 );\n+  VERIFY( lexicomp3(c3, c1) < 0 );\n+}\n+\n+void\n+test03()\n+{\n+  unsigned char a[2] = { 1, 2 };\n+  unsigned char* p = nullptr;\n+  // ensure memcmp not called with nullptr\n+  VERIFY( std::lexicographical_compare_three_way(p, p, a, a+2) < 0 );\n+  VERIFY( std::lexicographical_compare_three_way(a, a+2, p, p) > 0 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "5d1e15cc4f314ebb063a75c9367c620439f6c48b", "filename": "libstdc++-v3/testsuite/25_algorithms/lexicographical_compare_three_way/constexpr.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1355c8ddab619f0e5fae40cbdca33d468780b58/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Flexicographical_compare_three_way%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1355c8ddab619f0e5fae40cbdca33d468780b58/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Flexicographical_compare_three_way%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Flexicographical_compare_three_way%2Fconstexpr.cc?ref=f1355c8ddab619f0e5fae40cbdca33d468780b58", "patch": "@@ -0,0 +1,65 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <algorithm>\n+\n+constexpr bool\n+test01(int i)\n+{\n+  int a1[] = { 0, 1, 2, 3, 4, 5, 6, i, 8 };\n+  long a2[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8 };\n+\n+  return std::lexicographical_compare_three_way(a1, a1+0, a2, a2+0) == 0\n+    && std::lexicographical_compare_three_way(a1, a1+9, a2, a2+9) == (i <=> 7)\n+    && std::lexicographical_compare_three_way(a1, a1+7, a2, a2+7) == 0\n+    && std::lexicographical_compare_three_way(a1, a1+8, a2, a2+7) > 0\n+    && std::lexicographical_compare_three_way(a1, a1+7, a2, a2+8) < 0;\n+}\n+\n+static_assert( test01(~7) );\n+static_assert( test01(7) );\n+static_assert( test01(8) );\n+\n+constexpr bool\n+test02(unsigned char i)\n+{\n+  unsigned char a1[] = { 0, 1, 2, 3, 4, 5, 6, i, 8 };\n+  unsigned char a2[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8 };\n+\n+  return std::lexicographical_compare_three_way(a1, a1+0, a2, a2+0) == 0\n+    && std::lexicographical_compare_three_way(a1, a1+9, a2, a2+9) == (i <=> 7)\n+    && std::lexicographical_compare_three_way(a1, a1+7, a2, a2+7) == 0\n+    && std::lexicographical_compare_three_way(a1, a1+8, a2, a2+7) > 0\n+    && std::lexicographical_compare_three_way(a1, a1+7, a2, a2+8) < 0;\n+}\n+\n+static_assert( test02(248) );\n+static_assert( test02(7) );\n+static_assert( test02(8) );\n+\n+constexpr bool\n+test03(unsigned char* p)\n+{\n+  unsigned char a[2] = { 1, 2 };\n+  return std::lexicographical_compare_three_way(p, p, a, a+2) < 0\n+    && std::lexicographical_compare_three_way(a, a+2, p, p) > 0;\n+}\n+\n+static_assert( test03(nullptr) ); // ensure memcmp not called with nullptr"}]}