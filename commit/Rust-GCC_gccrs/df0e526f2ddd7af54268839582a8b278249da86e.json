{"sha": "df0e526f2ddd7af54268839582a8b278249da86e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGYwZTUyNmYyZGRkN2FmNTQyNjg4Mzk1ODJhOGIyNzgyNDlkYTg2ZQ==", "commit": {"author": {"name": "Andreas Schwab", "email": "schwab@issan.informatik.uni-dortmund.de", "date": "1998-06-02T21:53:37Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-06-02T21:53:37Z"}, "message": "fold-const.c (fold, [...]): When folding VAR++ == CONST or VAR-- == CONST construct a proper mask if...\n\n        * fold-const.c (fold, case EQ_EXPR): When folding VAR++ == CONST\n        or VAR-- == CONST construct a proper mask if VAR is a bitfield.\n        Cope with CONST being out of range for the bitfield.\n\nFrom-SVN: r20198", "tree": {"sha": "1ebe3908161c9d4f702e0bf08a2f7ff5e4835a9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ebe3908161c9d4f702e0bf08a2f7ff5e4835a9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df0e526f2ddd7af54268839582a8b278249da86e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df0e526f2ddd7af54268839582a8b278249da86e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df0e526f2ddd7af54268839582a8b278249da86e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df0e526f2ddd7af54268839582a8b278249da86e/comments", "author": null, "committer": null, "parents": [{"sha": "ccdb92510523a0302c4bd058a51530d089aac21f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccdb92510523a0302c4bd058a51530d089aac21f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccdb92510523a0302c4bd058a51530d089aac21f"}], "stats": {"total": 59, "additions": 55, "deletions": 4}, "files": [{"sha": "af9dab8ee9ce26d167d1cd16305055f2a386f447", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df0e526f2ddd7af54268839582a8b278249da86e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df0e526f2ddd7af54268839582a8b278249da86e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=df0e526f2ddd7af54268839582a8b278249da86e", "patch": "@@ -1,3 +1,9 @@\n+Tue Jun  2 22:50:10 1998  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.de>\n+\n+\t* fold-const.c (fold, case EQ_EXPR): When folding VAR++ == CONST\n+\tor VAR-- == CONST construct a proper mask if VAR is a bitfield.\n+\tCope with CONST being out of range for the bitfield.\n+\n Tue Jun  2 22:28:31 1998  Bernd Schmidt <crux@ohara.Informatik.RWTH-Aachen.DE>\n \n \t* expr.c (emit_move_insn_1): When moving complex values in several"}, {"sha": "d8477645c530375890b385602c27024ec62c628b", "filename": "gcc/fold-const.c", "status": "modified", "additions": 49, "deletions": 4, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df0e526f2ddd7af54268839582a8b278249da86e/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df0e526f2ddd7af54268839582a8b278249da86e/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=df0e526f2ddd7af54268839582a8b278249da86e", "patch": "@@ -5222,11 +5222,35 @@ fold (expr)\n \t\t      = TREE_INT_CST_LOW (DECL_SIZE\n \t\t\t\t\t  (TREE_OPERAND\n \t\t\t\t\t   (TREE_OPERAND (varop, 0), 1)));\n-\n+\t\t    tree mask, unsigned_type;\n+\t\t    int precision;\n+\t\t    tree folded_compare;\n+\n+\t\t    /* First check whether the comparison would come out\n+\t\t       always the same.  If we don't do that we would\n+\t\t       change the meaning with the masking.  */\n+\t\t    if (constopnum == 0)\n+\t\t      folded_compare = fold (build (code, type, constop,\n+\t\t\t\t\t\t    TREE_OPERAND (varop, 0)));\n+\t\t    else\n+\t\t      folded_compare = fold (build (code, type,\n+\t\t\t\t\t\t    TREE_OPERAND (varop, 0),\n+\t\t\t\t\t\t    constop));\n+\t\t    if (integer_zerop (folded_compare)\n+\t\t\t|| integer_onep (folded_compare))\n+\t\t      return omit_one_operand (type, folded_compare, varop);\n+\n+\t\t    unsigned_type = type_for_size (size, 1);\n+\t\t    precision = TYPE_PRECISION (unsigned_type);\n+\t\t    mask = build_int_2 (~0, ~0);\n+\t\t    TREE_TYPE (mask) = unsigned_type;\n+\t\t    force_fit_type (mask, 0);\n+\t\t    mask = const_binop (RSHIFT_EXPR, mask,\n+\t\t\t\t\tsize_int (precision - size), 0);\n \t\t    newconst = fold (build (BIT_AND_EXPR,\n \t\t\t\t\t    TREE_TYPE (varop), newconst,\n \t\t\t\t\t    convert (TREE_TYPE (varop),\n-\t\t\t\t\t\t     build_int_2 (size, 0))));\n+\t\t\t\t\t\t     mask)));\n \t\t  }\n \t\t\t\t\t\t\t \n \n@@ -5255,11 +5279,32 @@ fold (expr)\n \t\t      = TREE_INT_CST_LOW (DECL_SIZE\n \t\t\t\t\t  (TREE_OPERAND\n \t\t\t\t\t   (TREE_OPERAND (varop, 0), 1)));\n-\n+\t\t    tree mask, unsigned_type;\n+\t\t    int precision;\n+\t\t    tree folded_compare;\n+\n+\t\t    if (constopnum == 0)\n+\t\t      folded_compare = fold (build (code, type, constop,\n+\t\t\t\t\t\t    TREE_OPERAND (varop, 0)));\n+\t\t    else\n+\t\t      folded_compare = fold (build (code, type,\n+\t\t\t\t\t\t    TREE_OPERAND (varop, 0),\n+\t\t\t\t\t\t    constop));\n+\t\t    if (integer_zerop (folded_compare)\n+\t\t\t|| integer_onep (folded_compare))\n+\t\t      return omit_one_operand (type, folded_compare, varop);\n+\n+\t\t    unsigned_type = type_for_size (size, 1);\n+\t\t    precision = TYPE_PRECISION (unsigned_type);\n+\t\t    mask = build_int_2 (~0, ~0);\n+\t\t    TREE_TYPE (mask) = TREE_TYPE (varop);\n+\t\t    force_fit_type (mask, 0);\n+\t\t    mask = const_binop (RSHIFT_EXPR, mask,\n+\t\t\t\t\tsize_int (precision - size), 0);\n \t\t    newconst = fold (build (BIT_AND_EXPR,\n \t\t\t\t\t    TREE_TYPE (varop), newconst,\n \t\t\t\t\t    convert (TREE_TYPE (varop),\n-\t\t\t\t\t\t     build_int_2 (size, 0))));\n+\t\t\t\t\t\t     mask)));\n \t\t  }\n \t\t\t\t\t\t\t \n "}]}