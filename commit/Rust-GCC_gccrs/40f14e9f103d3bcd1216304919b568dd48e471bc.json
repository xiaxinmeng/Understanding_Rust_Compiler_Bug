{"sha": "40f14e9f103d3bcd1216304919b568dd48e471bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBmMTRlOWYxMDNkM2JjZDEyMTYzMDQ5MTliNTY4ZGQ0OGU0NzFiYw==", "commit": {"author": {"name": "Balaji V. Iyer", "email": "balaji.v.iyer@intel.com", "date": "2014-01-23T17:00:53Z"}, "committer": {"name": "Balaji V. Iyer", "email": "bviyer@gcc.gnu.org", "date": "2014-01-23T17:00:53Z"}, "message": "re PR c/59825 (Many cilkplus test failures)\n\nFix for PR c/59825.\n2014-01-23  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n\n        PR c/59825\n        * c-array-notation.c (expand_array_notation_exprs): Rewrote this\n        function to use walk_tree and moved a lot of its functionality to\n        expand_array_notations.\n        (expand_array_notations): New function.\n\nFrom-SVN: r206991", "tree": {"sha": "5169513707a6f8d8bcc95326cc2a05ff5acac171", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5169513707a6f8d8bcc95326cc2a05ff5acac171"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40f14e9f103d3bcd1216304919b568dd48e471bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40f14e9f103d3bcd1216304919b568dd48e471bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40f14e9f103d3bcd1216304919b568dd48e471bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40f14e9f103d3bcd1216304919b568dd48e471bc/comments", "author": null, "committer": null, "parents": [{"sha": "c733429f54ace8a10f50c2a751a0c2c940b8c9ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c733429f54ace8a10f50c2a751a0c2c940b8c9ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c733429f54ace8a10f50c2a751a0c2c940b8c9ce"}], "stats": {"total": 113, "additions": 61, "deletions": 52}, "files": [{"sha": "a158f11cb01b90535d90a90e402397a4ec2791b0", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f14e9f103d3bcd1216304919b568dd48e471bc/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f14e9f103d3bcd1216304919b568dd48e471bc/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=40f14e9f103d3bcd1216304919b568dd48e471bc", "patch": "@@ -1,3 +1,11 @@\n+2014-01-23  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\n+\tPR c/59825\n+\t* c-array-notation.c (expand_array_notation_exprs): Rewrote this\n+\tfunction to use walk_tree and moved a lot of its functionality to\n+\texpand_array_notations.\n+\t(expand_array_notations): New function.\n+\n 2014-01-23  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n \n \t* c-parser.c (c_finish_omp_declare_simd): Made \"cilk simd function\""}, {"sha": "6a5631c3b6f530b134f1364734d74cd7111f79aa", "filename": "gcc/c/c-array-notation.c", "status": "modified", "additions": 53, "deletions": 52, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40f14e9f103d3bcd1216304919b568dd48e471bc/gcc%2Fc%2Fc-array-notation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40f14e9f103d3bcd1216304919b568dd48e471bc/gcc%2Fc%2Fc-array-notation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-array-notation.c?ref=40f14e9f103d3bcd1216304919b568dd48e471bc", "patch": "@@ -1218,84 +1218,85 @@ fix_return_expr (tree expr)\n   return new_mod_list;\n }\n \n-/* Walks through tree node T and find all the call-statements that do not return\n-   anything and fix up any array notations they may carry.  The return value\n-   is the same type as T but with all array notations replaced with appropriate\n-   STATEMENT_LISTS.  */\n+/* Callback for walk_tree.  Expands all array notations in *TP.  *WALK_SUBTREES\n+   is set to 1 unless *TP contains no array notation expressions.  */\n \n-tree\n-expand_array_notation_exprs (tree t)\n+static tree\n+expand_array_notations (tree *tp, int *walk_subtrees, void *)\n {\n-  if (!contains_array_notation_expr (t))\n-    return t;\n+  if (!contains_array_notation_expr (*tp))\n+    {\n+      *walk_subtrees = 0;\n+      return NULL_TREE;\n+    }\n+  *walk_subtrees = 1;\n \n-  switch (TREE_CODE (t))\n+  switch (TREE_CODE (*tp))\n     {\n-    case BIND_EXPR:\n-      t = expand_array_notation_exprs (BIND_EXPR_BODY (t));\n-      return t;\n     case TRUTH_ORIF_EXPR:\n     case TRUTH_ANDIF_EXPR:\n     case TRUTH_OR_EXPR:\n     case TRUTH_AND_EXPR:\n     case TRUTH_XOR_EXPR:\n     case TRUTH_NOT_EXPR:\n     case COND_EXPR:\n-      t = fix_conditional_array_notations (t);\n-\n-      /* After the expansion if they are still a COND_EXPR, we go into its\n-\t subtrees.  */\n-      if (TREE_CODE (t) == COND_EXPR)\n-\t{\n-\t  if (COND_EXPR_THEN (t))\n-\t    COND_EXPR_THEN (t) =\n-\t      expand_array_notation_exprs (COND_EXPR_THEN (t));\n-\t  if (COND_EXPR_ELSE (t))\n-\t    COND_EXPR_ELSE (t) =\n-\t      expand_array_notation_exprs (COND_EXPR_ELSE (t));\n-\t}\n-      return t;\n-    case STATEMENT_LIST:\n-      {\n-\ttree_stmt_iterator ii_tsi;\n-\tfor (ii_tsi = tsi_start (t); !tsi_end_p (ii_tsi); tsi_next (&ii_tsi))\n-\t  *tsi_stmt_ptr (ii_tsi) = \n-\t    expand_array_notation_exprs (*tsi_stmt_ptr (ii_tsi));\n-      }\n-      return t;\n+      *tp = fix_conditional_array_notations (*tp);\n+      break;\n     case MODIFY_EXPR:\n       {\n-\tlocation_t loc = EXPR_HAS_LOCATION (t) ? EXPR_LOCATION (t) :\n+\tlocation_t loc = EXPR_HAS_LOCATION (*tp) ? EXPR_LOCATION (*tp) :\n \t  UNKNOWN_LOCATION;\n-\ttree lhs = TREE_OPERAND (t, 0);\n-\ttree rhs = TREE_OPERAND (t, 1);\n+\ttree lhs = TREE_OPERAND (*tp, 0);\n+\ttree rhs = TREE_OPERAND (*tp, 1);\n \tlocation_t rhs_loc = EXPR_HAS_LOCATION (rhs) ? EXPR_LOCATION (rhs) :\n \t  UNKNOWN_LOCATION;\n-\tt = build_array_notation_expr (loc, lhs, TREE_TYPE (lhs), NOP_EXPR,\n-\t\t\t\t       rhs_loc, rhs, TREE_TYPE (rhs));\n-\treturn t;\n+\t*tp = build_array_notation_expr (loc, lhs, TREE_TYPE (lhs), NOP_EXPR,\n+\t\t\t\t\t rhs_loc, rhs, TREE_TYPE (rhs));\n       }\n+      break;\n     case CALL_EXPR:\n-      t = fix_array_notation_call_expr (t);\n-      return t;\n+      *tp = fix_array_notation_call_expr (*tp);\n+      break;\n     case RETURN_EXPR:\n-      if (contains_array_notation_expr (t))\n-\tt = fix_return_expr (t);\n-      return t;\n+      *tp = fix_return_expr (*tp);\n+      break;\n+    case COMPOUND_EXPR:\n+      if (TREE_CODE (TREE_OPERAND (*tp, 0)) == SAVE_EXPR)\n+\t{\n+\t  /* In here we are calling expand_array_notations because\n+\t     we need to be able to catch the return value and check if\n+\t     it is an error_mark_node.  */\n+\t  expand_array_notations (&TREE_OPERAND (*tp, 1), walk_subtrees, NULL);\n+\n+\t  /* SAVE_EXPR cannot have an error_mark_node inside it.  This check\n+\t     will make sure that if there is an error in expanding of\n+\t     array notations (e.g. rank mismatch) then replace the entire\n+\t     SAVE_EXPR with an error_mark_node.  */\n+\t  if (TREE_OPERAND (*tp, 1) == error_mark_node)\n+\t    *tp = error_mark_node;\n+\t}\n+      break;\n     case ARRAY_NOTATION_REF:\n-      /* IF we are here, then we are dealing with cases like this:\n+      /* If we are here, then we are dealing with cases like this:\n \t A[:];\n \t A[x:y:z];\n \t A[x:y];\n \t Replace those with just void zero node.  */\n-      t = void_zero_node;\n+      *tp = void_zero_node;\n     default:\n-      for (int ii = 0; ii < TREE_CODE_LENGTH (TREE_CODE (t)); ii++)\n-\tif (contains_array_notation_expr (TREE_OPERAND (t, ii)))\n-\t  TREE_OPERAND (t, ii) =\n-\t    expand_array_notation_exprs (TREE_OPERAND (t, ii));\n-      return t;\n+      break;\n     }\n+  return NULL_TREE;\n+} \n+\n+/* Walks through tree node T and expands all array notations in its subtrees.\n+   The return value is the same type as T but with all array notations \n+   replaced with appropriate ARRAY_REFS with a loop around it.  */\n+\n+tree\n+expand_array_notation_exprs (tree t)\n+{\n+  walk_tree (&t, expand_array_notations, NULL, NULL);\n   return t;\n }\n "}]}