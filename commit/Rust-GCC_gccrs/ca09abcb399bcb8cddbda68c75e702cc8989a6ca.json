{"sha": "ca09abcb399bcb8cddbda68c75e702cc8989a6ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2EwOWFiY2IzOTliY2I4Y2RkYmRhNjhjNzVlNzAyY2M4OTg5YTZjYQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-09-14T16:30:54Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-09-14T16:30:54Z"}, "message": "Add a vect_worthwhile_without_simd_p helper routine\n\nThe vectoriser sometimes considers lowering \"vector\" operations into N\nscalar word operations.  This N needs to be fixed at compile time, so\nthe condition guarding it needs to change when variable-lengh vectors\nare added.  This patch puts the condition into a helper routine so that\nthere's only one place to update.\n\n2017-09-14  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (vect_min_worthwhile_factor): Delete.\n\t(vect_worthwhile_without_simd_p): Declare.\n\t* tree-vect-loop.c (vect_worthwhile_without_simd_p): New function.\n\t(vectorizable_reduction): Use it.\n\t* tree-vect-stmts.c (vectorizable_shift): Likewise.\n\t(vectorizable_operation): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r252765", "tree": {"sha": "3ba3014d56b97b588ffff4dc42c54a581319a315", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ba3014d56b97b588ffff4dc42c54a581319a315"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca09abcb399bcb8cddbda68c75e702cc8989a6ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca09abcb399bcb8cddbda68c75e702cc8989a6ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca09abcb399bcb8cddbda68c75e702cc8989a6ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca09abcb399bcb8cddbda68c75e702cc8989a6ca/comments", "author": null, "committer": null, "parents": [{"sha": "e8f142e28262a5048c6f40f4bfb6a612d3da55f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8f142e28262a5048c6f40f4bfb6a612d3da55f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8f142e28262a5048c6f40f4bfb6a612d3da55f0"}], "stats": {"total": 57, "additions": 33, "deletions": 24}, "files": [{"sha": "c3ab19aa7da67a1ddb2418add9db87417980e1cc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca09abcb399bcb8cddbda68c75e702cc8989a6ca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca09abcb399bcb8cddbda68c75e702cc8989a6ca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca09abcb399bcb8cddbda68c75e702cc8989a6ca", "patch": "@@ -1,3 +1,14 @@\n+2017-09-14  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree-vectorizer.h (vect_min_worthwhile_factor): Delete.\n+\t(vect_worthwhile_without_simd_p): Declare.\n+\t* tree-vect-loop.c (vect_worthwhile_without_simd_p): New function.\n+\t(vectorizable_reduction): Use it.\n+\t* tree-vect-stmts.c (vectorizable_shift): Likewise.\n+\t(vectorizable_operation): Likewise.\n+\n 2017-09-14  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "f0eafc58504e546a35a3e46c8a3d55a2f7fa8339", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca09abcb399bcb8cddbda68c75e702cc8989a6ca/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca09abcb399bcb8cddbda68c75e702cc8989a6ca/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=ca09abcb399bcb8cddbda68c75e702cc8989a6ca", "patch": "@@ -6030,8 +6030,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n             dump_printf (MSG_NOTE, \"op not supported by target.\\n\");\n \n           if (GET_MODE_SIZE (vec_mode) != UNITS_PER_WORD\n-              || LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n-\t          < vect_min_worthwhile_factor (code))\n+\t      || !vect_worthwhile_without_simd_p (loop_vinfo, code))\n             return false;\n \n           if (dump_enabled_p ())\n@@ -6040,8 +6039,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \n       /* Worthwhile without SIMD support?  */\n       if (!VECTOR_MODE_P (TYPE_MODE (vectype_in))\n-          && LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n-   \t     < vect_min_worthwhile_factor (code))\n+\t  && !vect_worthwhile_without_simd_p (loop_vinfo, code))\n         {\n           if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -6492,6 +6490,18 @@ vect_min_worthwhile_factor (enum tree_code code)\n     }\n }\n \n+/* Return true if VINFO indicates we are doing loop vectorization and if\n+   it is worth decomposing CODE operations into scalar operations for\n+   that loop's vectorization factor.  */\n+\n+bool\n+vect_worthwhile_without_simd_p (vec_info *vinfo, tree_code code)\n+{\n+  loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo);\n+  return (loop_vinfo\n+\t  && (LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n+\t      >= vect_min_worthwhile_factor (code)));\n+}\n \n /* Function vectorizable_induction\n "}, {"sha": "74ffb646d58b1c761cdafb1ba61d77bd24294dd4", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca09abcb399bcb8cddbda68c75e702cc8989a6ca/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca09abcb399bcb8cddbda68c75e702cc8989a6ca/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=ca09abcb399bcb8cddbda68c75e702cc8989a6ca", "patch": "@@ -4869,7 +4869,6 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n   bool scalar_shift_arg = true;\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   vec_info *vinfo = stmt_info->vinfo;\n-  int vf;\n \n   if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n     return false;\n@@ -4937,11 +4936,6 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n       return false;\n     }\n \n-  if (loop_vinfo)\n-    vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-  else\n-    vf = 1;\n-\n   /* Multiple types in SLP are handled by creating the appropriate number of\n      vectorized stmts for each SLP node.  Hence, NCOPIES is always 1 in\n      case of SLP.  */\n@@ -5086,18 +5080,18 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n                          \"op not supported by target.\\n\");\n       /* Check only during analysis.  */\n       if (GET_MODE_SIZE (vec_mode) != UNITS_PER_WORD\n-          || (vf < vect_min_worthwhile_factor (code)\n-              && !vec_stmt))\n+\t  || (!vec_stmt\n+\t      && !vect_worthwhile_without_simd_p (vinfo, code)))\n         return false;\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n                          \"proceeding using word mode.\\n\");\n     }\n \n   /* Worthwhile without SIMD support?  Check only during analysis.  */\n-  if (!VECTOR_MODE_P (TYPE_MODE (vectype))\n-      && vf < vect_min_worthwhile_factor (code)\n-      && !vec_stmt)\n+  if (!vec_stmt\n+      && !VECTOR_MODE_P (TYPE_MODE (vectype))\n+      && !vect_worthwhile_without_simd_p (vinfo, code))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5241,7 +5235,6 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n   tree vop0, vop1, vop2;\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   vec_info *vinfo = stmt_info->vinfo;\n-  int vf;\n \n   if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n     return false;\n@@ -5368,11 +5361,6 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n \t}\n     }\n \n-  if (loop_vinfo)\n-    vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-  else\n-    vf = 1;\n-\n   /* Multiple types in SLP are handled by creating the appropriate number of\n      vectorized stmts for each SLP node.  Hence, NCOPIES is always 1 in\n      case of SLP.  */\n@@ -5414,7 +5402,7 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n                          \"op not supported by target.\\n\");\n       /* Check only during analysis.  */\n       if (GET_MODE_SIZE (vec_mode) != UNITS_PER_WORD\n-\t  || (!vec_stmt && vf < vect_min_worthwhile_factor (code)))\n+\t  || (!vec_stmt && !vect_worthwhile_without_simd_p (vinfo, code)))\n         return false;\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n@@ -5424,7 +5412,7 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n   /* Worthwhile without SIMD support?  Check only during analysis.  */\n   if (!VECTOR_MODE_P (vec_mode)\n       && !vec_stmt\n-      && vf < vect_min_worthwhile_factor (code))\n+      && !vect_worthwhile_without_simd_p (vinfo, code))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,"}, {"sha": "3807f60680f165be0770105a949d542bf4423232", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca09abcb399bcb8cddbda68c75e702cc8989a6ca/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca09abcb399bcb8cddbda68c75e702cc8989a6ca/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=ca09abcb399bcb8cddbda68c75e702cc8989a6ca", "patch": "@@ -1230,7 +1230,7 @@ extern bool vectorizable_reduction (gimple *, gimple_stmt_iterator *,\n extern bool vectorizable_induction (gimple *, gimple_stmt_iterator *,\n \t\t\t\t    gimple **, slp_tree);\n extern tree get_initial_def_for_reduction (gimple *, tree, tree *);\n-extern int vect_min_worthwhile_factor (enum tree_code);\n+extern bool vect_worthwhile_without_simd_p (vec_info *, tree_code);\n extern int vect_get_known_peeling_cost (loop_vec_info, int, int *,\n \t\t\t\t\tstmt_vector_for_cost *,\n \t\t\t\t\tstmt_vector_for_cost *,"}]}