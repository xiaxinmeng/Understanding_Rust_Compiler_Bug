{"sha": "5ca5ef68709f317927a055a610bfcec6e4ec0172", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWNhNWVmNjg3MDlmMzE3OTI3YTA1NWE2MTBiZmNlYzZlNGVjMDE3Mg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-05-28T08:47:33Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2019-05-28T08:47:33Z"}, "message": "implementation_defined_pragmas.rst (Machine_Attribute): Document additional optional parameters.\n\n\t* doc/gnat_rm/implementation_defined_pragmas.rst (Machine_Attribute):\n\tDocument additional optional parameters.\n\t* sem_prag.adb (Analyze_Pragma) <Pragma_Machine_Attribute>: Accept\n\tmore than one optional parameter.\n\t* gcc-interface/decl.c (prepend_one_attribute_pragma): Alphabetize\n\tthe list of supported pragmas.  Simplify the handling of parameters\n\tand add support for more than one optional parameter.\n\t* gcc-interface/utils.c (attr_cold_hot_exclusions): New constant.\n\t(gnat_internal_attribute_table): Add entry for no_icf, noipa, flatten,\n\tused, cold, hot, target and target_clones.\n\t(begin_subprog_body): Do not create the RTL for the subprogram here.\n\t(handle_noicf_attribute): New static function.\n\t(handle_noipa_attribute): Likewise.\n\t(handle_flatten_attribute): Likewise.\n\t(handle_used_attribute): Likewise.\n\t(handle_cold_attribute): Likewise.\n\t(handle_hot_attribute): Likewise.\n\t(handle_target_attribute): Likewise.\n\t(handle_target_clones_attribute): Likewise.\n\nFrom-SVN: r271693", "tree": {"sha": "dec6a653b7329a451f0344e9c05b5d25a6bffdb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dec6a653b7329a451f0344e9c05b5d25a6bffdb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ca5ef68709f317927a055a610bfcec6e4ec0172", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ca5ef68709f317927a055a610bfcec6e4ec0172", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ca5ef68709f317927a055a610bfcec6e4ec0172", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ca5ef68709f317927a055a610bfcec6e4ec0172/comments", "author": null, "committer": null, "parents": [{"sha": "79069232df7ae1f59c68bbe90804a30c2dbec5d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79069232df7ae1f59c68bbe90804a30c2dbec5d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79069232df7ae1f59c68bbe90804a30c2dbec5d3"}], "stats": {"total": 451, "additions": 383, "deletions": 68}, "files": [{"sha": "e0f3d0ab88300174fc0d4ae059ad01cfd4cc5818", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ca5ef68709f317927a055a610bfcec6e4ec0172/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ca5ef68709f317927a055a610bfcec6e4ec0172/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5ca5ef68709f317927a055a610bfcec6e4ec0172", "patch": "@@ -1,3 +1,25 @@\n+2019-05-28  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* doc/gnat_rm/implementation_defined_pragmas.rst (Machine_Attribute):\n+\tDocument additional optional parameters.\n+\t* sem_prag.adb (Analyze_Pragma) <Pragma_Machine_Attribute>: Accept\n+\tmore than one optional parameter.\n+\t* gcc-interface/decl.c (prepend_one_attribute_pragma): Alphabetize\n+\tthe list of supported pragmas.  Simplify the handling of parameters\n+\tand add support for more than one optional parameter.\n+\t* gcc-interface/utils.c (attr_cold_hot_exclusions): New constant.\n+\t(gnat_internal_attribute_table): Add entry for no_icf, noipa, flatten,\n+\tused, cold, hot, target and target_clones.\n+\t(begin_subprog_body): Do not create the RTL for the subprogram here.\n+\t(handle_noicf_attribute): New static function.\n+\t(handle_noipa_attribute): Likewise.\n+\t(handle_flatten_attribute): Likewise.\n+\t(handle_used_attribute): Likewise.\n+\t(handle_cold_attribute): Likewise.\n+\t(handle_hot_attribute): Likewise.\n+\t(handle_target_attribute): Likewise.\n+\t(handle_target_clones_attribute): Likewise.\n+\n 2019-05-28  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (lvalue_required_for_attribute_p): Return 0"}, {"sha": "955a1376cab2175f819d6627b6fcd73bb0e754f2", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_pragmas.rst", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ca5ef68709f317927a055a610bfcec6e4ec0172/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ca5ef68709f317927a055a610bfcec6e4ec0172/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst?ref=5ca5ef68709f317927a055a610bfcec6e4ec0172", "patch": "@@ -3766,18 +3766,19 @@ Syntax:\n   pragma Machine_Attribute (\n        [Entity         =>] LOCAL_NAME,\n        [Attribute_Name =>] static_string_EXPRESSION\n-    [, [Info           =>] static_EXPRESSION] );\n+    [, [Info           =>] static_EXPRESSION {, static_EXPRESSION}] );\n \n \n Machine-dependent attributes can be specified for types and/or\n declarations.  This pragma is semantically equivalent to\n :samp:`__attribute__(({attribute_name}))` (if ``info`` is not\n specified) or :samp:`__attribute__(({attribute_name(info})))`\n-in GNU C, where *attribute_name* is recognized by the\n-compiler middle-end or the ``TARGET_ATTRIBUTE_TABLE`` machine\n-specific macro.  A string literal for the optional parameter ``info``\n-is transformed into an identifier, which may make this pragma unusable\n-for some attributes.\n+or :samp:`__attribute__(({attribute_name(info,...})))` in GNU C,\n+where *attribute_name* is recognized by the compiler middle-end\n+or the ``TARGET_ATTRIBUTE_TABLE`` machine specific macro.  Note\n+that a string literal for the optional parameter ``info`` or the\n+following ones is transformed by default into an identifier,\n+which may make this pragma unusable for some attributes.\n For further information see :title:`GNU Compiler Collection (GCC) Internals`.\n \n Pragma Main"}, {"sha": "4dfd76bfbcf9b5931e31372fcd55fff331a90d06", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 39, "deletions": 46, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ca5ef68709f317927a055a610bfcec6e4ec0172/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ca5ef68709f317927a055a610bfcec6e4ec0172/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=5ca5ef68709f317927a055a610bfcec6e4ec0172", "patch": "@@ -6458,25 +6458,18 @@ prepend_one_attribute (struct attrib **attr_list,\n static void\n prepend_one_attribute_pragma (struct attrib **attr_list, Node_Id gnat_pragma)\n {\n-  const Node_Id gnat_arg = Pragma_Argument_Associations (gnat_pragma);\n-  tree gnu_arg0 = NULL_TREE, gnu_arg1 = NULL_TREE;\n+  const Node_Id gnat_arg = First (Pragma_Argument_Associations (gnat_pragma));\n+  Node_Id gnat_next_arg = Next (gnat_arg);\n+  tree gnu_arg1 = NULL_TREE, gnu_arg_list = NULL_TREE;\n   enum attrib_type etype;\n \n   /* Map the pragma at hand.  Skip if this isn't one we know how to handle.  */\n   switch (Get_Pragma_Id (Chars (Pragma_Identifier (gnat_pragma))))\n     {\n-    case Pragma_Machine_Attribute:\n-      etype = ATTR_MACHINE_ATTRIBUTE;\n-      break;\n-\n     case Pragma_Linker_Alias:\n       etype = ATTR_LINK_ALIAS;\n       break;\n \n-    case Pragma_Linker_Section:\n-      etype = ATTR_LINK_SECTION;\n-      break;\n-\n     case Pragma_Linker_Constructor:\n       etype = ATTR_LINK_CONSTRUCTOR;\n       break;\n@@ -6485,58 +6478,58 @@ prepend_one_attribute_pragma (struct attrib **attr_list, Node_Id gnat_pragma)\n       etype = ATTR_LINK_DESTRUCTOR;\n       break;\n \n-    case Pragma_Weak_External:\n-      etype = ATTR_WEAK_EXTERNAL;\n+    case Pragma_Linker_Section:\n+      etype = ATTR_LINK_SECTION;\n+      break;\n+\n+    case Pragma_Machine_Attribute:\n+      etype = ATTR_MACHINE_ATTRIBUTE;\n       break;\n \n     case Pragma_Thread_Local_Storage:\n       etype = ATTR_THREAD_LOCAL_STORAGE;\n       break;\n \n+    case Pragma_Weak_External:\n+      etype = ATTR_WEAK_EXTERNAL;\n+      break;\n+\n     default:\n       return;\n     }\n \n   /* See what arguments we have and turn them into GCC trees for attribute\n-     handlers.  These expect identifier for strings.  We handle at most two\n-     arguments and static expressions only.  */\n-  if (Present (gnat_arg) && Present (First (gnat_arg)))\n+     handlers.  The first one is always expected to be a string meant to be\n+     turned into an identifier.  The next ones are all static expressions,\n+     among which strings meant to be turned into an identifier, except for\n+     a couple of specific attributes that require raw strings.  */\n+  if (Present (gnat_next_arg))\n     {\n-      Node_Id gnat_arg0 = Next (First (gnat_arg));\n-      Node_Id gnat_arg1 = Empty;\n-\n-      if (Present (gnat_arg0)\n-\t  && Is_OK_Static_Expression (Expression (gnat_arg0)))\n-\t{\n-\t  gnu_arg0 = gnat_to_gnu (Expression (gnat_arg0));\n-\n-\t  if (TREE_CODE (gnu_arg0) == STRING_CST)\n-\t    {\n-\t      gnu_arg0 = get_identifier (TREE_STRING_POINTER (gnu_arg0));\n-\t      if (IDENTIFIER_LENGTH (gnu_arg0) == 0)\n-\t\treturn;\n-\t    }\n-\n-\t  gnat_arg1 = Next (gnat_arg0);\n-\t}\n-\n-      if (Present (gnat_arg1)\n-\t  && Is_OK_Static_Expression (Expression (gnat_arg1)))\n+      gnu_arg1 = gnat_to_gnu (Expression (gnat_next_arg));\n+      gcc_assert (TREE_CODE (gnu_arg1) == STRING_CST);\n+\n+      const char *const p = TREE_STRING_POINTER (gnu_arg1);\n+      const bool string_args\n+\t= strcmp (p, \"target\") == 0 || strcmp (p, \"target_clones\") == 0;\n+      gnu_arg1 = get_identifier (p);\n+      if (IDENTIFIER_LENGTH (gnu_arg1) == 0)\n+\treturn;\n+      gnat_next_arg = Next (gnat_next_arg);\n+\n+      while (Present (gnat_next_arg))\n \t{\n-\t  gnu_arg1 = gnat_to_gnu (Expression (gnat_arg1));\n-\n-\t  if (TREE_CODE (gnu_arg1) == STRING_CST)\n-\t   gnu_arg1 = get_identifier (TREE_STRING_POINTER (gnu_arg1));\n+\t  tree gnu_arg = gnat_to_gnu (Expression (gnat_next_arg));\n+\t  if (TREE_CODE (gnu_arg) == STRING_CST && !string_args)\n+\t    gnu_arg = get_identifier (TREE_STRING_POINTER (gnu_arg));\n+\t  gnu_arg_list\n+\t    = chainon (gnu_arg_list, build_tree_list (NULL_TREE, gnu_arg));\n+\t  gnat_next_arg = Next (gnat_next_arg);\n \t}\n     }\n \n-  /* Prepend to the list.  Make a list of the argument we might have, as GCC\n-     expects it.  */\n-  prepend_one_attribute (attr_list, etype, gnu_arg0,\n-\t\t\t gnu_arg1\n-\t\t\t ? build_tree_list (NULL_TREE, gnu_arg1) : NULL_TREE,\n-\t\t\t Present (Next (First (gnat_arg)))\n-\t\t\t ? Expression (Next (First (gnat_arg))) : gnat_pragma);\n+  prepend_one_attribute (attr_list, etype, gnu_arg1, gnu_arg_list,\n+\t\t\t Present (Next (gnat_arg))\n+\t\t\t ? Expression (Next (gnat_arg)) : gnat_pragma);\n }\n \n /* Prepend to ATTR_LIST the list of attributes for GNAT_ENTITY, if any.  */"}, {"sha": "a74a2e2dceba2fd508ecd0dc6ff0e5e42e448cc6", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 235, "deletions": 11, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ca5ef68709f317927a055a610bfcec6e4ec0172/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ca5ef68709f317927a055a610bfcec6e4ec0172/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=5ca5ef68709f317927a055a610bfcec6e4ec0172", "patch": "@@ -93,13 +93,28 @@ static tree handle_noreturn_attribute (tree *, tree, tree, int, bool *);\n static tree handle_stack_protect_attribute (tree *, tree, tree, int, bool *);\n static tree handle_noinline_attribute (tree *, tree, tree, int, bool *);\n static tree handle_noclone_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_noicf_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_noipa_attribute (tree *, tree, tree, int, bool *);\n static tree handle_leaf_attribute (tree *, tree, tree, int, bool *);\n static tree handle_always_inline_attribute (tree *, tree, tree, int, bool *);\n static tree handle_malloc_attribute (tree *, tree, tree, int, bool *);\n static tree handle_type_generic_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_flatten_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_used_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_cold_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_hot_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_target_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_target_clones_attribute (tree *, tree, tree, int, bool *);\n static tree handle_vector_size_attribute (tree *, tree, tree, int, bool *);\n static tree handle_vector_type_attribute (tree *, tree, tree, int, bool *);\n \n+static const struct attribute_spec::exclusions attr_cold_hot_exclusions[] =\n+{\n+  { \"cold\", true,  true,  true  },\n+  { \"hot\" , true,  true,  true  },\n+  { NULL  , false, false, false }\n+};\n+\n /* Fake handler for attributes we don't properly support, typically because\n    they'd require dragging a lot of the common-c front-end circuitry.  */\n static tree fake_attribute_handler (tree *, tree, tree, int, bool *);\n@@ -130,30 +145,49 @@ const struct attribute_spec gnat_internal_attribute_table[] =\n     handle_noinline_attribute, NULL },\n   { \"noclone\",      0, 0,  true,  false, false, false,\n     handle_noclone_attribute, NULL },\n+  { \"no_icf\",       0, 0,  true,  false, false, false,\n+    handle_noicf_attribute, NULL },\n+  { \"noipa\",        0, 0,  true,  false, false, false,\n+    handle_noipa_attribute, NULL },\n   { \"leaf\",         0, 0,  true,  false, false, false,\n     handle_leaf_attribute, NULL },\n   { \"always_inline\",0, 0,  true,  false, false, false,\n     handle_always_inline_attribute, NULL },\n   { \"malloc\",       0, 0,  true,  false, false, false,\n     handle_malloc_attribute, NULL },\n-  { \"type generic\", 0, 0,  false, true, true, false,\n+  { \"type generic\", 0, 0,  false, true,  true,  false,\n     handle_type_generic_attribute, NULL },\n \n-  { \"vector_size\",  1, 1,  false, true, false,  false,\n+  { \"flatten\",      0, 0,  true,  false, false, false,\n+    handle_flatten_attribute, NULL },\n+  { \"used\",         0, 0,  true,  false, false, false,\n+    handle_used_attribute, NULL },\n+  { \"cold\",         0, 0,  true,  false, false, false,\n+    handle_cold_attribute, attr_cold_hot_exclusions },\n+  { \"hot\",          0, 0,  true,  false, false, false,\n+    handle_hot_attribute, attr_cold_hot_exclusions },\n+  { \"target\",       1, -1, true,  false, false, false,\n+    handle_target_attribute, NULL },\n+  { \"target_clones\",1, -1, true,  false, false, false,\n+    handle_target_clones_attribute, NULL },\n+\n+  { \"vector_size\",  1, 1,  false, true,  false, false,\n     handle_vector_size_attribute, NULL },\n-  { \"vector_type\",  0, 0,  false, true, false,  false,\n+  { \"vector_type\",  0, 0,  false, true,  false, false,\n     handle_vector_type_attribute, NULL },\n-  { \"may_alias\",    0, 0, false, true, false, false, NULL, NULL },\n+  { \"may_alias\",    0, 0,  false, true,  false, false,\n+    NULL, NULL },\n \n   /* ??? format and format_arg are heavy and not supported, which actually\n      prevents support for stdio builtins, which we however declare as part\n      of the common builtins.def contents.  */\n-  { \"format\",     3, 3,  false, true,  true,  false, fake_attribute_handler,\n-    NULL },\n-  { \"format_arg\", 1, 1,  false, true,  true,  false, fake_attribute_handler,\n-    NULL },\n+  { \"format\",       3, 3,  false, true,  true,  false,\n+    fake_attribute_handler, NULL },\n+  { \"format_arg\",   1, 1,  false, true,  true,  false,\n+    fake_attribute_handler, NULL },\n \n-  { NULL,         0, 0, false, false, false, false, NULL, NULL }\n+  { NULL,           0, 0,  false, false, false, false,\n+    NULL, NULL }\n };\n \n /* Associates a GNAT tree node to a GCC tree node. It is used in\n@@ -3397,8 +3431,6 @@ begin_subprog_body (tree subprog_decl)\n   for (param_decl = DECL_ARGUMENTS (subprog_decl); param_decl;\n        param_decl = DECL_CHAIN (param_decl))\n     DECL_CONTEXT (param_decl) = subprog_decl;\n-\n-  make_decl_rtl (subprog_decl);\n }\n \n /* Finish translating the current subprogram and set its BODY.  */\n@@ -6393,6 +6425,38 @@ handle_noclone_attribute (tree *node, tree name,\n   return NULL_TREE;\n }\n \n+/* Handle a \"no_icf\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_noicf_attribute (tree *node, tree name,\n+\t\t\ttree ARG_UNUSED (args),\n+\t\t\tint ARG_UNUSED (flags), bool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"noipa\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_noipa_attribute (tree *node, tree name, tree, int, bool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Handle a \"leaf\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n \n@@ -6483,6 +6547,166 @@ handle_type_generic_attribute (tree *node, tree ARG_UNUSED (name),\n   return NULL_TREE;\n }\n \n+/* Handle a \"flatten\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_flatten_attribute (tree *node, tree name,\n+\t\t\t  tree args ATTRIBUTE_UNUSED,\n+\t\t\t  int flags ATTRIBUTE_UNUSED, bool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n+    /* Do nothing else, just set the attribute.  We'll get at\n+       it later with lookup_attribute.  */\n+    ;\n+  else\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"used\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_used_attribute (tree *pnode, tree name, tree ARG_UNUSED (args),\n+\t\t       int ARG_UNUSED (flags), bool *no_add_attrs)\n+{\n+  tree node = *pnode;\n+\n+  if (TREE_CODE (node) == FUNCTION_DECL\n+      || (VAR_P (node) && TREE_STATIC (node))\n+      || (TREE_CODE (node) == TYPE_DECL))\n+    {\n+      TREE_USED (node) = 1;\n+      DECL_PRESERVE_P (node) = 1;\n+      if (VAR_P (node))\n+\tDECL_READ_P (node) = 1;\n+    }\n+  else\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"cold\" and attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_cold_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n+\t\t       int ARG_UNUSED (flags), bool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) == FUNCTION_DECL\n+      || TREE_CODE (*node) == LABEL_DECL)\n+    {\n+      /* Attribute cold processing is done later with lookup_attribute.  */\n+    }\n+  else\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"hot\" and attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_hot_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n+\t\t      int ARG_UNUSED (flags), bool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) == FUNCTION_DECL\n+      || TREE_CODE (*node) == LABEL_DECL)\n+    {\n+      /* Attribute hot processing is done later with lookup_attribute.  */\n+    }\n+  else\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"target\" attribute.  */\n+\n+static tree\n+handle_target_attribute (tree *node, tree name, tree args, int flags,\n+\t\t\t bool *no_add_attrs)\n+{\n+  /* Ensure we have a function type.  */\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      *no_add_attrs = true;\n+    }\n+  else if (lookup_attribute (\"target_clones\", DECL_ATTRIBUTES (*node)))\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored due to conflict \"\n+\t\t   \"with %qs attribute\", name, \"target_clones\");\n+      *no_add_attrs = true;\n+    }\n+  else if (!targetm.target_option.valid_attribute_p (*node, name, args, flags))\n+    *no_add_attrs = true;\n+\n+  /* Check that there's no empty string in values of the attribute.  */\n+  for (tree t = args; t != NULL_TREE; t = TREE_CHAIN (t))\n+    {\n+      tree value = TREE_VALUE (t);\n+      if (TREE_CODE (value) == STRING_CST\n+\t  && TREE_STRING_LENGTH (value) == 1\n+\t  && TREE_STRING_POINTER (value)[0] == '\\0')\n+\t{\n+\t  warning (OPT_Wattributes, \"empty string in attribute %<target%>\");\n+\t  *no_add_attrs = true;\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"target_clones\" attribute.  */\n+\n+static tree\n+handle_target_clones_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n+\t\t\t  int ARG_UNUSED (flags), bool *no_add_attrs)\n+{\n+  /* Ensure we have a function type.  */\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n+    {\n+      if (lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (*node)))\n+\t{\n+\t  warning (OPT_Wattributes, \"%qE attribute ignored due to conflict \"\n+\t\t   \"with %qs attribute\", name, \"always_inline\");\n+\t  *no_add_attrs = true;\n+\t}\n+      else if (lookup_attribute (\"target\", DECL_ATTRIBUTES (*node)))\n+\t{\n+\t  warning (OPT_Wattributes, \"%qE attribute ignored due to conflict \"\n+\t\t   \"with %qs attribute\", name, \"target\");\n+\t  *no_add_attrs = true;\n+\t}\n+      else\n+\t/* Do not inline functions with multiple clone targets.  */\n+\tDECL_UNINLINABLE (*node) = 1;\n+    }\n+  else\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      *no_add_attrs = true;\n+    }\n+  return NULL_TREE;\n+}\n+\n /* Handle a \"vector_size\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n "}, {"sha": "200e5dbf84719a38d0add697d869cc919ca84bf2", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ca5ef68709f317927a055a610bfcec6e4ec0172/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ca5ef68709f317927a055a610bfcec6e4ec0172/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=5ca5ef68709f317927a055a610bfcec6e4ec0172", "patch": "@@ -19349,20 +19349,25 @@ package body Sem_Prag is\n          -----------------------\n \n          --  pragma Machine_Attribute (\n-         --       [Entity         =>] LOCAL_NAME,\n-         --       [Attribute_Name =>] static_string_EXPRESSION\n-         --    [, [Info           =>] static_EXPRESSION] );\n+         --     [Entity         =>] LOCAL_NAME,\n+         --     [Attribute_Name =>] static_string_EXPRESSION\n+         --  [, [Info           =>] static_EXPRESSION {, static_EXPRESSION}] );\n \n          when Pragma_Machine_Attribute => Machine_Attribute : declare\n+            Arg : Node_Id;\n             Def_Id : Entity_Id;\n \n          begin\n             GNAT_Pragma;\n             Check_Arg_Order ((Name_Entity, Name_Attribute_Name, Name_Info));\n \n-            if Arg_Count = 3 then\n+            if Arg_Count >= 3 then\n                Check_Optional_Identifier (Arg3, Name_Info);\n-               Check_Arg_Is_OK_Static_Expression (Arg3);\n+               Arg := Arg3;\n+               while Present (Arg) loop\n+                  Check_Arg_Is_OK_Static_Expression (Arg);\n+                  Arg := Next (Arg);\n+               end loop;\n             else\n                Check_Arg_Count (2);\n             end if;"}, {"sha": "caeb40691f33386b67e5fe12bcbf6f252b2581f2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ca5ef68709f317927a055a610bfcec6e4ec0172/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ca5ef68709f317927a055a610bfcec6e4ec0172/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5ca5ef68709f317927a055a610bfcec6e4ec0172", "patch": "@@ -1,3 +1,7 @@\n+2019-05-28  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/machine_attr1.ad[sb]: New test.\n+\n 2019-05-28  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/opt79.ad[sb]: New test."}, {"sha": "f4e4ff7ddd566167094d2f4e5232bf2088e10011", "filename": "gcc/testsuite/gnat.dg/machine_attr1.adb", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ca5ef68709f317927a055a610bfcec6e4ec0172/gcc%2Ftestsuite%2Fgnat.dg%2Fmachine_attr1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ca5ef68709f317927a055a610bfcec6e4ec0172/gcc%2Ftestsuite%2Fgnat.dg%2Fmachine_attr1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fmachine_attr1.adb?ref=5ca5ef68709f317927a055a610bfcec6e4ec0172", "patch": "@@ -0,0 +1,41 @@\n+-- { dg-do compile { target i?86-*-linux* x86_64-*-linux* } }\n+-- { dg-options \"-O3 -gnatp\" }\n+\n+package body Machine_Attr1 is\n+\n+  procedure Proc1 is\n+  begin\n+    Proc3;\n+    Proc4;\n+  end;\n+\n+  procedure Proc2 is\n+  begin\n+    Proc1;\n+  end;\n+\n+  procedure Proc3 is\n+  begin\n+    A (1) := 0;\n+  end;\n+\n+  procedure Proc4 is\n+  begin\n+    A (2) := 0;\n+  end;\n+\n+  procedure Proc5 is\n+  begin\n+    for I in A'Range loop\n+      A(I) := B(I) + C(I);\n+    end loop;\n+  end;\n+\n+  procedure Proc6 is\n+  begin\n+    for I in A'Range loop\n+      A(I) := B(I) + C(I);\n+    end loop;\n+  end;\n+\n+end Machine_Attr1;"}, {"sha": "d1f2aecaa01a94aff0187a377c979fa6dcd46e7f", "filename": "gcc/testsuite/gnat.dg/machine_attr1.ads", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ca5ef68709f317927a055a610bfcec6e4ec0172/gcc%2Ftestsuite%2Fgnat.dg%2Fmachine_attr1.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ca5ef68709f317927a055a610bfcec6e4ec0172/gcc%2Ftestsuite%2Fgnat.dg%2Fmachine_attr1.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fmachine_attr1.ads?ref=5ca5ef68709f317927a055a610bfcec6e4ec0172", "patch": "@@ -0,0 +1,25 @@\n+package Machine_Attr1 is\n+\n+  type Arr is array (1 .. 256) of Integer;\n+\n+  A, B, C : Arr;\n+\n+  procedure Proc1;\n+  pragma Machine_Attribute (Proc1, \"flatten\");\n+\n+  procedure Proc2;\n+  pragma Machine_Attribute (Proc2, \"used\");\n+\n+  procedure Proc3;\n+  pragma Machine_Attribute (Proc3, \"cold\");\n+\n+  procedure Proc4;\n+  pragma Machine_Attribute (Proc4, \"hot\");\n+\n+  procedure Proc5;\n+  pragma Machine_Attribute (Proc5, \"target\", \"avx\");\n+\n+  procedure Proc6;\n+  pragma Machine_Attribute (Proc6, \"target_clones\", \"avx\", \"avx2\", \"default\");\n+\n+end Machine_Attr1;"}]}