{"sha": "8f992d640ed577dd5a8427d8c7855d7a51287e7f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGY5OTJkNjQwZWQ1NzdkZDVhODQyN2Q4Yzc4NTVkN2E1MTI4N2U3Zg==", "commit": {"author": {"name": "Daniel Carrera", "email": "dcarrera@gmail.com", "date": "2011-07-21T23:18:24Z"}, "committer": {"name": "Daniel Carrera", "email": "dcarrera@gcc.gnu.org", "date": "2011-07-21T23:18:24Z"}, "message": "trans.c (gfc_allocate_with_status): Split into two functions gfc_allocate_using_malloc and gfc_allocate_usig_lib.\n\n2011-07-21  Daniel Carrera  <dcarrera@gmail.com>\n\n\t* trans.c (gfc_allocate_with_status): Split into two functions\n\tgfc_allocate_using_malloc and gfc_allocate_usig_lib.\n\t(gfc_allocate_using_malloc): The status parameter is now the\n\tactual status rather than a pointer. Code cleanup.\n\t(gfc_allocate_using_lib): Ditto. Add new parametrs errmsg and\n\terrlen. Pass these to the coarray lib.\n\t* trans-openmp.c (gfc_omp_clause_default_ctor): Update calls to\n\tgfc_allocate_allocatable.\n\t(gfc_omp_clause_copy_ctor): Ditto.\n\t(gfc_trans_omp_array_reduction): Ditto.\n\t* trans-stmt.c (gfc_trans_allocate): Ditto. Update call to\n\tgfc_allocate_using_malloc. Pass stat rather than pstat to the allocate\n\tfuctions. If using coarray lib, pass errmsg and errlen to the allocate\n\tfunctions. Move error checking outside the if (!gfc_array_allocate)\n\tblock so that it also affects trees produced by gfc_array_allocate.\n\t* trans-array.c (gfc_array_allocate): Add new parameters errmsg\n\tand errlen. Replace parameter pstat by status. Code cleanup. Update\n\tcalls to gfc_allocate_allocatable and gfc_allocate_using_malloc.\n\t* trans-array.h (gfc_array_allocate): Update signature of\n\tgfc_array_allocate.\n\nFrom-SVN: r176606", "tree": {"sha": "feafa74c7b83c19f1ce8231bff3d26718744b8c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/feafa74c7b83c19f1ce8231bff3d26718744b8c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f992d640ed577dd5a8427d8c7855d7a51287e7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f992d640ed577dd5a8427d8c7855d7a51287e7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f992d640ed577dd5a8427d8c7855d7a51287e7f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f992d640ed577dd5a8427d8c7855d7a51287e7f/comments", "author": {"login": "dcarrera", "id": 89128, "node_id": "MDQ6VXNlcjg5MTI4", "avatar_url": "https://avatars.githubusercontent.com/u/89128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dcarrera", "html_url": "https://github.com/dcarrera", "followers_url": "https://api.github.com/users/dcarrera/followers", "following_url": "https://api.github.com/users/dcarrera/following{/other_user}", "gists_url": "https://api.github.com/users/dcarrera/gists{/gist_id}", "starred_url": "https://api.github.com/users/dcarrera/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dcarrera/subscriptions", "organizations_url": "https://api.github.com/users/dcarrera/orgs", "repos_url": "https://api.github.com/users/dcarrera/repos", "events_url": "https://api.github.com/users/dcarrera/events{/privacy}", "received_events_url": "https://api.github.com/users/dcarrera/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ef74e2ba382eecfea8d7ef44d54add99c3fd4d92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef74e2ba382eecfea8d7ef44d54add99c3fd4d92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef74e2ba382eecfea8d7ef44d54add99c3fd4d92"}], "stats": {"total": 375, "additions": 224, "deletions": 151}, "files": [{"sha": "dd4cd8dd15a54f6b879047b5bd29ce69c210adaa", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f992d640ed577dd5a8427d8c7855d7a51287e7f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f992d640ed577dd5a8427d8c7855d7a51287e7f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8f992d640ed577dd5a8427d8c7855d7a51287e7f", "patch": "@@ -1,3 +1,26 @@\n+2011-07-21  Daniel Carrera  <dcarrera@gmail.com>\n+\n+\t* trans.c (gfc_allocate_with_status): Split into two functions\n+\tgfc_allocate_using_malloc and gfc_allocate_usig_lib.\n+\t(gfc_allocate_using_malloc): The status parameter is now the\n+\tactual status rather than a pointer. Code cleanup.\n+\t(gfc_allocate_using_lib): Ditto. Add new parametrs errmsg and\n+\terrlen. Pass these to the coarray lib.\n+\t* trans-openmp.c (gfc_omp_clause_default_ctor): Update calls to\n+\tgfc_allocate_allocatable.\n+\t(gfc_omp_clause_copy_ctor): Ditto.\n+\t(gfc_trans_omp_array_reduction): Ditto.\n+\t* trans-stmt.c (gfc_trans_allocate): Ditto. Update call to\n+\tgfc_allocate_using_malloc. Pass stat rather than pstat to the allocate\n+\tfuctions. If using coarray lib, pass errmsg and errlen to the allocate\n+\tfunctions. Move error checking outside the if (!gfc_array_allocate)\n+\tblock so that it also affects trees produced by gfc_array_allocate.\n+\t* trans-array.c (gfc_array_allocate): Add new parameters errmsg\n+\tand errlen. Replace parameter pstat by status. Code cleanup. Update\n+\tcalls to gfc_allocate_allocatable and gfc_allocate_using_malloc.\n+\t* trans-array.h (gfc_array_allocate): Update signature of\n+\tgfc_array_allocate.\n+\n 2011-07-21  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \t* gfortran.texi: Remove a duplicate word."}, {"sha": "b959b36374c79f8d50619349c6986a71109ac574", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f992d640ed577dd5a8427d8c7855d7a51287e7f/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f992d640ed577dd5a8427d8c7855d7a51287e7f/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=8f992d640ed577dd5a8427d8c7855d7a51287e7f", "patch": "@@ -4383,7 +4383,8 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n /*GCC ARRAYS*/\n \n bool\n-gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree pstat)\n+gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n+\t\t    tree errlen)\n {\n   tree tmp;\n   tree pointer;\n@@ -4478,22 +4479,15 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree pstat)\n \t\t\t\t   1, msg);\n     }\n \n-  if (pstat != NULL_TREE && !integer_zerop (pstat))\n+  if (status != NULL_TREE)\n     {\n-      /* Set the status variable if it's present.  */\n+      tree status_type = TREE_TYPE (status);\n       stmtblock_t set_status_block;\n-      tree status_type = pstat ? TREE_TYPE (TREE_TYPE (pstat)) : NULL_TREE;\n \n       gfc_start_block (&set_status_block);\n-      gfc_add_modify (&set_status_block,\n-  \t\t      fold_build1_loc (input_location, INDIRECT_REF,\n-  \t\t\t\t       status_type, pstat),\n-  \t\t\t   build_int_cst (status_type, LIBERROR_ALLOCATION));\n-\n-      tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n-  \t\t\t     pstat, build_int_cst (TREE_TYPE (pstat), 0));\n-      error = fold_build3_loc (input_location, COND_EXPR, void_type_node, tmp,\n-  \t\t\t       error, gfc_finish_block (&set_status_block));\n+      gfc_add_modify (&set_status_block, status,\n+\t\t      build_int_cst (status_type, LIBERROR_ALLOCATION));\n+      error = gfc_finish_block (&set_status_block);\n     }\n \n   gfc_start_block (&elseblock);\n@@ -4502,14 +4496,15 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree pstat)\n   pointer = gfc_conv_descriptor_data_get (se->expr);\n   STRIP_NOPS (pointer);\n \n-  /* The allocate_array variants take the old pointer as first argument.  */\n+  /* The allocatable variant takes the old pointer as first argument.  */\n   if (allocatable)\n-    tmp = gfc_allocate_allocatable_with_status (&elseblock,\n-\t\t\t\t\t\tpointer, size, pstat, expr);\n+    tmp = gfc_allocate_allocatable (&elseblock, pointer, size,\n+\t\t\t\t    status, errmsg, errlen, expr);\n   else\n-    tmp = gfc_allocate_with_status (&elseblock, size, pstat, false);\n-  tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node, pointer,\n-\t\t\t tmp);\n+    tmp = gfc_allocate_using_malloc (&elseblock, size, status);\n+\n+  tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node,\n+\t\t\t pointer, tmp);\n \n   gfc_add_expr_to_block (&elseblock, tmp);\n "}, {"sha": "75704ad7454b4335b69d7b5c70828472e2ec25a9", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f992d640ed577dd5a8427d8c7855d7a51287e7f/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f992d640ed577dd5a8427d8c7855d7a51287e7f/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=8f992d640ed577dd5a8427d8c7855d7a51287e7f", "patch": "@@ -24,7 +24,7 @@ tree gfc_array_deallocate (tree, tree, gfc_expr*);\n \n /* Generate code to initialize an allocate an array.  Statements are added to\n    se, which should contain an expression for the array descriptor.  */\n-bool gfc_array_allocate (gfc_se *, gfc_expr *, tree);\n+bool gfc_array_allocate (gfc_se *, gfc_expr *, tree, tree, tree);\n \n /* Allow the bounds of a loop to be set from a callee's array spec.  */\n void gfc_set_loop_bounds_from_array_spec (gfc_interface_mapping *,"}, {"sha": "cd5ef0a4d05c5c6ba67839ef3ad6f5a98ed6f9ec", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f992d640ed577dd5a8427d8c7855d7a51287e7f/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f992d640ed577dd5a8427d8c7855d7a51287e7f/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=8f992d640ed577dd5a8427d8c7855d7a51287e7f", "patch": "@@ -188,9 +188,9 @@ gfc_omp_clause_default_ctor (tree clause, tree decl, tree outer)\n   size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n \t\t\t  size, esize);\n   size = gfc_evaluate_now (fold_convert (size_type_node, size), &cond_block);\n-  ptr = gfc_allocate_allocatable_with_status (&cond_block,\n-\t\t\t\t\t      build_int_cst (pvoid_type_node, 0),\n-\t\t\t\t\t      size, NULL, NULL);\n+  ptr = gfc_allocate_allocatable (&cond_block,\n+\t\t\t  build_int_cst (pvoid_type_node, 0),\n+\t\t\t  size, NULL_TREE, NULL_TREE, NULL_TREE, NULL);\n   gfc_conv_descriptor_data_set (&cond_block, decl, ptr);\n   then_b = gfc_finish_block (&cond_block);\n \n@@ -241,9 +241,9 @@ gfc_omp_clause_copy_ctor (tree clause, tree dest, tree src)\n   size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n \t\t\t  size, esize);\n   size = gfc_evaluate_now (fold_convert (size_type_node, size), &block);\n-  ptr = gfc_allocate_allocatable_with_status (&block,\n-\t\t\t\t\t      build_int_cst (pvoid_type_node, 0),\n-\t\t\t\t\t      size, NULL, NULL);\n+  ptr = gfc_allocate_allocatable (&block,\n+\t\t\t  build_int_cst (pvoid_type_node, 0),\n+\t\t\t  size, NULL_TREE, NULL_TREE, NULL_TREE, NULL);\n   gfc_conv_descriptor_data_set (&block, dest, ptr);\n   call = build_call_expr_loc (input_location,\n \t\t\t  built_in_decls[BUILT_IN_MEMCPY], 3, ptr,\n@@ -663,9 +663,9 @@ gfc_trans_omp_array_reduction (tree c, gfc_symbol *sym, locus where)\n       size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n \t\t\t      size, esize);\n       size = gfc_evaluate_now (fold_convert (size_type_node, size), &block);\n-      ptr = gfc_allocate_allocatable_with_status (&block,\n-\t\t\t\t\t\t  build_int_cst (pvoid_type_node, 0),\n-\t\t\t\t\t\t  size, NULL, NULL);\n+      ptr = gfc_allocate_allocatable (&block,\n+\t\t\t      build_int_cst (pvoid_type_node, 0),\n+\t\t\t      size, NULL_TREE, NULL_TREE, NULL_TREE, NULL);\n       gfc_conv_descriptor_data_set (&block, decl, ptr);\n       gfc_add_expr_to_block (&block, gfc_trans_assignment (e1, e2, false,\n \t\t\t     false));"}, {"sha": "75d72a285e0a3ad9050ae6086a30f1a3449d8f7a", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 71, "deletions": 33, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f992d640ed577dd5a8427d8c7855d7a51287e7f/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f992d640ed577dd5a8427d8c7855d7a51287e7f/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=8f992d640ed577dd5a8427d8c7855d7a51287e7f", "patch": "@@ -4686,8 +4686,10 @@ gfc_trans_allocate (gfc_code * code)\n   tree tmp;\n   tree parm;\n   tree stat;\n-  tree pstat;\n-  tree error_label;\n+  tree errmsg;\n+  tree errlen;\n+  tree label_errmsg;\n+  tree label_finish;\n   tree memsz;\n   tree expr3;\n   tree slen3;\n@@ -4699,21 +4701,39 @@ gfc_trans_allocate (gfc_code * code)\n   if (!code->ext.alloc.list)\n     return NULL_TREE;\n \n-  pstat = stat = error_label = tmp = memsz = NULL_TREE;\n+  stat = tmp = memsz = NULL_TREE;\n+  label_errmsg = label_finish = errmsg = errlen = NULL_TREE;\n \n   gfc_init_block (&block);\n   gfc_init_block (&post);\n \n-  /* Either STAT= and/or ERRMSG is present.  */\n-  if (code->expr1 || code->expr2)\n+  /* STAT= (and maybe ERRMSG=) is present.  */\n+  if (code->expr1)\n     {\n+      /* STAT=.  */\n       tree gfc_int4_type_node = gfc_get_int_type (4);\n-\n       stat = gfc_create_var (gfc_int4_type_node, \"stat\");\n-      pstat = gfc_build_addr_expr (NULL_TREE, stat);\n \n-      error_label = gfc_build_label_decl (NULL_TREE);\n-      TREE_USED (error_label) = 1;\n+      /* ERRMSG= only makes sense with STAT=.  */\n+      if (code->expr2)\n+\t{\n+\t  gfc_init_se (&se, NULL);\n+\t  gfc_conv_expr_lhs (&se, code->expr2);\n+\n+\t  errlen = gfc_get_expr_charlen (code->expr2);\n+\t  errmsg = gfc_build_addr_expr (pchar_type_node, se.expr);\n+\t}\n+      else\n+\t{\n+\t  errmsg = null_pointer_node;\n+\t  errlen = build_int_cst (gfc_charlen_type_node, 0);\n+\t}\n+\n+      /* GOTO destinations.  */\n+      label_errmsg = gfc_build_label_decl (NULL_TREE);\n+      label_finish = gfc_build_label_decl (NULL_TREE);\n+      TREE_USED (label_errmsg) = 1;\n+      TREE_USED (label_finish) = 1;\n     }\n \n   expr3 = NULL_TREE;\n@@ -4732,7 +4752,7 @@ gfc_trans_allocate (gfc_code * code)\n       se.descriptor_only = 1;\n       gfc_conv_expr (&se, expr);\n \n-      if (!gfc_array_allocate (&se, expr, pstat))\n+      if (!gfc_array_allocate (&se, expr, stat, errmsg, errlen))\n \t{\n \t  /* A scalar or derived type.  */\n \n@@ -4847,28 +4867,16 @@ gfc_trans_allocate (gfc_code * code)\n \n \t  /* Allocate - for non-pointers with re-alloc checking.  */\n \t  if (gfc_expr_attr (expr).allocatable)\n-\t    tmp = gfc_allocate_allocatable_with_status (&se.pre, se.expr, memsz,\n-\t\t\t\t\t\t\tpstat, expr);\n+\t    tmp = gfc_allocate_allocatable (&se.pre, se.expr, memsz,\n+\t\t\t\t\t    stat, errmsg, errlen, expr);\n \t  else\n-\t    tmp = gfc_allocate_with_status (&se.pre, memsz, pstat, false);\n+\t    tmp = gfc_allocate_using_malloc (&se.pre, memsz, stat);\n \n \t  tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node,\n \t\t\t\t se.expr,\n \t\t\t\t fold_convert (TREE_TYPE (se.expr), tmp));\n \t  gfc_add_expr_to_block (&se.pre, tmp);\n \n-\t  if (code->expr1 || code->expr2)\n-\t    {\n-\t      tmp = build1_v (GOTO_EXPR, error_label);\n-\t      parm = fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t      boolean_type_node, stat,\n-\t\t\t\t      build_int_cst (TREE_TYPE (stat), 0));\n-\t      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n-\t\t\t\t     parm, tmp,\n-\t\t\t\t     build_empty_stmt (input_location));\n-\t      gfc_add_expr_to_block (&se.pre, tmp);\n-\t    }\n-\n \t  if (expr->ts.type == BT_DERIVED && expr->ts.u.derived->attr.alloc_comp)\n \t    {\n \t      tmp = build_fold_indirect_ref_loc (input_location, se.expr);\n@@ -4879,6 +4887,25 @@ gfc_trans_allocate (gfc_code * code)\n \n       gfc_add_block_to_block (&block, &se.pre);\n \n+      /* Error checking -- Note: ERRMSG only makes sense with STAT.  */\n+      if (code->expr1)\n+\t{\n+\t  /* The coarray library already sets the errmsg.  */\n+\t  if (gfc_option.coarray == GFC_FCOARRAY_LIB\n+\t      && gfc_expr_attr (expr).codimension)\n+\t    tmp = build1_v (GOTO_EXPR, label_finish);\n+\t  else\n+\t    tmp = build1_v (GOTO_EXPR, label_errmsg);\n+\n+\t  parm = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t  boolean_type_node, stat,\n+\t\t\t\t  build_int_cst (TREE_TYPE (stat), 0));\n+\t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t\t parm, tmp,\n+\t\t\t\t     build_empty_stmt (input_location));\n+\t  gfc_add_expr_to_block (&block, tmp);\n+\t}\n+ \n       if (code->expr3 && !code->expr3->mold)\n \t{\n \t  /* Initialization via SOURCE block\n@@ -5005,24 +5032,19 @@ gfc_trans_allocate (gfc_code * code)\n \n     }\n \n-  /* STAT block.  */\n+  /* STAT  (ERRMSG only makes sense with STAT).  */\n   if (code->expr1)\n     {\n-      tmp = build1_v (LABEL_EXPR, error_label);\n+      tmp = build1_v (LABEL_EXPR, label_errmsg);\n       gfc_add_expr_to_block (&block, tmp);\n-\n-      gfc_init_se (&se, NULL);\n-      gfc_conv_expr_lhs (&se, code->expr1);\n-      tmp = convert (TREE_TYPE (se.expr), stat);\n-      gfc_add_modify (&block, se.expr, tmp);\n     }\n \n   /* ERRMSG block.  */\n   if (code->expr2)\n     {\n       /* A better error message may be possible, but not required.  */\n       const char *msg = \"Attempt to allocate an allocated object\";\n-      tree errmsg, slen, dlen;\n+      tree slen, dlen;\n \n       gfc_init_se (&se, NULL);\n       gfc_conv_expr_lhs (&se, code->expr2);\n@@ -5050,6 +5072,22 @@ gfc_trans_allocate (gfc_code * code)\n       gfc_add_expr_to_block (&block, tmp);\n     }\n \n+  /* STAT  (ERRMSG only makes sense with STAT).  */\n+  if (code->expr1)\n+    {\n+      tmp = build1_v (LABEL_EXPR, label_finish);\n+      gfc_add_expr_to_block (&block, tmp);\n+    }\n+\n+  /* STAT block.  */\n+  if (code->expr1)\n+    {\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr_lhs (&se, code->expr1);\n+      tmp = convert (TREE_TYPE (se.expr), stat);\n+      gfc_add_modify (&block, se.expr, tmp);\n+    }\n+\n   gfc_add_block_to_block (&block, &se.post);\n   gfc_add_block_to_block (&block, &post);\n "}, {"sha": "83fabe2fb2cf21863ab14de21df6be01419d2af3", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 102, "deletions": 86, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f992d640ed577dd5a8427d8c7855d7a51287e7f/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f992d640ed577dd5a8427d8c7855d7a51287e7f/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=8f992d640ed577dd5a8427d8c7855d7a51287e7f", "patch": "@@ -565,12 +565,12 @@ gfc_call_malloc (stmtblock_t * block, tree type, tree size)\n    This function follows the following pseudo-code:\n \n     void *\n-    allocate (size_t size, integer_type* stat)\n+    allocate (size_t size, integer_type stat)\n     {\n       void *newmem;\n     \n-      if (stat)\n-\t*stat = 0;\n+      if (stat requested)\n+\tstat = 0;\n \n       newmem = malloc (MAX (size, 1));\n       if (newmem == NULL)\n@@ -583,12 +583,11 @@ gfc_call_malloc (stmtblock_t * block, tree type, tree size)\n       return newmem;\n     }  */\n tree\n-gfc_allocate_with_status (stmtblock_t * block, tree size, tree status,\n-\t\t\t  bool coarray_lib)\n+gfc_allocate_using_malloc (stmtblock_t * block, tree size, tree status)\n {\n   stmtblock_t alloc_block;\n-  tree res, tmp, msg, cond;\n-  tree status_type = status ? TREE_TYPE (TREE_TYPE (status)) : NULL_TREE;\n+  tree res, tmp, on_error;\n+  tree status_type = status ? TREE_TYPE (status) : NULL_TREE;\n \n   /* Evaluate size only once, and make sure it has the right type.  */\n   size = gfc_evaluate_now (size, block);\n@@ -599,89 +598,107 @@ gfc_allocate_with_status (stmtblock_t * block, tree size, tree status,\n   res = gfc_create_var (prvoid_type_node, NULL);\n \n   /* Set the optional status variable to zero.  */\n-  if (status != NULL_TREE && !integer_zerop (status))\n-    {\n-      tmp = fold_build2_loc (input_location, MODIFY_EXPR, status_type,\n-\t\t\t     fold_build1_loc (input_location, INDIRECT_REF,\n-\t\t\t\t\t      status_type, status),\n-\t\t\t     build_int_cst (status_type, 0));\n-      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n-\t\t\t     fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t\t\tboolean_type_node, status,\n-\t\t\t\t\tbuild_int_cst (TREE_TYPE (status), 0)),\n-\t\t\t     tmp, build_empty_stmt (input_location));\n-      gfc_add_expr_to_block (block, tmp);\n-    }\n+  if (status != NULL_TREE)\n+      gfc_add_expr_to_block (block,\n+\t     fold_build2_loc (input_location, MODIFY_EXPR, status_type,\n+\t\t\t      status, build_int_cst (status_type, 0)));\n \n   /* The allocation itself.  */\n   gfc_start_block (&alloc_block);\n-  if (coarray_lib)\n-    {\n-      gfc_add_modify (&alloc_block, res,\n-\t      fold_convert (prvoid_type_node,\n-\t\t    build_call_expr_loc (input_location,\n-\t\t\t gfor_fndecl_caf_register, 6,\n-\t\t\t fold_build2_loc (input_location,\n-\t\t\t\t  MAX_EXPR, size_type_node, size,\n-\t\t\t\t  build_int_cst (size_type_node, 1)),\n-\t\t\t build_int_cst (integer_type_node,\n-\t\t\t\t\tGFC_CAF_COARRAY_ALLOC),\n-\t\t\t null_pointer_node,  /* token  */\n-\t\t\t null_pointer_node,  /* stat  */\n-\t\t\t null_pointer_node,  /* errmsg, errmsg_len  */\n-\t\t\t build_int_cst (integer_type_node, 0))));\n-    }\n+  gfc_add_modify (&alloc_block, res,\n+\t  fold_convert (prvoid_type_node,\n+\t\tbuild_call_expr_loc (input_location,\n+\t\t\t     built_in_decls[BUILT_IN_MALLOC], 1,\n+\t\t\t     fold_build2_loc (input_location,\n+\t\t\t\t      MAX_EXPR, size_type_node, size,\n+\t\t\t\t      build_int_cst (size_type_node, 1)))));\n+\n+  /* What to do in case of error.  */\n+  if (status != NULL_TREE)\n+    on_error = fold_build2_loc (input_location, MODIFY_EXPR, status_type,\n+\t\t\tstatus, build_int_cst (status_type, LIBERROR_ALLOCATION));\n   else\n-    {\n-      gfc_add_modify (&alloc_block, res,\n-\t      fold_convert (prvoid_type_node,\n-\t\t    build_call_expr_loc (input_location,\n-\t\t\t built_in_decls[BUILT_IN_MALLOC], 1,\n-\t\t\t fold_build2_loc (input_location,\n-\t\t\t\t  MAX_EXPR, size_type_node, size,\n-\t\t\t\t  build_int_cst (size_type_node, 1)))));\n-    }\n-\n-  msg = gfc_build_addr_expr (pchar_type_node, gfc_build_localized_cstring_const\n-\t\t\t     (\"Allocation would exceed memory limit\"));\n-  tmp = build_call_expr_loc (input_location,\n-\t\t\t gfor_fndecl_os_error, 1, msg);\n-\n-  if (status != NULL_TREE && !integer_zerop (status))\n-    {\n-      /* Set the status variable if it's present.  */\n-      tree tmp2;\n-\n-      cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n-\t\t\t      status, build_int_cst (TREE_TYPE (status), 0));\n-      tmp2 = fold_build2_loc (input_location, MODIFY_EXPR, status_type,\n-\t\t\t      fold_build1_loc (input_location, INDIRECT_REF,\n-\t\t\t\t\t       status_type, status),\n-\t\t\t      build_int_cst (status_type, LIBERROR_ALLOCATION));\n-      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond,\n-\t\t\t     tmp, tmp2);\n-    }\n+    on_error = build_call_expr_loc (input_location, gfor_fndecl_os_error, 1,\n+\t\t    gfc_build_addr_expr (pchar_type_node,\n+\t\t\t\t gfc_build_localized_cstring_const\n+\t\t\t\t (\"Allocation would exceed memory limit\")));\n \n   tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n \t\t\t fold_build2_loc (input_location, EQ_EXPR,\n \t\t\t\t\t  boolean_type_node, res,\n \t\t\t\t\t  build_int_cst (prvoid_type_node, 0)),\n-\t\t\t tmp, build_empty_stmt (input_location));\n+\t\t\t on_error, build_empty_stmt (input_location));\n+\n   gfc_add_expr_to_block (&alloc_block, tmp);\n   gfc_add_expr_to_block (block, gfc_finish_block (&alloc_block));\n \n   return res;\n }\n \n \n+/* Allocate memory, using an optional status argument.\n+ \n+   This function follows the following pseudo-code:\n+\n+    void *\n+    allocate (size_t size, integer_type stat)\n+    {\n+      void *newmem;\n+    \n+      newmem = _caf_register ( size, regtype, NULL, &stat, NULL, NULL);\n+      return newmem;\n+    }  */\n+tree\n+gfc_allocate_using_lib (stmtblock_t * block, tree size, tree status,\n+\t\t\ttree errmsg, tree errlen)\n+{\n+  tree res, pstat;\n+\n+  /* Evaluate size only once, and make sure it has the right type.  */\n+  size = gfc_evaluate_now (size, block);\n+  if (TREE_TYPE (size) != TREE_TYPE (size_type_node))\n+    size = fold_convert (size_type_node, size);\n+\n+  /* Create a variable to hold the result.  */\n+  res = gfc_create_var (prvoid_type_node, NULL);\n+\n+  /* The allocation itself.  */\n+  if (status == NULL_TREE)\n+    pstat  = null_pointer_node;\n+  else\n+    pstat  = gfc_build_addr_expr (NULL_TREE, status);\n+\n+  if (errmsg == NULL_TREE)\n+    {\n+      gcc_assert(errlen == NULL_TREE);\n+      errmsg = null_pointer_node;\n+      errlen = build_int_cst (integer_type_node, 0);\n+    }\n+\n+  gfc_add_modify (block, res,\n+\t  fold_convert (prvoid_type_node,\n+\t\tbuild_call_expr_loc (input_location,\n+\t\t     gfor_fndecl_caf_register, 6,\n+\t\t     fold_build2_loc (input_location,\n+\t\t\t      MAX_EXPR, size_type_node, size,\n+\t\t\t      build_int_cst (size_type_node, 1)),\n+\t\t     build_int_cst (integer_type_node,\n+\t\t\t    GFC_CAF_COARRAY_ALLOC),\n+\t\t     null_pointer_node,  /* token  */\n+\t\t     pstat, errmsg, errlen)));\n+\n+  return res;\n+}\n+\n+\n /* Generate code for an ALLOCATE statement when the argument is an\n    allocatable variable.  If the variable is currently allocated, it is an\n    error to allocate it again.\n  \n    This function follows the following pseudo-code:\n   \n     void *\n-    allocate_allocatable (void *mem, size_t size, integer_type *stat)\n+    allocate_allocatable (void *mem, size_t size, integer_type stat)\n     {\n       if (mem == NULL)\n \treturn allocate (size, stat);\n@@ -691,7 +708,7 @@ gfc_allocate_with_status (stmtblock_t * block, tree size, tree status,\n \t{\n \t  free (mem);\n \t  mem = allocate (size, stat);\n-\t  *stat = LIBERROR_ALLOCATION;\n+\t  stat = LIBERROR_ALLOCATION;\n \t  return mem;\n \t}\n \telse\n@@ -702,8 +719,8 @@ gfc_allocate_with_status (stmtblock_t * block, tree size, tree status,\n     expr must be set to the original expression being allocated for its locus\n     and variable name in case a runtime error has to be printed.  */\n tree\n-gfc_allocate_allocatable_with_status (stmtblock_t * block, tree mem, tree size,\n-\t\t\t\t      tree status, gfc_expr* expr)\n+gfc_allocate_allocatable (stmtblock_t * block, tree mem, tree size, tree status,\n+\t\t\t  tree errmsg, tree errlen, gfc_expr* expr)\n {\n   stmtblock_t alloc_block;\n   tree res, tmp, null_mem, alloc, error;\n@@ -718,11 +735,16 @@ gfc_allocate_allocatable_with_status (stmtblock_t * block, tree mem, tree size,\n \t\t\t\t\t    boolean_type_node, mem,\n \t\t\t\t\t    build_int_cst (type, 0)));\n \n-  /* If mem is NULL, we call gfc_allocate_with_status.  */\n+  /* If mem is NULL, we call gfc_allocate_using_malloc or\n+     gfc_allocate_using_lib.  */\n   gfc_start_block (&alloc_block);\n-  tmp = gfc_allocate_with_status (&alloc_block, size, status,\n-\t\t\t\t  gfc_option.coarray == GFC_FCOARRAY_LIB\n-\t\t\t\t  && gfc_expr_attr (expr).codimension);\n+\n+  if (gfc_option.coarray == GFC_FCOARRAY_LIB\n+      && gfc_expr_attr (expr).codimension)\n+    tmp = gfc_allocate_using_lib (&alloc_block, size, status,\n+\t\t\t\t  errmsg, errlen);\n+  else\n+    tmp = gfc_allocate_using_malloc (&alloc_block, size, status);\n \n   gfc_add_modify (&alloc_block, res, fold_convert (type, tmp));\n   alloc = gfc_finish_block (&alloc_block);\n@@ -747,9 +769,9 @@ gfc_allocate_allocatable_with_status (stmtblock_t * block, tree mem, tree size,\n \t\t\t\t     \"Attempting to allocate already allocated\"\n \t\t\t\t     \" variable\");\n \n-  if (status != NULL_TREE && !integer_zerop (status))\n+  if (status != NULL_TREE)\n     {\n-      tree status_type = TREE_TYPE (TREE_TYPE (status));\n+      tree status_type = TREE_TYPE (status);\n       stmtblock_t set_status_block;\n \n       gfc_start_block (&set_status_block);\n@@ -758,18 +780,12 @@ gfc_allocate_allocatable_with_status (stmtblock_t * block, tree mem, tree size,\n \t\t\t     fold_convert (pvoid_type_node, mem));\n       gfc_add_expr_to_block (&set_status_block, tmp);\n \n-      tmp = gfc_allocate_with_status (&set_status_block, size, status, false);\n+      tmp = gfc_allocate_using_malloc (&set_status_block, size, status);\n       gfc_add_modify (&set_status_block, res, fold_convert (type, tmp));\n \n-      gfc_add_modify (&set_status_block,\n-\t\t\t   fold_build1_loc (input_location, INDIRECT_REF,\n-\t\t\t\t\t    status_type, status),\n-\t\t\t   build_int_cst (status_type, LIBERROR_ALLOCATION));\n-\n-      tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n-\t\t\t     status, build_int_cst (status_type, 0));\n-      error = fold_build3_loc (input_location, COND_EXPR, void_type_node, tmp,\n-\t\t\t       error, gfc_finish_block (&set_status_block));\n+      gfc_add_modify (&set_status_block, status,\n+\t\t      build_int_cst (status_type, LIBERROR_ALLOCATION));\n+      error = gfc_finish_block (&set_status_block);\n     }\n \n   tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, null_mem,"}, {"sha": "73e2fa01e89fdfaec20a2f736eb364dd967f7395", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f992d640ed577dd5a8427d8c7855d7a51287e7f/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f992d640ed577dd5a8427d8c7855d7a51287e7f/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=8f992d640ed577dd5a8427d8c7855d7a51287e7f", "patch": "@@ -541,11 +541,12 @@ tree gfc_call_malloc (stmtblock_t *, tree, tree);\n tree gfc_build_memcpy_call (tree, tree, tree);\n \n /* Allocate memory for allocatable variables, with optional status variable.  */\n-tree gfc_allocate_allocatable_with_status (stmtblock_t*,\n-\t\t\t\t\t   tree, tree, tree, gfc_expr*);\n+tree gfc_allocate_allocatable (stmtblock_t*, tree, tree,\n+\t\t\t       tree, tree, tree, gfc_expr*);\n \n /* Allocate memory, with optional status variable.  */\n-tree gfc_allocate_with_status (stmtblock_t *, tree, tree, bool);\n+tree gfc_allocate_using_malloc (stmtblock_t *, tree, tree);\n+tree gfc_allocate_using_lib (stmtblock_t *, tree, tree, tree, tree);\n \n /* Generate code to deallocate an array.  */\n tree gfc_deallocate_with_status (tree, tree, bool, gfc_expr*);"}]}