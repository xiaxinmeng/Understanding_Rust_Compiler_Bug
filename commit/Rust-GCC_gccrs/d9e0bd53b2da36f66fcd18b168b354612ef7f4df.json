{"sha": "d9e0bd53b2da36f66fcd18b168b354612ef7f4df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDllMGJkNTNiMmRhMzZmNjZmY2QxOGIxNjhiMzU0NjEyZWY3ZjRkZg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-04-23T17:03:31Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-04-23T17:03:31Z"}, "message": "cpphash.h (struct definition): Move file, line, col members...\n\n\t* cpphash.h (struct definition): Move file, line, col members...\n\t(struct hashnode): ... here.  Also add 'disabled' flag.\n\t(enum node_type): Add T_VOID, T_XCONST, T_FMACRO, and\n\tT_IDENTITY.  Remove T_DISABLED.\n\tUpdate prototypes.\n\n\t* cpphash.c (_cpp_dump_definition): Split out dump_DEFINITION.\n\t(collect_expansion): Split into collect_objlike_expansion and\n\tcollect_funlike_expansion.\n\t(_cpp_macroexpand): Split out scan_arguments, stringify, and\n\tfunlike_macroexpand.\n\t(_cpp_compare_defs): Rename compare_defs, make static.\n\t(_cpp_make_hashnode): Initialize hp->disabled.\n\t(macro_cleanup): Adjust for new token types.  Clear\n\tm->disabled.\n\t(_cpp_create_definition): Move code here to determine what\n\tsort of macro it is, and code to check for redefinitions, from\n\tdo_define.  Implement a few simple cases without creating a\n\tfull DEFINITION.\n\t(_cpp_macroexpand, special_symbol, _cpp_dump_definition):\n\tHandle the simple cases.\n\t(push_macro_expansion): Set buf->has_escapes and hp->disabled\n\there.\n\n\t* cppinit.c (builtin_array): Change MCONST to XCONST\n\teverywhere.\n\t* cpplex.c (maybe_macroexpand): Handle IDENTITY macros here;\n\tfix check for disabled and function-like macros.\n\t* cpplib.c (do_define): Move most logic to\n\t_cpp_create_definition.\n\t(do_undef): Handle new special token types.\n\nFrom-SVN: r33355", "tree": {"sha": "dce0dfebe9bc09562c88a4bc2be4eecd8f6147d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dce0dfebe9bc09562c88a4bc2be4eecd8f6147d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9e0bd53b2da36f66fcd18b168b354612ef7f4df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9e0bd53b2da36f66fcd18b168b354612ef7f4df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9e0bd53b2da36f66fcd18b168b354612ef7f4df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9e0bd53b2da36f66fcd18b168b354612ef7f4df/comments", "author": null, "committer": null, "parents": [{"sha": "3c8c10b8c691cd1f8111f4eaf50ff22beadc0088", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c8c10b8c691cd1f8111f4eaf50ff22beadc0088", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c8c10b8c691cd1f8111f4eaf50ff22beadc0088"}], "stats": {"total": 1428, "additions": 806, "deletions": 622}, "files": [{"sha": "6351846ed5f8aae4c98c2d457c4e48caa2f79528", "filename": "gcc/ChangeLog", "status": "modified", "additions": 56, "deletions": 22, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9e0bd53b2da36f66fcd18b168b354612ef7f4df/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9e0bd53b2da36f66fcd18b168b354612ef7f4df/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d9e0bd53b2da36f66fcd18b168b354612ef7f4df", "patch": "@@ -1,3 +1,37 @@\n+2000-04-23  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cpphash.h (struct definition): Move file, line, col members...\n+\t(struct hashnode): ... here.  Also add 'disabled' flag.\n+\t(enum node_type): Add T_VOID, T_XCONST, T_FMACRO, and\n+\tT_IDENTITY.  Remove T_DISABLED.\t\t      \n+\tUpdate prototypes.\n+\n+\t* cpphash.c (_cpp_dump_definition): Split out dump_DEFINITION.     \n+\t(collect_expansion): Split into collect_objlike_expansion and\n+\tcollect_funlike_expansion.\t\t\t\t   \n+\t(_cpp_macroexpand): Split out scan_arguments, stringify, and\n+\tfunlike_macroexpand.\n+\t(_cpp_compare_defs): Rename compare_defs, make static.\n+\t(_cpp_make_hashnode): Initialize hp->disabled.\t\n+\t(macro_cleanup): Adjust for new token types.  Clear\n+\tm->disabled.\n+\t(_cpp_create_definition): Move code here to determine what     \n+\tsort of macro it is, and code to check for redefinitions, from\n+\tdo_define.  Implement a few simple cases without creating a   \n+\tfull DEFINITION.\n+\t(_cpp_macroexpand, special_symbol, _cpp_dump_definition):\n+\tHandle the simple cases.\t\t\t\t \n+\t(push_macro_expansion): Set buf->has_escapes and hp->disabled\n+\there.\n+\n+\t* cppinit.c (builtin_array): Change MCONST to XCONST\n+\teverywhere.\n+\t* cpplex.c (maybe_macroexpand): Handle IDENTITY macros here;\n+\tfix check for disabled and function-like macros.\n+\t* cpplib.c (do_define): Move most logic to\n+\t_cpp_create_definition.\n+\t(do_undef): Handle new special token types.\n+\n Sun Apr 23 14:27:44 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n \n \t* loop.c (maybe_eliminate_biv_1): Use GET_CODE (x) == CONST_INT instead\n@@ -53,31 +87,31 @@ Sat Apr 22 22:35:38 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n \n \t* Makefile.in (diagnostic.o): Depends on diagnostic.h\n \n-        * diagnostic.c: Tweak.  Rationalize the output logic.  Adjust\n+\t* diagnostic.c: Tweak.  Rationalize the output logic.  Adjust\n \tvarious function prototypes.\n-        (diagnostic.h): #include.\n-        (struct output_buffer): Move into diagnostic.h.\n-        (get_output_prefix): Rename to output_get_prefix.  Export.\n-        (init_output_buffer): Export. Break out.  Ajust intialization.\n-        (output_space_left, output_append): Export.\n-        (output_newline): Rename to output_add_newline.  Export.\n+\t(diagnostic.h): #include.\n+\t(struct output_buffer): Move into diagnostic.h.\n+\t(get_output_prefix): Rename to output_get_prefix.  Export.\n+\t(init_output_buffer): Export. Break out.  Ajust intialization.\n+\t(output_space_left, output_append): Export.\n+\t(output_newline): Rename to output_add_newline.  Export.\n \t(output_clear): Nullify additional output_buffer fields.\n-        (output_puts): Rename to output_add_string.  Export.\n-        (dump_output): Rename to output_flush_on.  Export.\n-        (build_location_prefix): Constify return-type.\n-        (emit_output_prefix): Rename to output_emit_prefix. Export.\n-        (set_real_maximum_length): New function.\n-        (output_set_maximum_length): Ditto\n-        (output_clear): Ditto.\n-        (output_add_character): Ditto.\n-        (output_add_integer): Ditto.\n-        (output_add_space): Ditto.\n-        (output_format): Ditto.\n-        (output_printf): Adjust buffer initialization.\n-        (vline_wrapper_message_with_location): Ditto.\n-        (v_message_with_decl): Ditto.  Adjust call to output_puts\n+\t(output_puts): Rename to output_add_string.  Export.\n+\t(dump_output): Rename to output_flush_on.  Export.\n+\t(build_location_prefix): Constify return-type.\n+\t(emit_output_prefix): Rename to output_emit_prefix. Export.\n+\t(set_real_maximum_length): New function.\n+\t(output_set_maximum_length): Ditto\n+\t(output_clear): Ditto.\n+\t(output_add_character): Ditto.\n+\t(output_add_integer): Ditto.\n+\t(output_add_space): Ditto.\n+\t(output_format): Ditto.\n+\t(output_printf): Adjust buffer initialization.\n+\t(vline_wrapper_message_with_location): Ditto.\n+\t(v_message_with_decl): Ditto.  Adjust call to output_puts\n \tand get_output_prefix.\n-        (default_print_error_function): Adjust buffer intialization.\n+\t(default_print_error_function): Adjust buffer intialization.\n \n Sat Apr 22 06:45:04 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n "}, {"sha": "cc704657abe7f7cf1fb6a0a3b2396aceb452dc22", "filename": "gcc/cpphash.c", "status": "modified", "additions": 719, "deletions": 507, "changes": 1226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9e0bd53b2da36f66fcd18b168b354612ef7f4df/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9e0bd53b2da36f66fcd18b168b354612ef7f4df/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=d9e0bd53b2da36f66fcd18b168b354612ef7f4df", "patch": "@@ -34,14 +34,17 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n static unsigned int hash_HASHNODE PARAMS ((const void *));\n static int eq_HASHNODE\t\t  PARAMS ((const void *, const void *));\n static void del_HASHNODE\t  PARAMS ((void *));\n+static void dump_DEFINITION\t  PARAMS ((cpp_reader *, DEFINITION *));\n static int dump_hash_helper\t  PARAMS ((void **, void *));\n \n-static void push_macro_expansion PARAMS ((cpp_reader *,\n-\t\t\t\t\t  U_CHAR *, int, HASHNODE *));\n+static void push_macro_expansion PARAMS ((cpp_reader *, const U_CHAR *,\n+\t\t\t\t\t  int, HASHNODE *));\n static int unsafe_chars\t\t PARAMS ((cpp_reader *, int, int));\n static int macro_cleanup\t PARAMS ((cpp_buffer *, cpp_reader *));\n static enum cpp_ttype macarg\t PARAMS ((cpp_reader *, int));\n-static void special_symbol\t PARAMS ((HASHNODE *, cpp_reader *));\n+static void special_symbol\t PARAMS ((cpp_reader *, HASHNODE *));\n+static int compare_defs\t\t PARAMS ((cpp_reader *, DEFINITION *,\n+\t\t\t\t\t  DEFINITION *));\n \n /* Initial hash table size.  (It can grow if necessary - see hashtab.c.)  */\n #define HASHSIZE 500\n@@ -72,8 +75,11 @@ struct arglist\n };\n \n \n-static DEFINITION *collect_expansion PARAMS ((cpp_reader *, cpp_toklist *,\n-\t\t\t\t\t      struct arglist *, unsigned int));\n+static DEFINITION *\n+collect_objlike_expansion PARAMS ((cpp_reader *, cpp_toklist *));\n+static DEFINITION *\n+collect_funlike_expansion PARAMS ((cpp_reader *, cpp_toklist *,\n+\t\t\t\t   struct arglist *, unsigned int));\n static unsigned int collect_params PARAMS ((cpp_reader *, cpp_toklist *,\n \t\t\t\t\t    struct arglist *));\n \n@@ -105,6 +111,12 @@ struct argdata\n   int stringified_length;\n };\n \n+static void scan_arguments\tPARAMS ((cpp_reader *, DEFINITION *,\n+\t\t\t\t\t  struct argdata *, const U_CHAR *));\n+static void stringify\t\tPARAMS ((cpp_reader *, struct argdata *));\n+static void funlike_macroexpand\tPARAMS ((cpp_reader *, HASHNODE *,\n+\t\t\t\t\t struct argdata *));\n+\n /* Calculate hash of a string of length LEN.  */\n unsigned int\n _cpp_calc_hash (str, len)\n@@ -174,6 +186,7 @@ _cpp_make_hashnode (name, len, type, hash)\n   hp->length = len;\n   hp->name = p;\n   hp->hash = hash;\n+  hp->disabled = 0;\n \n   memcpy (p, name, len);\n   p[len] = 0;\n@@ -277,10 +290,13 @@ macro_cleanup (pbuf, pfile)\n      cpp_buffer *pbuf;\n      cpp_reader *pfile ATTRIBUTE_UNUSED;\n {\n-  HASHNODE *macro = pbuf->macro;\n-  if (macro->type == T_DISABLED)\n-    macro->type = T_MACRO;\n-  if (macro->type != T_MACRO || pbuf->buf != macro->value.defn->expansion)\n+  HASHNODE *m = pbuf->macro;\n+  \n+  m->disabled = 0;\n+  if (m->type == T_FMACRO && pbuf->buf != m->value.defn->expansion)\n+    free ((PTR) pbuf->buf);\n+  else if (m->type != T_MACRO && m->type != T_FMACRO && m->type != T_CONST\n+\t   && m->type != T_MCONST && m->type != T_XCONST)\n     free ((PTR) pbuf->buf);\n   return 0;\n }\n@@ -398,16 +414,90 @@ trad_stringify (pfile, base, len, argc, argv, pat, endpat, last)\n   return last;\n }\n \n+/* Read a replacement list for an object-like macro, and build the\n+   DEFINITION structure.  LIST contains the replacement list,\n+   beginning at 1.  */\n+static DEFINITION *\n+collect_objlike_expansion (pfile, list)\n+     cpp_reader *pfile;\n+     cpp_toklist *list;\n+{\n+  DEFINITION *defn;\n+  unsigned int i;\n+  unsigned int start;\n+  int last_was_paste = 0;\n+  U_CHAR *exp;\n+  size_t len;\n \n-/* Read a replacement list for a macro, and build the DEFINITION\n-   structure.  LIST contains the replacement list, beginning at\n-   REPLACEMENT.  ARGLIST specifies the formal parameters to look for\n-   in the text of the definition.  If ARGLIST is null, this is an\n-   object-like macro; if it points to an empty arglist, this is a\n-   function-like macro with no arguments.  */\n+  /* We copy the expansion text into the token_buffer, then out to\n+     its proper home.  */\n+  start = CPP_WRITTEN (pfile);\n+  CPP_PUTS (pfile, \"\\r \", 2);\n+\n+  for (i = 1; i < list->tokens_used; i++)\n+    {\n+      switch (list->tokens[i].type)\n+\t{\n+\tcase CPP_POP:\n+\tcase CPP_EOF:\n+\t  cpp_ice (pfile, \"EOF in collect_expansion\");\n+\t  /* fall through */\n+\tcase CPP_VSPACE:\n+\t  goto done;\n+\n+\tcase CPP_PASTE:\n+\t  /* ## is not special if it appears right after another ##;\n+\t     nor is it special if -traditional.  */\n+\t  if (last_was_paste || CPP_TRADITIONAL (pfile))\n+\t    break;\n+\t  if (i == 1)\n+\t    cpp_error (pfile, \"`##' at start of macro definition\");\n+\n+\t  last_was_paste = 1;\n+\t  continue;\n+\n+\tdefault:;\n+\t}\n+\n+      if (i > 1 && !last_was_paste && (list->tokens[i].flags & HSPACE_BEFORE))\n+\tCPP_PUTC (pfile, ' ');\n+\n+      CPP_PUTS (pfile,\n+\t\tlist->tokens[i].val.name.offset + list->namebuf,\n+\t\tlist->tokens[i].val.name.len);\n+      last_was_paste = 0;\n+    }\n+ done:\n+\n+  if (last_was_paste)\n+    cpp_error (pfile, \"`##' at end of macro definition\");\n+\n+  CPP_PUTS (pfile, \"\\r \", 2);\n+  len = CPP_WRITTEN (pfile) - start;\n+  CPP_SET_WRITTEN (pfile, start);\n+\n+  exp = (U_CHAR *) xmalloc (len + 1);\n+  memcpy (exp, pfile->token_buffer + start, len);\n+  exp[len] = '\\0';\n+\n+  defn = (DEFINITION *) xmalloc (sizeof (DEFINITION));\n+  defn->length = len;\n+  defn->expansion = exp;\n+  defn->pattern = 0;\n+  defn->rest_args = 0;\n+  defn->argnames = 0;\n+  defn->nargs = -1;\n+\n+  return defn;\n+}\n+\n+/* Read a replacement list for a function-like macro, and build the\n+   DEFINITION structure.  LIST contains the replacement list,\n+   beginning at REPLACEMENT.  ARGLIST specifies the formal parameters\n+   to look for in the text of the definition.  */\n \n static DEFINITION *\n-collect_expansion (pfile, list, arglist, replacement)\n+collect_funlike_expansion (pfile, list, arglist, replacement)\n      cpp_reader *pfile;\n      cpp_toklist *list;\n      struct arglist *arglist;\n@@ -424,16 +514,8 @@ collect_expansion (pfile, list, arglist, replacement)\n   U_CHAR *tok, *exp;\n   enum { START = 0, NORM, ARG, STRIZE, PASTE } last_token = START;\n \n-  if (arglist)\n-    {\n-      argv = arglist->argv;\n-      argc = arglist->argc;\n-    }\n-  else\n-    {\n-      argv = 0;\n-      argc = 0;\n-    }\n+  argv = arglist->argv;\n+  argc = arglist->argc;\n \n   /* We copy the expansion text into the token_buffer, then out to\n      its proper home.  */\n@@ -455,12 +537,11 @@ collect_expansion (pfile, list, arglist, replacement)\n \t  goto done;\n \n \tcase CPP_HASH:\n-\t  /* # is not special in object-like macros.  It is special in\n-\t     function-like macros with no args.  (6.10.3.2 para 1.)\n-\t     However, it is not special after PASTE. (Implied by\n-\t     6.10.3.3 para 4.)  Nor is it special if -traditional.  */\n-\t  if (arglist == NULL || last_token == PASTE\n-\t      || CPP_TRADITIONAL (pfile))\n+\t  /* # is special in function-like macros with no args.\n+\t     (6.10.3.2 para 1.)  However, it is not special after\n+\t     PASTE. (Implied by 6.10.3.3 para 4.)  Nor is it special\n+\t     if -traditional.  */\n+\t  if (last_token == PASTE || CPP_TRADITIONAL (pfile))\n \t    break;\n \t  last_token = STRIZE;\n \t  continue;\n@@ -497,18 +578,20 @@ collect_expansion (pfile, list, arglist, replacement)\n \t{\n \tcase CPP_STRING:\n \tcase CPP_CHAR:\n-\t  if (argc)\n+\t  if (argc == 0)\n+\t    goto norm;\n+\t  if (CPP_TRADITIONAL (pfile))\n+\t    {\n+\t      last = trad_stringify (pfile, tok, len, argc, argv,\n+\t\t\t\t     &pat, &endpat, last);\n+\t      break;\n+\t    }\n+\t  else\n \t    {\n-\t      if (CPP_TRADITIONAL (pfile))\n-\t\t{\n-\t\t  last = trad_stringify (pfile, tok, len, argc, argv,\n-\t\t\t\t\t &pat, &endpat, last);\n-\t\t  break;\n-\t\t}\n \t      if (CPP_WTRADITIONAL (pfile))\n \t\twarn_trad_stringify (pfile, tok, len, argc, argv);\n+\t      goto norm;\n \t    }\n-\t  goto norm;\n \t  \n \tcase CPP_NAME:\n \t  for (j = 0; j < argc; j++)\n@@ -521,9 +604,6 @@ collect_expansion (pfile, list, arglist, replacement)\n \tnorm:\n \t  if (last_token == STRIZE)\n \t    cpp_error (pfile, \"# is not followed by a macro argument name\");\n-\t  if (last_token != PASTE && last_token != START\n-\t      && (list->tokens[i].flags & HSPACE_BEFORE))\n-\t    CPP_PUTC (pfile, ' ');\n \t  CPP_PUTS (pfile, tok, len);\n \t  last_token = NORM;\n \t}\n@@ -563,19 +643,11 @@ collect_expansion (pfile, list, arglist, replacement)\n   defn->length = len;\n   defn->expansion = exp;\n   defn->pattern = pat;\n-  defn->rest_args = argv && argv[argc - 1].rest_arg;\n-  if (arglist)\n-    {\n-      defn->nargs = argc;\n-      defn->argnames = arglist->namebuf;\n-      if (argv)\n-\tfree ((PTR) argv);\n-    }\n-  else\n-    {\n-      defn->nargs = -1;\n-      defn->argnames = 0;\n-    }\n+  defn->rest_args = argc && argv[argc - 1].rest_arg;\n+  defn->nargs = argc;\n+  defn->argnames = arglist->namebuf;\n+  if (argv)\n+    free ((PTR) argv);\n   return defn;\n }\n \n@@ -745,31 +817,134 @@ collect_params (pfile, list, arglist)\n    (including formal parameters if present) is in LIST.  If FUNLIKE is\n    true, this is a function-like macro.  */\n \n-DEFINITION *\n-_cpp_create_definition (pfile, list, funlike)\n+int\n+_cpp_create_definition (pfile, list, hp)\n      cpp_reader *pfile;\n      cpp_toklist *list;\n-     int funlike;\n+     HASHNODE *hp;\n {\n-  struct arglist args;\n-  DEFINITION *defn;\n-  int replacement = 1;  /* replacement begins at this token */\n+  DEFINITION *defn = 0;\n+  U_CHAR *cpval = 0;\n+  enum node_type ntype;\n+  int ok;\n+\n+  /* Special-case a few simple and common idioms:\n+     #define TOKEN   // nothing\n+     #define TOKEN TOKEN\n+     #define TOKEN OTHERTOKEN\n+\n+     Might also be good to special-case these:\n+\n+     #define FUNC()  // nothing\n+     #define FUNC(a, b, ...) // nothing\n+     #define FUNC(a, b, c) FUNC(a, b, c)\n+     #define FUNC(a, b, c) foobar(a, b, c)  */\n+\n+  if (list->tokens_used == 2)\n+    ntype = T_EMPTY;    /* Empty definition of object-like macro.  */\n+  else if (list->tokens_used == 3 && list->tokens[1].type == CPP_NAME)\n+    {\n+      if (list->tokens[0].val.name.len == list->tokens[1].val.name.len\n+\t  && !strncmp (list->tokens[0].val.name.offset + list->namebuf,\n+\t\t       list->tokens[1].val.name.offset + list->namebuf,\n+\t\t       list->tokens[0].val.name.len))\n+\tntype = T_IDENTITY;\n+      else\n+\t{\n+\t  ntype = T_MCONST;\n+\t  cpval = xmalloc (list->tokens[1].val.name.len + 1);\n+\t  memcpy (cpval, list->tokens[1].val.name.offset + list->namebuf,\n+\t\t  list->tokens[1].val.name.len);\n+\t  cpval[list->tokens[1].val.name.len] = '\\0';\n+\t}\n+    }\n \n-  if (funlike)\n+  /* The macro is function-like only if the next character,\n+     with no intervening whitespace, is '('.  */\n+  else if (list->tokens[1].type == CPP_OPEN_PAREN\n+\t   && ! (list->tokens[1].flags & HSPACE_BEFORE))\n     {\n+      struct arglist args;\n+      int replacement;\n+\n       replacement = collect_params (pfile, list, &args);\n       if (replacement == 0)\n \treturn 0;\n+      defn = collect_funlike_expansion (pfile, list, &args, replacement);\n+      if (defn == 0)\n+\treturn 0;\n+\n+      ntype = T_FMACRO;\n     }\n \n-  defn = collect_expansion (pfile, list, funlike ? &args : 0, replacement);\n-  if (defn == 0)\n-    return 0;\n+  /* Otherwise it is an object-like macro, and C99 requires\n+     whitespace after the name (6.10.3 para 3).  */\n+  else\n+    {\n+      if (! (list->tokens[1].flags & CPP_OPEN_PAREN))\n+\tcpp_pedwarn (pfile,\n+\t\t     \"The C standard requires whitespace after #define %s\",\n+\t\t     hp->name);\n \n-  defn->file = CPP_BUFFER (pfile)->nominal_fname;\n-  defn->line = list->line;\n-  defn->col  = list->tokens[0].col;\n-  return defn;\n+      defn = collect_objlike_expansion (pfile, list);\n+      if (defn == 0)\n+\treturn 0;\n+\n+      ntype = T_MACRO;\n+    }\n+\n+  /* Check for a redefinition, and its legality.  Redefining a macro\n+     of whatever stripe is ok if the definitions are the same.\n+     Redefining a built-in _constant_ (T_CONST or T_XCONST) is ok only\n+     with -D.  Otherwise a redefinition is not ok.  */\n+\n+  switch (hp->type)\n+    {\n+    case T_VOID:  ok = 1; break;\n+    default:\t  ok = 0; break;\n+\n+    case T_MACRO: case T_FMACRO:\n+      ok = (ntype == hp->type && !compare_defs (pfile, defn, hp->value.defn));\n+      break;\n+    case T_IDENTITY:\n+    case T_EMPTY:\n+      ok = (ntype == hp->type);\n+      break;\n+    case T_MCONST:\n+      ok = (ntype == hp->type && !strcmp (cpval, hp->value.cpval));\n+      break;\n+    case T_CONST:\n+    case T_XCONST:\n+      ok = ! pfile->done_initializing;\n+      break;\n+    }\n+\n+  /* Print the warning or error if it's not ok.  */\n+  if (! ok)\n+    {\n+      cpp_pedwarn (pfile, \"\\\"%s\\\" redefined\", hp->name);\n+      if (pfile->done_initializing)\n+\tcpp_pedwarn_with_file_and_line (pfile, hp->file, hp->line, hp->col,\n+\t\t\t\"this is the location of the previous definition\");\n+    }\n+\n+  /* And replace the old definition (if any).  */\n+\n+  if (hp->type == T_MACRO || hp->type == T_FMACRO)\n+    _cpp_free_definition (hp->value.defn);\n+  else if (hp->type == T_MCONST || hp->type == T_XCONST)\n+    free ((PTR) hp->value.cpval);\n+\n+  if (ntype == T_MACRO || ntype == T_FMACRO)\n+    hp->value.defn = defn;\n+  else\n+    hp->value.cpval = cpval;\n+\n+  hp->type = ntype;\n+  hp->file = CPP_BUFFER (pfile)->nominal_fname;\n+  hp->line = list->line;\n+  hp->col  = list->tokens[0].col;\n+  return 1;\n }\n \n /*\n@@ -874,9 +1049,9 @@ _cpp_quote_string (pfile, src)\n \n #define DSC(str) (const U_CHAR *)str, sizeof str - 1\n static void\n-special_symbol (hp, pfile)\n-     HASHNODE *hp;\n+special_symbol (pfile, hp)\n      cpp_reader *pfile;\n+     HASHNODE *hp;\n {\n   const char *buf;\n   cpp_buffer *ip;\n@@ -929,6 +1104,7 @@ special_symbol (hp, pfile)\n       /* else fall through */\n     case T_CONST:\n     case T_MCONST:\n+    case T_XCONST:\n     constant:\n       buf = hp->value.cpval;\n       if (!buf)\n@@ -1005,430 +1181,429 @@ _cpp_macroexpand (pfile, hp)\n      cpp_reader *pfile;\n      HASHNODE *hp;\n {\n-  int nargs;\n   DEFINITION *defn;\n-  register U_CHAR *xbuf;\n-  unsigned int start_line, start_column;\n-  cpp_buffer *ip;\n-  int xbuf_len;\n-  struct argdata *args = 0;\n-  long old_written = CPP_WRITTEN (pfile);\n-  int rest_args, rest_zero = 0;\n-  register int i;\n+  struct argdata *args;\n+  unsigned int old_written;\n+  int i;\n \n-  ip = cpp_file_buffer (pfile);\n-  if (ip)\n+  /* Object like macro - most common case.  */\n+  if (hp->type == T_MACRO)\n     {\n-      start_line = CPP_BUF_LINE (ip);\n-      start_column = CPP_BUF_COL (ip);\n+      push_macro_expansion (pfile, hp->value.defn->expansion,\n+\t\t\t    hp->value.defn->length, hp);\n+      return;\n+    }\n+\n+  /* Or might it be a constant string?  */\n+  if (hp->type == T_MCONST || hp->type == T_CONST || hp->type == T_XCONST)\n+    {\n+      const U_CHAR *cpval = hp->value.cpval;\n+      if (!cpval || *cpval == '\\0')\n+\tcpval = (const U_CHAR *) \"\\r \\r \";\n+      push_macro_expansion (pfile, cpval, strlen (cpval), hp);\n+      return;\n     }\n-  else\n-    start_line = start_column = 0;\n \n-  /* Check for and handle special symbols. */\n-  if (hp->type != T_MACRO)\n+  /* Or a special symbol?  */\n+  if (hp->type != T_FMACRO)\n     {\n-      special_symbol (hp, pfile);\n-      xbuf_len = CPP_WRITTEN (pfile) - old_written;\n-      xbuf = (U_CHAR *) xmalloc (xbuf_len + 1);\n+      U_CHAR *xbuf;\n+      unsigned int len, old_written = CPP_WRITTEN (pfile);\n+      \n+      special_symbol (pfile, hp);\n+      len = CPP_WRITTEN (pfile) - old_written;\n       CPP_SET_WRITTEN (pfile, old_written);\n-      memcpy (xbuf, CPP_PWRITTEN (pfile), xbuf_len + 1);\n-      push_macro_expansion (pfile, xbuf, xbuf_len, hp);\n-      CPP_BUFFER (pfile)->has_escapes = 1;\n+      xbuf = (U_CHAR *) xmalloc (len + 1);\n+      memcpy (xbuf, CPP_PWRITTEN (pfile), len);\n+      xbuf[len] = '\\0';\n+      push_macro_expansion (pfile, xbuf, len, hp);\n       return;\n     }\n \n+  /* Okay, it's a full-on function-like macro...  */\n+  old_written = CPP_WRITTEN (pfile);\n   defn = hp->value.defn;\n-  nargs = defn->nargs;\n+\n+  args = alloca (MAX (defn->nargs, 1) * sizeof (struct argdata));\n+  for (i = 0; i < MAX (defn->nargs, 1); i++)\n+    {\n+      args[i].raw = args[i].expanded = 0;\n+      args[i].raw_length = 0;\n+      args[i].expand_length = args[i].stringified_length = -1;\n+    }\n+\n   pfile->output_escapes++;\n+  scan_arguments (pfile, defn, args, hp->name);\n \n-  if (nargs >= 0)\n+  /* If macro wants zero args, we parsed the arglist for checking only.\n+     Read directly from the macro definition.  */\n+  if (defn->nargs == 0 || defn->pattern == 0)\n     {\n-      enum cpp_ttype token;\n+      CPP_SET_WRITTEN (pfile, old_written);\n+      pfile->output_escapes--;\n+      push_macro_expansion (pfile, defn->expansion, defn->length, hp);\n+      return;\n+    }\n \n-      args = (struct argdata *) alloca ((nargs + 1) * sizeof (struct argdata));\n+  funlike_macroexpand (pfile, hp, args);\n+  pfile->output_escapes--;\n+}\n \n-      for (i = 0; i < nargs; i++)\n-\t{\n-\t  args[i].raw = args[i].expanded = 0;\n-\t  args[i].raw_length = 0;\n-\t  args[i].expand_length = args[i].stringified_length = -1;\n-\t}\n+static void\n+scan_arguments (pfile, defn, args, name)\n+     cpp_reader *pfile;\n+     DEFINITION *defn;\n+     struct argdata *args;\n+     const U_CHAR *name;\n+{\n+  enum cpp_ttype token;\n+  unsigned int start_line, start_column;\n+  unsigned int nargs = defn->nargs;\n+  unsigned int i;\n+  \n+  cpp_buffer *ip = cpp_file_buffer (pfile);\n+  if (ip)\n+    {\n+      start_line = CPP_BUF_LINE (ip);\n+      start_column = CPP_BUF_COL (ip);\n+    }\n+  else\n+    start_line = start_column = 0;\n \n-      /* Parse all the macro args that are supplied.  I counts them.\n-         The first NARGS args are stored in ARGS.\n-         The rest are discarded.  If rest_args is set then we assume\n-         macarg absorbed the rest of the args.  */\n-      i = 0;\n-      rest_args = 0;\n-\n-      /* Skip over the opening parenthesis.  */\n-      CPP_OPTION (pfile, discard_comments)++;\n-      pfile->no_macro_expand++;\n-      pfile->no_directives++;\n-\n-      token = cpp_get_non_space_token (pfile);\n-      if (token != CPP_OPEN_PAREN)\n-\tcpp_ice (pfile, \"macroexpand: unexpected token %d (wanted LPAREN)\",\n-\t\t token);\n-      CPP_ADJUST_WRITTEN (pfile, -1);\n-\n-      token = CPP_EOF;\n-      do\n-\t{\n-\t  if (rest_args)\n-\t    continue;\n-\t  if (i < nargs || (nargs == 0 && i == 0))\n-\t    {\n-\t      /* if we are working on last arg which absorbs rest of args... */\n-\t      if (i == nargs - 1 && defn->rest_args)\n-\t\trest_args = 1;\n-\t      args[i].raw = CPP_WRITTEN (pfile);\n-\t      token = macarg (pfile, rest_args);\n-\t      args[i].raw_length = CPP_WRITTEN (pfile) - args[i].raw;\n-\t    }\n-\t  else\n-\t    token = macarg (pfile, 0);\n-\t  if (token == CPP_EOF || token == CPP_POP)\n-\t    cpp_error_with_line (pfile, start_line, start_column,\n-\t\t\t\t \"unterminated macro call\");\n-\t  i++;\n-\t}\n-      while (token == CPP_COMMA);\n-      CPP_OPTION (pfile, discard_comments)--;\n-      pfile->no_macro_expand--;\n-      pfile->no_directives--;\n-      if (token != CPP_CLOSE_PAREN)\n-\treturn;\n+  /* Parse all the macro args that are supplied.  I counts them.  The\n+     first NARGS args are stored in ARGS.  The rest are discarded.  If\n+     rest_args is set then we assume macarg absorbed the rest of the\n+     args.  */\n+  i = 0;\n \n-      /* foo ( ) is equivalent to foo () unless foo takes exactly one\n-\t argument, in which case the former is allowed and the latter\n-\t is not.  XXX C99 is silent on this rule, but it seems\n-\t inconsistent to me.  */\n-      if (i == 1 && nargs != 1)\n-\t{\n-\t  register U_CHAR *bp = ARG_BASE + args[0].raw;\n-\t  register U_CHAR *lim = bp + args[0].raw_length;\n-\t    while (bp != lim && is_space(*bp))\n-\t      bp++;\n-\t  if (bp == lim)\n-\t    i = 0;\n-\t}\n+  /* Skip over the opening parenthesis.  */\n+  CPP_OPTION (pfile, discard_comments)++;\n+  pfile->no_macro_expand++;\n+  pfile->no_directives++;\n \n-      /* Don't output an error message if we have already output one for\n-         a parse error above.  */\n-      rest_zero = 0;\n-      if (nargs == 0 && i > 0)\n-\t{\n-\t  cpp_error (pfile, \"arguments given to macro `%s'\", hp->name);\n-\t}\n-      else if (i < nargs)\n-\t{\n-\t  /* traditional C allows foo() if foo wants one argument.  */\n-\t  if (nargs == 1 && i == 0 && CPP_TRADITIONAL (pfile))\n-\t    ;\n-\t  /* the rest args token is allowed to absorb 0 tokens */\n-\t  else if (i == nargs - 1 && defn->rest_args)\n-\t    rest_zero = 1;\n-\t  else if (i == 0)\n-\t    cpp_error (pfile, \"macro `%s' used without args\", hp->name);\n-\t  else if (i == 1)\n-\t    cpp_error (pfile, \"macro `%s' used with just one arg\", hp->name);\n-\t  else\n-\t    cpp_error (pfile, \"macro `%s' used with only %d args\",\n-\t\t       hp->name, i);\n-\t}\n-      else if (i > nargs)\n+  token = cpp_get_non_space_token (pfile);\n+  if (token != CPP_OPEN_PAREN)\n+    cpp_ice (pfile, \"macroexpand: unexpected token %d (wanted LPAREN)\",\n+\t     token);\n+  CPP_ADJUST_WRITTEN (pfile, -1);\n+\n+  token = CPP_EOF;\n+  do\n+    {\n+      if (i < MAX (nargs, 1))\n \t{\n-\t  cpp_error (pfile,\n-\t\t     \"macro `%s' used with too many (%d) args\", hp->name, i);\n+\t  args[i].raw = CPP_WRITTEN (pfile);\n+\t  token = macarg (pfile, (i == nargs - 1 && defn->rest_args));\n+\t  args[i].raw_length = CPP_WRITTEN (pfile) - args[i].raw;\n \t}\n+      else\n+\ttoken = macarg (pfile, 0);\n+      if (token == CPP_EOF || token == CPP_POP)\n+\tcpp_error_with_line (pfile, start_line, start_column,\n+\t\t\t     \"unterminated macro call\");\n+      i++;\n     }\n+  while (token == CPP_COMMA);\n+  CPP_OPTION (pfile, discard_comments)--;\n+  pfile->no_macro_expand--;\n+  pfile->no_directives--;\n+  if (token != CPP_CLOSE_PAREN)\n+    return;\n \n-  /* If macro wants zero args, we parsed the arglist for checking only.\n-     Read directly from the macro definition.  */\n-  if (nargs <= 0)\n+  /* foo ( ) is equivalent to foo () unless foo takes exactly one\n+     argument, in which case the former is allowed and the latter\n+     is not.  XXX C99 is silent on this rule, but it seems\n+     inconsistent to me.  */\n+  if (i == 1 && nargs == 0)\n     {\n-      xbuf = defn->expansion;\n-      xbuf_len = defn->length;\n+      register U_CHAR *bp = ARG_BASE + args[0].raw;\n+      register U_CHAR *lim = bp + args[0].raw_length;\n+      while (bp != lim && is_space(*bp))\n+\tbp++;\n+      if (bp == lim)\n+\ti = 0;\n     }\n-  else\n-    {\n-      register U_CHAR *exp = defn->expansion;\n-      register int offset;\t/* offset in expansion,\n-\t\t\t\t   copied a piece at a time */\n-      register int totlen;\t/* total amount of exp buffer filled so far */\n \n-      register struct reflist *ap, *last_ap;\n+  /* Don't output an error message if we have already output one for\n+     a parse error above.  */\n+  if (nargs == 0 && i > 0)\n+    {\n+      cpp_error (pfile, \"arguments given to macro `%s'\", name);\n+    }\n+  else if (i < nargs)\n+    {\n+      /* traditional C allows foo() if foo wants one argument.  */\n+      if (nargs == 1 && i == 0 && CPP_TRADITIONAL (pfile))\n+\t;\n+      /* the rest args token is allowed to absorb 0 tokens */\n+      else if (i == nargs - 1 && defn->rest_args)\n+\t;\n+      else if (i == 0)\n+\tcpp_error (pfile, \"macro `%s' used without args\", name);\n+      else if (i == 1)\n+\tcpp_error (pfile, \"macro `%s' used with just one arg\", name);\n+      else\n+\tcpp_error (pfile, \"macro `%s' used with only %d args\", name, i);\n+    }\n+  else if (i > nargs)\n+    {\n+      cpp_error (pfile, \"macro `%s' used with too many (%d) args\", name, i);\n+    }\n+}\n \n-      /* Macro really takes args.  Compute the expansion of this call.  */\n+static void\n+stringify (pfile, arg)\n+     cpp_reader *pfile;\n+     struct argdata *arg;\n+{\n+  int arglen = arg->raw_length;\n+  int escaped = 0;\n+  int in_string = 0;\n+  int c;\n+  int i;\n+  /* Initially need_space is -1.  Otherwise, 1 means the previous\n+     character was a space, but we suppressed it; 0 means the previous\n+     character was a non-space.  */\n+  int need_space = -1;\n+  i = 0;\n+  arg->stringified = CPP_WRITTEN (pfile);\n+  CPP_PUTC (pfile, '\\\"');\t/* insert beginning quote */\n+  for (; i < arglen; i++)\n+    {\n+      c = (ARG_BASE + arg->raw)[i];\n \n-      /* Compute length in characters of the macro's expansion.\n-         Also count number of times each arg is used.  */\n-      xbuf_len = defn->length;\n-      for (ap = defn->pattern; ap != NULL; ap = ap->next)\n+      if (!in_string)\n \t{\n-\t  if (ap->stringify)\n+\t  /* Delete \"\\r \" and \"\\r-\" escapes.  */\n+\t  if (c == '\\r')\n \t    {\n-\t      register struct argdata *arg = &args[ap->argno];\n-\t      /* Stringify if it hasn't already been */\n-\t      if (arg->stringified_length < 0)\n-\t\t{\n-\t\t  int arglen = arg->raw_length;\n-\t\t  int escaped = 0;\n-\t\t  int in_string = 0;\n-\t\t  int c;\n-\t\t  /* Initially need_space is -1.  Otherwise, 1 means the\n-\t\t     previous character was a space, but we suppressed it;\n-\t\t     0 means the previous character was a non-space.  */\n-\t\t  int need_space = -1;\n-\t\t  i = 0;\n-\t\t  arg->stringified = CPP_WRITTEN (pfile);\n-\t\t  CPP_PUTC (pfile, '\\\"');\t/* insert beginning quote */\n-\t\t  for (; i < arglen; i++)\n-\t\t    {\n-\t\t      c = (ARG_BASE + arg->raw)[i];\n-\n-\t\t      if (!in_string)\n-\t\t\t{\n-\t\t\t  /* Delete \"\\r \" and \"\\r-\" escapes.  */\n-\t\t\t  if (c == '\\r')\n-\t\t\t    {\n-\t\t\t      i++;\n-\t\t\t      continue;\n-\t\t\t    }\n-\t\t\t  /* Internal sequences of whitespace are\n-\t\t\t     replaced by one space except within\n-\t\t\t     a string or char token. */\n-\t\t\t  else if (is_space(c))\n-\t\t\t    {\n-\t\t\t      if (need_space == 0)\n-\t\t\t\tneed_space = 1;\n-\t\t\t      continue;\n-\t\t\t    }\n-\t\t\t  else if (need_space > 0)\n-\t\t\t    CPP_PUTC (pfile, ' ');\n-\t\t\t  need_space = 0;\n-\t\t\t}\n-\n-\t\t      if (escaped)\n-\t\t\tescaped = 0;\n-\t\t      else\n-\t\t\t{\n-\t\t\t  if (c == '\\\\')\n-\t\t\t    escaped = 1;\n-\t\t\t  if (in_string)\n-\t\t\t    {\n-\t\t\t      if (c == in_string)\n-\t\t\t\tin_string = 0;\n-\t\t\t    }\n-\t\t\t  else if (c == '\\\"' || c == '\\'')\n-\t\t\t    in_string = c;\n-\t\t\t}\n-\n-\t\t      /* Escape these chars */\n-\t\t      if (c == '\\\"' || (in_string && c == '\\\\'))\n-\t\t\tCPP_PUTC (pfile, '\\\\');\n-\t\t      if (ISPRINT (c))\n-\t\t\tCPP_PUTC (pfile, c);\n-\t\t      else\n-\t\t\t{\n-\t\t\t  CPP_RESERVE (pfile, 4);\n-\t\t\t  sprintf ((char *) CPP_PWRITTEN (pfile), \"\\\\%03o\",\n-\t\t\t\t   (unsigned int) c);\n-\t\t\t  CPP_ADJUST_WRITTEN (pfile, 4);\n-\t\t\t}\n-\t\t    }\n-\t\t  CPP_PUTC (pfile, '\\\"');\t/* insert ending quote */\n-\t\t  arg->stringified_length\n-\t\t    = CPP_WRITTEN (pfile) - arg->stringified;\n-\t\t}\n-\t      xbuf_len += args[ap->argno].stringified_length;\n+\t      i++;\n+\t      continue;\n \t    }\n-\t  else if (ap->raw_before || ap->raw_after)\n-\t    /* Add 4 for two \\r-space markers to prevent\n-\t       token concatenation.  */\n-\t    xbuf_len += args[ap->argno].raw_length + 4;\n-\t  else\n+\t  /* Internal sequences of whitespace are replaced by one\n+\t     space except within a string or char token. */\n+\t  else if (is_space(c))\n \t    {\n-\t      /* We have an ordinary (expanded) occurrence of the arg.\n-\t         So compute its expansion, if we have not already.  */\n-\t      if (args[ap->argno].expand_length < 0)\n-\t\t{\n-\t\t  args[ap->argno].expanded = CPP_WRITTEN (pfile);\n-\t\t  _cpp_expand_to_buffer (pfile,\n-\t\t\t\t\t ARG_BASE + args[ap->argno].raw,\n-\t\t\t\t\t args[ap->argno].raw_length);\n-\n-\t\t  args[ap->argno].expand_length\n-\t\t    = CPP_WRITTEN (pfile) - args[ap->argno].expanded;\n-\t\t}\n+\t      if (need_space == 0)\n+\t\tneed_space = 1;\n+\t      continue;\n+\t    }\n+\t  else if (need_space > 0)\n+\t    CPP_PUTC (pfile, ' ');\n+\t  need_space = 0;\n+\t}\n \n-\t      /* Add 4 for two \\r-space markers to prevent\n-\t         token concatenation.  */\n-\t      xbuf_len += args[ap->argno].expand_length + 4;\n+      if (escaped)\n+\tescaped = 0;\n+      else\n+\t{\n+\t  if (c == '\\\\')\n+\t    escaped = 1;\n+\t  if (in_string)\n+\t    {\n+\t      if (c == in_string)\n+\t\tin_string = 0;\n \t    }\n+\t  else if (c == '\\\"' || c == '\\'')\n+\t    in_string = c;\n \t}\n \n-      xbuf = (U_CHAR *) xmalloc (xbuf_len + 1);\n+      /* Escape these chars */\n+      if (c == '\\\"' || (in_string && c == '\\\\'))\n+\tCPP_PUTC (pfile, '\\\\');\n+      if (ISPRINT (c))\n+\tCPP_PUTC (pfile, c);\n+      else\n+\t{\n+\t  CPP_RESERVE (pfile, 4);\n+\t  sprintf ((char *) CPP_PWRITTEN (pfile), \"\\\\%03o\", (unsigned int) c);\n+\t  CPP_ADJUST_WRITTEN (pfile, 4);\n+\t}\n+    }\n+  CPP_PUTC (pfile, '\\\"');\t/* insert ending quote */\n+  arg->stringified_length  = CPP_WRITTEN (pfile) - arg->stringified;\n+}\n \n-      /* Generate in XBUF the complete expansion\n-         with arguments substituted in.\n-         TOTLEN is the total size generated so far.\n-         OFFSET is the index in the definition\n-         of where we are copying from.  */\n-      offset = totlen = 0;\n-      for (last_ap = NULL, ap = defn->pattern; ap != NULL;\n-\t   last_ap = ap, ap = ap->next)\n+static void\n+funlike_macroexpand (pfile, hp, args)\n+     cpp_reader *pfile;\n+     HASHNODE *hp;\n+     struct argdata *args;\n+{\n+  DEFINITION *defn = hp->value.defn;\n+  register U_CHAR *xbuf;\n+  int xbuf_len;\n+  long old_written = CPP_WRITTEN (pfile);\n+  U_CHAR *exp = defn->expansion;\n+  int offset;\t/* offset in expansion, copied a piece at a time */\n+  int totlen;\t/* total amount of exp buffer filled so far */\n+  struct reflist *ap, *last_ap;\n+  int i;\n+\n+  /* Compute length in characters of the macro's expansion.\n+     Also count number of times each arg is used.  */\n+  xbuf_len = defn->length;\n+  for (ap = defn->pattern; ap != NULL; ap = ap->next)\n+    {\n+      if (ap->stringify)\n \t{\n-\t  register struct argdata *arg = &args[ap->argno];\n-\t  int count_before = totlen;\n-\n-\t  /* Add chars to XBUF.  */\n-\t  i = ap->nchars;\n-\t  memcpy (&xbuf[totlen], &exp[offset], i);\n-\t  totlen += i;\n-\t  offset += i;\n-\n-\t  /* If followed by an empty rest arg with concatenation,\n-\t     delete the last run of nonwhite chars.  */\n-\t  if (rest_zero && totlen > count_before\n-\t      && ((ap->rest_args && ap->raw_before)\n-\t\t  || (last_ap != NULL && last_ap->rest_args\n-\t\t      && last_ap->raw_after)))\n+\t  /* Stringify if it hasn't already been */\n+\t  if (args[ap->argno].stringified_length < 0)\n+\t    stringify (pfile, &args[ap->argno]);\n+\t  xbuf_len += args[ap->argno].stringified_length;\n+\t}\n+      else if (ap->raw_before || ap->raw_after)\n+\t/* Add 4 for two \\r-space markers to prevent\n+\t   token concatenation.  */\n+\txbuf_len += args[ap->argno].raw_length + 4;\n+      else\n+\t{\n+\t  /* We have an ordinary (expanded) occurrence of the arg.\n+\t     So compute its expansion, if we have not already.  */\n+\t  if (args[ap->argno].expand_length < 0)\n \t    {\n-\t      /* Delete final whitespace.  */\n-\t      while (totlen > count_before && is_space(xbuf[totlen - 1]))\n-\t\ttotlen--;\n+\t      args[ap->argno].expanded = CPP_WRITTEN (pfile);\n+\t      _cpp_expand_to_buffer (pfile, ARG_BASE + args[ap->argno].raw,\n+\t\t\t\t     args[ap->argno].raw_length);\n \n-\t      /* Delete the nonwhites before them.  */\n-\t      while (totlen > count_before && !is_space(xbuf[totlen - 1]))\n-\t\ttotlen--;\n+\t      args[ap->argno].expand_length\n+\t\t= CPP_WRITTEN (pfile) - args[ap->argno].expanded;\n \t    }\n \n-\t  if (ap->stringify != 0)\n-\t    {\n-\t      memcpy (xbuf + totlen, ARG_BASE + arg->stringified,\n-\t\t      arg->stringified_length);\n-\t      totlen += arg->stringified_length;\n-\t    }\n-\t  else if (ap->raw_before || ap->raw_after)\n+\t  /* Add 4 for two \\r-space markers to prevent\n+\t     token concatenation.  */\n+\t  xbuf_len += args[ap->argno].expand_length + 4;\n+\t}\n+    }\n+\n+  xbuf = (U_CHAR *) xmalloc (xbuf_len + 1);\n+\n+  /* Generate in XBUF the complete expansion with arguments\n+     substituted in.  TOTLEN is the total size generated so far.\n+     OFFSET is the index in the definition of where we are copying\n+     from.  */\n+  offset = totlen = 0;\n+  for (last_ap = NULL, ap = defn->pattern; ap != NULL;\n+       last_ap = ap, ap = ap->next)\n+    {\n+      register struct argdata *arg = &args[ap->argno];\n+      int count_before = totlen;\n+\n+      /* Add chars to XBUF.  */\n+      i = ap->nchars;\n+      memcpy (&xbuf[totlen], &exp[offset], i);\n+      totlen += i;\n+      offset += i;\n+\n+      /* If followed by an empty rest arg with concatenation,\n+\t delete the last run of nonwhite chars.  */\n+      if (arg->raw_length == 0 && totlen > count_before\n+\t  && ((ap->rest_args && ap->raw_before)\n+\t      || (last_ap != NULL && last_ap->rest_args\n+\t\t  && last_ap->raw_after)))\n+\t{\n+\t  /* Delete final whitespace.  */\n+\t  while (totlen > count_before && is_space(xbuf[totlen - 1]))\n+\t    totlen--;\n+\n+\t  /* Delete the nonwhites before them.  */\n+\t  while (totlen > count_before && !is_space(xbuf[totlen - 1]))\n+\t    totlen--;\n+\t}\n+\n+      if (ap->stringify != 0)\n+\t{\n+\t  memcpy (xbuf + totlen, ARG_BASE + arg->stringified,\n+\t\t  arg->stringified_length);\n+\t  totlen += arg->stringified_length;\n+\t}\n+      else if (ap->raw_before || ap->raw_after)\n+\t{\n+\t  U_CHAR *p1 = ARG_BASE + arg->raw;\n+\t  U_CHAR *l1 = p1 + arg->raw_length;\n+\t  if (ap->raw_before)\n \t    {\n-\t      U_CHAR *p1 = ARG_BASE + arg->raw;\n-\t      U_CHAR *l1 = p1 + arg->raw_length;\n-\t      if (ap->raw_before)\n+\t      /* Arg is concatenated before: delete leading whitespace,\n+\t\t whitespace markers, and no-reexpansion markers.  */\n+\t      while (p1 != l1)\n \t\t{\n-\t\t  /* Arg is concatenated before: delete leading whitespace,\n-\t\t     whitespace markers, and no-reexpansion markers.  */\n-\t\t  while (p1 != l1)\n-\t\t    {\n-\t\t      if (is_space(p1[0]))\n-\t\t\tp1++;\n-\t\t      else if (p1[0] == '\\r')\n-\t\t\tp1 += 2;\n-\t\t      else\n-\t\t\tbreak;\n-\t\t    }\n+\t\t  if (is_space(p1[0]))\n+\t\t    p1++;\n+\t\t  else if (p1[0] == '\\r')\n+\t\t    p1 += 2;\n+\t\t  else\n+\t\t    break;\n \t\t}\n-\t      if (ap->raw_after)\n+\t    }\n+\t  if (ap->raw_after)\n+\t    {\n+\t      /* Arg is concatenated after: delete trailing whitespace,\n+\t\t whitespace markers, and no-reexpansion markers.  */\n+\t      while (p1 != l1)\n \t\t{\n-\t\t  /* Arg is concatenated after: delete trailing whitespace,\n-\t\t     whitespace markers, and no-reexpansion markers.  */\n-\t\t  while (p1 != l1)\n+\t\t  if (is_space(l1[-1]))\n+\t\t    l1--;\n+\t\t  else if (l1[-1] == '\\r')\n+\t\t    l1--;\n+\t\t  else if (l1[-1] == '-')\n \t\t    {\n-\t\t      if (is_space(l1[-1]))\n-\t\t\tl1--;\n-\t\t      else if (l1[-1] == '\\r')\n-\t\t\tl1--;\n-\t\t      else if (l1[-1] == '-')\n-\t\t\t{\n-\t\t\t  if (l1 != p1 + 1 && l1[-2] == '\\r')\n-\t\t\t    l1 -= 2;\n-\t\t\t  else\n-\t\t\t    break;\n-\t\t\t}\n+\t\t      if (l1 != p1 + 1 && l1[-2] == '\\r')\n+\t\t\tl1 -= 2;\n \t\t      else\n \t\t\tbreak;\n \t\t    }\n+\t\t  else\n+\t\t    break;\n \t\t}\n-\n-\t      /* Delete any no-reexpansion marker that precedes\n-\t         an identifier at the beginning of the argument. */\n-\t      if (p1[0] == '\\r' && p1[1] == '-')\n-\t\tp1 += 2;\n-\n-\t      memcpy (xbuf + totlen, p1, l1 - p1);\n-\t      totlen += l1 - p1;\n \t    }\n-\t  else\n-\t    {\n-\t      U_CHAR *expanded = ARG_BASE + arg->expanded;\n-\t      if (!ap->raw_before && totlen > 0 && arg->expand_length\n-\t\t  && unsafe_chars (pfile, xbuf[totlen - 1], expanded[0]))\n-\t\t{\n-\t\t  xbuf[totlen++] = '\\r';\n-\t\t  xbuf[totlen++] = ' ';\n-\t\t}\n \n-\t      memcpy (xbuf + totlen, expanded, arg->expand_length);\n-\t      totlen += arg->expand_length;\n+\t  /* Delete any no-reexpansion marker that precedes\n+\t     an identifier at the beginning of the argument. */\n+\t  if (p1[0] == '\\r' && p1[1] == '-')\n+\t    p1 += 2;\n \n-\t      if (!ap->raw_after && totlen > 0 && offset < defn->length\n-\t\t  && unsafe_chars (pfile, xbuf[totlen - 1], exp[offset]))\n-\t\t{\n-\t\t  xbuf[totlen++] = '\\r';\n-\t\t  xbuf[totlen++] = ' ';\n-\t\t}\n-\t    }\n-\n-\t  if (totlen > xbuf_len)\n+\t  memcpy (xbuf + totlen, p1, l1 - p1);\n+\t  totlen += l1 - p1;\n+\t}\n+      else\n+\t{\n+\t  U_CHAR *expanded = ARG_BASE + arg->expanded;\n+\t  if (!ap->raw_before && totlen > 0 && arg->expand_length\n+\t      && unsafe_chars (pfile, xbuf[totlen - 1], expanded[0]))\n \t    {\n-\t      cpp_ice (pfile, \"buffer overrun in macroexpand\");\n-\t      return;\n+\t      xbuf[totlen++] = '\\r';\n+\t      xbuf[totlen++] = ' ';\n \t    }\n-\t}\n \n-      /* if there is anything left of the definition\n-         after handling the arg list, copy that in too.  */\n+\t  memcpy (xbuf + totlen, expanded, arg->expand_length);\n+\t  totlen += arg->expand_length;\n \n-      for (i = offset; i < defn->length; i++)\n-\t{\n-\t  /* if we've reached the end of the macro */\n-\t  if (exp[i] == ')')\n-\t    rest_zero = 0;\n-\t  if (!(rest_zero && last_ap != NULL && last_ap->rest_args\n-\t\t&& last_ap->raw_after))\n-\t    xbuf[totlen++] = exp[i];\n+\t  if (!ap->raw_after && totlen > 0 && offset < defn->length\n+\t      && unsafe_chars (pfile, xbuf[totlen - 1], exp[offset]))\n+\t    {\n+\t      xbuf[totlen++] = '\\r';\n+\t      xbuf[totlen++] = ' ';\n+\t    }\n \t}\n-\n-      xbuf[totlen] = 0;\n-      xbuf_len = totlen;\n-\n     }\n \n-  pfile->output_escapes--;\n+  /* if there is anything left of the definition\n+     after handling the arg list, copy that in too.  */\n \n+  for (i = offset; i < defn->length; i++)\n+    xbuf[totlen++] = exp[i];\n+  xbuf[totlen] = 0;\n+\n+  if (totlen > xbuf_len)\n+    /* Just die - we've trashed the heap at this point.  */\n+    abort ();\n+  \n   /* Now put the expansion on the input stack\n      so our caller will commence reading from it.  */\n-  push_macro_expansion (pfile, xbuf, xbuf_len, hp);\n-  CPP_BUFFER (pfile)->has_escapes = 1;\n+  push_macro_expansion (pfile, xbuf, totlen, hp);\n \n   /* Pop the space we've used in the token_buffer for argument expansion.  */\n   CPP_SET_WRITTEN (pfile, old_written);\n-\n-  /* In C89, a macro cannot be expanded recursively.  Traditional C\n-     permits it, but any use in an object-like macro must lead to\n-     infinite recursion, so always follow C89 in object-like macros.\n-\n-     The only example known where this doesn't cause infinite recursion\n-     in function-like macros is:\n-\t#define foo(x,y) bar(x(y, 0))\n-\tfoo(foo, baz)\n-     which expands to bar(foo(baz, 0)) in C89 and\n-     bar(bar(baz(0, 0)) in K+R.  This looks pathological to me.\n-     If someone has a real-world example I would love to see it.  */\n-  if (nargs <= 0 || !CPP_TRADITIONAL (pfile))\n-    hp->type = T_DISABLED;\n }\n \n /* Return 1 iff a token ending in C1 followed directly by a token C2\n@@ -1501,7 +1676,7 @@ unsafe_chars (pfile, c1, c2)\n static void\n push_macro_expansion (pfile, xbuf, len, hp)\n      cpp_reader *pfile;\n-     register U_CHAR *xbuf;\n+     const U_CHAR *xbuf;\n      int len;\n      HASHNODE *hp;\n {\n@@ -1539,12 +1714,33 @@ push_macro_expansion (pfile, xbuf, len, hp)\n     mbuf->cur += 2;\n   mbuf->cleanup = macro_cleanup;\n   mbuf->macro = hp;\n+  mbuf->has_escapes = 1;\n+\n+  /* In C89, a macro cannot be expanded recursively.  Traditional C\n+     permits it, but any use in an object-like macro must lead to\n+     infinite recursion, so always follow C89 in object-like macros.\n+     Likewise, in a function-like macro it must cause infinite\n+     recursion unless we are actually doing something with the\n+     arguments.\n+\n+     Even that criterion is too weak.  The only example known where\n+     macro recursion isn't infinite is:\n+\t#define bar(x,y) foo(x(y, 0))\n+\tbar(bar, baz)\n+     which expands to foo(bar(baz, 0)) in C89 and\n+     foo(foo(baz(0, 0)) in K+R.  This looks pathological to me.\n+     If someone has a real-world example I would love to see it.  */\n+  if (hp->type != T_FMACRO\n+      || hp->value.defn->nargs == 0\n+      || hp->value.defn->pattern == 0\n+      || !CPP_TRADITIONAL (pfile))\n+    hp->disabled = 1;\n }\n \n /* Return zero if two DEFINITIONs are isomorphic.  */\n \n-int\n-_cpp_compare_defs (pfile, d1, d2)\n+static int\n+compare_defs (pfile, d1, d2)\n      cpp_reader *pfile;\n      DEFINITION *d1, *d2;\n {\n@@ -1590,91 +1786,107 @@ _cpp_compare_defs (pfile, d1, d2)\n    to be read back in again. */\n \n void\n-_cpp_dump_definition (pfile, sym, len, defn)\n+_cpp_dump_definition (pfile, hp)\n      cpp_reader *pfile;\n-     const U_CHAR *sym;\n-     long len;\n-     DEFINITION *defn;\n+     HASHNODE *hp;\n {\n-  CPP_RESERVE (pfile, len + sizeof \"#define \");\n-  CPP_PUTS_Q (pfile, \"#define \", sizeof \"#define \" -1);\n-  CPP_PUTS_Q (pfile, sym, len);\n-\n-  if (defn->nargs == -1)\n+  CPP_RESERVE (pfile, hp->length + sizeof \"#define \");\n+  CPP_PUTS_Q (pfile, \"#define \", sizeof \"#define \" - 1);\n+  CPP_PUTS_Q (pfile, hp->name, hp->length);\n+\n+  if (hp->type == T_EMPTY)\n+    /* do nothing */;\n+  else if (hp->type == T_FMACRO)\n+    dump_DEFINITION (pfile, hp->value.defn);\n+  else\n     {\n       CPP_PUTC_Q (pfile, ' ');\n \n-      /* The first and last two characters of a macro expansion are\n-\t always \"\\r \"; this needs to be trimmed out.\n-\t So we need length-4 chars of space, plus one for the NUL.  */\n-      CPP_RESERVE (pfile, defn->length - 4 + 1);\n-      CPP_PUTS_Q (pfile, defn->expansion + 2, defn->length - 4);\n-    }\n-  else\n-    {\n-      struct reflist *r;\n-      unsigned char **argv = (unsigned char **) alloca (defn->nargs *\n-\t\t\t\t\t\t\tsizeof(char *));\n-      int *argl = (int *) alloca (defn->nargs * sizeof(int));\n-      unsigned char *x;\n-      int i;\n-\n-      /* First extract the argument list. */\n-      x = defn->argnames;\n-      for (i = 0; i < defn->nargs; i++)\n-\t{\n-\t  argv[i] = x;\n-\t  argl[i] = strlen (x);\n-\t  x += argl[i] + 1;\n-\t}\n-      \n-      /* Now print out the argument list. */\n-      CPP_PUTC_Q (pfile, '(');\n-      for (i = 0; i < defn->nargs; i++)\n+      if (hp->type == T_IDENTITY)\n+\tCPP_PUTS (pfile, hp->name, hp->length);\n+      else if (hp->type == T_MCONST)\n+\tCPP_PUTS (pfile, hp->value.cpval, strlen (hp->value.cpval));\n+      else if (hp->type == T_MACRO)\n \t{\n-\t  CPP_RESERVE (pfile, argl[i] + 2);\n-\t  if (!(i == defn->nargs-1 && defn->rest_args\n-\t\t&& !strcmp (argv[i], \"__VA_ARGS__\")))\n-\t    CPP_PUTS_Q (pfile, argv[i], argl[i]);\n-\t  if (i < defn->nargs-1)\n-\t    CPP_PUTS_Q (pfile, \", \", 2);\n+\t  /* The first and last two characters of a macro expansion are\n+\t     always \"\\r \"; this needs to be trimmed out.\n+\t     So we need length-4 chars of space, plus one for the NUL.  */\n+\t  CPP_RESERVE (pfile, hp->value.defn->length - 4 + 1);\n+\t  CPP_PUTS_Q (pfile, hp->value.defn->expansion + 2,\n+\t\t      hp->value.defn->length - 4);\n \t}\n-      if (defn->rest_args)\n-\tCPP_PUTS (pfile, \"...\", 3);\n-      CPP_PUTS (pfile, \") \", 2);\n+      else\n+\tcpp_ice (pfile, \"invalid hash type %d in dump_definition\", hp->type);\n+    }\n+  if (CPP_BUFFER (pfile) == 0 || ! pfile->done_initializing)\n+    CPP_PUTC (pfile, '\\n');\n+}\n \n-      /* Now the definition. */\n-      x = defn->expansion;\n-      for (r = defn->pattern; r; r = r->next)\n-      {\n-\ti = r->nchars;\n-\tif (*x == '\\r') x += 2, i -= 2;\n-\t/* i chars for macro text, plus the length of the macro\n-\t   argument name, plus one for a stringify marker, plus two for\n-\t   each concatenation marker. */\n-\tCPP_RESERVE (pfile,\n-\t\t     i + argl[r->argno] + r->stringify\n-\t\t     + (r->raw_before + r->raw_after) * 2);\n-\n-\tif (i > 0) CPP_PUTS_Q (pfile, x, i);\n-\tif (r->raw_before)\n-\t  CPP_PUTS_Q (pfile, \"##\", 2);\n-\tif (r->stringify)\n-\t  CPP_PUTC_Q (pfile, '#');\n-\tCPP_PUTS_Q (pfile, argv[r->argno], argl[r->argno]);\n-\tif (r->raw_after && !(r->next && r->next->nchars == 0\n-\t\t\t      && r->next->raw_before))\n-\t  CPP_PUTS_Q (pfile, \"##\", 2);\n-\n-\tx += i;\n-      }\n+static void\n+dump_DEFINITION (pfile, defn)\n+     cpp_reader *pfile;\n+     DEFINITION *defn;\n+{\n+  struct reflist *r;\n+  unsigned char **argv = (unsigned char **) alloca (defn->nargs *\n+\t\t\t\t\t\t    sizeof(char *));\n+  int *argl = (int *) alloca (defn->nargs * sizeof(int));\n+  unsigned char *x;\n+  int i;\n+\n+  /* First extract the argument list. */\n+  x = defn->argnames;\n+  for (i = 0; i < defn->nargs; i++)\n+    {\n+      argv[i] = x;\n+      argl[i] = strlen (x);\n+      x += argl[i] + 1;\n+    }\n+      \n+  /* Now print out the argument list. */\n+  CPP_PUTC_Q (pfile, '(');\n+  for (i = 0; i < defn->nargs; i++)\n+    {\n+      CPP_RESERVE (pfile, argl[i] + 2);\n+      if (!(i == defn->nargs-1 && defn->rest_args\n+\t    && !strcmp (argv[i], \"__VA_ARGS__\")))\n+\tCPP_PUTS_Q (pfile, argv[i], argl[i]);\n+      if (i < defn->nargs-1)\n+\tCPP_PUTS_Q (pfile, \", \", 2);\n+    }\n+  if (defn->rest_args)\n+    CPP_PUTS (pfile, \"...\", 3);\n+  CPP_PUTS (pfile, \") \", 2);\n \n-      i = defn->length - (x - defn->expansion) - 2;\n+  /* Now the definition. */\n+  x = defn->expansion;\n+  for (r = defn->pattern; r; r = r->next)\n+    {\n+      i = r->nchars;\n       if (*x == '\\r') x += 2, i -= 2;\n-      if (i > 0) CPP_PUTS (pfile, x, i);\n+      /* i chars for macro text, plus the length of the macro\n+\t argument name, plus one for a stringify marker, plus two for\n+\t each concatenation marker. */\n+      CPP_RESERVE (pfile,\n+\t\t   i + argl[r->argno] + r->stringify\n+\t\t   + (r->raw_before + r->raw_after) * 2);\n+\n+      if (i > 0) CPP_PUTS_Q (pfile, x, i);\n+      if (r->raw_before)\n+\tCPP_PUTS_Q (pfile, \"##\", 2);\n+      if (r->stringify)\n+\tCPP_PUTC_Q (pfile, '#');\n+      CPP_PUTS_Q (pfile, argv[r->argno], argl[r->argno]);\n+      if (r->raw_after && !(r->next && r->next->nchars == 0\n+\t\t\t    && r->next->raw_before))\n+\tCPP_PUTS_Q (pfile, \"##\", 2);\n+\n+      x += i;\n     }\n-  if (CPP_BUFFER (pfile) == 0 || ! pfile->done_initializing)\n-    CPP_PUTC (pfile, '\\n');\n+\n+  i = defn->length - (x - defn->expansion) - 2;\n+  if (*x == '\\r') x += 2, i -= 2;\n+  if (i > 0) CPP_PUTS (pfile, x, i);\n }\n \n /* Dump out the hash table.  */\n@@ -1687,7 +1899,7 @@ dump_hash_helper (h, p)\n   cpp_reader *pfile = (cpp_reader *)p;\n \n   if (hp->type == T_MACRO)\n-    _cpp_dump_definition (pfile, hp->name, hp->length, hp->value.defn);\n+    _cpp_dump_definition (pfile, hp);\n   return 1;\n }\n "}, {"sha": "78185f2001d37c1e5727a2e9b69ef9ddc86dfacb", "filename": "gcc/cpphash.h", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9e0bd53b2da36f66fcd18b168b354612ef7f4df/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9e0bd53b2da36f66fcd18b168b354612ef7f4df/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=d9e0bd53b2da36f66fcd18b168b354612ef7f4df", "patch": "@@ -64,9 +64,6 @@ struct definition\n   int nargs;\n   int length;\t\t\t/* length of expansion string */\n   U_CHAR *expansion;\n-  int line;\t\t\t/* Line number of definition */\n-  int col;\n-  const char *file;\t\t/* File of definition */\n   char rest_args;\t\t/* Nonzero if last arg. absorbs the rest */\n   struct reflist *pattern;\n \n@@ -86,6 +83,7 @@ struct definition\n /* different flavors of hash nodes */\n enum node_type\n {\n+  T_VOID = 0,\t   /* no definition yet */\n   T_SPECLINE,\t   /* `__LINE__' */\n   T_DATE,\t   /* `__DATE__' */\n   T_FILE,\t   /* `__FILE__' */\n@@ -94,10 +92,12 @@ enum node_type\n   T_TIME,\t   /* `__TIME__' */\n   T_STDC,\t   /* `__STDC__' */\n   T_CONST,\t   /* Constant string, used by `__SIZE_TYPE__' etc */\n-  T_MCONST,\t   /* Ditto, but the string is malloced memory */\n-  T_MACRO,\t   /* macro defined by `#define' */\n-  T_DISABLED,\t   /* macro temporarily turned off for rescan */\n-  T_POISON,\t   /* macro defined with `#pragma poison' */\n+  T_XCONST,\t   /* Ditto, but the string is malloced memory */\n+  T_POISON,\t   /* poisoned identifier */\n+  T_MCONST,\t   /* object-like macro defined to a single identifier */\n+  T_MACRO,\t   /* general object-like macro */\n+  T_FMACRO,\t   /* general function-like macro */\n+  T_IDENTITY,\t   /* macro defined to itself */\n   T_EMPTY\t   /* macro defined to nothing */\n };\n \n@@ -118,6 +118,11 @@ struct hashnode\n   unsigned long hash;\t\t/* cached hash value */\n   union hashval value;\t\t/* pointer to expansion, or whatever */\n   enum node_type type;\t\t/* type of special token */\n+  int disabled;\t\t\t/* macro turned off for rescan?  */\n+\n+  const char *file;\t\t/* File, line, column of definition; */\n+  int line;\n+  int col;\n };\n \n /* List of directories to look for include files in. */\n@@ -272,12 +277,9 @@ extern HASHNODE **_cpp_lookup_slot\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t enum insert_option,\n \t\t\t\t\t\t unsigned long *));\n extern void _cpp_free_definition\tPARAMS ((DEFINITION *));\n-extern DEFINITION *_cpp_create_definition PARAMS ((cpp_reader *,\n-\t\t\t\t\t\t   cpp_toklist *, int));\n-extern void _cpp_dump_definition\tPARAMS ((cpp_reader *, const U_CHAR *,\n-\t\t\t\t\t\t long, DEFINITION *));\n-extern int _cpp_compare_defs\t\tPARAMS ((cpp_reader *, DEFINITION *,\n-\t\t\t\t\t\t DEFINITION *));\n+extern int _cpp_create_definition\tPARAMS ((cpp_reader *,\n+\t\t\t\t\t\t cpp_toklist *, HASHNODE *));\n+extern void _cpp_dump_definition\tPARAMS ((cpp_reader *, HASHNODE *));\n extern void _cpp_quote_string\t\tPARAMS ((cpp_reader *, const char *));\n extern void _cpp_macroexpand\t\tPARAMS ((cpp_reader *, HASHNODE *));\n extern void _cpp_init_macro_hash\tPARAMS ((cpp_reader *));"}, {"sha": "957e6112fef874c49013ed5a6a1c0233db5c3f84", "filename": "gcc/cppinit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9e0bd53b2da36f66fcd18b168b354612ef7f4df/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9e0bd53b2da36f66fcd18b168b354612ef7f4df/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=d9e0bd53b2da36f66fcd18b168b354612ef7f4df", "patch": "@@ -635,7 +635,7 @@ static const struct builtin builtin_array[] =\n   { \"__LINE__\",\t\t\t0, T_SPECLINE,\t\t0 },\n   { \"__INCLUDE_LEVEL__\",\t0, T_INCLUDE_LEVEL,\t0 },\n \n-  { \"__VERSION__\",\t\t0,\t\t T_MCONST, DUMP|VERS },\n+  { \"__VERSION__\",\t\t0,\t\t T_XCONST, DUMP|VERS },\n   { \"__USER_LABEL_PREFIX__\",\t0,\t\t T_CONST,  DUMP|ULP  },\n   { \"__STDC__\",\t\t\t\"1\",\t\t T_STDC,   DUMP },\n   { \"__REGISTER_PREFIX__\",\tREGISTER_PREFIX, T_CONST,  DUMP },"}, {"sha": "f46b63892bb4728a25077afaf7813676d38a032b", "filename": "gcc/cpplex.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9e0bd53b2da36f66fcd18b168b354612ef7f4df/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9e0bd53b2da36f66fcd18b168b354612ef7f4df/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=d9e0bd53b2da36f66fcd18b168b354612ef7f4df", "patch": "@@ -1455,7 +1455,7 @@ maybe_macroexpand (pfile, written)\n \n   if (!hp)\n     return 0;\n-  if (hp->type == T_DISABLED)\n+  if (hp->disabled || hp->type == T_IDENTITY)\n     {\n       if (pfile->output_escapes)\n \t{\n@@ -1479,7 +1479,7 @@ maybe_macroexpand (pfile, written)\n     }\n \n   /* If macro wants an arglist, verify that a '(' follows.  */\n-  if (hp->type == T_MACRO && hp->value.defn->nargs >= 0)\n+  if (hp->type == T_FMACRO)\n     {\n       int macbuf_whitespace = 0;\n       int c;"}, {"sha": "5bb51623d3becad211fcac8160598ec09e580dd6", "filename": "gcc/cpplib.c", "status": "modified", "additions": 13, "deletions": 77, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9e0bd53b2da36f66fcd18b168b354612ef7f4df/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9e0bd53b2da36f66fcd18b168b354612ef7f4df/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=d9e0bd53b2da36f66fcd18b168b354612ef7f4df", "patch": "@@ -316,10 +316,8 @@ do_define (pfile)\n      cpp_reader *pfile;\n {\n   HASHNODE **slot;\n-  DEFINITION *def = 0;\n   unsigned long hash;\n   int len;\n-  int funlike = 0, empty = 0;\n   U_CHAR *sym;\n   cpp_toklist *list = &pfile->directbuf;\n \n@@ -350,90 +348,26 @@ do_define (pfile)\n       goto out;\n     }\n \n-\n-  if (list->tokens_used == 2 && list->tokens[1].type == CPP_VSPACE)\n-    empty = 1;  /* Empty definition of object-like macro.  */\n-\n-  /* If the next character, with no intervening whitespace, is '(',\n-     then this is a function-like macro.  Otherwise it is an object-\n-     like macro, and C99 requires whitespace after the name\n-     (6.10.3 para 3).  */\n-  else if (!(list->tokens[1].flags & HSPACE_BEFORE))\n-    {\n-      if (list->tokens[1].type == CPP_OPEN_PAREN)\n-\tfunlike = 1;\n-      else\n-\tcpp_pedwarn (pfile,\n-\t\t     \"The C standard requires whitespace after #define %.*s\",\n-\t\t     len, sym);\n-    }\n-\n-  if (! empty)\n-    {\n-      def = _cpp_create_definition (pfile, list, funlike);\n-      if (def == 0)\n-\tgoto out;\n-    }\n-\n   slot = _cpp_lookup_slot (pfile, sym, len, INSERT, &hash);\n   if (*slot)\n     {\n-      int ok;\n-      HASHNODE *hp = *slot;\n-\n-      /* Redefining a macro is ok if the definitions are the same.  */\n-      if (hp->type == T_MACRO)\n-\tok = ! empty && ! _cpp_compare_defs (pfile, def, hp->value.defn);\n-      else if (hp->type == T_EMPTY)\n-\tok = empty;\n-      /* Redefining a constant is ok with -D.  */\n-      else if (hp->type == T_CONST || hp->type == T_STDC)\n-        ok = ! pfile->done_initializing;\n-      /* Otherwise it's not ok.  */\n-      else\n-\tok = 0;\n-      /* Print the warning or error if it's not ok.  */\n-      if (! ok)\n+      /* Check for poisoned identifiers now.  All other checks\n+\t are done in cpphash.c.  */\n+      if ((*slot)->type == T_POISON)\n \t{\n-\t  if (hp->type == T_POISON)\n-\t    cpp_error (pfile, \"redefining poisoned `%.*s'\", len, sym);\n-\t  else\n-\t    cpp_pedwarn (pfile, \"`%.*s' redefined\", len, sym);\n-\t  if (hp->type == T_MACRO && pfile->done_initializing)\n-\t    {\n-\t      DEFINITION *d = hp->value.defn;\n-\t      cpp_pedwarn_with_file_and_line (pfile, d->file, d->line, d->col,\n-\t\t\t\"this is the location of the previous definition\");\n-\t    }\n-\t}\n-      if (hp->type != T_POISON)\n-\t{\n-\t  /* Replace the old definition.  */\n-\t  if (hp->type == T_MACRO)\n-\t    _cpp_free_definition (hp->value.defn);\n-\t  if (empty)\n-\t    {\n-\t      hp->type = T_EMPTY;\n-\t      hp->value.defn = 0;\n-\t    }\n-\t  else\n-\t    {\n-\t      hp->type = T_MACRO;\n-\t      hp->value.defn = def;\n-\t    }\n+\t  cpp_error (pfile, \"redefining poisoned `%.*s'\", len, sym);\n+\t  goto out;\n \t}\n     }\n   else\n-    {\n-      HASHNODE *hp = _cpp_make_hashnode (sym, len, empty ? T_EMPTY : T_MACRO,\n-\t\t\t\t\t hash);\n-      hp->value.defn = def;\n-      *slot = hp;\n-    }\n+    *slot = _cpp_make_hashnode (sym, len, T_VOID, hash);\n+    \n+  if (_cpp_create_definition (pfile, list, *slot) == 0)\n+    goto out;\n \n   if (CPP_OPTION (pfile, debug_output)\n       || CPP_OPTION (pfile, dump_macros) == dump_definitions)\n-    _cpp_dump_definition (pfile, sym, len, def);\n+    _cpp_dump_definition (pfile, *slot);\n   else if (CPP_OPTION (pfile, dump_macros) == dump_names)\n     pass_thru_directive (sym, len, pfile, T_DEFINE);\n \n@@ -769,7 +703,9 @@ do_undef (pfile)\n \t  if (CPP_OPTION (pfile, debug_output))\n \t    pass_thru_directive (hp->name, len, pfile, T_UNDEF);\n \n-\t  if (hp->type != T_MACRO && hp->type != T_EMPTY)\n+\t  if (hp->type != T_MACRO && hp->type != T_FMACRO\n+\t      && hp->type != T_MCONST\n+\t      && hp->type != T_EMPTY && hp->type != T_IDENTITY)\n \t    cpp_warning (pfile, \"undefining `%s'\", hp->name);\n \n \t  htab_clear_slot (pfile->hashtab, (void **)slot);"}]}