{"sha": "6b4b3deb4e4f5f7c8a5aab44b6907d006d78ac96", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI0YjNkZWI0ZTRmNWY3YzhhNWFhYjQ0YjY5MDdkMDA2ZDc4YWM5Ng==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-10-16T12:08:01Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-10-16T12:08:01Z"}, "message": "class.c (add_method): Fix documentation to reflect previous changes.\n\n\t* class.c (add_method): Fix documentation to reflect previous\n\tchanges.  Check for duplicate method declarations here.\n\t* decl.c (decls_match): Handle FUNCTION_DECL vs TEMPLATE_DECL\n\tcorrectly; such things never match.\n\t(grokfndecl): Don't look for duplicate methods here.\n\t* decl2.c (check_classfn): Don't assume names are mangled.\n\tDon't add bogus member function declarations to a class before the\n\tclass type is complete.\n\t(grokfield): Reformat error message.\n\t* method.c (set_mangled_name_for_decl): Don't mangle names while\n\tprocesing_template_decl.\n\nFrom-SVN: r23132", "tree": {"sha": "f1a18018ffc89c6255fe56cb63476779d58a8272", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1a18018ffc89c6255fe56cb63476779d58a8272"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b4b3deb4e4f5f7c8a5aab44b6907d006d78ac96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b4b3deb4e4f5f7c8a5aab44b6907d006d78ac96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b4b3deb4e4f5f7c8a5aab44b6907d006d78ac96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b4b3deb4e4f5f7c8a5aab44b6907d006d78ac96/comments", "author": null, "committer": null, "parents": [{"sha": "4c37d704290d58c6788acee45877199d6e7b0bb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c37d704290d58c6788acee45877199d6e7b0bb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c37d704290d58c6788acee45877199d6e7b0bb5"}], "stats": {"total": 231, "additions": 159, "deletions": 72}, "files": [{"sha": "50694eeab09510bfa77649769c2a68157cddb5e1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4b3deb4e4f5f7c8a5aab44b6907d006d78ac96/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4b3deb4e4f5f7c8a5aab44b6907d006d78ac96/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6b4b3deb4e4f5f7c8a5aab44b6907d006d78ac96", "patch": "@@ -1,3 +1,17 @@\n+1998-10-16  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* class.c (add_method): Fix documentation to reflect previous\n+\tchanges.  Check for duplicate method declarations here.\n+\t* decl.c (decls_match): Handle FUNCTION_DECL vs TEMPLATE_DECL\n+\tcorrectly; such things never match.\n+\t(grokfndecl): Don't look for duplicate methods here.\n+\t* decl2.c (check_classfn): Don't assume names are mangled.\n+\tDon't add bogus member function declarations to a class before the\n+\tclass type is complete.\n+\t(grokfield): Reformat error message.\n+\t* method.c (set_mangled_name_for_decl): Don't mangle names while\n+\tprocesing_template_decl.\n+\t\n 1998-10-16  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* typeck.c (build_indirect_ref): Complain about a pointer to data"}, {"sha": "2bc8f375e55e6c8f96a0f7ff8de99e1318f07bba", "filename": "gcc/cp/class.c", "status": "modified", "additions": 52, "deletions": 5, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4b3deb4e4f5f7c8a5aab44b6907d006d78ac96/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4b3deb4e4f5f7c8a5aab44b6907d006d78ac96/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=6b4b3deb4e4f5f7c8a5aab44b6907d006d78ac96", "patch": "@@ -1109,12 +1109,10 @@ free_method_vec (vec)\n   free_method_vecs = vec;\n }\n \n-/* Add method METHOD to class TYPE.  This is used when a method\n-   has been defined which did not initially appear in the class definition,\n-   and helps cut down on spurious error messages.\n+/* Add method METHOD to class TYPE.\n \n-   FIELDS is the entry in the METHOD_VEC vector entry of the class type where\n-   the method should be added.  */\n+   If non-NULL, FIELDS is the entry in the METHOD_VEC vector entry of\n+   the class type where the method should be added.  */\n \n void\n add_method (type, fields, method)\n@@ -1184,6 +1182,52 @@ add_method (type, fields, method)\n \t      len = 2 * len;\n \t      method_vec = CLASSTYPE_METHOD_VEC (type) = new_vec;\n \t    }\n+\t  else if (template_class_depth (type))\n+\t    /* TYPE is a template class.  Don't issue any errors now;\n+\t       wait until instantiation time to complain.  */\n+\t      ;\n+\t  else\n+\t    {\n+\t      tree fns;\n+\n+\t      /* Check to see if we've already got this method.  */\n+\t      for (fns = TREE_VEC_ELT (method_vec, i);\n+\t\t   fns;\n+\t\t   fns = OVL_NEXT (fns))\n+\t\t{\n+\t\t  tree fn = OVL_CURRENT (fns);\n+\t\t \n+\t\t  if (TREE_CODE (fn) != TREE_CODE (method))\n+\t\t    continue;\n+\n+\t\t  if (TREE_CODE (method) != TEMPLATE_DECL)\n+\t\t    {\n+\t\t      /* Since this is an ordinary function in a\n+\t\t\t non-template class, it's mangled name can be\n+\t\t\t used as a unique identifier.  This technique\n+\t\t\t is only an optimization; we would get the\n+\t\t\t same results if we just used decls_match\n+\t\t\t here.  */\n+\t\t      if (DECL_ASSEMBLER_NAME (fn) \n+\t\t\t  != DECL_ASSEMBLER_NAME (method))\n+\t\t\tcontinue;\n+\t\t    }\n+\t\t  else if (!decls_match (fn, method))\n+\t\t    continue;\n+\n+\t\t  /* There has already been a declaration of this\n+\t\t     method or member template.  */\n+\t\t  cp_error_at (\"`%D' has already been declared in `%T'\", \n+\t\t\t       method, type);\n+\n+\t\t  /* We don't call duplicate_decls here to merege the\n+\t\t     declarations because that will confuse things if\n+\t\t     the methods have inline definitions In\n+\t\t     particular, we will crash while processing the\n+\t\t     definitions.  */\n+\t\t  return;\n+\t\t}\n+\t    }\n \n \t  if (IDENTIFIER_TYPENAME_P (DECL_NAME (method)))\n \t    {\n@@ -1226,6 +1270,9 @@ add_method (type, fields, method)\n \t\t}\n \t    }\n \n+\t  /* Create RTL for the METHOD.  */\n+\t  make_decl_rtl (method, NULL_PTR, 1);\n+\n \t  /* Actually insert the new method.  */\n \t  TREE_VEC_ELT (method_vec, i) \n \t    = build_overload (method, TREE_VEC_ELT (method_vec, i));"}, {"sha": "f296fa2bbb4119fea0084707c60d8d0b09247115", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 7, "deletions": 51, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4b3deb4e4f5f7c8a5aab44b6907d006d78ac96/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4b3deb4e4f5f7c8a5aab44b6907d006d78ac96/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=6b4b3deb4e4f5f7c8a5aab44b6907d006d78ac96", "patch": "@@ -2511,8 +2511,12 @@ decls_match (newdecl, olddecl)\n {\n   int types_match;\n \n-  if (TREE_CODE (newdecl) == FUNCTION_DECL\n-      && TREE_CODE (olddecl) == FUNCTION_DECL)\n+  if (TREE_CODE (newdecl) != TREE_CODE (olddecl))\n+    /* If the two DECLs are not even the same kind of thing, we're not\n+       interested in their types.  */\n+    return 0;\n+\n+  if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n       tree f1 = TREE_TYPE (newdecl);\n       tree f2 = TREE_TYPE (olddecl);\n@@ -2568,8 +2572,7 @@ decls_match (newdecl, olddecl)\n       else\n \ttypes_match = 0;\n     }\n-  else if (TREE_CODE (newdecl) == TEMPLATE_DECL\n-\t   && TREE_CODE (olddecl) == TEMPLATE_DECL)\n+  else if (TREE_CODE (newdecl) == TEMPLATE_DECL)\n     {\n       if (!comp_template_parms (DECL_TEMPLATE_PARMS (newdecl),\n \t\t\t\tDECL_TEMPLATE_PARMS (olddecl)))\n@@ -8184,22 +8187,6 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \t}\n       if (! grok_ctor_properties (ctype, decl))\n \treturn error_mark_node;\n-\n-      if (check == 0 && ! current_function_decl)\n-\t{\n-\t  /* Assembler names live in the global namespace. */\n-\t  tmp = IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (decl));\n-\t  if (tmp == NULL_TREE)\n-\t    SET_IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (decl), decl);\n-\t  else if (TREE_CODE (tmp) != TREE_CODE (decl))\n-\t    cp_error (\"inconsistent declarations for `%D'\", decl);\n-\t  else\n-\t    {\n-\t      duplicate_decls (decl, tmp);\n-\t      decl = tmp;\n-\t    }\n-\t  make_decl_rtl (decl, NULL_PTR, 1);\n-\t}\n     }\n   else\n     {\n@@ -8248,37 +8235,6 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n       if (ctype == NULL_TREE || check)\n \treturn decl;\n \n-      /* Now install the declaration of this function so that others may\n-\t find it (esp. its DECL_FRIENDLIST).  Don't do this for local class\n-\t methods, though.  */\n-      if (! current_function_decl)\n-\t{\n-\t  if (!DECL_TEMPLATE_SPECIALIZATION (decl))\n-\t    {\n-\t      /* We don't do this for specializations since the\n-\t\t equivalent checks will be done later.  Also, at this\n-\t\t point the DECL_ASSEMBLER_NAME is not yet fully\n-\t\t accurate.  */\n-\n-\t      /* FIXME: this should only need to look at\n-\t\t IDENTIFIER_GLOBAL_VALUE.  */\n-\t      tmp = lookup_name (DECL_ASSEMBLER_NAME (decl), 0);\n-\t      if (tmp == NULL_TREE)\n-\t\tSET_IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (decl), decl);\n-\t      else if (TREE_CODE (tmp) != TREE_CODE (decl))\n-\t\tcp_error (\"inconsistent declarations for `%D'\", decl);\n-\t      else\n-\t\t{\n-\t\t  duplicate_decls (decl, tmp);\n-\t\t  decl = tmp;\n-\t\t}\n-\t    }\n-\n-\t  if (attrlist)\n-\t    cplus_decl_attributes (decl, TREE_PURPOSE (attrlist),\n-\t\t\t\t   TREE_VALUE (attrlist));\n-\t  make_decl_rtl (decl, NULL_PTR, 1);\n-\t}\n       if (virtualp)\n \t{\n \t  DECL_VIRTUAL_P (decl) = 1;"}, {"sha": "f20d6f2743f8ccd2020e4514b81768d7d8141995", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4b3deb4e4f5f7c8a5aab44b6907d006d78ac96/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4b3deb4e4f5f7c8a5aab44b6907d006d78ac96/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=6b4b3deb4e4f5f7c8a5aab44b6907d006d78ac96", "patch": "@@ -1383,14 +1383,19 @@ check_classfn (ctype, function)\n \t\t   fndecls = OVL_NEXT (fndecls))\n \t\t{\n \t\t  fndecl = OVL_CURRENT (fndecls);\n-\t\t  /* The DECL_ASSEMBLER_NAME for a TEMPLATE_DECL is\n+\t\t  /* The DECL_ASSEMBLER_NAME for a TEMPLATE_DECL, or\n+\t\t     for a for member function of a template class, is\n \t\t     not mangled, so the check below does not work\n-\t\t     correctly in that case.  Since mangled destructor names\n-\t\t     do not include the type of the arguments, we\n-\t\t     can't use this short-cut for them, either.  */\n-\t\t  if (TREE_CODE (function) != TEMPLATE_DECL\n-\t\t      && TREE_CODE (fndecl) != TEMPLATE_DECL\n-\t\t      && !DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (function))\n+\t\t     correctly in that case.  Since mangled destructor\n+\t\t     names do not include the type of the arguments,\n+\t\t     we can't use this short-cut for them, either.\n+\t\t     (It's not legal to declare arguments for a\n+\t\t     destructor, but some people try.)  */\n+\t\t  if (!DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (function))\n+\t\t      && (DECL_ASSEMBLER_NAME (function)\n+\t\t\t  != DECL_NAME (function))\n+\t\t      && (DECL_ASSEMBLER_NAME (fndecl)\n+\t\t\t  != DECL_NAME (fndecl))\n \t\t      && (DECL_ASSEMBLER_NAME (function) \n \t\t\t  == DECL_ASSEMBLER_NAME (fndecl)))\n \t\t    return fndecl;\n@@ -1467,8 +1472,11 @@ check_classfn (ctype, function)\n     }\n \n   /* If we did not find the method in the class, add it to avoid\n-     spurious errors.  */\n-  add_method (ctype, methods, function);\n+     spurious errors (unless the CTYPE is not yet defined, in which\n+     case we'll only confuse ourselves when the function is declared\n+     properly within the class.  */\n+  if (TYPE_SIZE (ctype))\n+    add_method (ctype, methods, function);\n   return NULL_TREE;\n }\n \n@@ -1573,8 +1581,8 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n \n   if (DECL_IN_AGGR_P (value))\n     {\n-      cp_error (\"`%D' is already defined in the class %T\", value,\n-\t\t  DECL_CONTEXT (value));\n+      cp_error (\"`%D' is already defined in `%T'\", value,\n+\t\tDECL_CONTEXT (value));\n       return void_type_node;\n     }\n "}, {"sha": "400aead4d46f4f0beeeb2dbcc8d9b74169914b97", "filename": "gcc/cp/method.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4b3deb4e4f5f7c8a5aab44b6907d006d78ac96/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4b3deb4e4f5f7c8a5aab44b6907d006d78ac96/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=6b4b3deb4e4f5f7c8a5aab44b6907d006d78ac96", "patch": "@@ -1662,7 +1662,13 @@ void\n set_mangled_name_for_decl (decl)\n      tree decl;\n {\n-  tree parm_types = TYPE_ARG_TYPES (TREE_TYPE (decl));\n+  tree parm_types;\n+\n+  if (processing_template_decl)\n+    /* There's no need to mangle the name of a template function.  */\n+    return;\n+\n+  parm_types = TYPE_ARG_TYPES (TREE_TYPE (decl));\n \n   if (DECL_STATIC_FUNCTION_P (decl))\n     parm_types = "}, {"sha": "e63d43cbec9cf60438708506a100d87119f385d3", "filename": "gcc/testsuite/g++.old-deja/g++.benjamin/warn02.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4b3deb4e4f5f7c8a5aab44b6907d006d78ac96/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Fwarn02.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4b3deb4e4f5f7c8a5aab44b6907d006d78ac96/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Fwarn02.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Fwarn02.C?ref=6b4b3deb4e4f5f7c8a5aab44b6907d006d78ac96", "patch": "@@ -31,16 +31,16 @@ class C\n class D\n {\n public:\n-  int foo2() {return b;}  // WARNING - \n-  int foo2() {return b;}  // WARNING - \n+  int foo2() {return b;}  \n+  int foo2() {return b;}  // ERROR - \n   int b;\n };\n \n class E\n {\n public:\n-  int foo2(); // WARNING - \n-  int foo2(); // WARNING - \n+  int foo2(); \n+  int foo2(); // ERROR - \n   int b;\n };\n "}, {"sha": "945e7ff68f0a316c8f3f0d5893a4502045266e74", "filename": "gcc/testsuite/g++.old-deja/g++.pt/memtemp78.C", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b4b3deb4e4f5f7c8a5aab44b6907d006d78ac96/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp78.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b4b3deb4e4f5f7c8a5aab44b6907d006d78ac96/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp78.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp78.C?ref=6b4b3deb4e4f5f7c8a5aab44b6907d006d78ac96", "patch": "@@ -0,0 +1,56 @@\n+// Build don't link:\n+\n+struct A \n+{\n+  void f() {}\n+\n+  template <class U>\n+  void f() {}\n+};\n+\n+\n+template <class T>\n+struct B\n+{\n+  void f() {}\n+\n+  template <class U>\n+  void f() {}\n+};\n+\n+template struct B<int>;\n+\n+struct C \n+{\n+  template <class U>\n+  void f() {}\n+\n+  template <class U>\n+  void f() {}  // ERROR - redeclaration\n+};\n+\n+\n+template <class T, class U>\n+struct D\n+{\n+  void f(T);\n+  void f(U);\n+};\n+\n+template struct D<int, double>;\n+\n+template <class T, class U>\n+struct D2\n+{\n+  void f(T);\n+  void f(U); // ERROR - redeclaration \n+};\n+\n+template struct D2<int, int>; \n+\n+struct E\n+{\n+  void f(); \n+  void f(); // ERROR - redeclaration\n+};\n+"}]}