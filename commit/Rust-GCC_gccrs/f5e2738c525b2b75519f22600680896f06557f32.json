{"sha": "f5e2738c525b2b75519f22600680896f06557f32", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjVlMjczOGM1MjViMmI3NTUxOWYyMjYwMDY4MDg5NmYwNjU1N2YzMg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2005-02-10T19:02:44Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2005-02-10T19:02:44Z"}, "message": "tree-ssa-loop-ivopts.c (determine_base_object): Ignore casts.\n\n\t* tree-ssa-loop-ivopts.c (determine_base_object): Ignore casts.\n\t(strip_offset): Handle addresses.\n\t(add_address_candidates): Use strip_offset.\n\t(difference_cost): Reflect strip_offset change.\n\t(force_var_cost, difference_cost): Strip nops.\n\nFrom-SVN: r94841", "tree": {"sha": "3c04bbc74253a526d44f96e31974f31bca57af9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c04bbc74253a526d44f96e31974f31bca57af9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5e2738c525b2b75519f22600680896f06557f32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5e2738c525b2b75519f22600680896f06557f32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5e2738c525b2b75519f22600680896f06557f32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5e2738c525b2b75519f22600680896f06557f32/comments", "author": null, "committer": null, "parents": [{"sha": "c486021de8b230d9b45ec1c6d70f7b149dbda2cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c486021de8b230d9b45ec1c6d70f7b149dbda2cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c486021de8b230d9b45ec1c6d70f7b149dbda2cb"}], "stats": {"total": 203, "additions": 129, "deletions": 74}, "files": [{"sha": "d3814a2c3f8d66375f7b38b31318c07139ce3eda", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e2738c525b2b75519f22600680896f06557f32/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e2738c525b2b75519f22600680896f06557f32/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f5e2738c525b2b75519f22600680896f06557f32", "patch": "@@ -1,3 +1,11 @@\n+2005-02-10  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-ssa-loop-ivopts.c (determine_base_object): Ignore casts.\n+\t(strip_offset): Handle addresses.\n+\t(add_address_candidates): Use strip_offset.\n+\t(difference_cost): Reflect strip_offset change.\n+\t(force_var_cost, difference_cost): Strip nops.\n+\n 2005-02-10  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* df.h (DF_REF_MODE_CHANGE, DF_REF_MEM_OK): Remove."}, {"sha": "a570569d02b35af202c5c3fd59cd8cbdb5a4e735", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 121, "deletions": 74, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e2738c525b2b75519f22600680896f06557f32/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e2738c525b2b75519f22600680896f06557f32/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=f5e2738c525b2b75519f22600680896f06557f32", "patch": "@@ -766,10 +766,10 @@ determine_base_object (tree expr)\n       base = get_base_address (obj);\n \n       if (!base)\n-\treturn fold_convert (ptr_type_node, expr);\n+\treturn expr;\n \n       if (TREE_CODE (base) == INDIRECT_REF)\n-\treturn fold_convert (ptr_type_node, TREE_OPERAND (base, 0));\n+\treturn determine_base_object (TREE_OPERAND (base, 0));\n \n       return fold (build1 (ADDR_EXPR, ptr_type_node, base));\n \n@@ -788,6 +788,10 @@ determine_base_object (tree expr)\n \n       return fold (build (code, ptr_type_node, op0, op1));\n \n+    case NOP_EXPR:\n+    case CONVERT_EXPR:\n+      return determine_base_object (TREE_OPERAND (expr, 0));\n+\n     default:\n       return fold_convert (ptr_type_node, expr);\n     }\n@@ -1737,6 +1741,105 @@ find_interesting_uses (struct ivopts_data *data)\n   free (body);\n }\n \n+/* Strips constant offsets from EXPR and stores them to OFFSET.  If INSIDE_ADDR\n+   is true, assume we are inside an address.  */\n+\n+static tree\n+strip_offset (tree expr, bool inside_addr, unsigned HOST_WIDE_INT *offset)\n+{\n+  tree op0 = NULL_TREE, op1 = NULL_TREE, step;\n+  enum tree_code code;\n+  tree type, orig_type = TREE_TYPE (expr);\n+  unsigned HOST_WIDE_INT off0, off1, st;\n+  tree orig_expr = expr;\n+\n+  STRIP_NOPS (expr);\n+  type = TREE_TYPE (expr);\n+  code = TREE_CODE (expr);\n+  *offset = 0;\n+\n+  switch (code)\n+    {\n+    case INTEGER_CST:\n+      if (!cst_and_fits_in_hwi (expr)\n+\t  || zero_p (expr))\n+\treturn orig_expr;\n+\n+      *offset = int_cst_value (expr);\n+      return build_int_cst_type (orig_type, 0);\n+\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+      op0 = TREE_OPERAND (expr, 0);\n+      op1 = TREE_OPERAND (expr, 1);\n+\n+      op0 = strip_offset (op0, false, &off0);\n+      op1 = strip_offset (op1, false, &off1);\n+\n+      *offset = (code == PLUS_EXPR ? off0 + off1 : off0 - off1);\n+      if (op0 == TREE_OPERAND (expr, 0)\n+\t  && op1 == TREE_OPERAND (expr, 1))\n+\treturn orig_expr;\n+\n+      if (zero_p (op1))\n+\texpr = op0;\n+      else if (zero_p (op0))\n+\t{\n+\t  if (code == PLUS_EXPR)\n+\t    expr = op1;\n+\t  else\n+\t    expr = build1 (NEGATE_EXPR, type, op1);\n+\t}\n+      else\n+\texpr = build2 (code, type, op0, op1);\n+\n+      return fold_convert (orig_type, expr);\n+\n+    case ARRAY_REF:\n+      if (!inside_addr)\n+\treturn orig_expr;\n+\n+      step = array_ref_element_size (expr);\n+      if (!cst_and_fits_in_hwi (step))\n+\tbreak;\n+\n+      st = int_cst_value (step);\n+      op1 = TREE_OPERAND (expr, 1);\n+      op1 = strip_offset (op1, false, &off1);\n+      *offset = off1 * st;\n+      break;\n+\n+    case COMPONENT_REF:\n+      if (!inside_addr)\n+\treturn orig_expr;\n+      break;\n+\n+    case ADDR_EXPR:\n+      inside_addr = true;\n+      break;\n+\n+    default:\n+      return orig_expr;\n+    }\n+\n+  /* Default handling of expressions for that we want to recurse into\n+     the first operand.  */\n+  op0 = TREE_OPERAND (expr, 0);\n+  op0 = strip_offset (op0, inside_addr, &off0);\n+  *offset += off0;\n+\n+  if (op0 == TREE_OPERAND (expr, 0)\n+      && (!op1 || op1 == TREE_OPERAND (expr, 1)))\n+    return orig_expr;\n+\n+  expr = copy_node (expr);\n+  TREE_OPERAND (expr, 0) = op0;\n+  if (op1)\n+    TREE_OPERAND (expr, 1) = op1;\n+\n+  return fold_convert (orig_type, expr);\n+}\n+\n /* Adds a candidate BASE + STEP * i.  Important field is set to IMPORTANT and\n    position to POS.  If USE is not NULL, the candidate is set as related to\n    it.  If both BASE and STEP are NULL, we add a pseudocandidate for the\n@@ -1962,7 +2065,8 @@ static void\n add_address_candidates (struct ivopts_data *data,\n \t\t\tstruct iv *iv, struct iv_use *use)\n {\n-  tree base, abase, tmp, *act;\n+  tree base, abase;\n+  unsigned HOST_WIDE_INT offset;\n \n   /* First, the trivial choices.  */\n   add_iv_value_candidates (data, iv, use);\n@@ -1991,26 +2095,9 @@ add_address_candidates (struct ivopts_data *data,\n \n   /* Third, try removing the constant offset.  */\n   abase = iv->base;\n-  while (TREE_CODE (abase) == PLUS_EXPR\n-\t && TREE_CODE (TREE_OPERAND (abase, 1)) != INTEGER_CST)\n-    abase = TREE_OPERAND (abase, 0);\n-  /* We found the offset, so make the copy of the non-shared part and\n-     remove it.  */\n-  if (TREE_CODE (abase) == PLUS_EXPR)\n-    {\n-      tmp = iv->base;\n-      act = &base;\n-\n-      for (tmp = iv->base; tmp != abase; tmp = TREE_OPERAND (tmp, 0))\n-\t{\n-\t  *act = build2 (PLUS_EXPR, TREE_TYPE (tmp),\n-\t\t\t NULL_TREE, TREE_OPERAND (tmp, 1));\n-\t  act = &TREE_OPERAND (*act, 0);\n-\t}\n-      *act = TREE_OPERAND (tmp, 0);\n-\n-      add_candidate (data, base, iv->step, false, use);\n-    }\n+  base = strip_offset (abase, false, &offset);\n+  if (offset)\n+    add_candidate (data, base, iv->step, false, use);\n }\n \n /* Possibly adds pseudocandidate for replacing the final value of USE by\n@@ -2472,53 +2559,6 @@ get_computation (struct loop *loop, struct iv_use *use, struct iv_cand *cand)\n   return get_computation_at (loop, use, cand, use->stmt);\n }\n \n-/* Strips constant offsets from EXPR and adds them to OFFSET.  */\n-\n-static void\n-strip_offset (tree *expr, unsigned HOST_WIDE_INT *offset)\n-{\n-  tree op0, op1;\n-  enum tree_code code;\n-  \n-  while (1)\n-    {\n-      if (cst_and_fits_in_hwi (*expr))\n-\t{\n-\t  *offset += int_cst_value (*expr);\n-\t  *expr = integer_zero_node;\n-\t  return;\n-\t}\n-\n-      code = TREE_CODE (*expr);\n-     \n-      if (code != PLUS_EXPR && code != MINUS_EXPR)\n-\treturn;\n-\n-      op0 = TREE_OPERAND (*expr, 0);\n-      op1 = TREE_OPERAND (*expr, 1);\n-\n-      if (cst_and_fits_in_hwi (op1))\n-\t{\n-\t  if (code == PLUS_EXPR)\n-\t    *offset += int_cst_value (op1);\n-\t  else\n-\t    *offset -= int_cst_value (op1);\n-\n-\t  *expr = op0;\n-\t  continue;\n-\t}\n-\n-      if (code != PLUS_EXPR)\n-\treturn;\n-\n-      if (!cst_and_fits_in_hwi (op0))\n-\treturn;\n-\n-      *offset += int_cst_value (op0);\n-      *expr = op1;\n-    }\n-}\n-\n /* Returns cost of addition in MODE.  */\n \n static unsigned\n@@ -2841,6 +2881,8 @@ force_var_cost (struct ivopts_data *data,\n       costs_initialized = true;\n     }\n \n+  STRIP_NOPS (expr);\n+\n   if (depends_on)\n     {\n       fd_ivopts_data = data;\n@@ -2875,6 +2917,8 @@ force_var_cost (struct ivopts_data *data,\n     case MULT_EXPR:\n       op0 = TREE_OPERAND (expr, 0);\n       op1 = TREE_OPERAND (expr, 1);\n+      STRIP_NOPS (op0);\n+      STRIP_NOPS (op1);\n \n       if (is_gimple_val (op0))\n \tcost0 = 0;\n@@ -3020,11 +3064,14 @@ difference_cost (struct ivopts_data *data,\n {\n   unsigned cost;\n   enum machine_mode mode = TYPE_MODE (TREE_TYPE (e1));\n+  unsigned HOST_WIDE_INT off1, off2;\n+\n+  e1 = strip_offset (e1, false, &off1);\n+  e2 = strip_offset (e2, false, &off2);\n+  *offset += off1 - off2;\n \n-  strip_offset (&e1, offset);\n-  *offset = -*offset;\n-  strip_offset (&e2, offset);\n-  *offset = -*offset;\n+  STRIP_NOPS (e1);\n+  STRIP_NOPS (e2);\n \n   if (TREE_CODE (e1) == ADDR_EXPR)\n     return ptr_difference_cost (data, e1, e2, symbol_present, var_present, offset,"}]}