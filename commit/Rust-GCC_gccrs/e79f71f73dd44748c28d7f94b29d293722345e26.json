{"sha": "e79f71f73dd44748c28d7f94b29d293722345e26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTc5ZjcxZjczZGQ0NDc0OGMyOGQ3Zjk0YjI5ZDI5MzcyMjM0NWUyNg==", "commit": {"author": {"name": "Geoff Keating", "email": "geoffk@cygnus.com", "date": "2000-05-28T05:51:16Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2000-05-28T05:51:16Z"}, "message": "rs6000.md (movsi): Constify 'name'.\n\n* config/rs6000/rs6000.md (movsi): Constify 'name'.\n\n* regclass.c [CLASS_CANNOT_CHANGE_SIZE]\n(class_can_change_size): New variable.\n(reg_changes_size): New variable.\n(init_reg_sets_1): Initialise class_can_change_size.\n(record_operand_costs): Remove subreg_changes_size.\nDon't pass it around.  Instead update reg_changes_size.\n(regclass): Initialise and free reg_changes_size.  If a register\nchanges size, don't preference it to a class that contains\nregisters that can't change size.\n(record_reg_classes): Don't look at subreg_changes_size.\n\nFrom-SVN: r34227", "tree": {"sha": "1c9decc7cdb4e93db21ebbe565bef611bdb9a2bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c9decc7cdb4e93db21ebbe565bef611bdb9a2bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e79f71f73dd44748c28d7f94b29d293722345e26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e79f71f73dd44748c28d7f94b29d293722345e26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e79f71f73dd44748c28d7f94b29d293722345e26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e79f71f73dd44748c28d7f94b29d293722345e26/comments", "author": null, "committer": null, "parents": [{"sha": "d2b51b106a2c3a176255baf6f0cb3cec57fa9c6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2b51b106a2c3a176255baf6f0cb3cec57fa9c6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2b51b106a2c3a176255baf6f0cb3cec57fa9c6b"}], "stats": {"total": 101, "additions": 74, "deletions": 27}, "files": [{"sha": "030667df9f4e07f3653ee2c98704a9b271673ad0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79f71f73dd44748c28d7f94b29d293722345e26/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79f71f73dd44748c28d7f94b29d293722345e26/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e79f71f73dd44748c28d7f94b29d293722345e26", "patch": "@@ -1,3 +1,18 @@\n+2000-05-27  Geoffrey Keating  <geoffk@cygnus.com>\n+\n+\t* config/rs6000/rs6000.md (movsi): Constify 'name'.\n+\n+\t* regclass.c [CLASS_CANNOT_CHANGE_SIZE]\n+\t(class_can_change_size): New variable.\n+\t(reg_changes_size): New variable.\n+\t(init_reg_sets_1): Initialise class_can_change_size.\n+\t(record_operand_costs): Remove subreg_changes_size.\n+\tDon't pass it around.  Instead update reg_changes_size.\n+\t(regclass): Initialise and free reg_changes_size.  If a register\n+\tchanges size, don't preference it to a class that contains\n+\tregisters that can't change size.\n+\t(record_reg_classes): Don't look at subreg_changes_size.\n+\n 2000-05-27  Richard Henderson  <rth@cygnus.com>\n \n \t* print-rtl.c (reg_names): Remove const."}, {"sha": "3b406f65fe5c9ca3b9a6218fd6a1890ad08cf50f", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79f71f73dd44748c28d7f94b29d293722345e26/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79f71f73dd44748c28d7f94b29d293722345e26/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=e79f71f73dd44748c28d7f94b29d293722345e26", "patch": "@@ -7481,7 +7481,7 @@\n \t  && GET_CODE (operands[1]) == SYMBOL_REF\n \t  && XSTR (operands[1], 0)[0] == '.')\n \t{\n-\t  char *name = XSTR (operands[1], 0);\n+\t  const char *name = XSTR (operands[1], 0);\n \t  rtx new_ref;\n \t  while (*name == '.')\n \t    name++;"}, {"sha": "6a741a64b4b6e0280b7b0aad99627088a15297ea", "filename": "gcc/regclass.c", "status": "modified", "additions": 58, "deletions": 26, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79f71f73dd44748c28d7f94b29d293722345e26/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79f71f73dd44748c28d7f94b29d293722345e26/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=e79f71f73dd44748c28d7f94b29d293722345e26", "patch": "@@ -203,6 +203,19 @@ static char *in_inc_dec;\n \n #endif /* FORBIDDEN_INC_DEC_CLASSES */\n \n+#ifdef CLASS_CANNOT_CHANGE_SIZE\n+\n+/* These are the classes containing only registers that can be used in\n+   a SUBREG expression that changes the size of the register.  */\n+\n+static int class_can_change_size[N_REG_CLASSES];\n+\n+/* Registers, including pseudos, which change size.  */\n+\n+static regset reg_changes_size;\n+\n+#endif /* CLASS_CANNOT_CHANGE_SIZE */\n+\n #ifdef HAVE_SECONDARY_RELOADS\n \n /* Sample MEM values for use by memory_move_secondary_cost.  */\n@@ -444,6 +457,22 @@ init_reg_sets_1 ()\n \telse\n \t  may_move_out_cost[i][j] = cost;\n       }\n+\n+#ifdef CLASS_CANNOT_CHANGE_SIZE\n+  {\n+    HARD_REG_SET c;\n+    COMPL_HARD_REG_SET (c, reg_class_contents[CLASS_CANNOT_CHANGE_SIZE]);\n+      \n+    for (i = 0; i < N_REG_CLASSES; i++)\n+      {\n+\tGO_IF_HARD_REG_SUBSET (reg_class_contents[i], c, ok_class);\n+\tclass_can_change_size [i] = 0;\n+\tcontinue;\n+      ok_class:\n+\tclass_can_change_size [i] = 1;\n+      }\n+    }\n+#endif /* CLASS_CANNOT_CHANGE_SIZE */\n }\n \n /* Compute the table of register modes.\n@@ -725,7 +754,7 @@ static rtx scan_one_insn\tPARAMS ((rtx, int));\n static void record_operand_costs PARAMS ((rtx, struct costs *, struct reg_pref *));\n static void dump_regclass\tPARAMS ((FILE *));\n static void record_reg_classes\tPARAMS ((int, int, rtx *, enum machine_mode *,\n-\t\t\t\t       char *, const char **, rtx,\n+\t\t\t\t       const char **, rtx,\n \t\t\t\t       struct costs *, struct reg_pref *));\n static int copy_cost\t\tPARAMS ((rtx, enum machine_mode, \n \t\t\t\t       enum reg_class, int));\n@@ -809,15 +838,13 @@ record_operand_costs (insn, op_costs, reg_pref)\n {\n   const char *constraints[MAX_RECOG_OPERANDS];\n   enum machine_mode modes[MAX_RECOG_OPERANDS];\n-  char subreg_changes_size[MAX_RECOG_OPERANDS];\n   int i;\n \n   for (i = 0; i < recog_data.n_operands; i++)\n     {\n       constraints[i] = recog_data.constraints[i];\n       modes[i] = recog_data.operand_mode[i];\n     }\n-  memset (subreg_changes_size, 0, sizeof (subreg_changes_size));\n \n   /* If we get here, we are set up to record the costs of all the\n      operands for this insn.  Start by initializing the costs.\n@@ -832,8 +859,9 @@ record_operand_costs (insn, op_costs, reg_pref)\n       if (GET_CODE (recog_data.operand[i]) == SUBREG)\n \t{\n \t  rtx inner = SUBREG_REG (recog_data.operand[i]);\n-\t  if (GET_MODE_SIZE (modes[i]) != GET_MODE_SIZE (GET_MODE (inner)))\n-\t    subreg_changes_size[i] = 1;\n+\t  if (GET_MODE_SIZE (modes[i]) != GET_MODE_SIZE (GET_MODE (inner))\n+\t      && GET_CODE (inner) == REG)\n+\t    SET_REGNO_REG_SET (reg_changes_size, REGNO (inner));\n \t  recog_data.operand[i] = inner;\n \t}\n \n@@ -864,12 +892,12 @@ record_operand_costs (insn, op_costs, reg_pref)\n \txconstraints[i] = constraints[i+1];\n \txconstraints[i+1] = constraints[i];\n \trecord_reg_classes (recog_data.n_alternatives, recog_data.n_operands,\n-\t\t\t    recog_data.operand, modes, subreg_changes_size,\n+\t\t\t    recog_data.operand, modes, \n \t\t\t    xconstraints, insn, op_costs, reg_pref);\n       }\n \n   record_reg_classes (recog_data.n_alternatives, recog_data.n_operands,\n-\t\t      recog_data.operand, modes, subreg_changes_size,\n+\t\t      recog_data.operand, modes, \n \t\t      constraints, insn, op_costs, reg_pref);\n }\n \f\n@@ -1017,6 +1045,10 @@ regclass (f, nregs, dump)\n \n   costs = (struct costs *) xmalloc (nregs * sizeof (struct costs));\n \n+#ifdef CLASS_CANNOT_CHANGE_SIZE\n+  reg_changes_size = BITMAP_XMALLOC();\n+#endif  \n+\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n \n   in_inc_dec = (char *) xmalloc (nregs);\n@@ -1154,6 +1186,10 @@ regclass (f, nregs, dump)\n \t\t  > reg_class_size[class]\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n \t\t  || (in_inc_dec[i] && forbidden_inc_dec_class[class])\n+#endif\n+#ifdef CLASS_CANNOT_CHANGE_SIZE\n+\t\t  || (REGNO_REG_SET_P (reg_changes_size, i)\n+\t\t      && ! class_can_change_size [class])\n #endif\n \t\t  )\n \t\t;\n@@ -1180,6 +1216,10 @@ regclass (f, nregs, dump)\n \t\t      > reg_class_size[(int) alt])\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n \t\t  && ! (in_inc_dec[i] && forbidden_inc_dec_class[class])\n+#endif\n+#ifdef CLASS_CANNOT_CHANGE_SIZE\n+\t\t  && ! (REGNO_REG_SET_P (reg_changes_size, i)\n+\t\t\t&& ! class_can_change_size [class])\n #endif\n \t\t  )\n \t\talt = reg_class_subunion[(int) alt][class];\n@@ -1212,6 +1252,9 @@ regclass (f, nregs, dump)\n \n #ifdef FORBIDDEN_INC_DEC_CLASSES\n   free (in_inc_dec);\n+#endif\n+#ifdef CLASS_CANNOT_CHANGE_SIZE\n+  BITMAP_XFREE (reg_changes_size);\n #endif\n   free (costs);\n }\n@@ -1241,13 +1284,12 @@ regclass (f, nregs, dump)\n    alternatives.  */\n \n static void\n-record_reg_classes (n_alts, n_ops, ops, modes, subreg_changes_size,\n+record_reg_classes (n_alts, n_ops, ops, modes,\n \t\t    constraints, insn, op_costs, reg_pref)\n      int n_alts;\n      int n_ops;\n      rtx *ops;\n      enum machine_mode *modes;\n-     char *subreg_changes_size ATTRIBUTE_UNUSED;\n      const char **constraints;\n      rtx insn;\n      struct costs *op_costs;\n@@ -1545,16 +1587,6 @@ record_reg_classes (n_alts, n_ops, ops, modes, subreg_changes_size,\n \n \t  constraints[i] = p;\n \n-#ifdef CLASS_CANNOT_CHANGE_SIZE\n-\t  /* If we noted a subreg earlier, and the selected class is a \n-\t     subclass of CLASS_CANNOT_CHANGE_SIZE, zap it.  */\n-\t  if (subreg_changes_size[i]\n-\t      && (reg_class_subunion[(int) CLASS_CANNOT_CHANGE_SIZE]\n-\t\t\t\t    [(int) classes[i]]\n-\t\t  == CLASS_CANNOT_CHANGE_SIZE))\n-\t    classes[i] = NO_REGS;\n-#endif\n-\n \t  /* How we account for this operand now depends on whether it is  a\n \t     pseudo register or not.  If it is, we first check if any\n \t     register classes are valid.  If not, we ignore this alternative,\n@@ -1566,13 +1598,13 @@ record_reg_classes (n_alts, n_ops, ops, modes, subreg_changes_size,\n \t    {\n \t      if (classes[i] == NO_REGS)\n \t\t{\n-\t\t    /* We must always fail if the operand is a REG, but\n-\t\t       we did not find a suitable class.\n-\n-\t\t       Otherwise we may perform an uninitialized read\n-\t\t       from this_op_costs after the `continue' statement\n-\t\t       below.  */\n-\t\t    alt_fail = 1;\n+\t\t  /* We must always fail if the operand is a REG, but\n+\t\t     we did not find a suitable class.\n+\t\t     \n+\t\t     Otherwise we may perform an uninitialized read\n+\t\t     from this_op_costs after the `continue' statement\n+\t\t     below.  */\n+\t\t  alt_fail = 1;\n \t\t}\n \t      else\n \t\t{"}]}