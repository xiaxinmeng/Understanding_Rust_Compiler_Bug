{"sha": "f000c6a763acc0ba0184c5634f2feb3ea883992c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjAwMGM2YTc2M2FjYzBiYTAxODRjNTYzNGYyZmViM2VhODgzOTkyYw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-02-03T20:42:48Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-02-03T20:42:48Z"}, "message": "re PR c++/4926 (C++ ABI needs clarification on mangling of complex expressions)\n\n\tPR c++/4926\n\tPR c++/38600\n\t* mangle.c (write_unqualified_id): Split out from write_expression.\n\t(write_unqualified_name): Call it.\n\t(write_member_name): Likewise.\n\t(write_expression): Support TEMPLATE_ID_EXPR.\n\tDisambiguate operator names.\n\nFrom-SVN: r156482", "tree": {"sha": "85f758f12214e67f5aac6efe669abcdc7aa570c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85f758f12214e67f5aac6efe669abcdc7aa570c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f000c6a763acc0ba0184c5634f2feb3ea883992c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f000c6a763acc0ba0184c5634f2feb3ea883992c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f000c6a763acc0ba0184c5634f2feb3ea883992c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f000c6a763acc0ba0184c5634f2feb3ea883992c/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "abfe01cec91fae69bb05700bf6a53f41a64fd15c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abfe01cec91fae69bb05700bf6a53f41a64fd15c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abfe01cec91fae69bb05700bf6a53f41a64fd15c"}], "stats": {"total": 212, "additions": 154, "deletions": 58}, "files": [{"sha": "5ae5ac6ca1205247d19d8fc3f4bd3c7813ec7dd2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f000c6a763acc0ba0184c5634f2feb3ea883992c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f000c6a763acc0ba0184c5634f2feb3ea883992c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f000c6a763acc0ba0184c5634f2feb3ea883992c", "patch": "@@ -1,5 +1,13 @@\n 2010-02-03  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/4926\n+\tPR c++/38600\n+\t* mangle.c (write_unqualified_id): Split out from write_expression.\n+\t(write_unqualified_name): Call it.\n+\t(write_member_name): Likewise.\n+\t(write_expression): Support TEMPLATE_ID_EXPR.\n+\tDisambiguate operator names.\n+\n \tPR c++/12909\n \t* mangle.c (write_type) [VECTOR_TYPE]: Change mangling with\n \t-fabi-version=4."}, {"sha": "ca15dabe6b10ea5581d5bd1259c2317f43493c0c", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 67, "deletions": 54, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f000c6a763acc0ba0184c5634f2feb3ea883992c/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f000c6a763acc0ba0184c5634f2feb3ea883992c/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=f000c6a763acc0ba0184c5634f2feb3ea883992c", "patch": "@@ -1116,11 +1116,56 @@ write_template_prefix (const tree node)\n \n     <local-source-name>\t::= L <source-name> <discriminator> */\n \n+static void\n+write_unqualified_id (tree identifier)\n+{\n+  if (IDENTIFIER_TYPENAME_P (identifier))\n+    write_conversion_operator_name (TREE_TYPE (identifier));\n+  else if (IDENTIFIER_OPNAME_P (identifier))\n+    {\n+      int i;\n+      const char *mangled_name = NULL;\n+\n+      /* Unfortunately, there is no easy way to go from the\n+\t name of the operator back to the corresponding tree\n+\t code.  */\n+      for (i = 0; i < MAX_TREE_CODES; ++i)\n+\tif (operator_name_info[i].identifier == identifier)\n+\t  {\n+\t    /* The ABI says that we prefer binary operator\n+\t       names to unary operator names.  */\n+\t    if (operator_name_info[i].arity == 2)\n+\t      {\n+\t\tmangled_name = operator_name_info[i].mangled_name;\n+\t\tbreak;\n+\t      }\n+\t    else if (!mangled_name)\n+\t      mangled_name = operator_name_info[i].mangled_name;\n+\t  }\n+\telse if (assignment_operator_name_info[i].identifier\n+\t\t == identifier)\n+\t  {\n+\t    mangled_name\n+\t      = assignment_operator_name_info[i].mangled_name;\n+\t    break;\n+\t  }\n+      write_string (mangled_name);\n+    }\n+  else\n+    write_source_name (identifier);\n+}\n+\n static void\n write_unqualified_name (const tree decl)\n {\n   MANGLE_TRACE_TREE (\"unqualified-name\", decl);\n \n+  if (TREE_CODE (decl) == IDENTIFIER_NODE)\n+    {\n+      write_unqualified_id (decl);\n+      return;\n+    }\n+\n   if (DECL_NAME (decl) == NULL_TREE)\n     {\n       gcc_assert (DECL_ASSEMBLER_NAME_SET_P (decl));\n@@ -2312,7 +2357,7 @@ static void\n write_member_name (tree member)\n {\n   if (TREE_CODE (member) == IDENTIFIER_NODE)\n-    write_source_name (member);\n+    write_unqualified_id (member);\n   else if (DECL_P (member))\n     write_unqualified_name (member);\n   else if (TREE_CODE (member) == TEMPLATE_ID_EXPR)\n@@ -2435,57 +2480,9 @@ write_expression (tree expr)\n \twrite_expression (member);\n       else\n \t{\n-\t  tree template_args;\n-\n \t  write_string (\"sr\");\n \t  write_type (scope);\n-\t  /* If MEMBER is a template-id, separate the template\n-\t     from the arguments.  */\n-\t  if (TREE_CODE (member) == TEMPLATE_ID_EXPR)\n-\t    {\n-\t      template_args = TREE_OPERAND (member, 1);\n-\t      member = TREE_OPERAND (member, 0);\n-\t    }\n-\t  else\n-\t    template_args = NULL_TREE;\n-\t  /* Write out the name of the MEMBER.  */\n-\t  if (IDENTIFIER_TYPENAME_P (member))\n-\t    write_conversion_operator_name (TREE_TYPE (member));\n-\t  else if (IDENTIFIER_OPNAME_P (member))\n-\t    {\n-\t      int i;\n-\t      const char *mangled_name = NULL;\n-\n-\t      /* Unfortunately, there is no easy way to go from the\n-\t\t name of the operator back to the corresponding tree\n-\t\t code.  */\n-\t      for (i = 0; i < MAX_TREE_CODES; ++i)\n-\t\tif (operator_name_info[i].identifier == member)\n-\t\t  {\n-\t\t    /* The ABI says that we prefer binary operator\n-\t\t       names to unary operator names.  */\n-\t\t    if (operator_name_info[i].arity == 2)\n-\t\t      {\n-\t\t\tmangled_name = operator_name_info[i].mangled_name;\n-\t\t\tbreak;\n-\t\t      }\n-\t\t    else if (!mangled_name)\n-\t\t      mangled_name = operator_name_info[i].mangled_name;\n-\t\t  }\n-\t\telse if (assignment_operator_name_info[i].identifier\n-\t\t\t == member)\n-\t\t  {\n-\t\t    mangled_name\n-\t\t      = assignment_operator_name_info[i].mangled_name;\n-\t\t    break;\n-\t\t  }\n-\t      write_string (mangled_name);\n-\t    }\n-\t  else\n-\t    write_source_name (member);\n-\t  /* Write out the template arguments.  */\n-\t  if (template_args)\n-\t    write_template_args (template_args);\n+\t  write_member_name (member);\n \t}\n     }\n   else if (TREE_CODE (expr) == INDIRECT_REF\n@@ -2494,6 +2491,25 @@ write_expression (tree expr)\n     {\n       write_expression (TREE_OPERAND (expr, 0));\n     }\n+  else if (TREE_CODE (expr) == IDENTIFIER_NODE)\n+    {\n+      /* An operator name appearing as a dependent name needs to be\n+\t specially marked to disambiguate between a use of the operator\n+\t name and a use of the operator in an expression.  */\n+      if (IDENTIFIER_OPNAME_P (expr))\n+\twrite_string (\"on\");\n+      write_unqualified_id (expr);\n+    }\n+  else if (TREE_CODE (expr) == TEMPLATE_ID_EXPR)\n+    {\n+      tree fn = TREE_OPERAND (expr, 0);\n+      if (is_overloaded_fn (fn))\n+\tfn = DECL_NAME (get_first_fn (fn));\n+      if (IDENTIFIER_OPNAME_P (fn))\n+\twrite_string (\"on\");\n+      write_unqualified_id (fn);\n+      write_template_args (TREE_OPERAND (expr, 1));\n+    }\n   else\n     {\n       int i, len;\n@@ -2560,10 +2576,7 @@ write_expression (tree expr)\n \t\t&& type_dependent_expression_p_push (expr))\n \t      fn = DECL_NAME (get_first_fn (fn));\n \n-\t    if (TREE_CODE (fn) == IDENTIFIER_NODE)\n-\t      write_source_name (fn);\n-\t    else\n-\t      write_expression (fn);\n+\t    write_expression (fn);\n \t  }\n \n \t  for (i = 0; i < call_expr_nargs (expr); ++i)"}, {"sha": "b3fef29a5a24026f5fa48da7c585faedbf6373ab", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f000c6a763acc0ba0184c5634f2feb3ea883992c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f000c6a763acc0ba0184c5634f2feb3ea883992c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f000c6a763acc0ba0184c5634f2feb3ea883992c", "patch": "@@ -1,5 +1,10 @@\n 2010-02-03  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/4926\n+\tPR c++/38600\n+\t* g++.dg/abi/mangle35.C: New.\n+\t* g++.dg/abi/mangle37.C: New.\n+\n \tPR c++/12909\n \t* g++.dg/abi/mangle36.C: New.\n "}, {"sha": "78d993344880754dd61b303e186e96cbf6d7b00a", "filename": "gcc/testsuite/g++.dg/abi/mangle35.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f000c6a763acc0ba0184c5634f2feb3ea883992c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle35.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f000c6a763acc0ba0184c5634f2feb3ea883992c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle35.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle35.C?ref=f000c6a763acc0ba0184c5634f2feb3ea883992c", "patch": "@@ -0,0 +1,13 @@\n+// PR c++/38600\n+// { dg-final { scan-assembler \"_Z3barIiE1AIX3fooIT_EEEv\" } }\n+\n+template<void (*)()> struct A {};\n+\n+template<typename> void foo();\n+\n+template<typename T> A<foo<T> > bar();\n+\n+void baz()\n+{\n+  bar<int>();\n+}"}, {"sha": "7270861ac5c8137167168a63a1630ee50e42d74b", "filename": "gcc/testsuite/g++.dg/abi/mangle37.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f000c6a763acc0ba0184c5634f2feb3ea883992c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle37.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f000c6a763acc0ba0184c5634f2feb3ea883992c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle37.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle37.C?ref=f000c6a763acc0ba0184c5634f2feb3ea883992c", "patch": "@@ -0,0 +1,35 @@\n+// Testcase for mangling of expressions involving operator names.\n+// { dg-options -std=c++0x }\n+// { dg-final { scan-assembler \"_Z1fI1AEDTclonplfp_fp_EET_\" } }\n+// { dg-final { scan-assembler \"_Z1gI1AEDTclonplIT_Efp_fp_EES1_\" } }\n+// { dg-final { scan-assembler \"_Z1hI1AEDTcldtfp_miEET_\" } }\n+// { dg-final { scan-assembler \"_Z1iI1AEDTcldtfp_srT_miEES1_\" } }\n+// { dg-final { scan-assembler \"_Z1jI1AEDTcldtfp_cvPT_EES1_\" } }\n+\n+struct A {\n+  void operator-();\n+  template <class T>\n+  operator T();\n+};\n+template <class T>\n+T operator+(T,T);\n+\n+template <class T>\n+auto f (T t) -> decltype(operator+(t,t));\n+template <class T>\n+auto g (T t) -> decltype(operator+<T>(t,t));\n+template <class T>\n+auto h (T t) -> decltype(t.operator-());\n+template <class T>\n+auto i (T t) -> decltype(t.T::operator-());\n+template <class T>\n+auto j (T t) -> decltype(t.operator T*());\n+\n+int main()\n+{\n+  f(A());\n+  g(A());\n+  h(A());\n+  i(A());\n+  j(A());\n+}"}, {"sha": "20c88d776c79b7fcd0293db8a28b7ae968946a0b", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f000c6a763acc0ba0184c5634f2feb3ea883992c/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f000c6a763acc0ba0184c5634f2feb3ea883992c/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=f000c6a763acc0ba0184c5634f2feb3ea883992c", "patch": "@@ -1,5 +1,7 @@\n 2010-02-03  Jason Merrill  <jason@redhat.com>\n \n+\t* cp-demangle.c (d_expression): Handle dependent operator name.\n+\n \tPR c++/12909\n \t* cp-demangle.c (d_number_component, d_vector_type): New.\n \t(cplus_demangle_type, d_print_comp, d_print_mod): Handle vectors."}, {"sha": "b1319cf3b468ed240bff122908f34a968f638a6a", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f000c6a763acc0ba0184c5634f2feb3ea883992c/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f000c6a763acc0ba0184c5634f2feb3ea883992c/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=f000c6a763acc0ba0184c5634f2feb3ea883992c", "patch": "@@ -2722,11 +2722,18 @@ d_expression (struct d_info *di)\n \n       return d_make_function_param (di, index);\n     }\n-  else if (IS_DIGIT (peek))\n+  else if (IS_DIGIT (peek)\n+\t   || (peek == 'o' && d_peek_next_char (di) == 'n'))\n     {\n       /* We can get an unqualified name as an expression in the case of\n-         a dependent member access, i.e. decltype(T().i).  */\n-      struct demangle_component *name = d_unqualified_name (di);\n+         a dependent function call, i.e. decltype(f(t)).  */\n+      struct demangle_component *name;\n+\n+      if (peek == 'o')\n+\t/* operator-function-id, i.e. operator+(t).  */\n+\td_advance (di, 2);\n+\n+      name = d_unqualified_name (di);\n       if (name == NULL)\n \treturn NULL;\n       if (d_peek_char (di) == 'I')\n@@ -2784,10 +2791,18 @@ d_expression (struct d_info *di)\n \t  {\n \t    struct demangle_component *left;\n \t    struct demangle_component *right;\n+\t    const char *code = op->u.s_operator.op->code;\n \n \t    left = d_expression (di);\n-\t    if (!strcmp (op->u.s_operator.op->code, \"cl\"))\n+\t    if (!strcmp (code, \"cl\"))\n \t      right = d_exprlist (di);\n+\t    else if (!strcmp (code, \"dt\") || !strcmp (code, \"pt\"))\n+\t      {\n+\t\tright = d_unqualified_name (di);\n+\t\tif (d_peek_char (di) == 'I')\n+\t\t  right = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE,\n+\t\t\t\t       right, d_template_args (di));\n+\t      }\n \t    else\n \t      right = d_expression (di);\n "}, {"sha": "0f85ddc456817f868e2a0c29cc78bc870ef02a1b", "filename": "libiberty/testsuite/demangle-expected", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f000c6a763acc0ba0184c5634f2feb3ea883992c/libiberty%2Ftestsuite%2Fdemangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f000c6a763acc0ba0184c5634f2feb3ea883992c/libiberty%2Ftestsuite%2Fdemangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fdemangle-expected?ref=f000c6a763acc0ba0184c5634f2feb3ea883992c", "patch": "@@ -3932,6 +3932,11 @@ f(float vector[32])\n --format=gnu-v3\n _Z1fIfLi4EEvDv_T0__T_\n void f<float, 4>(float vector[4])\n+_Z1fI1AEDTclonplfp_fp_EET_\n+decltype ((operator+)({parm#1}, {parm#1})) f<A>(A)\n+--format=gnu-v3\n+_Z1hI1AEDTcldtfp_miEET_\n+decltype (({parm#1}.(operator-))()) h<A>(A)\n #\n # Ada (GNAT) tests.\n #"}]}