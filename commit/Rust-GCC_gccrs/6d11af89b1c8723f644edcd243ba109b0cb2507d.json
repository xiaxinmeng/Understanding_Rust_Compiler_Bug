{"sha": "6d11af89b1c8723f644edcd243ba109b0cb2507d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQxMWFmODliMWM4NzIzZjY0NGVkY2QyNDNiYTEwOWIwY2IyNTA3ZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-03-25T15:59:29Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-03-25T15:59:29Z"}, "message": "[multiple changes]\n\n2004-03-25  Vasiliy Fofanov  <fofanov@act-europe.fr>\n\n\t* memtrack.adb: Log realloc calls, which are treated as free followed\n\tby alloc.\n\n2004-03-25  Vincent Celier  <celier@gnat.com>\n\n\t* prj-makr.adb (Process_Directories): Detect when a file contains\n\tseveral units. Do not include such files in the config pragmas or\n\tin the naming scheme.\n\n\t* prj-nmsc.adb (Record_Source): New parameter Trusted_Mode.\n\tResolve links only when not in Trusted_Mode.\n\t(Find_Sources, Recursive_Find_Dirs, Find_Source_Dirs, Locate_Directory):\n\tDo not resolve links for the display names.\n\n\t* prj-part.adb (Parse_Single_Project, Project_Path_Name_Of): Do not\n\tresolve links when computing the display names.\n\n2004-03-25  Thomas Quinot  <quinot@act-europe.fr>\n\n\t* sem_attr.adb (Check_Dereference): When the prefix of a 'Tag\n\tattribute reference does not denote a subtype, it can be any\n\texpression that has a classwide type, potentially after an implicit\n\tdereference.  In particular, the prefix can be a view conversion for\n\ta classwide type (for which Is_Object_Reference holds), but it can\n\talso be a value conversion for an access-to-classwide type. In the\n\tlatter case, there is an implicit dereference, and the original node\n\tfor the prefix does not verify Is_Object_Reference.\n\n\t* sem_util.adb (Is_Dependent_Component_Of_Mutable_Object): A view\n\tconversion of a discriminant-dependent component of a mutable object\n\tis one itself.\n\n2004-03-25  Ed Schonberg  <schonberg@gnat.com>\n\n\t* freeze.adb (Freeze_Entity): When an inherited subprogram is\n\tinherited, has convention C, and has unconstrained array parameters,\n\tplace the corresponding warning on the derived type declaration rather\n\tthan the original subprogram.\n\n\t* sem_ch12.adb (Instantiate_Formal_Subprogram): Set From_Default\n\tindication on renaming declaration, if formal has a box and actual\n\tis absent.\n\n\t* sem_ch8.adb (Analyze_Subprogram_Renaming): Use From_Default flag to\n\tdetermine whether to generate an implicit or explicit reference to\n\tthe renamed entity.\n\n\t* sinfo.ads, sinfo.adb: New flag From_Default, to indicate that a\n\tsubprogram renaming comes from a defaulted formal subprogram in an\n\tinstance.\n\n2004-03-25  Gary Dismukes  <dismukes@gnat.com>\n\n\t* sem_elab.adb (Check_Elab_Call): Refine loop that checks for default\n\tvalue expressions to ensure that calls within a component definition\n\twill be checked (since those are evaluated during the record type's\n\telaboration).\n\n2004-03-25  Arnaud Charlet  <charlet@act-europe.fr>\n\n\t* s-tpobop.adb: Code clean up:\n\t(Requeue_Call): Extract from PO_Service_Entries to remove duplicated\n\tcode.\n\t(PO_Do_Or_Queue): Remove duplicated code and use Requeue_Call.\n\n2004-03-25  Jose Ruiz  <ruiz@act-europe.fr>\n\n\t* Makefile.in: Clean up in the ravenscar run time.\n\nFrom-SVN: r79953", "tree": {"sha": "26147d46094f2e388618b0c64002236fd763880a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/26147d46094f2e388618b0c64002236fd763880a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d11af89b1c8723f644edcd243ba109b0cb2507d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d11af89b1c8723f644edcd243ba109b0cb2507d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d11af89b1c8723f644edcd243ba109b0cb2507d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d11af89b1c8723f644edcd243ba109b0cb2507d/comments", "author": null, "committer": null, "parents": [{"sha": "9728c9d15aceb958b36fef96e2f3b9e4d0d74dd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9728c9d15aceb958b36fef96e2f3b9e4d0d74dd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9728c9d15aceb958b36fef96e2f3b9e4d0d74dd7"}], "stats": {"total": 946, "additions": 572, "deletions": 374}, "files": [{"sha": "1229cfa390788ca9b64df389cb971ab28383b54e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6d11af89b1c8723f644edcd243ba109b0cb2507d", "patch": "@@ -1,3 +1,74 @@\n+2004-03-25  Vasiliy Fofanov  <fofanov@act-europe.fr>\n+\n+\t* memtrack.adb: Log realloc calls, which are treated as free followed\n+\tby alloc.\n+\n+2004-03-25  Vincent Celier  <celier@gnat.com>\n+\n+\t* prj-makr.adb (Process_Directories): Detect when a file contains\n+\tseveral units. Do not include such files in the config pragmas or\n+\tin the naming scheme.\n+\n+\t* prj-nmsc.adb (Record_Source): New parameter Trusted_Mode.\n+\tResolve links only when not in Trusted_Mode.\n+\t(Find_Sources, Recursive_Find_Dirs, Find_Source_Dirs, Locate_Directory):\n+\tDo not resolve links for the display names.\n+\n+\t* prj-part.adb (Parse_Single_Project, Project_Path_Name_Of): Do not\n+\tresolve links when computing the display names.\n+\n+2004-03-25  Thomas Quinot  <quinot@act-europe.fr>\n+\n+\t* sem_attr.adb (Check_Dereference): When the prefix of a 'Tag\n+\tattribute reference does not denote a subtype, it can be any\n+\texpression that has a classwide type, potentially after an implicit\n+\tdereference.  In particular, the prefix can be a view conversion for\n+\ta classwide type (for which Is_Object_Reference holds), but it can\n+\talso be a value conversion for an access-to-classwide type. In the\n+\tlatter case, there is an implicit dereference, and the original node\n+\tfor the prefix does not verify Is_Object_Reference.\n+\n+\t* sem_util.adb (Is_Dependent_Component_Of_Mutable_Object): A view\n+\tconversion of a discriminant-dependent component of a mutable object\n+\tis one itself.\n+\n+2004-03-25  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* freeze.adb (Freeze_Entity): When an inherited subprogram is\n+\tinherited, has convention C, and has unconstrained array parameters,\n+\tplace the corresponding warning on the derived type declaration rather\n+\tthan the original subprogram.\n+\n+\t* sem_ch12.adb (Instantiate_Formal_Subprogram): Set From_Default\n+\tindication on renaming declaration, if formal has a box and actual\n+\tis absent.\n+\n+\t* sem_ch8.adb (Analyze_Subprogram_Renaming): Use From_Default flag to\n+\tdetermine whether to generate an implicit or explicit reference to\n+\tthe renamed entity.\n+\n+\t* sinfo.ads, sinfo.adb: New flag From_Default, to indicate that a\n+\tsubprogram renaming comes from a defaulted formal subprogram in an\n+\tinstance.\n+\n+2004-03-25  Gary Dismukes  <dismukes@gnat.com>\n+\n+\t* sem_elab.adb (Check_Elab_Call): Refine loop that checks for default\n+\tvalue expressions to ensure that calls within a component definition\n+\twill be checked (since those are evaluated during the record type's\n+\telaboration).\n+\n+2004-03-25  Arnaud Charlet  <charlet@act-europe.fr>\n+\n+\t* s-tpobop.adb: Code clean up:\n+\t(Requeue_Call): Extract from PO_Service_Entries to remove duplicated\n+\tcode.\n+\t(PO_Do_Or_Queue): Remove duplicated code and use Requeue_Call.\n+\n+2004-03-25  Jose Ruiz  <ruiz@act-europe.fr>\n+\n+\t* Makefile.in: Clean up in the ravenscar run time.\n+\n 2004-03-23  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* decl.c (gnat_to_gnu_entity, case E_Access_Type): Pass value"}, {"sha": "3fd157b4e591e600b97ed92a22ecc51f8c0aec43", "filename": "gcc/ada/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.in?ref=6d11af89b1c8723f644edcd243ba109b0cb2507d", "patch": "@@ -567,6 +567,7 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworks,$(targ))),)\n   s-interr.adb<1sinterr.adb \\\n   s-taskin.ads<1staskin.ads \\\n   s-taskin.adb<1staskin.adb \\\n+  s-taspri.ads<1staspri.ads \\\n   s-tarest.adb<1starest.adb \\\n   s-tposen.ads<1stposen.ads \\\n   s-tposen.adb<1stposen.adb \\"}, {"sha": "bb4b3f93e24d668db01ea7c57b69ad93f05758d3", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=6d11af89b1c8723f644edcd243ba109b0cb2507d", "patch": "@@ -1868,10 +1868,8 @@ package body Freeze is\n \n       --  It is improper to freeze an external entity within a generic\n       --  because its freeze node will appear in a non-valid context.\n-      --  ??? We should probably freeze the entity at that point and insert\n-      --  the freeze node in a proper place but this proper place is not\n-      --  easy to find, and the proper scope is not easy to restore. For\n-      --  now, just wait to get out of the generic to freeze ???\n+      --  The entity will be frozen in the proper scope after the current\n+      --  generic is analyzed.\n \n       elsif Inside_A_Generic and then External_Ref_In_Generic (E) then\n          return No_List;\n@@ -2005,7 +2003,8 @@ package body Freeze is\n          if Is_Subprogram (E) then\n             if not Is_Internal (E) then\n                declare\n-                  F_Type : Entity_Id;\n+                  F_Type    : Entity_Id;\n+                  Warn_Node : Node_Id;\n \n                   function Is_Fat_C_Ptr_Type (T : Entity_Id) return Boolean;\n                   --  Determines if given type entity is a fat pointer type\n@@ -2082,12 +2081,30 @@ package body Freeze is\n                        and then Warn_On_Export_Import\n                      then\n                         Error_Msg_Qual_Level := 1;\n-                        Error_Msg_N\n+\n+                        --  If this is an inherited operation, place the\n+                        --  warning on the derived type declaration, rather\n+                        --  than on the original subprogram.\n+\n+                        if Nkind (Original_Node (Parent (E))) =\n+                          N_Full_Type_Declaration\n+                        then\n+                           Warn_Node := Parent (E);\n+\n+                           if Formal = First_Formal (E) then\n+                              Error_Msg_NE\n+                                (\"?in inherited operation&!\", Warn_Node, E);\n+                           end if;\n+                        else\n+                           Warn_Node := Formal;\n+                        end if;\n+\n+                        Error_Msg_NE\n                           (\"?type of argument& is unconstrained array\",\n-                           Formal);\n-                        Error_Msg_N\n+                           Warn_Node, Formal);\n+                        Error_Msg_NE\n                           (\"?foreign caller must pass bounds explicitly\",\n-                           Formal);\n+                           Warn_Node, Formal);\n                         Error_Msg_Qual_Level := 0;\n                      end if;\n "}, {"sha": "39ffb82eafbcfd509e37eda88d48e0db1f575466", "filename": "gcc/ada/memtrack.adb", "status": "modified", "additions": 55, "deletions": 2, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2Fmemtrack.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2Fmemtrack.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmemtrack.adb?ref=6d11af89b1c8723f644edcd243ba109b0cb2507d", "patch": "@@ -297,15 +297,68 @@ package body System.Memory is\n    function Realloc\n      (Ptr : System.Address; Size : size_t) return System.Address\n    is\n-      Result : System.Address;\n+      Addr : aliased constant System.Address := Ptr;\n+      Result : aliased System.Address;\n \n    begin\n+      --  For the purposes of allocations logging, we treat realloc as a free\n+      --  followed by malloc. This is not exactly accurate, but is a good way\n+      --  to fit it into malloc/free-centered reports.\n+\n       if Size = size_t'Last then\n          Raise_Exception (Storage_Error'Identity, \"object too large\");\n       end if;\n \n       Abort_Defer.all;\n-      Result := c_realloc (Ptr, Size);\n+      Lock_Task.all;\n+\n+      if First_Call then\n+\n+         First_Call := False;\n+\n+         --  We first log deallocation call\n+\n+         Gmem_Initialize;\n+         Call_Chain (Tracebk'Address, Max_Call_Stack, Num_Calls,\n+                     Skip_Frames => 2);\n+         fputc (Character'Pos ('D'), Gmemfile);\n+         fwrite (Addr'Address, Address_Size, 1, Gmemfile);\n+         fwrite (Num_Calls'Address, Integer'Max_Size_In_Storage_Elements, 1,\n+                 Gmemfile);\n+\n+         for J in Tracebk'First .. Tracebk'First + Num_Calls - 1 loop\n+            declare\n+               Ptr : System.Address := PC_For (Tracebk (J));\n+            begin\n+               fwrite (Ptr'Address, Address_Size, 1, Gmemfile);\n+            end;\n+         end loop;\n+\n+         --  Now perform actual realloc\n+\n+         Result := c_realloc (Ptr, Size);\n+\n+         --   Log allocation call using the same backtrace\n+\n+         fputc (Character'Pos ('A'), Gmemfile);\n+         fwrite (Result'Address, Address_Size, 1, Gmemfile);\n+         fwrite (Size'Address, size_t'Max_Size_In_Storage_Elements, 1,\n+                 Gmemfile);\n+         fwrite (Num_Calls'Address, Integer'Max_Size_In_Storage_Elements, 1,\n+                 Gmemfile);\n+\n+         for J in Tracebk'First .. Tracebk'First + Num_Calls - 1 loop\n+            declare\n+               Ptr : System.Address := PC_For (Tracebk (J));\n+            begin\n+               fwrite (Ptr'Address, Address_Size, 1, Gmemfile);\n+            end;\n+         end loop;\n+\n+         First_Call := True;\n+      end if;\n+\n+      Unlock_Task.all;\n       Abort_Undefer.all;\n \n       if Result = System.Null_Address then"}, {"sha": "bed3415e9e756218b62e58d31ebcb81256f7601d", "filename": "gcc/ada/prj-makr.adb", "status": "modified", "additions": 173, "deletions": 155, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2Fprj-makr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2Fprj-makr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-makr.adb?ref=6d11af89b1c8723f644edcd243ba109b0cb2507d", "patch": "@@ -43,6 +43,8 @@ with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n with GNAT.OS_Lib;               use GNAT.OS_Lib;\n with GNAT.Regexp;               use GNAT.Regexp;\n \n+with System.Case_Util;          use System.Case_Util;\n+\n package body Prj.Makr is\n \n    function Dup (Fd : File_Descriptor) return File_Descriptor;\n@@ -134,8 +136,8 @@ package body Prj.Makr is\n       Args : Argument_List  (1 .. Preproc_Switches'Length + 6);\n \n       type SFN_Pragma is record\n-         Unit : String_Access;\n-         File : String_Access;\n+         Unit : Name_Id;\n+         File : Name_Id;\n          Spec : Boolean;\n       end record;\n \n@@ -165,8 +167,14 @@ package body Prj.Makr is\n \n          Temp_File_Name : String_Access := null;\n \n+         Save_Last_Pragma_Index : Natural := 0;\n+\n+         File_Name_Id : Name_Id := No_Name;\n+\n+         SFN_Prag : SFN_Pragma;\n+\n       begin\n-         --  Avoid processing several times the same directory.\n+         --  Avoid processing the same directory more than once\n \n          for Index in 1 .. Processed_Directories.Last loop\n             if Processed_Directories.Table (Index).all = Dir_Name then\n@@ -199,15 +207,19 @@ package body Prj.Makr is\n \n             --  Process each regular file in the directory\n \n-            loop\n+            File_Loop : loop\n                Read (Dir, Str, Last);\n-               exit when Last = 0;\n+               exit File_Loop when Last = 0;\n \n                if Is_Regular_File\n                  (Dir_Name & Directory_Separator & Str (1 .. Last))\n                then\n                   Matched := True;\n \n+                  Name_Len := Last;\n+                  Name_Buffer (1 .. Name_Len) := Str (1 .. Last);\n+                  File_Name_Id := Name_Find;\n+\n                   --  First, check if the file name matches at least one of\n                   --  the excluded expressions;\n \n@@ -256,7 +268,7 @@ package body Prj.Makr is\n                         Saved_Error  : File_Descriptor;\n \n                      begin\n-                        --  If we don't have yet the path of the compiler,\n+                        --  If we don't have the path of the compiler yet,\n                         --  get it now.\n \n                         if Gcc_Path = null then\n@@ -302,8 +314,7 @@ package body Prj.Makr is\n                         Saved_Output := Dup (Standout);\n                         Saved_Error  := Dup (Standerr);\n \n-                        --  Set the standard output and error to the temporary\n-                        --  file.\n+                        --  Set standard output and error to the temporary file\n \n                         Dup2 (FD, Standout);\n                         Dup2 (FD, Standerr);\n@@ -313,6 +324,7 @@ package body Prj.Makr is\n                         Spawn (Gcc_Path.all, Args, Success);\n \n                         --  Restore the standard output and error\n+\n                         Dup2 (Saved_Output, Standout);\n                         Dup2 (Saved_Error, Standerr);\n \n@@ -329,11 +341,11 @@ package body Prj.Makr is\n                         --  Now that standard output is restored, check if\n                         --  the compiler ran correctly.\n \n-                        --  Read the first line of the temporary file:\n-                        --  it should contain the kind and name of the unit.\n+                        --  Read the lines of the temporary file:\n+                        --  they should contain the kind and name of the unit.\n \n                         declare\n-                           File : Text_File;\n+                           File      : Text_File;\n                            Text_Line : String (1 .. 1_000);\n                            Text_Last : Natural;\n \n@@ -345,173 +357,180 @@ package body Prj.Makr is\n                                 (\"could not read temporary file\");\n                            end if;\n \n+                           Save_Last_Pragma_Index := SFN_Pragmas.Last;\n+\n                            if End_Of_File (File) then\n                               if Opt.Verbose_Mode then\n                                  if not Success then\n                                     Output.Write_Str (\"(process died) \");\n                                  end if;\n+                              end if;\n+                           else\n+                              Line_Loop : while not End_Of_File (File) loop\n+                                 Get_Line (File, Text_Line, Text_Last);\n+\n+                                 --  Find the first closing parenthesis\n \n+                                 Char_Loop : for J in 1 .. Text_Last loop\n+                                    if Text_Line (J) = ')' then\n+                                       if J >= 13 and then\n+                                         Text_Line (1 .. 4) = \"Unit\"\n+                                       then\n+                                          --  Add an entry in the SFN_Pragmas\n+                                          --  table.\n+\n+                                          Name_Len := J - 12;\n+                                          Name_Buffer (1 .. Name_Len) :=\n+                                            Text_Line (6 .. J - 7);\n+                                          SFN_Prag :=\n+                                            (Unit => Name_Find,\n+                                             File => File_Name_Id,\n+                                             Spec => Text_Line (J - 5 .. J) =\n+                                                       \"(spec)\");\n+\n+                                          SFN_Pragmas.Increment_Last;\n+                                          SFN_Pragmas.Table\n+                                            (SFN_Pragmas.Last) := SFN_Prag;\n+                                       end if;\n+                                       exit Char_Loop;\n+                                    end if;\n+                                 end loop Char_Loop;\n+                              end loop Line_Loop;\n+                           end if;\n+\n+                           if Save_Last_Pragma_Index = SFN_Pragmas.Last then\n+                              if Opt.Verbose_Mode then\n                                  Output.Write_Line (\"not a unit\");\n                               end if;\n \n-                           else\n-                              Get_Line (File, Text_Line, Text_Last);\n-                              Close (File);\n+                           elsif SFN_Pragmas.Last >\n+                             Save_Last_Pragma_Index + 1\n+                           then\n+                              SFN_Pragmas.Set_Last (Save_Last_Pragma_Index);\n \n-                              --  Now that we have read the line, delete the\n-                              --  temporary file, it is not needed anymore.\n-                              --  On VMS, this avoids several version of the\n-                              --  file, if it were only delete after all\n-                              --  sources were parsed.\n+                              if Opt.Verbose_Mode then\n+                                 Output.Write_Line\n+                                   (\"file contains multiple units\");\n+                              end if;\n \n-                              Delete_File (Temp_File_Name.all, Success);\n+                           else\n+                              SFN_Prag := SFN_Pragmas.Table\n+                                (SFN_Pragmas.Last);\n \n-                              --  Find the first closing parenthesis\n+                              if Opt.Verbose_Mode then\n+                                 if SFN_Prag.Spec then\n+                                    Output.Write_Str (\"spec of \");\n \n-                              for J in 1 .. Text_Last loop\n-                                 if Text_Line (J) = ')' then\n-                                    Text_Last := J;\n-                                    exit;\n+                                 else\n+                                    Output.Write_Str (\"body of \");\n                                  end if;\n-                              end loop;\n \n-                              declare\n-                                 S : constant String :=\n-                                       Text_Line (1 .. Text_Last);\n+                                 Output.Write_Line\n+                                   (Get_Name_String (SFN_Prag.Unit));\n+                              end if;\n \n-                              begin\n-                                 if S'Length >= 13\n-                                   and then S (S'First .. S'First + 3) = \"Unit\"\n-                                 then\n-                                    if Opt.Verbose_Mode then\n-                                       Output.Write_Str\n-                                         (S (S'Last - 4 .. S'Last - 1));\n-                                       Output.Write_Str (\" of \");\n-                                       Output.Write_Line\n-                                         (S (S'First + 5 .. S'Last - 7));\n+                              if Project_File then\n+\n+                                 --  Add the corresponding attribute in\n+                                 --  the Naming package of the naming\n+                                 --  project.\n+\n+                                 declare\n+                                    Decl_Item : constant Project_Node_Id\n+                                      := Default_Project_Node\n+                                        (Of_Kind =>\n+                                             N_Declarative_Item);\n+\n+                                    Attribute : constant Project_Node_Id\n+                                      := Default_Project_Node\n+                                        (Of_Kind =>\n+                                             N_Attribute_Declaration);\n+\n+                                    Expression : constant Project_Node_Id\n+                                      := Default_Project_Node\n+                                        (Of_Kind => N_Expression,\n+                                         And_Expr_Kind => Single);\n+\n+                                    Term : constant Project_Node_Id :=\n+                                             Default_Project_Node\n+                                               (Of_Kind => N_Term,\n+                                                And_Expr_Kind => Single);\n+\n+                                    Value : constant Project_Node_Id :=\n+                                              Default_Project_Node\n+                                                (Of_Kind =>\n+                                                             N_Literal_String,\n+                                                 And_Expr_Kind =>\n+                                                   Single);\n+\n+                                 begin\n+                                    Set_Next_Declarative_Item\n+                                      (Decl_Item,\n+                                       To => First_Declarative_Item_Of\n+                                         (Naming_Package));\n+                                    Set_First_Declarative_Item_Of\n+                                      (Naming_Package, To => Decl_Item);\n+                                    Set_Current_Item_Node\n+                                      (Decl_Item, To => Attribute);\n+\n+                                    --  Is it a spec or a body?\n+\n+                                    if SFN_Prag.Spec then\n+                                       Set_Name_Of\n+                                         (Attribute, To => Name_Spec);\n+                                    else\n+                                       Set_Name_Of\n+                                         (Attribute,\n+                                          To => Name_Body);\n                                     end if;\n \n-                                    if Project_File then\n-\n-                                       --  Add the corresponding attribute in\n-                                       --  the Naming package of the naming\n-                                       --  project.\n-\n-                                       declare\n-                                          Decl_Item : constant Project_Node_Id\n-                                            := Default_Project_Node\n-                                              (Of_Kind =>\n-                                                   N_Declarative_Item);\n-\n-                                          Attribute : constant Project_Node_Id\n-                                            := Default_Project_Node\n-                                              (Of_Kind =>\n-                                                   N_Attribute_Declaration);\n-\n-                                          Expression : constant Project_Node_Id\n-                                            := Default_Project_Node\n-                                              (Of_Kind => N_Expression,\n-                                               And_Expr_Kind => Single);\n-\n-                                          Term : constant Project_Node_Id :=\n-                                                   Default_Project_Node\n-                                                     (Of_Kind => N_Term,\n-                                                      And_Expr_Kind => Single);\n-\n-                                          Value : constant Project_Node_Id :=\n-                                                    Default_Project_Node\n-                                                      (Of_Kind =>\n-                                                         N_Literal_String,\n-                                                       And_Expr_Kind =>\n-                                                         Single);\n-\n-                                       begin\n-                                          Set_Next_Declarative_Item\n-                                            (Decl_Item,\n-                                             To => First_Declarative_Item_Of\n-                                               (Naming_Package));\n-                                          Set_First_Declarative_Item_Of\n-                                            (Naming_Package, To => Decl_Item);\n-                                          Set_Current_Item_Node\n-                                            (Decl_Item, To => Attribute);\n-\n-                                          --  Is it a spec or a body?\n-\n-                                          if S (S'Last - 5 .. S'Last) =\n-                                            \"(spec)\"\n-                                          then\n-                                             Set_Name_Of\n-                                               (Attribute, To => Name_Spec);\n-                                          else\n-                                             Set_Name_Of\n-                                               (Attribute,\n-                                                To => Name_Body);\n-                                          end if;\n-\n-                                          --  Get the name of the unit\n-\n-                                          Name_Len := S'Last - S'First - 11;\n-                                          Name_Buffer (1 .. Name_Len) :=\n-                                            (To_Lower\n-                                               (S (S'First + 5 ..\n-                                                     S'Last - 7)));\n-                                          Set_Associative_Array_Index_Of\n-                                            (Attribute, To => Name_Find);\n+                                    --  Get the name of the unit\n \n-                                          Set_Expression_Of\n-                                            (Attribute, To => Expression);\n-                                          Set_First_Term\n-                                            (Expression, To => Term);\n-                                          Set_Current_Term (Term, To => Value);\n+                                    Get_Name_String (SFN_Prag.Unit);\n+                                    To_Lower (Name_Buffer (1 .. Name_Len));\n+                                    Set_Associative_Array_Index_Of\n+                                      (Attribute, To => Name_Find);\n \n-                                          --  And set the name of the file\n+                                    Set_Expression_Of\n+                                      (Attribute, To => Expression);\n+                                    Set_First_Term\n+                                      (Expression, To => Term);\n+                                    Set_Current_Term (Term, To => Value);\n \n-                                          Name_Len := Last;\n-                                          Name_Buffer (1 .. Name_Len) :=\n-                                            Str (1 .. Last);\n-                                          Set_String_Value_Of\n-                                            (Value, To => Name_Find);\n-                                       end;\n+                                    --  And set the name of the file\n \n-                                       --  Add source file name to source list\n-                                       --  file.\n+                                    Set_String_Value_Of\n+                                      (Value, To => File_Name_Id);\n+                                 end;\n \n-                                       Last := Last + 1;\n-                                       Str (Last) := ASCII.LF;\n+                                 --  Add source file name to source list\n+                                 --  file.\n \n-                                       if Write (Source_List_FD,\n-                                                 Str (1)'Address,\n-                                                 Last) /= Last\n-                                       then\n-                                          Prj.Com.Fail (\"disk full\");\n-                                       end if;\n-                                    else\n-                                       --  Add an entry in the SFN_Pragmas\n-                                       --  table.\n-\n-                                       SFN_Pragmas.Increment_Last;\n-                                       SFN_Pragmas.Table (SFN_Pragmas.Last) :=\n-                                         (Unit => new String'\n-                                            (S (S'First + 5 .. S'Last - 7)),\n-                                          File => new String'(Str (1 .. Last)),\n-                                          Spec => S (S'Last - 5 .. S'Last)\n-                                          = \"(spec)\");\n-                                    end if;\n+                                 Last := Last + 1;\n+                                 Str (Last) := ASCII.LF;\n \n-                                 else\n-                                    if Opt.Verbose_Mode then\n-                                       Output.Write_Line (\"not a unit\");\n-                                    end if;\n+                                 if Write (Source_List_FD,\n+                                           Str (1)'Address,\n+                                           Last) /= Last\n+                                 then\n+                                    Prj.Com.Fail (\"disk full\");\n                                  end if;\n-                              end;\n+                              end if;\n                            end if;\n+\n+                           Close (File);\n+\n+                           Delete_File (Temp_File_Name.all, Success);\n                         end;\n                      end;\n \n+                  --  File name matches none of the regular expressions\n+\n                   else\n-                     if Matched = False then\n-                        --  Look if this is a foreign source\n+                     --  If the file is not excluded, look if this is a foreign\n+                     --  source.\n \n+                     if Matched /= Excluded then\n                         for Index in Foreign_Expressions'Range loop\n                            if Match (Str (1 .. Last),\n                                      Foreign_Expressions (Index))\n@@ -551,7 +570,7 @@ package body Prj.Makr is\n                      end if;\n                   end if;\n                end if;\n-            end loop;\n+            end loop File_Loop;\n \n             Close (Dir);\n          end if;\n@@ -718,7 +737,6 @@ package body Prj.Makr is\n \n          declare\n             Discard : Boolean;\n-\n          begin\n             Delete_File\n               (Source_List_Path (1 .. Source_List_Last),\n@@ -753,7 +771,6 @@ package body Prj.Makr is\n          begin\n             Excluded_Expressions (Index) :=\n               Compile (Pattern => Excluded_Patterns (Index).all, Glob => True);\n-\n          exception\n             when Error_In_Regexp =>\n                Prj.Com.Fail\n@@ -773,7 +790,6 @@ package body Prj.Makr is\n          begin\n             Foreign_Expressions (Index) :=\n               Compile (Pattern => Foreign_Patterns (Index).all, Glob => True);\n-\n          exception\n             when Error_In_Regexp =>\n                Prj.Com.Fail\n@@ -823,8 +839,8 @@ package body Prj.Makr is\n             end if;\n \n             Part.Parse\n-              (Project           => Project_Node,\n-               Project_File_Name => Output_Name (1 .. Output_Name_Last),\n+              (Project                => Project_Node,\n+               Project_File_Name      => Output_Name (1 .. Output_Name_Last),\n                Always_Errout_Finalize => False);\n \n             --  If parsing was successful, remove the components that are\n@@ -837,7 +853,7 @@ package body Prj.Makr is\n \n                declare\n                   With_Clause : Project_Node_Id :=\n-                    First_With_Clause_Of (Project_Node);\n+                                  First_With_Clause_Of (Project_Node);\n                   Previous    : Project_Node_Id := Empty_Node;\n \n                begin\n@@ -1248,7 +1264,8 @@ package body Prj.Makr is\n                Write_A_String (\"pragma Source_File_Name\");\n                Write_Eol;\n                Write_A_String (\"  (\");\n-               Write_A_String (SFN_Pragmas.Table (Index).Unit.all);\n+               Write_A_String\n+                 (Get_Name_String (SFN_Pragmas.Table (Index).Unit));\n                Write_A_String (\",\");\n                Write_Eol;\n \n@@ -1259,7 +1276,8 @@ package body Prj.Makr is\n                   Write_A_String (\"   Body_File_Name => \"\"\");\n                end if;\n \n-               Write_A_String (SFN_Pragmas.Table (Index).File.all);\n+               Write_A_String\n+                 (Get_Name_String (SFN_Pragmas.Table (Index).File));\n                Write_A_String (\"\"\");\");\n                Write_Eol;\n             end loop;"}, {"sha": "5b09f84912712f5d51fd888e84aa423004e2367b", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 55, "deletions": 15, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=6d11af89b1c8723f644edcd243ba109b0cb2507d", "patch": "@@ -136,7 +136,8 @@ package body Prj.Nmsc is\n       Data            : in out Project_Data;\n       Location        : Source_Ptr;\n       Current_Source  : in out String_List_Id;\n-      Source_Recorded : in out Boolean);\n+      Source_Recorded : in out Boolean;\n+      Trusted_Mode    : Boolean);\n    --  Put a unit in the list of units of a project, if the file name\n    --  corresponds to a valid unit name.\n \n@@ -703,7 +704,8 @@ package body Prj.Nmsc is\n                                     (Name      => Name_Buffer (1 .. Name_Len),\n                                      Directory => Source_Directory\n                                        (Source_Directory'First .. Dir_Last),\n-                                     Resolve_Links => not Trusted_Mode);\n+                                     Resolve_Links => False,\n+                                     Case_Sensitive => True);\n                            Path_Name : Name_Id;\n \n                         begin\n@@ -725,7 +727,8 @@ package body Prj.Nmsc is\n                                  Data            => Data,\n                                  Location        => No_Location,\n                                  Current_Source  => Current_Source,\n-                                 Source_Recorded => Source_Recorded);\n+                                 Source_Recorded => Source_Recorded,\n+                                 Trusted_Mode    => Trusted_Mode);\n                            end if;\n                         end;\n                      end loop;\n@@ -841,7 +844,8 @@ package body Prj.Nmsc is\n                         Data            => Data,\n                         Location        => NL.Location,\n                         Current_Source  => Current_Source,\n-                        Source_Recorded => Source_Recorded);\n+                        Source_Recorded => Source_Recorded,\n+                        Trusted_Mode    => Trusted_Mode);\n                   end if;\n                end loop;\n \n@@ -2591,7 +2595,7 @@ package body Prj.Nmsc is\n \n             The_Path : constant String :=\n                          Normalize_Pathname (Get_Name_String (Path)) &\n-            Directory_Separator;\n+                         Directory_Separator;\n \n             The_Path_Last : constant Natural :=\n                               Compute_Directory_Last (The_Path);\n@@ -2692,7 +2696,9 @@ package body Prj.Nmsc is\n                                      (Name      => Name (1 .. Last),\n                                       Directory =>\n                                         The_Path\n-                                          (The_Path'First .. The_Path_Last));\n+                                          (The_Path'First .. The_Path_Last),\n+                                      Resolve_Links  => False,\n+                                      Case_Sensitive => True);\n \n                   begin\n                      if Is_Directory (Path_Name) then\n@@ -2761,7 +2767,9 @@ package body Prj.Nmsc is\n                             Normalize_Pathname\n                               (Name      => Get_Name_String (Base_Dir),\n                                Directory =>\n-                                 Get_Name_String (Data.Display_Directory));\n+                                 Get_Name_String (Data.Display_Directory),\n+                               Resolve_Links  => False,\n+                               Case_Sensitive => True);\n \n             begin\n                if Root_Dir'Length = 0 then\n@@ -3544,13 +3552,24 @@ package body Prj.Nmsc is\n          if Is_Directory (The_Name) then\n             declare\n                Normed : constant String :=\n-                 Normalize_Pathname (The_Name);\n+                          Normalize_Pathname\n+                            (The_Name,\n+                             Resolve_Links  => False,\n+                             Case_Sensitive => True);\n+\n+               Canonical_Path : constant String :=\n+                                  Normalize_Pathname\n+                                    (Normed,\n+                                     Resolve_Links  => True,\n+                                     Case_Sensitive => False);\n \n             begin\n                Name_Len := Normed'Length;\n                Name_Buffer (1 .. Name_Len) := Normed;\n                Display := Name_Find;\n-               Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n+\n+               Name_Len := Canonical_Path'Length;\n+               Name_Buffer (1 .. Name_Len) := Canonical_Path;\n                Dir := Name_Find;\n             end;\n          end if;\n@@ -3565,13 +3584,24 @@ package body Prj.Nmsc is\n             if Is_Directory (Full_Path) then\n                declare\n                   Normed : constant String :=\n-                             Normalize_Pathname (Full_Path);\n+                             Normalize_Pathname\n+                               (Full_Path,\n+                                Resolve_Links  => False,\n+                                Case_Sensitive => True);\n+\n+                  Canonical_Path : constant String :=\n+                                     Normalize_Pathname\n+                                       (Normed,\n+                                        Resolve_Links  => True,\n+                                        Case_Sensitive => False);\n \n                begin\n                   Name_Len := Normed'Length;\n                   Name_Buffer (1 .. Name_Len) := Normed;\n                   Display := Name_Find;\n-                  Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n+\n+                  Name_Len := Canonical_Path'Length;\n+                  Name_Buffer (1 .. Name_Len) := Canonical_Path;\n                   Dir := Name_Find;\n                end;\n             end if;\n@@ -3637,7 +3667,8 @@ package body Prj.Nmsc is\n       Data            : in out Project_Data;\n       Location        : Source_Ptr;\n       Current_Source  : in out String_List_Id;\n-      Source_Recorded : in out Boolean)\n+      Source_Recorded : in out Boolean;\n+      Trusted_Mode    : Boolean)\n    is\n       Canonical_File_Name : Name_Id;\n       Canonical_Path_Name : Name_Id;\n@@ -3655,9 +3686,18 @@ package body Prj.Nmsc is\n       Get_Name_String (File_Name);\n       Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n       Canonical_File_Name := Name_Find;\n-      Get_Name_String (Path_Name);\n-      Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n-      Canonical_Path_Name := Name_Find;\n+\n+      declare\n+         Canonical_Path : constant String :=\n+                            Normalize_Pathname\n+                              (Get_Name_String (Path_Name),\n+                               Resolve_Links => not Trusted_Mode,\n+                               Case_Sensitive => False);\n+      begin\n+         Name_Len := 0;\n+         Add_Str_To_Name_Buffer (Canonical_Path);\n+         Canonical_Path_Name := Name_Find;\n+      end;\n \n       --  Find out the unit name, the unit kind and if it needs\n       --  a specific SFN pragma."}, {"sha": "b381bacab095897ffb86df364cd2369614de8fbb", "filename": "gcc/ada/prj-part.adb", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2Fprj-part.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2Fprj-part.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-part.adb?ref=6d11af89b1c8723f644edcd243ba109b0cb2507d", "patch": "@@ -863,14 +863,17 @@ package body Prj.Part is\n       Extends_All := False;\n \n       declare\n-         Normed : String := Normalize_Pathname (Path_Name);\n+         Normed_Path : constant String := Normalize_Pathname\n+                  (Path_Name, Resolve_Links => False, Case_Sensitive => True);\n+         Canonical_Path : constant String := Normalize_Pathname\n+           (Normed_Path, Resolve_Links => True, Case_Sensitive => False);\n+\n       begin\n-         Name_Len := Normed'Length;\n-         Name_Buffer (1 .. Name_Len) := Normed;\n+         Name_Len := Normed_Path'Length;\n+         Name_Buffer (1 .. Name_Len) := Normed_Path;\n          Normed_Path_Name := Name_Find;\n-         Canonical_Case_File_Name (Normed);\n-         Name_Len := Normed'Length;\n-         Name_Buffer (1 .. Name_Len) := Normed;\n+         Name_Len := Canonical_Path'Length;\n+         Name_Buffer (1 .. Name_Len) := Canonical_Path;\n          Canonical_Path_Name := Name_Find;\n       end;\n \n@@ -1670,7 +1673,10 @@ package body Prj.Part is\n       else\n          declare\n             Final_Result : constant String :=\n-                             GNAT.OS_Lib.Normalize_Pathname (Result.all);\n+                             GNAT.OS_Lib.Normalize_Pathname\n+                               (Result.all,\n+                                Resolve_Links  => False,\n+                                Case_Sensitive => True);\n          begin\n             Free (Result);\n             return Final_Result;"}, {"sha": "fde749e9eef2efab7173aa80863958ac3b05a947", "filename": "gcc/ada/s-tpobop.adb", "status": "modified", "additions": 102, "deletions": 172, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2Fs-tpobop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2Fs-tpobop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpobop.adb?ref=6d11af89b1c8723f644edcd243ba109b0cb2507d", "patch": "@@ -119,6 +119,15 @@ package body System.Tasking.Protected_Objects.Operations is\n    --  Call this only while holding the PO's lock.\n    --  It returns with the PO's lock still held.\n \n+   procedure Requeue_Call\n+     (Self_Id    : Task_ID;\n+      Object     : Protection_Entries_Access;\n+      Entry_Call : Entry_Call_Link;\n+      With_Abort : Boolean);\n+   --  Handle requeue of Entry_Call.\n+   --  In particular, queue the call if needed, or service it immediately\n+   --  if possible.\n+\n    ---------------------------------\n    -- Cancel_Protected_Entry_Call --\n    ---------------------------------\n@@ -288,11 +297,9 @@ package body System.Tasking.Protected_Objects.Operations is\n       Entry_Call : Entry_Call_Link;\n       With_Abort : Boolean)\n    is\n-      E : Protected_Entry_Index := Protected_Entry_Index (Entry_Call.E);\n-      New_Object        : Protection_Entries_Access;\n-      Ceiling_Violation : Boolean;\n-      Barrier_Value     : Boolean;\n-      Result            : Boolean;\n+      E             : constant Protected_Entry_Index :=\n+                        Protected_Entry_Index (Entry_Call.E);\n+      Barrier_Value : Boolean;\n \n    begin\n       --  When the Action procedure for an entry body returns, it is either\n@@ -339,75 +346,7 @@ package body System.Tasking.Protected_Objects.Operations is\n             end if;\n \n          else\n-            --  Body of current entry requeued the call\n-            New_Object := To_Protection (Entry_Call.Called_PO);\n-\n-            if New_Object = null then\n-\n-               --  Call was requeued to a task\n-\n-               if Single_Lock then\n-                  STPO.Lock_RTS;\n-               end if;\n-\n-               Result := Rendezvous.Task_Do_Or_Queue\n-                 (Self_ID, Entry_Call,\n-                  With_Abort => Entry_Call.Requeue_With_Abort);\n-\n-               if not Result then\n-                  Queuing.Broadcast_Program_Error\n-                   (Self_ID, Object, Entry_Call, RTS_Locked => True);\n-               end if;\n-\n-               if Single_Lock then\n-                  STPO.Unlock_RTS;\n-               end if;\n-\n-               return;\n-            end if;\n-\n-            if Object /= New_Object then\n-               --  Requeue is on a different object\n-\n-               Lock_Entries (New_Object, Ceiling_Violation);\n-\n-               if Ceiling_Violation then\n-                  Object.Call_In_Progress := null;\n-                  Queuing.Broadcast_Program_Error\n-                   (Self_ID, Object, Entry_Call);\n-\n-               else\n-                  PO_Do_Or_Queue (Self_ID, New_Object, Entry_Call, With_Abort);\n-                  PO_Service_Entries (Self_ID, New_Object);\n-               end if;\n-\n-            else\n-               --  Requeue is on same protected object\n-\n-               if Entry_Call.Requeue_With_Abort\n-                 and then Entry_Call.Cancellation_Attempted\n-               then\n-                  --  If this is a requeue with abort and someone tried\n-                  --  to cancel this call, cancel it at this point.\n-\n-                  Entry_Call.State := Cancelled;\n-                  return;\n-               end if;\n-\n-               if not With_Abort or else\n-                 Entry_Call.Mode /= Conditional_Call\n-               then\n-                  E := Protected_Entry_Index (Entry_Call.E);\n-                  Queuing.Enqueue\n-                    (New_Object.Entry_Queues (E), Entry_Call);\n-                  Update_For_Queue_To_PO (Entry_Call, With_Abort);\n-\n-               else\n-                  --  Can we convert this recursion to a loop???\n-\n-                  PO_Do_Or_Queue (Self_ID, New_Object, Entry_Call, With_Abort);\n-               end if;\n-            end if;\n+            Requeue_Call (Self_ID, Object, Entry_Call, With_Abort);\n          end if;\n \n       elsif Entry_Call.Mode /= Conditional_Call\n@@ -447,105 +386,9 @@ package body System.Tasking.Protected_Objects.Operations is\n       Object        : Entries.Protection_Entries_Access;\n       Unlock_Object : Boolean := True)\n    is\n-      procedure Requeue_Call\n-        (Entry_Call      : Entry_Call_Link;\n-         Call_Cancelled  : out Boolean);\n-      --  Handle requeue of Entry_Call.\n-      --  Call_Cancelled is set to True of call was cancelled.\n-\n-      ------------------\n-      -- Requeue_Call --\n-      ------------------\n-\n-      procedure Requeue_Call\n-        (Entry_Call      : Entry_Call_Link;\n-         Call_Cancelled  : out Boolean)\n-      is\n-         New_Object        : Protection_Entries_Access;\n-         Ceiling_Violation : Boolean;\n-         Result            : Boolean;\n-         E                 : Protected_Entry_Index;\n-\n-      begin\n-         Call_Cancelled := False;\n-         New_Object := To_Protection (Entry_Call.Called_PO);\n-\n-         if New_Object = null then\n-\n-            --  Call is to be requeued to a task entry\n-\n-            if Single_Lock then\n-               STPO.Lock_RTS;\n-            end if;\n-\n-            Result := Rendezvous.Task_Do_Or_Queue\n-              (Self_ID, Entry_Call,\n-               With_Abort => Entry_Call.Requeue_With_Abort);\n-\n-            if not Result then\n-               Queuing.Broadcast_Program_Error\n-                 (Self_ID, Object, Entry_Call, RTS_Locked => True);\n-            end if;\n-\n-            if Single_Lock then\n-               STPO.Unlock_RTS;\n-            end if;\n-\n-         else\n-            --  Call should be requeued to a PO\n-\n-            if Object /= New_Object then\n-\n-               --  Requeue is to different PO\n-\n-               Lock_Entries (New_Object, Ceiling_Violation);\n-\n-               if Ceiling_Violation then\n-                  Object.Call_In_Progress := null;\n-                  Queuing.Broadcast_Program_Error\n-                    (Self_ID, Object, Entry_Call);\n-\n-               else\n-                  PO_Do_Or_Queue (Self_ID, New_Object, Entry_Call,\n-                    Entry_Call.Requeue_With_Abort);\n-                  PO_Service_Entries (Self_ID, New_Object);\n-               end if;\n-\n-            else\n-               --  Requeue is to same protected object\n-\n-               if Entry_Call.Requeue_With_Abort\n-                 and then Entry_Call.Cancellation_Attempted\n-               then\n-                  --  If this is a requeue with abort and someone tried\n-                  --  to cancel this call, cancel it at this point.\n-\n-                  Entry_Call.State := Cancelled;\n-                  Call_Cancelled := True;\n-                  return;\n-               end if;\n-\n-               if not Entry_Call.Requeue_With_Abort or else\n-                 Entry_Call.Mode /= Conditional_Call\n-               then\n-                  E := Protected_Entry_Index (Entry_Call.E);\n-                  Queuing.Enqueue\n-                    (New_Object.Entry_Queues (E), Entry_Call);\n-                  Update_For_Queue_To_PO (Entry_Call,\n-                    Entry_Call.Requeue_With_Abort);\n-\n-               else\n-                  PO_Do_Or_Queue (Self_ID, New_Object, Entry_Call,\n-                    Entry_Call.Requeue_With_Abort);\n-               end if;\n-            end if;\n-         end if;\n-      end Requeue_Call;\n-\n       E          : Protected_Entry_Index;\n       Caller     : Task_ID;\n       Entry_Call : Entry_Call_Link;\n-      Cancelled  : Boolean;\n \n    begin\n       loop\n@@ -581,8 +424,9 @@ package body System.Tasking.Protected_Objects.Operations is\n          end;\n \n          if Object.Call_In_Progress = null then\n-            Requeue_Call (Entry_Call, Cancelled);\n-            exit when Cancelled;\n+            Requeue_Call\n+              (Self_ID, Object, Entry_Call, Entry_Call.Requeue_With_Abort);\n+            exit when Entry_Call.State = Cancelled;\n \n          else\n             Object.Call_In_Progress := null;\n@@ -804,6 +648,92 @@ package body System.Tasking.Protected_Objects.Operations is\n       Entry_Calls.Check_Exception (Self_ID, Entry_Call);\n    end Protected_Entry_Call;\n \n+   ------------------\n+   -- Requeue_Call --\n+   ------------------\n+\n+   procedure Requeue_Call\n+     (Self_Id    : Task_ID;\n+      Object     : Protection_Entries_Access;\n+      Entry_Call : Entry_Call_Link;\n+      With_Abort : Boolean)\n+   is\n+      New_Object        : Protection_Entries_Access;\n+      Ceiling_Violation : Boolean;\n+      Result            : Boolean;\n+      E                 : Protected_Entry_Index;\n+\n+   begin\n+      New_Object := To_Protection (Entry_Call.Called_PO);\n+\n+      if New_Object = null then\n+\n+         --  Call is to be requeued to a task entry\n+\n+         if Single_Lock then\n+            STPO.Lock_RTS;\n+         end if;\n+\n+         Result := Rendezvous.Task_Do_Or_Queue\n+           (Self_Id, Entry_Call,\n+            With_Abort => Entry_Call.Requeue_With_Abort);\n+\n+         if not Result then\n+            Queuing.Broadcast_Program_Error\n+              (Self_Id, Object, Entry_Call, RTS_Locked => True);\n+         end if;\n+\n+         if Single_Lock then\n+            STPO.Unlock_RTS;\n+         end if;\n+\n+      else\n+         --  Call should be requeued to a PO\n+\n+         if Object /= New_Object then\n+\n+            --  Requeue is to different PO\n+\n+            Lock_Entries (New_Object, Ceiling_Violation);\n+\n+            if Ceiling_Violation then\n+               Object.Call_In_Progress := null;\n+               Queuing.Broadcast_Program_Error\n+                 (Self_Id, Object, Entry_Call);\n+\n+            else\n+               PO_Do_Or_Queue (Self_Id, New_Object, Entry_Call, With_Abort);\n+               PO_Service_Entries (Self_Id, New_Object);\n+            end if;\n+\n+         else\n+            --  Requeue is to same protected object\n+\n+            if Entry_Call.Requeue_With_Abort\n+              and then Entry_Call.Cancellation_Attempted\n+            then\n+               --  If this is a requeue with abort and someone tried\n+               --  to cancel this call, cancel it at this point.\n+\n+               Entry_Call.State := Cancelled;\n+               return;\n+            end if;\n+\n+            if not With_Abort\n+              or else Entry_Call.Mode /= Conditional_Call\n+            then\n+               E := Protected_Entry_Index (Entry_Call.E);\n+               Queuing.Enqueue\n+                 (New_Object.Entry_Queues (E), Entry_Call);\n+               Update_For_Queue_To_PO (Entry_Call, With_Abort);\n+\n+            else\n+               PO_Do_Or_Queue (Self_Id, New_Object, Entry_Call, With_Abort);\n+            end if;\n+         end if;\n+      end if;\n+   end Requeue_Call;\n+\n    ----------------------------\n    -- Protected_Entry_Caller --\n    ----------------------------"}, {"sha": "370bc1df9995eaafa2a524b4d041f391bd8b6422", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=6d11af89b1c8723f644edcd243ba109b0cb2507d", "patch": "@@ -861,9 +861,19 @@ package body Sem_Attr is\n \n       procedure Check_Dereference is\n       begin\n-         if Is_Object_Reference (P)\n-           and then Is_Access_Type (P_Type)\n+\n+         --  Case of a subtype mark\n+\n+         if Is_Entity_Name (P)\n+           and then Is_Type (Entity (P))\n          then\n+            return;\n+         end if;\n+\n+         --  Case of an expression\n+\n+         Resolve (P);\n+         if Is_Access_Type (P_Type) then\n             Rewrite (P,\n               Make_Explicit_Dereference (Sloc (P),\n                 Prefix => Relocate_Node (P)));"}, {"sha": "94e02cb15041d806ad2d70736d6eea090d749fa5", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=6d11af89b1c8723f644edcd243ba109b0cb2507d", "patch": "@@ -6672,6 +6672,10 @@ package body Sem_Ch12 is\n           Specification => New_Spec,\n           Name => Nam);\n \n+      if No (Actual) and then Box_Present (Formal) then\n+         Set_From_Default (Decl_Node);\n+      end if;\n+\n       --  Gather possible interpretations for the actual before analyzing the\n       --  instance. If overloaded, it will be resolved when analyzing the\n       --  renaming declaration."}, {"sha": "9a61938b03518af74e9e257bfa7b76444fef57b8", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=6d11af89b1c8723f644edcd243ba109b0cb2507d", "patch": "@@ -1356,7 +1356,7 @@ package body Sem_Ch8 is\n       if Old_S /= Any_Id then\n \n          if Is_Actual\n-           and then Box_Present (Inst_Node)\n+           and then From_Default (N)\n          then\n             --  This is an implicit reference to the default actual\n "}, {"sha": "78b5663c1188a8593c0a676d1c9434c68e18de1d", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=6d11af89b1c8723f644edcd243ba109b0cb2507d", "patch": "@@ -963,7 +963,10 @@ package body Sem_Elab is\n       --  will be doing the actual call later, not now, and it\n       --  is at the time of the actual call (statically speaking)\n       --  that we must do our static check, not at the time of\n-      --  its initial analysis).\n+      --  its initial analysis). However, we have to check calls\n+      --  within component definitions (e.g., a function call\n+      --  that determines an array component bound), so we\n+      --  terminate the loop in that case.\n \n       P := Parent (N);\n       while Present (P) loop\n@@ -972,6 +975,13 @@ package body Sem_Elab is\n             Nkind (P) = N_Component_Declaration\n          then\n             return;\n+\n+         --  The call occurs within the constraint of a component,\n+         --  so it must be checked.\n+\n+         elsif Nkind (P) = N_Component_Definition then\n+            exit;\n+\n          else\n             P := Parent (P);\n          end if;"}, {"sha": "4f6e2779e2f7e3c5cc29d1661035de8042bf0ad0", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=6d11af89b1c8723f644edcd243ba109b0cb2507d", "patch": "@@ -3330,6 +3330,13 @@ package body Sem_Util is\n            or else Nkind (Object) = N_Slice\n          then\n             return Is_Dependent_Component_Of_Mutable_Object (Prefix (Object));\n+\n+         elsif Nkind (Object) = N_Type_Conversion then\n+            --  A type conversion that Is_Variable is a view conversion:\n+            --  go back to the denoted object.\n+            return Is_Dependent_Component_Of_Mutable_Object\n+              (Expression (Object));\n+\n          end if;\n       end if;\n "}, {"sha": "03d5b13f9246d9890cfe2c8e3fa4db4d16d82f13", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=6d11af89b1c8723f644edcd243ba109b0cb2507d", "patch": "@@ -1193,6 +1193,14 @@ package body Sinfo is\n       return Flag4 (N);\n    end From_At_Mod;\n \n+   function From_Default\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Subprogram_Renaming_Declaration);\n+      return Flag6 (N);\n+   end From_Default;\n+\n    function Generic_Associations\n       (N : Node_Id) return List_Id is\n    begin\n@@ -3641,6 +3649,14 @@ package body Sinfo is\n       Set_Flag4 (N, Val);\n    end Set_From_At_Mod;\n \n+   procedure Set_From_Default\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Subprogram_Renaming_Declaration);\n+      Set_Flag6 (N, Val);\n+   end Set_From_Default;\n+\n    procedure Set_Generic_Associations\n       (N : Node_Id; Val : List_Id) is\n    begin"}, {"sha": "434ad7172aedc3ea0947123d63c57ac903e2a2ea", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d11af89b1c8723f644edcd243ba109b0cb2507d/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=6d11af89b1c8723f644edcd243ba109b0cb2507d", "patch": "@@ -968,6 +968,13 @@ package Sinfo is\n    --    and the representation clause is considered to be type specific\n    --    instead of subtype specific.\n \n+   --  From_Default (Flag6-Sem)\n+   --    This flag is set on the subprogram renaming declaration created in\n+   --    an instance for a formal subprogram, when the formal is declared\n+   --    with a box, and there is no explicit actual. If the flag is present,\n+   --    the declaration is treated as an implicit reference to the formal in\n+   --    the ali file.\n+\n    --  Generic_Parent (Node5-Sem)\n    --    Generic_parent is defined on declaration nodes that are instances.\n    --    The value of Generic_Parent is the generic entity from which the\n@@ -4341,6 +4348,7 @@ package Sinfo is\n       --  Name (Node2)\n       --  Parent_Spec (Node4-Sem)\n       --  Corresponding_Spec (Node5-Sem)\n+      --  From_Default (Flag6-Sem)\n \n       -----------------------------------------\n       -- 8.5.5  Generic Renaming Declaration --\n@@ -6356,20 +6364,19 @@ package Sinfo is\n       --  The front end also deals with specific cases that are not allowed\n       --  e.g. involving unconstrained array types.\n \n-      --  However, some checks, e.g. the check for suspicious aliasing\n-      --  when converting to a pointer type, can more conveniently be\n-      --  performed in the back end where alias sets are known.\n+      --  For the case of the standard gigi backend, this means that all\n+      --  checks are done in the front-end.\n \n-      --  In addition, for specialized back ends, notably the JVM-based\n-      --  back end for JGNAT, additional requirements and restrictions apply\n+      --  However, in the case of specialized back-ends, notably the JVM\n+      --  backend for JGNAT, additional requirements and restrictions apply\n       --  to unchecked conversion, and these are most conveniently performed\n       --  in the specialized back-end.\n \n-      --  To accommodate this requirement, the following special node is\n-      --  generated recording an unchecked conversion that needs to be\n-      --  validated. The back end should post an appropriate error message\n-      --  error message if the unchecked conversion is invalid or a warning\n-      --  message if a special warning is warranted.\n+      --  To accommodate this requirement, for such back ends, the following\n+      --  special node is generated recording an unchecked conversion that\n+      --  needs to be validated. The back end should post an appropriate\n+      --  error message if the unchecked conversion is invalid or warrants\n+      --  a special warning message.\n \n       --  Source_Type and Target_Type point to the entities for the two\n       --  types involved in the unchecked conversion instantiation that\n@@ -7230,6 +7237,9 @@ package Sinfo is\n    function From_At_Mod\n      (N : Node_Id) return Boolean;    -- Flag4\n \n+   function From_Default\n+     (N : Node_Id) return Boolean;    -- Flag6\n+\n    function Generic_Associations\n      (N : Node_Id) return List_Id;    -- List3\n \n@@ -8013,6 +8023,9 @@ package Sinfo is\n    procedure Set_From_At_Mod\n      (N : Node_Id; Val : Boolean := True);    -- Flag4\n \n+   procedure Set_From_Default\n+     (N : Node_Id; Val : Boolean := True);    -- Flag6\n+\n    procedure Set_Generic_Associations\n      (N : Node_Id; Val : List_Id);            -- List3\n \n@@ -8579,6 +8592,7 @@ package Sinfo is\n    pragma Inline (Formal_Type_Definition);\n    pragma Inline (Forwards_OK);\n    pragma Inline (From_At_Mod);\n+   pragma Inline (From_Default);\n    pragma Inline (Generic_Associations);\n    pragma Inline (Generic_Formal_Declarations);\n    pragma Inline (Generic_Parent);\n@@ -8837,6 +8851,7 @@ package Sinfo is\n    pragma Inline (Set_Formal_Type_Definition);\n    pragma Inline (Set_Forwards_OK);\n    pragma Inline (Set_From_At_Mod);\n+   pragma Inline (Set_From_Default);\n    pragma Inline (Set_Generic_Associations);\n    pragma Inline (Set_Generic_Formal_Declarations);\n    pragma Inline (Set_Generic_Parent);"}]}