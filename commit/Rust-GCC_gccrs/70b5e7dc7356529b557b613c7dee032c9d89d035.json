{"sha": "70b5e7dc7356529b557b613c7dee032c9d89d035", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzBiNWU3ZGM3MzU2NTI5YjU1N2I2MTNjN2RlZTAzMmM5ZDg5ZDAzNQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-08-10T08:29:29Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-08-10T08:29:29Z"}, "message": "tree.h (SSA_NAME_VAR): Return NULL_TREE if an IDENTIFIER_NODE is recorded as var.\n\n2012-08-10  Richard Guenther  <rguenther@suse.de>\n\n\t* tree.h (SSA_NAME_VAR): Return NULL_TREE if an IDENTIFIER_NODE\n\tis recorded as var.\n\t(SSA_NAME_IDENTIFIER): Return the IDENTIFIER_NODE of the SSA_NAME\n\tor its SSA_NAME_VAR.\n\t(SET_SSA_NAME_VAR_OR_IDENTIFIER): New setter.\n\t* tree-ssanames.c (make_ssa_name_fn): Handle creating anonymous\n\tSSA names by passing a type instead of a variable decl.\n\t(release_ssa_name): Use SET_SSA_NAME_VAR_OR_IDENTIFIER.\n\t(copy_ssa_name_fn): Handle anonymous SSA names.\n\t(replace_ssa_name_symbol): Use SET_SSA_NAME_VAR_OR_IDENTIFIER.\n\t* tree-flow-inline.h (make_temp_ssa_name): New inline function.\n\t* tree-pretty-print.c (dump_generic_node): Use SSA_NAME_IDENTIFIER,\n\tdump SSA names without a name as <anon>.\n\t* cfgexpand.c (expand_used_vars): Assing anonymous SSA names we are\n\tgoing to expand a decl.\n\t(gimple_expand_cfg): Assign all SSA names of a partition the\n\tdecl we created for its leader.\n\t* tree-ssa.c (target_for_debug_bind): Handle SSA_NAMEs.\n\t(verify_ssa_name): Handle anonymous SSA names.\n\t(verify_def): Likewise.\n\t* tree-predcom.c (eliminate_temp_copies): Likewise.\n\t* tree-ssa-copyrename.c (copy_rename_partition_coalesce): Likewise.\n\t* tree-ssa-live.c (var_map_base_init): Compute conflicts for\n\tanonymous SSA names with the same type.\n\t(mark_all_vars_used_1): Handle anonymous SSA names.\n\t(verify_live_on_entry): Likewise.\n\t* tree-ssa-coalesce.c (abnormal_corrupt): Remove.\n\t(create_outofssa_var_map): Adjust with respect to conflicts we\n\tcompute for anonymous SSA names.  Do not restrict abnormal\n\tcoalescing.\n\t(coalesce_partitions): Do not restrict abnormal coalescing.\n\tAssert we only ever coalesce variables we computed conflicts for.\n\t* tree-ssa-ter.c (process_replaceable): Do not restrict TER\n\tof anonymous names.\n\t* expr.c (expand_expr_real_1): Handle anonymous SSA names\n\texpanded from IVOPTs by creating a raw REG here.\n\t* tree-cfg.c (replace_ssa_name): Handle anonymous SSA names.\n\t(dump_function_to_file): Dump anonymous SSA names alongside\n\twith their types in the variable list.\n\t(verify_gimple_return): Guard use of SSA_NAME_VAR.\n\t* tree-into-ssa.c (mark_for_renaming): Handle a NULL symbol.\n\t(rewrite_into_ssa): Make SSA names anonymous.\n\t* tree-ssa-structalias.c (alias_get_name): Rewrite.\n\t* tree-ssa-uninit.c (ssa_undefined_value_p): Handle anonymous\n\tSSA names.\n\t(warn_uninitialized_phi): Likewise.\n\t* tree-ssa-loop-ivopts.c (prepare_decl_rtl): Defer expanding\n\tanonymous SSA names to the expander.\n\t(determine_iv_cost): Anonymous SSA names are artificial.\n\t* tree-ssa-loop-manip.c (tree_transform_and_unroll_loop):\n\tHandle anonymous SSA names.\n\t* lto-streamer-out.c (output_ssa_names): Stream SSA_NAME_VAR\n\tor if NULL, the type of the SSA name.\n\t* tree-inline.c (remap_ssa_name): Handle anonymous SSA names,\n\tremap names as anonymous where appropriate.\n\t(insert_init_stmt): Pass SSA names down to insert_init_debug_bind.\n\t* tree-ssa-uncprop.c (uncprop_into_successor_phis): Adjust\n\taccording to what we create conflicts for in out-of-SSA\n\tcoalescing.\n\t* tree-parloops.c (separate_decls_in_region_name): Handle\n\tanonymous SSA names.\n\t(add_field_for_name): Likewise.\n\t* tree.c (get_name): Handle SSA names.\n\t* tree-ssa-loop-im.c (gen_lsm_tmp_name): Defer to get_name for\n\tSSA_NAMEs.\n\t* tree-vect-loop-manip.c (adjust_debug_stmts): Use\n\tvirtual_operand_p.\n\t* tree-sra.c (create_access_replacement): Give up generating\n\ta DECL_DEBUG_EXPR for SSA names in the memory reference.\n\t(replace_removed_params_ssa_names): Guard use of SSA_NAME_VAR.\n\t* tree-complex.c (get_component_ssa_name): Handle anonymous\n\tSSA names.\n\t(set_component_ssa_name): Likewise.\n\t* tree-ssa-sccvn.c (visit_reference_op_load): Likewise.\n\t* tree-object-size.c (collect_object_sizes_for): Handle\n\tuninitialized SSA names properly.\n\t* ipa-inline-analysis.c (eliminated_by_inlining_prob): Guard use of\n\tSSA_NAME_VAR.\n\t* ipa-split.c (test_nonssa_use): Likewise.\n\t(consider_split): Likewise.\n\t(mark_nonssa_use): Likewise.\n\n\tc-family/\n\t* c-pretty-print.c (pp_c_expression): Handle anonymous SSA names.\n\n\tcp/\n\t* error.c (dump_expr): Likewise.\n\n\t* g++.dg/plugin/selfassign.c: Adjust.\n\t* gcc.dg/plugin/selfassign.c: Likewise.\n\t* gcc.dg/strlenopt-11.c: Likewise.\n\t* gcc.dg/strlenopt-13.c: Likewise.\n\t* gcc.dg/no-strict-overflow-4.c: Likewise.\n\t* gcc.dg/strict-overflow-4.c: Likewise.\n\t* gcc.dg/tree-ssa/alias-11.c: Likewise.\n\t* gcc.dg/tree-ssa/alias-6.c: Likewise.\n\t* gcc.dg/tree-ssa/asm-3.c: Likewise.\n\t* gcc.dg/tree-ssa/pr18908.c: Likewise.\n\t* gcc.dg/tree-ssa/pr19431.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-pre-21.c: Likewise.\n\t* gcc.dg/tree-ssa/phi-opt-10.c: Likewise.\n\t* gcc.dg/tree-ssa/phi-opt-7.c: Likewise.\n\t* gcc.dg/tree-ssa/slsr-27.c: Likewise.\n\t* gcc.dg/tree-ssa/slsr-28.c: Likewise.\n\t* gcc.dg/tree-ssa/slsr-29.c: Likewise.\n\t* gcc.dg/pr46309.c: Likewise.\n\t* gcc.dg/tree-ssa/loop-5.c: Likewise.\n\nFrom-SVN: r190284", "tree": {"sha": "997e1b096111bead6b6ecba118fde1adf2e1a6ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/997e1b096111bead6b6ecba118fde1adf2e1a6ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70b5e7dc7356529b557b613c7dee032c9d89d035", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70b5e7dc7356529b557b613c7dee032c9d89d035", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70b5e7dc7356529b557b613c7dee032c9d89d035", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70b5e7dc7356529b557b613c7dee032c9d89d035/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c170d40f35ca1d3b3ee6b152066b0abef9c8c93a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c170d40f35ca1d3b3ee6b152066b0abef9c8c93a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c170d40f35ca1d3b3ee6b152066b0abef9c8c93a"}], "stats": {"total": 791, "additions": 554, "deletions": 237}, "files": [{"sha": "9a9a9ce184e8c8730ef997e81ca4f8ef67cfa735", "filename": "gcc/ChangeLog", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -1,3 +1,87 @@\n+2012-08-10  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree.h (SSA_NAME_VAR): Return NULL_TREE if an IDENTIFIER_NODE\n+\tis recorded as var.\n+\t(SSA_NAME_IDENTIFIER): Return the IDENTIFIER_NODE of the SSA_NAME\n+\tor its SSA_NAME_VAR.\n+\t(SET_SSA_NAME_VAR_OR_IDENTIFIER): New setter.\n+\t* tree-ssanames.c (make_ssa_name_fn): Handle creating anonymous\n+\tSSA names by passing a type instead of a variable decl.\n+\t(release_ssa_name): Use SET_SSA_NAME_VAR_OR_IDENTIFIER.\n+\t(copy_ssa_name_fn): Handle anonymous SSA names.\n+\t(replace_ssa_name_symbol): Use SET_SSA_NAME_VAR_OR_IDENTIFIER.\n+\t* tree-flow-inline.h (make_temp_ssa_name): New inline function.\n+\t* tree-pretty-print.c (dump_generic_node): Use SSA_NAME_IDENTIFIER,\n+\tdump SSA names without a name as <anon>.\n+\t* cfgexpand.c (expand_used_vars): Assing anonymous SSA names we are\n+\tgoing to expand a decl.\n+\t(gimple_expand_cfg): Assign all SSA names of a partition the\n+\tdecl we created for its leader.\n+\t* tree-ssa.c (target_for_debug_bind): Handle SSA_NAMEs.\n+\t(verify_ssa_name): Handle anonymous SSA names.\n+\t(verify_def): Likewise.\n+\t* tree-predcom.c (eliminate_temp_copies): Likewise.\n+\t* tree-ssa-copyrename.c (copy_rename_partition_coalesce): Likewise.\n+\t* tree-ssa-live.c (var_map_base_init): Compute conflicts for\n+\tanonymous SSA names with the same type.\n+\t(mark_all_vars_used_1): Handle anonymous SSA names.\n+\t(verify_live_on_entry): Likewise.\n+\t* tree-ssa-coalesce.c (abnormal_corrupt): Remove.\n+\t(create_outofssa_var_map): Adjust with respect to conflicts we\n+\tcompute for anonymous SSA names.  Do not restrict abnormal\n+\tcoalescing.\n+\t(coalesce_partitions): Do not restrict abnormal coalescing.\n+\tAssert we only ever coalesce variables we computed conflicts for.\n+\t* tree-ssa-ter.c (process_replaceable): Do not restrict TER\n+\tof anonymous names.\n+\t* expr.c (expand_expr_real_1): Handle anonymous SSA names\n+\texpanded from IVOPTs by creating a raw REG here.\n+\t* tree-cfg.c (replace_ssa_name): Handle anonymous SSA names.\n+\t(dump_function_to_file): Dump anonymous SSA names alongside\n+\twith their types in the variable list.\n+\t(verify_gimple_return): Guard use of SSA_NAME_VAR.\n+\t* tree-into-ssa.c (mark_for_renaming): Handle a NULL symbol.\n+\t(rewrite_into_ssa): Make SSA names anonymous.\n+\t* tree-ssa-structalias.c (alias_get_name): Rewrite.\n+\t* tree-ssa-uninit.c (ssa_undefined_value_p): Handle anonymous\n+\tSSA names.\n+\t(warn_uninitialized_phi): Likewise.\n+\t* tree-ssa-loop-ivopts.c (prepare_decl_rtl): Defer expanding\n+\tanonymous SSA names to the expander.\n+\t(determine_iv_cost): Anonymous SSA names are artificial.\n+\t* tree-ssa-loop-manip.c (tree_transform_and_unroll_loop):\n+\tHandle anonymous SSA names.\n+\t* lto-streamer-out.c (output_ssa_names): Stream SSA_NAME_VAR\n+\tor if NULL, the type of the SSA name.\n+\t* tree-inline.c (remap_ssa_name): Handle anonymous SSA names,\n+\tremap names as anonymous where appropriate.\n+\t(insert_init_stmt): Pass SSA names down to insert_init_debug_bind.\n+\t* tree-ssa-uncprop.c (uncprop_into_successor_phis): Adjust\n+\taccording to what we create conflicts for in out-of-SSA\n+\tcoalescing.\n+\t* tree-parloops.c (separate_decls_in_region_name): Handle\n+\tanonymous SSA names.\n+\t(add_field_for_name): Likewise.\n+\t* tree.c (get_name): Handle SSA names.\n+\t* tree-ssa-loop-im.c (gen_lsm_tmp_name): Defer to get_name for\n+\tSSA_NAMEs.\n+\t* tree-vect-loop-manip.c (adjust_debug_stmts): Use\n+\tvirtual_operand_p.\n+\t* tree-sra.c (create_access_replacement): Give up generating\n+\ta DECL_DEBUG_EXPR for SSA names in the memory reference.\n+\t(replace_removed_params_ssa_names): Guard use of SSA_NAME_VAR.\n+\t* tree-complex.c (get_component_ssa_name): Handle anonymous\n+\tSSA names.\n+\t(set_component_ssa_name): Likewise.\n+\t* tree-ssa-sccvn.c (visit_reference_op_load): Likewise.\n+\t* tree-object-size.c (collect_object_sizes_for): Handle\n+\tuninitialized SSA names properly.\n+\t* ipa-inline-analysis.c (eliminated_by_inlining_prob): Guard use of\n+\tSSA_NAME_VAR.\n+\t* ipa-split.c (test_nonssa_use): Likewise.\n+\t(consider_split): Likewise.\n+\t(mark_nonssa_use): Likewise.\n+\n 2012-08-09  Jan Hubicka  <jh@suse.cz>\n \n \tPR middle-end/54146"}, {"sha": "c460b3586126f4b0c21d92201b3dfb41392fd0e5", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -1,3 +1,7 @@\n+2012-08-10  Richard Guenther  <rguenther@suse.de>\n+\n+\t* c-pretty-print.c (pp_c_expression): Handle anonymous SSA names.\n+\n 2012-08-07  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* c-pretty-print.c (pp_c_function_definition): Use pp_newline_and_flush"}, {"sha": "edeccce7a12cf8225a6c96dbebc09e71a8c6c032", "filename": "gcc/c-family/c-pretty-print.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Fc-family%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Fc-family%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pretty-print.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -2141,7 +2141,8 @@ pp_c_expression (c_pretty_printer *pp, tree e)\n       break;\n \n     case SSA_NAME:\n-      if (!DECL_ARTIFICIAL (SSA_NAME_VAR (e)))\n+      if (SSA_NAME_VAR (e)\n+\t  && !DECL_ARTIFICIAL (SSA_NAME_VAR (e)))\n \tpp_c_expression (pp, SSA_NAME_VAR (e));\n       else\n \tpp_c_ws_string (pp, M_(\"<unknown>\"));"}, {"sha": "c6cd4e290891513ac68f810c81a0b516977f0e1e", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -1453,6 +1453,7 @@ expand_used_vars (void)\n {\n   tree var, outer_block = DECL_INITIAL (current_function_decl);\n   VEC(tree,heap) *maybe_local_decls = NULL;\n+  struct pointer_map_t *ssa_name_decls;\n   unsigned i;\n   unsigned len;\n \n@@ -1465,11 +1466,23 @@ expand_used_vars (void)\n \n   init_vars_expansion ();\n \n+  ssa_name_decls = pointer_map_create ();\n   for (i = 0; i < SA.map->num_partitions; i++)\n     {\n       tree var = partition_to_var (SA.map, i);\n \n       gcc_assert (is_gimple_reg (var));\n+\n+      /* Assign decls to each SSA name partition, share decls for partitions\n+         we could have coalesced (those with the same type).  */\n+      if (SSA_NAME_VAR (var) == NULL_TREE)\n+\t{\n+\t  void **slot = pointer_map_insert (ssa_name_decls, TREE_TYPE (var));\n+\t  if (!*slot)\n+\t    *slot = (void *) create_tmp_reg (TREE_TYPE (var), NULL);\n+\t  replace_ssa_name_symbol (var, (tree) *slot);\n+\t}\n+\n       if (TREE_CODE (SSA_NAME_VAR (var)) == VAR_DECL)\n \texpand_one_var (var, true, true);\n       else\n@@ -1486,6 +1499,7 @@ expand_used_vars (void)\n \t    }\n \t}\n     }\n+  pointer_map_destroy (ssa_name_decls);\n \n   /* At this point all variables on the local_decls with TREE_USED\n      set are not associated with any block scope.  Lay them out.  */\n@@ -4450,7 +4464,6 @@ gimple_expand_cfg (void)\n       rtx r;\n \n       if (!name\n-\t  || !POINTER_TYPE_P (TREE_TYPE (name))\n \t  /* We might have generated new SSA names in\n \t     update_alias_info_with_stack_vars.  They will have a NULL\n \t     defining statements, and won't be part of the partitioning,\n@@ -4460,6 +4473,18 @@ gimple_expand_cfg (void)\n       part = var_to_partition (SA.map, name);\n       if (part == NO_PARTITION)\n \tcontinue;\n+\n+      /* Adjust all partition members to get the underlying decl of\n+\t the representative which we might have created in expand_one_var.  */\n+      if (SSA_NAME_VAR (name) == NULL_TREE)\n+\t{\n+\t  tree leader = partition_to_var (SA.map, part);\n+\t  gcc_assert (SSA_NAME_VAR (leader) != NULL_TREE);\n+\t  replace_ssa_name_symbol (name, SSA_NAME_VAR (leader));\n+\t}\n+      if (!POINTER_TYPE_P (TREE_TYPE (name)))\n+\tcontinue;\n+\n       r = SA.partition_to_pseudo[part];\n       if (REG_P (r))\n \tmark_reg_pointer (r, get_pointer_alignment (name));"}, {"sha": "b967735d2b53fb5a931f402bdb27b969a6d26dd5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -1,3 +1,7 @@\n+2012-08-10  Richard Guenther  <rguenther@suse.de>\n+\n+\t* error.c (dump_expr): Handle anonymous SSA names.\n+\n 2012-08-07  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* error.c (print_instantiation_context): Pretty-print a newline before"}, {"sha": "40f96d33f9bdfbdbfdbdb159a4dfa36d21c5964f", "filename": "gcc/cp/error.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -1803,7 +1803,8 @@ dump_expr (tree t, int flags)\n       break;\n \n     case SSA_NAME:\n-      if (!DECL_ARTIFICIAL (SSA_NAME_VAR (t)))\n+      if (SSA_NAME_VAR (t)\n+\t  && !DECL_ARTIFICIAL (SSA_NAME_VAR (t)))\n \tdump_expr (SSA_NAME_VAR (t), flags);\n       else\n \tpp_cxx_ws_string (cxx_pp, M_(\"<unknown>\"));"}, {"sha": "69e043dd4d9967e1a6ca979237f70bb87d1d1200", "filename": "gcc/expr.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -9159,8 +9159,13 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t base variable.  This unnecessarily allocates a pseudo, see how we can\n \t reuse it, if partition base vars have it set already.  */\n       if (!currently_expanding_to_rtl)\n-\treturn expand_expr_real_1 (SSA_NAME_VAR (exp), target, tmode, modifier,\n-\t\t\t\t   NULL);\n+\t{\n+\t  tree var = SSA_NAME_VAR (exp);\n+\t  if (var && DECL_RTL_SET_P (var))\n+\t    return DECL_RTL (var);\n+\t  return gen_raw_REG (TYPE_MODE (TREE_TYPE (exp)),\n+\t\t\t      LAST_VIRTUAL_REGISTER + 1);\n+\t}\n \n       g = get_gimple_for_ssa_name (exp);\n       /* For EXPAND_INITIALIZER try harder to get something simpler.  */"}, {"sha": "41d556a3afc83ba2670512e2e1cebcdb229f25b1", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -1394,9 +1394,9 @@ eliminated_by_inlining_prob (gimple stmt)\n \t        || (TREE_CODE(inner_lhs) == MEM_REF\n \t\t     && (unmodified_parm (stmt, TREE_OPERAND (inner_lhs, 0))\n \t\t\t || (TREE_CODE (TREE_OPERAND (inner_lhs, 0)) == SSA_NAME\n-\t\t\t     && TREE_CODE (SSA_NAME_VAR\n-\t\t\t\t\t    (TREE_OPERAND (inner_lhs, 0)))\n-\t\t\t     == RESULT_DECL))))\n+\t\t\t     && SSA_NAME_VAR (TREE_OPERAND (inner_lhs, 0))\n+\t\t\t     && TREE_CODE (SSA_NAME_VAR (TREE_OPERAND\n+\t\t\t\t  (inner_lhs, 0))) == RESULT_DECL))))\n \t      lhs_free = true;\n \t    if (lhs_free\n \t\t&& (is_gimple_reg (rhs) || is_gimple_min_invariant (rhs)))"}, {"sha": "2b5bc22b60fe10eb2e24ae3b2f667c577456164a", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -157,6 +157,7 @@ test_nonssa_use (gimple stmt ATTRIBUTE_UNUSED, tree t, void *data)\n      to pretend that the value pointed to is actual result decl.  */\n   if ((TREE_CODE (t) == MEM_REF || INDIRECT_REF_P (t))\n       && TREE_CODE (TREE_OPERAND (t, 0)) == SSA_NAME\n+      && SSA_NAME_VAR (TREE_OPERAND (t, 0))\n       && TREE_CODE (SSA_NAME_VAR (TREE_OPERAND (t, 0))) == RESULT_DECL\n       && DECL_BY_REFERENCE (DECL_RESULT (current_function_decl)))\n     return\n@@ -525,6 +526,7 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n   /* Special case is value returned by reference we record as if it was non-ssa\n      set to result_decl.  */\n   else if (TREE_CODE (retval) == SSA_NAME\n+\t   && SSA_NAME_VAR (retval)\n \t   && TREE_CODE (SSA_NAME_VAR (retval)) == RESULT_DECL\n \t   && DECL_BY_REFERENCE (DECL_RESULT (current_function_decl)))\n     current->split_part_set_retval\n@@ -698,6 +700,7 @@ mark_nonssa_use (gimple stmt ATTRIBUTE_UNUSED, tree t, void *data)\n      to pretend that the value pointed to is actual result decl.  */\n   if ((TREE_CODE (t) == MEM_REF || INDIRECT_REF_P (t))\n       && TREE_CODE (TREE_OPERAND (t, 0)) == SSA_NAME\n+      && SSA_NAME_VAR (TREE_OPERAND (t, 0))\n       && TREE_CODE (SSA_NAME_VAR (TREE_OPERAND (t, 0))) == RESULT_DECL\n       && DECL_BY_REFERENCE (DECL_RESULT (current_function_decl)))\n     return"}, {"sha": "a0eac254c8f79c2b88cbac1623f26f4b313d0769", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -619,7 +619,11 @@ output_ssa_names (struct output_block *ob, struct function *fn)\n       streamer_write_uhwi (ob, i);\n       streamer_write_char_stream (ob->main_stream,\n \t\t\t\t  SSA_NAME_IS_DEFAULT_DEF (ptr));\n-      stream_write_tree (ob, SSA_NAME_VAR (ptr), true);\n+      if (SSA_NAME_VAR (ptr))\n+\tstream_write_tree (ob, SSA_NAME_VAR (ptr), true);\n+      else\n+\t/* ???  This drops SSA_NAME_IDENTIFIER on the floor.  */\n+\tstream_write_tree (ob, TREE_TYPE (ptr), true);\n     }\n \n   streamer_write_zero (ob);"}, {"sha": "be6b56a721b2205c565f96dd9b85b784adaaf346", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -1,3 +1,25 @@\n+2012-08-10  Richard Guenther  <rguenther@suse.de>\n+\n+\t* g++.dg/plugin/selfassign.c: Adjust.\n+\t* gcc.dg/plugin/selfassign.c: Likewise.\n+\t* gcc.dg/strlenopt-11.c: Likewise.\n+\t* gcc.dg/strlenopt-13.c: Likewise.\n+\t* gcc.dg/no-strict-overflow-4.c: Likewise.\n+\t* gcc.dg/strict-overflow-4.c: Likewise.\n+\t* gcc.dg/tree-ssa/alias-11.c: Likewise.\n+\t* gcc.dg/tree-ssa/alias-6.c: Likewise.\n+\t* gcc.dg/tree-ssa/asm-3.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr18908.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr19431.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-pre-21.c: Likewise.\n+\t* gcc.dg/tree-ssa/phi-opt-10.c: Likewise.\n+\t* gcc.dg/tree-ssa/phi-opt-7.c: Likewise.\n+\t* gcc.dg/tree-ssa/slsr-27.c: Likewise.\n+\t* gcc.dg/tree-ssa/slsr-28.c: Likewise.\n+\t* gcc.dg/tree-ssa/slsr-29.c: Likewise.\n+\t* gcc.dg/pr46309.c: Likewise.\n+\t* gcc.dg/tree-ssa/loop-5.c: Likewise.\n+\n 2012-08-09  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.c-torture/compile/20120727-1.c (dg-options): Add -mfpmath=387"}, {"sha": "2c417744f9e6b5d013420387b8bc6cc77f417d04", "filename": "gcc/testsuite/g++.dg/plugin/selfassign.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fselfassign.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fselfassign.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fselfassign.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -46,7 +46,7 @@ get_real_ref_rhs (tree expr)\n              e.g. D.1797_14, we need to grab the rhs of its SSA def\n              statement (i.e. foo.x).  */\n           tree vdecl = SSA_NAME_VAR (expr);\n-          if (DECL_ARTIFICIAL (vdecl)\n+          if ((!vdecl || DECL_ARTIFICIAL (vdecl))\n               && !gimple_nop_p (SSA_NAME_DEF_STMT (expr)))\n             {\n               gimple def_stmt = SSA_NAME_DEF_STMT (expr);\n@@ -86,6 +86,8 @@ get_real_ref_rhs (tree expr)\n static tree\n get_non_ssa_expr (tree expr)\n {\n+  if (!expr)\n+    return NULL_TREE;\n   switch (TREE_CODE (expr))\n     {\n       case VAR_DECL:\n@@ -149,7 +151,7 @@ get_non_ssa_expr (tree expr)\n       case SSA_NAME:\n         {\n           tree vdecl = SSA_NAME_VAR (expr);\n-          if (DECL_ARTIFICIAL (vdecl)\n+          if ((!vdecl || DECL_ARTIFICIAL (vdecl))\n               && !gimple_nop_p (SSA_NAME_DEF_STMT (expr)))\n             {\n               gimple def_stmt = SSA_NAME_DEF_STMT (expr);\n@@ -209,7 +211,7 @@ warn_self_assign (gimple stmt)\n       if (TREE_CODE (lhs) == SSA_NAME)\n         {\n           lhs = SSA_NAME_VAR (lhs);\n-          if (DECL_ARTIFICIAL (lhs))\n+          if (!lhs || DECL_ARTIFICIAL (lhs))\n             return;\n         }\n "}, {"sha": "c3b57bba022b6c505e2a282edfda9ed90084d144", "filename": "gcc/testsuite/gcc.dg/no-strict-overflow-4.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-4.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -12,8 +12,5 @@ foo (int i)\n   return i + 1 > i;\n }\n \n-/* We expect to see \"<bb N>\"; confirm that, so that we know to count\n-   it in the real test.  */\n-/* { dg-final { scan-tree-dump-times \"<bb\\[^>\\]*>\" 1 \"optimized\" } } */\n-/* { dg-final { scan-tree-dump-times \">|<\" 3 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"\\[^ \\]*_.(\\\\\\(D\\\\\\))? (>|<) \\[^ \\]*_.\" \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "2c417744f9e6b5d013420387b8bc6cc77f417d04", "filename": "gcc/testsuite/gcc.dg/plugin/selfassign.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fselfassign.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fselfassign.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fselfassign.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -46,7 +46,7 @@ get_real_ref_rhs (tree expr)\n              e.g. D.1797_14, we need to grab the rhs of its SSA def\n              statement (i.e. foo.x).  */\n           tree vdecl = SSA_NAME_VAR (expr);\n-          if (DECL_ARTIFICIAL (vdecl)\n+          if ((!vdecl || DECL_ARTIFICIAL (vdecl))\n               && !gimple_nop_p (SSA_NAME_DEF_STMT (expr)))\n             {\n               gimple def_stmt = SSA_NAME_DEF_STMT (expr);\n@@ -86,6 +86,8 @@ get_real_ref_rhs (tree expr)\n static tree\n get_non_ssa_expr (tree expr)\n {\n+  if (!expr)\n+    return NULL_TREE;\n   switch (TREE_CODE (expr))\n     {\n       case VAR_DECL:\n@@ -149,7 +151,7 @@ get_non_ssa_expr (tree expr)\n       case SSA_NAME:\n         {\n           tree vdecl = SSA_NAME_VAR (expr);\n-          if (DECL_ARTIFICIAL (vdecl)\n+          if ((!vdecl || DECL_ARTIFICIAL (vdecl))\n               && !gimple_nop_p (SSA_NAME_DEF_STMT (expr)))\n             {\n               gimple def_stmt = SSA_NAME_DEF_STMT (expr);\n@@ -209,7 +211,7 @@ warn_self_assign (gimple stmt)\n       if (TREE_CODE (lhs) == SSA_NAME)\n         {\n           lhs = SSA_NAME_VAR (lhs);\n-          if (DECL_ARTIFICIAL (lhs))\n+          if (!lhs || DECL_ARTIFICIAL (lhs))\n             return;\n         }\n "}, {"sha": "ee154ccd2f3cfe41c7629dc4781044346546fe63", "filename": "gcc/testsuite/gcc.dg/pr46309.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Fpr46309.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Fpr46309.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr46309.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -65,6 +65,6 @@ f6 (unsigned int a)\n /* { dg-final { scan-tree-dump-times \"Optimizing range tests a_\\[0-9\\]*.D. -.1, 1. and -.2, 2.\\[\\n\\r\\]* into\" 1 \"reassoc1\" } } */\n /* { dg-final { scan-tree-dump-times \"Optimizing range tests a_\\[0-9\\]*.D. -.0, 31. and -.64, 95.\\[\\n\\r\\]* into\" 2 \"reassoc1\" } } */\n /* { dg-final { scan-tree-dump-times \"Optimizing range tests a_\\[0-9\\]*.D. -.128, 159. and -.192, 223.\\[\\n\\r\\]* into\" 1 \"reassoc1\" } } */\n-/* { dg-final { scan-tree-dump-times \"Optimizing range tests D.\\[0-9\\]*_\\[0-9\\]* -.0, 31. and -.128, 159.\\[\\n\\r\\]* into\" 1 \"reassoc2\" } } */\n+/* { dg-final { scan-tree-dump-times \"Optimizing range tests \\[^\\r\\n\\]*_\\[0-9\\]* -.0, 31. and -.128, 159.\\[\\n\\r\\]* into\" 1 \"reassoc2\" } } */\n /* { dg-final { cleanup-tree-dump \"reassoc1\" } } */\n /* { dg-final { cleanup-tree-dump \"reassoc2\" } } */"}, {"sha": "ad2d635e464bbb38cf5d7be68ccdcf54a3960f52", "filename": "gcc/testsuite/gcc.dg/strict-overflow-4.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-4.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -12,8 +12,5 @@ foo (int i)\n   return i + 1 > i;\n }\n \n-/* We expect to see \"<bb N>\"; confirm that, so that we know to count\n-   it in the real test.  */\n-/* { dg-final { scan-tree-dump-times \"<bb\\[^>\\]*>\" 1 \"optimized\" } } */\n-/* { dg-final { scan-tree-dump-times \">|<\" 2 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"return 1;\" \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "888eeb20cdcb6db331770c1185ff11e0aeadb23b", "filename": "gcc/testsuite/gcc.dg/strlenopt-11.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-11.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -64,7 +64,7 @@ main ()\n /* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n /* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n /* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"  D\\.\\[0-9_\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.0. = \" 1 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"  D\\.\\[0-9_\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.6. = \" 1 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"  D\\.\\[0-9_\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.9. = \" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.0. = \" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.6. = \" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.9. = \" 1 \"strlen\" } } */\n /* { dg-final { cleanup-tree-dump \"strlen\" } } */"}, {"sha": "9413cb53e2fe59b492bd1d06e97eb257e251fa82", "filename": "gcc/testsuite/gcc.dg/strlenopt-13.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-13.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -61,8 +61,8 @@ main ()\n /* { dg-final { scan-tree-dump-times \"strcat \\\\(\" 0 \"strlen\" } } */\n /* { dg-final { scan-tree-dump-times \"strchr \\\\(\" 0 \"strlen\" } } */\n /* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 0 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"  D\\.\\[0-9_\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.0. = \" 1 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"  D\\.\\[0-9_\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.1. = \" 1 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"  D\\.\\[0-9_\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.5. = \" 1 \"strlen\" } } */\n-/* { dg-final { scan-tree-dump-times \"  D\\.\\[0-9_\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.6. = \" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.0. = \" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.1. = \" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.5. = \" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"  _\\[0-9\\]* = strlen \\\\(\\[^\\n\\r\\]*;\\[\\n\\r\\]*  l.6. = \" 1 \"strlen\" } } */\n /* { dg-final { cleanup-tree-dump \"strlen\" } } */"}, {"sha": "1f8a12d85e2599b9585b1eebada7d2082184ea0c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/alias-11.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-11.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -15,7 +15,7 @@ int bar(void)\n }\n \n /* We need to have both: a load from \"a[0]\" and a load from \"*p.a\",\n-   the latter can be an ssa temporary.  */\n+   the latter is an ssa temporary.  */\n /* { dg-final { scan-tree-dump \"= a.0.;\" \"optimized\" } } */\n-/* { dg-final { scan-tree-dump \"= \\\\*\\[pD\\]\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"= \\\\*\\[^\\r\\n\\]*_.;\" \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "9a41920e76f28b47b5d165865b85b1bf4a7ef48d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/alias-6.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-6.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -15,7 +15,7 @@ int bar(void)\n }\n \n /* We need to have both: a load from \"a[0]\" and a load from \"*p.a\",\n-   the latter can be an ssa temporary.  */\n+   the latter is an ssa temporary.  */\n /* { dg-final { scan-tree-dump \"= a.0.;\" \"optimized\" } } */\n-/* { dg-final { scan-tree-dump \"= \\\\*\\[pD\\]\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"= \\\\*\\[^\\r\\n\\]*_.;\" \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "29b27f4ff563fbb658b139f47443f94c31f1f9c0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/asm-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fasm-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fasm-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fasm-3.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -31,6 +31,6 @@ void test(void)\n /* { dg-final { scan-tree-dump-times \"hardreg\" 3 \"optimized\" } } */\n \n /* In particular, hardreg should *not* appear in the call to bar.  */\n-/* { dg-final { scan-tree-dump-times \"bar \\[(\\]t_.\\[)\\]\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"bar \\[(\\]\\[^\\n\\r\\]*_.\\[)\\]\" 1 \"optimized\" } } */\n \n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "e9ff9fcfe38b6c34cb606b835792f9051646b12c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-5.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -18,7 +18,7 @@ void xxx(void)\n \n /* Only iter variable should remain.  */\n \n-/* { dg-final { scan-tree-dump-times \"int iter\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"int jiter\" 0 \"optimized\" } } */\n \n /* And jter shouldn't be an induction variable anymore (no PHI node).  */\n /* { dg-final { scan-tree-dump-times \"jter_\\[0-9\\]* = PHI\" 0 \"optimized\" } } */"}, {"sha": "62d007d4548ecd862b199636144045343da05137", "filename": "gcc/testsuite/gcc.dg/tree-ssa/phi-opt-10.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-10.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -7,5 +7,5 @@ int eqm1_phi (unsigned long a) { return a ? 0 : -1; }\n int spaceship1 (long a) { return a > 0 ? 1 : a < 0 ? -1 : 0; }\n int spaceship2 (long a) { return a > 0 ? 1 : a == 0 ? 0 : -1; }\n \n-/* { dg-final { scan-tree-dump-times \" = -D\" 4 \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-times \" = -\\[^\\r\\n\\]*_.;\" 4 \"optimized\"} } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "bd897554e2a5a5373d82e6b3bc5955000f652f15", "filename": "gcc/testsuite/gcc.dg/tree-ssa/phi-opt-7.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-7.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -18,6 +18,6 @@ int f(int t, int c)\n /* There should be one ifs as one of them should be changed into\n    a conditional and the other should be there still.  */\n /* { dg-final { scan-tree-dump-times \"if\" 1 \"optimized\" }  }*/\n-/* { dg-final { scan-tree-dump-times \"D.\\[0-9\\]*_\\[0-9\\]* = c_\\[0-9\\]*.D. != 0\" 1 \"optimized\"  } } */\n+/* { dg-final { scan-tree-dump-times \"\\[^\\r\\n\\]*_. = c_\\[0-9\\]*.D. != 0\" 1 \"optimized\"  } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */\n "}, {"sha": "3707efe36c37d118f308c082889f8114f727cd30", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr18908.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18908.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18908.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr18908.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -4,6 +4,6 @@\n _Bool f3(_Bool *p) { *p ^= 1; }\n \n /* We should be able to canonicalize the above to use bitwise not.  */\n-/* { dg-final { scan-tree-dump \"~D\" \"forwprop1\" } } */\n+/* { dg-final { scan-tree-dump \"~\\[^\\n\\r\\]*_.;\" \"forwprop1\" } } */\n /* { dg-final { scan-tree-dump-not \"\\\\\\^ 1\" \"forwprop1\" } } */\n /* { dg-final { cleanup-tree-dump \"forwprop1\" } } */"}, {"sha": "08972063e0d5df8c57c903d0aea1092f71b254cd", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr19431.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19431.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19431.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19431.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -24,6 +24,5 @@ int f(int k, int i1, int j1)\n   return *f1;\n }\n \n-/* { dg-final { scan-tree-dump \"i1_. = PHI <i1_\\[^,\\]*, j1_\\[^>\\]*>\" \"optimized\" } } */\n-/* { dg-final { scan-tree-dump \"return i1_.;\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"\\[^\\r\\n\\]*_. = PHI <i1_\\[^,\\]*, j1_\\[^>\\]*>\" \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "eb5734ae5433db0687afb1c953003d370d7cf7c8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-27.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-27.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -17,6 +17,6 @@ f (struct x *p, unsigned int n)\n }\n \n /* { dg-final { scan-tree-dump-times \"\\\\* 4;\" 1 \"dom2\" } } */\n-/* { dg-final { scan-tree-dump-times \"p_\\\\d\\+\\\\(D\\\\) \\\\+ D\" 1 \"dom2\" } } */\n-/* { dg-final { scan-tree-dump-times \"MEM\\\\\\[\\\\(struct x \\\\*\\\\)D\" 3 \"dom2\" } } */\n+/* { dg-final { scan-tree-dump-times \"p_\\\\d\\+\\\\(D\\\\) \\\\+ \\[^\\r\\n\\]*_\\\\d\\+;\" 1 \"dom2\" } } */\n+/* { dg-final { scan-tree-dump-times \"MEM\\\\\\[\\\\(struct x \\\\*\\\\)\\[^\\r\\n\\]*_\\\\d\\+\" 3 \"dom2\" } } */\n /* { dg-final { cleanup-tree-dump \"dom2\" } } */"}, {"sha": "7e7c7516e6a689e0c087a1bba26cf5155ae3c22a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-28.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-28.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -21,6 +21,6 @@ f (struct x *p, unsigned int n)\n }\n \n /* { dg-final { scan-tree-dump-times \"\\\\* 4;\" 1 \"dom2\" } } */\n-/* { dg-final { scan-tree-dump-times \"p_\\\\d\\+\\\\(D\\\\) \\\\+ D\" 1 \"dom2\" } } */\n-/* { dg-final { scan-tree-dump-times \"MEM\\\\\\[\\\\(struct x \\\\*\\\\)D\" 9 \"dom2\" } } */\n+/* { dg-final { scan-tree-dump-times \"p_\\\\d\\+\\\\(D\\\\) \\\\+ \\[^\\r\\n\\]*_\\\\d\\+\" 1 \"dom2\" } } */\n+/* { dg-final { scan-tree-dump-times \"MEM\\\\\\[\\\\(struct x \\\\*\\\\)\\[^\\r\\n\\]*_\\\\d\\+\" 9 \"dom2\" } } */\n /* { dg-final { cleanup-tree-dump \"dom2\" } } */"}, {"sha": "2a8fe0e6d6ca7f2bee6a7384abba298396e026ed", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-29.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-29.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-29.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-29.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -23,6 +23,6 @@ f (struct x *p, unsigned int n)\n }\n \n /* { dg-final { scan-tree-dump-times \"\\\\* 4;\" 1 \"dom2\" } } */\n-/* { dg-final { scan-tree-dump-times \"p_\\\\d\\+\\\\(D\\\\) \\\\+ D\" 1 \"dom2\" } } */\n-/* { dg-final { scan-tree-dump-times \"MEM\\\\\\[\\\\(struct x \\\\*\\\\)D\" 9 \"dom2\" } } */\n+/* { dg-final { scan-tree-dump-times \"p_\\\\d\\+\\\\(D\\\\) \\\\+ \\[^\\r\\n\\]*_\\\\d\\+\" 1 \"dom2\" } } */\n+/* { dg-final { scan-tree-dump-times \"MEM\\\\\\[\\\\(struct x \\\\*\\\\)\\[^\\r\\n\\]*_\\\\d\\+\" 9 \"dom2\" } } */\n /* { dg-final { cleanup-tree-dump \"dom2\" } } */"}, {"sha": "e4c9772f61f7973a54ee48d2db3a4eb4dc440620", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-21.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-21.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -11,5 +11,5 @@ NumSift (long *array, unsigned long k)\n \n /* There should be only two loads left.  */\n \n-/* { dg-final { scan-tree-dump-times \"= \\\\\\*D\\[^\\n;\\]*;\" 2 \"pre\" } } */\n+/* { dg-final { scan-tree-dump-times \"= \\\\\\*\\[^\\n;\\]*;\" 2 \"pre\" } } */\n /* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "daa0b446f5fa743542b85c378b18eb1e43ff3a73", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -4085,6 +4085,7 @@ verify_gimple_return (gimple stmt)\n   if ((TREE_CODE (op) == RESULT_DECL\n        && DECL_BY_REFERENCE (op))\n       || (TREE_CODE (op) == SSA_NAME\n+\t  && SSA_NAME_VAR (op)\n \t  && TREE_CODE (SSA_NAME_VAR (op)) == RESULT_DECL\n \t  && DECL_BY_REFERENCE (SSA_NAME_VAR (op))))\n     op = TREE_TYPE (op);\n@@ -5945,20 +5946,27 @@ replace_ssa_name (tree name, struct pointer_map_t *vars_map,\n \t\t  tree to_context)\n {\n   void **loc;\n-  tree new_name, decl = SSA_NAME_VAR (name);\n+  tree new_name;\n \n   gcc_assert (is_gimple_reg (name));\n \n   loc = pointer_map_contains (vars_map, name);\n \n   if (!loc)\n     {\n-      replace_by_duplicate_decl (&decl, vars_map, to_context);\n-\n-      new_name = make_ssa_name_fn (DECL_STRUCT_FUNCTION (to_context),\n-\t\t\t\t   decl, SSA_NAME_DEF_STMT (name));\n-      if (SSA_NAME_IS_DEFAULT_DEF (name))\n-\tset_ssa_default_def (DECL_STRUCT_FUNCTION (to_context), decl, new_name);\n+      tree decl = SSA_NAME_VAR (name);\n+      if (decl)\n+\t{\n+\t  replace_by_duplicate_decl (&decl, vars_map, to_context);\n+\t  new_name = make_ssa_name_fn (DECL_STRUCT_FUNCTION (to_context),\n+\t\t\t\t       decl, SSA_NAME_DEF_STMT (name));\n+\t  if (SSA_NAME_IS_DEFAULT_DEF (name))\n+\t    set_ssa_default_def (DECL_STRUCT_FUNCTION (to_context),\n+\t\t\t\t decl, new_name);\n+\t}\n+      else\n+\tnew_name = copy_ssa_name_fn (DECL_STRUCT_FUNCTION (to_context),\n+\t\t\t\t     name, SSA_NAME_DEF_STMT (name));\n \n       loc = pointer_map_insert (vars_map, name);\n       *loc = new_name;\n@@ -6684,6 +6692,19 @@ dump_function_to_file (tree fn, FILE *file, int flags)\n \n \t  any_var = true;\n \t}\n+      if (gimple_in_ssa_p (cfun))\n+\tfor (ix = 1; ix < num_ssa_names; ++ix)\n+\t  {\n+\t    tree name = ssa_name (ix);\n+\t    if (name && !SSA_NAME_VAR (name))\n+\t      {\n+\t\tfprintf (file, \"  \");\n+\t\tprint_generic_expr (file, TREE_TYPE (name), flags);\n+\t\tfprintf (file, \" \");\n+\t\tprint_generic_expr (file, name, flags);\n+\t\tfprintf (file, \";\\n\");\n+\t      }\n+\t  }\n     }\n \n   if (cfun && cfun->decl == fn && cfun->cfg && basic_block_info)"}, {"sha": "c6c5227e287ac03925a6a226a313bf8e6642ad5a", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -488,7 +488,10 @@ get_component_ssa_name (tree ssa_name, bool imag_p)\n   ret = VEC_index (tree, complex_ssa_name_components, ssa_name_index);\n   if (ret == NULL)\n     {\n-      ret = get_component_var (SSA_NAME_VAR (ssa_name), imag_p);\n+      if (SSA_NAME_VAR (ssa_name))\n+\tret = get_component_var (SSA_NAME_VAR (ssa_name), imag_p);\n+      else\n+\tret = TREE_TYPE (TREE_TYPE (ssa_name));\n       ret = make_ssa_name (ret, NULL);\n \n       /* Copy some properties from the original.  In particular, whether it\n@@ -549,7 +552,8 @@ set_component_ssa_name (tree ssa_name, bool imag_p, tree value)\n     {\n       /* Replace an anonymous base value with the variable from cvc_lookup.\n \t This should result in better debug info.  */\n-      if (DECL_IGNORED_P (SSA_NAME_VAR (value))\n+      if (SSA_NAME_VAR (ssa_name)\n+\t  && (!SSA_NAME_VAR (value) || DECL_IGNORED_P (SSA_NAME_VAR (value)))\n \t  && !DECL_IGNORED_P (SSA_NAME_VAR (ssa_name)))\n \t{\n \t  comp = get_component_var (SSA_NAME_VAR (ssa_name), imag_p);"}, {"sha": "7bd0db3917a9ca29532090808b97ccc7e5dee8d1", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -1162,6 +1162,18 @@ duplicate_ssa_name (tree var, gimple stmt)\n   return duplicate_ssa_name_fn (cfun, var, stmt);\n }\n \n+/* Return an anonymous SSA_NAME node for type TYPE defined in statement STMT\n+   in function cfun.  Arrange so that it uses NAME in dumps.  */\n+\n+static inline tree\n+make_temp_ssa_name (tree type, gimple stmt, const char *name)\n+{\n+  tree ssa_name;\n+  gcc_checking_assert (TYPE_P (type));\n+  ssa_name = make_ssa_name_fn (cfun, type, stmt);\n+  SET_SSA_NAME_VAR_OR_IDENTIFIER (ssa_name, get_identifier (name));\n+  return ssa_name;\n+}\n \n /* Returns the base object and a constant BITS_PER_UNIT offset in *POFFSET that\n    denotes the starting address of the memory access EXP."}, {"sha": "879292b72e106855833a8798e56219ab99749f08", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -176,7 +176,7 @@ static int processing_debug_stmt = 0;\n static tree\n remap_ssa_name (tree name, copy_body_data *id)\n {\n-  tree new_tree;\n+  tree new_tree, var;\n   tree *n;\n \n   gcc_assert (TREE_CODE (name) == SSA_NAME);\n@@ -218,9 +218,38 @@ remap_ssa_name (tree name, copy_body_data *id)\n       return name;\n     }\n \n+  /* Remap anonymous SSA names or SSA names of anonymous decls.  */\n+  var = SSA_NAME_VAR (name);\n+  if (!var\n+      || (!SSA_NAME_IS_DEFAULT_DEF (name)\n+\t  && TREE_CODE (var) == VAR_DECL\n+\t  && !VAR_DECL_IS_VIRTUAL_OPERAND (var)\n+\t  && DECL_ARTIFICIAL (var)\n+\t  && DECL_IGNORED_P (var)\n+\t  && !DECL_NAME (var)))\n+    {\n+      struct ptr_info_def *pi;\n+      new_tree = make_ssa_name (remap_type (TREE_TYPE (name), id), NULL);\n+      if (!var && SSA_NAME_IDENTIFIER (name))\n+\tSET_SSA_NAME_VAR_OR_IDENTIFIER (new_tree, SSA_NAME_IDENTIFIER (name));\n+      insert_decl_map (id, name, new_tree);\n+      SSA_NAME_OCCURS_IN_ABNORMAL_PHI (new_tree)\n+\t= SSA_NAME_OCCURS_IN_ABNORMAL_PHI (name);\n+      /* At least IPA points-to info can be directly transferred.  */\n+      if (id->src_cfun->gimple_df\n+\t  && id->src_cfun->gimple_df->ipa_pta\n+\t  && (pi = SSA_NAME_PTR_INFO (name))\n+\t  && !pi->pt.anything)\n+\t{\n+\t  struct ptr_info_def *new_pi = get_ptr_info (new_tree);\n+\t  new_pi->pt = pi->pt;\n+\t}\n+      return new_tree;\n+    }\n+\n   /* Do not set DEF_STMT yet as statement is not copied yet. We do that\n      in copy_bb.  */\n-  new_tree = remap_decl (SSA_NAME_VAR (name), id);\n+  new_tree = remap_decl (var, id);\n \n   /* We might've substituted constant or another SSA_NAME for\n      the variable.\n@@ -229,7 +258,8 @@ remap_ssa_name (tree name, copy_body_data *id)\n      inlining:  this saves us from need to introduce PHI node in a case\n      return value is just partly initialized.  */\n   if ((TREE_CODE (new_tree) == VAR_DECL || TREE_CODE (new_tree) == PARM_DECL)\n-      && (TREE_CODE (SSA_NAME_VAR (name)) != RESULT_DECL\n+      && (!SSA_NAME_VAR (name)\n+\t  || TREE_CODE (SSA_NAME_VAR (name)) != RESULT_DECL\n \t  || !id->transform_return_to_modify))\n     {\n       struct ptr_info_def *pi;\n@@ -259,7 +289,8 @@ remap_ssa_name (tree name, copy_body_data *id)\n \t     regions of the CFG, but this is expensive to test.  */\n \t  if (id->entry_bb\n \t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (name)\n-\t      && TREE_CODE (SSA_NAME_VAR (name)) != PARM_DECL\n+\t      && (!SSA_NAME_VAR (name)\n+\t\t  || TREE_CODE (SSA_NAME_VAR (name)) != PARM_DECL)\n \t      && (id->entry_bb != EDGE_SUCC (ENTRY_BLOCK_PTR, 0)->dest\n \t\t  || EDGE_COUNT (id->entry_bb->preds) != 1))\n \t    {\n@@ -1184,6 +1215,7 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n       if (retval\n \t  && (TREE_CODE (retval) != RESULT_DECL\n \t      && (TREE_CODE (retval) != SSA_NAME\n+\t\t  || ! SSA_NAME_VAR (retval)\n \t\t  || TREE_CODE (SSA_NAME_VAR (retval)) != RESULT_DECL)))\n         {\n \t  copy = gimple_build_assign (id->retvar, retval);\n@@ -2474,14 +2506,8 @@ insert_init_stmt (copy_body_data *id, basic_block bb, gimple init_stmt)\n \n       if (!is_gimple_debug (init_stmt) && MAY_HAVE_DEBUG_STMTS)\n \t{\n-\t  tree var, def = gimple_assign_lhs (init_stmt);\n-\n-\t  if (TREE_CODE (def) == SSA_NAME)\n-\t    var = SSA_NAME_VAR (def);\n-\t  else\n-\t    var = def;\n-\n-\t  insert_init_debug_bind (id, bb, var, def, init_stmt);\n+\t  tree def = gimple_assign_lhs (init_stmt);\n+\t  insert_init_debug_bind (id, bb, def, def, init_stmt);\n \t}\n     }\n }"}, {"sha": "815d8a866d816d0d0c2e5df21a88b1793bb45541", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -249,7 +249,7 @@ mark_for_renaming (tree sym)\n static bool\n marked_for_renaming (tree sym)\n {\n-  if (!symbols_to_rename_set)\n+  if (!symbols_to_rename_set || sym == NULL_TREE)\n     return false;\n   return bitmap_bit_p (symbols_to_rename_set, DECL_UID (sym));\n }\n@@ -2388,6 +2388,7 @@ rewrite_into_ssa (void)\n {\n   bitmap_head *dfs;\n   basic_block bb;\n+  unsigned i;\n \n   /* Initialize operand data structures.  */\n   init_ssa_operands (cfun);\n@@ -2428,6 +2429,25 @@ rewrite_into_ssa (void)\n \n   fini_ssa_renamer ();\n \n+  /* Try to get rid of all gimplifier generated temporaries by making\n+     its SSA names anonymous.  This way we can garbage collect them\n+     all after removing unused locals which we do in our TODO.  */\n+  for (i = 1; i < num_ssa_names; ++i)\n+    {\n+      tree decl, name = ssa_name (i);\n+      if (!name\n+\t  || SSA_NAME_IS_DEFAULT_DEF (name))\n+\tcontinue;\n+      decl = SSA_NAME_VAR (name);\n+      if (decl\n+\t  && TREE_CODE (decl) == VAR_DECL\n+\t  && !VAR_DECL_IS_VIRTUAL_OPERAND (decl)\n+\t  && DECL_ARTIFICIAL (decl)\n+\t  && DECL_IGNORED_P (decl)\n+\t  && !DECL_NAME (decl))\n+\tSET_SSA_NAME_VAR_OR_IDENTIFIER (name, NULL_TREE);\n+    }\n+\n   return 0;\n }\n "}, {"sha": "fcf9316a395108ae1203d968ae23d67c44a7b0e5", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -973,14 +973,12 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n       break;\n \n     case GIMPLE_NOP:\n-      {\n-\ttree decl = SSA_NAME_VAR (var);\n-\n-\tif (TREE_CODE (decl) != PARM_DECL && DECL_INITIAL (decl))\n-\t  expr_object_size (osi, var, DECL_INITIAL (decl));\n-\telse\n-\t  expr_object_size (osi, var, decl);\n-      }\n+      if (SSA_NAME_VAR (var)\n+\t  && TREE_CODE (SSA_NAME_VAR (var)) == PARM_DECL)\n+\texpr_object_size (osi, var, SSA_NAME_VAR (var));\n+      else\n+\t/* Uninitialized SSA names point nowhere.  */\n+\tobject_sizes[object_size_type][varno] = unknown[object_size_type];\n       break;\n \n     case GIMPLE_PHI:"}, {"sha": "e79eef47802f2f21a72c3f7faaf514526ac3b5ae", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -795,7 +795,25 @@ separate_decls_in_region_name (tree name,\n   if (slot && *slot)\n     return ((struct name_to_copy_elt *) *slot)->new_name;\n \n+  if (copy_name_p)\n+    {\n+      copy = duplicate_ssa_name (name, NULL);\n+      nelt = XNEW (struct name_to_copy_elt);\n+      nelt->version = idx;\n+      nelt->new_name = copy;\n+      nelt->field = NULL_TREE;\n+      *slot = nelt;\n+    }\n+  else\n+    {\n+      gcc_assert (!slot);\n+      copy = name;\n+    }\n+\n   var = SSA_NAME_VAR (name);\n+  if (!var)\n+    return copy;\n+\n   uid = DECL_UID (var);\n   ielt.uid = uid;\n   dslot = htab_find_slot_with_hash (decl_copies, &ielt, uid, INSERT);\n@@ -822,21 +840,6 @@ separate_decls_in_region_name (tree name,\n   else\n     var_copy = ((struct int_tree_map *) *dslot)->to;\n \n-  if (copy_name_p)\n-    {\n-      copy = duplicate_ssa_name (name, NULL);\n-      nelt = XNEW (struct name_to_copy_elt);\n-      nelt->version = idx;\n-      nelt->new_name = copy;\n-      nelt->field = NULL_TREE;\n-      *slot = nelt;\n-    }\n-  else\n-    {\n-      gcc_assert (!slot);\n-      copy = name;\n-    }\n-\n   replace_ssa_name_symbol (copy, var_copy);\n   return copy;\n }\n@@ -966,9 +969,9 @@ add_field_for_name (void **slot, void *data)\n   struct name_to_copy_elt *const elt = (struct name_to_copy_elt *) *slot;\n   tree type = (tree) data;\n   tree name = ssa_name (elt->version);\n-  tree var = SSA_NAME_VAR (name);\n-  tree field = build_decl (DECL_SOURCE_LOCATION (var),\n-\t\t\t   FIELD_DECL, DECL_NAME (var), TREE_TYPE (var));\n+  tree field = build_decl (UNKNOWN_LOCATION,\n+\t\t\t   FIELD_DECL, SSA_NAME_IDENTIFIER (name),\n+\t\t\t   TREE_TYPE (name));\n \n   insert_field_into_struct (type, field);\n   elt->field = field;"}, {"sha": "b13300c4d11b753ca466dd34ad476f10d081b1bf", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -1901,7 +1901,7 @@ eliminate_temp_copies (struct loop *loop, bitmap tmp_vars)\n       phi = gsi_stmt (psi);\n       name = PHI_RESULT (phi);\n       var = SSA_NAME_VAR (name);\n-      if (!bitmap_bit_p (tmp_vars, DECL_UID (var)))\n+      if (!var || !bitmap_bit_p (tmp_vars, DECL_UID (var)))\n \tcontinue;\n       use = PHI_ARG_DEF_FROM_EDGE (phi, e);\n       gcc_assert (TREE_CODE (use) == SSA_NAME);"}, {"sha": "8bd483a3a0e412fa1bd637d16f681d277be32b93", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -2043,7 +2043,9 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       break;\n \n     case SSA_NAME:\n-      dump_generic_node (buffer, SSA_NAME_VAR (node), spc, flags, false);\n+      if (SSA_NAME_IDENTIFIER (node))\n+\tdump_generic_node (buffer, SSA_NAME_IDENTIFIER (node),\n+\t\t\t   spc, flags, false);\n       pp_string (buffer, \"_\");\n       pp_decimal_int (buffer, SSA_NAME_VERSION (node));\n       if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (node))"}, {"sha": "4d210ad896e190adbdc7b466316993d4e944857d", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -1885,6 +1885,7 @@ create_access_replacement (struct access *access)\n     {\n       char *pretty_name = make_fancy_name (access->expr);\n       tree debug_expr = unshare_expr (access->expr), d;\n+      bool fail = false;\n \n       DECL_NAME (repl) = get_identifier (pretty_name);\n       obstack_free (&name_obstack, pretty_name);\n@@ -1894,29 +1895,34 @@ create_access_replacement (struct access *access)\n \t used SSA_NAMEs and thus they could be freed.  All debug info\n \t generation cares is whether something is constant or variable\n \t and that get_ref_base_and_extent works properly on the\n-\t expression.  */\n-      for (d = debug_expr; handled_component_p (d); d = TREE_OPERAND (d, 0))\n+\t expression.  It cannot handle accesses at a non-constant offset\n+\t though, so just give up in those cases.  */\n+      for (d = debug_expr; !fail && handled_component_p (d);\n+\t   d = TREE_OPERAND (d, 0))\n \tswitch (TREE_CODE (d))\n \t  {\n \t  case ARRAY_REF:\n \t  case ARRAY_RANGE_REF:\n \t    if (TREE_OPERAND (d, 1)\n-\t\t&& TREE_CODE (TREE_OPERAND (d, 1)) == SSA_NAME)\n-\t      TREE_OPERAND (d, 1) = SSA_NAME_VAR (TREE_OPERAND (d, 1));\n+\t\t&& TREE_CODE (TREE_OPERAND (d, 1)) != INTEGER_CST)\n+\t      fail = true;\n \t    if (TREE_OPERAND (d, 3)\n-\t\t&& TREE_CODE (TREE_OPERAND (d, 3)) == SSA_NAME)\n-\t      TREE_OPERAND (d, 3) = SSA_NAME_VAR (TREE_OPERAND (d, 3));\n+\t\t&& TREE_CODE (TREE_OPERAND (d, 3)) != INTEGER_CST)\n+\t      fail = true;\n \t    /* FALLTHRU */\n \t  case COMPONENT_REF:\n \t    if (TREE_OPERAND (d, 2)\n-\t\t&& TREE_CODE (TREE_OPERAND (d, 2)) == SSA_NAME)\n-\t      TREE_OPERAND (d, 2) = SSA_NAME_VAR (TREE_OPERAND (d, 2));\n+\t\t&& TREE_CODE (TREE_OPERAND (d, 2)) != INTEGER_CST)\n+\t      fail = true;\n \t    break;\n \t  default:\n \t    break;\n \t  }\n-      SET_DECL_DEBUG_EXPR (repl, debug_expr);\n-      DECL_DEBUG_EXPR_IS_FROM (repl) = 1;\n+      if (!fail)\n+\t{\n+\t  SET_DECL_DEBUG_EXPR (repl, debug_expr);\n+\t  DECL_DEBUG_EXPR_IS_FROM (repl) = 1;\n+\t}\n       if (access->grp_no_warning)\n \tTREE_NO_WARNING (repl) = 1;\n       else\n@@ -4236,8 +4242,10 @@ replace_removed_params_ssa_names (gimple stmt,\n \n   if (TREE_CODE (lhs) != SSA_NAME)\n     return false;\n+\n   decl = SSA_NAME_VAR (lhs);\n-  if (TREE_CODE (decl) != PARM_DECL)\n+  if (decl == NULL_TREE\n+      || TREE_CODE (decl) != PARM_DECL)\n     return false;\n \n   adj = get_adjustment_for_base (adjustments, decl);"}, {"sha": "b8b1a51dd72f63a580935f56aa459d9011f0a814", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 19, "deletions": 45, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -924,34 +924,6 @@ print_exprs (FILE *f, const char *str1, tree expr1, const char *str2,\n }\n \n \n-/* Called if a coalesce across and abnormal edge cannot be performed.  PHI is\n-   the phi node at fault, I is the argument index at fault.  A message is\n-   printed and compilation is then terminated.  */\n-\n-static inline void\n-abnormal_corrupt (gimple phi, int i)\n-{\n-  edge e = gimple_phi_arg_edge (phi, i);\n-  tree res = gimple_phi_result (phi);\n-  tree arg = gimple_phi_arg_def (phi, i);\n-\n-  fprintf (stderr, \" Corrupt SSA across abnormal edge BB%d->BB%d\\n\",\n-\t   e->src->index, e->dest->index);\n-  fprintf (stderr, \"Argument %d (\", i);\n-  print_generic_expr (stderr, arg, TDF_SLIM);\n-  if (TREE_CODE (arg) != SSA_NAME)\n-    fprintf (stderr, \") is not an SSA_NAME.\\n\");\n-  else\n-    {\n-      gcc_assert (SSA_NAME_VAR (res) != SSA_NAME_VAR (arg));\n-      fprintf (stderr, \") does not have the same base variable as the result \");\n-      print_generic_stmt (stderr, res, TDF_SLIM);\n-    }\n-\n-  internal_error (\"SSA corruption\");\n-}\n-\n-\n /* Print a failure to coalesce a MUST_COALESCE pair X and Y.  */\n \n static inline void\n@@ -1007,25 +979,25 @@ create_outofssa_var_map (coalesce_list_p cl, bitmap used_in_copy)\n \t    {\n \t      edge e = gimple_phi_arg_edge (phi, i);\n \t      arg = PHI_ARG_DEF (phi, i);\n-\t      if (TREE_CODE (arg) == SSA_NAME)\n-\t\tregister_ssa_partition (map, arg);\n-\t      if (TREE_CODE (arg) == SSA_NAME\n-\t\t  && SSA_NAME_VAR (arg) == SSA_NAME_VAR (res))\n-\t        {\n+\t      if (TREE_CODE (arg) != SSA_NAME)\n+\t\tcontinue;\n+\n+\t      register_ssa_partition (map, arg);\n+\t      if ((SSA_NAME_VAR (arg) == SSA_NAME_VAR (res)\n+\t\t   && TREE_TYPE (arg) == TREE_TYPE (res))\n+\t\t  || (e->flags & EDGE_ABNORMAL))\n+\t\t{\n \t\t  saw_copy = true;\n \t\t  bitmap_set_bit (used_in_copy, SSA_NAME_VERSION (arg));\n \t\t  if ((e->flags & EDGE_ABNORMAL) == 0)\n \t\t    {\n \t\t      int cost = coalesce_cost_edge (e);\n \t\t      if (cost == 1 && has_single_use (arg))\n-\t\t        add_cost_one_coalesce (cl, ver, SSA_NAME_VERSION (arg));\n+\t\t\tadd_cost_one_coalesce (cl, ver, SSA_NAME_VERSION (arg));\n \t\t      else\n \t\t\tadd_coalesce (cl, ver, SSA_NAME_VERSION (arg), cost);\n \t\t    }\n \t\t}\n-\t      else\n-\t        if (e->flags & EDGE_ABNORMAL)\n-\t\t  abnormal_corrupt (phi, i);\n \t    }\n \t  if (saw_copy)\n \t    bitmap_set_bit (used_in_copy, ver);\n@@ -1053,7 +1025,8 @@ create_outofssa_var_map (coalesce_list_p cl, bitmap used_in_copy)\n \t\tif (gimple_assign_copy_p (stmt)\n                     && TREE_CODE (lhs) == SSA_NAME\n \t\t    && TREE_CODE (rhs1) == SSA_NAME\n-\t\t    && SSA_NAME_VAR (lhs) == SSA_NAME_VAR (rhs1))\n+\t\t    && SSA_NAME_VAR (lhs) == SSA_NAME_VAR (rhs1)\n+\t\t    && TREE_TYPE (lhs) == TREE_TYPE (rhs1))\n \t\t  {\n \t\t    v1 = SSA_NAME_VERSION (lhs);\n \t\t    v2 = SSA_NAME_VERSION (rhs1);\n@@ -1103,7 +1076,8 @@ create_outofssa_var_map (coalesce_list_p cl, bitmap used_in_copy)\n \t\t    v1 = SSA_NAME_VERSION (outputs[match]);\n \t\t    v2 = SSA_NAME_VERSION (input);\n \n-\t\t    if (SSA_NAME_VAR (outputs[match]) == SSA_NAME_VAR (input))\n+\t\t    if (SSA_NAME_VAR (outputs[match]) == SSA_NAME_VAR (input)\n+\t\t\t&& TREE_TYPE (outputs[match]) == TREE_TYPE (input))\n \t\t      {\n \t\t\tcost = coalesce_cost (REG_BR_PROB_BASE,\n \t\t\t\t\t      optimize_bb_for_size_p (bb));\n@@ -1130,13 +1104,15 @@ create_outofssa_var_map (coalesce_list_p cl, bitmap used_in_copy)\n       if (var != NULL_TREE && is_gimple_reg (var))\n         {\n \t  /* Add coalesces between all the result decls.  */\n-\t  if (TREE_CODE (SSA_NAME_VAR (var)) == RESULT_DECL)\n+\t  if (SSA_NAME_VAR (var)\n+\t      && TREE_CODE (SSA_NAME_VAR (var)) == RESULT_DECL)\n \t    {\n \t      if (first == NULL_TREE)\n \t\tfirst = var;\n \t      else\n \t\t{\n-\t\t  gcc_assert (SSA_NAME_VAR (var) == SSA_NAME_VAR (first));\n+\t\t  gcc_assert (SSA_NAME_VAR (var) == SSA_NAME_VAR (first)\n+\t\t\t      && TREE_TYPE (var) == TREE_TYPE (first));\n \t\t  v1 = SSA_NAME_VERSION (first);\n \t\t  v2 = SSA_NAME_VERSION (var);\n \t\t  bitmap_set_bit (used_in_copy, v1);\n@@ -1256,9 +1232,6 @@ coalesce_partitions (var_map map, ssa_conflicts_p graph, coalesce_list_p cl,\n \t\tint v1 = SSA_NAME_VERSION (res);\n \t\tint v2 = SSA_NAME_VERSION (arg);\n \n-\t\tif (SSA_NAME_VAR (arg) != SSA_NAME_VAR (res))\n-\t\t  abnormal_corrupt (phi, e->dest_idx);\n-\n \t\tif (debug)\n \t\t  fprintf (debug, \"Abnormal coalesce: \");\n \n@@ -1276,7 +1249,8 @@ coalesce_partitions (var_map map, ssa_conflicts_p graph, coalesce_list_p cl,\n       var2 = ssa_name (y);\n \n       /* Assert the coalesces have the same base variable.  */\n-      gcc_assert (SSA_NAME_VAR (var1) == SSA_NAME_VAR (var2));\n+      gcc_assert (SSA_NAME_VAR (var1) == SSA_NAME_VAR (var2)\n+\t\t  && TREE_TYPE (var1) == TREE_TYPE (var2));\n \n       if (debug)\n \tfprintf (debug, \"Coalesce list: \");"}, {"sha": "82f8c64fe1c7dbf380d76d84c99b8ba9cf6509f6", "filename": "gcc/tree-ssa-copyrename.c", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-ssa-copyrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-ssa-copyrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copyrename.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -143,18 +143,20 @@ copy_rename_partition_coalesce (var_map map, tree var1, tree var2, FILE *debug)\n   gcc_assert (p1 != NO_PARTITION);\n   gcc_assert (p2 != NO_PARTITION);\n \n-  rep1 = partition_to_var (map, p1);\n-  rep2 = partition_to_var (map, p2);\n-  root1 = SSA_NAME_VAR (rep1);\n-  root2 = SSA_NAME_VAR (rep2);\n-\n   if (p1 == p2)\n     {\n       if (debug)\n \tfprintf (debug, \" : Already coalesced.\\n\");\n       return false;\n     }\n \n+  rep1 = partition_to_var (map, p1);\n+  rep2 = partition_to_var (map, p2);\n+  root1 = SSA_NAME_VAR (rep1);\n+  root2 = SSA_NAME_VAR (rep2);\n+  if (!root1 && !root2)\n+    return false;\n+\n   /* Don't coalesce if one of the variables occurs in an abnormal PHI.  */\n   abnorm = (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rep1)\n \t    || SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rep2));\n@@ -175,22 +177,24 @@ copy_rename_partition_coalesce (var_map map, tree var1, tree var2, FILE *debug)\n     }\n \n   /* Never attempt to coalesce 2 different parameters.  */\n-  if (TREE_CODE (root1) == PARM_DECL && TREE_CODE (root2) == PARM_DECL)\n+  if ((root1 && TREE_CODE (root1) == PARM_DECL)\n+      && (root2 && TREE_CODE (root2) == PARM_DECL))\n     {\n       if (debug)\n         fprintf (debug, \" : 2 different PARM_DECLS. No coalesce.\\n\");\n       return false;\n     }\n \n-  if ((TREE_CODE (root1) == RESULT_DECL) != (TREE_CODE (root2) == RESULT_DECL))\n+  if ((root1 && TREE_CODE (root1) == RESULT_DECL)\n+      != (root2 && TREE_CODE (root2) == RESULT_DECL))\n     {\n       if (debug)\n         fprintf (debug, \" : One root a RESULT_DECL. No coalesce.\\n\");\n       return false;\n     }\n \n-  ign1 = TREE_CODE (root1) == VAR_DECL && DECL_IGNORED_P (root1);\n-  ign2 = TREE_CODE (root2) == VAR_DECL && DECL_IGNORED_P (root2);\n+  ign1 = !root1 || (TREE_CODE (root1) == VAR_DECL && DECL_IGNORED_P (root1));\n+  ign2 = !root2 || (TREE_CODE (root2) == VAR_DECL && DECL_IGNORED_P (root2));\n \n   /* Refrain from coalescing user variables, if requested.  */\n   if (!ign1 && !ign2)\n@@ -211,9 +215,9 @@ copy_rename_partition_coalesce (var_map map, tree var1, tree var2, FILE *debug)\n \n   /* If both values have default defs, we can't coalesce.  If only one has a\n      tag, make sure that variable is the new root partition.  */\n-  if (ssa_default_def (cfun, root1))\n+  if (root1 && ssa_default_def (cfun, root1))\n     {\n-      if (ssa_default_def (cfun, root2))\n+      if (root2 && ssa_default_def (cfun, root2))\n \t{\n \t  if (debug)\n \t    fprintf (debug, \" : 2 default defs. No coalesce.\\n\");\n@@ -225,31 +229,41 @@ copy_rename_partition_coalesce (var_map map, tree var1, tree var2, FILE *debug)\n \t  ign1 = false;\n \t}\n     }\n-  else if (ssa_default_def (cfun, root2))\n+  else if (root2 && ssa_default_def (cfun, root2))\n     {\n       ign1 = true;\n       ign2 = false;\n     }\n \n+  /* Do not coalesce if we cannot assign a symbol to the partition.  */\n+  if (!(!ign2 && root2)\n+      && !(!ign1 && root1))\n+    {\n+      if (debug)\n+\tfprintf (debug, \" : Choosen variable has no root.  No coalesce.\\n\");\n+      return false;\n+    }\n+\n   /* Don't coalesce if the new chosen root variable would be read-only.\n      If both ign1 && ign2, then the root var of the larger partition\n      wins, so reject in that case if any of the root vars is TREE_READONLY.\n      Otherwise reject only if the root var, on which replace_ssa_name_symbol\n      will be called below, is readonly.  */\n-  if ((TREE_READONLY (root1) && ign2) || (TREE_READONLY (root2) && ign1))\n+  if (((root1 && TREE_READONLY (root1)) && ign2)\n+      || ((root2 && TREE_READONLY (root2)) && ign1))\n     {\n       if (debug)\n \tfprintf (debug, \" : Readonly variable.  No coalesce.\\n\");\n       return false;\n     }\n \n   /* Don't coalesce if the two variables aren't type compatible .  */\n-  if (!types_compatible_p (TREE_TYPE (root1), TREE_TYPE (root2))\n+  if (!types_compatible_p (TREE_TYPE (var1), TREE_TYPE (var2))\n       /* There is a disconnect between the middle-end type-system and\n          VRP, avoid coalescing enum types with different bounds.  */\n-      || ((TREE_CODE (TREE_TYPE (root1)) == ENUMERAL_TYPE\n-\t   || TREE_CODE (TREE_TYPE (root2)) == ENUMERAL_TYPE)\n-\t  && TREE_TYPE (root1) != TREE_TYPE (root2)))\n+      || ((TREE_CODE (TREE_TYPE (var1)) == ENUMERAL_TYPE\n+\t   || TREE_CODE (TREE_TYPE (var2)) == ENUMERAL_TYPE)\n+\t  && TREE_TYPE (var1) != TREE_TYPE (var2)))\n     {\n       if (debug)\n \tfprintf (debug, \" : Incompatible types.  No coalesce.\\n\");\n@@ -261,10 +275,12 @@ copy_rename_partition_coalesce (var_map map, tree var1, tree var2, FILE *debug)\n \n   /* Set the root variable of the partition to the better choice, if there is\n      one.  */\n-  if (!ign2)\n+  if (!ign2 && root2)\n     replace_ssa_name_symbol (partition_to_var (map, p3), root2);\n-  else if (!ign1)\n+  else if (!ign1 && root1)\n     replace_ssa_name_symbol (partition_to_var (map, p3), root1);\n+  else\n+    gcc_unreachable ();\n \n   if (debug)\n     {"}, {"sha": "85c71fc4ad74a427ac2e409d6ee8766ad88f6ed2", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -61,11 +61,11 @@ var_map_base_init (var_map map)\n {\n   int x, num_part;\n   tree var;\n-  htab_t decl_to_index;\n+  htab_t tree_to_index;\n   struct tree_int_map *m, *mapstorage;\n \n   num_part = num_var_partitions (map);\n-  decl_to_index = htab_create (num_part, tree_decl_map_hash,\n+  tree_to_index = htab_create (num_part, tree_map_base_hash,\n \t\t\t       tree_int_map_eq, NULL);\n   /* We can have at most num_part entries in the hash tables, so it's\n      enough to allocate so many map elements once, saving some malloc\n@@ -82,10 +82,18 @@ var_map_base_init (var_map map)\n       struct tree_int_map **slot;\n       unsigned baseindex;\n       var = partition_to_var (map, x);\n-      var = SSA_NAME_VAR (var);\n+      if (SSA_NAME_VAR (var))\n+\tm->base.from = SSA_NAME_VAR (var);\n+      else\n+\t/* This restricts what anonymous SSA names we can coalesce\n+\t   as it restricts the sets we compute conflicts for.\n+\t   Using TREE_TYPE to generate sets is the easies as\n+\t   type equivalency also holds for SSA names with the same\n+\t   underlying decl.  */\n+\tm->base.from = TREE_TYPE (var);\n       /* If base variable hasn't been seen, set it up.  */\n-      m->base.from = var;\n-      slot = (struct tree_int_map **) htab_find_slot (decl_to_index, m, INSERT);\n+      slot = (struct tree_int_map **) htab_find_slot (tree_to_index,\n+\t\t\t\t\t\t      m, INSERT);\n       if (!*slot)\n \t{\n \t  baseindex = m - mapstorage;\n@@ -101,7 +109,7 @@ var_map_base_init (var_map map)\n   map->num_basevars = m - mapstorage;\n \n   free (mapstorage);\n-  htab_delete (decl_to_index);\n+  htab_delete (tree_to_index);\n }\n \n \n@@ -360,7 +368,12 @@ mark_all_vars_used_1 (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n   tree b;\n \n   if (TREE_CODE (t) == SSA_NAME)\n-    t = SSA_NAME_VAR (t);\n+    {\n+      *walk_subtrees = 0;\n+      t = SSA_NAME_VAR (t);\n+      if (!t)\n+\treturn NULL;\n+    }\n \n   if (IS_EXPR_CODE_CLASS (c)\n       && (b = TREE_BLOCK (t)) != NULL)\n@@ -1240,12 +1253,13 @@ verify_live_on_entry (tree_live_info_p live)\n       for (i = 0; i < (unsigned)num_var_partitions (map); i++)\n \t{\n \t  basic_block tmp;\n-\t  tree d;\n+\t  tree d = NULL_TREE;\n \t  bitmap loe;\n \t  var = partition_to_var (map, i);\n \t  stmt = SSA_NAME_DEF_STMT (var);\n \t  tmp = gimple_bb (stmt);\n-\t  d = ssa_default_def (cfun, SSA_NAME_VAR (var));\n+\t  if (SSA_NAME_VAR (var))\n+\t    d = ssa_default_def (cfun, SSA_NAME_VAR (var));\n \n \t  loe = live_on_entry (live, e->dest);\n \t  if (loe && bitmap_bit_p (loe, i))"}, {"sha": "8894776ae8c26b13f9358fcc703895e951078e71", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -1919,9 +1919,6 @@ gen_lsm_tmp_name (tree ref)\n       break;\n \n     case SSA_NAME:\n-      ref = SSA_NAME_VAR (ref);\n-      /* Fallthru.  */\n-\n     case VAR_DECL:\n     case PARM_DECL:\n       name = get_name (ref);"}, {"sha": "c44567fd27541c20c9e0d83353c731b20fa6a6ca", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -2819,6 +2819,9 @@ prepare_decl_rtl (tree *expr_p, int *ws, void *data)\n     case SSA_NAME:\n       *ws = 0;\n       obj = SSA_NAME_VAR (*expr_p);\n+      /* Defer handling of anonymous SSA_NAMEs to the expander.  */\n+      if (!obj)\n+\treturn NULL_TREE;\n       if (!DECL_RTL_SET_P (obj))\n \tx = gen_raw_REG (DECL_MODE (obj), (*regno)++);\n       break;\n@@ -4966,6 +4969,7 @@ determine_iv_cost (struct ivopts_data *data, struct iv_cand *cand)\n      The reason is to make debugging simpler; so this is not relevant for\n      artificial ivs created by other optimization passes.  */\n   if (cand->pos != IP_ORIGINAL\n+      || !SSA_NAME_VAR (cand->var_before)\n       || DECL_ARTIFICIAL (SSA_NAME_VAR (cand->var_before)))\n     cost++;\n "}, {"sha": "288e7a2b45b241c2cac7a39c90f2d1e4ebfece91", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -875,7 +875,7 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n   enum tree_code exit_cmp;\n   gimple phi_old_loop, phi_new_loop, phi_rest;\n   gimple_stmt_iterator psi_old_loop, psi_new_loop;\n-  tree init, next, new_init, var;\n+  tree init, next, new_init;\n   struct loop *new_loop;\n   basic_block rest, exit_bb;\n   edge old_entry, new_entry, old_latch, precond_edge, new_exit;\n@@ -995,17 +995,16 @@ tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n       if (TREE_CODE (next) == SSA_NAME\n \t  && useless_type_conversion_p (TREE_TYPE (next),\n \t\t\t\t\tTREE_TYPE (init)))\n-\tvar = SSA_NAME_VAR (next);\n+\tnew_init = copy_ssa_name (next, NULL);\n       else if (TREE_CODE (init) == SSA_NAME\n \t       && useless_type_conversion_p (TREE_TYPE (init),\n \t\t\t\t\t     TREE_TYPE (next)))\n-\tvar = SSA_NAME_VAR (init);\n+\tnew_init = copy_ssa_name (init, NULL);\n       else if (useless_type_conversion_p (TREE_TYPE (next), TREE_TYPE (init)))\n-\tvar = create_tmp_var (TREE_TYPE (next), \"unrinittmp\");\n+\tnew_init = make_temp_ssa_name (TREE_TYPE (next), NULL, \"unrinittmp\");\n       else\n-\tvar = create_tmp_var (TREE_TYPE (init), \"unrinittmp\");\n+\tnew_init = make_temp_ssa_name (TREE_TYPE (init), NULL, \"unrinittmp\");\n \n-      new_init = make_ssa_name (var, NULL);\n       phi_rest = create_phi_node (new_init, rest);\n \n       add_phi_arg (phi_rest, init, precond_edge, UNKNOWN_LOCATION);"}, {"sha": "842c392914d2470117aad8ad462d19676fc98023", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -2746,7 +2746,8 @@ visit_reference_op_load (tree lhs, tree op, gimple stmt)\n \t a new SSA_NAME we create.  */\n       if (!result)\n         {\n-\t  result = make_ssa_name (SSA_NAME_VAR (lhs), gimple_build_nop ());\n+\t  result = make_temp_ssa_name (TREE_TYPE (lhs), gimple_build_nop (),\n+\t\t\t\t       \"vntemp\");\n \t  /* Initialize value-number information properly.  */\n \t  VN_INFO_GET (result)->valnum = result;\n \t  VN_INFO (result)->value_id = get_next_value_id ();"}, {"sha": "5b185b6e1290fddfcb5a7f6dfafa72a023db0e6d", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -2659,37 +2659,48 @@ lookup_vi_for_tree (tree t)\n static const char *\n alias_get_name (tree decl)\n {\n-  const char *res;\n+  const char *res = NULL;\n   char *temp;\n   int num_printed = 0;\n \n-  if (DECL_ASSEMBLER_NAME_SET_P (decl))\n-    res = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n-  else\n-    res= get_name (decl);\n-  if (res != NULL)\n-    return res;\n-\n-  res = \"NULL\";\n   if (!dump_file)\n-    return res;\n+    return \"NULL\";\n \n   if (TREE_CODE (decl) == SSA_NAME)\n     {\n-      num_printed = asprintf (&temp, \"%s_%u\",\n-\t\t\t      alias_get_name (SSA_NAME_VAR (decl)),\n-\t\t\t      SSA_NAME_VERSION (decl));\n+      res = get_name (decl);\n+      if (res)\n+\tnum_printed = asprintf (&temp, \"%s_%u\", res, SSA_NAME_VERSION (decl));\n+      else\n+\tnum_printed = asprintf (&temp, \"_%u\", SSA_NAME_VERSION (decl));\n+      if (num_printed > 0)\n+\t{\n+\t  res = ggc_strdup (temp);\n+\t  free (temp);\n+\t}\n     }\n   else if (DECL_P (decl))\n     {\n-      num_printed = asprintf (&temp, \"D.%u\", DECL_UID (decl));\n-    }\n-  if (num_printed > 0)\n-    {\n-      res = ggc_strdup (temp);\n-      free (temp);\n+      if (DECL_ASSEMBLER_NAME_SET_P (decl))\n+\tres = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+      else\n+\t{\n+\t  res = get_name (decl);\n+\t  if (!res)\n+\t    {\n+\t      num_printed = asprintf (&temp, \"D.%u\", DECL_UID (decl));\n+\t      if (num_printed > 0)\n+\t\t{\n+\t\t  res = ggc_strdup (temp);\n+\t\t  free (temp);\n+\t\t}\n+\t    }\n+\t}\n     }\n-  return res;\n+  if (res != NULL)\n+    return res;\n+\n+  return \"NULL\";\n }\n \n /* Find the variable id for tree T in the map."}, {"sha": "dbfa37cf7c4f4595997a7a9a9a5f976c7c0dedb5", "filename": "gcc/tree-ssa-ter.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-ssa-ter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-ssa-ter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ter.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -498,10 +498,11 @@ process_replaceable (temp_expr_table_p tab, gimple stmt, int call_cnt)\n \n   def = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_DEF);\n   version = SSA_NAME_VERSION (def);\n-  basevar = SSA_NAME_VAR (def);\n   def_vars = BITMAP_ALLOC (NULL);\n \n-  bitmap_set_bit (def_vars, DECL_UID (basevar));\n+  basevar = SSA_NAME_VAR (def);\n+  if (basevar)\n+    bitmap_set_bit (def_vars, DECL_UID (basevar));\n \n   /* Add this expression to the dependency list for each use partition.  */\n   FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_USE)\n@@ -515,7 +516,7 @@ process_replaceable (temp_expr_table_p tab, gimple stmt, int call_cnt)\n \t  bitmap_ior_into (def_vars, use_vars);\n \t  BITMAP_FREE (tab->expr_decl_uids[var_version]);\n \t}\n-      else\n+      else if (SSA_NAME_VAR (var))\n \tbitmap_set_bit (def_vars, DECL_UID (SSA_NAME_VAR (var)));\n     }\n   tab->expr_decl_uids[version] = def_vars;\n@@ -626,7 +627,8 @@ find_replaceable_in_bb (temp_expr_table_p tab, basic_block bb)\n \t      if (!bitmap_empty_p (vars))\n \t\tFOR_EACH_SSA_TREE_OPERAND (def, stmt, iter2, SSA_OP_DEF)\n \t\t  {\n-\t\t    if (bitmap_bit_p (vars, DECL_UID (SSA_NAME_VAR (def))))\n+\t\t    if (SSA_NAME_VAR (def)\n+\t\t\t&& bitmap_bit_p (vars, DECL_UID (SSA_NAME_VAR (def))))\n \t\t      {\n \t\t\tsame_root_var = true;\n \t\t\tbreak;"}, {"sha": "b5e1edffeb4857316e7640019d641fc676fea9fd", "filename": "gcc/tree-ssa-uncprop.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-ssa-uncprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-ssa-uncprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uncprop.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -463,14 +463,16 @@ uncprop_into_successor_phis (basic_block bb)\n \t{\n \t  gimple phi = gsi_stmt (gsi);\n \t  tree arg = PHI_ARG_DEF (phi, e->dest_idx);\n+\t  tree res = PHI_RESULT (phi);\n \t  struct equiv_hash_elt equiv_hash_elt;\n \t  void **slot;\n \n-\t  /* If the argument is not an invariant, or refers to the same\n+\t  /* If the argument is not an invariant, and refers to the same\n \t     underlying variable as the PHI result, then there's no\n \t     point in un-propagating the argument.  */\n \t  if (!is_gimple_min_invariant (arg)\n-\t      && SSA_NAME_VAR (arg) != SSA_NAME_VAR (PHI_RESULT (phi)))\n+\t      && (SSA_NAME_VAR (arg) == SSA_NAME_VAR (res)\n+\t\t  && TREE_TYPE (arg) == TREE_TYPE (res)))\n \t    continue;\n \n \t  /* Lookup this argument's value in the hash table.  */\n@@ -492,7 +494,8 @@ uncprop_into_successor_phis (basic_block bb)\n \t\t{\n \t\t  tree equiv = VEC_index (tree, elt->equivalences, j);\n \n-\t\t  if (SSA_NAME_VAR (equiv) == SSA_NAME_VAR (PHI_RESULT (phi)))\n+\t\t  if (SSA_NAME_VAR (equiv) == SSA_NAME_VAR (res)\n+\t\t      && TREE_TYPE (equiv) == TREE_TYPE (res))\n \t\t    {\n \t\t      SET_PHI_ARG_DEF (phi, e->dest_idx, equiv);\n \t\t      break;"}, {"sha": "c65c58ccf305a64de740f9778cc3ff97bc22cae3", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -83,18 +83,17 @@ ssa_undefined_value_p (tree t)\n {\n   tree var = SSA_NAME_VAR (t);\n \n+  if (!var)\n+    ;\n   /* Parameters get their initial value from the function entry.  */\n-  if (TREE_CODE (var) == PARM_DECL)\n+  else if (TREE_CODE (var) == PARM_DECL)\n     return false;\n-\n   /* When returning by reference the return address is actually a hidden\n      parameter.  */\n-  if (TREE_CODE (SSA_NAME_VAR (t)) == RESULT_DECL\n-      && DECL_BY_REFERENCE (SSA_NAME_VAR (t)))\n+  else if (TREE_CODE (var) == RESULT_DECL && DECL_BY_REFERENCE (var))\n     return false;\n-\n   /* Hard register variables get their initial value from the ether.  */\n-  if (TREE_CODE (var) == VAR_DECL && DECL_HARD_REGISTER (var))\n+  else if (TREE_CODE (var) == VAR_DECL && DECL_HARD_REGISTER (var))\n     return false;\n \n   /* The value is undefined iff its definition statement is empty.  */\n@@ -1948,6 +1947,8 @@ warn_uninitialized_phi (gimple phi, VEC(gimple, heap) **worklist,\n     return;\n \n   uninit_op = gimple_phi_arg_def (phi, MASK_FIRST_SET_BIT (uninit_opnds));\n+  if (SSA_NAME_VAR (uninit_op) == NULL_TREE)\n+    return;\n   warn_uninit (OPT_Wmaybe_uninitialized, uninit_op, SSA_NAME_VAR (uninit_op),\n \t       SSA_NAME_VAR (uninit_op),\n                \"%qD may be used uninitialized in this function\","}, {"sha": "5ea3bfd87f45ed1c6c9cdaf6d8a5ef038b28bd83", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -249,6 +249,13 @@ target_for_debug_bind (tree var)\n   if (!MAY_HAVE_DEBUG_STMTS)\n     return NULL_TREE;\n \n+  if (TREE_CODE (var) == SSA_NAME)\n+    {\n+      var = SSA_NAME_VAR (var);\n+      if (var == NULL_TREE)\n+\treturn NULL_TREE;\n+    }\n+\n   if ((TREE_CODE (var) != VAR_DECL\n        || VAR_DECL_IS_VIRTUAL_OPERAND (var))\n       && TREE_CODE (var) != PARM_DECL)\n@@ -622,7 +629,8 @@ verify_ssa_name (tree ssa_name, bool is_virtual)\n       return true;\n     }\n \n-  if (TREE_TYPE (ssa_name) != TREE_TYPE (SSA_NAME_VAR (ssa_name)))\n+  if (SSA_NAME_VAR (ssa_name) != NULL_TREE\n+      && TREE_TYPE (ssa_name) != TREE_TYPE (ssa_name))\n     {\n       error (\"type mismatch between an SSA_NAME and its symbol\");\n       return true;\n@@ -681,7 +689,8 @@ verify_def (basic_block bb, basic_block *definition_block, tree ssa_name,\n   if (verify_ssa_name (ssa_name, is_virtual))\n     goto err;\n \n-  if (TREE_CODE (SSA_NAME_VAR (ssa_name)) == RESULT_DECL\n+  if (SSA_NAME_VAR (ssa_name)\n+      && TREE_CODE (SSA_NAME_VAR (ssa_name)) == RESULT_DECL\n       && DECL_BY_REFERENCE (SSA_NAME_VAR (ssa_name)))\n     {\n       error (\"RESULT_DECL should be read only when DECL_BY_REFERENCE is set\");"}, {"sha": "57a1b482cea4c385963163e4520499ba5ef24ca1", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -120,7 +120,8 @@ make_ssa_name_fn (struct function *fn, tree var, gimple stmt)\n \n   gcc_assert (TREE_CODE (var) == VAR_DECL\n \t      || TREE_CODE (var) == PARM_DECL\n-\t      || TREE_CODE (var) == RESULT_DECL);\n+\t      || TREE_CODE (var) == RESULT_DECL\n+\t      || (TYPE_P (var) && is_gimple_reg_type (var)));\n \n   /* If our free list has an element, then use it.  */\n   if (!VEC_empty (tree, FREE_SSANAMES (fn)))\n@@ -143,8 +144,16 @@ make_ssa_name_fn (struct function *fn, tree var, gimple stmt)\n \tssa_name_nodes_created++;\n     }\n \n-  TREE_TYPE (t) = TREE_TYPE (var);\n-  SSA_NAME_VAR (t) = var;\n+  if (TYPE_P (var))\n+    {\n+      TREE_TYPE (t) = var;\n+      SET_SSA_NAME_VAR_OR_IDENTIFIER (t, NULL_TREE);\n+    }\n+  else\n+    {\n+      TREE_TYPE (t) = TREE_TYPE (var);\n+      SET_SSA_NAME_VAR_OR_IDENTIFIER (t, var);\n+    }\n   SSA_NAME_DEF_STMT (t) = stmt;\n   SSA_NAME_PTR_INFO (t) = NULL;\n   SSA_NAME_IN_FREE_LIST (t) = 0;\n@@ -225,7 +234,7 @@ release_ssa_name (tree var)\n \n       /* Hopefully this can go away once we have the new incremental\n          SSA updating code installed.  */\n-      SSA_NAME_VAR (var) = saved_ssa_name_var;\n+      SET_SSA_NAME_VAR_OR_IDENTIFIER (var, saved_ssa_name_var);\n \n       /* Note this SSA_NAME is now in the first list.  */\n       SSA_NAME_IN_FREE_LIST (var) = 1;\n@@ -321,7 +330,17 @@ get_ptr_info (tree t)\n tree\n copy_ssa_name_fn (struct function *fn, tree name, gimple stmt)\n {\n-  return make_ssa_name_fn (fn, SSA_NAME_VAR (name), stmt);\n+  tree new_name;\n+\n+  if (SSA_NAME_VAR (name))\n+    new_name = make_ssa_name_fn (fn, SSA_NAME_VAR (name), stmt);\n+  else\n+    {\n+      new_name = make_ssa_name_fn (fn, TREE_TYPE (name), stmt);\n+      SET_SSA_NAME_VAR_OR_IDENTIFIER (new_name, SSA_NAME_IDENTIFIER (name));\n+    }\n+\n+  return new_name;\n }\n \n \n@@ -385,7 +404,7 @@ release_defs (gimple stmt)\n void\n replace_ssa_name_symbol (tree ssa_name, tree sym)\n {\n-  SSA_NAME_VAR (ssa_name) = sym;\n+  SET_SSA_NAME_VAR_OR_IDENTIFIER (ssa_name, sym);\n   TREE_TYPE (ssa_name) = TREE_TYPE (sym);\n }\n "}, {"sha": "6e864c38a23ff98a4a5eeea602d3f0ef28bd60bb", "filename": "gcc/tree.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -10868,6 +10868,13 @@ get_name (tree t)\n   STRIP_NOPS (stripped_decl);\n   if (DECL_P (stripped_decl) && DECL_NAME (stripped_decl))\n     return IDENTIFIER_POINTER (DECL_NAME (stripped_decl));\n+  else if (TREE_CODE (stripped_decl) == SSA_NAME)\n+    {\n+      tree name = SSA_NAME_IDENTIFIER (stripped_decl);\n+      if (!name)\n+\treturn NULL;\n+      return IDENTIFIER_POINTER (name);\n+    }\n   else\n     {\n       switch (TREE_CODE (stripped_decl))"}, {"sha": "cc49629ca315e4ba9804f22f6aa9a7eaf5811866", "filename": "gcc/tree.h", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70b5e7dc7356529b557b613c7dee032c9d89d035/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=70b5e7dc7356529b557b613c7dee032c9d89d035", "patch": "@@ -1980,9 +1980,25 @@ struct GTY(()) tree_exp {\n \f\n /* SSA_NAME accessors.  */\n \n-/* Returns the variable being referenced.  Once released, this is the\n-   only field that can be relied upon.  */\n-#define SSA_NAME_VAR(NODE)\tSSA_NAME_CHECK (NODE)->ssa_name.var\n+/* Returns the IDENTIFIER_NODE giving the SSA name a name or NULL_TREE\n+   if there is no name associated with it.  */\n+#define SSA_NAME_IDENTIFIER(NODE)\t\t\t\t\\\n+  (SSA_NAME_CHECK (NODE)->ssa_name.var != NULL_TREE\t\t\\\n+   ? (TREE_CODE ((NODE)->ssa_name.var) == IDENTIFIER_NODE\t\\\n+      ? (NODE)->ssa_name.var\t\t\t\t\t\\\n+      : DECL_NAME ((NODE)->ssa_name.var))\t\t\t\\\n+   : NULL_TREE)\n+\n+/* Returns the variable being referenced.  This can be NULL_TREE for\n+   temporaries not associated with any user variable.\n+   Once released, this is the only field that can be relied upon.  */\n+#define SSA_NAME_VAR(NODE)\t\t\t\t\t\\\n+  (SSA_NAME_CHECK (NODE)->ssa_name.var == NULL_TREE\t\t\\\n+   || TREE_CODE ((NODE)->ssa_name.var) == IDENTIFIER_NODE\t\\\n+   ? NULL_TREE : (NODE)->ssa_name.var)\n+\n+#define SET_SSA_NAME_VAR_OR_IDENTIFIER(NODE,VAR) \\\n+  do { SSA_NAME_CHECK (NODE)->ssa_name.var = (VAR); } while (0)\n \n /* Returns the statement which defines this SSA name.  */\n #define SSA_NAME_DEF_STMT(NODE)\tSSA_NAME_CHECK (NODE)->ssa_name.def_stmt"}]}