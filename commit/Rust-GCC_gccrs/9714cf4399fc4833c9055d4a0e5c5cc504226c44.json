{"sha": "9714cf4399fc4833c9055d4a0e5c5cc504226c44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTcxNGNmNDM5OWZjNDgzM2M5MDU1ZDRhMGU1YzVjYzUwNDIyNmM0NA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2001-05-02T14:31:45Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2001-05-02T14:31:45Z"}, "message": "c-lex.c: NULL_PTR -> NULL.\n\n\t* c-lex.c: NULL_PTR -> NULL.\n\t* cse.c: Likewise.\n\t* emit-rtl.c: Likewise.\n\t* gcse.c: Likewise.\n\t* genpeep.c: Likewise.\n\t* jump.c: Likewise.\n\t* mips-tdump.c: Likewise.\n\t* reload1.c: Likewise.\n\t* rtlanal.c: Likewise.\n\t* stmt.c: Likewise.\n\t* stor-layout.c: Likewise.\n\t* toplev.c: Likewise.\n\nFrom-SVN: r41761", "tree": {"sha": "7242626023390eab7333b3367b8417b18f8e5803", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7242626023390eab7333b3367b8417b18f8e5803"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9714cf4399fc4833c9055d4a0e5c5cc504226c44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9714cf4399fc4833c9055d4a0e5c5cc504226c44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9714cf4399fc4833c9055d4a0e5c5cc504226c44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9714cf4399fc4833c9055d4a0e5c5cc504226c44/comments", "author": null, "committer": null, "parents": [{"sha": "46188dcad01ec9cd70c6670b3178553c51e6455a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46188dcad01ec9cd70c6670b3178553c51e6455a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46188dcad01ec9cd70c6670b3178553c51e6455a"}], "stats": {"total": 104, "additions": 58, "deletions": 46}, "files": [{"sha": "7dad94b2fdfad349286924ce018dbc167599c206", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9714cf4399fc4833c9055d4a0e5c5cc504226c44/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9714cf4399fc4833c9055d4a0e5c5cc504226c44/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9714cf4399fc4833c9055d4a0e5c5cc504226c44", "patch": "@@ -1,3 +1,18 @@\n+2001-05-02  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* c-lex.c: NULL_PTR -> NULL.\n+\t* cse.c: Likewise.\n+\t* emit-rtl.c: Likewise.\n+\t* gcse.c: Likewise.\n+\t* genpeep.c: Likewise.\n+\t* jump.c: Likewise.\n+\t* mips-tdump.c: Likewise.\n+\t* reload1.c: Likewise.\n+\t* rtlanal.c: Likewise.\n+\t* stmt.c: Likewise.\n+\t* stor-layout.c: Likewise.\n+\t* toplev.c: Likewise.\n+\n 2001-05-01  Per Bothner  <per@bothner.com>\n \n \t* expr.c (expand_expr):  When compiling LABELED_BLOCK_EXPR,"}, {"sha": "85ed543eaa4b5159a5e85910a4eb2e1c3534b18e", "filename": "gcc/c-lex.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9714cf4399fc4833c9055d4a0e5c5cc504226c44/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9714cf4399fc4833c9055d4a0e5c5cc504226c44/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=9714cf4399fc4833c9055d4a0e5c5cc504226c44", "patch": "@@ -1524,7 +1524,7 @@ lex_string (str, len, wide)\n \n #ifdef MULTIBYTE_CHARS\n   /* Reset multibyte conversion state.  */\n-  (void) local_mbtowc (NULL_PTR, NULL_PTR, 0);\n+  (void) local_mbtowc (NULL, NULL, 0);\n #endif\n \n   while (p < limit)\n@@ -1624,7 +1624,7 @@ lex_charconst (str, len, wide)\n \n #ifdef MULTIBYTE_CHARS\n   int longest_char = local_mb_cur_max ();\n-  (void) local_mbtowc (NULL_PTR, NULL_PTR, 0);\n+  (void) local_mbtowc (NULL, NULL, 0);\n #endif\n \n   max_chars = TYPE_PRECISION (integer_type_node) / width;"}, {"sha": "85716533792fae04fa8e8e7805efa71e5ac25fda", "filename": "gcc/cse.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9714cf4399fc4833c9055d4a0e5c5cc504226c44/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9714cf4399fc4833c9055d4a0e5c5cc504226c44/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=9714cf4399fc4833c9055d4a0e5c5cc504226c44", "patch": "@@ -1245,15 +1245,15 @@ mention_regs (x)\n     {\n       if (GET_CODE (XEXP (x, 0)) == REG\n \t  && ! REGNO_QTY_VALID_P (REGNO (XEXP (x, 0))))\n-\tif (insert_regs (XEXP (x, 0), NULL_PTR, 0))\n+\tif (insert_regs (XEXP (x, 0), NULL, 0))\n \t  {\n \t    rehash_using_reg (XEXP (x, 0));\n \t    changed = 1;\n \t  }\n \n       if (GET_CODE (XEXP (x, 1)) == REG\n \t  && ! REGNO_QTY_VALID_P (REGNO (XEXP (x, 1))))\n-\tif (insert_regs (XEXP (x, 1), NULL_PTR, 0))\n+\tif (insert_regs (XEXP (x, 1), NULL, 0))\n \t  {\n \t    rehash_using_reg (XEXP (x, 1));\n \t    changed = 1;\n@@ -1346,7 +1346,7 @@ insert_regs (x, classp, modified)\n   else if (GET_CODE (x) == SUBREG && GET_CODE (SUBREG_REG (x)) == REG\n \t   && ! REGNO_QTY_VALID_P (REGNO (SUBREG_REG (x))))\n     {\n-      insert_regs (SUBREG_REG (x), NULL_PTR, 0);\n+      insert_regs (SUBREG_REG (x), NULL, 0);\n       mention_regs (x);\n       return 1;\n     }\n@@ -1724,7 +1724,7 @@ insert (x, classp, hash, mode)\n \t  subhash = safe_hash (subexp, mode) & HASH_MASK;\n \t  subelt = lookup (subexp, subhash, mode);\n \t  if (subelt == 0)\n-\t    subelt = insert (subexp, NULL_PTR, subhash, mode);\n+\t    subelt = insert (subexp, NULL, subhash, mode);\n \t  /* Initialize SUBELT's circular chain if it has none.  */\n \t  if (subelt->related_value == 0)\n \t    subelt->related_value = subelt;\n@@ -1999,7 +1999,7 @@ remove_invalid_refs (regno)\n       {\n \tnext = p->next_same_hash;\n \tif (GET_CODE (p->exp) != REG\n-\t    && refers_to_regno_p (regno, regno + 1, p->exp, NULL_PTR))\n+\t    && refers_to_regno_p (regno, regno + 1, p->exp, (rtx*)0))\n \t  remove_from_table (p, i);\n       }\n }\n@@ -2029,7 +2029,7 @@ remove_invalid_subreg_refs (regno, offset, mode)\n \t\t|| (((SUBREG_BYTE (exp)\n \t\t      + (GET_MODE_SIZE (GET_MODE (exp)) - 1)) >= offset)\n \t\t    && SUBREG_BYTE (exp) <= end))\n-\t    && refers_to_regno_p (regno, regno + 1, p->exp, NULL_PTR))\n+\t    && refers_to_regno_p (regno, regno + 1, p->exp, (rtx*)0))\n \t  remove_from_table (p, i);\n       }\n }\n@@ -4603,7 +4603,7 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n \t new quantity number.  */\n       if (op0_elt == 0)\n \t{\n-\t  if (insert_regs (op0, NULL_PTR, 0))\n+\t  if (insert_regs (op0, NULL, 0))\n \t    {\n \t      rehash_using_reg (op0);\n \t      op0_hash = HASH (op0, mode);\n@@ -4615,7 +4615,7 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n \t\top1_hash = HASH (op1,mode);\n \t    }\n \n-\t  op0_elt = insert (op0, NULL_PTR, op0_hash, mode);\n+\t  op0_elt = insert (op0, NULL, op0_hash, mode);\n \t  op0_elt->in_memory = op0_in_memory;\n \t}\n \n@@ -4631,13 +4631,13 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n \t  /* Put OP1 in the hash table so it gets a new quantity number.  */\n \t  if (op1_elt == 0)\n \t    {\n-\t      if (insert_regs (op1, NULL_PTR, 0))\n+\t      if (insert_regs (op1, NULL, 0))\n \t\t{\n \t\t  rehash_using_reg (op1);\n \t\t  op1_hash = HASH (op1, mode);\n \t\t}\n \n-\t      op1_elt = insert (op1, NULL_PTR, op1_hash, mode);\n+\t      op1_elt = insert (op1, NULL, op1_hash, mode);\n \t      op1_elt->in_memory = op1_in_memory;\n \t    }\n \n@@ -4658,25 +4658,25 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n \n   if (op0_elt == 0)\n     {\n-      if (insert_regs (op0, NULL_PTR, 0))\n+      if (insert_regs (op0, NULL, 0))\n \t{\n \t  rehash_using_reg (op0);\n \t  op0_hash = HASH (op0, mode);\n \t}\n \n-      op0_elt = insert (op0, NULL_PTR, op0_hash, mode);\n+      op0_elt = insert (op0, NULL, op0_hash, mode);\n       op0_elt->in_memory = op0_in_memory;\n     }\n \n   if (op1_elt == 0)\n     {\n-      if (insert_regs (op1, NULL_PTR, 0))\n+      if (insert_regs (op1, NULL, 0))\n \t{\n \t  rehash_using_reg (op1);\n \t  op1_hash = HASH (op1, mode);\n \t}\n \n-      op1_elt = insert (op1, NULL_PTR, op1_hash, mode);\n+      op1_elt = insert (op1, NULL, op1_hash, mode);\n       op1_elt->in_memory = op1_in_memory;\n     }\n \n@@ -4749,7 +4749,7 @@ cse_insn (insn, libcall_insn)\n   int src_eqv_in_memory = 0;\n   unsigned src_eqv_hash = 0;\n \n-  struct set *sets = (struct set *) NULL_PTR;\n+  struct set *sets = (struct set *) 0;\n \n   this_insn = insn;\n "}, {"sha": "3452a68f71f366326bfb1579fb47e0a6ad1266dc", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9714cf4399fc4833c9055d4a0e5c5cc504226c44/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9714cf4399fc4833c9055d4a0e5c5cc504226c44/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=9714cf4399fc4833c9055d4a0e5c5cc504226c44", "patch": "@@ -1783,7 +1783,7 @@ gen_label_rtx ()\n   register rtx label;\n \n   label = gen_rtx_CODE_LABEL (VOIDmode, 0, NULL_RTX,\n-\t\t\t      NULL_RTX, label_num++, NULL_PTR, NULL_PTR);\n+\t\t\t      NULL_RTX, label_num++, NULL, NULL);\n \n   LABEL_NUSES (label) = 0;\n   LABEL_ALTERNATE_NAME (label) = NULL;"}, {"sha": "07bdbf5e21dfe4b8e45bdcf1405b4c05822741c9", "filename": "gcc/gcse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9714cf4399fc4833c9055d4a0e5c5cc504226c44/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9714cf4399fc4833c9055d4a0e5c5cc504226c44/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=9714cf4399fc4833c9055d4a0e5c5cc504226c44", "patch": "@@ -948,7 +948,7 @@ compute_can_copy ()\n #else\n \treg = gen_rtx_REG ((enum machine_mode) i, LAST_VIRTUAL_REGISTER + 1);\n \tinsn = emit_insn (gen_rtx_SET (VOIDmode, reg, reg));\n-\tif (recog (PATTERN (insn), insn, NULL_PTR) >= 0)\n+\tif (recog (PATTERN (insn), insn, NULL) >= 0)\n \t  can_copy_p[i] = 1;\n #endif\n       }"}, {"sha": "0249856e6113438073b7d7c3bfe6b0ceb2603548", "filename": "gcc/genpeep.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9714cf4399fc4833c9055d4a0e5c5cc504226c44/gcc%2Fgenpeep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9714cf4399fc4833c9055d4a0e5c5cc504226c44/gcc%2Fgenpeep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpeep.c?ref=9714cf4399fc4833c9055d4a0e5c5cc504226c44", "patch": "@@ -97,7 +97,7 @@ gen_peephole (peep)\n       /* Walk the insn's pattern, remembering at all times the path\n \t down to the walking point.  */\n \n-      match_rtx (XVECEXP (peep, 0, i), NULL_PTR, insn_code_number);\n+      match_rtx (XVECEXP (peep, 0, i), NULL, insn_code_number);\n     }\n \n   /* We get this far if the pattern matches."}, {"sha": "314a20bb0290f9649d59c80d9c6c31aaa42189d1", "filename": "gcc/jump.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9714cf4399fc4833c9055d4a0e5c5cc504226c44/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9714cf4399fc4833c9055d4a0e5c5cc504226c44/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=9714cf4399fc4833c9055d4a0e5c5cc504226c44", "patch": "@@ -973,7 +973,7 @@ delete_noop_moves (f)\n \t\t{\n \t\t  rtx trial;\n \t\t  rtx tem = find_equiv_reg (NULL_RTX, insn, 0,\n-\t\t\t\t\t    sreg, NULL_PTR, dreg,\n+\t\t\t\t\t    sreg, NULL, dreg,\n \t\t\t\t\t    GET_MODE (SET_SRC (body)));\n \n \t\t  if (tem != 0\n@@ -1011,8 +1011,7 @@ delete_noop_moves (f)\n \t\t}\n \t      else if (dreg >= 0 && CONSTANT_P (SET_SRC (body))\n \t\t       && find_equiv_reg (SET_SRC (body), insn, 0, dreg,\n-\t\t\t\t\t  NULL_PTR, 0,\n-\t\t\t\t\t  GET_MODE (SET_DEST (body))))\n+\t\t\t\t\t  NULL, 0, GET_MODE (SET_DEST (body))))\n \t\t{\n \t\t  /* This handles the case where we have two consecutive\n \t\t     assignments of the same constant to pseudos that didn't"}, {"sha": "f4cb9a3b6b7ee4c01df3f4041e03be8e7a198319", "filename": "gcc/mips-tdump.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9714cf4399fc4833c9055d4a0e5c5cc504226c44/gcc%2Fmips-tdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9714cf4399fc4833c9055d4a0e5c5cc504226c44/gcc%2Fmips-tdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tdump.c?ref=9714cf4399fc4833c9055d4a0e5c5cc504226c44", "patch": "@@ -1358,60 +1358,60 @@ read_tfile ()\n \n   print_sym_hdr (&sym_hdr);\n \n-  lines = (LINER *) read_seek (NULL_PTR,\n+  lines = (LINER *) read_seek (NULL,\n \t\t\t       sym_hdr.cbLine,\n \t\t\t       sym_hdr.cbLineOffset,\n \t\t\t       \"Line numbers\");\n \n-  dense_nums = (DNR *) read_seek (NULL_PTR,\n+  dense_nums = (DNR *) read_seek (NULL,\n \t\t\t\t  sym_hdr.idnMax * sizeof (DNR),\n \t\t\t\t  sym_hdr.cbDnOffset,\n \t\t\t\t  \"Dense numbers\");\n \n-  proc_desc = (PDR *) read_seek (NULL_PTR,\n+  proc_desc = (PDR *) read_seek (NULL,\n \t\t\t\t sym_hdr.ipdMax * sizeof (PDR),\n \t\t\t\t sym_hdr.cbPdOffset,\n \t\t\t\t \"Procedure tables\");\n \n-  l_symbols = (SYMR *) read_seek (NULL_PTR,\n+  l_symbols = (SYMR *) read_seek (NULL,\n \t\t\t\t  sym_hdr.isymMax * sizeof (SYMR),\n \t\t\t\t  sym_hdr.cbSymOffset,\n \t\t\t\t  \"Local symbols\");\n \n-  opt_symbols = (OPTR *) read_seek (NULL_PTR,\n+  opt_symbols = (OPTR *) read_seek (NULL,\n \t\t\t\t    sym_hdr.ioptMax * sizeof (OPTR),\n \t\t\t\t    sym_hdr.cbOptOffset,\n \t\t\t\t    \"Optimization symbols\");\n \n-  aux_symbols = (AUXU *) read_seek (NULL_PTR,\n+  aux_symbols = (AUXU *) read_seek (NULL,\n \t\t\t\t    sym_hdr.iauxMax * sizeof (AUXU),\n \t\t\t\t    sym_hdr.cbAuxOffset,\n \t\t\t\t    \"Auxiliary symbols\");\n \n   if (sym_hdr.iauxMax > 0)\n     aux_used = xcalloc (sym_hdr.iauxMax, 1);\n \n-  l_strings = (char *) read_seek (NULL_PTR,\n+  l_strings = (char *) read_seek (NULL,\n \t\t\t\t  sym_hdr.issMax,\n \t\t\t\t  sym_hdr.cbSsOffset,\n \t\t\t\t  \"Local string table\");\n \n-  e_strings = (char *) read_seek (NULL_PTR,\n+  e_strings = (char *) read_seek (NULL,\n \t\t\t\t  sym_hdr.issExtMax,\n \t\t\t\t  sym_hdr.cbSsExtOffset,\n \t\t\t\t  \"External string table\");\n \n-  file_desc = (FDR *) read_seek (NULL_PTR,\n+  file_desc = (FDR *) read_seek (NULL,\n \t\t\t\t sym_hdr.ifdMax * sizeof (FDR),\n \t\t\t\t sym_hdr.cbFdOffset,\n \t\t\t\t \"File tables\");\n \n-  rfile_desc = (ulong *) read_seek (NULL_PTR,\n+  rfile_desc = (ulong *) read_seek (NULL,\n \t\t\t\t    sym_hdr.crfd * sizeof (ulong),\n \t\t\t\t    sym_hdr.cbRfdOffset,\n \t\t\t\t    \"Relative file tables\");\n \n-  e_symbols = (EXTR *) read_seek (NULL_PTR,\n+  e_symbols = (EXTR *) read_seek (NULL,\n \t\t\t\t  sym_hdr.iextMax * sizeof (EXTR),\n \t\t\t\t  sym_hdr.cbExtOffset,\n \t\t\t\t  \"External symbols\");"}, {"sha": "f12e8f45617c68fe6e22af85e80e2263232f3dff", "filename": "gcc/reload1.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9714cf4399fc4833c9055d4a0e5c5cc504226c44/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9714cf4399fc4833c9055d4a0e5c5cc504226c44/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=9714cf4399fc4833c9055d4a0e5c5cc504226c44", "patch": "@@ -678,7 +678,7 @@ reload (first, global)\n \n   /* The two pointers used to track the true location of the memory used\n      for label offsets.  */\n-  char *real_known_ptr = NULL_PTR;\n+  char *real_known_ptr = NULL;\n   int (*real_at_ptr)[NUM_ELIMINABLE_REGS];\n \n   /* Make sure even insns with volatile mem refs are recognizable.  */\n@@ -5617,7 +5617,7 @@ choose_reload_regs (chain)\n \t    {\n \t      register rtx equiv\n \t\t= find_equiv_reg (search_equiv, insn, rld[r].class,\n-\t\t\t\t  -1, NULL_PTR, 0, rld[r].mode);\n+\t\t\t\t  -1, NULL, 0, rld[r].mode);\n \t      int regno = 0;\n \n \t      if (equiv != 0)\n@@ -6164,7 +6164,7 @@ emit_input_reload_insns (chain, rl, old, j)\n     oldequiv\n       = find_equiv_reg (old, insn,\n \t\t\trld[rl->secondary_in_reload].class,\n-\t\t\t-1, NULL_PTR, 0, mode);\n+\t\t\t-1, NULL, 0, mode);\n #endif\n \n   /* If reloading from memory, see if there is a register\n@@ -6180,8 +6180,7 @@ emit_input_reload_insns (chain, rl, old, j)\n \t  || (GET_CODE (old) == REG\n \t      && REGNO (old) >= FIRST_PSEUDO_REGISTER\n \t      && reg_renumber[REGNO (old)] < 0)))\n-    oldequiv = find_equiv_reg (old, insn, ALL_REGS,\n-\t\t\t       -1, NULL_PTR, 0, mode);\n+    oldequiv = find_equiv_reg (old, insn, ALL_REGS, -1, NULL, 0, mode);\n \n   if (oldequiv)\n     {"}, {"sha": "121b8791314de4f8a6d288e5bd6eca25ab1bb78e", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9714cf4399fc4833c9055d4a0e5c5cc504226c44/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9714cf4399fc4833c9055d4a0e5c5cc504226c44/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=9714cf4399fc4833c9055d4a0e5c5cc504226c44", "patch": "@@ -1214,7 +1214,7 @@ reg_overlap_mentioned_p (x, in)\n     do_reg:\n       endregno = regno + (regno < FIRST_PSEUDO_REGISTER\n \t\t\t  ? HARD_REGNO_NREGS (regno, GET_MODE (x)) : 1);\n-      return refers_to_regno_p (regno, endregno, in, NULL_PTR);\n+      return refers_to_regno_p (regno, endregno, in, (rtx*)0);\n \n     case MEM:\n       {"}, {"sha": "e628635fc6aebb287946acba60ceaa4a617511ae", "filename": "gcc/stmt.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9714cf4399fc4833c9055d4a0e5c5cc504226c44/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9714cf4399fc4833c9055d4a0e5c5cc504226c44/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=9714cf4399fc4833c9055d4a0e5c5cc504226c44", "patch": "@@ -1088,7 +1088,7 @@ void\n expand_fixups (first_insn)\n      rtx first_insn;\n {\n-  fixup_gotos (NULL_PTR, NULL_RTX, NULL_TREE, first_insn, 0);\n+  fixup_gotos (NULL, NULL_RTX, NULL_TREE, first_insn, 0);\n }\n \n /* When exiting a binding contour, process all pending gotos requiring fixups.\n@@ -5349,8 +5349,7 @@ expand_end_case (orig_index)\n \t      use_cost_table\n \t\t= (TREE_CODE (TREE_TYPE (orig_index)) != ENUMERAL_TYPE\n \t\t   && estimate_case_costs (thiscase->data.case_stmt.case_list));\n-\t      balance_case_nodes (&thiscase->data.case_stmt.case_list,\n-\t\t\t\t  NULL_PTR);\n+\t      balance_case_nodes (&thiscase->data.case_stmt.case_list, NULL);\n \t      emit_case_nodes (index, thiscase->data.case_stmt.case_list,\n \t\t\t       default_label, index_type);\n \t      emit_jump_if_reachable (default_label);"}, {"sha": "a278eb11e54a186168abd7a405443185d41ee6f4", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9714cf4399fc4833c9055d4a0e5c5cc504226c44/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9714cf4399fc4833c9055d4a0e5c5cc504226c44/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=9714cf4399fc4833c9055d4a0e5c5cc504226c44", "patch": "@@ -171,7 +171,7 @@ variable_size (size)\n   if (immediate_size_expand)\n     /* NULL_RTX is not defined; neither is the rtx type. \n        Also, we would like to pass const0_rtx here, but don't have it.  */\n-    expand_expr (size, expand_expr (integer_zero_node, NULL_PTR, VOIDmode, 0),\n+    expand_expr (size, expand_expr (integer_zero_node, NULL_RTX, VOIDmode, 0),\n \t\t VOIDmode, 0);\n   else if (cfun != 0 && cfun->x_dont_save_pending_sizes_p)\n     /* The front-end doesn't want us to keep a list of the expressions"}, {"sha": "9c0fcf49fab1b6f0722b41019b99db433884b023", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9714cf4399fc4833c9055d4a0e5c5cc504226c44/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9714cf4399fc4833c9055d4a0e5c5cc504226c44/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=9714cf4399fc4833c9055d4a0e5c5cc504226c44", "patch": "@@ -1948,7 +1948,7 @@ wrapup_global_declarations (vec, len)\n \t\t  || TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))))\n \t    {\n \t      reconsider = 1;\n-\t      rest_of_decl_compilation (decl, NULL_PTR, 1, 1);\n+\t      rest_of_decl_compilation (decl, NULL, 1, 1);\n \t    }\n \n \t  if (TREE_CODE (decl) == FUNCTION_DECL\n@@ -3374,7 +3374,7 @@ rest_of_compilation (decl)\n #ifdef OPTIMIZE_MODE_SWITCHING\n   timevar_push (TV_GCSE);\n \n-  if (optimize_mode_switching (NULL_PTR))\n+  if (optimize_mode_switching (NULL))\n     {\n       /* We did work, and so had to regenerate global life information.\n \t Take advantage of this and don't re-recompute register life"}]}