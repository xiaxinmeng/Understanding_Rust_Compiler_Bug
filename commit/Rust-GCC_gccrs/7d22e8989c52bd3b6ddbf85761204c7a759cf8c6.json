{"sha": "7d22e8989c52bd3b6ddbf85761204c7a759cf8c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2QyMmU4OTg5YzUyYmQzYjZkZGJmODU3NjEyMDRjN2E3NTljZjhjNg==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@st.com", "date": "2005-12-13T13:04:18Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2005-12-13T13:04:18Z"}, "message": "PR rtl-optimization/20070 / part1\n\n\tPR rtl-optimization/20070 / part1\n\t* flow.c (update_life_info): If PROP_POST_REGSTACK is set, call\n\tcount_or_remove_death_notes with kill == -1.\n\t(mark_set_1): Don't add REG_DEAD / REG_UNUSED notes for stack\n\tregisters if PROP_POST_REGSTACK is set.\n\t(mark_used_reg): Likewise.\n\t(count_or_remove_death_notes): If kill is -1, don't remove REG_DEAD /\n\tREG_UNUSED notes for stack regs.\n\t* cfgcleanup.c (condjump_equiv_p): Change parameters and processing\n\tto match rtx_equiv_p machinery.  Change caller.\n\t(outgoing_edges_match): Likewise.\n\t(try_crossjump_to_edge): Use struct_equiv_block_eq\n\tinstead of flow_find_cross_jump.\n\t* basic-block.h (PROP_POST_REGSTACK, STRUCT_EQUIV_START): Define.\n\t(STRUCT_EQUIV_RERUN, STRUCT_EQUIV_FINAL): Likewise.\n\t(STRUCT_EQUIV_NEED_FULL_BLOCK, STRUCT_EQUIV_MATCH_JUMPS): Likewise.\n\t(STRUCT_EQUIV_MAX_LOCAL): Likewise.\n\t(struct struct_equiv_checkpoint, struct equiv_info): Likewise.\n\t(insns_match_p): Update prototype.\n\t(flow_find_cross_jump): Remove prototype.\n\t(struct_equiv_block_eq, struct_equiv_init): Declare.\n\t(rtx_equiv_p, condjump_equiv_p): Likewise.\n\t* struct-equiv.c: Include reload.h.\n\t(IMPOSSIBLE_MOVE_FACTOR): Define.\n\t(assign_reg_reg_set, struct_equiv_make_checkpoint): New functions.\n\t(struct_equiv_improve_checkpoint): Likewise.\n\t(struct_equiv_restore_checkpoint, rtx_equiv_p): Likewise.\n\t(set_dest_equiv_p, set_dest_addr_equiv_p, struct_equiv_init): Likewise.\n\t(struct_equiv_merge, find_dying_input): Likewise.\n\t(resolve_input_conflict, note_local_live): Likewise.\n\t(death_notes_match_p): Change parameters and processing\n\tto match rtx_equiv_p machinery.  Change caller.\n\t(insns_match_p): Likewise.\n\t(flow_find_cross_jump): Replace with:\n\t(struct_equiv_block_eq).\n\n\tBack out this change:\n\t2005-03-07  Kazu Hirata  <kazu@cs.umass.edu>\n          * recog.c (verify_changes): Make it static.\n          * recog.h: Remove the corresponding prototype.\n\nFrom-SVN: r108480", "tree": {"sha": "e701881426d487009dc1064a87c21abe61a14c8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e701881426d487009dc1064a87c21abe61a14c8a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d22e8989c52bd3b6ddbf85761204c7a759cf8c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d22e8989c52bd3b6ddbf85761204c7a759cf8c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d22e8989c52bd3b6ddbf85761204c7a759cf8c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d22e8989c52bd3b6ddbf85761204c7a759cf8c6/comments", "author": null, "committer": null, "parents": [{"sha": "80e6edb051397f18aa328e0ddeb83f4bf380b3f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80e6edb051397f18aa328e0ddeb83f4bf380b3f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80e6edb051397f18aa328e0ddeb83f4bf380b3f9"}], "stats": {"total": 1681, "additions": 1491, "deletions": 190}, "files": [{"sha": "69bbe6d1b08d640d6617fc0e260e81ee22bf6cf5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d22e8989c52bd3b6ddbf85761204c7a759cf8c6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d22e8989c52bd3b6ddbf85761204c7a759cf8c6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7d22e8989c52bd3b6ddbf85761204c7a759cf8c6", "patch": "@@ -1,3 +1,46 @@\n+2005-12-13  J\"orn Rennecke <joern.rennecke@st.com>\n+\n+\tPR rtl-optimization/20070 / part1\n+\t* flow.c (update_life_info): If PROP_POST_REGSTACK is set, call\n+\tcount_or_remove_death_notes with kill == -1.\n+\t(mark_set_1): Don't add REG_DEAD / REG_UNUSED notes for stack\n+\tregisters if PROP_POST_REGSTACK is set.\n+\t(mark_used_reg): Likewise.\n+\t(count_or_remove_death_notes): If kill is -1, don't remove REG_DEAD /\n+\tREG_UNUSED notes for stack regs.\n+\t* cfgcleanup.c (condjump_equiv_p): Change parameters and processing\n+\tto match rtx_equiv_p machinery.  Change caller.\n+\t(outgoing_edges_match): Likewise.\n+\t(try_crossjump_to_edge): Use struct_equiv_block_eq\n+\tinstead of flow_find_cross_jump.\n+\t* basic-block.h (PROP_POST_REGSTACK, STRUCT_EQUIV_START): Define.\n+\t(STRUCT_EQUIV_RERUN, STRUCT_EQUIV_FINAL): Likewise.\n+\t(STRUCT_EQUIV_NEED_FULL_BLOCK, STRUCT_EQUIV_MATCH_JUMPS): Likewise.\n+\t(STRUCT_EQUIV_MAX_LOCAL): Likewise.\n+\t(struct struct_equiv_checkpoint, struct equiv_info): Likewise.\n+\t(insns_match_p): Update prototype.\n+\t(flow_find_cross_jump): Remove prototype.\n+\t(struct_equiv_block_eq, struct_equiv_init): Declare.\n+\t(rtx_equiv_p, condjump_equiv_p): Likewise.\n+\t* struct-equiv.c: Include reload.h.\n+\t(IMPOSSIBLE_MOVE_FACTOR): Define.\n+\t(assign_reg_reg_set, struct_equiv_make_checkpoint): New functions.\n+\t(struct_equiv_improve_checkpoint): Likewise.\n+\t(struct_equiv_restore_checkpoint, rtx_equiv_p): Likewise.\n+\t(set_dest_equiv_p, set_dest_addr_equiv_p, struct_equiv_init): Likewise.\n+\t(struct_equiv_merge, find_dying_input): Likewise.\n+\t(resolve_input_conflict, note_local_live): Likewise.\n+\t(death_notes_match_p): Change parameters and processing\n+\tto match rtx_equiv_p machinery.  Change caller.\n+\t(insns_match_p): Likewise.\n+\t(flow_find_cross_jump): Replace with:\n+\t(struct_equiv_block_eq).\n+\n+\tBack out this change:\n+\t2005-03-07  Kazu Hirata  <kazu@cs.umass.edu>\n+          * recog.c (verify_changes): Make it static.\n+          * recog.h: Remove the corresponding prototype.\n+\n 2005-12-13  J\"orn Rennecke <joern.rennecke@st.com>\n \n \t* rtlhooks.c (gen_lowpart_general): Handle SUBREGs of floating point"}, {"sha": "a3cecae8b6f519845e70a9a1d38c0ba7918e2494", "filename": "gcc/basic-block.h", "status": "modified", "additions": 177, "deletions": 2, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d22e8989c52bd3b6ddbf85761204c7a759cf8c6/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d22e8989c52bd3b6ddbf85761204c7a759cf8c6/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=7d22e8989c52bd3b6ddbf85761204c7a759cf8c6", "patch": "@@ -807,6 +807,9 @@ enum update_life_extent\n \t\t\t\t\t   to flag analysis of asms.  */\n #define PROP_DEAD_INSN\t\t1024\t/* Internal flag used within flow.c\n \t\t\t\t\t   to flag analysis of dead insn.  */\n+#define PROP_POST_REGSTACK\t2048\t/* We run after reg-stack and need\n+\t\t\t\t\t   to preserve REG_DEAD notes for\n+\t\t\t\t\t   stack regs.  */\n #define PROP_FINAL\t\t(PROP_DEATH_NOTES | PROP_LOG_LINKS  \\\n \t\t\t\t | PROP_REG_INFO | PROP_KILL_DEAD_CODE  \\\n \t\t\t\t | PROP_SCAN_DEAD_CODE | PROP_AUTOINC \\\n@@ -831,6 +834,17 @@ enum update_life_extent\n #define CLEANUP_CFGLAYOUT\t128\t/* Do cleanup in cfglayout mode.  */\n #define CLEANUP_LOG_LINKS\t256\t/* Update log links.  */\n \n+/* The following are ORed in on top of the CLEANUP* flags in calls to\n+   struct_equiv_block_eq.  */\n+#define STRUCT_EQUIV_START\t512\t /* Initializes the search range.  */\n+#define STRUCT_EQUIV_RERUN\t1024\t/* Rerun to find register use in\n+\t\t\t\t\t   found equivalence.  */\n+#define STRUCT_EQUIV_FINAL\t2048\t/* Make any changes necessary to get\n+\t\t\t\t\t   actual equivalence.  */\n+#define STRUCT_EQUIV_NEED_FULL_BLOCK 4096 /* struct_equiv_block_eq is required\n+\t\t\t\t\t     to match only full blocks  */\n+#define STRUCT_EQUIV_MATCH_JUMPS 8192\t/* Also include the jumps at the end of the block in the comparison.  */\n+\n extern void life_analysis (FILE *, int);\n extern int update_life_info (sbitmap, enum update_life_extent, int);\n extern int update_life_info_in_dirty_blocks (enum update_life_extent, int);\n@@ -992,7 +1006,168 @@ extern basic_block get_bb_copy (basic_block);\n #include \"cfghooks.h\"\n \n /* In struct-equiv.c */\n-extern bool insns_match_p (int, rtx, rtx);\n-extern int flow_find_cross_jump (int, basic_block, basic_block, rtx *, rtx *);\n+\n+/* Constants used to size arrays in struct equiv_info (currently only one).\n+   When these limits are exceeded, struct_equiv returns zero.\n+   The maximum number of pseudo registers that are different in the two blocks,\n+   but appear in equivalent places and are dead at the end (or where one of\n+   a pair is dead at the end).  */\n+#define STRUCT_EQUIV_MAX_LOCAL 16\n+/* The maximum number of references to an input register that struct_equiv\n+   can handle.  */\n+\n+/* Structure used to track state during struct_equiv that can be rolled\n+   back when we find we can't match an insn, or if we want to match part\n+   of it in a different way.\n+   This information pertains to the pair of partial blocks that has been\n+   matched so far.  Since this pair is structurally equivalent, this is\n+   conceptually just one partial block expressed in two potentially\n+   different ways.  */\n+struct struct_equiv_checkpoint\n+{\n+  int ninsns;       /* Insns are matched so far.  */\n+  int local_count;  /* Number of block-local registers.  */\n+  int input_count;  /* Number of inputs to the block.  */\n+\n+  /* X_START and Y_START are the first insns (in insn stream order)\n+     of the partial blocks that have been considered for matching so far.\n+     Since we are scanning backwards, they are also the instructions that\n+     are currently considered - or the last ones that have been considered -\n+     for matching (Unless we tracked back to these because a preceding\n+     instruction failed to match).  */\n+  rtx x_start, y_start;\n+\n+  /*  INPUT_VALID indicates if we have actually set up X_INPUT / Y_INPUT\n+      during the current pass; we keep X_INPUT / Y_INPUT around between passes\n+      so that we can match REG_EQUAL / REG_EQUIV notes referring to these.  */\n+  bool input_valid;\n+\n+  /* Some information would be expensive to exactly checkpoint, so we\n+     merely increment VERSION any time information about local\n+     registers, inputs and/or register liveness changes.  When backtracking,\n+     it is decremented for changes that can be undone, and if a discrepancy\n+     remains, NEED_RERUN in the relevant struct equiv_info is set to indicate\n+     that a new pass should be made over the entire block match to get\n+     accurate register information.  */\n+  int version;\n+};\n+\n+/* A struct equiv_info is used to pass information to struct_equiv and\n+   to gather state while two basic blocks are checked for structural\n+   equivalence.  */\n+\n+struct equiv_info\n+{\n+  /* Fields set up by the caller to struct_equiv_block_eq */\n+\n+  basic_block x_block, y_block;  /* The two blocks being matched.  */\n+\n+  /* MODE carries the mode bits from cleanup_cfg if we are called from\n+     try_crossjump_to_edge, and additionally it carries the\n+     STRUCT_EQUIV_* bits described above.  */\n+  int mode;\n+\n+  /* INPUT_COST is the cost that adding an extra input to the matched blocks\n+     is supposed to have, and is taken into account when considering if the\n+     matched sequence should be extended backwards.  input_cost < 0 means\n+     don't accept any inputs at all.  */\n+  int input_cost;\n+\n+\n+  /* Fields to track state inside of struct_equiv_block_eq.  Some of these\n+     are also outputs.  */\n+\n+  /* X_INPUT and Y_INPUT are used by struct_equiv to record a register that\n+     is used as an input parameter, i.e. where different registers are used\n+     as sources.  This is only used for a register that is live at the end\n+     of the blocks, or in some identical code at the end of the blocks;\n+     Inputs that are dead at the end go into X_LOCAL / Y_LOCAL.  */\n+  rtx x_input, y_input;\n+  /* When a previous pass has identified a valid input, INPUT_REG is set\n+     by struct_equiv_block_eq, and it is henceforth replaced in X_BLOCK\n+     for the input.  */\n+  rtx input_reg;\n+\n+  /* COMMON_LIVE keeps track of the registers which are currently live\n+     (as we scan backwards from the end) and have the same numbers in both\n+     blocks.  N.B. a register that is in common_live is unsuitable to become\n+     a local reg.  */\n+  regset common_live;\n+  /* Likewise, X_LOCAL_LIVE / Y_LOCAL_LIVE keep track of registers that are\n+     local to one of the blocks; these registers must not be accepted as\n+     identical when encountered in both blocks.  */\n+  regset x_local_live, y_local_live;\n+\n+  /* EQUIV_USED indicates for which insns a REG_EQUAL or REG_EQUIV note is\n+     being used, to avoid having to backtrack in the next pass, so that we\n+     get accurate life info for this insn then.  For each such insn,\n+     the bit with the number corresponding to the CUR.NINSNS value at the\n+     time of scanning is set.  */\n+  bitmap equiv_used;\n+\n+  /* Current state that can be saved & restored easily.  */\n+  struct struct_equiv_checkpoint cur;\n+  /* BEST_MATCH is used to store the best match so far, weighing the\n+     cost of matched insns COSTS_N_INSNS (CUR.NINSNS) against the cost\n+     CUR.INPUT_COUNT * INPUT_COST of setting up the inputs.  */\n+  struct struct_equiv_checkpoint best_match;\n+  /* If a checkpoint restore failed, or an input conflict newly arises,\n+     NEED_RERUN is set.  This has to be tested by the caller to re-run\n+     the comparison if the match appears otherwise sound.  The state kept in\n+     x_start, y_start, equiv_used and check_input_conflict ensures that\n+     we won't loop indefinetly.  */\n+  bool need_rerun;\n+  /* If there is indication of an input conflict at the end,\n+     CHECK_INPUT_CONFLICT is set so that we'll check for input conflicts\n+     for each insn in the next pass.  This is needed so that we won't discard\n+     a partial match if there is a longer match that has to be abandoned due\n+     to an input conflict.  */\n+  bool check_input_conflict;\n+  /* HAD_INPUT_CONFLICT is set if CHECK_INPUT_CONFLICT was already set and we\n+     have passed a point where there were multiple dying inputs.  This helps\n+     us decide if we should set check_input_conflict for the next pass.  */\n+  bool had_input_conflict;\n+\n+  /* LIVE_UPDATE controls if we want to change any life info at all.  We\n+     set it to false during REG_EQUAL / REG_EUQIV note comparison of the final\n+     pass so that we don't introduce new registers just for the note; if we\n+     can't match the notes without the current register information, we drop\n+     them.  */\n+  bool live_update;\n+\n+  /* X_LOCAL and Y_LOCAL are used to gather register numbers of register pairs\n+     that are local to X_BLOCK and Y_BLOCK, with CUR.LOCAL_COUNT being the index\n+     to the next free entry.  */\n+  rtx x_local[STRUCT_EQUIV_MAX_LOCAL], y_local[STRUCT_EQUIV_MAX_LOCAL];\n+  /* LOCAL_RVALUE is nonzero if the corresponding X_LOCAL / Y_LOCAL entry\n+     was a source operand (including STRICT_LOW_PART) for the last invocation\n+     of struct_equiv mentioning it, zero if it was a destination-only operand.\n+     Since we are scanning backwards, this means the register is input/local\n+     for the (partial) block scanned so far.  */\n+  bool local_rvalue[STRUCT_EQUIV_MAX_LOCAL];\n+\n+\n+  /* Additional fields that are computed for the convenience of the caller.  */\n+\n+  /* DYING_INPUTS is set to the number of local registers that turn out\n+     to be inputs to the (possibly partial) block.  */\n+  int dying_inputs;\n+  /* X_END and Y_END are the last insns in X_BLOCK and Y_BLOCK, respectively,\n+     that are being compared.  A final jump insn will not be included.  */\n+  rtx x_end, y_end;\n+\n+  /* If we are matching tablejumps, X_LABEL in X_BLOCK coresponds to\n+     Y_LABEL in Y_BLOCK.  */\n+  rtx x_label, y_label;\n+\n+};\n+\n+extern bool insns_match_p (rtx, rtx, struct equiv_info *);\n+extern int struct_equiv_block_eq (int, struct equiv_info *);\n+extern bool struct_equiv_init (int, struct equiv_info *);\n+extern bool rtx_equiv_p (rtx *, rtx, int, struct equiv_info *);\n+\n+/* In cfgrtl.c */\n+extern bool condjump_equiv_p (struct equiv_info *, bool);\n \n #endif /* GCC_BASIC_BLOCK_H */"}, {"sha": "c4939d07ceba4af3611f852e4425287623e6b0e5", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 137, "deletions": 68, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d22e8989c52bd3b6ddbf85761204c7a759cf8c6/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d22e8989c52bd3b6ddbf85761204c7a759cf8c6/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=7d22e8989c52bd3b6ddbf85761204c7a759cf8c6", "patch": "@@ -60,7 +60,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n static bool first_pass;\n static bool try_crossjump_to_edge (int, edge, edge);\n static bool try_crossjump_bb (int, basic_block);\n-static bool outgoing_edges_match (int, basic_block, basic_block);\n+static bool outgoing_edges_match (int *, struct equiv_info *);\n \n static void merge_blocks_move_predecessor_nojumps (basic_block, basic_block);\n static void merge_blocks_move_successor_nojumps (basic_block, basic_block);\n@@ -879,20 +879,20 @@ merge_blocks_move (edge e, basic_block b, basic_block c, int mode)\n }\n \f\n /* Return true iff the condbranches at the end of BB1 and BB2 match.  */\n-static bool\n-condjump_equiv_p (basic_block bb1, basic_block bb2)\n+bool\n+condjump_equiv_p (struct equiv_info *info, bool call_init)\n {\n-  edge b1, f1, b2, f2;\n+  basic_block bb1 = info->x_block;\n+  basic_block bb2 = info->y_block;\n+  edge b1 = BRANCH_EDGE (bb1);\n+  edge b2 = BRANCH_EDGE (bb2);\n+  edge f1 = FALLTHRU_EDGE (bb1);\n+  edge f2 = FALLTHRU_EDGE (bb2);\n   bool reverse, match;\n   rtx set1, set2, cond1, cond2;\n+  rtx src1, src2;\n   enum rtx_code code1, code2;\n \n-\n-  b1 = BRANCH_EDGE (bb1);\n-  b2 = BRANCH_EDGE (bb2);\n-  f1 = FALLTHRU_EDGE (bb1);\n-  f2 = FALLTHRU_EDGE (bb2);\n-\n   /* Get around possible forwarders on fallthru edges.  Other cases\n      should be optimized out already.  */\n   if (FORWARDER_BLOCK_P (f1->dest))\n@@ -923,8 +923,10 @@ condjump_equiv_p (basic_block bb1, basic_block bb2)\n       != (XEXP (SET_SRC (set2), 1) == pc_rtx))\n     reverse = !reverse;\n \n-  cond1 = XEXP (SET_SRC (set1), 0);\n-  cond2 = XEXP (SET_SRC (set2), 0);\n+  src1 = SET_SRC (set1);\n+  src2 = SET_SRC (set2);\n+  cond1 = XEXP (src1, 0);\n+  cond2 = XEXP (src2, 0);\n   code1 = GET_CODE (cond1);\n   if (reverse)\n     code2 = reversed_comparison_code (cond2, BB_END (bb2));\n@@ -934,15 +936,35 @@ condjump_equiv_p (basic_block bb1, basic_block bb2)\n   if (code2 == UNKNOWN)\n     return false;\n \n+  if (call_init && !struct_equiv_init (STRUCT_EQUIV_START | info->mode, info))\n+    gcc_unreachable ();\n+  /* Make the sources of the pc sets unreadable so that when we call\n+     insns_match_p it won't process them.\n+     The death_notes_match_p from insns_match_p won't see the local registers\n+     used for the pc set, but that could only cause missed optimizations when\n+     there are actually condjumps that use stack registers.  */\n+  SET_SRC (set1) = pc_rtx;\n+  SET_SRC (set2) = pc_rtx;\n   /* Verify codes and operands match.  */\n-  match = ((code1 == code2\n-            && rtx_renumbered_equal_p (XEXP (cond1, 0), XEXP (cond2, 0))\n-            && rtx_renumbered_equal_p (XEXP (cond1, 1), XEXP (cond2, 1)))\n-           || (code1 == swap_condition (code2)\n-               && rtx_renumbered_equal_p (XEXP (cond1, 1),\n-                                          XEXP (cond2, 0))\n-               && rtx_renumbered_equal_p (XEXP (cond1, 0),\n-                                          XEXP (cond2, 1))));\n+  if (code1 == code2)\n+    {\n+      match = (insns_match_p (BB_END (bb1), BB_END (bb2), info)\n+\t       && rtx_equiv_p (&XEXP (cond1, 0), XEXP (cond2, 0), 1, info)\n+\t       && rtx_equiv_p (&XEXP (cond1, 1), XEXP (cond2, 1), 1, info));\n+\n+    }\n+  else if (code1 == swap_condition (code2))\n+    {\n+      match = (insns_match_p (BB_END (bb1), BB_END (bb2), info)\n+\t       && rtx_equiv_p (&XEXP (cond1, 1), XEXP (cond2, 0), 1, info)\n+\t       && rtx_equiv_p (&XEXP (cond1, 0), XEXP (cond2, 1), 1, info));\n+\n+    }\n+  else\n+    match = false;\n+  SET_SRC (set1) = src1;\n+  SET_SRC (set2) = src2;\n+  match &= verify_changes (0);\n \n   /* If we return true, we will join the blocks.  Which means that\n      we will only have one branch prediction bit to work with.  Thus\n@@ -971,25 +993,33 @@ condjump_equiv_p (basic_block bb1, basic_block bb2)\n \t\t     \"Outcomes of branch in bb %i and %i differ too much (%i %i)\\n\",\n \t\t     bb1->index, bb2->index, b1->probability, prob2);\n \n-\t  return false;\n+\t  match = false;\n \t}\n     }\n \n   if (dump_file && match)\n     fprintf (dump_file, \"Conditionals in bb %i and %i match.\\n\",\n \t     bb1->index, bb2->index);\n \n+  if (!match)\n+    cancel_changes (0);\n   return match;\n }\n-/* Return true iff outgoing edges of BB1 and BB2 match, together with\n-   the branch instruction.  This means that if we commonize the control\n-   flow before end of the basic block, the semantic remains unchanged.\n+\n+/* Return true iff outgoing edges of INFO->y_block and INFO->x_block match,\n+   together with the branch instruction.  This means that if we commonize the\n+   control flow before end of the basic block, the semantic remains unchanged.\n+   If we need to compare jumps, we set STRUCT_EQUIV_MATCH_JUMPS in *MODE,\n+   and pass *MODE to struct_equiv_init or assign it to INFO->mode, as\n+   appropriate.\n \n    We may assume that there exists one edge with a common destination.  */\n \n static bool\n-outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n+outgoing_edges_match (int *mode, struct equiv_info *info)\n {\n+  basic_block bb1 = info->y_block;\n+  basic_block bb2 = info->x_block;\n   int nehedges1 = 0, nehedges2 = 0;\n   edge fallthru1 = 0, fallthru2 = 0;\n   edge e1, e2;\n@@ -1005,6 +1035,7 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n \t\t& (EDGE_COMPLEX | EDGE_FAKE)) == 0\n \t    && (!JUMP_P (BB_END (bb2)) || simplejump_p (BB_END (bb2))));\n \n+  *mode |= STRUCT_EQUIV_MATCH_JUMPS;\n   /* Match conditional jumps - this may get tricky when fallthru and branch\n      edges are crossed.  */\n   if (EDGE_COUNT (bb1->succs) == 2\n@@ -1015,7 +1046,8 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n \t  || !any_condjump_p (BB_END (bb2))\n \t  || !onlyjump_p (BB_END (bb2)))\n \treturn false;\n-      return condjump_equiv_p (bb1, bb2);\n+      info->mode = *mode;\n+      return condjump_equiv_p (info, true);\n     }\n \n   /* Generic case - we are seeing a computed jump, table jump or trapping\n@@ -1063,31 +1095,22 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n \t\t      identical = false;\n \t\t}\n \n-\t      if (identical)\n+\t      if (identical\n+\t\t  && struct_equiv_init (STRUCT_EQUIV_START | *mode, info))\n \t\t{\n-\t\t  replace_label_data rr;\n \t\t  bool match;\n \n-\t\t  /* Temporarily replace references to LABEL1 with LABEL2\n+\t\t  /* Indicate that LABEL1 is to be replaced with LABEL2\n \t\t     in BB1->END so that we could compare the instructions.  */\n-\t\t  rr.r1 = label1;\n-\t\t  rr.r2 = label2;\n-\t\t  rr.update_label_nuses = false;\n-\t\t  for_each_rtx (&BB_END (bb1), replace_label, &rr);\n+\t\t  info->y_label = label1;\n+\t\t  info->x_label = label2;\n \n-\t\t  match = insns_match_p (mode, BB_END (bb1), BB_END (bb2));\n+\t\t  match = insns_match_p (BB_END (bb1), BB_END (bb2), info);\n \t\t  if (dump_file && match)\n \t\t    fprintf (dump_file,\n \t\t\t     \"Tablejumps in bb %i and %i match.\\n\",\n \t\t\t     bb1->index, bb2->index);\n \n-\t\t  /* Set the original label in BB1->END because when deleting\n-\t\t     a block whose end is a tablejump, the tablejump referenced\n-\t\t     from the instruction is deleted too.  */\n-\t\t  rr.r1 = label2;\n-\t\t  rr.r2 = label1;\n-\t\t  for_each_rtx (&BB_END (bb1), replace_label, &rr);\n-\n \t\t  return match;\n \t\t}\n \t    }\n@@ -1097,7 +1120,8 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n \n   /* First ensure that the instructions match.  There may be many outgoing\n      edges so this test is generally cheaper.  */\n-  if (!insns_match_p (mode, BB_END (bb1), BB_END (bb2)))\n+  if (!struct_equiv_init (STRUCT_EQUIV_START | *mode, info)\n+      || !insns_match_p (BB_END (bb1), BB_END (bb2), info))\n     return false;\n \n   /* Search the outgoing edges, ensure that the counts do match, find possible\n@@ -1163,14 +1187,13 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n static bool\n try_crossjump_to_edge (int mode, edge e1, edge e2)\n {\n-  int nmatch;\n+  int nmatch, i;\n   basic_block src1 = e1->src, src2 = e2->src;\n   basic_block redirect_to, redirect_from, to_remove;\n-  rtx newpos1, newpos2;\n   edge s;\n   edge_iterator ei;\n-\n-  newpos1 = newpos2 = NULL_RTX;\n+  struct equiv_info info;\n+  rtx x_active, y_active;\n \n   /* If we have partitioned hot/cold basic blocks, it is a bad idea\n      to try this optimization.\n@@ -1217,19 +1240,66 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n     return false;\n \n   /* Look for the common insn sequence, part the first ...  */\n-  if (!outgoing_edges_match (mode, src1, src2))\n+  info.x_block = src2;\n+  info.y_block = src1;\n+  if (!outgoing_edges_match (&mode, &info))\n     return false;\n \n   /* ... and part the second.  */\n-  nmatch = flow_find_cross_jump (mode, src1, src2, &newpos1, &newpos2);\n+  info.input_cost = optimize_size ? COSTS_N_INSNS (1) : -1;\n+  nmatch = struct_equiv_block_eq (STRUCT_EQUIV_START | mode, &info);\n \n   /* Don't proceed with the crossjump unless we found a sufficient number\n      of matching instructions or the 'from' block was totally matched\n      (such that its predecessors will hopefully be redirected and the\n      block removed).  */\n-  if ((nmatch < PARAM_VALUE (PARAM_MIN_CROSSJUMP_INSNS))\n-      && (newpos1 != BB_HEAD (src1)))\n+  if (!nmatch)\n     return false;\n+  if ((nmatch -info.cur.input_count < PARAM_VALUE (PARAM_MIN_CROSSJUMP_INSNS))\n+      && (info.cur.y_start != BB_HEAD (src1)))\n+    return false;\n+  while (info.need_rerun)\n+    {\n+      nmatch = struct_equiv_block_eq (STRUCT_EQUIV_RERUN | mode, &info);\n+      if (!nmatch)\n+\treturn false;\n+      if ((nmatch -info.cur.input_count < PARAM_VALUE (PARAM_MIN_CROSSJUMP_INSNS))\n+\t   && (info.cur.y_start != BB_HEAD (src1)))\n+\treturn false;\n+    }\n+  nmatch = struct_equiv_block_eq (STRUCT_EQUIV_FINAL | mode, &info);\n+  if ((nmatch -info.cur.input_count < PARAM_VALUE (PARAM_MIN_CROSSJUMP_INSNS))\n+      && (info.cur.y_start != BB_HEAD (src1)))\n+    return false;\n+\n+  /* Skip possible basic block header.  */\n+  x_active = info.cur.x_start;\n+  if (LABEL_P (x_active))\n+    x_active = NEXT_INSN (x_active);\n+  if (NOTE_P (x_active))\n+    x_active = NEXT_INSN (x_active);\n+\n+  y_active = info.cur.y_start;\n+  if (LABEL_P (y_active))\n+    y_active = NEXT_INSN (y_active);\n+  if (NOTE_P (y_active))\n+    y_active = NEXT_INSN (y_active);\n+\n+  /* In order for this code to become active, either we have to be called\n+     before reload, or struct_equiv_block_eq needs to add register scavenging\n+     code to allocate input_reg after reload.  */\n+  if (info.input_reg)\n+    {\n+      emit_insn_before (gen_move_insn (info.input_reg, info.x_input),\n+\t\t\tx_active);\n+      emit_insn_before (gen_move_insn (info.input_reg, info.y_input),\n+\t\t\ty_active);\n+    }\n+\n+  for (i = 0; i < info.cur.local_count; i++)\n+    if (info.local_rvalue[i])\n+      emit_insn_before (gen_move_insn (info.x_local[i], info.y_local[i]),\n+\t\t\ty_active);\n \n   /* Here we know that the insns in the end of SRC1 which are common with SRC2\n      will be deleted.\n@@ -1265,30 +1335,36 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n   /* Avoid splitting if possible.  We must always split when SRC2 has\n      EH predecessor edges, or we may end up with basic blocks with both\n      normal and EH predecessor edges.  */\n-  if (newpos2 == BB_HEAD (src2)\n+  if (info.cur.x_start == BB_HEAD (src2)\n       && !(EDGE_PRED (src2, 0)->flags & EDGE_EH))\n     redirect_to = src2;\n   else\n     {\n-      if (newpos2 == BB_HEAD (src2))\n+      if (info.cur.x_start == BB_HEAD (src2))\n \t{\n \t  /* Skip possible basic block header.  */\n-\t  if (LABEL_P (newpos2))\n-\t    newpos2 = NEXT_INSN (newpos2);\n-\t  if (NOTE_P (newpos2))\n-\t    newpos2 = NEXT_INSN (newpos2);\n+\t  if (LABEL_P (info.cur.x_start))\n+\t    info.cur.x_start = NEXT_INSN (info.cur.x_start);\n+\t  if (NOTE_P (info.cur.x_start))\n+\t    info.cur.x_start = NEXT_INSN (info.cur.x_start);\n \t}\n \n       if (dump_file)\n \tfprintf (dump_file, \"Splitting bb %i before %i insns\\n\",\n \t\t src2->index, nmatch);\n-      redirect_to = split_block (src2, PREV_INSN (newpos2))->dest;\n+      redirect_to = split_block (src2, PREV_INSN (info.cur.x_start))->dest;\n+      COPY_REG_SET (info.y_block->il.rtl->global_live_at_end,\n+\t\t    info.x_block->il.rtl->global_live_at_end);\n     }\n \n   if (dump_file)\n-    fprintf (dump_file,\n-\t     \"Cross jumping from bb %i to bb %i; %i common insns\\n\",\n-\t     src1->index, src2->index, nmatch);\n+    {\n+      fprintf (dump_file, \"Cross jumping from bb %i to bb %i; %i common insns\",\n+\t       src1->index, src2->index, nmatch);\n+      if (info.cur.local_count)\n+\tfprintf (dump_file, \", %i local registers\", info.cur.local_count);\n+       fprintf (dump_file, \"\\n\");\n+    }\n \n   redirect_to->count += src1->count;\n   redirect_to->frequency += src1->frequency;\n@@ -1352,14 +1428,7 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n \n   /* Edit SRC1 to go to REDIRECT_TO at NEWPOS1.  */\n \n-  /* Skip possible basic block header.  */\n-  if (LABEL_P (newpos1))\n-    newpos1 = NEXT_INSN (newpos1);\n-\n-  if (NOTE_P (newpos1))\n-    newpos1 = NEXT_INSN (newpos1);\n-\n-  redirect_from = split_block (src1, PREV_INSN (newpos1))->src;\n+  redirect_from = split_block (src1, PREV_INSN (y_active))->src;\n   to_remove = single_succ (redirect_from);\n \n   redirect_edge_and_branch_force (single_succ_edge (redirect_from), redirect_to);"}, {"sha": "f958bfdb66e7880a088c9d9b9b28251007c40970", "filename": "gcc/flow.c", "status": "modified", "additions": 37, "deletions": 6, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d22e8989c52bd3b6ddbf85761204c7a759cf8c6/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d22e8989c52bd3b6ddbf85761204c7a759cf8c6/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=7d22e8989c52bd3b6ddbf85761204c7a759cf8c6", "patch": "@@ -643,7 +643,8 @@ update_life_info (sbitmap blocks, enum update_life_extent extent,\n \n       /* If asked, remove notes from the blocks we'll update.  */\n       if (extent == UPDATE_LIFE_GLOBAL_RM_NOTES)\n-\tcount_or_remove_death_notes (blocks, 1);\n+\tcount_or_remove_death_notes (blocks,\n+\t\t\t\t     prop_flags & PROP_POST_REGSTACK ? -1 : 1);\n     }\n \n   /* Clear log links in case we are asked to (re)compute them.  */\n@@ -2926,7 +2927,13 @@ mark_set_1 (struct propagate_block_info *pbi, enum rtx_code code, rtx reg, rtx c\n \t      if (flags & PROP_REG_INFO)\n \t\tREG_N_DEATHS (regno_first) += 1;\n \n-\t      if (flags & PROP_DEATH_NOTES)\n+\t      if (flags & PROP_DEATH_NOTES\n+#ifdef STACK_REGS\n+\t\t  && (!(flags & PROP_POST_REGSTACK)\n+\t\t      || !IN_RANGE (REGNO (reg), FIRST_STACK_REG,\n+\t\t\t\t    LAST_STACK_REG))\n+#endif\n+\t\t  )\n \t\t{\n \t\t  /* Note that dead stores have already been deleted\n \t\t     when possible.  If we get here, we have found a\n@@ -2939,7 +2946,13 @@ mark_set_1 (struct propagate_block_info *pbi, enum rtx_code code, rtx reg, rtx c\n \t    }\n \t  else\n \t    {\n-\t      if (flags & PROP_DEATH_NOTES)\n+\t      if (flags & PROP_DEATH_NOTES\n+#ifdef STACK_REGS\n+\t\t  && (!(flags & PROP_POST_REGSTACK)\n+\t\t      || !IN_RANGE (REGNO (reg), FIRST_STACK_REG,\n+\t\t\t\t    LAST_STACK_REG))\n+#endif\n+\t\t  )\n \t\t{\n \t\t  /* This is a case where we have a multi-word hard register\n \t\t     and some, but not all, of the words of the register are\n@@ -2998,7 +3011,12 @@ mark_set_1 (struct propagate_block_info *pbi, enum rtx_code code, rtx reg, rtx c\n      here and count it.  */\n   else if (GET_CODE (reg) == SCRATCH)\n     {\n-      if (flags & PROP_DEATH_NOTES)\n+      if (flags & PROP_DEATH_NOTES\n+#ifdef STACK_REGS\n+\t  && (!(flags & PROP_POST_REGSTACK)\n+\t      || !IN_RANGE (REGNO (reg), FIRST_STACK_REG, LAST_STACK_REG))\n+#endif\n+\t  )\n \tREG_NOTES (insn)\n \t  = alloc_EXPR_LIST (REG_UNUSED, reg, REG_NOTES (insn));\n     }\n@@ -3764,6 +3782,10 @@ mark_used_reg (struct propagate_block_info *pbi, rtx reg,\n       if (! some_was_live)\n \t{\n \t  if ((pbi->flags & PROP_DEATH_NOTES)\n+#ifdef STACK_REGS\n+\t      && (!(pbi->flags & PROP_POST_REGSTACK)\n+\t\t  || !IN_RANGE (REGNO (reg), FIRST_STACK_REG, LAST_STACK_REG))\n+#endif\n \t      && ! find_regno_note (insn, REG_DEAD, regno_first))\n \t    REG_NOTES (insn)\n \t      = alloc_EXPR_LIST (REG_DEAD, reg, REG_NOTES (insn));\n@@ -4385,7 +4407,9 @@ struct tree_opt_pass pass_recompute_reg_usage =\n \n /* Optionally removes all the REG_DEAD and REG_UNUSED notes from a set of\n    blocks.  If BLOCKS is NULL, assume the universal set.  Returns a count\n-   of the number of registers that died.  */\n+   of the number of registers that died.\n+   If KILL is 1, remove old REG_DEAD / REG_UNUSED notes.  If it is 0, don't.\n+   if it is -1, remove them unless they pertain to a stack reg.  */\n \n int\n count_or_remove_death_notes (sbitmap blocks, int kill)\n@@ -4457,7 +4481,14 @@ count_or_remove_death_notes_bb (basic_block bb, int kill)\n \t\t  /* Fall through.  */\n \n \t\tcase REG_UNUSED:\n-\t\t  if (kill)\n+\t\t  if (kill > 0\n+\t\t      || (kill\n+#ifdef STACK_REGS\n+\t\t\t  && (!REG_P (XEXP (link, 0))\n+\t\t\t      || !IN_RANGE (REGNO (XEXP (link, 0)),\n+\t\t\t\t\t    FIRST_STACK_REG, LAST_STACK_REG))\n+#endif\n+\t\t\t  ))\n \t\t    {\n \t\t      rtx next = XEXP (link, 1);\n \t\t      free_EXPR_LIST_node (link);"}, {"sha": "1df4b7fd1dec9915cdd820ea2ddeff635c2e736e", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d22e8989c52bd3b6ddbf85761204c7a759cf8c6/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d22e8989c52bd3b6ddbf85761204c7a759cf8c6/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=7d22e8989c52bd3b6ddbf85761204c7a759cf8c6", "patch": "@@ -339,7 +339,7 @@ num_changes_pending (void)\n /* Tentatively apply the changes numbered NUM and up.\n    Return 1 if all changes are valid, zero otherwise.  */\n \n-static int\n+int\n verify_changes (int num)\n {\n   int i;"}, {"sha": "b219c407cf30a05314f1869883860fd302e1128d", "filename": "gcc/recog.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d22e8989c52bd3b6ddbf85761204c7a759cf8c6/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d22e8989c52bd3b6ddbf85761204c7a759cf8c6/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=7d22e8989c52bd3b6ddbf85761204c7a759cf8c6", "patch": "@@ -76,6 +76,7 @@ extern int asm_operand_ok (rtx, const char *);\n extern int validate_change (rtx, rtx *, rtx, int);\n extern int validate_change_maybe_volatile (rtx, rtx *, rtx);\n extern int insn_invalid_p (rtx);\n+extern int verify_changes (int);\n extern void confirm_change_group (void);\n extern int apply_change_group (void);\n extern int num_validated_changes (void);"}, {"sha": "60f146f9a56ff44a3662fa467098193dabe34ad8", "filename": "gcc/struct-equiv.c", "status": "modified", "additions": 1095, "deletions": 113, "changes": 1208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d22e8989c52bd3b6ddbf85761204c7a759cf8c6/gcc%2Fstruct-equiv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d22e8989c52bd3b6ddbf85761204c7a759cf8c6/gcc%2Fstruct-equiv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstruct-equiv.c?ref=7d22e8989c52bd3b6ddbf85761204c7a759cf8c6", "patch": "@@ -19,7 +19,60 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n 02110-1301, USA.  */\n \n-/* This file contains helper functions for Cross jumping (tail merging).  */\n+/* Try to match two basic blocks - or their ends - for structural equivalence.\n+   We scan the blocks from their ends backwards, and expect that insns are\n+   identical, except for certain cases involving registers.  A mismatch\n+   We scan the blocks from their ends backwards, hoping to find a match, I.e.\n+   insns are identical, except for certain cases involving registers.  A\n+   mismatch between register number RX (used in block X) and RY (used in the\n+   same way in block Y) can be handled in one of the following cases:\n+   1. RX and RY are local to their respective blocks; they are set there and\n+      die there.  If so, they can effectively be ignored.\n+   2. RX and RY die in their blocks, but live at the start.  If any path\n+      gets redirected through X instead of Y, the caller must emit\n+      compensation code to move RY to RX.  If there are overlapping inputs,\n+      the function resolve_input_conflict ensures that this can be done.\n+      Information about these registers are tracked in the X_LOCAL, Y_LOCAL,\n+      LOCAL_COUNT and LOCAL_RVALUE fields.\n+   3. RX and RY live throughout their blocks, including the start and the end.\n+      Either RX and RY must be identical, or we have to replace all uses in\n+      block X with a new pseudo, which is stored in the INPUT_REG field.  The\n+      caller can then use block X instead of block Y by copying RY to the new\n+      pseudo.\n+\n+   The main entry point to this file is struct_equiv_block_eq.  This function\n+   uses a struct equiv_info to accept some of its inputs, to keep track of its\n+   internal state, to pass down to its helper functions, and to communicate\n+   some of the results back to the caller.\n+\n+   Most scans will result in a failure to match a sufficient number of insns\n+   to make any optimization worth while, therefore the process is geared more\n+   to quick scanning rather than the ability to exactly backtrack when we\n+   find a mismatch.  The information gathered is still meaningful to make a\n+   preliminary decision if we want to do an optimization, we might only\n+   slightly overestimate the number of matchable insns, and underestimate\n+   the number of inputs an miss an input conflict.  Sufficient information\n+   is gathered so that when we make another pass, we won't have to backtrack\n+   at the same point.\n+   Another issue is that information in memory atttributes and/or REG_NOTES\n+   might have to be merged or discarded to make a valid match.  We don't want\n+   to discard such information when we are not certain that we want to merge\n+   the two (partial) blocks.\n+   For these reasons, struct_equiv_block_eq has to be called first with the\n+   STRUCT_EQUIV_START bit set in the mode parameter.  This will calculate the\n+   number of matched insns and the number and types of inputs.  If the\n+   need_rerun field is set, the results are only tentative, and the caller\n+   has to call again with STRUCT_EQUIV_RERUN till need_rerun is false in\n+   order to get a reliable match.\n+   To install the changes necessary for the match, the function has to be\n+   called again with STRUCT_EQUIV_FINAL.\n+\n+   While scanning an insn, we process first all the SET_DESTs, then the\n+   SET_SRCes, then the REG_NOTES, in order to keep the register liveness\n+   information consistent.\n+   If we were to mix up the order for sources / destinations in an insn where\n+   a source is also a destination, we'd end up being mistaken to think that\n+   the register is not live in the preceding insn.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -34,8 +87,26 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"tm_p.h\"\n #include \"target.h\"\n #include \"emit-rtl.h\"\n+#include \"reload.h\"\n \n static void merge_memattrs (rtx, rtx);\n+static bool set_dest_equiv_p (rtx x, rtx y, struct equiv_info *info);\n+static bool set_dest_addr_equiv_p (rtx x, rtx y, struct equiv_info *info);\n+static void find_dying_inputs (struct equiv_info *info);\n+static bool resolve_input_conflict (struct equiv_info *info);\n+\n+/* After reload, some moves, as indicated by SECONDARY_RELOAD_CLASS and\n+   SECONDARY_MEMORY_NEEDED, cannot be done directly.  For our purposes, we\n+   consider them impossible to generate after reload (even though some\n+   might be synthesized when you throw enough code at them).\n+   Since we don't know while procesing a cross-jump if a local register\n+   that is currently live will eventually be live and thus be an input,\n+   we keep track of potential inputs that would require an impossible move\n+   by using a prohibitively high cost for them.\n+   This number, multiplied with the larger of STRUCT_EQUIV_MAX_LOCAL and\n+   FIRST_PSEUDO_REGISTER, must fit in the input_cost field of\n+   struct equiv_info.  */\n+#define IMPOSSIBLE_MOVE_FACTOR 20000\n \n \f\n \n@@ -129,18 +200,638 @@ merge_memattrs (rtx x, rtx y)\n   return;\n }\n \n+/* In SET, assign the bit for the register number of REG the value VALUE.\n+   If REG is a hard register, do so for all its consituent registers.\n+   Return the number of registers that have become included (as a positive\n+   number) or excluded (as a negative number).  */\n+static int\n+assign_reg_reg_set (regset set, rtx reg, int value)\n+{\n+  unsigned regno = REGNO (reg);\n+  int nregs, i, old;\n+\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    {\n+      gcc_assert (!reload_completed);\n+      nregs = 1;\n+    }\n+  else\n+    nregs = hard_regno_nregs[regno][GET_MODE (reg)];\n+  for (old = 0, i = nregs; --i >= 0; regno++)\n+    {\n+      if ((value != 0) == REGNO_REG_SET_P (set, regno))\n+\tcontinue;\n+      if (value)\n+\told++, SET_REGNO_REG_SET (set, regno);\n+      else\n+\told--, CLEAR_REGNO_REG_SET (set, regno);\n+    }\n+  return old;\n+}\n+\n+/* Record state about current inputs / local registers / liveness\n+   in *P.  */\n+static inline void\n+struct_equiv_make_checkpoint (struct struct_equiv_checkpoint *p,\n+\t\t\t      struct equiv_info *info)\n+{\n+  *p = info->cur;\n+}\n+\n+/* Call struct_equiv_make_checkpoint (P, INFO) if the current partial block\n+   is suitable to split off - i.e. there is no dangling cc0 user - and\n+   if the current cost of the common instructions, minus the cost for\n+   setting up the inputs, is higher than what has been recorded before\n+   in CHECKPOINT[N].  Also, if we do so, confirm or cancel any pending\n+   changes.  */\n+static void\n+struct_equiv_improve_checkpoint (struct struct_equiv_checkpoint *p,\n+\t\t\t\t struct equiv_info *info)\n+{\n+#ifdef HAVE_cc0\n+  if (reg_mentioned_p (cc0_rtx, info->x_start) && !sets_cc0_p (info->x_start))\n+    return;\n+#endif\n+  if (info->cur.input_count >= IMPOSSIBLE_MOVE_FACTOR)\n+    return;\n+  if (info->input_cost >= 0\n+      ? (COSTS_N_INSNS(info->cur.ninsns - p->ninsns)\n+\t > info->input_cost * (info->cur.input_count - p->input_count))\n+      : info->cur.ninsns > p->ninsns && !info->cur.input_count)\n+    {\n+      if (info->check_input_conflict && ! resolve_input_conflict (info))\n+\treturn;\n+      /* We have a profitable set of changes.  If this is the final pass,\n+\t commit them now.  Otherwise, we don't know yet if we can make any\n+\t change, so put the old code back for now.  */\n+      if (info->mode & STRUCT_EQUIV_FINAL)\n+\tconfirm_change_group ();\n+      else\n+\tcancel_changes (0);\n+      struct_equiv_make_checkpoint (p, info);\n+    }\n+}\n+\n+/* Restore state about current inputs / local registers / liveness\n+   from P.  */\n+static void\n+struct_equiv_restore_checkpoint (struct struct_equiv_checkpoint *p,\n+\t\t\t\t struct equiv_info *info)\n+{\n+  info->cur.ninsns = p->ninsns;\n+  info->cur.x_start = p->x_start;\n+  info->cur.y_start = p->y_start;\n+  info->cur.input_count = p->input_count;\n+  info->cur.input_valid = p->input_valid;\n+  while (info->cur.local_count > p->local_count)\n+    {\n+      info->cur.local_count--;\n+      info->cur.version--;\n+      if (REGNO_REG_SET_P (info->x_local_live,\n+\t\t\t   REGNO (info->x_local[info->cur.local_count])))\n+\t{\n+\t  assign_reg_reg_set (info->x_local_live,\n+\t\t\t      info->x_local[info->cur.local_count], 0);\n+\t  assign_reg_reg_set (info->y_local_live,\n+\t\t\t      info->y_local[info->cur.local_count], 0);\n+\t  info->cur.version--;\n+\t}\n+    }\n+  if (info->cur.version != p->version)\n+    info->need_rerun = true;\n+}\n+\n+\n+/* Update register liveness to reflect that X is now life (if rvalue is\n+   nonzero) or dead (if rvalue is zero) in INFO->x_block, and likewise Y\n+   in INFO->y_block.  Return the number of registers the liveness of which\n+   changed in each block (as a negative number if registers became dead).  */\n+static int\n+note_local_live (struct equiv_info *info, rtx x, rtx y, int rvalue)\n+{\n+  int x_change = assign_reg_reg_set (info->x_local_live, x, rvalue);\n+  int y_change = assign_reg_reg_set (info->y_local_live, y, rvalue);\n+\n+  gcc_assert (x_change == y_change);\n+  if (y_change)\n+    {\n+      if (reload_completed)\n+\t{\n+\t  unsigned x_regno ATTRIBUTE_UNUSED = REGNO (x);\n+\t  unsigned y_regno = REGNO (y);\n+\t  enum machine_mode x_mode = GET_MODE (x);\n+\n+\t  if (secondary_reload_class (0, REGNO_REG_CLASS (y_regno), x_mode, x)\n+\t      != NO_REGS\n+#ifdef SECONDARY_MEMORY_NEEDED\n+\t      || SECONDARY_MEMORY_NEEDED (REGNO_REG_CLASS (y_regno),\n+\t\t\t\t\t  REGNO_REG_CLASS (x_regno), x_mode)\n+#endif\n+\t      )\n+\t  y_change *= IMPOSSIBLE_MOVE_FACTOR;\n+\t}\n+      info->cur.input_count += y_change;\n+      info->cur.version++;\n+    }\n+  return x_change;\n+}\n+\n+/* Check if *XP is equivalent to Y.  Until an an unreconcilable difference is\n+   found, use in-group changes with validate_change on *XP to make register\n+   assignments agree.  It is the (not necessarily direct) callers\n+   responsibility to verify / confirm / cancel these changes, as appropriate.\n+   RVALUE indicates if the processed piece of rtl is used as a destination, in\n+   which case we can't have different registers being an input.  Returns\n+   nonzero if the two blocks have been identified as equivalent, zero otherwise.\n+   RVALUE == 0: destination\n+   RVALUE == 1: source\n+   RVALUE == -1: source, ignore SET_DEST of SET / clobber.  */\n+bool\n+rtx_equiv_p (rtx *xp, rtx y, int rvalue, struct equiv_info *info)\n+{\n+  rtx x = *xp;\n+  enum rtx_code code;\n+  int length;\n+  const char *format;\n+  int i;\n+\n+  if (!y || !x)\n+    return x == y;\n+  code = GET_CODE (y);\n+  if (code != REG && x == y)\n+    return true;\n+  if (GET_CODE (x) != code\n+      || GET_MODE (x) != GET_MODE (y))\n+    return false;\n+\n+  /* ??? could extend to allow CONST_INT inputs.  */\n+  switch (code)\n+    {\n+    case SUBREG:\n+      gcc_assert (!reload_completed\n+\t\t  || !info->live_update);\n+      break;\n+    case REG:\n+      {\n+\tunsigned x_regno = REGNO (x);\n+\tunsigned y_regno = REGNO (y);\n+\tint x_common_live, y_common_live;\n+\n+\tif (reload_completed\n+\t    && (x_regno >= FIRST_PSEUDO_REGISTER\n+\t\t|| y_regno >= FIRST_PSEUDO_REGISTER))\n+\t  {\n+\t    /* We should only see this in REG_NOTEs.  */\n+\t    gcc_assert (!info->live_update);\n+\t    /* Returning false will cause us to remove the notes.  */\n+\t    return false;\n+\t  }\n+#ifdef STACK_REGS\n+\t/* After reg-stack, can only accept literal matches of stack regs.  */\n+\tif (info->mode & CLEANUP_POST_REGSTACK\n+\t    && (IN_RANGE (x_regno, FIRST_STACK_REG, LAST_STACK_REG)\n+\t\t|| IN_RANGE (y_regno, FIRST_STACK_REG, LAST_STACK_REG)))\n+\t  return x_regno == y_regno;\n+#endif\n+\n+\t/* If the register is a locally live one in one block, the\n+\t   corresponding one must be locally live in the other, too, and\n+\t   match of identical regnos doesn't apply.  */\n+\tif (REGNO_REG_SET_P (info->x_local_live, x_regno))\n+\t  {\n+\t    if (!REGNO_REG_SET_P (info->y_local_live, y_regno))\n+\t      return false;\n+\t  }\n+\telse if (REGNO_REG_SET_P (info->y_local_live, y_regno))\n+\t  return false;\n+\telse if (x_regno == y_regno)\n+\t  {\n+\t    if (!rvalue && info->cur.input_valid\n+\t\t&& (reg_overlap_mentioned_p (x, info->x_input)\n+\t\t    || reg_overlap_mentioned_p (x, info->y_input)))\n+\t      return false;\n+\n+\t    /* Update liveness information.  */\n+\t    if (info->live_update\n+\t\t&& assign_reg_reg_set (info->common_live, x, rvalue))\n+\t      info->cur.version++;\n+\n+\t    return true;\n+\t  }\n+\n+\tx_common_live = REGNO_REG_SET_P (info->common_live, x_regno);\n+\ty_common_live = REGNO_REG_SET_P (info->common_live, y_regno);\n+\tif (x_common_live != y_common_live)\n+\t  return false;\n+\telse if (x_common_live)\n+\t  {\n+\t    if (! rvalue || info->input_cost < 0 || no_new_pseudos)\n+\t      return false;\n+\t    /* If info->live_update is not set, we are processing notes.\n+\t       We then allow a match with x_input / y_input found in a\n+\t       previous pass.  */\n+\t    if (info->live_update && !info->cur.input_valid)\n+\t      {\n+\t\tinfo->cur.input_valid = true;\n+\t\tinfo->x_input = x;\n+\t\tinfo->y_input = y;\n+\t\tinfo->cur.input_count += optimize_size ? 2 : 1;\n+\t\tif (info->input_reg\n+\t\t    && GET_MODE (info->input_reg) != GET_MODE (info->x_input))\n+\t\t  info->input_reg = NULL_RTX;\n+\t\tif (!info->input_reg)\n+\t\t  info->input_reg = gen_reg_rtx (GET_MODE (info->x_input));\n+\t      }\n+\t    else if ((info->live_update\n+\t\t      ? ! info->cur.input_valid : ! info->x_input)\n+\t\t     || ! rtx_equal_p (x, info->x_input)\n+\t\t     || ! rtx_equal_p (y, info->y_input))\n+\t      return false;\n+\t    validate_change (info->cur.x_start, xp, info->input_reg, 1);\n+\t  }\n+\telse\n+\t  {\n+\t    int x_nregs = (x_regno >= FIRST_PSEUDO_REGISTER\n+\t\t\t   ? 1 : hard_regno_nregs[x_regno][GET_MODE (x)]);\n+\t    int y_nregs = (y_regno >= FIRST_PSEUDO_REGISTER\n+\t\t\t   ? 1 : hard_regno_nregs[y_regno][GET_MODE (y)]);\n+\t    int size = GET_MODE_SIZE (GET_MODE (x));\n+\t    enum machine_mode x_mode = GET_MODE (x);\n+\t    unsigned x_regno_i, y_regno_i;\n+\t    int x_nregs_i, y_nregs_i, size_i;\n+\t    int local_count = info->cur.local_count;\n+\n+\t    /* This might be a register local to each block.  See if we have\n+\t       it already registered.  */\n+\t    for (i = local_count - 1; i >= 0; i--)\n+\t      {\n+\t\tx_regno_i = REGNO (info->x_local[i]);\n+\t\tx_nregs_i = (x_regno_i >= FIRST_PSEUDO_REGISTER\n+\t\t\t     ? 1 : hard_regno_nregs[x_regno_i][GET_MODE (x)]);\n+\t\ty_regno_i = REGNO (info->y_local[i]);\n+\t\ty_nregs_i = (y_regno_i >= FIRST_PSEUDO_REGISTER\n+\t\t\t     ? 1 : hard_regno_nregs[y_regno_i][GET_MODE (y)]);\n+\t\tsize_i = GET_MODE_SIZE (GET_MODE (info->x_local[i]));\n+\n+\t\t/* If we have a new pair of registers that is wider than an\n+\t\t   old pair and enclosing it with matching offsets,\n+\t\t   remove the old pair.  If we find a matching, wider, old\n+\t\t   pair, use the old one.  If the width is the same, use the\n+\t\t   old one if the modes match, but the new if they don't.\n+\t\t   We don't want to get too fancy with subreg_regno_offset\n+\t\t   here, so we just test two straightforwad cases each.  */\n+\t\tif (info->live_update\n+\t\t    && (x_mode != GET_MODE (info->x_local[i])\n+\t\t\t? size >= size_i : size > size_i))\n+\t\t  {\n+\t\t    /* If the new pair is fully enclosing a matching\n+\t\t       existing pair, remove the old one.  N.B. because\n+\t\t       we are removing one entry here, the check below\n+\t\t       if we have space for a new entry will succeed.  */\n+\t\t    if ((x_regno <= x_regno_i\n+\t\t\t && x_regno + x_nregs >= x_regno_i + x_nregs_i\n+\t\t\t && x_nregs == y_nregs && x_nregs_i == y_nregs_i\n+\t\t\t && x_regno - x_regno_i == y_regno - y_regno_i)\n+\t\t\t|| (x_regno == x_regno_i && y_regno == y_regno_i\n+\t\t\t    && x_nregs >= x_nregs_i && y_nregs >= y_nregs_i))\n+\t\t      {\n+\t\t\tinfo->cur.local_count = --local_count;\n+\t\t\tinfo->x_local[i] = info->x_local[local_count];\n+\t\t\tinfo->y_local[i] = info->y_local[local_count];\n+\t\t\tcontinue;\n+\t\t      }\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\n+\t\t    /* If the new pair is fully enclosed within a matching\n+\t\t       existing pair, succeed.  */\n+\t\t    if (x_regno >= x_regno_i\n+\t\t\t&& x_regno + x_nregs <= x_regno_i + x_nregs_i\n+\t\t\t&& x_nregs == y_nregs && x_nregs_i == y_nregs_i\n+\t\t\t&& x_regno - x_regno_i == y_regno - y_regno_i)\n+\t\t      break;\n+\t\t    if (x_regno == x_regno_i && y_regno == y_regno_i\n+\t\t\t&& x_nregs <= x_nregs_i && y_nregs <= y_nregs_i)\n+\t\t      break;\n+\t\t}\n+\n+\t\t/* Any other overlap causes a match failure.  */\n+\t\tif (x_regno + x_nregs > x_regno_i\n+\t\t    && x_regno_i + x_nregs_i > x_regno)\n+\t\t  return false;\n+\t\tif (y_regno + y_nregs > y_regno_i\n+\t\t    && y_regno_i + y_nregs_i > y_regno)\n+\t\t  return false;\n+\t      }\n+\t    if (i < 0)\n+\t      {\n+\t\t/* Not found.  Create a new entry if possible.  */\n+\t\tif (!info->live_update\n+\t\t    || info->cur.local_count >= STRUCT_EQUIV_MAX_LOCAL)\n+\t\t  return false;\n+\t\tinfo->x_local[info->cur.local_count] = x;\n+\t\tinfo->y_local[info->cur.local_count] = y;\n+\t\tinfo->cur.local_count++;\n+\t\tinfo->cur.version++;\n+\t      }\n+\t    note_local_live (info, x, y, rvalue);\n+\t  }\n+\treturn true;\n+      }\n+    case SET:\n+      gcc_assert (rvalue < 0);\n+      /* Ignore the destinations role as a destination.  Still, we have\n+\t to consider input registers embedded in the addresses of a MEM.\n+\t N.B., we process the rvalue aspect of STRICT_LOW_PART /\n+\t ZERO_EXTEND / SIGN_EXTEND along with their lvalue aspect.  */\n+      if(!set_dest_addr_equiv_p (SET_DEST (x), SET_DEST (y), info))\n+\treturn false;\n+      /* Process source.  */\n+      return rtx_equiv_p (&SET_SRC (x), SET_SRC (y), 1, info);\n+    case PRE_MODIFY:\n+      /* Process destination.  */\n+      if (!rtx_equiv_p (&XEXP (x, 0), XEXP (y, 0), 0, info))\n+\treturn false;\n+      /* Process source.  */\n+      return rtx_equiv_p (&XEXP (x, 1), XEXP (y, 1), 1, info);\n+    case POST_MODIFY:\n+      {\n+\trtx x_dest0, x_dest1;\n+\n+\t/* Process destination.  */\n+\tx_dest0 = XEXP (x, 0);\n+\tgcc_assert (REG_P (x_dest0));\n+\tif (!rtx_equiv_p (&XEXP (x, 0), XEXP (y, 0), 0, info))\n+\t  return false;\n+\tx_dest1 = XEXP (x, 0);\n+\t/* validate_change might have changed the destination.  Put it back\n+\t   so that we can do a valid source match.  */\n+\tXEXP (x, 0) = x_dest0;\n+\tif (!rtx_equiv_p (&XEXP (x, 1), XEXP (y, 1), 0, info))\n+\t  return false;\n+\tgcc_assert (x_dest1 == XEXP (x, 0));\n+\t/* Process source.  */\n+\treturn rtx_equiv_p (&XEXP (x, 1), XEXP (y, 1), 1, info);\n+      if (!rtx_equiv_p (&XEXP(x, 0), XEXP (y, 0), 0, info))\n+\treturn false;\n+      /* Process both subexpressions as inputs.  */\n+      break;\n+      }\n+    case CLOBBER:\n+      gcc_assert (rvalue < 0);\n+      return true;\n+    /* Some special forms are also rvalues when they appear in lvalue\n+       positions.  However, we must ont try to match a register after we\n+       have already altered it with validate_change, consider the rvalue\n+       aspect while we process the lvalue.  */\n+    case STRICT_LOW_PART:\n+    case ZERO_EXTEND:\n+    case SIGN_EXTEND:\n+      {\n+\trtx x_inner, y_inner;\n+\tenum rtx_code code;\n+\tint change;\n+\n+\tif (rvalue)\n+\t  break;\n+\tx_inner = XEXP (x, 0);\n+\ty_inner = XEXP (y, 0);\n+\tif (GET_MODE (x_inner) != GET_MODE (y_inner))\n+\t  return false;\n+\tcode = GET_CODE (x_inner);\n+\tif (code != GET_CODE (y_inner))\n+\t  return false;\n+\t/* The address of a MEM is an input that will be processed during\n+\t   rvalue == -1 processing.  */\n+\tif (code == SUBREG)\n+\t  {\n+\t    if (SUBREG_BYTE (x_inner) != SUBREG_BYTE (y_inner))\n+\t      return false;\n+\t    x = x_inner;\n+\t    x_inner = SUBREG_REG (x_inner);\n+\t    y_inner = SUBREG_REG (y_inner);\n+\t    if (GET_MODE (x_inner) != GET_MODE (y_inner))\n+\t      return false;\n+\t    code = GET_CODE (x_inner);\n+\t    if (code != GET_CODE (y_inner))\n+\t      return false;\n+\t  }\n+\tif (code == MEM)\n+\t  return true;\n+\tgcc_assert (code == REG);\n+\tif (! rtx_equiv_p (&XEXP (x, 0), y_inner, rvalue, info))\n+\t  return false;\n+\tif (REGNO (x_inner) == REGNO (y_inner))\n+\t  {\n+\t    change = assign_reg_reg_set (info->common_live, x_inner, 1);\n+\t    info->cur.version++;\n+\t  }\n+\telse\n+\t  change = note_local_live (info, x_inner, y_inner, 1);\n+\tgcc_assert (change);\n+\treturn true;\n+      }\n+    /* The AUTO_INC / POST_MODIFY / PRE_MODIFY sets are modelled to take\n+       place during input processing, however, that is benign, since they\n+       are paired with reads.  */\n+    case MEM:\n+      return !rvalue || rtx_equiv_p (&XEXP (x, 0), XEXP (y, 0), rvalue, info);\n+    case POST_INC: case POST_DEC: case PRE_INC: case PRE_DEC:\n+      return (rtx_equiv_p (&XEXP (x, 0), XEXP (y, 0), 0, info)\n+\t      && rtx_equiv_p (&XEXP (x, 0), XEXP (y, 0), 1, info));\n+    case PARALLEL:\n+      gcc_assert (rvalue < 0);\n+      break;\n+    case LABEL_REF:\n+      /* Check special tablejump match case.  */\n+      if (XEXP (y, 0) == info->y_label)\n+\treturn (XEXP (x, 0) == info->x_label);\n+      /* We can't assume nonlocal labels have their following insns yet.  */\n+      if (LABEL_REF_NONLOCAL_P (x) || LABEL_REF_NONLOCAL_P (y))\n+\treturn XEXP (x, 0) == XEXP (y, 0);\n+\n+      /* Two label-refs are equivalent if they point at labels\n+\t in the same position in the instruction stream.  */\n+      return (next_real_insn (XEXP (x, 0))\n+\t      == next_real_insn (XEXP (y, 0)));\n+    case SYMBOL_REF:\n+      return XSTR (x, 0) == XSTR (y, 0);\n+    /* Some rtl is guaranteed to be shared, or unique;  If we didn't match\n+       EQ equality above, they aren't the same.  */\n+    case CONST_INT:\n+    case CODE_LABEL:\n+      return false;\n+    default:\n+      break;\n+    }\n+\n+  /* For commutative operations, the RTX match if the operands match in any\n+     order.  */\n+  if (targetm.commutative_p (x, UNKNOWN))\n+    return ((rtx_equiv_p (&XEXP (x, 0), XEXP (y, 0), rvalue, info)\n+\t     && rtx_equiv_p (&XEXP (x, 1), XEXP (y, 1), rvalue, info))\n+\t    || (rtx_equiv_p (&XEXP (x, 0), XEXP (y, 1), rvalue, info)\n+\t\t&& rtx_equiv_p (&XEXP (x, 1), XEXP (y, 0), rvalue, info)));\n+\n+  /* Process subexpressions - this is similar to rtx_equal_p.  */\n+  length = GET_RTX_LENGTH (code);\n+  format = GET_RTX_FORMAT (code);\n+\n+  for (i = 0; i < length; ++i)\n+    {\n+      switch (format[i])\n+\t{\n+\tcase 'w':\n+\t  if (XWINT (x, i) != XWINT (y, i))\n+\t    return false;\n+\t  break;\n+\tcase 'n':\n+\tcase 'i':\n+\t  if (XINT (x, i) != XINT (y, i))\n+\t    return false;\n+\t  break;\n+\tcase 'V':\n+\tcase 'E':\n+\t  if (XVECLEN (x, i) != XVECLEN (y, i))\n+\t    return false;\n+\t  if (XVEC (x, i) != 0)\n+\t    {\n+\t      int j;\n+\t      for (j = 0; j < XVECLEN (x, i); ++j)\n+\t\t{\n+\t\t  if (! rtx_equiv_p (&XVECEXP (x, i, j), XVECEXP (y, i, j),\n+\t\t\t\t     rvalue, info))\n+\t\t    return false;\n+\t\t}\n+\t    }\n+\t  break;\n+\tcase 'e':\n+\t  if (! rtx_equiv_p (&XEXP (x, i), XEXP (y, i), rvalue, info))\n+\t    return false;\n+\t  break;\n+\tcase 'S':\n+\tcase 's':\n+\t  if ((XSTR (x, i) || XSTR (y, i))\n+\t      && (! XSTR (x, i) || ! XSTR (y, i)\n+\t\t  || strcmp (XSTR (x, i), XSTR (y, i))))\n+\t    return false;\n+\t  break;\n+\tcase 'u':\n+\t  /* These are just backpointers, so they don't matter.  */\n+\t  break;\n+\tcase '0':\n+\tcase 't':\n+\t  break;\n+\t  /* It is believed that rtx's at this level will never\n+\t     contain anything but integers and other rtx's,\n+\t     except for within LABEL_REFs and SYMBOL_REFs.  */\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+  return true;\n+}\n+\n+/* Do only the rtx_equiv_p SET_DEST processing for SETs and CLOBBERs.\n+   Since we are scanning backwards, this the first step in processing each\n+   insn.  Return true for success.  */\n+static bool\n+set_dest_equiv_p (rtx x, rtx y, struct equiv_info *info)\n+{\n+  if (!x || !y)\n+    return x == y;\n+  if (GET_CODE (x) != GET_CODE (y))\n+    return false;\n+  else if (GET_CODE (x) == SET || GET_CODE (x) == CLOBBER)\n+    return rtx_equiv_p (&XEXP (x, 0), XEXP (y, 0), 0, info);\n+  else if (GET_CODE (x) == PARALLEL)\n+    {\n+      int j;\n+\n+      if (XVECLEN (x, 0) != XVECLEN (y, 0))\n+\treturn false;\n+      for (j = 0; j < XVECLEN (x, 0); ++j)\n+\t{\n+\t  rtx xe = XVECEXP (x, 0, j);\n+\t  rtx ye = XVECEXP (y, 0, j);\n+\n+\t  if (GET_CODE (xe) != GET_CODE (ye))\n+\t    return false;\n+\t  if ((GET_CODE (xe) == SET || GET_CODE (xe) == CLOBBER)\n+\t      && ! rtx_equiv_p (&XEXP (xe, 0), XEXP (ye, 0), 0, info))\n+\t    return false;\n+\t}\n+    }\n+  return true;\n+}\n+\n+/* Process MEMs in SET_DEST destinations.  We must not process this together\n+   with REG SET_DESTs, but must do it separately, lest when we see\n+   [(set (reg:SI foo) (bar))\n+    (set (mem:SI (reg:SI foo) (baz)))]\n+   struct_equiv_block_eq could get confused to assume that (reg:SI foo)\n+   is not live before this instruction.  */\n+static bool\n+set_dest_addr_equiv_p (rtx x, rtx y, struct equiv_info *info)\n+{\n+  enum rtx_code code = GET_CODE (x);\n+  int length;\n+  const char *format;\n+  int i;\n+\n+  if (code != GET_CODE (y))\n+    return false;\n+  if (code == MEM)\n+    return rtx_equiv_p (&XEXP (x, 0), XEXP (y, 0), 1, info);\n+\n+  /* Process subexpressions.  */\n+  length = GET_RTX_LENGTH (code);\n+  format = GET_RTX_FORMAT (code);\n+\n+  for (i = 0; i < length; ++i)\n+    {\n+      switch (format[i])\n+\t{\n+\tcase 'V':\n+\tcase 'E':\n+\t  if (XVECLEN (x, i) != XVECLEN (y, i))\n+\t    return false;\n+\t  if (XVEC (x, i) != 0)\n+\t    {\n+\t      int j;\n+\t      for (j = 0; j < XVECLEN (x, i); ++j)\n+\t\t{\n+\t\t  if (! set_dest_addr_equiv_p (XVECEXP (x, i, j),\n+\t\t\t\t\t       XVECEXP (y, i, j), info))\n+\t\t    return false;\n+\t\t}\n+\t    }\n+\t  break;\n+\tcase 'e':\n+\t  if (! set_dest_addr_equiv_p (XEXP (x, i), XEXP (y, i), info))\n+\t    return false;\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+  return true;\n+}\n+\n /* Check if the set of REG_DEAD notes attached to I1 and I2 allows us to\n-   go ahead with merging I1 and I2, which otherwise look fine.  */\n+   go ahead with merging I1 and I2, which otherwise look fine.\n+   Inputs / local registers for the inputs of I1 and I2 have already been\n+   set up.  */\n static bool\n death_notes_match_p (rtx i1 ATTRIBUTE_UNUSED, rtx i2 ATTRIBUTE_UNUSED,\n-\t\t     int mode ATTRIBUTE_UNUSED)\n+\t\t     struct equiv_info *info ATTRIBUTE_UNUSED)\n {\n #ifdef STACK_REGS\n   /* If cross_jump_death_matters is not 0, the insn's mode\n-     indicates whether or not the insn contains any stack-like\n-     regs.  */\n+     indicates whether or not the insn contains any stack-like regs.  */\n \n-  if ((mode & CLEANUP_POST_REGSTACK) && stack_regs_mentioned (i1))\n+  if ((info->mode & CLEANUP_POST_REGSTACK) && stack_regs_mentioned (i1))\n     {\n       /* If register stack conversion has already been done, then\n \t death notes must also be compared before it is certain that\n@@ -158,7 +849,18 @@ death_notes_match_p (rtx i1 ATTRIBUTE_UNUSED, rtx i2 ATTRIBUTE_UNUSED,\n \n       for (note = REG_NOTES (i2); note; note = XEXP (note, 1))\n \tif (REG_NOTE_KIND (note) == REG_DEAD && STACK_REG_P (XEXP (note, 0)))\n-\t  SET_HARD_REG_BIT (i2_regset, REGNO (XEXP (note, 0)));\n+\t  {\n+\t    unsigned regno = REGNO (XEXP (note, 0));\n+\t    int i;\n+\n+\t    for (i = info->cur.local_count - 1; i >= 0; i--)\n+\t      if (regno == REGNO (info->y_local[i]))\n+\t\t{\n+\t\t  regno = REGNO (info->x_local[i]);\n+\t\t  break;\n+\t\t}\n+\t    SET_HARD_REG_BIT (i2_regset, regno);\n+\t  }\n \n       GO_IF_HARD_REG_EQUAL (i1_regset, i2_regset, done);\n \n@@ -174,19 +876,17 @@ death_notes_match_p (rtx i1 ATTRIBUTE_UNUSED, rtx i2 ATTRIBUTE_UNUSED,\n /* Return true if I1 and I2 are equivalent and thus can be crossjumped.  */\n \n bool\n-insns_match_p (int mode, rtx i1, rtx i2)\n+insns_match_p (rtx i1, rtx i2, struct equiv_info *info)\n {\n-  rtx p1, p2;\n+  int rvalue_change_start;\n+  struct struct_equiv_checkpoint before_rvalue_change;\n \n   /* Verify that I1 and I2 are equivalent.  */\n   if (GET_CODE (i1) != GET_CODE (i2))\n     return false;\n \n-  p1 = PATTERN (i1);\n-  p2 = PATTERN (i2);\n-\n-  if (GET_CODE (p1) != GET_CODE (p2))\n-    return false;\n+  info->cur.x_start = i1;\n+  info->cur.y_start = i2;\n \n   /* If this is a CALL_INSN, compare register usage information.\n      If we don't check this on stack register machines, the two\n@@ -198,17 +898,36 @@ insns_match_p (int mode, rtx i1, rtx i2)\n      ??? We take the simple route for now and assume that if they're\n      equal, they were constructed identically.  */\n \n-  if (CALL_P (i1)\n-      && (!rtx_equal_p (CALL_INSN_FUNCTION_USAGE (i1),\n-\t\t\tCALL_INSN_FUNCTION_USAGE (i2))\n-\t  || SIBLING_CALL_P (i1) != SIBLING_CALL_P (i2)))\n-    return false;\n-\n-  if (!death_notes_match_p (i1, i2, mode))\n-    return false;\n-\n-  if (reload_completed\n-      ? rtx_renumbered_equal_p (p1, p2) : rtx_equal_p (p1, p2))\n+  if (CALL_P (i1))\n+    {\n+      if (SIBLING_CALL_P (i1) != SIBLING_CALL_P (i2)\n+\t  || ! set_dest_equiv_p (PATTERN (i1), PATTERN (i2), info)\n+\t  || ! set_dest_equiv_p (CALL_INSN_FUNCTION_USAGE (i1),\n+\t\t\t\t CALL_INSN_FUNCTION_USAGE (i2), info)\n+\t  || ! rtx_equiv_p (&CALL_INSN_FUNCTION_USAGE (i1),\n+\t\t\t    CALL_INSN_FUNCTION_USAGE (i2), -1, info))\n+\t{\n+\t  cancel_changes (0);\n+\t  return false;\n+\t}\n+    }\n+  else if (INSN_P (i1))\n+    {\n+      if (! set_dest_equiv_p (PATTERN (i1), PATTERN (i2), info))\n+\t{\n+\t  cancel_changes (0);\n+\t  return false;\n+\t}\n+    }\n+  rvalue_change_start = num_validated_changes ();\n+  struct_equiv_make_checkpoint (&before_rvalue_change, info);\n+  /* Check death_notes_match_p *after* the inputs have been processed,\n+     so that local inputs will already have been set up.  */\n+  if (! INSN_P (i1)\n+      || (!bitmap_bit_p (info->equiv_used, info->cur.ninsns)\n+\t  && rtx_equiv_p (&PATTERN (i1), PATTERN (i2), -1, info)\n+\t  && death_notes_match_p (i1, i2, info)\n+\t  && verify_changes (0)))\n     return true;\n \n   /* Do not do EQUIV substitution after reload.  First, we're undoing the\n@@ -218,10 +937,14 @@ insns_match_p (int mode, rtx i1, rtx i2)\n      targets to disallow the troublesome insns after splitting.  */\n   if (!reload_completed)\n     {\n-      /* The following code helps take care of G++ cleanups.  */\n-      rtx equiv1 = find_reg_equal_equiv_note (i1);\n-      rtx equiv2 = find_reg_equal_equiv_note (i2);\n+      rtx equiv1, equiv2;\n \n+      cancel_changes (rvalue_change_start);\n+      struct_equiv_restore_checkpoint (&before_rvalue_change, info);\n+\n+      /* The following code helps take care of G++ cleanups.  */\n+      equiv1 = find_reg_equal_equiv_note (i1);\n+      equiv2 = find_reg_equal_equiv_note (i2);\n       if (equiv1 && equiv2\n \t  /* If the equivalences are not to a constant, they may\n \t     reference pseudos that no longer exist, so we can't\n@@ -232,131 +955,390 @@ insns_match_p (int mode, rtx i1, rtx i2)\n \t{\n \t  rtx s1 = single_set (i1);\n \t  rtx s2 = single_set (i2);\n-\t  if (s1 != 0 && s2 != 0\n-\t      && rtx_renumbered_equal_p (SET_DEST (s1), SET_DEST (s2)))\n+\n+\t  if (s1 != 0 && s2 != 0)\n \t    {\n \t      validate_change (i1, &SET_SRC (s1), XEXP (equiv1, 0), 1);\n \t      validate_change (i2, &SET_SRC (s2), XEXP (equiv2, 0), 1);\n-\t      if (! rtx_renumbered_equal_p (p1, p2))\n-\t\tcancel_changes (0);\n-\t      else if (apply_change_group ())\n-\t\treturn true;\n+\t      /* Only inspecting the new SET_SRC is not good enough,\n+\t\t because there may also be bare USEs in a single_set\n+\t\t PARALLEL.  */\n+\t      if (rtx_equiv_p (&PATTERN (i1), PATTERN (i2), -1, info)\n+\t\t  && death_notes_match_p (i1, i2, info)\n+\t\t  && verify_changes (0))\n+\t\t{\n+\t\t  /* Mark this insn so that we'll use the equivalence in\n+\t\t     all subsequent passes.  */\n+\t\t  bitmap_set_bit (info->equiv_used, info->cur.ninsns);\n+\t\t  return true;\n+\t\t}\n \t    }\n \t}\n     }\n \n+  cancel_changes (0);\n   return false;\n }\n-\f\n-/* Look through the insns at the end of BB1 and BB2 and find the longest\n-   sequence that are equivalent.  Store the first insns for that sequence\n-   in *F1 and *F2 and return the sequence length.\n \n-   To simplify callers of this function, if the blocks match exactly,\n-   store the head of the blocks in *F1 and *F2.  */\n+/* Set up mode and register information in INFO.  Return true for success.  */\n+bool\n+struct_equiv_init (int mode, struct equiv_info *info)\n+{\n+  if ((info->x_block->flags | info->y_block->flags) & BB_DIRTY)\n+    update_life_info_in_dirty_blocks (UPDATE_LIFE_GLOBAL_RM_NOTES,\n+\t\t\t\t      (PROP_DEATH_NOTES\n+\t\t\t\t       | ((mode & CLEANUP_POST_REGSTACK)\n+\t\t\t\t\t  ? PROP_POST_REGSTACK : 0)));\n+  if (!REG_SET_EQUAL_P (info->x_block->il.rtl->global_live_at_end,\n+\t\t\tinfo->y_block->il.rtl->global_live_at_end))\n+    {\n+#ifdef STACK_REGS\n+      unsigned rn;\n+\n+      if (!(mode & CLEANUP_POST_REGSTACK))\n+\treturn false;\n+      /* After reg-stack.  Remove bogus live info about stack regs.  N.B.\n+\t these regs are not necessarily all dead - we swap random bogosity\n+\t against constant bogosity.  However, clearing these bits at\n+\t least makes the regsets comparable.  */\n+      for (rn = FIRST_STACK_REG; rn < LAST_STACK_REG; rn++)\n+\t{\n+\t  CLEAR_REGNO_REG_SET (info->x_block->il.rtl->global_live_at_end, rn);\n+\t  CLEAR_REGNO_REG_SET (info->y_block->il.rtl->global_live_at_end, rn);\n+\t}\n+      if (!REG_SET_EQUAL_P (info->x_block->il.rtl->global_live_at_end,\n+\t\t\t    info->y_block->il.rtl->global_live_at_end))\n+#endif\n+\treturn false;\n+    }\n+  info->mode = mode;\n+  if (mode & STRUCT_EQUIV_START)\n+    {\n+      info->x_input = info->y_input = info->input_reg = NULL_RTX;\n+      info->equiv_used = ALLOC_REG_SET (&reg_obstack);\n+      info->check_input_conflict = false;\n+    }\n+  info->had_input_conflict = false;\n+  info->cur.ninsns = info->cur.version = 0;\n+  info->cur.local_count = info->cur.input_count = 0;\n+  info->cur.x_start = info->cur.y_start = NULL_RTX;\n+  info->x_label = info->y_label = NULL_RTX;\n+  info->need_rerun = false;\n+  info->live_update = true;\n+  info->cur.input_valid = false;\n+  info->common_live = ALLOC_REG_SET (&reg_obstack);\n+  info->x_local_live = ALLOC_REG_SET (&reg_obstack);\n+  info->y_local_live = ALLOC_REG_SET (&reg_obstack);\n+  COPY_REG_SET (info->common_live, info->x_block->il.rtl->global_live_at_end);\n+  struct_equiv_make_checkpoint (&info->best_match, info);\n+  return true;\n+}\n+\n+/* Insns XI and YI have been matched.  Merge memory attributes and reg\n+   notes.  */\n+static void\n+struct_equiv_merge (rtx xi, rtx yi, struct equiv_info *info)\n+{\n+  rtx equiv1, equiv2;\n+\n+  merge_memattrs (xi, yi);\n+\n+  /* If the merged insns have different REG_EQUAL notes, then\n+     remove them.  */\n+  info->live_update = false;\n+  equiv1 = find_reg_equal_equiv_note (xi);\n+  equiv2 = find_reg_equal_equiv_note (yi);\n+  if (equiv1 && !equiv2)\n+    remove_note (xi, equiv1);\n+  else if (!equiv1 && equiv2)\n+    remove_note (yi, equiv2);\n+  else if (equiv1 && equiv2\n+  \t && !rtx_equiv_p (&XEXP (equiv1, 0), XEXP (equiv2, 0),\n+  \t\t\t   1, info))\n+    {\n+      remove_note (xi, equiv1);\n+      remove_note (yi, equiv2);\n+    }\n+  info->live_update = true;\n+}\n \n+/* Return number of matched insns.\n+   This function must be called up to three times for a successful cross-jump\n+   match:\n+   first to find out which instructions do match.  While trying to match\n+   another instruction that doesn't match, we destroy information in info\n+   about the actual inputs.  So if there have been any before the last\n+   match attempt, we need to call this function again to recompute the\n+   actual inputs up to the actual start of the matching sequence.\n+   When we are then satisfied that the cross-jump is worthwhile, we\n+   call this function a third time to make any changes needed to make the\n+   sequences match: apply equivalences, remove non-matching\n+   notes and merge memory attributes.  */\n int\n-flow_find_cross_jump (int mode ATTRIBUTE_UNUSED, basic_block bb1,\n-\t\t      basic_block bb2, rtx *f1, rtx *f2)\n+struct_equiv_block_eq (int mode, struct equiv_info *info)\n {\n-  rtx i1, i2, last1, last2, afterlast1, afterlast2;\n-  int ninsns = 0;\n+  rtx x_stop, y_stop;\n+  rtx xi, yi;\n+  int i;\n+\n+  if (mode & STRUCT_EQUIV_START)\n+    {\n+      x_stop = BB_HEAD (info->x_block);\n+      y_stop = BB_HEAD (info->y_block);\n+      if (!x_stop || !y_stop)\n+\treturn 0;\n+    }\n+  else\n+    {\n+      x_stop = info->cur.x_start;\n+      y_stop = info->cur.y_start;\n+    }\n+  if (!struct_equiv_init (mode, info))\n+    gcc_unreachable ();\n \n   /* Skip simple jumps at the end of the blocks.  Complex jumps still\n      need to be compared for equivalence, which we'll do below.  */\n \n-  i1 = BB_END (bb1);\n-  last1 = afterlast1 = last2 = afterlast2 = NULL_RTX;\n-  if (onlyjump_p (i1)\n-      || (returnjump_p (i1) && !side_effects_p (PATTERN (i1))))\n+  xi = BB_END (info->x_block);\n+  if (onlyjump_p (xi)\n+      || (returnjump_p (xi) && !side_effects_p (PATTERN (xi))))\n     {\n-      last1 = i1;\n-      i1 = PREV_INSN (i1);\n+      info->cur.x_start = xi;\n+      xi = PREV_INSN (xi);\n     }\n \n-  i2 = BB_END (bb2);\n-  if (onlyjump_p (i2)\n-      || (returnjump_p (i2) && !side_effects_p (PATTERN (i2))))\n+  yi = BB_END (info->y_block);\n+  if (onlyjump_p (yi)\n+      || (returnjump_p (yi) && !side_effects_p (PATTERN (yi))))\n     {\n-      last2 = i2;\n+      info->cur.y_start = yi;\n       /* Count everything except for unconditional jump as insn.  */\n-      if (!simplejump_p (i2) && !returnjump_p (i2) && last1)\n-\tninsns++;\n-      i2 = PREV_INSN (i2);\n+      /* ??? Is it right to count unconditional jumps with a clobber?\n+\t Should we count conditional returns?  */\n+      if (!simplejump_p (yi) && !returnjump_p (yi) && info->cur.x_start)\n+\tinfo->cur.ninsns++;\n+      yi = PREV_INSN (yi);\n     }\n \n-  while (true)\n+  if (mode & STRUCT_EQUIV_MATCH_JUMPS)\n     {\n-      /* Ignore notes.  */\n-      while (!INSN_P (i1) && i1 != BB_HEAD (bb1))\n-\ti1 = PREV_INSN (i1);\n+      /* The caller is expected to have comapred the jumps already, but we\n+\t need to match them again to get any local registers and inputs.  */\n+      gcc_assert (!info->cur.x_start == !info->cur.y_start);\n+      if (info->cur.x_start)\n+\t{\n+\t  if (any_condjump_p (info->cur.x_start)\n+\t      ? !condjump_equiv_p (info, false)\n+\t      : !insns_match_p (info->cur.x_start, info->cur.y_start, info))\n+\t    gcc_unreachable ();\n+\t}\n+      else if (any_condjump_p (xi) && any_condjump_p (yi))\n+\t{\n+\t  info->cur.x_start = xi;\n+\t  info->cur.y_start = yi;\n+\t  xi = PREV_INSN (xi);\n+\t  yi = PREV_INSN (yi);\n+\t  info->cur.ninsns++;\n+\t  if (!condjump_equiv_p (info, false))\n+\t    gcc_unreachable ();\n+\t}\n+      if (info->cur.x_start && info->mode & STRUCT_EQUIV_FINAL)\n+\tstruct_equiv_merge (info->cur.x_start, info->cur.y_start, info);\n+    }\n \n-      while (!INSN_P (i2) && i2 != BB_HEAD (bb2))\n-\ti2 = PREV_INSN (i2);\n+  struct_equiv_improve_checkpoint (&info->best_match, info);\n+  info->x_end = xi;\n+  info->y_end = yi;\n+  if (info->cur.x_start != x_stop)\n+    for (;;)\n+      {\n+\t/* Ignore notes.  */\n+\twhile (!INSN_P (xi) && xi != x_stop)\n+\t  xi = PREV_INSN (xi);\n \n-      if (i1 == BB_HEAD (bb1) || i2 == BB_HEAD (bb2))\n-\tbreak;\n+\twhile (!INSN_P (yi) && yi != y_stop)\n+\t  yi = PREV_INSN (yi);\n+\n+\tif (!insns_match_p (xi, yi, info))\n+\t  break;\n+\tif (INSN_P (xi))\n+\t  {\n+\t    if (info->mode & STRUCT_EQUIV_FINAL)\n+\t      struct_equiv_merge (xi, yi, info);\n+\t    info->cur.ninsns++;\n+\t    struct_equiv_improve_checkpoint (&info->best_match, info);\n+\t  }\n+\tif (xi == x_stop || yi == y_stop)\n+\t  {\n+\t    /* If we reached the start of at least one of the blocks, but\n+\t       best_match hasn't been advanced back to the first valid insn\n+\t       yet, represent the increased benefit of completing the block\n+\t       as an increased instruction count.  */\n+\t    if (info->best_match.x_start != info->cur.x_start\n+\t\t&& (xi == BB_HEAD (info->x_block)\n+\t\t    || yi == BB_HEAD (info->y_block)))\n+\t      {\n+\t\tinfo->cur.ninsns++;\n+\t\tstruct_equiv_improve_checkpoint (&info->best_match, info);\n+\t\tinfo->cur.ninsns--;\n+\t\tif (info->best_match.ninsns > info->cur.ninsns)\n+\t\t  info->best_match.ninsns = info->cur.ninsns;\n+\t      }\n+\t    break;\n+\t  }\n+\txi = PREV_INSN (xi);\n+\tyi = PREV_INSN (yi);\n+      }\n+\n+  /* If we failed to match an insn, but had some changes registered from\n+     trying to make the insns match, we need to cancel these changes now.  */\n+  cancel_changes (0);\n+  /* Restore to best_match to get the sequence with the best known-so-far\n+     cost-benefit difference.  */\n+  struct_equiv_restore_checkpoint (&info->best_match, info);\n+\n+  /* Include preceding notes and labels in the cross-jump / if-conversion.\n+     One, this may bring us to the head of the blocks.\n+     Two, it keeps line number notes as matched as may be.  */\n+  if (info->cur.ninsns)\n+    {\n+      xi = info->cur.x_start;\n+      yi = info->cur.y_start;\n+      while (xi != x_stop && !INSN_P (PREV_INSN (xi)))\n+\txi = PREV_INSN (xi);\n \n-      if (!insns_match_p (mode, i1, i2))\n-\tbreak;\n+      while (yi != y_stop && !INSN_P (PREV_INSN (yi)))\n+\tyi = PREV_INSN (yi);\n \n-      merge_memattrs (i1, i2);\n+      info->cur.x_start = xi;\n+      info->cur.y_start = yi;\n+    }\n \n-      /* Don't begin a cross-jump with a NOTE insn.  */\n-      if (INSN_P (i1))\n+  if (!info->cur.input_valid)\n+    info->x_input = info->y_input = info->input_reg = NULL_RTX;\n+  if (!info->need_rerun)\n+    {\n+      find_dying_inputs (info);\n+      if (info->mode & STRUCT_EQUIV_FINAL)\n+\t{\n+\t  if (info->check_input_conflict && ! resolve_input_conflict (info))\n+\t    gcc_unreachable ();\n+\t}\n+      else\n \t{\n-\t  /* If the merged insns have different REG_EQUAL notes, then\n-\t     remove them.  */\n-\t  rtx equiv1 = find_reg_equal_equiv_note (i1);\n-\t  rtx equiv2 = find_reg_equal_equiv_note (i2);\n-\n-\t  if (equiv1 && !equiv2)\n-\t    remove_note (i1, equiv1);\n-\t  else if (!equiv1 && equiv2)\n-\t    remove_note (i2, equiv2);\n-\t  else if (equiv1 && equiv2\n-\t\t   && !rtx_equal_p (XEXP (equiv1, 0), XEXP (equiv2, 0)))\n+\t  bool input_conflict = info->had_input_conflict;\n+\n+\t  if (!input_conflict\n+\t      && info->dying_inputs > 1\n+\t      && bitmap_intersect_p (info->x_local_live, info->y_local_live))\n \t    {\n-\t      remove_note (i1, equiv1);\n-\t      remove_note (i2, equiv2);\n+\t      regset_head clobbered_regs;\n+\n+\t      INIT_REG_SET (&clobbered_regs);\n+\t      for (i = 0; i < info->cur.local_count; i++)\n+\t\t{\n+\t\t  if (assign_reg_reg_set (&clobbered_regs, info->y_local[i], 0))\n+\t\t    {\n+\t\t      input_conflict = true;\n+\t\t      break;\n+\t\t    }\n+\t\t  assign_reg_reg_set (&clobbered_regs, info->x_local[i], 1);\n+\t\t}\n+\t      CLEAR_REG_SET (&clobbered_regs);\n \t    }\n-\n-\t  afterlast1 = last1, afterlast2 = last2;\n-\t  last1 = i1, last2 = i2;\n-\t  ninsns++;\n+\t  if (input_conflict && !info->check_input_conflict)\n+\t    info->need_rerun = true;\n+\t  info->check_input_conflict = input_conflict;\n \t}\n-\n-      i1 = PREV_INSN (i1);\n-      i2 = PREV_INSN (i2);\n     }\n \n-#ifdef HAVE_cc0\n-  /* Don't allow the insn after a compare to be shared by\n-     cross-jumping unless the compare is also shared.  */\n-  if (ninsns && reg_mentioned_p (cc0_rtx, last1) && ! sets_cc0_p (last1))\n-    last1 = afterlast1, last2 = afterlast2, ninsns--;\n-#endif\n+  if (info->mode & STRUCT_EQUIV_NEED_FULL_BLOCK\n+      && (info->cur.x_start != x_stop || info->cur.y_start != y_stop))\n+    return 0;\n+  return info->cur.ninsns;\n+}\n \n-  /* Include preceding notes and labels in the cross-jump.  One,\n-     this may bring us to the head of the blocks as requested above.\n-     Two, it keeps line number notes as matched as may be.  */\n-  if (ninsns)\n-    {\n-      while (last1 != BB_HEAD (bb1) && !INSN_P (PREV_INSN (last1)))\n-\tlast1 = PREV_INSN (last1);\n+/* For each local register, set info->local_rvalue to true iff the register\n+   is a dying input.  Store the total number of these in info->dying_inputs.  */\n+static void\n+find_dying_inputs (struct equiv_info *info)\n+{\n+  int i;\n \n-      if (last1 != BB_HEAD (bb1) && LABEL_P (PREV_INSN (last1)))\n-\tlast1 = PREV_INSN (last1);\n+  info->dying_inputs = 0;\n+  for (i = info->cur.local_count-1; i >=0; i--)\n+    {\n+      rtx x = info->x_local[i];\n+      unsigned regno = REGNO (x);\n+      int nregs = (regno >= FIRST_PSEUDO_REGISTER\n+\t\t   ? 1 : hard_regno_nregs[regno][GET_MODE (x)]);\n+\n+      for (info->local_rvalue[i] = false; nregs >= 0; regno++, --nregs)\n+\tif (REGNO_REG_SET_P (info->x_local_live, regno))\n+\t  {\n+\t    info->dying_inputs++;\n+\t    info->local_rvalue[i] = true;\n+\t    break;\n+\t  }\n+    }\n+}\n \n-      while (last2 != BB_HEAD (bb2) && !INSN_P (PREV_INSN (last2)))\n-\tlast2 = PREV_INSN (last2);\n+/* For each local register that is a dying input, y_local[i] will be\n+   copied to x_local[i].  We'll do this in ascending order.  Try to\n+   re-order the locals to avoid conflicts like r3 = r2; r4 = r3; .\n+   Return true iff the re-ordering is successful, or not necessary.  */\n+static bool\n+resolve_input_conflict (struct equiv_info *info)\n+{\n+  int i, j, end;\n+  int nswaps = 0;\n+  rtx save_x_local[STRUCT_EQUIV_MAX_LOCAL];\n+  rtx save_y_local[STRUCT_EQUIV_MAX_LOCAL];\n \n-      if (last2 != BB_HEAD (bb2) && LABEL_P (PREV_INSN (last2)))\n-\tlast2 = PREV_INSN (last2);\n+  find_dying_inputs (info);\n+  if (info->dying_inputs <= 1)\n+    return true;\n+  memcpy (save_x_local, info->x_local, sizeof save_x_local);\n+  memcpy (save_y_local, info->y_local, sizeof save_y_local);\n+  end = info->cur.local_count - 1;\n+  for (i = 0; i <= end; i++)\n+    {\n+      /* Cycle detection with regsets is expensive, so we just check that\n+\t we don't exceed the maximum number of swaps needed in the acyclic\n+\t case.  */\n+      int max_swaps = end - i;\n+\n+      /* Check if x_local[i] will be clobbered.  */\n+      if (!info->local_rvalue[i])\n+\tcontinue;\n+      /* Check if any later value needs to be copied earlier.  */\n+      for (j = i + 1; j <= end; j++)\n+\t{\n+\t  rtx tmp;\n \n-      *f1 = last1;\n-      *f2 = last2;\n+\t  if (!info->local_rvalue[j])\n+\t    continue;\n+\t  if (!reg_overlap_mentioned_p (info->x_local[i], info->y_local[j]))\n+\t    continue;\n+\t  if (--max_swaps < 0)\n+\t    {\n+\t      memcpy (info->x_local, save_x_local, sizeof save_x_local);\n+\t      memcpy (info->y_local, save_y_local, sizeof save_y_local);\n+\t      return false;\n+\t    }\n+\t  nswaps++;\n+\t  tmp = info->x_local[i];\n+\t  info->x_local[i] = info->x_local[j];\n+\t  info->x_local[j] = tmp;\n+\t  tmp = info->y_local[i];\n+\t  info->y_local[i] = info->y_local[j];\n+\t  info->y_local[j] = tmp;\n+\t  j = i;\n+\t}\n     }\n-\n-  return ninsns;\n+  info->had_input_conflict = true;\n+  if (dump_file && nswaps)\n+    fprintf (dump_file, \"Resolved input conflict, %d %s.\\n\",\n+\t     nswaps, nswaps == 1 ? \"swap\" : \"swaps\");\n+  return true;\n }"}]}