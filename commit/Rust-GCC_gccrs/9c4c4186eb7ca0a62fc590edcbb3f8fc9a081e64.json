{"sha": "9c4c4186eb7ca0a62fc590edcbb3f8fc9a081e64", "node_id": "C_kwDOANBUbNoAKDljNGM0MTg2ZWI3Y2EwYTYyZmM1OTBlZGNiYjNmOGZjOWEwODFlNjQ", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-09-14T04:58:35Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-09-14T15:06:48Z"}, "message": "Provide cleaner set_nan(), clear_nan(), and update_nan() methods.\n\nset_* has a very specific meaning for irange's and friends.  Methods\nprefixed with set_* are setters clobbering the existing range.  As\nsuch, the current set_nan() method is confusing in that it's not\nactually setting a range to a NAN, but twiddling the NAN flags for an\nexisting frange.\n\nThis patch replaces set_nan() with an update_nan() to set the flag,\nand clear_nan() to clear it.  This makes the code clearer, and though\nthe confusing tristate is still there, it will be removed in upcoming\npatches.\n\nAlso, there is now an actual set_nan() method to set the range to a\nNAN.  This replaces two out of class functions doing the same thing.\nIn future patches I will also add the ability to create a NAN with a\nspecific sign, but doing so now would be confusing because we're not\ntracking NAN signs.\n\nWe should also submit set_signbit to the same fate, but it's about to\nget removed.\n\nNo functional changes.\n\nRegstrapped on x86-64 Linux, plus I ran selftests for\n-ffinite-math-only.\n\ngcc/ChangeLog:\n\n\t* range-op-float.cc (frange_set_nan): Remove.\n\t(build_lt): Use set_nan, update_nan, clear_nan.\n\t(build_gt): Same.\n\t(foperator_equal::op1_range): Same.\n\t(foperator_not_equal::op1_range): Same.\n\t(foperator_lt::op1_range): Same.\n\t(foperator_lt::op2_range): Same.\n\t(foperator_le::op1_range): Same.\n\t(foperator_le::op2_range): Same.\n\t(foperator_gt::op1_range): Same.\n\t(foperator_gt::op2_range): Same.\n\t(foperator_ge::op1_range): Same.\n\t(foperator_ge::op2_range): Same.\n\t(foperator_unordered::op1_range): Same.\n\t(foperator_ordered::op1_range): Same.\n\t* value-query.cc (range_query::get_tree_range): Same.\n\t* value-range.cc (frange::set_nan): Same.\n\t(frange::update_nan): Same.\n\t(frange::union_): Same.\n\t(frange::intersect): Same.\n\t(range_tests_nan): Same.\n\t(range_tests_signed_zeros): Same.\n\t(range_tests_signbit): Same.\n\t(range_tests_floats): Same.\n\t* value-range.h (class frange): Add update_nan and clear_nan.\n\t(frange::set_nan): New.", "tree": {"sha": "2e83a9a76cc97b9f29f58787da442680e094a660", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e83a9a76cc97b9f29f58787da442680e094a660"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9c4c4186eb7ca0a62fc590edcbb3f8fc9a081e64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c4c4186eb7ca0a62fc590edcbb3f8fc9a081e64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c4c4186eb7ca0a62fc590edcbb3f8fc9a081e64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c4c4186eb7ca0a62fc590edcbb3f8fc9a081e64/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6da65479fcd86c21d0f6b731dda763b574e8066c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6da65479fcd86c21d0f6b731dda763b574e8066c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6da65479fcd86c21d0f6b731dda763b574e8066c"}], "stats": {"total": 113, "additions": 51, "deletions": 62}, "files": [{"sha": "f979ca597cb79629b0afa54f15ac5514765d5d3a", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 17, "deletions": 29, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c4c4186eb7ca0a62fc590edcbb3f8fc9a081e64/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c4c4186eb7ca0a62fc590edcbb3f8fc9a081e64/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=9c4c4186eb7ca0a62fc590edcbb3f8fc9a081e64", "patch": "@@ -150,18 +150,6 @@ range_operator_float::op1_op2_relation (const irange &lhs ATTRIBUTE_UNUSED) cons\n   return VREL_VARYING;\n }\n \n-// Set R to [NAN, NAN].\n-\n-static inline void\n-frange_set_nan (frange &r, tree type)\n-{\n-  REAL_VALUE_TYPE rv;\n-  bool res = real_nan (&rv, \"\", 1, TYPE_MODE (type));\n-  if (flag_checking)\n-    gcc_assert (res);\n-  r.set (type, rv, rv);\n-}\n-\n // Return TRUE if OP1 is known to be free of NANs.\n \n static inline bool\n@@ -248,7 +236,7 @@ build_lt (frange &r, tree type, const REAL_VALUE_TYPE &val)\n   if (real_isinf (&val, 1))\n     {\n       if (HONOR_NANS (type))\n-\tfrange_set_nan (r, type);\n+\tr.set_nan (type);\n       else\n \tr.set_undefined ();\n       return false;\n@@ -286,7 +274,7 @@ build_gt (frange &r, tree type, const REAL_VALUE_TYPE &val)\n   if (real_isinf (&val, 0))\n     {\n       if (HONOR_NANS (type))\n-\tfrange_set_nan (r, type);\n+\tr.set_nan (type);\n       else\n \tr.set_undefined ();\n       return false;\n@@ -392,14 +380,14 @@ foperator_equal::op1_range (frange &r, tree type,\n       if (HONOR_SIGNED_ZEROS (type) && r.contains_p (build_zero_cst (type)))\n \tr.set_signbit (fp_prop::VARYING);\n       // The TRUE side of op1 == op2 implies op1 is !NAN.\n-      r.set_nan (fp_prop::NO);\n+      r.clear_nan ();\n       break;\n \n     case BRS_FALSE:\n       r.set_varying (type);\n       // The FALSE side of op1 == op1 implies op1 is a NAN.\n       if (rel == VREL_EQ)\n-\tfrange_set_nan (r, type);\n+\tr.set_nan (type);\n       // If the result is false, the only time we know anything is\n       // if OP2 is a constant.\n       else if (op2.singleton_p ()\n@@ -496,7 +484,7 @@ foperator_not_equal::op1_range (frange &r, tree type,\n       if (HONOR_SIGNED_ZEROS (type) && r.contains_p (build_zero_cst (type)))\n \tr.set_signbit (fp_prop::VARYING);\n       // The FALSE side of op1 != op2 implies op1 is !NAN.\n-      r.set_nan (fp_prop::NO);\n+      r.clear_nan ();\n       break;\n \n     default:\n@@ -563,7 +551,7 @@ foperator_lt::op1_range (frange &r,\n     case BRS_TRUE:\n       if (build_lt (r, type, op2.upper_bound ()))\n \t{\n-\t  r.set_nan (fp_prop::NO);\n+\t  r.clear_nan ();\n \t  // x < y implies x is not +INF.\n \t  frange_drop_inf (r, type);\n \t}\n@@ -591,7 +579,7 @@ foperator_lt::op2_range (frange &r,\n     case BRS_TRUE:\n       if (build_gt (r, type, op1.lower_bound ()))\n \t{\n-\t  r.set_nan (fp_prop::NO);\n+\t  r.clear_nan ();\n \t  // x < y implies y is not -INF.\n \t  frange_drop_ninf (r, type);\n \t}\n@@ -664,7 +652,7 @@ foperator_le::op1_range (frange &r,\n     {\n     case BRS_TRUE:\n       if (build_le (r, type, op2.upper_bound ()))\n-\tr.set_nan (fp_prop::NO);\n+\tr.clear_nan ();\n       break;\n \n     case BRS_FALSE:\n@@ -688,7 +676,7 @@ foperator_le::op2_range (frange &r,\n     {\n     case BRS_TRUE:\n       if (build_ge (r, type, op1.lower_bound ()))\n-\tr.set_nan (fp_prop::NO);\n+\tr.clear_nan ();\n       break;\n \n     case BRS_FALSE:\n@@ -759,7 +747,7 @@ foperator_gt::op1_range (frange &r,\n     case BRS_TRUE:\n       if (build_gt (r, type, op2.lower_bound ()))\n \t{\n-\t  r.set_nan (fp_prop::NO);\n+\t  r.clear_nan ();\n \t  // x > y implies x is not -INF.\n \t  frange_drop_ninf (r, type);\n \t}\n@@ -787,7 +775,7 @@ foperator_gt::op2_range (frange &r,\n     case BRS_TRUE:\n       if (build_lt (r, type, op1.upper_bound ()))\n \t{\n-\t  r.set_nan (fp_prop::NO);\n+\t  r.clear_nan ();\n \t  // x > y implies y is not +INF.\n \t  frange_drop_inf (r, type);\n \t}\n@@ -860,7 +848,7 @@ foperator_ge::op1_range (frange &r,\n     {\n     case BRS_TRUE:\n       build_ge (r, type, op2.lower_bound ());\n-      r.set_nan (fp_prop::NO);\n+      r.clear_nan ();\n       break;\n \n     case BRS_FALSE:\n@@ -887,7 +875,7 @@ foperator_ge::op2_range (frange &r, tree type,\n \n     case BRS_TRUE:\n       build_le (r, type, op1.upper_bound ());\n-      r.set_nan (fp_prop::NO);\n+      r.clear_nan ();\n       break;\n \n     default:\n@@ -948,13 +936,13 @@ foperator_unordered::op1_range (frange &r, tree type,\n       // Since at least one operand must be NAN, if one of them is\n       // not, the other must be.\n       if (!op2.maybe_nan ())\n-\tfrange_set_nan (r, type);\n+\tr.set_nan (type);\n       break;\n \n     case BRS_FALSE:\n       r.set_varying (type);\n       // A false UNORDERED means both operands are !NAN.\n-      r.set_nan (fp_prop::NO);\n+      r.clear_nan ();\n       break;\n \n     default:\n@@ -1011,14 +999,14 @@ foperator_ordered::op1_range (frange &r, tree type,\n     case BRS_TRUE:\n       r.set_varying (type);\n       // The TRUE side of op1 ORDERED op2 implies op1 is !NAN.\n-      r.set_nan (fp_prop::NO);\n+      r.clear_nan ();\n       break;\n \n     case BRS_FALSE:\n       r.set_varying (type);\n       // The FALSE side of op1 ORDERED op1 implies op1 is !NAN.\n       if (rel == VREL_EQ)\n-\tr.set_nan (fp_prop::NO);\n+\tr.clear_nan ();\n       break;\n \n     default:"}, {"sha": "ea6e4b979ad52c3b2481a82f221ac394dacff748", "filename": "gcc/value-query.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c4c4186eb7ca0a62fc590edcbb3f8fc9a081e64/gcc%2Fvalue-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c4c4186eb7ca0a62fc590edcbb3f8fc9a081e64/gcc%2Fvalue-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-query.cc?ref=9c4c4186eb7ca0a62fc590edcbb3f8fc9a081e64", "patch": "@@ -223,9 +223,9 @@ range_query::get_tree_range (vrange &r, tree expr, gimple *stmt)\n \t// Singletons from the tree world have known properties.\n \tREAL_VALUE_TYPE *rv = TREE_REAL_CST_PTR (expr);\n \tif (real_isnan (rv))\n-\t  f.set_nan (fp_prop::YES);\n+\t  f.update_nan (fp_prop::YES);\n \telse\n-\t  f.set_nan (fp_prop::NO);\n+\t  f.clear_nan ();\n \tif (real_isneg (rv))\n \t  f.set_signbit (fp_prop::YES);\n \telse"}, {"sha": "dd827421aca6ee5474689a19713b81b87d523fe0", "filename": "gcc/value-range.cc", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c4c4186eb7ca0a62fc590edcbb3f8fc9a081e64/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c4c4186eb7ca0a62fc590edcbb3f8fc9a081e64/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=9c4c4186eb7ca0a62fc590edcbb3f8fc9a081e64", "patch": "@@ -270,7 +270,7 @@ tree_compare (tree_code code, tree op1, tree op2)\n // Set the NAN property.  Adjust the range if appopriate.\n \n void\n-frange::set_nan (fp_prop::kind k)\n+frange::update_nan (fp_prop::kind k)\n {\n   if (k == fp_prop::YES)\n     {\n@@ -280,7 +280,7 @@ frange::set_nan (fp_prop::kind k)\n \t  return;\n \t}\n       gcc_checking_assert (!undefined_p ());\n-      *this = frange_nan (m_type);\n+      set_nan (m_type);\n       return;\n     }\n \n@@ -474,15 +474,15 @@ frange::union_ (const vrange &v)\n       *this = r;\n       m_props = save;\n       m_props.union_ (r.m_props);\n-      set_nan (fp_prop::VARYING);\n+      update_nan (fp_prop::VARYING);\n       if (flag_checking)\n \tverify_range ();\n       return true;\n     }\n   if (r.known_nan ())\n     {\n       m_props.union_ (r.m_props);\n-      set_nan (fp_prop::VARYING);\n+      update_nan (fp_prop::VARYING);\n       if (flag_checking)\n \tverify_range ();\n       return true;\n@@ -531,7 +531,7 @@ frange::intersect (const vrange &v)\n       if (m_props == r.m_props)\n \treturn false;\n \n-      *this = frange_nan (m_type);\n+      set_nan (m_type);\n       return true;\n     }\n   // ?? Perhaps the intersection of a NAN and anything is a NAN ??.\n@@ -3634,23 +3634,23 @@ range_tests_nan ()\n       r1 = frange_float (\"10\", \"12\");\n       r0 = r1;\n       ASSERT_EQ (r0, r1);\n-      r0.set_nan (fp_prop::NO);\n+      r0.clear_nan ();\n       ASSERT_NE (r0, r1);\n-      r0.set_nan (fp_prop::YES);\n+      r0.clear_nan ();\n       ASSERT_NE (r0, r1);\n     }\n \n   // NAN ranges are not equal to each other.\n-  r0 = frange_nan (float_type_node);\n+  r0.set_nan (float_type_node);\n   r1 = r0;\n   ASSERT_FALSE (r0 == r1);\n   ASSERT_FALSE (r0 == r0);\n   ASSERT_TRUE (r0 != r0);\n \n   // [5,6] U NAN = [5,6] NAN.\n   r0 = frange_float (\"5\", \"6\");\n-  r0.set_nan (fp_prop::NO);\n-  r1 = frange_nan (float_type_node);\n+  r0.clear_nan ();\n+  r1.set_nan (float_type_node);\n   r0.union_ (r1);\n   real_from_string (&q, \"5\");\n   real_from_string (&r, \"6\");\n@@ -3659,34 +3659,34 @@ range_tests_nan ()\n   ASSERT_TRUE (r0.maybe_nan ());\n \n   // NAN U NAN = NAN\n-  r0 = frange_nan (float_type_node);\n-  r1 = frange_nan (float_type_node);\n+  r0.set_nan (float_type_node);\n+  r1.set_nan (float_type_node);\n   r0.union_ (r1);\n   ASSERT_TRUE (real_isnan (&r0.lower_bound ()));\n   ASSERT_TRUE (real_isnan (&r1.upper_bound ()));\n   ASSERT_TRUE (r0.known_nan ());\n \n   // [INF, INF] ^ NAN = VARYING\n-  r0 = frange_nan (float_type_node);\n+  r0.set_nan (float_type_node);\n   r1 = frange_float (\"+Inf\", \"+Inf\");\n   r0.intersect (r1);\n   ASSERT_TRUE (r0.varying_p ());\n \n   // NAN ^ NAN = NAN\n-  r0 = frange_nan (float_type_node);\n-  r1 = frange_nan (float_type_node);\n+  r0.set_nan (float_type_node);\n+  r1.set_nan (float_type_node);\n   r0.intersect (r1);\n   ASSERT_TRUE (r0.known_nan ());\n \n   // VARYING ^ NAN = NAN.\n-  r0 = frange_nan (float_type_node);\n+  r0.set_nan (float_type_node);\n   r1.set_varying (float_type_node);\n   r0.intersect (r1);\n   ASSERT_TRUE (r0.known_nan ());\n \n   // Setting the NAN bit to yes, forces to range to [NAN, NAN].\n   r0.set_varying (float_type_node);\n-  r0.set_nan (fp_prop::YES);\n+  r0.update_nan (fp_prop::YES);\n   ASSERT_TRUE (r0.known_nan ());\n   ASSERT_TRUE (real_isnan (&r0.lower_bound ()));\n   ASSERT_TRUE (real_isnan (&r0.upper_bound ()));\n@@ -3736,7 +3736,7 @@ range_tests_signed_zeros ()\n   ASSERT_TRUE (r0.zero_p () && !r0.known_signbit (signbit));\n \n   // NAN U [5,6] should be [5,6] with no sign info.\n-  r0 = frange_nan (float_type_node);\n+  r0.set_nan (float_type_node);\n   r1 = frange_float (\"5\", \"6\");\n   r0.union_ (r1);\n   real_from_string (&q, \"5\");\n@@ -3762,41 +3762,41 @@ range_tests_signbit ()\n   // the signbit property set.\n   r0 = frange_float (\"-5\", \"10\");\n   r0.set_signbit (fp_prop::YES);\n-  r0.set_nan (fp_prop::NO);\n+  r0.clear_nan ();\n   ASSERT_TRUE (r0.known_signbit (signbit) && signbit);\n   r1 = frange_float (\"-5\", \"0\");\n   ASSERT_TRUE (real_identical (&r0.lower_bound (), &r1.lower_bound ()));\n   ASSERT_TRUE (real_identical (&r0.upper_bound (), &r1.upper_bound ()));\n \n   // Negative numbers should have the SIGNBIT set.\n   r0 = frange_float (\"-5\", \"-1\");\n-  r0.set_nan (fp_prop::NO);\n+  r0.clear_nan ();\n   ASSERT_TRUE (r0.known_signbit (signbit) && signbit);\n   // Positive numbers should have the SIGNBIT clear.\n   r0 = frange_float (\"1\", \"10\");\n-  r0.set_nan (fp_prop::NO);\n+  r0.clear_nan ();\n   ASSERT_TRUE (r0.known_signbit (signbit) && !signbit);\n   // Numbers containing zero should have an unknown SIGNBIT.\n   r0 = frange_float (\"0\", \"10\");\n-  r0.set_nan (fp_prop::NO);\n+  r0.clear_nan ();\n   ASSERT_TRUE (!r0.known_signbit (signbit));\n   // Numbers spanning both positive and negative should have an\n   // unknown SIGNBIT.\n   r0 = frange_float (\"-10\", \"10\");\n-  r0.set_nan (fp_prop::NO);\n+  r0.clear_nan ();\n   ASSERT_TRUE (!r0.known_signbit (signbit));\n   r0.set_varying (float_type_node);\n   ASSERT_TRUE (!r0.known_signbit (signbit));\n \n   // Ignore signbit changes when the sign bit is obviously known from\n   // the range.\n   r0 = frange_float (\"5\", \"10\");\n-  r0.set_nan (fp_prop::NO);\n+  r0.clear_nan ();\n   r0.set_signbit (fp_prop::VARYING);\n   ASSERT_TRUE (r0.known_signbit (signbit) && !signbit);\n   r0 = frange_float (\"-5\", \"-1\");\n   r0.set_signbit (fp_prop::NO);\n-  r0.set_nan (fp_prop::NO);\n+  r0.clear_nan ();\n   ASSERT_TRUE (r0.undefined_p ());\n }\n \n@@ -3817,7 +3817,7 @@ range_tests_floats ()\n   if (r0.maybe_nan ())\n     ASSERT_TRUE (r0.varying_p ());\n   // ...unless it has some special property...\n-  r0.set_nan (fp_prop::NO);\n+  r0.clear_nan ();\n   ASSERT_FALSE (r0.varying_p ());\n \n   // The endpoints of a VARYING are +-INF."}, {"sha": "6e896eb9ab57b57539d9996ee54de2a6dc8b2add", "filename": "gcc/value-range.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9c4c4186eb7ca0a62fc590edcbb3f8fc9a081e64/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9c4c4186eb7ca0a62fc590edcbb3f8fc9a081e64/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=9c4c4186eb7ca0a62fc590edcbb3f8fc9a081e64", "patch": "@@ -348,6 +348,7 @@ class frange : public vrange\n   virtual void set (tree, tree, value_range_kind = VR_RANGE) override;\n   void set (tree type, const REAL_VALUE_TYPE &, const REAL_VALUE_TYPE &,\n \t    value_range_kind = VR_RANGE);\n+  void set_nan (tree type);\n   virtual void set_varying (tree type) override;\n   virtual void set_undefined () override;\n   virtual bool union_ (const vrange &) override;\n@@ -376,7 +377,8 @@ class frange : public vrange\n   bool known_signbit (bool &signbit) const;\n \n   // Accessors for FP properties.\n-  void set_nan (fp_prop::kind f);\n+  void update_nan (fp_prop::kind f);\n+  void clear_nan () { update_nan (fp_prop::NO); }\n   void set_signbit (fp_prop::kind);\n private:\n   fp_prop get_nan () const { return m_props.get_nan (); }\n@@ -1186,13 +1188,12 @@ real_min_representable (REAL_VALUE_TYPE *r, tree type)\n \n // Build a NAN of type TYPE.\n \n-inline frange\n-frange_nan (tree type)\n+inline void\n+frange::set_nan (tree type)\n {\n   REAL_VALUE_TYPE r;\n-\n   gcc_assert (real_nan (&r, \"\", 1, TYPE_MODE (type)));\n-  return frange (type, r, r);\n+  set (type, r, r);\n }\n \n // Return TRUE if range is known to be finite."}]}