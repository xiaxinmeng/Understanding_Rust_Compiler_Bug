{"sha": "150f086dd5d99750b5a432953204a7023baab745", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTUwZjA4NmRkNWQ5OTc1MGI1YTQzMjk1MzIwNGE3MDIzYmFhYjc0NQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-11-14T01:43:56Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-11-14T01:43:56Z"}, "message": "gjavah.c (method_signature): New global.\n\n\t* gjavah.c (method_signature): New global.\n\t(HANDLE_METHOD): Set it.\n\t(decompile_return_statement): New function.\n\t(decompile_method): Use it.\n\t(print_method_info): Removed `synth' argument.\n\nFrom-SVN: r46999", "tree": {"sha": "d201c80f2f2c0d484aaa87057a95c8ddd4c6e7ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d201c80f2f2c0d484aaa87057a95c8ddd4c6e7ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/150f086dd5d99750b5a432953204a7023baab745", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/150f086dd5d99750b5a432953204a7023baab745", "html_url": "https://github.com/Rust-GCC/gccrs/commit/150f086dd5d99750b5a432953204a7023baab745", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/150f086dd5d99750b5a432953204a7023baab745/comments", "author": null, "committer": null, "parents": [{"sha": "77bd67cbdd1e989510f976cba5022989c46a42fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77bd67cbdd1e989510f976cba5022989c46a42fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77bd67cbdd1e989510f976cba5022989c46a42fd"}], "stats": {"total": 172, "additions": 156, "deletions": 16}, "files": [{"sha": "614198b8b66bdbc274c5db11cd8062ec37b53d76", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150f086dd5d99750b5a432953204a7023baab745/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150f086dd5d99750b5a432953204a7023baab745/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=150f086dd5d99750b5a432953204a7023baab745", "patch": "@@ -1,3 +1,11 @@\n+2001-11-13  Tom Tromey  <tromey@redhat.com>\n+\n+\t* gjavah.c (method_signature): New global.\n+\t(HANDLE_METHOD): Set it.\n+\t(decompile_return_statement): New function.\n+\t(decompile_method): Use it.\n+\t(print_method_info): Removed `synth' argument.\n+\n 2001-11-09  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* java-tree.h (java_set_yydebug): New."}, {"sha": "8b91549d12e47f2674e08c5de545ba674c29cb87", "filename": "gcc/java/gjavah.c", "status": "modified", "additions": 148, "deletions": 16, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150f086dd5d99750b5a432953204a7023baab745/gcc%2Fjava%2Fgjavah.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150f086dd5d99750b5a432953204a7023baab745/gcc%2Fjava%2Fgjavah.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgjavah.c?ref=150f086dd5d99750b5a432953204a7023baab745", "patch": "@@ -120,7 +120,7 @@ static struct method_name *method_name_list;\n static void print_field_info PARAMS ((FILE*, JCF*, int, int, JCF_u2));\n static void print_mangled_classname PARAMS ((FILE*, JCF*, const char*, int));\n static int  print_cxx_classname PARAMS ((FILE*, const char*, JCF*, int));\n-static void print_method_info PARAMS ((FILE*, JCF*, int, int, JCF_u2, int));\n+static void print_method_info PARAMS ((FILE*, JCF*, int, int, JCF_u2));\n static void print_c_decl PARAMS ((FILE*, JCF*, int, int, int, const char *,\n \t\t\t\t  int));\n static void print_stub_or_jni PARAMS ((FILE*, JCF*, int, int, int,\n@@ -151,6 +151,7 @@ static void version PARAMS ((void)) ATTRIBUTE_NORETURN;\n static int overloaded_jni_method_exists_p PARAMS ((const unsigned char *, int,\n \t\t\t\t\t\t   const char *, int));\n static void jni_print_char PARAMS ((FILE *, int));\n+static void decompile_return_statement PARAMS ((FILE *, JCF *, int, int, int));\n \n JCF_u2 current_field_name;\n JCF_u2 current_field_value;\n@@ -187,9 +188,12 @@ static int method_declared = 0;\n static int method_access = 0;\n static int method_printed = 0;\n static int method_synthetic = 0;\n+static int method_signature = 0;\n+\n #define HANDLE_METHOD(ACCESS_FLAGS, NAME, SIGNATURE, ATTRIBUTE_COUNT)\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n     method_synthetic = 0;\t\t\t\t\t\t\\\n+    method_signature = SIGNATURE;\t\t\t\t\t\\\n     if (ATTRIBUTE_COUNT)\t\t\t\t\t\t\\\n       method_synthetic = peek_attribute (jcf, ATTRIBUTE_COUNT,\t\t\\\n \t\t\t\t  (const char *)\"Synthetic\", 9);\t\\\n@@ -207,12 +211,12 @@ static int method_synthetic = 0;\n \tdecompiled = 0; method_printed = 0;\t\t\t\t\\\n \tif (out)\t\t\t\t\t\t\t\\\n \t  print_method_info (out, jcf, NAME, SIGNATURE,\t\t\t\\\n-\t\t\t     ACCESS_FLAGS, method_synthetic);\t\t\\\n+\t\t\t     ACCESS_FLAGS);\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n     else if (!method_synthetic)\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \tprint_method_info (NULL, jcf, NAME, SIGNATURE,\t\t\t\\\n-\t\t\t   ACCESS_FLAGS, method_synthetic);\t\t\\\n+\t\t\t   ACCESS_FLAGS);\t\t\t\t\\\n \tif (! stubs && ! flag_jni)\t\t\t\t\t\\\n \t  add_class_decl (out, jcf, SIGNATURE);\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n@@ -784,9 +788,9 @@ DEFUN(print_field_info, (stream, jcf, name_index, sig_index, flags),\n \n \n static void\n-DEFUN(print_method_info, (stream, jcf, name_index, sig_index, flags, synth),\n+DEFUN(print_method_info, (stream, jcf, name_index, sig_index, flags),\n       FILE *stream AND JCF* jcf\n-      AND int name_index AND int sig_index AND JCF_u2 flags AND int synth)\n+      AND int name_index AND int sig_index AND JCF_u2 flags)\n {\n   const unsigned char *str;\n   int length, is_init = 0;\n@@ -799,10 +803,6 @@ DEFUN(print_method_info, (stream, jcf, name_index, sig_index, flags, synth),\n   str = JPOOL_UTF_DATA (jcf, name_index);\n   length = JPOOL_UTF_LENGTH (jcf, name_index);\n \n-  /* Ignore synthetic methods. */\n-  if (synth)\n-    return;\n-\n   if (str[0] == '<')\n     {\n       /* Ignore the internally generated method <clinit>. However,\n@@ -892,6 +892,133 @@ DEFUN(print_method_info, (stream, jcf, name_index, sig_index, flags, synth),\n     free (override);\n }\n \n+/* A helper for the decompiler which prints a `return' statement where\n+   the type is a reference type.  If METHODTYPE and OBJECTTYPE are not\n+   identical, we emit a cast.  We do this because the C++ compiler\n+   doesn't know that a reference can be cast to the type of an\n+   interface it implements.  METHODTYPE is the index of the method's\n+   signature.  NAMEINDEX is the index of the field name; -1 for\n+   `this'.  OBJECTTYPE is the index of the object's type.  */\n+static void\n+decompile_return_statement (out, jcf, methodtype, nameindex, objecttype)\n+     FILE *out;\n+     JCF *jcf;\n+     int methodtype, nameindex, objecttype;\n+{\n+  int cast = 0;\n+  int obj_name_len, method_name_len;\n+  const unsigned char *obj_data, *method_data;\n+\n+  obj_name_len = JPOOL_UTF_LENGTH (jcf, objecttype);\n+  obj_data = JPOOL_UTF_DATA (jcf, objecttype);\n+\n+  method_name_len = JPOOL_UTF_LENGTH (jcf, methodtype);\n+  method_data = JPOOL_UTF_DATA (jcf, methodtype);\n+\n+  /* Skip forward to return type part of method.  */\n+  while (*method_data != ')')\n+    {\n+      ++method_data;\n+      --method_name_len;\n+    }\n+  /* Skip past `)'.  */\n+  ++method_data;\n+  --method_name_len;\n+\n+  /* If we see an `L', skip it and the trailing `;'.  */\n+  if (method_data[0] == 'L' && method_data[method_name_len - 1] == ';')\n+    {\n+      ++method_data;\n+      method_name_len -= 2;\n+    }\n+  if (obj_data[0] == 'L' && obj_data[obj_name_len - 1] == ';')\n+    {\n+      ++obj_data;\n+      obj_name_len -= 2;\n+    }\n+\n+  /* FIXME: if METHODTYPE is a superclass of OBJECTTYPE then we don't\n+     need a cast.  Right now there is no way to determine if this is\n+     the case.  */\n+  if (method_name_len != obj_name_len)\n+    cast = 1;\n+  else\n+    {\n+      int i;\n+      for (i = 0; i < method_name_len; ++i)\n+\t{\n+\t  if (method_data[i] != obj_data[i])\n+\t    {\n+\t      cast = 1;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  fputs (\" { return \", out);\n+\n+  if (cast)\n+    {\n+      int array_depth = 0;\n+      const unsigned char *limit;\n+\n+      fputs (\"reinterpret_cast<\", out);\n+\n+      while (*method_data == '[')\n+\t{\n+\t  ++method_data;\n+\t  ++array_depth;\n+\t  --method_name_len;\n+\t  fputs (\"JArray<\", out);\n+\t}\n+\n+      /* Leading space to avoid C++ digraphs.  */\n+      fputs (\" ::\", out);\n+\n+      /* If we see an `L', skip it and the trailing `;'.  Only do this\n+\t if we've seen an array specification.  If we don't have an\n+\t array then the `L' was stripped earlier.  */\n+      if (array_depth && method_data[0] == 'L'\n+\t  && method_data[method_name_len - 1] == ';')\n+\t{\n+\t  ++method_data;\n+\t  method_name_len -= 2;\n+\t}\n+\n+      limit = method_data + method_name_len;\n+      while (method_data < limit)\n+\t{\n+\t  int ch = UTF8_GET (method_data, limit);\n+\t  if (ch == '/')\n+\t    fputs (\"::\", out);\n+\t  else\n+\t    jcf_print_char (out, ch);\n+\t}\n+      fputs (\" *\", out);\n+\n+      /* Close each array.  */\n+      while (array_depth > 0)\n+\t{\n+\t  fputs (\"> *\", out);\n+\t  --array_depth;\n+\t}\n+\n+      /* Close the cast.  */\n+      fputs (\"> (\", out);\n+    }\n+\n+  if (nameindex == -1)\n+    fputs (\"this\", out);\n+  else\n+    print_field_name (out, jcf, nameindex, 0);\n+\n+  if (cast)\n+    fputs (\")\", out);\n+\n+  fputs (\"; }\", out);\n+}\n+\n+\n /* Try to decompile a method body.  Right now we just try to handle a\n    simple case that we can do.  Expand as desired.  */\n static void\n@@ -918,24 +1045,29 @@ decompile_method (out, jcf, code_len)\n \t  || codes[4] == OPCODE_lreturn))\n     {\n       /* Found code like `return FIELD'.  */\n-      fputs (\" { return \", out);\n       index = (codes[2] << 8) | codes[3];\n       /* FIXME: ensure that tag is CONSTANT_Fieldref.  */\n-      /* FIXME: ensure that the field's class is this class.  */\n       name_and_type = JPOOL_USHORT2 (jcf, index);\n       /* FIXME: ensure that tag is CONSTANT_NameAndType.  */\n       name = JPOOL_USHORT1 (jcf, name_and_type);\n-      /* FIXME: flags.  */\n-      print_field_name (out, jcf, name, 0);\n-      fputs (\"; }\", out);\n+      if (codes[4] == OPCODE_areturn)\n+\tdecompile_return_statement (out, jcf, method_signature,\n+\t\t\t\t    name, JPOOL_USHORT2 (jcf, name_and_type));\n+      else\n+\t{\n+\t  fputs (\" { return \", out);\n+\t  /* FIXME: flags.  */\n+\t  print_field_name (out, jcf, name, 0);\n+\t  fputs (\"; }\", out);\n+\t}\n       decompiled = 1;\n     }\n   else if (code_len == 2\n \t   && codes[0] == OPCODE_aload_0\n \t   && codes[1] == OPCODE_areturn)\n     {\n-      /* Found `return this'.  */\n-      fputs (\" { return this; }\", out);\n+      decompile_return_statement (out, jcf, method_signature, -1,\n+\t\t\t\t  JPOOL_USHORT1 (jcf, jcf->this_class));\n       decompiled = 1;\n     }\n   else if (code_len == 1 && codes[0] == OPCODE_return)"}]}