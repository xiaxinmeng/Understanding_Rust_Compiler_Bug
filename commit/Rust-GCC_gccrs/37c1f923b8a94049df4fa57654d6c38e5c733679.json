{"sha": "37c1f923b8a94049df4fa57654d6c38e5c733679", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzdjMWY5MjNiOGE5NDA0OWRmNGZhNTc2NTRkNmMzOGU1YzczMzY3OQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-01-02T09:26:54Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-01-02T09:26:54Z"}, "message": "[multiple changes]\n\n2013-01-02  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Analyze_Pragma): Check the legality of pragma Assume.\n\n2013-01-02  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_eval.adb (Compile_Time_Compare): For static operands, we\n\tcan perform a compile time comparison even if in preanalysis mode.\n\n2013-01-02  Thomas Quinot  <quinot@adacore.com>\n\n\t* par_sco.adb (SCO_Record): Always use\n\tTraverse_Declarations_Or_Statements to process the library level\n\tdeclaration, so that SCOs are properly generated for its aspects.\n\nFrom-SVN: r194778", "tree": {"sha": "0cf6944f6430f480d1e8b50f09693df7b31768f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0cf6944f6430f480d1e8b50f09693df7b31768f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37c1f923b8a94049df4fa57654d6c38e5c733679", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37c1f923b8a94049df4fa57654d6c38e5c733679", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37c1f923b8a94049df4fa57654d6c38e5c733679", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37c1f923b8a94049df4fa57654d6c38e5c733679/comments", "author": null, "committer": null, "parents": [{"sha": "8f252d27b1a28de7b0df05cd0caf826e223ffa43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f252d27b1a28de7b0df05cd0caf826e223ffa43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f252d27b1a28de7b0df05cd0caf826e223ffa43"}], "stats": {"total": 156, "additions": 84, "deletions": 72}, "files": [{"sha": "6c34e8acde0e090a2364c77b7b0fe9be28e84ea2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37c1f923b8a94049df4fa57654d6c38e5c733679/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37c1f923b8a94049df4fa57654d6c38e5c733679/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=37c1f923b8a94049df4fa57654d6c38e5c733679", "patch": "@@ -1,3 +1,18 @@\n+2013-01-02  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Pragma): Check the legality of pragma Assume.\n+\n+2013-01-02  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_eval.adb (Compile_Time_Compare): For static operands, we\n+\tcan perform a compile time comparison even if in preanalysis mode.\n+\n+2013-01-02  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* par_sco.adb (SCO_Record): Always use\n+\tTraverse_Declarations_Or_Statements to process the library level\n+\tdeclaration, so that SCOs are properly generated for its aspects.\n+\n 2013-01-02  Thomas Quinot  <quinot@adacore.com>\n \n \t* scos.ads (In_Decision): Add missing entry for 'a'."}, {"sha": "1838ce2fc49a4327dc400c6af6a78eb8f49e8ade", "filename": "gcc/ada/par_sco.adb", "status": "modified", "additions": 41, "deletions": 61, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37c1f923b8a94049df4fa57654d6c38e5c733679/gcc%2Fada%2Fpar_sco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37c1f923b8a94049df4fa57654d6c38e5c733679/gcc%2Fada%2Fpar_sco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.adb?ref=37c1f923b8a94049df4fa57654d6c38e5c733679", "patch": "@@ -154,7 +154,6 @@ package body Par_SCO is\n    --  Process L, a list of statements or declarations dominated by D.\n    --  If P is present, it is processed as though it had been prepended to L.\n \n-   procedure Traverse_Generic_Instantiation       (N : Node_Id);\n    procedure Traverse_Generic_Package_Declaration (N : Node_Id);\n    procedure Traverse_Handled_Statement_Sequence\n      (N : Node_Id;\n@@ -165,7 +164,6 @@ package body Par_SCO is\n    procedure Traverse_Subprogram_Or_Task_Body\n      (N : Node_Id;\n       D : Dominant_Info := No_Dominant);\n-   procedure Traverse_Subprogram_Declaration      (N : Node_Id);\n    --  Traverse the corresponding construct, generating SCO table entries\n \n    procedure Write_SCOs_To_ALI_File is new Put_SCOs;\n@@ -900,6 +898,23 @@ package body Par_SCO is\n       Lu   : Node_Id;\n       From : Nat;\n \n+      procedure Traverse_Aux_Decls (N : Node_Id);\n+      --  Traverse the Aux_Decl_Nodes of compilation unit N\n+\n+      ------------------------\n+      -- Traverse_Aux_Decls --\n+      ------------------------\n+\n+      procedure Traverse_Aux_Decls (N : Node_Id) is\n+         ADN : constant Node_Id := Aux_Decls_Node (N);\n+      begin\n+         Traverse_Declarations_Or_Statements (Config_Pragmas (ADN));\n+         Traverse_Declarations_Or_Statements (Declarations   (ADN));\n+         Traverse_Declarations_Or_Statements (Pragmas_After  (ADN));\n+      end Traverse_Aux_Decls;\n+\n+   --  Start of processing for SCO_Record\n+\n    begin\n       --  Ignore call if not generating code and generating SCO's\n \n@@ -929,27 +944,22 @@ package body Par_SCO is\n \n       --  Traverse the unit\n \n-      case Nkind (Lu) is\n-         when N_Protected_Body =>\n-            Traverse_Protected_Body (Lu);\n-\n-         when N_Subprogram_Body | N_Task_Body =>\n-            Traverse_Subprogram_Or_Task_Body (Lu);\n-\n-         when N_Subprogram_Declaration =>\n-            Traverse_Subprogram_Declaration (Lu);\n+      Traverse_Aux_Decls (Cunit (U));\n \n-         when N_Package_Declaration =>\n-            Traverse_Package_Declaration (Lu);\n-\n-         when N_Package_Body =>\n-            Traverse_Package_Body (Lu);\n-\n-         when N_Generic_Package_Declaration =>\n-            Traverse_Generic_Package_Declaration (Lu);\n-\n-         when N_Generic_Instantiation =>\n-            Traverse_Generic_Instantiation (Lu);\n+      case Nkind (Lu) is\n+         when\n+           N_Package_Declaration         |\n+           N_Package_Body                |\n+           N_Subprogram_Declaration      |\n+           N_Subprogram_Body             |\n+           N_Generic_Package_Declaration |\n+           N_Protected_Body              |\n+           N_Task_Body                   |\n+           N_Generic_Instantiation       =>\n+\n+            Traverse_Declarations_Or_Statements\n+              (L => No_List,\n+               P => Lu);\n \n          when others =>\n \n@@ -1989,47 +1999,29 @@ package body Par_SCO is\n    --  Start of processing for Traverse_Declarations_Or_Statements\n \n    begin\n+      --  Process single prefixed node\n+\n       if Present (P) then\n          Traverse_One (P);\n       end if;\n \n-      if Is_Non_Empty_List (L) then\n-\n-         --  Loop through statements or declarations\n+      --  Loop through statements or declarations\n \n+      if Is_Non_Empty_List (L) then\n          N := First (L);\n          while Present (N) loop\n             Traverse_One (N);\n             Next (N);\n          end loop;\n \n-         Set_Statement_Entry;\n       end if;\n-   end Traverse_Declarations_Or_Statements;\n-\n-   ------------------------------------\n-   -- Traverse_Generic_Instantiation --\n-   ------------------------------------\n-\n-   procedure Traverse_Generic_Instantiation (N : Node_Id) is\n-      First : Source_Ptr;\n-      Last  : Source_Ptr;\n-\n-   begin\n-      --  First we need a statement entry to cover the instantiation\n \n-      Sloc_Range (N, First, Last);\n-      Set_Table_Entry\n-        (C1   => 'S',\n-         C2   => ' ',\n-         From => First,\n-         To   => Last,\n-         Last => True);\n+      --  End sequence of statements and flush deferred decisions\n \n-      --  Now output any embedded decisions\n-\n-      Process_Decisions (N, 'X', No_Location);\n-   end Traverse_Generic_Instantiation;\n+      if Present (P) or else Is_Non_Empty_List (L) then\n+         Set_Statement_Entry;\n+      end if;\n+   end Traverse_Declarations_Or_Statements;\n \n    ------------------------------------------\n    -- Traverse_Generic_Package_Declaration --\n@@ -2114,16 +2106,4 @@ package body Par_SCO is\n       Traverse_Handled_Statement_Sequence (Handled_Statement_Sequence (N), D);\n    end Traverse_Subprogram_Or_Task_Body;\n \n-   -------------------------------------\n-   -- Traverse_Subprogram_Declaration --\n-   -------------------------------------\n-\n-   procedure Traverse_Subprogram_Declaration (N : Node_Id) is\n-      ADN : constant Node_Id := Aux_Decls_Node (Parent (N));\n-   begin\n-      Traverse_Declarations_Or_Statements (Config_Pragmas (ADN));\n-      Traverse_Declarations_Or_Statements (Declarations   (ADN));\n-      Traverse_Declarations_Or_Statements (Pragmas_After  (ADN));\n-   end Traverse_Subprogram_Declaration;\n-\n end Par_SCO;"}, {"sha": "9c3f8327a727900eda7dbea980c3fdabee200baa", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37c1f923b8a94049df4fa57654d6c38e5c733679/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37c1f923b8a94049df4fa57654d6c38e5c733679/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=37c1f923b8a94049df4fa57654d6c38e5c733679", "patch": "@@ -744,13 +744,19 @@ package body Sem_Eval is\n    begin\n       Diff.all := No_Uint;\n \n-      --  In preanalysis mode, always return Unknown, it is too early to be\n-      --  thinking we know the result of a comparison, save that judgment for\n-      --  the full analysis. This is particularly important in the case of\n-      --  pre and postconditions, which otherwise can be prematurely collapsed\n-      --  into having True or False conditions when this is inappropriate.\n-\n-      if not Full_Analysis then\n+      --  In preanalysis mode, always return Unknown unless the expression\n+      --  is static. It is too early to be thinking we know the result of a\n+      --  comparison, save that judgment for the full analysis. This is\n+      --  particularly important in the case of pre and postconditions, which\n+      --  otherwise can be prematurely collapsed into having True or False\n+      --  conditions when this is inappropriate.\n+\n+      if not (Full_Analysis\n+                or else\n+              (Is_Static_Expression (L)\n+                 and then\n+               Is_Static_Expression (R)))\n+      then\n          return Unknown;\n       end if;\n "}, {"sha": "35410b8be3f035d4fa187650450ff153e70cd02d", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37c1f923b8a94049df4fa57654d6c38e5c733679/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37c1f923b8a94049df4fa57654d6c38e5c733679/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=37c1f923b8a94049df4fa57654d6c38e5c733679", "patch": "@@ -7013,16 +7013,27 @@ package body Sem_Prag is\n \n          --  pragma Assume (boolean_EXPRESSION);\n \n-         --  This should share pragma Assert code ???\n-         --  Run-time check is missing completely ???\n-\n          when Pragma_Assume => Assume : declare\n          begin\n             GNAT_Pragma;\n             S14_Pragma;\n             Check_Arg_Count (1);\n \n-            Analyze_And_Resolve (Expression (Arg1), Any_Boolean);\n+            --  Pragma Assume is transformed into pragma Check in the following\n+            --  manner:\n+\n+            --    pragma Check (Assume, Expr);\n+\n+            Rewrite (N,\n+              Make_Pragma (Loc,\n+                Chars                        => Name_Check,\n+                Pragma_Argument_Associations => New_List (\n+                  Make_Pragma_Argument_Association (Loc,\n+                    Expression => Make_Identifier (Loc, Name_Assume)),\n+\n+                  Make_Pragma_Argument_Association (Loc,\n+                    Expression => Relocate_Node (Expression (Arg1))))));\n+            Analyze (N);\n          end Assume;\n \n          ------------------------------"}]}