{"sha": "d8d7a2867b0f3f642f7dcf6025b1515015f20d88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDhkN2EyODY3YjBmM2Y2NDJmN2RjZjYwMjViMTUxNTAxNWYyMGQ4OA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-09-05T23:02:58Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-09-05T23:02:58Z"}, "message": "ia64.h (INIT_TARGET_OPTABS): Remove.\n\n        * config/ia64/ia64.h (INIT_TARGET_OPTABS): Remove.\n        * config/ia64/lib1funcs.asm (__divdi3): Update from Intel IA-64\n        Optimization Guide, minimum latency alternative.\n        (__moddi3, __udivdi3, __umoddi3): Likewise.\n        (__divsi3, __modsi3, __udivsi3, __umodsi3): Likewise.\n\nFrom-SVN: r36169", "tree": {"sha": "aad29f9474abb72f524692eee0ba6a88eb5a8111", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aad29f9474abb72f524692eee0ba6a88eb5a8111"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8d7a2867b0f3f642f7dcf6025b1515015f20d88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8d7a2867b0f3f642f7dcf6025b1515015f20d88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8d7a2867b0f3f642f7dcf6025b1515015f20d88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8d7a2867b0f3f642f7dcf6025b1515015f20d88/comments", "author": null, "committer": null, "parents": [{"sha": "1056d2281ec2bfcbc72a6fd246b9f3d023aa43e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1056d2281ec2bfcbc72a6fd246b9f3d023aa43e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1056d2281ec2bfcbc72a6fd246b9f3d023aa43e5"}], "stats": {"total": 388, "additions": 145, "deletions": 243}, "files": [{"sha": "46b742fcf4066b263c1eaceae43071c01405f9f7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8d7a2867b0f3f642f7dcf6025b1515015f20d88/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8d7a2867b0f3f642f7dcf6025b1515015f20d88/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d8d7a2867b0f3f642f7dcf6025b1515015f20d88", "patch": "@@ -1,3 +1,11 @@\n+2000-09-05  Richard Henderson  <rth@cygnus.com>\n+\n+\t* config/ia64/ia64.h (INIT_TARGET_OPTABS): Remove.\n+\t* config/ia64/lib1funcs.asm (__divdi3): Update from Intel IA-64\n+\tOptimization Guide, minimum latency alternative.\n+\t(__moddi3, __udivdi3, __umoddi3): Likewise.\n+\t(__divsi3, __modsi3, __udivsi3, __umodsi3): Likewise.\n+\n 2000-09-05  Bruce Korb  <bkorb@gnu.org>\n \n         * gcc/fixinc/fixincl.c(load_file): always read header files"}, {"sha": "70647450e83152b675d16de3bb202a092a3ebae9", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8d7a2867b0f3f642f7dcf6025b1515015f20d88/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8d7a2867b0f3f642f7dcf6025b1515015f20d88/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=d8d7a2867b0f3f642f7dcf6025b1515015f20d88", "patch": "@@ -1694,18 +1694,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n    for lib1funcs.asm modules, e.g. __divdi3 vs _divdi3.  Since lib1funcs.asm\n    goes into libgcc.a first, the linker will find it first.  */\n \n-/* Define this macro as a C statement that declares additional library routines\n-   renames existing ones.  */\n-\n-/* ??? Disable the SImode divide routines for now.  */\n-#define INIT_TARGET_OPTABS \\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  sdiv_optab->handlers[(int) SImode].libfunc = 0;\t\t\t\\\n-  udiv_optab->handlers[(int) SImode].libfunc = 0;\t\t\t\\\n-  smod_optab->handlers[(int) SImode].libfunc = 0;\t\t\t\\\n-  umod_optab->handlers[(int) SImode].libfunc = 0;\t\t\t\\\n-} while (0)\n-\n /* Define this macro if GNU CC should generate calls to the System V (and ANSI\n    C) library functions `memcpy' and `memset' rather than the BSD functions\n    `bcopy' and `bzero'.  */"}, {"sha": "010147ea69a993ede9c807ac9efe05757f8900df", "filename": "gcc/config/ia64/lib1funcs.asm", "status": "modified", "additions": 137, "deletions": 231, "changes": 368, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8d7a2867b0f3f642f7dcf6025b1515015f20d88/gcc%2Fconfig%2Fia64%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8d7a2867b0f3f642f7dcf6025b1515015f20d88/gcc%2Fconfig%2Fia64%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Flib1funcs.asm?ref=d8d7a2867b0f3f642f7dcf6025b1515015f20d88", "patch": "@@ -116,16 +116,10 @@ __divsf3:\n #ifdef L__divdi3\n // Compute a 64-bit integer quotient.\n //\n-// Use reciprocal approximation and Newton-Raphson iteration to compute the\n-// quotient.  frcpa gives 8.6 significant bits, so we need 3 iterations\n-// to get more than the 64 bits of precision that we need for DImode.\n-//\n-// Must use max precision for the reciprocal computations to get 64 bits of\n-// precision.\n+// From the Intel IA-64 Optimization Guide, choose the minimum latency\n+// alternative.\n //\n-// r32/f8 holds the dividend.  r33/f9 holds the divisor.\n-// f10 holds the value 2.0.  f11 holds the reciprocal approximation.\n-// f12 is a temporary.\n+// in0 holds the dividend.  in1 holds the divisor.\n \n \t.text\n \t.align 16\n@@ -143,31 +137,26 @@ __divdi3:\n \t;;\n \t// Compute the reciprocal approximation.\n \tfrcpa.s1 f10, p6 = f8, f9\n-\t;;\n \t// 3 Newton-Raphson iterations.\n-(p6)\tfma.s1 f11 = farg0, f10, f0\n-(p6)\tfnma.s1 f12 = farg1, f10, f1\n-\t;;\n-(p6)\tfma.s1 f11 = f12, f11, f11\n-(p6)\tfma.s1 f13 = f12, f12, f0\n-(p6)\tfma.s1 f10 = f12, f10, f10\n+(p6)\tfnma.s1 f11 = f9, f10, f1\n+(p6)\tfmpy.s1 f12 = f8, f10\n \t;;\n-(p6)\tfma.s1 f11 = f13, f11, f11\n-(p6)\tfma.s1 f12 = f13, f13, f0\n-(p6)\tfma.s1 f10 = f13, f10, f10\n+(p6)\tfmpy.s1 f13 = f11, f11\n+(p6)\tfma.s1 f12 = f11, f12, f12\n \t;;\n-(p6)\tfma.s1 f11 = f12, f11, f11\n-(p6)\tfma.s1 f10 = f12, f10, f10\n+(p6)\tfma.s1 f10 = f11, f10, f10\n+(p6)\tfma.s1 f11 = f13, f12, f12\n \t;;\n-(p6)\tfnma.s1 f8 = f9, f11, f8\n+(p6)\tfma.s1 f10 = f13, f10, f10\n+(p6)\tfnma.s1 f12 = f9, f11, f8\n \t;;\n-(p6)\tfma.s1 f10 = f8, f10, f11\n+(p6)\tfma.s1 f10 = f12, f10, f11\n \t;;\n \t// Round quotient to an integer.\n-\tfcvt.fx.trunc.s1 f8 = f10\n+\tfcvt.fx.trunc.s1 f10 = f10\n \t;;\n \t// Transfer result to GP registers.\n-\tgetf.sig ret0 = f8\n+\tgetf.sig ret0 = f10\n \tbr.ret.sptk rp\n \t;;\n \t.endp __divdi3\n@@ -176,16 +165,10 @@ __divdi3:\n #ifdef L__moddi3\n // Compute a 64-bit integer modulus.\n //\n-// Use reciprocal approximation and Newton-Raphson iteration to compute the\n-// quotient.  frcpa gives 8.6 significant bits, so we need 3 iterations\n-// to get more than the 64 bits of precision that we need for DImode.\n-//\n-// Must use max precision for the reciprocal computations to get 64 bits of\n-// precision.\n+// From the Intel IA-64 Optimization Guide, choose the minimum latency\n+// alternative.\n //\n-// r32/f8 holds the dividend.  r33/f9 holds the divisor.\n-// f10 holds the value 2.0.  f11 holds the reciprocal approximation.\n-// f12 is a temporary.\n+// in0 holds the dividend (a).  in1 holds the divisor (b).\n \n \t.text\n \t.align 16\n@@ -194,49 +177,40 @@ __divdi3:\n __moddi3:\n \t.regstk 2,0,0,0\n \t// Transfer inputs to FP registers.\n-\tsetf.sig f8 = in0\n+\tsetf.sig f14 = in0\n \tsetf.sig f9 = in1\n \t;;\n \t// Convert the inputs to FP, so that they won't be treated as unsigned.\n-\tfcvt.xf f8 = f8\n+\tfcvt.xf f8 = f14\n \tfcvt.xf f9 = f9\n \t;;\n \t// Compute the reciprocal approximation.\n \tfrcpa.s1 f10, p6 = f8, f9\n \t;;\n \t// 3 Newton-Raphson iterations.\n-(p6)\tfma.s1 f11 = farg0, f10, f0\n-(p6)\tfnma.s1 f12 = farg1, f10, f1\n+(p6)\tfmpy.s1 f12 = f8, f10\n+(p6)\tfnma.s1 f11 = f9, f10, f1\n \t;;\n-(p6)\tfma.s1 f11 = f12, f11, f11\n-(p6)\tfma.s1 f13 = f12, f12, f0\n-(p6)\tfma.s1 f10 = f12, f10, f10\n-\t;;\n-(p6)\tfma.s1 f11 = f13, f11, f11\n-(p6)\tfma.s1 f12 = f13, f13, f0\n-(p6)\tfma.s1 f10 = f13, f10, f10\n+(p6)\tfma.s1 f12 = f11, f12, f12\n+(p6)\tfmpy.s1 f13 = f11, f11\n \t;;\n-(p6)\tfma.s1 f11 = f12, f11, f11\n-(p6)\tfma.s1 f10 = f12, f10, f10\n+(p6)\tfma.s1 f10 = f11, f10, f10\n+(p6)\tfma.s1 f11 = f13, f12, f12\n \t;;\n+\tsub in1 = r0, in1\n+(p6)\tfma.s1 f10 = f13, f10, f10\n (p6)\tfnma.s1 f12 = f9, f11, f8\n \t;;\n+\tsetf.sig f9 = in1\n (p6)\tfma.s1 f10 = f12, f10, f11\n \t;;\n-\t// Round quotient to an integer.\n \tfcvt.fx.trunc.s1 f10 = f10\n \t;;\n-\t// Renormalize.\n-\tfcvt.xf f10 = f10\n-\t;;\n-\t// Compute remainder.\n-\tfnma.s1 f8 = f10, f9, f8\n-\t;;\n-\t// Round remainder to an integer.\n-\tfcvt.fx.trunc.s1 f8 = f8\n+\t// r = q * (-b) + a\n+\txma.l f10 = f10, f9, f14\n \t;;\n \t// Transfer result to GP registers.\n-\tgetf.sig ret0 = f8\n+\tgetf.sig ret0 = f10\n \tbr.ret.sptk rp\n \t;;\n \t.endp __moddi3\n@@ -245,16 +219,10 @@ __moddi3:\n #ifdef L__udivdi3\n // Compute a 64-bit unsigned integer quotient.\n //\n-// Use reciprocal approximation and Newton-Raphson iteration to compute the\n-// quotient.  frcpa gives 8.6 significant bits, so we need 3 iterations\n-// to get more than the 64 bits of precision that we need for DImode.\n-//\n-// Must use max precision for the reciprocal computations to get 64 bits of\n-// precision.\n+// From the Intel IA-64 Optimization Guide, choose the minimum latency\n+// alternative.\n //\n-// r32/f8 holds the dividend.  r33/f9 holds the divisor.\n-// f10 holds the value 2.0.  f11 holds the reciprocal approximation.\n-// f12 is a temporary.\n+// in0 holds the dividend.  in1 holds the divisor.\n \n \t.text\n \t.align 16\n@@ -274,29 +242,25 @@ __udivdi3:\n \tfrcpa.s1 f10, p6 = f8, f9\n \t;;\n \t// 3 Newton-Raphson iterations.\n-(p6)\tfma.s1 f11 = farg0, f10, f0\n-(p6)\tfnma.s1 f12 = farg1, f10, f1\n+(p6)\tfnma.s1 f11 = f9, f10, f1\n+(p6)\tfmpy.s1 f12 = f8, f10\n \t;;\n-(p6)\tfma.s1 f11 = f12, f11, f11\n-(p6)\tfma.s1 f13 = f12, f12, f0\n-(p6)\tfma.s1 f10 = f12, f10, f10\n-\t;;\n-(p6)\tfma.s1 f11 = f13, f11, f11\n-(p6)\tfma.s1 f12 = f13, f13, f0\n-(p6)\tfma.s1 f10 = f13, f10, f10\n+(p6)\tfmpy.s1 f13 = f11, f11\n+(p6)\tfma.s1 f12 = f11, f12, f12\n \t;;\n-(p6)\tfma.s1 f11 = f12, f11, f11\n-(p6)\tfma.s1 f10 = f12, f10, f10\n+(p6)\tfma.s1 f10 = f11, f10, f10\n+(p6)\tfma.s1 f11 = f13, f12, f12\n \t;;\n-(p6)\tfnma.s1 f8 = f9, f11, f8\n+(p6)\tfma.s1 f10 = f13, f10, f10\n+(p6)\tfnma.s1 f12 = f9, f11, f8\n \t;;\n-(p6)\tfma.s1 f10 = f8, f10, f11\n+(p6)\tfma.s1 f10 = f2, f10, f11\n \t;;\n \t// Round quotient to an unsigned integer.\n-\tfcvt.fxu.trunc.s1 f8 = f10\n+\tfcvt.fxu.trunc.s1 f10 = f10\n \t;;\n \t// Transfer result to GP registers.\n-\tgetf.sig ret0 = f8\n+\tgetf.sig ret0 = f10\n \tbr.ret.sptk rp\n \t;;\n \t.endp __udivdi3\n@@ -305,16 +269,10 @@ __udivdi3:\n #ifdef L__umoddi3\n // Compute a 64-bit unsigned integer modulus.\n //\n-// Use reciprocal approximation and Newton-Raphson iteration to compute the\n-// quotient.  frcpa gives 8.6 significant bits, so we need 3 iterations\n-// to get more than the 64 bits of precision that we need for DImode.\n-//\n-// Must use max precision for the reciprocal computations to get 64 bits of\n-// precision.\n+// From the Intel IA-64 Optimization Guide, choose the minimum latency\n+// alternative.\n //\n-// r32/f8 holds the dividend.  r33/f9 holds the divisor.\n-// f10 holds the value 2.0.  f11 holds the reciprocal approximation.\n-// f12 is a temporary.\n+// in0 holds the dividend (a).  in1 holds the divisor (b).\n \n \t.text\n \t.align 16\n@@ -323,49 +281,41 @@ __udivdi3:\n __umoddi3:\n \t.regstk 2,0,0,0\n \t// Transfer inputs to FP registers.\n-\tsetf.sig f8 = in0\n+\tsetf.sig f14 = in0\n \tsetf.sig f9 = in1\n \t;;\n \t// Convert the inputs to FP, to avoid FP software assist faults.\n-\tfcvt.xuf.s1 f8 = f8\n+\tfcvt.xuf.s1 f8 = f14\n \tfcvt.xuf.s1 f9 = f9\n \t;;\n \t// Compute the reciprocal approximation.\n \tfrcpa.s1 f10, p6 = f8, f9\n \t;;\n \t// 3 Newton-Raphson iterations.\n-(p6)\tfma.s1 f11 = farg0, f10, f0\n-(p6)\tfnma.s1 f12 = farg1, f10, f1\n-\t;;\n-(p6)\tfma.s1 f11 = f12, f11, f11\n-(p6)\tfma.s1 f13 = f12, f12, f0\n-(p6)\tfma.s1 f10 = f12, f10, f10\n+(p6)\tfmpy.s1 f12 = f8, f10\n+(p6)\tfnma.s1 f11 = f9, f10, f1\n \t;;\n-(p6)\tfma.s1 f11 = f13, f11, f11\n-(p6)\tfma.s1 f12 = f13, f13, f0\n-(p6)\tfma.s1 f10 = f13, f10, f10\n+(p6)\tfma.s1 f12 = f11, f12, f12\n+(p6)\tfmpy.s1 f13 = f11, f11\n \t;;\n-(p6)\tfma.s1 f11 = f12, f11, f11\n-(p6)\tfma.s1 f10 = f12, f10, f10\n+(p6)\tfma.s1 f10 = f11, f10, f10\n+(p6)\tfma.s1 f11 = f13, f12, f12\n \t;;\n+\tsub in1 = r0, in1\n+(p6)\tfma.s1 f10 = f13, f10, f10\n (p6)\tfnma.s1 f12 = f9, f11, f8\n \t;;\n+\tsetf.sig f9 = in1\n (p6)\tfma.s1 f10 = f12, f10, f11\n \t;;\n \t// Round quotient to an unsigned integer.\n \tfcvt.fxu.trunc.s1 f10 = f10\n \t;;\n-\t// Renormalize.\n-\tfcvt.xuf.s1 f10 = f10\n-\t;;\n-\t// Compute remainder.\n-\tfnma.s1 f8 = f10, f9, f8\n-\t;;\n-\t// Round remainder to an integer.\n-\tfcvt.fxu.trunc.s1 f8 = f8\n+\t// r = q * (-b) + a\n+\txma.l f10 = f10, f9, f14\n \t;;\n \t// Transfer result to GP registers.\n-\tgetf.sig ret0 = f8\n+\tgetf.sig ret0 = f10\n \tbr.ret.sptk rp\n \t;;\n \t.endp __umoddi3\n@@ -374,50 +324,41 @@ __umoddi3:\n #ifdef L__divsi3\n // Compute a 32-bit integer quotient.\n //\n-// Use reciprocal approximation and Newton-Raphson iteration to compute the\n-// quotient.  frcpa gives 8.6 significant bits, so we need 2 iterations\n-// to get more than the 32 bits of precision that we need for SImode.\n-//\n-// ??? This is currently not used.  It needs to be fixed to be more like the\n-// above DImode routines.\n-//\n-// ??? Check to see if the error is less than >.5ulp error.  We may need\n-// some adjustment code to get precise enough results.\n-//\n-// ??? Should probably use max precision for the reciprocal computations.\n+// From the Intel IA-64 Optimization Guide, choose the minimum latency\n+// alternative.\n //\n-// r32/f8 holds the dividend.  r33/f9 holds the divisor.\n-// f10 holds the value 2.0.  f11 holds the reciprocal approximation.\n-// f12 is a temporary.\n+// in0 holds the dividend.  in1 holds the divisor.\n \n \t.text\n \t.align 16\n \t.global __divsi3\n \t.proc __divsi3\n __divsi3:\n \t.regstk 2,0,0,0\n+\tsxt4 in0 = in0\n+\tsxt4 in1 = in1\n+\t;;\n \tsetf.sig f8 = in0\n \tsetf.sig f9 = in1\n \t;;\n+\tmov r2 = 0x0ffdd\n \tfcvt.xf f8 = f8\n \tfcvt.xf f9 = f9\n \t;;\n-\tfrcpa f11, p6 = f8, f9\n-\tfadd f10 = f1, f1\n-\t;;\n-\tfnma f12 = f9, f11, f10\n+\tsetf.exp f11 = r2\n+\tfrcpa f10, p6 = f8, f9\n \t;;\n-\tfmpy f11 = f11, f12\n+(p6)\tfmpy.s1 f8 = f8, f10\n+(p6)\tfnma.s1 f9 = f9, f10, f1\n \t;;\n-\tfnma f12 = f9, f11, f10\n-\t;;\n-\tfmpy f11 = f11, f12\n+(p6)\tfma.s1 f8 = f9, f8, f8\n+(p6)\tfma.s1 f9 = f9, f9, f11\n \t;;\n-\tfmpy f8 = f8, f11\n+(p6)\tfma.s1 f10 = f9, f8, f8\n \t;;\n-\tfcvt.fx.trunc f8 = f8\n+\tfcvt.fx.trunc.s1 f10 = f10\n \t;;\n-\tgetf.sig ret0 = f8\n+\tgetf.sig ret0 = f10\n \tbr.ret.sptk rp\n \t;;\n \t.endp __divsi3\n@@ -426,56 +367,45 @@ __divsi3:\n #ifdef L__modsi3\n // Compute a 32-bit integer modulus.\n //\n-// Use reciprocal approximation and Newton-Raphson iteration to compute the\n-// quotient.  frcpa gives 8.6 significant bits, so we need 2 iterations\n-// to get more than the 32 bits of precision that we need for SImode.\n-//\n-// ??? This is currently not used.  It needs to be fixed to be more like the\n-// above DImode routines.\n-//\n-// ??? Check to see if the error is less than >.5ulp error.  We may need\n-// some adjustment code to get precise enough results.\n-//\n-// ??? Should probably use max precision for the reciprocal computations.\n+// From the Intel IA-64 Optimization Guide, choose the minimum latency\n+// alternative.\n //\n-// r32/f8 holds the dividend.  r33/f9 holds the divisor.\n-// f10 holds the value 2.0.  f11 holds the reciprocal approximation.\n-// f12 is a temporary.\n+// in0 holds the dividend.  in1 holds the divisor.\n \n \t.text\n \t.align 16\n \t.global __modsi3\n \t.proc __modsi3\n __modsi3:\n \t.regstk 2,0,0,0\n-\tsetf.sig f8 = r32\n+\tmov r2 = 0x0ffdd\n+\tsxt4 in0 = in0\n+\tsxt4 in1 = in1\n+\t;;\n+\tsetf.sig f13 = r32\n \tsetf.sig f9 = r33\n \t;;\n-\tfcvt.xf f8 = f8\n+\tsub in1 = r0, in1\n+\tfcvt.xf f8 = f13\n \tfcvt.xf f9 = f9\n \t;;\n-\tfrcpa f11, p6 = f8, f9\n-\tfadd f10 = f1, f1\n-\t;;\n-\tfnma f12 = f9, f11, f10\n-\t;;\n-\tfmpy f11 = f11, f12\n-\t;;\n-\tfnma f12 = f9, f11, f10\n+\tsetf.exp f11 = r2\n+\tfrcpa f10, p6 = f8, f9\n \t;;\n-\tfmpy f11 = f11, f12\n+(p6)\tfmpy.s1 f12 = f8, f10\n+(p6)\tfnma.s1 f10 = f9, f10, f1\n \t;;\n-\tfmpy f10 = f8, f11\n-\t;;\n-\tfcvt.fx.trunc f10 = f10\n+\tsetf.sig f9 = in1\n+(p6)\tfma.s1 f12 = f10, f12, f12\n+(p6)\tfma.s1 f10 = f10, f10, f11\t\n \t;;\n-\tfcvt.xf f10 = f10\n+(p6)\tfma.s1 f10 = f10, f12, f12\n \t;;\n-\tfnma f8 = f10, f9, f8\n+\tfcvt.fx.trunc.s1 f10 = f10\n \t;;\n-\tfcvt.fx f8 = f8\n+\txma.l f10 = f10, f9, f13\n \t;;\n-\tgetf.sig r32 = f8\n+\tgetf.sig ret0 = f10\n \tbr.ret.sptk rp\n \t;;\n \t.endp __modsi3\n@@ -484,50 +414,38 @@ __modsi3:\n #ifdef L__udivsi3\n // Compute a 32-bit unsigned integer quotient.\n //\n-// Use reciprocal approximation and Newton-Raphson iteration to compute the\n-// quotient.  frcpa gives 8.6 significant bits, so we need 2 iterations\n-// to get more than the 32 bits of precision that we need for SImode.\n-//\n-// ??? This is currently not used.  It needs to be fixed to be more like the\n-// above DImode routines.\n-//\n-// ??? Check to see if the error is less than >.5ulp error.  We may need\n-// some adjustment code to get precise enough results.\n-//\n-// ??? Should probably use max precision for the reciprocal computations.\n-//\n-// r32/f8 holds the dividend.  r33/f9 holds the divisor.\n-// f10 holds the value 2.0.  f11 holds the reciprocal approximation.\n-// f12 is a temporary.\n+// From the Intel IA-64 Optimization Guide, choose the minimum latency\n+// alternative.\n //\n-// This is the same as divsi3, except that we don't need fcvt instructions\n-// before the frcpa.\n+// in0 holds the dividend.  in1 holds the divisor.\n \n \t.text\n \t.align 16\n \t.global __udivsi3\n \t.proc __udivsi3\n __udivsi3:\n \t.regstk 2,0,0,0\n-\tsetf.sig f8 = r32\n-\tsetf.sig f9 = r33\n+\tmov r2 = 0x0ffdd\n+\tzxt4 in0 = in0\n+\tzxt4 in1 = in1\n \t;;\n-\tfrcpa f11, p6 = f8, f9\n-\tfadd f10 = f1, f1\n-\t;;\n-\tfnma f12 = f9, f11, f10\n+\tsetf.sig f8 = in0\n+\tsetf.sig f9 = in1\n \t;;\n-\tfmpy f11 = f11, f12\n+\tsetf.exp f11 = r2\n+\tfrcpa f10, p6 = f8, f9\n \t;;\n-\tfnma f12 = f9, f11, f10\n+(p6)\tfmpy.s1 f8 = f8, f10\n+(p6)\tfnma.s1 f9 = f9, f10, f1\n \t;;\n-\tfmpy f11 = f11, f12\n+(p6)\tfma.s1 f8 = f9, f8, f8\n+(p6)\tfma.s1 f9 = f9, f9, f11\n \t;;\n-\tfmpy f8 = f8, f11\n+(p6)\tfma.s1 f10 = f9, f8, f8\n \t;;\n-\tfcvt.fxu.trunc f8 = f8\n+\tfcvt.fxu.trunc.s1 f10 = f10\n \t;;\n-\tgetf.sig ret0 = f8\n+\tgetf.sig ret0 = f10\n \tbr.ret.sptk rp\n \t;;\n \t.endp __udivsi3\n@@ -536,56 +454,44 @@ __udivsi3:\n #ifdef L__umodsi3\n // Compute a 32-bit unsigned integer modulus.\n //\n-// Use reciprocal approximation and Newton-Raphson iteration to compute the\n-// quotient.  frcpa gives 8.6 significant bits, so we need 2 iterations\n-// to get more than the 32 bits of precision that we need for SImode.\n-//\n-// ??? This is currently not used.  It needs to be fixed to be more like the\n-// above DImode routines.\n-//\n-// ??? Check to see if the error is less than >.5ulp error.  We may need\n-// some adjustment code to get precise enough results.\n-//\n-// ??? Should probably use max precision for the reciprocal computations.\n-//\n-// r32/f8 holds the dividend.  r33/f9 holds the divisor.\n-// f10 holds the value 2.0.  f11 holds the reciprocal approximation.\n-// f12 is a temporary.\n+// From the Intel IA-64 Optimization Guide, choose the minimum latency\n+// alternative.\n //\n-// This is the same as modsi3, except that we don't need fcvt instructions\n-// before the frcpa.\n+// in0 holds the dividend.  in1 holds the divisor.\n \n \t.text\n \t.align 16\n \t.global __umodsi3\n \t.proc __umodsi3\n __umodsi3:\n \t.regstk 2,0,0,0\n-\tsetf.sig f8 = r32\n-\tsetf.sig f9 = r33\n-\t;;\n-\tfrcpa f11, p6 = f8, f9\n-\tfadd f10 = f1, f1\n-\t;;\n-\tfnma f12 = f9, f11, f10\n+\tmov r2 = 0x0ffdd\n+\tzxt4 in0 = in0\n+\tzxt4 in1 = in1\n \t;;\n-\tfmpy f11 = f11, f12\n+\tsetf.sig f13 = in0\n+\tsetf.sig f9 = in1\n \t;;\n-\tfnma f12 = f9, f11, f10\n+\tsub in1 = r0, in1\n+\tfcvt.xf f8 = f13\n+\tfcvt.xf f9 = f9\n \t;;\n-\tfmpy f11 = f11, f12\n+\tsetf.exp f11 = r2\n+\tfrcpa f10, p6 = f8, f9\n \t;;\n-\tfmpy f10 = f8, f11\n+(p6)\tfmpy.s1 f12 = f8, f10\n+(p6)\tfnma.s1 f10 = f9, f10, f1\n \t;;\n-\tfcvt.fxu.trunc f10 = f10\n+(p6)\tfma.s1 f12 = f10, f12, f12\n+(p6)\tfma.s1 f10 = f10, f10, f11\n \t;;\n-\tfcvt.xuf f10 = f10\n+(p6)\tfma.s1 f10 = f10, f12, f12\n \t;;\n-\tfnma f8 = f10, f9, f8\n+\tfcvt.fxu.trunc.s1 f10 = f10\n \t;;\n-\tfcvt.fxu f8 = f8\n+\txma.l f10 = f10, f9, f13\n \t;;\n-\tgetf.sig r32 = f8\n+\tgetf.sig ret0 = f10\n \tbr.ret.sptk rp\n \t;;\n \t.endp __umodsi3"}]}