{"sha": "9fb7806b3797b39b4931aa570e95ee056381dc0f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZiNzgwNmIzNzk3YjM5YjQ5MzFhYTU3MGU5NWVlMDU2MzgxZGMwZg==", "commit": {"author": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1995-12-06T11:39:58Z"}, "committer": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1995-12-06T11:39:58Z"}, "message": "Initial revision\n\nFrom-SVN: r10679", "tree": {"sha": "4b6db82ab183599f7759f9128c04346f1e0dc9d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b6db82ab183599f7759f9128c04346f1e0dc9d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fb7806b3797b39b4931aa570e95ee056381dc0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fb7806b3797b39b4931aa570e95ee056381dc0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fb7806b3797b39b4931aa570e95ee056381dc0f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fb7806b3797b39b4931aa570e95ee056381dc0f/comments", "author": null, "committer": null, "parents": [{"sha": "6e94a50355dfcc95bc255eb3de1be62a5cb25041", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e94a50355dfcc95bc255eb3de1be62a5cb25041", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e94a50355dfcc95bc255eb3de1be62a5cb25041"}], "stats": {"total": 856, "additions": 856, "deletions": 0}, "files": [{"sha": "5af670b023e86e8a823e114d0b62d8f13acb847b", "filename": "gcc/config/arm/aof.h", "status": "added", "additions": 480, "deletions": 0, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb7806b3797b39b4931aa570e95ee056381dc0f/gcc%2Fconfig%2Farm%2Faof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb7806b3797b39b4931aa570e95ee056381dc0f/gcc%2Fconfig%2Farm%2Faof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faof.h?ref=9fb7806b3797b39b4931aa570e95ee056381dc0f", "patch": "@@ -0,0 +1,480 @@\n+/* Definitions of target machine for GNU compiler, for Advanced RISC Machines\n+   ARM compilation, AOF Assembler.\n+   Copyright (C) 1995 Free Software Foundation, Inc.\n+   Contributed by Richard Earnshaw (rearnsha@armltd.co.uk)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+   \n+\f\n+\n+#define AOF_ASSEMBLER\n+\n+#define LINK_LIBGCC_SPECIAL 1\n+\n+#define LINK_SPEC \"%{aof} %{bin} %{aif} %{ihf} %{shl,*} %{reent*} %{split} \\\n+\t\t   %{ov*,*} %{reloc*} -nodebug\"\n+\n+#define STARTFILE_SPEC \"crtbegin.o%s\"\n+\n+#define ENDFILE_SPEC \"crtend.o%s\"\n+\n+#ifndef ASM_SPEC\n+#define ASM_SPEC \"%{g -g} -arch 4 \\\n+-apcs 3%{mapcs-32:/32bit}%{mapcs-26:/26bit}%{!mapcs-26:%{!macps-32:/26bit}}\"\n+#endif\n+\n+#ifndef LIB_SPEC\n+#define LIB_SPEC \"%{Eb: armlib_h.32b%s}%{!Eb: armlib_h.32l%s}\"\n+#endif\n+\n+#define LIBGCC_SPEC \"libgcc.a%s\"\n+\n+/* Dividing the Output into Sections (Text, Data, ...) */\n+/* AOF Assembler syntax is a nightmare when it comes to areas, since once\n+   we change from one area to another, we can't go back again.  Instead,\n+   we must create a new area with the same attributes and add the new output\n+   to that.  Unfortunately, there is nothing we can do here to guarantee that\n+   two areas with the same attributes will be linked adjacently in the\n+   resulting executable, so we have to be careful not to do pc-relative \n+   addressing across such boundaries.  This isn't a major problem for thumb,\n+   since the range of such addressing modes is so limited that it would\n+   rarely be useful anyway. */\n+char *aof_text_section ();\n+#define TEXT_SECTION_ASM_OP \\\n+  aof_text_section (in_section == in_readonly_data)\n+\n+#define SELECT_RTX_SECTION(MODE,RTX) text_section ();\n+\n+char *aof_data_section ();\n+#define DATA_SECTION_ASM_OP aof_data_section ()\n+\n+#define EXTRA_SECTIONS in_zero_init, in_readonly_data, in_ctor, in_dtor\n+\n+#define EXTRA_SECTION_FUNCTIONS\t\\\n+ZERO_INIT_SECTION\t\t\\\n+READONLYDATA_SECTION\t\t\\\n+CTOR_SECTION\t\t\t\\\n+DTOR_SECTION\n+\n+#define ZERO_INIT_SECTION\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+zero_init_section ()\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  static int zero_init_count = 1;\t\t\t\t\\\n+  if (in_section != in_zero_init)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"\\tAREA |C$$zidata%d|,NOINIT\\n\",\t\\\n+\t       zero_init_count++);\t\t\t\t\\\n+      in_section = in_zero_init;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define READONLYDATA_SECTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+readonly_data ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  extern int arm_text_section_count;\t\t\t\t\t\\\n+  if (in_section != in_readonly_data)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (in_section != in_text)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  fprintf (asm_out_file,\t\t\t\t\t\\\n+\t\t   \"\\tAREA |C$$code%d|, CODE, READONLY\",\t\t\\\n+\t\t   arm_text_section_count++);\t\t\t\t\\\n+\t  if (flag_pic)\t\t\t\t\t\t\t\\\n+\t    fputs (\", PIC, REENTRANT\", asm_out_file);\t\t\t\\\n+\t  fputc ('\\n', asm_out_file);\t\t \t\t\t\\\n+\t}\t \t\t\t\t\t\t\t\\\n+      in_section = in_readonly_data;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+int\t\t\t\t\t\t\t\t\t\\\n+in_readonly_data_section ()\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  return in_section == in_readonly_data;\t\t\t\t\\\n+}\n+\n+#define CTOR_SECTION\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+ctor_section ()\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  static int ctors_once = 0;\t\t\t\t\t\t\\\n+  if (in_section != in_ctor)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (ctors_once)\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  fprintf (stderr,\t\t\t\t\t\t\\\n+\t\t   \"Attempt to output more than one ctor section\\n\");\t\\\n+\t  abort ();\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"\\t%s\\n\", CTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_ctor;\t\t\t\t\t\t\\\n+      ctors_once = 1;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define DTOR_SECTION\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+dtor_section ()\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  static int dtors_once = 0;\t\t\t\t\t\t\\\n+  if (in_section != in_dtor)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (dtors_once)\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  fprintf (stderr,\t\t\t\t\t\t\\\n+\t\t   \"Attempt to output more than one dtor section\\n\");\t\\\n+\t  abort ();\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"\\t%s\\n\", DTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_dtor;\t\t\t\t\t\t\\\n+      dtors_once = 1;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define CTOR_LIST_BEGIN\t\t\t\t\t\\\n+asm (CTORS_SECTION_ASM_OP);\t\t\t\t\\\n+extern func_ptr __CTOR_END__[1];\t\t\t\\\n+func_ptr __CTOR_LIST__[1] = {__CTOR_END__};\n+\n+#define CTOR_LIST_END\t\t\t\t\t\\\n+asm (CTORS_SECTION_ASM_OP);\t\t\t\t\\\n+func_ptr __CTOR_END__[1] = { (func_ptr) 0 };\n+\n+#define DO_GLOBAL_CTORS_BODY\t\t\\\n+do {\t\t\t\t\t\\\n+  func_ptr *ptr = __CTOR_LIST__ + 1;\t\\\n+  while (*ptr)\t\t\t\t\\\n+    (*ptr++) ();\t\t\t\\\n+} while (0)\n+\n+#define DTOR_LIST_BEGIN\t\t\t\t\t\\\n+asm (DTORS_SECTION_ASM_OP);\t\t\t\t\\\n+extern func_ptr __DTOR_END__[1];\t\t\t\\\n+func_ptr __DTOR_LIST__[1] = {__DTOR_END__};\n+\n+#define DTOR_LIST_END\t\t\t\t\t\\\n+asm (DTORS_SECTION_ASM_OP);\t\t\t\t\\\n+func_ptr __DTOR_END__[1] = { (func_ptr) 0 };\n+\n+#define DO_GLOBAL_DTORS_BODY\t\t\\\n+do {\t\t\t\t\t\\\n+  func_ptr *ptr = __DTOR_LIST__ + 1;\t\\\n+  while (*ptr)\t\t\t\t\\\n+    (*ptr++) ();\t\t\t\\\n+} while (0)\n+#define READONLY_DATA_SECTION readonly_data\n+\n+#define JUMP_TABLES_IN_TEXT_SECTION 1\n+\n+#ifndef ARM_OS_NAME\n+#define ARM_OS_NAME \"(generic)\"\n+#endif\n+\n+/* For the AOF linker, we need to reference __main to force the standard\n+   library to get linked in. */\n+\n+#define ASM_FILE_START(STREAM)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  extern char *version_string;\t\t\t\t\t\\\n+  fprintf ((STREAM), \"%s Generated by gcc %s for ARM/%s\\n\", \t\\\n+\t   ASM_COMMENT_START, version_string, ARM_OS_NAME);\t\\\n+  fprintf ((STREAM), \"__a1\\tRN\\t0\\n\");\t\t\t\t\\\n+  fprintf ((STREAM), \"__a2\\tRN\\t1\\n\");\t\t\t\t\\\n+  fprintf ((STREAM), \"__a3\\tRN\\t2\\n\");\t\t\t\t\\\n+  fprintf ((STREAM), \"__a4\\tRN\\t3\\n\");\t\t\t\t\\\n+  fprintf ((STREAM), \"__v1\\tRN\\t4\\n\");\t\t\t\t\\\n+  fprintf ((STREAM), \"__v2\\tRN\\t5\\n\");\t\t\t\t\\\n+  fprintf ((STREAM), \"__v3\\tRN\\t6\\n\");\t\t\t\t\\\n+  fprintf ((STREAM), \"__v4\\tRN\\t7\\n\");\t\t\t\t\\\n+  fprintf ((STREAM), \"__v5\\tRN\\t8\\n\");\t\t\t\t\\\n+  fprintf ((STREAM), \"__v6\\tRN\\t9\\n\");\t\t\t\t\\\n+  fprintf ((STREAM), \"__sl\\tRN\\t10\\n\");\t\t\t\t\\\n+  fprintf ((STREAM), \"__fp\\tRN\\t11\\n\");\t\t\t\t\\\n+  fprintf ((STREAM), \"__ip\\tRN\\t12\\n\");\t\t\t\t\\\n+  fprintf ((STREAM), \"__sp\\tRN\\t13\\n\");\t\t\t\t\\\n+  fprintf ((STREAM), \"__lr\\tRN\\t14\\n\");\t\t\t\t\\\n+  fprintf ((STREAM), \"__pc\\tRN\\t15\\n\");\t\t\t\t\\\n+  fprintf ((STREAM), \"__f0\\tFN\\t0\\n\");\t\t\t\t\\\n+  fprintf ((STREAM), \"__f1\\tFN\\t1\\n\");\t\t\t\t\\\n+  fprintf ((STREAM), \"__f2\\tFN\\t2\\n\");\t\t\t\t\\\n+  fprintf ((STREAM), \"__f3\\tFN\\t3\\n\");\t\t\t\t\\\n+  fprintf ((STREAM), \"__f4\\tFN\\t4\\n\");\t\t\t\t\\\n+  fprintf ((STREAM), \"__f5\\tFN\\t5\\n\");\t\t\t\t\\\n+  fprintf ((STREAM), \"__f6\\tFN\\t6\\n\");\t\t\t\t\\\n+  fprintf ((STREAM), \"__f7\\tFN\\t7\\n\");\t\t\t\t\\\n+  text_section ();\t\t\t\t\t\t\\\n+}\n+\n+/* Some systems use __main in a way incompatible with its use in gcc, in these\n+   cases use the macros NAME__MAIN to give a quoted symbol and SYMBOL__MAIN to\n+   give the same symbol without quotes for an alternative entry point.  You\n+   must define both, or niether. */\n+#define NAME__MAIN \"__gccmain\"\n+#define SYMBOL__MAIN __gccmain\n+\n+#define ASM_FILE_END(STREAM)\t\t\\\n+do\t\t\t\t\t\\\n+{\t\t\t\t\t\\\n+  if (flag_pic)\t\t\t\t\\\n+    aof_dump_pic_table (STREAM);\t\\\n+  aof_dump_imports (STREAM);\t\t\\\n+  fputs (\"\\tEND\\n\", (STREAM));\t\t\\\n+} while (0);\n+\n+#define ASM_IDENTIFY_GCC(STREAM) fputs (\"|gcc2_compiled.|\\n\", (STREAM))\n+\n+#define ASM_COMMENT_START \";\"\n+\n+#define ASM_APP_ON \"\"\n+\n+#define ASM_APP_OFF \"\"\n+\n+#define ASM_OUTPUT_LONG_DOUBLE(STREAM,VALUE) \\\n+  ASM_OUTPUT_DOUBLE((STREAM),(VALUE))\n+\n+#define ASM_OUTPUT_DOUBLE(STREAM,VALUE)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  char dstr[30];\t\t\t\t\t\t\\\n+  long l[2];\t\t\t\t\t\t\t\\\n+  REAL_VALUE_TO_TARGET_DOUBLE ((VALUE), l);\t\t\t\\\n+  REAL_VALUE_TO_DECIMAL ((VALUE), \"%.14g\", dstr);\t\t\\\n+  fprintf ((STREAM), \"\\tDCD &%lx, &%lx\\t%s double %s\\n\",\t\\\n+\t   l[0], l[1], ASM_COMMENT_START, dstr);\t\t\\\n+} while (0)\n+\n+#define ASM_OUTPUT_FLOAT(STREAM,VALUE)\t\t\t\\\n+do {\t\t\t\t\t\t\t\\\n+  char dstr[30];\t\t\t\t\t\\\n+  long l;\t\t\t\t\t\t\\\n+  REAL_VALUE_TO_TARGET_SINGLE ((VALUE), l);\t\t\\\n+  REAL_VALUE_TO_DECIMAL ((VALUE), \"%.7g\", dstr);\t\\\n+  fprintf ((STREAM), \"\\tDCD &%lx\\t%s double %s\\n\",\t\\\n+\t   l, ASM_COMMENT_START, dstr);\t\t\t\\\n+} while (0)\n+\n+#define ASM_OUTPUT_INT(STREAM,VALUE)\t\t\\\n+  (fprintf ((STREAM), \"\\tDCD\\t\"),\t\t\\\n+   output_addr_const ((STREAM), (VALUE)),\t\\\n+   fputc ('\\n', (STREAM)))\n+\n+#define ASM_OUTPUT_SHORT(STREAM,VALUE)\t\t\\\n+  (fprintf ((STREAM), \"\\tDCW\\t\"),\t\t\\\n+   output_addr_const ((STREAM), (VALUE)),\t\\\n+   fputc ('\\n', (STREAM)))\n+\n+#define ASM_OUTPUT_CHAR(STREAM,VALUE)\t\t\\\n+  (fprintf ((STREAM), \"\\tDCB\\t\"),\t\t\\\n+   output_addr_const ((STREAM), (VALUE)),\t\\\n+   fputc ('\\n', (STREAM)))\n+\n+#define ASM_OUTPUT_BYTE(STREAM,VALUE)\t\t\\\n+  fprintf ((STREAM), \"\\tDCB\\t%d\\n\", (VALUE))\n+\n+#define ASM_OUTPUT_ASCII(STREAM,PTR,LEN)\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  int i;\t\t\t\t\t\t\\\n+  char *ptr = (PTR);\t\t\t\t\t\\\n+  fprintf ((STREAM), \"\\tDCB\");\t\t\t\t\\\n+  for (i = 0; i < (LEN); i++)\t\t\t\t\\\n+    fprintf ((STREAM), \" &%02x%s\", \t\t\t\\\n+\t     (unsigned ) *(ptr++),\t\t\t\\\n+\t     (i + 1 < (LEN)\t\t\t\t\\\n+\t      ? ((i & 3) == 3 ? \"\\n\\tDCB\" : \",\")\t\\\n+\t      : \"\\n\"));\t\t\t\t\t\\\n+}\n+\n+#define IS_ASM_LOGICAL_LINE_SEPARATOR(C) ((C) == '\\n')\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* Output of Uninitialized Variables */\n+\n+#define ASM_OUTPUT_COMMON(STREAM,NAME,SIZE,ROUNDED)\t\t\\\n+  (fprintf ((STREAM), \"\\tAREA \"),\t\t\t\t\\\n+   assemble_name ((STREAM), (NAME)),\t\t\t\t\\\n+   fprintf ((STREAM), \", DATA, COMMON\\n\\t%% %d\\t%s size=%d\\n\",\t\\\n+\t    (ROUNDED), ASM_COMMENT_START, SIZE))\n+\n+#define ASM_OUTPUT_LOCAL(STREAM,NAME,SIZE,ROUNDED)\t\\\n+   (zero_init_section (),\t\t\t\t\\\n+    assemble_name ((STREAM), (NAME)),\t\t\t\\\n+    fprintf ((STREAM), \"\\n\"),\t\t\t\t\\\n+    fprintf ((STREAM), \"\\t%% %d\\t%s size=%d\\n\",\t\t\\\n+\t     (ROUNDED), ASM_COMMENT_START, SIZE))\n+\n+/* Output and Generation of Labels */\n+\n+extern int arm_main_function;\n+\n+#define ASM_GLOBALIZE_LABEL(STREAM,NAME)\t\t\\\n+do {\t\t\t\t\t\t\t\\\n+  fprintf ((STREAM), \"\\tEXPORT\\t\");\t\t\t\\\n+  assemble_name ((STREAM), (NAME));\t\t\t\\\n+  fputc ('\\n', (STREAM));\t\t\t\t\\\n+  if ((NAME)[0] == 'm' && ! strcmp ((NAME), \"main\"))\t\\\n+    arm_main_function = 1;\t\t\t\t\\\n+} while (0)\n+\n+#define ARM_OUTPUT_LABEL(STREAM,NAME)\t\\\n+do {\t\t\t\t\t\\\n+  assemble_name (STREAM,NAME);\t\t\\\n+  fputs (\"\\n\", STREAM);\t\t\t\\\n+} while (0)\n+\n+#define ASM_DECLARE_FUNCTION_NAME(STREAM,NAME,DECL)\t\\\n+{\t\t\t\t\t\t\t\\\n+  if (output_bytecode)\t\t\t\t\t\\\n+    BC_OUTPUT_LABEL (STREAM, NAME);\t\t\t\\\n+  else\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      ASM_OUTPUT_LABEL (STREAM, NAME);\t\t\t\\\n+      if (! TREE_PUBLIC (DECL))\t\t\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  fputs (\"\\tKEEP \", STREAM);\t\t\t\\\n+\t  ASM_OUTPUT_LABEL (STREAM, NAME);\t\t\\\n+\t}\t\t\t\t\t\t\\\n+      aof_delete_import ((NAME));\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+}\n+\n+#define ASM_DECLARE_OBJECT_NAME(STREAM,NAME,DECL) \\\n+{\t\t\t\t\t\t\\\n+  if (output_bytecode)\t\t\t\t\\\n+    BC_OUTPUT_LABEL (STREAM, NAME);\t\t\\\n+  else\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      ASM_OUTPUT_LABEL (STREAM, NAME);\t\t\\\n+      if (! TREE_PUBLIC (DECL))\t\t\t\\\n+\t{\t\t\t\t\t\\\n+\t  fputs (\"\\tKEEP \", STREAM);\t\t\\\n+\t  ASM_OUTPUT_LABEL (STREAM, NAME);\t\\\n+\t}\t\t\t\t\t\\\n+      aof_delete_import ((NAME));\t\t\\\n+    }\t\t\t\t\t\t\\\n+}\n+\n+#define ASM_OUTPUT_EXTERNAL(STREAM,DECL,NAME)\t\\\n+ aof_add_import ((NAME))\n+\n+#define ASM_OUTPUT_EXTERNAL_LIBCALL(STREAM,SYMREF)\t\\\n+ (fprintf ((STREAM), \"\\tIMPORT\\t\"),\t\t\t\\\n+  assemble_name ((STREAM), XSTR ((SYMREF), 0)),\t\t\\\n+  fputc ('\\n', (STREAM)))\n+\n+#define ASM_OUTPUT_LABELREF(STREAM,NAME)\t\\\n+  fprintf ((STREAM), \"|%s|\", NAME)\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(STRING,PREFIX,NUM)\t\\\n+  sprintf ((STRING), \"*|%s..%d|\", (PREFIX), (NUM))\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTVAR,NAME,NUMBER)\t\\\n+ ((OUTVAR) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+  sprintf ((OUTVAR), \"%s.%d\", (NAME), (NUMBER)))\n+\n+/* How initialization functions are handled */\n+\n+#define CTORS_SECTION_ASM_OP \"AREA\\t|C$$gnu_ctorsvec|, DATA, READONLY\"\n+#define DTORS_SECTION_ASM_OP \"AREA\\t|C$$gnu_dtorsvec|, DATA, READONLY\"\n+\n+#define ASM_OUTPUT_CONSTRUCTOR(STREAM,NAME)\t\\\n+do {\t\t\t\t\t\t\\\n+  ctor_section ();\t\t\t\t\\\n+  fprintf ((STREAM), \"\\tDCD\\t\");\t\t\\\n+  assemble_name ((STREAM), (NAME));\t\t\\\n+  fputc ('\\n', (STREAM));\t\t\t\\\n+} while (0);\n+\n+#define ASM_OUTPUT_DESTRUCTOR(STREAM,NAME)\t\\\n+do {\t\t\t\t\t\t\\\n+  dtor_section ();\t\t\t\t\\\n+  fprintf ((STREAM), \"\\tDCD\\t\");\t\t\\\n+  assemble_name ((STREAM), (NAME));\t\t\\\n+  fputc ('\\n', (STREAM));\t\t\t\\\n+} while (0);\n+\n+/* Output of Assembler Instructions */\n+\n+#define REGISTER_NAMES\t\t\t\\\n+{\t\t\t\t\t\\\n+  \"a1\", \"a2\", \"a3\", \"a4\",\t\\\n+  \"v1\", \"v2\", \"v3\", \"v4\",\t\\\n+  \"v5\", \"v6\", \"sl\", \"fp\",\t\\\n+  \"ip\", \"sp\", \"lr\", \"pc\",\t\\\n+  \"f0\", \"f1\", \"f2\", \"f3\",\t\\\n+  \"f4\", \"f5\", \"f6\", \"f7\",\t\\\n+  \"cc\", \"sfp\", \"afp\"\t\t\\\n+}\n+\n+#define ADDITIONAL_REGISTER_NAMES\t\t\\\n+{\t\t\t\t\t\t\\\n+  {\"r0\", 0}, {\"a1\", 0},\t\t\t\t\\\n+  {\"r1\", 1}, {\"a2\", 1},\t\t\t\t\\\n+  {\"r2\", 2}, {\"a3\", 2},\t\t\t\t\\\n+  {\"r3\", 3}, {\"a4\", 3},\t\t      \t\t\\\n+  {\"r4\", 4}, {\"v1\", 4},\t\t\t\t\\\n+  {\"r5\", 5}, {\"v2\", 5},\t\t\t\t\\\n+  {\"r6\", 6}, {\"v3\", 6},\t\t\t\t\\\n+  {\"r7\", 7}, {\"wr\", 7},\t\t\t\t\\\n+  {\"r8\", 8}, {\"v5\", 8},\t\t\t\t\\\n+  {\"r9\", 9}, {\"v6\", 9},\t\t\t\t\\\n+  {\"r10\", 10}, {\"sl\", 10}, {\"v7\", 10},\t\t\\\n+  {\"r11\", 11}, {\"fp\", 11},\t\t\t\\\n+  {\"r12\", 12}, {\"ip\", 12}, \t\t\t\\\n+  {\"r13\", 13}, {\"sp\", 13}, \t\t\t\\\n+  {\"r14\", 14}, {\"lr\", 14},\t\t\t\\\n+  {\"r15\", 15}, {\"pc\", 15}\t\t\t\\\n+}\n+\n+#define REGISTER_PREFIX \"__\"\n+#define USER_LABEL_PREFIX \"\"\n+#define LOCAL_LABEL_PREFIX \"\"\n+\n+/* Output of Dispatch Tables */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM,VALUE,REL)\t\t\\\n+  fprintf ((STREAM), \"\\tb\\t|L..%d|\\n\", (VALUE))\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM,VALUE)\t\\\n+  fprintf ((STREAM), \"\\tDCD\\t|L..%d|\\n\", (VALUE))\n+\n+/* A label marking the start of a jump table is a data label. */\n+#define ASM_OUTPUT_CASE_LABEL(STREAM,PREFIX,NUM,TABLE)\t\\\n+  fprintf ((STREAM), \"\\tALIGN\\n|%s..%d|\\n\", (PREFIX), (NUM))\n+\n+/* Assembler Commands for Alignment */\n+\n+#define ASM_OUTPUT_SKIP(STREAM,NBYTES)\t\t\\\n+ fprintf ((STREAM), \"\\t%%\\t%d\\n\", (NBYTES))\n+\n+#define ASM_OUTPUT_ALIGN(STREAM,POWER)\t\t\t\\\n+do {\t\t\t\t\t\t\t\\\n+  register int amount = 1 << (POWER);\t\t\t\\\n+  if (amount == 2)\t\t\t\t\t\\\n+    fprintf ((STREAM), \"\\tALIGN 2\\n\");\t\t\t\\\n+  else if (amount == 4)\t\t\t\t\t\\\n+    fprintf ((STREAM), \"\\tALIGN\\n\");\t\t\t\\\n+  else\t\t\t\t\t\t\t\\\n+    fprintf ((STREAM), \"\\tALIGN %d\\n\", amount);\t\t\\\n+} while (0)\n+\n+#include \"arm/arm.h\"\n+\n+#undef DBX_DEBUGGING_INFO"}, {"sha": "7a4f29fffb60d0007be11b337ab0f9500d6b3609", "filename": "gcc/config/arm/aout.h", "status": "added", "additions": 264, "deletions": 0, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb7806b3797b39b4931aa570e95ee056381dc0f/gcc%2Fconfig%2Farm%2Faout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb7806b3797b39b4931aa570e95ee056381dc0f/gcc%2Fconfig%2Farm%2Faout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faout.h?ref=9fb7806b3797b39b4931aa570e95ee056381dc0f", "patch": "@@ -0,0 +1,264 @@\n+/* Definitions of target machine for GNU compiler, for ARM with a.out\n+   Copyright (C) 1995 Free Software Foundation, Inc.\n+   Contributed by Richard Earnshaw (rearnsha@armltd.co.uk)\n+   \n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#ifndef ARM_OS_NAME\n+#define ARM_OS_NAME \"(generic)\"\n+#endif\n+\n+/* The text to go at the start of the assembler file */\n+#define ASM_FILE_START(STREAM)\t\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  extern char *version_string;\t\t\t\t\t\t  \\\n+  fprintf (STREAM,\"%s Generated by gcc %s for ARM/%s\\n\",\t\t  \\\n+\t   ASM_COMMENT_START, version_string, ARM_OS_NAME);\t\t  \\\n+  fprintf (STREAM,\"%srfp\\t.req\\t%sr9\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n+  fprintf (STREAM,\"%ssl\\t.req\\t%sr10\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n+  fprintf (STREAM,\"%sfp\\t.req\\t%sr11\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n+  fprintf (STREAM,\"%sip\\t.req\\t%sr12\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n+  fprintf (STREAM,\"%ssp\\t.req\\t%sr13\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n+  fprintf (STREAM,\"%slr\\t.req\\t%sr14\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n+  fprintf (STREAM,\"%spc\\t.req\\t%sr15\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n+}\n+\n+#define ASM_APP_ON  \"\"\n+#define ASM_APP_OFF  \"\"\n+\n+/* Switch to the text or data segment.  */\n+#define TEXT_SECTION_ASM_OP  \".text\"\n+#define DATA_SECTION_ASM_OP  \".data\"\n+\n+#define REGISTER_PREFIX \"\"\n+#define USER_LABEL_PREFIX \"_\"\n+#define LOCAL_LABEL_PREFIX \"\"\n+\n+/* The assembler's names for the registers.  */\n+#ifndef REGISTER_NAMES\n+#define REGISTER_NAMES  \\\n+{\t\t\t\t                   \\\n+  \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",  \\\n+  \"r8\", \"r9\", \"sl\", \"fp\", \"ip\", \"sp\", \"lr\", \"pc\",  \\\n+  \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\",  \\\n+  \"cc\", \"sfp\", \"afp\"\t\t\t\t   \\\n+}\n+#endif\n+\n+#ifndef ADDITIONAL_REGISTER_NAMES\n+#define ADDITIONAL_REGISTER_NAMES\t\t\\\n+{\t\t\t\t\t\t\\\n+  {\"a1\", 0},\t\t\t\t\t\\\n+  {\"a2\", 1},\t\t\t\t\t\\\n+  {\"a3\", 2},\t\t\t\t\t\\\n+  {\"a4\", 3},\t\t\t\t\t\\\n+  {\"v1\", 4},\t\t\t\t\t\\\n+  {\"v2\", 5},\t\t\t\t\t\\\n+  {\"v3\", 6},\t\t\t\t\t\\\n+  {\"v4\", 7},\t\t\t\t\t\\\n+  {\"v5\", 8},\t\t\t\t\t\\\n+  {\"v6\", 9},\t\t\t\t\t\\\n+  {\"rfp\", 9}, /* Gcc used to call it this */\t\\\n+  {\"sb\", 9},\t\t\t\t\t\\\n+  {\"v7\", 10},\t\t\t\t\t\\\n+  {\"r10\", 10},\t/* sl */\t\t\t\\\n+  {\"r11\", 11},\t/* fp */\t\t\t\\\n+  {\"r12\", 12},\t/* ip */\t\t\t\\\n+  {\"r13\", 13},\t/* sp */\t\t\t\\\n+  {\"r14\", 14},\t/* lr */\t\t\t\\\n+  {\"r15\", 15}\t/* pc */\t\t\t\\\n+}\n+#endif\n+\n+/* Arm Assembler barfs on dollars */\n+#define DOLLARS_IN_IDENTIFIERS 0\n+\n+#define NO_DOLLAR_IN_LABEL\n+\n+/* DBX register number for a given compiler register number */\n+#define DBX_REGISTER_NUMBER(REGNO)  (REGNO)\n+\n+/* Generate DBX debugging information.  riscix.h will undefine this because\n+   the native assembler does not support stabs. */\n+#define DBX_DEBUGGING_INFO  1\n+\n+/* Acorn dbx moans about continuation chars, so don't use any.  */\n+#ifndef DBX_CONTIN_LENGTH\n+#define DBX_CONTIN_LENGTH  0\n+#endif\n+\n+/* Output a source filename for the debugger. RISCiX dbx insists that the\n+   ``desc'' field is set to compiler version number >= 315 (sic).  */\n+#define DBX_OUTPUT_MAIN_SOURCE_FILENAME(STREAM,NAME) \t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fprintf (STREAM, \".stabs \\\"%s\\\",%d,0,315,%s\\n\", (NAME), N_SO,\t\t\\\n+\t   &ltext_label_name[1]);\t\t\t\t\t\\\n+  text_section ();\t\t\t\t\t\t\t\\\n+  ASM_OUTPUT_INTERNAL_LABEL (STREAM, \"Ltext\", 0);\t\t\t\\\n+} while (0)\n+  \n+/* Output a function label definition.  */\n+#define ASM_DECLARE_FUNCTION_NAME(STREAM,NAME,DECL) \\\n+    ASM_OUTPUT_LABEL(STREAM, NAME)\n+\n+#define ARM_OUTPUT_LABEL(STREAM,NAME)\t\\\n+do {\t\t\t\t\t\\\n+  assemble_name (STREAM,NAME);\t\t\\\n+  fputs (\":\\n\", STREAM);\t\t\\\n+} while (0)\n+\n+/* Output a globalising directive for a label.  */\n+#define ASM_GLOBALIZE_LABEL(STREAM,NAME)  \\\n+  (fprintf (STREAM, \"\\t.global\\t\"),\t  \\\n+   assemble_name (STREAM, NAME),\t  \\\n+   fputc ('\\n',STREAM))                   \\\n+\n+/* Output a reference to a label.  */\n+#define ASM_OUTPUT_LABELREF(STREAM,NAME)  \\\n+  fprintf (STREAM, \"%s%s\", USER_LABEL_PREFIX, NAME)\n+\n+/* Make an internal label into a string.  */\n+#define ASM_GENERATE_INTERNAL_LABEL(STRING, PREFIX, NUM)  \\\n+  sprintf (STRING, \"*%s%d\", PREFIX, NUM)\n+\n+/* Nothing special is done about jump tables */\n+/* #define ASM_OUTPUT_CASE_LABEL(STREAM,PREFIX,NUM,TABLE)   */\n+/* #define ASM_OUTPUT_CASE_END(STREAM,NUM,TABLE)\t    */\n+\n+/* Construct a private name.  */\n+#define ASM_FORMAT_PRIVATE_NAME(OUTVAR,NAME,NUMBER)  \\\n+  ((OUTVAR) = (char *) alloca (strlen (NAME) + 10),  \\\n+   sprintf ((OUTVAR), \"%s.%d\", (NAME), (NUMBER)))\n+\n+/* Output an element of a dispatch table.  */\n+#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM,VALUE)  \\\n+   fprintf (STREAM, \"\\t.word\\tL%d\\n\", VALUE)\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM,VALUE,REL)  \\\n+   fprintf (STREAM, \"\\tb\\tL%d\\n\", (VALUE))\n+\n+/* Output various types of constants.  For real numbers we output hex, with\n+   a comment containing the \"human\" value, this allows us to pass NaN's which\n+   the riscix assembler doesn't understand (it also makes cross-assembling\n+   less likely to fail). */\n+\n+#define ASM_OUTPUT_LONG_DOUBLE(STREAM,VALUE)\t\t\t\t\\\n+do { char dstr[30];\t\t\t\t\t\t\t\\\n+     long l[3];\t\t\t\t\t\t\t\t\\\n+     arm_increase_location (12);\t\t\t\t\t\\\n+     REAL_VALUE_TO_TARGET_LONG_DOUBLE (VALUE, l);\t\t\t\\\n+     REAL_VALUE_TO_DECIMAL (VALUE, \"%.20g\", dstr);\t\t\t\\\n+     fprintf (STREAM, \"\\t.long 0x%lx,0x%lx,0x%lx\\t%s long double %s\\n\", \\\n+\t      l[0], l[1], l[2], ASM_COMMENT_START, dstr);\t\t\\\n+   } while (0)\n+\n+    \n+#define ASM_OUTPUT_DOUBLE(STREAM, VALUE)  \t\t\t\t\\\n+do { char dstr[30];\t\t\t\t\t\t\t\\\n+     long l[2];\t\t\t\t\t\t\t\t\\\n+     arm_increase_location (8);\t\t\t\t\t\t\\\n+     REAL_VALUE_TO_TARGET_DOUBLE (VALUE, l);\t\t\t\t\\\n+     REAL_VALUE_TO_DECIMAL (VALUE, \"%.14g\", dstr);\t\t\t\\\n+     fprintf (STREAM, \"\\t.long 0x%lx, 0x%lx\\t%s double %s\\n\", l[0],\t\\\n+\t      l[1], ASM_COMMENT_START, dstr);\t\t\t\t\\\n+   } while (0)\n+\n+#define ASM_OUTPUT_FLOAT(STREAM, VALUE)\t\t\t\t\t\\\n+do { char dstr[30];\t\t\t\t\t\t\t\\\n+     long l;\t\t\t\t\t\t\t\t\\\n+     arm_increase_location (4);\t\t\t\t\t\t\\\n+     REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);\t\t\t\t\\\n+     REAL_VALUE_TO_DECIMAL (VALUE, \"%.7g\", dstr);\t\t\t\\\n+     fprintf (STREAM, \"\\t.word 0x%lx\\t%s float %s\\n\", l,\t\t\\\n+\t      ASM_COMMENT_START, dstr);\t\t\t\t\t\\\n+   } while (0);\n+\n+#define ASM_OUTPUT_INT(STREAM, EXP)\t\\\n+  (fprintf (STREAM, \"\\t.word\\t\"),\t\\\n+   output_addr_const (STREAM, (EXP)),\t\\\n+   arm_increase_location (4),\t\t\\\n+   fputc ('\\n', STREAM))\n+\n+#define ASM_OUTPUT_SHORT(STREAM, EXP)  \\\n+  (fprintf (STREAM, \"\\t.short\\t\"),     \\\n+   output_addr_const (STREAM, (EXP)),  \\\n+   arm_increase_location (2),          \\\n+   fputc ('\\n', STREAM))\n+\n+#define ASM_OUTPUT_CHAR(STREAM, EXP)  \\\n+  (fprintf (STREAM, \"\\t.byte\\t\"),      \\\n+   output_addr_const (STREAM, (EXP)),  \\\n+   arm_increase_location (1),          \\\n+   fputc ('\\n', STREAM))\n+\n+#define ASM_OUTPUT_BYTE(STREAM, VALUE)  \\\n+  (fprintf (STREAM, \"\\t.byte\\t%d\\n\", VALUE),  \\\n+   arm_increase_location (1))\n+\n+#define ASM_OUTPUT_ASCII(STREAM, PTR, LEN)  \\\n+  output_ascii_pseudo_op ((STREAM), (unsigned char *)(PTR), (LEN))\n+\n+/* Output a gap.  In fact we fill it with nulls.  */\n+#define ASM_OUTPUT_SKIP(STREAM, NBYTES)  \\\n+  (arm_increase_location (NBYTES),              \\\n+   fprintf (STREAM, \"\\t.space\\t%d\\n\", NBYTES))\n+\n+/* Align output to a power of two.  Horrible /bin/as.  */\n+#define ASM_OUTPUT_ALIGN(STREAM, POWER)  \\\n+  do                                                           \\\n+    {                                                          \\\n+      register int amount = 1 << (POWER);                      \\\n+      extern int arm_text_location;\t\t\t       \\\n+                                                               \\\n+      if (amount == 2)                                         \\\n+\tfprintf (STREAM, \"\\t.even\\n\");                         \\\n+      else                                                     \\\n+\tfprintf (STREAM, \"\\t.align\\t%d\\n\", amount - 4);        \\\n+                                                               \\\n+      if (in_text_section ())                                  \\\n+\tarm_text_location = ((arm_text_location + amount - 1)  \\\n+\t\t\t     & ~(amount - 1));                 \\\n+    } while (0)\n+\n+/* Output a common block */\n+#define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED)  \t\t\\\n+  (fprintf (STREAM, \"\\t.comm\\t\"), \t\t     \t\t\t\\\n+   assemble_name ((STREAM), (NAME)),\t\t     \t\t\t\\\n+   fprintf(STREAM, \", %d\\t%s %d\\n\", ROUNDED, ASM_COMMENT_START, SIZE))\n+\n+/* Output a local common block.  /bin/as can't do this, so hack a `.space' into\n+   the bss segment.  Note that this is *bad* practice.  */\n+#define ASM_OUTPUT_LOCAL(STREAM,NAME,SIZE,ROUNDED)  \\\n+  output_lcomm_directive (STREAM, NAME, SIZE, ROUNDED)\n+\n+/* Output a source line for the debugger.  */\n+/* #define ASM_OUTPUT_SOURCE_LINE(STREAM,LINE) */\n+\n+/* Output a #ident directive.  */\n+#define ASM_OUTPUT_IDENT(STREAM,STRING)  \\\n+  fprintf (STREAM,\"- - - ident %s\\n\",STRING)\n+\n+/* The assembler's parentheses characters.  */\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+#ifndef ASM_COMMENT_START\n+#define ASM_COMMENT_START \"@\"\n+#endif\n+\n+#include \"arm/arm.h\""}, {"sha": "cb13a33381c68632bc5a3cdd1ab038af11808fe6", "filename": "gcc/config/arm/semiaof.h", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb7806b3797b39b4931aa570e95ee056381dc0f/gcc%2Fconfig%2Farm%2Fsemiaof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb7806b3797b39b4931aa570e95ee056381dc0f/gcc%2Fconfig%2Farm%2Fsemiaof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fsemiaof.h?ref=9fb7806b3797b39b4931aa570e95ee056381dc0f", "patch": "@@ -0,0 +1,49 @@\n+/* Definitions of target machine for GNU compiler.  ARM on semi-hosted platform\n+   AOF Syntax assembler.\n+   Copyright (C) 1995 Free Software Foundation, Inc.\n+   Contributed by Richard Earnshaw (richard.earnshaw@armltd.co.uk)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#define CPP_PREDEFINES \\\n+    \"-Darm -Dsemi -Acpu(arm) -Amachine(arm)\"\n+\n+#define CPP_SPEC \"%{m6:-D__arm6__} \\\n+%{mcpu-*:-D__%*} \\\n+%{mcpu=*:-D__%*} \\\n+%{mapcs-32:-D__APCS_32__ -U__APCS_26__} \\\n+%{mapcs-26:-D__APCS_26__ -U__APCS_32__} \\\n+%{!mapcs-32: %{!mapcs-26:-D__APCS_32__}} \\\n+%{msoft-float:-D__SOFTFP__} \\\n+%{mhard-float:-U__SOFTFP__} \\\n+%{!mhard-float: %{!msoft-float:-U__SOFTFP__}} \\\n+\"\n+\n+#define ASM_SPEC \"%{g -g} -arch 4 \\\n+-apcs 3%{mapcs-32:/32bit}%{mapcs-26:/26bit}%{!mapcs-26:%{!macps-32:/32bit}}\"\n+\n+#define LIB_SPEC \"%{Eb: armlib_h.32b%s}%{!Eb: armlib_h.32l%s}\"\n+\n+#define TARGET_VERSION fputs (\" (ARM/semi-hosted)\", stderr);\n+\n+#define TARGET_DEFAULT ARM_FLAG_APCS_32\n+\n+/* The Norcroft C library defines size_t as \"unsigned int\" */\n+#define SIZE_TYPE \"unsigned int\"\n+\n+#include \"arm/aof.h\""}, {"sha": "6f1dfca081c25df5425db953699e310572e23f1e", "filename": "gcc/config/arm/t-semiaof", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb7806b3797b39b4931aa570e95ee056381dc0f/gcc%2Fconfig%2Farm%2Ft-semiaof", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb7806b3797b39b4931aa570e95ee056381dc0f/gcc%2Fconfig%2Farm%2Ft-semiaof", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-semiaof?ref=9fb7806b3797b39b4931aa570e95ee056381dc0f", "patch": "@@ -0,0 +1,63 @@\n+OLDCC = armcc -w\n+# Don't build enquire\n+ENQUIRE=\n+CROSS_LIBGCC1 = libgcc1-aof.a\n+LIBGCC2 = libgcc2-aof.a\n+LIBGCC = libgcc-aof.a\n+LIBGCC2_CFLAGS = -O2 -fomit-frame-pointer\n+LIBGCC1_TEST = #libgcc1-atest\n+EXTRA_PARTS = crtbegin.o crtend.o\n+\n+# Rule to build libgcc1.a and libgcc2.a and libgcc.a, since the librarian \n+# for the ARM tools is somewhat quirky, and needs a special rule to use it.\n+libgcc1-aof.a: libgcc1.c $(CONFIG_H) config.status\n+\t-rm -rf tmplib libgcc1.a libgcc1-aof.a tmplibgcc1.a\n+\tmkdir tmplib\n+\tfor name in $(LIB1FUNCS); \\\n+\tdo \\\n+\t  echo $${name}; \\\n+\t  rm -f $${name}$(objext); \\\n+\t  $(OLDCC) $(CCLIBFLAGS) $(INCLUDES) -c -DL$${name} $(srcdir)/libgcc1.c; \\\n+\t  if [ $$? -eq 0 ] ; then true; else exit 1; fi; \\\n+\t  mv libgcc1$(objext) tmplib/$${name}$(objext); \\\n+\tdone\n+\t(cd tmplib; \\\n+\t armlib -c tmplibgcc1.a *; \\\n+\t mv tmplibgcc1.a ..)\n+\tmv tmplibgcc1.a libgcc1-aof.a\n+\trm -rf tmplib\n+\n+libgcc2-aof.a: libgcc2.c libgcc2.ready $(CONFIG_H) $(LIB2FUNCS_EXTRA) \\\n+   machmode.h longlong.h gbl-ctors.h config.status\n+\t-rm -f tmplibgcc2.a\n+\t-rm -rf tmplib\n+\tmkdir tmplib\n+\tfor name in $(LIB2FUNCS); \\\n+\tdo \\\n+\t  echo $${name}; \\\n+\t  $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(INCLUDES) -c -DL$${name} \\\n+\t      $(srcdir)/libgcc2.c -o tmplib/$${name}$(objext); \\\n+\t  if [ $$? -eq 0 ] ; then true; else exit 1; fi; \\\n+\tdone\n+\t(cd tmplib; \\\n+\t armlib -c tmplibgcc2.a *; \\\n+\t mv tmplibgcc2.a ..)\n+\tmv tmplibgcc2.a libgcc2-aof.a\n+\trm -rf tmplib\n+\n+# Combine the various libraries into a single library, libgcc.a.\n+libgcc-aof.a: $(CROSS_LIBGCC1) $(LIBGCC2)\n+\t-rm -rf tmplibgcc.a libgcc.a tmpcopy libgcc-aof.a\n+\tmkdir tmpcopy\n+\t(cd tmpcopy; armlib -e ../$(LIBGCC1) \\*)\n+\t-(cd tmpcopy; chmod +w * > /dev/null 2>&1)\n+\t(cd tmpcopy; armlib -e ../$(LIBGCC2) \\*)\n+\t(cd tmpcopy; armlib -co ../tmplibgcc.a *$(objext))\n+\trm -rf tmpcopy\n+\tmv tmplibgcc.a libgcc.a\n+\tln libgcc.a libgcc-aof.a\n+\n+libgcc1-atest: libgcc1-test.o native $(GCC_PARTS) $(EXTRA_PARTS)\n+\t@echo \"Testing libgcc1.  Ignore linker warning messages.\"\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) libgcc1-test.o -o libgcc1-test \\\n+\t-v"}]}