{"sha": "6bfa5aac87329dfa40b16181408237e9d0df764e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJmYTVhYWM4NzMyOWRmYTQwYjE2MTgxNDA4MjM3ZTlkMGRmNzY0ZQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2002-07-01T20:59:00Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2002-07-01T20:59:00Z"}, "message": "re PR rtl-optimization/4046 (redundant conditional branch)\n\n\n\tPR opt/4046\n\t* fold-const.c (fold) [COND_EXPR]: Simplify A ? 0 : 1 to !A,\n\tA ? B : 0 to A && B and A ? B : 1 into !A || B if both A and\n\tB are truth values.\n\nFrom-SVN: r55153", "tree": {"sha": "ede6758e3c42f784cd014a563a92268147d976cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ede6758e3c42f784cd014a563a92268147d976cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6bfa5aac87329dfa40b16181408237e9d0df764e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bfa5aac87329dfa40b16181408237e9d0df764e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bfa5aac87329dfa40b16181408237e9d0df764e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bfa5aac87329dfa40b16181408237e9d0df764e/comments", "author": null, "committer": null, "parents": [{"sha": "9a5c1b9db14b269edfea010febc1ae3066190900", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a5c1b9db14b269edfea010febc1ae3066190900", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a5c1b9db14b269edfea010febc1ae3066190900"}], "stats": {"total": 34, "additions": 34, "deletions": 0}, "files": [{"sha": "013ac5c422ce44d1581b70310b7e02ae7af3b32d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bfa5aac87329dfa40b16181408237e9d0df764e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bfa5aac87329dfa40b16181408237e9d0df764e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6bfa5aac87329dfa40b16181408237e9d0df764e", "patch": "@@ -1,3 +1,10 @@\n+2002-07-01  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR opt/4046\n+\t* fold-const.c (fold) [COND_EXPR]: Simplify A ? 0 : 1 to !A,\n+\tA ? B : 0 to A && B and A ? B : 1 into !A || B if both A and\n+\tB are truth values.\n+\n 2002-07-01  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \t* config/mmix/t-mmix: Eliminate last reference to LIBGCC1_TEST."}, {"sha": "3dafe0afb31115f095a91e97096d33585630f4ec", "filename": "gcc/fold-const.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bfa5aac87329dfa40b16181408237e9d0df764e/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bfa5aac87329dfa40b16181408237e9d0df764e/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=6bfa5aac87329dfa40b16181408237e9d0df764e", "patch": "@@ -7036,6 +7036,14 @@ fold (expr)\n \t  && type == TREE_TYPE (arg0))\n \treturn pedantic_non_lvalue (arg0);\n \n+      /* Convert A ? 0 : 1 to !A.  This prefers the use of NOT_EXPR\n+\t over COND_EXPR in cases such as floating point comparisons.  */\n+      if (integer_zerop (TREE_OPERAND (t, 1))\n+\t  && integer_onep (TREE_OPERAND (t, 2))\n+\t  && truth_value_p (TREE_CODE (arg0)))\n+\treturn pedantic_non_lvalue (convert (type,\n+\t\t\t\t\t     invert_truthvalue (arg0)));\n+\n       /* Look for expressions of the form A & 2 ? 2 : 0.  The result of this\n \t operation is simply A & 2.  */\n \n@@ -7048,6 +7056,25 @@ fold (expr)\n \t\t\t      arg1, 1))\n \treturn pedantic_non_lvalue (convert (type, TREE_OPERAND (arg0, 0)));\n \n+      /* Convert A ? B : 0 into A && B if A and B are truth values.  */\n+      if (integer_zerop (TREE_OPERAND (t, 2))\n+\t  && truth_value_p (TREE_CODE (arg0))\n+\t  && truth_value_p (TREE_CODE (arg1)))\n+\treturn pedantic_non_lvalue (fold (build (TRUTH_ANDIF_EXPR, type,\n+\t\t\t\t\t\t arg0, arg1)));\n+\n+      /* Convert A ? B : 1 into !A || B if A and B are truth values.  */\n+      if (integer_onep (TREE_OPERAND (t, 2))\n+\t  && truth_value_p (TREE_CODE (arg0))\n+\t  && truth_value_p (TREE_CODE (arg1)))\n+\t{\n+\t  /* Only perform transformation if ARG0 is easily inverted.  */\n+\t  tem = invert_truthvalue (arg0);\n+\t  if (TREE_CODE (tem) != TRUTH_NOT_EXPR)\n+\t    return pedantic_non_lvalue (fold (build (TRUTH_ORIF_EXPR, type,\n+\t\t\t\t\t\t     tem, arg1)));\n+\t}\n+\n       return t;\n \n     case COMPOUND_EXPR:"}]}