{"sha": "3906ea1b34ab9967430cd2b9c423815dc532acfe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkwNmVhMWIzNGFiOTk2NzQzMGNkMmI5YzQyMzgxNWRjNTMyYWNmZQ==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.vnet.ibm.com", "date": "2011-06-06T14:27:41Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2011-06-06T14:27:41Z"}, "message": "re PR tree-optimization/46728 (GCC does not generate fmadd for pow (x, 0.75)+y on powerpc)\n\n2011-06-06  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\tPR tree-optimization/46728\n\t* builtins.c (powi_table): Remove.\n\t(powi_lookup_cost): Remove.\n\t(powi_cost): Remove.\n\t(expand_powi_1): Remove.\n\t(expand_powi): Remove.\n\t(expand_builtin_pow_root): Remove.\n\t(expand_builtin_pow): Remove.\n\t(expand_builtin_powi): Eliminate handling of constant exponent.\n\t(expand_builtin): Use expand_builtin_mathfn_2 for BUILT_IN_POW.\n\nFrom-SVN: r174701", "tree": {"sha": "8ffec48de08bd89006e1ec11c236fb0334dcd4d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ffec48de08bd89006e1ec11c236fb0334dcd4d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3906ea1b34ab9967430cd2b9c423815dc532acfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3906ea1b34ab9967430cd2b9c423815dc532acfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3906ea1b34ab9967430cd2b9c423815dc532acfe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3906ea1b34ab9967430cd2b9c423815dc532acfe/comments", "author": {"login": "wschmidt-ibm", "id": 5520937, "node_id": "MDQ6VXNlcjU1MjA5Mzc=", "avatar_url": "https://avatars.githubusercontent.com/u/5520937?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wschmidt-ibm", "html_url": "https://github.com/wschmidt-ibm", "followers_url": "https://api.github.com/users/wschmidt-ibm/followers", "following_url": "https://api.github.com/users/wschmidt-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/wschmidt-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/wschmidt-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wschmidt-ibm/subscriptions", "organizations_url": "https://api.github.com/users/wschmidt-ibm/orgs", "repos_url": "https://api.github.com/users/wschmidt-ibm/repos", "events_url": "https://api.github.com/users/wschmidt-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/wschmidt-ibm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3598cabdae52826b408cc2fdff9982bc2633c730", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3598cabdae52826b408cc2fdff9982bc2633c730", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3598cabdae52826b408cc2fdff9982bc2633c730"}], "stats": {"total": 486, "additions": 14, "deletions": 472}, "files": [{"sha": "d52bde645e3e6b6b0f945b5b9cde8b95d8c5e6a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3906ea1b34ab9967430cd2b9c423815dc532acfe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3906ea1b34ab9967430cd2b9c423815dc532acfe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3906ea1b34ab9967430cd2b9c423815dc532acfe", "patch": "@@ -1,3 +1,16 @@\n+2011-06-06  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\tPR tree-optimization/46728\n+\t* builtins.c (powi_table): Remove.\n+\t(powi_lookup_cost): Remove.\n+\t(powi_cost): Remove.\n+\t(expand_powi_1): Remove.\n+\t(expand_powi): Remove.\n+\t(expand_builtin_pow_root): Remove.\n+\t(expand_builtin_pow): Remove.\n+\t(expand_builtin_powi): Eliminate handling of constant exponent.\n+\t(expand_builtin): Use expand_builtin_mathfn_2 for BUILT_IN_POW.\n+\t\n 2011-06-06  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* cprop.c (local_cprop_pass): Don't set changed for debug insns."}, {"sha": "7b24a0ce70395fac8d23069dbdb8ddc231fc5645", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 472, "changes": 473, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3906ea1b34ab9967430cd2b9c423815dc532acfe/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3906ea1b34ab9967430cd2b9c423815dc532acfe/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=3906ea1b34ab9967430cd2b9c423815dc532acfe", "patch": "@@ -2823,451 +2823,6 @@ expand_builtin_int_roundingfn_2 (tree exp, rtx target)\n   return target;\n }\n \n-/* To evaluate powi(x,n), the floating point value x raised to the\n-   constant integer exponent n, we use a hybrid algorithm that\n-   combines the \"window method\" with look-up tables.  For an\n-   introduction to exponentiation algorithms and \"addition chains\",\n-   see section 4.6.3, \"Evaluation of Powers\" of Donald E. Knuth,\n-   \"Seminumerical Algorithms\", Vol. 2, \"The Art of Computer Programming\",\n-   3rd Edition, 1998, and Daniel M. Gordon, \"A Survey of Fast Exponentiation\n-   Methods\", Journal of Algorithms, Vol. 27, pp. 129-146, 1998.  */\n-\n-/* Provide a default value for POWI_MAX_MULTS, the maximum number of\n-   multiplications to inline before calling the system library's pow\n-   function.  powi(x,n) requires at worst 2*bits(n)-2 multiplications,\n-   so this default never requires calling pow, powf or powl.  */\n-\n-#ifndef POWI_MAX_MULTS\n-#define POWI_MAX_MULTS  (2*HOST_BITS_PER_WIDE_INT-2)\n-#endif\n-\n-/* The size of the \"optimal power tree\" lookup table.  All\n-   exponents less than this value are simply looked up in the\n-   powi_table below.  This threshold is also used to size the\n-   cache of pseudo registers that hold intermediate results.  */\n-#define POWI_TABLE_SIZE 256\n-\n-/* The size, in bits of the window, used in the \"window method\"\n-   exponentiation algorithm.  This is equivalent to a radix of\n-   (1<<POWI_WINDOW_SIZE) in the corresponding \"m-ary method\".  */\n-#define POWI_WINDOW_SIZE 3\n-\n-/* The following table is an efficient representation of an\n-   \"optimal power tree\".  For each value, i, the corresponding\n-   value, j, in the table states than an optimal evaluation\n-   sequence for calculating pow(x,i) can be found by evaluating\n-   pow(x,j)*pow(x,i-j).  An optimal power tree for the first\n-   100 integers is given in Knuth's \"Seminumerical algorithms\".  */\n-\n-static const unsigned char powi_table[POWI_TABLE_SIZE] =\n-  {\n-      0,   1,   1,   2,   2,   3,   3,   4,  /*   0 -   7 */\n-      4,   6,   5,   6,   6,  10,   7,   9,  /*   8 -  15 */\n-      8,  16,   9,  16,  10,  12,  11,  13,  /*  16 -  23 */\n-     12,  17,  13,  18,  14,  24,  15,  26,  /*  24 -  31 */\n-     16,  17,  17,  19,  18,  33,  19,  26,  /*  32 -  39 */\n-     20,  25,  21,  40,  22,  27,  23,  44,  /*  40 -  47 */\n-     24,  32,  25,  34,  26,  29,  27,  44,  /*  48 -  55 */\n-     28,  31,  29,  34,  30,  60,  31,  36,  /*  56 -  63 */\n-     32,  64,  33,  34,  34,  46,  35,  37,  /*  64 -  71 */\n-     36,  65,  37,  50,  38,  48,  39,  69,  /*  72 -  79 */\n-     40,  49,  41,  43,  42,  51,  43,  58,  /*  80 -  87 */\n-     44,  64,  45,  47,  46,  59,  47,  76,  /*  88 -  95 */\n-     48,  65,  49,  66,  50,  67,  51,  66,  /*  96 - 103 */\n-     52,  70,  53,  74,  54, 104,  55,  74,  /* 104 - 111 */\n-     56,  64,  57,  69,  58,  78,  59,  68,  /* 112 - 119 */\n-     60,  61,  61,  80,  62,  75,  63,  68,  /* 120 - 127 */\n-     64,  65,  65, 128,  66, 129,  67,  90,  /* 128 - 135 */\n-     68,  73,  69, 131,  70,  94,  71,  88,  /* 136 - 143 */\n-     72, 128,  73,  98,  74, 132,  75, 121,  /* 144 - 151 */\n-     76, 102,  77, 124,  78, 132,  79, 106,  /* 152 - 159 */\n-     80,  97,  81, 160,  82,  99,  83, 134,  /* 160 - 167 */\n-     84,  86,  85,  95,  86, 160,  87, 100,  /* 168 - 175 */\n-     88, 113,  89,  98,  90, 107,  91, 122,  /* 176 - 183 */\n-     92, 111,  93, 102,  94, 126,  95, 150,  /* 184 - 191 */\n-     96, 128,  97, 130,  98, 133,  99, 195,  /* 192 - 199 */\n-    100, 128, 101, 123, 102, 164, 103, 138,  /* 200 - 207 */\n-    104, 145, 105, 146, 106, 109, 107, 149,  /* 208 - 215 */\n-    108, 200, 109, 146, 110, 170, 111, 157,  /* 216 - 223 */\n-    112, 128, 113, 130, 114, 182, 115, 132,  /* 224 - 231 */\n-    116, 200, 117, 132, 118, 158, 119, 206,  /* 232 - 239 */\n-    120, 240, 121, 162, 122, 147, 123, 152,  /* 240 - 247 */\n-    124, 166, 125, 214, 126, 138, 127, 153,  /* 248 - 255 */\n-  };\n-\n-\n-/* Return the number of multiplications required to calculate\n-   powi(x,n) where n is less than POWI_TABLE_SIZE.  This is a\n-   subroutine of powi_cost.  CACHE is an array indicating\n-   which exponents have already been calculated.  */\n-\n-static int\n-powi_lookup_cost (unsigned HOST_WIDE_INT n, bool *cache)\n-{\n-  /* If we've already calculated this exponent, then this evaluation\n-     doesn't require any additional multiplications.  */\n-  if (cache[n])\n-    return 0;\n-\n-  cache[n] = true;\n-  return powi_lookup_cost (n - powi_table[n], cache)\n-\t + powi_lookup_cost (powi_table[n], cache) + 1;\n-}\n-\n-/* Return the number of multiplications required to calculate\n-   powi(x,n) for an arbitrary x, given the exponent N.  This\n-   function needs to be kept in sync with expand_powi below.  */\n-\n-static int\n-powi_cost (HOST_WIDE_INT n)\n-{\n-  bool cache[POWI_TABLE_SIZE];\n-  unsigned HOST_WIDE_INT digit;\n-  unsigned HOST_WIDE_INT val;\n-  int result;\n-\n-  if (n == 0)\n-    return 0;\n-\n-  /* Ignore the reciprocal when calculating the cost.  */\n-  val = (n < 0) ? -n : n;\n-\n-  /* Initialize the exponent cache.  */\n-  memset (cache, 0, POWI_TABLE_SIZE * sizeof (bool));\n-  cache[1] = true;\n-\n-  result = 0;\n-\n-  while (val >= POWI_TABLE_SIZE)\n-    {\n-      if (val & 1)\n-\t{\n-\t  digit = val & ((1 << POWI_WINDOW_SIZE) - 1);\n-\t  result += powi_lookup_cost (digit, cache)\n-\t\t    + POWI_WINDOW_SIZE + 1;\n-\t  val >>= POWI_WINDOW_SIZE;\n-\t}\n-      else\n-\t{\n-\t  val >>= 1;\n-\t  result++;\n-\t}\n-    }\n-\n-  return result + powi_lookup_cost (val, cache);\n-}\n-\n-/* Recursive subroutine of expand_powi.  This function takes the array,\n-   CACHE, of already calculated exponents and an exponent N and returns\n-   an RTX that corresponds to CACHE[1]**N, as calculated in mode MODE.  */\n-\n-static rtx\n-expand_powi_1 (enum machine_mode mode, unsigned HOST_WIDE_INT n, rtx *cache)\n-{\n-  unsigned HOST_WIDE_INT digit;\n-  rtx target, result;\n-  rtx op0, op1;\n-\n-  if (n < POWI_TABLE_SIZE)\n-    {\n-      if (cache[n])\n-\treturn cache[n];\n-\n-      target = gen_reg_rtx (mode);\n-      cache[n] = target;\n-\n-      op0 = expand_powi_1 (mode, n - powi_table[n], cache);\n-      op1 = expand_powi_1 (mode, powi_table[n], cache);\n-    }\n-  else if (n & 1)\n-    {\n-      target = gen_reg_rtx (mode);\n-      digit = n & ((1 << POWI_WINDOW_SIZE) - 1);\n-      op0 = expand_powi_1 (mode, n - digit, cache);\n-      op1 = expand_powi_1 (mode, digit, cache);\n-    }\n-  else\n-    {\n-      target = gen_reg_rtx (mode);\n-      op0 = expand_powi_1 (mode, n >> 1, cache);\n-      op1 = op0;\n-    }\n-\n-  result = expand_mult (mode, op0, op1, target, 0);\n-  if (result != target)\n-    emit_move_insn (target, result);\n-  return target;\n-}\n-\n-/* Expand the RTL to evaluate powi(x,n) in mode MODE.  X is the\n-   floating point operand in mode MODE, and N is the exponent.  This\n-   function needs to be kept in sync with powi_cost above.  */\n-\n-static rtx\n-expand_powi (rtx x, enum machine_mode mode, HOST_WIDE_INT n)\n-{\n-  rtx cache[POWI_TABLE_SIZE];\n-  rtx result;\n-\n-  if (n == 0)\n-    return CONST1_RTX (mode);\n-\n-  memset (cache, 0, sizeof (cache));\n-  cache[1] = x;\n-\n-  result = expand_powi_1 (mode, (n < 0) ? -n : n, cache);\n-\n-  /* If the original exponent was negative, reciprocate the result.  */\n-  if (n < 0)\n-    result = expand_binop (mode, sdiv_optab, CONST1_RTX (mode),\n-\t\t\t   result, NULL_RTX, 0, OPTAB_LIB_WIDEN);\n-\n-  return result;\n-}\n-\n-/* Fold a builtin function call to pow, powf, or powl into a series of sqrts or\n-   cbrts.  Return NULL_RTX if no simplification can be made or expand the tree\n-   if we can simplify it.  */\n-static rtx\n-expand_builtin_pow_root (location_t loc, tree arg0, tree arg1, tree type,\n-\t\t\t rtx subtarget)\n-{\n-  if (TREE_CODE (arg1) == REAL_CST\n-      && !TREE_OVERFLOW (arg1)\n-      && flag_unsafe_math_optimizations)\n-    {\n-      enum machine_mode mode = TYPE_MODE (type);\n-      tree sqrtfn = mathfn_built_in (type, BUILT_IN_SQRT);\n-      tree cbrtfn = mathfn_built_in (type, BUILT_IN_CBRT);\n-      REAL_VALUE_TYPE c = TREE_REAL_CST (arg1);\n-      tree op = NULL_TREE;\n-\n-      if (sqrtfn)\n-\t{\n-\t  /* Optimize pow (x, 0.5) into sqrt.  */\n-\t  if (REAL_VALUES_EQUAL (c, dconsthalf))\n-\t    op = build_call_nofold_loc (loc, sqrtfn, 1, arg0);\n-\n-\t  /* Don't do this optimization if we don't have a sqrt insn.  */\n-\t  else if (optab_handler (sqrt_optab, mode) != CODE_FOR_nothing)\n-\t    {\n-\t      REAL_VALUE_TYPE dconst1_4 = dconst1;\n-\t      REAL_VALUE_TYPE dconst3_4;\n-\t      SET_REAL_EXP (&dconst1_4, REAL_EXP (&dconst1_4) - 2);\n-\n-\t      real_from_integer (&dconst3_4, VOIDmode, 3, 0, 0);\n-\t      SET_REAL_EXP (&dconst3_4, REAL_EXP (&dconst3_4) - 2);\n-\n-\t      /* Optimize pow (x, 0.25) into sqrt (sqrt (x)).  Assume on most\n-\t\t machines that a builtin sqrt instruction is smaller than a\n-\t\t call to pow with 0.25, so do this optimization even if\n-\t\t -Os.  */\n-\t      if (REAL_VALUES_EQUAL (c, dconst1_4))\n-\t\t{\n-\t\t  op = build_call_nofold_loc (loc, sqrtfn, 1, arg0);\n-\t\t  op = build_call_nofold_loc (loc, sqrtfn, 1, op);\n-\t\t}\n-\n-\t      /* Optimize pow (x, 0.75) = sqrt (x) * sqrt (sqrt (x)) unless we\n-\t\t are optimizing for space.  */\n-\t      else if (optimize_insn_for_speed_p ()\n-\t\t       && !TREE_SIDE_EFFECTS (arg0)\n-\t\t       && REAL_VALUES_EQUAL (c, dconst3_4))\n-\t\t{\n-\t\t  tree sqrt1 = build_call_expr_loc (loc, sqrtfn, 1, arg0);\n-\t\t  tree sqrt2 = builtin_save_expr (sqrt1);\n-\t\t  tree sqrt3 = build_call_expr_loc (loc, sqrtfn, 1, sqrt1);\n-\t\t  op = fold_build2_loc (loc, MULT_EXPR, type, sqrt2, sqrt3);\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* Check whether we can do cbrt insstead of pow (x, 1./3.) and\n-\t cbrt/sqrts instead of pow (x, 1./6.).  */\n-      if (cbrtfn && ! op\n-\t  && (tree_expr_nonnegative_p (arg0) || !HONOR_NANS (mode)))\n-\t{\n-\t  /* First try 1/3.  */\n-\t  REAL_VALUE_TYPE dconst1_3\n-\t    = real_value_truncate (mode, dconst_third ());\n-\n-\t  if (REAL_VALUES_EQUAL (c, dconst1_3))\n-\t    op = build_call_nofold_loc (loc, cbrtfn, 1, arg0);\n-\n-\t      /* Now try 1/6.  */\n-\t  else if (optimize_insn_for_speed_p ()\n-\t\t   && optab_handler (sqrt_optab, mode) != CODE_FOR_nothing)\n-\t    {\n-\t      REAL_VALUE_TYPE dconst1_6 = dconst1_3;\n-\t      SET_REAL_EXP (&dconst1_6, REAL_EXP (&dconst1_6) - 1);\n-\n-\t      if (REAL_VALUES_EQUAL (c, dconst1_6))\n-\t\t{\n-\t\t  op = build_call_nofold_loc (loc, sqrtfn, 1, arg0);\n-\t\t  op = build_call_nofold_loc (loc, cbrtfn, 1, op);\n-\t\t}\n-\t    }\n-\t}\n-\n-      if (op)\n-\treturn expand_expr (op, subtarget, mode, EXPAND_NORMAL);\n-    }\n-\n-  return NULL_RTX;\n-}\n-\n-/* Expand a call to the pow built-in mathematical function.  Return NULL_RTX if\n-   a normal call should be emitted rather than expanding the function\n-   in-line.  EXP is the expression that is a call to the builtin\n-   function; if convenient, the result should be placed in TARGET.  */\n-\n-static rtx\n-expand_builtin_pow (tree exp, rtx target, rtx subtarget)\n-{\n-  tree arg0, arg1;\n-  tree fn, narg0;\n-  tree type = TREE_TYPE (exp);\n-  REAL_VALUE_TYPE cint, c, c2;\n-  HOST_WIDE_INT n;\n-  rtx op, op2;\n-  enum machine_mode mode = TYPE_MODE (type);\n-\n-  if (! validate_arglist (exp, REAL_TYPE, REAL_TYPE, VOID_TYPE))\n-    return NULL_RTX;\n-\n-  arg0 = CALL_EXPR_ARG (exp, 0);\n-  arg1 = CALL_EXPR_ARG (exp, 1);\n-\n-  if (TREE_CODE (arg1) != REAL_CST\n-      || TREE_OVERFLOW (arg1))\n-    return expand_builtin_mathfn_2 (exp, target, subtarget);\n-\n-  /* Handle constant exponents.  */\n-\n-  /* For integer valued exponents we can expand to an optimal multiplication\n-     sequence using expand_powi.  */\n-  c = TREE_REAL_CST (arg1);\n-  n = real_to_integer (&c);\n-  real_from_integer (&cint, VOIDmode, n, n < 0 ? -1 : 0, 0);\n-  if (real_identical (&c, &cint)\n-      && ((n >= -1 && n <= 2)\n-\t  || (flag_unsafe_math_optimizations\n-\t      && optimize_insn_for_speed_p ()\n-\t      && powi_cost (n) <= POWI_MAX_MULTS)))\n-    {\n-      op = expand_expr (arg0, subtarget, VOIDmode, EXPAND_NORMAL);\n-      if (n != 1)\n-\t{\n-\t  op = force_reg (mode, op);\n-\t  op = expand_powi (op, mode, n);\n-\t}\n-      return op;\n-    }\n-\n-  narg0 = builtin_save_expr (arg0);\n-\n-  /* If the exponent is not integer valued, check if it is half of an integer.\n-     In this case we can expand to sqrt (x) * x**(n/2).  */\n-  fn = mathfn_built_in (type, BUILT_IN_SQRT);\n-  if (fn != NULL_TREE)\n-    {\n-      real_arithmetic (&c2, MULT_EXPR, &c, &dconst2);\n-      n = real_to_integer (&c2);\n-      real_from_integer (&cint, VOIDmode, n, n < 0 ? -1 : 0, 0);\n-      if (real_identical (&c2, &cint)\n-\t  && ((flag_unsafe_math_optimizations\n-\t       && optimize_insn_for_speed_p ()\n-\t       && powi_cost (n/2) <= POWI_MAX_MULTS)\n-\t      /* Even the c == 0.5 case cannot be done unconditionally\n-\t         when we need to preserve signed zeros, as\n-\t\t pow (-0, 0.5) is +0, while sqrt(-0) is -0.  */\n-\t      || (!HONOR_SIGNED_ZEROS (mode) && n == 1)\n-\t      /* For c == 1.5 we can assume that x * sqrt (x) is always\n-\t         smaller than pow (x, 1.5) if sqrt will not be expanded\n-\t\t as a call.  */\n-\t      || (n == 3\n-\t\t  && optab_handler (sqrt_optab, mode) != CODE_FOR_nothing)))\n-\t{\n-\t  tree call_expr = build_call_nofold_loc (EXPR_LOCATION (exp), fn, 1,\n-\t\t\t\t\t\t  narg0);\n-\t  /* Use expand_expr in case the newly built call expression\n-\t     was folded to a non-call.  */\n-\t  op = expand_expr (call_expr, subtarget, mode, EXPAND_NORMAL);\n-\t  if (n != 1)\n-\t    {\n-\t      op2 = expand_expr (narg0, subtarget, VOIDmode, EXPAND_NORMAL);\n-\t      op2 = force_reg (mode, op2);\n-\t      op2 = expand_powi (op2, mode, abs (n / 2));\n-\t      op = expand_simple_binop (mode, MULT, op, op2, NULL_RTX,\n-\t\t\t\t\t0, OPTAB_LIB_WIDEN);\n-\t      /* If the original exponent was negative, reciprocate the\n-\t\t result.  */\n-\t      if (n < 0)\n-\t\top = expand_binop (mode, sdiv_optab, CONST1_RTX (mode),\n-\t\t\t\t   op, NULL_RTX, 0, OPTAB_LIB_WIDEN);\n-\t    }\n-\t  return op;\n-\t}\n-    }\n-\n-  /* Check whether we can do a series of sqrt or cbrt's instead of the pow\n-     call.  */\n-  op = expand_builtin_pow_root (EXPR_LOCATION (exp), arg0, arg1, type,\n-\t\t\t\tsubtarget);\n-  if (op)\n-    return op;\n-\n-  /* Try if the exponent is a third of an integer.  In this case\n-     we can expand to x**(n/3) * cbrt(x)**(n%3).  As cbrt (x) is\n-     different from pow (x, 1./3.) due to rounding and behavior\n-     with negative x we need to constrain this transformation to\n-     unsafe math and positive x or finite math.  */\n-  fn = mathfn_built_in (type, BUILT_IN_CBRT);\n-  if (fn != NULL_TREE\n-      && flag_unsafe_math_optimizations\n-      && (tree_expr_nonnegative_p (arg0)\n-\t  || !HONOR_NANS (mode)))\n-    {\n-      REAL_VALUE_TYPE dconst3;\n-      real_from_integer (&dconst3, VOIDmode, 3, 0, 0);\n-      real_arithmetic (&c2, MULT_EXPR, &c, &dconst3);\n-      real_round (&c2, mode, &c2);\n-      n = real_to_integer (&c2);\n-      real_from_integer (&cint, VOIDmode, n, n < 0 ? -1 : 0, 0);\n-      real_arithmetic (&c2, RDIV_EXPR, &cint, &dconst3);\n-      real_convert (&c2, mode, &c2);\n-      if (real_identical (&c2, &c)\n-\t  && ((optimize_insn_for_speed_p ()\n-\t       && powi_cost (n/3) <= POWI_MAX_MULTS)\n-\t      || n == 1))\n-\t{\n-\t  tree call_expr = build_call_nofold_loc (EXPR_LOCATION (exp), fn, 1,\n-\t\t\t\t\t\t  narg0);\n-\t  op = expand_builtin (call_expr, NULL_RTX, subtarget, mode, 0);\n-\t  if (abs (n) % 3 == 2)\n-\t    op = expand_simple_binop (mode, MULT, op, op, op,\n-\t\t\t\t      0, OPTAB_LIB_WIDEN);\n-\t  if (n != 1)\n-\t    {\n-\t      op2 = expand_expr (narg0, subtarget, VOIDmode, EXPAND_NORMAL);\n-\t      op2 = force_reg (mode, op2);\n-\t      op2 = expand_powi (op2, mode, abs (n / 3));\n-\t      op = expand_simple_binop (mode, MULT, op, op2, NULL_RTX,\n-\t\t\t\t\t0, OPTAB_LIB_WIDEN);\n-\t      /* If the original exponent was negative, reciprocate the\n-\t\t result.  */\n-\t      if (n < 0)\n-\t\top = expand_binop (mode, sdiv_optab, CONST1_RTX (mode),\n-\t\t\t\t   op, NULL_RTX, 0, OPTAB_LIB_WIDEN);\n-\t    }\n-\t  return op;\n-\t}\n-    }\n-\n-  /* Fall back to optab expansion.  */\n-  return expand_builtin_mathfn_2 (exp, target, subtarget);\n-}\n-\n /* Expand a call to the powi built-in mathematical function.  Return NULL_RTX if\n    a normal call should be emitted rather than expanding the function\n    in-line.  EXP is the expression that is a call to the builtin\n@@ -3288,27 +2843,6 @@ expand_builtin_powi (tree exp, rtx target)\n   arg1 = CALL_EXPR_ARG (exp, 1);\n   mode = TYPE_MODE (TREE_TYPE (exp));\n \n-  /* Handle constant power.  */\n-\n-  if (TREE_CODE (arg1) == INTEGER_CST\n-      && !TREE_OVERFLOW (arg1))\n-    {\n-      HOST_WIDE_INT n = TREE_INT_CST_LOW (arg1);\n-\n-      /* If the exponent is -1, 0, 1 or 2, then expand_powi is exact.\n-\t Otherwise, check the number of multiplications required.  */\n-      if ((TREE_INT_CST_HIGH (arg1) == 0\n-\t   || TREE_INT_CST_HIGH (arg1) == -1)\n-\t  && ((n >= -1 && n <= 2)\n-\t      || (optimize_insn_for_speed_p ()\n-\t\t  && powi_cost (n) <= POWI_MAX_MULTS)))\n-\t{\n-\t  op0 = expand_expr (arg0, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-\t  op0 = force_reg (mode, op0);\n-\t  return expand_powi (op0, mode, n);\n-\t}\n-    }\n-\n   /* Emit a libcall to libgcc.  */\n \n   /* Mode of the 2nd argument must match that of an int.  */\n@@ -5862,12 +5396,6 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n \treturn target;\n       break;\n \n-    CASE_FLT_FN (BUILT_IN_POW):\n-      target = expand_builtin_pow (exp, target, subtarget);\n-      if (target)\n-\treturn target;\n-      break;\n-\n     CASE_FLT_FN (BUILT_IN_POWI):\n       target = expand_builtin_powi (exp, target);\n       if (target)\n@@ -5885,6 +5413,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n     CASE_FLT_FN (BUILT_IN_FMOD):\n     CASE_FLT_FN (BUILT_IN_REMAINDER):\n     CASE_FLT_FN (BUILT_IN_DREM):\n+    CASE_FLT_FN (BUILT_IN_POW):\n       target = expand_builtin_mathfn_2 (exp, target, subtarget);\n       if (target)\n \treturn target;"}]}