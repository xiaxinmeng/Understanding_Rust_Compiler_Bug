{"sha": "af7d1b7d17315b450db9de5c3d20f8a24a91b39e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWY3ZDFiN2QxNzMxNWI0NTBkYjlkZTVjM2QyMGY4YTI0YTkxYjM5ZQ==", "commit": {"author": {"name": "Peter Bergner", "email": "bergner@vnet.ibm.com", "date": "2013-11-21T21:19:35Z"}, "committer": {"name": "Peter Bergner", "email": "bergner@gcc.gnu.org", "date": "2013-11-21T21:19:35Z"}, "message": "* doc/extend.texi: Document htm builtins.\n\nFrom-SVN: r205233", "tree": {"sha": "cc6fc30d1fddcf37ed40c0b889ce73eb84c968fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc6fc30d1fddcf37ed40c0b889ce73eb84c968fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af7d1b7d17315b450db9de5c3d20f8a24a91b39e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af7d1b7d17315b450db9de5c3d20f8a24a91b39e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af7d1b7d17315b450db9de5c3d20f8a24a91b39e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af7d1b7d17315b450db9de5c3d20f8a24a91b39e/comments", "author": {"login": "peter-bergner", "id": 17504345, "node_id": "MDQ6VXNlcjE3NTA0MzQ1", "avatar_url": "https://avatars.githubusercontent.com/u/17504345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peter-bergner", "html_url": "https://github.com/peter-bergner", "followers_url": "https://api.github.com/users/peter-bergner/followers", "following_url": "https://api.github.com/users/peter-bergner/following{/other_user}", "gists_url": "https://api.github.com/users/peter-bergner/gists{/gist_id}", "starred_url": "https://api.github.com/users/peter-bergner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peter-bergner/subscriptions", "organizations_url": "https://api.github.com/users/peter-bergner/orgs", "repos_url": "https://api.github.com/users/peter-bergner/repos", "events_url": "https://api.github.com/users/peter-bergner/events{/privacy}", "received_events_url": "https://api.github.com/users/peter-bergner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a6094705724d05fc2286c4541c97b8093b77bf05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6094705724d05fc2286c4541c97b8093b77bf05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6094705724d05fc2286c4541c97b8093b77bf05"}], "stats": {"total": 195, "additions": 195, "deletions": 0}, "files": [{"sha": "c50c99e05ad493a72cc9defd5ac31efd45ca6935", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af7d1b7d17315b450db9de5c3d20f8a24a91b39e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af7d1b7d17315b450db9de5c3d20f8a24a91b39e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=af7d1b7d17315b450db9de5c3d20f8a24a91b39e", "patch": "@@ -1,3 +1,7 @@\n+2013-11-21  Peter Bergner  <bergner@vnet.ibm.com>\n+\n+\t* doc/extend.texi: Document htm builtins.\n+\n 2013-11-21  Jeff Law  <law@redhat.com>\n \n \tPR tree-optimization/59221"}, {"sha": "d1fbcc392741e9c5e499986c0b6c17d0fbedb607", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af7d1b7d17315b450db9de5c3d20f8a24a91b39e/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af7d1b7d17315b450db9de5c3d20f8a24a91b39e/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=af7d1b7d17315b450db9de5c3d20f8a24a91b39e", "patch": "@@ -9218,6 +9218,7 @@ instructions, but allow the compiler to schedule those calls.\n * picoChip Built-in Functions::\n * PowerPC Built-in Functions::\n * PowerPC AltiVec/VSX Built-in Functions::\n+* PowerPC Hardware Transactional Memory Built-in Functions::\n * RX Built-in Functions::\n * S/390 System z Built-in Functions::\n * SH Built-in Functions::\n@@ -15170,6 +15171,196 @@ The second argument to the @var{__builtin_crypto_vshasigmad} and\n integer that is 0 or 1.  The third argument to these builtin functions\n must be a constant integer in the range of 0 to 15.\n \n+@node PowerPC Hardware Transactional Memory Built-in Functions\n+@subsection PowerPC Hardware Transactional Memory Built-in Functions\n+GCC provides two interfaces for accessing the Hardware Transactional\n+Memory (HTM) instructions available on some of the PowerPC family\n+of prcoessors (eg, POWER8).  The two interfaces come in a low level\n+interface, consisting of built-in functions specific to PowerPC and a\n+higher level interface consisting of inline functions that are common\n+between PowerPC and S/390.\n+\n+@subsubsection PowerPC HTM Low Level Built-in Functions\n+\n+The following low level built-in functions are available with\n+@option{-mhtm} or @option{-mcpu=CPU} where CPU is `power8' or later.\n+They all generate the machine instruction that is part of the name.\n+\n+The HTM built-ins return true or false depending on their success and\n+their arguments match exactly the type and order of the associated\n+hardware instruction's operands.  Refer to the ISA manual for a\n+description of each instruction's operands.\n+\n+@smallexample\n+unsigned int __builtin_tbegin (unsigned int)\n+unsigned int __builtin_tend (unsigned int)\n+\n+unsigned int __builtin_tabort (unsigned int)\n+unsigned int __builtin_tabortdc (unsigned int, unsigned int, unsigned int)\n+unsigned int __builtin_tabortdci (unsigned int, unsigned int, int)\n+unsigned int __builtin_tabortwc (unsigned int, unsigned int, unsigned int)\n+unsigned int __builtin_tabortwci (unsigned int, unsigned int, int)\n+\n+unsigned int __builtin_tcheck (unsigned int)\n+unsigned int __builtin_treclaim (unsigned int)\n+unsigned int __builtin_trechkpt (void)\n+unsigned int __builtin_tsr (unsigned int)\n+@end smallexample\n+\n+In addition to the above HTM built-ins, we have added built-ins for\n+some common extended mnemonics of the HTM instructions:\n+\n+@smallexample\n+unsigned int __builtin_tendall (void)\n+unsigned int __builtin_tresume (void)\n+unsigned int __builtin_tsuspend (void)\n+@end smallexample\n+\n+The following set of built-in functions are available to gain access\n+to the HTM specific special purpose registers.\n+\n+@smallexample\n+unsigned long __builtin_get_texasr (void)\n+unsigned long __builtin_get_texasru (void)\n+unsigned long __builtin_get_tfhar (void)\n+unsigned long __builtin_get_tfiar (void)\n+\n+void __builtin_set_texasr (unsigned long);\n+void __builtin_set_texasru (unsigned long);\n+void __builtin_set_tfhar (unsigned long);\n+void __builtin_set_tfiar (unsigned long);\n+@end smallexample\n+\n+Example usage of these low level built-in functions may look like:\n+\n+@smallexample\n+#include <htmintrin.h>\n+\n+int num_retries = 10;\n+\n+while (1)\n+  @{\n+    if (__builtin_tbegin (0))\n+      @{\n+        /* Transaction State Initiated.  */\n+        if (is_locked (lock))\n+          __builtin_tabort (0);\n+        ... transaction code...\n+        __builtin_tend (0);\n+        break;\n+      @}\n+    else\n+      @{\n+        /* Transaction State Failed.  Use locks if the transaction\n+           failure is \"persistent\" or we've tried too many times.  */\n+        if (num_retries-- <= 0\n+            || _TEXASRU_FAILURE_PERSISTENT (__builtin_get_texasru ()))\n+          @{\n+            acquire_lock (lock);\n+            ... non transactional fallback path...\n+            release_lock (lock);\n+            break;\n+          @}\n+      @}\n+  @}\n+@end smallexample\n+\n+One final built-in function has been added that returns the value of\n+the 2-bit Transaction State field of the Machine Status Register (MSR)\n+as stored in @code{CR0}.\n+\n+@smallexample\n+unsigned long __builtin_ttest (void)\n+@end smallexample\n+\n+This built-in can be used to determine the current transaction state\n+using the following code example:\n+\n+@smallexample\n+#include <htmintrin.h>\n+\n+unsigned char tx_state = _HTM_STATE (__builtin_ttest ());\n+\n+if (tx_state == _HTM_TRANSACTIONAL)\n+  @{\n+    /* Code to use in transactional state.  */\n+  @}\n+else if (tx_state == _HTM_NONTRANSACTIONAL)\n+  @{\n+    /* Code to use in non-transactional state.  */\n+  @}\n+else if (tx_state == _HTM_SUSPENDED)\n+  @{\n+    /* Code to use in transaction suspended state.  */\n+  @}\n+@end smallexample\n+\n+@subsubsection PowerPC HTM High Level Inline Functions\n+\n+The following high level HTM interface is made available by including\n+@code{<htmxlintrin.h>} and using @option{-mhtm} or @option{-mcpu=CPU}\n+where CPU is `power8' or later.  This interface is common between PowerPC\n+and S/390, allowing users to write one HTM source implementation that\n+can be compiled and executed on either system.\n+\n+@smallexample\n+long __TM_simple_begin (void)\n+long __TM_begin (void* const TM_buff)\n+long __TM_end (void)\n+void __TM_abort (void)\n+void __TM_named_abort (unsigned char const code)\n+void __TM_resume (void)\n+void __TM_suspend (void)\n+\n+long __TM_is_user_abort (void* const TM_buff)\n+long __TM_is_named_user_abort (void* const TM_buff, unsigned char *code)\n+long __TM_is_illegal (void* const TM_buff)\n+long __TM_is_footprint_exceeded (void* const TM_buff)\n+long __TM_nesting_depth (void* const TM_buff)\n+long __TM_is_nested_too_deep(void* const TM_buff)\n+long __TM_is_conflict(void* const TM_buff)\n+long __TM_is_failure_persistent(void* const TM_buff)\n+long __TM_failure_address(void* const TM_buff)\n+long long __TM_failure_code(void* const TM_buff)\n+@end smallexample\n+\n+Using these common set of HTM inline functions, we can create\n+a more portable version of the HTM example in the previous\n+section that will work on either PowerPC or S/390:\n+\n+@smallexample\n+#include <htmxlintrin.h>\n+\n+int num_retries = 10;\n+TM_buff_type TM_buff;\n+\n+while (1)\n+  @{\n+    if (__TM_begin (TM_buff))\n+      @{\n+        /* Transaction State Initiated.  */\n+        if (is_locked (lock))\n+          __TM_abort ();\n+        ... transaction code...\n+        __TM_end ();\n+        break;\n+      @}\n+    else\n+      @{\n+        /* Transaction State Failed.  Use locks if the transaction\n+           failure is \"persistent\" or we've tried too many times.  */\n+        if (num_retries-- <= 0\n+            || __TM_is_failure_persistent (TM_buff))\n+          @{\n+            acquire_lock (lock);\n+            ... non transactional fallback path...\n+            release_lock (lock);\n+            break;\n+          @}\n+      @}\n+  @}\n+@end smallexample\n+\n @node RX Built-in Functions\n @subsection RX Built-in Functions\n GCC supports some of the RX instructions which cannot be expressed in"}]}