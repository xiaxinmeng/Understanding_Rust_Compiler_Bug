{"sha": "f0e01782d7d294907fe8f8325bfae9c6fae7a877", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjBlMDE3ODJkN2QyOTQ5MDdmZThmODMyNWJmYWU5YzZmYWU3YTg3Nw==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-06-15T18:30:58Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-06-15T18:30:58Z"}, "message": "40th Cygnus<->FSF merge\n\nFrom-SVN: r7493", "tree": {"sha": "2990254a5379920de31c9e0548663ccf4769e623", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2990254a5379920de31c9e0548663ccf4769e623"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0e01782d7d294907fe8f8325bfae9c6fae7a877", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0e01782d7d294907fe8f8325bfae9c6fae7a877", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0e01782d7d294907fe8f8325bfae9c6fae7a877", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0e01782d7d294907fe8f8325bfae9c6fae7a877/comments", "author": null, "committer": null, "parents": [{"sha": "7dbe2fdcf52add2c55b4e7ba95216942fb274a4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dbe2fdcf52add2c55b4e7ba95216942fb274a4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7dbe2fdcf52add2c55b4e7ba95216942fb274a4a"}], "stats": {"total": 516, "additions": 397, "deletions": 119}, "files": [{"sha": "cddc168d576788622096449b7d035acc88e69e3a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f0e01782d7d294907fe8f8325bfae9c6fae7a877", "patch": "@@ -1,7 +1,133 @@\n+Tue Jun 14 12:23:38 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* decl.c (grok_op_properties): Const objects can be passed by value.\n+\n+Mon Jun 13 03:10:59 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* decl2.c (import_export_vtable): Force implicit instantiations to\n+\tbe interface_only when -fno-implicit-templates.\n+\n+\t* decl.c (duplicate_decls): Redeclaring a class template name is an\n+\terror.\n+\n+\t* pt.c (end_template_decl): Call GNU_xref_decl for class templates.\n+\t* xref.c (GNU_xref_decl): Support templates.\n+\n+Sat Jun 11 17:09:05 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* decl.c (grok_op_properties): Split out checking for whether this\n+\tfunction should suppress the default assignment operator.\n+\t* decl2.c (grok_function_init): Ditto.\n+\t(copy_assignment_arg_p): New function do do just that.\n+\tNow considers virtual assignment operators that take a base as an\n+\targument to count as copy assignment operators.\n+\n+\t* search.c (dfs_debug_mark): Lose checks for DWARF_DEBUG and\n+\tTREE_ASM_WRITTEN, as they are redundant.\n+\n+\t* pt.c (end_template_decl): Don't try to set DECL_CLASS_CONTEXT on a\n+\tdecl that has no LANG_SPECIFIC part.\n+\t(do_type_instantiation): Force the debugging information for this\n+\ttype to be emitted.\n+\n+\t* decl.c (start_decl): Clear up uses of various types of templates\n+\t(say sorry for static data members, rather than \"invalid template\"). \n+\t(expand_static_init): Fix initialization of static data members of\n+\ttemplate classes.\n+\n+Fri Jun 10 00:41:19 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* decl.c (grokdeclarator): Set DECL_CONTEXT on static data members.\n+\n+\t* g++.c (main): Use -xc++-cpp-output for .i files.\n+\n+\t* pt.c (tsubst): Give meaningful error about declaring template for\n+\ta copy constructor which was not declared in the class template.\n+\t(do_type_instantiation): Explicit instantiation before the class\n+\ttemplate is an error.\n+\t(instantiate_template): Don't die if tsubst returns error_mark_node.\n+\n+Thu Jun  9 19:04:59 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\tDon't synthesize the copy assignment operator if the one in a base\n+\tclass is pure virtual.\n+\t* cp-tree.h (TYPE_HAS_ABSTRACT_ASSIGN_REF): New macro to indicate\n+\twhether the type has a pure virtual copy assignment operator.\n+\t* class.c (finish_base_struct): Don't generate the copy assignment\n+\toperator if a base class has a pure virtual one.\n+\t* decl.c (grok_op_properties): Add disabled code to set\n+\tTYPE_HAS_ABSTRACT_ASSIGN_REF with comment pointing to where it is\n+\tactually set.\n+\t* decl2.c (grok_function_init): Set TYPE_HAS_ABSTRACT_ASSIGN_REF.\n+\n+\t* decl2.c (import_export_vtable): Always treat template\n+\tinstantiations as if write_virtuals >= 2, and treat implicit\n+\tinstantiations as external if -fno-implicit-templates.\n+\t(finish_file): Output all pending inlines if\n+\tflag_keep_inline_functions.\n+\n+Wed Jun  8 20:48:02 1994  Mike Stump  (mrs@cygnus.com)\n+\n+\t* tree.c (layout_vbasetypes): Align virtual base classes inside\n+\tcomplete objects, so that we don't core dump on machines such as\n+\tSPARCs when we access members that require larger than normal\n+\talignments, such as a double.  Also, we bump up the total alignment\n+\ton the complete type, as necessary.\n+\n+Wed Jun  8 16:18:14 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* gxxint.texi (Free Store): New section with code for examining\n+\tcookie.\n+\t(Limitations of g++): Remove operator delete entry, since it is no\n+\tlonger accurate.  Fix access control entry.\n+\n+\t* typeck.c (build_unary_op): Pedwarn about taking the address of or\n+\tincrementing a cast to non-reference type.\n+\t(build_modify_expr): Use convert instead of convert_force again.\n+\n+\t* search.c (get_base_distance): Use IS_AGGR_TYPE_CODE to check for\n+\tclass type, not == RECORD_TYPE.\n+\n+\t* decl.c (grokdeclarator): Cope with grokfndecl returning NULL_TREE.\n+\n+\t* typeck2.c (report_case_error): #if 0 out.\n+\t* lex.c (real_yylex): Lose RANGE.\n+\t* parse.y: Ditto.\n+\n+Tue Jun  7 18:17:35 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* parse.y (simple_stmt, case ranges): Use ELLIPSIS instead of RANGE.\n+\n+Mon Jun  6 19:39:57 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* typeck.c (build_c_cast): Don't shortcut conversions to the same\n+\ttype.  Don't replace consts with their values here, since that's now\n+\tdone in cp_convert.\n+\n+\t* cvt.c (cp_convert): When converting to bool, take\n+\tinteger_zero_node to false_node and all other INTEGER_CSTs to\n+\ttrue_node.\n+\t(build_type_conversion): Don't complain about multiple conversions\n+\tto float if we're not really converting.\n+\n Fri Jun  3 02:10:56 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \n+\tImplement 'extern template class A<int>;' syntax for suppressing\n+\tspecific implicit instantiations.\n+\t* cp-tree.h: Update prototypes for do_*_instantiation.\n+\t* pt.c (do_pending_expansions): Don't compile 'extern' explicit\n+\tinstantiations.\n+\t(do_function_instantiation): Set DECL_EXTERNAL on 'extern' explicit\n+\tinstantiations.\n+\t(do_type_instantiation): Ditto.\n+\t* parse.y (explicit_instantiation): Support 'extern template class\n+\tA<int>;' syntax.\n+\t* decl.c (start_function): Don't modify the settings of TREE_PUBLIC\n+\tand DECL_EXTERNAL on explicit instantiations.\n+\n \t* cvt.c (cp_convert): Replace constants with their values before\n \tconverting.\n+\t(cp_convert): Consistently use 'e' instead of 'expr'.\n \n Thu Jun  2 03:53:30 1994  Jason Merrill  (jason@deneb.cygnus.com)\n "}, {"sha": "1d276816f993b712d3f0bf8bca399222d14f2463", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=f0e01782d7d294907fe8f8325bfae9c6fae7a877", "patch": "@@ -1390,6 +1390,7 @@ finish_base_struct (t, b, t_binfo)\n \t  && !TYPE_HAS_CONST_ASSIGN_REF (basetype))\n \tb->no_const_asn_ref = 1;\n       if (! TYPE_HAS_ASSIGN_REF (basetype)\n+\t  || TYPE_HAS_ABSTRACT_ASSIGN_REF (basetype)\n \t  || (TYPE_HAS_NONPUBLIC_ASSIGN_REF (basetype) == 2\n \t      && ! is_friend_type (t, basetype)))\n \tb->cant_synth_asn_ref = 1;"}, {"sha": "9ba72b02ad57359890e1a84be85c1f2dd03a575f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f0e01782d7d294907fe8f8325bfae9c6fae7a877", "patch": "@@ -438,11 +438,12 @@ struct lang_type\n       unsigned has_complex_init_ref : 1;\n       unsigned has_complex_assign_ref : 1;\n       unsigned vec_delete_takes_size : 1;\n+      unsigned has_abstract_assign_ref : 1;\n \n       /* The MIPS compiler gets it wrong if this struct also\n \t does not fill out to a multiple of 4 bytes.  Add a\n \t member `dummy' with new bits if you go over the edge.  */\n-      unsigned dummy : 20;\n+      unsigned dummy : 19;\n \n       unsigned n_vancestors : 16;\n     } type_flags;\n@@ -1182,6 +1183,7 @@ struct lang_decl\n /* Nonzero if there is a user-defined X::op=(x&) for this class.  */\n #define TYPE_HAS_REAL_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_real_assign_ref)\n #define TYPE_HAS_COMPLEX_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_complex_assign_ref)\n+#define TYPE_HAS_ABSTRACT_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_abstract_assign_ref)\n #define TYPE_HAS_COMPLEX_INIT_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_complex_init_ref)\n \n /* Nonzero for _TYPE node means that destroying an object of this type\n@@ -2160,7 +2162,8 @@ extern int type_unification\t\t\tPROTO((tree, tree *, tree, tree, int *, int));\n extern int do_pending_expansions\t\tPROTO((void));\n extern void do_pending_templates\t\tPROTO((void));\n struct tinst_level *tinst_for_decl\t\tPROTO((void));\n-extern void do_function_instantiation\t\tPROTO((tree, tree));\n+extern void do_function_instantiation\t\tPROTO((tree, tree, tree));\n+extern void do_type_instantiation\t\tPROTO((tree, tree));\n extern tree create_nested_upt\t\t\tPROTO((tree, tree));\n \n /* in search.c */"}, {"sha": "3750221aeeff0e92682543e7223986aa8745b94c", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=f0e01782d7d294907fe8f8325bfae9c6fae7a877", "patch": "@@ -1194,24 +1194,24 @@ cp_convert (type, expr, convtype, flags)\n   register tree e = expr;\n   register enum tree_code code = TREE_CODE (type);\n \n-  if (type == TREE_TYPE (expr)\n-      || TREE_CODE (expr) == ERROR_MARK)\n-    return expr;\n-  if (TREE_CODE (TREE_TYPE (expr)) == ERROR_MARK)\n+  if (type == TREE_TYPE (e)\n+      || TREE_CODE (e) == ERROR_MARK)\n+    return e;\n+  if (TREE_CODE (TREE_TYPE (e)) == ERROR_MARK)\n     return error_mark_node;\n \n   /* Trivial conversion: cv-qualifiers do not matter on rvalues.  */\n-  if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (expr)))\n-    return fold (build1 (NOP_EXPR, type, expr));\n+  if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (e)))\n+    return fold (build1 (NOP_EXPR, type, e));\n   \n   if (code == VOID_TYPE && (convtype & CONV_STATIC))\n     return build1 (CONVERT_EXPR, type, e);\n \n #if 0\n   /* This is incorrect.  A truncation can't be stripped this way.\n      Extensions will be stripped by the use of get_unwidened.  */\n-  if (TREE_CODE (expr) == NOP_EXPR)\n-    return convert (type, TREE_OPERAND (expr, 0));\n+  if (TREE_CODE (e) == NOP_EXPR)\n+    return convert (type, TREE_OPERAND (e, 0));\n #endif\n \n   /* Just convert to the type of the member.  */\n@@ -1231,7 +1231,7 @@ cp_convert (type, expr, convtype, flags)\n \n   if (INTEGRAL_CODE_P (code))\n     {\n-      tree intype = TREE_TYPE (expr);\n+      tree intype = TREE_TYPE (e);\n       enum tree_code form = TREE_CODE (intype);\n       /* enum = enum, enum = int, enum = float are all errors. */\n       if (flag_int_enum_equivalence == 0\n@@ -1249,7 +1249,7 @@ cp_convert (type, expr, convtype, flags)\n       else if (IS_AGGR_TYPE (intype))\n \t{\n \t  tree rval;\n-\t  rval = build_type_conversion (CONVERT_EXPR, type, expr, 1);\n+\t  rval = build_type_conversion (CONVERT_EXPR, type, e, 1);\n \t  if (rval) return rval;\n \t  if (code == BOOLEAN_TYPE)\n \t    cp_error (\"`%#T' used where a `bool' was expected\", intype);\n@@ -1265,6 +1265,13 @@ cp_convert (type, expr, convtype, flags)\n \t    e = newe;\n \t  if (TREE_TYPE (e) == bool_type_node)\n \t    return e;\n+\t  else if (TREE_CODE (e) == INTEGER_CST)\n+\t    {\n+\t      if (e == integer_zero_node)\n+\t\te = false_node;\n+\t      else\n+\t\te = true_node;\n+\t    }\n \t  else\n \t    return build1 (NOP_EXPR, bool_type_node, e);\n \t}\n@@ -1413,13 +1420,13 @@ cp_convert (type, expr, convtype, flags)\n \t}\n     }\n \n-  /* If TYPE or TREE_TYPE (EXPR) is not on the permanent_obstack,\n+  /* If TYPE or TREE_TYPE (E) is not on the permanent_obstack,\n      then the it won't be hashed and hence compare as not equal,\n      even when it is.  */\n   if (code == ARRAY_TYPE\n-      && TREE_TYPE (TREE_TYPE (expr)) == TREE_TYPE (type)\n-      && index_type_equal (TYPE_DOMAIN (TREE_TYPE (expr)), TYPE_DOMAIN (type)))\n-    return expr;\n+      && TREE_TYPE (TREE_TYPE (e)) == TREE_TYPE (type)\n+      && index_type_equal (TYPE_DOMAIN (TREE_TYPE (e)), TYPE_DOMAIN (type)))\n+    return e;\n \n   cp_error (\"conversion from `%T' to non-scalar type `%T' requested\",\n \t    TREE_TYPE (expr), type);\n@@ -1789,9 +1796,13 @@ build_type_conversion (code, xtype, expr, for_sure)\n \t operator int().  */\n       if (TYPE_HAS_INT_CONVERSION (basetype))\n \t{\n-\t  error (\"two possible conversions for type `%s'\",\n-\t\t TYPE_NAME_STRING (type));\n-\t  return error_mark_node;\n+\t  if (for_sure)\n+\t    {\n+\t      cp_error (\"two possible conversions for type `%T'\", type);\n+\t      return error_mark_node;\n+\t    }\n+\t  else\n+\t    return NULL_TREE;\n \t}\n \n       typename = DECL_NAME (CLASSTYPE_CONVERSION (basetype, real_conv));"}, {"sha": "4bbfec9c9adfaf1000a78b8cfe612b4370c15ec1", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 49, "deletions": 17, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=f0e01782d7d294907fe8f8325bfae9c6fae7a877", "patch": "@@ -2175,7 +2175,19 @@ duplicate_decls (newdecl, olddecl)\n   else if (!types_match)\n     {\n       if (TREE_CODE (newdecl) == TEMPLATE_DECL)\n-\treturn 0;\n+\t{\n+\t  /* The name of a class template may not be declared to refer to\n+\t     any other template, class, function, object, namespace, value,\n+\t     or type in the same scope. */\n+\t  if (DECL_TEMPLATE_IS_CLASS (olddecl)\n+\t      || DECL_TEMPLATE_IS_CLASS (newdecl))\n+\t    {\n+\t      cp_error (\"declaration of template `%#D'\", newdecl);\n+\t      cp_error_at (\"conflicts with previous declaration `%#D'\",\n+\t\t\t   olddecl);\n+\t    }\n+\t  return 0;\n+\t}\n       if (TREE_CODE (newdecl) == FUNCTION_DECL)\n \t{\n \t  if (DECL_LANGUAGE (newdecl) == lang_c\n@@ -5408,8 +5420,10 @@ start_decl (declarator, declspecs, initialized, raises)\n \t      return NULL_TREE;\n \t    }\n \n-          if (/* TREE_CODE (result) == VAR_DECL */ 1)\n-            {\n+\t  if (TREE_CODE (result) == FUNCTION_DECL)\n+\t    return tem;\n+\t  else if (TREE_CODE (result) == VAR_DECL)\n+\t    {\n #if 0\n               tree tmpl = UPT_TEMPLATE (type);\n \t      \n@@ -5420,15 +5434,24 @@ start_decl (declarator, declspecs, initialized, raises)\n               DECL_TEMPLATE_MEMBERS (tmpl)\n                 = perm_tree_cons (DECL_NAME (tem), tem,\n \t\t\t\t  DECL_TEMPLATE_MEMBERS (tmpl));\n-#endif\n \t      return tem;\n+#else\n+\t      sorry (\"static data member templates\");\n+\t      return NULL_TREE;\n+#endif\n \t    }\n-          my_friendly_abort (13);\n+\t  else\n+\t    my_friendly_abort (13);\n         }\n       else if (TREE_CODE (result) == FUNCTION_DECL)\n         /*tem = push_overloaded_decl (tem, 0)*/;\n-      else if (TREE_CODE (result) == VAR_DECL\n-\t       || TREE_CODE (result) == TYPE_DECL)\n+      else if (TREE_CODE (result) == VAR_DECL)\n+\t{\n+\t  cp_error (\"data template `%#D' must be member of a class template\",\n+\t\t    result);\n+\t  return NULL_TREE;\n+\t}\n+      else if (TREE_CODE (result) == TYPE_DECL)\n \t{\n \t  cp_error (\"invalid template `%#D'\", result);\n \t  return NULL_TREE;\n@@ -6450,7 +6473,8 @@ expand_static_init (decl, init)\n       if (TREE_PURPOSE (oldstatic) && init != NULL_TREE)\n \tcp_error (\"multiple initializations given for `%D'\", decl);\n     }\n-  else if (current_binding_level != global_binding_level)\n+  else if (current_binding_level != global_binding_level\n+\t   && current_binding_level->pseudo_global == 0)\n     {\n       /* Emit code to perform this initialization but once.  */\n       tree temp;\n@@ -8859,6 +8883,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t    decl = grokfndecl (ctype, type, declarator,\n \t\t\t       virtualp, flags, quals,\n \t\t\t       raises, friendp ? -1 : 0, publicp);\n+\t    if (decl == NULL_TREE)\n+\t      return NULL_TREE;\n+\n \t    DECL_INLINE (decl) = inlinep;\n \t  }\n \telse if (TREE_CODE (type) == METHOD_TYPE)\n@@ -8868,6 +8895,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t    decl = grokfndecl (ctype, type, declarator,\n \t\t\t       virtualp, flags, quals,\n \t\t\t       raises, friendp ? -1 : 0, 1);\n+\t    if (decl == NULL_TREE)\n+\t      return NULL_TREE;\n+\n \t    DECL_INLINE (decl) = inlinep;\n \t  }\n \telse if (TREE_CODE (type) == RECORD_TYPE\n@@ -9056,6 +9086,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t\t   raises,\n \t\t\t   processing_template_decl ? 0 : friendp ? 2 : 1,\n \t\t\t   publicp);\n+\tif (decl == NULL_TREE)\n+\t  return NULL_TREE;\n \n \tif (ctype == NULL_TREE && DECL_LANGUAGE (decl) != lang_c)\n \t  DECL_ASSEMBLER_NAME (decl) = declarator;\n@@ -9126,6 +9158,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \n \tif (ctype)\n \t  {\n+\t    DECL_CONTEXT (decl) = ctype;\n \t    if (staticp == 1)\n \t      {\n \t        cp_error (\"static member `%D' re-declared as static\",\n@@ -9725,14 +9758,17 @@ grok_op_properties (decl, virtualp, friendp)\n \t    }\n \t  parmtype = TREE_VALUE (TREE_CHAIN (argtypes));\n \n-\t  if (TREE_CODE (parmtype) == REFERENCE_TYPE\n-\t      && (TYPE_MAIN_VARIANT (TREE_TYPE (parmtype))\n-\t\t  == current_class_type)\n+\t  if (copy_assignment_arg_p (parmtype, virtualp)\n \t      && ! friendp)\n \t    {\n \t      TYPE_HAS_ASSIGN_REF (current_class_type) = 1;\n-\t      if (TYPE_READONLY (TREE_TYPE (parmtype)))\n+\t      if (TREE_CODE (parmtype) != REFERENCE_TYPE\n+\t\t  || TYPE_READONLY (TREE_TYPE (parmtype)))\n \t\tTYPE_HAS_CONST_ASSIGN_REF (current_class_type) = 1;\n+#if 0 /* Too soon; done in grok_function_init */\n+\t      if (DECL_ABSTRACT_VIRTUAL_P (decl))\n+\t\tTYPE_HAS_ABSTRACT_ASSIGN_REF (current_class_type) = 1;\n+#endif\n \t    }\n \t}\n       else if (name == ansi_opname[(int) COND_EXPR])\n@@ -10748,11 +10784,7 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n \t   || (DECL_INLINE (decl1) && ! flag_implement_inlines));\n     }\n   else if (DECL_EXPLICIT_INSTANTIATION (decl1))\n-    {\n-      TREE_PUBLIC (decl1) = 1;\n-      DECL_EXTERNAL (decl1) = (DECL_INLINE (decl1)\n-\t\t\t       && ! flag_implement_inlines);\n-    }\n+    /* PUBLIC and EXTERNAL set by do_*_instantiation */;\n   else\n     {\n       /* This is a definition, not a reference."}, {"sha": "964615e71e7026387157075a5917863572835880", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=f0e01782d7d294907fe8f8325bfae9c6fae7a877", "patch": "@@ -1667,6 +1667,21 @@ grokoptypename (declspecs, declarator)\n \n */\n \n+int\n+copy_assignment_arg_p (parmtype, virtualp)\n+     tree parmtype;\n+     int virtualp;\n+{\n+  if (TREE_CODE (parmtype) == REFERENCE_TYPE)\n+    parmtype = TREE_TYPE (parmtype);\n+\n+  if ((TYPE_MAIN_VARIANT (parmtype) == current_class_type)\n+      || (virtualp && DERIVED_FROM_P (parmtype, current_class_type)))\n+    return 1;\n+\n+  return 0;\n+}\n+\n static void\n grok_function_init (decl, init)\n      tree decl;\n@@ -1696,6 +1711,14 @@ grok_function_init (decl, init)\n \t}\n #endif\n       DECL_ABSTRACT_VIRTUAL_P (decl) = 1;\n+      if (DECL_NAME (decl) == ansi_opname [(int) MODIFY_EXPR])\n+\t{\n+\t  tree parmtype\n+\t    = TREE_VALUE (TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (decl))));\n+\n+\t  if (copy_assignment_arg_p (parmtype, 1))\n+\t    TYPE_HAS_ABSTRACT_ASSIGN_REF (current_class_type) = 1;\n+\t}\n     }\n   else if (TREE_CODE (init) == OFFSET_REF\n \t   && TREE_OPERAND (init, 0) == NULL_TREE\n@@ -2311,8 +2334,18 @@ static void\n import_export_vtable (decl, type)\n   tree decl, type;\n {\n-  if (write_virtuals >= 2)\n+  if (write_virtuals >= 2\n+      || CLASSTYPE_TEMPLATE_INSTANTIATION (type))\n     {\n+      if (CLASSTYPE_IMPLICIT_INSTANTIATION (type)\n+\t  && ! flag_implicit_templates\n+\t  && CLASSTYPE_INTERFACE_UNKNOWN (type))\n+\t{\n+\t  SET_CLASSTYPE_INTERFACE_KNOWN (type);\n+\t  CLASSTYPE_INTERFACE_ONLY (type) = 1;\n+\t  CLASSTYPE_VTABLE_NEEDS_WRITING (type) = 0;\n+\t}\n+\n       if (CLASSTYPE_INTERFACE_KNOWN (type))\n \t{\n \t  TREE_PUBLIC (decl) = 1;\n@@ -2745,7 +2778,8 @@ finish_file ()\n \t\t   || (DECL_INLINE (decl) && ! flag_implement_inlines));\n \t    }\n \t}\n-      if (TREE_PUBLIC (decl) || TREE_ADDRESSABLE (decl))\n+      if (TREE_PUBLIC (decl) || TREE_ADDRESSABLE (decl)\n+\t  || flag_keep_inline_functions)\n \t{\n \t  if (DECL_EXTERNAL (decl)\n \t      || (DECL_IMPLICIT_INSTANTIATION (decl)"}, {"sha": "426417acdad9be0ec27f42d4391b489fb3175b86", "filename": "gcc/cp/gxxint.texi", "status": "modified", "additions": 42, "deletions": 18, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2Fgxxint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2Fgxxint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxxint.texi?ref=f0e01782d7d294907fe8f8325bfae9c6fae7a877", "patch": "@@ -24,7 +24,8 @@ Questions and comments to mrs@@cygnus.com.\n * Error Reporting::             \n * Parser::                      \n * Copying Objects::             \n-* Exception Handling::             \n+* Exception Handling::          \n+* Free Store::                  \n * Concept Index::               \n @end menu\n \n@@ -44,22 +45,9 @@ I suspect there are other uses of pushdecl_class_level that do not call\n set_identifier_type_value in tandem with the call to\n pushdecl_class_level.  It would seem to be an omission.\n \n-@cindex delete, two argument\n-@item\n-For two argument delete, the second argument is always calculated by\n-``virtual_size ='' in the source.  It currently has a problem, in that\n-object size is not calculated by the virtual destructor and passed back\n-for the second parameter to delete.  Destructors need to return a value\n-just like constructors.  ANSI C++ Jun 5 92 wp 12.5.6\n-\n-The second argument is magically deleted in build_method_call, if it is\n-not used.  It needs to be deleted for global operator delete also.\n-\n @cindex access checking\n @item\n-Access checking in general is unimplemented, there are a few cases\n-where it is implemented.  grok_enum_decls should be used in more places\n-to do access checking, but this is only the tip of a bigger problem.\n+Access checking is unimplemented for nested types.\n \n @cindex @code{volatile}\n @item\n@@ -1142,7 +1130,7 @@ them.\n This issue is currently under discussion in the core reflector\n (2/28/94).\n \n-@node  Copying Objects, Concept Index, Copying Objects, Top\n+@node  Exception Handling, Free Store, Copying Objects, Top\n @section Exception Handling\n \n This section describes the mapping of C++ exceptions in the C++\n@@ -1155,7 +1143,7 @@ independent representation for exceptions.\n The C++ front-end exceptions are mapping into the unwind-protect\n semantics by the C++ front-end.  The mapping is describe below.\n \n-Objects with RTTI support, should use the RTTI information to do mapping\n+Objects with RTTI support should use the RTTI information to do mapping\n and checking.  Objects without RTTI, like int and const char *, have to\n use another means of matching.  Currently we use the normal mangling used in\n building functions names.  Int's are \"i\", const char * is PCc, etc...\n@@ -1189,7 +1177,43 @@ hit before the section finishes normally, they examine the list for\n actions to perform.  I hope they add this logic into the back-end, as it\n would be nice to get that alternative approach in C++.\n \n-@node Concept Index,  , Exception Handling, Top\n+@node Free Store, Concept Index, Exception Handling, Top\n+@section Free Store\n+\n+operator new [] adds a magic cookie to the beginning of arrays for which\n+the number of elements will be needed by operator delete [].  These are\n+arrays of objects with destructors and arrays of objects that define\n+operator delete [] with the optional size_t argument.  This cookie can\n+be examined from a program as follows:\n+\n+@example\n+typedef unsigned long size_t;\n+extern \"C\" int printf (const char *, ...);\n+\n+size_t nelts (void *p)\n+@{\n+  struct cookie @{\n+    size_t nelts __attribute__ ((aligned (sizeof (double))));\n+  @};\n+\n+  cookie *cp = (cookie *)p;\n+  --cp;\n+\n+  return cp->nelts;\n+@}\n+\n+struct A @{\n+  ~A() @{ @}\n+@};\n+\n+main()\n+@{\n+  A *ap = new A[3];\n+  printf (\"%ld\\n\", nelts (ap));\n+@}\n+@end example\n+\n+@node Concept Index,  , Free Store, Top\n @section Concept Index\n \n @printindex cp"}, {"sha": "5edf65927ad968d5954c0e095f14ebe754b4fe57", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=f0e01782d7d294907fe8f8325bfae9c6fae7a877", "patch": "@@ -3571,10 +3571,7 @@ real_yylex ()\n \t\tvalue = ELLIPSIS;\n \t\tgoto done;\n \t      }\n-\t    nextchar = c1;\n-\t    token_buffer[2] = '\\0';\n-\t    value = RANGE;\n-\t    goto done;\n+\t    error (\"parse error at `..'\");\n \t  }\n \tif (isdigit (c1))\n \t  {\n@@ -3689,10 +3686,7 @@ real_yylex ()\n \t\t\t    value = ELLIPSIS;\n \t\t\t    goto done;\n \t\t\t  }\n-\t\t\tnextchar = c;\n-\t\t\ttoken_buffer[2] = '\\0';\n-\t\t\tvalue = RANGE;\n-\t\t\tgoto done;\n+\t\t\terror (\"parse error at `..'\");\n \t\t      }\n \t\t    nextchar = c;\n \t\t    token_buffer[1] = '\\0';"}, {"sha": "1f26e4cb640bd7a32b88e9b20f043d502239cf64", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=f0e01782d7d294907fe8f8325bfae9c6fae7a877", "patch": "@@ -171,7 +171,7 @@ empty_parms ()\n %left '{' ',' ';'\n \n %right <code> ASSIGN '='\n-%right <code> '?' ':' RANGE\n+%right <code> '?' ':'\n %left <code> OROR\n %left <code> ANDAND\n %left <code> '|'\n@@ -765,9 +765,13 @@ identifier_defn:\n \n explicit_instantiation:\n \t  TEMPLATE specialization template_instantiation\n-\t\t{ do_type_instantiation ($3 ? $3 : $2); }\n+\t\t{ do_type_instantiation ($3 ? $3 : $2, NULL_TREE); }\n \t| TEMPLATE typed_declspecs declarator\n-\t\t{ do_function_instantiation ($2, $3); }\n+\t\t{ do_function_instantiation ($2, $3, NULL_TREE); }\n+\t| SCSPEC TEMPLATE specialization template_instantiation\n+\t\t{ do_type_instantiation ($4 ? $4 : $3, $1); }\n+\t| SCSPEC TEMPLATE typed_declspecs declarator\n+\t\t{ do_function_instantiation ($3, $4, $1); }\n \t;\n \n template_type:\n@@ -3205,7 +3209,7 @@ simple_stmt:\n \t\t  define_case_label (label);\n \t\t}\n \t  stmt\n-\t| CASE expr_no_commas RANGE expr_no_commas ':'\n+\t| CASE expr_no_commas ELLIPSIS expr_no_commas ':'\n \t\t{ register tree value1 = check_cp_case_value ($2);\n \t\t  register tree value2 = check_cp_case_value ($4);\n \t\t  register tree label"}, {"sha": "79d37f7dad3d0cbbfe67761dfadf5864041ce273", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 63, "deletions": 23, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=f0e01782d7d294907fe8f8325bfae9c6fae7a877", "patch": "@@ -37,6 +37,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"cp-tree.h\"\n #include \"decl.h\"\n #include \"parse.h\"\n+#include \"lex.h\"\n \n extern struct obstack permanent_obstack;\n extern tree grokdeclarator ();\n@@ -195,6 +196,7 @@ end_template_decl (d1, d2, is_class, defn)\n   if (is_class)\n     {\n       decl = build_lang_decl (TEMPLATE_DECL, d2, NULL_TREE);\n+      GNU_xref_decl (current_function_decl, decl);\n     }\n   else\n     {\n@@ -243,12 +245,11 @@ end_template_decl (d1, d2, is_class, defn)\n \t}\n \n       /* If this is for a method, there's an extra binding level here.\t*/\n-      if (! DECL_TEMPLATE_IS_CLASS (decl)\n-\t  && DECL_CONTEXT (DECL_TEMPLATE_RESULT (decl)) != NULL_TREE)\n+      if (DECL_CONTEXT (DECL_TEMPLATE_RESULT (decl)) != NULL_TREE)\n \t{\n \t  /* @@ Find out where this should be getting set!  */\n \t  tree r = DECL_TEMPLATE_RESULT (decl);\n-\t  if (DECL_CLASS_CONTEXT (r) == NULL_TREE)\n+\t  if (DECL_LANG_SPECIFIC (r) && DECL_CLASS_CONTEXT (r) == NULL_TREE)\n \t    DECL_CLASS_CONTEXT (r) = DECL_CONTEXT (r);\n \t}\n     }\n@@ -261,8 +262,7 @@ end_template_decl (d1, d2, is_class, defn)\n   \n   /* If context of decl is non-null (i.e., method template), add it\n      to the appropriate class template, and pop the binding levels.  */\n-  if (! DECL_TEMPLATE_IS_CLASS (decl)\n-      && DECL_CONTEXT (DECL_TEMPLATE_RESULT (decl)) != NULL_TREE)\n+  if (! is_class && DECL_CONTEXT (DECL_TEMPLATE_RESULT (decl)) != NULL_TREE)\n     {\n       tree ctx = DECL_CONTEXT (DECL_TEMPLATE_RESULT (decl));\n       tree tmpl, t;\n@@ -1284,6 +1284,13 @@ tsubst (t, args, nargs, in_decl)\n \t\t    fprintf (stderr, \"\\tfound %s\\n\\n\",\n \t\t\t     IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (method)));\n #endif\n+\t\t    if (DECL_ARTIFICIAL (method))\n+\t\t      {\n+\t\t\tcp_error (\"template for method `%D' which has default implementation in class `%T'\", name, ctx);\n+\t\t\tif (in_decl)\n+\t\t\t  cp_error_at (\"in attempt to instantiate `%D' declared at this point in file\", in_decl);\n+\t\t\treturn error_mark_node;\n+\t\t      }\n \n \t\t    if (DECL_ARGUMENTS (method)\n \t\t\t&& ! TREE_PERMANENT (DECL_ARGUMENTS (method)))\n@@ -1614,9 +1621,7 @@ instantiate_template (tmpl, targ_ptr)\n \n       /* Here, we have a match.  */\n       fndecl = TREE_VALUE (fndecl);\n-      function_maybepermanent_obstack = old_fmp_obstack;\n-      pop_obstacks ();\n-      return fndecl;\n+      goto exit;\n \n     no_match:\n       ;\n@@ -1631,10 +1636,12 @@ instantiate_template (tmpl, targ_ptr)\n   fndecl = tsubst (DECL_RESULT (tmpl), targ_ptr,\n \t\t   TREE_VEC_LENGTH (targs), tmpl);\n \n+  if (fndecl == error_mark_node)\n+    goto exit;\n+\n   /* If it's a static member fn in the template, we need to change it\n      into a FUNCTION_TYPE and chop off its this pointer.  */\n   if (TREE_CODE (TREE_TYPE (DECL_RESULT (tmpl))) == METHOD_TYPE\n-      && fndecl != error_mark_node\n       && DECL_STATIC_FUNCTION_P (fndecl))\n     {\n       tree olddecl = DECL_RESULT (tmpl);\n@@ -1693,10 +1700,7 @@ instantiate_template (tmpl, targ_ptr)\n   DECL_TEMPLATE_INSTANTIATIONS (tmpl) =\n     tree_cons (targs, fndecl, DECL_TEMPLATE_INSTANTIATIONS (tmpl));\n \n-  function_maybepermanent_obstack = old_fmp_obstack;\n-  pop_obstacks ();\n-\n-  if (fndecl == error_mark_node || p == (struct pending_inline *)0)\n+  if (p == (struct pending_inline *)0)\n     {\n       /* do nothing */\n     }\n@@ -1711,6 +1715,10 @@ instantiate_template (tmpl, targ_ptr)\n       p->next = pending_template_expansions;\n       pending_template_expansions = p;\n     }\n+ exit:\n+  function_maybepermanent_obstack = old_fmp_obstack;\n+  pop_obstacks ();\n+\n   return fndecl;\n }\n \n@@ -2235,7 +2243,7 @@ do_pending_expansions ()\n \tDECIDE (0);\n \n       if (DECL_EXPLICIT_INSTANTIATION (t))\n-\tDECIDE (1);\n+\tDECIDE (! DECL_EXTERNAL (t));\n       else if (! flag_implicit_templates)\n \tDECIDE (0);\n \n@@ -2335,8 +2343,8 @@ add_pending_template (pt)\n \n /* called from the parser.  */\n void\n-do_function_instantiation (declspecs, declarator)\n-     tree declspecs, declarator;\n+do_function_instantiation (declspecs, declarator, storage)\n+     tree declspecs, declarator, storage;\n {\n   tree decl = grokdeclarator (declarator, declspecs, NORMAL, 0, 0);\n   tree name = DECL_NAME (decl);\n@@ -2371,22 +2379,54 @@ do_function_instantiation (declspecs, declarator)\n \n   SET_DECL_EXPLICIT_INSTANTIATION (result);\n   TREE_PUBLIC (result) = 1;\n-  DECL_EXTERNAL (result) = DECL_INLINE (result) && ! flag_implement_inlines;\n+\n+  if (storage == NULL_TREE)\n+    DECL_EXTERNAL (result) = DECL_INLINE (result) && ! flag_implement_inlines;\n+  else if (storage == ridpointers[(int) RID_EXTERN])\n+    DECL_EXTERNAL (result) = 1;\n+  else\n+    cp_error (\"storage class `%D' applied to template instantiation\",\n+\t      storage);\n }\n \n void\n-do_type_instantiation (name)\n-     tree name;\n+do_type_instantiation (name, storage)\n+     tree name, storage;\n {\n   tree t = TREE_TYPE (name);\n+  int extern_p;\n \n   if (flag_external_templates)\n     return;\n \n+  if (TYPE_SIZE (t) == NULL_TREE)\n+    {\n+      cp_error (\"explicit instantiation of `%#T' before definition of template\",\n+\t\tt);\n+      return;\n+    }\n+\n+  if (storage == NULL_TREE)\n+    extern_p = 0;\n+  else if (storage == ridpointers[(int) RID_EXTERN])\n+    extern_p = 1;\n+  else\n+    {\n+      cp_error (\"storage class `%D' applied to template instantiation\",\n+\t\tstorage);\n+      extern_p = 0;\n+    }\n+\n   SET_CLASSTYPE_EXPLICIT_INSTANTIATION (t);\n-  CLASSTYPE_VTABLE_NEEDS_WRITING (t) = 1;\n+  CLASSTYPE_VTABLE_NEEDS_WRITING (t) = ! extern_p;\n   SET_CLASSTYPE_INTERFACE_KNOWN (t);\n-  CLASSTYPE_INTERFACE_ONLY (t) = 0;\n+  CLASSTYPE_INTERFACE_ONLY (t) = extern_p;\n+  if (! extern_p)\n+    {\n+      CLASSTYPE_DEBUG_REQUESTED (t) = 1;\n+      TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (t)) = 0;\n+      rest_of_type_compilation (t, 1);\n+    }\n \n   /* this should really be done by instantiate_member_templates */\n   {\n@@ -2395,8 +2435,8 @@ do_type_instantiation (name)\n       {\n \tSET_DECL_EXPLICIT_INSTANTIATION (method);\n \tTREE_PUBLIC (method) = 1;\n-\tDECL_EXTERNAL (method) = (DECL_INLINE (method)\n-\t\t\t\t  && ! flag_implement_inlines);\n+\tDECL_EXTERNAL (method)\n+\t  = (extern_p || (DECL_INLINE (method) && ! flag_implement_inlines));\n       }\n   }\n "}, {"sha": "c4c6a4ea7c16be305ecf2d7534e86bbd978deffc", "filename": "gcc/cp/search.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=f0e01782d7d294907fe8f8325bfae9c6fae7a877", "patch": "@@ -594,7 +594,7 @@ get_base_distance (parent, binfo, protect, path_ptr)\n \n   if (TREE_CODE (binfo) == TREE_VEC)\n     type = BINFO_TYPE (binfo);\n-  else if (TREE_CODE (binfo) == RECORD_TYPE)\n+  else if (IS_AGGR_TYPE_CODE (TREE_CODE (binfo)))\n     {\n       type = binfo;\n       binfo = TYPE_BINFO (type);\n@@ -2366,10 +2366,8 @@ dfs_debug_mark (binfo)\n     }\n   /* We cannot rely on some alien method to solve our problems,\n      so we must write out the debug info ourselves.  */\n-  if (write_symbols != DWARF_DEBUG)\n-    TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (t)) = 0;\n-  if (! TREE_ASM_WRITTEN (TYPE_NAME (t)))\n-    rest_of_type_compilation (t, global_bindings_p ());\n+  TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (t)) = 0;\n+  rest_of_type_compilation (t, global_bindings_p ());\n }\n \f\n /*  Attach to the type of the virtual base class, the pointer to the"}, {"sha": "5805d36d5111a27e618e8abc2678622f243874f5", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=f0e01782d7d294907fe8f8325bfae9c6fae7a877", "patch": "@@ -486,6 +486,7 @@ layout_vbasetypes (rec, max)\n #else\n   unsigned record_align = MAX (BITS_PER_UNIT, TYPE_ALIGN (rec));\n #endif\n+  int desired_align;\n \n   /* Record size so far is CONST_SIZE + VAR_SIZE bits,\n      where CONST_SIZE is an integer\n@@ -512,17 +513,25 @@ layout_vbasetypes (rec, max)\n       tree basetype = BINFO_TYPE (vbase_types);\n       tree offset;\n \n+      desired_align = TYPE_ALIGN (basetype);\n+      record_align = MAX (record_align, desired_align);\n+\n       if (const_size == 0)\n \toffset = integer_zero_node;\n       else\n-\toffset = size_int ((const_size + BITS_PER_UNIT - 1) / BITS_PER_UNIT);\n+\t{\n+\t  /* Give each virtual base type the alignment it wants.  */\n+\t  const_size = CEIL (const_size, TYPE_ALIGN (basetype))\n+\t    * TYPE_ALIGN (basetype);\n+\t  offset = size_int (CEIL (const_size, BITS_PER_UNIT));\n+\t}\n \n       if (CLASSTYPE_VSIZE (basetype) > max)\n \tmax = CLASSTYPE_VSIZE (basetype);\n       BINFO_OFFSET (vbase_types) = offset;\n \n       if (TREE_CODE (TYPE_SIZE (basetype)) == INTEGER_CST)\n-\tconst_size += MAX (record_align,\n+\tconst_size += MAX (BITS_PER_UNIT,\n \t\t\t   TREE_INT_CST_LOW (TYPE_SIZE (basetype))\n \t\t\t   - TREE_INT_CST_LOW (CLASSTYPE_VBASE_SIZE (basetype)));\n       else if (var_size == 0)\n@@ -533,6 +542,9 @@ layout_vbasetypes (rec, max)\n       vbase_types = TREE_CHAIN (vbase_types);\n     }\n \n+  /* Set the alignment in the complete type.  We don't set CLASSTYPE_ALIGN\n+   here, as that is for this class, without any virtual base classes.  */\n+  TYPE_ALIGN (rec) = record_align;\n   if (const_size != nonvirtual_const_size)\n     {\n       CLASSTYPE_VBASE_SIZE (rec)"}, {"sha": "746bcd855ada5f6a50a9a814c069cae69906ab48", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=f0e01782d7d294907fe8f8325bfae9c6fae7a877", "patch": "@@ -3990,6 +3990,8 @@ build_unary_op (code, xarg, noconvert)\n \t  case FIX_CEIL_EXPR:\n \t    {\n \t      tree incremented, modify, value;\n+\t      if (! lvalue_p (arg) && pedantic)\n+\t\tpedwarn (\"cast to non-reference type used as lvalue\");\n \t      arg = stabilize_reference (arg);\n \t      if (code == PREINCREMENT_EXPR || code == PREDECREMENT_EXPR)\n \t\tvalue = arg;\n@@ -4143,11 +4145,6 @@ build_unary_op (code, xarg, noconvert)\n       if (val != 0)\n \treturn val;\n \n-#if 0 /* Turned off because inconsistent;\n-\t float f; *&(int)f = 3.4 stores in int format\n-\t whereas (int)f = 3.4 stores in float format.  */\n-      /* Address of a cast is just a cast of the address\n-\t of the operand of the cast.  */\n       switch (TREE_CODE (arg))\n \t{\n \tcase NOP_EXPR:\n@@ -4157,12 +4154,9 @@ build_unary_op (code, xarg, noconvert)\n \tcase FIX_FLOOR_EXPR:\n \tcase FIX_ROUND_EXPR:\n \tcase FIX_CEIL_EXPR:\n-\t  if (pedantic)\n-\t    pedwarn (\"ANSI C++ forbids taking the address of a cast expression\");\n-\t  return convert (build_pointer_type (TREE_TYPE (arg)),\n-\t\t\t  build_unary_op (ADDR_EXPR, TREE_OPERAND (arg, 0), 0));\n+\t  if (! lvalue_p (arg) && pedantic)\n+\t    pedwarn (\"taking the address of a cast to non-reference type\");\n \t}\n-#endif\n \n       /* Allow the address of a constructor if all the elements\n \t are constant.  */\n@@ -4950,21 +4944,12 @@ build_c_cast (type, expr)\n       return error_mark_node;\n     }\n \n-  if (TREE_TYPE (value)\n-      && TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (value)))\n-    return build1 (NOP_EXPR, type, value);\n-\n   /* If there's only one function in the overloaded space,\n      just take it.  */\n   if (TREE_CODE (value) == TREE_LIST\n       && TREE_CHAIN (value) == NULL_TREE)\n     value = TREE_VALUE (value);\n \n-  /* Make up for the fact that we do not always perform\n-     `default_conversion' anymore.  */\n-  if (TREE_READONLY_DECL_P (value))\n-    value = decl_constant_value (value);\n-\n   if (TREE_CODE (type) == VOID_TYPE)\n     value = build1 (NOP_EXPR, type, value);\n   else if (TREE_TYPE (value) == NULL_TREE\n@@ -5579,7 +5564,7 @@ build_modify_expr (lhs, modifycode, rhs)\n \t\t\t\t\t     convert (lhstype, newrhs)));\n \tif (TREE_CODE (result) == ERROR_MARK)\n \t  return result;\n-\treturn convert_force (TREE_TYPE (lhs), result);\n+\treturn convert (TREE_TYPE (lhs), result);\n       }\n     }\n "}, {"sha": "2fe60403b6d78fb47d2df444bb0c7ce48791379d", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=f0e01782d7d294907fe8f8325bfae9c6fae7a877", "patch": "@@ -329,7 +329,7 @@ ack (s, v, v2)\n    silly.  So instead, we just do the equivalent of a call to fatal in the\n    same situation (call exit).  */\n \n-/* First used: 0 (reserved), Last used: 357.  Free:  */\n+/* First used: 0 (reserved), Last used: 358.  Free:  */\n \n static int abortcount = 0;\n \n@@ -1496,6 +1496,7 @@ enum_name_string (value, type)\n   return IDENTIFIER_POINTER (TREE_PURPOSE (values));\n }\n \n+#if 0\n /* Print out a language-specific error message for\n    (Pascal) case or (C) switch statements.\n    CODE tells what sort of message to print. \n@@ -1598,3 +1599,4 @@ report_case_error (code, type, new_value, old_value)\n \terror (\"range values reversed\");\n     }\n }\n+#endif"}, {"sha": "283771b1cf7ae12b659727d9452f8a241e726a17", "filename": "gcc/cp/xref.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2Fxref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0e01782d7d294907fe8f8325bfae9c6fae7a877/gcc%2Fcp%2Fxref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fxref.c?ref=f0e01782d7d294907fe8f8325bfae9c6fae7a877", "patch": "@@ -397,6 +397,18 @@ GNU_xref_decl (fndecl,decl)\n       decl = TYPE_NAME (decl);\n       uselin = TRUE;\n     }\n+  else if (TREE_CODE (decl) == TEMPLATE_DECL)\n+    {\n+      if (DECL_TEMPLATE_IS_CLASS (decl))\n+\tcls = \"CLASSTEMP\";\n+      else if (TREE_CODE (DECL_RESULT (decl)) == FUNCTION_DECL)\n+\tcls = \"FUNCTEMP\";\n+      else if (TREE_CODE (DECL_RESULT (decl)) == VAR_DECL)\n+\tcls = \"VARTEMP\";\n+      else\n+\tmy_friendly_abort (358);\n+      uselin = TRUE;\n+    }\n   else cls = \"UNKNOWN\";\n \n   if (decl == NULL || DECL_NAME (decl) == NULL) return;"}]}