{"sha": "01bd58f51858c375e5814e3937aa2c57fbbc9bdc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFiZDU4ZjUxODU4YzM3NWU1ODE0ZTM5MzdhYTJjNTdmYmJjOWJkYw==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2018-07-17T08:07:00Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-07-17T08:07:00Z"}, "message": "[Ada] Secondary stack leak in statements block located in a loop\n\nWhen a loop iterator has a block declaration containing statements that invoke\nfunctions whose result is returned on the secondary stack (such as a\nstring-returning function), the compiler fails to generate code to release the\nallocated memory when the loop terminates.\n\nAfter this patch the following test works fine.\n\nwith Ada.Text_IO; use Ada.Text_IO;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\npragma Warnings (Off);\nwith System.Secondary_Stack;\npragma Warnings (On);\n\nprocedure Small is\n   procedure Info is new System.Secondary_Stack.Ss_Info (Put_Line);\n\n   US : Unbounded_String;\nbegin\n   Info;\n   for J in 1 .. 100_000 loop\n      Leaky_Block : declare\n      begin\n         if (J mod 20000) = 0 then\n            Info;\n         end if;\n\n         Ada.Text_IO.Put_Line (To_String (US));  --  Test\n\n         if (J mod 20000) = 0 then\n            Info;\n         end if;\n      end Leaky_Block;\n   end loop;\n   Info;\nend;\n\nCommand:\n  gnatmake small.adb; small | grep \"Current allocated space :\" | uniq\nOutput:\n  Current allocated space :  0 bytes\n\n2018-07-17  Javier Miranda  <miranda@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch7.adb (Make_Transient_Block): When determining whether an\n\tenclosing scope already handles the secondary stack, take into account\n\ttransient blocks nested in a block that do not manage the secondary\n\tstack and are located within a loop.\n\nFrom-SVN: r262779", "tree": {"sha": "741aaee4e5d6357b48cea2a1c04482a60ed4a523", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/741aaee4e5d6357b48cea2a1c04482a60ed4a523"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01bd58f51858c375e5814e3937aa2c57fbbc9bdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01bd58f51858c375e5814e3937aa2c57fbbc9bdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01bd58f51858c375e5814e3937aa2c57fbbc9bdc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01bd58f51858c375e5814e3937aa2c57fbbc9bdc/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3567ca3f6be029d5a68722b675df74c2c6945854", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3567ca3f6be029d5a68722b675df74c2c6945854", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3567ca3f6be029d5a68722b675df74c2c6945854"}], "stats": {"total": 41, "additions": 41, "deletions": 0}, "files": [{"sha": "af38e50fa5fa8b16afabdb2cb9aff26fbf10d5cf", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01bd58f51858c375e5814e3937aa2c57fbbc9bdc/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01bd58f51858c375e5814e3937aa2c57fbbc9bdc/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=01bd58f51858c375e5814e3937aa2c57fbbc9bdc", "patch": "@@ -1,3 +1,10 @@\n+2018-07-17  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch7.adb (Make_Transient_Block): When determining whether an\n+\tenclosing scope already handles the secondary stack, take into account\n+\ttransient blocks nested in a block that do not manage the secondary\n+\tstack and are located within a loop.\n+\n 2018-07-17  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_util.adb (Enclosing_Subprogram): Protected entries and task"}, {"sha": "781456fdfea94dc90ea87b1a1e4c50c0c78170d1", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01bd58f51858c375e5814e3937aa2c57fbbc9bdc/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01bd58f51858c375e5814e3937aa2c57fbbc9bdc/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=01bd58f51858c375e5814e3937aa2c57fbbc9bdc", "patch": "@@ -8695,9 +8695,33 @@ package body Exp_Ch7 is\n       Action : Node_Id;\n       Par    : Node_Id) return Node_Id\n    is\n+      function Within_Loop_Statement (N : Node_Id) return Boolean;\n+      --  Return True when N appears within a loop and no block is containing N\n+\n       function Manages_Sec_Stack (Id : Entity_Id) return Boolean;\n       --  Determine whether scoping entity Id manages the secondary stack\n \n+      ---------------------------\n+      -- Within_Loop_Statement --\n+      ---------------------------\n+\n+      function Within_Loop_Statement (N : Node_Id) return Boolean is\n+         Par : Node_Id := Parent (N);\n+\n+      begin\n+         while not (Nkind_In (Par,\n+                              N_Loop_Statement,\n+                              N_Handled_Sequence_Of_Statements,\n+                              N_Package_Specification)\n+                      or else Nkind (Par) in N_Proper_Body)\n+         loop\n+            pragma Assert (Present (Par));\n+            Par := Parent (Par);\n+         end loop;\n+\n+         return Nkind (Par) = N_Loop_Statement;\n+      end Within_Loop_Statement;\n+\n       -----------------------\n       -- Manages_Sec_Stack --\n       -----------------------\n@@ -8780,6 +8804,16 @@ package body Exp_Ch7 is\n             elsif Ekind (Scop) = E_Loop then\n                exit;\n \n+            --  Ditto when the block appears without a block that does not\n+            --  manage the secondary stack and is located within a loop.\n+\n+            elsif Ekind (Scop) = E_Block\n+              and then not Manages_Sec_Stack (Scop)\n+              and then Present (Block_Node (Scop))\n+              and then Within_Loop_Statement (Block_Node (Scop))\n+            then\n+               exit;\n+\n             --  The transient block does not need to manage the secondary stack\n             --  when there is an enclosing construct which already does that.\n             --  This optimization saves on SS_Mark and SS_Release calls but may"}]}