{"sha": "5317d2f8b42652dbd7acf1eea432c8adc56ecca5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTMxN2QyZjhiNDI2NTJkYmQ3YWNmMWVlYTQzMmM4YWRjNTZlY2NhNQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-11-15T23:57:29Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-11-15T23:57:29Z"}, "message": "(redundant_insn_p): Change return type to rtx.\n\n(redundant_insn_p): Change return type to rtx.  Return the redundant insn\ninstead of true.\n(update_reg_unused_notes): New function.\n(fill_slots_from_thread): Call update_reg_unused_notes after one of the\nredundant_insn_p calls.\n\nFrom-SVN: r8446", "tree": {"sha": "b67e824f13ec315a2758ccc4e20881f658022b08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b67e824f13ec315a2758ccc4e20881f658022b08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5317d2f8b42652dbd7acf1eea432c8adc56ecca5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5317d2f8b42652dbd7acf1eea432c8adc56ecca5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5317d2f8b42652dbd7acf1eea432c8adc56ecca5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5317d2f8b42652dbd7acf1eea432c8adc56ecca5/comments", "author": null, "committer": null, "parents": [{"sha": "e31492751a579505293cb346b01ac132a422aa68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e31492751a579505293cb346b01ac132a422aa68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e31492751a579505293cb346b01ac132a422aa68"}], "stats": {"total": 45, "additions": 39, "deletions": 6}, "files": [{"sha": "9fe88faf116f29bf98084f25006061f17701566d", "filename": "gcc/reorg.c", "status": "modified", "additions": 39, "deletions": 6, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5317d2f8b42652dbd7acf1eea432c8adc56ecca5/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5317d2f8b42652dbd7acf1eea432c8adc56ecca5/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=5317d2f8b42652dbd7acf1eea432c8adc56ecca5", "patch": "@@ -244,12 +244,13 @@ static rtx steal_delay_list_from_fallthrough PROTO((rtx, rtx, rtx, rtx,\n \t\t\t\t\t\t    struct resources *,\n \t\t\t\t\t\t    int, int *, int *));\n static void try_merge_delay_insns PROTO((rtx, rtx));\n-static int redundant_insn_p\tPROTO((rtx, rtx, rtx));\n+static rtx redundant_insn_p\tPROTO((rtx, rtx, rtx));\n static int own_thread_p\t\tPROTO((rtx, rtx, int));\n static int find_basic_block\tPROTO((rtx));\n static void update_block\tPROTO((rtx, rtx));\n static int reorg_redirect_jump PROTO((rtx, rtx));\n static void update_reg_dead_notes PROTO((rtx, rtx));\n+static void update_reg_unused_notes PROTO((rtx, rtx));\n static void update_live_status\tPROTO((rtx, rtx));\n static rtx next_insn_no_annul\tPROTO((rtx));\n static void mark_target_live_regs PROTO((rtx, struct resources *));\n@@ -1922,7 +1923,7 @@ try_merge_delay_insns (insn, thread)\n    redundant insn, but the cost of splitting seems greater than the possible\n    gain in rare cases.  */\n \n-static int\n+static rtx\n redundant_insn_p (insn, target, delay_list)\n      rtx insn;\n      rtx target;\n@@ -2079,7 +2080,7 @@ redundant_insn_p (insn, target, delay_list)\n \t\t{\n \t\t  /* Show that this insn will be used in the sequel.  */\n \t\t  INSN_FROM_TARGET_P (candidate) = 0;\n-\t\t  return 1;\n+\t\t  return candidate;\n \t\t}\n \n \t      /* Unless this is an annulled insn from the target of a branch,\n@@ -2101,7 +2102,7 @@ redundant_insn_p (insn, target, delay_list)\n \t  /* See if TRIAL is the same as INSN.  */\n \t  pat = PATTERN (trial);\n \t  if (rtx_equal_p (pat, ipat))\n-\t    return 1;\n+\t    return trial;\n \n \t  /* Can't go any further if TRIAL conflicts with INSN.  */\n \t  if (insn_sets_resource_p (trial, &needed, 1))\n@@ -2276,6 +2277,33 @@ update_reg_dead_notes (insn, delayed_insn)\n \t  }\n       }\n }\n+\n+/* Delete any REG_UNUSED notes that exist on INSN but not on REDUNDANT_INSN.\n+\n+   This handles the case of udivmodXi4 instructions which optimize their\n+   output depending on whether any REG_UNUSED notes are present.\n+   we must make sure that INSN calculates as many results as REDUNDANT_INSN\n+   does.  */\n+\n+static void\n+update_reg_unused_notes (insn, redundant_insn)\n+     rtx insn, redundant_insn;\n+{\n+  rtx p, link, next;\n+\n+  for (link = REG_NOTES (insn); link; link = next)\n+    {\n+      next = XEXP (link, 1);\n+\n+      if (REG_NOTE_KIND (link) != REG_UNUSED\n+\t  || GET_CODE (XEXP (link, 0)) != REG)\n+\tcontinue;\n+\n+      if (! find_regno_note (redundant_insn, REG_UNUSED,\n+\t\t\t     REGNO (XEXP (link, 0))))\n+\tremove_note (insn, link);\n+    }\n+}\n \f\n /* Marks registers possibly live at the current place being scanned by\n    mark_target_live_regs.  Used only by next two function.    */\n@@ -3279,10 +3307,12 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n #endif\n \t  )\n \t{\n+\t  rtx prior_insn;\n+\n \t  /* If TRIAL is redundant with some insn before INSN, we don't\n \t     actually need to add it to the delay list; we can merely pretend\n \t     we did.  */\n-\t  if (redundant_insn_p (trial, insn, delay_list))\n+\t  if (prior_insn = redundant_insn_p (trial, insn, delay_list))\n \t    {\n \t      if (own_thread)\n \t\t{\n@@ -3297,7 +3327,10 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n \t\t  delete_insn (trial);\n \t\t}\n \t      else\n-\t\tnew_thread = next_active_insn (trial);\n+\t\t{\n+\t\t  update_reg_unused_notes (prior_insn, trial);\n+\t\t  new_thread = next_active_insn (trial);\n+\t\t}\n \n \t      continue;\n \t    }"}]}