{"sha": "02f5d6c5e36ea6a41e22f39209248bc1039759b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJmNWQ2YzVlMzZlYTZhNDFlMjJmMzkyMDkyNDhiYzEwMzk3NTliNw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-08-23T12:40:57Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-08-23T12:40:57Z"}, "message": "Makefile.in (tree-data-ref.o): Add tree-affine.h dependency.\n\n2011-08-23  Richard Guenther  <rguenther@suse.de>\n\n\t* Makefile.in (tree-data-ref.o): Add tree-affine.h dependency.\n\t* tree-affine.h (aff_comb_cannot_overlap_p): Declare.\n\t* tree-affine.c (aff_comb_cannot_overlap_p): New function, moved\n\tfrom ...\n\t* tree-ssa-loop-im.c (cannot_overlap_p): ... here.\n\t(mem_refs_may_alias_p): Adjust.\n\t* tree-data-ref.h (dr_may_alias_p): Adjust.\n\t* tree-data-ref.c: Include tree-affine.h.\n\t(dr_analyze_indices): Do nothing for the non-loop case.\n\t(dr_may_alias_p): Distinguish loop and non-loop case.  Disambiguate\n\tmore cases in the non-loop case.\n\t* graphite-sese-to-poly.c (write_alias_graph_to_ascii_dimacs): Adjust\n\tcalls to dr_may_alias_p.\n\t(write_alias_graph_to_ascii_ecc): Likewise.\n\t(write_alias_graph_to_ascii_dot): Likewise.\n\t(build_alias_set_optimal_p): Likewise.\n\nFrom-SVN: r177986", "tree": {"sha": "ef30b2e656f6d882ebaac0ac1bf93bba51c441f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef30b2e656f6d882ebaac0ac1bf93bba51c441f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02f5d6c5e36ea6a41e22f39209248bc1039759b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02f5d6c5e36ea6a41e22f39209248bc1039759b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02f5d6c5e36ea6a41e22f39209248bc1039759b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02f5d6c5e36ea6a41e22f39209248bc1039759b7/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0fcbc86b5586c3c3bc370d43b2dea98108fd9796", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fcbc86b5586c3c3bc370d43b2dea98108fd9796", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fcbc86b5586c3c3bc370d43b2dea98108fd9796"}], "stats": {"total": 138, "additions": 90, "deletions": 48}, "files": [{"sha": "5ab9d0c3af354b9c175a8e0abfa711b8f61f77b7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02f5d6c5e36ea6a41e22f39209248bc1039759b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02f5d6c5e36ea6a41e22f39209248bc1039759b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=02f5d6c5e36ea6a41e22f39209248bc1039759b7", "patch": "@@ -1,3 +1,22 @@\n+2011-08-23  Richard Guenther  <rguenther@suse.de>\n+\n+\t* Makefile.in (tree-data-ref.o): Add tree-affine.h dependency.\n+\t* tree-affine.h (aff_comb_cannot_overlap_p): Declare.\n+\t* tree-affine.c (aff_comb_cannot_overlap_p): New function, moved\n+\tfrom ...\n+\t* tree-ssa-loop-im.c (cannot_overlap_p): ... here.\n+\t(mem_refs_may_alias_p): Adjust.\n+\t* tree-data-ref.h (dr_may_alias_p): Adjust.\n+\t* tree-data-ref.c: Include tree-affine.h.\n+\t(dr_analyze_indices): Do nothing for the non-loop case.\n+\t(dr_may_alias_p): Distinguish loop and non-loop case.  Disambiguate\n+\tmore cases in the non-loop case.\n+\t* graphite-sese-to-poly.c (write_alias_graph_to_ascii_dimacs): Adjust\n+\tcalls to dr_may_alias_p.\n+\t(write_alias_graph_to_ascii_ecc): Likewise.\n+\t(write_alias_graph_to_ascii_dot): Likewise.\n+\t(build_alias_set_optimal_p): Likewise.\n+\n 2011-08-23  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/50162"}, {"sha": "15c73c63381a8e64baddbcd1c65aaf0116445fc9", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02f5d6c5e36ea6a41e22f39209248bc1039759b7/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02f5d6c5e36ea6a41e22f39209248bc1039759b7/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=02f5d6c5e36ea6a41e22f39209248bc1039759b7", "patch": "@@ -2690,7 +2690,7 @@ tree-scalar-evolution.o : tree-scalar-evolution.c $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_PASS_H) $(PARAMS_H) gt-tree-scalar-evolution.h\n tree-data-ref.o : tree-data-ref.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    gimple-pretty-print.h $(TREE_FLOW_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) \\\n-   $(TREE_PASS_H) langhooks.h\n+   $(TREE_PASS_H) langhooks.h tree-affine.h\n sese.o : sese.c sese.h $(CONFIG_H) $(SYSTEM_H) coretypes.h tree-pretty-print.h \\\n    $(TREE_FLOW_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) tree-pass.h value-prof.h\n graphite.o : graphite.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(DIAGNOSTIC_CORE_H) \\"}, {"sha": "d9bcf2783072328368fd864c9924ead11824f097", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02f5d6c5e36ea6a41e22f39209248bc1039759b7/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02f5d6c5e36ea6a41e22f39209248bc1039759b7/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=02f5d6c5e36ea6a41e22f39209248bc1039759b7", "patch": "@@ -1720,7 +1720,7 @@ write_alias_graph_to_ascii_dimacs (FILE *file, char *comment,\n \n   FOR_EACH_VEC_ELT (data_reference_p, drs, i, dr1)\n     for (j = i + 1; VEC_iterate (data_reference_p, drs, j, dr2); j++)\n-      if (dr_may_alias_p (dr1, dr2))\n+      if (dr_may_alias_p (dr1, dr2, true))\n \tedge_num++;\n \n   fprintf (file, \"$\\n\");\n@@ -1732,7 +1732,7 @@ write_alias_graph_to_ascii_dimacs (FILE *file, char *comment,\n \n   FOR_EACH_VEC_ELT (data_reference_p, drs, i, dr1)\n     for (j = i + 1; VEC_iterate (data_reference_p, drs, j, dr2); j++)\n-      if (dr_may_alias_p (dr1, dr2))\n+      if (dr_may_alias_p (dr1, dr2, true))\n \tfprintf (file, \"e %d %d\\n\", i + 1, j + 1);\n \n   return true;\n@@ -1762,7 +1762,7 @@ write_alias_graph_to_ascii_dot (FILE *file, char *comment,\n \n   FOR_EACH_VEC_ELT (data_reference_p, drs, i, dr1)\n     for (j = i + 1; VEC_iterate (data_reference_p, drs, j, dr2); j++)\n-      if (dr_may_alias_p (dr1, dr2))\n+      if (dr_may_alias_p (dr1, dr2, true))\n \tfprintf (file, \"n%d n%d\\n\", i, j);\n \n   return true;\n@@ -1788,7 +1788,7 @@ write_alias_graph_to_ascii_ecc (FILE *file, char *comment,\n \n   FOR_EACH_VEC_ELT (data_reference_p, drs, i, dr1)\n     for (j = i + 1; VEC_iterate (data_reference_p, drs, j, dr2); j++)\n-      if (dr_may_alias_p (dr1, dr2))\n+      if (dr_may_alias_p (dr1, dr2, true))\n \tfprintf (file, \"%d %d\\n\", i, j);\n \n   return true;\n@@ -1824,7 +1824,7 @@ build_alias_set_optimal_p (VEC (data_reference_p, heap) *drs)\n \n   FOR_EACH_VEC_ELT (data_reference_p, drs, i, dr1)\n     for (j = i+1; VEC_iterate (data_reference_p, drs, j, dr2); j++)\n-      if (dr_may_alias_p (dr1, dr2))\n+      if (dr_may_alias_p (dr1, dr2, true))\n \t{\n \t  add_edge (g, i, j);\n \t  add_edge (g, j, i);"}, {"sha": "69cce2e7e6104a4ee61e15a8d6e04b46dece4084", "filename": "gcc/tree-affine.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02f5d6c5e36ea6a41e22f39209248bc1039759b7/gcc%2Ftree-affine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02f5d6c5e36ea6a41e22f39209248bc1039759b7/gcc%2Ftree-affine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.c?ref=02f5d6c5e36ea6a41e22f39209248bc1039759b7", "patch": "@@ -887,3 +887,30 @@ get_inner_reference_aff (tree ref, aff_tree *addr, double_int *size)\n   *size = shwi_to_double_int ((bitsize + BITS_PER_UNIT - 1) / BITS_PER_UNIT);\n }\n \n+/* Returns true if a region of size SIZE1 at position 0 and a region of\n+   size SIZE2 at position DIFF cannot overlap.  */\n+\n+bool\n+aff_comb_cannot_overlap_p (aff_tree *diff, double_int size1, double_int size2)\n+{\n+  double_int d, bound;\n+\n+  /* Unless the difference is a constant, we fail.  */\n+  if (diff->n != 0)\n+    return false;\n+\n+  d = diff->offset;\n+  if (double_int_negative_p (d))\n+    {\n+      /* The second object is before the first one, we succeed if the last\n+\t element of the second object is before the start of the first one.  */\n+      bound = double_int_add (d, double_int_add (size2, double_int_minus_one));\n+      return double_int_negative_p (bound);\n+    }\n+  else\n+    {\n+      /* We succeed if the second object starts after the first one ends.  */\n+      return double_int_scmp (size1, d) <= 0;\n+    }\n+}\n+"}, {"sha": "8cfbd691d9e59c2e36d274ac023db47a312b3702", "filename": "gcc/tree-affine.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02f5d6c5e36ea6a41e22f39209248bc1039759b7/gcc%2Ftree-affine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02f5d6c5e36ea6a41e22f39209248bc1039759b7/gcc%2Ftree-affine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.h?ref=02f5d6c5e36ea6a41e22f39209248bc1039759b7", "patch": "@@ -76,6 +76,7 @@ void tree_to_aff_combination_expand (tree, tree, aff_tree *,\n \t\t\t\t     struct pointer_map_t **);\n void get_inner_reference_aff (tree, aff_tree *, double_int *);\n void free_affine_expand_cache (struct pointer_map_t **);\n+bool aff_comb_cannot_overlap_p (aff_tree *, double_int, double_int);\n \n /* Debugging functions.  */\n void print_aff (FILE *, aff_tree *);"}, {"sha": "2c488ab400d2fb578f6a2680b90dfb5be42820b6", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 35, "deletions": 13, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02f5d6c5e36ea6a41e22f39209248bc1039759b7/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02f5d6c5e36ea6a41e22f39209248bc1039759b7/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=02f5d6c5e36ea6a41e22f39209248bc1039759b7", "patch": "@@ -84,6 +84,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-scalar-evolution.h\"\n #include \"tree-pass.h\"\n #include \"langhooks.h\"\n+#include \"tree-affine.h\"\n \n static struct datadep_stats\n {\n@@ -841,8 +842,14 @@ dr_analyze_indices (struct data_reference *dr, loop_p nest, loop_p loop)\n   tree base, off, access_fn = NULL_TREE;\n   basic_block before_loop = NULL;\n \n-  if (nest)\n-    before_loop = block_before_loop (nest);\n+  if (!nest)\n+    {\n+      DR_BASE_OBJECT (dr) = ref;\n+      DR_ACCESS_FNS (dr) = NULL;\n+      return;\n+    }\n+\n+  before_loop = block_before_loop (nest);\n \n   /* Analyze access functions of dimensions we know to be independent.  */\n   while (handled_component_p (aref))\n@@ -852,12 +859,9 @@ dr_analyze_indices (struct data_reference *dr, loop_p nest, loop_p loop)\n       if (TREE_CODE (aref) == ARRAY_REF)\n \t{\n \t  op = TREE_OPERAND (aref, 1);\n-\t  if (nest)\n-\t    {\n-\t      access_fn = analyze_scalar_evolution (loop, op);\n-\t      access_fn = instantiate_scev (before_loop, loop, access_fn);\n-\t      VEC_safe_push (tree, heap, access_fns, access_fn);\n-\t    }\n+\t  access_fn = analyze_scalar_evolution (loop, op);\n+\t  access_fn = instantiate_scev (before_loop, loop, access_fn);\n+\t  VEC_safe_push (tree, heap, access_fns, access_fn);\n \t  TREE_OPERAND (aref, 1) = build_int_cst (TREE_TYPE (op), 0);\n \t}\n       /* REALPART_EXPR and IMAGPART_EXPR can be handled like accesses\n@@ -877,8 +881,7 @@ dr_analyze_indices (struct data_reference *dr, loop_p nest, loop_p loop)\n       aref = TREE_OPERAND (aref, 0);\n     }\n \n-  if (nest\n-      && TREE_CODE (aref) == MEM_REF)\n+  if (TREE_CODE (aref) == MEM_REF)\n     {\n       op = TREE_OPERAND (aref, 0);\n       access_fn = analyze_scalar_evolution (loop, op);\n@@ -1286,14 +1289,33 @@ object_address_invariant_in_loop_p (const struct loop *loop, const_tree obj)\n }\n \n /* Returns false if we can prove that data references A and B do not alias,\n-   true otherwise.  */\n+   true otherwise.  If LOOP_NEST is false no cross-iteration aliases are\n+   considered.  */\n \n bool\n-dr_may_alias_p (const struct data_reference *a, const struct data_reference *b)\n+dr_may_alias_p (const struct data_reference *a, const struct data_reference *b,\n+\t\tbool loop_nest)\n {\n   tree addr_a = DR_BASE_OBJECT (a);\n   tree addr_b = DR_BASE_OBJECT (b);\n \n+  /* If we are not processing a loop nest but scalar code we\n+     do not need to care about possible cross-iteration dependences\n+     and thus can process the full original reference.  Do so,\n+     similar to how loop invariant motion applies extra offset-based\n+     disambiguation.  */\n+  if (!loop_nest)\n+    {\n+      aff_tree off1, off2;\n+      double_int size1, size2;\n+      get_inner_reference_aff (DR_REF (a), &off1, &size1);\n+      get_inner_reference_aff (DR_REF (b), &off2, &size2);\n+      aff_combination_scale (&off1, double_int_minus_one);\n+      aff_combination_add (&off2, &off1);\n+      if (aff_comb_cannot_overlap_p (&off2, size1, size2))\n+\treturn false;\n+    }\n+\n   if (DR_IS_WRITE (a) && DR_IS_WRITE (b))\n     return refs_output_dependent_p (addr_a, addr_b);\n   else if (DR_IS_READ (a) && DR_IS_WRITE (b))\n@@ -1331,7 +1353,7 @@ initialize_data_dependence_relation (struct data_reference *a,\n     }\n \n   /* If the data references do not alias, then they are independent.  */\n-  if (!dr_may_alias_p (a, b))\n+  if (!dr_may_alias_p (a, b, loop_nest != NULL))\n     {\n       DDR_ARE_DEPENDENT (res) = chrec_known;\n       return res;"}, {"sha": "86f056884ea56c560a39340c642e5366800860ec", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02f5d6c5e36ea6a41e22f39209248bc1039759b7/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02f5d6c5e36ea6a41e22f39209248bc1039759b7/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=02f5d6c5e36ea6a41e22f39209248bc1039759b7", "patch": "@@ -431,7 +431,7 @@ extern tree find_data_references_in_bb (struct loop *, basic_block,\n \n extern void create_rdg_vertices (struct graph *, VEC (gimple, heap) *);\n extern bool dr_may_alias_p (const struct data_reference *,\n-\t\t\t    const struct data_reference *);\n+\t\t\t    const struct data_reference *, bool);\n extern bool dr_equal_offsets_p (struct data_reference *,\n                                 struct data_reference *);\n "}, {"sha": "7828c5b343b091233d4776cceae4f4ad1214d257", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 1, "deletions": 28, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02f5d6c5e36ea6a41e22f39209248bc1039759b7/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02f5d6c5e36ea6a41e22f39209248bc1039759b7/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=02f5d6c5e36ea6a41e22f39209248bc1039759b7", "patch": "@@ -1835,33 +1835,6 @@ analyze_memory_references (void)\n   create_vop_ref_mapping ();\n }\n \n-/* Returns true if a region of size SIZE1 at position 0 and a region of\n-   size SIZE2 at position DIFF cannot overlap.  */\n-\n-static bool\n-cannot_overlap_p (aff_tree *diff, double_int size1, double_int size2)\n-{\n-  double_int d, bound;\n-\n-  /* Unless the difference is a constant, we fail.  */\n-  if (diff->n != 0)\n-    return false;\n-\n-  d = diff->offset;\n-  if (double_int_negative_p (d))\n-    {\n-      /* The second object is before the first one, we succeed if the last\n-\t element of the second object is before the start of the first one.  */\n-      bound = double_int_add (d, double_int_add (size2, double_int_minus_one));\n-      return double_int_negative_p (bound);\n-    }\n-  else\n-    {\n-      /* We succeed if the second object starts after the first one ends.  */\n-      return double_int_scmp (size1, d) <= 0;\n-    }\n-}\n-\n /* Returns true if MEM1 and MEM2 may alias.  TTAE_CACHE is used as a cache in\n    tree_to_aff_combination_expand.  */\n \n@@ -1890,7 +1863,7 @@ mem_refs_may_alias_p (tree mem1, tree mem2, struct pointer_map_t **ttae_cache)\n   aff_combination_scale (&off1, double_int_minus_one);\n   aff_combination_add (&off2, &off1);\n \n-  if (cannot_overlap_p (&off2, size1, size2))\n+  if (aff_comb_cannot_overlap_p (&off2, size1, size2))\n     return false;\n \n   return true;"}]}