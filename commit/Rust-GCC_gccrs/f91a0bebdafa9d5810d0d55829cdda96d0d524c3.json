{"sha": "f91a0bebdafa9d5810d0d55829cdda96d0d524c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjkxYTBiZWJkYWZhOWQ1ODEwZDBkNTU4MjljZGRhOTZkMGQ1MjRjMw==", "commit": {"author": {"name": "Kenneth Zadeck", "email": "zadeck@naturalbridge.com", "date": "2005-12-20T23:10:49Z"}, "committer": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2005-12-20T23:10:49Z"}, "message": "cfganal.c (flow_reverse_top_sort_order_compute): Renamed to post_order_compute and additional parameter added which allows the...\n\n2005-12-20  Kenneth Zadeck <zadeck@naturalbridge.com>\n\n\t* cfganal.c (flow_reverse_top_sort_order_compute):\n\tRenamed to post_order_compute and additional parameter added which\n\tallows the inclusion of entry and exit blocks into list.\n\t(mark_dfs_back_edges): Fixed comment.\n\t(flow_depth_first_order_compute): Renamed to\n\tpre_and_rev_post_order_compute additional parameter added which\n\tallows the inclusion of entry and exit blocks into list.\n\t* global.c (set_up_bb_rts_numbers): Call to\n\tflow_reverse_top_sort_order_compute renamed to\n\tpost_order_compute.\n\t* var-tracking.c (vt_stack_adjustments): Fixed comment.\n\t(vt_find_locations): Call to\n\tflow_depth_first_order_compute renamed to\n\tpre_and_rev_post_order_compute.\n\t* cfgloop.c (flow_find_loops): Ditto.\n\t* tree-ssa-reassoc.c (init_reassoc): Ditto.\n\t* df.c (df_analyze_1, df_analyze_subcfg): Calls to\n\tflow_reverse_top_sort_order_compute renamed to post_order_compute\n\tand calls to flow_reverse_top_sort_order_compute renamed to\n\tpost_order_compute.\n\t* basic_block.h: Ditto.\n\nFrom-SVN: r108874", "tree": {"sha": "3c3755600937dd34ae35ee7f0ba92fc15d99c5c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c3755600937dd34ae35ee7f0ba92fc15d99c5c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f91a0bebdafa9d5810d0d55829cdda96d0d524c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f91a0bebdafa9d5810d0d55829cdda96d0d524c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f91a0bebdafa9d5810d0d55829cdda96d0d524c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f91a0bebdafa9d5810d0d55829cdda96d0d524c3/comments", "author": {"login": "zadeck", "id": 42682403, "node_id": "MDQ6VXNlcjQyNjgyNDAz", "avatar_url": "https://avatars.githubusercontent.com/u/42682403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zadeck", "html_url": "https://github.com/zadeck", "followers_url": "https://api.github.com/users/zadeck/followers", "following_url": "https://api.github.com/users/zadeck/following{/other_user}", "gists_url": "https://api.github.com/users/zadeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/zadeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zadeck/subscriptions", "organizations_url": "https://api.github.com/users/zadeck/orgs", "repos_url": "https://api.github.com/users/zadeck/repos", "events_url": "https://api.github.com/users/zadeck/events{/privacy}", "received_events_url": "https://api.github.com/users/zadeck/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "df239d2bf9943dde3deb93ff19b89efccb973646", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df239d2bf9943dde3deb93ff19b89efccb973646", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df239d2bf9943dde3deb93ff19b89efccb973646"}], "stats": {"total": 130, "additions": 95, "deletions": 35}, "files": [{"sha": "0d8c853d3b6091db1c3216b53f968faaf0dab869", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f91a0bebdafa9d5810d0d55829cdda96d0d524c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f91a0bebdafa9d5810d0d55829cdda96d0d524c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f91a0bebdafa9d5810d0d55829cdda96d0d524c3", "patch": "@@ -1,3 +1,28 @@\n+2005-12-20  Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\t* cfganal.c (flow_reverse_top_sort_order_compute):\n+\tRenamed to post_order_compute and additional parameter added which\n+\tallows the inclusion of entry and exit blocks into list.\n+\t(mark_dfs_back_edges): Fixed comment.\n+\t(flow_depth_first_order_compute): Renamed to\n+\tpre_and_rev_post_order_compute additional parameter added which\n+\tallows the inclusion of entry and exit blocks into list.\n+\t* global.c (set_up_bb_rts_numbers): Call to\n+\tflow_reverse_top_sort_order_compute renamed to\n+\tpost_order_compute.\n+\t* var-tracking.c (vt_stack_adjustments): Fixed comment.\n+\t(vt_find_locations): Call to\n+\tflow_depth_first_order_compute renamed to\n+\tpre_and_rev_post_order_compute.\n+\t* cfgloop.c (flow_find_loops): Ditto.\n+\t* tree-ssa-reassoc.c (init_reassoc): Ditto.\n+\t* df.c (df_analyze_1, df_analyze_subcfg): Calls to\n+\tflow_reverse_top_sort_order_compute renamed to post_order_compute\n+\tand calls to flow_reverse_top_sort_order_compute renamed to\n+\tpost_order_compute.\n+\t* basic_block.h: Ditto.\n+\n+\n 2005-12-20  Roger Sayle  <roger@eyesopen.com>\n \t    Paolo Bonzini  <bonzini@gnu.org>\n "}, {"sha": "69dba56dd8163e9ed0c20a1cbc1866bfebc77517", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f91a0bebdafa9d5810d0d55829cdda96d0d524c3/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f91a0bebdafa9d5810d0d55829cdda96d0d524c3/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=f91a0bebdafa9d5810d0d55829cdda96d0d524c3", "patch": "@@ -503,8 +503,8 @@ extern edge redirect_edge_succ_nodup (edge, basic_block);\n extern void redirect_edge_pred (edge, basic_block);\n extern basic_block create_basic_block_structure (rtx, rtx, rtx, basic_block);\n extern void clear_bb_flags (void);\n-extern void flow_reverse_top_sort_order_compute (int *);\n-extern int flow_depth_first_order_compute (int *, int *);\n+extern int post_order_compute (int *, bool);\n+extern int pre_and_rev_post_order_compute (int *, int *, bool);\n extern int dfs_enumerate_from (basic_block, int,\n \t\t\t       bool (*)(basic_block, void *),\n \t\t\t       basic_block *, int, void *);"}, {"sha": "efe5db7f6f57e9cd7e6783d90a1bc27d20bfdef5", "filename": "gcc/cfganal.c", "status": "modified", "additions": 59, "deletions": 24, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f91a0bebdafa9d5810d0d55829cdda96d0d524c3/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f91a0bebdafa9d5810d0d55829cdda96d0d524c3/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=f91a0bebdafa9d5810d0d55829cdda96d0d524c3", "patch": "@@ -152,7 +152,7 @@ could_fall_through (basic_block src, basic_block target)\n      Steven Muchnick\n      Morgan Kaufmann, 1997\n \n-   and heavily borrowed from flow_depth_first_order_compute.  */\n+   and heavily borrowed from pre_and_rev_post_order_compute.  */\n \n bool\n mark_dfs_back_edges (void)\n@@ -645,16 +645,20 @@ connect_infinite_loops_to_exit (void)\n   return;\n }\n \f\n-/* Compute reverse top sort order.  */\n+/* Compute reverse top sort order.  \n+   This is computing a post order numbering of the graph.  */\n \n-void\n-flow_reverse_top_sort_order_compute (int *rts_order)\n+int\n+post_order_compute (int *post_order, bool include_entry_exit)\n {\n   edge_iterator *stack;\n   int sp;\n-  int postnum = 0;\n+  int post_order_num = 0;\n   sbitmap visited;\n \n+  if (include_entry_exit)\n+    post_order[post_order_num++] = EXIT_BLOCK;\n+\n   /* Allocate stack for back-tracking up CFG.  */\n   stack = xmalloc ((n_basic_blocks + 1) * sizeof (edge_iterator));\n   sp = 0;\n@@ -690,12 +694,12 @@ flow_reverse_top_sort_order_compute (int *rts_order)\n \t       time, check its successors.  */\n \t    stack[sp++] = ei_start (dest->succs);\n \t  else\n-\t    rts_order[postnum++] = dest->index;\n+\t    post_order[post_order_num++] = dest->index;\n \t}\n       else\n \t{\n \t  if (ei_one_before_end_p (ei) && src != ENTRY_BLOCK_PTR)\n-\t   rts_order[postnum++] = src->index;\n+\t   post_order[post_order_num++] = src->index;\n \n \t  if (!ei_one_before_end_p (ei))\n \t    ei_next (&stack[sp - 1]);\n@@ -704,30 +708,50 @@ flow_reverse_top_sort_order_compute (int *rts_order)\n \t}\n     }\n \n+  if (include_entry_exit)\n+    post_order[post_order_num++] = ENTRY_BLOCK;\n+\n   free (stack);\n   sbitmap_free (visited);\n+  return post_order_num;\n }\n \n /* Compute the depth first search order and store in the array\n-  DFS_ORDER if nonzero, marking the nodes visited in VISITED.  If\n-  RC_ORDER is nonzero, return the reverse completion number for each\n+  PRE_ORDER if nonzero, marking the nodes visited in VISITED.  If\n+  REV_POST_ORDER is nonzero, return the reverse completion number for each\n   node.  Returns the number of nodes visited.  A depth first search\n   tries to get as far away from the starting point as quickly as\n-  possible.  */\n+  possible. \n+\n+  pre_order is a really a preorder numbering of the graph.\n+  rev_post_order is really a reverse postorder numbering of the graph.\n+ */\n \n int\n-flow_depth_first_order_compute (int *dfs_order, int *rc_order)\n+pre_and_rev_post_order_compute (int *pre_order, int *rev_post_order, \n+\t\t\t\tbool include_entry_exit)\n {\n   edge_iterator *stack;\n   int sp;\n-  int dfsnum = 0;\n-  int rcnum = n_basic_blocks - 1 - NUM_FIXED_BLOCKS;\n+  int pre_order_num = 0;\n+  int rev_post_order_num = n_basic_blocks - 1;\n   sbitmap visited;\n \n   /* Allocate stack for back-tracking up CFG.  */\n   stack = xmalloc ((n_basic_blocks + 1) * sizeof (edge_iterator));\n   sp = 0;\n \n+  if (include_entry_exit)\n+    {\n+      if (pre_order)\n+\tpre_order[pre_order_num] = ENTRY_BLOCK;\n+      pre_order_num++;\n+      if (rev_post_order)\n+\trev_post_order[rev_post_order_num--] = ENTRY_BLOCK;\n+    }\n+  else \n+    rev_post_order_num -= NUM_FIXED_BLOCKS;\n+\n   /* Allocate bitmap to track nodes that have been visited.  */\n   visited = sbitmap_alloc (last_basic_block);\n \n@@ -754,27 +778,27 @@ flow_depth_first_order_compute (int *dfs_order, int *rc_order)\n \t  /* Mark that we have visited the destination.  */\n \t  SET_BIT (visited, dest->index);\n \n-\t  if (dfs_order)\n-\t    dfs_order[dfsnum] = dest->index;\n+\t  if (pre_order)\n+\t    pre_order[pre_order_num] = dest->index;\n \n-\t  dfsnum++;\n+\t  pre_order_num++;\n \n \t  if (EDGE_COUNT (dest->succs) > 0)\n \t    /* Since the DEST node has been visited for the first\n \t       time, check its successors.  */\n \t    stack[sp++] = ei_start (dest->succs);\n-\t  else if (rc_order)\n+\t  else if (rev_post_order)\n \t    /* There are no successors for the DEST node so assign\n \t       its reverse completion number.  */\n-\t    rc_order[rcnum--] = dest->index;\n+\t    rev_post_order[rev_post_order_num--] = dest->index;\n \t}\n       else\n \t{\n \t  if (ei_one_before_end_p (ei) && src != ENTRY_BLOCK_PTR\n-\t      && rc_order)\n+\t      && rev_post_order)\n \t    /* There are no more successors for the SRC node\n \t       so assign its reverse completion number.  */\n-\t    rc_order[rcnum--] = src->index;\n+\t    rev_post_order[rev_post_order_num--] = src->index;\n \n \t  if (!ei_one_before_end_p (ei))\n \t    ei_next (&stack[sp - 1]);\n@@ -786,11 +810,22 @@ flow_depth_first_order_compute (int *dfs_order, int *rc_order)\n   free (stack);\n   sbitmap_free (visited);\n \n-  /* The number of nodes visited should be the number of blocks minus\n-     the entry and exit blocks which are not visited here.  */\n-  gcc_assert (dfsnum == n_basic_blocks - NUM_FIXED_BLOCKS);\n+  if (include_entry_exit)\n+    {\n+      if (pre_order)\n+\tpre_order[pre_order_num] = EXIT_BLOCK;\n+      pre_order_num++;\n+      if (rev_post_order)\n+\trev_post_order[rev_post_order_num--] = EXIT_BLOCK;\n+      /* The number of nodes visited should be the number of blocks.  */\n+      gcc_assert (pre_order_num == n_basic_blocks);\n+    }\n+  else\n+    /* The number of nodes visited should be the number of blocks minus\n+       the entry and exit blocks which are not visited here.  */\n+    gcc_assert (pre_order_num == n_basic_blocks - NUM_FIXED_BLOCKS);\n \n-  return dfsnum;\n+  return pre_order_num;\n }\n \n /* Compute the depth first search order on the _reverse_ graph and"}, {"sha": "7629c917016fc7e3c2dd6728d49de4234975b9ac", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f91a0bebdafa9d5810d0d55829cdda96d0d524c3/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f91a0bebdafa9d5810d0d55829cdda96d0d524c3/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=f91a0bebdafa9d5810d0d55829cdda96d0d524c3", "patch": "@@ -696,7 +696,7 @@ flow_loops_find (struct loops *loops)\n \t natural loops will be found before inner natural loops.  */\n       dfs_order = xmalloc (n_basic_blocks * sizeof (int));\n       rc_order = xmalloc (n_basic_blocks * sizeof (int));\n-      flow_depth_first_order_compute (dfs_order, rc_order);\n+      pre_and_rev_post_order_compute (dfs_order, rc_order, false);\n \n       /* Save CFG derived information to avoid recomputing it.  */\n       loops->cfg.dfs_order = dfs_order;"}, {"sha": "ecf81fa5b0079c94857b8cf93203bb82bc34a0d6", "filename": "gcc/df.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f91a0bebdafa9d5810d0d55829cdda96d0d524c3/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f91a0bebdafa9d5810d0d55829cdda96d0d524c3/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=f91a0bebdafa9d5810d0d55829cdda96d0d524c3", "patch": "@@ -1996,8 +1996,8 @@ df_analyze_1 (struct df *df, bitmap blocks, int flags, int update)\n   df->rc_order = xmalloc (sizeof (int) * n_basic_blocks - NUM_FIXED_BLOCKS);\n   df->rts_order = xmalloc (sizeof (int) * n_basic_blocks - NUM_FIXED_BLOCKS);\n \n-  flow_depth_first_order_compute (df->dfs_order, df->rc_order);\n-  flow_reverse_top_sort_order_compute (df->rts_order);\n+  pre_and_rev_post_order_compute (df->dfs_order, df->rc_order, false);\n+  post_order_compute (df->rts_order, false);\n   if (aflags & DF_RD)\n     {\n       /* Compute the sets of gens and kills for the defs of each bb.  */\n@@ -2424,8 +2424,8 @@ df_analyze_subcfg (struct df *df, bitmap blocks, int flags)\n   df->rc_order = xmalloc (sizeof (int) * n_basic_blocks - NUM_FIXED_BLOCKS);\n   df->rts_order = xmalloc (sizeof (int) * n_basic_blocks - NUM_FIXED_BLOCKS);\n \n-  flow_depth_first_order_compute (df->dfs_order, df->rc_order);\n-  flow_reverse_top_sort_order_compute (df->rts_order);\n+  pre_and_rev_post_order_compute (df->dfs_order, df->rc_order, false);\n+  post_order_compute (df->rts_order, false);\n \n   n_blocks = prune_to_subcfg (df->dfs_order, n_basic_blocks - NUM_FIXED_BLOCKS, blocks);\n   prune_to_subcfg (df->rc_order, n_basic_blocks - NUM_FIXED_BLOCKS, blocks);"}, {"sha": "e92a4cb7a95af81ad9d755e0867463ed0f901804", "filename": "gcc/global.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f91a0bebdafa9d5810d0d55829cdda96d0d524c3/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f91a0bebdafa9d5810d0d55829cdda96d0d524c3/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=f91a0bebdafa9d5810d0d55829cdda96d0d524c3", "patch": "@@ -2282,7 +2282,7 @@ set_up_bb_rts_numbers (void)\n   int *rts_order;\n   \n   rts_order = xmalloc (sizeof (int) * (n_basic_blocks - NUM_FIXED_BLOCKS));\n-  flow_reverse_top_sort_order_compute (rts_order);\n+  post_order_compute (rts_order, false);\n   for (i = 0; i < n_basic_blocks - NUM_FIXED_BLOCKS; i++)\n     BB_INFO_BY_INDEX (rts_order [i])->rts_number = i;\n   free (rts_order);"}, {"sha": "97492b8fb7f85f6fa470b2cac324a6492fd60373", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f91a0bebdafa9d5810d0d55829cdda96d0d524c3/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f91a0bebdafa9d5810d0d55829cdda96d0d524c3/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=f91a0bebdafa9d5810d0d55829cdda96d0d524c3", "patch": "@@ -1424,7 +1424,7 @@ init_reassoc (void)\n \n   /* Reverse RPO (Reverse Post Order) will give us something where\n      deeper loops come later.  */\n-  flow_depth_first_order_compute (NULL, bbs);\n+  pre_and_rev_post_order_compute (NULL, bbs, false);\n   bb_rank = xcalloc (last_basic_block + 1, sizeof (unsigned int));\n   \n   operand_rank = htab_create (511, operand_entry_hash,"}, {"sha": "046cab46d3132878124a69034cf75164aab7e266", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f91a0bebdafa9d5810d0d55829cdda96d0d524c3/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f91a0bebdafa9d5810d0d55829cdda96d0d524c3/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=f91a0bebdafa9d5810d0d55829cdda96d0d524c3", "patch": "@@ -485,7 +485,7 @@ bb_stack_adjust_offset (basic_block bb)\n \n /* Compute stack adjustments for all blocks by traversing DFS tree.\n    Return true when the adjustments on all incoming edges are consistent.\n-   Heavily borrowed from flow_depth_first_order_compute.  */\n+   Heavily borrowed from pre_and_rev_post_order_compute.  */\n \n static bool\n vt_stack_adjustments (void)\n@@ -1640,7 +1640,7 @@ vt_find_locations (void)\n      so that the data-flow runs faster.  */\n   rc_order = xmalloc ((n_basic_blocks - NUM_FIXED_BLOCKS) * sizeof (int));\n   bb_order = xmalloc (last_basic_block * sizeof (int));\n-  flow_depth_first_order_compute (NULL, rc_order);\n+  pre_and_rev_post_order_compute (NULL, rc_order, false);\n   for (i = 0; i < n_basic_blocks - NUM_FIXED_BLOCKS; i++)\n     bb_order[rc_order[i]] = i;\n   free (rc_order);"}]}