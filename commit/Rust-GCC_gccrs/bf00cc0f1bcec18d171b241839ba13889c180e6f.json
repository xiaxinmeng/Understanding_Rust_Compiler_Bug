{"sha": "bf00cc0f1bcec18d171b241839ba13889c180e6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmYwMGNjMGYxYmNlYzE4ZDE3MWIyNDE4MzliYTEzODg5YzE4MGU2Zg==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2005-11-28T03:52:01Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2005-11-28T03:52:01Z"}, "message": "re PR target/24997 (ICE with -ftree-vectorize)\n\n\tPR target/24997\n\t* config/rs6000/rs6000.c (legitimate_indexed_address_p): Allow pattern\n\tgenerated by reload.\n\t* config/rs6000/predicates.md (indexed_or_indirect_operand): Use\n\tindexed_or_indirect_address.\n\t(indexed_or_indirect_address): Don't test for base reg.  Call\n\taddress_operand last.  Make it a special predicate.\n\nFrom-SVN: r107591", "tree": {"sha": "d889bface62f769703ebcef97eebe29b0a3db9a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d889bface62f769703ebcef97eebe29b0a3db9a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf00cc0f1bcec18d171b241839ba13889c180e6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf00cc0f1bcec18d171b241839ba13889c180e6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf00cc0f1bcec18d171b241839ba13889c180e6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf00cc0f1bcec18d171b241839ba13889c180e6f/comments", "author": null, "committer": null, "parents": [{"sha": "24a62419d9fac12ffc4700d0a370fdf0922c718a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24a62419d9fac12ffc4700d0a370fdf0922c718a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24a62419d9fac12ffc4700d0a370fdf0922c718a"}], "stats": {"total": 78, "additions": 47, "deletions": 31}, "files": [{"sha": "f4c260bde14f5f4540802a29e27948ca8b6a9111", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf00cc0f1bcec18d171b241839ba13889c180e6f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf00cc0f1bcec18d171b241839ba13889c180e6f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf00cc0f1bcec18d171b241839ba13889c180e6f", "patch": "@@ -1,3 +1,13 @@\n+2005-11-28  Alan Modra  <amodra@bigpond.net.au>\n+\n+\tPR target/24997\n+\t* config/rs6000/rs6000.c (legitimate_indexed_address_p): Allow pattern\n+\tgenerated by reload.\n+\t* config/rs6000/predicates.md (indexed_or_indirect_operand): Use\n+\tindexed_or_indirect_address.\n+\t(indexed_or_indirect_address): Don't test for base reg.  Call\n+\taddress_operand last.  Make it a special predicate.\n+\n 2005-11-27  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* config/m68k/m68k.c (notice_update_cc): Remove useless code."}, {"sha": "26f46a0e0fd7c01cd4f48a850858df4e88ef0893", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf00cc0f1bcec18d171b241839ba13889c180e6f/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf00cc0f1bcec18d171b241839ba13889c180e6f/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=bf00cc0f1bcec18d171b241839ba13889c180e6f", "patch": "@@ -353,25 +353,6 @@\n \t\t\t\t\t   || reload_in_progress,\n \t\t\t\t\t   mode, XEXP (op, 0))\")))\n \n-;; Return 1 if the operand is an indexed or indirect memory operand.\n-(define_predicate \"indexed_or_indirect_operand\"\n-  (match_operand 0 \"memory_operand\")\n-{\n-  rtx tmp = XEXP (op, 0);\n-\n-  if (TARGET_ALTIVEC\n-      && ALTIVEC_VECTOR_MODE (mode)\n-      && GET_CODE (tmp) == AND\n-      && GET_CODE (XEXP (tmp, 1)) == CONST_INT\n-      && INTVAL (XEXP (tmp, 1)) == -16)\n-    tmp = XEXP (tmp, 0);\n-\n-    return REG_P (tmp)\n-\t\t  || (GET_CODE (tmp) == PLUS\n-\t\t      && REG_P (XEXP (tmp, 0)) \n-\t\t      && REG_P (XEXP (tmp, 1)));\n-})\n-\n ;; Return 1 if the operand is a memory operand with an address divisible by 4\n (define_predicate \"word_offset_memref_operand\"\n   (and (match_operand 0 \"memory_operand\")\n@@ -380,13 +361,28 @@\n \t\t    || GET_CODE (XEXP (XEXP (op, 0), 1)) != CONST_INT\n \t\t    || INTVAL (XEXP (XEXP (op, 0), 1)) % 4 == 0\")))\n \n+;; Return 1 if the operand is an indexed or indirect memory operand.\n+(define_predicate \"indexed_or_indirect_operand\"\n+  (match_code \"mem\")\n+{\n+  op = XEXP (op, 0);\n+  if (TARGET_ALTIVEC\n+      && ALTIVEC_VECTOR_MODE (mode)\n+      && GET_CODE (op) == AND\n+      && GET_CODE (XEXP (op, 1)) == CONST_INT\n+      && INTVAL (XEXP (op, 1)) == -16)\n+    op = XEXP (op, 0);\n+\n+  return indexed_or_indirect_address (op, mode);\n+})\n+\n ;; Return 1 if the operand is an indexed or indirect address.\n-(define_predicate \"indexed_or_indirect_address\"\n-  (and (match_operand 0 \"address_operand\")\n-       (match_test \"REG_P (op)\n+(define_special_predicate \"indexed_or_indirect_address\"\n+  (and (match_test \"REG_P (op)\n \t\t    || (GET_CODE (op) == PLUS\n-\t\t\t&& REG_P (XEXP (op, 0)) \n-\t\t\t&& REG_P (XEXP (op, 1)))\")))\n+\t\t\t/* Omit testing REG_P (XEXP (op, 0)).  */\n+\t\t\t&& REG_P (XEXP (op, 1)))\")\n+       (match_operand 0 \"address_operand\")))\n \n ;; Used for the destination of the fix_truncdfsi2 expander.\n ;; If stfiwx will be used, the result goes to memory; otherwise,"}, {"sha": "d013916a42e8031e1f072308ad3728e917e40f11", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf00cc0f1bcec18d171b241839ba13889c180e6f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf00cc0f1bcec18d171b241839ba13889c180e6f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=bf00cc0f1bcec18d171b241839ba13889c180e6f", "patch": "@@ -2731,13 +2731,23 @@ legitimate_indexed_address_p (rtx x, int strict)\n   op0 = XEXP (x, 0);\n   op1 = XEXP (x, 1);\n \n-  if (!REG_P (op0) || !REG_P (op1))\n-    return false;\n-\n-  return ((INT_REG_OK_FOR_BASE_P (op0, strict)\n-\t   && INT_REG_OK_FOR_INDEX_P (op1, strict))\n-\t  || (INT_REG_OK_FOR_BASE_P (op1, strict)\n-\t      && INT_REG_OK_FOR_INDEX_P (op0, strict)));\n+  if (REG_P (op0) && REG_P (op1))\n+    return ((INT_REG_OK_FOR_BASE_P (op0, strict)\n+\t     && INT_REG_OK_FOR_INDEX_P (op1, strict))\n+\t    || (INT_REG_OK_FOR_BASE_P (op1, strict)\n+\t\t&& INT_REG_OK_FOR_INDEX_P (op0, strict)));\n+\n+  /* Recognize the rtl generated by reload which we know will later be\n+     replaced by a base reg.  We rely on nothing but reload generating\n+     this particular pattern, a reasonable assumption because it is not\n+     canonical.  */\n+  else if (reload_in_progress\n+\t   && GET_CODE (op0) == PLUS\n+\t   && REG_P (XEXP (op0, 0))\n+\t   && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t   && REG_P (op1))\n+    return INT_REG_OK_FOR_INDEX_P (op1, strict);\n+  return false;\n }\n \n inline bool"}]}