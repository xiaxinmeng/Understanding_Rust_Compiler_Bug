{"sha": "0b525beee7461b1713595233bc68edc4ef8ad6a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI1MjViZWVlNzQ2MWIxNzEzNTk1MjMzYmM2OGVkYzRlZjhhZDZhNw==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonber@gnat.com", "date": "2004-10-04T14:57:11Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-10-04T14:57:11Z"}, "message": "sem_ch12.adb (Check_Generic_Actuals): New predicate Denotes_Previous_Actual...\n\n2004-10-04  Ed Schonberg  <schonberg@gnat.com>\n\n\t* sem_ch12.adb (Check_Generic_Actuals): New predicate\n\tDenotes_Previous_Actual, to handle properly the case of a private\n\tactual that is also the component type of a subsequent array actual.\n\tThe visibility status of the first actual is not affected when the\n\tsecond is installed.\n\t(Process_Nested_Formal): Subsidiary of Instantiate_Formal_Package, to\n\tmake fully recursive the treatment of formals of packages declared\n\twith a box.\n\t(Restore_Nested_Formal): Subsidiary of Restore_Private_Views, to undo\n\tthe above on exit from an instantiation.\n\t(Denotes_Formal_Package): When called from Restore_Private_Views, ignore\n\tcurrent instantiation which is now complete.\n\t(Analyze_Package_Instantiation): No instantiated body is needed if the\n\tmain unit is generic. Efficient, and avoid anomalies when a instance\n\tappears in a package accessed through rtsfind.\n\nFrom-SVN: r88496", "tree": {"sha": "5fca5058bdc74419e06e6b1898e0b4753f29b513", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5fca5058bdc74419e06e6b1898e0b4753f29b513"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b525beee7461b1713595233bc68edc4ef8ad6a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b525beee7461b1713595233bc68edc4ef8ad6a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b525beee7461b1713595233bc68edc4ef8ad6a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b525beee7461b1713595233bc68edc4ef8ad6a7/comments", "author": null, "committer": null, "parents": [{"sha": "27ad9660a8011119222121eb67aabb099cc43e1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27ad9660a8011119222121eb67aabb099cc43e1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27ad9660a8011119222121eb67aabb099cc43e1a"}], "stats": {"total": 304, "additions": 220, "deletions": 84}, "files": [{"sha": "f2fe7ce849c74c1485d1ff6bba4611a5327efb51", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b525beee7461b1713595233bc68edc4ef8ad6a7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b525beee7461b1713595233bc68edc4ef8ad6a7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0b525beee7461b1713595233bc68edc4ef8ad6a7", "patch": "@@ -1,3 +1,21 @@\n+2004-10-04  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* sem_ch12.adb (Check_Generic_Actuals): New predicate\n+\tDenotes_Previous_Actual, to handle properly the case of a private\n+\tactual that is also the component type of a subsequent array actual.\n+\tThe visibility status of the first actual is not affected when the\n+\tsecond is installed.\n+\t(Process_Nested_Formal): Subsidiary of Instantiate_Formal_Package, to\n+\tmake fully recursive the treatment of formals of packages declared\n+\twith a box.\n+\t(Restore_Nested_Formal): Subsidiary of Restore_Private_Views, to undo\n+\tthe above on exit from an instantiation.\n+\t(Denotes_Formal_Package): When called from Restore_Private_Views, ignore\n+\tcurrent instantiation which is now complete.\n+\t(Analyze_Package_Instantiation): No instantiated body is needed if the\n+\tmain unit is generic. Efficient, and avoid anomalies when a instance\n+\tappears in a package accessed through rtsfind.\n+\n 2004-10-04  Ed Schonberg  <schonberg@gnat.com>\n \n \t* exp_ch6.adb (Expand_N_Function_Call): If stack checking is enabled,"}, {"sha": "59e3bec5dfa56f168619fbb7621e85b2b4b5cd2b", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 202, "deletions": 84, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b525beee7461b1713595233bc68edc4ef8ad6a7/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b525beee7461b1713595233bc68edc4ef8ad6a7/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=0b525beee7461b1713595233bc68edc4ef8ad6a7", "patch": "@@ -286,8 +286,7 @@ package body Sem_Ch12 is\n    function Analyze_Associations\n      (I_Node  : Node_Id;\n       Formals : List_Id;\n-      F_Copy  : List_Id)\n-      return    List_Id;\n+      F_Copy  : List_Id) return List_Id;\n    --  At instantiation time, build the list of associations between formals\n    --  and actuals. Each association becomes a renaming declaration for the\n    --  formal entity. F_Copy is the analyzed list of formals in the generic\n@@ -359,25 +358,28 @@ package body Sem_Ch12 is\n    function Contains_Instance_Of\n      (Inner : Entity_Id;\n       Outer : Entity_Id;\n-      N     : Node_Id)\n-      return  Boolean;\n+      N     : Node_Id) return Boolean;\n    --  Inner is instantiated within the generic Outer. Check whether Inner\n    --  directly or indirectly contains an instance of Outer or of one of its\n    --  parents, in the case of a subunit. Each generic unit holds a list of\n    --  the entities instantiated within (at any depth). This procedure\n    --  determines whether the set of such lists contains a cycle, i.e. an\n    --  illegal circular instantiation.\n \n-   function Denotes_Formal_Package (Pack : Entity_Id) return Boolean;\n+   function Denotes_Formal_Package\n+     (Pack    : Entity_Id;\n+      On_Exit : Boolean := False) return Boolean;\n    --  Returns True if E is a formal package of an enclosing generic, or\n-   --  the actual for such a formal in an enclosing instantiation. Used in\n-   --  Restore_Private_Views, to keep the formals of such a package visible\n-   --  on exit from an inner instantiation.\n+   --  the actual for such a formal in an enclosing instantiation. If such\n+   --  a package is used as a formal in an nested generic, or as an actual\n+   --  in a nested instantiation, the visibility of ITS formals should not\n+   --  be modified. When called from within Restore_Private_Views, the flag\n+   --  On_Exit is true, to indicate that the search for a possible enclosing\n+   --  instance should ignore the current one.\n \n    function Find_Actual_Type\n      (Typ       : Entity_Id;\n-      Gen_Scope : Entity_Id)\n-      return      Entity_Id;\n+      Gen_Scope : Entity_Id) return Entity_Id;\n    --  When validating the actual types of a child instance, check whether\n    --  the formal is a formal type of the parent unit, and retrieve the current\n    --  actual for it. Typ is the entity in the analyzed formal type declaration\n@@ -391,8 +393,7 @@ package body Sem_Ch12 is\n \n    function In_Same_Declarative_Part\n      (F_Node : Node_Id;\n-      Inst   : Node_Id)\n-      return   Boolean;\n+      Inst   : Node_Id) return Boolean;\n    --  True if the instantiation Inst and the given freeze_node F_Node appear\n    --  within the same declarative part, ignoring subunits, but with no inter-\n    --  vening suprograms or concurrent units. If true, the freeze node\n@@ -485,27 +486,23 @@ package body Sem_Ch12 is\n    function Instantiate_Object\n      (Formal          : Node_Id;\n       Actual          : Node_Id;\n-      Analyzed_Formal : Node_Id)\n-      return            List_Id;\n+      Analyzed_Formal : Node_Id) return List_Id;\n \n    function Instantiate_Type\n      (Formal          : Node_Id;\n       Actual          : Node_Id;\n       Analyzed_Formal : Node_Id;\n-      Actual_Decls    : List_Id)\n-      return            Node_Id;\n+      Actual_Decls    : List_Id) return Node_Id;\n \n    function Instantiate_Formal_Subprogram\n      (Formal          : Node_Id;\n       Actual          : Node_Id;\n-      Analyzed_Formal : Node_Id)\n-      return            Node_Id;\n+      Analyzed_Formal : Node_Id) return Node_Id;\n \n    function Instantiate_Formal_Package\n      (Formal          : Node_Id;\n       Actual          : Node_Id;\n-      Analyzed_Formal : Node_Id)\n-      return            List_Id;\n+      Analyzed_Formal : Node_Id) return List_Id;\n    --  If the formal package is declared with a box, special visibility rules\n    --  apply to its formals: they are in the visible part of the package. This\n    --  is true in the declarative region of the formal package, that is to say\n@@ -639,7 +636,7 @@ package body Sem_Ch12 is\n    procedure Set_Next_Assoc (E : Assoc_Ptr; Next : Assoc_Ptr);\n    function  Next_Assoc     (E : Assoc_Ptr) return Assoc_Ptr;\n    function Get_Gen_Id      (E : Assoc_Ptr) return Entity_Id;\n-   function Hash            (F : Entity_Id)   return HTable_Range;\n+   function Hash            (F : Entity_Id) return HTable_Range;\n \n    package Generic_Renamings_HTable is new GNAT.HTable.Static_HTable (\n       Header_Num => HTable_Range,\n@@ -755,14 +752,12 @@ package body Sem_Ch12 is\n    function Analyze_Associations\n      (I_Node  : Node_Id;\n       Formals : List_Id;\n-      F_Copy  : List_Id)\n-      return    List_Id\n+      F_Copy  : List_Id) return List_Id\n    is\n-      Actual_Types    : constant Elist_Id  := New_Elmt_List;\n-      Assoc           : constant List_Id   := New_List;\n-      Defaults        : constant Elist_Id  := New_Elmt_List;\n-      Gen_Unit        : constant Entity_Id := Defining_Entity\n-                                                (Parent (F_Copy));\n+      Actual_Types : constant Elist_Id  := New_Elmt_List;\n+      Assoc        : constant List_Id   := New_List;\n+      Defaults     : constant Elist_Id  := New_Elmt_List;\n+      Gen_Unit     : constant Entity_Id := Defining_Entity (Parent (F_Copy));\n       Actuals         : List_Id;\n       Actual          : Node_Id;\n       Formal          : Node_Id;\n@@ -778,9 +773,8 @@ package body Sem_Ch12 is\n       Num_Actuals     : Int := 0;\n \n       function Matching_Actual\n-        (F    : Entity_Id;\n-         A_F  : Entity_Id)\n-         return Node_Id;\n+        (F   : Entity_Id;\n+         A_F : Entity_Id) return Node_Id;\n       --  Find actual that corresponds to a given a formal parameter. If the\n       --  actuals are positional, return the next one, if any. If the actuals\n       --  are named, scan the parameter associations to find the right one.\n@@ -801,9 +795,8 @@ package body Sem_Ch12 is\n       ---------------------\n \n       function Matching_Actual\n-        (F    : Entity_Id;\n-         A_F  : Entity_Id)\n-         return Node_Id\n+        (F   : Entity_Id;\n+         A_F : Entity_Id) return Node_Id\n       is\n          Found : Node_Id;\n          Prev  : Node_Id;\n@@ -2319,9 +2312,7 @@ package body Sem_Ch12 is\n \n          else\n             E := First_Entity (Gen_Unit);\n-\n             while Present (E) loop\n-\n                if Is_Subprogram (E)\n                  and then Is_Inlined (E)\n                then\n@@ -2596,8 +2587,9 @@ package body Sem_Ch12 is\n             --  If front_end_inlining is enabled, do not instantiate a\n             --  body if within a generic context.\n \n-            if Front_End_Inlining\n-              and then not Expander_Active\n+            if (Front_End_Inlining\n+                  and then not Expander_Active)\n+              or else Is_Generic_Unit (Cunit_Entity (Main_Unit))\n             then\n                Needs_Body := False;\n             end if;\n@@ -3497,6 +3489,7 @@ package body Sem_Ch12 is\n         or else Nkind (Assoc) = N_Extension_Aggregate\n       then\n          return Assoc;\n+\n       else\n          --  If the node is part of an inner generic, it may itself have been\n          --  remapped into a further generic copy. Associated_Node is otherwise\n@@ -3949,6 +3942,37 @@ package body Sem_Ch12 is\n       E      : Entity_Id;\n       Astype : Entity_Id;\n \n+      function Denotes_Previous_Actual (Typ : Entity_Id) return Boolean;\n+      --  For a formal that is an array type, the component type is often\n+      --  a previous formal in the same unit. The privacy status of the\n+      --  component type will have been examined earlier in the traversal\n+      --  of the corresponding actuals, and this status should not be\n+      --  modified for the array type itself.\n+      --  To detect this case we have to rescan the list of formals, which\n+      --  is usually short enough to ignore the resulting inefficiency.\n+\n+      function Denotes_Previous_Actual (Typ : Entity_Id) return Boolean is\n+         Prev : Entity_Id;\n+      begin\n+         Prev := First_Entity (Instance);\n+         while Present (Prev) loop\n+            if Is_Type (Prev)\n+              and then Nkind (Parent (Prev)) = N_Subtype_Declaration\n+              and then Is_Entity_Name (Subtype_Indication (Parent (Prev)))\n+              and then Entity (Subtype_Indication (Parent (Prev))) = Typ\n+            then\n+               return True;\n+            elsif Prev = E then\n+               return False;\n+            else\n+               Next_Entity (Prev);\n+            end if;\n+         end loop;\n+         return False;\n+      end Denotes_Previous_Actual;\n+\n+   --  Start of processing for Check_Generic_Actuals\n+\n    begin\n       E := First_Entity (Instance);\n       while Present (E) loop\n@@ -3957,9 +3981,17 @@ package body Sem_Ch12 is\n            and then Scope (Etype (E)) /= Instance\n            and then Is_Entity_Name (Subtype_Indication (Parent (E)))\n          then\n-            Check_Private_View (Subtype_Indication (Parent (E)));\n+            if Is_Array_Type (E)\n+              and then Denotes_Previous_Actual (Component_Type (E))\n+            then\n+               null;\n+            else\n+               Check_Private_View (Subtype_Indication (Parent (E)));\n+            end if;\n             Set_Is_Generic_Actual_Type (E, True);\n             Set_Is_Hidden (E, False);\n+            Set_Is_Potentially_Use_Visible (E,\n+              In_Use (Instance));\n \n             --  We constructed the generic actual type as a subtype of\n             --  the supplied type. This means that it normally would not\n@@ -4013,10 +4045,11 @@ package body Sem_Ch12 is\n             elsif Denotes_Formal_Package (E) then\n                null;\n \n-            elsif Present (Associated_Formal_Package (E))\n-              and then Box_Present (Parent (Associated_Formal_Package (E)))\n-            then\n-               Check_Generic_Actuals (Renamed_Object (E), True);\n+            elsif Present (Associated_Formal_Package (E)) then\n+               if Box_Present (Parent (Associated_Formal_Package (E))) then\n+                  Check_Generic_Actuals (Renamed_Object (E), True);\n+               end if;\n+\n                Set_Is_Hidden (E, False);\n             end if;\n \n@@ -4050,8 +4083,7 @@ package body Sem_Ch12 is\n \n       function Find_Generic_Child\n         (Scop : Entity_Id;\n-         Id   : Node_Id)\n-         return Entity_Id;\n+         Id   : Node_Id) return Entity_Id;\n       --  Search generic parent for possible child unit with the given name.\n \n       function In_Enclosing_Instance return Boolean;\n@@ -4065,8 +4097,7 @@ package body Sem_Ch12 is\n \n       function Find_Generic_Child\n         (Scop : Entity_Id;\n-         Id   : Node_Id)\n-         return Entity_Id\n+         Id   : Node_Id) return Entity_Id\n       is\n          E : Entity_Id;\n \n@@ -4486,8 +4517,7 @@ package body Sem_Ch12 is\n    function Contains_Instance_Of\n      (Inner : Entity_Id;\n       Outer : Entity_Id;\n-      N     : Node_Id)\n-      return  Boolean\n+      N     : Node_Id) return Boolean\n    is\n       Elmt : Elmt_Id;\n       Scop : Entity_Id;\n@@ -4559,8 +4589,7 @@ package body Sem_Ch12 is\n    function Copy_Generic_Node\n      (N             : Node_Id;\n       Parent_Id     : Node_Id;\n-      Instantiating : Boolean)\n-      return          Node_Id\n+      Instantiating : Boolean) return Node_Id\n    is\n       Ent   : Entity_Id;\n       New_N : Node_Id;\n@@ -4579,8 +4608,7 @@ package body Sem_Ch12 is\n \n       function Copy_Generic_List\n         (L         : List_Id;\n-         Parent_Id : Node_Id)\n-         return      List_Id;\n+         Parent_Id : Node_Id) return List_Id;\n       --  Apply Copy_Node recursively to the members of a node list.\n \n       function In_Defining_Unit_Name (Nam : Node_Id) return Boolean;\n@@ -4664,8 +4692,7 @@ package body Sem_Ch12 is\n \n       function Copy_Generic_List\n         (L         : List_Id;\n-         Parent_Id : Node_Id)\n-         return      List_Id\n+         Parent_Id : Node_Id) return List_Id\n       is\n          N     : Node_Id;\n          New_L : List_Id;\n@@ -5163,12 +5190,23 @@ package body Sem_Ch12 is\n    -- Denotes_Formal_Package --\n    ----------------------------\n \n-   function Denotes_Formal_Package (Pack : Entity_Id) return Boolean is\n-      Par  : constant Entity_Id := Current_Instantiated_Parent.Act_Id;\n+   function Denotes_Formal_Package\n+     (Pack    : Entity_Id;\n+      On_Exit : Boolean := False) return Boolean\n+   is\n+      Par  : Entity_Id;\n       Scop : constant Entity_Id := Scope (Pack);\n       E    : Entity_Id;\n \n    begin\n+      if On_Exit then\n+         Par :=\n+           Instance_Envs.Table\n+             (Instance_Envs.Last).Instantiated_Parent.Act_Id;\n+      else\n+         Par  := Current_Instantiated_Parent.Act_Id;\n+      end if;\n+\n       if Ekind (Scop) = E_Generic_Package\n         or else Nkind (Unit_Declaration_Node (Scop)) =\n                                          N_Generic_Subprogram_Declaration\n@@ -5227,8 +5265,7 @@ package body Sem_Ch12 is\n \n    function Find_Actual_Type\n      (Typ       : Entity_Id;\n-      Gen_Scope : Entity_Id)\n-      return      Entity_Id\n+      Gen_Scope : Entity_Id) return Entity_Id\n    is\n       T : Entity_Id;\n \n@@ -5704,8 +5741,7 @@ package body Sem_Ch12 is\n \n    function In_Same_Declarative_Part\n      (F_Node : Node_Id;\n-      Inst   : Node_Id)\n-      return   Boolean\n+      Inst   : Node_Id) return Boolean\n    is\n       Decls : constant Node_Id := Parent (F_Node);\n       Nod   : Node_Id := Parent (Inst);\n@@ -5846,6 +5882,10 @@ package body Sem_Ch12 is\n       --  origin of a node by finding the maximum sloc of any ancestor node.\n       --  Why is this not equivalent fo Top_Level_Location ???\n \n+      --------------------\n+      -- Enclosing_Subp --\n+      --------------------\n+\n       function Enclosing_Subp (Id : Entity_Id) return Entity_Id is\n          Scop : Entity_Id := Scope (Id);\n \n@@ -5859,6 +5899,10 @@ package body Sem_Ch12 is\n          return Scop;\n       end Enclosing_Subp;\n \n+      ---------------\n+      -- True_Sloc --\n+      ---------------\n+\n       function True_Sloc (N : Node_Id) return Source_Ptr is\n          Res : Source_Ptr;\n          N1  : Node_Id;\n@@ -6169,8 +6213,7 @@ package body Sem_Ch12 is\n    function Instantiate_Formal_Package\n      (Formal          : Node_Id;\n       Actual          : Node_Id;\n-      Analyzed_Formal : Node_Id)\n-      return            List_Id\n+      Analyzed_Formal : Node_Id) return List_Id\n    is\n       Loc         : constant Source_Ptr := Sloc (Actual);\n       Actual_Pack : Entity_Id;\n@@ -6195,8 +6238,7 @@ package body Sem_Ch12 is\n \n       function Formal_Entity\n         (F       : Node_Id;\n-         Act_Ent : Entity_Id)\n-         return    Entity_Id;\n+         Act_Ent : Entity_Id) return Entity_Id;\n       --  Returns the entity associated with the given formal F. In the\n       --  case where F is a formal package, this function will iterate\n       --  through all of F's formals and enter map associations from the\n@@ -6207,8 +6249,7 @@ package body Sem_Ch12 is\n \n       function Is_Instance_Of\n         (Act_Spec : Entity_Id;\n-         Gen_Anc  : Entity_Id)\n-         return     Boolean;\n+         Gen_Anc  : Entity_Id) return Boolean;\n       --  The actual can be an instantiation of a generic within another\n       --  instance, in which case there is no direct link from it to the\n       --  original generic ancestor. In that case, we recognize that the\n@@ -6227,6 +6268,12 @@ package body Sem_Ch12 is\n       --  that the entities in P2 are mapped into those of P3. The mapping of\n       --  entities has to be done recursively for nested packages.\n \n+      procedure Process_Nested_Formal (Formal : Entity_Id);\n+      --  If the current formal is declared with a box, its own formals are\n+      --  visible in the instance, as they were in the generic, and their\n+      --  Hidden flag must be reset. If some of these formals are themselves\n+      --  packages declared with a box, the processing must be recursive.\n+\n       --------------------------\n       -- Find_Matching_Actual --\n       --------------------------\n@@ -6268,8 +6315,7 @@ package body Sem_Ch12 is\n \n       function Formal_Entity\n         (F       : Node_Id;\n-         Act_Ent : Entity_Id)\n-         return    Entity_Id\n+         Act_Ent : Entity_Id) return Entity_Id\n       is\n          Orig_Node : Node_Id := F;\n          Act_Pkg   : Entity_Id;\n@@ -6371,8 +6417,7 @@ package body Sem_Ch12 is\n \n       function Is_Instance_Of\n         (Act_Spec : Entity_Id;\n-         Gen_Anc  : Entity_Id)\n-         return     Boolean\n+         Gen_Anc  : Entity_Id) return Boolean\n       is\n          Gen_Par : constant Entity_Id := Generic_Parent (Act_Spec);\n \n@@ -6455,6 +6500,33 @@ package body Sem_Ch12 is\n          end loop;\n       end Map_Entities;\n \n+      ---------------------------\n+      -- Process_Nested_Formal --\n+      ---------------------------\n+\n+      procedure Process_Nested_Formal (Formal : Entity_Id) is\n+         Ent : Entity_Id;\n+\n+      begin\n+         if Present (Associated_Formal_Package (Formal))\n+           and then Box_Present (Parent (Associated_Formal_Package (Formal)))\n+         then\n+            Ent := First_Entity (Formal);\n+            while Present (Ent) loop\n+               Set_Is_Hidden (Ent, False);\n+               Set_Is_Potentially_Use_Visible\n+                 (Ent, Is_Potentially_Use_Visible (Formal));\n+\n+               if Ekind (Ent) = E_Package then\n+                  exit when Renamed_Entity (Ent) = Renamed_Entity (Formal);\n+                  Process_Nested_Formal (Ent);\n+               end if;\n+\n+               Next_Entity (Ent);\n+            end loop;\n+         end if;\n+      end Process_Nested_Formal;\n+\n    --  Start of processing for Instantiate_Formal_Package\n \n    begin\n@@ -6563,6 +6635,10 @@ package body Sem_Ch12 is\n                   Set_Is_Potentially_Use_Visible\n                     (Actual_Ent, In_Use (Actual_Pack));\n \n+                  if Ekind (Actual_Ent) = E_Package then\n+                     Process_Nested_Formal (Actual_Ent);\n+                  end if;\n+\n                   if Present (Formal_Node) then\n                      Formal_Ent := Formal_Entity (Formal_Node, Actual_Ent);\n \n@@ -6618,8 +6694,7 @@ package body Sem_Ch12 is\n    function Instantiate_Formal_Subprogram\n      (Formal          : Node_Id;\n       Actual          : Node_Id;\n-      Analyzed_Formal : Node_Id)\n-      return            Node_Id\n+      Analyzed_Formal : Node_Id) return Node_Id\n    is\n       Loc        : Source_Ptr := Sloc (Instantiation_Node);\n       Formal_Sub : constant Entity_Id :=\n@@ -6876,8 +6951,7 @@ package body Sem_Ch12 is\n    function Instantiate_Object\n      (Formal          : Node_Id;\n       Actual          : Node_Id;\n-      Analyzed_Formal : Node_Id)\n-      return            List_Id\n+      Analyzed_Formal : Node_Id) return List_Id\n    is\n       Formal_Id : constant Entity_Id  := Defining_Identifier (Formal);\n       Type_Id   : constant Node_Id    := Subtype_Mark (Formal);\n@@ -7604,8 +7678,7 @@ package body Sem_Ch12 is\n      (Formal          : Node_Id;\n       Actual          : Node_Id;\n       Analyzed_Formal : Node_Id;\n-      Actual_Decls    : List_Id)\n-      return            Node_Id\n+      Actual_Decls    : List_Id) return Node_Id\n    is\n       Loc       : constant Source_Ptr := Sloc (Actual);\n       Gen_T     : constant Entity_Id  := Defining_Identifier (Formal);\n@@ -7754,6 +7827,10 @@ package body Sem_Ch12 is\n          function Formal_Dimensions return Int;\n          --  Count number of dimensions in array type formal\n \n+         -----------------------\n+         -- Formal_Dimensions --\n+         -----------------------\n+\n          function Formal_Dimensions return Int is\n             Num   : Int := 0;\n             Index : Node_Id;\n@@ -8361,8 +8438,7 @@ package body Sem_Ch12 is\n    ---------------------\n \n    function Is_In_Main_Unit (N : Node_Id) return Boolean is\n-      Unum : constant Unit_Number_Type := Get_Source_Unit (N);\n-\n+      Unum         : constant Unit_Number_Type := Get_Source_Unit (N);\n       Current_Unit : Node_Id;\n \n    begin\n@@ -8850,6 +8926,40 @@ package body Sem_Ch12 is\n       Dep_Elmt : Elmt_Id;\n       Dep_Typ  : Node_Id;\n \n+      procedure Restore_Nested_Formal (Formal : Entity_Id);\n+      --  Hide the generic formals of formal packages declared with box\n+      --  which were reachable in the current instantiation.\n+\n+      procedure Restore_Nested_Formal (Formal : Entity_Id) is\n+         Ent : Entity_Id;\n+      begin\n+         if Present (Renamed_Object (Formal))\n+           and then Denotes_Formal_Package (Renamed_Object (Formal), True)\n+         then\n+            return;\n+\n+         elsif Present (Associated_Formal_Package (Formal))\n+          and then Box_Present (Parent (Associated_Formal_Package (Formal)))\n+         then\n+            Ent := First_Entity (Formal);\n+\n+            while Present (Ent) loop\n+               exit when Ekind (Ent) = E_Package\n+                 and then Renamed_Entity (Ent) = Renamed_Entity (Formal);\n+\n+               Set_Is_Hidden (Ent);\n+               Set_Is_Potentially_Use_Visible (Ent, False);\n+\n+               if Ekind (Ent) = E_Package then\n+                  --  Recurse.\n+                  Restore_Nested_Formal (Ent);\n+               end if;\n+\n+               Next_Entity (Ent);\n+            end loop;\n+         end if;\n+      end Restore_Nested_Formal;\n+\n    begin\n       M := First_Elmt (Exchanged_Views);\n       while Present (M) loop\n@@ -8930,7 +9040,7 @@ package body Sem_Ch12 is\n \n             --  If the actual is itself a formal package for the enclosing\n             --  generic, or the actual for such a formal package, it remains\n-            --  visible after the current instance, and therefore nothing\n+            --  visible on exit from the instance, and therefore nothing\n             --  needs to be done either, except to keep it accessible.\n \n             if Is_Package\n@@ -8941,7 +9051,7 @@ package body Sem_Ch12 is\n             elsif Nkind (Parent (E)) /= N_Package_Renaming_Declaration then\n                null;\n \n-            elsif Denotes_Formal_Package (Renamed_Object (E)) then\n+            elsif Denotes_Formal_Package (Renamed_Object (E), True) then\n                Set_Is_Hidden (E, False);\n \n             else\n@@ -8954,15 +9064,19 @@ package body Sem_Ch12 is\n                   while Present (Id)\n                     and then Id /= First_Private_Entity (Act_P)\n                   loop\n-                     Set_Is_Hidden (Id, True);\n-                     Set_Is_Potentially_Use_Visible (Id, In_Use (Act_P));\n                      exit when Ekind (Id) = E_Package\n                                  and then Renamed_Object (Id) = Act_P;\n \n+                     Set_Is_Hidden (Id, True);\n+                     Set_Is_Potentially_Use_Visible (Id, In_Use (Act_P));\n+\n+                     if Ekind (Id) = E_Package then\n+                        Restore_Nested_Formal (Id);\n+                     end if;\n+\n                      Next_Entity (Id);\n                   end loop;\n                end;\n-               null;\n             end if;\n          end if;\n \n@@ -9054,6 +9168,10 @@ package body Sem_Ch12 is\n          --  the current scope (e.g. when the instance appears within the body\n          --  of an ancestor).\n \n+         ----------------------\n+         -- Is_Instance_Node --\n+         ----------------------\n+\n          function Is_Instance_Node (Decl : Node_Id) return Boolean is\n          begin\n             return (Nkind (Decl) in N_Generic_Instantiation"}]}