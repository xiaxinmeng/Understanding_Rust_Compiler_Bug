{"sha": "b224c3763e018e8bdd0047b3eb283992fb655ce0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjIyNGMzNzYzZTAxOGU4YmRkMDA0N2IzZWIyODM5OTJmYjY1NWNlMA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-05-08T18:06:49Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-05-08T18:13:29Z"}, "message": "preprocessor: Reimplement directives only processing, support raw literals.\n\nThe existing directives-only code (a) punched a hole through the\nlibcpp interface and (b) didn't support raw string literals.  This\nreimplements this preprocessing mode.  I added a proper callback\ninterface, and adjusted c-ppoutput to use it.  Sadly I cannot get rid\nof the libcpp/internal.h include for unrelated reasons.\n\nThe new scanner is in lex.x, and works doing some backwards scanning\nwhen it finds a charater of interest.  This reduces the number of\ncases one has to deal with in forward scanning.  It may have different\nfailure mode than forward scanning on bad tokenization.\n\nFinally, Moved some cpp tests from the c-specific dg.gcc/cpp directory\nto the c-c++-common/cpp shared directory,\n\n\tlibcpp/\n\t* directives-only.c: Delete.\n\t* Makefile.in (libcpp_a_OBJS, libcpp_a_SOURCES): Remove it.\n\t* include/cpplib.h (enum CPP_DO_task): New enum.\n\t(cpp_directive_only_preprocess): Declare.\n\t* internal.h (_cpp_dir_only_callbacks): Delete.\n\t(_cpp_preprocess_dir_only): Delete.\n\t* lex.c (do_peek_backslask, do_peek_next, do_peek_prev): New.\n\t(cpp_directives_only_process): New implementation.\n\n\tgcc/c-family/\n\tReimplement directives only processing.\n\t* c-ppoutput.c (token_streamer): Ne.\n\t(directives_only_cb): New.  Swallow ...\n\t(print_lines_directives_only): ... this.\n\t(scan_translation_unit_directives_only): Reimplment using the\n\tpublished interface.\n\n\tgcc/testsuite/\n\t* gcc.dg/cpp/counter-[23].c: Move to c-c+_-common/cpp.\n\t* gcc.dg/cpp/dir-only-*: Likewise.\n\t* c-c++-common/cpp/dir-only-[78].c: New.", "tree": {"sha": "0b9853fb61dcbb380a433dec1f58679c77036663", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b9853fb61dcbb380a433dec1f58679c77036663"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b224c3763e018e8bdd0047b3eb283992fb655ce0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b224c3763e018e8bdd0047b3eb283992fb655ce0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b224c3763e018e8bdd0047b3eb283992fb655ce0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b224c3763e018e8bdd0047b3eb283992fb655ce0/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc484e250990393e887f7239157cc85ce6fadcce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc484e250990393e887f7239157cc85ce6fadcce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc484e250990393e887f7239157cc85ce6fadcce"}], "stats": {"total": 1035, "additions": 770, "deletions": 265}, "files": [{"sha": "0550e53494260bdad283adb8a7023b70f7c92789", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=b224c3763e018e8bdd0047b3eb283992fb655ce0", "patch": "@@ -1,3 +1,12 @@\n+2020-05-08  Nathan Sidwell  <nathan@acm.org>\n+\n+\tReimplement directives only processing.\n+\t* c-ppoutput.c (token_streamer): Ne.\n+\t(directives_only_cb): New.  Swallow ...\n+\t(print_lines_directives_only): ... this.\n+\t(scan_translation_unit_directives_only): Reimplment using the\n+\tpublished interface.\n+\n 2020-05-07  Marek Polacek  <polacek@redhat.com>\n \n \t* c-format.c (badwords): Add \"nonstatic\"."}, {"sha": "1e2b32b46ac16b0b3a6414169d39b8d0eb7d3fd6", "filename": "gcc/c-family/c-ppoutput.c", "status": "modified", "additions": 172, "deletions": 11, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Fc-family%2Fc-ppoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Fc-family%2Fc-ppoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ppoutput.c?ref=b224c3763e018e8bdd0047b3eb283992fb655ce0", "patch": "@@ -52,7 +52,6 @@ static macro_queue *define_queue, *undef_queue;\n \n /* General output routines.  */\n static void scan_translation_unit (cpp_reader *);\n-static void print_lines_directives_only (int, const void *, size_t);\n static void scan_translation_unit_directives_only (cpp_reader *);\n static void scan_translation_unit_trad (cpp_reader *);\n static void account_for_newlines (const unsigned char *, size_t);\n@@ -165,6 +164,141 @@ init_pp_output (FILE *out_stream)\n   print.prev_was_system_token = false;\n }\n \n+// FIXME: Ideally we'd just turn the entirety of the print struct into\n+// an encapsulated streamer ...\n+\n+class token_streamer\n+{\n+  bool avoid_paste;\n+  bool do_line_adjustments;\n+  bool in_pragma;\n+  bool line_marker_emitted;\n+\n+ public:\n+  token_streamer (cpp_reader *pfile)\n+    :avoid_paste (false),\n+    do_line_adjustments (cpp_get_options (pfile)->lang != CLK_ASM\n+\t\t\t && !flag_no_line_commands),\n+    in_pragma (false),\n+    line_marker_emitted (false)\n+    {\n+    }\n+\n+  void begin_pragma () \n+  {\n+    in_pragma = true;\n+  }\n+\n+  void stream (cpp_reader *pfile, const cpp_token *tok, location_t);\n+};\n+\n+void\n+token_streamer::stream (cpp_reader *pfile, const cpp_token *token,\n+\t\t\tlocation_t loc)\n+{\n+  if (token->type == CPP_PADDING)\n+    {\n+      avoid_paste = true;\n+      if (print.source == NULL\n+\t  || (!(print.source->flags & PREV_WHITE)\n+\t      && token->val.source == NULL))\n+\tprint.source = token->val.source;\n+      return;\n+    }\n+\n+  if (token->type == CPP_EOF)\n+    return;\n+\n+  /* Subtle logic to output a space if and only if necessary.  */\n+  if (avoid_paste)\n+    {\n+      int src_line = LOCATION_LINE (loc);\n+\n+      if (print.source == NULL)\n+\tprint.source = token;\n+\n+      if (src_line != print.src_line\n+\t  && do_line_adjustments\n+\t  && !in_pragma)\n+\t{\n+\t  line_marker_emitted = do_line_change (pfile, token, loc, false);\n+\t  putc (' ', print.outf);\n+\t  print.printed = true;\n+\t}\n+      else if (print.source->flags & PREV_WHITE\n+\t       || (print.prev\n+\t\t   && cpp_avoid_paste (pfile, print.prev, token))\n+\t       || (print.prev == NULL && token->type == CPP_HASH))\n+\t{\n+\t  putc (' ', print.outf);\n+\t  print.printed = true;\n+\t}\n+    }\n+  else if (token->flags & PREV_WHITE)\n+    {\n+      int src_line = LOCATION_LINE (loc);\n+\n+      if (src_line != print.src_line\n+\t  && do_line_adjustments\n+\t  && !in_pragma)\n+\tline_marker_emitted = do_line_change (pfile, token, loc, false);\n+      putc (' ', print.outf);\n+      print.printed = true;\n+    }\n+\n+  avoid_paste = false;\n+  print.source = NULL;\n+  print.prev = token;\n+  if (token->type == CPP_PRAGMA)\n+    {\n+      const char *space;\n+      const char *name;\n+\n+      line_marker_emitted = maybe_print_line (token->src_loc);\n+      fputs (\"#pragma \", print.outf);\n+      c_pp_lookup_pragma (token->val.pragma, &space, &name);\n+      if (space)\n+\tfprintf (print.outf, \"%s %s\", space, name);\n+      else\n+\tfprintf (print.outf, \"%s\", name);\n+      print.printed = true;\n+      in_pragma = true;\n+    }\n+  else if (token->type == CPP_PRAGMA_EOL)\n+    {\n+      maybe_print_line (UNKNOWN_LOCATION);\n+      in_pragma = false;\n+    }\n+  else\n+    {\n+      if (cpp_get_options (parse_in)->debug)\n+\tlinemap_dump_location (line_table, token->src_loc, print.outf);\n+\n+      if (do_line_adjustments\n+\t  && !in_pragma\n+\t  && !line_marker_emitted\n+\t  && print.prev_was_system_token != !!in_system_header_at (loc)\n+\t  && !is_location_from_builtin_token (loc))\n+\t/* The system-ness of this token is different from the one of\n+\t   the previous token.  Let's emit a line change to mark the\n+\t   new system-ness before we emit the token.  */\n+\t{\n+\t  do_line_change (pfile, token, loc, false);\n+\t  print.prev_was_system_token = !!in_system_header_at (loc);\n+\t}\n+      cpp_output_token (token, print.outf);\n+      line_marker_emitted = false;\n+      print.printed = true;\n+    }\n+\n+  /* CPP_COMMENT tokens and raw-string literal tokens can have\n+     embedded new-line characters.  Rather than enumerating all the\n+     possible token types just check if token uses val.str union\n+     member.  */\n+  if (cpp_token_val_index (token) == CPP_TOKEN_FLD_STR)\n+    account_for_newlines (token->val.str.text, token->val.str.len);\n+}\n+\n /* Writes out the preprocessed file, handling spacing and paste\n    avoidance issues.  */\n static void\n@@ -288,23 +422,50 @@ scan_translation_unit (cpp_reader *pfile)\n }\n \n static void\n-print_lines_directives_only (int lines, const void *buf, size_t size)\n+directives_only_cb (cpp_reader *pfile, CPP_DO_task task, void *data_, ...)\n {\n-  print.src_line += lines;\n-  fwrite (buf, 1, size, print.outf);\n+  va_list args;\n+  va_start (args, data_);\n+\n+  token_streamer *streamer = reinterpret_cast <token_streamer *> (data_);\n+  switch (task)\n+    {\n+    default:\n+      gcc_unreachable ();\n+\n+    case CPP_DO_print:\n+      {\n+\tprint.src_line += va_arg (args, unsigned);\n+\n+\tconst void *buf = va_arg (args, const void *);\n+\tsize_t size = va_arg (args, size_t);\n+\tfwrite (buf, 1, size, print.outf);\n+      }\n+      break;\n+\n+    case CPP_DO_location:\n+      maybe_print_line (va_arg (args, location_t));\n+      break;\n+\n+    case CPP_DO_token:\n+      {\n+\tconst cpp_token *token = va_arg (args, const cpp_token *);\n+\tlocation_t spelling_loc = va_arg (args, location_t);\n+\tstreamer->stream (pfile, token, spelling_loc);\n+      }\n+      break;\n+    }\n+\n+  va_end (args);\n }\n \n /* Writes out the preprocessed file, handling spacing and paste\n    avoidance issues.  */\n static void\n scan_translation_unit_directives_only (cpp_reader *pfile)\n {\n-  struct _cpp_dir_only_callbacks cb;\n-\n-  cb.print_lines = print_lines_directives_only;\n-  cb.maybe_print_line = maybe_print_line;\n-\n-  _cpp_preprocess_dir_only (pfile, &cb);\n+  token_streamer streamer (pfile);\n+  cpp_directive_only_process (pfile, &streamer, directives_only_cb);\n }\n \n /* Adjust print.src_line for newlines embedded in output.  */\n@@ -396,7 +557,7 @@ print_line_1 (location_t src_loc, const char *special_flags, FILE *stream)\n     putc ('\\n', stream);\n   print.printed = false;\n \n-  if (!flag_no_line_commands)\n+  if (src_loc != UNKNOWN_LOCATION && !flag_no_line_commands)\n     {\n       const char *file_path = LOCATION_FILE (src_loc);\n       int sysp;"}, {"sha": "2381a1c80f97ff76d83049fc312ccd2d9c6a3884", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b224c3763e018e8bdd0047b3eb283992fb655ce0", "patch": "@@ -1,3 +1,9 @@\n+2020-05-08  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* gcc.dg/cpp/counter-[23].c: Move to c-c+_-common/cpp.\n+\t* gcc.dg/cpp/dir-only-*: Likewise.\n+\t* c-c++-common/cpp/dir-only-[78].c: New.\n+\n 2020-05-08  Richard Biener  <rguenther@suse.de>\n \n \t* gcc.dg/vect/bb-slp-pr68892.c: Adjust for not supported"}, {"sha": "7d6578d9ce378a7e71bb27664ac0e1b55cfdd8d3", "filename": "gcc/testsuite/c-c++-common/cpp/counter-2.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fcounter-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fcounter-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fcounter-2.c?ref=b224c3763e018e8bdd0047b3eb283992fb655ce0", "previous_filename": "gcc/testsuite/gcc.dg/cpp/counter-2.c"}, {"sha": "3b1824f25d58b0a19678326b5eb5a335556bf0f7", "filename": "gcc/testsuite/c-c++-common/cpp/counter-3.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fcounter-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fcounter-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fcounter-3.c?ref=b224c3763e018e8bdd0047b3eb283992fb655ce0", "previous_filename": "gcc/testsuite/gcc.dg/cpp/counter-3.c"}, {"sha": "3c2261683c90cc90f5caa1eb5cb330fbcf161108", "filename": "gcc/testsuite/c-c++-common/cpp/dir-only-1.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-1.c?ref=b224c3763e018e8bdd0047b3eb283992fb655ce0", "previous_filename": "gcc/testsuite/gcc.dg/cpp/dir-only-1.c"}, {"sha": "96dbcc0483ce770e9182df5d36a5a52c84c6e3d4", "filename": "gcc/testsuite/c-c++-common/cpp/dir-only-1.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-1.h?ref=b224c3763e018e8bdd0047b3eb283992fb655ce0", "previous_filename": "gcc/testsuite/gcc.dg/cpp/dir-only-1.h"}, {"sha": "489b4d6ee3455554ed3a365dfd034d63e0900f26", "filename": "gcc/testsuite/c-c++-common/cpp/dir-only-2.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-2.c?ref=b224c3763e018e8bdd0047b3eb283992fb655ce0", "previous_filename": "gcc/testsuite/gcc.dg/cpp/dir-only-2.c"}, {"sha": "e6eaa018096281a5be47b9c8ed98f343e4557f98", "filename": "gcc/testsuite/c-c++-common/cpp/dir-only-3.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-3.c?ref=b224c3763e018e8bdd0047b3eb283992fb655ce0", "previous_filename": "gcc/testsuite/gcc.dg/cpp/dir-only-3.c"}, {"sha": "6644bbfb0d4999681c52c5c9fd9f7b34e514934f", "filename": "gcc/testsuite/c-c++-common/cpp/dir-only-3a.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-3a.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-3a.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-3a.h?ref=b224c3763e018e8bdd0047b3eb283992fb655ce0", "previous_filename": "gcc/testsuite/gcc.dg/cpp/dir-only-3a.h"}, {"sha": "4edaa7b6ba5f9ab672501ba955e55da07dd62c1b", "filename": "gcc/testsuite/c-c++-common/cpp/dir-only-3b.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-3b.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-3b.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-3b.h?ref=b224c3763e018e8bdd0047b3eb283992fb655ce0", "previous_filename": "gcc/testsuite/gcc.dg/cpp/dir-only-3b.h"}, {"sha": "25f1b463b6db5c6e14bb2c5333072a5a2edf9095", "filename": "gcc/testsuite/c-c++-common/cpp/dir-only-4.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-4.c?ref=b224c3763e018e8bdd0047b3eb283992fb655ce0", "previous_filename": "gcc/testsuite/gcc.dg/cpp/dir-only-4.c"}, {"sha": "747006a682b4e3c561e0ee43ace3b0354763f638", "filename": "gcc/testsuite/c-c++-common/cpp/dir-only-5.c", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-5.c?ref=b224c3763e018e8bdd0047b3eb283992fb655ce0", "patch": "@@ -1,6 +1,7 @@\n /* Copyright 2007 Free Software Foundation, Inc.\n    Contributed by Ollie Wild <aaw@google.com>.  */\n \n-/* { dg-do preprocess } */\n+/* C++ silently ignores traditional! */\n+/* { dg-do preprocess { target c } } */\n /* { dg-options \"-fdirectives-only -traditional\" } */\n /* { dg-error \"'-fdirectives-only' is incompatible with '-traditional'\\n\" \"'-traditional' check\" { target *-*-* } 0 } */", "previous_filename": "gcc/testsuite/gcc.dg/cpp/dir-only-5.c"}, {"sha": "0023205faf756c745ffdd9a49e8b50f02a05e131", "filename": "gcc/testsuite/c-c++-common/cpp/dir-only-6.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-6.c?ref=b224c3763e018e8bdd0047b3eb283992fb655ce0", "previous_filename": "gcc/testsuite/gcc.dg/cpp/dir-only-6.c"}, {"sha": "b9fb4d885288b33227758825c55e567a8a31a8ea", "filename": "gcc/testsuite/c-c++-common/cpp/dir-only-7.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-7.c?ref=b224c3763e018e8bdd0047b3eb283992fb655ce0", "patch": "@@ -0,0 +1,35 @@\n+// { dg-do preprocess  }\n+// { dg-options \"-std=c++11\" { target c++ } }\n+// { dg-options \"-std=gnu99\" { target c } }\n+// { dg-additional-options -fdirectives-only }\n+\n+R\"stuff(\n+)nope\"\n+#error in raw literal\n+)stuff\"\n+// comment\n+#define bob 1\n+// \" comment\n+#if !bob\n+#error \"no bob\"\n+#endif\n+\n+bob\\\n+\\\n+R\"regular string not an erroneous raw one\"\n+\n+\"regular\"R\"***(not a raw string\"\n+#define HERE 1\n+ //)***\"\n+#ifndef HERE\n+#error \"oops no HERE\"\n+#endif\n+ /* comment */\n+\n+\n+0e+R\"*(not a raw string\"\n+#define CPP_NUM 1\n+ //)*\"\n+#ifndef CPP_NUM\n+#error \"oops no CPP_NUM\"\n+#endif"}, {"sha": "b0e00f5b54257240cfa4c78b4a002b1114663764", "filename": "gcc/testsuite/c-c++-common/cpp/dir-only-8.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b224c3763e018e8bdd0047b3eb283992fb655ce0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fdir-only-8.c?ref=b224c3763e018e8bdd0047b3eb283992fb655ce0", "patch": "@@ -0,0 +1,38 @@\n+// { dg-do preprocess { target c++ } }\n+// { dg-options \"-std=c++14\" }\n+// { dg-additional-options -fdirectives-only }\n+\n+012'bcd\n+#define A 1\n+// '\n+#ifndef A\n+#error Fell into first char const\n+#endif\n+enum { A = 195'936'478 }; 'a'\n+#define AA 1\n+\t\t\t  // 'a\n+#ifndef AA\n+#error Fell into early char const\n+#endif\n+\n+012\\\n+'bcd\n+#define B 1\n+// '\n+#ifndef B\n+#error Fell into second char const\n+#endif\n+\n+.012'b\n+#define C 1\n+// '\n+#ifndef C\n+#error Fell into third char const\n+#endif\n+\n+.0e+12'b\n+#define D 1\n+// '\n+#ifndef D\n+#error Fell into fourth char const\n+#endif"}, {"sha": "a1b78bb7194aa2b9552c572c0d197c758bad10e4", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b224c3763e018e8bdd0047b3eb283992fb655ce0/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b224c3763e018e8bdd0047b3eb283992fb655ce0/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=b224c3763e018e8bdd0047b3eb283992fb655ce0", "patch": "@@ -1,3 +1,15 @@\n+2020-05-08  Nathan Sidwell  <nathan@acm.org>\n+\n+\tReimplement directives only processing, support raw literals.\n+\t* directives-only.c: Delete.\n+\t* Makefile.in (libcpp_a_OBJS, libcpp_a_SOURCES): Remove it.\n+\t* include/cpplib.h (enum CPP_DO_task): New enum.\n+\t(cpp_directive_only_preprocess): Declare.\n+\t* internal.h (_cpp_dir_only_callbacks): Delete.\n+\t(_cpp_preprocess_dir_only): Delete.\n+\t* lex.c (do_peek_backslask, do_peek_next, do_peek_prev): New.\n+\t(cpp_directives_only_process): New implementation.\n+\n 2020-02-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPartially implement P1042R1: __VA_OPT__ wording clarifications"}, {"sha": "3d9ca0baaf6fff168912fc2be8f743a00cd31186", "filename": "libcpp/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b224c3763e018e8bdd0047b3eb283992fb655ce0/libcpp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b224c3763e018e8bdd0047b3eb283992fb655ce0/libcpp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FMakefile.in?ref=b224c3763e018e8bdd0047b3eb283992fb655ce0", "patch": "@@ -83,11 +83,11 @@ COMPILER_FLAGS = $(ALL_CXXFLAGS)\n DEPMODE = $(CXXDEPMODE)\n \n \n-libcpp_a_OBJS = charset.o directives.o directives-only.o errors.o \\\n+libcpp_a_OBJS = charset.o directives.o errors.o \\\n \texpr.o files.o identifiers.o init.o lex.o line-map.o macro.o \\\n \tmkdeps.o pch.o symtab.o traditional.o\n \n-libcpp_a_SOURCES = charset.c directives.c directives-only.c errors.c \\\n+libcpp_a_SOURCES = charset.c directives.c errors.c \\\n \texpr.c files.c identifiers.c init.c lex.c line-map.c macro.c \\\n \tmkdeps.c pch.c symtab.c traditional.c\n "}, {"sha": "5eac118d824ff0fb6bedd6edaacb12e27321d651", "filename": "libcpp/directives-only.c", "status": "removed", "additions": 0, "deletions": 240, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc484e250990393e887f7239157cc85ce6fadcce/libcpp%2Fdirectives-only.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc484e250990393e887f7239157cc85ce6fadcce/libcpp%2Fdirectives-only.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives-only.c?ref=bc484e250990393e887f7239157cc85ce6fadcce", "patch": "@@ -1,240 +0,0 @@\n-/* CPP Library - directive only preprocessing for distributed compilation.\n-   Copyright (C) 2007-2020 Free Software Foundation, Inc.\n-   Contributed by Ollie Wild <aaw@google.com>.\n-\n-This program is free software; you can redistribute it and/or modify it\n-under the terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 3, or (at your option) any\n-later version.\n-\n-This program is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this program; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"cpplib.h\"\n-#include \"internal.h\"\n-\n-/* DO (Directive only) flags. */\n-#define DO_BOL\t\t (1 << 0) /* At the beginning of a logical line. */\n-#define DO_STRING\t (1 << 1) /* In a string constant. */\n-#define DO_CHAR\t\t (1 << 2) /* In a character constant. */\n-#define DO_BLOCK_COMMENT (1 << 3) /* In a block comment. */\n-#define DO_LINE_COMMENT\t (1 << 4) /* In a single line \"//-style\" comment. */\n-\n-#define DO_LINE_SPECIAL (DO_STRING | DO_CHAR | DO_LINE_COMMENT)\n-#define DO_SPECIAL\t(DO_LINE_SPECIAL | DO_BLOCK_COMMENT)\n-\n-/* Writes out the preprocessed file, handling spacing and paste\n-   avoidance issues.  */\n-void\n-_cpp_preprocess_dir_only (cpp_reader *pfile,\n-\t\t\t  const struct _cpp_dir_only_callbacks *cb)\n-{\n-  struct cpp_buffer *buffer;\n-  const unsigned char *cur, *base, *next_line, *rlimit;\n-  cppchar_t c, last_c;\n-  unsigned flags;\n-  linenum_type lines;\n-  int col;\n-  location_t loc;\n-\n- restart:\n-  /* Buffer initialization ala _cpp_clean_line(). */\n-  buffer = pfile->buffer;\n-  buffer->cur_note = buffer->notes_used = 0;\n-  buffer->cur = buffer->line_base = buffer->next_line;\n-  buffer->need_line = false;\n-\n-  /* This isn't really needed.  It prevents a compiler warning, though. */\n-  loc = pfile->line_table->highest_line;\n-\n-  /* Scan initialization. */\n-  next_line = cur = base = buffer->cur;\n-  rlimit = buffer->rlimit;\n-  flags = DO_BOL;\n-  lines = 0;\n-  col = 1;\n-\n-  for (last_c = '\\n', c = *cur; cur < rlimit; last_c = c, c = *++cur, ++col)\n-    {\n-      /* Skip over escaped newlines. */\n-      if (__builtin_expect (c == '\\\\', false))\n-\t{\n-\t  const unsigned char *tmp = cur + 1;\n-\n-\t  while (is_nvspace (*tmp) && tmp < rlimit)\n-\t    tmp++;\n-\t  if (*tmp == '\\r')\n-\t    tmp++;\n-\t  if (*tmp == '\\n' && tmp < rlimit)\n-\t    {\n-\t      CPP_INCREMENT_LINE (pfile, 0);\n-\t      lines++;\n-\t      col = 0;\n-\t      cur = tmp;\n-\t      c = last_c;\n-\t      continue;\n-\t    }\n-\t}\n-\n-      if (__builtin_expect (last_c == '#', false) && !(flags & DO_SPECIAL))\n-\t{\n-\t  if (c != '#' && (flags & DO_BOL))\n-\t  {\n-\t    class line_maps *line_table;\n-\n-\t    if (!pfile->state.skipping && next_line != base)\n-\t      cb->print_lines (lines, base, next_line - base);\n-\n-\t    /* Prep things for directive handling. */\n-\t    buffer->next_line = cur;\n-\t    buffer->need_line = true;\n-\t    _cpp_get_fresh_line (pfile);\n-\n-\t    /* Ensure proper column numbering for generated error messages. */\n-\t    buffer->line_base -= col - 1;\n-\n-\t    _cpp_handle_directive (pfile, false /* ignore indented */);\n-\n-\t    /* Sanitize the line settings.  Duplicate #include's can mess\n-\t       things up. */\n-\t    line_table = pfile->line_table;\n-\t    line_table->highest_location = line_table->highest_line;\n-\n-\t    /* The if block prevents us from outputing line information when\n-\t       the file ends with a directive and no newline.  Note that we\n-\t       must use pfile->buffer, not buffer. */\n-\t    if (pfile->buffer->next_line < pfile->buffer->rlimit)\n-\t      cb->maybe_print_line (pfile->line_table->highest_line);\n-\n-\t    goto restart;\n-\t  }\n-\n-\t  flags &= ~DO_BOL;\n-\t  pfile->mi_valid = false;\n-\t}\n-      else if (__builtin_expect (last_c == '/', false) \\\n-\t       && !(flags & DO_SPECIAL) && c != '*' && c != '/')\n-\t{\n-\t  /* If a previous slash is not starting a block comment, clear the\n-\t     DO_BOL flag.  */\n-\t  flags &= ~DO_BOL;\n-\t  pfile->mi_valid = false;\n-\t}\n-\n-      switch (c)\n-\t{\n-\tcase '/':\n-\t  if ((flags & DO_BLOCK_COMMENT) && last_c == '*')\n-\t    {\n-\t      flags &= ~DO_BLOCK_COMMENT;\n-\t      c = 0;\n-\t    }\n-\t  else if (!(flags & DO_SPECIAL) && last_c == '/')\n-\t    flags |= DO_LINE_COMMENT;\n-\t  else if (!(flags & DO_SPECIAL))\n-\t    /* Mark the position for possible error reporting. */\n-\t    loc = linemap_position_for_column (pfile->line_table, col);\n-\n-\t  break;\n-\n-\tcase '*':\n-\t  if (!(flags & DO_SPECIAL))\n-\t    {\n-\t      if (last_c == '/')\n-\t\tflags |= DO_BLOCK_COMMENT;\n-\t      else\n-\t\t{\n-\t\t  flags &= ~DO_BOL;\n-\t\t  pfile->mi_valid = false;\n-\t\t}\n-\t    }\n-\n-\t  break;\n-\n-\tcase '\\'':\n-\tcase '\"':\n-\t  {\n-\t    unsigned state = (c == '\"') ? DO_STRING : DO_CHAR;\n-\n-\t    if (!(flags & DO_SPECIAL))\n-\t      {\n-\t\tflags |= state;\n-\t\tflags &= ~DO_BOL;\n-\t\tpfile->mi_valid = false;\n-\t      }\n-\t    else if ((flags & state) && last_c != '\\\\')\n-\t      flags &= ~state;\n-\n-\t    break;\n-\t  }\n-\n-\tcase '\\\\':\n-\t  {\n-\t    if ((flags & (DO_STRING | DO_CHAR)) && last_c == '\\\\')\n-\t      c = 0;\n-\n-\t    if (!(flags & DO_SPECIAL))\n-\t      {\n-\t\tflags &= ~DO_BOL;\n-\t\tpfile->mi_valid = false;\n-\t      }\n-\n-\t    break;\n-\t  }\n-\n-\tcase '\\n':\n-\t  CPP_INCREMENT_LINE (pfile, 0);\n-\t  lines++;\n-\t  col = 0;\n-\t  flags &= ~DO_LINE_SPECIAL;\n-\t  if (!(flags & DO_SPECIAL))\n-\t    flags |= DO_BOL;\n-\t  break;\n-\n-\tcase '#':\n-\t  next_line = cur;\n-\t  /* Don't update DO_BOL yet. */\n-\t  break;\n-\n-\tcase ' ': case '\\t': case '\\f': case '\\v': case '\\0':\n-\t  break;\n-\n-\tdefault:\n-\t  if (!(flags & DO_SPECIAL))\n-\t    {\n-\t      flags &= ~DO_BOL;\n-\t      pfile->mi_valid = false;\n-\t    }\n-\t  break;\n-\t}\n-    }\n-\n-  if (flags & DO_BLOCK_COMMENT)\n-    cpp_error_with_line (pfile, CPP_DL_ERROR, loc, 0, \"unterminated comment\");\n-\n-  if (!pfile->state.skipping && cur != base)\n-    {\n-      /* If the file was not newline terminated, add rlimit, which is\n-         guaranteed to point to a newline, to the end of our range.  */\n-      if (cur[-1] != '\\n')\n-\t{\n-\t  cur++;\n-\t  CPP_INCREMENT_LINE (pfile, 0);\n-\t  lines++;\n-\t}\n-\n-      cb->print_lines (lines, base, cur - base);\n-    }\n-\n-  _cpp_pop_buffer (pfile);\n-  if (pfile->buffer)\n-    goto restart;\n-}"}, {"sha": "2b1e33f94ae9582127a0716d78764cddb5a377a2", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b224c3763e018e8bdd0047b3eb283992fb655ce0/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b224c3763e018e8bdd0047b3eb283992fb655ce0/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=b224c3763e018e8bdd0047b3eb283992fb655ce0", "patch": "@@ -1304,6 +1304,18 @@ extern int cpp_read_state (cpp_reader *, const char *, FILE *,\n /* In lex.c */\n extern void cpp_force_token_locations (cpp_reader *, location_t);\n extern void cpp_stop_forcing_token_locations (cpp_reader *);\n+enum CPP_DO_task\n+{\n+  CPP_DO_print,\n+  CPP_DO_location,\n+  CPP_DO_token\n+};\n+\n+extern void cpp_directive_only_process (cpp_reader *pfile,\n+\t\t\t\t\tvoid *data,\n+\t\t\t\t\tvoid (*cb) (cpp_reader *,\n+\t\t\t\t\t\t    CPP_DO_task,\n+\t\t\t\t\t\t    void *data, ...));\n \n /* In expr.c */\n extern enum cpp_ttype cpp_userdef_string_remove_type"}, {"sha": "11b6469dccd1470ef9389b4c2ff4766a7653413e", "filename": "libcpp/internal.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b224c3763e018e8bdd0047b3eb283992fb655ce0/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b224c3763e018e8bdd0047b3eb283992fb655ce0/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=b224c3763e018e8bdd0047b3eb283992fb655ce0", "patch": "@@ -747,17 +747,6 @@ extern void _cpp_do_file_change (cpp_reader *, enum lc_reason, const char *,\n extern void _cpp_pop_buffer (cpp_reader *);\n extern char *_cpp_bracket_include (cpp_reader *);\n \n-/* In directives.c */\n-struct _cpp_dir_only_callbacks\n-{\n-  /* Called to print a block of lines. */\n-  void (*print_lines) (int, const void *, size_t);\n-  bool (*maybe_print_line) (location_t);\n-};\n-\n-extern void _cpp_preprocess_dir_only (cpp_reader *,\n-\t\t\t\t      const struct _cpp_dir_only_callbacks *);\n-\n /* In traditional.c.  */\n extern bool _cpp_scan_out_logical_line (cpp_reader *, cpp_macro *, bool);\n extern bool _cpp_read_logical_line_trad (cpp_reader *);"}, {"sha": "3bcf073710eb91984265db1fee4a3d862eba60a6", "filename": "libcpp/lex.c", "status": "modified", "additions": 482, "deletions": 0, "changes": 482, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b224c3763e018e8bdd0047b3eb283992fb655ce0/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b224c3763e018e8bdd0047b3eb283992fb655ce0/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=b224c3763e018e8bdd0047b3eb283992fb655ce0", "patch": "@@ -3826,3 +3826,485 @@ cpp_stop_forcing_token_locations (cpp_reader *r)\n {\n   r->forced_token_location = 0;\n }\n+\n+/* We're looking at \\, if it's escaping EOL, look past it.  If at\n+   LIMIT, don't advance.  */\n+\n+static const unsigned char *\n+do_peek_backslash (const unsigned char *peek, const unsigned char *limit)\n+{\n+  const unsigned char *probe = peek;\n+\n+  if (__builtin_expect (peek[1] == '\\n', true))\n+    {\n+    eol:\n+      probe += 2;\n+      if (__builtin_expect (probe < limit, true))\n+\t{\n+\t  peek = probe;\n+\t  if (*peek == '\\\\')\n+\t    /* The user might be perverse.  */\n+\t    return do_peek_backslash (peek, limit);\n+\t}\n+    }\n+  else if (__builtin_expect (peek[1] == '\\r', false))\n+    {\n+      if (probe[2] == '\\n')\n+\tprobe++;\n+      goto eol;\n+    }\n+\n+  return peek;\n+}\n+\n+static const unsigned char *\n+do_peek_next (const unsigned char *peek, const unsigned char *limit)\n+{\n+  if (__builtin_expect (*peek == '\\\\', false))\n+    peek = do_peek_backslash (peek, limit);\n+  return peek;\n+}\n+\n+static const unsigned char *\n+do_peek_prev (const unsigned char *peek, const unsigned char *bound)\n+{\n+  if (peek == bound)\n+    return NULL;\n+\n+  unsigned char c = *--peek;\n+  if (__builtin_expect (c == '\\n', false)\n+      || __builtin_expect (c == 'r', false))\n+    {\n+      if (peek == bound)\n+\treturn peek;\n+      int ix = -1;\n+      if (c == '\\n' && peek[ix] == '\\r')\n+\t{\n+\t  if (peek + ix == bound)\n+\t    return peek;\n+\t  ix--;\n+\t}\n+\n+      if (peek[ix] == '\\\\')\n+\treturn do_peek_prev (peek + ix, bound);\n+\n+      return peek;\n+    }\n+  else\n+    return peek;\n+}\n+\n+/* Directives-only scanning.  Somewhat more relaxed than correct\n+   parsing -- some ill-formed programs will not be rejected.  */\n+\n+void\n+cpp_directive_only_process (cpp_reader *pfile,\n+\t\t\t    void *data,\n+\t\t\t    void (*cb) (cpp_reader *, CPP_DO_task, void *, ...))\n+{\n+  do\n+    {\n+    restart:\n+      /* Buffer initialization, but no line cleaning. */\n+      cpp_buffer *buffer = pfile->buffer;\n+      buffer->cur_note = buffer->notes_used = 0;\n+      buffer->cur = buffer->line_base = buffer->next_line;\n+      buffer->need_line = false;\n+      /* Files always end in a newline.  We rely on this for\n+\t character peeking safety.  */\n+      gcc_assert (buffer->rlimit[-1] == '\\n');\n+\n+      const unsigned char *base = buffer->cur;\n+      unsigned line_count = 0;\n+      const unsigned char *line_start = base;\n+\n+      bool bol = true;\n+      bool raw = false;\n+\n+      const unsigned char *lwm = base;\n+      for (const unsigned char *pos = base, *limit = buffer->rlimit;\n+\t   pos < limit;)\n+\t{\n+\t  unsigned char c = *pos++;\n+\t  /* This matches the switch in _cpp_lex_direct.  */\n+\t  switch (c)\n+\t    {\n+\t    case ' ': case '\\t': case '\\f': case '\\v':\n+\t      /* Whitespace, do nothing.  */\n+\t      break;\n+\n+\t    case '\\r': /* MAC line ending, or Windows \\r\\n  */\n+\t      if (*pos == '\\n')\n+\t\tpos++;\n+\t      /* FALLTHROUGH */\n+\n+\t    case '\\n':\n+\t      bol = true;\n+\n+\t    next_line:\n+\t      CPP_INCREMENT_LINE (pfile, 0);\n+\t      line_count++;\n+\t      line_start = pos;\n+\t      break;\n+\n+\t    case '\\\\':\n+\t      /* <backslash><newline> is removed, and doesn't undo any\n+\t\t preceeding escape or whatnot.  */\n+\t      if (*pos == '\\n')\n+\t\t{\n+\t\t  pos++;\n+\t\t  goto next_line;\n+\t\t}\n+\t      else if (*pos == '\\r')\n+\t\t{\n+\t\t  if (pos[1] == '\\n')\n+\t\t    pos++;\n+\t\t  pos++;\n+\t\t  goto next_line;\n+\t\t}\n+\t      goto dflt;\n+\t      \n+\t    case '#':\n+\t      if (bol)\n+\t\t{\n+\t\t  /* Line directive.  */\n+\t\t  if (pos - 1 > base && !pfile->state.skipping)\n+\t\t    cb (pfile, CPP_DO_print, data,\n+\t\t\tline_count, base, pos - 1 - base);\n+\n+\t\t  /* Prep things for directive handling. */\n+\t\t  buffer->next_line = pos;\n+\t\t  buffer->need_line = true;\n+\t\t  _cpp_get_fresh_line (pfile);\n+\n+\t\t  /* Ensure proper column numbering for generated\n+\t\t     error messages. */\n+\t\t  buffer->line_base -= pos - line_start;\n+\n+\t\t  _cpp_handle_directive (pfile, line_start + 1 != pos);\n+\n+\t\t  /* Sanitize the line settings.  Duplicate #include's can\n+\t\t     mess things up. */\n+\t\t  // FIXME: Necessary?\n+\t\t  pfile->line_table->highest_location\n+\t\t    = pfile->line_table->highest_line;\n+\n+\t\t  if (!pfile->state.skipping\n+\t\t      && pfile->buffer->next_line < pfile->buffer->rlimit)\n+\t\t    cb (pfile, CPP_DO_location, data,\n+\t\t\tpfile->line_table->highest_line);\n+\n+\t\t  goto restart;\n+\t\t}\n+\t      goto dflt;\n+\n+\t    case '/':\n+\t      {\n+\t\tconst unsigned char *peek = do_peek_next (pos, limit);\n+\t\tif (!(*peek == '/' || *peek == '*'))\n+\t\t  goto dflt;\n+\n+\t\t/* Line or block comment  */\n+\t\tbool is_block = *peek == '*';\n+\t\tbool star = false;\n+\t\tbool esc = false;\n+\t\tlocation_t sloc\n+\t\t  = linemap_position_for_column (pfile->line_table,\n+\t\t\t\t\t\t pos - line_start);\n+\n+\t\twhile (pos < limit)\n+\t\t  {\n+\t\t    char c = *pos++;\n+\t\t    switch (c)\n+\t\t      {\n+\t\t      case '\\\\':\n+\t\t\tesc = true;\n+\t\t\tbreak;\n+\n+\t\t      case '\\r':\n+\t\t\tif (*pos == '\\n')\n+\t\t\t  pos++;\n+\t\t\t/* FALLTHROUGH  */\n+\n+\t\t      case '\\n':\n+\t\t\t{\n+\t\t\t  CPP_INCREMENT_LINE (pfile, 0);\n+\t\t\t  line_count++;\n+\t\t\t  line_start = pos;\n+\t\t\t  if (!esc && !is_block)\n+\t\t\t    {\n+\t\t\t      bol = true;\n+\t\t\t      goto done_comment;\n+\t\t\t    }\n+\t\t\t}\n+\t\t\tif (!esc)\n+\t\t\t  star = false;\n+\t\t\tesc = false;\n+\t\t\tbreak;\n+\n+\t\t      case '*':\n+\t\t\tif (pos > peek && !esc)\n+\t\t\t  star = is_block;\n+\t\t\tesc = false;\n+\t\t\tbreak;\n+\n+\t\t      case '/':\n+\t\t\tif (star)\n+\t\t\t  goto done_comment;\n+\t\t\t/* FALLTHROUGH  */\n+\n+\t\t      default:\n+\t\t\tstar = false;\n+\t\t\tesc = false;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t\tcpp_error_with_line (pfile, CPP_DL_ERROR, sloc, 0,\n+\t\t\t\t     \"unterminated comment\");\n+\t      done_comment:\n+\t\tlwm = pos;\n+\t\tbreak;\n+\t      }\n+\n+\t    case '\\'':\n+\t      if (!CPP_OPTION (pfile, digit_separators))\n+\t\tgoto delimited_string;\n+\n+\t      /* Possibly a number punctuator.  */\n+\t      if (!ISIDNUM (*do_peek_next (pos, limit)))\n+\t\tgoto delimited_string;\n+\n+\t      goto quote_peek;\n+\n+\t    case '\\\"':\n+\t      if (!CPP_OPTION (pfile, rliterals))\n+\t\tgoto delimited_string;\n+\n+\t    quote_peek:\n+\t      {\n+\t\t/* For ' see if it's a number punctuator\n+\t\t   \\.?<digit>(<digit>|<identifier-nondigit>\n+\t\t   |'<digit>|'<nondigit>|[eEpP]<sign>|\\.)* */\n+\t\t/* For \" see if it's a raw string\n+\t\t   {U,L,u,u8}R.  This includes CPP_NUMBER detection,\n+\t\t   because that could be 0e+R.  */\n+\t\tconst unsigned char *peek = pos - 1;\n+\t\tbool quote_first = c == '\"';\n+\t\tbool quote_eight = false;\n+\t\tbool maybe_number_start = false;\n+\t\tbool want_number = false;\n+\n+\t\twhile ((peek = do_peek_prev (peek, lwm)))\n+\t\t  {\n+\t\t    unsigned char p = *peek;\n+\t\t    if (quote_first)\n+\t\t      {\n+\t\t\tif (!raw)\n+\t\t\t  {\n+\t\t\t    if (p != 'R')\n+\t\t\t      break;\n+\t\t\t    raw = true;\n+\t\t\t    continue;\n+\t\t\t  }\n+\n+\t\t\tquote_first = false;\n+\t\t\tif (p == 'L' || p == 'U' || p == 'u')\n+\t\t\t  ;\n+\t\t\telse if (p == '8')\n+\t\t\t  quote_eight = true;\n+\t\t\telse\n+\t\t\t  goto second_raw;\n+\t\t      }\n+\t\t    else if (quote_eight)\n+\t\t      {\n+\t\t\tif (p != 'u')\n+\t\t\t  {\n+\t\t\t    raw = false;\n+\t\t\t    break;\n+\t\t\t  }\n+\t\t\tquote_eight = false;\n+\t\t      }\n+\t\t    else if (c == '\"')\n+\t\t      {\n+\t\t      second_raw:;\n+\t\t\tif (!want_number && ISIDNUM (p))\n+\t\t\t  {\n+\t\t\t    raw = false;\n+\t\t\t    break;\n+\t\t\t  }\n+\t\t      }\n+\n+\t\t    if (ISDIGIT (p))\n+\t\t      maybe_number_start = true;\n+\t\t    else if (p == '.')\n+\t\t      want_number = true;\n+\t\t    else if (ISIDNUM (p))\n+\t\t      maybe_number_start = false;\n+\t\t    else if (p == '+' || p == '-')\n+\t\t      {\n+\t\t\tif (const unsigned char *peek_prev\n+\t\t\t    = do_peek_prev (peek, lwm))\n+\t\t\t  {\n+\t\t\t    p = *peek_prev;\n+\t\t\t    if (p == 'e' || p == 'E'\n+\t\t\t\t|| p == 'p' || p == 'P')\n+\t\t\t      {\n+\t\t\t\twant_number = true;\n+\t\t\t\tmaybe_number_start = false;\n+\t\t\t      }\n+\t\t\t    else\n+\t\t\t      break;\n+\t\t\t  }\n+\t\t\telse\n+\t\t\t  break;\n+\t\t      }\n+\t\t    else if (p == '\\'' || p == '\\\"')\n+\t\t      {\n+\t\t\t/* If this is lwm, this must be the end of a\n+\t\t\t   previous string.  So this is a trailing\n+\t\t\t   literal type, (a) if those are allowed,\n+\t\t\t     and (b) maybe_start is false.  Otherwise\n+\t\t\t     this must be a CPP_NUMBER because we've\n+\t\t\t     met another ', and we'd have checked that\n+\t\t\t     in its own right.  */\n+\t\t\tif (peek == lwm && CPP_OPTION (pfile, uliterals))\n+\t\t\t  {\n+\t\t\t    if  (!maybe_number_start && !want_number)\n+\t\t\t      /* Must be a literal type.  */\n+\t\t\t      raw = false;\n+\t\t\t  }\n+\t\t\telse if (p == '\\''\n+\t\t\t\t && CPP_OPTION (pfile, digit_separators))\n+\t\t\t  maybe_number_start = true;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t    else if (c == '\\'')\n+\t\t      break;\n+\t\t    else if (!quote_first && !quote_eight)\n+\t\t      break;\n+\t\t  }\n+\n+\t\tif (maybe_number_start)\n+\t\t  {\n+\t\t    if (c == '\\'')\n+\t\t      /* A CPP NUMBER.  */\n+\t\t      goto dflt;\n+\t\t    raw = false;\n+\t\t  }\n+\n+\t\tgoto delimited_string;\n+\t      }\n+\n+\t    delimited_string:\n+\t      {\n+\t\t/* (Possibly raw) string or char literal.  */\n+\t\tunsigned char end = c;\n+\t\tint delim_len = -1;\n+\t\tconst unsigned char *delim = NULL;\n+\t\tlocation_t sloc = linemap_position_for_column (pfile->line_table,\n+\t\t\t\t\t\t\t       pos - line_start);\n+\t\tint esc = 0;\n+\n+\t\tif (raw)\n+\t\t  {\n+\t\t    /* There can be no line breaks in the delimiter.  */\n+\t\t    delim = pos;\n+\t\t    for (delim_len = 0; (c = *pos++) != '('; delim_len++)\n+\t\t      {\n+\t\t\tif (delim_len == 16)\n+\t\t\t  {\n+\t\t\t    cpp_error_with_line (pfile, CPP_DL_ERROR,\n+\t\t\t\t\t\t sloc, 0,\n+\t\t\t\t\t\t \"raw string delimiter\"\n+\t\t\t\t\t\t \" longer than %d\"\n+\t\t\t\t\t\t \" characters\",\n+\t\t\t\t\t\t delim_len);\n+\t\t\t    raw = false;\n+\t\t\t    pos = delim;\n+\t\t\t    break;\n+\t\t\t  }\n+\t\t\tif (strchr (\") \\\\\\t\\v\\f\\n\", c))\n+\t\t\t  {\n+\t\t\t    cpp_error_with_line (pfile, CPP_DL_ERROR,\n+\t\t\t\t\t\t sloc, 0,\n+\t\t\t\t\t\t \"invalid character '%c'\"\n+\t\t\t\t\t\t \" in raw string\"\n+\t\t\t\t\t\t \" delimiter\", c);\n+\t\t\t    raw = false;\n+\t\t\t    pos = delim;\n+\t\t\t    break;\n+\t\t\t  }\n+\t\t\tif (pos >= limit)\n+\t\t\t  goto bad_string;\n+\t\t      }\n+\t\t  }\n+\n+\t\twhile (pos < limit)\n+\t\t  {\n+\t\t    char c = *pos++;\n+\t\t    switch (c)\n+\t\t      {\n+\t\t      case '\\\\':\n+\t\t\tif (!raw)\n+\t\t\t  esc++;\n+\t\t\tbreak;\n+\n+\t\t      case '\\r':\n+\t\t\tif (*pos == '\\n')\n+\t\t\t  pos++;\n+\t\t\t/* FALLTHROUGH  */\n+\n+\t\t      case '\\n':\n+\t\t\t{\n+\t\t\t  CPP_INCREMENT_LINE (pfile, 0);\n+\t\t\t  line_count++;\n+\t\t\t  line_start = pos;\n+\t\t\t}\n+\t\t\tif (esc)\n+\t\t\t  esc--;\n+\t\t\tbreak;\n+\n+\t\t      case ')':\n+\t\t\tif (raw\n+\t\t\t    && pos + delim_len + 1 < limit\n+\t\t\t    && pos[delim_len] == end\n+\t\t\t    && !memcmp (delim, pos, delim_len))\n+\t\t\t  {\n+\t\t\t    pos += delim_len + 1;\n+\t\t\t    raw = false;\n+\t\t\t    goto done_string;\n+\t\t\t  }\n+\t\t\tbreak;\n+\n+\t\t      default:\n+\t\t\tif (!raw && !(esc & 1) && c == end)\n+\t\t\t  goto done_string;\n+\t\t\tesc = 0;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      bad_string:\n+\t\tcpp_error_with_line (pfile, CPP_DL_ERROR, sloc, 0,\n+\t\t\t\t     \"unterminated literal\");\n+\t\t\n+\t      done_string:\n+\t\traw = false;\n+\t\tlwm = pos - 1;\n+\t      }\n+\t      goto dflt;\n+\n+\t    default:\n+\t    dflt:\n+\t      bol = false;\n+\t      pfile->mi_valid = false;\n+\t      break;\n+\t    }\n+\t}\n+\n+      if (buffer->rlimit > base && !pfile->state.skipping)\n+\tcb (pfile, CPP_DO_print, data, line_count, base, buffer->rlimit - base);\n+\n+      _cpp_pop_buffer (pfile);\n+    }\n+  while (pfile->buffer);\n+}"}]}