{"sha": "ff7fa4886350037f892f9565f5a26c3ecd7ffc16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY3ZmE0ODg2MzUwMDM3Zjg5MmY5NTY1ZjVhMjZjM2VjZDdmZmMxNg==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2019-02-11T15:19:59Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2019-02-11T15:19:59Z"}, "message": "[RS6000] No inline PLT for V4 bss-plt, implement -mno-pltseq\n\nInline PLT calls need PLT to be an array of addresses.  PowerPC 32-bit\nbss-plt works differently, so this patch disables inline PLT calls\nwhen -mbss-plt.  The patch also adds support for a new -mno-pltseq\noption, which may be required when linking with -mbss-plt code.\n\n\t* doc/invoke.texi (man page RS/6000 and PowerPC Options): Mention\n\t-mlongcall and -mpltseq.\n\t(RS/6000 and PowerPC Options <-mlongcall>): Mention inline PLT calls.\n\t(RS/6000 and PowerPC Options <-mpltseq>): Document.\n\t* config/rs6000/rs6000.h (TARGET_PLTSEQ): Define.\n\t* config/rs6000/sysv4.opt (mpltseq): New option.\n\t* config/rs6000/sysv4.h (TARGET_PLTSEQ): Redefine.\n\t(SUBTARGET_OVERRIDE_OPTIONS): Error if given -mpltseq when assembler\n\tsupport is lacking.  Don't allow -mpltseq with -mbss-plt.\n\t* config/rs6000/linux64.h (SUBSUBTARGET_OVERRIDE_OPTIONS): Warn if\n\t-mpltseq given for ELFv1.\n\t* config/rs6000/rs6000.c (rs6000_call_aix): Comment on UNSPEC_PLTSEQ.\n\tOnly use UNSPEC_PLTSEQ for inline PLT calls.\n\t(rs6000_call_sysv, rs6000_sibcall_sysv): Expand comments.  Only\n\tuse UNSPEC_PLTSEQ for inline PLT calls.\n\t(rs6000_indirect_call_template_1, rs6000_longcall_ref),\n\t(rs6000_call_aix, rs6000_call_sysv, rs6000_sibcall_sysv): Replace\n\tuses of HAVE_AS_PLTSEQ with TARGET_PLTSEQ, simplifying.\n\t* config/rs6000/rs6000.md (pltseq_tocsave_<mode>),\n\t(pltseq_plt16_ha_<mode>, pltseq_plt16_lo_<mode>),\n\t(pltseq_mtctr_<mode>): Likewise.\n\nFrom-SVN: r268770", "tree": {"sha": "c3d2121f3766c48ce405a451f410387388c57dd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3d2121f3766c48ce405a451f410387388c57dd4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff7fa4886350037f892f9565f5a26c3ecd7ffc16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff7fa4886350037f892f9565f5a26c3ecd7ffc16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff7fa4886350037f892f9565f5a26c3ecd7ffc16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff7fa4886350037f892f9565f5a26c3ecd7ffc16/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "271ad97b6b353eaa40c1efd6fec3b402af137482", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/271ad97b6b353eaa40c1efd6fec3b402af137482", "html_url": "https://github.com/Rust-GCC/gccrs/commit/271ad97b6b353eaa40c1efd6fec3b402af137482"}], "stats": {"total": 161, "additions": 131, "deletions": 30}, "files": [{"sha": "b43bf022066f18ec769bdde155123a2343d90929", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7fa4886350037f892f9565f5a26c3ecd7ffc16/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7fa4886350037f892f9565f5a26c3ecd7ffc16/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff7fa4886350037f892f9565f5a26c3ecd7ffc16", "patch": "@@ -1,3 +1,27 @@\n+2019-02-11  Alan Modra  <amodra@gmail.com>\n+\n+\t* doc/invoke.texi (man page RS/6000 and PowerPC Options): Mention\n+\t-mlongcall and -mpltseq.\n+\t(RS/6000 and PowerPC Options <-mlongcall>): Mention inline PLT calls.\n+\t(RS/6000 and PowerPC Options <-mpltseq>): Document.\n+\t* config/rs6000/rs6000.h (TARGET_PLTSEQ): Define.\n+\t* config/rs6000/sysv4.opt (mpltseq): New option.\n+\t* config/rs6000/sysv4.h (TARGET_PLTSEQ): Redefine.\n+\t(SUBTARGET_OVERRIDE_OPTIONS): Error if given -mpltseq when assembler\n+\tsupport is lacking.  Don't allow -mpltseq with -mbss-plt.\n+\t* config/rs6000/linux64.h (SUBSUBTARGET_OVERRIDE_OPTIONS): Warn if\n+\t-mpltseq given for ELFv1.\n+\t* config/rs6000/rs6000.c (rs6000_call_aix): Comment on UNSPEC_PLTSEQ.\n+\tOnly use UNSPEC_PLTSEQ for inline PLT calls.\n+\t(rs6000_call_sysv, rs6000_sibcall_sysv): Expand comments.  Only\n+\tuse UNSPEC_PLTSEQ for inline PLT calls.\n+\t(rs6000_indirect_call_template_1, rs6000_longcall_ref),\n+\t(rs6000_call_aix, rs6000_call_sysv, rs6000_sibcall_sysv): Replace\n+\tuses of HAVE_AS_PLTSEQ with TARGET_PLTSEQ, simplifying.\n+\t* config/rs6000/rs6000.md (pltseq_tocsave_<mode>),\n+\t(pltseq_plt16_ha_<mode>, pltseq_plt16_lo_<mode>),\n+\t(pltseq_mtctr_<mode>): Likewise.\n+\n 2019-02-11  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* acinclude.m4 (gcc_AC_INITFINI_ARRAY): Use 8-byte strings with"}, {"sha": "df1d8a9f45a63880e14f25782f19ebeb20ec078a", "filename": "gcc/config/rs6000/linux64.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7fa4886350037f892f9565f5a26c3ecd7ffc16/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7fa4886350037f892f9565f5a26c3ecd7ffc16/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=ff7fa4886350037f892f9565f5a26c3ecd7ffc16", "patch": "@@ -155,6 +155,13 @@ extern int dot_symbols;\n \t\t    TARGET_NO_SUM_IN_TOC = 0;\t\t\t\\\n \t\t}\t\t\t\t\t\t\\\n \t    }\t\t\t\t\t\t\t\\\n+\t  if (TARGET_PLTSEQ && DEFAULT_ABI != ABI_ELFv2)\t\\\n+\t    {\t\t\t\t\t\t\t\\\n+\t      if (global_options_set.x_rs6000_pltseq)\t\t\\\n+\t\twarning (0, \"%qs unsupported for this ABI\",\t\\\n+\t\t\t \"-mpltseq\");\t\t\t\t\\\n+\t      rs6000_pltseq = false;\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\\"}, {"sha": "b4db03203a24abde5890b3900c1ce83cc8ab60a2", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 43, "deletions": 23, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7fa4886350037f892f9565f5a26c3ecd7ffc16/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7fa4886350037f892f9565f5a26c3ecd7ffc16/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=ff7fa4886350037f892f9565f5a26c3ecd7ffc16", "patch": "@@ -21665,7 +21665,7 @@ rs6000_indirect_call_template_1 (rtx *operands, unsigned int funop,\n \t\t    || (REG_P (operands[funop])\n \t\t\t&& REGNO (operands[funop]) == LR_REGNO));\n \n-  if (!TARGET_MACHO && HAVE_AS_PLTSEQ && GET_CODE (operands[funop]) == UNSPEC)\n+  if (TARGET_PLTSEQ && GET_CODE (operands[funop]) == UNSPEC)\n     {\n       const char *rel64 = TARGET_64BIT ? \"64\" : \"\";\n       char tls[29];\n@@ -32827,8 +32827,7 @@ rs6000_longcall_ref (rtx call_ref, rtx arg)\n       call_ref = gen_rtx_SYMBOL_REF (VOIDmode, IDENTIFIER_POINTER (node));\n     }\n \n-  if (HAVE_AS_PLTSEQ\n-      && (DEFAULT_ABI == ABI_ELFv2 || DEFAULT_ABI == ABI_V4))\n+  if (TARGET_PLTSEQ)\n     {\n       rtx base = const0_rtx;\n       int regno;\n@@ -37793,14 +37792,20 @@ rs6000_call_aix (rtx value, rtx func_desc, rtx tlsarg, rtx cookie)\n   rtx call[4];\n   int n_call;\n   rtx insn;\n+  bool is_pltseq_longcall;\n \n   if (global_tlsarg)\n     tlsarg = global_tlsarg;\n \n   /* Handle longcall attributes.  */\n+  is_pltseq_longcall = false;\n   if ((INTVAL (cookie) & CALL_LONG) != 0\n       && GET_CODE (func_desc) == SYMBOL_REF)\n-    func = rs6000_longcall_ref (func_desc, tlsarg);\n+    {\n+      func = rs6000_longcall_ref (func_desc, tlsarg);\n+      if (TARGET_PLTSEQ)\n+\tis_pltseq_longcall = true;\n+    }\n \n   /* Handle indirect calls.  */\n   if (!SYMBOL_REF_P (func)\n@@ -37825,10 +37830,12 @@ rs6000_call_aix (rtx value, rtx func_desc, rtx tlsarg, rtx cookie)\n \t\t\t\t\t     gen_rtx_PLUS (Pmode, stack_ptr,\n \t\t\t\t\t\t\t   stack_toc_offset));\n \t  MEM_VOLATILE_P (stack_toc_mem) = 1;\n-\t  if (HAVE_AS_PLTSEQ\n-\t      && DEFAULT_ABI == ABI_ELFv2\n-\t      && GET_CODE (func_desc) == SYMBOL_REF)\n+\t  if (is_pltseq_longcall)\n \t    {\n+\t      /* Use USPEC_PLTSEQ here to emit every instruction in an\n+\t\t inline PLT call sequence with a reloc, enabling the\n+\t\t linker to edit the sequence back to a direct call\n+\t\t when that makes sense.  */\n \t      rtvec v = gen_rtvec (3, toc_reg, func_desc, tlsarg);\n \t      rtx mark_toc_reg = gen_rtx_UNSPEC (Pmode, v, UNSPEC_PLTSEQ);\n \t      emit_insn (gen_rtx_SET (stack_toc_mem, mark_toc_reg));\n@@ -37849,8 +37856,7 @@ rs6000_call_aix (rtx value, rtx func_desc, rtx tlsarg, rtx cookie)\n \t     calls via LR, so move the address there.  Needed to mark\n \t     this insn for linker plt sequence editing too.  */\n \t  func_addr = gen_rtx_REG (Pmode, CTR_REGNO);\n-\t  if (HAVE_AS_PLTSEQ\n-\t      && GET_CODE (func_desc) == SYMBOL_REF)\n+\t  if (is_pltseq_longcall)\n \t    {\n \t      rtvec v = gen_rtvec (3, abi_reg, func_desc, tlsarg);\n \t      rtx mark_func = gen_rtx_UNSPEC (Pmode, v, UNSPEC_PLTSEQ);\n@@ -37988,9 +37994,15 @@ rs6000_call_sysv (rtx value, rtx func_desc, rtx tlsarg, rtx cookie)\n       && GET_CODE (func_desc) == SYMBOL_REF)\n     {\n       func = rs6000_longcall_ref (func_desc, tlsarg);\n-      /* If the longcall was implemented using PLT16 relocs, then r11\n-\t needs to be valid at the call for lazy linking.  */\n-      if (HAVE_AS_PLTSEQ)\n+      /* If the longcall was implemented as an inline PLT call using\n+\t PLT unspecs then func will be REG:r11.  If not, func will be\n+\t a pseudo reg.  The inline PLT call sequence supports lazy\n+\t linking (and longcalls to functions in dlopen'd libraries).\n+\t The other style of longcalls don't.  The lazy linking entry\n+\t to the dynamic symbol resolver requires r11 be the function\n+\t address (as it is for linker generated PLT stubs).  Ensure\n+\t r11 stays valid to the bctrl by marking r11 used by the call.  */\n+      if (TARGET_PLTSEQ)\n \tabi_reg = func;\n     }\n \n@@ -38000,11 +38012,12 @@ rs6000_call_sysv (rtx value, rtx func_desc, rtx tlsarg, rtx cookie)\n       func = force_reg (Pmode, func);\n \n       /* Indirect calls via CTR are strongly preferred over indirect\n-\t calls via LR, so move the address there.  Needed to mark\n-\t this insn for linker plt sequence editing too.  */\n+\t calls via LR, so move the address there.  That can't be left\n+\t to reload because we want to mark every instruction in an\n+\t inline PLT call sequence with a reloc, enabling the linker to\n+\t edit the sequence back to a direct call when that makes sense.  */\n       func_addr = gen_rtx_REG (Pmode, CTR_REGNO);\n-      if (HAVE_AS_PLTSEQ\n-\t  && GET_CODE (func_desc) == SYMBOL_REF)\n+      if (abi_reg)\n \t{\n \t  rtvec v = gen_rtvec (3, func, func_desc, tlsarg);\n \t  rtx mark_func = gen_rtx_UNSPEC (Pmode, v, UNSPEC_PLTSEQ);\n@@ -38058,9 +38071,15 @@ rs6000_sibcall_sysv (rtx value, rtx func_desc, rtx tlsarg, rtx cookie)\n       && GET_CODE (func_desc) == SYMBOL_REF)\n     {\n       func = rs6000_longcall_ref (func_desc, tlsarg);\n-      /* If the longcall was implemented using PLT16 relocs, then r11\n-\t needs to be valid at the call for lazy linking.  */\n-      if (HAVE_AS_PLTSEQ)\n+      /* If the longcall was implemented as an inline PLT call using\n+\t PLT unspecs then func will be REG:r11.  If not, func will be\n+\t a pseudo reg.  The inline PLT call sequence supports lazy\n+\t linking (and longcalls to functions in dlopen'd libraries).\n+\t The other style of longcalls don't.  The lazy linking entry\n+\t to the dynamic symbol resolver requires r11 be the function\n+\t address (as it is for linker generated PLT stubs).  Ensure\n+\t r11 stays valid to the bctr by marking r11 used by the call.  */\n+      if (TARGET_PLTSEQ)\n \tabi_reg = func;\n     }\n \n@@ -38069,11 +38088,12 @@ rs6000_sibcall_sysv (rtx value, rtx func_desc, rtx tlsarg, rtx cookie)\n     {\n       func = force_reg (Pmode, func);\n \n-      /* Indirect sibcalls must go via CTR.  Needed to mark\n-\t this insn for linker plt sequence editing too.  */\n+      /* Indirect sibcalls must go via CTR.  That can't be left to\n+\t reload because we want to mark every instruction in an inline\n+\t PLT call sequence with a reloc, enabling the linker to edit\n+\t the sequence back to a direct call when that makes sense.  */\n       func_addr = gen_rtx_REG (Pmode, CTR_REGNO);\n-      if (HAVE_AS_PLTSEQ\n-\t  && GET_CODE (func_desc) == SYMBOL_REF)\n+      if (abi_reg)\n \t{\n \t  rtvec v = gen_rtvec (3, func, func_desc, tlsarg);\n \t  rtx mark_func = gen_rtx_UNSPEC (Pmode, v, UNSPEC_PLTSEQ);"}, {"sha": "3b7052552192db6840d278e9bbfb267169d89633", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7fa4886350037f892f9565f5a26c3ecd7ffc16/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7fa4886350037f892f9565f5a26c3ecd7ffc16/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=ff7fa4886350037f892f9565f5a26c3ecd7ffc16", "patch": "@@ -226,6 +226,10 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n #define HAVE_AS_PLTSEQ 0\n #endif\n \n+#ifndef TARGET_PLTSEQ\n+#define TARGET_PLTSEQ 0\n+#endif\n+\n #ifndef TARGET_LINK_STACK\n #define TARGET_LINK_STACK 0\n #endif"}, {"sha": "5bca96b70d13ab5b748d4739b58d2f5ce8c8f19d", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7fa4886350037f892f9565f5a26c3ecd7ffc16/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7fa4886350037f892f9565f5a26c3ecd7ffc16/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=ff7fa4886350037f892f9565f5a26c3ecd7ffc16", "patch": "@@ -10179,7 +10179,7 @@\n \t\t   (match_operand:P 2 \"symbol_ref_operand\" \"s\")\n \t\t   (match_operand:P 3 \"\" \"\")]\n \t\t  UNSPEC_PLTSEQ))]\n-  \"HAVE_AS_PLTSEQ\n+  \"TARGET_PLTSEQ\n    && DEFAULT_ABI == ABI_ELFv2\"\n {\n   return rs6000_pltseq_template (operands, 0);\n@@ -10191,8 +10191,7 @@\n \t\t   (match_operand:P 2 \"symbol_ref_operand\" \"s\")\n \t\t   (match_operand:P 3 \"\" \"\")]\n \t\t  UNSPEC_PLT16_HA))]\n-  \"HAVE_AS_PLTSEQ\n-   && (DEFAULT_ABI == ABI_ELFv2 || DEFAULT_ABI == ABI_V4)\"\n+  \"TARGET_PLTSEQ\"\n {\n   return rs6000_pltseq_template (operands, 1);\n })\n@@ -10203,8 +10202,7 @@\n \t\t   (match_operand:P 2 \"symbol_ref_operand\" \"s\")\n \t\t   (match_operand:P 3 \"\" \"\")]\n \t\t  UNSPEC_PLT16_LO))]\n-  \"HAVE_AS_PLTSEQ\n-   && (DEFAULT_ABI == ABI_ELFv2 || DEFAULT_ABI == ABI_V4)\"\n+  \"TARGET_PLTSEQ\"\n {\n   return rs6000_pltseq_template (operands, 2);\n }\n@@ -10216,8 +10214,7 @@\n \t\t   (match_operand:P 2 \"symbol_ref_operand\" \"s\")\n \t\t   (match_operand:P 3 \"\" \"\")]\n \t\t  UNSPEC_PLTSEQ))]\n-  \"HAVE_AS_PLTSEQ\n-   && (DEFAULT_ABI == ABI_ELFv2 || DEFAULT_ABI == ABI_V4)\"\n+  \"TARGET_PLTSEQ\"\n {\n   return rs6000_pltseq_template (operands, 3);\n })"}, {"sha": "3861efdfee6fcd95a9ff792f22c0134797c2ed74", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7fa4886350037f892f9565f5a26c3ecd7ffc16/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7fa4886350037f892f9565f5a26c3ecd7ffc16/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=ff7fa4886350037f892f9565f5a26c3ecd7ffc16", "patch": "@@ -59,6 +59,11 @@\n #define TARGET_SECURE_PLT\tsecure_plt\n #endif\n \n+#if HAVE_AS_PLTSEQ\n+#undef TARGET_PLTSEQ\n+#define TARGET_PLTSEQ rs6000_pltseq\n+#endif\n+\n #define SDATA_DEFAULT_SIZE 8\n \n /* The macro SUBTARGET_OVERRIDE_OPTIONS is provided for subtargets, to\n@@ -192,6 +197,26 @@ do {\t\t\t\t\t\t\t\t\t\\\n       error (\"%qs not supported by your assembler\", \"-msecure-plt\");\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_PLTSEQ != rs6000_pltseq\t\t\t\t\t\\\n+      && global_options_set.x_rs6000_pltseq)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      error (\"%qs not supported by your assembler\", \"-mpltseq\");\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (DEFAULT_ABI == ABI_V4 && TARGET_PLTSEQ && !TARGET_SECURE_PLT)\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (global_options_set.x_rs6000_pltseq)\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (global_options_set.x_secure_plt)\t\t\t\t\\\n+\t    error (\"%qs and %qs are incompatible\",\t\t\t\\\n+\t\t   \"-mpltseq\", \"-mbss-plt\");\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    secure_plt = true;\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (!TARGET_SECURE_PLT)\t\t\t\t\t\t\\\n+\trs6000_pltseq = false;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n   if (flag_pic > 1 && DEFAULT_ABI == ABI_V4)\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       /* Note: flag_pic should not change any option flags that would\t\\"}, {"sha": "07e6df72495553d0ccc6db9a993bd41de85ccc35", "filename": "gcc/config/rs6000/sysv4.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7fa4886350037f892f9565f5a26c3ecd7ffc16/gcc%2Fconfig%2Frs6000%2Fsysv4.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7fa4886350037f892f9565f5a26c3ecd7ffc16/gcc%2Fconfig%2Frs6000%2Fsysv4.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.opt?ref=ff7fa4886350037f892f9565f5a26c3ecd7ffc16", "patch": "@@ -160,6 +160,10 @@ mbss-plt\n Target Report RejectNegative Var(secure_plt, 0) Save\n Generate code for old exec BSS PLT.\n \n+mpltseq\n+Target Report Var(rs6000_pltseq) Init(1) Save\n+Use inline plt sequences to implement long calls and -fno-plt.\n+\n mgnu-attribute\n Target Report Var(rs6000_gnu_attr) Init(1) Save\n Emit .gnu_attribute tags."}, {"sha": "f5044a6294d5be0c6411bf5fd696e9940d971ad3", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff7fa4886350037f892f9565f5a26c3ecd7ffc16/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff7fa4886350037f892f9565f5a26c3ecd7ffc16/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=ff7fa4886350037f892f9565f5a26c3ecd7ffc16", "patch": "@@ -1095,6 +1095,7 @@ See RS/6000 and PowerPC Options.\n -mtraceback=@var{traceback_type} @gol\n -maix-struct-return  -msvr4-struct-return @gol\n -mabi=@var{abi-type}  -msecure-plt  -mbss-plt @gol\n+-mlongcall  -mno-longcall  -mpltseq  -mno-pltseq  @gol\n -mblock-move-inline-limit=@var{num} @gol\n -mblock-compare-inline-limit=@var{num} @gol\n -mblock-compare-inline-loop-limit=@var{num} @gol\n@@ -24834,6 +24835,11 @@ generate slower code.  As of this writing, the AIX linker can do this,\n as can the GNU linker for PowerPC/64.  It is planned to add this feature\n to the GNU linker for 32-bit PowerPC systems as well.\n \n+On PowerPC64 ELFv2 and 32-bit PowerPC systems with newer GNU linkers,\n+GCC can generate long calls using an inline PLT call sequence (see\n+@option{-mpltseq}).  PowerPC with @option{-mbss-plt} and PowerPC64\n+ELFv1 (big-endian) do not support inline PLT calls.\n+\n On Darwin/PPC systems, @code{#pragma longcall} generates @code{jbsr\n callee, L42}, plus a @dfn{branch island} (glue code).  The two target\n addresses represent the callee and the branch island.  The\n@@ -24851,6 +24857,20 @@ to use or discard it.\n In the future, GCC may ignore all longcall specifications\n when the linker is known to generate glue.\n \n+@item -mpltseq\n+@itemx -mno-pltseq\n+@opindex mpltseq\n+@opindex mno-pltseq\n+Implement (do not implement) -fno-plt and long calls using an inline\n+PLT call sequence that supports lazy linking and long calls to\n+functions in dlopen'd shared libraries.  Inline PLT calls are only\n+supported on PowerPC64 ELFv2 and 32-bit PowerPC systems with newer GNU\n+linkers, and are enabled by default if the support is detected when\n+configuring GCC, and, in the case of 32-bit PowerPC, if GCC is\n+configured with @option{--enable-secureplt}.  @option{-mpltseq} code\n+and @option{-mbss-plt} 32-bit PowerPC relocatable objects may not be\n+linked together.\n+\n @item -mtls-markers\n @itemx -mno-tls-markers\n @opindex mtls-markers"}]}