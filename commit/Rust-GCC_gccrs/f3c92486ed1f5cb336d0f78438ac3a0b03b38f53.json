{"sha": "f3c92486ed1f5cb336d0f78438ac3a0b03b38f53", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjNjOTI0ODZlZDFmNWNiMzM2ZDBmNzg0MzhhYzNhMGIwM2IzOGY1Mw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-11-21T09:19:31Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-11-21T09:19:31Z"}, "message": "tree-vect-loop-manip.c (vect_build_loop_niters, [...]): Move ...\n\n2013-11-21  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-loop-manip.c (vect_build_loop_niters,\n\tvect_generate_tmps_on_preheader): Move ...\n\t* tree-vect-loop.c (vect_build_loop_niters,\n\tvect_generate_tmps_on_preheader): ... here and simplify.\n\t(vect_transform_loop): Call them here and pass down results\n\tto consumers.\n\t* tree-vect-loop-manip.c (vect_do_peeling_for_loop_bound):\n\tGet niter variables from caller.\n\t(vect_do_peeling_for_alignment): Likewise.\n\t* tree-vectorizer.h (vect_generate_tmps_on_preheader): Remove.\n\t(vect_do_peeling_for_loop_bound, vect_do_peeling_for_alignment):\n\tAdjust prototypes.\n\nFrom-SVN: r205199", "tree": {"sha": "23b6817225b21487b85dd002e5453634bef5bd95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23b6817225b21487b85dd002e5453634bef5bd95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3c92486ed1f5cb336d0f78438ac3a0b03b38f53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3c92486ed1f5cb336d0f78438ac3a0b03b38f53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3c92486ed1f5cb336d0f78438ac3a0b03b38f53", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3c92486ed1f5cb336d0f78438ac3a0b03b38f53/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7276921760f1b9a8ec3e6f34644c1399dff1b9b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7276921760f1b9a8ec3e6f34644c1399dff1b9b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7276921760f1b9a8ec3e6f34644c1399dff1b9b1"}], "stats": {"total": 323, "additions": 153, "deletions": 170}, "files": [{"sha": "cecd7578cad4260ec149d95d8ac36a75fa5568af", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3c92486ed1f5cb336d0f78438ac3a0b03b38f53/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3c92486ed1f5cb336d0f78438ac3a0b03b38f53/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f3c92486ed1f5cb336d0f78438ac3a0b03b38f53", "patch": "@@ -1,3 +1,18 @@\n+2013-11-21  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-loop-manip.c (vect_build_loop_niters,\n+\tvect_generate_tmps_on_preheader): Move ...\n+\t* tree-vect-loop.c (vect_build_loop_niters,\n+\tvect_generate_tmps_on_preheader): ... here and simplify.\n+\t(vect_transform_loop): Call them here and pass down results\n+\tto consumers.\n+\t* tree-vect-loop-manip.c (vect_do_peeling_for_loop_bound):\n+\tGet niter variables from caller.\n+\t(vect_do_peeling_for_alignment): Likewise.\n+\t* tree-vectorizer.h (vect_generate_tmps_on_preheader): Remove.\n+\t(vect_do_peeling_for_loop_bound, vect_do_peeling_for_alignment):\n+\tAdjust prototypes.\n+\n 2013-11-21  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-loop-ch.c (copy_loop_headers): Decrement"}, {"sha": "a03b54c1f97d601dab97f5967ed80e33b19cbfb4", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 6, "deletions": 159, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3c92486ed1f5cb336d0f78438ac3a0b03b38f53/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3c92486ed1f5cb336d0f78438ac3a0b03b38f53/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=f3c92486ed1f5cb336d0f78438ac3a0b03b38f53", "patch": "@@ -1400,151 +1400,6 @@ find_loop_location (struct loop *loop)\n }\n \n \n-/* This function builds ni_name = number of iterations loop executes\n-   on the loop preheader.  If SEQ is given the stmt is instead emitted\n-   there.  */\n-\n-static tree\n-vect_build_loop_niters (loop_vec_info loop_vinfo, gimple_seq seq)\n-{\n-  tree ni_name, var;\n-  gimple_seq stmts = NULL;\n-  edge pe;\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  tree ni = unshare_expr (LOOP_VINFO_NITERS (loop_vinfo));\n-\n-  var = create_tmp_var (TREE_TYPE (ni), \"niters\");\n-  ni_name = force_gimple_operand (ni, &stmts, false, var);\n-\n-  pe = loop_preheader_edge (loop);\n-  if (stmts)\n-    {\n-      if (seq)\n-\tgimple_seq_add_seq (&seq, stmts);\n-      else\n-\t{\n-\t  basic_block new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n-\t  gcc_assert (!new_bb);\n-\t}\n-    }\n-\n-  return ni_name;\n-}\n-\n-\n-/* This function generates the following statements:\n-\n- ni_name = number of iterations loop executes\n- ratio = ni_name / vf\n- ratio_mult_vf_name = ratio * vf\n-\n- and places them at the loop preheader edge or in COND_EXPR_STMT_LIST\n- if that is non-NULL.  */\n-\n-void\n-vect_generate_tmps_on_preheader (loop_vec_info loop_vinfo,\n-\t\t\t\t tree *ni_name_ptr,\n-\t\t\t\t tree *ratio_mult_vf_name_ptr,\n-\t\t\t\t tree *ratio_name_ptr,\n-\t\t\t\t gimple_seq cond_expr_stmt_list)\n-{\n-\n-  edge pe;\n-  basic_block new_bb;\n-  gimple_seq stmts;\n-  tree ni_name, ni_minus_gap_name;\n-  tree var;\n-  tree ratio_name;\n-  tree ratio_mult_vf_name;\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  tree ni = LOOP_VINFO_NITERS (loop_vinfo);\n-  int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-  tree log_vf;\n-\n-  pe = loop_preheader_edge (loop);\n-\n-  /* Generate temporary variable that contains\n-     number of iterations loop executes.  */\n-\n-  ni_name = vect_build_loop_niters (loop_vinfo, cond_expr_stmt_list);\n-  log_vf = build_int_cst (TREE_TYPE (ni), exact_log2 (vf));\n-\n-  /* If epilogue loop is required because of data accesses with gaps, we\n-     subtract one iteration from the total number of iterations here for\n-     correct calculation of RATIO.  */\n-  if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n-    {\n-      ni_minus_gap_name = fold_build2 (MINUS_EXPR, TREE_TYPE (ni_name),\n-\t\t\t\t       ni_name,\n-\t\t\t               build_one_cst (TREE_TYPE (ni_name)));\n-      if (!is_gimple_val (ni_minus_gap_name))\n-\t{\n-\t  var = create_tmp_var (TREE_TYPE (ni), \"ni_gap\");\n-\n-          stmts = NULL;\n-          ni_minus_gap_name = force_gimple_operand (ni_minus_gap_name, &stmts,\n-\t\t\t\t\t\t    true, var);\n-          if (cond_expr_stmt_list)\n-            gimple_seq_add_seq (&cond_expr_stmt_list, stmts);\n-          else\n-            {\n-              pe = loop_preheader_edge (loop);\n-              new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n-              gcc_assert (!new_bb);\n-            }\n-        }\n-    }\n-  else\n-    ni_minus_gap_name = ni_name;\n-\n-  /* Create: ratio = ni >> log2(vf) */\n-\n-  ratio_name = fold_build2 (RSHIFT_EXPR, TREE_TYPE (ni_minus_gap_name),\n-\t\t\t    ni_minus_gap_name, log_vf);\n-  if (!is_gimple_val (ratio_name))\n-    {\n-      var = create_tmp_var (TREE_TYPE (ni), \"bnd\");\n-\n-      stmts = NULL;\n-      ratio_name = force_gimple_operand (ratio_name, &stmts, true, var);\n-      if (cond_expr_stmt_list)\n-\tgimple_seq_add_seq (&cond_expr_stmt_list, stmts);\n-      else\n-\t{\n-\t  pe = loop_preheader_edge (loop);\n-\t  new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n-\t  gcc_assert (!new_bb);\n-\t}\n-    }\n-\n-  /* Create: ratio_mult_vf = ratio << log2 (vf).  */\n-\n-  ratio_mult_vf_name = fold_build2 (LSHIFT_EXPR, TREE_TYPE (ratio_name),\n-\t\t\t\t    ratio_name, log_vf);\n-  if (!is_gimple_val (ratio_mult_vf_name))\n-    {\n-      var = create_tmp_var (TREE_TYPE (ni), \"ratio_mult_vf\");\n-\n-      stmts = NULL;\n-      ratio_mult_vf_name = force_gimple_operand (ratio_mult_vf_name, &stmts,\n-\t\t\t\t\t\t true, var);\n-      if (cond_expr_stmt_list)\n-\tgimple_seq_add_seq (&cond_expr_stmt_list, stmts);\n-      else\n-\t{\n-\t  pe = loop_preheader_edge (loop);\n-\t  new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n-\t  gcc_assert (!new_bb);\n-\t}\n-    }\n-\n-  *ni_name_ptr = ni_name;\n-  *ratio_mult_vf_name_ptr = ratio_mult_vf_name;\n-  *ratio_name_ptr = ratio_name;\n-\n-  return;\n-}\n-\n /* Function vect_can_advance_ivs_p\n \n    In case the number of iterations that LOOP iterates is unknown at compile\n@@ -1762,10 +1617,10 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n    test.  */\n \n void\n-vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n+vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo,\n+\t\t\t\ttree ni_name, tree ratio_mult_vf_name,\n \t\t\t\tunsigned int th, bool check_profitability)\n {\n-  tree ni_name, ratio_mult_vf_name;\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   struct loop *new_loop;\n   edge update_e;\n@@ -1781,15 +1636,6 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n \n   initialize_original_copy_tables ();\n \n-  /* Generate the following variables on the preheader of original loop:\n-\n-     ni_name = number of iteration the original loop executes\n-     ratio = ni_name / vf\n-     ratio_mult_vf_name = ratio * vf  */\n-  vect_generate_tmps_on_preheader (loop_vinfo, &ni_name,\n-\t\t\t\t   &ratio_mult_vf_name, ratio,\n-\t\t\t\t   cond_expr_stmt_list);\n-\n   loop_num  = loop->num;\n \n   new_loop = slpeel_tree_peel_loop_to_edge (loop, single_exit (loop),\n@@ -2025,11 +1871,11 @@ vect_update_inits_of_drs (loop_vec_info loop_vinfo, tree niters)\n    peeling is recorded in LOOP_VINFO_UNALIGNED_DR.  */\n \n void\n-vect_do_peeling_for_alignment (loop_vec_info loop_vinfo,\n+vect_do_peeling_for_alignment (loop_vec_info loop_vinfo, tree ni_name,\n \t\t\t       unsigned int th, bool check_profitability)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  tree niters_of_prolog_loop, ni_name;\n+  tree niters_of_prolog_loop;\n   tree n_iters;\n   tree wide_prolog_niters;\n   struct loop *new_loop;\n@@ -2043,7 +1889,8 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo,\n \n   initialize_original_copy_tables ();\n \n-  ni_name = vect_build_loop_niters (loop_vinfo, NULL);\n+  gimple_seq stmts = NULL;\n+  gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);\n   niters_of_prolog_loop = vect_gen_niters_for_prolog_loop (loop_vinfo,\n \t\t\t\t\t\t\t   ni_name,\n \t\t\t\t\t\t\t   &bound);"}, {"sha": "36393da8ad307a32ba1d7d24e34ecb59da27cc76", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 129, "deletions": 7, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3c92486ed1f5cb336d0f78438ac3a0b03b38f53/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3c92486ed1f5cb336d0f78438ac3a0b03b38f53/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=f3c92486ed1f5cb336d0f78438ac3a0b03b38f53", "patch": "@@ -5572,6 +5572,110 @@ vect_loop_kill_debug_uses (struct loop *loop, gimple stmt)\n     }\n }\n \n+\n+/* This function builds ni_name = number of iterations.  Statements\n+   are queued onto SEQ.  */\n+\n+static tree\n+vect_build_loop_niters (loop_vec_info loop_vinfo, gimple_seq *seq)\n+{\n+  tree ni_name, var;\n+  gimple_seq stmts = NULL;\n+  tree ni = unshare_expr (LOOP_VINFO_NITERS (loop_vinfo));\n+\n+  var = create_tmp_var (TREE_TYPE (ni), \"niters\");\n+  ni_name = force_gimple_operand (ni, &stmts, false, var);\n+\n+  if (stmts)\n+    gimple_seq_add_seq (seq, stmts);\n+\n+  return ni_name;\n+}\n+\n+\n+/* This function generates the following statements:\n+\n+ ni_name = number of iterations loop executes\n+ ratio = ni_name / vf\n+ ratio_mult_vf_name = ratio * vf\n+\n+ and places them in COND_EXPR_STMT_LIST.  */\n+\n+static void\n+vect_generate_tmps_on_preheader (loop_vec_info loop_vinfo,\n+\t\t\t\t tree ni_name,\n+\t\t\t\t tree *ratio_mult_vf_name_ptr,\n+\t\t\t\t tree *ratio_name_ptr,\n+\t\t\t\t gimple_seq *cond_expr_stmt_list)\n+{\n+  gimple_seq stmts;\n+  tree ni_minus_gap_name;\n+  tree var;\n+  tree ratio_name;\n+  tree ratio_mult_vf_name;\n+  tree ni = LOOP_VINFO_NITERS (loop_vinfo);\n+  int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  tree log_vf;\n+\n+  log_vf = build_int_cst (TREE_TYPE (ni), exact_log2 (vf));\n+\n+  /* If epilogue loop is required because of data accesses with gaps, we\n+     subtract one iteration from the total number of iterations here for\n+     correct calculation of RATIO.  */\n+  if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n+    {\n+      ni_minus_gap_name = fold_build2 (MINUS_EXPR, TREE_TYPE (ni_name),\n+\t\t\t\t       ni_name,\n+\t\t\t               build_one_cst (TREE_TYPE (ni_name)));\n+      if (!is_gimple_val (ni_minus_gap_name))\n+\t{\n+\t  var = create_tmp_var (TREE_TYPE (ni), \"ni_gap\");\n+\n+          stmts = NULL;\n+          ni_minus_gap_name = force_gimple_operand (ni_minus_gap_name, &stmts,\n+\t\t\t\t\t\t    true, var);\n+\t  gimple_seq_add_seq (cond_expr_stmt_list, stmts);\n+        }\n+    }\n+  else\n+    ni_minus_gap_name = ni_name;\n+\n+  /* Create: ratio = ni >> log2(vf) */\n+\n+  ratio_name = fold_build2 (RSHIFT_EXPR, TREE_TYPE (ni_minus_gap_name),\n+\t\t\t    ni_minus_gap_name, log_vf);\n+  if (!is_gimple_val (ratio_name))\n+    {\n+      var = create_tmp_var (TREE_TYPE (ni), \"bnd\");\n+\n+      stmts = NULL;\n+      ratio_name = force_gimple_operand (ratio_name, &stmts, true, var);\n+      gimple_seq_add_seq (cond_expr_stmt_list, stmts);\n+    }\n+  *ratio_name_ptr = ratio_name;\n+\n+  /* Create: ratio_mult_vf = ratio << log2 (vf).  */\n+\n+  if (ratio_mult_vf_name_ptr)\n+    {\n+      ratio_mult_vf_name = fold_build2 (LSHIFT_EXPR, TREE_TYPE (ratio_name),\n+\t\t\t\t\tratio_name, log_vf);\n+      if (!is_gimple_val (ratio_mult_vf_name))\n+\t{\n+\t  var = create_tmp_var (TREE_TYPE (ni), \"ratio_mult_vf\");\n+\n+\t  stmts = NULL;\n+\t  ratio_mult_vf_name = force_gimple_operand (ratio_mult_vf_name, &stmts,\n+\t\t\t\t\t\t     true, var);\n+\t  gimple_seq_add_seq (cond_expr_stmt_list, stmts);\n+\t}\n+      *ratio_mult_vf_name_ptr = ratio_mult_vf_name;\n+    }\n+\n+  return;\n+}\n+\n+\n /* Function vect_transform_loop.\n \n    The analysis phase has determined that the loop is vectorizable.\n@@ -5636,11 +5740,18 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n     }\n \n   /* Peel the loop if there are data refs with unknown alignment.\n-     Only one data ref with unknown store is allowed.  */\n+     Only one data ref with unknown store is allowed.\n+     This clobbers LOOP_VINFO_NITERS but retains the original\n+     in LOOP_VINFO_NITERS_UNCHANGED.  So we cannot avoid re-computing\n+     niters.  */\n \n   if (LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo))\n     {\n-      vect_do_peeling_for_alignment (loop_vinfo, th, check_profitability);\n+      gimple_seq stmts = NULL;\n+      tree ni_name = vect_build_loop_niters (loop_vinfo, &stmts);\n+      gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);\n+      vect_do_peeling_for_alignment (loop_vinfo, ni_name,\n+\t\t\t\t     th, check_profitability);\n       check_profitability = false;\n     }\n \n@@ -5655,16 +5766,27 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   if ((int) tree_ctz (LOOP_VINFO_NITERS (loop_vinfo))\n       < exact_log2 (vectorization_factor)\n       || LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n-    vect_do_peeling_for_loop_bound (loop_vinfo, &ratio,\n-\t\t\t\t    th, check_profitability);\n+    {\n+      tree ni_name, ratio_mult_vf;\n+      gimple_seq stmts = NULL;\n+      ni_name = vect_build_loop_niters (loop_vinfo, &stmts);\n+      vect_generate_tmps_on_preheader (loop_vinfo, ni_name, &ratio_mult_vf,\n+\t\t\t\t       &ratio, &stmts);\n+      gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);\n+      vect_do_peeling_for_loop_bound (loop_vinfo, ni_name, ratio_mult_vf,\n+\t\t\t\t      th, check_profitability);\n+    }\n   else if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n     ratio = build_int_cst (TREE_TYPE (LOOP_VINFO_NITERS (loop_vinfo)),\n \t\tLOOP_VINFO_INT_NITERS (loop_vinfo) / vectorization_factor);\n   else\n     {\n-      tree ni_name, ratio_mult_vf;\n-      vect_generate_tmps_on_preheader (loop_vinfo, &ni_name, &ratio_mult_vf,\n-\t\t\t\t       &ratio, NULL);\n+      tree ni_name;\n+      gimple_seq stmts = NULL;\n+      ni_name = vect_build_loop_niters (loop_vinfo, &stmts);\n+      vect_generate_tmps_on_preheader (loop_vinfo, ni_name, NULL,\n+\t\t\t\t       &ratio, &stmts);\n+      gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);\n     }\n \n   /* 1) Make sure the loop header has exactly two entries"}, {"sha": "1297fab6cfeb9dde6fbba5f44d782925fb1d4738", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3c92486ed1f5cb336d0f78438ac3a0b03b38f53/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3c92486ed1f5cb336d0f78438ac3a0b03b38f53/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=f3c92486ed1f5cb336d0f78438ac3a0b03b38f53", "patch": "@@ -937,11 +937,10 @@ extern void slpeel_make_loop_iterate_ntimes (struct loop *, tree);\n extern bool slpeel_can_duplicate_loop_p (const struct loop *, const_edge);\n struct loop *slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *, edge);\n extern void vect_loop_versioning (loop_vec_info, unsigned int, bool);\n-extern void vect_generate_tmps_on_preheader (loop_vec_info, tree *, tree *,\n-\t\t\t\t\t     tree *, gimple_seq);\n-extern void vect_do_peeling_for_loop_bound (loop_vec_info, tree *,\n+extern void vect_do_peeling_for_loop_bound (loop_vec_info, tree, tree,\n \t\t\t\t\t    unsigned int, bool);\n-extern void vect_do_peeling_for_alignment (loop_vec_info, unsigned int, bool);\n+extern void vect_do_peeling_for_alignment (loop_vec_info, tree,\n+\t\t\t\t\t   unsigned int, bool);\n extern LOC find_loop_location (struct loop *);\n extern bool vect_can_advance_ivs_p (loop_vec_info);\n "}]}