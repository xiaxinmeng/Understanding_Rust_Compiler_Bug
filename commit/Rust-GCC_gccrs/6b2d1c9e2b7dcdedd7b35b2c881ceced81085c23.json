{"sha": "6b2d1c9e2b7dcdedd7b35b2c881ceced81085c23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmIyZDFjOWUyYjdkY2RlZGQ3YjM1YjJjODgxY2VjZWQ4MTA4NWMyMw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-03-31T05:25:52Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-03-31T05:25:52Z"}, "message": "gcse.c (gcse_constant_p): New function to identify constants suitable for constant propagation...\n\n\n\t* gcse.c (gcse_constant_p): New function to identify constants\n\tsuitable for constant propagation, including COMPARE with two\n\tinteger constant arguments.\n\t(hash_scan_set): Use gcse_constant_p.\n\t(find_avail_set): Likewise.\n\t(cprop_insn): Likewise.\n\t(do_local_cprop): Likewise.\n\t(find_implicit_sets): Likewise.\n\t(find_bypass_set): Likewise.\n\nFrom-SVN: r65075", "tree": {"sha": "39a4795ec64f8a39ea3be8d57c811dc14974664f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39a4795ec64f8a39ea3be8d57c811dc14974664f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b2d1c9e2b7dcdedd7b35b2c881ceced81085c23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b2d1c9e2b7dcdedd7b35b2c881ceced81085c23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b2d1c9e2b7dcdedd7b35b2c881ceced81085c23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b2d1c9e2b7dcdedd7b35b2c881ceced81085c23/comments", "author": null, "committer": null, "parents": [{"sha": "af8294418cf60ff684f7ea7f151360ca535c56af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af8294418cf60ff684f7ea7f151360ca535c56af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af8294418cf60ff684f7ea7f151360ca535c56af"}], "stats": {"total": 48, "additions": 39, "deletions": 9}, "files": [{"sha": "266e9c750ef032e67389f7a198456f5fb7c04e4c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b2d1c9e2b7dcdedd7b35b2c881ceced81085c23/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b2d1c9e2b7dcdedd7b35b2c881ceced81085c23/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6b2d1c9e2b7dcdedd7b35b2c881ceced81085c23", "patch": "@@ -1,3 +1,15 @@\n+2003-03-30  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcse.c (gcse_constant_p): New function to identify constants\n+\tsuitable for constant propagation, including COMPARE with two\n+\tinteger constant arguments.\n+\t(hash_scan_set): Use gcse_constant_p.\n+\t(find_avail_set): Likewise.\n+\t(cprop_insn): Likewise.\n+\t(do_local_cprop): Likewise.\n+\t(find_implicit_sets): Likewise.\n+\t(find_bypass_set): Likewise.\n+\n 2003-03-30  Matt Kraai  <kraai@alumni.cmu.edu>\n \n \t* except.h: Remove definition of varray_type."}, {"sha": "d41a11757bd681713e40d053c39e9918eac57e80", "filename": "gcc/gcse.c", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b2d1c9e2b7dcdedd7b35b2c881ceced81085c23/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b2d1c9e2b7dcdedd7b35b2c881ceced81085c23/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=6b2d1c9e2b7dcdedd7b35b2c881ceced81085c23", "patch": "@@ -572,6 +572,7 @@ static void hash_scan_set\tPARAMS ((rtx, rtx, struct hash_table *));\n static void hash_scan_clobber\tPARAMS ((rtx, rtx, struct hash_table *));\n static void hash_scan_call\tPARAMS ((rtx, rtx, struct hash_table *));\n static int want_to_gcse_p\tPARAMS ((rtx));\n+static bool gcse_constant_p\tPARAMS ((rtx));\n static int oprs_unchanged_p\tPARAMS ((rtx, rtx, int));\n static int oprs_anticipatable_p PARAMS ((rtx, rtx));\n static int oprs_available_p\tPARAMS ((rtx, rtx));\n@@ -2155,6 +2156,25 @@ insert_set_in_table (x, insn, table)\n     }\n }\n \n+/* Determine whether the rtx X should be treated as a constant for\n+   the purposes of GCSE's constant propagation.  */\n+\n+static bool\n+gcse_constant_p (x)\n+     rtx x;\n+{\n+  /* Consider a COMPARE of two integers constant.  */\n+  if (GET_CODE (x) == COMPARE\n+      && GET_CODE (XEXP (x, 0)) == CONST_INT\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+    return true;\n+\n+  if (GET_CODE (x) == CONSTANT_P_RTX)\n+    return false;\n+\n+  return CONSTANT_P (x);\n+}\n+\n /* Scan pattern PAT of INSN and add an entry to the hash TABLE (set or\n    expression one).  */\n \n@@ -2178,7 +2198,7 @@ hash_scan_set (pat, insn, table)\n       /* If this is a single set and we are doing constant propagation,\n \t see if a REG_NOTE shows this equivalent to a constant.  */\n       if (table->set_p && (note = find_reg_equal_equiv_note (insn)) != 0\n-\t  && CONSTANT_P (XEXP (note, 0)))\n+\t  && gcse_constant_p (XEXP (note, 0)))\n \tsrc = XEXP (note, 0), pat = gen_rtx_SET (VOIDmode, dest, src);\n \n       /* Only record sets of pseudo-regs in the hash table.  */\n@@ -2223,8 +2243,7 @@ hash_scan_set (pat, insn, table)\n \t\t    && REGNO (src) >= FIRST_PSEUDO_REGISTER\n \t\t    && can_copy_p [GET_MODE (dest)]\n \t\t    && REGNO (src) != regno)\n-\t\t   || (CONSTANT_P (src)\n-\t\t       && GET_CODE (src) != CONSTANT_P_RTX))\n+\t\t   || gcse_constant_p (src))\n \t       /* A copy is not available if its src or dest is subsequently\n \t\t  modified.  Here we want to search from INSN+1 on, but\n \t\t  oprs_available_p searches from INSN on.  */\n@@ -4015,7 +4034,7 @@ find_avail_set (regno, insn)\n          If the source operand changed, we may still use it for the next\n          iteration of this loop, but we may not use it for substitutions.  */\n \n-      if (CONSTANT_P (src) || oprs_not_set_p (src, insn))\n+      if (gcse_constant_p (src) || oprs_not_set_p (src, insn))\n \tset1 = set;\n \n       /* If the source of the set is anything except a register, then\n@@ -4207,7 +4226,7 @@ cprop_insn (insn, alter_jumps)\n       src = SET_SRC (pat);\n \n       /* Constant propagation.  */\n-      if (CONSTANT_P (src))\n+      if (gcse_constant_p (src))\n \t{\n           if (constprop_register (insn, reg_used->reg_rtx, src, alter_jumps))\n \t    {\n@@ -4328,8 +4347,7 @@ do_local_cprop (x, insn, alter_jumps, libcall_sp)\n \t  if (l->in_libcall)\n \t    continue;\n \n-\t  if (CONSTANT_P (this_rtx)\n-\t      && GET_CODE (this_rtx) != CONSTANT_P_RTX)\n+\t  if (gcse_constant_p (this_rtx))\n \t    newcnst = this_rtx;\n \t  if (REG_P (this_rtx) && REGNO (this_rtx) >= FIRST_PSEUDO_REGISTER\n \t      /* Don't copy propagate if it has attached REG_EQUIV note.\n@@ -4611,7 +4629,7 @@ find_implicit_sets ()\n \t    && (GET_CODE (cond) == EQ || GET_CODE (cond) == NE)\n \t    && GET_CODE (XEXP (cond, 0)) == REG\n \t    && REGNO (XEXP (cond, 0)) >= FIRST_PSEUDO_REGISTER\n-\t    && CONSTANT_P (XEXP (cond, 1)))\n+\t    && gcse_constant_p (XEXP (cond, 1)))\n \t  {\n \t    dest = GET_CODE (cond) == EQ ? BRANCH_EDGE (bb)->dest\n \t\t\t\t\t : FALLTHRU_EDGE (bb)->dest;\n@@ -4733,7 +4751,7 @@ find_bypass_set (regno, bb)\n \tabort ();\n \n       src = SET_SRC (set->expr);\n-      if (CONSTANT_P (src))\n+      if (gcse_constant_p (src))\n \tresult = set;\n \n       if (GET_CODE (src) != REG)"}]}