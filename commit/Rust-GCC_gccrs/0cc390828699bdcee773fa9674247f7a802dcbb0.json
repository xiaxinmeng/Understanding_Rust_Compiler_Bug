{"sha": "0cc390828699bdcee773fa9674247f7a802dcbb0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGNjMzkwODI4Njk5YmRjZWU3NzNmYTk2NzQyNDdmN2E4MDJkY2JiMA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-05-04T06:10:21Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-05-04T06:10:21Z"}, "message": "loop-unroll.c (var_to_expand, [...]): Use VEC instead of VARRAY.\n\n\t* loop-unroll.c (var_to_expand, analyze_insn_to_expand_var,\n\tget_expansion, expand_var_during_unrolling,\n\tinsert_var_expansion_initialization,\n\tcombine_var_copies_in_loop_exit, release_var_copies): Use VEC\n\tinstead of VARRAY.\n\nFrom-SVN: r99211", "tree": {"sha": "d87e8dd8437e936f6c0529481bc1149b140c93e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d87e8dd8437e936f6c0529481bc1149b140c93e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0cc390828699bdcee773fa9674247f7a802dcbb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cc390828699bdcee773fa9674247f7a802dcbb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cc390828699bdcee773fa9674247f7a802dcbb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cc390828699bdcee773fa9674247f7a802dcbb0/comments", "author": null, "committer": null, "parents": [{"sha": "887fb69bbc1c7d283aeec2a4e430e02065b6d33b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/887fb69bbc1c7d283aeec2a4e430e02065b6d33b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/887fb69bbc1c7d283aeec2a4e430e02065b6d33b"}], "stats": {"total": 37, "additions": 21, "deletions": 16}, "files": [{"sha": "c9c119849c63124f22d952e215a43fd847256617", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cc390828699bdcee773fa9674247f7a802dcbb0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cc390828699bdcee773fa9674247f7a802dcbb0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0cc390828699bdcee773fa9674247f7a802dcbb0", "patch": "@@ -4,6 +4,12 @@\n \tgen_struct_or_union_type_die, dwarf2out_init): Use VEC instead\n \tof VARRAY.\n \n+\t* loop-unroll.c (var_to_expand, analyze_insn_to_expand_var,\n+\tget_expansion, expand_var_during_unrolling,\n+\tinsert_var_expansion_initialization,\n+\tcombine_var_copies_in_loop_exit, release_var_copies): Use VEC\n+\tinstead of VARRAY.\n+\n 2004-05-03  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR middle-end/15618"}, {"sha": "409df0caa6e712f25efd7427f5b4fc3888840a90", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0cc390828699bdcee773fa9674247f7a802dcbb0/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0cc390828699bdcee773fa9674247f7a802dcbb0/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=0cc390828699bdcee773fa9674247f7a802dcbb0", "patch": "@@ -85,13 +85,16 @@ struct iv_to_split\n \t\t\t   XEXP (XEXP (single_set, loc[0]), loc[1]).  */ \n };\n \n+DEF_VEC_P(rtx);\n+DEF_VEC_ALLOC_P(rtx,heap);\n+\n /* Information about accumulators to expand.  */\n \n struct var_to_expand\n {\n   rtx insn;\t\t           /* The insn in that the variable expansion occurs.  */\n   rtx reg;                         /* The accumulator which is expanded.  */\n-  varray_type var_expansions;      /* The copies of the accumulator which is expanded.  */ \n+  VEC(rtx,heap) *var_expansions;   /* The copies of the accumulator which is expanded.  */ \n   enum rtx_code op;                /* The type of the accumulation - addition, subtraction \n                                       or multiplication.  */\n   int expansion_count;             /* Count the number of expansions generated so far.  */\n@@ -1578,7 +1581,7 @@ analyze_insn_to_expand_var (struct loop *loop, rtx insn)\n   /* Record the accumulator to expand.  */\n   ves = xmalloc (sizeof (struct var_to_expand));\n   ves->insn = insn;\n-  VARRAY_RTX_INIT (ves->var_expansions, 1, \"var_expansions\");\n+  ves->var_expansions = VEC_alloc (rtx, heap, 1);\n   ves->reg = copy_rtx (dest);\n   ves->op = GET_CODE (src);\n   ves->expansion_count = 0;\n@@ -1889,9 +1892,9 @@ get_expansion (struct var_to_expand *ve)\n   if (ve->reuse_expansion == 0)\n     reg = ve->reg;\n   else\n-    reg = VARRAY_RTX (ve->var_expansions,  ve->reuse_expansion - 1);\n+    reg = VEC_index (rtx, ve->var_expansions, ve->reuse_expansion - 1);\n   \n-  if (VARRAY_ACTIVE_SIZE (ve->var_expansions) == (unsigned) ve->reuse_expansion)\n+  if (VEC_length (rtx, ve->var_expansions) == (unsigned) ve->reuse_expansion)\n     ve->reuse_expansion = 0;\n   else \n     ve->reuse_expansion++;\n@@ -1928,7 +1931,7 @@ expand_var_during_unrolling (struct var_to_expand *ve, rtx insn)\n   if (apply_change_group ())\n     if (really_new_expansion)\n       {\n-        VARRAY_PUSH_RTX (ve->var_expansions, new_reg);\n+        VEC_safe_push (rtx, heap, ve->var_expansions, new_reg);\n         ve->expansion_count++;\n       }\n }\n@@ -1946,21 +1949,19 @@ insert_var_expansion_initialization (void **slot, void *place_p)\n   rtx seq, var, zero_init, insn;\n   unsigned i;\n   \n-  if (VARRAY_ACTIVE_SIZE (ve->var_expansions) == 0)\n+  if (VEC_length (rtx, ve->var_expansions) == 0)\n     return 1;\n   \n   start_sequence ();\n   if (ve->op == PLUS || ve->op == MINUS) \n-    for (i = 0; i < VARRAY_ACTIVE_SIZE (ve->var_expansions); i++)\n+    for (i = 0; VEC_iterate (rtx, ve->var_expansions, i, var); i++)\n       {\n-        var = VARRAY_RTX (ve->var_expansions, i);\n         zero_init =  CONST0_RTX (GET_MODE (var));\n         emit_move_insn (var, zero_init);\n       }\n   else if (ve->op == MULT)\n-    for (i = 0; i < VARRAY_ACTIVE_SIZE (ve->var_expansions); i++)\n+    for (i = 0; VEC_iterate (rtx, ve->var_expansions, i, var); i++)\n       {\n-        var = VARRAY_RTX (ve->var_expansions, i);\n         zero_init =  CONST1_RTX (GET_MODE (var));\n         emit_move_insn (var, zero_init);\n       }\n@@ -1991,21 +1992,19 @@ combine_var_copies_in_loop_exit (void **slot, void *place_p)\n   rtx expr, seq, var, insn;\n   unsigned i;\n \n-  if (VARRAY_ACTIVE_SIZE (ve->var_expansions) == 0)\n+  if (VEC_length (rtx, ve->var_expansions) == 0)\n     return 1;\n   \n   start_sequence ();\n   if (ve->op == PLUS || ve->op == MINUS)\n-    for (i = 0; i < VARRAY_ACTIVE_SIZE (ve->var_expansions); i++)\n+    for (i = 0; VEC_iterate (rtx, ve->var_expansions, i, var); i++)\n       {\n-        var = VARRAY_RTX (ve->var_expansions, i);\n         sum = simplify_gen_binary (PLUS, GET_MODE (ve->reg),\n                                    var, sum);\n       }\n   else if (ve->op == MULT)\n-    for (i = 0; i < VARRAY_ACTIVE_SIZE (ve->var_expansions); i++)\n+    for (i = 0; VEC_iterate (rtx, ve->var_expansions, i, var); i++)\n       {\n-        var = VARRAY_RTX (ve->var_expansions, i);\n         sum = simplify_gen_binary (MULT, GET_MODE (ve->reg),\n                                    var, sum);\n       }\n@@ -2166,7 +2165,7 @@ release_var_copies (void **slot, void *data ATTRIBUTE_UNUSED)\n {\n   struct var_to_expand *ve = *slot;\n   \n-  VARRAY_CLEAR (ve->var_expansions);\n+  VEC_free (rtx, heap, ve->var_expansions);\n   \n   /* Continue traversing the hash table.  */\n   return 1;"}]}