{"sha": "8dc5fa3267a492582a1ee58dda67bd1fa9b7df27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRjNWZhMzI2N2E0OTI1ODJhMWVlNThkZGE2N2JkMWZhOWI3ZGYyNw==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2004-11-01T11:31:44Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-11-01T11:31:44Z"}, "message": "locale_facets.tcc (num_get<>::_M_extract_float): Evaluate *__beg the exact strict minimum number of times...\n\n2004-11-01  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/locale_facets.tcc (num_get<>::_M_extract_float):\n\tEvaluate *__beg the exact strict minimum number of times; likewise\n\tfor __beg != __end; in the main parsing loop, call ++__beg in two\n\tplaces only. The former is also a correctness issue, because,\n\taccording to the standard (22.2.2.1.2, Stage 2), 'in' shall be\n\tdereferenced only one time for each increment.\n\nFrom-SVN: r89940", "tree": {"sha": "f8e2e7a14464efa41bc96181f14aa487250b853c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8e2e7a14464efa41bc96181f14aa487250b853c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8dc5fa3267a492582a1ee58dda67bd1fa9b7df27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dc5fa3267a492582a1ee58dda67bd1fa9b7df27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dc5fa3267a492582a1ee58dda67bd1fa9b7df27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dc5fa3267a492582a1ee58dda67bd1fa9b7df27/comments", "author": null, "committer": null, "parents": [{"sha": "c4f731746a858af919e7fb3b70b5b40c92ef0964", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4f731746a858af919e7fb3b70b5b40c92ef0964", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4f731746a858af919e7fb3b70b5b40c92ef0964"}], "stats": {"total": 112, "additions": 66, "deletions": 46}, "files": [{"sha": "ec19144b9650a5020f8c0f5463a98cf559533bd9", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc5fa3267a492582a1ee58dda67bd1fa9b7df27/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc5fa3267a492582a1ee58dda67bd1fa9b7df27/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=8dc5fa3267a492582a1ee58dda67bd1fa9b7df27", "patch": "@@ -1,3 +1,12 @@\n+2004-11-01  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/locale_facets.tcc (num_get<>::_M_extract_float):\n+\tEvaluate *__beg the exact strict minimum number of times; likewise\n+\tfor __beg != __end; in the main parsing loop, call ++__beg in two\n+\tplaces only. The former is also a correctness issue, because,\n+\taccording to the standard (22.2.2.1.2, Stage 2), 'in' shall be\n+\tdereferenced only one time for each increment.\n+\n 2004-10-31  Benjamin Kosnik  <bkoz@redhat.com>\n \n \tPR c++/16728"}, {"sha": "0f92db205a116a34a9f8f1c8f5d9f04ab4aebf88", "filename": "libstdc++-v3/include/bits/locale_facets.tcc", "status": "modified", "additions": 57, "deletions": 46, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc5fa3267a492582a1ee58dda67bd1fa9b7df27/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc5fa3267a492582a1ee58dda67bd1fa9b7df27/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc?ref=8dc5fa3267a492582a1ee58dda67bd1fa9b7df27", "patch": "@@ -279,28 +279,34 @@ namespace std\n       const locale& __loc = __io._M_getloc();\n       const __cache_type* __lc = __uc(__loc);\n       const _CharT* __lit = __lc->_M_atoms_in;\n+      char_type __c = char_type();\n \n-      // True if a mantissa is found.\n-      bool __found_mantissa = false;\n+      // True if __beg becomes equal to __end.\n+      bool __testeof = __beg == __end;\n \n       // First check for sign.\n-      if (__beg != __end)\n+      if (!__testeof)\n \t{\n-\t  const char_type __c = *__beg;\n+\t  __c = *__beg;\n \t  const bool __plus = __c == __lit[__num_base::_S_iplus];\n \t  if ((__plus || __c == __lit[__num_base::_S_iminus])\n \t      && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)\n \t      && !(__c == __lc->_M_decimal_point))\n \t    {\n \t      __xtrc += __plus ? '+' : '-';\n-\t      ++__beg;\n+\t      if (++__beg != __end)\n+\t\t__c = *__beg;\n+\t      else\n+\t\t__testeof = true;\n \t    }\n \t}\n \n+      // True if a mantissa is found.\n+      bool __found_mantissa = false;\n+\n       // Next, look for leading zeros.\n-      while (__beg != __end)\n+      while (!__testeof)\n \t{\n-\t  const char_type __c = *__beg;\n \t  if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep\n \t      || __c == __lc->_M_decimal_point)\n \t    break;\n@@ -311,7 +317,10 @@ namespace std\n \t\t  __xtrc += '0';\n \t\t  __found_mantissa = true;\n \t\t}\n-\t      ++__beg;\n+\t      if (++__beg != __end)\n+\t\t__c = *__beg;\n+\t      else\n+\t\t__testeof = true;\n \t    }\n \t  else\n \t    break;\n@@ -324,12 +333,12 @@ namespace std\n       if (__lc->_M_use_grouping)\n \t__found_grouping.reserve(32);\n       int __sep_pos = 0;\n+      const char_type* __q;\n       const char_type* __lit_zero = __lit + __num_base::_S_izero;\n-      while (__beg != __end)\n+      while (!__testeof)\n         {\n \t  // According to 22.2.2.1.2, p8-9, first look for thousands_sep\n \t  // and decimal_point.\n-\t  char_type __c = *__beg;\n           if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)\n \t    {\n \t      if (!__found_dec && !__found_sci)\n@@ -340,7 +349,6 @@ namespace std\n \t\t    {\n \t\t      __found_grouping += static_cast<char>(__sep_pos);\n \t\t      __sep_pos = 0;\n-\t\t      ++__beg;\n \t\t    }\n \t\t  else\n \t\t    {\n@@ -362,50 +370,53 @@ namespace std\n \t\t    __found_grouping += static_cast<char>(__sep_pos);\n \t\t  __xtrc += '.';\n \t\t  __found_dec = true;\n-\t\t  ++__beg;\n \t\t}\n \t      else\n \t\tbreak;\n \t    }\n-          else\n+          else if ((__q = __traits_type::find(__lit_zero, 10, __c)))\n \t    {\n-\t      const char_type* __q = __traits_type::find(__lit_zero, 10, __c);\n-\t      if (__q)\n+\t      __xtrc += __num_base::_S_atoms_in[__q - __lit];\n+\t      __found_mantissa = true;\n+\t      ++__sep_pos;\n+\t    }\n+\t  else if ((__c == __lit[__num_base::_S_ie] \n+\t\t    || __c == __lit[__num_base::_S_iE])\n+\t\t   && __found_mantissa && !__found_sci)\n+\t    {\n+\t      // Scientific notation.\n+\t      if (__found_grouping.size() && !__found_dec)\n+\t\t__found_grouping += static_cast<char>(__sep_pos);\n+\t      __xtrc += 'e';\n+\t      __found_sci = true;\n+\n+\t      // Remove optional plus or minus sign, if they exist.\n+\t      if (++__beg != __end)\n \t\t{\n-\t\t  __xtrc += __num_base::_S_atoms_in[__q - __lit];\n-\t\t  __found_mantissa = true;\n-\t\t  ++__sep_pos;\n-\t\t  ++__beg;\n+\t\t  __c = *__beg;\n+\t\t  const bool __plus = __c == __lit[__num_base::_S_iplus];\n+\t\t  if ((__plus || __c == __lit[__num_base::_S_iminus])\n+\t\t      && !(__lc->_M_use_grouping\n+\t\t\t   && __c == __lc->_M_thousands_sep)\n+\t\t      && !(__c == __lc->_M_decimal_point))\n+\t\t    __xtrc += __plus ? '+' : '-';\n+\t\t  else\n+\t\t    continue;\n \t\t}\n-\t      else if ((__c == __lit[__num_base::_S_ie] \n-\t\t\t|| __c == __lit[__num_base::_S_iE])\n-\t\t       && __found_mantissa && !__found_sci)\n+\t      else\n \t\t{\n-\t\t  // Scientific notation.\n-\t\t  if (__found_grouping.size() && !__found_dec)\n-\t\t    __found_grouping += static_cast<char>(__sep_pos);\n-\t\t  __xtrc += 'e';\n-\t\t  __found_sci = true;\n-\n-\t\t  // Remove optional plus or minus sign, if they exist.\n-\t\t  if (++__beg != __end)\n-\t\t    {\n-\t\t      __c = *__beg;\n-\t\t      const bool __plus = __c == __lit[__num_base::_S_iplus];\n-\t\t      if ((__plus || __c == __lit[__num_base::_S_iminus])\n-\t\t\t  && !(__lc->_M_use_grouping\n-\t\t\t       && __c == __lc->_M_thousands_sep)\n-\t\t\t  && !(__c == __lc->_M_decimal_point))\n-\t\t\t{\n-\t\t\t  __xtrc += __plus ? '+' : '-';\n-\t\t\t  ++__beg;\n-\t\t\t}\n-\t\t    }\n+\t\t  __testeof = true;\n+\t\t  break;\n \t\t}\n-\t      else\n-\t\t// Not a valid input item.\n-\t\tbreak;\n \t    }\n+\t  else\n+\t    // Not a valid input item.\n+\t    break;\n+\n+\t  if (++__beg != __end)\n+\t    __c = *__beg;\n+\t  else\n+\t    __testeof = true;\n         }\n \n       // Digit grouping is checked. If grouping and found_grouping don't\n@@ -423,7 +434,7 @@ namespace std\n         }\n \n       // Finish up.\n-      if (__beg == __end)\n+      if (__testeof)\n         __err |= ios_base::eofbit;\n       return __beg;\n     }"}]}