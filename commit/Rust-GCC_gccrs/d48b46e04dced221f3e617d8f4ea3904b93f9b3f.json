{"sha": "d48b46e04dced221f3e617d8f4ea3904b93f9b3f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQ4YjQ2ZTA0ZGNlZDIyMWYzZTYxN2Q4ZjRlYTM5MDRiOTNmOWIzZg==", "commit": {"author": {"name": "Revital Eres", "email": "revitale@gcc.gnu.org", "date": "2007-12-02T11:01:26Z"}, "committer": {"name": "Revital Eres", "email": "revitale@gcc.gnu.org", "date": "2007-12-02T11:01:26Z"}, "message": "Fix the direction of the scheduling window & Fix scheduling order within a row\n\nFrom-SVN: r130567", "tree": {"sha": "cd18fc47790c90d45aa7920acc3f517e2b703979", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd18fc47790c90d45aa7920acc3f517e2b703979"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d48b46e04dced221f3e617d8f4ea3904b93f9b3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d48b46e04dced221f3e617d8f4ea3904b93f9b3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d48b46e04dced221f3e617d8f4ea3904b93f9b3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d48b46e04dced221f3e617d8f4ea3904b93f9b3f/comments", "author": null, "committer": null, "parents": [{"sha": "083f0d3a045f1b42496ca57beb79d001b09f5354", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/083f0d3a045f1b42496ca57beb79d001b09f5354", "html_url": "https://github.com/Rust-GCC/gccrs/commit/083f0d3a045f1b42496ca57beb79d001b09f5354"}], "stats": {"total": 321, "additions": 270, "deletions": 51}, "files": [{"sha": "778160cc93c74fa6fae01b4672b5ea50f127a7da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d48b46e04dced221f3e617d8f4ea3904b93f9b3f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d48b46e04dced221f3e617d8f4ea3904b93f9b3f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d48b46e04dced221f3e617d8f4ea3904b93f9b3f", "patch": "@@ -1,3 +1,19 @@\n+2007-12-02  Ayal Zaks  <zaks@il.ibm.com>\n+\t    Revital Eres  <eres@il.ibm.com>\n+\n+\t* modulo-sched.c (calculate_must_precede_follow,\n+\ttry_scheduling_node_in_cycle): New functions.\n+\t(sms_schedule_by_order): Call the new functions.\n+\t(ps_insn_find_column): Use must_follow and must_precede only if\n+\tthey are not NULL.\n+\t(ps_insn_advance_column): Likewise.\n+\n+2007-12-02  Ayal Zaks  <zaks@il.ibm.com>\n+\t    Revital Eres  <eres@il.ibm.com>\n+\n+\t* modulo-sched.c (get_sched_window): Fix the direction of the\n+\tscheduling window and add dump info.\n+\n 2007-12-02  Samuel Tardieu  <sam@rfc1149.net>\n \n \t* config/sh/sh.md (cmpgeusi_t): Fix condition."}, {"sha": "c052ddeaa47f29c5ba6735f9d207c51e9795bd88", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 171, "deletions": 51, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d48b46e04dced221f3e617d8f4ea3904b93f9b3f/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d48b46e04dced221f3e617d8f4ea3904b93f9b3f/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=d48b46e04dced221f3e617d8f4ea3904b93f9b3f", "patch": "@@ -1343,8 +1343,9 @@ get_sched_window (partial_schedule_ptr ps, int *nodes_order, int i,\n                 MAX (early_start, p_st + e->latency - (e->distance * ii));\n \n               if (dump_file)\n-                fprintf (dump_file, \"pred st = %d; early_start = %d; \", p_st,\n-                         early_start);\n+                fprintf (dump_file, \n+                         \"pred st = %d; early_start = %d; latency: %d\",\n+                         p_st, early_start, e->latency);\n \n \t      if (e->data_type == MEM_DEP)\n \t\tend = MIN (end, SCHED_TIME (v_node) + ii - 1);\n@@ -1354,6 +1355,7 @@ get_sched_window (partial_schedule_ptr ps, int *nodes_order, int i,\n \t}\n       start = early_start;\n       end = MIN (end, early_start + ii);\n+      /* Schedule the node close to it's predecessors.  */\n       step = 1;\n \n       if (dump_file)\n@@ -1390,8 +1392,9 @@ get_sched_window (partial_schedule_ptr ps, int *nodes_order, int i,\n                                 s_st - e->latency + (e->distance * ii));\n \n               if (dump_file)\n-                fprintf (dump_file, \"succ st = %d; late_start = %d;\", s_st,\n-                         late_start);\n+                fprintf (dump_file, \n+                         \"succ st = %d; late_start = %d; latency = %d\",\n+                         s_st, late_start, e->latency);\n \n \t      if (e->data_type == MEM_DEP)\n \t\tend = MAX (end, SCHED_TIME (v_node) - ii + 1);\n@@ -1405,6 +1408,7 @@ get_sched_window (partial_schedule_ptr ps, int *nodes_order, int i,\n \t}\n       start = late_start;\n       end = MAX (end, late_start - ii);\n+      /* Schedule the node close to it's successors.  */\n       step = -1;\n \n       if (dump_file)\n@@ -1418,6 +1422,8 @@ get_sched_window (partial_schedule_ptr ps, int *nodes_order, int i,\n     {\n       int early_start = INT_MIN;\n       int late_start = INT_MAX;\n+      int count_preds = 0;\n+      int count_succs = 0;\n \n       start = INT_MIN;\n       end = INT_MAX;\n@@ -1445,8 +1451,12 @@ get_sched_window (partial_schedule_ptr ps, int *nodes_order, int i,\n \t\t\t\t - (e->distance * ii));\n \n               if (dump_file)\n-                fprintf (dump_file, \"pred st = %d; early_start = %d;\", p_st,\n-                         early_start);\n+                fprintf (dump_file, \n+                         \"pred st = %d; early_start = %d; latency = %d\",\n+                         p_st, early_start, e->latency);\n+\n+              if (e->type == TRUE_DEP && e->data_type == REG_DEP)\n+                count_preds++;\n \n \t      if (e->data_type == MEM_DEP)\n \t\tend = MIN (end, SCHED_TIME (v_node) + ii - 1);\n@@ -1478,9 +1488,13 @@ get_sched_window (partial_schedule_ptr ps, int *nodes_order, int i,\n \t\t\t\ts_st - e->latency\n \t\t\t\t+ (e->distance * ii));\n \n-               if (dump_file)\n-                 fprintf (dump_file, \"succ st = %d; late_start = %d;\", s_st,\n-                          late_start);\n+              if (dump_file)\n+                fprintf (dump_file, \n+                         \"succ st = %d; late_start = %d; latency = %d\",\n+                         s_st, late_start, e->latency);\n+\n+               if (e->type == TRUE_DEP && e->data_type == REG_DEP)\n+                 count_succs++;\n \n \t      if (e->data_type == MEM_DEP)\n \t\tstart = MAX (start, SCHED_TIME (v_node) - ii + 1);\n@@ -1492,6 +1506,16 @@ get_sched_window (partial_schedule_ptr ps, int *nodes_order, int i,\n       start = MAX (start, early_start);\n       end = MIN (end, MIN (early_start + ii, late_start + 1));\n       step = 1;\n+      /* If there are more successors than predecessors schedule the\n+         node close to it's successors.  */\n+      if (count_succs >= count_preds)\n+        {\n+          int old_start = start;\n+\n+          start = end - 1;\n+          end = old_start - 1;\n+          step = -1;\n+        }\n     }\n   else /* psp is empty && pss is empty.  */\n     {\n@@ -1517,6 +1541,114 @@ get_sched_window (partial_schedule_ptr ps, int *nodes_order, int i,\n     return 0;\n }\n \n+/* Calculate MUST_PRECEDE/MUST_FOLLOW bitmaps of U_NODE; which is the\n+   node currently been scheduled.  At the end of the calculation\n+   MUST_PRECEDE/MUST_FOLLOW contains all predecessors/successors of U_NODE\n+   which are in SCHED_NODES (already scheduled nodes) and scheduled at\n+   the same row as the first/last row of U_NODE's scheduling window.\n+   The first and last rows are calculated using the following paramaters:\n+   START/END rows - The cycles that begins/ends the traversal on the window;\n+   searching for an empty cycle to schedule U_NODE.\n+   STEP - The direction in which we traverse the window.\n+   II - The initiation interval.\n+   TODO: We can add an insn to the must_precede/must_follow bitmap only\n+   if it has tight dependence to U and they are both scheduled in the\n+   same row.  The current check is more conservative and content with\n+   the fact that both U and the insn are scheduled in the same row.  */\n+\n+static void\n+calculate_must_precede_follow (ddg_node_ptr u_node, int start, int end,\n+\t\t\t       int step, int ii, sbitmap sched_nodes,\n+\t\t\t       sbitmap must_precede, sbitmap must_follow)\n+{\n+  ddg_edge_ptr e;\n+  int first_cycle_in_window, last_cycle_in_window;\n+  int first_row_in_window, last_row_in_window;\n+\n+  gcc_assert (must_precede && must_follow);\n+\n+  /* Consider the following scheduling window:\n+     {first_cycle_in_window, first_cycle_in_window+1, ...,\n+     last_cycle_in_window}.  If step is 1 then the following will be\n+     the order we traverse the window: {start=first_cycle_in_window,\n+     first_cycle_in_window+1, ..., end=last_cycle_in_window+1},\n+     or {start=last_cycle_in_window, last_cycle_in_window-1, ...,\n+     end=first_cycle_in_window-1} if step is -1.  */\n+  first_cycle_in_window = (step == 1) ? start : end - step;\n+  last_cycle_in_window = (step == 1) ? end - step : start;\n+\n+  first_row_in_window = SMODULO (first_cycle_in_window, ii);\n+  last_row_in_window = SMODULO (last_cycle_in_window, ii);\n+\n+  sbitmap_zero (must_precede);\n+  sbitmap_zero (must_follow);\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nmust_precede: \");\n+\n+  for (e = u_node->in; e != 0; e = e->next_in)\n+    if (TEST_BIT (sched_nodes, e->src->cuid)\n+\t&& (SMODULO (SCHED_TIME (e->src), ii) == first_row_in_window))\n+      {\n+\tif (dump_file)\n+\t  fprintf (dump_file, \"%d \", e->src->cuid);\n+\n+\tSET_BIT (must_precede, e->src->cuid);\n+      }\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nmust_follow: \");\n+\n+  for (e = u_node->out; e != 0; e = e->next_out)\n+    if (TEST_BIT (sched_nodes, e->dest->cuid)\n+\t&& (SMODULO (SCHED_TIME (e->dest), ii) == last_row_in_window))\n+      {\n+\tif (dump_file)\n+\t  fprintf (dump_file, \"%d \", e->dest->cuid);\n+\n+\tSET_BIT (must_follow, e->dest->cuid);\n+      }\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n\");\n+}\n+\n+/* Return 1 if U_NODE can be scheduled in CYCLE.  Use the following\n+   parameters to decide if that's possible:\n+   PS - The partial schedule.\n+   U - The serial number of U_NODE.\n+   NUM_SPLITS - The number of row spilts made so far.\n+   MUST_PRECEDE - The nodes that must precede U_NODE. (only valid at\n+   the first row of the scheduling window)\n+   MUST_FOLLOW - The nodes that must follow U_NODE. (only valid at the\n+   last row of the scheduling window)  */\n+\n+static bool\n+try_scheduling_node_in_cycle (partial_schedule_ptr ps, ddg_node_ptr u_node,\n+\t\t\t      int u, int row, sbitmap sched_nodes,\n+\t\t\t      int *num_splits, sbitmap must_precede,\n+\t\t\t      sbitmap must_follow)\n+{\n+  ps_insn_ptr psi;\n+  bool success = 0;\n+\n+  verify_partial_schedule (ps, sched_nodes);\n+  psi = ps_add_node_check_conflicts (ps, u_node, row,\n+\t\t\t\t     must_precede, must_follow);\n+  if (psi)\n+    {\n+      SCHED_TIME (u_node) = row;\n+      SET_BIT (sched_nodes, u);\n+      success = 1;\n+      *num_splits = 0;\n+      if (dump_file)\n+\tfprintf (dump_file, \"Scheduled w/o split in %d\\n\", row);\n+\n+    }\n+\n+  return success;\n+}\n+\n /* This function implements the scheduling algorithm for SMS according to the\n    above algorithm.  */\n static partial_schedule_ptr\n@@ -1526,8 +1658,6 @@ sms_schedule_by_order (ddg_ptr g, int mii, int maxii, int *nodes_order)\n   int i, c, success, num_splits = 0;\n   int flush_and_start_over = true;\n   int num_nodes = g->num_nodes;\n-  ddg_edge_ptr e;\n-  ps_insn_ptr psi;\n   int start, end, step; /* Place together into one struct?  */\n   sbitmap sched_nodes = sbitmap_alloc (num_nodes);\n   sbitmap must_precede = sbitmap_alloc (num_nodes);\n@@ -1577,53 +1707,43 @@ sms_schedule_by_order (ddg_ptr g, int mii, int maxii, int *nodes_order)\n                 fprintf (dump_file, \"\\nTrying to schedule node %d \\\n                         INSN = %d  in (%d .. %d) step %d\\n\", u, (INSN_UID\n                         (g->nodes[u].insn)), start, end, step);\n-              /* Use must_follow & must_precede bitmaps to determine order\n-                 of nodes within the cycle.  */\n-\n-              /* use must_follow & must_precede bitmaps to determine order\n-                 of nodes within the cycle.  */\n-              sbitmap_zero (must_precede);\n-              sbitmap_zero (must_follow);\n-              /* TODO: We can add an insn to the must_precede or must_follow\n-                 bitmaps only if it has tight dependence to U and they\n-                 both scheduled in the same row.  The current check is less\n-                 conservative and content with the fact that both U and the\n-                 insn are scheduled in the same row.  */\n-              for (e = u_node->in; e != 0; e = e->next_in)\n-                if (TEST_BIT (sched_nodes, e->src->cuid)\n-                    && (SMODULO (SCHED_TIME (e->src), ii) ==\n-                        SMODULO (start, ii)))\n-                  SET_BIT (must_precede, e->src->cuid);\n-\n-              for (e = u_node->out; e != 0; e = e->next_out)\n-                if (TEST_BIT (sched_nodes, e->dest->cuid)\n-                    && (SMODULO (SCHED_TIME (e->dest), ii) ==\n-                        SMODULO ((end - step), ii)))\n-                  SET_BIT (must_follow, e->dest->cuid);\n \n               gcc_assert ((step > 0 && start < end)\n                           || (step < 0 && start > end));\n \n+              calculate_must_precede_follow (u_node, start, end, step, ii,\n+                                             sched_nodes, must_precede,\n+                                             must_follow);\n+\n               for (c = start; c != end; c += step)\n                 {\n-                  verify_partial_schedule (ps, sched_nodes);\n+                  sbitmap tmp_precede = NULL;\n+                  sbitmap tmp_follow = NULL;\n \n-                  psi = ps_add_node_check_conflicts (ps, u_node, c,\n-                                                     must_precede,\n-                                                     must_follow);\n-\n-                  if (psi)\n+                  if (c == start)\n                     {\n-                      SCHED_TIME (u_node) = c;\n-                      SET_BIT (sched_nodes, u);\n-                      success = 1;\n-                      num_splits = 0;\n-                      if (dump_file)\n-                        fprintf (dump_file, \"Scheduled w/o split in %d\\n\", c);\n-\n-                      break;\n+                      if (step == 1)\n+                        tmp_precede = must_precede;\n+                      else      /* step == -1.  */\n+                        tmp_follow = must_follow;\n                     }\n+                  if (c == end - step)\n+                    {\n+                      if (step == 1)\n+                        tmp_follow = must_follow;\n+                      else      /* step == -1.  */\n+                        tmp_precede = must_precede;\n+                    }\n+\n+                  success =\n+                    try_scheduling_node_in_cycle (ps, u_node, u, c,\n+                                                  sched_nodes,\n+                                                  &num_splits, tmp_precede,\n+                                                  tmp_follow);\n+                  if (success)\n+                    break;\n                 }\n+\n               verify_partial_schedule (ps, sched_nodes);\n             }\n             if (!success)\n@@ -2391,10 +2511,10 @@ ps_insn_find_column (partial_schedule_ptr ps, ps_insn_ptr ps_i,\n        next_ps_i;\n        next_ps_i = next_ps_i->next_in_row)\n     {\n-      if (TEST_BIT (must_follow, next_ps_i->node->cuid)\n+      if (must_follow && TEST_BIT (must_follow, next_ps_i->node->cuid)\n \t  && ! first_must_follow)\n         first_must_follow = next_ps_i;\n-      if (TEST_BIT (must_precede, next_ps_i->node->cuid))\n+      if (must_precede && TEST_BIT (must_precede, next_ps_i->node->cuid))\n         {\n           /* If we have already met a node that must follow, then\n \t     there is no possible column.  */\n@@ -2451,7 +2571,7 @@ ps_insn_advance_column (partial_schedule_ptr ps, ps_insn_ptr ps_i,\n \n   /* Check if next_in_row is dependent on ps_i, both having same sched\n      times (typically ANTI_DEP).  If so, ps_i cannot skip over it.  */\n-  if (TEST_BIT (must_follow, next_node->cuid))\n+  if (must_follow && TEST_BIT (must_follow, next_node->cuid))\n     return false;\n \n   /* Advance PS_I over its next_in_row in the doubly linked list.  */"}, {"sha": "5015c3d6b6ceaac442fae68bfad995c657954074", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d48b46e04dced221f3e617d8f4ea3904b93f9b3f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d48b46e04dced221f3e617d8f4ea3904b93f9b3f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d48b46e04dced221f3e617d8f4ea3904b93f9b3f", "patch": "@@ -1,3 +1,12 @@\n+2007-12-02  Revital Eres  <eres@il.ibm.com>\n+\n+\t* gcc.dg/sms-4.c: New testcase.\n+\n+2007-12-02  Vladimir Yanovsky  <yanov@il.ibm.com>\n+            Revital Eres  <eres@il.ibm.com>\n+\n+\t* gcc.dg/sms-3.c: New testcase.\n+\n 2007-12-01  Ollie Wild  <aaw@google.com>\n \n \tPR c++/8171"}, {"sha": "66792b5993b86e03e16307ed59eca54ecc8f80de", "filename": "gcc/testsuite/gcc.dg/sms-3.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d48b46e04dced221f3e617d8f4ea3904b93f9b3f/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d48b46e04dced221f3e617d8f4ea3904b93f9b3f/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-3.c?ref=d48b46e04dced221f3e617d8f4ea3904b93f9b3f", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fmodulo-sched -funroll-loops\" } */\n+\n+extern void abort (void);\n+\n+int X[1000]={0};\n+int Y[1000]={0};\n+\n+extern void abort (void);\n+\n+int\n+foo (int len, long a)\n+{\n+  int i;\n+  long res = a;\n+\n+  len = 1000;\n+  for (i = 0; i < len; i++)\n+    res += X[i]* Y[i];\n+\n+  if (res != 601)\n+    abort ();\n+\n+}\n+\n+int\n+main ()\n+{\n+  X[0] = Y[1] = 2;\n+  Y[0] = X[1] = 21;\n+  X[2] = Y[3] = 3;\n+  Y[2] = X[3] = 31;\n+  X[4] = Y[5] = 4;\n+  Y[4] = X[5] = 41;\n+\n+  foo (6, 3);\n+  return 0;\n+}\n+"}, {"sha": "04e89bb2572f56a84e743105598422b502e63d67", "filename": "gcc/testsuite/gcc.dg/sms-4.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d48b46e04dced221f3e617d8f4ea3904b93f9b3f/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d48b46e04dced221f3e617d8f4ea3904b93f9b3f/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-4.c?ref=d48b46e04dced221f3e617d8f4ea3904b93f9b3f", "patch": "@@ -0,0 +1,35 @@\n+/* Inspired from sbitmap_a_or_b_and_c_cg function in sbitmap.c.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fmodulo-sched -fmodulo-sched-allow-regmoves\" } */\n+\n+extern void abort (void);\n+\n+int a[5] = { 0, 1, 0, 0, 0 };\n+int b[5] = { 0, 1, 0, 1, 0 };\n+int c[5] = { 0, 0, 1, 1, 0 };\n+int dst[5] = { 0, 0, 0, 0, 0 };\n+\n+void\n+foo (int size, int *ap, int *bp, int *cp, int *dstp)\n+{\n+  unsigned int i, n = size;\n+  int changed = 0;\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      const int tmp = *ap++ | (*bp++ & *cp++);\n+      changed |= *dstp ^ tmp;\n+      *dstp++ = tmp;\n+    }\n+\n+  if (changed == 0)\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  foo (5, a, b, c, dst);\n+  return 0;\n+}\n+"}]}