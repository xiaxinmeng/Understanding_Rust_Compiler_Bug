{"sha": "50e94c7e583d2be25b1f940923fa01203aac65c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBlOTRjN2U1ODNkMmJlMjViMWY5NDA5MjNmYTAxMjAzYWFjNjVjMw==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2008-06-18T05:42:23Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2008-06-18T05:42:23Z"}, "message": "df.h (struct df_ref): Replace 'insn' field with 'insn_info' field.\n\n\t* df.h (struct df_ref): Replace 'insn' field with 'insn_info' field.\n\t(DF_REF_INSN_INFO): New.\n\t(DF_REF_INSN, DF_REF_INSN_UID): Rewrite macros using DF_REF_INSN_INFO.\n\t(DF_REF_IS_ARTIFICIAL): Artificial refs are now identified as refs\n\twith a NULL DF_REF_INSN_INFO.\n\t(DF_INSN_INFO_GET, DF_INSN_INFO_SET): Renamed from DF_INSN_GET and\n\tDF_INSN_SET.\n\t(DF_INSN_INFO_LUID, DF_INSN_INFO_DEFS, DF_INSN_INFO_USES,\n\tDF_INSN_INFO_EQ_USES): New.\n\t(DF_INSN_LUID, DF_INSN_DEFS, DF_INSN_USES, DF_INSN_EQ_USES,\n\tDF_INSN_UID_LUID, DF_INSN_UID_DEFS, DF_INSN_UID_USES,\n\tDF_INSN_UID_EQ_USES): Rewrite using DF_INSN_INFO_* macros.\n\t* df-core.c: Update comment for above changes.\n\t(df_insn_debug_regno): Use DF_INSN_INFO_GET instead of INSN_UID and\n\tDF_INSN_UID_* macros.\n\t(df_ref_debug): Check for NULL DF_REF_INSN_INFO.\n\t* df-scan.c (df_ref_record): Take a df_insn_info instead of an\n\tinsn rtx.  Update all callers.\n\t(df_def_record_1, df_defs_record, df_uses_record, df_get_call_refs,\n\tdf_ref_create_structure, df_insn_refs_collect): Likewise.\n\t(df_ref_equal_p): Compare DF_REF_INSN_INFO pointers for the refs.\n\t* df-problems.c (df_chain_dump): Test for non-NULL DF_REF_INSN_INFO.\n\t(df_live_bb_local_compute): Retrieve DF_INSN_INFO, use DF_INSN_INFO_*\n\tmacros to access the insn refs.\n\t(df_chain_top_dump, df_chain_bottom_dump, df_byte_lr_alloc): Likewise.\n\t* fwprop.c (use_killed_between): Use DF_REF_INSN accessor macro.\n\t(all_uses_available): Retrieve DF_INSN_INFO for def_insn, and use it\n\tfor accessing the refs.\n\t(try_fwprop_subst): Likewise.\n\t* ddg.c (add_cross_iteration_register_deps): Use DF_REF_INSN macro.\n\t* web.c (union_defs): Retrieve DF_INSN_INFO for def_insn, and use it\n\tfor accessing the refs.\n\t* loop-invariant.c (invariant_for_use): Use DF_REF_BB macro.\n\t(check_dependencies): Use DF_INSN_INFO_GET, use DF_INSN_INFO_* macros\n\tto look at the insn refs.\n\t(record_uses): Likewise.\n\t* dce.c (deletable_insn_p): Don't tolerate artificial DEFs in this\n\tfunction anymore.\n\t(mark_artificial_uses): Don't mark_insn for artificial refs.\n\t(mark_reg_rependencies): Likewise.\n\n\t* doc/rtl.texi: Remove documentation of ADDRESSOF.\n\nFrom-SVN: r136885", "tree": {"sha": "0c8c1622859a712e7e554f00afbc548652bc9317", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c8c1622859a712e7e554f00afbc548652bc9317"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50e94c7e583d2be25b1f940923fa01203aac65c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50e94c7e583d2be25b1f940923fa01203aac65c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50e94c7e583d2be25b1f940923fa01203aac65c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50e94c7e583d2be25b1f940923fa01203aac65c3/comments", "author": null, "committer": null, "parents": [{"sha": "00bb81c15b2976156db1be68faee7071e9efdf8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00bb81c15b2976156db1be68faee7071e9efdf8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00bb81c15b2976156db1be68faee7071e9efdf8b"}], "stats": {"total": 416, "additions": 240, "deletions": 176}, "files": [{"sha": "c65ec1ed14e4705ed9f14fa351a8663236329078", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e94c7e583d2be25b1f940923fa01203aac65c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e94c7e583d2be25b1f940923fa01203aac65c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=50e94c7e583d2be25b1f940923fa01203aac65c3", "patch": "@@ -1,3 +1,48 @@\n+2008-06-18  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* df.h (struct df_ref): Replace 'insn' field with 'insn_info' field.\n+\t(DF_REF_INSN_INFO): New.\n+\t(DF_REF_INSN, DF_REF_INSN_UID): Rewrite macros using DF_REF_INSN_INFO.\n+\t(DF_REF_IS_ARTIFICIAL): Artificial refs are now identified as refs\n+\twith a NULL DF_REF_INSN_INFO.\n+\t(DF_INSN_INFO_GET, DF_INSN_INFO_SET): Renamed from DF_INSN_GET and\n+\tDF_INSN_SET.\n+\t(DF_INSN_INFO_LUID, DF_INSN_INFO_DEFS, DF_INSN_INFO_USES,\n+\tDF_INSN_INFO_EQ_USES): New.\n+\t(DF_INSN_LUID, DF_INSN_DEFS, DF_INSN_USES, DF_INSN_EQ_USES,\n+\tDF_INSN_UID_LUID, DF_INSN_UID_DEFS, DF_INSN_UID_USES,\n+\tDF_INSN_UID_EQ_USES): Rewrite using DF_INSN_INFO_* macros.\n+\t* df-core.c: Update comment for above changes.\n+\t(df_insn_debug_regno): Use DF_INSN_INFO_GET instead of INSN_UID and\n+\tDF_INSN_UID_* macros.\n+\t(df_ref_debug): Check for NULL DF_REF_INSN_INFO.\n+\t* df-scan.c (df_ref_record): Take a df_insn_info instead of an\n+\tinsn rtx.  Update all callers.\n+\t(df_def_record_1, df_defs_record, df_uses_record, df_get_call_refs,\n+\tdf_ref_create_structure, df_insn_refs_collect): Likewise.\n+\t(df_ref_equal_p): Compare DF_REF_INSN_INFO pointers for the refs.\n+\t* df-problems.c (df_chain_dump): Test for non-NULL DF_REF_INSN_INFO.\n+\t(df_live_bb_local_compute): Retrieve DF_INSN_INFO, use DF_INSN_INFO_*\n+\tmacros to access the insn refs.\n+\t(df_chain_top_dump, df_chain_bottom_dump, df_byte_lr_alloc): Likewise.\n+\t* fwprop.c (use_killed_between): Use DF_REF_INSN accessor macro.\n+\t(all_uses_available): Retrieve DF_INSN_INFO for def_insn, and use it\n+\tfor accessing the refs.\n+\t(try_fwprop_subst): Likewise.\n+\t* ddg.c (add_cross_iteration_register_deps): Use DF_REF_INSN macro.\n+\t* web.c (union_defs): Retrieve DF_INSN_INFO for def_insn, and use it\n+\tfor accessing the refs.\n+\t* loop-invariant.c (invariant_for_use): Use DF_REF_BB macro.\n+\t(check_dependencies): Use DF_INSN_INFO_GET, use DF_INSN_INFO_* macros\n+\tto look at the insn refs.\n+\t(record_uses): Likewise.\n+\t* dce.c (deletable_insn_p): Don't tolerate artificial DEFs in this\n+\tfunction anymore.\n+\t(mark_artificial_uses): Don't mark_insn for artificial refs.\n+\t(mark_reg_rependencies): Likewise.\n+\n+\t* doc/rtl.texi: Remove documentation of ADDRESSOF.\n+\n 2008-06-17  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \t* configure: Regenerate."}, {"sha": "31a5f51ac1c188be43b6012fa77fe5764e7532ca", "filename": "gcc/dce.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e94c7e583d2be25b1f940923fa01203aac65c3/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e94c7e583d2be25b1f940923fa01203aac65c3/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=50e94c7e583d2be25b1f940923fa01203aac65c3", "patch": "@@ -154,12 +154,10 @@ deletable_insn_p (rtx insn, bool fast)\n static inline int\n marked_insn_p (rtx insn)\n {\n-  if (insn)\n-    return TEST_BIT (marked, INSN_UID (insn));\n-  else \n-    /* Artificial defs are always needed and they do not have an\n-       insn.  */\n-    return true;\n+  /* Artificial defs are always needed and they do not have an insn.\n+     We should never see them here.  */\n+  gcc_assert (insn);\n+  return TEST_BIT (marked, INSN_UID (insn));\n }\n \n \n@@ -339,7 +337,8 @@ mark_artificial_uses (void)\n       for (use_rec = df_get_artificial_uses (bb->index); \n \t   *use_rec; use_rec++)\n \tfor (defs = DF_REF_CHAIN (*use_rec); defs; defs = defs->next)\n-\t  mark_insn (DF_REF_INSN (defs->ref), false);\n+\t  if (! DF_REF_IS_ARTIFICIAL (defs->ref))\n+\t    mark_insn (DF_REF_INSN (defs->ref), false);\n     }\n }\n \n@@ -362,7 +361,8 @@ mark_reg_dependencies (rtx insn)\n \t  fprintf (dump_file, \" in insn %d:\\n\", INSN_UID (insn));\n \t}\n       for (defs = DF_REF_CHAIN (use); defs; defs = defs->next)\n-\tmark_insn (DF_REF_INSN (defs->ref), false);\n+\tif (! DF_REF_IS_ARTIFICIAL (defs->ref))\n+\t  mark_insn (DF_REF_INSN (defs->ref), false);\n     }\n }\n "}, {"sha": "1f8c1406fc45507a4757b82702d800c7d42b6ab9", "filename": "gcc/ddg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e94c7e583d2be25b1f940923fa01203aac65c3/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e94c7e583d2be25b1f940923fa01203aac65c3/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=50e94c7e583d2be25b1f940923fa01203aac65c3", "patch": "@@ -289,7 +289,7 @@ add_cross_iteration_register_deps (ddg_ptr g, struct df_ref *last_def)\n \t     deps when broken.\tIf the first_def reaches the USE then\n \t     there is such a dep.  */\n \t  ddg_node_ptr first_def_node = get_node_of_insn (g,\n-\t\t\t\t\t\t\t  first_def->insn);\n+\t\t\t\t\t\t\t  DF_REF_INSN (first_def));\n \n \t  gcc_assert (first_def_node);\n \n@@ -314,7 +314,7 @@ add_cross_iteration_register_deps (ddg_ptr g, struct df_ref *last_def)\n       if (last_def->id == first_def->id)\n \treturn;\n \n-      dest_node = get_node_of_insn (g, first_def->insn);\n+      dest_node = get_node_of_insn (g, DF_REF_INSN (first_def));\n       gcc_assert (dest_node);\n       create_ddg_dep_no_link (g, last_def_node, dest_node,\n \t\t\t      OUTPUT_DEP, REG_DEP, 1);"}, {"sha": "9e23c759469e51d4a301081a887e9daf05c4882e", "filename": "gcc/df-core.c", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e94c7e583d2be25b1f940923fa01203aac65c3/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e94c7e583d2be25b1f940923fa01203aac65c3/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=50e94c7e583d2be25b1f940923fa01203aac65c3", "patch": "@@ -268,25 +268,29 @@ pseudos and long for the hard registers.\n \n ACCESSING INSNS:\n \n-1) The df insn information is kept in the insns array.  This array is\n-   indexed by insn uid.  \n-\n-2) Each insn has three sets of refs: They are linked into one of three\n-   lists: the insn's defs list (accessed by the DF_INSN_DEFS or\n-   DF_INSN_UID_DEFS macros), the insn's uses list (accessed by the\n-   DF_INSN_USES or DF_INSN_UID_USES macros) or the insn's eq_uses list\n-   (accessed by the DF_INSN_EQ_USES or DF_INSN_UID_EQ_USES macros).\n-   The latter list are the list of references in REG_EQUAL or\n-   REG_EQUIV notes.  These macros produce a ref (or NULL), the rest of\n-   the list can be obtained by traversal of the NEXT_REF field\n-   (accessed by the DF_REF_NEXT_REF macro.)  There is no significance\n-   to the ordering of the uses or refs in an instruction.\n-\n-3) Each insn has a logical uid field (LUID).  When properly set, this\n-   is an integer that numbers each insn in the basic block, in order from\n-   the start of the block.  The numbers are only correct after a call to\n-   df_analyse.  They will rot after insns are added deleted or moved\n-   around.\n+1) The df insn information is kept in an array of DF_INSN_INFO objects.\n+   The array is indexed by insn uid, and every DF_REF points to the\n+   DF_INSN_INFO object of the insn that contains the reference.\n+\n+2) Each insn has three sets of refs, which are linked into one of three\n+   lists: The insn's defs list (accessed by the DF_INSN_INFO_DEFS,\n+   DF_INSN_DEFS, or DF_INSN_UID_DEFS macros), the insn's uses list\n+   (accessed by the DF_INSN_INFO_USES, DF_INSN_USES, or\n+   DF_INSN_UID_USES macros) or the insn's eq_uses list (accessed by the\n+   DF_INSN_INFO_EQ_USES, DF_INSN_EQ_USES or DF_INSN_UID_EQ_USES macros).\n+   The latter list are the list of references in REG_EQUAL or REG_EQUIV\n+   notes.  These macros produce a ref (or NULL), the rest of the list\n+   can be obtained by traversal of the NEXT_REF field (accessed by the\n+   DF_REF_NEXT_REF macro.)  There is no significance to the ordering of\n+   the uses or refs in an instruction.\n+\n+3) Each insn has a logical uid field (LUID) which is stored in the\n+   DF_INSN_INFO object for the insn.  The LUID field is accessed by\n+   the DF_INSN_INFO_LUID, DF_INSN_LUID, and DF_INSN_UID_LUID macros.\n+   When properly set, the LUID is an integer that numbers each insn in\n+   the basic block, in order from the start of the block.\n+   The numbers are only correct after a call to df_analyze.  They will\n+   rot after insns are added deleted or moved round.\n \n ACCESSING REFS:\n \n@@ -2152,17 +2156,18 @@ df_insn_debug (rtx insn, bool follow_chain, FILE *file)\n void\n df_insn_debug_regno (rtx insn, FILE *file)\n {\n-  unsigned int uid = INSN_UID(insn);\n+  struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n \n   fprintf (file, \"insn %d bb %d luid %d defs \",\n-\t   uid, BLOCK_FOR_INSN (insn)->index, DF_INSN_LUID (insn));\n-  df_refs_chain_dump (DF_INSN_UID_DEFS (uid), false, file);\n+\t   INSN_UID (insn), BLOCK_FOR_INSN (insn)->index,\n+\t   DF_INSN_INFO_LUID (insn_info));\n+  df_refs_chain_dump (DF_INSN_INFO_DEFS (insn_info), false, file);\n     \n   fprintf (file, \" uses \");\n-  df_refs_chain_dump (DF_INSN_UID_USES (uid), false, file);\n+  df_refs_chain_dump (DF_INSN_INFO_USES (insn_info), false, file);\n \n   fprintf (file, \" eq_uses \");\n-  df_refs_chain_dump (DF_INSN_UID_EQ_USES (uid), false, file);\n+  df_refs_chain_dump (DF_INSN_INFO_EQ_USES (insn_info), false, file);\n   fprintf (file, \"\\n\");\n }\n \n@@ -2188,7 +2193,7 @@ df_ref_debug (struct df_ref *ref, FILE *file)\n   fprintf (file, \"reg %d bb %d insn %d flag 0x%x type 0x%x \",\n \t   DF_REF_REGNO (ref),\n \t   DF_REF_BBNO (ref),\n-\t   DF_REF_INSN (ref) ? INSN_UID (DF_REF_INSN (ref)) : -1,\n+\t   DF_REF_INSN_INFO (ref) ? INSN_UID (DF_REF_INSN (ref)) : -1,\n \t   DF_REF_FLAGS (ref),\n \t   DF_REF_TYPE (ref));\n   if (DF_REF_LOC (ref))"}, {"sha": "b9f5eecec0869f5ccfcb30d8c6f6f7463f3cb6d9", "filename": "gcc/df-problems.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e94c7e583d2be25b1f940923fa01203aac65c3/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e94c7e583d2be25b1f940923fa01203aac65c3/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=50e94c7e583d2be25b1f940923fa01203aac65c3", "patch": "@@ -129,7 +129,7 @@ df_chain_dump (struct df_link *link, FILE *file)\n \t       DF_REF_REG_DEF_P (link->ref) ? 'd' : 'u',\n \t       DF_REF_ID (link->ref),\n \t       DF_REF_BBNO (link->ref),\n-\t       DF_REF_INSN (link->ref) ? DF_REF_INSN_UID (link->ref) : -1);\n+\t       DF_REF_INSN_INFO (link->ref) ? DF_REF_INSN_UID (link->ref) : -1);\n     }\n   fprintf (file, \"}\");\n }\n@@ -1429,15 +1429,15 @@ df_live_bb_local_compute (unsigned int bb_index)\n       if (!insn_info)\n \t{\n \t  gcc_assert (!INSN_P (insn));\n-\t  df_insn_create_insn_record (insn);\n+\t  insn_info = df_insn_create_insn_record (insn);\n \t}\n \n-      DF_INSN_LUID (insn) = luid;\n+      DF_INSN_INFO_LUID (insn_info) = luid;\n       if (!INSN_P (insn))\n \tcontinue;\n \n       luid++;\n-      for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n+      for (def_rec = DF_INSN_INFO_DEFS (insn_info); *def_rec; def_rec++)\n \t{\n \t  struct df_ref *def = *def_rec;\n \t  unsigned int regno = DF_REF_REGNO (def);\n@@ -2201,14 +2201,14 @@ df_chain_top_dump (basic_block bb, FILE *file)\n \n       FOR_BB_INSNS (bb, insn)\n \t{\n-\t  unsigned int uid = INSN_UID (insn);\n \t  if (INSN_P (insn))\n \t    {\n-\t      def_rec = DF_INSN_UID_DEFS (uid);\n+\t      struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+\t      def_rec = DF_INSN_INFO_DEFS (insn_info);\n \t      if (*def_rec)\n \t\t{\n \t\t  fprintf (file, \";;   DU chains for insn luid %d uid %d\\n\", \n-\t\t\t   DF_INSN_LUID (insn), uid);\n+\t\t\t   DF_INSN_INFO_LUID (insn_info), INSN_UID (insn));\n \t\t  \n \t\t  while (*def_rec)\n \t\t    {\n@@ -2250,15 +2250,15 @@ df_chain_bottom_dump (basic_block bb, FILE *file)\n \n       FOR_BB_INSNS (bb, insn)\n \t{\n-\t  unsigned int uid = INSN_UID (insn);\n \t  if (INSN_P (insn))\n \t    {\n-\t      struct df_ref **eq_use_rec = DF_INSN_UID_EQ_USES (uid);\n-\t      use_rec = DF_INSN_UID_USES (uid);\n+\t      struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+\t      struct df_ref **eq_use_rec = DF_INSN_INFO_EQ_USES (insn_info);\n+\t      use_rec = DF_INSN_INFO_USES (insn_info);\n \t      if (*use_rec || *eq_use_rec)\n \t\t{\n \t\t  fprintf (file, \";;   UD chains for insn luid %d uid %d\\n\", \n-\t\t\t   DF_INSN_LUID (insn), uid);\n+\t\t\t   DF_INSN_INFO_LUID (insn_info), INSN_UID (insn));\n \t\t  \n \t\t  while (*use_rec)\n \t\t    {\n@@ -2515,8 +2515,9 @@ df_byte_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n \t{\n \t  if (INSN_P (insn))\n \t    {\n-\t      df_byte_lr_check_regs (DF_INSN_DEFS (insn));\n-\t      df_byte_lr_check_regs (DF_INSN_USES (insn));\n+\t      struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+\t      df_byte_lr_check_regs (DF_INSN_INFO_DEFS (insn_info));\n+\t      df_byte_lr_check_regs (DF_INSN_INFO_USES (insn_info));\n \t    }\n \t}\n       bitmap_set_bit (df_byte_lr->out_of_date_transfer_functions, bb->index);"}, {"sha": "966fd4b255f833fc37d872e85609694654b30c50", "filename": "gcc/df-scan.c", "status": "modified", "additions": 93, "deletions": 86, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e94c7e583d2be25b1f940923fa01203aac65c3/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e94c7e583d2be25b1f940923fa01203aac65c3/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=50e94c7e583d2be25b1f940923fa01203aac65c3", "patch": "@@ -94,26 +94,28 @@ static struct df_mw_hardreg * df_null_mw_rec[1];\n \n static void df_ref_record (struct df_collection_rec *,\n \t\t\t   rtx, rtx *, \n-\t\t\t   basic_block, rtx, enum df_ref_type, \n-\t\t\t   enum df_ref_flags, int, int, enum machine_mode);\n-static void df_def_record_1 (struct df_collection_rec *,\n-\t\t\t     rtx, basic_block, rtx,\n+\t\t\t   basic_block, struct df_insn_info *,\n+\t\t\t   enum df_ref_type, enum df_ref_flags,\n+\t\t\t   int, int, enum machine_mode);\n+static void df_def_record_1 (struct df_collection_rec *, rtx,\n+\t\t\t     basic_block, struct df_insn_info *,\n \t\t\t     enum df_ref_flags);\n-static void df_defs_record (struct df_collection_rec *,\n-\t\t\t    rtx, basic_block, rtx,\n+static void df_defs_record (struct df_collection_rec *, rtx,\n+\t\t\t    basic_block, struct df_insn_info *,\n \t\t\t    enum df_ref_flags);\n static void df_uses_record (struct df_collection_rec *,\n \t\t\t    rtx *, enum df_ref_type,\n-\t\t\t    basic_block, rtx, enum df_ref_flags, \n+\t\t\t    basic_block, struct df_insn_info *,\n+\t\t\t    enum df_ref_flags, \n \t\t\t    int, int, enum machine_mode);\n \n static struct df_ref *df_ref_create_structure (struct df_collection_rec *, rtx, rtx *, \n-\t\t\t\t\t       basic_block, rtx, enum df_ref_type, \n-\t\t\t\t\t       enum df_ref_flags, \n+\t\t\t\t\t       basic_block, struct df_insn_info *,\n+\t\t\t\t\t       enum df_ref_type, enum df_ref_flags,\n \t\t\t\t\t       int, int, enum machine_mode);\n \n static void df_insn_refs_collect (struct df_collection_rec*, \n-\t\t\t\t  basic_block, rtx); \n+\t\t\t\t  basic_block, struct df_insn_info *); \n static void df_canonize_collection_rec (struct df_collection_rec *);\n \n static void df_get_regular_block_artificial_uses (bitmap);\n@@ -636,7 +638,7 @@ df_ref_create (rtx reg, rtx *loc, rtx insn,\n \n   /* You cannot hack artificial refs.  */\n   gcc_assert (insn);\n-  ref = df_ref_create_structure (NULL, reg, loc, bb, insn,\n+  ref = df_ref_create_structure (NULL, reg, loc, bb, DF_INSN_INFO_GET (insn),\n                                  ref_type, ref_flags, \n \t\t\t\t width, offset, mode);\n \n@@ -924,11 +926,11 @@ df_insn_create_insn_record (rtx insn)\n   struct df_insn_info *insn_rec;\n \n   df_grow_insn_info ();\n-  insn_rec = DF_INSN_GET (insn);\n+  insn_rec = DF_INSN_INFO_GET (insn);\n   if (!insn_rec)\n     {\n       insn_rec = pool_alloc (problem_data->insn_pool);\n-      DF_INSN_SET (insn, insn_rec);\n+      DF_INSN_INFO_SET (insn, insn_rec);\n     }\n   memset (insn_rec, 0, sizeof (struct df_insn_info));\n   insn_rec->insn = insn;\n@@ -1166,8 +1168,8 @@ df_insn_rescan (rtx insn)\n     }\n   else\n     {\n-      df_insn_create_insn_record (insn);\n-      df_insn_refs_collect (&collection_rec, bb, insn);\n+      struct df_insn_info *insn_info = df_insn_create_insn_record (insn);\n+      df_insn_refs_collect (&collection_rec, bb, insn_info);\n       if (dump_file)\n \tfprintf (dump_file, \"scanning new insn with uid = %d.\\n\", uid);\n     }\n@@ -1893,8 +1895,7 @@ df_ref_change_reg_with_loc_1 (struct df_reg_info *old, struct df_reg_info *new,\n \t    }\n \t  else\n \t    {\n-\t      struct df_insn_info *insn_info \n-\t\t= DF_INSN_GET (DF_REF_INSN (the_ref));\n+\t      struct df_insn_info *insn_info = DF_REF_INSN_INFO (the_ref);\n \t      if (DF_REF_FLAGS (the_ref) & DF_REF_IN_NOTE)\n \t\tref_vec = insn_info->eq_uses;\n \t      else\n@@ -2064,7 +2065,7 @@ df_notes_rescan (rtx insn)\n \t    case REG_EQUAL:\n \t      df_uses_record (&collection_rec,\n \t\t\t      &XEXP (note, 0), DF_REF_REG_USE,\n-\t\t\t      bb, insn, DF_REF_IN_NOTE, -1, -1, 0);\n+\t\t\t      bb, insn_info, DF_REF_IN_NOTE, -1, -1, 0);\n \t    default:\n \t      break;\n \t    }\n@@ -2149,7 +2150,7 @@ df_ref_equal_p (struct df_ref *ref1, struct df_ref *ref2)\n     (DF_REF_REG (ref1) == DF_REF_REG (ref2)\n      && DF_REF_REGNO (ref1) == DF_REF_REGNO (ref2)\n      && DF_REF_LOC (ref1) == DF_REF_LOC (ref2)\n-     && DF_REF_INSN (ref1) == DF_REF_INSN (ref2)\n+     && DF_REF_INSN_INFO (ref1) == DF_REF_INSN_INFO (ref2)\n      && DF_REF_TYPE (ref1) == DF_REF_TYPE (ref2)\n      && ((DF_REF_FLAGS (ref1) & ~(DF_REF_REG_MARKER + DF_REF_MW_HARDREG)) \n \t == (DF_REF_FLAGS (ref2) & ~(DF_REF_REG_MARKER + DF_REF_MW_HARDREG)))\n@@ -2516,7 +2517,7 @@ df_refs_add_to_chains (struct df_collection_rec *collection_rec,\n {\n   if (insn)\n     {\n-      struct df_insn_info *insn_rec = DF_INSN_GET (insn);\n+      struct df_insn_info *insn_rec = DF_INSN_INFO_GET (insn);\n       /* If there is a vector in the collection rec, add it to the\n \t insn.  A null rec is a signal that the caller will handle the\n \t chain specially.  */\n@@ -2591,7 +2592,7 @@ df_refs_add_to_chains (struct df_collection_rec *collection_rec,\n static struct df_ref *\n df_ref_create_structure (struct df_collection_rec *collection_rec,\n \t\t\t rtx reg, rtx *loc, \n-\t\t\t basic_block bb, rtx insn, \n+\t\t\t basic_block bb, struct df_insn_info *info,\n \t\t\t enum df_ref_type ref_type, \n \t\t\t enum df_ref_flags ref_flags,\n \t\t\t int width, int offset, enum machine_mode mode)\n@@ -2614,7 +2615,7 @@ df_ref_create_structure (struct df_collection_rec *collection_rec,\n   DF_REF_REG (this_ref) = reg;\n   DF_REF_REGNO (this_ref) =  regno;\n   DF_REF_LOC (this_ref) = loc;\n-  DF_REF_INSN (this_ref) = insn;\n+  DF_REF_INSN_INFO (this_ref) = info;\n   DF_REF_CHAIN (this_ref) = NULL;\n   DF_REF_TYPE (this_ref) = ref_type;\n   DF_REF_FLAGS (this_ref) = ref_flags;\n@@ -2669,7 +2670,7 @@ df_ref_create_structure (struct df_collection_rec *collection_rec,\n static void\n df_ref_record (struct df_collection_rec *collection_rec,\n                rtx reg, rtx *loc, \n-\t       basic_block bb, rtx insn, \n+\t       basic_block bb, struct df_insn_info *insn_info,\n \t       enum df_ref_type ref_type, \n \t       enum df_ref_flags ref_flags,\n \t       int width, int offset, enum machine_mode mode) \n@@ -2700,7 +2701,7 @@ df_ref_record (struct df_collection_rec *collection_rec,\n       /*  If this is a multiword hardreg, we create some extra\n \t  datastructures that will enable us to easily build REG_DEAD\n \t  and REG_UNUSED notes.  */\n-      if ((endregno != regno + 1) && insn)\n+      if ((endregno != regno + 1) && insn_info)\n \t{\n \t  /* Sets to a subreg of a multiword register are partial. \n \t     Sets to a non-subreg of a multiword register are not.  */\n@@ -2721,7 +2722,7 @@ df_ref_record (struct df_collection_rec *collection_rec,\n       for (i = regno; i < endregno; i++)\n \t{\n \t  ref = df_ref_create_structure (collection_rec, regno_reg_rtx[i], loc, \n-\t\t\t\t\t bb, insn, ref_type, ref_flags, \n+\t\t\t\t\t bb, insn_info, ref_type, ref_flags, \n \t\t\t\t\t width, offset, mode);\n \n           gcc_assert (ORIGINAL_REGNO (DF_REF_REG (ref)) == i);\n@@ -2730,7 +2731,7 @@ df_ref_record (struct df_collection_rec *collection_rec,\n   else\n     {\n       struct df_ref *ref;\n-      ref = df_ref_create_structure (collection_rec, reg, loc, bb, insn, \n+      ref = df_ref_create_structure (collection_rec, reg, loc, bb, insn_info, \n                                      ref_type, ref_flags, width, offset, mode);\n     }\n }\n@@ -2760,7 +2761,7 @@ df_read_modify_subreg_p (rtx x)\n \n static void\n df_def_record_1 (struct df_collection_rec *collection_rec,\n-                 rtx x, basic_block bb, rtx insn, \n+                 rtx x, basic_block bb, struct df_insn_info *insn_info,\n \t\t enum df_ref_flags flags)\n {\n   rtx *loc;\n@@ -2788,7 +2789,7 @@ df_def_record_1 (struct df_collection_rec *collection_rec,\n \t  if (GET_CODE (temp) == EXPR_LIST || GET_CODE (temp) == CLOBBER\n \t      || GET_CODE (temp) == SET)\n \t    df_def_record_1 (collection_rec,\n-                             temp, bb, insn, \n+                             temp, bb, insn_info, \n \t\t\t     GET_CODE (temp) == CLOBBER \n \t\t\t     ? flags | DF_REF_MUST_CLOBBER : flags);\n \t}\n@@ -2823,14 +2824,14 @@ df_def_record_1 (struct df_collection_rec *collection_rec,\n   if (REG_P (dst))\n     {\n       df_ref_record (collection_rec, \n-\t\t     dst, loc, bb, insn, DF_REF_REG_DEF, flags, \n+\t\t     dst, loc, bb, insn_info, DF_REF_REG_DEF, flags, \n \t\t     width, offset, mode);\n \n       /* We want to keep sp alive everywhere - by making all\n \t writes to sp also use of sp. */\n       if (REGNO (dst) == STACK_POINTER_REGNUM)\n \tdf_ref_record (collection_rec,\n-\t\t       dst, NULL, bb, insn, DF_REF_REG_USE, flags, \n+\t\t       dst, NULL, bb, insn_info, DF_REF_REG_USE, flags, \n \t\t       width, offset, mode);\n     }\n   else if (GET_CODE (dst) == SUBREG && REG_P (SUBREG_REG (dst)))\n@@ -2841,7 +2842,7 @@ df_def_record_1 (struct df_collection_rec *collection_rec,\n       flags |= DF_REF_SUBREG;\n \n       df_ref_record (collection_rec, \n-\t\t     dst, loc, bb, insn, DF_REF_REG_DEF, flags, \n+\t\t     dst, loc, bb, insn_info, DF_REF_REG_DEF, flags, \n \t\t     width, offset, mode);\n     }\n }\n@@ -2851,7 +2852,8 @@ df_def_record_1 (struct df_collection_rec *collection_rec,\n \n static void\n df_defs_record (struct df_collection_rec *collection_rec, \n-                rtx x, basic_block bb, rtx insn, enum df_ref_flags flags)\n+                rtx x, basic_block bb, struct df_insn_info *insn_info,\n+\t\tenum df_ref_flags flags)\n {\n   RTX_CODE code = GET_CODE (x);\n \n@@ -2860,20 +2862,20 @@ df_defs_record (struct df_collection_rec *collection_rec,\n       /* Mark the single def within the pattern.  */\n       enum df_ref_flags clobber_flags = flags;\n       clobber_flags |= (code == CLOBBER) ? DF_REF_MUST_CLOBBER : 0;\n-      df_def_record_1 (collection_rec, x, bb, insn, clobber_flags);\n+      df_def_record_1 (collection_rec, x, bb, insn_info, clobber_flags);\n     }\n   else if (code == COND_EXEC)\n     {\n       df_defs_record (collection_rec, COND_EXEC_CODE (x), \n-\t\t      bb, insn, DF_REF_CONDITIONAL);\n+\t\t      bb, insn_info, DF_REF_CONDITIONAL);\n     }\n   else if (code == PARALLEL)\n     {\n       int i;\n \n       /* Mark the multiple defs within the pattern.  */\n       for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n-\tdf_defs_record (collection_rec, XVECEXP (x, 0, i), bb, insn, flags);\n+\tdf_defs_record (collection_rec, XVECEXP (x, 0, i), bb, insn_info, flags);\n     }\n }\n \n@@ -2888,7 +2890,8 @@ df_defs_record (struct df_collection_rec *collection_rec,\n static void\n df_uses_record (struct df_collection_rec *collection_rec,\n                 rtx *loc, enum df_ref_type ref_type,\n-\t\tbasic_block bb, rtx insn, enum df_ref_flags flags,\n+\t\tbasic_block bb, struct df_insn_info *insn_info,\n+\t\tenum df_ref_flags flags,\n \t\tint width, int offset, enum machine_mode mode)\n {\n   RTX_CODE code;\n@@ -2920,16 +2923,17 @@ df_uses_record (struct df_collection_rec *collection_rec,\n       if (MEM_P (XEXP (x, 0)))\n \tdf_uses_record (collection_rec,\n \t\t\t&XEXP (XEXP (x, 0), 0),\n-\t\t\tDF_REF_REG_MEM_STORE, bb, insn, flags, \n-\t\t\twidth, offset, mode);\n+\t\t\tDF_REF_REG_MEM_STORE,\n+\t\t        bb, insn_info,\n+\t\t\tflags, width, offset, mode);\n \n       /* If we're clobbering a REG then we have a def so ignore.  */\n       return;\n \n     case MEM:\n       df_uses_record (collection_rec,\n \t\t      &XEXP (x, 0), DF_REF_REG_MEM_LOAD, \n-\t\t      bb, insn, flags & DF_REF_IN_NOTE, \n+\t\t      bb, insn_info, flags & DF_REF_IN_NOTE, \n \t\t      width, offset, mode);\n       return;\n \n@@ -2940,15 +2944,16 @@ df_uses_record (struct df_collection_rec *collection_rec,\n       if (!REG_P (SUBREG_REG (x)))\n \t{\n \t  loc = &SUBREG_REG (x);\n-\t  df_uses_record (collection_rec, loc, ref_type, bb, insn, flags, \n+\t  df_uses_record (collection_rec, loc, ref_type, bb, insn_info, flags, \n \t\t\t  width, offset, mode);\n \t  return;\n \t}\n       /* ... Fall through ...  */\n \n     case REG:\n       df_ref_record (collection_rec, \n-\t\t     x, loc, bb, insn, ref_type, flags, \n+\t\t     x, loc, bb, insn_info,\n+\t\t     ref_type, flags, \n \t\t     width, offset, mode);\n       return;\n \n@@ -2971,7 +2976,7 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \t      flags |= DF_REF_SIGN_EXTRACT;\n \n \t    df_uses_record (collection_rec,\n-\t\t\t    &XEXP (x, 0), ref_type, bb, insn, flags, \n+\t\t\t    &XEXP (x, 0), ref_type, bb, insn_info, flags, \n \t\t\t    width, offset, mode);\n \t    return;\n \t  }\n@@ -2983,7 +2988,7 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \trtx dst = SET_DEST (x);\n \tgcc_assert (!(flags & DF_REF_IN_NOTE));\n \tdf_uses_record (collection_rec,\n-\t\t\t&SET_SRC (x), DF_REF_REG_USE, bb, insn, flags, \n+\t\t\t&SET_SRC (x), DF_REF_REG_USE, bb, insn_info, flags, \n \t\t\twidth, offset, mode);\n \n \tswitch (GET_CODE (dst))\n@@ -2992,7 +2997,7 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \t      if (df_read_modify_subreg_p (dst))\n \t\t{\n \t\t  df_uses_record (collection_rec, &SUBREG_REG (dst), \n-\t\t\t\t  DF_REF_REG_USE, bb, insn, \n+\t\t\t\t  DF_REF_REG_USE, bb, insn_info, \n \t\t\t\t  flags | DF_REF_READ_WRITE | DF_REF_SUBREG, \n \t\t\t\t  width, offset, mode);\n \t\t  break;\n@@ -3006,7 +3011,7 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \t\tbreak;\n \t    case MEM:\n \t      df_uses_record (collection_rec, &XEXP (dst, 0),\n-\t\t\t      DF_REF_REG_MEM_STORE, bb, insn, flags, \n+\t\t\t      DF_REF_REG_MEM_STORE, bb, insn_info, flags, \n \t\t\t      width, offset, mode);\n \t      break;\n \t    case STRICT_LOW_PART:\n@@ -3017,7 +3022,7 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \t\tdst = XEXP (dst, 0);\n \t\tdf_uses_record (collection_rec, \n \t\t\t\t(GET_CODE (dst) == SUBREG) ? &SUBREG_REG (dst) : temp, \n-\t\t\t\tDF_REF_REG_USE, bb, insn, \n+\t\t\t\tDF_REF_REG_USE, bb, insn_info,\n \t\t\t\tDF_REF_READ_WRITE | DF_REF_STRICT_LOW_PART, \n \t\t\t\twidth, offset, mode);\n \t      }\n@@ -3034,15 +3039,15 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \t\telse \n \t\t  {\n \t\t    df_uses_record (collection_rec, &XEXP (dst, 1), \n-\t\t\t\t    DF_REF_REG_USE, bb, insn, flags, \n+\t\t\t\t    DF_REF_REG_USE, bb, insn_info, flags, \n \t\t\t\t    width, offset, mode);\n \t\t    df_uses_record (collection_rec, &XEXP (dst, 2), \n-\t\t\t\t    DF_REF_REG_USE, bb, insn, flags, \n+\t\t\t\t    DF_REF_REG_USE, bb, insn_info, flags, \n \t\t\t\t    width, offset, mode);\n \t\t  }\n \n \t\tdf_uses_record (collection_rec, &XEXP (dst, 0), \n-\t\t\t\tDF_REF_REG_USE, bb, insn, \n+\t\t\t\tDF_REF_REG_USE, bb, insn_info, \n \t\t\t\tDF_REF_READ_WRITE | DF_REF_ZERO_EXTRACT, \n \t\t\t\twidth, offset, mode);\n \t      }\n@@ -3094,7 +3099,7 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \n \t    for (j = 0; j < ASM_OPERANDS_INPUT_LENGTH (x); j++)\n \t      df_uses_record (collection_rec, &ASM_OPERANDS_INPUT (x, j),\n-\t\t\t      DF_REF_REG_USE, bb, insn, flags, \n+\t\t\t      DF_REF_REG_USE, bb, insn_info, flags, \n \t\t\t      width, offset, mode);\n \t    return;\n \t  }\n@@ -3108,7 +3113,8 @@ df_uses_record (struct df_collection_rec *collection_rec,\n     case PRE_MODIFY:\n     case POST_MODIFY:\n       /* Catch the def of the register being modified.  */\n-      df_ref_record (collection_rec, XEXP (x, 0), &XEXP (x, 0), bb, insn, \n+      df_ref_record (collection_rec, XEXP (x, 0), &XEXP (x, 0),\n+\t\t     bb, insn_info, \n \t\t     DF_REF_REG_DEF,\n                      flags | DF_REF_READ_WRITE | DF_REF_PRE_POST_MODIFY, \n \t\t     width, offset, mode);\n@@ -3135,7 +3141,7 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \t\tgoto retry;\n \t      }\n \t    df_uses_record (collection_rec, &XEXP (x, i), ref_type, \n-\t\t\t    bb, insn, flags, \n+\t\t\t    bb, insn_info, flags, \n \t\t\t    width, offset, mode);\n \t  }\n \telse if (fmt[i] == 'E')\n@@ -3144,7 +3150,7 @@ df_uses_record (struct df_collection_rec *collection_rec,\n \t    for (j = 0; j < XVECLEN (x, i); j++)\n \t      df_uses_record (collection_rec,\n \t\t\t      &XVECEXP (x, i, j), ref_type, \n-\t\t\t      bb, insn, flags, \n+\t\t\t      bb, insn_info, flags, \n \t\t\t      width, offset, mode);\n \t  }\n       }\n@@ -3179,7 +3185,7 @@ df_get_conditional_uses (struct df_collection_rec *collection_rec)\n \n           use = df_ref_create_structure (collection_rec, DF_REF_REG (ref),\n \t\t\t\t\t DF_REF_LOC (ref), DF_REF_BB (ref),\n-\t\t\t\t\t DF_REF_INSN (ref), DF_REF_REG_USE,\n+\t\t\t\t\t DF_REF_INSN_INFO (ref), DF_REF_REG_USE,\n \t\t\t\t\t DF_REF_FLAGS (ref) & ~DF_REF_CONDITIONAL,\n \t\t\t\t\t width, offset, mode);\n           DF_REF_REGNO (use) = DF_REF_REGNO (ref);\n@@ -3193,7 +3199,7 @@ df_get_conditional_uses (struct df_collection_rec *collection_rec)\n static void\n df_get_call_refs (struct df_collection_rec * collection_rec,\n                   basic_block bb, \n-                  rtx insn,\n+                  struct df_insn_info *insn_info,\n                   enum df_ref_flags flags)\n {\n   rtx note;\n@@ -3214,30 +3220,31 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n \n   /* Record the registers used to pass arguments, and explicitly\n      noted as clobbered.  */\n-  for (note = CALL_INSN_FUNCTION_USAGE (insn); note;\n+  for (note = CALL_INSN_FUNCTION_USAGE (insn_info->insn); note;\n        note = XEXP (note, 1))\n     {\n       if (GET_CODE (XEXP (note, 0)) == USE)\n         df_uses_record (collection_rec, &XEXP (XEXP (note, 0), 0),\n-\t\t\tDF_REF_REG_USE, bb, insn, flags, -1, -1, 0);\n+\t\t\tDF_REF_REG_USE, bb, insn_info, flags, -1, -1, 0);\n       else if (GET_CODE (XEXP (note, 0)) == CLOBBER)\n \t{\n \t  if (REG_P (XEXP (XEXP (note, 0), 0)))\n \t    {\n \t      unsigned int regno = REGNO (XEXP (XEXP (note, 0), 0));\n \t      if (!bitmap_bit_p (defs_generated, regno))\n \t\tdf_defs_record (collection_rec, XEXP (note, 0), bb,\n-\t\t\t\tinsn, flags);\n+\t\t\t\tinsn_info, flags);\n \t    }\n \t  else\n \t    df_uses_record (collection_rec, &XEXP (note, 0),\n-\t\t            DF_REF_REG_USE, bb, insn, flags, -1, -1, 0);\n+\t\t            DF_REF_REG_USE, bb, insn_info, flags, -1, -1, 0);\n \t}\n     }\n \n   /* The stack ptr is used (honorarily) by a CALL insn.  */\n   df_ref_record (collection_rec, regno_reg_rtx[STACK_POINTER_REGNUM],\n-\t\t NULL, bb, insn, DF_REF_REG_USE, DF_REF_CALL_STACK_USAGE | flags, \n+\t\t NULL, bb, insn_info, DF_REF_REG_USE,\n+\t\t DF_REF_CALL_STACK_USAGE | flags, \n \t\t -1, -1, 0);\n \n   /* Calls may also reference any of the global registers,\n@@ -3246,12 +3253,12 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n     if (global_regs[i])\n       {\n \tdf_ref_record (collection_rec, regno_reg_rtx[i],\n-\t\t       NULL, bb, insn, DF_REF_REG_USE, flags, -1, -1, 0);\n+\t\t       NULL, bb, insn_info, DF_REF_REG_USE, flags, -1, -1, 0);\n \tdf_ref_record (collection_rec, regno_reg_rtx[i],\n-\t\t       NULL, bb, insn, DF_REF_REG_DEF, flags, -1, -1, 0);\n+\t\t       NULL, bb, insn_info, DF_REF_REG_DEF, flags, -1, -1, 0);\n       }\n \n-  is_sibling_call = SIBLING_CALL_P (insn);\n+  is_sibling_call = SIBLING_CALL_P (insn_info->insn);\n   EXECUTE_IF_SET_IN_BITMAP (df_invalidated_by_call, 0, ui, bi)\n     {\n       if (!global_regs[ui]\n@@ -3261,7 +3268,8 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n \t      || refers_to_regno_p (ui, ui+1, \n \t\t\t\t    crtl->return_rtx, NULL)))\n         df_ref_record (collection_rec, regno_reg_rtx[ui], \n-\t\t       NULL, bb, insn, DF_REF_REG_DEF, DF_REF_MAY_CLOBBER | flags, \n+\t\t       NULL, bb, insn_info, DF_REF_REG_DEF,\n+\t\t       DF_REF_MAY_CLOBBER | flags, \n \t\t       -1, -1, 0);\n     }\n \n@@ -3276,10 +3284,10 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n \n static void\n df_insn_refs_collect (struct df_collection_rec* collection_rec, \n-\t\t      basic_block bb, rtx insn) \n+\t\t      basic_block bb, struct df_insn_info *insn_info) \n {\n   rtx note;\n-  bool is_cond_exec = (GET_CODE (PATTERN (insn)) == COND_EXEC);\n+  bool is_cond_exec = (GET_CODE (PATTERN (insn_info->insn)) == COND_EXEC);\n \n   /* Clear out the collection record.  */\n   collection_rec->next_def = 0;\n@@ -3288,10 +3296,10 @@ df_insn_refs_collect (struct df_collection_rec* collection_rec,\n   collection_rec->next_mw = 0;\n \n   /* Record register defs.  */\n-  df_defs_record (collection_rec, PATTERN (insn), bb, insn, 0);\n+  df_defs_record (collection_rec, PATTERN (insn_info->insn), bb, insn_info, 0);\n \n-  /* Process REG_EQUIV/REG_EQUAL notes */\n-  for (note = REG_NOTES (insn); note;\n+  /* Process REG_EQUIV/REG_EQUAL notes.  */\n+  for (note = REG_NOTES (insn_info->insn); note;\n        note = XEXP (note, 1))\n     {\n       switch (REG_NOTE_KIND (note))\n@@ -3300,20 +3308,18 @@ df_insn_refs_collect (struct df_collection_rec* collection_rec,\n         case REG_EQUAL:\n           df_uses_record (collection_rec,\n                           &XEXP (note, 0), DF_REF_REG_USE,\n-                          bb, insn, DF_REF_IN_NOTE, -1, -1, 0);\n+                          bb, insn_info, DF_REF_IN_NOTE, -1, -1, 0);\n           break;\n         case REG_NON_LOCAL_GOTO:\n           /* The frame ptr is used by a non-local goto.  */\n           df_ref_record (collection_rec,\n                          regno_reg_rtx[FRAME_POINTER_REGNUM],\n-                         NULL,\n-                         bb, insn, \n+                         NULL, bb, insn_info,\n                          DF_REF_REG_USE, 0, -1, -1, 0);\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n           df_ref_record (collection_rec,\n                          regno_reg_rtx[HARD_FRAME_POINTER_REGNUM],\n-                         NULL,\n-                         bb, insn, \n+                         NULL, bb, insn_info,\n                          DF_REF_REG_USE, 0, -1, -1, 0);\n #endif\n           break;\n@@ -3322,13 +3328,13 @@ df_insn_refs_collect (struct df_collection_rec* collection_rec,\n         }\n     }\n \n-  if (CALL_P (insn))\n-    df_get_call_refs (collection_rec, bb, insn, \n+  if (CALL_P (insn_info->insn))\n+    df_get_call_refs (collection_rec, bb, insn_info, \n \t\t      (is_cond_exec) ? DF_REF_CONDITIONAL : 0);\n \n   /* Record the register uses.  */\n   df_uses_record (collection_rec,\n-\t\t  &PATTERN (insn), DF_REF_REG_USE, bb, insn, 0, \n+\t\t  &PATTERN (insn_info->insn), DF_REF_REG_USE, bb, insn_info, 0, \n \t\t  -1, -1, 0);\n \n   /* DF_REF_CONDITIONAL needs corresponding USES. */\n@@ -3351,16 +3357,16 @@ df_recompute_luids (basic_block bb)\n   /* Scan the block an insn at a time from beginning to end.  */\n   FOR_BB_INSNS (bb, insn)\n     {\n-      struct df_insn_info *insn_info = DF_INSN_GET (insn);\n+      struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n       /* Inserting labels does not always trigger the incremental\n \t rescanning.  */\n       if (!insn_info)\n \t{\n \t  gcc_assert (!INSN_P (insn));\n-\t  df_insn_create_insn_record (insn);\n+\t  insn_info = df_insn_create_insn_record (insn);\n \t}\n \n-      DF_INSN_LUID (insn) = luid;\n+      DF_INSN_INFO_LUID (insn_info) = luid;\n       if (INSN_P (insn))\n \tluid++;\n     }\n@@ -3499,18 +3505,18 @@ df_bb_refs_record (int bb_index, bool scan_insns)\n     /* Scan the block an insn at a time from beginning to end.  */\n     FOR_BB_INSNS (bb, insn)\n       {\n-\tstruct df_insn_info *insn_info = DF_INSN_GET (insn);\n+\tstruct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n \tgcc_assert (!insn_info);\n \n-\tdf_insn_create_insn_record (insn);\n+\tinsn_info = df_insn_create_insn_record (insn);\n \tif (INSN_P (insn))\n \t  {\n \t    /* Record refs within INSN.  */\n-\t    DF_INSN_LUID (insn) = luid++;\n-\t    df_insn_refs_collect (&collection_rec, bb, insn);\n+\t    DF_INSN_INFO_LUID (insn_info) = luid++;\n+\t    df_insn_refs_collect (&collection_rec, bb, DF_INSN_INFO_GET (insn));\n \t    df_refs_add_to_chains (&collection_rec, bb, insn);\n \t  }\n-\tDF_INSN_LUID (insn) = luid;\n+\tDF_INSN_INFO_LUID (insn_info) = luid;\n       }\n \n   /* Other block level artificial refs */\n@@ -4272,8 +4278,9 @@ df_insn_refs_verify (struct df_collection_rec *collection_rec,\n {\n   bool ret1, ret2, ret3, ret4;\n   unsigned int uid = INSN_UID (insn);\n+  struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n \n-  df_insn_refs_collect (collection_rec, bb, insn);\n+  df_insn_refs_collect (collection_rec, bb, insn_info);\n \n   if (!DF_INSN_UID_DEFS (uid))\n     {"}, {"sha": "30e98507d41771467aaa4d38a367892d3a4c4358", "filename": "gcc/df.h", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e94c7e583d2be25b1f940923fa01203aac65c3/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e94c7e583d2be25b1f940923fa01203aac65c3/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=50e94c7e583d2be25b1f940923fa01203aac65c3", "patch": "@@ -370,9 +370,10 @@ struct df_ref\n   rtx reg;\t\t\t/* The register referenced.  */\n   basic_block bb;               /* Basic block containing the instruction. */\n \n-  /* Insn containing ref. This will be null if this is an artificial\n-     reference.  */\n-  rtx insn;\n+  /* Insn info for the insn containing ref. This will be null if this is\n+     an artificial reference.  */\n+  struct df_insn_info *insn_info;\n+\n   rtx *loc;\t\t\t/* The location of the reg.  */\n   struct df_link *chain;\t/* Head of def-use, use-def.  */\n   /* Location in the ref table.  This is only valid after a call to \n@@ -612,8 +613,9 @@ struct df\n #define DF_REF_LOC(REF) ((REF)->loc)\n #define DF_REF_BB(REF) ((REF)->bb)\n #define DF_REF_BBNO(REF) (DF_REF_BB (REF)->index)\n-#define DF_REF_INSN(REF) ((REF)->insn)\n-#define DF_REF_INSN_UID(REF) (INSN_UID ((REF)->insn))\n+#define DF_REF_INSN_INFO(REF) ((REF)->insn_info)\n+#define DF_REF_INSN(REF) ((REF)->insn_info->insn)\n+#define DF_REF_INSN_UID(REF) (INSN_UID (DF_REF_INSN(REF)))\n #define DF_REF_TYPE(REF) ((REF)->type)\n #define DF_REF_CHAIN(REF) ((REF)->chain)\n #define DF_REF_ID(REF) ((REF)->id)\n@@ -626,7 +628,7 @@ struct df\n    but an artificial one created to model \n    always live registers, eh uses, etc.  \n    ARTIFICIAL refs has NULL insn.  */\n-#define DF_REF_IS_ARTIFICIAL(REF) ((REF)->insn == NULL)\n+#define DF_REF_IS_ARTIFICIAL(REF) ((REF)->insn_info == NULL)\n #define DF_REF_REG_MARK(REF) (DF_REF_FLAGS_SET ((REF),DF_REF_REG_MARKER))\n #define DF_REF_REG_UNMARK(REF) (DF_REF_FLAGS_CLEAR ((REF),DF_REF_REG_MARKER))\n #define DF_REF_IS_REG_MARKED(REF) (DF_REF_FLAGS_IS_SET ((REF),DF_REF_REG_MARKER))\n@@ -691,12 +693,17 @@ struct df\n /* Macros to access the elements within the insn_info structure table.  */\n \n #define DF_INSN_SIZE() ((df)->insns_size)\n-#define DF_INSN_GET(INSN) (df->insns[(INSN_UID(INSN))])\n-#define DF_INSN_SET(INSN,VAL) (df->insns[(INSN_UID (INSN))]=(VAL))\n-#define DF_INSN_LUID(INSN) (DF_INSN_GET(INSN)->luid)\n-#define DF_INSN_DEFS(INSN) (DF_INSN_GET(INSN)->defs)\n-#define DF_INSN_USES(INSN) (DF_INSN_GET(INSN)->uses)\n-#define DF_INSN_EQ_USES(INSN) (DF_INSN_GET(INSN)->eq_uses)\n+#define DF_INSN_INFO_GET(INSN) (df->insns[(INSN_UID(INSN))])\n+#define DF_INSN_INFO_SET(INSN,VAL) (df->insns[(INSN_UID (INSN))]=(VAL))\n+#define DF_INSN_INFO_LUID(II) ((II)->luid)\n+#define DF_INSN_INFO_DEFS(II) ((II)->defs)\n+#define DF_INSN_INFO_USES(II) ((II)->uses)\n+#define DF_INSN_INFO_EQ_USES(II) ((II)->eq_uses)\n+\n+#define DF_INSN_LUID(INSN) (DF_INSN_INFO_LUID (DF_INSN_INFO_GET(INSN)))\n+#define DF_INSN_DEFS(INSN) (DF_INSN_INFO_DEFS (DF_INSN_INFO_GET(INSN)))\n+#define DF_INSN_USES(INSN) (DF_INSN_INFO_USES (DF_INSN_INFO_GET(INSN)))\n+#define DF_INSN_EQ_USES(INSN) (DF_INSN_INFO_EQ_USES (DF_INSN_INFO_GET(INSN)))\n \n #define DF_INSN_UID_GET(UID) (df->insns[(UID)])\n #define DF_INSN_UID_SET(UID,VAL) (df->insns[(UID)]=(VAL))"}, {"sha": "a901a17b2a37e6ed55824b28e378e5f9d31451fe", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e94c7e583d2be25b1f940923fa01203aac65c3/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e94c7e583d2be25b1f940923fa01203aac65c3/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=50e94c7e583d2be25b1f940923fa01203aac65c3", "patch": "@@ -2018,14 +2018,6 @@ The construct @code{(mem:BLK (scratch))} is considered to alias all\n other memories.  Thus it may be used as a memory barrier in epilogue\n stack deallocation patterns.\n \n-@findex addressof\n-@item (addressof:@var{m} @var{reg})\n-This RTX represents a request for the address of register @var{reg}.  Its mode\n-is always @code{Pmode}.  If there are any @code{addressof}\n-expressions left in the function after CSE, @var{reg} is forced into the\n-stack and the @code{addressof} expression is replaced with a @code{plus}\n-expression for the address of its stack slot.\n-\n @findex concat\n @item (concat@var{m} @var{rtx} @var{rtx})\n This RTX represents the concatenation of two other RTXs.  This is used"}, {"sha": "6456b0eae029be0ca0793fbb9999f9f600f9ff5e", "filename": "gcc/fwprop.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e94c7e583d2be25b1f940923fa01203aac65c3/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e94c7e583d2be25b1f940923fa01203aac65c3/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=50e94c7e583d2be25b1f940923fa01203aac65c3", "patch": "@@ -546,13 +546,13 @@ use_killed_between (struct df_ref *use, rtx def_insn, rtx target_insn)\n       /* See if USE is killed between DEF_INSN and the last insn in the\n \t basic block containing DEF_INSN.  */\n       x = df_bb_regno_last_def_find (def_bb, regno);\n-      if (x && DF_INSN_LUID (x->insn) >= DF_INSN_LUID (def_insn))\n+      if (x && DF_INSN_LUID (DF_REF_INSN (x)) >= DF_INSN_LUID (def_insn))\n \treturn true;\n \n       /* See if USE is killed between TARGET_INSN and the first insn in the\n \t basic block containing TARGET_INSN.  */\n       x = df_bb_regno_first_def_find (target_bb, regno);\n-      if (x && DF_INSN_LUID (x->insn) < DF_INSN_LUID (target_insn))\n+      if (x && DF_INSN_LUID (DF_REF_INSN (x)) < DF_INSN_LUID (target_insn))\n \treturn true;\n \n       return false;\n@@ -570,6 +570,7 @@ static bool\n all_uses_available_at (rtx def_insn, rtx target_insn)\n {\n   struct df_ref **use_rec;\n+  struct df_insn_info *insn_info = DF_INSN_INFO_GET (def_insn);\n   rtx def_set = single_set (def_insn);\n \n   gcc_assert (def_set);\n@@ -583,13 +584,13 @@ all_uses_available_at (rtx def_insn, rtx target_insn)\n \n       /* If the insn uses the reg that it defines, the substitution is\n          invalid.  */\n-      for (use_rec = DF_INSN_USES (def_insn); *use_rec; use_rec++)\n+      for (use_rec = DF_INSN_INFO_USES (insn_info); *use_rec; use_rec++)\n \t{\n \t  struct df_ref *use = *use_rec;\n \t  if (rtx_equal_p (DF_REF_REG (use), def_reg))\n \t    return false;\n \t}\n-      for (use_rec = DF_INSN_EQ_USES (def_insn); *use_rec; use_rec++)\n+      for (use_rec = DF_INSN_INFO_EQ_USES (insn_info); *use_rec; use_rec++)\n \t{\n \t  struct df_ref *use = *use_rec;\n \t  if (rtx_equal_p (use->reg, def_reg))\n@@ -600,13 +601,13 @@ all_uses_available_at (rtx def_insn, rtx target_insn)\n     {\n       /* Look at all the uses of DEF_INSN, and see if they are not\n \t killed between DEF_INSN and TARGET_INSN.  */\n-      for (use_rec = DF_INSN_USES (def_insn); *use_rec; use_rec++)\n+      for (use_rec = DF_INSN_INFO_USES (insn_info); *use_rec; use_rec++)\n \t{\n \t  struct df_ref *use = *use_rec;\n \t  if (use_killed_between (use, def_insn, target_insn))\n \t    return false;\n \t}\n-      for (use_rec = DF_INSN_EQ_USES (def_insn); *use_rec; use_rec++)\n+      for (use_rec = DF_INSN_INFO_EQ_USES (insn_info); *use_rec; use_rec++)\n \t{\n \t  struct df_ref *use = *use_rec;\n \t  if (use_killed_between (use, def_insn, target_insn))\n@@ -767,8 +768,9 @@ try_fwprop_subst (struct df_ref *use, rtx *loc, rtx new, rtx def_insn, bool set_\n       df_ref_remove (use);\n       if (!CONSTANT_P (new))\n \t{\n-\t  update_df (insn, loc, DF_INSN_USES (def_insn), type, flags);\n-\t  update_df (insn, loc, DF_INSN_EQ_USES (def_insn), type, flags);\n+\t  struct df_insn_info *insn_info = DF_INSN_INFO_GET (def_insn);\n+\t  update_df (insn, loc, DF_INSN_INFO_USES (insn_info), type, flags);\n+\t  update_df (insn, loc, DF_INSN_INFO_EQ_USES (insn_info), type, flags);\n \t}\n     }\n   else\n@@ -788,9 +790,10 @@ try_fwprop_subst (struct df_ref *use, rtx *loc, rtx new, rtx def_insn, bool set_\n \t     set_unique_reg_note?  */\n           if (!CONSTANT_P (new))\n \t    {\n-\t      update_df (insn, loc, DF_INSN_USES (def_insn),\n+\t      struct df_insn_info *insn_info = DF_INSN_INFO_GET (def_insn);\n+\t      update_df (insn, loc, DF_INSN_INFO_USES (insn_info),\n \t\t\t type, DF_REF_IN_NOTE);\n-\t      update_df (insn, loc, DF_INSN_EQ_USES (def_insn),\n+\t      update_df (insn, loc, DF_INSN_INFO_EQ_USES (insn_info),\n \t\t\t type, DF_REF_IN_NOTE);\n \t    }\n \t}"}, {"sha": "dd75b3a3a8f77eafa7450fb5939e887488284fbc", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e94c7e583d2be25b1f940923fa01203aac65c3/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e94c7e583d2be25b1f940923fa01203aac65c3/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=50e94c7e583d2be25b1f940923fa01203aac65c3", "patch": "@@ -248,7 +248,7 @@ invariant_for_use (struct df_ref *use)\n {\n   struct df_link *defs;\n   struct df_ref *def;\n-  basic_block bb = BLOCK_FOR_INSN (use->insn), def_bb;\n+  basic_block bb = DF_REF_BB (use), def_bb;\n \n   if (use->flags & DF_REF_READ_WRITE)\n     return NULL;\n@@ -768,13 +768,14 @@ check_dependency (basic_block bb, struct df_ref *use, bitmap depends_on)\n static bool\n check_dependencies (rtx insn, bitmap depends_on)\n {\n+  struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n   struct df_ref **use_rec;\n   basic_block bb = BLOCK_FOR_INSN (insn);\n \n-  for (use_rec = DF_INSN_USES (insn); *use_rec; use_rec++)\n+  for (use_rec = DF_INSN_INFO_USES (insn_info); *use_rec; use_rec++)\n     if (!check_dependency (bb, *use_rec, depends_on))\n       return false;\n-  for (use_rec = DF_INSN_EQ_USES (insn); *use_rec; use_rec++)\n+  for (use_rec = DF_INSN_INFO_EQ_USES (insn_info); *use_rec; use_rec++)\n     if (!check_dependency (bb, *use_rec, depends_on))\n       return false;\n \t\n@@ -850,17 +851,18 @@ find_invariant_insn (rtx insn, bool always_reached, bool always_executed)\n static void\n record_uses (rtx insn)\n {\n+  struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n   struct df_ref **use_rec;\n   struct invariant *inv;\n \n-  for (use_rec = DF_INSN_USES (insn); *use_rec; use_rec++)\n+  for (use_rec = DF_INSN_INFO_USES (insn_info); *use_rec; use_rec++)\n     {\n       struct df_ref *use = *use_rec;\n       inv = invariant_for_use (use);\n       if (inv)\n \trecord_use (inv->def, DF_REF_REAL_LOC (use), DF_REF_INSN (use));\n     }\n-  for (use_rec = DF_INSN_EQ_USES (insn); *use_rec; use_rec++)\n+  for (use_rec = DF_INSN_INFO_EQ_USES (insn_info); *use_rec; use_rec++)\n     {\n       struct df_ref *use = *use_rec;\n       inv = invariant_for_use (use);"}, {"sha": "d04e8a228907404897595ac490cb892be55e3ce1", "filename": "gcc/web.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50e94c7e583d2be25b1f940923fa01203aac65c3/gcc%2Fweb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50e94c7e583d2be25b1f940923fa01203aac65c3/gcc%2Fweb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fweb.c?ref=50e94c7e583d2be25b1f940923fa01203aac65c3", "patch": "@@ -105,22 +105,24 @@ union_defs (struct df_ref *use, struct web_entry *def_entry,\n  \t    struct web_entry *use_entry,\n  \t    bool (*fun) (struct web_entry *, struct web_entry *))\n {\n-  rtx insn = DF_REF_INSN (use);\n+  struct df_insn_info *insn_info = DF_REF_INSN_INFO (use);\n   struct df_link *link = DF_REF_CHAIN (use);\n   struct df_ref **use_link;\n   struct df_ref **eq_use_link;\n   struct df_ref **def_link;\n   rtx set;\n \n-  if (insn)\n+  if (insn_info)\n     {\n-      use_link = DF_INSN_USES (insn);\n-      eq_use_link = DF_INSN_EQ_USES (insn);\n-      def_link = DF_INSN_DEFS (insn);\n+      rtx insn = insn_info->insn;\n+      use_link = DF_INSN_INFO_USES (insn_info);\n+      eq_use_link = DF_INSN_INFO_EQ_USES (insn_info);\n+      def_link = DF_INSN_INFO_DEFS (insn_info);\n       set = single_set (insn);\n     }\n   else\n     {\n+      /* An artificial use.  It links up with nothing.  */\n       use_link = NULL;\n       eq_use_link = NULL;\n       def_link = NULL;\n@@ -180,8 +182,8 @@ union_defs (struct df_ref *use, struct web_entry *def_entry,\n     {\n       struct df_ref **link;\n \n-      if (DF_REF_INSN (use))\n-\tlink = DF_INSN_DEFS (DF_REF_INSN (use));\n+      if (insn_info)\n+\tlink = DF_INSN_INFO_DEFS (insn_info);\n       else\n \tlink = NULL;\n "}]}