{"sha": "56b3408df261966f5c2ce01171f471cf298d21ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZiMzQwOGRmMjYxOTY2ZjVjMmNlMDExNzFmNDcxY2YyOThkMjFhYw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-07-20T13:28:26Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-07-20T13:28:26Z"}, "message": "(output_bound_representation): Treat default case as variable bounds,\n\nthen look inside for SAVE_EXPR.\n\nFrom-SVN: r12543", "tree": {"sha": "fc324a030c3fa8b4bbbee9d3289c347d2b362d6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc324a030c3fa8b4bbbee9d3289c347d2b362d6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56b3408df261966f5c2ce01171f471cf298d21ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56b3408df261966f5c2ce01171f471cf298d21ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56b3408df261966f5c2ce01171f471cf298d21ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56b3408df261966f5c2ce01171f471cf298d21ac/comments", "author": null, "committer": null, "parents": [{"sha": "653b32a67042e48e7ed43a32e26a52bd314f4104", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/653b32a67042e48e7ed43a32e26a52bd314f4104", "html_url": "https://github.com/Rust-GCC/gccrs/commit/653b32a67042e48e7ed43a32e26a52bd314f4104"}], "stats": {"total": 124, "additions": 59, "deletions": 65}, "files": [{"sha": "987a653c7bdf239d38fbb016cf4da35b6746d5e0", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 59, "deletions": 65, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b3408df261966f5c2ce01171f471cf298d21ac/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b3408df261966f5c2ce01171f471cf298d21ac/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=56b3408df261966f5c2ce01171f471cf298d21ac", "patch": "@@ -1722,79 +1722,73 @@ output_bound_representation (bound, dim_num, u_or_l)\n   switch (TREE_CODE (bound))\n     {\n \n-      case ERROR_MARK:\n-\treturn;\n+    case ERROR_MARK:\n+      return;\n \n       /* All fixed-bounds are represented by INTEGER_CST nodes.\t */\n \n-      case INTEGER_CST:\n-\tASM_OUTPUT_DWARF_DATA4 (asm_out_file,\n-\t\t\t\t(unsigned) TREE_INT_CST_LOW (bound));\n-\tbreak;\n-\n-      /* Dynamic bounds may be represented by NOP_EXPR nodes containing\n-\t SAVE_EXPR nodes.  */\n-\n-      case NOP_EXPR:\n-\tbound = TREE_OPERAND (bound, 0);\n-\t/* ... fall thru...  */\n-\n-      case SAVE_EXPR:\n-\t{\n-\t  char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n-\t  char end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n-\n-\t  sprintf (begin_label, BOUND_BEGIN_LABEL_FMT,\n-\t\t\t\tcurrent_dienum, dim_num, u_or_l);\n-\n-\t  sprintf (end_label,\tBOUND_END_LABEL_FMT,\n-\t\t\t\tcurrent_dienum, dim_num, u_or_l);\n-\n-\t  ASM_OUTPUT_DWARF_DELTA2 (asm_out_file, end_label, begin_label);\n-\t  ASM_OUTPUT_LABEL (asm_out_file, begin_label);\n-\n-\t  /* If we are working on a bound for a dynamic dimension in C,\n-\t     the dynamic dimension in question had better have a static\n-\t     (zero) lower bound and a dynamic *upper* bound.  */\n+    case INTEGER_CST:\n+      ASM_OUTPUT_DWARF_DATA4 (asm_out_file,\n+\t\t\t      (unsigned) TREE_INT_CST_LOW (bound));\n+      break;\n \n-\t  if (u_or_l != 'u')\n-\t    abort ();\n+    default:\n \n-\t  /* If optimization is turned on, the SAVE_EXPRs that describe\n-\t     how to access the upper bound values are essentially bogus.\n-\t     They only describe (at best) how to get at these values at\n-\t     the points in the generated code right after they have just\n-\t     been computed.  Worse yet, in the typical case, the upper\n-\t     bound values will not even *be* computed in the optimized\n-\t     code, so these SAVE_EXPRs are entirely bogus.\n-\n-\t     In order to compensate for this fact, we check here to see\n-\t     if optimization is enabled, and if so, we effectively create\n-\t     an empty location description for the (unknown and unknowable)\n-\t     upper bound.\n-\n-\t     This should not cause too much trouble for existing (stupid?)\n-\t     debuggers because they have to deal with empty upper bounds\n-\t     location descriptions anyway in order to be able to deal with\n-\t     incomplete array types.\n-\n-\t     Of course an intelligent debugger (GDB?) should be able to\n-\t     comprehend that a missing upper bound specification in a\n-\t     array type used for a storage class `auto' local array variable\n-\t     indicates that the upper bound is both unknown (at compile-\n-\t     time) and unknowable (at run-time) due to optimization.\n-\t  */\n+      /* Dynamic bounds may be represented by NOP_EXPR nodes containing\n+\t SAVE_EXPR nodes, in which case we can do something, or as\n+\t an expression, which we cannot represent.  */\n+      {\n+\tchar begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n+\tchar end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n+\n+\tsprintf (begin_label, BOUND_BEGIN_LABEL_FMT,\n+\t\t current_dienum, dim_num, u_or_l);\n+\n+\tsprintf (end_label, BOUND_END_LABEL_FMT,\n+\t\t current_dienum, dim_num, u_or_l);\n+\n+\tASM_OUTPUT_DWARF_DELTA2 (asm_out_file, end_label, begin_label);\n+\tASM_OUTPUT_LABEL (asm_out_file, begin_label);\n+\n+\t/* If optimization is turned on, the SAVE_EXPRs that describe\n+\t   how to access the upper bound values are essentially bogus.\n+\t   They only describe (at best) how to get at these values at\n+\t   the points in the generated code right after they have just\n+\t   been computed.  Worse yet, in the typical case, the upper\n+\t   bound values will not even *be* computed in the optimized\n+\t   code, so these SAVE_EXPRs are entirely bogus.\n+\n+\t   In order to compensate for this fact, we check here to see\n+\t   if optimization is enabled, and if so, we effectively create\n+\t   an empty location description for the (unknown and unknowable)\n+\t   upper bound.\n+\n+\t   This should not cause too much trouble for existing (stupid?)\n+\t   debuggers because they have to deal with empty upper bounds\n+\t   location descriptions anyway in order to be able to deal with\n+\t   incomplete array types.\n+\n+\t   Of course an intelligent debugger (GDB?) should be able to\n+\t   comprehend that a missing upper bound specification in a\n+\t   array type used for a storage class `auto' local array variable\n+\t   indicates that the upper bound is both unknown (at compile-\n+\t   time) and unknowable (at run-time) due to optimization. */\n+\n+\tif (! optimize)\n+\t  {\n+\t    while (TREE_CODE (bound) == NOP_EXPR\n+\t\t   || TREE_CODE (bound) == CONVERT_EXPR)\n+\t      bound = TREE_OPERAND (bound, 0);\n \n-\t  if (! optimize)\n-\t    output_loc_descriptor\n-\t      (eliminate_regs (SAVE_EXPR_RTL (bound), 0, NULL_RTX));\n+\t    if (TREE_CODE (bound) == SAVE_EXPR_RTL)\n+\t      output_loc_descriptor\n+\t\t(eliminate_regs (SAVE_EXPR_RTL (bound), 0, NULL_RTX));\n+\t  }\n \n-\t  ASM_OUTPUT_LABEL (asm_out_file, end_label);\n-\t}\n-\tbreak;\n+\tASM_OUTPUT_LABEL (asm_out_file, end_label);\n+      }\n+      break;\n \n-      default:\n-\tabort ();\n     }\n }\n "}]}