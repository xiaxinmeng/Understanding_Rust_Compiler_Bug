{"sha": "edaaef601d0d6d263fba87b42d6d04c99dd23dba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWRhYWVmNjAxZDBkNmQyNjNmYmE4N2I0MmQ2ZDA0Yzk5ZGQyM2RiYQ==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2018-09-21T18:12:59Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2018-09-21T18:12:59Z"}, "message": "Use vectored writes when reporting errors and warnings.\n\nWhen producing error and warning messages, libgfortran writes a\nmessage by using many system calls.  By using vectored writes (the\nPOSIX writev function) when available and feasible to use without\nmajor surgery, we reduce the chance that output gets intermingled with\nother output to stderr.\n\nIn practice, this is done by introducing a new function estr_writev in\naddition to the existing estr_write.  In order to use this, the old\nst_vprintf is removed, replaced by direct calls of vsnprintf, allowing\nmore message batching.\n\nRegtested on x86_64-pc-linux-gnu.\n\nlibgfortran/ChangeLog:\n\n2018-09-21  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\t* config.h.in: Regenerated.\n\t* configure: Regenerated.\n\t* configure.ac: Check for writev and sys/uio.h.\n\t* libgfortran.h: Include sys/uio.h.\n\t(st_vprintf): Remove prototype.\n\t(struct iovec): Define if not available.\n\t(estr_writev): New prototype.\n\t* runtime/backtrace.c (error_callback): Use estr_writev.\n\t* runtime/error.c (ST_VPRINTF_SIZE): Remove.\n\t(estr_writev): New function.\n\t(st_vprintf): Remove.\n\t(gf_vsnprintf): New function.\n\t(ST_ERRBUF_SIZE): New macro.\n\t(st_printf): Use vsnprintf.\n\t(os_error): Use estr_writev.\n\t(runtime_error): Use vsnprintf and estr_writev.\n\t(runtime_error_at): Likewise.\n\t(runtime_warning_at): Likewise.\n\t(internal_error): Use estr_writev.\n\t(generate_error_common): Likewise.\n\t(generate_warning): Likewise.\n\t(notify_std): Likewise.\n\t* runtime/pause.c (pause_string): Likewise.\n\t* runtime/stop.c (report_exception): Likewise.\n\t(stop_string): Likewise.\n\t(error_stop_string): Likewise.\n\nFrom-SVN: r264487", "tree": {"sha": "1eae37a9045b327759b9ea32319467c34314ddb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1eae37a9045b327759b9ea32319467c34314ddb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/edaaef601d0d6d263fba87b42d6d04c99dd23dba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edaaef601d0d6d263fba87b42d6d04c99dd23dba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edaaef601d0d6d263fba87b42d6d04c99dd23dba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edaaef601d0d6d263fba87b42d6d04c99dd23dba/comments", "author": null, "committer": null, "parents": [{"sha": "5b4dd0158308d1a3effffd6316f1b39fdd1ad120", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b4dd0158308d1a3effffd6316f1b39fdd1ad120", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b4dd0158308d1a3effffd6316f1b39fdd1ad120"}], "stats": {"total": 364, "additions": 279, "deletions": 85}, "files": [{"sha": "d74474066157cde1a1360e043f09bbfa707f95e2", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edaaef601d0d6d263fba87b42d6d04c99dd23dba/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edaaef601d0d6d263fba87b42d6d04c99dd23dba/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=edaaef601d0d6d263fba87b42d6d04c99dd23dba", "patch": "@@ -1,3 +1,32 @@\n+2018-09-21  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\t* config.h.in: Regenerated.\n+\t* configure: Regenerated.\n+\t* configure.ac: Check for writev and sys/uio.h.\n+\t* libgfortran.h: Include sys/uio.h.\n+\t(st_vprintf): Remove prototype.\n+\t(struct iovec): Define if not available.\n+\t(estr_writev): New prototype.\n+\t* runtime/backtrace.c (error_callback): Use estr_writev.\n+\t* runtime/error.c (ST_VPRINTF_SIZE): Remove.\n+\t(estr_writev): New function.\n+\t(st_vprintf): Remove.\n+\t(gf_vsnprintf): New function.\n+\t(ST_ERRBUF_SIZE): New macro.\n+\t(st_printf): Use vsnprintf.\n+\t(os_error): Use estr_writev.\n+\t(runtime_error): Use vsnprintf and estr_writev.\n+\t(runtime_error_at): Likewise.\n+\t(runtime_warning_at): Likewise.\n+\t(internal_error): Use estr_writev.\n+\t(generate_error_common): Likewise.\n+\t(generate_warning): Likewise.\n+\t(notify_std): Likewise.\n+\t* runtime/pause.c (pause_string): Likewise.\n+\t* runtime/stop.c (report_exception): Likewise.\n+\t(stop_string): Likewise.\n+\t(error_stop_string): Likewise.\n+\n 2018-09-16  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/37802"}, {"sha": "c7f47146030b142aa7e2f63dd8b4ec7c3a53bd52", "filename": "libgfortran/config.h.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edaaef601d0d6d263fba87b42d6d04c99dd23dba/libgfortran%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edaaef601d0d6d263fba87b42d6d04c99dd23dba/libgfortran%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfig.h.in?ref=edaaef601d0d6d263fba87b42d6d04c99dd23dba", "patch": "@@ -762,6 +762,9 @@\n /* Define to 1 if you have the <sys/types.h> header file. */\n #undef HAVE_SYS_TYPES_H\n \n+/* Define to 1 if you have the <sys/uio.h> header file. */\n+#undef HAVE_SYS_UIO_H\n+\n /* Define to 1 if you have the <sys/wait.h> header file. */\n #undef HAVE_SYS_WAIT_H\n \n@@ -828,6 +831,9 @@\n /* Define if target has a reliable stat. */\n #undef HAVE_WORKING_STAT\n \n+/* Define to 1 if you have the `writev' function. */\n+#undef HAVE_WRITEV\n+\n /* Define to 1 if you have the <xlocale.h> header file. */\n #undef HAVE_XLOCALE_H\n "}, {"sha": "1c93683acd27a80f5f3843bad463a22d0c6a5a23", "filename": "libgfortran/configure", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edaaef601d0d6d263fba87b42d6d04c99dd23dba/libgfortran%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edaaef601d0d6d263fba87b42d6d04c99dd23dba/libgfortran%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure?ref=edaaef601d0d6d263fba87b42d6d04c99dd23dba", "patch": "@@ -2553,6 +2553,7 @@ as_fn_append ac_header_list \" sys/times.h\"\n as_fn_append ac_header_list \" sys/resource.h\"\n as_fn_append ac_header_list \" sys/types.h\"\n as_fn_append ac_header_list \" sys/stat.h\"\n+as_fn_append ac_header_list \" sys/uio.h\"\n as_fn_append ac_header_list \" sys/wait.h\"\n as_fn_append ac_header_list \" floatingpoint.h\"\n as_fn_append ac_header_list \" ieeefp.h\"\n@@ -2584,6 +2585,7 @@ as_fn_append ac_func_list \" access\"\n as_fn_append ac_func_list \" fork\"\n as_fn_append ac_func_list \" setmode\"\n as_fn_append ac_func_list \" fcntl\"\n+as_fn_append ac_func_list \" writev\"\n as_fn_append ac_func_list \" gettimeofday\"\n as_fn_append ac_func_list \" stat\"\n as_fn_append ac_func_list \" fstat\"\n@@ -12514,7 +12516,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 12517 \"configure\"\n+#line 12519 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -12620,7 +12622,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 12623 \"configure\"\n+#line 12625 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -16184,6 +16186,8 @@ done\n \n \n \n+\n+\n \n \n \n@@ -16781,6 +16785,8 @@ done\n \n \n \n+\n+\n \n \n "}, {"sha": "64f7b9a39d52a4f8cf76eebce0ac0af607599697", "filename": "libgfortran/configure.ac", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edaaef601d0d6d263fba87b42d6d04c99dd23dba/libgfortran%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edaaef601d0d6d263fba87b42d6d04c99dd23dba/libgfortran%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure.ac?ref=edaaef601d0d6d263fba87b42d6d04c99dd23dba", "patch": "@@ -276,7 +276,7 @@ AC_CHECK_TYPES([ptrdiff_t])\n \n # check header files (we assume C89 is available, so don't check for that)\n AC_CHECK_HEADERS_ONCE(unistd.h sys/random.h sys/time.h sys/times.h \\\n-sys/resource.h sys/types.h sys/stat.h sys/wait.h \\\n+sys/resource.h sys/types.h sys/stat.h sys/uio.h sys/wait.h \\\n floatingpoint.h ieeefp.h fenv.h fptrap.h \\\n fpxcp.h pwd.h complex.h xlocale.h)\n \n@@ -315,7 +315,7 @@ else\n    AC_CHECK_FUNCS_ONCE(getrusage times mkstemp strtof strtold snprintf \\\n    ftruncate chsize chdir getentropy getlogin gethostname kill link symlink \\\n    sleep ttyname \\\n-   alarm access fork setmode fcntl \\\n+   alarm access fork setmode fcntl writev \\\n    gettimeofday stat fstat lstat getpwuid vsnprintf dup \\\n    getcwd localtime_r gmtime_r getpwuid_r ttyname_r clock_gettime \\\n    getgid getpid getuid geteuid umask getegid \\"}, {"sha": "1179812310b7ae2a5c35ab2bf090ef29f2adfa2f", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edaaef601d0d6d263fba87b42d6d04c99dd23dba/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edaaef601d0d6d263fba87b42d6d04c99dd23dba/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=edaaef601d0d6d263fba87b42d6d04c99dd23dba", "patch": "@@ -88,6 +88,10 @@ extern long double __strtold (const char *, char **);\n #include <sys/types.h>\n #endif\n \n+#ifdef HAVE_SYS_UIO_H\n+#include <sys/uio.h>\n+#endif\n+\n #ifdef __MINGW32__\n typedef off64_t gfc_offset;\n #else\n@@ -701,8 +705,15 @@ internal_proto(exit_error);\n extern ssize_t estr_write (const char *);\n internal_proto(estr_write);\n \n-extern int st_vprintf (const char *, va_list);\n-internal_proto(st_vprintf);\n+#if !defined(HAVE_WRITEV) && !defined(HAVE_SYS_UIO_H)\n+struct iovec {\n+  void  *iov_base;    /* Starting address */\n+  size_t iov_len;     /* Number of bytes to transfer */\n+};\n+#endif\n+\n+extern ssize_t estr_writev (const struct iovec *iov, int iovcnt);\n+internal_proto(estr_writev);\n \n extern int st_printf (const char *, ...)\n   __attribute__((format (gfc_printf, 1, 2)));"}, {"sha": "e0c277044b62058184350553ae8dacb9b55b05cd", "filename": "libgfortran/runtime/backtrace.c", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edaaef601d0d6d263fba87b42d6d04c99dd23dba/libgfortran%2Fruntime%2Fbacktrace.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edaaef601d0d6d263fba87b42d6d04c99dd23dba/libgfortran%2Fruntime%2Fbacktrace.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fbacktrace.c?ref=edaaef601d0d6d263fba87b42d6d04c99dd23dba", "patch": "@@ -68,6 +68,7 @@ static void\n error_callback (void *data, const char *msg, int errnum)\n {\n   struct mystate *state = (struct mystate *) data;\n+  struct iovec iov[5];\n #define ERRHDR \"\\nCould not print backtrace: \"\n \n   if (errnum < 0)\n@@ -77,21 +78,31 @@ error_callback (void *data, const char *msg, int errnum)\n     }\n   else if (errnum == 0)\n     {\n-      estr_write (ERRHDR);\n-      estr_write (msg);\n-      estr_write (\"\\n\");\n+      iov[0].iov_base = (char*) ERRHDR;\n+      iov[0].iov_len = strlen (ERRHDR);\n+      iov[1].iov_base = (char*) msg;\n+      iov[1].iov_len = strlen (msg);\n+      iov[2].iov_base = (char*) \"\\n\";\n+      iov[2].iov_len = 1;\n+      estr_writev (iov, 3);\n     }\n   else\n     {\n       char errbuf[256];\n       if (state->in_signal_handler)\n \t{\n-\t  estr_write (ERRHDR);\n-\t  estr_write (msg);\n-\t  estr_write (\", errno: \");\n+\t  iov[0].iov_base = (char*) ERRHDR;\n+\t  iov[0].iov_len = strlen (ERRHDR);\n+\t  iov[1].iov_base = (char*) msg;\n+\t  iov[1].iov_len = strlen (msg);\n+\t  iov[2].iov_base = (char*) \", errno: \";\n+\t  iov[2].iov_len = strlen (iov[2].iov_base);\n \t  const char *p = gfc_itoa (errnum, errbuf, sizeof (errbuf));\n-\t  estr_write (p);\n-\t  estr_write (\"\\n\");\n+\t  iov[3].iov_base = (char*) p;\n+\t  iov[3].iov_len = strlen (p);\n+\t  iov[4].iov_base = (char*) \"\\n\";\n+\t  iov[4].iov_len = 1;\n+\t  estr_writev (iov, 5);\n \t}\n       else\n \tst_printf (ERRHDR \"%s: %s\\n\", msg,"}, {"sha": "b07a4c0b12a57e93ee4546c074cfc2b081f49e5d", "filename": "libgfortran/runtime/error.c", "status": "modified", "additions": 137, "deletions": 51, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edaaef601d0d6d263fba87b42d6d04c99dd23dba/libgfortran%2Fruntime%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edaaef601d0d6d263fba87b42d6d04c99dd23dba/libgfortran%2Fruntime%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Ferror.c?ref=edaaef601d0d6d263fba87b42d6d04c99dd23dba", "patch": "@@ -114,52 +114,71 @@ estr_write (const char *str)\n }\n \n \n-/* st_vprintf()-- vsnprintf-like function for error output.  We use a\n-   stack allocated buffer for formatting; since this function might be\n-   called from within a signal handler, printing directly to stderr\n-   with vfprintf is not safe since the stderr locking might lead to a\n-   deadlock.  */\n+/* Write a vector of strings to standard error.  This function is\n+   async-signal-safe.  */\n \n-#define ST_VPRINTF_SIZE 512\n+ssize_t\n+estr_writev (const struct iovec *iov, int iovcnt)\n+{\n+#ifdef HAVE_WRITEV\n+  return writev (STDERR_FILENO, iov, iovcnt);\n+#else\n+  ssize_t w = 0;\n+  for (int i = 0; i < iovcnt; i++)\n+    {\n+      ssize_t r = write (STDERR_FILENO, iov[i].iov_base, iov[i].iov_len);\n+      if (r == -1)\n+\treturn r;\n+      w += r;\n+    }\n+  return w;\n+#endif\n+}\n \n-int\n-st_vprintf (const char *format, va_list ap)\n+\n+#ifndef HAVE_VSNPRINTF\n+static int\n+gf_vsnprintf (char *str, size_t size, const char *format, va_list ap)\n {\n   int written;\n-  char buffer[ST_VPRINTF_SIZE];\n \n-#ifdef HAVE_VSNPRINTF\n-  written = vsnprintf(buffer, ST_VPRINTF_SIZE, format, ap);\n-#else\n   written = vsprintf(buffer, format, ap);\n \n-  if (written >= ST_VPRINTF_SIZE - 1)\n+  if (written >= size - 1)\n     {\n       /* The error message was longer than our buffer.  Ouch.  Because\n \t we may have messed up things badly, report the error and\n \t quit.  */\n-#define ERROR_MESSAGE \"Internal error: buffer overrun in st_vprintf()\\n\"\n-      write (STDERR_FILENO, buffer, ST_VPRINTF_SIZE - 1);\n-      write (STDERR_FILENO, ERROR_MESSAGE, strlen(ERROR_MESSAGE));\n+#define ERROR_MESSAGE \"Internal error: buffer overrun in gf_vsnprintf()\\n\"\n+      write (STDERR_FILENO, buffer, size - 1);\n+      write (STDERR_FILENO, ERROR_MESSAGE, strlen (ERROR_MESSAGE));\n       sys_abort ();\n #undef ERROR_MESSAGE\n \n     }\n-#endif\n-\n-  written = write (STDERR_FILENO, buffer, written);\n   return written;\n }\n \n+#define vsnprintf gf_vsnprintf\n+#endif\n+\n+\n+/* printf() like function for for printing to stderr.  Uses a stack\n+   allocated buffer and doesn't lock stderr, so it should be safe to\n+   use from within a signal handler.  */\n+\n+#define ST_ERRBUF_SIZE 512\n \n int\n st_printf (const char * format, ...)\n {\n+  char buffer[ST_ERRBUF_SIZE];\n   int written;\n   va_list ap;\n   va_start (ap, format);\n-  written = st_vprintf (format, ap);\n+  written = vsnprintf (buffer, ST_ERRBUF_SIZE, format, ap);\n   va_end (ap);\n+  written = write (STDERR_FILENO, buffer, written);\n   return written;\n }\n \n@@ -340,12 +359,19 @@ void\n os_error (const char *message)\n {\n   char errmsg[STRERR_MAXSZ];\n+  struct iovec iov[5];\n   recursion_check ();\n-  estr_write (\"Operating system error: \");\n-  estr_write (gf_strerror (errno, errmsg, STRERR_MAXSZ));\n-  estr_write (\"\\n\");\n-  estr_write (message);\n-  estr_write (\"\\n\");\n+  iov[0].iov_base = (char*) \"Operating system error: \";\n+  iov[0].iov_len = strlen (iov[0].iov_base);\n+  iov[1].iov_base = gf_strerror (errno, errmsg, STRERR_MAXSZ);\n+  iov[1].iov_len = strlen (iov[1].iov_base);\n+  iov[2].iov_base = (char*) \"\\n\";\n+  iov[2].iov_len = 1;\n+  iov[3].iov_base = (char*) message;\n+  iov[3].iov_len = strlen (message);\n+  iov[4].iov_base = (char*) \"\\n\";\n+  iov[4].iov_len = 1;\n+  estr_writev (iov, 5);\n   exit_error (1);\n }\n iexport(os_error);\n@@ -357,14 +383,25 @@ iexport(os_error);\n void\n runtime_error (const char *message, ...)\n {\n+  char buffer[ST_ERRBUF_SIZE];\n+  struct iovec iov[3];\n   va_list ap;\n+  int written;\n \n   recursion_check ();\n-  estr_write (\"Fortran runtime error: \");\n+  iov[0].iov_base = (char*) \"Fortran runtime error: \";\n+  iov[0].iov_len = strlen (iov[0].iov_base);\n   va_start (ap, message);\n-  st_vprintf (message, ap);\n+  written = vsnprintf (buffer, ST_ERRBUF_SIZE, message, ap);\n   va_end (ap);\n-  estr_write (\"\\n\");\n+  if (written >= 0)\n+    {\n+      iov[1].iov_base = buffer;\n+      iov[1].iov_len = written;\n+      iov[2].iov_base = (char*) \"\\n\";\n+      iov[2].iov_len = 1;\n+      estr_writev (iov, 3);\n+    }\n   exit_error (2);\n }\n iexport(runtime_error);\n@@ -375,15 +412,27 @@ iexport(runtime_error);\n void\n runtime_error_at (const char *where, const char *message, ...)\n {\n+  char buffer[ST_ERRBUF_SIZE];\n   va_list ap;\n+  struct iovec iov[4];\n+  int written;\n \n   recursion_check ();\n-  estr_write (where);\n-  estr_write (\"\\nFortran runtime error: \");\n+  iov[0].iov_base = (char*) where;\n+  iov[0].iov_len = strlen (where);\n+  iov[1].iov_base = (char*) \"\\nFortran runtime error: \";\n+  iov[1].iov_len = strlen (iov[1].iov_base);\n   va_start (ap, message);\n-  st_vprintf (message, ap);\n+  written = vsnprintf (buffer, ST_ERRBUF_SIZE, message, ap);\n   va_end (ap);\n-  estr_write (\"\\n\");\n+  if (written >= 0)\n+    {\n+      iov[2].iov_base = buffer;\n+      iov[2].iov_len = written;\n+      iov[3].iov_base = (char*) \"\\n\";\n+      iov[3].iov_len = 1;\n+      estr_writev (iov, 4);\n+    }\n   exit_error (2);\n }\n iexport(runtime_error_at);\n@@ -392,14 +441,26 @@ iexport(runtime_error_at);\n void\n runtime_warning_at (const char *where, const char *message, ...)\n {\n+  char buffer[ST_ERRBUF_SIZE];\n   va_list ap;\n+  struct iovec iov[4];\n+  int written;\n \n-  estr_write (where);\n-  estr_write (\"\\nFortran runtime warning: \");\n+  iov[0].iov_base = (char*) where;\n+  iov[0].iov_len = strlen (where);\n+  iov[1].iov_base = (char*) \"\\nFortran runtime warning: \";\n+  iov[1].iov_len = strlen (iov[1].iov_base);\n   va_start (ap, message);\n-  st_vprintf (message, ap);\n+  written = vsnprintf (buffer, ST_ERRBUF_SIZE, message, ap);\n   va_end (ap);\n-  estr_write (\"\\n\");\n+  if (written >= 0)\n+    {\n+      iov[2].iov_base = buffer;\n+      iov[2].iov_len = written;\n+      iov[3].iov_base = (char*) \"\\n\";\n+      iov[3].iov_len = 1;\n+      estr_writev (iov, 4);\n+    }\n }\n iexport(runtime_warning_at);\n \n@@ -410,11 +471,17 @@ iexport(runtime_warning_at);\n void\n internal_error (st_parameter_common *cmp, const char *message)\n {\n+  struct iovec iov[3];\n+\n   recursion_check ();\n   show_locus (cmp);\n-  estr_write (\"Internal Error: \");\n-  estr_write (message);\n-  estr_write (\"\\n\");\n+  iov[0].iov_base = (char*) \"Internal Error: \";\n+  iov[0].iov_len = strlen (iov[0].iov_base);\n+  iov[1].iov_base = (char*) message;\n+  iov[1].iov_len = strlen (message);\n+  iov[2].iov_base = (char*) \"\\n\";\n+  iov[2].iov_len = 1;\n+  estr_writev (iov, 3);\n \n   /* This function call is here to get the main.o object file included\n      when linking statically. This works because error.o is supposed to\n@@ -609,9 +676,14 @@ generate_error_common (st_parameter_common *cmp, int family, const char *message\n \n   recursion_check ();\n   show_locus (cmp);\n-  estr_write (\"Fortran runtime error: \");\n-  estr_write (message);\n-  estr_write (\"\\n\");\n+  struct iovec iov[3];\n+  iov[0].iov_base = (char*) \"Fortran runtime error: \";\n+  iov[0].iov_len = strlen (iov[0].iov_base);\n+  iov[1].iov_base = (char*) message;\n+  iov[1].iov_len = strlen (message);\n+  iov[2].iov_base = (char*) \"\\n\";\n+  iov[2].iov_len = 1;\n+  estr_writev (iov, 3);\n   return false;\n }\n \n@@ -645,9 +717,14 @@ generate_warning (st_parameter_common *cmp, const char *message)\n     message = \" \";\n \n   show_locus (cmp);\n-  estr_write (\"Fortran runtime warning: \");\n-  estr_write (message);\n-  estr_write (\"\\n\");\n+  struct iovec iov[3];\n+  iov[0].iov_base = (char*) \"Fortran runtime warning: \";\n+  iov[0].iov_len = strlen (iov[0].iov_base);\n+  iov[1].iov_base = (char*) message;\n+  iov[1].iov_len = strlen (message);\n+  iov[2].iov_base = (char*) \"\\n\";\n+  iov[2].iov_len = 1;\n+  estr_writev (iov, 3);\n }\n \n \n@@ -678,6 +755,7 @@ bool\n notify_std (st_parameter_common *cmp, int std, const char * message)\n {\n   int warning;\n+  struct iovec iov[3];\n \n   if (!compile_options.pedantic)\n     return true;\n@@ -690,17 +768,25 @@ notify_std (st_parameter_common *cmp, int std, const char * message)\n     {\n       recursion_check ();\n       show_locus (cmp);\n-      estr_write (\"Fortran runtime error: \");\n-      estr_write (message);\n-      estr_write (\"\\n\");\n+      iov[0].iov_base = (char*) \"Fortran runtime error: \";\n+      iov[0].iov_len = strlen (iov[0].iov_base);\n+      iov[1].iov_base = (char*) message;\n+      iov[1].iov_len = strlen (message);\n+      iov[2].iov_base = (char*) \"\\n\";\n+      iov[2].iov_len = 1;\n+      estr_writev (iov, 3);\n       exit_error (2);\n     }\n   else\n     {\n       show_locus (cmp);\n-      estr_write (\"Fortran runtime warning: \");\n-      estr_write (message);\n-      estr_write (\"\\n\");\n+      iov[0].iov_base = (char*) \"Fortran runtime warning: \";\n+      iov[0].iov_len = strlen (iov[0].iov_base);\n+      iov[1].iov_base = (char*) message;\n+      iov[1].iov_len = strlen (message);\n+      iov[2].iov_base = (char*) \"\\n\";\n+      iov[2].iov_len = 1;\n+      estr_writev (iov, 3);\n     }\n   return false;\n }"}, {"sha": "12997c7a685df00cab2e45c38f824fdb23b9cc44", "filename": "libgfortran/runtime/pause.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edaaef601d0d6d263fba87b42d6d04c99dd23dba/libgfortran%2Fruntime%2Fpause.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edaaef601d0d6d263fba87b42d6d04c99dd23dba/libgfortran%2Fruntime%2Fpause.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fpause.c?ref=edaaef601d0d6d263fba87b42d6d04c99dd23dba", "patch": "@@ -64,11 +64,15 @@ export_proto(pause_string);\n void\n pause_string (char *string, size_t len)\n {\n-  estr_write (\"PAUSE \");\n-  ssize_t w = write (STDERR_FILENO, string, len);\n-  (void) sizeof (w); /* Avoid compiler warning about not using write\n-\t\t\treturn val.  */\n-  estr_write (\"\\n\");\n+  struct iovec iov[3];\n+\n+  iov[0].iov_base = (char*) \"PAUSE \";\n+  iov[0].iov_len = strlen (iov[0].iov_base);\n+  iov[1].iov_base = string;\n+  iov[1].iov_len = len;\n+  iov[2].iov_base = (char*) \"\\n\";\n+  iov[2].iov_len = 1;\n+  estr_writev (iov, 3);\n \n   do_pause ();\n }"}, {"sha": "4833e7b414aa5cc3eb28d01ea0073601f1d1a3a2", "filename": "libgfortran/runtime/stop.c", "status": "modified", "additions": 56, "deletions": 15, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edaaef601d0d6d263fba87b42d6d04c99dd23dba/libgfortran%2Fruntime%2Fstop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edaaef601d0d6d263fba87b42d6d04c99dd23dba/libgfortran%2Fruntime%2Fstop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fstop.c?ref=edaaef601d0d6d263fba87b42d6d04c99dd23dba", "patch": "@@ -29,6 +29,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <unistd.h>\n #endif\n \n+#include <string.h>\n \n /* Fortran 2008 demands: If any exception (14) is signaling on that image, the\n    processor shall issue a warning indicating which exceptions are signaling;\n@@ -40,7 +41,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n static void\n report_exception (void)\n {\n-  int set_excepts;\n+  struct iovec iov[8];\n+  int set_excepts, iovcnt = 1;\n \n   if (!compile_options.fpe_summary)\n     return;\n@@ -49,33 +51,62 @@ report_exception (void)\n   if ((set_excepts & compile_options.fpe_summary) == 0)\n     return;\n \n-  estr_write (\"Note: The following floating-point exceptions are signalling:\");\n+  iov[0].iov_base = (char*) \"Note: The following floating-point exceptions are signalling:\";\n+  iov[0].iov_len = strlen (iov[0].iov_base);\n \n   if ((compile_options.fpe_summary & GFC_FPE_INVALID)\n       && (set_excepts & GFC_FPE_INVALID))\n-    estr_write (\" IEEE_INVALID_FLAG\");\n+    {\n+      iov[iovcnt].iov_base = (char*) \" IEEE_INVALID_FLAG\";\n+      iov[iovcnt].iov_len = strlen (iov[iovcnt].iov_base);\n+      iovcnt++;\n+    }\n \n   if ((compile_options.fpe_summary & GFC_FPE_ZERO)\n       && (set_excepts & GFC_FPE_ZERO))\n-    estr_write (\" IEEE_DIVIDE_BY_ZERO\");\n+    {\n+      iov[iovcnt].iov_base = (char*) \" IEEE_DIVIDE_BY_ZERO\";\n+      iov[iovcnt].iov_len = strlen (iov[iovcnt].iov_base);\n+      iovcnt++;\n+    }\n \n   if ((compile_options.fpe_summary & GFC_FPE_OVERFLOW)\n       && (set_excepts & GFC_FPE_OVERFLOW))\n-    estr_write (\" IEEE_OVERFLOW_FLAG\");\n+    {\n+      iov[iovcnt].iov_base = (char*) \" IEEE_OVERFLOW_FLAG\";\n+      iov[iovcnt].iov_len = strlen (iov[iovcnt].iov_base);\n+      iovcnt++;\n+    }\n \n   if ((compile_options.fpe_summary & GFC_FPE_UNDERFLOW)\n       && (set_excepts & GFC_FPE_UNDERFLOW))\n-    estr_write (\" IEEE_UNDERFLOW_FLAG\");\n+    {\n+      iov[iovcnt].iov_base = (char*) \" IEEE_UNDERFLOW_FLAG\";\n+      iov[iovcnt].iov_len = strlen (iov[iovcnt].iov_base);\n+      iovcnt++;\n+    }\n \n   if ((compile_options.fpe_summary & GFC_FPE_DENORMAL)\n       && (set_excepts & GFC_FPE_DENORMAL))\n-    estr_write (\" IEEE_DENORMAL\");\n+    {\n+      iov[iovcnt].iov_base = (char*) \" IEEE_DENORMAL\";\n+      iov[iovcnt].iov_len = strlen (iov[iovcnt].iov_base);\n+      iovcnt++;\n+    }\n \n   if ((compile_options.fpe_summary & GFC_FPE_INEXACT)\n       && (set_excepts & GFC_FPE_INEXACT))\n-    estr_write (\" IEEE_INEXACT_FLAG\");\n+    {\n+      iov[iovcnt].iov_base = (char*) \" IEEE_INEXACT_FLAG\";\n+      iov[iovcnt].iov_len = strlen (iov[iovcnt].iov_base);\n+      iovcnt++;\n+    }\n+\n+  iov[iovcnt].iov_base = (char*) \"\\n\";\n+  iov[iovcnt].iov_len = 1;\n+  iovcnt++;\n \n-  estr_write (\"\\n\");\n+  estr_writev (iov, iovcnt);\n }\n \n \n@@ -106,9 +137,14 @@ stop_string (const char *string, size_t len, bool quiet)\n       report_exception ();\n       if (string)\n \t{\n-\t  estr_write (\"STOP \");\n-\t  (void) write (STDERR_FILENO, string, len);\n-\t  estr_write (\"\\n\");\n+\t  struct iovec iov[3];\n+\t  iov[0].iov_base = (char*) \"STOP \";\n+\t  iov[0].iov_len = strlen (iov[0].iov_base);\n+\t  iov[1].iov_base = (char*) string;\n+\t  iov[1].iov_len = len;\n+\t  iov[2].iov_base = (char*) \"\\n\";\n+\t  iov[2].iov_len = 1;\n+\t  estr_writev (iov, 3);\n \t}\n     }\n   exit (0);\n@@ -128,10 +164,15 @@ error_stop_string (const char *string, size_t len, bool quiet)\n {\n   if (!quiet)\n     {\n+      struct iovec iov[3];\n       report_exception ();\n-      estr_write (\"ERROR STOP \");\n-      (void) write (STDERR_FILENO, string, len);\n-      estr_write (\"\\n\");\n+      iov[0].iov_base = (char*) \"ERROR STOP \";\n+      iov[0].iov_len = strlen (iov[0].iov_base);\n+      iov[1].iov_base = (char*) string;\n+      iov[1].iov_len = len;\n+      iov[2].iov_base = (char*) \"\\n\";\n+      iov[2].iov_len = 1;\n+      estr_writev (iov, 3);\n     }\n   exit_error (1);\n }"}]}