{"sha": "8910466afbc2208117531c016b79fd864a04ac66", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODkxMDQ2NmFmYmMyMjA4MTE3NTMxYzAxNmI3OWZkODY0YTA0YWM2Ng==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-06-28T23:22:56Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-06-28T23:22:56Z"}, "message": "tree-inline.c (remap_type_1): Do not duplicate fields that are shared in between type and its main variant.\n\n\n\t* tree-inline.c (remap_type_1): Do not duplicate fields\n\tthat are shared in between type and its main variant.\n\nFrom-SVN: r212111", "tree": {"sha": "d2ae7a51e46a7e6db69c7b0aea502f87c78e41ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2ae7a51e46a7e6db69c7b0aea502f87c78e41ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8910466afbc2208117531c016b79fd864a04ac66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8910466afbc2208117531c016b79fd864a04ac66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8910466afbc2208117531c016b79fd864a04ac66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8910466afbc2208117531c016b79fd864a04ac66/comments", "author": null, "committer": null, "parents": [{"sha": "16a4b3b9b2e06c99a827f237a7e51243e0a510db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16a4b3b9b2e06c99a827f237a7e51243e0a510db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16a4b3b9b2e06c99a827f237a7e51243e0a510db"}], "stats": {"total": 97, "additions": 74, "deletions": 23}, "files": [{"sha": "b6f82408ff01110de08fbe3f48295085c715b587", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8910466afbc2208117531c016b79fd864a04ac66/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8910466afbc2208117531c016b79fd864a04ac66/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8910466afbc2208117531c016b79fd864a04ac66", "patch": "@@ -1,3 +1,8 @@\n+2014-06-28  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* tree-inline.c (remap_type_1): Do not duplicate fields\n+\tthat are shared in between type and its main variant.\n+\n 2014-06-28  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-prop.c (ipa_set_jf_known_type): Record always the main variant"}, {"sha": "20e2aced25710fd917238e05d1343ba8f610cc1a", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 69, "deletions": 23, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8910466afbc2208117531c016b79fd864a04ac66/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8910466afbc2208117531c016b79fd864a04ac66/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=8910466afbc2208117531c016b79fd864a04ac66", "patch": "@@ -451,47 +451,81 @@ remap_type_1 (tree type, copy_body_data *id)\n   TYPE_POINTER_TO (new_tree) = NULL;\n   TYPE_REFERENCE_TO (new_tree) = NULL;\n \n+  /* Copy all types that may contain references to local variables; be sure to\n+     preserve sharing in between type and its main variant when possible.  */\n   switch (TREE_CODE (new_tree))\n     {\n     case INTEGER_TYPE:\n     case REAL_TYPE:\n     case FIXED_POINT_TYPE:\n     case ENUMERAL_TYPE:\n     case BOOLEAN_TYPE:\n-      t = TYPE_MIN_VALUE (new_tree);\n-      if (t && TREE_CODE (t) != INTEGER_CST)\n-        walk_tree (&TYPE_MIN_VALUE (new_tree), copy_tree_body_r, id, NULL);\n+      if (TYPE_MAIN_VARIANT (new_tree) != new_tree)\n+\t{\n+\t  gcc_checking_assert (TYPE_MIN_VALUE (type) == TYPE_MIN_VALUE (TYPE_MAIN_VARIANT (type)));\n+\t  gcc_checking_assert (TYPE_MAX_VALUE (type) == TYPE_MAX_VALUE (TYPE_MAIN_VARIANT (type)));\n \n-      t = TYPE_MAX_VALUE (new_tree);\n-      if (t && TREE_CODE (t) != INTEGER_CST)\n-        walk_tree (&TYPE_MAX_VALUE (new_tree), copy_tree_body_r, id, NULL);\n+\t  TYPE_MIN_VALUE (new_tree) = TYPE_MIN_VALUE (TYPE_MAIN_VARIANT (new_tree));\n+\t  TYPE_MAX_VALUE (new_tree) = TYPE_MAX_VALUE (TYPE_MAIN_VARIANT (new_tree));\n+\t}\n+      else\n+\t{\n+\t  t = TYPE_MIN_VALUE (new_tree);\n+\t  if (t && TREE_CODE (t) != INTEGER_CST)\n+\t    walk_tree (&TYPE_MIN_VALUE (new_tree), copy_tree_body_r, id, NULL);\n+\n+\t  t = TYPE_MAX_VALUE (new_tree);\n+\t  if (t && TREE_CODE (t) != INTEGER_CST)\n+\t    walk_tree (&TYPE_MAX_VALUE (new_tree), copy_tree_body_r, id, NULL);\n+\t}\n       return new_tree;\n \n     case FUNCTION_TYPE:\n-      TREE_TYPE (new_tree) = remap_type (TREE_TYPE (new_tree), id);\n-      walk_tree (&TYPE_ARG_TYPES (new_tree), copy_tree_body_r, id, NULL);\n+      if (TYPE_MAIN_VARIANT (new_tree) != new_tree\n+\t  && TREE_TYPE (type) == TREE_TYPE (TYPE_MAIN_VARIANT (type)))\n+\tTREE_TYPE (new_tree) = TREE_TYPE (TYPE_MAIN_VARIANT (new_tree));\n+      else\n+        TREE_TYPE (new_tree) = remap_type (TREE_TYPE (new_tree), id);\n+      if (TYPE_MAIN_VARIANT (new_tree) != new_tree\n+\t  && TYPE_ARG_TYPES (type) == TYPE_ARG_TYPES (TYPE_MAIN_VARIANT (type)))\n+\tTYPE_ARG_TYPES (new_tree) = TYPE_ARG_TYPES (TYPE_MAIN_VARIANT (new_tree));\n+      else\n+        walk_tree (&TYPE_ARG_TYPES (new_tree), copy_tree_body_r, id, NULL);\n       return new_tree;\n \n     case ARRAY_TYPE:\n-      TREE_TYPE (new_tree) = remap_type (TREE_TYPE (new_tree), id);\n-      TYPE_DOMAIN (new_tree) = remap_type (TYPE_DOMAIN (new_tree), id);\n+      if (TYPE_MAIN_VARIANT (new_tree) != new_tree\n+\t  && TREE_TYPE (type) == TREE_TYPE (TYPE_MAIN_VARIANT (type)))\n+\tTREE_TYPE (new_tree) = TREE_TYPE (TYPE_MAIN_VARIANT (new_tree));\n+\n+      if (TYPE_MAIN_VARIANT (new_tree) != new_tree)\n+\t{\n+\t  gcc_checking_assert (TYPE_DOMAIN (type) == TYPE_DOMAIN (TYPE_MAIN_VARIANT (type)));\n+\t  TYPE_DOMAIN (new_tree) = TYPE_DOMAIN (TYPE_MAIN_VARIANT (new_tree));\n+\t}\n+      else\n+\tTYPE_DOMAIN (new_tree) = remap_type (TYPE_DOMAIN (new_tree), id);\n       break;\n \n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case QUAL_UNION_TYPE:\n-      {\n-\ttree f, nf = NULL;\n+      if (TYPE_MAIN_VARIANT (type) != type\n+\t  && TYPE_FIELDS (type) == TYPE_FIELDS (TYPE_MAIN_VARIANT (type)))\n+\tTYPE_FIELDS (new_tree) = TYPE_FIELDS (TYPE_MAIN_VARIANT (new_tree));\n+      else\n+\t{\n+\t  tree f, nf = NULL;\n \n-\tfor (f = TYPE_FIELDS (new_tree); f ; f = DECL_CHAIN (f))\n-\t  {\n-\t    t = remap_decl (f, id);\n-\t    DECL_CONTEXT (t) = new_tree;\n-\t    DECL_CHAIN (t) = nf;\n-\t    nf = t;\n-\t  }\n-\tTYPE_FIELDS (new_tree) = nreverse (nf);\n-      }\n+\t  for (f = TYPE_FIELDS (new_tree); f ; f = DECL_CHAIN (f))\n+\t    {\n+\t      t = remap_decl (f, id);\n+\t      DECL_CONTEXT (t) = new_tree;\n+\t      DECL_CHAIN (t) = nf;\n+\t      nf = t;\n+\t    }\n+\t  TYPE_FIELDS (new_tree) = nreverse (nf);\n+\t}\n       break;\n \n     case OFFSET_TYPE:\n@@ -500,8 +534,20 @@ remap_type_1 (tree type, copy_body_data *id)\n       gcc_unreachable ();\n     }\n \n-  walk_tree (&TYPE_SIZE (new_tree), copy_tree_body_r, id, NULL);\n-  walk_tree (&TYPE_SIZE_UNIT (new_tree), copy_tree_body_r, id, NULL);\n+  /* All variants of type share the same size, so use the already remaped data.  */\n+  if (TYPE_MAIN_VARIANT (new_tree) != new_tree)\n+    {\n+      gcc_checking_assert (TYPE_SIZE (type) == TYPE_SIZE (TYPE_MAIN_VARIANT (type)));\n+      gcc_checking_assert (TYPE_SIZE_UNIT (type) == TYPE_SIZE_UNIT (TYPE_MAIN_VARIANT (type)));\n+\n+      TYPE_SIZE (new_tree) = TYPE_SIZE (TYPE_MAIN_VARIANT (new_tree));\n+      TYPE_SIZE_UNIT (new_tree) = TYPE_SIZE_UNIT (TYPE_MAIN_VARIANT (new_tree));\n+    }\n+  else\n+    {\n+      walk_tree (&TYPE_SIZE (new_tree), copy_tree_body_r, id, NULL);\n+      walk_tree (&TYPE_SIZE_UNIT (new_tree), copy_tree_body_r, id, NULL);\n+    }\n \n   return new_tree;\n }"}]}