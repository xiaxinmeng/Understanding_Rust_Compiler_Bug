{"sha": "17bbb839f1270db8e2f99a8f173f38188ad176f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTdiYmI4MzlmMTI3MGRiOGUyZjk5YThmMTczZjM4MTg4YWQxNzZmMw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2002-09-30T16:52:19Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-09-30T16:52:19Z"}, "message": "store-layout.c (finish_record_layout): Add free_p parameter.\n\n\t* store-layout.c (finish_record_layout): Add free_p parameter.\n\t(layout_type): Pass it.\n\t* tree.h (finish_record_layout): Update prototype.\n\n\t* class.c (walk_subobject_offsets): Correct the calculation of\n\toffsets for virtual bases.  Correct the counting of array\n\telements.\n\t(layout_nonempty_base_or_field): Simplify.  Correct the\n\tcalculation of offsets to be propagated through the binfo\n\thierarchy.\n\t(build_base_field): Avoid creating a FIELD_DECL for empty bases.\n\tAdd the FIELD_DECL to TYPE_FIELDS.\n\t(build_base_fields): Adjust accordingly.\n\t(layout_virtual_bases): Use build_base_field.\n\t(end_of_class): Return a tree, not an integer.\n\t(warn_about_ambiguous_direct_bases): Rename to ...\n\t(warn_about_ambiguous_bases): ... this.\n\t(include_empty_classes): New function.\n\t(layout_class_type): Create an alternative version of the type to\n\tbe used when as a base class type.  Do not call\n\tfinish_record_layout until we are done laying out the class.\n\t* cp-tree.h (lang_type_class): Remove size, size_unit.  Add\n\tas_base.\n\t(CLASSTYPE_SIZE): Reimplement.\n\t(CLASSTYPE_SIZE_UNIT): Likewise.\n\t(CLASSTYPE_ALIGN): Likweise.\n\t(CLASSTYPE_USER_ALIGN): Likewise.\n\t(CLASSTYPE_AS_BASE): New macro.\n\t(DECL_INITIALIZED_P): Likewise.\n\t(extract_init): Remove prototype.\n\t(build_forced_zero_init): Rename to ...\n\t(build_zero_init): ... this.\n\t(force_store_init_value): Remove.\n\t* decl.c (obscure_complex_init): Remove.\n\t(duplicate_decls): Copy DECL_INITIALIZED_P.\n\t(check_initializer): Do not leave junk in DECL_INITIAL.\n\t(cp_finish_decl): Handle zero-initialization of entities with\n\tstatic storage duration.\n\t* expr.c (extract_init): Remove.\n\t* init.c (build_forced_zero_init): Remove.\n\t(build_zero_init): New function.\n\t(build_default_init): Use it.\n\t(build_field_list): Skip FIELD_DECLs for base subobjects.\n\t(push_base_cleanups): Likewise.\n\t* method.c (do_build_assign_ref): Likewise.\n\t(synthesize_exception_spec): Likewise.\n\t* pt.c (tsubst_decl): Clear DECL_INITIALIZED_P.\n\t(regenerate_decl_from_template): To not set DECL_INITIAL for a\n\tstatic data member whose initialization took place in its class.\n\t(instantiate_decl): Do not pass an initializer to cp_finish_decl\n\tin that situation.\n\t* search.c (dfs_push_decls): Skip FIELD_DECLs for base subobjects.\n\t(dfs_unuse_fields): Likewise.\n\t* tree.c (pod_type_p): Handle error_mark_node.\n\t(zero_init_p): Likewise.\n\t* typeck.c (lookup_anon_field): Skip FIELD_DECLs for base\n\tsubobjects.\n\t* typeck2.c (store_init_value): Remove #if 0'd code.\n\t(force_store_init_value): Remove.\n\t(process_init_constructor): Use build_zero_init.\n\n\t* g++.dg/abi/empty7.C: New test.\n\t* g++.dg/init/pm2.C: Likewise.\n\nFrom-SVN: r57654", "tree": {"sha": "ca1fbe15f3c944722c4671ad1534fc2a6abdb753", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca1fbe15f3c944722c4671ad1534fc2a6abdb753"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17bbb839f1270db8e2f99a8f173f38188ad176f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17bbb839f1270db8e2f99a8f173f38188ad176f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17bbb839f1270db8e2f99a8f173f38188ad176f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17bbb839f1270db8e2f99a8f173f38188ad176f3/comments", "author": null, "committer": null, "parents": [{"sha": "acc59b855d7e95215412c2c86a6865595245be36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acc59b855d7e95215412c2c86a6865595245be36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acc59b855d7e95215412c2c86a6865595245be36"}], "stats": {"total": 1091, "additions": 629, "deletions": 462}, "files": [{"sha": "f1a6964664b29cf83d9a974db9cb6297e2ca0f28", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=17bbb839f1270db8e2f99a8f173f38188ad176f3", "patch": "@@ -1,3 +1,9 @@\n+2002-09-30  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* store-layout.c (finish_record_layout): Add free_p parameter.\n+\t(layout_type): Pass it.\n+\t* tree.h (finish_record_layout): Update prototype.\n+\t\n Mon Sep 30 14:57:18 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.h (TARGET_CPP_CPU_BUILTINS): Define __SSE_MATH__."}, {"sha": "1fef98d22b821048453f4154ea408e8b4157d16f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=17bbb839f1270db8e2f99a8f173f38188ad176f3", "patch": "@@ -1,3 +1,62 @@\n+2002-09-30  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* class.c (walk_subobject_offsets): Correct the calculation of\n+\toffsets for virtual bases.  Correct the counting of array\n+\telements.\n+\t(layout_nonempty_base_or_field): Simplify.  Correct the\n+\tcalculation of offsets to be propagated through the binfo\n+\thierarchy.\n+\t(build_base_field): Avoid creating a FIELD_DECL for empty bases.\n+\tAdd the FIELD_DECL to TYPE_FIELDS.\n+\t(build_base_fields): Adjust accordingly.\n+\t(layout_virtual_bases): Use build_base_field.\n+\t(end_of_class): Return a tree, not an integer.\n+\t(warn_about_ambiguous_direct_bases): Rename to ...\n+\t(warn_about_ambiguous_bases): ... this.\n+\t(include_empty_classes): New function.\n+\t(layout_class_type): Create an alternative version of the type to\n+\tbe used when as a base class type.  Do not call\n+\tfinish_record_layout until we are done laying out the class.\n+\t* cp-tree.h (lang_type_class): Remove size, size_unit.  Add\n+\tas_base.\n+\t(CLASSTYPE_SIZE): Reimplement.\n+\t(CLASSTYPE_SIZE_UNIT): Likewise.\n+\t(CLASSTYPE_ALIGN): Likweise.\n+\t(CLASSTYPE_USER_ALIGN): Likewise.\n+\t(CLASSTYPE_AS_BASE): New macro.\n+\t(DECL_INITIALIZED_P): Likewise.\n+\t(extract_init): Remove prototype.\n+\t(build_forced_zero_init): Rename to ...\n+\t(build_zero_init): ... this.\n+\t(force_store_init_value): Remove.\n+\t* decl.c (obscure_complex_init): Remove.\n+\t(duplicate_decls): Copy DECL_INITIALIZED_P.\n+\t(check_initializer): Do not leave junk in DECL_INITIAL.\n+\t(cp_finish_decl): Handle zero-initialization of entities with\n+\tstatic storage duration.\n+\t* expr.c (extract_init): Remove.\n+\t* init.c (build_forced_zero_init): Remove.\n+\t(build_zero_init): New function.\n+\t(build_default_init): Use it.\n+\t(build_field_list): Skip FIELD_DECLs for base subobjects.\n+\t(push_base_cleanups): Likewise.\n+\t* method.c (do_build_assign_ref): Likewise.\n+\t(synthesize_exception_spec): Likewise.\n+\t* pt.c (tsubst_decl): Clear DECL_INITIALIZED_P.\n+\t(regenerate_decl_from_template): To not set DECL_INITIAL for a\n+\tstatic data member whose initialization took place in its class.\n+\t(instantiate_decl): Do not pass an initializer to cp_finish_decl\n+\tin that situation.\n+\t* search.c (dfs_push_decls): Skip FIELD_DECLs for base subobjects.\n+\t(dfs_unuse_fields): Likewise.\n+\t* tree.c (pod_type_p): Handle error_mark_node.\n+\t(zero_init_p): Likewise.\n+\t* typeck.c (lookup_anon_field): Skip FIELD_DECLs for base \n+\tsubobjects.\n+\t* typeck2.c (store_init_value): Remove #if 0'd code.\n+\t(force_store_init_value): Remove.\n+\t(process_init_constructor): Use build_zero_init.\n+\t\n 2002-09-29  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/7788"}, {"sha": "b97b2683ee169fa0005ce8767a78c05cbaf16dc1", "filename": "gcc/cp/class.c", "status": "modified", "additions": 291, "deletions": 249, "changes": 540, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=17bbb839f1270db8e2f99a8f173f38188ad176f3", "patch": "@@ -137,21 +137,22 @@ static void check_bitfield_decl PARAMS ((tree));\n static void check_field_decl PARAMS ((tree, tree, int *, int *, int *, int *));\n static void check_field_decls PARAMS ((tree, tree *, int *, int *, int *, \n \t\t\t\t     int *));\n-static bool build_base_field PARAMS ((record_layout_info, tree, int *,\n-\t\t\t\t     splay_tree, tree));\n-static bool build_base_fields PARAMS ((record_layout_info, int *,\n-\t\t\t\t      splay_tree, tree));\n+static tree *build_base_field PARAMS ((record_layout_info, tree, int *,\n+\t\t\t\t       splay_tree, tree *));\n+static void build_base_fields PARAMS ((record_layout_info, int *,\n+\t\t\t\t      splay_tree, tree *));\n static void check_methods PARAMS ((tree));\n static void remove_zero_width_bit_fields PARAMS ((tree));\n static void check_bases PARAMS ((tree, int *, int *, int *));\n static void check_bases_and_members PARAMS ((tree, int *));\n static tree create_vtable_ptr PARAMS ((tree, int *, tree *));\n+static void include_empty_classes (record_layout_info);\n static void layout_class_type PARAMS ((tree, int *, int *, tree *));\n static void fixup_pending_inline PARAMS ((tree));\n static void fixup_inline_methods PARAMS ((tree));\n static void set_primary_base PARAMS ((tree, tree, int *));\n static void propagate_binfo_offsets PARAMS ((tree, tree, tree));\n-static void layout_virtual_bases PARAMS ((tree, splay_tree));\n+static void layout_virtual_bases (record_layout_info, splay_tree);\n static tree dfs_set_offset_for_unshared_vbases PARAMS ((tree, void *));\n static void build_vbase_offset_vtbl_entries PARAMS ((tree, vtbl_init_data *));\n static void add_vcall_offset_vtbl_entries_r PARAMS ((tree, vtbl_init_data *));\n@@ -171,9 +172,8 @@ static tree build_vtable PARAMS ((tree, tree, tree));\n static void initialize_vtable PARAMS ((tree, tree));\n static void initialize_array PARAMS ((tree, tree));\n static void layout_nonempty_base_or_field PARAMS ((record_layout_info,\n-\t\t\t\t\t\t   tree, tree,\n-\t\t\t\t\t\t   splay_tree, tree));\n-static unsigned HOST_WIDE_INT end_of_class PARAMS ((tree, int));\n+\t\t\t\t\t\t   tree, tree, splay_tree));\n+static tree end_of_class PARAMS ((tree, int));\n static bool layout_empty_base PARAMS ((tree, tree, splay_tree, tree));\n static void accumulate_vtbl_inits PARAMS ((tree, tree, tree, tree, tree));\n static tree dfs_accumulate_vtbl_inits PARAMS ((tree, tree, tree, tree,\n@@ -208,7 +208,7 @@ static void record_subobject_offsets PARAMS ((tree, tree, splay_tree, int));\n static int layout_conflict_p PARAMS ((tree, tree, splay_tree, int));\n static int splay_tree_compare_integer_csts PARAMS ((splay_tree_key k1,\n \t\t\t\t\t\t    splay_tree_key k2));\n-static void warn_about_ambiguous_direct_bases PARAMS ((tree));\n+static void warn_about_ambiguous_bases PARAMS ((tree));\n static bool type_requires_array_cookie PARAMS ((tree));\n static bool contains_empty_class_p (tree);\n \n@@ -3512,6 +3512,7 @@ walk_subobject_offsets (type, f, offset, offsets, max_offset, vbases_p)\n   if (CLASS_TYPE_P (type))\n     {\n       tree field;\n+      tree binfo;\n       int i;\n \n       /* Record the location of TYPE.  */\n@@ -3522,7 +3523,11 @@ walk_subobject_offsets (type, f, offset, offsets, max_offset, vbases_p)\n       /* Iterate through the direct base classes of TYPE.  */\n       for (i = 0; i < CLASSTYPE_N_BASECLASSES (type); ++i)\n \t{\n-\t  tree binfo = BINFO_BASETYPE (TYPE_BINFO (type), i);\n+\t  binfo = BINFO_BASETYPE (TYPE_BINFO (type), i);\n+\n+\t  if (abi_version_at_least (2) \n+\t      && TREE_VIA_VIRTUAL (binfo))\n+\t    continue;\n \n \t  if (!vbases_p \n \t      && TREE_VIA_VIRTUAL (binfo) \n@@ -3536,14 +3541,40 @@ walk_subobject_offsets (type, f, offset, offsets, max_offset, vbases_p)\n \t\t\t\t\t\t  BINFO_OFFSET (binfo)),\n \t\t\t\t      offsets,\n \t\t\t\t      max_offset,\n-\t\t\t\t      vbases_p);\n+\t\t\t\t      (abi_version_at_least (2) \n+\t\t\t\t       ? /*vbases_p=*/0 : vbases_p));\n \t  if (r)\n \t    return r;\n \t}\n \n+      /* Iterate through the virtual base classes of TYPE.  In G++\n+\t 3.2, we included virtual bases in the direct base class loop\n+\t above, which results in incorrect results; the correct\n+\t offsets for virtual bases are only known when working with\n+\t the most derived type.  */\n+      if (abi_version_at_least (2) && vbases_p)\n+\t{\n+\t  tree vbase;\n+\n+\t  for (vbase = CLASSTYPE_VBASECLASSES (type);\n+\t       vbase;\n+\t       vbase = TREE_CHAIN (vbase))\n+\t    {\n+\t      binfo = TREE_VALUE (vbase);\n+\t      r = walk_subobject_offsets (BINFO_TYPE (binfo),\n+\t\t\t\t\t  f,\n+\t\t\t\t\t  size_binop (PLUS_EXPR,\n+\t\t\t\t\t\t      offset,\n+\t\t\t\t\t\t      BINFO_OFFSET (binfo)),\n+\t\t\t\t\t  offsets,\n+\t\t\t\t\t  max_offset,\n+\t\t\t\t\t  /*vbases_p=*/0);\n+\t    }\n+\t}\n+\n       /* Iterate through the fields of TYPE.  */\n       for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n-\tif (TREE_CODE (field) == FIELD_DECL)\n+\tif (TREE_CODE (field) == FIELD_DECL && !DECL_ARTIFICIAL (field))\n \t  {\n \t    tree field_offset;\n \n@@ -3571,8 +3602,11 @@ walk_subobject_offsets (type, f, offset, offsets, max_offset, vbases_p)\n       tree index;\n \n       /* Step through each of the elements in the array.  */\n-      for (index = size_zero_node; \n-\t   INT_CST_LT (index, TYPE_MAX_VALUE (domain));\n+      for (index = size_zero_node;\n+\t   /* G++ 3.2 had an off-by-one error here.  */\n+\t   (abi_version_at_least (2) \n+\t    ? !INT_CST_LT (TYPE_MAX_VALUE (domain), index)\n+\t    : INT_CST_LT (index, TYPE_MAX_VALUE (domain)));\n \t   index = size_binop (PLUS_EXPR, index, size_one_node))\n \t{\n \t  r = walk_subobject_offsets (TREE_TYPE (type),\n@@ -3640,22 +3674,34 @@ layout_conflict_p (type, offset, offsets, vbases_p)\n /* DECL is a FIELD_DECL corresponding either to a base subobject of a\n    non-static data member of the type indicated by RLI.  BINFO is the\n    binfo corresponding to the base subobject, OFFSETS maps offsets to\n-   types already located at those offsets.  T is the most derived\n-   type.  This function determines the position of the DECL.  */\n+   types already located at those offsets.  This function determines\n+   the position of the DECL.  */\n \n static void\n-layout_nonempty_base_or_field (rli, decl, binfo, offsets, t)\n-     record_layout_info rli;\n-     tree decl;\n-     tree binfo;\n-     splay_tree offsets;\n-     tree t;\n+layout_nonempty_base_or_field (record_layout_info rli, \n+\t\t\t       tree decl, \n+\t\t\t       tree binfo, \n+\t\t\t       splay_tree offsets)\n {\n+  tree t = rli->t;\n   tree offset = NULL_TREE;\n-  tree type = TREE_TYPE (decl);\n-  /* If we are laying out a base class, rather than a field, then\n-     DECL_ARTIFICIAL will be set on the FIELD_DECL.  */\n-  int field_p = !DECL_ARTIFICIAL (decl);\n+  bool field_p;\n+  tree type;\n+  \n+  if (binfo)\n+    {\n+      /* For the purposes of determining layout conflicts, we want to\n+\t use the class type of BINFO; TREE_TYPE (DECL) will be the\n+\t CLASSTYPE_AS_BASE version, which does not contain entries for\n+\t zero-sized bases.  */\n+      type = TREE_TYPE (binfo);\n+      field_p = false;\n+    }\n+  else\n+    {\n+      type = TREE_TYPE (decl);\n+      field_p = true;\n+    }\n \n   /* Try to place the field.  It may take more than one try if we have\n      a hard time placing the field without putting two objects of the\n@@ -3683,10 +3729,7 @@ layout_nonempty_base_or_field (rli, decl, binfo, offsets, t)\n \t empty class, have nonzero size, any overlap can happen only\n \t with a direct or indirect base-class -- it can't happen with\n \t a data member.  */\n-      if (layout_conflict_p (TREE_TYPE (decl),\n-\t\t\t     offset,\n-\t\t\t     offsets, \n-\t\t\t     field_p))\n+      if (layout_conflict_p (type, offset, offsets, field_p))\n \t{\n \t  /* Strip off the size allocated to this field.  That puts us\n \t     at the first place we could have put the field with\n@@ -3709,8 +3752,15 @@ layout_nonempty_base_or_field (rli, decl, binfo, offsets, t)\n   /* Now that we know where it will be placed, update its\n      BINFO_OFFSET.  */\n   if (binfo && CLASS_TYPE_P (BINFO_TYPE (binfo)))\n+    /* Indirect virtual bases may have a non-zero BINFO_OFFSET at\n+       this point because their BINFO_OFFSET is copied from another\n+       hierarchy.  Therefore, we may not need to add the entire\n+       OFFSET.  */\n     propagate_binfo_offsets (binfo, \n-\t\t\t     convert (ssizetype, offset), t);\n+\t\t\t     size_diffop (convert (ssizetype, offset),\n+\t\t\t\t\t  convert (ssizetype, \n+\t\t\t\t\t\t   BINFO_OFFSET (binfo))),\n+\t\t\t     t);\n }\n \n /* Layout the empty base BINFO.  EOC indicates the byte currently just\n@@ -3768,103 +3818,116 @@ layout_empty_base (binfo, eoc, offsets, t)\n   return atend;\n }\n \n-/* Build a FIELD_DECL for the base given by BINFO in the class\n-   indicated by RLI.  If the new object is non-empty, clear *EMPTY_P.\n-   *BASE_ALIGN is a running maximum of the alignments of any base\n-   class.  OFFSETS gives the location of empty base subobjects.  T is\n-   the most derived type.  Return nonzero if the new object cannot be\n-   nearly-empty.  */\n+/* Layout the the base given by BINFO in the class indicated by RLI.\n+   If the new object is non-empty, and EMPTY_P is non-NULL, clear\n+   *EMPTY_P.  *BASE_ALIGN is a running maximum of the alignments of\n+   any base class.  OFFSETS gives the location of empty base\n+   subobjects.  T is the most derived type.  Return nonzero if the new\n+   object cannot be nearly-empty.  A new FIELD_DECL is inserted at\n+   *NEXT_FIELD, unless BINFO is for an empty base class.  \n \n-static bool\n-build_base_field (rli, binfo, empty_p, offsets, t)\n-     record_layout_info rli;\n-     tree binfo;\n-     int *empty_p;\n-     splay_tree offsets;\n-     tree t;\n+   Returns the location at which the next field should be inserted.  */\n+\n+static tree *\n+build_base_field (record_layout_info rli, tree binfo, int *empty_p, \n+\t\t  splay_tree offsets, tree *next_field)\n {\n+  tree t = rli->t;\n   tree basetype = BINFO_TYPE (binfo);\n-  tree decl;\n-  bool atend = false;\n \n   if (!COMPLETE_TYPE_P (basetype))\n     /* This error is now reported in xref_tag, thus giving better\n        location information.  */\n-    return atend;\n-  \n-  decl = build_decl (FIELD_DECL, NULL_TREE, basetype);\n-  DECL_ARTIFICIAL (decl) = 1;\n-  DECL_FIELD_CONTEXT (decl) = rli->t;\n-  DECL_SIZE (decl) = CLASSTYPE_SIZE (basetype);\n-  DECL_SIZE_UNIT (decl) = CLASSTYPE_SIZE_UNIT (basetype);\n-  DECL_ALIGN (decl) = CLASSTYPE_ALIGN (basetype);\n-  DECL_USER_ALIGN (decl) = CLASSTYPE_USER_ALIGN (basetype);\n-  /* Tell the backend not to round up to TYPE_ALIGN.  */\n-  DECL_PACKED (decl) = 1;\n+    return next_field;\n   \n-  if (!integer_zerop (DECL_SIZE (decl)))\n+  /* Place the base class.  */\n+  if (!is_empty_class (basetype))\n     {\n+      tree decl;\n+\n       /* The containing class is non-empty because it has a non-empty\n \t base class.  */\n-      *empty_p = 0;\n-\n+      if (empty_p)\n+\t*empty_p = 0;\n+      \n+      /* Create the FIELD_DECL.  */\n+      decl = build_decl (FIELD_DECL, NULL_TREE, CLASSTYPE_AS_BASE (basetype));\n+      DECL_ARTIFICIAL (decl) = 1;\n+      DECL_FIELD_CONTEXT (decl) = t;\n+      DECL_SIZE (decl) = CLASSTYPE_SIZE (basetype);\n+      DECL_SIZE_UNIT (decl) = CLASSTYPE_SIZE_UNIT (basetype);\n+      DECL_ALIGN (decl) = CLASSTYPE_ALIGN (basetype);\n+      DECL_USER_ALIGN (decl) = CLASSTYPE_USER_ALIGN (basetype);\n+      /* Tell the backend not to round up to TYPE_ALIGN.  */\n+      DECL_PACKED (decl) = 1;\n+  \n       /* Try to place the field.  It may take more than one try if we\n \t have a hard time placing the field without putting two\n \t objects of the same type at the same address.  */\n-      layout_nonempty_base_or_field (rli, decl, binfo, offsets, t);\n+      layout_nonempty_base_or_field (rli, decl, binfo, offsets);\n+      /* Add the new FIELD_DECL to the list of fields for T.  */\n+      TREE_CHAIN (decl) = *next_field;\n+      *next_field = decl;\n+      next_field = &TREE_CHAIN (decl);\n     }\n   else\n     {\n-      unsigned HOST_WIDE_INT eoc;\n+      tree eoc;\n \n       /* On some platforms (ARM), even empty classes will not be\n \t byte-aligned.  */\n-      eoc = tree_low_cst (rli_size_unit_so_far (rli), 0);\n-      eoc = CEIL (eoc, DECL_ALIGN_UNIT (decl)) * DECL_ALIGN_UNIT (decl);\n-      atend |= layout_empty_base (binfo, size_int (eoc), offsets, t);\n+      eoc = round_up (rli_size_unit_so_far (rli),\n+\t\t      CLASSTYPE_ALIGN_UNIT (basetype));\n+      if (layout_empty_base (binfo, eoc, offsets, t))\n+\tCLASSTYPE_NEARLY_EMPTY_P (t) = 0;\n+\n+      /* We do not create a FIELD_DECL for empty base classes because\n+\t it might overlap some other field.  We want to be able to\n+\t create CONSTRUCTORs for the class by iterating over the\n+\t FIELD_DECLs, and the back end does not handle overlapping\n+\t FIELD_DECLs.  */\n     }\n \n   /* Record the offsets of BINFO and its base subobjects.  */\n   record_subobject_offsets (BINFO_TYPE (binfo), \n \t\t\t    BINFO_OFFSET (binfo),\n \t\t\t    offsets, \n \t\t\t    /*vbases_p=*/0);\n-  return atend;\n+\n+  return next_field;\n }\n \n /* Layout all of the non-virtual base classes.  Record empty\n-   subobjects in OFFSETS.  T is the most derived type.  Return\n-   nonzero if the type cannot be nearly empty.  */\n+   subobjects in OFFSETS.  T is the most derived type.  Return nonzero\n+   if the type cannot be nearly empty.  The fields created\n+   corresponding to the base classes will be inserted at\n+   *NEXT_FIELD.  */\n \n-static bool\n-build_base_fields (rli, empty_p, offsets, t)\n-     record_layout_info rli;\n-     int *empty_p;\n-     splay_tree offsets;\n-     tree t;\n+static void\n+build_base_fields (record_layout_info rli, int *empty_p, \n+\t\t   splay_tree offsets, tree *next_field)\n {\n   /* Chain to hold all the new FIELD_DECLs which stand in for base class\n      subobjects.  */\n-  tree rec = rli->t;\n-  int n_baseclasses = CLASSTYPE_N_BASECLASSES (rec);\n+  tree t = rli->t;\n+  int n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n   int i;\n-  bool atend = 0;\n \n   /* The primary base class is always allocated first.  */\n-  if (CLASSTYPE_HAS_PRIMARY_BASE_P (rec))\n-    build_base_field (rli, CLASSTYPE_PRIMARY_BINFO (rec), \n-\t\t      empty_p, offsets, t);\n+  if (CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n+    next_field = build_base_field (rli, CLASSTYPE_PRIMARY_BINFO (t),\n+\t\t\t\t   empty_p, offsets, next_field);\n \n   /* Now allocate the rest of the bases.  */\n   for (i = 0; i < n_baseclasses; ++i)\n     {\n       tree base_binfo;\n \n-      base_binfo = BINFO_BASETYPE (TYPE_BINFO (rec), i);\n+      base_binfo = BINFO_BASETYPE (TYPE_BINFO (t), i);\n \n       /* The primary base was already allocated above, so we don't\n \t need to allocate it again here.  */\n-      if (base_binfo == CLASSTYPE_PRIMARY_BINFO (rec))\n+      if (base_binfo == CLASSTYPE_PRIMARY_BINFO (t))\n \tcontinue;\n \n       /* A primary virtual base class is allocated just like any other\n@@ -3874,9 +3937,9 @@ build_base_fields (rli, empty_p, offsets, t)\n \t  && !BINFO_PRIMARY_P (base_binfo))\n \tcontinue;\n \n-      atend |= build_base_field (rli, base_binfo, empty_p, offsets, t);\n+      next_field = build_base_field (rli, base_binfo, empty_p,\n+\t\t\t\t     offsets, next_field);\n     }\n-  return atend;\n }\n \n /* Go through the TYPE_METHODS of T issuing any appropriate\n@@ -4567,36 +4630,41 @@ dfs_set_offset_for_unshared_vbases (binfo, data)\n   return NULL_TREE;\n }\n \n-/* Set BINFO_OFFSET for all of the virtual bases for T.  Update\n+/* Set BINFO_OFFSET for all of the virtual bases for RLI->T.  Update\n    TYPE_ALIGN and TYPE_SIZE for T.  OFFSETS gives the location of\n    empty subobjects of T.  */\n \n static void\n-layout_virtual_bases (t, offsets)\n-     tree t;\n-     splay_tree offsets;\n+layout_virtual_bases (record_layout_info rli, splay_tree offsets)\n {\n-  tree vbases, dsize;\n-  unsigned HOST_WIDE_INT eoc;\n+  tree vbases;\n+  tree t = rli->t;\n   bool first_vbase = true;\n+  tree *next_field;\n \n   if (CLASSTYPE_N_BASECLASSES (t) == 0)\n     return;\n \n+  if (!abi_version_at_least(2))\n+    {\n+      /* In G++ 3.2, we incorrectly rounded the size before laying out\n+\t the virtual bases.  */\n+      finish_record_layout (rli, /*free_p=*/false);\n #ifdef STRUCTURE_SIZE_BOUNDARY\n-  /* Packed structures don't need to have minimum size.  */\n-  if (! TYPE_PACKED (t))\n-    TYPE_ALIGN (t) = MAX (TYPE_ALIGN (t), STRUCTURE_SIZE_BOUNDARY);\n+      /* Packed structures don't need to have minimum size.  */\n+      if (! TYPE_PACKED (t))\n+\tTYPE_ALIGN (t) = MAX (TYPE_ALIGN (t), STRUCTURE_SIZE_BOUNDARY);\n #endif\n+      rli->offset = TYPE_SIZE_UNIT (t);\n+      rli->bitpos = bitsize_zero_node;\n+      rli->record_align = TYPE_ALIGN (t);\n+    }\n \n-  /* DSIZE is the size of the class without the virtual bases.  */\n-  if (abi_version_at_least(2))\n-    dsize = CLASSTYPE_SIZE (t);\n-  else\n-    dsize = TYPE_SIZE (t);\n-\n-  /* Make every class have alignment of at least one.  */\n-  TYPE_ALIGN (t) = MAX (TYPE_ALIGN (t), BITS_PER_UNIT);\n+  /* Find the last field.  The artificial fields created for virtual\n+     bases will go after the last extant field to date.  */\n+  next_field = &TYPE_FIELDS (t);\n+  while (*next_field)\n+    next_field = &TREE_CHAIN (*next_field);\n \n   /* Go through the virtual bases, allocating space for each virtual\n      base that is not already a primary base class.  These are\n@@ -4614,45 +4682,12 @@ layout_virtual_bases (t, offsets)\n \n       if (!BINFO_PRIMARY_P (vbase))\n \t{\n+\t  tree basetype = TREE_TYPE (vbase);\n+\n \t  /* This virtual base is not a primary base of any class in the\n \t     hierarchy, so we have to add space for it.  */\n-\t  tree basetype, usize;\n-\t  unsigned int desired_align;\n-\n-\t  basetype = BINFO_TYPE (vbase);\n-\n-\t  desired_align = CLASSTYPE_ALIGN (basetype);\n-\t  TYPE_ALIGN (t) = MAX (TYPE_ALIGN (t), desired_align);\n-\n-\t  /* Add padding so that we can put the virtual base class at an\n-\t     appropriately aligned offset.  */\n-\t  dsize = round_up (dsize, desired_align);\n-\t  usize = size_binop (CEIL_DIV_EXPR, dsize, bitsize_unit_node);\n-\n-\t  /* We try to squish empty virtual bases in just like\n-\t     ordinary empty bases.  */\n-\t  if (is_empty_class (basetype))\n-\t    layout_empty_base (vbase,\n-\t\t\t       convert (sizetype, usize),\n-\t\t\t       offsets, t);\n-\t  else\n-\t    {\n-\t      tree offset;\n-\n-\t      offset = convert (ssizetype, usize);\n-\t      offset = size_diffop (offset, \n-\t\t\t\t    convert (ssizetype, \n-\t\t\t\t\t     BINFO_OFFSET (vbase)));\n-\n-\t      /* And compute the offset of the virtual base.  */\n-\t      propagate_binfo_offsets (vbase, offset, t);\n-\t      /* Every virtual baseclass takes a least a UNIT, so that\n-\t\t we can take it's address and get something different\n-\t\t for each base.  */\n-\t      dsize = size_binop (PLUS_EXPR, dsize,\n-\t\t\t\t  size_binop (MAX_EXPR, bitsize_unit_node,\n-\t\t\t\t\t      CLASSTYPE_SIZE (basetype)));\n-\t    }\n+\t  next_field = build_base_field (rli, vbase, /*empty_p=*/NULL, \n+\t\t\t\t\t offsets, next_field);\n \n \t  /* If the first virtual base might have been placed at a\n \t     lower address, had we started from CLASSTYPE_SIZE, rather\n@@ -4663,20 +4698,15 @@ layout_virtual_bases (t, offsets)\n \t     the results which is not particularly tractable.  */\n \t  if (warn_abi\n \t      && first_vbase\n-\t      && tree_int_cst_lt (size_binop (CEIL_DIV_EXPR,\n-\t\t\t\t\t      round_up (CLASSTYPE_SIZE (t),\n-\t\t\t\t\t\t\tdesired_align),\n-\t\t\t\t\t      bitsize_unit_node),\n-\t\t\t\t  BINFO_OFFSET (vbase)))\n+\t      && (tree_int_cst_lt \n+\t\t  (size_binop (CEIL_DIV_EXPR,\n+\t\t\t       round_up (CLASSTYPE_SIZE (t),\n+\t\t\t\t\t CLASSTYPE_ALIGN (basetype)),\n+\t\t\t       bitsize_unit_node),\n+\t\t   BINFO_OFFSET (vbase))))\n \t    warning (\"offset of virtual base `%T' is not ABI-compliant and may change in a future version of GCC\",\n \t\t     basetype);\n \n-\t  /* Keep track of the offsets assigned to this virtual base.  */\n-\t  record_subobject_offsets (BINFO_TYPE (vbase), \n-\t\t\t\t    BINFO_OFFSET (vbase),\n-\t\t\t\t    offsets,\n-\t\t\t\t    /*vbases_p=*/0);\n-\n \t  first_vbase = false;\n \t}\n     }\n@@ -4687,53 +4717,25 @@ layout_virtual_bases (t, offsets)\n      in lookup_base depend on the BINFO_OFFSETs being set\n      correctly.  */\n   dfs_walk (TYPE_BINFO (t), dfs_set_offset_for_unshared_vbases, NULL, t);\n-\n-  /* If we had empty base classes that protruded beyond the end of the\n-     class, we didn't update DSIZE above; we were hoping to overlay\n-     multiple such bases at the same location.  */\n-  eoc = end_of_class (t, /*include_virtuals_p=*/1);\n-  dsize = size_binop (MAX_EXPR, dsize, bitsize_int (eoc * BITS_PER_UNIT));\n-\n-  /* Now, make sure that the total size of the type is a multiple of\n-     its alignment.  */\n-  dsize = round_up (dsize, TYPE_ALIGN (t));\n-  TYPE_SIZE (t) = dsize;\n-  TYPE_SIZE_UNIT (t) = convert (sizetype,\n-\t\t\t\tsize_binop (CEIL_DIV_EXPR, TYPE_SIZE (t),\n-\t\t\t\t\t    bitsize_unit_node));\n-\n-  /* Check for ambiguous virtual bases.  */\n-  if (extra_warnings)\n-    for (vbases = CLASSTYPE_VBASECLASSES (t); \n-\t vbases; \n-\t vbases = TREE_CHAIN (vbases))\n-      {\n-\ttree basetype = BINFO_TYPE (TREE_VALUE (vbases));\n-\t\n-\tif (!lookup_base (t, basetype, ba_ignore | ba_quiet, NULL))\n-\t  warning (\"virtual base `%T' inaccessible in `%T' due to ambiguity\",\n-\t\t      basetype, t);\n-      }\n }\n \n /* Returns the offset of the byte just past the end of the base class\n    with the highest offset in T.  If INCLUDE_VIRTUALS_P is zero, then\n    only non-virtual bases are included.  */\n \n-static unsigned HOST_WIDE_INT\n+static tree\n end_of_class (t, include_virtuals_p)\n      tree t;\n      int include_virtuals_p;\n {\n-  unsigned HOST_WIDE_INT result = 0;\n+  tree result = size_zero_node;\n   int i;\n \n   for (i = 0; i < CLASSTYPE_N_BASECLASSES (t); ++i)\n     {\n       tree base_binfo;\n       tree offset;\n       tree size;\n-      unsigned HOST_WIDE_INT end_of_base;\n \n       base_binfo = BINFO_BASETYPE (TYPE_BINFO (t), i);\n \n@@ -4752,15 +4754,14 @@ end_of_class (t, include_virtuals_p)\n       offset = size_binop (PLUS_EXPR, \n \t\t\t   BINFO_OFFSET (base_binfo),\n \t\t\t   size);\n-      end_of_base = tree_low_cst (offset, /*pos=*/1);\n-      if (end_of_base > result)\n-\tresult = end_of_base;\n+      if (INT_CST_LT_UNSIGNED (result, offset))\n+\tresult = offset;\n     }\n \n   return result;\n }\n \n-/* Warn about direct bases of T that are inaccessible because they are\n+/* Warn about bases of T that are inaccessible because they are\n    ambiguous.  For example:\n \n      struct S {};\n@@ -4771,19 +4772,35 @@ end_of_class (t, include_virtuals_p)\n    subobjects of U.  */\n \n static void\n-warn_about_ambiguous_direct_bases (t)\n+warn_about_ambiguous_bases (t)\n      tree t;\n {\n   int i;\n+  tree vbases;\n+  tree basetype;\n \n+  /* Check direct bases.  */\n   for (i = 0; i < CLASSTYPE_N_BASECLASSES (t); ++i)\n     {\n-      tree basetype = TYPE_BINFO_BASETYPE (t, i);\n+      basetype = TYPE_BINFO_BASETYPE (t, i);\n \n       if (!lookup_base (t, basetype, ba_ignore | ba_quiet, NULL))\n \twarning (\"direct base `%T' inaccessible in `%T' due to ambiguity\",\n-\t\t    basetype, t);\n+\t\t basetype, t);\n     }\n+\n+  /* Check for ambiguous virtual bases.  */\n+  if (extra_warnings)\n+    for (vbases = CLASSTYPE_VBASECLASSES (t); \n+\t vbases; \n+\t vbases = TREE_CHAIN (vbases))\n+      {\n+\tbasetype = BINFO_TYPE (TREE_VALUE (vbases));\n+\t\n+\tif (!lookup_base (t, basetype, ba_ignore | ba_quiet, NULL))\n+\t  warning (\"virtual base `%T' inaccessible in `%T' due to ambiguity\",\n+\t\t   basetype, t);\n+      }\n }\n \n /* Compare two INTEGER_CSTs K1 and K2.  */\n@@ -4796,6 +4813,29 @@ splay_tree_compare_integer_csts (k1, k2)\n   return tree_int_cst_compare ((tree) k1, (tree) k2);\n }\n \n+/* Increase the size indicated in RLI to account for empty classes\n+   that are \"off the end\" of the class.  */\n+\n+static void\n+include_empty_classes (record_layout_info rli)\n+{\n+  tree eoc;\n+\n+  /* It might be the case that we grew the class to allocate a\n+     zero-sized base class.  That won't be reflected in RLI, yet,\n+     because we are willing to overlay multiple bases at the same\n+     offset.  However, now we need to make sure that RLI is big enough\n+     to reflect the entire class.  */\n+  eoc = end_of_class (rli->t, \n+\t\t      CLASSTYPE_AS_BASE (rli->t) != NULL_TREE);\n+  if (TREE_CODE (rli_size_unit_so_far (rli)) == INTEGER_CST\n+      && INT_CST_LT_UNSIGNED (rli_size_unit_so_far (rli), eoc))\n+    {\n+      rli->offset = size_binop (MAX_EXPR, rli->offset, eoc);\n+      rli->bitpos = bitsize_zero_node;\n+    }\n+}\n+\n /* Calculate the TYPE_SIZE, TYPE_ALIGN, etc for T.  Calculate\n    BINFO_OFFSETs for all of the base-classes.  Position the vtable\n    pointer.  Accumulate declared virtual functions on VIRTUALS_P.  */\n@@ -4811,12 +4851,15 @@ layout_class_type (t, empty_p, vfuns_p, virtuals_p)\n   tree field;\n   tree vptr;\n   record_layout_info rli;\n-  unsigned HOST_WIDE_INT eoc;\n   /* Maps offsets (represented as INTEGER_CSTs) to a TREE_LIST of\n      types that appear at that offset.  */\n   splay_tree empty_base_offsets;\n   /* True if the last field layed out was a bit-field.  */\n   bool last_field_was_bitfield = false;\n+  /* The location at which the next field should be inserted.  */\n+  tree *next_field;\n+  /* T, as a base class.  */\n+  tree base_t;\n \n   /* Keep track of the first non-static data member.  */\n   non_static_data_members = TYPE_FIELDS (t);\n@@ -4834,15 +4877,18 @@ layout_class_type (t, empty_p, vfuns_p, virtuals_p)\n   /* The vptr is always the first thing in the class.  */\n   if (vptr)\n     {\n-      TYPE_FIELDS (t) = chainon (vptr, TYPE_FIELDS (t));\n+      TREE_CHAIN (vptr) = TYPE_FIELDS (t);\n+      TYPE_FIELDS (t) = vptr;\n+      next_field = &TREE_CHAIN (vptr);\n       place_field (rli, vptr);\n     }\n+  else\n+    next_field = &TYPE_FIELDS (t);\n \n   /* Build FIELD_DECLs for all of the non-virtual base-types.  */\n   empty_base_offsets = splay_tree_new (splay_tree_compare_integer_csts, \n \t\t\t\t       NULL, NULL);\n-  if (build_base_fields (rli, empty_p, empty_base_offsets, t))\n-    CLASSTYPE_NEARLY_EMPTY_P (t) = 0;\n+  build_base_fields (rli, empty_p, empty_base_offsets, next_field);\n   \n   /* Layout the non-static data members.  */\n   for (field = non_static_data_members; field; field = TREE_CHAIN (field))\n@@ -4917,7 +4963,7 @@ layout_class_type (t, empty_p, vfuns_p, virtuals_p)\n \tpadding = NULL_TREE;\n \n       layout_nonempty_base_or_field (rli, field, NULL_TREE,\n-\t\t\t\t     empty_base_offsets, t);\n+\t\t\t\t     empty_base_offsets);\n \n       /* If a bit-field does not immediately follow another bit-field,\n \t and yet it starts in the middle of a byte, we have failed to\n@@ -4957,76 +5003,59 @@ layout_class_type (t, empty_p, vfuns_p, virtuals_p)\n \t  DECL_USER_ALIGN (padding_field) = 0;\n \t  layout_nonempty_base_or_field (rli, padding_field,\n \t\t\t\t\t NULL_TREE, \n-\t\t\t\t\t empty_base_offsets, t);\n+\t\t\t\t\t empty_base_offsets);\n \t}\n \n       last_field_was_bitfield = DECL_C_BIT_FIELD (field);\n     }\n \n-  /* It might be the case that we grew the class to allocate a\n-     zero-sized base class.  That won't be reflected in RLI, yet,\n-     because we are willing to overlay multiple bases at the same\n-     offset.  However, now we need to make sure that RLI is big enough\n-     to reflect the entire class.  */\n-  eoc = end_of_class (t, /*include_virtuals_p=*/0);\n-  if (TREE_CODE (rli_size_unit_so_far (rli)) == INTEGER_CST\n-      && compare_tree_int (rli_size_unit_so_far (rli), eoc) < 0)\n-    {\n-      rli->offset = size_binop (MAX_EXPR, rli->offset, size_int (eoc));\n-      rli->bitpos = bitsize_zero_node;\n-    }\n-\n-  /* We make all structures have at least one element, so that they\n-     have nonzero size.  The class may be empty even if it has\n-     basetypes.  Therefore, we add the fake field after all the other\n-     fields; if there are already FIELD_DECLs on the list, their\n-     offsets will not be disturbed.  */\n-  if (!eoc && *empty_p)\n-    {\n-      tree padding;\n-\n-      padding = build_decl (FIELD_DECL, NULL_TREE, char_type_node);\n-      place_field (rli, padding);\n-    } \n-  else if (abi_version_at_least (2)\n-\t   && !integer_zerop (rli->bitpos))\n+  if (abi_version_at_least (2) && !integer_zerop (rli->bitpos))\n     /* Make sure that we are on a byte boundary so that the size of\n        the class without virtual bases will always be a round number\n        of bytes.  */\n     rli->bitpos = round_up (rli->bitpos, BITS_PER_UNIT);\n-  \n-  /* Let the back-end lay out the type. Note that at this point we\n-     have only included non-virtual base-classes; we will lay out the\n-     virtual base classes later.  So, the TYPE_SIZE/TYPE_ALIGN after\n-     this call are not necessarily correct; they are just the size and\n-     alignment when no virtual base clases are used.  */\n-  finish_record_layout (rli);\n+\n+  /* Make sure that empty classes are reflected in RLI at this \n+     point.  */\n+  include_empty_classes(rli);\n \n   /* Delete all zero-width bit-fields from the list of fields.  Now\n      that the type is laid out they are no longer important.  */\n   remove_zero_width_bit_fields (t);\n \n-  /* Remember the size and alignment of the class before adding\n-     the virtual bases.  */\n-  if (*empty_p)\n+  /* Create the version of T used for virtual bases.  We do not use\n+     make_aggr_type for this version; this is an artificial type.  For\n+     a POD type, we just reuse T.  */\n+  if (CLASSTYPE_NON_POD_P (t) || *empty_p)\n     {\n-      CLASSTYPE_SIZE (t) = bitsize_zero_node;\n-      CLASSTYPE_SIZE_UNIT (t) = size_zero_node;\n-    }\n-  /* If this is a POD, we can't reuse its tail padding.  */\n-  else if (!CLASSTYPE_NON_POD_P (t))\n-    {\n-      CLASSTYPE_SIZE (t) = TYPE_SIZE (t);\n-      CLASSTYPE_SIZE_UNIT (t) = TYPE_SIZE_UNIT (t);\n+      base_t = make_node (TREE_CODE (t));\n+      \n+      /* Set the size and alignment for the new type.  */\n+      TYPE_SIZE (base_t) = rli_size_so_far (rli);\n+      TYPE_SIZE_UNIT (base_t) = rli_size_unit_so_far (rli);\n+      TYPE_ALIGN (base_t) = rli->record_align;\n+      TYPE_USER_ALIGN (base_t) = TYPE_USER_ALIGN (t);\n+\n+      /* Copy the fields from T.  */\n+      next_field = &TYPE_FIELDS (base_t);\n+      for (field = TYPE_FIELDS (t); field; field = TREE_CHAIN (field))\n+\tif (TREE_CODE (field) == FIELD_DECL)\n+\t  {\n+\t    *next_field = build_decl (FIELD_DECL,\n+\t\t\t\t      DECL_NAME (field), \n+\t\t\t\t      TREE_TYPE (field));\n+\t    DECL_CONTEXT (*next_field) = base_t;\n+\t    DECL_FIELD_OFFSET (*next_field) = DECL_FIELD_OFFSET (field);\n+\t    DECL_FIELD_BIT_OFFSET (*next_field)\n+\t      = DECL_FIELD_BIT_OFFSET (field);\n+\t    next_field = &TREE_CHAIN (*next_field);\n+\t  }\n+\n+      /* Record the base version of the type.  */\n+      CLASSTYPE_AS_BASE (t) = base_t;\n     }\n   else\n-    {\n-      CLASSTYPE_SIZE (t) = TYPE_BINFO_SIZE (t);\n-      CLASSTYPE_SIZE_UNIT (t) = TYPE_BINFO_SIZE_UNIT (t);\n-    }\n-\n-  CLASSTYPE_ALIGN (t) = TYPE_ALIGN (t);\n-  CLASSTYPE_USER_ALIGN (t) = TYPE_USER_ALIGN (t);\n+    CLASSTYPE_AS_BASE (t) = t;\n \n   /* Set the TYPE_DECL for this type to contain the right\n      value for DECL_OFFSET, so that we can use it as part\n@@ -5037,11 +5066,22 @@ layout_class_type (t, empty_p, vfuns_p, virtuals_p)\n      around.  We must get these done before we try to lay out the\n      virtual function table.  As a side-effect, this will remove the\n      base subobject fields.  */\n-  layout_virtual_bases (t, empty_base_offsets);\n+  layout_virtual_bases (rli, empty_base_offsets);\n+\n+  /* Make sure that empty classes are reflected in RLI at this \n+     point.  */\n+  include_empty_classes(rli);\n+\n+  /* Make sure not to create any structures with zero size.  */\n+  if (integer_zerop (rli_size_unit_so_far (rli)) && *empty_p)\n+    place_field (rli, \n+\t\t build_decl (FIELD_DECL, NULL_TREE, char_type_node));\n+\n+  /* Let the back-end lay out the type.  */\n+  finish_record_layout (rli, /*free_p=*/true);\n \n-  /* Warn about direct bases that can't be talked about due to\n-     ambiguity.  */\n-  warn_about_ambiguous_direct_bases (t);\n+  /* Warn about bases that can't be talked about due to ambiguity.  */\n+  warn_about_ambiguous_bases (t);\n \n   /* Clean up.  */\n   splay_tree_delete (empty_base_offsets);\n@@ -6414,7 +6454,9 @@ contains_empty_class_p (tree type)\n \tif (contains_empty_class_p (TYPE_BINFO_BASETYPE (type, i)))\n \t  return true;\n       for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n-\tif (contains_empty_class_p (TREE_TYPE (field)))\n+\tif (TREE_CODE (field) == FIELD_DECL\n+\t    && !DECL_ARTIFICIAL (field)\n+\t    && is_empty_class (TREE_TYPE (field)))\n \t  return true;\n     }\n   else if (TREE_CODE (type) == ARRAY_TYPE)"}, {"sha": "3a9c7e76d710e0510a622b64d1b3db1a94d64b06", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=17bbb839f1270db8e2f99a8f173f38188ad176f3", "patch": "@@ -59,6 +59,7 @@ struct diagnostic_context;\n       INHERITED_VALUE_BINDING_P (in CPLUS_BINDING)\n       ICS_ELLIPSIS_FLAG (in _CONV)\n       BINFO_ACCESS (in BINFO)\n+      DECL_INITIALIZED_P (in VAR_DECL)\n    2: IDENTIFIER_OPNAME_P.\n       TYPE_POLYMORPHIC_P (in _TYPE)\n       ICS_THIS_FLAG (in _CONV)\n@@ -96,11 +97,10 @@ struct diagnostic_context;\n       DECL_MUTABLE_P (in FIELD_DECL)\n    1: C_TYPEDEF_EXPLICITLY_SIGNED (in TYPE_DECL).\n       DECL_TEMPLATE_INSTANTIATED (in a VAR_DECL or a FUNCTION_DECL)\n-      DECL_C_BITFIELD (in FIELD_DECL)\n    2: DECL_THIS_EXTERN (in VAR_DECL or FUNCTION_DECL).\n       DECL_IMPLICIT_TYPEDEF_P (in a TYPE_DECL)\n    3: DECL_IN_AGGR_P.\n-   4: DECL_C_BIT_FIELD\n+   4: DECL_C_BIT_FIELD (in a FIELD_DECL)\n    5: DECL_INTERFACE_KNOWN.\n    6: DECL_THIS_STATIC (in VAR_DECL or FUNCTION_DECL).\n    7: DECL_DEAD_FOR_LOCAL (in VAR_DECL).\n@@ -1150,8 +1150,7 @@ struct lang_type_class GTY(())\n   tree vfields;\n   tree vbases;\n   tree tags;\n-  tree size;\n-  tree size_unit;\n+  tree as_base;\n   tree pure_virtuals;\n   tree friend_classes;\n   tree rtti;\n@@ -1396,12 +1395,17 @@ struct lang_type GTY(())\n #define CLASSTYPE_N_BASECLASSES(NODE) \\\n   (BINFO_N_BASETYPES (TYPE_BINFO (NODE)))\n \n+/* The type corresponding to NODE when NODE is used as a base class,\n+   i.e., NODE without virtual base classes.  */\n+\n+#define CLASSTYPE_AS_BASE(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->as_base)\n+\n /* These are the size and alignment of the type without its virtual\n    base classes, for when we use this type as a base itself.  */\n-#define CLASSTYPE_SIZE(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->size)\n-#define CLASSTYPE_SIZE_UNIT(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->size_unit)\n-#define CLASSTYPE_ALIGN(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->align)\n-#define CLASSTYPE_USER_ALIGN(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->user_align)\n+#define CLASSTYPE_SIZE(NODE) TYPE_SIZE (CLASSTYPE_AS_BASE (NODE))\n+#define CLASSTYPE_SIZE_UNIT(NODE) TYPE_SIZE_UNIT (CLASSTYPE_AS_BASE (NODE))\n+#define CLASSTYPE_ALIGN(NODE) TYPE_ALIGN (CLASSTYPE_AS_BASE (NODE))\n+#define CLASSTYPE_USER_ALIGN(NODE) TYPE_USER_ALIGN (CLASSTYPE_AS_BASE (NODE))\n \n /* The alignment of NODE, without its virtual bases, in bytes.  */\n #define CLASSTYPE_ALIGN_UNIT(NODE) \\\n@@ -1954,6 +1958,11 @@ struct lang_decl GTY(())\n    should be allocated.  */\n #define DECL_IN_AGGR_P(NODE) (DECL_LANG_FLAG_3 (NODE))\n \n+/* Nonzero for a VAR_DECL means that the variable's initialization has\n+   been processed.  */\n+#define DECL_INITIALIZED_P(NODE) \\\n+   (TREE_LANG_FLAG_1 (VAR_DECL_CHECK (NODE)))\n+\n /* Nonzero if the DECL was initialized in the class definition itself,\n    rather than outside the class.  */\n #define DECL_INITIALIZED_IN_CLASS_P(DECL) \\\n@@ -3850,7 +3859,6 @@ extern void check_handlers\t\t\tPARAMS ((tree));\n extern void choose_personality_routine\t\tPARAMS ((enum languages));\n \n /* in expr.c */\n-extern int extract_init\t\t\t\tPARAMS ((tree, tree));\n extern rtx cxx_expand_expr\t\t\tPARAMS ((tree, rtx,\n \t\t\t\t\t\t\t enum machine_mode,\n \t\t\t\t\t\t\t int));\n@@ -3870,7 +3878,7 @@ extern tree build_init\t\t\t\tPARAMS ((tree, tree, int));\n extern int is_aggr_type\t\t\t\tPARAMS ((tree, int));\n extern tree get_aggr_from_typedef\t\tPARAMS ((tree, int));\n extern tree get_type_value\t\t\tPARAMS ((tree));\n-extern tree build_forced_zero_init\t\tPARAMS ((tree));\n+extern tree build_zero_init       \t\t(tree, bool);\n extern tree build_member_call\t\t\tPARAMS ((tree, tree, tree));\n extern tree build_offset_ref\t\t\tPARAMS ((tree, tree));\n extern tree resolve_offset_ref\t\t\tPARAMS ((tree));\n@@ -4344,7 +4352,6 @@ extern tree binfo_or_else\t\t\tPARAMS ((tree, tree));\n extern void readonly_error\t\t\tPARAMS ((tree, const char *, int));\n extern int abstract_virtuals_error\t\tPARAMS ((tree, tree));\n \n-extern tree force_store_init_value\t\tPARAMS ((tree, tree));\n extern tree store_init_value\t\t\tPARAMS ((tree, tree));\n extern tree digest_init\t\t\t\tPARAMS ((tree, tree, tree *));\n extern tree build_scoped_ref\t\t\tPARAMS ((tree, tree, tree *));"}, {"sha": "fb6c776e65fe2606796950ecd00a9e9a13512a2c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 61, "deletions": 73, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=17bbb839f1270db8e2f99a8f173f38188ad176f3", "patch": "@@ -67,7 +67,6 @@ static int ambi_op_p PARAMS ((enum tree_code));\n static int unary_op_p PARAMS ((enum tree_code));\n static tree store_bindings PARAMS ((tree, tree));\n static tree lookup_tag_reverse PARAMS ((tree, tree));\n-static tree obscure_complex_init PARAMS ((tree, tree));\n static tree lookup_name_real PARAMS ((tree, int, int, int));\n static void push_local_name PARAMS ((tree));\n static void warn_extern_redeclared_static PARAMS ((tree, tree));\n@@ -3460,7 +3459,11 @@ duplicate_decls (newdecl, olddecl)\n \tnewtype = oldtype;\n \n       if (TREE_CODE (newdecl) == VAR_DECL)\n-\tDECL_THIS_EXTERN (newdecl) |= DECL_THIS_EXTERN (olddecl);\n+\t{\n+\t  DECL_THIS_EXTERN (newdecl) |= DECL_THIS_EXTERN (olddecl);\n+\t  DECL_INITIALIZED_P (newdecl) |= DECL_INITIALIZED_P (olddecl);\n+\t}\n+\n       /* Do this after calling `merge_types' so that default\n \t parameters don't confuse us.  */\n       else if (TREE_CODE (newdecl) == FUNCTION_DECL\n@@ -7548,45 +7551,6 @@ grok_reference_init (decl, type, init)\n   return NULL_TREE;\n }\n \n-/* Fill in DECL_INITIAL with some magical value to prevent expand_decl from\n-   mucking with forces it does not comprehend (i.e. initialization with a\n-   constructor).  If we are at global scope and won't go into COMMON, fill\n-   it in with a dummy CONSTRUCTOR to force the variable into .data;\n-   otherwise we can use error_mark_node.  */\n-\n-static tree\n-obscure_complex_init (decl, init)\n-     tree decl, init;\n-{\n-  if (TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL (decl))\n-    {\n-      error (\"run-time initialization of thread-local storage\");\n-      return NULL_TREE;\n-    }\n-\n-  if (! flag_no_inline && TREE_STATIC (decl))\n-    {\n-      if (extract_init (decl, init))\n-\treturn NULL_TREE;\n-    }\n-\n-#if ! defined (ASM_OUTPUT_BSS) && ! defined (ASM_OUTPUT_ALIGNED_BSS)\n-  if (toplevel_bindings_p () && ! DECL_COMMON (decl))\n-    DECL_INITIAL (decl) = build (CONSTRUCTOR, TREE_TYPE (decl), NULL_TREE,\n-\t\t\t\t NULL_TREE);\n-  else\n-#endif\n-    {\n-      if (zero_init_p (TREE_TYPE (decl)))\n-\tDECL_INITIAL (decl) = error_mark_node;\n-      /* Otherwise, force_store_init_value will have already stored a\n-\t zero-init initializer in DECL_INITIAL, that should be\n-\t retained.  */\n-    }\n-\n-  return init;\n-}\n-\n /* When parsing `int a[] = {1, 2};' we don't know the size of the\n    array until we finish parsing the initializer.  If that's the\n    situation we're in, update DECL accordingly.  */\n@@ -7773,17 +7737,18 @@ check_initializer (decl, init)\n      tree decl;\n      tree init;\n {\n-  tree type;\n-\n-  if (TREE_CODE (decl) == FIELD_DECL)\n-    return init;\n-\n-  type = TREE_TYPE (decl);\n+  tree type = TREE_TYPE (decl);\n \n   /* If `start_decl' didn't like having an initialization, ignore it now.  */\n   if (init != NULL_TREE && DECL_INITIAL (decl) == NULL_TREE)\n     init = NULL_TREE;\n \n+  /* If an initializer is present, DECL_INITIAL has been\n+     error_mark_node, to indicate that an as-of-yet unevaluated\n+     initialization will occur.  From now on, DECL_INITIAL reflects\n+     the static initialization -- if any -- of DECL.  */\n+  DECL_INITIAL (decl) = NULL_TREE;\n+\n   /* Check the initializer.  */\n   if (init)\n     {\n@@ -7823,21 +7788,9 @@ check_initializer (decl, init)\n       init = NULL_TREE;\n     }\n   else if (!DECL_EXTERNAL (decl) && TREE_CODE (type) == REFERENCE_TYPE)\n-    {\n-      init = grok_reference_init (decl, type, init);\n-      if (init)\n-\tinit = obscure_complex_init (decl, init);\n-    }\n-  else if (!DECL_EXTERNAL (decl) && !zero_init_p (type))\n-    {\n-      force_store_init_value (decl, build_forced_zero_init (type));\n-\n-      if (init)\n-\tgoto process_init;\n-    }\n+    init = grok_reference_init (decl, type, init);\n   else if (init)\n     {\n-    process_init:\n       if (TYPE_HAS_CONSTRUCTOR (type) || TYPE_NEEDS_CONSTRUCTING (type))\n \t{\n \t  if (TREE_CODE (type) == ARRAY_TYPE)\n@@ -7861,11 +7814,6 @@ check_initializer (decl, init)\n \t  if (TREE_CODE (init) != TREE_VEC)\n \t    init = store_init_value (decl, init);\n \t}\n-\n-      if (init)\n-\t/* We must hide the initializer so that expand_decl\n-\t   won't try to do something it does not understand.  */\n-\tinit = obscure_complex_init (decl, init);\n     }\n   else if (DECL_EXTERNAL (decl))\n     ;\n@@ -7884,10 +7832,6 @@ check_initializer (decl, init)\n \t}\n \n       check_for_uninitialized_const_var (decl);\n-\n-      if (COMPLETE_TYPE_P (type) && TYPE_NEEDS_CONSTRUCTING (type))\n-\tinit = obscure_complex_init (decl, NULL_TREE);\n-\n     }\n   else\n     check_for_uninitialized_const_var (decl);\n@@ -8255,10 +8199,54 @@ cp_finish_decl (decl, init, asmspec_tree, flags)\n       SET_DECL_ASSEMBLER_NAME (decl, get_identifier (asmspec));\n       make_decl_rtl (decl, asmspec);\n     }\n-\n-  /* Deduce size of array from initialization, if not already known.  */\n-  init = check_initializer (decl, init);\n-  maybe_deduce_size_from_array_init (decl, init);\n+  else if (TREE_CODE (decl) == RESULT_DECL)\n+    init = check_initializer (decl, init);\n+  else if (TREE_CODE (decl) == VAR_DECL)\n+    {\n+      /* Only PODs can have thread-local storage.  Other types may require\n+\t various kinds of non-trivial initialization.  */\n+      if (DECL_THREAD_LOCAL (decl) && !pod_type_p (TREE_TYPE (decl)))\n+\terror (\"`%D' cannot be thread-local because it has non-POD type `%T'\",\n+\t       decl, TREE_TYPE (decl));\n+      /* Convert the initializer to the type of DECL, if we have not\n+\t already initialized DECL.  */\n+      if (!DECL_INITIALIZED_P (decl)\n+\t  /* If !DECL_EXTERNAL then DECL is being defined.  In the\n+\t     case of a static data memberm initialized inside the\n+\t     class-specifier, there can be an initializer even if DECL\n+\t     is *not* defined.  */\n+\t  && (!DECL_EXTERNAL (decl) || init))\n+\t{\n+\t  init = check_initializer (decl, init);\n+\t  /* If DECL has an array type without a specific bound, deduce the\n+\t     array size from the initializer.  Note that this must be done\n+\t     after check_initializer is called because of cases like this:\n+\t     \n+ \t       struct S { int a; int b; };\n+\t       struct S a[] = { 1, 2 };\n+\t \n+\t     which creates a one-element array, not a two-element array.  */\n+\t  maybe_deduce_size_from_array_init (decl, init);\n+\t  /* Handle:\n+\t     \n+\t     [dcl.init]\n+\t     \n+\t     The memory occupied by any object of static storage\n+\t     duration is zero-initialized at program startup before\n+\t     any other initialization takes place.\n+\t     \n+\t     We cannot create an appropriate initializer until after\n+\t     the type of DECL is finalized.  If DECL_INITIAL is set,\n+\t     then the DECL is statically initialized, and any\n+\t     necessary zero-initialization has already been performed.  */\n+\t  if (TREE_STATIC (decl) && !DECL_INITIAL (decl))\n+\t    DECL_INITIAL (decl) = build_zero_init (TREE_TYPE (decl),\n+\t\t\t\t\t\t   /*static_storage_p=*/true);\n+\t  /* Remember that the initialization for this variable has\n+\t     taken place.  */\n+\t  DECL_INITIALIZED_P (decl) = 1;\n+\t}\n+    }\n \n   /* Add this declaration to the statement-tree.  This needs to happen\n      after the call to check_initializer so that the DECL_STMT for a"}, {"sha": "e5b0439c93d258c499a7b615dcb871acea70f4e7", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=17bbb839f1270db8e2f99a8f173f38188ad176f3", "patch": "@@ -127,11 +127,3 @@ cxx_expand_expr (exp, target, tmode, modifier)\n   /* NOTREACHED */\n   return NULL;\n }\n-\n-int\n-extract_init (decl, init)\n-     tree decl ATTRIBUTE_UNUSED, init ATTRIBUTE_UNUSED;\n-{\n-  return 0;\n-}\n-"}, {"sha": "ec74a25663917e68906cde122a5fb2dc868bb640", "filename": "gcc/cp/init.c", "status": "modified", "additions": 126, "deletions": 45, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=17bbb839f1270db8e2f99a8f173f38188ad176f3", "patch": "@@ -156,70 +156,151 @@ initialize_vtbl_ptrs (addr)\n \t    dfs_marked_real_bases_queue_p, type);\n }\n \n-/* Types containing pointers to data members cannot be\n-   zero-initialized with zeros, because the NULL value for such\n-   pointers is -1.\n-\n-   TYPE is a type that requires such zero initialization.  The\n-   returned value is the initializer.  */\n+/* Return an expression for the zero-initialization of an object with\n+   type T.  This expression will either be a constant (in the case\n+   that T is a scalar), or a CONSTRUCTOR (in the case that T is an\n+   aggregate).  In either case, the value can be used as DECL_INITIAL\n+   for a decl of the indicated TYPE; it is a valid static initializer.\n+   If STATIC_STORAGE_P is TRUE, initializers are only generated for\n+   entities for which zero-initialization does not simply mean filling\n+   the storage with zero bytes.  */\n \n tree\n-build_forced_zero_init (type)\n-     tree type;\n+build_zero_init (tree type, bool static_storage_p)\n {\n-  tree init = NULL;\n+  tree init = NULL_TREE;\n+\n+  /* [dcl.init]\n+\n+     To zero-initialization storage for an object of type T means:\n+\n+     -- if T is a scalar type, the storage is set to the value of zero\n+        converted to T.\n+\n+     -- if T is a non-union class type, the storage for each nonstatic\n+        data member and each base-class subobject is zero-initialized.\n+\n+     -- if T is a union type, the storage for its first data member is\n+        zero-initialized.\n+\n+     -- if T is an array type, the storage for each element is\n+        zero-initialized.\n+\n+     -- if T is a reference type, no initialization is performed.  */\n \n-  if (AGGREGATE_TYPE_P (type) && !TYPE_PTRMEMFUNC_P (type))\n+  if (type == error_mark_node)\n+    ;\n+  else if (static_storage_p && zero_init_p (type))\n+    /* In order to save space, we do not explicitly build initializers\n+       for items that do not need them.  GCC's semantics are that\n+       items with static storage duration that are not otherwise\n+       initialized are initialized to zero.  */\n+    ;\n+  else if (SCALAR_TYPE_P (type))\n+    init = convert (type, integer_zero_node);\n+  else if (CLASS_TYPE_P (type))\n+    {\n+      tree field;\n+      tree inits;\n+\n+      /* Build a constructor to contain the initializations.  */\n+      init = build (CONSTRUCTOR, type, NULL_TREE, NULL_TREE);\n+      /* Iterate over the fields, building initializations.  */\n+      inits = NULL_TREE;\n+      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t{\n+\t  if (TREE_CODE (field) != FIELD_DECL)\n+\t    continue;\n+\n+\t  /* Note that for class types there will be FIELD_DECLs\n+\t     corresponding to base classes as well.  Thus, iterating\n+\t     over TYPE_FIELDs will result in correct initialization of\n+\t     all of the subobjects.  */\n+\t  if (static_storage_p && !zero_init_p (TREE_TYPE (field)))\n+\t    inits = tree_cons (field, \n+\t\t\t       build_zero_init (TREE_TYPE (field),\n+\t\t\t\t\t\tstatic_storage_p),\n+\t\t\t       inits);\n+\n+\t  /* For unions, only the first field is initialized.  */\n+\t  if (TREE_CODE (type) == UNION_TYPE)\n+\t    break;\n+\t}\n+      CONSTRUCTOR_ELTS (init) = nreverse (inits);\n+    }\n+  else if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n-      /* This is a default initialization of an aggregate, but not one of\n-\t non-POD class type.  We cleverly notice that the initialization\n-\t rules in such a case are the same as for initialization with an\n-\t empty brace-initialization list.  */\n-      init = build (CONSTRUCTOR, NULL_TREE, NULL_TREE, NULL_TREE);\n+      tree index;\n+      tree max_index;\n+      tree inits;\n+\n+      /* Build a constructor to contain the initializations.  */\n+      init = build (CONSTRUCTOR, type, NULL_TREE, NULL_TREE);\n+      /* Iterate over the array elements, building initializations.  */\n+      inits = NULL_TREE;\n+      for (index = size_zero_node, max_index = array_type_nelts (type);\n+\t   !tree_int_cst_lt (max_index, index);\n+\t   index = size_binop (PLUS_EXPR, index, size_one_node))\n+\tinits = tree_cons (index,\n+\t\t\t   build_zero_init (TREE_TYPE (type), \n+\t\t\t\t\t    static_storage_p),\n+\t\t\t   inits);\n+      CONSTRUCTOR_ELTS (init) = nreverse (inits);\n     }\n   else if (TREE_CODE (type) == REFERENCE_TYPE)\n-    /*   --if T is a reference type, no initialization is performed.  */\n-    return NULL_TREE;\n+    ;\n   else\n-    {\n-      init = integer_zero_node;\n-      \n-      if (TREE_CODE (type) == ENUMERAL_TYPE)\n-        /* We must make enumeral types the right type.  */\n-        init = fold (build1 (NOP_EXPR, type, init));\n-    }\n+    abort ();\n \n-  init = digest_init (type, init, 0);\n+  /* In all cases, the initializer is a constant.  */\n+  if (init)\n+    TREE_CONSTANT (init) = 1;\n \n   return init;\n }\n \n-/* [dcl.init]:\n+/* Build an expression for the default-initialization of an object\n+   with type T.  If initialization T requires calling constructors,\n+   this function returns NULL_TREE; the caller is responsible for\n+   arranging for the constructors to be called.  */\n \n-  To default-initialize an object of type T means:\n+static tree\n+build_default_init (type)\n+     tree type;\n+{\n+  /* [dcl.init]:\n \n-  --if T is a non-POD class type (clause _class_), the default construc-\n-    tor  for  T is called (and the initialization is ill-formed if T has\n-    no accessible default constructor);\n+    To default-initialize an object of type T means:\n \n-  --if T is an array type, each element is default-initialized;\n+    --if T is a non-POD class type (clause _class_), the default construc-\n+      tor  for  T is called (and the initialization is ill-formed if T has\n+      no accessible default constructor);\n \n-  --otherwise, the storage for the object is zero-initialized.\n+    --if T is an array type, each element is default-initialized;\n \n-  A program that calls for default-initialization of an entity of refer-\n-  ence type is ill-formed.  */\n+    --otherwise, the storage for the object is zero-initialized.\n \n-static tree\n-build_default_init (type)\n-     tree type;\n-{\n+    A program that calls for default-initialization of an entity of refer-\n+    ence type is ill-formed.  */\n+\n+  /* If TYPE_NEEDS_CONSTRUCTING is true, the caller is responsible for\n+     performing the initialization.  This is confusing in that some\n+     non-PODs do not have TYPE_NEEDS_CONSTRUCTING set.  (For example,\n+     a class with a pointer-to-data member as a non-static data member\n+     does not have TYPE_NEEDS_CONSTRUCTING set.)  Therefore, we end up\n+     passing non-PODs to build_zero_init below, which is contrary to\n+     the semantics quoted above from [dcl.init].  \n+\n+     It happens, however, that the behavior of the constructor the\n+     standard says we should have generated would be precisely the\n+     same as that obtained by calling build_zero_init below, so things\n+     work out OK.  */\n   if (TYPE_NEEDS_CONSTRUCTING (type))\n-    /* Other code will handle running the default constructor.  We can't do\n-       anything with a CONSTRUCTOR for arrays here, as that would imply\n-       copy-initialization.  */\n     return NULL_TREE;\n-\n-  return build_forced_zero_init (type);\n+      \n+  /* At this point, TYPE is either a POD class type, an array of POD\n+     classes, or something even more inoccuous.  */\n+  return build_zero_init (type, /*static_storage_p=*/false);\n }\n \n /* Subroutine of emit_base_init.  */\n@@ -335,7 +416,7 @@ build_field_list (t, list, uses_unions_p)\n   for (fields = TYPE_FIELDS (t); fields; fields = TREE_CHAIN (fields))\n     {\n       /* Skip CONST_DECLs for enumeration constants and so forth.  */\n-      if (TREE_CODE (fields) != FIELD_DECL)\n+      if (TREE_CODE (fields) != FIELD_DECL || DECL_ARTIFICIAL (fields))\n \tcontinue;\n       \n       /* Keep track of whether or not any fields are unions.  */\n@@ -3337,7 +3418,7 @@ push_base_cleanups ()\n   for (member = TYPE_FIELDS (current_class_type); member;\n        member = TREE_CHAIN (member))\n     {\n-      if (TREE_CODE (member) != FIELD_DECL)\n+      if (TREE_CODE (member) != FIELD_DECL || DECL_ARTIFICIAL (member))\n \tcontinue;\n       if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (member)))\n \t{"}, {"sha": "6b4b79524fbc048347389440c7c762059387f9e3", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=17bbb839f1270db8e2f99a8f173f38188ad176f3", "patch": "@@ -668,7 +668,7 @@ do_build_assign_ref (fndecl)\n \t  tree comp, init, t;\n \t  tree field = fields;\n \n-\t  if (TREE_CODE (field) != FIELD_DECL)\n+\t  if (TREE_CODE (field) != FIELD_DECL || DECL_ARTIFICIAL (field))\n \t    continue;\n \n \t  if (CP_TYPE_CONST_P (TREE_TYPE (field)))\n@@ -824,7 +824,7 @@ synthesize_exception_spec (type, extractor, client)\n       tree type = TREE_TYPE (fields);\n       tree fn;\n       \n-      if (TREE_CODE (fields) != FIELD_DECL)\n+      if (TREE_CODE (fields) != FIELD_DECL || DECL_ARTIFICIAL (fields))\n         continue;\n       while (TREE_CODE (type) == ARRAY_TYPE)\n   \ttype = TREE_TYPE (type);"}, {"sha": "47421a0b09d642dd3600205105616f9d7ba46622", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=17bbb839f1270db8e2f99a8f173f38188ad176f3", "patch": "@@ -6141,7 +6141,10 @@ tsubst_decl (t, args, type, complain)\n \t/* Even if the original location is out of scope, the newly\n \t   substituted one is not.  */\n \tif (TREE_CODE (r) == VAR_DECL)\n-\t  DECL_DEAD_FOR_LOCAL (r) = 0;\n+\t  {\n+\t    DECL_DEAD_FOR_LOCAL (r) = 0;\n+\t    DECL_INITIALIZED_P (r) = 0;\n+\t  }\n \n \tif (!local_p)\n \t  {\n@@ -9860,9 +9863,10 @@ regenerate_decl_from_template (decl, tmpl)\n   if (TREE_CODE (decl) == VAR_DECL)\n     {\n       /* Set up DECL_INITIAL, since tsubst doesn't.  */\n-      DECL_INITIAL (new_decl) = \n-\ttsubst_expr (DECL_INITIAL (code_pattern), args, \n-\t\t     tf_error, DECL_TI_TEMPLATE (decl));\n+      if (!DECL_INITIALIZED_IN_CLASS_P (decl))\n+\tDECL_INITIAL (new_decl) = \n+\t  tsubst_expr (DECL_INITIAL (code_pattern), args, \n+\t\t       tf_error, DECL_TI_TEMPLATE (decl));\n     }\n   else if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n@@ -10142,7 +10146,10 @@ instantiate_decl (d, defer_ok)\n \t  DECL_EXTERNAL (d) = 1;\n \t  DECL_NOT_REALLY_EXTERN (d) = 1;\n \t}\n-      cp_finish_decl (d, DECL_INITIAL (d), NULL_TREE, 0);\n+      cp_finish_decl (d, \n+\t\t      (!DECL_INITIALIZED_IN_CLASS_P (d) \n+\t\t       ? DECL_INITIAL (d) : NULL_TREE),\n+\t\t      NULL_TREE, 0);\n     }\n   else if (TREE_CODE (d) == FUNCTION_DECL)\n     {"}, {"sha": "3b06a0a0cceda4ffde2295e4cf4a635c449b11ac", "filename": "gcc/cp/search.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=17bbb839f1270db8e2f99a8f173f38188ad176f3", "patch": "@@ -2536,7 +2536,8 @@ dfs_push_decls (binfo, data)\n       for (fields = TYPE_FIELDS (type); fields; fields = TREE_CHAIN (fields))\n \tif (DECL_NAME (fields) \n \t    && TREE_CODE (fields) != TYPE_DECL\n-\t    && TREE_CODE (fields) != USING_DECL)\n+\t    && TREE_CODE (fields) != USING_DECL\n+\t    && !DECL_ARTIFICIAL (fields))\n \t  setup_class_bindings (DECL_NAME (fields), /*type_binding_p=*/0);\n \telse if (TREE_CODE (fields) == FIELD_DECL\n \t\t && ANON_AGGR_TYPE_P (TREE_TYPE (fields)))\n@@ -2597,7 +2598,7 @@ dfs_unuse_fields (binfo, data)\n \n   for (fields = TYPE_FIELDS (type); fields; fields = TREE_CHAIN (fields))\n     {\n-      if (TREE_CODE (fields) != FIELD_DECL)\n+      if (TREE_CODE (fields) != FIELD_DECL || DECL_ARTIFICIAL (fields))\n \tcontinue;\n \n       TREE_USED (fields) = 0;"}, {"sha": "588b7108095e4acafbc9c36a066ac26b7c1acc0f", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=17bbb839f1270db8e2f99a8f173f38188ad176f3", "patch": "@@ -1937,6 +1937,8 @@ pod_type_p (t)\n {\n   t = strip_array_types (t);\n \n+  if (t == error_mark_node)\n+    return 1;\n   if (INTEGRAL_TYPE_P (t))\n     return 1;  /* integral, character or enumeral type */\n   if (FLOAT_TYPE_P (t))\n@@ -1964,6 +1966,9 @@ zero_init_p (t)\n {\n   t = strip_array_types (t);\n \n+  if (t == error_mark_node)\n+    return 1;\n+\n   /* NULL pointers to data members are initialized with -1.  */\n   if (TYPE_PTRMEM_P (t))\n     return 0;"}, {"sha": "ae78dbfee4e09fea7f2903123eaa1b6084c0cd9c", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=17bbb839f1270db8e2f99a8f173f38188ad176f3", "patch": "@@ -1811,7 +1811,7 @@ lookup_anon_field (t, type)\n     {\n       if (TREE_STATIC (field))\n \tcontinue;\n-      if (TREE_CODE (field) != FIELD_DECL)\n+      if (TREE_CODE (field) != FIELD_DECL || DECL_ARTIFICIAL (field))\n \tcontinue;\n \n       /* If we find it directly, return the field.  */"}, {"sha": "fa7f705019d6ef1ea9046135dad2d6b144c4d330", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 6, "deletions": 61, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=17bbb839f1270db8e2f99a8f173f38188ad176f3", "patch": "@@ -320,12 +320,6 @@ store_init_value (decl, init)\n   if (TREE_CODE (type) == ERROR_MARK)\n     return NULL_TREE;\n \n-#if 0\n-  /* This breaks arrays, and should not have any effect for other decls.  */\n-  /* Take care of C++ business up here.  */\n-  type = TYPE_MAIN_VARIANT (type);\n-#endif\n-\n   if (IS_AGGR_TYPE (type))\n     {\n       if (! TYPE_HAS_TRIVIAL_INIT_REF (type)\n@@ -337,35 +331,6 @@ store_init_value (decl, init)\n \t  error (\"constructor syntax used, but no constructor declared for type `%T'\", type);\n \t  init = build_nt (CONSTRUCTOR, NULL_TREE, nreverse (init));\n \t}\n-#if 0\n-      if (TREE_CODE (init) == CONSTRUCTOR)\n-\t{\n-\t  tree field;\n-\n-\t  /* Check that we're really an aggregate as ARM 8.4.1 defines it.  */\n-\t  if (CLASSTYPE_N_BASECLASSES (type))\n-\t    cp_error_at (\"initializer list construction invalid for derived class object `%D'\", decl);\n-\t  if (CLASSTYPE_VTBL_PTR (type))\n-\t    cp_error_at (\"initializer list construction invalid for polymorphic class object `%D'\", decl);\n-\t  if (TYPE_NEEDS_CONSTRUCTING (type))\n-\t    {\n-\t      cp_error_at (\"initializer list construction invalid for `%D'\", decl);\n-\t      error (\"due to the presence of a constructor\");\n-\t    }\n-\t  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n-\t    if (TREE_PRIVATE (field) || TREE_PROTECTED (field))\n-\t      {\n-\t\tcp_error_at (\"initializer list construction invalid for `%D'\", decl);\n-\t\tcp_error_at (\"due to non-public access of member `%D'\", field);\n-\t      }\n-\t  for (field = TYPE_METHODS (type); field; field = TREE_CHAIN (field))\n-\t    if (TREE_PRIVATE (field) || TREE_PROTECTED (field))\n-\t      {\n-\t\tcp_error_at (\"initializer list construction invalid for `%D'\", decl);\n-\t\tcp_error_at (\"due to non-public access of member `%D'\", field);\n-\t      }\n-\t}\n-#endif\n     }\n   else if (TREE_CODE (init) == TREE_LIST\n \t   && TREE_TYPE (init) != unknown_type_node)\n@@ -457,27 +422,6 @@ store_init_value (decl, init)\n   return NULL_TREE;\n }\n \n-/* Same as store_init_value, but used for known-to-be-valid static\n-   initializers.  Used to introduce a static initializer even in data\n-   structures that may require dynamic initialization.  */\n-\n-tree\n-force_store_init_value (decl, init)\n-     tree decl, init;\n-{\n-  tree type = TREE_TYPE (decl);\n-  int needs_constructing = TYPE_NEEDS_CONSTRUCTING (type);\n-\n-  TYPE_NEEDS_CONSTRUCTING (type) = 0;\n-\n-  init = store_init_value (decl, init);\n-  if (init)\n-    abort ();\n-\n-  TYPE_NEEDS_CONSTRUCTING (type) = needs_constructing;\n-\n-  return init;\n-}  \n \f\n /* Digest the parser output INIT as an initializer for type TYPE.\n    Return a C expression of type TYPE to represent the initial value.\n@@ -791,7 +735,8 @@ process_init_constructor (type, init, elts)\n \t      next1 = digest_init (TREE_TYPE (type), next1, 0);\n \t    }\n \t  else if (! zero_init_p (TREE_TYPE (type)))\n-\t    next1 = build_forced_zero_init (TREE_TYPE (type));\n+\t    next1 = build_zero_init (TREE_TYPE (type),\n+\t\t\t\t     /*static_storage_p=*/false);\n \t  else\n \t    /* The default zero-initialization is fine for us; don't\n \t       add anything to the CONSTRUCTOR.  */\n@@ -840,7 +785,7 @@ process_init_constructor (type, init, elts)\n \t      continue;\n \t    }\n \n-\t  if (TREE_CODE (field) != FIELD_DECL)\n+\t  if (TREE_CODE (field) != FIELD_DECL || DECL_ARTIFICIAL (field))\n \t    continue;\n \n \t  if (tail)\n@@ -909,7 +854,8 @@ process_init_constructor (type, init, elts)\n \t\twarning (\"missing initializer for member `%D'\", field);\n \n \t      if (! zero_init_p (TREE_TYPE (field)))\n-\t\tnext1 = build_forced_zero_init (TREE_TYPE (field));\n+\t\tnext1 = build_zero_init (TREE_TYPE (field),\n+\t\t\t\t\t /*static_storage_p=*/false);\n \t      else\n \t\t/* The default zero-initialization is fine for us; don't\n \t\t   add anything to the CONSTRUCTOR.  */\n@@ -933,8 +879,7 @@ process_init_constructor (type, init, elts)\n \n       /* Find the first named field.  ANSI decided in September 1990\n \t that only named fields count here.  */\n-      while (field && (DECL_NAME (field) == 0\n-\t\t       || TREE_CODE (field) != FIELD_DECL))\n+      while (field && (!DECL_NAME (field) || TREE_CODE (field) != FIELD_DECL))\n \tfield = TREE_CHAIN (field);\n \n       /* If this element specifies a field, initialize via that field.  */"}, {"sha": "953d58f75ca8ab8945a14550319d7650473df286", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=17bbb839f1270db8e2f99a8f173f38188ad176f3", "patch": "@@ -1484,11 +1484,14 @@ finalize_type_size (type)\n \n /* Do all of the work required to layout the type indicated by RLI,\n    once the fields have been laid out.  This function will call `free'\n-   for RLI.  */\n+   for RLI, unless FREE_P is false.  Passing a value other than false\n+   for FREE_P is bad practice; this option only exists to support the\n+   G++ 3.2 ABI.  */\n \n void\n-finish_record_layout (rli)\n+finish_record_layout (rli, free_p)\n      record_layout_info rli;\n+     int free_p;\n {\n   /* Compute the final size.  */\n   finalize_record_size (rli);\n@@ -1508,7 +1511,8 @@ finish_record_layout (rli)\n     }\n \n   /* Clean up.  */\n-  free (rli);\n+  if (free_p)\n+    free (rli);\n }\n \f\n /* Calculate the mode, size, and alignment for TYPE.\n@@ -1763,7 +1767,7 @@ layout_type (type)\n \t  (*lang_adjust_rli) (rli);\n \n \t/* Finish laying out the record.  */\n-\tfinish_record_layout (rli);\n+\tfinish_record_layout (rli, /*free_p=*/true);\n       }\n       break;\n "}, {"sha": "d444eea27d5605fe5f380a3514b23dee8621b223", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=17bbb839f1270db8e2f99a8f173f38188ad176f3", "patch": "@@ -1,3 +1,8 @@\n+2002-09-30  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.dg/abi/empty7.C: New test.\n+\t* g++.dg/init/pm2.C: Likewise.\n+\t\n 2002-09-29  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* g++.dg/rtti/crash1.C: New test."}, {"sha": "4b1ac3b2c2cfb8d2276d42c435b67a37f0fa83f8", "filename": "gcc/testsuite/g++.dg/abi/empty7.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fempty7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fempty7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fempty7.C?ref=17bbb839f1270db8e2f99a8f173f38188ad176f3", "patch": "@@ -0,0 +1,18 @@\n+// { dg-do run { target i?86-*-* } }\n+// { dg-options \"-fabi-version=0\" }\n+\n+struct S1 {};\n+struct S2 { virtual void f () {} S1 s1[4]; };\n+struct S3 : virtual public S2 {};\n+struct S4 : virtual public S2 { int i; };\n+struct S5 : public S3, virtual public S4 {};\n+struct S6 { S5 s5; };\n+struct S7 { S1 s1[5]; };\n+struct S8 : public S1, public S6, virtual public S7 { };\n+\n+S8 s8;\n+\n+int main () {\n+  if ((char *)(S7 *)&s8 - (char *)&s8 != 24)\n+    return 1;\n+}"}, {"sha": "35b9b32fea13bea2194093412bf20fe9a0978621", "filename": "gcc/testsuite/g++.dg/init/pm2.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fpm2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fpm2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fpm2.C?ref=17bbb839f1270db8e2f99a8f173f38188ad176f3", "patch": "@@ -0,0 +1,7 @@\n+struct S {\n+  S ();\n+  int S::* sp;\n+  int i;\n+};\n+\n+S s[2] = {};"}, {"sha": "1d0941c323ba3800c93732c823e1f2e6d9bd4ecd", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17bbb839f1270db8e2f99a8f173f38188ad176f3/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=17bbb839f1270db8e2f99a8f173f38188ad176f3", "patch": "@@ -2434,7 +2434,7 @@ extern tree rli_size_so_far\t\tPARAMS ((record_layout_info));\n extern void normalize_rli\t\tPARAMS ((record_layout_info));\n extern void place_field\t\t\tPARAMS ((record_layout_info, tree));\n extern void compute_record_mode\t\tPARAMS ((tree));\n-extern void finish_record_layout\tPARAMS ((record_layout_info));\n+extern void finish_record_layout\tPARAMS ((record_layout_info, int));\n \n /* Given a hashcode and a ..._TYPE node (for which the hashcode was made),\n    return a canonicalized ..._TYPE node, so that duplicates are not made."}]}