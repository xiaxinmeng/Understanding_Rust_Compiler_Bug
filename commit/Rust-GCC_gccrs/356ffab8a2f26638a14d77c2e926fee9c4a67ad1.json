{"sha": "356ffab8a2f26638a14d77c2e926fee9c4a67ad1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU2ZmZhYjhhMmYyNjYzOGExNGQ3N2MyZTkyNmZlZTljNGE2N2FkMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-26T11:38:57Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-26T11:38:57Z"}, "message": "[multiple changes]\n\n2015-10-26  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch4.adb (Is_OK_Object_Reference): New routine.\n\t(Substitute_Valid_Check): Perform the 'Valid subsitution but do\n\tnot suggest the use of the attribute if the left hand operand\n\tdoes not denote an object as it leads to illegal code.\n\n2015-10-26  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_unst.adb: Minor reformatting.\n\n2015-10-26  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb: Improve error msg.\n\nFrom-SVN: r229341", "tree": {"sha": "6b57b662e14baaad6ec855e82f2b88e8717bfc30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b57b662e14baaad6ec855e82f2b88e8717bfc30"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/356ffab8a2f26638a14d77c2e926fee9c4a67ad1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/356ffab8a2f26638a14d77c2e926fee9c4a67ad1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/356ffab8a2f26638a14d77c2e926fee9c4a67ad1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/356ffab8a2f26638a14d77c2e926fee9c4a67ad1/comments", "author": null, "committer": null, "parents": [{"sha": "ec6cfc5dc2d118e005edd98ecfef10de1fc48ad1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec6cfc5dc2d118e005edd98ecfef10de1fc48ad1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec6cfc5dc2d118e005edd98ecfef10de1fc48ad1"}], "stats": {"total": 151, "additions": 106, "deletions": 45}, "files": [{"sha": "244014f20c831ed656f7957ea8039db4072cf83c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/356ffab8a2f26638a14d77c2e926fee9c4a67ad1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/356ffab8a2f26638a14d77c2e926fee9c4a67ad1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=356ffab8a2f26638a14d77c2e926fee9c4a67ad1", "patch": "@@ -1,3 +1,18 @@\n+2015-10-26  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch4.adb (Is_OK_Object_Reference): New routine.\n+\t(Substitute_Valid_Check): Perform the 'Valid subsitution but do\n+\tnot suggest the use of the attribute if the left hand operand\n+\tdoes not denote an object as it leads to illegal code.\n+\n+2015-10-26  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_unst.adb: Minor reformatting.\n+\n+2015-10-26  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb: Improve error msg.\n+\n 2015-10-26  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_disp.adb (Check_Controlling_Type): Handle properly the"}, {"sha": "0b1fe7920a071f0a2914fe4a9048238fab276283", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 58, "deletions": 11, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/356ffab8a2f26638a14d77c2e926fee9c4a67ad1/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/356ffab8a2f26638a14d77c2e926fee9c4a67ad1/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=356ffab8a2f26638a14d77c2e926fee9c4a67ad1", "patch": "@@ -5493,9 +5493,6 @@ package body Exp_Ch4 is\n       Rop    : constant Node_Id    := Right_Opnd (N);\n       Static : constant Boolean    := Is_OK_Static_Expression (N);\n \n-      Ltyp  : Entity_Id;\n-      Rtyp  : Entity_Id;\n-\n       procedure Substitute_Valid_Check;\n       --  Replaces node N by Lop'Valid. This is done when we have an explicit\n       --  test for the left operand being in range of its subtype.\n@@ -5505,6 +5502,49 @@ package body Exp_Ch4 is\n       ----------------------------\n \n       procedure Substitute_Valid_Check is\n+         function Is_OK_Object_Reference (Nod : Node_Id) return Boolean;\n+         --  Determine whether arbitrary node Nod denotes a source object that\n+         --  may safely act as prefix of attribute 'Valid.\n+\n+         ----------------------------\n+         -- Is_OK_Object_Reference --\n+         ----------------------------\n+\n+         function Is_OK_Object_Reference (Nod : Node_Id) return Boolean is\n+            Obj_Ref : Node_Id;\n+\n+         begin\n+            --  Inspect the original operand\n+\n+            Obj_Ref := Original_Node (Nod);\n+\n+            --  The object reference must be a source construct, otherwise the\n+            --  codefix suggestion may refer to nonexistent code from a user\n+            --  perspective.\n+\n+            if Comes_From_Source (Obj_Ref) then\n+\n+               --  Recover the actual object reference. There may be more cases\n+               --  to consider???\n+\n+               loop\n+                  if Nkind_In (Obj_Ref, N_Type_Conversion,\n+                                        N_Unchecked_Type_Conversion)\n+                  then\n+                     Obj_Ref := Expression (Obj_Ref);\n+                  else\n+                     exit;\n+                  end if;\n+               end loop;\n+\n+               return Is_Object_Reference (Obj_Ref);\n+            end if;\n+\n+            return False;\n+         end Is_OK_Object_Reference;\n+\n+      --  Start of processing for Substitute_Valid_Check\n+\n       begin\n          Rewrite (N,\n            Make_Attribute_Reference (Loc,\n@@ -5513,20 +5553,27 @@ package body Exp_Ch4 is\n \n          Analyze_And_Resolve (N, Restyp);\n \n-         --  Give warning unless overflow checking is MINIMIZED or ELIMINATED,\n-         --  in which case, this usage makes sense, and in any case, we have\n-         --  actually eliminated the danger of optimization above.\n+         --  Emit a warning when the left-hand operand of the membership test\n+         --  is a source object, otherwise the use of attribute 'Valid would be\n+         --  illegal. The warning is not given when overflow checking is either\n+         --  MINIMIZED or ELIMINATED, as the danger of optimization has been\n+         --  eliminated above.\n \n-         if Overflow_Check_Mode not in Minimized_Or_Eliminated then\n+         if Is_OK_Object_Reference (Lop)\n+           and then Overflow_Check_Mode not in Minimized_Or_Eliminated\n+         then\n             Error_Msg_N\n               (\"??explicit membership test may be optimized away\", N);\n             Error_Msg_N -- CODEFIX\n               (\"\\??use ''Valid attribute instead\", N);\n          end if;\n-\n-         return;\n       end Substitute_Valid_Check;\n \n+      --  Local variables\n+\n+      Ltyp : Entity_Id;\n+      Rtyp : Entity_Id;\n+\n    --  Start of processing for Expand_N_In\n \n    begin\n@@ -9767,7 +9814,7 @@ package body Exp_Ch4 is\n             if not Is_Discrete_Type (Etype (N)) then\n                null;\n \n-            --  Don't do this on the left hand of an assignment statement.\n+            --  Don't do this on the left-hand side of an assignment statement.\n             --  Normally one would think that references like this would not\n             --  occur, but they do in generated code, and mean that we really\n             --  do want to assign the discriminant.\n@@ -10212,7 +10259,7 @@ package body Exp_Ch4 is\n             Cons := No_List;\n \n             --  If type is unconstrained we have to add a constraint, copied\n-            --  from the actual value of the left hand side.\n+            --  from the actual value of the left-hand side.\n \n             if not Is_Constrained (Target_Type) then\n                if Has_Discriminants (Operand_Type) then"}, {"sha": "5db40e52a8d41ace3e535791046d2a7bd375b643", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 32, "deletions": 33, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/356ffab8a2f26638a14d77c2e926fee9c4a67ad1/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/356ffab8a2f26638a14d77c2e926fee9c4a67ad1/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=356ffab8a2f26638a14d77c2e926fee9c4a67ad1", "patch": "@@ -316,12 +316,12 @@ package body Exp_Unst is\n             Callee : Entity_Id;\n \n             procedure Check_Static_Type (T : Entity_Id; DT : in out Boolean);\n-               --  Given a type T, checks if it is a static type defined as a\n-               --  type with no dynamic bounds in sight. If so, the only action\n-               --  is to set Is_Static_Type True for T. If T is not a static\n-               --  type, then all types with dynamic bounds associated with\n-               --  T are detected, and their bounds are marked as uplevel\n-               --  referenced if not at the library level, and DT is set True.\n+            --  Given a type T, checks if it is a static type defined as a type\n+            --  with no dynamic bounds in sight. If so, the only action is to\n+            --  set Is_Static_Type True for T. If T is not a static type, then\n+            --  all types with dynamic bounds associated with T are detected,\n+            --  and their bounds are marked as uplevel referenced if not at the\n+            --  library level, and DT is set True.\n \n             procedure Note_Uplevel_Ref\n               (E      : Entity_Id;\n@@ -407,7 +407,7 @@ package body Exp_Unst is\n                      end if;\n                   end;\n \n-                  --  For record type, check all components\n+               --  For record type, check all components\n \n                elsif Is_Record_Type (T) then\n                   declare\n@@ -420,7 +420,7 @@ package body Exp_Unst is\n                      end loop;\n                   end;\n \n-                  --  For array type, check index types and component type\n+               --  For array type, check index types and component type\n \n                elsif Is_Array_Type (T) then\n                   declare\n@@ -467,9 +467,9 @@ package body Exp_Unst is\n                if Caller = Callee then\n                   return;\n \n-               --  Callee may be a function that returns an array, and\n-               --  that has been rewritten as a procedure. If caller is\n-               --  that procedure, nothing to do either.\n+               --  Callee may be a function that returns an array, and that has\n+               --  been rewritten as a procedure. If caller is that procedure,\n+               --  nothing to do either.\n \n                elsif Ekind (Callee) = E_Function\n                  and then Rewritten_For_C (Callee)\n@@ -1183,8 +1183,9 @@ package body Exp_Unst is\n \n                      --  Now we can insert the AREC declarations into the body\n \n-                     --  type ARECnT is record .. end record;\n-                     --  pragma Suppress_Initialization (ARECnT);\n+                     --    type ARECnT is record .. end record;\n+                     --    pragma Suppress_Initialization (ARECnT);\n+\n                      --  Note that we need to set the Suppress_Initialization\n                      --  flag after Decl_ARECnT has been analyzed.\n \n@@ -1438,8 +1439,8 @@ package body Exp_Unst is\n                --  probably happens as a result of not properly treating\n                --  instance bodies. To be examined ???\n \n-               --  If this test is omitted, then the compilation of\n-               --  freeze.adb and inline.adb fail in unnesting mode.\n+               --  If this test is omitted, then the compilation of freeze.adb\n+               --  and inline.adb fail in unnesting mode.\n \n                if No (STJR.ARECnF) then\n                   goto Continue;\n@@ -1451,12 +1452,11 @@ package body Exp_Unst is\n \n                Push_Scope (STJR.Ent);\n \n-               --  Now we need to rewrite the reference. We have a\n-               --  reference is from level STJR.Lev to level STJE.Lev.\n-               --  The general form of the rewritten reference for\n-               --  entity X is:\n+               --  Now we need to rewrite the reference. We have a reference\n+               --  from level STJR.Lev to level STJE.Lev. The general form of\n+               --  the rewritten reference for entity X is:\n \n-               --   Typ'Deref (ARECaF.ARECbU.ARECcU.ARECdU....ARECm.X)\n+               --    Typ'Deref (ARECaF.ARECbU.ARECcU.ARECdU....ARECm.X)\n \n                --  where a,b,c,d .. m =\n                --    STJR.Lev - 1,  STJR.Lev - 2, .. STJE.Lev\n@@ -1562,11 +1562,10 @@ package body Exp_Unst is\n          begin\n             if Present (STT.ARECnF) then\n \n-               --  CTJ.N is a call to a subprogram which may require\n-               --  a pointer to an activation record. The subprogram\n-               --  containing the call is CTJ.From and the subprogram being\n-               --  called is CTJ.To, so we have a call from level STF.Lev to\n-               --  level STT.Lev.\n+               --  CTJ.N is a call to a subprogram which may require a pointer\n+               --  to an activation record. The subprogram containing the call\n+               --  is CTJ.From and the subprogram being called is CTJ.To, so we\n+               --  have a call from level STF.Lev to level STT.Lev.\n \n                --  There are three possibilities:\n \n@@ -1576,10 +1575,10 @@ package body Exp_Unst is\n                if STF.Lev = STT.Lev then\n                   Extra := New_Occurrence_Of (STF.ARECnF, Loc);\n \n-               --  For a call that goes down a level, we pass a pointer\n-               --  to the activation record constructed within the caller\n-               --  (which may be the outer level subprogram, but also may\n-               --  be a more deeply nested caller).\n+               --  For a call that goes down a level, we pass a pointer to the\n+               --  activation record constructed within the caller (which may\n+               --  be the outer-level subprogram, but also may be a more deeply\n+               --  nested caller).\n \n                elsif STT.Lev = STF.Lev + 1 then\n                   Extra := New_Occurrence_Of (STF.ARECnP, Loc);\n@@ -1601,9 +1600,9 @@ package body Exp_Unst is\n                   pragma Assert (STT.Lev < STF.Lev);\n \n                   Extra := New_Occurrence_Of (STF.ARECnF, Loc);\n-                  SubX := Subp_Index (CTJ.Caller);\n+                  SubX  := Subp_Index (CTJ.Caller);\n                   for K in reverse STT.Lev .. STF.Lev - 1 loop\n-                     SubX := Enclosing_Subp (SubX);\n+                     SubX  := Enclosing_Subp (SubX);\n                      Extra :=\n                        Make_Selected_Component (Loc,\n                          Prefix        => Extra,\n@@ -1628,8 +1627,8 @@ package body Exp_Unst is\n \n                Append (ExtraP, Parameter_Associations (CTJ.N));\n \n-               --  We need to deal with the actual parameter chain as well.\n-               --  The newly added parameter is always the last actual.\n+               --  We need to deal with the actual parameter chain as well. The\n+               --  newly added parameter is always the last actual.\n \n                Act := First_Named_Actual (CTJ.N);\n "}, {"sha": "d36cf850b4bcfe04f67dbf73ab8958d9e158ec79", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/356ffab8a2f26638a14d77c2e926fee9c4a67ad1/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/356ffab8a2f26638a14d77c2e926fee9c4a67ad1/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=356ffab8a2f26638a14d77c2e926fee9c4a67ad1", "patch": "@@ -674,7 +674,7 @@ package body Sem_Ch6 is\n                              Scope_Depth (Scope (Scope_Id))\n                      then\n                         Error_Msg_N\n-                          (\"access discriminant in return aggregate will be \"\n+                          (\"access discriminant in return aggregate would be \"\n                            & \"a dangling reference\", Obj);\n                      end if;\n                   end if;"}]}