{"sha": "aece2740acb5a0eede12d657076712b3e2e526f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWVjZTI3NDBhY2I1YTBlZWRlMTJkNjU3MDc2NzEyYjNlMmU1MjZmNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-10-15T06:56:28Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-10-15T06:56:28Z"}, "message": "genrecog.c (message_with_line): Prototype.\n\n        * genrecog.c (message_with_line): Prototype.\n        (validate_pattern): Pass along the set for the dest, not a flag.\n        Fix non-lvalue message.  Don't warn for VOIDmode SET_DEST of CALL.\n        Check for PC/CC0 as sources.\n        (nodes_identical): Check for children position match before\n        allowing the combination.\n\n        * rtl.c (read_rtx): Track line number across \\\\\\n.\n\nFrom-SVN: r30010", "tree": {"sha": "b7a113db2ece162dd4d84c92362f8413eba01a45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7a113db2ece162dd4d84c92362f8413eba01a45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aece2740acb5a0eede12d657076712b3e2e526f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aece2740acb5a0eede12d657076712b3e2e526f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aece2740acb5a0eede12d657076712b3e2e526f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aece2740acb5a0eede12d657076712b3e2e526f7/comments", "author": null, "committer": null, "parents": [{"sha": "0e7e91552cd13ba4c9d98876836c0ebe3d28f2b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e7e91552cd13ba4c9d98876836c0ebe3d28f2b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e7e91552cd13ba4c9d98876836c0ebe3d28f2b7"}], "stats": {"total": 92, "additions": 62, "deletions": 30}, "files": [{"sha": "c227608c4d04a967c57a1275c2c1fc4a46a6a520", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aece2740acb5a0eede12d657076712b3e2e526f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aece2740acb5a0eede12d657076712b3e2e526f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aece2740acb5a0eede12d657076712b3e2e526f7", "patch": "@@ -1,3 +1,14 @@\n+Thu Oct 14 23:51:56 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* genrecog.c (message_with_line): Prototype.\n+\t(validate_pattern): Pass along the set for the dest, not a flag.\n+\tFix non-lvalue message.  Don't warn for VOIDmode SET_DEST of CALL.\n+\tCheck for PC/CC0 as sources.\n+\t(nodes_identical): Check for children position match before \n+\tallowing the combination.\n+\n+\t* rtl.c (read_rtx): Track line number across \\\\\\n.\n+\n Thu Oct 14 23:50:25 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* mips.h (SPECIAL_MODE_PREDICATES): New."}, {"sha": "664ef50f55785ffc1aff3ae211f83267ec9eda9f", "filename": "gcc/genrecog.c", "status": "modified", "additions": 49, "deletions": 30, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aece2740acb5a0eede12d657076712b3e2e526f7/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aece2740acb5a0eede12d657076712b3e2e526f7/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=aece2740acb5a0eede12d657076712b3e2e526f7", "patch": "@@ -227,14 +227,17 @@ static const char * special_mode_pred_table[] = {\n #define NUM_SPECIAL_MODE_PREDS \\\n   (sizeof (special_mode_pred_table) / sizeof (special_mode_pred_table[0]))\n \n+static void message_with_line\n+  PVPROTO ((int, const char *, ...)) ATTRIBUTE_PRINTF_2;\n+\n static struct decision *new_decision\n   PROTO((const char *, struct decision_head *));\n static struct decision_test *new_decision_test\n   PROTO((enum decision_type, struct decision_test ***));\n static rtx find_operand\n   PROTO((rtx, int));\n static void validate_pattern\n-  PROTO((rtx, rtx, int));\n+  PROTO((rtx, rtx, rtx));\n static struct decision *add_to_sequence\n   PROTO((rtx, struct decision_head *, const char *, enum routine_type, int));\n \n@@ -418,13 +421,14 @@ find_operand (pattern, n)\n   return NULL;\n }\n \n-/* Check for various errors in patterns.  */\n+/* Check for various errors in patterns.  SET is nonnull for a destination,\n+   and is the complete set pattern.  */\n \n static void\n-validate_pattern (pattern, insn, set_dest)\n+validate_pattern (pattern, insn, set)\n      rtx pattern;\n      rtx insn;\n-     int set_dest;\n+     rtx set;\n {\n   const char *fmt;\n   RTX_CODE code;\n@@ -502,15 +506,28 @@ validate_pattern (pattern, insn, set_dest)\n \t\t}\n \t  }\n \n+\t/* A MATCH_OPERAND that is a SET should have an output reload.  */\n+\tif (set\n+\t    && code == MATCH_OPERAND\n+\t    && XSTR (pattern, 2)[0] != '\\0'\n+\t    && XSTR (pattern, 2)[0] != '='\n+\t    && XSTR (pattern, 2)[0] != '+')\n+\t  {\n+\t    message_with_line (pattern_lineno,\n+\t\t\t       \"operand %d missing output reload\", \n+\t\t\t       XINT (pattern, 0));\n+\t    error_count++;\n+\t  }\n+\n \t/* Allowing non-lvalues in destinations -- particularly CONST_INT --\n \t   while not likely to occur at runtime, results in less efficient\n \t   code from insn-recog.c.  */\n-\tif (set_dest\n+\tif (set\n \t    && pred_name[0] != '\\0'\n \t    && allows_non_lvalue)\n \t  {\n \t    message_with_line (pattern_lineno,\n-\t\t\t\"warning: destination operand 0 allows non-lvalue\",\n+\t\t\t\"warning: destination operand %d allows non-lvalue\",\n \t\t\tXINT (pattern, 0));\n \t  }\n \n@@ -519,7 +536,8 @@ validate_pattern (pattern, insn, set_dest)\n \t   it is a mistake.  Only DEFINE_INSN is eligible, since SPLIT\n \t   and PEEP2 can FAIL within the output pattern.  Exclude \n \t   address_operand, since its mode is related to the mode of\n-\t   the memory not the operand.  */\n+\t   the memory not the operand.  Exclude the SET_DEST of a call\n+\t   instruction, as that is a common idiom.  */\n \n \tif (GET_MODE (pattern) == VOIDmode\n \t    && code == MATCH_OPERAND\n@@ -528,26 +546,15 @@ validate_pattern (pattern, insn, set_dest)\n \t    && ! special_mode_pred\n \t    && pred_name[0] != '\\0'\n \t    && strcmp (pred_name, \"address_operand\") != 0\n-\t    && strstr (c_test, \"operands\") == NULL)\n+\t    && strstr (c_test, \"operands\") == NULL\n+\t    && ! (set\n+\t\t  && GET_CODE (set) == SET\n+\t\t  && GET_CODE (SET_SRC (set)) == CALL))\n \t  {\n \t    message_with_line (pattern_lineno,\n \t\t\t       \"warning: operand %d missing mode?\",\n \t\t\t       XINT (pattern, 0));\n \t  }\n-\n-\t/* A MATCH_OPERAND that is a SET should have an output reload.  */\n-\tif (set_dest\n-\t    && code == MATCH_OPERAND\n-\t    && XSTR (pattern, 2)[0] != '\\0'\n-\t    && XSTR (pattern, 2)[0] != '='\n-\t    && XSTR (pattern, 2)[0] != '+')\n-\t  {\n-\t    message_with_line (pattern_lineno,\n-\t\t\t       \"operand %d missing output reload\", \n-\t\t\t       XINT (pattern, 0));\n-\t    error_count++;\n-\t  }\n-\n \treturn;\n       }\n \n@@ -600,6 +607,8 @@ validate_pattern (pattern, insn, set_dest)\n \telse if (dmode != smode\n \t\t && GET_CODE (dest) != PC\n \t\t && GET_CODE (dest) != CC0\n+\t\t && GET_CODE (src) != PC\n+\t\t && GET_CODE (src) != CC0\n \t\t && GET_CODE (src) != CONST_INT)\n \t  {\n \t    const char *which;\n@@ -609,14 +618,14 @@ validate_pattern (pattern, insn, set_dest)\n \t  }\n \n \tif (dest != SET_DEST (pattern))\n-\t  validate_pattern (dest, insn, 1);\n-\tvalidate_pattern (SET_DEST (pattern), insn, 1);\n-        validate_pattern (SET_SRC (pattern), insn, 0);\n+\t  validate_pattern (dest, insn, pattern);\n+\tvalidate_pattern (SET_DEST (pattern), insn, pattern);\n+        validate_pattern (SET_SRC (pattern), insn, NULL_RTX);\n         return;\n       }\n \n     case CLOBBER:\n-      validate_pattern (SET_DEST (pattern), insn, 1);\n+      validate_pattern (SET_DEST (pattern), insn, pattern);\n       return;\n \n     case LABEL_REF:\n@@ -640,12 +649,12 @@ validate_pattern (pattern, insn, set_dest)\n       switch (fmt[i])\n \t{\n \tcase 'e': case 'u':\n-\t  validate_pattern (XEXP (pattern, i), insn, 0);\n+\t  validate_pattern (XEXP (pattern, i), insn, NULL_RTX);\n \t  break;\n \n \tcase 'E':\n \t  for (j = 0; j < XVECLEN (pattern, i); j++)\n-\t    validate_pattern (XVECEXP (pattern, i, j), insn, 0);\n+\t    validate_pattern (XVECEXP (pattern, i, j), insn, NULL_RTX);\n \t  break;\n \n \tcase 'i': case 'w': case '0': case 's':\n@@ -1219,7 +1228,17 @@ nodes_identical (d1, d2)\n     }\n \n   /* For success, they should now both be null.  */\n-  return t1 == t2;\n+  if (t1 != t2)\n+    return 0;\n+\n+  /* Check that their subnodes are at the same position, as any one set\n+     of sibling decisions must be at the same position.  */\n+  if (d1->success.first\n+      && d2->success.first\n+      && strcmp (d1->success.first->position, d2->success.first->position))\n+    return 0;\n+\n+  return 1;\n }\n \n /* A subroutine of merge_trees; given two nodes that have been declared\n@@ -2313,7 +2332,7 @@ make_insn_sequence (insn, type)\n       PUT_MODE (x, VOIDmode);\n     }\n \n-  validate_pattern (x, insn, 0);\n+  validate_pattern (x, insn, NULL_RTX);\n \n   memset(&head, 0, sizeof(head));\n   last = add_to_sequence (x, &head, \"\", type, 1);"}, {"sha": "282b4a7901f7ff6f679cc6c8ef4c6ede78e944b4", "filename": "gcc/rtl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aece2740acb5a0eede12d657076712b3e2e526f7/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aece2740acb5a0eede12d657076712b3e2e526f7/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=aece2740acb5a0eede12d657076712b3e2e526f7", "patch": "@@ -954,6 +954,8 @@ read_rtx (infile)\n \t\t      obstack_grow (rtl_obstack, \"\\\\n\\\\t\", 4);\n \t\t      continue;\n \t\t    }\n+\t\t  if (c == '\\n')\n+\t\t    read_rtx_lineno++;\n \t\t}\n \t      else if (c == '\"')\n \t\tbreak;"}]}