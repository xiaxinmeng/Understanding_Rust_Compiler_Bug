{"sha": "a7fabf19be96544b4ff7729a326f220ba2e37a27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdmYWJmMTliZTk2NTQ0YjRmZjc3MjlhMzI2ZjIyMGJhMmUzN2EyNw==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@albatross.co.nz", "date": "2001-01-05T23:30:50Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2001-01-05T23:30:50Z"}, "message": "* java/io/PipedReader: Synchronize on \"lock\" instead of this.\n\nFrom-SVN: r38731", "tree": {"sha": "61f27f474c65566bf6aa64809a165e0378fd8e39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61f27f474c65566bf6aa64809a165e0378fd8e39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7fabf19be96544b4ff7729a326f220ba2e37a27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7fabf19be96544b4ff7729a326f220ba2e37a27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7fabf19be96544b4ff7729a326f220ba2e37a27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7fabf19be96544b4ff7729a326f220ba2e37a27/comments", "author": null, "committer": null, "parents": [{"sha": "75b7557d49e09fed027d2f9f819b520bdb6976d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75b7557d49e09fed027d2f9f819b520bdb6976d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75b7557d49e09fed027d2f9f819b520bdb6976d0"}], "stats": {"total": 254, "additions": 135, "deletions": 119}, "files": [{"sha": "1f31191d19589dc93310324bb7b0d4edf25a72dd", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7fabf19be96544b4ff7729a326f220ba2e37a27/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7fabf19be96544b4ff7729a326f220ba2e37a27/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=a7fabf19be96544b4ff7729a326f220ba2e37a27", "patch": "@@ -1,3 +1,7 @@\n+2001-01-06  Bryce McKinlay  <bryce@albatross.co.nz>\n+\n+\t* java/io/PipedReader: Synchronize on \"lock\" instead of this.\n+\n 2001-01-05  Bryce McKinlay  <bryce@albatross.co.nz>\n \n \t* java/lang/Thread.java: Update comment.\n@@ -6,7 +10,7 @@\n \t* java/io/PipedOutputStream: Updated to match new PipedInputStream.\n \t* java/io/PipedReader: New implementation based on new \n \tPipedInputStream.\n-\t* java/io/PipedWriter: Updated to match new PipedOutputStream.\n+\t* java/io/PipedWriter: Updated to match new PipedReader.\n \n 2001-01-03  Tom Tromey  <tromey@redhat.com>\n "}, {"sha": "af375958987088207c1ce2131455fc49b1f77506", "filename": "libjava/java/io/PipedReader.java", "status": "modified", "additions": 130, "deletions": 118, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7fabf19be96544b4ff7729a326f220ba2e37a27/libjava%2Fjava%2Fio%2FPipedReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7fabf19be96544b4ff7729a326f220ba2e37a27/libjava%2Fjava%2Fio%2FPipedReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FPipedReader.java?ref=a7fabf19be96544b4ff7729a326f220ba2e37a27", "patch": "@@ -141,54 +141,57 @@ public void connect(PipedWriter source) throws IOException\n     *           put it here in order to support that bizarre recieve(int)\n     *           method.\n     */  \n-  synchronized void receive(char[] buf, int offset, int len)\n+  void receive(char[] buf, int offset, int len)\n     throws IOException\n   {\n-    if (closed)\n-      throw new IOException (\"Pipe closed\");\n+    synchronized (lock)\n+    {\n+      if (closed)\n+\tthrow new IOException (\"Pipe closed\");\n \n-    int bufpos = offset;\n-    int copylen;\n-    \n-    while (len > 0)\n-      {\n-        try\n-\t  {\n-\t    while (in == out)\n-\t      {\n-\t\t// The pipe is full. Wake up any readers and wait for them.\n-\t\tnotifyAll();\n-\t\twait();\n-\t\t// The pipe could have been closed while we were waiting.\n-\t        if (closed)\n-\t\t  throw new IOException (\"Pipe closed\");\n-\t      }\n-\t  }\n-\tcatch (InterruptedException ix)\n-\t  {\n-            throw new InterruptedIOException ();\n-\t  }\n-\n-\tif (in < 0) // The pipe is empty.\n-\t  in = 0;\n-\t\n-\t// Figure out how many chars from buf can be copied without \n-\t// overrunning out or going past the length of the buffer.\n-\tif (in < out)\n-\t  copylen = Math.min (len, out - in);\n-\telse\n-\t  copylen = Math.min (len, buffer.length - in);\n-\n-\t// Copy chars until the pipe is filled, wrapping if neccessary.\n-\tSystem.arraycopy(buf, bufpos, buffer, in, copylen);\n-\tlen -= copylen;\n-\tbufpos += copylen;\n-\tin += copylen;\n-\tif (in == buffer.length)\n-\t  in = 0;\n-      }\n-    // Notify readers that new data is in the pipe.\n-    notifyAll();\n+      int bufpos = offset;\n+      int copylen;\n+\n+      while (len > 0)\n+\t{\n+          try\n+\t    {\n+\t      while (in == out)\n+\t\t{\n+\t\t  // The pipe is full. Wake up any readers and wait for them.\n+\t\t  lock.notifyAll();\n+\t\t  lock.wait();\n+\t\t  // The pipe could have been closed while we were waiting.\n+\t          if (closed)\n+\t\t    throw new IOException (\"Pipe closed\");\n+\t\t}\n+\t    }\n+\t  catch (InterruptedException ix)\n+\t    {\n+              throw new InterruptedIOException ();\n+\t    }\n+\n+\t  if (in < 0) // The pipe is empty.\n+\t    in = 0;\n+\n+\t  // Figure out how many chars from buf can be copied without \n+\t  // overrunning out or going past the length of the buffer.\n+\t  if (in < out)\n+\t    copylen = Math.min (len, out - in);\n+\t  else\n+\t    copylen = Math.min (len, buffer.length - in);\n+\n+\t  // Copy chars until the pipe is filled, wrapping if neccessary.\n+\t  System.arraycopy(buf, bufpos, buffer, in, copylen);\n+\t  len -= copylen;\n+\t  bufpos += copylen;\n+\t  in += copylen;\n+\t  if (in == buffer.length)\n+\t    in = 0;\n+\t}\n+      // Notify readers that new data is in the pipe.\n+      lock.notifyAll();\n+    }\n   }\n   \n   /**\n@@ -240,84 +243,90 @@ public int read() throws IOException\n     * @exception IOException If <code>close()/code> was called on this Piped\n     *                        Reader.\n     */  \n-  public synchronized int read(char[] buf, int offset, int len)\n+  public int read(char[] buf, int offset, int len)\n     throws IOException\n   {\n-    if (source == null)\n-      throw new IOException (\"Not connected\");\n-    if (closed)\n-      throw new IOException (\"Pipe closed\");\n-\n-    // If the buffer is empty, wait until there is something in the pipe \n-    // to read.\n-    try\n-      {\n-\twhile (in < 0)\n-\t  {\n-\t    if (source.closed)\n-\t      return -1;\n-\t    wait();\n-\t  }\n-      }\n-    catch (InterruptedException ix)\n-      {\n-        throw new InterruptedIOException();\n-      }\n-    \n-    int total = 0;\n-    int copylen;\n-    \n-    while (true)\n-      {\n-\t// Figure out how many chars from the pipe can be copied without \n-\t// overrunning in or going past the length of buf.\n-\tif (out < in)\n-\t  copylen = Math.min (len, in - out);\n-\telse\n-\t  copylen = Math.min (len, buffer.length - out);\n-\n-        System.arraycopy (buffer, out, buf, offset, copylen);\n-\toffset += copylen;\n-\tlen -= copylen;\n-\tout += copylen;\n-\ttotal += copylen;\n-\t\n-\tif (out == buffer.length)\n-\t  out = 0;\n-\t\n-\tif (out == in)\n-\t  {\n-\t    // Pipe is now empty.\n-\t    in = -1;\n+    synchronized (lock)\n+    {\n+      if (source == null)\n+\tthrow new IOException (\"Not connected\");\n+      if (closed)\n+\tthrow new IOException (\"Pipe closed\");\n+\n+      // If the buffer is empty, wait until there is something in the pipe \n+      // to read.\n+      try\n+\t{\n+\t  while (in < 0)\n+\t    {\n+\t      if (source.closed)\n+\t\treturn -1;\n+\t      lock.wait();\n+\t    }\n+\t}\n+      catch (InterruptedException ix)\n+\t{\n+          throw new InterruptedIOException();\n+\t}\n+\n+      int total = 0;\n+      int copylen;\n+\n+      while (true)\n+\t{\n+\t  // Figure out how many chars from the pipe can be copied without \n+\t  // overrunning in or going past the length of buf.\n+\t  if (out < in)\n+\t    copylen = Math.min (len, in - out);\n+\t  else\n+\t    copylen = Math.min (len, buffer.length - out);\n+\n+          System.arraycopy (buffer, out, buf, offset, copylen);\n+\t  offset += copylen;\n+\t  len -= copylen;\n+\t  out += copylen;\n+\t  total += copylen;\n+\n+\t  if (out == buffer.length)\n \t    out = 0;\n-\t  }\n-\n-        // If output buffer is filled or the pipe is empty, we're done.\n-\tif (len == 0 || in == -1)\n-\t  {\n-\t    // Notify any waiting Writer that there is now space\n-\t    // to write.\n-\t    notifyAll();\n-\t    return total;\n-\t  }\n-      }\n+\n+\t  if (out == in)\n+\t    {\n+\t      // Pipe is now empty.\n+\t      in = -1;\n+\t      out = 0;\n+\t    }\n+\n+          // If output buffer is filled or the pipe is empty, we're done.\n+\t  if (len == 0 || in == -1)\n+\t    {\n+\t      // Notify any waiting Writer that there is now space\n+\t      // to write.\n+\t      lock.notifyAll();\n+\t      return total;\n+\t    }\n+\t}\n+    }\n   }\n   \n-  public synchronized boolean ready() throws IOException\n+  public boolean ready() throws IOException\n   {\n     // The JDK 1.3 implementation does not appear to check for the closed or \n     // unconnected stream conditions here.\n     \n-    if (in < 0)\n-      return false;\n-    \n-    int count;\n-    if (out < in)\n-      count = in - out;\n-    else\n-      count = (buffer.length - out) - in;\n-    \n-    return (count > 0);\n+    synchronized (lock)\n+    {\n+      if (in < 0)\n+\treturn false;\n+\n+      int count;\n+      if (out < in)\n+\tcount = in - out;\n+      else\n+\tcount = (buffer.length - out) - in;\n+\n+      return (count > 0);\n+    }\n   }\n   \n   /**\n@@ -326,10 +335,13 @@ public synchronized boolean ready() throws IOException\n   *\n   * @exception IOException If an error occurs\n   */\n-  public synchronized void close() throws IOException\n+  public void close() throws IOException\n   {\n-    closed = true;\n-    // Wake any thread which may be in receive() waiting to write data.\n-    notifyAll();\n+    synchronized (lock)\n+    {\n+      closed = true;\n+      // Wake any thread which may be in receive() waiting to write data.\n+      lock.notifyAll();\n+    }\n   }\n }"}]}