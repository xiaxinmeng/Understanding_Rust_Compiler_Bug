{"sha": "b48d4e6818674898f90d9358378c127511ef0f9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ4ZDRlNjgxODY3NDg5OGY5MGQ5MzU4Mzc4YzEyNzUxMWVmMGY5Zg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-08-17T20:49:05Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-08-17T20:49:05Z"}, "message": "Move more warning code to gimple-ssa-warn-access etc.\n\nAlso resolves:\nPR middle-end/101854 - Invalid warning -Wstringop-overflow wrong argument\n\ngcc/ChangeLog:\n\n\tPR middle-end/101854\n\t* builtins.c (expand_builtin_alloca): Move warning code to check_alloca\n\tin gimple-ssa-warn-access.cc.\n\t* calls.c (alloc_max_size): Move code to check_alloca.\n\t(get_size_range): Move to pointer-query.cc.\n\t(maybe_warn_alloc_args_overflow): Move to gimple-ssa-warn-access.cc.\n\t(get_attr_nonstring_decl): Move to tree.c.\n\t(fntype_argno_type): Move to gimple-ssa-warn-access.cc.\n\t(append_attrname): Same.\n\t(maybe_warn_rdwr_sizes): Same.\n\t(initialize_argument_information): Move code to\n\tgimple-ssa-warn-access.cc.\n\t* calls.h (maybe_warn_alloc_args_overflow): Move to\n\tgimple-ssa-warn-access.h.\n\t(get_attr_nonstring_decl): Move to tree.h.\n\t(maybe_warn_nonstring_arg):  Move to gimple-ssa-warn-access.h.\n\t(enum size_range_flags): Move to pointer-query.h.\n\t(get_size_range): Same.\n\t* gimple-ssa-warn-access.cc (has_location): Remove unused overload\n\tto avoid Clang -Wunused-function.\n\t(get_size_range): Declare static.\n\t(maybe_emit_free_warning): Rename...\n\t(maybe_check_dealloc_call): ...to this for consistency.\n\t(class pass_waccess): Add members.\n\t(pass_waccess::~pass_waccess): Defined.\n\t(alloc_max_size): Move here from calls.c.\n\t(maybe_warn_alloc_args_overflow): Same.\n\t(check_alloca): New function.\n\t(check_alloc_size_call): New function.\n\t(check_strncat): Handle another warning flag.\n\t(pass_waccess::check_builtin): Handle alloca.\n\t(fntype_argno_type): Move here from calls.c.\n\t(append_attrname): Same.\n\t(maybe_warn_rdwr_sizes): Same.\n\t(pass_waccess::check_call): Define.\n\t(check_nonstring_args): New function.\n\t(pass_waccess::check): Call new member functions.\n\t(pass_waccess::execute): Enable ranger.\n\t* gimple-ssa-warn-access.h (get_size_range): Move here from calls.h.\n\t(maybe_warn_nonstring_arg): Same.\n\t* gimple-ssa-warn-restrict.c: Remove #include.\n\t* pointer-query.cc (get_size_range): Move here from calls.c.\n\t* pointer-query.h (enum size_range_flags): Same.\n\t(get_size_range): Same.\n\t* tree.c (get_attr_nonstring_decl): Move here from calls.c.\n\t* tree.h (get_attr_nonstring_decl): Move here from calls.h.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/attr-alloc_size-5.c: Adjust optimization to -O1.\n\t* gcc.dg/attr-alloc_size-7.c: Use #pragmas to adjust optimization.\n\t* gcc.dg/attr-alloc_size-8.c: Adjust optimization to -O1.\n\n\tPR middle-end/101854\n\t* gcc.dg/Wstringop-overflow-72.c: New test.", "tree": {"sha": "8a9ba017b48f620474808116b309ca78335e0a94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a9ba017b48f620474808116b309ca78335e0a94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b48d4e6818674898f90d9358378c127511ef0f9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b48d4e6818674898f90d9358378c127511ef0f9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b48d4e6818674898f90d9358378c127511ef0f9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b48d4e6818674898f90d9358378c127511ef0f9f/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32c3a75390623a0470df52af13f78baddd562981", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32c3a75390623a0470df52af13f78baddd562981", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32c3a75390623a0470df52af13f78baddd562981"}], "stats": {"total": 1813, "additions": 952, "deletions": 861}, "files": [{"sha": "9954862776125515090e874808983b79e5855ad1", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48d4e6818674898f90d9358378c127511ef0f9f/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48d4e6818674898f90d9358378c127511ef0f9f/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=b48d4e6818674898f90d9358378c127511ef0f9f", "patch": "@@ -43,7 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"alias.h\"\n #include \"fold-const.h\"\n #include \"fold-const-call.h\"\n-#include \"gimple-ssa-warn-restrict.h\"\n+#include \"gimple-ssa-warn-access.h\"\n #include \"stor-layout.h\"\n #include \"calls.h\"\n #include \"varasm.h\"\n@@ -81,7 +81,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"demangle.h\"\n #include \"gimple-range.h\"\n #include \"pointer-query.h\"\n-#include \"gimple-ssa-warn-access.h\"\n \n struct target_builtins default_target_builtins;\n #if SWITCHABLE_TARGET\n@@ -4896,25 +4895,6 @@ expand_builtin_alloca (tree exp)\n   if (!valid_arglist)\n     return NULL_RTX;\n \n-  if ((alloca_for_var\n-       && warn_vla_limit >= HOST_WIDE_INT_MAX\n-       && warn_alloc_size_limit < warn_vla_limit)\n-      || (!alloca_for_var\n-\t  && warn_alloca_limit >= HOST_WIDE_INT_MAX\n-\t  && warn_alloc_size_limit < warn_alloca_limit\n-\t  ))\n-    {\n-      /* -Walloca-larger-than and -Wvla-larger-than settings of\n-\t less than HOST_WIDE_INT_MAX override the more general\n-\t -Walloc-size-larger-than so unless either of the former\n-\t options is smaller than the last one (wchich would imply\n-\t that the call was already checked), check the alloca\n-\t arguments for overflow.  */\n-      tree args[] = { CALL_EXPR_ARG (exp, 0), NULL_TREE };\n-      int idx[] = { 0, -1 };\n-      maybe_warn_alloc_args_overflow (fndecl, exp, args, idx);\n-    }\n-\n   /* Compute the argument.  */\n   op0 = expand_normal (CALL_EXPR_ARG (exp, 0));\n "}, {"sha": "e50d3fc3b62080b0e59630c247f7a55aec17eb56", "filename": "gcc/calls.c", "status": "modified", "additions": 0, "deletions": 760, "changes": 760, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48d4e6818674898f90d9358378c127511ef0f9f/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48d4e6818674898f90d9358378c127511ef0f9f/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=b48d4e6818674898f90d9358378c127511ef0f9f", "patch": "@@ -17,7 +17,6 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-#define INCLUDE_STRING\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -50,7 +49,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"rtl-iter.h\"\n #include \"tree-vrp.h\"\n #include \"tree-ssanames.h\"\n-#include \"tree-ssa-strlen.h\"\n #include \"intl.h\"\n #include \"stringpool.h\"\n #include \"hash-map.h\"\n@@ -60,8 +58,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-fold.h\"\n #include \"attr-fnspec.h\"\n #include \"value-query.h\"\n-#include \"pointer-query.h\"\n-#include \"gimple-ssa-warn-access.h\"\n #include \"tree-pretty-print.h\"\n \n /* Like PREFERRED_STACK_BOUNDARY but in units of bytes, not bits.  */\n@@ -1223,397 +1219,6 @@ store_unaligned_arguments_into_pseudos (struct arg_data *args, int num_actuals)\n       }\n }\n \n-/* The limit set by -Walloc-larger-than=.  */\n-static GTY(()) tree alloc_object_size_limit;\n-\n-/* Initialize ALLOC_OBJECT_SIZE_LIMIT based on the -Walloc-size-larger-than=\n-   setting if the option is specified, or to the maximum object size if it\n-   is not.  Return the initialized value.  */\n-\n-static tree\n-alloc_max_size (void)\n-{\n-  if (alloc_object_size_limit)\n-    return alloc_object_size_limit;\n-\n-  HOST_WIDE_INT limit = warn_alloc_size_limit;\n-  if (limit == HOST_WIDE_INT_MAX)\n-    limit = tree_to_shwi (TYPE_MAX_VALUE (ptrdiff_type_node));\n-\n-  alloc_object_size_limit = build_int_cst (size_type_node, limit);\n-\n-  return alloc_object_size_limit;\n-}\n-\n-/* Return true when EXP's range can be determined and set RANGE[] to it\n-   after adjusting it if necessary to make EXP a represents a valid size\n-   of object, or a valid size argument to an allocation function declared\n-   with attribute alloc_size (whose argument may be signed), or to a string\n-   manipulation function like memset.\n-   When ALLOW_ZERO is set in FLAGS, allow returning a range of [0, 0] for\n-   a size in an anti-range [1, N] where N > PTRDIFF_MAX.  A zero range is\n-   a (nearly) invalid argument to allocation functions like malloc but it\n-   is a valid argument to functions like memset.\n-   When USE_LARGEST is set in FLAGS set RANGE to the largest valid subrange\n-   in a multi-range, otherwise to the smallest valid subrange.  */\n-\n-bool\n-get_size_range (range_query *query, tree exp, gimple *stmt, tree range[2],\n-\t\tint flags /* = 0 */)\n-{\n-  if (!exp)\n-    return false;\n-\n-  if (tree_fits_uhwi_p (exp))\n-    {\n-      /* EXP is a constant.  */\n-      range[0] = range[1] = exp;\n-      return true;\n-    }\n-\n-  tree exptype = TREE_TYPE (exp);\n-  bool integral = INTEGRAL_TYPE_P (exptype);\n-\n-  wide_int min, max;\n-  enum value_range_kind range_type;\n-\n-  if (!query)\n-    query = get_global_range_query ();\n-\n-  if (integral)\n-    {\n-      value_range vr;\n-\n-      query->range_of_expr (vr, exp, stmt);\n-\n-      if (vr.undefined_p ())\n-\tvr.set_varying (TREE_TYPE (exp));\n-      range_type = vr.kind ();\n-      min = wi::to_wide (vr.min ());\n-      max = wi::to_wide (vr.max ());\n-    }\n-  else\n-    range_type = VR_VARYING;\n-\n-  if (range_type == VR_VARYING)\n-    {\n-      if (integral)\n-\t{\t\n-\t  /* Use the full range of the type of the expression when\n-\t     no value range information is available.  */\n-\t  range[0] = TYPE_MIN_VALUE (exptype);\n-\t  range[1] = TYPE_MAX_VALUE (exptype);\n-\t  return true;\n-\t}\n-\n-      range[0] = NULL_TREE;\n-      range[1] = NULL_TREE;\n-      return false;\n-    }\n-\n-  unsigned expprec = TYPE_PRECISION (exptype);\n-\n-  bool signed_p = !TYPE_UNSIGNED (exptype);\n-\n-  if (range_type == VR_ANTI_RANGE)\n-    {\n-      if (signed_p)\n-\t{\n-\t  if (wi::les_p (max, 0))\n-\t    {\n-\t      /* EXP is not in a strictly negative range.  That means\n-\t\t it must be in some (not necessarily strictly) positive\n-\t\t range which includes zero.  Since in signed to unsigned\n-\t\t conversions negative values end up converted to large\n-\t\t positive values, and otherwise they are not valid sizes,\n-\t\t the resulting range is in both cases [0, TYPE_MAX].  */\n-\t      min = wi::zero (expprec);\n-\t      max = wi::to_wide (TYPE_MAX_VALUE (exptype));\n-\t    }\n-\t  else if (wi::les_p (min - 1, 0))\n-\t    {\n-\t      /* EXP is not in a negative-positive range.  That means EXP\n-\t\t is either negative, or greater than max.  Since negative\n-\t\t sizes are invalid make the range [MAX + 1, TYPE_MAX].  */\n-\t      min = max + 1;\n-\t      max = wi::to_wide (TYPE_MAX_VALUE (exptype));\n-\t    }\n-\t  else\n-\t    {\n-\t      max = min - 1;\n-\t      min = wi::zero (expprec);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  wide_int maxsize = wi::to_wide (max_object_size ());\n-\t  min = wide_int::from (min, maxsize.get_precision (), UNSIGNED);\n-\t  max = wide_int::from (max, maxsize.get_precision (), UNSIGNED);\n-\t  if (wi::eq_p (0, min - 1))\n-\t    {\n-\t      /* EXP is unsigned and not in the range [1, MAX].  That means\n-\t\t it's either zero or greater than MAX.  Even though 0 would\n-\t\t normally be detected by -Walloc-zero, unless ALLOW_ZERO\n-\t\t is set, set the range to [MAX, TYPE_MAX] so that when MAX\n-\t\t is greater than the limit the whole range is diagnosed.  */\n-\t      wide_int maxsize = wi::to_wide (max_object_size ());\n-\t      if (flags & SR_ALLOW_ZERO)\n-\t\t{\n-\t\t  if (wi::leu_p (maxsize, max + 1)\n-\t\t      || !(flags & SR_USE_LARGEST))\n-\t\t    min = max = wi::zero (expprec);\n-\t\t  else\n-\t\t    {\n-\t\t      min = max + 1;\n-\t\t      max = wi::to_wide (TYPE_MAX_VALUE (exptype));\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  min = max + 1;\n-\t\t  max = wi::to_wide (TYPE_MAX_VALUE (exptype));\n-\t\t}\n-\t    }\n-\t  else if ((flags & SR_USE_LARGEST)\n-\t\t   && wi::ltu_p (max + 1, maxsize))\n-\t    {\n-\t      /* When USE_LARGEST is set and the larger of the two subranges\n-\t\t is a valid size, use it...  */\n-\t      min = max + 1;\n-\t      max = maxsize;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* ...otherwise use the smaller subrange.  */\n-\t      max = min - 1;\n-\t      min = wi::zero (expprec);\n-\t    }\n-\t}\n-    }\n-\n-  range[0] = wide_int_to_tree (exptype, min);\n-  range[1] = wide_int_to_tree (exptype, max);\n-\n-  return true;\n-}\n-\n-bool\n-get_size_range (tree exp, tree range[2], int flags /* = 0 */)\n-{\n-  return get_size_range (/*query=*/NULL, exp, /*stmt=*/NULL, range, flags);\n-}\n-\n-/* Diagnose a call EXP to function FN decorated with attribute alloc_size\n-   whose argument numbers given by IDX with values given by ARGS exceed\n-   the maximum object size or cause an unsigned oveflow (wrapping) when\n-   multiplied.  FN is null when EXP is a call via a function pointer.\n-   When ARGS[0] is null the function does nothing.  ARGS[1] may be null\n-   for functions like malloc, and non-null for those like calloc that\n-   are decorated with a two-argument attribute alloc_size.  */\n-\n-void\n-maybe_warn_alloc_args_overflow (tree fn, tree exp, tree args[2], int idx[2])\n-{\n-  /* The range each of the (up to) two arguments is known to be in.  */\n-  tree argrange[2][2] = { { NULL_TREE, NULL_TREE }, { NULL_TREE, NULL_TREE } };\n-\n-  /* Maximum object size set by -Walloc-size-larger-than= or SIZE_MAX / 2.  */\n-  tree maxobjsize = alloc_max_size ();\n-\n-  location_t loc = EXPR_LOCATION (exp);\n-\n-  tree fntype = fn ? TREE_TYPE (fn) : TREE_TYPE (TREE_TYPE (exp));\n-  bool warned = false;\n-\n-  /* Validate each argument individually.  */\n-  for (unsigned i = 0; i != 2 && args[i]; ++i)\n-    {\n-      if (TREE_CODE (args[i]) == INTEGER_CST)\n-\t{\n-\t  argrange[i][0] = args[i];\n-\t  argrange[i][1] = args[i];\n-\n-\t  if (tree_int_cst_lt (args[i], integer_zero_node))\n-\t    {\n-\t      warned = warning_at (loc, OPT_Walloc_size_larger_than_,\n-\t\t\t\t   \"argument %i value %qE is negative\",\n-\t\t\t\t   idx[i] + 1, args[i]);\n-\t    }\n-\t  else if (integer_zerop (args[i]))\n-\t    {\n-\t      /* Avoid issuing -Walloc-zero for allocation functions other\n-\t\t than __builtin_alloca that are declared with attribute\n-\t\t returns_nonnull because there's no portability risk.  This\n-\t\t avoids warning for such calls to libiberty's xmalloc and\n-\t\t friends.\n-\t\t Also avoid issuing the warning for calls to function named\n-\t\t \"alloca\".  */\n-\t      if (fn && fndecl_built_in_p (fn, BUILT_IN_ALLOCA)\n-\t\t  ? IDENTIFIER_LENGTH (DECL_NAME (fn)) != 6\n-\t\t  : !lookup_attribute (\"returns_nonnull\",\n-\t\t\t\t       TYPE_ATTRIBUTES (fntype)))\n-\t\twarned = warning_at (loc, OPT_Walloc_zero,\n-\t\t\t\t     \"argument %i value is zero\",\n-\t\t\t\t     idx[i] + 1);\n-\t    }\n-\t  else if (tree_int_cst_lt (maxobjsize, args[i]))\n-\t    {\n-\t      /* G++ emits calls to ::operator new[](SIZE_MAX) in C++98\n-\t\t mode and with -fno-exceptions as a way to indicate array\n-\t\t size overflow.  There's no good way to detect C++98 here\n-\t\t so avoid diagnosing these calls for all C++ modes.  */\n-\t      if (i == 0\n-\t\t  && fn\n-\t\t  && !args[1]\n-\t\t  && lang_GNU_CXX ()\n-\t\t  && DECL_IS_OPERATOR_NEW_P (fn)\n-\t\t  && integer_all_onesp (args[i]))\n-\t\tcontinue;\n-\n-\t      warned = warning_at (loc, OPT_Walloc_size_larger_than_,\n-\t\t\t\t   \"argument %i value %qE exceeds \"\n-\t\t\t\t   \"maximum object size %E\",\n-\t\t\t\t   idx[i] + 1, args[i], maxobjsize);\n-\t    }\n-\t}\n-      else if (TREE_CODE (args[i]) == SSA_NAME\n-\t       && get_size_range (args[i], argrange[i]))\n-\t{\n-\t  /* Verify that the argument's range is not negative (including\n-\t     upper bound of zero).  */\n-\t  if (tree_int_cst_lt (argrange[i][0], integer_zero_node)\n-\t      && tree_int_cst_le (argrange[i][1], integer_zero_node))\n-\t    {\n-\t      warned = warning_at (loc, OPT_Walloc_size_larger_than_,\n-\t\t\t\t   \"argument %i range [%E, %E] is negative\",\n-\t\t\t\t   idx[i] + 1,\n-\t\t\t\t   argrange[i][0], argrange[i][1]);\n-\t    }\n-\t  else if (tree_int_cst_lt (maxobjsize, argrange[i][0]))\n-\t    {\n-\t      warned = warning_at (loc, OPT_Walloc_size_larger_than_,\n-\t\t\t\t   \"argument %i range [%E, %E] exceeds \"\n-\t\t\t\t   \"maximum object size %E\",\n-\t\t\t\t   idx[i] + 1,\n-\t\t\t\t   argrange[i][0], argrange[i][1],\n-\t\t\t\t   maxobjsize);\n-\t    }\n-\t}\n-    }\n-\n-  if (!argrange[0])\n-    return;\n-\n-  /* For a two-argument alloc_size, validate the product of the two\n-     arguments if both of their values or ranges are known.  */\n-  if (!warned && tree_fits_uhwi_p (argrange[0][0])\n-      && argrange[1][0] && tree_fits_uhwi_p (argrange[1][0])\n-      && !integer_onep (argrange[0][0])\n-      && !integer_onep (argrange[1][0]))\n-    {\n-      /* Check for overflow in the product of a function decorated with\n-\t attribute alloc_size (X, Y).  */\n-      unsigned szprec = TYPE_PRECISION (size_type_node);\n-      wide_int x = wi::to_wide (argrange[0][0], szprec);\n-      wide_int y = wi::to_wide (argrange[1][0], szprec);\n-\n-      wi::overflow_type vflow;\n-      wide_int prod = wi::umul (x, y, &vflow);\n-\n-      if (vflow)\n-\twarned = warning_at (loc, OPT_Walloc_size_larger_than_,\n-\t\t\t     \"product %<%E * %E%> of arguments %i and %i \"\n-\t\t\t     \"exceeds %<SIZE_MAX%>\",\n-\t\t\t     argrange[0][0], argrange[1][0],\n-\t\t\t     idx[0] + 1, idx[1] + 1);\n-      else if (wi::ltu_p (wi::to_wide (maxobjsize, szprec), prod))\n-\twarned = warning_at (loc, OPT_Walloc_size_larger_than_,\n-\t\t\t     \"product %<%E * %E%> of arguments %i and %i \"\n-\t\t\t     \"exceeds maximum object size %E\",\n-\t\t\t     argrange[0][0], argrange[1][0],\n-\t\t\t     idx[0] + 1, idx[1] + 1,\n-\t\t\t     maxobjsize);\n-\n-      if (warned)\n-\t{\n-\t  /* Print the full range of each of the two arguments to make\n-\t     it clear when it is, in fact, in a range and not constant.  */\n-\t  if (argrange[0][0] != argrange [0][1])\n-\t    inform (loc, \"argument %i in the range [%E, %E]\",\n-\t\t    idx[0] + 1, argrange[0][0], argrange[0][1]);\n-\t  if (argrange[1][0] != argrange [1][1])\n-\t    inform (loc, \"argument %i in the range [%E, %E]\",\n-\t\t    idx[1] + 1, argrange[1][0], argrange[1][1]);\n-\t}\n-    }\n-\n-  if (warned && fn)\n-    {\n-      location_t fnloc = DECL_SOURCE_LOCATION (fn);\n-\n-      if (DECL_IS_UNDECLARED_BUILTIN (fn))\n-\tinform (loc,\n-\t\t\"in a call to built-in allocation function %qD\", fn);\n-      else\n-\tinform (fnloc,\n-\t\t\"in a call to allocation function %qD declared here\", fn);\n-    }\n-}\n-\n-/* If EXPR refers to a character array or pointer declared attribute\n-   nonstring return a decl for that array or pointer and set *REF to\n-   the referenced enclosing object or pointer.  Otherwise returns\n-   null.  */\n-\n-tree\n-get_attr_nonstring_decl (tree expr, tree *ref)\n-{\n-  tree decl = expr;\n-  tree var = NULL_TREE;\n-  if (TREE_CODE (decl) == SSA_NAME)\n-    {\n-      gimple *def = SSA_NAME_DEF_STMT (decl);\n-\n-      if (is_gimple_assign (def))\n-\t{\n-\t  tree_code code = gimple_assign_rhs_code (def);\n-\t  if (code == ADDR_EXPR\n-\t      || code == COMPONENT_REF\n-\t      || code == VAR_DECL)\n-\t    decl = gimple_assign_rhs1 (def);\n-\t}\n-      else\n-\tvar = SSA_NAME_VAR (decl);\n-    }\n-\n-  if (TREE_CODE (decl) == ADDR_EXPR)\n-    decl = TREE_OPERAND (decl, 0);\n-\n-  /* To simplify calling code, store the referenced DECL regardless of\n-     the attribute determined below, but avoid storing the SSA_NAME_VAR\n-     obtained above (it's not useful for dataflow purposes).  */\n-  if (ref)\n-    *ref = decl;\n-\n-  /* Use the SSA_NAME_VAR that was determined above to see if it's\n-     declared nonstring.  Otherwise drill down into the referenced\n-     DECL.  */\n-  if (var)\n-    decl = var;\n-  else if (TREE_CODE (decl) == ARRAY_REF)\n-    decl = TREE_OPERAND (decl, 0);\n-  else if (TREE_CODE (decl) == COMPONENT_REF)\n-    decl = TREE_OPERAND (decl, 1);\n-  else if (TREE_CODE (decl) == MEM_REF)\n-    return get_attr_nonstring_decl (TREE_OPERAND (decl, 0), ref);\n-\n-  if (DECL_P (decl)\n-      && lookup_attribute (\"nonstring\", DECL_ATTRIBUTES (decl)))\n-    return decl;\n-\n-  return NULL_TREE;\n-}\n-\n /* Issue an error if CALL_EXPR was flagged as requiring\n    tall-call optimization.  */\n \n@@ -1627,310 +1232,6 @@ maybe_complain_about_tail_call (tree call_expr, const char *reason)\n   error_at (EXPR_LOCATION (call_expr), \"cannot tail-call: %s\", reason);\n }\n \n-/* Returns the type of the argument ARGNO to function with type FNTYPE\n-   or null when the typoe cannot be determined or no such argument exists.  */\n-\n-static tree\n-fntype_argno_type (tree fntype, unsigned argno)\n-{\n-  if (!prototype_p (fntype))\n-    return NULL_TREE;\n-\n-  tree argtype;\n-  function_args_iterator it;\n-  FOREACH_FUNCTION_ARGS (fntype, argtype, it)\n-    if (argno-- == 0)\n-      return argtype;\n-\n-  return NULL_TREE;\n-}\n-\n-/* Helper to append the \"human readable\" attribute access specification\n-   described by ACCESS to the array ATTRSTR with size STRSIZE.  Used in\n-   diagnostics.  */\n-\n-static inline void\n-append_attrname (const std::pair<int, attr_access> &access,\n-\t\t char *attrstr, size_t strsize)\n-{\n-  if (access.second.internal_p)\n-    return;\n-\n-  tree str = access.second.to_external_string ();\n-  gcc_assert (strsize >= (size_t) TREE_STRING_LENGTH (str));\n-  strcpy (attrstr, TREE_STRING_POINTER (str));\n-}\n-\n-/* Iterate over attribute access read-only, read-write, and write-only\n-   arguments and diagnose past-the-end accesses and related problems\n-   in the function call EXP.  */\n-\n-static void\n-maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, tree exp)\n-{\n-  auto_diagnostic_group adg;\n-\n-  /* Set if a warning has been issued for any argument (used to decide\n-     whether to emit an informational note at the end).  */\n-  opt_code opt_warned = N_OPTS;\n-\n-  /* A string describing the attributes that the warnings issued by this\n-     function apply to.  Used to print one informational note per function\n-     call, rather than one per warning.  That reduces clutter.  */\n-  char attrstr[80];\n-  attrstr[0] = 0;\n-\n-  for (rdwr_map::iterator it = rwm->begin (); it != rwm->end (); ++it)\n-    {\n-      std::pair<int, attr_access> access = *it;\n-\n-      /* Get the function call arguments corresponding to the attribute's\n-\t positional arguments.  When both arguments have been specified\n-\t there will be two entries in *RWM, one for each.  They are\n-\t cross-referenced by their respective argument numbers in\n-\t ACCESS.PTRARG and ACCESS.SIZARG.  */\n-      const int ptridx = access.second.ptrarg;\n-      const int sizidx = access.second.sizarg;\n-\n-      gcc_assert (ptridx != -1);\n-      gcc_assert (access.first == ptridx || access.first == sizidx);\n-\n-      /* The pointer is set to null for the entry corresponding to\n-\t the size argument.  Skip it.  It's handled when the entry\n-\t corresponding to the pointer argument comes up.  */\n-      if (!access.second.ptr)\n-\tcontinue;\n-\n-      tree ptrtype = fntype_argno_type (fntype, ptridx);\n-      tree argtype = TREE_TYPE (ptrtype);\n-\n-      /* The size of the access by the call.  */\n-      tree access_size;\n-      if (sizidx == -1)\n-\t{\n-\t  /* If only the pointer attribute operand was specified and\n-\t     not size, set SIZE to the greater of MINSIZE or size of\n-\t     one element of the pointed to type to detect smaller\n-\t     objects (null pointers are diagnosed in this case only\n-\t     if the pointer is also declared with attribute nonnull.  */\n-\t  if (access.second.minsize\n-\t      && access.second.minsize != HOST_WIDE_INT_M1U)\n-\t    access_size = build_int_cstu (sizetype, access.second.minsize);\n-\t  else\n-\t    access_size = size_one_node;\n-\t}\n-      else\n-\taccess_size = rwm->get (sizidx)->size;\n-\n-      /* Format the value or range to avoid an explosion of messages.  */\n-      char sizstr[80];\n-      tree sizrng[2] = { size_zero_node, build_all_ones_cst (sizetype) };\n-      if (get_size_range (access_size, sizrng, true))\n-\t{\n-\t  char *s0 = print_generic_expr_to_str (sizrng[0]);\n-\t  if (tree_int_cst_equal (sizrng[0], sizrng[1]))\n-\t    {\n-\t      gcc_checking_assert (strlen (s0) < sizeof sizstr);\n-\t      strcpy (sizstr, s0);\n-\t    }\n-\t  else\n-\t    {\n-\t      char *s1 = print_generic_expr_to_str (sizrng[1]);\n-\t      gcc_checking_assert (strlen (s0) + strlen (s1)\n-\t\t\t\t   < sizeof sizstr - 4);\n-\t      sprintf (sizstr, \"[%s, %s]\", s0, s1);\n-\t      free (s1);\n-\t    }\n-\t  free (s0);\n-\t}\n-      else\n-\t*sizstr = '\\0';\n-\n-      /* Set if a warning has been issued for the current argument.  */\n-      opt_code arg_warned = no_warning;\n-      location_t loc = EXPR_LOCATION (exp);\n-      tree ptr = access.second.ptr;\n-      if (*sizstr\n-\t  && tree_int_cst_sgn (sizrng[0]) < 0\n-\t  && tree_int_cst_sgn (sizrng[1]) < 0)\n-\t{\n-\t  /* Warn about negative sizes.  */\n-\t  if (access.second.internal_p)\n-\t    {\n-\t      const std::string argtypestr\n-\t\t= access.second.array_as_string (ptrtype);\n-\n-\t      if (warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t\t      \"bound argument %i value %s is \"\n-\t\t\t      \"negative for a variable length array \"\n-\t\t\t      \"argument %i of type %s\",\n-\t\t\t      sizidx + 1, sizstr,\n-\t\t\t      ptridx + 1, argtypestr.c_str ()))\n-\t\targ_warned = OPT_Wstringop_overflow_;\n-\t    }\n-\t  else if (warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t\t       \"argument %i value %s is negative\",\n-\t\t\t       sizidx + 1, sizstr))\n-\t    arg_warned = OPT_Wstringop_overflow_;\n-\n-\t  if (arg_warned != no_warning)\n-\t    {\n-\t      append_attrname (access, attrstr, sizeof attrstr);\n-\t      /* Remember a warning has been issued and avoid warning\n-\t\t again below for the same attribute.  */\n-\t      opt_warned = arg_warned;\n-\t      continue;\n-\t    }\n-\t}\n-\n-      if (tree_int_cst_sgn (sizrng[0]) >= 0)\n-\t{\n-\t  if (COMPLETE_TYPE_P (argtype))\n-\t    {\n-\t      /* Multiply ACCESS_SIZE by the size of the type the pointer\n-\t\t argument points to.  If it's incomplete the size is used\n-\t\t as is.  */\n-\t      if (tree argsize = TYPE_SIZE_UNIT (argtype))\n-\t\tif (TREE_CODE (argsize) == INTEGER_CST)\n-\t\t  {\n-\t\t    const int prec = TYPE_PRECISION (sizetype);\n-\t\t    wide_int minsize = wi::to_wide (sizrng[0], prec);\n-\t\t    minsize *= wi::to_wide (argsize, prec);\n-\t\t    access_size = wide_int_to_tree (sizetype, minsize);\n-\t\t  }\n-\t    }\n-\t}\n-      else\n-\taccess_size = NULL_TREE;\n-\n-      if (integer_zerop (ptr))\n-\t{\n-\t  if (sizidx >= 0 && tree_int_cst_sgn (sizrng[0]) > 0)\n-\t    {\n-\t      /* Warn about null pointers with positive sizes.  This is\n-\t\t different from also declaring the pointer argument with\n-\t\t attribute nonnull when the function accepts null pointers\n-\t\t only when the corresponding size is zero.  */\n-\t      if (access.second.internal_p)\n-\t\t{\n-\t\t  const std::string argtypestr\n-\t\t    = access.second.array_as_string (ptrtype);\n-\n-\t\t  if (warning_at (loc, OPT_Wnonnull,\n-\t\t\t\t  \"argument %i of variable length \"\n-\t\t\t\t  \"array %s is null but \"\n-\t\t\t\t  \"the corresponding bound argument \"\n-\t\t\t\t  \"%i value is %s\",\n-\t\t\t\t  ptridx + 1, argtypestr.c_str (),\n-\t\t\t\t  sizidx + 1, sizstr))\n-\t\t    arg_warned = OPT_Wnonnull;\n-\t\t}\n-\t      else if (warning_at (loc, OPT_Wnonnull,\n-\t\t\t\t   \"argument %i is null but \"\n-\t\t\t\t   \"the corresponding size argument \"\n-\t\t\t\t   \"%i value is %s\",\n-\t\t\t\t   ptridx + 1, sizidx + 1, sizstr))\n-\t\targ_warned = OPT_Wnonnull;\n-\t    }\n-\t  else if (access_size && access.second.static_p)\n-\t    {\n-\t      /* Warn about null pointers for [static N] array arguments\n-\t\t but do not warn for ordinary (i.e., nonstatic) arrays.  */\n-\t      if (warning_at (loc, OPT_Wnonnull,\n-\t\t\t      \"argument %i to %<%T[static %E]%> \"\n-\t\t\t      \"is null where non-null expected\",\n-\t\t\t      ptridx + 1, argtype, access_size))\n-\t\targ_warned = OPT_Wnonnull;\t\t\n-\t    }\n-\n-\t  if (arg_warned != no_warning)\n-\t    {\n-\t      append_attrname (access, attrstr, sizeof attrstr);\n-\t      /* Remember a warning has been issued and avoid warning\n-\t\t again below for the same attribute.  */\n-\t      opt_warned = OPT_Wnonnull;\n-\t      continue;\n-\t    }\n-\t}\n-\n-      access_data data (ptr, access.second.mode, NULL_TREE, false,\n-\t\t\tNULL_TREE, false);\n-      access_ref* const pobj = (access.second.mode == access_write_only\n-\t\t\t\t? &data.dst : &data.src);\n-      tree objsize = compute_objsize (ptr, 1, pobj);\n-\n-      /* The size of the destination or source object.  */\n-      tree dstsize = NULL_TREE, srcsize = NULL_TREE;\n-      if (access.second.mode == access_read_only\n-\t  || access.second.mode == access_none)\n-\t{\n-\t  /* For a read-only argument there is no destination.  For\n-\t     no access, set the source as well and differentiate via\n-\t     the access flag below.  */\n-\t  srcsize = objsize;\n-\t  if (access.second.mode == access_read_only\n-\t      || access.second.mode == access_none)\n-\t    {\n-\t      /* For a read-only attribute there is no destination so\n-\t\t clear OBJSIZE.  This emits \"reading N bytes\" kind of\n-\t\t diagnostics instead of the \"writing N bytes\" kind,\n-\t\t unless MODE is none.  */\n-\t      objsize = NULL_TREE;\n-\t    }\n-\t}\n-      else\n-\tdstsize = objsize;\n-\n-      /* Clear the no-warning bit in case it was set by check_access\n-\t in a prior iteration so that accesses via different arguments\n-\t are diagnosed.  */\n-      suppress_warning (exp, OPT_Wstringop_overflow_, false);\n-      access_mode mode = data.mode;\n-      if (mode == access_deferred)\n-\tmode = TYPE_READONLY (argtype) ? access_read_only : access_read_write;\n-      check_access (exp, access_size, /*maxread=*/ NULL_TREE, srcsize,\n-\t\t    dstsize, mode, &data);\n-\n-      if (warning_suppressed_p (exp, OPT_Wstringop_overflow_))\n-\topt_warned = OPT_Wstringop_overflow_;\n-      if (opt_warned != N_OPTS)\n-\t{\n-\t  if (access.second.internal_p)\n-\t    inform (loc, \"referencing argument %u of type %qT\",\n-\t\t    ptridx + 1, ptrtype);\n-\t  else\n-\t    /* If check_access issued a warning above, append the relevant\n-\t       attribute to the string.  */\n-\t    append_attrname (access, attrstr, sizeof attrstr);\n-\t}\n-    }\n-\n-  if (*attrstr)\n-    {\n-      if (fndecl)\n-\tinform (DECL_SOURCE_LOCATION (fndecl),\n-\t\t\"in a call to function %qD declared with attribute %qs\",\n-\t\tfndecl, attrstr);\n-      else\n-\tinform (EXPR_LOCATION (fndecl),\n-\t\t\"in a call with type %qT and attribute %qs\",\n-\t\tfntype, attrstr);\n-    }\n-  else if (opt_warned != N_OPTS)\n-    {\n-      if (fndecl)\n-\tinform (DECL_SOURCE_LOCATION (fndecl),\n-\t\t\"in a call to function %qD\", fndecl);\n-      else\n-\tinform (EXPR_LOCATION (fndecl),\n-\t\t\"in a call with type %qT\", fntype);\n-    }\n-\n-  /* Set the bit in case if was cleared and not set above.  */\n-  if (opt_warned != N_OPTS)\n-    suppress_warning (exp, opt_warned);\n-}\n-\n /* Fill in ARGS_SIZE and ARGS array based on the parameters found in\n    CALL_EXPR EXP.\n \n@@ -2030,27 +1331,6 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \n   bitmap_obstack_release (NULL);\n \n-  tree fntypeattrs = TYPE_ATTRIBUTES (fntype);\n-  /* Extract attribute alloc_size from the type of the called expression\n-     (which could be a function or a function pointer) and if set, store\n-     the indices of the corresponding arguments in ALLOC_IDX, and then\n-     the actual argument(s) at those indices in ALLOC_ARGS.  */\n-  int alloc_idx[2] = { -1, -1 };\n-  if (tree alloc_size = lookup_attribute (\"alloc_size\", fntypeattrs))\n-    {\n-      tree args = TREE_VALUE (alloc_size);\n-      alloc_idx[0] = TREE_INT_CST_LOW (TREE_VALUE (args)) - 1;\n-      if (TREE_CHAIN (args))\n-\talloc_idx[1] = TREE_INT_CST_LOW (TREE_VALUE (TREE_CHAIN (args))) - 1;\n-    }\n-\n-  /* Array for up to the two attribute alloc_size arguments.  */\n-  tree alloc_args[] = { NULL_TREE, NULL_TREE };\n-\n-  /* Map of attribute accewss specifications for function arguments.  */\n-  rdwr_map rdwr_idx;\n-  init_attr_rdwr_indices (&rdwr_idx, fntypeattrs);\n-\n   /* I counts args in order (to be) pushed; ARGPOS counts in order written.  */\n   for (argpos = 0; argpos < num_actuals; i--, argpos++)\n     {\n@@ -2283,44 +1563,7 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t does pass the promoted mode.  */\n       arg.mode = TYPE_MODE (type);\n       targetm.calls.function_arg_advance (args_so_far, arg);\n-\n-      /* Store argument values for functions decorated with attribute\n-\t alloc_size.  */\n-      if (argpos == alloc_idx[0])\n-\talloc_args[0] = args[i].tree_value;\n-      else if (argpos == alloc_idx[1])\n-\talloc_args[1] = args[i].tree_value;\n-\n-      /* Save the actual argument that corresponds to the access attribute\n-\t operand for later processing.  */\n-      if (attr_access *access = rdwr_idx.get (argpos))\n-\t{\n-\t  if (POINTER_TYPE_P (type))\n-\t    {\n-\t      access->ptr = args[i].tree_value;\n-\t      // A nonnull ACCESS->SIZE contains VLA bounds.  */\n-\t    }\n-\t  else\n-\t    {\n-\t      access->size = args[i].tree_value;\n-\t      gcc_assert (access->ptr == NULL_TREE);\n-\t    }\n-\t}\n-    }\n-\n-  if (alloc_args[0])\n-    {\n-      /* Check the arguments of functions decorated with attribute\n-\t alloc_size.  */\n-      maybe_warn_alloc_args_overflow (fndecl, exp, alloc_args, alloc_idx);\n     }\n-\n-  /* Detect passing non-string arguments to functions expecting\n-     nul-terminated strings.  */\n-  maybe_warn_nonstring_arg (fndecl, exp);\n-\n-  /* Check attribute access arguments.  */\n-  maybe_warn_rdwr_sizes (&rdwr_idx, fndecl, fntype, exp);\n }\n \n /* Update ARGS_SIZE to contain the total size for the argument block.\n@@ -6020,6 +5263,3 @@ cxx17_empty_base_field_p (const_tree field)\n \t  && RECORD_OR_UNION_TYPE_P (TREE_TYPE (field))\n \t  && !lookup_attribute (\"no_unique_address\", DECL_ATTRIBUTES (field)));\n }\n-\n-/* Tell the garbage collector about GTY markers in this source file.  */\n-#include \"gt-calls.h\""}, {"sha": "9a98f5de75f592b53e0af946a3da0cd14b2e0393", "filename": "gcc/calls.h", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48d4e6818674898f90d9358378c127511ef0f9f/gcc%2Fcalls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48d4e6818674898f90d9358378c127511ef0f9f/gcc%2Fcalls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.h?ref=b48d4e6818674898f90d9358378c127511ef0f9f", "patch": "@@ -130,21 +130,8 @@ extern bool apply_pass_by_reference_rules (CUMULATIVE_ARGS *,\n \t\t\t\t\t   function_arg_info &);\n extern bool reference_callee_copied (CUMULATIVE_ARGS *,\n \t\t\t\t     const function_arg_info &);\n-extern void maybe_warn_alloc_args_overflow (tree, tree, tree[2], int[2]);\n-extern tree get_attr_nonstring_decl (tree, tree * = NULL);\n-extern bool maybe_warn_nonstring_arg (tree, tree);\n extern void maybe_complain_about_tail_call (tree, const char *);\n-enum size_range_flags\n-  {\n-   /* Set to consider zero a valid range.  */\n-   SR_ALLOW_ZERO = 1,\n-   /* Set to use the largest subrange of a set of ranges as opposed\n-      to the smallest.  */\n-   SR_USE_LARGEST = 2\n-  };\n-extern bool get_size_range (tree, tree[2], int = 0);\n-extern bool get_size_range (class range_query *, tree, gimple *,\n-\t\t\t    tree[2], int = 0);\n+\n extern rtx rtx_for_static_chain (const_tree, bool);\n extern bool cxx17_empty_base_field_p (const_tree);\n "}, {"sha": "f3efe564af0ea440f2b40da0f55ebd62f7265207", "filename": "gcc/gimple-ssa-warn-access.cc", "status": "modified", "additions": 663, "deletions": 20, "changes": 683, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48d4e6818674898f90d9358378c127511ef0f9f/gcc%2Fgimple-ssa-warn-access.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48d4e6818674898f90d9358378c127511ef0f9f/gcc%2Fgimple-ssa-warn-access.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-access.cc?ref=b48d4e6818674898f90d9358378c127511ef0f9f", "patch": "@@ -20,6 +20,7 @@\n    along with GCC; see the file COPYING3.  If not see\n    <http://www.gnu.org/licenses/>.  */\n \n+#define INCLUDE_STRING\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -36,6 +37,7 @@\n #include \"fold-const.h\"\n #include \"gimple-fold.h\"\n #include \"gimple-iterator.h\"\n+#include \"langhooks.h\"\n #include \"tree-dfa.h\"\n #include \"tree-ssa.h\"\n #include \"tree-cfg.h\"\n@@ -50,14 +52,6 @@\n #include \"demangle.h\"\n #include \"pointer-query.h\"\n \n-/* Return true if STMT has an associated location.  */\n-\n-static inline location_t\n-has_location (const gimple *stmt)\n-{\n-  return gimple_has_location (stmt);\n-}\n-\n /* Return true if tree node X has an associated location.  */\n \n static inline location_t\n@@ -1177,7 +1171,7 @@ warn_for_access (location_t loc, tree func, tree expr, int opt,\n /* Helper to set RANGE to the range of BOUND if it's nonnull, bounded\n    by BNDRNG if nonnull and valid.  */\n \n-void\n+static void\n get_size_range (tree bound, tree range[2], const offset_int bndrng[2])\n {\n   if (bound)\n@@ -2105,14 +2099,14 @@ warn_dealloc_offset (location_t loc, gimple *call, const access_ref &aref)\n    form of C++ operatorn new.  */\n \n static void\n-maybe_emit_free_warning (gcall *call)\n+maybe_check_dealloc_call (gcall *call)\n {\n   tree fndecl = gimple_call_fndecl (call);\n   if (!fndecl)\n     return;\n \n   unsigned argno = fndecl_dealloc_argno (fndecl);\n-  if ((unsigned) gimple_call_num_args (call) <= argno)\n+  if ((unsigned) call_nargs (call) <= argno)\n     return;\n \n   tree ptr = gimple_call_arg (call, argno);\n@@ -2246,9 +2240,9 @@ const pass_data pass_data_waccess = {\n class pass_waccess : public gimple_opt_pass\n {\n  public:\n-  pass_waccess (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_waccess, ctxt), m_ranger ()\n-    { }\n+  pass_waccess (gcc::context *);\n+\n+  ~pass_waccess ();\n \n   opt_pass *clone () { return new pass_waccess (m_ctxt); }\n \n@@ -2258,16 +2252,45 @@ class pass_waccess : public gimple_opt_pass\n   /* Check a call to a built-in function.  */\n   bool check_builtin (gcall *);\n \n+  /* Check a call to an ordinary function.  */\n+  bool check_call (gcall *);\n+\n   /* Check statements in a basic block.  */\n   void check (basic_block);\n \n   /* Check a call to a function.  */\n  void check (gcall *);\n \n private:\n+  /* Not copyable or assignable.  */\n+  pass_waccess (pass_waccess &) = delete;\n+  void operator= (pass_waccess &) = delete;\n+\n+  /* A pointer_query object and its cache to store information about\n+     pointers and their targets in.  */\n+  pointer_query ptr_qry;\n+  pointer_query::cache_type var_cache;\n+\n   gimple_ranger *m_ranger;\n };\n \n+/* Construct the pass.  */\n+\n+pass_waccess::pass_waccess (gcc::context *ctxt)\n+  : gimple_opt_pass (pass_data_waccess, ctxt),\n+    ptr_qry (m_ranger, &var_cache),\n+    var_cache (),\n+    m_ranger ()\n+{\n+}\n+\n+/* Release pointer_query cache.  */\n+\n+pass_waccess::~pass_waccess ()\n+{\n+  ptr_qry.flush_cache ();\n+}\n+\n /* Return true when any checks performed by the pass are enabled.  */\n \n bool\n@@ -2278,12 +2301,256 @@ pass_waccess::gate (function *)\n \t  || warn_mismatched_new_delete);\n }\n \n+/* Initialize ALLOC_OBJECT_SIZE_LIMIT based on the -Walloc-size-larger-than=\n+   setting if the option is specified, or to the maximum object size if it\n+   is not.  Return the initialized value.  */\n+\n+static tree\n+alloc_max_size (void)\n+{\n+  HOST_WIDE_INT limit = warn_alloc_size_limit;\n+  if (limit == HOST_WIDE_INT_MAX)\n+    limit = tree_to_shwi (TYPE_MAX_VALUE (ptrdiff_type_node));\n+\n+  return build_int_cst (size_type_node, limit);\n+}\n+\n+/* Diagnose a call EXP to function FN decorated with attribute alloc_size\n+   whose argument numbers given by IDX with values given by ARGS exceed\n+   the maximum object size or cause an unsigned oveflow (wrapping) when\n+   multiplied.  FN is null when EXP is a call via a function pointer.\n+   When ARGS[0] is null the function does nothing.  ARGS[1] may be null\n+   for functions like malloc, and non-null for those like calloc that\n+   are decorated with a two-argument attribute alloc_size.  */\n+\n+void\n+maybe_warn_alloc_args_overflow (gimple *stmt, const tree args[2],\n+\t\t\t\tconst int idx[2])\n+{\n+  /* The range each of the (up to) two arguments is known to be in.  */\n+  tree argrange[2][2] = { { NULL_TREE, NULL_TREE }, { NULL_TREE, NULL_TREE } };\n+\n+  /* Maximum object size set by -Walloc-size-larger-than= or SIZE_MAX / 2.  */\n+  tree maxobjsize = alloc_max_size ();\n+\n+  location_t loc = get_location (stmt);\n+\n+  tree fn = gimple_call_fndecl (stmt);\n+  tree fntype = fn ? TREE_TYPE (fn) : gimple_call_fntype (stmt);\n+  bool warned = false;\n+\n+  /* Validate each argument individually.  */\n+  for (unsigned i = 0; i != 2 && args[i]; ++i)\n+    {\n+      if (TREE_CODE (args[i]) == INTEGER_CST)\n+\t{\n+\t  argrange[i][0] = args[i];\n+\t  argrange[i][1] = args[i];\n+\n+\t  if (tree_int_cst_lt (args[i], integer_zero_node))\n+\t    {\n+\t      warned = warning_at (loc, OPT_Walloc_size_larger_than_,\n+\t\t\t\t   \"argument %i value %qE is negative\",\n+\t\t\t\t   idx[i] + 1, args[i]);\n+\t    }\n+\t  else if (integer_zerop (args[i]))\n+\t    {\n+\t      /* Avoid issuing -Walloc-zero for allocation functions other\n+\t\t than __builtin_alloca that are declared with attribute\n+\t\t returns_nonnull because there's no portability risk.  This\n+\t\t avoids warning for such calls to libiberty's xmalloc and\n+\t\t friends.\n+\t\t Also avoid issuing the warning for calls to function named\n+\t\t \"alloca\".  */\n+\t      if (fn && fndecl_built_in_p (fn, BUILT_IN_ALLOCA)\n+\t\t  ? IDENTIFIER_LENGTH (DECL_NAME (fn)) != 6\n+\t\t  : !lookup_attribute (\"returns_nonnull\",\n+\t\t\t\t       TYPE_ATTRIBUTES (fntype)))\n+\t\twarned = warning_at (loc, OPT_Walloc_zero,\n+\t\t\t\t     \"argument %i value is zero\",\n+\t\t\t\t     idx[i] + 1);\n+\t    }\n+\t  else if (tree_int_cst_lt (maxobjsize, args[i]))\n+\t    {\n+\t      /* G++ emits calls to ::operator new[](SIZE_MAX) in C++98\n+\t\t mode and with -fno-exceptions as a way to indicate array\n+\t\t size overflow.  There's no good way to detect C++98 here\n+\t\t so avoid diagnosing these calls for all C++ modes.  */\n+\t      if (i == 0\n+\t\t  && fn\n+\t\t  && !args[1]\n+\t\t  && lang_GNU_CXX ()\n+\t\t  && DECL_IS_OPERATOR_NEW_P (fn)\n+\t\t  && integer_all_onesp (args[i]))\n+\t\tcontinue;\n+\n+\t      warned = warning_at (loc, OPT_Walloc_size_larger_than_,\n+\t\t\t\t   \"argument %i value %qE exceeds \"\n+\t\t\t\t   \"maximum object size %E\",\n+\t\t\t\t   idx[i] + 1, args[i], maxobjsize);\n+\t    }\n+\t}\n+      else if (TREE_CODE (args[i]) == SSA_NAME\n+\t       && get_size_range (args[i], argrange[i]))\n+\t{\n+\t  /* Verify that the argument's range is not negative (including\n+\t     upper bound of zero).  */\n+\t  if (tree_int_cst_lt (argrange[i][0], integer_zero_node)\n+\t      && tree_int_cst_le (argrange[i][1], integer_zero_node))\n+\t    {\n+\t      warned = warning_at (loc, OPT_Walloc_size_larger_than_,\n+\t\t\t\t   \"argument %i range [%E, %E] is negative\",\n+\t\t\t\t   idx[i] + 1,\n+\t\t\t\t   argrange[i][0], argrange[i][1]);\n+\t    }\n+\t  else if (tree_int_cst_lt (maxobjsize, argrange[i][0]))\n+\t    {\n+\t      warned = warning_at (loc, OPT_Walloc_size_larger_than_,\n+\t\t\t\t   \"argument %i range [%E, %E] exceeds \"\n+\t\t\t\t   \"maximum object size %E\",\n+\t\t\t\t   idx[i] + 1,\n+\t\t\t\t   argrange[i][0], argrange[i][1],\n+\t\t\t\t   maxobjsize);\n+\t    }\n+\t}\n+    }\n+\n+  if (!argrange[0])\n+    return;\n+\n+  /* For a two-argument alloc_size, validate the product of the two\n+     arguments if both of their values or ranges are known.  */\n+  if (!warned && tree_fits_uhwi_p (argrange[0][0])\n+      && argrange[1][0] && tree_fits_uhwi_p (argrange[1][0])\n+      && !integer_onep (argrange[0][0])\n+      && !integer_onep (argrange[1][0]))\n+    {\n+      /* Check for overflow in the product of a function decorated with\n+\t attribute alloc_size (X, Y).  */\n+      unsigned szprec = TYPE_PRECISION (size_type_node);\n+      wide_int x = wi::to_wide (argrange[0][0], szprec);\n+      wide_int y = wi::to_wide (argrange[1][0], szprec);\n+\n+      wi::overflow_type vflow;\n+      wide_int prod = wi::umul (x, y, &vflow);\n+\n+      if (vflow)\n+\twarned = warning_at (loc, OPT_Walloc_size_larger_than_,\n+\t\t\t     \"product %<%E * %E%> of arguments %i and %i \"\n+\t\t\t     \"exceeds %<SIZE_MAX%>\",\n+\t\t\t     argrange[0][0], argrange[1][0],\n+\t\t\t     idx[0] + 1, idx[1] + 1);\n+      else if (wi::ltu_p (wi::to_wide (maxobjsize, szprec), prod))\n+\twarned = warning_at (loc, OPT_Walloc_size_larger_than_,\n+\t\t\t     \"product %<%E * %E%> of arguments %i and %i \"\n+\t\t\t     \"exceeds maximum object size %E\",\n+\t\t\t     argrange[0][0], argrange[1][0],\n+\t\t\t     idx[0] + 1, idx[1] + 1,\n+\t\t\t     maxobjsize);\n+\n+      if (warned)\n+\t{\n+\t  /* Print the full range of each of the two arguments to make\n+\t     it clear when it is, in fact, in a range and not constant.  */\n+\t  if (argrange[0][0] != argrange [0][1])\n+\t    inform (loc, \"argument %i in the range [%E, %E]\",\n+\t\t    idx[0] + 1, argrange[0][0], argrange[0][1]);\n+\t  if (argrange[1][0] != argrange [1][1])\n+\t    inform (loc, \"argument %i in the range [%E, %E]\",\n+\t\t    idx[1] + 1, argrange[1][0], argrange[1][1]);\n+\t}\n+    }\n+\n+  if (warned && fn)\n+    {\n+      location_t fnloc = DECL_SOURCE_LOCATION (fn);\n+\n+      if (DECL_IS_UNDECLARED_BUILTIN (fn))\n+\tinform (loc,\n+\t\t\"in a call to built-in allocation function %qD\", fn);\n+      else\n+\tinform (fnloc,\n+\t\t\"in a call to allocation function %qD declared here\", fn);\n+    }\n+}\n+\n+/* Check a call to an alloca function for an excessive size.  */\n+\n+static void\n+check_alloca (gimple *stmt)\n+{\n+  if ((warn_vla_limit >= HOST_WIDE_INT_MAX\n+       && warn_alloc_size_limit < warn_vla_limit)\n+      || (warn_alloca_limit >= HOST_WIDE_INT_MAX\n+\t  && warn_alloc_size_limit < warn_alloca_limit))\n+    {\n+      /* -Walloca-larger-than and -Wvla-larger-than settings of less\n+\t than  HWI_MAX override the more general -Walloc-size-larger-than\n+\t so unless either of the former options is smaller than the last\n+\t one (wchich would imply that the call was already checked), check\n+\t the alloca arguments for overflow.  */\n+      const tree alloc_args[] = { call_arg (stmt, 0), NULL_TREE };\n+      const int idx[] = { 0, -1 };\n+      maybe_warn_alloc_args_overflow (stmt, alloc_args, idx);\n+    }\n+}\n+\n+/* Check a call to an allocation function for an excessive size.  */\n+\n+static void\n+check_alloc_size_call (gimple *stmt)\n+{\n+  if (gimple_call_num_args (stmt) < 1)\n+    /* Avoid invalid calls to functions without a prototype.  */\n+    return;\n+\n+  tree fndecl = gimple_call_fndecl (stmt);\n+  if (fndecl && gimple_call_builtin_p (stmt, BUILT_IN_NORMAL))\n+    {\n+      /* Alloca is handled separately.  */\n+      switch (DECL_FUNCTION_CODE (fndecl))\n+\t{\n+\tcase BUILT_IN_ALLOCA:\n+\tcase BUILT_IN_ALLOCA_WITH_ALIGN:\n+\tcase BUILT_IN_ALLOCA_WITH_ALIGN_AND_MAX:\n+\t  return;\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+\n+  tree fntype = gimple_call_fntype (stmt);\n+  tree fntypeattrs = TYPE_ATTRIBUTES (fntype);\n+\n+  tree alloc_size = lookup_attribute (\"alloc_size\", fntypeattrs);\n+  if (!alloc_size)\n+    return;\n+\n+  /* Extract attribute alloc_size from the type of the called expression\n+     (which could be a function or a function pointer) and if set, store\n+     the indices of the corresponding arguments in ALLOC_IDX, and then\n+     the actual argument(s) at those indices in ALLOC_ARGS.  */\n+  int idx[2] = { -1, -1 };\n+  tree alloc_args[] = { NULL_TREE, NULL_TREE };\n+\n+  tree args = TREE_VALUE (alloc_size);\n+  idx[0] = TREE_INT_CST_LOW (TREE_VALUE (args)) - 1;\n+  alloc_args[0] = call_arg (stmt, idx[0]);\n+  if (TREE_CHAIN (args))\n+    {\n+      idx[1] = TREE_INT_CST_LOW (TREE_VALUE (TREE_CHAIN (args))) - 1;\n+      alloc_args[1] = call_arg (stmt, idx[1]);\n+    }\n+\n+  maybe_warn_alloc_args_overflow (stmt, alloc_args, idx);\n+}\n+\n /* Check a call STMT to strcat() for overflow and warn if it does.  */\n \n static void\n check_strcat (gimple *stmt)\n {\n-  if (!warn_stringop_overflow)\n+  if (!warn_stringop_overflow && !warn_stringop_overread)\n     return;\n \n   tree dest = call_arg (stmt, 0);\n@@ -2308,7 +2575,7 @@ check_strcat (gimple *stmt)\n static void\n check_strncat (gimple *stmt)\n {\n-  if (!warn_stringop_overflow)\n+  if (!warn_stringop_overflow && !warn_stringop_overread)\n     return;\n \n   tree dest = call_arg (stmt, 0);\n@@ -2537,6 +2804,12 @@ pass_waccess::check_builtin (gcall *stmt)\n \n   switch (DECL_FUNCTION_CODE (callee))\n     {\n+    case BUILT_IN_ALLOCA:\n+    case BUILT_IN_ALLOCA_WITH_ALIGN:\n+    case BUILT_IN_ALLOCA_WITH_ALIGN_AND_MAX:\n+      check_alloca (stmt);\n+      return true;\n+\n     case BUILT_IN_GETTEXT:\n     case BUILT_IN_PUTS:\n     case BUILT_IN_PUTS_UNLOCKED:\n@@ -2639,16 +2912,384 @@ pass_waccess::check_builtin (gcall *stmt)\n   return true;\n }\n \n+/* Returns the type of the argument ARGNO to function with type FNTYPE\n+   or null when the typoe cannot be determined or no such argument exists.  */\n+\n+static tree\n+fntype_argno_type (tree fntype, unsigned argno)\n+{\n+  if (!prototype_p (fntype))\n+    return NULL_TREE;\n+\n+  tree argtype;\n+  function_args_iterator it;\n+  FOREACH_FUNCTION_ARGS (fntype, argtype, it)\n+    if (argno-- == 0)\n+      return argtype;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Helper to append the \"human readable\" attribute access specification\n+   described by ACCESS to the array ATTRSTR with size STRSIZE.  Used in\n+   diagnostics.  */\n+\n+static inline void\n+append_attrname (const std::pair<int, attr_access> &access,\n+\t\t char *attrstr, size_t strsize)\n+{\n+  if (access.second.internal_p)\n+    return;\n+\n+  tree str = access.second.to_external_string ();\n+  gcc_assert (strsize >= (size_t) TREE_STRING_LENGTH (str));\n+  strcpy (attrstr, TREE_STRING_POINTER (str));\n+}\n+\n+/* Iterate over attribute access read-only, read-write, and write-only\n+   arguments and diagnose past-the-end accesses and related problems\n+   in the function call EXP.  */\n+\n+static void\n+maybe_warn_rdwr_sizes (rdwr_map *rwm, tree fndecl, tree fntype, gimple *stmt)\n+{\n+  auto_diagnostic_group adg;\n+\n+  /* Set if a warning has been issued for any argument (used to decide\n+     whether to emit an informational note at the end).  */\n+  opt_code opt_warned = no_warning;\n+\n+  /* A string describing the attributes that the warnings issued by this\n+     function apply to.  Used to print one informational note per function\n+     call, rather than one per warning.  That reduces clutter.  */\n+  char attrstr[80];\n+  attrstr[0] = 0;\n+\n+  for (rdwr_map::iterator it = rwm->begin (); it != rwm->end (); ++it)\n+    {\n+      std::pair<int, attr_access> access = *it;\n+\n+      /* Get the function call arguments corresponding to the attribute's\n+\t positional arguments.  When both arguments have been specified\n+\t there will be two entries in *RWM, one for each.  They are\n+\t cross-referenced by their respective argument numbers in\n+\t ACCESS.PTRARG and ACCESS.SIZARG.  */\n+      const int ptridx = access.second.ptrarg;\n+      const int sizidx = access.second.sizarg;\n+\n+      gcc_assert (ptridx != -1);\n+      gcc_assert (access.first == ptridx || access.first == sizidx);\n+\n+      /* The pointer is set to null for the entry corresponding to\n+\t the size argument.  Skip it.  It's handled when the entry\n+\t corresponding to the pointer argument comes up.  */\n+      if (!access.second.ptr)\n+\tcontinue;\n+\n+      tree ptrtype = fntype_argno_type (fntype, ptridx);\n+      tree argtype = TREE_TYPE (ptrtype);\n+\n+      /* The size of the access by the call.  */\n+      tree access_size;\n+      if (sizidx == -1)\n+\t{\n+\t  /* If only the pointer attribute operand was specified and\n+\t     not size, set SIZE to the greater of MINSIZE or size of\n+\t     one element of the pointed to type to detect smaller\n+\t     objects (null pointers are diagnosed in this case only\n+\t     if the pointer is also declared with attribute nonnull.  */\n+\t  if (access.second.minsize\n+\t      && access.second.minsize != HOST_WIDE_INT_M1U)\n+\t    access_size = build_int_cstu (sizetype, access.second.minsize);\n+\t  else\n+\t    access_size = size_one_node;\n+\t}\n+      else\n+\taccess_size = rwm->get (sizidx)->size;\n+\n+      /* Format the value or range to avoid an explosion of messages.  */\n+      char sizstr[80];\n+      tree sizrng[2] = { size_zero_node, build_all_ones_cst (sizetype) };\n+      if (get_size_range (access_size, sizrng, true))\n+\t{\n+\t  char *s0 = print_generic_expr_to_str (sizrng[0]);\n+\t  if (tree_int_cst_equal (sizrng[0], sizrng[1]))\n+\t    {\n+\t      gcc_checking_assert (strlen (s0) < sizeof sizstr);\n+\t      strcpy (sizstr, s0);\n+\t    }\n+\t  else\n+\t    {\n+\t      char *s1 = print_generic_expr_to_str (sizrng[1]);\n+\t      gcc_checking_assert (strlen (s0) + strlen (s1)\n+\t\t\t\t   < sizeof sizstr - 4);\n+\t      sprintf (sizstr, \"[%s, %s]\", s0, s1);\n+\t      free (s1);\n+\t    }\n+\t  free (s0);\n+\t}\n+      else\n+\t*sizstr = '\\0';\n+\n+      /* Set if a warning has been issued for the current argument.  */\n+      opt_code arg_warned = no_warning;\n+      location_t loc = get_location (stmt);\n+      tree ptr = access.second.ptr;\n+      if (*sizstr\n+\t  && tree_int_cst_sgn (sizrng[0]) < 0\n+\t  && tree_int_cst_sgn (sizrng[1]) < 0)\n+\t{\n+\t  /* Warn about negative sizes.  */\n+\t  if (access.second.internal_p)\n+\t    {\n+\t      const std::string argtypestr\n+\t\t= access.second.array_as_string (ptrtype);\n+\n+\t      if (warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t\t      \"bound argument %i value %s is \"\n+\t\t\t      \"negative for a variable length array \"\n+\t\t\t      \"argument %i of type %s\",\n+\t\t\t      sizidx + 1, sizstr,\n+\t\t\t      ptridx + 1, argtypestr.c_str ()))\n+\t\targ_warned = OPT_Wstringop_overflow_;\n+\t    }\n+\t  else if (warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t\t       \"argument %i value %s is negative\",\n+\t\t\t       sizidx + 1, sizstr))\n+\t    arg_warned = OPT_Wstringop_overflow_;\n+\n+\t  if (arg_warned != no_warning)\n+\t    {\n+\t      append_attrname (access, attrstr, sizeof attrstr);\n+\t      /* Remember a warning has been issued and avoid warning\n+\t\t again below for the same attribute.  */\n+\t      opt_warned = arg_warned;\n+\t      continue;\n+\t    }\n+\t}\n+\n+      if (tree_int_cst_sgn (sizrng[0]) >= 0)\n+\t{\n+\t  if (COMPLETE_TYPE_P (argtype))\n+\t    {\n+\t      /* Multiply ACCESS_SIZE by the size of the type the pointer\n+\t\t argument points to.  If it's incomplete the size is used\n+\t\t as is.  */\n+\t      if (tree argsize = TYPE_SIZE_UNIT (argtype))\n+\t\tif (TREE_CODE (argsize) == INTEGER_CST)\n+\t\t  {\n+\t\t    const int prec = TYPE_PRECISION (sizetype);\n+\t\t    wide_int minsize = wi::to_wide (sizrng[0], prec);\n+\t\t    minsize *= wi::to_wide (argsize, prec);\n+\t\t    access_size = wide_int_to_tree (sizetype, minsize);\n+\t\t  }\n+\t    }\n+\t}\n+      else\n+\taccess_size = NULL_TREE;\n+\n+      if (integer_zerop (ptr))\n+\t{\n+\t  if (sizidx >= 0 && tree_int_cst_sgn (sizrng[0]) > 0)\n+\t    {\n+\t      /* Warn about null pointers with positive sizes.  This is\n+\t\t different from also declaring the pointer argument with\n+\t\t attribute nonnull when the function accepts null pointers\n+\t\t only when the corresponding size is zero.  */\n+\t      if (access.second.internal_p)\n+\t\t{\n+\t\t  const std::string argtypestr\n+\t\t    = access.second.array_as_string (ptrtype);\n+\n+\t\t  if (warning_at (loc, OPT_Wnonnull,\n+\t\t\t\t  \"argument %i of variable length \"\n+\t\t\t\t  \"array %s is null but \"\n+\t\t\t\t  \"the corresponding bound argument \"\n+\t\t\t\t  \"%i value is %s\",\n+\t\t\t\t  ptridx + 1, argtypestr.c_str (),\n+\t\t\t\t  sizidx + 1, sizstr))\n+\t\t    arg_warned = OPT_Wnonnull;\n+\t\t}\n+\t      else if (warning_at (loc, OPT_Wnonnull,\n+\t\t\t\t   \"argument %i is null but \"\n+\t\t\t\t   \"the corresponding size argument \"\n+\t\t\t\t   \"%i value is %s\",\n+\t\t\t\t   ptridx + 1, sizidx + 1, sizstr))\n+\t\targ_warned = OPT_Wnonnull;\n+\t    }\n+\t  else if (access_size && access.second.static_p)\n+\t    {\n+\t      /* Warn about null pointers for [static N] array arguments\n+\t\t but do not warn for ordinary (i.e., nonstatic) arrays.  */\n+\t      if (warning_at (loc, OPT_Wnonnull,\n+\t\t\t      \"argument %i to %<%T[static %E]%> \"\n+\t\t\t      \"is null where non-null expected\",\n+\t\t\t      ptridx + 1, argtype, access_size))\n+\t\targ_warned = OPT_Wnonnull;\n+\t    }\n+\n+\t  if (arg_warned != no_warning)\n+\t    {\n+\t      append_attrname (access, attrstr, sizeof attrstr);\n+\t      /* Remember a warning has been issued and avoid warning\n+\t\t again below for the same attribute.  */\n+\t      opt_warned = OPT_Wnonnull;\n+\t      continue;\n+\t    }\n+\t}\n+\n+      access_data data (ptr, access.second.mode, NULL_TREE, false,\n+\t\t\tNULL_TREE, false);\n+      access_ref* const pobj = (access.second.mode == access_write_only\n+\t\t\t\t? &data.dst : &data.src);\n+      tree objsize = compute_objsize (ptr, 1, pobj);\n+\n+      /* The size of the destination or source object.  */\n+      tree dstsize = NULL_TREE, srcsize = NULL_TREE;\n+      if (access.second.mode == access_read_only\n+\t  || access.second.mode == access_none)\n+\t{\n+\t  /* For a read-only argument there is no destination.  For\n+\t     no access, set the source as well and differentiate via\n+\t     the access flag below.  */\n+\t  srcsize = objsize;\n+\t  if (access.second.mode == access_read_only\n+\t      || access.second.mode == access_none)\n+\t    {\n+\t      /* For a read-only attribute there is no destination so\n+\t\t clear OBJSIZE.  This emits \"reading N bytes\" kind of\n+\t\t diagnostics instead of the \"writing N bytes\" kind,\n+\t\t unless MODE is none.  */\n+\t      objsize = NULL_TREE;\n+\t    }\n+\t}\n+      else\n+\tdstsize = objsize;\n+\n+      /* Clear the no-warning bit in case it was set by check_access\n+\t in a prior iteration so that accesses via different arguments\n+\t are diagnosed.  */\n+      suppress_warning (stmt, OPT_Wstringop_overflow_, false);\n+      access_mode mode = data.mode;\n+      if (mode == access_deferred)\n+\tmode = TYPE_READONLY (argtype) ? access_read_only : access_read_write;\n+      check_access (stmt, access_size, /*maxread=*/ NULL_TREE, srcsize,\n+\t\t    dstsize, mode, &data);\n+\n+      if (warning_suppressed_p (stmt, OPT_Wstringop_overflow_))\n+\topt_warned = OPT_Wstringop_overflow_;\n+      if (opt_warned != no_warning)\n+\t{\n+\t  if (access.second.internal_p)\n+\t    inform (loc, \"referencing argument %u of type %qT\",\n+\t\t    ptridx + 1, ptrtype);\n+\t  else\n+\t    /* If check_access issued a warning above, append the relevant\n+\t       attribute to the string.  */\n+\t    append_attrname (access, attrstr, sizeof attrstr);\n+\t}\n+    }\n+\n+  if (*attrstr)\n+    {\n+      if (fndecl)\n+\tinform (get_location (fndecl),\n+\t\t\"in a call to function %qD declared with attribute %qs\",\n+\t\tfndecl, attrstr);\n+      else\n+\tinform (get_location (stmt),\n+\t\t\"in a call with type %qT and attribute %qs\",\n+\t\tfntype, attrstr);\n+    }\n+  else if (opt_warned != no_warning)\n+    {\n+      if (fndecl)\n+\tinform (get_location (fndecl),\n+\t\t\"in a call to function %qD\", fndecl);\n+      else\n+\tinform (get_location (stmt),\n+\t\t\"in a call with type %qT\", fntype);\n+    }\n+\n+  /* Set the bit in case if was cleared and not set above.  */\n+  if (opt_warned != no_warning)\n+    suppress_warning (stmt, opt_warned);\n+}\n+\n+/* Check call STMT to an ordinary (non-built-in) function for invalid\n+   accesses.  Return true if a call has been handled.  */\n+\n+bool\n+pass_waccess::check_call (gcall *stmt)\n+{\n+  tree fntype = gimple_call_fntype (stmt);\n+  if (!fntype)\n+    return false;\n+\n+  tree fntypeattrs = TYPE_ATTRIBUTES (fntype);\n+  if (!fntypeattrs)\n+    return false;\n+\n+  /* Map of attribute accewss specifications for function arguments.  */\n+  rdwr_map rdwr_idx;\n+  init_attr_rdwr_indices (&rdwr_idx, fntypeattrs);\n+\n+  unsigned nargs = call_nargs (stmt);\n+  for (unsigned i = 0; i != nargs; ++i)\n+    {\n+      tree arg = call_arg (stmt, i);\n+\n+      /* Save the actual argument that corresponds to the access attribute\n+\t operand for later processing.  */\n+      if (attr_access *access = rdwr_idx.get (i))\n+\t{\n+\t  if (POINTER_TYPE_P (TREE_TYPE (arg)))\n+\t    {\n+\t      access->ptr = arg;\n+\t      // A nonnull ACCESS->SIZE contains VLA bounds.  */\n+\t    }\n+\t  else\n+\t    {\n+\t      access->size = arg;\n+\t      gcc_assert (access->ptr == NULL_TREE);\n+\t    }\n+\t}\n+    }\n+\n+  /* Check attribute access arguments.  */\n+  tree fndecl = gimple_call_fndecl (stmt);\n+  maybe_warn_rdwr_sizes (&rdwr_idx, fndecl, fntype, stmt);\n+\n+  check_alloc_size_call (stmt);\n+  return true;\n+}\n+\n+/* Check arguments in a call STMT for attribute nonstring.  */\n+\n+static void\n+check_nonstring_args (gcall *stmt)\n+{\n+  tree fndecl = gimple_call_fndecl (stmt);\n+\n+  /* Detect passing non-string arguments to functions expecting\n+     nul-terminated strings.  */\n+  maybe_warn_nonstring_arg (fndecl, stmt);\n+}\n+\n /* Check call STMT for invalid accesses.  */\n \n void\n pass_waccess::check (gcall *stmt)\n {\n-  if (gimple_call_builtin_p (stmt, BUILT_IN_NORMAL)\n-      && check_builtin (stmt))\n-    return;\n+  if (gimple_call_builtin_p (stmt, BUILT_IN_NORMAL))\n+    check_builtin (stmt);\n \n-  maybe_emit_free_warning (stmt);\n+  if (is_gimple_call (stmt))\n+    check_call (stmt);\n+\n+  maybe_check_dealloc_call (stmt);\n+\n+  check_nonstring_args (stmt);\n }\n \n /* Check basic block BB for invalid accesses.  */\n@@ -2669,6 +3310,8 @@ pass_waccess::check (basic_block bb)\n unsigned\n pass_waccess::execute (function *fun)\n {\n+  m_ranger = enable_ranger (fun);\n+\n   basic_block bb;\n   FOR_EACH_BB_FN (bb, fun)\n     check (bb);"}, {"sha": "1cd3a28c4212a1ee5de328a21b316a9e593ab908", "filename": "gcc/gimple-ssa-warn-access.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48d4e6818674898f90d9358378c127511ef0f9f/gcc%2Fgimple-ssa-warn-access.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48d4e6818674898f90d9358378c127511ef0f9f/gcc%2Fgimple-ssa-warn-access.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-access.h?ref=b48d4e6818674898f90d9358378c127511ef0f9f", "patch": "@@ -31,7 +31,9 @@ extern void warn_string_no_nul (location_t, tree, const char *, tree,\n \t\t\t\ttree, tree = NULL_TREE, bool = false,\n \t\t\t\tconst wide_int[2] = NULL);\n extern tree unterminated_array (tree, tree * = NULL, bool * = NULL);\n-extern void get_size_range (tree, tree[2], const offset_int[2]);\n+\n+extern bool maybe_warn_nonstring_arg (tree, gimple *);\n+extern bool maybe_warn_nonstring_arg (tree, tree);\n \n class access_data;\n extern bool maybe_warn_for_bound (opt_code, location_t, gimple *, tree,"}, {"sha": "d1df9ca8d4fc1412c4f82777ff00c5959a68c899", "filename": "gcc/gimple-ssa-warn-restrict.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48d4e6818674898f90d9358378c127511ef0f9f/gcc%2Fgimple-ssa-warn-restrict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48d4e6818674898f90d9358378c127511ef0f9f/gcc%2Fgimple-ssa-warn-restrict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-restrict.c?ref=b48d4e6818674898f90d9358378c127511ef0f9f", "patch": "@@ -29,6 +29,7 @@\n #include \"pointer-query.h\"\n #include \"ssa.h\"\n #include \"gimple-pretty-print.h\"\n+#include \"gimple-ssa-warn-access.h\"\n #include \"gimple-ssa-warn-restrict.h\"\n #include \"diagnostic-core.h\"\n #include \"fold-const.h\""}, {"sha": "99caf78bfa7c715f925114ada9efb646451b2e9f", "filename": "gcc/pointer-query.cc", "status": "modified", "additions": 158, "deletions": 37, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48d4e6818674898f90d9358378c127511ef0f9f/gcc%2Fpointer-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48d4e6818674898f90d9358378c127511ef0f9f/gcc%2Fpointer-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-query.cc?ref=b48d4e6818674898f90d9358378c127511ef0f9f", "patch": "@@ -22,58 +22,21 @@\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"backend.h\"\n-#include \"target.h\"\n-#include \"rtl.h\"\n #include \"tree.h\"\n-#include \"memmodel.h\"\n #include \"gimple.h\"\n-#include \"predict.h\"\n-#include \"tm_p.h\"\n #include \"stringpool.h\"\n #include \"tree-vrp.h\"\n-#include \"tree-ssanames.h\"\n-#include \"expmed.h\"\n-#include \"optabs.h\"\n-#include \"emit-rtl.h\"\n-#include \"recog.h\"\n #include \"diagnostic-core.h\"\n-#include \"alias.h\"\n #include \"fold-const.h\"\n-#include \"fold-const-call.h\"\n-#include \"gimple-ssa-warn-restrict.h\"\n-#include \"stor-layout.h\"\n-#include \"calls.h\"\n-#include \"varasm.h\"\n #include \"tree-object-size.h\"\n #include \"tree-ssa-strlen.h\"\n-#include \"realmpfr.h\"\n-#include \"cfgrtl.h\"\n-#include \"except.h\"\n-#include \"dojump.h\"\n-#include \"explow.h\"\n-#include \"stmt.h\"\n-#include \"expr.h\"\n-#include \"libfuncs.h\"\n-#include \"output.h\"\n-#include \"typeclass.h\"\n #include \"langhooks.h\"\n-#include \"value-prof.h\"\n-#include \"builtins.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n-#include \"asan.h\"\n-#include \"internal-fn.h\"\n-#include \"case-cfn-macros.h\"\n #include \"gimple-fold.h\"\n #include \"intl.h\"\n-#include \"tree-dfa.h\"\n-#include \"gimple-iterator.h\"\n-#include \"gimple-ssa.h\"\n-#include \"tree-ssa-live.h\"\n-#include \"tree-outof-ssa.h\"\n #include \"attr-fnspec.h\"\n #include \"gimple-range.h\"\n-\n #include \"pointer-query.h\"\n \n static bool compute_objsize_r (tree, int, access_ref *, ssa_name_limit_t &,\n@@ -311,6 +274,164 @@ gimple_call_return_array (gimple *stmt, offset_int offrng[2], bool *past_end,\n   return NULL_TREE;\n }\n \n+/* Return true when EXP's range can be determined and set RANGE[] to it\n+   after adjusting it if necessary to make EXP a represents a valid size\n+   of object, or a valid size argument to an allocation function declared\n+   with attribute alloc_size (whose argument may be signed), or to a string\n+   manipulation function like memset.\n+   When ALLOW_ZERO is set in FLAGS, allow returning a range of [0, 0] for\n+   a size in an anti-range [1, N] where N > PTRDIFF_MAX.  A zero range is\n+   a (nearly) invalid argument to allocation functions like malloc but it\n+   is a valid argument to functions like memset.\n+   When USE_LARGEST is set in FLAGS set RANGE to the largest valid subrange\n+   in a multi-range, otherwise to the smallest valid subrange.  */\n+\n+bool\n+get_size_range (range_query *query, tree exp, gimple *stmt, tree range[2],\n+\t\tint flags /* = 0 */)\n+{\n+  if (!exp)\n+    return false;\n+\n+  if (tree_fits_uhwi_p (exp))\n+    {\n+      /* EXP is a constant.  */\n+      range[0] = range[1] = exp;\n+      return true;\n+    }\n+\n+  tree exptype = TREE_TYPE (exp);\n+  bool integral = INTEGRAL_TYPE_P (exptype);\n+\n+  wide_int min, max;\n+  enum value_range_kind range_type;\n+\n+  if (!query)\n+    query = get_global_range_query ();\n+\n+  if (integral)\n+    {\n+      value_range vr;\n+\n+      query->range_of_expr (vr, exp, stmt);\n+\n+      if (vr.undefined_p ())\n+\tvr.set_varying (TREE_TYPE (exp));\n+      range_type = vr.kind ();\n+      min = wi::to_wide (vr.min ());\n+      max = wi::to_wide (vr.max ());\n+    }\n+  else\n+    range_type = VR_VARYING;\n+\n+  if (range_type == VR_VARYING)\n+    {\n+      if (integral)\n+\t{\t\n+\t  /* Use the full range of the type of the expression when\n+\t     no value range information is available.  */\n+\t  range[0] = TYPE_MIN_VALUE (exptype);\n+\t  range[1] = TYPE_MAX_VALUE (exptype);\n+\t  return true;\n+\t}\n+\n+      range[0] = NULL_TREE;\n+      range[1] = NULL_TREE;\n+      return false;\n+    }\n+\n+  unsigned expprec = TYPE_PRECISION (exptype);\n+\n+  bool signed_p = !TYPE_UNSIGNED (exptype);\n+\n+  if (range_type == VR_ANTI_RANGE)\n+    {\n+      if (signed_p)\n+\t{\n+\t  if (wi::les_p (max, 0))\n+\t    {\n+\t      /* EXP is not in a strictly negative range.  That means\n+\t\t it must be in some (not necessarily strictly) positive\n+\t\t range which includes zero.  Since in signed to unsigned\n+\t\t conversions negative values end up converted to large\n+\t\t positive values, and otherwise they are not valid sizes,\n+\t\t the resulting range is in both cases [0, TYPE_MAX].  */\n+\t      min = wi::zero (expprec);\n+\t      max = wi::to_wide (TYPE_MAX_VALUE (exptype));\n+\t    }\n+\t  else if (wi::les_p (min - 1, 0))\n+\t    {\n+\t      /* EXP is not in a negative-positive range.  That means EXP\n+\t\t is either negative, or greater than max.  Since negative\n+\t\t sizes are invalid make the range [MAX + 1, TYPE_MAX].  */\n+\t      min = max + 1;\n+\t      max = wi::to_wide (TYPE_MAX_VALUE (exptype));\n+\t    }\n+\t  else\n+\t    {\n+\t      max = min - 1;\n+\t      min = wi::zero (expprec);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  wide_int maxsize = wi::to_wide (max_object_size ());\n+\t  min = wide_int::from (min, maxsize.get_precision (), UNSIGNED);\n+\t  max = wide_int::from (max, maxsize.get_precision (), UNSIGNED);\n+\t  if (wi::eq_p (0, min - 1))\n+\t    {\n+\t      /* EXP is unsigned and not in the range [1, MAX].  That means\n+\t\t it's either zero or greater than MAX.  Even though 0 would\n+\t\t normally be detected by -Walloc-zero, unless ALLOW_ZERO\n+\t\t is set, set the range to [MAX, TYPE_MAX] so that when MAX\n+\t\t is greater than the limit the whole range is diagnosed.  */\n+\t      wide_int maxsize = wi::to_wide (max_object_size ());\n+\t      if (flags & SR_ALLOW_ZERO)\n+\t\t{\n+\t\t  if (wi::leu_p (maxsize, max + 1)\n+\t\t      || !(flags & SR_USE_LARGEST))\n+\t\t    min = max = wi::zero (expprec);\n+\t\t  else\n+\t\t    {\n+\t\t      min = max + 1;\n+\t\t      max = wi::to_wide (TYPE_MAX_VALUE (exptype));\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  min = max + 1;\n+\t\t  max = wi::to_wide (TYPE_MAX_VALUE (exptype));\n+\t\t}\n+\t    }\n+\t  else if ((flags & SR_USE_LARGEST)\n+\t\t   && wi::ltu_p (max + 1, maxsize))\n+\t    {\n+\t      /* When USE_LARGEST is set and the larger of the two subranges\n+\t\t is a valid size, use it...  */\n+\t      min = max + 1;\n+\t      max = maxsize;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* ...otherwise use the smaller subrange.  */\n+\t      max = min - 1;\n+\t      min = wi::zero (expprec);\n+\t    }\n+\t}\n+    }\n+\n+  range[0] = wide_int_to_tree (exptype, min);\n+  range[1] = wide_int_to_tree (exptype, max);\n+\n+  return true;\n+}\n+\n+bool\n+get_size_range (tree exp, tree range[2], int flags /* = 0 */)\n+{\n+  return get_size_range (/*query=*/NULL, exp, /*stmt=*/NULL, range, flags);\n+}\n+\n /* If STMT is a call to an allocation function, returns the constant\n    maximum size of the object allocated by the call represented as\n    sizetype.  If nonnull, sets RNG1[] to the range of the size."}, {"sha": "eb7e90dde036674a0a813077a031a9ffc3382d90", "filename": "gcc/pointer-query.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48d4e6818674898f90d9358378c127511ef0f9f/gcc%2Fpointer-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48d4e6818674898f90d9358378c127511ef0f9f/gcc%2Fpointer-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-query.h?ref=b48d4e6818674898f90d9358378c127511ef0f9f", "patch": "@@ -230,6 +230,17 @@ struct access_data\n   access_mode mode;\n };\n \n+enum size_range_flags\n+  {\n+   /* Set to consider zero a valid range.  */\n+   SR_ALLOW_ZERO = 1,\n+   /* Set to use the largest subrange of a set of ranges as opposed\n+      to the smallest.  */\n+   SR_USE_LARGEST = 2\n+  };\n+extern bool get_size_range (tree, tree[2], int = 0);\n+extern bool get_size_range (range_query *, tree, gimple *, tree[2], int = 0);\n+\n class range_query;\n extern tree gimple_call_alloc_size (gimple *, wide_int[2] = NULL,\n \t\t\t\t    range_query * = NULL);"}, {"sha": "c10773e90a364f3549c3e5e73aeffcf22ef6e9f5", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-72.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48d4e6818674898f90d9358378c127511ef0f9f/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-72.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48d4e6818674898f90d9358378c127511ef0f9f/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-72.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-72.c?ref=b48d4e6818674898f90d9358378c127511ef0f9f", "patch": "@@ -0,0 +1,13 @@\n+/* PR middle-end/101854 - Invalid warning -Wstringop-overflow wrong argument\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+struct A { int a[5]; };\n+\n+struct A g (int*, int[6][8]);\n+\n+struct A f (void)\n+{\n+  int a[2];\n+  return g (a, 0);            // { dg-bogus \"-Wstringop-overflow\" }\n+}"}, {"sha": "4eea625a9669ec23308237b8c87c1d3cbe438b2b", "filename": "gcc/testsuite/gcc.dg/attr-alloc_size-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48d4e6818674898f90d9358378c127511ef0f9f/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48d4e6818674898f90d9358378c127511ef0f9f/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-5.c?ref=b48d4e6818674898f90d9358378c127511ef0f9f", "patch": "@@ -4,7 +4,7 @@\n    zero bytes.  For standard allocation functions the return value is\n    implementation-defined and so relying on it may be a source of bugs.  */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -Wall -Walloc-zero\" } */\n+/* { dg-options \"-O1 -Wall -Walloc-zero\" } */\n \n #define SCHAR_MAX  __SCHAR_MAX__\n #define SCHAR_MIN  (-SCHAR_MAX - 1)"}, {"sha": "3adde5c227068bf42a52305242e60fb9431c9d27", "filename": "gcc/testsuite/gcc.dg/attr-alloc_size-7.c", "status": "modified", "additions": 39, "deletions": 6, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48d4e6818674898f90d9358378c127511ef0f9f/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48d4e6818674898f90d9358378c127511ef0f9f/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-7.c?ref=b48d4e6818674898f90d9358378c127511ef0f9f", "patch": "@@ -4,7 +4,7 @@\n    of the maximum specified by -Walloc-size-larger-than=maximum.  */\n /* { dg-do compile } */\n /* { dg-require-effective-target alloca } */\n-/* { dg-options \"-O2 -Wall -Walloc-size-larger-than=12345\" } */\n+/* { dg-options \"-O1 -Wall -Walloc-size-larger-than=12345\" } */\n \n #define SIZE_MAX   __SIZE_MAX__\n #define MAXOBJSZ   12345\n@@ -13,15 +13,40 @@ typedef __SIZE_TYPE__ size_t;\n \n void sink (void*);\n \n-static size_t maxobjsize (void)\n+#pragma GCC push_options\n+/* Verify that constant evaluation takes place even at -O0.  */\n+#pragma GCC optimize (\"0\")\n+\n+void test_cst (void *p)\n {\n-  return MAXOBJSZ;\n+  enum { max = MAXOBJSZ };\n+\n+  sink (__builtin_aligned_alloc (1, max));\n+  sink (__builtin_aligned_alloc (1, max + 1));   /* { dg-warning \"argument 2 value .12346\\[lu\\]*. exceeds maximum object size 12345\" } */\n+\n+  sink (__builtin_alloca (max));\n+  sink (__builtin_alloca (max + 2));   /* { dg-warning \"argument 1 value .12347\\[lu\\]*. exceeds maximum object size 12345\" } */\n+\n+  sink (__builtin_calloc (1, max));\n+  sink (__builtin_calloc (max, 1));\n+\n+  sink (__builtin_calloc (max / 2, 3));   /* { dg-warning \"product .6172\\[lu\\]* \\\\* 3\\[lu\\]*. of arguments 1 and 2 exceeds maximum object size 12345\" } */\n+  sink (__builtin_calloc (4, max / 3));   /* { dg-warning \"product .4\\[lu\\]* \\\\* 4115\\[lu\\]*. of arguments 1 and 2 exceeds maximum object size 12345\" } */\n+\n+  sink (__builtin_malloc (max));\n+  sink (__builtin_malloc (max + 3));   /* { dg-warning \"argument 1 value .12348\\[lu\\]*. exceeds maximum object size 12345\" } */\n+\n+  sink (__builtin_realloc (p, max));\n+  sink (__builtin_realloc (p, max + 4));  /* { dg-warning \"argument 2 value .12349\\[lu\\]*. exceeds maximum object size 12345\" } */\n }\n \n \n-void test_var (void *p)\n+/* Variable evaluation needs -O1.  */\n+#pragma GCC pop_options\n+\n+__attribute__ ((noipa)) void test_var (void *p)\n {\n-  size_t max = maxobjsize ();\n+  size_t max = MAXOBJSZ;\n \n   sink (__builtin_aligned_alloc (1, max));\n   sink (__builtin_aligned_alloc (1, max + 1));   /* { dg-warning \"argument 2 value .12346\\[lu\\]*. exceeds maximum object size 12345\" } */\n@@ -43,7 +68,15 @@ void test_var (void *p)\n }\n \n \n-void test_range (void *p, size_t range)\n+/* Value range evaluation (apparently) needs -O2 here.  */\n+#pragma GCC optimize (\"2\")\n+\n+static size_t maxobjsize (void)\n+{\n+  return MAXOBJSZ;\n+}\n+\n+__attribute__ ((noipa)) void test_range (void *p, size_t range)\n {\n   /* Make sure the variable is at least as large as the maximum object\n      size but also make sure that it's guaranteed not to be too big to"}, {"sha": "7b47b045b1184aa761b994a98489856fb6751dce", "filename": "gcc/testsuite/gcc.dg/attr-alloc_size-8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48d4e6818674898f90d9358378c127511ef0f9f/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48d4e6818674898f90d9358378c127511ef0f9f/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-8.c?ref=b48d4e6818674898f90d9358378c127511ef0f9f", "patch": "@@ -4,7 +4,7 @@\n    two more specific options override the more general latter option.  */\n /* { dg-do compile } */\n /* { dg-require-effective-target alloca } */\n-/* { dg-options \"-O2 -Walloc-size-larger-than=123 -Walloca-larger-than=234 -Wvla-larger-than=345\" } */\n+/* { dg-options \"-O -Walloc-size-larger-than=123 -Walloca-larger-than=234 -Wvla-larger-than=345\" } */\n \n typedef __SIZE_TYPE__ size_t;\n "}, {"sha": "cba3bca41b3a50557939267b7a06df04b5d042b7", "filename": "gcc/tree.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48d4e6818674898f90d9358378c127511ef0f9f/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48d4e6818674898f90d9358378c127511ef0f9f/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=b48d4e6818674898f90d9358378c127511ef0f9f", "patch": "@@ -14464,6 +14464,60 @@ fndecl_dealloc_argno (tree fndecl)\n   return UINT_MAX;\n }\n \n+/* If EXPR refers to a character array or pointer declared attribute\n+   nonstring, return a decl for that array or pointer and set *REF\n+   to the referenced enclosing object or pointer.  Otherwise return\n+   null.  */\n+\n+tree\n+get_attr_nonstring_decl (tree expr, tree *ref)\n+{\n+  tree decl = expr;\n+  tree var = NULL_TREE;\n+  if (TREE_CODE (decl) == SSA_NAME)\n+    {\n+      gimple *def = SSA_NAME_DEF_STMT (decl);\n+\n+      if (is_gimple_assign (def))\n+\t{\n+\t  tree_code code = gimple_assign_rhs_code (def);\n+\t  if (code == ADDR_EXPR\n+\t      || code == COMPONENT_REF\n+\t      || code == VAR_DECL)\n+\t    decl = gimple_assign_rhs1 (def);\n+\t}\n+      else\n+\tvar = SSA_NAME_VAR (decl);\n+    }\n+\n+  if (TREE_CODE (decl) == ADDR_EXPR)\n+    decl = TREE_OPERAND (decl, 0);\n+\n+  /* To simplify calling code, store the referenced DECL regardless of\n+     the attribute determined below, but avoid storing the SSA_NAME_VAR\n+     obtained above (it's not useful for dataflow purposes).  */\n+  if (ref)\n+    *ref = decl;\n+\n+  /* Use the SSA_NAME_VAR that was determined above to see if it's\n+     declared nonstring.  Otherwise drill down into the referenced\n+     DECL.  */\n+  if (var)\n+    decl = var;\n+  else if (TREE_CODE (decl) == ARRAY_REF)\n+    decl = TREE_OPERAND (decl, 0);\n+  else if (TREE_CODE (decl) == COMPONENT_REF)\n+    decl = TREE_OPERAND (decl, 1);\n+  else if (TREE_CODE (decl) == MEM_REF)\n+    return get_attr_nonstring_decl (TREE_OPERAND (decl, 0), ref);\n+\n+  if (DECL_P (decl)\n+      && lookup_attribute (\"nonstring\", DECL_ATTRIBUTES (decl)))\n+    return decl;\n+\n+  return NULL_TREE;\n+}\n+\n #if CHECKING_P\n \n namespace selftest {"}, {"sha": "905417fd17b1721f6c65d3cdf66a5fd5f920de7f", "filename": "gcc/tree.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b48d4e6818674898f90d9358378c127511ef0f9f/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b48d4e6818674898f90d9358378c127511ef0f9f/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=b48d4e6818674898f90d9358378c127511ef0f9f", "patch": "@@ -6488,4 +6488,10 @@ extern void copy_warning (tree, const_tree);\n    value if it isn't.  */\n extern unsigned fndecl_dealloc_argno (tree);\n \n+/* If an expression refers to a character array or pointer declared\n+   attribute nonstring, return a decl for that array or pointer and\n+   if nonnull, set the second argument to the referenced enclosing\n+   object or pointer.  Otherwise return null.  */\n+extern tree get_attr_nonstring_decl (tree, tree * = NULL);\n+\n #endif  /* GCC_TREE_H  */"}]}