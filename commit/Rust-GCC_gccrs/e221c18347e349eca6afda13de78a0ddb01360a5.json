{"sha": "e221c18347e349eca6afda13de78a0ddb01360a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTIyMWMxODM0N2UzNDllY2E2YWZkYTEzZGU3OGEwZGRiMDEzNjBhNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-05-31T15:29:17Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-05-31T15:29:17Z"}, "message": "alpha.md (reload_*_help): New patterns and splitters.\n\n        * alpha.md (reload_*_help): New patterns and splitters.\n        (reload_*): Use them.\n        (mov[qh]i): Likewise.\n\nFrom-SVN: r27283", "tree": {"sha": "2411bc199b46975b04d755826fd03773b9cd32b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2411bc199b46975b04d755826fd03773b9cd32b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e221c18347e349eca6afda13de78a0ddb01360a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e221c18347e349eca6afda13de78a0ddb01360a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e221c18347e349eca6afda13de78a0ddb01360a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e221c18347e349eca6afda13de78a0ddb01360a5/comments", "author": null, "committer": null, "parents": [{"sha": "efa90f05afe058d369bddb59c4971026f8aecee8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efa90f05afe058d369bddb59c4971026f8aecee8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efa90f05afe058d369bddb59c4971026f8aecee8"}], "stats": {"total": 182, "additions": 142, "deletions": 40}, "files": [{"sha": "87d8fe7e57966943a4e4562555327004c5041074", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e221c18347e349eca6afda13de78a0ddb01360a5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e221c18347e349eca6afda13de78a0ddb01360a5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e221c18347e349eca6afda13de78a0ddb01360a5", "patch": "@@ -1,3 +1,9 @@\n+Mon May 31 15:23:23 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* alpha.md (reload_*_help): New patterns and splitters.\n+\t(reload_*): Use them.\n+\t(mov[qh]i): Likewise.\n+\n Mon May 31 11:48:07 1999  Mark Mitchell  <mark@codesourcery.com>\n \n         * cccp.c (handle_directive): Handle backslash-newlines in quoted"}, {"sha": "6d075e99904ae031e60fd5dcb71c01ee0ef18188", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 136, "deletions": 40, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e221c18347e349eca6afda13de78a0ddb01360a5/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e221c18347e349eca6afda13de78a0ddb01360a5/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=e221c18347e349eca6afda13de78a0ddb01360a5", "patch": "@@ -4563,15 +4563,22 @@\n     {\n       if (aligned_memory_operand (operands[1], QImode))\n \t{\n-\t  rtx aligned_mem, bitnum;\n-\t  rtx scratch = (reload_in_progress\n-\t\t\t ? gen_rtx_REG (SImode, REGNO (operands[0]))\n-\t\t\t : gen_reg_rtx (SImode));\n+\t  if (reload_in_progress)\n+\t    {\n+\t      emit_insn (gen_reload_inqi_help\n+\t\t         (operands[0], operands[1],\n+\t\t\t  gen_rtx_REG (SImode, REGNO (operands[0]))));\n+\t    }\n+\t  else\n+\t    {\n+\t      rtx aligned_mem, bitnum;\n+\t      rtx scratch = gen_reg_rtx (SImode);\n \n-\t  get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n+\t      get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n \n-\t  emit_insn (gen_aligned_loadqi (operands[0], aligned_mem, bitnum,\n-\t\t\t\t\t scratch));\n+\t      emit_insn (gen_aligned_loadqi (operands[0], aligned_mem, bitnum,\n+\t\t\t\t\t     scratch));\n+\t    }\n \t}\n       else\n \t{\n@@ -4674,15 +4681,22 @@\n     {\n       if (aligned_memory_operand (operands[1], HImode))\n \t{\n-\t  rtx aligned_mem, bitnum;\n-\t  rtx scratch = (reload_in_progress\n-\t\t\t ? gen_rtx_REG (SImode, REGNO (operands[0]))\n-\t\t\t : gen_reg_rtx (SImode));\n+\t  if (reload_in_progress)\n+\t    {\n+\t      emit_insn (gen_reload_inhi_help\n+\t\t         (operands[0], operands[1],\n+\t\t\t  gen_rtx_REG (SImode, REGNO (operands[0]))));\n+\t    }\n+\t  else\n+\t    {\n+\t      rtx aligned_mem, bitnum;\n+\t      rtx scratch = gen_reg_rtx (SImode);\n \n-\t  get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n+\t      get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n \n-\t  emit_insn (gen_aligned_loadhi (operands[0], aligned_mem, bitnum,\n-\t\t\t\t\t scratch));\n+\t      emit_insn (gen_aligned_loadhi (operands[0], aligned_mem, bitnum,\n+\t\t\t\t\t     scratch));\n+\t    }\n \t}\n       else\n \t{\n@@ -4760,11 +4774,8 @@\n \n   if (aligned_memory_operand (operands[1], QImode))\n     {\n-      rtx aligned_mem, bitnum;\n-\n-      get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n-      seq = gen_aligned_loadqi (operands[0], aligned_mem, bitnum,\n-\t\t\t\tgen_rtx_REG (SImode, REGNO (operands[2])));\n+      seq = gen_reload_inqi_help (operands[0], operands[1],\n+\t\t\t\t  gen_rtx_REG (SImode, REGNO (operands[2])));\n     }\n   else\n     {\n@@ -4801,11 +4812,8 @@\n \n   if (aligned_memory_operand (operands[1], HImode))\n     {\n-      rtx aligned_mem, bitnum;\n-\n-      get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n-      seq = gen_aligned_loadhi (operands[0], aligned_mem, bitnum,\n-\t\t\t\tgen_rtx_REG (SImode, REGNO (operands[2])));\n+      seq = gen_reload_inhi_help (operands[0], operands[1], \n+\t\t\t\t  gen_rtx_REG (SImode, REGNO (operands[2])));\n     }\n   else\n     {\n@@ -4840,14 +4848,10 @@\n \n   if (aligned_memory_operand (operands[0], QImode))\n     {\n-      rtx aligned_mem, bitnum;\n-\n-      get_aligned_mem (operands[0], &aligned_mem, &bitnum);\n-\n-      emit_insn (gen_aligned_store (aligned_mem, operands[1], bitnum,\n-\t\t\t\t    gen_rtx_REG (SImode, REGNO (operands[2])),\n-\t\t\t\t    gen_rtx_REG (SImode,\n-\t\t\t\t\t\t REGNO (operands[2]) + 1)));\n+      emit_insn (gen_reload_outqi_help\n+\t\t (operands[0], operands[1],\n+\t\t  gen_rtx_REG (SImode, REGNO (operands[2])),\n+\t\t  gen_rtx_REG (SImode, REGNO (operands[2]) + 1)));\n     }\n   else\n     {\n@@ -4880,14 +4884,10 @@\n \n   if (aligned_memory_operand (operands[0], HImode))\n     {\n-      rtx aligned_mem, bitnum;\n-\n-      get_aligned_mem (operands[0], &aligned_mem, &bitnum);\n-\n-      emit_insn (gen_aligned_store (aligned_mem, operands[1], bitnum,\n-\t\t\t\t    gen_rtx_REG (SImode, REGNO (operands[2])),\n-\t\t\t\t    gen_rtx_REG (SImode,\n-\t\t\t\t\t\t REGNO (operands[2]) + 1)));\n+      emit_insn (gen_reload_outhi_help\n+\t\t (operands[0], operands[1],\n+\t\t  gen_rtx_REG (SImode, REGNO (operands[2])),\n+\t\t  gen_rtx_REG (SImode, REGNO (operands[2]) + 1)));\n     }\n   else\n     {\n@@ -4907,6 +4907,102 @@\n     }\n   DONE;\n }\")\n+\n+;; Helpers for the above.  The way reload is structured, we can't\n+;; always get a proper address for a stack slot during reload_foo\n+;; expansion, so we must delay our address manipulations until after.\n+\n+(define_insn \"reload_inqi_help\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"r\")\n+        (match_operand:QI 1 \"memory_operand\" \"m\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"r\"))]\n+  \"! TARGET_BWX && (reload_in_progress || reload_completed)\"\n+  \"#\")\n+\n+(define_insn \"reload_inhi_help\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"r\")\n+        (match_operand:HI 1 \"memory_operand\" \"m\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"r\"))]\n+  \"! TARGET_BWX && (reload_in_progress || reload_completed)\"\n+  \"#\")\n+\n+(define_insn \"reload_outqi_help\"\n+  [(set (match_operand:QI 0 \"memory_operand\" \"m\")\n+        (match_operand:QI 1 \"register_operand\" \"r\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"r\"))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"r\"))]\n+  \"! TARGET_BWX && (reload_in_progress || reload_completed)\"\n+  \"#\")\n+\n+(define_insn \"reload_outhi_help\"\n+  [(set (match_operand:HI 0 \"memory_operand\" \"m\")\n+        (match_operand:HI 1 \"register_operand\" \"r\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"r\"))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"r\"))]\n+  \"! TARGET_BWX && (reload_in_progress || reload_completed)\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:QI 0 \"register_operand\" \"r\")\n+        (match_operand:QI 1 \"memory_operand\" \"m\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"r\"))]\n+  \"! TARGET_BWX && reload_completed\"\n+  [(const_int 0)]\n+  \"\n+{\n+  rtx aligned_mem, bitnum;\n+  get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n+  emit_insn (gen_aligned_loadqi (operands[0], aligned_mem, bitnum,\n+\t\t\t\t operands[2]));\n+  DONE;\n+}\")\n+  \n+(define_split\n+  [(set (match_operand:HI 0 \"register_operand\" \"r\")\n+        (match_operand:HI 1 \"memory_operand\" \"m\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"r\"))]\n+  \"! TARGET_BWX && reload_completed\"\n+  [(const_int 0)]\n+  \"\n+{\n+  rtx aligned_mem, bitnum;\n+  get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n+  emit_insn (gen_aligned_loadhi (operands[0], aligned_mem, bitnum,\n+\t\t\t\t operands[2]));\n+  DONE;\n+}\")\n+  \n+(define_split\n+  [(set (match_operand:QI 0 \"memory_operand\" \"m\")\n+        (match_operand:QI 1 \"register_operand\" \"r\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"r\"))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"r\"))]\n+  \"! TARGET_BWX && reload_completed\"\n+  [(const_int 0)]\n+  \"\n+{\n+  rtx aligned_mem, bitnum;\n+  get_aligned_mem (operands[0], &aligned_mem, &bitnum);\n+  emit_insn (gen_aligned_store (aligned_mem, operands[1], bitnum,\n+\t\t\t\toperands[2], operands[3]));\n+  DONE;\n+}\")\n+\n+(define_split\n+  [(set (match_operand:HI 0 \"memory_operand\" \"m\")\n+        (match_operand:HI 1 \"register_operand\" \"r\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"r\"))\n+   (clobber (match_operand:SI 3 \"register_operand\" \"r\"))]\n+  \"! TARGET_BWX && reload_completed\"\n+  [(const_int 0)]\n+  \"\n+{\n+  rtx aligned_mem, bitnum;\n+  get_aligned_mem (operands[0], &aligned_mem, &bitnum);\n+  emit_insn (gen_aligned_store (aligned_mem, operands[1], bitnum,\n+\t\t\t\toperands[2], operands[3]));\n+  DONE;\n+}\")\n \f\n ;; Bit field extract patterns which use ext[wlq][lh]\n "}]}