{"sha": "774b9d213ac7f52fd74f3aca414775356fb6770c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc0YjlkMjEzYWM3ZjUyZmQ3NGYzYWNhNDE0Nzc1MzU2ZmI2NzcwYw==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2006-02-07T15:11:10Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2006-02-07T15:11:10Z"}, "message": "[multiple changes]\n\n2006-02-07  Paolo Carlini  <pcarlini@suse.de>\t\n\n\t* include/tr1/hashtable: Trivial formatting fixes.\n\n2006-02-07  Paolo Carlini  <pcarlini@suse.de>\n\t    Zak Kipling  <zak@transversal.com>\n\n\tPR libstdc++/26127\n\t* include/tr1/hashtable (hashtable<>::key_equal): Define.\n\t(hashtable<>::bucket, rehash_base<>::max_load_factor): Fix.\n\t* testsuite/tr1/6_containers/unordered/hashtable/26127.cc: New.\n\nCo-Authored-By: Zak Kipling <zak@transversal.com>\n\nFrom-SVN: r110697", "tree": {"sha": "6b18e0d7498ee480393dbe729f6b39f4e25f8acf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b18e0d7498ee480393dbe729f6b39f4e25f8acf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/774b9d213ac7f52fd74f3aca414775356fb6770c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/774b9d213ac7f52fd74f3aca414775356fb6770c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/774b9d213ac7f52fd74f3aca414775356fb6770c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/774b9d213ac7f52fd74f3aca414775356fb6770c/comments", "author": null, "committer": null, "parents": [{"sha": "4f0de5dd33ec2f8eb0aa43da72d9cc493478f077", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f0de5dd33ec2f8eb0aa43da72d9cc493478f077", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f0de5dd33ec2f8eb0aa43da72d9cc493478f077"}], "stats": {"total": 100, "additions": 80, "deletions": 20}, "files": [{"sha": "66489338ec637794655621de32f20b9482b0984d", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/774b9d213ac7f52fd74f3aca414775356fb6770c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/774b9d213ac7f52fd74f3aca414775356fb6770c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=774b9d213ac7f52fd74f3aca414775356fb6770c", "patch": "@@ -1,3 +1,15 @@\n+2006-02-07  Paolo Carlini  <pcarlini@suse.de>\t\n+\n+\t* include/tr1/hashtable: Trivial formatting fixes.\n+\n+2006-02-07  Paolo Carlini  <pcarlini@suse.de>\n+\t    Zak Kipling  <zak@transversal.com>\n+\n+\tPR libstdc++/26127\n+\t* include/tr1/hashtable (hashtable<>::key_equal): Define.\n+\t(hashtable<>::bucket, rehash_base<>::max_load_factor): Fix.\n+\t* testsuite/tr1/6_containers/unordered/hashtable/26127.cc: New.\n+\n 2006-02-07  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/tr1/cmath: New."}, {"sha": "e9b73c65d6379e7762d1a39bd05c2aae5b86dce8", "filename": "libstdc++-v3/include/tr1/hashtable", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/774b9d213ac7f52fd74f3aca414775356fb6770c/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/774b9d213ac7f52fd74f3aca414775356fb6770c/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable?ref=774b9d213ac7f52fd74f3aca414775356fb6770c", "patch": "@@ -653,7 +653,7 @@ namespace Internal\n       max_load_factor() const\n       {\n \tconst Hashtable* This = static_cast<const Hashtable*>(this);\n-\treturn This->rehash_policy()->max_load_factor();\n+\treturn This->rehash_policy().max_load_factor();\n       }\n \n       void\n@@ -836,7 +836,7 @@ namespace Internal\n       typedef std::size_t hash_code_t;\n   \n       hash_code_t\n-      m_hash_code (const Key& k) const\n+      m_hash_code(const Key& k) const\n       { return m_h1(k); }\n   \n       std::size_t\n@@ -1081,6 +1081,13 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       max_size() const\n       { return m_node_allocator.max_size(); }\n \n+    public:                             // Observers\n+      key_equal\n+      key_eq() const\n+      { return this->m_eq; }\n+\n+      // hash_function, if present, comes from hash_code_base.\n+\n     public:\t\t\t\t// Bucket operations\n       size_type\n       bucket_count() const\n@@ -1094,9 +1101,11 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       bucket_size(size_type n) const\n       { return std::distance(begin(n), end(n)); }\n   \n-      size_type bucket(const key_type& k) const\n+      size_type\n+      bucket(const key_type& k) const\n       { \n-\treturn this->bucket_index(k, this->m_hash_code, this->m_bucket_count);\n+\treturn this->bucket_index(k, this->m_hash_code(k),\n+\t\t\t\t  this->m_bucket_count);\n       }\n \n       local_iterator\n@@ -1477,9 +1486,9 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     find(const key_type& k)\n     {\n-      typename hashtable::hash_code_t code = this->m_hash_code (k);\n+      typename hashtable::hash_code_t code = this->m_hash_code(k);\n       std::size_t n = this->bucket_index(k, code, this->bucket_count());\n-      node* p = find_node (m_buckets[n], k, code);\n+      node* p = find_node(m_buckets[n], k, code);\n       return p ? iterator(p, m_buckets + n) : this->end();\n     }\n   \n@@ -1491,9 +1500,9 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     find(const key_type& k) const\n     {\n-      typename hashtable::hash_code_t code = this->m_hash_code (k);\n+      typename hashtable::hash_code_t code = this->m_hash_code(k);\n       std::size_t n = this->bucket_index(k, code, this->bucket_count());\n-      node* p = find_node (m_buckets[n], k, code);\n+      node* p = find_node(m_buckets[n], k, code);\n       return p ? const_iterator(p, m_buckets + n) : this->end();\n     }\n   \n@@ -1505,11 +1514,11 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     count(const key_type& k) const\n     {\n-      typename hashtable::hash_code_t code = this->m_hash_code (k);\n-      std::size_t n = this->bucket_index (k, code, this->bucket_count());\n+      typename hashtable::hash_code_t code = this->m_hash_code(k);\n+      std::size_t n = this->bucket_index(k, code, this->bucket_count());\n       size_t result = 0;\n       for (node* p = m_buckets[n]; p ; p = p->m_next)\n-\tif (this->compare (k, code, p))\n+\tif (this->compare(k, code, p))\n \t  ++result;\n       return result;\n     }\n@@ -1525,7 +1534,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     equal_range(const key_type& k)\n     {\n-      typename hashtable::hash_code_t code = this->m_hash_code (k);\n+      typename hashtable::hash_code_t code = this->m_hash_code(k);\n       std::size_t n = this->bucket_index(k, code, this->bucket_count());\n       node** head = m_buckets + n;\n       node* p = find_node (*head, k, code);\n@@ -1558,16 +1567,16 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     equal_range(const key_type& k) const\n     {\n-      typename hashtable::hash_code_t code = this->m_hash_code (k);\n+      typename hashtable::hash_code_t code = this->m_hash_code(k);\n       std::size_t n = this->bucket_index(k, code, this->bucket_count());\n       node** head = m_buckets + n;\n-      node* p = find_node (*head, k, code);\n+      node* p = find_node(*head, k, code);\n \n       if (p)\n \t{\n \t  node* p1 = p->m_next;\n \t  for (; p1 ; p1 = p1->m_next)\n-\t    if (!this->compare (k, code, p1))\n+\t    if (!this->compare(k, code, p1))\n \t      break;\n \n \t  const_iterator first(p, head);\n@@ -1608,7 +1617,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     insert(const value_type& v, std::tr1::true_type)\n     {\n       const key_type& k = this->m_extract(v);\n-      typename hashtable::hash_code_t code = this->m_hash_code (k);\n+      typename hashtable::hash_code_t code = this->m_hash_code(k);\n       size_type n = this->bucket_index(k, code, m_bucket_count);\n       \n       if (node* p = find_node(m_buckets[n], k, code))\n@@ -1657,7 +1666,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \tm_rehash(do_rehash.second);\n \n       const key_type& k = this->m_extract(v);\n-      typename hashtable::hash_code_t code = this->m_hash_code (k);\n+      typename hashtable::hash_code_t code = this->m_hash_code(k);\n       size_type n = this->bucket_index(k, code, m_bucket_count);\n       \n       node* new_node = m_allocate_node (v);\n@@ -1760,15 +1769,15 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     erase(const key_type& k)\n     {\n-      typename hashtable::hash_code_t code = this->m_hash_code (k);\n+      typename hashtable::hash_code_t code = this->m_hash_code(k);\n       size_type n = this->bucket_index(k, code, m_bucket_count);\n       size_type result = 0;\n       \n       node** slot = m_buckets + n;\n-      while (*slot && ! this->compare (k, code, *slot))\n+      while (*slot && ! this->compare(k, code, *slot))\n \tslot = &((*slot)->m_next);\n \n-      while (*slot && this->compare (k, code, *slot))\n+      while (*slot && this->compare(k, code, *slot))\n \t{\n \t  node* n = *slot;\n \t  *slot = n->m_next;"}, {"sha": "d14a625b554c67a9f6c890a1baab869da257c602", "filename": "libstdc++-v3/testsuite/tr1/6_containers/unordered/hashtable/26127.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/774b9d213ac7f52fd74f3aca414775356fb6770c/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fhashtable%2F26127.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/774b9d213ac7f52fd74f3aca414775356fb6770c/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fhashtable%2F26127.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fhashtable%2F26127.cc?ref=774b9d213ac7f52fd74f3aca414775356fb6770c", "patch": "@@ -0,0 +1,39 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2006 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 6.3 Unordered associative containers\n+\n+#include <tr1/unordered_set>\n+\n+// libstdc++/26127\n+void test01()\n+{\n+  std::tr1::unordered_set<int> s;\n+\n+  s.bucket(42);\n+  s.key_eq();\n+  s.max_load_factor();  \n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}