{"sha": "8ddfdbc265cfe0da5b727559d3736876d0198afb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRkZmRiYzI2NWNmZTBkYTViNzI3NTU5ZDM3MzY4NzZkMDE5OGFmYg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-01-17T18:22:34Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-01-17T18:22:34Z"}, "message": "re PR c++/61636 (generic lambda: segfault / \"cannot call member function without object\")\n\n\tPR c++/61636\n\t* cp-tree.h (maybe_generic_this_capture): Declare.\n\t* lambda.c (resolvable_dummy_lambda): New, broken out of ...\n\t(maybe_resolve_dummy): ... here.  Call it.\n\t(maybe_generic_this_capture): New.\n\t* parser.c (cp_parser_postfix_expression): Speculatively capture\n\tthis in generic lambda in unresolved member function call.\n\t* pt.c (tsubst_copy_and_build): Force hard error from failed\n\tmember function lookup in generic lambda.\n\n\tPR c++/61636\n\t* g++.dg/cpp1y/pr61636-1.C: New.\n\t* g++.dg/cpp1y/pr61636-2.C: New.\n\t* g++.dg/cpp1y/pr61636-3.C: New.\n\nFrom-SVN: r244544", "tree": {"sha": "127551e9b5d51e1763e5a76af78e43a959b28a43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/127551e9b5d51e1763e5a76af78e43a959b28a43"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ddfdbc265cfe0da5b727559d3736876d0198afb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ddfdbc265cfe0da5b727559d3736876d0198afb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ddfdbc265cfe0da5b727559d3736876d0198afb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ddfdbc265cfe0da5b727559d3736876d0198afb/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f46fe37e86aa04522258dad374d0c7bf9c443ed3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f46fe37e86aa04522258dad374d0c7bf9c443ed3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f46fe37e86aa04522258dad374d0c7bf9c443ed3"}], "stats": {"total": 256, "additions": 231, "deletions": 25}, "files": [{"sha": "d24b2ae23ad39d6d2c33724be6c618d8cfe30ac5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddfdbc265cfe0da5b727559d3736876d0198afb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddfdbc265cfe0da5b727559d3736876d0198afb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8ddfdbc265cfe0da5b727559d3736876d0198afb", "patch": "@@ -1,3 +1,15 @@\n+2017-01-17  Nathan Sidwell  <nathan@acm.org>\n+\n+\tPR c++/61636\n+\t* cp-tree.h (maybe_generic_this_capture): Declare.\n+\t* lambda.c (resolvable_dummy_lambda): New, broken out of ...\n+\t(maybe_resolve_dummy): ... here.  Call it.\n+\t(maybe_generic_this_capture): New.\n+\t* parser.c (cp_parser_postfix_expression): Speculatively capture\n+\tthis in generic lambda in unresolved member function call.\n+\t* pt.c (tsubst_copy_and_build): Force hard error from failed\n+\tmember function lookup in generic lambda.\n+\n 2017-01-17  Aldy Hernandez  <aldyh@redhat.com>\n \n \tPR c++/70565"}, {"sha": "0c8f147c6b24ca6bd1e9ec6cbd3ffe3b64bc3eb3", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddfdbc265cfe0da5b727559d3736876d0198afb/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddfdbc265cfe0da5b727559d3736876d0198afb/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8ddfdbc265cfe0da5b727559d3736876d0198afb", "patch": "@@ -6551,6 +6551,7 @@ extern bool is_capture_proxy\t\t\t(tree);\n extern bool is_normal_capture_proxy             (tree);\n extern void register_capture_members\t\t(tree);\n extern tree lambda_expr_this_capture            (tree, bool);\n+extern void maybe_generic_this_capture\t\t(tree, tree);\n extern tree maybe_resolve_dummy\t\t\t(tree, bool);\n extern tree current_nonlambda_function\t\t(void);\n extern tree nonlambda_method_basetype\t\t(void);"}, {"sha": "4d22c3d37d98c365e45500f17aab1a64aefa5ae1", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 48, "deletions": 13, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddfdbc265cfe0da5b727559d3736876d0198afb/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddfdbc265cfe0da5b727559d3736876d0198afb/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=8ddfdbc265cfe0da5b727559d3736876d0198afb", "patch": "@@ -793,16 +793,14 @@ lambda_expr_this_capture (tree lambda, bool add_capture_p)\n   return result;\n }\n \n-/* We don't want to capture 'this' until we know we need it, i.e. after\n-   overload resolution has chosen a non-static member function.  At that\n-   point we call this function to turn a dummy object into a use of the\n-   'this' capture.  */\n+/* Return the current LAMBDA_EXPR, if this is a resolvable dummy\n+   object.  NULL otherwise..  */\n \n-tree\n-maybe_resolve_dummy (tree object, bool add_capture_p)\n+static tree\n+resolvable_dummy_lambda (tree object)\n {\n   if (!is_dummy_object (object))\n-    return object;\n+    return NULL_TREE;\n \n   tree type = TYPE_MAIN_VARIANT (TREE_TYPE (object));\n   gcc_assert (!TYPE_PTR_P (type));\n@@ -812,18 +810,55 @@ maybe_resolve_dummy (tree object, bool add_capture_p)\n       && LAMBDA_TYPE_P (current_class_type)\n       && lambda_function (current_class_type)\n       && DERIVED_FROM_P (type, current_nonlambda_class_type ()))\n-    {\n-      /* In a lambda, need to go through 'this' capture.  */\n-      tree lam = CLASSTYPE_LAMBDA_EXPR (current_class_type);\n-      tree cap = lambda_expr_this_capture (lam, add_capture_p);\n-      if (cap && cap != error_mark_node)\n+    return CLASSTYPE_LAMBDA_EXPR (current_class_type);\n+\n+  return NULL_TREE;\n+}\n+\n+/* We don't want to capture 'this' until we know we need it, i.e. after\n+   overload resolution has chosen a non-static member function.  At that\n+   point we call this function to turn a dummy object into a use of the\n+   'this' capture.  */\n+\n+tree\n+maybe_resolve_dummy (tree object, bool add_capture_p)\n+{\n+  if (tree lam = resolvable_dummy_lambda (object))\n+    if (tree cap = lambda_expr_this_capture (lam, add_capture_p))\n+      if (cap != error_mark_node)\n \tobject = build_x_indirect_ref (EXPR_LOCATION (object), cap,\n \t\t\t\t       RO_NULL, tf_warning_or_error);\n-    }\n \n   return object;\n }\n \n+/* When parsing a generic lambda containing an argument-dependent\n+   member function call we defer overload resolution to instantiation\n+   time.  But we have to know now whether to capture this or not.\n+   Do that if FNS contains any non-static fns.\n+   The std doesn't anticipate this case, but I expect this to be the\n+   outcome of discussion.  */\n+\n+void\n+maybe_generic_this_capture (tree object, tree fns)\n+{\n+  if (tree lam = resolvable_dummy_lambda (object))\n+    if (!LAMBDA_EXPR_THIS_CAPTURE (lam))\n+      {\n+\t/* We've not yet captured, so look at the function set of\n+\t   interest.  */\n+\tif (BASELINK_P (fns))\n+\t  fns = BASELINK_FUNCTIONS (fns);\n+\tfor (; fns; fns = OVL_NEXT (fns))\n+\t  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (OVL_CURRENT (fns)))\n+\t    {\n+\t      /* Found a non-static member.  Capture this.  */\n+\t      lambda_expr_this_capture (lam, true);\n+\t      break;\n+\t    }\n+      }\n+}\n+\n /* Returns the innermost non-lambda function.  */\n \n tree"}, {"sha": "6d3b8777cf2897e402dcabdbc6119d112e6e173a", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddfdbc265cfe0da5b727559d3736876d0198afb/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddfdbc265cfe0da5b727559d3736876d0198afb/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=8ddfdbc265cfe0da5b727559d3736876d0198afb", "patch": "@@ -6971,6 +6971,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\t\t|| type_dependent_expression_p (fn)\n \t\t\t|| any_type_dependent_arguments_p (args)))\n \t\t  {\n+\t\t    maybe_generic_this_capture (instance, fn);\n \t\t    postfix_expression\n \t\t      = build_nt_call_vec (postfix_expression, args);\n \t\t    release_tree_vector (args);"}, {"sha": "022ffda9ed28337676b4a70042e5a09c912180d7", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 33, "deletions": 12, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddfdbc265cfe0da5b727559d3736876d0198afb/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddfdbc265cfe0da5b727559d3736876d0198afb/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8ddfdbc265cfe0da5b727559d3736876d0198afb", "patch": "@@ -17142,19 +17142,34 @@ tsubst_copy_and_build (tree t,\n \n \t\tif (unq != function)\n \t\t  {\n-\t\t    tree fn = unq;\n-\t\t    if (INDIRECT_REF_P (fn))\n-\t\t      fn = TREE_OPERAND (fn, 0);\n-\t\t    if (TREE_CODE (fn) == COMPONENT_REF)\n-\t\t      fn = TREE_OPERAND (fn, 1);\n-\t\t    if (is_overloaded_fn (fn))\n-\t\t      fn = get_first_fn (fn);\n-\t\t    if (permerror (EXPR_LOC_OR_LOC (t, input_location),\n-\t\t\t\t   \"%qD was not declared in this scope, \"\n-\t\t\t\t   \"and no declarations were found by \"\n-\t\t\t\t   \"argument-dependent lookup at the point \"\n-\t\t\t\t   \"of instantiation\", function))\n+\t\t    /* In a lambda fn, we have to be careful to not\n+\t\t       introduce new this captures.  Legacy code can't\n+\t\t       be using lambdas anyway, so it's ok to be\n+\t\t       stricter.  */\n+\t\t    bool in_lambda = (current_class_type\n+\t\t\t\t      && LAMBDA_TYPE_P (current_class_type));\n+\t\t    char const *msg = \"%qD was not declared in this scope, \"\n+\t\t      \"and no declarations were found by \"\n+\t\t      \"argument-dependent lookup at the point \"\n+\t\t      \"of instantiation\";\n+\n+\t\t    bool diag = true;\n+\t\t    if (in_lambda)\n+\t\t      error_at (EXPR_LOC_OR_LOC (t, input_location),\n+\t\t\t\tmsg, function);\n+\t\t    else\n+\t\t      diag = permerror (EXPR_LOC_OR_LOC (t, input_location),\n+\t\t\t\t\tmsg, function);\n+\t\t    if (diag)\n \t\t      {\n+\t\t\ttree fn = unq;\n+\t\t\tif (INDIRECT_REF_P (fn))\n+\t\t\t  fn = TREE_OPERAND (fn, 0);\n+\t\t\tif (TREE_CODE (fn) == COMPONENT_REF)\n+\t\t\t  fn = TREE_OPERAND (fn, 1);\n+\t\t\tif (is_overloaded_fn (fn))\n+\t\t\t  fn = get_first_fn (fn);\n+\n \t\t\tif (!DECL_P (fn))\n \t\t\t  /* Can't say anything more.  */;\n \t\t\telse if (DECL_CLASS_SCOPE_P (fn))\n@@ -17177,7 +17192,13 @@ tsubst_copy_and_build (tree t,\n \t\t\t  inform (DECL_SOURCE_LOCATION (fn),\n \t\t\t\t  \"%qD declared here, later in the \"\n \t\t\t\t  \"translation unit\", fn);\n+\t\t\tif (in_lambda)\n+\t\t\t  {\n+\t\t\t    release_tree_vector (call_args);\n+\t\t\t    RETURN (error_mark_node);\n+\t\t\t  }\n \t\t      }\n+\n \t\t    function = unq;\n \t\t  }\n \t      }"}, {"sha": "8697c8a1f3808770aa421ac42242dbe6b88f8925", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddfdbc265cfe0da5b727559d3736876d0198afb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddfdbc265cfe0da5b727559d3736876d0198afb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8ddfdbc265cfe0da5b727559d3736876d0198afb", "patch": "@@ -1,3 +1,10 @@\n+2017-01-17  Nathan Sidwell  <nathan@acm.org>\n+\n+\tPR c++/61636\n+\t* g++.dg/cpp1y/pr61636-1.C: New.\n+\t* g++.dg/cpp1y/pr61636-2.C: New.\n+\t* g++.dg/cpp1y/pr61636-3.C: New.\n+\n 2017-01-17  Martin Sebor  <msebor@redhat.com>\n \n \tPR testsuite/79115\n@@ -214,6 +221,7 @@\n \n \tPR target/79004\n \t* gcc.target/powerpc/pr79004.c: New test.\n+\n 2017-01-12  Martin Sebor  <msebor@redhat.com>\n \n \t* gcc.dg/pr78138.c: Adjust."}, {"sha": "9426d5f12178a5f978dfbfaad8d22bf11dd755e1", "filename": "gcc/testsuite/g++.dg/cpp1y/pr61636-1.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddfdbc265cfe0da5b727559d3736876d0198afb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr61636-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddfdbc265cfe0da5b727559d3736876d0198afb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr61636-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr61636-1.C?ref=8ddfdbc265cfe0da5b727559d3736876d0198afb", "patch": "@@ -0,0 +1,31 @@\n+// PR c++/61636\n+// { dg-do compile { target c++14 } }\n+\n+// ICE because we figure this capture too late.\n+\n+struct Base\n+{\n+  void Bar (int);\n+};\n+\n+struct A : Base {\n+  void b ();\n+  void Foo (int);\n+  using Base::Bar;\n+  template <typename T> void Baz (T);\n+};\n+\n+void A::b() {\n+\n+  auto lam = [&](auto asdf) { Foo (asdf); };\n+\n+  lam (0);\n+\n+  auto lam1 = [&](auto asdf) { Bar (asdf); };\n+\n+  lam1 (0);\n+\n+  auto lam2 = [&](auto asdf) { Baz (asdf); };\n+\n+  lam2 (0);\n+}"}, {"sha": "a1bd597295a2450adf90aab33782b0e286f7c090", "filename": "gcc/testsuite/g++.dg/cpp1y/pr61636-2.C", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddfdbc265cfe0da5b727559d3736876d0198afb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr61636-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddfdbc265cfe0da5b727559d3736876d0198afb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr61636-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr61636-2.C?ref=8ddfdbc265cfe0da5b727559d3736876d0198afb", "patch": "@@ -0,0 +1,72 @@\n+// PR c++/61636\n+// { dg-do run { target c++14 } }\n+\n+// Check we don't capture this (too) unnecessarily\n+\n+struct A {\n+  int b ();\n+  void f (int) {}\n+  static void f (double) {}\n+\n+  static void g (int) {}\n+  static void g (double) {}\n+};\n+\n+struct O {\n+  void x (int) {}\n+  static void x (double) {}\n+};\n+\n+namespace N {\n+  void y (double) {}\n+}\n+\n+int Check (bool expect, unsigned size)\n+{\n+  return (expect ? sizeof (void *) : 1) != size;\n+}\n+\n+int A::b() {\n+  int r = 0;\n+\n+  // one of the functions is non-static\n+  auto l0 = [&](auto z) { f (z); };\n+  r += Check (true, sizeof l0);\n+  l0(0.0); // doesn't need this capture for A::f(double), but too late\n+  l0 (0); // Needs this capture for A::f(int)\n+\n+  // no fn is non-static.\n+  auto l00 = [&](auto z) { g (z); };\n+  r += Check (false, sizeof l00);\n+  l00(0.0); \n+  l00 (0);\n+\n+  // sizeof isn't an evaluation context, so no this capture\n+  auto l1 = [&](auto z) { sizeof (f (z), 1); };\n+  r += Check (false, sizeof l1);\n+  l1(0.0); l1 (0); \n+\n+  auto l2 = [&](auto) { f (2.4); };\n+  auto l3 = [&](auto) { f (0); };\n+  l2(0); l3(0); l2(0.0); l3 (0.0);\n+  r += Check (false, sizeof l2);\n+  r += Check (true, sizeof l3);\n+\n+  auto l4 = [&](auto) { O::x (2.4); };\n+  auto l5 = [&](auto) { N::y (2.4); };\n+  auto l6 = [&](auto) { };\n+  l4(0); l5(0); l6(0);\n+  l4(0.0); l5(0.0); l6(0.0);\n+  r += Check (false, sizeof l4);\n+  r += Check (false, sizeof l5);\n+  r += Check (false, sizeof l6);\n+\n+  return r;\n+}\n+\n+int main ()\n+{\n+  A a;\n+\n+  return a.b () ? 1 : 0;\n+}"}, {"sha": "18f83fe435e0b3adc0d01a156df85c65d2c1d992", "filename": "gcc/testsuite/g++.dg/cpp1y/pr61636-3.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddfdbc265cfe0da5b727559d3736876d0198afb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr61636-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddfdbc265cfe0da5b727559d3736876d0198afb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr61636-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr61636-3.C?ref=8ddfdbc265cfe0da5b727559d3736876d0198afb", "patch": "@@ -0,0 +1,25 @@\n+// PR c++/61636\n+// { dg-do compile { target c++14 } }\n+// permissiveness doesn't make this permitted\n+// { dg-additional-options \"-fpermissive\" }\n+\n+// ICE because we attempt to use dependent Foo during error recovery\n+// and die with an unexpected this capture need.\n+\n+template <typename T> struct Base\n+{\n+  void Foo (int);\n+};\n+\n+template <typename T> struct A : Base<T> {\n+  void b ();\n+};\n+\n+template <typename T> void A<T>::b() {\n+\n+  auto lam = [&](auto asdf) { Foo (asdf); }; // { dg-error \"not declared\" }\n+\n+  lam (T(0));\n+}\n+\n+template void A<int>::b ();"}]}