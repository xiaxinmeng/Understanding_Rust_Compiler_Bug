{"sha": "5f2e59d44bc4aa1dd5e2fd9d2b412b85519fb39d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWYyZTU5ZDQ0YmM0YWExZGQ1ZTJmZDlkMmI0MTJiODU1MTlmYjM5ZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2012-01-27T09:35:03Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-01-27T09:35:03Z"}, "message": "ada-tree.h (DECL_ALIASED_P): New flag.\n\n\t* gcc-interface/ada-tree.h (DECL_ALIASED_P): New flag.\n\t* gcc-interface/decl.c (is_variable_size): Rename to...\n\t(type_has_variable_size): ...this.\n\t(adjust_packed): Adjust to above renaming.\n\t(gnat_to_gnu_field): Set DECL_ALIASED_P on the field.\n\t(field_is_artificial): New predicate.\n\t(field_is_aliased): Likewise.\n\t(field_has_self_size): Likewise.\n\t(field_has_variable_size): Likewise.\n\t(components_to_record): Record information for the final layout during\n\tthe first pass on fields.\n\tIf there is an aliased field placed after a field whose length depends\n\ton discriminants, put all the fields of the latter sort, last.\n\nFrom-SVN: r183609", "tree": {"sha": "2316952bdf1880a92959189d3c487e8302fcc19d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2316952bdf1880a92959189d3c487e8302fcc19d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f2e59d44bc4aa1dd5e2fd9d2b412b85519fb39d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f2e59d44bc4aa1dd5e2fd9d2b412b85519fb39d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f2e59d44bc4aa1dd5e2fd9d2b412b85519fb39d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f2e59d44bc4aa1dd5e2fd9d2b412b85519fb39d/comments", "author": null, "committer": null, "parents": [{"sha": "ae25db4568034756df727d432dd48caa5e5f41dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae25db4568034756df727d432dd48caa5e5f41dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae25db4568034756df727d432dd48caa5e5f41dc"}], "stats": {"total": 163, "additions": 140, "deletions": 23}, "files": [{"sha": "433fff461d8c01e9edff48c181625559ad56f9c2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f2e59d44bc4aa1dd5e2fd9d2b412b85519fb39d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f2e59d44bc4aa1dd5e2fd9d2b412b85519fb39d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5f2e59d44bc4aa1dd5e2fd9d2b412b85519fb39d", "patch": "@@ -1,3 +1,19 @@\n+2012-01-27  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/ada-tree.h (DECL_ALIASED_P): New flag.\n+\t* gcc-interface/decl.c (is_variable_size): Rename to...\n+\t(type_has_variable_size): ...this.\n+\t(adjust_packed): Adjust to above renaming.\n+\t(gnat_to_gnu_field): Set DECL_ALIASED_P on the field.\n+\t(field_is_artificial): New predicate.\n+\t(field_is_aliased): Likewise.\n+\t(field_has_self_size): Likewise.\n+\t(field_has_variable_size): Likewise.\n+\t(components_to_record): Record information for the final layout during\n+\tthe first pass on fields.\n+\tIf there is an aliased field placed after a field whose length depends\n+\ton discriminants, put all the fields of the latter sort, last.\n+\n 2012-01-27  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/gigi.h (get_minimal_subprog_decl): Declare."}, {"sha": "0c32f210deae3f3675d8f6133b7f8ba25ddbc65c", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f2e59d44bc4aa1dd5e2fd9d2b412b85519fb39d/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f2e59d44bc4aa1dd5e2fd9d2b412b85519fb39d/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=5f2e59d44bc4aa1dd5e2fd9d2b412b85519fb39d", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2011, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2012, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -344,6 +344,9 @@ do {\t\t\t\t\t\t   \\\n    pair of INDIRECT_REFs is needed to access the object.  */\n #define DECL_BY_DOUBLE_REF_P(NODE) DECL_LANG_FLAG_0 (PARM_DECL_CHECK (NODE))\n \n+/* Nonzero in a FIELD_DECL if it is declared as aliased.  */\n+#define DECL_ALIASED_P(NODE) DECL_LANG_FLAG_0 (FIELD_DECL_CHECK (NODE))\n+\n /* Nonzero in a TYPE_DECL if this is the declaration of a Taft amendment type\n    in the main unit, i.e. the full declaration is available.  */\n #define DECL_TAFT_TYPE_P(NODE) DECL_LANG_FLAG_0 (TYPE_DECL_CHECK (NODE))"}, {"sha": "bc0804aa472a1e97f46a6a43e0577defaaff220a", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 85, "deletions": 22, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f2e59d44bc4aa1dd5e2fd9d2b412b85519fb39d/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f2e59d44bc4aa1dd5e2fd9d2b412b85519fb39d/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=5f2e59d44bc4aa1dd5e2fd9d2b412b85519fb39d", "patch": "@@ -145,7 +145,7 @@ static void prepend_one_attribute_to (struct attrib **,\n \t\t\t\t      enum attr_type, tree, tree, Node_Id);\n static void prepend_attributes (Entity_Id, struct attrib **);\n static tree elaborate_expression (Node_Id, Entity_Id, tree, bool, bool, bool);\n-static bool is_variable_size (tree);\n+static bool type_has_variable_size (tree);\n static tree elaborate_expression_1 (tree, Entity_Id, tree, bool, bool);\n static tree elaborate_expression_2 (tree, Entity_Id, tree, bool, bool,\n \t\t\t\t    unsigned int);\n@@ -6848,7 +6848,7 @@ adjust_packed (tree field_type, tree record_type, int packed)\n      because we cannot create temporaries of non-fixed size in case\n      we need to take the address of the field.  See addressable_p and\n      the notes on the addressability issues for further details.  */\n-  if (is_variable_size (field_type))\n+  if (type_has_variable_size (field_type))\n     return 0;\n \n   /* If the alignment of the record is specified and the field type\n@@ -7123,6 +7123,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n     = create_field_decl (gnu_field_id, gnu_field_type, gnu_record_type,\n \t\t\t gnu_size, gnu_pos, packed, Is_Aliased (gnat_field));\n   Sloc_to_locus (Sloc (gnat_field), &DECL_SOURCE_LOCATION (gnu_field));\n+  DECL_ALIASED_P (gnu_field) = Is_Aliased (gnat_field);\n   TREE_THIS_VOLATILE (gnu_field) = TREE_SIDE_EFFECTS (gnu_field) = is_volatile;\n \n   if (Ekind (gnat_field) == E_Discriminant)\n@@ -7136,7 +7137,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n    field of variable size or is a record that has a field such a field.  */\n \n static bool\n-is_variable_size (tree type)\n+type_has_variable_size (tree type)\n {\n   tree field;\n \n@@ -7151,12 +7152,68 @@ is_variable_size (tree type)\n     return false;\n \n   for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n-    if (is_variable_size (TREE_TYPE (field)))\n+    if (type_has_variable_size (TREE_TYPE (field)))\n       return true;\n \n   return false;\n }\n \f\n+/* Return true if FIELD is an artificial field.  */\n+\n+static bool\n+field_is_artificial (tree field)\n+{\n+  /* These fields are generated by the front-end proper.  */\n+  if (IDENTIFIER_POINTER (DECL_NAME (field)) [0] == '_')\n+    return true;\n+\n+  /* These fields are generated by gigi.  */\n+  if (DECL_INTERNAL_P (field))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Return true if FIELD is a non-artificial aliased field.  */\n+\n+static bool\n+field_is_aliased (tree field)\n+{\n+  if (field_is_artificial (field))\n+    return false;\n+\n+  return DECL_ALIASED_P (field);\n+}\n+\n+/* Return true if FIELD is a non-artificial field with self-referential\n+   size.  */\n+\n+static bool\n+field_has_self_size (tree field)\n+{\n+  if (field_is_artificial (field))\n+    return false;\n+\n+  if (DECL_SIZE (field) && TREE_CODE (DECL_SIZE (field)) == INTEGER_CST)\n+    return false;\n+\n+  return CONTAINS_PLACEHOLDER_P (TYPE_SIZE (TREE_TYPE (field)));\n+}\n+\n+/* Return true if FIELD is a non-artificial field with variable size.  */\n+\n+static bool\n+field_has_variable_size (tree field)\n+{\n+  if (field_is_artificial (field))\n+    return false;\n+\n+  if (DECL_SIZE (field) && TREE_CODE (DECL_SIZE (field)) == INTEGER_CST)\n+    return false;\n+\n+  return TREE_CODE (TYPE_SIZE (TREE_TYPE (field))) != INTEGER_CST;\n+}\n+\n /* qsort comparer for the bit positions of two record components.  */\n \n static int\n@@ -7219,6 +7276,8 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n {\n   bool all_rep_and_size = all_rep && TYPE_SIZE (gnu_record_type);\n   bool layout_with_rep = false;\n+  bool has_self_field = false;\n+  bool has_aliased_after_self_field = false;\n   Node_Id component_decl, variant_part;\n   tree gnu_field, gnu_next, gnu_last;\n   tree gnu_rep_part = NULL_TREE;\n@@ -7270,6 +7329,12 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t\tgnu_field_list = gnu_field;\n \t\tif (!gnu_last)\n \t\t  gnu_last = gnu_field;\n+\n+\t\t/* And record information for the final layout.  */\n+\t\tif (field_has_self_size (gnu_field))\n+\t\t  has_self_field = true;\n+\t\telse if (has_self_field && field_is_aliased (gnu_field))\n+\t\t  has_aliased_after_self_field = true;\n \t      }\n \t  }\n \n@@ -7505,33 +7570,25 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t  continue;\n \t}\n \n-      /* Reorder non-internal fields with non-fixed size.  */\n-      if (reorder\n-\t  && !DECL_INTERNAL_P (gnu_field)\n-\t  && !(DECL_SIZE (gnu_field)\n-\t       && TREE_CODE (DECL_SIZE (gnu_field)) == INTEGER_CST))\n+      if ((reorder || has_aliased_after_self_field)\n+\t  && field_has_self_size (gnu_field))\n \t{\n-\t  tree type_size = TYPE_SIZE (TREE_TYPE (gnu_field));\n-\n-\t  if (CONTAINS_PLACEHOLDER_P (type_size))\n-\t    {\n-\t      MOVE_FROM_FIELD_LIST_TO (gnu_self_list);\n-\t      continue;\n-\t    }\n+\t  MOVE_FROM_FIELD_LIST_TO (gnu_self_list);\n+\t  continue;\n+\t}\n \n-\t  if (TREE_CODE (type_size) != INTEGER_CST)\n-\t    {\n-\t      MOVE_FROM_FIELD_LIST_TO (gnu_var_list);\n-\t      continue;\n-\t    }\n+      if (reorder && field_has_variable_size (gnu_field))\n+\t{\n+\t  MOVE_FROM_FIELD_LIST_TO (gnu_var_list);\n+\t  continue;\n \t}\n \n       gnu_last = gnu_field;\n     }\n \n #undef MOVE_FROM_FIELD_LIST_TO\n \n-  /* If permitted, we reorder the components as follows:\n+  /* If permitted, we reorder the fields as follows:\n \n        1) all fixed length fields,\n        2) all fields whose length doesn't depend on discriminants,\n@@ -7544,6 +7601,12 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n       = chainon (nreverse (gnu_self_list),\n \t\t chainon (nreverse (gnu_var_list), gnu_field_list));\n \n+  /* Otherwise, if there is an aliased field placed after a field whose length\n+     depends on discriminants, we put all the fields of the latter sort, last.\n+     We need to do this in case an object of this record type is mutable.  */\n+  else if (has_aliased_after_self_field)\n+    gnu_field_list = chainon (nreverse (gnu_self_list), gnu_field_list);\n+\n   /* If P_REP_LIST is nonzero, this means that we are asked to move the fields\n      in our REP list to the previous level because this level needs them in\n      order to do a correct layout, i.e. avoid having overlapping fields.  */"}, {"sha": "66a5eedf1845401e59e3cf87fc7c0c6ad20d9d49", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f2e59d44bc4aa1dd5e2fd9d2b412b85519fb39d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f2e59d44bc4aa1dd5e2fd9d2b412b85519fb39d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5f2e59d44bc4aa1dd5e2fd9d2b412b85519fb39d", "patch": "@@ -1,3 +1,7 @@\n+2012-01-27  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/discr33.adb: New test.\n+\n 2012-01-27  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/limited_with3.ad[sb): New test."}, {"sha": "e667e7f27815b87013a1fc736073be1a0d101fb7", "filename": "gcc/testsuite/gnat.dg/discr33.adb", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f2e59d44bc4aa1dd5e2fd9d2b412b85519fb39d/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr33.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f2e59d44bc4aa1dd5e2fd9d2b412b85519fb39d/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr33.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr33.adb?ref=5f2e59d44bc4aa1dd5e2fd9d2b412b85519fb39d", "patch": "@@ -0,0 +1,31 @@\n+-- { dg-do run }\n+\n+procedure Discr33 is\n+\n+   subtype Int is Integer range 1..100;\n+\n+   type T (D : Int := 1) is\n+      record\n+         A : Integer;\n+         B : String (1..D);\n+         C : aliased Integer;\n+      end record;\n+\n+   Var : T := (D => 1, A => 1234, B => \"x\", C => 4567);\n+\n+   type Int_Ref is access all Integer;\n+   Pointer_To_C : Int_Ref := Var.C'Access;\n+\n+begin\n+\n+   if Pointer_To_C.all /= 4567 then\n+      raise Program_Error;\n+   end if;\n+\n+   Var := (D => 26, A => 1234, B => \"abcdefghijklmnopqrstuvwxyz\", C => 2345);\n+\n+   if Pointer_To_C.all /= 2345 then\n+      raise Program_Error;\n+   end if;\n+\n+end Discr33;"}]}