{"sha": "f729943cf65ec9d475acccc5d04d7752680e19a3", "node_id": "C_kwDOANBUbNoAKGY3Mjk5NDNjZjY1ZWM5ZDQ3NWFjY2NjNWQwNGQ3NzUyNjgwZTE5YTM", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2021-08-30T21:41:29Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-10-04T08:45:08Z"}, "message": "[Ada] Fix resolution of Declare_Expressions involving transient scopes\n\ngcc/ada/\n\n\t* sem_res.adb (Resolve_Declare_Expression): Use tree traversals\n\tto perform name capture of local entities in the expression of\n\tthe construct.\n\t* exp_util.adb (Possible_Side_Effects_In_SPARK): Do not apply to\n\tthe prefix of an attribute reference Reduce when that prefix is\n\tan aggregate, because it will be expanded into a loop, and has\n\tno identifiable type.", "tree": {"sha": "e4a0af27aeed2223d437c72897f130ab6b01be66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4a0af27aeed2223d437c72897f130ab6b01be66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f729943cf65ec9d475acccc5d04d7752680e19a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f729943cf65ec9d475acccc5d04d7752680e19a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f729943cf65ec9d475acccc5d04d7752680e19a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f729943cf65ec9d475acccc5d04d7752680e19a3/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e1e74a162c751014b43d609207aaf75ed4dd428", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e1e74a162c751014b43d609207aaf75ed4dd428", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e1e74a162c751014b43d609207aaf75ed4dd428"}], "stats": {"total": 113, "additions": 64, "deletions": 49}, "files": [{"sha": "c0966fb0b96c008b023023500168e68eea6efa1e", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f729943cf65ec9d475acccc5d04d7752680e19a3/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f729943cf65ec9d475acccc5d04d7752680e19a3/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=f729943cf65ec9d475acccc5d04d7752680e19a3", "patch": "@@ -11737,10 +11737,15 @@ package body Exp_Util is\n       --  case and it is better not to make an additional one for the attribute\n       --  itself, because the return type of many of them is universal integer,\n       --  which is a very large type for a temporary.\n+      --  The prefix of an attribute reference Reduce may be syntactically an\n+      --  aggregate, but will be expanded into a loop, so no need to remove\n+      --  side-effects.\n \n       if Nkind (Exp) = N_Attribute_Reference\n         and then Side_Effect_Free_Attribute (Attribute_Name (Exp))\n         and then Side_Effect_Free (Expressions (Exp), Name_Req, Variable_Ref)\n+        and then (Attribute_Name (Exp) /= Name_Reduce\n+                   or else Nkind (Prefix (Exp)) /= N_Aggregate)\n         and then not Is_Name_Reference (Prefix (Exp))\n       then\n          Remove_Side_Effects (Prefix (Exp), Name_Req, Variable_Ref);"}, {"sha": "4dc3827acba4848233431f50c52fb675450efda9", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 59, "deletions": 49, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f729943cf65ec9d475acccc5d04d7752680e19a3/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f729943cf65ec9d475acccc5d04d7752680e19a3/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=f729943cf65ec9d475acccc5d04d7752680e19a3", "patch": "@@ -7487,66 +7487,76 @@ package body Sem_Res is\n      (N   : Node_Id;\n       Typ : Entity_Id)\n    is\n-      Decl                 : Node_Id;\n-      Need_Transient_Scope : Boolean := False;\n-   begin\n-      --  Install the scope created for local declarations, if\n-      --  any. The syntax allows a Declare_Expression with no\n-      --  declarations, in analogy with block statements.\n-      --  Note that that scope has no explicit declaration, but\n-      --  appears as the scope of all entities declared therein.\n+      Expr : constant Node_Id := Expression (N);\n \n-      Decl := First (Actions (N));\n-      while Present (Decl) loop\n-         exit when Nkind (Decl)\n-                     in N_Object_Declaration | N_Object_Renaming_Declaration;\n-         Next (Decl);\n-      end loop;\n+      Decl  : Node_Id;\n+      Local : Entity_Id := Empty;\n \n-      if Present (Decl) then\n+      function Replace_Local (N  : Node_Id) return Traverse_Result;\n+      --  Use a tree traversal to replace each ocurrence of the name of\n+      --  a local object declared in the construct, with the corresponding\n+      --  entity. This replaces the usual way to perform name capture by\n+      --  visibility, because it is not possible to place on the scope\n+      --  stack the fake scope created for the analysis of the local\n+      --  declarations; such a scope conflicts with the transient scopes\n+      --  that may be generated if the expression includes function calls\n+      --  requiring finalization.\n \n-         --  Need to establish a transient scope in case Expression (N)\n-         --  requires actions to be wrapped.\n+      -------------------\n+      -- Replace_Local --\n+      -------------------\n \n-         declare\n-            Node : Node_Id;\n-         begin\n-            Node := First (Actions (N));\n-            while Present (Node) loop\n-               if Nkind (Node) = N_Object_Declaration\n-                 and then Requires_Transient_Scope\n-                            (Etype (Defining_Identifier (Node)))\n-               then\n-                  Need_Transient_Scope := True;\n-                  exit;\n-               end if;\n+      function Replace_Local (N  : Node_Id) return Traverse_Result is\n+      begin\n+         --  The identifier may be the prefix of a selected component,\n+         --  but not a selector name, because the local entities do not\n+         --  have a scope that can be named: a selected component whose\n+         --  selector is a homonym of a local entity must denote some\n+         --  global entity.\n+\n+         if Nkind (N) = N_Identifier\n+           and then Chars (N) = Chars (Local)\n+           and then No (Entity (N))\n+           and then\n+             (Nkind (Parent (N)) /= N_Selected_Component\n+               or else N = Prefix (Parent (N)))\n+         then\n+            Set_Entity (N, Local);\n+            Set_Etype (N, Etype (Local));\n+         end if;\n \n-               Next (Node);\n-            end loop;\n-         end;\n+         return OK;\n+      end Replace_Local;\n \n-         if Need_Transient_Scope then\n-            Establish_Transient_Scope (Decl, Manage_Sec_Stack => True);\n-         else\n-            Push_Scope (Scope (Defining_Identifier (Decl)));\n+      procedure Replace_Local_Ref is new Traverse_Proc (Replace_Local);\n+\n+      --  Start of processing for  Resolve_Declare_Expression\n+\n+   begin\n+\n+      Decl := First (Actions (N));\n+\n+      while Present (Decl) loop\n+         if Nkind (Decl) in\n+            N_Object_Declaration | N_Object_Renaming_Declaration\n+              and then Comes_From_Source (Defining_Identifier (Decl))\n+         then\n+            Local := Defining_Identifier (Decl);\n+            Replace_Local_Ref (Expr);\n          end if;\n \n-         declare\n-            E : Entity_Id := First_Entity (Current_Scope);\n-         begin\n-            while Present (E) loop\n-               Set_Current_Entity (E);\n-               Set_Is_Immediately_Visible (E);\n-               Next_Entity (E);\n-            end loop;\n-         end;\n+         Next (Decl);\n+      end loop;\n \n-         Resolve (Expression (N), Typ);\n-         End_Scope;\n+      --  The end of the declarative list is a freeze point for the\n+      --  local declarations.\n \n-      else\n-         Resolve (Expression (N), Typ);\n+      if Present (Local) then\n+         Decl := Parent (Local);\n+         Freeze_All (First_Entity (Scope (Local)), Decl);\n       end if;\n+\n+      Resolve (Expr, Typ);\n    end Resolve_Declare_Expression;\n \n    -----------------------------------------"}]}