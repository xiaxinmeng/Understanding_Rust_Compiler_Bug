{"sha": "5925f0ec54ab5ed773935eec09a602f58fa0ca2c", "node_id": "C_kwDOANBUbNoAKDU5MjVmMGVjNTRhYjVlZDc3MzkzNWVlYzA5YTYwMmY1OGZhMGNhMmM", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-11-15T14:32:21Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-11-15T14:32:21Z"}, "message": "c++: remove i_c_e_p parm from tsubst_copy_and_build\n\nIt seems the only and original purpose of tsubst_copy_and_build's\nintegral_constant_expression_p boolean parameter (added in r116276, which\npredates the constexpr machinery) is to diagnose certain constructs that\naren't allowed to appear in a C++98 integral constant expression\ncontext, specifically casts to a non-integral type (diagnosed from the\n*_CAST_EXPR case of tsubst_copy_and_build) or dependent names that\nresolve to a non-constant decl (diagnosed from the IDENTIFIER_NODE case\nof tsubst_copy_and_build).  The parameter has no effect outside of C++98\nAFAICT.\n\nBut diagnosing such constructs should arguably be the job of the constexpr\nmachinery (e.g. is_constant_expression) after substitution, and doing it\nduring substitution by way of an additional parameter complicates the\nAPI of this workhorse function for what amounts to a couple of archaic\nC++98 restrictions.  And it seems is_constant_expression already does a\ngood job of diagnosing the aforementioned two constructs in C++98 mode,\nat least as far as our testsuite is concerned.\n\nSo this patch removes this parameter from tsubst_copy_and_build,\ntsubst_expr and tsubst_copy_and_build_call_args.  The only interesting\nchanges are to potential_constant_expression_1 and the IDENTIFIER_NODE\nand *_CAST_EXPR cases of tsubst_copy_and_build; the rest are mechanical\nadjustments to the functions' signatures and their call sites.\n\ngcc/cp/ChangeLog:\n\n\t* constexpr.cc (potential_constant_expression_1)\n\t<case *_CAST_EXPR>: Use\n\tcast_valid_in_integral_constant_expression_p instead of\n\topen coding it.\n\t* constraint.cc (tsubst_valid_expression_requirement): Adjust\n\tcalls to tsubst_copy_and_build and tsubst_expr.\n\t(tsubst_constraint): Likewise.\n\t(satisfy_atom): Likewise.\n\t(diagnose_trait_expr): Likewise.\n\t* cp-tree.h (tsubst_copy_and_build): Remove i_c_e_p parameter.\n\t(tsubst_expr): Likewise.\n\t* init.cc (get_nsdmi): Adjust calls to tsubst_copy_and_build\n\tand tsubst_expr.\n\t* pt.cc (expand_integer_pack): Likewise.\n\t(instantiate_non_dependent_expr_internal): Likewise.\n\t(tsubst_friend_function): Likewise.\n\t(tsubst_attribute): Likewise.\n\t(instantiate_class_template): Likewise.\n\t(tsubst_template_arg): Likewise.\n\t(gen_elem_of_pack_expansion_instantiation): Likewise.\n\t(tsubst_fold_expr_init): Likewise.\n\t(tsubst_pack_expansion): Likewise.\n\t(tsubst_default_argument): Likewise.\n\t(tsubst_function_decl): Likewise.\n\t(tsubst_decl): Likewise.\n\t(tsubst_arg_types): Likewise.\n\t(tsubst_exception_specification): Likewise.\n\t(tsubst): Likewise.\n\t(tsubst_init): Likewise.\n\t(tsubst_copy): Likewise.\n\t(tsubst_omp_clause_decl): Likewise.\n\t(tsubst_omp_clauses): Likewise.\n\t(tsubst_copy_asm_operands): Likewise.\n\t(tsubst_omp_for_iterator): Likewise.\n\t(tsubst_expr): Likewise.  Remove i_c_e_p parameter.\n\t(tsubst_omp_udr): Likewise.\n\t(tsubst_non_call_postfix_expression): Likewise.  Remove i_c_e_p parameter.\n\t(tsubst_lambda_expr): Likewise.\n\t(tsubst_copy_and_build_call_args): Likewise.\n\t(tsubst_copy_and_build): Likewise.  Remove i_c_e_p parameter.\n\t<case IDENTIFIER_NODE>: Adjust call to finish_id_expression\n\tfollowing removal of i_c_e_p.\n\t<case *_CAST_EXPR>: Remove C++98-specific cast validity check\n\tguarded by i_c_e_p.\n\t(maybe_instantiate_noexcept): Adjust calls to\n\ttsubst_copy_and_build and tsubst_expr.\n\t(instantiate_body): Likewise.\n\t(instantiate_decl): Likewise.\n\t(tsubst_initializer_list): Likewise.\n\t(tsubst_enum): Likewise.\n\ngcc/objcp/ChangeLog:\n\n\t* objcp-lang.cc (objcp_tsubst_copy_and_build): Adjust calls to\n\ttsubst_copy_and_build and tsubst_expr.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/template/crash55.C: Don't expect additional\n\tC++98-specific diagnostics.\n\t* g++.dg/template/ref3.C: Remove C++98-specific xfail.", "tree": {"sha": "fc38375379d93d0a5e7abe1b1a2aeb868ecc268e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc38375379d93d0a5e7abe1b1a2aeb868ecc268e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5925f0ec54ab5ed773935eec09a602f58fa0ca2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5925f0ec54ab5ed773935eec09a602f58fa0ca2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5925f0ec54ab5ed773935eec09a602f58fa0ca2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5925f0ec54ab5ed773935eec09a602f58fa0ca2c/comments", "author": null, "committer": null, "parents": [{"sha": "c52c322627dd0f206b4bf7f7c94ab42bf5e61b6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c52c322627dd0f206b4bf7f7c94ab42bf5e61b6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c52c322627dd0f206b4bf7f7c94ab42bf5e61b6f"}], "stats": {"total": 279, "additions": 94, "deletions": 185}, "files": [{"sha": "e665839f5b1b074a60edbe3a203e4be6de61e664", "filename": "gcc/cp/constexpr.cc", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5925f0ec54ab5ed773935eec09a602f58fa0ca2c/gcc%2Fcp%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5925f0ec54ab5ed773935eec09a602f58fa0ca2c/gcc%2Fcp%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.cc?ref=5925f0ec54ab5ed773935eec09a602f58fa0ca2c", "patch": "@@ -9460,9 +9460,7 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n     case STATIC_CAST_EXPR:\n     case REINTERPRET_CAST_EXPR:\n     case IMPLICIT_CONV_EXPR:\n-      if (cxx_dialect < cxx11\n-\t  && !dependent_type_p (TREE_TYPE (t))\n-\t  && !INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (t)))\n+      if (!cast_valid_in_integral_constant_expression_p (TREE_TYPE (t)))\n \t/* In C++98, a conversion to non-integral type can't be part of a\n \t   constant expression.  */\n \t{"}, {"sha": "3ddbd5353303b6f0f7a874e7d00114e1da89b38c", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5925f0ec54ab5ed773935eec09a602f58fa0ca2c/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5925f0ec54ab5ed773935eec09a602f58fa0ca2c/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=5925f0ec54ab5ed773935eec09a602f58fa0ca2c", "patch": "@@ -1921,7 +1921,7 @@ hash_placeholder_constraint (tree c)\n static tree\n tsubst_valid_expression_requirement (tree t, tree args, sat_info info)\n {\n-  tree r = tsubst_expr (t, args, tf_none, info.in_decl, false);\n+  tree r = tsubst_expr (t, args, tf_none, info.in_decl);\n   if (convert_to_void (r, ICV_STATEMENT, tf_none) != error_mark_node)\n     return r;\n \n@@ -1932,7 +1932,7 @@ tsubst_valid_expression_requirement (tree t, tree args, sat_info info)\n \t{\n \t  inform (loc, \"the required expression %qE is invalid, because\", t);\n \t  if (r == error_mark_node)\n-\t    tsubst_expr (t, args, info.complain, info.in_decl, false);\n+\t    tsubst_expr (t, args, info.complain, info.in_decl);\n \t  else\n \t    convert_to_void (r, ICV_STATEMENT, info.complain);\n \t}\n@@ -1941,7 +1941,7 @@ tsubst_valid_expression_requirement (tree t, tree args, sat_info info)\n     }\n   else if (info.noisy ())\n     {\n-      r = tsubst_expr (t, args, info.complain, info.in_decl, false);\n+      r = tsubst_expr (t, args, info.complain, info.in_decl);\n       convert_to_void (r, ICV_STATEMENT, info.complain);\n     }\n \n@@ -2706,7 +2706,7 @@ tsubst_constraint (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n      constraint-expressions of a declaration.  */\n   processing_constraint_expression_sentinel s;\n   cp_unevaluated u;\n-  tree expr = tsubst_expr (t, args, complain, in_decl, false);\n+  tree expr = tsubst_expr (t, args, complain, in_decl);\n   return expr;\n }\n \n@@ -2954,13 +2954,13 @@ satisfy_atom (tree t, tree args, sat_info info)\n \n   /* Apply the parameter mapping (i.e., just substitute).  */\n   tree expr = ATOMIC_CONSTR_EXPR (t);\n-  tree result = tsubst_expr (expr, args, quiet.complain, quiet.in_decl, false);\n+  tree result = tsubst_expr (expr, args, quiet.complain, quiet.in_decl);\n   if (result == error_mark_node)\n     {\n       /* If substitution results in an invalid type or expression, the constraint\n \t is not satisfied. Replay the substitution.  */\n       if (info.diagnose_unsatisfaction_p ())\n-\ttsubst_expr (expr, args, info.complain, info.in_decl, false);\n+\ttsubst_expr (expr, args, info.complain, info.in_decl);\n       return cache.save (inst_cache.save (boolean_false_node));\n     }\n \n@@ -3587,7 +3587,7 @@ diagnose_trait_expr (tree expr, tree args)\n   /* Build a \"fake\" version of the instantiated trait, so we can\n      get the instantiated types from result.  */\n   ++processing_template_decl;\n-  expr = tsubst_expr (expr, args, tf_none, NULL_TREE, false);\n+  expr = tsubst_expr (expr, args, tf_none, NULL_TREE);\n   --processing_template_decl;\n \n   tree t1 = TRAIT_EXPR_TYPE1 (expr);"}, {"sha": "8c9beb865680553bd59f32af7fcbc90708c71fd0", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5925f0ec54ab5ed773935eec09a602f58fa0ca2c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5925f0ec54ab5ed773935eec09a602f58fa0ca2c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5925f0ec54ab5ed773935eec09a602f58fa0ca2c", "patch": "@@ -7383,10 +7383,8 @@ extern void instantiate_pending_templates\t(int);\n extern tree tsubst_default_argument\t\t(tree, int, tree, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree tsubst (tree, tree, tsubst_flags_t, tree);\n-extern tree tsubst_copy_and_build\t\t(tree, tree, tsubst_flags_t,\n-\t\t\t\t\t\t tree, bool = false);\n-extern tree tsubst_expr                         (tree, tree, tsubst_flags_t,\n-                                                 tree, bool);\n+extern tree tsubst_copy_and_build\t\t(tree, tree, tsubst_flags_t, tree);\n+extern tree tsubst_expr                         (tree, tree, tsubst_flags_t, tree);\n extern tree tsubst_pack_expansion\t\t(tree, tree, tsubst_flags_t, tree);\n extern tree tsubst_argument_pack\t\t(tree, tree, tsubst_flags_t, tree);\n extern tree tsubst_template_args\t\t(tree, tree, tsubst_flags_t, tree);"}, {"sha": "2fff4ad2dc716f72ebec04102c9430c3caf43ebf", "filename": "gcc/cp/init.cc", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5925f0ec54ab5ed773935eec09a602f58fa0ca2c/gcc%2Fcp%2Finit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5925f0ec54ab5ed773935eec09a602f58fa0ca2c/gcc%2Fcp%2Finit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.cc?ref=5925f0ec54ab5ed773935eec09a602f58fa0ca2c", "patch": "@@ -620,10 +620,8 @@ get_nsdmi (tree member, bool in_ctor, tsubst_flags_t complain)\n \t  start_lambda_scope (member);\n \n \t  /* Do deferred instantiation of the NSDMI.  */\n-\t  init = (tsubst_copy_and_build\n-\t\t  (init, DECL_TI_ARGS (member),\n-\t\t   complain, member,\n-\t\t   /*integral_constant_expression_p=*/false));\n+\t  init = tsubst_copy_and_build (init, DECL_TI_ARGS (member),\n+\t\t\t\t\tcomplain, member);\n \t  init = digest_nsdmi_init (member, init, complain);\n \n \t  finish_lambda_scope ();"}, {"sha": "e6017b34c0c9834bfd6703f4090f890546b0fff0", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 79, "deletions": 161, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5925f0ec54ab5ed773935eec09a602f58fa0ca2c/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5925f0ec54ab5ed773935eec09a602f58fa0ca2c/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=5925f0ec54ab5ed773935eec09a602f58fa0ca2c", "patch": "@@ -3772,8 +3772,7 @@ expand_integer_pack (tree call, tree args, tsubst_flags_t complain,\n \t\t     tree in_decl)\n {\n   tree ohi = CALL_EXPR_ARG (call, 0);\n-  tree hi = tsubst_copy_and_build (ohi, args, complain, in_decl,\n-\t\t\t\t   true/*int_cst*/);\n+  tree hi = tsubst_copy_and_build (ohi, args, complain, in_decl);\n \n   if (instantiation_dependent_expression_p (hi))\n     {\n@@ -6360,8 +6359,7 @@ instantiate_non_dependent_expr_internal (tree expr, tsubst_flags_t complain)\n   return tsubst_copy_and_build (expr,\n \t\t\t\t/*args=*/NULL_TREE,\n \t\t\t\tcomplain,\n-\t\t\t\t/*in_decl=*/NULL_TREE,\n-\t\t\t\t/*integral_constant_expression_p=*/true);\n+\t\t\t\t/*in_decl=*/NULL_TREE);\n }\n \n /* Instantiate the non-dependent expression EXPR.  */\n@@ -11195,8 +11193,7 @@ tsubst_friend_function (tree decl, tree args)\n \t current class with same name.  */\n       push_nested_namespace (ns);\n       fns = tsubst_expr (DECL_TI_TEMPLATE (decl), args,\n-\t\t\t tf_warning_or_error, NULL_TREE,\n-\t\t\t /*integral_constant_expression_p=*/false);\n+\t\t\t tf_warning_or_error, NULL_TREE);\n       pop_nested_namespace (ns);\n       arglist = tsubst (DECL_TI_ARGS (decl), args,\n \t\t\ttf_warning_or_error, NULL_TREE);\n@@ -11612,9 +11609,7 @@ tsubst_attribute (tree t, tree *decl_p, tree args,\n \t\t\t      get_attribute_name (t)))\n     {\n       ++cp_unevaluated_operand;\n-      tree varid\n-\t= tsubst_expr (TREE_PURPOSE (val), args, complain,\n-\t\t       in_decl, /*integral_constant_expression_p=*/false);\n+      tree varid = tsubst_expr (TREE_PURPOSE (val), args, complain, in_decl);\n       --cp_unevaluated_operand;\n       tree chain = TREE_CHAIN (val);\n       location_t match_loc = cp_expr_loc_or_input_loc (TREE_PURPOSE (chain));\n@@ -11650,7 +11645,7 @@ tsubst_attribute (tree t, tree *decl_p, tree args,\n \t\t\ttree v = TREE_VALUE (t3);\n \t\t\tif (TREE_CODE (v) == STRING_CST && allow_string)\n \t\t\t  continue;\n-\t\t\tv = tsubst_expr (v, args, complain, in_decl, true);\n+\t\t\tv = tsubst_expr (v, args, complain, in_decl);\n \t\t\tv = fold_non_dependent_expr (v);\n \t\t\tif (!INTEGRAL_TYPE_P (TREE_TYPE (v))\n \t\t\t    || (TREE_PURPOSE (t3) == score\n@@ -11696,8 +11691,7 @@ tsubst_attribute (tree t, tree *decl_p, tree args,\n   else if (attribute_takes_identifier_p (get_attribute_name (t)))\n     {\n       tree chain\n-\t= tsubst_expr (TREE_CHAIN (val), args, complain, in_decl,\n-\t\t       /*integral_constant_expression_p=*/false);\n+\t= tsubst_expr (TREE_CHAIN (val), args, complain, in_decl);\n       if (chain != TREE_CHAIN (val))\n \tval = tree_cons (NULL_TREE, TREE_VALUE (val), chain);\n     }\n@@ -11720,8 +11714,7 @@ tsubst_attribute (tree t, tree *decl_p, tree args,\n       return list;\n     }\n   else\n-    val = tsubst_expr (val, args, complain, in_decl,\n-\t\t       /*integral_constant_expression_p=*/false);\n+    val = tsubst_expr (val, args, complain, in_decl);\n \n   if (val == error_mark_node)\n     return error_mark_node;\n@@ -12163,8 +12156,7 @@ instantiate_class_template (tree type)\n \t    {\n \t      /* Build new TYPE_FIELDS.  */\n               if (TREE_CODE (t) == STATIC_ASSERT)\n-\t\ttsubst_expr (t, args, tf_warning_or_error, NULL_TREE,\n-\t\t\t     /*integral_constant_expression_p=*/true);\n+\t\ttsubst_expr (t, args, tf_warning_or_error, NULL_TREE);\n \t      else if (TREE_CODE (t) != CONST_DECL)\n \t\t{\n \t\t  tree r;\n@@ -12421,8 +12413,7 @@ tsubst_template_arg (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     {\n       if (!(complain & tf_warning))\n \t++c_inhibit_evaluation_warnings;\n-      r = tsubst_expr (t, args, complain, in_decl,\n-\t\t       /*integral_constant_expression_p=*/true);\n+      r = tsubst_expr (t, args, complain, in_decl);\n       if (!(complain & tf_warning))\n \t--c_inhibit_evaluation_warnings;\n     }\n@@ -12686,8 +12677,7 @@ gen_elem_of_pack_expansion_instantiation (tree pattern,\n   else if (pattern == error_mark_node)\n     t = error_mark_node;\n   else if (!TYPE_P (pattern))\n-    t = tsubst_expr (pattern, args, complain, in_decl,\n-\t\t     /*integral_constant_expression_p=*/false);\n+    t = tsubst_expr (pattern, args, complain, in_decl);\n   else\n     {\n       t = tsubst (pattern, args, complain, in_decl);\n@@ -12781,7 +12771,7 @@ tsubst_fold_expr_pack (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n static inline tree\n tsubst_fold_expr_init (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n {\n-  return tsubst_expr (FOLD_EXPR_INIT (t), args, complain, in_decl, false);\n+  return tsubst_expr (FOLD_EXPR_INIT (t), args, complain, in_decl);\n }\n \n /* Expand a PACK of arguments into a grouped as left fold.\n@@ -13150,12 +13140,12 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n \t  if (BASES_DIRECT (parm_pack))\n \t    return calculate_direct_bases (tsubst_expr (BASES_TYPE (parm_pack),\n \t\t\t\t\t\t\targs, complain,\n-\t\t\t\t\t\t\tin_decl, false),\n+\t\t\t\t\t\t\tin_decl),\n \t\t\t\t\t   complain);\n \t  else\n \t    return calculate_bases (tsubst_expr (BASES_TYPE (parm_pack),\n-\t\t\t\t\t\t args, complain, in_decl,\n-\t\t\t\t\t\t false), complain);\n+\t\t\t\t\t\t args, complain, in_decl),\n+\t\t\t\t    complain);\n \t}\n       else if (builtin_pack_call_p (parm_pack))\n \t{\n@@ -13329,8 +13319,7 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n \t pattern and return a PACK_EXPANSION_*. The caller will need to\n \t deal with that.  */\n       if (TREE_CODE (t) == EXPR_PACK_EXPANSION)\n-\tresult = tsubst_expr (pattern, args, complain, in_decl,\n-\t\t\t /*integral_constant_expression_p=*/false);\n+\tresult = tsubst_expr (pattern, args, complain, in_decl);\n       else\n \tresult = tsubst (pattern, args, complain, in_decl);\n       result = make_pack_expansion (result, complain);\n@@ -13904,9 +13893,7 @@ tsubst_default_argument (tree fn, int parmnum, tree type, tree arg,\n      the body of function so as to avoid collecting live data on the\n      stack.  */\n   ++function_depth;\n-  arg = tsubst_expr (arg, DECL_TI_ARGS (fn),\n-\t\t     complain, NULL_TREE,\n-\t\t     /*integral_constant_expression_p=*/false);\n+  arg = tsubst_expr (arg, DECL_TI_ARGS (fn), complain, NULL_TREE);\n   --function_depth;\n \n   finish_lambda_scope ();\n@@ -14211,8 +14198,7 @@ tsubst_function_decl (tree t, tree args, tsubst_flags_t complain,\n   if (DECL_HAS_DEPENDENT_EXPLICIT_SPEC_P (t))\n     {\n       tree spec = lookup_explicit_specifier (t);\n-      spec = tsubst_copy_and_build (spec, args, complain, in_decl,\n-\t\t\t\t    /*i_c_e_p=*/true);\n+      spec = tsubst_copy_and_build (spec, args, complain, in_decl);\n       spec = build_explicit_specifier (spec, complain);\n       if (spec == error_mark_node)\n \treturn error_mark_node;\n@@ -14824,8 +14810,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t\t number of bits.  */\n \t      DECL_BIT_FIELD_REPRESENTATIVE (r)\n \t\t= tsubst_expr (DECL_BIT_FIELD_REPRESENTATIVE (t), args,\n-\t\t\t       complain, in_decl,\n-\t\t\t       /*integral_constant_expression_p=*/true);\n+\t\t\t       complain, in_decl);\n \t    if (DECL_INITIAL (t))\n \t      {\n \t\t/* Set up DECL_TEMPLATE_INFO so that we can get at the\n@@ -15077,8 +15062,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t\tbool nop = (TREE_CODE (ve) == NOP_EXPR);\n \t\tif (nop)\n \t\t  ve = TREE_OPERAND (ve, 0);\n-\t\tve = tsubst_expr (ve, args, complain, in_decl,\n-\t\t\t\t  /*constant_expression_p=*/false);\n+\t\tve = tsubst_expr (ve, args, complain, in_decl);\n \t\tif (REFERENCE_REF_P (ve))\n \t\t  {\n \t\t    gcc_assert (TYPE_REF_P (type));\n@@ -15276,8 +15260,7 @@ tsubst_arg_types (tree arg_types,\n   if (lambda_fn_in_template_p (in_decl)\n       || (in_decl && TREE_CODE (in_decl) == FUNCTION_DECL\n \t  && DECL_LOCAL_DECL_P (in_decl)))\n-    default_arg = tsubst_copy_and_build (default_arg, args, complain, in_decl,\n-\t\t\t\t\t false/*constexpr*/);\n+    default_arg = tsubst_copy_and_build (default_arg, args, complain, in_decl);\n \n   tree remaining_arg_types = tsubst_arg_types (TREE_CHAIN (arg_types),\n \t\t\t\t\t       args, end, complain, in_decl);\n@@ -15458,9 +15441,7 @@ tsubst_exception_specification (tree fntype,\n \t\t\t\t\t   args);\n \t      expr = DEFERRED_NOEXCEPT_PATTERN (expr);\n \t    }\n-\t  new_specs = tsubst_copy_and_build\n-\t    (expr, args, complain, in_decl,\n-\t     /*integral_constant_expression_p=*/true);\n+\t  new_specs = tsubst_copy_and_build (expr, args, complain, in_decl);\n \t}\n       new_specs = build_noexcept_spec (new_specs, complain);\n       /* We've instantiated a template before a noexcept-specifier\n@@ -15767,8 +15748,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       {\n \ttree max, omax = TREE_OPERAND (TYPE_MAX_VALUE (t), 0);\n \n-\tmax = tsubst_expr (omax, args, complain, in_decl,\n-\t\t\t   /*integral_constant_expression_p=*/false);\n+\tmax = tsubst_expr (omax, args, complain, in_decl);\n \n \t/* Fix up type of the magic NOP_EXPR with TREE_SIDE_EFFECTS if\n \t   needed.  */\n@@ -16361,9 +16341,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t++cp_unevaluated_operand;\n \t++c_inhibit_evaluation_warnings;\n \n-\ttype = tsubst_expr (TYPEOF_TYPE_EXPR (t), args,\n-\t\t\t    complain, in_decl,\n-\t\t\t    /*integral_constant_expression_p=*/false);\n+\ttype = tsubst_expr (TYPEOF_TYPE_EXPR (t), args, complain, in_decl);\n \n \t--cp_unevaluated_operand;\n \t--c_inhibit_evaluation_warnings;\n@@ -16383,8 +16361,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t++c_inhibit_evaluation_warnings;\n \n \ttype = tsubst_copy_and_build (DECLTYPE_TYPE_EXPR (t), args,\n-\t\t\t\t      complain|tf_decltype, in_decl,\n-\t\t\t\t      /*integral_constant_expression*/false);\n+\t\t\t\t      complain|tf_decltype, in_decl);\n \n \t--cp_unevaluated_operand;\n \t--c_inhibit_evaluation_warnings;\n@@ -16843,7 +16820,7 @@ tsubst_init (tree init, tree decl, tree args,\n   if (!init)\n     return NULL_TREE;\n \n-  init = tsubst_expr (init, args, complain, in_decl, false);\n+  init = tsubst_expr (init, args, complain, in_decl);\n \n   tree type = TREE_TYPE (decl);\n \n@@ -17680,9 +17657,7 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       return t;\n \n     case CO_AWAIT_EXPR:\n-      return tsubst_expr (t, args, complain, in_decl,\n-\t\t\t  /*integral_constant_expression_p=*/false);\n-      break;\n+      return tsubst_expr (t, args, complain, in_decl);\n \n     default:\n       /* We shouldn't get here, but keep going if !flag_checking.  */\n@@ -17722,14 +17697,11 @@ tsubst_omp_clause_decl (tree decl, tree args, tsubst_flags_t complain,\n \t      DECL_CONTEXT (TREE_VEC_ELT (*tp, 0)) = current_function_decl;\n \t      pushdecl (TREE_VEC_ELT (*tp, 0));\n \t      TREE_VEC_ELT (*tp, 1)\n-\t\t= tsubst_expr (TREE_VEC_ELT (it, 1), args, complain, in_decl,\n-\t\t\t       /*integral_constant_expression_p=*/false);\n+\t\t= tsubst_expr (TREE_VEC_ELT (it, 1), args, complain, in_decl);\n \t      TREE_VEC_ELT (*tp, 2)\n-\t\t= tsubst_expr (TREE_VEC_ELT (it, 2), args, complain, in_decl,\n-\t\t\t       /*integral_constant_expression_p=*/false);\n+\t\t= tsubst_expr (TREE_VEC_ELT (it, 2), args, complain, in_decl);\n \t      TREE_VEC_ELT (*tp, 3)\n-\t\t= tsubst_expr (TREE_VEC_ELT (it, 3), args, complain, in_decl,\n-\t\t\t       /*integral_constant_expression_p=*/false);\n+\t\t= tsubst_expr (TREE_VEC_ELT (it, 3), args, complain, in_decl);\n \t      TREE_CHAIN (*tp) = NULL_TREE;\n \t      tp = &TREE_CHAIN (*tp);\n \t    }\n@@ -17751,10 +17723,8 @@ tsubst_omp_clause_decl (tree decl, tree args, tsubst_flags_t complain,\n   if (TREE_CODE (decl) == TREE_LIST)\n     {\n       tree low_bound\n-\t= tsubst_expr (TREE_PURPOSE (decl), args, complain, in_decl,\n-\t\t       /*integral_constant_expression_p=*/false);\n-      tree length = tsubst_expr (TREE_VALUE (decl), args, complain, in_decl,\n-\t\t\t\t /*integral_constant_expression_p=*/false);\n+\t= tsubst_expr (TREE_PURPOSE (decl), args, complain, in_decl);\n+      tree length = tsubst_expr (TREE_VALUE (decl), args, complain, in_decl);\n       tree chain = tsubst_omp_clause_decl (TREE_CHAIN (decl), args, complain,\n \t\t\t\t\t   in_decl, NULL);\n       if (TREE_PURPOSE (decl) == low_bound\n@@ -17766,8 +17736,7 @@ tsubst_omp_clause_decl (tree decl, tree args, tsubst_flags_t complain,\n \t= OMP_CLAUSE_DOACROSS_SINK_NEGATIVE (decl);\n       return ret;\n     }\n-  tree ret = tsubst_expr (decl, args, complain, in_decl,\n-\t\t\t  /*integral_constant_expression_p=*/false);\n+  tree ret = tsubst_expr (decl, args, complain, in_decl);\n   /* Undo convert_from_reference tsubst_expr could have called.  */\n   if (decl\n       && REFERENCE_REF_P (ret)\n@@ -17798,8 +17767,8 @@ tsubst_omp_clauses (tree clauses, enum c_omp_region_type ort,\n \t  if (OMP_CLAUSE_LASTPRIVATE_STMT (oc))\n \t    {\n \t      OMP_CLAUSE_LASTPRIVATE_STMT (nc) = push_stmt_list ();\n-\t      tsubst_expr (OMP_CLAUSE_LASTPRIVATE_STMT (oc), args, complain,\n-\t\t\t   in_decl, /*integral_constant_expression_p=*/false);\n+\t      tsubst_expr (OMP_CLAUSE_LASTPRIVATE_STMT (oc), args,\n+\t\t\t   complain, in_decl);\n \t      OMP_CLAUSE_LASTPRIVATE_STMT (nc)\n \t\t= pop_stmt_list (OMP_CLAUSE_LASTPRIVATE_STMT (nc));\n \t    }\n@@ -17832,8 +17801,7 @@ tsubst_omp_clauses (tree clauses, enum c_omp_region_type ort,\n \t  if (OMP_CLAUSE_NUM_TEAMS_LOWER_EXPR (oc))\n \t    OMP_CLAUSE_NUM_TEAMS_LOWER_EXPR (nc)\n \t      = tsubst_expr (OMP_CLAUSE_NUM_TEAMS_LOWER_EXPR (oc), args,\n-\t\t\t     complain, in_decl,\n-\t\t\t     /*integral_constant_expression_p=*/false);\n+\t\t\t     complain, in_decl);\n \t  /* FALLTHRU */\n \tcase OMP_CLAUSE_TILE:\n \tcase OMP_CLAUSE_IF:\n@@ -17861,8 +17829,7 @@ tsubst_omp_clauses (tree clauses, enum c_omp_region_type ort,\n \tcase OMP_CLAUSE_WAIT:\n \tcase OMP_CLAUSE_DETACH:\n \t  OMP_CLAUSE_OPERAND (nc, 0)\n-\t    = tsubst_expr (OMP_CLAUSE_OPERAND (oc, 0), args, complain,\n-\t\t\t   in_decl, /*integral_constant_expression_p=*/false);\n+\t    = tsubst_expr (OMP_CLAUSE_OPERAND (oc, 0), args, complain, in_decl);\n \t  break;\n \tcase OMP_CLAUSE_REDUCTION:\n \tcase OMP_CLAUSE_IN_REDUCTION:\n@@ -17892,19 +17859,16 @@ tsubst_omp_clauses (tree clauses, enum c_omp_region_type ort,\n \t    = tsubst_omp_clause_decl (OMP_CLAUSE_DECL (oc), args, complain,\n \t\t\t\t      in_decl, NULL);\n \t  OMP_CLAUSE_OPERAND (nc, 1)\n-\t    = tsubst_expr (OMP_CLAUSE_OPERAND (oc, 1), args, complain,\n-\t\t\t   in_decl, /*integral_constant_expression_p=*/false);\n+\t    = tsubst_expr (OMP_CLAUSE_OPERAND (oc, 1), args, complain, in_decl);\n \t  break;\n \tcase OMP_CLAUSE_ALLOCATE:\n \t  OMP_CLAUSE_DECL (nc)\n \t    = tsubst_omp_clause_decl (OMP_CLAUSE_DECL (oc), args, complain,\n \t\t\t\t      in_decl, NULL);\n \t  OMP_CLAUSE_OPERAND (nc, 1)\n-\t    = tsubst_expr (OMP_CLAUSE_OPERAND (oc, 1), args, complain,\n-\t\t\t   in_decl, /*integral_constant_expression_p=*/false);\n+\t    = tsubst_expr (OMP_CLAUSE_OPERAND (oc, 1), args, complain, in_decl);\n \t  OMP_CLAUSE_OPERAND (nc, 2)\n-\t    = tsubst_expr (OMP_CLAUSE_OPERAND (oc, 2), args, complain,\n-\t\t\t   in_decl, /*integral_constant_expression_p=*/false);\n+\t    = tsubst_expr (OMP_CLAUSE_OPERAND (oc, 2), args, complain, in_decl);\n \t  break;\n \tcase OMP_CLAUSE_LINEAR:\n \t  OMP_CLAUSE_DECL (nc)\n@@ -17921,9 +17885,8 @@ tsubst_omp_clauses (tree clauses, enum c_omp_region_type ort,\n \t\t\t\t\tcomplain, in_decl, NULL);\n \t  else\n \t    OMP_CLAUSE_LINEAR_STEP (nc)\n-\t      = tsubst_expr (OMP_CLAUSE_LINEAR_STEP (oc), args, complain,\n-\t\t\t     in_decl,\n-\t\t\t     /*integral_constant_expression_p=*/false);\n+\t      = tsubst_expr (OMP_CLAUSE_LINEAR_STEP (oc), args,\n+\t\t\t     complain, in_decl);\n \t  break;\n \tcase OMP_CLAUSE_NOWAIT:\n \tcase OMP_CLAUSE_DEFAULT:\n@@ -18048,8 +18011,7 @@ tsubst_copy_asm_operands (tree t, tree args, tsubst_flags_t complain,\n     return t;\n \n   if (TREE_CODE (t) != TREE_LIST)\n-    return tsubst_copy_and_build (t, args, complain, in_decl,\n-\t\t\t\t  /*integral_constant_expression_p=*/false);\n+    return tsubst_copy_and_build (t, args, complain, in_decl);\n \n   if (t == void_list_node)\n     return t;\n@@ -18090,12 +18052,10 @@ static tree tsubst_decomp_names (tree, tree, tree, tsubst_flags_t, tree,\n static bool\n tsubst_omp_for_iterator (tree t, int i, tree declv, tree &orig_declv,\n \t\t\t tree initv, tree condv, tree incrv, tree *clauses,\n-\t\t\t tree args, tsubst_flags_t complain, tree in_decl,\n-\t\t\t bool integral_constant_expression_p)\n+\t\t\t tree args, tsubst_flags_t complain, tree in_decl)\n {\n #define RECUR(NODE)\t\t\t\t\\\n-  tsubst_expr ((NODE), args, complain, in_decl,\t\\\n-\t       integral_constant_expression_p)\n+  tsubst_expr ((NODE), args, complain, in_decl)\n   tree decl, init, cond = NULL_TREE, incr = NULL_TREE;\n   bool ret = false;\n \n@@ -18583,13 +18543,11 @@ dependent_operand_p (tree t)\n    processing.  */\n \n tree\n-tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n-\t     bool integral_constant_expression_p)\n+tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n {\n #define RETURN(EXP) do { r = (EXP); goto out; } while(0)\n #define RECUR(NODE)\t\t\t\t\\\n-  tsubst_expr ((NODE), args, complain, in_decl,\t\\\n-\t       integral_constant_expression_p)\n+  tsubst_expr ((NODE), args, complain, in_decl)\n \n   tree stmt, tmp;\n   tree r;\n@@ -19135,11 +19093,8 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \ttree condition;\n \n \t++c_inhibit_evaluation_warnings;\n-\tcondition =\n-\t  tsubst_expr (STATIC_ASSERT_CONDITION (t),\n-                       args,\n-                       complain, in_decl,\n-                       /*integral_constant_expression_p=*/true);\n+\tcondition = tsubst_expr (STATIC_ASSERT_CONDITION (t), args,\n+\t\t\t\t complain, in_decl);\n \t--c_inhibit_evaluation_warnings;\n \n         finish_static_assert (condition,\n@@ -19235,8 +19190,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t    any_range_for\n \t      |= tsubst_omp_for_iterator (t, i, declv, orig_declv, initv,\n \t\t\t\t\t  condv, incrv, &clauses, args,\n-\t\t\t\t\t  complain, in_decl,\n-\t\t\t\t\t  integral_constant_expression_p);\n+\t\t\t\t\t  complain, in_decl);\n \tomp_parallel_combined_clauses = NULL;\n \n \tif (any_range_for)\n@@ -19634,8 +19588,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n     default:\n       gcc_assert (!STATEMENT_CODE_P (TREE_CODE (t)));\n \n-      RETURN (tsubst_copy_and_build (t, args, complain, in_decl,\n-\t\t\t\t    integral_constant_expression_p));\n+      RETURN (tsubst_copy_and_build (t, args, complain, in_decl));\n     }\n \n   RETURN (NULL_TREE);\n@@ -19682,7 +19635,7 @@ tsubst_omp_udr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       DECL_CONTEXT (omp_in) = current_function_decl;\n       keep_next_level (true);\n       tree block = begin_omp_structured_block ();\n-      tsubst_expr (stmts[2], args, complain, in_decl, false);\n+      tsubst_expr (stmts[2], args, complain, in_decl);\n       block = finish_omp_structured_block (block);\n       block = maybe_cleanup_point_expr_void (block);\n       add_decl_expr (omp_out);\n@@ -19702,7 +19655,7 @@ tsubst_omp_udr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       DECL_CONTEXT (omp_orig) = current_function_decl;\n       keep_next_level (true);\n       tree block = begin_omp_structured_block ();\n-      tsubst_expr (stmts[5], args, complain, in_decl, false);\n+      tsubst_expr (stmts[5], args, complain, in_decl);\n       block = finish_omp_structured_block (block);\n       block = maybe_cleanup_point_expr_void (block);\n       cp_walk_tree (&block, cp_remove_omp_priv_cleanup_stmt, omp_priv, NULL);\n@@ -19726,8 +19679,7 @@ tsubst_non_call_postfix_expression (tree t, tree args,\n     t = tsubst_qualified_id (t, args, complain, in_decl,\n \t\t\t     /*done=*/false, /*address_p=*/false);\n   else\n-    t = tsubst_copy_and_build (t, args, complain, in_decl,\n-\t\t\t       /*integral_constant_expression_p=*/false);\n+    t = tsubst_copy_and_build (t, args, complain, in_decl);\n \n   return t;\n }\n@@ -19798,8 +19750,7 @@ tsubst_lambda_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       if (PACK_EXPANSION_P (init))\n \tinit = tsubst_pack_expansion (init, args, complain, in_decl);\n       else\n-\tinit = tsubst_copy_and_build (init, args, complain, in_decl,\n-\t\t\t\t      /*constexpr*/false);\n+\tinit = tsubst_copy_and_build (init, args, complain, in_decl);\n \n       if (init == error_mark_node)\n \treturn error_mark_node;\n@@ -19965,7 +19916,7 @@ tsubst_lambda_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t   need another to confuse NRV (91217).  */\n \tsaved = BIND_EXPR_BODY (saved);\n \n-      tsubst_expr (saved, args, complain, r, /*constexpr*/false);\n+      tsubst_expr (saved, args, complain, r);\n \n       finish_lambda_function (body);\n \n@@ -20055,9 +20006,7 @@ maybe_fold_fn_template_args (tree fn, tsubst_flags_t complain)\n \n static void\n tsubst_copy_and_build_call_args (tree t, tree args, tsubst_flags_t complain,\n-\t\t\t\t tree in_decl,\n-\t\t\t\t bool integral_constant_expression_p,\n-\t\t\t\t releasing_vec &call_args)\n+\t\t\t\t tree in_decl, releasing_vec &call_args)\n {\n   unsigned int nargs = call_expr_nargs (t);\n   for (unsigned int i = 0; i < nargs; ++i)\n@@ -20066,8 +20015,7 @@ tsubst_copy_and_build_call_args (tree t, tree args, tsubst_flags_t complain,\n \n       if (!PACK_EXPANSION_P (arg))\n \tvec_safe_push (call_args,\n-\t\t       tsubst_copy_and_build (arg, args, complain, in_decl,\n-\t\t\t\t\t      integral_constant_expression_p));\n+\t\t       tsubst_copy_and_build (arg, args, complain, in_decl));\n       else\n \t{\n \t  /* Expand the pack expansion and push each entry onto CALL_ARGS.  */\n@@ -20099,13 +20047,11 @@ tree\n tsubst_copy_and_build (tree t,\n \t\t       tree args,\n \t\t       tsubst_flags_t complain,\n-\t\t       tree in_decl,\n-\t\t       bool integral_constant_expression_p)\n+\t\t       tree in_decl)\n {\n #define RETURN(EXP) do { retval = (EXP); goto out; } while(0)\n #define RECUR(NODE)\t\t\t\t\t\t\\\n-  tsubst_copy_and_build (NODE, args, complain, in_decl, \t\\\n-\t\t\t integral_constant_expression_p)\n+  tsubst_copy_and_build (NODE, args, complain, in_decl)\n \n   tree retval, op1;\n   location_t save_loc;\n@@ -20131,7 +20077,6 @@ tsubst_copy_and_build (tree t,\n       {\n \ttree decl;\n \tcp_id_kind idk;\n-\tbool non_integral_constant_expression_p;\n \tconst char *error_msg;\n \n \tif (IDENTIFIER_CONV_OP_P (t))\n@@ -20150,9 +20095,9 @@ tsubst_copy_and_build (tree t,\n \n \tdecl = finish_id_expression (t, decl, NULL_TREE,\n \t\t\t\t     &idk,\n-\t\t\t\t     integral_constant_expression_p,\n-          /*allow_non_integral_constant_expression_p=*/(cxx_dialect >= cxx11),\n-\t\t\t\t     &non_integral_constant_expression_p,\n+\t\t\t\t     /*i_c_e_p=*/false,\n+\t\t\t\t     /*allow_i_c_e_p=*/true,\n+\t\t\t\t     /*non_i_c_e_p=*/nullptr,\n \t\t\t\t     /*template_p=*/false,\n \t\t\t\t     /*done=*/true,\n \t\t\t\t     /*address_p=*/false,\n@@ -20174,8 +20119,7 @@ tsubst_copy_and_build (tree t,\n       {\n \ttree object;\n \ttree templ = tsubst_copy_and_build (TREE_OPERAND (t, 0), args,\n-\t\t\t\t\t    complain, in_decl,\n-\t\t\t\t\t    integral_constant_expression_p);\n+\t\t\t\t\t    complain, in_decl);\n \ttree targs = TREE_OPERAND (t, 1);\n \n \tif (targs)\n@@ -20315,14 +20259,6 @@ tsubst_copy_and_build (tree t,\n \tif (TREE_CODE (t) == CAST_EXPR)\n \t  tcomplain |= tf_tst_ok;\n \ttype = tsubst (TREE_TYPE (t), args, tcomplain, in_decl);\n-\tif (integral_constant_expression_p\n-\t    && !cast_valid_in_integral_constant_expression_p (type))\n-\t  {\n-            if (complain & tf_error)\n-              error (\"a cast to a type other than an integral or \"\n-                     \"enumeration type cannot appear in a constant-expression\");\n-\t    RETURN (error_mark_node);\n-\t  }\n \n \top = RECUR (TREE_OPERAND (t, 0));\n \n@@ -20507,7 +20443,6 @@ tsubst_copy_and_build (tree t,\n \t  tree c = TREE_OPERAND (t, 1);\n \t  releasing_vec index_exp_list;\n \t  tsubst_copy_and_build_call_args (c, args, complain, in_decl,\n-\t\t\t\t\t   integral_constant_expression_p,\n \t\t\t\t\t   index_exp_list);\n \n \t  tree r;\n@@ -20556,9 +20491,7 @@ tsubst_copy_and_build (tree t,\n \t    if (TYPE_P (op1))\n \t      op1 = tsubst (op1, args, complain, in_decl);\n \t    else\n-\t      op1 = tsubst_copy_and_build (op1, args, complain, in_decl,\n-\t\t\t\t\t   /*integral_constant_expression_p=*/\n-\t\t\t\t\t   false);\n+\t      op1 = tsubst_copy_and_build (op1, args, complain, in_decl);\n \t    --cp_unevaluated_operand;\n \t    --c_inhibit_evaluation_warnings;\n \t  }\n@@ -20595,8 +20528,7 @@ tsubst_copy_and_build (tree t,\n \top1 = TREE_OPERAND (t, 0);\n \t++cp_unevaluated_operand;\n \t++c_inhibit_evaluation_warnings;\n-\top1 = tsubst_copy_and_build (op1, args, complain, in_decl,\n-\t\t\t\t     /*integral_constant_expression_p=*/false);\n+\top1 = tsubst_copy_and_build (op1, args, complain, in_decl);\n \t--cp_unevaluated_operand;\n \t--c_inhibit_evaluation_warnings;\n \tRETURN (objc_build_encode_expr (op1));\n@@ -20607,8 +20539,7 @@ tsubst_copy_and_build (tree t,\n       ++cp_unevaluated_operand;\n       ++c_inhibit_evaluation_warnings;\n       ++cp_noexcept_operand;\n-      op1 = tsubst_copy_and_build (op1, args, complain, in_decl,\n-\t\t\t\t   /*integral_constant_expression_p=*/false);\n+      op1 = tsubst_copy_and_build (op1, args, complain, in_decl);\n       --cp_unevaluated_operand;\n       --c_inhibit_evaluation_warnings;\n       --cp_noexcept_operand;\n@@ -20717,8 +20648,7 @@ tsubst_copy_and_build (tree t,\n     case COMPOUND_EXPR:\n       {\n \ttree op0 = tsubst_copy_and_build (TREE_OPERAND (t, 0), args,\n-\t\t\t\t\t  complain & ~tf_decltype, in_decl,\n-\t\t\t\t\t  integral_constant_expression_p);\n+\t\t\t\t\t  complain & ~tf_decltype, in_decl);\n \tRETURN (build_x_compound_expr (EXPR_LOCATION (t),\n \t\t\t\t       op0,\n \t\t\t\t       RECUR (TREE_OPERAND (t, 1)),\n@@ -20799,9 +20729,7 @@ tsubst_copy_and_build (tree t,\n \t\t augmenting the overload set via ADL, so during this initial\n \t\t substitution we disable mark_used by setting tf_conv (68942).  */\n \t      subcomplain |= tf_conv;\n-\t    function = tsubst_copy_and_build (function, args, subcomplain,\n-\t\t\t\t\t      in_decl,\n-\t\t\t\t\t      integral_constant_expression_p);\n+\t    function = tsubst_copy_and_build (function, args, subcomplain, in_decl);\n \n \t    if (BASELINK_P (function))\n \t      qualified_p = true;\n@@ -20810,7 +20738,6 @@ tsubst_copy_and_build (tree t,\n \tnargs = call_expr_nargs (t);\n \treleasing_vec call_args;\n \ttsubst_copy_and_build_call_args (t, args, complain, in_decl,\n-\t\t\t\t\t integral_constant_expression_p,\n \t\t\t\t\t call_args);\n \n \t/* Stripped-down processing for a call in a thunk.  Specifically, in\n@@ -20903,9 +20830,8 @@ tsubst_copy_and_build (tree t,\n \t\t/* For backwards compatibility and good diagnostics, try\n \t\t   the unqualified lookup again if we aren't in SFINAE\n \t\t   context.  */\n-\t\ttree unq = (tsubst_copy_and_build\n-\t\t\t    (function, args, complain, in_decl,\n-\t\t\t     integral_constant_expression_p));\n+\t\ttree unq = tsubst_copy_and_build (function, args,\n+\t\t\t\t\t\t  complain, in_decl);\n \t\tif (unq == error_mark_node)\n \t\t  RETURN (error_mark_node);\n \n@@ -21454,9 +21380,8 @@ tsubst_copy_and_build (tree t,\n     case OFFSETOF_EXPR:\n       {\n \ttree object_ptr\n-\t  = tsubst_copy_and_build (TREE_OPERAND (t, 1), args, complain,\n-\t\t\t\t   in_decl,\n-\t\t\t\t   /*integral_constant_expression_p=*/false);\n+\t  = tsubst_copy_and_build (TREE_OPERAND (t, 1), args,\n+\t\t\t\t   complain, in_decl);\n \tRETURN (finish_offsetof (object_ptr,\n \t\t\t\t RECUR (TREE_OPERAND (t, 0)),\n \t\t\t\t EXPR_LOCATION (t)));\n@@ -21482,8 +21407,7 @@ tsubst_copy_and_build (tree t,\n \ttree stmt_expr = begin_stmt_expr ();\n \n \tcur_stmt_expr = stmt_expr;\n-\ttsubst_expr (STMT_EXPR_STMT (t), args, complain, in_decl,\n-\t\t     integral_constant_expression_p);\n+\ttsubst_expr (STMT_EXPR_STMT (t), args, complain, in_decl);\n \tstmt_expr = finish_stmt_expr (stmt_expr, false);\n \tcur_stmt_expr = old_stmt_expr;\n \n@@ -21510,8 +21434,7 @@ tsubst_copy_and_build (tree t,\n       }\n \n     case TRANSACTION_EXPR:\n-      RETURN (tsubst_expr(t, args, complain, in_decl,\n-\t     integral_constant_expression_p));\n+      RETURN (tsubst_expr (t, args, complain, in_decl));\n \n     case PAREN_EXPR:\n       if (REF_PARENTHESIZED_P (t))\n@@ -26373,8 +26296,7 @@ maybe_instantiate_noexcept (tree fn, tsubst_flags_t complain)\n \t  /* Do deferred instantiation of the noexcept-specifier.  */\n \t  noex = tsubst_copy_and_build (DEFERRED_NOEXCEPT_PATTERN (noex),\n \t\t\t\t\tDEFERRED_NOEXCEPT_ARGS (noex),\n-\t\t\t\t\ttf_warning_or_error, fn,\n-\t\t\t\t\t/*i_c_e_p=*/true);\n+\t\t\t\t\ttf_warning_or_error, fn);\n \n \t  /* Build up the noexcept-specification.  */\n \t  spec = build_noexcept_spec (noex, tf_warning_or_error);\n@@ -26560,8 +26482,7 @@ instantiate_body (tree pattern, tree args, tree d, bool nested_p)\n       else\n \t{\n \t  tsubst_expr (DECL_SAVED_TREE (code_pattern), args,\n-\t\t       tf_warning_or_error, DECL_TI_TEMPLATE (d),\n-\t\t       /*integral_constant_expression_p=*/false);\n+\t\t       tf_warning_or_error, DECL_TI_TEMPLATE (d));\n \n \t  /* Set the current input_location to the end of the function\n \t     so that finish_function knows where we are.  */\n@@ -26802,8 +26723,7 @@ instantiate_decl (tree d, bool defer_ok, bool expl_inst_class_mem_p)\n \t    push_nested_class (DECL_CONTEXT (d));\n \t  init = tsubst_expr (DECL_INITIAL (code_pattern),\n \t\t\t      args,\n-\t\t\t      tf_warning_or_error, NULL_TREE,\n-\t\t\t      /*integral_constant_expression_p=*/false);\n+\t\t\t      tf_warning_or_error, NULL_TREE);\n \t  /* If instantiating the initializer involved instantiating this\n \t     again, don't call cp_finish_decl twice.  */\n \t  if (!DECL_INITIAL (d))\n@@ -27091,8 +27011,7 @@ tsubst_initializer_list (tree t, tree argvec)\n \t      tmp = init;\n \t      if (init != void_type_node)\n \t\tinit = tsubst_expr (init, argvec,\n-\t\t\t\t    tf_warning_or_error, NULL_TREE,\n-\t\t\t\t    /*integral_constant_expression_p=*/false);\n+\t\t\t\t    tf_warning_or_error, NULL_TREE);\n \t      if (init == NULL_TREE && tmp != NULL_TREE)\n \t\t/* If we had an initializer but it instantiated to nothing,\n \t\t   value-initialize the object.  This will only occur when\n@@ -27158,8 +27077,7 @@ tsubst_enum (tree tag, tree newtag, tree args)\n       /* Note that in a template enum, the TREE_VALUE is the\n \t CONST_DECL, not the corresponding INTEGER_CST.  */\n       value = tsubst_expr (DECL_INITIAL (decl),\n-\t\t\t   args, tf_warning_or_error, NULL_TREE,\n-\t\t\t   /*integral_constant_expression_p=*/true);\n+\t\t\t   args, tf_warning_or_error, NULL_TREE);\n \n       /* Give this enumeration constant the correct access.  */\n       set_current_access_from_decl (decl);"}, {"sha": "fa754028773ff64fd7c2955254918e7a9f2c6cf9", "filename": "gcc/objcp/objcp-lang.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5925f0ec54ab5ed773935eec09a602f58fa0ca2c/gcc%2Fobjcp%2Fobjcp-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5925f0ec54ab5ed773935eec09a602f58fa0ca2c/gcc%2Fobjcp%2Fobjcp-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2Fobjcp-lang.cc?ref=5925f0ec54ab5ed773935eec09a602f58fa0ca2c", "patch": "@@ -54,8 +54,7 @@ objcp_tsubst_copy_and_build (tree t, tree args, tsubst_flags_t complain,\n \t\t\t     tree in_decl)\n {\n #define RECURSE(NODE)\t\t\t\t\t\t\t\\\n-  tsubst_copy_and_build (NODE, args, complain, in_decl, \t\t\\\n-\t\t\t /*integral_constant_expression_p=*/false)\n+  tsubst_copy_and_build (NODE, args, complain, in_decl)\n \n   /* The following two can only occur in Objective-C++.  */\n "}, {"sha": "8a7fc112c1994ecf2a99572ca53c7c0c95056614", "filename": "gcc/testsuite/g++.dg/template/crash55.C", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5925f0ec54ab5ed773935eec09a602f58fa0ca2c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash55.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5925f0ec54ab5ed773935eec09a602f58fa0ca2c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash55.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash55.C?ref=5925f0ec54ab5ed773935eec09a602f58fa0ca2c", "patch": "@@ -1,7 +1,6 @@\n //PR c++/27668\n \n template<typename class T, T = T()> // { dg-error \"nested-name-specifier|two or more|class type|incomplete\" }\n-// { dg-error \"cast\" \"\" { target c++98_only } .-1 }\n struct A {};\n \n-template<int> void foo(A<int>);\t// { dg-error \"template argument 2\" \"\" { target c++98_only } }\n+template<int> void foo(A<int>);"}, {"sha": "976c093a15b7244540da35cf6847b2a716525cca", "filename": "gcc/testsuite/g++.dg/template/ref3.C", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5925f0ec54ab5ed773935eec09a602f58fa0ca2c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fref3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5925f0ec54ab5ed773935eec09a602f58fa0ca2c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fref3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fref3.C?ref=5925f0ec54ab5ed773935eec09a602f58fa0ca2c", "patch": "@@ -5,8 +5,7 @@ template<const int&> struct A {};\n template<typename T> struct B\n {\n   A<(T)0> b; // { dg-error \"constant|not a valid\" }\n-  A<T(0)> a; // { dg-error \"constant|not a valid\" \"\" { xfail c++98_only } }\n-                                                       // PR c++/68699\n+  A<T(0)> a; // { dg-error \"constant|not a valid\" }\n };\n \n B<const int&> b;"}]}