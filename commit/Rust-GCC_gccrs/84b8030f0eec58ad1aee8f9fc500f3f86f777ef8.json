{"sha": "84b8030f0eec58ad1aee8f9fc500f3f86f777ef8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRiODAzMGYwZWVjNThhZDFhZWU4ZjlmYzUwMGYzZjg2Zjc3N2VmOA==", "commit": {"author": {"name": "Kenneth Zadeck", "email": "zadeck@naturalbridge.com", "date": "2008-05-14T17:05:13Z"}, "committer": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2008-05-14T17:05:13Z"}, "message": "optabs.c (prepare_cmp_insn): Changed LCT_PURE_MAKE_BLOCK to LCT_PURE and LCT_CONST_MAKE_BLOCK to LCT_CONST...\n\n2008-05-14  Kenneth Zadeck <zadeck@naturalbridge.com>\n\n\t* optabs.c (prepare_cmp_insn): Changed LCT_PURE_MAKE_BLOCK to\n\tLCT_PURE and LCT_CONST_MAKE_BLOCK to LCT_CONST in calls to\n\temit_library_call_value. \n\t* builtins.c (expand_builtin_powi, expand_builtin_memcmp): Ditto.\n\t* tree.h (ECF_LIBCALL_BLOCK): Removed.\n\t* calls.c (initialize_argument_information, precompute_arguments, \n\texpand_call, emit_library_call_value_1): Remove ECF_LIBCALL_BLOCK.\n\t(precompute_arguments): Removed flags parameter.\n\t* rtl.h (LCT_CONST_MAKE_BLOCK, LCT_PURE_MAKE_BLOCK): Removed.\n\nFrom-SVN: r135299", "tree": {"sha": "81f15ffce6244463dae4466631dbaf409875916c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81f15ffce6244463dae4466631dbaf409875916c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84b8030f0eec58ad1aee8f9fc500f3f86f777ef8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84b8030f0eec58ad1aee8f9fc500f3f86f777ef8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84b8030f0eec58ad1aee8f9fc500f3f86f777ef8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84b8030f0eec58ad1aee8f9fc500f3f86f777ef8/comments", "author": {"login": "zadeck", "id": 42682403, "node_id": "MDQ6VXNlcjQyNjgyNDAz", "avatar_url": "https://avatars.githubusercontent.com/u/42682403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zadeck", "html_url": "https://github.com/zadeck", "followers_url": "https://api.github.com/users/zadeck/followers", "following_url": "https://api.github.com/users/zadeck/following{/other_user}", "gists_url": "https://api.github.com/users/zadeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/zadeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zadeck/subscriptions", "organizations_url": "https://api.github.com/users/zadeck/orgs", "repos_url": "https://api.github.com/users/zadeck/repos", "events_url": "https://api.github.com/users/zadeck/events{/privacy}", "received_events_url": "https://api.github.com/users/zadeck/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f403a4a270a54f42ce8bddabbce58797adfd5c07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f403a4a270a54f42ce8bddabbce58797adfd5c07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f403a4a270a54f42ce8bddabbce58797adfd5c07"}], "stats": {"total": 208, "additions": 33, "deletions": 175}, "files": [{"sha": "a27f697729c5f1c41fc515e85d7d521fc17781b0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8030f0eec58ad1aee8f9fc500f3f86f777ef8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8030f0eec58ad1aee8f9fc500f3f86f777ef8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=84b8030f0eec58ad1aee8f9fc500f3f86f777ef8", "patch": "@@ -1,3 +1,15 @@\n+2008-05-14  Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\t* optabs.c (prepare_cmp_insn): Changed LCT_PURE_MAKE_BLOCK to\n+\tLCT_PURE and LCT_CONST_MAKE_BLOCK to LCT_CONST in calls to\n+\temit_library_call_value. \n+\t* builtins.c (expand_builtin_powi, expand_builtin_memcmp): Ditto.\n+\t* tree.h (ECF_LIBCALL_BLOCK): Removed.\n+\t* calls.c (initialize_argument_information, precompute_arguments, \n+\texpand_call, emit_library_call_value_1): Remove ECF_LIBCALL_BLOCK.\n+\t(precompute_arguments): Removed flags parameter.\n+\t* rtl.h (LCT_CONST_MAKE_BLOCK, LCT_PURE_MAKE_BLOCK): Removed.\n+\t\n 2008-05-14  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-dse.c (dse_possible_dead_store_p): Remove dead code."}, {"sha": "4211e6247a1abfb229a9d9d9b70a93ef08db2d49", "filename": "gcc/builtins.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8030f0eec58ad1aee8f9fc500f3f86f777ef8/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8030f0eec58ad1aee8f9fc500f3f86f777ef8/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=84b8030f0eec58ad1aee8f9fc500f3f86f777ef8", "patch": "@@ -3082,7 +3082,7 @@ expand_builtin_powi (tree exp, rtx target, rtx subtarget)\n     op1 = convert_to_mode (mode2, op1, 0);\n \n   target = emit_library_call_value (optab_libfunc (powi_optab, mode),\n-\t\t\t\t    target, LCT_CONST_MAKE_BLOCK, mode, 2,\n+\t\t\t\t    target, LCT_CONST, mode, 2,\n \t\t\t\t    op0, mode, op1, mode2);\n \n   return target;\n@@ -4147,7 +4147,7 @@ expand_builtin_memcmp (tree exp, rtx target, enum machine_mode mode)\n     if (insn)\n       emit_insn (insn);\n     else\n-      emit_library_call_value (memcmp_libfunc, result, LCT_PURE_MAKE_BLOCK,\n+      emit_library_call_value (memcmp_libfunc, result, LCT_PURE,\n \t\t\t       TYPE_MODE (integer_type_node), 3,\n \t\t\t       XEXP (arg1_rtx, 0), Pmode,\n \t\t\t       XEXP (arg2_rtx, 0), Pmode,"}, {"sha": "e7799f0e2ad1c25f48406625cd9041d93018aaed", "filename": "gcc/calls.c", "status": "modified", "additions": 13, "deletions": 163, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8030f0eec58ad1aee8f9fc500f3f86f777ef8/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8030f0eec58ad1aee8f9fc500f3f86f777ef8/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=84b8030f0eec58ad1aee8f9fc500f3f86f777ef8", "patch": "@@ -129,7 +129,7 @@ static int store_one_arg (struct arg_data *, rtx, int, int, int);\n static void store_unaligned_arguments_into_pseudos (struct arg_data *, int);\n static int finalize_must_preallocate (int, int, struct arg_data *,\n \t\t\t\t      struct args_size *);\n-static void precompute_arguments (int, int, struct arg_data *);\n+static void precompute_arguments (int, struct arg_data *);\n static int compute_argument_block_size (int, struct args_size *, tree, int);\n static void initialize_argument_information (int, struct arg_data *,\n \t\t\t\t\t     struct args_size *, int,\n@@ -1040,7 +1040,6 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \n \t      if (*ecf_flags & ECF_CONST)\n \t\t*ecf_flags &= ~(ECF_CONST | ECF_LOOPING_CONST_OR_PURE);\n-\t      *ecf_flags &= ~ECF_LIBCALL_BLOCK;\n \t    }\n \t  else\n \t    {\n@@ -1075,8 +1074,6 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \n \t      store_expr (args[i].tree_value, copy, 0, false);\n \n-\t      *ecf_flags &= ~(ECF_LIBCALL_BLOCK);\n-\n \t      /* Just change the const function to pure and then let\n \t\t the next test clear the pure based on\n \t\t callee_copies.  */\n@@ -1140,11 +1137,6 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t  || (args[i].pass_on_stack && args[i].reg != 0))\n \t*must_preallocate = 1;\n \n-      /* If this is an addressable type, we cannot pre-evaluate it.  Thus,\n-\t we cannot consider this function call constant.  */\n-      if (TREE_ADDRESSABLE (type))\n-\t*ecf_flags &= ~ECF_LIBCALL_BLOCK;\n-\n       /* Compute the stack-size of this argument.  */\n       if (args[i].reg == 0 || args[i].partial != 0\n \t  || reg_parm_stack_space > 0\n@@ -1265,7 +1257,7 @@ compute_argument_block_size (int reg_parm_stack_space,\n    precomputed argument.  */\n \n static void\n-precompute_arguments (int flags, int num_actuals, struct arg_data *args)\n+precompute_arguments (int num_actuals, struct arg_data *args)\n {\n   int i;\n \n@@ -1279,15 +1271,14 @@ precompute_arguments (int flags, int num_actuals, struct arg_data *args)\n      which have already been stored into the stack.  (we have code to avoid\n      such case by saving the outgoing stack arguments, but it results in\n      worse code)  */\n-  if ((flags & ECF_LIBCALL_BLOCK) == 0 && !ACCUMULATE_OUTGOING_ARGS)\n+  if (!ACCUMULATE_OUTGOING_ARGS)\n     return;\n \n   for (i = 0; i < num_actuals; i++)\n     {\n       enum machine_mode mode;\n \n-      if ((flags & ECF_LIBCALL_BLOCK) == 0\n-\t  && TREE_CODE (args[i].tree_value) != CALL_EXPR)\n+      if (TREE_CODE (args[i].tree_value) != CALL_EXPR)\n \tcontinue;\n \n       /* If this is an addressable type, we cannot pre-evaluate it.  */\n@@ -2076,8 +2067,7 @@ expand_call (tree exp, rtx target, int ignore)\n   if (aggregate_value_p (exp, fndecl))\n     {\n       /* This call returns a big structure.  */\n-      flags &= ~(ECF_CONST | ECF_PURE | ECF_LOOPING_CONST_OR_PURE \n-\t\t | ECF_LIBCALL_BLOCK);\n+      flags &= ~(ECF_CONST | ECF_PURE | ECF_LOOPING_CONST_OR_PURE);\n \n #ifdef PCC_STATIC_STRUCT_RETURN\n       {\n@@ -2238,15 +2228,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t\t\t\t   &try_tail_call, CALL_FROM_THUNK_P (exp));\n \n   if (args_size.var)\n-    {\n-      /* If this function requires a variable-sized argument list, don't\n-\t try to make a cse'able block for this call.  We may be able to\n-\t do this eventually, but it is too complicated to keep track of\n-\t what insns go in the cse'able block and which don't.  */\n-\n-      flags &= ~ECF_LIBCALL_BLOCK;\n-      must_preallocate = 1;\n-    }\n+    must_preallocate = 1;\n \n   /* Now make final decision about preallocating stack space.  */\n   must_preallocate = finalize_must_preallocate (must_preallocate,\n@@ -2377,18 +2359,13 @@ expand_call (tree exp, rtx target, int ignore)\n \t  || pass == 0)\n \tdo_pending_stack_adjust ();\n \n-      /* When calling a const function, we must pop the stack args right away,\n-\t so that the pop is deleted or moved with the call.  */\n-      if (pass && (flags & ECF_LIBCALL_BLOCK))\n-\tNO_DEFER_POP;\n-\n       /* Precompute any arguments as needed.  */\n       if (pass)\n-\tprecompute_arguments (flags, num_actuals, args);\n+\tprecompute_arguments (num_actuals, args);\n \n       /* Now we are about to start emitting insns that can be deleted\n \t if a libcall is deleted.  */\n-      if (pass && (flags & (ECF_LIBCALL_BLOCK | ECF_MALLOC)))\n+      if (pass && (flags & ECF_MALLOC))\n \tstart_sequence ();\n \n       if (pass == 0 && crtl->stack_protect_guard)\n@@ -2626,7 +2603,6 @@ expand_call (tree exp, rtx target, int ignore)\n \t  /* When the stack adjustment is pending, we get better code\n \t     by combining the adjustments.  */\n \t  if (pending_stack_adjust\n-\t      && ! (flags & ECF_LIBCALL_BLOCK)\n \t      && ! inhibit_defer_pop)\n \t    {\n \t      pending_stack_adjust\n@@ -2826,65 +2802,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t  valreg = gen_rtx_REG (TYPE_MODE (TREE_TYPE (exp)), REGNO (valreg));\n \t}\n \n-      /* If call is cse'able, make appropriate pair of reg-notes around it.\n-\t Test valreg so we don't crash; may safely ignore `const'\n-\t if return type is void.  Disable for PARALLEL return values, because\n-\t we have no way to move such values into a pseudo register.  */\n-      if (pass && (flags & ECF_LIBCALL_BLOCK))\n-\t{\n-\t  rtx insns;\n-\t  rtx insn;\n-\t  bool failed = valreg == 0 || GET_CODE (valreg) == PARALLEL;\n-\n-\t  insns = get_insns ();\n-\n-\t  /* Expansion of block moves possibly introduced a loop that may\n-\t     not appear inside libcall block.  */\n-\t  for (insn = insns; insn; insn = NEXT_INSN (insn))\n-\t    if (JUMP_P (insn))\n-\t      failed = true;\n-\n-\t  if (failed)\n-\t    {\n-\t      end_sequence ();\n-\t      emit_insn (insns);\n-\t    }\n-\t  else\n-\t    {\n-\t      rtx note = 0;\n-\t      rtx temp = gen_reg_rtx (GET_MODE (valreg));\n-\n-\t      /* Mark the return value as a pointer if needed.  */\n-\t      if (TREE_CODE (TREE_TYPE (exp)) == POINTER_TYPE)\n-\t\tmark_reg_pointer (temp,\n-\t\t\t\t  TYPE_ALIGN (TREE_TYPE (TREE_TYPE (exp))));\n-\n-\t      end_sequence ();\n-\t      if (flag_unsafe_math_optimizations\n-\t\t  && fndecl\n-\t\t  && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n-\t\t  && (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_SQRT\n-\t\t      || DECL_FUNCTION_CODE (fndecl) == BUILT_IN_SQRTF\n-\t\t      || DECL_FUNCTION_CODE (fndecl) == BUILT_IN_SQRTL))\n-\t\tnote = gen_rtx_fmt_e (SQRT,\n-\t\t\t\t      GET_MODE (temp),\n-\t\t\t\t      args[0].initial_value);\n-\t      else\n-\t\t{\n-\t\t  /* Construct an \"equal form\" for the value which\n-\t\t     mentions all the arguments in order as well as\n-\t\t     the function name.  */\n-\t\t  for (i = 0; i < num_actuals; i++)\n-\t\t    note = gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t      args[i].initial_value, note);\n-\t\t  note = gen_rtx_EXPR_LIST (VOIDmode, funexp, note);\n-\t\t}\n-\t      emit_libcall_block (insns, temp, valreg, note);\n-\n-\t      valreg = temp;\n-\t    }\n-\t}\n-      else if (pass && (flags & ECF_MALLOC))\n+      if (pass && (flags & ECF_MALLOC))\n \t{\n \t  rtx temp = gen_reg_rtx (GET_MODE (valreg));\n \t  rtx last, insns;\n@@ -3346,12 +3264,6 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n     case LCT_PURE:\n       flags |= ECF_PURE;\n       break;\n-    case LCT_CONST_MAKE_BLOCK:\n-      flags |= ECF_CONST | ECF_LIBCALL_BLOCK;\n-      break;\n-    case LCT_PURE_MAKE_BLOCK:\n-      flags |= ECF_PURE | ECF_LIBCALL_BLOCK;\n-      break;\n     case LCT_NORETURN:\n       flags |= ECF_NORETURN;\n       break;\n@@ -3391,8 +3303,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t    mem_value = assign_temp (tfom, 0, 1, 1);\n #endif\n \t  /* This call returns a big structure.  */\n-\t  flags &= ~(ECF_CONST | ECF_PURE | ECF_LOOPING_CONST_OR_PURE \n-\t\t     | ECF_LIBCALL_BLOCK);\n+\t  flags &= ~(ECF_CONST | ECF_PURE | ECF_LOOPING_CONST_OR_PURE);\n \t}\n     }\n   else\n@@ -3421,11 +3332,6 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \n   count = 0;\n \n-  /* Now we are about to start emitting insns that can be deleted\n-     if a libcall is deleted.  */\n-  if (flags & ECF_LIBCALL_BLOCK)\n-    start_sequence ();\n-\n   push_temp_slots ();\n \n   /* If there's a structure value address to be passed,\n@@ -3487,16 +3393,6 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t  int must_copy\n \t    = !reference_callee_copied (&args_so_far, mode, NULL_TREE, 1);\n \n-\t  /* loop.c won't look at CALL_INSN_FUNCTION_USAGE of const/pure\n-\t     functions, so we have to pretend this isn't such a function.  */\n-\t  if (flags & ECF_LIBCALL_BLOCK)\n-\t    {\n-\t      rtx insns = get_insns ();\n-\t      end_sequence ();\n-\t      emit_insn (insns);\n-\t    }\n-\t  flags &= ~ECF_LIBCALL_BLOCK;\n-\n \t  /* If this was a CONST function, it is now PURE since it now\n \t     reads memory.  */\n \t  if (flags & ECF_CONST)\n@@ -3886,49 +3782,6 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n   /* Now restore inhibit_defer_pop to its actual original value.  */\n   OK_DEFER_POP;\n \n-  /* If call is cse'able, make appropriate pair of reg-notes around it.\n-     Test valreg so we don't crash; may safely ignore `const'\n-     if return type is void.  Disable for PARALLEL return values, because\n-     we have no way to move such values into a pseudo register.  */\n-  if (flags & ECF_LIBCALL_BLOCK)\n-    {\n-      rtx insns;\n-\n-      if (valreg == 0)\n-\t{\n-\t  insns = get_insns ();\n-\t  end_sequence ();\n-\t  emit_insn (insns);\n-\t}\n-      else\n-\t{\n-\t  rtx note = 0;\n-\t  rtx temp;\n-\t  int i;\n-\n-\t  if (GET_CODE (valreg) == PARALLEL)\n-\t    {\n-\t      temp = gen_reg_rtx (outmode);\n-\t      emit_group_store (temp, valreg, NULL_TREE,\n-\t\t\t\tGET_MODE_SIZE (outmode));\n-\t      valreg = temp;\n-\t    }\n-\n-\t  temp = gen_reg_rtx (GET_MODE (valreg));\n-\n-\t  /* Construct an \"equal form\" for the value which mentions all the\n-\t     arguments in order as well as the function name.  */\n-\t  for (i = 0; i < nargs; i++)\n-\t    note = gen_rtx_EXPR_LIST (VOIDmode, argvec[i].value, note);\n-\t  note = gen_rtx_EXPR_LIST (VOIDmode, fun, note);\n-\n-\t  insns = get_insns ();\n-\t  end_sequence ();\n-\t  emit_libcall_block (insns, temp, valreg, note);\n-\n-\t  valreg = temp;\n-\t}\n-    }\n   pop_temp_slots ();\n \n   /* Copy the value to the right place.  */\n@@ -4012,12 +3865,9 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n    with NARGS different arguments, passed as alternating rtx values\n    and machine_modes to convert them to.\n \n-   FN_TYPE should be LCT_NORMAL for `normal' calls, LCT_CONST for `const'\n-   calls, LCT_PURE for `pure' calls, LCT_CONST_MAKE_BLOCK for `const' calls\n-   which should be enclosed in REG_LIBCALL/REG_RETVAL notes,\n-   LCT_PURE_MAKE_BLOCK for `purep' calls which should be enclosed in\n-   REG_LIBCALL/REG_RETVAL notes with extra (use (memory (scratch)),\n-   or other LCT_ value for other types of library calls.  */\n+   FN_TYPE should be LCT_NORMAL for `normal' calls, LCT_CONST for\n+   `const' calls, LCT_PURE for `pure' calls, or other LCT_ value for\n+   other types of library calls.  */\n \n void\n emit_library_call (rtx orgfun, enum libcall_type fn_type,"}, {"sha": "c13ccaeb460760d64a1c6c39764f30212ec207ab", "filename": "gcc/optabs.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8030f0eec58ad1aee8f9fc500f3f86f777ef8/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8030f0eec58ad1aee8f9fc500f3f86f777ef8/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=84b8030f0eec58ad1aee8f9fc500f3f86f777ef8", "patch": "@@ -4127,7 +4127,7 @@ prepare_cmp_insn (rtx *px, rtx *py, enum rtx_code *pcomparison, rtx size,\n       size = convert_to_mode (TYPE_MODE (length_type), size,\n \t\t\t      TYPE_UNSIGNED (length_type));\n \n-      result = emit_library_call_value (libfunc, 0, LCT_PURE_MAKE_BLOCK,\n+      result = emit_library_call_value (libfunc, 0, LCT_PURE,\n \t\t\t\t\tresult_mode, 3,\n \t\t\t\t\tXEXP (x, 0), Pmode,\n \t\t\t\t\tXEXP (y, 0), Pmode,\n@@ -4169,7 +4169,7 @@ prepare_cmp_insn (rtx *px, rtx *py, enum rtx_code *pcomparison, rtx size,\n \t    libfunc = ulibfunc;\n \t}\n \n-      result = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST_MAKE_BLOCK,\n+      result = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST,\n \t\t\t\t\ttargetm.libgcc_cmp_return_mode (),\n \t\t\t\t\t2, x, mode, y, mode);\n "}, {"sha": "e9dbb3b8d30797973f3ef9a3e98e0988ebd369f5", "filename": "gcc/rtl.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8030f0eec58ad1aee8f9fc500f3f86f777ef8/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8030f0eec58ad1aee8f9fc500f3f86f777ef8/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=84b8030f0eec58ad1aee8f9fc500f3f86f777ef8", "patch": "@@ -2218,11 +2218,9 @@ enum libcall_type\n   LCT_NORMAL = 0,\n   LCT_CONST = 1,\n   LCT_PURE = 2,\n-  LCT_CONST_MAKE_BLOCK = 3,\n-  LCT_PURE_MAKE_BLOCK = 4,\n-  LCT_NORETURN = 5,\n-  LCT_THROW = 6,\n-  LCT_RETURNS_TWICE = 7\n+  LCT_NORETURN = 3,\n+  LCT_THROW = 4,\n+  LCT_RETURNS_TWICE = 5\n };\n \n extern void emit_library_call (rtx, enum libcall_type, enum machine_mode, int,"}, {"sha": "0618d0ab52e7d19cf6c9f33cdf36feada853fcc2", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b8030f0eec58ad1aee8f9fc500f3f86f777ef8/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b8030f0eec58ad1aee8f9fc500f3f86f777ef8/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=84b8030f0eec58ad1aee8f9fc500f3f86f777ef8", "patch": "@@ -4970,11 +4970,9 @@ extern tree build_duplicate_type (tree);\n #define ECF_RETURNS_TWICE\t  (1 << 7)\n /* Nonzero if this call replaces the current stack frame.  */\n #define ECF_SIBCALL\t\t  (1 << 8)\n-/* Create libcall block around the call.  */\n-#define ECF_LIBCALL_BLOCK\t  (1 << 9)\n /* Function does not read or write memory (but may have side effects, so\n    it does not necessarily fit ECF_CONST).  */\n-#define ECF_NOVOPS\t\t  (1 << 10)\n+#define ECF_NOVOPS\t\t  (1 << 9)\n \n extern int flags_from_decl_or_type (const_tree);\n extern int call_expr_flags (const_tree);"}]}