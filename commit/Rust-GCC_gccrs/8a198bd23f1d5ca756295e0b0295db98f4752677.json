{"sha": "8a198bd23f1d5ca756295e0b0295db98f4752677", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGExOThiZDIzZjFkNWNhNzU2Mjk1ZTBiMDI5NWRiOThmNDc1MjY3Nw==", "commit": {"author": {"name": "John Wehle", "email": "john@feith.com", "date": "1998-05-11T23:47:28Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-05-11T23:47:28Z"}, "message": "varasm.c (assemble_variable): Compute the alignment of the data earlier so that both initialized and...\n\n        * varasm.c (assemble_variable): Compute the alignment of the data\n        earlier so that both initialized and uninitialized variables are\n        effected by DATA_ALIGNMENT.\n        * tm.texi (DATA_ALIGNMENT): Updated appropriately.\n\nFrom-SVN: r19692", "tree": {"sha": "410a3ff25df88c10b9c9c4cb17863bd3dea83ea5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/410a3ff25df88c10b9c9c4cb17863bd3dea83ea5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a198bd23f1d5ca756295e0b0295db98f4752677", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a198bd23f1d5ca756295e0b0295db98f4752677", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a198bd23f1d5ca756295e0b0295db98f4752677", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a198bd23f1d5ca756295e0b0295db98f4752677/comments", "author": {"login": "jlwehle", "id": 46985578, "node_id": "MDQ6VXNlcjQ2OTg1NTc4", "avatar_url": "https://avatars.githubusercontent.com/u/46985578?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlwehle", "html_url": "https://github.com/jlwehle", "followers_url": "https://api.github.com/users/jlwehle/followers", "following_url": "https://api.github.com/users/jlwehle/following{/other_user}", "gists_url": "https://api.github.com/users/jlwehle/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlwehle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlwehle/subscriptions", "organizations_url": "https://api.github.com/users/jlwehle/orgs", "repos_url": "https://api.github.com/users/jlwehle/repos", "events_url": "https://api.github.com/users/jlwehle/events{/privacy}", "received_events_url": "https://api.github.com/users/jlwehle/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cf4ccd63bc9d72c975529785f74743a9310a37d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf4ccd63bc9d72c975529785f74743a9310a37d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf4ccd63bc9d72c975529785f74743a9310a37d6"}], "stats": {"total": 87, "additions": 49, "deletions": 38}, "files": [{"sha": "37585510cc10e5b66070553f5c0ecae00bf36fb6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a198bd23f1d5ca756295e0b0295db98f4752677/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a198bd23f1d5ca756295e0b0295db98f4752677/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8a198bd23f1d5ca756295e0b0295db98f4752677", "patch": "@@ -1,3 +1,10 @@\n+Tue May 12 00:47:33 1998  John Wehle  (john@feith.com)\n+\n+\t* varasm.c (assemble_variable): Compute the alignment of the data \n+\tearlier so that both initialized and uninitialized variables are\n+\teffected by DATA_ALIGNMENT.\n+\t* tm.texi (DATA_ALIGNMENT): Updated appropriately.\n+\n Mon May 11 19:57:58 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* mips.c: Prototype static functions."}, {"sha": "b95514e538bbbebe912462767cfa01d32d963937", "filename": "gcc/tm.texi", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a198bd23f1d5ca756295e0b0295db98f4752677/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a198bd23f1d5ca756295e0b0295db98f4752677/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=8a198bd23f1d5ca756295e0b0295db98f4752677", "patch": "@@ -810,9 +810,9 @@ the default value is @code{BIGGEST_ALIGNMENT}.\n \n @findex DATA_ALIGNMENT\n @item DATA_ALIGNMENT (@var{type}, @var{basic-align})\n-If defined, a C expression to compute the alignment for a static\n-variable.  @var{type} is the data type, and @var{basic-align} is the\n-alignment that the object would ordinarily have.  The value of this\n+If defined, a C expression to compute the alignment for a variables in\n+the static store.  @var{type} is the data type, and @var{basic-align} is\n+the alignment that the object would ordinarily have.  The value of this\n macro is used instead of that alignment to align the object.\n \n If this macro is not defined, then @var{basic-align} is used."}, {"sha": "afdee7b78e5a5fcde18de7b511318201079d6dae", "filename": "gcc/varasm.c", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a198bd23f1d5ca756295e0b0295db98f4752677/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a198bd23f1d5ca756295e0b0295db98f4752677/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=8a198bd23f1d5ca756295e0b0295db98f4752677", "patch": "@@ -1275,6 +1275,42 @@ assemble_variable (decl, top_level, at_end, dont_output_data)\n       strcpy (first_global_object_name, p);\n     }\n \n+  /* Compute the alignment of this data.  */\n+\n+  align = DECL_ALIGN (decl);\n+\n+  /* In the case for initialing an array whose length isn't specified,\n+     where we have not yet been able to do the layout,\n+     figure out the proper alignment now.  */\n+  if (dont_output_data && DECL_SIZE (decl) == 0\n+      && TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n+    align = MAX (align, TYPE_ALIGN (TREE_TYPE (TREE_TYPE (decl))));\n+\n+  /* Some object file formats have a maximum alignment which they support.\n+     In particular, a.out format supports a maximum alignment of 4.  */\n+#ifndef MAX_OFILE_ALIGNMENT\n+#define MAX_OFILE_ALIGNMENT BIGGEST_ALIGNMENT\n+#endif\n+  if (align > MAX_OFILE_ALIGNMENT)\n+    {\n+      warning_with_decl (decl,\n+\t  \"alignment of `%s' is greater than maximum object file alignment\");\n+      align = MAX_OFILE_ALIGNMENT;\n+    }\n+\n+  /* On some machines, it is good to increase alignment sometimes.  */\n+#ifdef DATA_ALIGNMENT\n+  align = DATA_ALIGNMENT (TREE_TYPE (decl), align);\n+#endif\n+#ifdef CONSTANT_ALIGNMENT\n+  if (DECL_INITIAL (decl) != 0 && DECL_INITIAL (decl) != error_mark_node)\n+    align = CONSTANT_ALIGNMENT (DECL_INITIAL (decl), align);\n+#endif\n+\n+  /* Reset the alignment in case we have made it tighter, so we can benefit\n+     from it in get_pointer_alignment.  */\n+  DECL_ALIGN (decl) = align;\n+\n   /* Handle uninitialized definitions.  */\n \n   if ((DECL_INITIAL (decl) == 0 || DECL_INITIAL (decl) == error_mark_node)\n@@ -1464,42 +1500,10 @@ assemble_variable (decl, top_level, at_end, dont_output_data)\n   if (in_section != saved_in_section)\n     variable_section (decl, reloc);\n \n-  /* Compute and output the alignment of this data.  */\n-\n-  align = DECL_ALIGN (decl);\n-  /* In the case for initialing an array whose length isn't specified,\n-     where we have not yet been able to do the layout,\n-     figure out the proper alignment now.  */\n-  if (dont_output_data && DECL_SIZE (decl) == 0\n-      && TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n-    align = MAX (align, TYPE_ALIGN (TREE_TYPE (TREE_TYPE (decl))));\n-\n-  /* Some object file formats have a maximum alignment which they support.\n-     In particular, a.out format supports a maximum alignment of 4.  */\n-#ifndef MAX_OFILE_ALIGNMENT\n-#define MAX_OFILE_ALIGNMENT BIGGEST_ALIGNMENT\n-#endif\n-  if (align > MAX_OFILE_ALIGNMENT)\n-    {\n-      warning_with_decl (decl,\n-\t  \"alignment of `%s' is greater than maximum object file alignment\");\n-      align = MAX_OFILE_ALIGNMENT;\n-    }\n-#ifdef DATA_ALIGNMENT\n-  /* On some machines, it is good to increase alignment sometimes.  */\n-  align = DATA_ALIGNMENT (TREE_TYPE (decl), align);\n-#endif\n-#ifdef CONSTANT_ALIGNMENT\n-  if (DECL_INITIAL (decl))\n-    align = CONSTANT_ALIGNMENT (DECL_INITIAL (decl), align);\n-#endif\n-\n-  /* Reset the alignment in case we have made it tighter, so we can benefit\n-     from it in get_pointer_alignment.  */\n-  DECL_ALIGN (decl) = align;\n-\n+  /* Output the alignment of this data.  */\n   if (align > BITS_PER_UNIT)\n-    ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));\n+    ASM_OUTPUT_ALIGN (asm_out_file,\n+\t\t      floor_log2 (DECL_ALIGN (decl) / BITS_PER_UNIT));\n \n   /* Do any machine/system dependent processing of the object.  */\n #ifdef ASM_DECLARE_OBJECT_NAME"}]}