{"sha": "1ceddd7497e15d262ead6f673f8f5ce79dd63714", "node_id": "C_kwDOANBUbNoAKDFjZWRkZDc0OTdlMTVkMjYyZWFkNmY2NzNmOGY1Y2U3OWRkNjM3MTQ", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-04-23T08:25:31Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-04-23T08:25:31Z"}, "message": "i386: Improve ix86_expand_int_movcc [PR105338]\n\nThe following testcase regressed on x86_64 on the trunk, due to some GIMPLE\npass changes (r12-7687) we end up an *.optimized dump difference of:\n@@ -8,14 +8,14 @@ int foo (int i)\n\n   <bb 2> [local count: 1073741824]:\n   if (i_2(D) != 0)\n-    goto <bb 4>; [35.00%]\n+    goto <bb 3>; [35.00%]\n   else\n-    goto <bb 3>; [65.00%]\n+    goto <bb 4>; [65.00%]\n\n-  <bb 3> [local count: 697932184]:\n+  <bb 3> [local count: 375809640]:\n\n   <bb 4> [local count: 1073741824]:\n-  # iftmp.0_1 = PHI <5(2), i_2(D)(3)>\n+  # iftmp.0_1 = PHI <5(3), i_2(D)(2)>\n   return iftmp.0_1;\n\n }\nand similarly for the other functions.  That is functionally equivalent and\nthere is no canonical form for those.  The reason for i_2(D) in the PHI\nargument as opposed to 0 is the uncprop pass, that is in many cases\nbeneficial for expansion as we don't need to load the value into some pseudo\nin one of the if blocks.\nNow, for the 11.x ordering we have the pseudo = i insn in the extended basic\nblock (it comes first) and so forwprop1 undoes what uncprop does by\npropagating constant 0 there.  But for the 12.x ordering, the extended basic\nblock contains pseudo = 5 and pseudo = i is in the other bb and so fwprop1\ndoesn't change it.\nDuring the ce1 pass, we attempt to emit a conditional move and we have very\nnice code for the cases where both last operands of ?: are constant, and yet\nanother for !TARGET_CMOVE if at least one of them is.\n\nThe following patch will undo the uncprop behavior during\nix86_expand_int_movcc, but just for those spots that can benefit from both\nor at least one operands being constant, leaving the pure cmov case as is\n(because then it is useful not to have to load a constant into a pseudo\nas it already is in one).  We can do that in the\nop0 == op1 ? op0 : op3\nor\nop0 != op1 ? op2 : op0\ncases if op1 is a CONST_INT by pretending it is\nop0 == op1 ? op1 : op3\nor\nop0 != op1 ? op2 : op1\n\n2022-04-23  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR target/105338\n\t* config/i386/i386-expand.cc (ix86_expand_int_movcc): Handle\n\top0 == cst1 ? op0 : op3 like op0 == cst1 ? cst1 : op3 for the non-cmov\n\tcases.\n\n\t* gcc.target/i386/pr105338.c: New test.", "tree": {"sha": "3588002ffb178e6a3280b898102207af27957145", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3588002ffb178e6a3280b898102207af27957145"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ceddd7497e15d262ead6f673f8f5ce79dd63714", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ceddd7497e15d262ead6f673f8f5ce79dd63714", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ceddd7497e15d262ead6f673f8f5ce79dd63714", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ceddd7497e15d262ead6f673f8f5ce79dd63714/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab54f6007c79711fc2192098d4ccc3c24e95f3e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab54f6007c79711fc2192098d4ccc3c24e95f3e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab54f6007c79711fc2192098d4ccc3c24e95f3e6"}], "stats": {"total": 51, "additions": 47, "deletions": 4}, "files": [{"sha": "31780b6daf7c5df6a960251bdafdf64b68dad6cf", "filename": "gcc/config/i386/i386-expand.cc", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ceddd7497e15d262ead6f673f8f5ce79dd63714/gcc%2Fconfig%2Fi386%2Fi386-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ceddd7497e15d262ead6f673f8f5ce79dd63714/gcc%2Fconfig%2Fi386%2Fi386-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.cc?ref=1ceddd7497e15d262ead6f673f8f5ce79dd63714", "patch": "@@ -3136,6 +3136,8 @@ ix86_expand_int_movcc (rtx operands[])\n   bool sign_bit_compare_p = false;\n   rtx op0 = XEXP (operands[1], 0);\n   rtx op1 = XEXP (operands[1], 1);\n+  rtx op2 = operands[2];\n+  rtx op3 = operands[3];\n \n   if (GET_MODE (op0) == TImode\n       || (GET_MODE (op0) == DImode\n@@ -3153,17 +3155,29 @@ ix86_expand_int_movcc (rtx operands[])\n       || (op1 == constm1_rtx && (code == GT || code == LE)))\n     sign_bit_compare_p = true;\n \n+  /* op0 == op1 ? op0 : op3 is equivalent to op0 == op1 ? op1 : op3,\n+     but if op1 is a constant, the latter form allows more optimizations,\n+     either through the last 2 ops being constant handling, or the one\n+     constant and one variable cases.  On the other side, for cmov the\n+     former might be better as we don't need to load the constant into\n+     another register.  */\n+  if (code == EQ && CONST_INT_P (op1) && rtx_equal_p (op0, op2))\n+    op2 = op1;\n+  /* Similarly for op0 != op1 ? op2 : op0 and op0 != op1 ? op2 : op1.  */\n+  else if (code == NE && CONST_INT_P (op1) && rtx_equal_p (op0, op3))\n+    op3 = op1;\n+\n   /* Don't attempt mode expansion here -- if we had to expand 5 or 6\n      HImode insns, we'd be swallowed in word prefix ops.  */\n \n   if ((mode != HImode || TARGET_FAST_PREFIX)\n       && (mode != (TARGET_64BIT ? TImode : DImode))\n-      && CONST_INT_P (operands[2])\n-      && CONST_INT_P (operands[3]))\n+      && CONST_INT_P (op2)\n+      && CONST_INT_P (op3))\n     {\n       rtx out = operands[0];\n-      HOST_WIDE_INT ct = INTVAL (operands[2]);\n-      HOST_WIDE_INT cf = INTVAL (operands[3]);\n+      HOST_WIDE_INT ct = INTVAL (op2);\n+      HOST_WIDE_INT cf = INTVAL (op3);\n       HOST_WIDE_INT diff;\n \n       diff = ct - cf;\n@@ -3559,6 +3573,9 @@ ix86_expand_int_movcc (rtx operands[])\n       if (BRANCH_COST (optimize_insn_for_speed_p (), false) <= 2)\n \treturn false;\n \n+      operands[2] = op2;\n+      operands[3] = op3;\n+\n       /* If one of the two operands is an interesting constant, load a\n \t constant with the above and mask it in with a logical operation.  */\n "}, {"sha": "a7b879444f4d121d12d737b95622f91eeb749e03", "filename": "gcc/testsuite/gcc.target/i386/pr105338.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ceddd7497e15d262ead6f673f8f5ce79dd63714/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr105338.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ceddd7497e15d262ead6f673f8f5ce79dd63714/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr105338.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr105338.c?ref=1ceddd7497e15d262ead6f673f8f5ce79dd63714", "patch": "@@ -0,0 +1,26 @@\n+/* PR target/105338 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-ipa-icf -masm=att\" } */\n+/* { dg-final { scan-assembler-times \"\\tnegl\\t\" 3 } } */\n+/* { dg-final { scan-assembler-times \"\\tsbbl\\t\" 3 } } */\n+/* { dg-final { scan-assembler-times \"\\tandl\\t\" 3 } } */\n+\n+int\n+foo (int i)\n+{\n+  return i ? 5 : 0;\n+}\n+\n+int\n+bar (int b)\n+{\n+  return !!b * 5;\n+}\n+\n+int\n+baz (int b)\n+{\n+  if (!b)\n+    return 0;\n+  return 5;\n+}"}]}