{"sha": "22c02455bf65c6cec3bf1d7a69439de949fdc76e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJjMDI0NTViZjY1YzZjZWMzYmYxZDdhNjk0MzlkZTk0OWZkYzc2ZQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2008-10-16T00:51:34Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2008-10-16T00:51:34Z"}, "message": "re PR middle-end/37535 (gcc/libgcc2.c:404: internal compiler error: Floating point exception)\n\n2008-10-15  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR middle-end/37535\n\t* ira-lives.c (mark_early_clobbers): Remove.\n\t(make_pseudo_conflict, check_and_make_def_use_conflicts,\n\tcheck_and_make_def_conflicts,\n\tmake_early_clobber_and_input_conflicts,\n\tmark_hard_reg_early_clobbers): New functions.\n\t(process_bb_node_lives): Call\n\tmake_early_clobber_and_input_conflicts and\n\tmark_hard_reg_early_clobbers.  Make hard register inputs live\n\tagain.\n\n\t* doc/rtl.texi (clobber): Change descriotion of RA behaviour for\n\tearly clobbers of pseudo-registers.\n\nFrom-SVN: r141160", "tree": {"sha": "98630eeb409712d9d59c071d3d4c9376d77c509a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98630eeb409712d9d59c071d3d4c9376d77c509a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22c02455bf65c6cec3bf1d7a69439de949fdc76e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22c02455bf65c6cec3bf1d7a69439de949fdc76e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22c02455bf65c6cec3bf1d7a69439de949fdc76e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22c02455bf65c6cec3bf1d7a69439de949fdc76e/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0ca9fa56e9c0eb900efe8106d3c85153b902da8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ca9fa56e9c0eb900efe8106d3c85153b902da8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ca9fa56e9c0eb900efe8106d3c85153b902da8f"}], "stats": {"total": 228, "additions": 193, "deletions": 35}, "files": [{"sha": "68ae6eca9d6dfe23564a48d1b49cee1882fec325", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c02455bf65c6cec3bf1d7a69439de949fdc76e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c02455bf65c6cec3bf1d7a69439de949fdc76e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=22c02455bf65c6cec3bf1d7a69439de949fdc76e", "patch": "@@ -1,3 +1,19 @@\n+2008-10-15  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR middle-end/37535\n+\t* ira-lives.c (mark_early_clobbers): Remove.\n+\t(make_pseudo_conflict, check_and_make_def_use_conflicts,\n+\tcheck_and_make_def_conflicts,\n+\tmake_early_clobber_and_input_conflicts,\n+\tmark_hard_reg_early_clobbers): New functions.\n+\t(process_bb_node_lives): Call\n+\tmake_early_clobber_and_input_conflicts and\n+\tmark_hard_reg_early_clobbers.  Make hard register inputs live\n+\tagain.\n+\n+\t* doc/rtl.texi (clobber): Change descriotion of RA behaviour for\n+\tearly clobbers of pseudo-registers.\n+\t\n 2008-10-15  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR middle-end/37674"}, {"sha": "1411f24e5d9c936fce8b0b7bad6ad7d5fb57e9da", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c02455bf65c6cec3bf1d7a69439de949fdc76e/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c02455bf65c6cec3bf1d7a69439de949fdc76e/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=22c02455bf65c6cec3bf1d7a69439de949fdc76e", "patch": "@@ -2917,11 +2917,12 @@ constituent instructions might not.\n When a @code{clobber} expression for a register appears inside a\n @code{parallel} with other side effects, the register allocator\n guarantees that the register is unoccupied both before and after that\n-insn if it is a hard register clobber or the @samp{&} constraint\n-is specified for at least one alternative (@pxref{Modifiers}) of the\n-clobber.  However, the reload phase may allocate a register used for\n-one of the inputs unless the @samp{&} constraint is specified for the\n-selected alternative.  You can clobber either a specific hard\n+insn if it is a hard register clobber.  For pseudo-register clobber,\n+the register allocator and the reload pass do not assign the same hard\n+register to the clobber and the input operands if there is an insn\n+alternative containing the @samp{&} constraint (@pxref{Modifiers}) for\n+the clobber and the hard register is in register classes of the\n+clobber in the alternative.  You can clobber either a specific hard\n register, a pseudo register, or a @code{scratch} expression; in the\n latter two cases, GCC will allocate a hard register that is available\n there for use as a temporary."}, {"sha": "f4b2d6de42b7d2145a0f82d0784f0845328b4c25", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 171, "deletions": 30, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c02455bf65c6cec3bf1d7a69439de949fdc76e/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c02455bf65c6cec3bf1d7a69439de949fdc76e/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=22c02455bf65c6cec3bf1d7a69439de949fdc76e", "patch": "@@ -349,39 +349,169 @@ mark_ref_dead (df_ref def)\n   mark_reg_dead (reg);\n }\n \n-/* Mark early clobber registers of the current INSN as live (if\n-   LIVE_P) or dead.  Return true if there are such registers.  */\n+/* Make pseudo REG conflicting with pseudo DREG, if the 1st pseudo\n+   class is intersected with class CL.  Advance the current program\n+   point before making the conflict if ADVANCE_P.  Return TRUE if we\n+   will need to advance the current program point.  */\n static bool\n-mark_early_clobbers (rtx insn, bool live_p)\n+make_pseudo_conflict (rtx reg, enum reg_class cl, rtx dreg, bool advance_p)\n {\n-  int alt;\n-  int def;\n-  df_ref *def_rec;\n-  bool set_p = false;\n+  ira_allocno_t a;\n \n-  for (def = 0; def < recog_data.n_operands; def++)\n-    {\n-      rtx dreg = recog_data.operand[def];\n-      \n-      if (GET_CODE (dreg) == SUBREG)\n-\tdreg = SUBREG_REG (dreg);\n-      if (! REG_P (dreg))\n-\tcontinue;\n+  if (GET_CODE (reg) == SUBREG)\n+    reg = SUBREG_REG (reg);\n+  \n+  if (! REG_P (reg) || REGNO (reg) < FIRST_PSEUDO_REGISTER)\n+    return advance_p;\n+  \n+  a = ira_curr_regno_allocno_map[REGNO (reg)];\n+  if (! reg_classes_intersect_p (cl, ALLOCNO_COVER_CLASS (a)))\n+    return advance_p;\n \n-      for (alt = 0; alt < recog_data.n_alternatives; alt++)\n-\tif ((recog_op_alt[def][alt].earlyclobber)\n-\t    && (recog_op_alt[def][alt].cl != NO_REGS))\n-\t  break;\n+  if (advance_p)\n+    curr_point++;\n \n-      if (alt >= recog_data.n_alternatives)\n-\tcontinue;\n+  mark_reg_live (reg);\n+  mark_reg_live (dreg);\n+  mark_reg_dead (reg);\n+  mark_reg_dead (dreg);\n+\n+  return false;\n+}\n \n-      if (live_p)\n-\tmark_reg_live (dreg);\n+/* Check and make if necessary conflicts for pseudo DREG of class\n+   DEF_CL of the current insn with input operand USE of class USE_CL.\n+   Advance the current program point before making the conflict if\n+   ADVANCE_P.  Return TRUE if we will need to advance the current\n+   program point.  */\n+static bool\n+check_and_make_def_use_conflict (rtx dreg, enum reg_class def_cl,\n+\t\t\t\t int use, enum reg_class use_cl,\n+\t\t\t\t bool advance_p)\n+{\n+  if (! reg_classes_intersect_p (def_cl, use_cl))\n+    return advance_p;\n+  \n+  advance_p = make_pseudo_conflict (recog_data.operand[use],\n+\t\t\t\t    use_cl, dreg, advance_p);\n+  /* Reload may end up swapping commutative operands, so you\n+     have to take both orderings into account.  The\n+     constraints for the two operands can be completely\n+     different.  (Indeed, if the constraints for the two\n+     operands are the same for all alternatives, there's no\n+     point marking them as commutative.)  */\n+  if (use < recog_data.n_operands + 1\n+      && recog_data.constraints[use][0] == '%')\n+    advance_p\n+      = make_pseudo_conflict (recog_data.operand[use + 1],\n+\t\t\t      use_cl, dreg, advance_p);\n+  if (use >= 1\n+      && recog_data.constraints[use - 1][0] == '%')\n+    advance_p\n+      = make_pseudo_conflict (recog_data.operand[use - 1],\n+\t\t\t      use_cl, dreg, advance_p);\n+  return advance_p;\n+}\n+\n+/* Check and make if necessary conflicts for definition DEF of class\n+   DEF_CL of the current insn with input operands.  Process only\n+   constraints of alternative ALT.  */\n+static void\n+check_and_make_def_conflict (int alt, int def, enum reg_class def_cl)\n+{\n+  int use, use_match;\n+  ira_allocno_t a;\n+  enum reg_class use_cl, acl;\n+  bool advance_p;\n+  rtx dreg = recog_data.operand[def];\n+\t\n+  if (def_cl == NO_REGS)\n+    return;\n+  \n+  if (GET_CODE (dreg) == SUBREG)\n+    dreg = SUBREG_REG (dreg);\n+  \n+  if (! REG_P (dreg) || REGNO (dreg) < FIRST_PSEUDO_REGISTER)\n+    return;\n+  \n+  a = ira_curr_regno_allocno_map[REGNO (dreg)];\n+  acl = ALLOCNO_COVER_CLASS (a);\n+  if (! reg_classes_intersect_p (acl, def_cl))\n+    return;\n+  \n+  advance_p = true;\n+  \n+  for (use = 0; use < recog_data.n_operands; use++)\n+    {\n+      if (use == def || recog_data.operand_type[use] == OP_OUT)\n+\treturn;\n+      \n+      if (recog_op_alt[use][alt].anything_ok)\n+\tuse_cl = ALL_REGS;\n       else\n-\tmark_reg_dead (dreg);\n-      set_p = true;\n+\tuse_cl = recog_op_alt[use][alt].cl;\n+      \n+      advance_p = check_and_make_def_use_conflict (dreg, def_cl, use,\n+\t\t\t\t\t\t   use_cl, advance_p);\n+      \n+      if ((use_match = recog_op_alt[use][alt].matches) >= 0)\n+\t{\n+\t  if (use_match == def)\n+\t    return;\n+\t  \n+\t  if (recog_op_alt[use_match][alt].anything_ok)\n+\t    use_cl = ALL_REGS;\n+\t  else\n+\t    use_cl = recog_op_alt[use_match][alt].cl;\n+\t  advance_p = check_and_make_def_use_conflict (dreg, def_cl, use,\n+\t\t\t\t\t\t       use_cl, advance_p);\n+\t}\n     }\n+}\n+\n+/* Make conflicts of early clobber pseudo registers of the current\n+   insn with its inputs.  Avoid introducing unnecessary conflicts by\n+   checking classes of the constraints and pseudos because otherwise\n+   significant code degradation is possible for some targets.  */\n+static void\n+make_early_clobber_and_input_conflicts (void)\n+{\n+  int alt;\n+  int def, def_match;\n+  enum reg_class def_cl;\n+\n+  for (alt = 0; alt < recog_data.n_alternatives; alt++)\n+    for (def = 0; def < recog_data.n_operands; def++)\n+      {\n+\tdef_cl = NO_REGS;\n+\tif (recog_op_alt[def][alt].earlyclobber)\n+\t  {\n+\t    if (recog_op_alt[def][alt].anything_ok)\n+\t      def_cl = ALL_REGS;\n+\t    else\n+\t      def_cl = recog_op_alt[def][alt].cl;\n+\t    check_and_make_def_conflict (alt, def, def_cl);\n+\t  }\n+\tif ((def_match = recog_op_alt[def][alt].matches) >= 0\n+\t    && (recog_op_alt[def_match][alt].earlyclobber\n+\t\t|| recog_op_alt[def][alt].earlyclobber))\n+\t  {\n+\t    if (recog_op_alt[def_match][alt].anything_ok)\n+\t      def_cl = ALL_REGS;\n+\t    else\n+\t      def_cl = recog_op_alt[def_match][alt].cl;\n+\t    check_and_make_def_conflict (alt, def, def_cl);\n+\t  }\n+      }\n+}\n+\n+/* Mark early clobber hard registers of the current INSN as live (if\n+   LIVE_P) or dead.  Return true if there are such registers.  */\n+static bool\n+mark_hard_reg_early_clobbers (rtx insn, bool live_p)\n+{\n+  df_ref *def_rec;\n+  bool set_p = false;\n \n   for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n     if (DF_REF_FLAGS_IS_SET (*def_rec, DF_REF_MUST_CLOBBER))\n@@ -792,25 +922,36 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t\t}\n \t    }\n \t  \n+\t  make_early_clobber_and_input_conflicts ();\n+\n \t  curr_point++;\n \n \t  /* Mark each used value as live.  */\n \t  for (use_rec = DF_INSN_USES (insn); *use_rec; use_rec++)\n \t    mark_ref_live (*use_rec);\n \n-\t  set_p = mark_early_clobbers (insn, true);\n-\n \t  process_single_reg_class_operands (true, freq);\n \t  \n+\t  set_p = mark_hard_reg_early_clobbers (insn, true);\n+\n \t  if (set_p)\n \t    {\n-\t      mark_early_clobbers (insn, false);\n+\t      mark_hard_reg_early_clobbers (insn, false);\n \n-\t      /* Mark each used value as live again.  For example, a\n+\t      /* Mark each hard reg as live again.  For example, a\n \t\t hard register can be in clobber and in an insn\n \t\t input.  */\n \t      for (use_rec = DF_INSN_USES (insn); *use_rec; use_rec++)\n-\t\tmark_ref_live (*use_rec);\n+\t\t{\n+\t\t  rtx ureg = DF_REF_REG (*use_rec);\n+\t\t  \n+\t\t  if (GET_CODE (ureg) == SUBREG)\n+\t\t    ureg = SUBREG_REG (ureg);\n+\t\t  if (! REG_P (ureg) || REGNO (ureg) >= FIRST_PSEUDO_REGISTER)\n+\t\t    continue;\n+\t\t  \n+\t\t  mark_ref_live (*use_rec);\n+\t\t}\n \t    }\n \n \t  curr_point++;"}]}