{"sha": "3fb68f2e666d9de7e0326af9f43b12c9e98f19a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZiNjhmMmU2NjZkOWRlN2UwMzI2YWY5ZjQzYjEyYzllOThmMTlhNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-06-03T19:16:43Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-06-03T19:24:38Z"}, "message": "Optimize ODR enum streaming\n\nit turns out that half of the global decl stream of cc1 LTO build consits\nTREE_LISTS, identifiers and integer cosntats representing TYPE_VALUES of enums.\nThose are streamed only to produce ODR warning and used otherwise, so this\npatch moves the info to a separate section that is represented and streamed\nmore effectively.\n\nThis also adds place for more info that may be used for ODR diagnostics\n(i.e. at the moment we do not warn when the declarations differs i.e. by the\nassociated member functions and their types) and the type inheritance graph\nrather then poluting the global stream.\n\nI was bit unsure what enums we want to store into the section.  All parsed\nenums is probably too expensive, only those enums streamed to represent IL is\nbit hard to get, so I went for those seen by free lang data.\n\nAs a plus we now get bit more precise warning because also the location of\nmismatched enum CONST_DECL is streamed.\n\nIt changes:\n[WPA] read 4608466 unshared trees\n[WPA] read 2942094 mergeable SCCs of average size 1.365328\n[WPA] 8625389 tree bodies read in total\n[WPA] tree SCC table: size 524287, 247652 elements, collision ratio: 0.383702\n[WPA] tree SCC max chain length 2 (size 1)\n[WPA] Compared 2694442 SCCs, 228 collisions (0.000085)\n[WPA] Merged 2694419 SCCs\n[WPA] Merged 3731982 tree bodies\n[WPA] Merged 633335 types\n[WPA] 122077 types prevailed (155548 associated trees)\n...\n[WPA] Compression: 110593119 input bytes, 287696614 uncompressed bytes (ratio: 2.601397)\n[WPA] Size of mmap'd section decls: 85628556 bytes\n[WPA] Size of mmap'd section function_body: 13842928 bytes\n\n[WPA] read 1720989 unshared trees\n[WPA] read 1252217 mergeable SCCs of average size 1.858507\n[WPA] 4048243 tree bodies read in total\n[WPA] tree SCC table: size 524287, 226524 elements, collision ratio: 0.491759\n[WPA] tree SCC max chain length 2 (size 1)\n[WPA] Compared 1025693 SCCs, 196 collisions (0.000191)\n[WPA] Merged 1025670 SCCs\n[WPA] Merged 2063373 tree bodies\n[WPA] Merged 633497 types\n[WPA] 122299 types prevailed (155827 associated trees)\n...\n[WPA] Compression: 103428770 input bytes, 281151423 uncompressed bytes (ratio: 2.718310)\n[WPA] Size of mmap'd section decls: 49390917 bytes\n[WPA] Size of mmap'd section function_body: 13858258 bytes\n...\n[WPA] Size of mmap'd section odr_types: 29054816 bytes\n\nSo number of SCCs streamed drops to 38% and the number of unshared trees (that\nare bit misnamed since it is mostly integer_cst) to 37%.\n\nThings speeds up correspondingly, but I did not save time report from previous\nbuild.\n\nThe enum values are still quite surprisingly large.  I may take a look into\nways getting it smaller incrementally, but it streams reasonably fast:\n\nTime variable                                   usr           sys          wall               GGC\n phase opt and generate             :  25.20 ( 68%)  10.88 ( 72%)  36.13 ( 69%)  868060 kB ( 52%)\n phase stream in                    :   4.46 ( 12%)   0.90 (  6%)   5.38 ( 10%)  790724 kB ( 48%)\n phase stream out                   :   6.69 ( 18%)   3.32 ( 22%)  10.03 ( 19%)       8 kB (  0%)\n ipa lto gimple in                  :   0.79 (  2%)   1.86 ( 12%)   2.39 (  5%)  252612 kB ( 15%)\n ipa lto gimple out                 :   2.48 (  7%)   0.78 (  5%)   3.26 (  6%)       0 kB (  0%)\n ipa lto decl in                    :   1.71 (  5%)   0.46 (  3%)   2.34 (  4%)  417883 kB ( 25%)\n ipa lto decl out                   :   3.28 (  9%)   0.07 (  0%)   3.27 (  6%)       0 kB (  0%)\n whopr wpa I/O                      :   0.40 (  1%)   2.24 ( 15%)   2.77 (  5%)       8 kB (  0%)\n lto stream decompression           :   1.38 (  4%)   0.31 (  2%)   1.36 (  3%)       0 kB (  0%)\n ipa ODR types                      :   0.18 (  0%)   0.02 (  0%)   0.25 (  0%)       0 kB (  0%)\n ipa inlining heuristics            :  11.64 ( 31%)   1.45 ( 10%)  13.12 ( 25%)  453160 kB ( 27%)\n ipa pure const                     :   1.74 (  5%)   0.00 (  0%)   1.76 (  3%)       0 kB (  0%)\n ipa icf                            :   1.72 (  5%)   5.33 ( 35%)   7.06 ( 13%)   16593 kB (  1%)\n whopr partitioning                 :   2.22 (  6%)   0.01 (  0%)   2.23 (  4%)    5689 kB (  0%)\n TOTAL                              :  37.17         15.20         52.46        1660886 kB\n\nLTO-bootstrapped/regtested x86_64-linux, will comit it shortly.\n\ngcc/ChangeLog:\n\n2020-06-03  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* ipa-devirt.c: Include data-streamer.h, lto-streamer.h and\n\tstreamer-hooks.h.\n\t(odr_enums): New static var.\n\t(struct odr_enum_val): New struct.\n\t(class odr_enum): New struct.\n\t(odr_enum_map): New hashtable.\n\t(odr_types_equivalent_p): Drop code testing TYPE_VALUES.\n\t(add_type_duplicate): Likewise.\n\t(free_odr_warning_data): Do not free TYPE_VALUES.\n\t(register_odr_enum): New function.\n\t(ipa_odr_summary_write): New function.\n\t(ipa_odr_read_section): New function.\n\t(ipa_odr_summary_read): New function.\n\t(class pass_ipa_odr): New pass.\n\t(make_pass_ipa_odr): New function.\n\t* ipa-utils.h (register_odr_enum): Declare.\n\t* lto-section-in.c: (lto_section_name): Add odr_types section.\n\t* lto-streamer.h (enum lto_section_type): Add odr_types section.\n\t* passes.def: Add odr_types pass.\n\t* lto-streamer-out.c (DFS::DFS_write_tree_body): Do not stream\n\tTYPE_VALUES.\n\t(hash_tree): Likewise.\n\t* tree-streamer-in.c (lto_input_ts_type_non_common_tree_pointers):\n\tLikewise.\n\t* tree-streamer-out.c (write_ts_type_non_common_tree_pointers):\n\tLikewise.\n\t* timevar.def (TV_IPA_ODR): New timervar.\n\t* tree-pass.h (make_pass_ipa_odr): Declare.\n\t* tree.c (free_lang_data_in_type): Regiser ODR types.\n\ngcc/lto/ChangeLog:\n\n2020-06-03  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* lto-common.c (compare_tree_sccs_1): Do not compare TYPE_VALUES.\n\ngcc/testsuite/ChangeLog:\n\n2020-06-03  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* g++.dg/lto/pr84805_0.C: Update.", "tree": {"sha": "1e0611b64d8dc175b8ea8e33735528f35bc79ef6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e0611b64d8dc175b8ea8e33735528f35bc79ef6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6/comments", "author": null, "committer": null, "parents": [{"sha": "cf7eac5805e714c7e71b699329e2c4f4a88addc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf7eac5805e714c7e71b699329e2c4f4a88addc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf7eac5805e714c7e71b699329e2c4f4a88addc1"}], "stats": {"total": 468, "additions": 379, "deletions": 89}, "files": [{"sha": "8e36ff1ea1ddec22d40f244fbc4a20fd791903ad", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 359, "deletions": 45, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=3fb68f2e666d9de7e0326af9f43b12c9e98f19a6", "patch": "@@ -88,7 +88,7 @@ along with GCC; see the file COPYING3.  If not see\n      This means that the graph is not complete. Types with no methods are not\n      inserted into the graph.  Also types without virtual methods are not\n      represented at all, though it may be easy to add this.\n- \n+\n      The inheritance graph is represented as follows:\n \n        Vertices are structures odr_type.  Every odr_type may correspond\n@@ -131,6 +131,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"intl.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n+#include \"data-streamer.h\"\n+#include \"lto-streamer.h\"\n+#include \"streamer-hooks.h\"\n \n /* Hash based set of pairs of types.  */\n struct type_pair\n@@ -495,6 +498,29 @@ static odr_hash_type *odr_hash;\n static GTY(()) vec <odr_type, va_gc> *odr_types_ptr;\n #define odr_types (*odr_types_ptr)\n \n+/* All enums defined and accessible for the unit.  */\n+static GTY(()) vec <tree, va_gc> *odr_enums;\n+\n+/* Information we hold about value defined by an enum type.  */\n+struct odr_enum_val\n+{\n+  const char *name;\n+  HOST_WIDE_INT val;\n+  location_t locus;\n+};\n+\n+/* Information about enum values.  */\n+struct odr_enum\n+{\n+  location_t locus;\n+  auto_vec<odr_enum_val, 0> vals;\n+  bool warned;\n+};\n+\n+/* A table of all ODR enum definitions.  */\n+static hash_map <nofree_string_hash, odr_enum> *odr_enum_map = NULL;\n+static struct obstack odr_enum_obstack;\n+\n /* Set TYPE_BINFO of TYPE and its variants to BINFO.  */\n void\n set_type_binfo (tree type, tree binfo)\n@@ -1205,37 +1231,6 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n       return false;\n     }\n \n-  if (TREE_CODE (t1) == ENUMERAL_TYPE\n-      && TYPE_VALUES (t1) && TYPE_VALUES (t2))\n-    {\n-      tree v1, v2;\n-      for (v1 = TYPE_VALUES (t1), v2 = TYPE_VALUES (t2);\n-\t   v1 && v2 ; v1 = TREE_CHAIN (v1), v2 = TREE_CHAIN (v2))\n-\t{\n-\t  if (TREE_PURPOSE (v1) != TREE_PURPOSE (v2))\n-\t    {\n-\t      warn_odr (t1, t2, NULL, NULL, warn, warned,\n-\t\t\tG_(\"an enum with different value name\"\n-\t\t\t   \" is defined in another translation unit\"));\n-\t      return false;\n-\t    }\n-\t  if (!operand_equal_p (TREE_VALUE (v1), TREE_VALUE (v2), 0))\n-\t    {\n-\t      warn_odr (t1, t2, NULL, NULL, warn, warned,\n-\t\t\tG_(\"an enum with different values is defined\"\n-\t\t\t   \" in another translation unit\"));\n-\t      return false;\n-\t    }\n-\t}\n-      if (v1 || v2)\n-\t{\n-\t  warn_odr (t1, t2, NULL, NULL, warn, warned,\n-\t\t    G_(\"an enum with mismatching number of values \"\n-\t\t       \"is defined in another translation unit\"));\n-\t  return false;\n-\t}\n-    }\n-\n   /* Non-aggregate types can be handled cheaply.  */\n   if (INTEGRAL_TYPE_P (t1)\n       || SCALAR_FLOAT_TYPE_P (t1)\n@@ -1622,10 +1617,6 @@ add_type_duplicate (odr_type val, tree type)\n     }\n   else if (COMPLETE_TYPE_P (val->type) && !COMPLETE_TYPE_P (type))\n     ;\n-  else if (TREE_CODE (val->type) == ENUMERAL_TYPE\n-\t   && TREE_CODE (type) == ENUMERAL_TYPE\n-\t   && !TYPE_VALUES (val->type) && TYPE_VALUES (type))\n-    prevail = true;\n   else if (TREE_CODE (val->type) == RECORD_TYPE\n \t   && TREE_CODE (type) == RECORD_TYPE\n \t   && TYPE_BINFO (type) && !TYPE_BINFO (val->type))\n@@ -1974,7 +1965,7 @@ get_odr_type (tree type, bool insert)\n       unsigned int i;\n \n       gcc_assert (BINFO_TYPE (TYPE_BINFO (val->type)) == type);\n-  \n+\n       val->all_derivations_known = type_all_derivations_known_p (type);\n       for (i = 0; i < BINFO_N_BASE_BINFOS (binfo); i++)\n \t/* For now record only polymorphic types. other are\n@@ -2219,7 +2210,7 @@ dump_type_inheritance_graph (FILE *f)\n \n /* Save some WPA->ltrans streaming by freeing stuff needed only for good\n    ODR warnings.\n-   We free TYPE_VALUES of enums and also make TYPE_DECLs to not point back\n+   We make TYPE_DECLs to not point back\n    to the type (which is needed to keep them in the same SCC and preserve\n    location information to output warnings) and subsequently we make all\n    TYPE_DECLS of same assembler name equivalent.  */\n@@ -2239,17 +2230,13 @@ free_odr_warning_data ()\n       {\n \ttree t = odr_types[i]->type;\n \n-\tif (TREE_CODE (t) == ENUMERAL_TYPE)\n-\t  TYPE_VALUES (t) = NULL;\n \tTREE_TYPE (TYPE_NAME (t)) = void_type_node;\n \n \tif (odr_types[i]->types)\n           for (unsigned int j = 0; j < odr_types[i]->types->length (); j++)\n \t    {\n \t      tree td = (*odr_types[i]->types)[j];\n \n-\t      if (TREE_CODE (td) == ENUMERAL_TYPE)\n-\t        TYPE_VALUES (td) = NULL;\n \t      TYPE_NAME (td) = TYPE_NAME (t);\n \t    }\n       }\n@@ -2283,7 +2270,7 @@ build_type_inheritance_graph (void)\n       get_odr_type (TYPE_METHOD_BASETYPE (TREE_TYPE (n->decl)), true);\n \n     /* Look also for virtual tables of types that do not define any methods.\n- \n+\n        We need it in a case where class B has virtual base of class A\n        re-defining its virtual method and there is class C with no virtual\n        methods with B as virtual base.\n@@ -2600,7 +2587,7 @@ record_target_from_binfo (vec <cgraph_node *> &nodes,\n    INSERTED is used to avoid duplicate insertions of methods into NODES.\n    MATCHED_VTABLES are used to avoid duplicate walking vtables.\n    Clear COMPLETEP if unreferable target is found.\n- \n+\n    If CONSIDER_CONSTRUCTION is true, record to BASES_TO_CONSIDER\n    all cases where BASE_SKIPPED is true (because the base is abstract\n    class).  */\n@@ -2800,7 +2787,7 @@ subbinfo_with_vtable_at_offset (tree binfo, unsigned HOST_WIDE_INT offset,\n \t  && DECL_ASSEMBLER_NAME (v) == DECL_ASSEMBLER_NAME (vtable))\n \treturn binfo;\n     }\n-  \n+\n   for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n     if (polymorphic_type_binfo_p (base_binfo))\n       {\n@@ -4016,4 +4003,331 @@ debug_tree_odr_name (tree type, bool demangle)\n   fprintf (stderr, \"%s\\n\", odr);\n }\n \n+/* Register ODR enum so we later stream record about its values.  */\n+\n+void\n+register_odr_enum (tree t)\n+{\n+  if (flag_lto)\n+    vec_safe_push (odr_enums, t);\n+}\n+\n+/* Write ODR enums to LTO stream file.  */\n+\n+static void\n+ipa_odr_summary_write (void)\n+{\n+  if (!odr_enums && !odr_enum_map)\n+    return;\n+  struct output_block *ob = create_output_block (LTO_section_odr_types);\n+  unsigned int i;\n+  tree t;\n+\n+  if (odr_enums)\n+    {\n+      streamer_write_uhwi (ob, odr_enums->length ());\n+\n+      /* For every ODR enum stream out\n+\t   - its ODR name\n+\t   - number of values,\n+\t   - value names and constant their represent\n+\t   - bitpack of locations so we can do good diagnostics.  */\n+      FOR_EACH_VEC_ELT (*odr_enums, i, t)\n+\t{\n+\t  streamer_write_string (ob, ob->main_stream,\n+\t\t\t\t IDENTIFIER_POINTER\n+\t\t\t\t     (DECL_ASSEMBLER_NAME (TYPE_NAME (t))),\n+\t\t\t\t true);\n+\n+\t  int n = 0;\n+\t  for (tree e = TYPE_VALUES (t); e; e = TREE_CHAIN (e))\n+\t    n++;\n+\t  streamer_write_uhwi (ob, n);\n+\t  for (tree e = TYPE_VALUES (t); e; e = TREE_CHAIN (e))\n+\t    {\n+\t      streamer_write_string (ob, ob->main_stream,\n+\t\t\t\t     IDENTIFIER_POINTER (TREE_PURPOSE (e)),\n+\t\t\t\t     true);\n+\t      streamer_write_hwi (ob, tree_to_shwi\n+\t\t\t\t\t(DECL_INITIAL (TREE_VALUE (e))));\n+\t    }\n+\n+\t  bitpack_d bp = bitpack_create (ob->main_stream);\n+\t  lto_output_location (ob, &bp, DECL_SOURCE_LOCATION (TYPE_NAME (t)));\n+\t  for (tree e = TYPE_VALUES (t); e; e = TREE_CHAIN (e))\n+\t    lto_output_location (ob, &bp,\n+\t\t\t\t DECL_SOURCE_LOCATION (TREE_VALUE (e)));\n+\t  streamer_write_bitpack (&bp);\n+\t}\n+      vec_free (odr_enums);\n+      odr_enums = NULL;\n+    }\n+  /* During LTO incremental linking we already have streamed in types.  */\n+  else if (odr_enum_map)\n+    {\n+      gcc_checking_assert (!odr_enums);\n+      streamer_write_uhwi (ob, odr_enum_map->elements ());\n+\n+      hash_map<nofree_string_hash, odr_enum>::iterator iter\n+\t\t= odr_enum_map->begin ();\n+      for (; iter != odr_enum_map->end (); ++iter)\n+\t{\n+\t  odr_enum &this_enum = (*iter).second;\n+\t  streamer_write_string (ob, ob->main_stream, (*iter).first, true);\n+\n+\t  streamer_write_uhwi (ob, this_enum.vals.length ());\n+\t  for (unsigned j = 0; j < this_enum.vals.length (); j++)\n+\t    {\n+\t      streamer_write_string (ob, ob->main_stream,\n+\t\t\t\t     this_enum.vals[j].name, true);\n+\t      streamer_write_hwi (ob, this_enum.vals[j].val);\n+\t    }\n+\n+\t  bitpack_d bp = bitpack_create (ob->main_stream);\n+\t  lto_output_location (ob, &bp, this_enum.locus);\n+\t  for (unsigned j = 0; j < this_enum.vals.length (); j++)\n+\t    lto_output_location (ob, &bp, this_enum.vals[j].locus);\n+\t  streamer_write_bitpack (&bp);\n+\t}\n+\n+      delete odr_enum_map;\n+      obstack_free (&odr_enum_obstack, NULL);\n+      odr_enum_map = NULL;\n+    }\n+\n+  produce_asm (ob, NULL);\n+  destroy_output_block (ob);\n+}\n+\n+/* Write ODR enums from LTO stream file and warn on mismatches.  */\n+\n+static void\n+ipa_odr_read_section (struct lto_file_decl_data *file_data, const char *data,\n+\t\t      size_t len)\n+{\n+  const struct lto_function_header *header\n+    = (const struct lto_function_header *) data;\n+  const int cfg_offset = sizeof (struct lto_function_header);\n+  const int main_offset = cfg_offset + header->cfg_size;\n+  const int string_offset = main_offset + header->main_size;\n+  class data_in *data_in;\n+\n+  lto_input_block ib ((const char *) data + main_offset, header->main_size,\n+\t\t      file_data->mode_table);\n+\n+  data_in\n+    = lto_data_in_create (file_data, (const char *) data + string_offset,\n+\t\t\t  header->string_size, vNULL);\n+  unsigned int n = streamer_read_uhwi (&ib);\n+\n+  if (!odr_enum_map)\n+    {\n+      gcc_obstack_init (&odr_enum_obstack);\n+      odr_enum_map = new (hash_map <nofree_string_hash, odr_enum>);\n+    }\n+\n+  for (unsigned i = 0; i < n; i++)\n+    {\n+      const char *rname = streamer_read_string (data_in, &ib);\n+      unsigned int nvals = streamer_read_uhwi (&ib);\n+      char *name;\n+  \n+      obstack_grow (&odr_enum_obstack, rname, strlen (rname) + 1);\n+      name = XOBFINISH (&odr_enum_obstack, char *);\n+\n+      bool existed_p;\n+      class odr_enum &this_enum\n+\t\t = odr_enum_map->get_or_insert (xstrdup (name), &existed_p);\n+\n+      if (!existed_p)\n+\t{\n+\t  this_enum.vals.safe_grow_cleared (nvals);\n+\t  this_enum.warned = false;\n+\t  for (unsigned j = 0; j < nvals; j++)\n+\t    {\n+\t      const char *val_name = streamer_read_string (data_in, &ib);\n+\t      obstack_grow (&odr_enum_obstack, val_name, strlen (val_name) + 1);\n+\t      this_enum.vals[j].name = XOBFINISH (&odr_enum_obstack, char *);\n+\t      this_enum.vals[j].val = streamer_read_hwi (&ib);\n+\t    }\n+\t  bitpack_d bp = streamer_read_bitpack (&ib);\n+\t  stream_input_location (&this_enum.locus, &bp, data_in);\n+\t  for (unsigned j = 0; j < nvals; j++)\n+\t    stream_input_location (&this_enum.vals[j].locus, &bp, data_in);\n+\t  data_in->location_cache.apply_location_cache ();\n+\t}\n+      else\n+\t{\n+\t  int do_warning = -1;\n+\t  char *warn_name = NULL;\n+\t  HOST_WIDE_INT warn_value = 0;\n+\n+\t  for (unsigned j = 0; j < nvals; j++)\n+\t    {\n+\t      const char *id = streamer_read_string (data_in, &ib);\n+\t      HOST_WIDE_INT val = streamer_read_hwi (&ib);\n+\n+\t      if (do_warning != -1 || j > this_enum.vals.length ())\n+\t\tcontinue;\n+\t      if (strcmp (id, this_enum.vals[j].name)\n+\t\t  || val != this_enum.vals[j].val)\n+\t\t{\n+\t\t  warn_name = xstrdup (id);\n+\t\t  warn_value = val;\n+\t\t  do_warning = j;\n+\t\t}\n+\t    }\n+\t  bitpack_d bp = streamer_read_bitpack (&ib);\n+\n+\t  location_t locus;\n+\t  stream_input_location (&locus, &bp, data_in);\n+\n+\t  if (do_warning != -1 || nvals != this_enum.vals.length ())\n+\t    {\n+\t      data_in->location_cache.apply_location_cache ();\n+\n+\t      const int opts = DMGL_PARAMS | DMGL_ANSI | DMGL_TYPES;\n+\t      char *dmgname = cplus_demangle (name, opts);\n+\t      if (this_enum.warned\n+\t\t  || !warning_at (this_enum.locus,\n+\t\t\t\t  OPT_Wodr, \"type %qs violates the \"\n+\t\t\t\t  \"C++ One Definition Rule\",\n+\t\t\t\t  dmgname))\n+\t\tdo_warning = -1;\n+\t      else\n+\t       {\n+\t\t this_enum.warned = true;\n+\t\t if (do_warning == -1)\n+\t\t   inform (locus,\n+\t\t\t   \"an enum with different number of values is defined\"\n+\t\t\t   \" in another translation unit\");\n+\t\t else if (warn_name)\n+\t\t   inform (locus,\n+\t\t\t   \"an enum with different value name\"\n+\t\t\t   \" is defined in another translation unit\");\n+\t\t else\n+\t\t   inform (locus,\n+\t\t\t   \"an enum with different values\"\n+\t\t\t   \" is defined in another translation unit\");\n+\t       }\n+\t    }\n+\t  else\n+\t    data_in->location_cache.revert_location_cache ();\n+\t  for (unsigned j = 0; j < nvals; j++)\n+\t    {\n+\t      location_t id_locus;\n+\n+\t      data_in->location_cache.revert_location_cache ();\n+\t      stream_input_location (&id_locus, &bp, data_in);\n+\t      if ((int) j == do_warning)\n+\t\t{\n+\t\t  data_in->location_cache.apply_location_cache ();\n+\t\t  if (strcmp (warn_name, this_enum.vals[j].name))\n+\t\t    inform (this_enum.vals[j].locus,\n+\t\t\t    \"name %qs differs from name %qs defined\"\n+\t\t\t    \" in another translation unit\",\n+\t\t\t    this_enum.vals[j].name, warn_name);\n+\t\t  else\n+\t\t    inform (this_enum.vals[j].locus,\n+\t\t\t    \"name %qs is defined to \" HOST_WIDE_INT_PRINT_DEC\n+\t\t\t    \" while another translation unit defines \"\n+\t\t\t    \"it as \" HOST_WIDE_INT_PRINT_DEC,\n+\t\t\t    warn_name, this_enum.vals[j].val, warn_value);\n+\t\t  inform (id_locus,\n+\t\t\t  \"mismatching definition\");\n+\t\t}\n+\t      else\n+\t        data_in->location_cache.revert_location_cache ();\n+\t    }\n+\t  if (warn_name)\n+\t    free (warn_name);\n+\t  obstack_free (&odr_enum_obstack, name);\n+\t}\n+    }\n+  lto_free_section_data (file_data, LTO_section_ipa_fn_summary, NULL, data,\n+\t\t\t len);\n+  lto_data_in_delete (data_in);\n+}\n+\n+/* Read all ODR type sections.  */\n+\n+static void\n+ipa_odr_summary_read (void)\n+{\n+  struct lto_file_decl_data **file_data_vec = lto_get_file_decl_data ();\n+  struct lto_file_decl_data *file_data;\n+  unsigned int j = 0;\n+\n+  while ((file_data = file_data_vec[j++]))\n+    {\n+      size_t len;\n+      const char *data\n+\t= lto_get_summary_section_data (file_data, LTO_section_odr_types,\n+\t\t\t\t\t&len);\n+      if (data)\n+\tipa_odr_read_section (file_data, data, len);\n+    }\n+  /* Enum info is used only to produce warnings.  Only case we will need it\n+     again is streaming for incremental LTO.  */\n+  if (flag_incremental_link != INCREMENTAL_LINK_LTO)\n+    {\n+      delete odr_enum_map;\n+      obstack_free (&odr_enum_obstack, NULL);\n+      odr_enum_map = NULL;\n+    }\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_ipa_odr =\n+{\n+  IPA_PASS, /* type */\n+  \"odr\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_IPA_ODR, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_ipa_odr : public ipa_opt_pass_d\n+{\n+public:\n+  pass_ipa_odr (gcc::context *ctxt)\n+    : ipa_opt_pass_d (pass_data_ipa_odr, ctxt,\n+\t\t      NULL, /* generate_summary */\n+\t\t      ipa_odr_summary_write, /* write_summary */\n+\t\t      ipa_odr_summary_read, /* read_summary */\n+\t\t      NULL, /* write_optimization_summary */\n+\t\t      NULL, /* read_optimization_summary */\n+\t\t      NULL, /* stmt_fixup */\n+\t\t      0, /* function_transform_todo_flags_start */\n+\t\t      NULL, /* function_transform */\n+\t\t      NULL) /* variable_transform */\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *)\n+    {\n+      return (in_lto_p || flag_lto);\n+    }\n+\n+  virtual unsigned int execute (function *)\n+    {\n+      return 0;\n+    }\n+\n+}; // class pass_ipa_odr\n+\n+} // anon namespace\n+\n+ipa_opt_pass_d *\n+make_pass_ipa_odr (gcc::context *ctxt)\n+{\n+  return new pass_ipa_odr (ctxt);\n+}\n+\n+\n #include \"gt-ipa-devirt.h\""}, {"sha": "178c2cbe446f80cf5cd9a77f938f03f185ecbbf4", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=3fb68f2e666d9de7e0326af9f43b12c9e98f19a6", "patch": "@@ -98,6 +98,8 @@ void enable_odr_based_tbaa (tree type);\n bool odr_based_tbaa_p (const_tree type);\n void set_type_canonical_for_odr_type (tree type, tree canonical);\n \n+void register_odr_enum (tree type);\n+\n /* Return vector containing possible targets of polymorphic call E.\n    If COMPLETEP is non-NULL, store true if the list is complete. \n    CACHE_TOKEN (if non-NULL) will get stored to an unique ID of entry"}, {"sha": "48cf4844b6326a06443e154a19ec55c7f98eca74", "filename": "gcc/lto-section-in.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6/gcc%2Flto-section-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6/gcc%2Flto-section-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-in.c?ref=3fb68f2e666d9de7e0326af9f43b12c9e98f19a6", "patch": "@@ -55,7 +55,8 @@ const char *lto_section_name[LTO_N_SECTION_TYPES] =\n   \"mode_table\",\n   \"hsa\",\n   \"lto\",\n-  \"ipa_sra\"\n+  \"ipa_sra\",\n+  \"odr_types\",\n };\n \n /* Hooks so that the ipa passes can call into the lto front end to get"}, {"sha": "059688821ccc04b35f95699f3040a830c7fcdbbf", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=3fb68f2e666d9de7e0326af9f43b12c9e98f19a6", "patch": "@@ -1000,9 +1000,7 @@ DFS::DFS_write_tree_body (struct output_block *ob,\n \n   if (CODE_CONTAINS_STRUCT (code, TS_TYPE_NON_COMMON))\n     {\n-      if (TREE_CODE (expr) == ENUMERAL_TYPE)\n-\tDFS_follow_tree_edge (TYPE_VALUES (expr));\n-      else if (TREE_CODE (expr) == ARRAY_TYPE)\n+      if (TREE_CODE (expr) == ARRAY_TYPE)\n \tDFS_follow_tree_edge (TYPE_DOMAIN (expr));\n       else if (RECORD_OR_UNION_TYPE_P (expr))\n \tfor (tree t = TYPE_FIELDS (expr); t; t = TREE_CHAIN (t))\n@@ -1413,9 +1411,7 @@ hash_tree (struct streamer_tree_cache_d *cache, hash_map<tree, hashval_t> *map,\n \n   if (CODE_CONTAINS_STRUCT (code, TS_TYPE_NON_COMMON))\n     {\n-      if (code == ENUMERAL_TYPE)\n-\tvisit (TYPE_VALUES (t));\n-      else if (code == ARRAY_TYPE)\n+      if (code == ARRAY_TYPE)\n \tvisit (TYPE_DOMAIN (t));\n       else if (RECORD_OR_UNION_TYPE_P (t))\n \tfor (tree f = TYPE_FIELDS (t); f; f = TREE_CHAIN (f))"}, {"sha": "b17137f0f9a80a30aa16b4ede4ccd667dd4516a9", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=3fb68f2e666d9de7e0326af9f43b12c9e98f19a6", "patch": "@@ -227,6 +227,7 @@ enum lto_section_type\n   LTO_section_ipa_hsa,\n   LTO_section_lto,\n   LTO_section_ipa_sra,\n+  LTO_section_odr_types,\n   LTO_N_SECTION_TYPES\t\t/* Must be last.  */\n };\n "}, {"sha": "86d8851dac74e6e444bbe2cd0a41a4153c4e6da1", "filename": "gcc/lto/lto-common.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6/gcc%2Flto%2Flto-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6/gcc%2Flto%2Flto-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-common.c?ref=3fb68f2e666d9de7e0326af9f43b12c9e98f19a6", "patch": "@@ -1503,9 +1503,7 @@ compare_tree_sccs_1 (tree t1, tree t2, tree **map)\n \n   if (CODE_CONTAINS_STRUCT (code, TS_TYPE_NON_COMMON))\n     {\n-      if (code == ENUMERAL_TYPE)\n-\tcompare_tree_edges (TYPE_VALUES (t1), TYPE_VALUES (t2));\n-      else if (code == ARRAY_TYPE)\n+      if (code == ARRAY_TYPE)\n \tcompare_tree_edges (TYPE_DOMAIN (t1), TYPE_DOMAIN (t2));\n       else if (RECORD_OR_UNION_TYPE_P (t1))\n \t{"}, {"sha": "56322025226d4153dee0f169f8acbdef219e1852", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=3fb68f2e666d9de7e0326af9f43b12c9e98f19a6", "patch": "@@ -145,6 +145,7 @@ along with GCC; see the file COPYING3.  If not see\n \n   INSERT_PASSES_AFTER (all_regular_ipa_passes)\n   NEXT_PASS (pass_analyzer);\n+  NEXT_PASS (pass_ipa_odr);\n   NEXT_PASS (pass_ipa_whole_program_visibility);\n   NEXT_PASS (pass_ipa_profile);\n   NEXT_PASS (pass_ipa_icf);"}, {"sha": "1509eae4845e8f216b3d460547d4f2f75fd4c35e", "filename": "gcc/testsuite/g++.dg/lto/pr84805_0.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr84805_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr84805_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr84805_0.C?ref=3fb68f2e666d9de7e0326af9f43b12c9e98f19a6", "patch": "@@ -11,7 +11,7 @@ struct __is_void_helper : false_type {};\n struct is_void : __is_void_helper {};\n template < typename > struct is_array : false_type {};\n namespace __gnu_cxx {\n-enum _Lock_policy { _S_single, _S_mutex, _S_atomic }; // { dg-lto-warning \"6: type '_Lock_policy' violates the C\\\\+\\\\+ One Definition Rule\" }\n+enum _Lock_policy { _S_single, _S_mutex, _S_atomic }; // { dg-lto-warning \"6: type '__gnu_cxx::_Lock_policy' violates the C\\\\+\\\\+ One Definition Rule\" }\n const _Lock_policy __default_lock_policy = _S_atomic;\n } namespace std {\n using __gnu_cxx::_Lock_policy;"}, {"sha": "29479205c417b1f576273e02da8cdda2874549d4", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=3fb68f2e666d9de7e0326af9f43b12c9e98f19a6", "patch": "@@ -70,6 +70,7 @@ DEFTIMEVAR (TV_CGRAPH                , \"callgraph construction\")\n DEFTIMEVAR (TV_CGRAPHOPT             , \"callgraph optimization\")\n DEFTIMEVAR (TV_CGRAPH_FUNC_EXPANSION , \"callgraph functions expansion\")\n DEFTIMEVAR (TV_CGRAPH_IPA_PASSES     , \"callgraph ipa passes\")\n+DEFTIMEVAR (TV_IPA_ODR\t\t     , \"ipa ODR types\")\n DEFTIMEVAR (TV_IPA_FNSUMMARY         , \"ipa function summary\")\n DEFTIMEVAR (TV_IPA_UNREACHABLE       , \"ipa dead code removal\")\n DEFTIMEVAR (TV_IPA_INHERITANCE       , \"ipa inheritance graph\")"}, {"sha": "396428f167ff3ad465610234d8305f6a7e13157c", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=3fb68f2e666d9de7e0326af9f43b12c9e98f19a6", "patch": "@@ -506,6 +506,7 @@ extern ipa_opt_pass_d *make_pass_ipa_cp (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_sra (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_icf (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_devirt (gcc::context *ctxt);\n+extern ipa_opt_pass_d *make_pass_ipa_odr (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_reference (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_hsa (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_pure_const (gcc::context *ctxt);"}, {"sha": "707a0591bfeadc7641a603891aee1ac589c865c3", "filename": "gcc/tree-streamer-in.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=3fb68f2e666d9de7e0326af9f43b12c9e98f19a6", "patch": "@@ -843,9 +843,7 @@ lto_input_ts_type_non_common_tree_pointers (class lto_input_block *ib,\n \t\t\t\t\t    class data_in *data_in,\n \t\t\t\t\t    tree expr)\n {\n-  if (TREE_CODE (expr) == ENUMERAL_TYPE)\n-    TYPE_VALUES (expr) = stream_read_tree_ref (ib, data_in);\n-  else if (TREE_CODE (expr) == ARRAY_TYPE)\n+  if (TREE_CODE (expr) == ARRAY_TYPE)\n     TYPE_DOMAIN (expr) = stream_read_tree_ref (ib, data_in);\n   else if (RECORD_OR_UNION_TYPE_P (expr))\n     TYPE_FIELDS (expr) = streamer_read_chain (ib, data_in);"}, {"sha": "d7a451cfef4c01fe531bdc504c179b136ece40f2", "filename": "gcc/tree-streamer-out.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6/gcc%2Ftree-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6/gcc%2Ftree-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.c?ref=3fb68f2e666d9de7e0326af9f43b12c9e98f19a6", "patch": "@@ -724,9 +724,7 @@ write_ts_type_common_tree_pointers (struct output_block *ob, tree expr)\n static void\n write_ts_type_non_common_tree_pointers (struct output_block *ob, tree expr)\n {\n-  if (TREE_CODE (expr) == ENUMERAL_TYPE)\n-    stream_write_tree_ref (ob, TYPE_VALUES (expr));\n-  else if (TREE_CODE (expr) == ARRAY_TYPE)\n+  if (TREE_CODE (expr) == ARRAY_TYPE)\n     stream_write_tree_ref (ob, TYPE_DOMAIN (expr));\n   else if (RECORD_OR_UNION_TYPE_P (expr))\n     streamer_write_chain (ob, TYPE_FIELDS (expr));"}, {"sha": "7197b4720ce9a1815ef3e7742b84f62d3577df84", "filename": "gcc/tree.c", "status": "modified", "additions": 6, "deletions": 27, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb68f2e666d9de7e0326af9f43b12c9e98f19a6/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=3fb68f2e666d9de7e0326af9f43b12c9e98f19a6", "patch": "@@ -5556,40 +5556,19 @@ free_lang_data_in_type (tree type, class free_lang_data_d *fld)\n     {\n       if (TREE_CODE (type) == ENUMERAL_TYPE)\n \t{\n-\t  tree it = NULL_TREE;\n \t  ENUM_IS_OPAQUE (type) = 0;\n \t  ENUM_IS_SCOPED (type) = 0;\n \t  /* Type values are used only for C++ ODR checking.  Drop them\n \t     for all type variants and non-ODR types.\n \t     For ODR types the data is freed in free_odr_warning_data.  */\n-\t  if (TYPE_MAIN_VARIANT (type) != type\n-\t      || !type_with_linkage_p (type))\n+\t  if (!TYPE_VALUES (type))\n+\t    ;\n+\t  else if (TYPE_MAIN_VARIANT (type) != type\n+\t\t   || !type_with_linkage_p (type)\n+\t\t   || type_in_anonymous_namespace_p (type))\n \t    TYPE_VALUES (type) = NULL;\n \t  else\n-\t  /* Simplify representation by recording only values rather\n-\t     than const decls.  */\n-\t    for (tree e = TYPE_VALUES (type); e; e = TREE_CHAIN (e))\n-\t      {\n-\t\tif (TREE_CODE (TREE_VALUE (e)) == CONST_DECL)\n-\t\t  {\n-\t\t    TREE_VALUE (e) = DECL_INITIAL (TREE_VALUE (e));\n-\t\t    /* We can not stream values whose TREE_TYPE is type itself\n-\t\t       because that would create non-trivial CSS.  Canonicalize\n-\t\t       them to integer types.  */\n-\t\t  }\n-\t\t/* Some frontends use ENUMERAL_TYPE to represent the constants.\n-\t\t   This leads to nontrivial SCC components containing\n-\t\t   INTEGER_CST which is not good for streaming.  Convert them\n-\t\t   all to corresponding integer type.  */\n-\t\tif (TREE_CODE (TREE_TYPE (TREE_VALUE (e))) != INTEGER_TYPE)\n-\t\t  {\n-\t\t    if (!it)\n-\t\t      it = lang_hooks.types.type_for_size\n-\t\t\t       (TYPE_PRECISION (TREE_TYPE (TREE_VALUE (e))),\n-\t\t\t\tTYPE_UNSIGNED (TREE_TYPE (TREE_VALUE (e))));\n-\t\t    TREE_VALUE (e) = fold_convert (it, TREE_VALUE (e));\n-\t\t  }\n-\t       }\n+\t    register_odr_enum (type);\n \t}\n       free_lang_data_in_one_sizepos (&TYPE_MIN_VALUE (type));\n       free_lang_data_in_one_sizepos (&TYPE_MAX_VALUE (type));"}]}