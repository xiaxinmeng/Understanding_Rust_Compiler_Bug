{"sha": "3ddfabe34fbcf04822c794f1dc8e1740811ad016", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RkZmFiZTM0ZmJjZjA0ODIyYzc5NGYxZGM4ZTE3NDA4MTFhZDAxNg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-06-20T12:22:09Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-06-20T12:22:09Z"}, "message": "[multiple changes]\n\n2016-06-16  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* atree.ads, atree.adb (Elist29): New routine.\n\t(Set_Elist29): New routine.\n\t* atree.h New definition for Elist29.\n\t* einfo.adb Subprograms_For_Type is now an Elist rather than\n\ta node. Has_Invariants is now a synthesized attribute\n\tand does not require a flag. Has_Own_Invariants\n\tis now Flag232. Has_Inherited_Invariants is\n\tFlag291. Is_Partial_Invariant_Procedure is Flag292.\n\t(Default_Init_Cond_Procedure): Reimplemented.\n\t(Has_Inherited_Invariants): New routine.\n\t(Has_Invariants): Reimplemented.\n\t(Has_Own_Invariants): New routine.\n\t(Invariant_Procedure): Reimplemented.\n\t(Is_Partial_Invariant_Procedure): New routine.\n\t(Partial_Invariant_Procedure): Reimplemented.\n\t(Predicate_Function): Reimplemented.\n\t(Predicate_Function_M): Reimplemented.\n\t(Set_Default_Init_Cond_Procedure): Reimplemented.\n\t(Set_Has_Inherited_Invariants): New routine.\n\t(Set_Has_Invariants): Removed.\n\t(Set_Has_Own_Invariants): New routine.\n\t(Set_Invariant_Procedure): Reimplemented.\n\t(Set_Is_Partial_Invariant_Procedure): New routine.\n\t(Set_Partial_Invariant_Procedure): Reimplemented.\n\t(Set_Predicate_Function): Reimplemented.\n\t(Set_Predicate_Function_M): Reimplemented.\n\t(Set_Subprograms_For_Type): Reimplemented.\n\t(Subprograms_For_Type): Reimplemented.\n\t(Write_Entity_Flags): Output Flag232 and Flag291.\n\t* einfo.ads Add new attributes Has_Inherited_Invariants\n\tHas_Own_Invariants Is_Partial_Invariant_Procedure\n\tPartial_Invariant_Procedure Change the documentation\n\tof attributes Has_Inheritable_Invariants Has_Invariants\n\tInvariant_Procedure Is_Invariant_Procedure Subprograms_For_Type\n\t(Has_Inherited_Invariants): New routine along with pragma Inline.\n\t(Has_Own_Invariants): New routine along with pragma Inline.\n\t(Is_Partial_Invariant_Procedure): New routine along with pragma Inline.\n\t(Partial_Invariant_Procedure): New routine.\n\t(Set_Has_Inherited_Invariants): New routine along with pragma Inline.\n\t(Set_Has_Invariants): Removed along with pragma Inline.\n\t(Set_Has_Own_Invariants): New routine along with pragma Inline.\n\t(Set_Is_Partial_Invariant_Procedure): New routine\n\talong with pragma Inline.\n\t(Set_Partial_Invariant_Procedure): New routine.\n\t(Set_Subprograms_For_Type): Update the signature.\n\t(Subprograms_For_Type): Update the signature.\n\t* exp_ch3.adb Remove with and use clauses for Sem_Ch13.\n\t(Build_Array_Invariant_Proc): Removed.\n\t(Build_Record_Invariant_Proc): Removed.\n\t(Freeze_Type): Build the body of the invariant procedure.\n\t(Insert_Component_Invariant_Checks): Removed.\n\t* exp_ch7.adb Add with and use clauses for Sem_Ch6, Sem_Ch13,\n\tand Stringt.\n\t(Build_Invariant_Procedure_Body): New routine.\n\t(Build_Invariant_Procedure_Declaration): New routine.\n\t* exp_ch7.ads (Build_Invariant_Procedure_Body): New routine.\n\t(Build_Invariant_Procedure_Declaration): New routine.\n\t* exp_ch9.adb (Build_Corresponding_Record): Do not propagate\n\tattributes related to invariants to the corresponding record\n\twhen building the corresponding record. This is done by\n\tBuild_Invariant_Procedure_Declaration.\n\t* exp_util.adb (Make_Invariant_Call): Reimplemented.\n\t* freeze.adb (Freeze_Array_Type): An array type requires an\n\tinvariant procedure when its component type has invariants.\n\t(Freeze_Record_Type): A record type requires an invariant\n\tprocedure when at least one of its components has an invariant.\n\t* sem_ch3.adb (Analyze_Private_Extension_Declaration): Inherit\n\tinvariant-related attributes.\n\t(Analyze_Subtype_Declaration):\n\tInherit invariant-related attributes.\n\t(Build_Derived_Record_Type): Inherit invariant-related attributes.\n\t(Check_Duplicate_Aspects): Reimplemented.\n\t(Get_Partial_View_Aspect): New routine.\n\t(Process_Full_View): Inherit invariant-related attributes. Reimplement\n\tthe check on hidden inheritance of class-wide invariants.\n\t(Remove_Default_Init_Cond_Procedure): Reimplemented.\n\t* sem_ch6.adb (Analyze_Subprogram_Specification): Do not modify\n\tthe controlling type for an invariant procedure declaration\n\tor body.\n\t(Is_Invariant_Procedure_Or_Body): New routine.\n\t* sem_ch7.adb (Analyze_Package_Specification): Build the partial\n\tinvariant body in order to preanalyze and resolve all invariants\n\tof a private type at the end of the visible declarations. Build\n\tthe full invariant body in order to preanalyze and resolve\n\tall invariants of a private type's full view at the end of\n\tthe private declarations.\n\t(Preserve_Full_Attributes): Inherit invariant-related attributes.\n\t* sem_ch9.adb (Analyze_Protected_Type_Declaration): Ensure that\n\taspects are analyzed with the proper view when the protected type\n\tis a completion of a private type. Inherit invariant-related attributes.\n\t(Analyze_Task_Type_Declaration): Ensure that\n\taspects are analyzed with the proper view when the task type\n\tis a completion of a private type. Inherit invariant-related\n\tattributes.\n\t* sem_ch13.adb Remove with and use clauses for Stringt.\n\t(Build_Invariant_Procedure_Declaration): Removed.\n\t(Build_Invariant_Procedure): Removed.\n\t(Freeze_Entity_Checks): Do not build the body of the invariant\n\tprocedure here.\n\tThe body is built when the type is frozen in Freeze_Type.\n\t(Inherit_Aspects_At_Freeze_Point): Do not inherit any attributes\n\trelated to invariants here because this leads to erroneous\n\tinheritance.\n\t(Replace_Node): Rename to Replace_Type_Ref.\n\t* sem_ch13.ads (Build_Invariant_Procedure_Declaration): Removed.\n\t(Build_Invariant_Procedure): Removed.\n\t* sem_prag.adb Add with and use clauses for Exp_Ch7.\n\t(Analyze_Pragma): Reimplement the analysis of pragma Invariant.\n\t* sem_res.adb (Resolve_Actuals): Emit a specialized error when\n\tthe context is an invariant.\n\t* sem_util.adb (Get_Views): New routine.\n\t(Incomplete_Or_Partial_View): Consider generic packages when\n\texamining declarations.\n\t(Inspect_Decls): Consider full type\n\tdeclarations because they may denote a derivation from a\n\tprivate type.\n\t(Propagate_Invariant_Attributes): New routine.\n\t* sem_util.ads (Get_Views): New routine.\n\t(Propagate_Invariant_Attributes): New routine.\n\n2016-06-16  Arnaud Charlet  <charlet@adacore.com>\n\n\t* pprint.adb (Expression_Image): Add better handling of UCs,\n\twe don't want to strip them all for clarity.\n\nFrom-SVN: r237596", "tree": {"sha": "f64553974385489d1482a336810f4c521ae2bf35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f64553974385489d1482a336810f4c521ae2bf35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ddfabe34fbcf04822c794f1dc8e1740811ad016", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ddfabe34fbcf04822c794f1dc8e1740811ad016", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ddfabe34fbcf04822c794f1dc8e1740811ad016", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ddfabe34fbcf04822c794f1dc8e1740811ad016/comments", "author": null, "committer": null, "parents": [{"sha": "1db6c46d4d1d3d8b731b2c697f3aea7e47f7ed0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1db6c46d4d1d3d8b731b2c697f3aea7e47f7ed0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1db6c46d4d1d3d8b731b2c697f3aea7e47f7ed0d"}], "stats": {"total": 4387, "additions": 2750, "deletions": 1637}, "files": [{"sha": "9845111ed2bfb1c38d005bac06a4e972ab43658e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3ddfabe34fbcf04822c794f1dc8e1740811ad016", "patch": "@@ -1,3 +1,131 @@\n+2016-06-16  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* atree.ads, atree.adb (Elist29): New routine.\n+\t(Set_Elist29): New routine.\n+\t* atree.h New definition for Elist29.\n+\t* einfo.adb Subprograms_For_Type is now an Elist rather than\n+\ta node. Has_Invariants is now a synthesized attribute\n+\tand does not require a flag. Has_Own_Invariants\n+\tis now Flag232. Has_Inherited_Invariants is\n+\tFlag291. Is_Partial_Invariant_Procedure is Flag292.\n+\t(Default_Init_Cond_Procedure): Reimplemented.\n+\t(Has_Inherited_Invariants): New routine.\n+\t(Has_Invariants): Reimplemented.\n+\t(Has_Own_Invariants): New routine.\n+\t(Invariant_Procedure): Reimplemented.\n+\t(Is_Partial_Invariant_Procedure): New routine.\n+\t(Partial_Invariant_Procedure): Reimplemented.\n+\t(Predicate_Function): Reimplemented.\n+\t(Predicate_Function_M): Reimplemented.\n+\t(Set_Default_Init_Cond_Procedure): Reimplemented.\n+\t(Set_Has_Inherited_Invariants): New routine.\n+\t(Set_Has_Invariants): Removed.\n+\t(Set_Has_Own_Invariants): New routine.\n+\t(Set_Invariant_Procedure): Reimplemented.\n+\t(Set_Is_Partial_Invariant_Procedure): New routine.\n+\t(Set_Partial_Invariant_Procedure): Reimplemented.\n+\t(Set_Predicate_Function): Reimplemented.\n+\t(Set_Predicate_Function_M): Reimplemented.\n+\t(Set_Subprograms_For_Type): Reimplemented.\n+\t(Subprograms_For_Type): Reimplemented.\n+\t(Write_Entity_Flags): Output Flag232 and Flag291.\n+\t* einfo.ads Add new attributes Has_Inherited_Invariants\n+\tHas_Own_Invariants Is_Partial_Invariant_Procedure\n+\tPartial_Invariant_Procedure Change the documentation\n+\tof attributes Has_Inheritable_Invariants Has_Invariants\n+\tInvariant_Procedure Is_Invariant_Procedure Subprograms_For_Type\n+\t(Has_Inherited_Invariants): New routine along with pragma Inline.\n+\t(Has_Own_Invariants): New routine along with pragma Inline.\n+\t(Is_Partial_Invariant_Procedure): New routine along with pragma Inline.\n+\t(Partial_Invariant_Procedure): New routine.\n+\t(Set_Has_Inherited_Invariants): New routine along with pragma Inline.\n+\t(Set_Has_Invariants): Removed along with pragma Inline.\n+\t(Set_Has_Own_Invariants): New routine along with pragma Inline.\n+\t(Set_Is_Partial_Invariant_Procedure): New routine\n+\talong with pragma Inline.\n+\t(Set_Partial_Invariant_Procedure): New routine.\n+\t(Set_Subprograms_For_Type): Update the signature.\n+\t(Subprograms_For_Type): Update the signature.\n+\t* exp_ch3.adb Remove with and use clauses for Sem_Ch13.\n+\t(Build_Array_Invariant_Proc): Removed.\n+\t(Build_Record_Invariant_Proc): Removed.\n+\t(Freeze_Type): Build the body of the invariant procedure.\n+\t(Insert_Component_Invariant_Checks): Removed.\n+\t* exp_ch7.adb Add with and use clauses for Sem_Ch6, Sem_Ch13,\n+\tand Stringt.\n+\t(Build_Invariant_Procedure_Body): New routine.\n+\t(Build_Invariant_Procedure_Declaration): New routine.\n+\t* exp_ch7.ads (Build_Invariant_Procedure_Body): New routine.\n+\t(Build_Invariant_Procedure_Declaration): New routine.\n+\t* exp_ch9.adb (Build_Corresponding_Record): Do not propagate\n+\tattributes related to invariants to the corresponding record\n+\twhen building the corresponding record. This is done by\n+\tBuild_Invariant_Procedure_Declaration.\n+\t* exp_util.adb (Make_Invariant_Call): Reimplemented.\n+\t* freeze.adb (Freeze_Array_Type): An array type requires an\n+\tinvariant procedure when its component type has invariants.\n+\t(Freeze_Record_Type): A record type requires an invariant\n+\tprocedure when at least one of its components has an invariant.\n+\t* sem_ch3.adb (Analyze_Private_Extension_Declaration): Inherit\n+\tinvariant-related attributes.\n+\t(Analyze_Subtype_Declaration):\n+\tInherit invariant-related attributes.\n+\t(Build_Derived_Record_Type): Inherit invariant-related attributes.\n+\t(Check_Duplicate_Aspects): Reimplemented.\n+\t(Get_Partial_View_Aspect): New routine.\n+\t(Process_Full_View): Inherit invariant-related attributes. Reimplement\n+\tthe check on hidden inheritance of class-wide invariants.\n+\t(Remove_Default_Init_Cond_Procedure): Reimplemented.\n+\t* sem_ch6.adb (Analyze_Subprogram_Specification): Do not modify\n+\tthe controlling type for an invariant procedure declaration\n+\tor body.\n+\t(Is_Invariant_Procedure_Or_Body): New routine.\n+\t* sem_ch7.adb (Analyze_Package_Specification): Build the partial\n+\tinvariant body in order to preanalyze and resolve all invariants\n+\tof a private type at the end of the visible declarations. Build\n+\tthe full invariant body in order to preanalyze and resolve\n+\tall invariants of a private type's full view at the end of\n+\tthe private declarations.\n+\t(Preserve_Full_Attributes): Inherit invariant-related attributes.\n+\t* sem_ch9.adb (Analyze_Protected_Type_Declaration): Ensure that\n+\taspects are analyzed with the proper view when the protected type\n+\tis a completion of a private type. Inherit invariant-related attributes.\n+\t(Analyze_Task_Type_Declaration): Ensure that\n+\taspects are analyzed with the proper view when the task type\n+\tis a completion of a private type. Inherit invariant-related\n+\tattributes.\n+\t* sem_ch13.adb Remove with and use clauses for Stringt.\n+\t(Build_Invariant_Procedure_Declaration): Removed.\n+\t(Build_Invariant_Procedure): Removed.\n+\t(Freeze_Entity_Checks): Do not build the body of the invariant\n+\tprocedure here.\n+\tThe body is built when the type is frozen in Freeze_Type.\n+\t(Inherit_Aspects_At_Freeze_Point): Do not inherit any attributes\n+\trelated to invariants here because this leads to erroneous\n+\tinheritance.\n+\t(Replace_Node): Rename to Replace_Type_Ref.\n+\t* sem_ch13.ads (Build_Invariant_Procedure_Declaration): Removed.\n+\t(Build_Invariant_Procedure): Removed.\n+\t* sem_prag.adb Add with and use clauses for Exp_Ch7.\n+\t(Analyze_Pragma): Reimplement the analysis of pragma Invariant.\n+\t* sem_res.adb (Resolve_Actuals): Emit a specialized error when\n+\tthe context is an invariant.\n+\t* sem_util.adb (Get_Views): New routine.\n+\t(Incomplete_Or_Partial_View): Consider generic packages when\n+\texamining declarations.\n+\t(Inspect_Decls): Consider full type\n+\tdeclarations because they may denote a derivation from a\n+\tprivate type.\n+\t(Propagate_Invariant_Attributes): New routine.\n+\t* sem_util.ads (Get_Views): New routine.\n+\t(Propagate_Invariant_Attributes): New routine.\n+\n+2016-06-16  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* pprint.adb (Expression_Image): Add better handling of UCs,\n+\twe don't want to strip them all for clarity.\n+\n+\n 2016-06-20  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* exp_util.adb (Safe_Unchecked_Type_Conversion): Use \"alignment\""}, {"sha": "87ef79fdeec14c2b91a1b1af594597b89eecfb9a", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=3ddfabe34fbcf04822c794f1dc8e1740811ad016", "patch": "@@ -3317,6 +3317,17 @@ package body Atree is\n          end if;\n       end Elist26;\n \n+      function Elist29 (N : Node_Id) return Elist_Id is\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Value : constant Union_Id := Nodes.Table (N + 4).Field11;\n+      begin\n+         if Value = 0 then\n+            return No_Elist;\n+         else\n+            return Elist_Id (Value);\n+         end if;\n+      end Elist29;\n+\n       function Elist36 (N : Node_Id) return Elist_Id is\n          pragma Assert (Nkind (N) in N_Entity);\n          Value : constant Union_Id := Nodes.Table (N + 6).Field6;\n@@ -6109,6 +6120,12 @@ package body Atree is\n          Nodes.Table (N + 4).Field8 := Union_Id (Val);\n       end Set_Elist26;\n \n+      procedure Set_Elist29 (N : Node_Id; Val : Elist_Id) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 4).Field11 := Union_Id (Val);\n+      end Set_Elist29;\n+\n       procedure Set_Elist36 (N : Node_Id; Val : Elist_Id) is\n       begin\n          pragma Assert (Nkind (N) in N_Entity);"}, {"sha": "2d911b23b7f53c808b57da1af660ce05d9f2df29", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=3ddfabe34fbcf04822c794f1dc8e1740811ad016", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1473,6 +1473,9 @@ package Atree is\n       function Elist26 (N : Node_Id) return Elist_Id;\n       pragma Inline (Elist26);\n \n+      function Elist29 (N : Node_Id) return Elist_Id;\n+      pragma Inline (Elist29);\n+\n       function Elist36 (N : Node_Id) return Elist_Id;\n       pragma Inline (Elist36);\n \n@@ -2836,6 +2839,9 @@ package Atree is\n       procedure Set_Elist26 (N : Node_Id; Val : Elist_Id);\n       pragma Inline (Set_Elist26);\n \n+      procedure Set_Elist29 (N : Node_Id; Val : Elist_Id);\n+      pragma Inline (Set_Elist29);\n+\n       procedure Set_Elist36 (N : Node_Id; Val : Elist_Id);\n       pragma Inline (Set_Elist36);\n "}, {"sha": "e09f7e2c9fece69ae200a6fd2b3ab951ab95c323", "filename": "gcc/ada/atree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fatree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fatree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.h?ref=3ddfabe34fbcf04822c794f1dc8e1740811ad016", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2015, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2016, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -526,6 +526,7 @@ extern Node_Id Current_Error_Node;\n #define Elist24(N)    Field24 (N)\n #define Elist25(N)    Field25 (N)\n #define Elist26(N)    Field26 (N)\n+#define Elist29(N)    Field29 (N)\n #define Elist36(N)    Field36 (N)\n \n #define Name1(N)      Field1  (N)"}, {"sha": "6fa9f9a4fdbd0443ff70e54a8fba193f9b8ffd71", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 292, "deletions": 119, "changes": 411, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=3ddfabe34fbcf04822c794f1dc8e1740811ad016", "patch": "@@ -245,7 +245,7 @@ package body Einfo is\n    --    Underlying_Record_View          Node28\n \n    --    BIP_Initialization_Call         Node29\n-   --    Subprograms_For_Type            Node29\n+   --    Subprograms_For_Type            Elist29\n \n    --    Anonymous_Object                Node30\n    --    Corresponding_Equality          Node30\n@@ -539,7 +539,7 @@ package body Einfo is\n    --    Has_Pragma_Inline_Always        Flag230\n \n    --    Renamed_In_Spec                 Flag231\n-   --    Has_Invariants                  Flag232\n+   --    Has_Own_Invariants              Flag232\n    --    Has_Pragma_Unmodified           Flag233\n    --    Is_Dispatch_Table_Entity        Flag234\n    --    Is_Trivial_Subprogram           Flag235\n@@ -603,19 +603,20 @@ package body Einfo is\n    --    Predicates_Ignored              Flag288\n    --    Has_Timing_Event                Flag289\n \n-   --    (unused)                        Flag290\n+   --    (unused)                        Flag290  --  ??? flag breaks einfo.h\n+\n+   --    Has_Inherited_Invariants        Flag291\n+   --    Is_Partial_Invariant_Procedure  Flag292\n \n-   --    (unused)                        Flag291\n-   --    (unused)                        Flag292\n    --    (unused)                        Flag293\n    --    (unused)                        Flag294\n    --    (unused)                        Flag295\n    --    (unused)                        Flag296\n    --    (unused)                        Flag297\n    --    (unused)                        Flag298\n    --    (unused)                        Flag299\n-\n    --    (unused)                        Flag300\n+\n    --    (unused)                        Flag301\n    --    (unused)                        Flag302\n    --    (unused)                        Flag303\n@@ -1610,18 +1611,18 @@ package body Einfo is\n       return Flag133 (Base_Type (Id));\n    end Has_Inherited_Default_Init_Cond;\n \n+   function Has_Inherited_Invariants (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      return Flag291 (Id);\n+   end Has_Inherited_Invariants;\n+\n    function Has_Initial_Value (Id : E) return B is\n    begin\n       pragma Assert (Ekind (Id) = E_Variable or else Is_Formal (Id));\n       return Flag219 (Id);\n    end Has_Initial_Value;\n \n-   function Has_Invariants (Id : E) return B is\n-   begin\n-      pragma Assert (Is_Type (Id));\n-      return Flag232 (Id);\n-   end Has_Invariants;\n-\n    function Has_Loop_Entry_Attributes (Id : E) return B is\n    begin\n       pragma Assert (Ekind (Id) = E_Loop);\n@@ -1675,6 +1676,12 @@ package body Einfo is\n       return Flag110 (Id);\n    end Has_Out_Or_In_Out_Parameter;\n \n+   function Has_Own_Invariants (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      return Flag232 (Id);\n+   end Has_Own_Invariants;\n+\n    function Has_Per_Object_Constraint (Id : E) return B is\n    begin\n       return Flag154 (Id);\n@@ -2388,6 +2395,12 @@ package body Einfo is\n       return Flag215 (Base_Type (Id));\n    end Is_Param_Block_Component_Type;\n \n+   function Is_Partial_Invariant_Procedure (Id : E) return B is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Function, E_Procedure));\n+      return Flag292 (Id);\n+   end Is_Partial_Invariant_Procedure;\n+\n    function Is_Potentially_Use_Visible (Id : E) return B is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n@@ -3314,10 +3327,10 @@ package body Einfo is\n       return Node18 (Id);\n    end String_Literal_Low_Bound;\n \n-   function Subprograms_For_Type (Id : E) return E is\n+   function Subprograms_For_Type (Id : E) return L is\n    begin\n-      pragma Assert (Is_Type (Id) or else Is_Subprogram (Id));\n-      return Node29 (Id);\n+      pragma Assert (Is_Type (Id));\n+      return Elist29 (Id);\n    end Subprograms_For_Type;\n \n    function Subps_Index (Id : E) return U is\n@@ -4596,18 +4609,18 @@ package body Einfo is\n       Set_Flag133 (Base_Type (Id), V);\n    end Set_Has_Inherited_Default_Init_Cond;\n \n+   procedure Set_Has_Inherited_Invariants (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      Set_Flag291 (Id, V);\n+   end Set_Has_Inherited_Invariants;\n+\n    procedure Set_Has_Initial_Value (Id : E; V : B := True) is\n    begin\n       pragma Assert (Ekind_In (Id, E_Variable, E_Out_Parameter));\n       Set_Flag219 (Id, V);\n    end Set_Has_Initial_Value;\n \n-   procedure Set_Has_Invariants (Id : E; V : B := True) is\n-   begin\n-      pragma Assert (Is_Type (Id));\n-      Set_Flag232 (Id, V);\n-   end Set_Has_Invariants;\n-\n    procedure Set_Has_Loop_Entry_Attributes (Id : E; V : B := True) is\n    begin\n       pragma Assert (Ekind (Id) = E_Loop);\n@@ -4662,6 +4675,12 @@ package body Einfo is\n       Set_Flag110 (Id, V);\n    end Set_Has_Out_Or_In_Out_Parameter;\n \n+   procedure Set_Has_Own_Invariants (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      Set_Flag232 (Id, V);\n+   end Set_Has_Own_Invariants;\n+\n    procedure Set_Has_Per_Object_Constraint (Id : E; V : B := True) is\n    begin\n       Set_Flag154 (Id, V);\n@@ -5442,6 +5461,12 @@ package body Einfo is\n       Set_Flag215 (Id, V);\n    end Set_Is_Param_Block_Component_Type;\n \n+   procedure Set_Is_Partial_Invariant_Procedure (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Procedure);\n+      Set_Flag292 (Id, V);\n+   end Set_Is_Partial_Invariant_Procedure;\n+\n    procedure Set_Is_Potentially_Use_Visible (Id : E; V : B := True) is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n@@ -5450,7 +5475,7 @@ package body Einfo is\n \n    procedure Set_Is_Predicate_Function (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Ekind_In (Id, E_Function, E_Procedure));\n+      pragma Assert (Ekind (Id) = E_Function);\n       Set_Flag255 (Id, V);\n    end Set_Is_Predicate_Function;\n \n@@ -6404,10 +6429,10 @@ package body Einfo is\n       Set_Node18 (Id, V);\n    end Set_String_Literal_Low_Bound;\n \n-   procedure Set_Subprograms_For_Type (Id : E; V : E) is\n+   procedure Set_Subprograms_For_Type (Id : E; V : L) is\n    begin\n-      pragma Assert (Is_Type (Id) or else Is_Subprogram (Id));\n-      Set_Node29 (Id, V);\n+      pragma Assert (Is_Type (Id));\n+      Set_Elist29 (Id, V);\n    end Set_Subprograms_For_Type;\n \n    procedure Set_Subps_Index (Id : E; V : U) is\n@@ -6945,22 +6970,30 @@ package body Einfo is\n    ---------------------------------\n \n    function Default_Init_Cond_Procedure (Id : E) return E is\n-      Subp_Id : Entity_Id;\n+      Subp_Elmt : Elmt_Id;\n+      Subp_Id   : Entity_Id;\n+      Subps     : Elist_Id;\n \n    begin\n       pragma Assert\n         (Is_Type (Id)\n           and then (Has_Default_Init_Cond (Id)\n-                     or Has_Inherited_Default_Init_Cond (Id)));\n+                     or else Has_Inherited_Default_Init_Cond (Id)));\n \n-      Subp_Id := Subprograms_For_Type (Base_Type (Id));\n-      while Present (Subp_Id) loop\n-         if Is_Default_Init_Cond_Procedure (Subp_Id) then\n-            return Subp_Id;\n-         end if;\n+      Subps := Subprograms_For_Type (Base_Type (Id));\n \n-         Subp_Id := Subprograms_For_Type (Subp_Id);\n-      end loop;\n+      if Present (Subps) then\n+         Subp_Elmt := First_Elmt (Subps);\n+         while Present (Subp_Elmt) loop\n+            Subp_Id := Node (Subp_Elmt);\n+\n+            if Is_Default_Init_Cond_Procedure (Subp_Id) then\n+               return Subp_Id;\n+            end if;\n+\n+            Next_Elmt (Subp_Elmt);\n+         end loop;\n+      end if;\n \n       return Empty;\n    end Default_Init_Cond_Procedure;\n@@ -7370,6 +7403,15 @@ package body Einfo is\n       return False;\n    end Has_Interrupt_Handler;\n \n+   --------------------\n+   -- Has_Invariants --\n+   --------------------\n+\n+   function Has_Invariants (Id : E) return B is\n+   begin\n+      return Has_Own_Invariants (Id) or else Has_Inherited_Invariants (Id);\n+   end Has_Invariants;\n+\n    --------------------------\n    -- Has_Non_Limited_View --\n    --------------------------\n@@ -7533,26 +7575,29 @@ package body Einfo is\n    -------------------------\n \n    function Invariant_Procedure (Id : E) return E is\n-      S : Entity_Id;\n+      Subp_Elmt : Elmt_Id;\n+      Subp_Id   : Entity_Id;\n+      Subps     : Elist_Id;\n \n    begin\n-      pragma Assert (Is_Type (Id) and then Has_Invariants (Id));\n+      pragma Assert (Is_Type (Id));\n \n-      if No (Subprograms_For_Type (Id)) then\n-         return Empty;\n+      Subps := Subprograms_For_Type (Id);\n \n-      else\n-         S := Subprograms_For_Type (Id);\n-         while Present (S) loop\n-            if Is_Invariant_Procedure (S) then\n-               return S;\n-            else\n-               S := Subprograms_For_Type (S);\n+      if Present (Subps) then\n+         Subp_Elmt := First_Elmt (Subps);\n+         while Present (Subp_Elmt) loop\n+            Subp_Id := Node (Subp_Elmt);\n+\n+            if Is_Invariant_Procedure (Subp_Id) then\n+               return Subp_Id;\n             end if;\n-         end loop;\n \n-         return Empty;\n+            Next_Elmt (Subp_Elmt);\n+         end loop;\n       end if;\n+\n+      return Empty;\n    end Invariant_Procedure;\n \n    ----------------------\n@@ -8261,83 +8306,128 @@ package body Einfo is\n       return Ekind (Id);\n    end Parameter_Mode;\n \n+   ---------------------------------\n+   -- Partial_Invariant_Procedure --\n+   ---------------------------------\n+\n+   function Partial_Invariant_Procedure (Id : E) return E is\n+      Subp_Elmt : Elmt_Id;\n+      Subp_Id   : Entity_Id;\n+      Subps     : Elist_Id;\n+\n+   begin\n+      pragma Assert (Is_Type (Id));\n+\n+      Subps := Subprograms_For_Type (Id);\n+\n+      if Present (Subps) then\n+         Subp_Elmt := First_Elmt (Subps);\n+         while Present (Subp_Elmt) loop\n+            Subp_Id := Node (Subp_Elmt);\n+\n+            if Is_Partial_Invariant_Procedure (Subp_Id) then\n+               return Subp_Id;\n+            end if;\n+\n+            Next_Elmt (Subp_Elmt);\n+         end loop;\n+      end if;\n+\n+      return Empty;\n+   end Partial_Invariant_Procedure;\n+\n    ------------------------\n    -- Predicate_Function --\n    ------------------------\n \n    function Predicate_Function (Id : E) return E is\n-      S : Entity_Id;\n-      T : Entity_Id;\n+      Subp_Elmt : Elmt_Id;\n+      Subp_Id   : Entity_Id;\n+      Subps     : Elist_Id;\n+      Typ       : Entity_Id;\n \n    begin\n       pragma Assert (Is_Type (Id));\n \n-      --  If type is private and has a completion, predicate may be defined\n-      --  on the full view.\n+      --  If type is private and has a completion, predicate may be defined on\n+      --  the full view.\n \n       if Is_Private_Type (Id)\n          and then\n            (not Has_Predicates (Id) or else No (Subprograms_For_Type (Id)))\n          and then Present (Full_View (Id))\n       then\n-         T := Full_View (Id);\n+         Typ := Full_View (Id);\n \n       else\n-         T := Id;\n+         Typ := Id;\n       end if;\n \n-      if No (Subprograms_For_Type (T)) then\n-         return Empty;\n+      Subps := Subprograms_For_Type (Typ);\n \n-      else\n-         S := Subprograms_For_Type (T);\n-         while Present (S) loop\n-            if Is_Predicate_Function (S) then\n-               return S;\n-            else\n-               S := Subprograms_For_Type (S);\n+      if Present (Subps) then\n+         Subp_Elmt := First_Elmt (Subps);\n+         while Present (Subp_Elmt) loop\n+            Subp_Id := Node (Subp_Elmt);\n+\n+            if Ekind (Subp_Id) = E_Function\n+              and then Is_Predicate_Function (Subp_Id)\n+            then\n+               return Subp_Id;\n             end if;\n-         end loop;\n \n-         return Empty;\n+            Next_Elmt (Subp_Elmt);\n+         end loop;\n       end if;\n+\n+      return Empty;\n    end Predicate_Function;\n \n    --------------------------\n    -- Predicate_Function_M --\n    --------------------------\n \n    function Predicate_Function_M (Id : E) return E is\n-      S : Entity_Id;\n-      T : Entity_Id;\n+      Subp_Elmt : Elmt_Id;\n+      Subp_Id   : Entity_Id;\n+      Subps     : Elist_Id;\n+      Typ       : Entity_Id;\n \n    begin\n       pragma Assert (Is_Type (Id));\n \n-      --  If type is private and has a completion, predicate may be defined\n-      --  on the full view.\n+      --  If type is private and has a completion, predicate may be defined on\n+      --  the full view.\n+\n+      if Is_Private_Type (Id)\n+         and then\n+           (not Has_Predicates (Id) or else No (Subprograms_For_Type (Id)))\n+         and then Present (Full_View (Id))\n+      then\n+         Typ := Full_View (Id);\n \n-      if Is_Private_Type (Id) and then Present (Full_View (Id)) then\n-         T := Full_View (Id);\n       else\n-         T := Id;\n+         Typ := Id;\n       end if;\n \n-      if No (Subprograms_For_Type (T)) then\n-         return Empty;\n+      Subps := Subprograms_For_Type (Typ);\n \n-      else\n-         S := Subprograms_For_Type (T);\n-         while Present (S) loop\n-            if Is_Predicate_Function_M (S) then\n-               return S;\n-            else\n-               S := Subprograms_For_Type (S);\n+      if Present (Subps) then\n+         Subp_Elmt := First_Elmt (Subps);\n+         while Present (Subp_Elmt) loop\n+            Subp_Id := Node (Subp_Elmt);\n+\n+            if Ekind (Subp_Id) = E_Function\n+              and then Is_Predicate_Function_M (Subp_Id)\n+            then\n+               return Subp_Id;\n             end if;\n-         end loop;\n \n-         return Empty;\n+            Next_Elmt (Subp_Elmt);\n+         end loop;\n       end if;\n+\n+      return Empty;\n    end Predicate_Function_M;\n \n    -------------------------\n@@ -8563,8 +8653,10 @@ package body Einfo is\n    -------------------------------------\n \n    procedure Set_Default_Init_Cond_Procedure (Id : E; V : E) is\n-      Base_Typ : Entity_Id;\n-      Subp_Id  : Entity_Id;\n+      Base_Typ  : Entity_Id;\n+      Subp_Elmt : Elmt_Id;\n+      Subp_Id   : Entity_Id;\n+      Subps     : Elist_Id;\n \n    begin\n       --  Once set, this attribute cannot be reset\n@@ -8577,21 +8669,29 @@ package body Einfo is\n       pragma Assert\n         (Is_Type (Id)\n           and then (Has_Default_Init_Cond (Id)\n-                     or Has_Inherited_Default_Init_Cond (Id)));\n+                     or else Has_Inherited_Default_Init_Cond (Id)));\n+\n       Base_Typ := Base_Type (Id);\n+      Subps    := Subprograms_For_Type (Base_Typ);\n+\n+      if No (Subps) then\n+         Subps := New_Elmt_List;\n+         Set_Subprograms_For_Type (Base_Typ, Subps);\n+      end if;\n \n-      Subp_Id := Subprograms_For_Type (Base_Typ);\n-      Set_Subprograms_For_Type (Base_Typ, V);\n-      Set_Subprograms_For_Type (V, Subp_Id);\n+      Subp_Elmt := First_Elmt (Subps);\n+      Prepend_Elmt (V, Subps);\n \n-      --  Check for a duplicate procedure\n+      --  Check for a duplicate default initial condition procedure\n+\n+      while Present (Subp_Elmt) loop\n+         Subp_Id := Node (Subp_Elmt);\n \n-      while Present (Subp_Id) loop\n          if Is_Default_Init_Cond_Procedure (Subp_Id) then\n             raise Program_Error;\n          end if;\n \n-         Subp_Id := Subprograms_For_Type (Subp_Id);\n+         Next_Elmt (Subp_Elmt);\n       end loop;\n    end Set_Default_Init_Cond_Procedure;\n \n@@ -8600,46 +8700,105 @@ package body Einfo is\n    -----------------------------\n \n    procedure Set_Invariant_Procedure (Id : E; V : E) is\n-      S : Entity_Id;\n+      Subp_Elmt : Elmt_Id;\n+      Subp_Id   : Entity_Id;\n+      Subps     : Elist_Id;\n \n    begin\n-      pragma Assert (Is_Type (Id) and then Has_Invariants (Id));\n+      pragma Assert (Is_Type (Id));\n \n-      S := Subprograms_For_Type (Id);\n-      Set_Subprograms_For_Type (Id, V);\n-      Set_Subprograms_For_Type (V, S);\n+      Subps := Subprograms_For_Type (Id);\n+\n+      if No (Subps) then\n+         Subps := New_Elmt_List;\n+         Set_Subprograms_For_Type (Id, Subps);\n+      end if;\n \n-      --  Check for duplicate entry\n+      Subp_Elmt := First_Elmt (Subps);\n+      Prepend_Elmt (V, Subps);\n \n-      while Present (S) loop\n-         if Is_Invariant_Procedure (S) then\n+      --  Check for a duplicate invariant procedure\n+\n+      while Present (Subp_Elmt) loop\n+         Subp_Id := Node (Subp_Elmt);\n+\n+         if Is_Invariant_Procedure (Subp_Id) then\n             raise Program_Error;\n-         else\n-            S := Subprograms_For_Type (S);\n          end if;\n+\n+         Next_Elmt (Subp_Elmt);\n       end loop;\n    end Set_Invariant_Procedure;\n \n+   -------------------------------------\n+   -- Set_Partial_Invariant_Procedure --\n+   -------------------------------------\n+\n+   procedure Set_Partial_Invariant_Procedure (Id : E; V : E) is\n+      Subp_Elmt : Elmt_Id;\n+      Subp_Id   : Entity_Id;\n+      Subps     : Elist_Id;\n+\n+   begin\n+      pragma Assert (Is_Type (Id));\n+\n+      Subps := Subprograms_For_Type (Id);\n+\n+      if No (Subps) then\n+         Subps := New_Elmt_List;\n+         Set_Subprograms_For_Type (Id, Subps);\n+      end if;\n+\n+      Subp_Elmt := First_Elmt (Subps);\n+      Prepend_Elmt (V, Subps);\n+\n+      --  Check for a duplicate partial invariant procedure\n+\n+      while Present (Subp_Elmt) loop\n+         Subp_Id := Node (Subp_Elmt);\n+\n+         if Is_Partial_Invariant_Procedure (Subp_Id) then\n+            raise Program_Error;\n+         end if;\n+\n+         Next_Elmt (Subp_Elmt);\n+      end loop;\n+   end Set_Partial_Invariant_Procedure;\n+\n    ----------------------------\n    -- Set_Predicate_Function --\n    ----------------------------\n \n    procedure Set_Predicate_Function (Id : E; V : E) is\n-      S : Entity_Id;\n+      Subp_Elmt : Elmt_Id;\n+      Subp_Id   : Entity_Id;\n+      Subps     : Elist_Id;\n \n    begin\n       pragma Assert (Is_Type (Id) and then Has_Predicates (Id));\n \n-      S := Subprograms_For_Type (Id);\n-      Set_Subprograms_For_Type (Id, V);\n-      Set_Subprograms_For_Type (V, S);\n+      Subps := Subprograms_For_Type (Id);\n+\n+      if No (Subps) then\n+         Subps := New_Elmt_List;\n+         Set_Subprograms_For_Type (Id, Subps);\n+      end if;\n \n-      while Present (S) loop\n-         if Is_Predicate_Function (S) then\n+      Subp_Elmt := First_Elmt (Subps);\n+      Prepend_Elmt (V, Subps);\n+\n+      --  Check for a duplicate predication function\n+\n+      while Present (Subp_Elmt) loop\n+         Subp_Id := Node (Subp_Elmt);\n+\n+         if Ekind (Subp_Id) = E_Function\n+           and then Is_Predicate_Function (Subp_Id)\n+         then\n             raise Program_Error;\n-         else\n-            S := Subprograms_For_Type (S);\n          end if;\n+\n+         Next_Elmt (Subp_Elmt);\n       end loop;\n    end Set_Predicate_Function;\n \n@@ -8648,23 +8807,35 @@ package body Einfo is\n    ------------------------------\n \n    procedure Set_Predicate_Function_M (Id : E; V : E) is\n-      S : Entity_Id;\n+      Subp_Elmt : Elmt_Id;\n+      Subp_Id   : Entity_Id;\n+      Subps     : Elist_Id;\n \n    begin\n       pragma Assert (Is_Type (Id) and then Has_Predicates (Id));\n \n-      S := Subprograms_For_Type (Id);\n-      Set_Subprograms_For_Type (Id, V);\n-      Set_Subprograms_For_Type (V, S);\n+      Subps := Subprograms_For_Type (Id);\n+\n+      if No (Subps) then\n+         Subps := New_Elmt_List;\n+         Set_Subprograms_For_Type (Id, Subps);\n+      end if;\n+\n+      Subp_Elmt := First_Elmt (Subps);\n+      Prepend_Elmt (V, Subps);\n \n-      --  Check for duplicates\n+      --  Check for a duplicate predication function\n \n-      while Present (S) loop\n-         if Is_Predicate_Function_M (S) then\n+      while Present (Subp_Elmt) loop\n+         Subp_Id := Node (Subp_Elmt);\n+\n+         if Ekind (Subp_Id) = E_Function\n+           and then Is_Predicate_Function_M (Subp_Id)\n+         then\n             raise Program_Error;\n-         else\n-            S := Subprograms_For_Type (S);\n          end if;\n+\n+         Next_Elmt (Subp_Elmt);\n       end loop;\n    end Set_Predicate_Function_M;\n \n@@ -8952,8 +9123,8 @@ package body Einfo is\n       W (\"Has_Independent_Components\",      Flag34  (Id));\n       W (\"Has_Inheritable_Invariants\",      Flag248 (Id));\n       W (\"Has_Inherited_Default_Init_Cond\", Flag133 (Id));\n+      W (\"Has_Inherited_Invariants\",        Flag291 (Id));\n       W (\"Has_Initial_Value\",               Flag219 (Id));\n-      W (\"Has_Invariants\",                  Flag232 (Id));\n       W (\"Has_Loop_Entry_Attributes\",       Flag260 (Id));\n       W (\"Has_Machine_Radix_Clause\",        Flag83  (Id));\n       W (\"Has_Master_Entity\",               Flag21  (Id));\n@@ -8963,6 +9134,7 @@ package body Einfo is\n       W (\"Has_Non_Standard_Rep\",            Flag75  (Id));\n       W (\"Has_Out_Or_In_Out_Parameter\",     Flag110 (Id));\n       W (\"Has_Object_Size_Clause\",          Flag172 (Id));\n+      W (\"Has_Own_Invariants\",              Flag232 (Id));\n       W (\"Has_Per_Object_Constraint\",       Flag154 (Id));\n       W (\"Has_Pragma_Controlled\",           Flag27  (Id));\n       W (\"Has_Pragma_Elaborate_Body\",       Flag150 (Id));\n@@ -9086,6 +9258,7 @@ package body Einfo is\n       W (\"Is_Packed\",                       Flag51  (Id));\n       W (\"Is_Packed_Array_Impl_Type\",       Flag138 (Id));\n       W (\"Is_Param_Block_Component_Type\",   Flag215 (Id));\n+      W (\"Is_Partial_Invariant_Procedure\",  Flag292 (Id));\n       W (\"Is_Potentially_Use_Visible\",      Flag9   (Id));\n       W (\"Is_Predicate_Function\",           Flag255 (Id));\n       W (\"Is_Predicate_Function_M\",         Flag256 (Id));"}, {"sha": "148e2dc433d66dc4fee0bcb8aff03335c8998c10", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 88, "deletions": 52, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=3ddfabe34fbcf04822c794f1dc8e1740811ad016", "patch": "@@ -1698,19 +1698,22 @@ package Einfo is\n --       usual manner.\n \n --    Has_Inheritable_Invariants (Flag248)\n---       Defined in all type entities. Set in private types from which one\n---       or more Invariant'Class aspects will be inherited if a another type is\n---       derived from the type (i.e. those types which have an Invariant'Class\n---       aspect, or which inherit one or more Invariant'Class aspects). Also\n---       set in the corresponding full types. Note that it might be the full\n---       type which has inheritable invariants, and in this case the flag will\n---       also be set in the private type.\n+--       Defined in all type entities. Set on private types and interface types\n+--       which define at least one class-wide invariant. Such invariants must\n+--       be inherited by derived types. The flag is also set on the full view\n+--       of a private type for completeness.\n \n --    Has_Inherited_Default_Init_Cond (Flag133) [base type only]\n --       Defined in all type entities. Set when a derived type inherits pragma\n --       Default_Initial_Condition from its parent type. This flag is mutually\n --       exclusive with flag Has_Default_Init_Cond.\n \n+--    Has_Inherited_Invariants (Flag291)\n+--       Defined in all type entities. Set on private extensions and derived\n+--       types which inherit at least on class-wide invariant from a parent or\n+--       an interface type. The flag is also set on the full view of a private\n+--       extension for completeness.\n+\n --    Has_Initial_Value (Flag219)\n --       Defined in entities for variables and out parameters. Set if there\n --       is an explicit initial value expression in the declaration of the\n@@ -1725,15 +1728,10 @@ package Einfo is\n --       definition contains at least one procedure to which a pragma\n --       Interrupt_Handler applies.\n \n---    Has_Invariants (Flag232)\n---       Defined in all type entities and in subprogram entities. Set in\n---       private types if an Invariant or Invariant'Class aspect applies to the\n---       type, or if the type inherits one or more Invariant'Class aspects.\n---       Also set in the corresponding full type. Note: if this flag is set\n---       True, then usually the Invariant_Procedure attribute is set once the\n---       type is frozen, however this may not be true in some error situations.\n---       Note that it might be the full type which has inheritable invariants,\n---       and then the flag will also be set in the private type.\n+--    Has_Invariants (synthesized)\n+--       Defined in all type entities. True if the type defines at least one\n+--       invariant of its own or inherits at least one class-wide invariant\n+--       from a parent type or an interface.\n \n --    Has_Loop_Entry_Attributes (Flag260)\n --       Defined in E_Loop entities. Set when the loop is subject to at least\n@@ -1809,6 +1807,11 @@ package Einfo is\n --       families. Set if they have at least one OUT or IN OUT parameter\n --       (allowed for functions only in Ada 2012).\n \n+--    Has_Own_Invariants (Flag232)\n+--       Defined in all type entities. Set on any type which defines at least\n+--       one invariant of its own. The flag is also set on the full view of a\n+--       private extension or a private type for completeness.\n+\n --    Has_Per_Object_Constraint (Flag154)\n --       Defined in E_Component entities. Set if the subtype of the component\n --       has a per object constraint. Per object constraints result from the\n@@ -2189,15 +2192,18 @@ package Einfo is\n --       ancestors (Ada 2005: AI-251).\n \n --    Invariant_Procedure (synthesized)\n---       Defined in types and subtypes. Set for private types if one or more\n---       Invariant, or Invariant'Class, or inherited Invariant'Class aspects\n---       apply to the type. Points to the entity for a procedure which checks\n---       the invariant. This invariant procedure takes a single argument of the\n---       given type, and returns if the invariant holds, or raises exception\n---       Assertion_Error with an appropriate message if it does not hold. This\n---       attribute is defined but always empty for private subtypes. This\n---       attribute is also set for the corresponding full type.\n---\n+--       Defined in types and subtypes. Set for private types and their full\n+--       views if one or more [class-wide] invariants apply to the type, or\n+--       when the type inherits class-wide invariants from a parent type or\n+--       an interface, or when the type is an array and its component type is\n+--       subject to an invariant, or when the type is record and contains a\n+--       component subject to an invariant (property is recursive). Points to\n+--       to the entity for a procedure which checks all these invariants. The\n+--       invariant procedure takes a single argument of the given type, and\n+--       returns if the invariant holds, or raises exception Assertion_Error\n+--       with an appropriate message if it does not hold. This attribute is\n+--       defined but always Empty for private subtypes.\n+\n --       Note: the reason this is marked as a synthesized attribute is that the\n --       way this is stored is as an element of the Subprograms_For_Type field.\n \n@@ -2267,7 +2273,7 @@ package Einfo is\n --       applies to both the partial view and the full view.\n \n --    Is_Base_Type (synthesized)\n---       Applies to type and subtype entities. True if entity is a base type\n+--       Applies to type and subtype entities. True if entity is a base type.\n \n --    Is_Bit_Packed_Array (Flag122) [implementation base type only]\n --       Defined in all entities. This flag is set for a packed array type that\n@@ -2325,9 +2331,9 @@ package Einfo is\n --       which are not Completely_Hidden (e.g. discriminants of a root type).\n \n --    Is_Composite_Type (synthesized)\n---       Applies to all entities, true for all composite types and\n---       subtypes. Either Is_Composite_Type or Is_Elementary_Type (but\n---       not both) is true of any type.\n+--       Applies to all entities, true for all composite types and subtypes.\n+--       Either Is_Composite_Type or Is_Elementary_Type (but not both) is true\n+--       of any type.\n \n --    Is_Concurrent_Record_Type (Flag20)\n --       Defined in record types and subtypes. Set if the type was created\n@@ -2686,7 +2692,9 @@ package Einfo is\n \n --    Is_Invariant_Procedure (Flag257)\n --       Defined in functions and procedures. Set for a generated invariant\n---       procedure to identify it easily.\n+--       procedure which verifies the invariants of both the partial and full\n+--       views of a private type or private extension as well as any inherited\n+--       class-wide invariants from parent types or interfaces.\n \n --    Is_Itype (Flag91)\n --       Defined in all entities. Set to indicate that a type is an Itype,\n@@ -2912,6 +2920,11 @@ package Einfo is\n --       component of the parameter block record type generated by the compiler\n --       for an entry or a select statement. Read by CodePeer.\n \n+--    Is_Partial_Invariant_Procedure (Flag292)\n+--       Defined in functions and procedures. Set for a generated invariant\n+--       procedure which verifies the invariants of the partial view of a\n+--       private type or private extension.\n+\n --    Is_Potentially_Use_Visible (Flag9)\n --       Defined in all entities. Set if entity is potentially use visible,\n --       i.e. it is defined in a package that appears in a currently active\n@@ -3738,6 +3751,18 @@ package Einfo is\n --       of a single protected/task type, the references are examined as they\n --       must appear only within the type defintion and the corresponding body.\n \n+--    Partial_Invariant_Procedure (synthesized)\n+--       Defined in types and subtypes. Set for private types when one or more\n+--       [class-wide] type invariants apply to them. Points to the entity for a\n+--       procedure which checks the invariant. This invariant procedure takes a\n+--       single argument of the given type, and returns if the invariant holds,\n+--       or raises exception Assertion_Error with an appropriate message if it\n+--       does not hold. This attribute is defined but always Empty for private\n+--       subtypes. This attribute is also set for the corresponding full type.\n+--\n+--       Note: the reason this is marked as a synthesized attribute is that the\n+--       way this is stored is as an element of the Subprograms_For_Type field.\n+\n --    Partial_View_Has_Unknown_Discr (Flag280)\n --       Present in all types. Set to Indicate that the partial view of a type\n --       has unknown discriminants. A default initialization of an object of\n@@ -4263,15 +4288,14 @@ package Einfo is\n --       the low bound of the applicable index constraint if there is one,\n --       or a copy of the low bound of the index base type if not.\n \n---    Subprograms_For_Type (Node29)\n---       Defined in all type and subprogram entities. This is used to hold\n---       a list of subprogram entities for subprograms associated with the\n---       type, linked through the Subprograms_For_Type field of the subprogram\n---       entity. Basically this is a way of multiplexing the single field to\n---       hold more than one entity (since we ran out of space in some type\n---       entities). This is currently used for Invariant_Procedure and also\n---       for Predicate_Function, and clients will always use the latter two\n---       names to access entries in this list.\n+--    Subprograms_For_Type (Elist29)\n+--       Defined in all types. The list may contain the entities of the default\n+--       initial condition procedure, invariant procedure, and the two versions\n+--       of the predicate function.\n+--\n+--       Historical note: This attribute used to be a direct linked list of\n+--       entities rather than an Elist. The Elist allows greater flexibility\n+--       in inheritance of subprograms between views of the same type.\n \n --    Subps_Index (Uint24)\n --       Present in subprogram entries. Set if the subprogram contains nested\n@@ -5471,7 +5495,7 @@ package Einfo is\n    --    Pending_Access_Types                (Elist15)\n    --    Related_Expression                  (Node24)\n    --    Current_Use_Clause                  (Node27)\n-   --    Subprograms_For_Type                (Node29)\n+   --    Subprograms_For_Type                (Elist29)\n    --    Derived_Type_Link                   (Node31)\n    --    No_Tagged_Streams_Pragma            (Node32)\n    --    Linker_Section_Pragma               (Node33)\n@@ -5495,11 +5519,12 @@ package Einfo is\n    --    Has_Discriminants                   (Flag5)\n    --    Has_Dynamic_Predicate_Aspect        (Flag258)\n    --    Has_Independent_Components          (Flag34)   (base type only)\n-   --    Has_Inheritable_Invariants          (Flag248)\n+   --    Has_Inheritable_Invariants          (Flag248)  (base type only)\n    --    Has_Inherited_Default_Init_Cond     (Flag133)  (base type only)\n-   --    Has_Invariants                      (Flag232)\n+   --    Has_Inherited_Invariants            (Flag291)  (base type only)\n    --    Has_Non_Standard_Rep                (Flag75)   (base type only)\n    --    Has_Object_Size_Clause              (Flag172)\n+   --    Has_Own_Invariants                  (Flag232)  (base type only)\n    --    Has_Pragma_Preelab_Init             (Flag221)\n    --    Has_Pragma_Unreferenced_Objects     (Flag212)\n    --    Has_Predicates                      (Flag250)\n@@ -5553,11 +5578,13 @@ package Einfo is\n    --    Alignment_Clause                    (synth)\n    --    Base_Type                           (synth)\n    --    Default_Init_Cond_Procedure         (synth)\n+   --    Has_Invariants                      (synth)\n    --    Implementation_Base_Type            (synth)\n    --    Invariant_Procedure                 (synth)\n    --    Is_Access_Protected_Subprogram_Type (synth)\n    --    Is_Atomic_Or_VFA                    (synth)\n    --    Is_Controlled_Active                (synth)\n+   --    Partial_Invariant_Procedure         (synth)\n    --    Predicate_Function                  (synth)\n    --    Predicate_Function_M                (synth)\n    --    Root_Type                           (synth)\n@@ -5921,7 +5948,6 @@ package Einfo is\n    --    Overridden_Operation                (Node26)\n    --    Wrapped_Entity                      (Node27)   (non-generic case only)\n    --    Extra_Formals                       (Node28)\n-   --    Subprograms_For_Type                (Node29)\n    --    Corresponding_Equality              (Node30)   (implicit /= only)\n    --    Thunk_Entity                        (Node31)   (thunk case only)\n    --    Corresponding_Procedure             (Node32)   (generate C code only)\n@@ -5942,7 +5968,6 @@ package Einfo is\n    --    Has_Completion                      (Flag26)\n    --    Has_Controlling_Result              (Flag98)\n    --    Has_Expanded_Contract               (Flag240)  (non-generic case only)\n-   --    Has_Invariants                      (Flag232)\n    --    Has_Master_Entity                   (Flag21)\n    --    Has_Missing_Return                  (Flag142)\n    --    Has_Nested_Block_With_Handler       (Flag101)\n@@ -5952,6 +5977,7 @@ package Einfo is\n    --    Is_Abstract_Subprogram              (Flag19)   (non-generic case only)\n    --    Is_Called                           (Flag102)  (non-generic case only)\n    --    Is_Constructor                      (Flag76)\n+   --    Is_Default_Init_Cond_Procedure      (Flag132)  (non-generic case only)\n    --    Is_Discrim_SO_Function              (Flag176)\n    --    Is_Discriminant_Check_Function      (Flag264)\n    --    Is_Eliminated                       (Flag124)\n@@ -5962,6 +5988,7 @@ package Einfo is\n    --    Is_Intrinsic_Subprogram             (Flag64)\n    --    Is_Invariant_Procedure              (Flag257)  (non-generic case only)\n    --    Is_Machine_Code_Subprogram          (Flag137)  (non-generic case only)\n+   --    Is_Partial_Invariant_Procedure      (Flag292)  (non-generic case only)\n    --    Is_Predicate_Function               (Flag255)  (non-generic case only)\n    --    Is_Predicate_Function_M             (Flag256)  (non-generic case only)\n    --    Is_Primitive                        (Flag218)\n@@ -6094,13 +6121,11 @@ package Einfo is\n    --    Last_Entity                         (Node20)\n    --    Subps_Index                         (Uint24)\n    --    Overridden_Operation                (Node26)\n-   --    Subprograms_For_Type                (Node29)\n    --    Linker_Section_Pragma               (Node33)\n    --    Contract                            (Node34)\n    --    Import_Pragma                       (Node35)\n    --    SPARK_Pragma                        (Node40)\n    --    Default_Expressions_Processed       (Flag108)\n-   --    Has_Invariants                      (Flag232)\n    --    Has_Nested_Subprogram               (Flag282)\n    --    Is_Intrinsic_Subprogram             (Flag64)\n    --    Is_Machine_Code_Subprogram          (Flag137)\n@@ -6254,7 +6279,6 @@ package Einfo is\n    --    Discard_Names                       (Flag88)\n    --    Has_Completion                      (Flag26)\n    --    Has_Expanded_Contract               (Flag240)  (non-generic case only)\n-   --    Has_Invariants                      (Flag232)\n    --    Has_Master_Entity                   (Flag21)\n    --    Has_Nested_Block_With_Handler       (Flag101)\n    --    Has_Nested_Subprogram               (Flag282)\n@@ -6273,6 +6297,7 @@ package Einfo is\n    --    Is_Invariant_Procedure              (Flag257)  (non-generic case only)\n    --    Is_Machine_Code_Subprogram          (Flag137)  (non-generic case only)\n    --    Is_Null_Init_Proc                   (Flag178)\n+   --    Is_Partial_Invariant_Procedure      (Flag292)  (non-generic case only)\n    --    Is_Predicate_Function               (Flag255)  (non-generic case only)\n    --    Is_Predicate_Function_M             (Flag256)  (non-generic case only)\n    --    Is_Primitive                        (Flag218)\n@@ -6918,6 +6943,7 @@ package Einfo is\n    function Has_Independent_Components          (Id : E) return B;\n    function Has_Inheritable_Invariants          (Id : E) return B;\n    function Has_Inherited_Default_Init_Cond     (Id : E) return B;\n+   function Has_Inherited_Invariants            (Id : E) return B;\n    function Has_Initial_Value                   (Id : E) return B;\n    function Has_Interrupt_Handler               (Id : E) return B;\n    function Has_Invariants                      (Id : E) return B;\n@@ -6930,6 +6956,7 @@ package Einfo is\n    function Has_Non_Standard_Rep                (Id : E) return B;\n    function Has_Object_Size_Clause              (Id : E) return B;\n    function Has_Out_Or_In_Out_Parameter         (Id : E) return B;\n+   function Has_Own_Invariants                  (Id : E) return B;\n    function Has_Per_Object_Constraint           (Id : E) return B;\n    function Has_Pragma_Controlled               (Id : E) return B;\n    function Has_Pragma_Elaborate_Body           (Id : E) return B;\n@@ -7058,6 +7085,7 @@ package Einfo is\n    function Is_Packed_Array_Impl_Type           (Id : E) return B;\n    function Is_Potentially_Use_Visible          (Id : E) return B;\n    function Is_Param_Block_Component_Type       (Id : E) return B;\n+   function Is_Partial_Invariant_Procedure      (Id : E) return B;\n    function Is_Predicate_Function               (Id : E) return B;\n    function Is_Predicate_Function_M             (Id : E) return B;\n    function Is_Preelaborated                    (Id : E) return B;\n@@ -7208,7 +7236,7 @@ package Einfo is\n    function Strict_Alignment                    (Id : E) return B;\n    function String_Literal_Length               (Id : E) return U;\n    function String_Literal_Low_Bound            (Id : E) return N;\n-   function Subprograms_For_Type                (Id : E) return E;\n+   function Subprograms_For_Type                (Id : E) return L;\n    function Subps_Index                         (Id : E) return U;\n    function Suppress_Elaboration_Warnings       (Id : E) return B;\n    function Suppress_Initialization             (Id : E) return B;\n@@ -7589,8 +7617,8 @@ package Einfo is\n    procedure Set_Has_Independent_Components      (Id : E; V : B := True);\n    procedure Set_Has_Inheritable_Invariants      (Id : E; V : B := True);\n    procedure Set_Has_Inherited_Default_Init_Cond (Id : E; V : B := True);\n+   procedure Set_Has_Inherited_Invariants        (Id : E; V : B := True);\n    procedure Set_Has_Initial_Value               (Id : E; V : B := True);\n-   procedure Set_Has_Invariants                  (Id : E; V : B := True);\n    procedure Set_Has_Loop_Entry_Attributes       (Id : E; V : B := True);\n    procedure Set_Has_Machine_Radix_Clause        (Id : E; V : B := True);\n    procedure Set_Has_Master_Entity               (Id : E; V : B := True);\n@@ -7600,6 +7628,7 @@ package Einfo is\n    procedure Set_Has_Non_Standard_Rep            (Id : E; V : B := True);\n    procedure Set_Has_Object_Size_Clause          (Id : E; V : B := True);\n    procedure Set_Has_Out_Or_In_Out_Parameter     (Id : E; V : B := True);\n+   procedure Set_Has_Own_Invariants              (Id : E; V : B := True);\n    procedure Set_Has_Per_Object_Constraint       (Id : E; V : B := True);\n    procedure Set_Has_Pragma_Controlled           (Id : E; V : B := True);\n    procedure Set_Has_Pragma_Elaborate_Body       (Id : E; V : B := True);\n@@ -7732,6 +7761,7 @@ package Einfo is\n    procedure Set_Is_Packed                       (Id : E; V : B := True);\n    procedure Set_Is_Packed_Array_Impl_Type       (Id : E; V : B := True);\n    procedure Set_Is_Param_Block_Component_Type   (Id : E; V : B := True);\n+   procedure Set_Is_Partial_Invariant_Procedure  (Id : E; V : B := True);\n    procedure Set_Is_Potentially_Use_Visible      (Id : E; V : B := True);\n    procedure Set_Is_Predicate_Function           (Id : E; V : B := True);\n    procedure Set_Is_Predicate_Function_M         (Id : E; V : B := True);\n@@ -7882,7 +7912,7 @@ package Einfo is\n    procedure Set_Strict_Alignment                (Id : E; V : B := True);\n    procedure Set_String_Literal_Length           (Id : E; V : U);\n    procedure Set_String_Literal_Low_Bound        (Id : E; V : N);\n-   procedure Set_Subprograms_For_Type            (Id : E; V : E);\n+   procedure Set_Subprograms_For_Type            (Id : E; V : L);\n    procedure Set_Subps_Index                     (Id : E; V : U);\n    procedure Set_Suppress_Elaboration_Warnings   (Id : E; V : B := True);\n    procedure Set_Suppress_Initialization         (Id : E; V : B := True);\n@@ -7911,11 +7941,13 @@ package Einfo is\n \n    function Default_Init_Cond_Procedure         (Id : E) return E;\n    function Invariant_Procedure                 (Id : E) return E;\n+   function Partial_Invariant_Procedure         (Id : E) return E;\n    function Predicate_Function                  (Id : E) return E;\n    function Predicate_Function_M                (Id : E) return E;\n \n    procedure Set_Default_Init_Cond_Procedure    (Id : E; V : E);\n    procedure Set_Invariant_Procedure            (Id : E; V : E);\n+   procedure Set_Partial_Invariant_Procedure    (Id : E; V : E);\n    procedure Set_Predicate_Function             (Id : E; V : E);\n    procedure Set_Predicate_Function_M           (Id : E; V : E);\n \n@@ -8374,8 +8406,8 @@ package Einfo is\n    pragma Inline (Has_Independent_Components);\n    pragma Inline (Has_Inheritable_Invariants);\n    pragma Inline (Has_Inherited_Default_Init_Cond);\n+   pragma Inline (Has_Inherited_Invariants);\n    pragma Inline (Has_Initial_Value);\n-   pragma Inline (Has_Invariants);\n    pragma Inline (Has_Loop_Entry_Attributes);\n    pragma Inline (Has_Machine_Radix_Clause);\n    pragma Inline (Has_Master_Entity);\n@@ -8385,6 +8417,7 @@ package Einfo is\n    pragma Inline (Has_Non_Standard_Rep);\n    pragma Inline (Has_Object_Size_Clause);\n    pragma Inline (Has_Out_Or_In_Out_Parameter);\n+   pragma Inline (Has_Own_Invariants);\n    pragma Inline (Has_Per_Object_Constraint);\n    pragma Inline (Has_Pragma_Controlled);\n    pragma Inline (Has_Pragma_Elaborate_Body);\n@@ -8550,6 +8583,7 @@ package Einfo is\n    pragma Inline (Is_Packed);\n    pragma Inline (Is_Packed_Array_Impl_Type);\n    pragma Inline (Is_Param_Block_Component_Type);\n+   pragma Inline (Is_Partial_Invariant_Procedure);\n    pragma Inline (Is_Potentially_Use_Visible);\n    pragma Inline (Is_Predicate_Function);\n    pragma Inline (Is_Predicate_Function_M);\n@@ -8884,8 +8918,8 @@ package Einfo is\n    pragma Inline (Set_Has_Independent_Components);\n    pragma Inline (Set_Has_Inheritable_Invariants);\n    pragma Inline (Set_Has_Inherited_Default_Init_Cond);\n+   pragma Inline (Set_Has_Inherited_Invariants);\n    pragma Inline (Set_Has_Initial_Value);\n-   pragma Inline (Set_Has_Invariants);\n    pragma Inline (Set_Has_Loop_Entry_Attributes);\n    pragma Inline (Set_Has_Machine_Radix_Clause);\n    pragma Inline (Set_Has_Master_Entity);\n@@ -8895,6 +8929,7 @@ package Einfo is\n    pragma Inline (Set_Has_Non_Standard_Rep);\n    pragma Inline (Set_Has_Object_Size_Clause);\n    pragma Inline (Set_Has_Out_Or_In_Out_Parameter);\n+   pragma Inline (Set_Has_Own_Invariants);\n    pragma Inline (Set_Has_Per_Object_Constraint);\n    pragma Inline (Set_Has_Pragma_Controlled);\n    pragma Inline (Set_Has_Pragma_Elaborate_Body);\n@@ -9026,6 +9061,7 @@ package Einfo is\n    pragma Inline (Set_Is_Packed);\n    pragma Inline (Set_Is_Packed_Array_Impl_Type);\n    pragma Inline (Set_Is_Param_Block_Component_Type);\n+   pragma Inline (Set_Is_Partial_Invariant_Procedure);\n    pragma Inline (Set_Is_Potentially_Use_Visible);\n    pragma Inline (Set_Is_Predicate_Function);\n    pragma Inline (Set_Is_Predicate_Function_M);"}, {"sha": "923eca373a70944ea0e537493beee63734e405e2", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 14, "deletions": 501, "changes": 515, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=3ddfabe34fbcf04822c794f1dc8e1740811ad016", "patch": "@@ -59,7 +59,6 @@ with Sem_Cat;  use Sem_Cat;\n with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n-with Sem_Ch13; use Sem_Ch13;\n with Sem_Disp; use Sem_Disp;\n with Sem_Eval; use Sem_Eval;\n with Sem_Mech; use Sem_Mech;\n@@ -92,22 +91,6 @@ package body Exp_Ch3 is\n    --  used for attachment of any actions required in its construction.\n    --  It also supplies the source location used for the procedure.\n \n-   function Build_Array_Invariant_Proc\n-     (A_Type : Entity_Id;\n-      Nod    : Node_Id) return Node_Id;\n-   --  If the component of type of array type has invariants, build procedure\n-   --  that checks invariant on all components of the array. Ada 2012 specifies\n-   --  that an invariant on some type T must be applied to in-out parameters\n-   --  and return values that include a part of type T. If the array type has\n-   --  an otherwise specified invariant, the component check procedure is\n-   --  called from within the user-specified invariant. Otherwise this becomes\n-   --  the invariant procedure for the array type.\n-\n-   function Build_Record_Invariant_Proc\n-     (R_Type : Entity_Id;\n-      Nod    : Node_Id) return Node_Id;\n-   --  Ditto for record types.\n-\n    function Build_Discriminant_Formals\n      (Rec_Id : Entity_Id;\n       Use_Dl : Boolean) return List_Id;\n@@ -200,14 +183,6 @@ package body Exp_Ch3 is\n    --  Treat user-defined stream operations as renaming_as_body if the\n    --  subprogram they rename is not frozen when the type is frozen.\n \n-   procedure Insert_Component_Invariant_Checks\n-     (N    : Node_Id;\n-      Typ  : Entity_Id;\n-      Proc : Node_Id);\n-   --  If a composite type has invariants and also has components with defined\n-   --  invariants. the component invariant procedure is inserted into the user-\n-   --  defined invariant procedure and added to the checks to be performed.\n-\n    procedure Initialization_Warning (E : Entity_Id);\n    --  If static elaboration of the package is requested, indicate\n    --  when a type does meet the conditions for static initialization. If\n@@ -794,138 +769,6 @@ package body Exp_Ch3 is\n       end if;\n    end Build_Array_Init_Proc;\n \n-   --------------------------------\n-   -- Build_Array_Invariant_Proc --\n-   --------------------------------\n-\n-   function Build_Array_Invariant_Proc\n-     (A_Type : Entity_Id;\n-      Nod    : Node_Id) return Node_Id\n-   is\n-      Loc : constant Source_Ptr := Sloc (Nod);\n-\n-      Object_Name : constant Name_Id := New_Internal_Name ('I');\n-      --  Name for argument of invariant procedure\n-\n-      Object_Entity : constant Node_Id :=\n-                        Make_Defining_Identifier (Loc, Object_Name);\n-      --  The procedure declaration entity for the argument\n-\n-      Body_Stmts : List_Id;\n-      Index_List : List_Id;\n-      Proc_Id    : Entity_Id;\n-      Proc_Body  : Node_Id;\n-\n-      function Build_Component_Invariant_Call return Node_Id;\n-      --  Create one statement to verify invariant on one array component,\n-      --  designated by a full set of indexes.\n-\n-      function Check_One_Dimension (N : Int) return List_Id;\n-      --  Create loop to check on one dimension of the array. The single\n-      --  statement in the loop body checks the inner dimensions if any, or\n-      --  else a single component. This procedure is called recursively, with\n-      --  N being the dimension to be initialized. A call with N greater than\n-      --  the number of dimensions generates the component initialization\n-      --  and terminates the recursion.\n-\n-      ------------------------------------\n-      -- Build_Component_Invariant_Call --\n-      ------------------------------------\n-\n-      function Build_Component_Invariant_Call return Node_Id is\n-         Comp : Node_Id;\n-      begin\n-         Comp :=\n-           Make_Indexed_Component (Loc,\n-             Prefix      => New_Occurrence_Of (Object_Entity, Loc),\n-             Expressions => Index_List);\n-         return\n-           Make_Procedure_Call_Statement (Loc,\n-             Name                   =>\n-               New_Occurrence_Of\n-                 (Invariant_Procedure (Component_Type (A_Type)), Loc),\n-             Parameter_Associations => New_List (Comp));\n-      end Build_Component_Invariant_Call;\n-\n-      -------------------------\n-      -- Check_One_Dimension --\n-      -------------------------\n-\n-      function Check_One_Dimension (N : Int) return List_Id is\n-         Index : Entity_Id;\n-\n-      begin\n-         --  If all dimensions dealt with, we simply check invariant of the\n-         --  component.\n-\n-         if N > Number_Dimensions (A_Type) then\n-            return New_List (Build_Component_Invariant_Call);\n-\n-         --  Else generate one loop and recurse\n-\n-         else\n-            Index :=\n-              Make_Defining_Identifier (Loc, New_External_Name ('J', N));\n-\n-            Append (New_Occurrence_Of (Index, Loc), Index_List);\n-\n-            return New_List (\n-              Make_Implicit_Loop_Statement (Nod,\n-                Identifier       => Empty,\n-                Iteration_Scheme =>\n-                  Make_Iteration_Scheme (Loc,\n-                    Loop_Parameter_Specification =>\n-                      Make_Loop_Parameter_Specification (Loc,\n-                        Defining_Identifier         => Index,\n-                        Discrete_Subtype_Definition =>\n-                          Make_Attribute_Reference (Loc,\n-                            Prefix          =>\n-                              New_Occurrence_Of (Object_Entity, Loc),\n-                            Attribute_Name  => Name_Range,\n-                            Expressions     => New_List (\n-                              Make_Integer_Literal (Loc, N))))),\n-                Statements       =>  Check_One_Dimension (N + 1)));\n-         end if;\n-      end Check_One_Dimension;\n-\n-   --  Start of processing for Build_Array_Invariant_Proc\n-\n-   begin\n-      Index_List := New_List;\n-\n-      Proc_Id :=\n-        Make_Defining_Identifier (Loc,\n-           Chars => New_External_Name (Chars (A_Type), \"CInvariant\"));\n-\n-      Body_Stmts := Check_One_Dimension (1);\n-\n-      Proc_Body :=\n-        Make_Subprogram_Body (Loc,\n-          Specification =>\n-            Make_Procedure_Specification (Loc,\n-              Defining_Unit_Name       => Proc_Id,\n-              Parameter_Specifications => New_List (\n-                Make_Parameter_Specification (Loc,\n-                  Defining_Identifier => Object_Entity,\n-                  Parameter_Type      => New_Occurrence_Of (A_Type, Loc)))),\n-\n-          Declarations               => Empty_List,\n-          Handled_Statement_Sequence =>\n-            Make_Handled_Sequence_Of_Statements (Loc,\n-              Statements => Body_Stmts));\n-\n-      Set_Ekind          (Proc_Id, E_Procedure);\n-      Set_Is_Public      (Proc_Id, Is_Public (A_Type));\n-      Set_Is_Internal    (Proc_Id);\n-      Set_Has_Completion (Proc_Id);\n-\n-      if not Debug_Generated_Code then\n-         Set_Debug_Info_Off (Proc_Id);\n-      end if;\n-\n-      return Proc_Body;\n-   end Build_Array_Invariant_Proc;\n-\n    --------------------------------\n    -- Build_Discr_Checking_Funcs --\n    --------------------------------\n@@ -3671,242 +3514,6 @@ package body Exp_Ch3 is\n       end if;\n    end Build_Record_Init_Proc;\n \n-   --------------------------------\n-   -- Build_Record_Invariant_Proc --\n-   --------------------------------\n-\n-   function Build_Record_Invariant_Proc\n-     (R_Type : Entity_Id;\n-      Nod    : Node_Id) return Node_Id\n-   is\n-      Loc : constant Source_Ptr := Sloc (Nod);\n-\n-      Object_Name : constant Name_Id := New_Internal_Name ('I');\n-      --  Name for argument of invariant procedure\n-\n-      Object_Entity : constant Node_Id :=\n-        Make_Defining_Identifier (Loc, Object_Name);\n-      --  The procedure declaration entity for the argument\n-\n-      Invariant_Found : Boolean;\n-      --  Set if any component needs an invariant check.\n-\n-      Proc_Id   : Entity_Id;\n-      Proc_Body : Node_Id;\n-      Stmts     : List_Id;\n-      Type_Def  : Node_Id;\n-\n-      function Build_Invariant_Checks (Comp_List : Node_Id) return List_Id;\n-      --  Recursive procedure that generates a list of checks for components\n-      --  that need it, and recurses through variant parts when present.\n-\n-      function Build_Component_Invariant_Call\n-        (Comp : Entity_Id) return Node_Id;\n-      --  Build call to invariant procedure for a record component\n-\n-      ------------------------------------\n-      -- Build_Component_Invariant_Call --\n-      ------------------------------------\n-\n-      function Build_Component_Invariant_Call\n-        (Comp : Entity_Id) return Node_Id\n-      is\n-         Call     : Node_Id;\n-         Proc     : Entity_Id;\n-         Sel_Comp : Node_Id;\n-         Typ      : Entity_Id;\n-\n-      begin\n-         Typ := Etype (Comp);\n-\n-         Sel_Comp :=\n-           Make_Selected_Component (Loc,\n-             Prefix        => New_Occurrence_Of (Object_Entity, Loc),\n-             Selector_Name => New_Occurrence_Of (Comp, Loc));\n-\n-         if Is_Access_Type (Typ) then\n-\n-            --  If the access component designates a type with an invariant,\n-            --  the check applies to the designated object. The access type\n-            --  itself may have an invariant, in which case it applies to the\n-            --  access value directly.\n-\n-            --  Note: we are assuming that invariants will not occur on both\n-            --  the access type and the type that it designates. This is not\n-            --  really justified but it is hard to imagine that this case will\n-            --  ever cause trouble ???\n-\n-            if not (Has_Invariants (Typ)) then\n-               Sel_Comp := Make_Explicit_Dereference (Loc, Sel_Comp);\n-               Typ := Designated_Type (Typ);\n-            end if;\n-         end if;\n-\n-         --  The aspect is type-specific, so retrieve it from the base type\n-\n-         Proc := Invariant_Procedure (Base_Type (Typ));\n-\n-         if Has_Null_Body (Proc) then\n-            return Make_Null_Statement (Loc);\n-         end if;\n-\n-         Invariant_Found := True;\n-         Call :=\n-           Make_Procedure_Call_Statement (Loc,\n-             Name                   => New_Occurrence_Of (Proc, Loc),\n-             Parameter_Associations => New_List (Sel_Comp));\n-\n-         if Is_Access_Type (Etype (Comp)) then\n-            Call :=\n-              Make_If_Statement (Loc,\n-                Condition       =>\n-                  Make_Op_Ne (Loc,\n-                    Left_Opnd   => Make_Null (Loc),\n-                    Right_Opnd  =>\n-                      Make_Selected_Component (Loc,\n-                        Prefix        =>\n-                          New_Occurrence_Of (Object_Entity, Loc),\n-                        Selector_Name => New_Occurrence_Of (Comp, Loc))),\n-                Then_Statements => New_List (Call));\n-         end if;\n-\n-         return Call;\n-      end Build_Component_Invariant_Call;\n-\n-      ----------------------------\n-      -- Build_Invariant_Checks --\n-      ----------------------------\n-\n-      function Build_Invariant_Checks (Comp_List : Node_Id) return List_Id is\n-         Decl     : Node_Id;\n-         Id       : Entity_Id;\n-         Stmts    : List_Id;\n-\n-      begin\n-         Stmts := New_List;\n-         Decl := First_Non_Pragma (Component_Items (Comp_List));\n-         while Present (Decl) loop\n-            if Nkind (Decl) = N_Component_Declaration then\n-               Id := Defining_Identifier (Decl);\n-\n-               if Has_Invariants (Etype (Id))\n-                 and then In_Open_Scopes (Scope (R_Type))\n-               then\n-                  if Has_Unchecked_Union (R_Type) then\n-                     Error_Msg_NE\n-                       (\"invariants cannot be checked on components of \"\n-                         & \"unchecked_union type&?\", Decl, R_Type);\n-                     return Empty_List;\n-\n-                  else\n-                     Append_To (Stmts, Build_Component_Invariant_Call (Id));\n-                  end if;\n-\n-               elsif Is_Access_Type (Etype (Id))\n-                 and then not Is_Access_Constant (Etype (Id))\n-                 and then Has_Invariants (Designated_Type (Etype (Id)))\n-                 and then In_Open_Scopes (Scope (Designated_Type (Etype (Id))))\n-               then\n-                  Append_To (Stmts, Build_Component_Invariant_Call (Id));\n-               end if;\n-            end if;\n-\n-            Next (Decl);\n-         end loop;\n-\n-         if Present (Variant_Part (Comp_List)) then\n-            declare\n-               Variant_Alts  : constant List_Id := New_List;\n-               Var_Loc       : Source_Ptr;\n-               Variant       : Node_Id;\n-               Variant_Stmts : List_Id;\n-\n-            begin\n-               Variant :=\n-                 First_Non_Pragma (Variants (Variant_Part (Comp_List)));\n-               while Present (Variant) loop\n-                  Variant_Stmts :=\n-                    Build_Invariant_Checks (Component_List (Variant));\n-                  Var_Loc := Sloc (Variant);\n-                  Append_To (Variant_Alts,\n-                    Make_Case_Statement_Alternative (Var_Loc,\n-                      Discrete_Choices =>\n-                        New_Copy_List (Discrete_Choices (Variant)),\n-                      Statements => Variant_Stmts));\n-\n-                  Next_Non_Pragma (Variant);\n-               end loop;\n-\n-               --  The expression in the case statement is the reference to\n-               --  the discriminant of the target object.\n-\n-               Append_To (Stmts,\n-                 Make_Case_Statement (Var_Loc,\n-                   Expression =>\n-                     Make_Selected_Component (Var_Loc,\n-                      Prefix => New_Occurrence_Of (Object_Entity, Var_Loc),\n-                      Selector_Name => New_Occurrence_Of\n-                        (Entity\n-                          (Name (Variant_Part (Comp_List))), Var_Loc)),\n-                      Alternatives => Variant_Alts));\n-            end;\n-         end if;\n-\n-         return Stmts;\n-      end Build_Invariant_Checks;\n-\n-   --  Start of processing for Build_Record_Invariant_Proc\n-\n-   begin\n-      Invariant_Found := False;\n-      Type_Def := Type_Definition (Parent (R_Type));\n-\n-      if Nkind (Type_Def) = N_Record_Definition\n-        and then not Null_Present (Type_Def)\n-      then\n-         Stmts := Build_Invariant_Checks (Component_List (Type_Def));\n-      else\n-         return Empty;\n-      end if;\n-\n-      if not Invariant_Found then\n-         return Empty;\n-      end if;\n-\n-      --  The name of the invariant procedure reflects the fact that the\n-      --  checks correspond to invariants on the component types. The\n-      --  record type itself may have invariants that will create a separate\n-      --  procedure whose name carries the Invariant suffix.\n-\n-      Proc_Id :=\n-        Make_Defining_Identifier (Loc,\n-           Chars => New_External_Name (Chars (R_Type), \"CInvariant\"));\n-\n-      Proc_Body :=\n-        Make_Subprogram_Body (Loc,\n-          Specification =>\n-            Make_Procedure_Specification (Loc,\n-              Defining_Unit_Name       => Proc_Id,\n-              Parameter_Specifications => New_List (\n-                Make_Parameter_Specification (Loc,\n-                  Defining_Identifier => Object_Entity,\n-                  Parameter_Type      => New_Occurrence_Of (R_Type, Loc)))),\n-\n-          Declarations               => Empty_List,\n-          Handled_Statement_Sequence =>\n-            Make_Handled_Sequence_Of_Statements (Loc,\n-              Statements => Stmts));\n-\n-      Set_Ekind          (Proc_Id, E_Procedure);\n-      Set_Is_Public      (Proc_Id, Is_Public (R_Type));\n-      Set_Is_Internal    (Proc_Id);\n-      Set_Has_Completion (Proc_Id);\n-\n-      return Proc_Body;\n-      --  Insert_After (Nod, Proc_Body);\n-      --  Analyze (Proc_Body);\n-   end Build_Record_Invariant_Proc;\n-\n    ----------------------------\n    -- Build_Slice_Assignment --\n    ----------------------------\n@@ -4680,21 +4287,6 @@ package body Exp_Ch3 is\n          Build_Array_Init_Proc (Base, N);\n       end if;\n \n-      if Has_Invariants (Component_Type (Base))\n-        and then Typ = Base\n-        and then In_Open_Scopes (Scope (Component_Type (Base)))\n-      then\n-         --  Generate component invariant checking procedure. This is only\n-         --  relevant if the array type is within the scope of the component\n-         --  type. Otherwise an array object can only be built using the public\n-         --  subprograms for the component type, and calls to those will have\n-         --  invariant checks. The invariant procedure is only generated for\n-         --  a base type, not a subtype.\n-\n-         Insert_Component_Invariant_Checks\n-           (N, Base, Build_Array_Invariant_Proc (Base, N));\n-      end if;\n-\n       Ghost_Mode := Save_Ghost_Mode;\n    end Expand_Freeze_Array_Type;\n \n@@ -5551,24 +5143,6 @@ package body Exp_Ch3 is\n          end;\n       end if;\n \n-      --  Check whether individual components have a defined invariant, and add\n-      --  the corresponding component invariant checks.\n-\n-      --  Do not create an invariant procedure for some internally generated\n-      --  subtypes, in particular those created for objects of a class-wide\n-      --  type. Such types may have components to which invariant apply, but\n-      --  the corresponding checks will be applied when an object of the parent\n-      --  type is constructed.\n-\n-      --  Such objects will show up in a class-wide postcondition, and the\n-      --  invariant will be checked, if necessary, upon return from the\n-      --  enclosing subprogram.\n-\n-      if not Is_Class_Wide_Equivalent_Type (Typ) then\n-         Insert_Component_Invariant_Checks\n-           (N, Typ, Build_Record_Invariant_Proc (Typ, N));\n-      end if;\n-\n       Ghost_Mode := Save_Ghost_Mode;\n    end Expand_Freeze_Record_Type;\n \n@@ -7476,11 +7050,11 @@ package body Exp_Ch3 is\n \n       elsif Ekind_In (Def_Id, E_Access_Type, E_General_Access_Type) then\n          declare\n-            Loc         : constant Source_Ptr := Sloc (N);\n-            Desig_Type  : constant Entity_Id  := Designated_Type (Def_Id);\n-            Pool_Object : Entity_Id;\n+            Loc        : constant Source_Ptr := Sloc (N);\n+            Desig_Type : constant Entity_Id  := Designated_Type (Def_Id);\n \n             Freeze_Action_Typ : Entity_Id;\n+            Pool_Object       : Entity_Id;\n \n          begin\n             --  Case 1\n@@ -7500,8 +7074,8 @@ package body Exp_Ch3 is\n \n             elsif Has_Storage_Size_Clause (Def_Id) then\n                declare\n-                  DT_Size  : Node_Id;\n                   DT_Align : Node_Id;\n+                  DT_Size  : Node_Id;\n \n                begin\n                   --  For unconstrained composite types we give a size of zero\n@@ -7746,6 +7320,16 @@ package body Exp_Ch3 is\n       Process_Pending_Access_Types (Def_Id);\n       Freeze_Stream_Operations (N, Def_Id);\n \n+      --  Generate the [spec and] body of the invariant procedure tasked with\n+      --  the runtime verification of all invariants that pertain to the type.\n+      --  This includes invariants on the partial and full view, inherited\n+      --  class-wide invariants from parent types or interfaces, and invariants\n+      --  on array elements or record components.\n+\n+      if Has_Invariants (Def_Id) then\n+         Build_Invariant_Procedure_Body (Def_Id);\n+      end if;\n+\n       Ghost_Mode := Save_Ghost_Mode;\n       return Result;\n \n@@ -8164,77 +7748,6 @@ package body Exp_Ch3 is\n       return Is_RTU (S1, System) or else Is_RTU (S1, Ada);\n    end In_Runtime;\n \n-   ---------------------------------------\n-   -- Insert_Component_Invariant_Checks --\n-   ---------------------------------------\n-\n-   procedure Insert_Component_Invariant_Checks\n-     (N   : Node_Id;\n-     Typ  : Entity_Id;\n-     Proc : Node_Id)\n-   is\n-      Loc     : constant Source_Ptr := Sloc (Typ);\n-      Proc_Id : Entity_Id;\n-\n-   begin\n-      if Present (Proc) then\n-         Proc_Id := Defining_Entity (Proc);\n-\n-         if not Has_Invariants (Typ) then\n-            Set_Has_Invariants (Typ);\n-            Set_Is_Invariant_Procedure (Proc_Id);\n-            Set_Invariant_Procedure (Typ, Proc_Id);\n-            Insert_After (N, Proc);\n-            Analyze (Proc);\n-\n-         else\n-\n-            --  Find already created invariant subprogram, insert body of\n-            --  component invariant proc in its body, and add call after\n-            --  other checks.\n-\n-            declare\n-               Bod    : Node_Id;\n-               Inv_Id : constant Entity_Id := Invariant_Procedure (Typ);\n-               Call   : constant Node_Id   :=\n-                 Make_Procedure_Call_Statement (Sloc (N),\n-                   Name                   => New_Occurrence_Of (Proc_Id, Loc),\n-                   Parameter_Associations =>\n-                     New_List\n-                       (New_Occurrence_Of (First_Formal (Inv_Id), Loc)));\n-\n-            begin\n-               --  The invariant  body has not been analyzed yet, so we do a\n-               --  sequential search forward, and retrieve it by name.\n-\n-               Bod := Next (N);\n-               while Present (Bod) loop\n-                  exit when Nkind (Bod) = N_Subprogram_Body\n-                    and then Chars (Defining_Entity (Bod)) = Chars (Inv_Id);\n-                  Next (Bod);\n-               end loop;\n-\n-               --  If the body is not found, it is the case of an invariant\n-               --  appearing on a full declaration in a private part, in\n-               --  which case the type has been frozen but the invariant\n-               --  procedure for the composite type not created yet. Create\n-               --  body now.\n-\n-               if No (Bod) then\n-                  Build_Invariant_Procedure (Typ, Parent (Current_Scope));\n-                  Bod := Unit_Declaration_Node\n-                    (Corresponding_Body (Unit_Declaration_Node (Inv_Id)));\n-               end if;\n-\n-               Append_To (Declarations (Bod), Proc);\n-               Append_To (Statements (Handled_Statement_Sequence (Bod)), Call);\n-               Analyze (Proc);\n-               Analyze (Call);\n-            end;\n-         end if;\n-      end if;\n-   end Insert_Component_Invariant_Checks;\n-\n    ----------------------------\n    -- Initialization_Warning --\n    ----------------------------"}, {"sha": "0e6dc4591c297262baf353e1826722c7dcf5750d", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 1515, "deletions": 0, "changes": 1515, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=3ddfabe34fbcf04822c794f1dc8e1740811ad016", "patch": "@@ -55,12 +55,15 @@ with Sinfo;    use Sinfo;\n with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Ch3;  use Sem_Ch3;\n+with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch7;  use Sem_Ch7;\n with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Ch13; use Sem_Ch13;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n with Snames;   use Snames;\n with Stand;    use Stand;\n+with Stringt;  use Stringt;\n with Tbuild;   use Tbuild;\n with Ttypes;   use Ttypes;\n with Uintp;    use Uintp;\n@@ -3438,6 +3441,1518 @@ package body Exp_Ch7 is\n       Expand_At_End_Handler (HSS, Empty);\n    end Build_Finalizer_Call;\n \n+   ------------------------------------\n+   -- Build_Invariant_Procedure_Body --\n+   ------------------------------------\n+\n+   procedure Build_Invariant_Procedure_Body\n+     (Typ               : Entity_Id;\n+      Partial_Invariant : Boolean := False)\n+   is\n+      Loc : constant Source_Ptr := Sloc (Typ);\n+\n+      Pragmas_Seen : Elist_Id := No_Elist;\n+      --  This list contains all invariant pragmas processed so far. The list\n+      --  is used to avoid generating redundant invariant checks.\n+\n+      Produced_Check : Boolean := False;\n+      --  This flag tracks whether the type has produced at least one invariant\n+      --  check. The flag is used as a sanity check at the end of the routine.\n+\n+      --  NOTE: most of the routines in Build_Invariant_Procedure_Body are\n+      --  intentionally unnested to avoid deep indentation of code.\n+\n+      --  NOTE: all Add_xxx_Invariants routines are reactive. In other words\n+      --  they emit checks, loops (for arrays) and case statements (for record\n+      --  variant parts) only when there are invariants to verify. This keeps\n+      --  the body of the invariant procedure free from useless code.\n+\n+      procedure Add_Array_Component_Invariants\n+        (T      : Entity_Id;\n+         Obj_Id : Entity_Id;\n+         Checks : in out List_Id);\n+      --  Generate an invariant check for each component of array type T.\n+      --  Obj_Id denotes the entity of the _object formal parameter of the\n+      --  invariant procedure. All created checks are added to list Checks.\n+\n+      procedure Add_Interface_Invariants\n+        (T      : Entity_Id;\n+         Obj_Id : Entity_Id;\n+         Checks : in out List_Id);\n+      --  Generate an invariant check for each inherited class-wide invariant\n+      --  coming from all interfaces implemented by type T. Obj_Id denotes the\n+      --  entity of the _object formal parameter of the invariant procedure.\n+      --  All created checks are added to list Checks.\n+\n+      procedure Add_Parent_Invariants\n+        (T      : Entity_Id;\n+         Obj_Id : Entity_Id;\n+         Checks : in out List_Id);\n+      --  Generate an invariant check for each inherited class-wide invariant\n+      --  coming from all parent types of type T. Obj_Id denotes the entity of\n+      --  the _object formal parameter of the invariant procedure. All created\n+      --  checks are added to list Checks.\n+\n+      procedure Add_Record_Component_Invariants\n+        (T      : Entity_Id;\n+         Obj_Id : Entity_Id;\n+         Checks : in out List_Id);\n+      --  Generate an invariant check for each component of record type T.\n+      --  Obj_Id denotes the entity of the _object formal parameter of the\n+      --  invariant procedure. All created checks are added to list Checks.\n+\n+      procedure Add_Type_Invariants\n+        (Priv_Typ  : Entity_Id;\n+         Full_Typ  : Entity_Id;\n+         CRec_Typ  : Entity_Id;\n+         Obj_Id    : Entity_Id;\n+         Checks    : in out List_Id;\n+         Inherit   : Boolean := False;\n+         Priv_Item : Node_Id := Empty);\n+      --  Generate an invariant check for each invariant found in one of the\n+      --  following types (if available):\n+      --\n+      --    Priv_Typ - the partial view of a type\n+      --    Full_Typ - the full view of a type\n+      --    CRec_Typ - the corresponding record of a protected or a task type\n+      --\n+      --  Obj_Id denotes the entity of the _object formal parameter of the\n+      --  invariant procedure. All created checks are added to list Checks.\n+      --  Flag Inherit should be set when generating invariant checks for\n+      --  inherited class-wide invariants. Priv_Item denotes the first rep\n+      --  item of the private type.\n+\n+      procedure Create_Append (L : in out List_Id; N : Node_Id);\n+      --  Append arbitrary node N to list L. If there is no list, create one.\n+\n+      function Is_Untagged_Private_Derivation\n+        (Priv_Typ : Entity_Id;\n+         Full_Typ : Entity_Id) return Boolean;\n+      --  Determine whether private type Priv_Typ and its full view Full_Typ\n+      --  represent an untagged derivation from a private parent.\n+\n+      ------------------------------------\n+      -- Add_Array_Component_Invariants --\n+      ------------------------------------\n+\n+      procedure Add_Array_Component_Invariants\n+        (T      : Entity_Id;\n+         Obj_Id : Entity_Id;\n+         Checks : in out List_Id)\n+      is\n+         Comp_Typ : constant Entity_Id := Component_Type (T);\n+         Dims     : constant Pos       := Number_Dimensions (T);\n+\n+         procedure Process_Array_Component\n+           (Indices     : List_Id;\n+            Comp_Checks : in out List_Id);\n+         --  Generate an invariant check for an array component identified by\n+         --  the indices in list Indices. All created checks are added to list\n+         --  Comp_Checks.\n+\n+         procedure Process_One_Dimension\n+           (Dim        : Pos;\n+            Indices    : List_Id;\n+            Dim_Checks : in out List_Id);\n+         --  Generate a loop over the Nth dimension Dim of an array type. List\n+         --  Indices contains all array indices for the dimension. All created\n+         --  checks are added to list Dim_Checks.\n+\n+         -----------------------------\n+         -- Process_Array_Component --\n+         -----------------------------\n+\n+         procedure Process_Array_Component\n+           (Indices     : List_Id;\n+            Comp_Checks : in out List_Id)\n+         is\n+            Proc_Id : Entity_Id;\n+\n+         begin\n+            if Has_Invariants (Comp_Typ) then\n+               Proc_Id := Invariant_Procedure (Base_Type (Comp_Typ));\n+\n+               --  The component type should have an invariant procedure if it\n+               --  has invariants of its own or inherits class-wide invariants\n+               --  from parent or interface types.\n+\n+               pragma Assert (Present (Proc_Id));\n+\n+               --  Generate:\n+               --    <Comp_Typ>Invariant (_object (<Indices>));\n+\n+               --  Note that the invariant procedure may have a null body if\n+               --  assertions are disabled or Assertion_Polity Ignore is in\n+               --  effect.\n+\n+               if not Has_Null_Body (Proc_Id) then\n+                  Create_Append (Comp_Checks,\n+                    Make_Procedure_Call_Statement (Loc,\n+                      Name                   =>\n+                        New_Occurrence_Of (Proc_Id, Loc),\n+                      Parameter_Associations => New_List (\n+                        Make_Indexed_Component (Loc,\n+                          Prefix      => New_Occurrence_Of (Obj_Id, Loc),\n+                          Expressions => New_Copy_List (Indices)))));\n+               end if;\n+\n+               Produced_Check := True;\n+            end if;\n+\n+            --  In a rare case the designated type of an access component may\n+            --  have an invariant. In this case verify the dereference of the\n+            --  component.\n+\n+            if Is_Access_Type (Comp_Typ)\n+              and then Has_Invariants (Designated_Type (Comp_Typ))\n+            then\n+               Proc_Id :=\n+                 Invariant_Procedure (Base_Type (Designated_Type (Comp_Typ)));\n+\n+               --  The designated type should have an invariant procedure if it\n+               --  has invariants of its own or inherits class-wide invariants\n+               --  from parent or interface types.\n+\n+               pragma Assert (Present (Proc_Id));\n+\n+               --  Generate:\n+               --    if _object (<Indexes>) /= null then\n+               --       <Desig_Comp_Typ>Invariant (_object (<Indices>).all);\n+               --    end if;\n+\n+               --  Note that the invariant procedure may have a null body if\n+               --  assertions are disabled or Assertion_Polity Ignore is in\n+               --  effect.\n+\n+               if not Has_Null_Body (Proc_Id) then\n+                  Create_Append (Comp_Checks,\n+                    Make_If_Statement (Loc,\n+                      Condition       =>\n+                        Make_Op_Ne (Loc,\n+                          Left_Opnd  =>\n+                            Make_Indexed_Component (Loc,\n+                              Prefix      => New_Occurrence_Of (Obj_Id, Loc),\n+                              Expressions => New_Copy_List (Indices)),\n+                          Right_Opnd => Make_Null (Loc)),\n+\n+                      Then_Statements => New_List (\n+                        Make_Procedure_Call_Statement (Loc,\n+                          Name                   =>\n+                            New_Occurrence_Of (Proc_Id, Loc),\n+\n+                          Parameter_Associations => New_List (\n+                            Make_Explicit_Dereference (Loc,\n+                              Prefix =>\n+                                Make_Indexed_Component (Loc,\n+                                  Prefix      =>\n+                                    New_Occurrence_Of (Obj_Id, Loc),\n+                                  Expressions =>\n+                                    New_Copy_List (Indices))))))));\n+               end if;\n+\n+               Produced_Check := True;\n+            end if;\n+         end Process_Array_Component;\n+\n+         ---------------------------\n+         -- Process_One_Dimension --\n+         ---------------------------\n+\n+         procedure Process_One_Dimension\n+           (Dim        : Pos;\n+            Indices    : List_Id;\n+            Dim_Checks : in out List_Id)\n+         is\n+            Comp_Checks : List_Id := No_List;\n+            Index       : Entity_Id;\n+\n+         begin\n+            --  Generate the invariant checks for the array component after all\n+            --  dimensions have produced their respective loops.\n+\n+            if Dim > Dims then\n+               Process_Array_Component\n+                 (Indices     => Indices,\n+                  Comp_Checks => Dim_Checks);\n+\n+            --  Otherwise create a loop for the current dimension\n+\n+            else\n+               --  Create a new loop variable for each dimension\n+\n+               Index :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars => New_External_Name ('I', Dim));\n+               Append_To (Indices, New_Occurrence_Of (Index, Loc));\n+\n+               Process_One_Dimension\n+                 (Dim        => Dim + 1,\n+                  Indices    => Indices,\n+                  Dim_Checks => Comp_Checks);\n+\n+               --  Generate:\n+               --    for I<Dim> in _object'Range (<Dim>) loop\n+               --       <Comp_Checks>\n+               --    end loop;\n+\n+               --  Note that the invariant procedure may have a null body if\n+               --  assertions are disabled or Assertion_Polity Ignore is in\n+               --  effect.\n+\n+               if Present (Comp_Checks) then\n+                  Create_Append (Dim_Checks,\n+                    Make_Implicit_Loop_Statement (T,\n+                      Identifier       => Empty,\n+                      Iteration_Scheme =>\n+                        Make_Iteration_Scheme (Loc,\n+                          Loop_Parameter_Specification =>\n+                            Make_Loop_Parameter_Specification (Loc,\n+                              Defining_Identifier         => Index,\n+                              Discrete_Subtype_Definition =>\n+                                Make_Attribute_Reference (Loc,\n+                                  Prefix         =>\n+                                    New_Occurrence_Of (Obj_Id, Loc),\n+                                  Attribute_Name => Name_Range,\n+                                  Expressions    => New_List (\n+                                    Make_Integer_Literal (Loc, Dim))))),\n+\n+                      Statements => Comp_Checks));\n+               end if;\n+            end if;\n+         end Process_One_Dimension;\n+\n+      --  Start of processing for Add_Array_Component_Invariants\n+\n+      begin\n+         Process_One_Dimension\n+           (Dim        => 1,\n+            Indices    => New_List,\n+            Dim_Checks => Checks);\n+      end Add_Array_Component_Invariants;\n+\n+      ------------------------------\n+      -- Add_Interface_Invariants --\n+      ------------------------------\n+\n+      procedure Add_Interface_Invariants\n+        (T      : Entity_Id;\n+         Obj_Id : Entity_Id;\n+         Checks : in out List_Id)\n+      is\n+         Iface_Elmt : Elmt_Id;\n+         Ifaces     : Elist_Id;\n+\n+      begin\n+         if Is_Tagged_Type (T) then\n+            Collect_Interfaces (T, Ifaces);\n+\n+            --  Process the class-wide invariants of all implemented interfaces\n+\n+            Iface_Elmt := First_Elmt (Ifaces);\n+            while Present (Iface_Elmt) loop\n+               Add_Type_Invariants\n+                 (Priv_Typ => Empty,\n+                  Full_Typ => Node (Iface_Elmt),\n+                  CRec_Typ => Empty,\n+                  Obj_Id   => Obj_Id,\n+                  Checks   => Checks,\n+                  Inherit  => True);\n+\n+               Next_Elmt (Iface_Elmt);\n+            end loop;\n+         end if;\n+      end Add_Interface_Invariants;\n+\n+      ---------------------------\n+      -- Add_Parent_Invariants --\n+      ---------------------------\n+\n+      procedure Add_Parent_Invariants\n+        (T      : Entity_Id;\n+         Obj_Id : Entity_Id;\n+         Checks : in out List_Id)\n+      is\n+         Dummy_1 : Entity_Id;\n+         Dummy_2 : Entity_Id;\n+\n+         Curr_Typ : Entity_Id;\n+         --  The entity of the current type being examined\n+\n+         Full_Typ : Entity_Id;\n+         --  The full view of Par_Typ\n+\n+         Par_Typ : Entity_Id;\n+         --  The entity of the parent type\n+\n+         Priv_Typ : Entity_Id;\n+         --  The partial view of Par_Typ\n+\n+      begin\n+         --  Climb the parent type chain\n+\n+         Curr_Typ := T;\n+         loop\n+            --  Do not consider subtypes as they inherit the invariants from\n+            --  their base types.\n+\n+            Par_Typ := Base_Type (Etype (Curr_Typ));\n+\n+            --  Stop the climb once the root of the parent chain is reached\n+\n+            exit when Curr_Typ = Par_Typ;\n+\n+            --  Process the class-wide invariants of the parent type\n+\n+            Get_Views (Par_Typ, Priv_Typ, Full_Typ, Dummy_1, Dummy_2);\n+\n+            Add_Type_Invariants\n+              (Priv_Typ => Priv_Typ,\n+               Full_Typ => Full_Typ,\n+               CRec_Typ => Empty,\n+               Obj_Id   => Obj_Id,\n+               Checks   => Checks,\n+               Inherit  => True);\n+\n+            Curr_Typ := Par_Typ;\n+         end loop;\n+      end Add_Parent_Invariants;\n+\n+      -------------------------------------\n+      -- Add_Record_Component_Invariants --\n+      -------------------------------------\n+\n+      procedure Add_Record_Component_Invariants\n+        (T      : Entity_Id;\n+         Obj_Id : Entity_Id;\n+         Checks : in out List_Id)\n+      is\n+         procedure Process_Component_List\n+           (Comp_List : Node_Id;\n+            CL_Checks : in out List_Id);\n+         --  Generate invariant checks for all record components found in\n+         --  component list Comp_List, including variant parts. All created\n+         --  checks are added to list CL_Checks.\n+\n+         procedure Process_Record_Component\n+           (Comp_Id     : Entity_Id;\n+            Comp_Checks : in out List_Id);\n+         --  Generate an invariant check for a record component identified by\n+         --  Comp_Id. All created checks are added to list Comp_Checks.\n+\n+         ----------------------------\n+         -- Process_Component_List --\n+         ----------------------------\n+\n+         procedure Process_Component_List\n+           (Comp_List : Node_Id;\n+            CL_Checks : in out List_Id)\n+         is\n+            Comp       : Node_Id;\n+            Var        : Node_Id;\n+            Var_Alts   : List_Id := No_List;\n+            Var_Checks : List_Id := No_List;\n+            Var_Stmts  : List_Id;\n+\n+            Produced_Variant_Check : Boolean := False;\n+            --  This flag tracks whether the component has produced at least\n+            --  one invariant check.\n+\n+         begin\n+            --  Traverse the component items\n+\n+            Comp := First (Component_Items (Comp_List));\n+            while Present (Comp) loop\n+               if Nkind (Comp) = N_Component_Declaration then\n+\n+                  --  Generate the component invariant check\n+\n+                  Process_Record_Component\n+                    (Comp_Id     => Defining_Entity (Comp),\n+                     Comp_Checks => CL_Checks);\n+               end if;\n+\n+               Next (Comp);\n+            end loop;\n+\n+            --  Traverse the variant part\n+\n+            if Present (Variant_Part (Comp_List)) then\n+               Var := First (Variants (Variant_Part (Comp_List)));\n+               while Present (Var) loop\n+                  Var_Checks := No_List;\n+\n+                  --  Generate invariant checks for all components and variant\n+                  --  parts that qualify.\n+\n+                  Process_Component_List\n+                    (Comp_List => Component_List (Var),\n+                     CL_Checks => Var_Checks);\n+\n+                  --  The components of the current variant produced at least\n+                  --  one invariant check.\n+\n+                  if Present (Var_Checks) then\n+                     Var_Stmts := Var_Checks;\n+                     Produced_Variant_Check := True;\n+\n+                  --  Otherwise there are either no components with invariants,\n+                  --  assertions are disabled, or Assertion_Policy Ignore is in\n+                  --  effect.\n+\n+                  else\n+                     Var_Stmts := New_List (Make_Null_Statement (Loc));\n+                  end if;\n+\n+                  Create_Append (Var_Alts,\n+                    Make_Case_Statement_Alternative (Loc,\n+                      Discrete_Choices =>\n+                        New_Copy_List (Discrete_Choices (Var)),\n+                      Statements       => Var_Stmts));\n+\n+                  Next (Var);\n+               end loop;\n+\n+               --  Create a case statement which verifies the invariant checks\n+               --  of a particular component list depending on the discriminant\n+               --  values only when there is at least one real invariant check.\n+\n+               if Produced_Variant_Check then\n+                  Create_Append (CL_Checks,\n+                    Make_Case_Statement (Loc,\n+                      Expression   =>\n+                        Make_Selected_Component (Loc,\n+                          Prefix        => New_Occurrence_Of (Obj_Id, Loc),\n+                          Selector_Name =>\n+                            New_Occurrence_Of\n+                              (Entity (Name (Variant_Part (Comp_List))), Loc)),\n+                      Alternatives => Var_Alts));\n+               end if;\n+            end if;\n+         end Process_Component_List;\n+\n+         ------------------------------\n+         -- Process_Record_Component --\n+         ------------------------------\n+\n+         procedure Process_Record_Component\n+           (Comp_Id     : Entity_Id;\n+            Comp_Checks : in out List_Id)\n+         is\n+            Comp_Typ : constant Entity_Id := Etype (Comp_Id);\n+            Proc_Id  : Entity_Id;\n+\n+            Produced_Component_Check : Boolean := False;\n+            --  This flag tracks whether the component has produced at least\n+            --  one invariant check.\n+\n+         begin\n+            --  Nothing to do for internal component _parent. Note that it is\n+            --  not desirable to check whether the component comes from source\n+            --  because protected type components are relocated to an internal\n+            --  corresponding record, but still need processing.\n+\n+            if Chars (Comp_Id) = Name_uParent then\n+               return;\n+            end if;\n+\n+            --  Verify the invariant of the component. Note that an access\n+            --  type may have an invariant when it acts as the full view of a\n+            --  private type and the invariant appears on the partial view. In\n+            --  this case verify the access value itself.\n+\n+            if Has_Invariants (Comp_Typ) then\n+               Proc_Id := Invariant_Procedure (Base_Type (Comp_Typ));\n+\n+               --  The component type should have an invariant procedure if it\n+               --  has invariants of its own or inherits class-wide invariants\n+               --  from parent or interface types.\n+\n+               pragma Assert (Present (Proc_Id));\n+\n+               --  Generate:\n+               --    <Comp_Typ>Invariant (T (_object).<Comp_Id>);\n+\n+               --  Note that the invariant procedure may have a null body if\n+               --  assertions are disabled or Assertion_Polity Ignore is in\n+               --  effect.\n+\n+               if not Has_Null_Body (Proc_Id) then\n+                  Create_Append (Comp_Checks,\n+                    Make_Procedure_Call_Statement (Loc,\n+                      Name                   =>\n+                        New_Occurrence_Of (Proc_Id, Loc),\n+                      Parameter_Associations => New_List (\n+                        Make_Selected_Component (Loc,\n+                          Prefix        =>\n+                            Unchecked_Convert_To\n+                              (T, New_Occurrence_Of (Obj_Id, Loc)),\n+                          Selector_Name =>\n+                            New_Occurrence_Of (Comp_Id, Loc)))));\n+               end if;\n+\n+               Produced_Check           := True;\n+               Produced_Component_Check := True;\n+            end if;\n+\n+            --  In a rare case the designated type of an access component may\n+            --  have a invariant. In this case verify the dereference of the\n+            --  component.\n+\n+            if Is_Access_Type (Comp_Typ)\n+              and then Has_Invariants (Designated_Type (Comp_Typ))\n+            then\n+               Proc_Id :=\n+                 Invariant_Procedure (Base_Type (Designated_Type (Comp_Typ)));\n+\n+               --  The designated type should have an invariant procedure if it\n+               --  has invariants of its own or inherits class-wide invariants\n+               --  from parent or interface types.\n+\n+               pragma Assert (Present (Proc_Id));\n+\n+               --  Generate:\n+               --    if T (_object).<Comp_Id> /= null then\n+               --       <Desig_Comp_Typ>Invariant (T (_object).<Comp_Id>.all);\n+               --    end if;\n+\n+               --  Note that the invariant procedure may have a null body if\n+               --  assertions are disabled or Assertion_Polity Ignore is in\n+               --  effect.\n+\n+               if not Has_Null_Body (Proc_Id) then\n+                  Create_Append (Comp_Checks,\n+                    Make_If_Statement (Loc,\n+                      Condition       =>\n+                        Make_Op_Ne (Loc,\n+                          Left_Opnd  =>\n+                            Make_Selected_Component (Loc,\n+                              Prefix        =>\n+                                Unchecked_Convert_To\n+                                  (T, New_Occurrence_Of (Obj_Id, Loc)),\n+                              Selector_Name =>\n+                                New_Occurrence_Of (Comp_Id, Loc)),\n+                          Right_Opnd => Make_Null (Loc)),\n+\n+                      Then_Statements => New_List (\n+                        Make_Procedure_Call_Statement (Loc,\n+                          Name                   =>\n+                            New_Occurrence_Of (Proc_Id, Loc),\n+\n+                          Parameter_Associations => New_List (\n+                            Make_Explicit_Dereference (Loc,\n+                              Prefix =>\n+                                Make_Selected_Component (Loc,\n+                                  Prefix        =>\n+                                    Unchecked_Convert_To\n+                                      (T, New_Occurrence_Of (Obj_Id, Loc)),\n+                                  Selector_Name =>\n+                                    New_Occurrence_Of (Comp_Id, Loc))))))));\n+               end if;\n+\n+               Produced_Check           := True;\n+               Produced_Component_Check := True;\n+            end if;\n+\n+            if Produced_Component_Check and then Has_Unchecked_Union (T) then\n+               Error_Msg_NE\n+                 (\"invariants cannot be checked on components of \"\n+                  & \"unchecked_union type &?\", Comp_Id, T);\n+            end if;\n+         end Process_Record_Component;\n+\n+         --  Local variables\n+\n+         Comps : Node_Id;\n+         Def   : Node_Id;\n+\n+      --  Start of processing for Add_Record_Component_Invariants\n+\n+      begin\n+         --  An untagged derived type inherits the components of its parent\n+         --  type. In order to avoid creating redundant invariant checks, do\n+         --  not process the components now. Instead wait until the ultimate\n+         --  parent of the untagged derivation chain is reached.\n+\n+         if not Is_Untagged_Derivation (T) then\n+            Def := Type_Definition (Parent (T));\n+\n+            if Nkind (Def) = N_Derived_Type_Definition then\n+               Def := Record_Extension_Part (Def);\n+            end if;\n+\n+            pragma Assert (Nkind (Def) = N_Record_Definition);\n+            Comps := Component_List (Def);\n+\n+            if Present (Comps) then\n+               Process_Component_List\n+                 (Comp_List => Comps,\n+                  CL_Checks => Checks);\n+            end if;\n+         end if;\n+      end Add_Record_Component_Invariants;\n+\n+      -------------------------\n+      -- Add_Type_Invariants --\n+      -------------------------\n+\n+      procedure Add_Type_Invariants\n+        (Priv_Typ  : Entity_Id;\n+         Full_Typ  : Entity_Id;\n+         CRec_Typ  : Entity_Id;\n+         Obj_Id    : Entity_Id;\n+         Checks    : in out List_Id;\n+         Inherit   : Boolean := False;\n+         Priv_Item : Node_Id := Empty)\n+      is\n+         procedure Add_Invariant (Prag : Node_Id);\n+         --  Create a runtime check to verify the invariant exression of pragma\n+         --  Prag. All generated code is added to list Checks.\n+\n+         procedure Process_Type (T : Entity_Id; Stop_Item : Node_Id := Empty);\n+         --  Generate invariant checks for type T by inspecting the rep item\n+         --  chain of the type. Stop_Item denotes a rep item which once seen\n+         --  will stop the inspection.\n+\n+         -------------------\n+         -- Add_Invariant --\n+         -------------------\n+\n+         procedure Add_Invariant (Prag : Node_Id) is\n+            Rep_Typ : Entity_Id;\n+            --  The replacement type used in the substitution of the current\n+            --  instance of a type with the _object formal parameter.\n+\n+            procedure Replace_Type_Ref (N : Node_Id);\n+            --  Substitute the occurrence of a type name denoted by N with a\n+            --  reference to the _object formal parameter.\n+\n+            ----------------------\n+            -- Replace_Type_Ref --\n+            ----------------------\n+\n+            procedure Replace_Type_Ref (N : Node_Id) is\n+               Nloc : constant Source_Ptr := Sloc (N);\n+               Ref  : Node_Id;\n+\n+            begin\n+               --  Decorate the reference to Ref_Typ even though it may be\n+               --  rewritten further down. This is done for two reasons:\n+\n+               --    1) ASIS has all necessary semantic information in the\n+               --    original tree.\n+\n+               --    2) Routines which examine properties of the Original_Node\n+               --    have some semantic information.\n+\n+               if Nkind (N) = N_Identifier then\n+                  Set_Entity (N, Rep_Typ);\n+                  Set_Etype  (N, Rep_Typ);\n+\n+               elsif Nkind (N) = N_Selected_Component then\n+                  Analyze (Prefix (N));\n+                  Set_Entity (Selector_Name (N), Rep_Typ);\n+                  Set_Etype  (Selector_Name (N), Rep_Typ);\n+               end if;\n+\n+               --  Do not alter the tree for ASIS. As a result all references\n+               --  to Ref_Typ remain as is, but they have sufficent semantic\n+               --  information.\n+\n+               if not ASIS_Mode then\n+\n+                  --  Perform the following substitution:\n+\n+                  --    Ref_Typ  -->  _object\n+\n+                  Ref := Make_Identifier (Nloc, Chars (Obj_Id));\n+                  Set_Entity (Ref, Obj_Id);\n+                  Set_Etype  (Ref, Rep_Typ);\n+\n+                  --  When the pragma denotes a class-wide invariant, perform\n+                  --  the following substitution:\n+\n+                  --    Rep_Typ  -->  Rep_Typ'Class (_object)\n+\n+                  if Class_Present (Prag) then\n+                     Ref :=\n+                       Make_Type_Conversion (Nloc,\n+                         Subtype_Mark =>\n+                           Make_Attribute_Reference (Nloc,\n+                             Prefix         =>\n+                               New_Occurrence_Of (Rep_Typ, Nloc),\n+                             Attribute_Name => Name_Class),\n+                         Expression   => Ref);\n+                  end if;\n+\n+                  Rewrite (N, Ref);\n+                  Set_Comes_From_Source (N, True);\n+               end if;\n+            end Replace_Type_Ref;\n+\n+            procedure Replace_Type_Refs is\n+              new Replace_Type_References_Generic (Replace_Type_Ref);\n+\n+            --  Local variables\n+\n+            Asp  : constant Node_Id    := Corresponding_Aspect (Prag);\n+            Nam  : constant Name_Id    := Original_Aspect_Pragma_Name (Prag);\n+            Ploc : constant Source_Ptr := Sloc (Prag);\n+\n+            Arg1      : Node_Id;\n+            Arg2      : Node_Id;\n+            Arg3      : Node_Id;\n+            ASIS_Expr : Node_Id;\n+            Assoc     : List_Id;\n+            Expr      : Node_Id;\n+            Str       : String_Id;\n+\n+         --  Start of processing for Add_Invariant\n+\n+         begin\n+            --  Nothing to do if the pragma was already processed\n+\n+            if Contains (Pragmas_Seen, Prag) then\n+               return;\n+            end if;\n+\n+            --  Extract the arguments of the invariant pragma\n+\n+            Arg1 := First (Pragma_Argument_Associations (Prag));\n+            Arg2 := Next (Arg1);\n+            Arg3 := Next (Arg2);\n+\n+            Arg1 := Get_Pragma_Arg (Arg1);\n+            Arg2 := Get_Pragma_Arg (Arg2);\n+\n+            --  The pragma applies to the partial view\n+\n+            if Present (Priv_Typ) and then Entity (Arg1) = Priv_Typ then\n+               Rep_Typ := Priv_Typ;\n+\n+            --  The pragma applies to the full view\n+\n+            elsif Present (Full_Typ) and then Entity (Arg1) = Full_Typ then\n+               Rep_Typ := Full_Typ;\n+\n+            --  Otherwise the pragma applies to a parent type in which case it\n+            --  will be processed at a later stage by Add_Parent_Invariants or\n+            --  Add_Interface_Invariants.\n+\n+            else\n+               return;\n+            end if;\n+\n+            --  Nothing to do when the caller requests the processing of all\n+            --  inherited class-wide invariants, but the pragma does not fall\n+            --  in this category.\n+\n+            if Inherit and then not Class_Present (Prag) then\n+               return;\n+            end if;\n+\n+            Expr := New_Copy_Tree (Arg2);\n+\n+            --  Substitute all references to type Rep_Typ with references to\n+            --  the _object formal parameter.\n+\n+            Replace_Type_Refs (Expr, Rep_Typ);\n+\n+            --  Additional processing for non-class-wide invariants\n+\n+            if not Inherit then\n+\n+               --  Preanalyze the invariant expression to detect errors and at\n+               --  the same time capture the visibility of the proper package\n+               --  part.\n+\n+               --  Historical note: the old implementation of invariants used\n+               --  node N as the parent, but a package specification as parent\n+               --  of an expression is bizarre.\n+\n+               Set_Parent (Expr, Parent (Arg2));\n+               Preanalyze_Assert_Expression (Expr, Any_Boolean);\n+\n+               --  If the pragma comes from an aspect specification, replace\n+               --  the saved expression because all type references must be\n+               --  substituted for the call to Preanalyze_Spec_Expression in\n+               --  Check_Aspect_At_xxx routines.\n+\n+               if Present (Asp) then\n+                  Set_Entity (Identifier (Asp), New_Copy_Tree (Expr));\n+               end if;\n+\n+               --  Analyze the original invariant expression for ASIS\n+\n+               if ASIS_Mode then\n+                  ASIS_Expr := Empty;\n+\n+                  if Comes_From_Source (Prag) then\n+                     ASIS_Expr := Arg2;\n+                  elsif Present (Asp) then\n+                     ASIS_Expr := Expression (Asp);\n+                  end if;\n+\n+                  if Present (ASIS_Expr) then\n+                     Replace_Type_Refs (ASIS_Expr, Rep_Typ);\n+                     Preanalyze_Assert_Expression (ASIS_Expr, Any_Boolean);\n+                  end if;\n+               end if;\n+\n+               --  A class-wide invariant may be inherited in a separate unit,\n+               --  where the corresponding expression cannot be resolved by\n+               --  visibility, because it refers to a local function. Propagate\n+               --  semantic information to the original representation item, to\n+               --  be used when an invariant procedure for a derived type is\n+               --  constructed.\n+\n+               --  ??? Unclear how to handle class-wide invariants that are not\n+               --  function calls.\n+\n+               if Class_Present (Prag)\n+                 and then Nkind (Expr) = N_Function_Call\n+                 and then Nkind (Arg2) = N_Indexed_Component\n+               then\n+                  Rewrite (Arg2,\n+                    Make_Function_Call (Ploc,\n+                      Name                   =>\n+                        New_Occurrence_Of (Entity (Name (Expr)), Ploc),\n+                      Parameter_Associations => Expressions (Arg2)));\n+               end if;\n+            end if;\n+\n+            --  The invariant is ignored, nothing left to do\n+\n+            if Is_Ignored (Prag) then\n+               null;\n+\n+            --  Otherwise the invariant is checked. Build a Check pragma to\n+            --  verify the expression at runtime.\n+\n+            else\n+               Assoc := New_List (\n+                 Make_Pragma_Argument_Association (Ploc,\n+                   Expression => Make_Identifier (Ploc, Nam)),\n+                 Make_Pragma_Argument_Association (Ploc,\n+                   Expression => Expr));\n+\n+               --  Handle the String argument (if any)\n+\n+               if Present (Arg3) then\n+                  Str := Strval (Get_Pragma_Arg (Arg3));\n+\n+                  --  When inheriting an invariant, modify the message from\n+                  --  \"failed invariant\" to \"failed inherited invariant\".\n+\n+                  if Inherit then\n+                     String_To_Name_Buffer (Str);\n+\n+                     if Name_Buffer (1 .. 16) = \"failed invariant\" then\n+                        Insert_Str_In_Name_Buffer (\"inherited \", 8);\n+                        Str := String_From_Name_Buffer;\n+                     end if;\n+                  end if;\n+\n+                  Append_To (Assoc,\n+                    Make_Pragma_Argument_Association (Ploc,\n+                      Expression => Make_String_Literal (Ploc, Str)));\n+               end if;\n+\n+               --  Generate:\n+               --    pragma Check (<Nam>, <Expr>, <Str>);\n+\n+               Create_Append (Checks,\n+                 Make_Pragma (Ploc,\n+                   Pragma_Identifier            =>\n+                     Make_Identifier (Ploc, Name_Check),\n+                   Pragma_Argument_Associations => Assoc));\n+            end if;\n+\n+            --  Output an info message when inheriting an invariant and the\n+            --  listing option is enabled.\n+\n+            if Inherit and Opt.List_Inherited_Aspects then\n+               Error_Msg_Sloc := Sloc (Prag);\n+               Error_Msg_N\n+                 (\"info: & inherits `Invariant''Class` aspect from #?L?\", Typ);\n+            end if;\n+\n+            --  Add the pragma to the list of processed pragmas\n+\n+            Append_New_Elmt (Prag, Pragmas_Seen);\n+            Produced_Check := True;\n+         end Add_Invariant;\n+\n+         ------------------\n+         -- Process_Type --\n+         ------------------\n+\n+         procedure Process_Type\n+           (T         : Entity_Id;\n+            Stop_Item : Node_Id := Empty)\n+         is\n+            Rep_Item : Node_Id;\n+\n+         begin\n+            Rep_Item := First_Rep_Item (T);\n+            while Present (Rep_Item) loop\n+               if Nkind (Rep_Item) = N_Pragma\n+                 and then Pragma_Name (Rep_Item) = Name_Invariant\n+               then\n+                  --  Stop the traversal of the rep item chain once a specific\n+                  --  item is encountered.\n+\n+                  if Present (Stop_Item) and then Rep_Item = Stop_Item then\n+                     exit;\n+\n+                  --  Otherwise generate an invariant check\n+\n+                  else\n+                     Add_Invariant (Rep_Item);\n+                  end if;\n+               end if;\n+\n+               Next_Rep_Item (Rep_Item);\n+            end loop;\n+         end Process_Type;\n+\n+      --  Start of processing for Add_Type_Invariants\n+\n+      begin\n+         --  Process the invariants of the partial view\n+\n+         if Present (Priv_Typ) then\n+            Process_Type (Priv_Typ);\n+         end if;\n+\n+         --  Process the invariants of the full view\n+\n+         if Present (Full_Typ) then\n+            Process_Type (Full_Typ, Stop_Item => Priv_Item);\n+\n+            --  Process the elements of an array type\n+\n+            if Is_Array_Type (Full_Typ) then\n+               Add_Array_Component_Invariants (Full_Typ, Obj_Id, Checks);\n+\n+            --  Process the components of a record type\n+\n+            elsif Ekind (Full_Typ) = E_Record_Type then\n+               Add_Record_Component_Invariants (Full_Typ, Obj_Id, Checks);\n+            end if;\n+         end if;\n+\n+         --  Process the components of a corresponding record type\n+\n+         if Present (CRec_Typ) then\n+            Add_Record_Component_Invariants (CRec_Typ, Obj_Id, Checks);\n+         end if;\n+      end Add_Type_Invariants;\n+\n+      -------------------\n+      -- Create_Append --\n+      -------------------\n+\n+      procedure Create_Append (L : in out List_Id; N : Node_Id) is\n+      begin\n+         if No (L) then\n+            L := New_List;\n+         end if;\n+\n+         Append_To (L, N);\n+      end Create_Append;\n+\n+      ------------------------------------\n+      -- Is_Untagged_Private_Derivation --\n+      ------------------------------------\n+\n+      function Is_Untagged_Private_Derivation\n+        (Priv_Typ : Entity_Id;\n+         Full_Typ : Entity_Id) return Boolean\n+      is\n+      begin\n+         return\n+           Present (Priv_Typ)\n+             and then Is_Untagged_Derivation (Priv_Typ)\n+             and then Is_Private_Type (Etype (Priv_Typ))\n+             and then Present (Full_Typ)\n+             and then Is_Itype (Full_Typ);\n+      end Is_Untagged_Private_Derivation;\n+\n+      --  Local variables\n+\n+      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n+\n+      Dummy        : Entity_Id;\n+      Priv_Item    : Node_Id;\n+      Proc_Body    : Node_Id;\n+      Proc_Body_Id : Entity_Id;\n+      Proc_Decl    : Node_Id;\n+      Proc_Id      : Entity_Id;\n+      Stmts        : List_Id := No_List;\n+\n+      CRec_Typ : Entity_Id;\n+      --  The corresponding record type of Full_Typ\n+\n+      Full_Proc : Entity_Id;\n+      --  The entity of the \"full\" invariant procedure\n+\n+      Full_Typ : Entity_Id;\n+      --  The full view of the working type\n+\n+      Freeze_Typ : Entity_Id;\n+      --  The freeze type whose freeze node carries the invariant procedure\n+      --  body. This is either the partial or the full view of the working\n+      --  type.\n+\n+      Obj_Id : Entity_Id;\n+      --  The _object formal parameter of the invariant procedure\n+\n+      Part_Proc : Entity_Id;\n+      --  The entity of the \"partial\" invariant procedure\n+\n+      Priv_Typ : Entity_Id;\n+      --  The partial view of the working type\n+\n+      Work_Typ : Entity_Id;\n+      --  The working type\n+\n+   --  Start of processing for Build_Invariant_Procedure_Body\n+\n+   begin\n+      Work_Typ := Typ;\n+\n+      --  The input type denotes the implementation base type of a constrained\n+      --  array type. Work with the first subtype as all invariant pragmas are\n+      --  on its rep item chain.\n+\n+      if Ekind (Work_Typ) = E_Array_Type and then Is_Itype (Work_Typ) then\n+         Work_Typ := First_Subtype (Work_Typ);\n+\n+      --  The input type denotes the corresponding record type of a protected\n+      --  or task type. Work with the concurrent type because the corresponding\n+      --  record type may not be visible to clients of the type.\n+\n+      elsif Ekind (Work_Typ) = E_Record_Type\n+        and then Is_Concurrent_Record_Type (Work_Typ)\n+      then\n+         Work_Typ := Corresponding_Concurrent_Type (Work_Typ);\n+      end if;\n+\n+      --  The type must either have invariants of its own, inherit class-wide\n+      --  invariants from parent types or interfaces, or be an array or record\n+      --  type whose components have invariants.\n+\n+      pragma Assert (Has_Invariants (Work_Typ));\n+\n+      --  Nothing to do for interface types as their class-wide invariants are\n+      --  inherited by implementing types.\n+\n+      if Is_Interface (Work_Typ) then\n+         return;\n+      end if;\n+\n+      --  Obtain both views of the type\n+\n+      Get_Views (Work_Typ, Priv_Typ, Full_Typ, Dummy, CRec_Typ);\n+\n+      --  The caller requests a body for the partial invariant procedure\n+\n+      if Partial_Invariant then\n+         Full_Proc := Invariant_Procedure (Work_Typ);\n+         Proc_Id   := Partial_Invariant_Procedure (Work_Typ);\n+\n+         --  The \"full\" invariant procedure body was already created\n+\n+         if Present (Full_Proc)\n+           and then Present\n+                      (Corresponding_Body (Unit_Declaration_Node (Full_Proc)))\n+         then\n+            --  This scenario happens only when the type is an untagged\n+            --  derivation from a private parent and the underlying full\n+            --  view was processed before the partial view.\n+\n+            pragma Assert\n+              (Is_Untagged_Private_Derivation (Priv_Typ, Full_Typ));\n+\n+            --  Nothing to do because the processing of the underlying full\n+            --  view already checked the invariants of the partial view.\n+\n+            return;\n+         end if;\n+\n+         --  Create a declaration for the \"partial\" invariant procedure if it\n+         --  is not available.\n+\n+         if No (Proc_Id) then\n+            Build_Invariant_Procedure_Declaration\n+              (Typ               => Work_Typ,\n+               Partial_Invariant => True);\n+\n+            Proc_Id := Partial_Invariant_Procedure (Work_Typ);\n+         end if;\n+\n+      --  The caller requests a body for the \"full\" invariant procedure\n+\n+      else\n+         Proc_Id   := Invariant_Procedure (Work_Typ);\n+         Part_Proc := Partial_Invariant_Procedure (Work_Typ);\n+\n+         --  Create a declaration for the \"full\" invariant procedure if it is\n+         --  not available.\n+\n+         if No (Proc_Id) then\n+            Build_Invariant_Procedure_Declaration (Work_Typ);\n+            Proc_Id := Invariant_Procedure (Work_Typ);\n+         end if;\n+      end if;\n+\n+      --  At this point there should be an invariant procedure declaration\n+\n+      pragma Assert (Present (Proc_Id));\n+      Proc_Decl := Unit_Declaration_Node (Proc_Id);\n+\n+      --  Nothing to do if the invariant procedure already has a body\n+\n+      if Present (Corresponding_Body (Proc_Decl)) then\n+         return;\n+      end if;\n+\n+      --  The working type may be subject to pragma Ghost. Set the mode now to\n+      --  ensure that the invariant procedure is properly marked as Ghost.\n+\n+      Set_Ghost_Mode_From_Entity (Work_Typ);\n+\n+      Obj_Id := First_Formal (Proc_Id);\n+\n+      --  The \"partial\" invariant procedure verifies the invariants of the\n+      --  partial view only.\n+\n+      if Partial_Invariant then\n+         pragma Assert (Present (Priv_Typ));\n+         Freeze_Typ := Priv_Typ;\n+\n+         --  Emulate the environment of the invariant procedure by installing\n+         --  its scope and formal parameters. Note that this is not need, but\n+         --  having the scope of the invariant procedure installed helps with\n+         --  the detection of invariant-related errors.\n+\n+         Push_Scope (Proc_Id);\n+         Install_Formals (Proc_Id);\n+\n+         Add_Type_Invariants\n+           (Priv_Typ => Priv_Typ,\n+            Full_Typ => Empty,\n+            CRec_Typ => Empty,\n+            Obj_Id   => Obj_Id,\n+            Checks   => Stmts);\n+\n+         End_Scope;\n+\n+      --  Otherwise the \"full\" invariant procedure verifies the invariants of\n+      --  the full view, all array or record components, as well as class-wide\n+      --  invariants inherited from parent types or interfaces. In addition, it\n+      --  indirectly verifies the invariants of the partial view by calling the\n+      --  \"partial\" invariant procedure.\n+\n+      else\n+         pragma Assert (Present (Full_Typ));\n+         Freeze_Typ := Full_Typ;\n+\n+         --  Check the invariants of the partial view by calling the \"partial\"\n+         --  invariant procedure. Generate:\n+\n+         --    <Work_Typ>Partial_Invariant (_object);\n+\n+         if Present (Part_Proc) then\n+            Create_Append (Stmts,\n+              Make_Procedure_Call_Statement (Loc,\n+                Name                   => New_Occurrence_Of (Part_Proc, Loc),\n+                Parameter_Associations => New_List (\n+                  New_Occurrence_Of (Obj_Id, Loc))));\n+\n+            Produced_Check := True;\n+         end if;\n+\n+         Priv_Item := Empty;\n+\n+         --  Derived subtypes do not have a partial view\n+\n+         if Present (Priv_Typ) then\n+\n+            --  The processing of the \"full\" invariant procedure intentionally\n+            --  skips the partial view because a) this may result in changes of\n+            --  visibility and b) lead to duplicate checks. However, when the\n+            --  full view is the underlying full view of an untagged derived\n+            --  type whose parent type is private, partial invariants appear on\n+            --  the rep item chain of the partial view only.\n+\n+            --    package Pack_1 is\n+            --       type Root ... is private;\n+            --    private\n+            --       <full view of Root>\n+            --    end Pack_1;\n+\n+            --    with Pack_1;\n+            --    package Pack_2 is\n+            --       type Child is new Pack_1.Root with Type_Invariant => ...;\n+            --       <underlying full view of Child>\n+            --    end Pack_2;\n+\n+            --  As a result, the processing of the full view must also consider\n+            --  all invariants of the partial view.\n+\n+            if Is_Untagged_Private_Derivation (Priv_Typ, Full_Typ) then\n+               null;\n+\n+            --  Otherwise the invariants of the partial view are ignored\n+\n+            else\n+               --  Note that the rep item chain is shared between the partial\n+               --  and full views of a type. To avoid processing the invariants\n+               --  of the partial view, signal the logic to stop when the first\n+               --  rep item of the partial view has been reached.\n+\n+               Priv_Item := First_Rep_Item (Priv_Typ);\n+\n+               --  Ignore the invariants of the partial view by eliminating the\n+               --  view.\n+\n+               Priv_Typ := Empty;\n+            end if;\n+         end if;\n+\n+         --  Process the invariants of the full view and in certain cases those\n+         --  of the partial view. This also handles any invariants on array or\n+         --  record components.\n+\n+         Add_Type_Invariants\n+           (Priv_Typ  => Priv_Typ,\n+            Full_Typ  => Full_Typ,\n+            CRec_Typ  => CRec_Typ,\n+            Obj_Id    => Obj_Id,\n+            Checks    => Stmts,\n+            Priv_Item => Priv_Item);\n+\n+         --  Process the inherited class-wide invariants of all parent types.\n+         --  This also handles any invariants on record components.\n+\n+         Add_Parent_Invariants (Full_Typ, Obj_Id, Stmts);\n+\n+         --  Process the inherited class-wide invariants of all implemented\n+         --  interface types.\n+\n+         Add_Interface_Invariants (Full_Typ, Obj_Id, Stmts);\n+      end if;\n+\n+      --  At this point there should be at least one invariant check. If this\n+      --  is not the case, then the invariant-related flags were not properly\n+      --  set, or there is a missing invariant procedure on one of the array\n+      --  or record components.\n+\n+      pragma Assert (Produced_Check);\n+\n+      --  Account for the case where assertions are disabled or all invariant\n+      --  checks are subject to Assertion_Policy Ignore. Produce a completing\n+      --  empty body.\n+\n+      if No (Stmts) then\n+         Stmts := New_List (Make_Null_Statement (Loc));\n+      end if;\n+\n+      Proc_Body :=\n+        Make_Subprogram_Body (Loc,\n+          Specification                =>\n+            Copy_Subprogram_Spec (Parent (Proc_Id)),\n+          Declarations                 => Empty_List,\n+            Handled_Statement_Sequence =>\n+              Make_Handled_Sequence_Of_Statements (Loc,\n+                Statements => Stmts));\n+      Proc_Body_Id := Defining_Entity (Proc_Body);\n+\n+      --  Link both spec and body to avoid generating duplicates\n+\n+      Set_Corresponding_Body (Proc_Decl, Proc_Body_Id);\n+      Set_Corresponding_Spec (Proc_Body, Proc_Id);\n+\n+      Append_Freeze_Action (Freeze_Typ, Proc_Body);\n+      Ghost_Mode := Save_Ghost_Mode;\n+   end Build_Invariant_Procedure_Body;\n+\n+   -------------------------------------------\n+   -- Build_Invariant_Procedure_Declaration --\n+   -------------------------------------------\n+\n+   procedure Build_Invariant_Procedure_Declaration\n+     (Typ               : Entity_Id;\n+      Partial_Invariant : Boolean := False)\n+   is\n+      Loc : constant Source_Ptr := Sloc (Typ);\n+\n+      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n+\n+      Proc_Id  : Entity_Id;\n+      Typ_Decl : Node_Id;\n+\n+      CRec_Typ : Entity_Id;\n+      --  The corresponding record type of Full_Typ\n+\n+      Full_Base : Entity_Id;\n+      --  The base type of Full_Typ\n+\n+      Full_Typ : Entity_Id;\n+      --  The full view of working type\n+\n+      Obj_Id : Entity_Id;\n+      --  The _object formal parameter of the invariant procedure\n+\n+      Priv_Typ : Entity_Id;\n+      --  The partial view of working type\n+\n+      Work_Typ : Entity_Id;\n+      --  The working type\n+\n+   begin\n+      Work_Typ := Typ;\n+\n+      --  The input type denotes the implementation base type of a constrained\n+      --  array type. Work with the first subtype as all invariant pragmas are\n+      --  on its rep item chain.\n+\n+      if Ekind (Work_Typ) = E_Array_Type and then Is_Itype (Work_Typ) then\n+         Work_Typ := First_Subtype (Work_Typ);\n+\n+      --  The input denotes the corresponding record type of a protected or a\n+      --  task type. Work with the concurrent type because the corresponding\n+      --  record type may not be visible to clients of the type.\n+\n+      elsif Ekind (Work_Typ) = E_Record_Type\n+        and then Is_Concurrent_Record_Type (Work_Typ)\n+      then\n+         Work_Typ := Corresponding_Concurrent_Type (Work_Typ);\n+      end if;\n+\n+      --  The type must either have invariants of its own, inherit class-wide\n+      --  invariants from parent or interface types, or be an array or record\n+      --  type whose components have invariants.\n+\n+      pragma Assert (Has_Invariants (Work_Typ));\n+\n+      --  Nothing to do for interface types as their class-wide invariants are\n+      --  inherited by implementing types.\n+\n+      if Is_Interface (Work_Typ) then\n+         return;\n+\n+      --  Nothing to do if the type already has a \"partial\" invariant procedure\n+\n+      elsif Partial_Invariant then\n+         if Present (Partial_Invariant_Procedure (Work_Typ)) then\n+            return;\n+         end if;\n+\n+      --  Nothing to do if the type already has a \"full\" invariant procedure\n+\n+      elsif Present (Invariant_Procedure (Work_Typ)) then\n+         return;\n+      end if;\n+\n+      --  The working type may be subject to pragma Ghost. Set the mode now to\n+      --  ensure that the invariant procedure is properly marked as Ghost.\n+\n+      Set_Ghost_Mode_From_Entity (Work_Typ);\n+\n+      --  The caller requests the declaration of the \"partial\" invariant\n+      --  procedure.\n+\n+      if Partial_Invariant then\n+         Proc_Id :=\n+           Make_Defining_Identifier (Loc,\n+             Chars =>\n+               New_External_Name (Chars (Work_Typ), \"Partial_Invariant\"));\n+\n+         Set_Ekind (Proc_Id, E_Procedure);\n+         Set_Is_Partial_Invariant_Procedure (Proc_Id);\n+         Set_Partial_Invariant_Procedure (Work_Typ, Proc_Id);\n+\n+      --  Otherwise the caller requests the declaration of the \"full\" invariant\n+      --  procedure.\n+\n+      else\n+         Proc_Id :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => New_External_Name (Chars (Work_Typ), \"Invariant\"));\n+\n+         Set_Ekind (Proc_Id, E_Procedure);\n+         Set_Is_Invariant_Procedure (Proc_Id);\n+         Set_Invariant_Procedure (Work_Typ, Proc_Id);\n+      end if;\n+\n+      --  The invariant procedure requires debug info when the invariants are\n+      --  subject to Source Coverage Obligations.\n+\n+      if Opt.Generate_SCO then\n+         Set_Needs_Debug_Info (Proc_Id);\n+      end if;\n+\n+      --  Mark the invariant procedure explicitly as Ghost because it does not\n+      --  come from source.\n+\n+      if Ghost_Mode > None then\n+         Set_Is_Ghost_Entity (Proc_Id);\n+      end if;\n+\n+      --  Obtain all views of the input type\n+\n+      Get_Views (Work_Typ, Priv_Typ, Full_Typ, Full_Base, CRec_Typ);\n+\n+      --  Associate the invariant procedure with all views\n+\n+      Propagate_Invariant_Attributes (Priv_Typ,  From_Typ => Work_Typ);\n+      Propagate_Invariant_Attributes (Full_Typ,  From_Typ => Work_Typ);\n+      Propagate_Invariant_Attributes (Full_Base, From_Typ => Work_Typ);\n+      Propagate_Invariant_Attributes (CRec_Typ,  From_Typ => Work_Typ);\n+\n+      --  The declaration of the invariant procedure is inserted after the\n+      --  declaration of the partial view as this allows for proper external\n+      --  visibility.\n+\n+      if Present (Priv_Typ) then\n+         Typ_Decl := Declaration_Node (Priv_Typ);\n+\n+      --  Derived types with the full view as parent do not have a partial\n+      --  view. Insert the invariant procedure after the derived type.\n+\n+      else\n+         Typ_Decl := Declaration_Node (Full_Typ);\n+      end if;\n+\n+      --  The type should have a declarative node\n+\n+      pragma Assert (Present (Typ_Decl));\n+\n+      --  Create the formal parameter which emulates the variable-like behavior\n+      --  of the current type instance.\n+\n+      Obj_Id := Make_Defining_Identifier (Loc, Chars => Name_uObject);\n+      Set_Ekind (Obj_Id, E_In_Parameter);\n+\n+      --  Generate:\n+      --    procedure <Work_Typ>[Partial_]Invariant (_object : <Work_Typ>);\n+\n+      Insert_After_And_Analyze (Typ_Decl,\n+        Make_Subprogram_Declaration (Loc,\n+          Specification =>\n+            Make_Procedure_Specification (Loc,\n+              Defining_Unit_Name       => Proc_Id,\n+              Parameter_Specifications => New_List (\n+                Make_Parameter_Specification (Loc,\n+                  Defining_Identifier => Obj_Id,\n+                  Parameter_Type      =>\n+                    New_Occurrence_Of (Work_Typ, Loc))))));\n+\n+      Ghost_Mode := Save_Ghost_Mode;\n+   end Build_Invariant_Procedure_Declaration;\n+\n    ---------------------\n    -- Build_Late_Proc --\n    ---------------------"}, {"sha": "ed654164d1eee7c174e8dd6c3368574ccf3cc410", "filename": "gcc/ada/exp_ch7.ads", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fexp_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fexp_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.ads?ref=3ddfabe34fbcf04822c794f1dc8e1740811ad016", "patch": "@@ -118,9 +118,24 @@ package Exp_Ch7 is\n    --  finalization master must be analyzed. Insertion_Node is the insertion\n    --  point before which the master is to be inserted.\n \n+   procedure Build_Invariant_Procedure_Body\n+     (Typ               : Entity_Id;\n+      Partial_Invariant : Boolean := False);\n+   --  Create the body of the procedure which verifies the invariants of type\n+   --  Typ at runtime. Flag Partial_Invariant should be set when Typ denotes a\n+   --  private type, otherwise it is assumed that Typ denotes the full view of\n+   --  a private type.\n+\n+   procedure Build_Invariant_Procedure_Declaration\n+     (Typ               : Entity_Id;\n+      Partial_Invariant : Boolean := False);\n+   --  Create the declaration of the procedure which verifies the invariants of\n+   --  type Typ at runtime. Flag Partial_Invariant should be set when building\n+   --  the invariant procedure for a private type.\n+\n    procedure Build_Late_Proc (Typ : Entity_Id; Nam : Name_Id);\n-   --  Build one controlling procedure when a late body overrides one of\n-   --  the controlling operations.\n+   --  Build one controlling procedure when a late body overrides one of the\n+   --  controlling operations.\n \n    procedure Build_Object_Declarations\n      (Data        : out Finalization_Exception_Data;"}, {"sha": "34f2150b37d2b6379cbffa345ff52eb5c4c777de", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=3ddfabe34fbcf04822c794f1dc8e1740811ad016", "patch": "@@ -1526,12 +1526,6 @@ package body Exp_Ch9 is\n       Set_Stored_Constraint             (Rec_Ent, No_Elist);\n       Cdecls := New_List;\n \n-      --  Propagate type invariants to the corresponding record type\n-\n-      Set_Has_Invariants                (Rec_Ent, Has_Invariants (Ctyp));\n-      Set_Has_Inheritable_Invariants    (Rec_Ent,\n-        Has_Inheritable_Invariants (Ctyp));\n-\n       --  Use discriminals to create list of discriminants for record, and\n       --  create new discriminals for use in default expressions, etc. It is\n       --  worth noting that a task discriminant gives rise to 5 entities;"}, {"sha": "a0ec32566494e1786dd7a4f5d5989de439ce01f8", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=3ddfabe34fbcf04822c794f1dc8e1740811ad016", "patch": "@@ -6405,30 +6405,19 @@ package body Exp_Util is\n    -------------------------\n \n    function Make_Invariant_Call (Expr : Node_Id) return Node_Id is\n-      Loc : constant Source_Ptr := Sloc (Expr);\n-      Typ : Entity_Id;\n+      Loc     : constant Source_Ptr := Sloc (Expr);\n+      Typ     : constant Entity_Id  := Base_Type (Etype (Expr));\n+      Proc_Id : Entity_Id;\n \n    begin\n-      Typ := Etype (Expr);\n+      pragma Assert (Has_Invariants (Typ));\n \n-      --  Subtypes may be subject to invariants coming from their respective\n-      --  base types. The subtype may be fully or partially private.\n-\n-      if Ekind_In (Typ, E_Array_Subtype,\n-                        E_Private_Subtype,\n-                        E_Record_Subtype,\n-                        E_Record_Subtype_With_Private)\n-      then\n-         Typ := Base_Type (Typ);\n-      end if;\n-\n-      pragma Assert\n-        (Has_Invariants (Typ) and then Present (Invariant_Procedure (Typ)));\n+      Proc_Id := Invariant_Procedure (Typ);\n+      pragma Assert (Present (Proc_Id));\n \n       return\n         Make_Procedure_Call_Statement (Loc,\n-          Name                   =>\n-            New_Occurrence_Of (Invariant_Procedure (Typ), Loc),\n+          Name                   => New_Occurrence_Of (Proc_Id, Loc),\n           Parameter_Associations => New_List (Relocate_Node (Expr)));\n    end Make_Invariant_Call;\n "}, {"sha": "a0277c84b1d6183d3229ef4d1a85a43ffbf164e3", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=3ddfabe34fbcf04822c794f1dc8e1740811ad016", "patch": "@@ -2290,6 +2290,25 @@ package body Freeze is\n                Set_Has_Unchecked_Union (Arr);\n             end if;\n \n+            --  The array type requires its own invariant procedure in order to\n+            --  verify the component invariant over all elements.\n+\n+            if Has_Invariants (Component_Type (Arr))\n+              or else\n+                (Is_Access_Type (Component_Type (Arr))\n+                  and then Has_Invariants\n+                             (Designated_Type (Component_Type (Arr))))\n+            then\n+               Set_Has_Own_Invariants (Arr);\n+\n+               --  The array type is an implementation base type. Propagate the\n+               --  same property to the first subtype.\n+\n+               if Is_Itype (Arr) then\n+                  Set_Has_Own_Invariants (First_Subtype (Arr));\n+               end if;\n+            end if;\n+\n             --  Warn for pragma Pack overriding foreign convention\n \n             if Has_Foreign_Convention (Ctyp)\n@@ -4165,7 +4184,8 @@ package body Freeze is\n                Freeze_And_Append (Corresponding_Remote_Type (Rec), N, Result);\n             end if;\n \n-            --  Check for controlled components and unchecked unions.\n+            --  Check for controlled components, unchecked unions, and type\n+            --  invariants.\n \n             Comp := First_Component (Rec);\n             while Present (Comp) loop\n@@ -4194,6 +4214,22 @@ package body Freeze is\n                   Set_Has_Unchecked_Union (Rec);\n                end if;\n \n+               --  The record type requires its own invariant procedure in\n+               --  order to verify the invariant of each individual component.\n+               --  Do not consider internal components such as _parent because\n+               --  parent class-wide invariants are always inherited.\n+\n+               if Comes_From_Source (Comp)\n+                 and then\n+                   (Has_Invariants (Etype (Comp))\n+                     or else\n+                       (Is_Access_Type (Etype (Comp))\n+                         and then Has_Invariants\n+                                    (Designated_Type (Etype (Comp)))))\n+               then\n+                  Set_Has_Own_Invariants (Rec);\n+               end if;\n+\n                --  Scan component declaration for likely misuses of current\n                --  instance, either in a constraint or a default expression.\n \n@@ -5224,8 +5260,7 @@ package body Freeze is\n               and then not Is_Tagged_Type (E)\n             then\n                Error_Msg_NE\n-                 (\"Type_Invariant''Class cannot be specified for &\",\n-                  Prag, E);\n+                 (\"Type_Invariant''Class cannot be specified for &\", Prag, E);\n                Error_Msg_N\n                  (\"\\can only be specified for a tagged type\", Prag);\n             end if;"}, {"sha": "1319f87f6fe498c9ae1011d576f0254f73503951", "filename": "gcc/ada/pprint.adb", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fpprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fpprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpprint.adb?ref=3ddfabe34fbcf04822c794f1dc8e1740811ad016", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2008-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2008-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -542,13 +542,28 @@ package body Pprint is\n             when N_Parameter_Association =>\n                return Expr_Name (Explicit_Actual_Parameter (Expr));\n \n-            when N_Type_Conversion | N_Unchecked_Type_Conversion =>\n+            when N_Type_Conversion =>\n \n                --  Most conversions are not very interesting (used inside\n                --  expanded checks to convert to larger ranges), so skip them.\n \n                return Expr_Name (Expression (Expr));\n \n+            when N_Unchecked_Type_Conversion =>\n+\n+               --  Only keep the type conversion in complex cases\n+\n+               if not Is_Scalar_Type (Etype (Expr))\n+                 or else not Is_Scalar_Type (Etype (Expression (Expr)))\n+                 or else Is_Modular_Integer_Type (Etype (Expr))\n+                         /= Is_Modular_Integer_Type (Etype (Expression (Expr)))\n+               then\n+                  return Expr_Name (Subtype_Mark (Expr)) &\n+                    \"(\" & Expr_Name (Expression (Expr)) & \")\";\n+               else\n+                  return Expr_Name (Expression (Expr));\n+               end if;\n+\n             when N_Indexed_Component =>\n                if Take_Prefix then\n                   return"}, {"sha": "3e1ddb48a94e420045af3090edd56c063c5babc3", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 33, "deletions": 630, "changes": 663, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=3ddfabe34fbcf04822c794f1dc8e1740811ad016", "patch": "@@ -62,7 +62,6 @@ with Sinput;   use Sinput;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Sinfo;    use Sinfo;\n-with Stringt;  use Stringt;\n with Targparm; use Targparm;\n with Ttypes;   use Ttypes;\n with Tbuild;   use Tbuild;\n@@ -8080,576 +8079,6 @@ package body Sem_Ch13 is\n       return Prag;\n    end Build_Export_Import_Pragma;\n \n-   -------------------------------------------\n-   -- Build_Invariant_Procedure_Declaration --\n-   -------------------------------------------\n-\n-   function Build_Invariant_Procedure_Declaration\n-     (Typ : Entity_Id) return Node_Id\n-   is\n-      Loc    : constant Source_Ptr := Sloc (Typ);\n-      Decl   : Node_Id;\n-      Obj_Id : Entity_Id;\n-      SId    : Entity_Id;\n-\n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n-   begin\n-      --  Check for duplicate definitions\n-\n-      if Has_Invariants (Typ) and then Present (Invariant_Procedure (Typ)) then\n-         return Empty;\n-      end if;\n-\n-      --  The related type may be subject to pragma Ghost. Set the mode now to\n-      --  ensure that the invariant procedure is properly marked as Ghost.\n-\n-      Set_Ghost_Mode_From_Entity (Typ);\n-\n-      SId :=\n-        Make_Defining_Identifier (Loc,\n-          Chars => New_External_Name (Chars (Typ), \"Invariant\"));\n-      Set_Has_Invariants (Typ);\n-      Set_Ekind (SId, E_Procedure);\n-      Set_Etype (SId, Standard_Void_Type);\n-      Set_Is_Invariant_Procedure (SId);\n-      Set_Invariant_Procedure (Typ, SId);\n-\n-      --  Source Coverage Obligations might be attached to the invariant\n-      --  expression this procedure evaluates, and we need debug info to be\n-      --  able to assess the coverage achieved by evaluations.\n-\n-      if Opt.Generate_SCO then\n-         Set_Needs_Debug_Info (SId);\n-      end if;\n-\n-      --  Mark the invariant procedure explicitly as Ghost because it does not\n-      --  come from source.\n-\n-      if Ghost_Mode > None then\n-         Set_Is_Ghost_Entity (SId);\n-      end if;\n-\n-      Obj_Id := Make_Defining_Identifier (Loc, New_Internal_Name ('I'));\n-      Set_Etype (Obj_Id, Typ);\n-\n-      Decl :=\n-        Make_Subprogram_Declaration (Loc,\n-          Make_Procedure_Specification (Loc,\n-            Defining_Unit_Name       => SId,\n-            Parameter_Specifications => New_List (\n-              Make_Parameter_Specification (Loc,\n-                Defining_Identifier => Obj_Id,\n-                Parameter_Type      => New_Occurrence_Of (Typ, Loc)))));\n-\n-      Ghost_Mode := Save_Ghost_Mode;\n-\n-      return Decl;\n-   end Build_Invariant_Procedure_Declaration;\n-\n-   -------------------------------\n-   -- Build_Invariant_Procedure --\n-   -------------------------------\n-\n-   --  The procedure that is constructed here has the form\n-\n-   --  procedure typInvariant (Ixxx : typ) is\n-   --  begin\n-   --     pragma Check (Invariant, exp, \"failed invariant from xxx\");\n-   --     pragma Check (Invariant, exp, \"failed invariant from xxx\");\n-   --     ...\n-   --     pragma Check (Invariant, exp, \"failed inherited invariant from xxx\");\n-   --     ...\n-   --  end typInvariant;\n-\n-   procedure Build_Invariant_Procedure (Typ : Entity_Id; N : Node_Id) is\n-      procedure Add_Invariants\n-        (T       : Entity_Id;\n-         Obj_Id  : Entity_Id;\n-         Stmts   : in out List_Id;\n-         Inherit : Boolean);\n-      --  Appends statements to Stmts for any invariants in the rep item chain\n-      --  of the given type. If Inherit is False, then we only process entries\n-      --  on the chain for the type Typ. If Inherit is True, then we ignore any\n-      --  Invariant aspects, but we process all Invariant'Class aspects, adding\n-      --  \"inherited\" to the exception message and generating an informational\n-      --  message about the inheritance of an invariant.\n-\n-      --------------------\n-      -- Add_Invariants --\n-      --------------------\n-\n-      procedure Add_Invariants\n-        (T       : Entity_Id;\n-         Obj_Id  : Entity_Id;\n-         Stmts   : in out List_Id;\n-         Inherit : Boolean)\n-      is\n-         procedure Add_Invariant (Prag : Node_Id);\n-         --  Create a runtime check to verify the exression of invariant pragma\n-         --  Prag. All generated code is added to list Stmts.\n-\n-         -------------------\n-         -- Add_Invariant --\n-         -------------------\n-\n-         procedure Add_Invariant (Prag : Node_Id) is\n-            procedure Replace_Type_Reference (N : Node_Id);\n-            --  Replace a single occurrence N of the subtype name with a\n-            --  reference to the formal of the predicate function. N can be an\n-            --  identifier referencing the subtype, or a selected component,\n-            --  representing an appropriately qualified occurrence of the\n-            --  subtype name.\n-\n-            procedure Replace_Type_References is\n-              new Replace_Type_References_Generic (Replace_Type_Reference);\n-            --  Traverse an expression replacing all occurrences of the subtype\n-            --  name with appropriate references to the formal of the predicate\n-            --  function. Note that we must ensure that the type and entity\n-            --  information is properly set in the replacement node, since we\n-            --  will do a Preanalyze call of this expression without proper\n-            --  visibility of the procedure argument.\n-\n-            ----------------------------\n-            -- Replace_Type_Reference --\n-            ----------------------------\n-\n-            --  Note: See comments in Add_Predicates.Replace_Type_Reference\n-            --  regarding handling of Sloc and Comes_From_Source.\n-\n-            procedure Replace_Type_Reference (N : Node_Id) is\n-               Nloc : constant Source_Ptr := Sloc (N);\n-\n-            begin\n-               --  Add semantic information to node to be rewritten, for ASIS\n-               --  navigation needs.\n-\n-               if Nkind (N) = N_Identifier then\n-                  Set_Entity (N, T);\n-                  Set_Etype  (N, T);\n-\n-               elsif Nkind (N) = N_Selected_Component then\n-                  Analyze (Prefix (N));\n-                  Set_Entity (Selector_Name (N), T);\n-                  Set_Etype  (Selector_Name (N), T);\n-               end if;\n-\n-               --  Invariant'Class, replace with T'Class (obj)\n-\n-               if Class_Present (Prag) then\n-\n-                  --  In ASIS mode, an inherited item is already analyzed,\n-                  --  and the replacement has been done, so do not repeat\n-                  --  the transformation to prevent a malformed tree.\n-\n-                  if ASIS_Mode\n-                    and then Nkind (Parent (N)) = N_Attribute_Reference\n-                    and then Attribute_Name (Parent (N)) = Name_Class\n-                  then\n-                     null;\n-\n-                  else\n-                     Rewrite (N,\n-                       Make_Type_Conversion (Nloc,\n-                         Subtype_Mark =>\n-                           Make_Attribute_Reference (Nloc,\n-                             Prefix         => New_Occurrence_Of (T, Nloc),\n-                             Attribute_Name => Name_Class),\n-                         Expression   =>\n-                           Make_Identifier (Nloc, Chars (Obj_Id))));\n-\n-                     Set_Entity (Expression (N), Obj_Id);\n-                     Set_Etype  (Expression (N), Typ);\n-                  end if;\n-\n-               --  Invariant, replace with obj\n-\n-               else\n-                  Rewrite (N, Make_Identifier (Nloc, Chars (Obj_Id)));\n-                  Set_Entity (N, Obj_Id);\n-                  Set_Etype  (N, Typ);\n-               end if;\n-\n-               Set_Comes_From_Source (N, True);\n-            end Replace_Type_Reference;\n-\n-            --  Local variables\n-\n-            Asp   : constant Node_Id    := Corresponding_Aspect (Prag);\n-            Nam   : constant Name_Id    := Original_Aspect_Pragma_Name (Prag);\n-            Ploc  : constant Source_Ptr := Sloc (Prag);\n-            Arg1  : Node_Id;\n-            Arg2  : Node_Id;\n-            Arg3  : Node_Id;\n-            Assoc : List_Id;\n-            Expr  : Node_Id;\n-            Str   : String_Id;\n-\n-         --  Start of processing for Add_Invariant\n-\n-         begin\n-            --  Extract the arguments of the invariant pragma\n-\n-            Arg1 := First (Pragma_Argument_Associations (Prag));\n-            Arg2 := Next (Arg1);\n-            Arg3 := Next (Arg2);\n-\n-            Arg1 := Get_Pragma_Arg (Arg1);\n-            Arg2 := Get_Pragma_Arg (Arg2);\n-\n-            --  The caller requests processing of all Invariant'Class pragmas,\n-            --  but the current pragma does not fall in this category. Return\n-            --  as there is nothing left to do.\n-\n-            if Inherit then\n-               if not Class_Present (Prag) then\n-                  return;\n-               end if;\n-\n-            --  Otherwise the pragma must apply to the current type\n-\n-            elsif Entity (Arg1) /= T then\n-               return;\n-            end if;\n-\n-            Expr := New_Copy_Tree (Arg2);\n-\n-            --  Replace all occurrences of the type's name with references to\n-            --  the formal parameter of the invariant procedure.\n-\n-            Replace_Type_References (Expr, T);\n-\n-            --  If the invariant pragma comes from an aspect, replace the saved\n-            --  expression because we need the subtype references replaced for\n-            --  the calls to Preanalyze_Spec_Expression in Check_Aspect_At_xxx\n-            --  routines. This is not done for interited class-wide invariants\n-            --  because the original pragma of the parent type must remain\n-            --  unchanged.\n-\n-            if not Inherit and then Present (Asp) then\n-               Set_Entity (Identifier (Asp), New_Copy_Tree (Expr));\n-            end if;\n-\n-            --  Preanalyze the invariant expression to capture the visibility\n-            --  of the proper package part. In general the expression is not\n-            --  fully analyzed until the body of the invariant procedure is\n-            --  analyzed at the end of the private part, but that yields the\n-            --  wrong visibility.\n-\n-            --  Historical note: we used to set N as the parent, but a package\n-            --  specification as the parent of an expression is bizarre.\n-\n-            Set_Parent (Expr, Parent (Arg2));\n-            Preanalyze_Assert_Expression (Expr, Any_Boolean);\n-\n-            --  Both modifications performed below are not done for inherited\n-            --  class-wide invariants because the origial aspect/pragma of the\n-            --  parent type must remain unchanged.\n-\n-            if not Inherit then\n-\n-               --  A class-wide invariant may be inherited in a separate unit,\n-               --  where the corresponding expression cannot be resolved by\n-               --  visibility, because it refers to a local function. Propagate\n-               --  semantic information to the original representation item, to\n-               --  be used when an invariant procedure for a derived type is\n-               --  constructed.\n-\n-               --  ??? Unclear how to handle class-wide invariants that are not\n-               --  function calls.\n-\n-               if Class_Present (Prag)\n-                 and then Nkind (Expr) = N_Function_Call\n-                 and then Nkind (Arg2) = N_Indexed_Component\n-               then\n-                  Rewrite (Arg2,\n-                    Make_Function_Call (Ploc,\n-                      Name                   =>\n-                        New_Occurrence_Of (Entity (Name (Expr)), Ploc),\n-                      Parameter_Associations => Expressions (Arg2)));\n-               end if;\n-\n-               --  In ASIS mode, even if assertions are not enabled, we must\n-               --  analyze the original expression in the aspect specification\n-               --  because it is part of the original tree.\n-\n-               if ASIS_Mode and then Present (Asp) then\n-                  declare\n-                     Asp_Expr : constant Node_Id := Expression (Asp);\n-\n-                  begin\n-                     Replace_Type_References (Asp_Expr, T);\n-                     Preanalyze_Assert_Expression (Asp_Expr, Any_Boolean);\n-                  end;\n-               end if;\n-            end if;\n-\n-            --  An ignored invariant must not generate a runtime check. Add a\n-            --  null statement to ensure that the invariant procedure does get\n-            --  a completing body.\n-\n-            if No (Stmts) then\n-               Stmts := Empty_List;\n-            end if;\n-\n-            if Is_Ignored (Prag) then\n-               Append_To (Stmts, Make_Null_Statement (Ploc));\n-\n-            --  Otherwise the invariant is checked. Build a Check pragma to\n-            --  verify the expression at runtime.\n-\n-            else\n-               Assoc := New_List (\n-                 Make_Pragma_Argument_Association (Ploc,\n-                   Expression => Make_Identifier (Ploc, Nam)),\n-                 Make_Pragma_Argument_Association (Ploc,\n-                   Expression => Expr));\n-\n-               --  Handle the String argument (if any)\n-\n-               if Present (Arg3) then\n-                  Str := Strval (Get_Pragma_Arg (Arg3));\n-\n-                  --  When inheriting an invariant, modify the message from\n-                  --  \"failed invariant\" to \"failed inherited invariant\".\n-\n-                  if Inherit then\n-                     String_To_Name_Buffer (Str);\n-\n-                     if Name_Buffer (1 .. 16) = \"failed invariant\" then\n-                        Insert_Str_In_Name_Buffer (\"inherited \", 8);\n-                        Str := String_From_Name_Buffer;\n-                     end if;\n-                  end if;\n-\n-                  Append_To (Assoc,\n-                    Make_Pragma_Argument_Association (Ploc,\n-                      Expression => Make_String_Literal (Ploc, Str)));\n-               end if;\n-\n-               --  Generate:\n-               --    pragma Check (Nam, Expr, Str);\n-\n-               Append_To (Stmts,\n-                 Make_Pragma (Ploc,\n-                   Pragma_Identifier            =>\n-                     Make_Identifier (Ploc, Name_Check),\n-                   Pragma_Argument_Associations => Assoc));\n-            end if;\n-\n-            --  Output an info message when inheriting an invariant and the\n-            --  listing option is enabled.\n-\n-            if Inherit and Opt.List_Inherited_Aspects then\n-               Error_Msg_Sloc := Sloc (Prag);\n-               Error_Msg_N\n-                 (\"info: & inherits `Invariant''Class` aspect from #?L?\", Typ);\n-            end if;\n-         end Add_Invariant;\n-\n-         --  Local variables\n-\n-         Ritem : Node_Id;\n-\n-      --  Start of processing for Add_Invariants\n-\n-      begin\n-         Ritem := First_Rep_Item (T);\n-         while Present (Ritem) loop\n-            if Nkind (Ritem) = N_Pragma\n-              and then Pragma_Name (Ritem) = Name_Invariant\n-            then\n-               Add_Invariant (Ritem);\n-            end if;\n-\n-            Next_Rep_Item (Ritem);\n-         end loop;\n-      end Add_Invariants;\n-\n-      --  Local variables\n-\n-      Loc        : constant Source_Ptr := Sloc (Typ);\n-      Priv_Decls : constant List_Id    := Private_Declarations (N);\n-      Vis_Decls  : constant List_Id    := Visible_Declarations (N);\n-\n-      Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n-\n-      PBody : Node_Id;\n-      PDecl : Node_Id;\n-      SId   : Entity_Id;\n-      Spec  : Node_Id;\n-      Stmts : List_Id;\n-\n-      Obj_Id : Node_Id;\n-      --  The entity of the formal for the procedure\n-\n-   --  Start of processing for Build_Invariant_Procedure\n-\n-   begin\n-      --  The related type may be subject to pragma Ghost. Set the mode now to\n-      --  ensure that the invariant procedure is properly marked as Ghost.\n-\n-      Set_Ghost_Mode_From_Entity (Typ);\n-\n-      Stmts := No_List;\n-      PDecl := Empty;\n-      PBody := Empty;\n-      SId   := Empty;\n-\n-      --  If the aspect specification exists for some view of the type, the\n-      --  declaration for the procedure has been created.\n-\n-      if Has_Invariants (Typ) then\n-         SId := Invariant_Procedure (Typ);\n-      end if;\n-\n-      --  If the body is already present, nothing to do. This will occur when\n-      --  the type is already frozen, which is the case when the invariant\n-      --  appears in a private part, and the freezing takes place before the\n-      --  final pass over full declarations.\n-\n-      --  See Exp_Ch3.Insert_Component_Invariant_Checks for details.\n-\n-      if Present (SId) then\n-         PDecl := Unit_Declaration_Node (SId);\n-\n-         if Present (PDecl)\n-           and then Nkind (PDecl) = N_Subprogram_Declaration\n-           and then Present (Corresponding_Body (PDecl))\n-         then\n-            Ghost_Mode := Save_Ghost_Mode;\n-            return;\n-         end if;\n-\n-      else\n-         PDecl := Build_Invariant_Procedure_Declaration (Typ);\n-      end if;\n-\n-      --  Recover formal of procedure, for use in the calls to invariant\n-      --  functions (including inherited ones).\n-\n-      Obj_Id :=\n-        Defining_Identifier\n-          (First (Parameter_Specifications (Specification (PDecl))));\n-\n-      --  Add invariants for the current type\n-\n-      Add_Invariants\n-        (T       => Typ,\n-         Obj_Id  => Obj_Id,\n-         Stmts   => Stmts,\n-         Inherit => False);\n-\n-      --  Add invariants for parent types\n-\n-      declare\n-         Current_Typ : Entity_Id;\n-         Parent_Typ  : Entity_Id;\n-\n-      begin\n-         Current_Typ := Typ;\n-         loop\n-            Parent_Typ := Etype (Current_Typ);\n-\n-            if Is_Private_Type (Parent_Typ)\n-              and then Present (Full_View (Base_Type (Parent_Typ)))\n-            then\n-               Parent_Typ := Full_View (Base_Type (Parent_Typ));\n-            end if;\n-\n-            exit when Parent_Typ = Current_Typ;\n-\n-            Current_Typ := Parent_Typ;\n-            Add_Invariants\n-              (T       => Current_Typ,\n-               Obj_Id  => Obj_Id,\n-               Stmts   => Stmts,\n-               Inherit => True);\n-         end loop;\n-      end;\n-\n-      --  Add invariants of progenitors\n-\n-      if Is_Tagged_Type (Typ) and then not Is_Interface (Typ) then\n-         declare\n-            Ifaces_List : Elist_Id;\n-            AI          : Elmt_Id;\n-            Iface       : Entity_Id;\n-\n-         begin\n-            Collect_Interfaces (Typ, Ifaces_List);\n-\n-            AI := First_Elmt (Ifaces_List);\n-            while Present (AI) loop\n-               Iface := Node (AI);\n-\n-               if not Is_Ancestor (Iface, Typ, Use_Full_View => True) then\n-                  Add_Invariants\n-                    (T       => Iface,\n-                     Obj_Id  => Obj_Id,\n-                     Stmts   => Stmts,\n-                     Inherit => True);\n-               end if;\n-\n-               Next_Elmt (AI);\n-            end loop;\n-         end;\n-      end if;\n-\n-      --  Build the procedure if we generated at least one Check pragma\n-\n-      if Stmts /= No_List then\n-         Spec := Copy_Separate_Tree (Specification (PDecl));\n-\n-         PBody :=\n-           Make_Subprogram_Body (Loc,\n-             Specification              => Spec,\n-             Declarations               => Empty_List,\n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc,\n-                 Statements => Stmts));\n-\n-         --  The processing of an invariant pragma immediately generates the\n-         --  invariant procedure spec, inserts it into the tree, and analyzes\n-         --  it. If the spec has not been analyzed, then the invariant pragma\n-         --  is being inherited and requires manual insertion and analysis.\n-\n-         if not Analyzed (PDecl) then\n-            Append_To (Vis_Decls, PDecl);\n-            Analyze (PDecl);\n-         end if;\n-\n-         --  The invariant procedure body is inserted at the end of the private\n-         --  declarations.\n-\n-         if Present (Priv_Decls) then\n-            Append_To (Priv_Decls, PBody);\n-\n-            --  If the invariant appears on the full view of a private type,\n-            --  then the analysis of the private part is already completed.\n-            --  Manually analyze the new body in this case, otherwise wait\n-            --  for the analysis of the private declarations to process the\n-            --  body.\n-\n-            if In_Private_Part (Current_Scope) then\n-               Analyze (PBody);\n-            end if;\n-\n-         --  Otherwise there are no private declarations. This is either an\n-         --  error or the related type is a private extension, in which case\n-         --  it does not need a completion in a private part. Insert the body\n-         --  at the end of the visible declarations and analyze immediately\n-         --  because the related type is about to be frozen.\n-\n-         else\n-            Append_To (Vis_Decls, PBody);\n-            Analyze (PBody);\n-         end if;\n-      end if;\n-\n-      Ghost_Mode := Save_Ghost_Mode;\n-   end Build_Invariant_Procedure;\n-\n    -------------------------------\n    -- Build_Predicate_Functions --\n    -------------------------------\n@@ -11159,9 +10588,7 @@ package body Sem_Ch13 is\n          end if;\n       end Hide_Non_Overridden_Subprograms;\n \n-      ---------------------\n-      -- Local variables --\n-      ---------------------\n+      --  Local variables\n \n       E : constant Entity_Id := Entity (N);\n \n@@ -11324,14 +10751,14 @@ package body Sem_Ch13 is\n \n       Inside_Freezing_Actions := Inside_Freezing_Actions - 1;\n \n-      --  If we have a type with predicates, build predicate function. This\n-      --  is not needed in the generic case, and is not needed within TSS\n-      --  subprograms and other predefined primitives.\n+      --  If we have a type with predicates, build predicate function. This is\n+      --  not needed in the generic case, nor within TSS subprograms and other\n+      --  predefined primitives.\n \n-      if Non_Generic_Case\n-        and then Is_Type (E)\n-        and then Has_Predicates (E)\n+      if Is_Type (E)\n+        and then Non_Generic_Case\n         and then not Within_Internal_Subprogram\n+        and then Has_Predicates (E)\n       then\n          Build_Predicate_Functions (E, N);\n       end if;\n@@ -11830,30 +11257,6 @@ package body Sem_Ch13 is\n          Set_Discard_Names (Typ);\n       end if;\n \n-      --  Invariants\n-\n-      if not Has_Rep_Item (Typ, Name_Invariant, False)\n-        and then Has_Rep_Item (Typ, Name_Invariant)\n-        and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item\n-                   (Get_Rep_Item (Typ, Name_Invariant))\n-      then\n-         Set_Has_Invariants (Typ);\n-\n-         if Class_Present (Get_Rep_Item (Typ, Name_Invariant)) then\n-            Set_Has_Inheritable_Invariants (Typ);\n-         end if;\n-\n-      --  If we have a subtype with invariants, whose base type does not have\n-      --  invariants, copy these invariants to the base type. This happens for\n-      --  the case of implicit base types created for scalar and array types.\n-\n-      elsif Has_Invariants (Typ)\n-        and then not Has_Invariants (Base_Type (Typ))\n-      then\n-         Set_Has_Invariants (Base_Type (Typ));\n-         Set_Invariant_Procedure (Base_Type (Typ), Invariant_Procedure (Typ));\n-      end if;\n-\n       --  Volatile\n \n       if not Has_Rep_Item (Typ, Name_Volatile, False)\n@@ -12636,7 +12039,7 @@ package body Sem_Ch13 is\n       if Has_Discriminants (E) then\n          Push_Scope (E);\n \n-         --  Make discriminants visible for type declarations and protected\n+         --  Make the discriminants visible for type declarations and protected\n          --  type declarations, not for subtype declarations (RM 13.1.1 (12/3))\n \n          if Nkind (Parent (E)) /= N_Subtype_Declaration then\n@@ -12891,18 +12294,15 @@ package body Sem_Ch13 is\n    procedure Replace_Type_References_Generic (N : Node_Id; T : Entity_Id) is\n       TName : constant Name_Id := Chars (T);\n \n-      function Replace_Node (N : Node_Id) return Traverse_Result;\n+      function Replace_Type_Ref (N : Node_Id) return Traverse_Result;\n       --  Processes a single node in the traversal procedure below, checking\n       --  if node N should be replaced, and if so, doing the replacement.\n \n-      procedure Replace_Type_Refs is new Traverse_Proc (Replace_Node);\n-      --  This instantiation provides the body of Replace_Type_References\n-\n-      ------------------\n-      -- Replace_Node --\n-      ------------------\n+      ----------------------\n+      -- Replace_Type_Ref --\n+      ----------------------\n \n-      function Replace_Node (N : Node_Id) return Traverse_Result is\n+      function Replace_Type_Ref (N : Node_Id) return Traverse_Result is\n          S : Entity_Id;\n          P : Node_Id;\n \n@@ -12911,10 +12311,10 @@ package body Sem_Ch13 is\n \n          if Nkind (N) = N_Identifier then\n \n-            --  If not the type name, check whether it is a reference to\n-            --  some other type, which must be frozen before the predicate\n-            --  function is analyzed, i.e. before the freeze node of the\n-            --  type to which the predicate applies.\n+            --  If not the type name, check whether it is a reference to some\n+            --  other type, which must be frozen before the predicate function\n+            --  is analyzed, i.e. before the freeze node of the type to which\n+            --  the predicate applies.\n \n             if Chars (N) /= TName then\n                if Present (Current_Entity (N))\n@@ -12932,13 +12332,13 @@ package body Sem_Ch13 is\n                return Skip;\n             end if;\n \n-         --  Case of selected component (which is what a qualification\n-         --  looks like in the unanalyzed tree, which is what we have.\n+         --  Case of selected component (which is what a qualification looks\n+         --  like in the unanalyzed tree, which is what we have.\n \n          elsif Nkind (N) = N_Selected_Component then\n \n-            --  If selector name is not our type, keeping going (we might\n-            --  still have an occurrence of the type in the prefix).\n+            --  If selector name is not our type, keeping going (we might still\n+            --  have an occurrence of the type in the prefix).\n \n             if Nkind (Selector_Name (N)) /= N_Identifier\n               or else Chars (Selector_Name (N)) /= TName\n@@ -12959,8 +12359,8 @@ package body Sem_Ch13 is\n                      return OK;\n                   end if;\n \n-                  --  Do replace if prefix is an identifier matching the\n-                  --  scope that we are currently looking at.\n+                  --  Do replace if prefix is an identifier matching the scope\n+                  --  that we are currently looking at.\n \n                   if Nkind (P) = N_Identifier\n                     and then Chars (P) = Chars (S)\n@@ -12969,9 +12369,9 @@ package body Sem_Ch13 is\n                      return Skip;\n                   end if;\n \n-                  --  Go check scope above us if prefix is itself of the\n-                  --  form of a selected component, whose selector matches\n-                  --  the scope we are currently looking at.\n+                  --  Go check scope above us if prefix is itself of the form\n+                  --  of a selected component, whose selector matches the scope\n+                  --  we are currently looking at.\n \n                   if Nkind (P) = N_Selected_Component\n                     and then Nkind (Selector_Name (P)) = N_Identifier\n@@ -12995,7 +12395,9 @@ package body Sem_Ch13 is\n          else\n             return OK;\n          end if;\n-      end Replace_Node;\n+      end Replace_Type_Ref;\n+\n+      procedure Replace_Type_Refs is new Traverse_Proc (Replace_Type_Ref);\n \n    begin\n       Replace_Type_Refs (N);\n@@ -13057,17 +12459,18 @@ package body Sem_Ch13 is\n             Expr := Expression (ASN);\n \n             case A_Id is\n+\n                --  For now we only deal with aspects that do not generate\n                --  subprograms, or that may mention current instances of\n                --  types. These will require special handling (???TBD).\n \n                when Aspect_Predicate         |\n                     Aspect_Predicate_Failure |\n-                    Aspect_Invariant =>\n+                    Aspect_Invariant         =>\n                   null;\n \n-               when Aspect_Static_Predicate |\n-                    Aspect_Dynamic_Predicate =>\n+               when Aspect_Dynamic_Predicate |\n+                    Aspect_Static_Predicate  =>\n \n                   --  Build predicate function specification and preanalyze\n                   --  expression after type replacement."}, {"sha": "e3ee2117f35c398404c063fcc2ba4372b8b808aa", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=3ddfabe34fbcf04822c794f1dc8e1740811ad016", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -53,25 +53,6 @@ package Sem_Ch13 is\n    --  order is specified and there is at least one component clause. Adjusts\n    --  component positions according to either Ada 95 or Ada 2005 (AI-133).\n \n-   function Build_Invariant_Procedure_Declaration\n-     (Typ : Entity_Id) return Node_Id;\n-   --  If a type declaration has a specified invariant aspect, build the\n-   --  declaration for the procedure at once, so that calls to it can be\n-   --  generated before the body of the invariant procedure is built. This\n-   --  is needed in the presence of public expression functions that return\n-   --  the type in question.\n-\n-   procedure Build_Invariant_Procedure (Typ : Entity_Id; N : Node_Id);\n-   --  Typ is a private type with invariants (indicated by Has_Invariants being\n-   --  set for Typ, indicating the presence of pragma Invariant entries on the\n-   --  rep chain, note that Invariant aspects have already been converted to\n-   --  pragma Invariant), then this procedure builds the spec and body for the\n-   --  corresponding Invariant procedure, inserting them at appropriate points\n-   --  in the package specification N. Invariant_Procedure is set for Typ. Note\n-   --  that this procedure is called at the end of processing the declarations\n-   --  in the visible part (i.e. the right point for visibility analysis of\n-   --  the invariant expression).\n-\n    procedure Check_Record_Representation_Clause (N : Node_Id);\n    --  This procedure completes the analysis of a record representation clause\n    --  N. It is called at freeze time after adjustment of component clause bit"}, {"sha": "9fe05eb95113019864ea2611883c2a03d72f6f83", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 187, "deletions": 155, "changes": 342, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=3ddfabe34fbcf04822c794f1dc8e1740811ad016", "patch": "@@ -4475,6 +4475,8 @@ package body Sem_Ch3 is\n    procedure Analyze_Private_Extension_Declaration (N : Node_Id) is\n       Indic       : constant Node_Id   := Subtype_Indication (N);\n       T           : constant Entity_Id := Defining_Identifier (N);\n+      Iface       : Entity_Id;\n+      Iface_Elmt  : Elmt_Id;\n       Parent_Base : Entity_Id;\n       Parent_Type : Entity_Id;\n \n@@ -4540,8 +4542,8 @@ package body Sem_Ch3 is\n \n       elsif Is_Concurrent_Type (Parent_Type) then\n          Error_Msg_N\n-           (\"parent type of a private extension cannot be \"\n-            & \"a synchronized tagged type (RM 3.9.1 (3/1))\", N);\n+           (\"parent type of a private extension cannot be a synchronized \"\n+            & \"tagged type (RM 3.9.1 (3/1))\", N);\n \n          Set_Etype              (T, Any_Type);\n          Set_Ekind              (T, E_Limited_Private_Type);\n@@ -4562,7 +4564,6 @@ package body Sem_Ch3 is\n       if (not Is_Package_Or_Generic_Package (Current_Scope)\n            and then Nkind (Parent (N)) /= N_Generic_Subprogram_Declaration)\n         or else In_Private_Part (Current_Scope)\n-\n       then\n          Error_Msg_N (\"invalid context for private extension\", N);\n       end if;\n@@ -4589,13 +4590,26 @@ package body Sem_Ch3 is\n \n       Build_Derived_Record_Type (N, Parent_Type, T);\n \n-      --  Propagate inherited invariant information. The new type has\n-      --  invariants, if the parent type has inheritable invariants,\n-      --  and these invariants can in turn be inherited.\n+      --  A private extension inherits any class-wide invariants coming from a\n+      --  parent type or an interface. Note that the invariant procedure of the\n+      --  parent type should not be inherited because the private extension may\n+      --  define invariants of its own.\n \n       if Has_Inheritable_Invariants (Parent_Type) then\n-         Set_Has_Inheritable_Invariants (T);\n-         Set_Has_Invariants (T);\n+         Set_Has_Inherited_Invariants (T);\n+\n+      elsif Present (Interfaces (T)) then\n+         Iface_Elmt := First_Elmt (Interfaces (T));\n+         while Present (Iface_Elmt) loop\n+            Iface := Node (Iface_Elmt);\n+\n+            if Has_Inheritable_Invariants (Iface) then\n+               Set_Has_Inherited_Invariants (T);\n+               exit;\n+            end if;\n+\n+            Next_Elmt (Iface_Elmt);\n+         end loop;\n       end if;\n \n       --  Ada 2005 (AI-443): Synchronized private extension or a rewritten\n@@ -4617,33 +4631,29 @@ package body Sem_Ch3 is\n                 (not Is_Interface (Parent_Type)\n                   or else not Is_Synchronized_Interface (Parent_Type))\n             then\n-               Error_Msg_NE (\"parent type of & must be tagged limited \" &\n-                             \"or synchronized\", N, T);\n+               Error_Msg_NE\n+                 (\"parent type of & must be tagged limited or synchronized\",\n+                  N, T);\n             end if;\n \n             --  The progenitors (if any) must be limited or synchronized\n             --  interfaces.\n \n             if Present (Interfaces (T)) then\n-               declare\n-                  Iface      : Entity_Id;\n-                  Iface_Elmt : Elmt_Id;\n-\n-               begin\n-                  Iface_Elmt := First_Elmt (Interfaces (T));\n-                  while Present (Iface_Elmt) loop\n-                     Iface := Node (Iface_Elmt);\n+               Iface_Elmt := First_Elmt (Interfaces (T));\n+               while Present (Iface_Elmt) loop\n+                  Iface := Node (Iface_Elmt);\n \n-                     if not Is_Limited_Interface (Iface)\n-                       and then not Is_Synchronized_Interface (Iface)\n-                     then\n-                        Error_Msg_NE (\"progenitor & must be limited \" &\n-                                      \"or synchronized\", N, Iface);\n-                     end if;\n+                  if not Is_Limited_Interface (Iface)\n+                    and then not Is_Synchronized_Interface (Iface)\n+                  then\n+                     Error_Msg_NE\n+                       (\"progenitor & must be limited or synchronized\",\n+                        N, Iface);\n+                  end if;\n \n-                     Next_Elmt (Iface_Elmt);\n-                  end loop;\n-               end;\n+                  Next_Elmt (Iface_Elmt);\n+               end loop;\n             end if;\n \n          --  Regular derived extension, the parent must be a limited or\n@@ -5154,10 +5164,9 @@ package body Sem_Ch3 is\n \n       if Has_Predicates (T)\n         and then Present (Predicate_Function (T))\n-\n-         and then\n-           ((In_Instance and then not Comes_From_Source (N))\n-              or else No (Aspect_Specifications (N)))\n+        and then\n+          ((In_Instance and then not Comes_From_Source (N))\n+             or else No (Aspect_Specifications (N)))\n       then\n          Set_Subprograms_For_Type (Id, Subprograms_For_Type (T));\n \n@@ -5167,6 +5176,11 @@ package body Sem_Ch3 is\n          end if;\n       end if;\n \n+      --  Propagate invariant-related attributes from the base type to the\n+      --  subtype.\n+\n+      Propagate_Invariant_Attributes (Id, From_Typ => Base_Type (T));\n+\n       --  Remaining processing depends on characteristics of base type\n \n       T := Etype (Id);\n@@ -5228,9 +5242,9 @@ package body Sem_Ch3 is\n \n       if Nkind (Subtype_Indication (N)) = N_Subtype_Indication then\n          if Is_Scalar_Type (Etype (Id))\n-            and then Scalar_Range (Id) /=\n-                     Scalar_Range (Etype (Subtype_Mark\n-                                           (Subtype_Indication (N))))\n+           and then Scalar_Range (Id) /=\n+                    Scalar_Range\n+                      (Etype (Subtype_Mark (Subtype_Indication (N))))\n          then\n             Apply_Range_Check\n               (Scalar_Range (Id),\n@@ -5301,14 +5315,6 @@ package body Sem_Ch3 is\n          end if;\n       end if;\n \n-      --  A type invariant applies to any subtype in its scope, in particular\n-      --  to a generic actual.\n-\n-      if Has_Invariants (T) and then In_Open_Scopes (Scope (T)) then\n-         Set_Has_Invariants (Id);\n-         Set_Invariant_Procedure (Id, Invariant_Procedure (T));\n-      end if;\n-\n       Set_Optimize_Alignment_Flags (Id);\n       Check_Eliminated (Id);\n \n@@ -5633,16 +5639,20 @@ package body Sem_Ch3 is\n \n          --  Complete setup of implicit base type\n \n-         Set_First_Index       (Implicit_Base, First_Index (T));\n-         Set_Component_Type    (Implicit_Base, Element_Type);\n+         Set_Component_Size (Implicit_Base, Uint_0);\n+         Set_Component_Type (Implicit_Base, Element_Type);\n+         Set_Finalize_Storage_Only\n+                            (Implicit_Base,\n+                              Finalize_Storage_Only (Element_Type));\n+         Set_First_Index    (Implicit_Base, First_Index (T));\n+         Set_Has_Controlled_Component\n+                            (Implicit_Base,\n+                              Has_Controlled_Component (Element_Type)\n+                                or else Is_Controlled_Active  (Element_Type));\n+         Set_Packed_Array_Impl_Type\n+                            (Implicit_Base, Empty);\n+\n          Propagate_Concurrent_Flags (Implicit_Base, Element_Type);\n-         Set_Component_Size    (Implicit_Base, Uint_0);\n-         Set_Packed_Array_Impl_Type (Implicit_Base, Empty);\n-         Set_Has_Controlled_Component (Implicit_Base,\n-           Has_Controlled_Component (Element_Type)\n-             or else Is_Controlled_Active  (Element_Type));\n-         Set_Finalize_Storage_Only (Implicit_Base,\n-           Finalize_Storage_Only (Element_Type));\n \n          --  Inherit the \"ghostness\" from the constrained array type\n \n@@ -8786,31 +8796,35 @@ package body Sem_Ch3 is\n                   end;\n                end if;\n \n-               --  Propagate inherited invariant information of parents\n-               --  and progenitors\n+               --  A derived type inherits any class-wide invariants coming\n+               --  from a parent type or an interface. Note that the invariant\n+               --  procedure of the parent type should not be inherited because\n+               --  the derived type may define invariants of its own.\n \n                if Ada_Version >= Ada_2012\n                  and then not Is_Interface (Derived_Type)\n                then\n-                  if Has_Inheritable_Invariants (Parent_Type) then\n-                     Set_Has_Invariants (Derived_Type);\n-                     Set_Has_Inheritable_Invariants (Derived_Type);\n+                  if Has_Inherited_Invariants (Parent_Type)\n+                    or else Has_Inheritable_Invariants (Parent_Type)\n+                  then\n+                     Set_Has_Inherited_Invariants (Derived_Type);\n \n                   elsif not Is_Empty_Elmt_List (Ifaces_List) then\n                      declare\n-                        AI : Elmt_Id;\n+                        Iface      : Entity_Id;\n+                        Iface_Elmt : Elmt_Id;\n \n                      begin\n-                        AI := First_Elmt (Ifaces_List);\n-                        while Present (AI) loop\n-                           if Has_Inheritable_Invariants (Node (AI)) then\n-                              Set_Has_Invariants (Derived_Type);\n-                              Set_Has_Inheritable_Invariants (Derived_Type);\n+                        Iface_Elmt := First_Elmt (Ifaces_List);\n+                        while Present (Iface_Elmt) loop\n+                           Iface := Node (Iface_Elmt);\n \n+                           if Has_Inheritable_Invariants (Iface) then\n+                              Set_Has_Inherited_Invariants (Derived_Type);\n                               exit;\n                            end if;\n \n-                           Next_Elmt (AI);\n+                           Next_Elmt (Iface_Elmt);\n                         end loop;\n                      end;\n                   end if;\n@@ -16427,63 +16441,93 @@ package body Sem_Ch3 is\n \n    function Find_Type_Name (N : Node_Id) return Entity_Id is\n       Id       : constant Entity_Id := Defining_Identifier (N);\n-      Prev     : Entity_Id;\n       New_Id   : Entity_Id;\n+      Prev     : Entity_Id;\n       Prev_Par : Node_Id;\n \n       procedure Check_Duplicate_Aspects;\n       --  Check that aspects specified in a completion have not been specified\n-      --  already in the partial view. Type_Invariant and others can be\n-      --  specified on either view but never on both.\n+      --  already in the partial view.\n \n       procedure Tag_Mismatch;\n-      --  Diagnose a tagged partial view whose full view is untagged.\n-      --  We post the message on the full view, with a reference to\n-      --  the previous partial view. The partial view can be private\n-      --  or incomplete, and these are handled in a different manner,\n-      --  so we determine the position of the error message from the\n-      --  respective slocs of both.\n+      --  Diagnose a tagged partial view whose full view is untagged. We post\n+      --  the message on the full view, with a reference to the previous\n+      --  partial view. The partial view can be private or incomplete, and\n+      --  these are handled in a different manner, so we determine the position\n+      --  of the error message from the respective slocs of both.\n \n       -----------------------------\n       -- Check_Duplicate_Aspects --\n       -----------------------------\n \n       procedure Check_Duplicate_Aspects is\n-         Prev_Aspects   : constant List_Id := Aspect_Specifications (Prev_Par);\n-         Full_Aspects   : constant List_Id := Aspect_Specifications (N);\n-         F_Spec, P_Spec : Node_Id;\n+         function Get_Partial_View_Aspect (Asp : Node_Id) return Node_Id;\n+         --  Return the corresponding aspect of the partial view which matches\n+         --  the aspect id of Asp. Return Empty is no such aspect exists.\n+\n+         -----------------------------\n+         -- Get_Partial_View_Aspect --\n+         -----------------------------\n+\n+         function Get_Partial_View_Aspect (Asp : Node_Id) return Node_Id is\n+            Asp_Id    : constant Aspect_Id := Get_Aspect_Id (Asp);\n+            Prev_Asps : constant List_Id   := Aspect_Specifications (Prev_Par);\n+            Prev_Asp  : Node_Id;\n+\n+         begin\n+            if Present (Prev_Asps) then\n+               Prev_Asp := First (Prev_Asps);\n+               while Present (Prev_Asp) loop\n+                  if Get_Aspect_Id (Prev_Asp) = Asp_Id then\n+                     return Prev_Asp;\n+                  end if;\n+\n+                  Next (Prev_Asp);\n+               end loop;\n+            end if;\n+\n+            return Empty;\n+         end Get_Partial_View_Aspect;\n+\n+         --  Local variables\n+\n+         Full_Asps : constant List_Id := Aspect_Specifications (N);\n+         Full_Asp  : Node_Id;\n+         Part_Asp  : Node_Id;\n+\n+      --  Start of processing for Check_Duplicate_Aspects\n \n       begin\n-         if Present (Full_Aspects) then\n-            F_Spec := First (Full_Aspects);\n-            while Present (F_Spec) loop\n-               if Present (Prev_Aspects) then\n-                  P_Spec := First (Prev_Aspects);\n-                  while Present (P_Spec) loop\n-                     if Chars (Identifier (P_Spec)) =\n-                       Chars (Identifier (F_Spec))\n-                     then\n-                        Error_Msg_N\n-                          (\"aspect already specified in private declaration\",\n-                            F_Spec);\n-                        Remove (F_Spec);\n-                        return;\n-                     end if;\n+         if Present (Full_Asps) then\n+            Full_Asp := First (Full_Asps);\n+            while Present (Full_Asp) loop\n+               Part_Asp := Get_Partial_View_Aspect (Full_Asp);\n \n-                     Next (P_Spec);\n-                  end loop;\n+               --  An aspect and its class-wide counterpart are two distinct\n+               --  aspects and may apply to both views of an entity.\n+\n+               if Present (Part_Asp)\n+                 and then Class_Present (Part_Asp) = Class_Present (Full_Asp)\n+               then\n+                  Error_Msg_N\n+                    (\"aspect already specified in private declaration\",\n+                     Full_Asp);\n+\n+                  Remove (Full_Asp);\n+                  return;\n                end if;\n \n                if Has_Discriminants (Prev)\n                  and then not Has_Unknown_Discriminants (Prev)\n-                 and then Chars (Identifier (F_Spec)) =\n-                   Name_Implicit_Dereference\n+                 and then Get_Aspect_Id (Full_Asp) =\n+                            Aspect_Implicit_Dereference\n                then\n-                  Error_Msg_N (\"cannot specify aspect \" &\n-                    \"if partial view has known discriminants\", F_Spec);\n+                  Error_Msg_N\n+                    (\"cannot specify aspect if partial view has known \"\n+                     & \"discriminants\", Full_Asp);\n                end if;\n \n-               Next (F_Spec);\n+               Next (Full_Asp);\n             end loop;\n          end if;\n       end Check_Duplicate_Aspects;\n@@ -19573,8 +19617,8 @@ package body Sem_Ch3 is\n            and then not Is_Ancestor (Base_Type (Priv_Parent), Full_Parent)\n          then\n             Error_Msg_N\n-              (\"parent of full type must descend from parent\"\n-                  & \" of private extension\", Full_Indic);\n+              (\"parent of full type must descend from parent of private \"\n+               & \"extension\", Full_Indic);\n \n          --  First check a formal restriction, and then proceed with checking\n          --  Ada rules. Since the formal restriction is not a serious error, we\n@@ -19628,9 +19672,9 @@ package body Sem_Ch3 is\n                   while Present (Priv_Discr) and then Present (Full_Discr) loop\n                      if Original_Record_Component (Priv_Discr) =\n                         Original_Record_Component (Full_Discr)\n-                       or else\n-                         Corresponding_Discriminant (Priv_Discr) =\n-                         Corresponding_Discriminant (Full_Discr)\n+                          or else\n+                        Corresponding_Discriminant (Priv_Discr) =\n+                        Corresponding_Discriminant (Full_Discr)\n                      then\n                         null;\n                      else\n@@ -19643,8 +19687,8 @@ package body Sem_Ch3 is\n \n                   if Present (Priv_Discr) or else Present (Full_Discr) then\n                      Error_Msg_N\n-                       (\"full view must inherit discriminants of the parent\"\n-                        & \" type used in the private extension\", Full_Indic);\n+                       (\"full view must inherit discriminants of the parent \"\n+                        & \"type used in the private extension\", Full_Indic);\n \n                   elsif Priv_Constr and then not Full_Constr then\n                      Error_Msg_N\n@@ -19662,13 +19706,13 @@ package body Sem_Ch3 is\n                --  known or unknown discriminants, then the full type\n                --  declaration shall define a definite subtype.\n \n-            elsif      not Has_Unknown_Discriminants (Priv_T)\n+            elsif not Has_Unknown_Discriminants (Priv_T)\n               and then not Has_Discriminants (Priv_T)\n               and then not Is_Constrained (Full_T)\n             then\n                Error_Msg_N\n-                 (\"full view must define a constrained type if partial view\"\n-                  & \" has no discriminants\", Full_T);\n+                 (\"full view must define a constrained type if partial view \"\n+                  & \"has no discriminants\", Full_T);\n             end if;\n \n             --  ??????? Do we implement the following properly ?????\n@@ -20095,42 +20139,33 @@ package body Sem_Ch3 is\n          Mark_Full_View_As_Ghost (Priv_T, Full_T);\n       end if;\n \n-      --  Propagate invariants to full type\n+      --  Propagate invariant-related attributes from the private view to the\n+      --  full view and its base type.\n \n-      if Has_Invariants (Priv_T) then\n-         Set_Has_Invariants (Full_T);\n-         Set_Invariant_Procedure (Full_T, Invariant_Procedure (Priv_T));\n-      end if;\n-\n-      if Has_Inheritable_Invariants (Priv_T) then\n-         Set_Has_Inheritable_Invariants (Full_T);\n-      end if;\n+      Propagate_Invariant_Attributes (Full_T, From_Typ => Priv_T);\n+      Propagate_Invariant_Attributes (Base_Type (Full_T), From_Typ => Priv_T);\n \n-      --  Check hidden inheritance of class-wide type invariants\n+      --  AI12-0041: Detect an attempt to inherit a class-wide type invariant\n+      --  in the full view without advertising the inheritance in the partial\n+      --  view. This can only occur when the partial view has no parent type\n+      --  and the full view has an interface as a parent. Any other scenarios\n+      --  are illegal because implemented interfaces must match between the\n+      --  two views.\n \n-      if Ada_Version >= Ada_2012\n-        and then not Has_Inheritable_Invariants (Full_T)\n-        and then In_Private_Part (Current_Scope)\n-        and then Has_Interfaces (Full_T)\n-      then\n+      if Is_Tagged_Type (Priv_T) and then Is_Tagged_Type (Full_T) then\n          declare\n-            Ifaces : Elist_Id;\n-            AI     : Elmt_Id;\n+            Full_Par : constant Entity_Id := Etype (Full_T);\n+            Priv_Par : constant Entity_Id := Etype (Priv_T);\n \n          begin\n-            Collect_Interfaces (Full_T, Ifaces, Exclude_Parents => True);\n-\n-            AI := First_Elmt (Ifaces);\n-            while Present (AI) loop\n-               if Has_Inheritable_Invariants (Node (AI)) then\n-                  Error_Msg_N\n-                    (\"hidden inheritance of class-wide type invariants \" &\n-                     \"not allowed\", N);\n-                  exit;\n-               end if;\n-\n-               Next_Elmt (AI);\n-            end loop;\n+            if not Is_Interface (Priv_Par)\n+              and then Is_Interface (Full_Par)\n+              and then Has_Inheritable_Invariants (Full_Par)\n+            then\n+               Error_Msg_N\n+                 (\"hidden inheritance of class-wide type invariants not \"\n+                  & \"allowed\", N);\n+            end if;\n          end;\n       end if;\n \n@@ -20952,34 +20987,31 @@ package body Sem_Ch3 is\n       Private_To_Full_View : Boolean := False)\n    is\n       procedure Remove_Default_Init_Cond_Procedure (Typ : Entity_Id);\n-      --  Remove the default initial procedure (if any) from the rep chain of\n-      --  type Typ.\n+      --  Remove the default initial condition procedure (if any) from the\n+      --  Subprograms_For_Type chain of type Typ.\n \n       ----------------------------------------\n       -- Remove_Default_Init_Cond_Procedure --\n       ----------------------------------------\n \n       procedure Remove_Default_Init_Cond_Procedure (Typ : Entity_Id) is\n-         Found : Boolean := False;\n-         Prev  : Entity_Id;\n-         Subp  : Entity_Id;\n+         Subps     : constant Elist_Id := Subprograms_For_Type (Typ);\n+         Subp_Elmt : Elmt_Id;\n+         Subp_Id   : Entity_Id;\n \n       begin\n-         Prev := Typ;\n-         Subp := Subprograms_For_Type (Typ);\n-         while Present (Subp) loop\n-            if Is_Default_Init_Cond_Procedure (Subp) then\n-               Found := True;\n-               exit;\n-            end if;\n+         if Present (Subps) then\n+            Subp_Elmt := First_Elmt (Subps);\n+            while Present (Subp_Elmt) loop\n+               Subp_Id := Node (Subp_Elmt);\n \n-            Prev := Subp;\n-            Subp := Subprograms_For_Type (Subp);\n-         end loop;\n+               if Is_Default_Init_Cond_Procedure (Subp_Id) then\n+                  Remove_Elmt (Subps, Subp_Elmt);\n+                  exit;\n+               end if;\n \n-         if Found then\n-            Set_Subprograms_For_Type (Prev, Subprograms_For_Type (Subp));\n-            Set_Subprograms_For_Type (Subp, Empty);\n+               Next_Elmt (Subp_Elmt);\n+            end loop;\n          end if;\n       end Remove_Default_Init_Cond_Procedure;\n "}, {"sha": "ce5f55663be9c0a171f67b68fbb9b628d464b2cd", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=3ddfabe34fbcf04822c794f1dc8e1740811ad016", "patch": "@@ -4428,6 +4428,34 @@ package body Sem_Ch6 is\n    --  both subprogram bodies and subprogram declarations (specs).\n \n    function Analyze_Subprogram_Specification (N : Node_Id) return Entity_Id is\n+      function Is_Invariant_Procedure_Or_Body (E : Entity_Id) return Boolean;\n+      --  Determine whether entity E denotes the spec or body of an invariant\n+      --  procedure.\n+\n+      ------------------------------------\n+      -- Is_Invariant_Procedure_Or_Body --\n+      ------------------------------------\n+\n+      function Is_Invariant_Procedure_Or_Body (E : Entity_Id) return Boolean is\n+         Decl : constant Node_Id := Unit_Declaration_Node (E);\n+         Spec : Entity_Id;\n+\n+      begin\n+         if Nkind (Decl) = N_Subprogram_Body then\n+            Spec := Corresponding_Spec (Decl);\n+         else\n+            Spec := E;\n+         end if;\n+\n+         return\n+           Present (Spec)\n+             and then Ekind (Spec) = E_Procedure\n+             and then (Is_Partial_Invariant_Procedure (Spec)\n+                        or else Is_Invariant_Procedure (Spec));\n+      end Is_Invariant_Procedure_Or_Body;\n+\n+      --  Local variables\n+\n       Designator : constant Entity_Id := Defining_Entity (N);\n       Formals    : constant List_Id   := Parameter_Specifications (N);\n \n@@ -4487,7 +4515,27 @@ package body Sem_Ch6 is\n          --  Same processing for an access parameter whose designated type is\n          --  derived from a synchronized interface.\n \n-         if Ada_Version >= Ada_2005 then\n+         --  This modification is not done for invariant procedures because\n+         --  the corresponding record may not necessarely be visible when the\n+         --  concurrent type acts as the full view of a private type.\n+\n+         --    package Pack is\n+         --       type Prot is private with Type_Invariant => ...;\n+         --       procedure ConcInvariant (Obj : Prot);\n+         --    private\n+         --       protected type Prot is ...;\n+         --       type Concurrent_Record_Prot is record ...;\n+         --       procedure ConcInvariant (Obj : Prot) is\n+         --          ...\n+         --       end ConcInvariant;\n+         --    end Pack;\n+\n+         --  In the example above, both the spec and body of the invariant\n+         --  procedure must utilize the private type as the controlling type.\n+\n+         if Ada_Version >= Ada_2005\n+           and then not Is_Invariant_Procedure_Or_Body (Designator)\n+         then\n             declare\n                Formal     : Entity_Id;\n                Formal_Typ : Entity_Id;"}, {"sha": "01a5edbbc3af974a6bee9168e4eb3b2d0a520c59", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 47, "deletions": 67, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=3ddfabe34fbcf04822c794f1dc8e1740811ad016", "patch": "@@ -35,6 +35,7 @@ with Debug;     use Debug;\n with Einfo;     use Einfo;\n with Elists;    use Elists;\n with Errout;    use Errout;\n+with Exp_Ch7;   use Exp_Ch7;\n with Exp_Disp;  use Exp_Disp;\n with Exp_Dist;  use Exp_Dist;\n with Exp_Dbug;  use Exp_Dbug;\n@@ -1457,23 +1458,25 @@ package body Sem_Ch7 is\n                Inherit_Default_Init_Cond_Procedure (E);\n             end if;\n \n-            --  If invariants are present, build the invariant procedure for a\n-            --  private type, but not any of its subtypes or interface types.\n+            --  Preanalyze and resolve the invariants of a private type at the\n+            --  end of the visible declarations to catch potential errors. Note\n+            --  that inherited class-wide invariants are not considered because\n+            --  they have already been resolved.\n \n-            if Has_Invariants (E) then\n-               if Ekind (E) = E_Private_Subtype then\n-                  null;\n-               else\n-                  Build_Invariant_Procedure (E, N);\n-               end if;\n+            if Ekind_In (E, E_Limited_Private_Type,\n+                            E_Private_Type,\n+                            E_Record_Type_With_Private)\n+              and then Has_Own_Invariants (E)\n+            then\n+               Build_Invariant_Procedure_Body (E, Partial_Invariant => True);\n             end if;\n          end if;\n \n          Next_Entity (E);\n       end loop;\n \n       if Is_Remote_Call_Interface (Id)\n-         and then Nkind (Parent (Parent (N))) = N_Compilation_Unit\n+        and then Nkind (Parent (Parent (N))) = N_Compilation_Unit\n       then\n          Validate_RCI_Declarations (Id);\n       end if;\n@@ -1544,7 +1547,6 @@ package body Sem_Ch7 is\n       if Is_Compilation_Unit (Id) then\n          Install_Private_With_Clauses (Id);\n       else\n-\n          --  The current compilation unit may include private with_clauses,\n          --  which are visible in the private part of the current nested\n          --  package, and have to be installed now. This is not done for\n@@ -1636,48 +1638,18 @@ package body Sem_Ch7 is\n               (\"full view of & does not have preelaborable initialization\", E);\n          end if;\n \n-         --  An invariant may appear on a full view of a type\n+         --  Preanalyze and resolve the invariants of a private type's full\n+         --  view at the end of the private declarations in case freezing did\n+         --  not take place either due to errors or because the context is a\n+         --  generic unit.\n \n          if Is_Type (E)\n+           and then not Is_Private_Type (E)\n            and then Has_Private_Declaration (E)\n-           and then Nkind (Parent (E)) = N_Full_Type_Declaration\n+           and then Has_Invariants (E)\n+           and then Serious_Errors_Detected > 0\n          then\n-            declare\n-               IP_Built : Boolean := False;\n-\n-            begin\n-               if Has_Aspects (Parent (E)) then\n-                  declare\n-                     ASN : Node_Id;\n-\n-                  begin\n-                     ASN := First (Aspect_Specifications (Parent (E)));\n-                     while Present (ASN) loop\n-                        if Nam_In (Chars (Identifier (ASN)),\n-                             Name_Invariant,\n-                             Name_Type_Invariant)\n-                        then\n-                           Build_Invariant_Procedure (E, N);\n-                           IP_Built := True;\n-                           exit;\n-                        end if;\n-\n-                        Next (ASN);\n-                     end loop;\n-                  end;\n-               end if;\n-\n-               --  Invariants may have been inherited from progenitors\n-\n-               if not IP_Built\n-                 and then Has_Interfaces (E)\n-                 and then Has_Inheritable_Invariants (E)\n-                 and then not Is_Interface (E)\n-                 and then not Is_Class_Wide_Type (E)\n-               then\n-                  Build_Invariant_Procedure (E, N);\n-               end if;\n-            end;\n+            Build_Invariant_Procedure_Body (E);\n          end if;\n \n          Next_Entity (E);\n@@ -2543,7 +2515,7 @@ package body Sem_Ch7 is\n       Priv_Elmt : Elmt_Id;\n       Priv_Sub  : Entity_Id;\n \n-      procedure Preserve_Full_Attributes (Priv, Full : Entity_Id);\n+      procedure Preserve_Full_Attributes (Priv : Entity_Id; Full : Entity_Id);\n       --  Copy to the private declaration the attributes of the full view that\n       --  need to be available for the partial view also.\n \n@@ -2554,12 +2526,16 @@ package body Sem_Ch7 is\n       -- Preserve_Full_Attributes --\n       ------------------------------\n \n-      procedure Preserve_Full_Attributes (Priv, Full : Entity_Id) is\n-         Priv_Is_Base_Type : constant Boolean := Is_Base_Type (Priv);\n+      procedure Preserve_Full_Attributes\n+        (Priv : Entity_Id;\n+         Full : Entity_Id)\n+      is\n+         Full_Base         : constant Entity_Id := Base_Type (Full);\n+         Priv_Is_Base_Type : constant Boolean   := Is_Base_Type (Priv);\n \n       begin\n-         Set_Size_Info (Priv, (Full));\n-         Set_RM_Size                 (Priv, RM_Size (Full));\n+         Set_Size_Info               (Priv,                             Full);\n+         Set_RM_Size                 (Priv, RM_Size                    (Full));\n          Set_Size_Known_At_Compile_Time\n                                      (Priv, Size_Known_At_Compile_Time (Full));\n          Set_Is_Volatile             (Priv, Is_Volatile                (Full));\n@@ -2581,26 +2557,30 @@ package body Sem_Ch7 is\n          end if;\n \n          if Priv_Is_Base_Type then\n-            Set_Is_Controlled (Priv, Is_Controlled (Base_Type (Full)));\n+            Set_Is_Controlled (Priv, Is_Controlled            (Full_Base));\n             Set_Finalize_Storage_Only\n-                              (Priv, Finalize_Storage_Only\n-                                                   (Base_Type (Full)));\n-            Propagate_Concurrent_Flags\n-                              (Priv,                Base_Type (Full));\n+                              (Priv, Finalize_Storage_Only    (Full_Base));\n             Set_Has_Controlled_Component\n-                              (Priv, Has_Controlled_Component\n-                                                   (Base_Type (Full)));\n+                              (Priv, Has_Controlled_Component (Full_Base));\n+\n+            Propagate_Concurrent_Flags (Priv, Base_Type (Full));\n          end if;\n \n          Set_Freeze_Node (Priv, Freeze_Node (Full));\n \n-         --  Propagate information of type invariants, which may be specified\n-         --  for the full view.\n+         --  Propagate invariant-related attributes from the base type of the\n+         --  full view to the full view and vice versa. This may seem strange,\n+         --  but is necessary depending on which type triggered the generation\n+         --  of the invariant procedure body. As a result, both the full view\n+         --  and its base type carry the same invariant-related information.\n \n-         if Has_Invariants (Full) and not Has_Invariants (Priv) then\n-            Set_Has_Invariants (Priv);\n-            Set_Subprograms_For_Type (Priv, Subprograms_For_Type (Full));\n-         end if;\n+         Propagate_Invariant_Attributes (Full, From_Typ => Full_Base);\n+         Propagate_Invariant_Attributes (Full_Base, From_Typ => Full);\n+\n+         --  Propagate invariant-related attributes from the full view to the\n+         --  private view.\n+\n+         Propagate_Invariant_Attributes (Priv, From_Typ => Full);\n \n          if Is_Tagged_Type (Priv)\n            and then Is_Tagged_Type (Full)\n@@ -2943,7 +2923,7 @@ package body Sem_Ch7 is\n                   if Is_Overloadable (Subp) and then Is_Primitive (Subp) then\n                      Error_Msg_NE\n                        (\"type& must be completed in the private part\",\n-                         Parent (Subp), Id);\n+                        Parent (Subp), Id);\n \n                   --  The result type of an access-to-function type cannot be a\n                   --  Taft-amendment type, unless the version is Ada 2012 or"}, {"sha": "39e8dc174eac0a0034bfa39a8ce4d3ab0206d709", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 36, "deletions": 7, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=3ddfabe34fbcf04822c794f1dc8e1740811ad016", "patch": "@@ -2037,11 +2037,21 @@ package body Sem_Ch9 is\n \n       Set_Is_Constrained (T, not Has_Discriminants (T));\n \n-      --  If aspects are present, analyze them now. They can make references\n-      --  to the discriminants of the type, but not to any components.\n+      --  If aspects are present, analyze them now. They can make references to\n+      --  the discriminants of the type, but not to any components.\n \n       if Has_Aspects (N) then\n-         Analyze_Aspect_Specifications (N, Def_Id);\n+\n+         --  The protected type is the full view of a private type. Analyze the\n+         --  aspects with the entity of the private type to ensure that after\n+         --  both views are exchanged, the aspect are actually associated with\n+         --  the full view.\n+\n+         if T /= Def_Id and then Is_Private_Type (Def_Id) then\n+            Analyze_Aspect_Specifications (N, T);\n+         else\n+            Analyze_Aspect_Specifications (N, Def_Id);\n+         end if;\n       end if;\n \n       Analyze (Protected_Definition (N));\n@@ -2194,6 +2204,11 @@ package body Sem_Ch9 is\n             Set_Must_Have_Preelab_Init (T);\n          end if;\n \n+         --  Propagate invariant-related attributes from the private type to\n+         --  the protected type.\n+\n+         Propagate_Invariant_Attributes (T, From_Typ => Def_Id);\n+\n          --  Create corresponding record now, because some private dependents\n          --  may be subtypes of the partial view.\n \n@@ -3071,7 +3086,17 @@ package body Sem_Ch9 is\n       Set_Is_Constrained (T, not Has_Discriminants (T));\n \n       if Has_Aspects (N) then\n-         Analyze_Aspect_Specifications (N, Def_Id);\n+\n+         --  The task type is the full view of a private type. Analyze the\n+         --  aspects with the entity of the private type to ensure that after\n+         --  both views are exchanged, the aspect are actually associated with\n+         --  the full view.\n+\n+         if T /= Def_Id and then Is_Private_Type (Def_Id) then\n+            Analyze_Aspect_Specifications (N, T);\n+         else\n+            Analyze_Aspect_Specifications (N, Def_Id);\n+         end if;\n       end if;\n \n       if Present (Task_Definition (N)) then\n@@ -3102,9 +3127,8 @@ package body Sem_Ch9 is\n \n       --  Case of a completion of a private declaration\n \n-      if T /= Def_Id\n-        and then Is_Private_Type (Def_Id)\n-      then\n+      if T /= Def_Id and then Is_Private_Type (Def_Id) then\n+\n          --  Deal with preelaborable initialization. Note that this processing\n          --  is done by Process_Full_View, but as can be seen below, in this\n          --  case the call to Process_Full_View is skipped if any serious\n@@ -3114,6 +3138,11 @@ package body Sem_Ch9 is\n             Set_Must_Have_Preelab_Init (T);\n          end if;\n \n+         --  Propagate invariant-related attributes from the private type to\n+         --  task type.\n+\n+         Propagate_Invariant_Attributes (T, From_Typ => Def_Id);\n+\n          --  Create corresponding record now, because some private dependents\n          --  may be subtypes of the partial view.\n "}, {"sha": "6c7539bb4945a282c95ec70f74e480eb10b01b91", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 74, "deletions": 37, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=3ddfabe34fbcf04822c794f1dc8e1740811ad016", "patch": "@@ -39,6 +39,7 @@ with Debug;     use Debug;\n with Einfo;     use Einfo;\n with Elists;    use Elists;\n with Errout;    use Errout;\n+with Exp_Ch7;   use Exp_Ch7;\n with Exp_Dist;  use Exp_Dist;\n with Exp_Util;  use Exp_Util;\n with Freeze;    use Freeze;\n@@ -16503,7 +16504,19 @@ package body Sem_Prag is\n          when Pragma_Invariant => Invariant : declare\n             Discard : Boolean;\n             Typ     : Entity_Id;\n-            Type_Id : Node_Id;\n+            Typ_Arg : Node_Id;\n+\n+            CRec_Typ : Entity_Id;\n+            --  The corresponding record type of Full_Typ\n+\n+            Full_Base : Entity_Id;\n+            --  The base type of Full_Typ\n+\n+            Full_Typ : Entity_Id;\n+            --  The full view of Typ\n+\n+            Priv_Typ : Entity_Id;\n+            --  The partial view of Typ\n \n          begin\n             GNAT_Pragma;\n@@ -16519,14 +16532,16 @@ package body Sem_Prag is\n \n             Check_Arg_Is_Local_Name (Arg1);\n \n-            Type_Id := Get_Pragma_Arg (Arg1);\n-            Find_Type (Type_Id);\n-            Typ := Entity (Type_Id);\n+            Typ_Arg := Get_Pragma_Arg (Arg1);\n+            Find_Type (Typ_Arg);\n+            Typ := Entity (Typ_Arg);\n+\n+            --  Nothing to do of the related type is erroneous in some way\n \n             if Typ = Any_Type then\n                return;\n \n-            --  Invariants allowed in interface types (RM 7.3.2(3/3))\n+            --  AI12-0041: Invariants are allowed in interface types\n \n             elsif Is_Interface (Typ) then\n                null;\n@@ -16536,64 +16551,86 @@ package body Sem_Prag is\n             --  a class-wide invariant can only appear on a private declaration\n             --  or private extension, not a completion.\n \n-            elsif Ekind_In (Typ, E_Private_Type,\n-                                 E_Record_Type_With_Private,\n-                                 E_Limited_Private_Type)\n+            --  A [class-wide] invariant may be associated a [limited] private\n+            --  type or a private extension.\n+\n+            elsif Ekind_In (Typ, E_Limited_Private_Type,\n+                                 E_Private_Type,\n+                                 E_Record_Type_With_Private)\n             then\n                null;\n \n-            elsif In_Private_Part (Current_Scope)\n-              and then Has_Private_Declaration (Typ)\n+            --  A non-class-wide invariant may be associated with the full view\n+            --  of a [limited] private type or a private extension.\n+\n+            elsif Has_Private_Declaration (Typ)\n               and then not Class_Present (N)\n             then\n                null;\n \n-            elsif In_Private_Part (Current_Scope) then\n+            --  A class-wide invariant may appear on the partial view only\n+\n+            elsif Class_Present (N) then\n                Error_Pragma_Arg\n-                 (\"pragma% only allowed for private type declared in \"\n-                  & \"visible part\", Arg1);\n+                 (\"pragma % only allowed for private type\", Arg1);\n+               return;\n+\n+            --  A regular invariant may appear on both views\n \n             else\n                Error_Pragma_Arg\n-                 (\"pragma% only allowed for private type\", Arg1);\n+                 (\"pragma % only allowed for private type or corresponding \"\n+                  & \"full view\", Arg1);\n+               return;\n             end if;\n \n-            --  A pragma that applies to a Ghost entity becomes Ghost for the\n-            --  purposes of legality checks and removal of ignored Ghost code.\n-\n-            Mark_Pragma_As_Ghost (N, Typ);\n-\n-            --  Not allowed for abstract type in the non-class case (it is\n-            --  allowed to use Invariant'Class for abstract types).\n+            --  An invariant associated with an abstract type (this includes\n+            --  interfaces) must be class-wide.\n \n             if Is_Abstract_Type (Typ) and then not Class_Present (N) then\n                Error_Pragma_Arg\n-                 (\"pragma% not allowed for abstract type\", Arg1);\n+                 (\"pragma % not allowed for abstract type\", Arg1);\n+               return;\n             end if;\n \n-            --  Link the pragma on to the rep item chain, for processing when\n-            --  the type is frozen.\n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n \n-            Discard := Rep_Item_Too_Late (Typ, N, FOnly => True);\n+            Mark_Pragma_As_Ghost (N, Typ);\n \n-            --  Note that the type has at least one invariant, and also that\n-            --  it has inheritable invariants if we have Invariant'Class\n-            --  or Type_Invariant'Class. Build the corresponding invariant\n-            --  procedure declaration, so that calls to it can be generated\n-            --  before the body is built (e.g. within an expression function).\n+            --  The pragma defines a type-specific invariant, the type is said\n+            --  to have invariants of its \"own\".\n \n-            --  Interface types have no invariant procedure; their invariants\n-            --  are propagated to the build invariant procedure of all the\n-            --  types covering the interface type.\n+            Set_Has_Own_Invariants (Typ);\n \n-            if not Is_Interface (Typ) then\n-               Insert_After_And_Analyze\n-                 (N, Build_Invariant_Procedure_Declaration (Typ));\n-            end if;\n+            --  If the invariant is class-wide, then it can be inherited by\n+            --  derived or interface implementing types. The type is said to\n+            --  have \"inheritable\" invariants.\n \n             if Class_Present (N) then\n                Set_Has_Inheritable_Invariants (Typ);\n             end if;\n+\n+            Get_Views (Typ, Priv_Typ, Full_Typ, Full_Base, CRec_Typ);\n+\n+            --  Propagate invariant-related attributes to all views of the type\n+            --  and any additional types that may have been created.\n+\n+            Propagate_Invariant_Attributes (Priv_Typ,  From_Typ => Typ);\n+            Propagate_Invariant_Attributes (Full_Typ,  From_Typ => Typ);\n+            Propagate_Invariant_Attributes (Full_Base, From_Typ => Typ);\n+            Propagate_Invariant_Attributes (CRec_Typ,  From_Typ => Typ);\n+\n+            --  Chain the pragma on to the rep item chain, for processing when\n+            --  the type is frozen.\n+\n+            Discard := Rep_Item_Too_Late (Typ, N, FOnly => True);\n+\n+            --  Create the declaration of the invariant procedure which will\n+            --  verify the invariant at run-time. Note that interfaces do not\n+            --  carry such a declaration.\n+\n+            Build_Invariant_Procedure_Declaration (Typ);\n          end Invariant;\n \n          ----------------"}, {"sha": "f6fb056d192184e769ac86f02932e82f2997fcf9", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=3ddfabe34fbcf04822c794f1dc8e1740811ad016", "patch": "@@ -4223,14 +4223,19 @@ package body Sem_Res is\n                then\n                   Error_Msg_NE (\"actual for& must be a variable\", A, F);\n \n-                  if Is_Subprogram (Current_Scope)\n-                    and then\n-                      (Is_Invariant_Procedure (Current_Scope)\n-                        or else Is_Predicate_Function (Current_Scope))\n-                  then\n-                     Error_Msg_N\n-                       (\"function used in predicate cannot \"\n-                        & \"modify its argument\", F);\n+                  if Is_Subprogram (Current_Scope) then\n+                     if Is_Invariant_Procedure (Current_Scope)\n+                       or else Is_Partial_Invariant_Procedure (Current_Scope)\n+                     then\n+                        Error_Msg_N\n+                          (\"function used in invariant cannot modify its \"\n+                           & \"argument\", F);\n+\n+                     elsif Is_Predicate_Function (Current_Scope) then\n+                        Error_Msg_N\n+                          (\"function used in predicate cannot modify its \"\n+                           & \"argument\", F);\n+                     end if;\n                   end if;\n                end if;\n "}, {"sha": "1dd35e4884ff99c076a5954e3b2a52f4eec6dc93", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 148, "deletions": 7, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=3ddfabe34fbcf04822c794f1dc8e1740811ad016", "patch": "@@ -8622,6 +8622,76 @@ package body Sem_Util is\n       return Empty;\n    end Get_User_Defined_Eq;\n \n+   ---------------\n+   -- Get_Views --\n+   ---------------\n+\n+   procedure Get_Views\n+     (Typ       : Entity_Id;\n+      Priv_Typ  : out Entity_Id;\n+      Full_Typ  : out Entity_Id;\n+      Full_Base : out Entity_Id;\n+      CRec_Typ  : out Entity_Id)\n+   is\n+   begin\n+      --  Assume that none of the views can be recovered\n+\n+      Priv_Typ  := Empty;\n+      Full_Typ  := Empty;\n+      Full_Base := Empty;\n+      CRec_Typ  := Empty;\n+\n+      --  The input type is private\n+\n+      if Is_Private_Type (Typ) then\n+         Priv_Typ := Typ;\n+         Full_Typ := Full_View (Priv_Typ);\n+\n+         if Present (Full_Typ) then\n+            Full_Base := Base_Type (Full_Typ);\n+\n+            if Ekind_In (Full_Typ, E_Protected_Type, E_Task_Type) then\n+               CRec_Typ := Corresponding_Record_Type (Full_Typ);\n+            end if;\n+         end if;\n+\n+      --  The input type is the corresponding record type of a protected or a\n+      --  task type.\n+\n+      elsif Ekind (Typ) = E_Record_Type\n+        and then Is_Concurrent_Record_Type (Typ)\n+      then\n+         CRec_Typ  := Typ;\n+         Full_Typ  := Corresponding_Concurrent_Type (CRec_Typ);\n+         Full_Base := Base_Type (Full_Typ);\n+         Priv_Typ  := Incomplete_Or_Partial_View (Full_Typ);\n+\n+      --  Otherwise the input type could be the full view of a private type\n+\n+      else\n+         Full_Typ  := Typ;\n+         Full_Base := Base_Type (Full_Typ);\n+\n+         if Ekind_In (Full_Typ, E_Protected_Type, E_Task_Type) then\n+            CRec_Typ := Corresponding_Record_Type (Full_Typ);\n+         end if;\n+\n+         --  The type is the full view of a private type, obtain the partial\n+         --  view.\n+\n+         if Has_Private_Declaration (Full_Typ)\n+           and then not Is_Private_Type (Full_Typ)\n+         then\n+            Priv_Typ := Incomplete_Or_Partial_View (Full_Typ);\n+\n+            --  The full view of a private type should always have a partial\n+            --  view.\n+\n+            pragma Assert (Present (Priv_Typ));\n+         end if;\n+      end if;\n+   end Get_Views;\n+\n    -----------------------\n    -- Has_Access_Values --\n    -----------------------\n@@ -10988,20 +11058,31 @@ package body Sem_Util is\n          while Present (Decl) loop\n             Match := Empty;\n \n+            --  The partial view of a Taft-amendment type is an incomplete\n+            --  type.\n+\n             if Taft then\n                if Nkind (Decl) = N_Incomplete_Type_Declaration then\n                   Match := Defining_Identifier (Decl);\n                end if;\n \n-            else\n-               if Nkind_In (Decl, N_Private_Extension_Declaration,\n+            --  Otherwise look for a private type whose full view matches the\n+            --  input type. Note that this checks full_type_declaration nodes\n+            --  to account for derivations from a private type where the type\n+            --  declaration hold the partial view and the full view is an\n+            --  itype.\n+\n+            elsif Nkind_In (Decl, N_Full_Type_Declaration,\n+                                  N_Private_Extension_Declaration,\n                                   N_Private_Type_Declaration)\n-               then\n-                  Match := Defining_Identifier (Decl);\n-               end if;\n+            then\n+               Match := Defining_Identifier (Decl);\n             end if;\n \n+            --  Guard against unanalyzed entities\n+\n             if Present (Match)\n+              and then Is_Type (Match)\n               and then Present (Full_View (Match))\n               and then Full_View (Match) = Id\n             then\n@@ -11040,7 +11121,9 @@ package body Sem_Util is\n          Pkg_Decl : Node_Id := Pkg;\n \n       begin\n-         if Present (Pkg) and then Ekind (Pkg) = E_Package then\n+         if Present (Pkg)\n+           and then Ekind_In (Pkg, E_Generic_Package, E_Package)\n+         then\n             while Nkind (Pkg_Decl) /= N_Package_Specification loop\n                Pkg_Decl := Parent (Pkg_Decl);\n             end loop;\n@@ -18519,13 +18602,71 @@ package body Sem_Util is\n       Set_Sloc (Endl, Loc);\n    end Process_End_Label;\n \n+   ------------------------------------\n+   -- Propagate_Invariant_Attributes --\n+   ------------------------------------\n+\n+   procedure Propagate_Invariant_Attributes\n+     (Typ      : Entity_Id;\n+      From_Typ : Entity_Id)\n+   is\n+      Full_IP : Entity_Id;\n+      Part_IP : Entity_Id;\n+\n+   begin\n+      if Present (Typ) and then Present (From_Typ) then\n+         pragma Assert (Is_Type (Typ) and then Is_Type (From_Typ));\n+\n+         --  Nothing to do if both the source and the destination denote the\n+         --  same type.\n+\n+         if From_Typ = Typ then\n+            return;\n+         end if;\n+\n+         Full_IP := Invariant_Procedure (From_Typ);\n+         Part_IP := Partial_Invariant_Procedure (From_Typ);\n+\n+         --  The setting of the attributes is intentionally conservative. This\n+         --  prevents accidental clobbering of enabled attributes.\n+\n+         if Has_Inheritable_Invariants (From_Typ)\n+           and then not Has_Inheritable_Invariants (Typ)\n+         then\n+            Set_Has_Inheritable_Invariants (Typ, True);\n+         end if;\n+\n+         if Has_Inherited_Invariants (From_Typ)\n+           and then not Has_Inherited_Invariants (Typ)\n+         then\n+            Set_Has_Inherited_Invariants (Typ, True);\n+         end if;\n+\n+         if Has_Own_Invariants (From_Typ)\n+           and then not Has_Own_Invariants (Typ)\n+         then\n+            Set_Has_Own_Invariants (Typ, True);\n+         end if;\n+\n+         if Present (Full_IP) and then No (Invariant_Procedure (Typ)) then\n+            Set_Invariant_Procedure (Typ, Full_IP);\n+         end if;\n+\n+         if Present (Part_IP) and then No (Partial_Invariant_Procedure (Typ))\n+         then\n+            Set_Partial_Invariant_Procedure (Typ, Part_IP);\n+         end if;\n+      end if;\n+   end Propagate_Invariant_Attributes;\n+\n    --------------------------------\n    -- Propagate_Concurrent_Flags --\n    --------------------------------\n \n    procedure Propagate_Concurrent_Flags\n      (Typ      : Entity_Id;\n-      Comp_Typ : Entity_Id) is\n+      Comp_Typ : Entity_Id)\n+   is\n    begin\n       if Has_Task (Comp_Typ) then\n          Set_Has_Task (Typ);"}, {"sha": "d0bb92d9b48289bdf40698c4f1ca24d1979ba247", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ddfabe34fbcf04822c794f1dc8e1740811ad016/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=3ddfabe34fbcf04822c794f1dc8e1740811ad016", "patch": "@@ -1005,6 +1005,20 @@ package Sem_Util is\n    --  For a type entity, return the entity of the primitive equality function\n    --  for the type if it exists, otherwise return Empty.\n \n+   procedure Get_Views\n+     (Typ       : Entity_Id;\n+      Priv_Typ  : out Entity_Id;\n+      Full_Typ  : out Entity_Id;\n+      Full_Base : out Entity_Id;\n+      CRec_Typ  : out Entity_Id);\n+   --  Obtain the partial and full view of type Typ and in addition any extra\n+   --  types the full view may have. The return entities are as follows:\n+   --\n+   --    Priv_Typ  - the partial view (a private type)\n+   --    Full_Typ  - the full view\n+   --    Full_Base - the base type of the full view\n+   --    CRec_Typ  - the corresponding record type of the full view\n+\n    function Has_Access_Values (T : Entity_Id) return Boolean;\n    --  Returns true if type or subtype T is an access type, or has a component\n    --  (at any recursive level) that is an access type. This is a conservative\n@@ -2022,6 +2036,12 @@ package Sem_Util is\n    --  parameter Ent gives the entity to which the End_Label refers,\n    --  and to which cross-references are to be generated.\n \n+   procedure Propagate_Invariant_Attributes\n+     (Typ      : Entity_Id;\n+      From_Typ : Entity_Id);\n+   --  Inherit all invariant-related attributes form type From_Typ. Typ is the\n+   --  destination type.\n+\n    procedure Propagate_Concurrent_Flags\n      (Typ      : Entity_Id;\n       Comp_Typ : Entity_Id);"}]}