{"sha": "2aca9d5b92723ee3e34b011902582e8738208695", "node_id": "C_kwDOANBUbNoAKDJhY2E5ZDViOTI3MjNlZTNlMzRiMDExOTAyNTgyZTg3MzgyMDg2OTU", "commit": {"author": {"name": "chenglulu", "email": "chenglulu@loongson.cn", "date": "2021-11-27T07:00:22Z"}, "committer": {"name": "Chenghua Xu", "email": "paul.hua.gm@gmail.com", "date": "2022-03-29T09:43:34Z"}, "message": "LoongArch Port: Builtin functions.\n\n2022-03-29  Chenghua Xu  <xuchenghua@loongson.cn>\n\t    Lulu Cheng  <chenglulu@loongson.cn>\n\ngcc/ChangeLog:\n\n\t* config/loongarch/larchintrin.h: New file.\n\t* config/loongarch/loongarch-builtins.cc: New file.", "tree": {"sha": "9c0d4dec22c602a0972b0edf357c9c3f71fddf97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c0d4dec22c602a0972b0edf357c9c3f71fddf97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2aca9d5b92723ee3e34b011902582e8738208695", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2aca9d5b92723ee3e34b011902582e8738208695", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2aca9d5b92723ee3e34b011902582e8738208695", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2aca9d5b92723ee3e34b011902582e8738208695/comments", "author": {"login": "chenglulu326", "id": 88083425, "node_id": "MDQ6VXNlcjg4MDgzNDI1", "avatar_url": "https://avatars.githubusercontent.com/u/88083425?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenglulu326", "html_url": "https://github.com/chenglulu326", "followers_url": "https://api.github.com/users/chenglulu326/followers", "following_url": "https://api.github.com/users/chenglulu326/following{/other_user}", "gists_url": "https://api.github.com/users/chenglulu326/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenglulu326/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenglulu326/subscriptions", "organizations_url": "https://api.github.com/users/chenglulu326/orgs", "repos_url": "https://api.github.com/users/chenglulu326/repos", "events_url": "https://api.github.com/users/chenglulu326/events{/privacy}", "received_events_url": "https://api.github.com/users/chenglulu326/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ChenghuaXu", "id": 87753117, "node_id": "MDQ6VXNlcjg3NzUzMTE3", "avatar_url": "https://avatars.githubusercontent.com/u/87753117?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChenghuaXu", "html_url": "https://github.com/ChenghuaXu", "followers_url": "https://api.github.com/users/ChenghuaXu/followers", "following_url": "https://api.github.com/users/ChenghuaXu/following{/other_user}", "gists_url": "https://api.github.com/users/ChenghuaXu/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChenghuaXu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChenghuaXu/subscriptions", "organizations_url": "https://api.github.com/users/ChenghuaXu/orgs", "repos_url": "https://api.github.com/users/ChenghuaXu/repos", "events_url": "https://api.github.com/users/ChenghuaXu/events{/privacy}", "received_events_url": "https://api.github.com/users/ChenghuaXu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62ec3b5352b3be1c52846e9b64e911d8482c21c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62ec3b5352b3be1c52846e9b64e911d8482c21c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62ec3b5352b3be1c52846e9b64e911d8482c21c1"}], "stats": {"total": 779, "additions": 779, "deletions": 0}, "files": [{"sha": "2833f148709c57eb8602949b6a4bc76b428c420a", "filename": "gcc/config/loongarch/larchintrin.h", "status": "added", "additions": 355, "deletions": 0, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aca9d5b92723ee3e34b011902582e8738208695/gcc%2Fconfig%2Floongarch%2Flarchintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aca9d5b92723ee3e34b011902582e8738208695/gcc%2Fconfig%2Floongarch%2Flarchintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Flarchintrin.h?ref=2aca9d5b92723ee3e34b011902582e8738208695", "patch": "@@ -0,0 +1,355 @@\n+/* Intrinsics for LoongArch BASE operations.\n+   Copyright (C) 2021-2022 Free Software Foundation, Inc.\n+   Contributed by Loongson Ltd.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published\n+by the Free Software Foundation; either version 3, or (at your\n+option) any later version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef _GCC_LOONGARCH_BASE_INTRIN_H\n+#define _GCC_LOONGARCH_BASE_INTRIN_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+typedef struct drdtime\n+{\n+  unsigned long dvalue;\n+  unsigned long dtimeid;\n+} __drdtime_t;\n+\n+typedef struct rdtime\n+{\n+  unsigned int value;\n+  unsigned int timeid;\n+} __rdtime_t;\n+\n+#ifdef __loongarch64\n+extern __inline __drdtime_t\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__rdtime_d (void)\n+{\n+  __drdtime_t __drdtime;\n+  __asm__ volatile (\n+    \"rdtime.d\\t%[val],%[tid]\\n\\t\"\n+    : [val]\"=&r\"(__drdtime.dvalue),[tid]\"=&r\"(__drdtime.dtimeid)\n+    :);\n+  return __drdtime;\n+}\n+#endif\n+\n+extern __inline __rdtime_t\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__rdtimeh_w (void)\n+{\n+  __rdtime_t __rdtime;\n+  __asm__ volatile (\n+    \"rdtimeh.w\\t%[val],%[tid]\\n\\t\"\n+    : [val]\"=&r\"(__rdtime.value),[tid]\"=&r\"(__rdtime.timeid)\n+    :);\n+  return __rdtime;\n+}\n+\n+extern __inline __rdtime_t\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__rdtimel_w (void)\n+{\n+  __rdtime_t __rdtime;\n+  __asm__ volatile (\n+    \"rdtimel.w\\t%[val],%[tid]\\n\\t\"\n+    : [val]\"=&r\"(__rdtime.value),[tid]\"=&r\"(__rdtime.timeid)\n+    :);\n+  return __rdtime;\n+}\n+\n+/* Assembly instruction format:\trj, fcsr.  */\n+/* Data types in instruction templates:  USI, UQI.  */\n+#define __movfcsr2gr(/*ui5*/ _1) __builtin_loongarch_movfcsr2gr ((_1));\n+\n+/* Assembly instruction format:\tfcsr, rj.  */\n+/* Data types in instruction templates:  VOID, UQI, USI.  */\n+#define __movgr2fcsr(/*ui5*/ _1, _2) \\\n+  __builtin_loongarch_movgr2fcsr ((_1), (unsigned int) _2);\n+\n+#if defined __loongarch64\n+/* Assembly instruction format:\tui5, rj, si12.  */\n+/* Data types in instruction templates:  VOID, USI, UDI, SI.  */\n+#define __cacop_d(/*ui5*/ _1, /*unsigned long int*/ _2, /*si12*/ _3) \\\n+  ((void) __builtin_loongarch_cacop_d ((_1), (unsigned long int) (_2), (_3)))\n+#else\n+#error \"Unsupported ABI.\"\n+#endif\n+\n+/* Assembly instruction format:\trd, rj.  */\n+/* Data types in instruction templates:  USI, USI.  */\n+extern __inline unsigned int\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__cpucfg (unsigned int _1)\n+{\n+  return (unsigned int) __builtin_loongarch_cpucfg ((unsigned int) _1);\n+}\n+\n+#ifdef __loongarch64\n+/* Assembly instruction format:\trj, rk.  */\n+/* Data types in instruction templates:  DI, DI.  */\n+extern __inline void\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__asrtle_d (long int _1, long int _2)\n+{\n+  __builtin_loongarch_asrtle_d ((long int) _1, (long int) _2);\n+}\n+\n+/* Assembly instruction format:\trj, rk.  */\n+/* Data types in instruction templates:  DI, DI.  */\n+extern __inline void\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__asrtgt_d (long int _1, long int _2)\n+{\n+  __builtin_loongarch_asrtgt_d ((long int) _1, (long int) _2);\n+}\n+#endif\n+\n+#if defined __loongarch64\n+/* Assembly instruction format:\trd, rj, ui5.  */\n+/* Data types in instruction templates:  DI, DI, UQI.  */\n+#define __lddir_d(/*long int*/ _1, /*ui5*/ _2) \\\n+  ((long int) __builtin_loongarch_lddir_d ((long int) (_1), (_2)))\n+#else\n+#error \"Unsupported ABI.\"\n+#endif\n+\n+#if defined __loongarch64\n+/* Assembly instruction format:\trj, ui5.  */\n+/* Data types in instruction templates:  VOID, DI, UQI.  */\n+#define __ldpte_d(/*long int*/ _1, /*ui5*/ _2) \\\n+  ((void) __builtin_loongarch_ldpte_d ((long int) (_1), (_2)))\n+#else\n+#error \"Unsupported ABI.\"\n+#endif\n+\n+/* Assembly instruction format:\trd, rj, rk.  */\n+/* Data types in instruction templates:  SI, QI, SI.  */\n+extern __inline int\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__crc_w_b_w (char _1, int _2)\n+{\n+  return (int) __builtin_loongarch_crc_w_b_w ((char) _1, (int) _2);\n+}\n+\n+/* Assembly instruction format:\trd, rj, rk.  */\n+/* Data types in instruction templates:  SI, HI, SI.  */\n+extern __inline int\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__crc_w_h_w (short _1, int _2)\n+{\n+  return (int) __builtin_loongarch_crc_w_h_w ((short) _1, (int) _2);\n+}\n+\n+/* Assembly instruction format:\trd, rj, rk.  */\n+/* Data types in instruction templates:  SI, SI, SI.  */\n+extern __inline int\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__crc_w_w_w (int _1, int _2)\n+{\n+  return (int) __builtin_loongarch_crc_w_w_w ((int) _1, (int) _2);\n+}\n+\n+#ifdef __loongarch64\n+/* Assembly instruction format:\trd, rj, rk.  */\n+/* Data types in instruction templates:  SI, DI, SI.  */\n+extern __inline int\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__crc_w_d_w (long int _1, int _2)\n+{\n+  return (int) __builtin_loongarch_crc_w_d_w ((long int) _1, (int) _2);\n+}\n+#endif\n+\n+/* Assembly instruction format:\trd, rj, rk.  */\n+/* Data types in instruction templates:  SI, QI, SI.  */\n+extern __inline int\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__crcc_w_b_w (char _1, int _2)\n+{\n+  return (int) __builtin_loongarch_crcc_w_b_w ((char) _1, (int) _2);\n+}\n+\n+/* Assembly instruction format:\trd, rj, rk.  */\n+/* Data types in instruction templates:  SI, HI, SI.  */\n+extern __inline int\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__crcc_w_h_w (short _1, int _2)\n+{\n+  return (int) __builtin_loongarch_crcc_w_h_w ((short) _1, (int) _2);\n+}\n+\n+/* Assembly instruction format:\trd, rj, rk.  */\n+/* Data types in instruction templates:  SI, SI, SI.  */\n+extern __inline int\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__crcc_w_w_w (int _1, int _2)\n+{\n+  return (int) __builtin_loongarch_crcc_w_w_w ((int) _1, (int) _2);\n+}\n+\n+#ifdef __loongarch64\n+/* Assembly instruction format:\trd, rj, rk.  */\n+/* Data types in instruction templates:  SI, DI, SI.  */\n+extern __inline int\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__crcc_w_d_w (long int _1, int _2)\n+{\n+  return (int) __builtin_loongarch_crcc_w_d_w ((long int) _1, (int) _2);\n+}\n+#endif\n+\n+/* Assembly instruction format:\trd, ui14.  */\n+/* Data types in instruction templates:  USI, USI.  */\n+#define __csrrd_w(/*ui14*/ _1) \\\n+  ((unsigned int) __builtin_loongarch_csrrd_w ((_1)))\n+\n+/* Assembly instruction format:\trd, ui14.  */\n+/* Data types in instruction templates:  USI, USI, USI.  */\n+#define __csrwr_w(/*unsigned int*/ _1, /*ui14*/ _2) \\\n+  ((unsigned int) __builtin_loongarch_csrwr_w ((unsigned int) (_1), (_2)))\n+\n+/* Assembly instruction format:\trd, rj, ui14.  */\n+/* Data types in instruction templates:  USI, USI, USI, USI.  */\n+#define __csrxchg_w(/*unsigned int*/ _1, /*unsigned int*/ _2, /*ui14*/ _3) \\\n+  ((unsigned int) __builtin_loongarch_csrxchg_w ((unsigned int) (_1), \\\n+\t\t\t\t\t       (unsigned int) (_2), (_3)))\n+\n+#ifdef __loongarch64\n+/* Assembly instruction format:\trd, ui14.  */\n+/* Data types in instruction templates:  UDI, USI.  */\n+#define __csrrd_d(/*ui14*/ _1) \\\n+  ((unsigned long int) __builtin_loongarch_csrrd_d ((_1)))\n+\n+/* Assembly instruction format:\trd, ui14.  */\n+/* Data types in instruction templates:  UDI, UDI, USI.  */\n+#define __csrwr_d(/*unsigned long int*/ _1, /*ui14*/ _2) \\\n+  ((unsigned long int) __builtin_loongarch_csrwr_d ((unsigned long int) (_1), \\\n+\t\t\t\t\t\t   (_2)))\n+\n+/* Assembly instruction format:\trd, rj, ui14.  */\n+/* Data types in instruction templates:  UDI, UDI, UDI, USI.  */\n+#define __csrxchg_d(/*unsigned long int*/ _1, /*unsigned long int*/ _2, \\\n+\t\t   /*ui14*/ _3) \\\n+  ((unsigned long int) __builtin_loongarch_csrxchg_d ( \\\n+    (unsigned long int) (_1), (unsigned long int) (_2), (_3)))\n+#endif\n+\n+/* Assembly instruction format:\trd, rj.  */\n+/* Data types in instruction templates:  UQI, USI.  */\n+extern __inline unsigned char\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__iocsrrd_b (unsigned int _1)\n+{\n+  return (unsigned char) __builtin_loongarch_iocsrrd_b ((unsigned int) _1);\n+}\n+\n+/* Assembly instruction format:\trd, rj.  */\n+/* Data types in instruction templates:  UHI, USI.  */\n+extern __inline unsigned char\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__iocsrrd_h (unsigned int _1)\n+{\n+  return (unsigned short) __builtin_loongarch_iocsrrd_h ((unsigned int) _1);\n+}\n+\n+/* Assembly instruction format:\trd, rj.  */\n+/* Data types in instruction templates:  USI, USI.  */\n+extern __inline unsigned int\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__iocsrrd_w (unsigned int _1)\n+{\n+  return (unsigned int) __builtin_loongarch_iocsrrd_w ((unsigned int) _1);\n+}\n+\n+#ifdef __loongarch64\n+/* Assembly instruction format:\trd, rj.  */\n+/* Data types in instruction templates:  UDI, USI.  */\n+extern __inline unsigned long int\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__iocsrrd_d (unsigned int _1)\n+{\n+  return (unsigned long int) __builtin_loongarch_iocsrrd_d ((unsigned int) _1);\n+}\n+#endif\n+\n+/* Assembly instruction format:\trd, rj.  */\n+/* Data types in instruction templates:  VOID, UQI, USI.  */\n+extern __inline void\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__iocsrwr_b (unsigned char _1, unsigned int _2)\n+{\n+  __builtin_loongarch_iocsrwr_b ((unsigned char) _1, (unsigned int) _2);\n+}\n+\n+/* Assembly instruction format:\trd, rj.  */\n+/* Data types in instruction templates:  VOID, UHI, USI.  */\n+extern __inline void\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__iocsrwr_h (unsigned short _1, unsigned int _2)\n+{\n+  __builtin_loongarch_iocsrwr_h ((unsigned short) _1, (unsigned int) _2);\n+}\n+\n+/* Assembly instruction format:\trd, rj.  */\n+/* Data types in instruction templates:  VOID, USI, USI.  */\n+extern __inline void\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__iocsrwr_w (unsigned int _1, unsigned int _2)\n+{\n+  __builtin_loongarch_iocsrwr_w ((unsigned int) _1, (unsigned int) _2);\n+}\n+\n+#ifdef __loongarch64\n+/* Assembly instruction format:\trd, rj.  */\n+/* Data types in instruction templates:  VOID, UDI, USI.  */\n+extern __inline void\n+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))\n+__iocsrwr_d (unsigned long int _1, unsigned int _2)\n+{\n+  __builtin_loongarch_iocsrwr_d ((unsigned long int) _1, (unsigned int) _2);\n+}\n+#endif\n+\n+/* Assembly instruction format:\tui15.  */\n+/* Data types in instruction templates:  USI.  */\n+#define __dbar(/*ui15*/ _1) __builtin_loongarch_dbar ((_1))\n+\n+/* Assembly instruction format:\tui15.  */\n+/* Data types in instruction templates:  USI.  */\n+#define __ibar(/*ui15*/ _1) __builtin_loongarch_ibar ((_1))\n+\n+/* Assembly instruction format:\tui15.  */\n+/* Data types in instruction templates:  USI.  */\n+#define __syscall(/*ui15*/ _1) __builtin_loongarch_syscall ((_1))\n+\n+/* Assembly instruction format:\tui15.  */\n+/* Data types in instruction templates:  USI.  */\n+#define __break(/*ui15*/ _1) __builtin_loongarch_break ((_1))\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+#endif /* _GCC_LOONGARCH_BASE_INTRIN_H */"}, {"sha": "64fe11168fa21b6d826caaaf729823a029340fb8", "filename": "gcc/config/loongarch/loongarch-builtins.cc", "status": "added", "additions": 424, "deletions": 0, "changes": 424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2aca9d5b92723ee3e34b011902582e8738208695/gcc%2Fconfig%2Floongarch%2Floongarch-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2aca9d5b92723ee3e34b011902582e8738208695/gcc%2Fconfig%2Floongarch%2Floongarch-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Floongarch-builtins.cc?ref=2aca9d5b92723ee3e34b011902582e8738208695", "patch": "@@ -0,0 +1,424 @@\n+/* Subroutines used for expanding LoongArch builtins.\n+   Copyright (C) 2021-2022 Free Software Foundation, Inc.\n+   Contributed by Loongson Ltd.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#define IN_TARGET_CODE 1\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"target.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"memmodel.h\"\n+#include \"gimple.h\"\n+#include \"tm_p.h\"\n+#include \"optabs.h\"\n+#include \"recog.h\"\n+#include \"diagnostic.h\"\n+#include \"fold-const.h\"\n+#include \"expr.h\"\n+#include \"langhooks.h\"\n+\n+/* Macros to create an enumeration identifier for a function prototype.  */\n+#define LARCH_FTYPE_NAME1(A, B) LARCH_##A##_FTYPE_##B\n+#define LARCH_FTYPE_NAME2(A, B, C) LARCH_##A##_FTYPE_##B##_##C\n+#define LARCH_FTYPE_NAME3(A, B, C, D) LARCH_##A##_FTYPE_##B##_##C##_##D\n+\n+/* Classifies the prototype of a built-in function.  */\n+enum loongarch_function_type\n+{\n+#define DEF_LARCH_FTYPE(NARGS, LIST) LARCH_FTYPE_NAME##NARGS LIST,\n+#include \"config/loongarch/loongarch-ftypes.def\"\n+#undef DEF_LARCH_FTYPE\n+  LARCH_MAX_FTYPE_MAX\n+};\n+\n+/* Specifies how a built-in function should be converted into rtl.  */\n+enum loongarch_builtin_type\n+{\n+  /* The function corresponds directly to an .md pattern.  The return\n+     value is mapped to operand 0 and the arguments are mapped to\n+     operands 1 and above.  */\n+  LARCH_BUILTIN_DIRECT,\n+\n+  /* The function corresponds directly to an .md pattern.  There is no return\n+     value and the arguments are mapped to operands 0 and above.  */\n+  LARCH_BUILTIN_DIRECT_NO_TARGET,\n+\n+};\n+\n+/* Declare an availability predicate for built-in functions that require\n+ * COND to be true.  NAME is the main part of the predicate's name.  */\n+#define AVAIL_ALL(NAME, COND) \\\n+  static unsigned int \\\n+  loongarch_builtin_avail_##NAME (void) \\\n+  { \\\n+    return (COND) ? 1 : 0; \\\n+  }\n+\n+static unsigned int\n+loongarch_builtin_avail_default (void)\n+{\n+  return 1;\n+}\n+/* This structure describes a single built-in function.  */\n+struct loongarch_builtin_description\n+{\n+  /* The code of the main .md file instruction.  See loongarch_builtin_type\n+     for more information.  */\n+  enum insn_code icode;\n+\n+  /* The name of the built-in function.  */\n+  const char *name;\n+\n+  /* Specifies how the function should be expanded.  */\n+  enum loongarch_builtin_type builtin_type;\n+\n+  /* The function's prototype.  */\n+  enum loongarch_function_type function_type;\n+\n+  /* Whether the function is available.  */\n+  unsigned int (*avail) (void);\n+};\n+\n+AVAIL_ALL (hard_float, TARGET_HARD_FLOAT_ABI)\n+\n+/* Construct a loongarch_builtin_description from the given arguments.\n+\n+   INSN is the name of the associated instruction pattern, without the\n+   leading CODE_FOR_loongarch_.\n+\n+   CODE is the floating-point condition code associated with the\n+   function.  It can be 'f' if the field is not applicable.\n+\n+   NAME is the name of the function itself, without the leading\n+   \"__builtin_loongarch_\".\n+\n+   BUILTIN_TYPE and FUNCTION_TYPE are loongarch_builtin_description fields.\n+\n+   AVAIL is the name of the availability predicate, without the leading\n+   loongarch_builtin_avail_.  */\n+#define LARCH_BUILTIN(INSN, NAME, BUILTIN_TYPE, FUNCTION_TYPE, AVAIL) \\\n+  { \\\n+    CODE_FOR_loongarch_##INSN, \"__builtin_loongarch_\" NAME, \\\n+      BUILTIN_TYPE, FUNCTION_TYPE, \\\n+      loongarch_builtin_avail_##AVAIL \\\n+  }\n+\n+/* Define __builtin_loongarch_<INSN>, which is a LARCH_BUILTIN_DIRECT function\n+   mapped to instruction CODE_FOR_loongarch_<INSN>,  FUNCTION_TYPE and AVAIL\n+   are as for LARCH_BUILTIN.  */\n+#define DIRECT_BUILTIN(INSN, FUNCTION_TYPE, AVAIL) \\\n+  LARCH_BUILTIN (INSN, #INSN, LARCH_BUILTIN_DIRECT, FUNCTION_TYPE, AVAIL)\n+\n+/* Define __builtin_loongarch_<INSN>, which is a LARCH_BUILTIN_DIRECT_NO_TARGET\n+   function mapped to instruction CODE_FOR_loongarch_<INSN>,  FUNCTION_TYPE\n+   and AVAIL are as for LARCH_BUILTIN.  */\n+#define DIRECT_NO_TARGET_BUILTIN(INSN, FUNCTION_TYPE, AVAIL) \\\n+  LARCH_BUILTIN (INSN, #INSN, LARCH_BUILTIN_DIRECT_NO_TARGET, \\\n+\t\t FUNCTION_TYPE, AVAIL)\n+\n+static const struct loongarch_builtin_description loongarch_builtins[] = {\n+#define LARCH_MOVFCSR2GR 0\n+  DIRECT_BUILTIN (movfcsr2gr, LARCH_USI_FTYPE_UQI, hard_float),\n+#define LARCH_MOVGR2FCSR 1\n+  DIRECT_NO_TARGET_BUILTIN (movgr2fcsr, LARCH_VOID_FTYPE_UQI_USI, hard_float),\n+\n+  DIRECT_NO_TARGET_BUILTIN (cacop_w, LARCH_VOID_FTYPE_USI_USI_SI, default),\n+  DIRECT_NO_TARGET_BUILTIN (cacop_d, LARCH_VOID_FTYPE_USI_UDI_SI, default),\n+  DIRECT_NO_TARGET_BUILTIN (dbar, LARCH_VOID_FTYPE_USI, default),\n+  DIRECT_NO_TARGET_BUILTIN (ibar, LARCH_VOID_FTYPE_USI, default),\n+\n+  DIRECT_BUILTIN (lddir_d, LARCH_DI_FTYPE_DI_UQI, default),\n+  DIRECT_BUILTIN (lddir_w, LARCH_SI_FTYPE_SI_UQI, default),\n+  DIRECT_NO_TARGET_BUILTIN (ldpte_d, LARCH_VOID_FTYPE_DI_UQI, default),\n+  DIRECT_NO_TARGET_BUILTIN (ldpte_w, LARCH_VOID_FTYPE_SI_UQI, default),\n+\n+  /* CRC Instrinsic */\n+\n+  DIRECT_BUILTIN (crc_w_b_w, LARCH_SI_FTYPE_QI_SI, default),\n+  DIRECT_BUILTIN (crc_w_h_w, LARCH_SI_FTYPE_HI_SI, default),\n+  DIRECT_BUILTIN (crc_w_w_w, LARCH_SI_FTYPE_SI_SI, default),\n+  DIRECT_BUILTIN (crc_w_d_w, LARCH_SI_FTYPE_DI_SI, default),\n+  DIRECT_BUILTIN (crcc_w_b_w, LARCH_SI_FTYPE_QI_SI, default),\n+  DIRECT_BUILTIN (crcc_w_h_w, LARCH_SI_FTYPE_HI_SI, default),\n+  DIRECT_BUILTIN (crcc_w_w_w, LARCH_SI_FTYPE_SI_SI, default),\n+  DIRECT_BUILTIN (crcc_w_d_w, LARCH_SI_FTYPE_DI_SI, default),\n+\n+  DIRECT_BUILTIN (csrrd_w, LARCH_USI_FTYPE_USI, default),\n+  DIRECT_BUILTIN (csrrd_d, LARCH_UDI_FTYPE_USI, default),\n+  DIRECT_BUILTIN (csrwr_w, LARCH_USI_FTYPE_USI_USI, default),\n+  DIRECT_BUILTIN (csrwr_d, LARCH_UDI_FTYPE_UDI_USI, default),\n+  DIRECT_BUILTIN (csrxchg_w, LARCH_USI_FTYPE_USI_USI_USI, default),\n+  DIRECT_BUILTIN (csrxchg_d, LARCH_UDI_FTYPE_UDI_UDI_USI, default),\n+  DIRECT_BUILTIN (iocsrrd_b, LARCH_UQI_FTYPE_USI, default),\n+  DIRECT_BUILTIN (iocsrrd_h, LARCH_UHI_FTYPE_USI, default),\n+  DIRECT_BUILTIN (iocsrrd_w, LARCH_USI_FTYPE_USI, default),\n+  DIRECT_BUILTIN (iocsrrd_d, LARCH_UDI_FTYPE_USI, default),\n+  DIRECT_NO_TARGET_BUILTIN (iocsrwr_b, LARCH_VOID_FTYPE_UQI_USI, default),\n+  DIRECT_NO_TARGET_BUILTIN (iocsrwr_h, LARCH_VOID_FTYPE_UHI_USI, default),\n+  DIRECT_NO_TARGET_BUILTIN (iocsrwr_w, LARCH_VOID_FTYPE_USI_USI, default),\n+  DIRECT_NO_TARGET_BUILTIN (iocsrwr_d, LARCH_VOID_FTYPE_UDI_USI, default),\n+\n+  DIRECT_BUILTIN (cpucfg, LARCH_USI_FTYPE_USI, default),\n+  DIRECT_NO_TARGET_BUILTIN (asrtle_d, LARCH_VOID_FTYPE_DI_DI, default),\n+  DIRECT_NO_TARGET_BUILTIN (asrtgt_d, LARCH_VOID_FTYPE_DI_DI, default),\n+  DIRECT_NO_TARGET_BUILTIN (syscall, LARCH_VOID_FTYPE_USI, default),\n+  DIRECT_NO_TARGET_BUILTIN (break, LARCH_VOID_FTYPE_USI, default),\n+};\n+\n+/* Index I is the function declaration for loongarch_builtins[I], or null if\n+   the function isn't defined on this target.  */\n+static GTY (()) tree loongarch_builtin_decls[ARRAY_SIZE (loongarch_builtins)];\n+/* Get the index I of the function declaration for loongarch_builtin_decls[I]\n+   using the instruction code or return null if not defined for the target.  */\n+static GTY (()) int loongarch_get_builtin_decl_index[NUM_INSN_CODES];\n+\n+/* Source-level argument types.  */\n+#define LARCH_ATYPE_VOID void_type_node\n+#define LARCH_ATYPE_INT integer_type_node\n+#define LARCH_ATYPE_POINTER ptr_type_node\n+\n+/* Standard mode-based argument types.  */\n+#define LARCH_ATYPE_QI intQI_type_node\n+#define LARCH_ATYPE_UQI unsigned_intQI_type_node\n+#define LARCH_ATYPE_HI intHI_type_node\n+#define LARCH_ATYPE_UHI unsigned_intHI_type_node\n+#define LARCH_ATYPE_SI intSI_type_node\n+#define LARCH_ATYPE_USI unsigned_intSI_type_node\n+#define LARCH_ATYPE_DI intDI_type_node\n+#define LARCH_ATYPE_UDI unsigned_intDI_type_node\n+#define LARCH_ATYPE_SF float_type_node\n+#define LARCH_ATYPE_DF double_type_node\n+\n+/* LARCH_FTYPE_ATYPESN takes N LARCH_FTYPES-like type codes and lists\n+   their associated LARCH_ATYPEs.  */\n+#define LARCH_FTYPE_ATYPES1(A, B) LARCH_ATYPE_##A, LARCH_ATYPE_##B\n+\n+#define LARCH_FTYPE_ATYPES2(A, B, C) \\\n+  LARCH_ATYPE_##A, LARCH_ATYPE_##B, LARCH_ATYPE_##C\n+\n+#define LARCH_FTYPE_ATYPES3(A, B, C, D) \\\n+  LARCH_ATYPE_##A, LARCH_ATYPE_##B, LARCH_ATYPE_##C, LARCH_ATYPE_##D\n+\n+#define LARCH_FTYPE_ATYPES4(A, B, C, D, E) \\\n+  LARCH_ATYPE_##A, LARCH_ATYPE_##B, LARCH_ATYPE_##C, LARCH_ATYPE_##D, \\\n+  LARCH_ATYPE_##E\n+\n+/* Return the function type associated with function prototype TYPE.  */\n+\n+static tree\n+loongarch_build_function_type (enum loongarch_function_type type)\n+{\n+  static tree types[(int) LARCH_MAX_FTYPE_MAX];\n+\n+  if (types[(int) type] == NULL_TREE)\n+    switch (type)\n+      {\n+#define DEF_LARCH_FTYPE(NUM, ARGS) \\\n+  case LARCH_FTYPE_NAME##NUM ARGS: \\\n+    types[(int) type] \\\n+      = build_function_type_list (LARCH_FTYPE_ATYPES##NUM ARGS, NULL_TREE); \\\n+    break;\n+#include \"config/loongarch/loongarch-ftypes.def\"\n+#undef DEF_LARCH_FTYPE\n+      default:\n+\tgcc_unreachable ();\n+      }\n+\n+  return types[(int) type];\n+}\n+\n+/* Implement TARGET_INIT_BUILTINS.  */\n+\n+void\n+loongarch_init_builtins (void)\n+{\n+  const struct loongarch_builtin_description *d;\n+  unsigned int i;\n+  tree type;\n+\n+  /* Iterate through all of the bdesc arrays, initializing all of the\n+     builtin functions.  */\n+  for (i = 0; i < ARRAY_SIZE (loongarch_builtins); i++)\n+    {\n+      d = &loongarch_builtins[i];\n+      if (d->avail ())\n+\t{\n+\t  type = loongarch_build_function_type (d->function_type);\n+\t  loongarch_builtin_decls[i]\n+\t    = add_builtin_function (d->name, type, i, BUILT_IN_MD, NULL,\n+\t\t\t\t    NULL);\n+\t  loongarch_get_builtin_decl_index[d->icode] = i;\n+\t}\n+    }\n+}\n+\n+/* Implement TARGET_BUILTIN_DECL.  */\n+\n+tree\n+loongarch_builtin_decl (unsigned int code, bool initialize_p ATTRIBUTE_UNUSED)\n+{\n+  if (code >= ARRAY_SIZE (loongarch_builtins))\n+    return error_mark_node;\n+  return loongarch_builtin_decls[code];\n+}\n+\n+/* Take argument ARGNO from EXP's argument list and convert it into\n+   an expand operand.  Store the operand in *OP.  */\n+\n+static void\n+loongarch_prepare_builtin_arg (struct expand_operand *op, tree exp,\n+\t\t\t       unsigned int argno)\n+{\n+  tree arg;\n+  rtx value;\n+\n+  arg = CALL_EXPR_ARG (exp, argno);\n+  value = expand_normal (arg);\n+  create_input_operand (op, value, TYPE_MODE (TREE_TYPE (arg)));\n+}\n+\n+/* Expand instruction ICODE as part of a built-in function sequence.\n+   Use the first NOPS elements of OPS as the instruction's operands.\n+   HAS_TARGET_P is true if operand 0 is a target; it is false if the\n+   instruction has no target.\n+\n+   Return the target rtx if HAS_TARGET_P, otherwise return const0_rtx.  */\n+\n+static rtx\n+loongarch_expand_builtin_insn (enum insn_code icode, unsigned int nops,\n+\t\t\t       struct expand_operand *ops, bool has_target_p)\n+{\n+  if (!maybe_expand_insn (icode, nops, ops))\n+    {\n+      error (\"invalid argument to built-in function\");\n+      return has_target_p ? gen_reg_rtx (ops[0].mode) : const0_rtx;\n+    }\n+  return has_target_p ? ops[0].value : const0_rtx;\n+}\n+\n+/* Expand a LARCH_BUILTIN_DIRECT or LARCH_BUILTIN_DIRECT_NO_TARGET function;\n+   HAS_TARGET_P says which.  EXP is the CALL_EXPR that calls the function\n+   and ICODE is the code of the associated .md pattern.  TARGET, if nonnull,\n+   suggests a good place to put the result.  */\n+\n+static rtx\n+loongarch_expand_builtin_direct (enum insn_code icode, rtx target, tree exp,\n+\t\t\t\t bool has_target_p)\n+{\n+  struct expand_operand ops[MAX_RECOG_OPERANDS];\n+  int opno, argno;\n+\n+  /* Map any target to operand 0.  */\n+  opno = 0;\n+  if (has_target_p)\n+    create_output_operand (&ops[opno++], target, TYPE_MODE (TREE_TYPE (exp)));\n+\n+  /* Map the arguments to the other operands.  */\n+  gcc_assert (opno + call_expr_nargs (exp)\n+\t      == insn_data[icode].n_generator_args);\n+  for (argno = 0; argno < call_expr_nargs (exp); argno++)\n+    loongarch_prepare_builtin_arg (&ops[opno++], exp, argno);\n+\n+  return loongarch_expand_builtin_insn (icode, opno, ops, has_target_p);\n+}\n+\n+/* Implement TARGET_EXPAND_BUILTIN.  */\n+\n+rtx\n+loongarch_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n+\t\t\t  machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t  int ignore ATTRIBUTE_UNUSED)\n+{\n+  tree fndecl;\n+  unsigned int fcode, avail;\n+  const struct loongarch_builtin_description *d;\n+\n+  fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n+  fcode = DECL_MD_FUNCTION_CODE (fndecl);\n+  gcc_assert (fcode < ARRAY_SIZE (loongarch_builtins));\n+  d = &loongarch_builtins[fcode];\n+  avail = d->avail ();\n+  gcc_assert (avail != 0);\n+  switch (d->builtin_type)\n+    {\n+    case LARCH_BUILTIN_DIRECT:\n+      return loongarch_expand_builtin_direct (d->icode, target, exp, true);\n+\n+    case LARCH_BUILTIN_DIRECT_NO_TARGET:\n+      return loongarch_expand_builtin_direct (d->icode, target, exp, false);\n+    }\n+  gcc_unreachable ();\n+}\n+\n+/* Implement TARGET_ATOMIC_ASSIGN_EXPAND_FENV.  */\n+\n+void\n+loongarch_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)\n+{\n+  if (!TARGET_HARD_FLOAT_ABI)\n+    return;\n+  tree exceptions_var = create_tmp_var_raw (LARCH_ATYPE_USI);\n+  tree fcsr_orig_var = create_tmp_var_raw (LARCH_ATYPE_USI);\n+  tree fcsr_mod_var = create_tmp_var_raw (LARCH_ATYPE_USI);\n+  tree const0 = build_int_cst (LARCH_ATYPE_UQI, 0);\n+  tree get_fcsr = loongarch_builtin_decls[LARCH_MOVFCSR2GR];\n+  tree set_fcsr = loongarch_builtin_decls[LARCH_MOVGR2FCSR];\n+  tree get_fcsr_hold_call = build_call_expr (get_fcsr, 1, const0);\n+  tree hold_assign_orig = build4 (TARGET_EXPR, LARCH_ATYPE_USI,\n+\t\t\t\t  fcsr_orig_var, get_fcsr_hold_call,\n+\t\t\t\t  NULL, NULL);\n+  tree hold_mod_val = build2 (BIT_AND_EXPR, LARCH_ATYPE_USI, fcsr_orig_var,\n+\t\t\t      build_int_cst (LARCH_ATYPE_USI, 0xffe0ffe0));\n+  tree hold_assign_mod = build4 (TARGET_EXPR, LARCH_ATYPE_USI,\n+\t\t\t\t fcsr_mod_var, hold_mod_val, NULL, NULL);\n+  tree set_fcsr_hold_call = build_call_expr (set_fcsr, 2, const0,\n+\t\t\t\t\t     fcsr_mod_var);\n+  tree hold_all = build2 (COMPOUND_EXPR, LARCH_ATYPE_USI, hold_assign_orig,\n+\t\t\t  hold_assign_mod);\n+  *hold = build2 (COMPOUND_EXPR, void_type_node, hold_all, set_fcsr_hold_call);\n+\n+  *clear = build_call_expr (set_fcsr, 2, const0, fcsr_mod_var);\n+\n+  tree get_fcsr_update_call = build_call_expr (get_fcsr, 1, const0);\n+  *update = build4 (TARGET_EXPR, LARCH_ATYPE_USI, exceptions_var,\n+\t\t    get_fcsr_update_call, NULL, NULL);\n+  tree set_fcsr_update_call = build_call_expr (set_fcsr, 2, const0,\n+\t\t\t\t\t       fcsr_orig_var);\n+  *update = build2 (COMPOUND_EXPR, void_type_node, *update,\n+\t\t    set_fcsr_update_call);\n+  tree atomic_feraiseexcept\n+    = builtin_decl_implicit (BUILT_IN_ATOMIC_FERAISEEXCEPT);\n+  tree int_exceptions_var = fold_convert (integer_type_node, exceptions_var);\n+  tree atomic_feraiseexcept_call = build_call_expr (atomic_feraiseexcept, 1,\n+\t\t\t\t\t\t    int_exceptions_var);\n+  *update = build2 (COMPOUND_EXPR, void_type_node, *update,\n+\t\t    atomic_feraiseexcept_call);\n+}\n+\n+/* Implement TARGET_BUILTIN_VA_LIST.  */\n+\n+tree\n+loongarch_build_builtin_va_list (void)\n+{\n+  return ptr_type_node;\n+}"}]}