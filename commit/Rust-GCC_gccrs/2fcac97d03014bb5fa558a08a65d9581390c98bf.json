{"sha": "2fcac97d03014bb5fa558a08a65d9581390c98bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmZjYWM5N2QwMzAxNGJiNWZhNTU4YTA4YTY1ZDk1ODEzOTBjOThiZg==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2010-08-23T12:26:42Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2010-08-23T12:26:42Z"}, "message": "re PR fortran/45366 (Problem with procedure pointer dummy in PURE function)\n\n2010-08-23  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/45366\n\t* resolve.c (resolve_procedure_interface): New function split off from\n\t'resolve_symbol'.\n\t(resolve_formal_arglist): Call it here ...\n\t(resolve_symbol): ... and here.\n\n\n2010-08-23  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/45366\n\t* gfortran.dg/proc_ptr_29.f90: New.\n\nFrom-SVN: r163468", "tree": {"sha": "1d1186a3af361b4d85d85d13ba2f35c7ea166e28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d1186a3af361b4d85d85d13ba2f35c7ea166e28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2fcac97d03014bb5fa558a08a65d9581390c98bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fcac97d03014bb5fa558a08a65d9581390c98bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fcac97d03014bb5fa558a08a65d9581390c98bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fcac97d03014bb5fa558a08a65d9581390c98bf/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55736285607f453aa0072f7e6c3d52cb0f344210", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55736285607f453aa0072f7e6c3d52cb0f344210", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55736285607f453aa0072f7e6c3d52cb0f344210"}], "stats": {"total": 208, "additions": 132, "deletions": 76}, "files": [{"sha": "eba7534df8608df40623e4767839aa235f326b4c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fcac97d03014bb5fa558a08a65d9581390c98bf/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fcac97d03014bb5fa558a08a65d9581390c98bf/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=2fcac97d03014bb5fa558a08a65d9581390c98bf", "patch": "@@ -1,3 +1,11 @@\n+2010-08-23  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/45366\n+\t* resolve.c (resolve_procedure_interface): New function split off from\n+\t'resolve_symbol'.\n+\t(resolve_formal_arglist): Call it here ...\n+\t(resolve_symbol): ... and here.\n+\n 2010-08-22  Joseph Myers  <joseph@codesourcery.com>\n \n \t* Make-lang.in (gfortranspec.o): Update dependencies."}, {"sha": "1d56ec6a867bb7c2c6d506b1f8af8bf81f896998", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 90, "deletions": 76, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fcac97d03014bb5fa558a08a65d9581390c98bf/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fcac97d03014bb5fa558a08a65d9581390c98bf/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=2fcac97d03014bb5fa558a08a65d9581390c98bf", "patch": "@@ -126,6 +126,88 @@ resolve_typespec_used (gfc_typespec* ts, locus* where, const char* name)\n }\n \n \n+static void resolve_symbol (gfc_symbol *sym);\n+static gfc_try resolve_intrinsic (gfc_symbol *sym, locus *loc);\n+\n+\n+/* Resolve the interface for a PROCEDURE declaration or procedure pointer.  */\n+\n+static gfc_try\n+resolve_procedure_interface (gfc_symbol *sym)\n+{\n+  if (sym->ts.interface == sym)\n+    {\n+      gfc_error (\"PROCEDURE '%s' at %L may not be used as its own interface\",\n+\t\t sym->name, &sym->declared_at);\n+      return FAILURE;\n+    }\n+  if (sym->ts.interface->attr.procedure)\n+    {\n+      gfc_error (\"Interface '%s', used by procedure '%s' at %L, is declared \"\n+\t\t \"in a later PROCEDURE statement\", sym->ts.interface->name,\n+\t\t sym->name, &sym->declared_at);\n+      return FAILURE;\n+    }\n+\n+  /* Get the attributes from the interface (now resolved).  */\n+  if (sym->ts.interface->attr.if_source || sym->ts.interface->attr.intrinsic)\n+    {\n+      gfc_symbol *ifc = sym->ts.interface;\n+      resolve_symbol (ifc);\n+\n+      if (ifc->attr.intrinsic)\n+\tresolve_intrinsic (ifc, &ifc->declared_at);\n+\n+      if (ifc->result)\n+\tsym->ts = ifc->result->ts;\n+      else   \n+\tsym->ts = ifc->ts;\n+      sym->ts.interface = ifc;\n+      sym->attr.function = ifc->attr.function;\n+      sym->attr.subroutine = ifc->attr.subroutine;\n+      gfc_copy_formal_args (sym, ifc);\n+\n+      sym->attr.allocatable = ifc->attr.allocatable;\n+      sym->attr.pointer = ifc->attr.pointer;\n+      sym->attr.pure = ifc->attr.pure;\n+      sym->attr.elemental = ifc->attr.elemental;\n+      sym->attr.dimension = ifc->attr.dimension;\n+      sym->attr.contiguous = ifc->attr.contiguous;\n+      sym->attr.recursive = ifc->attr.recursive;\n+      sym->attr.always_explicit = ifc->attr.always_explicit;\n+      sym->attr.ext_attr |= ifc->attr.ext_attr;\n+      /* Copy array spec.  */\n+      sym->as = gfc_copy_array_spec (ifc->as);\n+      if (sym->as)\n+\t{\n+\t  int i;\n+\t  for (i = 0; i < sym->as->rank; i++)\n+\t    {\n+\t      gfc_expr_replace_symbols (sym->as->lower[i], sym);\n+\t      gfc_expr_replace_symbols (sym->as->upper[i], sym);\n+\t    }\n+\t}\n+      /* Copy char length.  */\n+      if (ifc->ts.type == BT_CHARACTER && ifc->ts.u.cl)\n+\t{\n+\t  sym->ts.u.cl = gfc_new_charlen (sym->ns, ifc->ts.u.cl);\n+\t  gfc_expr_replace_symbols (sym->ts.u.cl->length, sym);\n+\t  if (sym->ts.u.cl->length && !sym->ts.u.cl->resolved\n+\t      && gfc_resolve_expr (sym->ts.u.cl->length) == FAILURE)\n+\t    return FAILURE;\n+\t}\n+    }\n+  else if (sym->ts.interface->name[0] != '\\0')\n+    {\n+      gfc_error (\"Interface '%s' of procedure '%s' at %L must be explicit\",\n+\t\t sym->ts.interface->name, sym->name, &sym->declared_at);\n+      return FAILURE;\n+    }\n+\n+  return SUCCESS;\n+}\n+\n+\n /* Resolve types of formal argument lists.  These have to be done early so that\n    the formal argument lists of module procedures can be copied to the\n    containing module before the individual procedures are resolved\n@@ -174,6 +256,9 @@ resolve_formal_arglist (gfc_symbol *proc)\n \t\t       &proc->declared_at);\n \t  continue;\n \t}\n+      else if (sym->attr.procedure && sym->ts.interface\n+\t       && sym->attr.if_source != IFSRC_DECL)\n+\tresolve_procedure_interface (sym);\n \n       if (sym->attr.if_source != IFSRC_UNKNOWN)\n \tresolve_formal_arglist (sym);\n@@ -10970,9 +11055,6 @@ ensure_not_abstract (gfc_symbol* sub, gfc_symbol* ancestor)\n }\n \n \n-static void resolve_symbol (gfc_symbol *sym);\n-\n-\n /* Resolve the components of a derived type.  */\n \n static gfc_try\n@@ -11533,7 +11615,8 @@ resolve_symbol (gfc_symbol *sym)\n   gfc_component *c;\n \n   /* Avoid double resolution of function result symbols.  */\n-  if ((sym->result || sym->attr.result) && (sym->ns != gfc_current_ns))\n+  if ((sym->result || sym->attr.result) && !sym->attr.dummy\n+      && (sym->ns != gfc_current_ns))\n     return;\n   \n   if (sym->attr.flavor == FL_UNKNOWN)\n@@ -11572,78 +11655,9 @@ resolve_symbol (gfc_symbol *sym)\n     gfc_add_function (&sym->attr, sym->name, &sym->declared_at);\n \n   if (sym->attr.procedure && sym->ts.interface\n-      && sym->attr.if_source != IFSRC_DECL)\n-    {\n-      if (sym->ts.interface == sym)\n-\t{\n-\t  gfc_error (\"PROCEDURE '%s' at %L may not be used as its own \"\n-\t\t     \"interface\", sym->name, &sym->declared_at);\n-\t  return;\n-\t}\n-      if (sym->ts.interface->attr.procedure)\n-\t{\n-\t  gfc_error (\"Interface '%s', used by procedure '%s' at %L, is declared\"\n-\t\t     \" in a later PROCEDURE statement\", sym->ts.interface->name,\n-\t\t     sym->name,&sym->declared_at);\n-\t  return;\n-\t}\n-\n-      /* Get the attributes from the interface (now resolved).  */\n-      if (sym->ts.interface->attr.if_source\n-\t  || sym->ts.interface->attr.intrinsic)\n-\t{\n-\t  gfc_symbol *ifc = sym->ts.interface;\n-\t  resolve_symbol (ifc);\n-\n-\t  if (ifc->attr.intrinsic)\n-\t    resolve_intrinsic (ifc, &ifc->declared_at);\n-\n-\t  if (ifc->result)\n-\t    sym->ts = ifc->result->ts;\n-\t  else   \n-\t    sym->ts = ifc->ts;\n-\t  sym->ts.interface = ifc;\n-\t  sym->attr.function = ifc->attr.function;\n-\t  sym->attr.subroutine = ifc->attr.subroutine;\n-\t  gfc_copy_formal_args (sym, ifc);\n-\n-\t  sym->attr.allocatable = ifc->attr.allocatable;\n-\t  sym->attr.pointer = ifc->attr.pointer;\n-\t  sym->attr.pure = ifc->attr.pure;\n-\t  sym->attr.elemental = ifc->attr.elemental;\n-\t  sym->attr.dimension = ifc->attr.dimension;\n-\t  sym->attr.contiguous = ifc->attr.contiguous;\n-\t  sym->attr.recursive = ifc->attr.recursive;\n-\t  sym->attr.always_explicit = ifc->attr.always_explicit;\n-          sym->attr.ext_attr |= ifc->attr.ext_attr;\n-\t  /* Copy array spec.  */\n-\t  sym->as = gfc_copy_array_spec (ifc->as);\n-\t  if (sym->as)\n-\t    {\n-\t      int i;\n-\t      for (i = 0; i < sym->as->rank; i++)\n-\t\t{\n-\t\t  gfc_expr_replace_symbols (sym->as->lower[i], sym);\n-\t\t  gfc_expr_replace_symbols (sym->as->upper[i], sym);\n-\t\t}\n-\t    }\n-\t  /* Copy char length.  */\n-\t  if (ifc->ts.type == BT_CHARACTER && ifc->ts.u.cl)\n-\t    {\n-\t      sym->ts.u.cl = gfc_new_charlen (sym->ns, ifc->ts.u.cl);\n-\t      gfc_expr_replace_symbols (sym->ts.u.cl->length, sym);\n-\t      if (sym->ts.u.cl->length && !sym->ts.u.cl->resolved\n-\t\t    && gfc_resolve_expr (sym->ts.u.cl->length) == FAILURE)\n-\t\treturn;\n-\t    }\n-\t}\n-      else if (sym->ts.interface->name[0] != '\\0')\n-\t{\n-\t  gfc_error (\"Interface '%s' of procedure '%s' at %L must be explicit\",\n-\t\t    sym->ts.interface->name, sym->name, &sym->declared_at);\n-\t  return;\n-\t}\n-    }\n+      && sym->attr.if_source != IFSRC_DECL\n+      && resolve_procedure_interface (sym) == FAILURE)\n+    return;\n \n   if (sym->attr.is_protected && !sym->attr.proc_pointer\n       && (sym->attr.procedure || sym->attr.external))"}, {"sha": "f117080a577f3029acbc109fe67bfb79324289be", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fcac97d03014bb5fa558a08a65d9581390c98bf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fcac97d03014bb5fa558a08a65d9581390c98bf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2fcac97d03014bb5fa558a08a65d9581390c98bf", "patch": "@@ -1,3 +1,8 @@\n+2010-08-23  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/45366\n+\t* gfortran.dg/proc_ptr_29.f90: New.\n+\n 2010-08-22  Tobias Burnus  <burnus@net-b.de>\n \t    Dominique d'Humieres <dominiq@lps.ens.fr>\n "}, {"sha": "69f0b03419606a7ed448565921fea7bb26b42ccc", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_29.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fcac97d03014bb5fa558a08a65d9581390c98bf/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_29.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fcac97d03014bb5fa558a08a65d9581390c98bf/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_29.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_29.f90?ref=2fcac97d03014bb5fa558a08a65d9581390c98bf", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do compile }\n+!\n+! PR 45366: Problem with procedure pointer dummy in PURE function\n+!\n+! Contributed by Marco Restelli <mrestelli@gmail.com>\n+\n+module m1\n+ implicit none\n+ abstract interface\n+  pure function i_f(x) result(y)\n+   real, intent(in) :: x\n+   real :: y\n+  end function i_f\n+ end interface\n+end module m1\n+\n+module m2\n+ use m1, only: i_f\n+ implicit none\n+contains\n+ pure function i_g(x,p) result(y)\n+  real, intent(in) :: x\n+  procedure(i_f), pointer, intent(in) :: p\n+  real :: y\n+   y = p(x)\n+ end function i_g\n+end module m2\n+\n+! { dg-final { cleanup-modules \"m1 m2\" } }"}]}