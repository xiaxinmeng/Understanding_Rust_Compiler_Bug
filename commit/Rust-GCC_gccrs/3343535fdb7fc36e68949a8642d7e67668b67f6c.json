{"sha": "3343535fdb7fc36e68949a8642d7e67668b67f6c", "node_id": "C_kwDOANBUbNoAKDMzNDM1MzVmZGI3ZmMzNmU2ODk0OWE4NjQyZDdlNjc2NjhiNjdmNmM", "commit": {"author": {"name": "Faisal Abbas", "email": "90.abbasfaisal@gmail.com", "date": "2022-07-10T13:42:29Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-25T11:40:24Z"}, "message": "gccrs const folding port: continue porting potential_constant_expression_1()\n\nFollowing functions are ported in this changeset:\n - fields_linear_search\n - nothrow_spec_p\n - maybe_get_fns\n - get_fns\n - get_first_fn\n - dependent_name\n - called_fns_equal\n - canonical_eh_spec\n - rs_tree_code_length\n - rs_tree_operand_length\n - rs_tree_equal\n - publicly_uniquely_derived_p\n - comp_except_types\n - comp_except_specs\n - compparms\n - rs_build_qualified_type_real\n - vector_targets_convertible_p\n - comp_array_types\n - same_type_ignoring_top_level_qualifiers_p\n - comp_ptr_ttypes_const\n - similar_type_p\n - structural_comptypes\n - comptypes\n - gnu_vector_type_p\n - set_array_type_canon\n - is_byte_access_type\n - build_cplus_array_type\n\nFollowing structs, classes and enums are ported in this changeset:\n - named_decl_hash\n - lang_decl_selector\n - lang_decl_base\n - lang_decl_min\n - lang_decl_fn\n - lang_decl_ns\n - lang_decl_parm\n - lang_decl_decomp\n - lang_decl\n - lkp_iterator\n - compare_bounds_t\n - cplus_array_info\n - cplus_array_hasher\n\nSigned-off-by: Faisal Abbas <90.abbasfaisal@gmail.com>", "tree": {"sha": "46f950a078c12d71fd8fff88cefaddc05e832101", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46f950a078c12d71fd8fff88cefaddc05e832101"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3343535fdb7fc36e68949a8642d7e67668b67f6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3343535fdb7fc36e68949a8642d7e67668b67f6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3343535fdb7fc36e68949a8642d7e67668b67f6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3343535fdb7fc36e68949a8642d7e67668b67f6c/comments", "author": {"login": "abbasfaisal", "id": 9428333, "node_id": "MDQ6VXNlcjk0MjgzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/9428333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abbasfaisal", "html_url": "https://github.com/abbasfaisal", "followers_url": "https://api.github.com/users/abbasfaisal/followers", "following_url": "https://api.github.com/users/abbasfaisal/following{/other_user}", "gists_url": "https://api.github.com/users/abbasfaisal/gists{/gist_id}", "starred_url": "https://api.github.com/users/abbasfaisal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abbasfaisal/subscriptions", "organizations_url": "https://api.github.com/users/abbasfaisal/orgs", "repos_url": "https://api.github.com/users/abbasfaisal/repos", "events_url": "https://api.github.com/users/abbasfaisal/events{/privacy}", "received_events_url": "https://api.github.com/users/abbasfaisal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b394fe4571f6c6207c1135da1297bf44f750bbf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b394fe4571f6c6207c1135da1297bf44f750bbf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b394fe4571f6c6207c1135da1297bf44f750bbf4"}], "stats": {"total": 1708, "additions": 1708, "deletions": 0}, "files": [{"sha": "4439dea251e6f2d41260daca578d75571d9193a3", "filename": "gcc/rust/backend/rust-tree.cc", "status": "modified", "additions": 1297, "deletions": 0, "changes": 1297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3343535fdb7fc36e68949a8642d7e67668b67f6c/gcc%2Frust%2Fbackend%2Frust-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3343535fdb7fc36e68949a8642d7e67668b67f6c/gcc%2Frust%2Fbackend%2Frust-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.cc?ref=3343535fdb7fc36e68949a8642d7e67668b67f6c", "patch": "@@ -22,6 +22,7 @@\n #include \"attribs.h\"\n #include \"escaped_string.h\"\n #include \"libiberty.h\"\n+#include \"stor-layout.h\"\n \n namespace Rust {\n \n@@ -1525,4 +1526,1300 @@ build_min_array_type (tree elt_type, tree index_type)\n   return t;\n }\n \n+// forked from gcc/cp/name-lookup.cc fields_linear_search\n+\n+/* Linear search of (partially ordered) fields of KLASS for NAME.  */\n+\n+static tree\n+fields_linear_search (tree klass, tree name, bool want_type)\n+{\n+  for (tree fields = TYPE_FIELDS (klass); fields; fields = DECL_CHAIN (fields))\n+    {\n+      tree decl = fields;\n+\n+      if (DECL_NAME (decl) != name)\n+\tcontinue;\n+\n+      if (DECL_DECLARES_FUNCTION_P (decl))\n+\t/* Functions are found separately.  */\n+\tcontinue;\n+\n+      if (!want_type || DECL_DECLARES_TYPE_P (decl))\n+\treturn decl;\n+    }\n+}\n+\n+// forked from gcc/cp/except.cc canonnothrow_spec_pical_eh_spec\n+\n+/* Return true iff SPEC is throw() or noexcept(true).  */\n+\n+bool\n+nothrow_spec_p (const_tree spec)\n+{\n+  if (spec == empty_except_spec || spec == noexcept_true_spec)\n+    return true;\n+\n+  gcc_assert (!spec || TREE_VALUE (spec) || spec == noexcept_false_spec\n+\t      || TREE_PURPOSE (spec) == error_mark_node);\n+\n+  return false;\n+}\n+\n+// forked from gcc/cp/tree.cc may_get_fns\n+\n+/* Get the overload set FROM refers to.  Returns NULL if it's not an\n+   overload set.  */\n+\n+tree\n+maybe_get_fns (tree from)\n+{\n+  STRIP_ANY_LOCATION_WRAPPER (from);\n+\n+  /* A baselink is also considered an overloaded function.  */\n+  if (TREE_CODE (from) == COMPONENT_REF)\n+    from = TREE_OPERAND (from, 1);\n+\n+  if (OVL_P (from))\n+    return from;\n+\n+  return NULL;\n+}\n+\n+// forked from gcc/cp/tree.cc get_fns\n+\n+/* FROM refers to an overload set.  Return that set (or die).  */\n+\n+tree\n+get_fns (tree from)\n+{\n+  tree res = maybe_get_fns (from);\n+\n+  gcc_assert (res);\n+  return res;\n+}\n+\n+// forked from gcc/cp/tree.cc get_first_fn\n+\n+/* Return the first function of the overload set FROM refers to.  */\n+\n+tree\n+get_first_fn (tree from)\n+{\n+  return OVL_FIRST (get_fns (from));\n+}\n+\n+// forked from gcc/cp/tree.cc dependent_name\n+\n+/* X is the CALL_EXPR_FN of a CALL_EXPR.  If X represents a dependent name\n+   (14.6.2), return the IDENTIFIER_NODE for that name.  Otherwise, return\n+   NULL_TREE.  */\n+\n+tree\n+dependent_name (tree x)\n+{\n+  /* FIXME a dependent name must be unqualified, but this function doesn't\n+     distinguish between qualified and unqualified identifiers.  */\n+  if (identifier_p (x))\n+    return x;\n+\n+  if (OVL_P (x))\n+    return OVL_NAME (x);\n+  return NULL_TREE;\n+}\n+\n+// forked from gcc/cp/tree.cc called_fns_equal\n+\n+/* Subroutine of rs_tree_equal: t1 and t2 are the CALL_EXPR_FNs of two\n+   CALL_EXPRS.  Return whether they are equivalent.  */\n+\n+static bool\n+called_fns_equal (tree t1, tree t2)\n+{\n+  /* Core 1321: dependent names are equivalent even if the overload sets\n+     are different.  But do compare explicit template arguments.  */\n+  tree name1 = dependent_name (t1);\n+  tree name2 = dependent_name (t2);\n+  if (name1 || name2)\n+    {\n+      tree targs1 = NULL_TREE, targs2 = NULL_TREE;\n+\n+      if (name1 != name2)\n+\treturn false;\n+\n+      /* FIXME dependent_name currently returns an unqualified name regardless\n+\t of whether the function was named with a qualified- or unqualified-id.\n+\t Until that's fixed, check that we aren't looking at overload sets from\n+\t different scopes.  */\n+      if (is_overloaded_fn (t1) && is_overloaded_fn (t2)\n+\t  && (DECL_CONTEXT (get_first_fn (t1))\n+\t      != DECL_CONTEXT (get_first_fn (t2))))\n+\treturn false;\n+\n+      if (TREE_CODE (t1) == TEMPLATE_ID_EXPR)\n+\ttargs1 = TREE_OPERAND (t1, 1);\n+      if (TREE_CODE (t2) == TEMPLATE_ID_EXPR)\n+\ttargs2 = TREE_OPERAND (t2, 1);\n+      return rs_tree_equal (targs1, targs2);\n+    }\n+  else\n+    return rs_tree_equal (t1, t2);\n+}\n+\n+// forked from gcc/cp/tree.cc canonical_eh_spec\n+\n+/* Return the canonical version of exception-specification RAISES for a C++17\n+   function type, for use in type comparison and building TYPE_CANONICAL.  */\n+\n+tree\n+canonical_eh_spec (tree raises)\n+{\n+  if (raises == NULL_TREE)\n+    return raises;\n+  else if (nothrow_spec_p (raises))\n+    /* throw() -> noexcept.  */\n+    return noexcept_true_spec;\n+  else\n+    /* For C++17 type matching, anything else -> nothing.  */\n+    return NULL_TREE;\n+}\n+\n+/* Like cp_tree_operand_length, but takes a tree_code CODE.  */\n+\n+int\n+rs_tree_code_length (enum tree_code code)\n+{\n+  gcc_assert (TREE_CODE_CLASS (code) != tcc_vl_exp);\n+\n+  switch (code)\n+    {\n+    case PREINCREMENT_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+      return 1;\n+\n+    case ARRAY_REF:\n+      return 2;\n+\n+    default:\n+      return TREE_CODE_LENGTH (code);\n+    }\n+}\n+\n+// forked from gcc/cp/tree.cc rs_tree_operand_length\n+\n+/* Return the number of operands in T that we care about for things like\n+   mangling.  */\n+\n+int\n+rs_tree_operand_length (const_tree t)\n+{\n+  enum tree_code code = TREE_CODE (t);\n+\n+  if (TREE_CODE_CLASS (code) == tcc_vl_exp)\n+    return VL_EXP_OPERAND_LENGTH (t);\n+\n+  return rs_tree_code_length (code);\n+}\n+\n+// forked from gcc/cp/tree.cc cp_tree_equal\n+\n+/* Return truthvalue of whether T1 is the same tree structure as T2.\n+   Return 1 if they are the same. Return 0 if they are different.  */\n+\n+bool\n+rs_tree_equal (tree t1, tree t2)\n+{\n+  enum tree_code code1, code2;\n+\n+  if (t1 == t2)\n+    return true;\n+  if (!t1 || !t2)\n+    return false;\n+\n+  code1 = TREE_CODE (t1);\n+  code2 = TREE_CODE (t2);\n+\n+  if (code1 != code2)\n+    return false;\n+\n+  if (CONSTANT_CLASS_P (t1) && !same_type_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n+    return false;\n+\n+  switch (code1)\n+    {\n+    case VOID_CST:\n+      /* There's only a single VOID_CST node, so we should never reach\n+\t here.  */\n+      gcc_unreachable ();\n+\n+    case INTEGER_CST:\n+      return tree_int_cst_equal (t1, t2);\n+\n+    case REAL_CST:\n+      return real_identical (&TREE_REAL_CST (t1), &TREE_REAL_CST (t2));\n+\n+    case STRING_CST:\n+      return TREE_STRING_LENGTH (t1) == TREE_STRING_LENGTH (t2)\n+\t     && !memcmp (TREE_STRING_POINTER (t1), TREE_STRING_POINTER (t2),\n+\t\t\t TREE_STRING_LENGTH (t1));\n+\n+    case FIXED_CST:\n+      return FIXED_VALUES_IDENTICAL (TREE_FIXED_CST (t1), TREE_FIXED_CST (t2));\n+\n+    case COMPLEX_CST:\n+      return rs_tree_equal (TREE_REALPART (t1), TREE_REALPART (t2))\n+\t     && rs_tree_equal (TREE_IMAGPART (t1), TREE_IMAGPART (t2));\n+\n+    case VECTOR_CST:\n+      return operand_equal_p (t1, t2, OEP_ONLY_CONST);\n+\n+    case CONSTRUCTOR:\n+      /* We need to do this when determining whether or not two\n+\t non-type pointer to member function template arguments\n+\t are the same.  */\n+      if (!same_type_p (TREE_TYPE (t1), TREE_TYPE (t2))\n+\t  || CONSTRUCTOR_NELTS (t1) != CONSTRUCTOR_NELTS (t2))\n+\treturn false;\n+      {\n+\ttree field, value;\n+\tunsigned int i;\n+\tFOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (t1), i, field, value)\n+\t  {\n+\t    constructor_elt *elt2 = CONSTRUCTOR_ELT (t2, i);\n+\t    if (!rs_tree_equal (field, elt2->index)\n+\t\t|| !rs_tree_equal (value, elt2->value))\n+\t      return false;\n+\t  }\n+      }\n+      return true;\n+\n+    case TREE_LIST:\n+      if (!rs_tree_equal (TREE_PURPOSE (t1), TREE_PURPOSE (t2)))\n+\treturn false;\n+      if (!rs_tree_equal (TREE_VALUE (t1), TREE_VALUE (t2)))\n+\treturn false;\n+      return rs_tree_equal (TREE_CHAIN (t1), TREE_CHAIN (t2));\n+\n+    case SAVE_EXPR:\n+      return rs_tree_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n+\n+      case CALL_EXPR: {\n+\tif (KOENIG_LOOKUP_P (t1) != KOENIG_LOOKUP_P (t2))\n+\t  return false;\n+\n+\tif (!called_fns_equal (CALL_EXPR_FN (t1), CALL_EXPR_FN (t2)))\n+\t  return false;\n+\n+\tcall_expr_arg_iterator iter1, iter2;\n+\tinit_call_expr_arg_iterator (t1, &iter1);\n+\tinit_call_expr_arg_iterator (t2, &iter2);\n+\tif (iter1.n != iter2.n)\n+\t  return false;\n+\n+\twhile (more_call_expr_args_p (&iter1))\n+\t  {\n+\t    tree arg1 = next_call_expr_arg (&iter1);\n+\t    tree arg2 = next_call_expr_arg (&iter2);\n+\n+\t    gcc_checking_assert (arg1 && arg2);\n+\t    if (!rs_tree_equal (arg1, arg2))\n+\t      return false;\n+\t  }\n+\n+\treturn true;\n+      }\n+\n+      case TARGET_EXPR: {\n+\ttree o1 = TREE_OPERAND (t1, 0);\n+\ttree o2 = TREE_OPERAND (t2, 0);\n+\n+\t/* Special case: if either target is an unallocated VAR_DECL,\n+\t   it means that it's going to be unified with whatever the\n+\t   TARGET_EXPR is really supposed to initialize, so treat it\n+\t   as being equivalent to anything.  */\n+\tif (VAR_P (o1) && DECL_NAME (o1) == NULL_TREE && !DECL_RTL_SET_P (o1))\n+\t  /*Nop*/;\n+\telse if (VAR_P (o2) && DECL_NAME (o2) == NULL_TREE\n+\t\t && !DECL_RTL_SET_P (o2))\n+\t  /*Nop*/;\n+\telse if (!rs_tree_equal (o1, o2))\n+\t  return false;\n+\n+\treturn rs_tree_equal (TREE_OPERAND (t1, 1), TREE_OPERAND (t2, 1));\n+      }\n+\n+    case PARM_DECL:\n+      /* For comparing uses of parameters in late-specified return types\n+\t with an out-of-class definition of the function, but can also come\n+\t up for expressions that involve 'this' in a member function\n+\t template.  */\n+\n+      if (same_type_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n+\t{\n+\t  if (DECL_ARTIFICIAL (t1) ^ DECL_ARTIFICIAL (t2))\n+\t    return false;\n+\t  if (CONSTRAINT_VAR_P (t1) ^ CONSTRAINT_VAR_P (t2))\n+\t    return false;\n+\t  if (DECL_ARTIFICIAL (t1)\n+\t      || (DECL_PARM_LEVEL (t1) == DECL_PARM_LEVEL (t2)\n+\t\t  && DECL_PARM_INDEX (t1) == DECL_PARM_INDEX (t2)))\n+\t    return true;\n+\t}\n+      return false;\n+\n+    case VAR_DECL:\n+    case CONST_DECL:\n+    case FIELD_DECL:\n+    case FUNCTION_DECL:\n+    case IDENTIFIER_NODE:\n+    case SSA_NAME:\n+      return false;\n+\n+    case TREE_VEC:\n+      return true;\n+\n+    case NON_LVALUE_EXPR:\n+    case VIEW_CONVERT_EXPR:\n+      /* Used for location wrappers with possibly NULL types.  */\n+      if (!TREE_TYPE (t1) || !TREE_TYPE (t2))\n+\t{\n+\t  if (TREE_TYPE (t1) || TREE_TYPE (t2))\n+\t    return false;\n+\t  break;\n+\t}\n+\n+    default:\n+      break;\n+    }\n+\n+  switch (TREE_CODE_CLASS (code1))\n+    {\n+    case tcc_unary:\n+    case tcc_binary:\n+    case tcc_comparison:\n+    case tcc_expression:\n+    case tcc_vl_exp:\n+    case tcc_reference:\n+      case tcc_statement: {\n+\tint n = rs_tree_operand_length (t1);\n+\tif (TREE_CODE_CLASS (code1) == tcc_vl_exp\n+\t    && n != TREE_OPERAND_LENGTH (t2))\n+\t  return false;\n+\n+\tfor (int i = 0; i < n; ++i)\n+\t  if (!rs_tree_equal (TREE_OPERAND (t1, i), TREE_OPERAND (t2, i)))\n+\t    return false;\n+\n+\treturn true;\n+      }\n+\n+    case tcc_type:\n+      return same_type_p (t1, t2);\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* We can get here with --disable-checking.  */\n+  return false;\n+}\n+\n+// forked from gcc/cp/class.cc publicly_uniquely_derived_p\n+\n+/* TRUE iff TYPE is publicly & uniquely derived from PARENT.  */\n+\n+bool\n+publicly_uniquely_derived_p (tree parent, tree type)\n+{\n+  return false;\n+}\n+\n+// forked from gcc/cp/typeck.cc comp_except_types\n+\n+/* Compare two exception specifier types for exactness or subsetness, if\n+   allowed. Returns false for mismatch, true for match (same, or\n+   derived and !exact).\n+\n+   [except.spec] \"If a class X ... objects of class X or any class publicly\n+   and unambiguously derived from X. Similarly, if a pointer type Y * ...\n+   exceptions of type Y * or that are pointers to any type publicly and\n+   unambiguously derived from Y. Otherwise a function only allows exceptions\n+   that have the same type ...\"\n+   This does not mention cv qualifiers and is different to what throw\n+   [except.throw] and catch [except.catch] will do. They will ignore the\n+   top level cv qualifiers, and allow qualifiers in the pointer to class\n+   example.\n+\n+   We implement the letter of the standard.  */\n+\n+static bool\n+comp_except_types (tree a, tree b, bool exact)\n+{\n+  if (same_type_p (a, b))\n+    return true;\n+  else if (!exact)\n+    {\n+      if (rs_type_quals (a) || rs_type_quals (b))\n+\treturn false;\n+\n+      if (TYPE_PTR_P (a) && TYPE_PTR_P (b))\n+\t{\n+\t  a = TREE_TYPE (a);\n+\t  b = TREE_TYPE (b);\n+\t  if (rs_type_quals (a) || rs_type_quals (b))\n+\t    return false;\n+\t}\n+\n+      if (TREE_CODE (a) != RECORD_TYPE || TREE_CODE (b) != RECORD_TYPE)\n+\treturn false;\n+\n+      if (publicly_uniquely_derived_p (a, b))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+// forked from gcc/cp/typeck.cc comp_except_specs\n+\n+/* Return true if TYPE1 and TYPE2 are equivalent exception specifiers.\n+   If EXACT is ce_derived, T2 can be stricter than T1 (according to 15.4/5).\n+   If EXACT is ce_type, the C++17 type compatibility rules apply.\n+   If EXACT is ce_normal, the compatibility rules in 15.4/3 apply.\n+   If EXACT is ce_exact, the specs must be exactly the same. Exception lists\n+   are unordered, but we've already filtered out duplicates. Most lists will\n+   be in order, we should try to make use of that.  */\n+\n+bool\n+comp_except_specs (const_tree t1, const_tree t2, int exact)\n+{\n+  const_tree probe;\n+  const_tree base;\n+  int length = 0;\n+\n+  if (t1 == t2)\n+    return true;\n+\n+  /* First handle noexcept.  */\n+  if (exact < ce_exact)\n+    {\n+      if (exact == ce_type\n+\t  && (canonical_eh_spec (CONST_CAST_TREE (t1))\n+\t      == canonical_eh_spec (CONST_CAST_TREE (t2))))\n+\treturn true;\n+\n+      /* noexcept(false) is compatible with no exception-specification,\n+\t and less strict than any spec.  */\n+      if (t1 == noexcept_false_spec)\n+\treturn t2 == NULL_TREE || exact == ce_derived;\n+      /* Even a derived noexcept(false) is compatible with no\n+\t exception-specification.  */\n+      if (t2 == noexcept_false_spec)\n+\treturn t1 == NULL_TREE;\n+\n+      /* Otherwise, if we aren't looking for an exact match, noexcept is\n+\t equivalent to throw().  */\n+      if (t1 == noexcept_true_spec)\n+\tt1 = empty_except_spec;\n+      if (t2 == noexcept_true_spec)\n+\tt2 = empty_except_spec;\n+    }\n+\n+  /* If any noexcept is left, it is only comparable to itself;\n+     either we're looking for an exact match or we're redeclaring a\n+     template with dependent noexcept.  */\n+  if ((t1 && TREE_PURPOSE (t1)) || (t2 && TREE_PURPOSE (t2)))\n+    return (t1 && t2 && rs_tree_equal (TREE_PURPOSE (t1), TREE_PURPOSE (t2)));\n+\n+  if (t1 == NULL_TREE) /* T1 is ...  */\n+    return t2 == NULL_TREE || exact == ce_derived;\n+  if (!TREE_VALUE (t1)) /* t1 is EMPTY */\n+    return t2 != NULL_TREE && !TREE_VALUE (t2);\n+  if (t2 == NULL_TREE) /* T2 is ...  */\n+    return false;\n+  if (TREE_VALUE (t1) && !TREE_VALUE (t2)) /* T2 is EMPTY, T1 is not */\n+    return exact == ce_derived;\n+\n+  /* Neither set is ... or EMPTY, make sure each part of T2 is in T1.\n+     Count how many we find, to determine exactness. For exact matching and\n+     ordered T1, T2, this is an O(n) operation, otherwise its worst case is\n+     O(nm).  */\n+  for (base = t1; t2 != NULL_TREE; t2 = TREE_CHAIN (t2))\n+    {\n+      for (probe = base; probe != NULL_TREE; probe = TREE_CHAIN (probe))\n+\t{\n+\t  tree a = TREE_VALUE (probe);\n+\t  tree b = TREE_VALUE (t2);\n+\n+\t  if (comp_except_types (a, b, exact))\n+\t    {\n+\t      if (probe == base && exact > ce_derived)\n+\t\tbase = TREE_CHAIN (probe);\n+\t      length++;\n+\t      break;\n+\t    }\n+\t}\n+      if (probe == NULL_TREE)\n+\treturn false;\n+    }\n+  return exact == ce_derived || base == NULL_TREE || length == list_length (t1);\n+}\n+\n+// forked from gcc/cp/typeck.cc compparms\n+\n+/* Subroutines of `comptypes'.  */\n+\n+/* Return true if two parameter type lists PARMS1 and PARMS2 are\n+   equivalent in the sense that functions with those parameter types\n+   can have equivalent types.  The two lists must be equivalent,\n+   element by element.  */\n+\n+bool\n+compparms (const_tree parms1, const_tree parms2)\n+{\n+  const_tree t1, t2;\n+\n+  /* An unspecified parmlist matches any specified parmlist\n+     whose argument types don't need default promotions.  */\n+\n+  for (t1 = parms1, t2 = parms2; t1 || t2;\n+       t1 = TREE_CHAIN (t1), t2 = TREE_CHAIN (t2))\n+    {\n+      /* If one parmlist is shorter than the other,\n+\t they fail to match.  */\n+      if (!t1 || !t2)\n+\treturn false;\n+      if (!same_type_p (TREE_VALUE (t1), TREE_VALUE (t2)))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+/* Set TYPE_CANONICAL like build_array_type_1, but using\n+   build_cplus_array_type.  */\n+\n+static void\n+set_array_type_canon (tree t, tree elt_type, tree index_type, bool dep)\n+{\n+  /* Set the canonical type for this new node.  */\n+  if (TYPE_STRUCTURAL_EQUALITY_P (elt_type)\n+      || (index_type && TYPE_STRUCTURAL_EQUALITY_P (index_type)))\n+    SET_TYPE_STRUCTURAL_EQUALITY (t);\n+  else if (TYPE_CANONICAL (elt_type) != elt_type\n+\t   || (index_type && TYPE_CANONICAL (index_type) != index_type))\n+    TYPE_CANONICAL (t)\n+      = build_cplus_array_type (TYPE_CANONICAL (elt_type),\n+\t\t\t\tindex_type\n+\t\t\t\t? TYPE_CANONICAL (index_type) : index_type,\n+\t\t\t\tdep);\n+  else\n+    TYPE_CANONICAL (t) = t;\n+}\n+\n+// forked from gcc/cp/tree.cc cplus_array_info\n+\n+struct cplus_array_info\n+{\n+  tree type;\n+  tree domain;\n+};\n+\n+// forked from gcc/cp/tree.cc cplus_array_hasher\n+\n+struct cplus_array_hasher : ggc_ptr_hash<tree_node>\n+{\n+  typedef cplus_array_info *compare_type;\n+\n+  static hashval_t hash (tree t);\n+  static bool equal (tree, cplus_array_info *);\n+};\n+\n+/* Hash an ARRAY_TYPE.  K is really of type `tree'.  */\n+\n+hashval_t\n+cplus_array_hasher::hash (tree t)\n+{\n+  hashval_t hash;\n+\n+  hash = TYPE_UID (TREE_TYPE (t));\n+  if (TYPE_DOMAIN (t))\n+    hash ^= TYPE_UID (TYPE_DOMAIN (t));\n+  return hash;\n+}\n+\n+/* Compare two ARRAY_TYPEs.  K1 is really of type `tree', K2 is really\n+   of type `cplus_array_info*'. */\n+\n+bool\n+cplus_array_hasher::equal (tree t1, cplus_array_info *t2)\n+{\n+  return (TREE_TYPE (t1) == t2->type && TYPE_DOMAIN (t1) == t2->domain);\n+}\n+\n+// forked from gcc/cp/tree.cc cplus_array_htab\n+\n+/* Hash table containing dependent array types, which are unsuitable for\n+   the language-independent type hash table.  */\n+static GTY (()) hash_table<cplus_array_hasher> *cplus_array_htab;\n+\n+// forked from gcc/cp/tree.cc is_byte_access_type\n+\n+/* Returns true if TYPE is char, unsigned char, or std::byte.  */\n+\n+bool\n+is_byte_access_type (tree type)\n+{\n+  type = TYPE_MAIN_VARIANT (type);\n+  if (type == char_type_node\n+      || type == unsigned_char_type_node)\n+    return true;\n+\n+  return (TREE_CODE (type) == ENUMERAL_TYPE\n+\t  && TYPE_CONTEXT (type) == std_node\n+\t  && !strcmp (\"byte\", TYPE_NAME_STRING (type)));\n+}\n+\n+// forked from gcc/cp/tree.cc build_cplus_array_type\n+\n+/* Like build_array_type, but handle special C++ semantics: an array of a\n+   variant element type is a variant of the array of the main variant of\n+   the element type.  IS_DEPENDENT is -ve if we should determine the\n+   dependency.  Otherwise its bool value indicates dependency.  */\n+\n+tree\n+build_cplus_array_type (tree elt_type, tree index_type, int dependent)\n+{\n+  tree t;\n+\n+  if (elt_type == error_mark_node || index_type == error_mark_node)\n+    return error_mark_node;\n+\n+  if (dependent < 0)\n+    dependent = 0;\n+\n+  if (elt_type != TYPE_MAIN_VARIANT (elt_type))\n+    /* Start with an array of the TYPE_MAIN_VARIANT.  */\n+    t = build_cplus_array_type (TYPE_MAIN_VARIANT (elt_type),\n+\t\t\t\tindex_type, dependent);\n+  else if (dependent)\n+    {\n+      /* Since type_hash_canon calls layout_type, we need to use our own\n+\t hash table.  */\n+      cplus_array_info cai;\n+      hashval_t hash;\n+\n+      if (cplus_array_htab == NULL)\n+\tcplus_array_htab = hash_table<cplus_array_hasher>::create_ggc (61);\n+      \n+      hash = TYPE_UID (elt_type);\n+      if (index_type)\n+\thash ^= TYPE_UID (index_type);\n+      cai.type = elt_type;\n+      cai.domain = index_type;\n+\n+      tree *e = cplus_array_htab->find_slot_with_hash (&cai, hash, INSERT); \n+      if (*e)\n+\t/* We have found the type: we're done.  */\n+\treturn (tree) *e;\n+      else\n+\t{\n+\t  /* Build a new array type.  */\n+\t  t = build_min_array_type (elt_type, index_type);\n+\n+\t  /* Store it in the hash table. */\n+\t  *e = t;\n+\n+\t  /* Set the canonical type for this new node.  */\n+\t  set_array_type_canon (t, elt_type, index_type, dependent);\n+\n+\t  /* Mark it as dependent now, this saves time later.  */\n+\t  TYPE_DEPENDENT_P_VALID (t) = true;\n+\t  TYPE_DEPENDENT_P (t) = true;\n+\t}\n+    }\n+  else\n+    {\n+      bool typeless_storage = is_byte_access_type (elt_type);\n+      t = build_array_type (elt_type, index_type, typeless_storage);\n+\n+      /* Mark as non-dependenty now, this will save time later.  */\n+      TYPE_DEPENDENT_P_VALID (t) = true;\n+    }\n+\n+  /* Now check whether we already have this array variant.  */\n+  if (elt_type != TYPE_MAIN_VARIANT (elt_type))\n+    {\n+      tree m = t;\n+      for (t = m; t; t = TYPE_NEXT_VARIANT (t))\n+\tif (TREE_TYPE (t) == elt_type\n+\t    && TYPE_NAME (t) == NULL_TREE\n+\t    && TYPE_ATTRIBUTES (t) == NULL_TREE)\n+\t  break;\n+      if (!t)\n+\t{\n+\t  t = build_min_array_type (elt_type, index_type);\n+\t  /* Mark dependency now, this saves time later.  */\n+\t  TYPE_DEPENDENT_P_VALID (t) = true;\n+\t  TYPE_DEPENDENT_P (t) = dependent;\n+\t  set_array_type_canon (t, elt_type, index_type, dependent);\n+\t  if (!dependent)\n+\t    {\n+\t      layout_type (t);\n+\t      /* Make sure sizes are shared with the main variant.\n+\t\t layout_type can't be called after setting TYPE_NEXT_VARIANT,\n+\t\t as it will overwrite alignment etc. of all variants.  */\n+\t      TYPE_SIZE (t) = TYPE_SIZE (m);\n+\t      TYPE_SIZE_UNIT (t) = TYPE_SIZE_UNIT (m);\n+\t      TYPE_TYPELESS_STORAGE (t) = TYPE_TYPELESS_STORAGE (m);\n+\t    }\n+\n+\t  TYPE_MAIN_VARIANT (t) = m;\n+\t  TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (m);\n+\t  TYPE_NEXT_VARIANT (m) = t;\n+\t}\n+    }\n+\n+  /* Avoid spurious warnings with VLAs (c++/54583).  */\n+  if (TYPE_SIZE (t) && EXPR_P (TYPE_SIZE (t)))\n+    suppress_warning (TYPE_SIZE (t), OPT_Wunused);\n+\n+  /* Push these needs up to the ARRAY_TYPE so that initialization takes\n+     place more easily.  */\n+  bool needs_ctor = (TYPE_NEEDS_CONSTRUCTING (t)\n+\t\t     = TYPE_NEEDS_CONSTRUCTING (elt_type));\n+  bool needs_dtor = (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t)\n+\t\t     = TYPE_HAS_NONTRIVIAL_DESTRUCTOR (elt_type));\n+\n+  if (!dependent && t == TYPE_MAIN_VARIANT (t)\n+      && !COMPLETE_TYPE_P (t) && COMPLETE_TYPE_P (elt_type))\n+    {\n+      /* The element type has been completed since the last time we saw\n+\t this array type; update the layout and 'tor flags for any variants\n+\t that need it.  */\n+      layout_type (t);\n+      for (tree v = TYPE_NEXT_VARIANT (t); v; v = TYPE_NEXT_VARIANT (v))\n+\t{\n+\t  TYPE_NEEDS_CONSTRUCTING (v) = needs_ctor;\n+\t  TYPE_HAS_NONTRIVIAL_DESTRUCTOR (v) = needs_dtor;\n+\t}\n+    }\n+\n+  return t;\n+}\n+\n+// forked from gcc/cp/tree.cc cp_build_qualified_type_real\n+\n+/* Make a variant of TYPE, qualified with the TYPE_QUALS.  Handles\n+   arrays correctly.  In particular, if TYPE is an array of T's, and\n+   TYPE_QUALS is non-empty, returns an array of qualified T's.\n+\n+   FLAGS determines how to deal with ill-formed qualifications. If\n+   tf_ignore_bad_quals is set, then bad qualifications are dropped\n+   (this is permitted if TYPE was introduced via a typedef or template\n+   type parameter). If bad qualifications are dropped and tf_warning\n+   is set, then a warning is issued for non-const qualifications.  If\n+   tf_ignore_bad_quals is not set and tf_error is not set, we\n+   return error_mark_node. Otherwise, we issue an error, and ignore\n+   the qualifications.\n+\n+   Qualification of a reference type is valid when the reference came\n+   via a typedef or template type argument. [dcl.ref] No such\n+   dispensation is provided for qualifying a function type.  [dcl.fct]\n+   DR 295 queries this and the proposed resolution brings it into line\n+   with qualifying a reference.  We implement the DR.  We also behave\n+   in a similar manner for restricting non-pointer types.  */\n+\n+tree\n+rs_build_qualified_type_real (tree type, int type_quals,\n+\t\t\t      tsubst_flags_t complain)\n+{\n+  tree result;\n+  int bad_quals = TYPE_UNQUALIFIED;\n+\n+  if (type == error_mark_node)\n+    return type;\n+\n+  if (type_quals == rs_type_quals (type))\n+    return type;\n+\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    {\n+      /* In C++, the qualification really applies to the array element\n+\t type.  Obtain the appropriately qualified element type.  */\n+      tree t;\n+      tree element_type\n+\t= rs_build_qualified_type_real (TREE_TYPE (type), type_quals, complain);\n+\n+      if (element_type == error_mark_node)\n+\treturn error_mark_node;\n+\n+      /* See if we already have an identically qualified type.  Tests\n+\t should be equivalent to those in check_qualified_type.  */\n+      for (t = TYPE_MAIN_VARIANT (type); t; t = TYPE_NEXT_VARIANT (t))\n+\tif (TREE_TYPE (t) == element_type && TYPE_NAME (t) == TYPE_NAME (type)\n+\t    && TYPE_CONTEXT (t) == TYPE_CONTEXT (type)\n+\t    && attribute_list_equal (TYPE_ATTRIBUTES (t),\n+\t\t\t\t     TYPE_ATTRIBUTES (type)))\n+\t  break;\n+\n+      if (!t)\n+\t{\n+\t  /* If we already know the dependentness, tell the array type\n+\t     constructor.  This is important for module streaming, as we cannot\n+\t     dynamically determine that on read in.  */\n+\t  t = build_cplus_array_type (element_type, TYPE_DOMAIN (type),\n+\t\t\t\t      TYPE_DEPENDENT_P_VALID (type)\n+\t\t\t\t\t? int (TYPE_DEPENDENT_P (type))\n+\t\t\t\t\t: -1);\n+\n+\t  /* Keep the typedef name.  */\n+\t  if (TYPE_NAME (t) != TYPE_NAME (type))\n+\t    {\n+\t      t = build_variant_type_copy (t);\n+\t      TYPE_NAME (t) = TYPE_NAME (type);\n+\t      SET_TYPE_ALIGN (t, TYPE_ALIGN (type));\n+\t      TYPE_USER_ALIGN (t) = TYPE_USER_ALIGN (type);\n+\t    }\n+\t}\n+\n+      /* Even if we already had this variant, we update\n+\t TYPE_NEEDS_CONSTRUCTING and TYPE_HAS_NONTRIVIAL_DESTRUCTOR in case\n+\t they changed since the variant was originally created.\n+\n+\t This seems hokey; if there is some way to use a previous\n+\t variant *without* coming through here,\n+\t TYPE_NEEDS_CONSTRUCTING will never be updated.  */\n+      TYPE_NEEDS_CONSTRUCTING (t)\n+\t= TYPE_NEEDS_CONSTRUCTING (TYPE_MAIN_VARIANT (element_type));\n+      TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t)\n+\t= TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TYPE_MAIN_VARIANT (element_type));\n+      return t;\n+    }\n+\n+  /* A reference or method type shall not be cv-qualified.\n+     [dcl.ref], [dcl.fct].  This used to be an error, but as of DR 295\n+     (in CD1) we always ignore extra cv-quals on functions.  */\n+\n+  /* [dcl.ref/1] Cv-qualified references are ill-formed except when\n+     the cv-qualifiers are introduced through the use of a typedef-name\n+     ([dcl.typedef], [temp.param]) or decltype-specifier\n+     ([dcl.type.decltype]),in which case the cv-qualifiers are\n+     ignored.  */\n+  if (type_quals & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE)\n+      && (TYPE_REF_P (type) || FUNC_OR_METHOD_TYPE_P (type)))\n+    {\n+      if (TYPE_REF_P (type)\n+\t  && (!typedef_variant_p (type) || FUNC_OR_METHOD_TYPE_P (type)))\n+\tbad_quals |= type_quals & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE);\n+      type_quals &= ~(TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE);\n+    }\n+\n+  /* But preserve any function-cv-quals on a FUNCTION_TYPE.  */\n+  if (TREE_CODE (type) == FUNCTION_TYPE)\n+    type_quals |= type_memfn_quals (type);\n+\n+  /* A restrict-qualified type must be a pointer (or reference)\n+     to object or incomplete type. */\n+  if ((type_quals & TYPE_QUAL_RESTRICT)\n+      && TREE_CODE (type) != TEMPLATE_TYPE_PARM\n+      && TREE_CODE (type) != TYPENAME_TYPE && !INDIRECT_TYPE_P (type))\n+    {\n+      bad_quals |= TYPE_QUAL_RESTRICT;\n+      type_quals &= ~TYPE_QUAL_RESTRICT;\n+    }\n+\n+  if (bad_quals == TYPE_UNQUALIFIED || (complain & tf_ignore_bad_quals))\n+    /*OK*/;\n+  else if (!(complain & tf_error))\n+    return error_mark_node;\n+  else\n+    {\n+      tree bad_type = build_qualified_type (ptr_type_node, bad_quals);\n+      error (\"%qV qualifiers cannot be applied to %qT\", bad_type, type);\n+    }\n+\n+  /* Retrieve (or create) the appropriately qualified variant.  */\n+  result = build_qualified_type (type, type_quals);\n+\n+  return result;\n+}\n+\n+// forked from gcc/cp/c-common.cc vector_targets_convertible_p\n+\n+/* vector_targets_convertible_p is used for vector pointer types.  The\n+   callers perform various checks that the qualifiers are satisfactory,\n+   while OTOH vector_targets_convertible_p ignores the number of elements\n+   in the vectors.  That's fine with vector pointers as we can consider,\n+   say, a vector of 8 elements as two consecutive vectors of 4 elements,\n+   and that does not require and conversion of the pointer values.\n+   In contrast, vector_types_convertible_p and\n+   vector_types_compatible_elements_p are used for vector value types.  */\n+/* True if pointers to distinct types T1 and T2 can be converted to\n+   each other without an explicit cast.  Only returns true for opaque\n+   vector types.  */\n+bool\n+vector_targets_convertible_p (const_tree t1, const_tree t2)\n+{\n+  if (VECTOR_TYPE_P (t1) && VECTOR_TYPE_P (t2)\n+      && (TYPE_VECTOR_OPAQUE (t1) || TYPE_VECTOR_OPAQUE (t2))\n+      && tree_int_cst_equal (TYPE_SIZE (t1), TYPE_SIZE (t2)))\n+    return true;\n+\n+  return false;\n+}\n+\n+// forked from gcc/cp/typeck.cc comp_array_types\n+\n+/* Compare the array types T1 and T2.  CB says how we should behave when\n+   comparing array bounds: bounds_none doesn't allow dimensionless arrays,\n+   bounds_either says than any array can be [], bounds_first means that\n+   onlt T1 can be an array with unknown bounds.  STRICT is true if\n+   qualifiers must match when comparing the types of the array elements.  */\n+\n+static bool\n+comp_array_types (const_tree t1, const_tree t2, compare_bounds_t cb,\n+\t\t  bool strict)\n+{\n+  tree d1;\n+  tree d2;\n+  tree max1, max2;\n+\n+  if (t1 == t2)\n+    return true;\n+\n+  /* The type of the array elements must be the same.  */\n+  if (strict ? !same_type_p (TREE_TYPE (t1), TREE_TYPE (t2))\n+\t     : !similar_type_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n+    return false;\n+\n+  d1 = TYPE_DOMAIN (t1);\n+  d2 = TYPE_DOMAIN (t2);\n+\n+  if (d1 == d2)\n+    return true;\n+\n+  /* If one of the arrays is dimensionless, and the other has a\n+     dimension, they are of different types.  However, it is valid to\n+     write:\n+\n+       extern int a[];\n+       int a[3];\n+\n+     by [basic.link]:\n+\n+       declarations for an array object can specify\n+       array types that differ by the presence or absence of a major\n+       array bound (_dcl.array_).  */\n+  if (!d1 && d2)\n+    return cb >= bounds_either;\n+  else if (d1 && !d2)\n+    return cb == bounds_either;\n+\n+  /* Check that the dimensions are the same.  */\n+\n+  if (!rs_tree_equal (TYPE_MIN_VALUE (d1), TYPE_MIN_VALUE (d2)))\n+    return false;\n+  max1 = TYPE_MAX_VALUE (d1);\n+  max2 = TYPE_MAX_VALUE (d2);\n+\n+  if (!rs_tree_equal (max1, max2))\n+    return false;\n+\n+  return true;\n+}\n+\n+// forked from gcc/cp/typeck.cc same_type_ignoring_top_level_qualifiers_p\n+\n+/* Returns nonzero iff TYPE1 and TYPE2 are the same type, ignoring\n+   top-level qualifiers.  */\n+\n+bool\n+same_type_ignoring_top_level_qualifiers_p (tree type1, tree type2)\n+{\n+  if (type1 == error_mark_node || type2 == error_mark_node)\n+    return false;\n+  if (type1 == type2)\n+    return true;\n+\n+  type1 = rs_build_qualified_type (type1, TYPE_UNQUALIFIED);\n+  type2 = rs_build_qualified_type (type2, TYPE_UNQUALIFIED);\n+  return same_type_p (type1, type2);\n+}\n+\n+// forked from gcc/cp/typeck.cc comp_ptr_ttypes_const\n+\n+/* Return true if TO and FROM (both of which are POINTER_TYPEs or\n+   pointer-to-member types) are the same, ignoring cv-qualification at\n+   all levels.  CB says how we should behave when comparing array bounds.  */\n+\n+bool\n+comp_ptr_ttypes_const (tree to, tree from, compare_bounds_t cb)\n+{\n+  bool is_opaque_pointer = false;\n+\n+  for (;; to = TREE_TYPE (to), from = TREE_TYPE (from))\n+    {\n+      if (TREE_CODE (to) != TREE_CODE (from))\n+\treturn false;\n+\n+      if (TREE_CODE (from) == OFFSET_TYPE\n+\t  && same_type_p (TYPE_OFFSET_BASETYPE (from),\n+\t\t\t  TYPE_OFFSET_BASETYPE (to)))\n+\tcontinue;\n+\n+      if (VECTOR_TYPE_P (to))\n+\tis_opaque_pointer = vector_targets_convertible_p (to, from);\n+\n+      if (TREE_CODE (to) == ARRAY_TYPE\n+\t  /* Ignore cv-qualification, but if we see e.g. int[3] and int[4],\n+\t     we must fail.  */\n+\t  && !comp_array_types (to, from, cb, /*strict=*/false))\n+\treturn false;\n+\n+      /* CWG 330 says we need to look through arrays.  */\n+      if (!TYPE_PTR_P (to) && TREE_CODE (to) != ARRAY_TYPE)\n+\treturn (is_opaque_pointer\n+\t\t|| same_type_ignoring_top_level_qualifiers_p (to, from));\n+    }\n+}\n+\n+// forked from gcc/cp/typeck.cc similar_type_p\n+\n+/* Returns nonzero iff TYPE1 and TYPE2 are similar, as per [conv.qual].  */\n+\n+bool\n+similar_type_p (tree type1, tree type2)\n+{\n+  if (type1 == error_mark_node || type2 == error_mark_node)\n+    return false;\n+\n+  /* Informally, two types are similar if, ignoring top-level cv-qualification:\n+     * they are the same type; or\n+     * they are both pointers, and the pointed-to types are similar; or\n+     * they are both pointers to member of the same class, and the types of\n+       the pointed-to members are similar; or\n+     * they are both arrays of the same size or both arrays of unknown bound,\n+       and the array element types are similar.  */\n+\n+  if (same_type_ignoring_top_level_qualifiers_p (type1, type2))\n+    return true;\n+\n+  if ((TYPE_PTR_P (type1) && TYPE_PTR_P (type2))\n+      || (TYPE_PTRDATAMEM_P (type1) && TYPE_PTRDATAMEM_P (type2))\n+      || (TREE_CODE (type1) == ARRAY_TYPE && TREE_CODE (type2) == ARRAY_TYPE))\n+    return comp_ptr_ttypes_const (type1, type2, bounds_either);\n+\n+  return false;\n+}\n+\n+// forked from gcc/cp/typeck.cc structural_comptypes\n+// note: this fork only handles strict == COMPARE_STRICT\n+// if you pass in any other value for strict i.e. COMPARE_BASE,\n+// COMPARE_DERIVED, COMPARE_REDECLARATION or COMPARE_STRUCTURAL\n+// see the original function in gcc/cp/typeck.cc and port the required bits\n+// specifically under case UNION_TYPE.\n+\n+/* Subroutine in comptypes.  */\n+\n+static bool\n+structural_comptypes (tree t1, tree t2, int strict)\n+{\n+  /* Both should be types that are not obviously the same.  */\n+  gcc_checking_assert (t1 != t2 && TYPE_P (t1) && TYPE_P (t2));\n+\n+  if (TYPE_PTRMEMFUNC_P (t1))\n+    t1 = TYPE_PTRMEMFUNC_FN_TYPE (t1);\n+  if (TYPE_PTRMEMFUNC_P (t2))\n+    t2 = TYPE_PTRMEMFUNC_FN_TYPE (t2);\n+\n+  /* Different classes of types can't be compatible.  */\n+  if (TREE_CODE (t1) != TREE_CODE (t2))\n+    return false;\n+\n+  /* Qualifiers must match.  For array types, we will check when we\n+     recur on the array element types.  */\n+  if (TREE_CODE (t1) != ARRAY_TYPE && rs_type_quals (t1) != rs_type_quals (t2))\n+    return false;\n+  if (TREE_CODE (t1) == FUNCTION_TYPE\n+      && type_memfn_quals (t1) != type_memfn_quals (t2))\n+    return false;\n+  /* Need to check this before TYPE_MAIN_VARIANT.\n+     FIXME function qualifiers should really change the main variant.  */\n+  if (FUNC_OR_METHOD_TYPE_P (t1))\n+    {\n+      if (type_memfn_rqual (t1) != type_memfn_rqual (t2))\n+\treturn false;\n+      if (/* cxx_dialect >= cxx17 && */\n+\t  !comp_except_specs (TYPE_RAISES_EXCEPTIONS (t1),\n+\t\t\t      TYPE_RAISES_EXCEPTIONS (t2), ce_type))\n+\treturn false;\n+    }\n+\n+  /* Allow for two different type nodes which have essentially the same\n+     definition.  Note that we already checked for equality of the type\n+     qualifiers (just above).  */\n+  if (TREE_CODE (t1) != ARRAY_TYPE\n+      && TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2))\n+    return true;\n+\n+  /* Compare the types.  Return false on known not-same. Break on not\n+     known.   Never return true from this switch -- you'll break\n+     specialization comparison.    */\n+  switch (TREE_CODE (t1))\n+    {\n+    case VOID_TYPE:\n+    case BOOLEAN_TYPE:\n+      /* All void and bool types are the same.  */\n+      break;\n+\n+    case OPAQUE_TYPE:\n+    case INTEGER_TYPE:\n+    case FIXED_POINT_TYPE:\n+    case REAL_TYPE:\n+      /* With these nodes, we can't determine type equivalence by\n+\t looking at what is stored in the nodes themselves, because\n+\t two nodes might have different TYPE_MAIN_VARIANTs but still\n+\t represent the same type.  For example, wchar_t and int could\n+\t have the same properties (TYPE_PRECISION, TYPE_MIN_VALUE,\n+\t TYPE_MAX_VALUE, etc.), but have different TYPE_MAIN_VARIANTs\n+\t and are distinct types. On the other hand, int and the\n+\t following typedef\n+\n+\t   typedef int INT __attribute((may_alias));\n+\n+\t have identical properties, different TYPE_MAIN_VARIANTs, but\n+\t represent the same type.  The canonical type system keeps\n+\t track of equivalence in this case, so we fall back on it.  */\n+      if (TYPE_CANONICAL (t1) != TYPE_CANONICAL (t2))\n+\treturn false;\n+\n+      /* We don't need or want the attribute comparison.  */\n+      return true;\n+\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+      return false;\n+\n+    case OFFSET_TYPE:\n+      if (!comptypes (TYPE_OFFSET_BASETYPE (t1), TYPE_OFFSET_BASETYPE (t2),\n+\t\t      strict & ~COMPARE_REDECLARATION))\n+\treturn false;\n+      if (!same_type_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n+\treturn false;\n+      break;\n+\n+    case REFERENCE_TYPE:\n+      if (TYPE_REF_IS_RVALUE (t1) != TYPE_REF_IS_RVALUE (t2))\n+\treturn false;\n+      /* fall through to checks for pointer types */\n+      gcc_fallthrough ();\n+\n+    case POINTER_TYPE:\n+      if (TYPE_MODE (t1) != TYPE_MODE (t2)\n+\t  || !same_type_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n+\treturn false;\n+      break;\n+\n+    case METHOD_TYPE:\n+    case FUNCTION_TYPE:\n+      /* Exception specs and memfn_rquals were checked above.  */\n+      if (!same_type_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n+\treturn false;\n+      if (!compparms (TYPE_ARG_TYPES (t1), TYPE_ARG_TYPES (t2)))\n+\treturn false;\n+      break;\n+\n+    case ARRAY_TYPE:\n+      /* Target types must match incl. qualifiers.  */\n+      if (!comp_array_types (t1, t2,\n+\t\t\t     ((strict & COMPARE_REDECLARATION) ? bounds_either\n+\t\t\t\t\t\t\t       : bounds_none),\n+\t\t\t     /*strict=*/true))\n+\treturn false;\n+      break;\n+\n+    case COMPLEX_TYPE:\n+      if (!same_type_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n+\treturn false;\n+      break;\n+\n+    case VECTOR_TYPE:\n+      if (gnu_vector_type_p (t1) != gnu_vector_type_p (t2)\n+\t  || maybe_ne (TYPE_VECTOR_SUBPARTS (t1), TYPE_VECTOR_SUBPARTS (t2))\n+\t  || !same_type_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n+\treturn false;\n+      break;\n+\n+    default:\n+      return false;\n+    }\n+\n+  /* If we get here, we know that from a target independent POV the\n+     types are the same.  Make sure the target attributes are also\n+     the same.  */\n+  if (!comp_type_attributes (t1, t2))\n+    return false;\n+\n+  return true;\n+}\n+\n+// forked from gcc/cp/typeck.cc comptypes\n+\n+/* Return true if T1 and T2 are related as allowed by STRICT.  STRICT\n+   is a bitwise-or of the COMPARE_* flags.  */\n+\n+bool\n+comptypes (tree t1, tree t2, int strict)\n+{\n+  gcc_checking_assert (t1 && t2);\n+\n+  /* TYPE_ARGUMENT_PACKS are not really types.  */\n+  gcc_checking_assert (TREE_CODE (t1) != TYPE_ARGUMENT_PACK\n+\t\t       && TREE_CODE (t2) != TYPE_ARGUMENT_PACK);\n+\n+  if (t1 == t2)\n+    return true;\n+\n+  /* Suppress errors caused by previously reported errors.  */\n+  if (t1 == error_mark_node || t2 == error_mark_node)\n+    return false;\n+\n+  if (strict == COMPARE_STRICT)\n+    {\n+      if (TYPE_STRUCTURAL_EQUALITY_P (t1) || TYPE_STRUCTURAL_EQUALITY_P (t2))\n+\t/* At least one of the types requires structural equality, so\n+\t   perform a deep check. */\n+\treturn structural_comptypes (t1, t2, strict);\n+\n+      if (flag_checking && param_use_canonical_types)\n+\t{\n+\t  bool result = structural_comptypes (t1, t2, strict);\n+\n+\t  if (result && TYPE_CANONICAL (t1) != TYPE_CANONICAL (t2))\n+\t    /* The two types are structurally equivalent, but their\n+\t       canonical types were different. This is a failure of the\n+\t       canonical type propagation code.*/\n+\t    internal_error (\n+\t      \"canonical types differ for identical types %qT and %qT\", t1, t2);\n+\t  else if (!result && TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2))\n+\t    /* Two types are structurally different, but the canonical\n+\t       types are the same. This means we were over-eager in\n+\t       assigning canonical types. */\n+\t    internal_error (\n+\t      \"same canonical type node for different types %qT and %qT\", t1,\n+\t      t2);\n+\n+\t  return result;\n+\t}\n+      if (!flag_checking && param_use_canonical_types)\n+\treturn TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2);\n+      else\n+\treturn structural_comptypes (t1, t2, strict);\n+    }\n+  else if (strict == COMPARE_STRUCTURAL)\n+    return structural_comptypes (t1, t2, COMPARE_STRICT);\n+  else\n+    return structural_comptypes (t1, t2, strict);\n+}\n+\n } // namespace Rust"}, {"sha": "d5cc3186811aacbe6862466e7b9c42263ecedebc", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 411, "deletions": 0, "changes": 411, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3343535fdb7fc36e68949a8642d7e67668b67f6c/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3343535fdb7fc36e68949a8642d7e67668b67f6c/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=3343535fdb7fc36e68949a8642d7e67668b67f6c", "patch": "@@ -745,6 +745,106 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n #define TYPE_NAME_STRING(NODE) (IDENTIFIER_POINTER (TYPE_IDENTIFIER (NODE)))\n #define TYPE_NAME_LENGTH(NODE) (IDENTIFIER_LENGTH (TYPE_IDENTIFIER (NODE)))\n \n+/* Whether a PARM_DECL represents a local parameter in a\n+   requires-expression.  */\n+#define CONSTRAINT_VAR_P(NODE) DECL_LANG_FLAG_2 (TREE_CHECK (NODE, PARM_DECL))\n+\n+/* In a CALL_EXPR appearing in a template, true if Koenig lookup\n+   should be performed at instantiation time.  */\n+#define KOENIG_LOOKUP_P(NODE) TREE_LANG_FLAG_0 (CALL_EXPR_CHECK (NODE))\n+\n+/* The index of a user-declared parameter in its function, starting at 1.\n+   All artificial parameters will have index 0.  */\n+#define DECL_PARM_INDEX(NODE) (LANG_DECL_PARM_CHECK (NODE)->index)\n+\n+/* The level of a user-declared parameter in its function, starting at 1.\n+   A parameter of the function will have level 1; a parameter of the first\n+   nested function declarator (i.e. t in void f (void (*p)(T t))) will have\n+   level 2.  */\n+#define DECL_PARM_LEVEL(NODE) (LANG_DECL_PARM_CHECK (NODE)->level)\n+\n+#define LANG_DECL_PARM_CHECK(NODE) (&DECL_LANG_SPECIFIC (NODE)->u.parm)\n+\n+/* These flags are used by the conversion code.\n+   CONV_IMPLICIT   :  Perform implicit conversions (standard and user-defined).\n+   CONV_STATIC     :  Perform the explicit conversions for static_cast.\n+   CONV_CONST      :  Perform the explicit conversions for const_cast.\n+   CONV_REINTERPRET:  Perform the explicit conversions for reinterpret_cast.\n+   CONV_PRIVATE    :  Perform upcasts to private bases.\n+   CONV_FORCE_TEMP :  Require a new temporary when converting to the same\n+\t\t      aggregate type.  */\n+\n+#define CONV_IMPLICIT 1\n+#define CONV_STATIC 2\n+#define CONV_CONST 4\n+#define CONV_REINTERPRET 8\n+#define CONV_PRIVATE 16\n+#define CONV_FORCE_TEMP 32\n+#define CONV_FOLD 64\n+#define CONV_OLD_CONVERT                                                       \\\n+  (CONV_IMPLICIT | CONV_STATIC | CONV_CONST | CONV_REINTERPRET)\n+#define CONV_C_CAST                                                            \\\n+  (CONV_IMPLICIT | CONV_STATIC | CONV_CONST | CONV_REINTERPRET | CONV_PRIVATE  \\\n+   | CONV_FORCE_TEMP)\n+#define CONV_BACKEND_CONVERT (CONV_OLD_CONVERT | CONV_FOLD)\n+\n+/* Used by build_expr_type_conversion to indicate which types are\n+   acceptable as arguments to the expression under consideration.  */\n+\n+#define WANT_INT 1\t\t  /* integer types, including bool */\n+#define WANT_FLOAT 2\t\t  /* floating point types */\n+#define WANT_ENUM 4\t\t  /* enumerated types */\n+#define WANT_POINTER 8\t\t  /* pointer types */\n+#define WANT_NULL 16\t\t  /* null pointer constant */\n+#define WANT_VECTOR_OR_COMPLEX 32 /* vector or complex types */\n+#define WANT_ARITH (WANT_INT | WANT_FLOAT | WANT_VECTOR_OR_COMPLEX)\n+\n+/* Used with comptypes, and related functions, to guide type\n+   comparison.  */\n+\n+#define COMPARE_STRICT                                                         \\\n+  0 /* Just check if the types are the                                         \\\n+       same.  */\n+#define COMPARE_BASE                                                           \\\n+  1 /* Check to see if the second type is                                      \\\n+       derived from the first.  */\n+#define COMPARE_DERIVED                                                        \\\n+  2 /* Like COMPARE_BASE, but in                                               \\\n+       reverse.  */\n+#define COMPARE_REDECLARATION                                                  \\\n+  4 /* The comparison is being done when                                       \\\n+       another declaration of an existing                                      \\\n+       entity is seen.  */\n+#define COMPARE_STRUCTURAL                                                     \\\n+  8 /* The comparison is intended to be                                        \\\n+       structural. The actual comparison                                       \\\n+       will be identical to                                                    \\\n+       COMPARE_STRICT.  */\n+\n+/* Used with start function.  */\n+#define SF_DEFAULT 0 /* No flags.  */\n+#define SF_PRE_PARSED                                                          \\\n+  1 /* The function declaration has                                            \\\n+       already been parsed.  */\n+#define SF_INCLASS_INLINE                                                      \\\n+  2 /* The function is an inline, defined                                      \\\n+       in the class body.  */\n+\n+/* Used with start_decl's initialized parameter.  */\n+#define SD_UNINITIALIZED 0\n+#define SD_INITIALIZED 1\n+/* Like SD_INITIALIZED, but also mark the new decl as DECL_DECOMPOSITION_P.  */\n+#define SD_DECOMPOSITION 2\n+#define SD_DEFAULTED 3\n+#define SD_DELETED 4\n+\n+/* Returns nonzero iff TYPE1 and TYPE2 are the same type, in the usual\n+   sense of `same'.  */\n+#define same_type_p(TYPE1, TYPE2) comptypes ((TYPE1), (TYPE2), COMPARE_STRICT)\n+\n+/* Returns true if NODE is a pointer-to-data-member.  */\n+#define TYPE_PTRDATAMEM_P(NODE) (TREE_CODE (NODE) == OFFSET_TYPE)\n+\n // Below macros are copied from gcc/c-family/c-common.h\n \n /* In a FIELD_DECL, nonzero if the decl was originally a bitfield.  */\n@@ -810,6 +910,234 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n \n // Above macros are copied from gcc/cp/name-lookup.cc\n \n+/* hash traits for declarations.  Hashes potential overload sets via\n+   DECL_NAME.  */\n+\n+struct named_decl_hash : ggc_remove<tree>\n+{\n+  typedef tree value_type;   /* A DECL or OVERLOAD  */\n+  typedef tree compare_type; /* An identifier.  */\n+\n+  inline static hashval_t hash (const value_type decl);\n+  inline static bool equal (const value_type existing, compare_type candidate);\n+\n+  static const bool empty_zero_p = true;\n+  static inline void mark_empty (value_type &p) { p = NULL_TREE; }\n+  static inline bool is_empty (value_type p) { return !p; }\n+\n+  /* Nothing is deletable.  Everything is insertable.  */\n+  static bool is_deleted (value_type) { return false; }\n+  static void mark_deleted (value_type) { gcc_unreachable (); }\n+};\n+\n+// forked from gcc/cp/cp-tree.h lang_decl_selector\n+\n+/* Discriminator values for lang_decl.  */\n+\n+enum lang_decl_selector\n+{\n+  lds_min,\n+  lds_fn,\n+  lds_ns,\n+  lds_parm,\n+  lds_decomp\n+};\n+\n+// forked from gcc/cp/cp-tree.h lang_decl_base\n+\n+/* Flags shared by all forms of DECL_LANG_SPECIFIC.\n+\n+   Some of the flags live here only to make lang_decl_min/fn smaller.  Do\n+   not make this struct larger than 32 bits.  */\n+\n+struct GTY (()) lang_decl_base\n+{\n+  ENUM_BITFIELD (lang_decl_selector) selector : 3;\n+  unsigned use_template : 2;\n+  unsigned not_really_extern : 1;    /* var or fn */\n+  unsigned initialized_in_class : 1; /* var or fn */\n+\n+  unsigned threadprivate_or_deleted_p : 1; /* var or fn */\n+  /* anticipated_p is no longer used for anticipated_decls (fn, type\n+     or template).  It is used as DECL_OMP_PRIVATIZED_MEMBER in\n+     var.  */\n+  unsigned anticipated_p : 1;\n+  unsigned friend_or_tls : 1;\t      /* var, fn, type or template */\n+  unsigned unknown_bound_p : 1;\t      /* var */\n+  unsigned odr_used : 1;\t      /* var or fn */\n+  unsigned concept_p : 1;\t      /* applies to vars and functions */\n+  unsigned var_declared_inline_p : 1; /* var */\n+  unsigned dependent_init_p : 1;      /* var */\n+\n+  /* The following apply to VAR, FUNCTION, TYPE, CONCEPT, & NAMESPACE\n+     decls.  */\n+  unsigned module_purview_p : 1; /* in module purview (not GMF) */\n+  unsigned module_import_p : 1;\t /* from an import */\n+  unsigned module_entity_p : 1;\t /* is in the entitity ary &\n+\t\t\t\t    hash.  */\n+  /* VAR_DECL or FUNCTION_DECL has attached decls.     */\n+  unsigned module_attached_p : 1;\n+\n+  /* 12 spare bits.  */\n+};\n+\n+/* True for DECL codes which have template info and access.  */\n+#define LANG_DECL_HAS_MIN(NODE)                                                \\\n+  (VAR_OR_FUNCTION_DECL_P (NODE) || TREE_CODE (NODE) == FIELD_DECL             \\\n+   || TREE_CODE (NODE) == CONST_DECL || TREE_CODE (NODE) == TYPE_DECL          \\\n+   || TREE_CODE (NODE) == TEMPLATE_DECL || TREE_CODE (NODE) == USING_DECL      \\\n+   || TREE_CODE (NODE) == CONCEPT_DECL)\n+\n+// forked from gcc/cp/cp-tree.h lang_decl_min\n+\n+/* DECL_LANG_SPECIFIC for the above codes.  */\n+\n+struct GTY (()) lang_decl_min\n+{\n+  struct lang_decl_base base; /* 32-bits.  */\n+\n+  /* In a FUNCTION_DECL for which DECL_THUNK_P holds, this is\n+     THUNK_ALIAS.\n+     In a FUNCTION_DECL for which DECL_THUNK_P does not hold,\n+     VAR_DECL, TYPE_DECL, or TEMPLATE_DECL, this is\n+     DECL_TEMPLATE_INFO.  */\n+  tree template_info;\n+\n+  /* In a DECL_THUNK_P FUNCTION_DECL, this is THUNK_VIRTUAL_OFFSET.\n+     In a lambda-capture proxy VAR_DECL, this is DECL_CAPTURED_VARIABLE.\n+     In a function-scope TREE_STATIC VAR_DECL or IMPLICIT_TYPEDEF_P TYPE_DECL,\n+     this is DECL_DISCRIMINATOR.\n+     In a DECL_LOCAL_DECL_P decl, this is the namespace decl it aliases.\n+     Otherwise, in a class-scope DECL, this is DECL_ACCESS.   */\n+  tree access;\n+};\n+\n+// forked from gcc/cp/cp-tree.h lang_decl_fn\n+\n+/* Additional DECL_LANG_SPECIFIC information for functions.  */\n+\n+struct GTY (()) lang_decl_fn\n+{\n+  struct lang_decl_min min;\n+\n+  /* In a overloaded operator, this is the compressed operator code.  */\n+  unsigned ovl_op_code : 6;\n+  unsigned global_ctor_p : 1;\n+  unsigned global_dtor_p : 1;\n+\n+  unsigned static_function : 1;\n+  unsigned pure_virtual : 1;\n+  unsigned defaulted_p : 1;\n+  unsigned has_in_charge_parm_p : 1;\n+  unsigned has_vtt_parm_p : 1;\n+  unsigned pending_inline_p : 1;\n+  unsigned nonconverting : 1;\n+  unsigned thunk_p : 1;\n+\n+  unsigned this_thunk_p : 1;\n+  unsigned omp_declare_reduction_p : 1;\n+  unsigned has_dependent_explicit_spec_p : 1;\n+  unsigned immediate_fn_p : 1;\n+  unsigned maybe_deleted : 1;\n+  unsigned coroutine_p : 1;\n+  unsigned implicit_constexpr : 1;\n+\n+  unsigned spare : 9;\n+\n+  /* 32-bits padding on 64-bit host.  */\n+\n+  /* For a non-thunk function decl, this is a tree list of\n+     friendly classes. For a thunk function decl, it is the\n+     thunked to function decl.  */\n+  tree befriending_classes;\n+\n+  /* For a virtual FUNCTION_DECL for which\n+     DECL_THIS_THUNK_P does not hold, this is DECL_THUNKS. Both\n+     this pointer and result pointer adjusting thunks are\n+     chained here.  This pointer thunks to return pointer thunks\n+     will be chained on the return pointer thunk.\n+     For a DECL_CONSTUCTOR_P FUNCTION_DECL, this is the base from\n+     whence we inherit.  Otherwise, it is the class in which a\n+     (namespace-scope) friend is defined (if any).   */\n+  tree context;\n+\n+  union lang_decl_u5\n+  {\n+    /* In a non-thunk FUNCTION_DECL, this is DECL_CLONED_FUNCTION.  */\n+    tree GTY ((tag (\"0\"))) cloned_function;\n+\n+    /* In a FUNCTION_DECL for which THUNK_P holds this is the\n+       THUNK_FIXED_OFFSET.  */\n+    HOST_WIDE_INT GTY ((tag (\"1\"))) fixed_offset;\n+  } GTY ((desc (\"%1.thunk_p\"))) u5;\n+\n+  union lang_decl_u3\n+  {\n+    struct cp_token_cache *GTY ((tag (\"1\"))) pending_inline_info;\n+    tree GTY ((tag (\"0\"))) saved_auto_return_type;\n+  } GTY ((desc (\"%1.pending_inline_p\"))) u;\n+};\n+\n+// forked from gcc/cp/cp-tree.h lang_decl_ns\n+\n+/* DECL_LANG_SPECIFIC for namespaces.  */\n+\n+struct GTY (()) lang_decl_ns\n+{\n+  struct lang_decl_base base; /* 32 bits.  */\n+\n+  /* Inline children.  Needs to be va_gc, because of PCH.  */\n+  vec<tree, va_gc> *inlinees;\n+\n+  /* Hash table of bound decls. It'd be nice to have this inline, but\n+     as the hash_map has a dtor, we can't then put this struct into a\n+     union (until moving to c++11).  */\n+  hash_table<named_decl_hash> *bindings;\n+};\n+\n+// forked from gcc/cp/cp-tree.h lang_decl_parm\n+\n+/* DECL_LANG_SPECIFIC for parameters.  */\n+\n+struct GTY (()) lang_decl_parm\n+{\n+  struct lang_decl_base base; /* 32 bits.  */\n+  int level;\n+  int index;\n+};\n+\n+// forked from gcc/cp/cp-tree.h lang_decl_decomp\n+\n+/* Additional DECL_LANG_SPECIFIC information for structured bindings.  */\n+\n+struct GTY (()) lang_decl_decomp\n+{\n+  struct lang_decl_min min;\n+  /* The artificial underlying \"e\" variable of the structured binding\n+     variable.  */\n+  tree base;\n+};\n+\n+// forked from gcc/cp/cp-tree.h lang_decl\n+\n+/* DECL_LANG_SPECIFIC for all types.  It would be nice to just make this a\n+   union rather than a struct containing a union as its only field, but\n+   tree.h declares it as a struct.  */\n+\n+struct GTY (()) lang_decl\n+{\n+  union GTY ((desc (\"%h.base.selector\"))) lang_decl_u\n+  {\n+    /* Nothing of only the base type exists.  */\n+    struct lang_decl_base GTY ((default)) base;\n+    struct lang_decl_min GTY ((tag (\"lds_min\"))) min;\n+    struct lang_decl_fn GTY ((tag (\"lds_fn\"))) fn;\n+    struct lang_decl_ns GTY ((tag (\"lds_ns\"))) ns;\n+    struct lang_decl_parm GTY ((tag (\"lds_parm\"))) parm;\n+    struct lang_decl_decomp GTY ((tag (\"lds_decomp\"))) decomp;\n+  } u;\n+};\n+\n // forked from gcc/c-family/c-common.h c_fileinfo\n \n /* Information recorded about each file examined during compilation.  */\n@@ -958,6 +1286,38 @@ class ovl_iterator\n   static tree reveal_node (tree ovl, tree node);\n };\n \n+// forked from gcc/cp/cp-tree.h lkp_iterator\n+\n+/* Iterator over a (potentially) 2 dimensional overload, which is\n+   produced by name lookup.  */\n+\n+class lkp_iterator : public ovl_iterator\n+{\n+  typedef ovl_iterator parent;\n+\n+  tree outer;\n+\n+public:\n+  explicit lkp_iterator (tree o) : parent (o, true), outer (maybe_push ()) {}\n+\n+public:\n+  lkp_iterator &operator++ ()\n+  {\n+    bool repush = !outer;\n+\n+    if (!parent::operator++ () && !repush)\n+      {\n+\tpop (outer);\n+\trepush = true;\n+      }\n+\n+    if (repush)\n+      outer = maybe_push ();\n+\n+    return *this;\n+  }\n+};\n+\n // forked from gcc/cp/cp-tree.h treee_pair_s\n \n struct GTY (()) tree_pair_s\n@@ -1203,6 +1563,18 @@ enum rs_built_in_function\n   RS_BUILT_IN_LAST\n };\n \n+// forked from gcc/cp/cp-tree.h compare_bounds_t\n+\n+/* in typeck.cc */\n+/* Says how we should behave when comparing two arrays one of which\n+   has unknown bounds.  */\n+enum compare_bounds_t\n+{\n+  bounds_none,\n+  bounds_either,\n+  bounds_first\n+};\n+\n extern tree\n convert_to_void (tree expr, impl_conv_void implicit);\n \n@@ -1345,6 +1717,33 @@ build_cplus_array_type (tree, tree, int is_dep = -1);\n \n extern bool is_byte_access_type (tree);\n \n+extern bool\n+comptypes (tree, tree, int);\n+\n+extern tree canonical_eh_spec\t\t\t(tree);\n+\n+extern int cp_tree_operand_length\t\t(const_tree);\n+\n+extern bool rs_tree_equal\t\t\t(tree, tree);\n+\n+extern bool compparms\t\t\t\t(const_tree, const_tree);\n+\n+extern tree\n+rs_build_qualified_type_real (tree, int, tsubst_flags_t);\n+#define rs_build_qualified_type(TYPE, QUALS)                                   \\\n+  rs_build_qualified_type_real ((TYPE), (QUALS), tf_warning_or_error)\n+extern bool cv_qualified_p (const_tree);\n+\n+extern bool similar_type_p (tree, tree);\n+\n+extern bool rs_tree_equal (tree, tree);\n+\n+extern bool vector_targets_convertible_p (const_tree t1, const_tree t2);\n+\n+extern bool same_type_ignoring_top_level_qualifiers_p (tree, tree);\n+\n+extern bool comp_ptr_ttypes_const\t\t(tree, tree, compare_bounds_t);\n+\n // forked from gcc/cp/cp-tree.h\n \n enum\n@@ -1441,6 +1840,18 @@ identifier_p (tree t)\n   return NULL;\n }\n \n+// forked from gcc/c-family/c-common.h gnu_vector_type_p\n+\n+/* Return true if TYPE is a vector type that should be subject to the GNU\n+   vector extensions (as opposed to a vector type that is used only for\n+   the purposes of defining target-specific built-in functions).  */\n+\n+inline bool\n+gnu_vector_type_p (const_tree type)\n+{\n+  return TREE_CODE (type) == VECTOR_TYPE && !TYPE_INDIVISIBLE_P (type);\n+}\n+\n } // namespace Rust\n \n #endif // RUST_TREE"}]}