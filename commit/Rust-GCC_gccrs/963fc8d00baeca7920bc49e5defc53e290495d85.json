{"sha": "963fc8d00baeca7920bc49e5defc53e290495d85", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTYzZmM4ZDAwYmFlY2E3OTIwYmM0OWU1ZGVmYzUzZTI5MDQ5NWQ4NQ==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel1@de.ibm.com", "date": "2008-05-28T14:11:19Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2008-05-28T14:11:19Z"}, "message": "constraints.md ('b', [...]): New constraint letters defined.\n\n2008-05-28  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n\t* config/s390/constraints.md ('b', 'C', 'D', 'e'): New constraint\n\tletters defined.\n\n\t* config/s390/s390.c (s390_compare_and_branch_condition_mask,\n\ts390_contiguous_bitmask_p, s390_symref_operand_p,\n\ts390_check_symref_alignment, s390_reload_larl_operand,\n\ts390_reload_symref_address): New functions.\n\t(s390_branch_condition_mnemonic): Support compare and branch\n\tinstructions.\n\t(s390_mem_constraint): Avoid symrefs to accepted by the 'T'\n\tand 'W' constraints.\n\t(s390_secondary_reload): Add secondary reloads for unaligned\n\tsymbol refs or symbol refs to floating point or QI/TI mode\n\tinteger values.\n\t(legitimate_address_p): Accept symbol references as addresses.\n\t(s390_expand_insv): Use rotate and insert selected bits\n\tinstruction for insv when building for z10.\n\t(print_operand_address): Handle symbol ref addresses.\n\t(print_operand): Output modifier 'c' added for signed byte\n\tvalues.\n\t(s390_encode_section_info): Mark symbol refs with\n\tSYMBOL_FLAG_NOT_NATURALLY_ALIGNED if appropriate.\n\n\t* config/s390/s390.md (SIL,RRS,RIS): New instruction formats added.\n\t(length attribute): RRF, RRR have 4 byte length.\n\t(FPALL, INTALL): New mode iterators added.\n\t(*tstdi_sign, *cmpdi_ccs_sign, *cmpsi_ccs_sign,\n\t*cmp<mode>_ccs, *cmpdi_ccu_zero, *cmpdi_ccu, *cmpsi_ccu, *cmphi_ccu,\n\t*movdi_64, *movsi_zarch, *movhi, movmem<mode>, *movmem_short,\n\t*extendsidi2, *extendhidi2_extimm, *extendhisi2_extimm,\n\t*zero_extendsidi2, adddi3, *adddi3_31z, *adddi3_31, addsi3,\n\t*add<mode>3, *add<mode>3_carry1_cc, *add<mode>3_carry2_cc,\n\t*add<mode>3_cc, *add<mode>3_imm_cc, *muldi3_sign, muldi3,\n\t*mulsi3_sign, mulsi3, mulsidi3): Patterns enhanced with z10\n\tinstructions.\n\t(*cmphi_ccs_z10, *cmpdi_ccs_signhi_rl, *cmpsi_ccu_zerohi_rlsi,\n\t*cmp<GPR:mode>_ccu_zerohi_rldi, *cmp_and_br_signed_<mode>,\n\t*cmp_and_br_unsigned_<mode>, reload<INTALL:mode><P:mode>_tomem_z10,\n\treload<INTALL:mode><P:mode>_toreg_z10,\n\treload<FPALL:mode><P:mode>_tomem_z10,\n\treload<FPALL:mode><P:mode>_toreg_z10,\n\treload<P:mode>_larl_odd_addend_z10, *execute_rl, *insv<mode>_z10,\n\t*insv<mode>_z10_noshift, *insv<mode>_or_z10_noshift,\n\t*zero_extendhi<mode>2_z10, *cmp_and_trap_signed_int<mode>,\n\t*cmp_and_trap_unsigned_int<mode>, prefetch): New pattern or expander\n\tdefinition.\n\t(movmem, clrmem, cmpmem): New splitters added.\n\n\t* config/s390/predicates.md (larl_operand): Use\n\tSYMBOL_REF_FLAGS (op) & SYMBOL_FLAG_ALIGN1 replaced with\n\tSYMBOL_REF_ALIGN1_P.\n\t(s390_signed_integer_comparison,\n\ts390_unsigned_integer_comparison): New predicates.\n\n\t* config/s390/s390-protos.h (s390_check_symref_alignment,\n\ts390_contiguous_bitmask_p, s390_reload_larl_operand,\n\ts390_reload_symref_address,\n\ts390_compare_and_branch_condition_mask): Prototypes added.\n\n\t* config/s390/s390.h (TARGET_MEM_CONSTRAINT,\n\tSYMBOL_REF_ALIGN1_P, SYMBOL_FLAG_NOT_NATURALLY_ALIGNED,\n\tSYMBOL_REF_NOT_NATURALLY_ALIGNED_P): Macro definition added.\n\nFrom-SVN: r136098", "tree": {"sha": "79e2244d727348f1422e1e2e4085cb4c39b63834", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79e2244d727348f1422e1e2e4085cb4c39b63834"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/963fc8d00baeca7920bc49e5defc53e290495d85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/963fc8d00baeca7920bc49e5defc53e290495d85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/963fc8d00baeca7920bc49e5defc53e290495d85", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/963fc8d00baeca7920bc49e5defc53e290495d85/comments", "author": null, "committer": null, "parents": [{"sha": "93538e8eda151ed00a7919836b302c0e3763dac3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93538e8eda151ed00a7919836b302c0e3763dac3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93538e8eda151ed00a7919836b302c0e3763dac3"}], "stats": {"total": 1310, "additions": 1119, "deletions": 191}, "files": [{"sha": "a64b0b01185418faea66adc3869fd649010703a7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/963fc8d00baeca7920bc49e5defc53e290495d85/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/963fc8d00baeca7920bc49e5defc53e290495d85/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=963fc8d00baeca7920bc49e5defc53e290495d85", "patch": "@@ -1,3 +1,68 @@\n+2008-05-28  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\t* config/s390/constraints.md ('b', 'C', 'D', 'e'): New constraint\n+\tletters defined.\n+\n+\t* config/s390/s390.c (s390_compare_and_branch_condition_mask,\n+\ts390_contiguous_bitmask_p, s390_symref_operand_p,\n+\ts390_check_symref_alignment, s390_reload_larl_operand,\n+\ts390_reload_symref_address): New functions.\n+\t(s390_branch_condition_mnemonic): Support compare and branch\n+\tinstructions.\n+\t(s390_mem_constraint): Avoid symrefs to accepted by the 'T'\n+\tand 'W' constraints.\n+\t(s390_secondary_reload): Add secondary reloads for unaligned\n+\tsymbol refs or symbol refs to floating point or QI/TI mode\n+\tinteger values.\n+\t(legitimate_address_p): Accept symbol references as addresses.\n+\t(s390_expand_insv): Use rotate and insert selected bits\n+\tinstruction for insv when building for z10.\n+\t(print_operand_address): Handle symbol ref addresses.\n+\t(print_operand): Output modifier 'c' added for signed byte\n+\tvalues.\n+\t(s390_encode_section_info): Mark symbol refs with\n+\tSYMBOL_FLAG_NOT_NATURALLY_ALIGNED if appropriate.\n+\n+\t* config/s390/s390.md (SIL,RRS,RIS): New instruction formats added.\n+\t(length attribute): RRF, RRR have 4 byte length.\n+\t(FPALL, INTALL): New mode iterators added.\n+\t(*tstdi_sign, *cmpdi_ccs_sign, *cmpsi_ccs_sign,\n+\t*cmp<mode>_ccs, *cmpdi_ccu_zero, *cmpdi_ccu, *cmpsi_ccu, *cmphi_ccu,\n+\t*movdi_64, *movsi_zarch, *movhi, movmem<mode>, *movmem_short,\n+\t*extendsidi2, *extendhidi2_extimm, *extendhisi2_extimm,\n+\t*zero_extendsidi2, adddi3, *adddi3_31z, *adddi3_31, addsi3,\n+\t*add<mode>3, *add<mode>3_carry1_cc, *add<mode>3_carry2_cc,\n+\t*add<mode>3_cc, *add<mode>3_imm_cc, *muldi3_sign, muldi3,\n+\t*mulsi3_sign, mulsi3, mulsidi3): Patterns enhanced with z10\n+\tinstructions.\n+\t(*cmphi_ccs_z10, *cmpdi_ccs_signhi_rl, *cmpsi_ccu_zerohi_rlsi,\n+\t*cmp<GPR:mode>_ccu_zerohi_rldi, *cmp_and_br_signed_<mode>,\n+\t*cmp_and_br_unsigned_<mode>, reload<INTALL:mode><P:mode>_tomem_z10,\n+\treload<INTALL:mode><P:mode>_toreg_z10,\n+\treload<FPALL:mode><P:mode>_tomem_z10,\n+\treload<FPALL:mode><P:mode>_toreg_z10,\n+\treload<P:mode>_larl_odd_addend_z10, *execute_rl, *insv<mode>_z10,\n+\t*insv<mode>_z10_noshift, *insv<mode>_or_z10_noshift,\n+\t*zero_extendhi<mode>2_z10, *cmp_and_trap_signed_int<mode>,\n+\t*cmp_and_trap_unsigned_int<mode>, prefetch): New pattern or expander\n+\tdefinition.\n+\t(movmem, clrmem, cmpmem): New splitters added.\n+\n+\t* config/s390/predicates.md (larl_operand): Use\n+\tSYMBOL_REF_FLAGS (op) & SYMBOL_FLAG_ALIGN1 replaced with\n+\tSYMBOL_REF_ALIGN1_P.\n+\t(s390_signed_integer_comparison,\n+\ts390_unsigned_integer_comparison): New predicates.\n+\n+\t* config/s390/s390-protos.h (s390_check_symref_alignment,\n+\ts390_contiguous_bitmask_p, s390_reload_larl_operand,\n+\ts390_reload_symref_address,\n+\ts390_compare_and_branch_condition_mask): Prototypes added.\n+\n+\t* config/s390/s390.h (TARGET_MEM_CONSTRAINT,\n+\tSYMBOL_REF_ALIGN1_P, SYMBOL_FLAG_NOT_NATURALLY_ALIGNED,\n+\tSYMBOL_REF_NOT_NATURALLY_ALIGNED_P): Macro definition added.\n+\n 2008-05-28  Andreas Krebbel  <krebbel1@de.ibm.com>\n \n \t* config/s390/s390.c (z10_cost): New cost function for z10."}, {"sha": "ad953080ff138ea7628c91987955138b70217995", "filename": "gcc/config/s390/constraints.md", "status": "modified", "additions": 39, "deletions": 4, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/963fc8d00baeca7920bc49e5defc53e290495d85/gcc%2Fconfig%2Fs390%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/963fc8d00baeca7920bc49e5defc53e290495d85/gcc%2Fconfig%2Fs390%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fconstraints.md?ref=963fc8d00baeca7920bc49e5defc53e290495d85", "patch": "@@ -1,5 +1,5 @@\n ;; Constraints definitions belonging to the gcc backend for IBM S/390.\n-;; Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n+;; Copyright (C) 2006, 2007, 2008 Free Software Foundation, Inc.\n ;; Written by Wolfgang Gellerich, using code and information found in\n ;; files s390.md, s390.h, and s390.c.\n ;;\n@@ -24,10 +24,14 @@\n ;; Special constraints for s/390 machine description:\n ;;\n ;;    a -- Any address register from 1 to 15.\n+;;    b -- Memory operand whose address is a symbol reference or a symbol\n+;;         reference + constant which can be proven to be naturally aligned.\n ;;    c -- Condition code register 33.\n ;;    d -- Any register from 0 to 15.\n ;;    f -- Floating point registers.\n ;;    t -- Access registers 36 and 37.\n+;;    C -- A signed 8-bit constant (-128..127)\n+;;    D -- An unsigned 16-bit constant (0..65535)\n ;;    G -- Const double zero operand\n ;;    I -- An 8-bit constant (0..255).\n ;;    J -- A 12-bit constant (0..4095).\n@@ -102,6 +106,19 @@\n ;;  General constraints for constants.\n ;;\n \n+(define_constraint \"C\"\n+  \"@internal\n+   An 8-bit signed immediate constant (-128..127)\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= -128 && ival <= 127\")))\n+\n+\n+(define_constraint \"D\"\n+  \"An unsigned 16-bit constant (0..65535)\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= 0 && ival <= 65535\")))\n+\n+\n (define_constraint \"G\"\n   \"@internal\n    Const double zero operand\"\n@@ -127,7 +144,6 @@\n        (match_test \"ival >= -32768 && ival <= 32767\")))\n \n \n-\n (define_constraint \"L\"\n   \"Value appropriate as displacement.\n       (0..4095) for short displacement\n@@ -355,7 +371,6 @@\n   (match_test \"s390_mem_constraint (\\\"Q\\\", op)\"))\n \n \n-\n (define_memory_constraint \"R\"\n   \"Memory reference with index register and short displacement\"\n   (match_test \"s390_mem_constraint (\\\"R\\\", op)\"))\n@@ -371,6 +386,27 @@\n   (match_test \"s390_mem_constraint (\\\"T\\\", op)\"))\n \n \n+(define_memory_constraint \"b\"\n+  \"Memory reference whose address is a naturally aligned symbol reference.\"\n+  (match_test \"MEM_P (op)\n+               && s390_check_symref_alignment (XEXP (op, 0),\n+                                               GET_MODE_SIZE (GET_MODE (op)))\"))\n+\n+(define_memory_constraint \"e\"\n+  \"Matches all memory references available on the current architecture\n+level.  This constraint will never be used and using it in an inline\n+assembly is *always* a bug since there is no instruction accepting all\n+those addresses.  It just serves as a placeholder for a generic memory\n+constraint.\"\n+  (match_test \"legitimate_address_p (GET_MODE (op), op, 1)\"))\n+\n+; This defines 'm' as normal memory constraint.  This is only possible\n+; since the standard memory constraint is re-defined in s390.h using\n+; the TARGET_MEM_CONSTRAINT macro.\n+(define_memory_constraint \"m\"\n+  \"Matches the most general memory address for pre-z10 machines.\"\n+  (match_test \"s390_mem_constraint (\\\"R\\\", op)\n+               || s390_mem_constraint (\\\"T\\\", op)\"))\n \n (define_memory_constraint \"AQ\"\n   \"@internal \n@@ -425,7 +461,6 @@\n   (match_test \"s390_mem_constraint (\\\"BT\\\", op)\"))\n \n \n-\n (define_address_constraint \"U\"\n   \"Pointer with short displacement\"\n   (match_test \"s390_mem_constraint (\\\"U\\\", op)\"))"}, {"sha": "ca5d17556a5f9cbee064a3c1a7a03a15e07336df", "filename": "gcc/config/s390/predicates.md", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/963fc8d00baeca7920bc49e5defc53e290495d85/gcc%2Fconfig%2Fs390%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/963fc8d00baeca7920bc49e5defc53e290495d85/gcc%2Fconfig%2Fs390%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fpredicates.md?ref=963fc8d00baeca7920bc49e5defc53e290495d85", "patch": "@@ -1,5 +1,5 @@\n ;; Predicate definitions for S/390 and zSeries.\n-;; Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n+;; Copyright (C) 2005, 2007, 2008 Free Software Foundation, Inc.\n ;; Contributed by Hartmut Penner (hpenner@de.ibm.com) and\n ;;                Ulrich Weigand (uweigand@de.ibm.com).\n ;;\n@@ -110,7 +110,7 @@\n   if (GET_CODE (op) == LABEL_REF)\n     return true;\n   if (GET_CODE (op) == SYMBOL_REF)\n-    return ((SYMBOL_REF_FLAGS (op) & SYMBOL_FLAG_ALIGN1) == 0\n+    return (!SYMBOL_REF_ALIGN1_P (op)\n \t    && SYMBOL_REF_TLS_MODEL (op) == 0\n \t    && (!flag_pic || SYMBOL_REF_LOCAL_P (op)));\n \n@@ -172,6 +172,18 @@\n   return (s390_branch_condition_mask (op) >= 0);\n })\n \n+(define_predicate \"s390_signed_integer_comparison\"\n+  (match_code \"eq, ne, lt, gt, le, ge\")\n+{\n+  return (s390_compare_and_branch_condition_mask (op) >= 0);\n+})\n+\n+(define_predicate \"s390_unsigned_integer_comparison\"\n+  (match_code \"eq, ne, ltu, gtu, leu, geu\")\n+{\n+  return (s390_compare_and_branch_condition_mask (op) >= 0);\n+})\n+\n ;; Return nonzero if OP is a valid comparison operator\n ;; for an ALC condition.\n "}, {"sha": "76f73f9dd2c0b18ae28f4ebda9ac050acaad07f4", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/963fc8d00baeca7920bc49e5defc53e290495d85/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/963fc8d00baeca7920bc49e5defc53e290495d85/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=963fc8d00baeca7920bc49e5defc53e290495d85", "patch": "@@ -1,5 +1,7 @@\n /* Definitions of target machine for GNU compiler, for IBM S/390.\n-   Copyright (C) 2000, 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2002, 2003, 2004, 2005, 2007, 2008 Free\n+   Software Foundation, Inc.\n+\n    Contributed by Hartmut Penner (hpenner@de.ibm.com)\n \n This file is part of GCC.\n@@ -27,7 +29,7 @@ extern int s390_mem_constraint (const char *str, rtx op);\n extern int s390_O_constraint_str (const char c, HOST_WIDE_INT value);\n extern int s390_N_constraint_str (const char *str, HOST_WIDE_INT value);\n extern int s390_float_const_zero_p (rtx value);\n-\n+extern bool s390_check_symref_alignment (rtx addr, HOST_WIDE_INT alignment);\n \n \n /* Declare functions in s390.c.  */\n@@ -51,6 +53,7 @@ extern int s390_const_ok_for_constraint_p (HOST_WIDE_INT, int, const char *);\n extern int s390_const_double_ok_for_constraint_p (rtx, int, const char *);\n extern int s390_single_part (rtx, enum machine_mode, enum machine_mode, int);\n extern unsigned HOST_WIDE_INT s390_extract_part (rtx, enum machine_mode, int);\n+extern bool s390_contiguous_bitmask_p (unsigned HOST_WIDE_INT, int, int *, int *);\n extern bool s390_split_ok_p (rtx, rtx, enum machine_mode, int);\n extern bool s390_overlap_p (rtx, rtx, HOST_WIDE_INT);\n extern bool s390_offset_p (rtx, rtx, rtx);\n@@ -80,6 +83,8 @@ extern enum reg_class s390_secondary_input_reload_class (enum reg_class,\n extern enum reg_class s390_secondary_output_reload_class (enum reg_class,\n \t\t\t\t\t\t\t  enum machine_mode,\n \t\t\t\t\t\t\t  rtx);\n+extern void s390_reload_larl_operand (rtx , rtx , rtx);\n+extern void s390_reload_symref_address (rtx , rtx , rtx , bool);\n extern void s390_expand_plus_operand (rtx, rtx, rtx);\n extern void emit_symbolic_move (rtx *);\n extern void s390_load_address (rtx, rtx);\n@@ -113,6 +118,7 @@ extern void s390_emit_tpf_eh_return (rtx);\n extern bool s390_legitimate_address_without_index_p (rtx);\n extern bool s390_decompose_shift_count (rtx, rtx *, HOST_WIDE_INT *);\n extern int s390_branch_condition_mask (rtx);\n+extern int s390_compare_and_branch_condition_mask (rtx);\n \n #endif /* RTX_CODE */\n "}, {"sha": "5ffbcaef338dacd558fc88c7804ffc5f5d9e6e54", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 355, "deletions": 20, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/963fc8d00baeca7920bc49e5defc53e290495d85/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/963fc8d00baeca7920bc49e5defc53e290495d85/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=963fc8d00baeca7920bc49e5defc53e290495d85", "patch": "@@ -1,8 +1,9 @@\n /* Subroutines used for code generation on IBM S/390 and zSeries\n    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,\n-   2007 Free Software Foundation, Inc.\n+   2007, 2008 Free Software Foundation, Inc.\n    Contributed by Hartmut Penner (hpenner@de.ibm.com) and\n-                  Ulrich Weigand (uweigand@de.ibm.com).\n+                  Ulrich Weigand (uweigand@de.ibm.com) and\n+                  Andreas Krebbel (Andreas.Krebbel@de.ibm.com).\n \n This file is part of GCC.\n \n@@ -1061,13 +1062,50 @@ s390_branch_condition_mask (rtx code)\n     }\n }\n \n+\n+/* Return branch condition mask to implement a compare and branch\n+   specified by CODE.  Return -1 for invalid comparisons.  */\n+\n+int\n+s390_compare_and_branch_condition_mask (rtx code)\n+{\n+  const int CC0 = 1 << 3;\n+  const int CC1 = 1 << 2;\n+  const int CC2 = 1 << 1;\n+\n+  switch (GET_CODE (code))\n+    {\n+    case EQ:\n+      return CC0;\n+    case NE:\n+      return CC1 | CC2;\n+    case LT:\n+    case LTU:\n+      return CC1;\n+    case GT:\n+    case GTU:\n+      return CC2;\n+    case LE:\n+    case LEU:\n+      return CC0 | CC1;\n+    case GE:\n+    case GEU:\n+      return CC0 | CC2;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  return -1;\n+}\n+\n /* If INV is false, return assembler mnemonic string to implement\n    a branch specified by CODE.  If INV is true, return mnemonic\n    for the corresponding inverted branch.  */\n \n static const char *\n s390_branch_condition_mnemonic (rtx code, int inv)\n {\n+  int mask;\n+\n   static const char *const mnemonic[16] =\n     {\n       NULL, \"o\", \"h\", \"nle\",\n@@ -1076,7 +1114,13 @@ s390_branch_condition_mnemonic (rtx code, int inv)\n       \"le\", \"nh\", \"no\", NULL\n     };\n \n-  int mask = s390_branch_condition_mask (code);\n+  if (GET_CODE (XEXP (code, 0)) == REG\n+      && REGNO (XEXP (code, 0)) == CC_REGNUM\n+      && XEXP (code, 1) == const0_rtx)\n+    mask = s390_branch_condition_mask (code);\n+  else\n+    mask = s390_compare_and_branch_condition_mask (code);\n+\n   gcc_assert (mask >= 0);\n \n   if (inv)\n@@ -1153,6 +1197,67 @@ s390_single_part (rtx op,\n   return part == -1 ? -1 : n_parts - 1 - part;\n }\n \n+/* Return true if IN contains a contiguous bitfield in the lower SIZE\n+   bits and no other bits are set in IN.  POS and LENGTH can be used\n+   to obtain the start position and the length of the bitfield.\n+\n+   POS gives the position of the first bit of the bitfield counting\n+   from the lowest order bit starting with zero.  In order to use this\n+   value for S/390 instructions this has to be converted to \"bits big\n+   endian\" style.  */\n+\n+bool\n+s390_contiguous_bitmask_p (unsigned HOST_WIDE_INT in, int size,\n+\t\t\t   int *pos, int *length)\n+{\n+  int tmp_pos = 0;\n+  int tmp_length = 0;\n+  int i;\n+  unsigned HOST_WIDE_INT mask = 1ULL;\n+  bool contiguous = false;\n+\n+  for (i = 0; i < size; mask <<= 1, i++)\n+    {\n+      if (contiguous)\n+\t{\n+\t  if (mask & in)\n+\t    tmp_length++;\n+\t  else\n+\t    break;\n+\t}\n+      else\n+\t{\n+\t  if (mask & in)\n+\t    {\n+\t      contiguous = true;\n+\t      tmp_length++;\n+\t    }\n+\t  else\n+\t    tmp_pos++;\n+\t}\n+    }\n+\n+  if (!tmp_length)\n+    return false;\n+\n+  /* Calculate a mask for all bits beyond the contiguous bits.  */\n+  mask = (-1LL & ~(((1ULL << (tmp_length + tmp_pos - 1)) << 1) - 1));\n+\n+  if (mask & in)\n+    return false;\n+\n+  if (tmp_length + tmp_pos - 1 > size)\n+    return false;\n+\n+  if (length)\n+    *length = tmp_length;\n+\n+  if (pos)\n+    *pos = tmp_pos;\n+\n+  return true;\n+}\n+\n /* Check whether we can (and want to) split a double-word\n    move in mode MODE from SRC to DST into two single-word\n    moves, moving the subword FIRST_SUBWORD first.  */\n@@ -2034,10 +2139,9 @@ s390_mem_constraint (const char *str, rtx op)\n \treturn 0;\n       if (GET_CODE (op) != MEM)\n \treturn 0;\n-      /* Any invalid address here will be fixed up by reload,\n-\t so accept it for the most generic constraint.  */\n-      if (s390_decompose_address (XEXP (op, 0), &addr)\n-\t  && s390_short_displacement (addr.disp))\n+      if (!s390_decompose_address (XEXP (op, 0), &addr))\n+\treturn 0;\n+      if (s390_short_displacement (addr.disp))\n \treturn 0;\n       break;\n \n@@ -2054,10 +2158,9 @@ s390_mem_constraint (const char *str, rtx op)\n     case 'W':\n       if (!TARGET_LONG_DISPLACEMENT)\n \treturn 0;\n-      /* Any invalid address here will be fixed up by reload,\n-\t so accept it for the most generic constraint.  */\n-      if (s390_decompose_address (op, &addr)\n-\t  && s390_short_displacement (addr.disp))\n+      if (!s390_decompose_address (op, &addr))\n+\treturn 0;\n+      if (s390_short_displacement (addr.disp))\n \treturn 0;\n       break;\n \n@@ -2693,6 +2796,132 @@ s390_preferred_reload_class (rtx op, enum reg_class class)\n   return class;\n }\n \n+/* Return true if ADDR is of kind symbol_ref or symbol_ref + const_int\n+   and return these parts in SYMREF and ADDEND.  You can pass NULL in\n+   SYMREF and/or ADDEND if you are not interested in these values.  */\n+\n+static bool\n+s390_symref_operand_p (rtx addr, rtx *symref, HOST_WIDE_INT *addend)\n+{\n+  HOST_WIDE_INT tmpaddend = 0;\n+\n+  if (GET_CODE (addr) == CONST)\n+    addr = XEXP (addr, 0);\n+\n+  if (GET_CODE (addr) == PLUS)\n+    {\n+      if (GET_CODE (XEXP (addr, 0)) == SYMBOL_REF\n+\t  && CONST_INT_P (XEXP (addr, 1)))\n+\t{\n+\t  tmpaddend = INTVAL (XEXP (addr, 1));\n+\t  addr = XEXP (addr, 0);\n+\t}\n+      else\n+\treturn false;\n+    }\n+  else\n+    if (GET_CODE (addr) != SYMBOL_REF)\n+\treturn false;\n+\n+  if (symref)\n+    *symref = addr;\n+  if (addend)\n+    *addend = tmpaddend;\n+\n+  return true;\n+}\n+\n+/* Return true if ADDR is SYMBOL_REF + addend with addend being a\n+   multiple of ALIGNMENT and the SYMBOL_REF being naturally\n+   aligned.  */\n+\n+bool\n+s390_check_symref_alignment (rtx addr, HOST_WIDE_INT alignment)\n+{\n+  HOST_WIDE_INT addend;\n+  rtx symref;\n+\n+  if (!s390_symref_operand_p (addr, &symref, &addend))\n+    return false;\n+\n+  return (!SYMBOL_REF_NOT_NATURALLY_ALIGNED_P (symref)\n+\t  && !(addend & (alignment - 1)));\n+}\n+\n+/* ADDR is moved into REG using larl.  If ADDR isn't a valid larl\n+   operand SCRATCH is used to reload the even part of the address and\n+   adding one.  */\n+\n+void\n+s390_reload_larl_operand (rtx reg, rtx addr, rtx scratch)\n+{\n+  HOST_WIDE_INT addend;\n+  rtx symref;\n+\n+  if (!s390_symref_operand_p (addr, &symref, &addend))\n+    gcc_unreachable ();\n+\n+  if (!(addend & 1))\n+    /* Easy case.  The addend is even so larl will do fine.  */\n+    emit_move_insn (reg, addr);\n+  else\n+    {\n+      /* We can leave the scratch register untouched if the target\n+\t register is a valid base register.  */\n+      if (REGNO (reg) < FIRST_PSEUDO_REGISTER\n+\t  && REGNO_REG_CLASS (REGNO (reg)) == ADDR_REGS)\n+\tscratch = reg;\n+\n+      gcc_assert (REGNO (scratch) < FIRST_PSEUDO_REGISTER);\n+      gcc_assert (REGNO_REG_CLASS (REGNO (scratch)) == ADDR_REGS);\n+\n+      if (addend != 1)\n+\temit_move_insn (scratch,\n+\t\t\tgen_rtx_CONST (Pmode,\n+\t\t\t\t       gen_rtx_PLUS (Pmode, symref,\n+\t\t\t\t\t\t     GEN_INT (addend - 1))));\n+      else\n+\temit_move_insn (scratch, symref);\n+\n+      /* Increment the address using la in order to avoid clobbering cc.  */\n+      emit_move_insn (reg, gen_rtx_PLUS (Pmode, scratch, const1_rtx));\n+    }\n+}\n+\n+/* Generate what is necessary to move between REG and MEM using\n+   SCRATCH.  The direction is given by TOMEM.  */\n+\n+void\n+s390_reload_symref_address (rtx reg, rtx mem, rtx scratch, bool tomem)\n+{\n+  /* Reload might have pulled a constant out of the literal pool.\n+     Force it back in.  */\n+  if (CONST_INT_P (mem) || GET_CODE (mem) == CONST_DOUBLE\n+      || GET_CODE (mem) == CONST)\n+    mem = force_const_mem (GET_MODE (reg), mem);\n+\n+  gcc_assert (MEM_P (mem));\n+\n+  /* For a load from memory we can leave the scratch register\n+     untouched if the target register is a valid base register.  */\n+  if (!tomem\n+      && REGNO (reg) < FIRST_PSEUDO_REGISTER\n+      && REGNO_REG_CLASS (REGNO (reg)) == ADDR_REGS\n+      && GET_MODE (reg) == GET_MODE (scratch))\n+    scratch = reg;\n+\n+  /* Load address into scratch register.  Since we can't have a\n+     secondary reload for a secondary reload we have to cover the case\n+     where larl would need a secondary reload here as well.  */\n+  s390_reload_larl_operand (scratch, XEXP (mem, 0), scratch);\n+\n+  /* Now we can use a standard load/store to do the move.  */\n+  if (tomem)\n+    emit_move_insn (replace_equiv_address (mem, scratch), reg);\n+  else\n+    emit_move_insn (reg, replace_equiv_address (mem, scratch));\n+}\n+\n /* Inform reload about cases where moving X with a mode MODE to a register in\n    CLASS requires an extra scratch or immediate register.  Return the class\n    needed for the immediate register.  */\n@@ -2705,6 +2934,60 @@ s390_secondary_reload (bool in_p, rtx x, enum reg_class class,\n   if (reg_classes_intersect_p (CC_REGS, class))\n     return GENERAL_REGS;\n \n+  if (TARGET_Z10)\n+    {\n+      /* On z10 several optimizer steps may generate larl operands with\n+\t an odd addend.  */\n+      if (in_p\n+\t  && s390_symref_operand_p (x, NULL, NULL)\n+\t  && mode == Pmode\n+\t  && !s390_check_symref_alignment (x, 2))\n+\tsri->icode = ((mode == DImode) ? CODE_FOR_reloaddi_larl_odd_addend_z10\n+\t\t      : CODE_FOR_reloadsi_larl_odd_addend_z10);\n+\n+      /* On z10 we need a scratch register when moving QI, TI or floating\n+\t point mode values from or to a memory location with a SYMBOL_REF\n+\t or if the symref addend of a SI or DI move is not aligned to the\n+\t width of the access.  */\n+      if (MEM_P (x)\n+\t  && s390_symref_operand_p (XEXP (x, 0), NULL, NULL)\n+\t  && (mode == QImode || mode == TImode || FLOAT_MODE_P (mode)\n+\t      || (!TARGET_64BIT && mode == DImode)\n+\t      || ((mode == HImode || mode == SImode || mode == DImode)\n+\t\t  && (!s390_check_symref_alignment (XEXP (x, 0),\n+\t\t\t\t\t\t    GET_MODE_SIZE (mode))))))\n+\t{\n+#define __SECONDARY_RELOAD_CASE(M,m)\t\t\t\t\t\\\n+\t  case M##mode:\t\t\t\t\t\t\t\\\n+\t    if (TARGET_64BIT)\t\t\t\t\t\t\\\n+\t      sri->icode = in_p ? CODE_FOR_reload##m##di_toreg_z10 :\t\\\n+                                  CODE_FOR_reload##m##di_tomem_z10;\t\\\n+\t    else\t\t\t\t\t\t\t\\\n+  \t      sri->icode = in_p ? CODE_FOR_reload##m##si_toreg_z10 :\t\\\n+                                  CODE_FOR_reload##m##si_tomem_z10;\t\\\n+\t  break;\n+\n+\t  switch (GET_MODE (x))\n+\t    {\n+\t      __SECONDARY_RELOAD_CASE (QI, qi);\n+\t      __SECONDARY_RELOAD_CASE (HI, hi);\n+\t      __SECONDARY_RELOAD_CASE (SI, si);\n+\t      __SECONDARY_RELOAD_CASE (DI, di);\n+\t      __SECONDARY_RELOAD_CASE (TI, ti);\n+\t      __SECONDARY_RELOAD_CASE (SF, sf);\n+\t      __SECONDARY_RELOAD_CASE (DF, df);\n+\t      __SECONDARY_RELOAD_CASE (TF, tf);\n+\t      __SECONDARY_RELOAD_CASE (SD, sd);\n+\t      __SECONDARY_RELOAD_CASE (DD, dd);\n+\t      __SECONDARY_RELOAD_CASE (TD, td);\n+\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+#undef __SECONDARY_RELOAD_CASE\n+\t}\n+    }\n+\n   /* We need a scratch register when loading a PLUS expression which\n      is not a legitimate operand of the LOAD ADDRESS instruction.  */\n   if (in_p && s390_plus_operand (x, mode))\n@@ -2811,10 +3094,16 @@ s390_expand_plus_operand (rtx target, rtx src,\n    STRICT specifies whether strict register checking applies.  */\n \n bool\n-legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t      rtx addr, int strict)\n+legitimate_address_p (enum machine_mode mode, rtx addr, int strict)\n {\n   struct s390_address ad;\n+\n+  if (TARGET_Z10\n+      && larl_operand (addr, VOIDmode)\n+      && (mode == VOIDmode\n+\t  || s390_check_symref_alignment (addr, GET_MODE_SIZE (mode))))\n+    return true;\n+\n   if (!s390_decompose_address (addr, &ad))\n     return false;\n \n@@ -4052,14 +4341,31 @@ s390_expand_addcc (enum rtx_code cmp_code, rtx cmp_op0, rtx cmp_op1,\n   return false;\n }\n \n-/* Expand code for the insv template. Return true if successful, false else.  */\n+/* Expand code for the insv template. Return true if successful.  */\n \n-bool \n+bool\n s390_expand_insv (rtx dest, rtx op1, rtx op2, rtx src)\n {\n   int bitsize = INTVAL (op1);\n   int bitpos = INTVAL (op2);\n \n+  /* On z10 we can use the risbg instruction to implement insv.  */\n+  if (TARGET_Z10\n+      && ((GET_MODE (dest) == DImode && GET_MODE (src) == DImode)\n+\t  || (GET_MODE (dest) == SImode && GET_MODE (src) == SImode)))\n+    {\n+      rtx op;\n+      rtx clobber;\n+\n+      op = gen_rtx_SET (GET_MODE(src),\n+\t\t\tgen_rtx_ZERO_EXTRACT (GET_MODE (dest), dest, op1, op2),\n+\t\t\tsrc);\n+      clobber = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, CC_REGNUM));\n+      emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, op, clobber)));\n+\n+      return true;\n+    }\n+\n   /* We need byte alignment.  */\n   if (bitsize % BITS_PER_UNIT)\n     return false;\n@@ -4596,6 +4902,13 @@ print_operand_address (FILE *file, rtx addr)\n {\n   struct s390_address ad;\n \n+  if (s390_symref_operand_p (addr, NULL, NULL))\n+    {\n+      gcc_assert (TARGET_Z10);\n+      output_addr_const (file, addr);\n+      return;\n+    }\n+\n   if (!s390_decompose_address (addr, &ad)\n       || (ad.base && !REGNO_OK_FOR_BASE_P (REGNO (ad.base)))\n       || (ad.indx && !REGNO_OK_FOR_INDEX_P (REGNO (ad.indx))))\n@@ -4629,6 +4942,7 @@ print_operand_address (FILE *file, rtx addr)\n     'Y': print shift count operand.\n \n     'b': print integer X as if it's an unsigned byte.\n+    'c': print integer X as if it's an signed byte.\n     'x': print integer X as if it's an unsigned halfword.\n     'h': print integer X as if it's a signed halfword.\n     'i': print the first nonzero HImode part of X.\n@@ -4774,6 +5088,8 @@ print_operand (FILE *file, rtx x, int code)\n     case CONST_INT:\n       if (code == 'b')\n         fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (x) & 0xff);\n+      else if (code == 'c')\n+        fprintf (file, HOST_WIDE_INT_PRINT_DEC, ((INTVAL (x) & 0xff) ^ 0x80) - 0x80);\n       else if (code == 'x')\n         fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (x) & 0xffff);\n       else if (code == 'h')\n@@ -8563,11 +8879,30 @@ s390_encode_section_info (tree decl, rtx rtl, int first)\n {\n   default_encode_section_info (decl, rtl, first);\n \n-  /* If a variable has a forced alignment to < 2 bytes, mark it with\n-     SYMBOL_FLAG_ALIGN1 to prevent it from being used as LARL operand.  */\n-  if (TREE_CODE (decl) == VAR_DECL\n-      && DECL_USER_ALIGN (decl) && DECL_ALIGN (decl) < 16)\n-    SYMBOL_REF_FLAGS (XEXP (rtl, 0)) |= SYMBOL_FLAG_ALIGN1;\n+  if (TREE_CODE (decl) == VAR_DECL)\n+    {\n+      /* If a variable has a forced alignment to < 2 bytes, mark it\n+\t with SYMBOL_FLAG_ALIGN1 to prevent it from being used as LARL\n+\t operand.  */\n+      if (DECL_USER_ALIGN (decl) && DECL_ALIGN (decl) < 16)\n+\tSYMBOL_REF_FLAGS (XEXP (rtl, 0)) |= SYMBOL_FLAG_ALIGN1;\n+      if (!DECL_SIZE (decl)\n+\t  || !DECL_ALIGN (decl)\n+\t  || !host_integerp (DECL_SIZE (decl), 0)\n+\t  || (DECL_ALIGN (decl) <= 64\n+\t      && DECL_ALIGN (decl) != tree_low_cst (DECL_SIZE (decl), 0)))\n+\tSYMBOL_REF_FLAGS (XEXP (rtl, 0)) |= SYMBOL_FLAG_NOT_NATURALLY_ALIGNED;\n+    }\n+\n+  /* Literal pool references don't have a decl so they are handled\n+     differently here.  We rely on the information in the MEM_ALIGN\n+     entry to decide upon natural alignment.  */\n+  if (MEM_P (rtl)\n+      && GET_CODE (XEXP (rtl, 0)) == SYMBOL_REF\n+      && TREE_CONSTANT_POOL_ADDRESS_P (XEXP (rtl, 0))\n+      && (MEM_ALIGN (rtl) == 0\n+\t  || MEM_ALIGN (rtl) < GET_MODE_BITSIZE (GET_MODE (rtl))))\n+    SYMBOL_REF_FLAGS (XEXP (rtl, 0)) |= SYMBOL_FLAG_NOT_NATURALLY_ALIGNED;\n }\n \n /* Output thunk to FILE that implements a C++ virtual function call (with"}, {"sha": "79286d5a9bc86af0bb03bc29883d83004750a356", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/963fc8d00baeca7920bc49e5defc53e290495d85/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/963fc8d00baeca7920bc49e5defc53e290495d85/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=963fc8d00baeca7920bc49e5defc53e290495d85", "patch": "@@ -1,8 +1,9 @@\n /* Definitions of target machine for GNU compiler, for IBM S/390\n    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,\n-   2007 Free Software Foundation, Inc.\n+   2007, 2008 Free Software Foundation, Inc.\n    Contributed by Hartmut Penner (hpenner@de.ibm.com) and\n                   Ulrich Weigand (uweigand@de.ibm.com).\n+                  Andreas Krebbel (Andreas.Krebbel@de.ibm.com)\n \n This file is part of GCC.\n \n@@ -62,6 +63,10 @@ extern enum processor_flags s390_tune_flags;\n extern enum processor_type s390_arch;\n extern enum processor_flags s390_arch_flags;\n \n+/* These flags indicate that the generated code should run on a cpu\n+   providing the respective hardware facility regardless of the\n+   current cpu mode (ESA or z/Architecture).  */\n+\n #define TARGET_CPU_IEEE_FLOAT \\\n \t(s390_arch_flags & PF_IEEE_FLOAT)\n #define TARGET_CPU_ZARCH \\\n@@ -75,6 +80,10 @@ extern enum processor_flags s390_arch_flags;\n #define TARGET_CPU_Z10 \\\n  \t(s390_arch_flags & PF_Z10)\n \n+/* These flags indicate that the generated code should run on a cpu\n+   providing the respective hardware facility when run in\n+   z/Architecture mode.  */\n+\n #define TARGET_LONG_DISPLACEMENT \\\n        (TARGET_ZARCH && TARGET_CPU_LONG_DISPLACEMENT)\n #define TARGET_EXTIMM \\\n@@ -491,11 +500,14 @@ extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n #define PREFERRED_RELOAD_CLASS(X, CLASS)\t\\\n   s390_preferred_reload_class ((X), (CLASS))\n \n-/* We need secondary memory to move data between GPRs and FPRs.  */\n+/* We need secondary memory to move data between GPRs and FPRs.  With\n+   DFP the ldgr lgdr instructions are available.  But these\n+   instructions do not handle GPR pairs so it is not possible for 31\n+   bit.  */\n #define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE) \\\n  ((CLASS1) != (CLASS2)                                \\\n   && ((CLASS1) == FP_REGS || (CLASS2) == FP_REGS)     \\\n-  && (!TARGET_DFP || GET_MODE_SIZE (MODE) != 8))\n+  && (!TARGET_DFP || !TARGET_64BIT || GET_MODE_SIZE (MODE) != 8))\n \n /* Get_secondary_mem widens its argument to BITS_PER_WORD which loses on 64bit\n    because the movsi and movsf patterns don't handle r/f moves.  */\n@@ -693,6 +705,13 @@ CUMULATIVE_ARGS;\n /* Maximum number of registers that can appear in a valid memory address.  */\n #define MAX_REGS_PER_ADDRESS 2\n \n+/* This definition replaces the formerly used 'm' constraint with a\n+different constraint letter in order to avoid changing semantics of\n+the 'm' constraint when accepting new address formats in\n+legitimate_address_p.  The constraint letter defined here must not be\n+used in insn definitions or inline assemblies.  */\n+#define TARGET_MEM_CONSTRAINT 'e'\n+\n /* S/390 has no mode dependent addresses.  */\n #define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\n \n@@ -959,7 +978,12 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) ((VALUE) = 64, 1)\n \n /* Machine-specific symbol_ref flags.  */\n-#define SYMBOL_FLAG_ALIGN1\t(SYMBOL_FLAG_MACH_DEP << 0)\n+#define SYMBOL_FLAG_ALIGN1\t          (SYMBOL_FLAG_MACH_DEP << 0)\n+#define SYMBOL_REF_ALIGN1_P(X)\t\t\\\n+  ((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_ALIGN1))\n+#define SYMBOL_FLAG_NOT_NATURALLY_ALIGNED (SYMBOL_FLAG_MACH_DEP << 1)\n+#define SYMBOL_REF_NOT_NATURALLY_ALIGNED_P(X) \\\n+  ((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_NOT_NATURALLY_ALIGNED))\n \n /* Check whether integer displacement is in range.  */\n #define DISP_IN_RANGE(d) \\"}, {"sha": "f97e756518f876a39dbce5449ec9bfcef6df0ae6", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 610, "deletions": 159, "changes": 769, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/963fc8d00baeca7920bc49e5defc53e290495d85/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/963fc8d00baeca7920bc49e5defc53e290495d85/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=963fc8d00baeca7920bc49e5defc53e290495d85", "patch": "@@ -1,8 +1,9 @@\n ;;- Machine description for GNU compiler -- S/390 / zSeries version.\n-;;  Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+;;  Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n ;;  Free Software Foundation, Inc.\n ;;  Contributed by Hartmut Penner (hpenner@de.ibm.com) and\n-;;                 Ulrich Weigand (uweigand@de.ibm.com).\n+;;                 Ulrich Weigand (uweigand@de.ibm.com) and\n+;;                 Andreas Krebbel (Andreas.Krebbel@de.ibm.com)\n \n ;; This file is part of GCC.\n \n@@ -38,6 +39,7 @@\n ;;     %Y: print shift count operand.\n ;;  \n ;;     %b: print integer X as if it's an unsigned byte.\n+;;     %c: print integer X as if it's an signed byte.\n ;;     %x: print integer X as if it's an unsigned halfword.\n ;;     %h: print integer X as if it's a signed halfword.\n ;;     %i: print the first nonzero HImode part of X.\n@@ -189,7 +191,7 @@\n ;; Used to determine defaults for length and other attribute values.\n \n (define_attr \"op_type\"\n-  \"NN,E,RR,RRE,RX,RS,RSI,RI,SI,S,SS,SSE,RXE,RSE,RIL,RIE,RXY,RSY,SIY,RRF,RRR\"\n+  \"NN,E,RR,RRE,RX,RS,RSI,RI,SI,S,SS,SSE,RXE,RSE,RIL,RIE,RXY,RSY,SIY,RRF,RRR,SIL,RRS,RIS\"\n   (const_string \"NN\"))\n \n ;; Instruction type attribute used for scheduling.\n@@ -218,8 +220,8 @@\n ;; Length in bytes.\n \n (define_attr \"length\" \"\"\n-  (cond [(eq_attr \"op_type\" \"E,RR\")\t\t      (const_int 2)\n-         (eq_attr \"op_type\" \"RX,RI,RRE,RS,RSI,S,SI\")  (const_int 4)]\n+  (cond [(eq_attr \"op_type\" \"E,RR\")\t\t              (const_int 2)\n+         (eq_attr \"op_type\" \"RX,RI,RRE,RS,RSI,S,SI,RRF,RRR\")  (const_int 4)]\n     (const_int 6)))\n \n \n@@ -286,6 +288,7 @@\n (define_mode_iterator FP_ALL [TF DF SF (TD \"TARGET_HARD_DFP\") (DD \"TARGET_HARD_DFP\") \n                               (SD \"TARGET_HARD_DFP\")])\n (define_mode_iterator FP [TF DF SF (TD \"TARGET_HARD_DFP\") (DD \"TARGET_HARD_DFP\")])\n+(define_mode_iterator FPALL [TF DF SF TD DD SD])\n (define_mode_iterator BFP [TF DF SF])\n (define_mode_iterator DFP [TD DD])\n (define_mode_iterator DFP_ALL [TD DD SD])\n@@ -315,6 +318,7 @@\n ;; This mode iterator allows the integer patterns to be defined from the\n ;; same template.\n (define_mode_iterator INT [(DI \"TARGET_64BIT\") SI HI QI])\n+(define_mode_iterator INTALL [TI DI SI HI QI])\n \n ;; This iterator allows to unify all 'bCOND' expander patterns.\n (define_code_iterator COMPARE [eq ne gt gtu lt ltu ge geu le leu unordered \n@@ -457,7 +461,6 @@\n ;; Maximum unsigned integer that fits in MODE.\n (define_mode_attr max_uint [(HI \"65535\") (QI \"255\")])\n \n-\n ;;\n ;;- Compare instructions.\n ;;\n@@ -543,14 +546,19 @@\n \n (define_insn \"*tstdi_sign\"\n   [(set (reg CC_REGNUM)\n-        (compare (ashiftrt:DI (ashift:DI (subreg:DI (match_operand:SI 0 \"register_operand\" \"d\") 0)\n-\t\t\t\t\t (const_int 32)) (const_int 32))\n-                 (match_operand:DI 1 \"const0_operand\" \"\")))\n-   (set (match_operand:DI 2 \"register_operand\" \"=d\")\n+        (compare\n+          (ashiftrt:DI\n+            (ashift:DI\n+              (subreg:DI (match_operand:SI 0 \"nonimmediate_operand\" \"d,RT\") 0)\n+\t      (const_int 32)) (const_int 32))\n+\t  (match_operand:DI 1 \"const0_operand\" \"\")))\n+   (set (match_operand:DI 2 \"register_operand\" \"=d,d\")\n         (sign_extend:DI (match_dup 0)))]\n   \"s390_match_ccmode(insn, CCSmode) && TARGET_64BIT\"\n-  \"ltgfr\\t%2,%0\"\n-  [(set_attr \"op_type\" \"RRE\")])\n+  \"ltgfr\\t%2,%0\n+   ltgf\\t%2,%0\"\n+  [(set_attr \"op_type\"      \"RRE,RXY\")\n+   (set_attr \"cpu_facility\" \"*,z10\")])\n \n ; ltr, lt, ltgr, ltg\n (define_insn \"*tst<mode>_extimm\"\n@@ -726,90 +734,159 @@\n \n (define_insn \"*cmpdi_ccs_sign\"\n   [(set (reg CC_REGNUM)\n-        (compare (sign_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"d,RT\"))\n-                 (match_operand:DI 0 \"register_operand\" \"d,d\")))]\n+        (compare (sign_extend:DI (match_operand:SI 1 \"nonimmediate_operand\"\n+\t\t\t\t\t\t     \"d,RT,b\"))\n+                 (match_operand:DI 0 \"register_operand\" \"d, d,d\")))]\n   \"s390_match_ccmode(insn, CCSRmode) && TARGET_64BIT\"\n   \"@\n    cgfr\\t%0,%1\n-   cgf\\t%0,%1\"\n-  [(set_attr \"op_type\" \"RRE,RXY\")])\n+   cgf\\t%0,%1\n+   cgfrl\\t%0,%1\"\n+  [(set_attr \"op_type\"      \"RRE,RXY,RIL\")\n+   (set_attr \"cpu_facility\" \"*,*,z10\")\n+   (set_attr \"type\"         \"*,*,larl\")])\n \n (define_insn \"*cmpsi_ccs_sign\"\n   [(set (reg CC_REGNUM)\n-        (compare (sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"R,T\"))\n-                 (match_operand:SI 0 \"register_operand\" \"d,d\")))]\n+        (compare (sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"R,T,b\"))\n+                 (match_operand:SI 0 \"register_operand\" \"d,d,d\")))]\n   \"s390_match_ccmode(insn, CCSRmode)\"\n   \"@\n    ch\\t%0,%1\n-   chy\\t%0,%1\"\n-  [(set_attr \"op_type\" \"RX,RXY\")])\n+   chy\\t%0,%1\n+   chrl\\t%0,%1\"\n+  [(set_attr \"op_type\"      \"RX,RXY,RIL\")\n+   (set_attr \"cpu_facility\" \"*,*,z10\")\n+   (set_attr \"type\"         \"*,*,larl\")])\n+\n+(define_insn \"*cmphi_ccs_z10\"\n+  [(set (reg CC_REGNUM)\n+        (compare (match_operand:HI 0 \"s_operand\"         \"Q\")\n+                 (match_operand:HI 1 \"immediate_operand\" \"K\")))]\n+  \"s390_match_ccmode(insn, CCSmode) && TARGET_Z10\"\n+  \"chhsi\\t%0,%1\"\n+  [(set_attr \"op_type\" \"SIL\")])\n+\n+(define_insn \"*cmpdi_ccs_signhi_rl\"\n+  [(set (reg CC_REGNUM)\n+\t(compare (sign_extend:DI (match_operand:HI 1 \"memory_operand\" \"RT,b\"))\n+\t\t (match_operand:GPR 0 \"register_operand\"  \"d,d\")))]\n+  \"s390_match_ccmode(insn, CCSRmode) && TARGET_Z10\"\n+  \"@\n+   cgh\\t%0,%1\n+   cghrl\\t%0,%1\"\n+  [(set_attr \"op_type\" \"RXY,RIL\")\n+   (set_attr \"type\"    \"*,larl\")])\n \n-; cr, chi, cfi, c, cy, cgr, cghi, cgfi, cg\n+; cr, chi, cfi, c, cy, cgr, cghi, cgfi, cg, chsi, cghsi, crl, cgrl\n (define_insn \"*cmp<mode>_ccs\"\n   [(set (reg CC_REGNUM)\n-        (compare (match_operand:GPR 0 \"register_operand\" \"d,d,d,d,d\")\n-                 (match_operand:GPR 1 \"general_operand\" \"d,K,Os,R,T\")))]\n+        (compare (match_operand:GPR 0 \"nonimmediate_operand\"\n+                                      \"d,d,Q, d,d,d,d\")\n+                 (match_operand:GPR 1 \"general_operand\"\n+                                      \"d,K,K,Os,R,T,b\")))]\n   \"s390_match_ccmode(insn, CCSmode)\"\n   \"@\n    c<g>r\\t%0,%1\n    c<g>hi\\t%0,%h1\n+   c<g>hsi\\t%0,%h1\n    c<g>fi\\t%0,%1\n    c<g>\\t%0,%1\n-   c<y>\\t%0,%1\"\n-  [(set_attr \"op_type\" \"RR<E>,RI,RIL,RX<Y>,RXY\")])\n+   c<y>\\t%0,%1\n+   c<g>rl\\t%0,%1\"\n+  [(set_attr \"op_type\" \"RR<E>,RI,SIL,RIL,RX<Y>,RXY,RIL\")\n+   (set_attr \"cpu_facility\" \"*,*,z10,extimm,*,*,z10\")\n+   (set_attr \"type\" \"*,*,*,*,*,*,larl\")])\n \n \n ; Compare (unsigned) instructions\n \n+(define_insn \"*cmpsi_ccu_zerohi_rlsi\"\n+  [(set (reg CC_REGNUM)\n+ \t(compare (zero_extend:SI (mem:HI (match_operand:SI 1\n+\t\t\t\t\t  \"larl_operand\" \"X\")))\n+\t\t (match_operand:SI 0 \"register_operand\" \"d\")))]\n+  \"s390_match_ccmode(insn, CCURmode) && TARGET_Z10\"\n+  \"clhrl\\t%0,%1\"\n+  [(set_attr \"op_type\" \"RIL\")\n+   (set_attr \"type\"    \"larl\")])\n+\n+; clhrl, clghrl\n+(define_insn \"*cmp<GPR:mode>_ccu_zerohi_rldi\"\n+  [(set (reg CC_REGNUM)\n+ \t(compare (zero_extend:GPR (mem:HI (match_operand:DI 1\n+\t\t\t\t\t  \"larl_operand\" \"X\")))\n+\t\t (match_operand:GPR 0 \"register_operand\" \"d\")))]\n+  \"s390_match_ccmode(insn, CCURmode) && TARGET_Z10\"\n+  \"cl<g>hrl\\t%0,%1\"\n+  [(set_attr \"op_type\" \"RIL\")\n+   (set_attr \"type\"    \"larl\")])\n+\n (define_insn \"*cmpdi_ccu_zero\"\n   [(set (reg CC_REGNUM)\n-        (compare (zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"d,RT\"))\n-                 (match_operand:DI 0 \"register_operand\" \"d,d\")))]\n+        (compare (zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\"\n+                                                        \"d,RT,b\"))\n+                 (match_operand:DI 0 \"register_operand\" \"d, d,d\")))]\n   \"s390_match_ccmode (insn, CCURmode) && TARGET_64BIT\"\n   \"@\n    clgfr\\t%0,%1\n-   clgf\\t%0,%1\"\n-  [(set_attr \"op_type\" \"RRE,RXY\")])\n+   clgf\\t%0,%1\n+   clgfrl\\t%0,%1\"\n+  [(set_attr \"op_type\"      \"RRE,RXY,RIL\")\n+   (set_attr \"cpu_facility\" \"*,*,z10\")\n+   (set_attr \"type\"         \"*,*,larl\")])\n \n (define_insn \"*cmpdi_ccu\"\n   [(set (reg CC_REGNUM)\n-        (compare (match_operand:DI 0 \"nonimmediate_operand\" \"d,d,d,Q,BQ\")\n-                 (match_operand:DI 1 \"general_operand\" \"d,Op,RT,BQ,Q\")))]\n+        (compare (match_operand:DI 0 \"nonimmediate_operand\"\n+                                     \"d, d,d,Q, d, Q,BQ\")\n+                 (match_operand:DI 1 \"general_operand\"\n+                                     \"d,Op,b,D,RT,BQ,Q\")))]\n   \"s390_match_ccmode (insn, CCUmode) && TARGET_64BIT\"\n   \"@\n    clgr\\t%0,%1\n    clgfi\\t%0,%1\n+   clgrl\\t%0,%1\n+   clghsi\\t%0,%x1\n    clg\\t%0,%1\n    #\n    #\"\n-  [(set_attr \"op_type\" \"RRE,RIL,RXY,SS,SS\")])\n+  [(set_attr \"op_type\" \"RRE,RIL,RIL,SIL,RXY,SS,SS\")\n+   (set_attr \"cpu_facility\" \"*,extimm,z10,z10,*,*,*\")\n+   (set_attr \"type\"         \"*,*,larl,*,*,*,*\")])\n \n (define_insn \"*cmpsi_ccu\"\n   [(set (reg CC_REGNUM)\n-        (compare (match_operand:SI 0 \"nonimmediate_operand\" \"d,d,d,d,Q,BQ\")\n-                 (match_operand:SI 1 \"general_operand\" \"d,Os,R,T,BQ,Q\")))]\n+        (compare (match_operand:SI 0 \"nonimmediate_operand\" \"d, d,d,Q,d,d, Q,BQ\")\n+                 (match_operand:SI 1 \"general_operand\"      \"d,Os,b,D,R,T,BQ, Q\")))]\n   \"s390_match_ccmode (insn, CCUmode)\"\n   \"@\n    clr\\t%0,%1\n    clfi\\t%0,%o1\n+   clrl\\t%0,%1\n+   clfhsi\\t%0,%x1\n    cl\\t%0,%1\n    cly\\t%0,%1\n    #\n    #\"\n-  [(set_attr \"op_type\" \"RR,RIL,RX,RXY,SS,SS\")])\n+  [(set_attr \"op_type\" \"RR,RIL,RIL,SIL,RX,RXY,SS,SS\")\n+   (set_attr \"cpu_facility\" \"*,extimm,z10,z10,*,*,*,*\")\n+   (set_attr \"type\"         \"*,*,larl,*,*,*,*,*\")])\n \n (define_insn \"*cmphi_ccu\"\n   [(set (reg CC_REGNUM)\n-        (compare (match_operand:HI 0 \"nonimmediate_operand\" \"d,d,Q,BQ\")\n-                 (match_operand:HI 1 \"general_operand\" \"Q,S,BQ,Q\")))]\n+        (compare (match_operand:HI 0 \"nonimmediate_operand\" \"d,d,Q,Q,BQ\")\n+                 (match_operand:HI 1 \"general_operand\"      \"Q,S,D,BQ,Q\")))]\n   \"s390_match_ccmode (insn, CCUmode)\n    && !register_operand (operands[1], HImode)\"\n   \"@\n    clm\\t%0,3,%S1\n    clmy\\t%0,3,%S1\n+   clhhsi\\t%0,%1\n    #\n    #\"\n-  [(set_attr \"op_type\" \"RS,RSY,SS,SS\")])\n+  [(set_attr \"op_type\" \"RS,RSY,SIL,SS,SS\")\n+   (set_attr \"cpu_facility\" \"*,*,z10,*,*\")])\n \n (define_insn \"*cmpqi_ccu\"\n   [(set (reg CC_REGNUM)\n@@ -885,6 +962,59 @@\n    [(set_attr \"op_type\" \"RRE,RXE\")\n     (set_attr \"type\"  \"fsimp<bfp>\")])\n \n+\n+; Compare and Branch instructions\n+\n+; cij, cgij, crj, cgrj, cfi, cgfi, cr, cgr\n+(define_insn \"*cmp_and_br_signed_<mode>\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"s390_signed_integer_comparison\"\n+\t\t\t[(match_operand:GPR 1 \"register_operand\"  \"d,d\")\n+\t\t\t (match_operand:GPR 2 \"nonmemory_operand\" \"d,C\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_Z10\"\n+{\n+  if (get_attr_length (insn) == 6)\n+    return which_alternative ?\n+      \"c<g>ij%C0\\t%1,%c2,%l3\" : \"c<g>rj%C0\\t%1,%2,%l3\";\n+  else\n+    return which_alternative ?\n+      \"c<g>fi\\t%1,%c2\\;jg%C0\\t%l3\" : \"c<g>r\\t%1,%2\\;jg%C0\\t%l3\";\n+}\n+  [(set_attr \"op_type\" \"RIE\")\n+   (set_attr \"type\"    \"branch\")\n+   (set (attr \"length\")\n+        (if_then_else (lt (abs (minus (pc) (match_dup 3))) (const_int 60000))\n+                      (const_int 6) (const_int 12)))]) ; 8 byte for cr/jg\n+                                                       ; 10 byte for cgr/jg\n+\n+; clij, clgij, clrj, clgrj, clfi, clgfi, clr, clgr\n+(define_insn \"*cmp_and_br_unsigned_<mode>\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"s390_unsigned_integer_comparison\"\n+\t\t\t[(match_operand:GPR 1 \"register_operand\"  \"d,d\")\n+\t\t\t (match_operand:GPR 2 \"nonmemory_operand\" \"d,I\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_Z10\"\n+{\n+  if (get_attr_length (insn) == 6)\n+    return which_alternative ?\n+      \"cl<g>ij%C0\\t%1,%b2,%l3\" : \"cl<g>rj%C0\\t%1,%2,%l3\";\n+  else\n+    return which_alternative ?\n+      \"cl<g>fi\\t%1,%b2\\;jg%C0\\t%l3\" : \"cl<g>r\\t%1,%2\\;jg%C0\\t%l3\";\n+}\n+  [(set_attr \"op_type\" \"RIE\")\n+   (set_attr \"type\"    \"branch\")\n+   (set (attr \"length\")\n+        (if_then_else (lt (abs (minus (pc) (match_dup 3))) (const_int 60000))\n+                      (const_int 6) (const_int 12)))]) ; 8 byte for clr/jg\n+                                                       ; 10 byte for clgr/jg\n+\n ;;\n ;;- Move instructions.\n ;;\n@@ -951,6 +1081,60 @@\n ; Patterns used for secondary reloads\n ;\n \n+; z10 provides move instructions accepting larl memory operands.\n+; Unfortunately there is no such variant for QI, TI and FP mode moves.\n+; These patterns are also used for unaligned SI and DI accesses.\n+\n+(define_expand \"reload<INTALL:mode><P:mode>_tomem_z10\"\n+  [(parallel [(match_operand:INTALL 0 \"memory_operand\"   \"\")\n+\t      (match_operand:INTALL 1 \"register_operand\" \"=d\")\n+\t      (match_operand:P 2 \"register_operand\" \"=&a\")])]\n+  \"TARGET_Z10\"\n+{\n+  s390_reload_symref_address (operands[1], operands[0], operands[2], 1);\n+  DONE;\n+})\n+\n+(define_expand \"reload<INTALL:mode><P:mode>_toreg_z10\"\n+  [(parallel [(match_operand:INTALL 0 \"register_operand\" \"=d\")\n+\t      (match_operand:INTALL 1 \"memory_operand\"   \"\")\n+\t      (match_operand:P 2 \"register_operand\" \"=a\")])]\n+  \"TARGET_Z10\"\n+{\n+  s390_reload_symref_address (operands[0], operands[1], operands[2], 0);\n+  DONE;\n+})\n+\n+(define_expand \"reload<FPALL:mode><P:mode>_tomem_z10\"\n+  [(parallel [(match_operand:FPALL 0 \"memory_operand\"   \"\")\n+\t      (match_operand:FPALL 1 \"register_operand\" \"=d\")\n+\t      (match_operand:P 2 \"register_operand\" \"=&a\")])]\n+  \"TARGET_Z10\"\n+{\n+  s390_reload_symref_address (operands[1], operands[0], operands[2], 1);\n+  DONE;\n+})\n+\n+(define_expand \"reload<FPALL:mode><P:mode>_toreg_z10\"\n+  [(parallel [(match_operand:FPALL 0 \"register_operand\" \"=d\")\n+\t      (match_operand:FPALL 1 \"memory_operand\"   \"\")\n+\t      (match_operand:P 2 \"register_operand\" \"=a\")])]\n+  \"TARGET_Z10\"\n+{\n+  s390_reload_symref_address (operands[0], operands[1], operands[2], 0);\n+  DONE;\n+})\n+\n+(define_expand \"reload<P:mode>_larl_odd_addend_z10\"\n+  [(parallel [(match_operand:P 0 \"register_operand\" \"=d\")\n+\t      (match_operand:P 1 \"larl_operand\"     \"\")\n+\t      (match_operand:P 2 \"register_operand\" \"=a\")])]\n+  \"TARGET_Z10\"\n+{\n+  s390_reload_larl_operand (operands[0], operands[1], operands[2]);\n+  DONE;\n+})\n+\n ; Handles loading a PLUS (load address) expression\n \n (define_expand \"reload<mode>_plus\"\n@@ -1020,11 +1204,11 @@\n \n (define_insn \"*movdi_64\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\"\n-                            \"=d,d,d,d,d,d,d,d,f,d,d,d,d,\n-                             RT,!*f,!*f,!*f,!R,!T,d,t,Q,t,?Q\")\n+                            \"=d,d,d,d,d,d,d,d,f,d,d,d,d,d,\n+                             RT,!*f,!*f,!*f,!R,!T,b,Q,d,t,Q,t,?Q\")\n         (match_operand:DI 1 \"general_operand\"\n-                            \"K,N0HD0,N1HD0,N2HD0,N3HD0,Os,N0SD0,N1SD0,d,f,L,d,RT,\n-                             d,*f,R,T,*f,*f,t,d,t,Q,?Q\"))]\n+                            \"K,N0HD0,N1HD0,N2HD0,N3HD0,Os,N0SD0,N1SD0,d,f,L,b,d,RT,\n+                             d,*f,R,T,*f,*f,d,K,t,d,t,Q,?Q\"))]\n   \"TARGET_64BIT\"\n   \"@\n    lghi\\t%0,%h1\n@@ -1038,6 +1222,7 @@\n    ldgr\\t%0,%1\n    lgdr\\t%0,%1\n    lay\\t%0,%a1\n+   lgrl\\t%0,%1\n    lgr\\t%0,%1\n    lg\\t%0,%1\n    stg\\t%1,%0\n@@ -1046,17 +1231,21 @@\n    ldy\\t%0,%1\n    std\\t%1,%0\n    stdy\\t%1,%0\n+   stgrl\\t%1,%0\n+   mvghi\\t%0,%1\n    #\n    #\n    stam\\t%1,%N1,%S0\n    lam\\t%0,%N0,%S1\n    #\"\n-  [(set_attr \"op_type\" \"RI,RI,RI,RI,RI,RIL,RIL,RIL,RRE,RRE,RXY,RRE,RXY,RXY,\n-                        RR,RX,RXY,RX,RXY,*,*,RS,RS,SS\")\n-   (set_attr \"type\" \"*,*,*,*,*,*,*,*,floaddf,floaddf,la,lr,load,store,\n-                     floaddf,floaddf,floaddf,fstoredf,fstoredf,*,*,*,*,*\")\n+  [(set_attr \"op_type\" \"RI,RI,RI,RI,RI,RIL,RIL,RIL,RRE,RRE,RXY,RIL,RRE,RXY,\n+                        RXY,RR,RX,RXY,RX,RXY,RIL,SIL,*,*,RS,RS,SS\")\n+   (set_attr \"type\" \"*,*,*,*,*,*,*,*,floaddf,floaddf,la,larl,lr,load,store,\n+                     floaddf,floaddf,floaddf,fstoredf,fstoredf,larl,*,*,*,\n+                     *,*,*\")\n    (set_attr \"cpu_facility\" \"*,*,*,*,*,extimm,extimm,extimm,dfp,dfp,longdisp,\n-                             *,*,*,*,*,longdisp,*,longdisp,*,*,*,*,*\")])\n+                             z10,*,*,*,*,*,longdisp,*,longdisp,\n+                             z10,z10,*,*,*,*,*\")])\n \n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -1092,8 +1281,10 @@\n    s390_split_access_reg (operands[0], &operands[3], &operands[4]);\")\n \n (define_insn \"*movdi_31\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,Q,S,d,o,!*f,!*f,!*f,!R,!T,Q\")\n-        (match_operand:DI 1 \"general_operand\" \"Q,S,d,d,dPRT,d,*f,R,T,*f,*f,Q\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\"\n+                            \"=d,d,Q,S,d   ,o,!*f,!*f,!*f,!R,!T,Q,d\")\n+        (match_operand:DI 1 \"general_operand\"\n+                            \" Q,S,d,d,dPRT,d, *f,  R,  T,*f,*f,Q,b\"))]\n   \"!TARGET_64BIT\"\n   \"@\n    lm\\t%0,%N0,%S1\n@@ -1107,9 +1298,26 @@\n    ldy\\t%0,%1\n    std\\t%1,%0\n    stdy\\t%1,%0\n+   #\n    #\"\n-  [(set_attr \"op_type\" \"RS,RSY,RS,RSY,*,*,RR,RX,RXY,RX,RXY,SS\")\n-   (set_attr \"type\" \"lm,lm,stm,stm,*,*,floaddf,floaddf,floaddf,fstoredf,fstoredf,*\")])\n+  [(set_attr \"op_type\" \"RS,RSY,RS,RSY,*,*,RR,RX,RXY,RX,RXY,SS,*\")\n+   (set_attr \"type\" \"lm,lm,stm,stm,*,*,floaddf,floaddf,floaddf,fstoredf,fstoredf,*,*\")\n+   (set_attr \"cpu_facility\" \"*,*,*,*,*,*,*,*,*,*,*,*,z10\")])\n+\n+; For a load from a symbol ref we can use one of the target registers\n+; together with larl to load the address.\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+        (match_operand:DI 1 \"memory_operand\" \"\"))]\n+  \"!TARGET_64BIT && reload_completed && TARGET_Z10\n+   && larl_operand (XEXP (operands[1], 0), SImode)\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 0) (match_dup 1))]\n+{\n+  operands[2] = operand_subword (operands[0], 1, 0, DImode);\n+  operands[3] = XEXP (operands[1], 0);\n+  operands[1] = replace_equiv_address (operands[1], operands[2]);\n+})\n \n (define_split\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n@@ -1227,16 +1435,17 @@\n \n (define_insn \"*movsi_zarch\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\"\n-\t\t\t    \"=d,d,d,d,d,d,d,d,R,T,!*f,!*f,!*f,!R,!T,d,t,Q,t,?Q\")\n+\t\t\t    \"=d,d,d,d,d,d,d,d,d,R,T,!*f,!*f,!*f,!R,!T,d,t,Q,b,Q,t,?Q\")\n         (match_operand:SI 1 \"general_operand\"\n-\t\t\t    \"K,N0HS0,N1HS0,Os,L,d,R,T,d,d,*f,R,T,*f,*f,t,d,t,Q,?Q\"))]\n+\t\t\t    \"K,N0HS0,N1HS0,Os,L,b,d,R,T,d,d,*f,R,T,*f,*f,t,d,t,d,K,Q,?Q\"))]\n   \"TARGET_ZARCH\"\n   \"@\n    lhi\\t%0,%h1\n    llilh\\t%0,%i1\n    llill\\t%0,%i1\n    iilf\\t%0,%o1\n    lay\\t%0,%a1\n+   lrl\\t%0,%1\n    lr\\t%0,%1\n    l\\t%0,%1\n    ly\\t%0,%1\n@@ -1250,12 +1459,16 @@\n    ear\\t%0,%1\n    sar\\t%0,%1\n    stam\\t%1,%1,%S0\n+   strl\\t%1,%0\n+   mvhi\\t%0,%1\n    lam\\t%0,%0,%S1\n    #\"\n-  [(set_attr \"op_type\" \"RI,RI,RI,RIL,RXY,RR,RX,RXY,RX,RXY,\n-                        RR,RX,RXY,RX,RXY,RRE,RRE,RS,RS,SS\")\n-   (set_attr \"type\" \"*,*,*,*,la,lr,load,load,store,store,\n-                     floadsf,floadsf,floadsf,fstoresf,fstoresf,*,*,*,*,*\")])\n+  [(set_attr \"op_type\" \"RI,RI,RI,RIL,RXY,RIL,RR,RX,RXY,RX,RXY,\n+                        RR,RX,RXY,RX,RXY,RRE,RRE,RS,RIL,SIL,RS,SS\")\n+   (set_attr \"type\" \"*,*,*,*,la,larl,lr,load,load,store,store,\n+                     floadsf,floadsf,floadsf,fstoresf,fstoresf,*,*,*,larl,*,*,*\")\n+   (set_attr \"cpu_facility\" \"*,*,*,extimm,longdisp,z10,*,*,longdisp,*,longdisp,\n+                             *,*,longdisp,*,longdisp,*,*,*,z10,z10,*,*\")])\n \n (define_insn \"*movsi_esa\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,R,!*f,!*f,!R,d,t,Q,t,?Q\")\n@@ -1381,19 +1594,23 @@\n })\n \n (define_insn \"*movhi\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,d,d,d,R,T,?Q\")\n-        (match_operand:HI 1 \"general_operand\" \"d,n,R,T,d,d,?Q\"))]\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,R,T,b,Q,?Q\")\n+        (match_operand:HI 1 \"general_operand\"      \" d,n,R,T,b,d,d,d,K,?Q\"))]\n   \"\"\n   \"@\n    lr\\t%0,%1\n    lhi\\t%0,%h1\n    lh\\t%0,%1\n    lhy\\t%0,%1\n+   lhrl\\t%0,%1\n    sth\\t%1,%0\n    sthy\\t%1,%0\n+   sthrl\\t%1,%0\n+   mvhhi\\t%0,%1\n    #\"\n-  [(set_attr \"op_type\" \"RR,RI,RX,RXY,RX,RXY,SS\")\n-   (set_attr \"type\" \"lr,*,*,*,store,store,*\")])\n+  [(set_attr \"op_type\"      \"RR,RI,RX,RXY,RIL,RX,RXY,RIL,SIL,SS\")\n+   (set_attr \"type\"         \"lr,*,*,*,larl,store,store,store,*,*\")\n+   (set_attr \"cpu_facility\" \"*,*,*,*,z10,*,*,z10,z10,*\")])\n \n (define_peephole2\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n@@ -2014,6 +2231,17 @@\n ;; String instructions.\n ;;\n \n+(define_insn \"*execute_rl\"\n+  [(match_parallel 0 \"\"\n+    [(unspec [(match_operand 1    \"register_operand\" \"a\")\n+\t      (match_operand 2    \"\" \"\")\n+              (match_operand:SI 3 \"larl_operand\" \"X\")] UNSPEC_EXECUTE)])]\n+  \"TARGET_Z10 && GET_MODE_CLASS (GET_MODE (operands[1])) == MODE_INT\n+   && GET_MODE_SIZE (GET_MODE (operands[1])) <= UNITS_PER_WORD\"\n+  \"exrl\\t%1,%3\"\n+  [(set_attr \"op_type\" \"RIL\")\n+   (set_attr \"type\"    \"cs\")])\n+\n (define_insn \"*execute\"\n   [(match_parallel 0 \"\"\n     [(unspec [(match_operand 1 \"register_operand\" \"a\")\n@@ -2158,9 +2386,9 @@\n ;\n \n (define_expand \"movmem<mode>\"\n-  [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n-        (match_operand:BLK 1 \"memory_operand\" \"\"))\n-   (use (match_operand:GPR 2 \"general_operand\" \"\"))\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"\")   ; destination\n+        (match_operand:BLK 1 \"memory_operand\" \"\"))  ; source\n+   (use (match_operand:GPR 2 \"general_operand\" \"\")) ; count\n    (match_operand 3 \"\" \"\")]\n   \"\"\n   \"s390_expand_movmem (operands[0], operands[1], operands[2]); DONE;\")\n@@ -2179,15 +2407,16 @@\n   \"operands[3] = gen_rtx_SCRATCH (Pmode);\")\n \n (define_insn \"*movmem_short\"\n-  [(set (match_operand:BLK 0 \"memory_operand\" \"=Q,Q,Q\")\n-        (match_operand:BLK 1 \"memory_operand\" \"Q,Q,Q\"))\n-   (use (match_operand 2 \"nonmemory_operand\" \"n,a,a\"))\n-   (use (match_operand 3 \"immediate_operand\" \"X,R,X\"))\n-   (clobber (match_scratch 4 \"=X,X,&a\"))]\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"=Q,Q,Q,Q\")\n+        (match_operand:BLK 1 \"memory_operand\" \"Q,Q,Q,Q\"))\n+   (use (match_operand 2 \"nonmemory_operand\" \"n,a,a,a\"))\n+   (use (match_operand 3 \"immediate_operand\" \"X,R,X,X\"))\n+   (clobber (match_scratch 4 \"=X,X,X,&a\"))]\n   \"(GET_MODE (operands[2]) == Pmode || GET_MODE (operands[2]) == VOIDmode)\n    && GET_MODE (operands[4]) == Pmode\"\n   \"#\"\n-  [(set_attr \"type\" \"cs\")])\n+  [(set_attr \"type\"         \"cs\")\n+   (set_attr \"cpu_facility\" \"*,*,z10,*\")])\n \n (define_split\n   [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n@@ -2215,6 +2444,20 @@\n      (use (const_int 1))])]\n   \"\")\n \n+(define_split\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+        (match_operand:BLK 1 \"memory_operand\" \"\"))\n+   (use (match_operand 2 \"register_operand\" \"\"))\n+   (use (const:BLK (unspec:BLK [(const_int 0)] UNSPEC_INSN)))\n+   (clobber (scratch))]\n+  \"TARGET_Z10 && reload_completed\"\n+  [(parallel\n+    [(unspec [(match_dup 2) (const_int 0)\n+              (label_ref (match_dup 3))] UNSPEC_EXECUTE)\n+     (set (match_dup 0) (match_dup 1))\n+     (use (const_int 1))])]\n+  \"operands[3] = gen_label_rtx ();\")\n+\n (define_split\n   [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n         (match_operand:BLK 1 \"memory_operand\" \"\"))\n@@ -2358,16 +2601,17 @@\n   \"operands[2] = gen_rtx_SCRATCH (Pmode);\")\n \n (define_insn \"*clrmem_short\"\n-  [(set (match_operand:BLK 0 \"memory_operand\" \"=Q,Q,Q\")\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"=Q,Q,Q,Q\")\n         (const_int 0))\n-   (use (match_operand 1 \"nonmemory_operand\" \"n,a,a\"))\n-   (use (match_operand 2 \"immediate_operand\" \"X,R,X\"))\n-   (clobber (match_scratch 3 \"=X,X,&a\"))\n+   (use (match_operand 1 \"nonmemory_operand\" \"n,a,a,a\"))\n+   (use (match_operand 2 \"immediate_operand\" \"X,R,X,X\"))\n+   (clobber (match_scratch 3 \"=X,X,X,&a\"))\n    (clobber (reg:CC CC_REGNUM))]\n   \"(GET_MODE (operands[1]) == Pmode || GET_MODE (operands[1]) == VOIDmode)\n    && GET_MODE (operands[3]) == Pmode\"\n   \"#\"\n-  [(set_attr \"type\" \"cs\")])\n+  [(set_attr \"type\" \"cs\")\n+   (set_attr \"cpu_facility\" \"*,*,z10,*\")])\n \n (define_split\n   [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n@@ -2399,6 +2643,22 @@\n      (clobber (reg:CC CC_REGNUM))])]\n   \"\")\n \n+(define_split\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+        (const_int 0))\n+   (use (match_operand 1 \"register_operand\" \"\"))\n+   (use (const:BLK (unspec:BLK [(const_int 0)] UNSPEC_INSN)))\n+   (clobber (scratch))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_Z10 && reload_completed\"\n+  [(parallel\n+    [(unspec [(match_dup 1) (const_int 0)\n+              (label_ref (match_dup 3))] UNSPEC_EXECUTE)\n+     (set (match_dup 0) (const_int 0))\n+     (use (const_int 1))\n+     (clobber (reg:CC CC_REGNUM))])]\n+  \"operands[3] = gen_label_rtx ();\")\n+\n (define_split\n   [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n         (const_int 0))\n@@ -2499,15 +2759,16 @@\n \n (define_insn \"*cmpmem_short\"\n   [(set (reg:CCU CC_REGNUM)\n-        (compare:CCU (match_operand:BLK 0 \"memory_operand\" \"Q,Q,Q\")\n-                     (match_operand:BLK 1 \"memory_operand\" \"Q,Q,Q\")))\n-   (use (match_operand 2 \"nonmemory_operand\" \"n,a,a\"))\n-   (use (match_operand 3 \"immediate_operand\" \"X,R,X\"))\n-   (clobber (match_scratch 4 \"=X,X,&a\"))]\n+        (compare:CCU (match_operand:BLK 0 \"memory_operand\" \"Q,Q,Q,Q\")\n+                     (match_operand:BLK 1 \"memory_operand\" \"Q,Q,Q,Q\")))\n+   (use (match_operand 2 \"nonmemory_operand\" \"n,a,a,a\"))\n+   (use (match_operand 3 \"immediate_operand\" \"X,R,X,X\"))\n+   (clobber (match_scratch 4 \"=X,X,X,&a\"))]\n   \"(GET_MODE (operands[2]) == Pmode || GET_MODE (operands[2]) == VOIDmode)\n    && GET_MODE (operands[4]) == Pmode\"\n   \"#\"\n-  [(set_attr \"type\" \"cs\")])\n+  [(set_attr \"type\" \"cs\")\n+   (set_attr \"cpu_facility\" \"*,*,z10,*\")])\n \n (define_split\n   [(set (reg:CCU CC_REGNUM)\n@@ -2537,6 +2798,21 @@\n      (use (const_int 1))])]\n   \"\")\n \n+(define_split\n+  [(set (reg:CCU CC_REGNUM)\n+        (compare:CCU (match_operand:BLK 0 \"memory_operand\" \"\")\n+                     (match_operand:BLK 1 \"memory_operand\" \"\")))\n+   (use (match_operand 2 \"register_operand\" \"\"))\n+   (use (const:BLK (unspec:BLK [(const_int 0)] UNSPEC_INSN)))\n+   (clobber (scratch))]\n+  \"TARGET_Z10 && reload_completed\"\n+  [(parallel\n+    [(unspec [(match_dup 2) (const_int 0)\n+              (label_ref (match_dup 4))] UNSPEC_EXECUTE)\n+     (set (reg:CCU CC_REGNUM) (compare:CCU (match_dup 0) (match_dup 1)))\n+     (use (const_int 1))])]\n+  \"operands[4] = gen_label_rtx ();\")\n+\n (define_split\n   [(set (reg:CCU CC_REGNUM)\n         (compare:CCU (match_operand:BLK 0 \"memory_operand\" \"\")\n@@ -2776,6 +3052,83 @@\n   FAIL;\n })\n \n+(define_insn \"*insv<mode>_z10\"\n+  [(set (zero_extract:GPR (match_operand:GPR 0 \"nonimmediate_operand\" \"+d\")\n+\t\t\t  (match_operand 1 \"const_int_operand\"    \"I\")\n+\t\t\t  (match_operand 2 \"const_int_operand\"    \"I\"))\n+\t(match_operand:GPR 3 \"nonimmediate_operand\" \"d\"))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_Z10\n+   && (INTVAL (operands[1]) + INTVAL (operands[2])) <=\n+      GET_MODE_BITSIZE (<MODE>mode)\"\n+{\n+  int start = INTVAL (operands[2]);\n+  int size = INTVAL (operands[1]);\n+  int offset = 64 - GET_MODE_BITSIZE (<MODE>mode);\n+\n+  operands[2] = GEN_INT (offset + start);              /* start bit position */\n+  operands[1] = GEN_INT (offset + start + size - 1);   /* end bit position */\n+  operands[4] = GEN_INT (GET_MODE_BITSIZE (<MODE>mode) -\n+\t\t\t start - size);       /* left shift count */\n+\n+  return \"risbg\\t%0,%3,%b2,%b1,%b4\";\n+}\n+  [(set_attr \"op_type\" \"RIE\")])\n+\n+; and op1 with a mask being 1 for the selected bits and 0 for the rest\n+; and op3=op0 with a mask being 0 for the selected bits and 1 for the rest\n+(define_insn \"*insv<mode>_z10_noshift\"\n+  [(set (match_operand:GPR 0 \"nonimmediate_operand\" \"=d\")\n+\t(ior:GPR (and:GPR (match_operand:GPR 1 \"nonimmediate_operand\" \"d\")\n+\t\t\t  (match_operand 2 \"const_int_operand\" \"n\"))\n+\t\t (and:GPR (match_operand:GPR 3 \"nonimmediate_operand\" \"0\")\n+\t\t\t  (match_operand 4 \"const_int_operand\" \"n\"))))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_Z10\n+   && s390_contiguous_bitmask_p (INTVAL (operands[2]),\n+                                 GET_MODE_BITSIZE (<MODE>mode), NULL, NULL)\n+   && INTVAL (operands[2]) == ~(INTVAL (operands[4]))\"\n+\n+{\n+  int start;\n+  int size;\n+\n+  s390_contiguous_bitmask_p (INTVAL (operands[2]),\n+                             GET_MODE_BITSIZE (<MODE>mode), &start, &size);\n+\n+  operands[5] = GEN_INT (64 - start - size); /* start bit position */\n+  operands[6] = GEN_INT (64 - 1 - start);    /* end bit position */\n+  operands[7] = const0_rtx;                  /* left shift count */\n+\n+  return \"risbg\\t%0,%1,%b5,%b6,%b7\";\n+}\n+  [(set_attr \"op_type\" \"RIE\")])\n+\n+; and op1 with a mask being 1 for the selected bits and 0 for the rest\n+(define_insn \"*insv<mode>_or_z10_noshift\"\n+  [(set (match_operand:GPR 0 \"nonimmediate_operand\" \"=d\")\n+\t(ior:GPR (and:GPR (match_operand:GPR 1 \"nonimmediate_operand\" \"d\")\n+\t\t\t  (match_operand 2 \"const_int_operand\" \"n\"))\n+\t\t(match_operand:GPR 3 \"nonimmediate_operand\" \"0\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_Z10\n+   && s390_contiguous_bitmask_p (INTVAL (operands[2]),\n+                                 GET_MODE_BITSIZE (<MODE>mode), NULL, NULL)\"\n+{\n+  int start;\n+  int size;\n+\n+  s390_contiguous_bitmask_p (INTVAL (operands[2]),\n+                             GET_MODE_BITSIZE (<MODE>mode), &start, &size);\n+\n+  operands[4] = GEN_INT (64 - start - size); /* start bit position */\n+  operands[5] = GEN_INT (64 - 1 - start);    /* end bit position */\n+  operands[6] = const0_rtx;                  /* left shift count */\n+\n+  return \"rosbg\\t%0,%1,%b4,%b5,%b6\";\n+}\n+  [(set_attr \"op_type\" \"RIE\")])\n+\n (define_insn \"*insv<mode>_mem_reg\"\n   [(set (zero_extract:P (match_operand:QI 0 \"memory_operand\" \"+Q,S\")\n \t\t\t(match_operand 1 \"const_int_operand\" \"n,n\")\n@@ -2871,13 +3224,16 @@\n })\n \n (define_insn \"*extendsidi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n-        (sign_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"d,RT\")))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d,d,d\")\n+        (sign_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"d,RT,b\")))]\n   \"TARGET_64BIT\"\n   \"@\n    lgfr\\t%0,%1\n-   lgf\\t%0,%1\"\n-  [(set_attr \"op_type\" \"RRE,RXY\")])\n+   lgf\\t%0,%1\n+   lgfrl\\t%0,%1\"\n+  [(set_attr \"op_type\"      \"RRE,RXY,RIL\")\n+   (set_attr \"type\"         \"*,*,larl\")\n+   (set_attr \"cpu_facility\" \"*,*,z10\")])\n \n ;\n ; extend(hi|qi)(si|di)2 instruction pattern(s).\n@@ -2912,13 +3268,16 @@\n ;\n \n (define_insn \"*extendhidi2_extimm\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n-        (sign_extend:DI (match_operand:HI 1 \"nonimmediate_operand\" \"d,RT\")))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d,d,d\")\n+        (sign_extend:DI (match_operand:HI 1 \"general_operand\" \"d,RT,b\")))]\n   \"TARGET_64BIT && TARGET_EXTIMM\"\n   \"@\n    lghr\\t%0,%1\n-   lgh\\t%0,%1\"\n-  [(set_attr \"op_type\" \"RRE,RXY\")])\n+   lgh\\t%0,%1\n+   lghrl\\t%0,%1\"\n+  [(set_attr \"op_type\"      \"RRE,RXY,RIL\")\n+   (set_attr \"type\"         \"*,*,larl\")\n+   (set_attr \"cpu_facility\" \"extimm,extimm,z10\")])\n \n (define_insn \"*extendhidi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n@@ -2932,14 +3291,17 @@\n ;\n \n (define_insn \"*extendhisi2_extimm\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n-        (sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"d,R,T\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d,d\")\n+        (sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \" d,R,T,b\")))]\n   \"TARGET_EXTIMM\"\n   \"@\n    lhr\\t%0,%1\n    lh\\t%0,%1\n-   lhy\\t%0,%1\"\n-  [(set_attr \"op_type\" \"RRE,RX,RXY\")])\n+   lhy\\t%0,%1\n+   lhrl\\t%0,%1\"\n+  [(set_attr \"op_type\"      \"RRE,RX,RXY,RIL\")\n+   (set_attr \"type\"         \"*,*,*,larl\")\n+   (set_attr \"cpu_facility\" \"extimm,extimm,extimm,z10\")])\n \n (define_insn \"*extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n@@ -3011,13 +3373,16 @@\n })\n \n (define_insn \"*zero_extendsidi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n-        (zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"d,RT\")))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d,d,d\")\n+        (zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"d,RT,b\")))]\n   \"TARGET_64BIT\"\n   \"@\n    llgfr\\t%0,%1\n-   llgf\\t%0,%1\"\n-  [(set_attr \"op_type\" \"RRE,RXY\")])\n+   llgf\\t%0,%1\n+   llgfrl\\t%0,%1\"\n+  [(set_attr \"op_type\"      \"RRE,RXY,RIL\")\n+   (set_attr \"type\"         \"*,*,larl\")\n+   (set_attr \"cpu_facility\" \"*,*,z10\")])\n \n ;\n ; LLGT-type instructions (zero-extend from 31 bit to 64 bit).\n@@ -3116,6 +3481,19 @@\n     }\n })\n \n+; llhrl, llghrl\n+(define_insn \"*zero_extendhi<mode>2_z10\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=d,d,d\")\n+        (zero_extend:GPR (match_operand:HI 1 \"nonimmediate_operand\" \"d,RT,b\")))]\n+  \"TARGET_Z10\"\n+  \"@\n+   ll<g>hr\\t%0,%1\n+   ll<g>h\\t%0,%1\n+   ll<g>hrl\\t%0,%1\"\n+  [(set_attr \"op_type\"      \"RXY,RRE,RIL\")\n+   (set_attr \"type\"         \"*,*,larl\")\n+   (set_attr \"cpu_facility\" \"*,*,z10\")])\n+\n ; llhr, llcr, llghr, llgcr, llh, llc, llgh, llgc\n (define_insn \"*zero_extend<HQI:mode><GPR:mode>2_extimm\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=d,d\")\n@@ -3628,7 +4006,7 @@\n \n (define_expand \"adddi3\"\n   [(parallel\n-    [(set (match_operand:DI 0 \"register_operand\" \"\")\n+    [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n           (plus:DI (match_operand:DI 1 \"nonimmediate_operand\" \"\")\n                    (match_operand:DI 2 \"general_operand\" \"\")))\n      (clobber (reg:CC CC_REGNUM))])]\n@@ -3683,7 +4061,7 @@\n   [(set_attr \"op_type\"  \"RRE,RXY\")])\n \n (define_insn_and_split \"*adddi3_31z\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=&d\")\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&d\")\n         (plus:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0\")\n                  (match_operand:DI 2 \"general_operand\" \"do\") ) )\n    (clobber (reg:CC CC_REGNUM))]\n@@ -3708,7 +4086,7 @@\n    operands[8] = operand_subword (operands[2], 1, 0, DImode);\")\n \n (define_insn_and_split \"*adddi3_31\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=&d\")\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&d\")\n         (plus:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0\")\n                  (match_operand:DI 2 \"general_operand\" \"do\") ) )\n    (clobber (reg:CC CC_REGNUM))]\n@@ -3745,7 +4123,7 @@\n \n (define_expand \"addsi3\"\n   [(parallel\n-    [(set (match_operand:SI 0 \"register_operand\" \"\")\n+    [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n           (plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"\")\n                    (match_operand:SI 2 \"general_operand\" \"\")))\n      (clobber (reg:CC CC_REGNUM))])]\n@@ -3767,11 +4145,11 @@\n ; add(di|si)3 instruction pattern(s).\n ;\n \n-; ar, ahi, alfi, slfi, a, ay, agr, aghi, algfi, slgfi, ag\n+; ar, ahi, alfi, slfi, a, ay, agr, aghi, algfi, slgfi, ag, asi, agsi\n (define_insn \"*add<mode>3\"\n-  [(set (match_operand:GPR 0 \"register_operand\" \"=d,d,d,d,d,d\")\n-        (plus:GPR (match_operand:GPR 1 \"nonimmediate_operand\" \"%0,0,0,0,0,0\")\n-\t\t  (match_operand:GPR 2 \"general_operand\" \"d,K,Op,On,R,T\") ) )\n+  [(set (match_operand:GPR 0 \"nonimmediate_operand\" \"=d,d,d,d,d,d,QS\")\n+        (plus:GPR (match_operand:GPR 1 \"nonimmediate_operand\" \"%0,0,0,0,0,0,0\")\n+\t\t  (match_operand:GPR 2 \"general_operand\" \"d,K,Op,On,R,T,C\") ) )\n    (clobber (reg:CC CC_REGNUM))]\n   \"\"\n   \"@\n@@ -3780,25 +4158,29 @@\n    al<g>fi\\t%0,%2\n    sl<g>fi\\t%0,%n2\n    a<g>\\t%0,%2\n-   a<y>\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"RR<E>,RI,RIL,RIL,RX<Y>,RXY\")])\n+   a<y>\\t%0,%2\n+   a<g>si\\t%0,%c2\"\n+  [(set_attr \"op_type\"  \"RR<E>,RI,RIL,RIL,RX<Y>,RXY,SIY\")\n+   (set_attr \"cpu_facility\" \"*,*,extimm,extimm,*,*,z10\")])\n \n-; alr, alfi, slfi, al, aly, algr, algfi, slgfi, alg\n+; alr, alfi, slfi, al, aly, algr, algfi, slgfi, alg, alsi, algsi\n (define_insn \"*add<mode>3_carry1_cc\"\n   [(set (reg CC_REGNUM)\n-        (compare (plus:GPR (match_operand:GPR 1 \"nonimmediate_operand\" \"%0,0,0,0,0\")\n-\t\t\t   (match_operand:GPR 2 \"general_operand\" \"d,Op,On,R,T\"))\n+        (compare (plus:GPR (match_operand:GPR 1 \"nonimmediate_operand\" \"%0,0,0,0,0,0\")\n+\t\t\t   (match_operand:GPR 2 \"general_operand\" \"d,Op,On,R,T,C\"))\n                  (match_dup 1)))\n-   (set (match_operand:GPR 0 \"register_operand\" \"=d,d,d,d,d\")\n+   (set (match_operand:GPR 0 \"nonimmediate_operand\" \"=d,d,d,d,d,d\")\n         (plus:GPR (match_dup 1) (match_dup 2)))]\n   \"s390_match_ccmode (insn, CCL1mode)\"\n   \"@\n    al<g>r\\t%0,%2\n    al<g>fi\\t%0,%2\n    sl<g>fi\\t%0,%n2\n    al<g>\\t%0,%2\n-   al<y>\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"RR<E>,RIL,RIL,RX<Y>,RXY\")])\n+   al<y>\\t%0,%2\n+   al<g>si\\t%0,%c2\"\n+  [(set_attr \"op_type\"      \"RR<E>,RIL,RIL,RX<Y>,RXY,SIY\")\n+   (set_attr \"cpu_facility\" \"*,extimm,extimm,*,*,z10\")])\n \n ; alr, al, aly, algr, alg\n (define_insn \"*add<mode>3_carry1_cconly\"\n@@ -3814,22 +4196,24 @@\n    al<y>\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RR<E>,RX<Y>,RXY\")])\n \n-; alr, alfi, slfi, al, aly, algr, algfi, slgfi, alg\n+; alr, alfi, slfi, al, aly, algr, algfi, slgfi, alg, alsi, algsi\n (define_insn \"*add<mode>3_carry2_cc\"\n   [(set (reg CC_REGNUM)\n-        (compare (plus:GPR (match_operand:GPR 1 \"nonimmediate_operand\" \"%0,0,0,0,0\")\n-\t\t\t   (match_operand:GPR 2 \"general_operand\" \"d,Op,On,R,T\"))\n+        (compare (plus:GPR (match_operand:GPR 1 \"nonimmediate_operand\" \"%0,0,0,0,0,0\")\n+\t\t\t   (match_operand:GPR 2 \"general_operand\" \"d,Op,On,R,T,C\"))\n                  (match_dup 2)))\n-   (set (match_operand:GPR 0 \"register_operand\" \"=d,d,d,d,d\")\n+   (set (match_operand:GPR 0 \"nonimmediate_operand\" \"=d,d,d,d,d,RS\")\n         (plus:GPR (match_dup 1) (match_dup 2)))]\n   \"s390_match_ccmode (insn, CCL1mode)\"\n   \"@\n    al<g>r\\t%0,%2\n    al<g>fi\\t%0,%2\n    sl<g>fi\\t%0,%n2\n    al<g>\\t%0,%2\n-   al<y>\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"RR<E>,RIL,RIL,RX<Y>,RXY\")])\n+   al<y>\\t%0,%2\n+   al<g>si\\t%0,%c2\"\n+  [(set_attr \"op_type\"  \"RR<E>,RIL,RIL,RX<Y>,RXY,SIY\")\n+   (set_attr \"cpu_facility\" \"*,extimm,extimm,*,*,z10\")])\n \n ; alr, al, aly, algr, alg\n (define_insn \"*add<mode>3_carry2_cconly\"\n@@ -3845,22 +4229,24 @@\n    al<y>\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RR<E>,RX<Y>,RXY\")])\n \n-; alr, alfi, slfi, al, aly, algr, algfi, slgfi, alg\n+; alr, alfi, slfi, al, aly, algr, algfi, slgfi, alg, alsi, algsi\n (define_insn \"*add<mode>3_cc\"\n   [(set (reg CC_REGNUM)\n-        (compare (plus:GPR (match_operand:GPR 1 \"nonimmediate_operand\" \"%0,0,0,0,0\")\n-\t\t\t   (match_operand:GPR 2 \"general_operand\" \"d,Op,On,R,T\"))\n+        (compare (plus:GPR (match_operand:GPR 1 \"nonimmediate_operand\" \"%0,0,0,0,0,0\")\n+\t\t\t   (match_operand:GPR 2 \"general_operand\" \"d,Op,On,R,T,C\"))\n                  (const_int 0)))\n-   (set (match_operand:GPR 0 \"register_operand\" \"=d,d,d,d,d\")\n+   (set (match_operand:GPR 0 \"nonimmediate_operand\" \"=d,d,d,d,d,RS\")\n         (plus:GPR (match_dup 1) (match_dup 2)))]\n   \"s390_match_ccmode (insn, CCLmode)\"\n   \"@\n    al<g>r\\t%0,%2\n    al<g>fi\\t%0,%2\n    sl<g>fi\\t%0,%n2\n    al<g>\\t%0,%2\n-   al<y>\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"RR<E>,RIL,RIL,RX<Y>,RXY\")])\n+   al<y>\\t%0,%2\n+   al<g>si\\t%0,%c2\"\n+  [(set_attr \"op_type\"  \"RR<E>,RIL,RIL,RX<Y>,RXY,SIY\")\n+   (set_attr \"cpu_facility\" \"*,extimm,extimm,*,*,z10\")])\n \n ; alr, al, aly, algr, alg\n (define_insn \"*add<mode>3_cconly\"\n@@ -3889,22 +4275,25 @@\n    al<y>\\t%0,%2\"\n   [(set_attr \"op_type\"  \"RR<E>,RX<Y>,RXY\")])\n \n-; ahi, afi, aghi, agfi\n+; ahi, afi, aghi, agfi, asi, agsi\n (define_insn \"*add<mode>3_imm_cc\"\n   [(set (reg CC_REGNUM)\n-        (compare (plus:GPR (match_operand:GPR 1 \"nonimmediate_operand\" \"0,0\")\n-\t\t\t   (match_operand:GPR 2 \"const_int_operand\" \"K,Os\"))\n+        (compare (plus:GPR (match_operand:GPR 1 \"nonimmediate_operand\" \"0,0,0\")\n+\t\t\t   (match_operand:GPR 2 \"const_int_operand\" \"K,Os,C\"))\n                  (const_int 0)))\n-   (set (match_operand:GPR 0 \"register_operand\" \"=d,d\")\n+   (set (match_operand:GPR 0 \"nonimmediate_operand\" \"=d,d,QS\")\n         (plus:GPR (match_dup 1) (match_dup 2)))]\n   \"s390_match_ccmode (insn, CCAmode)\n    && (CONST_OK_FOR_CONSTRAINT_P (INTVAL (operands[2]), 'K', \\\"K\\\")\n-       || CONST_OK_FOR_CONSTRAINT_P (INTVAL (operands[2]), 'O', \\\"Os\\\"))\n+       || CONST_OK_FOR_CONSTRAINT_P (INTVAL (operands[2]), 'O', \\\"Os\\\")\n+       || CONST_OK_FOR_CONSTRAINT_P (INTVAL (operands[2]), 'C', \\\"C\\\"))\n    && INTVAL (operands[2]) != -((HOST_WIDE_INT)1 << (GET_MODE_BITSIZE(<MODE>mode) - 1))\"\n   \"@\n    a<g>hi\\t%0,%h2\n-   a<g>fi\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"RI,RIL\")])\n+   a<g>fi\\t%0,%2\n+   a<g>si\\t%0,%c2\"\n+  [(set_attr \"op_type\"      \"RI,RIL,SIY\")\n+   (set_attr \"cpu_facility\" \"*,extimm,z10\")])\n \n ;\n ; add(tf|df|sf|td|dd)3 instruction pattern(s).\n@@ -4503,69 +4892,78 @@\n \n (define_insn \"*muldi3_sign\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n-        (mult:DI (sign_extend:DI (match_operand:SI 2 \"nonimmediate_operand\" \"d,RT\"))\n+        (mult:DI (sign_extend:DI (match_operand:SI 2 \"general_operand\" \"d,RT\"))\n                  (match_operand:DI 1 \"register_operand\" \"0,0\")))]\n   \"TARGET_64BIT\"\n   \"@\n    msgfr\\t%0,%2\n    msgf\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"RRE,RXY\")\n-   (set_attr \"type\"     \"imuldi\")])\n+  [(set_attr \"op_type\"      \"RRE,RXY\")\n+   (set_attr \"type\"         \"imuldi\")])\n \n (define_insn \"muldi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d,d,d\")\n-        (mult:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0,0\")\n-                 (match_operand:DI 2 \"general_operand\" \"d,K,RT\")))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d,d,d,d\")\n+        (mult:DI (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0,0,0\")\n+                 (match_operand:DI 2 \"general_operand\" \"d,K,RT,Os\")))]\n   \"TARGET_64BIT\"\n   \"@\n    msgr\\t%0,%2\n    mghi\\t%0,%h2\n-   msg\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"RRE,RI,RXY\")\n-   (set_attr \"type\"     \"imuldi\")])\n+   msg\\t%0,%2\n+   msgfi\\t%0,%2\"\n+  [(set_attr \"op_type\"      \"RRE,RI,RXY,RIL\")\n+   (set_attr \"type\"         \"imuldi\")\n+   (set_attr \"cpu_facility\" \"*,*,*,z10\")])\n \n ;\n ; mulsi3 instruction pattern(s).\n ;\n \n (define_insn \"*mulsi3_sign\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (mult:SI (sign_extend:SI (match_operand:HI 2 \"memory_operand\" \"R\"))\n-                 (match_operand:SI 1 \"register_operand\" \"0\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+        (mult:SI (sign_extend:SI (match_operand:HI 2 \"memory_operand\" \"R,T\"))\n+                 (match_operand:SI 1 \"register_operand\" \"0,0\")))]\n   \"\"\n-  \"mh\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"RX\")\n-   (set_attr \"type\"     \"imulhi\")])\n+  \"@\n+   mh\\t%0,%2\n+   mhy\\t%0,%2\"\n+  [(set_attr \"op_type\"      \"RX,RXY\")\n+   (set_attr \"type\"         \"imulhi\")\n+   (set_attr \"cpu_facility\" \"*,z10\")])\n \n (define_insn \"mulsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d,d\")\n-        (mult:SI  (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0,0,0\")\n-                  (match_operand:SI 2 \"general_operand\" \"d,K,R,T\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d,d,d\")\n+        (mult:SI  (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0,0,0,0\")\n+                  (match_operand:SI 2 \"general_operand\" \"d,K,R,T,Os\")))]\n   \"\"\n   \"@\n    msr\\t%0,%2\n    mhi\\t%0,%h2\n    ms\\t%0,%2\n-   msy\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"RRE,RI,RX,RXY\")\n-   (set_attr \"type\"     \"imulsi,imulhi,imulsi,imulsi\")])\n+   msy\\t%0,%2\n+   msfi\\t%0,%2\"\n+  [(set_attr \"op_type\"      \"RRE,RI,RX,RXY,RIL\")\n+   (set_attr \"type\"         \"imulsi,imulhi,imulsi,imulsi,imulsi\")\n+   (set_attr \"cpu_facility\" \"*,*,*,*,z10\")])\n \n ;\n ; mulsidi3 instruction pattern(s).\n ;\n \n (define_insn \"mulsidi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d,d,d\")\n         (mult:DI (sign_extend:DI\n-\t           (match_operand:SI 1 \"register_operand\" \"%0,0\"))\n+\t           (match_operand:SI 1 \"register_operand\" \"%0,0,0\"))\n                  (sign_extend:DI\n-\t           (match_operand:SI 2 \"nonimmediate_operand\" \"d,R\"))))]\n+\t           (match_operand:SI 2 \"nonimmediate_operand\" \"d,R,T\"))))]\n   \"!TARGET_64BIT\"\n   \"@\n    mr\\t%0,%2\n-   m\\t%0,%2\"\n-  [(set_attr \"op_type\"  \"RR,RX\")\n-   (set_attr \"type\"     \"imulsi\")])\n+   m\\t%0,%2\n+   mfy\\t%0,%2\"\n+  [(set_attr \"op_type\"      \"RR,RX,RXY\")\n+   (set_attr \"type\"         \"imulsi\")\n+   (set_attr \"cpu_facility\" \"*,*,z10\")])\n \n ;\n ; umulsidi3 instruction pattern(s).\n@@ -6762,6 +7160,32 @@\n   [(set_attr \"op_type\" \"RI\")\n    (set_attr \"type\"  \"branch\")])\n \n+; crt, cgrt, cit, cgit\n+(define_insn \"*cmp_and_trap_signed_int<mode>\"\n+  [(trap_if (match_operator 0 \"s390_signed_integer_comparison\"\n+\t       [(match_operand:GPR 1 \"register_operand\"  \"d,d\")\n+\t\t(match_operand:GPR 2 \"nonmemory_operand\" \"d,K\")])\n+\t    (const_int 0))]\n+  \"TARGET_Z10\"\n+  \"@\n+   c<g>rt%C0\\t%1,%2\n+   c<g>it%C0\\t%1,%h2\"\n+  [(set_attr \"op_type\" \"RRF,RIE\")\n+   (set_attr \"type\"    \"branch\")])\n+\n+; clrt, clgrt, clfit, clgit\n+(define_insn \"*cmp_and_trap_unsigned_int<mode>\"\n+  [(trap_if (match_operator 0 \"s390_unsigned_integer_comparison\"\n+\t       [(match_operand:GPR 1 \"register_operand\"  \"d,d\")\n+\t\t(match_operand:GPR 2 \"nonmemory_operand\" \"d,D\")])\n+\t    (const_int 0))]\n+  \"TARGET_Z10\"\n+  \"@\n+   cl<g>rt%C0\\t%1,%2\n+   cl<gf>it%C0\\t%1,%x2\"\n+  [(set_attr \"op_type\" \"RRF,RIE\")\n+   (set_attr \"type\"    \"branch\")])\n+\n ;;\n ;;- Loop instructions.\n ;;\n@@ -7908,3 +8332,30 @@\n   \"\"\n   \"\"\n   [(set_attr \"length\" \"0\")])\n+\n+\n+;\n+; Data prefetch patterns\n+;\n+\n+(define_insn \"prefetch\"\n+  [(prefetch (match_operand 0 \"address_operand\" \"UW,X\")\n+\t     (match_operand:SI 1 \"const_int_operand\" \"n,n\")\n+\t     (match_operand:SI 2 \"const_int_operand\" \"n,n\"))]\n+  \"TARGET_Z10\"\n+{\n+  if (larl_operand (operands[0], Pmode))\n+    return INTVAL (operands[1]) == 1 ? \"pfdrl\\t2,%a0\" : \"pfdrl\\t1,%a0\";\n+\n+  if (s390_mem_constraint (\"W\", operands[0])\n+      || s390_mem_constraint (\"U\", operands[0]))\n+    return INTVAL (operands[1]) == 1 ? \"pfd\\t2,%a0\" : \"pfd\\t1,%a0\";\n+\n+  /* This point might be reached if op0 is a larl operand with an\n+     uneven addend.  In this case we simply omit issuing a prefetch\n+     instruction.  */\n+\n+  return \"\";\n+\n+} [(set_attr \"type\" \"load,larl\")\n+   (set_attr \"op_type\" \"RXY,RIL\")])"}]}