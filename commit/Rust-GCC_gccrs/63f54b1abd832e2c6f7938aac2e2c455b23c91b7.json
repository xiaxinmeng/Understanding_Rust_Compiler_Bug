{"sha": "63f54b1abd832e2c6f7938aac2e2c455b23c91b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjNmNTRiMWFiZDgzMmUyYzZmNzkzOGFhYzJlMmM0NTViMjNjOTFiNw==", "commit": {"author": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@ispras.ru", "date": "2006-03-16T05:23:21Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2006-03-16T05:23:21Z"}, "message": "sched-int.h (struct haifa_insn_data): New fields: resolved_deps, inter_tick, queue_index.\n\n2006-03-16  Maxim Kuvyrkov <mkuvyrkov@ispras.ru>\n\n        * sched-int.h (struct haifa_insn_data): New fields: resolved_deps,\n\tinter_tick, queue_index.\n\t(struct sched_info): Change signature of init_ready_list field.\n\tAdjust all initializations.\n\t(RESOLVED_DEPS): New access macro.\n\t(ready_add): Remove prototype.\n\t(try_ready): Add prototype.\n\t* sched-rgn.c (init_ready_list): Use try_ready.\n\t(schedule_region): Initialize\n\tcurrent_sched_info->{sched_max_insns_priority, queue_must_finish_empty}.\n\t* sched-ebb.c (new_ready): Remove.  Adjust ebb_sched_info.\n\t(init_ready_list): Use try_ready.\n\t(schedule_ebb): Initialize current_sched_info->sched_max_insns_priority.\n\t* lists.c (remove_list_elem): Remove `static'.\n\t(remove_free_INSN_LIST_elem): New function.\n\t* rtl.h (remove_list_elem, remove_free_INSN_LIST_elem): Add prototypes.\n\t* haifa-sched.c (INTER_TICK, QUEUE_INDEX): New macros.\n\t(INVALID_TICK, MIN_TICK, QUEUE_SCHEDULED, QUEUE_NOWHERE, QUEUE_READY):\n\tNew constants.\n\t(readyp): New variable.\n\t(queue_remove, ready_remove_insn, fix_inter_tick, fix_tick_ready,\n\tchange_queue_index, resolve_dep): New static functions.\n\t(try_ready): New function.  Adjust callers in sched-rgn.c and\n\tsched-ebb.c to use it instead of ready_add.\n\t(clock_var): Move at the begining of file.\n\t(rank_for_schedule): Fix typo.\n\t(queue_insn): Add assertion.  Handle QUEUE_INDEX.\n\t(ready_lastpos): Enforce assertion.\n\t(ready_add): Make it static.  Handle QUEUE_INDEX.  Add new argument,\n\tupdate all callers.\n\t(ready_remove_first, ready_remove): Handle QUEUE_INDEX.\n\t(schedule_insn): Rewrite to use try_ready and resolve_dep.\n\t(queue_to_ready): Use free_INSN_LIST_list.\n\t(early_queue_to_ready): Fix typo.\n\t(schedule_block): Init readyp.  Move init_ready_list call after the\n\tinitialization of clock_var.  Fix error in rejecting insn by\n\ttargetm.sched.dfa_new_cycle.  Add call to fix_inter_tick.  Remove code\n\tthat previously\tcorrected INSN_TICKs.  Add code for handling\n\tQUEUE_INDEX.\n\t(set_priorities): Fix typo.\n\t(sched_init): Initialize INSN_TICK, INTER_TICK and QUEUE_INDEX.\n\tClarify comment and code that keeps current_sched_info->next_tail\n\tnon-null.\n\nFrom-SVN: r112127", "tree": {"sha": "2406ed9805b60255cb95efc06c870414886a802d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2406ed9805b60255cb95efc06c870414886a802d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63f54b1abd832e2c6f7938aac2e2c455b23c91b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63f54b1abd832e2c6f7938aac2e2c455b23c91b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63f54b1abd832e2c6f7938aac2e2c455b23c91b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63f54b1abd832e2c6f7938aac2e2c455b23c91b7/comments", "author": null, "committer": null, "parents": [{"sha": "d08eefb9d2cb72e7168d3b790111d6c07ce87a8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d08eefb9d2cb72e7168d3b790111d6c07ce87a8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d08eefb9d2cb72e7168d3b790111d6c07ce87a8a"}], "stats": {"total": 662, "additions": 500, "deletions": 162}, "files": [{"sha": "826ea2784b72017df45be77eb154c08f69dd2b78", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63f54b1abd832e2c6f7938aac2e2c455b23c91b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63f54b1abd832e2c6f7938aac2e2c455b23c91b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=63f54b1abd832e2c6f7938aac2e2c455b23c91b7", "patch": "@@ -1,3 +1,49 @@\n+2006-03-16  Maxim Kuvyrkov <mkuvyrkov@ispras.ru>\n+\n+        * sched-int.h (struct haifa_insn_data): New fields: resolved_deps,\n+\tinter_tick, queue_index.\n+\t(struct sched_info): Change signature of init_ready_list field.\n+\tAdjust all initializations.\n+\t(RESOLVED_DEPS): New access macro.\n+\t(ready_add): Remove prototype.\n+\t(try_ready): Add prototype.\n+\t* sched-rgn.c (init_ready_list): Use try_ready.\n+\t(schedule_region): Initialize\n+\tcurrent_sched_info->{sched_max_insns_priority, queue_must_finish_empty}.\n+\t* sched-ebb.c (new_ready): Remove.  Adjust ebb_sched_info.\n+\t(init_ready_list): Use try_ready.\n+\t(schedule_ebb): Initialize current_sched_info->sched_max_insns_priority.\n+\t* lists.c (remove_list_elem): Remove `static'.\n+\t(remove_free_INSN_LIST_elem): New function.\n+\t* rtl.h (remove_list_elem, remove_free_INSN_LIST_elem): Add prototypes.\n+\t* haifa-sched.c (INTER_TICK, QUEUE_INDEX): New macros.\n+\t(INVALID_TICK, MIN_TICK, QUEUE_SCHEDULED, QUEUE_NOWHERE, QUEUE_READY):\n+\tNew constants.\n+\t(readyp): New variable.\n+\t(queue_remove, ready_remove_insn, fix_inter_tick, fix_tick_ready,\n+\tchange_queue_index, resolve_dep): New static functions.\n+\t(try_ready): New function.  Adjust callers in sched-rgn.c and\n+\tsched-ebb.c to use it instead of ready_add.\n+\t(clock_var): Move at the begining of file.\n+\t(rank_for_schedule): Fix typo.\n+\t(queue_insn): Add assertion.  Handle QUEUE_INDEX.\n+\t(ready_lastpos): Enforce assertion.\n+\t(ready_add): Make it static.  Handle QUEUE_INDEX.  Add new argument,\n+\tupdate all callers.\n+\t(ready_remove_first, ready_remove): Handle QUEUE_INDEX.\n+\t(schedule_insn): Rewrite to use try_ready and resolve_dep.\n+\t(queue_to_ready): Use free_INSN_LIST_list.\n+\t(early_queue_to_ready): Fix typo.\n+\t(schedule_block): Init readyp.  Move init_ready_list call after the\n+\tinitialization of clock_var.  Fix error in rejecting insn by\n+\ttargetm.sched.dfa_new_cycle.  Add call to fix_inter_tick.  Remove code\n+\tthat previously\tcorrected INSN_TICKs.  Add code for handling\n+\tQUEUE_INDEX.\n+\t(set_priorities): Fix typo.\n+\t(sched_init): Initialize INSN_TICK, INTER_TICK and QUEUE_INDEX.\n+\tClarify comment and code that keeps current_sched_info->next_tail\n+\tnon-null.\n+\n 2006-03-16  Maxim Kuvyrkov <mkuvyrkov@ispras.ru>\n \n \t* sched-rgn.c (extend_rgns): New static function."}, {"sha": "75300b5f17d7a095cfd35a231bb14370194765dc", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 413, "deletions": 111, "changes": 524, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63f54b1abd832e2c6f7938aac2e2c455b23c91b7/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63f54b1abd832e2c6f7938aac2e2c455b23c91b7/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=63f54b1abd832e2c6f7938aac2e2c455b23c91b7", "patch": "@@ -187,6 +187,13 @@ struct haifa_insn_data *h_i_d;\n \n #define LINE_NOTE(INSN)\t\t(h_i_d[INSN_UID (INSN)].line_note)\n #define INSN_TICK(INSN)\t\t(h_i_d[INSN_UID (INSN)].tick)\n+#define INTER_TICK(INSN)        (h_i_d[INSN_UID (INSN)].inter_tick)\n+\n+/* If INSN_TICK of an instruction is equal to INVALID_TICK,\n+   then it should be recalculated from scratch.  */\n+#define INVALID_TICK (-(max_insn_queue_index + 1))\n+/* The minimal value of the INSN_TICK of an instruction.  */\n+#define MIN_TICK (-max_insn_queue_index)\n \n /* Vector indexed by basic block number giving the starting line-number\n    for each basic block.  */\n@@ -236,7 +243,7 @@ static rtx note_list;\n \n /* Implement a circular buffer to delay instructions until sufficient\n    time has passed.  For the new pipeline description interface,\n-   MAX_INSN_QUEUE_INDEX is a power of two minus one which is larger\n+   MAX_INSN_QUEUE_INDEX is a power of two minus one which is not less\n    than maximal time of instruction execution computed by genattr.c on\n    the base maximal time of functional unit reservations and getting a\n    result.  This is the longest time an insn may be queued.  */\n@@ -247,6 +254,17 @@ static int q_size = 0;\n #define NEXT_Q(X) (((X)+1) & max_insn_queue_index)\n #define NEXT_Q_AFTER(X, C) (((X)+C) & max_insn_queue_index)\n \n+#define QUEUE_SCHEDULED (-3)\n+#define QUEUE_NOWHERE   (-2)\n+#define QUEUE_READY     (-1)\n+/* QUEUE_SCHEDULED - INSN is scheduled.\n+   QUEUE_NOWHERE   - INSN isn't scheduled yet and is neither in\n+   queue or ready list.\n+   QUEUE_READY     - INSN is in ready list.\n+   N >= 0 - INSN queued for X [where NEXT_Q_AFTER (q_ptr, X) == N] cycles.  */\n+   \n+#define QUEUE_INDEX(INSN) (h_i_d[INSN_UID (INSN)].queue_index)\n+\n /* The following variable value refers for all current and future\n    reservations of the processor units.  */\n state_t curr_state;\n@@ -275,6 +293,12 @@ struct ready_list\n   int n_ready;\n };\n \n+/* The pointer to the ready list.  */\n+static struct ready_list *readyp;\n+\n+/* Scheduling clock.  */\n+static int clock_var;\n+\n static int may_trap_exp (rtx, int);\n \n /* Nonzero iff the address is comprised from at most 1 register.  */\n@@ -442,7 +466,7 @@ static int priority (rtx);\n static int rank_for_schedule (const void *, const void *);\n static void swap_sort (rtx *, int);\n static void queue_insn (rtx, int);\n-static int schedule_insn (rtx, struct ready_list *, int);\n+static int schedule_insn (rtx);\n static int find_set_reg_weight (rtx);\n static void find_insn_reg_weight (int);\n static void adjust_priority (rtx);\n@@ -476,6 +500,7 @@ static rtx unlink_line_notes (rtx, rtx);\n static rtx reemit_notes (rtx, rtx);\n \n static rtx *ready_lastpos (struct ready_list *);\n+static void ready_add (struct ready_list *, rtx, bool);\n static void ready_sort (struct ready_list *);\n static rtx ready_remove_first (struct ready_list *);\n \n@@ -491,10 +516,16 @@ static rtx move_insn (rtx, rtx);\n    on the first cycle.  */\n static rtx ready_element (struct ready_list *, int);\n static rtx ready_remove (struct ready_list *, int);\n+static void ready_remove_insn (rtx);\n static int max_issue (struct ready_list *, int *);\n \n static rtx choose_ready (struct ready_list *);\n \n+static void fix_inter_tick (rtx, rtx);\n+static int fix_tick_ready (rtx);\n+static void change_queue_index (rtx, int);\n+static void resolve_dep (rtx, rtx);\n+\n #endif /* INSN_SCHEDULING */\n \f\n /* Point to state used for the current scheduling pass.  */\n@@ -663,7 +694,7 @@ rank_for_schedule (const void *x, const void *y)\n     return info_val;\n \n   /* Compare insns based on their relation to the last-scheduled-insn.  */\n-  if (last_scheduled_insn)\n+  if (INSN_P (last_scheduled_insn))\n     {\n       /* Classify the instructions into three classes:\n          1) Data dependent on last schedule insn.\n@@ -736,6 +767,9 @@ queue_insn (rtx insn, int n_cycles)\n {\n   int next_q = NEXT_Q_AFTER (q_ptr, n_cycles);\n   rtx link = alloc_INSN_LIST (insn, insn_queue[next_q]);\n+\n+  gcc_assert (n_cycles <= max_insn_queue_index);\n+\n   insn_queue[next_q] = link;\n   q_size += 1;\n \n@@ -746,6 +780,18 @@ queue_insn (rtx insn, int n_cycles)\n \n       fprintf (sched_dump, \"queued for %d cycles.\\n\", n_cycles);\n     }\n+  \n+  QUEUE_INDEX (insn) = next_q;\n+}\n+\n+/* Remove INSN from queue.  */\n+static void\n+queue_remove (rtx insn)\n+{\n+  gcc_assert (QUEUE_INDEX (insn) >= 0);\n+  remove_free_INSN_LIST_elem (insn, &insn_queue[QUEUE_INDEX (insn)]);\n+  q_size--;\n+  QUEUE_INDEX (insn) = QUEUE_NOWHERE;\n }\n \n /* Return a pointer to the bottom of the ready list, i.e. the insn\n@@ -754,25 +800,45 @@ queue_insn (rtx insn, int n_cycles)\n HAIFA_INLINE static rtx *\n ready_lastpos (struct ready_list *ready)\n {\n-  gcc_assert (ready->n_ready);\n+  gcc_assert (ready->n_ready >= 1);\n   return ready->vec + ready->first - ready->n_ready + 1;\n }\n \n-/* Add an element INSN to the ready list so that it ends up with the lowest\n-   priority.  */\n+/* Add an element INSN to the ready list so that it ends up with the\n+   lowest/highest priority dependending on FIRST_P.  */\n \n-HAIFA_INLINE void\n-ready_add (struct ready_list *ready, rtx insn)\n+HAIFA_INLINE static void\n+ready_add (struct ready_list *ready, rtx insn, bool first_p)\n {\n-  if (ready->first == ready->n_ready)\n+  if (!first_p)\n     {\n-      memmove (ready->vec + ready->veclen - ready->n_ready,\n-\t       ready_lastpos (ready),\n-\t       ready->n_ready * sizeof (rtx));\n-      ready->first = ready->veclen - 1;\n+      if (ready->first == ready->n_ready)\n+\t{\n+\t  memmove (ready->vec + ready->veclen - ready->n_ready,\n+\t\t   ready_lastpos (ready),\n+\t\t   ready->n_ready * sizeof (rtx));\n+\t  ready->first = ready->veclen - 1;\n+\t}\n+      ready->vec[ready->first - ready->n_ready] = insn;\n     }\n-  ready->vec[ready->first - ready->n_ready] = insn;\n+  else\n+    {\n+      if (ready->first == ready->veclen - 1)\n+\t{\n+\t  if (ready->n_ready)\n+\t    /* ready_lastpos() fails when called with (ready->n_ready == 0).  */\n+\t    memmove (ready->vec + ready->veclen - ready->n_ready - 1,\n+\t\t     ready_lastpos (ready),\n+\t\t     ready->n_ready * sizeof (rtx));\n+\t  ready->first = ready->veclen - 2;\n+\t}\n+      ready->vec[++(ready->first)] = insn;\n+    }\n+\n   ready->n_ready++;\n+\n+  gcc_assert (QUEUE_INDEX (insn) != QUEUE_READY);\n+  QUEUE_INDEX (insn) = QUEUE_READY;\n }\n \n /* Remove the element with the highest priority from the ready list and\n@@ -789,6 +855,10 @@ ready_remove_first (struct ready_list *ready)\n   /* If the queue becomes empty, reset it.  */\n   if (ready->n_ready == 0)\n     ready->first = ready->veclen - 1;\n+\n+  gcc_assert (QUEUE_INDEX (t) == QUEUE_READY);\n+  QUEUE_INDEX (t) = QUEUE_NOWHERE;\n+\n   return t;\n }\n \n@@ -825,9 +895,24 @@ ready_remove (struct ready_list *ready, int index)\n   ready->n_ready--;\n   for (i = index; i < ready->n_ready; i++)\n     ready->vec[ready->first - i] = ready->vec[ready->first - i - 1];\n+  QUEUE_INDEX (t) = QUEUE_NOWHERE;\n   return t;\n }\n \n+/* Remove INSN from the ready list.  */\n+static void\n+ready_remove_insn (rtx insn)\n+{\n+  int i;\n+\n+  for (i = 0; i < readyp->n_ready; i++)\n+    if (ready_element (readyp, i) == insn)\n+      {\n+        ready_remove (readyp, i);\n+        return;\n+      }\n+  gcc_unreachable ();\n+}\n \n /* Sort the ready list READY by ascending priority, using the SCHED_SORT\n    macro.  */\n@@ -883,19 +968,18 @@ static int last_clock_var;\n    zero for insns in a schedule group).  */\n \n static int\n-schedule_insn (rtx insn, struct ready_list *ready, int clock)\n+schedule_insn (rtx insn)\n {\n   rtx link;\n   int advance = 0;\n-  int premature_issue = 0;\n \n   if (sched_verbose >= 1)\n     {\n       char buf[2048];\n \n       print_insn (buf, insn, 0);\n       buf[40] = 0;\n-      fprintf (sched_dump, \";;\\t%3i--> %-40s:\", clock, buf);\n+      fprintf (sched_dump, \";;\\t%3i--> %-40s:\", clock_var, buf);\n \n       if (recog_memoized (insn) < 0)\n \tfprintf (sched_dump, \"nothing\");\n@@ -904,52 +988,44 @@ schedule_insn (rtx insn, struct ready_list *ready, int clock)\n       fputc ('\\n', sched_dump);\n     }\n \n-  if (INSN_TICK (insn) > clock)\n-    {\n-      /* 'insn' has been prematurely moved from the queue to the\n-\t ready list.  */\n-      premature_issue = INSN_TICK (insn) - clock;\n-    }\n+  /* Scheduling instruction should have all its dependencies resolved and\n+     should have been removed from the ready list.  */\n+  gcc_assert (INSN_DEP_COUNT (insn) == 0);\n+  gcc_assert (!LOG_LINKS (insn));\n+  gcc_assert (QUEUE_INDEX (insn) == QUEUE_NOWHERE);\n \n-  for (link = INSN_DEPEND (insn); link != 0; link = XEXP (link, 1))\n+  QUEUE_INDEX (insn) = QUEUE_SCHEDULED;\n+  \n+  /* Now we can free RESOLVED_DEPS list.  */\n+  if (current_sched_info->flags & USE_DEPS_LIST)\n+    free_DEPS_LIST_list (&RESOLVED_DEPS (insn));\n+  else\n+    free_INSN_LIST_list (&RESOLVED_DEPS (insn));\n+    \n+  gcc_assert (INSN_TICK (insn) >= MIN_TICK);\n+  if (INSN_TICK (insn) > clock_var)\n+    /* INSN has been prematurely moved from the queue to the ready list.\n+       This is possible only if following flag is set.  */\n+    gcc_assert (flag_sched_stalled_insns);    \n+\n+  /* ??? Probably, if INSN is scheduled prematurely, we should leave\n+     INSN_TICK untouched.  This is a machine-dependent issue, actually.  */\n+  INSN_TICK (insn) = clock_var;\n+\n+  /* Update dependent instructions.  */\n+  for (link = INSN_DEPEND (insn); link; link = XEXP (link, 1))\n     {\n+      int effective_cost;      \n       rtx next = XEXP (link, 0);\n-      int cost = insn_cost (insn, link, next);\n \n-      INSN_TICK (next) = MAX (INSN_TICK (next), clock + cost + premature_issue);\n-\n-      if ((INSN_DEP_COUNT (next) -= 1) == 0)\n-\t{\n-\t  int effective_cost = INSN_TICK (next) - clock;\n+      resolve_dep (next, insn);\n \n-\t  if (! (*current_sched_info->new_ready) (next))\n-\t    continue;\n-\n-\t  if (sched_verbose >= 2)\n-\t    {\n-\t      fprintf (sched_dump, \";;\\t\\tdependences resolved: insn %s \",\n-\t\t       (*current_sched_info->print_insn) (next, 0));\n-\n-\t      if (effective_cost < 1)\n-\t\tfprintf (sched_dump, \"into ready\\n\");\n-\t      else\n-\t\tfprintf (sched_dump, \"into queue with cost=%d\\n\",\n-\t\t\t effective_cost);\n-\t    }\n-\n-\t  /* Adjust the priority of NEXT and either put it on the ready\n-\t     list or queue it.  */\n-\t  adjust_priority (next);\n-\t  if (effective_cost < 1)\n-\t    ready_add (ready, next);\n-\t  else\n-\t    {\n-\t      queue_insn (next, effective_cost);\n-\n-\t      if (SCHED_GROUP_P (next) && advance < effective_cost)\n-\t\tadvance = effective_cost;\n-\t    }\n-\t}\n+      effective_cost = try_ready (next);\n+      \n+      if (effective_cost >= 0\n+\t  && SCHED_GROUP_P (next)\n+\t  && advance < effective_cost)\n+\tadvance = effective_cost;\n     }\n \n   /* Annotate the instruction with issue information -- TImode\n@@ -962,9 +1038,10 @@ schedule_insn (rtx insn, struct ready_list *ready, int clock)\n       && GET_CODE (PATTERN (insn)) != CLOBBER)\n     {\n       if (reload_completed)\n-\tPUT_MODE (insn, clock > last_clock_var ? TImode : VOIDmode);\n-      last_clock_var = clock;\n+\tPUT_MODE (insn, clock_var > last_clock_var ? TImode : VOIDmode);\n+      last_clock_var = clock_var;\n     }\n+\n   return advance;\n }\n \n@@ -1354,9 +1431,6 @@ find_insn_reg_weight (int b)\n     }\n }\n \n-/* Scheduling clock, modified in schedule_block() and queue_to_ready ().  */\n-static int clock_var;\n-\n /* Move insns that became ready to fire from queue to ready list.  */\n \n static void\n@@ -1378,11 +1452,11 @@ queue_to_ready (struct ready_list *ready)\n \tfprintf (sched_dump, \";;\\t\\tQ-->Ready: insn %s: \",\n \t\t (*current_sched_info->print_insn) (insn, 0));\n \n-      ready_add (ready, insn);\n+      ready_add (ready, insn, false);\n       if (sched_verbose >= 2)\n \tfprintf (sched_dump, \"moving to ready without stalls\\n\");\n     }\n-  insn_queue[q_ptr] = 0;\n+  free_INSN_LIST_list (&insn_queue[q_ptr]);\n \n   /* If there are no ready insns, stall until one is ready and add all\n      of the pending insns at that point to the ready list.  */\n@@ -1403,11 +1477,11 @@ queue_to_ready (struct ready_list *ready)\n \t\t    fprintf (sched_dump, \";;\\t\\tQ-->Ready: insn %s: \",\n \t\t\t     (*current_sched_info->print_insn) (insn, 0));\n \n-\t\t  ready_add (ready, insn);\n+\t\t  ready_add (ready, insn, false);\n \t\t  if (sched_verbose >= 2)\n \t\t    fprintf (sched_dump, \"moving to ready with %d stalls\\n\", stalls);\n \t\t}\n-\t      insn_queue[NEXT_Q_AFTER (q_ptr, stalls)] = 0;\n+\t      free_INSN_LIST_list (&insn_queue[NEXT_Q_AFTER (q_ptr, stalls)]);\n \n \t      advance_one_cycle ();\n \n@@ -1542,7 +1616,7 @@ early_queue_to_ready (state_t state, struct ready_list *ready)\n \t\t    {\n \t\t      /* move from Q to R */\n \t\t      q_size -= 1;\n-\t\t      ready_add (ready, insn);\n+\t\t      ready_add (ready, insn, false);\n \n \t\t      if (prev_link)   \n \t\t\tXEXP (prev_link, 1) = next_link;\n@@ -1557,7 +1631,8 @@ early_queue_to_ready (state_t state, struct ready_list *ready)\n \n \t\t      insns_removed++;\n \t\t      if (insns_removed == flag_sched_stalled_insns)\n-\t\t\t/* Remove only one insn from Q at a time.  */\n+\t\t\t/* Remove no more than flag_sched_stalled_insns insns\n+\t\t\t   from Q at a time.  */\n \t\t\treturn insns_removed;\n \t\t    }\n \t\t}\n@@ -1872,6 +1947,7 @@ schedule_block (int b, int rgn_n_insns)\n   state_reset (curr_state);\n \n   /* Allocate the ready list.  */\n+  readyp = &ready;\n   ready.veclen = rgn_n_insns + 1 + issue_rate;\n   ready.first = ready.veclen - 1;\n   ready.vec = XNEWVEC (rtx, ready.veclen);\n@@ -1884,8 +1960,6 @@ schedule_block (int b, int rgn_n_insns)\n   for (i = 0; i <= rgn_n_insns; i++)\n     choice_stack[i].state = xmalloc (dfa_state_size);\n \n-  (*current_sched_info->init_ready_list) (&ready);\n-\n   if (targetm.sched.md_init)\n     targetm.sched.md_init (sched_dump, sched_verbose, ready.veclen);\n \n@@ -1899,10 +1973,16 @@ schedule_block (int b, int rgn_n_insns)\n \n   insn_queue = alloca ((max_insn_queue_index + 1) * sizeof (rtx));\n   memset (insn_queue, 0, (max_insn_queue_index + 1) * sizeof (rtx));\n-  last_clock_var = -1;\n \n   /* Start just before the beginning of time.  */\n   clock_var = -1;\n+\n+  /* We need queue and ready lists and clock_var be initialized \n+     in try_ready () (which is called through init_ready_list ()).  */\n+  (*current_sched_info->init_ready_list) ();\n+\n+  last_clock_var = -1;\n+\n   advance = 0;\n \n   sort_p = TRUE;\n@@ -2002,9 +2082,20 @@ schedule_block (int b, int rgn_n_insns)\n \t      && targetm.sched.dfa_new_cycle (sched_dump, sched_verbose,\n \t\t\t\t\t      insn, last_clock_var,\n \t\t\t\t\t      clock_var, &sort_p))\n+\t    /* SORT_P is used by the target to override sorting\n+\t       of the ready list.  This is needed when the target\n+\t       has modified its internal structures expecting that\n+\t       the insn will be issued next.  As we need the insn\n+\t       to have the highest priority (so it will be returned by\n+\t       the ready_remove_first call above), we invoke\n+\t       ready_add (&ready, insn, true).\n+\t       But, still, there is one issue: INSN can be later \n+\t       discarded by scheduler's front end through \n+\t       current_sched_info->can_schedule_ready_p, hence, won't\n+\t       be issued next.  */ \n \t    {\n-\t      ready_add (&ready, insn);\n-\t      break;\n+\t      ready_add (&ready, insn, true);\n+              break;\n \t    }\n \n \t  sort_p = TRUE;\n@@ -2051,8 +2142,10 @@ schedule_block (int b, int rgn_n_insns)\n \t  last_scheduled_insn = move_insn (insn, last_scheduled_insn);\n \n \t  if (memcmp (curr_state, temp_state, dfa_state_size) != 0)\n-\t    cycle_issued_insns++;\n-\t  memcpy (curr_state, temp_state, dfa_state_size);\n+            {\n+              cycle_issued_insns++;\n+              memcpy (curr_state, temp_state, dfa_state_size);\n+            }\n \n \t  if (targetm.sched.variable_issue)\n \t    can_issue_more =\n@@ -2064,7 +2157,7 @@ schedule_block (int b, int rgn_n_insns)\n \t\t   && GET_CODE (PATTERN (insn)) != CLOBBER)\n \t    can_issue_more--;\n \n-\t  advance = schedule_insn (insn, &ready, clock_var);\n+\t  advance = schedule_insn (insn);\n \n \t  /* After issuing an asm insn we should start a new cycle.  */\n \t  if (advance == 0 && asm_p)\n@@ -2094,45 +2187,48 @@ schedule_block (int b, int rgn_n_insns)\n \t}\n     }\n \n-  if (targetm.sched.md_finish)\n-    targetm.sched.md_finish (sched_dump, sched_verbose);\n-\n   /* Debug info.  */\n   if (sched_verbose)\n     {\n       fprintf (sched_dump, \";;\\tReady list (final):  \");\n       debug_ready_list (&ready);\n     }\n \n-  /* Sanity check -- queue must be empty now.  Meaningless if region has\n-     multiple bbs.  */\n-  gcc_assert (!current_sched_info->queue_must_finish_empty || !q_size);\n-\n-  /* Update head/tail boundaries.  */\n-  head = NEXT_INSN (prev_head);\n-  tail = last_scheduled_insn;\n-\n-  if (!reload_completed)\n+  if (current_sched_info->queue_must_finish_empty)\n+    /* Sanity check -- queue must be empty now.  Meaningless if region has\n+       multiple bbs.  */\n+    gcc_assert (!q_size && !ready.n_ready);\n+  else \n     {\n-      rtx insn, link, next;\n+      /* We must maintain QUEUE_INDEX between blocks in region.  */\n+      for (i = ready.n_ready - 1; i >= 0; i--)\n+\tQUEUE_INDEX (ready_element (&ready, i)) = QUEUE_NOWHERE;\n+\n+      if (q_size)   \n+\tfor (i = 0; i <= max_insn_queue_index; i++)\n+\t  {\n+\t    rtx link;\n+\t    for (link = insn_queue[i]; link; link = XEXP (link, 1))\n+\t      QUEUE_INDEX (XEXP (link, 0)) = QUEUE_NOWHERE;\n+\t    free_INSN_LIST_list (&insn_queue[i]);\n+\t  }\n \n       /* INSN_TICK (minimum clock tick at which the insn becomes\n          ready) may be not correct for the insn in the subsequent\n          blocks of the region.  We should use a correct value of\n          `clock_var' or modify INSN_TICK.  It is better to keep\n          clock_var value equal to 0 at the start of a basic block.\n          Therefore we modify INSN_TICK here.  */\n-      for (insn = head; insn != tail; insn = NEXT_INSN (insn))\n-\tif (INSN_P (insn))\n-\t  {\n-\t    for (link = INSN_DEPEND (insn); link != 0; link = XEXP (link, 1))\n-\t      {\n-\t\tnext = XEXP (link, 0);\n-\t\tINSN_TICK (next) -= clock_var;\n-\t      }\n-\t  }\n+      fix_inter_tick (NEXT_INSN (prev_head), last_scheduled_insn);\n     }\n \n+  if (targetm.sched.md_finish)\n+    targetm.sched.md_finish (sched_dump, sched_verbose);\n+\n+  /* Update head/tail boundaries.  */\n+  head = NEXT_INSN (prev_head);\n+  tail = last_scheduled_insn;\n+\n   /* Restore-other-notes: NOTE_LIST is the end of a chain of notes\n      previously found among the insns.  Insert them at the beginning\n      of the insns.  */\n@@ -2183,16 +2279,15 @@ set_priorities (rtx head, rtx tail)\n \tcurrent_sched_info->sched_max_insns_priority;\n   rtx prev_head;\n \n-  prev_head = PREV_INSN (head);\n-\n   if (head == tail && (! INSN_P (head)))\n     return 0;\n \n   n_insn = 0;\n-  sched_max_insns_priority = 0;\n+\n+  prev_head = PREV_INSN (head);\n   for (insn = tail; insn != prev_head; insn = PREV_INSN (insn))\n     {\n-      if (NOTE_P (insn))\n+      if (!INSN_P (insn))\n \tcontinue;\n \n       n_insn++;\n@@ -2202,9 +2297,8 @@ set_priorities (rtx head, rtx tail)\n \tsched_max_insns_priority =\n \t  MAX (sched_max_insns_priority, INSN_PRIORITY (insn)); \n     }\n-  sched_max_insns_priority += 1;\n-  current_sched_info->sched_max_insns_priority =\n-\tsched_max_insns_priority;\n+\n+  current_sched_info->sched_max_insns_priority = sched_max_insns_priority;\n \n   return n_insn;\n }\n@@ -2253,7 +2347,12 @@ sched_init (void)\n   h_i_d = XCNEWVEC (struct haifa_insn_data, old_max_uid);\n \n   for (i = 0; i < old_max_uid; i++)\n-    h_i_d [i].cost = -1;\n+    {\n+      h_i_d[i].cost = -1;\n+      h_i_d[i].queue_index = QUEUE_NOWHERE;\n+      h_i_d[i].tick = INVALID_TICK;\n+      h_i_d[i].inter_tick = INVALID_TICK;\n+    }\n \n   if (targetm.sched.init_dfa_pre_cycle_insn)\n     targetm.sched.init_dfa_pre_cycle_insn ();\n@@ -2320,8 +2419,7 @@ sched_init (void)\n \t}\n     }\n \n-  /* ??? Add a NOTE after the last insn of the last basic block.  It is not\n-     known why this is done.  */\n+  /* The following is done to keep current_sched_info->next_tail non null.  */\n \n   insn = BB_END (EXIT_BLOCK_PTR->prev_bb);\n   if (NEXT_INSN (insn) == 0\n@@ -2330,9 +2428,9 @@ sched_init (void)\n \t  /* Don't emit a NOTE if it would end up before a BARRIER.  */\n \t  && !BARRIER_P (NEXT_INSN (insn))))\n     {\n-      emit_note_after (NOTE_INSN_DELETED, BB_END (EXIT_BLOCK_PTR->prev_bb));\n+      emit_note_after (NOTE_INSN_DELETED, insn);\n       /* Make insn to appear outside BB.  */\n-      BB_END (EXIT_BLOCK_PTR->prev_bb) = PREV_INSN (BB_END (EXIT_BLOCK_PTR->prev_bb));\n+      BB_END (EXIT_BLOCK_PTR->prev_bb) = insn;\n     }\n \n   /* Compute INSN_REG_WEIGHT for all blocks.  We must do this before\n@@ -2362,4 +2460,208 @@ sched_finish (void)\n \n   current_sched_info = NULL;\n }\n+\n+/* Fix INSN_TICKs of the instructions in the current block as well as\n+   INSN_TICKs of their dependants.\n+   HEAD and TAIL are the begin and the end of the current scheduled block.  */\n+static void\n+fix_inter_tick (rtx head, rtx tail)\n+{\n+  /* Set of instructions with corrected INSN_TICK.  */\n+  bitmap_head processed;\n+  int next_clock = clock_var + 1;\n+\n+  bitmap_initialize (&processed, 0);\n+  \n+  /* Iterates over scheduled instructions and fix their INSN_TICKs and\n+     INSN_TICKs of dependent instructions, so that INSN_TICKs are consistent\n+     across different blocks.  */\n+  for (tail = NEXT_INSN (tail); head != tail; head = NEXT_INSN (head))\n+    {\n+      if (INSN_P (head))\n+\t{\n+\t  int tick;\n+\t  rtx link;\n+                  \n+\t  tick = INSN_TICK (head);\n+\t  gcc_assert (tick >= MIN_TICK);\n+\t  \n+\t  /* Fix INSN_TICK of instruction from just scheduled block.  */\n+\t  if (!bitmap_bit_p (&processed, INSN_LUID (head)))\n+\t    {\n+\t      bitmap_set_bit (&processed, INSN_LUID (head));\n+\t      tick -= next_clock;\n+\t      \n+\t      if (tick < MIN_TICK)\n+\t\ttick = MIN_TICK;\n+\t      \n+\t      INSN_TICK (head) = tick;\t\t \n+\t    }\n+\t  \n+\t  for (link = INSN_DEPEND (head); link; link = XEXP (link, 1))\n+\t    {\n+\t      rtx next;\n+\t      \n+\t      next = XEXP (link, 0);\n+\t      tick = INSN_TICK (next);\n+\n+\t      if (tick != INVALID_TICK\n+\t\t  /* If NEXT has its INSN_TICK calculated, fix it.\n+\t\t     If not - it will be properly calculated from\n+\t\t     scratch later in fix_tick_ready.  */\n+\t\t  && !bitmap_bit_p (&processed, INSN_LUID (next)))\n+\t\t{\n+\t\t  bitmap_set_bit (&processed, INSN_LUID (next));\n+\t\t  tick -= next_clock;\n+\t\t  \n+\t\t  if (tick < MIN_TICK)\n+\t\t    tick = MIN_TICK;\n+\t\t  \n+\t\t  if (tick > INTER_TICK (next))\n+\t\t    INTER_TICK (next) = tick;\n+\t\t  else\n+\t\t    tick = INTER_TICK (next);\n+\t\t  \n+\t\t  INSN_TICK (next) = tick;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  bitmap_clear (&processed);\n+}\n+  \n+/* Check if NEXT is ready to be added to the ready or queue list.\n+   If \"yes\", add it to the proper list.\n+   Returns:\n+      -1 - is not ready yet,\n+       0 - added to the ready list,\n+   0 < N - queued for N cycles.  */\n+int\n+try_ready (rtx next)\n+{\n+  if (LOG_LINKS (next)\n+      || (current_sched_info->new_ready\n+\t  && !current_sched_info->new_ready (next)))\n+    {\n+      gcc_assert (QUEUE_INDEX (next) == QUEUE_NOWHERE);\n+      return -1;\n+    }\n+\n+  if (sched_verbose >= 2)\n+    fprintf (sched_dump, \";;\\t\\tdependencies resolved: insn %s\\n\",\n+\t     (*current_sched_info->print_insn) (next, 0));          \n+        \n+  adjust_priority (next);\n+\n+  return fix_tick_ready (next);\n+}\n+\n+/* Calculate INSN_TICK of NEXT and add it to either ready or queue list.  */\n+static int\n+fix_tick_ready (rtx next)\n+{\n+  rtx link;\n+  int tick, delay;\n+\n+  link = RESOLVED_DEPS (next);\n+      \n+  if (link)\n+    {\n+      int full_p;\n+\n+      tick = INSN_TICK (next);\n+      /* if tick is note equals to INVALID_TICK, then update\n+\t INSN_TICK of NEXT with the most recent resolved dependence\n+\t cost.  Overwise, recalculate from scratch.  */\n+      full_p = tick == INVALID_TICK;\n+      do\n+        {        \n+          rtx pro;\n+          int tick1;\n+              \n+          pro = XEXP (link, 0);\n+\t  gcc_assert (INSN_TICK (pro) >= MIN_TICK);\n+          /* We should specify FORWARD link to insn_cost,\n+\t     but are giving a BACKWARD one.\n+             This is ok, because only REG_NOTE_KIND of link is used.\n+             May be substitute LINK with REG_NOTE_KIND?  */\n+          tick1 = INSN_TICK (pro) + insn_cost (pro, link, next);\n+          if (tick1 > tick)\n+            tick = tick1;\n+        }\n+      while ((link = XEXP (link, 1)) && full_p);\n+    }\n+  else\n+    tick = -1;\n+\n+  INSN_TICK (next) = tick;\n+\n+  delay = tick - clock_var;\n+  if (delay <= 0)\n+    delay = QUEUE_READY;\n+\n+  change_queue_index (next, delay);\n+  \n+  return delay;\n+}\n+\n+/* Move NEXT to the proper queue list with (DELAY >= 1),\n+   or add it to the ready list (DELAY == QUEUE_READY),\n+   or remove it from ready and queue lists at all (DELAY == QUEUE_NOWHERE).  */\n+static void\n+change_queue_index (rtx next, int delay)\n+{\n+  int i = QUEUE_INDEX (next);\n+\n+  gcc_assert (QUEUE_NOWHERE <= delay && delay <= max_insn_queue_index \n+\t      && delay != 0);\n+  gcc_assert (i != QUEUE_SCHEDULED);\n+  \n+  if ((delay > 0 && NEXT_Q_AFTER (q_ptr, delay) == i)\n+      || (delay < 0 && delay == i))\n+    /* We have nothing to do.  */\n+    return;\n+\n+  /* Remove NEXT from whereever it is now.  */\n+  if (i == QUEUE_READY)\n+    ready_remove_insn (next);\n+  else if (i >= 0)\n+    queue_remove (next);\n+    \n+  /* Add it to the proper place.  */\n+  if (delay == QUEUE_READY)\n+    ready_add (readyp, next, false);\n+  else if (delay >= 1)\n+    queue_insn (next, delay);\n+    \n+  if (sched_verbose >= 2)\n+    {\t      \n+      fprintf (sched_dump, \";;\\t\\ttick updated: insn %s\",\n+\t       (*current_sched_info->print_insn) (next, 0));\n+      \n+      if (delay == QUEUE_READY)\n+\tfprintf (sched_dump, \" into ready\\n\");\n+      else if (delay >= 1)\n+\tfprintf (sched_dump, \" into queue with cost=%d\\n\", delay);\n+      else\n+\tfprintf (sched_dump, \" removed from ready or queue lists\\n\");\n+    }\n+}\n+\n+/* INSN is being scheduled.  Resolve the dependence between INSN and NEXT.  */\n+static void\n+resolve_dep (rtx next, rtx insn)\n+{\n+  rtx dep;\n+\n+  INSN_DEP_COUNT (next)--;\n+  \n+  dep = remove_list_elem (insn, &LOG_LINKS (next));\n+  XEXP (dep, 1) = RESOLVED_DEPS (next);\n+  RESOLVED_DEPS (next) = dep;\n+  \n+  gcc_assert ((INSN_DEP_COUNT (next) != 0 || !LOG_LINKS (next))\n+\t      && (LOG_LINKS (next) || INSN_DEP_COUNT (next) == 0));\n+}\n+\n #endif /* INSN_SCHEDULING */"}, {"sha": "c9df54a779cdeb6d3ce8eb5403b0e350f7a8ad75", "filename": "gcc/lists.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63f54b1abd832e2c6f7938aac2e2c455b23c91b7/gcc%2Flists.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63f54b1abd832e2c6f7938aac2e2c455b23c91b7/gcc%2Flists.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flists.c?ref=63f54b1abd832e2c6f7938aac2e2c455b23c91b7", "patch": "@@ -98,7 +98,7 @@ remove_list_node (rtx *listp)\n \n /* Removes corresponding to ELEM node from the list pointed to by LISTP.\n    Returns that node.  */\n-static rtx\n+rtx\n remove_list_elem (rtx elem, rtx *listp)\n {\n   rtx node;\n@@ -241,4 +241,12 @@ remove_free_DEPS_LIST_elem (rtx elem, rtx *listp)\n   free_DEPS_LIST_node (remove_list_elem (elem, listp));\n }\n \n+/* Remove and free corresponding to ELEM node in the INSN_LIST pointed to\n+   by LISTP.  */\n+void\n+remove_free_INSN_LIST_elem (rtx elem, rtx *listp)\n+{\n+  free_INSN_LIST_node (remove_list_elem (elem, listp));\n+}\n+\n #include \"gt-lists.h\""}, {"sha": "1ee04fc9382007ea60818ef6dcf135e85bfd20aa", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63f54b1abd832e2c6f7938aac2e2c455b23c91b7/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63f54b1abd832e2c6f7938aac2e2c455b23c91b7/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=63f54b1abd832e2c6f7938aac2e2c455b23c91b7", "patch": "@@ -1756,6 +1756,8 @@ rtx alloc_EXPR_LIST\t\t\t(int, rtx, rtx);\n void free_DEPS_LIST_list (rtx *);\n rtx alloc_DEPS_LIST (rtx, rtx, HOST_WIDE_INT);\n void remove_free_DEPS_LIST_elem (rtx, rtx *);\n+void remove_free_INSN_LIST_elem (rtx, rtx *);\n+rtx remove_list_elem (rtx, rtx *);\n \n /* regclass.c */\n "}, {"sha": "0b2e1bf193d2fc2e7aa8a3d8b45ab2c704f0677e", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63f54b1abd832e2c6f7938aac2e2c455b23c91b7/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63f54b1abd832e2c6f7938aac2e2c455b23c91b7/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=63f54b1abd832e2c6f7938aac2e2c455b23c91b7", "patch": "@@ -49,9 +49,8 @@ static int target_n_insns;\n static int sched_n_insns;\n \n /* Implementations of the sched_info functions for region scheduling.  */\n-static void init_ready_list (struct ready_list *);\n+static void init_ready_list (void);\n static int can_schedule_ready_p (rtx);\n-static int new_ready (rtx);\n static int schedule_more_p (void);\n static const char *ebb_print_insn (rtx, int);\n static int rank (rtx, rtx);\n@@ -76,7 +75,7 @@ schedule_more_p (void)\n    once before scheduling a set of insns.  */\n \n static void\n-init_ready_list (struct ready_list *ready)\n+init_ready_list (void)\n {\n   rtx prev_head = current_sched_info->prev_head;\n   rtx next_tail = current_sched_info->next_tail;\n@@ -95,8 +94,7 @@ init_ready_list (struct ready_list *ready)\n      Count number of insns in the target block being scheduled.  */\n   for (insn = NEXT_INSN (prev_head); insn != next_tail; insn = NEXT_INSN (insn))\n     {\n-      if (INSN_DEP_COUNT (insn) == 0)\n-\tready_add (ready, insn);\n+      try_ready (insn);\n       target_n_insns++;\n     }\n }\n@@ -111,15 +109,6 @@ can_schedule_ready_p (rtx insn ATTRIBUTE_UNUSED)\n   return 1;\n }\n \n-/* Called after INSN has all its dependencies resolved.  Return nonzero\n-   if it should be moved to the ready list or the queue, or zero if we\n-   should silently discard it.  */\n-static int\n-new_ready (rtx next ATTRIBUTE_UNUSED)\n-{\n-  return 1;\n-}\n-\n /* Return a string that contains the insn uid and optionally anything else\n    necessary to identify this insn in an output.  It's valid to use a\n    static buffer for this.  The ALIGNED parameter should cause the string\n@@ -197,7 +186,7 @@ static struct sched_info ebb_sched_info =\n   init_ready_list,\n   can_schedule_ready_p,\n   schedule_more_p,\n-  new_ready,\n+  NULL,\n   rank,\n   ebb_print_insn,\n   contributes_to_priority,\n@@ -524,7 +513,9 @@ schedule_ebb (rtx head, rtx tail)\n     targetm.sched.dependencies_evaluation_hook (head, tail);\n \n   /* Set priorities.  */\n+  current_sched_info->sched_max_insns_priority = 0;\n   n_insns = set_priorities (head, tail);\n+  current_sched_info->sched_max_insns_priority++;\n \n   current_sched_info->prev_head = PREV_INSN (head);\n   current_sched_info->next_tail = NEXT_INSN (tail);"}, {"sha": "17c7f7bfb1e33bc98843714ddd4d343cc5c4a5cc", "filename": "gcc/sched-int.h", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63f54b1abd832e2c6f7938aac2e2c455b23c91b7/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63f54b1abd832e2c6f7938aac2e2c455b23c91b7/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=63f54b1abd832e2c6f7938aac2e2c455b23c91b7", "patch": "@@ -142,7 +142,7 @@ struct sched_info\n {\n   /* Add all insns that are initially ready to the ready list.  Called once\n      before scheduling a set of insns.  */\n-  void (*init_ready_list) (struct ready_list *);\n+  void (*init_ready_list) (void);\n   /* Called after taking an insn from the ready list.  Returns nonzero if\n      this insn can be scheduled, nonzero if we should silently discard it.  */\n   int (*can_schedule_ready_p) (rtx);\n@@ -203,6 +203,10 @@ struct haifa_insn_data\n      it represents forward dependencies.  */\n   rtx depend;\n \n+  /* A list of scheduled producers of the instruction.  Links are being moved\n+     from LOG_LINKS to RESOLVED_DEPS during scheduling.  */\n+  rtx resolved_deps;\n+  \n   /* The line number note in effect for each insn.  For line number\n      notes, this indicates whether the note may be reused.  */\n   rtx line_note;\n@@ -225,6 +229,13 @@ struct haifa_insn_data\n      used to note timing constraints for the insns in the pending list.  */\n   int tick;\n \n+  /* INTER_TICK is used to adjust INSN_TICKs of instructions from the\n+     subsequent blocks in a region.  */\n+  int inter_tick;\n+  \n+  /* See comment on QUEUE_INDEX macro in haifa-sched.c.  */\n+  int queue_index;\n+\n   short cost;\n \n   /* This weight is an estimation of the insn's contribution to\n@@ -252,6 +263,7 @@ extern struct haifa_insn_data *h_i_d;\n /* Accessor macros for h_i_d.  There are more in haifa-sched.c and\n    sched-rgn.c.  */\n #define INSN_DEPEND(INSN)\t(h_i_d[INSN_UID (INSN)].depend)\n+#define RESOLVED_DEPS(INSN)     (h_i_d[INSN_UID (INSN)].resolved_deps)\n #define INSN_LUID(INSN)\t\t(h_i_d[INSN_UID (INSN)].luid)\n #define CANT_MOVE(insn)\t\t(h_i_d[INSN_UID (insn)].cant_move)\n #define INSN_DEP_COUNT(INSN)\t(h_i_d[INSN_UID (INSN)].dep_count)\n@@ -513,6 +525,6 @@ extern void schedule_block (int, int);\n extern void sched_init (void);\n extern void sched_finish (void);\n \n-extern void ready_add (struct ready_list *, rtx);\n+extern int try_ready (rtx);\n \n #endif /* GCC_SCHED_INT_H */"}, {"sha": "314d72851db278c57bdebffd34f28a3c92f292a5", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 10, "deletions": 33, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63f54b1abd832e2c6f7938aac2e2c455b23c91b7/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63f54b1abd832e2c6f7938aac2e2c455b23c91b7/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=63f54b1abd832e2c6f7938aac2e2c455b23c91b7", "patch": "@@ -1884,7 +1884,7 @@ static int sched_n_insns;\n static int last_was_jump;\n \n /* Implementations of the sched_info functions for region scheduling.  */\n-static void init_ready_list (struct ready_list *);\n+static void init_ready_list (void);\n static int can_schedule_ready_p (rtx);\n static int new_ready (rtx);\n static int schedule_more_p (void);\n@@ -1905,7 +1905,7 @@ schedule_more_p (void)\n    once before scheduling a set of insns.  */\n \n static void\n-init_ready_list (struct ready_list *ready)\n+init_ready_list (void)\n {\n   rtx prev_head = current_sched_info->prev_head;\n   rtx next_tail = current_sched_info->next_tail;\n@@ -1943,15 +1943,8 @@ init_ready_list (struct ready_list *ready)\n   /* Initialize ready list with all 'ready' insns in target block.\n      Count number of insns in the target block being scheduled.  */\n   for (insn = NEXT_INSN (prev_head); insn != next_tail; insn = NEXT_INSN (insn))\n-    {\n-      if (INSN_DEP_COUNT (insn) == 0)\n-\t{\n-\t  ready_add (ready, insn);\n-\n-\t  if (targetm.sched.adjust_priority)\n-\t    INSN_PRIORITY (insn) =\n-\t      targetm.sched.adjust_priority (insn, INSN_PRIORITY (insn));\n-\t}\n+    {      \n+      try_ready (insn);\n       target_n_insns++;\n     }\n \n@@ -1970,26 +1963,8 @@ init_ready_list (struct ready_list *ready)\n \tsrc_head = head;\n \n \tfor (insn = src_head; insn != src_next_tail; insn = NEXT_INSN (insn))\n-\t  {\n-\t    if (! INSN_P (insn))\n-\t      continue;\n-\n-\t    if (!CANT_MOVE (insn)\n-\t\t&& (!IS_SPECULATIVE_INSN (insn)\n-\t\t    || ((recog_memoized (insn) < 0\n-\t\t\t || min_insn_conflict_delay (curr_state,\n-\t\t\t\t\t\t     insn, insn) <= 3)\n-\t\t\t&& check_live (insn, bb_src)\n-\t\t\t&& is_exception_free (insn, bb_src, target_bb))))\n-\t      if (INSN_DEP_COUNT (insn) == 0)\n-\t\t{\n-\t\t  ready_add (ready, insn); \n-\n-\t\t  if (targetm.sched.adjust_priority)\n-\t\t    INSN_PRIORITY (insn) =\n-\t\t      targetm.sched.adjust_priority (insn, INSN_PRIORITY (insn));\n-\t\t}\n-\t  }\n+\t  if (INSN_P (insn))\n+\t    try_ready (insn);\n       }\n }\n \n@@ -2638,13 +2613,15 @@ schedule_region (int rgn)\n     }\n \n   /* Set priorities.  */\n+  current_sched_info->sched_max_insns_priority = 0;\n   for (bb = 0; bb < current_nr_blocks; bb++)\n     {\n       rtx head, tail;\n       get_block_head_tail (BB_TO_BLOCK (bb), &head, &tail);\n \n       rgn_n_insns += set_priorities (head, tail);\n     }\n+  current_sched_info->sched_max_insns_priority++;\n \n   /* Compute interblock info: probabilities, split-edges, dominators, etc.  */\n   if (current_nr_blocks > 1)\n@@ -2727,8 +2704,8 @@ schedule_region (int rgn)\n \n       target_bb = bb;\n \n-      current_sched_info->queue_must_finish_empty\n-\t= current_nr_blocks > 1 && !flag_schedule_interblock;\n+      gcc_assert (flag_schedule_interblock || current_nr_blocks == 1);\n+      current_sched_info->queue_must_finish_empty = current_nr_blocks == 1;\n \n       schedule_block (b, rgn_n_insns);\n       sched_rgn_n_insns += sched_n_insns;"}]}