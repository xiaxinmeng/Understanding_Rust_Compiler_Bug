{"sha": "2e2f53d50c6fd17eb87d256d57696acc650a50e1", "node_id": "C_kwDOANBUbNoAKDJlMmY1M2Q1MGM2ZmQxN2ViODdkMjU2ZDU3Njk2YWNjNjUwYTUwZTE", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2022-02-16T12:56:50Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-13T08:04:39Z"}, "message": "[Ada] Remove dependency on tampering checks and controlled types for formal\n\nFormal hashed sets and maps are now using a different type of hash table\nthat does not require controlled types. This is possible because formal\ncontainers do not rely on tampering checks, as cursors do not hold a\npointer to a single matching container, but are logical indexes that can\nbe used with multiple containers.\n\nFor simplicity of the package organisation, and symmetry with other\nversions of containers, add a formal version of hashed types in the\nshared Ada.Containers.Hash_Tables unit. This unit should be specialized\nto only include the formal version of hash tables for runtimes that\ndo not support controlled types (so that the dependency on\nAda.Containers.Helpers can be removed).\n\nThe new versions of units for generic keys and operations are modified\nversions of the units for bounded containers, with all tampering checks\nremoved (they were no-op in formal containers). A declaration of\nconstant Checks is added at the start of the body, as these units cannot\nuse the version in Ada.Containers.Helpers.\n\ngcc/ada/\n\n\t* Makefile.rtl: Add new files.\n\t* libgnat/a-cfhama.adb: Use formal version of hash tables.\n\t* libgnat/a-cfhama.ads: Same.\n\t* libgnat/a-cfhase.adb: Same.\n\t* libgnat/a-cfhase.ads: Same.\n\t* libgnat/a-chtgfk.adb: New unit for formal containers, modified\n\tversion of Generic_Bounded_Keys.\n\t* libgnat/a-chtgfk.ads: Same.\n\t* libgnat/a-chtgfo.adb: New unit for formal containers, modified\n\tversion of Generic_Bounded_Operations.\n\t* libgnat/a-chtgfo.ads: Same.\n\t* libgnat/a-cohata.ads (Generic_Formal_Hash_Table_Types): Third\n\tversion of the type for hash tables, equivalent to the bounded\n\tversion without tampering checks.", "tree": {"sha": "b9feda92254b0b4e2ea3aeb9f9e259c3eefed573", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9feda92254b0b4e2ea3aeb9f9e259c3eefed573"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e2f53d50c6fd17eb87d256d57696acc650a50e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e2f53d50c6fd17eb87d256d57696acc650a50e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e2f53d50c6fd17eb87d256d57696acc650a50e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e2f53d50c6fd17eb87d256d57696acc650a50e1/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d22fb118f5c292c6c35c9177074485be0159810", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d22fb118f5c292c6c35c9177074485be0159810", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d22fb118f5c292c6c35c9177074485be0159810"}], "stats": {"total": 1185, "additions": 1170, "deletions": 15}, "files": [{"sha": "0394d967a5f4101b153a675e831058f683c5acd3", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e2f53d50c6fd17eb87d256d57696acc650a50e1/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e2f53d50c6fd17eb87d256d57696acc650a50e1/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=2e2f53d50c6fd17eb87d256d57696acc650a50e1", "patch": "@@ -126,6 +126,8 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-chlat9$(objext) \\\n   a-chtgbk$(objext) \\\n   a-chtgbo$(objext) \\\n+  a-chtgfk$(objext) \\\n+  a-chtgfo$(objext) \\\n   a-chtgke$(objext) \\\n   a-chtgop$(objext) \\\n   a-chzla1$(objext) \\"}, {"sha": "c688a86d1e1c041c0f37519b1dd7f8b2a3cd6038", "filename": "gcc/ada/libgnat/a-cfhama.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e2f53d50c6fd17eb87d256d57696acc650a50e1/gcc%2Fada%2Flibgnat%2Fa-cfhama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e2f53d50c6fd17eb87d256d57696acc650a50e1/gcc%2Fada%2Flibgnat%2Fa-cfhama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfhama.adb?ref=2e2f53d50c6fd17eb87d256d57696acc650a50e1", "patch": "@@ -25,11 +25,11 @@\n -- <http://www.gnu.org/licenses/>.                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Containers.Hash_Tables.Generic_Bounded_Operations;\n-pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Bounded_Operations);\n+with Ada.Containers.Hash_Tables.Generic_Formal_Operations;\n+pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Formal_Operations);\n \n-with Ada.Containers.Hash_Tables.Generic_Bounded_Keys;\n-pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Bounded_Keys);\n+with Ada.Containers.Hash_Tables.Generic_Formal_Keys;\n+pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Formal_Keys);\n \n with Ada.Containers.Prime_Numbers; use Ada.Containers.Prime_Numbers;\n \n@@ -75,14 +75,14 @@ is\n    --------------------------\n \n    package HT_Ops is\n-     new Hash_Tables.Generic_Bounded_Operations\n+     new Hash_Tables.Generic_Formal_Operations\n        (HT_Types  => HT_Types,\n         Hash_Node => Hash_Node,\n         Next      => Next,\n         Set_Next  => Set_Next);\n \n    package Key_Ops is\n-     new Hash_Tables.Generic_Bounded_Keys\n+     new Hash_Tables.Generic_Formal_Keys\n        (HT_Types        => HT_Types,\n         Next            => Next,\n         Set_Next        => Set_Next,"}, {"sha": "bf1e85f3ab81b9a1b8e61ff0fe463abbd3d49f97", "filename": "gcc/ada/libgnat/a-cfhama.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e2f53d50c6fd17eb87d256d57696acc650a50e1/gcc%2Fada%2Flibgnat%2Fa-cfhama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e2f53d50c6fd17eb87d256d57696acc650a50e1/gcc%2Fada%2Flibgnat%2Fa-cfhama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfhama.ads?ref=2e2f53d50c6fd17eb87d256d57696acc650a50e1", "patch": "@@ -900,7 +900,7 @@ private\n    end record;\n \n    package HT_Types is new\n-     Ada.Containers.Hash_Tables.Generic_Bounded_Hash_Table_Types (Node_Type);\n+     Ada.Containers.Hash_Tables.Generic_Formal_Hash_Table_Types (Node_Type);\n \n    type Map (Capacity : Count_Type; Modulus : Hash_Type) is record\n      Content : HT_Types.Hash_Table_Type (Capacity, Modulus);"}, {"sha": "786abf1dc99db1aca98ec858ea6ff3039df3fa60", "filename": "gcc/ada/libgnat/a-cfhase.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e2f53d50c6fd17eb87d256d57696acc650a50e1/gcc%2Fada%2Flibgnat%2Fa-cfhase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e2f53d50c6fd17eb87d256d57696acc650a50e1/gcc%2Fada%2Flibgnat%2Fa-cfhase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfhase.adb?ref=2e2f53d50c6fd17eb87d256d57696acc650a50e1", "patch": "@@ -25,11 +25,11 @@\n -- <http://www.gnu.org/licenses/>.                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Containers.Hash_Tables.Generic_Bounded_Operations;\n-pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Bounded_Operations);\n+with Ada.Containers.Hash_Tables.Generic_Formal_Operations;\n+pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Formal_Operations);\n \n-with Ada.Containers.Hash_Tables.Generic_Bounded_Keys;\n-pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Bounded_Keys);\n+with Ada.Containers.Hash_Tables.Generic_Formal_Keys;\n+pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Formal_Keys);\n \n with Ada.Containers.Prime_Numbers; use Ada.Containers.Prime_Numbers;\n \n@@ -95,13 +95,13 @@ is\n    -- Local Instantiations --\n    --------------------------\n \n-   package HT_Ops is new Hash_Tables.Generic_Bounded_Operations\n+   package HT_Ops is new Hash_Tables.Generic_Formal_Operations\n      (HT_Types  => HT_Types,\n       Hash_Node => Hash_Node,\n       Next      => Next,\n       Set_Next  => Set_Next);\n \n-   package Element_Keys is new Hash_Tables.Generic_Bounded_Keys\n+   package Element_Keys is new Hash_Tables.Generic_Formal_Keys\n      (HT_Types        => HT_Types,\n       Next            => Next,\n       Set_Next        => Set_Next,\n@@ -815,7 +815,7 @@ is\n       -- Local Instantiations --\n       --------------------------\n \n-      package Key_Keys is new Hash_Tables.Generic_Bounded_Keys\n+      package Key_Keys is new Hash_Tables.Generic_Formal_Keys\n         (HT_Types        => HT_Types,\n          Next            => Next,\n          Set_Next        => Set_Next,"}, {"sha": "1a40118013eacb90e2dafe8859d850f87e25e751", "filename": "gcc/ada/libgnat/a-cfhase.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e2f53d50c6fd17eb87d256d57696acc650a50e1/gcc%2Fada%2Flibgnat%2Fa-cfhase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e2f53d50c6fd17eb87d256d57696acc650a50e1/gcc%2Fada%2Flibgnat%2Fa-cfhase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfhase.ads?ref=2e2f53d50c6fd17eb87d256d57696acc650a50e1", "patch": "@@ -1479,7 +1479,7 @@ private\n       end record;\n \n    package HT_Types is new\n-     Ada.Containers.Hash_Tables.Generic_Bounded_Hash_Table_Types (Node_Type);\n+     Ada.Containers.Hash_Tables.Generic_Formal_Hash_Table_Types (Node_Type);\n \n    type Set (Capacity : Count_Type; Modulus : Hash_Type) is record\n      Content : HT_Types.Hash_Table_Type (Capacity, Modulus);"}, {"sha": "57967f9883ebee5e60c46aa3605a8ff5fcd90db0", "filename": "gcc/ada/libgnat/a-chtgfk.adb", "status": "added", "additions": 316, "deletions": 0, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e2f53d50c6fd17eb87d256d57696acc650a50e1/gcc%2Fada%2Flibgnat%2Fa-chtgfk.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e2f53d50c6fd17eb87d256d57696acc650a50e1/gcc%2Fada%2Flibgnat%2Fa-chtgfk.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-chtgfk.adb?ref=2e2f53d50c6fd17eb87d256d57696acc650a50e1", "patch": "@@ -0,0 +1,316 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--               ADA.CONTAINERS.HASH_TABLES.GENERIC_FORMAL_KEYS             --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2022, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+package body Ada.Containers.Hash_Tables.Generic_Formal_Keys is\n+\n+   Checks : constant Boolean := Container_Checks'Enabled;\n+\n+   -----------------------------\n+   -- Checked_Equivalent_Keys --\n+   -----------------------------\n+\n+   function Checked_Equivalent_Keys\n+     (HT   : Hash_Table_Type'Class;\n+      Key  : Key_Type;\n+      Node : Count_Type) return Boolean\n+   is\n+   begin\n+      return Equivalent_Keys (Key, HT.Nodes (Node));\n+   end Checked_Equivalent_Keys;\n+\n+   -------------------\n+   -- Checked_Index --\n+   -------------------\n+\n+   function Checked_Index\n+     (HT  : Hash_Table_Type'Class;\n+      Key : Key_Type) return Hash_Type\n+   is\n+   begin\n+      return HT.Buckets'First + Hash (Key) mod HT.Buckets'Length;\n+   end Checked_Index;\n+\n+   --------------------------\n+   -- Delete_Key_Sans_Free --\n+   --------------------------\n+\n+   procedure Delete_Key_Sans_Free\n+     (HT  : in out Hash_Table_Type'Class;\n+      Key : Key_Type;\n+      X   : out Count_Type)\n+   is\n+      Indx : Hash_Type;\n+      Prev : Count_Type;\n+\n+   begin\n+      if HT.Length = 0 then\n+         X := 0;\n+         return;\n+      end if;\n+\n+      Indx := Checked_Index (HT, Key);\n+      X := HT.Buckets (Indx);\n+\n+      if X = 0 then\n+         return;\n+      end if;\n+\n+      if Checked_Equivalent_Keys (HT, Key, X) then\n+         HT.Buckets (Indx) := Next (HT.Nodes (X));\n+         HT.Length := HT.Length - 1;\n+         return;\n+      end if;\n+\n+      loop\n+         Prev := X;\n+         X := Next (HT.Nodes (Prev));\n+\n+         if X = 0 then\n+            return;\n+         end if;\n+\n+         if Checked_Equivalent_Keys (HT, Key, X) then\n+            Set_Next (HT.Nodes (Prev), Next => Next (HT.Nodes (X)));\n+            HT.Length := HT.Length - 1;\n+            return;\n+         end if;\n+      end loop;\n+   end Delete_Key_Sans_Free;\n+\n+   ----------\n+   -- Find --\n+   ----------\n+\n+   function Find\n+     (HT  : Hash_Table_Type'Class;\n+      Key : Key_Type) return Count_Type\n+   is\n+      Indx : Hash_Type;\n+      Node : Count_Type;\n+\n+   begin\n+      if HT.Length = 0 then\n+         return 0;\n+      end if;\n+\n+      Indx := Checked_Index (HT'Unrestricted_Access.all, Key);\n+\n+      Node := HT.Buckets (Indx);\n+      while Node /= 0 loop\n+         if Checked_Equivalent_Keys\n+           (HT'Unrestricted_Access.all, Key, Node)\n+         then\n+            return Node;\n+         end if;\n+         Node := Next (HT.Nodes (Node));\n+      end loop;\n+\n+      return 0;\n+   end Find;\n+\n+   --------------------------------\n+   -- Generic_Conditional_Insert --\n+   --------------------------------\n+\n+   procedure Generic_Conditional_Insert\n+     (HT       : in out Hash_Table_Type'Class;\n+      Key      : Key_Type;\n+      Node     : out Count_Type;\n+      Inserted : out Boolean)\n+   is\n+      Indx : Hash_Type;\n+\n+   begin\n+      Indx := Checked_Index (HT, Key);\n+      Node := HT.Buckets (Indx);\n+\n+      if Node = 0 then\n+         if Checks and then HT.Length = HT.Capacity then\n+            raise Capacity_Error with \"no more capacity for insertion\";\n+         end if;\n+\n+         Node := New_Node;\n+         Set_Next (HT.Nodes (Node), Next => 0);\n+\n+         Inserted := True;\n+\n+         HT.Buckets (Indx) := Node;\n+         HT.Length := HT.Length + 1;\n+\n+         return;\n+      end if;\n+\n+      loop\n+         if Checked_Equivalent_Keys (HT, Key, Node) then\n+            Inserted := False;\n+            return;\n+         end if;\n+\n+         Node := Next (HT.Nodes (Node));\n+\n+         exit when Node = 0;\n+      end loop;\n+\n+      if Checks and then HT.Length = HT.Capacity then\n+         raise Capacity_Error with \"no more capacity for insertion\";\n+      end if;\n+\n+      Node := New_Node;\n+      Set_Next (HT.Nodes (Node), Next => HT.Buckets (Indx));\n+\n+      Inserted := True;\n+\n+      HT.Buckets (Indx) := Node;\n+      HT.Length := HT.Length + 1;\n+   end Generic_Conditional_Insert;\n+\n+   -----------------------------\n+   -- Generic_Replace_Element --\n+   -----------------------------\n+\n+   procedure Generic_Replace_Element\n+     (HT   : in out Hash_Table_Type'Class;\n+      Node : Count_Type;\n+      Key  : Key_Type)\n+   is\n+      pragma Assert (HT.Length > 0);\n+      pragma Assert (Node /= 0);\n+\n+      BB : Buckets_Type renames HT.Buckets;\n+      NN : Nodes_Type renames HT.Nodes;\n+\n+      Old_Indx : Hash_Type;\n+      New_Indx : constant Hash_Type := Checked_Index (HT, Key);\n+\n+      New_Bucket : Count_Type renames BB (New_Indx);\n+      N, M       : Count_Type;\n+\n+   begin\n+      --  The following block appears to be vestigial -- this should be done\n+      --  using Checked_Index instead. Also, we might have to move the actual\n+      --  tampering checks to the top of the subprogram, in order to prevent\n+      --  infinite recursion when calling Hash. (This is similar to how Insert\n+      --  and Delete are implemented.) This implies that we will have to defer\n+      --  the computation of New_Index until after the tampering check. ???\n+\n+      Old_Indx := HT.Buckets'First + Hash (NN (Node)) mod HT.Buckets'Length;\n+\n+      --  Replace_Element is allowed to change a node's key to Key\n+      --  (generic formal operation Assign provides the mechanism), but\n+      --  only if Key is not already in the hash table. (In a unique-key\n+      --  hash table as this one, a key is mapped to exactly one node.)\n+\n+      if Checked_Equivalent_Keys (HT, Key, Node) then\n+         --  The new Key value is mapped to this same Node, so Node\n+         --  stays in the same bucket.\n+\n+         Assign (NN (Node), Key);\n+         return;\n+      end if;\n+\n+      --  Key is not equivalent to Node, so we now have to determine if it's\n+      --  equivalent to some other node in the hash table. This is the case\n+      --  irrespective of whether Key is in the same or a different bucket from\n+      --  Node.\n+\n+      N := New_Bucket;\n+      while N /= 0 loop\n+         if Checks and then Checked_Equivalent_Keys (HT, Key, N) then\n+            pragma Assert (N /= Node);\n+            raise Program_Error with\n+              \"attempt to replace existing element\";\n+         end if;\n+\n+         N := Next (NN (N));\n+      end loop;\n+\n+      --  We have determined that Key is not already in the hash table, so\n+      --  the change is tentatively allowed. We now perform the standard\n+      --  checks to determine whether the hash table is locked (because you\n+      --  cannot change an element while it's in use by Query_Element or\n+      --  Update_Element), or if the container is busy (because moving a\n+      --  node to a different bucket would interfere with iteration).\n+\n+      if Old_Indx = New_Indx then\n+         --  The node is already in the bucket implied by Key. In this case\n+         --  we merely change its value without moving it.\n+\n+         Assign (NN (Node), Key);\n+         return;\n+      end if;\n+\n+      --  The node is in a bucket different from the bucket implied by Key.\n+      --  Do the assignment first, before moving the node, so that if Assign\n+      --  propagates an exception, then the hash table will not have been\n+      --  modified (except for any possible side-effect Assign had on Node).\n+\n+      Assign (NN (Node), Key);\n+\n+      --  Now we can safely remove the node from its current bucket\n+\n+      N := BB (Old_Indx);  -- get value of first node in old bucket\n+      pragma Assert (N /= 0);\n+\n+      if N = Node then  -- node is first node in its bucket\n+         BB (Old_Indx) := Next (NN (Node));\n+\n+      else\n+         pragma Assert (HT.Length > 1);\n+\n+         loop\n+            M := Next (NN (N));\n+            pragma Assert (M /= 0);\n+\n+            if M = Node then\n+               Set_Next (NN (N), Next => Next (NN (Node)));\n+               exit;\n+            end if;\n+\n+            N := M;\n+         end loop;\n+      end if;\n+\n+      --  Now we link the node into its new bucket (corresponding to Key)\n+\n+      Set_Next (NN (Node), Next => New_Bucket);\n+      New_Bucket := Node;\n+   end Generic_Replace_Element;\n+\n+   -----------\n+   -- Index --\n+   -----------\n+\n+   function Index\n+     (HT  : Hash_Table_Type'Class;\n+      Key : Key_Type) return Hash_Type is\n+   begin\n+      return HT.Buckets'First + Hash (Key) mod HT.Buckets'Length;\n+   end Index;\n+\n+end Ada.Containers.Hash_Tables.Generic_Formal_Keys;"}, {"sha": "633887f54992459428fc3064fe862ca00f6cfd26", "filename": "gcc/ada/libgnat/a-chtgfk.ads", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e2f53d50c6fd17eb87d256d57696acc650a50e1/gcc%2Fada%2Flibgnat%2Fa-chtgfk.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e2f53d50c6fd17eb87d256d57696acc650a50e1/gcc%2Fada%2Flibgnat%2Fa-chtgfk.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-chtgfk.ads?ref=2e2f53d50c6fd17eb87d256d57696acc650a50e1", "patch": "@@ -0,0 +1,120 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--               ADA.CONTAINERS.HASH_TABLES.GENERIC_FORMAL_KEYS             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2022, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+--  Hash_Table_Type is used to implement hashed containers. This package\n+--  declares hash-table operations that depend on keys.\n+\n+generic\n+   with package HT_Types is\n+     new Generic_Formal_Hash_Table_Types (<>);\n+\n+   use HT_Types;\n+\n+   with function Next (Node : Node_Type) return Count_Type;\n+\n+   with procedure Set_Next\n+     (Node : in out Node_Type;\n+      Next : Count_Type);\n+\n+   type Key_Type (<>) is limited private;\n+\n+   with function Hash (Key : Key_Type) return Hash_Type;\n+\n+   with function Equivalent_Keys\n+     (Key  : Key_Type;\n+      Node : Node_Type) return Boolean;\n+\n+package Ada.Containers.Hash_Tables.Generic_Formal_Keys is\n+   pragma Pure;\n+\n+   function Index\n+     (HT  : Hash_Table_Type'Class;\n+      Key : Key_Type) return Hash_Type;\n+   pragma Inline (Index);\n+   --  Returns the bucket number (array index value) for the given key\n+\n+   function Checked_Index\n+     (HT  : Hash_Table_Type'Class;\n+      Key : Key_Type) return Hash_Type;\n+   pragma Inline (Checked_Index);\n+   --  Calls Index, but also locks and unlocks the container, per AI05-0022, in\n+   --  order to detect element tampering by the generic actual Hash function.\n+\n+   function Checked_Equivalent_Keys\n+     (HT   : Hash_Table_Type'Class;\n+      Key  : Key_Type;\n+      Node : Count_Type) return Boolean;\n+   --  Calls Equivalent_Keys, but locks and unlocks the container, per\n+   --  AI05-0022, in order to detect element tampering by that generic actual.\n+\n+   procedure Delete_Key_Sans_Free\n+     (HT  : in out Hash_Table_Type'Class;\n+      Key : Key_Type;\n+      X   : out Count_Type);\n+   --  Removes the node (if any) with the given key from the hash table,\n+   --  without deallocating it. Program_Error is raised if the hash\n+   --  table is busy.\n+\n+   function Find\n+     (HT  : Hash_Table_Type'Class;\n+      Key : Key_Type) return Count_Type;\n+   --  Returns the node (if any) corresponding to the given key\n+\n+   generic\n+      with function New_Node return Count_Type;\n+   procedure Generic_Conditional_Insert\n+     (HT       : in out Hash_Table_Type'Class;\n+      Key      : Key_Type;\n+      Node     : out Count_Type;\n+      Inserted : out Boolean);\n+   --  Attempts to insert a new node with the given key into the hash table.\n+   --  If a node with that key already exists in the table, then that node\n+   --  is returned and Inserted returns False. Otherwise New_Node is called\n+   --  to allocate a new node, and Inserted returns True. Program_Error is\n+   --  raised if the hash table is busy.\n+\n+   generic\n+      with function Hash (Node : Node_Type) return Hash_Type;\n+      with procedure Assign (Node : in out Node_Type; Key : Key_Type);\n+   procedure Generic_Replace_Element\n+     (HT   : in out Hash_Table_Type'Class;\n+      Node : Count_Type;\n+      Key  : Key_Type);\n+   --  Assigns Key to Node, possibly changing its equivalence class. If Node\n+   --  is in the same equivalence class as Key (that is, it's already in the\n+   --  bucket implied by Key), then if the hash table is locked then\n+   --  Program_Error is raised; otherwise Assign is called to assign Key to\n+   --  Node. If Node is in a different bucket from Key, then Program_Error is\n+   --  raised if the hash table is busy. Otherwise it Assigns Key to Node and\n+   --  moves the Node from its current bucket to the bucket implied by Key.\n+   --  Note that it is never proper to assign to Node a key value already\n+   --  in the map, and so if Key is equivalent to some other node then\n+   --  Program_Error is raised.\n+\n+end Ada.Containers.Hash_Tables.Generic_Formal_Keys;"}, {"sha": "063537ea8ac6ea42717da50dc4d110260b5afe97", "filename": "gcc/ada/libgnat/a-chtgfo.adb", "status": "added", "additions": 542, "deletions": 0, "changes": 542, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e2f53d50c6fd17eb87d256d57696acc650a50e1/gcc%2Fada%2Flibgnat%2Fa-chtgfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e2f53d50c6fd17eb87d256d57696acc650a50e1/gcc%2Fada%2Flibgnat%2Fa-chtgfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-chtgfo.adb?ref=2e2f53d50c6fd17eb87d256d57696acc650a50e1", "patch": "@@ -0,0 +1,542 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--            ADA.CONTAINERS.HASH_TABLES.GENERIC_FORMAL_OPERATIONS          --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2022, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+with System; use type System.Address;\n+\n+package body Ada.Containers.Hash_Tables.Generic_Formal_Operations is\n+\n+   Checks : constant Boolean := Container_Checks'Enabled;\n+\n+   -------------------\n+   -- Checked_Index --\n+   -------------------\n+\n+   function Checked_Index\n+     (Hash_Table : Hash_Table_Type'Class;\n+      Node       : Count_Type) return Hash_Type\n+   is\n+   begin\n+      return Index (Hash_Table, Hash_Table.Nodes (Node));\n+   end Checked_Index;\n+\n+   -----------\n+   -- Clear --\n+   -----------\n+\n+   procedure Clear (HT : in out Hash_Table_Type'Class) is\n+   begin\n+      HT.Length := 0;\n+      --  HT.Busy := 0;\n+      --  HT.Lock := 0;\n+      HT.Free := -1;\n+      HT.Buckets := [others => 0];  -- optimize this somehow ???\n+   end Clear;\n+\n+   --------------------------\n+   -- Delete_Node_At_Index --\n+   --------------------------\n+\n+   procedure Delete_Node_At_Index\n+     (HT   : in out Hash_Table_Type'Class;\n+      Indx : Hash_Type;\n+      X    : Count_Type)\n+   is\n+      Prev : Count_Type;\n+      Curr : Count_Type;\n+\n+   begin\n+      Prev := HT.Buckets (Indx);\n+\n+      if Checks and then Prev = 0 then\n+         raise Program_Error with\n+           \"attempt to delete node from empty hash bucket\";\n+      end if;\n+\n+      if Prev = X then\n+         HT.Buckets (Indx) := Next (HT.Nodes (Prev));\n+         HT.Length := HT.Length - 1;\n+         return;\n+      end if;\n+\n+      if Checks and then HT.Length = 1 then\n+         raise Program_Error with\n+           \"attempt to delete node not in its proper hash bucket\";\n+      end if;\n+\n+      loop\n+         Curr := Next (HT.Nodes (Prev));\n+\n+         if Checks and then Curr = 0 then\n+            raise Program_Error with\n+              \"attempt to delete node not in its proper hash bucket\";\n+         end if;\n+\n+         Prev := Curr;\n+      end loop;\n+   end Delete_Node_At_Index;\n+\n+   ---------------------------\n+   -- Delete_Node_Sans_Free --\n+   ---------------------------\n+\n+   procedure Delete_Node_Sans_Free\n+     (HT : in out Hash_Table_Type'Class;\n+      X  : Count_Type)\n+   is\n+      pragma Assert (X /= 0);\n+\n+      Indx : Hash_Type;\n+      Prev : Count_Type;\n+      Curr : Count_Type;\n+\n+   begin\n+      if Checks and then HT.Length = 0 then\n+         raise Program_Error with\n+           \"attempt to delete node from empty hashed container\";\n+      end if;\n+\n+      Indx := Checked_Index (HT, X);\n+      Prev := HT.Buckets (Indx);\n+\n+      if Checks and then Prev = 0 then\n+         raise Program_Error with\n+           \"attempt to delete node from empty hash bucket\";\n+      end if;\n+\n+      if Prev = X then\n+         HT.Buckets (Indx) := Next (HT.Nodes (Prev));\n+         HT.Length := HT.Length - 1;\n+         return;\n+      end if;\n+\n+      if Checks and then HT.Length = 1 then\n+         raise Program_Error with\n+           \"attempt to delete node not in its proper hash bucket\";\n+      end if;\n+\n+      loop\n+         Curr := Next (HT.Nodes (Prev));\n+\n+         if Checks and then Curr = 0 then\n+            raise Program_Error with\n+              \"attempt to delete node not in its proper hash bucket\";\n+         end if;\n+\n+         if Curr = X then\n+            Set_Next (HT.Nodes (Prev), Next => Next (HT.Nodes (Curr)));\n+            HT.Length := HT.Length - 1;\n+            return;\n+         end if;\n+\n+         Prev := Curr;\n+      end loop;\n+   end Delete_Node_Sans_Free;\n+\n+   -----------\n+   -- First --\n+   -----------\n+\n+   function First (HT : Hash_Table_Type'Class) return Count_Type is\n+      Indx : Hash_Type;\n+\n+   begin\n+      if HT.Length = 0 then\n+         return 0;\n+      end if;\n+\n+      Indx := HT.Buckets'First;\n+      loop\n+         if HT.Buckets (Indx) /= 0 then\n+            return HT.Buckets (Indx);\n+         end if;\n+\n+         Indx := Indx + 1;\n+      end loop;\n+   end First;\n+\n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free\n+     (HT : in out Hash_Table_Type'Class;\n+      X  : Count_Type)\n+   is\n+      N : Nodes_Type renames HT.Nodes;\n+\n+   begin\n+      --  This subprogram \"deallocates\" a node by relinking the node off of the\n+      --  active list and onto the free list. Previously it would flag index\n+      --  value 0 as an error. The precondition was weakened, so that index\n+      --  value 0 is now allowed, and this value is interpreted to mean \"do\n+      --  nothing\". This makes its behavior analogous to the behavior of\n+      --  Ada.Unchecked_Deallocation, and allows callers to avoid having to add\n+      --  special-case checks at the point of call.\n+\n+      if X = 0 then\n+         return;\n+      end if;\n+\n+      pragma Assert (X <= HT.Capacity);\n+\n+      --  pragma Assert (N (X).Prev >= 0);  -- node is active\n+      --  Find a way to mark a node as active vs. inactive; we could\n+      --  use a special value in Color_Type for this.  ???\n+\n+      --  The hash table actually contains two data structures: a list for\n+      --  the \"active\" nodes that contain elements that have been inserted\n+      --  onto the container, and another for the \"inactive\" nodes of the free\n+      --  store.\n+      --\n+      --  We desire that merely declaring an object should have only minimal\n+      --  cost; specially, we want to avoid having to initialize the free\n+      --  store (to fill in the links), especially if the capacity is large.\n+      --\n+      --  The head of the free list is indicated by Container.Free. If its\n+      --  value is non-negative, then the free store has been initialized\n+      --  in the \"normal\" way: Container.Free points to the head of the list\n+      --  of free (inactive) nodes, and the value 0 means the free list is\n+      --  empty. Each node on the free list has been initialized to point\n+      --  to the next free node (via its Parent component), and the value 0\n+      --  means that this is the last free node.\n+      --\n+      --  If Container.Free is negative, then the links on the free store\n+      --  have not been initialized. In this case the link values are\n+      --  implied: the free store comprises the components of the node array\n+      --  started with the absolute value of Container.Free, and continuing\n+      --  until the end of the array (Nodes'Last).\n+      --\n+      --  ???\n+      --  It might be possible to perform an optimization here. Suppose that\n+      --  the free store can be represented as having two parts: one\n+      --  comprising the non-contiguous inactive nodes linked together\n+      --  in the normal way, and the other comprising the contiguous\n+      --  inactive nodes (that are not linked together, at the end of the\n+      --  nodes array). This would allow us to never have to initialize\n+      --  the free store, except in a lazy way as nodes become inactive.\n+\n+      --  When an element is deleted from the list container, its node\n+      --  becomes inactive, and so we set its Next component to value of\n+      --  the node's index (in the nodes array), to indicate that it is\n+      --  now inactive. This provides a useful way to detect a dangling\n+      --  cursor reference.  ???\n+\n+      Set_Next (N (X), Next => X);  -- Node is deallocated (not on active list)\n+\n+      if HT.Free >= 0 then\n+         --  The free store has previously been initialized. All we need to\n+         --  do here is link the newly-free'd node onto the free list.\n+\n+         Set_Next (N (X), HT.Free);\n+         HT.Free := X;\n+\n+      elsif X + 1 = abs HT.Free then\n+         --  The free store has not been initialized, and the node becoming\n+         --  inactive immediately precedes the start of the free store. All\n+         --  we need to do is move the start of the free store back by one.\n+\n+         HT.Free := HT.Free + 1;\n+\n+      else\n+         --  The free store has not been initialized, and the node becoming\n+         --  inactive does not immediately precede the free store. Here we\n+         --  first initialize the free store (meaning the links are given\n+         --  values in the traditional way), and then link the newly-free'd\n+         --  node onto the head of the free store.\n+\n+         --  ???\n+         --  See the comments above for an optimization opportunity. If\n+         --  the next link for a node on the free store is negative, then\n+         --  this means the remaining nodes on the free store are\n+         --  physically contiguous, starting as the absolute value of\n+         --  that index value.\n+\n+         HT.Free := abs HT.Free;\n+\n+         if HT.Free > HT.Capacity then\n+            HT.Free := 0;\n+\n+         else\n+            for I in HT.Free .. HT.Capacity - 1 loop\n+               Set_Next (Node => N (I), Next => I + 1);\n+            end loop;\n+\n+            Set_Next (Node => N (HT.Capacity), Next => 0);\n+         end if;\n+\n+         Set_Next (Node => N (X), Next => HT.Free);\n+         HT.Free := X;\n+      end if;\n+   end Free;\n+\n+   ----------------------\n+   -- Generic_Allocate --\n+   ----------------------\n+\n+   procedure Generic_Allocate\n+     (HT   : in out Hash_Table_Type'Class;\n+      Node : out Count_Type)\n+   is\n+      N : Nodes_Type renames HT.Nodes;\n+\n+   begin\n+      if HT.Free >= 0 then\n+         Node := HT.Free;\n+\n+         --  We always perform the assignment first, before we\n+         --  change container state, in order to defend against\n+         --  exceptions duration assignment.\n+\n+         Set_Element (N (Node));\n+         HT.Free := Next (N (Node));\n+\n+      else\n+         --  A negative free store value means that the links of the nodes\n+         --  in the free store have not been initialized. In this case, the\n+         --  nodes are physically contiguous in the array, starting at the\n+         --  index that is the absolute value of the Container.Free, and\n+         --  continuing until the end of the array (Nodes'Last).\n+\n+         Node := abs HT.Free;\n+\n+         --  As above, we perform this assignment first, before modifying\n+         --  any container state.\n+\n+         Set_Element (N (Node));\n+         HT.Free := HT.Free - 1;\n+      end if;\n+   end Generic_Allocate;\n+\n+   -------------------\n+   -- Generic_Equal --\n+   -------------------\n+\n+   function Generic_Equal\n+     (L, R : Hash_Table_Type'Class) return Boolean\n+   is\n+      L_Index : Hash_Type;\n+      L_Node  : Count_Type;\n+\n+      N : Count_Type;\n+\n+   begin\n+      if L'Address = R'Address then\n+         return True;\n+      end if;\n+\n+      if L.Length /= R.Length then\n+         return False;\n+      end if;\n+\n+      if L.Length = 0 then\n+         return True;\n+      end if;\n+\n+      --  Find the first node of hash table L\n+\n+      L_Index := L.Buckets'First;\n+      loop\n+         L_Node := L.Buckets (L_Index);\n+         exit when L_Node /= 0;\n+         L_Index := L_Index + 1;\n+      end loop;\n+\n+      --  For each node of hash table L, search for an equivalent node in hash\n+      --  table R.\n+\n+      N := L.Length;\n+      loop\n+         if not Find (HT => R, Key => L.Nodes (L_Node)) then\n+            return False;\n+         end if;\n+\n+         N := N - 1;\n+\n+         L_Node := Next (L.Nodes (L_Node));\n+\n+         if L_Node = 0 then\n+\n+            --  We have exhausted the nodes in this bucket\n+\n+            if N = 0 then\n+               return True;\n+            end if;\n+\n+            --  Find the next bucket\n+\n+            loop\n+               L_Index := L_Index + 1;\n+               L_Node := L.Buckets (L_Index);\n+               exit when L_Node /= 0;\n+            end loop;\n+         end if;\n+      end loop;\n+   end Generic_Equal;\n+\n+   -----------------------\n+   -- Generic_Iteration --\n+   -----------------------\n+\n+   procedure Generic_Iteration (HT : Hash_Table_Type'Class) is\n+      Node : Count_Type;\n+\n+   begin\n+      if HT.Length = 0 then\n+         return;\n+      end if;\n+\n+      for Indx in HT.Buckets'Range loop\n+         Node := HT.Buckets (Indx);\n+         while Node /= 0 loop\n+            Process (Node);\n+            Node := Next (HT.Nodes (Node));\n+         end loop;\n+      end loop;\n+   end Generic_Iteration;\n+\n+   ------------------\n+   -- Generic_Read --\n+   ------------------\n+\n+   procedure Generic_Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      HT     : out Hash_Table_Type'Class)\n+   is\n+      N : Count_Type'Base;\n+\n+   begin\n+      Clear (HT);\n+\n+      Count_Type'Base'Read (Stream, N);\n+\n+      if Checks and then N < 0 then\n+         raise Program_Error with \"stream appears to be corrupt\";\n+      end if;\n+\n+      if N = 0 then\n+         return;\n+      end if;\n+\n+      if Checks and then N > HT.Capacity then\n+         raise Capacity_Error with \"too many elements in stream\";\n+      end if;\n+\n+      for J in 1 .. N loop\n+         declare\n+            Node : constant Count_Type := New_Node (Stream);\n+            Indx : constant Hash_Type := Checked_Index (HT, Node);\n+            B    : Count_Type renames HT.Buckets (Indx);\n+         begin\n+            Set_Next (HT.Nodes (Node), Next => B);\n+            B := Node;\n+         end;\n+\n+         HT.Length := HT.Length + 1;\n+      end loop;\n+   end Generic_Read;\n+\n+   -------------------\n+   -- Generic_Write --\n+   -------------------\n+\n+   procedure Generic_Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      HT     : Hash_Table_Type'Class)\n+   is\n+      procedure Write (Node : Count_Type);\n+      pragma Inline (Write);\n+\n+      procedure Write is new Generic_Iteration (Write);\n+\n+      -----------\n+      -- Write --\n+      -----------\n+\n+      procedure Write (Node : Count_Type) is\n+      begin\n+         Write (Stream, HT.Nodes (Node));\n+      end Write;\n+\n+   begin\n+      Count_Type'Base'Write (Stream, HT.Length);\n+      Write (HT);\n+   end Generic_Write;\n+\n+   -----------\n+   -- Index --\n+   -----------\n+\n+   function Index\n+     (Buckets : Buckets_Type;\n+      Node    : Node_Type) return Hash_Type is\n+   begin\n+      return Buckets'First + Hash_Node (Node) mod Buckets'Length;\n+   end Index;\n+\n+   function Index\n+     (HT   : Hash_Table_Type'Class;\n+      Node : Node_Type) return Hash_Type is\n+   begin\n+      return Index (HT.Buckets, Node);\n+   end Index;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   function Next\n+     (HT   : Hash_Table_Type'Class;\n+      Node : Count_Type) return Count_Type\n+   is\n+      Result : Count_Type;\n+      First  : Hash_Type;\n+\n+   begin\n+      Result := Next (HT.Nodes (Node));\n+\n+      if Result /= 0 then  -- another node in same bucket\n+         return Result;\n+      end if;\n+\n+      --  This was the last node in the bucket, so move to the next\n+      --  bucket, and start searching for next node from there.\n+\n+      First := Checked_Index (HT'Unrestricted_Access.all, Node) + 1;\n+      for Indx in First .. HT.Buckets'Last loop\n+         Result := HT.Buckets (Indx);\n+\n+         if Result /= 0 then  -- bucket is not empty\n+            return Result;\n+         end if;\n+      end loop;\n+\n+      return 0;\n+   end Next;\n+\n+end Ada.Containers.Hash_Tables.Generic_Formal_Operations;"}, {"sha": "4936c737c44c2ccf10e4a44aaf5a13af56564edd", "filename": "gcc/ada/libgnat/a-chtgfo.ads", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e2f53d50c6fd17eb87d256d57696acc650a50e1/gcc%2Fada%2Flibgnat%2Fa-chtgfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e2f53d50c6fd17eb87d256d57696acc650a50e1/gcc%2Fada%2Flibgnat%2Fa-chtgfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-chtgfo.ads?ref=2e2f53d50c6fd17eb87d256d57696acc650a50e1", "patch": "@@ -0,0 +1,156 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--            ADA.CONTAINERS.HASH_TABLES.GENERIC_FORMAL_OPERATIONS          --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2004-2022, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- This unit was originally developed by Matthew J Heaney.                  --\n+------------------------------------------------------------------------------\n+\n+--  Hash_Table_Type is used to implement hashed containers. This package\n+--  declares hash-table operations that do not depend on keys.\n+\n+with Ada.Streams;\n+\n+generic\n+   with package HT_Types is\n+     new Generic_Formal_Hash_Table_Types (<>);\n+\n+   use HT_Types;\n+\n+   with function Hash_Node (Node : Node_Type) return Hash_Type;\n+\n+   with function Next (Node : Node_Type) return Count_Type;\n+\n+   with procedure Set_Next\n+     (Node : in out Node_Type;\n+      Next : Count_Type);\n+\n+package Ada.Containers.Hash_Tables.Generic_Formal_Operations is\n+   pragma Pure;\n+\n+   function Index\n+     (Buckets : Buckets_Type;\n+      Node    : Node_Type) return Hash_Type;\n+   pragma Inline (Index);\n+   --  Uses the hash value of Node to compute its Buckets array index\n+\n+   function Index\n+     (HT   : Hash_Table_Type'Class;\n+      Node : Node_Type) return Hash_Type;\n+   pragma Inline (Index);\n+   --  Uses the hash value of Node to compute its Hash_Table buckets array\n+   --  index.\n+\n+   function Checked_Index\n+     (Hash_Table : Hash_Table_Type'Class;\n+      Node       : Count_Type) return Hash_Type;\n+   --  Calls Index, but also locks and unlocks the container, per AI05-0022, in\n+   --  order to detect element tampering by the generic actual Hash function.\n+\n+   generic\n+      with function Find\n+        (HT  : Hash_Table_Type'Class;\n+         Key : Node_Type) return Boolean;\n+   function Generic_Equal (L, R : Hash_Table_Type'Class) return Boolean;\n+   --  Used to implement hashed container equality. For each node in hash table\n+   --  L, it calls Find to search for an equivalent item in hash table R. If\n+   --  Find returns False for any node then Generic_Equal terminates\n+   --  immediately and returns False. Otherwise if Find returns True for every\n+   --  node then Generic_Equal returns True.\n+\n+   procedure Clear (HT : in out Hash_Table_Type'Class);\n+   --  Deallocates each node in hash table HT. (Note that it only deallocates\n+   --  the nodes, not the buckets array.) Program_Error is raised if the hash\n+   --  table is busy.\n+\n+   procedure Delete_Node_At_Index\n+     (HT   : in out Hash_Table_Type'Class;\n+      Indx : Hash_Type;\n+      X    : Count_Type);\n+   --  Delete a node whose bucket position is known. extracted from following\n+   --  subprogram, but also used directly to remove a node whose element has\n+   --  been modified through a key_preserving reference: in that case we cannot\n+   --  use the value of the element precisely because the current value does\n+   --  not correspond to the hash code that determines its bucket.\n+\n+   procedure Delete_Node_Sans_Free\n+     (HT : in out Hash_Table_Type'Class;\n+      X  : Count_Type);\n+   --  Removes node X from the hash table without deallocating the node\n+\n+   generic\n+      with procedure Set_Element (Node : in out Node_Type);\n+   procedure Generic_Allocate\n+     (HT   : in out Hash_Table_Type'Class;\n+      Node : out Count_Type);\n+   --  Claim a node from the free store. Generic_Allocate first\n+   --  calls Set_Element on the potential node, and then returns\n+   --  the node's index as the value of the Node parameter.\n+\n+   procedure Free\n+     (HT : in out Hash_Table_Type'Class;\n+      X  : Count_Type);\n+   --  Return a node back to the free store, from where it had\n+   --  been previously claimed via Generic_Allocate.\n+\n+   function First (HT : Hash_Table_Type'Class) return Count_Type;\n+   --  Returns the head of the list in the first (lowest-index) non-empty\n+   --  bucket.\n+\n+   function Next\n+     (HT   : Hash_Table_Type'Class;\n+      Node : Count_Type) return Count_Type;\n+   --  Returns the node that immediately follows Node. This corresponds to\n+   --  either the next node in the same bucket, or (if Node is the last node in\n+   --  its bucket) the head of the list in the first non-empty bucket that\n+   --  follows.\n+\n+   generic\n+      with procedure Process (Node : Count_Type);\n+   procedure Generic_Iteration (HT : Hash_Table_Type'Class);\n+   --  Calls Process for each node in hash table HT\n+\n+   generic\n+      use Ada.Streams;\n+      with procedure Write\n+        (Stream : not null access Root_Stream_Type'Class;\n+         Node   : Node_Type);\n+   procedure Generic_Write\n+     (Stream : not null access Root_Stream_Type'Class;\n+      HT     : Hash_Table_Type'Class);\n+   --  Used to implement the streaming attribute for hashed containers. It\n+   --  calls Write for each node to write its value into Stream.\n+\n+   generic\n+      use Ada.Streams;\n+      with function New_Node (Stream : not null access Root_Stream_Type'Class)\n+         return Count_Type;\n+   procedure Generic_Read\n+     (Stream : not null access Root_Stream_Type'Class;\n+      HT     : out Hash_Table_Type'Class);\n+   --  Used to implement the streaming attribute for hashed containers. It\n+   --  first clears hash table HT, then populates the hash table by calling\n+   --  New_Node for each item in Stream.\n+\n+end Ada.Containers.Hash_Tables.Generic_Formal_Operations;"}, {"sha": "2f035e378609a58f897bb1e89de8669cc5be4996", "filename": "gcc/ada/libgnat/a-cohata.ads", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e2f53d50c6fd17eb87d256d57696acc650a50e1/gcc%2Fada%2Flibgnat%2Fa-cohata.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e2f53d50c6fd17eb87d256d57696acc650a50e1/gcc%2Fada%2Flibgnat%2Fa-cohata.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cohata.ads?ref=2e2f53d50c6fd17eb87d256d57696acc650a50e1", "patch": "@@ -79,4 +79,23 @@ package Ada.Containers.Hash_Tables is\n       package Implementation is new Helpers.Generic_Implementation;\n    end Generic_Bounded_Hash_Table_Types;\n \n+   generic\n+      type Node_Type is private;\n+   package Generic_Formal_Hash_Table_Types is\n+\n+      type Nodes_Type is array (Count_Type range <>) of Node_Type;\n+      type Buckets_Type is array (Hash_Type range <>) of Count_Type;\n+\n+      type Hash_Table_Type\n+        (Capacity : Count_Type;\n+         Modulus  : Hash_Type) is\n+      tagged record\n+         Length  : Count_Type                  := 0;\n+         Free    : Count_Type'Base             := -1;\n+         Nodes   : Nodes_Type (1 .. Capacity);\n+         Buckets : Buckets_Type (1 .. Modulus) := [others => 0];\n+      end record;\n+\n+   end Generic_Formal_Hash_Table_Types;\n+\n end Ada.Containers.Hash_Tables;"}]}