{"sha": "7ba6eb1e5cca6b0da36fa791d1f6d7ab68cc12a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2JhNmViMWU1Y2NhNmIwZGEzNmZhNzkxZDFmNmQ3YWI2OGNjMTJhMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-10-18T18:23:26Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-10-18T18:23:26Z"}, "message": "ipa.c (cgraph_externally_visible_p, [...]): Revert accidental commit.\n\n\t* ipa.c (cgraph_externally_visible_p, varpool_externally_visible_p,\n\tfunction_and_variable_visibility): Revert accidental commit.\n\nFrom-SVN: r165655", "tree": {"sha": "bd299a6803bcee24bd4658236478e615f218c27f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd299a6803bcee24bd4658236478e615f218c27f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ba6eb1e5cca6b0da36fa791d1f6d7ab68cc12a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ba6eb1e5cca6b0da36fa791d1f6d7ab68cc12a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ba6eb1e5cca6b0da36fa791d1f6d7ab68cc12a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ba6eb1e5cca6b0da36fa791d1f6d7ab68cc12a2/comments", "author": null, "committer": null, "parents": [{"sha": "e426b47b65aca8b12aff9697e769c98c03af7691", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e426b47b65aca8b12aff9697e769c98c03af7691", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e426b47b65aca8b12aff9697e769c98c03af7691"}], "stats": {"total": 112, "additions": 29, "deletions": 83}, "files": [{"sha": "677a1ac46a2fa723e5750ae413879f6a132d8890", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba6eb1e5cca6b0da36fa791d1f6d7ab68cc12a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba6eb1e5cca6b0da36fa791d1f6d7ab68cc12a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7ba6eb1e5cca6b0da36fa791d1f6d7ab68cc12a2", "patch": "@@ -1,3 +1,8 @@\n+2010-10-18  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa.c (cgraph_externally_visible_p, varpool_externally_visible_p,\n+\tfunction_and_variable_visibility): Revert accidental commit.\n+\n 2010-10-18  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tMerge from 'apple/trunk' branch on FSF servers."}, {"sha": "fccfb6a1c72949e6e7b157045815fff94b2919fd", "filename": "gcc/ipa.c", "status": "modified", "additions": 24, "deletions": 83, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ba6eb1e5cca6b0da36fa791d1f6d7ab68cc12a2/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ba6eb1e5cca6b0da36fa791d1f6d7ab68cc12a2/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=7ba6eb1e5cca6b0da36fa791d1f6d7ab68cc12a2", "patch": "@@ -593,7 +593,6 @@ ipa_discover_readonly_nonaddressable_vars (void)\n static bool\n cgraph_externally_visible_p (struct cgraph_node *node, bool whole_program, bool aliased)\n {\n-  struct cgraph_node *alias;\n   if (!node->local.finalized)\n     return false;\n   if (!DECL_COMDAT (node->decl)\n@@ -608,23 +607,6 @@ cgraph_externally_visible_p (struct cgraph_node *node, bool whole_program, bool\n   /* If linker counts on us, we must preserve the function.  */\n   if (cgraph_used_from_object_file_p (node))\n     return true;\n-  if (DECL_PRESERVE_P (node->decl))\n-    return true;\n-  if (lookup_attribute (\"externally_visible\", DECL_ATTRIBUTES (node->decl)))\n-    return true;\n-\n-  /* See if we have linker information about symbol not being used or\n-     if we need to make guess based on the declaration.\n-\n-     Even if the linker clams the symbol is unused, never bring internal\n-     symbols that are declared by user as used or externally visible.\n-     This is needed for i.e. references from asm statements.   */\n-  for (alias = node->same_body; alias; alias = alias->next)\n-    if (alias->resolution != LDPR_PREVAILING_DEF_IRONLY)\n-      break;\n-  if (!alias && node->resolution == LDPR_PREVAILING_DEF_IRONLY)\n-    return false;\n-\n   /* When doing link time optimizations, hidden symbols become local.  */\n   if (in_lto_p\n       && (DECL_VISIBILITY (node->decl) == VISIBILITY_HIDDEN\n@@ -656,70 +638,11 @@ cgraph_externally_visible_p (struct cgraph_node *node, bool whole_program, bool\n \t      return true;\n \t}\n     }\n-\n-  if (MAIN_NAME_P (DECL_NAME (node->decl)))\n-    return true;\n-\n-  return false;\n-}\n-\n-/* Return true when variable VNODE should be considered externally visible.  */\n-\n-static bool\n-varpool_externally_visible_p (struct varpool_node *vnode, bool aliased)\n-{\n-  struct varpool_node *alias;\n-  if (!DECL_COMDAT (vnode->decl) && !TREE_PUBLIC (vnode->decl))\n-    return false;\n-\n-  /* Do not even try to be smart about aliased nodes.  Until we properly\n-     represent everything by same body alias, these are just evil.  */\n-  if (aliased)\n-    return true;\n-\n-  /* If linker counts on us, we must preserve the function.  */\n-  if (varpool_used_from_object_file_p (vnode))\n-    return true;\n-\n-  if (DECL_PRESERVE_P (vnode->decl))\n-    return true;\n-  if (lookup_attribute (\"externally_visible\",\n-\t\t\tDECL_ATTRIBUTES (vnode->decl)))\n-    return true;\n-\n-  /* See if we have linker information about symbol not being used or\n-     if we need to make guess based on the declaration.\n-\n-     Even if the linker clams the symbol is unused, never bring internal\n-     symbols that are declared by user as used or externally visible.\n-     This is needed for i.e. references from asm statements.   */\n-  if (varpool_used_from_object_file_p (vnode))\n+  if (DECL_PRESERVE_P (node->decl))\n     return true;\n-  for (alias = vnode->extra_name; alias; alias = alias->next)\n-    if (alias->resolution != LDPR_PREVAILING_DEF_IRONLY)\n-      break;\n-  if (!alias && vnode->resolution == LDPR_PREVAILING_DEF_IRONLY)\n-    return false;\n-\n-  /* When doing link time optimizations, hidden symbols become local.  */\n-  if (in_lto_p\n-      && (DECL_VISIBILITY (vnode->decl) == VISIBILITY_HIDDEN\n-\t  || DECL_VISIBILITY (vnode->decl) == VISIBILITY_INTERNAL)\n-      /* Be sure that node is defined in IR file, not in other object\n-\t file.  In that case we don't set used_from_other_object_file.  */\n-      && vnode->finalized)\n-    ;\n-  else if (!flag_whole_program)\n+  if (MAIN_NAME_P (DECL_NAME (node->decl)))\n     return true;\n-\n-  /* Do not attempt to privatize COMDATS by default.\n-     This would break linking with C++ libraries sharing\n-     inline definitions.\n-\n-     FIXME: We can do so for readonly vars with no address taken and\n-     possibly also for vtables since no direct pointer comparsion is done.\n-     It might be interesting to do so to reduce linking overhead.  */\n-  if (DECL_COMDAT (vnode->decl) || DECL_WEAK (vnode->decl))\n+  if (lookup_attribute (\"externally_visible\", DECL_ATTRIBUTES (node->decl)))\n     return true;\n   return false;\n }\n@@ -875,9 +798,27 @@ function_and_variable_visibility (bool whole_program)\n       if (!vnode->finalized)\n         continue;\n       if (vnode->needed\n-\t  && varpool_externally_visible_p\n-\t      (vnode, \n-\t       pointer_set_contains (aliased_vnodes, vnode)))\n+\t  && (DECL_COMDAT (vnode->decl) || TREE_PUBLIC (vnode->decl))\n+\t  && (((!whole_program\n+\t        /* We can privatize comdat readonly variables whose address is\n+\t\t   not taken, but doing so is not going to bring us\n+\t\t   optimization oppurtunities until we start reordering\n+\t\t   datastructures.  */\n+\t\t|| DECL_COMDAT (vnode->decl)\n+\t\t|| DECL_WEAK (vnode->decl))\n+\t       /* When doing linktime optimizations, all hidden symbols will\n+\t\t  become local.  */\n+\t       && (!in_lto_p\n+\t\t   || (DECL_VISIBILITY (vnode->decl) != VISIBILITY_HIDDEN\n+\t\t       && DECL_VISIBILITY (vnode->decl) != VISIBILITY_INTERNAL)\n+\t\t   /* We can get prevailing decision in other object file.\n+\t\t      In this case we do not sed used_from_object_file.  */\n+\t\t   || !vnode->finalized))\n+\t      || DECL_PRESERVE_P (vnode->decl)\n+              || varpool_used_from_object_file_p (vnode)\n+\t      || pointer_set_contains (aliased_vnodes, vnode)\n+\t      || lookup_attribute (\"externally_visible\",\n+\t\t\t\t   DECL_ATTRIBUTES (vnode->decl))))\n \tvnode->externally_visible = true;\n       else\n         vnode->externally_visible = false;"}]}