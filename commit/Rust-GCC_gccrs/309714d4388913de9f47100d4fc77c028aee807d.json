{"sha": "309714d4388913de9f47100d4fc77c028aee807d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA5NzE0ZDQzODg5MTNkZTlmNDcxMDBkNGZjNzdjMDI4YWVlODA3ZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-08-06T19:35:01Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-08-06T19:35:01Z"}, "message": "typeck.c (complete_type_or_maybe_complain): Split out from...\n\n\t* typeck.c (complete_type_or_maybe_complain): Split out from...\n\t(complete_type_or_else): Here.\n\t(build_class_member_access_expr): Call it.\n\t(finish_class_member_access_expr): Likewise.\n\t* call.c (build_special_member_call): Likewise.\n\t* cvt.c (build_expr_type_conversion): Likewise.\n\t* init.c (build_new): Likewise.\n\t* typeck2.c (build_functional_cast): Likewise.\n\t* cp-tree.h: Declare it.\n\n\t* init.c (build_value_init): Add complain parm.\n\t(build_value_init_noctor): Likewise.\n\t(perform_member_init): Pass it.\n\t(expand_aggr_init_1): Likewise.\n\t(build_new_1): Likewise.\n\t(build_vec_init): Likewise.\n\t* pt.c (tsubst_expr): Likewise.\n\t* typeck2.c (build_functional_cast): Likewise.\n\t* cp-tree.h: Adjust.\n\t* tree.c (build_target_expr_with_type): Handle error_mark_node.\n\nFrom-SVN: r162953", "tree": {"sha": "0df2634b2632db2fc4a2ad794b8a5d160a7d78e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0df2634b2632db2fc4a2ad794b8a5d160a7d78e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/309714d4388913de9f47100d4fc77c028aee807d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/309714d4388913de9f47100d4fc77c028aee807d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/309714d4388913de9f47100d4fc77c028aee807d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/309714d4388913de9f47100d4fc77c028aee807d/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0c32fb95f0dc38547c4b3a50536a79cb2dc88f90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c32fb95f0dc38547c4b3a50536a79cb2dc88f90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c32fb95f0dc38547c4b3a50536a79cb2dc88f90"}], "stats": {"total": 183, "additions": 156, "deletions": 27}, "files": [{"sha": "b4eea19854779ddaeddf8228142669d781fb0f60", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309714d4388913de9f47100d4fc77c028aee807d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309714d4388913de9f47100d4fc77c028aee807d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=309714d4388913de9f47100d4fc77c028aee807d", "patch": "@@ -1,5 +1,26 @@\n 2010-08-06  Jason Merrill  <jason@redhat.com>\n \n+\t* typeck.c (complete_type_or_maybe_complain): Split out from...\n+\t(complete_type_or_else): Here.\n+\t(build_class_member_access_expr): Call it.\n+\t(finish_class_member_access_expr): Likewise.\n+\t* call.c (build_special_member_call): Likewise.\n+\t* cvt.c (build_expr_type_conversion): Likewise.\n+\t* init.c (build_new): Likewise.\n+\t* typeck2.c (build_functional_cast): Likewise.\n+\t* cp-tree.h: Declare it.\n+\n+\t* init.c (build_value_init): Add complain parm.\n+\t(build_value_init_noctor): Likewise.\n+\t(perform_member_init): Pass it.\n+\t(expand_aggr_init_1): Likewise.\n+\t(build_new_1): Likewise.\n+\t(build_vec_init): Likewise.\n+\t* pt.c (tsubst_expr): Likewise.\n+\t* typeck2.c (build_functional_cast): Likewise.\n+\t* cp-tree.h: Adjust.\n+\t* tree.c (build_target_expr_with_type): Handle error_mark_node.\n+\n \t* typeck.c (decay_conversion): Any expression with type nullptr_t\n \tdecays to nullptr.\n "}, {"sha": "fbf98f1e82e76c348fc40698d9871e7450646fdf", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309714d4388913de9f47100d4fc77c028aee807d/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309714d4388913de9f47100d4fc77c028aee807d/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=309714d4388913de9f47100d4fc77c028aee807d", "patch": "@@ -6189,7 +6189,7 @@ build_special_member_call (tree instance, tree name, VEC(tree,gc) **args,\n   if (TYPE_P (binfo))\n     {\n       /* Resolve the name.  */\n-      if (!complete_type_or_else (binfo, NULL_TREE))\n+      if (!complete_type_or_maybe_complain (binfo, NULL_TREE, complain))\n \treturn error_mark_node;\n \n       binfo = TYPE_BINFO (binfo);"}, {"sha": "baa66562031faa060f896fd6feb7ed7508305c06", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309714d4388913de9f47100d4fc77c028aee807d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309714d4388913de9f47100d4fc77c028aee807d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=309714d4388913de9f47100d4fc77c028aee807d", "patch": "@@ -4915,8 +4915,8 @@ extern tree build_aggr_init\t\t\t(tree, tree, int,\n extern int is_class_type\t\t\t(tree, int);\n extern tree get_type_value\t\t\t(tree);\n extern tree build_zero_init\t\t\t(tree, tree, bool);\n-extern tree build_value_init\t\t\t(tree);\n-extern tree build_value_init_noctor\t\t(tree);\n+extern tree build_value_init\t\t\t(tree, tsubst_flags_t);\n+extern tree build_value_init_noctor\t\t(tree, tsubst_flags_t);\n extern tree build_offset_ref\t\t\t(tree, tree, bool);\n extern tree build_new\t\t\t\t(VEC(tree,gc) **, tree, tree,\n \t\t\t\t\t\t VEC(tree,gc) **, int,\n@@ -5419,6 +5419,7 @@ extern tree condition_conversion\t\t(tree);\n extern tree require_complete_type\t\t(tree);\n extern tree complete_type\t\t\t(tree);\n extern tree complete_type_or_else\t\t(tree, tree);\n+extern tree complete_type_or_maybe_complain\t(tree, tree, tsubst_flags_t);\n extern int type_unknown_p\t\t\t(const_tree);\n enum { ce_derived, ce_normal, ce_exact };\n extern bool comp_except_specs\t\t\t(const_tree, const_tree, int);"}, {"sha": "ab2b6bf2d700cdfd5e5e61005bd563cdb2b29a38", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309714d4388913de9f47100d4fc77c028aee807d/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309714d4388913de9f47100d4fc77c028aee807d/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=309714d4388913de9f47100d4fc77c028aee807d", "patch": "@@ -1468,7 +1468,7 @@ build_expr_type_conversion (int desires, tree expr, bool complain)\n \n   /* The code for conversions from class type is currently only used for\n      delete expressions.  Other expressions are handled by build_new_op.  */\n-  if (!complete_type_or_else (basetype, expr))\n+  if (!complete_type_or_maybe_complain (basetype, expr, complain))\n     return error_mark_node;\n   if (!TYPE_HAS_CONVERSION (basetype))\n     return NULL_TREE;"}, {"sha": "8555fadfb4213066ffba5a20c17137a507dcf617", "filename": "gcc/cp/init.c", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309714d4388913de9f47100d4fc77c028aee807d/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309714d4388913de9f47100d4fc77c028aee807d/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=309714d4388913de9f47100d4fc77c028aee807d", "patch": "@@ -269,7 +269,7 @@ build_zero_init (tree type, tree nelts, bool static_storage_p)\n    TYPE, as described in [dcl.init].  */\n \n tree\n-build_value_init (tree type)\n+build_value_init (tree type, tsubst_flags_t complain)\n {\n   /* [dcl.init]\n \n@@ -302,7 +302,7 @@ build_value_init (tree type)\n \t  (type,\n \t   build_special_member_call (NULL_TREE, complete_ctor_identifier,\n \t\t\t\t      NULL, type, LOOKUP_NORMAL,\n-\t\t\t\t      tf_warning_or_error));\n+\t\t\t\t      complain));\n       else if (TREE_CODE (type) != UNION_TYPE && TYPE_NEEDS_CONSTRUCTING (type))\n \t{\n \t  /* This is a class that needs constructing, but doesn't have\n@@ -311,21 +311,21 @@ build_value_init (tree type)\n \t     This will be handled in simplify_aggr_init_expr.  */\n \t  tree ctor = build_special_member_call\n \t    (NULL_TREE, complete_ctor_identifier,\n-\t     NULL, type, LOOKUP_NORMAL, tf_warning_or_error);\n+\t     NULL, type, LOOKUP_NORMAL, complain);\n \n \t  ctor = build_aggr_init_expr (type, ctor);\n \t  AGGR_INIT_ZERO_FIRST (ctor) = 1;\n \t  return ctor;\n \t}\n     }\n-  return build_value_init_noctor (type);\n+  return build_value_init_noctor (type, complain);\n }\n \n /* Like build_value_init, but don't call the constructor for TYPE.  Used\n    for base initializers.  */\n \n tree\n-build_value_init_noctor (tree type)\n+build_value_init_noctor (tree type, tsubst_flags_t complain)\n {\n   if (CLASS_TYPE_P (type))\n     {\n@@ -347,7 +347,12 @@ build_value_init_noctor (tree type)\n \t      ftype = TREE_TYPE (field);\n \n \t      if (TREE_CODE (ftype) == REFERENCE_TYPE)\n-\t\terror (\"value-initialization of reference\");\n+\t\t{\n+\t\t  if (complain & tf_error)\n+\t\t    error (\"value-initialization of reference\");\n+\t\t  else\n+\t\t    return error_mark_node;\n+\t\t}\n \n \t      /* We could skip vfields and fields of types with\n \t\t user-defined constructors, but I think that won't improve\n@@ -359,7 +364,7 @@ build_value_init_noctor (tree type)\n \t\t corresponding to base classes as well.  Thus, iterating\n \t\t over TYPE_FIELDs will result in correct initialization of\n \t\t all of the subobjects.  */\n-\t      value = build_value_init (ftype);\n+\t      value = build_value_init (ftype, complain);\n \n \t      if (value)\n \t\tCONSTRUCTOR_APPEND_ELT(v, field, value);\n@@ -401,7 +406,7 @@ build_value_init_noctor (tree type)\n \t    ce->index = build2 (RANGE_EXPR, sizetype, size_zero_node,\n \t\t\t\tmax_index);\n \n-\t  ce->value = build_value_init (TREE_TYPE (type));\n+\t  ce->value = build_value_init (TREE_TYPE (type), complain);\n \n \t  /* The gimplifier can't deal with a RANGE_EXPR of TARGET_EXPRs.  */\n \t  gcc_assert (TREE_CODE (ce->value) != TARGET_EXPR\n@@ -459,7 +464,8 @@ perform_member_init (tree member, tree init)\n \t\t       member);\n \t  else\n \t    {\n-\t      init = build2 (INIT_EXPR, type, decl, build_value_init (type));\n+\t      init = build2 (INIT_EXPR, type, decl,\n+\t\t\t     build_value_init (type, tf_warning_or_error));\n \t      finish_expr_stmt (init);\n \t    }\n \t}\n@@ -1473,7 +1479,8 @@ expand_aggr_init_1 (tree binfo, tree true_exp, tree exp, tree init, int flags,\n \t then just zero out the object and we're done.  */\n       else\n \t{\n-\t  init = build2 (INIT_EXPR, type, exp, build_value_init_noctor (type));\n+\t  init = build2 (INIT_EXPR, type, exp,\n+\t\t\t build_value_init_noctor (type, complain));\n \t  finish_expr_stmt (init);\n \t  return;\n \t}\n@@ -2314,8 +2321,10 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n \t  else if (explicit_value_init_p)\n \t    {\n \t      /* Something like `new int()'.  */\n-\t      init_expr = build2 (INIT_EXPR, type,\n-\t\t\t\t  init_expr, build_value_init (type));\n+\t      tree val = build_value_init (type, complain);\n+\t      if (val == error_mark_node)\n+\t\treturn error_mark_node;\n+\t      init_expr = build2 (INIT_EXPR, type, init_expr, val);\n \t    }\n \t  else\n \t    {\n@@ -2534,7 +2543,7 @@ build_new (VEC(tree,gc) **placement, tree type, tree nelts,\n   /* The type allocated must be complete.  If the new-type-id was\n      \"T[N]\" then we are just checking that \"T\" is complete here, but\n      that is equivalent, since the value of \"N\" doesn't matter.  */\n-  if (!complete_type_or_else (type, NULL_TREE))\n+  if (!complete_type_or_maybe_complain (type, NULL_TREE, complain))\n     return error_mark_node;\n \n   rval = build_new_1 (placement, type, nelts, init, use_global_new, complain);\n@@ -3041,8 +3050,13 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t\t\t\t     0, complain);\n \t}\n       else if (explicit_value_init_p)\n-\telt_init = build2 (INIT_EXPR, type, to,\n-\t\t\t   build_value_init (type));\n+\t{\n+\t  elt_init = build_value_init (type, complain);\n+\t  if (elt_init == error_mark_node)\n+\t    return error_mark_node;\n+\t  else\n+\t    elt_init = build2 (INIT_EXPR, type, to, elt_init);\n+\t}\n       else\n \t{\n \t  gcc_assert (TYPE_NEEDS_CONSTRUCTING (type));"}, {"sha": "bb6b1a0ab2c3cf6814fbb934bcd4d3ec761e2d0b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309714d4388913de9f47100d4fc77c028aee807d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309714d4388913de9f47100d4fc77c028aee807d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=309714d4388913de9f47100d4fc77c028aee807d", "patch": "@@ -11705,7 +11705,8 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t\t\t       pack expansion where the parameter packs\n \t\t\t       used in that expansion were of length\n \t\t\t       zero.  */\n-\t\t\t    init = build_value_init (TREE_TYPE (decl));\n+\t\t\t    init = build_value_init (TREE_TYPE (decl),\n+\t\t\t\t\t\t     complain);\n \t\t\t    if (TREE_CODE (init) == AGGR_INIT_EXPR)\n \t\t\t      init = get_target_expr (init);\n \t\t\t  }"}, {"sha": "5441448c32e4ce3589fddd945769cfa69fac3ff5", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309714d4388913de9f47100d4fc77c028aee807d/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309714d4388913de9f47100d4fc77c028aee807d/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=309714d4388913de9f47100d4fc77c028aee807d", "patch": "@@ -477,7 +477,8 @@ build_target_expr_with_type (tree init, tree type)\n {\n   gcc_assert (!VOID_TYPE_P (type));\n \n-  if (TREE_CODE (init) == TARGET_EXPR)\n+  if (TREE_CODE (init) == TARGET_EXPR\n+      || init == error_mark_node)\n     return init;\n   else if (CLASS_TYPE_P (type) && type_has_nontrivial_copy_init (type)\n \t   && !VOID_TYPE_P (TREE_TYPE (init))"}, {"sha": "03e72977066c8024bfe7d3541d5a2c9a91942363", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309714d4388913de9f47100d4fc77c028aee807d/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309714d4388913de9f47100d4fc77c028aee807d/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=309714d4388913de9f47100d4fc77c028aee807d", "patch": "@@ -135,21 +135,28 @@ complete_type (tree type)\n    Returns NULL_TREE if the type cannot be made complete.  */\n \n tree\n-complete_type_or_else (tree type, tree value)\n+complete_type_or_maybe_complain (tree type, tree value, tsubst_flags_t complain)\n {\n   type = complete_type (type);\n   if (type == error_mark_node)\n     /* We already issued an error.  */\n     return NULL_TREE;\n   else if (!COMPLETE_TYPE_P (type))\n     {\n-      cxx_incomplete_type_diagnostic (value, type, DK_ERROR);\n+      if (complain & tf_error)\n+\tcxx_incomplete_type_diagnostic (value, type, DK_ERROR);\n       return NULL_TREE;\n     }\n   else\n     return type;\n }\n \n+tree\n+complete_type_or_else (tree type, tree value)\n+{\n+  return complete_type_or_maybe_complain (type, value, tf_warning_or_error);\n+}\n+\n /* Return truthvalue of whether type of EXP is instantiated.  */\n \n int\n@@ -2209,7 +2216,7 @@ build_class_member_access_expr (tree object, tree member,\n      complete type).  */\n   object_type = TREE_TYPE (object);\n   if (!currently_open_class (object_type)\n-      && !complete_type_or_else (object_type, object))\n+      && !complete_type_or_maybe_complain (object_type, object, complain))\n     return error_mark_node;\n   if (!CLASS_TYPE_P (object_type))\n     {\n@@ -2585,7 +2592,7 @@ finish_class_member_access_expr (tree object, tree name, bool template_p,\n      The type of the first expression shall be \"class object\" (of a\n      complete type).  */\n   if (!currently_open_class (object_type)\n-      && !complete_type_or_else (object_type, object))\n+      && !complete_type_or_maybe_complain (object_type, object, complain))\n     return error_mark_node;\n   if (!CLASS_TYPE_P (object_type))\n     {"}, {"sha": "59b9c40960e4dcb910bb8bef3f334aa41d3af29b", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309714d4388913de9f47100d4fc77c028aee807d/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309714d4388913de9f47100d4fc77c028aee807d/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=309714d4388913de9f47100d4fc77c028aee807d", "patch": "@@ -1606,7 +1606,7 @@ build_functional_cast (tree exp, tree parms, tsubst_flags_t complain)\n \n      then the slot being initialized will be filled in.  */\n \n-  if (!complete_type_or_else (type, NULL_TREE))\n+  if (!complete_type_or_maybe_complain (type, NULL_TREE, complain))\n     return error_mark_node;\n   if (abstract_virtuals_error (NULL_TREE, type))\n     return error_mark_node;\n@@ -1631,7 +1631,7 @@ build_functional_cast (tree exp, tree parms, tsubst_flags_t complain)\n \t just calling the constructor, so fall through.  */\n       && !TYPE_HAS_USER_CONSTRUCTOR (type))\n     {\n-      exp = build_value_init (type);\n+      exp = build_value_init (type, complain);\n       return get_target_expr (exp);\n     }\n "}, {"sha": "9013a058933342237ec91db2f42f4905ddd653e7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309714d4388913de9f47100d4fc77c028aee807d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309714d4388913de9f47100d4fc77c028aee807d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=309714d4388913de9f47100d4fc77c028aee807d", "patch": "@@ -1,3 +1,8 @@\n+2010-08-06  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/cpp0x/sfinae3.C: New.\n+\t* g++.dg/cpp0x/sfinae4.C: New.\n+\n 2010-08-06  Richard Guenther  <rguenther@suse.de>\n \n \t* gcc.dg/tree-ssa/ssa-dce-3.c: XFAIL."}, {"sha": "8582ba777c45e1111070b9fc66b977f730d32ae5", "filename": "gcc/testsuite/g++.dg/cpp0x/sfinae3.C", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309714d4388913de9f47100d4fc77c028aee807d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309714d4388913de9f47100d4fc77c028aee807d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae3.C?ref=309714d4388913de9f47100d4fc77c028aee807d", "patch": "@@ -0,0 +1,56 @@\n+// { dg-options -std=c++0x }\n+\n+namespace std { template <class T> T&& declval(); }\n+\n+template<typename _Tp, typename... _Args>\n+  class is_constructible_mini\n+  {\n+    typedef char __one;\n+    typedef struct { char __arr[2]; } __two;\n+\n+    template<typename _Tp1, typename... _Args1>\n+      static decltype(::new _Tp1(std::declval<_Args1>()...), __one())\n+      __test(int);\n+\n+    template<typename, typename...>\n+      static __two __test(...);\n+\n+  public:\n+    static const bool value = sizeof(__test<_Tp, _Args...>(0)) == 1;\n+  };\n+\n+/*\n+template<typename _Tp>\n+  class is_constructible_mini<_Tp>\n+  {\n+    typedef char __one;\n+    typedef struct { char __arr[2]; } __two;\n+\n+    template<typename _Tp1>\n+      static decltype(::new _Tp1, __one()) __test(int);\n+\n+    template<typename>\n+      static __two __test(...);\n+\n+  public:\n+    static const bool value\n+    = sizeof(__test<typename std::remove_cv<_Tp>::type>(0)) == 1;\n+  };\n+*/\n+\n+struct A\n+{\n+  A(int);\n+};\n+\n+struct B { };\n+\n+static_assert( is_constructible_mini<A, int>::value, \"\");\n+static_assert( is_constructible_mini<A, A>::value, \"\");\n+static_assert( !is_constructible_mini<A, int, double>::value, \"\");\n+\n+static_assert( !is_constructible_mini<A>::value, \"\");  // doesn't compile without the\n+                                                       // partial specialization\n+\n+static_assert( is_constructible_mini<B>::value, \"\");\n+static_assert( is_constructible_mini<const B>::value, \"\");"}, {"sha": "b664831249896110e844d466d4535ed23b39f598", "filename": "gcc/testsuite/g++.dg/cpp0x/sfinae4.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309714d4388913de9f47100d4fc77c028aee807d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309714d4388913de9f47100d4fc77c028aee807d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae4.C?ref=309714d4388913de9f47100d4fc77c028aee807d", "patch": "@@ -0,0 +1,23 @@\n+// { dg-options -std=c++0x }\n+\n+namespace std { template <class T> T&& declval(); }\n+\n+template<typename _Tp, typename... _Args>\n+  class is_constructible_mini\n+  {\n+    typedef char __one;\n+    typedef struct { char __arr[2]; } __two;\n+\n+    template<typename _Tp1, typename... _Args1>\n+      static decltype(::new _Tp1(std::declval<_Args1>()...), __one())\n+      __test(int);\n+\n+    template<typename, typename...>\n+      static __two __test(...);\n+\n+  public:\n+    static const bool value = sizeof(__test<_Tp, _Args...>(0)) == 1;\n+  };\n+\n+static_assert( !is_constructible_mini<int[], int>::value, \"\");\n+static_assert( !is_constructible_mini<void, int>::value, \"\");"}]}