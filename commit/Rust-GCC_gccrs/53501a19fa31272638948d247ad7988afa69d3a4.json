{"sha": "53501a19fa31272638948d247ad7988afa69d3a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM1MDFhMTlmYTMxMjcyNjM4OTQ4ZDI0N2FkNzk4OGFmYTY5ZDNhNA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.com", "date": "2002-06-28T15:43:54Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2002-06-28T15:43:54Z"}, "message": "Prevent creation of paradoxical FLOAT_MODE subregs\n\nFrom-SVN: r55064", "tree": {"sha": "b551da7ab87d09377d299d36ba9dc9390c9f471c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b551da7ab87d09377d299d36ba9dc9390c9f471c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/53501a19fa31272638948d247ad7988afa69d3a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53501a19fa31272638948d247ad7988afa69d3a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53501a19fa31272638948d247ad7988afa69d3a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53501a19fa31272638948d247ad7988afa69d3a4/comments", "author": null, "committer": null, "parents": [{"sha": "20c2d1fea3d673ea7ee8e6aedf294130797fde68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20c2d1fea3d673ea7ee8e6aedf294130797fde68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20c2d1fea3d673ea7ee8e6aedf294130797fde68"}], "stats": {"total": 51, "additions": 39, "deletions": 12}, "files": [{"sha": "0b8c5a7567328c93cadba4702f5cb869042a2d70", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53501a19fa31272638948d247ad7988afa69d3a4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53501a19fa31272638948d247ad7988afa69d3a4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=53501a19fa31272638948d247ad7988afa69d3a4", "patch": "@@ -1,3 +1,9 @@\n+2001-06-08  Bernd Schmidt  <bernds@redhat.com>\n+\n+\t* emit-rtl.c (gen_lowpart_common): Don't create paradoxical FLOAT_MODE\n+\tsubregs.\n+\t* recog.c (general_operand, register_operand): Disallow them.\n+\n 2002-06-28  Neil Booth  <neil@daikokuya.co.uk>\n \n \tPR preprocessor/7138"}, {"sha": "956d38db7424317c232cc980b4146d9f3425991c", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53501a19fa31272638948d247ad7988afa69d3a4/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53501a19fa31272638948d247ad7988afa69d3a4/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=53501a19fa31272638948d247ad7988afa69d3a4", "patch": "@@ -964,6 +964,11 @@ gen_lowpart_common (mode, x)\n \t  > ((xsize + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)))\n     return 0;\n \n+  /* Don't allow generating paradoxical FLOAT_MODE subregs.  */\n+  if (GET_MODE_CLASS (mode) == MODE_FLOAT\n+      && GET_MODE (x) != VOIDmode && msize > xsize)\n+    return 0;\n+\n   offset = subreg_lowpart_offset (mode, GET_MODE (x));\n \n   if ((GET_CODE (x) == ZERO_EXTEND || GET_CODE (x) == SIGN_EXTEND)"}, {"sha": "5b5d3dc062a8b78be0cc18f0e2ecc300be17da6d", "filename": "gcc/recog.c", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53501a19fa31272638948d247ad7988afa69d3a4/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53501a19fa31272638948d247ad7988afa69d3a4/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=53501a19fa31272638948d247ad7988afa69d3a4", "patch": "@@ -958,11 +958,13 @@ general_operand (op, mode)\n \n   if (code == SUBREG)\n     {\n+      rtx sub = SUBREG_REG (op);\n+\n #ifdef INSN_SCHEDULING\n       /* On machines that have insn scheduling, we want all memory\n \t reference to be explicit, so outlaw paradoxical SUBREGs.  */\n-      if (GET_CODE (SUBREG_REG (op)) == MEM\n-\t  && GET_MODE_SIZE (mode) > GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))))\n+      if (GET_CODE (sub) == MEM\n+\t  && GET_MODE_SIZE (mode) > GET_MODE_SIZE (GET_MODE (sub)))\n \treturn 0;\n #endif\n       /* Avoid memories with nonzero SUBREG_BYTE, as offsetting the memory\n@@ -972,10 +974,16 @@ general_operand (op, mode)\n \n \t ??? This is a kludge.  */\n       if (!reload_completed && SUBREG_BYTE (op) != 0\n-\t  && GET_CODE (SUBREG_REG (op)) == MEM)\n+\t  && GET_CODE (sub) == MEM)\n \treturn 0;\n \n-      op = SUBREG_REG (op);\n+      /* FLOAT_MODE subregs can't be paradoxical.  Combine will occasionally\n+ \t create such rtl, and we must reject it.  */\n+      if (GET_MODE_CLASS (GET_MODE (op)) == MODE_FLOAT\n+\t  && GET_MODE_SIZE (GET_MODE (op)) > GET_MODE_SIZE (GET_MODE (sub)))\n+\treturn 0;\n+\n+      op = sub;\n       code = GET_CODE (op);\n     }\n \n@@ -1048,28 +1056,36 @@ register_operand (op, mode)\n \n   if (GET_CODE (op) == SUBREG)\n     {\n+      rtx sub = SUBREG_REG (op);\n+\n       /* Before reload, we can allow (SUBREG (MEM...)) as a register operand\n \t because it is guaranteed to be reloaded into one.\n \t Just make sure the MEM is valid in itself.\n \t (Ideally, (SUBREG (MEM)...) should not exist after reload,\n \t but currently it does result from (SUBREG (REG)...) where the\n \t reg went on the stack.)  */\n-      if (! reload_completed && GET_CODE (SUBREG_REG (op)) == MEM)\n+      if (! reload_completed && GET_CODE (sub) == MEM)\n \treturn general_operand (op, mode);\n \n #ifdef CLASS_CANNOT_CHANGE_MODE\n-      if (GET_CODE (SUBREG_REG (op)) == REG\n-\t  && REGNO (SUBREG_REG (op)) < FIRST_PSEUDO_REGISTER\n+      if (GET_CODE (sub) == REG\n+\t  && REGNO (sub) < FIRST_PSEUDO_REGISTER\n \t  && (TEST_HARD_REG_BIT\n \t      (reg_class_contents[(int) CLASS_CANNOT_CHANGE_MODE],\n-\t       REGNO (SUBREG_REG (op))))\n-\t  && CLASS_CANNOT_CHANGE_MODE_P (mode, GET_MODE (SUBREG_REG (op)))\n-\t  && GET_MODE_CLASS (GET_MODE (SUBREG_REG (op))) != MODE_COMPLEX_INT\n-\t  && GET_MODE_CLASS (GET_MODE (SUBREG_REG (op))) != MODE_COMPLEX_FLOAT)\n+\t       REGNO (sub)))\n+\t  && CLASS_CANNOT_CHANGE_MODE_P (mode, GET_MODE (sub))\n+\t  && GET_MODE_CLASS (GET_MODE (sub)) != MODE_COMPLEX_INT\n+\t  && GET_MODE_CLASS (GET_MODE (sub)) != MODE_COMPLEX_FLOAT)\n \treturn 0;\n #endif\n \n-      op = SUBREG_REG (op);\n+      /* FLOAT_MODE subregs can't be paradoxical.  Combine will occasionally\n+\t create such rtl, and we must reject it.  */\n+      if (GET_MODE_CLASS (GET_MODE (op)) == MODE_FLOAT\n+\t  && GET_MODE_SIZE (GET_MODE (op)) > GET_MODE_SIZE (GET_MODE (sub)))\n+\treturn 0;\n+\n+      op = sub;\n     }\n \n   /* If we have an ADDRESSOF, consider it valid since it will be"}]}