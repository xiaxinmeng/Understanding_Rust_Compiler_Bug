{"sha": "3c32917793e8ecf6c8ca77060b0cb0c985e66419", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2MzMjkxNzc5M2U4ZWNmNmM4Y2E3NzA2MGIwY2IwYzk4NWU2NjQxOQ==", "commit": {"author": {"name": "Will Schmidt", "email": "will_schmidt@vnet.ibm.com", "date": "2018-10-11T21:25:23Z"}, "committer": {"name": "Will Schmidt", "email": "willschm@gcc.gnu.org", "date": "2018-10-11T21:25:23Z"}, "message": "fold-vec-extract-char.p7.c: New.\n\n[testsuite]\n\t* gcc.target/powerpc/fold-vec-extract-char.p7.c: New.\n\t* gcc.target/powerpc/fold-vec-extract-char.p8.c: New.\n\t* gcc.target/powerpc/fold-vec-extract-char.p9.c: New.\n\t* gcc.target/powerpc/fold-vec-extract-double.p7.c: New.\n\t* gcc.target/powerpc/fold-vec-extract-double.p8.c: New.\n\t* gcc.target/powerpc/fold-vec-extract-double.p9.c: New.\n\t* gcc.target/powerpc/fold-vec-extract-float.p7.c: New.\n\t* gcc.target/powerpc/fold-vec-extract-float.p8.c: New.\n\t* gcc.target/powerpc/fold-vec-extract-float.p9.c: New.\n\t* gcc.target/powerpc/fold-vec-extract-int.p7.c: New.\n\t* gcc.target/powerpc/fold-vec-extract-int.p8.c: New.\n\t* gcc.target/powerpc/fold-vec-extract-int.p9.c: New.\n\t* gcc.target/powerpc/fold-vec-extract-longlong.p7.c: New.\n\t* gcc.target/powerpc/fold-vec-extract-longlong.p8.c: New.\n\t* gcc.target/powerpc/fold-vec-extract-longlong.p9.c: New.\n\t* gcc.target/powerpc/fold-vec-extract-short.p7.c: New.\n\t* gcc.target/powerpc/fold-vec-extract-short.p8.c: New.\n\t* gcc.target/powerpc/fold-vec-extract-short.p9.c: New.\n\nFrom-SVN: r265066", "tree": {"sha": "db8c12f7048f0d9935498fd8f75fbd486924e3b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db8c12f7048f0d9935498fd8f75fbd486924e3b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c32917793e8ecf6c8ca77060b0cb0c985e66419", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c32917793e8ecf6c8ca77060b0cb0c985e66419", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c32917793e8ecf6c8ca77060b0cb0c985e66419", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c32917793e8ecf6c8ca77060b0cb0c985e66419/comments", "author": {"login": "willschm", "id": 44359, "node_id": "MDQ6VXNlcjQ0MzU5", "avatar_url": "https://avatars.githubusercontent.com/u/44359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willschm", "html_url": "https://github.com/willschm", "followers_url": "https://api.github.com/users/willschm/followers", "following_url": "https://api.github.com/users/willschm/following{/other_user}", "gists_url": "https://api.github.com/users/willschm/gists{/gist_id}", "starred_url": "https://api.github.com/users/willschm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willschm/subscriptions", "organizations_url": "https://api.github.com/users/willschm/orgs", "repos_url": "https://api.github.com/users/willschm/repos", "events_url": "https://api.github.com/users/willschm/events{/privacy}", "received_events_url": "https://api.github.com/users/willschm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d9519daf1e1632872c28c45996e4849665b9854e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9519daf1e1632872c28c45996e4849665b9854e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9519daf1e1632872c28c45996e4849665b9854e"}], "stats": {"total": 993, "additions": 993, "deletions": 0}, "files": [{"sha": "79ca29273fd1a63505ee80780a86310e12399aa4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3c32917793e8ecf6c8ca77060b0cb0c985e66419", "patch": "@@ -1,3 +1,24 @@\n+2018-10-11  Will Schmidt  <will_schmidt@vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/fold-vec-extract-char.p7.c: New.\n+\t* gcc.target/powerpc/fold-vec-extract-char.p8.c: New.\n+\t* gcc.target/powerpc/fold-vec-extract-char.p9.c: New.\n+\t* gcc.target/powerpc/fold-vec-extract-double.p7.c: New.\n+\t* gcc.target/powerpc/fold-vec-extract-double.p8.c: New.\n+\t* gcc.target/powerpc/fold-vec-extract-double.p9.c: New.\n+\t* gcc.target/powerpc/fold-vec-extract-float.p7.c: New.\n+\t* gcc.target/powerpc/fold-vec-extract-float.p8.c: New.\n+\t* gcc.target/powerpc/fold-vec-extract-float.p9.c: New.\n+\t* gcc.target/powerpc/fold-vec-extract-int.p7.c: New.\n+\t* gcc.target/powerpc/fold-vec-extract-int.p8.c: New.\n+\t* gcc.target/powerpc/fold-vec-extract-int.p9.c: New.\n+\t* gcc.target/powerpc/fold-vec-extract-longlong.p7.c: New.\n+\t* gcc.target/powerpc/fold-vec-extract-longlong.p8.c: New.\n+\t* gcc.target/powerpc/fold-vec-extract-longlong.p9.c: New.\n+\t* gcc.target/powerpc/fold-vec-extract-short.p7.c: New.\n+\t* gcc.target/powerpc/fold-vec-extract-short.p8.c: New.\n+\t* gcc.target/powerpc/fold-vec-extract-short.p9.c: New.\n+\n 2018-10-11  Will Schmidt  <will_schmidt@vnet.ibm.com>\n \n \t* gcc.target/powerpc/fold-vec-select-char.c: New."}, {"sha": "9ca3878f5d51787c8854203f7a779af64fb6e700", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-extract-char.p7.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-char.p7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-char.p7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-char.p7.c?ref=3c32917793e8ecf6c8ca77060b0cb0c985e66419", "patch": "@@ -0,0 +1,61 @@\n+/* Verify that overloaded built-ins for vec_extract() with char\n+   inputs produce the right code with a power7 (BE) target.  */\n+\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n+/* { dg-options \"-mcpu=power7 -O2\" } */\n+\n+// Six tests total. Targeting P7 (BE).\n+// P7 variable offset:  addi, li,       stxvw4x, rldicl, add, lbz, (extsb)\n+// P7 const offset:           li, addi, stxvw4x,              lbz, (extsb)\n+/* one extsb (extend sign-bit) instruction generated for each test against\n+   unsigned types */\n+\n+/* { dg-final { scan-assembler-times {\\maddi\\M} 6 } } */\n+/* { dg-final { scan-assembler-times {\\mli\\M} 6 } } */\n+/* { dg-final { scan-assembler-times {\\mstxvw4x\\M|\\mstvx\\M|\\mstxv\\M} 6 } } */\n+/* -m32 target uses rlwinm in place of rldicl. */\n+/* { dg-final { scan-assembler-times {\\mrldicl\\M|\\mrlwinm\\M} 3 } } */\n+/* { dg-final { scan-assembler-times {\\madd\\M} 3 } } */\n+/* { dg-final { scan-assembler-times {\\mlbz\\M} 6 } } */\n+/* { dg-final { scan-assembler-times {\\mextsb\\M} 2 } } */\n+\n+#include <altivec.h>\n+\n+unsigned char\n+testbc_var (vector bool char vbc2, signed int si)\n+{\n+  return vec_extract (vbc2, si);\n+}\n+\n+signed char\n+testsc_var (vector signed char vsc2, signed int si)\n+{\n+  return vec_extract (vsc2, si);\n+}\n+\n+unsigned char\n+testuc_var (vector unsigned char vuc2, signed int si)\n+{\n+  return vec_extract (vuc2, si);\n+}\n+\n+unsigned char\n+testbc_cst (vector bool char vbc2)\n+{\n+  return vec_extract (vbc2, 12);\n+}\n+\n+signed char\n+testsc_cst (vector signed char vsc2)\n+{\n+  return vec_extract (vsc2, 12);\n+}\n+\n+unsigned char\n+testuc_cst (vector unsigned char vuc2)\n+{\n+  return vec_extract (vuc2, 12);\n+}\n+"}, {"sha": "ba065dc93b0b41b2eb66e7129f157541fce10198", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-extract-char.p8.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-char.p8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-char.p8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-char.p8.c?ref=3c32917793e8ecf6c8ca77060b0cb0c985e66419", "patch": "@@ -0,0 +1,70 @@\n+/* Verify that overloaded built-ins for vec_extract() with char\n+   inputs produce the right code with a P8 (LE or BE) target.  */\n+\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O2\" } */\n+\n+// six tests total. Targeting P8LE / P8BE.\n+// P8 LE variable offset: rldicl, subfic, sldi, mtvsrd, xxpermdi, vslo, mfvsrd, sradi, (extsb)\n+// P8 LE constant offset: vspltb, mfvsrd, rlwinm, (extsb)\n+// P8 BE variable offset:                 sldi, mtvsrd, xxpermdi, vslo, mfvsrd, sradi, (extsb)\n+// P8 BE constant offset: vspltb, mfvsrd, rlwinm, (extsb)\n+\n+/* { dg-final { scan-assembler-times {\\mrldicl\\M} 3 { target { le } } } } */\n+/* { dg-final { scan-assembler-times {\\msubfic\\M} 3 { target { le } } } } */\n+/* { dg-final { scan-assembler-times {\\msldi\\M} 3 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mmtvsrd\\M} 3 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mxxpermdi\\M} 3 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mvslo\\M} 3 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mmfvsrd\\M} 6 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\msradi\\M} 3 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times \"extsb\" 2 } } */\n+/* { dg-final { scan-assembler-times {\\mvspltb\\M} 3 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mrlwinm\\M} 2 { target lp64} } } */\n+\n+/* multiple codegen variations for -m32. */\n+/* { dg-final { scan-assembler-times {\\mrlwinm\\M} 3 { target ilp32} } } */\n+/* { dg-final { scan-assembler-times {\\mstxvw4x\\M} 6 { target ilp32} } } */\n+/* { dg-final { scan-assembler-times {\\mlbz\\M} 6 { target ilp32} } } */\n+\n+\n+#include <altivec.h>\n+\n+unsigned char\n+testbc_var (vector bool char vbc2,signed int si)\n+{\n+  return vec_extract (vbc2, si);\n+}\n+\n+signed char\n+testsc_var (vector signed char vsc2, signed int si)\n+{\n+  return vec_extract (vsc2, si);\n+}\n+\n+unsigned char\n+testuc_var (vector unsigned char vuc2, signed int si)\n+{\n+  return vec_extract (vuc2, si);\n+}\n+\n+unsigned char\n+testbc_cst (vector bool char vbc2)\n+{\n+  return vec_extract (vbc2, 12);\n+}\n+\n+signed char\n+testsc_cst (vector signed char vsc2)\n+{\n+  return vec_extract (vsc2, 12);\n+}\n+\n+unsigned char\n+testuc_cst (vector unsigned char vuc2)\n+{\n+  return vec_extract (vuc2, 12);\n+}\n+"}, {"sha": "227497538d6581678f6d424f5c78611fa9adeae1", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-extract-char.p9.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-char.p9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-char.p9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-char.p9.c?ref=3c32917793e8ecf6c8ca77060b0cb0c985e66419", "patch": "@@ -0,0 +1,56 @@\n+/* Verify that overloaded built-ins for vec_extract() with char\n+   inputs produce the right code with a P9 (LE) target.  */\n+\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -O2 \" } */\n+\n+/* { dg-final { scan-assembler-times {\\mli\\M} 3 { target lp64 } } } */\n+/*  Endian sensitive, vextubrx or vextublx.  */\n+/* { dg-final { scan-assembler-times \"vextubrx|vextublx\" 6 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times \"extsb\" 2 } } */\n+\n+/* { dg-final { scan-assembler-times \"stxv\" 6 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times \"lbz\" 6 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times \"addi\" 6 { target ilp32 } } } */\n+\n+\n+#include <altivec.h>\n+\n+unsigned char\n+testbc_var (vector bool char vbc2,signed int si)\n+{\n+  return vec_extract (vbc2, si);\n+}\n+\n+signed char\n+testsc_var (vector signed char vsc2, signed int si)\n+{\n+  return vec_extract (vsc2, si);\n+}\n+\n+unsigned char\n+testuc_var (vector unsigned char vuc2, signed int si)\n+{\n+  return vec_extract (vuc2, si);\n+}\n+\n+unsigned char\n+testbc_cst (vector bool char vbc2)\n+{\n+  return vec_extract (vbc2, 12);\n+}\n+\n+signed char\n+testsc_cst (vector signed char vsc2)\n+{\n+  return vec_extract (vsc2, 12);\n+}\n+\n+unsigned char\n+testuc_cst (vector unsigned char vuc2)\n+{\n+  return vec_extract (vuc2, 12);\n+}\n+"}, {"sha": "49ebf42240fa62c0e35d628f054945b633233e0b", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-extract-double.p7.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-double.p7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-double.p7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-double.p7.c?ref=3c32917793e8ecf6c8ca77060b0cb0c985e66419", "patch": "@@ -0,0 +1,35 @@\n+/* Verify that overloaded built-ins for vec_extract() with\n+   double inputs produce the right code.  */\n+\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n+/* { dg-options \"-mcpu=power7 -O2 -mbig-endian\" } */\n+\n+// targeting P7 (BE), 2 tests.\n+// P7 constants: xxpermdi\n+// P7 variables: li, addi, rldic, addi, stxvd2x, lfdx\n+\n+/* { dg-final { scan-assembler-times {\\mxxpermdi\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mli\\M} 1 } } */\n+/* -m32 target has an 'add' in place of one of the 'addi'. */\n+/* { dg-final { scan-assembler-times {\\maddi\\M|\\madd\\M} 2 } } */\n+/* -m32 target has a rlwinm in place of a rldic .  */\n+/* { dg-final { scan-assembler-times {\\mrldic\\M|\\mrlwinm\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mstxvd2x\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mlfdx\\M|\\mlfd\\M} 1 } } */\n+\n+#include <altivec.h>\n+\n+double\n+testd_var (vector double vd2, signed int si)\n+{\n+  return vec_extract (vd2, si);\n+}\n+\n+double\n+testd_cst (vector double vd2)\n+{\n+  return vec_extract (vd2, 1);\n+}\n+"}, {"sha": "f418008b5e4071fa0bb10fcb6a1230914a03aa25", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-extract-double.p8.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-double.p8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-double.p8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-double.p8.c?ref=3c32917793e8ecf6c8ca77060b0cb0c985e66419", "patch": "@@ -0,0 +1,40 @@\n+/* Verify that overloaded built-ins for vec_extract() with\n+   double inputs produce the right code with a P8 (LE or BE) target.  */\n+\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O2\" } */\n+\n+// targeting P8, BE and LE. 2 tests.\n+// P8 (LE) constants: xxlor\n+// P8 (LE) variables: xori, rldic, mtvsrd, xxpermdi, vslo, xxlor\n+// P8 (BE) constants: xxpermdi\n+// P8 (BE) variables:       rldic, mtvsrd, xxpermdi, vslo, xxlor\n+\n+/* { dg-final { scan-assembler-times {\\mxxlor\\M} 2 { target { le && lp64 } } } } */\n+/* { dg-final { scan-assembler-times {\\mxxlor\\M} 1 { target { be && lp64 } } } } */\n+/* { dg-final { scan-assembler-times {\\mxori\\M} 1 { target { le } } } } */\n+/* { dg-final { scan-assembler-times {\\mrldic\\M|\\mrlwinm\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mmtvsrd\\M} 1 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mxxpermdi\\M} 1 { target { le } } } } */\n+/* { dg-final { scan-assembler-times {\\mxxpermdi\\M} 2 { target { lp64 && be } } } } */\n+/* { dg-final { scan-assembler-times {\\mvslo\\M} 1 { target lp64 } } } */\n+\n+/* { dg-final { scan-assembler-times {\\mstxvd2x\\M} 1 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\mxxpermdi\\M} 1 { target ilp32 } } } */\n+\n+#include <altivec.h>\n+\n+double\n+testd_var (vector double vd2, signed int si)\n+{\n+  return vec_extract (vd2, si);\n+}\n+\n+double\n+testd_cst (vector double vd2)\n+{\n+  return vec_extract (vd2, 1);\n+}\n+"}, {"sha": "c5a2a130abce5005127b4996550f6feb98497c4f", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-extract-double.p9.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-double.p9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-double.p9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-double.p9.c?ref=3c32917793e8ecf6c8ca77060b0cb0c985e66419", "patch": "@@ -0,0 +1,27 @@\n+/* Verify that overloaded built-ins for vec_extract() with\n+   double inputs produce the right code.  */\n+\n+/* { dg-do compile { target { p9vector_hw } } } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -O2 \" } */\n+\n+/* { dg-final { scan-assembler-times {\\mxxlor\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mrldic\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mmtvsrdd\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mvslo\\M} 1 } } */\n+\n+#include <altivec.h>\n+\n+double\n+testd_var (vector double vd2, signed int si)\n+{\n+  return vec_extract (vd2, si);\n+}\n+\n+double\n+testd_cst (vector double vd2)\n+{\n+  return vec_extract (vd2, 1);\n+}\n+"}, {"sha": "c1d0996b7ccd0860eb16e7d97bb92a707b7dd446", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-extract-float.p7.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-float.p7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-float.p7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-float.p7.c?ref=3c32917793e8ecf6c8ca77060b0cb0c985e66419", "patch": "@@ -0,0 +1,36 @@\n+/* Verify that overloaded built-ins for vec_extract() with float\n+   inputs produce the right code with a P7 (BE) target.  */\n+\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n+/* { dg-options \"-mcpu=power7 -O2 \" } */\n+\n+// targeting P7 (BE), 2 tests.\n+// P7 constants: xscvspdp\n+// P7 variables: li, addi, stxvd2x, rldic, addi, lfsx\n+\n+/* { dg-final { scan-assembler-times {\\mxscvspdp\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mli\\M} 1 } } */\n+/* -m32 as an add in place of an addi. */\n+/* { dg-final { scan-assembler-times {\\maddi\\M|\\madd\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mstxvd2x\\M|\\mstvx\\M|\\mstxv\\M} 1 } } */\n+/* -m32 uses rlwinm in place of rldic */\n+/* { dg-final { scan-assembler-times {\\mrldic\\M|\\mrlwinm\\M} 1 } } */\n+/* -m32 has lfs in place of lfsx */\n+/* { dg-final { scan-assembler-times {\\mlfsx\\M|\\mlfs\\M} 1 } } */\n+\n+#include <altivec.h>\n+\n+float\n+testf_var (vector float vf2, signed int si)\n+{\n+  return vec_extract (vf2, si);\n+}\n+\n+float\n+testf_cst (vector float vf2)\n+{\n+  return vec_extract (vf2, 12);\n+}\n+"}, {"sha": "ff674198372f150c06d00339e6e391ea64d2fe9d", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-extract-float.p8.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-float.p8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-float.p8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-float.p8.c?ref=3c32917793e8ecf6c8ca77060b0cb0c985e66419", "patch": "@@ -0,0 +1,46 @@\n+/* Verify that overloaded built-ins for vec_extract() with float\n+   inputs produce the right code with a P8 (LE or BE) target.  */\n+\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O2\" } */\n+\n+// targeting P8, BE and LE. 2 tests.\n+// P8 (LE) constants: xxsldwi, xscvspdp\n+// P8 (LE) variables: rldicl, subfic, sldi, mtvsrd, xxpermdi, vslo, xscvspdp\n+// P8 (BE) constants:          xscvspdp\n+// P8 (BE) variables:                 sldi, mtvsrd, xxpermdi, vslo, xscvspdp\n+\n+/* { dg-final { scan-assembler-times {\\mxxsldwi\\M} 1 { target { le } } } } */\n+/* { dg-final { scan-assembler-times {\\mxscvspdp\\M} 2 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mrldicl\\M} 1 { target { le } } } } */\n+/* { dg-final { scan-assembler-times {\\msubfic\\M} 1 { target { le } } } } */\n+/* { dg-final { scan-assembler-times {\\msldi\\M} 1 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mmtvsrd\\M} 1 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mxxpermdi\\M} 1 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mvslo\\M} 1 { target lp64 } } } */\n+\n+/* { dg-final { scan-assembler-times {\\mxscvspdp\\M} 1 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\mli\\M} 1 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\mrlwinm\\M} 1 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\mstxvd2x\\M} 1 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\madd\\M} 1 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\mlfs\\M} 1 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\maddi\\M} 1 { target ilp32 } } } */\n+\n+\n+#include <altivec.h>\n+\n+float\n+testf_var (vector float vf2, signed int si)\n+{\n+  return vec_extract (vf2, si);\n+}\n+\n+float\n+testf_cst (vector float vf2)\n+{\n+  return vec_extract (vf2, 12);\n+}\n+"}, {"sha": "d8776b0625aa3300292256f0ffb69c9c15604c6d", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-extract-float.p9.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-float.p9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-float.p9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-float.p9.c?ref=3c32917793e8ecf6c8ca77060b0cb0c985e66419", "patch": "@@ -0,0 +1,29 @@\n+/* Verify that overloaded built-ins for vec_extract() with float\n+   inputs produce the right code.  */\n+\n+/* { dg-do compile { target { powerpc*-*-linux* && le } } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -O2 \" } */\n+\n+/* { dg-final { scan-assembler-times {\\mxscvspdp\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mrldicl\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\msubfic\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\msldi\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mmtvsrdd\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mvslo\\M} 1 } } */\n+\n+#include <altivec.h>\n+\n+float\n+testf_var (vector float vf2, signed int si)\n+{\n+  return vec_extract (vf2, si);\n+}\n+\n+float\n+testf_cst (vector float vf2)\n+{\n+  return vec_extract (vf2, 12);\n+}\n+"}, {"sha": "d7090fbe3378dc408ab567c2bace6ebbf6042372", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-extract-int.p7.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-int.p7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-int.p7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-int.p7.c?ref=3c32917793e8ecf6c8ca77060b0cb0c985e66419", "patch": "@@ -0,0 +1,56 @@\n+/* Verify that overloaded built-ins for vec_extract() with int\n+   inputs produce the right code with a P7 (BE) target.  */\n+\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n+/* { dg-options \"-mcpu=power7 -O2 \" } */\n+\n+// Targeting P7 (BE).  6 tests total.\n+// P7 constant:   li, addi, stxvw4x, rldic, addi, lwzx/lwax\n+// P7 variables:  li, addi, stxvw4x, lwa/lwz\n+\n+/* { dg-final { scan-assembler-times {\\mli\\M} 6 } } */\n+/* { dg-final { scan-assembler-times {\\maddi\\M|\\madd\\M} 9 } } */\n+/* { dg-final { scan-assembler-times {\\mstxvw4x\\M|\\mstvx\\M|\\mstxv\\M} 6 } } */\n+/* { dg-final { scan-assembler-times {\\mrldic\\M|\\mrlwinm\\M} 3 } } */\n+/* { dg-final { scan-assembler-times {\\mlwz\\M|\\mlwa\\M|\\mlwzx\\M|\\mlwax\\M} 6 } } */\n+\n+#include <altivec.h>\n+\n+unsigned int\n+testbi_var (vector bool int vbi2, signed int si)\n+{\n+  return vec_extract (vbi2, si);\n+}\n+\n+signed int\n+testsi_var (vector signed int vsi2, signed int si)\n+{\n+  return vec_extract (vsi2, si);\n+}\n+\n+unsigned int\n+testui_var (vector unsigned int vui2, signed int si)\n+{\n+  return vec_extract (vui2, si);\n+}\n+\n+unsigned int\n+testbi_cst (vector bool int vbi2)\n+{\n+  return vec_extract (vbi2, 12);\n+}\n+\n+signed int\n+testsi_cst (vector signed int vsi2)\n+{\n+  return vec_extract (vsi2, 12);\n+}\n+\n+unsigned int\n+testui_cst (vector unsigned int vui2)\n+{\n+  return vec_extract (vui2, 12);\n+}\n+"}, {"sha": "1463be3089a70c42e4a66c5ed7856abd6821d27f", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-extract-int.p8.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-int.p8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-int.p8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-int.p8.c?ref=3c32917793e8ecf6c8ca77060b0cb0c985e66419", "patch": "@@ -0,0 +1,75 @@\n+/* Verify that overloaded built-ins for vec_extract() with int\n+   inputs produce the right code with a P8 (LE or BE) target.  */\n+\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O2\" } */\n+\n+// Targeting P8 (LE) and (BE).  6 tests total.\n+// P8 LE constant:  vspltw, mfvsrwz, (1:extsw/2:rldicl)\n+// P8 LE variables: rldicl, subfic,  sldi, mtvsrd, xxpermdi, vslo, mfvsrd, sradi, (1:extsw)\n+// P8 BE constant:  vspltw, mfvsrwz, (1:extsw/2:rldicl)\n+// P8 BE variables:                  sldi, mtvsrd, xxpermdi, vslo, mfvsrd, sradi, (1:extsw)\n+\n+/* { dg-final { scan-assembler-times {\\mvspltw\\M} 3 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mmfvsrwz\\M} 3 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mrldicl\\M} 5 { target { le } } } } */\n+/* { dg-final { scan-assembler-times {\\mrldicl\\M} 2 { target { lp64 && be } } } } */\n+/* { dg-final { scan-assembler-times {\\msubfic\\M} 3 { target { le } } } } */\n+/* { dg-final { scan-assembler-times {\\msldi\\M} 3  { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mmtvsrd\\M} 3 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mxxpermdi\\M} 3 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mvslo\\M} 3 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mmfvsrd\\M} 3 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\msradi\\M} 3 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mextsw\\M} 2 { target lp64 } } } */\n+\n+\n+/* { dg-final { scan-assembler-times {\\mli\\M} 6 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\mrlwinm\\M} 3 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\mstxvw4x\\M} 6 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\madd\\M} 3 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\mlwz\\M} 6 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\maddi\\M} 6 { target ilp32 } } } */\n+\n+\n+\n+#include <altivec.h>\n+\n+unsigned int\n+testbi_var (vector bool int vbi2, signed int si)\n+{\n+  return vec_extract (vbi2, si);\n+}\n+\n+signed int\n+testsi_var (vector signed int vsi2, signed int si)\n+{\n+  return vec_extract (vsi2, si);\n+}\n+\n+unsigned int\n+testui_var (vector unsigned int vui2, signed int si)\n+{\n+  return vec_extract (vui2, si);\n+}\n+\n+unsigned int\n+testbi_cst (vector bool int vbi2)\n+{\n+  return vec_extract (vbi2, 12);\n+}\n+\n+signed int\n+testsi_cst (vector signed int vsi2)\n+{\n+  return vec_extract (vsi2, 12);\n+}\n+\n+unsigned int\n+testui_cst (vector unsigned int vui2)\n+{\n+  return vec_extract (vui2, 12);\n+}\n+"}, {"sha": "a8217af4438e6c2872bf35b83adbfa387031c6d0", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-extract-int.p9.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-int.p9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-int.p9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-int.p9.c?ref=3c32917793e8ecf6c8ca77060b0cb0c985e66419", "patch": "@@ -0,0 +1,62 @@\n+/* Verify that overloaded built-ins for vec_extract() with int\n+   inputs produce the right code with a P9 (LE) target.  */\n+\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -O2 \" } */\n+\n+// Targeting P9 (LE).  6 tests total.\n+// P9 constant:   li, vextuwrx, (1:extsw)\n+// P9 variables:  slwi, vextuwrx, (1:extsw)\n+\n+/* { dg-final { scan-assembler-times {\\mli\\M} 3 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mslwi\\M} 3 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mvextuwrx\\M|\\mvextuwlx\\M} 6 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mextsw\\M} 2 { target lp64 } } } */\n+\n+/* { dg-final { scan-assembler-times {\\mrlwinm\\M} 3 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\madd\\M} 3 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\mstxv\\M} 6 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\mlwz\\M} 6 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\maddi\\M} 6 { target ilp32 } } } */\n+\n+\n+#include <altivec.h>\n+\n+unsigned int\n+testbi_var (vector bool int vbi2, signed int si)\n+{\n+  return vec_extract (vbi2, si);\n+}\n+\n+signed int\n+testsi_var (vector signed int vsi2, signed int si)\n+{\n+  return vec_extract (vsi2, si);\n+}\n+\n+unsigned int\n+testui_var (vector unsigned int vui2, signed int si)\n+{\n+  return vec_extract (vui2, si);\n+}\n+\n+unsigned int\n+testbi_cst (vector bool int vbi2)\n+{\n+  return vec_extract (vbi2, 12);\n+}\n+\n+signed int\n+testsi_cst (vector signed int vsi2)\n+{\n+  return vec_extract (vsi2, 12);\n+}\n+\n+unsigned int\n+testui_cst (vector unsigned int vui2)\n+{\n+  return vec_extract (vui2, 12);\n+}\n+"}, {"sha": "c6182151d358c1e6cb399e628d1fb4b6f66585fb", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-extract-longlong.p7.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-longlong.p7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-longlong.p7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-longlong.p7.c?ref=3c32917793e8ecf6c8ca77060b0cb0c985e66419", "patch": "@@ -0,0 +1,68 @@\n+/* Verify that overloaded built-ins for vec_extract() with long long\n+   inputs produce the right code with a P8 (LE or BE) target.  */\n+\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n+/* { dg-options \"-mcpu=power7 -O2\" } */\n+\n+// Targeting P7. six tests total.\n+// P7 (m64) with constants: xxpermdi, stfd, ld\n+// P7 (m64) with variables: li, addi, stxvd2x, rldic, addi, ldx\n+\n+// P7 (m32) with constants: [xxpermdi or li/lwz,li/lwz],stxvw4x/stfd,lwz,lwz, addi\n+// P7 (m32) with variables: li, addi/rlwinm, stxvd2x, rldic, addi/add, ldx/lwz\n+\n+/* results. */\n+/* { dg-final { scan-assembler-times {\\mstfd\\M} 3 { target lp64 } } } */\n+/* -m32 target with constant test has a stxvw4x in place of a stfd. */\n+/* { dg-final { scan-assembler-times {\\mstfd\\M} 2 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\mld\\M} 3 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mlwz\\M} 11 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\mli\\M} 3 { target lp64 } } } */\n+/* -m32 target with constant test uses (+2)li where the -m64 has an ld */\n+/* { dg-final { scan-assembler-times {\\mli\\M} 5 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\maddi\\M} 6 } } */\n+/* { dg-final { scan-assembler-times {\\mstxvd2x\\M|\\mstvx\\M} 3 } } */\n+/* { dg-final { scan-assembler-times {\\mrldic\\M|\\mrlwinm\\M} 3 } } */\n+/* { dg-final { scan-assembler-times {\\mldx\\M} 3 { target lp64 } } } */\n+\n+\n+#include <altivec.h>\n+\n+unsigned long long\n+testbl_var (vector bool long long vbl2, signed int si)\n+{\n+  return vec_extract (vbl2, si);\n+}\n+\n+signed long long\n+testsl_var (vector signed long long vsl2, signed int si)\n+{\n+  return vec_extract (vsl2, si);\n+}\n+\n+unsigned long long\n+testul_var (vector unsigned long long vul2, signed int si)\n+{\n+  return vec_extract (vul2, si);\n+}\n+\n+unsigned long long\n+testbl_cst (vector bool long long vbl2)\n+{\n+  return vec_extract (vbl2, 1);\n+}\n+\n+signed long long\n+testsl_cst (vector signed long long vsl2)\n+{\n+  return vec_extract (vsl2, 1);\n+}\n+\n+unsigned long long\n+testul_cst (vector unsigned long vul2)\n+{\n+  return vec_extract (vul2, 1);\n+}\n+"}, {"sha": "bcad058f209bd41baa78b089f70e9ac139134acf", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-extract-longlong.p8.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-longlong.p8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-longlong.p8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-longlong.p8.c?ref=3c32917793e8ecf6c8ca77060b0cb0c985e66419", "patch": "@@ -0,0 +1,66 @@\n+/* Verify that overloaded built-ins for vec_extract() with long long\n+   inputs produce the right code with a P8 (LE or BE) target.  */\n+\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O2\" } */\n+\n+// targeting P8, both LE and BE. six tests.\n+// P8 (LE) constants: mfvsrd\n+// P8 (LE) variables: xori, rldic, mtvsrd, xxpermdi, vslo, mfvsrd\n+// P8 (BE) constants: xxpermdi, mfvsrd\n+// P8 (BE) Variables:       rldic, mtvsrd, xxpermdi, vslo, mfvsrd\n+\n+/* results. */\n+/* { dg-final { scan-assembler-times {\\mxori\\M} 3 { target le } } } */\n+/* { dg-final { scan-assembler-times {\\mrldic\\M|\\mrlwinm\\M} 3 } } */\n+/* { dg-final { scan-assembler-times {\\mstxvd2x\\M|\\mstxvw4x\\M} 4 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\madd\\M} 3 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\mlwz\\M} 11 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\maddi\\M} 6 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\mmfvsrd\\M} 6 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mmtvsrd\\M} 3 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mxxpermdi\\M} 3 { target le } } } */\n+/* { dg-final { scan-assembler-times {\\mxxpermdi\\M} 6 { target { be && lp64 } } } } */\n+/* { dg-final { scan-assembler-times {\\mxxpermdi\\M} 2 { target { be && ilp32 } } } } */\n+/* { dg-final { scan-assembler-times {\\mvslo\\M} 3 { target lp64 } } } */\n+\n+#include <altivec.h>\n+\n+unsigned long long\n+testbl_var (vector bool long long vbl2, signed int si)\n+{\n+  return vec_extract (vbl2, si);\n+}\n+\n+signed long long\n+testsl_var (vector signed long long vsl2, signed int si)\n+{\n+  return vec_extract (vsl2, si);\n+}\n+\n+unsigned long long\n+testul_var (vector unsigned long long vul2, signed int si)\n+{\n+  return vec_extract (vul2, si);\n+}\n+\n+unsigned long long\n+testbl_cst (vector bool long long vbl2)\n+{\n+  return vec_extract (vbl2, 1);\n+}\n+\n+signed long long\n+testsl_cst (vector signed long long vsl2)\n+{\n+  return vec_extract (vsl2, 1);\n+}\n+\n+unsigned long long\n+testul_cst (vector unsigned long vul2)\n+{\n+  return vec_extract (vul2, 1);\n+}\n+"}, {"sha": "b7e508ea906eae0497e62438296cb774140c7f17", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-extract-longlong.p9.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-longlong.p9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-longlong.p9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-longlong.p9.c?ref=3c32917793e8ecf6c8ca77060b0cb0c985e66419", "patch": "@@ -0,0 +1,57 @@\n+/* Verify that overloaded built-ins for vec_extract() with long long\n+   inputs produce the right code for a P9 (LE) target.  */\n+\n+/* { dg-do compile { target { powerpc*-*-linux* && le } } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+\n+// targeting P9 (LE), six tests.\n+// p9 constants: mfvsrd\n+// p9 vars:  xori, rldic, mtvsrdd, vslo, mfvsrd\n+\n+/* results. */\n+/* { dg-final { scan-assembler-times {\\mxori\\M} 3 } } */\n+/* { dg-final { scan-assembler-times {\\mrldic\\M} 3 } } */\n+/* { dg-final { scan-assembler-times {\\mmtvsrdd\\M} 3 } } */\n+/* { dg-final { scan-assembler-times {\\mvslo\\M} 3 } } */\n+/* { dg-final { scan-assembler-times {\\mmfvsrd\\M} 6 } } */\n+\n+#include <altivec.h>\n+\n+unsigned long long\n+testbl_var (vector bool long long vbl2, signed int si)\n+{\n+  return vec_extract (vbl2, si);\n+}\n+\n+signed long long\n+testsl_var (vector signed long long vsl2, signed int si)\n+{\n+  return vec_extract (vsl2, si);\n+}\n+\n+unsigned long long\n+testul_var (vector unsigned long long vul2, signed int si)\n+{\n+  return vec_extract (vul2, si);\n+}\n+\n+unsigned long long\n+testbl_cst (vector bool long long vbl2)\n+{\n+  return vec_extract (vbl2, 1);\n+}\n+\n+signed long long\n+testsl_cst (vector signed long long vsl2)\n+{\n+  return vec_extract (vsl2, 1);\n+}\n+\n+unsigned long long\n+testul_cst (vector unsigned long vul2)\n+{\n+  return vec_extract (vul2, 1);\n+}\n+"}, {"sha": "edfecf08f1a5431816e961e2ac2f11bdf2d82af7", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-extract-short.p7.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-short.p7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-short.p7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-short.p7.c?ref=3c32917793e8ecf6c8ca77060b0cb0c985e66419", "patch": "@@ -0,0 +1,56 @@\n+/* Verify that overloaded built-ins for vec_extract() with short\n+   inputs produce the right code for a P7 (BE) target.  */\n+\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n+/* { dg-options \"-mcpu=power7 -O2\" } */\n+\n+// six tests total. Targeting P7 BE.\n+// p7 (be) vars:                 li, addi,              stxvw4x, rldic, addi, lhax/lhzx\n+// P7 (be) constants:            li, addi,              stxvw4x, lha/lhz\n+\n+/* { dg-final { scan-assembler-times {\\mli\\M} 6 } } */\n+/* { dg-final { scan-assembler-times {\\maddi\\M|\\madd\\M} 9 } } */\n+/* { dg-final { scan-assembler-times {\\mrldic\\M|\\mrlwinm\\M} 3 } } */\n+/* { dg-final { scan-assembler-times {\\mstxvw4x\\M|\\mstvx\\M} 6 } } */\n+/* { dg-final { scan-assembler-times \"lhz|lha|lhzx|lhax\" 6 } } */\n+\n+#include <altivec.h>\n+\n+unsigned short\n+testbi_cst (vector bool short vbs2)\n+{\n+  return vec_extract (vbs2, 12);\n+}\n+\n+signed short\n+testsi_cst (vector signed short vss2)\n+{\n+  return vec_extract (vss2, 12);\n+}\n+\n+unsigned short\n+testui_cst12 (vector unsigned short vus2)\n+{\n+  return vec_extract (vus2, 12);\n+}\n+\n+unsigned short\n+testbi_var (vector bool short vbs2, signed int si)\n+{\n+  return vec_extract (vbs2, si);\n+}\n+\n+signed short\n+testsi_var (vector signed short vss2, signed int si)\n+{\n+return vec_extract (vss2, si);\n+}\n+\n+unsigned short\n+testui_var (vector unsigned short vus2, signed int si)\n+{\n+return vec_extract (vus2, si);\n+}\n+"}, {"sha": "33e403941aa34f86d2841685cde31e237077c04a", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-extract-short.p8.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-short.p8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-short.p8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-short.p8.c?ref=3c32917793e8ecf6c8ca77060b0cb0c985e66419", "patch": "@@ -0,0 +1,77 @@\n+/* Verify that overloaded built-ins for vec_extract() with short\n+   inputs produce the right results with a P8 (LE or BE) target.  */\n+\n+/* { dg-do compile { target { powerpc*-*-linux* } } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O2\" } */\n+\n+// six tests total. Targeting P8, both LE and BE.\n+// p8 (le) variable offset: rldicl, subfic, sldi, mtvsrd, xxpermdi, vslo, mfvsrd, sradi, *extsh\n+// p8 (le) const offset:                          mtvsrd,                                *extsh/rlwinm\n+// p8 (be) var offset:                      sldi, mtvsrd, xxpermdi, vslo, mfvsrd, sradi, *extsh\n+// p8 (be) const offset:    vsplth,               mfvsrd,                                *extsh/rlwinm\n+\n+// * - each of the above will have an extsh if the argument is signed.\n+// * - bool and unsigned tests also have an rlwinm.\n+\n+/* { dg-final { scan-assembler-times \"rldicl\" 3 {target { lp64 && le } } } } */\n+/* { dg-final { scan-assembler-times \"subfic\" 3 {target { lp64 && le } } } } */\n+/* { dg-final { scan-assembler-times \"vsplth\" 3 { target { lp64 && be } } } } */\n+/* { dg-final { scan-assembler-times \"sldi\" 3 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times \"mtvsrd\" 3 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times \"xxpermdi\" 3 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times \"vslo\" 3 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times \"mfvsrd\" 6 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times \"sradi\" 3 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times \"extsh\" 2 { target lp64 } } } */\n+/* { dg-final { scan-assembler-times \"rlwinm\" 2 { target lp64 } } } */\n+\n+/* -m32 codegen tests. */\n+/* { dg-final { scan-assembler-times {\\mli\\M} 6 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times \"stxvw4x\" 6 { target ilp32 } } } */\n+/* add and rlwinm instructions only on the variable tests. */\n+/* { dg-final { scan-assembler-times {\\madd\\M} 3 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times \"rlwinm\" 3 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\maddi\\M} 6 { target ilp32 } } } */\n+/* { dg-final { scan-assembler-times {\\mlha\\M|\\mlhz\\M} 6 { target ilp32 } } } */\n+\n+\n+#include <altivec.h>\n+\n+unsigned short\n+testbi_cst (vector bool short vbs2)\n+{\n+  return vec_extract (vbs2, 12);\n+}\n+\n+signed short\n+testsi_cst (vector signed short vss2)\n+{\n+  return vec_extract (vss2, 12);\n+}\n+\n+unsigned short\n+testui_cst12 (vector unsigned short vus2)\n+{\n+  return vec_extract (vus2, 12);\n+}\n+\n+unsigned short\n+testbi_var (vector bool short vbs2, signed int si)\n+{\n+  return vec_extract (vbs2, si);\n+}\n+\n+signed short\n+testsi_var (vector signed short vss2, signed int si)\n+{\n+return vec_extract (vss2, si);\n+}\n+\n+unsigned short\n+testui_var (vector unsigned short vus2, signed int si)\n+{\n+return vec_extract (vus2, si);\n+}\n+"}, {"sha": "b45f3cfdf57219ceb9e921e584f68b02b81ab642", "filename": "gcc/testsuite/gcc.target/powerpc/fold-vec-extract-short.p9.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-short.p9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c32917793e8ecf6c8ca77060b0cb0c985e66419/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-short.p9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffold-vec-extract-short.p9.c?ref=3c32917793e8ecf6c8ca77060b0cb0c985e66419", "patch": "@@ -0,0 +1,55 @@\n+/* Verify that overloaded built-ins for vec_extract() with short\n+   inputs produce the right code for a P9 (LE) target.  */\n+\n+/* { dg-do compile { target { powerpc*-*-linux* && le } } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+\n+// six tests total. Targeting P9 LE.\n+// p9 (le) variable offset: slwi, vextuhlx, extsh\n+// p9 (le) const offset:  li, vextuhlx, extsh\n+\n+/* { dg-final { scan-assembler-times {\\mslwi\\M} 3 } } */\n+/* { dg-final { scan-assembler-times {\\mli\\M} 3 } } */\n+/* { dg-final { scan-assembler-times \"vextuhrx\" 6 } } */\n+/* { dg-final { scan-assembler-times {\\mextsh\\M} 2 } } */\n+\n+#include <altivec.h>\n+\n+unsigned short\n+testbi_cst (vector bool short vbs2)\n+{\n+  return vec_extract (vbs2, 12);\n+}\n+\n+signed short\n+testsi_cst (vector signed short vss2)\n+{\n+  return vec_extract (vss2, 12);\n+}\n+\n+unsigned short\n+testui_cst12 (vector unsigned short vus2)\n+{\n+  return vec_extract (vus2, 12);\n+}\n+\n+unsigned short\n+testbi_var (vector bool short vbs2, signed int si)\n+{\n+  return vec_extract (vbs2, si);\n+}\n+\n+signed short\n+testsi_var (vector signed short vss2, signed int si)\n+{\n+return vec_extract (vss2, si);\n+}\n+\n+unsigned short\n+testui_var (vector unsigned short vus2, signed int si)\n+{\n+return vec_extract (vus2, si);\n+}\n+"}]}