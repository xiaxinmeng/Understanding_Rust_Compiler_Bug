{"sha": "d0cee9ba75d0aa5b65704190f6a5fa2af74aea95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBjZWU5YmE3NWQwYWE1YjY1NzA0MTkwZjZhNWZhMmFmNzRhZWE5NQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "1999-12-08T07:26:04Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1999-12-08T07:26:04Z"}, "message": "sparc.c (hard_32bit_mode_classes): Mark registers suitable for holding OFmode values so that gcc works with...\n\n\t* config/sparc/sparc.c (hard_32bit_mode_classes): Mark registers\n\tsuitable for holding OFmode values so that gcc works with complex\n\tquad long doubles.\n\t(hard_64bit_mode_classes): Likewise.\n\nFrom-SVN: r30821", "tree": {"sha": "67af9f330085041f02364924d2213eb122cbdf75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67af9f330085041f02364924d2213eb122cbdf75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0cee9ba75d0aa5b65704190f6a5fa2af74aea95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0cee9ba75d0aa5b65704190f6a5fa2af74aea95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0cee9ba75d0aa5b65704190f6a5fa2af74aea95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0cee9ba75d0aa5b65704190f6a5fa2af74aea95/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "60fb6df968b2ed5ee054874052371f08b59cb712", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60fb6df968b2ed5ee054874052371f08b59cb712", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60fb6df968b2ed5ee054874052371f08b59cb712"}], "stats": {"total": 64, "additions": 39, "deletions": 25}, "files": [{"sha": "d7d5d9f22810c579578e3c93dbb84ff33e6c5201", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0cee9ba75d0aa5b65704190f6a5fa2af74aea95/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0cee9ba75d0aa5b65704190f6a5fa2af74aea95/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d0cee9ba75d0aa5b65704190f6a5fa2af74aea95", "patch": "@@ -1,3 +1,10 @@\n+1999-12-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* config/sparc/sparc.c (hard_32bit_mode_classes): Mark registers\n+\tsuitable for holding OFmode values so that gcc works with complex\n+\tquad long doubles.\n+\t(hard_64bit_mode_classes): Likewise.\n+\n Tue Dec  7 19:22:06 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* loop.h (struct induction): Add multi_insn_incr."}, {"sha": "b2161ab04079d8e17f4f606d431030382ed21237", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0cee9ba75d0aa5b65704190f6a5fa2af74aea95/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0cee9ba75d0aa5b65704190f6a5fa2af74aea95/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=d0cee9ba75d0aa5b65704190f6a5fa2af74aea95", "patch": "@@ -2731,6 +2731,9 @@ enum sparc_mode_class {\n /* Modes for quad-word and smaller quantities.  */\n #define T_MODES (D_MODES | (1 << (int) T_MODE) | (1 << (int) TF_MODE))\n \n+/* Modes for 8-word and smaller quantities.  */\n+#define O_MODES (T_MODES | (1 << (int) O_MODE) | (1 << (int) OF_MODE))\n+\n /* Modes for single-float quantities.  We must allow any single word or\n    smaller quantity.  This is because the fix/float conversion instructions\n    take integer inputs/outputs from the float registers.  */\n@@ -2739,21 +2742,25 @@ enum sparc_mode_class {\n /* Modes for double-float and smaller quantities.  */\n #define DF_MODES (S_MODES | D_MODES)\n \n-#define DF_MODES64 DF_MODES\n-\n /* Modes for double-float only quantities.  */\n-#define DF_ONLY_MODES ((1 << (int) DF_MODE) | (1 << (int) D_MODE))\n-\n-/* Modes for double-float and larger quantities.  */\n-#define DF_UP_MODES (DF_ONLY_MODES | TF_ONLY_MODES)\n+#define DF_MODES_NO_S (D_MODES)\n \n /* Modes for quad-float only quantities.  */\n #define TF_ONLY_MODES (1 << (int) TF_MODE)\n \n /* Modes for quad-float and smaller quantities.  */\n #define TF_MODES (DF_MODES | TF_ONLY_MODES)\n \n-#define TF_MODES64 (DF_MODES64 | TF_ONLY_MODES)\n+/* Modes for quad-float and double-float quantities.  */\n+#define TF_MODES_NO_S (DF_MODES_NO_S | TF_ONLY_MODES)\n+\n+/* Modes for quad-float pair only quantities.  */\n+#define OF_ONLY_MODES (1 << (int) OF_MODE)\n+\n+/* Modes for quad-float pairs and smaller quantities.  */\n+#define OF_MODES (TF_MODES | OF_ONLY_MODES)\n+\n+#define OF_MODES_NO_S (TF_MODES_NO_S | OF_ONLY_MODES)\n \n /* Modes for condition codes.  */\n #define CC_MODES (1 << (int) CC_MODE)\n@@ -2774,17 +2781,17 @@ static int hard_32bit_mode_classes[] = {\n   T_MODES, S_MODES, T_MODES, S_MODES, T_MODES, S_MODES, D_MODES, S_MODES,\n   T_MODES, S_MODES, T_MODES, S_MODES, D_MODES, S_MODES, D_MODES, S_MODES,\n \n-  TF_MODES, SF_MODES, DF_MODES, SF_MODES, TF_MODES, SF_MODES, DF_MODES, SF_MODES,\n-  TF_MODES, SF_MODES, DF_MODES, SF_MODES, TF_MODES, SF_MODES, DF_MODES, SF_MODES,\n-  TF_MODES, SF_MODES, DF_MODES, SF_MODES, TF_MODES, SF_MODES, DF_MODES, SF_MODES,\n-  TF_MODES, SF_MODES, DF_MODES, SF_MODES, TF_MODES, SF_MODES, DF_MODES, SF_MODES,\n+  OF_MODES, SF_MODES, DF_MODES, SF_MODES, OF_MODES, SF_MODES, DF_MODES, SF_MODES,\n+  OF_MODES, SF_MODES, DF_MODES, SF_MODES, OF_MODES, SF_MODES, DF_MODES, SF_MODES,\n+  OF_MODES, SF_MODES, DF_MODES, SF_MODES, OF_MODES, SF_MODES, DF_MODES, SF_MODES,\n+  OF_MODES, SF_MODES, DF_MODES, SF_MODES, TF_MODES, SF_MODES, DF_MODES, SF_MODES,\n \n   /* FP regs f32 to f63.  Only the even numbered registers actually exist,\n      and none can hold SFmode/SImode values.  */\n-  DF_UP_MODES, 0, DF_ONLY_MODES, 0, DF_UP_MODES, 0, DF_ONLY_MODES, 0,\n-  DF_UP_MODES, 0, DF_ONLY_MODES, 0, DF_UP_MODES, 0, DF_ONLY_MODES, 0,\n-  DF_UP_MODES, 0, DF_ONLY_MODES, 0, DF_UP_MODES, 0, DF_ONLY_MODES, 0,\n-  DF_UP_MODES, 0, DF_ONLY_MODES, 0, DF_UP_MODES, 0, DF_ONLY_MODES, 0,\n+  OF_MODES_NO_S, 0, DF_MODES_NO_S, 0, OF_MODES_NO_S, 0, DF_MODES_NO_S, 0,\n+  OF_MODES_NO_S, 0, DF_MODES_NO_S, 0, OF_MODES_NO_S, 0, DF_MODES_NO_S, 0,\n+  OF_MODES_NO_S, 0, DF_MODES_NO_S, 0, OF_MODES_NO_S, 0, DF_MODES_NO_S, 0,\n+  OF_MODES_NO_S, 0, DF_MODES_NO_S, 0, TF_MODES_NO_S, 0, DF_MODES_NO_S, 0,\n \n   /* %fcc[0123] */\n   CCFP_MODES, CCFP_MODES, CCFP_MODES, CCFP_MODES,\n@@ -2795,21 +2802,21 @@ static int hard_32bit_mode_classes[] = {\n \n static int hard_64bit_mode_classes[] = {\n   D_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES,\n+  O_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES,\n   T_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES,\n-  T_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES,\n-  T_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES,\n+  O_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES, T_MODES, D_MODES,\n \n-  TF_MODES64, SF_MODES, DF_MODES64, SF_MODES, TF_MODES64, SF_MODES, DF_MODES64, SF_MODES,\n-  TF_MODES64, SF_MODES, DF_MODES64, SF_MODES, TF_MODES64, SF_MODES, DF_MODES64, SF_MODES,\n-  TF_MODES64, SF_MODES, DF_MODES64, SF_MODES, TF_MODES64, SF_MODES, DF_MODES64, SF_MODES,\n-  TF_MODES64, SF_MODES, DF_MODES64, SF_MODES, TF_MODES64, SF_MODES, DF_MODES64, SF_MODES,\n+  OF_MODES, SF_MODES, DF_MODES, SF_MODES, OF_MODES, SF_MODES, DF_MODES, SF_MODES,\n+  OF_MODES, SF_MODES, DF_MODES, SF_MODES, OF_MODES, SF_MODES, DF_MODES, SF_MODES,\n+  OF_MODES, SF_MODES, DF_MODES, SF_MODES, OF_MODES, SF_MODES, DF_MODES, SF_MODES,\n+  OF_MODES, SF_MODES, DF_MODES, SF_MODES, TF_MODES, SF_MODES, DF_MODES, SF_MODES,\n \n   /* FP regs f32 to f63.  Only the even numbered registers actually exist,\n      and none can hold SFmode/SImode values.  */\n-  DF_UP_MODES, 0, DF_ONLY_MODES, 0, DF_UP_MODES, 0, DF_ONLY_MODES, 0,\n-  DF_UP_MODES, 0, DF_ONLY_MODES, 0, DF_UP_MODES, 0, DF_ONLY_MODES, 0,\n-  DF_UP_MODES, 0, DF_ONLY_MODES, 0, DF_UP_MODES, 0, DF_ONLY_MODES, 0,\n-  DF_UP_MODES, 0, DF_ONLY_MODES, 0, DF_UP_MODES, 0, DF_ONLY_MODES, 0,\n+  OF_MODES_NO_S, 0, DF_MODES_NO_S, 0, OF_MODES_NO_S, 0, DF_MODES_NO_S, 0,\n+  OF_MODES_NO_S, 0, DF_MODES_NO_S, 0, OF_MODES_NO_S, 0, DF_MODES_NO_S, 0,\n+  OF_MODES_NO_S, 0, DF_MODES_NO_S, 0, OF_MODES_NO_S, 0, DF_MODES_NO_S, 0,\n+  OF_MODES_NO_S, 0, DF_MODES_NO_S, 0, TF_MODES_NO_S, 0, DF_MODES_NO_S, 0,\n \n   /* %fcc[0123] */\n   CCFP_MODES, CCFP_MODES, CCFP_MODES, CCFP_MODES,"}]}