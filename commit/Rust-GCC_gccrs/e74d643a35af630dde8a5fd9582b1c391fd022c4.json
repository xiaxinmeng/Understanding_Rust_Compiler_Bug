{"sha": "e74d643a35af630dde8a5fd9582b1c391fd022c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTc0ZDY0M2EzNWFmNjMwZGRlOGE1ZmQ5NTgyYjFjMzkxZmQwMjJjNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-14T13:39:16Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-14T13:39:16Z"}, "message": "[multiple changes]\n\n2013-10-14  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Analyze_Dependency_Clause): Add new local variable\n\tNon_Null_Output_Seen.  Update the call to Analyze_Input_Output.\n\t(Analyze_Input_Item): Streamline the detection mechanism of null and\n\tnon-null items.\n\t(Analyze_Input_List): Add new local variable\n\tNon_Null_Input_Seen. Update all calls to Analyze_Input_Output.\n\t(Analyze_Input_Output): Add new formal parameter Non_Null_Seen\n\tand update the related comment on usage. Update the\n\trecursive call to itself. Attribute 'Result is now treated\n\tas a non-null item. Detect mixes of null and non-null items.\n\t(Analyze_Initialization_Item): Streamline the detection mechanism\n\tof null and non-null items.\n\n2013-10-14  Vincent Celier  <celier@adacore.com>\n\n\t* projects.texi: Add documentation for the new project level\n\tattribute Library_Rpath_Options.\n\n2013-10-14  Tristan Gingold  <gingold@adacore.com>\n\n\t* a-exexpr-gcc.adb (Set_Exception_Parameter): New procedure.\n\t(Set_Foreign_Occurrence): New procedure, extracted from\n\tSetup_Current_Excep.\n\t* exp_ch11.adb (Expand_Exception_Handlers): Do not expand choice\n\tparameter in case of zcx.\n\t* sem_ch11.adb (Analyze_Exception_Handlers): Need debug info\n\tfor the choice parameter.\n\t* raise-gcc.c: Add comments.\n\nFrom-SVN: r203552", "tree": {"sha": "e87125024e2e1c27c24e75512938bdfb58f824e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e87125024e2e1c27c24e75512938bdfb58f824e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e74d643a35af630dde8a5fd9582b1c391fd022c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e74d643a35af630dde8a5fd9582b1c391fd022c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e74d643a35af630dde8a5fd9582b1c391fd022c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e74d643a35af630dde8a5fd9582b1c391fd022c4/comments", "author": null, "committer": null, "parents": [{"sha": "9b2451e5b31bcea0398b5cb8574d516c97efa0f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b2451e5b31bcea0398b5cb8574d516c97efa0f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b2451e5b31bcea0398b5cb8574d516c97efa0f9"}], "stats": {"total": 292, "additions": 211, "deletions": 81}, "files": [{"sha": "a102f90fb1dbb4abc6f792078a43b58e7c0cd2ad", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e74d643a35af630dde8a5fd9582b1c391fd022c4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e74d643a35af630dde8a5fd9582b1c391fd022c4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e74d643a35af630dde8a5fd9582b1c391fd022c4", "patch": "@@ -1,3 +1,34 @@\n+2013-10-14  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Dependency_Clause): Add new local variable\n+\tNon_Null_Output_Seen.  Update the call to Analyze_Input_Output.\n+\t(Analyze_Input_Item): Streamline the detection mechanism of null and\n+\tnon-null items.\n+\t(Analyze_Input_List): Add new local variable\n+\tNon_Null_Input_Seen. Update all calls to Analyze_Input_Output.\n+\t(Analyze_Input_Output): Add new formal parameter Non_Null_Seen\n+\tand update the related comment on usage. Update the\n+\trecursive call to itself. Attribute 'Result is now treated\n+\tas a non-null item. Detect mixes of null and non-null items.\n+\t(Analyze_Initialization_Item): Streamline the detection mechanism\n+\tof null and non-null items.\n+\n+2013-10-14  Vincent Celier  <celier@adacore.com>\n+\n+\t* projects.texi: Add documentation for the new project level\n+\tattribute Library_Rpath_Options.\n+\n+2013-10-14  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* a-exexpr-gcc.adb (Set_Exception_Parameter): New procedure.\n+\t(Set_Foreign_Occurrence): New procedure, extracted from\n+\tSetup_Current_Excep.\n+\t* exp_ch11.adb (Expand_Exception_Handlers): Do not expand choice\n+\tparameter in case of zcx.\n+\t* sem_ch11.adb (Analyze_Exception_Handlers): Need debug info\n+\tfor the choice parameter.\n+\t* raise-gcc.c: Add comments.\n+\n 2013-10-14  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* aspects.adb: Add an entry in table Canonical_Aspect for"}, {"sha": "77abaa502f94dc78cf53cb7954bb2031f56f15a3", "filename": "gcc/ada/a-exexpr-gcc.adb", "status": "modified", "additions": 57, "deletions": 8, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e74d643a35af630dde8a5fd9582b1c391fd022c4/gcc%2Fada%2Fa-exexpr-gcc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e74d643a35af630dde8a5fd9582b1c391fd022c4/gcc%2Fada%2Fa-exexpr-gcc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exexpr-gcc.adb?ref=e74d643a35af630dde8a5fd9582b1c391fd022c4", "patch": "@@ -199,13 +199,14 @@ package body Exception_Propagation is\n      (GCC_Exception : not null GCC_Exception_Access);\n    pragma No_Return (Reraise_GCC_Exception);\n    pragma Export (C, Reraise_GCC_Exception, \"__gnat_reraise_zcx\");\n-   --  Called to implement raise without exception, ie reraise.  Called\n+   --  Called to implement raise without exception, ie reraise. Called\n    --  directly from gigi.\n \n    function Setup_Current_Excep\n      (GCC_Exception : not null GCC_Exception_Access) return EOA;\n    pragma Export (C, Setup_Current_Excep, \"__gnat_setup_current_excep\");\n-   --  Write Get_Current_Excep.all from GCC_Exception\n+   --  Write Get_Current_Excep.all from GCC_Exception. Called by the\n+   --  personnality routine.\n \n    procedure Unhandled_Except_Handler\n      (GCC_Exception : not null GCC_Exception_Access);\n@@ -243,6 +244,17 @@ package body Exception_Propagation is\n       UW_Argument  : System.Address);\n    pragma Import (C, Unwind_ForcedUnwind, \"__gnat_Unwind_ForcedUnwind\");\n \n+   procedure Set_Exception_Parameter\n+     (Excep : EOA;\n+      GCC_Exception : not null GCC_Exception_Access);\n+   pragma Export (C, Set_Exception_Parameter,\n+                    \"__gnat_set_exception_parameter\");\n+   --  Called inserted by gigi to initialize the exception parameter\n+\n+   procedure Set_Foreign_Occurrence (Excep : EOA; Mo : System.Address);\n+   --  Utility routine to initialize occurrence Excep for a foreign exception\n+   --  whose machine occurrence is Mo.\n+\n    --  Hooks called when entering/leaving an exception handler for a given\n    --  occurrence, aimed at handling the stack of active occurrences. The\n    --  calls are generated by gigi in tree_transform/N_Exception_Handler.\n@@ -338,6 +350,20 @@ package body Exception_Propagation is\n       Free (Copy);\n    end GNAT_GCC_Exception_Cleanup;\n \n+   ----------------------------\n+   -- Set_Foreign_Occurrence --\n+   ----------------------------\n+\n+   procedure Set_Foreign_Occurrence (Excep : EOA; Mo : System.Address) is\n+   begin\n+      Excep.Id := Foreign_Exception'Access;\n+      Excep.Machine_Occurrence := Mo;\n+      Excep.Msg_Length := 0;\n+      Excep.Exception_Raised := True;\n+      Excep.Pid := Local_Partition_ID;\n+      Excep.Num_Tracebacks := 0;\n+   end Set_Foreign_Occurrence;\n+\n    -------------------------\n    -- Setup_Current_Excep --\n    -------------------------\n@@ -366,12 +392,7 @@ package body Exception_Propagation is\n \n          --  A default one\n \n-         Excep.Id := Foreign_Exception'Access;\n-         Excep.Machine_Occurrence := GCC_Exception.all'Address;\n-         Excep.Msg_Length := 0;\n-         Excep.Exception_Raised := True;\n-         Excep.Pid := Local_Partition_ID;\n-         Excep.Num_Tracebacks := 0;\n+         Set_Foreign_Occurrence (Excep, GCC_Exception.all'Address);\n \n          return Excep;\n       end if;\n@@ -465,6 +486,34 @@ package body Exception_Propagation is\n       Propagate_GCC_Exception (To_GCC_Exception (Excep.Machine_Occurrence));\n    end Propagate_Exception;\n \n+   -----------------------------\n+   -- Set_Exception_Parameter --\n+   -----------------------------\n+\n+   procedure Set_Exception_Parameter\n+     (Excep : EOA;\n+      GCC_Exception : not null GCC_Exception_Access) is\n+   begin\n+      --  Setup the exception occurrence\n+\n+      if GCC_Exception.Class = GNAT_Exception_Class then\n+\n+         --  From the GCC exception\n+\n+         declare\n+            GNAT_Occurrence : constant GNAT_GCC_Exception_Access :=\n+              To_GNAT_GCC_Exception (GCC_Exception);\n+         begin\n+            Save_Occurrence (Excep.all, GNAT_Occurrence.Occurrence);\n+         end;\n+      else\n+\n+         --  A default one\n+\n+         Set_Foreign_Occurrence (Excep, GCC_Exception.all'Address);\n+      end if;\n+   end Set_Exception_Parameter;\n+\n    ------------------------------\n    -- Unhandled_Except_Handler --\n    ------------------------------"}, {"sha": "476b69ce538bc09f1cf5baceb523826018c58253", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e74d643a35af630dde8a5fd9582b1c391fd022c4/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e74d643a35af630dde8a5fd9582b1c391fd022c4/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=e74d643a35af630dde8a5fd9582b1c391fd022c4", "patch": "@@ -1025,7 +1025,12 @@ package body Exp_Ch11 is\n                --        ...\n                --     end;\n \n-               if Present (Choice_Parameter (Handler)) then\n+               --  This expansion is not performed when using GCC ZCX. Gigi\n+               --  will insert a call to intialize the choice parameter.\n+\n+               if Present (Choice_Parameter (Handler))\n+                 and then Exception_Mechanism /= Back_End_Exceptions\n+               then\n                   declare\n                      Cparm : constant Entity_Id  := Choice_Parameter (Handler);\n                      Cloc  : constant Source_Ptr := Sloc (Cparm);"}, {"sha": "819c1e96c014c9c1ba53fe741e56853e9596a2b1", "filename": "gcc/ada/projects.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e74d643a35af630dde8a5fd9582b1c391fd022c4/gcc%2Fada%2Fprojects.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e74d643a35af630dde8a5fd9582b1c391fd022c4/gcc%2Fada%2Fprojects.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprojects.texi?ref=e74d643a35af630dde8a5fd9582b1c391fd022c4", "patch": "@@ -3962,6 +3962,14 @@ the command line when linking a shared library.\n \n Value is a list of options that are to be used when linking a shared library.\n \n+@item @b{Library_Rpath_Options}: list, indexed, case-insensitive index\n+\n+Index is a language name. Value is a list of options for an invocation of the\n+compiler of the language. This invocation is done for a shared library project\n+with sources of the language. The output of the invocation is the path name\n+of a shared library file. The directory name is to be put in the run path\n+option switch when linking the shared library for the project.\n+\n @item @b{Library_Src_Dir}: single\n \n Value is the name of the directory where copies of the sources of the"}, {"sha": "a207e524d8a6849e017d8c1f4d8a173c92fb9999", "filename": "gcc/ada/raise-gcc.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e74d643a35af630dde8a5fd9582b1c391fd022c4/gcc%2Fada%2Fraise-gcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e74d643a35af630dde8a5fd9582b1c391fd022c4/gcc%2Fada%2Fraise-gcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise-gcc.c?ref=e74d643a35af630dde8a5fd9582b1c391fd022c4", "patch": "@@ -1217,7 +1217,9 @@ PERSONALITY_FUNCTION (version_arg_t version_arg,\n   setup_to_install\n     (uw_context, uw_exception, action.landing_pad, action.ttype_filter);\n \n-  /* Write current exception, so that it can be retrieved from Ada.  */\n+  /* Write current exception, so that it can be retrieved from Ada.  It was\n+     already done during phase 1 (just above), but in between, one or several\n+     exceptions may have been raised (in cleanup handlers).  */\n   __gnat_setup_current_excep (uw_exception);\n \n   return _URC_INSTALL_CONTEXT;"}, {"sha": "a397edfb40e0d4eb24a9bae46797f84b06eb47f6", "filename": "gcc/ada/sem_ch11.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e74d643a35af630dde8a5fd9582b1c391fd022c4/gcc%2Fada%2Fsem_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e74d643a35af630dde8a5fd9582b1c391fd022c4/gcc%2Fada%2Fsem_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch11.adb?ref=e74d643a35af630dde8a5fd9582b1c391fd022c4", "patch": "@@ -199,6 +199,7 @@ package body Sem_Ch11 is\n \n                if Comes_From_Source (Choice) then\n                   Check_Restriction (No_Exception_Propagation, Choice);\n+                  Set_Debug_Info_Needed (Choice);\n                end if;\n \n                if No (H_Scope) then"}, {"sha": "bd00a3c7ed1153a027288f2144a3b9afd60833db", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 105, "deletions": 71, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e74d643a35af630dde8a5fd9582b1c391fd022c4/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e74d643a35af630dde8a5fd9582b1c391fd022c4/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=e74d643a35af630dde8a5fd9582b1c391fd022c4", "patch": "@@ -555,20 +555,22 @@ package body Sem_Prag is\n          --  Verify the legality of a single input list\n \n          procedure Analyze_Input_Output\n-           (Item      : Node_Id;\n-            Is_Input  : Boolean;\n-            Self_Ref  : Boolean;\n-            Top_Level : Boolean;\n-            Seen      : in out Elist_Id;\n-            Null_Seen : in out Boolean);\n+           (Item          : Node_Id;\n+            Is_Input      : Boolean;\n+            Self_Ref      : Boolean;\n+            Top_Level     : Boolean;\n+            Seen          : in out Elist_Id;\n+            Null_Seen     : in out Boolean;\n+            Non_Null_Seen : in out Boolean);\n          --  Verify the legality of a single input or output item. Flag\n          --  Is_Input should be set whenever Item is an input, False when it\n          --  denotes an output. Flag Self_Ref should be set when the item is an\n          --  output and the dependency clause has a \"+\". Flag Top_Level should\n          --  be set whenever Item appears immediately within an input or output\n          --  list. Seen is a collection of all abstract states, variables and\n          --  formals processed so far. Flag Null_Seen denotes whether a null\n-         --  input or output has been encountered.\n+         --  input or output has been encountered. Flag Non_Null_Seen denotes\n+         --  whether a non-null input or output has been encountered.\n \n          ------------------------\n          -- Analyze_Input_List --\n@@ -579,8 +581,9 @@ package body Sem_Prag is\n             --  A list containing the entities of all inputs that appear in the\n             --  current input list.\n \n-            Null_Input_Seen : Boolean := False;\n-            --  A flag used to track the legality of a null input\n+            Non_Null_Input_Seen : Boolean := False;\n+            Null_Input_Seen     : Boolean := False;\n+            --  Flags used to check the legality of an input list\n \n             Input : Node_Id;\n \n@@ -596,12 +599,13 @@ package body Sem_Prag is\n                   Input := First (Expressions (Inputs));\n                   while Present (Input) loop\n                      Analyze_Input_Output\n-                       (Item      => Input,\n-                        Is_Input  => True,\n-                        Self_Ref  => False,\n-                        Top_Level => False,\n-                        Seen      => Inputs_Seen,\n-                        Null_Seen => Null_Input_Seen);\n+                       (Item          => Input,\n+                        Is_Input      => True,\n+                        Self_Ref      => False,\n+                        Top_Level     => False,\n+                        Seen          => Inputs_Seen,\n+                        Null_Seen     => Null_Input_Seen,\n+                        Non_Null_Seen => Non_Null_Input_Seen);\n \n                      Next (Input);\n                   end loop;\n@@ -614,12 +618,13 @@ package body Sem_Prag is\n \n             else\n                Analyze_Input_Output\n-                 (Item      => Inputs,\n-                  Is_Input  => True,\n-                  Self_Ref  => False,\n-                  Top_Level => False,\n-                  Seen      => Inputs_Seen,\n-                  Null_Seen => Null_Input_Seen);\n+                 (Item          => Inputs,\n+                  Is_Input      => True,\n+                  Self_Ref      => False,\n+                  Top_Level     => False,\n+                  Seen          => Inputs_Seen,\n+                  Null_Seen     => Null_Input_Seen,\n+                  Non_Null_Seen => Non_Null_Input_Seen);\n             end if;\n \n             --  Detect an illegal dependency clause of the form\n@@ -638,12 +643,13 @@ package body Sem_Prag is\n          --------------------------\n \n          procedure Analyze_Input_Output\n-           (Item      : Node_Id;\n-            Is_Input  : Boolean;\n-            Self_Ref  : Boolean;\n-            Top_Level : Boolean;\n-            Seen      : in out Elist_Id;\n-            Null_Seen : in out Boolean)\n+           (Item          : Node_Id;\n+            Is_Input      : Boolean;\n+            Self_Ref      : Boolean;\n+            Top_Level     : Boolean;\n+            Seen          : in out Elist_Id;\n+            Null_Seen     : in out Boolean;\n+            Non_Null_Seen : in out Boolean)\n          is\n             Is_Output : constant Boolean := not Is_Input;\n             Grouped   : Node_Id;\n@@ -666,12 +672,13 @@ package body Sem_Prag is\n                   Grouped := First (Expressions (Item));\n                   while Present (Grouped) loop\n                      Analyze_Input_Output\n-                       (Item      => Grouped,\n-                        Is_Input  => Is_Input,\n-                        Self_Ref  => Self_Ref,\n-                        Top_Level => False,\n-                        Seen      => Seen,\n-                        Null_Seen => Null_Seen);\n+                       (Item          => Grouped,\n+                        Is_Input      => Is_Input,\n+                        Self_Ref      => Self_Ref,\n+                        Top_Level     => False,\n+                        Seen          => Seen,\n+                        Null_Seen     => Null_Seen,\n+                        Non_Null_Seen => Non_Null_Seen);\n \n                      Next (Grouped);\n                   end loop;\n@@ -683,6 +690,7 @@ package body Sem_Prag is\n             --  Process Function'Result in the context of a dependency clause\n \n             elsif Is_Attribute_Result (Item) then\n+               Non_Null_Seen := True;\n \n                --  It is sufficent to analyze the prefix of 'Result in order to\n                --  establish legality of the attribute.\n@@ -707,6 +715,10 @@ package body Sem_Prag is\n                elsif Is_Input then\n                   Error_Msg_N (\"function result cannot act as input\", Item);\n \n+               elsif Null_Seen then\n+                  Error_Msg_N\n+                    (\"cannot mix null and non-null dependency items\", Item);\n+\n                else\n                   Result_Seen := True;\n                end if;\n@@ -719,19 +731,39 @@ package body Sem_Prag is\n                if Null_Seen then\n                   Error_Msg_N\n                     (\"multiple null dependency relations not allowed\", Item);\n+\n+               elsif Non_Null_Seen then\n+                  Error_Msg_N\n+                    (\"cannot mix null and non-null dependency items\", Item);\n+\n                else\n                   Null_Seen := True;\n \n-                  if Is_Output and then not Is_Last then\n-                     Error_Msg_N\n-                       (\"null output list must be the last clause in a \"\n-                        & \"dependency relation\", Item);\n+                  if Is_Output then\n+                     if not Is_Last then\n+                        Error_Msg_N\n+                          (\"null output list must be the last clause in a \"\n+                           & \"dependency relation\", Item);\n+\n+                     --  Catch a useless dependence of the form:\n+                     --    null =>+ ...\n+\n+                     elsif Self_Ref then\n+                        Error_Msg_N\n+                          (\"useless dependence, null depends on itself\", Item);\n+                     end if;\n                   end if;\n                end if;\n \n             --  Default case\n \n             else\n+               Non_Null_Seen := True;\n+\n+               if Null_Seen then\n+                  Error_Msg_N (\"cannot mix null and non-null items\", Item);\n+               end if;\n+\n                Analyze (Item);\n \n                --  Find the entity of the item. If this is a renaming, climb\n@@ -845,6 +877,9 @@ package body Sem_Prag is\n          Output   : Node_Id;\n          Self_Ref : Boolean;\n \n+         Non_Null_Output_Seen : Boolean := False;\n+         --  Flag used to check the legality of an output list\n+\n       --  Start of processing for Analyze_Dependency_Clause\n \n       begin\n@@ -864,12 +899,13 @@ package body Sem_Prag is\n          Output := First (Choices (Clause));\n          while Present (Output) loop\n             Analyze_Input_Output\n-              (Item      => Output,\n-               Is_Input  => False,\n-               Self_Ref  => Self_Ref,\n-               Top_Level => True,\n-               Seen      => All_Outputs_Seen,\n-               Null_Seen => Null_Output_Seen);\n+              (Item          => Output,\n+               Is_Input      => False,\n+               Self_Ref      => Self_Ref,\n+               Top_Level     => True,\n+               Seen          => All_Outputs_Seen,\n+               Null_Seen     => Null_Output_Seen,\n+               Non_Null_Seen => Non_Null_Output_Seen);\n \n             Next (Output);\n          end loop;\n@@ -2192,22 +2228,15 @@ package body Sem_Prag is\n          Item_Id : Entity_Id;\n \n       begin\n-         --  A package with null initialization list is not allowed to have\n-         --  additional initializations.\n-\n-         if Null_Seen then\n-            Error_Msg_NE (\"package & has null initialization\", Item, Pack_Id);\n-\n          --  Null initialization list\n \n-         elsif Nkind (Item) = N_Null then\n-\n-            --  Catch a case where a null initialization item appears in a list\n-            --  of non-null items.\n+         if Nkind (Item) = N_Null then\n+            if Null_Seen then\n+               Error_Msg_N (\"multiple null initializations not allowed\", Item);\n \n-            if Non_Null_Seen then\n-               Error_Msg_NE\n-                 (\"package & has non-null initialization\", Item, Pack_Id);\n+            elsif Non_Null_Seen then\n+               Error_Msg_N\n+                 (\"cannot mix null and non-null initialization items\", Item);\n             else\n                Null_Seen := True;\n             end if;\n@@ -2217,6 +2246,11 @@ package body Sem_Prag is\n          else\n             Non_Null_Seen := True;\n \n+            if Null_Seen then\n+               Error_Msg_N\n+                 (\"cannot mix null and non-null initialization items\", Item);\n+            end if;\n+\n             Analyze (Item);\n \n             if Is_Entity_Name (Item) then\n@@ -2287,21 +2321,16 @@ package body Sem_Prag is\n             Input_Id : Entity_Id;\n \n          begin\n-            --  An initialization item with null inputs is not allowed to have\n-            --  assitional inputs.\n-\n-            if Null_Seen then\n-               Error_Msg_N (\"item has null input list\", Item);\n-\n             --  Null input list\n \n-            elsif Nkind (Input) = N_Null then\n-\n-               --  Catch a case where a null input appears in a list of non-\n-               --  null inpits.\n+            if Nkind (Input) = N_Null then\n+               if Null_Seen then\n+                  Error_Msg_N\n+                    (\"multiple null initializations not allowed\", Item);\n \n-               if Non_Null_Seen then\n-                  Error_Msg_N (\"item has non-null input list\", Item);\n+               elsif Non_Null_Seen then\n+                  Error_Msg_N\n+                    (\"cannot mix null and non-null initialization item\", Item);\n                else\n                   Null_Seen := True;\n                end if;\n@@ -2311,6 +2340,11 @@ package body Sem_Prag is\n             else\n                Non_Null_Seen := True;\n \n+               if Null_Seen then\n+                  Error_Msg_N\n+                    (\"cannot mix null and non-null initialization item\", Item);\n+               end if;\n+\n                Analyze (Input);\n \n                if Is_Entity_Name (Input) then\n@@ -9299,7 +9333,7 @@ package body Sem_Prag is\n \n                elsif Nkind (State) = N_Null then\n                   Name := New_Internal_Name ('S');\n-                  Is_Null := True;\n+                  Is_Null   := True;\n                   Null_Seen := True;\n \n                   --  Catch a case where a null state appears in a list of\n@@ -19946,7 +19980,7 @@ package body Sem_Prag is\n                   Dep_Id := Entity_Of (Dep_Input);\n \n                   --  Inspect all inputs of the refinement clause and attempt\n-                  --  to match against the inputs of the dependance clause.\n+                  --  to match against the inputs of the dependence clause.\n \n                   Ref_Input := First (Ref_Inputs);\n                   while Present (Ref_Input) loop\n@@ -20256,7 +20290,7 @@ package body Sem_Prag is\n       begin\n          --  The analysis of pragma Depends should produce normalized clauses\n          --  with exactly one output. This is important because output items\n-         --  are unique in the whole dependance relation and can be used as\n+         --  are unique in the whole dependence relation and can be used as\n          --  keys.\n \n          pragma Assert (No (Next (Dep_Output)));"}]}