{"sha": "1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc5OWU1ZDVjYTIwMzA0ZTMyZjdkMTEzNGJhNWU4YTJhYjIzMTg4MA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2006-03-09T18:14:39Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2006-03-09T18:14:39Z"}, "message": "Merge C++ from gomp-20050608-branch.\n\nFrom-SVN: r111867", "tree": {"sha": "461ecbd500b6dd4b3b219e43f1580a187a1407cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/461ecbd500b6dd4b3b219e43f1580a187a1407cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/comments", "author": null, "committer": null, "parents": [{"sha": "f8fe05458d2116e5dcd2aa3eac9dff868be27cfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8fe05458d2116e5dcd2aa3eac9dff868be27cfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8fe05458d2116e5dcd2aa3eac9dff868be27cfb"}], "stats": {"total": 7009, "additions": 6653, "deletions": 356}, "files": [{"sha": "1f5ecd582394dbe48c3ee92a8657898947c1898b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -1,3 +1,8 @@\n+2006-03-09  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* tree-cfg.c (move_block_to_fn): Remove the statements from the\n+\toriginal fn's eh regions.\n+\n 2006-03-09  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* fold-const.c (build_range_check): Make sure to use a valid type to"}, {"sha": "60c191713030afe35b6da90bde6fa3d142180619", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 473, "deletions": 24, "changes": 497, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -1,3 +1,452 @@\n+2006-03-09  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tMerge from gomp-20050608-branch\n+\n+\t2006-02-02  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t\t* decl.c (pop_labels_1): Use appropriate pointer casting.\n+\t\t(poplevel_named_label_1): Likewise.\n+\t\t(named_label_entry_hash): Likewise.\n+\t\t(named_label_entry_eq): Likewise.\n+\t\t(check_goto): Likewise.\n+\t\t(define_label): Likewise.\n+\n+\t2006-01-26  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t\t* cp-tree.h (CP_OMP_CLAUSE_INFO): Use TREE_TYPE instead\n+\t\tof TREE_BLOCK.\n+\t\t* pt.c: Use OMP_CLAUSE_CODE and OMP_CLAUSE_OPERAND\n+\t\tinstead of TREE_CODE/TREE_OPERAND.\n+\t\t* semantics.c: Likewise.\n+\t\t* parser.c: Likewise.\n+\n+\t2005-11-10  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t\t* parser.c (cp_parser_omp_threadprivate): Emit diagnostic if\n+\t\ttarget does not support TLS.\n+\n+\t2005-11-09  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t\t* decl.c (redeclaration_error_message): Don't error about\n+\t\tDECL_THREAD_LOCAL_P mismatches if CP_DECL_THREADPRIVATE_P\n+\t\t(olddecl).\n+\n+\t2005-11-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t\tPR c++/24735\n+\t\t* semantics.c (finish_omp_barrier, finish_omp_flush): New\n+\t\t  functions.\n+\t\t* parser.c (cp_parser_omp_barrier): Call finish_omp_barrier.\n+\t\t(cp_parser_omp_flush): Call finish_omp_flush.\n+\t\t* cp-tree.h (finish_omp_barrier, finish_omp_flush): New\n+\t\t  prototypes.\n+\n+\t\tPR c++/24734\n+\t\t* pt.c (tsubst_expr): Handle OMP_MASTER and OMP_ORDERED.\n+\n+\t2005-11-03  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t\t* semantics.c (finish_omp_threadprivate): Error on class-scope\n+\t\tvariables.\n+\n+\t2005-11-02  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t\t* parser.c (cp_parser_omp_all_clauses): If some clause\n+\t\ttype is not allowed, don't remove just one of the\n+\t\tclauses, but all clauses added in that loop round.\n+\n+\t\t* semantics.c (finish_omp_clauses): Fix function\n+\t\tcomment. Don't handle non-const or mutable specially,\n+\t\tas const and not mutable is predetermined shared and\n+\t\tthat leads to double error. Don't ICE if copyin var is\n+\t\tPARM_DECL.\n+\n+\t\tPR c++/24613\n+\t\t* parser.c (cp_parser_pragma): Diagnose\n+\t\tPRAGMA_OMP_SECTION outside of PRAGMA_OMP_SECTIONS\n+\t\tconstruct.\n+\n+\t\t* semantics.c (finish_omp_threadprivate): Error if V\n+\t\t  is automatic variable or has incomplete type.\n+\n+\t2005-11-01  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t\t* parser.c (cp_parser_omp_all_clauses): Use\n+\t\tOMP_CLAUSE_CHAIN instead of TREE_CHAIN.\n+\n+\t2005-11-01  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t\t* parser.c (cp_parser_omp_all_clauses): When emitting an\n+\t\terror message, remove the invalid clause from the list.\n+\n+\t2005-10-31  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t\t* parser.c (cp_parser_omp_parallel): Do not allow 'nowait' in\n+\t\tcombined parallel+workshare directives.\n+\n+\t2005-10-31  Richard Henderson  <rth@redhat.com>\n+\n+\t\t* cp-objcp-common.h (LANG_HOOKS_OMP_CLAUSE_DTOR):\n+\t\tUse cxx_omp_clause_dtor.\n+\t\t* cp-tree.h (CP_OMP_CLAUSE_INFO): New.\n+\t\t(cxx_omp_clause_dtor): New.\n+\t\t* cp-gimplify.c (cxx_omp_clause_apply_fn): New.\n+\t\t(cxx_omp_clause_default_ctor): Use it.\n+\t\t(cxx_omp_clause_copy_ctor, cxx_omp_clause_assign_op):\n+\t\tLikewise.\n+\t\t(cxx_omp_clause_dtor): New.\n+\t\t* semantics.c (finish_omp_clauses): Rewrite cdtor\n+\t\tchecking to fill in CP_OMP_CLAUSE_INFO.  Don't\n+\t\tspecialcase LASTPRIVATE for removal.\n+\t\t(cxx_omp_clause_default_ctor, cxx_omp_clause_copy_ctor,\n+\t\tcxx_omp_clause_assign_op): Move to cp-gimplify.c.\n+\n+\t2005-10-28  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t\t* semantics.c (finish_omp_threadprivate): If\n+\t\t  DECL_RTL_SET_P, call make_decl_rtl again so that\n+\t\t  encode_section_info can update SYMBOL_REF's flags.\n+\n+\t2005-10-26  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t\t* semantics.c (finish_omp_for): Don't segfault if COND\n+\t\tor INCR is NULL.  If not calling c_finish_omp_for\n+\t\tright away and one of COND and INCR is NULL, issue\n+\t\terror and don't expand anything.\n+\n+\t\tPR c++/24512\n+\t\t* cp-tree.h (finish_omp_for): Add PRE_BODY argument.\n+\t\t* semantics.c (finish_omp_for): Likewise.  Set\n+\t\tOMP_FOR_PRE_BODY to PRE_BODY if deferring, add it\n+\t\tinto the current statement list if not processing\n+\t\ttemplate decl or pass it to c_finish_omp_for.\n+\n+\t\t* parser.c (cp_parser_omp_for_loop): Expand optional DECL_EXPRs\n+\t\tinto PRE_BODY statement list.  Pass it to finish_omp_for.\n+\t\t* pt.c (tsubst_expr) <case OMP_FOR>: tsubst_expr also\n+\t\tOMP_FOR_PRE_BODY into PRE_BODY stmt list, pass it to\n+\t\tfinish_omp_for.  Put all the statements into sk_omp\n+\t\tscope.\n+\n+\t2005-10-25  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t\tPR c++/24516\n+\t\t* parser.c (struct cp_parser): Rename in_iteration_statement\n+\t\tfield to in_statement.\n+\t\t(IN_SWITCH_STMT, IN_ITERATION_STMT): Define.\n+\t\t(IN_OMP_BLOCK, IN_OMP_FOR): Change values.\n+\t\t(cp_parser_new, cp_parser_begin_omp_structured_block,\n+\t\tcp_parser_end_omp_structured_block,\n+\t\tcp_parser_omp_for_loop): Adjust for\n+\t\tin_iteration_statement renaming.\n+\t\t(cp_parser_selection_statement): Save\n+\t\tparser->in_iteration, or it temporarily with\n+\t\tIN_SWITCH_STMT for the\n+\t\tcp_parser_implicitly_scoped_statement call.\n+\t\t(cp_parser_iteration_statement): Adjust for\n+\t\tin_iteration_statement renaming.  Use\n+\t\tIN_ITERATION_STMT rather than true.\n+\t\t(cp_parser_jump_statement): Adjust for\n+\t\tin_iteration_statement renaming and new values.  Don't\n+\t\terror on break in a switch statement within OMP_FOR or\n+\t\tOpenMP structured block.\n+\n+\t\tPR c++/24513\n+\t\t* parser.c (cp_parser_cache_group): Don't stop if next\n+\t\ttoken is CPP_PRAGMA_EOL and end is CPP_PRAGMA_EOL as\n+\t\twell.  If current token is CPP_PRAGMA, consume\n+\t\teverything until CPP_PRAGMA_EOL inclusive.\n+\n+\t2005-10-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t\tPR c++/24502\n+\t\t* semantics.c (finish_omp_for): Handle MODOP_EXPR in\n+\t\taddition to MODIFY_EXPR.\n+\n+\t2005-10-23  Richard Henderson  <rth@redhat.com>\n+\n+\t\t* cp-gimplify.c (struct cp_gimplify_ctx): Remove.\n+\t\t(bc_label): New.\n+\t\t(begin_bc_block, finish_bc_block): Use it.\n+\t\t(push_context, pop_context): Remove.\n+\t\t(cp_genericize): Don't use them.  Assert bc_label is null.\n+\t\t* semantics.c (finish_omp_clauses): Create a fake data\n+\t\telement of TYPE for probing ctors.\n+\n+\t2005-10-23  Richard Henderson  <rth@redhat.com>\n+\n+\t\t* cp-objcp-common.h (LANG_HOOKS_OMP_CLAUSE_DEFAULT_CTOR): New.\n+\t\t(LANG_HOOKS_OMP_CLAUSE_COPY_CTOR): New.\n+\t\t(LANG_HOOKS_OMP_CLAUSE_ASSIGN_OP): New.\n+\t\t(LANG_HOOKS_OMP_CLAUSE_DTOR): New.\n+\t\t* semantics.c (finish_omp_clauses): Look through\n+\t\tarrays when looking up special member calls.  Also\n+\t\tremove FIRSTPRIVATE when LASTPRIVATE fails.\n+\t\t(cxx_omp_clause_default_ctor, cxx_omp_clause_copy_ctor): New.\n+\t\t(cxx_omp_clause_assign_op): New.\n+\t\t* cp-tree.h: Declare them.\n+\n+\t2005-10-21  Richard Henderson  <rth@redhat.com>\n+\n+\t\t* decl.c (check_previous_goto_1): Return false if error.\n+\t\t(check_switch_goto): Likewise.\n+\t\t(finish_case_label): Don't emit the case label on error.\n+\t\t* parser.c (struct cp_parser): Revert\n+\t\tin_switch_statement_p changes.\n+\t\t(cp_parser_labeled_statement,\n+\t\tcp_parser_selection_statement): Likewise.\n+\t\t(cp_parser_begin_omp_structured_block): Don't save...\n+\t\t(cp_parser_end_omp_structured_block): or restore\n+\t\tin_switch_statement_p.\n+\n+\t2005-10-21  Richard Henderson  <rth@redhat.com>\n+\n+\t\t* semantics.c (finish_omp_threadprivate): Set\n+\t\tdecl_flags.u2sel when necessary.\n+\n+\t2005-10-21  Richard Henderson  <rth@redhat.com>\n+\n+\t\t* decl.c (poplevel_named_label_1): Restore creation of the\n+\t\tbad_decls list.\n+\t\t(decl_jump_unsafe): Check for error_mark_node types.\n+\t\t(check_goto): Don't check cdtor_label.  Don't use identify_goto.                * semantics.c (finish_return_stmt): Do check_omp_return before\n+\t\tconverting to cdtor_label goto.\n+\n+\t2005-10-21  Richard Henderson  <rth@redhat.com>\n+\n+\t\tPR c++/24451\n+\t\t* decl.c (check_omp_return): Return false on error.\n+\t\t* cp-tree.h (check_omp_return): Update decl.\n+\t\t* semantics.c (finish_return_stmt): Avoid adding\n+\t\treturn on error.\n+\n+\t2005-10-21  Richard Henderson  <rth@redhat.com>\n+\n+\t\t* cp-tree.h (struct language_function): Remove\n+\t\tx_named_label_uses.\n+\t\tChange x_named_labels to a hashtable.\n+\t\t(check_omp_return): Declare.\n+\t\t* decl.c (struct named_label_use_entry): Rename from\n+\t\tnamed_label_use_list.  Remove label_decl.\n+\t\t(struct named_label_entry): Rename from\n+\t\tnamed_label_list.  Remove old_value and next.  Change\n+\t\tin_try_scope and in_catch_scope to bool. Add\n+\t\tin_omp_scope.\n+\t\t(pop_labels_1): New.\n+\t\t(pop_labels): Use it.\n+\t\t(pop_local_label, poplevel_named_label_1): New.\n+\t\t(poplevel): Use them.\n+\t\t(named_label_entry_hash, named_label_entry_eq): New.\n+\t\t(make_label_decl): Create named_labels.  Move label\n+\t\tcreation bits from lookup_label.\n+\t\t(declare_local_label): Tidy.\n+\t\t(identify_goto): Split out from ...\n+\t\t(check_previous_goto_1): Add exited_omp argument.\n+\t\tHandle omp scopes.\n+\n+\t\t(use_label): Merge into...\n+\t\t(check_goto): ... here.  Handle omp scopes.\n+\t\t(check_omp_return): New.\n+\t\t(check_previous_gotos): Merge into...\n+\t\t(define_label): ... here.\n+\t\t(save_function_data): Remove x_named_label_uses reference.\n+\t\t(finish_function): Likewise.\n+\t\t* name-lookup.h (sk_omp): New.\n+\t\t* name-lookup.c (begin_scope): Handle it.\n+\t\t* parser.c (cp_parser_omp_for): Don't create extra\n+\t\tcompound stmt.\n+\n+\t\t(cp_parser_omp_sections): Likewise.\n+\t\t* semantics.c (finish_return_stmt): Call check_omp_return.\n+\t\t(begin_omp_structured_block): Use sk_omp.\n+\t\t(finish_omp_structured_block): Use do_poplevel.  Don't build a\n+\t\tMUST_NOT_THROW expression here.\n+\t\t(begin_omp_parallel, finish_omp_parallel): Don't create extra\n+\t\tcompound statements.\n+\n+\t2005-10-21  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t\tPR 24455\n+\t\t* cp/cp-tree.h (struct lang_decl_flags): Add field\n+\t\tthreadprivate_p.\n+\t\t(CP_DECL_IS_THREADPRIVATE): Define.\n+\t\t* cp/semantics.c (finish_omp_threadprivate): Set.  Do\n+\t\tnot error out if CP_DECL_IS_THREADPRIVATE is set\n+\t\talready.\n+\t\t* cp/decl.c (duplicate_decls): Merge\n+\t\tCP_DECL_THREADPRIVATE_P.\n+\n+\t2005-10-20  Richard Henderson  <rth@redhat.com>\n+\n+\t\t* cp-gimplify.c (cp_gimplify_omp_for): New.\n+\t\t(cp_gimplify_expr): Call it.\n+\t\t* cp-tree.h (OMP_FOR_GIMPLIFYING_P): New.\n+\t\t* parser.c (struct cp_parser): Rename\n+\t\tin_iteration_statement_p to in_iteration_statement and\n+\t\tchange to unsigned char.  Similarly with\n+\t\tin_switch_statement.  Update all users.\n+\t\t(IN_OMP_BLOCK, IN_OMP_FOR): New.\n+\t\t(cp_parser_labeled_statement): Diagnose case labels\n+\t\tbinding closer to an openmp block nested than the\n+\t\tswitch.\n+\t\t(cp_parser_jump_statement): Diagnose break and\n+\t\tcontinue labels binding closer to an openmp block than\n+\t\tan iteration or switch.\n+\t\t(cp_parser_omp_for_loop): Mark in_iteration_statement\n+\t\tfor an omp for.\n+\t\t(cp_parser_begin_omp_structured_block): New.\n+\t\t(cp_parser_end_omp_structured_block): New.\n+\t\t(cp_parser_omp_structured_block): Use them.\n+\t\t(cp_parser_omp_for, cp_parser_omp_sections_scope): Likewise.\n+\t\t(cp_parser_omp_parallel): Likewise.\n+\n+\t2005-10-20  Richard Henderson  <rth@redhat.com>\n+\n+\t\t* semantics.c (begin_omp_structured_block): New.\n+\t\t(finish_omp_structured_block): New.\n+\t\t(begin_omp_parallel, finish_omp_parallel): Use them.\n+\t\t* parser.c (cp_parser_omp_structured_block): Likewise.\n+\t\t(cp_parser_omp_for): Likewise.\n+\t\t(cp_parser_omp_sections_scope): Likewise.\n+\t\t* cp-tree.h: Declare them.\n+\n+\t2005-10-20  Richard Henderson  <rth@redhat.com>\n+\n+\t\t* parser.c (cp_parser_omp_master): Return the statement.\n+\t\t(cp_parser_omp_ordered): Likewise.\n+\t\t(cp_parser_omp_construct): Set the locus for them.\n+\n+\t2005-10-19  Richard Henderson  <rth@redhat.com>\n+\n+\t\t* semantics.c (finish_omp_atomic): Revert to\n+\t\tuses_template_parms.\n+\n+\t2005-10-19  Richard Henderson  <rth@redhat.com>\n+\n+\t\t* semantics.c (finish_omp_clauses): Avoid\n+\t\tDECL_THREAD_LOCAL_P on a PARM_DECL.  Remove some\n+\t\tstub asserts guaranteed to fail.\n+\n+\t2005-10-19  Richard Henderson  <rth@redhat.com>\n+\n+\t\t* cp-tree.h (OMP_ATOMIC_DEPENDENT_P, OMP_ATOMIC_CODE): New.\n+\t\t(finish_omp_clauses, finish_omp_for, finish_omp_atomic): New.\n+\t\t* parser.c (cp_parser_omp_clause_copyin): Remove.\n+\t\t(cp_parser_omp_all_clauses): Use cp_parser_omp_var_list instead.                Call finish_omp_clauses.\n+\t\t(cp_parser_omp_clause_if): Don't do error checking here.\n+\t\t(cp_parser_omp_clause_num_threads): Likewise.\n+\t\t(cp_parser_omp_clause_schedule): Likewise.\n+\t\t(cp_parser_omp_atomic): Use finish_omp_atomic.\n+\t\t(cp_parser_omp_for_loop): Don't discard DECL_EXPR.\n+\t\tDon't decompose assignment statment here.  Use\n+\t\tfinish_omp_for.\n+\n+\t\t* pt.c (tsubst_omp_clauses): New.\n+\t\t(tsubst_expr): Handle OMP_PARALLEL, OMP_FOR, OMP_SECTIONS,\n+\t\tOMP_SINGLE, OMP_SECTION, OMP_CRITICAL, OMP_ATOMIC.\n+\t\t* semantics.c (finish_omp_clauses): New.\n+\t\t(begin_omp_parallel, finish_omp_parallel): Know Less about the\n+\t\tinternals of the stmt_list stack.\n+\t\t(finish_omp_for, finish_omp_atomic): New.\n+\n+\t2005-10-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t\t* semantics.c (cxx_omp_predetermined_sharing): New function.\n+\t\t* cp-tree.h (cxx_omp_predetermined_sharing): New prototype.\n+\t\t* cp-objcp-common.h\n+\t\t(LANG_HOOKS_OMP_PREDETERMINED_SHARING): Redefine.\n+\n+\t2005-10-18  Richard Henderson  <rth@redhat.com>\n+\n+\t\t* parser.c (cp_parser_omp_single): Use make_node and accessors\n+\t\tinstead of build.\n+\n+\t2005-10-17  Richard Henderson  <rth@redhat.com>\n+\n+\t\t* parser.c (cp_parser_omp_for_loop): Handle declarations.\n+\n+\t2005-10-12  Richard Henderson  <rth@redhat.com>\n+\n+\t\t* Make-lang.in (CXX_C_OBJS): Add c-omp.o.\n+\t\t* cp-tree.h (begin_omp_parallel, finish_omp_parallel): Declare.\n+\t\t(finish_omp_threadprivate): Declare.\n+\t\t* parser.c (struct cp_lexer): Add in_pragma.\n+\t\t(cp_lexer_consume_token): Don't consume a PRAGMA_EOL\n+\t\twhen in_pragma.\n+\t\t(cp_parser_skip_to_closing_parenthesis): Stop at PRAGMA_EOL.\n+\t\t(cp_parser_skip_to_end_of_statement): Likewise.\n+\t\t(cp_parser_skip_to_end_of_block_or_statement): Likewise.\n+\t\t(cp_parser_skip_to_closing_brace): Likewise.\n+\t\t(cp_parser_skip_to_pragma_eol): Reset in_pragma.\n+\t\t(cp_parser_require_pragma_eol): New.\n+\t\t(cp_parser_statement): Add in_compound argument;\n+\t\tupdate all callers.\n+\t\tRestart if a non-statement pragma seen outside a\n+\t\tcompound.\n+\t\t(cp_parser_statement_seq_opt): Stop at PRAGMA_EOL.\n+\t\t(cp_parser_declaration_seq_opt): Likewise.\n+\t\t(cp_parser_member_specification_opt): Likewise.\n+\t\t(cp_parser_function_definition_after_decl): Likewise.\n+\t\t(cp_parser_skip_until_found): Likewise.\n+\t\t(cp_parser_cache_group): Likewise.\n+\t\t(enum pragma_omp_clause, cp_parser_omp_clause_name,\n+\t\tcheck_no_duplicate_clause,\n+\t\tcp_parser_omp_var_list_no_open,\n+\t\tcp_parser_omp_var_list, cp_parser_omp_clause_copyin,\n+\t\tcp_parser_omp_clause_default, cp_parser_omp_clause_if,\n+\t\tcp_parser_omp_clause_nowait,\n+\t\tcp_parser_omp_clause_num_threads,\n+\t\tcp_parser_omp_clause_ordered,\n+\t\tcp_parser_omp_clause_reduction,\n+\t\tcp_parser_omp_clause_schedule,\n+\t\tcp_parser_omp_all_clauses,\n+\t\tcp_parser_omp_structured_block, cp_parser_omp_atomic,\n+\t\tcp_parser_omp_barrier, cp_parser_omp_critical,\n+\t\tcp_parser_omp_flush, cp_parser_omp_for_loop,\n+\t\tcp_parser_omp_for, cp_parser_omp_master,\n+\t\tcp_parser_omp_ordered, cp_parser_omp_sections_scope,\n+\t\tcp_parser_omp_sections, cp_parser_omp_parallel,\n+\t\tcp_parser_omp_single, cp_parser_omp_threadprivate,\n+\t\tcp_parser_omp_construct): New.\n+\t\t(cp_parser_pragma): Handle OpenMP pragmas.\n+\t\t* semantics.c (finish_omp_threadprivate): New.\n+\t\t(begin_omp_parallel, finish_omp_parallel): New.\n+\n+\t2005-10-11  Richard Henderson  <rth@redhat.com>\n+\n+\t\t* parser.c (struct cp_token): Add pragma_kind.\n+\t\t(eof_token): Initialize it.\n+\t\t(cp_lexer_handle_pragma): Remove.\n+\t\t(cp_parser_initial_pragma): New.\n+\t\t(cp_lexer_new_main): Use it.\n+\t\t(cp_lexer_get_preprocessor_token): Initialize pragma_kind.\n+\t\t(cp_lexer_print_token): Don't handle CPP_PRAGMA.\n+\t\t(cp_parser_skip_to_pragma_eol): New.\n+\t\t(cp_parser_error): Use it.\n+\t\t(pragma_lex): New.\n+\n+\t2005-10-09  Richard Henderson  <rth@redhat.com>\n+\n+\t\t* lex.c (parse_strconst_pragma): Update for c_lex name change.\n+\t\t(handle_pragma_java_exceptions): Likewise.\n+\t\t* parser.c (cp_lexer_new_main): Likewise.\n+\n+\t2005-10-06  Richard Henderson  <rth@redhat.com>\n+\n+\t\t* parser.c (cp_lexer_new_main): Comment out defer_pragmas.\n+\t\t(cp_lexer_handle_pragma): Comment out\n+\t\tcpp_handle_deferred_pragma.\n+\n+\t2005-10-01  Richard Henderson  <rth@redhat.com>\n+\n+\t\t* name-lookup.c (lookup_name): Remove prefer_type argument.\n+\t\t(lookup_name_prefer_type): New function.\n+\t\t* name-lookup.h (lookup_name_prefer_type): Declare it.\n+\t\t* decl.c (lookup_and_check_tag): Use it.\n+\t\t* pt.c (tsubst_friend_class): Likewise. Update for\n+\t\tlookup_name change.\n+\t\t(lookup_template_class, tsubst_copy_and_build): Likewise.\n+\n 2006-03-06  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \tPR c++/15759\n@@ -27,7 +476,7 @@\n \n \tPR c++/26291\n \t* decl.c (grok_op_properties): Check for ellipsis in arguments of\n-        operators.\n+\toperators.\n \n 2006-02-20  Rafael \ufffdvila de Esp\ufffdndola  <rafael.espindola@gmail.com>\n \n@@ -443,10 +892,10 @@\n \n 2006-01-20  Dirk Mueller  <dmueller@suse.com>\n \n-        PR c++/5520\n-        * semantics.c (finish_if_stmt): Call empty_body_warning.\n-        * parser.c (cp_parser_implicitly_scoped_statement):\n-        Mark empty statement with an empty stmt.\n+\tPR c++/5520\n+\t* semantics.c (finish_if_stmt): Call empty_body_warning.\n+\t* parser.c (cp_parser_implicitly_scoped_statement):\n+\tMark empty statement with an empty stmt.\n \n 2006-01-19  Mark Mitchell  <mark@codesourcery.com>\n \n@@ -572,8 +1021,8 @@\n \n 2006-01-04  Chris Lattner  <sabre@gnu.org>\n \n-        * typeck2.c: update copyright to 2006\n-        (split_nonconstant_init_1):  Set TREE_CONSTANT to true.\n+\t* typeck2.c: update copyright to 2006\n+\t(split_nonconstant_init_1):  Set TREE_CONSTANT to true.\n \n 2006-01-04  Mark Mitchell  <mark@codesourcery.com>\n \n@@ -814,7 +1263,7 @@\n 2005-12-06  Aldy Hernandez  <aldyh@redhat.com>\n \n        PR C++/24138\n-        * decl.c (reshape_init_array_1): Handle max_index of -1.\n+\t* decl.c (reshape_init_array_1): Handle max_index of -1.\n \n 2005-12-06  Roger Sayle  <roger@eyesopen.com>\n \n@@ -1479,7 +1928,7 @@\n 2005-10-10  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n \t    Mark Mitchell  <mark@codesourcery.com>\n \n-        PR c++/23437\n+\tPR c++/23437\n \t* parser.c (cp_parser_template_argument_list): Do not treat\n \tcontents of argument list as part of a constant expression.\n \n@@ -1977,27 +2426,27 @@\n \n 2005-08-15 Fariborz Jahanian <fjahanian@apple.com>\n \n-        * cp-tree.h (can_convert_arg, fn_type_unification): New argument.\n-        * call.c (add_template_candidate_real): Pass down 'flags' to\n-        fn_type_unification.\n-        (can_convert_arg): New 'flags' argument. Pass it to call to\n-        implicit_conversion instead of LOOKUP_NORMAL.\n+\t* cp-tree.h (can_convert_arg, fn_type_unification): New argument.\n+\t* call.c (add_template_candidate_real): Pass down 'flags' to\n+\tfn_type_unification.\n+\t(can_convert_arg): New 'flags' argument. Pass it to call to\n+\timplicit_conversion instead of LOOKUP_NORMAL.\n \t(can_convert): Add LOOKUP_NORMAL to call to can_convert_arg.\n-        * class.c (resolve_address_of_overloaded_function): Ditto.\n-        (resolve_address_of_overloaded_function): Ditto.\n-        * decl.c (reshape_init, check_default_argument): Ditto.\n-        * typeck.c (build_ptrmemfunc): Ditto.\n-        * pt.c (type_unification_real): Add 'flags' argument.\n-        (fn_type_unification): Pass 'flags' to type_unification_real.\n-        (type_unification_real): Pass new 'flags' argument to call to\n-        can_convert_arg.\n+\t* class.c (resolve_address_of_overloaded_function): Ditto.\n+\t(resolve_address_of_overloaded_function): Ditto.\n+\t* decl.c (reshape_init, check_default_argument): Ditto.\n+\t* typeck.c (build_ptrmemfunc): Ditto.\n+\t* pt.c (type_unification_real): Add 'flags' argument.\n+\t(fn_type_unification): Pass 'flags' to type_unification_real.\n+\t(type_unification_real): Pass new 'flags' argument to call to\n+\tcan_convert_arg.\n \n 2005-08-12  Giovanni Bajo  <giovannibajo@libero.it>\n \t    Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/21799\n \tPR c++/8271\n-        * pt.c (unify) <METHOD_TYPE>: Check this-pointer cv-qualifiers\n+\t* pt.c (unify) <METHOD_TYPE>: Check this-pointer cv-qualifiers\n \texplicitly.\n \n 2005-08-12  Nathan Sidwell  <nathan@codesourcery.com>\n@@ -2327,7 +2776,7 @@\n \tdiagnostics.\n \n 2005-07-02  Zack Weinberg  <zack@codesourcery.com>\n-            Joseph S. Myers  <joseph@codesourcery.com>\n+\t    Joseph S. Myers  <joseph@codesourcery.com>\n \n \t* error.c (location_of): Add comment.\n \t(locate_error, cp_error_at, cp_warning_at, cp_pedwarn_at): Remove."}, {"sha": "63b7507fd0348af349e630bc13c9677511c0d0c6", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -75,7 +75,7 @@ g++-cross$(exeext): g++$(exeext)\n CXX_C_OBJS = attribs.o c-common.o c-format.o c-pragma.o c-semantics.o c-lex.o \\\n \tc-dump.o $(CXX_TARGET_OBJS) c-pretty-print.o c-opts.o c-pch.o \\\n \tc-incpath.o cppdefault.o c-ppoutput.o c-cppbuiltin.o prefix.o \\\n-\tc-gimplify.o tree-inline.o\n+\tc-gimplify.o c-omp.o tree-inline.o\n \n # Language-specific object files for C++ and Objective C++.\n CXX_AND_OBJCXX_OBJS = cp/call.o cp/decl.o cp/expr.o cp/pt.o cp/typeck2.o \\"}, {"sha": "bd8f1a0569f52aff8eb3b45e2a761f6a68bf7a86", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 194, "deletions": 31, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -37,30 +37,9 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n enum bc_t { bc_break = 0, bc_continue = 1 };\n \n-static struct cp_gimplify_ctx\n-{\n-  /* Stack of labels which are targets for \"break\" or \"continue\",\n-     linked through TREE_CHAIN.  */\n-  tree current_label[2];\n-} *ctxp;\n-\n-static void\n-push_context (void)\n-{\n-  gcc_assert (!ctxp);\n-  ctxp = ((struct cp_gimplify_ctx *)\n-\t  xcalloc (1, sizeof (struct cp_gimplify_ctx)));\n-}\n-\n-static void\n-pop_context (void)\n-{\n-  gcc_assert (ctxp\n-\t      && !ctxp->current_label[0]\n-\t      && !ctxp->current_label[1]);\n-  free (ctxp);\n-  ctxp = NULL;\n-}\n+/* Stack of labels which are targets for \"break\" or \"continue\",\n+   linked through TREE_CHAIN.  */\n+static tree bc_label[2];\n \n /* Begin a scope which can be exited by a break or continue statement.  BC\n    indicates which.\n@@ -71,8 +50,8 @@ static tree\n begin_bc_block (enum bc_t bc)\n {\n   tree label = create_artificial_label ();\n-  TREE_CHAIN (label) = ctxp->current_label[bc];\n-  ctxp->current_label[bc] = label;\n+  TREE_CHAIN (label) = bc_label[bc];\n+  bc_label[bc] = label;\n   return label;\n }\n \n@@ -86,7 +65,7 @@ begin_bc_block (enum bc_t bc)\n static tree\n finish_bc_block (enum bc_t bc, tree label, tree body)\n {\n-  gcc_assert (label == ctxp->current_label[bc]);\n+  gcc_assert (label == bc_label[bc]);\n \n   if (TREE_USED (label))\n     {\n@@ -99,7 +78,7 @@ finish_bc_block (enum bc_t bc, tree label, tree body)\n       body = sl;\n     }\n \n-  ctxp->current_label[bc] = TREE_CHAIN (label);\n+  bc_label[bc] = TREE_CHAIN (label);\n   TREE_CHAIN (label) = NULL_TREE;\n   return body;\n }\n@@ -110,7 +89,7 @@ finish_bc_block (enum bc_t bc, tree label, tree body)\n static tree\n build_bc_goto (enum bc_t bc)\n {\n-  tree label = ctxp->current_label[bc];\n+  tree label = bc_label[bc];\n \n   if (label == NULL_TREE)\n     {\n@@ -338,6 +317,36 @@ gimplify_switch_stmt (tree *stmt_p)\n   *stmt_p = finish_bc_block (bc_break, break_block, *stmt_p);\n }\n \n+/* Hook into the middle of gimplifying an OMP_FOR node.  This is required\n+   in order to properly gimplify CONTINUE statements.  Here we merely\n+   manage the continue stack; the rest of the job is performed by the\n+   regular gimplifier.  */ \n+\n+static enum gimplify_status\n+cp_gimplify_omp_for (tree *expr_p)\n+{\n+  tree for_stmt = *expr_p;\n+  tree cont_block;\n+\n+  /* Protect ourselves from recursion.  */\n+  if (OMP_FOR_GIMPLIFYING_P (for_stmt))\n+    return GS_UNHANDLED;\n+  OMP_FOR_GIMPLIFYING_P (for_stmt) = 1;\n+\n+  /* Note that while technically the continue label is enabled too soon\n+     here, we should have already diagnosed invalid continues nested within\n+     statement expressions within the INIT, COND, or INCR expressions.  */\n+  cont_block = begin_bc_block (bc_continue);\n+\n+  gimplify_stmt (expr_p);\n+\n+  OMP_FOR_BODY (for_stmt)\n+    = finish_bc_block (bc_continue, cont_block, OMP_FOR_BODY (for_stmt));\n+  OMP_FOR_GIMPLIFYING_P (for_stmt) = 0;\n+\n+  return GS_ALL_DONE;\n+}\n+\n /*  Gimplify an EXPR_STMT node.  */\n \n static void\n@@ -543,6 +552,10 @@ cp_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p)\n       ret = GS_ALL_DONE;\n       break;\n \n+    case OMP_FOR:\n+      ret = cp_gimplify_omp_for (expr_p);\n+      break;\n+\n     case CONTINUE_STMT:\n       *expr_p = build_bc_goto (bc_continue);\n       ret = GS_ALL_DONE;\n@@ -686,7 +699,157 @@ cp_genericize (tree fndecl)\n   pointer_set_destroy (p_set);\n \n   /* Do everything else.  */\n-  push_context ();\n   c_genericize (fndecl);\n-  pop_context ();\n+\n+  gcc_assert (bc_label[bc_break] == NULL);\n+  gcc_assert (bc_label[bc_continue] == NULL);\n+}\n+\f\n+/* Build code to apply FN to each member of ARG1 and ARG2.  FN may be\n+   NULL if there is in fact nothing to do.  ARG2 may be null if FN\n+   actually only takes one argument.  */\n+\n+static tree\n+cxx_omp_clause_apply_fn (tree fn, tree arg1, tree arg2)\n+{\n+  if (fn == NULL)\n+    return NULL;\n+\n+  if (TREE_CODE (TREE_TYPE (arg1)) == ARRAY_TYPE)\n+    {\n+      tree inner_type = TREE_TYPE (arg1);\n+      tree start1, end1, p1;\n+      tree start2 = NULL, p2 = NULL;\n+      tree ret = NULL, lab, t;\n+\n+      start1 = arg1;\n+      start2 = arg2;\n+      do\n+\t{\n+\t  inner_type = TREE_TYPE (inner_type);\n+\t  start1 = build4 (ARRAY_REF, inner_type, start1,\n+\t\t\t   size_zero_node, NULL, NULL);\n+\t  if (arg2)\n+\t    start2 = build4 (ARRAY_REF, inner_type, start2,\n+\t\t\t     size_zero_node, NULL, NULL);\n+\t}\n+      while (TREE_CODE (inner_type) == ARRAY_TYPE);\n+      start1 = build_fold_addr_expr (start1);\n+      if (arg2)\n+\tstart2 = build_fold_addr_expr (start2);\n+\n+      end1 = TYPE_SIZE_UNIT (TREE_TYPE (arg1));\n+      end1 = fold_convert (TREE_TYPE (start1), end1);\n+      end1 = build2 (PLUS_EXPR, TREE_TYPE (start1), start1, end1);\n+\n+      p1 = create_tmp_var (TREE_TYPE (start1), NULL);\n+      t = build2 (MODIFY_EXPR, void_type_node, p1, start1);\n+      append_to_statement_list (t, &ret);\n+\n+      if (arg2)\n+\t{\n+\t  p2 = create_tmp_var (TREE_TYPE (start2), NULL);\n+\t  t = build2 (MODIFY_EXPR, void_type_node, p2, start2);\n+\t  append_to_statement_list (t, &ret);\n+\t}\n+\n+      lab = create_artificial_label ();\n+      t = build1 (LABEL_EXPR, void_type_node, lab);\n+      append_to_statement_list (t, &ret);\n+\n+      t = NULL;\n+      if (arg2)\n+\tt = tree_cons (NULL, p2, t);\n+      t = tree_cons (NULL, p1, t);\n+      t = build_call (fn, t);\n+      append_to_statement_list (t, &ret);\n+\n+      t = fold_convert (TREE_TYPE (p1), TYPE_SIZE_UNIT (inner_type));\n+      t = build2 (PLUS_EXPR, TREE_TYPE (p1), p1, t);\n+      t = build2 (MODIFY_EXPR, void_type_node, p1, t);\n+      append_to_statement_list (t, &ret);\n+\n+      if (arg2)\n+\t{\n+\t  t = fold_convert (TREE_TYPE (p2), TYPE_SIZE_UNIT (inner_type));\n+\t  t = build2 (PLUS_EXPR, TREE_TYPE (p2), p2, t);\n+\t  t = build2 (MODIFY_EXPR, void_type_node, p2, t);\n+\t  append_to_statement_list (t, &ret);\n+\t}\n+\n+      t = build2 (NE_EXPR, boolean_type_node, p1, end1);\n+      t = build3 (COND_EXPR, void_type_node, t, build_and_jump (&lab), NULL);\n+      append_to_statement_list (t, &ret);\n+\n+      return ret;\n+    }\n+  else\n+    {\n+      tree t = NULL;\n+      if (arg2)\n+\tt = tree_cons (NULL, build_fold_addr_expr (arg2), t);\n+      t = tree_cons (NULL, build_fold_addr_expr (arg1), t);\n+      return build_call (fn, t);\n+    }\n+}\n+\n+/* Return code to initialize DECL with its default constructor, or\n+   NULL if there's nothing to do.  */\n+\n+tree\n+cxx_omp_clause_default_ctor (tree clause, tree decl)\n+{\n+  tree info = CP_OMP_CLAUSE_INFO (clause);\n+  tree ret = NULL;\n+\n+  if (info)\n+    ret = cxx_omp_clause_apply_fn (TREE_VEC_ELT (info, 0), decl, NULL);\n+\n+  return ret;\n+}\n+\n+/* Return code to initialize DST with a copy constructor from SRC.  */\n+\n+tree\n+cxx_omp_clause_copy_ctor (tree clause, tree dst, tree src)\n+{\n+  tree info = CP_OMP_CLAUSE_INFO (clause);\n+  tree ret = NULL;\n+\n+  if (info)\n+    ret = cxx_omp_clause_apply_fn (TREE_VEC_ELT (info, 0), dst, src);\n+  if (ret == NULL)\n+    ret = build2 (MODIFY_EXPR, void_type_node, dst, src);\n+\n+  return ret;\n+}\n+\n+/* Similarly, except use an assignment operator instead.  */\n+\n+tree\n+cxx_omp_clause_assign_op (tree clause, tree dst, tree src)\n+{\n+  tree info = CP_OMP_CLAUSE_INFO (clause);\n+  tree ret = NULL;\n+\n+  if (info)\n+    ret = cxx_omp_clause_apply_fn (TREE_VEC_ELT (info, 2), dst, src);\n+  if (ret == NULL)\n+    ret = build2 (MODIFY_EXPR, void_type_node, dst, src);\n+\n+  return ret;\n+}\n+\n+/* Return code to destroy DECL.  */\n+\n+tree\n+cxx_omp_clause_dtor (tree clause, tree decl)\n+{\n+  tree info = CP_OMP_CLAUSE_INFO (clause);\n+  tree ret = NULL;\n+\n+  if (info)\n+    ret = cxx_omp_clause_apply_fn (TREE_VEC_ELT (info, 1), decl, NULL);\n+\n+  return ret;\n }"}, {"sha": "96e6eb699dca7497dd7fc490577de5f7d67bd665", "filename": "gcc/cp/cp-objcp-common.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Fcp%2Fcp-objcp-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Fcp%2Fcp-objcp-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.h?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -151,5 +151,15 @@ extern tree objcp_tsubst_copy_and_build (tree, tree, tsubst_flags_t,\n #define LANG_HOOKS_TO_TARGET_CHARSET c_common_to_target_charset\n #undef LANG_HOOKS_GIMPLIFY_EXPR\n #define LANG_HOOKS_GIMPLIFY_EXPR cp_gimplify_expr\n+#undef LANG_HOOKS_OMP_PREDETERMINED_SHARING\n+#define LANG_HOOKS_OMP_PREDETERMINED_SHARING cxx_omp_predetermined_sharing\n+#undef LANG_HOOKS_OMP_CLAUSE_DEFAULT_CTOR\n+#define LANG_HOOKS_OMP_CLAUSE_DEFAULT_CTOR cxx_omp_clause_default_ctor\n+#undef LANG_HOOKS_OMP_CLAUSE_COPY_CTOR\n+#define LANG_HOOKS_OMP_CLAUSE_COPY_CTOR cxx_omp_clause_copy_ctor\n+#undef LANG_HOOKS_OMP_CLAUSE_ASSIGN_OP\n+#define LANG_HOOKS_OMP_CLAUSE_ASSIGN_OP cxx_omp_clause_assign_op\n+#undef LANG_HOOKS_OMP_CLAUSE_DTOR\n+#define LANG_HOOKS_OMP_CLAUSE_DTOR cxx_omp_clause_dtor\n \n #endif /* GCC_CP_OBJCP_COMMON */"}, {"sha": "69d64667502d64b4da770fe5aab7d99b767755f6", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 47, "deletions": 4, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -52,6 +52,8 @@ struct diagnostic_context;\n       TYPENAME_IS_ENUM_P (in TYPENAME_TYPE)\n       REFERENCE_REF_P (in INDIRECT_EXPR)\n       QUALIFIED_NAME_IS_TEMPLATE (in SCOPE_REF)\n+      OMP_ATOMIC_DEPENDENT_P (in OMP_ATOMIC)\n+      OMP_FOR_GIMPLIFYING_P (in OMP_FOR)\n       BASELINK_QUALIFIED_P (in BASELINK)\n    1: IDENTIFIER_VIRTUAL_P (in IDENTIFIER_NODE)\n       TI_PENDING_TEMPLATE_FLAG.\n@@ -742,8 +744,7 @@ struct language_function GTY(())\n   /* True if this function can throw an exception.  */\n   BOOL_BITFIELD can_throw : 1;\n \n-  struct named_label_use_list *x_named_label_uses;\n-  struct named_label_list *x_named_labels;\n+  htab_t GTY((param_is(struct named_label_entry))) x_named_labels;\n   struct cp_binding_level *bindings;\n   VEC(tree,gc) *x_local_names;\n };\n@@ -1521,7 +1522,8 @@ struct lang_decl_flags GTY(())\n   unsigned this_thunk_p : 1;\n   unsigned repo_available_p : 1;\n   unsigned hidden_friend_p : 1;\n-  unsigned dummy : 2;\n+  unsigned threadprivate_p : 1;\n+  /* One unused bit.  */\n \n   union lang_decl_u {\n     /* In a FUNCTION_DECL for which DECL_THUNK_P holds, this is\n@@ -2348,6 +2350,11 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n #define DECL_HIDDEN_FRIEND_P(NODE) \\\n   (DECL_LANG_SPECIFIC (DECL_COMMON_CHECK (NODE))->decl_flags.hidden_friend_p)\n \n+/* Nonzero if DECL has been declared threadprivate by\n+   #pragma omp threadprivate.  */\n+#define CP_DECL_THREADPRIVATE_P(DECL) \\\n+  (DECL_LANG_SPECIFIC (VAR_DECL_CHECK (DECL))->decl_flags.threadprivate_p)\n+\n /* Record whether a typedef for type `int' was actually `signed int'.  */\n #define C_TYPEDEF_EXPLICITLY_SIGNED(EXP) DECL_LANG_FLAG_1 (EXP)\n \n@@ -2947,6 +2954,26 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n #define QUALIFIED_NAME_IS_TEMPLATE(NODE) \\\n   (TREE_LANG_FLAG_0 (SCOPE_REF_CHECK (NODE)))\n \n+/* True for an OMP_ATOMIC that has dependent parameters.  These are stored\n+   as bare LHS/RHS, and not as ADDR/RHS, as in the generic statement.  */\n+#define OMP_ATOMIC_DEPENDENT_P(NODE) \\\n+  (TREE_LANG_FLAG_0 (OMP_ATOMIC_CHECK (NODE)))\n+\n+/* Used to store the operation code when OMP_ATOMIC_DEPENDENT_P is set.  */\n+#define OMP_ATOMIC_CODE(NODE) \\\n+  (OMP_ATOMIC_CHECK (NODE)->exp.complexity)\n+\n+/* Used while gimplifying continue statements bound to OMP_FOR nodes.  */\n+#define OMP_FOR_GIMPLIFYING_P(NODE) \\\n+  (TREE_LANG_FLAG_0 (OMP_FOR_CHECK (NODE)))\n+\n+/* A language-specific token attached to the OpenMP data clauses to \n+   hold code (or code fragments) related to ctors, dtors, and op=.\n+   See semantics.c for details.  */\n+#define CP_OMP_CLAUSE_INFO(NODE) \\\n+  TREE_TYPE (OMP_CLAUSE_RANGE_CHECK (NODE, OMP_CLAUSE_PRIVATE, \\\n+\t\t\t             OMP_CLAUSE_COPYPRIVATE))\n+\n /* These macros provide convenient access to the various _STMT nodes\n    created when parsing template declarations.  */\n #define TRY_STMTS(NODE)\t\tTREE_OPERAND (TRY_BLOCK_CHECK (NODE), 0)\n@@ -3782,12 +3809,12 @@ extern tree pushtag\t\t\t\t(tree, tree, tag_scope);\n extern tree make_anon_name\t\t\t(void);\n extern int decls_match\t\t\t\t(tree, tree);\n extern tree duplicate_decls\t\t\t(tree, tree, bool);\n-extern tree pushdecl_top_level\t\t\t(tree);\n extern tree pushdecl_top_level_maybe_friend\t(tree, bool);\n extern tree pushdecl_top_level_and_finish\t(tree, tree);\n extern tree declare_local_label\t\t\t(tree);\n extern tree define_label\t\t\t(location_t, tree);\n extern void check_goto\t\t\t\t(tree);\n+extern bool check_omp_return\t\t\t(void);\n extern tree make_typename_type\t\t\t(tree, tree, enum tag_types, tsubst_flags_t);\n extern tree make_unbound_class_template\t\t(tree, tree, tree, tsubst_flags_t);\n extern tree check_for_out_of_scope_variable\t(tree);\n@@ -4216,6 +4243,22 @@ extern tree finish_qualified_id_expr\t\t(tree, tree, bool, bool,\n extern void simplify_aggr_init_expr\t\t(tree *);\n extern void finalize_nrv\t\t\t(tree *, tree, tree);\n extern void note_decl_for_pch\t\t\t(tree);\n+extern tree finish_omp_clauses\t\t\t(tree);\n+extern void finish_omp_threadprivate\t\t(tree);\n+extern tree begin_omp_structured_block\t\t(void);\n+extern tree finish_omp_structured_block\t\t(tree);\n+extern tree begin_omp_parallel\t\t\t(void);\n+extern tree finish_omp_parallel\t\t\t(tree, tree);\n+extern tree finish_omp_for\t\t\t(location_t, tree, tree,\n+\t\t\t\t\t\t tree, tree, tree, tree);\n+extern void finish_omp_atomic\t\t\t(enum tree_code, tree, tree);\n+extern void finish_omp_barrier\t\t\t(void);\n+extern void finish_omp_flush\t\t\t(void);\n+extern enum omp_clause_default_kind cxx_omp_predetermined_sharing (tree);\n+extern tree cxx_omp_clause_default_ctor\t\t(tree, tree);\n+extern tree cxx_omp_clause_copy_ctor\t\t(tree, tree, tree);\n+extern tree cxx_omp_clause_assign_op\t\t(tree, tree, tree);\n+extern tree cxx_omp_clause_dtor\t\t\t(tree, tree);\n \n /* in tree.c */\n extern void lang_check_failed\t\t\t(const char *, int,"}, {"sha": "d0866dc5b3dd3f0f7a122f89546c544b1a486352", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 350, "deletions": 222, "changes": 572, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -80,15 +80,6 @@ static tree record_builtin_java_type (const char *, int);\n static const char *tag_name (enum tag_types);\n static tree lookup_and_check_tag (enum tag_types, tree, tag_scope, bool);\n static int walk_namespaces_r (tree, walk_namespaces_fn, void *);\n-static tree make_label_decl (tree, int);\n-static void use_label (tree);\n-static void check_previous_goto_1 (tree, struct cp_binding_level *, tree,\n-\t\t\t\t   const location_t *);\n-static void check_previous_goto (struct named_label_use_list *);\n-static void check_switch_goto (struct cp_binding_level *);\n-static void check_previous_gotos (tree);\n-static void pop_label (tree, tree);\n-static void pop_labels (tree);\n static void maybe_deduce_size_from_array_init (tree, tree);\n static void layout_var_decl (tree);\n static void maybe_commonize_var (tree);\n@@ -167,20 +158,6 @@ tree global_type_node;\n /* The node that holds the \"name\" of the global scope.  */\n tree global_scope_name;\n \n-/* Used only for jumps to as-yet undefined labels, since jumps to\n-   defined labels can have their validity checked immediately.  */\n-\n-struct named_label_use_list GTY(())\n-{\n-  struct cp_binding_level *binding_level;\n-  tree names_in_scope;\n-  tree label_decl;\n-  location_t o_goto_locus;\n-  struct named_label_use_list *next;\n-};\n-\n-#define named_label_uses cp_function_chain->x_named_label_uses\n-\n #define local_names cp_function_chain->x_local_names\n \n /* A list of objects which have constructors or destructors\n@@ -195,20 +172,58 @@ tree static_aggregates;\n \n tree integer_two_node, integer_three_node;\n \n+/* Used only for jumps to as-yet undefined labels, since jumps to\n+   defined labels can have their validity checked immediately.  */\n+\n+struct named_label_use_entry GTY(())\n+{\n+  struct named_label_use_entry *next;\n+  /* The binding level to which this entry is *currently* attached.\n+     This is initially the binding level in which the goto appeared,\n+     but is modified as scopes are closed.  */\n+  struct cp_binding_level *binding_level;\n+  /* The head of the names list that was current when the goto appeared,\n+     or the inner scope popped.  These are the decls that will *not* be\n+     skipped when jumping to the label.  */\n+  tree names_in_scope;\n+  /* The location of the goto, for error reporting.  */\n+  location_t o_goto_locus;\n+  /* True if an OpenMP structured block scope has been closed since\n+     the goto appeared.  This means that the branch from the label will\n+     illegally exit an OpenMP scope.  */\n+  bool in_omp_scope;\n+};\n+\n /* A list of all LABEL_DECLs in the function that have names.  Here so\n    we can clear out their names' definitions at the end of the\n    function, and so we can check the validity of jumps to these labels.  */\n \n-struct named_label_list GTY(())\n+struct named_label_entry GTY(())\n {\n+  /* The decl itself.  */\n+  tree label_decl;\n+\n+  /* The binding level to which the label is *currently* attached.\n+     This is initially set to the binding level in which the label\n+     is defined, but is modified as scopes are closed.  */\n   struct cp_binding_level *binding_level;\n+  /* The head of the names list that was current when the label was \n+     defined, or the inner scope popped.  These are the decls that will\n+     be skipped when jumping to the label.  */\n   tree names_in_scope;\n-  tree old_value;\n-  tree label_decl;\n+  /* A tree list of all decls from all binding levels that would be\n+     crossed by a backward branch to the label.  */\n   tree bad_decls;\n-  struct named_label_list *next;\n-  unsigned int in_try_scope : 1;\n-  unsigned int in_catch_scope : 1;\n+\n+  /* A list of uses of the label, before the label is defined.  */\n+  struct named_label_use_entry *uses;\n+\n+  /* The following bits are set after the label is defined, and are\n+     updated as scopes are popped.  They indicate that a backward jump\n+     to the label will illegally enter a scope of the given flavour.  */\n+  bool in_try_scope;\n+  bool in_catch_scope;\n+  bool in_omp_scope;\n };\n \n #define named_labels cp_function_chain->x_named_labels\n@@ -372,23 +387,47 @@ pop_label (tree label, tree old_value)\n    go out of scope.  BLOCK is the top-level block for the\n    function.  */\n \n+static int\n+pop_labels_1 (void **slot, void *data)\n+{\n+  struct named_label_entry *ent = (struct named_label_entry *) *slot;\n+  tree block = (tree) data;\n+\n+  pop_label (ent->label_decl, NULL_TREE);\n+\n+  /* Put the labels into the \"variables\" of the top-level block,\n+     so debugger can see them.  */\n+  TREE_CHAIN (ent->label_decl) = BLOCK_VARS (block);\n+  BLOCK_VARS (block) = ent->label_decl;\n+\n+  htab_clear_slot (named_labels, slot);\n+\n+  return 1;\n+}\n+\n static void\n pop_labels (tree block)\n {\n-  struct named_label_list *link;\n-\n-  /* Clear out the definitions of all label names, since their scopes\n-     end here.  */\n-  for (link = named_labels; link; link = link->next)\n+  if (named_labels)\n     {\n-      pop_label (link->label_decl, link->old_value);\n-      /* Put the labels into the \"variables\" of the top-level block,\n-\t so debugger can see them.  */\n-      TREE_CHAIN (link->label_decl) = BLOCK_VARS (block);\n-      BLOCK_VARS (block) = link->label_decl;\n+      htab_traverse (named_labels, pop_labels_1, block);\n+      named_labels = NULL;\n     }\n+}\n+\n+/* At the end of a block with local labels, restore the outer definition.  */\n \n-  named_labels = NULL;\n+static void\n+pop_local_label (tree label, tree old_value)\n+{\n+  struct named_label_entry dummy;\n+  void **slot;\n+\n+  pop_label (label, old_value);\n+\n+  dummy.label_decl = label;\n+  slot = htab_find_slot (named_labels, &dummy, NO_INSERT);\n+  htab_clear_slot (named_labels, slot);\n }\n \n /* The following two routines are used to interface to Objective-C++.\n@@ -426,6 +465,57 @@ objc_mark_locals_volatile (void *enclosing_blk)\n     }\n }\n \n+/* Update data for defined and undefined labels when leaving a scope.  */\n+\n+static int\n+poplevel_named_label_1 (void **slot, void *data)\n+{\n+  struct named_label_entry *ent = (struct named_label_entry *) *slot;\n+  struct cp_binding_level *bl = (struct cp_binding_level *) data;\n+  struct cp_binding_level *obl = bl->level_chain;\n+\n+  if (ent->binding_level == bl)\n+    {\n+      tree decl;\n+\n+      for (decl = ent->names_in_scope; decl; decl = TREE_CHAIN (decl))\n+\tif (decl_jump_unsafe (decl))\n+\t  ent->bad_decls = tree_cons (NULL, decl, ent->bad_decls);\n+\n+      ent->binding_level = obl;\n+      ent->names_in_scope = obl->names;\n+      switch (bl->kind)\n+\t{\n+\tcase sk_try:\n+\t  ent->in_try_scope = true;\n+\t  break;\n+\tcase sk_catch:\n+\t  ent->in_catch_scope = true;\n+\t  break;\n+\tcase sk_omp:\n+\t  ent->in_omp_scope = true;\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+  else if (ent->uses)\n+    {\n+      struct named_label_use_entry *use;\n+\n+      for (use = ent->uses; use ; use = use->next)\n+\tif (use->binding_level == bl)\n+\t  {\n+\t    use->binding_level = obl;\n+\t    use->names_in_scope = obl->names;\n+\t    if (bl->kind == sk_omp)\n+\t      use->in_omp_scope = true;\n+\t  }\n+    }\n+\n+  return 1;\n+}\n+\n /* Exit a binding level.\n    Pop the level off, and restore the state of the identifier-decl mappings\n    that were in effect when this level was entered.\n@@ -480,39 +570,9 @@ poplevel (int keep, int reverse, int functionbody)\n \n   /* Any uses of undefined labels, and any defined labels, now operate\n      under constraints of next binding contour.  */\n-  if (cfun && !functionbody)\n-    {\n-      struct cp_binding_level *level_chain;\n-      level_chain = current_binding_level->level_chain;\n-      if (level_chain)\n-\t{\n-\t  struct named_label_use_list *uses;\n-\t  struct named_label_list *labels;\n-\t  for (labels = named_labels; labels; labels = labels->next)\n-\t    if (labels->binding_level == current_binding_level)\n-\t      {\n-\t\ttree decl;\n-\t\tif (current_binding_level->kind == sk_try)\n-\t\t  labels->in_try_scope = 1;\n-\t\tif (current_binding_level->kind == sk_catch)\n-\t\t  labels->in_catch_scope = 1;\n-\t\tfor (decl = labels->names_in_scope; decl;\n-\t\t     decl = TREE_CHAIN (decl))\n-\t\t  if (decl_jump_unsafe (decl))\n-\t\t    labels->bad_decls = tree_cons (NULL_TREE, decl,\n-\t\t\t\t\t\t   labels->bad_decls);\n-\t\tlabels->binding_level = level_chain;\n-\t\tlabels->names_in_scope = level_chain->names;\n-\t      }\n-\n-\t  for (uses = named_label_uses; uses; uses = uses->next)\n-\t    if (uses->binding_level == current_binding_level)\n-\t      {\n-\t\tuses->binding_level = level_chain;\n-\t\tuses->names_in_scope = level_chain->names;\n-\t      }\n-\t}\n-    }\n+  if (cfun && !functionbody && named_labels)\n+    htab_traverse (named_labels, poplevel_named_label_1,\n+\t\t   current_binding_level);\n \n   /* Get the decls in the order they were written.\n      Usually current_binding_level->names is in reverse order.\n@@ -660,7 +720,7 @@ poplevel (int keep, int reverse, int functionbody)\n   for (link = current_binding_level->shadowed_labels;\n        link;\n        link = TREE_CHAIN (link))\n-    pop_label (TREE_VALUE (link), TREE_PURPOSE (link));\n+    pop_local_label (TREE_VALUE (link), TREE_PURPOSE (link));\n \n   /* There may be OVERLOADs (wrapped in TREE_LISTs) on the BLOCK_VARs\n      list if a `using' declaration put them there.  The debugging\n@@ -1585,6 +1645,18 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t    |= DECL_NONTRIVIALLY_INITIALIZED_P (olddecl);\n \t  DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (newdecl)\n \t    |= DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (olddecl);\n+\n+\t  /* Merge the threadprivate attribute from OLDDECL into NEWDECL.  */\n+\t  if (DECL_LANG_SPECIFIC (olddecl)\n+\t      && CP_DECL_THREADPRIVATE_P (olddecl))\n+\t    {\n+\t      /* Allocate a LANG_SPECIFIC structure for NEWDECL, if needed.  */\n+\t      if (!DECL_LANG_SPECIFIC (newdecl))\n+\t\tretrofit_lang_decl (newdecl);\n+\n+\t      DECL_TLS_MODEL (newdecl) = DECL_TLS_MODEL (olddecl);\n+\t      CP_DECL_THREADPRIVATE_P (newdecl) = 1;\n+\t    }\n \t}\n \n       /* Do this after calling `merge_types' so that default\n@@ -2039,7 +2111,10 @@ redeclaration_error_message (tree newdecl, tree olddecl)\n       return NULL;\n     }\n   else if (TREE_CODE (newdecl) == VAR_DECL\n-\t   && DECL_THREAD_LOCAL_P (newdecl) != DECL_THREAD_LOCAL_P (olddecl))\n+\t   && DECL_THREAD_LOCAL_P (newdecl) != DECL_THREAD_LOCAL_P (olddecl)\n+\t   && (! DECL_LANG_SPECIFIC (olddecl)\n+\t       || ! CP_DECL_THREADPRIVATE_P (olddecl)\n+\t       || DECL_THREAD_LOCAL_P (newdecl)))\n     {\n       /* Only variables can be thread-local, and all declarations must\n \t agree on this property.  */\n@@ -2070,11 +2145,30 @@ redeclaration_error_message (tree newdecl, tree olddecl)\n     }\n }\n \f\n+/* Hash and equality functions for the named_label table.  */\n+\n+static hashval_t\n+named_label_entry_hash (const void *data)\n+{\n+  const struct named_label_entry *ent = (const struct named_label_entry *) data;\n+  return DECL_UID (ent->label_decl);\n+}\n+\n+static int\n+named_label_entry_eq (const void *a, const void *b)\n+{\n+  const struct named_label_entry *ent_a = (const struct named_label_entry *) a;\n+  const struct named_label_entry *ent_b = (const struct named_label_entry *) b;\n+  return ent_a->label_decl == ent_b->label_decl;\n+}\n+\n /* Create a new label, named ID.  */\n \n static tree\n make_label_decl (tree id, int local_p)\n {\n+  struct named_label_entry *ent;\n+  void **slot;\n   tree decl;\n \n   decl = build_decl (LABEL_DECL, id, void_type_node);\n@@ -2090,30 +2184,22 @@ make_label_decl (tree id, int local_p)\n   /* Record the fact that this identifier is bound to this label.  */\n   SET_IDENTIFIER_LABEL_VALUE (id, decl);\n \n-  return decl;\n-}\n+  /* Create the label htab for the function on demand.  */\n+  if (!named_labels)\n+    named_labels = htab_create_ggc (13, named_label_entry_hash,\n+\t\t\t\t    named_label_entry_eq, NULL);\n \n-/* Record this label on the list of used labels so that we can check\n-   at the end of the function to see whether or not the label was\n-   actually defined, and so we can check when the label is defined whether\n-   this use is valid.  */\n+  /* Record this label on the list of labels used in this function.\n+     We do this before calling make_label_decl so that we get the\n+     IDENTIFIER_LABEL_VALUE before the new label is declared.  */\n+  ent = GGC_CNEW (struct named_label_entry);\n+  ent->label_decl = decl;\n \n-static void\n-use_label (tree decl)\n-{\n-  if (named_label_uses == NULL\n-      || named_label_uses->names_in_scope != current_binding_level->names\n-      || named_label_uses->label_decl != decl)\n-    {\n-      struct named_label_use_list *new_ent;\n-      new_ent = GGC_NEW (struct named_label_use_list);\n-      new_ent->label_decl = decl;\n-      new_ent->names_in_scope = current_binding_level->names;\n-      new_ent->binding_level = current_binding_level;\n-      new_ent->o_goto_locus = input_location;\n-      new_ent->next = named_label_uses;\n-      named_label_uses = new_ent;\n-    }\n+  slot = htab_find_slot (named_labels, ent, INSERT);\n+  gcc_assert (*slot == NULL);\n+  *slot = ent;\n+\n+  return decl;\n }\n \n /* Look for a label named ID in the current function.  If one cannot\n@@ -2124,7 +2210,6 @@ tree\n lookup_label (tree id)\n {\n   tree decl;\n-  struct named_label_list *ent;\n \n   timevar_push (TV_NAME_LOOKUP);\n   /* You can't use labels at global scope.  */\n@@ -2139,20 +2224,7 @@ lookup_label (tree id)\n   if (decl != NULL_TREE && DECL_CONTEXT (decl) == current_function_decl)\n     POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n \n-  /* Record this label on the list of labels used in this function.\n-     We do this before calling make_label_decl so that we get the\n-     IDENTIFIER_LABEL_VALUE before the new label is declared.  */\n-  ent = GGC_CNEW (struct named_label_list);\n-  ent->old_value = IDENTIFIER_LABEL_VALUE (id);\n-  ent->next = named_labels;\n-  named_labels = ent;\n-\n-  /* We need a new label.  */\n   decl = make_label_decl (id, /*local_p=*/0);\n-\n-  /* Now fill in the information we didn't have before.  */\n-  ent->label_decl = decl;\n-\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n }\n \n@@ -2161,18 +2233,16 @@ lookup_label (tree id)\n tree\n declare_local_label (tree id)\n {\n-  tree decl;\n+  tree decl, shadow;\n \n   /* Add a new entry to the SHADOWED_LABELS list so that when we leave\n-     this scope we can restore the old value of\n-     IDENTIFIER_TYPE_VALUE.  */\n-  current_binding_level->shadowed_labels\n-    = tree_cons (IDENTIFIER_LABEL_VALUE (id), NULL_TREE,\n-\t\t current_binding_level->shadowed_labels);\n-  /* Look for the label.  */\n+     this scope we can restore the old value of IDENTIFIER_TYPE_VALUE.  */\n+  shadow = tree_cons (IDENTIFIER_LABEL_VALUE (id), NULL_TREE,\n+\t\t      current_binding_level->shadowed_labels);\n+  current_binding_level->shadowed_labels = shadow;\n+\n   decl = make_label_decl (id, /*local_p=*/1);\n-  /* Now fill in the information we didn't have before.  */\n-  TREE_VALUE (current_binding_level->shadowed_labels) = decl;\n+  TREE_VALUE (shadow) = decl;\n \n   return decl;\n }\n@@ -2199,42 +2269,55 @@ decl_jump_unsafe (tree decl)\n   return 1;\n }\n \n+/* A subroutine of check_previous_goto_1 to identify a branch to the user.  */\n+\n+static void\n+identify_goto (tree decl, const location_t *locus)\n+{\n+  if (decl)\n+    pedwarn (\"jump to label %qD\", decl);\n+  else\n+    pedwarn (\"jump to case label\");\n+  if (locus)\n+    pedwarn (\"%H  from here\", locus);\n+}\n+\n /* Check that a single previously seen jump to a newly defined label\n    is OK.  DECL is the LABEL_DECL or 0; LEVEL is the binding_level for\n    the jump context; NAMES are the names in scope in LEVEL at the jump\n-   context; FILE and LINE are the source position of the jump or 0.  */\n+   context; LOCUS is the source position of the jump or 0.  Returns \n+   true if all is well.  */\n \n-static void\n-check_previous_goto_1 (tree decl,\n-\t\t       struct cp_binding_level* level,\n-\t\t       tree names, const location_t *locus)\n-{\n-  int identified = 0;\n-  int saw_eh = 0;\n-  struct cp_binding_level *b = current_binding_level;\n-  for (; b; b = b->level_chain)\n-    {\n-      tree new_decls = b->names;\n-      tree old_decls = (b == level ? names : NULL_TREE);\n-      for (; new_decls != old_decls;\n+static bool\n+check_previous_goto_1 (tree decl, struct cp_binding_level* level, tree names,\n+\t\t       bool exited_omp, const location_t *locus)\n+{\n+  struct cp_binding_level *b;\n+  bool identified = false, saw_eh = false, saw_omp = false;\n+\n+  if (exited_omp)\n+    {\n+      identify_goto (decl, locus);\n+      error (\"  exits OpenMP structured block\");\n+      identified = saw_omp = true;\n+    }\n+\n+  for (b = current_binding_level; b ; b = b->level_chain)\n+    {\n+      tree new_decls, old_decls = (b == level ? names : NULL_TREE);\n+\n+      for (new_decls = b->names; new_decls != old_decls;\n \t   new_decls = TREE_CHAIN (new_decls))\n \t{\n \t  int problem = decl_jump_unsafe (new_decls);\n \t  if (! problem)\n \t    continue;\n \n-\t  if (! identified)\n+\t  if (!identified)\n \t    {\n-\t      if (decl)\n-\t\tpedwarn (\"jump to label %qD\", decl);\n-\t      else\n-\t\tpedwarn (\"jump to case label\");\n-\n-\t      if (locus)\n-\t\tpedwarn (\"%H  from here\", locus);\n-\t      identified = 1;\n+\t      identify_goto (decl, locus);\n+\t      identified = true;\n \t    }\n-\n \t  if (problem > 1)\n \t    error (\"  crosses initialization of %q+#D\", new_decls);\n \t  else\n@@ -2243,63 +2326,46 @@ check_previous_goto_1 (tree decl,\n \n       if (b == level)\n \tbreak;\n-      if ((b->kind == sk_try || b->kind == sk_catch) && ! saw_eh)\n+      if ((b->kind == sk_try || b->kind == sk_catch) && !saw_eh)\n \t{\n-\t  if (! identified)\n+\t  if (!identified)\n \t    {\n-\t      if (decl)\n-\t\tpedwarn (\"jump to label %qD\", decl);\n-\t      else\n-\t\tpedwarn (\"jump to case label\");\n-\n-\t      if (locus)\n-\t\tpedwarn (\"%H  from here\", locus);\n-\t      identified = 1;\n+\t      identify_goto (decl, locus);\n+\t      identified = true;\n \t    }\n \t  if (b->kind == sk_try)\n \t    error (\"  enters try block\");\n \t  else\n \t    error (\"  enters catch block\");\n-\t  saw_eh = 1;\n+\t  saw_eh = true;\n+\t}\n+      if (b->kind == sk_omp && !saw_omp)\n+\t{\n+\t  if (!identified)\n+\t    {\n+\t      identify_goto (decl, locus);\n+\t      identified = true;\n+\t    }\n+\t  error (\"  enters OpenMP structured block\");\n+\t  saw_omp = true;\n \t}\n     }\n+\n+  return !identified;\n }\n \n static void\n-check_previous_goto (struct named_label_use_list* use)\n+check_previous_goto (tree decl, struct named_label_use_entry *use)\n {\n-  check_previous_goto_1 (use->label_decl, use->binding_level,\n-\t\t\t use->names_in_scope, &use->o_goto_locus);\n+  check_previous_goto_1 (decl, use->binding_level,\n+\t\t\t use->names_in_scope, use->in_omp_scope,\n+\t\t\t &use->o_goto_locus);\n }\n \n-static void\n+static bool\n check_switch_goto (struct cp_binding_level* level)\n {\n-  check_previous_goto_1 (NULL_TREE, level, level->names, NULL);\n-}\n-\n-/* Check that any previously seen jumps to a newly defined label DECL\n-   are OK.  Called by define_label.  */\n-\n-static void\n-check_previous_gotos (tree decl)\n-{\n-  struct named_label_use_list **usep;\n-\n-  if (! TREE_USED (decl))\n-    return;\n-\n-  for (usep = &named_label_uses; *usep; )\n-    {\n-      struct named_label_use_list *use = *usep;\n-      if (use->label_decl == decl)\n-\t{\n-\t  check_previous_goto (use);\n-\t  *usep = use->next;\n-\t}\n-      else\n-\tusep = &(use->next);\n-    }\n+  return check_previous_goto_1 (NULL_TREE, level, level->names, false, NULL);\n }\n \n /* Check that a new jump to a label DECL is OK.  Called by\n@@ -2308,57 +2374,114 @@ check_previous_gotos (tree decl)\n void\n check_goto (tree decl)\n {\n-  int identified = 0;\n+  struct named_label_entry *ent, dummy;\n+  bool saw_catch = false, identified = false;\n   tree bad;\n-  struct named_label_list *lab;\n \n-  /* We can't know where a computed goto is jumping.  So we assume\n-     that it's OK.  */\n-  if (! DECL_P (decl))\n+  /* We can't know where a computed goto is jumping.\n+     So we assume that it's OK.  */\n+  if (TREE_CODE (decl) != LABEL_DECL)\n+    return;\n+\n+  /* We didn't record any information about this label when we created it,\n+     and there's not much point since it's trivial to analyze as a return.  */\n+  if (decl == cdtor_label)\n     return;\n \n+  dummy.label_decl = decl;\n+  ent = (struct named_label_entry *) htab_find (named_labels, &dummy);\n+  gcc_assert (ent != NULL);\n+\n   /* If the label hasn't been defined yet, defer checking.  */\n   if (! DECL_INITIAL (decl))\n     {\n-      use_label (decl);\n-      return;\n-    }\n+      struct named_label_use_entry *new_use;\n \n-  for (lab = named_labels; lab; lab = lab->next)\n-    if (decl == lab->label_decl)\n-      break;\n+      /* Don't bother creating another use if the last goto had the\n+\t same data, and will therefore create the same set of errors.  */\n+      if (ent->uses\n+\t  && ent->uses->names_in_scope == current_binding_level->names)\n+\treturn;\n \n-  /* If the label is not on named_labels it's a gcc local label, so\n-     it must be in an outer scope, so jumping to it is always OK.  */\n-  if (lab == 0)\n-    return;\n+      new_use = GGC_NEW (struct named_label_use_entry);\n+      new_use->binding_level = current_binding_level;\n+      new_use->names_in_scope = current_binding_level->names;\n+      new_use->o_goto_locus = input_location;\n+      new_use->in_omp_scope = false;\n \n-  if ((lab->in_try_scope || lab->in_catch_scope || lab->bad_decls)\n-      && !identified)\n+      new_use->next = ent->uses;\n+      ent->uses = new_use;\n+      return;\n+    }\n+\n+  if (ent->in_try_scope || ent->in_catch_scope\n+      || ent->in_omp_scope || ent->bad_decls)\n     {\n       pedwarn (\"jump to label %q+D\", decl);\n       pedwarn (\"  from here\");\n-      identified = 1;\n+      identified = true;\n     }\n \n-  for (bad = lab->bad_decls; bad; bad = TREE_CHAIN (bad))\n+  for (bad = ent->bad_decls; bad; bad = TREE_CHAIN (bad))\n     {\n       tree b = TREE_VALUE (bad);\n       int u = decl_jump_unsafe (b);\n \n       if (u > 1 && DECL_ARTIFICIAL (b))\n-\t/* Can't skip init of __exception_info.  */\n-\terror (\"%J  enters catch block\", b);\n+\t{\n+\t  /* Can't skip init of __exception_info.  */\n+\t  error (\"%J  enters catch block\", b);\n+\t  saw_catch = true;\n+\t}\n       else if (u > 1)\n \terror (\"  skips initialization of %q+#D\", b);\n       else\n \tpedwarn (\"  enters scope of non-POD %q+#D\", b);\n     }\n \n-  if (lab->in_try_scope)\n+  if (ent->in_try_scope)\n     error (\"  enters try block\");\n-  else if (lab->in_catch_scope)\n+  else if (ent->in_catch_scope && !saw_catch)\n     error (\"  enters catch block\");\n+\n+  if (ent->in_omp_scope)\n+    error (\"  enters OpenMP structured block\");\n+  else if (flag_openmp)\n+    {\n+      struct cp_binding_level *b;\n+      for (b = current_binding_level; b ; b = b->level_chain)\n+\t{\n+\t  if (b == ent->binding_level)\n+\t    break;\n+\t  if (b->kind == sk_omp)\n+\t    {\n+\t      if (!identified)\n+\t\t{\n+\t\t  pedwarn (\"jump to label %q+D\", decl);\n+\t\t  pedwarn (\"  from here\");\n+\t\t  identified = true;\n+\t\t}\n+\t      error (\"  exits OpenMP structured block\");\n+\t      break;\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Check that a return is ok wrt OpenMP structured blocks.\n+   Called by finish_return_stmt.  Returns true if all is well.  */\n+\n+bool\n+check_omp_return (void)\n+{\n+  struct cp_binding_level *b;\n+  for (b = current_binding_level; b ; b = b->level_chain)\n+    if (b->kind == sk_omp)\n+      {\n+\terror (\"invalid exit from OpenMP structured block\");\n+\treturn false;\n+      }\n+  return true;\n }\n \n /* Define a label, specifying the location in the source file.\n@@ -2367,14 +2490,17 @@ check_goto (tree decl)\n tree\n define_label (location_t location, tree name)\n {\n-  tree decl = lookup_label (name);\n-  struct named_label_list *ent;\n+  struct named_label_entry *ent, dummy;\n   struct cp_binding_level *p;\n+  tree decl;\n \n   timevar_push (TV_NAME_LOOKUP);\n-  for (ent = named_labels; ent; ent = ent->next)\n-    if (ent->label_decl == decl)\n-      break;\n+\n+  decl = lookup_label (name);\n+\n+  dummy.label_decl = decl;\n+  ent = (struct named_label_entry *) htab_find (named_labels, &dummy);\n+  gcc_assert (ent != NULL);\n \n   /* After labels, make any new cleanups in the function go into their\n      own new (temporary) binding contour.  */\n@@ -2390,16 +2516,19 @@ define_label (location_t location, tree name)\n     error (\"duplicate label %qD\", decl);\n   else\n     {\n+      struct named_label_use_entry *use;\n+\n       /* Mark label as having been defined.  */\n       DECL_INITIAL (decl) = error_mark_node;\n       /* Say where in the source.  */\n       DECL_SOURCE_LOCATION (decl) = location;\n-      if (ent)\n-\t{\n-\t  ent->names_in_scope = current_binding_level->names;\n-\t  ent->binding_level = current_binding_level;\n-\t}\n-      check_previous_gotos (decl);\n+\n+      ent->binding_level = current_binding_level;\n+      ent->names_in_scope = current_binding_level->names;\n+\n+      for (use = ent->uses; use ; use = use->next)\n+\tcheck_previous_goto (decl, use);\n+      ent->uses = NULL;\n     }\n \n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n@@ -2486,11 +2615,12 @@ finish_case_label (tree low_value, tree high_value)\n   if (cond && TREE_CODE (cond) == TREE_LIST)\n     cond = TREE_VALUE (cond);\n \n+  if (!check_switch_goto (switch_stack->level))\n+    return error_mark_node;\n+\n   r = c_add_case_label (switch_stack->cases, cond, TREE_TYPE (cond),\n \t\t\tlow_value, high_value);\n \n-  check_switch_goto (switch_stack->level);\n-\n   /* After labels, make any new cleanups in the function go into their\n      own new (temporary) binding contour.  */\n   for (p = current_binding_level;\n@@ -10589,7 +10719,6 @@ save_function_data (tree decl)\n \n   /* Clear out the bits we don't need.  */\n   f->base.x_stmt_tree.x_cur_stmt_list = NULL_TREE;\n-  f->x_named_label_uses = NULL;\n   f->bindings = NULL;\n   f->x_local_names = NULL;\n }\n@@ -10955,7 +11084,6 @@ finish_function (int flags)\n     }\n   /* Clear out the bits we don't need.  */\n   local_names = NULL;\n-  named_label_uses = NULL;\n \n   /* We're leaving the context of this function, so zap cfun.  It's still in\n      DECL_STRUCT_FUNCTION, and we'll restore it in tree_rest_of_compilation.  */"}, {"sha": "ebf8a3365ed8313ccde1dbc800f7a6134bdb8852", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -1278,6 +1278,7 @@ begin_scope (scope_kind kind, tree entity)\n     case sk_for:\n     case sk_class:\n     case sk_function_parms:\n+    case sk_omp:\n       scope->keep = keep_next_level_flag;\n       break;\n "}, {"sha": "20c82255a4dee7b6cc3db91ab8e9b83818ae84d5", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -106,7 +106,7 @@ typedef enum scope_kind {\n \t\t\tcontents to zero, and the default scope kind\n \t\t\tis \"sk_block\".  */\n   sk_cleanup,\t     /* A scope for (pseudo-)scope for cleanup.  It is\n-\t\t\tpeusdo in that it is transparent to name lookup\n+\t\t\tpseudo in that it is transparent to name lookup\n \t\t\tactivities.  */\n   sk_try,\t     /* A try-block.  */\n   sk_catch,\t     /* A catch-block.  */\n@@ -117,10 +117,11 @@ typedef enum scope_kind {\n   sk_namespace,\t     /* The scope containing the members of a\n \t\t\tnamespace, including the global scope.  */\n   sk_template_parms, /* A scope for template parameters.  */\n-  sk_template_spec   /* Like sk_template_parms, but for an explicit\n+  sk_template_spec,  /* Like sk_template_parms, but for an explicit\n \t\t\tspecialization.  Since, by definition, an\n \t\t\texplicit specialization is introduced by\n \t\t\t\"template <>\", this scope is always empty.  */\n+  sk_omp             /* An OpenMP structured block.  */\n } scope_kind;\n \n /* The scope where the class/struct/union/enum tag applies.  */"}, {"sha": "b5c7fc011a5bae964715623865db1ffeb4142e76", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1357, "deletions": 71, "changes": 1428, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -1293,12 +1293,21 @@ typedef struct cp_parser GTY(())\n   /* TRUE if we are presently parsing a template-argument-list.  */\n   bool in_template_argument_list_p;\n \n-  /* TRUE if we are presently parsing the body of an\n-     iteration-statement.  */\n-  bool in_iteration_statement_p;\n-\n-  /* TRUE if we are presently parsing the body of a switch\n-     statement.  */\n+  /* Set to IN_ITERATION_STMT if parsing an iteration-statement,\n+     to IN_OMP_BLOCK if parsing OpenMP structured block and\n+     IN_OMP_FOR if parsing OpenMP loop.  If parsing a switch statement,\n+     this is bitwise ORed with IN_SWITCH_STMT, unless parsing an\n+     iteration-statement, OpenMP block or loop within that switch.  */\n+#define IN_SWITCH_STMT\t\t1\n+#define IN_ITERATION_STMT\t2\n+#define IN_OMP_BLOCK\t\t4\n+#define IN_OMP_FOR\t\t8\n+  unsigned char in_statement;\n+\n+  /* TRUE if we are presently parsing the body of a switch statement.\n+     Note that this doesn't quite overlap with in_statement above.\n+     The difference relates to giving the right sets of error messages:\n+     \"case not in switch\" vs \"break statement used with OpenMP...\".  */\n   bool in_switch_statement_p;\n \n   /* TRUE if we are parsing a type-id in an expression context.  In\n@@ -2420,6 +2429,17 @@ cp_parser_skip_to_pragma_eol (cp_parser* parser, cp_token *pragma_tok)\n   cp_lexer_purge_tokens_after (parser->lexer, pragma_tok);\n }\n \n+/* Require pragma end of line, resyncing with it as necessary.  The\n+   arguments are as for cp_parser_skip_to_pragma_eol.  */\n+\n+static void\n+cp_parser_require_pragma_eol (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  parser->lexer->in_pragma = false;\n+  if (!cp_parser_require (parser, CPP_PRAGMA_EOL, \"end of line\"))\n+    cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+}\n+\n /* This is a simple wrapper around make_typename_type. When the id is\n    an unresolved identifier node, we can provide a superior diagnostic\n    using cp_parser_diagnose_invalid_type_name.  */\n@@ -2489,7 +2509,7 @@ cp_parser_new (void)\n   parser->in_template_argument_list_p = false;\n \n   /* We are not in an iteration statement.  */\n-  parser->in_iteration_statement_p = false;\n+  parser->in_statement = 0;\n \n   /* We are not in a switch statement.  */\n   parser->in_switch_statement_p = false;\n@@ -6413,15 +6433,19 @@ cp_parser_selection_statement (cp_parser* parser)\n \telse\n \t  {\n \t    bool in_switch_statement_p;\n+\t    unsigned char in_statement;\n \n \t    /* Add the condition.  */\n \t    finish_switch_cond (condition, statement);\n \n \t    /* Parse the body of the switch-statement.  */\n \t    in_switch_statement_p = parser->in_switch_statement_p;\n+\t    in_statement = parser->in_statement;\n \t    parser->in_switch_statement_p = true;\n+\t    parser->in_statement |= IN_SWITCH_STMT;\n \t    cp_parser_implicitly_scoped_statement (parser);\n \t    parser->in_switch_statement_p = in_switch_statement_p;\n+\t    parser->in_statement = in_statement;\n \n \t    /* Now we're all done with the switch-statement.  */\n \t    finish_switch_stmt (statement);\n@@ -6552,8 +6576,7 @@ cp_parser_iteration_statement (cp_parser* parser)\n   cp_token *token;\n   enum rid keyword;\n   tree statement;\n-  bool in_iteration_statement_p;\n-\n+  unsigned char in_statement;\n \n   /* Peek at the next token.  */\n   token = cp_parser_require (parser, CPP_KEYWORD, \"iteration-statement\");\n@@ -6562,7 +6585,7 @@ cp_parser_iteration_statement (cp_parser* parser)\n \n   /* Remember whether or not we are already within an iteration\n      statement.  */\n-  in_iteration_statement_p = parser->in_iteration_statement_p;\n+  in_statement = parser->in_statement;\n \n   /* See what kind of keyword it is.  */\n   keyword = token->keyword;\n@@ -6582,9 +6605,9 @@ cp_parser_iteration_statement (cp_parser* parser)\n \t/* Look for the `)'.  */\n \tcp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n \t/* Parse the dependent statement.  */\n-\tparser->in_iteration_statement_p = true;\n+\tparser->in_statement = IN_ITERATION_STMT;\n \tcp_parser_already_scoped_statement (parser);\n-\tparser->in_iteration_statement_p = in_iteration_statement_p;\n+\tparser->in_statement = in_statement;\n \t/* We're done with the while-statement.  */\n \tfinish_while_stmt (statement);\n       }\n@@ -6597,9 +6620,9 @@ cp_parser_iteration_statement (cp_parser* parser)\n \t/* Begin the do-statement.  */\n \tstatement = begin_do_stmt ();\n \t/* Parse the body of the do-statement.  */\n-\tparser->in_iteration_statement_p = true;\n+\tparser->in_statement = IN_ITERATION_STMT;\n \tcp_parser_implicitly_scoped_statement (parser);\n-\tparser->in_iteration_statement_p = in_iteration_statement_p;\n+\tparser->in_statement = in_statement;\n \tfinish_do_body (statement);\n \t/* Look for the `while' keyword.  */\n \tcp_parser_require_keyword (parser, RID_WHILE, \"`while'\");\n@@ -6644,9 +6667,9 @@ cp_parser_iteration_statement (cp_parser* parser)\n \tcp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n \n \t/* Parse the body of the for-statement.  */\n-\tparser->in_iteration_statement_p = true;\n+\tparser->in_statement = IN_ITERATION_STMT;\n \tcp_parser_already_scoped_statement (parser);\n-\tparser->in_iteration_statement_p = in_iteration_statement_p;\n+\tparser->in_statement = in_statement;\n \n \t/* We're done with the for-statement.  */\n \tfinish_for_stmt (statement);\n@@ -6726,25 +6749,42 @@ cp_parser_jump_statement (cp_parser* parser)\n   switch (keyword)\n     {\n     case RID_BREAK:\n-      if (!parser->in_switch_statement_p\n-\t  && !parser->in_iteration_statement_p)\n+      switch (parser->in_statement)\n \t{\n+\tcase 0:\n \t  error (\"break statement not within loop or switch\");\n-\t  statement = error_mark_node;\n+\t  break;\n+\tdefault:\n+\t  gcc_assert ((parser->in_statement & IN_SWITCH_STMT)\n+\t\t      || parser->in_statement == IN_ITERATION_STMT);\n+\t  statement = finish_break_stmt ();\n+\t  break;\n+\tcase IN_OMP_BLOCK:\n+\t  error (\"invalid exit from OpenMP structured block\");\n+\t  break;\n+\tcase IN_OMP_FOR:\n+\t  error (\"break statement used with OpenMP for loop\");\n+\t  break;\n \t}\n-      else\n-\tstatement = finish_break_stmt ();\n       cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n       break;\n \n     case RID_CONTINUE:\n-      if (!parser->in_iteration_statement_p)\n+      switch (parser->in_statement & ~IN_SWITCH_STMT)\n \t{\n+\tcase 0:\n \t  error (\"continue statement not within a loop\");\n-\t  statement = error_mark_node;\n+\t  break;\n+\tcase IN_ITERATION_STMT:\n+\tcase IN_OMP_FOR:\n+\t  statement = finish_continue_stmt ();\n+\t  break;\n+\tcase IN_OMP_BLOCK:\n+\t  error (\"invalid exit from OpenMP structured block\");\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n-      else\n-\tstatement = finish_continue_stmt ();\n       cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n       break;\n \n@@ -17590,76 +17630,1322 @@ cp_parser_objc_statement (cp_parser * parser) {\n \n   return error_mark_node;\n }\n-/* The parser.  */\n+\f\n+/* OpenMP 2.5 parsing routines.  */\n+\n+/* All OpenMP clauses.  OpenMP 2.5.  */\n+typedef enum pragma_omp_clause {\n+  PRAGMA_OMP_CLAUSE_NONE = 0,\n+\n+  PRAGMA_OMP_CLAUSE_COPYIN,\n+  PRAGMA_OMP_CLAUSE_COPYPRIVATE,\n+  PRAGMA_OMP_CLAUSE_DEFAULT,\n+  PRAGMA_OMP_CLAUSE_FIRSTPRIVATE,\n+  PRAGMA_OMP_CLAUSE_IF,\n+  PRAGMA_OMP_CLAUSE_LASTPRIVATE,\n+  PRAGMA_OMP_CLAUSE_NOWAIT,\n+  PRAGMA_OMP_CLAUSE_NUM_THREADS,\n+  PRAGMA_OMP_CLAUSE_ORDERED,\n+  PRAGMA_OMP_CLAUSE_PRIVATE,\n+  PRAGMA_OMP_CLAUSE_REDUCTION,\n+  PRAGMA_OMP_CLAUSE_SCHEDULE,\n+  PRAGMA_OMP_CLAUSE_SHARED\n+} pragma_omp_clause;\n+\n+/* Returns name of the next clause.\n+   If the clause is not recognized PRAGMA_OMP_CLAUSE_NONE is returned and\n+   the token is not consumed.  Otherwise appropriate pragma_omp_clause is\n+   returned and the token is consumed.  */\n+\n+static pragma_omp_clause\n+cp_parser_omp_clause_name (cp_parser *parser)\n+{\n+  pragma_omp_clause result = PRAGMA_OMP_CLAUSE_NONE;\n+\n+  if (cp_lexer_next_token_is_keyword (parser->lexer, RID_IF))\n+    result = PRAGMA_OMP_CLAUSE_IF;\n+  else if (cp_lexer_next_token_is_keyword (parser->lexer, RID_DEFAULT))\n+    result = PRAGMA_OMP_CLAUSE_DEFAULT;\n+  else if (cp_lexer_next_token_is_keyword (parser->lexer, RID_PRIVATE))\n+    result = PRAGMA_OMP_CLAUSE_PRIVATE;\n+  else if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+    {\n+      tree id = cp_lexer_peek_token (parser->lexer)->value;\n+      const char *p = IDENTIFIER_POINTER (id);\n+\n+      switch (p[0])\n+\t{\n+\tcase 'c':\n+\t  if (!strcmp (\"copyin\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_COPYIN;\n+          else if (!strcmp (\"copyprivate\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_COPYPRIVATE;\n+\t  break;\n+\tcase 'f':\n+\t  if (!strcmp (\"firstprivate\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_FIRSTPRIVATE;\n+\t  break;\n+\tcase 'l':\n+\t  if (!strcmp (\"lastprivate\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_LASTPRIVATE;\n+\t  break;\n+\tcase 'n':\n+\t  if (!strcmp (\"nowait\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_NOWAIT;\n+\t  else if (!strcmp (\"num_threads\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_NUM_THREADS;\n+\t  break;\n+\tcase 'o':\n+\t  if (!strcmp (\"ordered\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_ORDERED;\n+\t  break;\n+\tcase 'r':\n+\t  if (!strcmp (\"reduction\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_REDUCTION;\n+\t  break;\n+\tcase 's':\n+\t  if (!strcmp (\"schedule\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_SCHEDULE;\n+\t  else if (!strcmp (\"shared\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_SHARED;\n+\t  break;\n+\t}\n+    }\n \n-static GTY (()) cp_parser *the_parser;\n+  if (result != PRAGMA_OMP_CLAUSE_NONE)\n+    cp_lexer_consume_token (parser->lexer);\n \n-\f\n-/* Special handling for the first token or line in the file.  The first\n-   thing in the file might be #pragma GCC pch_preprocess, which loads a\n-   PCH file, which is a GC collection point.  So we need to handle this\n-   first pragma without benefit of an existing lexer structure.\n+  return result;\n+}\n \n-   Always returns one token to the caller in *FIRST_TOKEN.  This is \n-   either the true first token of the file, or the first token after\n-   the initial pragma.  */\n+/* Validate that a clause of the given type does not already exist.  */\n \n static void\n-cp_parser_initial_pragma (cp_token *first_token)\n+check_no_duplicate_clause (tree clauses, enum tree_code code, const char *name)\n {\n-  tree name = NULL;\n+  tree c;\n \n-  cp_lexer_get_preprocessor_token (NULL, first_token);\n-  if (first_token->pragma_kind != PRAGMA_GCC_PCH_PREPROCESS)\n-    return;\n+  for (c = clauses; c ; c = OMP_CLAUSE_CHAIN (c))\n+    if (OMP_CLAUSE_CODE (c) == code)\n+      {\n+\terror (\"too many %qs clauses\", name);\n+\tbreak;\n+      }\n+}\n \n-  cp_lexer_get_preprocessor_token (NULL, first_token);\n-  if (first_token->type == CPP_STRING)\n+/* OpenMP 2.5:\n+   variable-list:\n+     identifier\n+     variable-list , identifier\n+\n+   In addition, we match a closing parenthesis.  An opening parenthesis\n+   will have been consumed by the caller.\n+\n+   If KIND is nonzero, create the appropriate node and install the decl\n+   in OMP_CLAUSE_DECL and add the node to the head of the list.\n+\n+   If KIND is zero, create a TREE_LIST with the decl in TREE_PURPOSE;\n+   return the list created.  */\n+\n+static tree\n+cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n+\t\t\t\ttree list)\n+{\n+  while (1)\n     {\n-      name = first_token->value;\n+      tree name, decl;\n \n-      cp_lexer_get_preprocessor_token (NULL, first_token);\n-      if (first_token->type != CPP_PRAGMA_EOL)\n-\terror (\"junk at end of %<#pragma GCC pch_preprocess%>\");\n+      name = cp_parser_id_expression (parser, /*template_p=*/false,\n+\t\t\t\t      /*check_dependency_p=*/true,\n+\t\t\t\t      /*template_p=*/NULL,\n+\t\t\t\t      /*declarator_p=*/false);\n+      if (name == error_mark_node)\n+\tgoto skip_comma;\n+\n+      decl = cp_parser_lookup_name_simple (parser, name);\n+      if (decl == error_mark_node)\n+\tcp_parser_name_lookup_error (parser, name, decl, NULL);\n+      else if (kind != 0)\n+\t{\n+\t  tree u = build_omp_clause (kind);\n+\t  OMP_CLAUSE_DECL (u) = decl;\n+\t  OMP_CLAUSE_CHAIN (u) = list;\n+\t  list = u;\n+\t}\n+      else\n+\tlist = tree_cons (decl, NULL_TREE, list);\n+\n+    get_comma:\n+      if (cp_lexer_next_token_is_not (parser->lexer, CPP_COMMA))\n+\tbreak;\n+      cp_lexer_consume_token (parser->lexer);\n+    }\n+\n+  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n+    {\n+      int ending;\n+\n+      /* Try to resync to an unnested comma.  Copied from\n+\t cp_parser_parenthesized_expression_list.  */\n+    skip_comma:\n+      ending = cp_parser_skip_to_closing_parenthesis (parser,\n+\t\t\t\t\t\t      /*recovering=*/true,\n+\t\t\t\t\t\t      /*or_comma=*/true,\n+\t\t\t\t\t\t      /*consume_paren=*/true);\n+      if (ending < 0)\n+\tgoto get_comma;\n+    }\n+\n+  return list;\n+}\n+\n+/* Similarly, but expect leading and trailing parenthesis.  This is a very\n+   common case for omp clauses.  */\n+\n+static tree\n+cp_parser_omp_var_list (cp_parser *parser, enum omp_clause_code kind, tree list)\n+{\n+  if (cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\"))\n+    return cp_parser_omp_var_list_no_open (parser, kind, list);\n+  return list;\n+}\n+\n+/* OpenMP 2.5:\n+   default ( shared | none ) */\n+\n+static tree\n+cp_parser_omp_clause_default (cp_parser *parser, tree list)\n+{\n+  enum omp_clause_default_kind kind = OMP_CLAUSE_DEFAULT_UNSPECIFIED;\n+  tree c;\n+\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\"))\n+    return list;\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+    {\n+      tree id = cp_lexer_peek_token (parser->lexer)->value;\n+      const char *p = IDENTIFIER_POINTER (id);\n+\n+      switch (p[0])\n+\t{\n+\tcase 'n':\n+\t  if (strcmp (\"none\", p) != 0)\n+\t    goto invalid_kind;\n+\t  kind = OMP_CLAUSE_DEFAULT_NONE;\n+\t  break;\n+\n+\tcase 's':\n+\t  if (strcmp (\"shared\", p) != 0)\n+\t    goto invalid_kind;\n+\t  kind = OMP_CLAUSE_DEFAULT_SHARED;\n+\t  break;\n+\n+\tdefault:\n+\t  goto invalid_kind;\n+\t}\n+\n+      cp_lexer_consume_token (parser->lexer);\n     }\n   else\n-    error (\"expected string literal\");\n+    {\n+    invalid_kind:\n+      cp_parser_error (parser, \"expected %<none%> or %<shared%>\");\n+    }\n \n-  /* Skip to the end of the pragma.  */\n-  while (first_token->type != CPP_PRAGMA_EOL && first_token->type != CPP_EOF)\n-    cp_lexer_get_preprocessor_token (NULL, first_token);\n+  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n+    cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n+\t\t\t\t\t   /*or_comma=*/false,\n+\t\t\t\t\t   /*consume_paren=*/true);\n+  \n+  if (kind == OMP_CLAUSE_DEFAULT_UNSPECIFIED)\n+    return list;\n \n-  /* Read one more token to return to our caller.  */\n-  cp_lexer_get_preprocessor_token (NULL, first_token);\n+  check_no_duplicate_clause (list, OMP_CLAUSE_DEFAULT, \"default\");\n+  c = build_omp_clause (OMP_CLAUSE_DEFAULT);\n+  OMP_CLAUSE_CHAIN (c) = list;\n+  OMP_CLAUSE_DEFAULT_KIND (c) = kind;\n \n-  /* Now actually load the PCH file.  */\n-  if (name)\n-    c_common_pch_pragma (parse_in, TREE_STRING_POINTER (name));\n+  return c;\n }\n \n-/* Normal parsing of a pragma token.  Here we can (and must) use the\n-   regular lexer.  */\n+/* OpenMP 2.5:\n+   if ( expression ) */\n \n-static bool\n-cp_parser_pragma (cp_parser *parser, enum pragma_context context ATTRIBUTE_UNUSED)\n+static tree\n+cp_parser_omp_clause_if (cp_parser *parser, tree list)\n {\n-  cp_token *pragma_tok;\n-  unsigned int id;\n+  tree t, c;\n \n-  pragma_tok = cp_lexer_consume_token (parser->lexer);\n-  gcc_assert (pragma_tok->type == CPP_PRAGMA);\n-  parser->lexer->in_pragma = true;\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\"))\n+    return list;\n \n-  id = pragma_tok->pragma_kind;\n-  switch (id)\n+  t = cp_parser_condition (parser);\n+\n+  if (t == error_mark_node\n+      || !cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n+    cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n+\t\t\t\t\t   /*or_comma=*/false,\n+\t\t\t\t\t   /*consume_paren=*/true);\n+\n+  check_no_duplicate_clause (list, OMP_CLAUSE_IF, \"if\");\n+\n+  c = build_omp_clause (OMP_CLAUSE_IF);\n+  OMP_CLAUSE_IF_EXPR (c) = t;\n+  OMP_CLAUSE_CHAIN (c) = list;\n+\n+  return c;\n+}\n+\n+/* OpenMP 2.5:\n+   nowait */\n+\n+static tree\n+cp_parser_omp_clause_nowait (cp_parser *parser ATTRIBUTE_UNUSED, tree list)\n+{\n+  tree c;\n+\n+  check_no_duplicate_clause (list, OMP_CLAUSE_NOWAIT, \"nowait\");\n+\n+  c = build_omp_clause (OMP_CLAUSE_NOWAIT);\n+  OMP_CLAUSE_CHAIN (c) = list;\n+  return c;\n+}\n+\n+/* OpenMP 2.5:\n+   num_threads ( expression ) */\n+\n+static tree\n+cp_parser_omp_clause_num_threads (cp_parser *parser, tree list)\n+{\n+  tree t, c;\n+\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\"))\n+    return list;\n+\n+  t = cp_parser_expression (parser, false);\n+\n+  if (t == error_mark_node\n+      || !cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n+    cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n+\t\t\t\t\t   /*or_comma=*/false,\n+\t\t\t\t\t   /*consume_paren=*/true);\n+\n+  check_no_duplicate_clause (list, OMP_CLAUSE_NUM_THREADS, \"num_threads\");\n+\n+  c = build_omp_clause (OMP_CLAUSE_NUM_THREADS);\n+  OMP_CLAUSE_NUM_THREADS_EXPR (c) = t;\n+  OMP_CLAUSE_CHAIN (c) = list;\n+\n+  return c;\n+}\n+\n+/* OpenMP 2.5:\n+   ordered */\n+\n+static tree\n+cp_parser_omp_clause_ordered (cp_parser *parser ATTRIBUTE_UNUSED, tree list)\n+{\n+  tree c;\n+\n+  check_no_duplicate_clause (list, OMP_CLAUSE_ORDERED, \"ordered\");\n+\n+  c = build_omp_clause (OMP_CLAUSE_ORDERED);\n+  OMP_CLAUSE_CHAIN (c) = list;\n+  return c;\n+}\n+\n+/* OpenMP 2.5:\n+   reduction ( reduction-operator : variable-list )\n+\n+   reduction-operator:\n+     One of: + * - & ^ | && || */\n+\n+static tree\n+cp_parser_omp_clause_reduction (cp_parser *parser, tree list)\n+{\n+  enum tree_code code;\n+  tree nlist, c;\n+\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\"))\n+    return list;\n+\n+  switch (cp_lexer_peek_token (parser->lexer)->type)\n     {\n-    case PRAGMA_GCC_PCH_PREPROCESS:\n-      error (\"%<#pragma GCC pch_preprocess%> must be first\");\n+    case CPP_PLUS:\n+      code = PLUS_EXPR;\n+      break;\n+    case CPP_MULT:\n+      code = MULT_EXPR;\n+      break;\n+    case CPP_MINUS:\n+      code = MINUS_EXPR;\n+      break;\n+    case CPP_AND:\n+      code = BIT_AND_EXPR;\n+      break;\n+    case CPP_XOR:\n+      code = BIT_XOR_EXPR;\n+      break;\n+    case CPP_OR:\n+      code = BIT_IOR_EXPR;\n+      break;\n+    case CPP_AND_AND:\n+      code = TRUTH_ANDIF_EXPR;\n+      break;\n+    case CPP_OR_OR:\n+      code = TRUTH_ORIF_EXPR;\n       break;\n-\n     default:\n-      gcc_assert (id >= PRAGMA_FIRST_EXTERNAL);\n-      c_invoke_pragma_handler (id);\n+      cp_parser_error (parser, \"`+', `*', `-', `&', `^', `|', `&&', or `||'\");\n+    resync_fail:\n+      cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n+\t\t\t\t\t     /*or_comma=*/false,\n+\t\t\t\t\t     /*consume_paren=*/true);\n+      return list;\n+    }\n+  cp_lexer_consume_token (parser->lexer);\n+\n+  if (!cp_parser_require (parser, CPP_COLON, \"`:'\"))\n+    goto resync_fail;\n+\n+  nlist = cp_parser_omp_var_list_no_open (parser, OMP_CLAUSE_REDUCTION, list);\n+  for (c = nlist; c != list; c = OMP_CLAUSE_CHAIN (c))\n+    OMP_CLAUSE_REDUCTION_CODE (c) = code;\n+\n+  return nlist;\n+}\n+\n+/* OpenMP 2.5:\n+   schedule ( schedule-kind )\n+   schedule ( schedule-kind , expression )\n+\n+   schedule-kind:\n+     static | dynamic | guided | runtime\n+*/\n+\n+static tree\n+cp_parser_omp_clause_schedule (cp_parser *parser, tree list)\n+{\n+  tree c, t;\n+\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+    return list;\n+\n+  c = build_omp_clause (OMP_CLAUSE_SCHEDULE);\n+\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+    {\n+      tree id = cp_lexer_peek_token (parser->lexer)->value;\n+      const char *p = IDENTIFIER_POINTER (id);\n+\n+      switch (p[0])\n+\t{\n+\tcase 'd':\n+\t  if (strcmp (\"dynamic\", p) != 0)\n+\t    goto invalid_kind;\n+\t  OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_DYNAMIC;\n+\t  break;\n+\n+        case 'g':\n+\t  if (strcmp (\"guided\", p) != 0)\n+\t    goto invalid_kind;\n+\t  OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_GUIDED;\n+\t  break;\n+\n+\tcase 'r':\n+\t  if (strcmp (\"runtime\", p) != 0)\n+\t    goto invalid_kind;\n+\t  OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_RUNTIME;\n+\t  break;\n+\n+\tdefault:\n+\t  goto invalid_kind;\n+\t}\n+    }\n+  else if (cp_lexer_next_token_is_keyword (parser->lexer, RID_STATIC))\n+    OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_STATIC;\n+  else\n+    goto invalid_kind;\n+  cp_lexer_consume_token (parser->lexer);\n+\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+\n+      t = cp_parser_assignment_expression (parser, false);\n+\n+      if (t == error_mark_node)\n+\tgoto resync_fail;\n+      else if (OMP_CLAUSE_SCHEDULE_KIND (c) == OMP_CLAUSE_SCHEDULE_RUNTIME)\n+\terror (\"schedule %<runtime%> does not take \"\n+\t       \"a %<chunk_size%> parameter\");\n+      else\n+\tOMP_CLAUSE_SCHEDULE_CHUNK_EXPR (c) = t;\n+\n+      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n+\tgoto resync_fail;\n+    }\n+  else if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"`,' or `)'\"))\n+    goto resync_fail;\n+\n+  check_no_duplicate_clause (list, OMP_CLAUSE_SCHEDULE, \"schedule\");\n+  OMP_CLAUSE_CHAIN (c) = list;\n+  return c;\n+\n+ invalid_kind:\n+  cp_parser_error (parser, \"invalid schedule kind\");\n+ resync_fail:\n+  cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n+\t\t\t\t\t /*or_comma=*/false,\n+\t\t\t\t\t /*consume_paren=*/true);\n+  return list;\n+}\n+\n+/* Parse all OpenMP clauses.  The set clauses allowed by the directive\n+   is a bitmask in MASK.  Return the list of clauses found; the result\n+   of clause default goes in *pdefault.  */\n+\n+static tree\n+cp_parser_omp_all_clauses (cp_parser *parser, unsigned int mask,\n+\t\t\t   const char *where, cp_token *pragma_tok)\n+{\n+  tree clauses = NULL;\n+\n+  while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL))\n+    {\n+      pragma_omp_clause c_kind = cp_parser_omp_clause_name (parser);\n+      const char *c_name;\n+      tree prev = clauses;\n+\n+      switch (c_kind)\n+\t{\n+\tcase PRAGMA_OMP_CLAUSE_COPYIN:\n+\t  clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_COPYIN, clauses);\n+\t  c_name = \"copyin\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_COPYPRIVATE:\n+\t  clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_COPYPRIVATE,\n+\t\t\t\t\t    clauses);\n+\t  c_name = \"copyprivate\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_DEFAULT:\n+\t  clauses = cp_parser_omp_clause_default (parser, clauses);\n+\t  c_name = \"default\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_FIRSTPRIVATE:\n+\t  clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_FIRSTPRIVATE,\n+\t\t\t\t\t    clauses);\n+\t  c_name = \"firstprivate\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_IF:\n+\t  clauses = cp_parser_omp_clause_if (parser, clauses);\n+\t  c_name = \"if\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_LASTPRIVATE:\n+\t  clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_LASTPRIVATE,\n+\t\t\t\t\t    clauses);\n+\t  c_name = \"lastprivate\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_NOWAIT:\n+\t  clauses = cp_parser_omp_clause_nowait (parser, clauses);\n+\t  c_name = \"nowait\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_NUM_THREADS:\n+\t  clauses = cp_parser_omp_clause_num_threads (parser, clauses);\n+\t  c_name = \"num_threads\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_ORDERED:\n+\t  clauses = cp_parser_omp_clause_ordered (parser, clauses);\n+\t  c_name = \"ordered\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_PRIVATE:\n+\t  clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_PRIVATE,\n+\t\t\t\t\t    clauses);\n+\t  c_name = \"private\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_REDUCTION:\n+\t  clauses = cp_parser_omp_clause_reduction (parser, clauses);\n+\t  c_name = \"reduction\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_SCHEDULE:\n+\t  clauses = cp_parser_omp_clause_schedule (parser, clauses);\n+\t  c_name = \"schedule\";\n+\t  break;\n+\tcase PRAGMA_OMP_CLAUSE_SHARED:\n+\t  clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_SHARED,\n+\t\t\t\t\t    clauses);\n+\t  c_name = \"shared\";\n+\t  break;\n+\tdefault:\n+\t  cp_parser_error (parser, \"expected %<#pragma omp%> clause\");\n+\t  goto saw_error;\n+\t}\n+\n+      if (((mask >> c_kind) & 1) == 0)\n+\t{\n+\t  /* Remove the invalid clause(s) from the list to avoid\n+\t     confusing the rest of the compiler.  */\n+\t  clauses = prev;\n+\t  error (\"%qs is not valid for %qs\", c_name, where);\n+\t}\n+    }\n+ saw_error:\n+  cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+  return finish_omp_clauses (clauses);\n+}\n+\n+/* OpenMP 2.5:\n+   structured-block:\n+     statement\n+\n+   In practice, we're also interested in adding the statement to an\n+   outer node.  So it is convenient if we work around the fact that\n+   cp_parser_statement calls add_stmt.  */\n+\n+static unsigned\n+cp_parser_begin_omp_structured_block (cp_parser *parser)\n+{\n+  unsigned save = parser->in_statement;\n+\n+  /* Only move the values to IN_OMP_BLOCK if they weren't false.\n+     This preserves the \"not within loop or switch\" style error messages\n+     for nonsense cases like\n+\tvoid foo() {\n+\t#pragma omp single\n+\t  break;\n+\t}\n+  */\n+  if (parser->in_statement)\n+    parser->in_statement = IN_OMP_BLOCK;\n+\n+  return save;\n+}\n+\n+static void\n+cp_parser_end_omp_structured_block (cp_parser *parser, unsigned save)\n+{\n+  parser->in_statement = save;\n+}\n+\n+static tree\n+cp_parser_omp_structured_block (cp_parser *parser)\n+{\n+  tree stmt = begin_omp_structured_block ();\n+  unsigned int save = cp_parser_begin_omp_structured_block (parser);\n+\n+  cp_parser_statement (parser, NULL_TREE, false);\n+\n+  cp_parser_end_omp_structured_block (parser, save);\n+  return finish_omp_structured_block (stmt);\n+}\n+\n+/* OpenMP 2.5:\n+   # pragma omp atomic new-line\n+     expression-stmt\n+\n+   expression-stmt:\n+     x binop= expr | x++ | ++x | x-- | --x\n+   binop:\n+     +, *, -, /, &, ^, |, <<, >>\n+\n+  where x is an lvalue expression with scalar type.  */\n+\n+static void\n+cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  tree lhs, rhs;\n+  enum tree_code code;\n+\n+  cp_parser_require_pragma_eol (parser, pragma_tok);\n+\n+  lhs = cp_parser_unary_expression (parser, /*address_p=*/false,\n+\t\t\t\t    /*cast_p=*/false);\n+  switch (TREE_CODE (lhs))\n+    {\n+    case ERROR_MARK:\n+      goto saw_error;\n+\n+    case PREINCREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+      lhs = TREE_OPERAND (lhs, 0);\n+      code = PLUS_EXPR;\n+      rhs = integer_one_node;\n+      break;\n+\n+    case PREDECREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+      lhs = TREE_OPERAND (lhs, 0);\n+      code = MINUS_EXPR;\n+      rhs = integer_one_node;\n+      break;\n+\n+    default:\n+      switch (cp_lexer_peek_token (parser->lexer)->type)\n+\t{\n+\tcase CPP_MULT_EQ:\n+\t  code = MULT_EXPR;\n+\t  break;\n+\tcase CPP_DIV_EQ:\n+\t  code = TRUNC_DIV_EXPR;\n+\t  break;\n+\tcase CPP_PLUS_EQ:\n+\t  code = PLUS_EXPR;\n+\t  break;\n+\tcase CPP_MINUS_EQ:\n+\t  code = MINUS_EXPR;\n+\t  break;\n+\tcase CPP_LSHIFT_EQ:\n+\t  code = LSHIFT_EXPR;\n+\t  break;\n+\tcase CPP_RSHIFT_EQ:\n+\t  code = RSHIFT_EXPR;\n+\t  break;\n+\tcase CPP_AND_EQ:\n+\t  code = BIT_AND_EXPR;\n+\t  break;\n+\tcase CPP_OR_EQ:\n+\t  code = BIT_IOR_EXPR;\n+\t  break;\n+\tcase CPP_XOR_EQ:\n+\t  code = BIT_XOR_EXPR;\n+\t  break;\n+\tdefault:\n+\t  cp_parser_error (parser,\n+\t\t\t   \"invalid operator for %<#pragma omp atomic%>\");\n+\t  goto saw_error;\n+\t}\n+      cp_lexer_consume_token (parser->lexer);\n+\n+      rhs = cp_parser_expression (parser, false);\n+      if (rhs == error_mark_node)\n+\tgoto saw_error;\n+      break;\n+    }\n+  finish_omp_atomic (code, lhs, rhs);\n+  cp_parser_consume_semicolon_at_end_of_statement (parser);\n+  return;\n+\n+ saw_error:\n+  cp_parser_skip_to_end_of_block_or_statement (parser);\n+}\n+\n+\n+/* OpenMP 2.5:\n+   # pragma omp barrier new-line\n+*/\n+\n+static void\n+cp_parser_omp_barrier (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  cp_parser_require_pragma_eol (parser, pragma_tok);\n+  finish_omp_barrier ();\n+}\n+\n+/* OpenMP 2.5:\n+   # pragma omp critical [(name)] new-line\n+     structured-block\n+*/\n+\n+static tree\n+cp_parser_omp_critical (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  tree stmt, name = NULL;\n+\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+\n+      name = cp_parser_identifier (parser);\n+      \n+      if (name == error_mark_node\n+\t  || !cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n+\tcp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n+\t\t\t\t\t       /*or_comma=*/false,\n+\t\t\t\t\t       /*consume_paren=*/true);\n+      if (name == error_mark_node)\n+\tname = NULL;\n+    }\n+  cp_parser_require_pragma_eol (parser, pragma_tok);\n+\n+  stmt = cp_parser_omp_structured_block (parser);\n+  return c_finish_omp_critical (stmt, name);\n+}\n+\n+/* OpenMP 2.5:\n+   # pragma omp flush flush-vars[opt] new-line\n+\n+   flush-vars:\n+     ( variable-list ) */\n+\n+static void\n+cp_parser_omp_flush (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n+    (void) cp_parser_omp_var_list (parser, 0, NULL);\n+  cp_parser_require_pragma_eol (parser, pragma_tok);\n+\n+  finish_omp_flush ();\n+}\n+\n+/* Parse the restricted form of the for statment allowed by OpenMP.  */\n+\n+static tree\n+cp_parser_omp_for_loop (cp_parser *parser)\n+{\n+  tree init, cond, incr, body, decl, pre_body;\n+  location_t loc;\n+\n+  if (!cp_lexer_next_token_is_keyword (parser->lexer, RID_FOR))\n+    {\n+      cp_parser_error (parser, \"for statement expected\");\n+      return NULL;\n+    }\n+  loc = cp_lexer_consume_token (parser->lexer)->location;\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\"))\n+    return NULL;\n+\n+  init = decl = NULL;\n+  pre_body = push_stmt_list ();\n+  if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n+    {\n+      cp_decl_specifier_seq type_specifiers;\n+\n+      /* First, try to parse as an initialized declaration.  See\n+\t cp_parser_condition, from whence the bulk of this is copied.  */\n+\n+      cp_parser_parse_tentatively (parser);\n+      cp_parser_type_specifier_seq (parser, /*is_condition=*/false,\n+\t\t\t\t    &type_specifiers);\n+      if (!cp_parser_error_occurred (parser))\n+\t{\n+\t  tree asm_specification, attributes;\n+\t  cp_declarator *declarator;\n+\n+\t  declarator = cp_parser_declarator (parser,\n+\t\t\t\t\t     CP_PARSER_DECLARATOR_NAMED,\n+\t\t\t\t\t     /*ctor_dtor_or_conv_p=*/NULL,\n+\t\t\t\t\t     /*parenthesized_p=*/NULL,\n+\t\t\t\t\t     /*member_p=*/false);\n+\t  attributes = cp_parser_attributes_opt (parser);\n+\t  asm_specification = cp_parser_asm_specification_opt (parser);\n+\n+\t  cp_parser_require (parser, CPP_EQ, \"`='\");\n+\t  if (cp_parser_parse_definitely (parser))\n+\t    {\n+\t      tree pushed_scope;\n+\n+\t      decl = start_decl (declarator, &type_specifiers,\n+\t\t\t\t /*initialized_p=*/false, attributes,\n+\t\t\t\t /*prefix_attributes=*/NULL_TREE,\n+\t\t\t\t &pushed_scope);\n+\n+\t      init = cp_parser_assignment_expression (parser, false);\n+\n+\t      cp_finish_decl (decl, NULL_TREE, /*init_const_expr_p=*/false,\n+\t\t\t      asm_specification, LOOKUP_ONLYCONVERTING);\n+\n+\t      if (pushed_scope)\n+\t\tpop_scope (pushed_scope);\n+\t    }\n+\t}\n+\n+      /* If parsing as an initialized declaration failed, try again as\n+\t a simple expression.  */\n+      if (decl == NULL)\n+\t{\n+\t  cp_parser_abort_tentative_parse (parser);\n+\t  init = cp_parser_expression (parser, false);\n+\t}\n+    }\n+  cp_parser_require (parser, CPP_SEMICOLON, \"`;'\");\n+  pre_body = pop_stmt_list (pre_body);\n+\n+  cond = NULL;\n+  if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n+    cond = cp_parser_condition (parser);\n+  cp_parser_require (parser, CPP_SEMICOLON, \"`;'\");\n+\n+  incr = NULL;\n+  if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN))\n+    incr = cp_parser_expression (parser, false);\n+\n+  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n+    cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n+\t\t\t\t\t   /*or_comma=*/false,\n+\t\t\t\t\t   /*consume_paren=*/true);\n+\n+  /* Note that we saved the original contents of this flag when we entered\n+     the structured block, and so we don't need to re-save it here.  */\n+  parser->in_statement = IN_OMP_FOR;\n+\n+  /* Note that the grammar doesn't call for a structured block here,\n+     though the loop as a whole is a structured block.  */\n+  body = push_stmt_list ();\n+  cp_parser_statement (parser, NULL_TREE, false);\n+  body = pop_stmt_list (body);\n+\n+  return finish_omp_for (loc, decl, init, cond, incr, body, pre_body);\n+}\n+\n+/* OpenMP 2.5:\n+   #pragma omp for for-clause[optseq] new-line\n+     for-loop\n+*/\n+\n+#define OMP_FOR_CLAUSE_MASK\t\t\t\t\\\n+\t( (1u << PRAGMA_OMP_CLAUSE_PRIVATE)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_LASTPRIVATE)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_REDUCTION)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_ORDERED)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_SCHEDULE)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_NOWAIT))\n+\n+static tree\n+cp_parser_omp_for (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  tree clauses, sb, ret;\n+  unsigned int save;\n+\n+  clauses = cp_parser_omp_all_clauses (parser, OMP_FOR_CLAUSE_MASK,\n+\t\t\t\t       \"#pragma omp for\", pragma_tok);\n+\n+  sb = begin_omp_structured_block ();\n+  save = cp_parser_begin_omp_structured_block (parser);\n+\n+  ret = cp_parser_omp_for_loop (parser);\n+  if (ret)\n+    OMP_FOR_CLAUSES (ret) = clauses;\n+\n+  cp_parser_end_omp_structured_block (parser, save);\n+  add_stmt (finish_omp_structured_block (sb));\n+\n+  return ret;\n+}\n+\n+/* OpenMP 2.5:\n+   # pragma omp master new-line\n+     structured-block\n+*/\n+\n+static tree\n+cp_parser_omp_master (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  cp_parser_require_pragma_eol (parser, pragma_tok);\n+  return c_finish_omp_master (cp_parser_omp_structured_block (parser));\n+}\n+\n+/* OpenMP 2.5:\n+   # pragma omp ordered new-line\n+     structured-block\n+*/\n+\n+static tree\n+cp_parser_omp_ordered (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  cp_parser_require_pragma_eol (parser, pragma_tok);\n+  return c_finish_omp_ordered (cp_parser_omp_structured_block (parser));\n+}\n+\n+/* OpenMP 2.5:\n+\n+   section-scope:\n+     { section-sequence }\n+\n+   section-sequence:\n+     section-directive[opt] structured-block\n+     section-sequence section-directive structured-block  */\n+\n+static tree\n+cp_parser_omp_sections_scope (cp_parser *parser)\n+{\n+  tree stmt, substmt;\n+  bool error_suppress = false;\n+  cp_token *tok;\n+\n+  if (!cp_parser_require (parser, CPP_OPEN_BRACE, \"`{'\"))\n+    return NULL_TREE;\n+\n+  stmt = push_stmt_list ();\n+\n+  if (cp_lexer_peek_token (parser->lexer)->pragma_kind != PRAGMA_OMP_SECTION)\n+    {\n+      unsigned save;\n+\n+      substmt = begin_omp_structured_block ();\n+      save = cp_parser_begin_omp_structured_block (parser);\n+\n+      while (1)\n+\t{\n+          cp_parser_statement (parser, NULL_TREE, false);\n+\n+\t  tok = cp_lexer_peek_token (parser->lexer);\n+\t  if (tok->pragma_kind == PRAGMA_OMP_SECTION)\n+\t    break;\n+\t  if (tok->type == CPP_CLOSE_BRACE)\n+\t    break;\n+\t  if (tok->type == CPP_EOF)\n+\t    break;\n+\t}\n+\n+      cp_parser_end_omp_structured_block (parser, save);\n+      substmt = finish_omp_structured_block (substmt);\n+      substmt = build1 (OMP_SECTION, void_type_node, substmt);\n+      add_stmt (substmt);\n+    }\n+\n+  while (1)\n+    {\n+      tok = cp_lexer_peek_token (parser->lexer);\n+      if (tok->type == CPP_CLOSE_BRACE)\n+\tbreak;\n+      if (tok->type == CPP_EOF)\n+\tbreak;\n+\n+      if (tok->pragma_kind == PRAGMA_OMP_SECTION)\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  cp_parser_require_pragma_eol (parser, tok);\n+\t  error_suppress = false;\n+\t}\n+      else if (!error_suppress)\n+\t{\n+\t  cp_parser_error (parser, \"expected %<#pragma omp section%> or %<}%>\");\n+\t  error_suppress = true;\n+\t}\n+\n+      substmt = cp_parser_omp_structured_block (parser);\n+      substmt = build1 (OMP_SECTION, void_type_node, substmt);\n+      add_stmt (substmt);\n+    }\n+  cp_parser_require (parser, CPP_CLOSE_BRACE, \"`}'\");\n+\n+  substmt = pop_stmt_list (stmt);\n+\n+  stmt = make_node (OMP_SECTIONS);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OMP_SECTIONS_BODY (stmt) = substmt;\n+\n+  add_stmt (stmt);\n+  return stmt;\n+}\n+\n+/* OpenMP 2.5:\n+   # pragma omp sections sections-clause[optseq] newline\n+     sections-scope\n+*/\n+\n+#define OMP_SECTIONS_CLAUSE_MASK\t\t\t\\\n+\t( (1u << PRAGMA_OMP_CLAUSE_PRIVATE)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_LASTPRIVATE)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_REDUCTION)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_NOWAIT))\n+\n+static tree\n+cp_parser_omp_sections (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  tree clauses, ret;\n+\n+  clauses = cp_parser_omp_all_clauses (parser, OMP_SECTIONS_CLAUSE_MASK,\n+\t\t\t\t       \"#pragma omp sections\", pragma_tok);\n+\n+  ret = cp_parser_omp_sections_scope (parser);\n+  if (ret)\n+    OMP_SECTIONS_CLAUSES (ret) = clauses;\n+\n+  return ret;\n+}\n+\n+/* OpenMP 2.5:\n+   # pragma parallel parallel-clause new-line\n+   # pragma parallel for parallel-for-clause new-line\n+   # pragma parallel sections parallel-sections-clause new-line\n+*/\n+\n+#define OMP_PARALLEL_CLAUSE_MASK\t\t\t\\\n+\t( (1u << PRAGMA_OMP_CLAUSE_IF)\t\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_PRIVATE)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_DEFAULT)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_SHARED)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_COPYIN)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_REDUCTION)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_NUM_THREADS))\n+\n+static tree\n+cp_parser_omp_parallel (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  enum pragma_kind p_kind = PRAGMA_OMP_PARALLEL;\n+  const char *p_name = \"#pragma omp parallel\";\n+  tree stmt, clauses, par_clause, ws_clause, block;\n+  unsigned int mask = OMP_PARALLEL_CLAUSE_MASK;\n+  unsigned int save;\n+\n+  if (cp_lexer_next_token_is_keyword (parser->lexer, RID_FOR))\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+      p_kind = PRAGMA_OMP_PARALLEL_FOR;\n+      p_name = \"#pragma omp parallel for\";\n+      mask |= OMP_FOR_CLAUSE_MASK;\n+      mask &= ~(1u << PRAGMA_OMP_CLAUSE_NOWAIT);\n+    }\n+  else if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+    {\n+      tree id = cp_lexer_peek_token (parser->lexer)->value;\n+      const char *p = IDENTIFIER_POINTER (id);\n+      if (strcmp (p, \"sections\") == 0)\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  p_kind = PRAGMA_OMP_PARALLEL_SECTIONS;\n+\t  p_name = \"#pragma omp parallel sections\";\n+\t  mask |= OMP_SECTIONS_CLAUSE_MASK;\n+\t  mask &= ~(1u << PRAGMA_OMP_CLAUSE_NOWAIT);\n+\t}\n+    }\n+\n+  clauses = cp_parser_omp_all_clauses (parser, mask, p_name, pragma_tok);\n+  block = begin_omp_parallel ();\n+  save = cp_parser_begin_omp_structured_block (parser);\n+\n+  switch (p_kind)\n+    {\n+    case PRAGMA_OMP_PARALLEL:\n+      cp_parser_already_scoped_statement (parser);\n+      par_clause = clauses;\n+      break;\n+\n+    case PRAGMA_OMP_PARALLEL_FOR:\n+      c_split_parallel_clauses (clauses, &par_clause, &ws_clause);\n+      stmt = cp_parser_omp_for_loop (parser);\n+      if (stmt)\n+\tOMP_FOR_CLAUSES (stmt) = ws_clause;\n+      break;\n+\n+    case PRAGMA_OMP_PARALLEL_SECTIONS:\n+      c_split_parallel_clauses (clauses, &par_clause, &ws_clause);\n+      stmt = cp_parser_omp_sections_scope (parser);\n+      if (stmt)\n+\tOMP_SECTIONS_CLAUSES (stmt) = ws_clause;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  cp_parser_end_omp_structured_block (parser, save);\n+  return finish_omp_parallel (par_clause, block);\n+}\n+\n+/* OpenMP 2.5:\n+   # pragma omp single single-clause[optseq] new-line\n+     structured-block\n+*/\n+\n+#define OMP_SINGLE_CLAUSE_MASK\t\t\t\t\\\n+\t( (1u << PRAGMA_OMP_CLAUSE_PRIVATE)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_FIRSTPRIVATE)\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_COPYPRIVATE)\t\t\\\n+\t| (1u << PRAGMA_OMP_CLAUSE_NOWAIT))\n+\n+static tree\n+cp_parser_omp_single (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  tree stmt = make_node (OMP_SINGLE);\n+  TREE_TYPE (stmt) = void_type_node;\n+\n+  OMP_SINGLE_CLAUSES (stmt)\n+    = cp_parser_omp_all_clauses (parser, OMP_SINGLE_CLAUSE_MASK,\n+\t\t\t\t \"#pragma omp single\", pragma_tok);\n+  OMP_SINGLE_BODY (stmt) = cp_parser_omp_structured_block (parser);\n+\n+  return add_stmt (stmt);\n+}\n+\n+/* OpenMP 2.5:\n+   # pragma omp threadprivate (variable-list) */\n+\n+static void\n+cp_parser_omp_threadprivate (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  tree vars;\n+\n+  vars = cp_parser_omp_var_list (parser, 0, NULL);\n+  cp_parser_require_pragma_eol (parser, pragma_tok);\n+\n+  if (!targetm.have_tls)\n+    sorry (\"threadprivate variables not supported in this target\");\n+\n+  finish_omp_threadprivate (vars);\n+}\n+\n+/* Main entry point to OpenMP statement pragmas.  */\n+\n+static void\n+cp_parser_omp_construct (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  tree stmt;\n+\n+  switch (pragma_tok->pragma_kind)\n+    {\n+    case PRAGMA_OMP_ATOMIC:\n+      cp_parser_omp_atomic (parser, pragma_tok);\n+      return;\n+    case PRAGMA_OMP_CRITICAL:\n+      stmt = cp_parser_omp_critical (parser, pragma_tok);\n+      break;\n+    case PRAGMA_OMP_FOR:\n+      stmt = cp_parser_omp_for (parser, pragma_tok);\n+      break;\n+    case PRAGMA_OMP_MASTER:\n+      stmt = cp_parser_omp_master (parser, pragma_tok);\n+      break;\n+    case PRAGMA_OMP_ORDERED:\n+      stmt = cp_parser_omp_ordered (parser, pragma_tok);\n+      break;\n+    case PRAGMA_OMP_PARALLEL:\n+      stmt = cp_parser_omp_parallel (parser, pragma_tok);\n+      break;\n+    case PRAGMA_OMP_SECTIONS:\n+      stmt = cp_parser_omp_sections (parser, pragma_tok);\n+      break;\n+    case PRAGMA_OMP_SINGLE:\n+      stmt = cp_parser_omp_single (parser, pragma_tok);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (stmt)\n+    SET_EXPR_LOCATION (stmt, pragma_tok->location);\n+}\n+\f\n+/* The parser.  */\n+\n+static GTY (()) cp_parser *the_parser;\n+\n+\f\n+/* Special handling for the first token or line in the file.  The first\n+   thing in the file might be #pragma GCC pch_preprocess, which loads a\n+   PCH file, which is a GC collection point.  So we need to handle this\n+   first pragma without benefit of an existing lexer structure.\n+\n+   Always returns one token to the caller in *FIRST_TOKEN.  This is \n+   either the true first token of the file, or the first token after\n+   the initial pragma.  */\n+\n+static void\n+cp_parser_initial_pragma (cp_token *first_token)\n+{\n+  tree name = NULL;\n+\n+  cp_lexer_get_preprocessor_token (NULL, first_token);\n+  if (first_token->pragma_kind != PRAGMA_GCC_PCH_PREPROCESS)\n+    return;\n+\n+  cp_lexer_get_preprocessor_token (NULL, first_token);\n+  if (first_token->type == CPP_STRING)\n+    {\n+      name = first_token->value;\n+\n+      cp_lexer_get_preprocessor_token (NULL, first_token);\n+      if (first_token->type != CPP_PRAGMA_EOL)\n+\terror (\"junk at end of %<#pragma GCC pch_preprocess%>\");\n+    }\n+  else\n+    error (\"expected string literal\");\n+\n+  /* Skip to the end of the pragma.  */\n+  while (first_token->type != CPP_PRAGMA_EOL && first_token->type != CPP_EOF)\n+    cp_lexer_get_preprocessor_token (NULL, first_token);\n+\n+  /* Read one more token to return to our caller.  */\n+  cp_lexer_get_preprocessor_token (NULL, first_token);\n+\n+  /* Now actually load the PCH file.  */\n+  if (name)\n+    c_common_pch_pragma (parse_in, TREE_STRING_POINTER (name));\n+}\n+\n+/* Normal parsing of a pragma token.  Here we can (and must) use the\n+   regular lexer.  */\n+\n+static bool\n+cp_parser_pragma (cp_parser *parser, enum pragma_context context)\n+{\n+  cp_token *pragma_tok;\n+  unsigned int id;\n+\n+  pragma_tok = cp_lexer_consume_token (parser->lexer);\n+  gcc_assert (pragma_tok->type == CPP_PRAGMA);\n+  parser->lexer->in_pragma = true;\n+\n+  id = pragma_tok->pragma_kind;\n+  switch (id)\n+    {\n+    case PRAGMA_GCC_PCH_PREPROCESS:\n+      error (\"%<#pragma GCC pch_preprocess%> must be first\");\n+      break;\n+\n+    case PRAGMA_OMP_BARRIER:\n+      switch (context)\n+\t{\n+\tcase pragma_compound:\n+\t  cp_parser_omp_barrier (parser, pragma_tok);\n+\t  return false;\n+\tcase pragma_stmt:\n+\t  error (\"%<#pragma omp barrier%> may only be \"\n+\t\t \"used in compound statements\");\n+\t  break;\n+\tdefault:\n+\t  goto bad_stmt;\n+\t}\n+      break;\n+\n+    case PRAGMA_OMP_FLUSH:\n+      switch (context)\n+\t{\n+\tcase pragma_compound:\n+\t  cp_parser_omp_flush (parser, pragma_tok);\n+\t  return false;\n+\tcase pragma_stmt:\n+\t  error (\"%<#pragma omp flush%> may only be \"\n+\t\t \"used in compound statements\");\n+\t  break;\n+\tdefault:\n+\t  goto bad_stmt;\n+\t}\n+      break;\n+\n+    case PRAGMA_OMP_THREADPRIVATE:\n+      cp_parser_omp_threadprivate (parser, pragma_tok);\n+      return false;\n+\n+    case PRAGMA_OMP_ATOMIC:\n+    case PRAGMA_OMP_CRITICAL:\n+    case PRAGMA_OMP_FOR:\n+    case PRAGMA_OMP_MASTER:\n+    case PRAGMA_OMP_ORDERED:\n+    case PRAGMA_OMP_PARALLEL:\n+    case PRAGMA_OMP_SECTIONS:\n+    case PRAGMA_OMP_SINGLE:\n+      if (context == pragma_external)\n+\tgoto bad_stmt;\n+      cp_parser_omp_construct (parser, pragma_tok);\n+      return true;\n+\n+    case PRAGMA_OMP_SECTION:\n+      error (\"%<#pragma omp section%> may only be used in \"\n+\t     \"%<#pragma omp sections%> construct\");\n+      break;\n+\n+    default:\n+      gcc_assert (id >= PRAGMA_FIRST_EXTERNAL);\n+      c_invoke_pragma_handler (id);\n+      break;\n+\n+    bad_stmt:\n+      cp_parser_error (parser, \"expected declaration specifiers\");\n       break;\n     }\n "}, {"sha": "6cb78657eb340dc74d6a0c868ceb3fbb7d0b054a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -8081,6 +8081,47 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     }\n }\n \n+/* Like tsubst_copy, but specifically for OpenMP clauses.  */\n+\n+static tree\n+tsubst_omp_clauses (tree clauses, tree args, tsubst_flags_t complain,\n+\t\t    tree in_decl)\n+{\n+  tree new_clauses = NULL, nc, oc;\n+\n+  for (oc = clauses; oc ; oc = OMP_CLAUSE_CHAIN (oc))\n+    {\n+      nc = copy_node (oc);\n+      OMP_CLAUSE_CHAIN (nc) = new_clauses;\n+      new_clauses = nc;\n+\n+      switch (OMP_CLAUSE_CODE (nc))\n+\t{\n+\tcase OMP_CLAUSE_PRIVATE:\n+\tcase OMP_CLAUSE_SHARED:\n+\tcase OMP_CLAUSE_FIRSTPRIVATE:\n+\tcase OMP_CLAUSE_LASTPRIVATE:\n+\tcase OMP_CLAUSE_REDUCTION:\n+\tcase OMP_CLAUSE_COPYIN:\n+\tcase OMP_CLAUSE_COPYPRIVATE:\n+\tcase OMP_CLAUSE_IF:\n+\tcase OMP_CLAUSE_NUM_THREADS:\n+\tcase OMP_CLAUSE_SCHEDULE:\n+\t  OMP_CLAUSE_OPERAND (nc, 0)\n+\t    = tsubst_expr (OMP_CLAUSE_OPERAND (oc, 0), args, complain, in_decl);\n+\t  break;\n+\tcase OMP_CLAUSE_NOWAIT:\n+\tcase OMP_CLAUSE_ORDERED:\n+\tcase OMP_CLAUSE_DEFAULT:\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+\n+  return finish_omp_clauses (nreverse (new_clauses));\n+}\n+\n /* Like tsubst_copy_and_build, but unshare TREE_LIST nodes.  */\n \n static tree\n@@ -8400,6 +8441,84 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       tsubst (TREE_TYPE (t), args, complain, NULL_TREE);\n       break;\n \n+    case OMP_PARALLEL:\n+      tmp = tsubst_omp_clauses (OMP_PARALLEL_CLAUSES (t),\n+\t\t\t\targs, complain, in_decl);\n+      stmt = begin_omp_parallel ();\n+      tsubst_expr (OMP_PARALLEL_BODY (t), args, complain, in_decl);\n+      finish_omp_parallel (tmp, stmt);\n+      break;\n+\n+    case OMP_FOR:\n+      {\n+\ttree clauses, decl, init, cond, incr, body, pre_body;\n+\n+\tclauses = tsubst_omp_clauses (OMP_FOR_CLAUSES (t),\n+\t\t\t\t      args, complain, in_decl);\n+\tinit = OMP_FOR_INIT (t);\n+\tgcc_assert (TREE_CODE (init) == MODIFY_EXPR);\n+\tdecl = tsubst_expr (TREE_OPERAND (init, 0), args, complain, in_decl);\n+\tinit = tsubst_expr (TREE_OPERAND (init, 1), args, complain, in_decl);\n+\tcond = tsubst_expr (OMP_FOR_COND (t), args, complain, in_decl);\n+\tincr = tsubst_expr (OMP_FOR_INCR (t), args, complain, in_decl);\n+\n+\tstmt = begin_omp_structured_block ();\n+\n+\tpre_body = push_stmt_list ();\n+\ttsubst_expr (OMP_FOR_PRE_BODY (t), args, complain, in_decl);\n+\tpre_body = pop_stmt_list (pre_body);\n+\n+\tbody = push_stmt_list ();\n+\ttsubst_expr (OMP_FOR_BODY (t), args, complain, in_decl);\n+\tbody = pop_stmt_list (body);\n+\n+\tt = finish_omp_for (EXPR_LOCATION (t), decl, init, cond, incr, body,\n+\t\t\t    pre_body);\n+\tif (t)\n+\t  OMP_FOR_CLAUSES (t) = clauses;\n+\n+\tadd_stmt (finish_omp_structured_block (stmt));\n+      }\n+      break;\n+\n+    case OMP_SECTIONS:\n+    case OMP_SINGLE:\n+      tmp = tsubst_omp_clauses (OMP_CLAUSES (t), args, complain, in_decl);\n+      stmt = push_stmt_list ();\n+      tsubst_expr (OMP_BODY (t), args, complain, in_decl);\n+      stmt = pop_stmt_list (stmt);\n+\n+      t = copy_node (t);\n+      OMP_BODY (t) = stmt;\n+      OMP_CLAUSES (t) = tmp;\n+      add_stmt (t);\n+      break;\n+\n+    case OMP_SECTION:\n+    case OMP_CRITICAL:\n+    case OMP_MASTER:\n+    case OMP_ORDERED:\n+      stmt = push_stmt_list ();\n+      tsubst_expr (OMP_BODY (t), args, complain, in_decl);\n+      stmt = pop_stmt_list (stmt);\n+\n+      t = copy_node (t);\n+      OMP_BODY (t) = stmt;\n+      add_stmt (t);\n+      break;\n+\n+    case OMP_ATOMIC:\n+      {\n+\ttree op0, op1;\n+\top0 = tsubst_expr (TREE_OPERAND (t, 0), args, complain, in_decl);\n+\top1 = tsubst_expr (TREE_OPERAND (t, 1), args, complain, in_decl);\n+\tif (OMP_ATOMIC_DEPENDENT_P (t))\n+\t  c_finish_omp_atomic (OMP_ATOMIC_CODE (t), op0, op1);\n+\telse\n+\t  add_stmt (build2 (OMP_ATOMIC, void_type_node, op0, op1));\n+      }\n+      break;\n+\n     default:\n       gcc_assert (!STATEMENT_CODE_P (TREE_CODE (t)));\n "}, {"sha": "1931dc97f8f70418ef2877ef05d132097ab456a1", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 614, "deletions": 1, "changes": 615, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -743,6 +743,9 @@ finish_return_stmt (tree expr)\n   bool no_warning;\n \n   expr = check_return_expr (expr, &no_warning);\n+\n+  if (flag_openmp && !check_omp_return ())\n+    return error_mark_node;\n   if (!processing_template_decl)\n     {\n       if (DECL_DESTRUCTOR_P (current_function_decl)\n@@ -3219,9 +3222,619 @@ finalize_nrv (tree *tp, tree var, tree result)\n   walk_tree (tp, finalize_nrv_r, &data, 0);\n   htab_delete (data.visited);\n }\n+\f\n+/* For all elements of CLAUSES, validate them vs OpenMP constraints.\n+   Remove any elements from the list that are invalid.  */\n+\n+tree\n+finish_omp_clauses (tree clauses)\n+{\n+  bitmap_head generic_head, firstprivate_head, lastprivate_head;\n+  tree c, t, *pc = &clauses;\n+  const char *name;\n+\n+  bitmap_obstack_initialize (NULL);\n+  bitmap_initialize (&generic_head, &bitmap_default_obstack);\n+  bitmap_initialize (&firstprivate_head, &bitmap_default_obstack);\n+  bitmap_initialize (&lastprivate_head, &bitmap_default_obstack);\n+\n+  for (pc = &clauses, c = clauses; c ; c = *pc)\n+    {\n+      bool remove = false;\n+\n+      switch (OMP_CLAUSE_CODE (c))\n+\t{\n+\tcase OMP_CLAUSE_SHARED:\n+\t  name = \"shared\";\n+\t  goto check_dup_generic;\n+\tcase OMP_CLAUSE_PRIVATE:\n+\t  name = \"private\";\n+\t  goto check_dup_generic;\n+\tcase OMP_CLAUSE_REDUCTION:\n+\t  name = \"reduction\";\n+\t  goto check_dup_generic;\n+\tcase OMP_CLAUSE_COPYPRIVATE:\n+\t  name = \"copyprivate\";\n+\t  goto check_dup_generic;\n+\tcase OMP_CLAUSE_COPYIN:\n+\t  name = \"copyin\";\n+\t  goto check_dup_generic;\n+\tcheck_dup_generic:\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n+\t    {\n+\t      if (processing_template_decl)\n+\t\tbreak;\n+\t      error (\"%qE is not a variable in clause %qs\", t, name);\n+\t      remove = true;\n+\t    }\n+\t  else if (bitmap_bit_p (&generic_head, DECL_UID (t))\n+\t\t   || bitmap_bit_p (&firstprivate_head, DECL_UID (t))\n+\t\t   || bitmap_bit_p (&lastprivate_head, DECL_UID (t)))\n+\t    {\n+\t      error (\"%qE appears more than once in data clauses\", t);\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    bitmap_set_bit (&generic_head, DECL_UID (t));\n+\t  break;\n+\n+\tcase OMP_CLAUSE_FIRSTPRIVATE:\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n+\t    {\n+\t      if (processing_template_decl)\n+\t\tbreak;\n+\t      error (\"%qE is not a variable in clause %<firstprivate%>\", t);\n+\t      remove = true;\n+\t    }\n+\t  else if (bitmap_bit_p (&generic_head, DECL_UID (t))\n+\t\t   || bitmap_bit_p (&firstprivate_head, DECL_UID (t)))\n+\t    {\n+\t      error (\"%qE appears more than once in data clauses\", t);\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    bitmap_set_bit (&firstprivate_head, DECL_UID (t));\n+\t  break;\n+\n+\tcase OMP_CLAUSE_LASTPRIVATE:\n+\t  t = OMP_CLAUSE_DECL (c);\n+\t  if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n+\t    {\n+\t      if (processing_template_decl)\n+\t\tbreak;\n+\t      error (\"%qE is not a variable in clause %<lastprivate%>\", t);\n+\t      remove = true;\n+\t    }\n+\t  else if (bitmap_bit_p (&generic_head, DECL_UID (t))\n+\t\t   || bitmap_bit_p (&lastprivate_head, DECL_UID (t)))\n+\t    {\n+\t      error (\"%qE appears more than once in data clauses\", t);\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    bitmap_set_bit (&lastprivate_head, DECL_UID (t));\n+\t  break;\n+\n+\tcase OMP_CLAUSE_IF:\n+\t  t = OMP_CLAUSE_IF_EXPR (c);\n+\t  t = maybe_convert_cond (t);\n+\t  if (t == error_mark_node)\n+\t    remove = true;\n+\t  OMP_CLAUSE_IF_EXPR (c) = t;\n+\t  break;\n+\n+\tcase OMP_CLAUSE_NUM_THREADS:\n+\t  t = OMP_CLAUSE_NUM_THREADS_EXPR (c);\n+\t  if (t == error_mark_node)\n+\t    remove = true;\n+\t  else if (!INTEGRAL_TYPE_P (TREE_TYPE (t))\n+\t\t   && !type_dependent_expression_p (t))\n+\t    {\n+\t      error (\"num_threads expression must be integral\");\n+\t      remove = true;\n+\t    }\n+\t  break;\n+\n+\tcase OMP_CLAUSE_SCHEDULE:\n+\t  t = OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (c);\n+\t  if (t == NULL)\n+\t    ;\n+\t  else if (t == error_mark_node)\n+\t    remove = true;\n+\t  else if (!INTEGRAL_TYPE_P (TREE_TYPE (t))\n+\t\t   && !type_dependent_expression_p (t))\n+\t    {\n+\t      error (\"schedule chunk size expression must be integral\");\n+\t      remove = true;\n+\t    }\n+\t  break;\n+\n+\tcase OMP_CLAUSE_NOWAIT:\n+\tcase OMP_CLAUSE_ORDERED:\n+\tcase OMP_CLAUSE_DEFAULT:\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      if (remove)\n+\t*pc = OMP_CLAUSE_CHAIN (c);\n+      else\n+\tpc = &OMP_CLAUSE_CHAIN (c);\n+    }\n+\n+  for (pc = &clauses, c = clauses; c ; c = *pc)\n+    {\n+      enum tree_code c_kind = OMP_CLAUSE_CODE (c);\n+      bool remove = false;\n+      bool need_complete_non_reference = false;\n+      bool need_default_ctor = false;\n+      bool need_copy_ctor = false;\n+      bool need_copy_assignment = false;\n+      bool need_implicitly_determined = false;\n+      tree type, inner_type;\n+\n+      switch (c_kind)\n+\t{\n+\tcase OMP_CLAUSE_SHARED:\n+\t  name = \"shared\";\n+\t  need_implicitly_determined = true;\n+\t  break;\n+\tcase OMP_CLAUSE_PRIVATE:\n+\t  name = \"private\";\n+\t  need_complete_non_reference = true;\n+\t  need_default_ctor = true;\n+\t  need_implicitly_determined = true;\n+\t  break;\n+\tcase OMP_CLAUSE_FIRSTPRIVATE:\n+\t  name = \"firstprivate\";\n+\t  need_complete_non_reference = true;\n+\t  need_copy_ctor = true;\n+\t  need_implicitly_determined = true;\n+\t  break;\n+\tcase OMP_CLAUSE_LASTPRIVATE:\n+\t  name = \"lastprivate\";\n+\t  need_complete_non_reference = true;\n+\t  need_copy_assignment = true;\n+\t  need_implicitly_determined = true;\n+\t  break;\n+\tcase OMP_CLAUSE_REDUCTION:\n+\t  name = \"reduction\";\n+\t  need_implicitly_determined = true;\n+\t  break;\n+\tcase OMP_CLAUSE_COPYPRIVATE:\n+\t  name = \"copyprivate\";\n+\t  need_copy_assignment = true;\n+\t  break;\n+\tcase OMP_CLAUSE_COPYIN:\n+\t  name = \"copyin\";\n+\t  need_copy_assignment = true;\n+\t  break;\n+\tdefault:\n+\t  pc = &OMP_CLAUSE_CHAIN (c);\n+\t  continue;\n+\t}\n+\n+      t = OMP_CLAUSE_DECL (c);\n+      if (processing_template_decl\n+\t  && TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n+\t{\n+\t  pc = &OMP_CLAUSE_CHAIN (c);\n+\t  continue;\n+\t}\n+\n+      switch (c_kind)\n+\t{\n+\tcase OMP_CLAUSE_LASTPRIVATE:\n+\t  if (!bitmap_bit_p (&firstprivate_head, DECL_UID (t)))\n+\t    need_default_ctor = true;\n+\t  break;\n+\n+\tcase OMP_CLAUSE_REDUCTION:\n+\t  if (AGGREGATE_TYPE_P (TREE_TYPE (t))\n+\t      || POINTER_TYPE_P (TREE_TYPE (t)))\n+\t    {\n+\t      error (\"%qE has invalid type for %<reduction%>\", t);\n+\t      remove = true;\n+\t    }\n+\t  else if (FLOAT_TYPE_P (TREE_TYPE (t)))\n+\t    {\n+\t      enum tree_code r_code = OMP_CLAUSE_REDUCTION_CODE (c);\n+\t      switch (r_code)\n+\t\t{\n+\t\tcase PLUS_EXPR:\n+\t\tcase MULT_EXPR:\n+\t\tcase MINUS_EXPR:\n+\t\t  break;\n+\t\tdefault:\n+\t\t  error (\"%qE has invalid type for %<reduction(%s)%>\",\n+\t\t\t t, operator_name_info[r_code].name);\n+\t\t  remove = true;\n+\t\t}\n+\t    }\n+\t  break;\n+\n+\tcase OMP_CLAUSE_COPYIN:\n+\t  if (TREE_CODE (t) != VAR_DECL || !DECL_THREAD_LOCAL_P (t))\n+\t    {\n+\t      error (\"%qE must be %<threadprivate%> for %<copyin%>\", t);\n+\t      remove = true;\n+\t    }\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+\n+      if (need_complete_non_reference)\n+\t{\n+\t  t = require_complete_type (t);\n+\t  if (t == error_mark_node)\n+\t    remove = true;\n+\t  else if (TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE)\n+\t    {\n+\t      error (\"%qE has reference type for %qs\", t, name);\n+\t      remove = true;\n+\t    }\n+\t}\n+      if (need_implicitly_determined)\n+\t{\n+\t  const char *share_name = NULL;\n+\n+\t  if (TREE_CODE (t) == VAR_DECL && DECL_THREAD_LOCAL_P (t))\n+\t    share_name = \"threadprivate\";\n+\t  else switch (cxx_omp_predetermined_sharing (t))\n+\t    {\n+\t    case OMP_CLAUSE_DEFAULT_UNSPECIFIED:\n+\t      break;\n+\t    case OMP_CLAUSE_DEFAULT_SHARED:\n+\t      share_name = \"shared\";\n+\t      break;\n+\t    case OMP_CLAUSE_DEFAULT_PRIVATE:\n+\t      share_name = \"private\";\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t  if (share_name)\n+\t    {\n+\t      error (\"%qE is predetermined %qs for %qs\",\n+\t\t     t, share_name, name);\n+\t      remove = true;\n+\t    }\n+\t}\n+\n+      /* We're interested in the base element, not arrays.  */\n+      inner_type = type = TREE_TYPE (t);\n+      while (TREE_CODE (inner_type) == ARRAY_TYPE)\n+\tinner_type = TREE_TYPE (inner_type);\n+\n+      /* Check for special function availablity by building a call to one.\n+\t Save the results, because later we won't be in the right context\n+\t for making these queries.  */\n+      if (CLASS_TYPE_P (inner_type)\n+\t  && (need_default_ctor || need_copy_ctor || need_copy_assignment))\n+\t{\n+\t  int save_errorcount = errorcount;\n+\t  tree info;\n+\n+\t  /* Always allocate 3 elements for simplicity.  These are the\n+\t     function decls for the ctor, dtor, and assignment op.\n+\t     This layout is known to the three lang hooks,\n+\t     cxx_omp_clause_default_init, cxx_omp_clause_copy_init,\n+\t     and cxx_omp_clause_assign_op.  */\n+\t  info = make_tree_vec (3);\n+\t  CP_OMP_CLAUSE_INFO (c) = info;\n+\n+\t  if (need_default_ctor\n+\t      || (need_copy_ctor\n+\t\t  && !TYPE_HAS_TRIVIAL_INIT_REF (inner_type)))\n+\t    {\n+\t      if (need_default_ctor)\n+\t\tt = NULL;\n+\t      else\n+\t\t{\n+\t\t  t = build_int_cst (build_pointer_type (inner_type), 0);\n+\t\t  t = build1 (INDIRECT_REF, inner_type, t);\n+\t\t  t = build_tree_list (NULL, t);\n+\t\t}\n+\t      t = build_special_member_call (NULL_TREE,\n+\t\t\t\t\t     complete_ctor_identifier,\n+\t\t\t\t\t     t, inner_type, LOOKUP_NORMAL);\n+\t      t = get_callee_fndecl (t);\n+\t      TREE_VEC_ELT (info, 0) = t;\n+\t    }\n+\n+\t  if ((need_default_ctor || need_copy_ctor)\n+\t      && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (inner_type))\n+\t    {\n+\t      t = build_int_cst (build_pointer_type (inner_type), 0);\n+\t      t = build1 (INDIRECT_REF, inner_type, t);\n+\t      t = build_special_member_call (t, complete_dtor_identifier,\n+\t\t\t\t\t     NULL, inner_type, LOOKUP_NORMAL);\n+\t      t = get_callee_fndecl (t);\n+\t      TREE_VEC_ELT (info, 1) = t;\n+\t    }\n+\n+\t  if (need_copy_assignment\n+\t      && !TYPE_HAS_TRIVIAL_ASSIGN_REF (inner_type))\n+\t    {\n+\t      t = build_int_cst (build_pointer_type (inner_type), 0);\n+\t      t = build1 (INDIRECT_REF, inner_type, t);\n+\t      t = build_special_member_call (t, ansi_assopname (NOP_EXPR),\n+\t\t\t\t\t     build_tree_list (NULL, t),\n+\t\t\t\t\t     inner_type, LOOKUP_NORMAL);\n+\n+\t      /* We'll have called convert_from_reference on the call, which\n+\t\t may well have added an indirect_ref.  It's unneeded here, \n+\t\t and in the way, so kill it.  */\n+\t      if (TREE_CODE (t) == INDIRECT_REF)\n+\t\tt = TREE_OPERAND (t, 0);\n+\n+\t      t = get_callee_fndecl (t);\n+\t      TREE_VEC_ELT (info, 2) = t;\n+\t    }\n+\n+\t  if (errorcount != save_errorcount)\n+\t    remove = true;\n+\t}\n+\n+      if (remove)\n+\t*pc = OMP_CLAUSE_CHAIN (c);\n+      else\n+\tpc = &OMP_CLAUSE_CHAIN (c);\n+    }\n+\n+  bitmap_obstack_release (NULL);\n+  return clauses;\n+}\n+\n+/* For all variables in the tree_list VARS, mark them as thread local.  */\n+\n+void\n+finish_omp_threadprivate (tree vars)\n+{\n+  tree t;\n+\n+  /* Mark every variable in VARS to be assigned thread local storage.  */\n+  for (t = vars; t; t = TREE_CHAIN (t))\n+    {\n+      tree v = TREE_PURPOSE (t);\n+\n+      /* If V had already been marked threadprivate, it doesn't matter\n+\t whether it had been used prior to this point.  */\n+      if (TREE_USED (v)\n+\t  && (DECL_LANG_SPECIFIC (v) == NULL\n+\t      || !CP_DECL_THREADPRIVATE_P (v)))\n+\terror (\"%qE declared %<threadprivate%> after first use\", v);\n+      else if (! TREE_STATIC (v) && ! DECL_EXTERNAL (v))\n+\terror (\"automatic variable %qE cannot be %<threadprivate%>\", v);\n+      else if (! COMPLETE_TYPE_P (TREE_TYPE (v)))\n+\terror (\"%<threadprivate%> %qE has incomplete type\", v);\n+      else if (TREE_STATIC (v) && TYPE_P (CP_DECL_CONTEXT (v)))\n+\terror (\"%<threadprivate%> %qE is not file, namespace \"\n+\t       \"or block scope variable\", v);\n+      else\n+\t{\n+\t  /* Allocate a LANG_SPECIFIC structure for V, if needed.  */\n+\t  if (DECL_LANG_SPECIFIC (v) == NULL)\n+\t    {\n+\t      retrofit_lang_decl (v);\n+\n+\t      /* Make sure that DECL_DISCRIMINATOR_P continues to be true\n+\t\t after the allocation of the lang_decl structure.  */\n+\t      if (DECL_DISCRIMINATOR_P (v))\n+\t\tDECL_LANG_SPECIFIC (v)->decl_flags.u2sel = 1;\n+\t    }\n+\n+\t  if (! DECL_THREAD_LOCAL_P (v))\n+\t    {\n+\t      DECL_TLS_MODEL (v) = decl_default_tls_model (v);\n+\t      /* If rtl has been already set for this var, call\n+\t\t make_decl_rtl once again, so that encode_section_info\n+\t\t has a chance to look at the new decl flags.  */\n+\t      if (DECL_RTL_SET_P (v))\n+\t\tmake_decl_rtl (v);\n+\t    }\n+\t  CP_DECL_THREADPRIVATE_P (v) = 1;\n+\t}\n+    }\n+}\n+\n+/* Build an OpenMP structured block.  */\n+\n+tree\n+begin_omp_structured_block (void)\n+{\n+  return do_pushlevel (sk_omp);\n+}\n+\n+tree\n+finish_omp_structured_block (tree block)\n+{\n+  return do_poplevel (block);\n+}\n+\n+/* Similarly, except force the retension of the BLOCK.  */\n+\n+tree\n+begin_omp_parallel (void)\n+{\n+  keep_next_level (true);\n+  return begin_omp_structured_block ();\n+}\n+\n+tree\n+finish_omp_parallel (tree clauses, tree body)\n+{\n+  tree stmt;\n+\n+  body = finish_omp_structured_block (body);\n \n-/* Perform initialization related to this module.  */\n+  stmt = make_node (OMP_PARALLEL);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OMP_PARALLEL_CLAUSES (stmt) = clauses;\n+  OMP_PARALLEL_BODY (stmt) = body;\n \n+  return add_stmt (stmt);\n+}\n+\n+/* Build and validate an OMP_FOR statement.  CLAUSES, BODY, COND, INCR\n+   are directly for their associated operands in the statement.  DECL\n+   and INIT are a combo; if DECL is NULL then INIT ought to be a\n+   MODIFY_EXPR, and the DECL should be extracted.  PRE_BODY are\n+   optional statements that need to go before the loop into its\n+   sk_omp scope.  */\n+\n+tree\n+finish_omp_for (location_t locus, tree decl, tree init, tree cond,\n+\t\ttree incr, tree body, tree pre_body)\n+{\n+  if (decl == NULL)\n+    {\n+      if (init != NULL)\n+\tswitch (TREE_CODE (init))\n+\t  {\n+\t  case MODIFY_EXPR:\n+\t    decl = TREE_OPERAND (init, 0);\n+\t    init = TREE_OPERAND (init, 1);\n+\t    break;\n+\t  case MODOP_EXPR:\n+\t    if (TREE_CODE (TREE_OPERAND (init, 1)) == NOP_EXPR)\n+\t      {\n+\t\tdecl = TREE_OPERAND (init, 0);\n+\t\tinit = TREE_OPERAND (init, 2);\n+\t      }\n+\t    break;\n+\t  default:\n+\t    break;\n+\t  }\n+\n+      if (decl == NULL)\n+\t{\n+\t  error (\"expected iteration declaration or initialization\");\n+\t  return NULL;\n+\t}\n+    }\n+\n+  if (type_dependent_expression_p (decl)\n+      || type_dependent_expression_p (init)\n+      || (cond && type_dependent_expression_p (cond))\n+      || (incr && type_dependent_expression_p (incr)))\n+    {\n+      tree stmt;\n+\n+      if (cond == NULL)\n+\t{\n+\t  error (\"%Hmissing controlling predicate\", &locus);\n+\t  return NULL;\n+\t}\n+\n+      if (incr == NULL)\n+\t{\n+\t  error (\"%Hmissing increment expression\", &locus);\n+\t  return NULL;\n+\t}\n+\n+      stmt = make_node (OMP_FOR);\n+\n+      /* This is really just a place-holder.  We'll be decomposing this\n+\t again and going through the build_modify_expr path below when\n+\t we instantiate the thing.  */\n+      init = build2 (MODIFY_EXPR, void_type_node, decl, init);\n+\n+      TREE_TYPE (stmt) = void_type_node;\n+      OMP_FOR_INIT (stmt) = init;\n+      OMP_FOR_COND (stmt) = cond;\n+      OMP_FOR_INCR (stmt) = incr;\n+      OMP_FOR_BODY (stmt) = body;\n+      OMP_FOR_PRE_BODY (stmt) = pre_body;\n+\n+      SET_EXPR_LOCATION (stmt, locus);\n+      return add_stmt (stmt);\n+    }\n+\n+  if (!DECL_P (decl))\n+    {\n+      error (\"expected iteration declaration or initialization\");\n+      return NULL;\n+    }\n+\n+  if (pre_body == NULL || IS_EMPTY_STMT (pre_body))\n+    pre_body = NULL;\n+  else if (! processing_template_decl)\n+    {\n+      add_stmt (pre_body);\n+      pre_body = NULL;\n+    }\n+  init = build_modify_expr (decl, NOP_EXPR, init);\n+  return c_finish_omp_for (locus, decl, init, cond, incr, body, pre_body);\n+}\n+\n+void\n+finish_omp_atomic (enum tree_code code, tree lhs, tree rhs)\n+{\n+  /* If either of the operands are dependent, we can't do semantic \n+     processing yet.  Stuff the values away for now.  We cheat a bit\n+     and use the same tree code for this, even though the operands \n+     are of totally different form, thus we need to remember which\n+     statements are which, thus the lang_flag bit.  */\n+  /* ??? We ought to be using type_dependent_expression_p, but the\n+     invocation of build_modify_expr in c_finish_omp_atomic can result\n+     in the creation of CONVERT_EXPRs, which are not handled by\n+     tsubst_copy_and_build.  */\n+  if (uses_template_parms (lhs) || uses_template_parms (rhs))\n+    {\n+      tree stmt = build2 (OMP_ATOMIC, void_type_node, lhs, rhs);\n+      OMP_ATOMIC_DEPENDENT_P (stmt) = 1;\n+      OMP_ATOMIC_CODE (stmt) = code;\n+      add_stmt (stmt);\n+    }\n+  else\n+    c_finish_omp_atomic (code, lhs, rhs);\n+}\n+\n+void\n+finish_omp_barrier (void)\n+{\n+  tree fn = built_in_decls[BUILT_IN_GOMP_BARRIER];\n+  tree stmt = finish_call_expr (fn, NULL, false, false);\n+  finish_expr_stmt (stmt);\n+}\n+\n+void\n+finish_omp_flush (void)\n+{\n+  tree fn = built_in_decls[BUILT_IN_SYNCHRONIZE];\n+  tree stmt = finish_call_expr (fn, NULL, false, false);\n+  finish_expr_stmt (stmt);\n+}\n+\n+/* True if OpenMP sharing attribute of DECL is predetermined.  */\n+\n+enum omp_clause_default_kind\n+cxx_omp_predetermined_sharing (tree decl)\n+{\n+  enum omp_clause_default_kind kind;\n+\n+  kind = c_omp_predetermined_sharing (decl);\n+  if (kind != OMP_CLAUSE_DEFAULT_UNSPECIFIED)\n+    return kind;\n+\n+  /* Static data members are predetermined as shared.  */\n+  if (TREE_STATIC (decl))\n+    {\n+      tree ctx = CP_DECL_CONTEXT (decl);\n+      if (TYPE_P (ctx) && IS_AGGR_TYPE (ctx))\n+\treturn OMP_CLAUSE_DEFAULT_SHARED;\n+    }\n+\n+  return OMP_CLAUSE_DEFAULT_UNSPECIFIED;\n+}\n+\f\n void\n init_cp_semantics (void)\n {"}, {"sha": "677fd313f4eca7b1bf195a0317b2817879f807a9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -1,3 +1,8 @@\n+2006-03-09  Diego Novillo  <dnovillo@redhat.com>\n+\n+        * gcc/testsuite/g++.dg/gomp: New directory.\n+        * gcc/testsuite/g++.dg/dg.exp: Gather tests in gomp/.\n+\n 2006-03-09  Roger Sayle  <roger@eyesopen.com>\n \t    Eric Botcazou  <ebotcazou@libertysurf.fr>\n "}, {"sha": "5ecb161bee7d7f507136c3334c96596f6bbb4861", "filename": "gcc/testsuite/g++.dg/dg.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -40,6 +40,7 @@ set tests [prune $tests $srcdir/$subdir/pch/*]\n set tests [prune $tests $srcdir/$subdir/special/*]\n set tests [prune $tests $srcdir/$subdir/tls/*]\n set tests [prune $tests $srcdir/$subdir/vect/*]\n+set tests [prune $tests $srcdir/$subdir/gomp/*]\n \n # Main loop.\n dg-runtest $tests \"\" $DEFAULT_CXXFLAGS"}, {"sha": "3e4bc569ba7fdb1db0fa101d110efe43238fe2db", "filename": "gcc/testsuite/g++.dg/gomp/atomic-1.C", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,99 @@\n+/* { dg-do compile } */\n+\n+int x;\n+volatile int y;\n+volatile unsigned char z;\n+\n+void f1(void)\n+{\n+  #pragma omp atomic\n+    x++;\n+  #pragma omp atomic\n+    x--;\n+  #pragma omp atomic\n+    ++x;\n+  #pragma omp atomic\n+    --x;\n+  #pragma omp atomic\n+    x += 1;\n+  #pragma omp atomic\n+    x -= y;\n+  #pragma omp atomic\n+    x |= 1;\n+  #pragma omp atomic\n+    x &= 1;\n+  #pragma omp atomic\n+    x ^= 1;\n+  #pragma omp atomic\n+    x *= 3;\n+  #pragma omp atomic\n+    x /= 3;\n+  #pragma omp atomic\n+    x /= 3;\n+  #pragma omp atomic\n+    x <<= 3;\n+  #pragma omp atomic\n+    x >>= 3;\n+}\n+\n+void f2(void)\n+{\n+  #pragma omp atomic\n+    y++;\n+  #pragma omp atomic\n+    y--;\n+  #pragma omp atomic\n+    ++y;\n+  #pragma omp atomic\n+    --y;\n+  #pragma omp atomic\n+    y += 1;\n+  #pragma omp atomic\n+    y -= x;\n+  #pragma omp atomic\n+    y |= 1;\n+  #pragma omp atomic\n+    y &= 1;\n+  #pragma omp atomic\n+    y ^= 1;\n+  #pragma omp atomic\n+    y *= 3;\n+  #pragma omp atomic\n+    y /= 3;\n+  #pragma omp atomic\n+    y /= 3;\n+  #pragma omp atomic\n+    y <<= 3;\n+  #pragma omp atomic\n+    y >>= 3;\n+}\n+\n+void f3(void)\n+{\n+  #pragma omp atomic\n+    z++;\n+  #pragma omp atomic\n+    z--;\n+  #pragma omp atomic\n+    ++z;\n+  #pragma omp atomic\n+    --z;\n+  #pragma omp atomic\n+    z += 1;\n+  #pragma omp atomic\n+    z |= 1;\n+  #pragma omp atomic\n+    z &= 1;\n+  #pragma omp atomic\n+    z ^= 1;\n+  #pragma omp atomic\n+    z *= 3;\n+  #pragma omp atomic\n+    z /= 3;\n+  #pragma omp atomic\n+    z /= 3;\n+  #pragma omp atomic\n+    z <<= 3;\n+  #pragma omp atomic\n+    z >>= 3;\n+}"}, {"sha": "720ec9e8ba0dc1690e733af9a451f42f3a0a1505", "filename": "gcc/testsuite/g++.dg/gomp/atomic-2.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-2.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+\n+float x, y;\n+\n+void f1(void)\n+{\n+  #pragma omp atomic\n+    x++;\n+  #pragma omp atomic\n+    x--;\n+  #pragma omp atomic\n+    ++x;\n+  #pragma omp atomic\n+    --x;\n+  #pragma omp atomic\n+    x += 1;\n+  #pragma omp atomic\n+    x -= y;\n+  #pragma omp atomic\n+    x *= 3;\n+  #pragma omp atomic\n+    x /= 3;\n+}"}, {"sha": "0c612a160612c3c252b89205ebb7a4b475b6bef3", "filename": "gcc/testsuite/g++.dg/gomp/atomic-3.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-3.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-gimple\" } */\n+\n+int *xyzzy;\n+\n+void f1(void)\n+{\n+  #pragma omp atomic\n+    xyzzy++;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"xyzzy, 4\" 1 \"gimple\" { target i?86-*-* x86_64-*-* ia64-*-* powerpc*-*-* alpha*-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"gimple\" } } */"}, {"sha": "7f27370d535b6f1f1c360d25195ee1e6b2631395", "filename": "gcc/testsuite/g++.dg/gomp/atomic-4.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-4.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+\n+int a[4];\n+int *p;\n+struct S { int x; int y[4]; } s;\n+int *bar(void);\n+\n+void f1(void)\n+{\n+  #pragma omp atomic\n+    a[4] += 1;\n+  #pragma omp atomic\n+    *p += 1;\n+  #pragma omp atomic\n+    s.x += 1;\n+  #pragma omp atomic\n+    s.y[*p] += 1;\n+  #pragma omp atomic\n+    s.y[*p] *= 42;\n+  #pragma omp atomic\n+    *bar() += 1;\n+  #pragma omp atomic\n+    *bar() *= 42;\n+}"}, {"sha": "0f750c73d742c49ff3bd3757f90d60fcb1545fd6", "filename": "gcc/testsuite/g++.dg/gomp/atomic-5.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-5.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+\n+int x;\n+const int y = 0;\n+int bar(void);\n+\n+void f1(void)\n+{\n+  #pragma omp atomic\n+    x %= 2;\t\t/* { dg-error \"invalid operator\" } */\n+  #pragma omp atomic\n+    x = x + 1;\t\t/* { dg-error \"invalid operator\" } */\n+  #pragma omp atomic\n+    x = 1;\t\t/* { dg-error \"invalid operator\" } */\n+  #pragma omp atomic\n+    ++y;\t\t/* { dg-error \"read-only variable\" } */\n+  #pragma omp atomic\n+    y--;\t\t/* { dg-error \"read-only variable\" } */\n+  #pragma omp atomic\n+    y += 1;\t\t/* { dg-error \"read-only variable\" } */\n+  #pragma omp atomic\n+    bar();\t\t/* { dg-error \"invalid operator\" } */\n+  #pragma omp atomic\n+    bar() += 1;\t\t/* { dg-error \"lvalue required\" } */\n+  #pragma omp atomic a\t/* { dg-error \"expected end of line\" } */\n+    x++;\n+  #pragma omp atomic\n+    ;\t\t\t/* { dg-error \"expected primary-expression\" } */\n+  #pragma omp atomic\n+  #pragma omp atomic\t/* { dg-error \"not allowed\" } */\n+    ;\n+  /* Check that we didn't get stuck on the pragma eol marker.  */\n+  undef;\t\t/* { dg-error \"\" } */\n+}"}, {"sha": "52ac40f2a212aea8ad140a3928372ae4646986af", "filename": "gcc/testsuite/g++.dg/gomp/atomic-6.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-6.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,11 @@\n+// { dg-do compile }\n+// { dg-options \"-w -fopenmp\" }\n+\n+int x[10], z;\n+double y[10];\n+\n+void f1(void)\n+{\n+  #pragma omp atomic\n+    x[z] /= y[z];\n+}"}, {"sha": "612e97f453039bfcadd32e28f95ffdb84379edfa", "filename": "gcc/testsuite/g++.dg/gomp/atomic-7.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-7.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+\n+double x, y;\n+\n+void f2(void)\n+{\n+  #pragma omp atomic\n+    y++;\n+  #pragma omp atomic\n+    y--;\n+  #pragma omp atomic\n+    ++y;\n+  #pragma omp atomic\n+    --y;\n+  #pragma omp atomic\n+    y += 1;\n+  #pragma omp atomic\n+    y -= x;\n+  #pragma omp atomic\n+    y *= 3;\n+  #pragma omp atomic\n+    y /= 3;\n+}"}, {"sha": "2f04151f0ed854ca5fa89e898978cb141c4df15d", "filename": "gcc/testsuite/g++.dg/gomp/atomic-8.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-8.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+\n+long double z;\n+\n+void f3(void)\n+{\n+  #pragma omp atomic\n+    z++;\n+  #pragma omp atomic\n+    z--;\n+  #pragma omp atomic\n+    ++z;\n+  #pragma omp atomic\n+    --z;\n+  #pragma omp atomic\n+    z += 1;\n+  #pragma omp atomic\n+    z *= 3;\n+  #pragma omp atomic\n+    z /= 3;\n+}"}, {"sha": "128e9df5e4aef5dbdc4ef4603884308554a05593", "filename": "gcc/testsuite/g++.dg/gomp/atomic-9.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fatomic-9.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-gimple\" } */\n+\n+volatile int *bar(void);\n+\n+void f1(void)\n+{\n+  #pragma omp atomic\n+    *bar() += 1;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__sync_fetch_and_add\" 1 \"gimple\" { target i?86-*-* x86_64-*-* ia64-*-* powerpc*-*-* alpha*-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"gimple\" } } */"}, {"sha": "10ca553f94bccc94d3a9ae75c510a5e0693dd4b3", "filename": "gcc/testsuite/g++.dg/gomp/barrier-1.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fbarrier-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fbarrier-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fbarrier-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-gimple\" } */\n+\n+void f1(void)\n+{\n+  #pragma omp barrier\n+}\n+\n+void f2(bool p)\n+{\n+  if (p)\n+    {\n+      #pragma omp barrier\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_barrier\" 2 \"gimple\" } } */\n+/* { dg-final { cleanup-tree-dump \"gimple\" } } */"}, {"sha": "1d929d26dde4118e9d03368a9a8bb8a2f37fd099", "filename": "gcc/testsuite/g++.dg/gomp/barrier-2.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fbarrier-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fbarrier-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fbarrier-2.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,12 @@\n+// { dg-do compile }\n+\n+void f1(void)\n+{\n+  #pragma omp barrier a\t\t// { dg-error \"expected end of line\" }\n+}\n+\n+void f3(bool p)\n+{\n+  if (p)\n+    #pragma omp barrier\t\t// { dg-error \"compound statements\" }\n+}\t\t\t\t// { dg-error \"\" }"}, {"sha": "1be534d59df32584620b534f04eabb0dec47c1e8", "filename": "gcc/testsuite/g++.dg/gomp/block-0.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-0.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,33 @@\n+// { dg-do compile }\n+// { dg-options \"-fopenmp -fdump-tree-omplower\" }\n+\n+void bar();\n+void foo()\n+{\n+  #pragma omp critical\n+    bar ();\n+  #pragma omp master\n+    bar ();\n+  #pragma omp single\n+    bar ();\n+  #pragma omp for\n+  for (int i = 0; i < 10; ++i)\n+    bar ();\n+  #pragma omp sections\n+    { bar(); }\n+  #pragma omp parallel\n+    bar ();\n+  #pragma omp parallel for\n+  for (int i = 0; i < 10; ++i)\n+    bar ();\n+  #pragma omp parallel sections\n+    {\n+      bar ();\n+      bar ();\n+    #pragma omp section\n+      bar ();\n+    }\n+}\n+\n+// { dg-final { scan-tree-dump-times \"terminate\" 8 \"omplower\" } }\n+// { dg-final { cleanup-tree-dump \"omplower\" } }"}, {"sha": "50a8c0e9ead48fbd6601a360b6a55a5e85783a1e", "filename": "gcc/testsuite/g++.dg/gomp/block-1.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,22 @@\n+// { dg-do compile }\n+\n+void foo()\n+{\n+  bad1:\t\t\t\t// { dg-error \"jump to label\" }\n+  #pragma omp parallel\n+    goto bad1;\t\t\t// { dg-error \"from here|exits OpenMP\" }\n+\n+  goto bad2;\t\t\t// { dg-error \"from here\" }\n+  #pragma omp parallel\n+    {\n+      bad2: ;\t\t\t// { dg-error \"jump to label|enters OpenMP\" }\n+    }\n+\n+  #pragma omp parallel\n+    {\n+      int i;\n+      goto ok1;\n+      for (i = 0; i < 10; ++i)\n+\t{ ok1: break; }\n+    }\n+}"}, {"sha": "b273c1f297c1d6354f3792323689ac6ab6583e39", "filename": "gcc/testsuite/g++.dg/gomp/block-10.C", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-10.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,40 @@\n+// { dg-do compile }\n+\n+void foo(int i)\n+{\n+  int j;\n+  switch (i)\n+  {\n+  #pragma omp parallel\n+    { case 0:; }\t// { dg-error \"jump|enters\" }\n+  }\n+  switch (i)\n+  {\n+  #pragma omp for\n+    for (j = 0; j < 10; ++ j)\n+      { case 1:; }\t// { dg-error \"jump|enters\" }\n+  }\n+  switch (i)\n+  {\n+  #pragma omp critical\n+    { case 2:; }\t// { dg-error \"jump|enters\" }\n+  }\n+  switch (i)\n+  {\n+  #pragma omp master\n+    { case 3:; }\t// { dg-error \"jump|enters\" }\n+  }\n+  switch (i)\n+  {\n+  #pragma omp sections\n+    { case 4:;\t\t// { dg-error \"jump|enters\" }\n+    #pragma omp section\n+       { case 5:; }\t// { dg-error \"jump|enters\" }\n+    }\n+  }\n+  switch (i)\n+  {\n+  #pragma omp ordered\n+    { default:; }\t// { dg-error \"jump|enters\" }\n+  }\n+}"}, {"sha": "c2800061b6e78b2ca523b536021e1a3bf41dafb9", "filename": "gcc/testsuite/g++.dg/gomp/block-11.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-11.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,19 @@\n+/* PR c++/24516 */\n+/* { dg-do compile } */\n+\n+void\n+bar (int *p)\n+{\n+  int m;\n+#pragma omp parallel for\n+  for (m = 0; m < 1000; ++m)\n+    switch (p[m])\n+      {\n+      case 1:\n+\tp[m] = 2;\n+\tbreak;\n+      default:\n+\tp[m] = 3;\n+\tbreak;\n+      }\n+}"}, {"sha": "621a90d7bc4ec9caed2e24ada5d788922112c45d", "filename": "gcc/testsuite/g++.dg/gomp/block-2.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-2.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,32 @@\n+// { dg-do compile }\n+\n+void foo()\n+{\n+  int i, j;\n+\n+  #pragma omp for\n+  for (i = 0; i < 10; ++i)\n+    break;\t\t\t// { dg-error \"break\" }\n+\n+  bad1:\t\t\t\t// { dg-error \"jump to label\" }\n+  #pragma omp for\n+  for (i = 0; i < 10; ++i)\n+    goto bad1;\t\t\t// { dg-error \"from here|exits OpenMP\" }\n+\n+  goto bad2;\t\t\t// { dg-error \"from here\" }\n+  #pragma omp for\n+  for (i = 0; i < 10; ++i)\n+    {\n+      bad2: ;\t\t\t// { dg-error \"jump|enters OpenMP\" }\n+    }\n+\n+  #pragma omp for\n+  for (i = 0; i < 10; ++i)\n+    for (j = 0; j < 10; ++j)\n+      if (i == j)\n+\tbreak;\n+\n+  #pragma omp for\n+  for (i = 0; i < 10; ++i)\n+    continue;\n+}"}, {"sha": "8e036e45364df84265b24b4f98328fefd28d3210", "filename": "gcc/testsuite/g++.dg/gomp/block-3.C", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-3.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,57 @@\n+// { dg-do compile }\n+\n+extern int test(int);\n+void foo()\n+{\n+  int i;\n+\n+  for (i = 0; i < 10; ++i)\n+    {\n+      #pragma omp sections\n+      {\n+\tcontinue;\t\t// { dg-error \"invalid exit\" }\n+      }\n+    }\n+\n+  #pragma omp sections\n+    {\n+    #pragma omp section\n+      { bad1: ; }\t\t// { dg-error \"jump to label\" }\n+    #pragma omp section\n+      goto bad1;\t\t// { dg-error \"from here|enters OpenMP\" }\n+    }\n+\n+  #pragma omp sections\n+    {\n+      goto bad2;\t\t// { dg-error \"from here\" }\n+    }\n+  bad2:;\t\t\t// { dg-error \"jump|exits OpenMP\" }\n+\n+  goto bad3;\t\t\t// { dg-error \"from here\" }\n+  #pragma omp sections\n+    {\n+      bad3: ;\t\t\t// { dg-error \"jump|enters OpenMP\" }\n+    }\n+\n+  #pragma omp sections\n+    {\n+      goto ok1;\n+      ok1:;\n+\n+    #pragma omp section\n+      for (i = 0; i < 10; ++i)\n+\tif (test(i))\n+\t  break;\n+\telse\n+\t  continue;\n+\n+    #pragma omp section\n+      switch (i)\n+\t{\n+\tcase 0:\n+\t  break;\n+\tdefault:\n+\t  test(i);\n+\t}\n+    }\n+}"}, {"sha": "815d36b2e3950017b7915971a0012bca40c93bf1", "filename": "gcc/testsuite/g++.dg/gomp/block-4.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-4.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,9 @@\n+// { dg-do compile }\n+\n+void foo()\n+{\n+  #pragma omp critical\n+    {\n+      return;\t\t// { dg-error \"invalid exit\" }\n+    }\n+}"}, {"sha": "67ed72c8daafeeb298ba501517d3915f83c8a2bd", "filename": "gcc/testsuite/g++.dg/gomp/block-5.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-5.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do compile }\n+\n+void foo()\n+{\n+  #pragma omp master\n+    {\n+      goto bad1;\t// { dg-error \"from here\" }\n+    }\n+\n+  #pragma omp master\n+    {\n+    bad1:\t\t// { dg-error \"jump|exits OpenMP\" }\n+      return;\t\t// { dg-error \"invalid exit\" }\n+    }\n+}"}, {"sha": "fa4c5eab5f4cbc6f2c5a61577ce79164bf526846", "filename": "gcc/testsuite/g++.dg/gomp/block-6.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-6.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,9 @@\n+// { dg-do compile }\n+\n+void foo()\n+{\n+  #pragma omp ordered\n+    {\n+      return;\t\t// { dg-error \"invalid exit\" }\n+    }\n+}"}, {"sha": "802b3b3a383feb89e70fc806e2bc2e5ea9acc824", "filename": "gcc/testsuite/g++.dg/gomp/block-7.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-7.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,20 @@\n+// { dg-do compile }\n+\n+void foo()\n+{\n+  int i, j;\n+  for (i = 0; i < 10; ++i)\n+    {\n+      #pragma omp for\n+      for (j = ({ continue; 0; });\t// { dg-error \"invalid exit\" }\n+\t   j < ({ continue; 10; });\t// { dg-error \"invalid exit\" }\n+\t   j += ({ continue; 1; }))\t// { dg-error \"invalid exit\" }\n+\tcontinue;\n+\n+      #pragma omp for\n+      for (j = ({ break; 0; });\t\t// { dg-error \"invalid exit\" }\n+\t   j < ({ break; 10; });\t// { dg-error \"invalid exit\" }\n+\t   j += ({ break; 1; }))\t// { dg-error \"invalid exit\" }\n+\tbreak;\t\t\t\t// { dg-error \"break\" }\n+    }\n+}"}, {"sha": "177acaa28c0426b2f0019886973941ab08e1c7c5", "filename": "gcc/testsuite/g++.dg/gomp/block-8.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-8.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,11 @@\n+// { dg-do compile }\n+// PR 24451\n+\n+int foo()\n+{\n+  int i;\n+\n+  #pragma omp parallel for\n+  for (i = 0; i < 10; ++i)\n+    return 0;\t\t\t// { dg-error \"invalid exit\" }\n+}"}, {"sha": "8012e5a7d46fca2ff1e74ba0b4712217717045a1", "filename": "gcc/testsuite/g++.dg/gomp/block-9.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-9.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,25 @@\n+// { dg-do compile }\n+\n+void foo(int i)\n+{\n+  int j;\n+  switch (i)\n+  {\n+  #pragma omp parallel\n+    { case 0:; }\t\t// { dg-error \"jump|enters\" }\n+  #pragma omp for\n+    for (j = 0; j < 10; ++ j)\n+      { case 1:; }\t\t// { dg-error \"jump|enters\" }\n+  #pragma omp critical\n+    { case 2:; }\t\t// { dg-error \"jump|enters\" }\n+  #pragma omp master\n+    { case 3:; }\t\t// { dg-error \"jump|enters\" }\n+  #pragma omp sections\n+    { case 4:;\t\t\t// { dg-error \"jump|enters\" }\n+    #pragma omp section\n+       { case 5:; }\t\t// { dg-error \"jump|enters\" }\n+    }\n+  #pragma omp ordered\n+    { default:; }\t\t// { dg-error \"jump|enters\" }\n+  }\n+}"}, {"sha": "76683ecf6ee94c42d2785e322fe252a8be1e0410", "filename": "gcc/testsuite/g++.dg/gomp/clause-1.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,32 @@\n+// { dg-do compile }\n+\n+struct T\n+{\n+  int n;\n+\n+  void test();\n+};\n+\n+void T::test()\n+{\n+  #pragma omp parallel private(n)\t// { dg-error \"T::n\" }\n+    n = 1;\n+\n+  #pragma omp parallel shared(n)\t// { dg-error \"T::n\" }\n+    n = 1;\n+\n+  #pragma omp parallel firstprivate(n)\t// { dg-error \"T::n\" }\n+    n = 1;\n+\n+  #pragma omp sections lastprivate(n)\t// { dg-error \"T::n\" }\n+    { n = 1; }\n+\n+  #pragma omp parallel reduction(+:n)\t// { dg-error \"T::n\" }\n+    n = 1;\n+\n+  #pragma omp single copyprivate(n)\t// { dg-error \"T::n\" }\n+    n = 1;\n+\n+  #pragma omp parallel copyin(n)\t// { dg-error \"T::n\" }\n+    n = 1;\n+}"}, {"sha": "450419ad6cd4250893ebaf9c9c9f781c9edf048d", "filename": "gcc/testsuite/g++.dg/gomp/clause-2.C", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-2.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,38 @@\n+// { dg-do compile }\n+\n+struct A { int a; };\n+struct B { B(); };\n+struct C { C(); C(const C&); };\n+struct D { D& operator=(const D&); };\n+\n+class E { private: E(); public: E(int); };\t// { dg-error \"private\" }\n+class F { private: F(const F&); public: F(); };\t// { dg-error \"private\" }\n+class G { private: G& operator=(const G&); };\t// { dg-error \"private\" }\n+\n+void bar();\n+void foo()\n+{\n+  A a; B b; C c; D d; E e(0); F f; G g;\n+\n+  #pragma omp parallel shared(a, b, c, d, e, f, g)\n+    bar();\n+\n+  #pragma omp parallel private(a, b, c, d, f, g)\n+    bar();\n+  #pragma omp parallel private(e)\t\t// { dg-error \"context\" }\n+    bar();\n+\n+  #pragma omp parallel firstprivate(a, b, c, d, e, g)\n+    bar();\n+  #pragma omp parallel firstprivate(f)\t\t// { dg-error \"context\" }\n+    bar();\n+\n+  #pragma omp parallel sections lastprivate(a, b, d, c, f)\n+    { bar(); }\n+  #pragma omp parallel sections lastprivate(e)\t// { dg-error \"context\" }\n+    { bar(); }\n+  #pragma omp parallel sections lastprivate(g)\t// { dg-error \"context\" }\n+    { bar(); }\n+  #pragma omp parallel sections firstprivate(e) lastprivate(e)\n+    { bar(); }\n+}"}, {"sha": "6b3d410a9334c442405287bd8889526dcd6ee69c", "filename": "gcc/testsuite/g++.dg/gomp/clause-3.C", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fclause-3.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,94 @@\n+// { dg-do compile }\n+// { dg-require-effective-target tls }\n+\n+#define p parallel\n+\n+extern void bar (void);\n+extern char q[]; // { dg-error \"has incomplete type\" }\n+int t;\n+#pragma omp threadprivate (t)\n+\n+void\n+foo (int x)\n+{\n+  char *p;\n+  struct S { int i; int j; } s;\n+  char a[32];\n+  double d;\n+  int i;\n+  const int c = 8;\n+#pragma omp p shared (x, x) // { dg-error \"more than once\" }\n+    ;\n+#pragma omp p private (x) private (x) // { dg-error \"more than once\" }\n+    ;\n+#pragma omp p shared (x) firstprivate (x) // { dg-error \"more than once\" }\n+    ;\n+#pragma omp p firstprivate (x, x) // { dg-error \"more than once\" }\n+    ;\n+#pragma omp p for shared (x) lastprivate (x) // { dg-error \"more than once\" }\n+  for (i = 0; i < 10; i++)\n+    ;\n+#pragma omp p for private (x) lastprivate (x) // { dg-error \"more than once\" }\n+  for (i = 0; i < 10; i++)\n+    ;\n+#pragma omp p for lastprivate (x, x) // { dg-error \"more than once\" }\n+  for (i = 0; i < 10; i++)\n+    ;\n+#pragma omp single private (x) copyprivate (x) // { dg-error \"more than once\" }\n+    ;\n+#pragma omp p shared (bar) // { dg-error \"is not a variable\" }\n+    ;\n+#pragma omp p private (bar) // { dg-error \"is not a variable\" }\n+    ;\n+#pragma omp p firstprivate (bar) // { dg-error \"is not a variable\" }\n+    ;\n+#pragma omp p reduction (+:p) // { dg-error \"has invalid type for\" }\n+    ;\n+#pragma omp p reduction (*:s) // { dg-error \"has invalid type for\" }\n+    ;\n+#pragma omp p reduction (-:a) // { dg-error \"has invalid type for\" }\n+    ;\n+  d = 0;\n+#pragma omp p reduction (*:d)\n+    ;\n+#pragma omp p reduction (|:d) // { dg-error \"has invalid type for\" }\n+    ;\n+#pragma omp p reduction (&&:d) // { dg-error \"has invalid type for\" }\n+    ;\n+#pragma omp p copyin (d) // { dg-error \"must be 'threadprivate'\" }\n+    ;\n+#pragma omp p copyin (x) // { dg-error \"must be 'threadprivate'\" }\n+    ;\n+#pragma omp p for firstprivate (x) lastprivate (x)\n+  for (i = 0; i < 10; i++)\n+    ;\n+#pragma omp p private (q) // { dg-error \"unspecified bounds\" }\n+    ;\n+#pragma omp p firstprivate (q) // { dg-error \"unspecified bounds\" }\n+    ;\n+#pragma omp p for lastprivate (q) // { dg-error \"unspecified bounds\" }\n+  for (i = 0; i < 10; i++)\n+    ;\n+#pragma omp p shared (t) // { dg-error \"predetermined 'threadprivate'\" }\n+    ;\n+#pragma omp p private (t) // { dg-error \"predetermined 'threadprivate'\" }\n+    ;\n+#pragma omp p firstprivate (t) // { dg-error \"predetermined 'threadprivate'\" }\n+    ;\n+#pragma omp p for lastprivate (t) // { dg-error \"predetermined 'threadpriv\" }\n+  for (i = 0; i < 10; i++)\n+    ;\n+#pragma omp p reduction (*:t) // { dg-error \"predetermined 'threadprivate'\" }\n+    ;\n+#pragma omp p shared (c) // { dg-error \"predetermined 'shared'\" }\n+    ;\n+#pragma omp p private (c) // { dg-error \"predetermined 'shared'\" }\n+    ;\n+#pragma omp p firstprivate (c) // { dg-error \"predetermined 'shared'\" }\n+    ;\n+#pragma omp p for lastprivate (c) // { dg-error \"predetermined 'shared'\" }\n+  for (i = 0; i < 10; i++)\n+    ;\n+#pragma omp p reduction (*:c) // { dg-error \"predetermined 'shared'\" }\n+    ;\n+}"}, {"sha": "117f82f8134f75d3ff67a8d53132f3769fbdb003", "filename": "gcc/testsuite/g++.dg/gomp/copyin-1.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fcopyin-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fcopyin-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fcopyin-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,27 @@\n+// { dg-do compile }\n+// { dg-require-effective-target tls }\n+\n+int i, j;\n+\n+#pragma omp threadprivate (i)\n+\n+void bar(void);\n+void foo(void)\n+{\n+  int k;\n+  extern int l;\n+  extern int m;\n+\n+#pragma omp threadprivate (m)\n+\n+  #pragma omp parallel copyin(i)\n+    bar();\n+  #pragma omp parallel copyin(j)\t// { dg-error \"threadprivate\" }\n+    bar();\n+  #pragma omp parallel copyin(k)\t// { dg-error \"threadprivate\" }\n+    bar();\n+  #pragma omp parallel copyin(l)\t// { dg-error \"threadprivate\" }\n+    bar();\n+  #pragma omp parallel copyin(m)\n+    bar();\n+}"}, {"sha": "bdc7bad7b823de5bbf6743dbf064089e02fad036", "filename": "gcc/testsuite/g++.dg/gomp/critical-1.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fcritical-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fcritical-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fcritical-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-omplower\" } */\n+\n+extern void bar(int);\n+\n+void foo (void)\n+{\n+  #pragma omp critical\n+    bar(0);\n+\n+  /* Note that \"name\" is in its own namespace, thus this foo is not\n+     the same as the function.  */\n+  #pragma omp critical(foo)\n+  {\n+    bar(1);\n+    bar(2);\n+  }\n+\n+  #pragma omp critical\n+  #pragma omp critical(foo)\n+    bar(3);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_critical_start\" 2 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_critical_end\" 2 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_critical_name_start\" 2 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_critical_name_end\" 2 \"omplower\" } } */\n+/* { dg-final { cleanup-tree-dump \"omplower\" } } */"}, {"sha": "37c9c2414d9339b9db830cf614d86ea877e941e0", "filename": "gcc/testsuite/g++.dg/gomp/critical-2.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fcritical-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fcritical-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fcritical-2.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,12 @@\n+// { dg-do compile }\n+\n+void f1(void)\n+{\n+  #pragma omp critical a\t// { dg-error \"expected\" }\n+    ;\n+  #pragma omp critical (\t// { dg-error \"expected identifier\" }\n+    ;\n+  #pragma omp critical (a\t// { dg-error \"expected .\\\\).\" }\n+    ;\n+  #pragma omp critical (a b)\t// { dg-error \"expected .\\\\).\" }\n+}\t\t\t\t// { dg-error \"\" }"}, {"sha": "3c6a34bff371cc2fb1713b839e1b6bd2e0eb7b86", "filename": "gcc/testsuite/g++.dg/gomp/flush-1.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fflush-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fflush-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fflush-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-gimple\" } */\n+\n+void f1(void)\n+{\n+  #pragma omp flush\n+}\n+\n+int x;\n+\n+void f2(bool p)\n+{\n+  int z;\n+  if (p)\n+    {\n+      #pragma omp flush (x)\n+    }\n+  else\n+    {\n+      #pragma omp flush (x, z, p)\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__sync_synchronize\" 3 \"gimple\" } } */\n+/* { dg-final { cleanup-tree-dump \"gimple\" } } */"}, {"sha": "a5c0df89cc28239cfcbc0f972e7ae8ff54dbce1d", "filename": "gcc/testsuite/g++.dg/gomp/flush-2.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fflush-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fflush-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fflush-2.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,10 @@\n+// { dg-do compile }\n+\n+void f1(void)\n+{\n+  #pragma omp flush a\t\t// { dg-error \"expected\" }\n+  #pragma omp flush (\t\t// { dg-error \"expected\" }\n+  #pragma omp flush (b\t\t// { dg-error \"declared|expected\" }\n+  #pragma omp flush (c d)\t// { dg-error \"declared|expected\" }\n+  #pragma omp flush (e)\t\t// { dg-error \"declared\" }\n+}"}, {"sha": "f8bb9d54727b90aa47394f48fc317fa8afe7a3c9", "filename": "gcc/testsuite/g++.dg/gomp/for-1.C", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,49 @@\n+// { dg-do compile }\n+\n+extern void baz(int);\n+void foo (int j, int k)\n+{\n+  int i;\n+\n+  /* Valid loops.  */\n+  #pragma omp for\n+  for (i = 0; i < 10; i++)\n+    baz (i);\n+\n+  #pragma omp for\n+  for (i = j; i <= 10; i+=4)\n+    baz (i);\n+\n+  #pragma omp for\n+  for (i = j; i > 0; i = i - 1)\n+    baz (j);\n+\n+  #pragma omp for\n+  for (i = j; i >= k; i--)\n+    baz (i);\n+\n+  // Malformed parallel loops.\n+  #pragma omp for\n+  i = 0;\t\t// { dg-error \"for statement expected\" }\n+  for ( ; i < 10; )\n+    {\n+      baz (i);\n+      i++;\n+    }\n+\n+  #pragma omp for\n+  for (i = 0; ; i--)\t// { dg-error \"missing controlling predicate\" }\n+    {\n+      if (i >= 10)\n+\tbreak;\t\t// { dg-error \"break\" }\n+      baz (i);\n+    }\n+\n+  #pragma omp for\n+  for (i = 0; i < 10 && j > 4; i-=3)\t// { dg-error \"invalid controlling predicate\" }\n+    baz (i);\n+\n+  #pragma omp for\n+  for (i = 0; i < 10; i-=3, j+=2)\t// { dg-error \"invalid increment expression\" }\n+    baz (i);\n+}"}, {"sha": "f21404249c765f68020ad1864b1edfba13b77bc4", "filename": "gcc/testsuite/g++.dg/gomp/for-10.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-10.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-ompexp\" } */\n+\n+extern void bar(int);\n+\n+void foo (int n)\n+{\n+  int i;\n+\n+  #pragma omp for schedule(runtime) ordered\n+  for (i = 0; i < n; ++i)\n+    bar(i);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_runtime_start\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_runtime_next\" 1 \"ompexp\" } } */\n+/* { dg-final { cleanup-tree-dump \"ompexp\" } } */"}, {"sha": "d15576d2fe928d6d69158e5fc93f1d5b8ae83581", "filename": "gcc/testsuite/g++.dg/gomp/for-11.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-11.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,14 @@\n+// { dg-do compile }\n+\n+extern void baz (int);\n+\n+void foo (int j, int k)\n+{\n+  #pragma omp for\n+  for (int l = j; l < k; l++)\n+    baz (l);\n+\n+  #pragma omp for\n+  for (int i = 0, m = 0; m < 10; m++)\t// { dg-error \"\" }\n+    baz (m);\n+}"}, {"sha": "98318d7d5aec216412e4f1c8f145ac9c6d7d8c99", "filename": "gcc/testsuite/g++.dg/gomp/for-12.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-12.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,12 @@\n+int foo (void)\n+{\n+  int i, a;\n+\n+  a = 30;\n+\n+  #pragma omp parallel for lastprivate (a)\n+  for (i = 0; i < 10; i++)\n+    a = a + i;\n+\n+  return a;\n+}"}, {"sha": "16e971f1927142e27838a753067fb4b37a60cf05", "filename": "gcc/testsuite/g++.dg/gomp/for-13.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-13.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,18 @@\n+// At one point in development, a typo disabled the remapping of the\n+// for iteration variable as private.\n+\n+// { dg-do compile }\n+// { dg-options \"-fopenmp -fdump-tree-lower\" }\n+\n+extern void bar(int);\n+void foo(void)\n+{\n+  int i;\n+\n+#pragma omp parallel for default(none)\n+  for (i = 0; i < 10; i++)\n+    bar(i);\n+}\n+\n+// { dg-final { scan-tree-dump-times \"omp_data_o\" 0 \"lower\" } }\n+// { dg-final { cleanup-tree-dump \"lower\" } }"}, {"sha": "fb26413702580d956d9f5a092ffb5836d27f909f", "filename": "gcc/testsuite/g++.dg/gomp/for-14.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-14.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,19 @@\n+// { dg-do compile }\n+\n+extern int printf (const char *, ...);\n+extern void foo (int *);\n+\n+int main (void)\n+{\n+  double d = 6;\n+  int i = 1, j = 6, k = 8;\n+#pragma omp parallel shared(d) private(i) num_threads (4)\n+  {\n+    i = 4;\n+#pragma omp for lastprivate(j)\n+    for (j = 1; j <= k; j++)\n+      printf (\"%s %d %d %d %p %g\\n\", \"Hello, World!\", i, j, k, &j, d);\n+    printf (\"%s %d %g\\n\", \"Hello, World!\", i, d);\n+  }\n+  return 0;\n+}"}, {"sha": "25eea2ad24d0135e881a704f1d9352ea360f7e30", "filename": "gcc/testsuite/g++.dg/gomp/for-15.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-15.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,35 @@\n+// PR c++/24512\n+// { dg-do compile }\n+\n+template<typename T> void foo ()\n+{\n+#pragma omp for\n+  for (int i = 0; i < 10; i++);\n+\n+#pragma omp for\n+  for (int i = 0; i < 10; i++);\n+\n+#pragma omp for\n+  for (T j = 0; j < 10; j++);\n+\n+#pragma omp for\n+  for (T j = 0; j < 10; j++);\n+\n+#pragma omp parallel for\n+  for (int k = 0; k < 10; k++);\n+\n+#pragma omp parallel for\n+  for (int k = 0; k < 10; k++);\n+\n+#pragma omp parallel for\n+  for (T l = 0; l < 10; l++);\n+\n+#pragma omp parallel for\n+  for (T l = 0; l < 10; l++);\n+}\n+\n+void bar ()\n+{\n+  foo<int> ();\n+  foo<long> ();\n+}"}, {"sha": "76231751f703f8414e2600170d8e7f0dd469ce39", "filename": "gcc/testsuite/g++.dg/gomp/for-16.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-16.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,33 @@\n+// { dg-do compile }\n+\n+template<typename T>\n+void foo ()\n+{\n+#pragma omp for\n+  for (unsigned int i = 0; i < 10; i++); // { dg-warning \"is unsigned\" }\n+#pragma omp for\n+  for (int j = 0; ; j++); // { dg-error \"missing controlling predicate\" }\n+#pragma omp for\n+  for (int k = 0; k == 1; k++); // { dg-error \"invalid controlling predicate\" }\n+#pragma omp for\n+  for (int l = 0; l < 10; ); // { dg-error \"missing increment expression\" }\n+#pragma omp for\n+  for (int m = 0; m < 10; m *= 3); // Error here is emitted only during\n+\t\t\t\t   // instantiation\n+#pragma omp for\n+  for (T n = 0; ; n++); // { dg-error \"missing controlling predicate\" }\n+#pragma omp for\n+  for (T o = 0; o == 1; o++); // Error here is emitted only during\n+\t\t\t      // instantiation\n+#pragma omp for\n+  for (T p = 0; p < 10; ); // { dg-error \"missing increment expression\" }\n+#pragma omp for\n+  for (T q = 0; q < 10; q *= 3); // Error here is emitted only during\n+\t\t\t\t // instantiation\n+}\n+\n+void bar ()\n+{\n+#pragma omp for\n+  for (int m = 0; m < 10; m *= 3); // { dg-error \"invalid increment expression\" }\n+}"}, {"sha": "9634e59c8e3cc6b206fa9139403c75ef56422fa8", "filename": "gcc/testsuite/g++.dg/gomp/for-17.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-17.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+\n+void foo()\n+{\n+\tlong n = 10;\n+\tint i;\n+#pragma omp for\n+\tfor (i=0; i < n; ++i) ;\n+#pragma omp for\n+\tfor (i=0; n > i; ++i) ;\n+}"}, {"sha": "0a5052674939256f2e91ffd718ca4204c83ef6e1", "filename": "gcc/testsuite/g++.dg/gomp/for-18.C", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-18.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,67 @@\n+// { dg-do compile }\n+extern int bar (int);\n+\n+void\n+foo (void)\n+{\n+  int j, k = 1, l = 30, m = 4;\n+  long int o = 4;\n+  long long int p = 0;\n+#pragma omp for\n+  for (j = k; j <= l; j += m - 1)\n+    ;\n+#pragma omp for\n+  for (j = k; j <= l; j += (m - 1))\n+    ;\n+#pragma omp for\n+  for (j = k; j <= l; j += bar (m - 1))\n+    ;\n+#pragma omp for\n+  for (j = k; j <= l; j = j + m - 1)\n+    ;\n+#pragma omp for\n+  for (j = k; j <= l; j = j + (m - 1))\n+    ;\n+#pragma omp for\n+  for (j = k; j <= l; j = j + bar (m - 1))\n+    ;\n+#pragma omp for\n+  for (j = ({ int n; n = k; n; }); j <= l; j++)\n+    ;\n+#pragma omp for\n+  for (j = k; j <= ({ int n; n = l; n; }); j++)\n+    ;\n+#pragma omp for\n+  for (j = k; j <= l; j += ({ int n; n = 1; n; }))\n+    ;\n+#pragma omp for\n+  for (j = k; j <= l; j += m + 1)\n+    ;\n+#pragma omp for\n+  for (j = k; j <= l; j += o)\n+    ;\n+#pragma omp for\n+  for (j = k; j <= l; j = j + o)\n+    ;\n+#pragma omp for\n+  for (j = k; j <= l; j = o + 1 + j)\n+    ;\n+#pragma omp for\n+  for (j = k; j <= l; j = o + m + j)\n+    ;\n+#pragma omp for\n+  for (j = k; j <= l; j += o + p)\n+    ;\n+#pragma omp for\n+  for (j = k; j <= l; j = j + o + p)\n+    ;\n+#pragma omp for\n+  for (j = l; j >= k; j -= o)\n+    ;\n+#pragma omp for\n+  for (j = l; j >= k; j -= p)\n+    ;\n+#pragma omp for\n+  for (j = l; j >= k; j -= o + p)\n+    ;\n+}"}, {"sha": "37e5929afa124b455fbb669db71ea58f4a784ddb", "filename": "gcc/testsuite/g++.dg/gomp/for-2.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-2.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+\n+void foo()\n+{\n+  int i;\n+\n+  #pragma omp for nowait\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for nowait nowait\t\t/* { dg-error \"too many\" } */\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for ordered\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for ordered ordered\t/* { dg-error \"too many\" } */\n+  for (i = 0; i < 10; ++i) ;\n+}"}, {"sha": "fcf5a2c1b2372ae8fc3e6df9dbb8f2955161c566", "filename": "gcc/testsuite/g++.dg/gomp/for-3.C", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-3.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,62 @@\n+// { dg-do compile }\n+\n+int bar ();\n+\n+void foo()\n+{\n+  int i;\n+\n+  #pragma omp for schedule\t\t// { dg-error \"expected\" }\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule static\t// { dg-error \"expected\" }\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule (\t\t// { dg-error \"invalid schedule kind\" }\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule ( static\t// { dg-error \"expected\" }\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule ( static )\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule ( foo )\t// { dg-error \"invalid schedule kind\" }\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule ( static 1\t// { dg-error \"expected\" }\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule ( static 1 ) nowait\t// { dg-error \"expected\" }\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule ( static, 1 ) nowait\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule ( static, 1, 1 ) nowait  // { dg-error \"expected\" }\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule ( static, 1 + 1 ) nowait\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule ( static, 1.0 )\t// { dg-error \"integral\" }\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule (dynamic)\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule (dynamic, bar ())\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule (guided)\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule (guided, bar ())\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule (runtime)\n+  for (i = 0; i < 10; ++i) ;\n+\n+  #pragma omp for schedule (runtime, bar ())\t// { dg-error \"does not take\" }\n+  for (i = 0; i < 10; ++i) ;\n+}"}, {"sha": "fb6994ea20b8a533f9129cf2fb04e71bfe6e7020", "filename": "gcc/testsuite/g++.dg/gomp/for-4.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-4.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-ompexp\" } */\n+\n+extern void bar(int);\n+\n+void foo (int n)\n+{\n+  int i;\n+\n+  #pragma omp for schedule(dynamic)\n+  for (i = 0; i < n; ++i)\n+    bar(i);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_dynamic_start\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_dynamic_next\" 1 \"ompexp\" } } */\n+/* { dg-final { cleanup-tree-dump \"ompexp\" } } */"}, {"sha": "5912a4e5561ed5aade4116d5ff3377b058ccdf7b", "filename": "gcc/testsuite/g++.dg/gomp/for-5.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-5.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-ompexp\" } */\n+\n+extern void bar(int);\n+\n+void foo (int n)\n+{\n+  int i;\n+\n+  #pragma omp for schedule(guided)\n+  for (i = 0; i < n; ++i)\n+    bar(i);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_guided_start\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_guided_next\" 1 \"ompexp\" } } */\n+/* { dg-final { cleanup-tree-dump \"ompexp\" } } */"}, {"sha": "100ee2c8c2198b096fa15eb1554eb43d9c5603a9", "filename": "gcc/testsuite/g++.dg/gomp/for-6.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-6.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-ompexp\" } */\n+\n+extern void bar(int);\n+\n+void foo (int n)\n+{\n+  int i;\n+\n+  #pragma omp for schedule(runtime)\n+  for (i = 0; i < n; ++i)\n+    bar(i);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_runtime_start\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_runtime_next\" 1 \"ompexp\" } } */\n+/* { dg-final { cleanup-tree-dump \"ompexp\" } } */"}, {"sha": "10763dc596c2755f5c3ca2fd7cbccecb09736cac", "filename": "gcc/testsuite/g++.dg/gomp/for-7.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-7.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-ompexp\" } */\n+\n+extern void bar(int);\n+\n+void foo (int n)\n+{\n+  int i;\n+\n+  #pragma omp for schedule(static) ordered\n+  for (i = 0; i < n; ++i)\n+    bar(i);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_static_start\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_static_next\" 1 \"ompexp\" } } */\n+/* { dg-final { cleanup-tree-dump \"ompexp\" } } */"}, {"sha": "1bc66c49a0d60b81277c8a0fc3d560bbf2a4e699", "filename": "gcc/testsuite/g++.dg/gomp/for-8.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-8.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-ompexp\" } */\n+\n+extern void bar(int);\n+\n+void foo (int n)\n+{\n+  int i;\n+\n+  #pragma omp for schedule(dynamic) ordered\n+  for (i = 0; i < n; ++i)\n+    bar(i);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_dynamic_start\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_dynamic_next\" 1 \"ompexp\" } } */\n+/* { dg-final { cleanup-tree-dump \"ompexp\" } } */"}, {"sha": "af99e216e793a78cccb9bf38265206befd08cf59", "filename": "gcc/testsuite/g++.dg/gomp/for-9.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ffor-9.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-ompexp\" } */\n+\n+extern void bar(int);\n+\n+void foo (int n)\n+{\n+  int i;\n+\n+  #pragma omp for schedule(guided) ordered\n+  for (i = 0; i < n; ++i)\n+    bar(i);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_guided_start\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_guided_next\" 1 \"ompexp\" } } */\n+/* { dg-final { cleanup-tree-dump \"ompexp\" } } */"}, {"sha": "851c1c9bf4f14c191faa159cd9c0de32e4263d46", "filename": "gcc/testsuite/g++.dg/gomp/gomp.exp", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fgomp.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fgomp.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fgomp.exp?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,11 @@\n+# Load support procs.\n+load_lib g++-dg.exp\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Main loop.\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.C]] \"\" \"-fopenmp\"\n+\n+# All done.\n+dg-finish"}, {"sha": "b04610d2ccf78b755659fbd5cbebf1dd516e74b6", "filename": "gcc/testsuite/g++.dg/gomp/macro-1.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmacro-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmacro-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmacro-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,10 @@\n+// { dg-do compile }\n+\n+#define N 10\n+\n+extern void bar(void);\n+void foo(void)\n+{\n+  #pragma omp parallel num_threads(N)\n+    bar();\n+}"}, {"sha": "75d6490cd7c3d3889ef68f1dbc46a302e5eca975", "filename": "gcc/testsuite/g++.dg/gomp/macro-2.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmacro-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmacro-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmacro-2.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,14 @@\n+// { dg-do compile }\n+\n+#define p\tparallel\n+#define s(x)\tshared(x##1, x##2)\n+#define d(x)\tdefault(x)\n+\n+void bar(int, int, int, int);\n+void foo(void)\n+{\n+  int a1, a2, b1, b2;\n+\n+  #pragma omp p s(a) s(b) d(none)\n+    bar(a1, a2, b1, b2);\n+}"}, {"sha": "2681c216a3ff79dd086b715798af4e3619480e75", "filename": "gcc/testsuite/g++.dg/gomp/master-1.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmaster-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmaster-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmaster-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+\n+extern void bar(int);\n+\n+void foo (void)\n+{\n+  #pragma omp master\n+    bar(0);\n+\n+  #pragma omp master\n+  {\n+    bar(1);\n+    bar(2);\n+  }\n+\n+  /* Yes, this is legal -- structured-block contains statement contains\n+     openmp-construct contains master-construct.  */\n+  #pragma omp master\n+  #pragma omp master\n+  #pragma omp master\n+    ;\n+}"}, {"sha": "05320662724999085694e54c0c739c3a539387a7", "filename": "gcc/testsuite/g++.dg/gomp/master-2.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmaster-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmaster-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmaster-2.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do compile } */\n+\n+void f1(void)\n+{\n+  #pragma omp master asdf\t/* { dg-error \"expected\" } */\n+  #pragma omp master\n+}\t\t\t\t/* { dg-error \"expected\" } */"}, {"sha": "37966106df58a4af596743b1ee63caa787a32778", "filename": "gcc/testsuite/g++.dg/gomp/master-3.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmaster-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmaster-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmaster-3.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-omplower\" } */\n+\n+extern void bar(int);\n+\n+void foo (void)\n+{\n+  #pragma omp master\n+    bar(0);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"omp_get_thread_num\" 1 \"omplower\" } } */\n+/* { dg-final { cleanup-tree-dump \"omplower\" } } */"}, {"sha": "3d8235656b171dbc10180d3b1a9944bf93c8d729", "filename": "gcc/testsuite/g++.dg/gomp/method-1.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmethod-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmethod-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fmethod-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,18 @@\n+/* PR c++/24513 */\n+/* { dg-do compile } */\n+\n+struct S\n+{\n+  void foo (int *p)\n+  {\n+#pragma omp parallel for\n+    for (int i = 0; i < 1000; ++i)\n+      p[i]=0;\n+  }\n+  void bar ()\n+  {\n+#pragma omp master\n+    j = 2;\n+  }\n+  int j;\n+};"}, {"sha": "a1cd7f486028d190698de65cc27be78b8b2bb3c9", "filename": "gcc/testsuite/g++.dg/gomp/ordered-1.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fordered-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fordered-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fordered-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-omplower\" } */\n+\n+extern void bar(int);\n+\n+void foo (void)\n+{\n+  #pragma omp ordered\n+    bar(0);\n+\n+  #pragma omp ordered\n+  {\n+    bar(1);\n+    bar(2);\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GOMP_ordered_start\" 2 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_ordered_end\" 2 \"omplower\" } } */\n+/* { dg-final { cleanup-tree-dump \"omplower\" } } */"}, {"sha": "6c2b4329c64f0ef77490707c31c820fac0ebd068", "filename": "gcc/testsuite/g++.dg/gomp/ordered-2.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fordered-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fordered-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fordered-2.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do compile } */\n+\n+void f1(void)\n+{\n+  #pragma omp ordered asdf\t/* { dg-error \"expected\" } */\n+  #pragma omp ordered\n+}\t\t\t\t/* { dg-error \"expected\" } */"}, {"sha": "c5c233b76eb89bd36884522cf06aad216f56c5a0", "filename": "gcc/testsuite/g++.dg/gomp/parallel-1.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fparallel-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fparallel-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fparallel-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile }\n+\n+void foo()\n+{\n+  int i;\n+\n+  #pragma omp parallel\n+    {\n+    #pragma omp parallel\n+      {\n+      #pragma omp parallel\n+        {\n+ \t  i++;\n+\t}\n+      }\n+    }\n+}"}, {"sha": "68e577766b1f481a39f1bb1c117d5faab4cca3c8", "filename": "gcc/testsuite/g++.dg/gomp/parallel-2.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fparallel-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fparallel-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fparallel-2.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile }\n+\n+void foo()\n+{\n+  int i;\n+\n+  #pragma omp parallel default(none)\t\t// { dg-error \"enclosing\" }\n+    {\n+    #pragma omp parallel\n+      {\n+      #pragma omp parallel default(none)\t// { dg-error \"enclosing\" }\n+        {\n+ \t  i++;\t\t\t\t\t// { dg-error \"not specified\" }\n+\t}\n+      }\n+    }\n+}"}, {"sha": "633d7ba5998301c4e84a6eabfbfad8de40f7bf8d", "filename": "gcc/testsuite/g++.dg/gomp/parallel-3.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fparallel-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fparallel-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fparallel-3.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do compile }\n+\n+extern int printf (const char *, ...);\n+\n+int main (void)\n+{\n+  double d = 6;\n+  int i = 1;\n+#pragma omp parallel shared(d) private(i) num_threads (4 + i)\n+  {\n+    i = 4;\n+    printf (\"%s %d %g\\n\", \"Hello, World!\", i, d);\n+  }\n+  return 0;\n+}"}, {"sha": "ca06aeef9ef72250b4c003553bcb67af20a9c2ad", "filename": "gcc/testsuite/g++.dg/gomp/parallel-4.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fparallel-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fparallel-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fparallel-4.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+\n+extern int foo(void);\n+extern void bar(void);\n+\n+int main ()\n+{\n+  /* Malformed uses of 'if' and 'num_threads'.  */\n+  #pragma omp parallel if (foo () > 10) if (foo () == 3) /* { dg-error \"too many\" } */\n+    {\n+      bar ();\n+    }\n+\n+  #pragma omp parallel num_threads (3) num_threads (20)\t/* { dg-error \"too many\" } */\n+    {\n+      bar ();\n+    }\n+\n+  /* Valid uses of 'if' and 'num_threads'.  */\n+  #pragma omp parallel if (foo () == 10) num_threads (foo ())\n+    {\n+      bar ();\n+    }\n+}"}, {"sha": "b8cd174a31b479bda91092cc759123c2964dee46", "filename": "gcc/testsuite/g++.dg/gomp/parallel-5.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fparallel-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fparallel-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fparallel-5.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,11 @@\n+// { dg-do compile }\n+\n+extern void bar (void);\n+\n+int main (void)\n+{\n+  int i;\n+#pragma omp parallel for nowait /* { dg-error \"'nowait'\" } */\n+  for (i = 0; i < 10; i++)\n+    bar ();\n+}"}, {"sha": "f3564371992015a5a60618fbaf09d39bf56ae326", "filename": "gcc/testsuite/g++.dg/gomp/pr24849.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr24849.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr24849.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr24849.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+\n+template<typename T> struct Healpix_Map {\n+  T *map;\n+  int npix_;\n+\n+  void Import_nograde (const Healpix_Map<T> &orig) {\n+#pragma omp parallel\n+{\n+    int m;\n+#pragma omp for schedule (dynamic)\n+    for (m=0; m<npix_; ++m) map[m] = orig.map[m];\n+}\n+    }\n+  };\n+\n+void foo(Healpix_Map<int> &a, Healpix_Map<int> &b) {\n+  a.Import_nograde(b);\n+  }"}, {"sha": "02adef97f5688f614ea23b3f4294d05f06028696", "filename": "gcc/testsuite/g++.dg/gomp/pr25874.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr25874.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr25874.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr25874.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,23 @@\n+int foo();\n+\n+struct wigner_d\n+  {\n+  void recurse () {\n+    int dd;\n+    for (int j=0; j<=1; ++j) {\n+#pragma omp parallel\n+      dd=5;\n+      }\n+    }\n+  };\n+\n+template<typename T> void rotate_alm(T arg)\n+  {\n+  wigner_d rec;\n+  rec.recurse();\n+#pragma omp parallel\n+    foo();\n+  }\n+\n+template void rotate_alm(float arg);\n+template void rotate_alm(double arg);"}, {"sha": "43704908e43de34b39717efbe1c65bcacf9d65aa", "filename": "gcc/testsuite/g++.dg/gomp/sections-1.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsections-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsections-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsections-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+\n+extern void bar(int);\n+\n+void f1(void)\n+{\n+  #pragma omp sections nowait\n+    {\n+      bar (1);\n+    #pragma omp section\n+      bar (2);\n+    #pragma omp section\n+      bar (3);\n+    #pragma omp section\n+      bar (4);\n+    #pragma omp section\n+      bar (5);\n+    }\n+}\n+\n+void f2(void)\n+{\n+  #pragma omp sections\n+    {\n+    #pragma omp section\n+      {\n+        bar (1);\n+        bar (1);\n+      }\n+    #pragma omp section\n+      bar (2);\n+    #pragma omp section\n+      bar (3);\n+    #pragma omp section\n+      bar (4);\n+    #pragma omp section\n+      bar (5);\n+    }\n+}"}, {"sha": "aabdfaf8069aef31c2c0eda8f23c02c04ad1fe03", "filename": "gcc/testsuite/g++.dg/gomp/sections-2.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsections-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsections-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsections-2.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+\n+extern void bar(int);\n+void foo(void)\n+{\n+  #pragma omp sections\n+    bar (0);\t\t// { dg-error \"expected\" }\n+\n+  #pragma omp sections\n+    {\n+    }\t\t\t// { dg-error \"expected\" }\n+\n+  #pragma omp sections\n+    {\n+      bar (1);\n+    }\n+\n+  #pragma omp sections\n+    {\n+    #pragma omp section\n+      bar(2);\n+      bar(3);\t\t// { dg-error \"expected\" }\n+      bar(4);\n+    #pragma omp section\n+      bar(5);\n+      bar(6);\t\t// { dg-error \"expected\" }\n+      bar(7);\n+    }\n+}"}, {"sha": "d8fb2a09d3059e4a734e4dfbd8c13d5cf325adfe", "filename": "gcc/testsuite/g++.dg/gomp/sections-3.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsections-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsections-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsections-3.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,15 @@\n+\n+// { dg-do compile }\n+\n+extern void bar (void);\n+\n+int main (void)\n+{\n+  #pragma omp parallel sections nowait /* { dg-error \"'nowait'\" } */\n+    {\n+    #pragma omp section\n+\t{ bar(); }\n+    #pragma omp section\n+\t{ bar(); }\n+    }\n+}"}, {"sha": "44e7de98c209f7e6fe52fc33a8a2c4ac540781eb", "filename": "gcc/testsuite/g++.dg/gomp/sections-4.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsections-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsections-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsections-4.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,13 @@\n+/* PR c++/24613 */\n+/* { dg-compile } */\n+\n+#pragma omp section\t/* { dg-error \"may only be used in\" } */\n+\n+int i;\n+\n+void\n+foo (void)\n+{\n+  #pragma omp section\t/* { dg-error \"may only be used in\" } */\n+    i++;\n+}"}, {"sha": "83b818098342580e903b64b4d17a26ba2ef74b7e", "filename": "gcc/testsuite/g++.dg/gomp/sharing-1.C", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsharing-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsharing-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fsharing-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,77 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target tls } */\n+\n+int thrglobalvar;\n+#pragma omp threadprivate (thrglobalvar)\n+int globalvar;\n+const struct S\n+{\n+  int x;\n+} constvar = { 8 };\n+struct T\n+{\n+  static T t;\n+  int i;\n+};\n+T T::t = { 6 };\n+/* const qualified type, but mutable member -> not predetermined.  */\n+const struct U\n+{\n+  int x;\n+  mutable int y;\n+} constmutvar = { 6, 4 };\n+\n+int\n+foo (int x)\n+{\n+  return x;\n+}\n+\n+int\n+bar (int *x)\n+{\n+  return *x;\n+}\n+\n+int\n+baz (U u)\n+{\n+  return u.x;\n+}\n+\n+int\n+main (void)\n+{\n+  static int thrlocvar;\n+#pragma omp threadprivate (thrlocvar)\n+  static int locvar;\n+  static int *p;\n+  int i, j, s, l;\n+\n+  p = new int;\n+  *p = 7;\n+  s = 6;\n+  l = 0;\n+#pragma omp parallel for /* { dg-error \"enclosing parallel\" } */ \\\n+  default (none) private (p) shared (s) \n+  for (i = 0; i < 64; i++)\n+    {\n+      int k = foo (0);\t/* Predetermined - private (automatic var declared */\n+      k++;\t\t/* in scope of construct).  */\n+      thrglobalvar++;\t/* Predetermined - threadprivate.  */\n+      thrlocvar++;\t/* Predetermined - threadprivate.  */\n+      foo (i);\t\t/* Predetermined - private (omp for loop variable).  */\n+      foo (constvar.x);\t/* Predetermined - shared (const qualified type).  */\n+      foo (T::t.i);\t/* Predetermined - shared (static data member).  */\n+      foo (*p);\t\t/* *p predetermined - shared (heap allocated */\n+      (*p)++;\t\t/* storage).  */\n+      bar (p);\t\t/* Explicitly determined - private.  */\n+      foo (s);\t\t/* Explicitly determined - shared.  */\n+      globalvar++;\t/* { dg-error \"not specified in\" } */\n+      locvar++;\t\t/* { dg-error \"not specified in\" } */\n+      l++;\t\t/* { dg-error \"not specified in\" } */\n+      for (j = 0; j < 2; j++); /* { dg-error \"not specified in\" } */\n+      baz (constmutvar);/* { dg-error \"not specified in\" } */\n+    }\n+  return 0;\n+}"}, {"sha": "bfe62cb009b300d6f9c5c575af695517d87f97ef", "filename": "gcc/testsuite/g++.dg/gomp/tls-1.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,18 @@\n+// { dg-do compile }\n+// { dg-require-effective-target tls }\n+\n+int tp1;\n+static int tp2;\n+extern int tp3;\n+\n+int tp4 = 1;\n+static int tp5 = 1;\n+\n+#pragma omp threadprivate (tp1, tp2, tp3, tp4, tp5)\n+\n+#pragma omp threadprivate (undef)\t// { dg-error \"declared\" }\n+\n+int tp6;\n+int foo(void) { return tp6; }\n+\n+#pragma omp threadprivate (tp6)\t\t// { dg-error \"after first use\" }"}, {"sha": "80275f9081c20e98be4166769c4df415b167e3a6", "filename": "gcc/testsuite/g++.dg/gomp/tls-2.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-2.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target tls } */\n+\n+extern char buf[];\n+#pragma omp threadprivate (buf)\t/* { dg-error \"has incomplete type\" } */\n+\n+void\n+foo (void)\n+{\n+  int i;\n+#pragma omp threadprivate (i) /* { dg-error \"automatic variable\" } */\n+  i = 0;\n+}"}, {"sha": "c42d74c4d5770f667fc1ba4796e070dfffc8717e", "filename": "gcc/testsuite/g++.dg/gomp/tls-3.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-3.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,25 @@\n+// { dg-do compile }\n+// { dg-require-effective-target tls }\n+\n+#define thr threadprivate\n+\n+int i;\n+#pragma omp thr (i)\n+namespace N\n+{\n+  int j;\n+#pragma omp thr (j)\n+};\n+struct S\n+{\n+  static int s;\n+#pragma omp thr (s) // { dg-error \"is not file, namespace or block scope\" }\n+};\n+\n+int\n+foo ()\n+{\n+  static int k;\n+#pragma omp thr (k)\n+  return k++ + S::s;\n+}"}, {"sha": "ff1e3632db6db7bdc71d5313e6897db97e6047fa", "filename": "gcc/testsuite/g++.dg/gomp/tpl-atomic-1.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-atomic-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-atomic-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-atomic-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,26 @@\n+// { dg-do compile }\n+\n+int check;\n+\n+template<typename T> void foo()\n+{\n+  #pragma omp atomic\n+  check |= sizeof(T);\n+}\n+\n+template<typename T> void bar(T *x, T y)\n+{\n+  #pragma omp atomic\n+  *x += y;\n+}\n+\n+void test ()\n+{\n+  int i;\n+  long l;\n+\n+  foo<char>();\n+  foo<short>();\n+  bar(&i, 4);\n+  bar(&l, 8L);\n+}"}, {"sha": "363bd103d8e41a1a7bcfcbb41bb40ed229100991", "filename": "gcc/testsuite/g++.dg/gomp/tpl-atomic-2.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-atomic-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-atomic-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-atomic-2.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,41 @@\n+// { dg-do compile }\n+\n+struct S { int x; } s;\n+\n+// Make sure we detect errors on non-type-dependent things\n+// even when the templates are never instantiated.\n+template<typename T> void f1()\n+{\n+  #pragma omp atomic\n+  s += 1;\t\t// { dg-error \"invalid\" }\n+}\n+\n+template<typename T> void f2(float *f)\n+{\n+  #pragma omp atomic\n+  *f |= 1;\t\t// { dg-error \"invalid|evaluation\" }\n+}\n+\n+// Here the rhs is dependent, but not type dependent.\n+// ??? Fails.  See the comment in finish_omp_atomic.\n+template<typename T> void f3(float *f)\n+{\n+  #pragma omp atomic\n+  *f |= sizeof (T);\t// { dg-error \"invalid|evaluation\" \"\" { xfail *-*-* } }\n+}\n+\n+// And the converse, no error here because we're never fed a T.\n+template<typename T> void f4(T *t)\n+{\n+  #pragma omp atomic\n+  *t += 1;\n+}\n+\n+// Here we'll let it go, because the rhs is type dependent and\n+// we can't properly instantiate the statement, and we do most\n+// of the semantic analysis concurrent with that.\n+template<typename T> void f5(float *f)\n+{\n+  #pragma omp atomic\n+  *f |= (T)sizeof(T);\t// { dg-error \"invalid|evaluation\" \"\" { xfail *-*-* } }\n+}"}, {"sha": "60567d910284d44b8d1120bd30494bcce54aa9e8", "filename": "gcc/testsuite/g++.dg/gomp/tpl-barrier-1.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-barrier-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-barrier-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-barrier-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,25 @@\n+// PR c++/24735\n+// { dg-do compile }\n+// { dg-options \"-fopenmp -fdump-tree-gimple\" }\n+\n+template <int> void f1 ()\n+{\n+  #pragma omp barrier\n+}\n+\n+template <int> void f2 (bool p)\n+{\n+  if (p)\n+    {\n+      #pragma omp barrier\n+    }\n+}\n+\n+void f3 ()\n+{\n+  f1<0> ();\n+  f2<0> (true);\n+}\n+\n+// { dg-final { scan-tree-dump-times \"GOMP_barrier\" 2 \"gimple\" } }\n+// { dg-final { cleanup-tree-dump \"gimple\" } }"}, {"sha": "e036e64471519d2299fc2b903c26a83c79855acf", "filename": "gcc/testsuite/g++.dg/gomp/tpl-for-1.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-for-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-for-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-for-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile }\n+\n+void foo(int);\n+void foo(long);\n+\n+template<typename T> void bar()\n+{\n+  #pragma omp for\n+  for (T i = 0; i < 10; ++i)\n+    foo(i);\n+}\n+\n+void test()\n+{\n+  bar<int>();\n+  bar<long>();\n+}"}, {"sha": "a3bb6ccd46b45e82bc76e821806a90abb943e00a", "filename": "gcc/testsuite/g++.dg/gomp/tpl-for-2.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-for-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-for-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-for-2.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do compile }\n+\n+void foo(int);\n+\n+template<int A, int B, int C> void bar()\n+{\n+  #pragma omp for\n+  for (int i = A; i < B; i += C)\n+    foo(i);\n+}\n+\n+void test()\n+{\n+  bar<0, 10, 2>();\n+}"}, {"sha": "0cafd9628b5d0143b95fd4176e4f779e19cc7fb3", "filename": "gcc/testsuite/g++.dg/gomp/tpl-for-3.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-for-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-for-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-for-3.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,28 @@\n+// { dg-do compile }\n+\n+void foo(int);\n+\n+template<typename T> void bar()\n+{\n+  #pragma omp parallel for\n+  for (typename T::T i = 0; i < T::N; ++i)\n+    foo(i);\n+}\n+\n+struct A\n+{\n+  typedef int T;\n+  static T N;\n+};\n+\n+struct B\n+{\n+  typedef long T;\n+  static T N;\n+};\n+\n+void test()\n+{\n+  bar<A>();\n+  bar<B>();\n+}"}, {"sha": "cf22e1c3fd3a4a9da0e67396e81b80707e03db29", "filename": "gcc/testsuite/g++.dg/gomp/tpl-master-1.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-master-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-master-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-master-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,30 @@\n+// PR c++/24734\n+// { dg-do compile }\n+// { dg-options \"-fopenmp -fdump-tree-gimple\" }\n+\n+int i;\n+\n+template <int> void f1 ()\n+{\n+  #pragma omp ordered\n+    i++;\n+}\n+\n+template <int> void f2 (bool p)\n+{\n+  if (p)\n+    {\n+      #pragma omp master\n+\ti++;\n+    }\n+}\n+\n+void f3 ()\n+{\n+  f1<0> ();\n+  f2<0> (true);\n+}\n+\n+// { dg-final { scan-tree-dump-times \"#pragma omp ordered\" 1 \"gimple\" } }\n+// { dg-final { scan-tree-dump-times \"#pragma omp master\" 1 \"gimple\" } }\n+// { dg-final { cleanup-tree-dump \"gimple\" } }"}, {"sha": "886d07e215b1979c6150fa9256989c67fb1b1715", "filename": "gcc/testsuite/g++.dg/gomp/tpl-parallel-1.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-parallel-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-parallel-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-parallel-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,24 @@\n+// { dg-do compile }\n+\n+int check;\n+\n+template<typename T> void foo()\n+{\n+  check |= sizeof(T);\n+}\n+\n+template<typename T>\n+void bar(void)\n+{\n+  #pragma omp parallel if (0)\n+    foo<T>();\n+}\n+\n+int main()\n+{\n+  bar<char>();\n+  bar<short>();\n+  if (check != (sizeof(char) | sizeof(short)))\n+    __builtin_trap ();\n+  return 0;\n+}"}, {"sha": "3f2e3bb6211ef68237807cbe07f9cc4ec17dd71b", "filename": "gcc/testsuite/g++.dg/gomp/tpl-parallel-2.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-parallel-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-parallel-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-parallel-2.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,20 @@\n+// { dg-do compile }\n+\n+template<typename T>\n+struct S\n+{\n+  T n;\n+  void test();\n+  void work();\n+};\n+\n+template<typename T>\n+void S<T>::test()\n+{\n+  #pragma omp parallel num_threads(n)\t// { dg-error \"must be integral\" }\n+    work();\n+}\n+\n+template struct S<int>;\n+template struct S<long>;\n+template struct S<float>;\t// { dg-error \"instantiated from here\" }"}, {"sha": "b7f147ce77f2ec7ba24f32b5f7a88b698316e393", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -4736,6 +4736,8 @@ move_block_to_fn (struct function *dest_cfun, basic_block bb,\n \t  if (uid >= dest_cfun->last_label_uid)\n \t    dest_cfun->last_label_uid = uid + 1;\n \t}\n+\n+      remove_stmt_from_eh_region (stmt);\n     }\n }\n "}, {"sha": "278cba07e3c51aa84effdf22bca8806ad149ca7c", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -1,3 +1,7 @@\n+2006-03-09  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* testsuite/libgomp.c++: New directory.\n+\n 2006-02-25  Shantonu Sen  <ssen@opendarwin.org>\n \n \t* config/posix/sem.h: Define BROKEN_POSIX_SEMAPHORES functions."}, {"sha": "ecb4aa9a9c72e70356337f97766ca1d3004c8231", "filename": "libgomp/testsuite/libgomp.c++/c++.exp", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fc%2B%2B.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fc%2B%2B.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fc%2B%2B.exp?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,20 @@\n+set lang_library_path\t\"../libstdc++-v3/src/.libs\"\n+set lang_test_file\t\"${lang_library_path}/libstdc++.a\"\n+set lang_link_flags\t\"-lstdc++\"\n+\n+load_lib libgomp-dg.exp\n+\n+# Initialize dg.\n+dg-init\n+\n+if [file exists \"${blddir}/${lang_test_file}\"] {\n+\n+    # Gather a list of all tests.\n+    set tests [lsort [glob -nocomplain $srcdir/$subdir/*.C]]\n+\n+    # Main loop.\n+    gfortran-dg-runtest $tests \"\"\n+}\n+\n+# All done.\n+dg-finish"}, {"sha": "bc12be2d2f961566ba2fad86895cc9d270d19886", "filename": "libgomp/testsuite/libgomp.c++/copyin-1.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcopyin-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcopyin-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcopyin-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,34 @@\n+// { dg-do run }\n+// { dg-require-effective-target tls_runtime }\n+\n+#include <omp.h>\n+\n+extern \"C\" void abort (void);\n+\n+int thr = 32;\n+#pragma omp threadprivate (thr)\n+\n+int\n+main (void)\n+{\n+  int l = 0;\n+\n+  omp_set_dynamic (0);\n+  omp_set_num_threads (6);\n+\n+#pragma omp parallel copyin (thr) reduction (||:l)\n+  {\n+    l = thr != 32;\n+    thr = omp_get_thread_num () + 11;\n+  }\n+\n+  if (l || thr != 11)\n+    abort ();\n+\n+#pragma omp parallel reduction (||:l)\n+  l = thr != omp_get_thread_num () + 11;\n+\n+  if (l)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "024f5998054e85818506cc04c4dc0efd98736228", "filename": "libgomp/testsuite/libgomp.c++/copyin-2.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcopyin-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcopyin-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fcopyin-2.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,34 @@\n+// { dg-do run }\n+// { dg-require-effective-target tls_runtime }\n+\n+#include <omp.h>\n+\n+extern \"C\" void abort (void);\n+\n+struct S { int t; char buf[64]; } thr = { 32, \"\" };\n+#pragma omp threadprivate (thr)\n+\n+int\n+main (void)\n+{\n+  int l = 0;\n+\n+  omp_set_dynamic (0);\n+  omp_set_num_threads (6);\n+\n+#pragma omp parallel copyin (thr) reduction (||:l)\n+  {\n+    l = thr.t != 32;\n+    thr.t = omp_get_thread_num () + 11;\n+  }\n+\n+  if (l || thr.t != 11)\n+    abort ();\n+\n+#pragma omp parallel reduction (||:l)\n+  l = thr.t != omp_get_thread_num () + 11;\n+\n+  if (l)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "2ad3b3a6efcc62aaed512be009a9f2f45724c1a0", "filename": "libgomp/testsuite/libgomp.c++/ctor-1.C", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,65 @@\n+// { dg-do run }\n+\n+#include <omp.h>\n+#include <assert.h>\n+\n+struct B\n+{\n+  static int icount;\n+  static int dcount;\n+  static int xcount;\n+\n+  B();\n+  B(const B &);\n+  ~B();\n+  B& operator=(const B &);\n+  void doit();\n+};\n+\n+int B::icount;\n+int B::dcount;\n+int B::xcount;\n+\n+B::B()\n+{\n+  #pragma omp atomic \n+    icount++;\n+}\n+\n+B::~B()\n+{\n+  #pragma omp atomic\n+    dcount++;\n+}\n+\n+void B::doit()\n+{\n+  #pragma omp atomic\n+    xcount++;\n+}\n+\n+static int nthreads;\n+\n+void foo()\n+{\n+  B b;\n+  #pragma omp parallel private(b)\n+    {\n+      #pragma omp master\n+\tnthreads = omp_get_num_threads ();\n+      b.doit();\n+    }\n+}\n+\n+int main()\n+{\n+  omp_set_dynamic (0);\n+  omp_set_num_threads (4);\n+  foo();\n+\n+  assert (B::xcount == nthreads);\n+  assert (B::icount == nthreads+1);\n+  assert (B::dcount == nthreads+1);\n+\n+  return 0;\n+}"}, {"sha": "6611c592fda9a83bcc8d60eae8efdb1694d168c2", "filename": "libgomp/testsuite/libgomp.c++/ctor-2.C", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-2.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,76 @@\n+// { dg-do run }\n+\n+#include <omp.h>\n+#include <assert.h>\n+\n+struct B\n+{\n+  static int ccount;\n+  static int dcount;\n+  static int xcount;\n+  static B *expected;\n+\n+  B();\n+  B(int);\n+  B(const B &);\n+  ~B();\n+  B& operator=(const B &);\n+  void doit();\n+};\n+\n+int B::ccount;\n+int B::dcount;\n+int B::xcount;\n+B * B::expected;\n+\n+B::B(int)\n+{\n+  expected = this;\n+}\n+\n+B::B(const B &b)\n+{\n+  #pragma omp atomic \n+    ccount++;\n+  assert (&b == expected);\n+}\n+\n+B::~B()\n+{\n+  #pragma omp atomic\n+    dcount++;\n+}\n+\n+void B::doit()\n+{\n+  #pragma omp atomic\n+    xcount++;\n+  assert (this != expected);\n+}\n+\n+static int nthreads;\n+\n+void foo()\n+{\n+  B b(0);\n+\n+  #pragma omp parallel firstprivate(b)\n+    {\n+      #pragma omp master\n+\tnthreads = omp_get_num_threads ();\n+      b.doit();\n+    }\n+}\n+\n+int main()\n+{\n+  omp_set_dynamic (0);\n+  omp_set_num_threads (4);\n+  foo();\n+\n+  assert (B::xcount == nthreads);\n+  assert (B::ccount == nthreads);\n+  assert (B::dcount == nthreads+1);\n+\n+  return 0;\n+}"}, {"sha": "e65e4ea521b0ceaa14a3bf2ce26d0b1638535aa1", "filename": "libgomp/testsuite/libgomp.c++/ctor-3.C", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-3.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,89 @@\n+// { dg-do run }\n+\n+#include <omp.h>\n+#include <assert.h>\n+\n+struct B\n+{\n+  static int icount;\n+  static int dcount;\n+  static int ccount;\n+  static B *e_inner;\n+  static B *e_outer;\n+\n+  B();\n+  B(int);\n+  B(const B &);\n+  ~B();\n+  B& operator=(const B &);\n+  void doit();\n+};\n+\n+int B::icount;\n+int B::dcount;\n+int B::ccount;\n+B * B::e_inner;\n+B * B::e_outer;\n+\n+B::B()\n+{\n+  #pragma omp atomic \n+    icount++;\n+}\n+\n+B::B(int)\n+{\n+  e_outer = this;\n+}\n+\n+B::~B()\n+{\n+  #pragma omp atomic\n+    dcount++;\n+}\n+\n+B& B::operator= (const B &b)\n+{\n+  assert (&b == e_inner);\n+  assert (this == e_outer);\n+  #pragma omp atomic\n+    ccount++;\n+  return *this;\n+}\n+\n+void B::doit()\n+{\n+  #pragma omp critical\n+    {\n+      assert (e_inner == 0);\n+      e_inner = this;\n+    }\n+}\n+\n+static int nthreads;\n+\n+void foo()\n+{\n+  B b(0);\n+\n+  #pragma omp parallel sections lastprivate(b)\n+    {\n+    #pragma omp section\n+      nthreads = omp_get_num_threads ();\n+    #pragma omp section\n+      b.doit ();\n+    }\n+}\n+\n+int main()\n+{\n+  omp_set_dynamic (0);\n+  omp_set_num_threads (4);\n+  foo();\n+\n+  assert (B::ccount == 1);\n+  assert (B::icount == nthreads);\n+  assert (B::dcount == nthreads+1);\n+\n+  return 0;\n+}"}, {"sha": "e4f8f82db34e9a4019e3a9766fedac818666bbba", "filename": "libgomp/testsuite/libgomp.c++/ctor-4.C", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-4.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,90 @@\n+// { dg-do run }\n+\n+#include <omp.h>\n+#include <assert.h>\n+\n+struct B\n+{\n+  static int ccount;\n+  static int dcount;\n+  static int ecount;\n+  static B *e_inner;\n+  static B *e_outer;\n+\n+  B();\n+  B(int);\n+  B(const B &);\n+  ~B();\n+  B& operator=(const B &);\n+  void doit();\n+};\n+\n+int B::ccount;\n+int B::dcount;\n+int B::ecount;\n+B * B::e_inner;\n+B * B::e_outer;\n+\n+B::B(int)\n+{\n+  e_outer = this;\n+}\n+\n+B::B(const B &b)\n+{\n+  assert (&b == e_outer);\n+  #pragma omp atomic \n+    ccount++;\n+}\n+\n+B::~B()\n+{\n+  #pragma omp atomic\n+    dcount++;\n+}\n+\n+B& B::operator= (const B &b)\n+{\n+  assert (&b == e_inner);\n+  assert (this == e_outer);\n+  #pragma omp atomic\n+    ecount++;\n+  return *this;\n+}\n+\n+void B::doit()\n+{\n+  #pragma omp critical\n+    {\n+      assert (e_inner == 0);\n+      e_inner = this;\n+    }\n+}\n+\n+static int nthreads;\n+\n+void foo()\n+{\n+  B b(0);\n+\n+  #pragma omp parallel sections firstprivate(b) lastprivate(b)\n+    {\n+    #pragma omp section\n+      nthreads = omp_get_num_threads ();\n+    #pragma omp section\n+      b.doit ();\n+    }\n+}\n+\n+int main()\n+{\n+  omp_set_dynamic (0);\n+  omp_set_num_threads (4);\n+  foo();\n+\n+  assert (B::ecount == 1);\n+  assert (B::ccount == nthreads);\n+  assert (B::dcount == nthreads+1);\n+\n+  return 0;\n+}"}, {"sha": "d99a1d4628f737721abc1330420d45582e39d071", "filename": "libgomp/testsuite/libgomp.c++/ctor-5.C", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-5.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,52 @@\n+// { dg-do run }\n+// { dg-require-effective-target tls_runtime }\n+\n+#include <omp.h>\n+#include <assert.h>\n+\n+struct B\n+{\n+  static int count;\n+  static B *expected;\n+\n+  B& operator=(const B &);\n+};\n+\n+int B::count;\n+B * B::expected;\n+\n+static B thr;\n+#pragma omp threadprivate(thr)\n+\n+B& B::operator= (const B &b)\n+{\n+  assert (&b == expected);\n+  assert (this != expected);\n+  #pragma omp atomic\n+    count++;\n+  return *this;\n+}\n+\n+static int nthreads;\n+\n+void foo()\n+{\n+  B::expected = &thr;\n+\n+  #pragma omp parallel copyin(thr)\n+    {\n+    #pragma omp master\n+      nthreads = omp_get_num_threads ();\n+    }\n+}\n+\n+int main()\n+{\n+  omp_set_dynamic (0);\n+  omp_set_num_threads (4);\n+  foo();\n+\n+  assert (B::count == nthreads-1);\n+\n+  return 0;\n+}"}, {"sha": "eab74e08922473be70c39a785cb755720fbbac8d", "filename": "libgomp/testsuite/libgomp.c++/ctor-6.C", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-6.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,50 @@\n+// { dg-do run }\n+\n+#include <omp.h>\n+#include <assert.h>\n+\n+struct B\n+{\n+  static int count;\n+  static B *expected;\n+\n+  B& operator=(const B &);\n+};\n+\n+int B::count;\n+B * B::expected;\n+\n+B& B::operator= (const B &b)\n+{\n+  assert (&b == expected);\n+  assert (this != expected);\n+  #pragma omp atomic\n+    count++;\n+  return *this;\n+}\n+\n+static int nthreads;\n+\n+void foo()\n+{\n+  #pragma omp parallel\n+    {\n+      B b;\n+      #pragma omp single copyprivate(b)\n+\t{\n+\t  nthreads = omp_get_num_threads ();\n+\t  B::expected = &b;\n+\t}\n+    }\n+}\n+\n+int main()\n+{\n+  omp_set_dynamic (0);\n+  omp_set_num_threads (4);\n+  foo();\n+\n+  assert (B::count == nthreads-1);\n+\n+  return 0;\n+}"}, {"sha": "3d669a707910a0dba6395806066f84a4351959e3", "filename": "libgomp/testsuite/libgomp.c++/ctor-7.C", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-7.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,67 @@\n+// { dg-do run }\n+\n+#include <omp.h>\n+#include <assert.h>\n+\n+#define N 10\n+\n+struct B\n+{\n+  static int icount;\n+  static int dcount;\n+  static int xcount;\n+\n+  B();\n+  B(const B &);\n+  ~B();\n+  B& operator=(const B &);\n+  void doit();\n+};\n+\n+int B::icount;\n+int B::dcount;\n+int B::xcount;\n+\n+B::B()\n+{\n+  #pragma omp atomic \n+    icount++;\n+}\n+\n+B::~B()\n+{\n+  #pragma omp atomic\n+    dcount++;\n+}\n+\n+void B::doit()\n+{\n+  #pragma omp atomic\n+    xcount++;\n+}\n+\n+static int nthreads;\n+\n+void foo()\n+{\n+  B b[N];\n+  #pragma omp parallel private(b)\n+    {\n+      #pragma omp master\n+\tnthreads = omp_get_num_threads ();\n+      b[0].doit();\n+    }\n+}\n+\n+int main()\n+{\n+  omp_set_dynamic (0);\n+  omp_set_num_threads (4);\n+  foo();\n+\n+  assert (B::xcount == nthreads);\n+  assert (B::icount == (nthreads+1)*N);\n+  assert (B::dcount == (nthreads+1)*N);\n+\n+  return 0;\n+}"}, {"sha": "5c0d81b73d10e443acf9682d4e745ce05cf12e9a", "filename": "libgomp/testsuite/libgomp.c++/ctor-8.C", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-8.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,77 @@\n+// { dg-do run }\n+// { dg-require-effective-target tls_runtime }\n+\n+#include <omp.h>\n+#include <assert.h>\n+\n+#define N 10\n+#define THR 4\n+\n+struct B\n+{\n+  B();\n+  B(const B &);\n+  ~B();\n+  B& operator=(const B &);\n+  void doit();\n+};\n+\n+static B *base;\n+static B *threadbase;\n+static unsigned cmask[THR];\n+static unsigned dmask[THR];\n+\n+#pragma omp threadprivate(threadbase)\n+\n+B::B()\n+{\n+  assert (base == 0);\n+}\n+\n+B::B(const B &b)\n+{\n+  unsigned index = &b - base;\n+  assert (index < N);\n+  cmask[omp_get_thread_num()] |= 1u << index;\n+}\n+\n+B::~B()\n+{\n+  if (threadbase)\n+    {\n+      unsigned index = this - threadbase;\n+      assert (index < N);\n+      dmask[omp_get_thread_num()] |= 1u << index;\n+    }\n+}\n+\n+void foo()\n+{\n+  B b[N];\n+\n+  base = b;\n+\n+  #pragma omp parallel firstprivate(b)\n+    {\n+      assert (omp_get_num_threads () == THR);\n+      threadbase = b;\n+    }\n+\n+  threadbase = 0;\n+}\n+\n+int main()\n+{\n+  omp_set_dynamic (0);\n+  omp_set_num_threads (THR);\n+  foo();\n+\n+  for (int i = 0; i < THR; ++i)\n+    {\n+      unsigned xmask = (1u << N) - 1;\n+      assert (cmask[i] == xmask);\n+      assert (dmask[i] == xmask);\n+    }\n+\n+  return 0;\n+}"}, {"sha": "215a901f8d352d94c1f73721199c2e2b3ec82110", "filename": "libgomp/testsuite/libgomp.c++/ctor-9.C", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fctor-9.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,60 @@\n+// { dg-do run }\n+// { dg-require-effective-target tls_runtime }\n+\n+#include <omp.h>\n+#include <assert.h>\n+\n+#define N 10\n+#define THR 4\n+\n+struct B\n+{\n+  B& operator=(const B &);\n+};\n+\n+static B *base;\n+static B *threadbase;\n+static int singlethread;\n+#pragma omp threadprivate(threadbase)\n+\n+static unsigned cmask[THR];\n+\n+B& B::operator= (const B &b)\n+{\n+  unsigned sindex = &b - base;\n+  unsigned tindex = this - threadbase;\n+  assert(sindex < N);\n+  assert(sindex == tindex);\n+  cmask[omp_get_thread_num ()] |= 1u << tindex;\n+  return *this;\n+}\n+\n+void foo()\n+{\n+  #pragma omp parallel\n+    {\n+      B b[N];\n+      threadbase = b;\n+      #pragma omp single copyprivate(b)\n+\t{\n+\t  assert(omp_get_num_threads () == THR);\n+\t  singlethread = omp_get_thread_num ();\n+\t  base = b;\n+\t}\n+    }\n+}\n+\n+int main()\n+{\n+  omp_set_dynamic (0);\n+  omp_set_num_threads (THR);\n+  foo();\n+\n+  for (int i = 0; i < THR; ++i)\n+    if (i == singlethread)\n+      assert(cmask[singlethread] == 0);\n+    else\n+      assert(cmask[i] == (1u << N) - 1);\n+\n+  return 0;\n+}"}, {"sha": "0e83c95832f1d40aafbcfa775fac5490280046e2", "filename": "libgomp/testsuite/libgomp.c++/loop-1.C", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,96 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include <omp.h>\n+\n+#define MAX\t1000\n+\n+void main1()\n+{\n+  int i, N1, N2, step;\n+  int a[MAX], b[MAX];\n+\n+  N1 = rand () % 13;\n+  N2 = rand () % (MAX - 51) + 50;\n+  step = rand () % 7 + 1;\n+\n+  printf (\"N1 = %d\\nN2 = %d\\nstep = %d\\n\", N1, N2, step);\n+\n+  for (i = N1; i <= N2; i += step)\n+    a[i] = 42+ i;\n+\n+  /* COUNTING UP (<).  Fill in array 'b' in parallel.  */\n+  memset (b, 0, sizeof b);\n+#pragma omp parallel shared(a,b,N1,N2,step) private(i)\n+  {\n+#pragma omp for\n+    for (i = N1; i < N2; i += step)\n+      b[i] = a[i];\n+  }\n+\n+  /* COUNTING UP (<).  Check that all the cells were filled in properly.  */\n+  for (i = N1; i < N2; i += step)\n+    if (a[i] != b[i])\n+      abort ();\n+\n+  printf (\"for (i = %d; i < %d; i += %d) [OK]\\n\", N1, N2, step);\n+\n+  /* COUNTING UP (<=).  Fill in array 'b' in parallel.  */\n+  memset (b, 0, sizeof b);\n+#pragma omp parallel shared(a,b,N1,N2,step) private(i)\n+  {\n+#pragma omp for\n+    for (i = N1; i <= N2; i += step)\n+      b[i] = a[i];\n+  }\n+\n+  /* COUNTING UP (<=).  Check that all the cells were filled in properly.  */\n+  for (i = N1; i <= N2; i += step)\n+    if (a[i] != b[i])\n+      abort ();\n+\n+  printf (\"for (i = %d; i <= %d; i += %d) [OK]\\n\", N1, N2, step);\n+\n+  /* COUNTING DOWN (>).  Fill in array 'b' in parallel.  */\n+  memset (b, 0, sizeof b);\n+#pragma omp parallel shared(a,b,N1,N2,step) private(i)\n+  {\n+#pragma omp for\n+    for (i = N2; i > N1; i -= step)\n+      b[i] = a[i];\n+  }\n+\n+  /* COUNTING DOWN (>).  Check that all the cells were filled in properly.  */\n+  for (i = N2; i > N1; i -= step)\n+    if (a[i] != b[i])\n+      abort ();\n+\n+  printf (\"for (i = %d; i > %d; i -= %d) [OK]\\n\", N2, N1, step);\n+\n+  /* COUNTING DOWN (>=).  Fill in array 'b' in parallel.  */\n+  memset (b, 0, sizeof b);\n+#pragma omp parallel shared(a,b,N1,N2,step) private(i)\n+  {\n+#pragma omp for\n+    for (i = N2; i >= N1; i -= step)\n+      b[i] = a[i];\n+  }\n+\n+  /* COUNTING DOWN (>=).  Check that all the cells were filled in properly.  */\n+  for (i = N2; i >= N1; i -= step)\n+    if (a[i] != b[i])\n+      abort ();\n+\n+  printf (\"for (i = %d; i >= %d; i -= %d) [OK]\\n\", N2, N1, step);\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+\n+  srand (0);\n+  for (i = 0; i < 10; ++i)\n+    main1();\n+  return 0;\n+}"}, {"sha": "ea3dc588afd1a33a35c75077a62abd1eb26db6ea", "filename": "libgomp/testsuite/libgomp.c++/loop-2.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-2.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,32 @@\n+#include <omp.h>\n+\n+/* Orphaned work sharing.  */\n+\n+extern \"C\" void abort (void);\n+\n+#define N 10\n+\n+void parloop (int *a)\n+{\n+  int i;\n+\n+#pragma omp for\n+  for (i = 0; i < N; i++)\n+    a[i] = i + 3;\n+}\n+\n+main()\n+{\n+  int i, a[N];\n+\n+#pragma omp parallel shared(a)\n+  {\n+    parloop (a);\n+  }\n+\n+  for (i = 0; i < N; i++)\n+    if (a[i] != i + 3)\n+      abort ();\n+\n+  return 0;\n+}"}, {"sha": "fa50f099f3ff4330532799f74659face4ba44ffe", "filename": "libgomp/testsuite/libgomp.c++/loop-3.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-3.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,26 @@\n+extern \"C\" void abort (void);\n+int a;\n+\n+void\n+foo ()\n+{\n+  int i;\n+  a = 30;\n+#pragma omp barrier\n+#pragma omp for lastprivate (a)\n+  for (i = 0; i < 1024; i++)\n+    {\n+      a = i;\n+    }\n+  if (a != 1023)\n+    abort ();\n+}\n+\n+int\n+main (void)\n+{\n+#pragma omp parallel num_threads (64)\n+  foo ();\n+\n+  return 0;\n+}"}, {"sha": "731f234502176f239305d240b1d377baeca475bb", "filename": "libgomp/testsuite/libgomp.c++/loop-4.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-4.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,20 @@\n+extern \"C\" void abort (void);\n+\n+main()\n+{\n+  int i, a;\n+\n+  a = 30;\n+\n+#pragma omp parallel for firstprivate (a) lastprivate (a) \\\n+\tnum_threads (2) schedule(static)\n+  for (i = 0; i < 10; i++)\n+    a = a + i;\n+\n+  /* The thread that owns the last iteration will have computed\n+     30 + 5 + 6 + 7 + 8 + 9 = 65.  */\n+  if (a != 65)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "c427efa85c69a2a03ff9ef07847f429f1a0e1462", "filename": "libgomp/testsuite/libgomp.c++/loop-5.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-5.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,19 @@\n+extern \"C\" void abort ();\n+\n+int check;\n+int f1() { check |= 1; return 1; }\n+int f2() { check |= 2; return 11; }\n+int f3() { check |= 4; return 2; }\n+\n+int a[12];\n+\n+int main()\n+{\n+  #pragma omp for\n+  for (int i = f1(); i <= f2(); i += f3())\n+    a[i] = 1;\n+\n+  for (int i = 0; i < 12; ++i)\n+    if (a[i] != (i & 1))\n+      abort ();\n+}"}, {"sha": "fa26c6892cff218e447e1445b91ae381d674bb30", "filename": "libgomp/testsuite/libgomp.c++/loop-6.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-6.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,24 @@\n+// { dg-do run }\n+\n+extern \"C\" void abort (void);\n+\n+volatile int count;\n+static int test(void)\n+{\n+  return ++count > 0;\n+}\n+\n+int main()\n+{\n+  int i;\n+  #pragma omp for\n+  for (i = 0; i < 10; ++i)\n+    {\n+      if (test())\n+\tcontinue;\n+      abort ();\n+    }\n+  if (i != count)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "4eccb7fca01f640959dba8baf922bbe2bb80dd70", "filename": "libgomp/testsuite/libgomp.c++/loop-7.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Floop-7.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,22 @@\n+// PR c++/24502\n+// { dg-do run }\n+\n+extern \"C\" void abort ();\n+\n+template <typename T> T\n+foo (T r)\n+{\n+  T i;\n+#pragma omp for\n+  for (i = 0; i < 10; i++)\n+    r += i;\n+  return r;\n+}\n+\n+int\n+main ()\n+{\n+  if (foo (0) != 10 * 9 / 2 || foo (2L) != 10L * 9 / 2 + 2)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "734b4e2cd98e72528ec6ffc734c5a56480073b8d", "filename": "libgomp/testsuite/libgomp.c++/master-1.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmaster-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmaster-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fmaster-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,24 @@\n+// PR c++/24734\n+// { dg-do run }\n+\n+extern \"C\" void abort ();\n+int i;\n+\n+template<int> void\n+foo ()\n+{\n+  #pragma omp parallel\n+    {\n+    #pragma omp master\n+      i++;\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  foo<0> ();\n+  if (i != 1)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "8d0e397bd2e628526575b6bd322b4b0a5fc7b1b7", "filename": "libgomp/testsuite/libgomp.c++/nested-1.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fnested-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fnested-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fnested-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,28 @@\n+// { dg-do run }\n+\n+extern \"C\" void abort(void);\n+#define N 1000\n+\n+int foo()\n+{\n+  int i = 0, j;\n+\n+  #pragma omp parallel for num_threads(2) shared (i)\n+  for (j = 0; j < N; ++j)\n+    {\n+      #pragma omp parallel num_threads(1) shared (i)\n+      {\n+\t#pragma omp atomic\n+\ti++;\n+      }\n+    }\n+\n+  return i;\n+}\n+\n+int main()\n+{\n+  if (foo() != N)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "3c93147132840faa7226b500b28ee2497ee8f9f6", "filename": "libgomp/testsuite/libgomp.c++/parallel-1.C", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fparallel-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fparallel-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fparallel-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,40 @@\n+#include <omp.h>\n+\n+extern \"C\" void abort (void);\n+\n+int\n+foo (void)\n+{\n+  return 10;\n+}\n+\n+main ()\n+{\n+  int A = 0;\n+\n+  #pragma omp parallel if (foo () > 10) shared (A)\n+    {\n+      A = omp_get_num_threads ();\n+    }\n+\n+  if (A != 1)\n+    abort ();\n+\n+  #pragma omp parallel if (foo () == 10) num_threads (3) shared (A)\n+    {\n+      A = omp_get_num_threads ();\n+    }\n+\n+  if (A != 3)\n+    abort ();\n+\n+  #pragma omp parallel if (foo () == 10) num_threads (foo ()) shared (A)\n+    {\n+      A = omp_get_num_threads ();\n+    }\n+\n+  if (A != 10)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "e7f38f8ab7b610cfcdf50fcec936807d3a054a82", "filename": "libgomp/testsuite/libgomp.c++/pr24455-1.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr24455-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr24455-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr24455-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,6 @@\n+// { dg-do compile }\n+// { dg-require-effective-target tls }\n+extern int i;\n+#pragma omp threadprivate (i)\n+\n+int i;"}, {"sha": "ad43b47b2c50860cd7bd08a0c253cd7d089768ef", "filename": "libgomp/testsuite/libgomp.c++/pr24455.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr24455.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr24455.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr24455.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,23 @@\n+// { dg-do run }\n+// { dg-additional-sources pr24455-1.C }\n+// { dg-require-effective-target tls_runtime }\n+\n+extern \"C\" void abort (void);\n+\n+extern int i;\n+#pragma omp threadprivate(i)\n+\n+int main()\n+{\n+  i = 0;\n+\n+#pragma omp parallel default(none) num_threads(10) copyin(i)\n+    {\n+      i++;\n+#pragma omp barrier\n+      if (i != 1)\n+\tabort ();\n+    }\n+\n+    return 0;\n+}"}, {"sha": "665163af09f9181a7a35f33090968497c6f3f94e", "filename": "libgomp/testsuite/libgomp.c++/reduction-1.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,36 @@\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+int\n+main (void)\n+{\n+  int i = 0, j = 0, k = ~0;\n+  double d = 1.0;\n+#pragma omp parallel num_threads(4) reduction(+:i) reduction(*:d) reduction(&:k)\n+  {\n+    if (i != 0 || d != 1.0 || k != ~0)\n+#pragma omp atomic\n+      j |= 1;\n+  \n+    if (omp_get_num_threads () != 4)\n+#pragma omp atomic\n+      j |= 2;\n+\n+    i = omp_get_thread_num ();\n+    d = i + 1;\n+    k = ~(1 << (2 * i));\n+  }\n+\n+  if (j & 1)\n+    abort ();\n+  if ((j & 2) == 0)\n+    {\n+      if (i != (0 + 1 + 2 + 3))\n+\tabort ();\n+      if (d != (1.0 * 2.0 * 3.0 * 4.0))\n+\tabort ();\n+      if (k != (~0 ^ 0x55))\n+\tabort ();\n+    }\n+  return 0;\n+}"}, {"sha": "52b3faff787e3a3d160cd15c3c37dbda88d91852", "filename": "libgomp/testsuite/libgomp.c++/reduction-2.C", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-2.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,50 @@\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+int\n+main (void)\n+{\n+  int i = 0, j = 0, k = ~0, l;\n+  double d = 1.0;\n+#pragma omp parallel num_threads(4)\n+  {\n+#pragma omp single\n+    {\n+      i = 16;\n+      k ^= (1 << 16);\n+      d += 32.0;\n+    }\n+\n+#pragma omp for reduction(+:i) reduction(*:d) reduction(&:k)\n+    for (l = 0; l < 4; l++)\n+      {\n+\tif (omp_get_num_threads () == 4 && (i != 0 || d != 1.0 || k != ~0))\n+#pragma omp atomic\n+\t  j |= 1;\n+  \n+\tif (l == omp_get_thread_num ())\n+\t  {\n+\t    i = omp_get_thread_num ();\n+\t    d = i + 1;\n+\t    k = ~(1 << (2 * i));\n+\t  }\n+      }\n+\n+    if (omp_get_num_threads () == 4)\n+      {\n+\tif (i != (16 + 0 + 1 + 2 + 3))\n+#pragma omp atomic\n+\t  j |= 2;\n+\tif (d != (33.0 * 1.0 * 2.0 * 3.0 * 4.0))\n+#pragma omp atomic\n+\t  j |= 4;\n+\tif (k != (~0 ^ 0x55 ^ (1 << 16)))\n+#pragma omp atomic\n+\t  j |= 8;\n+      }\n+  }\n+\n+  if (j)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "4f8f2fc123660df26413aa80641604b131237d22", "filename": "libgomp/testsuite/libgomp.c++/reduction-3.C", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Freduction-3.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,51 @@\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+int\n+main (void)\n+{\n+  int i = 0, j = 0, k = ~0, l;\n+  double d = 1.0;\n+#pragma omp parallel num_threads(4)\n+  {\n+#pragma omp single\n+    {\n+      i = 16;\n+      k ^= (1 << 16);\n+      d += 32.0;\n+    }\n+\n+#pragma omp for reduction(+:i) reduction(*:d) reduction(&:k) nowait\n+    for (l = 0; l < 4; l++)\n+      {\n+\tif (omp_get_num_threads () == 4 && (i != 0 || d != 1.0 || k != ~0))\n+#pragma omp atomic\n+\t  j |= 1;\n+  \n+\tif (l == omp_get_thread_num ())\n+\t  {\n+\t    i = omp_get_thread_num ();\n+\t    d = i + 1;\n+\t    k = ~(1 << (2 * i));\n+\t  }\n+      }\n+\n+    if (omp_get_num_threads () == 4)\n+      {\n+#pragma omp barrier\n+\tif (i != (16 + 0 + 1 + 2 + 3))\n+#pragma omp atomic\n+\t  j |= 2;\n+\tif (d != (33.0 * 1.0 * 2.0 * 3.0 * 4.0))\n+#pragma omp atomic\n+\t  j |= 4;\n+\tif (k != (~0 ^ 0x55 ^ (1 << 16)))\n+#pragma omp atomic\n+\t  j |= 8;\n+      }\n+  }\n+\n+  if (j)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "32c93dbdef69c5634ca76f9863da6ba41fa9121f", "filename": "libgomp/testsuite/libgomp.c++/sections-1.C", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsections-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsections-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsections-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,64 @@\n+/******************************************************************************\n+* FILE: omp_workshare2.c\n+* DESCRIPTION:\n+*   OpenMP Example - Sections Work-sharing - C/C++ Version\n+*   In this example, the OpenMP SECTION directive is used to assign\n+*   different array operations to threads that execute a SECTION. Each \n+*   thread receives its own copy of the result array to work with.\n+* AUTHOR: Blaise Barney  5/99\n+* LAST REVISED: 04/06/05\n+******************************************************************************/\n+#include <omp.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#define N     50\n+\n+int main (int argc, char *argv[]) {\n+\n+int i, nthreads, tid;\n+float a[N], b[N], c[N];\n+\n+/* Some initializations */\n+for (i=0; i<N; i++)\n+  a[i] = b[i] = i * 1.0;\n+\n+#pragma omp parallel shared(a,b,nthreads) private(c,i,tid)\n+  {\n+  tid = omp_get_thread_num();\n+  if (tid == 0)\n+    {\n+    nthreads = omp_get_num_threads();\n+    printf(\"Number of threads = %d\\n\", nthreads);\n+    }\n+  printf(\"Thread %d starting...\\n\",tid);\n+\n+  #pragma omp sections nowait\n+    {\n+    #pragma omp section\n+      {\n+      printf(\"Thread %d doing section 1\\n\",tid);\n+      for (i=0; i<N; i++)\n+        {\n+        c[i] = a[i] + b[i];\n+        printf(\"Thread %d: c[%d]= %f\\n\",tid,i,c[i]);\n+        }\n+      }\n+\n+    #pragma omp section\n+      {\n+      printf(\"Thread %d doing section 2\\n\",tid);\n+      for (i=0; i<N; i++)\n+        {\n+        c[i] = a[i] * b[i];\n+        printf(\"Thread %d: c[%d]= %f\\n\",tid,i,c[i]);\n+        }\n+      }\n+\n+    }  /* end of sections */\n+\n+    printf(\"Thread %d done.\\n\",tid); \n+\n+  }  /* end of parallel section */\n+\n+  return 0;\n+}"}, {"sha": "334a553ce238c1ce0b00727e58eeb34f3fd52ca3", "filename": "libgomp/testsuite/libgomp.c++/shared-1.C", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fshared-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fshared-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fshared-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,60 @@\n+#include <omp.h>\n+\n+extern \"C\" void abort (void);\n+\n+struct Y\n+{\n+  int l[5][10];\n+};\n+\n+struct X\n+{\n+  struct Y y;\n+  float b[10];\n+};\n+\n+void\n+parallel (int a, int b)\n+{\n+  int i, j;\n+  struct X A[10][5];\n+  a = b = 3;\n+\n+  for (i = 0; i < 10; i++)\n+    for (j = 0; j < 5; j++)\n+      A[i][j].y.l[3][3] = -10;\n+\n+  #pragma omp parallel shared (a, b, A) num_threads (5)\n+    {\n+      int i, j;\n+\n+      #pragma omp atomic\n+      a += omp_get_num_threads ();\n+\n+      #pragma omp atomic\n+      b += omp_get_num_threads ();\n+\n+      #pragma omp for private (j)\n+      for (i = 0; i < 10; i++)\n+\tfor (j = 0; j < 5; j++)\n+\t  A[i][j].y.l[3][3] += 20;\n+\n+    }\n+\n+  for (i = 0; i < 10; i++)\n+    for (j = 0; j < 5; j++)\n+      if (A[i][j].y.l[3][3] != 10)\n+\tabort ();\n+\n+  if (a != 28)\n+    abort ();\n+\n+  if (b != 28)\n+    abort ();\n+}\n+\n+main()\n+{\n+  parallel (1, 2);\n+  return 0;\n+}"}, {"sha": "01855fbd496e48233928617021a186f491d9b475", "filename": "libgomp/testsuite/libgomp.c++/shared-2.C", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fshared-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fshared-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fshared-2.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,47 @@\n+extern \"C\" void abort (void);\n+\n+void\n+parallel (int a, int b)\n+{\n+  int bad, LASTPRIV, LASTPRIV_SEC;\n+  int i;\n+\n+  a = b = 3;\n+\n+  bad = 0;\n+\n+  #pragma omp parallel firstprivate (a,b) shared (bad) num_threads (5)\n+    {\n+      if (a != 3 || b != 3)\n+\tbad = 1;\n+\n+      #pragma omp for lastprivate (LASTPRIV)\n+      for (i = 0; i < 10; i++)\n+\tLASTPRIV = i;\n+\n+      #pragma omp sections lastprivate (LASTPRIV_SEC)\n+\t{\n+\t  #pragma omp section\n+\t    { LASTPRIV_SEC = 3; }\n+\n+\t  #pragma omp section\n+\t    { LASTPRIV_SEC = 42; }\n+\t}\n+\n+    }\n+\n+  if (LASTPRIV != 9)\n+    abort ();\n+\n+  if (LASTPRIV_SEC != 42)\n+    abort ();\n+\n+  if (bad)\n+    abort ();\n+}\n+\n+int main()\n+{\n+  parallel (1, 2);\n+  return 0;\n+}"}, {"sha": "e318a48ca5ccc10d6d5fb316c05fd03a0780b690", "filename": "libgomp/testsuite/libgomp.c++/single-1.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsingle-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsingle-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsingle-1.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,19 @@\n+extern \"C\" void abort (void);\n+\n+main()\n+{\n+  int i = 0;\n+\n+  #pragma omp parallel shared (i)\n+    {\n+      #pragma omp single\n+\t{\n+\t  i++;\n+\t}\n+    }\n+\n+  if (i != 1)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "c2dd228568dce187e88fbd3b3bfde0442539ecef", "filename": "libgomp/testsuite/libgomp.c++/single-2.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsingle-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsingle-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsingle-2.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,36 @@\n+extern \"C\" void abort (void);\n+\n+struct X\n+{\n+  int a;\n+  char b;\n+  int c;\n+};\n+\n+main()\n+{\n+  int i = 0;\n+  struct X x;\n+  int bad = 0;\n+\n+  #pragma omp parallel private (i, x) shared (bad)\n+    {\n+      i = 5;\n+\n+      #pragma omp single copyprivate (i, x)\n+\t{\n+\t  i++;\n+\t  x.a = 23;\n+\t  x.b = 42;\n+\t  x.c = 26;\n+\t}\n+\n+      if (i != 6 || x.a != 23 || x.b != 42 || x.c != 26)\n+\tbad = 1;\n+    }\n+\n+  if (bad)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "abc7f44b31140330e63ceecd38fcfc00e17a7f8a", "filename": "libgomp/testsuite/libgomp.c++/single-3.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsingle-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1799e5d5ca20304e32f7d1134ba5e8a2ab231880/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsingle-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fsingle-3.C?ref=1799e5d5ca20304e32f7d1134ba5e8a2ab231880", "patch": "@@ -0,0 +1,21 @@\n+extern \"C\" void abort (void);\n+\n+void\n+single (int a, int b)\n+{\n+  #pragma omp single copyprivate(a) copyprivate(b)\n+    {\n+      a = b = 5;\n+    }\n+\n+  if (a != b)\n+    abort ();\n+}\n+\n+int main()\n+{\n+  #pragma omp parallel\n+    single (1, 2);\n+\n+  return 0;\n+}"}]}