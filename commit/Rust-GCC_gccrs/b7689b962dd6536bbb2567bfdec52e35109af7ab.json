{"sha": "b7689b962dd6536bbb2567bfdec52e35109af7ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc2ODliOTYyZGQ2NTM2YmJiMjU2N2JmZGVjNTJlMzUxMDlhZjdhYg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-11-05T23:56:18Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-11-05T23:56:18Z"}, "message": "Implement C++20 operator<=>.\n\nThere are three major pieces to this support: scalar operator<=>,\nsynthesis of comparison operators, and rewritten/reversed overload\nresolution (e.g. a < b becomes 0 > b <=> a).\n\nUnlike other defaulted functions, where we use synthesized_method_walk to\nsemi-simulate what the definition of the function will be like, this patch\ndetermines the characteristics of a comparison operator by trying to define\nit.\n\nMy handling of non-dependent rewritten operators in templates can still use\nsome work: build_min_non_dep_op_overload can't understand the rewrites and\ncrashes, so I'm avoiding it for now by clearing *overload.  This means we'll\ndo name lookup again at instantiation time, which can incorrectly mean a\ndifferent result.  I'll poke at this more in stage 3.\n\nI'm leaving out a fourth section (\"strong structural equality\") even though\nI've implemented it, because it seems likely to change radically tomorrow.\n\nThanks to Tim van Deurzen and Jakub for implementing lexing of the <=>\noperator, and Jonathan for the initial <compare> header.\n\ngcc/cp/\n\t* cp-tree.h (struct lang_decl_fn): Add maybe_deleted bitfield.\n\t(DECL_MAYBE_DELETED): New.\n\t(enum special_function_kind): Add sfk_comparison.\n\t(LOOKUP_REWRITTEN, LOOKUP_REVERSED): New.\n\t* call.c (struct z_candidate): Add rewritten and reversed methods.\n\t(add_builtin_candidate): Handle SPACESHIP_EXPR.\n\t(add_builtin_candidates): Likewise.\n\t(add_candidates): Don't add a reversed candidate if the parms are\n\tthe same.\n\t(add_operator_candidates): Split out from build_new_op_1.  Handle\n\trewritten and reversed candidates.\n\t(add_candidate): Swap conversions of reversed candidate.\n\t(build_new_op_1): Swap them back.  Build a second operation for\n\trewritten candidates.\n\t(extract_call_expr): Handle rewritten calls.\n\t(same_fn_or_template): New.\n\t(joust): Handle rewritten and reversed candidates.\n\t* class.c (add_implicitly_declared_members): Add implicit op==.\n\t(classtype_has_op, classtype_has_defaulted_op): New.\n\t* constexpr.c (cxx_eval_binary_expression): Handle SPACESHIP_EXPR.\n\t(cxx_eval_constant_expression, potential_constant_expression_1):\n\tLikewise.\n\t* cp-gimplify.c (genericize_spaceship): New.\n\t(cp_genericize_r): Use it.\n\t* cp-objcp-common.c (cp_common_init_ts): Handle SPACESHIP_EXPR.\n\t* decl.c (finish_function): Handle deleted function.\n\t* decl2.c (grokfield): SET_DECL_FRIEND_CONTEXT on defaulted friend.\n\t(mark_used): Check DECL_MAYBE_DELETED.  Remove assumption that\n\tdefaulted functions are non-static members.\n\t* error.c (dump_expr): Handle SPACESHIP_EXPR.\n\t* method.c (type_has_trivial_fn): False for sfk_comparison.\n\t(enum comp_cat_tag, struct comp_cat_info_t): New types.\n\t(comp_cat_cache): New array variable.\n\t(lookup_comparison_result, lookup_comparison_category)\n\t(is_cat, cat_tag_for, spaceship_comp_cat)\n\t(spaceship_type, genericize_spaceship)\n\t(common_comparison_type, early_check_defaulted_comparison)\n\t(comp_info, build_comparison_op): New.\n\t(synthesize_method): Handle sfk_comparison.  Handle deleted.\n\t(get_defaulted_eh_spec, maybe_explain_implicit_delete)\n\t(explain_implicit_non_constexpr, implicitly_declare_fn)\n\t(defaulted_late_check, defaultable_fn_check): Handle sfk_comparison.\n\t* name-lookup.c (get_std_name_hint): Add comparison categories.\n\t* tree.c (special_function_p): Add sfk_comparison.\n\t* typeck.c (cp_build_binary_op): Handle SPACESHIP_EXPR.\n\n2019-11-05  Tim van Deurzen  <tim@kompiler.org>\n\n\tAdd new tree code for the spaceship operator.\ngcc/cp/\n\t* cp-tree.def: Add new tree code.\n\t* operators.def: New binary operator.\n\t* parser.c: Add new token and tree code.\nlibcpp/\n\t* cpplib.h: Add spaceship operator for C++.\n\t* lex.c: Implement conditional lexing of spaceship operator for C++20.\n\n2019-11-05  Jonathan Wakely  <jwakely@redhat.com>\n\nlibstdc++-v3/\n\t* libsupc++/compare: New header.\n\t* libsupc++/Makefile.am (std_HEADERS): Add compare.\n\t* include/std/version: Define __cpp_lib_three_way_comparison.\n\t* include/std/functional: #include <compare>.\n\nFrom-SVN: r277865", "tree": {"sha": "6a00e1710db7a55cbcfec28cfbaf837950a9c70b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a00e1710db7a55cbcfec28cfbaf837950a9c70b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7689b962dd6536bbb2567bfdec52e35109af7ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7689b962dd6536bbb2567bfdec52e35109af7ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7689b962dd6536bbb2567bfdec52e35109af7ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7689b962dd6536bbb2567bfdec52e35109af7ab/comments", "author": null, "committer": null, "parents": [{"sha": "b63566a4045e9cc27f739c89f863dbfb9dbe7860", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b63566a4045e9cc27f739c89f863dbfb9dbe7860", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b63566a4045e9cc27f739c89f863dbfb9dbe7860"}], "stats": {"total": 2780, "additions": 2653, "deletions": 127}, "files": [{"sha": "cf3d437fc37065704448984a0b284c916ba73509", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -990,6 +990,7 @@ c_cpp_builtins (cpp_reader *pfile)\n \t  cpp_define (pfile, \"__cpp_nontype_template_parameter_class=201806L\");\n \t  cpp_define (pfile, \"__cpp_impl_destroying_delete=201806L\");\n \t  cpp_define (pfile, \"__cpp_constexpr_dynamic_alloc=201907L\");\n+\t  cpp_define (pfile, \"__cpp_impl_three_way_comparison=201907L\");\n \t}\n       if (flag_concepts)\n         {"}, {"sha": "d0b47f7c5629ed10b298c98a49fb761eced9810d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -1,3 +1,59 @@\n+2019-11-05  Jason Merrill  <jason@redhat.com>\n+\n+\tImplement C++20 operator<=>.\n+\t* cp-tree.h (struct lang_decl_fn): Add maybe_deleted bitfield.\n+\t(DECL_MAYBE_DELETED): New.\n+\t(enum special_function_kind): Add sfk_comparison.\n+\t(LOOKUP_REWRITTEN, LOOKUP_REVERSED): New.\n+\t* call.c (struct z_candidate): Add rewritten and reversed methods.\n+\t(add_builtin_candidate): Handle SPACESHIP_EXPR.\n+\t(add_builtin_candidates): Likewise.\n+\t(add_candidates): Don't add a reversed candidate if the parms are\n+\tthe same.\n+\t(add_operator_candidates): Split out from build_new_op_1.  Handle\n+\trewritten and reversed candidates.\n+\t(add_candidate): Swap conversions of reversed candidate.\n+\t(build_new_op_1): Swap them back.  Build a second operation for\n+\trewritten candidates.\n+\t(extract_call_expr): Handle rewritten calls.\n+\t(same_fn_or_template): New.\n+\t(joust): Handle rewritten and reversed candidates.\n+\t* class.c (add_implicitly_declared_members): Add implicit op==.\n+\t(classtype_has_op, classtype_has_defaulted_op): New.\n+\t* constexpr.c (cxx_eval_binary_expression): Handle SPACESHIP_EXPR.\n+\t(cxx_eval_constant_expression, potential_constant_expression_1):\n+\tLikewise.\n+\t* cp-gimplify.c (genericize_spaceship): New.\n+\t(cp_genericize_r): Use it.\n+\t* cp-objcp-common.c (cp_common_init_ts): Handle SPACESHIP_EXPR.\n+\t* decl.c (finish_function): Handle deleted function.\n+\t* decl2.c (grokfield): SET_DECL_FRIEND_CONTEXT on defaulted friend.\n+\t(mark_used): Check DECL_MAYBE_DELETED.  Remove assumption that\n+\tdefaulted functions are non-static members.\n+\t* error.c (dump_expr): Handle SPACESHIP_EXPR.\n+\t* method.c (type_has_trivial_fn): False for sfk_comparison.\n+\t(enum comp_cat_tag, struct comp_cat_info_t): New types.\n+\t(comp_cat_cache): New array variable.\n+\t(lookup_comparison_result, lookup_comparison_category)\n+\t(is_cat, cat_tag_for, spaceship_comp_cat)\n+\t(spaceship_type, genericize_spaceship)\n+\t(common_comparison_type, early_check_defaulted_comparison)\n+\t(comp_info, build_comparison_op): New.\n+\t(synthesize_method): Handle sfk_comparison.  Handle deleted.\n+\t(get_defaulted_eh_spec, maybe_explain_implicit_delete)\n+\t(explain_implicit_non_constexpr, implicitly_declare_fn)\n+\t(defaulted_late_check, defaultable_fn_check): Handle sfk_comparison.\n+\t* name-lookup.c (get_std_name_hint): Add comparison categories.\n+\t* tree.c (special_function_p): Add sfk_comparison.\n+\t* typeck.c (cp_build_binary_op): Handle SPACESHIP_EXPR.\n+\n+2019-11-05  Tim van Deurzen  <tim@kompiler.org>\n+\n+\tAdd new tree code for the spaceship operator.\n+\t* cp-tree.def: Add new tree code.\n+\t* operators.def: New binary operator.\n+\t* parser.c: Add new token and tree code.\n+\n 2019-09-15  Jason Merrill  <jason@redhat.com>\n \n \t* call.c (build_new_op_1): Don't apply any standard conversions to"}, {"sha": "0034c1cee0da8e5061813438007d86e742952bab", "filename": "gcc/cp/call.c", "status": "modified", "additions": 358, "deletions": 91, "changes": 449, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -514,6 +514,9 @@ struct z_candidate {\n \n   /* The flags active in add_candidate.  */\n   int flags;\n+\n+  bool rewritten () { return (flags & LOOKUP_REWRITTEN); }\n+  bool reversed () { return (flags & LOOKUP_REVERSED); }\n };\n \n /* Returns true iff T is a null pointer constant in the sense of\n@@ -2106,6 +2109,11 @@ add_candidate (struct z_candidate **candidates,\n   cand->flags = flags;\n   *candidates = cand;\n \n+  if (convs && cand->reversed ())\n+    /* Swap the conversions for comparison in joust; we'll swap them back\n+       before build_over_call.  */\n+    std::swap (convs[0], convs[1]);\n+\n   return cand;\n }\n \n@@ -2737,6 +2745,16 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n      where  LR  is  the  result of the usual arithmetic conversions between\n      types L and R.\n \n+     For every integral type T there exists a candidate operator function of\n+     the form\n+\n+       std::strong_ordering operator<=>(T, T);\n+\n+     For every pair of floating-point types L and R, there exists a candidate\n+     operator function of the form\n+\n+       std::partial_ordering operator<=>(L, R);\n+\n    14For every pair of types T and I, where T  is  a  cv-qualified  or  cv-\n      unqualified  complete  object  type and I is a promoted integral type,\n      there exist candidate operator functions of the form\n@@ -2758,11 +2776,15 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n \t     bool    operator>=(T, T);\n \t     bool    operator==(T, T);\n \t     bool    operator!=(T, T);\n+\t     R       operator<=>(T, T);\n+\n+     where R is the result type specified in [expr.spaceship].\n \n    17For every pointer to member type T,  there  exist  candidate  operator\n      functions of the form\n \t     bool    operator==(T, T);\n-\t     bool    operator!=(T, T);  */\n+\t     bool    operator!=(T, T);\n+\t     std::strong_equality operator<=>(T, T);  */\n \n     case MINUS_EXPR:\n       if (TYPE_PTROB_P (type1) && TYPE_PTROB_P (type2))\n@@ -2780,6 +2802,11 @@ add_builtin_candidate (struct z_candidate **candidates, enum tree_code code,\n \tbreak;\n       return;\n \n+      /* This isn't exactly what's specified above for operator<=>, but it's\n+\t close enough.  In particular, we don't care about the return type\n+\t specified above; it doesn't participate in overload resolution and it\n+\t doesn't affect the semantics of the built-in operator.  */\n+    case SPACESHIP_EXPR:\n     case EQ_EXPR:\n     case NE_EXPR:\n       if ((TYPE_PTRMEMFUNC_P (type1) && TYPE_PTRMEMFUNC_P (type2))\n@@ -3138,6 +3165,7 @@ add_builtin_candidates (struct z_candidate **candidates, enum tree_code code,\n     case LE_EXPR:\n     case GT_EXPR:\n     case GE_EXPR:\n+    case SPACESHIP_EXPR:\n       enum_p = 1;\n       /* Fall through.  */\n \n@@ -5740,6 +5768,15 @@ add_candidates (tree fns, tree first_arg, const vec<tree, va_gc> *args,\n \t  fn_args = non_static_args;\n \t}\n \n+      /* Don't bother reversing an operator with two identical parameters.  */\n+      else if (args->length () == 2 && (flags & LOOKUP_REVERSED))\n+\t{\n+\t  tree parmlist = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+\t  if (same_type_p (TREE_VALUE (parmlist),\n+\t\t\t   TREE_VALUE (TREE_CHAIN (parmlist))))\n+\t    continue;\n+\t}\n+\n       if (TREE_CODE (fn) == TEMPLATE_DECL)\n \tadd_template_candidate (candidates,\n \t\t\t\tfn,\n@@ -5800,6 +5837,178 @@ op_is_ordered (tree_code code)\n     }\n }\n \n+/* Subroutine of build_new_op_1: Add to CANDIDATES all candidates for the\n+   operator indicated by CODE/CODE2.  This function calls itself recursively to\n+   handle C++20 rewritten comparison operator candidates.  */\n+\n+static tree\n+add_operator_candidates (z_candidate **candidates,\n+\t\t\t tree_code code, tree_code code2,\n+\t\t\t vec<tree, va_gc> *arglist,\n+\t\t\t int flags, tsubst_flags_t complain)\n+{\n+  z_candidate *start_candidates = *candidates;\n+  bool ismodop = code2 != ERROR_MARK;\n+  tree fnname = ovl_op_identifier (ismodop, ismodop ? code2 : code);\n+\n+  /* LOOKUP_REWRITTEN is set when we're looking for the == or <=> operator to\n+     rewrite from, and also when we're looking for the e.g. < operator to use\n+     on the result of <=>.  In the latter case, we don't want the flag set in\n+     the candidate, we just want to suppress looking for rewrites.  */\n+  bool rewritten = (flags & LOOKUP_REWRITTEN);\n+  if (rewritten && code != EQ_EXPR && code != SPACESHIP_EXPR)\n+    flags &= ~LOOKUP_REWRITTEN;\n+\n+  bool memonly = false;\n+  switch (code)\n+    {\n+      /* =, ->, [], () must be non-static member functions.  */\n+    case MODIFY_EXPR:\n+      if (code2 != NOP_EXPR)\n+\tbreak;\n+      /* FALLTHRU */\n+    case COMPONENT_REF:\n+    case ARRAY_REF:\n+      memonly = true;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  /* Add namespace-scope operators to the list of functions to\n+     consider.  */\n+  if (!memonly)\n+    {\n+      tree fns = lookup_name_real (fnname, 0, 1, /*block_p=*/true, 0, 0);\n+      fns = lookup_arg_dependent (fnname, fns, arglist);\n+      add_candidates (fns, NULL_TREE, arglist, NULL_TREE,\n+\t\t      NULL_TREE, false, NULL_TREE, NULL_TREE,\n+\t\t      flags, candidates, complain);\n+    }\n+\n+  /* Add class-member operators to the candidate set.  */\n+  tree arg1_type = TREE_TYPE ((*arglist)[0]);\n+  unsigned nargs = arglist->length () > 1 ? 2 : 1;\n+  tree arg2_type = nargs > 1 ? TREE_TYPE ((*arglist)[1]) : NULL_TREE;\n+  if (CLASS_TYPE_P (arg1_type))\n+    {\n+      tree fns = lookup_fnfields (arg1_type, fnname, 1);\n+      if (fns == error_mark_node)\n+\treturn error_mark_node;\n+      if (fns)\n+\tadd_candidates (BASELINK_FUNCTIONS (fns),\n+\t\t\tNULL_TREE, arglist, NULL_TREE,\n+\t\t\tNULL_TREE, false,\n+\t\t\tBASELINK_BINFO (fns),\n+\t\t\tBASELINK_ACCESS_BINFO (fns),\n+\t\t\tflags, candidates, complain);\n+    }\n+  /* Per [over.match.oper]3.2, if no operand has a class type, then\n+     only non-member functions that have type T1 or reference to\n+     cv-qualified-opt T1 for the first argument, if the first argument\n+     has an enumeration type, or T2 or reference to cv-qualified-opt\n+     T2 for the second argument, if the second argument has an\n+     enumeration type.  Filter out those that don't match.  */\n+  else if (! arg2_type || ! CLASS_TYPE_P (arg2_type))\n+    {\n+      struct z_candidate **candp, **next;\n+\n+      for (candp = candidates; *candp != start_candidates; candp = next)\n+\t{\n+\t  unsigned i;\n+\t  z_candidate *cand = *candp;\n+\t  next = &cand->next;\n+\n+\t  tree parmlist = TYPE_ARG_TYPES (TREE_TYPE (cand->fn));\n+\n+\t  for (i = 0; i < nargs; ++i)\n+\t    {\n+\t      tree parmtype = TREE_VALUE (parmlist);\n+\t      tree argtype = unlowered_expr_type ((*arglist)[i]);\n+\n+\t      if (TYPE_REF_P (parmtype))\n+\t\tparmtype = TREE_TYPE (parmtype);\n+\t      if (TREE_CODE (argtype) == ENUMERAL_TYPE\n+\t\t  && (same_type_ignoring_top_level_qualifiers_p\n+\t\t      (argtype, parmtype)))\n+\t\tbreak;\n+\n+\t      parmlist = TREE_CHAIN (parmlist);\n+\t    }\n+\n+\t  /* No argument has an appropriate type, so remove this\n+\t     candidate function from the list.  */\n+\t  if (i == nargs)\n+\t    {\n+\t      *candp = cand->next;\n+\t      next = candp;\n+\t    }\n+\t}\n+    }\n+\n+  if (!rewritten)\n+    {\n+      /* The standard says to rewrite built-in candidates, too,\n+\t but there's no point.  */\n+      add_builtin_candidates (candidates, code, code2, fnname, arglist,\n+\t\t\t      flags, complain);\n+\n+      /* Maybe add C++20 rewritten comparison candidates.  */\n+      tree_code rewrite_code = ERROR_MARK;\n+      if (cxx_dialect >= cxx2a\n+\t  && nargs == 2\n+\t  && (OVERLOAD_TYPE_P (arg1_type) || OVERLOAD_TYPE_P (arg2_type)))\n+\tswitch (code)\n+\t  {\n+\t  case LT_EXPR:\n+\t  case LE_EXPR:\n+\t  case GT_EXPR:\n+\t  case GE_EXPR:\n+\t  case SPACESHIP_EXPR:\n+\t    rewrite_code = SPACESHIP_EXPR;\n+\t    break;\n+\n+\t  case NE_EXPR:\n+\t  case EQ_EXPR:\n+\t    rewrite_code = EQ_EXPR;\n+\t    break;\n+\n+\t  default:;\n+\t  }\n+\n+      if (rewrite_code)\n+\t{\n+\t  flags |= LOOKUP_REWRITTEN;\n+\t  if (rewrite_code != code)\n+\t    /* Add rewritten candidates in same order.  */\n+\t    add_operator_candidates (candidates, rewrite_code, ERROR_MARK,\n+\t\t\t\t     arglist, flags, complain);\n+\n+\t  z_candidate *save_cand = *candidates;\n+\n+\t  /* Add rewritten candidates in reverse order.  */\n+\t  flags |= LOOKUP_REVERSED;\n+\t  vec<tree,va_gc> *revlist = make_tree_vector ();\n+\t  revlist->quick_push ((*arglist)[1]);\n+\t  revlist->quick_push ((*arglist)[0]);\n+\t  add_operator_candidates (candidates, rewrite_code, ERROR_MARK,\n+\t\t\t\t   revlist, flags, complain);\n+\n+\t  /* Release the vec if we didn't add a candidate that uses it.  */\n+\t  for (z_candidate *c = *candidates; c != save_cand; c = c->next)\n+\t    if (c->args == revlist)\n+\t      {\n+\t\trevlist = NULL;\n+\t\tbreak;\n+\t      }\n+\t  release_tree_vector (revlist);\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n static tree\n build_new_op_1 (const op_location_t &loc, enum tree_code code, int flags,\n \t\ttree arg1, tree arg2, tree arg3, tree *overload,\n@@ -5809,7 +6018,7 @@ build_new_op_1 (const op_location_t &loc, enum tree_code code, int flags,\n   vec<tree, va_gc> *arglist;\n   tree result = NULL_TREE;\n   bool result_valid_p = false;\n-  enum tree_code code2 = NOP_EXPR;\n+  enum tree_code code2 = ERROR_MARK;\n   enum tree_code code_orig_arg1 = ERROR_MARK;\n   enum tree_code code_orig_arg2 = ERROR_MARK;\n   conversion *conv;\n@@ -5828,14 +6037,12 @@ build_new_op_1 (const op_location_t &loc, enum tree_code code, int flags,\n       code2 = TREE_CODE (arg3);\n       arg3 = NULL_TREE;\n     }\n-  tree fnname = ovl_op_identifier (ismodop, ismodop ? code2 : code);\n \n   tree arg1_type = unlowered_expr_type (arg1);\n   tree arg2_type = arg2 ? unlowered_expr_type (arg2) : NULL_TREE;\n \n   arg1 = prep_operand (arg1);\n \n-  bool memonly = false;\n   switch (code)\n     {\n     case NEW_EXPR:\n@@ -5868,16 +6075,6 @@ build_new_op_1 (const op_location_t &loc, enum tree_code code, int flags,\n       code_orig_arg2 = TREE_CODE (arg2_type);\n       break;\n \n-      /* =, ->, [], () must be non-static member functions.  */\n-    case MODIFY_EXPR:\n-      if (code2 != NOP_EXPR)\n-\tbreak;\n-      /* FALLTHRU */\n-    case COMPONENT_REF:\n-    case ARRAY_REF:\n-      memonly = true;\n-      break;\n-\n     default:\n       break;\n     }\n@@ -5908,82 +6105,10 @@ build_new_op_1 (const op_location_t &loc, enum tree_code code, int flags,\n   /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n   p = conversion_obstack_alloc (0);\n \n-  /* Add namespace-scope operators to the list of functions to\n-     consider.  */\n-  if (!memonly)\n-    {\n-      tree fns = lookup_name_real (fnname, 0, 1, /*block_p=*/true, 0, 0);\n-      fns = lookup_arg_dependent (fnname, fns, arglist);\n-      add_candidates (fns, NULL_TREE, arglist, NULL_TREE,\n-\t\t      NULL_TREE, false, NULL_TREE, NULL_TREE,\n-\t\t      flags, &candidates, complain);\n-    }\n-\n-  /* Add class-member operators to the candidate set.  */\n-  if (CLASS_TYPE_P (arg1_type))\n-    {\n-      tree fns;\n-\n-      fns = lookup_fnfields (arg1_type, fnname, 1);\n-      if (fns == error_mark_node)\n-\t{\n-\t  result = error_mark_node;\n-\t  goto user_defined_result_ready;\n-\t}\n-      if (fns)\n-\tadd_candidates (BASELINK_FUNCTIONS (fns),\n-\t\t\tNULL_TREE, arglist, NULL_TREE,\n-\t\t\tNULL_TREE, false,\n-\t\t\tBASELINK_BINFO (fns),\n-\t\t\tBASELINK_ACCESS_BINFO (fns),\n-\t\t\tflags, &candidates, complain);\n-    }\n-  /* Per [over.match.oper]3.2, if no operand has a class type, then\n-     only non-member functions that have type T1 or reference to\n-     cv-qualified-opt T1 for the first argument, if the first argument\n-     has an enumeration type, or T2 or reference to cv-qualified-opt\n-     T2 for the second argument, if the second argument has an\n-     enumeration type.  Filter out those that don't match.  */\n-  else if (! arg2 || ! CLASS_TYPE_P (arg2_type))\n-    {\n-      struct z_candidate **candp, **next;\n-\n-      for (candp = &candidates; *candp; candp = next)\n-\t{\n-\t  tree parmlist, parmtype;\n-\t  int i, nargs = (arg2 ? 2 : 1);\n-\n-\t  cand = *candp;\n-\t  next = &cand->next;\n-\n-\t  parmlist = TYPE_ARG_TYPES (TREE_TYPE (cand->fn));\n-\n-\t  for (i = 0; i < nargs; ++i)\n-\t    {\n-\t      parmtype = TREE_VALUE (parmlist);\n-\n-\t      if (TYPE_REF_P (parmtype))\n-\t\tparmtype = TREE_TYPE (parmtype);\n-\t      if (TREE_CODE (unlowered_expr_type ((*arglist)[i])) == ENUMERAL_TYPE\n-\t\t  && (same_type_ignoring_top_level_qualifiers_p\n-\t\t      (unlowered_expr_type ((*arglist)[i]), parmtype)))\n-\t\tbreak;\n-\n-\t      parmlist = TREE_CHAIN (parmlist);\n-\t    }\n-\n-\t  /* No argument has an appropriate type, so remove this\n-\t     candidate function from the list.  */\n-\t  if (i == nargs)\n-\t    {\n-\t      *candp = cand->next;\n-\t      next = candp;\n-\t    }\n-\t}\n-    }\n-\n-  add_builtin_candidates (&candidates, code, code2, fnname, arglist,\n-\t\t\t  flags, complain);\n+  result = add_operator_candidates (&candidates, code, code2, arglist,\n+\t\t\t\t    flags, complain);\n+  if (result == error_mark_node)\n+    goto user_defined_result_ready;\n \n   switch (code)\n     {\n@@ -6021,6 +6146,7 @@ build_new_op_1 (const op_location_t &loc, enum tree_code code, int flags,\n \t     -fpermissive.  */\n \t  else\n \t    {\n+\t      tree fnname = ovl_op_identifier (ismodop, ismodop ? code2 : code);\n \t      const char *msg = (flag_permissive) \n \t\t? G_(\"no %<%D(int)%> declared for postfix %qs,\"\n \t\t     \" trying prefix operator instead\")\n@@ -6091,7 +6217,12 @@ build_new_op_1 (const op_location_t &loc, enum tree_code code, int flags,\n \t  if (resolve_args (arglist, complain) == NULL)\n \t    result = error_mark_node;\n \t  else\n-\t    result = build_over_call (cand, LOOKUP_NORMAL, complain);\n+\t    {\n+\t      if (cand->reversed ())\n+\t\t/* We swapped these in add_candidate, swap them back now.  */\n+\t\tstd::swap (cand->convs[0], cand->convs[1]);\n+\t      result = build_over_call (cand, LOOKUP_NORMAL, complain);\n+\t    }\n \n \t  if (trivial_fn_p (cand->fn))\n \t    /* There won't be a CALL_EXPR.  */;\n@@ -6121,6 +6252,73 @@ build_new_op_1 (const op_location_t &loc, enum tree_code code, int flags,\n \t\t  break;\n \t\t}\n \t    }\n+\n+\t  /* If this was a C++20 rewritten comparison, adjust the result.  */\n+\t  if (cand->rewritten ())\n+\t    {\n+\t      /* FIXME build_min_non_dep_op_overload can't handle rewrites.  */\n+\t      if (overload)\n+\t\t*overload = NULL_TREE;\n+\t      switch (code)\n+\t\t{\n+\t\tcase EQ_EXPR:\n+\t\t  gcc_checking_assert (cand->reversed ());\n+\t\t  gcc_fallthrough ();\n+\t\tcase NE_EXPR:\n+\t\t  /* If a rewritten operator== candidate is selected by\n+\t\t     overload resolution for an operator @, its return type\n+\t\t     shall be cv bool.... */\n+\t\t  if (TREE_CODE (TREE_TYPE (result)) != BOOLEAN_TYPE)\n+\t\t    {\n+\t\t      if (complain & tf_error)\n+\t\t\t{\n+\t\t\t  auto_diagnostic_group d;\n+\t\t\t  error_at (loc, \"return type of %qD is not %qs\",\n+\t\t\t\t    cand->fn, \"bool\");\n+\t\t\t  inform (loc, \"used as rewritten candidate for \"\n+\t\t\t\t  \"comparison of %qT and %qT\",\n+\t\t\t\t  arg1_type, arg2_type);\n+\t\t\t}\n+\t\t      result = error_mark_node;\n+\t\t    }\n+\t\t  else if (code == NE_EXPR)\n+\t\t    /* !(y == x) or !(x == y)  */\n+\t\t    result = build1_loc (loc, TRUTH_NOT_EXPR,\n+\t\t\t\t\t boolean_type_node, result);\n+\t\t  break;\n+\n+\t\t  /* If a rewritten operator<=> candidate is selected by\n+\t\t     overload resolution for an operator @, x @ y is\n+\t\t     interpreted as 0 @ (y <=> x) if the selected candidate is\n+\t\t     a synthesized candidate with reversed order of parameters,\n+\t\t     or (x <=> y) @ 0 otherwise, using the selected rewritten\n+\t\t     operator<=> candidate.  */\n+\t\tcase SPACESHIP_EXPR:\n+\t\t  if (!cand->reversed ())\n+\t\t    /* We're in the build_new_op call below for an outer\n+\t\t       reversed call; we don't need to do anything more.  */\n+\t\t    break;\n+\t\t  gcc_fallthrough ();\n+\t\tcase LT_EXPR:\n+\t\tcase LE_EXPR:\n+\t\tcase GT_EXPR:\n+\t\tcase GE_EXPR:\n+\t\t  {\n+\t\t    tree lhs = result;\n+\t\t    tree rhs = integer_zero_node;\n+\t\t    if (cand->reversed ())\n+\t\t      std::swap (lhs, rhs);\n+\t\t    result = build_new_op (loc, code,\n+\t\t\t\t\t   LOOKUP_NORMAL|LOOKUP_REWRITTEN,\n+\t\t\t\t\t   lhs, rhs, NULL_TREE,\n+\t\t\t\t\t   NULL, complain);\n+\t\t  }\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n+\t    }\n \t}\n       else\n \t{\n@@ -6232,6 +6430,7 @@ build_new_op_1 (const op_location_t &loc, enum tree_code code, int flags,\n       if (complain & tf_warning && warn_tautological_compare)\n \twarn_tautological_cmp (loc, code, arg1, arg2);\n       /* Fall through.  */\n+    case SPACESHIP_EXPR:\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n     case MULT_EXPR:\n@@ -6307,6 +6506,29 @@ extract_call_expr (tree call)\n     call = TREE_OPERAND (call, 0);\n   if (TREE_CODE (call) == TARGET_EXPR)\n     call = TARGET_EXPR_INITIAL (call);\n+  if (cxx_dialect >= cxx2a)\n+    switch (TREE_CODE (call))\n+      {\n+\t/* C++20 rewritten comparison operators.  */\n+      case TRUTH_NOT_EXPR:\n+\tcall = TREE_OPERAND (call, 0);\n+\tbreak;\n+      case LT_EXPR:\n+      case LE_EXPR:\n+      case GT_EXPR:\n+      case GE_EXPR:\n+      case SPACESHIP_EXPR:\n+\t{\n+\t  tree op0 = TREE_OPERAND (call, 0);\n+\t  if (integer_zerop (op0))\n+\t    call = TREE_OPERAND (call, 1);\n+\t  else\n+\t    call = op0;\n+\t}\n+\tbreak;\n+      default:;\n+      }\n+\n   gcc_assert (TREE_CODE (call) == CALL_EXPR\n \t      || TREE_CODE (call) == AGGR_INIT_EXPR\n \t      || call == error_mark_node);\n@@ -10772,6 +10994,20 @@ joust_maybe_elide_copy (z_candidate *&cand)\n   return false;\n }\n \n+/* True if cand1 and cand2 represent the same function or function\n+   template.  */\n+\n+static bool\n+same_fn_or_template (z_candidate *cand1, z_candidate *cand2)\n+{\n+  if (cand1->fn == cand2->fn)\n+    return true;\n+  if (!cand1->template_decl || !cand2->template_decl)\n+    return false;\n+  return (most_general_template (TI_TEMPLATE (cand1->template_decl))\n+\t  == most_general_template (TI_TEMPLATE (cand2->template_decl)));\n+}\n+\n /* Compare two candidates for overloading as described in\n    [over.match.best].  Return values:\n \n@@ -10798,6 +11034,7 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn,\n   /* If we have two pseudo-candidates for conversions to the same type,\n      or two candidates for the same function, arbitrarily pick one.  */\n   if (cand1->fn == cand2->fn\n+      && cand1->reversed () == cand2->reversed ()\n       && (IS_TYPE_OR_DECL_P (cand1->fn)))\n     return 1;\n \n@@ -10917,6 +11154,21 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn,\n \n \t  if (winner && comp != winner)\n \t    {\n+\t      if (same_fn_or_template (cand1, cand2))\n+\t\t{\n+\t\t  /* Ambiguity between normal and reversed versions of the\n+\t\t     same comparison operator; prefer the normal one.\n+\t\t     https://lists.isocpp.org/core/2019/10/7438.php  */\n+\t\t  if (cand1->reversed ())\n+\t\t    winner = -1;\n+\t\t  else\n+\t\t    {\n+\t\t      gcc_checking_assert (cand2->reversed ());\n+\t\t      winner = 1;\n+\t\t    }\n+\t\t  break;\n+\t\t}\n+\n \t      winner = 0;\n \t      goto tweak;\n \t    }\n@@ -11046,6 +11298,21 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn,\n \treturn winner;\n     }\n \n+  /* F2 is a rewritten candidate (12.4.1.2) and F1 is not, or F1 and F2 are\n+     rewritten candidates, and F2 is a synthesized candidate with reversed\n+     order of parameters and F1 is not.  */\n+  if (cand1->rewritten ())\n+    {\n+      if (!cand2->rewritten ())\n+\treturn -1;\n+      if (!cand1->reversed () && cand2->reversed ())\n+\treturn 1;\n+      if (cand1->reversed () && !cand2->reversed ())\n+\treturn -1;\n+    }\n+  else if (cand2->rewritten ())\n+    return 1;\n+\n   /* F1 is generated from a deduction-guide (13.3.1.8) and F2 is not */\n   if (deduction_guide_p (cand1->fn))\n     {"}, {"sha": "89ed1c040f608e7ada985b1db3c7440530913976", "filename": "gcc/cp/class.c", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -3234,6 +3234,17 @@ add_implicitly_declared_members (tree t, tree* access_decls,\n      a virtual function from a base class.  */\n   declare_virt_assop_and_dtor (t);\n \n+  /* If the class definition does not explicitly declare an == operator\n+     function, but declares a defaulted three-way comparison operator function,\n+     an == operator function is declared implicitly.  */\n+  if (!classtype_has_op (t, EQ_EXPR))\n+    if (tree space = classtype_has_defaulted_op (t, SPACESHIP_EXPR))\n+      {\n+\ttree eq = implicitly_declare_fn (sfk_comparison, t, false, space,\n+\t\t\t\t\t NULL_TREE);\n+\tadd_method (t, eq, false);\n+      }\n+\n   while (*access_decls)\n     {\n       tree using_decl = TREE_VALUE (*access_decls);\n@@ -5386,6 +5397,44 @@ classtype_has_depr_implicit_copy (tree t)\n   return NULL_TREE;\n }\n \n+/* True iff T has a member or friend declaration of operator OP.  */\n+\n+bool\n+classtype_has_op (tree t, tree_code op)\n+{\n+  tree name = ovl_op_identifier (op);\n+  if (get_class_binding (t, name))\n+    return true;\n+  for (tree f = DECL_FRIENDLIST (TYPE_MAIN_DECL (t)); f; f = TREE_CHAIN (f))\n+    if (FRIEND_NAME (f) == name)\n+      return true;\n+  return false;\n+}\n+\n+\n+/* If T has a defaulted member or friend declaration of OP, return it.  */\n+\n+tree\n+classtype_has_defaulted_op (tree t, tree_code op)\n+{\n+  tree name = ovl_op_identifier (op);\n+  for (ovl_iterator oi (get_class_binding (t, name)); oi; ++oi)\n+    {\n+      tree fn = *oi;\n+      if (DECL_DEFAULTED_FN (fn))\n+\treturn fn;\n+    }\n+  for (tree f = DECL_FRIENDLIST (TYPE_MAIN_DECL (t)); f; f = TREE_CHAIN (f))\n+    if (FRIEND_NAME (f) == name)\n+      for (tree l = FRIEND_DECLS (f); l; l = TREE_CHAIN (l))\n+\t{\n+\t  tree fn = TREE_VALUE (l);\n+\t  if (DECL_DEFAULTED_FN (fn))\n+\t    return fn;\n+\t}\n+  return NULL_TREE;\n+}\n+\n /* Nonzero if we need to build up a constructor call when initializing an\n    object of this class, either because it has a user-declared constructor\n    or because it doesn't have a default constructor (so we need to give an"}, {"sha": "20fddc57825a8f88920507d7f569e9f418007a77", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -2480,6 +2480,12 @@ cxx_eval_binary_expression (const constexpr_ctx *ctx, tree t,\n   else if (code == POINTER_PLUS_EXPR)\n     r = cxx_fold_pointer_plus_expression (ctx, t, lhs, rhs, non_constant_p,\n \t\t\t\t\t  overflow_p);\n+  else if (code == SPACESHIP_EXPR)\n+    {\n+      r = genericize_spaceship (type, lhs, rhs);\n+      r = cxx_eval_constant_expression (ctx, r, false, non_constant_p,\n+\t\t\t\t\toverflow_p);\n+    }\n \n   if (r == NULL_TREE)\n     r = fold_binary_loc (loc, code, type, lhs, rhs);\n@@ -5226,6 +5232,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case GE_EXPR:\n     case EQ_EXPR:\n     case NE_EXPR:\n+    case SPACESHIP_EXPR:\n     case UNORDERED_EXPR:\n     case ORDERED_EXPR:\n     case UNLT_EXPR:\n@@ -7037,6 +7044,7 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n     case GE_EXPR:\n     case EQ_EXPR:\n     case NE_EXPR:\n+    case SPACESHIP_EXPR:\n       want_rval = true;\n       goto binary;\n "}, {"sha": "744707e792d9f748e9904458bdf05270c688f041", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -1144,6 +1144,17 @@ cp_fold_function (tree fndecl)\n   cp_walk_tree (&DECL_SAVED_TREE (fndecl), cp_fold_r, &pset, NULL);\n }\n \n+/* Turn SPACESHIP_EXPR EXPR into GENERIC.  */\n+\n+static tree genericize_spaceship (tree expr)\n+{\n+  iloc_sentinel s (cp_expr_location (expr));\n+  tree type = TREE_TYPE (expr);\n+  tree op0 = TREE_OPERAND (expr, 0);\n+  tree op1 = TREE_OPERAND (expr, 1);\n+  return genericize_spaceship (type, op0, op1);\n+}\n+\n /* Perform any pre-gimplification lowering of C++ front end trees to\n    GENERIC.  */\n \n@@ -1574,6 +1585,10 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n       genericize_break_stmt (stmt_p);\n       break;\n \n+    case SPACESHIP_EXPR:\n+      *stmt_p = genericize_spaceship (*stmt_p);\n+      break;\n+\n     case OMP_FOR:\n     case OMP_SIMD:\n     case OMP_DISTRIBUTE:"}, {"sha": "b9bc2c6592cb2a2a58a3c9938a399ee813494ecf", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -518,6 +518,7 @@ cp_common_init_ts (void)\n   MARK_TS_EXP (VEC_DELETE_EXPR);\n   MARK_TS_EXP (VEC_INIT_EXPR);\n   MARK_TS_EXP (VEC_NEW_EXPR);\n+  MARK_TS_EXP (SPACESHIP_EXPR);\n \n   /* Fold expressions.  */\n   MARK_TS_EXP (BINARY_LEFT_FOLD_EXPR);"}, {"sha": "4e798e3b614abdbf237ca5b47e1f9f8fc782261e", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -255,6 +255,7 @@ DEFTREECODE (IMPLICIT_CONV_EXPR, \"implicit_conv_expr\", tcc_unary, 1)\n DEFTREECODE (DOTSTAR_EXPR, \"dotstar_expr\", tcc_expression, 2)\n DEFTREECODE (TYPEID_EXPR, \"typeid_expr\", tcc_expression, 1)\n DEFTREECODE (NOEXCEPT_EXPR, \"noexcept_expr\", tcc_unary, 1)\n+DEFTREECODE (SPACESHIP_EXPR, \"spaceship_expr\", tcc_expression, 2)\n \n /* A placeholder for an expression that is not type-dependent, but\n    does occur in a template.  When an expression that is not"}, {"sha": "2b45d62ce21bf64d41f0c8104bad371097c7aeba", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -2695,7 +2695,8 @@ struct GTY(()) lang_decl_fn {\n   unsigned omp_declare_reduction_p : 1;\n   unsigned has_dependent_explicit_spec_p : 1;\n   unsigned immediate_fn_p : 1;\n-  unsigned spare : 11;\n+  unsigned maybe_deleted : 1;\n+  unsigned spare : 10;\n \n   /* 32-bits padding on 64-bit host.  */\n \n@@ -3137,6 +3138,11 @@ struct GTY(()) lang_decl {\n #define DECL_HAS_DEPENDENT_EXPLICIT_SPEC_P(NODE) \\\n   (LANG_DECL_FN_CHECK (NODE)->has_dependent_explicit_spec_p)\n \n+/* Nonzero for a defaulted FUNCTION_DECL for which we haven't decided yet if\n+   it's deleted.  */\n+#define DECL_MAYBE_DELETED(NODE) \\\n+  (LANG_DECL_FN_CHECK (NODE)->maybe_deleted)\n+\n /* True (in a FUNCTION_DECL) if NODE is a virtual function that is an\n    invalid overrider for a function from a base class.  Once we have\n    complained about an invalid overrider we avoid complaining about it\n@@ -5203,6 +5209,7 @@ enum special_function_kind {\n \t\t\t      destroyed.  */\n   sfk_conversion,\t   /* A conversion operator.  */\n   sfk_deduction_guide,\t   /* A class template deduction guide.  */\n+  sfk_comparison,\t   /* A comparison operator (e.g. ==, <, <=>).  */\n   sfk_virtual_destructor   /* Used by member synthesis fns.  */\n };\n \n@@ -5565,6 +5572,17 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, TYPENAME_FLAG };\n #define LOOKUP_ALLOW_FLEXARRAY_INIT (LOOKUP_DELEGATING_CONS << 1)\n /* Require constant initialization of a non-constant variable.  */\n #define LOOKUP_CONSTINIT (LOOKUP_ALLOW_FLEXARRAY_INIT << 1)\n+/* We're looking for either a rewritten comparison operator candidate or the\n+   operator to use on the former's result.  We distinguish between the two by\n+   knowing that comparisons other than == and <=> must be the latter, as must\n+   a <=> expression trying to rewrite to <=> without reversing.  */\n+#define LOOKUP_REWRITTEN (LOOKUP_CONSTINIT << 1)\n+/* Reverse the order of the two arguments for comparison rewriting.  First we\n+   swap the arguments in add_operator_candidates, then we swap the conversions\n+   in add_candidate (so that they correspond to the original order of the\n+   args), then we swap the conversions back in build_new_op_1 (so they\n+   correspond to the order of the args in the candidate).  */\n+#define LOOKUP_REVERSED (LOOKUP_REWRITTEN << 1)\n \n #define LOOKUP_NAMESPACES_ONLY(F)  \\\n   (((F) & LOOKUP_PREFER_NAMESPACES) && !((F) & LOOKUP_PREFER_TYPES))\n@@ -6371,6 +6389,8 @@ extern bool type_has_virtual_destructor\t\t(tree);\n extern bool classtype_has_move_assign_or_move_ctor_p (tree, bool user_declared);\n extern bool classtype_has_non_deleted_move_ctor (tree);\n extern tree classtype_has_depr_implicit_copy\t(tree);\n+extern bool classtype_has_op (tree, tree_code);\n+extern tree classtype_has_defaulted_op (tree, tree_code);\n extern bool type_build_ctor_call\t\t(tree);\n extern bool type_build_dtor_call\t\t(tree);\n extern void explain_non_literal_class\t\t(tree);\n@@ -7544,6 +7564,8 @@ extern tree composite_pointer_type\t\t(const op_location_t &,\n extern tree merge_types\t\t\t\t(tree, tree);\n extern tree strip_array_domain\t\t\t(tree);\n extern tree check_return_expr\t\t\t(tree, bool *);\n+extern tree spaceship_type\t\t\t(tree, tsubst_flags_t = tf_warning_or_error);\n+extern tree genericize_spaceship\t\t(tree, tree, tree);\n extern tree cp_build_binary_op                  (const op_location_t &,\n \t\t\t\t\t\t enum tree_code, tree, tree,\n \t\t\t\t\t\t tsubst_flags_t);"}, {"sha": "3bfcfb2c6b73fec3dc38588175507fd46b784679", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -16793,6 +16793,13 @@ finish_function (bool inline_p)\n \t}\n     }\n \n+  if (DECL_DELETED_FN (fndecl))\n+    {\n+      DECL_INITIAL (fndecl) = error_mark_node;\n+      DECL_SAVED_TREE (fndecl) = NULL_TREE;\n+      goto cleanup;\n+    }\n+\n   // If this is a concept, check that the definition is reasonable.\n   if (DECL_DECLARED_CONCEPT_P (fndecl))\n     check_function_concept (fndecl);\n@@ -16939,6 +16946,7 @@ finish_function (bool inline_p)\n   if (!processing_template_decl && !DECL_IMMEDIATE_FUNCTION_P (fndecl))\n     cp_genericize (fndecl);\n \n+ cleanup:\n   /* We're leaving the context of this function, so zap cfun.  It's still in\n      DECL_STRUCT_FUNCTION, and we'll restore it in tree_rest_of_compilation.  */\n   set_cfun (NULL);"}, {"sha": "4f0b2161db1fdca8bed6571db793e03ecc0c0d98", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -927,6 +927,10 @@ grokfield (const cp_declarator *declarator,\n \t    }\n \t  else if (init == ridpointers[(int)RID_DEFAULT])\n \t    {\n+\t      if (friendp)\n+\t\t/* ??? do_friend doesn't set this because funcdef_flag is false\n+\t\t   for in-class defaulted functions.  So set it here.  */\n+\t\tSET_DECL_FRIEND_CONTEXT (value, current_class_type);\n \t      if (defaultable_fn_check (value))\n \t\t{\n \t\t  DECL_DEFAULTED_FN (value) = 1;\n@@ -5471,6 +5475,17 @@ mark_used (tree decl, tsubst_flags_t complain)\n   if (TREE_CODE (decl) == CONST_DECL)\n     used_types_insert (DECL_CONTEXT (decl));\n \n+  if (TREE_CODE (decl) == FUNCTION_DECL\n+      && DECL_MAYBE_DELETED (decl))\n+    {\n+      /* ??? Switch other defaulted functions to use DECL_MAYBE_DELETED?  */\n+      gcc_assert (special_function_p (decl) == sfk_comparison);\n+\n+      ++function_depth;\n+      synthesize_method (decl);\n+      --function_depth;\n+    }\n+\n   if (TREE_CODE (decl) == FUNCTION_DECL\n       && !maybe_instantiate_noexcept (decl, complain))\n     return false;\n@@ -5592,7 +5607,6 @@ mark_used (tree decl, tsubst_flags_t complain)\n \n   /* Is it a synthesized method that needs to be synthesized?  */\n   if (TREE_CODE (decl) == FUNCTION_DECL\n-      && DECL_NONSTATIC_MEMBER_FUNCTION_P (decl)\n       && DECL_DEFAULTED_FN (decl)\n       /* A function defaulted outside the class is synthesized either by\n \t cp_finish_decl or instantiate_decl.  */"}, {"sha": "c06776f565a0c4830eaafaaccc347fe273995762", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -2286,6 +2286,7 @@ dump_expr (cxx_pretty_printer *pp, tree t, int flags)\n     case GE_EXPR:\n     case EQ_EXPR:\n     case NE_EXPR:\n+    case SPACESHIP_EXPR:\n     case EXACT_DIV_EXPR:\n       dump_binary_op (pp, OVL_OP_INFO (false, TREE_CODE (t))->name, t, flags);\n       break;"}, {"sha": "c9dd90fcba756446a1e61058f209a4c0a544cbe6", "filename": "gcc/cp/method.c", "status": "modified", "additions": 713, "deletions": 22, "changes": 735, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -406,6 +406,7 @@ type_has_trivial_fn (tree ctype, special_function_kind sfk)\n     case sfk_virtual_destructor:\n       return !TYPE_HAS_NONTRIVIAL_DESTRUCTOR (ctype);\n     case sfk_inheriting_constructor:\n+    case sfk_comparison:\n       return false;\n     default:\n       gcc_unreachable ();\n@@ -877,6 +878,588 @@ do_build_copy_assign (tree fndecl)\n   finish_compound_stmt (compound_stmt);\n }\n \n+/* C++20 <compare> comparison category types.  */\n+\n+enum comp_cat_tag\n+{\n+  cc_weak_equality,\n+  cc_strong_equality,\n+  cc_partial_ordering,\n+  cc_weak_ordering,\n+  cc_strong_ordering,\n+  cc_last\n+};\n+\n+/* Names of the comparison categories and their value members, to be indexed by\n+   comp_cat_tag enumerators.  genericize_spaceship below relies on the ordering\n+   of the members.  */\n+\n+struct comp_cat_info_t\n+{\n+  const char *name;\n+  const char *members[4];\n+};\n+static const comp_cat_info_t comp_cat_info[cc_last]\n+= {\n+   { \"weak_equality\", \"equivalent\", \"nonequivalent\" },\n+   { \"strong_equality\", \"equal\", \"nonequal\" },\n+   { \"partial_ordering\", \"equivalent\", \"greater\", \"less\", \"unordered\" },\n+   { \"weak_ordering\", \"equivalent\", \"greater\", \"less\" },\n+   { \"strong_ordering\", \"equal\", \"greater\", \"less\" }\n+};\n+\n+/* A cache of the category types to speed repeated lookups.  */\n+\n+static GTY((deletable)) tree comp_cat_cache[cc_last];\n+\n+/* Look up one of the result variables in the comparison category type.  */\n+\n+static tree\n+lookup_comparison_result (tree type, const char *name_str,\n+\t\t\t  tsubst_flags_t complain = tf_warning_or_error)\n+{\n+  tree name = get_identifier (name_str);\n+  tree decl = lookup_qualified_name (type, name);\n+  if (TREE_CODE (decl) != VAR_DECL)\n+    {\n+      if (complain & tf_error)\n+\t{\n+\t  auto_diagnostic_group d;\n+\t  if (decl == error_mark_node || TREE_CODE (decl) == TREE_LIST)\n+\t    qualified_name_lookup_error (type, name, decl, input_location);\n+\t  else\n+\t    error (\"%<%T::%D%> is not a static data member\", type, decl);\n+\t  inform (input_location, \"determining value of %qs\", \"operator<=>\");\n+\t}\n+      return error_mark_node;\n+    }\n+  return decl;\n+}\n+\n+/* Look up a <compare> comparison category type in std.  */\n+\n+static tree\n+lookup_comparison_category (comp_cat_tag tag,\n+\t\t\t    tsubst_flags_t complain = tf_warning_or_error)\n+{\n+  if (tree cached = comp_cat_cache[tag])\n+    return cached;\n+\n+  tree name = get_identifier (comp_cat_info[tag].name);\n+  tree decl = lookup_qualified_name (std_node, name);\n+  if (TREE_CODE (decl) != TYPE_DECL)\n+    {\n+      if (complain & tf_error)\n+\t{\n+\t  auto_diagnostic_group d;\n+\t  if (decl == error_mark_node || TREE_CODE (decl) == TREE_LIST)\n+\t    qualified_name_lookup_error (std_node, name, decl, input_location);\n+\t  else\n+\t    error (\"%<std::%D%> is not a type\", decl);\n+\t  inform (input_location, \"forming type of %qs\", \"operator<=>\");\n+\t}\n+      return error_mark_node;\n+    }\n+  /* Also make sure we can look up the value members now, since we won't\n+     really use them until genericize time.  */\n+  tree type = TREE_TYPE (decl);\n+  for (int i = 0; i < 4; ++i)\n+    {\n+      const char *p = comp_cat_info[tag].members[i];\n+      if (!p) break;\n+      if (lookup_comparison_result (type, p, complain)\n+\t  == error_mark_node)\n+\treturn error_mark_node;\n+    }\n+  return comp_cat_cache[tag] = type;\n+}\n+\n+/* Wrapper that takes the tag rather than the type.  */\n+\n+static tree\n+lookup_comparison_result (comp_cat_tag tag, const char *name_str,\n+\t\t\t  tsubst_flags_t complain = tf_warning_or_error)\n+{\n+  tree type = lookup_comparison_category (tag, complain);\n+  return lookup_comparison_result (type, name_str, complain);\n+}\n+\n+/* Wrapper that takes the index into the members array instead of the name.  */\n+\n+static tree\n+lookup_comparison_result (comp_cat_tag tag, tree type, int idx)\n+{\n+  const char *name_str = comp_cat_info[tag].members[idx];\n+  if (!name_str)\n+    return NULL_TREE;\n+  return lookup_comparison_result (type, name_str);\n+}\n+\n+/* Does TYPE correspond to TAG?  */\n+\n+static bool\n+is_cat (tree type, comp_cat_tag tag)\n+{\n+  tree name = TYPE_LINKAGE_IDENTIFIER (type);\n+  return id_equal (name, comp_cat_info[tag].name);\n+}\n+\n+/* Return the comp_cat_tag for TYPE.  */\n+\n+static comp_cat_tag\n+cat_tag_for (tree type)\n+{\n+  for (int i = 0; i < cc_last; ++i)\n+    {\n+      comp_cat_tag tag = (comp_cat_tag)i;\n+      if (is_cat (type, tag))\n+\treturn tag;\n+    }\n+  return cc_last;\n+}\n+\n+/* Return the comparison category tag of a <=> expression with non-class type\n+   OPTYPE.  */\n+\n+static comp_cat_tag\n+spaceship_comp_cat (tree optype)\n+{\n+  if (INTEGRAL_OR_ENUMERATION_TYPE_P (optype) || TYPE_PTROBV_P (optype))\n+    return cc_strong_ordering;\n+  else if (TREE_CODE (optype) == REAL_TYPE)\n+    return cc_partial_ordering;\n+  else if (TYPE_PTRFN_P (optype) || TYPE_PTRMEM_P (optype)\n+\t   || NULLPTR_TYPE_P (optype))\n+    return cc_strong_equality;\n+  else if (TREE_CODE (optype) == COMPLEX_TYPE)\n+    {\n+      tree intype = optype;\n+      while (TREE_CODE (intype) == COMPLEX_TYPE)\n+\tintype = TREE_TYPE (intype);\n+      if (TREE_CODE (intype) == REAL_TYPE)\n+\treturn cc_weak_equality;\n+      else\n+\treturn cc_strong_equality;\n+    }\n+\n+  /* FIXME should vector <=> produce a vector of one of the above?  */\n+  gcc_unreachable ();\n+}\n+\n+/* Return the comparison category type of a <=> expression with non-class type\n+   OPTYPE.  */\n+\n+tree\n+spaceship_type (tree optype, tsubst_flags_t complain)\n+{\n+  comp_cat_tag tag = spaceship_comp_cat (optype);\n+  return lookup_comparison_category (tag, complain);\n+}\n+\n+/* Turn <=> with type TYPE and operands OP0 and OP1 into GENERIC.  */\n+\n+tree\n+genericize_spaceship (tree type, tree op0, tree op1)\n+{\n+  /* ??? maybe optimize based on knowledge of representation? */\n+  comp_cat_tag tag = cat_tag_for (type);\n+  gcc_checking_assert (tag < cc_last);\n+\n+  tree eq = lookup_comparison_result (tag, type, 0);\n+  tree negt = lookup_comparison_result (tag, type, 1);\n+\n+  if (tag == cc_strong_equality || tag == cc_weak_equality)\n+    {\n+      tree comp = fold_build2 (EQ_EXPR, boolean_type_node, op0, op1);\n+      return fold_build3 (COND_EXPR, type, comp, eq, negt);\n+    }\n+\n+  tree r;\n+  op0 = save_expr (op0);\n+  op1 = save_expr (op1);\n+\n+  if (tag == cc_partial_ordering)\n+    {\n+      /* op0 == op1 ? equivalent : op0 < op1 ? less :\n+\t op0 > op1 ? greater : unordered */\n+      tree uo = lookup_comparison_result (tag, type, 3);\n+      tree comp = fold_build2 (GT_EXPR, boolean_type_node, op0, op1);\n+      r = fold_build3 (COND_EXPR, type, comp, negt, uo);\n+    }\n+  else\n+    /* op0 == op1 ? equal : op0 < op1 ? less : greater */\n+    r = negt;\n+\n+  tree lt = lookup_comparison_result (tag, type, 2);\n+  tree comp = fold_build2 (LT_EXPR, boolean_type_node, op0, op1);\n+  r = fold_build3 (COND_EXPR, type, comp, lt, r);\n+\n+  comp = fold_build2 (EQ_EXPR, boolean_type_node, op0, op1);\n+  r = fold_build3 (COND_EXPR, type, comp, eq, r);\n+\n+  return r;\n+}\n+\n+/* Check that the signature of a defaulted comparison operator is\n+   well-formed.  */\n+\n+static bool\n+early_check_defaulted_comparison (tree fn)\n+{\n+  location_t loc = DECL_SOURCE_LOCATION (fn);\n+  tree ctx;\n+  if (DECL_CLASS_SCOPE_P (fn))\n+    ctx = DECL_CONTEXT (fn);\n+  else\n+    ctx = DECL_FRIEND_CONTEXT (fn);\n+  bool ok = true;\n+\n+  if (!DECL_OVERLOADED_OPERATOR_IS (fn, SPACESHIP_EXPR)\n+      && !same_type_p (TREE_TYPE (TREE_TYPE (fn)), boolean_type_node))\n+    {\n+      error_at (loc, \"defaulted %qD must return %<bool%>\", fn);\n+      ok = false;\n+    }\n+\n+  int i = DECL_NONSTATIC_MEMBER_FUNCTION_P (fn);\n+  if (i && type_memfn_quals (TREE_TYPE (fn)) != TYPE_QUAL_CONST)\n+    {\n+      error_at (loc, \"defaulted %qD must be %<const%>\", fn);\n+      ok = false;\n+    }\n+  tree parmnode = FUNCTION_FIRST_USER_PARMTYPE (fn);\n+  for (; parmnode != void_list_node; parmnode = TREE_CHAIN (parmnode))\n+    {\n+      ++i;\n+      tree parmtype = TREE_VALUE (parmnode);\n+      diagnostic_t kind = DK_UNSPECIFIED;\n+      int opt = 0;\n+      if (same_type_p (parmtype, ctx))\n+\t/* The draft specifies const reference, but let's also allow by-value\n+\t   unless -Wpedantic, hopefully it will be added soon. */\n+\tkind = DK_PEDWARN,\n+\t  opt = OPT_Wpedantic;\n+      else if (TREE_CODE (parmtype) != REFERENCE_TYPE\n+\t       || TYPE_QUALS (TREE_TYPE (parmtype)) != TYPE_QUAL_CONST\n+\t       || !(same_type_ignoring_top_level_qualifiers_p\n+\t\t    (TREE_TYPE (parmtype), ctx)))\n+\tkind = DK_ERROR;\n+      if (kind)\n+\temit_diagnostic (kind, loc, opt, \"defaulted %qD must have \"\n+\t\t\t \"parameter type %<const %T&%>\", fn, ctx);\n+      if (kind == DK_ERROR)\n+\tok = false;\n+    }\n+\n+  /* We still need to deduce deleted/constexpr/noexcept and maybe return. */\n+  DECL_MAYBE_DELETED (fn) = true;\n+\n+  return ok;\n+}\n+\n+/* Subroutine of build_comparison_op.  Given the vec of memberwise\n+   comparisons COMPS, calculate the overall comparison category for\n+   operator<=>.  */\n+\n+static tree\n+common_comparison_type (vec<tree> &comps)\n+{\n+  tree seen[cc_last] = {};\n+\n+  for (unsigned i = 0; i < comps.length(); ++i)\n+    {\n+      tree comp = comps[i];\n+      tree ctype = TREE_TYPE (comp);\n+      comp_cat_tag tag = cat_tag_for (ctype);\n+      if (tag < cc_last)\n+\tseen[tag] = ctype;\n+      else\n+\t/* If any Ti is not a comparison category type, U is void.  */\n+\treturn void_type_node;\n+    }\n+\n+  /* Otherwise, if at least one T i is std::weak_equality, or at least one T i\n+     is std::strong_equality and at least one T j is std::partial_ordering or\n+     std::weak_ordering, U is std::weak_equality.  */\n+  if (tree t = seen[cc_weak_equality]) return t;\n+  if (seen[cc_strong_equality]\n+      && (seen[cc_partial_ordering] || seen[cc_weak_ordering]))\n+    return lookup_comparison_category (cc_weak_equality);\n+\n+  /* Otherwise, if at least one T i is std::strong_equality, U is\n+     std::strong_equality.  */\n+  if (tree t = seen[cc_strong_equality]) return t;\n+\n+  /* Otherwise, if at least one T i is std::partial_ordering, U is\n+     std::partial_ordering.  */\n+  if (tree t = seen[cc_partial_ordering]) return t;\n+\n+  /* Otherwise, if at least one T i is std::weak_ordering, U is\n+     std::weak_ordering.  */\n+  if (tree t = seen[cc_weak_ordering]) return t;\n+\n+  /* Otherwise, U is std::strong_ordering.  */\n+  if (tree t = seen[cc_strong_ordering]) return t;\n+  return lookup_comparison_category (cc_strong_ordering);\n+}\n+\n+/* Data structure for build_comparison_op.  */\n+\n+struct comp_info\n+{\n+  tree fndecl;\n+  location_t loc;\n+  bool defining;\n+  bool first_time;\n+  bool constexp;\n+  bool was_constexp;\n+  bool noex;\n+\n+  comp_info (tree fndecl, tsubst_flags_t &complain)\n+    : fndecl (fndecl)\n+  {\n+    loc = DECL_SOURCE_LOCATION (fndecl);\n+\n+    /* We only have tf_error set when we're called from\n+       explain_invalid_constexpr_fn or maybe_explain_implicit_delete.  */\n+    defining = !(complain & tf_error);\n+\n+    first_time = DECL_MAYBE_DELETED (fndecl);\n+    DECL_MAYBE_DELETED (fndecl) = false;\n+\n+    /* Do we want to try to set constexpr?  */\n+    was_constexp = DECL_DECLARED_CONSTEXPR_P (fndecl);\n+    constexp = first_time;\n+    if (constexp)\n+      /* Set this for var_in_constexpr_fn.  */\n+      DECL_DECLARED_CONSTEXPR_P (fndecl) = true;\n+\n+    /* Do we want to try to set noexcept?  */\n+    noex = first_time;\n+    if (noex)\n+      {\n+\ttree raises = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fndecl));\n+\tif (raises && !UNEVALUATED_NOEXCEPT_SPEC_P (raises))\n+\t  /* There was an explicit exception-specification.  */\n+\t  noex = false;\n+      }\n+  }\n+\n+  /* EXPR is an expression built as part of the function body.\n+     Adjust the properties appropriately.  */\n+  void check (tree expr)\n+  {\n+    if (expr == error_mark_node)\n+      DECL_DELETED_FN (fndecl) = true;\n+    if ((constexp || was_constexp)\n+\t&& !potential_rvalue_constant_expression (expr))\n+      {\n+\tif (was_constexp)\n+\t  require_potential_rvalue_constant_expression (expr);\n+\telse\n+\t  constexp = false;\n+      }\n+    if (noex && !expr_noexcept_p (expr, tf_none))\n+      noex = false;\n+  }\n+};\n+\n+/* Build up the definition of a defaulted comparison operator.  Unlike other\n+   defaulted functions that use synthesized_method_walk to determine whether\n+   the function is e.g. deleted, for comparisons we use the same code.  We try\n+   to use synthesize_method at the earliest opportunity and bail out if the\n+   function ends up being deleted.  */\n+\n+static void\n+build_comparison_op (tree fndecl, tsubst_flags_t complain)\n+{\n+  comp_info info (fndecl, complain);\n+\n+  if (!info.defining && !(complain & tf_error) && !DECL_MAYBE_DELETED (fndecl))\n+    return;\n+\n+  int flags = LOOKUP_NORMAL | LOOKUP_NONVIRTUAL | LOOKUP_DEFAULTED;\n+  const ovl_op_info_t *op = IDENTIFIER_OVL_OP_INFO (DECL_NAME (fndecl));\n+  tree_code code = op->tree_code;\n+\n+  tree lhs = DECL_ARGUMENTS (fndecl);\n+  tree rhs = DECL_CHAIN (lhs);\n+  if (is_this_parameter (lhs))\n+    lhs = cp_build_fold_indirect_ref (lhs);\n+  else\n+    lhs = convert_from_reference (lhs);\n+  rhs = convert_from_reference (rhs);\n+  tree ctype = TYPE_MAIN_VARIANT (TREE_TYPE (lhs));\n+\n+  iloc_sentinel ils (info.loc);\n+\n+  /* A defaulted comparison operator function for class C is defined as\n+     deleted if ... C is a union-like class.  */\n+  if (TREE_CODE (ctype) == UNION_TYPE)\n+    {\n+      if (complain & tf_error)\n+\tinform (info.loc, \"cannot default compare union %qT\", ctype);\n+      DECL_DELETED_FN (fndecl) = true;\n+    }\n+\n+  tree compound_stmt = NULL_TREE;\n+  if (info.defining)\n+    compound_stmt = begin_compound_stmt (0);\n+  else\n+    ++cp_unevaluated_operand;\n+\n+  tree rettype = TREE_TYPE (TREE_TYPE (fndecl));\n+  if (code != SPACESHIP_EXPR && is_auto (rettype))\n+    {\n+      rettype = boolean_type_node;\n+      apply_deduced_return_type (fndecl, rettype);\n+    }\n+\n+  if (code == EQ_EXPR || code == SPACESHIP_EXPR)\n+    {\n+      auto_vec<tree> comps;\n+\n+      /* Compare each of the subobjects.  Note that we get bases from\n+\t next_initializable_field because we're past C++17.  */\n+      for (tree field = next_initializable_field (TYPE_FIELDS (ctype));\n+\t   field;\n+\t   field = next_initializable_field (DECL_CHAIN (field)))\n+\t{\n+\t  tree expr_type = TREE_TYPE (field);\n+\n+\t  /* A defaulted comparison operator function for class C is defined as\n+\t     deleted if any non-static data member of C is of reference type or\n+\t     C is a union-like class.  */\n+\t  if (TREE_CODE (expr_type) == REFERENCE_TYPE)\n+\t    {\n+\t      if (complain & tf_error)\n+\t\tinform (DECL_SOURCE_LOCATION (field), \"cannot default compare \"\n+\t\t\t\"reference member %qD\", field);\n+\t      DECL_DELETED_FN (fndecl) = true;\n+\t      continue;\n+\t    }\n+\t  else if (ANON_UNION_TYPE_P (expr_type))\n+\t    {\n+\t      if (complain & tf_error)\n+\t\tinform (DECL_SOURCE_LOCATION (field), \"cannot default compare \"\n+\t\t\t\"anonymous union member\");\n+\t      DECL_DELETED_FN (fndecl) = true;\n+\t      continue;\n+\t    }\n+\n+\t  tree lhs_mem = build3 (COMPONENT_REF, expr_type, lhs, field,\n+\t\t\t\t NULL_TREE);\n+\t  tree rhs_mem = build3 (COMPONENT_REF, expr_type, rhs, field,\n+\t\t\t\t NULL_TREE);\n+\t  tree comp = build_new_op (info.loc, code, flags, lhs_mem, rhs_mem,\n+\t\t\t\t    NULL_TREE, NULL, complain);\n+\t  comps.safe_push (comp);\n+\t}\n+      if (code == SPACESHIP_EXPR && is_auto (rettype))\n+\t{\n+\t  rettype = common_comparison_type (comps);\n+\t  apply_deduced_return_type (fndecl, rettype);\n+\t}\n+      for (unsigned i = 0; i < comps.length(); ++i)\n+\t{\n+\t  tree comp = comps[i];\n+\t  tree eq, retval = NULL_TREE, if_ = NULL_TREE;\n+\t  if (info.defining)\n+\t    if_ = begin_if_stmt ();\n+\t  /* Spaceship is specified to use !=, but for the comparison category\n+\t     types, != is equivalent to !(==), so let's use == directly.  */\n+\t  if (code == EQ_EXPR)\n+\t    {\n+\t      /* if (x==y); else return false; */\n+\t      eq = comp;\n+\t      retval = boolean_false_node;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* if (auto v = x<=>y, v == 0); else return v; */\n+\t      if (TREE_CODE (comp) == SPACESHIP_EXPR)\n+\t\tTREE_TYPE (comp) = rettype;\n+\t      else\n+\t\tcomp = build_static_cast (rettype, comp, complain);\n+\t      info.check (comp);\n+\t      if (info.defining)\n+\t\t{\n+\t\t  tree var = create_temporary_var (rettype);\n+\t\t  pushdecl (var);\n+\t\t  cp_finish_decl (var, comp, false, NULL_TREE, flags);\n+\t\t  comp = retval = var;\n+\t\t}\n+\t      eq = build_new_op (info.loc, EQ_EXPR, flags, comp,\n+\t\t\t\t integer_zero_node, NULL_TREE, NULL,\n+\t\t\t\t complain);\n+\t    }\n+\t  tree ceq = contextual_conv_bool (eq, complain);\n+\t  info.check (ceq);\n+\t  if (info.defining)\n+\t    {\n+\t      finish_if_stmt_cond (ceq, if_);\n+\t      finish_then_clause (if_);\n+\t      begin_else_clause (if_);\n+\t      finish_return_stmt (retval);\n+\t      finish_else_clause (if_);\n+\t      finish_if_stmt (if_);\n+\t    }\n+\t}\n+      if (info.defining)\n+\t{\n+\t  tree val;\n+\t  if (code == EQ_EXPR)\n+\t    val = boolean_true_node;\n+\t  else\n+\t    {\n+\t      tree seql = lookup_comparison_result (cc_strong_ordering,\n+\t\t\t\t\t\t    \"equal\", complain);\n+\t      val = build_static_cast (rettype, seql, complain);\n+\t    }\n+\t  finish_return_stmt (val);\n+\t}\n+    }\n+  else if (code == NE_EXPR)\n+    {\n+      tree comp = build_new_op (info.loc, EQ_EXPR, flags, lhs, rhs,\n+\t\t\t\tNULL_TREE, NULL, complain);\n+      comp = contextual_conv_bool (comp, complain);\n+      info.check (comp);\n+      if (info.defining)\n+\t{\n+\t  tree neg = build1 (TRUTH_NOT_EXPR, boolean_type_node, comp);\n+\t  finish_return_stmt (neg);\n+\t}\n+    }\n+  else\n+    {\n+      tree comp = build_new_op (info.loc, SPACESHIP_EXPR, flags, lhs, rhs,\n+\t\t\t\tNULL_TREE, NULL, complain);\n+      tree comp2 = build_new_op (info.loc, code, flags, comp, integer_zero_node,\n+\t\t\t\t NULL_TREE, NULL, complain);\n+      info.check (comp2);\n+      if (info.defining)\n+\tfinish_return_stmt (comp2);\n+    }\n+\n+  if (info.defining)\n+    finish_compound_stmt (compound_stmt);\n+  else\n+    --cp_unevaluated_operand;\n+\n+  if (info.first_time)\n+    {\n+      DECL_DECLARED_CONSTEXPR_P (fndecl) = info.constexp || info.was_constexp;\n+      tree raises = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fndecl));\n+      if (!raises || UNEVALUATED_NOEXCEPT_SPEC_P (raises))\n+\t{\n+\t  raises = info.noex ? noexcept_true_spec : noexcept_false_spec;\n+\t  TREE_TYPE (fndecl) = build_exception_variant (TREE_TYPE (fndecl),\n+\t\t\t\t\t\t\traises);\n+\t}\n+    }\n+}\n+\n /* Synthesize FNDECL, a non-static member function.   */\n \n void\n@@ -889,6 +1472,7 @@ synthesize_method (tree fndecl)\n   location_t save_input_location = input_location;\n   int error_count = errorcount;\n   int warning_count = warningcount + werrorcount;\n+  special_function_kind sfk = special_function_p (fndecl);\n \n   /* Reset the source location, we might have been previously\n      deferred, and thus have saved where we were first needed.  */\n@@ -930,6 +1514,12 @@ synthesize_method (tree fndecl)\n       else\n \tfinish_mem_initializers (NULL_TREE);\n     }\n+  else if (sfk == sfk_comparison)\n+    {\n+      /* Pass tf_none so the function is just deleted if there's a problem.  */\n+      build_comparison_op (fndecl, tf_none);\n+      need_body = false;\n+    }\n \n   /* If we haven't yet generated the body of the function, just\n      generate an empty compound statement.  */\n@@ -941,7 +1531,10 @@ synthesize_method (tree fndecl)\n     }\n \n   finish_function_body (stmt);\n-  expand_or_defer_fn (finish_function (/*inline_p=*/false));\n+  finish_function (/*inline_p=*/false);\n+\n+  if (!DECL_DELETED_FN (fndecl))\n+    expand_or_defer_fn (fndecl);\n \n   input_location = save_input_location;\n \n@@ -1753,6 +2346,13 @@ get_defaulted_eh_spec (tree decl, tsubst_flags_t complain)\n   if (DECL_CLONED_FUNCTION_P (decl))\n     decl = DECL_CLONED_FUNCTION (decl);\n   special_function_kind sfk = special_function_p (decl);\n+  if (sfk == sfk_comparison)\n+    {\n+      /* We're in synthesize_method. Start with NULL_TREE, build_comparison_op\n+\t will adjust as needed.  */\n+      gcc_assert (decl == current_function_decl);\n+      return NULL_TREE;\n+    }\n   tree ctype = DECL_CONTEXT (decl);\n   tree parms = FUNCTION_FIRST_USER_PARMTYPE (decl);\n   tree parm_type = TREE_VALUE (parms);\n@@ -1836,7 +2436,14 @@ maybe_explain_implicit_delete (tree decl)\n \t      informed = true;\n \t    }\n \t}\n-      if (!informed)\n+      if (!informed && sfk == sfk_comparison)\n+\t{\n+\t  inform (DECL_SOURCE_LOCATION (decl),\n+\t\t  \"%q#D is implicitly deleted because the default \"\n+\t\t  \"definition would be ill-formed:\", decl);\n+\t  build_comparison_op (decl, tf_warning_or_error);\n+\t}\n+      else if (!informed)\n \t{\n \t  tree parms = FUNCTION_FIRST_USER_PARMTYPE (decl);\n \t  bool const_p = false;\n@@ -1891,10 +2498,18 @@ explain_implicit_non_constexpr (tree decl)\n   bool const_p = CP_TYPE_CONST_P (non_reference (TREE_VALUE (parms)));\n   tree inh = DECL_INHERITED_CTOR (decl);\n   bool dummy;\n-  synthesized_method_walk (DECL_CLASS_CONTEXT (decl),\n-\t\t\t   special_function_p (decl), const_p,\n-\t\t\t   NULL, NULL, NULL, &dummy, true,\n-\t\t\t   &inh, parms);\n+  special_function_kind sfk = special_function_p (decl);\n+  if (sfk == sfk_comparison)\n+    {\n+      DECL_DECLARED_CONSTEXPR_P (decl) = true;\n+      build_comparison_op (decl, tf_warning_or_error);\n+      DECL_DECLARED_CONSTEXPR_P (decl) = false;\n+    }\n+  else\n+    synthesized_method_walk (DECL_CLASS_CONTEXT (decl),\n+\t\t\t     sfk, const_p,\n+\t\t\t     NULL, NULL, NULL, &dummy, true,\n+\t\t\t     &inh, parms);\n }\n \n /* DECL is an instantiation of an inheriting constructor template.  Deduce\n@@ -1933,12 +2548,12 @@ deduce_inheriting_ctor (tree decl)\n /* Implicitly declare the special function indicated by KIND, as a\n    member of TYPE.  For copy constructors and assignment operators,\n    CONST_P indicates whether these functions should take a const\n-   reference argument or a non-const reference.  Returns the\n-   FUNCTION_DECL for the implicitly declared function.  */\n+   reference argument or a non-const reference.\n+   Returns the FUNCTION_DECL for the implicitly declared function.  */\n \n tree\n implicitly_declare_fn (special_function_kind kind, tree type,\n-\t\t       bool const_p, tree inherited_ctor,\n+\t\t       bool const_p, tree pattern_fn,\n \t\t       tree inherited_parms)\n {\n   tree fn;\n@@ -1950,8 +2565,11 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n   tree this_parm;\n   tree name;\n   HOST_WIDE_INT saved_processing_template_decl;\n-  bool deleted_p;\n-  bool constexpr_p;\n+  bool deleted_p = false;\n+  bool constexpr_p = false;\n+  bool friend_p = (kind == sfk_comparison && DECL_FRIEND_P (pattern_fn));\n+  tree inherited_ctor = (kind == sfk_inheriting_constructor\n+\t\t\t ? pattern_fn : NULL_TREE);\n \n   /* Because we create declarations for implicitly declared functions\n      lazily, we may be creating the declaration for a member of TYPE\n@@ -1978,6 +2596,7 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n   else\n     return_type = void_type_node;\n \n+  int this_quals = TYPE_UNQUALIFIED;\n   switch (kind)\n     {\n     case sfk_destructor:\n@@ -2021,6 +2640,36 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n \t}\n       break;\n     }\n+\n+    case sfk_comparison:\n+      /* If the class definition does not explicitly declare an == operator\n+\t function, but declares a defaulted three-way comparison operator\n+\t function, an == operator function is declared implicitly with the same\n+\t access as the three-way comparison operator function.\n+\n+\t The implicitly-declared == operator for a class X is an inline member\n+\t and is defined as defaulted in the definition of X.\n+\n+\t If the three-way comparison operator function is declared as a\n+\t non-static const member, the implicitly-declared == operator function\n+\t is a member of the form\n+\n+\t   bool X::operator==(const X&) const;\n+\n+\t Otherwise, the implicitly-declared == operator function is of the form\n+\n+\t   friend bool operator==(const X&, const X&); */\n+      /* No other comparison operator is implicitly declared.  */\n+      name = ovl_op_identifier (false, EQ_EXPR);\n+      return_type = boolean_type_node;\n+      rhs_parm_type = cp_build_qualified_type (type, TYPE_QUAL_CONST);\n+      rhs_parm_type = cp_build_reference_type (rhs_parm_type, false);\n+      parameter_types = tree_cons (NULL_TREE, rhs_parm_type, parameter_types);\n+      if (friend_p)\n+\tparameter_types = tree_cons (NULL_TREE, rhs_parm_type, parameter_types);\n+      this_quals = TYPE_QUAL_CONST;\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -2038,9 +2687,10 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n   else if (cxx_dialect >= cxx11)\n     {\n       raises = noexcept_deferred_spec;\n-      synthesized_method_walk (type, kind, const_p, NULL, &trivial_p,\n-\t\t\t       &deleted_p, &constexpr_p, false,\n-\t\t\t       &inherited_ctor, inherited_parms);\n+      if (kind != sfk_comparison)\n+\tsynthesized_method_walk (type, kind, const_p, NULL, &trivial_p,\n+\t\t\t\t &deleted_p, &constexpr_p, false,\n+\t\t\t\t &inherited_ctor, inherited_parms);\n     }\n   else\n     synthesized_method_walk (type, kind, const_p, &raises, &trivial_p,\n@@ -2062,7 +2712,9 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n     type_set_nontrivial_flag (type, kind);\n \n   /* Create the function.  */\n-  fn_type = build_method_type_directly (type, return_type, parameter_types);\n+  tree this_type = cp_build_qualified_type (type, this_quals);\n+  fn_type = build_method_type_directly (this_type, return_type,\n+\t\t\t\t\tparameter_types);\n   if (raises)\n     {\n       if (raises != error_mark_node)\n@@ -2073,16 +2725,25 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n \tgcc_assert (seen_error ());\n     }\n   fn = build_lang_decl (FUNCTION_DECL, name, fn_type);\n-  if (kind != sfk_inheriting_constructor)\n+  if (kind == sfk_comparison)\n+    {\n+      DECL_SOURCE_LOCATION (fn) = DECL_SOURCE_LOCATION (pattern_fn);\n+      DECL_MAYBE_DELETED (fn) = true;\n+    }\n+  else if (kind != sfk_inheriting_constructor)\n     DECL_SOURCE_LOCATION (fn) = DECL_SOURCE_LOCATION (TYPE_NAME (type));\n \n-  if (!IDENTIFIER_CDTOR_P (name))\n-    /* Assignment operator.  */\n-    DECL_OVERLOADED_OPERATOR_CODE_RAW (fn) = OVL_OP_NOP_EXPR;\n+  if (IDENTIFIER_OVL_OP_P (name))\n+    {\n+      const ovl_op_info_t *op = IDENTIFIER_OVL_OP_INFO (name);\n+      DECL_OVERLOADED_OPERATOR_CODE_RAW (fn) = op->ovl_op_code;\n+    }\n   else if (IDENTIFIER_CTOR_P (name))\n     DECL_CXX_CONSTRUCTOR_P (fn) = true;\n-  else\n+  else if (IDENTIFIER_DTOR_P (name))\n     DECL_CXX_DESTRUCTOR_P (fn) = true;\n+  else\n+    gcc_unreachable ();\n \n   SET_DECL_ALIGN (fn, MINIMUM_METHOD_BOUNDARY);\n \n@@ -2097,6 +2758,13 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n       retrofit_lang_decl (decl);\n       DECL_PARM_INDEX (decl) = DECL_PARM_LEVEL (decl) = 1;\n       DECL_ARGUMENTS (fn) = decl;\n+      if (friend_p)\n+\t{\n+\t  /* The second parm of friend op==.  */\n+\t  tree decl2 = copy_decl (decl);\n+\t  DECL_CHAIN (decl) = decl2;\n+\t  DECL_PARM_INDEX (decl2) = 2;\n+\t}\n     }\n   else if (kind == sfk_inheriting_constructor)\n     {\n@@ -2122,7 +2790,7 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n       constexpr_p = DECL_DECLARED_CONSTEXPR_P (inherited_ctor);\n     }\n   /* Add the \"this\" parameter.  */\n-  this_parm = build_this_parm (fn, fn_type, TYPE_UNQUALIFIED);\n+  this_parm = build_this_parm (fn, fn_type, this_quals);\n   DECL_CHAIN (this_parm) = DECL_ARGUMENTS (fn);\n   DECL_ARGUMENTS (fn) = this_parm;\n \n@@ -2141,6 +2809,12 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n   set_linkage_according_to_type (type, fn);\n   if (TREE_PUBLIC (fn))\n     DECL_COMDAT (fn) = 1;\n+  if (kind == sfk_comparison && !friend_p)\n+    {\n+      /* The implicit op== has the same access as the op<=>.  */\n+      TREE_PRIVATE (fn) = TREE_PRIVATE (pattern_fn);\n+      TREE_PROTECTED (fn) = TREE_PROTECTED (pattern_fn);\n+    }\n   rest_of_decl_compilation (fn, namespace_bindings_p (), at_eof);\n   gcc_assert (!TREE_USED (fn));\n \n@@ -2182,6 +2856,16 @@ defaulted_late_check (tree fn)\n   /* Complain about invalid signature for defaulted fn.  */\n   tree ctx = DECL_CONTEXT (fn);\n   special_function_kind kind = special_function_p (fn);\n+\n+  if (kind == sfk_comparison)\n+    {\n+      /* If the function was declared constexpr, check that the definition\n+\t qualifies.  Otherwise we can define the function lazily.  */\n+      if (DECL_DECLARED_CONSTEXPR_P (fn))\n+\tsynthesize_method (fn);\n+      return;\n+    }\n+\n   bool fn_const_p = (copy_fn_p (fn) == 2);\n   tree implicit_fn = implicitly_declare_fn (kind, ctx, fn_const_p,\n \t\t\t\t\t    NULL, NULL);\n@@ -2272,6 +2956,13 @@ defaultable_fn_check (tree fn)\n       else if (move_fn_p (fn))\n \tkind = sfk_move_assignment;\n     }\n+  else if (DECL_OVERLOADED_OPERATOR_CODE_RAW (fn) >= OVL_OP_EQ_EXPR\n+\t   && DECL_OVERLOADED_OPERATOR_CODE_RAW (fn) <= OVL_OP_SPACESHIP_EXPR)\n+    {\n+      kind = sfk_comparison;\n+      if (!early_check_defaulted_comparison (fn))\n+\treturn false;\n+    }\n \n   if (kind == sfk_none)\n     {\n@@ -2293,7 +2984,7 @@ defaultable_fn_check (tree fn)\n \tif (DECL_NAME (p))\n \t  TREE_NO_WARNING (p) = 1;\n \n-      if (TYPE_BEING_DEFINED (DECL_CONTEXT (fn)))\n+      if (current_class_type && TYPE_BEING_DEFINED (current_class_type))\n \t/* Defer checking.  */;\n       else if (!processing_template_decl)\n \tdefaulted_late_check (fn);"}, {"sha": "cd0d9551aa34fcbb12415e5eb374f9f5eb5a9459", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -5592,6 +5592,12 @@ get_std_name_hint (const char *name)\n     {\"atomic_ref\", \"<atomic>\", cxx2a},\n     /* <bitset>.  */\n     {\"bitset\", \"<bitset>\", cxx11},\n+    /* <compare> */\n+    {\"weak_equality\", \"<compare>\", cxx2a},\n+    {\"strong_equality\", \"<compare>\", cxx2a},\n+    {\"partial_ordering\", \"<compare>\", cxx2a},\n+    {\"weak_ordering\", \"<compare>\", cxx2a},\n+    {\"strong_ordering\", \"<compare>\", cxx2a},\n     /* <complex>.  */\n     {\"complex\", \"<complex>\", cxx98},\n     {\"complex_literals\", \"<complex>\", cxx14},"}, {"sha": "ee0a4c17592baff0f2e9585babdfa99b98ff229f", "filename": "gcc/cp/operators.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Foperators.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Foperators.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foperators.def?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -104,12 +104,16 @@ DEF_OPERATOR (\"|\", BIT_IOR_EXPR, \"or\", OVL_OP_FLAG_BINARY)\n DEF_OPERATOR (\"^\", BIT_XOR_EXPR, \"eo\", OVL_OP_FLAG_BINARY)\n DEF_OPERATOR (\"<<\", LSHIFT_EXPR, \"ls\", OVL_OP_FLAG_BINARY)\n DEF_OPERATOR (\">>\", RSHIFT_EXPR, \"rs\", OVL_OP_FLAG_BINARY)\n+\n+/* defaultable_fn_check relies on the ordering of the comparison operators.  */\n DEF_OPERATOR (\"==\", EQ_EXPR, \"eq\", OVL_OP_FLAG_BINARY)\n DEF_OPERATOR (\"!=\", NE_EXPR, \"ne\", OVL_OP_FLAG_BINARY)\n DEF_OPERATOR (\"<\", LT_EXPR, \"lt\", OVL_OP_FLAG_BINARY)\n DEF_OPERATOR (\">\", GT_EXPR, \"gt\", OVL_OP_FLAG_BINARY)\n DEF_OPERATOR (\"<=\", LE_EXPR, \"le\", OVL_OP_FLAG_BINARY)\n DEF_OPERATOR (\">=\", GE_EXPR, \"ge\", OVL_OP_FLAG_BINARY)\n+DEF_OPERATOR (\"<=>\", SPACESHIP_EXPR, \"ss\", OVL_OP_FLAG_BINARY)\n+\n DEF_OPERATOR (\"&&\", TRUTH_ANDIF_EXPR, \"aa\", OVL_OP_FLAG_BINARY)\n DEF_OPERATOR (\"||\", TRUTH_ORIF_EXPR, \"oo\", OVL_OP_FLAG_BINARY)\n DEF_OPERATOR (\",\", COMPOUND_EXPR, \"cm\", OVL_OP_FLAG_BINARY)"}, {"sha": "cbbf946d32c12cd442c69ddd0c902a247a3ce933", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -1850,6 +1850,7 @@ enum cp_parser_prec\n   PREC_AND_EXPRESSION,\n   PREC_EQUALITY_EXPRESSION,\n   PREC_RELATIONAL_EXPRESSION,\n+  PREC_SPACESHIP_EXPRESSION,\n   PREC_SHIFT_EXPRESSION,\n   PREC_ADDITIVE_EXPRESSION,\n   PREC_MULTIPLICATIVE_EXPRESSION,\n@@ -1921,6 +1922,8 @@ static const cp_parser_binary_operations_map_node binops[] = {\n   { CPP_LSHIFT, LSHIFT_EXPR, PREC_SHIFT_EXPRESSION },\n   { CPP_RSHIFT, RSHIFT_EXPR, PREC_SHIFT_EXPRESSION },\n \n+  { CPP_SPACESHIP, SPACESHIP_EXPR, PREC_SPACESHIP_EXPRESSION },\n+\n   { CPP_LESS, LT_EXPR, PREC_RELATIONAL_EXPRESSION },\n   { CPP_GREATER, GT_EXPR, PREC_RELATIONAL_EXPRESSION },\n   { CPP_LESS_EQ, LE_EXPR, PREC_RELATIONAL_EXPRESSION },\n@@ -15507,6 +15510,10 @@ cp_parser_operator (cp_parser* parser, location_t start_loc)\n       op = GE_EXPR;\n       break;\n \n+    case CPP_SPACESHIP:\n+      op = SPACESHIP_EXPR;\n+      break;\n+\n     case CPP_AND_AND:\n       op = TRUTH_ANDIF_EXPR;\n       break;"}, {"sha": "313b8073a3c4aff8b4f740eecd7c9e0499b157e7", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -19003,6 +19003,7 @@ tsubst_copy_and_build (tree t,\n     case GE_EXPR:\n     case LT_EXPR:\n     case GT_EXPR:\n+    case SPACESHIP_EXPR:\n     case MEMBER_REF:\n     case DOTSTAR_EXPR:\n       {"}, {"sha": "5cdeb6a07fef5226dc3e37b639a3f9abf2b9f8af", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -5042,6 +5042,9 @@ special_function_p (const_tree decl)\n     return sfk_conversion;\n   if (deduction_guide_p (decl))\n     return sfk_deduction_guide;\n+  if (DECL_OVERLOADED_OPERATOR_CODE_RAW (decl) >= OVL_OP_EQ_EXPR\n+      && DECL_OVERLOADED_OPERATOR_CODE_RAW (decl) <= OVL_OP_SPACESHIP_EXPR)\n+    return sfk_comparison;\n \n   return sfk_none;\n }"}, {"sha": "38a15d14620077c950d34a1e3eb8ea6050f7d643", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -4889,6 +4889,7 @@ cp_build_binary_op (const op_location_t &location,\n \n     case EQ_EXPR:\n     case NE_EXPR:\n+    case SPACESHIP_EXPR:\n       if (code0 == VECTOR_TYPE && code1 == VECTOR_TYPE)\n \tgoto vector_compare;\n       if ((complain & tf_warning)\n@@ -4965,7 +4966,9 @@ cp_build_binary_op (const op_location_t &location,\n \t  warn_for_null_address (location, op1, complain);\n \t}\n       else if ((code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n-\t       || (TYPE_PTRDATAMEM_P (type0) && TYPE_PTRDATAMEM_P (type1)))\n+\t       || (code == SPACESHIP_EXPR\n+\t\t   ? TYPE_PTRMEM_P (type0) && TYPE_PTRMEM_P (type1)\n+\t\t   : TYPE_PTRDATAMEM_P (type0) && TYPE_PTRDATAMEM_P (type1)))\n \tresult_type = composite_pointer_type (location,\n \t\t\t\t\t      type0, type1, op0, op1,\n \t\t\t\t\t      CPO_COMPARISON, complain);\n@@ -5358,6 +5361,55 @@ cp_build_binary_op (const op_location_t &location,\n \t\t\t\t  location);\n     }\n \n+  if (code == SPACESHIP_EXPR)\n+    {\n+      iloc_sentinel s (location);\n+\n+      tree orig_type0 = TREE_TYPE (orig_op0);\n+      tree_code orig_code0 = TREE_CODE (orig_type0);\n+      tree orig_type1 = TREE_TYPE (orig_op1);\n+      tree_code orig_code1 = TREE_CODE (orig_type1);\n+      if ((orig_code0 == BOOLEAN_TYPE) != (orig_code1 == BOOLEAN_TYPE))\n+\t/* \"If one of the operands is of type bool and the other is not, the\n+\t   program is ill-formed.\"  */\n+\tresult_type = NULL_TREE;\n+      else if (code0 == POINTER_TYPE && orig_code0 != POINTER_TYPE\n+\t       && code1 == POINTER_TYPE && orig_code1 != POINTER_TYPE)\n+\t/* We only do array/function-to-pointer conversion if \"at least one of\n+\t   the operands is of pointer type\".  */\n+\tresult_type = NULL_TREE;\n+      else if (orig_code0 == ENUMERAL_TYPE && orig_code1 == ENUMERAL_TYPE\n+\t       && !(same_type_ignoring_top_level_qualifiers_p\n+\t\t    (orig_type0, orig_type1)))\n+\t/* \"If both operands have arithmetic types, or one operand has integral\n+\t   type and the other operand has unscoped enumeration type, the usual\n+\t   arithmetic conversions are applied to the operands.\"  So we don't do\n+\t   arithmetic conversions if the operands both have enumeral type.  */\n+\tresult_type = NULL_TREE;\n+\n+      if (result_type)\n+\tbuild_type = spaceship_type (result_type, complain);\n+\n+      if (result_type && arithmetic_types_p)\n+\t{\n+\t  /* If a narrowing conversion is required, other than from an integral\n+\t     type to a floating point type, the program is ill-formed.  */\n+\t  bool ok = true;\n+\t  if (TREE_CODE (result_type) == REAL_TYPE\n+\t      && INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (orig_op0)))\n+\t    /* OK */;\n+\t  else if (!check_narrowing (result_type, orig_op0, complain))\n+\t    ok = false;\n+\t  if (TREE_CODE (result_type) == REAL_TYPE\n+\t      && INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (orig_op1)))\n+\t    /* OK */;\n+\t  else if (!check_narrowing (result_type, orig_op1, complain))\n+\t    ok = false;\n+\t  if (!ok && !(complain & tf_error))\n+\t    return error_mark_node;\n+\t}\n+    }\n+\n   if (!result_type)\n     {\n       if (complain & tf_error)"}, {"sha": "a3dc38dd325beec021de9d9af47fe5c814451058", "filename": "gcc/testsuite/c-c++-common/cpp/spaceship-1.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fspaceship-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fspaceship-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fspaceship-1.c?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-do preprocess } */\n+/* { dg-options \"-std=c11\" { target c } } */\n+\n+#define A(x, y) x##y\n+A(<=, >)\t/* { dg-error \"does not give a valid preprocessing token\" \"\" { target { ! c++2a } } } */\n+A(<=>, >)\t/* { dg-error \"does not give a valid preprocessing token\" \"\" { target c++2a } } */"}, {"sha": "241b277c05bb0b8c6efdbde08390222318c95f70", "filename": "gcc/testsuite/g++.dg/cpp/spaceship-1.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Fspaceship-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Fspaceship-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp%2Fspaceship-1.C?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -0,0 +1,8 @@\n+// { dg-do compile { target c++17_down } }\n+// { dg-options \"-Wno-pointer-arith\" }\n+\n+struct X {};\n+bool operator<= (X, X);\n+template<bool (X, X)> struct Y {};\n+Y<&operator<=> y;\n+bool foo (bool (*fn) (X, X), int n) { return n+&operator<=> fn; }"}, {"sha": "9d008f19feac6789aa2d84230fc1a96cb64419bc", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-constexpr1.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-constexpr1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-constexpr1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-constexpr1.C?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do compile { target c++2a } }\n+\n+struct A\n+{\n+  int i;\n+  bool operator==(A a) const { return i == a.i; }\n+};\n+\n+struct B\n+{\n+  A a;\n+  bool operator==(const B&) const = default; // { dg-error \"A::operator==\" }\n+};\n+\n+constexpr bool x = B() == B();\t// { dg-error \"non-.constexpr\" }"}, {"sha": "19a03fb04dfc430f010342a888a6ece5c4244f99", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-eq1.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq1.C?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do run { target c++2a } }\n+\n+struct D\n+{\n+  int i;\n+  bool operator==(const D& x) const = default; // OK, returns x.i == y.i\n+  bool operator!=(const D& z) const = default;  // OK, returns !(*this == z)\n+};\n+\n+#define assert(X) do { if (!(X)) __builtin_abort(); } while (0)\n+\n+int main()\n+{\n+  D d{42};\n+  assert (d == d);\n+  assert (!(d != d));\n+}"}, {"sha": "7e98c472cd1b4abf73e513862dc5e086f9034fd9", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-eq1a.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq1a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq1a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq1a.C?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -0,0 +1,24 @@\n+// { dg-do run { target c++2a } }\n+\n+template <class T>\n+struct D\n+{\n+  T i;\n+  bool operator==(const D& x) const = default; // OK, returns x.i == y.i\n+  bool operator!=(const D& z) const = default;  // OK, returns !(*this == z)\n+};\n+\n+#define assert(X) do { if (!(X)) __builtin_abort(); } while (0)\n+\n+template <class T>\n+void f()\n+{\n+  D<T> d{42};\n+  assert (d == d);\n+  assert (!(d != d));\n+}\n+\n+int main()\n+{\n+  f<int>();\n+}"}, {"sha": "06b988f6e57e398001cf3c1aae71fcf5c2bf3232", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-eq2.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq2.C?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -0,0 +1,12 @@\n+// { dg-do compile { target c++2a } }\n+\n+struct D\n+{\n+  int i;\n+  bool operator==(const D& x) const = default; // OK, returns x.i == y.i\n+  bool operator!=(const D& z) const = default;  // OK, returns !(*this == z)\n+};\n+\n+constexpr D d{42};\n+static_assert (d == d);\n+static_assert (!(d != d));"}, {"sha": "490726de56f13f35e840955aed8430468a08273b", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-eq3.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq3.C?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -0,0 +1,16 @@\n+// { dg-do compile { target c++2a } }\n+\n+struct A {\n+  bool operator==(const A&) const;\n+};\n+\n+struct D\n+{\n+  A i;\n+  bool operator==(const D& x) const = default; // { dg-error \"A::operator==\" }\n+  bool operator!=(const D& z) const = default; // { dg-error \"D::operator==\" }\n+};\n+\n+constexpr D d{A()};\n+static_assert (d == d);\t\t// { dg-error \"non-constant|constexpr\" }\n+static_assert (!(d != d));\t// { dg-error \"non-constant|constexpr\" }"}, {"sha": "d89fc885e5013aa064a73eea88a02bf7f5b92b90", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-eq4.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq4.C?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -0,0 +1,8 @@\n+// { dg-do compile { target c++2a } }\n+\n+struct A {\n+  int operator==(const A&) const = default; // { dg-error \"return .bool\" }\n+  bool operator==(const A&, const A&) const = default; // { dg-error \"exactly one\" }\n+  bool operator==(int) const = default; // { dg-error \"parameter type\" }\n+  bool operator==(const A&) = default; // { dg-error \"const\" }\n+};"}, {"sha": "ac24f366c94d496c4091248211ab06f6cd3726d2", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-eq5.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq5.C?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -0,0 +1,10 @@\n+// { dg-do compile { target c++2a } }\n+\n+struct A {\n+  int &r;\t\t\t// { dg-message \"reference\" }\n+  bool operator==(const A&) const = default; // { dg-message \"deleted\" }\n+};\n+\n+int i;\n+A a { i };\n+bool b = a == a;\t\t// { dg-error \"deleted\" }"}, {"sha": "f804e133714124bfa6c22a46709c1923cd647750", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-eq6.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq6.C?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -0,0 +1,10 @@\n+// { dg-do compile { target c++2a } }\n+\n+struct A\n+{\n+  union { int i; }\t\t\t     // { dg-message \"union\" }\n+  bool operator==(const A&) const = default; // { dg-message \"deleted\" }\n+};\n+\n+A a { 42 };\n+bool b = a == a;\t\t// { dg-error \"deleted\" }"}, {"sha": "8112eaa4f80a4aebc86090c11a3e4004d45cbd04", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-eq7.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq7.C?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -0,0 +1,10 @@\n+// { dg-do compile { target c++2a } }\n+\n+union A\n+{\n+  int i;\n+  bool operator==(const A&) const = default; // { dg-message \"union\" }\n+};\n+\n+A a { 42 };\n+bool b = a == a;\t\t// { dg-error \"deleted\" }"}, {"sha": "ce7b56ce57415e699b7eaa289447dcba22366cba", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-err1.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-err1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-err1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-err1.C?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -0,0 +1,5 @@\n+// Test that we suggest adding #include <compare>.\n+// { dg-do compile { target c++2a } }\n+\n+auto x = 1<=>2;\t\t\t// { dg-error \"\" }\n+// { dg-message \"<compare>\" \"\" { target *-*-* } .-1 }"}, {"sha": "6461c6ab60a782e7155e4e704fffe8026c049614", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-err2.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-err2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-err2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-err2.C?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -0,0 +1,7 @@\n+// { dg-do compile { target c++2a } }\n+\n+#include <compare>\n+template <class T, T x = (T() <=> T())> // { dg-error \"31:0 <=> 0\" }\n+void f(T);\n+//constexpr int f(...) { return 42; }\n+constexpr int i = f(24);\t//  { dg-error \"no match\" }"}, {"sha": "bb60302622f7262de2d8600aae86090a48c55353", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-rewrite1.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-rewrite1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-rewrite1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-rewrite1.C?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -0,0 +1,15 @@\n+// This should continue to work.\n+// { dg-do compile { target c++2a } }\n+\n+template<class T>\n+struct A {\n+  template<class U>\n+  bool operator==(const A<U>&);\n+};\n+\n+int main()\n+{\n+  A<int> a1;\n+  A<void> a2;\n+  return a1 == a2;\n+}"}, {"sha": "2ca86b748ffc2f57b6f228314c2ade53e1416eda", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-scalar1.C", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-scalar1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-scalar1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-scalar1.C?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -0,0 +1,93 @@\n+// { dg-do run { target c++2a } }\n+\n+#include <compare>\n+\n+#define assert(X) do { if (!(X)) __builtin_abort(); } while(0)\n+\n+void f(){}\n+void g(){}\n+\n+int main()\n+{\n+  {\n+    constexpr auto v = 1 <=> 2;\n+    static_assert (__is_same_as (decltype (v), const std::strong_ordering));\n+    static_assert (!is_eq (v));\n+    static_assert (is_neq (v));\n+    static_assert (is_lt (v));\n+    static_assert (is_lteq (v));\n+    static_assert (!is_gt (v));\n+    static_assert (!is_gteq (v));\n+  }\n+\n+  {\n+    enum E { a = 0 };\n+    constexpr auto v = E::a <=> 1;\n+    static_assert (__is_same_as (decltype (v), const std::strong_ordering));\n+    static_assert (!is_eq (v));\n+    static_assert (is_neq (v));\n+    static_assert (is_lt (v));\n+    static_assert (is_lteq (v));\n+    static_assert (!is_gt (v));\n+    static_assert (!is_gteq (v));\n+  }\n+\n+  {\n+    enum class E { a, b };\n+    constexpr auto v = E::a <=> E::b;\n+    static_assert (__is_same_as (decltype (v), const std::strong_ordering));\n+    static_assert (!is_eq (v));\n+    static_assert (is_neq (v));\n+    static_assert (is_lt (v));\n+    static_assert (is_lteq (v));\n+    static_assert (!is_gt (v));\n+    static_assert (!is_gteq (v));\n+  }\n+\n+  {\n+    int ar[2];\n+    constexpr auto v = &ar[1] <=> &ar[0];\n+    static_assert (__is_same_as (decltype (v), const std::strong_ordering));\n+    static_assert (!is_eq (v));\n+    static_assert (is_neq (v));\n+    static_assert (!is_lt (v));\n+    static_assert (!is_lteq (v));\n+    static_assert (is_gt (v));\n+    static_assert (is_gteq (v));\n+  }\n+\n+  {\n+    constexpr auto v = 3.14 <=> 3.14;\n+    static_assert (__is_same_as (decltype (v), const std::partial_ordering));\n+    static_assert (is_eq (v));\n+    static_assert (!is_neq (v));\n+    static_assert (!is_lt (v));\n+    static_assert (is_lteq (v));\n+    static_assert (!is_gt (v));\n+    static_assert (is_gteq (v));\n+  }\n+\n+  {\n+    // GCC doesn't consider &f == &g to be a constant expression (PR 69681)\n+    const auto v = &f <=> &g;\n+    static_assert (__is_same_as (decltype (v), const std::strong_equality));\n+    assert (!is_eq (v));\n+    assert (is_neq (v));\n+  }\n+\n+  {\n+    struct A { int i; int j; };\n+    constexpr auto v = &A::i <=> &A::j;\n+    static_assert (__is_same_as (decltype (v), const std::strong_equality));\n+    static_assert (!is_eq (v));\n+    static_assert (is_neq (v));\n+  }\n+\n+  {\n+    struct A { void f(); };\n+    constexpr auto v = &A::f <=> &A::f;\n+    static_assert (__is_same_as (decltype (v), const std::strong_equality));\n+    static_assert (is_eq (v));\n+    static_assert (!is_neq (v));\n+  }\n+}"}, {"sha": "1dc95497fd9327f86e469177485f7a5dc7bda79a", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-scalar1a.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-scalar1a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-scalar1a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-scalar1a.C?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -0,0 +1,41 @@\n+// { dg-do run { target c++2a } }\n+\n+#include <compare>\n+\n+#define assert(X) do { if (!(X)) __builtin_abort(); } while(0)\n+\n+void f(){}\n+void g(){}\n+\n+template <class T, class U, class R>\n+constexpr bool check(T a, U b, R expected)\n+{\n+  auto r = a <=> b;\n+  static_assert (__is_same_as (decltype (r), R));\n+  return r == expected;\n+}\n+\n+int main()\n+{\n+  static_assert (check (1, 2, std::strong_ordering::less));\n+\n+  enum E1 { a = 0 };\n+  static_assert (check (a, 1, std::strong_ordering::less));\n+\n+  enum class E2 { a, b };\n+  static_assert (check (E2::a, E2::b, std::strong_ordering::less));\n+\n+  int ar[2];\n+  static_assert (check (&ar[1], &ar[0], std::strong_ordering::greater));\n+\n+  static_assert (check (3.14, 3.14, std::partial_ordering::equivalent));\n+\n+  // GCC doesn't consider &f == &g to be a constant expression (PR 69681)\n+  assert (check (&f, &g, std::strong_equality::nonequal));\n+\n+  struct A { int i; int j; };\n+  static_assert (check (&A::i, &A::j, std::strong_equality::nonequal));\n+\n+  struct A2 { void f(); };\n+  static_assert (check (&A2::f, &A2::f, std::strong_equality::equal));\n+}"}, {"sha": "d3cb0a6b0f0a8513d74427c7c21c7b828cf16b3b", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-scalar2.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-scalar2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-scalar2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-scalar2.C?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -0,0 +1,11 @@\n+// { dg-do compile { target c++2a } }\n+\n+#include <compare>\n+\n+int main()\n+{\n+  { true <=> 1; }\t\t// { dg-error \"bool\" }\n+  { int a[2]; a <=> a; }\t// { dg-error \"2\" }\n+  { -1 <=> 1U; }\t\t// { dg-error \"narrowing\" }\n+  { enum A { a }; enum B { b }; a <=> b; } // { dg-error \"A\" }\n+}"}, {"sha": "20bc8e61455e12fb4ae0dad765e30db2454bf7b9", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-scalar3.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-scalar3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-scalar3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-scalar3.C?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -0,0 +1,21 @@\n+// { dg-do run { target c++2a } }\n+// { dg-options \"-fext-numeric-literals\" }\n+\n+#include <compare>\n+\n+int main()\n+{\n+  // GCC complex literal extension  \n+  {\n+    constexpr auto v = 1 <=> 1i;\n+    static_assert (__is_same_as (decltype (v), const std::strong_equality));\n+    static_assert (!is_eq (v));\n+    static_assert (is_neq (v));\n+  }\n+  {\n+    constexpr auto v = 1i <=> 1.0i;\n+    static_assert (__is_same_as (decltype (v), const std::weak_equality));\n+    static_assert (is_eq (v));\n+    static_assert (!is_neq (v));\n+  }\n+}"}, {"sha": "6a03f54b91aee6ecaf6bd7eae0f4f2e34edc84a4", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-sfinae1.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-sfinae1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-sfinae1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-sfinae1.C?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -0,0 +1,7 @@\n+// { dg-do compile { target c++2a } }\n+\n+// missing #include <compare>\n+template <class T, T x = (T() <=> T()) == 0>\n+void f(T);\n+constexpr int f(...) { return 42; }\n+constexpr int i = f(24);"}, {"sha": "2a35de99e09dea14154a22f6a90eda3ae259bfc9", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-synth1.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth1.C?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -0,0 +1,43 @@\n+// Test with all operators explicitly defaulted.\n+// { dg-do run { target c++2a } }\n+\n+#include <compare>\n+\n+struct D\n+{\n+  int i;\n+  auto operator<=>(const D& x) const = default;\n+  bool operator==(const D& x) const = default;\n+  bool operator!=(const D& x) const = default;\n+  bool operator<(const D& x) const = default;\n+  bool operator<=(const D& x) const = default;\n+  bool operator>(const D& x) const = default;\n+  bool operator>=(const D& x) const = default;\n+};\n+\n+#define assert(X) do { if (!(X)) __builtin_abort(); } while (0)\n+\n+int main()\n+{\n+  D d{42};\n+  D d2{24};\n+\n+  assert (is_eq (d <=> d));\n+  assert (is_lteq (d <=> d));\n+  assert (is_gteq (d <=> d));\n+  assert (is_lt (d2 <=> d));\n+  assert (is_lteq (d2 <=> d));\n+  assert (is_gt (d <=> d2));\n+  assert (is_gteq (d <=> d2));\n+\n+  assert (d == d);\n+  assert (!(d2 == d));\n+  assert (!(d == d2));\n+  assert (d != d2);\n+  assert (!(d2 != d2));\n+\n+  assert (d2 < d);\n+  assert (d2 <= d);\n+  assert (d > d2);\n+  assert (d >= d2);\n+}"}, {"sha": "32314579dcbc403ba44ba85fb5d86d293bd9e2fa", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-synth1a.C", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth1a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth1a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth1a.C?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -0,0 +1,113 @@\n+// Test with all operators explicitly defaulted.\n+// { dg-do run { target c++2a } }\n+\n+#include <compare>\n+\n+template <class T>\n+struct D\n+{\n+  T i;\n+  auto operator<=>(const D& x) const = default;\n+  bool operator==(const D& x) const = default;\n+  bool operator!=(const D& x) const = default;\n+  bool operator<(const D& x) const = default;\n+  bool operator<=(const D& x) const = default;\n+  bool operator>(const D& x) const = default;\n+  bool operator>=(const D& x) const = default;\n+};\n+\n+template <class T>\n+struct E\n+{\n+  T i;\n+  auto operator<=>(const E& x) const = default;\n+  // auto operator==(const E& x) const = default;\n+  // auto operator!=(const E& x) const = default;\n+  // auto operator<(const E& x) const = default;\n+  // auto operator<=(const E& x) const = default;\n+  // auto operator>(const E& x) const = default;\n+  // auto operator>=(const E& x) const = default;\n+};\n+\n+template <class T>\n+struct F\n+{\n+  T i;\n+  constexpr auto operator<=>(T x) const { return i<=>x; }\n+  constexpr bool operator== (T x) const { return i==x;  }\n+};\n+\n+#define assert(X) do { if (!(X)) __builtin_abort(); } while (0)\n+\n+template <class T, class U>\n+constexpr bool check_eq (T d, U d2)\n+{\n+  return is_eq (d <=> d2)\n+    && is_eq (d2 <=> d)\n+    && is_lteq (d <=> d2)\n+    && is_lteq (d2 <=> d)\n+    && !is_lt (d <=> d2)\n+    && !is_lt (d2 <=> d)\n+    && is_gteq (d <=> d2)\n+    && is_gteq (d2 <=> d)\n+    && !is_gt (d <=> d2)\n+    && !is_gt (d2 <=> d)\n+    && d == d2\n+    && d2 == d\n+    && !(d != d2)\n+    && !(d2 != d)\n+    && d >= d2\n+    && d <= d2\n+    && d2 >= d\n+    && d2 <= d\n+    && !(d < d2)\n+    && !(d2 < d)\n+    && !(d > d2)\n+    && !(d2 > d);\n+}\n+\n+template <class T, class U>\n+constexpr bool check_less (T d, U d2)\n+{\n+  return !is_eq (d <=> d2)\n+    && !is_eq (d2 <=> d)\n+    && is_lteq (d <=> d2)\n+    && !is_lteq (d2 <=> d)\n+    && is_lt (d <=> d2)\n+    && !is_lt (d2 <=> d)\n+    && !is_gteq (d <=> d2)\n+    && is_gteq (d2 <=> d)\n+    && !is_gt (d <=> d2)\n+    && is_gt (d2 <=> d)\n+    && !(d == d2)\n+    && !(d2 == d)\n+    && (d != d2)\n+    && (d2 != d)\n+    && !(d >= d2)\n+    && (d <= d2)\n+    && (d2 >= d)\n+    && !(d2 <= d)\n+    && (d < d2)\n+    && !(d2 < d)\n+    && !(d > d2)\n+    && (d2 > d);\n+}\n+\n+int main()\n+{\n+  constexpr D<int> d{42};\n+  constexpr D<int> d2{24};\n+\n+  static_assert (check_eq (d, d));\n+  static_assert (check_less (d2, d));\n+\n+  constexpr E<float> e { 3.14 };\n+  constexpr E<float> ee { 2.72 };\n+  static_assert (check_eq (e, e));\n+  static_assert (check_less (ee, e));\n+\n+  constexpr F<char> f { 'b' };\n+  static_assert (check_eq (f, 'b'));\n+  static_assert (check_less (f, 'c'));\n+  static_assert (check_less ('a', f));\n+}"}, {"sha": "cf23c9771e01328952c4d42eda807e755afa9eab", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-synth2.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth2.C?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -0,0 +1,43 @@\n+// Test with only spaceship defaulted.\n+// { dg-do run { target c++2a } }\n+\n+#include <compare>\n+\n+struct D\n+{\n+  int i;\n+  auto operator<=>(const D& x) const = default;\n+  // auto operator==(const D& x) const = default;\n+  // auto operator!=(const D& x) const = default;\n+  // auto operator<(const D& x) const = default;\n+  // auto operator<=(const D& x) const = default;\n+  // auto operator>(const D& x) const = default;\n+  // auto operator>=(const D& x) const = default;\n+};\n+\n+#define assert(X) do { if (!(X)) __builtin_abort(); } while (0)\n+\n+int main()\n+{\n+  D d{42};\n+  D d2{24};\n+\n+  assert (is_eq (d <=> d));\n+  assert (is_lteq (d <=> d));\n+  assert (is_gteq (d <=> d));\n+  assert (is_lt (d2 <=> d));\n+  assert (is_lteq (d2 <=> d));\n+  assert (is_gt (d <=> d2));\n+  assert (is_gteq (d <=> d2));\n+\n+  assert (d == d);\n+  assert (!(d2 == d));\n+  assert (!(d == d2));\n+  assert (d != d2);\n+  assert (!(d2 != d2));\n+\n+  assert (d2 < d);\n+  assert (d2 <= d);\n+  assert (d > d2);\n+  assert (d >= d2);\n+}"}, {"sha": "0fc5aa2c9b84b839950fc0af24abdda3a715193a", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-synth3.C", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth3.C?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -0,0 +1,48 @@\n+// Test for reversed candidates.\n+// { dg-do run { target c++2a } }\n+\n+#include <compare>\n+\n+struct D\n+{\n+  int i;\n+  auto operator<=>(int x) const { return i<=>x; }\n+  bool operator== (int x) const { return i==x;  }\n+};\n+\n+#define assert(X) do { if (!(X)) __builtin_abort(); } while (0)\n+\n+int main()\n+{\n+  D d{42};\n+  int d1 = 42;\n+  int d2 = 24;\n+\n+  assert (is_eq (d <=> d1));\n+  assert (is_eq (d1 <=> d));\n+  assert (is_lteq (d <=> d1));\n+  assert (is_lteq (d1 <=> d));\n+  assert (is_gteq (d <=> d1));\n+  assert (is_gteq (d1 <=> d));\n+  assert (is_lt (d2 <=> d));\n+  assert (is_lteq (d2 <=> d));\n+  assert (is_gt (d <=> d2));\n+  assert (is_gteq (d <=> d2));\n+\n+  assert (d == d1);\n+  assert (d1 == d);\n+  assert (!(d2 == d));\n+  assert (!(d == d2));\n+  assert (d != d2);\n+  assert (d2 != d);\n+  assert (!(d != d1));\n+  assert (!(d1 != d));\n+\n+  assert (d2 < d);\n+  assert (d2 <= d);\n+  assert (d1 <= d);\n+  assert (d > d2);\n+  assert (d >= d2);\n+  assert (d >= d1);\n+  assert (d <= d1);\n+}"}, {"sha": "89f84899fcce8d462ce5e1d5232161f23e8faf55", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-synth3a.C", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth3a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth3a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-synth3a.C?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -0,0 +1,54 @@\n+// Test for reversed candidates.\n+// { dg-do run { target c++2a } }\n+\n+#include <compare>\n+\n+struct D\n+{\n+  int i;\n+  auto operator<=>(int x) const { return i<=>x; }\n+  bool operator== (int x) const { return i==x;  }\n+};\n+\n+#define assert(X) do { if (!(X)) __builtin_abort(); } while (0)\n+\n+template <class T>\n+void f()\n+{\n+  D d{42};\n+  int d1 = 42;\n+  int d2 = 24;\n+\n+  assert (is_eq (d <=> d1));\n+  assert (is_eq (d1 <=> d));\n+  assert (is_lteq (d <=> d1));\n+  assert (is_lteq (d1 <=> d));\n+  assert (is_gteq (d <=> d1));\n+  assert (is_gteq (d1 <=> d));\n+  assert (is_lt (d2 <=> d));\n+  assert (is_lteq (d2 <=> d));\n+  assert (is_gt (d <=> d2));\n+  assert (is_gteq (d <=> d2));\n+\n+  assert (d == d1);\n+  assert (d1 == d);\n+  assert (!(d2 == d));\n+  assert (!(d == d2));\n+  assert (d != d2);\n+  assert (d2 != d);\n+  assert (!(d != d1));\n+  assert (!(d1 != d));\n+\n+  assert (d2 < d);\n+  assert (d2 <= d);\n+  assert (d1 <= d);\n+  assert (d > d2);\n+  assert (d >= d2);\n+  assert (d >= d1);\n+  assert (d <= d1);\n+}\n+\n+int main()\n+{\n+  f<int>();\n+}"}, {"sha": "1ff39549973cf4d581f470000d97f1beb9d3c196", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-weak1.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-weak1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-weak1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-weak1.C?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -0,0 +1,15 @@\n+// Test explicit weak_ordering.\n+// { dg-do compile { target c++2a } }\n+\n+#include <compare>\n+struct A\n+{\n+  int i;\n+  std::weak_ordering operator<=> (const A&) const = default;\n+};\n+\n+constexpr A a = { 42 };\n+constexpr auto c = a <=> a;\n+static_assert (std::same_as <decltype (c), const std::weak_ordering>);\n+static_assert (std::is_eq (c));\n+"}, {"sha": "18b2219166a46482e5f92a9b5067e61d9385b79d", "filename": "gcc/testsuite/g++.dg/lookup/pr21802.C", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fpr21802.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fpr21802.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fpr21802.C?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -60,6 +60,7 @@ struct Y : virtual X\n   template <typename T>\n   int operator&(T x) { return m + x + 1; }\n   friend int operator==(Y o, int x) { return o.m + x + 1; }\n+  int operator!=(int x) { return m + x + 1; }\n };\n \n /* The folloiwng \"FooN\" functions each contain a different way to call and to\n@@ -81,7 +82,6 @@ Foo1 (T)\n   { int t = x | I; assert (t == 7); }\n   { int t = x && I; assert (t == 7); }\n   { int t = x || I; assert (t == 7); }\n-  { int t = x != I; assert (t == 7); }\n   { int t = x < I; assert (t == 7); }\n   { int t = x <= I; assert (t == 7); }\n   { int t = x > I; assert (t == 7); }\n@@ -104,6 +104,7 @@ Foo1 (T)\n   { int t = x & I; assert (t == 8); }\n   { int t = &x; assert (t == 8); }\n   { int t = x == I; assert (t == 8); }\n+  { int t = x != I; assert (t == 8); }\n }\n \n template <typename T>\n@@ -204,7 +205,6 @@ Foo4 (T)\n   { int t = x.operator| (I); assert (t == 7); }\n   { int t = x.operator&& (I); assert (t == 7); }\n   { int t = x.operator|| (I); assert (t == 7); }\n-  { int t = x.operator!= (I); assert (t == 7); }\n   { int t = x.operator< (I); assert (t == 7); }\n   { int t = x.operator<= (I); assert (t == 7); }\n   { int t = x.operator> (I); assert (t == 7); }\n@@ -227,6 +227,7 @@ Foo4 (T)\n   { int t = x.operator& (); assert (t == 8); }\n   { int t = x.operator& (I); assert (t == 8); }\n   { int t = operator== (x, I); assert (t == 8); }\n+  { int t = x.operator!= (I); assert (t == 8); }\n }\n \n "}, {"sha": "c0921bb43de93c135267546c43677b63465fe56d", "filename": "gcc/testsuite/g++.old-deja/g++.robertl/eb22.C", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb22.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb22.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb22.C?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -11,18 +11,17 @@ public:\n         operator int() const {return 2;}\n };\n \n-bool operator==(const MyInt& a, const int& b)   // { dg-message \"operator==\" } candidate\n+bool operator==(const MyInt& a, const int& b) // { dg-message \"operator==\" \"\" { target c++17_down } }\n {\n         return (int)a == b;\n }\n \n-bool operator==(const MyInt& a, const MyInt& b) // { dg-message \"operator==\" } candidate\n+bool operator==(const MyInt& a, const MyInt& b) // { dg-message \"operator==\" \"\" { target c++17_down } }\n {\n         return (int)a == (int)b;\n }\n \n bool f()\n {\n-  return 3 == MyInt();                          // { dg-error \"ambiguous\" \"err\" } \n-  // { dg-message \"operator==\" \"match candidate text\" { target *-*-* } .-1 }\n+  return 3 == MyInt();\t// { dg-error \"ambiguous\" \"err\" { target c++17_down } }\n }"}, {"sha": "8be84386d6cb814a78bdaffe58889eefd3516816", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -1,3 +1,8 @@\n+2019-11-05  Tim van Deurzen  <tim@kompiler.org>\n+\n+\t* cpplib.h: Add spaceship operator for C++.\n+\t* lex.c: Implement conditional lexing of spaceship operator for C++20.\n+\n 2019-10-31  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR preprocessor/92296"}, {"sha": "ed108f17bfa122fa951199f90fd2d665ec056cc4", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -78,6 +78,7 @@ struct _cpp_file;\n   OP(NOT_EQ,\t\t\"!=\")\t\t\t\t\t\t\\\n   OP(GREATER_EQ,\t\">=\")\t\t\t\t\t\t\\\n   OP(LESS_EQ,\t\t\"<=\")\t\t\t\t\t\t\\\n+  OP(SPACESHIP,\t\t\"<=>\")\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   /* These two are unary + / - in preprocessor expressions.  */\t\t\\\n   OP(PLUS_EQ,\t\t\"+=\")\t/* math */\t\t\t\t\\"}, {"sha": "e95eda3f44e84e1d203ce7ea4a3c90279b42f71d", "filename": "libcpp/lex.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -2980,7 +2980,13 @@ _cpp_lex_direct (cpp_reader *pfile)\n \n       result->type = CPP_LESS;\n       if (*buffer->cur == '=')\n-\tbuffer->cur++, result->type = CPP_LESS_EQ;\n+\t{\n+\t  buffer->cur++, result->type = CPP_LESS_EQ;\n+\t  if (*buffer->cur == '>'\n+\t      && CPP_OPTION (pfile, cplusplus)\n+\t      && CPP_OPTION (pfile, lang) >= CLK_GNUCXX2A)\n+\t    buffer->cur++, result->type = CPP_SPACESHIP;\n+\t}\n       else if (*buffer->cur == '<')\n \t{\n \t  buffer->cur++;\n@@ -3491,6 +3497,7 @@ cpp_avoid_paste (cpp_reader *pfile, const cpp_token *token1,\n \t\t\t\t|| (CPP_OPTION (pfile, objc)\n \t\t\t\t    && token1->val.str.text[0] == '@'\n \t\t\t\t    && (b == CPP_NAME || b == CPP_STRING)));\n+    case CPP_LESS_EQ:\treturn c == '>';\n     case CPP_STRING:\n     case CPP_WSTRING:\n     case CPP_UTF8STRING:"}, {"sha": "4f05f774b8b2cea23626492e7d8dda309f6d76e3", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -1,5 +1,10 @@\n 2019-11-05  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* libsupc++/compare: New header.\n+\t* libsupc++/Makefile.am (std_HEADERS): Add compare.\n+\t* include/std/version: Define __cpp_lib_three_way_comparison.\n+\t* include/std/functional: #include <compare>.\n+\n \t* include/std/version [!_GLIBCXX_HOSTED]: Do not define feature test\n \tmacros for features that are only present in hosted builds.\n "}, {"sha": "49fd41360bca942275ff927beba34ccee30107f4", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -1385,8 +1385,9 @@ endif\n # <new>, <typeinfo>, <exception>, <initializer_list>, <cstdalign>, <cstdarg>,\n # <concepts>, <cstdbool>, <type_traits>, <bit>, <atomic>,\n # and any files which they include (and which we provide).\n-# <new>, <typeinfo>, <exception>, and <initializer_list> are installed by\n-# libsupc++, so only the others and the sub-includes are copied here.\n+# <new>, <typeinfo>, <exception>, <initializer_list> and <compare>\n+# are installed by libsupc++, so only the others and the sub-includes\n+# are copied here.\n install-freestanding-headers:\n \t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/bits\n \tfor file in c++0x_warning.h atomic_base.h concept_check.h move.h; do \\"}, {"sha": "b6a57ac9b54ef16eaea8bddfdb29793fc2be8c16", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -66,6 +66,7 @@\n #endif\n #if __cplusplus > 201703L\n # include <bits/range_cmp.h>\n+# include <compare>\n #endif\n \n namespace std _GLIBCXX_VISIBILITY(default)"}, {"sha": "fa6d27467f798a443285f81192984179726cd61d", "filename": "libstdc++-v3/include/std/version", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -187,6 +187,9 @@\n #define __cpp_lib_list_remove_return_type 201806L\n #define __cpp_lib_math_constants 201907L\n #define __cpp_lib_span 201902L\n+#if __cpp_impl_three_way_comparison >= 201907L\n+# define __cpp_lib_three_way_comparison 201711L\n+#endif\n #define __cpp_lib_to_array 201907L\n #endif\n #endif // C++2a"}, {"sha": "8303f88ef41f5fdf4ea31bb661a856e0751c814c", "filename": "libstdc++-v3/libsupc++/Makefile.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -31,7 +31,7 @@ toolexeclib_LTLIBRARIES = libsupc++.la\n noinst_LTLIBRARIES = libsupc++convenience.la\n \n std_HEADERS = \\\n-\tcxxabi.h exception initializer_list new typeinfo\n+\tcompare cxxabi.h exception initializer_list new typeinfo\n \n bits_HEADERS = \\\n \tatomic_lockfree_defines.h cxxabi_forced.h \\"}, {"sha": "379b2d485827a25703556c2a5812051c02e31d24", "filename": "libstdc++-v3/libsupc++/compare", "status": "added", "additions": 644, "deletions": 0, "changes": 644, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcompare", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcompare", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcompare?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -0,0 +1,644 @@\n+// -*- C++ -*- operator<=> three-way comparison support.\n+\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file compare\n+ *  This is a Standard C++ Library header.\n+ */\n+\n+#ifndef _COMPARE\n+#define _COMPARE\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus > 201703L && __cpp_impl_three_way_comparison >= 201907L\n+\n+#pragma GCC visibility push(default)\n+\n+#include <concepts>\n+\n+namespace std\n+{\n+#define __cpp_lib_three_way_comparison 201711L\n+\n+  // [cmp.categories], comparison category types\n+\n+  namespace __cmp_cat\n+  {\n+    enum class _Eq\n+    { equal = 0, equivalent = equal, nonequal = 1, nonequivalent = nonequal };\n+\n+    enum class _Ord { _Less = -1, _Greater = 1 };\n+\n+    enum class _Ncmp { _Unordered = -127 };\n+\n+    struct __unspec\n+    {\n+      constexpr __unspec(__unspec*) { }\n+    };\n+  }\n+\n+  class weak_equality\n+  {\n+    int _M_value;\n+\n+    constexpr explicit\n+    weak_equality(__cmp_cat::_Eq __val) noexcept\n+    : _M_value(int(__val))\n+    { }\n+\n+  public:\n+    // valid values\n+\n+    static const weak_equality equivalent;\n+    static const weak_equality nonequivalent;\n+\n+    // comparisons\n+\n+    friend constexpr bool\n+    operator==(weak_equality __v, __cmp_cat::__unspec) noexcept\n+    { return __v._M_value == 0; }\n+\n+    friend constexpr bool\n+    operator==(weak_equality, weak_equality) noexcept = default;\n+\n+    friend constexpr weak_equality\n+    operator<=>(weak_equality __v, __cmp_cat::__unspec) noexcept\n+    { return __v; }\n+\n+    friend constexpr weak_equality\n+    operator<=>(__cmp_cat::__unspec, weak_equality __v) noexcept\n+    { return __v; }\n+  };\n+\n+  // valid values' definitions\n+  inline constexpr weak_equality\n+  weak_equality::equivalent(__cmp_cat::_Eq::equivalent);\n+\n+  inline constexpr weak_equality\n+  weak_equality::nonequivalent(__cmp_cat::_Eq::nonequivalent);\n+\n+  class strong_equality\n+  {\n+    int _M_value;\n+\n+    constexpr explicit\n+    strong_equality(__cmp_cat::_Eq __val) noexcept\n+    : _M_value(int(__val))\n+    { }\n+\n+  public:\n+    // valid values\n+\n+    static const strong_equality equal;\n+    static const strong_equality nonequal;\n+    static const strong_equality equivalent;\n+    static const strong_equality nonequivalent;\n+\n+    // conversion\n+    constexpr operator weak_equality() const noexcept\n+    {\n+      if (_M_value == 0)\n+\treturn weak_equality::equivalent;\n+      else\n+\treturn weak_equality::nonequivalent;\n+    }\n+\n+    // comparisons\n+\n+    friend constexpr bool\n+    operator==(strong_equality __v, __cmp_cat::__unspec) noexcept\n+    { return __v._M_value == 0; }\n+\n+    friend constexpr bool\n+    operator==(strong_equality, strong_equality) noexcept = default;\n+\n+    friend constexpr strong_equality\n+    operator<=>(strong_equality __v, __cmp_cat::__unspec) noexcept\n+    { return __v; }\n+\n+    friend constexpr strong_equality\n+    operator<=>(__cmp_cat::__unspec, strong_equality __v) noexcept\n+    { return __v; }\n+  };\n+\n+  // valid values' definitions\n+  inline constexpr strong_equality\n+  strong_equality::equal(__cmp_cat::_Eq::equal);\n+\n+  inline constexpr strong_equality\n+  strong_equality::nonequal(__cmp_cat::_Eq::nonequal);\n+\n+  inline constexpr strong_equality\n+  strong_equality::equivalent(__cmp_cat::_Eq::equivalent);\n+\n+  inline constexpr strong_equality\n+  strong_equality::nonequivalent(__cmp_cat::_Eq::nonequivalent);\n+\n+  class partial_ordering\n+  {\n+    int _M_value;\n+    bool _M_is_ordered;\n+\n+    constexpr explicit\n+    partial_ordering(__cmp_cat::_Eq __v) noexcept\n+    : _M_value(int(__v)), _M_is_ordered(true)\n+    { }\n+\n+    constexpr explicit\n+    partial_ordering(__cmp_cat::_Ord __v) noexcept\n+    : _M_value(int(__v)), _M_is_ordered(true)\n+    { }\n+\n+    constexpr explicit\n+    partial_ordering(__cmp_cat::_Ncmp __v) noexcept\n+    : _M_value(int(__v)), _M_is_ordered(false)\n+    { }\n+\n+  public:\n+    // valid values\n+    static const partial_ordering less;\n+    static const partial_ordering equivalent;\n+    static const partial_ordering greater;\n+    static const partial_ordering unordered;\n+\n+    // conversion\n+    constexpr operator weak_equality() const noexcept\n+    {\n+      if (_M_value == 0)\n+\treturn weak_equality::equivalent;\n+      else\n+\treturn weak_equality::nonequivalent;\n+    }\n+\n+    // comparisons\n+    friend constexpr bool\n+    operator==(partial_ordering __v, __cmp_cat::__unspec) noexcept\n+    { return __v._M_is_ordered && __v._M_value == 0; }\n+\n+    friend constexpr bool\n+    operator==(partial_ordering, partial_ordering) noexcept = default;\n+\n+    friend constexpr bool\n+    operator< (partial_ordering __v, __cmp_cat::__unspec) noexcept\n+    { return __v._M_is_ordered && __v._M_value < 0; }\n+\n+    friend constexpr bool\n+    operator> (partial_ordering __v, __cmp_cat::__unspec) noexcept\n+    { return __v._M_is_ordered && __v._M_value > 0; }\n+\n+    friend constexpr bool\n+    operator<=(partial_ordering __v, __cmp_cat::__unspec) noexcept\n+    { return __v._M_is_ordered && __v._M_value <= 0; }\n+\n+    friend constexpr bool\n+    operator>=(partial_ordering __v, __cmp_cat::__unspec) noexcept\n+    { return __v._M_is_ordered && __v._M_value >= 0; }\n+\n+    friend constexpr bool\n+    operator< (__cmp_cat::__unspec, partial_ordering __v) noexcept\n+    { return __v._M_is_ordered && 0 < __v._M_value; }\n+\n+    friend constexpr bool\n+    operator> (__cmp_cat::__unspec, partial_ordering __v) noexcept\n+    { return __v._M_is_ordered && 0 > __v._M_value; }\n+\n+    friend constexpr bool\n+    operator<=(__cmp_cat::__unspec, partial_ordering __v) noexcept\n+    { return __v._M_is_ordered && 0 <= __v._M_value; }\n+\n+    friend constexpr bool\n+    operator>=(__cmp_cat::__unspec, partial_ordering __v) noexcept\n+    { return __v._M_is_ordered && 0 >= __v._M_value; }\n+\n+    friend constexpr partial_ordering\n+    operator<=>(partial_ordering __v, __cmp_cat::__unspec) noexcept\n+    { return __v; }\n+\n+    friend constexpr partial_ordering\n+    operator<=>(__cmp_cat::__unspec, partial_ordering __v) noexcept\n+    {\n+      if (__v < 0)\n+\treturn  partial_ordering::greater;\n+      else if (__v > 0)\n+\treturn partial_ordering::less;\n+      else\n+\treturn __v;\n+    }\n+  };\n+\n+  // valid values' definitions\n+  inline constexpr partial_ordering\n+  partial_ordering::less(__cmp_cat::_Ord::_Less);\n+\n+  inline constexpr partial_ordering\n+  partial_ordering::equivalent(__cmp_cat::_Eq::equivalent);\n+\n+  inline constexpr partial_ordering\n+  partial_ordering::greater(__cmp_cat::_Ord::_Greater);\n+\n+  inline constexpr partial_ordering\n+  partial_ordering::unordered(__cmp_cat::_Ncmp::_Unordered);\n+\n+  class weak_ordering\n+  {\n+    int _M_value;\n+\n+    constexpr explicit\n+    weak_ordering(__cmp_cat::_Eq __v) noexcept : _M_value(int(__v))\n+    { }\n+\n+    constexpr explicit\n+    weak_ordering(__cmp_cat::_Ord __v) noexcept : _M_value(int(__v))\n+    { }\n+\n+  public:\n+    // valid values\n+    static const weak_ordering less;\n+    static const weak_ordering equivalent;\n+    static const weak_ordering greater;\n+\n+    // conversions\n+    constexpr operator weak_equality() const noexcept\n+    {\n+      if (_M_value == 0)\n+\treturn weak_equality::equivalent;\n+      else\n+\treturn weak_equality::nonequivalent;\n+    }\n+\n+    constexpr operator partial_ordering() const noexcept\n+    {\n+      if (_M_value == 0)\n+\treturn partial_ordering::equivalent;\n+      else if (_M_value < 0)\n+\treturn partial_ordering::less;\n+      else\n+\treturn partial_ordering::greater;\n+    }\n+\n+    // comparisons\n+    friend constexpr bool\n+    operator==(weak_ordering __v, __cmp_cat::__unspec) noexcept\n+    { return __v._M_value == 0; }\n+\n+    friend constexpr bool\n+    operator==(weak_ordering, weak_ordering) noexcept = default;\n+\n+    friend constexpr bool\n+    operator< (weak_ordering __v, __cmp_cat::__unspec) noexcept\n+    { return __v._M_value < 0; }\n+\n+    friend constexpr bool\n+    operator> (weak_ordering __v, __cmp_cat::__unspec) noexcept\n+    { return __v._M_value > 0; }\n+\n+    friend constexpr bool\n+    operator<=(weak_ordering __v, __cmp_cat::__unspec) noexcept\n+    { return __v._M_value <= 0; }\n+\n+    friend constexpr bool\n+    operator>=(weak_ordering __v, __cmp_cat::__unspec) noexcept\n+    { return __v._M_value >= 0; }\n+\n+    friend constexpr bool\n+    operator< (__cmp_cat::__unspec, weak_ordering __v) noexcept\n+    { return 0 < __v._M_value; }\n+\n+    friend constexpr bool\n+    operator> (__cmp_cat::__unspec, weak_ordering __v) noexcept\n+    { return 0 > __v._M_value; }\n+\n+    friend constexpr bool\n+    operator<=(__cmp_cat::__unspec, weak_ordering __v) noexcept\n+    { return 0 <= __v._M_value; }\n+\n+    friend constexpr bool\n+    operator>=(__cmp_cat::__unspec, weak_ordering __v) noexcept\n+    { return 0 >= __v._M_value; }\n+\n+    friend constexpr weak_ordering\n+    operator<=>(weak_ordering __v, __cmp_cat::__unspec) noexcept\n+    { return __v; }\n+\n+    friend constexpr weak_ordering\n+    operator<=>(__cmp_cat::__unspec, weak_ordering __v) noexcept\n+    {\n+      if (__v < 0)\n+\treturn  weak_ordering::greater;\n+      else if (__v > 0)\n+\treturn weak_ordering::less;\n+      else\n+\treturn __v;\n+    }\n+  };\n+\n+  // valid values' definitions\n+  inline constexpr weak_ordering\n+  weak_ordering::less(__cmp_cat::_Ord::_Less);\n+\n+  inline constexpr weak_ordering\n+  weak_ordering::equivalent(__cmp_cat::_Eq::equivalent);\n+\n+  inline constexpr weak_ordering\n+  weak_ordering::greater(__cmp_cat::_Ord::_Greater);\n+\n+  class strong_ordering\n+  {\n+    int _M_value;\n+\n+    constexpr explicit\n+    strong_ordering(__cmp_cat::_Eq __v) noexcept\n+    : _M_value(int(__v))\n+    { }\n+\n+    constexpr explicit\n+    strong_ordering(__cmp_cat::_Ord __v) noexcept\n+    : _M_value(int(__v))\n+    { }\n+\n+  public:\n+    // valid values\n+    static const strong_ordering less;\n+    static const strong_ordering equal;\n+    static const strong_ordering equivalent;\n+    static const strong_ordering greater;\n+\n+    // conversions\n+    constexpr operator weak_equality() const noexcept\n+    {\n+      if (_M_value == 0)\n+\treturn weak_equality::equivalent;\n+      else\n+\treturn weak_equality::nonequivalent;\n+    }\n+\n+    constexpr operator strong_equality() const noexcept\n+    {\n+      if (_M_value == 0)\n+\treturn strong_equality::equal;\n+      else\n+\treturn strong_equality::nonequal;\n+    }\n+\n+    constexpr operator partial_ordering() const noexcept\n+    {\n+      if (_M_value == 0)\n+\treturn partial_ordering::equivalent;\n+      else if (_M_value < 0)\n+\treturn partial_ordering::less;\n+      else\n+\treturn partial_ordering::greater;\n+    }\n+\n+    constexpr operator weak_ordering() const noexcept\n+    {\n+      if (_M_value == 0)\n+\treturn weak_ordering::equivalent;\n+      else if (_M_value < 0)\n+\treturn weak_ordering::less;\n+      else\n+\treturn weak_ordering::greater;\n+    }\n+\n+    // comparisons\n+    friend constexpr bool\n+    operator==(strong_ordering __v, __cmp_cat::__unspec) noexcept\n+    { return __v._M_value == 0; }\n+\n+    friend constexpr bool\n+    operator==(strong_ordering, strong_ordering) noexcept = default;\n+\n+    friend constexpr bool\n+    operator< (strong_ordering __v, __cmp_cat::__unspec) noexcept\n+    { return __v._M_value < 0; }\n+\n+    friend constexpr bool\n+    operator> (strong_ordering __v, __cmp_cat::__unspec) noexcept\n+    { return __v._M_value > 0; }\n+\n+    friend constexpr bool\n+    operator<=(strong_ordering __v, __cmp_cat::__unspec) noexcept\n+    { return __v._M_value <= 0; }\n+\n+    friend constexpr bool\n+    operator>=(strong_ordering __v, __cmp_cat::__unspec) noexcept\n+    { return __v._M_value >= 0; }\n+\n+    friend constexpr bool\n+    operator< (__cmp_cat::__unspec, strong_ordering __v) noexcept\n+    { return 0 < __v._M_value; }\n+\n+    friend constexpr bool\n+    operator> (__cmp_cat::__unspec, strong_ordering __v) noexcept\n+    { return 0 > __v._M_value; }\n+\n+    friend constexpr bool\n+    operator<=(__cmp_cat::__unspec, strong_ordering __v) noexcept\n+    { return 0 <= __v._M_value; }\n+\n+    friend constexpr bool\n+    operator>=(__cmp_cat::__unspec, strong_ordering __v) noexcept\n+    { return 0 >= __v._M_value; }\n+\n+    friend constexpr strong_ordering\n+    operator<=>(strong_ordering __v, __cmp_cat::__unspec) noexcept\n+    { return __v; }\n+\n+    friend constexpr strong_ordering\n+    operator<=>(__cmp_cat::__unspec, strong_ordering __v) noexcept\n+    {\n+      if (__v < 0)\n+\treturn  strong_ordering::greater;\n+      else if (__v > 0)\n+\treturn strong_ordering::less;\n+      else\n+\treturn __v;\n+    }\n+  };\n+\n+  // valid values' definitions\n+  inline constexpr strong_ordering\n+  strong_ordering::less(__cmp_cat::_Ord::_Less);\n+\n+  inline constexpr strong_ordering\n+  strong_ordering::equal(__cmp_cat::_Eq::equal);\n+\n+  inline constexpr strong_ordering\n+  strong_ordering::equivalent(__cmp_cat::_Eq::equivalent);\n+\n+  inline constexpr strong_ordering\n+  strong_ordering::greater(__cmp_cat::_Ord::_Greater);\n+\n+\n+  // named comparison functions\n+  constexpr bool\n+  is_eq(weak_equality __cmp) noexcept\n+  { return __cmp == 0; }\n+\n+  constexpr bool\n+  is_neq(weak_equality __cmp) noexcept\n+  { return __cmp != 0; }\n+\n+  constexpr bool\n+  is_lt  (partial_ordering __cmp) noexcept\n+  { return __cmp < 0; }\n+\n+  constexpr bool\n+  is_lteq(partial_ordering __cmp) noexcept\n+  { return __cmp <= 0; }\n+\n+  constexpr bool\n+  is_gt  (partial_ordering __cmp) noexcept\n+  { return __cmp > 0; }\n+\n+  constexpr bool\n+  is_gteq(partial_ordering __cmp) noexcept\n+  { return __cmp >= 0; }\n+\n+  // [cmp.common], common comparison category type\n+  template<typename... _Ts>\n+    struct common_comparison_category {\n+      // using type = TODO\n+    };\n+\n+  template<typename... _Ts>\n+    using common_comparison_category_t\n+      = typename common_comparison_category<_Ts...>::type;\n+\n+#if __cpp_concepts\n+  namespace __detail\n+  {\n+    template<typename _Tp, typename _Cat>\n+      concept __compares_as\n+\t= same_as<common_comparison_category_t<_Tp, _Cat>, _Cat>;\n+\n+    template<typename _Tp, typename _Up>\n+      concept __partially_ordered_with\n+\t= requires(const remove_reference_t<_Tp>& __t,\n+\t\t   const remove_reference_t<_Up>& __u) {\n+\t  { __t <  __u } -> boolean;\n+\t  { __t >  __u } -> boolean;\n+\t  { __t <= __u } -> boolean;\n+\t  { __t >= __u } -> boolean;\n+\t  { __u <  __t } -> boolean;\n+\t  { __u >  __t } -> boolean;\n+\t  { __u <= __t } -> boolean;\n+\t  { __u >= __t } -> boolean;\n+\t};\n+  } // namespace __detail\n+\n+  // [cmp.concept], concept three_way_comparable\n+  template<typename _Tp, typename _Cat = partial_ordering>\n+    concept three_way_comparable\n+      = __detail::__weakly_eq_cmp_with<_Tp, _Tp>\n+      && (!convertible_to<_Cat, partial_ordering>\n+\t  || __detail::__partially_ordered_with<_Tp, _Tp>)\n+      && requires(const remove_reference_t<_Tp>& __a,\n+\t\t  const remove_reference_t<_Tp>& __b) {\n+\t{ __a <=> __b } -> __detail::__compares_as<_Cat>;\n+      };\n+\n+  template<typename _Tp, typename _Up, typename _Cat = partial_ordering>\n+    concept three_way_comparable_with\n+      = __detail::__weakly_eq_cmp_with<_Tp, _Up>\n+      && (!convertible_to<_Cat, partial_ordering>\n+\t  || __detail::__partially_ordered_with<_Tp, _Up>)\n+      && three_way_comparable<_Tp, _Cat>\n+      && three_way_comparable<_Up, _Cat>\n+      && common_reference_with<const remove_reference_t<_Tp>&,\n+\t\t\t       const remove_reference_t<_Up>&>\n+      && three_way_comparable<\n+\t  common_reference_t<const remove_reference_t<_Tp>&,\n+\t\t\t     const remove_reference_t<_Up>&>, _Cat>\n+      && requires(const remove_reference_t<_Tp>& __t,\n+\t\t  const remove_reference_t<_Up>& __u) {\n+\t{ __t <=> __u } -> __detail::__compares_as<_Cat>;\n+\t{ __u <=> __t } -> __detail::__compares_as<_Cat>;\n+      };\n+#endif\n+\n+  template<typename _Tp, typename _Up>\n+    using __cmp2way_res_t\n+      = decltype(std::declval<_Tp&>() <=> std::declval<_Up&>());\n+\n+  template<typename _Tp, typename _Up = _Tp, typename = void>\n+    struct __cmp3way_helper\n+    { };\n+\n+  template<typename _Tp, typename _Up>\n+    struct __cmp3way_helper<_Tp, _Up, void_t<__cmp2way_res_t<_Tp, _Up>>>\n+    {\n+      using type = __cmp2way_res_t<_Tp, _Up>;\n+      using __type = type;\n+    };\n+\n+  /// [cmp.result], result of three-way comparison\n+  template<typename _Tp, typename _Up = _Tp>\n+    struct compare_three_way_result\n+    : __cmp3way_helper<_Tp, _Up>\n+    { };\n+\n+  template<typename _Tp, typename _Up = _Tp>\n+    using compare_three_way_result_t\n+      = typename compare_three_way_result<_Tp, _Up>::__type;\n+\n+  // [cmp.object], typename compare_three_way\n+  struct compare_three_way\n+  {\n+    // TODO\n+#if 0\n+    template<typename _Tp, typename _Up>\n+      requires (three_way_comparable_with<_Tp, _Up>\n+\t  || BUILTIN-PTR-THREE-WAY(_Tp, _Up))\n+    constexpr auto\n+    operator()(_Tp&& __t, _Up&& __u) const noexcept\n+    {\n+      // TODO\n+    }\n+#endif\n+\n+    using is_transparent = void;\n+  };\n+\n+  // [cmp.alg], comparison algorithms\n+  inline namespace __cmp_alg\n+  {\n+    // TODO\n+#if 0\n+    inline constexpr unspecified strong_order = unspecified;\n+    inline constexpr unspecified weak_order = unspecified;\n+    inline constexpr unspecified partial_order = unspecified;\n+    inline constexpr unspecified compare_strong_order_fallback = unspecified;\n+    inline constexpr unspecified compare_weak_order_fallback = unspecified;\n+    inline constexpr unspecified compare_partial_order_fallback = unspecified;\n+#endif\n+  }\n+}\n+\n+#pragma GCC visibility pop\n+\n+#endif // C++20\n+\n+#endif // _COMPARE"}, {"sha": "938b75e39d98f3083b5b3eabc2b52f629411c8e4", "filename": "libstdc++-v3/testsuite/std/concepts/concepts.object/regular.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7689b962dd6536bbb2567bfdec52e35109af7ab/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.object%2Fregular.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7689b962dd6536bbb2567bfdec52e35109af7ab/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.object%2Fregular.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Fconcepts%2Fconcepts.object%2Fregular.cc?ref=b7689b962dd6536bbb2567bfdec52e35109af7ab", "patch": "@@ -52,7 +52,7 @@ static_assert( ! std::regular<HasReference> );\n \n struct HasEq { };\n bool operator==(HasEq, HasEq) { return true; }\n-#ifdef __cpp_lib_three_way_comparison\n+#ifdef __cpp_impl_three_way_comparison\n static_assert( std::regular<HasEq> );\n #else\n static_assert( ! std::regular<HasEq> );"}]}