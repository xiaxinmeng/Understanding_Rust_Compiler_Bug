{"sha": "2a7b629279cd9750761e9be507d755f53202a57a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmE3YjYyOTI3OWNkOTc1MDc2MWU5YmU1MDdkNzU1ZjUzMjAyYTU3YQ==", "commit": {"author": {"name": "Peter Gerwinski", "email": "peter@gerwinski.de", "date": "1999-10-28T11:39:31Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-10-28T11:39:31Z"}, "message": "* tree.def (PLACEHOLDER_EXPR): Update comments.\n\nFrom-SVN: r30241", "tree": {"sha": "b431f8f8e76df45e15f2340aa37c59793829a2e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b431f8f8e76df45e15f2340aa37c59793829a2e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a7b629279cd9750761e9be507d755f53202a57a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a7b629279cd9750761e9be507d755f53202a57a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a7b629279cd9750761e9be507d755f53202a57a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a7b629279cd9750761e9be507d755f53202a57a/comments", "author": null, "committer": null, "parents": [{"sha": "301452153700ff8c81d28e58a9e10117655b6a00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/301452153700ff8c81d28e58a9e10117655b6a00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/301452153700ff8c81d28e58a9e10117655b6a00"}], "stats": {"total": 73, "additions": 43, "deletions": 30}, "files": [{"sha": "f8ac9886d4afd4f6bdf07a0e84fc88497bd4a0c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7b629279cd9750761e9be507d755f53202a57a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7b629279cd9750761e9be507d755f53202a57a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a7b629279cd9750761e9be507d755f53202a57a", "patch": "@@ -1,3 +1,7 @@\n+Thu Oct 28 03:37:50 1999  Peter Gerwinski <peter@gerwinski.de>\n+\n+\t* tree.def (PLACEHOLDER_EXPR): Update comments.\n+\n Thu Oct 28 06:47:32 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* c-common.c (check_format_info): Avoid non-literal format string"}, {"sha": "9ccc3c579dff4c24e0f517c72ff0f85e0eaac973", "filename": "gcc/tree.def", "status": "modified", "additions": 39, "deletions": 30, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a7b629279cd9750761e9be507d755f53202a57a/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a7b629279cd9750761e9be507d755f53202a57a/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=2a7b629279cd9750761e9be507d755f53202a57a", "patch": "@@ -490,39 +490,48 @@ DEFTREECODE (WITH_CLEANUP_EXPR, \"with_cleanup_expr\", 'e', 3)\n DEFTREECODE (CLEANUP_POINT_EXPR, \"cleanup_point_expr\", 'e', 1)\n \n /* The following two codes are used in languages that have types where\n-   the position and/or sizes of fields vary from object to object of the\n-   same type, i.e., where some other field in the object contains a value\n-   that is used in the computation of another field's offset or size.\n-\n-   For example, a record type with a discriminant in Ada is such a type.\n-   This mechanism is also used to create \"fat pointers\" for unconstrained\n-   array types in Ada; the fat pointer is a structure one of whose fields is\n-   a pointer to the actual array type and the other field is a pointer to a\n-   template, which is a structure containing the bounds of the array.  The\n-   bounds in the type pointed to by the first field in the fat pointer refer\n-   to the values in the template.\n-\n-   These \"self-references\" are doing using a PLACEHOLDER_EXPR.  This is a\n-   node that will later be replaced with the object being referenced.  Its type\n-   is that of the object and selects which object to use from a chain of\n-   references (see below).\n-\n-   When we wish to evaluate a size or offset, we check it is contains a\n-   placeholder.  If it does, we construct a WITH_RECORD_EXPR that contains\n-   both the expression we wish to evaluate and an expression within which the\n-   object may be found.  The latter expression is the object itself in\n-   the simple case of an Ada record with discriminant, but it can be the\n-   array in the case of an unconstrained array.\n-\n-   In the latter case, we need the fat pointer, because the bounds of the\n-   array can only be accessed from it.  However, we rely here on the fact that\n-   the expression for the array contains the dereference of the fat pointer\n-   that obtained the array pointer.\n+   some field in an object of the type contains a value that is used in\n+   the computation of another field's offset or size and/or the size of\n+   the type.  The positions and/or sizes of fields can vary from object\n+   to object of the same type.\n+\n+   Record types with discriminants in Ada or schema types in Pascal are\n+   examples of such types.  This mechanism is also used to create \"fat\n+   pointers\" for unconstrained array types in Ada; the fat pointer is a\n+   structure one of whose fields is a pointer to the actual array type\n+   and the other field is a pointer to a template, which is a structure\n+   containing the bounds of the array.  The bounds in the type pointed\n+   to by the first field in the fat pointer refer to the values in the\n+   template.\n+\n+   When you wish to construct such a type you need \"self-references\"\n+   that allow you to reference the object having this type from the\n+   TYPE node, i.e. without having a variable instantiating this type.\n+\n+   Such a \"self-references\" is done using a PLACEHOLDER_EXPR.  This is\n+   a node that will later be replaced with the object being referenced.\n+   Its type is that of the object and selects which object to use from\n+   a chain of references (see below).  No other slots are used in the\n+   PLACEHOLDER_EXPR.\n+\n+   For example, if your type FOO is a RECORD_TYPE with a field BAR,\n+   and you need the value of <variable>.BAR to calculate TYPE_SIZE\n+   (FOO), just substitute <variable> above with a PLACEHOLDER_EXPR\n+   what contains both the expression we wish to\n+   evaluate and an expression within which the object may be found.\n+   The latter expression is the object itself in the simple case of an\n+   Ada record with discriminant, but it can be the array in the case of\n+   an unconstrained array.\n+\n+   In the latter case, we need the fat pointer, because the bounds of\n+   the array can only be accessed from it.  However, we rely here on the\n+   fact that the expression for the array contains the dereference of\n+   the fat pointer that obtained the array pointer.\n \n    Accordingly, when looking for the object to substitute in place of\n    a PLACEHOLDER_EXPR, we look down the first operand of the expression\n-   passed as the second operand to WITH_RECORD_EXPR until we find something\n-   of the desired type or reach a constant.  */\n+   passed as the second operand to WITH_RECORD_EXPR until we find\n+   something of the desired type or reach a constant.  */\n \n /* Denotes a record to later be supplied with a WITH_RECORD_EXPR when\n    evaluating this expression.  The type of this expression is used to"}]}