{"sha": "f5655e4a9433c8a865b36eb098fb2315d7621855", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjU2NTVlNGE5NDMzYzhhODY1YjM2ZWIwOThmYjIzMTVkNzYyMTg1NQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-04T07:54:00Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-04T07:54:00Z"}, "message": "[multiple changes]\n\n2014-08-04  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_aggr.adb (Expand_Array_Aggregate): Do not attempt expansion\n\tif error already detected.  We may reach this point in spite of\n\tprevious errors when compiling with -gnatq, to force all possible\n\terrors (this is the usual ACATS mode).\n\n2014-08-04  Gary Dismukes  <dismukes@adacore.com>\n\n\t* checks.adb (Generate_Range_Check): For the case of converting\n\ta base type with a larger range to a smaller target subtype, only\n\tuse unchecked conversions of bounds in the range check followed\n\tby conversion in the case where both types are discrete. In other\n\tcases, convert to the target base type and save in a temporary\n\tfollowed by the range check.\n\t(Convert_And_Check_Range): New procedure factoring code to save\n\tconversion to a temporary followed by a range check (called two\n\tplaces in Generate_Range_Check).\n\t* exp_ch4.adb (Expand_N_Type_Conversion): Relax previous\n\tcheck-in, to generate range checks for conversions between\n\tany floating-point types rather than limiting it to matching\n\tbase types.\n\nFrom-SVN: r213532", "tree": {"sha": "91119788af8e584b9632c7a81a99301a7bf9abab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91119788af8e584b9632c7a81a99301a7bf9abab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5655e4a9433c8a865b36eb098fb2315d7621855", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5655e4a9433c8a865b36eb098fb2315d7621855", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5655e4a9433c8a865b36eb098fb2315d7621855", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5655e4a9433c8a865b36eb098fb2315d7621855/comments", "author": null, "committer": null, "parents": [{"sha": "52627911786069aabae42e6393f536ae288adf6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52627911786069aabae42e6393f536ae288adf6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52627911786069aabae42e6393f536ae288adf6d"}], "stats": {"total": 210, "additions": 135, "deletions": 75}, "files": [{"sha": "bcbe25ddf74790b55e0197e74442ac6c15f0e481", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5655e4a9433c8a865b36eb098fb2315d7621855/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5655e4a9433c8a865b36eb098fb2315d7621855/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f5655e4a9433c8a865b36eb098fb2315d7621855", "patch": "@@ -1,3 +1,30 @@\n+2014-08-04  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* g-trasym-vms-ia64.adb, g-trasym-vms-alpha.adb: Removed.\n+\n+2014-08-04  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_aggr.adb (Expand_Array_Aggregate): Do not attempt expansion\n+\tif error already detected.  We may reach this point in spite of\n+\tprevious errors when compiling with -gnatq, to force all possible\n+\terrors (this is the usual ACATS mode).\n+\n+2014-08-04  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* checks.adb (Generate_Range_Check): For the case of converting\n+\ta base type with a larger range to a smaller target subtype, only\n+\tuse unchecked conversions of bounds in the range check followed\n+\tby conversion in the case where both types are discrete. In other\n+\tcases, convert to the target base type and save in a temporary\n+\tfollowed by the range check.\n+\t(Convert_And_Check_Range): New procedure factoring code to save\n+\tconversion to a temporary followed by a range check (called two\n+\tplaces in Generate_Range_Check).\n+\t* exp_ch4.adb (Expand_N_Type_Conversion): Relax previous\n+\tcheck-in, to generate range checks for conversions between\n+\tany floating-point types rather than limiting it to matching\n+\tbase types.\n+\n 2014-08-02  Trevor Saunders  <tsaunders@mozilla.com>\n \n \t* gcc-interface/trans.c: Use hash_set instead of pointer_set."}, {"sha": "bab3ba7eb0a03a4d2a7dd112d7e0a369c5b00969", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 91, "deletions": 67, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5655e4a9433c8a865b36eb098fb2315d7621855/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5655e4a9433c8a865b36eb098fb2315d7621855/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=f5655e4a9433c8a865b36eb098fb2315d7621855", "patch": "@@ -6402,6 +6402,59 @@ package body Checks is\n       Source_Base_Type : constant Entity_Id  := Base_Type (Source_Type);\n       Target_Base_Type : constant Entity_Id  := Base_Type (Target_Type);\n \n+      procedure Convert_And_Check_Range;\n+      --  Convert the conversion operand to the target base type and save in\n+      --  a temporary. Then check the converted value against the range of the\n+      --  target subtype.\n+\n+      procedure Convert_And_Check_Range is\n+         --  To what does the following comment belong???\n+         --  We make a temporary to hold the value of the converted value\n+         --  (converted to the base type), and then we will do the test against\n+         --  this temporary.\n+         --\n+         --     Tnn : constant Target_Base_Type := Target_Base_Type (N);\n+         --     [constraint_error when Tnn not in Target_Type]\n+         --\n+         --  The conversion itself is replaced by an occurrence of Tnn\n+\n+         Tnn : constant Entity_Id := Make_Temporary (Loc, 'T', N);\n+\n+         --  To what does the following comment belong???\n+         --  Follow the conversion with the explicit range check. Note that we\n+         --  suppress checks for this code, since we don't want a recursive\n+         --  range check popping up.\n+\n+      begin\n+         Insert_Actions (N, New_List (\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Tnn,\n+             Object_Definition   => New_Occurrence_Of (Target_Base_Type, Loc),\n+             Constant_Present    => True,\n+             Expression          =>\n+               Make_Type_Conversion (Loc,\n+                 Subtype_Mark => New_Occurrence_Of (Target_Base_Type, Loc),\n+                 Expression   => Duplicate_Subexpr (N))),\n+\n+           Make_Raise_Constraint_Error (Loc,\n+             Condition =>\n+               Make_Not_In (Loc,\n+                 Left_Opnd  => New_Occurrence_Of (Tnn, Loc),\n+                 Right_Opnd => New_Occurrence_Of (Target_Type, Loc)),\n+             Reason => Reason)),\n+           Suppress => All_Checks);\n+\n+         Rewrite (N, New_Occurrence_Of (Tnn, Loc));\n+\n+         --  Set the type of N, because the declaration for Tnn might not\n+         --  be analyzed yet, as is the case if N appears within a record\n+         --  declaration, as a discriminant constraint or expression.\n+\n+         Set_Etype (N, Target_Base_Type);\n+      end Convert_And_Check_Range;\n+\n+   --  Start of processing for Generate_Range_Check\n+\n    begin\n       --  First special case, if the source type is already within the range\n       --  of the target type, then no check is needed (probably we should have\n@@ -6500,29 +6553,44 @@ package body Checks is\n          --  Insert the explicit range check. Note that we suppress checks for\n          --  this code, since we don't want a recursive range check popping up.\n \n-         Insert_Action (N,\n-           Make_Raise_Constraint_Error (Loc,\n-             Condition =>\n-               Make_Not_In (Loc,\n-                 Left_Opnd  => Duplicate_Subexpr (N),\n+         if Is_Discrete_Type (Source_Base_Type)\n+              and then\n+            Is_Discrete_Type (Target_Base_Type)\n+         then\n+            Insert_Action (N,\n+              Make_Raise_Constraint_Error (Loc,\n+                Condition =>\n+                  Make_Not_In (Loc,\n+                    Left_Opnd  => Duplicate_Subexpr (N),\n \n-                 Right_Opnd =>\n-                   Make_Range (Loc,\n-                     Low_Bound =>\n-                       Unchecked_Convert_To (Source_Base_Type,\n-                         Make_Attribute_Reference (Loc,\n-                           Prefix =>\n-                             New_Occurrence_Of (Target_Type, Loc),\n-                           Attribute_Name => Name_First)),\n-\n-                     High_Bound =>\n-                       Unchecked_Convert_To (Source_Base_Type,\n-                         Make_Attribute_Reference (Loc,\n-                           Prefix =>\n-                             New_Occurrence_Of (Target_Type, Loc),\n-                           Attribute_Name => Name_Last)))),\n-             Reason => Reason),\n-           Suppress => All_Checks);\n+                    Right_Opnd =>\n+                      Make_Range (Loc,\n+                        Low_Bound  =>\n+                          Unchecked_Convert_To (Source_Base_Type,\n+                            Make_Attribute_Reference (Loc,\n+                              Prefix         =>\n+                                New_Occurrence_Of (Target_Type, Loc),\n+                              Attribute_Name => Name_First)),\n+\n+                        High_Bound =>\n+                          Unchecked_Convert_To (Source_Base_Type,\n+                            Make_Attribute_Reference (Loc,\n+                              Prefix         =>\n+                                New_Occurrence_Of (Target_Type, Loc),\n+                              Attribute_Name => Name_Last)))),\n+                Reason    => Reason),\n+              Suppress => All_Checks);\n+\n+         --  For conversions involving at least one type that is not discrete,\n+         --  first convert to target type and then generate the range check.\n+         --  This avoids problems with values that are close to a bound of the\n+         --  target type that would fail a range check when done in a larger\n+         --  source type before converting but would pass if converted with\n+         --  rounding and then checked (such as in float-to-float conversions).\n+\n+         else\n+            Convert_And_Check_Range;\n+         end if;\n \n       --  Note that at this stage we now that the Target_Base_Type is not in\n       --  the range of the Source_Base_Type (since even the Target_Type itself\n@@ -6533,51 +6601,7 @@ package body Checks is\n       --  and then test the target result against the bounds.\n \n       elsif In_Subrange_Of (Source_Type, Target_Base_Type) then\n-\n-         --  We make a temporary to hold the value of the converted value\n-         --  (converted to the base type), and then we will do the test against\n-         --  this temporary.\n-\n-         --     Tnn : constant Target_Base_Type := Target_Base_Type (N);\n-         --     [constraint_error when Tnn not in Target_Type]\n-\n-         --  Then the conversion itself is replaced by an occurrence of Tnn\n-\n-         --  Insert the explicit range check. Note that we suppress checks for\n-         --  this code, since we don't want a recursive range check popping up.\n-\n-         declare\n-            Tnn : constant Entity_Id := Make_Temporary (Loc, 'T', N);\n-\n-         begin\n-            Insert_Actions (N, New_List (\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Tnn,\n-                Object_Definition   =>\n-                  New_Occurrence_Of (Target_Base_Type, Loc),\n-                Constant_Present    => True,\n-                Expression          =>\n-                  Make_Type_Conversion (Loc,\n-                    Subtype_Mark => New_Occurrence_Of (Target_Base_Type, Loc),\n-                    Expression   => Duplicate_Subexpr (N))),\n-\n-              Make_Raise_Constraint_Error (Loc,\n-                Condition =>\n-                  Make_Not_In (Loc,\n-                    Left_Opnd  => New_Occurrence_Of (Tnn, Loc),\n-                    Right_Opnd => New_Occurrence_Of (Target_Type, Loc)),\n-\n-                Reason => Reason)),\n-              Suppress => All_Checks);\n-\n-            Rewrite (N, New_Occurrence_Of (Tnn, Loc));\n-\n-            --  Set the type of N, because the declaration for Tnn might not\n-            --  be analyzed yet, as is the case if N appears within a record\n-            --  declaration, as a discriminant constraint or expression.\n-\n-            Set_Etype (N, Target_Base_Type);\n-         end;\n+         Convert_And_Check_Range;\n \n       --  At this stage, we know that we have two scalar types, which are\n       --  directly convertible, and where neither scalar type has a base"}, {"sha": "60838de36740ad0d343290ddd9e12537be217295", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5655e4a9433c8a865b36eb098fb2315d7621855/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5655e4a9433c8a865b36eb098fb2315d7621855/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=f5655e4a9433c8a865b36eb098fb2315d7621855", "patch": "@@ -5013,6 +5013,13 @@ package body Exp_Aggr is\n                    (Return_Applies_To (Return_Statement_Entity (Parent (N))))\n       then\n          return;\n+\n+      --  Do not attempt expansion if error already detected. We may reach this\n+      --  point in spite of previous errors when compiling with -gnatq, to\n+      --  force all possible errors (this is the usual ACATS mode).\n+\n+      elsif Error_Posted (N) then\n+         return;\n       end if;\n \n       --  If the semantic analyzer has determined that aggregate N will raise"}, {"sha": "7123389b813e3a4f5e4f67a0e86bef222b22f832", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5655e4a9433c8a865b36eb098fb2315d7621855/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5655e4a9433c8a865b36eb098fb2315d7621855/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=f5655e4a9433c8a865b36eb098fb2315d7621855", "patch": "@@ -10844,19 +10844,19 @@ package body Exp_Ch4 is\n \n       --  The only remaining step is to generate a range check if we still have\n       --  a type conversion at this stage and Do_Range_Check is set. For now we\n-      --  do this only for conversions of discrete types and for floating-point\n-      --  conversions where the base types of source and target are the same.\n+      --  do this only for conversions of discrete types and for float-to-float\n+      --  conversions.\n \n       if Nkind (N) = N_Type_Conversion then\n \n-         --  For now we only support floating-point cases where the base types\n-         --  of the target type and source expression are the same, so there's\n-         --  potentially only a range check. Conversions where the source and\n-         --  target have different base types are still TBD. ???\n+         --  For now we only support floating-point cases where both source\n+         --  and target are floating-point types. Conversions where the source\n+         --  and target involve integer or fixed-point types are still TBD,\n+         --  though not clear whether those can even happen at this point, due\n+         --  to transformations above. ???\n \n          if Is_Floating_Point_Type (Etype (N))\n-           and then\n-             Base_Type (Etype (N)) = Base_Type (Etype (Expression (N)))\n+           and then Is_Floating_Point_Type (Etype (Expression (N)))\n          then\n             if Do_Range_Check (Expression (N))\n               and then Is_Floating_Point_Type (Target_Type)\n@@ -10865,6 +10865,8 @@ package body Exp_Ch4 is\n                  (Expression (N), Target_Type, CE_Range_Check_Failed);\n             end if;\n \n+         --  Discrete-to-discrete conversions\n+\n          elsif Is_Discrete_Type (Etype (N)) then\n             declare\n                Expr : constant Node_Id := Expression (N);"}]}