{"sha": "6a27c430468cb85454b19cef881a1422580657ff", "node_id": "C_kwDOANBUbNoAKDZhMjdjNDMwNDY4Y2I4NTQ1NGIxOWNlZjg4MWExNDIyNTgwNjU3ZmY", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-06-16T08:58:58Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-06-16T09:00:59Z"}, "message": "expand: Fix up IFN_ATOMIC_{BIT*,*CMP_0} expansion [PR105951]\n\nBoth IFN_ATOMIC_BIT_TEST_AND_* and IFN_ATOMIC_*_FETCH_CMP_0 ifns\nare matched if their corresponding optab is implemented for the particular\nmode.  The fact that those optabs are implemented doesn't guarantee\nthey will succeed though, they can just FAIL in their expansion.\nThe expansion in that case uses expand_atomic_fetch_op as fallback, but\nas has been reported and and can be reproduced on the testcases,\neven those can fail and we didn't have any fallback after that.\nFor IFN_ATOMIC_BIT_TEST_AND_* we actually have such calls.  One is\ndone whenever we lost lhs of the ifn at some point in between matching\nit in tree-ssa-ccp.cc and expansion.  The following patch for that case\njust falls through and expands as if there was a lhs, creates a temporary\nfor it.  For the other expand_atomic_fetch_op call in the same expander\nand for the only expand_atomic_fetch_op call in the other, this falls\nback the hard way, by constructing a CALL_EXPR to the call from which\nthe ifn has been matched and expanding that.  Either it is lucky and manages\nto expand inline, or it emits a libatomic API call.\nSo that we don't have to rediscover which builtin function to call in the\nfallback, we record at tree-ssa-ccp.cc time gimple_call_fn (call) in\nan extra argument to the ifn.\n\n2022-06-16  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR middle-end/105951\n\t* tree-ssa-ccp.cc (optimize_atomic_bit_test_and,\n\toptimize_atomic_op_fetch_cmp_0): Remember gimple_call_fn (call)\n\tas last argument to the internal functions.\n\t* builtins.cc (expand_ifn_atomic_bit_test_and): Adjust for the\n\textra call argument to ifns.  If expand_atomic_fetch_op fails for the\n\tlhs == NULL_TREE case, fall through into the optab code with\n\tgen_reg_rtx (mode) as target.  If second expand_atomic_fetch_op\n\tfails, construct a CALL_EXPR and expand that.\n\t(expand_ifn_atomic_op_fetch_cmp_0): Adjust for the extra call argument\n\tto ifns.  If expand_atomic_fetch_op fails, construct a CALL_EXPR and\n\texpand that.\n\n\t* gcc.target/i386/pr105951-1.c: New test.\n\t* gcc.target/i386/pr105951-2.c: New test.", "tree": {"sha": "6c0c250b690811c859325f460a8c877ae6a6a5d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c0c250b690811c859325f460a8c877ae6a6a5d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a27c430468cb85454b19cef881a1422580657ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a27c430468cb85454b19cef881a1422580657ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a27c430468cb85454b19cef881a1422580657ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a27c430468cb85454b19cef881a1422580657ff/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d1c6e7038b0c281ac2678f2f615806a7aac9174", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d1c6e7038b0c281ac2678f2f615806a7aac9174", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d1c6e7038b0c281ac2678f2f615806a7aac9174"}], "stats": {"total": 80, "additions": 64, "deletions": 16}, "files": [{"sha": "971b18c374592bb60dec9feee21d44f4d1a1ebc4", "filename": "gcc/builtins.cc", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a27c430468cb85454b19cef881a1422580657ff/gcc%2Fbuiltins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a27c430468cb85454b19cef881a1422580657ff/gcc%2Fbuiltins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.cc?ref=6a27c430468cb85454b19cef881a1422580657ff", "patch": "@@ -6224,7 +6224,7 @@ expand_ifn_atomic_bit_test_and (gcall *call)\n \n   gcc_assert (flag_inline_atomics);\n \n-  if (gimple_call_num_args (call) == 4)\n+  if (gimple_call_num_args (call) == 5)\n     model = get_memmodel (gimple_call_arg (call, 3));\n \n   rtx mem = get_builtin_sync_mem (ptr, mode);\n@@ -6250,15 +6250,19 @@ expand_ifn_atomic_bit_test_and (gcall *call)\n \n   if (lhs == NULL_TREE)\n     {\n-      val = expand_simple_binop (mode, ASHIFT, const1_rtx,\n-\t\t\t\t val, NULL_RTX, true, OPTAB_DIRECT);\n+      rtx val2 = expand_simple_binop (mode, ASHIFT, const1_rtx,\n+\t\t\t\t      val, NULL_RTX, true, OPTAB_DIRECT);\n       if (code == AND)\n-\tval = expand_simple_unop (mode, NOT, val, NULL_RTX, true);\n-      expand_atomic_fetch_op (const0_rtx, mem, val, code, model, false);\n-      return;\n+\tval2 = expand_simple_unop (mode, NOT, val2, NULL_RTX, true);\n+      if (expand_atomic_fetch_op (const0_rtx, mem, val2, code, model, false))\n+\treturn;\n     }\n \n-  rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+  rtx target;\n+  if (lhs)\n+    target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+  else\n+    target = gen_reg_rtx (mode);\n   enum insn_code icode = direct_optab_handler (optab, mode);\n   gcc_assert (icode != CODE_FOR_nothing);\n   create_output_operand (&ops[0], target, mode);\n@@ -6277,6 +6281,22 @@ expand_ifn_atomic_bit_test_and (gcall *call)\n     val = expand_simple_unop (mode, NOT, val, NULL_RTX, true);\n   rtx result = expand_atomic_fetch_op (gen_reg_rtx (mode), mem, val,\n \t\t\t\t       code, model, false);\n+  if (!result)\n+    {\n+      bool is_atomic = gimple_call_num_args (call) == 5;\n+      tree tcall = gimple_call_arg (call, 3 + is_atomic);\n+      tree fndecl = gimple_call_addr_fndecl (tcall);\n+      tree type = TREE_TYPE (TREE_TYPE (fndecl));\n+      tree exp = build_call_nary (type, tcall, 2 + is_atomic, ptr,\n+\t\t\t\t  make_tree (type, val),\n+\t\t\t\t  is_atomic\n+\t\t\t\t  ? gimple_call_arg (call, 3)\n+\t\t\t\t  : integer_zero_node);\n+      result = expand_builtin (exp, gen_reg_rtx (mode), NULL_RTX,\n+\t\t\t       mode, !lhs);\n+    }\n+  if (!lhs)\n+    return;\n   if (integer_onep (flag))\n     {\n       result = expand_simple_binop (mode, ASHIFTRT, result, bitval,\n@@ -6308,7 +6328,7 @@ expand_ifn_atomic_op_fetch_cmp_0 (gcall *call)\n \n   gcc_assert (flag_inline_atomics);\n \n-  if (gimple_call_num_args (call) == 4)\n+  if (gimple_call_num_args (call) == 5)\n     model = get_memmodel (gimple_call_arg (call, 3));\n \n   rtx mem = get_builtin_sync_mem (ptr, mode);\n@@ -6369,6 +6389,21 @@ expand_ifn_atomic_op_fetch_cmp_0 (gcall *call)\n \n   rtx result = expand_atomic_fetch_op (gen_reg_rtx (mode), mem, op,\n \t\t\t\t       code, model, true);\n+  if (!result)\n+    {\n+      bool is_atomic = gimple_call_num_args (call) == 5;\n+      tree tcall = gimple_call_arg (call, 3 + is_atomic);\n+      tree fndecl = gimple_call_addr_fndecl (tcall);\n+      tree type = TREE_TYPE (TREE_TYPE (fndecl));\n+      tree exp = build_call_nary (type, tcall,\n+\t\t\t\t  2 + is_atomic, ptr, arg,\n+\t\t\t\t  is_atomic\n+\t\t\t\t  ? gimple_call_arg (call, 3)\n+\t\t\t\t  : integer_zero_node);\n+      result = expand_builtin (exp, gen_reg_rtx (mode), NULL_RTX,\n+\t\t\t       mode, !lhs);\n+    }\n+\n   if (lhs)\n     {\n       result = emit_store_flag_force (target, comp, result, const0_rtx, mode,"}, {"sha": "ff1c1db133ae585edbbe6c1932dacd5b01b9a55a", "filename": "gcc/testsuite/gcc.target/i386/pr105951-1.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a27c430468cb85454b19cef881a1422580657ff/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr105951-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a27c430468cb85454b19cef881a1422580657ff/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr105951-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr105951-1.c?ref=6a27c430468cb85454b19cef881a1422580657ff", "patch": "@@ -0,0 +1,5 @@\n+/* PR middle-end/105951 */\n+/* { dg-do compile { target ia32 } } */\n+/* { dg-options \"-O2 -march=i386\" } */\n+\n+#include \"pr98737-2.c\""}, {"sha": "fed77f795e00b9ec92c9ab736cfa52467a27208d", "filename": "gcc/testsuite/gcc.target/i386/pr105951-2.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a27c430468cb85454b19cef881a1422580657ff/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr105951-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a27c430468cb85454b19cef881a1422580657ff/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr105951-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr105951-2.c?ref=6a27c430468cb85454b19cef881a1422580657ff", "patch": "@@ -0,0 +1,5 @@\n+/* PR middle-end/105951 */\n+/* { dg-do compile { target ia32 } } */\n+/* { dg-options \"-O2 -march=i386\" } */\n+\n+#include \"pr98737-4.c\""}, {"sha": "58e0face2e7773e88c3b6d53f2209ea193b615a7", "filename": "gcc/tree-ssa-ccp.cc", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a27c430468cb85454b19cef881a1422580657ff/gcc%2Ftree-ssa-ccp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a27c430468cb85454b19cef881a1422580657ff/gcc%2Ftree-ssa-ccp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.cc?ref=6a27c430468cb85454b19cef881a1422580657ff", "patch": "@@ -3789,11 +3789,12 @@ optimize_atomic_bit_test_and (gimple_stmt_iterator *gsip,\n   tree new_lhs = make_ssa_name (TREE_TYPE (lhs));\n   tree flag = build_int_cst (TREE_TYPE (lhs), use_bool);\n   if (has_model_arg)\n-    g = gimple_build_call_internal (fn, 4, gimple_call_arg (call, 0),\n-\t\t\t\t    bit, flag, gimple_call_arg (call, 2));\n+    g = gimple_build_call_internal (fn, 5, gimple_call_arg (call, 0),\n+\t\t\t\t    bit, flag, gimple_call_arg (call, 2),\n+\t\t\t\t    gimple_call_fn (call));\n   else\n-    g = gimple_build_call_internal (fn, 3, gimple_call_arg (call, 0),\n-\t\t\t\t    bit, flag);\n+    g = gimple_build_call_internal (fn, 4, gimple_call_arg (call, 0),\n+\t\t\t\t    bit, flag, gimple_call_fn (call));\n   gimple_call_set_lhs (g, new_lhs);\n   gimple_set_location (g, gimple_location (call));\n   gimple_move_vops (g, call);\n@@ -4003,14 +4004,16 @@ optimize_atomic_op_fetch_cmp_0 (gimple_stmt_iterator *gsip,\n   gimple *g;\n   tree flag = build_int_cst (TREE_TYPE (lhs), encoded);\n   if (has_model_arg)\n-    g = gimple_build_call_internal (fn, 4, flag,\n+    g = gimple_build_call_internal (fn, 5, flag,\n \t\t\t\t    gimple_call_arg (call, 0),\n \t\t\t\t    gimple_call_arg (call, 1),\n-\t\t\t\t    gimple_call_arg (call, 2));\n+\t\t\t\t    gimple_call_arg (call, 2),\n+\t\t\t\t    gimple_call_fn (call));\n   else\n-    g = gimple_build_call_internal (fn, 3, flag,\n+    g = gimple_build_call_internal (fn, 4, flag,\n \t\t\t\t    gimple_call_arg (call, 0),\n-\t\t\t\t    gimple_call_arg (call, 1));\n+\t\t\t\t    gimple_call_arg (call, 1),\n+\t\t\t\t    gimple_call_fn (call));\n   gimple_call_set_lhs (g, new_lhs);\n   gimple_set_location (g, gimple_location (call));\n   gimple_move_vops (g, call);"}]}