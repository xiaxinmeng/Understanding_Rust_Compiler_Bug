{"sha": "efac62a3d17d534e8fec39a53031689efb0dc724", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWZhYzYyYTNkMTdkNTM0ZThmZWMzOWE1MzAzMTY4OWVmYjBkYzcyNA==", "commit": {"author": {"name": "Sam Tebbs", "email": "sam.tebbs@arm.com", "date": "2019-01-08T10:31:11Z"}, "committer": {"name": "Sam Tebbs", "email": "samtebbs@gcc.gnu.org", "date": "2019-01-08T10:31:11Z"}, "message": "[PATCH 2/3][GCC][AARCH64] Add new -mbranch-protection option to combine pointer signing and BTI\n\ngcc/ChangeLog:\n\n2019-01-08  Sam Tebbs  <sam.tebbs@arm.com>\n\n\t* config/aarch64/aarch64.c (BRANCH_PROTECT_STR_MAX,\n\taarch64_parse_branch_protection,\n\tstruct aarch64_branch_protect_type,\n\taarch64_handle_no_branch_protection,\n\taarch64_handle_standard_branch_protection,\n\taarch64_validate_mbranch_protection,\n\taarch64_handle_pac_ret_protection,\n\taarch64_handle_attr_branch_protection,\n\taccepted_branch_protection_string,\n\taarch64_pac_ret_subtypes,\n\taarch64_branch_protect_types,\n\taarch64_handle_pac_ret_leaf): Define.\n\t(aarch64_override_options_after_change_1, aarch64_override_options):\n\tAdd check for accepted_branch_protection_string.\n\t(aarch64_option_save): Save accepted_branch_protection_string.\n\t(aarch64_option_restore): Save accepted_branch_protection_string.\n\t* config/aarch64/aarch64.c (aarch64_attributes): Add branch-protection.\n\t* config/aarch64/aarch64.opt: Add mbranch-protection. Deprecate\n\tmsign-return-address.\n\t* doc/invoke.texi: Add mbranch-protection.\n\ngcc/testsuite/Changelog:\n\n2019-01-08  Sam Tebbs  <sam.tebbs@arm.com>\n\n\t* gcc.target/aarch64/(return_address_sign_1.c,\n\treturn_address_sign_2.c, return_address_sign_3.c (__attribute__)):\n\tChange option to -mbranch-protection.\n\t* gcc.target/aarch64/(branch-protection-option.c,\n\tbranch-protection-option-2.c, branch-protection-attr.c,\n\tbranch-protection-attr-2.c): New file.\n\nFrom-SVN: r267717", "tree": {"sha": "ad35cab19dbd793ab596cc3677d2357b029e01c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad35cab19dbd793ab596cc3677d2357b029e01c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/efac62a3d17d534e8fec39a53031689efb0dc724", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efac62a3d17d534e8fec39a53031689efb0dc724", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efac62a3d17d534e8fec39a53031689efb0dc724", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efac62a3d17d534e8fec39a53031689efb0dc724/comments", "author": null, "committer": null, "parents": [{"sha": "35724e51548e17ed4af8bed121f9b89a603ff0e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35724e51548e17ed4af8bed121f9b89a603ff0e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35724e51548e17ed4af8bed121f9b89a603ff0e7"}], "stats": {"total": 350, "additions": 343, "deletions": 7}, "files": [{"sha": "95208f3f058353bbad843770b62301d212d522de", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efac62a3d17d534e8fec39a53031689efb0dc724/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efac62a3d17d534e8fec39a53031689efb0dc724/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=efac62a3d17d534e8fec39a53031689efb0dc724", "patch": "@@ -1,3 +1,26 @@\n+2019-01-08  Sam Tebbs  <sam.tebbs@arm.com>\n+\n+\t* config/aarch64/aarch64.c (BRANCH_PROTECT_STR_MAX,\n+\taarch64_parse_branch_protection,\n+\tstruct aarch64_branch_protect_type,\n+\taarch64_handle_no_branch_protection,\n+\taarch64_handle_standard_branch_protection,\n+\taarch64_validate_mbranch_protection,\n+\taarch64_handle_pac_ret_protection,\n+\taarch64_handle_attr_branch_protection,\n+\taccepted_branch_protection_string,\n+\taarch64_pac_ret_subtypes,\n+\taarch64_branch_protect_types,\n+\taarch64_handle_pac_ret_leaf): Define.\n+\t(aarch64_override_options_after_change_1, aarch64_override_options):\n+\tAdd check for accepted_branch_protection_string.\n+\t(aarch64_option_save): Save accepted_branch_protection_string.\n+\t(aarch64_option_restore): Save accepted_branch_protection_string.\n+\t* config/aarch64/aarch64.c (aarch64_attributes): Add branch-protection.\n+\t* config/aarch64/aarch64.opt: Add mbranch-protection. Deprecate\n+\tmsign-return-address.\n+\t* doc/invoke.texi: Add mbranch-protection.\n+\n 2019-01-08  Alan Modra  <amodra@gmail.com>\n \n \tPR target/88614"}, {"sha": "1c452430810adf87386849ab53be4cc12958b065", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efac62a3d17d534e8fec39a53031689efb0dc724/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efac62a3d17d534e8fec39a53031689efb0dc724/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=efac62a3d17d534e8fec39a53031689efb0dc724", "patch": "@@ -183,6 +183,12 @@ bool aarch64_pcrelative_literal_loads;\n /* Global flag for whether frame pointer is enabled.  */\n bool aarch64_use_frame_pointer;\n \n+#define BRANCH_PROTECT_STR_MAX 255\n+char *accepted_branch_protection_string = NULL;\n+\n+static enum aarch64_parse_opt_result\n+aarch64_parse_branch_protection (const char*, char**);\n+\n /* Support for command line parsing of boolean flags in the tuning\n    structures.  */\n struct aarch64_flag_desc\n@@ -1170,6 +1176,79 @@ aarch64_cc;\n \n #define AARCH64_INVERSE_CONDITION_CODE(X) ((aarch64_cc) (((int) X) ^ 1))\n \n+struct aarch64_branch_protect_type\n+{\n+  /* The type's name that the user passes to the branch-protection option\n+    string.  */\n+  const char* name;\n+  /* Function to handle the protection type and set global variables.\n+    First argument is the string token corresponding with this type and the\n+    second argument is the next token in the option string.\n+    Return values:\n+    * AARCH64_PARSE_OK: Handling was sucessful.\n+    * AARCH64_INVALID_ARG: The type is invalid in this context and the caller\n+      should print an error.\n+    * AARCH64_INVALID_FEATURE: The type is invalid and the handler prints its\n+      own error.  */\n+  enum aarch64_parse_opt_result (*handler)(char*, char*);\n+  /* A list of types that can follow this type in the option string.  */\n+  const aarch64_branch_protect_type* subtypes;\n+  unsigned int num_subtypes;\n+};\n+\n+static enum aarch64_parse_opt_result\n+aarch64_handle_no_branch_protection (char* str, char* rest)\n+{\n+  aarch64_ra_sign_scope = AARCH64_FUNCTION_NONE;\n+  if (rest)\n+    {\n+      error (\"unexpected %<%s%> after %<%s%>\", rest, str);\n+      return AARCH64_PARSE_INVALID_FEATURE;\n+    }\n+  return AARCH64_PARSE_OK;\n+}\n+\n+static enum aarch64_parse_opt_result\n+aarch64_handle_standard_branch_protection (char* str, char* rest)\n+{\n+  aarch64_ra_sign_scope = AARCH64_FUNCTION_NON_LEAF;\n+  if (rest)\n+    {\n+      error (\"unexpected %<%s%> after %<%s%>\", rest, str);\n+      return AARCH64_PARSE_INVALID_FEATURE;\n+    }\n+  return AARCH64_PARSE_OK;\n+}\n+\n+static enum aarch64_parse_opt_result\n+aarch64_handle_pac_ret_protection (char* str ATTRIBUTE_UNUSED,\n+\t\t\t\t    char* rest ATTRIBUTE_UNUSED)\n+{\n+  aarch64_ra_sign_scope = AARCH64_FUNCTION_NON_LEAF;\n+  return AARCH64_PARSE_OK;\n+}\n+\n+static enum aarch64_parse_opt_result\n+aarch64_handle_pac_ret_leaf (char* str ATTRIBUTE_UNUSED,\n+\t\t\t      char* rest ATTRIBUTE_UNUSED)\n+{\n+  aarch64_ra_sign_scope = AARCH64_FUNCTION_ALL;\n+  return AARCH64_PARSE_OK;\n+}\n+\n+static const struct aarch64_branch_protect_type aarch64_pac_ret_subtypes[] = {\n+  { \"leaf\", aarch64_handle_pac_ret_leaf, NULL, 0 },\n+  { NULL, NULL, NULL, 0 }\n+};\n+\n+static const struct aarch64_branch_protect_type aarch64_branch_protect_types[] = {\n+  { \"none\", aarch64_handle_no_branch_protection, NULL, 0 },\n+  { \"standard\", aarch64_handle_standard_branch_protection, NULL, 0 },\n+  { \"pac-ret\", aarch64_handle_pac_ret_protection, aarch64_pac_ret_subtypes,\n+    ARRAY_SIZE (aarch64_pac_ret_subtypes) },\n+  { NULL, NULL, NULL, 0 }\n+};\n+\n /* The condition codes of the processor, and the inverse function.  */\n static const char * const aarch64_condition_codes[] =\n {\n@@ -11099,6 +11178,12 @@ aarch64_parse_override_string (const char* input_string,\n static void\n aarch64_override_options_after_change_1 (struct gcc_options *opts)\n {\n+  if (accepted_branch_protection_string)\n+    {\n+      opts->x_aarch64_branch_protection_string\n+\t= xstrdup (accepted_branch_protection_string);\n+    }\n+\n   /* PR 70044: We have to be careful about being called multiple times for the\n      same function.  This means all changes should be repeatable.  */\n \n@@ -11384,6 +11469,110 @@ aarch64_validate_mcpu (const char *str, const struct processor **res,\n   return false;\n }\n \n+/* Parses CONST_STR for branch protection features specified in\n+   aarch64_branch_protect_types, and set any global variables required.  Returns\n+   the parsing result and assigns LAST_STR to the last processed token from\n+   CONST_STR so that it can be used for error reporting.  */\n+\n+static enum\n+aarch64_parse_opt_result aarch64_parse_branch_protection (const char *const_str,\n+\t\t\t\t\t\t\t  char** last_str)\n+{\n+  char *str_root = xstrdup (const_str);\n+  char* token_save = NULL;\n+  char *str = strtok_r (str_root, \"+\", &token_save);\n+  enum aarch64_parse_opt_result res = AARCH64_PARSE_OK;\n+  if (!str)\n+    res = AARCH64_PARSE_MISSING_ARG;\n+  else\n+    {\n+      char *next_str = strtok_r (NULL, \"+\", &token_save);\n+      /* Reset the branch protection features to their defaults.  */\n+      aarch64_handle_no_branch_protection (NULL, NULL);\n+\n+      while (str && res == AARCH64_PARSE_OK)\n+\t{\n+\t  const aarch64_branch_protect_type* type = aarch64_branch_protect_types;\n+\t  bool found = false;\n+\t  /* Search for this type.  */\n+\t  while (type && type->name && !found && res == AARCH64_PARSE_OK)\n+\t    {\n+\t      if (strcmp (str, type->name) == 0)\n+\t\t{\n+\t\t  found = true;\n+\t\t  res = type->handler (str, next_str);\n+\t\t  str = next_str;\n+\t\t  next_str = strtok_r (NULL, \"+\", &token_save);\n+\t\t}\n+\t      else\n+\t\ttype++;\n+\t    }\n+\t  if (found && res == AARCH64_PARSE_OK)\n+\t    {\n+\t      bool found_subtype = true;\n+\t      /* Loop through each token until we find one that isn't a\n+\t\t subtype.  */\n+\t      while (found_subtype)\n+\t\t{\n+\t\t  found_subtype = false;\n+\t\t  const aarch64_branch_protect_type *subtype = type->subtypes;\n+\t\t  /* Search for the subtype.  */\n+\t\t  while (str && subtype && subtype->name && !found_subtype\n+\t\t\t  && res == AARCH64_PARSE_OK)\n+\t\t    {\n+\t\t      if (strcmp (str, subtype->name) == 0)\n+\t\t\t{\n+\t\t\t  found_subtype = true;\n+\t\t\t  res = subtype->handler (str, next_str);\n+\t\t\t  str = next_str;\n+\t\t\t  next_str = strtok_r (NULL, \"+\", &token_save);\n+\t\t\t}\n+\t\t      else\n+\t\t\tsubtype++;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  else if (!found)\n+\t    res = AARCH64_PARSE_INVALID_ARG;\n+\t}\n+    }\n+  /* Copy the last processed token into the argument to pass it back.\n+    Used by option and attribute validation to print the offending token.  */\n+  if (last_str)\n+    {\n+      if (str) strcpy (*last_str, str);\n+      else *last_str = NULL;\n+    }\n+  if (res == AARCH64_PARSE_OK)\n+    {\n+      /* If needed, alloc the accepted string then copy in const_str.\n+\tUsed by override_option_after_change_1.  */\n+      if (!accepted_branch_protection_string)\n+\taccepted_branch_protection_string = (char *) xmalloc (\n+\t\t\t\t\t\t      BRANCH_PROTECT_STR_MAX\n+\t\t\t\t\t\t\t+ 1);\n+      strncpy (accepted_branch_protection_string, const_str,\n+\t\tBRANCH_PROTECT_STR_MAX + 1);\n+      /* Forcibly null-terminate.  */\n+      accepted_branch_protection_string[BRANCH_PROTECT_STR_MAX] = '\\0';\n+    }\n+  return res;\n+}\n+\n+static bool\n+aarch64_validate_mbranch_protection (const char *const_str)\n+{\n+  char *str = (char *) xmalloc (strlen (const_str));\n+  enum aarch64_parse_opt_result res =\n+    aarch64_parse_branch_protection (const_str, &str);\n+  if (res == AARCH64_PARSE_INVALID_ARG)\n+    error (\"invalid arg %<%s%> for %<-mbranch-protection=%>\", str);\n+  else if (res == AARCH64_PARSE_MISSING_ARG)\n+    error (\"missing arg for %<-mbranch-protection=%>\");\n+  free (str);\n+  return res == AARCH64_PARSE_OK;\n+}\n+\n /* Validate a command-line -march option.  Parse the arch and extensions\n    (if any) specified in STR and throw errors if appropriate.  Put the\n    results, if they are valid, in RES and ISA_FLAGS.  Return whether the\n@@ -11518,6 +11707,9 @@ aarch64_override_options (void)\n   selected_arch = NULL;\n   selected_tune = NULL;\n \n+  if (aarch64_branch_protection_string)\n+    aarch64_validate_mbranch_protection (aarch64_branch_protection_string);\n+\n   /* -mcpu=CPU is shorthand for -march=ARCH_FOR_CPU, -mtune=CPU.\n      If either of -march or -mtune is given, they override their\n      respective component of -mcpu.  */\n@@ -11690,6 +11882,8 @@ static void\n aarch64_option_save (struct cl_target_option *ptr, struct gcc_options *opts)\n {\n   ptr->x_aarch64_override_tune_string = opts->x_aarch64_override_tune_string;\n+  ptr->x_aarch64_branch_protection_string\n+    = opts->x_aarch64_branch_protection_string;\n }\n \n /* Implements TARGET_OPTION_RESTORE.  Restore the backend codegen decisions\n@@ -11703,6 +11897,13 @@ aarch64_option_restore (struct gcc_options *opts, struct cl_target_option *ptr)\n   opts->x_explicit_arch = ptr->x_explicit_arch;\n   selected_arch = aarch64_get_arch (ptr->x_explicit_arch);\n   opts->x_aarch64_override_tune_string = ptr->x_aarch64_override_tune_string;\n+  opts->x_aarch64_branch_protection_string\n+    = ptr->x_aarch64_branch_protection_string;\n+  if (opts->x_aarch64_branch_protection_string)\n+    {\n+      aarch64_parse_branch_protection (opts->x_aarch64_branch_protection_string,\n+\t\t\t\t\tNULL);\n+    }\n \n   aarch64_override_options_internal (opts);\n }\n@@ -11897,6 +12098,37 @@ aarch64_handle_attr_cpu (const char *str)\n   return false;\n }\n \n+/* Handle the argument STR to the branch-protection= attribute.  */\n+\n+ static bool\n+ aarch64_handle_attr_branch_protection (const char* str)\n+ {\n+  char *err_str = (char *) xmalloc (strlen (str));\n+  enum aarch64_parse_opt_result res = aarch64_parse_branch_protection (str,\n+\t\t\t\t\t\t\t\t      &err_str);\n+  bool success = false;\n+  switch (res)\n+    {\n+     case AARCH64_PARSE_MISSING_ARG:\n+       error (\"missing argument to %<target(\\\"branch-protection=\\\")%> pragma or\"\n+\t      \" attribute\");\n+       break;\n+     case AARCH64_PARSE_INVALID_ARG:\n+       error (\"invalid protection type (\\\"%s\\\") in %<target(\\\"branch-protection\"\n+\t      \"=\\\")%> pragma or attribute\", err_str);\n+       break;\n+     case AARCH64_PARSE_OK:\n+       success = true;\n+      /* Fall through.  */\n+     case AARCH64_PARSE_INVALID_FEATURE:\n+       break;\n+     default:\n+       gcc_unreachable ();\n+    }\n+  free (err_str);\n+  return success;\n+ }\n+\n /* Handle the argument STR to the tune= target attribute.  */\n \n static bool\n@@ -11995,6 +12227,8 @@ static const struct aarch64_attribute_info aarch64_attributes[] =\n   { \"cpu\", aarch64_attr_custom, false, aarch64_handle_attr_cpu, OPT_mcpu_ },\n   { \"tune\", aarch64_attr_custom, false, aarch64_handle_attr_tune,\n      OPT_mtune_ },\n+  { \"branch-protection\", aarch64_attr_custom, false,\n+     aarch64_handle_attr_branch_protection, OPT_mbranch_protection_ },\n   { \"sign-return-address\", aarch64_attr_enum, false, NULL,\n      OPT_msign_return_address_ },\n   { NULL, aarch64_attr_custom, false, NULL, OPT____ }"}, {"sha": "69a5103a082f2fb32777e6aae21049d4ec30891e", "filename": "gcc/config/aarch64/aarch64.opt", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efac62a3d17d534e8fec39a53031689efb0dc724/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efac62a3d17d534e8fec39a53031689efb0dc724/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.opt?ref=efac62a3d17d534e8fec39a53031689efb0dc724", "patch": "@@ -149,8 +149,12 @@ mpc-relative-literal-loads\n Target Report Save Var(pcrelative_literal_loads) Init(2) Save\n PC relative literal loads.\n \n+mbranch-protection=\n+Target RejectNegative Joined Var(aarch64_branch_protection_string) Save\n+Use branch-protection features.\n+\n msign-return-address=\n-Target RejectNegative Report Joined Enum(aarch64_ra_sign_scope_t) Var(aarch64_ra_sign_scope) Init(AARCH64_FUNCTION_NONE) Save\n+Target Deprecated RejectNegative Joined Enum(aarch64_ra_sign_scope_t) Var(aarch64_ra_sign_scope) Init(AARCH64_FUNCTION_NONE) Save\n Select return address signing scope.\n \n Enum"}, {"sha": "e5c63411a445ebe03509daabf60a15b96e5a9b71", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efac62a3d17d534e8fec39a53031689efb0dc724/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efac62a3d17d534e8fec39a53031689efb0dc724/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=efac62a3d17d534e8fec39a53031689efb0dc724", "patch": "@@ -631,6 +631,7 @@ Objective-C and Objective-C++ Dialects}.\n -mlow-precision-recip-sqrt  -mlow-precision-sqrt  -mlow-precision-div @gol\n -mpc-relative-literal-loads @gol\n -msign-return-address=@var{scope} @gol\n+-mbranch-protection=@var{none}|@var{standard}|@var{pac-ret}[+@var{leaf}] @gol\n -march=@var{name}  -mcpu=@var{name}  -mtune=@var{name}  @gol\n -moverride=@var{string}  -mverbose-cost-dump  -mtrack-speculation} \n \n@@ -15738,7 +15739,21 @@ Select the function scope on which return address signing will be applied.\n Permissible values are @samp{none}, which disables return address signing,\n @samp{non-leaf}, which enables pointer signing for functions which are not leaf\n functions, and @samp{all}, which enables pointer signing for all functions.  The\n-default value is @samp{none}.\n+default value is @samp{none}. This option has been deprecated by\n+-mbranch-protection.\n+\n+@item -mbranch-protection=@var{none}|@var{standard}|@var{pac-ret}[+@var{leaf}]\n+@opindex mbranch-protection\n+Select the branch protection features to use.\n+@samp{none} is the default and turns off all types of branch protection.\n+@samp{standard} turns on all types of branch protection features.  If a feature\n+has additional tuning options, then @samp{standard} sets it to its standard\n+level.\n+@samp{pac-ret[+@var{leaf}]} turns on return address signing to its standard\n+level: signing functions that save the return address to memory (non-leaf\n+functions will practically always do this) using the a-key.  The optional\n+argument @samp{leaf} can be used to extend the signing to include leaf\n+functions.\n \n @item -msve-vector-bits=@var{bits}\n @opindex msve-vector-bits"}, {"sha": "14a59446eb3f2d12c07b32425f07caf03f6fbb91", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efac62a3d17d534e8fec39a53031689efb0dc724/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efac62a3d17d534e8fec39a53031689efb0dc724/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=efac62a3d17d534e8fec39a53031689efb0dc724", "patch": "@@ -1,3 +1,12 @@\n+2019-01-08  Sam Tebbs  <sam.tebbs@arm.com>\n+\n+\t* gcc.target/aarch64/(return_address_sign_1.c,\n+\treturn_address_sign_2.c, return_address_sign_3.c (__attribute__)):\n+\tChange option to -mbranch-protection.\n+\t* gcc.target/aarch64/(branch-protection-option.c,\n+\tbranch-protection-option-2.c, branch-protection-attr.c,\n+\tbranch-protection-attr-2.c): New file.\n+\n 2019-01-08  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* g++.dg/diagnostic/out-of-class-redeclaration.C: New."}, {"sha": "19b3511ab6111a895383f5ddf93644110c3971c6", "filename": "gcc/testsuite/gcc.target/aarch64/branch-protection-attr-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efac62a3d17d534e8fec39a53031689efb0dc724/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbranch-protection-attr-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efac62a3d17d534e8fec39a53031689efb0dc724/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbranch-protection-attr-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbranch-protection-attr-2.c?ref=efac62a3d17d534e8fec39a53031689efb0dc724", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do \"compile\" } */\n+\n+void __attribute__ ((target(\"branch-protection=pac-ret+leaf,branch-protection=none\")))\n+foo ()\n+{\n+}\n+\n+void __attribute__ ((target(\"branch-protection=pac-ret,branch-protection=none\")))\n+foo2 ()\n+{\n+  /* Function call here to make this a non-leaf function, so that it is covered by pac-ret.  */\n+  foo ();\n+}\n+\n+/* { dg-final { scan-assembler-not \"\\tautiasp\\t\" } } */\n+/* { dg-final { scan-assembler-not \"\\tpaciasp\\t\" } } */"}, {"sha": "229ce1ca7bebce060204946682af175389527193", "filename": "gcc/testsuite/gcc.target/aarch64/branch-protection-attr.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efac62a3d17d534e8fec39a53031689efb0dc724/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbranch-protection-attr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efac62a3d17d534e8fec39a53031689efb0dc724/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbranch-protection-attr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbranch-protection-attr.c?ref=efac62a3d17d534e8fec39a53031689efb0dc724", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do \"compile\" } */\n+\n+void __attribute__ ((target(\"branch-protection=leaf\")))\n+foo1 ()\n+{\n+}\n+/* { dg-error {invalid protection type \\(\"leaf\"\\) in 'target\\(\"branch-protection=\"\\)' pragma or attribute} \"\" { target *-*-* } 5 } */\n+/* { dg-error {pragma or attribute 'target\\(\"branch-protection=leaf\"\\)' is not valid} \"\" { target *-*-* } 5 } */\n+\n+void __attribute__ ((target(\"branch-protection=none+pac-ret\")))\n+foo2 ()\n+{\n+}\n+/* { dg-error \"unexpected 'pac-ret' after 'none'\" \"\" { target *-*-* } 12 } */\n+/* { dg-error {pragma or attribute 'target\\(\"branch-protection=none\\+pac-ret\"\\)' is not valid} \"\" { target *-*-* } 12 } */\n+\n+void __attribute__ ((target(\"branch-protection=\")))\n+foo3 ()\n+{\n+}\n+/* { dg-error {missing argument to 'target\\(\"branch-protection=\"\\)' pragma or attribute} \"\" { target *-*-* } 19 } */\n+/* { dg-error {pragma or attribute 'target\\(\"branch-protection=\"\\)' is not valid} \"\" { target *-*-* } 19 } */"}, {"sha": "281851136520ece286186fd18c1a64b984f0b3e8", "filename": "gcc/testsuite/gcc.target/aarch64/branch-protection-option-2.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efac62a3d17d534e8fec39a53031689efb0dc724/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbranch-protection-option-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efac62a3d17d534e8fec39a53031689efb0dc724/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbranch-protection-option-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbranch-protection-option-2.c?ref=efac62a3d17d534e8fec39a53031689efb0dc724", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do \"compile\" } */\n+/* { dg-options \"-mbranch-protection=pac-ret+leaf -mbranch-protection=none\" } */\n+\n+void foo2 ()\n+{\n+}\n+\n+/* { dg-final { scan-assembler-not \"\\tautiasp\\t\" } } */\n+/* { dg-final { scan-assembler-not \"\\tpaciasp\\t\" } } */"}, {"sha": "1b3bf4ee2b88a6e89d78f99766889904849a89db", "filename": "gcc/testsuite/gcc.target/aarch64/branch-protection-option.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efac62a3d17d534e8fec39a53031689efb0dc724/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbranch-protection-option.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efac62a3d17d534e8fec39a53031689efb0dc724/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbranch-protection-option.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbranch-protection-option.c?ref=efac62a3d17d534e8fec39a53031689efb0dc724", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-do \"compile\" } */\n+/* { dg-options \"-mbranch-protection=leaf -mbranch-protection=none+pac-ret\" } */\n+\n+/* { dg-error \"unexpected 'pac-ret' after 'none'\"  \"\" { target *-*-* } 0 } */"}, {"sha": "0140bee194f5a3ec53e794984c2f9b0e96bdbb63", "filename": "gcc/testsuite/gcc.target/aarch64/return_address_sign_1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efac62a3d17d534e8fec39a53031689efb0dc724/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Freturn_address_sign_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efac62a3d17d534e8fec39a53031689efb0dc724/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Freturn_address_sign_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Freturn_address_sign_1.c?ref=efac62a3d17d534e8fec39a53031689efb0dc724", "patch": "@@ -1,6 +1,6 @@\n /* Testing return address signing where no combined instructions used.  */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -msign-return-address=all\" } */\n+/* { dg-options \"-O2 -mbranch-protection=pac-ret+leaf\" } */\n /* { dg-require-effective-target lp64 } */\n \n int foo (int);"}, {"sha": "a4bc5b4533382d3d21085a763028576f72531ed7", "filename": "gcc/testsuite/gcc.target/aarch64/return_address_sign_2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efac62a3d17d534e8fec39a53031689efb0dc724/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Freturn_address_sign_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efac62a3d17d534e8fec39a53031689efb0dc724/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Freturn_address_sign_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Freturn_address_sign_2.c?ref=efac62a3d17d534e8fec39a53031689efb0dc724", "patch": "@@ -1,6 +1,6 @@\n /* Testing return address signing where combined instructions used.  */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -msign-return-address=all\" } */\n+/* { dg-options \"-O2 -mbranch-protection=pac-ret+leaf\" } */\n /* { dg-require-effective-target lp64 } */\n \n int foo (int);"}, {"sha": "e39ed34ab1c13d1368f4a625b4a466eb76354ef8", "filename": "gcc/testsuite/gcc.target/aarch64/return_address_sign_3.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efac62a3d17d534e8fec39a53031689efb0dc724/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Freturn_address_sign_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efac62a3d17d534e8fec39a53031689efb0dc724/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Freturn_address_sign_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Freturn_address_sign_3.c?ref=efac62a3d17d534e8fec39a53031689efb0dc724", "patch": "@@ -1,17 +1,17 @@\n /* Testing the disable of return address signing.  */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -msign-return-address=all\" } */\n+/* { dg-options \"-O2 -mbranch-protection=pac-ret+leaf\" } */\n /* { dg-require-effective-target lp64 } */\n \n int bar (int, int);\n \n-int __attribute__ ((target (\"arch=armv8.3-a, sign-return-address=non-leaf\")))\n+int __attribute__ ((target (\"arch=armv8.3-a, branch-protection=pac-ret\")))\n func1_leaf (int a, int b, int c, int d)\n {\n   return a + b + c + d;\n }\n \n-int __attribute__ ((target (\"arch=armv8.3-a, sign-return-address=none\")))\n+int __attribute__ ((target (\"arch=armv8.3-a, branch-protection=none\")))\n func2_none (int a, int b, int c, int d)\n {\n   return c + bar (a, b) + d;"}]}