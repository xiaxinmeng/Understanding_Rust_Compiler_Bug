{"sha": "eb50f5f41a6cb89213b013a759dfea6204a94068", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWI1MGY1ZjQxYTZjYjg5MjEzYjAxM2E3NTlkZmVhNjIwNGE5NDA2OA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-02-28T22:14:43Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-02-28T22:14:43Z"}, "message": "tree-inline.c (expand_call_inline): Avoid duplicate declarations of static vars.\n\n\t* tree-inline.c (expand_call_inline): Avoid duplicate declarations of\n\tstatic vars.\n\t(copy_arguments_for_versioning): If var is declared don't declare it.\n\t(tree_function_versioning): First setup substitutions and then copy\n\targs.\n\nFrom-SVN: r144497", "tree": {"sha": "568b3dc4f877070b6024d890558308742dfa5c68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/568b3dc4f877070b6024d890558308742dfa5c68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb50f5f41a6cb89213b013a759dfea6204a94068", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb50f5f41a6cb89213b013a759dfea6204a94068", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb50f5f41a6cb89213b013a759dfea6204a94068", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb50f5f41a6cb89213b013a759dfea6204a94068/comments", "author": null, "committer": null, "parents": [{"sha": "261401301f185163dbca9103c8d62fe8f3cd84d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/261401301f185163dbca9103c8d62fe8f3cd84d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/261401301f185163dbca9103c8d62fe8f3cd84d6"}], "stats": {"total": 57, "additions": 35, "deletions": 22}, "files": [{"sha": "87578499cf096fa2a443ff5f069edca149982c56", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb50f5f41a6cb89213b013a759dfea6204a94068/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb50f5f41a6cb89213b013a759dfea6204a94068/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eb50f5f41a6cb89213b013a759dfea6204a94068", "patch": "@@ -1,3 +1,11 @@\n+2009-02-28  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-inline.c (expand_call_inline): Avoid duplicate declarations of\n+\tstatic vars.\n+\t(copy_arguments_for_versioning): If var is declared don't declare it.\n+\t(tree_function_versioning): First setup substitutions and then copy\n+\targs.\n+\n 2009-02-27  Jan Hubicka  <jh@suse.cz>\n \n \tPR debug/39267"}, {"sha": "a7e25fd15c8f937b33ffcfc916aa24b5398e49f4", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb50f5f41a6cb89213b013a759dfea6204a94068/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb50f5f41a6cb89213b013a759dfea6204a94068/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=eb50f5f41a6cb89213b013a759dfea6204a94068", "patch": "@@ -3305,26 +3305,31 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n       DECL_NO_TBAA_P (retvar) = 1;\n     }\n \n-  /* This is it.  Duplicate the callee body.  Assume callee is\n-     pre-gimplified.  Note that we must not alter the caller\n-     function in any way before this point, as this CALL_EXPR may be\n-     a self-referential call; if we're calling ourselves, we need to\n-     duplicate our body before altering anything.  */\n-  copy_body (id, bb->count, bb->frequency, bb, return_block);\n-\n   /* Add local vars in this inlined callee to caller.  */\n   t_step = id->src_cfun->local_decls;\n   for (; t_step; t_step = TREE_CHAIN (t_step))\n     {\n       var = TREE_VALUE (t_step);\n       if (TREE_STATIC (var) && !TREE_ASM_WRITTEN (var))\n-\tcfun->local_decls = tree_cons (NULL_TREE, var,\n-\t\t\t\t\t       cfun->local_decls);\n+\t{\n+\t  if (var_ann (var) && referenced_var_check_and_insert (var))\n+\t    cfun->local_decls = tree_cons (NULL_TREE, var,\n+\t\t\t\t\t   cfun->local_decls);\n+\t}\n       else\n-\tcfun->local_decls = tree_cons (NULL_TREE, remap_decl (var, id),\n-\t\t\t\t\t       cfun->local_decls);\n+        {\n+\t  cfun->local_decls = tree_cons (NULL_TREE, remap_decl (var, id),\n+\t\t\t\t\t          cfun->local_decls);\n+\t}\n     }\n \n+  /* This is it.  Duplicate the callee body.  Assume callee is\n+     pre-gimplified.  Note that we must not alter the caller\n+     function in any way before this point, as this CALL_EXPR may be\n+     a self-referential call; if we're calling ourselves, we need to\n+     duplicate our body before altering anything.  */\n+  copy_body (id, bb->count, bb->frequency, bb, return_block);\n+\n   /* Clean up.  */\n   pointer_map_destroy (id->decl_map);\n   id->decl_map = st;\n@@ -4140,7 +4145,7 @@ copy_arguments_for_versioning (tree orig_parm, copy_body_data * id,\n         *parg = new_tree;\n \tparg = &TREE_CHAIN (new_tree);\n       }\n-    else\n+    else if (!pointer_map_contains (id->decl_map, arg))\n       {\n \t/* Make an equivalent VAR_DECL.  If the argument was used\n \t   as temporary variable later in function, the uses will be\n@@ -4263,16 +4268,6 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n     DECL_STRUCT_FUNCTION (new_decl)->static_chain_decl =\n       copy_static_chain (DECL_STRUCT_FUNCTION (old_decl)->static_chain_decl,\n \t\t\t &id);\n-  /* Copy the function's arguments.  */\n-  if (DECL_ARGUMENTS (old_decl) != NULL_TREE)\n-    DECL_ARGUMENTS (new_decl) =\n-      copy_arguments_for_versioning (DECL_ARGUMENTS (old_decl), &id,\n-      \t\t\t\t     args_to_skip, &vars);\n-  \n-  DECL_INITIAL (new_decl) = remap_blocks (DECL_INITIAL (id.src_fn), &id);\n-  \n-  /* Renumber the lexical scoping (non-code) blocks consecutively.  */\n-  number_blocks (id.dst_fn);\n   \n   /* If there's a tree_map, prepare for substitution.  */\n   if (tree_map)\n@@ -4307,6 +4302,16 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n \t      VEC_safe_push (gimple, heap, init_stmts, init);\n \t  }\n       }\n+  /* Copy the function's arguments.  */\n+  if (DECL_ARGUMENTS (old_decl) != NULL_TREE)\n+    DECL_ARGUMENTS (new_decl) =\n+      copy_arguments_for_versioning (DECL_ARGUMENTS (old_decl), &id,\n+      \t\t\t\t     args_to_skip, &vars);\n+  \n+  DECL_INITIAL (new_decl) = remap_blocks (DECL_INITIAL (id.src_fn), &id);\n+  \n+  /* Renumber the lexical scoping (non-code) blocks consecutively.  */\n+  number_blocks (id.dst_fn);\n   \n   declare_inline_vars (DECL_INITIAL (new_decl), vars);\n   if (DECL_STRUCT_FUNCTION (old_decl)->local_decls != NULL_TREE)"}]}