{"sha": "f250a0bc1c4d417c3669e75f1fa768a52b7c99d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI1MGEwYmMxYzRkNDE3YzM2NjllNzVmMWZhNzY4YTUyYjdjOTlkMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-04-10T21:19:42Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-04-10T21:19:42Z"}, "message": "(e64toe): Properly distinguish between NaN and infinity bit patterns for real-words-big-endian targets.\n\n(e64toe): Properly distinguish between NaN and infinity bit patterns\nfor real-words-big-endian targets.\n(endian): Add two explicit casts.\n(e64toe): Support ARM extended precision fp format.  Check negative\ninfinities properly for NaNs.\n(toe64): Support ARM extended precision fp format.\n\nFrom-SVN: r11688", "tree": {"sha": "9d7f6302371f3f9dceafdd8e88cfbdd5ef2e7c44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d7f6302371f3f9dceafdd8e88cfbdd5ef2e7c44"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f250a0bc1c4d417c3669e75f1fa768a52b7c99d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f250a0bc1c4d417c3669e75f1fa768a52b7c99d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f250a0bc1c4d417c3669e75f1fa768a52b7c99d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f250a0bc1c4d417c3669e75f1fa768a52b7c99d1/comments", "author": null, "committer": null, "parents": [{"sha": "6e9e65c67ae29c8e3985458344097fccc6952711", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e9e65c67ae29c8e3985458344097fccc6952711", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e9e65c67ae29c8e3985458344097fccc6952711"}], "stats": {"total": 38, "additions": 34, "deletions": 4}, "files": [{"sha": "e8f78ad73cfb296f6cd9de6eca989a51c76e524b", "filename": "gcc/real.c", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f250a0bc1c4d417c3669e75f1fa768a52b7c99d1/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f250a0bc1c4d417c3669e75f1fa768a52b7c99d1/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=f250a0bc1c4d417c3669e75f1fa768a52b7c99d1", "patch": "@@ -471,7 +471,7 @@ endian (e, x, mode)\n \t  th = (unsigned long) e[0] & 0xffff;\n \t  t = (unsigned long) e[1] & 0xffff;\n \t  t |= th << 16;\n-\t  x[0] = t;\n+\t  x[0] = (long) t;\n \t  break;\n \n \tdefault:\n@@ -520,7 +520,7 @@ endian (e, x, mode)\n \t  th = (unsigned long) e[1] & 0xffff;\n \t  t = (unsigned long) e[0] & 0xffff;\n \t  t |= th << 16;\n-\t  x[0] = t;\n+\t  x[0] = (long) t;\n \t  break;\n \n \tdefault:\n@@ -2978,16 +2978,22 @@ e64toe (pe, y)\n   else\n     {\n       p = &yy[0] + (NE - 1);\n+#ifdef ARM_EXTENDED_IEEE_FORMAT\n+      /* For ARMs, the exponent is in the lowest 15 bits of the word.  */\n+      *p-- = (e[0] & 0x8000) | (e[1] & 0x7ffff);\n+      e += 2;\n+#else\n       *p-- = *e++;\n       ++e;\n+#endif\n       for (i = 0; i < 4; i++)\n \t*p-- = *e++;\n     }\n #endif\n #ifdef INFINITY\n   /* Point to the exponent field and check max exponent cases.  */\n   p = &yy[NE - 1];\n-  if (*p == 0x7fff)\n+  if ((*p & 0x7fff) == 0x7fff)\n     {\n #ifdef NANS\n       if (! REAL_WORDS_BIG_ENDIAN)\n@@ -3005,14 +3011,32 @@ e64toe (pe, y)\n \t}\n       else\n \t{\n-\t  for (i = 1; i <= 4; i++)\n+#ifdef ARM_EXTENDED_IEEE_FORMAT\n+\t  for (i = 2; i <= 5; i++)\n \t    {\n \t      if (pe[i] != 0)\n \t\t{\n \t\t  enan (y, (*p & 0x8000) != 0);\n \t\t  return;\n \t\t}\n \t    }\n+#else /* not ARM */\n+\t  /* In Motorola extended precision format, the most significant\n+\t     bit of an infinity mantissa could be either 1 or 0.  It is\n+\t     the lower order bits that tell whether the value is a NaN.  */\n+\t  if ((pe[2] & 0x7fff) != 0)\n+\t    goto bigend_nan;\n+\n+\t  for (i = 3; i <= 5; i++)\n+\t    {\n+\t      if (pe[i] != 0)\n+\t\t{\n+bigend_nan:\n+\t\t  enan (y, (*p & 0x8000) != 0);\n+\t\t  return;\n+\t\t}\n+\t    }\n+#endif /* not ARM */\n \t}\n #endif /* NANS */\n       eclear (y);\n@@ -3390,11 +3414,17 @@ toe64 (a, b)\n #ifdef IEEE\n   if (REAL_WORDS_BIG_ENDIAN)\n     {\n+#ifdef ARM_EXTENDED_IEEE_FORMAT\n+      /* The exponent is in the lowest 15 bits of the first word.  */\n+      *q++ = i ? 0x8000 : 0;\n+      *q++ = *p++;\n+#else\n       if (i)\n \t*q++ = *p++ | 0x8000;\n       else\n \t*q++ = *p++;\n       *q++ = 0;\n+#endif\n     }\n   else\n     {"}]}