{"sha": "cf92a178334a034950ff9faac1a336a02374988b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Y5MmExNzgzMzRhMDM0OTUwZmY5ZmFhYzFhMzM2YTAyMzc0OTg4Yg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-22T16:54:47Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-22T16:54:47Z"}, "message": "gcse.c: Use rtx_insn\n\ngcc/\n\t* gcse.c (struct occr): Strengthen field \"insn\" from rtx to\n\trtx_insn *.\n\t(test_insn): Likewise for this global.\n\t(oprs_unchanged_p): Strengthen param \"insn\" from const_rtx to\n\tconst rtx_insn *.\n\t(oprs_anticipatable_p): Likewise.\n\t(oprs_available_p): Likewise.\n\t(insert_expr_in_table): Strengthen param \"insn\" from  rtx to\n\trtx_insn *.\n\t(hash_scan_set): Likewise.\n\t(hash_scan_clobber): Likewise.\n\t(hash_scan_call): Likewise.\n\t(hash_scan_insn): Likewise.\n\t(compute_hash_table_work): Likewise for local \"insn\".\n\t(process_insert_insn): Likewise for return type and local \"pat\".\n\t(insert_insn_end_basic_block): Likewise for locals \"new_insn\",\n\t\"pat\", \"pat_end\", \"maybe_cc0_setter\".\n\t(pre_edge_insert): Likewise for local \"insn\".\n\t(pre_insert_copy_insn): Likewise for param \"insn\".\n\t(pre_insert_copies): Likewise for local \"insn\".\n\t(struct set_data): Likewise for field \"insn\".\n\t(single_set_gcse): Likewise for param \"insn\".\n\t(gcse_emit_move_after): Likewise.\n\t(pre_delete): Likewise for local \"insn\".\n\t(update_bb_reg_pressure): Likewise for param \"from\" and local\n\t\"insn\".\n\t(should_hoist_expr_to_dom): Likewise for param \"from\".\n\t(hoist_code): Likewise for local \"insn\".\n\t(get_pressure_class_and_nregs): Likewise for param \"insn\".\n\t(calculate_bb_reg_pressure): Likewise for local \"insn\".\n\t(compute_ld_motion_mems): Likewise.\n\nFrom-SVN: r214331", "tree": {"sha": "cd3b751fcc1d3c4d9ba2a93739e1c8a98705868e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd3b751fcc1d3c4d9ba2a93739e1c8a98705868e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf92a178334a034950ff9faac1a336a02374988b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf92a178334a034950ff9faac1a336a02374988b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf92a178334a034950ff9faac1a336a02374988b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf92a178334a034950ff9faac1a336a02374988b/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ced9924c22e4fbf72637d30927e9b2fa61488dbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ced9924c22e4fbf72637d30927e9b2fa61488dbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ced9924c22e4fbf72637d30927e9b2fa61488dbe"}], "stats": {"total": 126, "additions": 81, "deletions": 45}, "files": [{"sha": "3c6c7373fbc46a0fe12344a18864320774eb8245", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf92a178334a034950ff9faac1a336a02374988b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf92a178334a034950ff9faac1a336a02374988b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf92a178334a034950ff9faac1a336a02374988b", "patch": "@@ -1,3 +1,37 @@\n+2014-08-22  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gcse.c (struct occr): Strengthen field \"insn\" from rtx to\n+\trtx_insn *.\n+\t(test_insn): Likewise for this global.\n+\t(oprs_unchanged_p): Strengthen param \"insn\" from const_rtx to\n+\tconst rtx_insn *.\n+\t(oprs_anticipatable_p): Likewise.\n+\t(oprs_available_p): Likewise.\n+\t(insert_expr_in_table): Strengthen param \"insn\" from  rtx to\n+\trtx_insn *.\n+\t(hash_scan_set): Likewise.\n+\t(hash_scan_clobber): Likewise.\n+\t(hash_scan_call): Likewise.\n+\t(hash_scan_insn): Likewise.\n+\t(compute_hash_table_work): Likewise for local \"insn\".\n+\t(process_insert_insn): Likewise for return type and local \"pat\".\n+\t(insert_insn_end_basic_block): Likewise for locals \"new_insn\",\n+\t\"pat\", \"pat_end\", \"maybe_cc0_setter\".\n+\t(pre_edge_insert): Likewise for local \"insn\".\n+\t(pre_insert_copy_insn): Likewise for param \"insn\".\n+\t(pre_insert_copies): Likewise for local \"insn\".\n+\t(struct set_data): Likewise for field \"insn\".\n+\t(single_set_gcse): Likewise for param \"insn\".\n+\t(gcse_emit_move_after): Likewise.\n+\t(pre_delete): Likewise for local \"insn\".\n+\t(update_bb_reg_pressure): Likewise for param \"from\" and local\n+\t\"insn\".\n+\t(should_hoist_expr_to_dom): Likewise for param \"from\".\n+\t(hoist_code): Likewise for local \"insn\".\n+\t(get_pressure_class_and_nregs): Likewise for param \"insn\".\n+\t(calculate_bb_reg_pressure): Likewise for local \"insn\".\n+\t(compute_ld_motion_mems): Likewise.\n+\n 2014-08-22  David Malcolm  <dmalcolm@redhat.com>\n \n \t* genpeep.c (main): Rename param back from \"uncast_ins1\" to"}, {"sha": "2148a7e1fd35b2f6fd29f3300732b75d79f94c5f", "filename": "gcc/gcse.c", "status": "modified", "additions": 47, "deletions": 45, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf92a178334a034950ff9faac1a336a02374988b/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf92a178334a034950ff9faac1a336a02374988b/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=cf92a178334a034950ff9faac1a336a02374988b", "patch": "@@ -296,7 +296,7 @@ struct occr\n   /* Next occurrence of this expression.  */\n   struct occr *next;\n   /* The insn that computes the expression.  */\n-  rtx insn;\n+  rtx_insn *insn;\n   /* Nonzero if this [anticipatable] occurrence has been deleted.  */\n   char deleted_p;\n   /* Nonzero if this [available] occurrence has been copied to\n@@ -462,16 +462,16 @@ static void *gcalloc (size_t, size_t) ATTRIBUTE_MALLOC;\n static void *gcse_alloc (unsigned long);\n static void alloc_gcse_mem (void);\n static void free_gcse_mem (void);\n-static void hash_scan_insn (rtx, struct hash_table_d *);\n-static void hash_scan_set (rtx, rtx, struct hash_table_d *);\n-static void hash_scan_clobber (rtx, rtx, struct hash_table_d *);\n-static void hash_scan_call (rtx, rtx, struct hash_table_d *);\n+static void hash_scan_insn (rtx_insn *, struct hash_table_d *);\n+static void hash_scan_set (rtx, rtx_insn *, struct hash_table_d *);\n+static void hash_scan_clobber (rtx, rtx_insn *, struct hash_table_d *);\n+static void hash_scan_call (rtx, rtx_insn *, struct hash_table_d *);\n static int want_to_gcse_p (rtx, int *);\n-static int oprs_unchanged_p (const_rtx, const_rtx, int);\n-static int oprs_anticipatable_p (const_rtx, const_rtx);\n-static int oprs_available_p (const_rtx, const_rtx);\n-static void insert_expr_in_table (rtx, enum machine_mode, rtx, int, int, int,\n-\t\t\t\t  struct hash_table_d *);\n+static int oprs_unchanged_p (const_rtx, const rtx_insn *, int);\n+static int oprs_anticipatable_p (const_rtx, const rtx_insn *);\n+static int oprs_available_p (const_rtx, const rtx_insn *);\n+static void insert_expr_in_table (rtx, enum machine_mode, rtx_insn *, int, int,\n+\t\t\t\t  int, struct hash_table_d *);\n static unsigned int hash_expr (const_rtx, enum machine_mode, int *, int);\n static void record_last_reg_set_info (rtx, int);\n static void record_last_mem_set_info (rtx);\n@@ -493,7 +493,7 @@ static struct edge_list *compute_pre_data (void);\n static int pre_expr_reaches_here_p (basic_block, struct expr *,\n \t\t\t\t    basic_block);\n static void insert_insn_end_basic_block (struct expr *, basic_block);\n-static void pre_insert_copy_insn (struct expr *, rtx);\n+static void pre_insert_copy_insn (struct expr *, rtx_insn *);\n static void pre_insert_copies (void);\n static int pre_delete (void);\n static int pre_gcse (struct edge_list *);\n@@ -505,12 +505,12 @@ static void compute_code_hoist_vbeinout (void);\n static void compute_code_hoist_data (void);\n static int should_hoist_expr_to_dom (basic_block, struct expr *, basic_block,\n \t\t\t\t     sbitmap, int, int *, enum reg_class,\n-\t\t\t\t     int *, bitmap, rtx);\n+\t\t\t\t     int *, bitmap, rtx_insn *);\n static int hoist_code (void);\n static enum reg_class get_regno_pressure_class (int regno, int *nregs);\n-static enum reg_class get_pressure_class_and_nregs (rtx insn, int *nregs);\n+static enum reg_class get_pressure_class_and_nregs (rtx_insn *insn, int *nregs);\n static int one_code_hoisting_pass (void);\n-static rtx process_insert_insn (struct expr *);\n+static rtx_insn *process_insert_insn (struct expr *);\n static int pre_edge_insert (struct edge_list *, struct expr **);\n static int pre_expr_reaches_here_p_work (basic_block, struct expr *,\n \t\t\t\t\t basic_block, char *);\n@@ -526,7 +526,7 @@ static void trim_ld_motion_mems (void);\n static void update_ld_motion_stores (struct expr *);\n static void clear_modify_mem_tables (void);\n static void free_modify_mem_tables (void);\n-static rtx gcse_emit_move_after (rtx, rtx, rtx);\n+static rtx gcse_emit_move_after (rtx, rtx, rtx_insn *);\n static bool is_too_expensive (const char *);\n \n #define GNEW(T)\t\t\t((T *) gmalloc (sizeof (T)))\n@@ -830,7 +830,7 @@ want_to_gcse_p (rtx x, int *max_distance_ptr)\n \n /* Used internally by can_assign_to_reg_without_clobbers_p.  */\n \n-static GTY(()) rtx test_insn;\n+static GTY(()) rtx_insn *test_insn;\n \n /* Return true if we can assign X to a pseudo register such that the\n    resulting insn does not result in clobbering a hard register as a\n@@ -896,7 +896,7 @@ can_assign_to_reg_without_clobbers_p (rtx x)\n    or from INSN to the end of INSN's basic block (if AVAIL_P != 0).  */\n \n static int\n-oprs_unchanged_p (const_rtx x, const_rtx insn, int avail_p)\n+oprs_unchanged_p (const_rtx x, const rtx_insn *insn, int avail_p)\n {\n   int i, j;\n   enum rtx_code code;\n@@ -1071,7 +1071,7 @@ load_killed_in_block_p (const_basic_block bb, int uid_limit, const_rtx x,\n    the start of INSN's basic block up to but not including INSN.  */\n \n static int\n-oprs_anticipatable_p (const_rtx x, const_rtx insn)\n+oprs_anticipatable_p (const_rtx x, const rtx_insn *insn)\n {\n   return oprs_unchanged_p (x, insn, 0);\n }\n@@ -1080,7 +1080,7 @@ oprs_anticipatable_p (const_rtx x, const_rtx insn)\n    INSN to the end of INSN's basic block.  */\n \n static int\n-oprs_available_p (const_rtx x, const_rtx insn)\n+oprs_available_p (const_rtx x, const rtx_insn *insn)\n {\n   return oprs_unchanged_p (x, insn, 1);\n }\n@@ -1126,7 +1126,8 @@ expr_equiv_p (const_rtx x, const_rtx y)\n    be moved.  */\n \n static void\n-insert_expr_in_table (rtx x, enum machine_mode mode, rtx insn, int antic_p,\n+insert_expr_in_table (rtx x, enum machine_mode mode, rtx_insn *insn,\n+\t\t      int antic_p,\n \t\t      int avail_p, int max_distance, struct hash_table_d *table)\n {\n   int found, do_not_record_p;\n@@ -1231,7 +1232,7 @@ insert_expr_in_table (rtx x, enum machine_mode mode, rtx insn, int antic_p,\n /* Scan SET present in INSN and add an entry to the hash TABLE.  */\n \n static void\n-hash_scan_set (rtx set, rtx insn, struct hash_table_d *table)\n+hash_scan_set (rtx set, rtx_insn *insn, struct hash_table_d *table)\n {\n   rtx src = SET_SRC (set);\n   rtx dest = SET_DEST (set);\n@@ -1350,14 +1351,14 @@ hash_scan_set (rtx set, rtx insn, struct hash_table_d *table)\n }\n \n static void\n-hash_scan_clobber (rtx x ATTRIBUTE_UNUSED, rtx insn ATTRIBUTE_UNUSED,\n+hash_scan_clobber (rtx x ATTRIBUTE_UNUSED, rtx_insn *insn ATTRIBUTE_UNUSED,\n \t\t   struct hash_table_d *table ATTRIBUTE_UNUSED)\n {\n   /* Currently nothing to do.  */\n }\n \n static void\n-hash_scan_call (rtx x ATTRIBUTE_UNUSED, rtx insn ATTRIBUTE_UNUSED,\n+hash_scan_call (rtx x ATTRIBUTE_UNUSED, rtx_insn *insn ATTRIBUTE_UNUSED,\n \t\tstruct hash_table_d *table ATTRIBUTE_UNUSED)\n {\n   /* Currently nothing to do.  */\n@@ -1366,7 +1367,7 @@ hash_scan_call (rtx x ATTRIBUTE_UNUSED, rtx insn ATTRIBUTE_UNUSED,\n /* Process INSN and add hash table entries as appropriate.  */\n \n static void\n-hash_scan_insn (rtx insn, struct hash_table_d *table)\n+hash_scan_insn (rtx_insn *insn, struct hash_table_d *table)\n {\n   rtx pat = PATTERN (insn);\n   int i;\n@@ -1566,7 +1567,7 @@ compute_hash_table_work (struct hash_table_d *table)\n \n   FOR_EACH_BB_FN (current_bb, cfun)\n     {\n-      rtx insn;\n+      rtx_insn *insn;\n       unsigned int regno;\n \n       /* First pass over the instructions records information used to\n@@ -2122,13 +2123,13 @@ pre_expr_reaches_here_p (basic_block occr_bb, struct expr *expr, basic_block bb)\n \f\n /* Generate RTL to copy an EXPR to its `reaching_reg' and return it.  */\n \n-static rtx\n+static rtx_insn *\n process_insert_insn (struct expr *expr)\n {\n   rtx reg = expr->reaching_reg;\n   /* Copy the expression to make sure we don't have any sharing issues.  */\n   rtx exp = copy_rtx (expr->expr);\n-  rtx pat;\n+  rtx_insn *pat;\n \n   start_sequence ();\n \n@@ -2161,10 +2162,10 @@ static void\n insert_insn_end_basic_block (struct expr *expr, basic_block bb)\n {\n   rtx insn = BB_END (bb);\n-  rtx new_insn;\n+  rtx_insn *new_insn;\n   rtx reg = expr->reaching_reg;\n   int regno = REGNO (reg);\n-  rtx pat, pat_end;\n+  rtx_insn *pat, *pat_end;\n \n   pat = process_insert_insn (expr);\n   gcc_assert (pat && INSN_P (pat));\n@@ -2190,7 +2191,7 @@ insert_insn_end_basic_block (struct expr *expr, basic_block bb)\n \tinsn = XEXP (note, 0);\n       else\n \t{\n-\t  rtx maybe_cc0_setter = prev_nonnote_insn (insn);\n+\t  rtx_insn *maybe_cc0_setter = prev_nonnote_insn (insn);\n \t  if (maybe_cc0_setter\n \t      && INSN_P (maybe_cc0_setter)\n \t      && sets_cc0_p (PATTERN (maybe_cc0_setter)))\n@@ -2298,7 +2299,7 @@ pre_edge_insert (struct edge_list *edge_list, struct expr **index_map)\n \t\t       reach the deleted occurrence in BB.  */\n \t\t    if (!bitmap_bit_p (inserted[e], j))\n \t\t      {\n-\t\t\trtx insn;\n+\t\t\trtx_insn *insn;\n \t\t\tedge eg = INDEX_EDGE (edge_list, e);\n \n \t\t\t/* We can't insert anything on an abnormal and\n@@ -2355,7 +2356,7 @@ pre_edge_insert (struct edge_list *edge_list, struct expr **index_map)\n      MEM          <- reaching_reg.  */\n \n static void\n-pre_insert_copy_insn (struct expr *expr, rtx insn)\n+pre_insert_copy_insn (struct expr *expr, rtx_insn *insn)\n {\n   rtx reg = expr->reaching_reg;\n   int regno = REGNO (reg);\n@@ -2478,7 +2479,7 @@ pre_insert_copies (void)\n \n \t    for (avail = expr->avail_occr; avail != NULL; avail = avail->next)\n \t      {\n-\t\trtx insn = avail->insn;\n+\t\trtx_insn *insn = avail->insn;\n \n \t\t/* No need to handle this one if handled already.  */\n \t\tif (avail->copied_p)\n@@ -2509,7 +2510,7 @@ pre_insert_copies (void)\n \n struct set_data\n {\n-  rtx insn;\n+  rtx_insn *insn;\n   const_rtx set;\n   int nsets;\n };\n@@ -2545,7 +2546,7 @@ record_set_data (rtx dest, const_rtx set, void *data)\n }\n \n static const_rtx\n-single_set_gcse (rtx insn)\n+single_set_gcse (rtx_insn *insn)\n {\n   struct set_data s;\n   rtx pattern;\n@@ -2570,7 +2571,7 @@ single_set_gcse (rtx insn)\n    in INSN.  */\n \n static rtx\n-gcse_emit_move_after (rtx dest, rtx src, rtx insn)\n+gcse_emit_move_after (rtx dest, rtx src, rtx_insn *insn)\n {\n   rtx new_rtx;\n   const_rtx set = single_set_gcse (insn);\n@@ -2625,7 +2626,7 @@ pre_delete (void)\n \t/* We only need to search antic_occr since we require ANTLOC != 0.  */\n \tfor (occr = expr->antic_occr; occr != NULL; occr = occr->next)\n \t  {\n-\t    rtx insn = occr->insn;\n+\t    rtx_insn *insn = occr->insn;\n \t    rtx set;\n \t    basic_block bb = BLOCK_FOR_INSN (insn);\n \n@@ -2957,9 +2958,10 @@ compute_code_hoist_data (void)\n    NOTE: Register pressure won't be increased in this function.  */\n \n static int\n-update_bb_reg_pressure (basic_block bb, rtx from)\n+update_bb_reg_pressure (basic_block bb, rtx_insn *from)\n {\n-  rtx dreg, insn;\n+  rtx dreg;\n+  rtx_insn *insn;\n   basic_block succ_bb;\n   df_ref use, op_ref;\n   edge succ;\n@@ -3043,7 +3045,7 @@ static int\n should_hoist_expr_to_dom (basic_block expr_bb, struct expr *expr,\n \t\t\t  basic_block bb, sbitmap visited, int distance,\n \t\t\t  int *bb_size, enum reg_class pressure_class,\n-\t\t\t  int *nregs, bitmap hoisted_bbs, rtx from)\n+\t\t\t  int *nregs, bitmap hoisted_bbs, rtx_insn *from)\n {\n   unsigned int i;\n   edge pred;\n@@ -3239,7 +3241,7 @@ hoist_code (void)\n \n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      rtx insn;\n+      rtx_insn *insn;\n       int to_head;\n \n       to_head = 0;\n@@ -3433,7 +3435,7 @@ hoist_code (void)\n \t\t to hoist to BB and make the transformations.  */\n \t      FOR_EACH_VEC_ELT (occrs_to_hoist, j, occr)\n \t\t{\n-\t\t  rtx insn;\n+\t\t  rtx_insn *insn;\n \t\t  const_rtx set;\n \n \t\t  gcc_assert (!occr->deleted_p);\n@@ -3516,7 +3518,7 @@ get_regno_pressure_class (int regno, int *nregs)\n /* Return pressure class and number of hard registers (through *NREGS)\n    for destination of INSN. */\n static enum reg_class\n-get_pressure_class_and_nregs (rtx insn, int *nregs)\n+get_pressure_class_and_nregs (rtx_insn *insn, int *nregs)\n {\n   rtx reg;\n   enum reg_class pressure_class;\n@@ -3569,7 +3571,7 @@ calculate_bb_reg_pressure (void)\n {\n   int i;\n   unsigned int j;\n-  rtx insn;\n+  rtx_insn *insn;\n   basic_block bb;\n   bitmap curr_regs_live;\n   bitmap_iterator bi;\n@@ -3948,7 +3950,7 @@ compute_ld_motion_mems (void)\n {\n   struct ls_expr * ptr;\n   basic_block bb;\n-  rtx insn;\n+  rtx_insn *insn;\n \n   pre_ldst_mems = NULL;\n   pre_ldst_table = new hash_table<pre_ldst_expr_hasher> (13);"}]}