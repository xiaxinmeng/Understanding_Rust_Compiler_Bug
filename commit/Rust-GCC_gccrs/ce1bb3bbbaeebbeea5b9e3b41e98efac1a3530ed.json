{"sha": "ce1bb3bbbaeebbeea5b9e3b41e98efac1a3530ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2UxYmIzYmJiYWVlYmJlZWE1YjllM2I0MWU5OGVmYWMxYTM1MzBlZA==", "commit": {"author": {"name": "Eric Blake", "email": "ebb9@email.byu.edu", "date": "2003-03-24T00:50:18Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-03-24T00:50:18Z"}, "message": "natStringBuffer.cc (regionMatches): New function.\n\n2003-03-23  Eric Blake  <ebb9@email.byu.edu>\n\n\t* java/lang/natStringBuffer.cc (regionMatches): New function.\n\t* java/lang/String.java (count): Now package-private.\n\t* java/lang/StringBuffer.java: Merged with Classpath.\n\nFrom-SVN: r64770", "tree": {"sha": "6cae07836eef2ed9d18073a8b7e48580e4196f5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cae07836eef2ed9d18073a8b7e48580e4196f5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce1bb3bbbaeebbeea5b9e3b41e98efac1a3530ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce1bb3bbbaeebbeea5b9e3b41e98efac1a3530ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce1bb3bbbaeebbeea5b9e3b41e98efac1a3530ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce1bb3bbbaeebbeea5b9e3b41e98efac1a3530ed/comments", "author": null, "committer": null, "parents": [{"sha": "fc3703e35c1769b71d838064d05075b1e106c2a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc3703e35c1769b71d838064d05075b1e106c2a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc3703e35c1769b71d838064d05075b1e106c2a0"}], "stats": {"total": 1201, "additions": 696, "deletions": 505}, "files": [{"sha": "13649bd6ca96cfe2fb3fb098426afb909a01ec64", "filename": "libjava/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1bb3bbbaeebbeea5b9e3b41e98efac1a3530ed/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1bb3bbbaeebbeea5b9e3b41e98efac1a3530ed/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=ce1bb3bbbaeebbeea5b9e3b41e98efac1a3530ed", "patch": "@@ -1,3 +1,9 @@\n+2003-03-23  Eric Blake  <ebb9@email.byu.edu>\n+\n+\t* java/lang/natStringBuffer.cc (regionMatches): New function.\n+\t* java/lang/String.java (count): Now package-private.\n+\t* java/lang/StringBuffer.java: Merged with Classpath.\n+\n 2003-03-23  Michael Koch  <konqueror@gmx.de>\n \n \t* java/io/BufferedOutputStream.java:"}, {"sha": "17b5dabd9773a5897dc256a85ab1cee5ba76b18d", "filename": "libjava/java/lang/String.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1bb3bbbaeebbeea5b9e3b41e98efac1a3530ed/libjava%2Fjava%2Flang%2FString.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1bb3bbbaeebbeea5b9e3b41e98efac1a3530ed/libjava%2Fjava%2Flang%2FString.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FString.java?ref=ce1bb3bbbaeebbeea5b9e3b41e98efac1a3530ed", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1998, 1999, 2000, 2001, 2002  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -26,7 +26,7 @@ public final class String implements Serializable, Comparable, CharSequence\n {\n   private Object data;\n   private int boffset; // Note this is a byte offset - don't use in Java code!\n-  private int count;\n+  int count;\n \n   // This is probably not necessary because this class is special cased already\n   // but it will avoid showing up as a discrepancy when comparing SUIDs."}, {"sha": "fac7892524e8087a91d14ebdbb9b03348e1bbe45", "filename": "libjava/java/lang/StringBuffer.java", "status": "modified", "additions": 675, "deletions": 502, "changes": 1177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1bb3bbbaeebbeea5b9e3b41e98efac1a3530ed/libjava%2Fjava%2Flang%2FStringBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1bb3bbbaeebbeea5b9e3b41e98efac1a3530ed/libjava%2Fjava%2Flang%2FStringBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FStringBuffer.java?ref=ce1bb3bbbaeebbeea5b9e3b41e98efac1a3530ed", "patch": "@@ -1,13 +1,13 @@\n /* StringBuffer.java -- Growable strings\n-   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -36,276 +36,194 @@\n exception statement from your version. */\n \n package java.lang;\n-import java.io.Serializable;\n \n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * Updated using online JDK 1.2 docs.\n- * Believed complete and correct to JDK 1.2.\n- * Merged with Classpath.\n- */\n+import java.io.Serializable;\n \n /**\n  * <code>StringBuffer</code> represents a changeable <code>String</code>.\n  * It provides the operations required to modify the\n- * <code>StringBuffer</code> including insert, replace, delete, append,\n- * and reverse.\n- * <P>\n+ * <code>StringBuffer</code>, including insert, replace, delete, append,\n+ * and reverse. It is thread-safe; meaning that all modifications to a buffer\n+ * are in synchronized methods.\n  *\n- * <code>StringBuffer</code>s are variable-length in nature, so even if\n+ * <p><code>StringBuffer</code>s are variable-length in nature, so even if\n  * you initialize them to a certain size, they can still grow larger than\n- * that.  <EM>Capacity</EM> indicates the number of characters the\n+ * that. <em>Capacity</em> indicates the number of characters the\n  * <code>StringBuffer</code> can have in it before it has to grow (growing\n  * the char array is an expensive operation involving <code>new</code>).\n- * <P>\n  *\n- * Incidentally, the String operator \"+\" actually is turned into a\n- * <code>StringBuffer</code> operation:\n- * <BR>\n- * <code>a + b</code>\n- * <BR>\n- * is the same as\n- * <BR>\n- * <code>new StringBuffer(a).append(b).toString()</code>.\n+ * <p>Incidentally, compilers often implement the String operator \"+\"\n+ * by using a <code>StringBuffer</code> operation:<br>\n+ * <code>a + b</code><br>\n+ * is the same as<br>\n+ * <code>new StringBuffer().append(a).append(b).toString()</code>.\n  *\n- * @implnote Classpath's StringBuffer is capable of sharing memory with\n- *           Strings for efficiency.  This will help in two instances:\n- *           first, when a StringBuffer is created from a String but is\n- *           never changed, and second, when a StringBuffer is converted\n- *           to a String and the StringBuffer is not changed after that.\n+ * <p>Classpath's StringBuffer is capable of sharing memory with Strings for\n+ * efficiency.  This will help when a StringBuffer is converted to a String\n+ * and the StringBuffer is not changed after that (quite common when performing\n+ * string concatenation).\n  *\n- * @since JDK1.0\n  * @author Paul Fisher\n  * @author John Keiser\n  * @author Tom Tromey\n- * @see java.lang.String\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @see String\n+ * @since 1.0\n+ * @status updated to 1.4\n  */\n public final class StringBuffer implements Serializable, CharSequence\n {\n-  /** Append the <code>String</code> value of the argument to this <code>StringBuffer</code>.\n-   *  Uses <code>String.valueOf()</code> to convert to\n-   *  <code>String</code>.\n-   *  @param bool the <code>boolean</code> to convert and append.\n-   *  @return this <code>StringBuffer</code>.\n-   *  @see java.lang.String#valueOf(boolean)\n+  /**\n+   * Compatible with JDK 1.0+.\n    */\n-  public StringBuffer append (boolean bool)\n-  {\n-    return append (String.valueOf(bool));\n-  }\n+  private static final long serialVersionUID = 3388685877147921107L;\n \n-  /** Append the <code>char</code> to this <code>StringBuffer</code>.\n-   *  @param c the <code>char</code> to append.\n-   *  @return this <code>StringBuffer</code>.\n+  /**\n+   * Index of next available character (and thus the size of the current\n+   * string contents).  Note that this has permissions set this way so that\n+   * String can get the value.\n+   *\n+   * @serial the number of characters in the buffer\n    */\n-  public synchronized StringBuffer append (char ch)\n-  {\n-    ensureCapacity_unsynchronized (count + 1);\n-    value[count++] = ch;\n-    return this;\n-  }\n+  int count;\n \n-  /** Append the <code>String</code> value of the argument to this <code>StringBuffer</code>.\n-   *  Uses <code>String.valueOf()</code> to convert to\n-   *  <code>String</code>.\n-   *  @param inum the <code>int</code> to convert and append.\n-   *  @return this <code>StringBuffer</code>.\n-   *  @see java.lang.String#valueOf(int)\n+  /**\n+   * The buffer.  Note that this has permissions set this way so that String\n+   * can get the value.\n+   *\n+   * @serial the buffer\n    */\n-  public native StringBuffer append (int inum);\n+  char[] value;\n \n-  /** Append the <code>String</code> value of the argument to this <code>StringBuffer</code>.\n-   *  Uses <code>String.valueOf()</code> to convert to\n-   *  <code>String</code>.\n-   *  @param lnum the <code>long</code> to convert and append.\n-   *  @return this <code>StringBuffer</code>.\n-   *  @see java.lang.String#valueOf(long)\n+  /**\n+   * True if the buffer is shared with another object (StringBuffer or\n+   * String); this means the buffer must be copied before writing to it again.\n+   * Note that this has permissions set this way so that String can get the\n+   * value.\n+   *\n+   * @serial whether the buffer is shared\n    */\n-  public StringBuffer append (long lnum)\n-  {\n-    return append (String.valueOf(lnum));\n-  }\n+  boolean shared;\n \n-  /** Append the <code>String</code> value of the argument to this <code>StringBuffer</code>.\n-   *  Uses <code>String.valueOf()</code> to convert to\n-   *  <code>String</code>.\n-   *  @param fnum the <code>float</code> to convert and append.\n-   *  @return this <code>StringBuffer</code>.\n-   *  @see java.lang.String#valueOf(float)\n+  /**\n+   * The default capacity of a buffer.\n    */\n-  public StringBuffer append (float fnum)\n-  {\n-    return append (String.valueOf(fnum));\n-  }\n+  private final static int DEFAULT_CAPACITY = 16;\n \n-  /** Append the <code>String</code> value of the argument to this <code>StringBuffer</code>.\n-   *  Uses <code>String.valueOf()</code> to convert to\n-   *  <code>String</code>.\n-   *  @param dnum the <code>double</code> to convert and append.\n-   *  @return this <code>StringBuffer</code>.\n-   *  @see java.lang.String#valueOf(double)\n+  /**\n+   * Create a new StringBuffer with default capacity 16.\n    */\n-  public StringBuffer append (double dnum)\n+  public StringBuffer()\n   {\n-    return append (String.valueOf(dnum));\n+    this(DEFAULT_CAPACITY);\n   }\n \n-  /** Append the <code>String</code> value of the argument to this <code>StringBuffer</code>.\n-   *  Uses <code>String.valueOf()</code> to convert to\n-   *  <code>String</code>.\n-   *  @param obj the <code>Object</code> to convert and append.\n-   *  @return this <code>StringBuffer</code>.\n-   *  @see java.lang.String#valueOf(java.lang.Object)\n+  /**\n+   * Create an empty <code>StringBuffer</code> with the specified initial\n+   * capacity.\n+   *\n+   * @param capacity the initial capacity\n+   * @throws NegativeArraySizeException if capacity is negative\n    */\n-  public StringBuffer append (Object obj)\n+  public StringBuffer(int capacity)\n   {\n-    return append (String.valueOf(obj));\n+    value = new char[capacity];\n   }\n \n-  /** Append the <code>String</code> to this <code>StringBuffer</code>.\n-   *  @param str the <code>String</code> to append.\n-   *  @return this <code>StringBuffer</code>.\n+  /**\n+   * Create a new <code>StringBuffer</code> with the characters in the\n+   * specified <code>String</code>. Initial capacity will be the size of the\n+   * String plus 16.\n+   *\n+   * @param str the <code>String</code> to convert\n+   * @throws NullPointerException if str is null\n    */\n-  public synchronized StringBuffer append (String str)\n+  public StringBuffer(String str)\n   {\n-    if (str == null)\n-      str = \"null\";\n-    int len = str.length();\n-    ensureCapacity_unsynchronized (count + len);\n-    str.getChars(0, len, value, count);\n-    count += len;\n-    return this;\n+    // Unfortunately, because the size is 16 larger, we cannot share.\n+    count = str.count;\n+    value = new char[count + DEFAULT_CAPACITY];\n+    str.getChars(0, count, value, 0);\n   }\n \n-  /** Append the <code>char</code> array to this <code>StringBuffer</code>.\n-   *  @param data the <code>char[]</code> to append.\n-   *  @return this <code>StringBuffer</code>.\n-   *  @exception NullPointerException if <code>str</code> is <code>null</code>.\n+  /**\n+   * Get the length of the <code>String</code> this <code>StringBuffer</code>\n+   * would create. Not to be confused with the <em>capacity</em> of the\n+   * <code>StringBuffer</code>.\n+   *\n+   * @return the length of this <code>StringBuffer</code>\n+   * @see #capacity()\n+   * @see #setLength(int)\n    */\n-  public StringBuffer append (char[] data)\n+  public synchronized int length()\n   {\n-    return append (data, 0, data.length);\n+    return count;\n   }\n \n-  /** Append the <code>char</code> array to this <code>StringBuffer</code>.\n-   *  @param data the <code>char[]</code> to append.\n-   *  @param offset the place to start grabbing characters from\n-   *         <code>str</code>.\n-   *  @param count the number of characters to get from <code>str</code>.\n-   *  @return this <code>StringBuffer</code>.\n-   *  @exception NullPointerException if <code>str</code> is <code>null</code>.\n-   *  @exception IndexOutOfBoundsException if <code>offset</code> or\n-   *             <code>offset+len</code> is out of range.\n-   */\n-  public synchronized StringBuffer append (char[] data, int offset, int count)\n-  {\n-    ensureCapacity_unsynchronized (this.count + count);\n-    System.arraycopy(data, offset, value, this.count, count);\n-    this.count += count;\n-    return this;\n-  } \n-\n-  /** Get the total number of characters this <code>StringBuffer</code>\n-   *  can support before it must be grown.  Not to be confused with\n-   *  <em>length</em>.\n-   *  @return the capacity of this <code>StringBuffer</code>\n-   *  @see #length()\n-   *  @see #ensureCapacity(int)\n+  /**\n+   * Get the total number of characters this <code>StringBuffer</code> can\n+   * support before it must be grown.  Not to be confused with <em>length</em>.\n+   *\n+   * @return the capacity of this <code>StringBuffer</code>\n+   * @see #length()\n+   * @see #ensureCapacity(int)\n    */\n-  public int capacity ()\n+  public synchronized int capacity()\n   {\n     return value.length;\n   }\n \n-  /** Get the character at the specified index.\n-   *  @param index the index of the character to get, starting at 0.\n-   *  @return the character at the specified index.\n-   *  @exception IndexOutOfBoundsException if the desired character index\n-   *             is negative or greater then length() - 1.\n+  /**\n+   * Increase the capacity of this <code>StringBuffer</code>. This will\n+   * ensure that an expensive growing operation will not occur until\n+   * <code>minimumCapacity</code> is reached. The buffer is grown to the\n+   * larger of <code>minimumCapacity</code> and\n+   * <code>capacity() * 2 + 2</code>, if it is not already large enough.\n+   *\n+   * @param minimumCapacity the new capacity\n+   * @see #capacity()\n    */\n-  public synchronized char charAt (int index)\n+  public synchronized void ensureCapacity(int minimumCapacity)\n   {\n-    if (index >= count)\n-      throw new StringIndexOutOfBoundsException (index);\n-    return value[index];\n+    ensureCapacity_unsynchronized(minimumCapacity);\n   }\n \n-  /** Delete characters from this <code>StringBuffer</code>.\n-   *  <code>delete(10, 12)</code> will delete 10 and 11, but not 12.\n-   *  @param start the first character to delete.\n-   *  @param end the index after the last character to delete.\n-   *  @return this <code>StringBuffer</code>.\n-   *  @exception StringIndexOutOfBoundsException if <code>start</code>\n-   *             or <code>end-1</code> are out of bounds, or if\n-   *             <code>start > end</code>.\n+  /**\n+   * Set the length of this StringBuffer. If the new length is greater than\n+   * the current length, all the new characters are set to '\\0'. If the new\n+   * length is less than the current length, the first <code>newLength</code>\n+   * characters of the old array will be preserved, and the remaining\n+   * characters are truncated.\n+   *\n+   * @param newLength the new length\n+   * @throws IndexOutOfBoundsException if the new length is negative\n+   *         (while unspecified, this is a StringIndexOutOfBoundsException)\n+   * @see #length()\n    */\n-  public synchronized StringBuffer delete (int start, int end)\n+  public synchronized void setLength(int newLength)\n   {\n-    if (start < 0 || start > count || start > end)\n-      throw new StringIndexOutOfBoundsException (start);\n-    if (end > count)\n-      end = count;\n-    // This will unshare if required.\n-    ensureCapacity_unsynchronized (count);\n-    if (count - end != 0)\n-      System.arraycopy (value, end, value, start, count - end);\n-    count -= (end - start);\n-    return this;\n-  }\n+    if (newLength < 0)\n+      throw new StringIndexOutOfBoundsException(newLength);\n \n-  /** Delete a character from this <code>StringBuffer</code>.\n-   *  @param index the index of the character to delete.\n-   *  @return this <code>StringBuffer</code>.\n-   *  @exception StringIndexOutOfBoundsException if <code>index</code>\n-   *             is out of bounds.\n-   */\n-  public StringBuffer deleteCharAt(int index)\n-  {\n-    return delete (index, index + 1);\n+    ensureCapacity_unsynchronized(newLength);\n+    while (count < newLength)\n+      value[count++] = '\\0';\n+    count = newLength;\n   }\n \n-  /** Increase the capacity of this <code>StringBuffer</code>.\n-   *  This will ensure that an expensive growing operation will not occur\n-   *  until <code>minimumCapacity</code> is reached.\n-   *  If the capacity is actually already greater than <code>minimumCapacity</code>\n-   *  @param minimumCapacity the new capacity.\n-   *  @see #capacity()\n+  /**\n+   * Get the character at the specified index.\n+   *\n+   * @param index the index of the character to get, starting at 0\n+   * @return the character at the specified index\n+   * @throws IndexOutOfBoundsException if index is negative or &gt;= length()\n+   *         (while unspecified, this is a StringIndexOutOfBoundsException)\n    */\n-  public synchronized void ensureCapacity (int minimumCapacity)\n+  public synchronized char charAt(int index)\n   {\n-    if (shared || minimumCapacity > value.length)\n-      {\n-\t// We don't want to make a larger vector when `shared' is\n-\t// set.  If we do, then setLength becomes very inefficient\n-\t// when repeatedly reusing a StringBuffer in a loop.\n-\tint max = (minimumCapacity > value.length\n-\t\t   ? value.length*2+2\n-\t\t   : value.length);\n-\tminimumCapacity = (minimumCapacity < max ? max : minimumCapacity);\n-\tchar[] nb = new char[minimumCapacity];\n-\tSystem.arraycopy(value, 0, nb, 0, count);\n-\tvalue = nb;\n-\tshared = false;\n-      }\n-  }\n-\n-  // ensureCapacity is used by several synchronized methods in StringBuffer.\n-  // There's no need to synchronize again.\n-  private void ensureCapacity_unsynchronized (int minimumCapacity)\n-  {\n-    if (shared || minimumCapacity > value.length)\n-      {\n-\t// We don't want to make a larger vector when `shared' is\n-\t// set.  If we do, then setLength becomes very inefficient\n-\t// when repeatedly reusing a StringBuffer in a loop.\n-\tint max = (minimumCapacity > value.length\n-\t\t   ? value.length*2+2\n-\t\t   : value.length);\n-\tminimumCapacity = (minimumCapacity < max ? max : minimumCapacity);\n-\tchar[] nb = new char[minimumCapacity];\n-\tSystem.arraycopy(value, 0, nb, 0, count);\n-\tvalue = nb;\n-\tshared = false;\n-      }\n+    if (index < 0 || index >= count)\n+      throw new StringIndexOutOfBoundsException(index);\n+    return value[index];\n   }\n \n   /**\n@@ -332,397 +250,652 @@ public synchronized void getChars(int srcOffset, int srcEnd,\n     System.arraycopy(value, srcOffset, dst, dstOffset, todo);\n   }\n \n-  /** Insert the <code>String</code> value of the argument into this <code>StringBuffer</code>.\n-   *  Uses <code>String.valueOf()</code> to convert to\n-   *  <code>String</code>.\n-   *  @param offset the place to insert.\n-   *  @param bool the <code>boolean</code> to convert and insert.\n-   *  @return this <code>StringBuffer</code>.\n-   *  @exception IndexOutOfBoundsException if <code>offset</code> is out\n-   *             of range for this <code>StringBuffer</code>.\n-   *  @see java.lang.String#valueOf(boolean)\n+  /**\n+   * Set the character at the specified index.\n+   *\n+   * @param index the index of the character to set starting at 0\n+   * @param ch the value to set that character to\n+   * @throws IndexOutOfBoundsException if index is negative or &gt;= length()\n+   *         (while unspecified, this is a StringIndexOutOfBoundsException)\n    */\n-  public StringBuffer insert (int offset, boolean bool)\n+  public synchronized void setCharAt(int index, char ch)\n   {\n-    return insert (offset, bool ? \"true\" : \"false\");\n+    if (index < 0 || index >= count)\n+      throw new StringIndexOutOfBoundsException(index);\n+    // Call ensureCapacity to enforce copy-on-write.\n+    ensureCapacity_unsynchronized(count);\n+    value[index] = ch;\n   }\n \n-  /** Insert the <code>char</code> argument into this <code>StringBuffer</code>.\n-   *  @param offset the place to insert.\n-   *  @param ch the <code>char</code> to insert.\n-   *  @return this <code>StringBuffer</code>.\n-   *  @exception IndexOutOfBoundsException if <code>offset</code> is out\n-   *             of range for this <code>StringBuffer</code>.\n+  /**\n+   * Append the <code>String</code> value of the argument to this\n+   * <code>StringBuffer</code>. Uses <code>String.valueOf()</code> to convert\n+   * to <code>String</code>.\n+   *\n+   * @param obj the <code>Object</code> to convert and append\n+   * @return this <code>StringBuffer</code>\n+   * @see String#valueOf(Object)\n+   * @see #append(String)\n    */\n-  public synchronized StringBuffer insert (int offset, char ch)\n+  public StringBuffer append(Object obj)\n   {\n-    if (offset < 0 || offset > count)\n-      throw new StringIndexOutOfBoundsException (offset);\n-    ensureCapacity_unsynchronized (count+1);\n-    System.arraycopy(value, offset, value, offset+1, count-offset);\n-    value[offset] = ch;\n-    count++;\n-    return this;\n+    return append(obj == null ? \"null\" : obj.toString());\n   }\n \n-  /** Insert the <code>String</code> value of the argument into this <code>StringBuffer</code>.\n-   *  Uses <code>String.valueOf()</code> to convert to\n-   *  <code>String</code>.\n-   *  @param offset the place to insert.\n-   *  @param inum the <code>int</code> to convert and insert.\n-   *  @return this <code>StringBuffer</code>.\n-   *  @exception IndexOutOfBoundsException if <code>offset</code> is out\n-   *             of range for this <code>StringBuffer</code>.\n-   *  @see java.lang.String#valueOf(int)\n+  /**\n+   * Append the <code>String</code> to this <code>StringBuffer</code>. If\n+   * str is null, the String \"null\" is appended.\n+   *\n+   * @param str the <code>String</code> to append\n+   * @return this <code>StringBuffer</code>\n    */\n-  public StringBuffer insert (int offset, int inum)\n+  public synchronized StringBuffer append(String str)\n   {\n-    return insert (offset, String.valueOf(inum));\n+    if (str == null)\n+      str = \"null\";\n+    int len = str.count;\n+    ensureCapacity_unsynchronized(count + len);\n+    str.getChars(0, len, value, count);\n+    count += len;\n+    return this;\n   }\n \n-  /** Insert the <code>String</code> value of the argument into this <code>StringBuffer</code>.\n-   *  Uses <code>String.valueOf()</code> to convert to\n-   *  <code>String</code>.\n-   *  @param offset the place to insert.\n-   *  @param lnum the <code>long</code> to convert and insert.\n-   *  @return this <code>StringBuffer</code>.\n-   *  @exception IndexOutOfBoundsException if <code>offset</code> is out\n-   *             of range for this <code>StringBuffer</code>.\n-   *  @see java.lang.String#valueOf(long)\n+  /**\n+   * Append the <code>StringBuffer</code> value of the argument to this\n+   * <code>StringBuffer</code>. This behaves the same as\n+   * <code>append((Object) stringBuffer)</code>, except it is more efficient.\n+   *\n+   * @param stringBuffer the <code>StringBuffer</code> to convert and append\n+   * @return this <code>StringBuffer</code>\n+   * @see #append(Object)\n+   * @since 1.4\n    */\n-  public StringBuffer insert (int offset, long lnum)\n+  public synchronized StringBuffer append(StringBuffer stringBuffer)\n   {\n-    return insert (offset, String.valueOf(lnum));\n+    if (stringBuffer == null)\n+      return append(\"null\");\n+    synchronized (stringBuffer)\n+      {\n+        int len = stringBuffer.count;\n+        ensureCapacity_unsynchronized(count + len);\n+        System.arraycopy(stringBuffer.value, 0, value, count, len);\n+        count += len;\n+      }\n+    return this;\n   }\n \n-  /** Insert the <code>String</code> value of the argument into this <code>StringBuffer</code>.\n-   *  Uses <code>String.valueOf()</code> to convert to\n-   *  <code>String</code>.\n-   *  @param offset the place to insert.\n-   *  @param fnum the <code>float</code> to convert and insert.\n-   *  @return this <code>StringBuffer</code>.\n-   *  @exception IndexOutOfBoundsException if <code>offset</code> is out\n-   *             of range for this <code>StringBuffer</code>.\n-   *  @see java.lang.String#valueOf(float)\n+  /**\n+   * Append the <code>char</code> array to this <code>StringBuffer</code>.\n+   * This is similar (but more efficient) than\n+   * <code>append(new String(data))</code>, except in the case of null.\n+   *\n+   * @param data the <code>char[]</code> to append\n+   * @return this <code>StringBuffer</code>\n+   * @throws NullPointerException if <code>str</code> is <code>null</code>\n+   * @see #append(char[], int, int)\n    */\n-  public StringBuffer insert (int offset, float fnum)\n+  public StringBuffer append(char[] data)\n   {\n-    return insert (offset, String.valueOf(fnum));\n+    return append(data, 0, data.length);\n   }\n \n-  /** Insert the <code>String</code> value of the argument into this <code>StringBuffer</code>.\n-   *  Uses <code>String.valueOf()</code> to convert to\n-   *  <code>String</code>.\n-   *  @param offset the place to insert.\n-   *  @param dnum the <code>double</code> to convert and insert.\n-   *  @return this <code>StringBuffer</code>.\n-   *  @exception IndexOutOfBoundsException if <code>offset</code> is out\n-   *             of range for this <code>StringBuffer</code>.\n-   *  @see java.lang.String#valueOf(double)\n+  /**\n+   * Append part of the <code>char</code> array to this\n+   * <code>StringBuffer</code>. This is similar (but more efficient) than\n+   * <code>append(new String(data, offset, count))</code>, except in the case\n+   * of null.\n+   *\n+   * @param data the <code>char[]</code> to append\n+   * @param offset the start location in <code>str</code>\n+   * @param count the number of characters to get from <code>str</code>\n+   * @return this <code>StringBuffer</code>\n+   * @throws NullPointerException if <code>str</code> is <code>null</code>\n+   * @throws IndexOutOfBoundsException if offset or count is out of range\n+   *         (while unspecified, this is a StringIndexOutOfBoundsException)\n    */\n-  public StringBuffer insert (int offset, double dnum)\n+  public synchronized StringBuffer append(char[] data, int offset, int count)\n   {\n-    return insert (offset, String.valueOf(dnum));\n+    ensureCapacity_unsynchronized(this.count + count);\n+    System.arraycopy(data, offset, value, this.count, count);\n+    this.count += count;\n+    return this;\n   }\n \n-  /** Insert the <code>String</code> value of the argument into this <code>StringBuffer</code>.\n-   *  Uses <code>String.valueOf()</code> to convert to\n-   *  <code>String</code>.\n-   *  @param offset the place to insert.\n-   *  @param obj the <code>Object</code> to convert and insert.\n-   *  @return this <code>StringBuffer</code>.\n-   *  @exception IndexOutOfBoundsException if <code>offset</code> is out\n-   *             of range for this <code>StringBuffer</code>.\n-   *  @see java.lang.String#valueOf(java.lang.Object)\n+  /**\n+   * Append the <code>String</code> value of the argument to this\n+   * <code>StringBuffer</code>. Uses <code>String.valueOf()</code> to convert\n+   * to <code>String</code>.\n+   *\n+   * @param bool the <code>boolean</code> to convert and append\n+   * @return this <code>StringBuffer</code>\n+   * @see String#valueOf(boolean)\n    */\n-  public StringBuffer insert (int offset, Object obj)\n+  public StringBuffer append(boolean bool)\n   {\n-    return insert (offset, String.valueOf(obj));\n+    return append(bool ? \"true\" : \"false\");\n   }\n \n-  /** Insert the <code>String</code> argument into this <code>StringBuffer</code>.\n-   *  @param offset the place to insert.\n-   *  @param str the <code>String</code> to insert.\n-   *  @return this <code>StringBuffer</code>.\n-   *  @exception IndexOutOfBoundsException if <code>offset</code> is out\n-   *             of range for this <code>StringBuffer</code>.\n+  /**\n+   * Append the <code>char</code> to this <code>StringBuffer</code>.\n+   *\n+   * @param c the <code>char</code> to append\n+   * @return this <code>StringBuffer</code>\n    */\n-  public synchronized StringBuffer insert (int offset, String str)\n+  public synchronized StringBuffer append(char ch)\n   {\n-    if (offset < 0 || offset > count)\n-      throw new StringIndexOutOfBoundsException (offset);\n-    // Note that using `null' is from JDK 1.2.\n-    if (str == null)\n-      str = \"null\";\n-    int len = str.length();\n-    ensureCapacity_unsynchronized (count+len);\n-    System.arraycopy(value, offset, value, offset+len, count-offset);\n-    str.getChars(0, len, value, offset);\n-    count += len;\n+    ensureCapacity_unsynchronized(count + 1);\n+    value[count++] = ch;\n     return this;\n   }\n \n-  /** Insert the <code>char[]</code> argument into this\n-   *  <code>StringBuffer</code>. \n-   *  @param offset the place to insert.\n-   *  @param data the <code>char[]</code> to insert.\n-   *  @return this <code>StringBuffer</code>.\n-   *  @exception NullPointerException if <code>data</code> is\n-   *             <code>null</code>.\n-   *  @exception IndexOutOfBoundsException if <code>offset</code> is out\n-   *             of range for this <code>StringBuffer</code>.\n-   */\n-  public StringBuffer insert (int offset, char[] data)\n-  {\n-    // One could check if offset is invalid here instead of making sure that\n-    // data isn't null before dereferencing, but this works just as well.\n-    return insert (offset, data, 0, data == null ? 0 : data.length);\n-  }\n-\n-  /** Insert the <code>char[]</code> argument into this\n-   *  <code>StringBuffer</code>.\n-   *  @param offset the place to insert.\n-   *  @param str the <code>char[]</code> to insert.\n-   *  @param str_offset the index in <code>str</code> to start inserting\n-   *         from.\n-   *  @param len the number of characters to insert.\n-   *  @return this <code>StringBuffer</code>.\n-   *  @exception NullPointerException if <code>str</code> is <code>null</code>.\n-   *  @exception IndexOutOfBoundsException if <code>offset</code> is out\n-   *             of range, for this <code>StringBuffer</code>, or if\n-   *             <code>str_offset</code> or <code>str_offset+len</code>\n-   *             are out of range for <code>str</code>.\n-   */\n-  public synchronized StringBuffer insert(int offset, char[] str,\n-\t\t\t\t\t  int str_offset, int len)\n+  /**\n+   * Append the <code>String</code> value of the argument to this\n+   * <code>StringBuffer</code>. Uses <code>String.valueOf()</code> to convert\n+   * to <code>String</code>.\n+   *\n+   * @param inum the <code>int</code> to convert and append\n+   * @return this <code>StringBuffer</code>\n+   * @see String#valueOf(int)\n+   */\n+  // GCJ LOCAL: this is native for efficiency.\n+  public native StringBuffer append (int inum);\n+\n+  /**\n+   * Append the <code>String</code> value of the argument to this\n+   * <code>StringBuffer</code>. Uses <code>String.valueOf()</code> to convert\n+   * to <code>String</code>.\n+   *\n+   * @param lnum the <code>long</code> to convert and append\n+   * @return this <code>StringBuffer</code>\n+   * @see String#valueOf(long)\n+   */\n+  public StringBuffer append(long lnum)\n   {\n-    if (offset < 0 || offset > count)\n-      throw new StringIndexOutOfBoundsException (offset);\n-    if (len < 0)\n-      throw new StringIndexOutOfBoundsException (len);\n-    if (str_offset < 0 || str_offset + len > str.length)\n-      throw new StringIndexOutOfBoundsException (str_offset);\n-    ensureCapacity_unsynchronized (count + len);\n-    System.arraycopy(value, offset, value, offset + len, count - offset);\n-    System.arraycopy(str, str_offset, value, offset, len);\n-    count += len;\n+    return append(Long.toString(lnum, 10));\n+  }\n+\n+  /**\n+   * Append the <code>String</code> value of the argument to this\n+   * <code>StringBuffer</code>. Uses <code>String.valueOf()</code> to convert\n+   * to <code>String</code>.\n+   *\n+   * @param fnum the <code>float</code> to convert and append\n+   * @return this <code>StringBuffer</code>\n+   * @see String#valueOf(float)\n+   */\n+  public StringBuffer append(float fnum)\n+  {\n+    return append(Float.toString(fnum));\n+  }\n+\n+  /**\n+   * Append the <code>String</code> value of the argument to this\n+   * <code>StringBuffer</code>. Uses <code>String.valueOf()</code> to convert\n+   * to <code>String</code>.\n+   *\n+   * @param dnum the <code>double</code> to convert and append\n+   * @return this <code>StringBuffer</code>\n+   * @see String#valueOf(double)\n+   */\n+  public StringBuffer append(double dnum)\n+  {\n+    return append(Double.toString(dnum));\n+  }\n+\n+  /**\n+   * Delete characters from this <code>StringBuffer</code>.\n+   * <code>delete(10, 12)</code> will delete 10 and 11, but not 12. It is\n+   * harmless for end to be larger than length().\n+   *\n+   * @param start the first character to delete\n+   * @param end the index after the last character to delete\n+   * @return this <code>StringBuffer</code>\n+   * @throws StringIndexOutOfBoundsException if start or end are out of bounds\n+   * @since 1.2\n+   */\n+  public synchronized StringBuffer delete(int start, int end)\n+  {\n+    if (start < 0 || start > count || start > end)\n+      throw new StringIndexOutOfBoundsException(start);\n+    if (end > count)\n+      end = count;\n+    // This will unshare if required.\n+    ensureCapacity_unsynchronized(count);\n+    if (count - end != 0)\n+      System.arraycopy(value, end, value, start, count - end);\n+    count -= end - start;\n     return this;\n   }\n \n-  /** Get the length of the <code>String</code> this\n-   *  <code>StringBuffer</code> would create.  Not to be confused with the\n-   *  <em>capacity</em> of the <code>StringBuffer</code>.\n-   *  @return the length of this <code>StringBuffer</code>.\n-   *  @see #capacity()\n-   *  @see #setLength(int)\n+  /**\n+   * Delete a character from this <code>StringBuffer</code>.\n+   *\n+   * @param index the index of the character to delete\n+   * @return this <code>StringBuffer</code>\n+   * @throws StringIndexOutOfBoundsException if index is out of bounds\n+   * @since 1.2\n    */\n-  public int length ()\n+  public StringBuffer deleteCharAt(int index)\n   {\n-    return count;\n+    return delete(index, index + 1);\n   }\n \n-  /** Replace characters between index <code>start</code> (inclusive) and \n-   *  <code>end</code> (exclusive) with <code>str</code>. If <code>end</code> \n-   *  is larger than the size of this StringBuffer, all characters after\n-   *  <code>start</code> are replaced.\n-   *  @param start the beginning index of characters to delete (inclusive).\n-   *  @param end the ending index of characters to delete (exclusive).\n-   *  @param str the new <code>String</code> to insert.\n-   *  @return this <code>StringBuffer</code>.\n+  /**\n+   * Replace characters between index <code>start</code> (inclusive) and\n+   * <code>end</code> (exclusive) with <code>str</code>. If <code>end</code>\n+   * is larger than the size of this StringBuffer, all characters after\n+   * <code>start</code> are replaced.\n+   *\n+   * @param start the beginning index of characters to delete (inclusive)\n+   * @param end the ending index of characters to delete (exclusive)\n+   * @param str the new <code>String</code> to insert\n+   * @return this <code>StringBuffer</code>\n+   * @throws StringIndexOutOfBoundsException if start or end are out of bounds\n+   * @throws NullPointerException if str is null\n+   * @since 1.2\n    */\n-  public synchronized StringBuffer replace (int start, int end, String str)\n+  public synchronized StringBuffer replace(int start, int end, String str)\n   {\n     if (start < 0 || start > count || start > end)\n-      throw new StringIndexOutOfBoundsException (start);\n-  \n-    int len = str.length();\n+      throw new StringIndexOutOfBoundsException(start);\n+\n+    int len = str.count;\n     // Calculate the difference in 'count' after the replace.\n-    int delta = len - ((end > count ? count : end) - start);\n-    ensureCapacity_unsynchronized (count + delta);\n-        \n+    int delta = len - (end > count ? count : end) + start;\n+    ensureCapacity_unsynchronized(count + delta);\n+\n     if (delta != 0 && end < count)\n       System.arraycopy(value, end, value, end + delta, count - end);\n-    \n-    str.getChars (0, len, value, start);    \n-    count += delta;    \n-    return this;    \n+\n+    str.getChars(0, len, value, start);\n+    count += delta;\n+    return this;\n   }\n \n-  /** Reverse the characters in this StringBuffer.\n-   *  @return this <code>StringBuffer</code>.\n+  /**\n+   * Creates a substring of this StringBuffer, starting at a specified index\n+   * and ending at the end of this StringBuffer.\n+   *\n+   * @param beginIndex index to start substring (base 0)\n+   * @return new String which is a substring of this StringBuffer\n+   * @throws StringIndexOutOfBoundsException if beginIndex is out of bounds\n+   * @see #substring(int, int)\n+   * @since 1.2\n    */\n-  public synchronized StringBuffer reverse ()\n+  public String substring(int beginIndex)\n   {\n-    // Call ensureCapacity to enforce copy-on-write.\n-    ensureCapacity_unsynchronized (count);\n-    for (int i = 0; i < count / 2; ++i)\n-      {\n-\tchar c = value[i];\n-\tvalue[i] = value[count - i - 1];\n-\tvalue[count - i - 1] = c;\n-      }\n-    return this;\n+    return substring(beginIndex, count);\n   }\n \n-  /** Set the character at the specified index.\n-   *  @param index the index of the character to set starting at 0.\n-   *  @param ch the value to set that character to.\n-   *  @exception IndexOutOfBoundsException if the specified character\n-   *             index is not between 0 and length() - 1 (inclusive).\n+  /**\n+   * Creates a substring of this StringBuffer, starting at a specified index\n+   * and ending at one character before a specified index. This is implemented\n+   * the same as <code>substring(beginIndex, endIndex)</code>, to satisfy\n+   * the CharSequence interface.\n+   *\n+   * @param beginIndex index to start at (inclusive, base 0)\n+   * @param endIndex index to end at (exclusive)\n+   * @return new String which is a substring of this StringBuffer\n+   * @throws IndexOutOfBoundsException if beginIndex or endIndex is out of\n+   *         bounds\n+   * @see #substring(int, int)\n+   * @since 1.4\n    */\n-  public synchronized void setCharAt (int index, char ch)\n+  public CharSequence subSequence(int beginIndex, int endIndex)\n   {\n-    if (index < 0 || index >= count)\n-      throw new StringIndexOutOfBoundsException (index);\n-    // Call ensureCapacity to enforce copy-on-write.\n-    ensureCapacity_unsynchronized (count);\n-    value[index] = ch;\n+    return substring(beginIndex, endIndex);\n   }\n \n-  /** Set the length of this StringBuffer.\n-   *  <P>\n-   *  If the new length is greater than the current length, all the new\n-   *  characters are set to '\\0'.\n-   *  <P>\n-   *  If the new length is less than the current length, the first\n-   *  <code>newLength</code> characters of the old array will be\n-   * @param newLength the new length\n-   * @exception IndexOutOfBoundsException if the new length is\n-   *            negative.\n-   * @see #length()\n+  /**\n+   * Creates a substring of this StringBuffer, starting at a specified index\n+   * and ending at one character before a specified index.\n+   *\n+   * @param beginIndex index to start at (inclusive, base 0)\n+   * @param endIndex index to end at (exclusive)\n+   * @return new String which is a substring of this StringBuffer\n+   * @throws StringIndexOutOfBoundsException if beginIndex or endIndex is out\n+   *         of bounds\n+   * @since 1.2\n    */\n-  public synchronized void setLength (int newLength)\n+  public synchronized String substring(int beginIndex, int endIndex)\n   {\n-    if (newLength < 0)\n-      throw new StringIndexOutOfBoundsException (newLength);\n+    int len = endIndex - beginIndex;\n+    if (beginIndex < 0 || endIndex > count || len < 0)\n+      throw new StringIndexOutOfBoundsException();\n+    if (len == 0)\n+      return \"\";\n+    // Share the char[] unless 3/4 empty.\n+    shared = (len << 2) >= value.length;\n+    // Package constructor avoids an array copy.\n+    return new String(value, beginIndex, len, shared);\n+  }\n \n-    ensureCapacity_unsynchronized (newLength);\n-    for (int i = count; i < newLength; ++i)\n-      value[i] = '\\0';\n-    count = newLength;\n+  /**\n+   * Insert a subarray of the <code>char[]</code> argument into this\n+   * <code>StringBuffer</code>.\n+   *\n+   * @param offset the place to insert in this buffer\n+   * @param str the <code>char[]</code> to insert\n+   * @param str_offset the index in <code>str</code> to start inserting from\n+   * @param len the number of characters to insert\n+   * @return this <code>StringBuffer</code>\n+   * @throws NullPointerException if <code>str</code> is <code>null</code>\n+   * @throws StringIndexOutOfBoundsException if any index is out of bounds\n+   * @since 1.2\n+   */\n+  public synchronized StringBuffer insert(int offset,\n+                                          char[] str, int str_offset, int len)\n+  {\n+    if (offset < 0 || offset > count || len < 0\n+        || str_offset < 0 || str_offset + len > str.length)\n+      throw new StringIndexOutOfBoundsException();\n+    ensureCapacity_unsynchronized(count + len);\n+    System.arraycopy(value, offset, value, offset + len, count - offset);\n+    System.arraycopy(str, str_offset, value, offset, len);\n+    count += len;\n+    return this;\n   }\n \n-  /** Create a new StringBuffer with default capacity 16.\n-   *  @see JLS 20.13.1\n+  /**\n+   * Insert the <code>String</code> value of the argument into this\n+   * <code>StringBuffer</code>. Uses <code>String.valueOf()</code> to convert\n+   * to <code>String</code>.\n+   *\n+   * @param offset the place to insert in this buffer\n+   * @param obj the <code>Object</code> to convert and insert\n+   * @return this <code>StringBuffer</code>\n+   * @exception StringIndexOutOfBoundsException if offset is out of bounds\n+   * @see String#valueOf(Object)\n    */\n-  public StringBuffer ()\n+  public StringBuffer insert(int offset, Object obj)\n   {\n-    this (DEFAULT_CAPACITY);\n+    return insert(offset, obj == null ? \"null\" : obj.toString());\n   }\n \n-  /** Create an empty <code>StringBuffer</code> with the specified initial capacity.\n-   *  @param capacity the initial capacity.\n+  /**\n+   * Insert the <code>String</code> argument into this\n+   * <code>StringBuffer</code>. If str is null, the String \"null\" is used\n+   * instead.\n+   *\n+   * @param offset the place to insert in this buffer\n+   * @param str the <code>String</code> to insert\n+   * @return this <code>StringBuffer</code>\n+   * @throws StringIndexOutOfBoundsException if offset is out of bounds\n    */\n-  public StringBuffer (int capacity)\n+  public synchronized StringBuffer insert(int offset, String str)\n   {\n-    count = 0;\n-    value = new char[capacity];\n-    shared = false;\n+    if (offset < 0 || offset > count)\n+      throw new StringIndexOutOfBoundsException(offset);\n+    if (str == null)\n+      str = \"null\";\n+    int len = str.count;\n+    ensureCapacity_unsynchronized(count + len);\n+    System.arraycopy(value, offset, value, offset + len, count - offset);\n+    str.getChars(0, len, value, offset);\n+    count += len;\n+    return this;\n   }\n \n-  /** Create a new <code>StringBuffer</code> with the characters in the specified <code>String</code>.\n-   *  Initial capacity will be the size of the String plus 16.\n-   *  @param str the <code>String</code> to make a <code>StringBuffer</code> out of.\n-   *  @XXX optimize for sharing.\n+  /**\n+   * Insert the <code>char[]</code> argument into this\n+   * <code>StringBuffer</code>.\n+   *\n+   * @param offset the place to insert in this buffer\n+   * @param data the <code>char[]</code> to insert\n+   * @return this <code>StringBuffer</code>\n+   * @throws NullPointerException if <code>data</code> is <code>null</code>\n+   * @throws StringIndexOutOfBoundsException if offset is out of bounds\n+   * @see #insert(int, char[], int, int)\n    */\n-  public StringBuffer (String str)\n+  public StringBuffer insert(int offset, char[] data)\n   {\n-    // The documentation is not clear, but experimentation with\n-    // other implementations indicates that StringBuffer(null)\n-    // should throw a NullPointerException.\n-    count = str.length();\n-    // JLS: The initial capacity of the string buffer is 16 plus the\n-    // length of the argument string.\n-    value = new char[count + DEFAULT_CAPACITY];\n-    str.getChars(0, count, value, 0);\n-    shared = false;\n+    return insert(offset, data, 0, data.length);\n   }\n \n   /**\n-   * Creates a substring of this StringBuffer, starting at a specified index\n-   * and ending at the end of this StringBuffer.\n+   * Insert the <code>String</code> value of the argument into this\n+   * <code>StringBuffer</code>. Uses <code>String.valueOf()</code> to convert\n+   * to <code>String</code>.\n    *\n-   * @param beginIndex index to start substring (base 0)\n-   * \n-   * @return new String which is a substring of this StringBuffer\n+   * @param offset the place to insert in this buffer\n+   * @param bool the <code>boolean</code> to convert and insert\n+   * @return this <code>StringBuffer</code>\n+   * @throws StringIndexOutOfBoundsException if offset is out of bounds\n+   * @see String#valueOf(boolean)\n+   */\n+  public StringBuffer insert(int offset, boolean bool)\n+  {\n+    return insert(offset, bool ? \"true\" : \"false\");\n+  }\n+\n+  /**\n+   * Insert the <code>char</code> argument into this <code>StringBuffer</code>.\n    *\n-   * @exception StringIndexOutOfBoundsException \n-   *   if (beginIndex < 0 || beginIndex > this.length())\n+   * @param offset the place to insert in this buffer\n+   * @param ch the <code>char</code> to insert\n+   * @return this <code>StringBuffer</code>\n+   * @throws StringIndexOutOfBoundsException if offset is out of bounds\n    */\n-  public String substring (int beginIndex)\n+  public synchronized StringBuffer insert(int offset, char ch)\n   {\n-    return substring (beginIndex, count);\n+    if (offset < 0 || offset > count)\n+      throw new StringIndexOutOfBoundsException(offset);\n+    ensureCapacity_unsynchronized(count + 1);\n+    System.arraycopy(value, offset, value, offset + 1, count - offset);\n+    value[offset] = ch;\n+    count++;\n+    return this;\n   }\n \n   /**\n-   * Creates a substring of this StringBuffer, starting at a specified index\n-   * and ending at one character before a specified index.\n+   * Insert the <code>String</code> value of the argument into this\n+   * <code>StringBuffer</code>. Uses <code>String.valueOf()</code> to convert\n+   * to <code>String</code>.\n    *\n-   * @param beginIndex index to start substring (base 0)\n-   * @param endIndex index after the last character to be \n-   *   copied into the substring\n-   * \n-   * @return new String which is a substring of this StringBuffer\n+   * @param offset the place to insert in this buffer\n+   * @param inum the <code>int</code> to convert and insert\n+   * @return this <code>StringBuffer</code>\n+   * @throws StringIndexOutOfBoundsException if offset is out of bounds\n+   * @see String#valueOf(int)\n+   */\n+  public StringBuffer insert(int offset, int inum)\n+  {\n+    return insert(offset, String.valueOf(inum));\n+  }\n+\n+  /**\n+   * Insert the <code>String</code> value of the argument into this\n+   * <code>StringBuffer</code>. Uses <code>String.valueOf()</code> to convert\n+   * to <code>String</code>.\n    *\n-   * @exception StringIndexOutOfBoundsException \n-   *   if (beginIndex < 0 || endIndex > this.length() || beginIndex > endIndex)\n+   * @param offset the place to insert in this buffer\n+   * @param lnum the <code>long</code> to convert and insert\n+   * @return this <code>StringBuffer</code>\n+   * @throws StringIndexOutOfBoundsException if offset is out of bounds\n+   * @see String#valueOf(long)\n    */\n-  public synchronized String substring (int beginIndex, int endIndex) \n+  public StringBuffer insert(int offset, long lnum)\n   {\n-    if (beginIndex < 0 || endIndex > count || beginIndex > endIndex)\n-      throw new StringIndexOutOfBoundsException ();\n-    // FIXME: for libgcj it would be possible, and more efficient, to\n-    // enable sharing here.\n-    return new String (value, beginIndex, endIndex - beginIndex);\n+    return insert(offset, Long.toString(lnum, 10));\n   }\n \n   /**\n-   * Creates a substring of this StringBuffer, starting at a specified index\n-   * and ending at one character before a specified index.\n-   * <p>\n-   * To implement <code>CharSequence</code>.\n-   * Calls <code>substring(beginIndex, endIndex)</code>.\n+   * Insert the <code>String</code> value of the argument into this\n+   * <code>StringBuffer</code>. Uses <code>String.valueOf()</code> to convert\n+   * to <code>String</code>.\n    *\n-   * @param beginIndex index to start substring (base 0)\n-   * @param endIndex index after the last character to be \n-   *   copied into the substring\n-   * \n-   * @return new String which is a substring of this StringBuffer\n+   * @param offset the place to insert in this buffer\n+   * @param fnum the <code>float</code> to convert and insert\n+   * @return this <code>StringBuffer</code>\n+   * @throws StringIndexOutOfBoundsException if offset is out of bounds\n+   * @see String#valueOf(float)\n+   */\n+  public StringBuffer insert(int offset, float fnum)\n+  {\n+    return insert(offset, Float.toString(fnum));\n+  }\n+\n+  /**\n+   * Insert the <code>String</code> value of the argument into this\n+   * <code>StringBuffer</code>. Uses <code>String.valueOf()</code> to convert\n+   * to <code>String</code>.\n    *\n-   * @exception StringIndexOutOfBoundsException \n-   *   if (beginIndex < 0 || endIndex > this.length() || beginIndex > endIndex)\n+   * @param offset the place to insert in this buffer\n+   * @param dnum the <code>double</code> to convert and insert\n+   * @return this <code>StringBuffer</code>\n+   * @throws StringIndexOutOfBoundsException if offset is out of bounds\n+   * @see String#valueOf(double)\n    */\n-  public CharSequence subSequence (int beginIndex, int endIndex) \n+  public StringBuffer insert(int offset, double dnum)\n   {\n-    return substring(beginIndex, endIndex);\n+    return insert(offset, Double.toString(dnum));\n   }\n \n+  /**\n+   * Finds the first instance of a substring in this StringBuffer.\n+   *\n+   * @param str String to find\n+   * @return location (base 0) of the String, or -1 if not found\n+   * @throws NullPointerException if str is null\n+   * @see #indexOf(String, int)\n+   * @since 1.4\n+   */\n+  public int indexOf(String str)\n+  {\n+    return indexOf(str, 0);\n+  }\n \n-  /** Convert this <code>StringBuffer</code> to a <code>String</code>.\n-   *  @return the characters in this StringBuffer\n+  /**\n+   * Finds the first instance of a String in this StringBuffer, starting at\n+   * a given index.  If starting index is less than 0, the search starts at\n+   * the beginning of this String.  If the starting index is greater than the\n+   * length of this String, or the substring is not found, -1 is returned.\n+   *\n+   * @param str String to find\n+   * @param fromIndex index to start the search\n+   * @return location (base 0) of the String, or -1 if not found\n+   * @throws NullPointerException if str is null\n+   * @since 1.4\n    */\n-  public String toString ()\n+  public synchronized int indexOf(String str, int fromIndex)\n   {\n-    // Note: in libgcj this causes the StringBuffer to be shared.  In\n-    // Classpath it does not.\n-    return new String (this);\n+    if (fromIndex < 0)\n+      fromIndex = 0;\n+    int limit = count - str.count;\n+    for ( ; fromIndex <= limit; fromIndex++)\n+      if (regionMatches(fromIndex, str))\n+        return fromIndex;\n+    return -1;\n   }\n \n-  // Index of next available character.  Note that this has\n-  // permissions set this way so that String can get the value.\n-  int count;\n+  /**\n+   * Finds the last instance of a substring in this StringBuffer.\n+   *\n+   * @param str String to find\n+   * @return location (base 0) of the String, or -1 if not found\n+   * @throws NullPointerException if str is null\n+   * @see #lastIndexOf(String, int)\n+   * @since 1.4\n+   */\n+  public int lastIndexOf(String str)\n+  {\n+    return lastIndexOf(str, count - str.count);\n+  }\n \n-  // The buffer.  Note that this has permissions set this way so that\n-  // String can get the value.\n-  char[] value;\n+  /**\n+   * Finds the last instance of a String in this StringBuffer, starting at a\n+   * given index.  If starting index is greater than the maximum valid index,\n+   * then the search begins at the end of this String.  If the starting index\n+   * is less than zero, or the substring is not found, -1 is returned.\n+   *\n+   * @param str String to find\n+   * @param fromIndex index to start the search\n+   * @return location (base 0) of the String, or -1 if not found\n+   * @throws NullPointerException if str is null\n+   * @since 1.4\n+   */\n+  public synchronized int lastIndexOf(String str, int fromIndex)\n+  {\n+    fromIndex = Math.min(fromIndex, count - str.count);\n+    for ( ; fromIndex >= 0; fromIndex--)\n+      if (regionMatches(fromIndex, str))\n+        return fromIndex;\n+    return -1;\n+  }\n \n-  // True if we need to copy the buffer before writing to it again.\n-  // FIXME: JDK 1.2 doesn't specify this.  The new buffer-growing\n-  // semantics make this less useful in that case, too.  Note that\n-  // this has permissions set this way so that String can get the\n-  // value.\n-  boolean shared;\n+  /**\n+   * Reverse the characters in this StringBuffer. The same sequence of\n+   * characters exists, but in the reverse index ordering.\n+   *\n+   * @return this <code>StringBuffer</code>\n+   */\n+  public synchronized StringBuffer reverse()\n+  {\n+    // Call ensureCapacity to enforce copy-on-write.\n+    ensureCapacity_unsynchronized(count);\n+    for (int i = count >> 1, j = count - i; --i >= 0; ++j)\n+      {\n+        char c = value[i];\n+        value[i] = value[j];\n+        value[j] = c;\n+      }\n+    return this;\n+  }\n+\n+  /**\n+   * Convert this <code>StringBuffer</code> to a <code>String</code>. The\n+   * String is composed of the characters currently in this StringBuffer. Note\n+   * that the result is a copy, and that future modifications to this buffer\n+   * do not affect the String.\n+   *\n+   * @return the characters in this StringBuffer\n+   */\n+  public String toString()\n+  {\n+    // The string will set this.shared = true.\n+    return new String(this);\n+  }\n+\n+  /**\n+   * An unsynchronized version of ensureCapacity, used internally to avoid\n+   * the cost of a second lock on the same object. This also has the side\n+   * effect of duplicating the array, if it was shared (to form copy-on-write\n+   * semantics).\n+   *\n+   * @param minimumCapacity the minimum capacity\n+   * @see #ensureCapacity(int)\n+   */\n+  private void ensureCapacity_unsynchronized(int minimumCapacity)\n+  {\n+    if (shared || minimumCapacity > value.length)\n+      {\n+        // We don't want to make a larger vector when `shared' is\n+        // set.  If we do, then setLength becomes very inefficient\n+        // when repeatedly reusing a StringBuffer in a loop.\n+        int max = (minimumCapacity > value.length\n+                   ? value.length * 2 + 2\n+                   : value.length);\n+        minimumCapacity = (minimumCapacity < max ? max : minimumCapacity);\n+        char[] nb = new char[minimumCapacity];\n+        System.arraycopy(value, 0, nb, 0, count);\n+        value = nb;\n+        shared = false;\n+      }\n+  }\n \n-  static final long serialVersionUID = 3388685877147921107L;\n-  private final static int DEFAULT_CAPACITY = 16; // JLS 20.13.1\n+  /**\n+   * Predicate which determines if a substring of this matches another String\n+   * starting at a specified offset for each String and continuing for a\n+   * specified length. This is more efficient than creating a String to call\n+   * indexOf on.\n+   *\n+   * @param toffset index to start comparison at for this String\n+   * @param other non-null String to compare to region of this\n+   * @return true if regions match, false otherwise\n+   * @see #indexOf(String, int)\n+   * @see #lastIndexOf(String, int)\n+   * @see String#regionMatches(boolean, int, String, int, int)\n+   */\n+  // GCJ LOCAL: native for gcj.\n+  private native boolean regionMatches(int toffset, String other);\n }"}, {"sha": "8fbb8dfbc3c6a58c1fc84cb25fa4da203ccfa13f", "filename": "libjava/java/lang/natStringBuffer.cc", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1bb3bbbaeebbeea5b9e3b41e98efac1a3530ed/libjava%2Fjava%2Flang%2FnatStringBuffer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1bb3bbbaeebbeea5b9e3b41e98efac1a3530ed/libjava%2Fjava%2Flang%2FnatStringBuffer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatStringBuffer.cc?ref=ce1bb3bbbaeebbeea5b9e3b41e98efac1a3530ed", "patch": "@@ -1,6 +1,6 @@\n // natStringBuffer.cc - Implementation of java.lang.StringBuffer native methods.\n \n-/* Copyright (C) 2001  Free Software Foundation\n+/* Copyright (C) 2001, 2003  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -28,3 +28,15 @@ java::lang::StringBuffer::append (jint num)\n   count = needed;\n   return this;\n }\n+\n+jboolean\n+java::lang::StringBuffer::regionMatches(jint toffset, jstring other)\n+{\n+  jint len = other->count;\n+  jchar *tptr = elements(value) + toffset;\n+  jchar *optr = JvGetStringChars(other);\n+  while (--len >= 0)\n+    if (*tptr++ != *optr++)\n+      return false;\n+  return true;\n+}"}]}