{"sha": "facc279fc19a31c23323ce3eeac869eb14d07bda", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFjYzI3OWZjMTlhMzFjMjMzMjNjZTNlZWFjODY5ZWIxNGQwN2JkYQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-02-04T20:49:27Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-02-04T20:49:27Z"}, "message": "defineclass.cc (handleMethodsBegin): Allocate _Jv_MethodBase pointers.\n\n\t* defineclass.cc (handleMethodsBegin): Allocate _Jv_MethodBase\n\tpointers.\n\t(handleMethodsEnd): Fixed error messages.  Create a _Jv_JNIMethod\n\tif the method is native.\n\t* resolve.cc (ncode): Don't handle native methods.\n\t(_Jv_JNIMethod::ncode): New method.\n\t(_Jv_PrepareClass): Handle native methods.\n\t* jni.cc (call): Renamed from _Jv_JNI_conversion_call.\n\tInclude AbstractMethodError.h.\n\t(add_char): New function.\n\t(mangled_name): Likewise.\n\t* include/java-interp.h (class _Jv_JNIMethod): New class.\n\t(class _Jv_MethodBase): New class.\n\t(class _Jv_InterpMethod): Derive from _Jv_MethodBase.\n\t(_Jv_InterpClass): Changed `interpreted_methods' field to type\n\t`_Jv_MethodBase'.\n\n\t* include/jvm.h (_Jv_FindSymbolInExecutable): Declare.\n\t* java/lang/natRuntime.cc (libraries_size, libraries_count,\n\tlibraries): New globals.\n\t(add_library): New function.\n\t(_Jv_FindSymbolInExecutable): New function.\n\n\t* java/lang/natClassLoader.cc (initiated_classes, loaded_classes):\n\tNow static.\n\nFrom-SVN: r31790", "tree": {"sha": "f2e35a2ea96bcecfa7499a5ec8161bd2528c22d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2e35a2ea96bcecfa7499a5ec8161bd2528c22d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/facc279fc19a31c23323ce3eeac869eb14d07bda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/facc279fc19a31c23323ce3eeac869eb14d07bda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/facc279fc19a31c23323ce3eeac869eb14d07bda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/facc279fc19a31c23323ce3eeac869eb14d07bda/comments", "author": null, "committer": null, "parents": [{"sha": "a89608cbebb11969af54ba5a5354302fab2a0b4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a89608cbebb11969af54ba5a5354302fab2a0b4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a89608cbebb11969af54ba5a5354302fab2a0b4b"}], "stats": {"total": 370, "additions": 312, "deletions": 58}, "files": [{"sha": "77122f15a2e5ac8bb51fea0b536c03f27a918ff4", "filename": "libjava/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/facc279fc19a31c23323ce3eeac869eb14d07bda/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/facc279fc19a31c23323ce3eeac869eb14d07bda/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=facc279fc19a31c23323ce3eeac869eb14d07bda", "patch": "@@ -1,3 +1,31 @@\n+2000-02-04  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* defineclass.cc (handleMethodsBegin): Allocate _Jv_MethodBase\n+\tpointers.\n+\t(handleMethodsEnd): Fixed error messages.  Create a _Jv_JNIMethod\n+\tif the method is native.\n+\t* resolve.cc (ncode): Don't handle native methods.\n+\t(_Jv_JNIMethod::ncode): New method.\n+\t(_Jv_PrepareClass): Handle native methods.\n+\t* jni.cc (call): Renamed from _Jv_JNI_conversion_call.\n+\tInclude AbstractMethodError.h.\n+\t(add_char): New function.\n+\t(mangled_name): Likewise.\n+\t* include/java-interp.h (class _Jv_JNIMethod): New class.\n+\t(class _Jv_MethodBase): New class.\n+\t(class _Jv_InterpMethod): Derive from _Jv_MethodBase.\n+\t(_Jv_InterpClass): Changed `interpreted_methods' field to type\n+\t`_Jv_MethodBase'.\n+\n+\t* include/jvm.h (_Jv_FindSymbolInExecutable): Declare.\n+\t* java/lang/natRuntime.cc (libraries_size, libraries_count,\n+\tlibraries): New globals.\n+\t(add_library): New function.\n+\t(_Jv_FindSymbolInExecutable): New function.\n+\n+\t* java/lang/natClassLoader.cc (initiated_classes, loaded_classes):\n+\tNow static.\n+\n 2000-02-04  Andrew Haley  <aph@cygnus.com>\n \n \t* java/lang/Throwable.java (CPlusPlusDemangler): New class."}, {"sha": "215fc23cfb0db69398c2a921a4dcef6d58101192", "filename": "libjava/defineclass.cc", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/facc279fc19a31c23323ce3eeac869eb14d07bda/libjava%2Fdefineclass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/facc279fc19a31c23323ce3eeac869eb14d07bda/libjava%2Fdefineclass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdefineclass.cc?ref=facc279fc19a31c23323ce3eeac869eb14d07bda", "patch": "@@ -1142,13 +1142,15 @@ void _Jv_ClassReader::handleFieldsEnd ()\n \n \n \n-void _Jv_ClassReader::handleMethodsBegin (int count)\n+void\n+_Jv_ClassReader::handleMethodsBegin (int count)\n {\n   def->methods = (_Jv_Method*)\n     _Jv_AllocBytesChecked (sizeof (_Jv_Method)*count);\n \n-  def->interpreted_methods = (_Jv_InterpMethod**)\n-    _Jv_AllocBytesChecked (sizeof (_Jv_InterpMethod*) * count);\n+  def->interpreted_methods\n+    = (_Jv_MethodBase **) _Jv_AllocBytesChecked (sizeof (_Jv_MethodBase *)\n+\t\t\t\t\t\t * count);\n \n   for (int i = 0; i < count; i++)\n     def->interpreted_methods[i] = 0;\n@@ -1230,7 +1232,8 @@ void _Jv_ClassReader::handleExceptionTableEntry\n   (int method_index, int exc_index, \n    int start_pc, int end_pc, int handler_pc, int catch_type)\n {\n-  _Jv_InterpMethod *method = def->interpreted_methods[method_index];\n+  _Jv_InterpMethod *method = reinterpret_cast<_Jv_InterpMethod *>\n+    (def->interpreted_methods[method_index]);\n   _Jv_InterpException *exc = method->exceptions ();\n \n   exc[exc_index].start_pc     = start_pc;\n@@ -1246,17 +1249,29 @@ void _Jv_ClassReader::handleMethodsEnd ()\n   for (int i = 0; i < def->method_count; i++)\n     {\n       _Jv_Method *method = &def->methods[i];\n-      if (method->accflags & (Modifier::NATIVE | Modifier::ABSTRACT))\n+      if ((method->accflags & Modifier::NATIVE) != 0)\n+\t{\n+\t  if (def->interpreted_methods[i] != 0)\n+\t    throw_class_format_error (\"code provided for native method\");\n+\t  else\n+\t    {\n+\t      _Jv_JNIMethod *m = (_Jv_JNIMethod *)\n+\t\t_Jv_AllocBytesChecked (sizeof (_Jv_JNIMethod));\n+\t      m->defining_class = def;\n+\t      m->self = method;\n+\t      m->function = NULL;\n+\t      def->interpreted_methods[i] = m;\n+\t    }\n+\t}\n+      else if ((method->accflags & Modifier::ABSTRACT) != 0)\n \t{\n \t  if (def->interpreted_methods[i] != 0)\n-\t    throw_class_format_error (\"code provided \"\n-\t\t\t\t      \"for abstract or native method\");\n+\t    throw_class_format_error (\"code provided for abstract method\");\n \t}\n       else\n \t{\n \t  if (def->interpreted_methods[i] == 0)\n-\t    throw_class_format_error (\"abstract or native method \"\n-\t\t\t\t      \"with no code\");\n+\t    throw_class_format_error (\"method with no code\");\n \t}\n     }\n "}, {"sha": "7022411bb51e3bf1cf49a23900ab45af87672f2f", "filename": "libjava/include/java-interp.h", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/facc279fc19a31c23323ce3eeac869eb14d07bda/libjava%2Finclude%2Fjava-interp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/facc279fc19a31c23323ce3eeac869eb14d07bda/libjava%2Finclude%2Fjava-interp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-interp.h?ref=facc279fc19a31c23323ce3eeac869eb14d07bda", "patch": "@@ -14,6 +14,18 @@ details.  */\n #include <jvm.h>\n #include <java-cpool.h>\n \n+// Base class for method representations.  Subclasses are interpreted\n+// and JNI methods.\n+class _Jv_MethodBase\n+{\n+protected:\n+  // The class which defined this method.\n+  _Jv_InterpClass *defining_class;\n+\n+  // The method description.\n+  _Jv_Method *self;\n+};\n+\n #ifdef INTERPRETER\n \n #pragma interface\n@@ -66,18 +78,15 @@ class _Jv_InterpException {\n   friend class _Jv_InterpMethod;\n };\n \n-class _Jv_InterpMethod {\n-\n+class _Jv_InterpMethod : public _Jv_MethodBase\n+{\n   _Jv_ushort       max_stack;\n   _Jv_ushort       max_locals;\n   int              code_length;\n \n   _Jv_ushort       exc_count;\n   _Jv_ushort       args_raw_size;\n \n-  _Jv_InterpClass *defining_class;\n-  _Jv_Method      *self;\n-\n   unsigned char* bytecode () \n   {\n     return \n@@ -121,9 +130,6 @@ class _Jv_InterpMethod {\n   friend class gnu::gcj::runtime::MethodInvocation;\n \n   friend void _Jv_PrepareClass(jclass);\n-\n-  // This function is used when making a JNI call from the interpreter.\n-  friend void _Jv_JNI_conversion_call (ffi_cif *, void *, ffi_raw *, void *);\n };\n \n class _Jv_InterpMethodInvocation {\n@@ -140,7 +146,7 @@ class _Jv_InterpMethodInvocation {\n   \n class _Jv_InterpClass : public java::lang::Class\n {\n-  _Jv_InterpMethod **interpreted_methods;\n+  _Jv_MethodBase **interpreted_methods;\n   _Jv_ushort        *field_initializers;\n \n   friend class _Jv_ClassReader;\n@@ -165,4 +171,19 @@ struct _Jv_ResolvedMethod {\n \n #endif /* INTERPRETER */\n \n+class _Jv_JNIMethod : public _Jv_MethodBase\n+{\n+  // The underlying function.  If NULL we have to look for the\n+  // function.\n+  void *function;\n+\n+  // This function is used when making a JNI call from the interpreter.\n+  static void call (ffi_cif *, void *, ffi_raw *, void *);\n+\n+  void *ncode ();\n+\n+  friend class _Jv_ClassReader;\n+  friend void _Jv_PrepareClass(jclass);\n+};\n+\n #endif /* __JAVA_INTERP_H__ */"}, {"sha": "325fe9390958c4ce329220827989d07e97604f85", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/facc279fc19a31c23323ce3eeac869eb14d07bda/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/facc279fc19a31c23323ce3eeac869eb14d07bda/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=facc279fc19a31c23323ce3eeac869eb14d07bda", "patch": "@@ -201,6 +201,9 @@ extern \"C\"\n extern char *_Jv_ThisExecutable (void);\n extern void _Jv_ThisExecutable (const char *);\n \n+/* Return a pointer to a symbol in executable or loaded library.  */\n+void *_Jv_FindSymbolInExecutable (const char *);\n+\n /* Initialize JNI.  */\n extern void _Jv_JNI_Init (void);\n "}, {"sha": "ba7b2c66b666a43123e37f9e7525de6a66c655f4", "filename": "libjava/java/lang/natClassLoader.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/facc279fc19a31c23323ce3eeac869eb14d07bda/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/facc279fc19a31c23323ce3eeac869eb14d07bda/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClassLoader.cc?ref=facc279fc19a31c23323ce3eeac869eb14d07bda", "patch": "@@ -308,8 +308,12 @@ struct _Jv_LoaderInfo {\n     java::lang::ClassLoader *loader;\n };\n \n-_Jv_LoaderInfo *initiated_classes[HASH_LEN];\n-jclass loaded_classes[HASH_LEN];\n+static _Jv_LoaderInfo *initiated_classes[HASH_LEN];\n+static jclass loaded_classes[HASH_LEN];\n+\n+// This is the root of a linked list of classes\n+\n+\f\n \n jclass\n _Jv_FindClassInCache (_Jv_Utf8Const *name, java::lang::ClassLoader *loader)"}, {"sha": "dd8b0d01e8778e983c688c0079530679f30ced21", "filename": "libjava/java/lang/natRuntime.cc", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/facc279fc19a31c23323ce3eeac869eb14d07bda/libjava%2Fjava%2Flang%2FnatRuntime.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/facc279fc19a31c23323ce3eeac869eb14d07bda/libjava%2Fjava%2Flang%2FnatRuntime.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatRuntime.cc?ref=facc279fc19a31c23323ce3eeac869eb14d07bda", "patch": "@@ -24,7 +24,52 @@ details.  */\n /* FIXME: we don't always need this.  The next libtool will let us use\n    AC_LTDL_PREOPEN to see if we do.  */\n const lt_dlsymlist lt_preloaded_symbols[1] = { { 0, 0 } };\n-#endif\n+\n+// We keep track of all the libraries loaded by this application.  For\n+// now we use them to look up symbols for JNI.  `libraries_size' holds\n+// the total size of the buffer.  `libraries_count' is the number of\n+// items which are in use.\n+static int libraries_size;\n+static int libraries_count;\n+static lt_dlhandle *libraries;\n+\n+static void\n+add_library (lt_dlhandle lib)\n+{\n+  if (libraries_count == libraries_size)\n+    {\n+      int ns = libraries_size * 2;\n+      if (ns == 0)\n+\tns = 10;\n+      lt_dlhandle *n = (lt_dlhandle *) _Jv_Malloc (ns * sizeof (lt_dlhandle));\n+      if (libraries)\n+\t{\n+\t  memcpy (n, libraries, libraries_size * sizeof (lt_dlhandle));\n+\t  _Jv_Free (libraries);\n+\t}\n+      libraries = n;\n+      libraries_size = ns;\n+      for (int i = libraries_count; i < libraries_size; ++i)\n+\tlibraries[i] = NULL;\n+    }\n+\n+  libraries[libraries_count++] = lib;\n+}\n+\n+void *\n+_Jv_FindSymbolInExecutable (const char *symname)\n+{\n+  for (int i = 0; i < libraries_count; ++i)\n+    {\n+      void *r = lt_dlsym (libraries[i], symname);\n+      if (r)\n+\treturn r;\n+    }\n+\n+  return lt_dlsym (NULL, symname);\n+}\n+\n+#endif /* USE_LTDL */\n \n void\n java::lang::Runtime::exit (jint status)"}, {"sha": "da964e14cf35ad7602e934ba52f23fa5210e4342", "filename": "libjava/jni.cc", "status": "modified", "additions": 119, "deletions": 9, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/facc279fc19a31c23323ce3eeac869eb14d07bda/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/facc279fc19a31c23323ce3eeac869eb14d07bda/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=facc279fc19a31c23323ce3eeac869eb14d07bda", "patch": "@@ -32,6 +32,7 @@ details.  */\n #include <java/lang/Throwable.h>\n #include <java/lang/ArrayIndexOutOfBoundsException.h>\n #include <java/lang/StringIndexOutOfBoundsException.h>\n+#include <java/lang/AbstractMethodError.h>\n #include <java/lang/InstantiationException.h>\n #include <java/lang/NoSuchFieldError.h>\n #include <java/lang/NoSuchMethodError.h>\n@@ -1204,15 +1205,101 @@ _Jv_JNI_FromReflectedMethod (JNIEnv *, jobject method)\n \n \f\n \n+// Add a character to the buffer, encoding properly.\n+static void\n+add_char (char *buf, jchar c, int *here)\n+{\n+  if (c == '_')\n+    {\n+      buf[(*here)++] = '_';\n+      buf[(*here)++] = '1';\n+    }\n+  else if (c == ';')\n+    {\n+      buf[(*here)++] = '_';\n+      buf[(*here)++] = '2';\n+    }\n+  else if (c == '[')\n+    {\n+      buf[(*here)++] = '_';\n+      buf[(*here)++] = '3';\n+    }\n+  else if (c == '/')\n+    buf[(*here)++] = '_';\n+  if ((c >= '0' && c <= '9')\n+      || (c >= 'a' && c <= 'z')\n+      || (c >= 'A' && c <= 'Z'))\n+    buf[(*here)++] = (char) c;\n+  else\n+    {\n+      // \"Unicode\" character.\n+      buf[(*here)++] = '_';\n+      buf[(*here)++] = '0';\n+      for (int i = 0; i < 4; ++i)\n+\t{\n+\t  int val = c & 0x0f;\n+\t  buf[(*here) + 4 - i] = (val > 10) ? ('a' + val - 10) : ('0' + val);\n+\t  c >>= 4;\n+\t}\n+      *here += 4;\n+    }\n+}\n+\n+// Compute a mangled name for a native function.  This computes the\n+// long name, and also returns an index which indicates where a NUL\n+// can be placed to create the short name.  This function assumes that\n+// the buffer is large enough for its results.\n+static void\n+mangled_name (jclass klass, _Jv_Utf8Const *func_name,\n+\t      _Jv_Utf8Const *signature, char *buf, int *long_start)\n+{\n+  strcpy (buf, \"Java_\");\n+  int here = 5;\n+\n+  // Add fully qualified class name.\n+  jchar *chars = _Jv_GetStringChars (klass->getName ());\n+  jint len = klass->getName ()->length ();\n+  for (int i = 0; i < len; ++i)\n+    add_char (buf, chars[i], &here);\n+\n+  // Don't use add_char because we need a literal `_'.\n+  buf[here++] = '_';\n+\n+  const unsigned char *fn = (const unsigned char *) func_name->data;\n+  const unsigned char *limit = fn + func_name->length;\n+  for (int i = 0; ; ++i)\n+    {\n+      int ch = UTF8_GET (fn, limit);\n+      if (ch < 0)\n+\tbreak;\n+      add_char (buf, ch, &here);\n+    }\n+\n+  // This is where the long signature begins.\n+  *long_start = here;\n+  buf[here++] = '_';\n+  buf[here++] = '_';\n+\n+  const unsigned char *sig = (const unsigned char *) signature->data;\n+  limit = sig + signature->length;\n+  JvAssert (signature[0] == '(');\n+  for (int i = 1; ; ++i)\n+    {\n+      int ch = UTF8_GET (sig, limit);\n+      if (ch == ')' || ch < 0)\n+\tbreak;\n+      add_char (buf, ch, &here);\n+    }\n+\n+  buf[here] = '\\0';\n+}\n+\n // This function is the stub which is used to turn an ordinary (CNI)\n // method call into a JNI call.\n void\n-_Jv_JNI_conversion_call (ffi_cif *cif,\n-\t\t\t void *ret,\n-\t\t\t ffi_raw *args,\n-\t\t\t void *__this)\n+_Jv_JNIMethod::call (ffi_cif *cif, void *ret, ffi_raw *args, void *__this)\n {\n-  _Jv_InterpMethod* _this = (_Jv_InterpMethod*)__this;\n+  _Jv_JNIMethod* _this = (_Jv_JNIMethod *) __this;\n \n   JNIEnv env;\n   _Jv_JNI_LocalFrame *frame\n@@ -1234,10 +1321,33 @@ _Jv_JNI_conversion_call (ffi_cif *cif,\n   // now we assume a conservative GC, and we assume that the\n   // references are on the stack somewhere.\n \n-  ffi_raw_call (cif,\n-\t\tNULL, // FIXME: function pointer.\n-\t\tret,\n-\t\targs);\n+  // We cache the value that we find, of course, but if we don't find\n+  // a value we don't cache that fact -- we might subsequently load a\n+  // library which finds the function in question.\n+  if (_this->function == NULL)\n+    {\n+      char buf[10 + 6 * (_this->self->name->length\n+\t\t\t + _this->self->signature->length)];\n+      int long_start;\n+      mangled_name (_this->defining_class, _this->self->name,\n+\t\t    _this->self->signature, buf, &long_start);\n+      char c = buf[long_start];\n+      buf[long_start] = '\\0';\n+      _this->function = _Jv_FindSymbolInExecutable (buf);\n+      if (_this->function == NULL)\n+\t{\n+\t  buf[long_start] = c;\n+\t  _this->function = _Jv_FindSymbolInExecutable (buf);\n+\t  if (_this->function == NULL)\n+\t    {\n+\t      jstring str = JvNewStringUTF (_this->self->name->data);\n+\t      JvThrow (new java::lang::AbstractMethodError (str));\n+\t    }\n+\t}\n+    }\n+\n+  // The actual call to the JNI function.\n+  ffi_raw_call (cif, (void (*) (...)) _this->function, ret, args);\n \n   do\n     {"}, {"sha": "eb9a37168b4fef48998221c74a044d4d4d650dc8", "filename": "libjava/resolve.cc", "status": "modified", "additions": 56, "deletions": 28, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/facc279fc19a31c23323ce3eeac869eb14d07bda/libjava%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/facc279fc19a31c23323ce3eeac869eb14d07bda/libjava%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fresolve.cc?ref=facc279fc19a31c23323ce3eeac869eb14d07bda", "patch": "@@ -563,21 +563,21 @@ _Jv_PrepareClass(jclass klass)\n      have code -- for static constructors. */\n   for (int i = 0; i < clz->method_count; i++)\n     {\n-      _Jv_InterpMethod *imeth = clz->interpreted_methods[i];\n+      _Jv_MethodBase *imeth = clz->interpreted_methods[i];\n \n-      if (imeth != 0)\t\t// it could be abstract or native\n+      if ((clz->methods[i].accflags & Modifier::NATIVE) != 0)\n \t{\n-\t  clz->methods[i].ncode = imeth->ncode ();\n+\t  // You might think we could use a virtual `ncode' method in\n+\t  // the _Jv_MethodBase and unify the native and non-native\n+\t  // cases.  Well, we can't, because we don't allocate these\n+\t  // objects using `new', and thus they don't get a vtable.\n+\t  _Jv_JNIMethod *jnim = reinterpret_cast<_Jv_JNIMethod *> (imeth);\n+\t  clz->methods[i].ncode = jnim->ncode ();\n \t}\n-      else\n+      else if (imeth != 0)\t\t// it could be abstract\n \t{\n-\t  if ((clz->methods[i].accflags & Modifier::NATIVE) != 0)\n-\t    {\n-\t      JvThrow\n-\t\t(new java::lang::VirtualMachineError\n-\t\t (JvNewStringLatin1 \n-\t\t  (\"the interpreter does not support native methods\")));\n-\t    }\n+\t  _Jv_InterpMethod *im = reinterpret_cast<_Jv_InterpMethod *> (im);\n+\t  clz->methods[i].ncode = im->ncode ();\n \t}\n     }\n \n@@ -588,13 +588,6 @@ _Jv_PrepareClass(jclass klass)\n       return;\n     }\n \n-  /* FIXME: native methods for interpreted classes should be handled, I\n-   * dunno exactly how, but it seems that we should try to find them at\n-   * this point, and if we fail, try again after <clinit>, since it\n-   * could have caused additional code to be loaded.  Interfaces cannot\n-   * have native methods (not even for static initialization). */\n-\n-\n   /* Now onto the actual job: vtable layout.  First, count how many new\n      methods we have */\n   int new_method_count = 0;\n@@ -1022,13 +1015,9 @@ _Jv_InterpMethod::ncode ()\n \n   args_raw_size = ffi_raw_size (&closure->cif);\n \n-  if ((self->accflags & Modifier::NATIVE) != 0)\n-    {\n-      // FIXME: for now we assume that all native methods for\n-      // interpreted code use JNI.\n-      fun = (ffi_closure_fun) &_Jv_JNI_conversion_call;\n-    }\n-  else if ((self->accflags & Modifier::SYNCHRONIZED) != 0)\n+  JvAssert ((self->accflags & Modifier::NATIVE) == 0);\n+\n+  if ((self->accflags & Modifier::SYNCHRONIZED) != 0)\n     {\n       if (staticp)\n \tfun = (ffi_closure_fun)&_Jv_InterpMethod::run_synch_class;\n@@ -1041,9 +1030,48 @@ _Jv_InterpMethod::ncode ()\n     }\n \n   ffi_prep_raw_closure (&closure->closure,\n-\t\t     &closure->cif, \n-\t\t     fun,\n-\t\t     (void*)this);\n+\t\t\t&closure->cif, \n+\t\t\tfun,\n+\t\t\t(void*) this);\n+\n+  self->ncode = (void*)closure;\n+  return self->ncode;\n+}\n+\n+\n+void *\n+_Jv_JNIMethod::ncode ()\n+{\n+  using namespace java::lang::reflect;\n+\n+  if (self->ncode != 0)\n+    return self->ncode;\n+\n+  jboolean staticp = (self->accflags & Modifier::STATIC) != 0;\n+  int arg_count = count_arguments (self->signature, staticp);\n+\n+  ncode_closure *closure =\n+    (ncode_closure*)_Jv_AllocBytesChecked (sizeof (ncode_closure)\n+\t\t\t\t\t+ arg_count * sizeof (ffi_type*));\n+\n+  init_cif (self->signature,\n+\t    arg_count,\n+\t    staticp,\n+\t    &closure->cif,\n+\t    &closure->arg_types[0]);\n+\n+  ffi_closure_fun fun;\n+\n+  JvAssert ((self->accflags & Modifier::NATIVE) != 0);\n+\n+  // FIXME: for now we assume that all native methods for\n+  // interpreted code use JNI.\n+  fun = (ffi_closure_fun) &_Jv_JNIMethod::call;\n+\n+  ffi_prep_raw_closure (&closure->closure,\n+\t\t\t&closure->cif, \n+\t\t\tfun,\n+\t\t\t(void*) this);\n \n   self->ncode = (void*)closure;\n   return self->ncode;"}]}