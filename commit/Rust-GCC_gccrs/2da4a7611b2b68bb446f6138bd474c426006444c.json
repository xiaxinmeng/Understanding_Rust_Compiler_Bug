{"sha": "2da4a7611b2b68bb446f6138bd474c426006444c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmRhNGE3NjExYjJiNjhiYjQ0NmY2MTM4YmQ0NzRjNDI2MDA2NDQ0Yw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-01-08T00:42:45Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-01-08T00:42:45Z"}, "message": "re PR go/59433 (Many 64-bit Go tests SEGV on Solaris)\n\n\tPR go/59433\nnet: Don't use stack space for fd_sets when using select.\n\nFrom-SVN: r206411", "tree": {"sha": "de5d458286ae1d045a6d4c6c5f2f049e2a99b65f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de5d458286ae1d045a6d4c6c5f2f049e2a99b65f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2da4a7611b2b68bb446f6138bd474c426006444c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2da4a7611b2b68bb446f6138bd474c426006444c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2da4a7611b2b68bb446f6138bd474c426006444c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2da4a7611b2b68bb446f6138bd474c426006444c/comments", "author": null, "committer": null, "parents": [{"sha": "06f4627b30d21952b56df4642872df5a637f93f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06f4627b30d21952b56df4642872df5a637f93f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06f4627b30d21952b56df4642872df5a637f93f4"}], "stats": {"total": 61, "additions": 45, "deletions": 16}, "files": [{"sha": "788d19f6190441e0a9d170498ec71724de0e5181", "filename": "libgo/runtime/netpoll_select.c", "status": "modified", "additions": 45, "deletions": 16, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2da4a7611b2b68bb446f6138bd474c426006444c/libgo%2Fruntime%2Fnetpoll_select.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2da4a7611b2b68bb446f6138bd474c426006444c/libgo%2Fruntime%2Fnetpoll_select.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fnetpoll_select.c?ref=2da4a7611b2b68bb446f6138bd474c426006444c", "patch": "@@ -118,10 +118,15 @@ runtime_netpollclose(uintptr fd)\n \treturn 0;\n }\n \n+/* Used to avoid using too much stack memory.  */\n+static bool inuse;\n+static fd_set grfds, gwfds, gefds, gtfds;\n+\n G*\n runtime_netpoll(bool block)\n {\n-\tfd_set rfds, wfds, efds, tfds;\n+\tfd_set *prfds, *pwfds, *pefds, *ptfds;\n+\tbool allocatedfds;\n \tstruct timeval timeout;\n \tstruct timeval *pt;\n \tint max, c, i;\n@@ -140,37 +145,52 @@ runtime_netpoll(bool block)\n \t\treturn nil;\n \t}\n \n-\t__builtin_memcpy(&rfds, &fds, sizeof fds);\n+\tif(inuse) {\n+\t\tprfds = runtime_SysAlloc(4 * sizeof fds, &mstats.other_sys);\n+\t\tpwfds = prfds + 1;\n+\t\tpefds = pwfds + 1;\n+\t\tptfds = pefds + 1;\n+\t\tallocatedfds = true;\n+\t} else {\n+\t\tprfds = &grfds;\n+\t\tpwfds = &gwfds;\n+\t\tpefds = &gefds;\n+\t\tptfds = &gtfds;\n+\t\tinuse = true;\n+\t\tallocatedfds = false;\n+\t}\n+\n+\t__builtin_memcpy(prfds, &fds, sizeof fds);\n \n \truntime_unlock(&selectlock);\n \n-\t__builtin_memcpy(&wfds, &rfds, sizeof fds);\n-\tFD_CLR(rdwake, &wfds);\n-\t__builtin_memcpy(&efds, &wfds, sizeof fds);\n+\t__builtin_memcpy(pwfds, prfds, sizeof fds);\n+\tFD_CLR(rdwake, pwfds);\n+\t__builtin_memcpy(pefds, pwfds, sizeof fds);\n \n-\t__builtin_memcpy(&tfds, &wfds, sizeof fds);\n+\t__builtin_memcpy(ptfds, pwfds, sizeof fds);\n \n \t__builtin_memset(&timeout, 0, sizeof timeout);\n \tpt = &timeout;\n \tif(block)\n \t\tpt = nil;\n \n-\tc = select(max, &rfds, &wfds, &efds, pt);\n+\tc = select(max, prfds, pwfds, pefds, pt);\n \tif(c < 0) {\n \t\tif(errno == EBADF) {\n \t\t\t// Some file descriptor has been closed.\n \t\t\t// Check each one, and treat each closed\n \t\t\t// descriptor as ready for read/write.\n \t\t\tc = 0;\n-\t\t\tFD_ZERO(&rfds);\n-\t\t\tFD_ZERO(&wfds);\n-\t\t\tFD_ZERO(&efds);\n+\t\t\tFD_ZERO(prfds);\n+\t\t\tFD_ZERO(pwfds);\n+\t\t\tFD_ZERO(pefds);\n \t\t\tfor(i = 0; i < max; i++) {\n-\t\t\t\tif(FD_ISSET(i, &tfds)\n+\t\t\t\tif(FD_ISSET(i, ptfds)\n \t\t\t\t   && fstat(i, &st) < 0\n \t\t\t\t   && errno == EBADF) {\n-\t\t\t\t\tFD_SET(i, &rfds);\n-\t\t\t\t\tFD_SET(i, &wfds);\n+\t\t\t\t\tFD_SET(i, prfds);\n+\t\t\t\t\tFD_SET(i, pwfds);\n \t\t\t\t\tc += 2;\n \t\t\t\t}\n \t\t\t}\n@@ -184,15 +204,15 @@ runtime_netpoll(bool block)\n \tgp = nil;\n \tfor(i = 0; i < max && c > 0; i++) {\n \t\tmode = 0;\n-\t\tif(FD_ISSET(i, &rfds)) {\n+\t\tif(FD_ISSET(i, prfds)) {\n \t\t\tmode += 'r';\n \t\t\t--c;\n \t\t}\n-\t\tif(FD_ISSET(i, &wfds)) {\n+\t\tif(FD_ISSET(i, pwfds)) {\n \t\t\tmode += 'w';\n \t\t\t--c;\n \t\t}\n-\t\tif(FD_ISSET(i, &efds)) {\n+\t\tif(FD_ISSET(i, pefds)) {\n \t\t\tmode = 'r' + 'w';\n \t\t\t--c;\n \t\t}\n@@ -213,6 +233,15 @@ runtime_netpoll(bool block)\n \t}\n \tif(block && gp == nil)\n \t\tgoto retry;\n+\n+\tif(allocatedfds) {\n+\t\truntime_SysFree(prfds, 4 * sizeof fds, &mstats.other_sys);\n+\t} else {\n+\t\truntime_lock(&selectlock);\n+\t\tinuse = false;\n+\t\truntime_unlock(&selectlock);\n+\t}\n+\n \treturn gp;\n }\n "}]}