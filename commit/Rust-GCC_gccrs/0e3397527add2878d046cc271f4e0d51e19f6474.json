{"sha": "0e3397527add2878d046cc271f4e0d51e19f6474", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGUzMzk3NTI3YWRkMjg3OGQwNDZjYzI3MWY0ZTBkNTFlMTlmNjQ3NA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@apple.com", "date": "2002-08-09T01:16:39Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2002-08-09T01:16:39Z"}, "message": "call.c (add_builtin_candidate): legal -> valid, illegal -> invalid.\n\n        * call.c (add_builtin_candidate): legal -> valid, illegal -> invalid.\n        (type_decays_to): Likewise.\n        * class.c (find_final_overrider): Likewise.\n        (maybe_note_name_used_in_class): Likewise.\n        * decl.c (current_tmpl_spec_kind): Likewise.\n        (add_binding): Likewise.\n        (push_class_binding): Likewise.\n        (duplicate_decls): Likewise.\n        (layout_var_decl): Likewise.\n        (grokfndecl): Likewise.\n        (grokdeclarator): Likewise.\n        (check_default_argument): Likewise.\n        * decl2.c (handle_class_head): Likewise.\n        * error.c (dump_template_decl): Likewise.\n        * init.c (build_offset_ref): Likewise.\n        * pt.c (check_specialization_scope): Likewise.\n        (determine_specialization): Likewise.\n        (check_explicit_specialization): Likewise.\n        (maybe_check_template_type): Likewise.\n        (process_partial_specialization): Likewise.\n        (check_default_tmpl_args): Likewise.\n        (push_template_decl_real): Likewise.\n        (convert_template_argument): Likewise.\n        (try_class_unification): Likewise.\n        (get_bindings_real): Likewise.\n        (do_decl_instantiation): Likewise.\n        * semantics.c (begin_function_definition): Likewise.\n        (finish_member_declaration): Likewise.\n        (check_multiple_declarators): Likewise.\n        * typeck.c (comp_array_types): Likewise.\n        (comptypes): Likewise.\n        (expr_sizeof): Likewise.\n        (build_binary_op): Likewise.\n        (dubious_conversion_warnings): Likewise.\n        (check_return_expr): Likewise.\n\nFrom-SVN: r56144", "tree": {"sha": "7032976e390cb994d16dc0166a68b611936b1a34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7032976e390cb994d16dc0166a68b611936b1a34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e3397527add2878d046cc271f4e0d51e19f6474", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e3397527add2878d046cc271f4e0d51e19f6474", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e3397527add2878d046cc271f4e0d51e19f6474", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e3397527add2878d046cc271f4e0d51e19f6474/comments", "author": null, "committer": null, "parents": [{"sha": "9e20be0cb2d7a3fcd2c82049493e0c458c2f2eaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e20be0cb2d7a3fcd2c82049493e0c458c2f2eaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e20be0cb2d7a3fcd2c82049493e0c458c2f2eaa"}], "stats": {"total": 128, "additions": 83, "deletions": 45}, "files": [{"sha": "f2da62af52dc6faa7935ddd5fc3cc988d3c489c5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3397527add2878d046cc271f4e0d51e19f6474/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3397527add2878d046cc271f4e0d51e19f6474/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0e3397527add2878d046cc271f4e0d51e19f6474", "patch": "@@ -1,3 +1,41 @@\n+2002-08-08  Mike Stump  <mrs@apple.com>\n+\n+\t* call.c (add_builtin_candidate): legal -> valid, illegal -> invalid.\n+\t(type_decays_to): Likewise.\n+\t* class.c (find_final_overrider): Likewise.\n+\t(maybe_note_name_used_in_class): Likewise.\n+\t* decl.c (current_tmpl_spec_kind): Likewise.\n+\t(add_binding): Likewise.\n+\t(push_class_binding): Likewise.\n+\t(duplicate_decls): Likewise.\n+\t(layout_var_decl): Likewise.\n+\t(grokfndecl): Likewise.\n+\t(grokdeclarator): Likewise.\n+\t(check_default_argument): Likewise.\n+\t* decl2.c (handle_class_head): Likewise.\n+\t* error.c (dump_template_decl): Likewise.\n+\t* init.c (build_offset_ref): Likewise.\n+\t* pt.c (check_specialization_scope): Likewise.\n+\t(determine_specialization): Likewise.\n+\t(check_explicit_specialization): Likewise.\n+\t(maybe_check_template_type): Likewise.\n+\t(process_partial_specialization): Likewise.\n+\t(check_default_tmpl_args): Likewise.\n+\t(push_template_decl_real): Likewise.\n+\t(convert_template_argument): Likewise.\n+\t(try_class_unification): Likewise.\n+\t(get_bindings_real): Likewise.\n+\t(do_decl_instantiation): Likewise.\n+\t* semantics.c (begin_function_definition): Likewise.\n+\t(finish_member_declaration): Likewise.\n+\t(check_multiple_declarators): Likewise.\n+\t* typeck.c (comp_array_types): Likewise.\n+\t(comptypes): Likewise.\n+\t(expr_sizeof): Likewise.\n+\t(build_binary_op): Likewise.\n+\t(dubious_conversion_warnings): Likewise.\n+\t(check_return_expr): Likewise.\n+\t\n 2002-08-08  Mark Mitchell  <mark@codesourcery.com>\n \n \t* typeck.c (build_class_member_access_expr): Do not return"}, {"sha": "00df003cffbd28f749665b2b5d39b1956e95eb5a", "filename": "gcc/cp/call.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3397527add2878d046cc271f4e0d51e19f6474/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3397527add2878d046cc271f4e0d51e19f6474/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=0e3397527add2878d046cc271f4e0d51e19f6474", "patch": "@@ -2020,7 +2020,7 @@ add_builtin_candidate (candidates, code, code2, fnname, type1, type2,\n \t types are TYPE2.  */\n \tbreak;\n \n-      /* These arguments do not make for a legal overloaded operator.  */\n+      /* These arguments do not make for a valid overloaded operator.  */\n       return candidates;\n \n     default:\n@@ -2070,7 +2070,7 @@ type_decays_to (type)\n    Here we generate a superset of the possible candidates for this particular\n    case.  That is a subset of the full set the standard defines, plus some\n    other cases which the standard disallows. add_builtin_candidate will\n-   filter out the illegal set.  */\n+   filter out the invalid set.  */\n \n static struct z_candidate *\n add_builtin_candidates (candidates, code, code2, fnname, args, flags)"}, {"sha": "db8cfa759200e0d5a4b5a8fe1a1d062c54372235", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3397527add2878d046cc271f4e0d51e19f6474/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3397527add2878d046cc271f4e0d51e19f6474/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=0e3397527add2878d046cc271f4e0d51e19f6474", "patch": "@@ -2366,7 +2366,7 @@ find_final_overrider (t, binfo, fn)\n {\n   find_final_overrider_data ffod;\n \n-  /* Getting this right is a little tricky.  This is legal:\n+  /* Getting this right is a little tricky.  This is valid:\n \n        struct S { virtual void f (); };\n        struct T { virtual void f (); };\n@@ -6389,7 +6389,7 @@ maybe_note_name_used_in_class (name, decl)\n }\n \n /* Note that NAME was declared (as DECL) in the current class.  Check\n-   to see that the declaration is legal.  */\n+   to see that the declaration is valid.  */\n \n void\n note_name_declared_in_class (name, decl)"}, {"sha": "15566e5f1135d38e80dbcef84741bfd37ce801fd", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3397527add2878d046cc271f4e0d51e19f6474/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3397527add2878d046cc271f4e0d51e19f6474/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0e3397527add2878d046cc271f4e0d51e19f6474", "patch": "@@ -709,7 +709,7 @@ current_tmpl_spec_kind (n_class_scopes)\n \n \t    template <class T> template <> ...\n \n-\t which is always illegal since [temp.expl.spec] forbids the\n+\t which is always invalid since [temp.expl.spec] forbids the\n \t specialization of a class member template if the enclosing\n \t class templates are not explicitly specialized as well.  */\n       if (b->template_spec_p)\n@@ -746,7 +746,7 @@ current_tmpl_spec_kind (n_class_scopes)\n \n          template <class T> void R<T>::S<T>::f(int);\n \n-       This is illegal; there needs to be one set of template\n+       This is invalid; there needs to be one set of template\n        parameters for each class.  */\n     return tsk_insufficient_parms;\n   else if (n_template_parm_scopes == n_class_scopes)\n@@ -932,7 +932,7 @@ push_binding (id, decl, level)\n    stat' hack whereby a non-typedef class-name or enum-name can be\n    bound at the same level as some other kind of entity.  It's the\n    responsibility of the caller to check that inserting this name is\n-   legal here.  Returns nonzero if the new binding was successful.  */\n+   valid here.  Returns nonzero if the new binding was successful.  */\n static int\n add_binding (id, decl)\n      tree id;\n@@ -1069,7 +1069,7 @@ push_class_binding (id, decl)\n   tree context;\n \n   /* Note that we declared this value so that we can issue an error if\n-     this an illegal redeclaration of a name already used for some\n+     this is an invalid redeclaration of a name already used for some\n      other purpose.  */\n   note_name_declared_in_class (id, decl);\n \n@@ -3213,7 +3213,7 @@ duplicate_decls (newdecl, olddecl)\n        specialization, and the other is an instantiation of the same\n        template, that we do not exit at this point.  That situation\n        can occur if we instantiate a template class, and then\n-       specialize one of its methods.  This situation is legal, but\n+       specialize one of its methods.  This situation is valid, but\n        the declarations must be merged in the usual way.  */\n     return 0;\n   else if (TREE_CODE (newdecl) == FUNCTION_DECL\n@@ -7615,7 +7615,7 @@ layout_var_decl (decl)\n   /* If we haven't already layed out this declaration, do so now.\n      Note that we must not call complete type for an external object\n      because it's type might involve templates that we are not\n-     supposed to isntantiate yet.  (And it's perfectly legal to say\n+     supposed to isntantiate yet.  (And it's perfectly valid to say\n      `extern X x' for some incomplete type `X'.)  */\n   if (!DECL_EXTERNAL (decl))\n     complete_type (type);\n@@ -9117,7 +9117,7 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \t    decl = DECL_TEMPLATE_RESULT (decl);\n \n \t  /* Attempt to merge the declarations.  This can fail, in\n-\t     the case of some illegal specialization declarations.  */\n+\t     the case of some invalid specialization declarations.  */\n \t  if (!duplicate_decls (decl, old_decl))\n \t    error (\"no `%#D' member function declared in class `%T'\",\n \t\t      decl, ctype);\n@@ -11815,23 +11815,23 @@ friend declaration requires class-key, i.e. `friend %#T'\",\n \n \tif (staticp == 1)\n \t  {\n-\t    int illegal_static = 0;\n+\t    int invalid_static = 0;\n \n \t    /* Don't allow a static member function in a class, and forbid\n \t       declaring main to be static.  */\n \t    if (TREE_CODE (type) == METHOD_TYPE)\n \t      {\n \t\tpedwarn (\"cannot declare member function `%D' to have static linkage\", decl);\n-\t\tillegal_static = 1;\n+\t\tinvalid_static = 1;\n \t      }\n \t    else if (current_function_decl)\n \t      {\n \t\t/* FIXME need arm citation */\n \t\terror (\"cannot declare static function inside another function\");\n-\t\tillegal_static = 1;\n+\t\tinvalid_static = 1;\n \t      }\n \n-\t    if (illegal_static)\n+\t    if (invalid_static)\n \t      {\n \t\tstaticp = 0;\n \t\tRIDBIT_RESET (RID_STATIC, specbits);\n@@ -11989,7 +11989,7 @@ local_variable_p_walkfn (tp, walk_subtrees, data)\n }\n \n /* Check that ARG, which is a default-argument expression for a\n-   parameter DECL, is legal.  Returns ARG, or ERROR_MARK_NODE, if\n+   parameter DECL, is valid.  Returns ARG, or ERROR_MARK_NODE, if\n    something goes wrong.  DECL may also be a _TYPE node, rather than a\n    DECL, if there is no DECL available.  */\n "}, {"sha": "9072e9e828eca2ff3008fa283a461f0bba6b322e", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3397527add2878d046cc271f4e0d51e19f6474/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3397527add2878d046cc271f4e0d51e19f6474/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=0e3397527add2878d046cc271f4e0d51e19f6474", "patch": "@@ -4826,7 +4826,7 @@ handle_class_head (tag_kind, scope, id, attributes, defn_p, new_type_p)\n \tpush_scope (context);\n \n       if (TREE_CODE (TREE_TYPE (decl)) == RECORD_TYPE)\n-\t/* It is legal to define a class with a different class key,\n+\t/* It is valid to define a class with a different class key,\n \t   and this changes the default member access.  */\n \tCLASSTYPE_DECLARED_CLASS (TREE_TYPE (decl))\n \t  = (tag_kind == class_type);"}, {"sha": "b0c063996804d6efcfc021bfa40c1cac7294cded", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3397527add2878d046cc271f4e0d51e19f6474/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3397527add2878d046cc271f4e0d51e19f6474/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=0e3397527add2878d046cc271f4e0d51e19f6474", "patch": "@@ -1063,7 +1063,7 @@ dump_template_decl (t, flags)\n         dump_function_decl (t, flags | TFF_TEMPLATE_NAME);\n         break;\n       default:\n-        /* This case can occur with some illegal code.  */\n+        /* This case can occur with some invalid code.  */\n         dump_type (TREE_TYPE (t),\n                    (flags & ~TFF_CLASS_KEY_OR_ENUM) | TFF_TEMPLATE_NAME\n                    | (flags & TFF_DECL_SPECIFIERS ? TFF_CLASS_KEY_OR_ENUM : 0));"}, {"sha": "b50f85fc4b9a072652de927f7aa7dcfdff3f0f3f", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3397527add2878d046cc271f4e0d51e19f6474/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3397527add2878d046cc271f4e0d51e19f6474/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=0e3397527add2878d046cc271f4e0d51e19f6474", "patch": "@@ -1756,7 +1756,7 @@ build_offset_ref (type, name)\n \n   if (TREE_CODE (t) == FIELD_DECL && DECL_C_BIT_FIELD (t))\n     {\n-      error (\"illegal pointer to bit-field `%D'\", t);\n+      error (\"invalid pointer to bit-field `%D'\", t);\n       return error_mark_node;\n     }\n "}, {"sha": "9cea85cd8425c15c05875c864ab5c097ce285c6f", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3397527add2878d046cc271f4e0d51e19f6474/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3397527add2878d046cc271f4e0d51e19f6474/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=0e3397527add2878d046cc271f4e0d51e19f6474", "patch": "@@ -585,7 +585,7 @@ begin_template_parm_list ()\n }\n \n /* This routine is called when a specialization is declared.  If it is\n-   illegal to declare a specialization here, an error is reported.  */\n+   invalid to declare a specialization here, an error is reported.  */\n \n static void\n check_specialization_scope ()\n@@ -1011,7 +1011,7 @@ determine_specialization (template_id, decl, targs_out,\n \t     For example,\n \t       template <class T> void f(int i = 0);\n \t       template <> void f<int>();\n-\t     The specialization f<int> is illegal but is not caught\n+\t     The specialization f<int> is invalid but is not caught\n \t     by get_bindings below.  */\n \n \t  if (list_length (TYPE_ARG_TYPES (TREE_TYPE (fn)))\n@@ -1110,7 +1110,7 @@ determine_specialization (template_id, decl, targs_out,\n \t      template. \n \n \t So, we do use the partial ordering rules, at least for now.\n-\t This extension can only serve to make illegal programs legal,\n+\t This extension can only serve to make invalid programs valid,\n \t so it's safe.  And, there is strong anecdotal evidence that\n \t the committee intended the partial ordering rules to apply;\n \t the EDG front-end has that behavior, and John Spicer claims\n@@ -1315,7 +1315,7 @@ copy_default_args_to_explicit_spec (decl)\n      template <> void S<int>::f();\n \n    the TEMPLATE_COUNT would be 0.  (Note that this declaration is\n-   illegal; there should be no template <>.)\n+   invalid; there should be no template <>.)\n \n    If the function is a specialization, it is marked as such via\n    DECL_TEMPLATE_SPECIALIZATION.  Furthermore, its DECL_TEMPLATE_INFO\n@@ -1416,7 +1416,7 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t       template <class T> struct S { void f(); };\n \t       void S<int>::f() {} // Missing template <>\n \n-\t     That used to be legal C++.  */\n+\t     That used to be valid C++.  */\n \t  if (pedantic)\n \t    pedwarn\n \t      (\"explicit specialization not preceded by `template <>'\");\n@@ -1498,13 +1498,13 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n       if (ctype != NULL_TREE && TYPE_BEING_DEFINED (ctype))\n \t{\n \t  if (!explicit_instantiation)\n-\t    /* A specialization in class scope.  This is illegal,\n+\t    /* A specialization in class scope.  This is invalid,\n \t       but the error will already have been flagged by\n \t       check_specialization_scope.  */\n \t    return error_mark_node;\n \t  else\n \t    {\n-\t      /* It's not legal to write an explicit instantiation in\n+\t      /* It's not valid to write an explicit instantiation in\n \t\t class scope, e.g.:\n \n \t           class C { template void f(); }\n@@ -1514,7 +1514,7 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t       \n \t\t   template class C { void f(); };\n \n-\t\t   (which is illegal) we can get here.  The error will be\n+\t\t   (which is invalid) we can get here.  The error will be\n \t\t   issued later.  */\n \t      ;\n \t    }\n@@ -1734,7 +1734,7 @@ maybe_check_template_type (type)\n \t       struct I {};\n \t     }; \n \n-\t   is illegal, but:\n+\t   is invalid, but:\n \n \t     template <class T> struct S {\n \t       template <class U> struct I;\n@@ -2220,7 +2220,7 @@ process_partial_specialization (decl)\n \t  struct S2<T>;\n        };\n \n-     The S2<T> declaration is actually illegal; it is a\n+     The S2<T> declaration is actually invalid; it is a\n      full-specialization.  Of course, \n \n \t  template <class U>\n@@ -2459,7 +2459,7 @@ check_default_tmpl_args (decl, parms, is_primary, is_partial)\n     /* If we're inside a class definition, there's no need to\n        examine the parameters to the class itself.  On the one\n        hand, they will be checked when the class is defined, and,\n-       on the other, default arguments are legal in things like:\n+       on the other, default arguments are valid in things like:\n          template <class T = double>\n          struct S { template <class U> void f(U); };\n        Here the default argument for `S' has no bearing on the\n@@ -2615,7 +2615,7 @@ push_template_decl_real (decl, is_friend)\n \t{\n \t  /* Since a template declaration already existed for this\n \t     class-type, we must be redeclaring it here.  Make sure\n-\t     that the redeclaration is legal.  */\n+\t     that the redeclaration is valid.  */\n \t  redeclare_class_template (TREE_TYPE (decl),\n \t\t\t\t    current_template_parms);\n \t  /* We don't need to create a new TEMPLATE_DECL; just use the\n@@ -3323,7 +3323,7 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n     {  \n       /* The template argument was the name of some\n \t member function.  That's usually\n-\t illegal, but static members are OK.  In any\n+\t invalid, but static members are OK.  In any\n \t case, grab the underlying fields/functions\n \t and issue an error later if required.  */\n       arg = TREE_VALUE (arg);\n@@ -3489,7 +3489,7 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n \t   extension, since deciding whether or not these\n \t   conversions can occur is part of determining which\n \t   function template to call, or whether a given explicit\n-\t   argument specification is legal.  */\n+\t   argument specification is valid.  */\n \tval = convert_nontype_argument (t, arg);\n       else\n \tval = arg;\n@@ -8414,7 +8414,7 @@ try_class_unification (tparms, targs, parm, arg)\n \n      Now, by the time we consider the unification involving `s2', we\n      already know that we must have `f<0, 0, 0>'.  But, even though\n-     `S<0, 1, 2>' is derived from `S<0, 0, 0>', the code is not legal\n+     `S<0, 1, 2>' is derived from `S<0, 0, 0>', the code is invalid\n      because there are two ways to unify base classes of S<0, 1, 2>\n      with S<I, I, I>.  If we kept the already deduced knowledge, we\n      would reject the possibility I=1.  */\n@@ -9257,7 +9257,7 @@ get_bindings_real (fn, decl, explicit_args, check_rettype, deduce, len)\n       if (DECL_TEMPLATE_INFO (decl))\n \ttmpl = DECL_TI_TEMPLATE (decl);\n       else\n-\t/* We can get here for some illegal specializations.  */\n+\t/* We can get here for some invalid specializations.  */\n \treturn NULL_TREE;\n \n       converted_args\n@@ -9571,7 +9571,7 @@ do_decl_instantiation (tree decl, tree storage)\n     result = decl;\n \n   /* Check for various error cases.  Note that if the explicit\n-     instantiation is legal the RESULT will currently be marked as an\n+     instantiation is valid the RESULT will currently be marked as an\n      *implicit* instantiation; DECL_EXPLICIT_INSTANTIATION is not set\n      until we get here.  */\n "}, {"sha": "cbe9b45b7a5394e3e3dadc1f1a64b27de9eddaa8", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3397527add2878d046cc271f4e0d51e19f6474/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3397527add2878d046cc271f4e0d51e19f6474/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=0e3397527add2878d046cc271f4e0d51e19f6474", "patch": "@@ -1551,7 +1551,7 @@ reset_type_access_control ()\n \n /* Begin a function definition declared with DECL_SPECS, ATTRIBUTES,\n    and DECLARATOR.  Returns non-zero if the function-declaration is\n-   legal.  */\n+   valid.  */\n \n int\n begin_function_definition (decl_specs, attributes, declarator)\n@@ -1877,7 +1877,7 @@ finish_member_declaration (decl)\n \t   struct S { enum E { }; int E } s;\n \t   s.E = 3;\n \n-\t is legal.  In addition, the FIELD_DECLs must be maintained in\n+\t is valid.  In addition, the FIELD_DECLs must be maintained in\n \t declaration order so that class layout works as expected.\n \t However, we don't need that order until class layout, so we\n \t save a little time by putting FIELD_DECLs on in reverse order\n@@ -2094,7 +2094,7 @@ check_multiple_declarators ()\n      contain at most one declarator.  \n \n      We don't just use PROCESSING_TEMPLATE_DECL for the first\n-     condition since that would disallow the perfectly legal code, \n+     condition since that would disallow the perfectly valid code, \n      like `template <class T> struct S { int i, j; };'.  */\n   if (at_function_scope_p ())\n     /* It's OK to write `template <class T> void f() { int i, j;}'.  */"}, {"sha": "09ecd66b4ad1ca2044ec5bea0f1ffbf4a02b82d2", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3397527add2878d046cc271f4e0d51e19f6474/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3397527add2878d046cc271f4e0d51e19f6474/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=0e3397527add2878d046cc271f4e0d51e19f6474", "patch": "@@ -857,7 +857,7 @@ comp_array_types (cmp, t1, t2, strict)\n     return 1;\n \n   /* If one of the arrays is dimensionless, and the other has a\n-     dimension, they are of different types.  However, it is legal to\n+     dimension, they are of different types.  However, it is valid to\n      write:\n \n        extern int a[];\n@@ -897,7 +897,7 @@ comptypes (t1, t2, strict)\n        extern int (*i)[];\n        int (*i)[8];\n \n-     is not legal, for example.  */\n+     is invalid, for example.  */\n   strict &= ~COMPARE_REDECLARATION;\n \n   /* Suppress errors caused by previously reported errors */\n@@ -1543,7 +1543,7 @@ expr_sizeof (e)\n       cxx_incomplete_type_error (e, TREE_TYPE (e));\n       return c_sizeof (char_type_node);\n     }\n-  /* It's illegal to say `sizeof (X::i)' for `i' a non-static data\n+  /* It's invalid to say `sizeof (X::i)' for `i' a non-static data\n      member unless you're in a non-static member of X.  So hand off to\n      resolve_offset_ref.  [expr.prim]  */\n   else if (TREE_CODE (e) == OFFSET_REF)\n@@ -3618,7 +3618,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n       return error_mark_node;\n     }\n \n-  /* Issue warnings about peculiar, but legal, uses of NULL.  */\n+  /* Issue warnings about peculiar, but valid, uses of NULL.  */\n   if (/* It's reasonable to use pointer values as operands of &&\n \t and ||, so NULL is no exception.  */\n       !(code == TRUTH_ANDIF_EXPR || code == TRUTH_ORIF_EXPR)\n@@ -5713,7 +5713,7 @@ dubious_conversion_warnings (type, expr, errtype, fndecl, parmnum)\n   if (TREE_CODE (type) == REFERENCE_TYPE)\n     type = TREE_TYPE (type);\n   \n-  /* Issue warnings about peculiar, but legal, uses of NULL.  */\n+  /* Issue warnings about peculiar, but valid, uses of NULL.  */\n   if (ARITHMETIC_TYPE_P (type) && expr == null_node)\n     {\n       if (fndecl)\n@@ -6065,7 +6065,7 @@ maybe_warn_about_returning_address_of_local (retval)\n     }\n }\n \n-/* Check that returning RETVAL from the current function is legal.\n+/* Check that returning RETVAL from the current function is valid.\n    Return an expression explicitly showing all conversions required to\n    change RETVAL into the function return type, and to assign it to\n    the DECL_RESULT for the function.  */"}]}