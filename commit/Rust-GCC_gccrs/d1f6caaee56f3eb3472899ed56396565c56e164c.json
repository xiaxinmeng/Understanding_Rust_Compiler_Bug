{"sha": "d1f6caaee56f3eb3472899ed56396565c56e164c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDFmNmNhYWVlNTZmM2ViMzQ3Mjg5OWVkNTYzOTY1NjVjNTZlMTY0Yw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2017-05-22T22:44:45Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2017-05-22T22:44:45Z"}, "message": "re PR target/80718 (GCC generates slow code for offsettable vec_duplicate)\n\n[gcc]\n2017-05-22  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/80718\n\t* config/rs6000/vsx.md (vsx_splat_<mode>, VSX_D iterator): Split\n\tV2DF/V2DI splat into two separate patterns, one that handles\n\tregisters, and the other that only handles memory.  Drop support\n\tfor splatting from a GPR on ISA 2.07 and then splitting the\n\tsplat into direct move and splat.\n\t(vsx_splat_<mode>_reg): Likewise.\n\t(vsx_splat_<mode>_mem): Likewise.\n\n[gcc/testsuite]\n2017-05-22  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/80718\n\t* gcc.target/powerpc/pr80718.c: New test.\n\nFrom-SVN: r248352", "tree": {"sha": "d6ad2a88a27ffdc08c333828b09a2a19a299df3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6ad2a88a27ffdc08c333828b09a2a19a299df3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1f6caaee56f3eb3472899ed56396565c56e164c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1f6caaee56f3eb3472899ed56396565c56e164c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1f6caaee56f3eb3472899ed56396565c56e164c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1f6caaee56f3eb3472899ed56396565c56e164c/comments", "author": null, "committer": null, "parents": [{"sha": "2ea0d750147582b5d7bf405dce36f864618eacbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ea0d750147582b5d7bf405dce36f864618eacbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ea0d750147582b5d7bf405dce36f864618eacbd"}], "stats": {"total": 364, "additions": 345, "deletions": 19}, "files": [{"sha": "6824450961bfa680ad0995b91114bf8aba49dac1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1f6caaee56f3eb3472899ed56396565c56e164c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1f6caaee56f3eb3472899ed56396565c56e164c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d1f6caaee56f3eb3472899ed56396565c56e164c", "patch": "@@ -1,3 +1,14 @@\n+2017-05-22  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/80718\n+\t* config/rs6000/vsx.md (vsx_splat_<mode>, VSX_D iterator): Split\n+\tV2DF/V2DI splat into two separate patterns, one that handles\n+\tregisters, and the other that only handles memory.  Drop support\n+\tfor splatting from a GPR on ISA 2.07 and then splitting the\n+\tsplat into direct move and splat.\n+\t(vsx_splat_<mode>_reg): Likewise.\n+\t(vsx_splat_<mode>_mem): Likewise.\n+\n 2017-05-22  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* cfgcleanup.c (bb_is_just_return): Allow CLOBBERs."}, {"sha": "b669764ce8f32f827ab891c3649f99db6e378fad", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1f6caaee56f3eb3472899ed56396565c56e164c/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1f6caaee56f3eb3472899ed56396565c56e164c/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=d1f6caaee56f3eb3472899ed56396565c56e164c", "patch": "@@ -3066,29 +3066,41 @@\n })\n \n ;; V2DF/V2DI splat\n-(define_insn_and_split \"vsx_splat_<mode>\"\n-  [(set (match_operand:VSX_D 0 \"vsx_register_operand\"\n-\t\t\t\t\t\"=<VSa>,    <VSa>,we,<VS_64dm>\")\n+;; We separate the register splat insn from the memory splat insn to force the\n+;; register allocator to generate the indexed form of the SPLAT when it is\n+;; given an offsettable memory reference.  Otherwise, if the register and\n+;; memory insns were combined into a single insn, the register allocator will\n+;; load the value into a register, and then do a double word permute.\n+(define_expand \"vsx_splat_<mode>\"\n+  [(set (match_operand:VSX_D 0 \"vsx_register_operand\")\n \t(vec_duplicate:VSX_D\n-\t (match_operand:<VS_scalar> 1 \"splat_input_operand\"\n-\t\t\t\t\t\"<VS_64reg>,Z,    b, wA\")))]\n+\t (match_operand:<VS_scalar> 1 \"input_operand\")))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n+{\n+  rtx op1 = operands[1];\n+  if (MEM_P (op1))\n+    operands[1] = rs6000_address_for_fpconvert (op1);\n+  else if (!REG_P (op1))\n+    op1 = force_reg (<VSX_D:VS_scalar>mode, op1);\n+})\n+\n+(define_insn \"vsx_splat_<mode>_reg\"\n+  [(set (match_operand:VSX_D 0 \"vsx_register_operand\" \"=<VSX_D:VSa>,?we\")\n+\t(vec_duplicate:VSX_D\n+\t (match_operand:<VS_scalar> 1 \"gpc_reg_operand\" \"<VSX_D:VS_64reg>,b\")))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n   \"@\n    xxpermdi %x0,%x1,%x1,0\n-   lxvdsx %x0,%y1\n-   mtvsrdd %x0,%1,%1\n-   #\"\n-  \"&& reload_completed && TARGET_POWERPC64 && !TARGET_P9_VECTOR\n-   && int_reg_operand (operands[1], <VS_scalar>mode)\"\n-  [(set (match_dup 2)\n-\t(match_dup 1))\n-   (set (match_dup 0)\n-\t(vec_duplicate:VSX_D (match_dup 2)))]\n-{\n-  operands[2] = gen_rtx_REG (<VS_scalar>mode, reg_or_subregno (operands[0]));\n-}\n-  [(set_attr \"type\" \"vecperm,vecload,vecperm,vecperm\")\n-   (set_attr \"length\" \"4,4,4,8\")])\n+   mtvsrdd %x0,%1,%1\"\n+  [(set_attr \"type\" \"vecperm\")])\n+\n+(define_insn \"vsx_splat_<VSX_D:mode>_mem\"\n+  [(set (match_operand:VSX_D 0 \"vsx_register_operand\" \"=<VSX_D:VSa>\")\n+\t(vec_duplicate:VSX_D\n+\t (match_operand:<VSX_D:VS_scalar> 1 \"memory_operand\" \"Z\")))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n+  \"lxvdsx %x0,%y1\"\n+  [(set_attr \"type\" \"vecload\")])\n \n ;; V4SI splat support\n (define_insn \"vsx_splat_v4si\""}, {"sha": "702940b67dfcc53b01fc24c1c92861368db29182", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1f6caaee56f3eb3472899ed56396565c56e164c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1f6caaee56f3eb3472899ed56396565c56e164c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d1f6caaee56f3eb3472899ed56396565c56e164c", "patch": "@@ -1,3 +1,8 @@\n+2017-05-22  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/80718\n+\t* gcc.target/powerpc/pr80718.c: New test.\n+\n 2017-05-22  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* gcc.target/powerpc/conditional-return.c: New testcase."}, {"sha": "9ac5b1b684fbbff66c3019a52acbd1b71636bc14", "filename": "gcc/testsuite/gcc.target/powerpc/pr80718.c", "status": "added", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1f6caaee56f3eb3472899ed56396565c56e164c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr80718.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1f6caaee56f3eb3472899ed56396565c56e164c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr80718.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr80718.c?ref=d1f6caaee56f3eb3472899ed56396565c56e164c", "patch": "@@ -0,0 +1,298 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O3 -ffast-math\" } */\n+\n+/* Taken from the Spec 2006 milc brenchmark.  Ultimately, GCC wants to generate\n+   a DF splat from offsettable memory.  The register allocator decided it was\n+   better to do the load in the GPR registers and do a move direct, rather than\n+   doing a load in the VSX register sets.  */\n+\n+typedef struct\n+{\n+  double real;\n+  double imag;\n+} complex;\n+\n+typedef struct\n+{\n+  double real;\n+  double imag;\n+} double_complex;\n+\n+complex cmplx (double x, double y);\n+complex cadd (complex * a, complex * b);\n+complex cmul (complex * a, complex * b);\n+complex csub (complex * a, complex * b);\n+complex cdiv (complex * a, complex * b);\n+complex conjg (complex * a);\n+complex ce_itheta (double theta);\n+\n+double_complex dcmplx (double x, double y);\n+double_complex dcadd (double_complex * a, double_complex * b);\n+double_complex dcmul (double_complex * a, double_complex * b);\n+double_complex dcsub (double_complex * a, double_complex * b);\n+double_complex dcdiv (double_complex * a, double_complex * b);\n+double_complex dconjg (double_complex * a);\n+double_complex dcexp (double_complex * a);\n+double_complex dclog (double_complex * a);\n+double_complex dcsqrt (double_complex * z);\n+double_complex dce_itheta (double theta);\n+\n+typedef struct\n+{\n+  unsigned long r0, r1, r2, r3, r4, r5, r6;\n+  unsigned long multiplier, addend, ic_state;\n+  double scale;\n+} double_prn;\n+\n+double myrand (double_prn * prn_pt);\n+\n+typedef struct\n+{\n+  complex e[3][3];\n+} su3_matrix;\n+\n+typedef struct\n+{\n+  complex c[3];\n+} su3_vector;\n+\n+typedef struct\n+{\n+  complex m01, m02, m12;\n+  double m00im, m11im, m22im;\n+  double space;\n+} anti_hermitmat;\n+\n+typedef struct\n+{\n+  complex e[2][2];\n+} su2_matrix;\n+typedef struct\n+{\n+  su3_vector d[4];\n+} wilson_vector;\n+typedef struct\n+{\n+  su3_vector h[2];\n+} half_wilson_vector;\n+typedef struct\n+{\n+  wilson_vector c[3];\n+} color_wilson_vector;\n+typedef struct\n+{\n+  wilson_vector d[4];\n+} spin_wilson_vector;\n+typedef struct\n+{\n+  color_wilson_vector d[4];\n+} wilson_matrix;\n+typedef struct\n+{\n+  spin_wilson_vector c[3];\n+} wilson_propagator;\n+\n+void mult_su3_nn (su3_matrix * a, su3_matrix * b, su3_matrix * c);\n+void mult_su3_na (su3_matrix * a, su3_matrix * b, su3_matrix * c);\n+void mult_su3_an (su3_matrix * a, su3_matrix * b, su3_matrix * c);\n+double realtrace_su3 (su3_matrix * a, su3_matrix * b);\n+complex trace_su3 (su3_matrix * a);\n+complex complextrace_su3 (su3_matrix * a, su3_matrix * b);\n+complex det_su3 (su3_matrix * a);\n+void add_su3_matrix (su3_matrix * a, su3_matrix * b, su3_matrix * c);\n+void sub_su3_matrix (su3_matrix * a, su3_matrix * b, su3_matrix * c);\n+void scalar_mult_su3_matrix (su3_matrix * src, double scalar,\n+\t\t\t     su3_matrix * dest);\n+void scalar_mult_add_su3_matrix (su3_matrix * src1, su3_matrix * src2,\n+\t\t\t\t double scalar, su3_matrix * dest);\n+void scalar_mult_sub_su3_matrix (su3_matrix * src1, su3_matrix * src2,\n+\t\t\t\t double scalar, su3_matrix * dest);\n+void c_scalar_mult_su3mat (su3_matrix * src, complex * scalar,\n+\t\t\t   su3_matrix * dest);\n+void c_scalar_mult_add_su3mat (su3_matrix * src1, su3_matrix * src2,\n+\t\t\t       complex * scalar, su3_matrix * dest);\n+void c_scalar_mult_sub_su3mat (su3_matrix * src1, su3_matrix * src2,\n+\t\t\t       complex * scalar, su3_matrix * dest);\n+void su3_adjoint (su3_matrix * a, su3_matrix * b);\n+void make_anti_hermitian (su3_matrix * m3, anti_hermitmat * ah3);\n+void random_anti_hermitian (anti_hermitmat * mat_antihermit,\n+\t\t\t    double_prn * prn_pt);\n+void uncompress_anti_hermitian (anti_hermitmat * mat_anti, su3_matrix * mat);\n+void compress_anti_hermitian (su3_matrix * mat, anti_hermitmat * mat_anti);\n+void clear_su3mat (su3_matrix * dest);\n+void su3mat_copy (su3_matrix * a, su3_matrix * b);\n+void dumpmat (su3_matrix * m);\n+\n+void su3_projector (su3_vector * a, su3_vector * b, su3_matrix * c);\n+complex su3_dot (su3_vector * a, su3_vector * b);\n+double su3_rdot (su3_vector * a, su3_vector * b);\n+double magsq_su3vec (su3_vector * a);\n+void su3vec_copy (su3_vector * a, su3_vector * b);\n+void dumpvec (su3_vector * v);\n+void clearvec (su3_vector * v);\n+\n+void mult_su3_mat_vec (su3_matrix * a, su3_vector * b, su3_vector * c);\n+void mult_su3_mat_vec_sum (su3_matrix * a, su3_vector * b, su3_vector * c);\n+void mult_su3_mat_vec_sum_4dir (su3_matrix * a, su3_vector * b0,\n+\t\t\t\tsu3_vector * b1, su3_vector * b2,\n+\t\t\t\tsu3_vector * b3, su3_vector * c);\n+void mult_su3_mat_vec_nsum (su3_matrix * a, su3_vector * b, su3_vector * c);\n+void mult_adj_su3_mat_vec (su3_matrix * a, su3_vector * b, su3_vector * c);\n+void mult_adj_su3_mat_vec_4dir (su3_matrix * a, su3_vector * b,\n+\t\t\t\tsu3_vector * c);\n+void mult_adj_su3_mat_4vec (su3_matrix * mat, su3_vector * src,\n+\t\t\t    su3_vector * dest0, su3_vector * dest1,\n+\t\t\t    su3_vector * dest2, su3_vector * dest3);\n+void mult_adj_su3_mat_vec_sum (su3_matrix * a, su3_vector * b,\n+\t\t\t       su3_vector * c);\n+void mult_adj_su3_mat_vec_nsum (su3_matrix * a, su3_vector * b,\n+\t\t\t\tsu3_vector * c);\n+\n+void add_su3_vector (su3_vector * a, su3_vector * b, su3_vector * c);\n+void sub_su3_vector (su3_vector * a, su3_vector * b, su3_vector * c);\n+void sub_four_su3_vecs (su3_vector * a, su3_vector * b1, su3_vector * b2,\n+\t\t\tsu3_vector * b3, su3_vector * b4);\n+\n+void scalar_mult_su3_vector (su3_vector * src, double scalar,\n+\t\t\t     su3_vector * dest);\n+void scalar_mult_add_su3_vector (su3_vector * src1, su3_vector * src2,\n+\t\t\t\t double scalar, su3_vector * dest);\n+void scalar_mult_sum_su3_vector (su3_vector * src1, su3_vector * src2,\n+\t\t\t\t double scalar);\n+void scalar_mult_sub_su3_vector (su3_vector * src1, su3_vector * src2,\n+\t\t\t\t double scalar, su3_vector * dest);\n+void scalar_mult_wvec (wilson_vector * src, double s, wilson_vector * dest);\n+void scalar_mult_hwvec (half_wilson_vector * src, double s,\n+\t\t\thalf_wilson_vector * dest);\n+void scalar_mult_add_wvec (wilson_vector * src1, wilson_vector * src2,\n+\t\t\t   double scalar, wilson_vector * dest);\n+void scalar_mult_addtm_wvec (wilson_vector * src1, wilson_vector * src2,\n+\t\t\t     double scalar, wilson_vector * dest);\n+void c_scalar_mult_wvec (wilson_vector * src1, complex * phase,\n+\t\t\t wilson_vector * dest);\n+void c_scalar_mult_add_wvec (wilson_vector * src1, wilson_vector * src2,\n+\t\t\t     complex * phase, wilson_vector * dest);\n+void c_scalar_mult_add_wvec2 (wilson_vector * src1, wilson_vector * src2,\n+\t\t\t      complex s, wilson_vector * dest);\n+void c_scalar_mult_su3vec (su3_vector * src, complex * phase,\n+\t\t\t   su3_vector * dest);\n+void c_scalar_mult_add_su3vec (su3_vector * v1, complex * phase,\n+\t\t\t       su3_vector * v2);\n+void c_scalar_mult_sub_su3vec (su3_vector * v1, complex * phase,\n+\t\t\t       su3_vector * v2);\n+\n+void left_su2_hit_n (su2_matrix * u, int p, int q, su3_matrix * link);\n+void right_su2_hit_a (su2_matrix * u, int p, int q, su3_matrix * link);\n+void dumpsu2 (su2_matrix * u);\n+void mult_su2_mat_vec_elem_n (su2_matrix * u, complex * x0, complex * x1);\n+void mult_su2_mat_vec_elem_a (su2_matrix * u, complex * x0, complex * x1);\n+\n+void mult_mat_wilson_vec (su3_matrix * mat, wilson_vector * src,\n+\t\t\t  wilson_vector * dest);\n+void mult_su3_mat_hwvec (su3_matrix * mat, half_wilson_vector * src,\n+\t\t\t half_wilson_vector * dest);\n+void mult_adj_mat_wilson_vec (su3_matrix * mat, wilson_vector * src,\n+\t\t\t      wilson_vector * dest);\n+void mult_adj_su3_mat_hwvec (su3_matrix * mat, half_wilson_vector * src,\n+\t\t\t     half_wilson_vector * dest);\n+\n+void add_wilson_vector (wilson_vector * src1, wilson_vector * src2,\n+\t\t\twilson_vector * dest);\n+void sub_wilson_vector (wilson_vector * src1, wilson_vector * src2,\n+\t\t\twilson_vector * dest);\n+double magsq_wvec (wilson_vector * src);\n+complex wvec_dot (wilson_vector * src1, wilson_vector * src2);\n+complex wvec2_dot (wilson_vector * src1, wilson_vector * src2);\n+double wvec_rdot (wilson_vector * a, wilson_vector * b);\n+\n+void wp_shrink (wilson_vector * src, half_wilson_vector * dest,\n+\t\tint dir, int sign);\n+void wp_shrink_4dir (wilson_vector * a, half_wilson_vector * b1,\n+\t\t     half_wilson_vector * b2, half_wilson_vector * b3,\n+\t\t     half_wilson_vector * b4, int sign);\n+void wp_grow (half_wilson_vector * src, wilson_vector * dest,\n+\t      int dir, int sign);\n+void wp_grow_add (half_wilson_vector * src, wilson_vector * dest,\n+\t\t  int dir, int sign);\n+void grow_add_four_wvecs (wilson_vector * a, half_wilson_vector * b1,\n+\t\t\t  half_wilson_vector * b2, half_wilson_vector * b3,\n+\t\t\t  half_wilson_vector * b4, int sign, int sum);\n+void mult_by_gamma (wilson_vector * src, wilson_vector * dest, int dir);\n+void mult_by_gamma_left (wilson_matrix * src, wilson_matrix * dest, int dir);\n+void mult_by_gamma_right (wilson_matrix * src, wilson_matrix * dest, int dir);\n+void mult_swv_by_gamma_l (spin_wilson_vector * src, spin_wilson_vector * dest,\n+\t\t\t  int dir);\n+void mult_swv_by_gamma_r (spin_wilson_vector * src, spin_wilson_vector * dest,\n+\t\t\t  int dir);\n+void su3_projector_w (wilson_vector * a, wilson_vector * b, su3_matrix * c);\n+void clear_wvec (wilson_vector * dest);\n+void copy_wvec (wilson_vector * src, wilson_vector * dest);\n+void dump_wilson_vec (wilson_vector * src);\n+\n+double gaussian_rand_no (double_prn * prn_pt);\n+typedef int int32type;\n+typedef unsigned int u_int32type;\n+void byterevn (int32type w[], int n);\n+\n+void\n+mult_adj_su3_mat_vec (su3_matrix * a, su3_vector * b, su3_vector * c)\n+{\n+  int i;\n+  register double t, ar, ai, br, bi, cr, ci;\n+  for (i = 0; i < 3; i++)\n+    {\n+      ar = a->e[0][i].real;\n+      ai = a->e[0][i].imag;\n+\n+      br = b->c[0].real;\n+      bi = b->c[0].imag;\n+\n+      cr = ar * br;\n+      t = ai * bi;\n+      cr += t;\n+\n+      ci = ar * bi;\n+      t = ai * br;\n+      ci -= t;\n+\n+      ar = a->e[1][i].real;\n+      ai = a->e[1][i].imag;\n+\n+      br = b->c[1].real;\n+      bi = b->c[1].imag;\n+\n+      t = ar * br;\n+      cr += t;\n+      t = ai * bi;\n+      cr += t;\n+\n+      t = ar * bi;\n+      ci += t;\n+      t = ai * br;\n+      ci -= t;\n+\n+      ar = a->e[2][i].real;\n+      ai = a->e[2][i].imag;\n+\n+      br = b->c[2].real;\n+      bi = b->c[2].imag;\n+\n+      t = ar * br;\n+      cr += t;\n+      t = ai * bi;\n+      cr += t;\n+\n+      t = ar * bi;\n+      ci += t;\n+      t = ai * br;\n+      ci -= t;\n+\n+      c->c[i].real = cr;\n+      c->c[i].imag = ci;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-not \"mtvsrd\" } } */"}]}