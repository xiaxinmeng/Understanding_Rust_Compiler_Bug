{"sha": "b8363a243d4778afbdcc3794c86a7e08eb076f76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjgzNjNhMjQzZDQ3NzhhZmJkY2MzNzk0Yzg2YTdlMDhlYjA3NmY3Ng==", "commit": {"author": {"name": "Zack Weinberg", "email": "zackw@stanford.edu", "date": "2001-07-01T18:48:13Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2001-07-01T18:48:13Z"}, "message": "c-common.h (enum rid): Add RID_FIRST_AT, RID_LAST_AT, RID_LAST_PQ.\n\n\t* c-common.h (enum rid): Add RID_FIRST_AT, RID_LAST_AT,\n\tRID_LAST_PQ.  Move RID_FIRST_PQ down with the other FIRST/LAST\n\tenumerators.\n\t(OBJC_IS_AT_KEYWORD, OBJC_IS_PQ_KEYWORD): New macros.\n\n\t* c-parse.in (OBJC_STRING): Kill.\n\t(objc_string): Decompose to [objc_string] '@' STRING.\n\t(reswords): Take the leading '@' off all the Objective C keywords.\n\t(objc_rid_sans_at): Kill.\n\t(init_reswords): Don't initialize it.\n\t(yylexname): Use OBJC_IS_AT_KEYWORD and OBJC_IS_PQ_KEYWORD.\n\t(_yylex): Kill reconsider label.  Look ahead one token after\n\tan '@'; if we get an identifier, check whether it's an\n\tObjective C @-keyword.  If so, return the keyword.  Otherwise,\n\tput back the token and return the '@' as a terminal.\n\n\t* cpplib.c (lex_macro_node): Remove unnecessary check for\n\tleading '@' on identifier.  Clarify control flow and commentary.\n\nFrom-SVN: r43674", "tree": {"sha": "3248bbe65b87f7c0868d63322c7f0b313358975f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3248bbe65b87f7c0868d63322c7f0b313358975f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8363a243d4778afbdcc3794c86a7e08eb076f76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8363a243d4778afbdcc3794c86a7e08eb076f76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8363a243d4778afbdcc3794c86a7e08eb076f76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8363a243d4778afbdcc3794c86a7e08eb076f76/comments", "author": null, "committer": null, "parents": [{"sha": "128e8aa95204284655c889767409150181ce0b19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/128e8aa95204284655c889767409150181ce0b19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/128e8aa95204284655c889767409150181ce0b19"}], "stats": {"total": 176, "additions": 100, "deletions": 76}, "files": [{"sha": "6077e4585240944a13c16279a42b02b39565c438", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8363a243d4778afbdcc3794c86a7e08eb076f76/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8363a243d4778afbdcc3794c86a7e08eb076f76/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b8363a243d4778afbdcc3794c86a7e08eb076f76", "patch": "@@ -1,3 +1,24 @@\n+2001-07-01  Zack Weinberg  <zackw@stanford.edu>\n+\n+\t* c-common.h (enum rid): Add RID_FIRST_AT, RID_LAST_AT,\n+\tRID_LAST_PQ.  Move RID_FIRST_PQ down with the other FIRST/LAST\n+\tenumerators.\n+\t(OBJC_IS_AT_KEYWORD, OBJC_IS_PQ_KEYWORD): New macros.\n+\n+\t* c-parse.in (OBJC_STRING): Kill.\n+\t(objc_string): Decompose to [objc_string] '@' STRING.\n+\t(reswords): Take the leading '@' off all the Objective C keywords.\n+\t(objc_rid_sans_at): Kill.\n+\t(init_reswords): Don't initialize it.\n+\t(yylexname): Use OBJC_IS_AT_KEYWORD and OBJC_IS_PQ_KEYWORD.\n+\t(_yylex): Kill reconsider label.  Look ahead one token after\n+\tan '@'; if we get an identifier, check whether it's an\n+\tObjective C @-keyword.  If so, return the keyword.  Otherwise,\n+\tput back the token and return the '@' as a terminal.\n+\n+\t* cpplib.c (lex_macro_node): Remove unnecessary check for\n+\tleading '@' on identifier.  Clarify control flow and commentary.\n+\n Sun Jul  1 11:53:52 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* cse.c (new_label_ref): Variable deleted."}, {"sha": "95ead5424412b96da3291b6c97a7b1c08679757f", "filename": "gcc/c-common.h", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8363a243d4778afbdcc3794c86a7e08eb076f76/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8363a243d4778afbdcc3794c86a7e08eb076f76/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=b8363a243d4778afbdcc3794c86a7e08eb076f76", "patch": "@@ -63,7 +63,7 @@ enum rid\n   RID_FRIEND, RID_VIRTUAL, RID_EXPLICIT, RID_EXPORT, RID_MUTABLE,\n \n   /* ObjC */\n-  RID_FIRST_PQ, RID_IN = RID_FIRST_PQ, RID_OUT, RID_INOUT, RID_BYCOPY, RID_BYREF, RID_ONEWAY,\n+  RID_IN, RID_OUT, RID_INOUT, RID_BYCOPY, RID_BYREF, RID_ONEWAY,\n \n   /* C */\n   RID_INT,     RID_CHAR,   RID_FLOAT,    RID_DOUBLE, RID_VOID,\n@@ -107,9 +107,22 @@ enum rid\n   RID_MAX,\n \n   RID_FIRST_MODIFIER = RID_STATIC,\n-  RID_LAST_MODIFIER = RID_ONEWAY\n+  RID_LAST_MODIFIER = RID_ONEWAY,\n+\n+  RID_FIRST_AT = RID_AT_ENCODE,\n+  RID_LAST_AT = RID_AT_IMPLEMENTATION,\n+  RID_FIRST_PQ = RID_IN,\n+  RID_LAST_PQ = RID_ONEWAY\n };\n \n+#define OBJC_IS_AT_KEYWORD(rid) \\\n+  ((unsigned int)(rid) >= (unsigned int)RID_FIRST_AT && \\\n+   (unsigned int)(rid) <= (unsigned int)RID_LAST_AT)\n+\n+#define OBJC_IS_PQ_KEYWORD(rid) \\\n+  ((unsigned int)(rid) >= (unsigned int)RID_FIRST_PQ && \\\n+   (unsigned int)(rid) <= (unsigned int)RID_LAST_PQ)\n+\n /* The elements of `ridpointers' are identifier nodes for the reserved\n    type names and storage classes.  It is indexed by a RID_... value.  */\n extern tree *ridpointers;"}, {"sha": "9a7fe1cd34f9338ef1d088ff43f500b726c98ee0", "filename": "gcc/c-parse.in", "status": "modified", "additions": 45, "deletions": 59, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8363a243d4778afbdcc3794c86a7e08eb076f76/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8363a243d4778afbdcc3794c86a7e08eb076f76/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=b8363a243d4778afbdcc3794c86a7e08eb076f76", "patch": "@@ -157,11 +157,6 @@ end ifc\n %token INTERFACE IMPLEMENTATION END SELECTOR DEFS ENCODE\n %token CLASSNAME PUBLIC PRIVATE PROTECTED PROTOCOL OBJECTNAME CLASS ALIAS\n \n-/* Objective-C string constants in raw form.\n-   yylval is an STRING_CST node.  */\n-%token OBJC_STRING\n-\n-\n %type <code> unop\n %type <ttype> ENUM STRUCT UNION IF ELSE WHILE DO FOR SWITCH CASE DEFAULT\n %type <ttype> BREAK CONTINUE RETURN GOTO ASM_KEYWORD SIZEOF TYPEOF ALIGNOF\n@@ -231,7 +226,7 @@ ifobjc\n %type <ttype> selectorarg keywordnamelist keywordname objcencodeexpr\n %type <ttype> objc_string non_empty_protocolrefs protocolrefs identifier_list objcprotocolexpr\n \n-%type <ttype> CLASSNAME OBJC_STRING OBJECTNAME\n+%type <ttype> CLASSNAME OBJECTNAME\n end ifobjc\n \f\n %{\n@@ -767,9 +762,10 @@ ifobjc\n /* Produces an STRING_CST with perhaps more STRING_CSTs chained\n    onto it, which is to be read as an ObjC string object.  */\n objc_string:\n-\t  OBJC_STRING\n-\t| objc_string OBJC_STRING\n-\t\t{ $$ = chainon ($1, $2); }\n+\t  '@' STRING\n+\t\t{ $$ = $2; }\n+\t| objc_string '@' STRING\n+\t\t{ $$ = chainon ($1, $3); }\n \t;\n end ifobjc\n \n@@ -3407,19 +3403,25 @@ static const struct resword reswords[] =\n   { \"volatile\",\t\tRID_VOLATILE,\tD_TRAD },\n   { \"while\",\t\tRID_WHILE,\t0 },\n ifobjc\n-  { \"@class\",\t\tRID_AT_CLASS,\t\tD_OBJC },\n-  { \"@compatibility_alias\", RID_AT_ALIAS,\tD_OBJC },\n-  { \"@defs\",\t\tRID_AT_DEFS,\t\tD_OBJC },\n-  { \"@encode\",\t\tRID_AT_ENCODE,\t\tD_OBJC },\n-  { \"@end\",\t\tRID_AT_END,\t\tD_OBJC },\n-  { \"@implementation\",\tRID_AT_IMPLEMENTATION,\tD_OBJC },\n-  { \"@interface\",\tRID_AT_INTERFACE,\tD_OBJC },\n-  { \"@private\",\t\tRID_AT_PRIVATE,\t\tD_OBJC },\n-  { \"@protected\",\tRID_AT_PROTECTED,\tD_OBJC },\n-  { \"@protocol\",\tRID_AT_PROTOCOL,\tD_OBJC },\n-  { \"@public\",\t\tRID_AT_PUBLIC,\t\tD_OBJC },\n-  { \"@selector\",\tRID_AT_SELECTOR,\tD_OBJC },\n   { \"id\",\t\tRID_ID,\t\t\tD_OBJC },\n+\n+  /* These objc keywords are recognized only immediately after\n+     an '@'.  */\n+  { \"class\",\t\tRID_AT_CLASS,\t\tD_OBJC },\n+  { \"compatibility_alias\", RID_AT_ALIAS,\tD_OBJC },\n+  { \"defs\",\t\tRID_AT_DEFS,\t\tD_OBJC },\n+  { \"encode\",\t\tRID_AT_ENCODE,\t\tD_OBJC },\n+  { \"end\",\t\tRID_AT_END,\t\tD_OBJC },\n+  { \"implementation\",\tRID_AT_IMPLEMENTATION,\tD_OBJC },\n+  { \"interface\",\tRID_AT_INTERFACE,\tD_OBJC },\n+  { \"private\",\t\tRID_AT_PRIVATE,\t\tD_OBJC },\n+  { \"protected\",\tRID_AT_PROTECTED,\tD_OBJC },\n+  { \"protocol\",\t\tRID_AT_PROTOCOL,\tD_OBJC },\n+  { \"public\",\t\tRID_AT_PUBLIC,\t\tD_OBJC },\n+  { \"selector\",\t\tRID_AT_SELECTOR,\tD_OBJC },\n+\n+  /* These are recognized only in protocol-qualifier context\n+     (see above) */\n   { \"bycopy\",\t\tRID_BYCOPY,\t\tD_OBJC },\n   { \"byref\",\t\tRID_BYREF,\t\tD_OBJC },\n   { \"in\",\t\tRID_IN,\t\t\tD_OBJC },\n@@ -3568,13 +3570,6 @@ static const short rid_to_yy[RID_MAX] =\n   /* RID_AT_IMPLEMENTATION */\tIMPLEMENTATION\n };\n \n-ifobjc\n-/* Lookup table for ObjC keywords beginning with '@'.  Crude but\n-   hopefully effective.  */\n-#define N_at_reswords ((int) RID_AT_IMPLEMENTATION - (int)RID_AT_ENCODE + 1)\n-static tree objc_rid_sans_at[N_at_reswords];\n-end ifobjc\n-\n static void\n init_reswords ()\n {\n@@ -3602,16 +3597,6 @@ init_reswords ()\n       C_RID_CODE (id) = reswords[i].rid;\n       C_IS_RESERVED_WORD (id) = 1;\n       ridpointers [(int) reswords[i].rid] = id;\n-\n-ifobjc\n-      /* Enter ObjC @-prefixed keywords into the \"sans\" table\n-\t _without_ their leading at-sign.  Again, all these\n-\t identifiers are reachable by the get_identifer table, so it's\n-\t not necessary to make objc_rid_sans_at a GC root.  */\n-      if (reswords[i].word[0] == '@')\n-\tobjc_rid_sans_at[(int) reswords[i].rid - (int) RID_AT_ENCODE]\n-\t  = get_identifier (reswords[i].word + 1);\n-end ifobjc\n     }\n }\n \n@@ -3680,8 +3665,8 @@ yylexname ()\n       enum rid rid_code = C_RID_CODE (yylval.ttype);\n \n ifobjc\n-      if (!((unsigned int) rid_code - (unsigned int) RID_FIRST_PQ < 6)\n-\t  || objc_pq_context)\n+      if (!OBJC_IS_AT_KEYWORD (rid_code)\n+\t  && (!OBJC_IS_PQ_KEYWORD (rid_code) || objc_pq_context))\n end ifobjc\n       {\n \tint yycode = rid_to_yy[(int) rid_code];\n@@ -3730,9 +3715,6 @@ _yylex ()\n {\n  get_next:\n   last_token = c_lex (&yylval.ttype);\n-ifobjc\n- reconsider:\n-end ifobjc\n   switch (last_token)\n     {\n     case CPP_EQ:\t\t\t\t\treturn '=';\n@@ -3809,23 +3791,27 @@ end ifobjc\n \t token special significance.  */\n     case CPP_ATSIGN:\n ifobjc\n-      last_token = c_lex (&yylval.ttype);\n-      if (last_token == CPP_STRING)\n-\treturn OBJC_STRING;\n-      else if (last_token == CPP_NAME)\n-\t{\n-\t  int i;\n-\t  for (i = 0; i < N_at_reswords; i++)\n-\t    if (objc_rid_sans_at[i] == yylval.ttype)\n-\t      {\n-\t\tint rid_code = i + (int) RID_AT_ENCODE;\n-\t\tyylval.ttype = ridpointers[rid_code];\n-\t\treturn rid_to_yy[rid_code];\n-\t      }\n-\t}\n-      error (\"syntax error at '@' token\");\n-      goto reconsider;\n+      {\n+\ttree after_at;\n+\tenum cpp_ttype after_at_type;\n+\n+\tcpp_start_lookahead (parse_in);\n+\tafter_at_type = c_lex (&after_at);\n+\n+\tif (after_at_type == CPP_NAME\n+\t    && C_IS_RESERVED_WORD (after_at)\n+\t    && OBJC_IS_AT_KEYWORD (C_RID_CODE (after_at)))\n+\t  {\n+\t    cpp_stop_lookahead (parse_in, 1);  /* accept this token */\n+\t    yylval.ttype = after_at;\n+\t    last_token = after_at_type;\n+\t    return rid_to_yy [(int) C_RID_CODE (after_at)];\n+\t  }\n+\tcpp_stop_lookahead (parse_in, 0);  /* put back this token */\n+\treturn '@';\n+      }\n end ifobjc\n+\n       /* These tokens are C++ specific (and will not be generated\n          in C mode, but let's be cautious).  */\n     case CPP_SCOPE:"}, {"sha": "e0f61247c466fdff3ae280e4491226d669790fb1", "filename": "gcc/cpplib.c", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8363a243d4778afbdcc3794c86a7e08eb076f76/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8363a243d4778afbdcc3794c86a7e08eb076f76/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=b8363a243d4778afbdcc3794c86a7e08eb076f76", "patch": "@@ -438,14 +438,17 @@ lex_macro_node (pfile)\n      cpp_reader *pfile;\n {\n   cpp_token token;\n+  cpp_hashnode *node;\n \n   /* Lex the macro name directly.  */\n   _cpp_lex_token (pfile, &token);\n \n   /* The token immediately after #define must be an identifier.  That\n-     identifier is not allowed to be \"defined\".  See predefined macro\n-     names (6.10.8.4).  In C++, it is not allowed to be any of the\n-     <iso646.h> macro names (which are keywords in C++) either.  */\n+     identifier may not be \"defined\", per C99 6.10.8p4.\n+     In C++, it may not be any of the \"named operators\" either,\n+     per C++98 [lex.digraph], [lex.key].\n+     Finally, the identifier may not have been poisoned.  (In that case\n+     the lexer has issued the error message for us.)  */\n \n   if (token.type != CPP_NAME)\n     {\n@@ -454,25 +457,26 @@ lex_macro_node (pfile)\n \t\t   pfile->directive->name);\n       else if (token.flags & NAMED_OP)\n \tcpp_error (pfile,\n-\t\t   \"\\\"%s\\\" cannot be used as a macro name as it is an operator in C++\",\n+\t   \"\\\"%s\\\" cannot be used as a macro name as it is an operator in C++\",\n \t\t   NODE_NAME (token.val.node));\n       else\n \tcpp_error (pfile, \"macro names must be identifiers\");\n+\n+      return 0;\n     }\n-  else\n+\n+  node = token.val.node;\n+  if (node->flags & NODE_POISONED)\n+    return 0;\n+\n+  if (node == pfile->spec_nodes.n_defined)\n     {\n-      cpp_hashnode *node = token.val.node;\n-\n-      /* In Objective C, some keywords begin with '@', but general\n-\t identifiers do not, and you're not allowed to #define them.  */\n-      if (node == pfile->spec_nodes.n_defined || NODE_NAME (node)[0] == '@')\n-\tcpp_error (pfile, \"\\\"%s\\\" cannot be used as a macro name\",\n-\t\t   NODE_NAME (node));\n-      else if (!(node->flags & NODE_POISONED))\n-\treturn node;\n+      cpp_error (pfile, \"\\\"%s\\\" cannot be used as a macro name\",\n+\t\t NODE_NAME (node));\n+      return 0;\n     }\n \n-  return 0;\n+  return node;\n }\n \n /* Process a #define directive.  Most work is done in cppmacro.c.  */"}]}