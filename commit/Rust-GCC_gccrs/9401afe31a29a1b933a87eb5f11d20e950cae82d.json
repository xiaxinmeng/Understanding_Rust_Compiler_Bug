{"sha": "9401afe31a29a1b933a87eb5f11d20e950cae82d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQwMWFmZTMxYTI5YTFiOTMzYTg3ZWI1ZjExZDIwZTk1MGNhZTgyZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-06-22T23:27:48Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-06-22T23:27:48Z"}, "message": "flow.c (mark_set_1, [...]): compute REG_FREQ using bb->frequency.\n\n\t* flow.c (mark_set_1, attempt_auto_inc, mark_used_reg,\n\ttry_pre_increment_1): compute REG_FREQ using bb->frequency.\n\n\t* regclass.c (loop_cost): Kill.\n\t(frequency): New global variable.\n\t(record_operand_costs): Replace loop_cost by frequency.\n\t(scan_one_insn): Likewise.\n\t(regclass): Likewise; set frequency according to bb->frequency.\n\n\t* flow.c (split_edge): Set frequency.\n\nFrom-SVN: r43523", "tree": {"sha": "1487bbd44b4837e8ff22896787a36be48e22e427", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1487bbd44b4837e8ff22896787a36be48e22e427"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9401afe31a29a1b933a87eb5f11d20e950cae82d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9401afe31a29a1b933a87eb5f11d20e950cae82d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9401afe31a29a1b933a87eb5f11d20e950cae82d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9401afe31a29a1b933a87eb5f11d20e950cae82d/comments", "author": null, "committer": null, "parents": [{"sha": "44f498639c0cdfd08c184f834ebae07b8dc51831", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44f498639c0cdfd08c184f834ebae07b8dc51831", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44f498639c0cdfd08c184f834ebae07b8dc51831"}], "stats": {"total": 56, "additions": 36, "deletions": 20}, "files": [{"sha": "8afeccb9004632b3a5522b24a4f5468ce78046ae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9401afe31a29a1b933a87eb5f11d20e950cae82d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9401afe31a29a1b933a87eb5f11d20e950cae82d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9401afe31a29a1b933a87eb5f11d20e950cae82d", "patch": "@@ -1,3 +1,16 @@\n+Sat Jun 23 01:23:59 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* flow.c (mark_set_1, attempt_auto_inc, mark_used_reg,\n+\ttry_pre_increment_1): compute REG_FREQ using bb->frequency.\n+\n+\t* regclass.c (loop_cost): Kill.\n+\t(frequency): New global variable.\n+\t(record_operand_costs): Replace loop_cost by frequency.\n+\t(scan_one_insn): Likewise.\n+\t(regclass): Likewise; set frequency according to bb->frequency.\n+\n+\t* flow.c (split_edge): Set frequency.\n+\n Sat Jun 23 01:16:42 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* predict.c (block_info_def): Add nvisited."}, {"sha": "2db6d20c000b254e350eca136ecb62a8ea2edaad", "filename": "gcc/flow.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9401afe31a29a1b933a87eb5f11d20e950cae82d/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9401afe31a29a1b933a87eb5f11d20e950cae82d/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=9401afe31a29a1b933a87eb5f11d20e950cae82d", "patch": "@@ -1627,7 +1627,8 @@ split_edge (edge_in)\n   bb->pred = edge_in;\n   bb->succ = edge_out;\n   bb->count = edge_in->count;\n-  /* ??? Set bb->frequency.  */\n+  bb->frequency = (edge_in->probability * edge_in->src->frequency\n+\t\t   / REG_BR_PROB_BASE);\n \n   edge_in->dest = bb;\n   edge_in->flags &= ~EDGE_CRITICAL;\n@@ -4857,7 +4858,8 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n \t\t     register twice if it is modified, but that is correct.  */\n \t\t  REG_N_SETS (i) += 1;\n \t\t  REG_N_REFS (i) += 1;\n-\t\t  REG_FREQ (i) += (optimize_size ? 1 : pbi->bb->loop_depth + 1);\n+\t\t  REG_FREQ (i) += (optimize_size || !pbi->bb->frequency\n+\t\t\t\t   ? 1 : pbi->bb->frequency);\n \n \t          /* The insns where a reg is live are normally counted\n \t\t     elsewhere, but we want the count to include the insn\n@@ -5524,7 +5526,8 @@ attempt_auto_inc (pbi, inc, insn, mem, incr, incr_reg)\n       /* Count an extra reference to the reg.  When a reg is\n \t incremented, spilling it is worse, so we want to make\n \t that less likely.  */\n-      REG_FREQ (regno) += (optimize_size ? 1 : pbi->bb->loop_depth + 1);\n+      REG_FREQ (regno) += (optimize_size || !phi->bb->frequency\n+\t\t           ? 1 : pbi->bb->frequency);\n \n       /* Count the increment as a setting of the register,\n \t even though it isn't a SET in rtl.  */\n@@ -5690,7 +5693,7 @@ mark_used_reg (pbi, reg, cond, insn)\n \n \t  /* Count (weighted) number of uses of each reg.  */\n \t  REG_FREQ (regno_first)\n-\t    += (optimize_size ? 1 : pbi->bb->loop_depth + 1);\n+\t    += (optimize_size || !pbi->bb->frequency ? 1 : pbi->bb->frequency);\n \t  REG_N_REFS (regno_first)++;\n \t}\n     }\n@@ -6112,7 +6115,8 @@ try_pre_increment_1 (pbi, insn)\n \t so we want to make that less likely.  */\n       if (regno >= FIRST_PSEUDO_REGISTER)\n \t{\n-\t  REG_FREQ (regno) += (optimize_size ? 1 : pbi->bb->loop_depth + 1);\n+\t  REG_FREQ (regno) += (optimize_size || !phi->bb->frequency\n+\t\t\t       ? 1 : pbi->bb->frequency);\n \t  REG_N_SETS (regno)++;\n \t}\n "}, {"sha": "0af5328effef7f5bb90796e15ba966e0e5be214e", "filename": "gcc/regclass.c", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9401afe31a29a1b933a87eb5f11d20e950cae82d/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9401afe31a29a1b933a87eb5f11d20e950cae82d/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=9401afe31a29a1b933a87eb5f11d20e950cae82d", "patch": "@@ -794,10 +794,9 @@ static struct reg_pref *reg_pref;\n \n static struct reg_pref *reg_pref_buffer;\n \n-/* Account for the fact that insns within a loop are executed very commonly,\n-   but don't keep doing this as loops go too deep.  */\n+/* Frequency of executions of current insn.  */\n \n-static int loop_cost;\n+static int frequency;\n \n static rtx scan_one_insn\tPARAMS ((rtx, int));\n static void record_operand_costs PARAMS ((rtx, struct costs *, struct reg_pref *));\n@@ -928,10 +927,10 @@ record_operand_costs (insn, op_costs, reg_pref)\n \n       if (GET_CODE (recog_data.operand[i]) == MEM)\n \trecord_address_regs (XEXP (recog_data.operand[i], 0),\n-\t\t\t     BASE_REG_CLASS, loop_cost * 2);\n+\t\t\t     BASE_REG_CLASS, frequency * 2);\n       else if (constraints[i][0] == 'p')\n \trecord_address_regs (recog_data.operand[i],\n-\t\t\t     BASE_REG_CLASS, loop_cost * 2);\n+\t\t\t     BASE_REG_CLASS, frequency * 2);\n     }\n \n   /* Check for commutative in a separate loop so everything will\n@@ -1007,9 +1006,9 @@ scan_one_insn (insn, pass)\n       costs[REGNO (SET_DEST (set))].mem_cost\n \t-= (MEMORY_MOVE_COST (GET_MODE (SET_DEST (set)),\n \t\t\t      GENERAL_REGS, 1)\n-\t    * loop_cost);\n+\t    * frequency);\n       record_address_regs (XEXP (SET_SRC (set), 0),\n-\t\t\t   BASE_REG_CLASS, loop_cost * 2);\n+\t\t\t   BASE_REG_CLASS, frequency * 2);\n       return insn;\n     }\n \n@@ -1059,17 +1058,17 @@ scan_one_insn (insn, pass)\n       /* This makes one more setting of new insns's dest.  */\n       REG_N_SETS (REGNO (recog_data.operand[0]))++;\n       REG_N_REFS (REGNO (recog_data.operand[0]))++;\n-      REG_FREQ (REGNO (recog_data.operand[0])) += loop_cost;\n+      REG_FREQ (REGNO (recog_data.operand[0])) += frequency;\n \n       *recog_data.operand_loc[1] = recog_data.operand[0];\n       REG_N_REFS (REGNO (recog_data.operand[0]))++;\n-      REG_FREQ (REGNO (recog_data.operand[0])) += loop_cost;\n+      REG_FREQ (REGNO (recog_data.operand[0])) += frequency;\n       for (i = recog_data.n_dups - 1; i >= 0; i--)\n \tif (recog_data.dup_num[i] == 1)\n \t  {\n \t    *recog_data.dup_loc[i] = recog_data.operand[0];\n \t    REG_N_REFS (REGNO (recog_data.operand[0]))++;\n-\t    REG_FREQ (REGNO (recog_data.operand[0])) += loop_cost;\n+\t    REG_FREQ (REGNO (recog_data.operand[0])) += frequency;\n \t  }\n \n       return PREV_INSN (newinsn);\n@@ -1087,9 +1086,9 @@ scan_one_insn (insn, pass)\n \tint regno = REGNO (recog_data.operand[i]);\n \tstruct costs *p = &costs[regno], *q = &op_costs[i];\n \n-\tp->mem_cost += q->mem_cost * loop_cost;\n+\tp->mem_cost += q->mem_cost * frequency;\n \tfor (j = 0; j < N_REG_CLASSES; j++)\n-\t  p->cost[j] += q->cost[j] * loop_cost;\n+\t  p->cost[j] += q->cost[j] * frequency;\n       }\n \n   return insn;\n@@ -1195,7 +1194,7 @@ regclass (f, nregs, dump)\n \n       if (!optimize)\n \t{\n-\t  loop_cost = 1;\n+\t  frequency = 1;\n \t  for (insn = f; insn; insn = NEXT_INSN (insn))\n \t    insn = scan_one_insn (insn, pass);\n \t}\n@@ -1209,9 +1208,9 @@ regclass (f, nregs, dump)\n \t       aggressive than the assumptions made elsewhere and is being\n \t       tried as an experiment.  */\n \t    if (optimize_size)\n-\t      loop_cost = 1;\n+\t      frequency = 1;\n \t    else\n-\t      loop_cost = 1 << (2 * MIN (bb->loop_depth, 5));\n+\t      frequency = bb->frequency ? bb->frequency : 1;\n \t    for (insn = bb->head; ; insn = NEXT_INSN (insn))\n \t      {\n \t\tinsn = scan_one_insn (insn, pass);"}]}