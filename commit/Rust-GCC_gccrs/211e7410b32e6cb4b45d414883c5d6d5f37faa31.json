{"sha": "211e7410b32e6cb4b45d414883c5d6d5f37faa31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjExZTc0MTBiMzJlNmNiNGI0NWQ0MTQ4ODNjNWQ2ZDVmMzdmYWEzMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T15:54:39Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T15:54:39Z"}, "message": "[multiple changes]\n\n2017-04-25  Arnaud Charlet  <charlet@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Case_Expression): Emit error message when\n\tgenerating C code on complex case expressions.\n\n2017-04-25  Arnaud Charlet  <charlet@adacore.com>\n\n\t* sem_prag.adb (Analyze_Pragma): Generate a warning instead\n\tof silently ignoring pragma Ada_xxx in Latest_Ada_Only mode.\n\t* directio.ads, ioexcept.ads, sequenio.ads, text_io.ads: Use\n\tAda_2012 instead of Ada_2005 to be compatible with the above\n\tchange.\n\t* bindgen.adb: Silence new warning on pragma Ada_95.\n\n2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* checks.adb (Generate_Range_Check): Revert part of previous change.\n\n2017-04-25  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Try_Container_Indexing): Handle properly a\n\tcontainer indexing operation that appears as a an actual in a\n\tparameter association in a procedure call.\n\n2017-04-25  Olivier Ramonat  <ramonat@adacore.com>\n\n\t* prj-proc.adb, sem_util.adb, s-stposu.adb, sem_attr.adb, prj-conf.ads:\n\tFix spelling mistakes.\n\n2017-04-25  Bob Duff  <duff@adacore.com>\n\n\t* types.ads, osint.adb, sinput-c.adb, sinput-d.adb, sinput-l.adb,\n\t* sinput-p.adb: Use regular fat pointers, with bounds checking,\n\tfor source buffers.  Fix misc obscure bugs.\n\t* sinput.ads, sinput.adb: Use regular fat pointers, with bounds\n\tchecking, for source buffers.  Modify representation clause for\n\tSource_File_Record as appropriate.  Move Source_File_Index_Table\n\tfrom spec to body, because it is not used outside the body.\n\tMove Set_Source_File_Index_Table into the private part, because\n\tit is used only in the body and in children.  Use trickery to\n\tmodify the dope in the generic instantiation case.  It's ugly,\n\tbut not as ugly as the previous method.  Fix documentation.\n\tRemove obsolete code.\n\t* fname-sf.adb, targparm.adb: Fix misc out-of-bounds\n\tindexing in source buffers.\n\t* fmap.adb: Avoid conversions from one string type to another.\n\tRemove a use of global name buffer.\n\t* osint.ads, sfn_scan.ads, sfn_scan.adb, sinput-c.ads: Comment\n\tfixes.\n\nFrom-SVN: r247252", "tree": {"sha": "55dae71c0ef21060e28548eed6b71f8e8f1b0965", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55dae71c0ef21060e28548eed6b71f8e8f1b0965"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/211e7410b32e6cb4b45d414883c5d6d5f37faa31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/211e7410b32e6cb4b45d414883c5d6d5f37faa31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/211e7410b32e6cb4b45d414883c5d6d5f37faa31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/211e7410b32e6cb4b45d414883c5d6d5f37faa31/comments", "author": null, "committer": null, "parents": [{"sha": "f66c70dc0392cfa06f6414a8b9fa65adb9051b58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f66c70dc0392cfa06f6414a8b9fa65adb9051b58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f66c70dc0392cfa06f6414a8b9fa65adb9051b58"}], "stats": {"total": 1314, "additions": 668, "deletions": 646}, "files": [{"sha": "c31446dd2c5dcb8df8c9f990b995e8feb1622284", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -1,3 +1,53 @@\n+2017-04-25  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Case_Expression): Emit error message when\n+\tgenerating C code on complex case expressions.\n+\n+2017-04-25  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Pragma): Generate a warning instead\n+\tof silently ignoring pragma Ada_xxx in Latest_Ada_Only mode.\n+\t* directio.ads, ioexcept.ads, sequenio.ads, text_io.ads: Use\n+\tAda_2012 instead of Ada_2005 to be compatible with the above\n+\tchange.\n+\t* bindgen.adb: Silence new warning on pragma Ada_95.\n+\n+2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* checks.adb (Generate_Range_Check): Revert part of previous change.\n+\n+2017-04-25  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch4.adb (Try_Container_Indexing): Handle properly a\n+\tcontainer indexing operation that appears as a an actual in a\n+\tparameter association in a procedure call.\n+\n+2017-04-25  Olivier Ramonat  <ramonat@adacore.com>\n+\n+\t* prj-proc.adb, sem_util.adb, s-stposu.adb, sem_attr.adb, prj-conf.ads:\n+\tFix spelling mistakes.\n+\n+2017-04-25  Bob Duff  <duff@adacore.com>\n+\n+\t* types.ads, osint.adb, sinput-c.adb, sinput-d.adb, sinput-l.adb,\n+\t* sinput-p.adb: Use regular fat pointers, with bounds checking,\n+\tfor source buffers.  Fix misc obscure bugs.\n+\t* sinput.ads, sinput.adb: Use regular fat pointers, with bounds\n+\tchecking, for source buffers.  Modify representation clause for\n+\tSource_File_Record as appropriate.  Move Source_File_Index_Table\n+\tfrom spec to body, because it is not used outside the body.\n+\tMove Set_Source_File_Index_Table into the private part, because\n+\tit is used only in the body and in children.  Use trickery to\n+\tmodify the dope in the generic instantiation case.  It's ugly,\n+\tbut not as ugly as the previous method.  Fix documentation.\n+\tRemove obsolete code.\n+\t* fname-sf.adb, targparm.adb: Fix misc out-of-bounds\n+\tindexing in source buffers.\n+\t* fmap.adb: Avoid conversions from one string type to another.\n+\tRemove a use of global name buffer.\n+\t* osint.ads, sfn_scan.ads, sfn_scan.adb, sinput-c.ads: Comment\n+\tfixes.\n+\n 2017-04-25  Gary Dismukes  <dismukes@adacore.com>\n \n \t* exp_util.adb, exp_ch4.adb: Minor reformatting."}, {"sha": "59b43e0c27ebbda45957a01618e4cccceafb95f7", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -2083,8 +2083,8 @@ package body Bindgen is\n       --  handle use of Ada 2005 keywords as identifiers in Ada 95 mode. None\n       --  of the Ada 2005 or Ada 2012 constructs are needed by the binder file.\n \n-      WBI (\"pragma Ada_95;\");\n       WBI (\"pragma Warnings (Off);\");\n+      WBI (\"pragma Ada_95;\");\n \n       --  If we are operating in Restrictions (No_Exception_Handlers) mode,\n       --  then we need to make sure that the binder program is compiled with\n@@ -2291,8 +2291,8 @@ package body Bindgen is\n       --  handle use of Ada 2005 keywords as identifiers in Ada 95 mode. None\n       --  of the Ada 2005/2012 constructs are needed by the binder file.\n \n-      WBI (\"pragma Ada_95;\");\n       WBI (\"pragma Warnings (Off);\");\n+      WBI (\"pragma Ada_95;\");\n \n       --  Output Source_File_Name pragmas which look like\n "}, {"sha": "2833fff87a1c6fc7e5c122d06d44b5b6d6ee89b4", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -6697,20 +6697,9 @@ package body Checks is\n          Set_Etype (N, Target_Base_Type);\n       end Convert_And_Check_Range;\n \n-      --  Local variables\n-\n-      Checks_On : constant Boolean :=\n-                    not Index_Checks_Suppressed (Target_Type)\n-                      or else\n-                    not Range_Checks_Suppressed (Target_Type);\n-\n    --  Start of processing for Generate_Range_Check\n \n    begin\n-      if not Expander_Active or not Checks_On then\n-         return;\n-      end if;\n-\n       --  First special case, if the source type is already within the range\n       --  of the target type, then no check is needed (probably we should have\n       --  stopped Do_Range_Check from being set in the first place, but better"}, {"sha": "6c0f9f50250beedc662ff11c465333fd1927ca89", "filename": "gcc/ada/directio.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fdirectio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fdirectio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdirectio.ads?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -13,10 +13,10 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-pragma Ada_2005;\n---  Explicit setting of Ada 2005 mode is required here, since we want to with a\n+pragma Ada_2012;\n+--  Explicit setting of Ada 2012 mode is required here, since we want to with a\n --  child unit (not possible in Ada 83 mode), and Direct_IO is not considered\n---  to be an internal unit that is automatically compiled in Ada 2005 mode\n+--  to be an internal unit that is automatically compiled in Ada 2012 mode\n --  (since a user is allowed to redeclare Direct_IO).\n \n with Ada.Direct_IO;"}, {"sha": "e2446e1bfe7ad844666e02970a58ced57b0a7233", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -4867,6 +4867,18 @@ package body Exp_Ch4 is\n       --    type Ptr_Typ is access all Typ;\n \n       else\n+         if Generate_C_Code then\n+\n+            --  We cannot ensure that correct C code will be generated if\n+            --  any temporary is created down the line (to e.g. handle\n+            --  checks or capture values) since we might end up with\n+            --  dangling references to local variables, so better be safe\n+            --  and reject the construct.\n+\n+            Error_Msg_N\n+              (\"case expression too complex, use case statement instead\", N);\n+         end if;\n+\n          Target_Typ := Make_Temporary (Loc, 'P');\n \n          Append_To (Acts,"}, {"sha": "d517c2a4ddc5783f93c997349647012f6a8d089c", "filename": "gcc/ada/fmap.adb", "status": "modified", "additions": 22, "deletions": 32, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Ffmap.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Ffmap.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffmap.adb?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -45,9 +45,6 @@ package body Fmap is\n    --  procedure Initialize, so that no attempt is made to open the mapping\n    --  file in procedure Update_Mapping_File.\n \n-   function To_Big_String_Ptr is new Unchecked_Conversion\n-     (Source_Buffer_Ptr, Big_String_Ptr);\n-\n    Max_Buffer : constant := 1_500;\n    Buffer : String (1 .. Max_Buffer);\n    --  Used to buffer output when writing to a new mapping file\n@@ -180,11 +177,9 @@ package body Fmap is\n    procedure Initialize (File_Name : String) is\n       Src : Source_Buffer_Ptr;\n       Hi  : Source_Ptr;\n-      BS  : Big_String_Ptr;\n-      SP  : String_Ptr;\n \n-      First : Positive := 1;\n-      Last  : Natural  := 0;\n+      First : Source_Ptr := 1;\n+      Last  : Source_Ptr := 0;\n \n       Uname : Unit_Name_Type;\n       Fname : File_Name_Type;\n@@ -204,7 +199,7 @@ package body Fmap is\n       --  the name buffer contains \"/\".\n \n       procedure Get_Line;\n-      --  Get a line from the mapping file, where a line is SP (First .. Last)\n+      --  Get a line from the mapping file, where a line is Src (First .. Last)\n \n       procedure Report_Truncated;\n       --  Report a warning when the mapping file is truncated\n@@ -263,23 +258,23 @@ package body Fmap is\n \n          --  If not at the end of file, skip the end of line\n \n-         while First < SP'Last\n-           and then (SP (First) = CR\n-                      or else SP (First) = LF\n-                      or else SP (First) = EOF)\n+         while First < Src'Last\n+           and then (Src (First) = CR\n+                      or else Src (First) = LF\n+                      or else Src (First) = EOF)\n          loop\n             First := First + 1;\n          end loop;\n \n          --  If not at the end of file, find the end of this new line\n \n-         if First < SP'Last and then SP (First) /= EOF then\n+         if First < Src'Last and then Src (First) /= EOF then\n             Last := First;\n \n-            while Last < SP'Last\n-              and then SP (Last + 1) /= CR\n-              and then SP (Last + 1) /= LF\n-              and then SP (Last + 1) /= EOF\n+            while Last < Src'Last\n+              and then Src (Last + 1) /= CR\n+              and then Src (Last + 1) /= LF\n+              and then Src (Last + 1) /= EOF\n             loop\n                Last := Last + 1;\n             end loop;\n@@ -302,9 +297,7 @@ package body Fmap is\n \n    begin\n       Empty_Tables;\n-      Name_Len := File_Name'Length;\n-      Name_Buffer (1 .. Name_Len) := File_Name;\n-      Read_Source_File (Name_Enter, 0, Hi, Src, Config);\n+      Read_Source_File (Name_Enter (File_Name), 1, Hi, Src, Config);\n \n       if Null_Source_Buffer_Ptr (Src) then\n          Write_Str (\"warning: could not read mapping file \"\"\");\n@@ -313,9 +306,6 @@ package body Fmap is\n          No_Mapping_File := True;\n \n       else\n-         BS := To_Big_String_Ptr (Src);\n-         SP := BS (1 .. Natural (Hi))'Unrestricted_Access;\n-\n          loop\n             --  Get the unit name\n \n@@ -325,19 +315,19 @@ package body Fmap is\n \n             exit when First > Last;\n \n-            if (Last < First + 2) or else (SP (Last - 1) /= '%')\n-              or else (SP (Last) /= 's' and then SP (Last) /= 'b')\n+            if (Last < First + 2) or else (Src (Last - 1) /= '%')\n+              or else (Src (Last) /= 's' and then Src (Last) /= 'b')\n             then\n                Write_Line\n                  (\"warning: mapping file \"\"\" & File_Name &\n                   \"\"\" is incorrectly formatted\");\n-               Write_Line (\"Line = \"\"\" & SP (First .. Last) & '\"');\n+               Write_Line (\"Line = \"\"\" & String (Src (First .. Last)) & '\"');\n                Empty_Tables;\n                return;\n             end if;\n \n-            Name_Len := Last - First + 1;\n-            Name_Buffer (1 .. Name_Len) := SP (First .. Last);\n+            Name_Len := Integer (Last - First + 1);\n+            Name_Buffer (1 .. Name_Len) := String (Src (First .. Last));\n             Uname := Find_Unit_Name;\n \n             --  Get the file name\n@@ -352,8 +342,8 @@ package body Fmap is\n                return;\n             end if;\n \n-            Name_Len := Last - First + 1;\n-            Name_Buffer (1 .. Name_Len) := SP (First .. Last);\n+            Name_Len := Integer (Last - First + 1);\n+            Name_Buffer (1 .. Name_Len) := String (Src (First .. Last));\n             Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n             Fname := Find_File_Name;\n \n@@ -369,8 +359,8 @@ package body Fmap is\n                return;\n             end if;\n \n-            Name_Len := Last - First + 1;\n-            Name_Buffer (1 .. Name_Len) := SP (First .. Last);\n+            Name_Len := Integer (Last - First + 1);\n+            Name_Buffer (1 .. Name_Len) := String (Src (First .. Last));\n             Pname := Find_File_Name;\n \n             --  Add the mappings for this unit name"}, {"sha": "be115bca0b717dbb964be568815a354b008988a6", "filename": "gcc/ada/fname-sf.adb", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Ffname-sf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Ffname-sf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffname-sf.adb?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -34,9 +34,6 @@ with Unchecked_Conversion;\n \n package body Fname.SF is\n \n-   function To_Big_String_Ptr is new Unchecked_Conversion\n-     (Source_Buffer_Ptr, Big_String_Ptr);\n-\n    ----------------------\n    -- Local Procedures --\n    ----------------------\n@@ -66,19 +63,19 @@ package body Fname.SF is\n    procedure Read_Source_File_Name_Pragmas is\n       Src : Source_Buffer_Ptr;\n       Hi  : Source_Ptr;\n-      BS  : Big_String_Ptr;\n-      SP  : String_Ptr;\n \n    begin\n-      Name_Buffer (1 .. 8) := \"gnat.adc\";\n-      Name_Len := 8;\n-      Read_Source_File (Name_Enter, 0, Hi, Src);\n+      Read_Source_File (Name_Enter (\"gnat.adc\"), 1, Hi, Src);\n \n       if not Null_Source_Buffer_Ptr (Src) then\n-         BS := To_Big_String_Ptr (Src);\n-         SP := BS (1 .. Natural (Hi))'Unrestricted_Access;\n+         --  We need to strip off the trailing EOF that was added by\n+         --  Read_Source_File, because there might be another EOF in\n+         --  the file, and two in a row causes Scan_SFN_Pragmas to give\n+         --  errors.\n+\n+         pragma Assert (Src (Hi) = EOF);\n          Scan_SFN_Pragmas\n-           (SP.all,\n+           (String (Src (1 .. Hi - 1)),\n             Set_File_Name'Access,\n             Set_File_Name_Pattern'Access);\n       end if;"}, {"sha": "da467290814a8bb8920e71fcec53bf0d80f8b4b4", "filename": "gcc/ada/ioexcept.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fioexcept.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fioexcept.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fioexcept.ads?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -13,11 +13,11 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-pragma Ada_2005;\n---  Explicit setting of Ada 2005 mode is required here, since we want to with a\n+pragma Ada_2012;\n+--  Explicit setting of Ada 2012 mode is required here, since we want to with a\n --  child unit (not possible in Ada 83 mode), and IO_Exceptions is not\n --  considered to be an internal unit that is automatically compiled in Ada\n---  2005 mode (since a user is allowed to redeclare IO_Exceptions).\n+--  2012 mode (since a user is allowed to redeclare IO_Exceptions).\n \n with Ada.IO_Exceptions;\n "}, {"sha": "aed853134513f6748655042318e912661ad1b6de", "filename": "gcc/ada/namet.adb", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fnamet.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fnamet.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.adb?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -809,7 +809,7 @@ package body Namet is\n    end Get_Name_String;\n \n    function Get_Name_String (Id : Name_Id) return String is\n-      Buf : Bounded_String;\n+      Buf : Bounded_String (Max_Length => Natural (Length_Of_Name (Id)));\n    begin\n       Append (Buf, Id);\n       return +Buf;\n@@ -1020,7 +1020,7 @@ package body Namet is\n    end Is_Internal_Name;\n \n    function Is_Internal_Name (Id : Name_Id) return Boolean is\n-      Buf : Bounded_String;\n+      Buf : Bounded_String (Max_Length => Natural (Length_Of_Name (Id)));\n    begin\n       if Id in Error_Name_Or_No_Name then\n          return False;\n@@ -1132,6 +1132,13 @@ package body Namet is\n       return Name_Entries.Last;\n    end Name_Enter;\n \n+   function Name_Enter (S : String) return Name_Id is\n+      Buf : Bounded_String (Max_Length => S'Length);\n+   begin\n+      Append (Buf, S);\n+      return Name_Enter (Buf);\n+   end Name_Enter;\n+\n    --------------------------\n    -- Name_Entries_Address --\n    --------------------------\n@@ -1240,7 +1247,7 @@ package body Namet is\n    end Name_Find;\n \n    function Name_Find (S : String) return Name_Id is\n-      Buf : Bounded_String;\n+      Buf : Bounded_String (Max_Length => S'Length);\n    begin\n       Append (Buf, S);\n       return Name_Find (Buf);\n@@ -1743,7 +1750,7 @@ package body Namet is\n \n       else\n          declare\n-            Buf : Bounded_String;\n+            Buf : Bounded_String (Max_Length => Natural (Length_Of_Name (Id)));\n          begin\n             Append (Buf, Id);\n             Write_Str (Buf.Chars (1 .. Buf.Length));\n@@ -1758,7 +1765,7 @@ package body Namet is\n    ----------------\n \n    procedure Write_Name (Id : Name_Id) is\n-      Buf : Bounded_String;\n+      Buf : Bounded_String (Max_Length => Natural (Length_Of_Name (Id)));\n    begin\n       if Id >= First_Name_Id then\n          Append (Buf, Id);"}, {"sha": "b2a2ed5fe8182c55d7a9094af954293b63b25b9e", "filename": "gcc/ada/namet.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fnamet.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fnamet.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.ads?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -348,6 +348,7 @@ package Namet is\n \n    function Name_Enter\n      (Buf : Bounded_String := Global_Name_Buffer) return Name_Id;\n+   function Name_Enter (S : String) return Name_Id;\n    --  Name_Enter is similar to Name_Find. The difference is that it does not\n    --  search the table for an existing match, and also subsequent Name_Find\n    --  calls using the same name will not locate the entry created by this"}, {"sha": "8e958c5f8a9b8305b377ed63378e9027399e729d", "filename": "gcc/ada/osint.adb", "status": "modified", "additions": 10, "deletions": 32, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fosint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fosint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.adb?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -2651,49 +2651,23 @@ package body Osint is\n       --  Do the actual read operation\n \n       declare\n-         subtype Actual_Source_Buffer is Source_Buffer (Lo .. Hi);\n-         --  Physical buffer allocated\n-\n-         type Actual_Source_Ptr is access Actual_Source_Buffer;\n-         --  This is the pointer type for the physical buffer allocated\n-\n-         Actual_Ptr : constant Actual_Source_Ptr := new Actual_Source_Buffer;\n-         --  And this is the actual physical buffer\n-\n-      begin\n+         Var_Ptr : constant Source_Buffer_Ptr_Var :=\n+           new Source_Buffer (Lo .. Hi);\n          --  Allocate source buffer, allowing extra character at end for EOF\n-\n+      begin\n          --  Some systems have file types that require one read per line,\n          --  so read until we get the Len bytes or until there are no more\n          --  characters.\n \n          Hi := Lo;\n          loop\n-            Actual_Len := Read (Source_File_FD, Actual_Ptr (Hi)'Address, Len);\n+            Actual_Len := Read (Source_File_FD, Var_Ptr (Hi)'Address, Len);\n             Hi := Hi + Source_Ptr (Actual_Len);\n             exit when Actual_Len = Len or else Actual_Len <= 0;\n          end loop;\n \n-         Actual_Ptr (Hi) := EOF;\n-\n-         --  Now we need to work out the proper virtual origin pointer to\n-         --  return. This is exactly Actual_Ptr (0)'Address, but we have to\n-         --  be careful to suppress checks to compute this address.\n-\n-         declare\n-            pragma Suppress (All_Checks);\n-\n-            pragma Warnings (Off);\n-            --  This use of unchecked conversion is aliasing safe\n-\n-            function To_Source_Buffer_Ptr is new\n-              Unchecked_Conversion (Address, Source_Buffer_Ptr);\n-\n-            pragma Warnings (On);\n-\n-         begin\n-            Src := To_Source_Buffer_Ptr (Actual_Ptr (0)'Address);\n-         end;\n+         Var_Ptr (Hi) := EOF;\n+         Src := Var_Ptr.all'Access;\n       end;\n \n       --  Read is complete, get time stamp and close file and we are done\n@@ -2703,6 +2677,10 @@ package body Osint is\n       --  The status should never be False. But, if it is, what can we do?\n       --  So, we don't test it.\n \n+      --  ???We don't really need to return Hi anymore; We could get rid of\n+      --  it. We could also make this into a function.\n+\n+      pragma Assert (Hi = Src'Last);\n    end Read_Source_File;\n \n    -------------------"}, {"sha": "4712b9885f86f5a08e3a15c063574cc4b10eb2de", "filename": "gcc/ada/osint.ads", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fosint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fosint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.ads?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -417,11 +417,8 @@ package Osint is\n    --  positions other than the last source character are treated as blanks).\n    --\n    --  The logical lower bound of the source buffer is the input value of Lo,\n-   --  and on exit Hi is set to the logical upper bound of the source buffer.\n-   --  Note that the returned value in Src points to an array with a physical\n-   --  lower bound of zero. This virtual origin addressing approach means that\n-   --  a constrained array pointer can be used with a low bound of zero which\n-   --  results in more efficient code.\n+   --  and on exit Hi is set to the logical upper bound of the source buffer,\n+   --  which is redundant with Src'Last.\n    --\n    --  If the given file cannot be opened, then the action depends on whether\n    --  this file is the current main unit (i.e. its name matches the name"}, {"sha": "41ef5eb858cf0d6f0a818063df4e4f6c7d6811dd", "filename": "gcc/ada/prj-conf.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fprj-conf.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fprj-conf.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-conf.ads?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---            Copyright (C) 2006-2014, Free Software Foundation, Inc.       --\n+--            Copyright (C) 2006-2017, Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -107,7 +107,7 @@ package Prj.Conf is\n    --  in another directory.\n    --\n    --  If specified, On_New_Tree_Loaded is called after each aggregated project\n-   --  has been processed succesfully.\n+   --  has been processed successfully.\n \n    procedure Process_Project_And_Apply_Config\n      (Main_Project               : out Prj.Project_Id;"}, {"sha": "ec52c2340e22e97f249a06c70bbdbfef3abcc138", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -185,7 +185,7 @@ package body Prj.Proc is\n    --  encapsulated library dependencies.\n    --\n    --  If specified, On_New_Tree_Loaded is called after each aggregated project\n-   --  has been processed succesfully.\n+   --  has been processed successfully.\n \n    function Get_Attribute_Index\n      (Tree  : Project_Node_Tree_Ref;"}, {"sha": "abf2013e48dec7e800dd1556a8333550d7246afd", "filename": "gcc/ada/s-stposu.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fs-stposu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fs-stposu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stposu.adb?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2011-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2011-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -44,7 +44,7 @@ use  System.Storage_Pools.Subpools.Finalization;\n package body System.Storage_Pools.Subpools is\n \n    Finalize_Address_Table_In_Use : Boolean := False;\n-   --  This flag should be set only when a successfull allocation on a subpool\n+   --  This flag should be set only when a successful allocation on a subpool\n    --  has been performed and the associated Finalize_Address has been added to\n    --  the hash table in System.Finalization_Masters.\n "}, {"sha": "cc082e802c5330bb91cbb6e26906cb99d1ae64a6", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -4317,7 +4317,7 @@ package body Sem_Attr is\n       begin\n          Attr := N;\n \n-         --  Set the type of the attribute now to ensure the successfull\n+         --  Set the type of the attribute now to ensure the successful\n          --  continuation of analysis even if the attribute is misplaced.\n \n          Set_Etype (Attr, P_Type);"}, {"sha": "709bb34440c4328bb47c3f319915030a83fe3a34", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 66, "deletions": 41, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -7521,6 +7521,15 @@ package body Sem_Ch4 is\n    is\n       Pref_Typ : constant Entity_Id := Etype (Prefix);\n \n+      function Expr_Matches_In_Formal\n+        (Subp : Entity_Id;\n+         Par  : Node_Id) return Boolean;\n+      --  Find formal corresponding to given indexed component that is an\n+      --  actual in a call. Note that the enclosing subprogram call has not\n+      --  beenanalyzed yet, and the parameter list is not normalized, so\n+      --  that if the argument is a parameter association we must match it\n+      --  by name and not by position.\n+\n       function Constant_Indexing_OK return Boolean;\n       --  Constant_Indexing is legal if there is no Variable_Indexing defined\n       --  for the type, or else node not a target of assignment, or an actual\n@@ -7535,6 +7544,56 @@ package body Sem_Ch4 is\n       --  interpretations. Flag Is_Constant should be set when the context is\n       --  constant indexing.\n \n+      -----------------------------\n+      -- Expr_Matches_In_Formal  --\n+      -----------------------------\n+\n+      function Expr_Matches_In_Formal\n+        (Subp : Entity_Id;\n+         Par  : Node_Id) return Boolean\n+      is\n+         Actual : Node_Id;\n+         Formal : Node_Id;\n+\n+      begin\n+         Formal := First_Formal (Subp);\n+         Actual := First  (Parameter_Associations ((Parent (Par))));\n+\n+         if Nkind (Par) /= N_Parameter_Association then\n+\n+            --  Match by position.\n+\n+            while Present (Actual) and then Present (Formal) loop\n+               exit when Actual = Par;\n+               Next (Actual);\n+\n+               if Present (Formal) then\n+                  Next_Formal (Formal);\n+\n+               --  Otherwise this is a parameter mismatch, the error is\n+               --  reported elsewhere, or else variable indexing is implied.\n+\n+               else\n+                  return False;\n+               end if;\n+            end loop;\n+\n+         else\n+            --  Match by name\n+\n+            while Present (Formal) loop\n+               exit when Chars (Formal) = Chars (Selector_Name (Par));\n+               Next_Formal (Formal);\n+\n+               if No (Formal) then\n+                  return False;\n+               end if;\n+            end loop;\n+         end if;\n+\n+         return Present (Formal) and then Ekind (Formal) = E_In_Parameter;\n+      end Expr_Matches_In_Formal;\n+\n       --------------------------\n       -- Constant_Indexing_OK --\n       --------------------------\n@@ -7566,8 +7625,6 @@ package body Sem_Ch4 is\n               and then Is_Entity_Name (Name (Parent (Par)))\n             then\n                declare\n-                  Actual : Node_Id;\n-                  Formal : Entity_Id;\n                   Proc   : Entity_Id;\n \n                begin\n@@ -7582,34 +7639,22 @@ package body Sem_Ch4 is\n                   if Is_Overloaded (Name (Parent (Par))) then\n                      declare\n                         Proc : constant Node_Id := Name (Parent (Par));\n-                        A    : Node_Id;\n-                        F    : Entity_Id;\n                         I    : Interp_Index;\n                         It   : Interp;\n \n                      begin\n                         Get_First_Interp (Proc, I, It);\n                         while Present (It.Nam) loop\n-                           F := First_Formal (It.Nam);\n-                           A := First (Parameter_Associations (Parent (Par)));\n-\n-                           while Present (F) and then Present (A) loop\n-                              if A = Par then\n-                                 if Ekind (F) /= E_In_Parameter then\n-                                    return False;\n-                                 else\n-                                    exit;  --  interpretation is safe\n-                                 end if;\n-                              end if;\n-\n-                              Next_Formal (F);\n-                              Next_Actual (A);\n-                           end loop;\n+                           if not Expr_Matches_In_Formal (It.Nam, Par) then\n+                              return False;\n+                           end if;\n \n                            Get_Next_Interp (I, It);\n                         end loop;\n                      end;\n \n+                     --  All interpretations have a matching in-formal.\n+\n                      return True;\n \n                   else\n@@ -7623,27 +7668,7 @@ package body Sem_Ch4 is\n                      end if;\n                   end if;\n \n-                  Formal := First_Formal (Proc);\n-                  Actual := First_Actual (Parent (Par));\n-\n-                  --  Find corresponding actual\n-\n-                  while Present (Actual) loop\n-                     exit when Actual = Par;\n-                     Next_Actual (Actual);\n-\n-                     if Present (Formal) then\n-                        Next_Formal (Formal);\n-\n-                     --  Otherwise this is a parameter mismatch, the error is\n-                     --  reported elsewhere.\n-\n-                     else\n-                        return False;\n-                     end if;\n-                  end loop;\n-\n-                  return Ekind (Formal) = E_In_Parameter;\n+                  return Expr_Matches_In_Formal (Proc, Par);\n                end;\n \n             elsif Nkind (Parent (Par)) = N_Object_Renaming_Declaration then"}, {"sha": "c9c18e0038c145a06352c6c748614ef50c736a80", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -11486,7 +11486,9 @@ package body Sem_Prag is\n \n             --  Now set Ada 83 mode\n \n-            if not Latest_Ada_Only then\n+            if Latest_Ada_Only then\n+               Error_Pragma (\"??pragma% ignored\");\n+            else\n                Ada_Version          := Ada_83;\n                Ada_Version_Explicit := Ada_83;\n                Ada_Version_Pragma   := N;\n@@ -11520,7 +11522,9 @@ package body Sem_Prag is\n \n             --  Now set Ada 95 mode\n \n-            if not Latest_Ada_Only then\n+            if Latest_Ada_Only then\n+               Error_Pragma (\"??pragma% ignored\");\n+            else\n                Ada_Version          := Ada_95;\n                Ada_Version_Explicit := Ada_95;\n                Ada_Version_Pragma   := N;\n@@ -11582,7 +11586,9 @@ package body Sem_Prag is\n \n                --  Now set appropriate Ada mode\n \n-               if not Latest_Ada_Only then\n+               if Latest_Ada_Only then\n+                  Error_Pragma (\"??pragma% ignored\");\n+               else\n                   Ada_Version          := Ada_2005;\n                   Ada_Version_Explicit := Ada_2005;\n                   Ada_Version_Pragma   := N;"}, {"sha": "f78ade285dad75df0901d513c226837b3e950884", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -21377,7 +21377,7 @@ package body Sem_Util is\n    procedure Transfer_Entities (From : Entity_Id; To : Entity_Id) is\n       procedure Set_Public_Status_Of (Id : Entity_Id);\n       --  Set the Is_Public attribute of arbitrary entity Id by calling routine\n-      --  Set_Public_Status. If successfull and Id denotes a record type, set\n+      --  Set_Public_Status. If successful and Id denotes a record type, set\n       --  the Is_Public attribute of its fields.\n \n       --------------------------"}, {"sha": "ad1d7fa18f537ae4d95599181e25648499b5566b", "filename": "gcc/ada/sequenio.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fsequenio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fsequenio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsequenio.ads?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -13,11 +13,11 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-pragma Ada_2005;\n---  Explicit setting of Ada 2005 mode is required here, since we want to with a\n+pragma Ada_2012;\n+--  Explicit setting of Ada 2012 mode is required here, since we want to with a\n --  child unit (not possible in Ada 83 mode), and Sequential_IO is not\n --  considered to be an internal unit that is automatically compiled in Ada\n---  2005 mode (since a user is allowed to redeclare Sequential_IO).\n+--  2012 mode (since a user is allowed to redeclare Sequential_IO).\n \n with Ada.Sequential_IO;\n "}, {"sha": "23dc31551cee7652e9b1aaf4769da0e610a48b07", "filename": "gcc/ada/sfn_scan.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fsfn_scan.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fsfn_scan.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsfn_scan.adb?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2000-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2000-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -102,7 +102,7 @@ package body SFN_Scan is\n    --  immediately following is non-alphabetic, non-numeric. If so,\n    --  P is stepped past the token, and True is returned. If not,\n    --  P is unchanged (except for possibly skipping past whitespace),\n-   --  and False is returned. S may contain only lower-case letters\n+   --  and False is returned. T may contain only lower-case letters\n    --  ('a' .. 'z').\n \n    procedure Error (Err : String);"}, {"sha": "9e85994f2708ca10460e3e5e31b24802559c0693", "filename": "gcc/ada/sfn_scan.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fsfn_scan.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fsfn_scan.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsfn_scan.ads?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2000-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2000-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -78,7 +78,7 @@ package SFN_Scan is\n       SFN_Ptr  : Set_File_Name_Ptr;\n       SFNP_Ptr : Set_File_Name_Pattern_Ptr);\n    --  This is the procedure called to scan a gnat.adc file. The Source\n-   --  parameter points to the full text of the file, with normal line end\n+   --  parameter contains the full text of the file, with normal line end\n    --  characters, in the format normally read by the compiler. The two\n    --  parameters SFN_Ptr and SFNP_Ptr point to procedures that will be\n    --  called to register Source_File_Name pragmas as they are found.\n@@ -91,6 +91,6 @@ package SFN_Scan is\n    --  that includes only pragmas and comments. It does not do a full\n    --  syntax correctness scan by any means, but if it does find anything\n    --  that it can tell is wrong it will immediately raise the exception\n-   --  to indicate the approximate location of the error\n+   --  to indicate the approximate location of the error.\n \n end SFN_Scan;"}, {"sha": "fe9285c873e265722005425f310d32ceff9f739a", "filename": "gcc/ada/sinput-c.adb", "status": "modified", "additions": 19, "deletions": 34, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fsinput-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fsinput-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput-c.adb?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -23,7 +23,9 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Debug;  use Debug;\n with Opt;    use Opt;\n+with Output; use Output;\n with System; use System;\n \n with Ada.Unchecked_Conversion;\n@@ -65,6 +67,14 @@ package body Sinput.C is\n       Source_File.Increment_Last;\n       X := Source_File.Last;\n \n+      if Debug_Flag_L then\n+         Write_Str (\"Sinput.C.Load_File: created source \");\n+         Write_Int (Int (X));\n+         Write_Str (\" for \");\n+         Write_Str (Path);\n+         Write_Line (\"\");\n+      end if;\n+\n       if X = Source_File.First then\n          Lo := First_Source_Ptr;\n       else\n@@ -100,50 +110,24 @@ package body Sinput.C is\n       --  Do the actual read operation\n \n       declare\n-         subtype Actual_Source_Buffer is Source_Buffer (Lo .. Hi);\n-         --  Physical buffer allocated\n-\n-         type Actual_Source_Ptr is access Actual_Source_Buffer;\n-         --  This is the pointer type for the physical buffer allocated\n-\n-         Actual_Ptr : constant Actual_Source_Ptr := new Actual_Source_Buffer;\n-         --  And this is the actual physical buffer\n-\n-      begin\n+         Var_Ptr : constant Source_Buffer_Ptr_Var :=\n+           new Source_Buffer (Lo .. Hi);\n          --  Allocate source buffer, allowing extra character at end for EOF\n \n+      begin\n          --  Some systems have file types that require one read per line,\n          --  so read until we get the Len bytes or until there are no more\n          --  characters.\n \n          Hi := Lo;\n          loop\n-            Actual_Len := Read (Source_File_FD, Actual_Ptr (Hi)'Address, Len);\n+            Actual_Len := Read (Source_File_FD, Var_Ptr (Hi)'Address, Len);\n             Hi := Hi + Source_Ptr (Actual_Len);\n             exit when Actual_Len = Len or else Actual_Len <= 0;\n          end loop;\n \n-         Actual_Ptr (Hi) := EOF;\n-\n-         --  Now we need to work out the proper virtual origin pointer to\n-         --  return. This is exactly Actual_Ptr (0)'Address, but we have to\n-         --  be careful to suppress checks to compute this address.\n-\n-         declare\n-            pragma Suppress (All_Checks);\n-\n-            pragma Warnings (Off);\n-            --  The following unchecked conversion is aliased safe, since it\n-            --  is not used to create improperly aliased pointer values.\n-\n-            function To_Source_Buffer_Ptr is new\n-              Ada.Unchecked_Conversion (Address, Source_Buffer_Ptr);\n-\n-            pragma Warnings (On);\n-\n-         begin\n-            Src := To_Source_Buffer_Ptr (Actual_Ptr (0)'Address);\n-         end;\n+         Var_Ptr (Hi) := EOF;\n+         Src := Var_Ptr.all'Access;\n       end;\n \n       --  Read is complete, close the file and we are done (no need to test\n@@ -199,7 +183,8 @@ package body Sinput.C is\n                Source_Text         => Src,\n                Template            => No_Source_File,\n                Unit                => No_Unit,\n-               Time_Stamp          => Empty_Time_Stamp);\n+               Time_Stamp          => Empty_Time_Stamp,\n+               Index               => X);\n \n          Alloc_Line_Tables (S, Opt.Table_Factor * Alloc.Lines_Initial);\n          S.Lines_Table (1) := Lo;"}, {"sha": "432abe277f4177b41a08ca7c26daee1e571327e2", "filename": "gcc/ada/sinput-c.ads", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fsinput-c.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fsinput-c.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput-c.ads?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -25,8 +25,9 @@\n \n --  This child package contains a procedure to load files\n \n---  It is used by Sinput.P to load project files, and by GPrep to load\n---  preprocessor definition files and input files.\n+--  It is used by Sinput.P to load project files, by GPrep to load preprocessor\n+--  definition files and input files, and by ALI.Util to compute checksums for\n+--  source files.\n \n package Sinput.C is\n "}, {"sha": "c9c128b8bbfdfa0199ba21fc4bfdd277b1f55101", "filename": "gcc/ada/sinput-d.adb", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fsinput-d.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fsinput-d.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput-d.adb?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2002-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2002-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -23,8 +23,10 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Debug;   use Debug;\n with Osint;   use Osint;\n with Osint.C; use Osint.C;\n+with Output;  use Output;\n \n package body Sinput.D is\n \n@@ -36,11 +38,8 @@ package body Sinput.D is\n    ------------------------\n \n    procedure Close_Debug_Source is\n-      S    : Source_File_Record renames Source_File.Table (Dfile);\n+      SFR  : Source_File_Record renames Source_File.Table (Dfile);\n       Src  : Source_Buffer_Ptr;\n-\n-      pragma Warnings (Off, S);\n-\n    begin\n       Trim_Lines_Table (Dfile);\n       Close_Debug_File;\n@@ -49,8 +48,10 @@ package body Sinput.D is\n       --  subsequent access.\n \n       Read_Source_File\n-        (S.Full_Debug_Name, S.Source_First, S.Source_Last, Src);\n-      S.Source_Text := Src;\n+        (SFR.Full_Debug_Name, SFR.Source_First, SFR.Source_Last, Src);\n+      SFR.Source_Text := Src;\n+      pragma Assert (SFR.Source_Text'First = SFR.Source_First);\n+      pragma Assert (SFR.Source_Text'Last = SFR.Source_Last);\n    end Close_Debug_Source;\n \n    -------------------------\n@@ -72,8 +73,10 @@ package body Sinput.D is\n          S : Source_File_Record renames Source_File.Table (Dfile);\n \n       begin\n+         S.Index             := Dfile;\n          S.Full_Debug_Name   := Create_Debug_File (S.File_Name);\n          S.Debug_Source_Name := Strip_Directory (S.Full_Debug_Name);\n+         S.Source_Text       := null;\n          S.Source_First      := Loc;\n          S.Source_Last       := Loc;\n          S.Lines_Table       := null;\n@@ -85,6 +88,14 @@ package body Sinput.D is\n          Alloc_Line_Tables\n            (S, Int (Source_File.Table (Source).Last_Source_Line * 3));\n          S.Lines_Table (1) := Loc;\n+\n+         if Debug_Flag_L then\n+            Write_Str (\"Sinput.D.Create_Debug_Source: created source \");\n+            Write_Int (Int (Dfile));\n+            Write_Str (\" for \");\n+            Write_Str (Get_Name_String (S.Full_Debug_Name));\n+            Write_Line (\"\");\n+         end if;\n       end;\n    end Create_Debug_Source;\n "}, {"sha": "a64283ec42ecbfa4293e8a5af2e9de4efbbb04e0", "filename": "gcc/ada/sinput-l.adb", "status": "modified", "additions": 47, "deletions": 69, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fsinput-l.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fsinput-l.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput-l.adb?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -142,13 +142,20 @@ package body Sinput.L is\n       Source_File.Append (Source_File.Table (Xold));\n       Xnew := Source_File.Last;\n \n+      if Debug_Flag_L then\n+         Write_Str (\"Create_Instantiation_Source: created source \");\n+         Write_Int (Int (Xnew));\n+         Write_Line (\"\");\n+      end if;\n+\n       declare\n          Sold : Source_File_Record renames Source_File.Table (Xold);\n          Snew : Source_File_Record renames Source_File.Table (Xnew);\n \n          Inst_Spec : Node_Id;\n \n       begin\n+         Snew.Index            := Xnew;\n          Snew.Inlined_Body     := Inlined_Body;\n          Snew.Inherited_Pragma := Inherited_Pragma;\n          Snew.Template         := Xold;\n@@ -213,8 +220,8 @@ package body Sinput.L is\n          end if;\n \n          --  Now compute the new values of Source_First and Source_Last and\n-         --  adjust the source file pointer to have the correct virtual origin\n-         --  for the new range of values.\n+         --  adjust the source file pointer to have the correct bounds for the\n+         --  new range of values.\n \n          --  Source_First must be greater than the last Source_Last value and\n          --  also must be a multiple of Source_Align.\n@@ -229,6 +236,19 @@ package body Sinput.L is\n \n          Snew.Sloc_Adjust := Sold.Sloc_Adjust - Factor.Adjust;\n \n+         --  Modify the Dope of the instance Source_Text to use the\n+         --  above-computed bounds.\n+\n+         declare\n+            Dope : constant Dope_Ptr :=\n+              new Dope_Rec'(Snew.Source_First, Snew.Source_Last);\n+         begin\n+            Snew.Source_Text := Sold.Source_Text;\n+            Set_Dope (Snew.Source_Text'Address, Dope);\n+            pragma Assert (Snew.Source_Text'First = Snew.Source_First);\n+            pragma Assert (Snew.Source_Text'Last = Snew.Source_Last);\n+         end;\n+\n          if Debug_Flag_L then\n             Write_Eol;\n             Write_Str (\"*** Create instantiation source for \");\n@@ -307,31 +327,6 @@ package body Sinput.L is\n             Write_Location (Sloc (Inst_Node));\n             Write_Eol;\n          end if;\n-\n-         --  For a given character in the source, a higher subscript will be\n-         --  used to access the instantiation, which means that the virtual\n-         --  origin must have a corresponding lower value. We compute this new\n-         --  origin by taking the address of the appropriate adjusted element\n-         --  in the old array. Since this adjusted element will be at a\n-         --  negative subscript, we must suppress checks.\n-\n-         declare\n-            pragma Suppress (All_Checks);\n-\n-            pragma Warnings (Off);\n-            --  This unchecked conversion is aliasing safe, since it is never\n-            --  used to create improperly aliased pointer values.\n-\n-            function To_Source_Buffer_Ptr is new\n-              Unchecked_Conversion (Address, Source_Buffer_Ptr);\n-\n-            pragma Warnings (On);\n-\n-         begin\n-            Snew.Source_Text :=\n-              To_Source_Buffer_Ptr\n-                (Sold.Source_Text (-Factor.Adjust)'Address);\n-         end;\n       end;\n    end Create_Instantiation_Source;\n \n@@ -405,6 +400,14 @@ package body Sinput.L is\n       Source_File.Increment_Last;\n       X := Source_File.Last;\n \n+      if Debug_Flag_L then\n+         Write_Str (\"Sinput.L.Load_File: created source \");\n+         Write_Int (Int (X));\n+         Write_Str (\" for \");\n+         Write_Str (Get_Name_String (N));\n+         Write_Line (\"\");\n+      end if;\n+\n       --  Compute starting index, respecting alignment requirement\n \n       if X = Source_File.First then\n@@ -529,7 +532,8 @@ package body Sinput.L is\n                   Source_Text         => Src,\n                   Template            => No_Source_File,\n                   Unit                => No_Unit,\n-                  Time_Stamp          => Osint.Current_Source_File_Stamp);\n+                  Time_Stamp          => Osint.Current_Source_File_Stamp,\n+                  Index               => X);\n \n             Alloc_Line_Tables (S, Opt.Table_Factor * Alloc.Lines_Initial);\n             S.Lines_Table (1) := Lo;\n@@ -688,54 +692,28 @@ package body Sinput.L is\n                   --  Create the new source buffer\n \n                   declare\n-                     subtype Actual_Source_Buffer is Source_Buffer (Lo .. Hi);\n-                     --  Physical buffer allocated\n-\n-                     type Actual_Source_Ptr is access Actual_Source_Buffer;\n-                     --  Pointer type for the physical buffer allocated\n-\n-                     Actual_Ptr : constant Actual_Source_Ptr :=\n-                                    new Actual_Source_Buffer;\n-                     --  Actual physical buffer\n+                     Var_Ptr : constant Source_Buffer_Ptr_Var :=\n+                       new Source_Buffer (Lo .. Hi);\n+                     --  Allocate source buffer, allowing extra character at\n+                     --  end for EOF.\n \n                   begin\n-                     Actual_Ptr (Lo .. Hi - 1) :=\n+                     Var_Ptr (Lo .. Hi - 1) :=\n                        Prep_Buffer (1 .. Prep_Buffer_Last);\n-                     Actual_Ptr (Hi) := EOF;\n-\n-                     --  Now we need to work out the proper virtual origin\n-                     --  pointer to return. This is Actual_Ptr (0)'Address, but\n-                     --  we have to be careful to suppress checks to compute\n-                     --  this address.\n-\n-                     declare\n-                        pragma Suppress (All_Checks);\n-\n-                        pragma Warnings (Off);\n-                        --  This unchecked conversion is aliasing safe, since\n-                        --  it is never used to create improperly aliased\n-                        --  pointer values.\n-\n-                        function To_Source_Buffer_Ptr is new\n-                          Unchecked_Conversion (Address, Source_Buffer_Ptr);\n-\n-                        pragma Warnings (On);\n-\n-                     begin\n-                        Src := To_Source_Buffer_Ptr (Actual_Ptr (0)'Address);\n+                     Var_Ptr (Hi) := EOF;\n+                     Src := Var_Ptr.all'Access;\n+                  end;\n \n-                        --  Record in the table the new source buffer and the\n-                        --  new value of Hi.\n+                  --  Record in the table the new source buffer and the\n+                  --  new value of Hi.\n \n-                        Source_File.Table (X).Source_Text := Src;\n-                        Source_File.Table (X).Source_Last := Hi;\n+                  Source_File.Table (X).Source_Text := Src;\n+                  Source_File.Table (X).Source_Last := Hi;\n \n-                        --  Reset Last_Line to 1, because the lines do not\n-                        --  have necessarily the same starts and lengths.\n+                  --  Reset Last_Line to 1, because the lines do not\n+                  --  have necessarily the same starts and lengths.\n \n-                        Source_File.Table (X).Last_Source_Line := 1;\n-                     end;\n-                  end;\n+                  Source_File.Table (X).Last_Source_Line := 1;\n                end if;\n             end;\n          end if;"}, {"sha": "d643d6466ec65c76d79107539aa908c7a3d395f7", "filename": "gcc/ada/sinput-p.adb", "status": "modified", "additions": 12, "deletions": 35, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fsinput-p.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fsinput-p.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput-p.adb?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -23,14 +23,12 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Unchecked_Conversion;\n-with Ada.Unchecked_Deallocation;\n+with Unchecked_Conversion;\n+with Unchecked_Deallocation;\n \n with Prj.Err;\n with Sinput.C;\n \n-with System;\n-\n package body Sinput.P is\n \n    First : Boolean := True;\n@@ -39,50 +37,29 @@ package body Sinput.P is\n    --  The flag is reset to False at the first call to Load_Project_File.\n    --  Calling Reset_First sets it back to True.\n \n-   procedure Free is new Ada.Unchecked_Deallocation\n+   procedure Free is new Unchecked_Deallocation\n      (Lines_Table_Type, Lines_Table_Ptr);\n \n-   procedure Free is new Ada.Unchecked_Deallocation\n+   procedure Free is new Unchecked_Deallocation\n      (Logical_Lines_Table_Type, Logical_Lines_Table_Ptr);\n \n    -----------------------------\n    -- Clear_Source_File_Table --\n    -----------------------------\n \n    procedure Clear_Source_File_Table is\n-      use System;\n-\n    begin\n       for X in 1 .. Source_File.Last loop\n          declare\n             S  : Source_File_Record renames Source_File.Table (X);\n-            Lo : constant Source_Ptr := S.Source_First;\n-            Hi : constant Source_Ptr := S.Source_Last;\n-            subtype Actual_Source_Buffer is Source_Buffer (Lo .. Hi);\n-            --  Physical buffer allocated\n-\n-            type Actual_Source_Ptr is access Actual_Source_Buffer;\n-            --  This is the pointer type for the physical buffer allocated\n-\n-            procedure Free is new Ada.Unchecked_Deallocation\n-              (Actual_Source_Buffer, Actual_Source_Ptr);\n-\n-            pragma Suppress (All_Checks);\n-\n-            pragma Warnings (Off);\n-            --  The following unchecked conversion is aliased safe, since it\n-            --  is not used to create improperly aliased pointer values.\n-\n-            function To_Actual_Source_Ptr is new\n-              Ada.Unchecked_Conversion (Address, Actual_Source_Ptr);\n-\n-            pragma Warnings (On);\n-\n-            Actual_Ptr : Actual_Source_Ptr :=\n-                           To_Actual_Source_Ptr (S.Source_Text (Lo)'Address);\n-\n          begin\n-            Free (Actual_Ptr);\n+            if S.Instance = No_Instance_Id then\n+               Free_Source_Buffer (S.Source_Text);\n+            else\n+               Free_Dope (S.Source_Text'Address);\n+               S.Source_Text := null;\n+            end if;\n+\n             Free (S.Lines_Table);\n             Free (S.Logical_Lines_Table);\n          end;"}, {"sha": "3cb9a0e415830ee5c7f84013dae9892e87c38e34", "filename": "gcc/ada/sinput.adb", "status": "modified", "additions": 163, "deletions": 134, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fsinput.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fsinput.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput.adb?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -42,7 +42,7 @@ with Widechar; use Widechar;\n \n with GNAT.Byte_Order_Mark; use GNAT.Byte_Order_Mark;\n \n-with System;         use System;\n+with System.Storage_Elements;\n with System.Memory;\n with System.WCh_Con; use System.WCh_Con;\n \n@@ -51,11 +51,7 @@ with Unchecked_Deallocation;\n \n package body Sinput is\n \n-   use ASCII;\n-   --  Make control characters visible\n-\n-   First_Time_Around : Boolean := True;\n-   --  This needs a comment ???\n+   use ASCII, System;\n \n    --  Routines to support conversion between types Lines_Table_Ptr,\n    --  Logical_Lines_Table_Ptr and System.Address.\n@@ -78,6 +74,24 @@ package body Sinput is\n \n    pragma Warnings (On);\n \n+   -----------------------------\n+   -- Source_File_Index_Table --\n+   -----------------------------\n+\n+   --  The Get_Source_File_Index function is called very frequently. Earlier\n+   --  versions cached a single entry, but then reverted to a serial search,\n+   --  and this proved to be a significant source of inefficiency. We then\n+   --  switched to using a table with a start point followed by a serial\n+   --  search. Now we make sure source buffers are on a reasonable boundary\n+   --  (see Types.Source_Align), and we can just use a direct look up in the\n+   --  following table.\n+\n+   --  Note that this array is pretty large, but in most operating systems\n+   --  it will not be allocated in physical memory unless it is actually used.\n+\n+   Source_File_Index_Table :\n+     array (Int range 0 .. 1 + (Int'Last / Source_Align)) of Source_File_Index;\n+\n    ---------------------------\n    -- Add_Line_Tables_Entry --\n    ---------------------------\n@@ -328,6 +342,26 @@ package body Sinput is\n       return SIE.Inlined_Body;\n    end Comes_From_Inlined_Body;\n \n+   ------------------------\n+   -- Free_Source_Buffer --\n+   ------------------------\n+\n+   procedure Free_Source_Buffer (Src : in out Source_Buffer_Ptr) is\n+      --  Unchecked_Deallocation doesn't work for access-to-constant; we need\n+      --  to first Unchecked_Convert to access-to-variable.\n+\n+      function To_Source_Buffer_Ptr_Var is new\n+        Unchecked_Conversion (Source_Buffer_Ptr, Source_Buffer_Ptr_Var);\n+\n+      Temp : Source_Buffer_Ptr_Var := To_Source_Buffer_Ptr_Var (Src);\n+\n+      procedure Free_Ptr is new\n+        Unchecked_Deallocation (Source_Buffer, Source_Buffer_Ptr_Var);\n+   begin\n+      Free_Ptr (Temp);\n+      Src := null;\n+   end Free_Source_Buffer;\n+\n    -----------------------\n    -- Get_Column_Number --\n    -----------------------\n@@ -472,8 +506,51 @@ package body Sinput is\n    ---------------------------\n \n    function Get_Source_File_Index (S : Source_Ptr) return Source_File_Index is\n+      Result : Source_File_Index;\n+\n+      procedure Assertions;\n+      --  Assert various properties of the result\n+\n+      procedure Assertions is\n+         --  ???The old version using zero-origin array indexing without array\n+         --  bounds checks returned 1 (i.e. system.ads) for these special\n+         --  locations, presumably by accident. We are mimicing that here.\n+         Special : constant Boolean :=\n+           S = No_Location or else S = Standard_Location\n+           or else S = Standard_ASCII_Location or else S = System_Location;\n+         pragma Assert ((S > No_Location) xor Special);\n+\n+         pragma Assert (Result in Source_File.First .. Source_File.Last);\n+\n+         SFR : Source_File_Record renames Source_File.Table (Result);\n+      begin\n+         --  SFR.Source_Text = null if and only if this is the SFR for a debug\n+         --  output file (*.dg), and that file is under construction.\n+\n+         if not Null_Source_Buffer_Ptr (SFR.Source_Text) then\n+            pragma Assert (SFR.Source_Text'First = SFR.Source_First);\n+            pragma Assert (SFR.Source_Text'Last = SFR.Source_Last);\n+            null;\n+         end if;\n+\n+         if not Special then\n+            pragma Assert (S in SFR.Source_First .. SFR.Source_Last);\n+            null;\n+         end if;\n+      end Assertions;\n+\n+   --  Start of processing for Get_Source_File_Index\n+\n    begin\n-      return Source_File_Index_Table (Int (S) / Source_Align);\n+      if S > No_Location then\n+         Result := Source_File_Index_Table (Int (S) / Source_Align);\n+      else\n+         Result := 1;\n+      end if;\n+\n+      pragma Debug (Assertions);\n+\n+      return Result;\n    end Get_Source_File_Index;\n \n    ----------------\n@@ -482,11 +559,8 @@ package body Sinput is\n \n    procedure Initialize is\n    begin\n-      Source_gnat_adc    := No_Source_File;\n-      First_Time_Around  := True;\n-\n+      Source_gnat_adc := No_Source_File;\n       Source_File.Init;\n-\n       Instances.Init;\n       Instances.Append (No_Location);\n       pragma Assert (Instances.Last = No_Instance_Id);\n@@ -791,6 +865,33 @@ package body Sinput is\n       end;\n    end Skip_Line_Terminators;\n \n+   --------------\n+   -- Set_Dope --\n+   --------------\n+\n+   procedure Set_Dope\n+     (Src : System.Address; New_Dope : Dope_Ptr)\n+   is\n+      --  A fat pointer is a pair consisting of data pointer and dope pointer,\n+      --  in that order. So we want to overwrite the second word.\n+      Dope : Address;\n+      pragma Import (Ada, Dope);\n+      use System.Storage_Elements;\n+      for Dope'Address use Src + System.Address'Size / 8;\n+   begin\n+      Dope := New_Dope.all'Address;\n+   end Set_Dope;\n+\n+   procedure Free_Dope (Src : System.Address) is\n+      Dope : Dope_Ptr;\n+      pragma Import (Ada, Dope);\n+      use System.Storage_Elements;\n+      for Dope'Address use Src + System.Address'Size / 8;\n+      procedure Free is new Unchecked_Deallocation (Dope_Rec, Dope_Ptr);\n+   begin\n+      Free (Dope);\n+   end Free_Dope;\n+\n    ----------------\n    -- Sloc_Range --\n    ----------------\n@@ -871,60 +972,29 @@ package body Sinput is\n    begin\n       --  First we must free any old source buffer pointers\n \n-      if not First_Time_Around then\n-         for J in Source_File.First .. Source_File.Last loop\n-            declare\n-               S : Source_File_Record renames Source_File.Table (J);\n-\n-               type Source_Buffer_Ptr_Var is access all Big_Source_Buffer;\n-\n-               procedure Free_Ptr is new Unchecked_Deallocation\n-                 (Big_Source_Buffer, Source_Buffer_Ptr_Var);\n-               --  This works only because we're calling malloc, which keeps\n-               --  track of the size on its own, ignoring the size of\n-               --  Big_Source_Buffer, which is the wrong size.\n-\n-               pragma Warnings (Off);\n-               --  This unchecked conversion is aliasing safe, since it is not\n-               --  used to create improperly aliased pointer values.\n-\n-               function To_Source_Buffer_Ptr_Var is new\n-                 Unchecked_Conversion (Address, Source_Buffer_Ptr_Var);\n-\n-               pragma Warnings (On);\n-\n-               Tmp1 : Source_Buffer_Ptr_Var;\n+      for J in Source_File.First .. Source_File.Last loop\n+         declare\n+            S : Source_File_Record renames Source_File.Table (J);\n+         begin\n+            if S.Instance = No_Instance_Id then\n+               Free_Source_Buffer (S.Source_Text);\n \n-            begin\n-               if S.Instance /= No_Instance_Id then\n-                  null;\n+               if S.Lines_Table /= null then\n+                  Memory.Free (To_Address (S.Lines_Table));\n+                  S.Lines_Table := null;\n+               end if;\n \n-               else\n-                  --  Free the buffer, we use Free here, because we used malloc\n-                  --  or realloc directly to allocate the tables. That is\n-                  --  because we were playing the big array trick.\n-\n-                  --  We have to recreate a proper pointer to the actual array\n-                  --  from the zero origin pointer stored in the source table.\n-\n-                  Tmp1 :=\n-                    To_Source_Buffer_Ptr_Var\n-                      (S.Source_Text (S.Source_First)'Address);\n-                  Free_Ptr (Tmp1);\n-\n-                  if S.Lines_Table /= null then\n-                     Memory.Free (To_Address (S.Lines_Table));\n-                     S.Lines_Table := null;\n-                  end if;\n-\n-                  if S.Logical_Lines_Table /= null then\n-                     Memory.Free (To_Address (S.Logical_Lines_Table));\n-                     S.Logical_Lines_Table := null;\n-                  end if;\n+               if S.Logical_Lines_Table /= null then\n+                  Memory.Free (To_Address (S.Logical_Lines_Table));\n+                  S.Logical_Lines_Table := null;\n                end if;\n-            end;\n-         end loop;\n-      end if;\n+\n+            else\n+               Free_Dope (S.Source_Text'Address);\n+               S.Source_Text := null;\n+            end if;\n+         end;\n+      end loop;\n \n       --  Read in source file table and instance table\n \n@@ -938,56 +1008,10 @@ package body Sinput is\n       for J in Source_File.First .. Source_File.Last loop\n          declare\n             S : Source_File_Record renames Source_File.Table (J);\n-\n          begin\n-            --  For the instantiation case, we do not read in any data. Instead\n-            --  we share the data for the generic template entry. Since the\n-            --  template always occurs first, we can safely refer to its data.\n-\n-            if S.Instance /= No_Instance_Id then\n-               declare\n-                  ST : Source_File_Record renames\n-                         Source_File.Table (S.Template);\n-\n-               begin\n-                  --  The lines tables are copied from the template entry\n-\n-                  S.Lines_Table :=\n-                    Source_File.Table (S.Template).Lines_Table;\n-                  S.Logical_Lines_Table :=\n-                    Source_File.Table (S.Template).Logical_Lines_Table;\n-\n-                  --  In the case of the source table pointer, we share the\n-                  --  same data as the generic template, but the virtual origin\n-                  --  is adjusted. For example, if the first subscript of the\n-                  --  template is 100, and that of the instantiation is 200,\n-                  --  then the instantiation pointer is obtained by subtracting\n-                  --  100 from the template pointer.\n-\n-                  declare\n-                     pragma Suppress (All_Checks);\n-\n-                     pragma Warnings (Off);\n-                     --  This unchecked conversion is aliasing safe since it\n-                     --  not used to create improperly aliased pointer values.\n-\n-                     function To_Source_Buffer_Ptr is new\n-                       Unchecked_Conversion (Address, Source_Buffer_Ptr);\n-\n-                     pragma Warnings (On);\n-\n-                  begin\n-                     S.Source_Text :=\n-                       To_Source_Buffer_Ptr\n-                          (ST.Source_Text\n-                            (ST.Source_First - S.Source_First)'Address);\n-                  end;\n-               end;\n-\n             --  Normal case (non-instantiation)\n \n-            else\n-               First_Time_Around := False;\n+            if S.Instance = No_Instance_Id then\n                S.Lines_Table := null;\n                S.Logical_Lines_Table := null;\n                Alloc_Line_Tables (S, Int (S.Last_Source_Line));\n@@ -1002,33 +1026,42 @@ package body Sinput is\n                   end loop;\n                end if;\n \n-               --  Allocate source buffer and read in the data and then set the\n-               --  virtual origin to point to the logical zero'th element. This\n-               --  address must be computed with subscript checks turned off.\n+               --  Allocate source buffer and read in the data\n \n                declare\n-                  subtype B is Text_Buffer (S.Source_First .. S.Source_Last);\n-                  type Text_Buffer_Ptr is access B;\n-                  T : Text_Buffer_Ptr;\n-\n-                  pragma Suppress (All_Checks);\n-\n-                  pragma Warnings (Off);\n-                  --  This unchecked conversion is aliasing safe, since it is\n-                  --  never used to create improperly aliased pointer values.\n+                  T : constant Source_Buffer_Ptr_Var :=\n+                    new Source_Buffer (S.Source_First .. S.Source_Last);\n+               begin\n+                  Tree_Read_Data (T (S.Source_First)'Address,\n+                     Int (S.Source_Last) - Int (S.Source_First) + 1);\n+                  S.Source_Text := T.all'Access;\n+               end;\n \n-                  function To_Source_Buffer_Ptr is new\n-                    Unchecked_Conversion (Address, Source_Buffer_Ptr);\n+            --  For the instantiation case, we do not read in any data. Instead\n+            --  we share the data for the generic template entry. Since the\n+            --  template always occurs first, we can safely refer to its data.\n \n-                  pragma Warnings (On);\n+            else\n+               declare\n+                  ST : Source_File_Record renames\n+                         Source_File.Table (S.Template);\n \n                begin\n-                  T := new B;\n+                  --  The lines tables are copied from the template entry\n \n-                  Tree_Read_Data (T (S.Source_First)'Address,\n-                     Int (S.Source_Last) - Int (S.Source_First) + 1);\n+                  S.Lines_Table := ST.Lines_Table;\n+                  S.Logical_Lines_Table := ST.Logical_Lines_Table;\n+\n+                  --  The Source_Text of the instance is the same data as that\n+                  --  of the template, but with different bounds.\n \n-                  S.Source_Text := To_Source_Buffer_Ptr (T (0)'Address);\n+                  declare\n+                     Dope : constant Dope_Ptr :=\n+                       new Dope_Rec'(S.Source_First, S.Source_Last);\n+                  begin\n+                     S.Source_Text := ST.Source_Text;\n+                     Set_Dope (S.Source_Text'Address, Dope);\n+                  end;\n                end;\n             end if;\n          end;\n@@ -1058,13 +1091,9 @@ package body Sinput is\n             --  For instantiations, there is nothing to do, since the data is\n             --  shared with the generic template. When the tree is read, the\n             --  pointers must be set, but no extra data needs to be written.\n+            --  For the normal case, write out the data of the tables.\n \n-            if S.Instance /= No_Instance_Id then\n-               null;\n-\n-            --  For the normal case, write out the data of the tables\n-\n-            else\n+            if S.Instance = No_Instance_Id then\n                --  Lines table\n \n                for J in 1 .. S.Last_Source_Line loop"}, {"sha": "7162d0fd747a761b6589362421162aa2cc156c00", "filename": "gcc/ada/sinput.ads", "status": "modified", "additions": 64, "deletions": 57, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fsinput.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Fsinput.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput.ads?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -63,6 +63,7 @@\n with Alloc;\n with Casing; use Casing;\n with Namet;  use Namet;\n+with System;\n with Table;\n with Types;  use Types;\n \n@@ -219,19 +220,17 @@ package Sinput is\n    --    pragmas are used, then the value is set to No_Line_Number.\n \n    --  Source_Text : Source_Buffer_Ptr (read-only)\n-   --    Text of source file. Note that every source file has a distinct set\n-   --    of non-overlapping logical bounds, so it is possible to determine\n-   --    which file is referenced from a given subscript (Source_Ptr) value.\n+   --    Text of source file. Every source file has a distinct set of\n+   --    nonoverlapping bounds, so it is possible to determine which\n+   --    file is referenced from a given subscript (Source_Ptr) value.\n \n    --  Source_First : Source_Ptr; (read-only)\n-   --    Subscript of first character in Source_Text. Note that this cannot\n-   --    be obtained as Source_Text'First, because we use virtual origin\n-   --    addressing.\n+   --    This is always equal to Source_Text'First, except during\n+   --    construction of a debug output file (*.dg), when Source_Text = null,\n+   --    and Source_First is the size so far. Likewise for Last.\n \n    --  Source_Last : Source_Ptr; (read-only)\n-   --    Subscript of last character in Source_Text. Note that this cannot\n-   --    be obtained as Source_Text'Last, because we use virtual origin\n-   --    addressing, so this value is always Source_Ptr'Last.\n+   --    Same idea as Source_Last, but for Last\n \n    --  Time_Stamp : Time_Stamp_Type; (read-only)\n    --    Time stamp of the source file\n@@ -341,29 +340,6 @@ package Sinput is\n    Main_Source_File : Source_File_Index := No_Source_File;\n    --  This is set to the source file index of the main unit\n \n-   -----------------------------\n-   -- Source_File_Index_Table --\n-   -----------------------------\n-\n-   --  The Get_Source_File_Index function is called very frequently. Earlier\n-   --  versions cached a single entry, but then reverted to a serial search,\n-   --  and this proved to be a significant source of inefficiency. We then\n-   --  switched to using a table with a start point followed by a serial\n-   --  search. Now we make sure source buffers are on a reasonable boundary\n-   --  (see Types.Source_Align), and we can just use a direct look up in the\n-   --  following table.\n-\n-   --  Note that this array is pretty large, but in most operating systems\n-   --  it will not be allocated in physical memory unless it is actually used.\n-\n-   Source_File_Index_Table :\n-     array (Int range 0 .. 1 + (Int'Last / Source_Align)) of Source_File_Index;\n-\n-   procedure Set_Source_File_Index_Table (Xnew : Source_File_Index);\n-   --  Sets entries in the Source_File_Index_Table for the newly created\n-   --  Source_File table entry whose index is Xnew. The Source_First and\n-   --  Source_Last fields of this entry must be set before the call.\n-\n    -----------------------\n    -- Checksum Handling --\n    -----------------------\n@@ -396,13 +372,13 @@ package Sinput is\n    --  is also possible to find the location of the instantiation.\n \n    --  This is achieved as follows. When an instantiation occurs, a new entry\n-   --  is made in the source file table. This entry points to the same source\n-   --  text, i.e. the file that contains the instantiation, but has a distinct\n-   --  set of Source_Ptr index values. The separate range of Sloc values avoids\n+   --  is made in the source file table. The Source_Text of the instantiation\n+   --  points to the same Source_Buffer as the Source_Text of the template, but\n+   --  with different bounds. The separate range of Sloc values avoids\n    --  confusion, and means that the Sloc values can still be used to uniquely\n-   --  identify the source file table entry. It is possible for both entries\n-   --  to point to the same text, because of the virtual origin pointers used\n-   --  in the source table.\n+   --  identify the source file table entry. See Set_Dope below for the\n+   --  low-level trickery that allows two different pointers to point at the\n+   --  same array, but with different bounds.\n \n    --  The Instantiation_Id field of this source file index entry, set\n    --  to No_Instance_Id for normal entries, instead contains a value that\n@@ -858,6 +834,7 @@ private\n       --  Max_Source_Line gives the maximum used value, this gives the\n       --  maximum allocated value.\n \n+      Index : Source_File_Index := 123456789; -- for debugging\n    end record;\n \n    --  The following representation clause ensures that the above record\n@@ -892,36 +869,38 @@ private\n       Identifier_Casing   at 78 range 0 .. 15;\n       Sloc_Adjust         at 80 range 0 .. 31;\n       Lines_Table_Max     at 84 range 0 .. 31;\n+      Index               at 92 range 0 .. 31;\n \n       --  The following fields are pointers, so we have to specialize their\n       --  lengths using pointer size, obtained above as Standard'Address_Size.\n+      --  Note that Source_Text is a fat pointer, so it has size = AS*2.\n \n-      Source_Text         at 92 range 0      .. AS - 1;\n-      Lines_Table         at 92 range AS     .. AS * 2 - 1;\n-      Logical_Lines_Table at 92 range AS * 2 .. AS * 3 - 1;\n-   end record;\n+      Source_Text         at 96 range 0      .. AS * 2 - 1;\n+      Lines_Table         at 96 range AS * 2 .. AS * 3 - 1;\n+      Logical_Lines_Table at 96 range AS * 3 .. AS * 4 - 1;\n+   end record; -- Source_File_Record\n \n-   for Source_File_Record'Size use 92 * 8 + AS * 3;\n+   for Source_File_Record'Size use 96 * 8 + AS * 4;\n    --  This ensures that we did not leave out any fields\n \n-   package Source_File is new Table.Table (\n-     Table_Component_Type => Source_File_Record,\n-     Table_Index_Type     => Source_File_Index,\n-     Table_Low_Bound      => 1,\n-     Table_Initial        => Alloc.Source_File_Initial,\n-     Table_Increment      => Alloc.Source_File_Increment,\n-     Table_Name           => \"Source_File\");\n+   package Source_File is new Table.Table\n+     (Table_Component_Type => Source_File_Record,\n+      Table_Index_Type     => Source_File_Index,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => Alloc.Source_File_Initial,\n+      Table_Increment      => Alloc.Source_File_Increment,\n+      Table_Name           => \"Source_File\");\n \n    --  Auxiliary table containing source location of instantiations. Index 0\n    --  is used for code that does not come from an instance.\n \n-   package Instances is new Table.Table (\n-     Table_Component_Type => Source_Ptr,\n-     Table_Index_Type     => Instance_Id,\n-     Table_Low_Bound      => 0,\n-     Table_Initial        => Alloc.Source_File_Initial,\n-     Table_Increment      => Alloc.Source_File_Increment,\n-     Table_Name           => \"Instances\");\n+   package Instances is new Table.Table\n+     (Table_Component_Type => Source_Ptr,\n+      Table_Index_Type     => Instance_Id,\n+      Table_Low_Bound      => 0,\n+      Table_Initial        => Alloc.Source_File_Initial,\n+      Table_Increment      => Alloc.Source_File_Increment,\n+      Table_Name           => \"Instances\");\n \n    -----------------\n    -- Subprograms --\n@@ -948,4 +927,32 @@ private\n    --  correspond to the current value of Num_Source_Lines, releasing\n    --  any unused storage. This is used by Sinput.L and Sinput.D.\n \n+   procedure Set_Source_File_Index_Table (Xnew : Source_File_Index);\n+   --  Sets entries in the Source_File_Index_Table for the newly created\n+   --  Source_File table entry whose index is Xnew. The Source_First and\n+   --  Source_Last fields of this entry must be set before the call.\n+   --  See package body for details.\n+\n+   type Dope_Rec is record\n+      First, Last : Source_Ptr'Base;\n+   end record;\n+   Dope_Rec_Size : constant := 2 * Source_Ptr'Size;\n+   for Dope_Rec'Size use Dope_Rec_Size;\n+   for Dope_Rec'Alignment use Dope_Rec_Size / 8;\n+   type Dope_Ptr is access all Dope_Rec;\n+\n+   procedure Set_Dope\n+     (Src : System.Address; New_Dope : Dope_Ptr);\n+   --  Src is the address of a variable of type Source_Buffer_Ptr, which is a\n+   --  fat pointer. This sets the dope part of the fat pointer to point to the\n+   --  specified New_Dope. This low-level processing is used to make the\n+   --  Source_Text of an instance point to the same text as the template, but\n+   --  with different bounds.\n+\n+   procedure Free_Dope (Src : System.Address);\n+   --  Calls Unchecked_Deallocation on the dope part of the fat pointer Src\n+\n+   procedure Free_Source_Buffer (Src : in out Source_Buffer_Ptr);\n+   --  Deallocates the source buffer\n+\n end Sinput;"}, {"sha": "7eba1365c3ea4ab86205ec209c87ffc2653d3c3b", "filename": "gcc/ada/targparm.adb", "status": "modified", "additions": 108, "deletions": 118, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Ftargparm.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Ftargparm.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftargparm.adb?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -106,34 +106,34 @@ package body Targparm is\n \n    type Buffer_Ptr is access constant Source_Buffer;\n    Targparm_Str : constant array (Targparm_Tags) of Buffer_Ptr :=\n-     (AAM_Str'Access,\n-      ACR_Str'Access,\n-      ASD_Str'Access,\n-      BDC_Str'Access,\n-      BOC_Str'Access,\n-      CLA_Str'Access,\n-      CRT_Str'Access,\n-      D32_Str'Access,\n-      DEN_Str'Access,\n-      EXS_Str'Access,\n-      FEL_Str'Access,\n-      FEX_Str'Access,\n-      FFO_Str'Access,\n-      MOV_Str'Access,\n-      MRN_Str'Access,\n-      PAS_Str'Access,\n-      SAG_Str'Access,\n-      SAP_Str'Access,\n-      SCA_Str'Access,\n-      SCC_Str'Access,\n-      SCD_Str'Access,\n-      SCL_Str'Access,\n-      SCP_Str'Access,\n-      SLS_Str'Access,\n-      SNZ_Str'Access,\n-      SSL_Str'Access,\n-      UAM_Str'Access,\n-      ZCX_Str'Access);\n+     (AAM => AAM_Str'Access,\n+      ACR => ACR_Str'Access,\n+      ASD => ASD_Str'Access,\n+      BDC => BDC_Str'Access,\n+      BOC => BOC_Str'Access,\n+      CLA => CLA_Str'Access,\n+      CRT => CRT_Str'Access,\n+      D32 => D32_Str'Access,\n+      DEN => DEN_Str'Access,\n+      EXS => EXS_Str'Access,\n+      FEL => FEL_Str'Access,\n+      FEX => FEX_Str'Access,\n+      FFO => FFO_Str'Access,\n+      MOV => MOV_Str'Access,\n+      MRN => MRN_Str'Access,\n+      PAS => PAS_Str'Access,\n+      SAG => SAG_Str'Access,\n+      SAP => SAP_Str'Access,\n+      SCA => SCA_Str'Access,\n+      SCC => SCC_Str'Access,\n+      SCD => SCD_Str'Access,\n+      SCL => SCL_Str'Access,\n+      SCP => SCP_Str'Access,\n+      SLS => SLS_Str'Access,\n+      SNZ => SNZ_Str'Access,\n+      SSL => SSL_Str'Access,\n+      UAM => UAM_Str'Access,\n+      ZCX => ZCX_Str'Access);\n \n    -----------------------\n    -- Local Subprograms --\n@@ -146,7 +146,7 @@ package body Targparm is\n    -- Get_Target_Parameters --\n    ---------------------------\n \n-   --  Version which reads in system.ads\n+   --  Version that reads in system.ads\n \n    procedure Get_Target_Parameters\n      (Make_Id : Make_Id_Type := null;\n@@ -200,6 +200,9 @@ package body Targparm is\n       Set_NUA      : Set_NUA_Type := null;\n       Set_NUP      : Set_NUP_Type := null)\n    is\n+      pragma Assert (System_Text'First = Source_First);\n+      pragma Assert (System_Text'Last = Source_Last);\n+\n       P : Source_Ptr;\n       --  Scans source buffer containing source of system.ads\n \n@@ -220,6 +223,13 @@ package body Targparm is\n       --  with Name_Len being length, folded to lower case. On return, P points\n       --  just past the last character (which should be a right paren).\n \n+      function Looking_At (S : Source_Buffer) return Boolean;\n+      --  True if P points to the same text as S in System_Text\n+\n+      function Looking_At_Skip (S : Source_Buffer) return Boolean;\n+      --  True if P points to the same text as S in System_Text,\n+      --  and if True, moves P forward to skip S as a side effect.\n+\n       ------------------\n       -- Collect_Name --\n       ------------------\n@@ -249,15 +259,39 @@ package body Targparm is\n          end loop;\n       end Collect_Name;\n \n+      ----------------\n+      -- Looking_At --\n+      ----------------\n+\n+      function Looking_At (S : Source_Buffer) return Boolean is\n+         Last : constant Source_Ptr := P + S'Length - 1;\n+      begin\n+         return Last <= System_Text'Last\n+           and then System_Text (P .. Last) = S;\n+      end Looking_At;\n+\n+      ---------------------\n+      -- Looking_At_Skip --\n+      ---------------------\n+\n+      function Looking_At_Skip (S : Source_Buffer) return Boolean is\n+         Result : constant Boolean := Looking_At (S);\n+      begin\n+         if Result then\n+            P := P + S'Length;\n+         end if;\n+\n+         return Result;\n+      end Looking_At_Skip;\n+\n    --  Start of processing for Get_Target_Parameters\n \n    begin\n       if Parameters_Obtained then\n          return;\n-      else\n-         Parameters_Obtained := True;\n       end if;\n \n+      Parameters_Obtained := True;\n       Opt.Address_Is_Private := False;\n \n       --  Loop through source lines\n@@ -271,71 +305,59 @@ package body Targparm is\n       --  For a special exception, see processing for pragma Pure below\n \n       P := Source_First;\n-      Line_Loop : while System_Text (P .. P + 10) /= \"end System;\" loop\n \n-         --  Skip comments quickly\n+      while not Looking_At (\"end System;\") loop\n+         --  Skip comments\n \n-         if System_Text (P) = '-' then\n+         if Looking_At (\"-\") then\n             goto Line_Loop_Continue;\n \n          --  Test for type Address is private\n \n-         elsif System_Text (P .. P + 26) = \"   type Address is private;\" then\n+         elsif Looking_At_Skip (\"   type Address is private;\") then\n             Opt.Address_Is_Private := True;\n-            P := P + 26;\n             goto Line_Loop_Continue;\n \n          --  Test for pragma Profile (Ravenscar);\n \n-         elsif System_Text (P .. P + 26) =\n-                 \"pragma Profile (Ravenscar);\"\n-         then\n+         elsif Looking_At_Skip (\"pragma Profile (Ravenscar);\") then\n             Set_Profile_Restrictions (Ravenscar);\n             Opt.Task_Dispatching_Policy := 'F';\n             Opt.Locking_Policy          := 'C';\n-            P := P + 27;\n             goto Line_Loop_Continue;\n \n          --  Test for pragma Profile (GNAT_Extended_Ravenscar);\n \n-         elsif System_Text (P .. P + 40) =\n-                 \"pragma Profile (GNAT_Extended_Ravenscar);\"\n+         elsif Looking_At_Skip\n+           (\"pragma Profile (GNAT_Extended_Ravenscar);\")\n          then\n             Set_Profile_Restrictions (GNAT_Extended_Ravenscar);\n             Opt.Task_Dispatching_Policy := 'F';\n             Opt.Locking_Policy          := 'C';\n-            P := P + 41;\n             goto Line_Loop_Continue;\n \n          --  Test for pragma Profile (GNAT_Ravenscar_EDF);\n \n-         elsif System_Text (P .. P + 35) =\n-                 \"pragma Profile (GNAT_Ravenscar_EDF);\"\n-         then\n+         elsif Looking_At_Skip (\"pragma Profile (GNAT_Ravenscar_EDF);\") then\n             Set_Profile_Restrictions (GNAT_Ravenscar_EDF);\n             Opt.Task_Dispatching_Policy := 'E';\n             Opt.Locking_Policy          := 'C';\n-            P := P + 36;\n             goto Line_Loop_Continue;\n \n          --  Test for pragma Profile (Restricted);\n \n-         elsif System_Text (P .. P + 27) =\n-                 \"pragma Profile (Restricted);\"\n-         then\n+         elsif Looking_At_Skip (\"pragma Profile (Restricted);\") then\n             Set_Profile_Restrictions (Restricted);\n-            P := P + 28;\n             goto Line_Loop_Continue;\n \n          --  Test for pragma Restrictions\n \n-         elsif System_Text (P .. P + 20) = \"pragma Restrictions (\" then\n-            P := P + 21;\n+         elsif Looking_At_Skip (\"pragma Restrictions (\") then\n             PR_Start := P - 1;\n \n             --  Boolean restrictions\n \n-            Rloop : for K in All_Boolean_Restrictions loop\n+            for K in All_Boolean_Restrictions loop\n                declare\n                   Rname : constant String := Restriction_Id'Image (K);\n \n@@ -354,9 +376,8 @@ package body Targparm is\n                   end if;\n                end;\n \n-            <<Rloop_Continue>>\n-               null;\n-            end loop Rloop;\n+               <<Rloop_Continue>> null;\n+            end loop;\n \n             --  Restrictions taking integer parameter\n \n@@ -423,15 +444,12 @@ package body Targparm is\n                   end if;\n                end;\n \n-            <<Ploop_Continue>>\n-               null;\n+               <<Ploop_Continue>> null;\n             end loop Ploop;\n \n             --  No_Dependence case\n \n-            if System_Text (P .. P + 16) = \"No_Dependence => \" then\n-               P := P + 17;\n-\n+            if Looking_At_Skip (\"No_Dependence => \") then\n                --  Skip this processing (and simply ignore No_Dependence lines)\n                --  if caller did not supply the three subprograms we need to\n                --  process these lines.\n@@ -481,10 +499,7 @@ package body Targparm is\n \n             --  No_Specification_Of_Aspect case\n \n-            elsif System_Text (P .. P + 29) = \"No_Specification_Of_Aspect => \"\n-            then\n-               P := P + 30;\n-\n+            elsif Looking_At_Skip (\"No_Specification_Of_Aspect => \") then\n                --  Skip this processing (and simply ignore the pragma), if\n                --  caller did not supply the subprogram we need to process\n                --  such lines.\n@@ -513,9 +528,7 @@ package body Targparm is\n \n             --  No_Use_Of_Attribute case\n \n-            elsif System_Text (P .. P + 22) = \"No_Use_Of_Attribute => \" then\n-               P := P + 23;\n-\n+            elsif Looking_At_Skip (\"No_Use_Of_Attribute => \") then\n                --  Skip this processing (and simply ignore No_Use_Of_Attribute\n                --  lines) if caller did not supply the subprogram we need to\n                --  process such lines.\n@@ -544,9 +557,7 @@ package body Targparm is\n \n             --  No_Use_Of_Pragma case\n \n-            elsif System_Text (P .. P + 19) = \"No_Use_Of_Pragma => \" then\n-               P := P + 20;\n-\n+            elsif Looking_At_Skip (\"No_Use_Of_Pragma => \") then\n                --  Skip this processing (and simply ignore No_Use_Of_Pragma\n                --  lines) if caller did not supply the subprogram we need to\n                --  process such lines.\n@@ -597,89 +608,72 @@ package body Targparm is\n \n          --  Test for pragma Detect_Blocking;\n \n-         elsif System_Text (P .. P + 22) = \"pragma Detect_Blocking;\" then\n-            P := P + 23;\n+         elsif Looking_At_Skip (\"pragma Detect_Blocking;\") then\n             Opt.Detect_Blocking := True;\n             goto Line_Loop_Continue;\n \n          --  Discard_Names\n \n-         elsif System_Text (P .. P + 20) = \"pragma Discard_Names;\" then\n-            P := P + 21;\n+         elsif Looking_At_Skip (\"pragma Discard_Names;\") then\n             Opt.Global_Discard_Names := True;\n             goto Line_Loop_Continue;\n \n          --  Locking Policy\n \n-         elsif System_Text (P .. P + 22) = \"pragma Locking_Policy (\" then\n-            P := P + 23;\n+         elsif Looking_At_Skip (\"pragma Locking_Policy (\") then\n             Opt.Locking_Policy := System_Text (P);\n             Opt.Locking_Policy_Sloc := System_Location;\n             goto Line_Loop_Continue;\n \n          --  Normalize_Scalars\n \n-         elsif System_Text (P .. P + 24) = \"pragma Normalize_Scalars;\" then\n-            P := P + 25;\n+         elsif Looking_At_Skip (\"pragma Normalize_Scalars;\") then\n             Opt.Normalize_Scalars := True;\n             Opt.Init_Or_Norm_Scalars := True;\n             goto Line_Loop_Continue;\n \n          --  Partition_Elaboration_Policy\n \n-         elsif System_Text (P .. P + 36) =\n-                 \"pragma Partition_Elaboration_Policy (\"\n-         then\n-            P := P + 37;\n+         elsif Looking_At_Skip (\"pragma Partition_Elaboration_Policy (\") then\n             Opt.Partition_Elaboration_Policy := System_Text (P);\n             Opt.Partition_Elaboration_Policy_Sloc := System_Location;\n             goto Line_Loop_Continue;\n \n          --  Polling (On)\n \n-         elsif System_Text (P .. P + 19) = \"pragma Polling (On);\" then\n-            P := P + 20;\n+         elsif Looking_At_Skip (\"pragma Polling (On);\") then\n             Opt.Polling_Required := True;\n             goto Line_Loop_Continue;\n \n          --  Queuing Policy\n \n-         elsif System_Text (P .. P + 22) = \"pragma Queuing_Policy (\" then\n-            P := P + 23;\n+         elsif Looking_At_Skip (\"pragma Queuing_Policy (\") then\n             Opt.Queuing_Policy := System_Text (P);\n             Opt.Queuing_Policy_Sloc := System_Location;\n             goto Line_Loop_Continue;\n \n          --  Suppress_Exception_Locations\n \n-         elsif System_Text (P .. P + 35) =\n-                                   \"pragma Suppress_Exception_Locations;\"\n-         then\n-            P := P + 36;\n+         elsif Looking_At_Skip (\"pragma Suppress_Exception_Locations;\") then\n             Opt.Exception_Locations_Suppressed := True;\n             goto Line_Loop_Continue;\n \n          --  Task_Dispatching Policy\n \n-         elsif System_Text (P .. P + 31) =\n-                                   \"pragma Task_Dispatching_Policy (\"\n-         then\n-            P := P + 32;\n+         elsif Looking_At_Skip (\"pragma Task_Dispatching_Policy (\") then\n             Opt.Task_Dispatching_Policy := System_Text (P);\n             Opt.Task_Dispatching_Policy_Sloc := System_Location;\n             goto Line_Loop_Continue;\n \n          --  No other configuration pragmas are permitted\n \n-         elsif System_Text (P .. P + 6) = \"pragma \" then\n-\n+         elsif Looking_At (\"pragma \") then\n             --  Special exception, we allow pragma Pure (System) appearing in\n             --  column one. This is an obsolete usage which may show up in old\n             --  tests with an obsolete version of system.ads, so we recognize\n             --  and ignore it to make life easier in handling such tests.\n \n-            if System_Text (P .. P + 20) = \"pragma Pure (System);\" then\n-               P := P + 21;\n+            if Looking_At_Skip (\"pragma Pure (System);\") then\n                goto Line_Loop_Continue;\n             end if;\n \n@@ -699,11 +693,9 @@ package body Targparm is\n \n          --  See if we have a Run_Time_Name\n \n-         elsif System_Text (P .. P + 38) =\n-                  \"   Run_Time_Name : constant String := \"\"\"\n+         elsif Looking_At_Skip\n+           (\"   Run_Time_Name : constant String := \"\"\")\n          then\n-            P := P + 39;\n-\n             Name_Len := 0;\n             while System_Text (P) in 'A' .. 'Z'\n                     or else\n@@ -739,11 +731,9 @@ package body Targparm is\n \n          --  See if we have an Executable_Extension\n \n-         elsif System_Text (P .. P + 45) =\n-                  \"   Executable_Extension : constant String := \"\"\"\n+         elsif Looking_At_Skip\n+           (\"   Executable_Extension : constant String := \"\"\")\n          then\n-            P := P + 46;\n-\n             Name_Len := 0;\n             while System_Text (P) /= '\"'\n               and then System_Text (P) /= ASCII.LF\n@@ -769,11 +759,7 @@ package body Targparm is\n \n          else\n             Config_Param_Loop : for K in Targparm_Tags loop\n-               if System_Text (P + 3 .. P + 2 + Targparm_Str (K)'Length) =\n-                                                      Targparm_Str (K).all\n-               then\n-                  P := P + 3 + Targparm_Str (K)'Length;\n-\n+               if Looking_At_Skip (\"   \" & Targparm_Str (K).all) then\n                   if Targparm_Flags (K) then\n                      Set_Standard_Error;\n                      Write_Line\n@@ -851,14 +837,18 @@ package body Targparm is\n \n          <<Line_Loop_Continue>>\n \n-         while System_Text (P) /= CR and then System_Text (P) /= LF loop\n+         while P < Source_Last\n+           and then System_Text (P) /= CR\n+           and then System_Text (P) /= LF\n+         loop\n             P := P + 1;\n-            exit when P >= Source_Last;\n          end loop;\n \n-         while System_Text (P) = CR or else System_Text (P) = LF loop\n+         while P < Source_Last\n+           and then (System_Text (P) = CR\n+                       or else System_Text (P) = LF)\n+         loop\n             P := P + 1;\n-            exit when P >= Source_Last;\n          end loop;\n \n          if P >= Source_Last then\n@@ -868,7 +858,7 @@ package body Targparm is\n             Set_Standard_Output;\n             raise Unrecoverable_Error;\n          end if;\n-      end loop Line_Loop;\n+      end loop;\n \n       if Fatal then\n          raise Unrecoverable_Error;"}, {"sha": "4c67d8dd36f23022afebba29f95cd5da8fbaa090", "filename": "gcc/ada/text_io.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Ftext_io.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Ftext_io.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftext_io.ads?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -13,10 +13,10 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-pragma Ada_2005;\n---  Explicit setting of Ada 2005 mode is required here, since we want to with a\n+pragma Ada_2012;\n+--  Explicit setting of Ada 2012 mode is required here, since we want to with a\n --  child unit (not possible in Ada 83 mode), and Text_IO is not considered to\n---  be an internal unit that is automatically compiled in Ada 2005 mode (since\n+--  be an internal unit that is automatically compiled in Ada 2012 mode (since\n --  a user is allowed to redeclare Text_IO).\n \n with Ada.Text_IO;"}, {"sha": "e0809f27037242c9ebf9b4358c1cdf13d50ff556", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/211e7410b32e6cb4b45d414883c5d6d5f37faa31/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=211e7410b32e6cb4b45d414883c5d6d5f37faa31", "patch": "@@ -196,34 +196,26 @@ package Types is\n    --  which are one greater than the previous upper bound, rounded up to\n    --  a multiple of Source_Align.\n \n-   subtype Big_Source_Buffer is Text_Buffer (0 .. Text_Ptr'Last);\n-   --  This is a virtual type used as the designated type of the access type\n-   --  Source_Buffer_Ptr, see Osint.Read_Source_File for details.\n-\n-   type Source_Buffer_Ptr is access constant Big_Source_Buffer;\n-   --  Pointer to source buffer. We use virtual origin addressing for source\n-   --  buffers, with thin pointers. The pointer points to a virtual instance\n-   --  of type Big_Source_Buffer, where the actual type is in fact of type\n-   --  Source_Buffer. The address is adjusted so that the virtual origin\n-   --  addressing works correctly. See Osint.Read_Source_Buffer for further\n-   --  details. Again, as for Big_String_Ptr, we should never allocate using\n-   --  this type, but we don't give a storage size clause of zero, since we\n-   --  may end up doing deallocations of instances allocated manually.\n+   type Source_Buffer_Ptr_Var is access all Source_Buffer;\n+   type Source_Buffer_Ptr is access constant Source_Buffer;\n+   --  Pointer to source buffer. Source_Buffer_Ptr_Var is used for allocation\n+   --  and deallocation; Source_Buffer_Ptr is used for all other uses of source\n+   --  buffers.\n \n    function Null_Source_Buffer_Ptr (X : Source_Buffer_Ptr) return Boolean;\n-   --  True if X = null. ???This usage of \"=\" is wrong, because the zero-origin\n-   --  pointer could happen to be equal to null. We need to eliminate this.\n+   --  True if X = null\n \n    function Source_Buffer_Ptr_Equal (X, Y : Source_Buffer_Ptr) return Boolean\n      renames \"=\";\n    --  Squirrel away the predefined \"=\", for use in Null_Source_Buffer_Ptr.\n    --  Do not call this elsewhere.\n \n    function \"=\" (X, Y : Source_Buffer_Ptr) return Boolean is abstract;\n-   --  Make \"=\" abstract, to make sure no one calls it. Note that this makes\n-   --  \"/=\" abstract as well. Calls to \"=\" on Source_Buffer_Ptr are always\n-   --  wrong, because two different arrays allocated at two different addresses\n-   --  can have the same virtual origin.\n+   --  Make \"=\" abstract. Note that this makes \"/=\" abstract as well. This is a\n+   --  vestige of the zero-origin array indexing we used to use, where \"=\" is\n+   --  always wrong (including the one in Null_Source_Buffer_Ptr). We keep this\n+   --  just because we never need to compare Source_Buffer_Ptrs other than to\n+   --  null.\n \n    subtype Source_Ptr is Text_Ptr;\n    --  Type used to represent a source location, which is a subscript of a\n@@ -580,7 +572,7 @@ package Types is\n    No_Unit : constant Unit_Number_Type := -1;\n    --  Special value used to signal no unit\n \n-   type Source_File_Index is new Int range -1 .. Int'Last;\n+   type Source_File_Index is new Int range 0 .. Int'Last;\n    --  Type used to index the source file table (see package Sinput)\n \n    No_Source_File : constant Source_File_Index := 0;"}]}