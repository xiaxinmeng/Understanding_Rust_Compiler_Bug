{"sha": "5cce22b6c2bfebd556b36a9c89d1bdf3eee900ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWNjZTIyYjZjMmJmZWJkNTU2YjM2YTljODlkMWJkZjNlZWU5MDBhZQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2000-11-17T10:05:31Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2000-11-17T10:05:31Z"}, "message": "cp-tree.h (PARMLIST_ELLIPSIS_P): New macro.\n\ncp:\n\t* cp-tree.h (PARMLIST_ELLIPSIS_P): New macro.\n\t* decl.c (grokdeclarator): Don't reject void parms here.\n\t(require_complete_types_for_parms): Simplify, use\n\tcomplete_type_or_else.\n\t(grokparms): Remove bitrot. Remove funcdef parm.\n\tDeal with ellipsis parm lists here.\n\t* semantics.c (finish_parmlist): Don't append void_list_node\n\there. Set PARMLIST_ELLIPSIS_P.\n\ntestsuite:\n\t* g++.old-deja/g++.other/incomplete.C: Add more tests.\n\t* g++.old-deja/g++.pt/crash9.C: Mark new expected error.\n\nFrom-SVN: r37517", "tree": {"sha": "e34855fe7b427f6d66bd4533fcc51da52d25cfb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e34855fe7b427f6d66bd4533fcc51da52d25cfb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5cce22b6c2bfebd556b36a9c89d1bdf3eee900ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cce22b6c2bfebd556b36a9c89d1bdf3eee900ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cce22b6c2bfebd556b36a9c89d1bdf3eee900ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cce22b6c2bfebd556b36a9c89d1bdf3eee900ae/comments", "author": null, "committer": null, "parents": [{"sha": "146c8d603442514a3d8ad791630e87c2cf5169c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/146c8d603442514a3d8ad791630e87c2cf5169c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/146c8d603442514a3d8ad791630e87c2cf5169c3"}], "stats": {"total": 363, "additions": 144, "deletions": 219}, "files": [{"sha": "1cbeac8055a76c89264e06707979c89c4328f2ac", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cce22b6c2bfebd556b36a9c89d1bdf3eee900ae/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cce22b6c2bfebd556b36a9c89d1bdf3eee900ae/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5cce22b6c2bfebd556b36a9c89d1bdf3eee900ae", "patch": "@@ -1,3 +1,14 @@\n+2000-11-17  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cp-tree.h (PARMLIST_ELLIPSIS_P): New macro.\n+\t* decl.c (grokdeclarator): Don't reject void parms here.\n+\t(require_complete_types_for_parms): Simplify, use\n+\tcomplete_type_or_else.\n+\t(grokparms): Remove bitrot. Remove funcdef parm.\n+\tDeal with ellipsis parm lists here.\n+\t* semantics.c (finish_parmlist): Don't append void_list_node\n+\there. Set PARMLIST_ELLIPSIS_P.\n+\n 2000-11-17  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* typeck2.c (incomplete_type_error): Reorganise to avoid"}, {"sha": "34c9d13651198b07d6da291263b3dc2a5d26686e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cce22b6c2bfebd556b36a9c89d1bdf3eee900ae/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cce22b6c2bfebd556b36a9c89d1bdf3eee900ae/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5cce22b6c2bfebd556b36a9c89d1bdf3eee900ae", "patch": "@@ -44,6 +44,7 @@ Boston, MA 02111-1307, USA.  */\n       CTOR_BEGIN_P (in CTOR_STMT)\n       BV_USE_VCALL_INDEX_P (in the BINFO_VIRTUALS TREE_LIST)\n       PTRMEM_OK_P (in ADDR_EXPR, OFFSET_REF)\n+      PARMLIST_ELLIPSIS_P (in PARMLIST)\n    1: IDENTIFIER_VIRTUAL_P.\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n@@ -1768,6 +1769,9 @@ struct lang_type\n    is a list of parameters, as opposed to a list of expressions.  */\n #define TREE_PARMLIST(NODE) ((NODE)->common.unsigned_flag) /* overloaded! */\n \n+/* Nonzero for a parmlist means that this parmlist ended in ...  */\n+#define PARMLIST_ELLIPSIS_P(NODE) TREE_LANG_FLAG_0 (NODE)\n+\n /* For FUNCTION_TYPE or METHOD_TYPE, a list of the exceptions that\n    this type can raise.  Each TREE_VALUE is a _TYPE.  The TREE_VALUE\n    will be NULL_TREE to indicate a throw specification of `()', or"}, {"sha": "a357526aa0c1253e60441ddfdc3864fd442abc2d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 101, "deletions": 209, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cce22b6c2bfebd556b36a9c89d1bdf3eee900ae/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cce22b6c2bfebd556b36a9c89d1bdf3eee900ae/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=5cce22b6c2bfebd556b36a9c89d1bdf3eee900ae", "patch": "@@ -100,7 +100,7 @@ extern int (*valid_lang_attribute) PARAMS ((tree, tree, tree, tree));\n \t\t\t: \"long long unsigned int\"))\n #endif\n \n-static tree grokparms\t\t\t\tPARAMS ((tree, int));\n+static tree grokparms\t\t\t\tPARAMS ((tree));\n static const char *redeclaration_error_message\tPARAMS ((tree, tree));\n \n static void push_binding_level PARAMS ((struct binding_level *, int,\n@@ -10738,7 +10738,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    /* FIXME: This is where default args should be fully\n \t       processed.  */\n \n-\t    arg_types = grokparms (inner_parms, funcdecl_p ? funcdef_flag : 0);\n+\t    arg_types = grokparms (inner_parms);\n \n \t    if (declarator && flags == DTOR_FLAG)\n \t      {\n@@ -11367,11 +11367,6 @@ friend declaration requires class-key, i.e. `friend %#T'\",\n \ttype = build_pointer_type (type);\n       else if (TREE_CODE (type) == OFFSET_TYPE)\n \ttype = build_pointer_type (type);\n-      else if (TREE_CODE (type) == VOID_TYPE && declarator)\n-\t{\n-\t  error (\"declaration of `%s' as void\", name);\n-\t  return NULL_TREE;\n-\t}\n     }\n \n   {\n@@ -11837,25 +11832,13 @@ require_complete_types_for_parms (parms)\n {\n   for (; parms; parms = TREE_CHAIN (parms))\n     {\n-      tree type = TREE_TYPE (parms);\n-\n-      /* Try to complete the TYPE.  */\n-      type = complete_type (type);\n-\n-      if (type == error_mark_node)\n-\tcontinue;\n-\n-      if (!COMPLETE_TYPE_P (type))\n-\t{\n-\t  if (DECL_NAME (parms))\n-\t    error (\"parameter `%s' has incomplete type\",\n-\t\t   IDENTIFIER_POINTER (DECL_NAME (parms)));\n-\t  else\n-\t    error (\"parameter has incomplete type\");\n-\t  TREE_TYPE (parms) = error_mark_node;\n-\t}\n-      else\n+      if (VOID_TYPE_P (TREE_TYPE (parms)))\n+        /* grokparms will have already issued an error */\n+        TREE_TYPE (parms) = error_mark_node;\n+      else if (complete_type_or_else (TREE_TYPE (parms), parms))\n \tlayout_decl (parms, 0);\n+      else\n+        TREE_TYPE (parms) = error_mark_node;\n     }\n }\n \n@@ -11986,205 +11969,114 @@ check_default_argument (decl, arg)\n    Given the list of things declared inside the parens,\n    return a list of types.\n \n-   The list we receive can have three kinds of elements:\n-   an IDENTIFIER_NODE for names given without types,\n-   a TREE_LIST node for arguments given as typespecs or names with typespecs,\n-   or void_type_node, to mark the end of an argument list\n-   when additional arguments are not permitted (... was not used).\n-\n-   FUNCDEF_FLAG is nonzero for a function definition, 0 for\n-   a mere declaration.  A nonempty identifier-list gets an error message\n-   when FUNCDEF_FLAG is zero.\n-   If FUNCDEF_FLAG is 1, then parameter types must be complete.\n-   If FUNCDEF_FLAG is -1, then parameter types may be incomplete.\n-\n-   If all elements of the input list contain types,\n-   we return a list of the types.\n-   If all elements contain no type (except perhaps a void_type_node\n-   at the end), we return a null list.\n-   If some have types and some do not, it is an error, and we\n-   return a null list.\n-\n-   Also set last_function_parms to either\n-   a list of names (IDENTIFIER_NODEs) or a chain of PARM_DECLs.\n-   A list of names is converted to a chain of PARM_DECLs\n-   by store_parm_decls so that ultimately it is always a chain of decls.\n-\n-   Note that in C++, parameters can take default values.  These default\n-   values are in the TREE_PURPOSE field of the TREE_LIST.  It is\n-   an error to specify default values which are followed by parameters\n-   that have no default values, or an ELLIPSES.  For simplicities sake,\n-   only parameters which are specified with their types can take on\n-   default values.  */\n+   We determine whether ellipsis parms are used by PARMLIST_ELLIPSIS_P\n+   flag. If unset, we append void_list_node. A parmlist declared\n+   as `(void)' is accepted as the empty parmlist.\n+\n+   Also set last_function_parms to the chain of PARM_DECLs.  */\n \n static tree\n-grokparms (first_parm, funcdef_flag)\n+grokparms (first_parm)\n      tree first_parm;\n-     int funcdef_flag;\n {\n   tree result = NULL_TREE;\n   tree decls = NULL_TREE;\n+  int ellipsis = !first_parm || PARMLIST_ELLIPSIS_P (first_parm);\n+  tree parm, chain;\n+  int any_error = 0;\n \n-  if (first_parm != NULL_TREE\n-      && TREE_CODE (TREE_VALUE (first_parm)) == IDENTIFIER_NODE)\n-    {\n-      if (! funcdef_flag)\n-\tpedwarn (\"parameter names (without types) in function declaration\");\n-      last_function_parms = first_parm;\n-      return NULL_TREE;\n-    }\n-  else if (first_parm != NULL_TREE\n-\t   && TREE_CODE (TREE_VALUE (first_parm)) != TREE_LIST\n-\t   && TREE_CODE (TREE_VALUE (first_parm)) != VOID_TYPE)\n-    my_friendly_abort (145);\n-  else\n+  my_friendly_assert (!first_parm || TREE_PARMLIST (first_parm), 20001115);\n+\n+  for (parm = first_parm; parm != NULL_TREE; parm = chain)\n     {\n-      /* Types were specified.  This is a list of declarators\n-\t each represented as a TREE_LIST node.  */\n-      register tree parm, chain;\n-      int any_init = 0, any_error = 0;\n+      tree type = NULL_TREE, list_node = parm;\n+      register tree decl = TREE_VALUE (parm);\n+      tree init = TREE_PURPOSE (parm);\n \n-      if (first_parm != NULL_TREE)\n+      chain = TREE_CHAIN (parm);\n+      /* @@ weak defense against parse errors.  */\n+      if (TREE_CODE (decl) != VOID_TYPE\n+\t  && TREE_CODE (decl) != TREE_LIST)\n \t{\n-\t  tree last_result = NULL_TREE;\n-\t  tree last_decl = NULL_TREE;\n-\n-\t  for (parm = first_parm; parm != NULL_TREE; parm = chain)\n-\t    {\n-\t      tree type = NULL_TREE, list_node = parm;\n-\t      register tree decl = TREE_VALUE (parm);\n-\t      tree init = TREE_PURPOSE (parm);\n-\n-\t      chain = TREE_CHAIN (parm);\n-\t      /* @@ weak defense against parse errors.  */\n-\t      if (TREE_CODE (decl) != VOID_TYPE\n-\t\t  && TREE_CODE (decl) != TREE_LIST)\n-\t\t{\n-\t\t  /* Give various messages as the need arises.  */\n-\t\t  if (TREE_CODE (decl) == STRING_CST)\n-\t\t    cp_error (\"invalid string constant `%E'\", decl);\n-\t\t  else if (TREE_CODE (decl) == INTEGER_CST)\n-\t\t    error (\"invalid integer constant in parameter list, did you forget to give parameter name?\");\n-\t\t  continue;\n-\t\t}\n+\t  /* Give various messages as the need arises.  */\n+\t  if (TREE_CODE (decl) == STRING_CST)\n+\t    cp_error (\"invalid string constant `%E'\", decl);\n+\t  else if (TREE_CODE (decl) == INTEGER_CST)\n+\t    error (\"invalid integer constant in parameter list, did you forget to give parameter name?\");\n+\t  continue;\n+\t}\n \n-\t      if (TREE_CODE (decl) != VOID_TYPE)\n-\t\t{\n-\t\t  decl = grokdeclarator (TREE_VALUE (decl),\n-\t\t\t\t\t TREE_PURPOSE (decl),\n-\t\t\t\t\t PARM, init != NULL_TREE,\n-\t\t\t\t\t NULL_TREE);\n-\t\t  if (! decl || TREE_TYPE (decl) == error_mark_node)\n-\t\t    continue;\n-\n-\t\t  /* Top-level qualifiers on the parameters are\n-\t\t     ignored for function types.  */\n-\t\t  type = TYPE_MAIN_VARIANT (TREE_TYPE (decl));\n-\n-\t\t  if (TREE_CODE (type) == VOID_TYPE)\n-\t\t    decl = void_type_node;\n-\t\t  else if (TREE_CODE (type) == METHOD_TYPE)\n-\t\t    {\n-\t\t      if (DECL_NAME (decl))\n-\t\t\t/* Cannot use the decl here because\n-\t\t\t   we don't have DECL_CONTEXT set up yet.  */\n-\t\t\tcp_error (\"parameter `%D' invalidly declared method type\",\n-\t\t\t\t  DECL_NAME (decl));\n-\t\t      else\n-\t\t\terror (\"parameter invalidly declared method type\");\n-\t\t      type = build_pointer_type (type);\n-\t\t      TREE_TYPE (decl) = type;\n-\t\t    }\n-\t\t  else if (TREE_CODE (type) == OFFSET_TYPE)\n-\t\t    {\n-\t\t      if (DECL_NAME (decl))\n-\t\t\tcp_error (\"parameter `%D' invalidly declared offset type\",\n-\t\t\t\t  DECL_NAME (decl));\n-\t\t      else\n-\t\t\terror (\"parameter invalidly declared offset type\");\n-\t\t      type = build_pointer_type (type);\n-\t\t      TREE_TYPE (decl) = type;\n-\t\t    }\n-                  else if (abstract_virtuals_error (decl, type))\n-\t\t    any_error = 1;  /* Seems like a good idea. */\n-\t\t  else if (POINTER_TYPE_P (type))\n-\t\t    {\n-\t\t      tree t = type;\n-\t\t      while (POINTER_TYPE_P (t)\n-\t\t\t     || (TREE_CODE (t) == ARRAY_TYPE\n-\t\t\t\t && TYPE_DOMAIN (t) != NULL_TREE))\n-\t\t\tt = TREE_TYPE (t);\n-\t\t      if (TREE_CODE (t) == ARRAY_TYPE)\n-\t\t\tcp_error (\"parameter type `%T' includes %s to array of unknown bound\",\n-\t\t\t\t  type,\n-\t\t\t\t  TYPE_PTR_P (type) ? \"pointer\" : \"reference\");\n-\t\t    }\n-\t\t}\n+      if (parm == void_list_node)\n+        break;\n \n-\t      if (TREE_CODE (decl) == VOID_TYPE)\n-\t\t{\n-\t\t  if (result == NULL_TREE)\n-\t\t    {\n-\t\t      result = void_list_node;\n-\t\t      last_result = result;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      TREE_CHAIN (last_result) = void_list_node;\n-\t\t      last_result = void_list_node;\n-\t\t    }\n-\t\t  if (chain\n-\t\t      && (chain != void_list_node || TREE_CHAIN (chain)))\n-\t\t    error (\"`void' in parameter list must be entire list\");\n-\t\t  break;\n-\t\t}\n+      decl = grokdeclarator (TREE_VALUE (decl), TREE_PURPOSE (decl),\n+        \t\t     PARM, init != NULL_TREE, NULL_TREE);\n+      if (! decl || TREE_TYPE (decl) == error_mark_node)\n+        continue;\n+    \n+      type = TREE_TYPE (decl);\n+      if (VOID_TYPE_P (type))\n+        {\n+          if (same_type_p (type, void_type_node)\n+              && !DECL_NAME (decl) && !result && !chain && !ellipsis)\n+            /* this is a parmlist of `(void)', which is ok.  */\n+            break;\n+          incomplete_type_error (decl, type);\n+        }\n+      \n+      /* Top-level qualifiers on the parameters are\n+         ignored for function types.  */\n+      type = TYPE_MAIN_VARIANT (type);\n+      if (TREE_CODE (type) == METHOD_TYPE)\n+        {\n+          cp_error (\"parameter `%D' invalidly declared method type\", decl);\n+          type = build_pointer_type (type);\n+          TREE_TYPE (decl) = type;\n+        }\n+      else if (TREE_CODE (type) == OFFSET_TYPE)\n+        {\n+          cp_error (\"parameter `%D' invalidly declared offset type\", decl);\n+          type = build_pointer_type (type);\n+          TREE_TYPE (decl) = type;\n+        }\n+      else if (abstract_virtuals_error (decl, type))\n+        any_error = 1;  /* Seems like a good idea. */\n+      else if (POINTER_TYPE_P (type))\n+        {\n+          /* [dcl.fct]/6, parameter types cannot contain pointers (references)\n+             to arrays of unknown bound.  */\n+          tree t = type;\n+          \n+          while (POINTER_TYPE_P (t)\n+                 || (TREE_CODE (t) == ARRAY_TYPE\n+                     && TYPE_DOMAIN (t) != NULL_TREE))\n+    \t    t = TREE_TYPE (t);\n+          if (TREE_CODE (t) == ARRAY_TYPE)\n+    \t    cp_error (\"parameter `%D' includes %s to array of unknown bound `%T'\",\n+    \t\t      decl, TYPE_PTR_P (type) ? \"pointer\" : \"reference\", t);\n+        }\n \n-\t      /* Since there is a prototype, args are passed in their own types.  */\n-\t      DECL_ARG_TYPE (decl) = TREE_TYPE (decl);\n-\t      if (PROMOTE_PROTOTYPES\n-\t\t  && (TREE_CODE (type) == INTEGER_TYPE\n-\t\t      || TREE_CODE (type) == ENUMERAL_TYPE)\n-\t\t  && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node))\n-\t\tDECL_ARG_TYPE (decl) = integer_type_node;\n-\t      if (!any_error && init)\n-\t\t{\n-\t\t  any_init++;\n-\t\t  init = check_default_argument (decl, init);\n-\t\t}\n-\t      else\n-\t\tinit = NULL_TREE;\n+      DECL_ARG_TYPE (decl) = TREE_TYPE (decl);\n+      if (PROMOTE_PROTOTYPES\n+\t  && (TREE_CODE (type) == INTEGER_TYPE\n+\t      || TREE_CODE (type) == ENUMERAL_TYPE)\n+\t  && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node))\n+\tDECL_ARG_TYPE (decl) = integer_type_node;\n+      if (!any_error && init)\n+        init = check_default_argument (decl, init);\n+      else\n+\tinit = NULL_TREE;\n \n-\t      if (decls == NULL_TREE)\n-\t\t{\n-\t\t  decls = decl;\n-\t\t  last_decl = decls;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  TREE_CHAIN (last_decl) = decl;\n-\t\t  last_decl = decl;\n-\t\t}\n-\t      list_node = tree_cons (init, type, NULL_TREE);\n-\t      if (result == NULL_TREE)\n-\t\t{\n-\t\t  result = list_node;\n-\t\t  last_result = result;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  TREE_CHAIN (last_result) = list_node;\n-\t\t  last_result = list_node;\n-\t\t}\n-\t    }\n-\t  if (last_result)\n-\t    TREE_CHAIN (last_result) = NULL_TREE;\n-\t  /* If there are no parameters, and the function does not end\n-\t     with `...', then last_decl will be NULL_TREE.  */\n-\t  if (last_decl != NULL_TREE)\n-\t    TREE_CHAIN (last_decl) = NULL_TREE;\n-\t}\n+      TREE_CHAIN (decl) = decls;\n+      decls = decl;\n+      list_node = tree_cons (init, type, NULL_TREE);\n+      TREE_CHAIN (list_node) = result;\n+      result = list_node;\n     }\n-\n+  decls = nreverse (decls);\n+  result = nreverse (result);\n+  if (!ellipsis)\n+    result = chainon (result, void_list_node);\n   last_function_parms = decls;\n \n   return result;"}, {"sha": "b372fdd4a7e078c3e78c908744cdc52033701eec", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cce22b6c2bfebd556b36a9c89d1bdf3eee900ae/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cce22b6c2bfebd556b36a9c89d1bdf3eee900ae/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=5cce22b6c2bfebd556b36a9c89d1bdf3eee900ae", "patch": "@@ -1695,13 +1695,15 @@ finish_parmlist (parms, ellipsis)\n      tree parms;\n      int ellipsis;\n {\n-  if (!ellipsis)\n-    chainon (parms, void_list_node);\n-  /* We mark the PARMS as a parmlist so that declarator processing can\n-     disambiguate certain constructs.  */\n-  if (parms != NULL_TREE)\n-    TREE_PARMLIST (parms) = 1;\n-\n+  if (parms)\n+    {\n+      /* We mark the PARMS as a parmlist so that declarator processing can\n+         disambiguate certain constructs.  */\n+      TREE_PARMLIST (parms) = 1;\n+      /* We do not append void_list_node here, but leave it to grokparms\n+         to do that.  */\n+      PARMLIST_ELLIPSIS_P (parms) = ellipsis;\n+    }\n   return parms;\n }\n "}, {"sha": "b6acd130c183c3c77e8eff7c22755a482aa6c3f3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cce22b6c2bfebd556b36a9c89d1bdf3eee900ae/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cce22b6c2bfebd556b36a9c89d1bdf3eee900ae/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5cce22b6c2bfebd556b36a9c89d1bdf3eee900ae", "patch": "@@ -1,3 +1,8 @@\n+2000-11-17  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.old-deja/g++.other/incomplete.C: Add more tests.\n+\t* g++.old-deja/g++.pt/crash9.C: Mark new expected error.\n+\n 2000-11-16  Nick Clifton  <nickc@redhat.com>\n \n \t* gcc.c-torture/execute/nestfunc-2.c: New test."}, {"sha": "f5e9a581faf98d97c83849be667089d3532e5cab", "filename": "gcc/testsuite/g++.old-deja/g++.other/incomplete.C", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cce22b6c2bfebd556b36a9c89d1bdf3eee900ae/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fincomplete.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cce22b6c2bfebd556b36a9c89d1bdf3eee900ae/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fincomplete.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fincomplete.C?ref=5cce22b6c2bfebd556b36a9c89d1bdf3eee900ae", "patch": "@@ -1,5 +1,16 @@\n // Build don't link:\n \n-struct S;\n+// gcc represents non-ellipsis parmlists by terminating them with\n+// a void parm. We need to distinguish between a parmlist of (void), and\n+// some ill-formed ones.\n \n-void f(S s) {} // ERROR - incomplete type\n+struct S; // ERROR - forward ref\n+\n+void f(S);            // ok\n+void f(S s) {}        // ERROR - incomplete type\n+void j (int){};       // ok\n+void k (){};          // ok\n+void q (void){}       // ok\n+void t (void t);      // ERROR - incomplete\n+void r (void, ...);   // ERROR - incomplete\n+void s (void const);  // ERROR - incomplete"}, {"sha": "d72699d2360eebcc03d0ff1f6f3e1c9801f45b8a", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash9.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cce22b6c2bfebd556b36a9c89d1bdf3eee900ae/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cce22b6c2bfebd556b36a9c89d1bdf3eee900ae/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash9.C?ref=5cce22b6c2bfebd556b36a9c89d1bdf3eee900ae", "patch": "@@ -3,7 +3,7 @@\n template <class T>\n void f(T) {} // ERROR - parameter has incomplete type\n \n-class C;\n+class C;    // ERROR - forward declaration\n \n void g(const C& c)\n {"}]}