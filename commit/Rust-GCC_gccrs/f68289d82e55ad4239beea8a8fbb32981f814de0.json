{"sha": "f68289d82e55ad4239beea8a8fbb32981f814de0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjY4Mjg5ZDgyZTU1YWQ0MjM5YmVlYThhOGZiYjMyOTgxZjgxNGRlMA==", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2019-10-10T15:23:24Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-10-10T15:23:24Z"}, "message": "[Ada] Generation of procedures for blocks occurring in elaboration code for LLVM\n\n2019-10-10  Gary Dismukes  <dismukes@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch7.adb (Check_Unnesting_Elaboration_Code): Various\n\tcleanups.\n\t(Set_Elab_Proc): New procedure to create the defining identifier\n\tfor a procedure created to encapsulate top-level blocks\n\toccurring as a part of library package elaboration.\n\t(First_Local_Scope): Function replaced by\n\tReset_Scopes_To_Elab_Proc.\n\t(Reset_Scopes_To_Elab_Proc): New recursive procedure based on\n\tFirst_Local_Scope, which it replaces, that is called to traverse\n\tthe statements of a library package body to locate top-level\n\tblocks and determine whether they contain nested subprograms\n\tthat might address library-level objects of the package. Such\n\tblocks (and loops) and certain top-level subprograms within the\n\tstatements will have their Scope reset here to match an\n\tencapsulating procedure created by\n\tCheck_Unnesting_Elaboration_Code that will contain the\n\tstatements.\n\t(Check_Unnesting_In_Decls_Or_Stmts): Code for handling blocks\n\tfactored out into Unnest_Block. Add handling for package\n\tdeclarations and bodies, making recursive calls for\n\tvisible/private declarations, body declarations, statements, and\n\texception handlers. Also remove test for Is_Compilation_Unit:\n\tcaller tests for Is_Library_Level_Entity instead.  Also, this\n\tproc's name was changed from Check_Unnesting_In_Declarations.\n\t(Check_Unnesting_In_Handlers): New procedure to traverse a\n\tsequence of exception handlers, calling\n\tCheck_Unnesting_In_Decls_Or_Stmts on the statements of each\n\thandler.\n\t(Expand_N_Package_Body): Call Check_Unnesting_* routines only\n\twhen Unnest_Subprogram_Mode is set and the current scope is a\n\tlibrary-level entity (which includes packages and instantiations\n\tnested directly within a library unit).\n\t(Expand_N_Package_Declaration): Call Check_Unnesting_* routines\n\tonly when Unnest_Subprogram_Mode is set and the current scope is\n\ta library-level entity (which includes packages and\n\tinstantiations nested directly within a library unit).\n\t(Unnest_Block): New procedure factored out of\n\tCheck_Unnesting_In_Decls_Or_Stmts, for creating a new procedure\n\tto replace a block statement and resetting the Scope fields of\n\tthe block's top-level entities.\n\nFrom-SVN: r276816", "tree": {"sha": "0f961c2f666c466dd48c655b7ddd58e6beb2b2a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f961c2f666c466dd48c655b7ddd58e6beb2b2a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f68289d82e55ad4239beea8a8fbb32981f814de0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f68289d82e55ad4239beea8a8fbb32981f814de0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f68289d82e55ad4239beea8a8fbb32981f814de0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f68289d82e55ad4239beea8a8fbb32981f814de0/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d408dbfeabe3b4a65f6e955e97c0bef92056a845", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d408dbfeabe3b4a65f6e955e97c0bef92056a845", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d408dbfeabe3b4a65f6e955e97c0bef92056a845"}], "stats": {"total": 430, "additions": 269, "deletions": 161}, "files": [{"sha": "866de1f3516ebed156a88b2b554f8bb6fd6765cc", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 41, "deletions": 9, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f68289d82e55ad4239beea8a8fbb32981f814de0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f68289d82e55ad4239beea8a8fbb32981f814de0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f68289d82e55ad4239beea8a8fbb32981f814de0", "patch": "@@ -1,10 +1,42 @@\n-2019-10-10  Anthony Leonardo Gracio  <leonardo@adacore.com>\n+2019-10-10  Gary Dismukes  <dismukes@adacore.com>\n \n-\t* doc/gnat_ugn/about_this_guide.rst,\n-\tdoc/gnat_ugn/building_executable_programs_with_gnat.rst,\n-\tdoc/gnat_ugn/getting_started_with_gnat.rst,\n-\tdoc/gnat_ugn/gnat_and_program_execution.rst, errout.ads,\n-\texp_ch3.adb, gnatls.adb, impunit.adb, lib-writ.ads, opt.ads,\n-\tsem_ch7.adb, sem_prag.adb, sem_res.adb, sem_warn.adb,\n-\tterminals.c: Replace GPS by GNAT Studio.\n-\t* gnat_ugn.texi: Regenerate.\n\\ No newline at end of file\n+\t* exp_ch7.adb (Check_Unnesting_Elaboration_Code): Various\n+\tcleanups.\n+\t(Set_Elab_Proc): New procedure to create the defining identifier\n+\tfor a procedure created to encapsulate top-level blocks\n+\toccurring as a part of library package elaboration.\n+\t(First_Local_Scope): Function replaced by\n+\tReset_Scopes_To_Elab_Proc.\n+\t(Reset_Scopes_To_Elab_Proc): New recursive procedure based on\n+\tFirst_Local_Scope, which it replaces, that is called to traverse\n+\tthe statements of a library package body to locate top-level\n+\tblocks and determine whether they contain nested subprograms\n+\tthat might address library-level objects of the package. Such\n+\tblocks (and loops) and certain top-level subprograms within the\n+\tstatements will have their Scope reset here to match an\n+\tencapsulating procedure created by\n+\tCheck_Unnesting_Elaboration_Code that will contain the\n+\tstatements.\n+\t(Check_Unnesting_In_Decls_Or_Stmts): Code for handling blocks\n+\tfactored out into Unnest_Block. Add handling for package\n+\tdeclarations and bodies, making recursive calls for\n+\tvisible/private declarations, body declarations, statements, and\n+\texception handlers. Also remove test for Is_Compilation_Unit:\n+\tcaller tests for Is_Library_Level_Entity instead.  Also, this\n+\tproc's name was changed from Check_Unnesting_In_Declarations.\n+\t(Check_Unnesting_In_Handlers): New procedure to traverse a\n+\tsequence of exception handlers, calling\n+\tCheck_Unnesting_In_Decls_Or_Stmts on the statements of each\n+\thandler.\n+\t(Expand_N_Package_Body): Call Check_Unnesting_* routines only\n+\twhen Unnest_Subprogram_Mode is set and the current scope is a\n+\tlibrary-level entity (which includes packages and instantiations\n+\tnested directly within a library unit).\n+\t(Expand_N_Package_Declaration): Call Check_Unnesting_* routines\n+\tonly when Unnest_Subprogram_Mode is set and the current scope is\n+\ta library-level entity (which includes packages and\n+\tinstantiations nested directly within a library unit).\n+\t(Unnest_Block): New procedure factored out of\n+\tCheck_Unnesting_In_Decls_Or_Stmts, for creating a new procedure\n+\tto replace a block statement and resetting the Scope fields of\n+\tthe block's top-level entities.\n\\ No newline at end of file"}, {"sha": "f1b72798be0ebac23c23613237e48c2b719f23e0", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 228, "deletions": 152, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f68289d82e55ad4239beea8a8fbb32981f814de0/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f68289d82e55ad4239beea8a8fbb32981f814de0/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=f68289d82e55ad4239beea8a8fbb32981f814de0", "patch": "@@ -364,20 +364,39 @@ package body Exp_Ch7 is\n \n    procedure Check_Unnesting_Elaboration_Code (N : Node_Id);\n    --  The statement part of a package body that is a compilation unit may\n-   --  contain blocks that declare local subprograms. In Subprogram_Unnesting\n+   --  contain blocks that declare local subprograms. In Subprogram_Unnesting_\n    --  Mode such subprograms must be handled as nested inside the (implicit)\n    --  elaboration procedure that executes that statement part. To handle\n    --  properly uplevel references we construct that subprogram explicitly,\n    --  to contain blocks and inner subprograms, The statement part becomes\n    --  a call to this subprogram. This is only done if blocks are present\n-   --  in the statement list of the body.\n-\n-   procedure Check_Unnesting_In_Declarations (Decls : List_Id);\n-   --  Similarly, the declarations in the package body may have created\n-   --  blocks with nested subprograms. Such a block must be transformed into a\n-   --  procedure followed by a call to it, so that unnesting can handle uplevel\n-   --  references within these nested subprograms (typically generated\n-   --  subprograms to handle finalization actions).\n+   --  in the statement list of the body. (It would be nice to unify this\n+   --  procedure with Check_Unnesting_In_Decls_Or_Stmts, if possible, since\n+   --  they're doing very similar work, but are structured differently. ???)\n+\n+   procedure Check_Unnesting_In_Decls_Or_Stmts (Decls_Or_Stmts : List_Id);\n+   --  Similarly, the declarations or statements in library-level packages may\n+   --  have created blocks blocks with nested subprograms. Such a block must be\n+   --  transformed into a procedure followed by a call to it, so that unnesting\n+   --  can handle uplevel references within these nested subprograms (typically\n+   --  subprograms that handle finalization actions). This also applies to\n+   --  nested packages, including instantiations, in which case it must\n+   --  recursively process inner bodies.\n+\n+   procedure Check_Unnesting_In_Handlers (N : Node_Id);\n+   --  Similarly, check for blocks with nested subprograms occurring within\n+   --  a set of exception handlers associated with a package body N.\n+\n+   procedure Unnest_Block (Decl : Node_Id);\n+   --  Blocks that contain nested subprograms with up-level references need to\n+   --  create activation records for them. We do this by rewriting the block as\n+   --  a procedure, followed by a call to it in the same declarative list, to\n+   --  replicate the semantics of the original block.\n+   --\n+   --  A common source for such block is a transient block created for a\n+   --  construct (declaration, assignment, etc.) that involves controlled\n+   --  actions or secondary-stack management, in which case the nested\n+   --  subprogram is a finalizer.\n \n    procedure Check_Visibly_Controlled\n      (Prim : Final_Primitives;\n@@ -4020,27 +4039,39 @@ package body Exp_Ch7 is\n    --------------------------------------\n \n    procedure Check_Unnesting_Elaboration_Code (N : Node_Id) is\n-      Loc       : constant Source_Ptr := Sloc (N);\n-      First_Ent : Entity_Id := Empty;\n-      Loop_Id   : Entity_Id := Empty;\n-\n-      function First_Local_Scope (L : List_Id) return Entity_Id;\n-      --  Find first entity in the elaboration code of the body that contains\n-      --  or represents a subprogram body. A body can appear within a block or\n-      --  a loop or can appear by itself if generated for an object declaration\n-      --  that involves controlled actions. The first such entity encountered\n-      --  is used to reset the scopes of all entities that become local to the\n-      --  new elaboration procedure. This is needed for subsequent unnesting,\n-      --  which depends on the scope links to determine the nesting level of\n-      --  each subprogram.\n+      Loc             : constant Source_Ptr := Sloc (N);\n+      Block_Elab_Proc : Entity_Id           := Empty;\n+\n+      procedure Set_Block_Elab_Proc;\n+      --  Create a defining identifier for a procedure that will replace\n+      --  a block with nested subprograms (unless it has already been created,\n+      --  in which case this is a no-op).\n+\n+      procedure Set_Block_Elab_Proc is\n+      begin\n+         if No (Block_Elab_Proc) then\n+            Block_Elab_Proc :=\n+              Make_Defining_Identifier (Loc, Chars => New_Internal_Name ('I'));\n+         end if;\n+      end Set_Block_Elab_Proc;\n+\n+      procedure Reset_Scopes_To_Block_Elab_Proc (L : List_Id);\n+      --  Find entities in the elaboration code of a library package body that\n+      --  contain or represent a subprogram body. A body can appear within a\n+      --  block or a loop or can appear by itself if generated for an object\n+      --  declaration that involves controlled actions. The first such entity\n+      --  forces creation of a new procedure entity (via Set_Block_Elab_Proc)\n+      --  that will be used to reset the scopes of all entities that become\n+      --  local to the new elaboration procedure. This is needed for subsequent\n+      --  unnesting actions, which depend on proper setting of the Scope links\n+      --  to determine the nesting level of each subprogram.\n \n       -----------------------\n       --  Find_Local_Scope --\n       -----------------------\n \n-      function First_Local_Scope (L : List_Id) return Entity_Id is\n+      procedure Reset_Scopes_To_Block_Elab_Proc (L : List_Id) is\n          Id   : Entity_Id;\n-         Scop : Entity_Id;\n          Stat : Node_Id;\n \n       begin\n@@ -4050,53 +4081,45 @@ package body Exp_Ch7 is\n                when N_Block_Statement =>\n                   Id := Entity (Identifier (Stat));\n \n-                  if No (First_Ent) then\n-                     First_Ent := Id;\n-                  end if;\n+                  --  The Scope of this block needs to be reset to the new\n+                  --  procedure if the block contains nested subprograms.\n \n                   if Present (Id) and then Contains_Subprogram (Id) then\n-                     return Id;\n+                     Set_Block_Elab_Proc;\n+                     Set_Scope (Id, Block_Elab_Proc);\n                   end if;\n \n                when N_Loop_Statement =>\n                   Id := Entity (Identifier (Stat));\n \n-                  if No (First_Ent) then\n-                     First_Ent := Id;\n-                  end if;\n-\n-                  if Contains_Subprogram (Id) then\n+                  if Present (Id) and then Contains_Subprogram (Id) then\n                      if Scope (Id) = Current_Scope then\n-                        Loop_Id := Id;\n+                        Set_Block_Elab_Proc;\n+                        Set_Scope (Id, Block_Elab_Proc);\n                      end if;\n-\n-                     return Id;\n                   end if;\n \n-               when N_If_Statement =>\n-                  Scop := First_Local_Scope (Then_Statements (Stat));\n+                  --  We traverse the loop's statements as well, which may\n+                  --  include other block (etc.) statements that need to have\n+                  --  their Scope set to Block_Elab_Proc. (Is this really the\n+                  --  case, or do such nested blocks refer to the loop scope\n+                  --  rather than the loop's enclosing scope???.)\n \n-                  if Present (Scop) then\n-                     return Scop;\n-                  end if;\n+                  Reset_Scopes_To_Block_Elab_Proc (Statements (Stat));\n \n-                  Scop := First_Local_Scope (Else_Statements (Stat));\n+               when N_If_Statement =>\n+                  Reset_Scopes_To_Block_Elab_Proc (Then_Statements (Stat));\n \n-                  if Present (Scop) then\n-                     return Scop;\n-                  end if;\n+                  Reset_Scopes_To_Block_Elab_Proc (Else_Statements (Stat));\n \n                   declare\n                      Elif : Node_Id;\n \n                   begin\n                      Elif := First (Elsif_Parts (Stat));\n                      while Present (Elif) loop\n-                        Scop := First_Local_Scope (Statements (Elif));\n-\n-                        if Present (Scop) then\n-                           return Scop;\n-                        end if;\n+                        Reset_Scopes_To_Block_Elab_Proc\n+                          (Then_Statements (Elif));\n \n                         Next (Elif);\n                      end loop;\n@@ -4109,178 +4132,154 @@ package body Exp_Ch7 is\n                   begin\n                      Alt := First (Alternatives (Stat));\n                      while Present (Alt) loop\n-                        Scop := First_Local_Scope (Statements (Alt));\n-\n-                        if Present (Scop) then\n-                           return Scop;\n-                        end if;\n+                        Reset_Scopes_To_Block_Elab_Proc (Statements (Alt));\n \n                         Next (Alt);\n                      end loop;\n                   end;\n \n+               --  Reset the Scope of a subprogram occurring at the top level\n+\n                when N_Subprogram_Body =>\n                   Id := Defining_Entity (Stat);\n \n-                  if No (First_Ent) then\n-                     First_Ent := Id;\n-                  end if;\n-\n-                  return Id;\n+                  Set_Block_Elab_Proc;\n+                  Set_Scope (Id, Block_Elab_Proc);\n \n                when others =>\n                   null;\n             end case;\n \n             Next (Stat);\n          end loop;\n-\n-         return Empty;\n-      end First_Local_Scope;\n+      end Reset_Scopes_To_Block_Elab_Proc;\n \n       --  Local variables\n \n       H_Seq     : constant Node_Id := Handled_Statement_Sequence (N);\n       Elab_Body : Node_Id;\n       Elab_Call : Node_Id;\n-      Elab_Proc : Entity_Id;\n-      Ent       : Entity_Id;\n \n    --  Start of processing for Check_Unnesting_Elaboration_Code\n \n    begin\n-      if Unnest_Subprogram_Mode\n-        and then Present (H_Seq)\n-        and then Is_Compilation_Unit (Current_Scope)\n-      then\n-         Ent := First_Local_Scope (Statements (H_Seq));\n+      if Present (H_Seq) then\n+         Reset_Scopes_To_Block_Elab_Proc (Statements (H_Seq));\n \n-         --  There msy be subprograms declared in the exception handlers\n+         --  There may be subprograms declared in the exception handlers\n          --  of the current body.\n \n-         if No (Ent) and then Present (Exception_Handlers (H_Seq)) then\n+         if Present (Exception_Handlers (H_Seq)) then\n             declare\n                Handler : Node_Id := First (Exception_Handlers (H_Seq));\n             begin\n                while Present (Handler) loop\n-                  Ent := First_Local_Scope (Statements (Handler));\n-                  if Present (Ent) then\n-                     First_Ent := Ent;\n-                     exit;\n-                  end if;\n+                  Reset_Scopes_To_Block_Elab_Proc (Statements (Handler));\n \n                   Next (Handler);\n                end loop;\n             end;\n          end if;\n \n-         if Present (Ent) then\n-            Elab_Proc :=\n-              Make_Defining_Identifier (Loc,\n-                Chars => New_Internal_Name ('I'));\n-\n+         if Present (Block_Elab_Proc) then\n             Elab_Body :=\n               Make_Subprogram_Body (Loc,\n                 Specification              =>\n                   Make_Procedure_Specification (Loc,\n-                    Defining_Unit_Name => Elab_Proc),\n+                    Defining_Unit_Name => Block_Elab_Proc),\n                 Declarations               => New_List,\n                 Handled_Statement_Sequence =>\n                   Relocate_Node (Handled_Statement_Sequence (N)));\n \n             Elab_Call :=\n               Make_Procedure_Call_Statement (Loc,\n-                Name => New_Occurrence_Of (Elab_Proc, Loc));\n+                Name => New_Occurrence_Of (Block_Elab_Proc, Loc));\n \n             Append_To (Declarations (N), Elab_Body);\n             Analyze (Elab_Body);\n-            Set_Has_Nested_Subprogram (Elab_Proc);\n+            Set_Has_Nested_Subprogram (Block_Elab_Proc);\n \n             Set_Handled_Statement_Sequence (N,\n               Make_Handled_Sequence_Of_Statements (Loc,\n                 Statements => New_List (Elab_Call)));\n \n             Analyze (Elab_Call);\n \n-            --  The scope of all blocks and loops in the elaboration code is\n-            --  now the constructed elaboration procedure. Nested subprograms\n-            --  within those blocks will have activation records if they\n-            --  contain references to entities in the enclosing block or\n-            --  the package itself.\n-\n-            Ent := First_Ent;\n-            while Present (Ent) loop\n-               Set_Scope (Ent, Elab_Proc);\n-               Next_Entity (Ent);\n-            end loop;\n-\n-            if Present (Loop_Id) then\n-               Set_Scope (Loop_Id, Elab_Proc);\n-            end if;\n+            --  Could we reset the scopes of entities associated with the new\n+            --  procedure here via a loop over entities rather than doing it in\n+            --  the recursive Reset_Scopes_To_Elab_Proc procedure???\n          end if;\n       end if;\n    end Check_Unnesting_Elaboration_Code;\n \n-   -------------------------------------\n-   -- Check_Unnesting_In_Declarations --\n-   -------------------------------------\n+   ---------------------------------------\n+   -- Check_Unnesting_In_Decls_Or_Stmts --\n+   ---------------------------------------\n \n-   procedure Check_Unnesting_In_Declarations (Decls : List_Id) is\n-      Decl       : Node_Id;\n-      Ent        : Entity_Id;\n-      Loc        : Source_Ptr;\n-      Local_Body : Node_Id;\n-      Local_Call : Node_Id;\n-      Local_Proc : Entity_Id;\n+   procedure Check_Unnesting_In_Decls_Or_Stmts (Decls_Or_Stmts : List_Id) is\n+      Decl_Or_Stmt : Node_Id;\n \n    begin\n-      Local_Call := Empty;\n-\n       if Unnest_Subprogram_Mode\n-        and then Present (Decls)\n-        and then Is_Compilation_Unit (Current_Scope)\n+        and then Present (Decls_Or_Stmts)\n       then\n-         Decl := First (Decls);\n-         while Present (Decl) loop\n-            if Nkind (Decl) = N_Block_Statement\n-               and then Contains_Subprogram (Entity (Identifier (Decl)))\n+         Decl_Or_Stmt := First (Decls_Or_Stmts);\n+         while Present (Decl_Or_Stmt) loop\n+            if Nkind (Decl_Or_Stmt) = N_Block_Statement\n+              and then Contains_Subprogram (Entity (Identifier (Decl_Or_Stmt)))\n             then\n-               Ent := First_Entity (Entity (Identifier (Decl)));\n-               Loc := Sloc (Decl);\n-               Local_Proc :=\n-                 Make_Defining_Identifier (Loc,\n-                   Chars => New_Internal_Name ('P'));\n-\n-               Local_Body :=\n-                 Make_Subprogram_Body (Loc,\n-                   Specification              =>\n-                     Make_Procedure_Specification (Loc,\n-                       Defining_Unit_Name => Local_Proc),\n-                       Declarations       => Declarations (Decl),\n-                   Handled_Statement_Sequence =>\n-                     Handled_Statement_Sequence (Decl));\n-\n-               Rewrite (Decl, Local_Body);\n-               Analyze (Decl);\n-               Set_Has_Nested_Subprogram (Local_Proc);\n-\n-               Local_Call :=\n-                 Make_Procedure_Call_Statement (Loc,\n-                   Name => New_Occurrence_Of (Local_Proc, Loc));\n+               Unnest_Block (Decl_Or_Stmt);\n \n-               Insert_After (Decl, Local_Call);\n-               Analyze (Local_Call);\n+            elsif Nkind (Decl_Or_Stmt) = N_Package_Declaration\n+              and then not Modify_Tree_For_C\n+            then\n+               Check_Unnesting_In_Decls_Or_Stmts\n+                 (Visible_Declarations (Specification (Decl_Or_Stmt)));\n+               Check_Unnesting_In_Decls_Or_Stmts\n+                 (Private_Declarations (Specification (Decl_Or_Stmt)));\n \n-               while Present (Ent) loop\n-                  Set_Scope (Ent, Local_Proc);\n-                  Next_Entity (Ent);\n-               end loop;\n+            elsif Nkind (Decl_Or_Stmt) = N_Package_Body\n+              and then not Modify_Tree_For_C\n+            then\n+               Check_Unnesting_In_Decls_Or_Stmts (Declarations (Decl_Or_Stmt));\n+               if Present (Statements\n+                    (Handled_Statement_Sequence (Decl_Or_Stmt)))\n+               then\n+                  Check_Unnesting_In_Decls_Or_Stmts (Statements\n+                    (Handled_Statement_Sequence (Decl_Or_Stmt)));\n+                  Check_Unnesting_In_Handlers (Decl_Or_Stmt);\n+               end if;\n             end if;\n \n-            Next (Decl);\n+            Next (Decl_Or_Stmt);\n          end loop;\n       end if;\n-   end Check_Unnesting_In_Declarations;\n+   end Check_Unnesting_In_Decls_Or_Stmts;\n+\n+   ---------------------------------\n+   -- Check_Unnesting_In_Handlers --\n+   ---------------------------------\n+\n+   procedure Check_Unnesting_In_Handlers (N : Node_Id) is\n+      Stmt_Seq : constant Node_Id := Handled_Statement_Sequence (N);\n+\n+   begin\n+      if Present (Stmt_Seq)\n+        and then Present (Exception_Handlers (Stmt_Seq))\n+      then\n+         declare\n+            Handler : Node_Id := First (Exception_Handlers (Stmt_Seq));\n+         begin\n+            while Present (Handler) loop\n+               if Present (Statements (Handler)) then\n+                  Check_Unnesting_In_Decls_Or_Stmts (Statements (Handler));\n+               end if;\n+\n+               Next (Handler);\n+            end loop;\n+         end;\n+      end if;\n+   end Check_Unnesting_In_Handlers;\n \n    ------------------------------\n    -- Check_Visibly_Controlled --\n@@ -5036,8 +5035,20 @@ package body Exp_Ch7 is\n          --  end of the body statements.\n \n          Expand_Pragma_Initial_Condition (Spec_Id, N);\n-         Check_Unnesting_Elaboration_Code (N);\n-         Check_Unnesting_In_Declarations (Declarations (N));\n+\n+         --  If this is a library-level package and unnesting is enabled,\n+         --  check for the presence of blocks with nested subprograms occurring\n+         --  in elaboration code, and generate procedures to encapsulate the\n+         --  blocks in case the nested subprograms make up-level references.\n+\n+         if Unnest_Subprogram_Mode\n+           and then\n+             Is_Library_Level_Entity (Current_Scope)\n+         then\n+            Check_Unnesting_Elaboration_Code (N);\n+            Check_Unnesting_In_Decls_Or_Stmts (Declarations (N));\n+            Check_Unnesting_In_Handlers (N);\n+         end if;\n \n          Pop_Scope;\n       end if;\n@@ -5196,8 +5207,17 @@ package body Exp_Ch7 is\n          Set_Finalizer (Id, Fin_Id);\n       end if;\n \n-      Check_Unnesting_In_Declarations (Visible_Declarations (Spec));\n-      Check_Unnesting_In_Declarations (Private_Declarations (Spec));\n+      --  If this is a library-level package and unnesting is enabled,\n+      --  check for the presence of blocks with nested subprograms occurring\n+      --  in elaboration code, and generate procedures to encapsulate the\n+      --  blocks in case the nested subprograms make up-level references.\n+\n+      if Unnest_Subprogram_Mode\n+        and then Is_Library_Level_Entity (Current_Scope)\n+      then\n+         Check_Unnesting_In_Decls_Or_Stmts (Visible_Declarations (Spec));\n+         Check_Unnesting_In_Decls_Or_Stmts (Private_Declarations (Spec));\n+      end if;\n    end Expand_N_Package_Declaration;\n \n    ----------------------------\n@@ -9180,6 +9200,62 @@ package body Exp_Ch7 is\n       Store_Actions_In_Scope (Cleanup, L);\n    end Store_Cleanup_Actions_In_Scope;\n \n+   ------------------\n+   -- Unnest_Block --\n+   ------------------\n+\n+   procedure Unnest_Block (Decl : Node_Id) is\n+      Loc        : constant Source_Ptr := Sloc (Decl);\n+      Ent        : Entity_Id;\n+      Local_Body : Node_Id;\n+      Local_Call : Node_Id;\n+      Local_Proc : Entity_Id;\n+      Local_Scop : Entity_Id;\n+\n+   begin\n+      Local_Scop := Entity (Identifier (Decl));\n+      Ent := First_Entity (Local_Scop);\n+\n+      Local_Proc :=\n+        Make_Defining_Identifier (Loc,\n+          Chars => New_Internal_Name ('P'));\n+\n+      Local_Body :=\n+        Make_Subprogram_Body (Loc,\n+          Specification              =>\n+            Make_Procedure_Specification (Loc,\n+              Defining_Unit_Name => Local_Proc),\n+              Declarations       => Declarations (Decl),\n+          Handled_Statement_Sequence =>\n+            Handled_Statement_Sequence (Decl));\n+\n+      Rewrite (Decl, Local_Body);\n+      Analyze (Decl);\n+      Set_Has_Nested_Subprogram (Local_Proc);\n+\n+      Local_Call :=\n+        Make_Procedure_Call_Statement (Loc,\n+          Name => New_Occurrence_Of (Local_Proc, Loc));\n+\n+      Insert_After (Decl, Local_Call);\n+      Analyze (Local_Call);\n+\n+      --  The new subprogram has the same scope as the original block\n+\n+      Set_Scope (Local_Proc, Scope (Local_Scop));\n+\n+      --  And the entity list of the new procedure is that of the block\n+\n+      Set_First_Entity (Local_Proc, Ent);\n+\n+      --  Reset the scopes of all the entities to the new procedure\n+\n+      while Present (Ent) loop\n+         Set_Scope (Ent, Local_Proc);\n+         Next_Entity (Ent);\n+      end loop;\n+   end Unnest_Block;\n+\n    --------------------------------\n    -- Wrap_Transient_Declaration --\n    --------------------------------"}]}