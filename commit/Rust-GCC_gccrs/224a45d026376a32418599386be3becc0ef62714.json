{"sha": "224a45d026376a32418599386be3becc0ef62714", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjI0YTQ1ZDAyNjM3NmEzMjQxODU5OTM4NmJlM2JlY2MwZWY2MjcxNA==", "commit": {"author": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2002-06-22T03:03:56Z"}, "committer": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2002-06-22T03:03:56Z"}, "message": "stl_map.h, [...]: Reformat and complete doxygenation.\n\n2002-06-21  Phil Edwards  <pme@gcc.gnu.org>\n\n\t* include/bits/stl_map.h, include/bits/stl_multimap.h,\n\tinclude/bits/stl_queue.h, include/bits/stl_stack.h:  Reformat and\n\tcomplete doxygenation.\n\t* include/bits/boost_concept_check.h:  Minor comment.\n\nFrom-SVN: r54897", "tree": {"sha": "1124a12e63777c7a3ea9591b579bacd8ab4c75bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1124a12e63777c7a3ea9591b579bacd8ab4c75bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/224a45d026376a32418599386be3becc0ef62714", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/224a45d026376a32418599386be3becc0ef62714", "html_url": "https://github.com/Rust-GCC/gccrs/commit/224a45d026376a32418599386be3becc0ef62714", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/224a45d026376a32418599386be3becc0ef62714/comments", "author": null, "committer": null, "parents": [{"sha": "233610934411ab34d6f64b42e3f253044207c795", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/233610934411ab34d6f64b42e3f253044207c795", "html_url": "https://github.com/Rust-GCC/gccrs/commit/233610934411ab34d6f64b42e3f253044207c795"}], "stats": {"total": 1393, "additions": 904, "deletions": 489}, "files": [{"sha": "35bfd0a9a4706424ced27e97653946daef9c5a47", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/224a45d026376a32418599386be3becc0ef62714/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/224a45d026376a32418599386be3becc0ef62714/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=224a45d026376a32418599386be3becc0ef62714", "patch": "@@ -1,3 +1,10 @@\n+2002-06-21  Phil Edwards  <pme@gcc.gnu.org>\n+\n+\t* include/bits/stl_map.h, include/bits/stl_multimap.h,\n+\tinclude/bits/stl_queue.h, include/bits/stl_stack.h:  Reformat and\n+\tcomplete doxygenation.\n+\t* include/bits/boost_concept_check.h:  Minor comment.\n+\n 2002-06-21  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* include/c_compatibility: New."}, {"sha": "d91c2e88e3c90f4c85a0a2b29933b6537be798b2", "filename": "libstdc++-v3/include/bits/boost_concept_check.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/224a45d026376a32418599386be3becc0ef62714/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fboost_concept_check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/224a45d026376a32418599386be3becc0ef62714/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fboost_concept_check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fboost_concept_check.h?ref=224a45d026376a32418599386be3becc0ef62714", "patch": "@@ -149,6 +149,8 @@ struct _Aux_require_same<_Tp,_Tp> { typedef _Tp _Type; };\n       __a = __b;                   // const required for argument to assignment\n     }\n     _Tp __a;\n+    // possibly should be \"Tp* a;\" and then dereference \"a\" in constraint\n+    // functions?  present way would require a default ctor, i think...\n   };\n \n   template <class _Tp>"}, {"sha": "f85b60438c4f5a5b8acd0ef545bbdcec0a8a62d2", "filename": "libstdc++-v3/include/bits/stl_map.h", "status": "modified", "additions": 376, "deletions": 214, "changes": 590, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/224a45d026376a32418599386be3becc0ef62714/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/224a45d026376a32418599386be3becc0ef62714/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h?ref=224a45d026376a32418599386be3becc0ef62714", "patch": "@@ -58,330 +58,470 @@\n  *  You should not attempt to use it directly.\n  */\n \n-#ifndef _CPP_BITS_STL_MAP_H\n-#define _CPP_BITS_STL_MAP_H 1\n+#ifndef __GLIBCPP_INTERNAL_MAP_H\n+#define __GLIBCPP_INTERNAL_MAP_H\n \n #include <bits/concept_check.h>\n \n+// Since this entire file is within namespace std, there's no reason to\n+// waste two spaces along the left column.  Thus the leading indentation is\n+// slightly violated from here on.\n namespace std\n {\n \n /**\n- *  @brief A standard container made up of pairs (see std::pair in <utility>)\n- *         which can be retrieved based on a key.\n+ *  @brief A standard container made up of (key,value) pairs, which can be\n+ *  retrieved based on a key, in logarithmic time.\n  *\n- *  This is an associative container.  Values contained within it can be\n- *  quickly retrieved through a key element.  Example:  MyMap[\"First\"] would\n- *  return the data associated with the key \"First\".\n+ *  @ingroup Containers\n+ *  @ingroup Assoc_containers\n+ *\n+ *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n+ *  <a href=\"tables.html#66\">reversible container</a>, and an\n+ *  <a href=\"tables.html#69\">associative container</a> (using unique keys).\n+ *  For a @c map<Key,T> the key_type is Key, the mapped_type is T, and the\n+ *  value_type is std::pair<const Key,T>.\n+ *\n+ *  Maps support bidirectional iterators.\n+ *\n+ *  @if maint\n+ *  The private tree data is declared exactly the same way for map and\n+ *  multimap; the distinction is made entirely in how the tree functions are\n+ *  called (*_unique versus *_equal, same as the standard).\n+ *  @endif\n */\n-template <class _Key, class _Tp, class _Compare = less<_Key>,\n-          class _Alloc = allocator<pair<const _Key, _Tp> > >\n-class map\n+template <typename _Key, typename _Tp, typename _Compare = less<_Key>,\n+          typename _Alloc = allocator<pair<const _Key, _Tp> > >\n+  class map\n {\n   // concept requirements\n   __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n-  __glibcpp_class_requires4(_Compare, bool, _Key, _Key, _BinaryFunctionConcept);\n+  __glibcpp_class_requires4(_Compare, bool, _Key, _Key, _BinaryFunctionConcept)\n \n public:\n-  // typedefs:\n-  typedef _Key                 key_type;\n-  typedef _Tp                   data_type;\n-  typedef _Tp                   mapped_type;\n-  typedef pair<const _Key, _Tp> value_type;\n-  typedef _Compare             key_compare;\n+  typedef _Key                                          key_type;\n+  typedef _Tp                                           mapped_type;\n+  typedef pair<const _Key, _Tp>                         value_type;\n+  typedef _Compare                                      key_compare;\n \n   class value_compare\n-    : public binary_function<value_type, value_type, bool> {\n-  friend class map<_Key,_Tp,_Compare,_Alloc>;\n-  protected :\n-    _Compare comp;\n-    value_compare(_Compare __c) : comp(__c) {}\n-  public:\n-    bool operator()(const value_type& __x, const value_type& __y) const {\n-      return comp(__x.first, __y.first);\n-    }\n-  };\n+    : public binary_function<value_type, value_type, bool>\n+    {\n+      friend class map<_Key,_Tp,_Compare,_Alloc>;\n+    protected:\n+      _Compare comp;\n+      value_compare(_Compare __c) : comp(__c) {}\n+    public:\n+      bool operator()(const value_type& __x, const value_type& __y) const\n+        { return comp(__x.first, __y.first); }\n+    };\n \n private:\n+  /// @if maint  This turns a red-black tree into a [multi]map.  @endif\n   typedef _Rb_tree<key_type, value_type,\n                    _Select1st<value_type>, key_compare, _Alloc> _Rep_type;\n-  _Rep_type _M_t;  // red-black tree representing map\n+  /// @if maint  The actual tree structure.  @endif\n+  _Rep_type _M_t;\n+\n public:\n-  typedef typename _Rep_type::pointer pointer;\n-  typedef typename _Rep_type::const_pointer const_pointer;\n-  typedef typename _Rep_type::reference reference;\n-  typedef typename _Rep_type::const_reference const_reference;\n-  typedef typename _Rep_type::iterator iterator;\n-  typedef typename _Rep_type::const_iterator const_iterator;\n-  typedef typename _Rep_type::reverse_iterator reverse_iterator;\n-  typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;\n-  typedef typename _Rep_type::size_type size_type;\n-  typedef typename _Rep_type::difference_type difference_type;\n-  typedef typename _Rep_type::allocator_type allocator_type;\n-\n-  // allocation/deallocation\n-\n-  map() : _M_t(_Compare(), allocator_type()) {}\n-  explicit map(const _Compare& __comp,\n-               const allocator_type& __a = allocator_type())\n-    : _M_t(__comp, __a) {}\n-\n-  template <class _InputIterator>\n-  map(_InputIterator __first, _InputIterator __last)\n+  // many of these are specified differently in ISO, but the following are\n+  // \"functionally equivalent\"\n+  typedef typename _Rep_type::allocator_type            allocator_type;\n+  typedef typename _Rep_type::reference                 reference;\n+  typedef typename _Rep_type::const_reference           const_reference;\n+  typedef typename _Rep_type::iterator                  iterator;\n+  typedef typename _Rep_type::const_iterator            const_iterator;\n+  typedef typename _Rep_type::size_type                 size_type;\n+  typedef typename _Rep_type::difference_type           difference_type;\n+  typedef typename _Rep_type::pointer                   pointer;\n+  typedef typename _Rep_type::const_pointer             const_pointer;\n+  typedef typename _Rep_type::reverse_iterator          reverse_iterator;\n+  typedef typename _Rep_type::const_reverse_iterator    const_reverse_iterator;\n+\n+\n+  // [23.3.1.1] construct/copy/destroy\n+  // (get_allocator() is normally listed in this section, but seems to have\n+  // been accidentally omitted in the printed standard)\n+  /**\n+   *  @brief  Default constructor creates no elements.\n+  */\n+  map() : _M_t(_Compare(), allocator_type()) { }\n+\n+  // for some reason this was made a separate function\n+  /**\n+   *  @brief  Default constructor creates no elements.\n+  */\n+  explicit\n+  map(const _Compare& __comp, const allocator_type& __a = allocator_type())\n+    : _M_t(__comp, __a) { }\n+\n+  /**\n+   *  @brief  Map copy constructor.\n+   *  @param  x  A %map of identical element and allocator types.\n+   *\n+   *  The newly-created %map uses a copy of the allocation object used\n+   *  by @a x.\n+  */\n+  map(const map& __x)\n+    : _M_t(__x._M_t) { }\n+\n+  /**\n+   *  @brief  Builds a %map from a range.\n+   *  @param  first  An input iterator.\n+   *  @param  last  An input iterator.\n+   *\n+   *  Creats a %map consisting of copies of the elements from [first,last).\n+   *  This is linear in N if the range is already sorted, and NlogN\n+   *  otherwise (where N is distance(first,last)).\n+  */\n+  template <typename _InputIterator>\n+    map(_InputIterator __first, _InputIterator __last)\n     : _M_t(_Compare(), allocator_type())\n     { _M_t.insert_unique(__first, __last); }\n \n-  template <class _InputIterator>\n-  map(_InputIterator __first, _InputIterator __last, const _Compare& __comp,\n-      const allocator_type& __a = allocator_type())\n-    : _M_t(__comp, __a) { _M_t.insert_unique(__first, __last); }\n-  map(const map<_Key,_Tp,_Compare,_Alloc>& __x) : _M_t(__x._M_t) {}\n+  /**\n+   *  @brief  Builds a %map from a range.\n+   *  @param  first  An input iterator.\n+   *  @param  last  An input iterator.\n+   *  @param  comp  A comparison functor.\n+   *  @param  a  An allocator object.\n+   *\n+   *  Creats a %map consisting of copies of the elements from [first,last).\n+   *  This is linear in N if the range is already sorted, and NlogN\n+   *  otherwise (where N is distance(first,last)).\n+  */\n+  template <typename _InputIterator>\n+    map(_InputIterator __first, _InputIterator __last,\n+        const _Compare& __comp, const allocator_type& __a = allocator_type())\n+    : _M_t(__comp, __a)\n+    { _M_t.insert_unique(__first, __last); }\n \n-  map<_Key,_Tp,_Compare,_Alloc>&\n-  operator=(const map<_Key, _Tp, _Compare, _Alloc>& __x)\n+  // FIXME There is no dtor declared, but we should have something generated\n+  // by Doxygen.  I don't know what tags to add to this paragraph to make\n+  // that happen:\n+  /**\n+   *  The dtor only erases the elements, and note that if the elements\n+   *  themselves are pointers, the pointed-to memory is not touched in any\n+   *  way.  Managing the pointer is the user's responsibilty.\n+  */\n+\n+  /**\n+   *  @brief  Map assignment operator.\n+   *  @param  x  A %map of identical element and allocator types.\n+   *\n+   *  All the elements of @a x are copied, but unlike the copy constructor, the\n+   *  allocator object is not copied.\n+  */\n+  map&\n+  operator=(const map& __x)\n   {\n     _M_t = __x._M_t;\n     return *this;\n   }\n \n-  // accessors:\n-\n-  key_compare key_comp() const { return _M_t.key_comp(); }\n-  value_compare value_comp() const { return value_compare(_M_t.key_comp()); }\n-  allocator_type get_allocator() const { return _M_t.get_allocator(); }\n+  /// Get a copy of the memory allocation object.\n+  allocator_type\n+  get_allocator() const { return _M_t.get_allocator(); }\n \n+  // iterators\n   /**\n-   *  Returns a read/write iterator that points to the first pair in the map.\n+   *  Returns a read/write iterator that points to the first pair in the %map.\n    *  Iteration is done in ascending order according to the keys.\n   */\n-  iterator begin() { return _M_t.begin(); }\n+  iterator\n+  begin() { return _M_t.begin(); }\n \n   /**\n    *  Returns a read-only (constant) iterator that points to the first pair\n-   *  in the map.  Iteration is done in ascending order according to the keys.\n+   *  in the %map.  Iteration is done in ascending order according to the keys.\n   */\n-  const_iterator begin() const { return _M_t.begin(); }\n+  const_iterator\n+  begin() const { return _M_t.begin(); }\n \n   /**\n    *  Returns a read/write iterator that points one past the last pair in the\n-   *  map.  Iteration is done in ascending order according to the keys.\n+   *  %map.  Iteration is done in ascending order according to the keys.\n   */\n-  iterator end() { return _M_t.end(); }\n+  iterator\n+  end() { return _M_t.end(); }\n \n   /**\n    *  Returns a read-only (constant) iterator that points one past the last\n-   *  pair in the map.  Iteration is done in ascending order according to the\n+   *  pair in the %map.  Iteration is done in ascending order according to the\n    *  keys.\n   */\n-  const_iterator end() const { return _M_t.end(); }\n+  const_iterator\n+  end() const { return _M_t.end(); }\n \n   /**\n    *  Returns a read/write reverse iterator that points to the last pair in\n-   *  the map.  Iteration is done in descending order according to the keys.\n+   *  the %map.  Iteration is done in descending order according to the keys.\n   */\n-  reverse_iterator rbegin() { return _M_t.rbegin(); }\n+  reverse_iterator\n+  rbegin() { return _M_t.rbegin(); }\n \n   /**\n    *  Returns a read-only (constant) reverse iterator that points to the last\n-   *  pair in the map.  Iteration is done in descending order according to\n+   *  pair in the %map.  Iteration is done in descending order according to\n    *  the keys.\n   */\n-  const_reverse_iterator rbegin() const { return _M_t.rbegin(); }\n+  const_reverse_iterator\n+  rbegin() const { return _M_t.rbegin(); }\n \n   /**\n    *  Returns a read/write reverse iterator that points to one before the\n-   *  first pair in the map.  Iteration is done in descending order according\n+   *  first pair in the %map.  Iteration is done in descending order according\n    *  to the keys.\n   */\n-  reverse_iterator rend() { return _M_t.rend(); }\n+  reverse_iterator\n+  rend() { return _M_t.rend(); }\n \n   /**\n    *  Returns a read-only (constant) reverse iterator that points to one\n-   *  before the first pair in the map.  Iteration is done in descending order\n+   *  before the first pair in the %map.  Iteration is done in descending order\n    *  according to the keys.\n   */\n-  const_reverse_iterator rend() const { return _M_t.rend(); }\n+  const_reverse_iterator\n+  rend() const { return _M_t.rend(); }\n+\n+  // capacity\n+  /** Returns true if the %map is empty.  (Thus begin() would equal end().)  */\n+  bool\n+  empty() const { return _M_t.empty(); }\n+\n+  /** Returns the size of the %map.  */\n+  size_type\n+  size() const { return _M_t.size(); }\n \n-  /** Returns true if the map is empty.  (Thus begin() would equal end().)  */\n-  bool empty() const { return _M_t.empty(); }\n-  /** Returns the size of the map.  */\n-  size_type size() const { return _M_t.size(); }\n-  /** Returns the maximum size of the map.  */\n-  size_type max_size() const { return _M_t.max_size(); }\n+  /** Returns the maximum size of the %map.  */\n+  size_type\n+  max_size() const { return _M_t.max_size(); }\n \n+  // [23.3.1.2] element access\n   /**\n-   *  @brief Subscript ( [] ) access to map data.\n+   *  @brief  Subscript ( @c [] ) access to %map data.\n    *  @param  k  The key for which data should be retrieved.\n-   * \n-   *  Allows for easy lookup with the subscript ( [] ) operator.  Returns the\n+   *  @return  A reference to the data of the (key,data) %pair.\n+   *\n+   *  Allows for easy lookup with the subscript ( @c [] ) operator.  Returns\n    *  data associated with the key specified in subscript.  If the key does\n-   *  not exist a pair with that key is created with a default value, which\n+   *  not exist, a pair with that key is created using default values, which\n    *  is then returned.\n+   *\n+   *  Lookup requires logarithmic time.\n   */\n-  _Tp& operator[](const key_type& __k) {\n+  mapped_type&\n+  operator[](const key_type& __k)\n+  {\n+    // concept requirements\n+    __glibcpp_function_requires(_DefaultConstructibleConcept<mapped_type>)\n+\n     iterator __i = lower_bound(__k);\n     // __i->first is greater than or equivalent to __k.\n     if (__i == end() || key_comp()(__k, (*__i).first))\n-      __i = insert(__i, value_type(__k, _Tp()));\n+      __i = insert(__i, value_type(__k, mapped_type()));\n     return (*__i).second;\n   }\n \n-  void swap(map<_Key,_Tp,_Compare,_Alloc>& __x) { _M_t.swap(__x._M_t); }\n-\n-  // insert/erase\n+  // modifiers\n   /**\n-   *  @brief Attempts to insert a std::pair into the map.\n+   *  @brief Attempts to insert a std::pair into the %map.\n    *  @param  x  Pair to be inserted (see std::make_pair for easy creation of\n    *             pairs).\n-   *  @return  A pair of which the first element is an iterator that points\n-   *           to the possibly inserted pair, a second element of type bool\n-   *           to show if the pair was actually inserted.\n+   *  @return  A pair, of which the first element is an iterator that points\n+   *           to the possibly inserted pair, and the second is a bool that\n+   *           is true if the pair was actually inserted.\n+   *\n+   *  This function attempts to insert a (key, value) %pair into the %map.  A\n+   *  %map relies on unique keys and thus a %pair is only inserted if its first\n+   *  element (the key) is not already present in the %map.\n    *\n-   *  This function attempts to insert a (key, value) pair into the map.  A\n-   *  map relies on unique keys and thus a pair is only inserted if its first\n-   *  element (the key) is not already present in the map.\n+   *  Insertion requires logarithmic time.\n   */\n-  pair<iterator,bool> insert(const value_type& __x)\n+  pair<iterator,bool>\n+  insert(const value_type& __x)\n     { return _M_t.insert_unique(__x); }\n \n   /**\n-   *  @brief Attempts to insert a std::pair into the map.\n+   *  @brief Attempts to insert a std::pair into the %map.\n    *  @param  position  An iterator that serves as a hint as to where the\n    *                    pair should be inserted.\n    *  @param  x  Pair to be inserted (see std::make_pair for easy creation of\n    *             pairs).\n-   *  @return  An iterator that points to the inserted (key,value) pair.\n+   *  @return  An iterator that points to the element with key of @a x (may\n+   *           or may not be the %pair passed in).\n    *\n-   *  This function is not concerned about whether the insertion took place\n-   *  or not and thus does not return a boolean like the single-argument\n+   *  This function is not concerned about whether the insertion took place,\n+   *  and thus does not return a boolean like the single-argument\n    *  insert() does.  Note that the first parameter is only a hint and can\n    *  potentially improve the performance of the insertion process.  A bad\n    *  hint would cause no gains in efficiency.\n+   *\n+   *  See http://gcc.gnu.org/onlinedocs/libstdc++/23_containers/howto.html#4\n+   *  for more on \"hinting\".\n+   *\n+   *  Insertion requires logarithmic time (if the hint is not taken).\n   */\n-  iterator insert(iterator position, const value_type& __x)\n+  iterator\n+  insert(iterator position, const value_type& __x)\n     { return _M_t.insert_unique(position, __x); }\n \n   /**\n-   *  @brief A template function that attemps to insert elements from\n-   *         another range (possibly another map).\n+   *  @brief A template function that attemps to insert a range of elements.\n    *  @param  first  Iterator pointing to the start of the range to be inserted.\n    *  @param  last  Iterator pointing to the end of the range.\n+   *\n+   *  Complexity similar to that of the range constructor.\n   */\n-  template <class _InputIterator>\n-  void insert(_InputIterator __first, _InputIterator __last) {\n-    _M_t.insert_unique(__first, __last);\n-  }\n+  template <typename _InputIterator>\n+    void\n+    insert(_InputIterator __first, _InputIterator __last)\n+      { _M_t.insert_unique(__first, __last); }\n \n   /**\n-   *  @brief Erases an element from a map.\n+   *  @brief Erases an element from a %map.\n    *  @param  position  An iterator pointing to the element to be erased.\n    *\n    *  This function erases an element, pointed to by the given iterator, from\n-   *  a map.  Note that this function only erases the element, and that if\n+   *  a %map.  Note that this function only erases the element, and that if\n    *  the element is itself a pointer, the pointed-to memory is not touched\n    *  in any way.  Managing the pointer is the user's responsibilty.\n   */\n-  void erase(iterator __position) { _M_t.erase(__position); }\n+  void\n+  erase(iterator __position) { _M_t.erase(__position); }\n \n   /**\n-   *  @brief Erases an element according to the provided key.\n+   *  @brief Erases elements according to the provided key.\n    *  @param  x  Key of element to be erased.\n-   *  @return  Doc me! (Number of elements that match key? Only makes sense\n-   *           with multimap)\n+   *  @return  The number of elements erased.\n    *\n-   *  This function erases an element, located by the given key, from a map.\n+   *  This function erases all the elements located by the given key from\n+   *  a %map.\n    *  Note that this function only erases the element, and that if\n    *  the element is itself a pointer, the pointed-to memory is not touched\n    *  in any way.  Managing the pointer is the user's responsibilty.\n   */\n-  size_type erase(const key_type& __x) { return _M_t.erase(__x); }\n+  size_type\n+  erase(const key_type& __x) { return _M_t.erase(__x); }\n \n   /**\n-   *  @brief Erases a [first,last) range of elements from a map.\n+   *  @brief Erases a [first,last) range of elements from a %map.\n    *  @param  first  Iterator pointing to the start of the range to be erased.\n    *  @param  last  Iterator pointing to the end of the range to be erased.\n    *\n-   *  This function erases a sequence of elements from a map.\n+   *  This function erases a sequence of elements from a %map.\n    *  Note that this function only erases the element, and that if\n    *  the element is itself a pointer, the pointed-to memory is not touched\n    *  in any way.  Managing the pointer is the user's responsibilty.\n   */\n-  void erase(iterator __first, iterator __last)\n-    { _M_t.erase(__first, __last); }\n+  void\n+  erase(iterator __first, iterator __last) { _M_t.erase(__first, __last); }\n \n-  /** Erases all elements in a map.  Note that this function only erases\n+  /**\n+   *  @brief  Swaps data with another %map.\n+   *  @param  x  A %map of the same element and allocator types.\n+   *\n+   *  This exchanges the elements between two maps in constant time.\n+   *  (It is only swapping a pointer, an integer, and an instance of\n+   *  the @c Compare type (which itself is often stateless and empty), so it\n+   *  should be quite fast.)\n+   *  Note that the global std::swap() function is specialized such that\n+   *  std::swap(m1,m2) will feed to this function.\n+  */\n+  void\n+  swap(map& __x) { _M_t.swap(__x._M_t); }\n+\n+  /**\n+   *  Erases all elements in a %map.  Note that this function only erases\n    *  the elements, and that if the elements themselves are pointers, the\n    *  pointed-to memory is not touched in any way.  Managing the pointer is\n    *  the user's responsibilty.\n   */\n-  void clear() { _M_t.clear(); }\n+  void\n+  clear() { _M_t.clear(); }\n+\n+  // observers\n+  /**\n+   *  Returns the key comparison object out of which the %map was constructed.\n+  */\n+  key_compare\n+  key_comp() const { return _M_t.key_comp(); }\n \n-  // map operations:\n+  /**\n+   *  Returns a value comparison object, built from the key comparison\n+   *  object out of which the %map was constructed.\n+  */\n+  value_compare\n+  value_comp() const { return value_compare(_M_t.key_comp()); }\n \n+  // [23.3.1.3] map operations\n   /**\n-   *  @brief Tries to locate an element in a map.\n-   *  @param  x  Key of (key, value) pair to be located.\n+   *  @brief Tries to locate an element in a %map.\n+   *  @param  x  Key of (key, value) %pair to be located.\n    *  @return  Iterator pointing to sought-after element, or end() if not\n    *           found.\n    *\n    *  This function takes a key and tries to locate the element with which\n    *  the key matches.  If successful the function returns an iterator\n-   *  pointing to the sought after pair. If unsuccessful it returns the\n-   *  one past the end ( end() ) iterator.\n+   *  pointing to the sought after %pair.  If unsuccessful it returns the\n+   *  past-the-end ( @c end() ) iterator.\n   */\n-  iterator find(const key_type& __x) { return _M_t.find(__x); }\n+  iterator\n+  find(const key_type& __x) { return _M_t.find(__x); }\n \n   /**\n-   *  @brief Tries to locate an element in a map.\n-   *  @param  x  Key of (key, value) pair to be located.\n+   *  @brief Tries to locate an element in a %map.\n+   *  @param  x  Key of (key, value) %pair to be located.\n    *  @return  Read-only (constant) iterator pointing to sought-after\n    *           element, or end() if not found.\n    *\n    *  This function takes a key and tries to locate the element with which\n    *  the key matches.  If successful the function returns a constant iterator\n-   *  pointing to the sought after pair. If unsuccessful it returns the\n-   *  one past the end ( end() ) iterator.\n+   *  pointing to the sought after %pair. If unsuccessful it returns the\n+   *  past-the-end ( @c end() ) iterator.\n   */\n-  const_iterator find(const key_type& __x) const { return _M_t.find(__x); }\n+  const_iterator\n+  find(const key_type& __x) const { return _M_t.find(__x); }\n \n   /**\n-   *  @brief Finds the number of elements with given key.\n+   *  @brief  Finds the number of elements with given key.\n    *  @param  x  Key of (key, value) pairs to be located.\n-   *  @return Number of elements with specified key.\n+   *  @return  Number of elements with specified key.\n    *\n-   *  This function only makes sense for multimaps.\n+   *  This function only makes sense for multimaps; for map the result will\n+   *  either be 0 (not present) or 1 (present).\n   */\n-  size_type count(const key_type& __x) const {\n-    return _M_t.find(__x) == _M_t.end() ? 0 : 1;\n-  }\n+  size_type\n+  count(const key_type& __x) const\n+    { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }\n \n   /**\n    *  @brief Finds the beginning of a subsequence matching given key.\n    *  @param  x  Key of (key, value) pair to be located.\n    *  @return  Iterator pointing to first element matching given key, or\n    *           end() if not found.\n    *\n-   *  This function is useful only with std::multimap.  It returns the first\n+   *  This function is useful only with multimaps.  It returns the first\n    *  element of a subsequence of elements that matches the given key.  If\n    *  unsuccessful it returns an iterator pointing to the first element that\n    *  has a greater value than given key or end() if no such element exists.\n   */\n-  iterator lower_bound(const key_type& __x) {return _M_t.lower_bound(__x); }\n+  iterator\n+  lower_bound(const key_type& __x) { return _M_t.lower_bound(__x); }\n \n   /**\n    *  @brief Finds the beginning of a subsequence matching given key.\n    *  @param  x  Key of (key, value) pair to be located.\n    *  @return  Read-only (constant) iterator pointing to first element\n    *           matching given key, or end() if not found.\n    *\n-   *  This function is useful only with std::multimap.  It returns the first\n+   *  This function is useful only with multimaps.  It returns the first\n    *  element of a subsequence of elements that matches the given key.  If\n    *  unsuccessful the iterator will point to the next greatest element or,\n    *  if no such greater element exists, to end().\n   */\n-  const_iterator lower_bound(const key_type& __x) const {\n-    return _M_t.lower_bound(__x);\n-  }\n+  const_iterator\n+  lower_bound(const key_type& __x) const { return _M_t.lower_bound(__x); }\n \n   /**\n    *  @brief Finds the end of a subsequence matching given key.\n@@ -390,7 +530,8 @@ class map\n    *\n    *  This function only makes sense with multimaps.\n   */\n-  iterator upper_bound(const key_type& __x) {return _M_t.upper_bound(__x); }\n+  iterator\n+  upper_bound(const key_type& __x) { return _M_t.upper_bound(__x); }\n \n   /**\n    *  @brief Finds the end of a subsequence matching given key.\n@@ -400,18 +541,17 @@ class map\n    *\n    *  This function only makes sense with multimaps.\n   */\n-  const_iterator upper_bound(const key_type& __x) const {\n-    return _M_t.upper_bound(__x);\n-  }\n+  const_iterator\n+  upper_bound(const key_type& __x) const\n+    { return _M_t.upper_bound(__x); }\n \n   /**\n    *  @brief Finds a subsequence matching given key.\n    *  @param  x  Key of (key, value) pairs to be located.\n    *  @return  Pair of iterators that possibly points to the subsequence\n    *           matching given key.\n    *\n-   *  This function improves on lower_bound() and upper_bound() by giving a more\n-   *  elegant and efficient solution.  It returns a pair of which the first\n+   *  This function returns a pair of which the first\n    *  element possibly points to the first element matching the given key\n    *  and the second element possibly points to the last element matching the\n    *  given key.  If unsuccessful the first element of the returned pair will\n@@ -420,18 +560,17 @@ class map\n    *\n    *  This function only makes sense for multimaps.\n   */\n-  pair<iterator,iterator> equal_range(const key_type& __x) {\n-    return _M_t.equal_range(__x);\n-  }\n+  pair<iterator,iterator>\n+  equal_range(const key_type& __x)\n+    { return _M_t.equal_range(__x); }\n \n   /**\n    *  @brief Finds a subsequence matching given key.\n    *  @param  x  Key of (key, value) pairs to be located.\n    *  @return  Pair of read-only (constant) iterators that possibly points to\n    *           the subsequence matching given key.\n    *\n-   *  This function improves on lower_bound() and upper_bound() by giving a more\n-   *  elegant and efficient solution.  It returns a pair of which the first\n+   *  This function returns a pair of which the first\n    *  element possibly points to the first element matching the given key\n    *  and the second element possibly points to the last element matching the\n    *  given key.  If unsuccessful the first element of the returned pair will\n@@ -440,64 +579,87 @@ class map\n    *\n    *  This function only makes sense for multimaps.\n   */\n-  pair<const_iterator,const_iterator> equal_range(const key_type& __x) const {\n-    return _M_t.equal_range(__x);\n-  }\n-\n-  template <class _K1, class _T1, class _C1, class _A1>\n-  friend bool operator== (const map<_K1, _T1, _C1, _A1>&,\n-                          const map<_K1, _T1, _C1, _A1>&);\n-  template <class _K1, class _T1, class _C1, class _A1>\n-  friend bool operator< (const map<_K1, _T1, _C1, _A1>&,\n-                         const map<_K1, _T1, _C1, _A1>&);\n+  pair<const_iterator,const_iterator>\n+  equal_range(const key_type& __x) const\n+    { return _M_t.equal_range(__x); }\n+\n+  template <typename _K1, typename _T1, typename _C1, typename _A1>\n+  friend bool operator== (const map<_K1,_T1,_C1,_A1>&,\n+                          const map<_K1,_T1,_C1,_A1>&);\n+  template <typename _K1, typename _T1, typename _C1, typename _A1>\n+  friend bool operator< (const map<_K1,_T1,_C1,_A1>&,\n+                         const map<_K1,_T1,_C1,_A1>&);\n };\n \n-template <class _Key, class _Tp, class _Compare, class _Alloc>\n-inline bool operator==(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n-                       const map<_Key,_Tp,_Compare,_Alloc>& __y) {\n-  return __x._M_t == __y._M_t;\n-}\n-\n-template <class _Key, class _Tp, class _Compare, class _Alloc>\n-inline bool operator<(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n-                      const map<_Key,_Tp,_Compare,_Alloc>& __y) {\n-  return __x._M_t < __y._M_t;\n-}\n-\n-template <class _Key, class _Tp, class _Compare, class _Alloc>\n-inline bool operator!=(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n-                       const map<_Key,_Tp,_Compare,_Alloc>& __y) {\n-  return !(__x == __y);\n-}\n-\n-template <class _Key, class _Tp, class _Compare, class _Alloc>\n-inline bool operator>(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n-                      const map<_Key,_Tp,_Compare,_Alloc>& __y) {\n-  return __y < __x;\n-}\n-\n-template <class _Key, class _Tp, class _Compare, class _Alloc>\n-inline bool operator<=(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n-                       const map<_Key,_Tp,_Compare,_Alloc>& __y) {\n-  return !(__y < __x);\n-}\n-\n-template <class _Key, class _Tp, class _Compare, class _Alloc>\n-inline bool operator>=(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n-                       const map<_Key,_Tp,_Compare,_Alloc>& __y) {\n-  return !(__x < __y);\n-}\n-\n-template <class _Key, class _Tp, class _Compare, class _Alloc>\n-inline void swap(map<_Key,_Tp,_Compare,_Alloc>& __x,\n-                 map<_Key,_Tp,_Compare,_Alloc>& __y) {\n-  __x.swap(__y);\n-}\n+\n+/**\n+ *  @brief  Map equality comparison.\n+ *  @param  x  A %map.\n+ *  @param  y  A %map of the same type as @a x.\n+ *  @return  True iff the size and elements of the maps are equal.\n+ *\n+ *  This is an equivalence relation.  It is linear in the size of the\n+ *  maps.  Maps are considered equivalent if their sizes are equal,\n+ *  and if corresponding elements compare equal.\n+*/\n+template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  inline bool\n+  operator==(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n+             const map<_Key,_Tp,_Compare,_Alloc>& __y)\n+  { return __x._M_t == __y._M_t; }\n+\n+/**\n+ *  @brief  Map ordering relation.\n+ *  @param  x  A %map.\n+ *  @param  y  A %map of the same type as @a x.\n+ *  @return  True iff @a x is lexographically less than @a y.\n+ *\n+ *  This is a total ordering relation.  It is linear in the size of the\n+ *  maps.  The elements must be comparable with @c <.\n+ *\n+ *  See std::lexographical_compare() for how the determination is made.\n+*/\n+template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  inline bool\n+  operator<(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n+            const map<_Key,_Tp,_Compare,_Alloc>& __y)\n+  { return __x._M_t < __y._M_t; }\n+\n+/// Based on operator==\n+template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  inline bool\n+  operator!=(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n+             const map<_Key,_Tp,_Compare,_Alloc>& __y)\n+  { return !(__x == __y); }\n+\n+/// Based on operator<\n+template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  inline bool\n+  operator>(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n+            const map<_Key,_Tp,_Compare,_Alloc>& __y)\n+  { return __y < __x; }\n+\n+/// Based on operator<\n+template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  inline bool\n+  operator<=(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n+             const map<_Key,_Tp,_Compare,_Alloc>& __y)\n+  { return !(__y < __x); }\n+\n+/// Based on operator<\n+template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  inline bool\n+  operator>=(const map<_Key,_Tp,_Compare,_Alloc>& __x,\n+             const map<_Key,_Tp,_Compare,_Alloc>& __y)\n+  { return !(__x < __y); }\n+\n+/// See std::map::swap().\n+template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  inline void\n+  swap(map<_Key,_Tp,_Compare,_Alloc>& __x, map<_Key,_Tp,_Compare,_Alloc>& __y)\n+  { __x.swap(__y); }\n \n } // namespace std\n \n-#endif /* _CPP_BITS_STL_MAP_H */\n+#endif /* __GLIBCPP_INTERNAL_MAP_H */\n \n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "3da5d7be88cd8c84a73049b6fa256497f1e7cacc", "filename": "libstdc++-v3/include/bits/stl_multimap.h", "status": "modified", "additions": 357, "deletions": 207, "changes": 564, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/224a45d026376a32418599386be3becc0ef62714/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/224a45d026376a32418599386be3becc0ef62714/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h?ref=224a45d026376a32418599386be3becc0ef62714", "patch": "@@ -1,6 +1,6 @@\n // Multimap implementation -*- C++ -*-\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -63,293 +63,421 @@\n \n #include <bits/concept_check.h>\n \n+// Since this entire file is within namespace std, there's no reason to\n+// waste two spaces along the left column.  Thus the leading indentation is\n+// slightly violated from here on.\n namespace std\n {\n+\n // Forward declaration of operators < and ==, needed for friend declaration.\n-template <class _Key, class _Tp,\n-          class _Compare = less<_Key>,\n-          class _Alloc = allocator<pair<const _Key, _Tp> > >\n+\n+template <typename _Key, typename _Tp,\n+          typename _Compare = less<_Key>,\n+          typename _Alloc = allocator<pair<const _Key, _Tp> > >\n class multimap;\n \n-template <class _Key, class _Tp, class _Compare, class _Alloc>\n+template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n inline bool operator==(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n                        const multimap<_Key,_Tp,_Compare,_Alloc>& __y);\n \n-template <class _Key, class _Tp, class _Compare, class _Alloc>\n+template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n inline bool operator<(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n                       const multimap<_Key,_Tp,_Compare,_Alloc>& __y);\n \n /**\n- *  @brief A standard container made up of pairs (see std::pair in <utility>)\n- *         which can be retrieved based on a key.\n+ *  @brief A standard container made up of (key,value) pairs, which can be\n+ *  retrieved based on a key, in logarithmic time.\n+ *\n+ *  @ingroup Containers\n+ *  @ingroup Assoc_containers\n+ *\n+ *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n+ *  <a href=\"tables.html#66\">reversible container</a>, and an\n+ *  <a href=\"tables.html#69\">associative container</a> (using equivalent keys).\n+ *  For a @c multimap<Key,T> the key_type is Key, the mapped_type is T, and\n+ *  the value_type is std::pair<const Key,T>.\n  *\n- *  This is an associative container.  Values contained within it can be\n- *  quickly retrieved through a key element. In contrast with a map a\n- *  multimap can have multiple duplicate keys.\n+ *  Multimaps support bidirectional iterators.\n+ *\n+ *  @if maint\n+ *  The private tree data is declared exactly the same way for map and\n+ *  multimap; the distinction is made entirely in how the tree functions are\n+ *  called (*_unique versus *_equal, same as the standard).\n+ *  @endif\n */\n-template <class _Key, class _Tp, class _Compare, class _Alloc>\n-class multimap\n+template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  class multimap\n {\n   // concept requirements\n   __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n-  __glibcpp_class_requires4(_Compare, bool, _Key, _Key, _BinaryFunctionConcept);\n+  __glibcpp_class_requires4(_Compare, bool, _Key, _Key, _BinaryFunctionConcept)\n \n public:\n-\n-// typedefs:\n-\n-  typedef _Key                  key_type;\n-  typedef _Tp                   data_type;\n-  typedef _Tp                   mapped_type;\n-  typedef pair<const _Key, _Tp> value_type;\n-  typedef _Compare              key_compare;\n-\n-  class value_compare : public binary_function<value_type, value_type, bool> {\n-  friend class multimap<_Key,_Tp,_Compare,_Alloc>;\n-  protected:\n-    _Compare comp;\n-    value_compare(_Compare __c) : comp(__c) {}\n-  public:\n-    bool operator()(const value_type& __x, const value_type& __y) const {\n-      return comp(__x.first, __y.first);\n-    }\n+  typedef _Key                                          key_type;\n+  typedef _Tp                                           mapped_type;\n+  typedef pair<const _Key, _Tp>                         value_type;\n+  typedef _Compare                                      key_compare;\n+\n+  class value_compare\n+    : public binary_function<value_type, value_type, bool>\n+    {\n+      friend class multimap<_Key,_Tp,_Compare,_Alloc>;\n+    protected:\n+      _Compare comp;\n+      value_compare(_Compare __c) : comp(__c) {}\n+    public:\n+      bool operator()(const value_type& __x, const value_type& __y) const\n+        { return comp(__x.first, __y.first); }\n   };\n \n private:\n+  /// @if maint  This turns a red-black tree into a [multi]map.  @endif\n   typedef _Rb_tree<key_type, value_type,\n                   _Select1st<value_type>, key_compare, _Alloc> _Rep_type;\n-  _Rep_type _M_t;  // red-black tree representing multimap\n-public:\n-  typedef typename _Rep_type::pointer pointer;\n-  typedef typename _Rep_type::const_pointer const_pointer;\n-  typedef typename _Rep_type::reference reference;\n-  typedef typename _Rep_type::const_reference const_reference;\n-  typedef typename _Rep_type::iterator iterator;\n-  typedef typename _Rep_type::const_iterator const_iterator; \n-  typedef typename _Rep_type::reverse_iterator reverse_iterator;\n-  typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;\n-  typedef typename _Rep_type::size_type size_type;\n-  typedef typename _Rep_type::difference_type difference_type;\n-  typedef typename _Rep_type::allocator_type allocator_type;\n-\n-// allocation/deallocation\n+  /// @if maint  The actual tree structure.  @endif\n+  _Rep_type _M_t;\n \n+public:\n+  // many of these are specified differently in ISO, but the following are\n+  // \"functionally equivalent\"\n+  typedef typename _Rep_type::allocator_type            allocator_type;\n+  typedef typename _Rep_type::reference                 reference;\n+  typedef typename _Rep_type::const_reference           const_reference;\n+  typedef typename _Rep_type::iterator                  iterator;\n+  typedef typename _Rep_type::const_iterator            const_iterator;\n+  typedef typename _Rep_type::size_type                 size_type;\n+  typedef typename _Rep_type::difference_type           difference_type;\n+  typedef typename _Rep_type::pointer                   pointer;\n+  typedef typename _Rep_type::const_pointer             const_pointer;\n+  typedef typename _Rep_type::reverse_iterator          reverse_iterator;\n+  typedef typename _Rep_type::const_reverse_iterator    const_reverse_iterator;\n+\n+\n+  // [23.3.2] construct/copy/destroy\n+  // (get_allocator() is also listed in this section)\n+  /**\n+   *  @brief  Default constructor creates no elements.\n+  */\n   multimap() : _M_t(_Compare(), allocator_type()) { }\n-  explicit multimap(const _Compare& __comp,\n-                    const allocator_type& __a = allocator_type())\n+\n+  // for some reason this was made a separate function\n+  /**\n+   *  @brief  Default constructor creates no elements.\n+  */\n+  explicit\n+  multimap(const _Compare& __comp, const allocator_type& __a = allocator_type())\n     : _M_t(__comp, __a) { }\n \n-  template <class _InputIterator>\n-  multimap(_InputIterator __first, _InputIterator __last)\n-    : _M_t(_Compare(), allocator_type())\n-    { _M_t.insert_equal(__first, __last); }\n+  /**\n+   *  @brief  %Multimap copy constructor.\n+   *  @param  x  A %multimap of identical element and allocator types.\n+   *\n+   *  The newly-created %multimap uses a copy of the allocation object used\n+   *  by @a x.\n+  */\n+  multimap(const multimap& __x)\n+    : _M_t(__x._M_t) { }\n \n-  template <class _InputIterator>\n-  multimap(_InputIterator __first, _InputIterator __last,\n-           const _Compare& __comp,\n-           const allocator_type& __a = allocator_type())\n-    : _M_t(__comp, __a) { _M_t.insert_equal(__first, __last); }\n-  multimap(const multimap<_Key,_Tp,_Compare,_Alloc>& __x) : _M_t(__x._M_t) { }\n+  /**\n+   *  @brief  Builds a %multimap from a range.\n+   *  @param  first  An input iterator.\n+   *  @param  last  An input iterator.\n+   *\n+   *  Creats a %multimap consisting of copies of the elements from\n+   *  [first,last).  This is linear in N if the range is already sorted,\n+   *  and NlogN otherwise (where N is distance(first,last)).\n+  */\n+  template <typename _InputIterator>\n+    multimap(_InputIterator __first, _InputIterator __last)\n+      : _M_t(_Compare(), allocator_type())\n+      { _M_t.insert_equal(__first, __last); }\n \n-  multimap<_Key,_Tp,_Compare,_Alloc>&\n-  operator=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x) {\n+  /**\n+   *  @brief  Builds a %multimap from a range.\n+   *  @param  first  An input iterator.\n+   *  @param  last  An input iterator.\n+   *  @param  comp  A comparison functor.\n+   *  @param  a  An allocator object.\n+   *\n+   *  Creats a %multimap consisting of copies of the elements from [first,last).\n+   *  This is linear in N if the range is already sorted, and NlogN\n+   *  otherwise (where N is distance(first,last)).\n+  */\n+  template <typename _InputIterator>\n+    multimap(_InputIterator __first, _InputIterator __last,\n+             const _Compare& __comp,\n+             const allocator_type& __a = allocator_type())\n+      : _M_t(__comp, __a)\n+      { _M_t.insert_equal(__first, __last); }\n+\n+  // FIXME There is no dtor declared, but we should have something generated\n+  // by Doxygen.  I don't know what tags to add to this paragraph to make\n+  // that happen:\n+  /**\n+   *  The dtor only erases the elements, and note that if the elements\n+   *  themselves are pointers, the pointed-to memory is not touched in any\n+   *  way.  Managing the pointer is the user's responsibilty.\n+  */\n+\n+  /**\n+   *  @brief  %Multimap assignment operator.\n+   *  @param  x  A %multimap of identical element and allocator types.\n+   *\n+   *  All the elements of @a x are copied, but unlike the copy constructor, the\n+   *  allocator object is not copied.\n+  */\n+  multimap&\n+  operator=(const multimap& __x)\n+  {\n     _M_t = __x._M_t;\n-    return *this; \n+    return *this;\n   }\n \n-  // accessors:\n-\n-  key_compare key_comp() const { return _M_t.key_comp(); }\n-  value_compare value_comp() const { return value_compare(_M_t.key_comp()); }\n-  allocator_type get_allocator() const { return _M_t.get_allocator(); }\n+  /// Get a copy of the memory allocation object.\n+  allocator_type\n+  get_allocator() const { return _M_t.get_allocator(); }\n \n+  // iterators\n   /**\n    *  Returns a read/write iterator that points to the first pair in the\n-   *  multimap.  Iteration is done in ascending order according to the keys.\n+   *  %multimap.  Iteration is done in ascending order according to the keys.\n   */\n-  iterator begin() { return _M_t.begin(); }\n+  iterator\n+  begin() { return _M_t.begin(); }\n \n   /**\n    *  Returns a read-only (constant) iterator that points to the first pair\n-   *  in the multimap.  Iteration is done in ascending order according to the\n+   *  in the %multimap.  Iteration is done in ascending order according to the\n    *  keys.\n   */\n-  const_iterator begin() const { return _M_t.begin(); }\n+  const_iterator\n+  begin() const { return _M_t.begin(); }\n \n   /**\n    *  Returns a read/write iterator that points one past the last pair in the\n-   *  multimap.  Iteration is done in ascending order according to the keys.\n+   *  %multimap.  Iteration is done in ascending order according to the keys.\n   */\n-  iterator end() { return _M_t.end(); }\n+  iterator\n+  end() { return _M_t.end(); }\n \n   /**\n    *  Returns a read-only (constant) iterator that points one past the last\n-   *  pair in the multimap.  Iteration is done in ascending order according\n+   *  pair in the %multimap.  Iteration is done in ascending order according\n    *  to the keys.\n   */\n-  const_iterator end() const { return _M_t.end(); }\n+  const_iterator\n+  end() const { return _M_t.end(); }\n \n   /**\n    *  Returns a read/write reverse iterator that points to the last pair in\n-   *  the multimap.  Iteration is done in descending order according to the\n+   *  the %multimap.  Iteration is done in descending order according to the\n    *  keys.\n   */\n-  reverse_iterator rbegin() { return _M_t.rbegin(); }\n+  reverse_iterator\n+  rbegin() { return _M_t.rbegin(); }\n \n   /**\n    *  Returns a read-only (constant) reverse iterator that points to the last\n-   *  pair in the multimap.  Iteration is done in descending order according\n+   *  pair in the %multimap.  Iteration is done in descending order according\n    *  to the keys.\n   */\n-  const_reverse_iterator rbegin() const { return _M_t.rbegin(); }\n+  const_reverse_iterator\n+  rbegin() const { return _M_t.rbegin(); }\n \n   /**\n    *  Returns a read/write reverse iterator that points to one before the\n-   *  first pair in the multimap.  Iteration is done in descending order\n+   *  first pair in the %multimap.  Iteration is done in descending order\n    *  according to the keys.\n   */\n-  reverse_iterator rend() { return _M_t.rend(); }\n+  reverse_iterator\n+  rend() { return _M_t.rend(); }\n \n   /**\n    *  Returns a read-only (constant) reverse iterator that points to one\n-   *  before the first pair in the multimap.  Iteration is done in descending\n+   *  before the first pair in the %multimap.  Iteration is done in descending\n    *  order according to the keys.\n   */\n-  const_reverse_iterator rend() const { return _M_t.rend(); }\n-\n-  /** Returns true if the map is empty.  (Thus begin() would equal end().)  */\n-  bool empty() const { return _M_t.empty(); }\n+  const_reverse_iterator\n+  rend() const { return _M_t.rend(); }\n \n-  /** Returns the size of the map.  */\n-  size_type size() const { return _M_t.size(); }\n+  // capacity\n+  /** Returns true if the %multimap is empty.  */\n+  bool\n+  empty() const { return _M_t.empty(); }\n \n-  /** Returns the maximum size of the map.  */\n-  size_type max_size() const { return _M_t.max_size(); }\n+  /** Returns the size of the %multimap.  */\n+  size_type\n+  size() const { return _M_t.size(); }\n \n-  void swap(multimap<_Key,_Tp,_Compare,_Alloc>& __x) { _M_t.swap(__x._M_t); }\n+  /** Returns the maximum size of the %multimap.  */\n+  size_type\n+  max_size() const { return _M_t.max_size(); }\n \n-  // insert/erase\n+  // modifiers\n   /**\n-   *  @brief Inserts a std::pair into the multimap.\n+   *  @brief Inserts a std::pair into the %multimap.\n    *  @param  x  Pair to be inserted (see std::make_pair for easy creation of\n    *             pairs).\n    *  @return An iterator that points to the inserted (key,value) pair.\n    *\n-   *  This function inserts a (key, value) pair into the multimap.  Contrary\n-   *  to a std::map the multimap does not rely on unique keys and thus a\n+   *  This function inserts a (key, value) pair into the %multimap.  Contrary\n+   *  to a std::map the %multimap does not rely on unique keys and thus\n    *  multiple pairs with the same key can be inserted.\n+   *\n+   *  Insertion requires logarithmic time.\n   */\n-  iterator insert(const value_type& __x) { return _M_t.insert_equal(__x); }\n+  iterator\n+  insert(const value_type& __x) { return _M_t.insert_equal(__x); }\n \n   /**\n-   *  @brief Inserts a std::pair into the multimap.\n+   *  @brief Inserts a std::pair into the %multimap.\n    *  @param  position  An iterator that serves as a hint as to where the\n    *                    pair should be inserted.\n    *  @param  x  Pair to be inserted (see std::make_pair for easy creation of\n    *             pairs).\n    *  @return An iterator that points to the inserted (key,value) pair.\n    *\n-   *  This function inserts a (key, value) pair into the multimap.  Contrary\n-   *  to a std::map the multimap does not rely on unique keys and thus a\n+   *  This function inserts a (key, value) pair into the %multimap.  Contrary\n+   *  to a std::map the %multimap does not rely on unique keys and thus\n    *  multiple pairs with the same key can be inserted.\n    *  Note that the first parameter is only a hint and can potentially\n    *  improve the performance of the insertion process.  A bad hint would\n    *  cause no gains in efficiency.\n+   *\n+   *  See http://gcc.gnu.org/onlinedocs/libstdc++/23_containers/howto.html#4\n+   *  for more on \"hinting\".\n+   *\n+   *  Insertion requires logarithmic time (if the hint is not taken).\n   */\n-  iterator insert(iterator __position, const value_type& __x) {\n-    return _M_t.insert_equal(__position, __x);\n-  }\n+  iterator\n+  insert(iterator __position, const value_type& __x)\n+    { return _M_t.insert_equal(__position, __x); }\n \n   /**\n-   *  @brief A template function that attemps to insert elements from\n-   *         another range (possibly another multimap or standard container).\n-   *  @param  first  Iterator pointing to the start of the range to be\n-   *                 inserted.\n-   *  @param  last  Iterator pointing to the end of the range to be inserted.\n+   *  @brief A template function that attemps to insert a range of elements.\n+   *  @param  first  Iterator pointing to the start of the range to be inserted.\n+   *  @param  last  Iterator pointing to the end of the range.\n+   *\n+   *  Complexity similar to that of the range constructor.\n   */\n-  template <class _InputIterator>\n-  void insert(_InputIterator __first, _InputIterator __last) {\n-    _M_t.insert_equal(__first, __last);\n-  }\n+  template <typename _InputIterator>\n+    void\n+    insert(_InputIterator __first, _InputIterator __last)\n+      { _M_t.insert_equal(__first, __last); }\n \n   /**\n-   *  @brief Erases an element from a multimap.\n+   *  @brief Erases an element from a %multimap.\n    *  @param  position  An iterator pointing to the element to be erased.\n    *\n    *  This function erases an element, pointed to by the given iterator, from\n-   *  a mutlimap.  Note that this function only erases the element, and that\n+   *  a %multimap.  Note that this function only erases the element, and that\n    *  if the element is itself a pointer, the pointed-to memory is not\n    *  touched in any way.  Managing the pointer is the user's responsibilty.\n   */\n-  void erase(iterator __position) { _M_t.erase(__position); }\n+  void\n+  erase(iterator __position) { _M_t.erase(__position); }\n \n   /**\n-   *  @brief Erases an element according to the provided key.\n+   *  @brief Erases elements according to the provided key.\n    *  @param  x  Key of element to be erased.\n-   *  @return  Doc me! (Number of elements erased?)\n+   *  @return  The number of elements erased.\n    *\n-   *  This function erases all elements, located by the given key, from a\n-   *  multimap.\n+   *  This function erases all elements located by the given key from a\n+   *  %multimap.\n    *  Note that this function only erases the element, and that if\n    *  the element is itself a pointer, the pointed-to memory is not touched\n    *  in any way.  Managing the pointer is the user's responsibilty.\n   */\n-  size_type erase(const key_type& __x) { return _M_t.erase(__x); }\n+  size_type\n+  erase(const key_type& __x) { return _M_t.erase(__x); }\n \n   /**\n-   *  @brief Erases a [first,last) range of elements from a multimap.\n+   *  @brief Erases a [first,last) range of elements from a %multimap.\n    *  @param  first  Iterator pointing to the start of the range to be erased.\n    *  @param  last  Iterator pointing to the end of the range to be erased.\n    *\n-   *  This function erases a sequence of elements from a multimap.\n+   *  This function erases a sequence of elements from a %multimap.\n    *  Note that this function only erases the elements, and that if\n    *  the elements themselves are pointers, the pointed-to memory is not\n    *  touched in any way.  Managing the pointer is the user's responsibilty.\n   */\n-  void erase(iterator __first, iterator __last)\n-    { _M_t.erase(__first, __last); }\n+  void\n+  erase(iterator __first, iterator __last) { _M_t.erase(__first, __last); }\n+\n+  /**\n+   *  @brief  Swaps data with another %multimap.\n+   *  @param  x  A %multimap of the same element and allocator types.\n+   *\n+   *  This exchanges the elements between two multimaps in constant time.\n+   *  (It is only swapping a pointer, an integer, and an instance of\n+   *  the @c Compare type (which itself is often stateless and empty), so it\n+   *  should be quite fast.)\n+   *  Note that the global std::swap() function is specialized such that\n+   *  std::swap(m1,m2) will feed to this function.\n+  */\n+  void\n+  swap(multimap& __x) { _M_t.swap(__x._M_t); }\n \n-  /** Erases all elements in a multimap.  Note that this function only erases\n+  /**\n+   *  Erases all elements in a %multimap.  Note that this function only erases\n    *  the elements, and that if the elements themselves are pointers, the\n    *  pointed-to memory is not touched in any way.  Managing the pointer is\n    *  the user's responsibilty.\n   */\n-  void clear() { _M_t.clear(); }\n+  void\n+  clear() { _M_t.clear(); }\n+\n+  // observers\n+  /**\n+   *  Returns the key comparison object out of which the %multimap\n+   *  was constructed.\n+  */\n+  key_compare\n+  key_comp() const { return _M_t.key_comp(); }\n \n-  // multimap operations:\n+  /**\n+   *  Returns a value comparison object, built from the key comparison\n+   *  object out of which the %multimap was constructed.\n+  */\n+  value_compare\n+  value_comp() const { return value_compare(_M_t.key_comp()); }\n \n+  // multimap operations\n   /**\n-   *  @brief Tries to locate an element in a multimap.\n+   *  @brief Tries to locate an element in a %multimap.\n    *  @param  x  Key of (key, value) pair to be located.\n-   *  @return  Iterator pointing to sought-after (first matching?) element,\n+   *  @return  Iterator pointing to sought-after element,\n    *           or end() if not found.\n    *\n    *  This function takes a key and tries to locate the element with which\n    *  the key matches.  If successful the function returns an iterator\n-   *  pointing to the sought after pair. If unsuccessful it returns the\n-   *  one past the end ( end() ) iterator.\n+   *  pointing to the sought after %pair.  If unsuccessful it returns the\n+   *  past-the-end ( @c end() ) iterator.\n   */\n-  iterator find(const key_type& __x) { return _M_t.find(__x); }\n+  iterator\n+  find(const key_type& __x) { return _M_t.find(__x); }\n \n   /**\n-   *  @brief Tries to locate an element in a multimap.\n+   *  @brief Tries to locate an element in a %multimap.\n    *  @param  x  Key of (key, value) pair to be located.\n-   *  @return  Read-only (constant) iterator pointing to sought-after (first\n-   *           matching?) element, or end() if not found.\n+   *  @return  Read-only (constant) iterator pointing to sought-after\n+   *           element, or end() if not found.\n    *\n    *  This function takes a key and tries to locate the element with which\n    *  the key matches.  If successful the function returns a constant iterator\n-   *  pointing to the sought after pair. If unsuccessful it returns the\n-   *  one past the end ( end() ) iterator.\n+   *  pointing to the sought after %pair.  If unsuccessful it returns the\n+   *  past-the-end ( @c end() ) iterator.\n   */\n-  const_iterator find(const key_type& __x) const { return _M_t.find(__x); }\n+  const_iterator\n+  find(const key_type& __x) const { return _M_t.find(__x); }\n \n   /**\n    *  @brief Finds the number of elements with given key.\n    *  @param  x  Key of (key, value) pairs to be located.\n    *  @return Number of elements with specified key.\n   */\n-  size_type count(const key_type& __x) const { return _M_t.count(__x); }\n+  size_type\n+  count(const key_type& __x) const { return _M_t.count(__x); }\n \n   /**\n    *  @brief Finds the beginning of a subsequence matching given key.\n@@ -362,7 +490,8 @@ class multimap\n    *  pointing to the first element that has a greater value than given key\n    *  or end() if no such element exists.\n   */\n-  iterator lower_bound(const key_type& __x) {return _M_t.lower_bound(__x); }\n+  iterator\n+  lower_bound(const key_type& __x) { return _M_t.lower_bound(__x); }\n \n   /**\n    *  @brief Finds the beginning of a subsequence matching given key.\n@@ -375,117 +504,138 @@ class multimap\n    *  to the next greatest element or, if no such greater element exists, to\n    *  end().\n   */\n-  const_iterator lower_bound(const key_type& __x) const {\n-    return _M_t.lower_bound(__x);\n-  }\n+  const_iterator\n+  lower_bound(const key_type& __x) const { return _M_t.lower_bound(__x); }\n \n   /**\n    *  @brief Finds the end of a subsequence matching given key.\n    *  @param  x  Key of (key, value) pair to be located.\n    *  @return Iterator pointing to last element matching given key.\n   */\n-  iterator upper_bound(const key_type& __x) {return _M_t.upper_bound(__x); }\n+  iterator\n+  upper_bound(const key_type& __x) { return _M_t.upper_bound(__x); }\n \n   /**\n    *  @brief Finds the end of a subsequence matching given key.\n    *  @param  x  Key of (key, value) pair to be located.\n    *  @return  Read-only (constant) iterator pointing to last element matching\n    *           given key.\n   */\n-  const_iterator upper_bound(const key_type& __x) const {\n-    return _M_t.upper_bound(__x);\n-  }\n+  const_iterator\n+  upper_bound(const key_type& __x) const { return _M_t.upper_bound(__x); }\n \n   /**\n    *  @brief Finds a subsequence matching given key.\n    *  @param  x  Key of (key, value) pairs to be located.\n    *  @return  Pair of iterators that possibly points to the subsequence\n    *           matching given key.\n    *\n-   *  This function improves on lower_bound() and upper_bound() by giving a more\n-   *  elegant and efficient solution.  It returns a pair of which the first\n+   *  This function returns a pair of which the first\n    *  element possibly points to the first element matching the given key\n    *  and the second element possibly points to the last element matching the\n    *  given key.  If unsuccessful the first element of the returned pair will\n    *  contain an iterator pointing to the next greatest element or, if no such\n    *  greater element exists, to end().\n   */\n-  pair<iterator,iterator> equal_range(const key_type& __x) {\n-    return _M_t.equal_range(__x);\n-  }\n+  pair<iterator,iterator>\n+  equal_range(const key_type& __x) { return _M_t.equal_range(__x); }\n \n   /**\n    *  @brief Finds a subsequence matching given key.\n    *  @param  x  Key of (key, value) pairs to be located.\n    *  @return  Pair of read-only (constant) iterators that possibly points to\n    *           the subsequence matching given key.\n    *\n-   *  This function improves on lower_bound() and upper_bound() by giving a more\n-   *  elegant and efficient solution.  It returns a pair of which the first\n+   *  This function returns a pair of which the first\n    *  element possibly points to the first element matching the given key\n    *  and the second element possibly points to the last element matching the\n    *  given key.  If unsuccessful the first element of the returned pair will\n    *  contain an iterator pointing to the next greatest element or, if no such\n    *  a greater element exists, to end().\n   */\n-  pair<const_iterator,const_iterator> equal_range(const key_type& __x) const {\n-    return _M_t.equal_range(__x);\n-  }\n-\n-  template <class _K1, class _T1, class _C1, class _A1>\n-  friend bool operator== (const multimap<_K1, _T1, _C1, _A1>&,\n-                          const multimap<_K1, _T1, _C1, _A1>&);\n-  template <class _K1, class _T1, class _C1, class _A1>\n-  friend bool operator< (const multimap<_K1, _T1, _C1, _A1>&,\n-                         const multimap<_K1, _T1, _C1, _A1>&);\n+  pair<const_iterator,const_iterator>\n+  equal_range(const key_type& __x) const { return _M_t.equal_range(__x); }\n+\n+  template <typename _K1, typename _T1, typename _C1, typename _A1>\n+  friend bool operator== (const multimap<_K1,_T1,_C1,_A1>&,\n+                          const multimap<_K1,_T1,_C1,_A1>&);\n+  template <typename _K1, typename _T1, typename _C1, typename _A1>\n+  friend bool operator< (const multimap<_K1,_T1,_C1,_A1>&,\n+                         const multimap<_K1,_T1,_C1,_A1>&);\n };\n \n-template <class _Key, class _Tp, class _Compare, class _Alloc>\n-inline bool operator==(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n-                       const multimap<_Key,_Tp,_Compare,_Alloc>& __y) {\n-  return __x._M_t == __y._M_t;\n-}\n-\n-template <class _Key, class _Tp, class _Compare, class _Alloc>\n-inline bool operator<(const multimap<_Key,_Tp,_Compare,_Alloc>& __x, \n-                      const multimap<_Key,_Tp,_Compare,_Alloc>& __y) {\n-  return __x._M_t < __y._M_t;\n-}\n-\n-template <class _Key, class _Tp, class _Compare, class _Alloc>\n-inline bool operator!=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x, \n-                       const multimap<_Key,_Tp,_Compare,_Alloc>& __y) {\n-  return !(__x == __y);\n-}\n-\n-template <class _Key, class _Tp, class _Compare, class _Alloc>\n-inline bool operator>(const multimap<_Key,_Tp,_Compare,_Alloc>& __x, \n-                      const multimap<_Key,_Tp,_Compare,_Alloc>& __y) {\n-  return __y < __x;\n-}\n-\n-template <class _Key, class _Tp, class _Compare, class _Alloc>\n-inline bool operator<=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x, \n-                       const multimap<_Key,_Tp,_Compare,_Alloc>& __y) {\n-  return !(__y < __x);\n-}\n-\n-template <class _Key, class _Tp, class _Compare, class _Alloc>\n-inline bool operator>=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x, \n-                       const multimap<_Key,_Tp,_Compare,_Alloc>& __y) {\n-  return !(__x < __y);\n-}\n-\n-template <class _Key, class _Tp, class _Compare, class _Alloc>\n-inline void swap(multimap<_Key,_Tp,_Compare,_Alloc>& __x, \n-                 multimap<_Key,_Tp,_Compare,_Alloc>& __y) {\n-  __x.swap(__y);\n-}\n+\n+/**\n+ *  @brief  Multimap equality comparison.\n+ *  @param  x  A %multimap.\n+ *  @param  y  A %multimap of the same type as @a x.\n+ *  @return  True iff the size and elements of the maps are equal.\n+ *\n+ *  This is an equivalence relation.  It is linear in the size of the\n+ *  multimaps.  Multimaps are considered equivalent if their sizes are equal,\n+ *  and if corresponding elements compare equal.\n+*/\n+template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  inline bool\n+  operator==(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n+             const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n+  {\n+    return __x._M_t == __y._M_t;\n+  }\n+\n+/**\n+ *  @brief  Multimap ordering relation.\n+ *  @param  x  A %multimap.\n+ *  @param  y  A %multimap of the same type as @a x.\n+ *  @return  True iff @a x is lexographically less than @a y.\n+ *\n+ *  This is a total ordering relation.  It is linear in the size of the\n+ *  multimaps.  The elements must be comparable with @c <.\n+ *\n+ *  See std::lexographical_compare() for how the determination is made.\n+*/\n+template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  inline bool\n+  operator<(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n+            const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n+  { return __x._M_t < __y._M_t; }\n+\n+/// Based on operator==\n+template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  inline bool\n+  operator!=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n+             const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n+  { return !(__x == __y); }\n+\n+/// Based on operator<\n+template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  inline bool\n+  operator>(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n+            const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n+  { return __y < __x; }\n+\n+/// Based on operator<\n+template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  inline bool\n+  operator<=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n+             const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n+  { return !(__y < __x); }\n+\n+/// Based on operator<\n+template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  inline bool\n+  operator>=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n+             const multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n+  { return !(__x < __y); }\n+\n+/// See std::multimap::swap().\n+template <typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n+  inline void\n+  swap(multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n+       multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n+  { __x.swap(__y); }\n \n } // namespace std\n \n #endif /* __GLIBCPP_INTERNAL_MULTIMAP_H */\n \n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "f8a2714c3722da9ee630a893b340d5a3d4419aa6", "filename": "libstdc++-v3/include/bits/stl_queue.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/224a45d026376a32418599386be3becc0ef62714/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/224a45d026376a32418599386be3becc0ef62714/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h?ref=224a45d026376a32418599386be3becc0ef62714", "patch": "@@ -75,10 +75,10 @@ template <typename _Tp, typename _Sequence = deque<_Tp> >\n class queue;\n \n template <typename _Tp, typename _Seq>\n-inline bool operator==(const queue<_Tp, _Seq>&, const queue<_Tp, _Seq>&);\n+inline bool operator==(const queue<_Tp,_Seq>&, const queue<_Tp,_Seq>&);\n \n template <typename _Tp, typename _Seq>\n-inline bool operator<(const queue<_Tp, _Seq>&, const queue<_Tp, _Seq>&);\n+inline bool operator<(const queue<_Tp,_Seq>&, const queue<_Tp,_Seq>&);\n \n \n /**\n@@ -291,8 +291,8 @@ template <typename _Tp, typename _Sequence>\n  *  defining a strict weak ordering.\n  *\n  *  Members not found in \"normal\" containers are @c container_type,\n- *  which is a typedef for the second Sequence parameter, and @c push and\n- *  @c pop, which are standard %queue/FIFO operations.\n+ *  which is a typedef for the second Sequence parameter, and @c push,\n+ *  @c pop, and @c top, which are standard %queue/FIFO operations.\n  *\n  *  @note  No equality/comparison operators are provided for %priority_queue.\n  *"}, {"sha": "fb4af7605c0a65429cc58b7c1fb67b092681c310", "filename": "libstdc++-v3/include/bits/stl_stack.h", "status": "modified", "additions": 158, "deletions": 64, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/224a45d026376a32418599386be3becc0ef62714/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/224a45d026376a32418599386be3becc0ef62714/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_stack.h?ref=224a45d026376a32418599386be3becc0ef62714", "patch": "@@ -1,6 +1,6 @@\n // Stack implementation -*- C++ -*-\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -63,98 +63,192 @@\n \n #include <bits/concept_check.h>\n \n+// Since this entire file is within namespace std, there's no reason to\n+// waste two spaces along the left column.  Thus the leading indentation is\n+// slightly violated from here on.\n namespace std\n {\n \n // Forward declarations of operators == and <, needed for friend declaration.\n \n-template <class _Tp, \n-          class _Sequence = deque<_Tp> >\n+template <typename _Tp, typename _Sequence = deque<_Tp> >\n class stack;\n \n-template <class _Tp, class _Seq>\n-bool operator==(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y);\n+template <typename _Tp, typename _Seq>\n+inline bool operator==(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y);\n \n-template <class _Tp, class _Seq>\n-bool operator<(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y);\n+template <typename _Tp, typename _Seq>\n+inline bool operator<(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y);\n \n \n-template <class _Tp, class _Sequence>\n-class stack\n+/**\n+ *  @brief  A standard container giving FILO behavior.\n+ *\n+ *  @ingroup Containers\n+ *  @ingroup Sequences\n+ *\n+ *  Meets many of the requirements of a <a href=\"tables.html#65\">container</a>,\n+ *  but does not define anything to do with iterators.  Very few of the\n+ *  other standard container interfaces are defined.\n+ *\n+ *  This is not a true container, but an @e adaptor.  It holds another\n+ *  container, and provides a wrapper interface to that container.  The\n+ *  wrapper is what enforces strict first-in-last-out %stack behavior.\n+ *\n+ *  The second template parameter defines the type of the underlying\n+ *  sequence/container.  It defaults to std::deque, but it can be any type\n+ *  that supports @c back, @c push_back, and @c pop_front, such as\n+ *  std::list, std::vector, or an appropriate user-defined type.\n+ *\n+ *  Members not found in \"normal\" containers are @c container_type,\n+ *  which is a typedef for the second Sequence parameter, and @c push,\n+ *  @c pop, and @c top, which are standard %stack/FILO operations.\n+*/\n+template <typename _Tp, typename _Sequence>\n+  class stack\n {\n   // concept requirements\n+  typedef typename _Sequence::value_type _Sequence_value_type;\n   __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n   __glibcpp_class_requires(_Sequence, _BackInsertionSequenceConcept)\n-  typedef typename _Sequence::value_type _Sequence_value_type;\n-  __glibcpp_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept);\n+  __glibcpp_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept)\n \n-  template <class _Tp1, class _Seq1>\n+  template <typename _Tp1, typename _Seq1>\n   friend bool operator== (const stack<_Tp1, _Seq1>&,\n                           const stack<_Tp1, _Seq1>&);\n-  template <class _Tp1, class _Seq1>\n+  template <typename _Tp1, typename _Seq1>\n   friend bool operator< (const stack<_Tp1, _Seq1>&,\n                          const stack<_Tp1, _Seq1>&);\n+\n public:\n-  typedef typename _Sequence::value_type      value_type;\n-  typedef typename _Sequence::size_type       size_type;\n-  typedef          _Sequence                  container_type;\n+  typedef typename _Sequence::value_type                value_type;\n+  typedef typename _Sequence::reference                 reference;\n+  typedef typename _Sequence::const_reference           const_reference;\n+  typedef typename _Sequence::size_type                 size_type;\n+  typedef          _Sequence                            container_type;\n \n-  typedef typename _Sequence::reference       reference;\n-  typedef typename _Sequence::const_reference const_reference;\n protected:\n+  //  See queue::c for notes on this name.\n   _Sequence c;\n+\n public:\n-  stack() : c() {}\n-  explicit stack(const _Sequence& __s) : c(__s) {}\n-\n-  bool empty() const { return c.empty(); }\n-  size_type size() const { return c.size(); }\n-  reference top() { return c.back(); }\n-  const_reference top() const { return c.back(); }\n-  void push(const value_type& __x) { c.push_back(__x); }\n-  void pop() { c.pop_back(); }\n+  // XXX removed old def ctor, added def arg to this one to match 14882\n+  /**\n+   *  @brief  Default constructor creates no elements.\n+  */\n+  explicit\n+  stack(const _Sequence& __c = _Sequence())\n+  : c(__c) {}\n+\n+  /**\n+   *  Returns true if the %stack is empty.\n+  */\n+  bool\n+  empty() const { return c.empty(); }\n+\n+  /**  Returns the number of elements in the %stack.  */\n+  size_type\n+  size() const { return c.size(); }\n+\n+  /**\n+   *  Returns a read/write reference to the data at the first element of the\n+   *  %stack.\n+  */\n+  reference\n+  top() { return c.back(); }\n+\n+  /**\n+   *  Returns a read-only (constant) reference to the data at the first\n+   *  element of the %stack.\n+  */\n+  const_reference\n+  top() const { return c.back(); }\n+\n+  /**\n+   *  @brief  Add data to the top of the %stack.\n+   *  @param  x  Data to be added.\n+   *\n+   *  This is a typical %stack operation.  The function creates an element at\n+   *  the top of the %stack and assigns the given data to it.\n+   *  The time complexity of the operation depends on the underlying\n+   *  sequence.\n+  */\n+  void\n+  push(const value_type& __x) { c.push_back(__x); }\n+\n+  /**\n+   *  @brief  Removes first element.\n+   *\n+   *  This is a typical %stack operation.  It shrinks the %stack by one.\n+   *  The time complexity of the operation depends on the underlying\n+   *  sequence.\n+   *\n+   *  Note that no data is returned, and if the first element's data is\n+   *  needed, it should be retrieved before pop() is called.\n+  */\n+  void\n+  pop() { c.pop_back(); }\n };\n \n-template <class _Tp, class _Seq>\n-bool operator==(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n-{\n-  return __x.c == __y.c;\n-}\n \n-template <class _Tp, class _Seq>\n-bool operator<(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n-{\n-  return __x.c < __y.c;\n-}\n-\n-template <class _Tp, class _Seq>\n-bool operator!=(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n-{\n-  return !(__x == __y);\n-}\n-\n-template <class _Tp, class _Seq>\n-bool operator>(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n-{\n-  return __y < __x;\n-}\n-\n-template <class _Tp, class _Seq>\n-bool operator<=(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n-{\n-  return !(__y < __x);\n-}\n-\n-template <class _Tp, class _Seq>\n-bool operator>=(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n-{\n-  return !(__x < __y);\n-}\n+/**\n+ *  @brief  Stack equality comparison.\n+ *  @param  x  A %stack.\n+ *  @param  y  A %stack of the same type as @a x.\n+ *  @return  True iff the size and elements of the stacks are equal.\n+ *\n+ *  This is an equivalence relation.  Complexity and semantics depend on the\n+ *  underlying sequence type, but the expected rules are:  this relation is\n+ *  linear in the size of the sequences, and stacks are considered equivalent\n+ *  if their sequences compare equal.\n+*/\n+template <typename _Tp, typename _Seq>\n+  inline bool\n+  operator==(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n+  { return __x.c == __y.c; }\n+\n+/**\n+ *  @brief  Stack ordering relation.\n+ *  @param  x  A %stack.\n+ *  @param  y  A %stack of the same type as @a x.\n+ *  @return  True iff @a x is lexographically less than @a y.\n+ *\n+ *  This is an total ordering relation.  Complexity and semantics depend on the\n+ *  underlying sequence type, but the expected rules are:  this relation is\n+ *  linear in the size of the sequences, the elements must be comparable\n+ *  with @c <, and std::lexographical_compare() is usually used to make the\n+ *  determination.\n+*/\n+template <typename _Tp, typename _Seq>\n+  inline bool\n+  operator<(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n+  { return __x.c < __y.c; }\n+\n+/// Based on operator==\n+template <typename _Tp, typename _Seq>\n+  inline bool\n+  operator!=(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n+  { return !(__x == __y); }\n+\n+/// Based on operator<\n+template <typename _Tp, typename _Seq>\n+  inline bool\n+  operator>(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n+  { return __y < __x; }\n+\n+/// Based on operator<\n+template <typename _Tp, typename _Seq>\n+  inline bool\n+  operator<=(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n+  { return !(__y < __x); }\n+\n+/// Based on operator<\n+template <typename _Tp, typename _Seq>\n+  inline bool\n+  operator>=(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n+  { return !(__x < __y); }\n \n } // namespace std\n \n #endif /* __GLIBCPP_INTERNAL_STACK_H */\n \n-// Local Variables:\n-// mode:C++\n-// End:"}]}