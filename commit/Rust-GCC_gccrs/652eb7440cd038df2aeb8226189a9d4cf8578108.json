{"sha": "652eb7440cd038df2aeb8226189a9d4cf8578108", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjUyZWI3NDQwY2QwMzhkZjJhZWI4MjI2MTg5YTlkNGNmODU3ODEwOA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2004-07-08T16:57:48Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2004-07-08T16:57:48Z"}, "message": "expr.h (FUNCTION_ARG_PARTIAL_NREGS): Default to 0.\n\n* expr.h (FUNCTION_ARG_PARTIAL_NREGS): Default to 0.\n(FUNCTION_ARG_PASS_BY_REFERENCE): Likewise.\n(FUNCTION_ARG_CALLEE_COPIES): Likewise.\n* calls.c: Remove ifdefs of macros above.\n* functions.c: Likewise.\n* expr.c: Likewise.\n\nFrom-SVN: r84300", "tree": {"sha": "c07d0ed79a9f0db3ec09e586d2e9f1ee07f9160c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c07d0ed79a9f0db3ec09e586d2e9f1ee07f9160c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/652eb7440cd038df2aeb8226189a9d4cf8578108", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/652eb7440cd038df2aeb8226189a9d4cf8578108", "html_url": "https://github.com/Rust-GCC/gccrs/commit/652eb7440cd038df2aeb8226189a9d4cf8578108", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/652eb7440cd038df2aeb8226189a9d4cf8578108/comments", "author": null, "committer": null, "parents": [{"sha": "50711d27cf77c6e1b43c1360439d349a1987e4b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50711d27cf77c6e1b43c1360439d349a1987e4b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50711d27cf77c6e1b43c1360439d349a1987e4b7"}], "stats": {"total": 51, "additions": 23, "deletions": 28}, "files": [{"sha": "e2cdc6693e1d944795e5471fe124286debf79f1a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/652eb7440cd038df2aeb8226189a9d4cf8578108/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/652eb7440cd038df2aeb8226189a9d4cf8578108/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=652eb7440cd038df2aeb8226189a9d4cf8578108", "patch": "@@ -1,3 +1,12 @@\n+2004-07-08  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* expr.h (FUNCTION_ARG_PARTIAL_NREGS): Default to 0.\n+\t(FUNCTION_ARG_PASS_BY_REFERENCE): Likewise.\n+\t(FUNCTION_ARG_CALLEE_COPIES): Likewise.\n+\t* calls.c: Remove ifdefs of macros above.\n+\t* functions.c: Likewise.\n+\t* expr.c: Likewise.\n+\n 2004-07-08  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* config/sparc/sparc.md (UNSPECV_GOTO_V9): Delete."}, {"sha": "d46b653eb527725bbca8c76e58711ce0ad409511", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/652eb7440cd038df2aeb8226189a9d4cf8578108/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/652eb7440cd038df2aeb8226189a9d4cf8578108/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=652eb7440cd038df2aeb8226189a9d4cf8578108", "patch": "@@ -975,24 +975,20 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n       /* See if this argument should be passed by invisible reference.  */\n       if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE (type))\n \t  || TREE_ADDRESSABLE (type)\n-#ifdef FUNCTION_ARG_PASS_BY_REFERENCE\n \t  || FUNCTION_ARG_PASS_BY_REFERENCE (*args_so_far, TYPE_MODE (type),\n \t\t\t\t\t     type, argpos < n_named_args)\n-#endif\n \t  )\n \t{\n \t  /* If we're compiling a thunk, pass through invisible\n              references instead of making a copy.  */\n \t  if (call_from_thunk_p\n-#ifdef FUNCTION_ARG_CALLEE_COPIES\n \t      || (FUNCTION_ARG_CALLEE_COPIES (*args_so_far, TYPE_MODE (type),\n \t\t\t\t\t     type, argpos < n_named_args)\n \t\t  /* If it's in a register, we must make a copy of it too.  */\n \t\t  /* ??? Is this a sufficient test?  Is there a better one? */\n \t\t  && !(TREE_CODE (args[i].tree_value) == VAR_DECL\n \t\t       && REG_P (DECL_RTL (args[i].tree_value)))\n \t\t  && ! TREE_ADDRESSABLE (type))\n-#endif\n \t      )\n \t    {\n \t      /* C++ uses a TARGET_EXPR to indicate that we want to make a\n@@ -1095,12 +1091,10 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n       args[i].tail_call_reg = args[i].reg;\n #endif\n \n-#ifdef FUNCTION_ARG_PARTIAL_NREGS\n       if (args[i].reg)\n \targs[i].partial\n \t  = FUNCTION_ARG_PARTIAL_NREGS (*args_so_far, mode, type,\n \t\t\t\t\targpos < n_named_args);\n-#endif\n \n       args[i].pass_on_stack = MUST_PASS_IN_STACK (mode, type);\n \n@@ -3525,10 +3519,8 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n       argvec[count].partial = 0;\n \n       argvec[count].reg = FUNCTION_ARG (args_so_far, Pmode, NULL_TREE, 1);\n-#ifdef FUNCTION_ARG_PARTIAL_NREGS\n       if (FUNCTION_ARG_PARTIAL_NREGS (args_so_far, Pmode, NULL_TREE, 1))\n \tabort ();\n-#endif\n \n       locate_and_pad_parm (Pmode, NULL_TREE,\n #ifdef STACK_PARMS_IN_REG_PARM_AREA\n@@ -3566,16 +3558,11 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t  && ! (CONSTANT_P (val) && LEGITIMATE_CONSTANT_P (val)))\n \tval = force_operand (val, NULL_RTX);\n \n-#ifdef FUNCTION_ARG_PASS_BY_REFERENCE\n       if (FUNCTION_ARG_PASS_BY_REFERENCE (args_so_far, mode, NULL_TREE, 1))\n \t{\n \t  rtx slot;\n-\t  int must_copy = 1\n-#ifdef FUNCTION_ARG_CALLEE_COPIES\n-\t    && ! FUNCTION_ARG_CALLEE_COPIES (args_so_far, mode,\n-\t\t\t\t\t     NULL_TREE, 1)\n-#endif\n-\t    ;\n+\t  int must_copy = ! FUNCTION_ARG_CALLEE_COPIES (args_so_far, mode,\n+\t\t\t\t\t\t\tNULL_TREE, 1);\n \n \t  /* loop.c won't look at CALL_INSN_FUNCTION_USAGE of const/pure\n \t     functions, so we have to pretend this isn't such a function.  */\n@@ -3627,19 +3614,14 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t  mode = Pmode;\n \t  val = force_operand (XEXP (slot, 0), NULL_RTX);\n \t}\n-#endif\n \n       argvec[count].value = val;\n       argvec[count].mode = mode;\n \n       argvec[count].reg = FUNCTION_ARG (args_so_far, mode, NULL_TREE, 1);\n \n-#ifdef FUNCTION_ARG_PARTIAL_NREGS\n       argvec[count].partial\n \t= FUNCTION_ARG_PARTIAL_NREGS (args_so_far, mode, NULL_TREE, 1);\n-#else\n-      argvec[count].partial = 0;\n-#endif\n \n       locate_and_pad_parm (mode, NULL_TREE,\n #ifdef STACK_PARMS_IN_REG_PARM_AREA"}, {"sha": "abe6d7cc936fc2cbee33f8e1ddb5e00603f3db9a", "filename": "gcc/expr.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/652eb7440cd038df2aeb8226189a9d4cf8578108/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/652eb7440cd038df2aeb8226189a9d4cf8578108/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=652eb7440cd038df2aeb8226189a9d4cf8578108", "patch": "@@ -1424,11 +1424,9 @@ block_move_libcall_safe_for_call_parm (void)\n \trtx tmp = FUNCTION_ARG (args_so_far, mode, NULL_TREE, 1);\n \tif (!tmp || !REG_P (tmp))\n \t  return false;\n-#ifdef FUNCTION_ARG_PARTIAL_NREGS\n \tif (FUNCTION_ARG_PARTIAL_NREGS (args_so_far, mode,\n \t\t\t\t\tNULL_TREE, 1))\n \t  return false;\n-#endif\n \tFUNCTION_ARG_ADVANCE (args_so_far, mode, NULL_TREE, 1);\n       }\n   }"}, {"sha": "b335db0f373ab52560f2d759703d401f46a5674b", "filename": "gcc/expr.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/652eb7440cd038df2aeb8226189a9d4cf8578108/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/652eb7440cd038df2aeb8226189a9d4cf8578108/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=652eb7440cd038df2aeb8226189a9d4cf8578108", "patch": "@@ -203,6 +203,18 @@ do {\t\t\t\t\t\t\t\\\n #define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\tPARM_BOUNDARY\n #endif\n \n+#ifndef FUNCTION_ARG_PARTIAL_NREGS\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n+#endif\n+\n+#ifndef FUNCTION_ARG_PASS_BY_REFERENCE\n+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) 0\n+#endif\n+\n+#ifndef FUNCTION_ARG_CALLEE_COPIES\n+#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) 0\n+#endif\n+\n tree split_complex_types (tree);\n tree split_complex_values (tree);\n "}, {"sha": "79d7f6933c0ddbc2f4ad0d0dddb9212b3b71c72a", "filename": "gcc/function.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/652eb7440cd038df2aeb8226189a9d4cf8578108/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/652eb7440cd038df2aeb8226189a9d4cf8578108/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=652eb7440cd038df2aeb8226189a9d4cf8578108", "patch": "@@ -2241,10 +2241,8 @@ assign_parm_find_data_types (struct assign_parm_data_all *all, tree parm,\n      the machine requires these objects be passed that way.  */\n   if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE (passed_type))\n       || TREE_ADDRESSABLE (passed_type)\n-#ifdef FUNCTION_ARG_PASS_BY_REFERENCE\n       || FUNCTION_ARG_PASS_BY_REFERENCE (all->args_so_far, passed_mode,\n \t\t\t\t\t passed_type, data->named_arg)\n-#endif\n       )\n     {\n       passed_type = nominal_type = build_pointer_type (passed_type);\n@@ -2361,7 +2359,6 @@ assign_parm_find_entry_rtl (struct assign_parm_data_all *all,\n   if (MUST_PASS_IN_STACK (data->promoted_mode, data->passed_type))\n     entry_parm = 0;\n \n-#ifdef FUNCTION_ARG_PARTIAL_NREGS\n   if (entry_parm)\n     {\n       int partial;\n@@ -2404,7 +2401,6 @@ assign_parm_find_entry_rtl (struct assign_parm_data_all *all,\n \t  all->extra_pretend_bytes = all->pretend_args_size;\n \t}\n     }\n-#endif\n \n   locate_and_pad_parm (data->promoted_mode, data->passed_type, in_regs,\n \t\t       entry_parm ? data->partial : 0, current_function_decl,\n@@ -2849,7 +2845,6 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n       data->stack_parm = NULL;\n     }\n \n-#ifdef FUNCTION_ARG_CALLEE_COPIES\n   /* If we are passed an arg by reference and it is our responsibility\n      to make a copy, do it now.\n      PASSED_TYPE and PASSED mode now refer to the pointer, not the\n@@ -2894,7 +2889,6 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n \t  did_conversion = true;\n \t}\n     }\n-#endif /* FUNCTION_ARG_CALLEE_COPIES */\n \n   /* Mark the register as eliminable if we did no conversion and it was\n      copied from memory at a fixed offset, and the arg pointer was not"}]}