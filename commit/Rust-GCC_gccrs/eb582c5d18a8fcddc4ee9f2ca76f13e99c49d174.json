{"sha": "eb582c5d18a8fcddc4ee9f2ca76f13e99c49d174", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWI1ODJjNWQxOGE4ZmNkZGM0ZWU5ZjJjYTc2ZjEzZTk5YzQ5ZDE3NA==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-01-26T22:22:32Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-01-26T22:22:32Z"}, "message": "sparc.h (sparc_arch_type): Delete.\n\n\t* sparc/sparc.h (sparc_arch_type): Delete.\n\t({,TARGET_}MASK_DEPRECATED_V8_INSNS): Define.\n\t(ARCH64_SWITCHES): Renamed from V9_SWITCHES.\n\t* sparc/sparc.c (sparc_arch_type): Delete.\n\t(sparc_init_modes): Likewise.\n\t(output_move_quad): Don't use ldq/stq unless TARGET_HARD_QUAD.\n\t* sparc/sp64-sol2.h (TARGET_DEFAULT): Add MASK_DEPRECATED_V8_INSNS.\n\t(SUBTARGET_SWITCHES): Add -m{no,}deprecated-v8-insns\n\t* sparc/sparc.md (arch attribute): Rewrite.\n\t(isa): New attribute.\n\t(32 bit multiply/divide patterns): Use if TARGET_DEPRECATED_V8_INSNS.\n\t(32 bit divide patterns): V9 doesn't require delay after y reg write.\n\nFrom-SVN: r11110", "tree": {"sha": "66d651f73bbac94607fb51f27d7a1d0864253752", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66d651f73bbac94607fb51f27d7a1d0864253752"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb582c5d18a8fcddc4ee9f2ca76f13e99c49d174", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb582c5d18a8fcddc4ee9f2ca76f13e99c49d174", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb582c5d18a8fcddc4ee9f2ca76f13e99c49d174", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb582c5d18a8fcddc4ee9f2ca76f13e99c49d174/comments", "author": null, "committer": null, "parents": [{"sha": "2f3e5814284494e67d761eb0e68e8b7f1a130966", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f3e5814284494e67d761eb0e68e8b7f1a130966", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f3e5814284494e67d761eb0e68e8b7f1a130966"}], "stats": {"total": 160, "additions": 97, "deletions": 63}, "files": [{"sha": "244cd93b1a34b4d94273aebc4d88276a98737252", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb582c5d18a8fcddc4ee9f2ca76f13e99c49d174/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb582c5d18a8fcddc4ee9f2ca76f13e99c49d174/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=eb582c5d18a8fcddc4ee9f2ca76f13e99c49d174", "patch": "@@ -45,9 +45,6 @@ Boston, MA 02111-1307, USA.  */\n \n /* Global variables for machine-dependent things.  */\n \n-/* Says what architecture we're compiling for.  */\n-enum arch_type sparc_arch_type;\n-\n /* Size of frame.  Need to know this to emit return insns from leaf procedures.\n    ACTUAL_FSIZE is set by compute_frame_size() which is called during the\n    reload pass.  This is important as the value is later used in insn\n@@ -1913,13 +1910,14 @@ output_move_quad (operands)\n \t     the register number.  */\n \t  || (TARGET_V9 && REGNO (reg) >= 64))\n \t{\n-\t  if (TARGET_V9 && FP_REG_P (reg))\n+\t  if (TARGET_V9 && FP_REG_P (reg) && TARGET_HARD_QUAD)\n \t    {\n \t      if ((REGNO (reg) & 3) != 0)\n \t\tabort ();\n \t      return (mem == op1 ? \"ldq %1,%0\" : \"stq %1,%0\");\n \t    }\n \t  operands[2] = adj_offsettable_operand (mem, 8);\n+\t  /* ??? In arch64 case, shouldn't we use ldd/std for fp regs.  */\n \t  if (mem == op1)\n \t    return TARGET_ARCH64 ? \"ldx %1,%0;ldx %2,%R0\" : \"ldd %1,%0;ldd %2,%S0\";\n \t  else\n@@ -2641,8 +2639,6 @@ sparc_init_modes ()\n {\n   int i;\n \n-  sparc_arch_type = TARGET_ARCH64 ? ARCH_64BIT : ARCH_32BIT;\n-\n   for (i = 0; i < NUM_MACHINE_MODES; i++)\n     {\n       switch (GET_MODE_CLASS (i))"}, {"sha": "ca432ffe936b07685443da2e29a50cf31799843c", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb582c5d18a8fcddc4ee9f2ca76f13e99c49d174/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb582c5d18a8fcddc4ee9f2ca76f13e99c49d174/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=eb582c5d18a8fcddc4ee9f2ca76f13e99c49d174", "patch": "@@ -55,12 +55,6 @@ Boston, MA 02111-1307, USA.  */\n #define SPARC_ARCH64 0\n #endif\n \n-/* ??? Delete and use `TARGET_ARCH64' instead.  */\n-/* What architecture we're compiling for.  This must coincide with the\n-   `arch_type' attribute in the .md file.  */\n-enum arch_type { ARCH_32BIT, ARCH_64BIT };\n-extern enum arch_type sparc_arch_type;\n-\n /* Names to predefine in the preprocessor for this target machine.  */\n \n /* ??? The GCC_NEW_VARARGS macro is now obsolete, because gcc always uses\n@@ -204,7 +198,7 @@ extern int target_flags;\n /* Nonzero if we're compiling for v9 sparc.\n    Note that v9's can run in 32 bit mode so this doesn't necessarily mean\n    the word size is 64.  It does mean that the extra fp regs are available\n-   as are the new instructions.  */\n+   as are the new instructions that don't require 64 bit words.  */\n #define MASK_V9 0x40\n #define TARGET_V9 (target_flags & MASK_V9)\n \n@@ -238,13 +232,16 @@ extern int target_flags;\n #define MASK_APP_REGS 0x400\n #define TARGET_APP_REGS (target_flags & MASK_APP_REGS)\n \n-/*  Option to select how quad word floating point is implemented.\n-    When TARGET_HARD_QUAD is true, we use the hardware quad instructions.\n-    Otherwise, we use the SPARC ABI quad library functions.  */\n+/* Option to select how quad word floating point is implemented.\n+   When TARGET_HARD_QUAD is true, we use the hardware quad instructions.\n+   Otherwise, we use the SPARC ABI quad library functions.  */\n #define MASK_HARD_QUAD 0x800\n #define TARGET_HARD_QUAD (target_flags & MASK_HARD_QUAD)\n \n-/* Bit 0x1000 is unused.  */\n+/* Non-zero to generate code that uses the instructions deprecated in\n+   the v9 architecture.  This option only applies to v9 systems.  */\n+#define MASK_DEPRECATED_V8_INSNS 0x1000\n+#define TARGET_DEPRECATED_V8_INSNS (target_flags & MASK_DEPRECATED_V8_INSNS)\n \n /* Nonzero if ints are 64 bits.\n    This automatically implies longs are 64 bits too.\n@@ -266,16 +263,12 @@ extern int target_flags;\n /* Nonzero if generating code to run in a 64 bit environment.  */\n #define MASK_ARCH64 0x10000\n #define TARGET_ARCH64 (target_flags & MASK_ARCH64)\n-\n-/* Nonzero if generating code to run in a 32 bit environment.\n-   Hence, we assume the upper 32 bits of symbolic addresses are zero, and\n-   avoid generating %uhi and %ulo terms.\n-   Pointers are still 64 bits though!  This option is for v9 only.  */\n #define TARGET_ARCH32 (! TARGET_ARCH64)\n \n /* SPARC64 memory models.\n-   TARGET_MEDLOW: 32 bit address space, top 32 bits = 0\n-                  (pointers still 64 bits)\n+   TARGET_MEDLOW: 32 bit address space, top 32 bits = 0,\n+                  avoid generating %uhi and %ulo terms.\n+                  (pointers can be 32 or 64 bits)\n    TARGET_MEDANY: 64 bit address space, data segment restricted to 4G, but\n                   can be loaded anywhere (use %g4 as offset).\n    TARGET_FULLANY: 64 bit address space, no restrictions.\n@@ -338,18 +331,18 @@ extern int target_flags;\n     {\"hard-quad-float\", MASK_HARD_QUAD}, \\\n     {\"soft-quad-float\", -MASK_HARD_QUAD}, \\\n     SUBTARGET_SWITCHES\t\t\t\\\n-    V9_SWITCHES\t\t\t\t\\\n+    ARCH64_SWITCHES\t\t\t\\\n     { \"\", TARGET_DEFAULT}}\n \n #define TARGET_DEFAULT (MASK_APP_REGS + MASK_EPILOGUE + MASK_FPU)\n \n /* This is meant to be redefined in the host dependent files */\n #define SUBTARGET_SWITCHES\n \n-/* ??? Until we support a combination v8/v9 compiler, the v9 specific options\n-   are only defined for the v9 compiler (in a true 64 bit environment).  */\n+/* ??? Until we support a combination 32/64 bit compiler, these options\n+   are only defined for the v9 compiler in a true 64 bit environment.  */\n #if SPARC_ARCH64\n-#define V9_SWITCHES \\\n+#define ARCH64_SWITCHES \\\n /*  {\"arch32\", -MASK_ARCH64}, */\t\\\n /*  {\"arch64\", MASK_ARCH64}, */\t\t\\\n     {\"int64\", MASK_INT64+MASK_LONG64},\t\\\n@@ -369,7 +362,7 @@ extern int target_flags;\n     {\"fullany\", -MASK_CODE_MODEL},\t\\\n     {\"fullany\", MASK_FULLANY},\n #else\n-#define V9_SWITCHES\n+#define ARCH64_SWITCHES\n #endif\n \f\n /* target machine storage layout */"}, {"sha": "85dae7c71c535b67882157d3d5f0aab126716887", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 79, "deletions": 34, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb582c5d18a8fcddc4ee9f2ca76f13e99c49d174/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb582c5d18a8fcddc4ee9f2ca76f13e99c49d174/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=eb582c5d18a8fcddc4ee9f2ca76f13e99c49d174", "patch": "@@ -29,12 +29,22 @@\n ;; constraint letter is 'e'.  To avoid any confusion, 'e' is used instead of\n ;; 'f' for all DF/TFmode values, including those that are specific to the v8.\n \n-;; Architecture type.  Arch32bit includes v7, sparclite, v8.\n-;; ??? Delete and use `TARGET_ARCH64' instead.\n+;; Attribute for the instruction set.\n+;; At present we only need to distinguish v9/!v9, but for clarity we\n+;; test TARGET_V8 too.\n+(define_attr \"isa\" \"v6,v8,v9\"\n+ (const\n+  (cond [(symbol_ref \"TARGET_V9\") (const_string \"v9\")\n+\t (symbol_ref \"TARGET_V8\") (const_string \"v8\")]\n+\t(const_string \"v6\"))))\n+\n+;; Architecture size.\n (define_attr \"arch\" \"arch32bit,arch64bit\"\n-  (const (symbol_ref \"sparc_arch_type\")))\n+ (const\n+  (cond [(symbol_ref \"TARGET_ARCH64\") (const_string \"arch64bit\")]\n+\t(const_string \"arch32bit\"))))\n \n-;; CPU type. This is only used for instruction scheduling\n+;; CPU type.  This is only used for instruction scheduling.\n (define_attr \"cpu\" \"cypress,supersparc\"\n  (const\n   (cond [(symbol_ref \"TARGET_SUPERSPARC\") (const_string \"supersparc\")]\n@@ -3580,15 +3590,18 @@\n \t(minus:DI (match_dup 1) (match_dup 2)))]\n   \"TARGET_ARCH64\"\n   \"subcc %1,%2,%0\")\n+\f\n+;; Integer Multiply/Divide.\n \n-;; This is anachronistic, and should not be used in v9 software.\n-;; The v9 compiler will widen the args and use muldi3.\n+;; The 32 bit multiply/divide instructions are deprecated on v9 and shouldn't\n+;; we used.  We still use them in 32 bit v9 compilers.\n+;; The 64 bit v9 compiler will (/should) widen the args and use muldi3.\n \n (define_insn \"mulsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(mult:SI (match_operand:SI 1 \"arith_operand\" \"%r\")\n \t\t (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n-  \"TARGET_V8 || TARGET_SPARCLITE\"\n+  \"TARGET_V8 || TARGET_SPARCLITE || TARGET_DEPRECATED_V8_INSNS\"\n   \"smul %1,%2,%0\"\n   [(set_attr \"type\" \"imul\")])\n \n@@ -3608,15 +3621,15 @@\n    (set (reg:CC_NOOV 0)\n \t(compare:CC_NOOV (mult:SI (match_dup 1) (match_dup 2))\n \t\t\t (const_int 0)))]\n-  \"TARGET_V8 || TARGET_SPARCLITE\"\n+  \"TARGET_V8 || TARGET_SPARCLITE || TARGET_DEPRECATED_V8_INSNS\"\n   \"smulcc %1,%2,%0\"\n   [(set_attr \"type\" \"imul\")])\n \n (define_expand \"mulsidi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"\"))\n \t\t (sign_extend:DI (match_operand:SI 2 \"arith_operand\" \"\"))))]\n-  \"TARGET_V8 || TARGET_SPARCLITE\"\n+  \"TARGET_V8 || TARGET_SPARCLITE || TARGET_DEPRECATED_V8_INSNS\"\n   \"\n {\n   if (CONSTANT_P (operands[2]))\n@@ -3630,7 +3643,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n \t\t (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"r\"))))]\n-  \"TARGET_V8 || TARGET_SPARCLITE\"\n+  \"TARGET_V8 || TARGET_SPARCLITE || TARGET_DEPRECATED_V8_INSNS\"\n   \"smul %1,%2,%R0\\;rd %%y,%0\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -3640,7 +3653,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n \t\t (match_operand:SI 2 \"small_int\" \"I\")))]\n-  \"TARGET_V8 || TARGET_SPARCLITE\"\n+  \"TARGET_V8 || TARGET_SPARCLITE || TARGET_DEPRECATED_V8_INSNS\"\n   \"smul %1,%2,%R0\\;rd %%y,%0\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -3650,7 +3663,7 @@\n \t (lshiftrt:DI (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"\"))\n \t\t\t       (sign_extend:DI (match_operand:SI 2 \"arith_operand\" \"\")))\n \t\t      (const_int 32))))]\n-  \"TARGET_V8 || TARGET_SPARCLITE\"\n+  \"TARGET_V8 || TARGET_SPARCLITE || TARGET_DEPRECATED_V8_INSNS\"\n   \"\n {\n   if (CONSTANT_P (operands[2]))\n@@ -3666,7 +3679,7 @@\n \t (lshiftrt:DI (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n \t\t\t       (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"r\")))\n \t\t      (const_int 32))))]\n-  \"TARGET_V8 || TARGET_SPARCLITE\"\n+  \"TARGET_V8 || TARGET_SPARCLITE || TARGET_DEPRECATED_V8_INSNS\"\n   \"smul %1,%2,%%g0\\;rd %%y,%0\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -3676,15 +3689,15 @@\n \t (lshiftrt:DI (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n \t\t\t       (match_operand:SI 2 \"register_operand\" \"r\"))\n \t\t      (const_int 32))))]\n-  \"TARGET_V8 || TARGET_SPARCLITE\"\n+  \"TARGET_V8 || TARGET_SPARCLITE || TARGET_DEPRECATED_V8_INSNS\"\n   \"smul %1,%2,%%g0\\;rd %%y,%0\"\n   [(set_attr \"length\" \"2\")])\n \n (define_expand \"umulsidi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"\"))\n \t\t (zero_extend:DI (match_operand:SI 2 \"uns_arith_operand\" \"\"))))]\n-  \"TARGET_V8 || TARGET_SPARCLITE\"\n+  \"TARGET_V8 || TARGET_SPARCLITE || TARGET_DEPRECATED_V8_INSNS\"\n   \"\n {\n   if (CONSTANT_P (operands[2]))\n@@ -3698,7 +3711,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n \t\t (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"r\"))))]\n-  \"TARGET_V8 || TARGET_SPARCLITE\"\n+  \"TARGET_V8 || TARGET_SPARCLITE || TARGET_DEPRECATED_V8_INSNS\"\n   \"umul %1,%2,%R0\\;rd %%y,%0\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -3708,7 +3721,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n \t\t (match_operand:SI 2 \"uns_small_int\" \"\")))]\n-  \"TARGET_V8 || TARGET_SPARCLITE\"\n+  \"TARGET_V8 || TARGET_SPARCLITE || TARGET_DEPRECATED_V8_INSNS\"\n   \"umul %1,%2,%R0\\;rd %%y,%0\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -3718,7 +3731,7 @@\n \t (lshiftrt:DI (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"\"))\n \t\t\t       (zero_extend:DI (match_operand:SI 2 \"uns_arith_operand\" \"\")))\n \t\t      (const_int 32))))]\n-  \"TARGET_V8 || TARGET_SPARCLITE\"\n+  \"TARGET_V8 || TARGET_SPARCLITE || TARGET_DEPRECATED_V8_INSNS\"\n   \"\n {\n   if (CONSTANT_P (operands[2]))\n@@ -3734,7 +3747,7 @@\n \t (lshiftrt:DI (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n \t\t\t       (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"r\")))\n \t\t      (const_int 32))))]\n-  \"TARGET_V8 || TARGET_SPARCLITE\"\n+  \"TARGET_V8 || TARGET_SPARCLITE || TARGET_DEPRECATED_V8_INSNS\"\n   \"umul %1,%2,%%g0\\;rd %%y,%0\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -3744,21 +3757,29 @@\n \t (lshiftrt:DI (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n \t\t\t       (match_operand:SI 2 \"uns_small_int\" \"\"))\n \t\t      (const_int 32))))]\n-  \"TARGET_V8 || TARGET_SPARCLITE\"\n+  \"TARGET_V8 || TARGET_SPARCLITE || TARGET_DEPRECATED_V8_INSNS\"\n   \"umul %1,%2,%%g0\\;rd %%y,%0\"\n   [(set_attr \"length\" \"2\")])\n \n-;; The architecture specifies that there must be 3 instructions between\n+;; The v8 architecture specifies that there must be 3 instructions between\n ;; a y register write and a use of it for correct results.\n \n (define_insn \"divsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(div:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t(match_operand:SI 2 \"arith_operand\" \"rI\")))\n    (clobber (match_scratch:SI 3 \"=&r\"))]\n-  \"TARGET_V8\"\n-  \"sra %1,31,%3\\;wr %%g0,%3,%%y\\;nop\\;nop\\;nop\\;sdiv %1,%2,%0\"\n-  [(set_attr \"length\" \"6\")])\n+  \"TARGET_V8 || TARGET_DEPRECATED_V8_INSNS\"\n+  \"*\n+{\n+  if (TARGET_V9)\n+    return \\\"sra %1,31,%3\\;wr %%g0,%3,%%y\\;sdiv %1,%2,%0\\\";\n+  else\n+    return \\\"sra %1,31,%3\\;wr %%g0,%3,%%y\\;nop\\;nop\\;nop\\;sdiv %1,%2,%0\\\";\n+}\"\n+  [(set (attr \"length\")\n+\t(if_then_else (eq_attr \"isa\" \"v9\")\n+\t\t      (const_int 3) (const_int 6)))])\n \n (define_insn \"divdi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -3777,17 +3798,33 @@\n \t(compare:CC (div:SI (match_dup 1) (match_dup 2))\n \t\t    (const_int 0)))\n    (clobber (match_scratch:SI 3 \"=&r\"))]\n-  \"TARGET_V8\"\n-  \"sra %1,31,%3\\;wr %%g0,%3,%%y\\;nop\\;nop\\;nop\\;sdivcc %1,%2,%0\"\n-  [(set_attr \"length\" \"6\")])\n+  \"TARGET_V8 || TARGET_DEPRECATED_V8_INSNS\"\n+  \"*\n+{\n+  if (TARGET_V9)\n+    return \\\"sra %1,31,%3\\;wr %%g0,%3,%%y\\;sdivcc %1,%2,%0\\\";\n+  else\n+    return \\\"sra %1,31,%3\\;wr %%g0,%3,%%y\\;nop\\;nop\\;nop\\;sdivcc %1,%2,%0\\\";\n+}\"\n+  [(set (attr \"length\")\n+\t(if_then_else (eq_attr \"isa\" \"v9\")\n+\t\t      (const_int 3) (const_int 6)))])\n \n (define_insn \"udivsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(udiv:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t(match_operand:SI 2 \"arith_operand\" \"rI\")))]\n-  \"TARGET_V8\"\n-  \"wr %%g0,%%g0,%%y\\;nop\\;nop\\;nop\\;udiv %1,%2,%0\"\n-  [(set_attr \"length\" \"5\")])\n+\t\t (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n+  \"TARGET_V8 || TARGET_DEPRECATED_V8_INSNS\"\n+  \"*\n+{\n+  if (TARGET_V9)\n+    return \\\"wr %%g0,%%g0,%%y\\;udiv %1,%2,%0\\\";\n+  else\n+    return \\\"wr %%g0,%%g0,%%y\\;nop\\;nop\\;nop\\;udiv %1,%2,%0\\\";\n+}\"\n+  [(set (attr \"length\")\n+\t(if_then_else (eq_attr \"isa\" \"v9\")\n+\t\t      (const_int 2) (const_int 5)))])\n \n (define_insn \"udivdi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -3805,9 +3842,17 @@\n    (set (reg:CC 0)\n \t(compare:CC (udiv:SI (match_dup 1) (match_dup 2))\n \t\t    (const_int 0)))]\n-  \"TARGET_V8\"\n-  \"wr %%g0,%%g0,%%y\\;nop\\;nop\\;nop\\;udivcc %1,%2,%0\"\n-  [(set_attr \"length\" \"5\")])\n+  \"TARGET_V8 || TARGET_DEPRECATED_V8_INSNS\"\n+  \"*\n+{\n+  if (TARGET_V9)\n+    return \\\"wr %%g0,%%g0,%%y\\;udivcc %1,%2,%0\\\";\n+  else\n+    return \\\"wr %%g0,%%g0,%%y\\;nop\\;nop\\;nop\\;udivcc %1,%2,%0\\\";\n+}\"\n+  [(set (attr \"length\")\n+\t(if_then_else (eq_attr \"isa\" \"v9\")\n+\t\t      (const_int 2) (const_int 5)))])\n \f\n ;;- Boolean instructions\n ;; We define DImode `and` so with DImode `not` we can get"}]}