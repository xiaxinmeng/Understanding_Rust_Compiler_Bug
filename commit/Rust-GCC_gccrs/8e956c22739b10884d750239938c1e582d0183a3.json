{"sha": "8e956c22739b10884d750239938c1e582d0183a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU5NTZjMjI3MzliMTA4ODRkNzUwMjM5OTM4YzFlNTgyZDAxODNhMw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-02-07T17:43:12Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-02-07T17:43:12Z"}, "message": "method.c (synthesized_method_base_walk): New.\n\n\t* method.c (synthesized_method_base_walk): New.  Broken out of ...\n\t(synthesized_method_walk): ... here.  Call it.  Cleanup\n\tinitializations.\n\nFrom-SVN: r245250", "tree": {"sha": "1a73b3b1eb79a3ec1ec0359ba2b5f5c5c2945144", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a73b3b1eb79a3ec1ec0359ba2b5f5c5c2945144"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e956c22739b10884d750239938c1e582d0183a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e956c22739b10884d750239938c1e582d0183a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e956c22739b10884d750239938c1e582d0183a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e956c22739b10884d750239938c1e582d0183a3/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e5f234b2c4283d959631ba157462f0431bb49fcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5f234b2c4283d959631ba157462f0431bb49fcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5f234b2c4283d959631ba157462f0431bb49fcc"}], "stats": {"total": 217, "additions": 105, "deletions": 112}, "files": [{"sha": "dc87561793c9369af6291965b9834ec60993a742", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e956c22739b10884d750239938c1e582d0183a3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e956c22739b10884d750239938c1e582d0183a3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8e956c22739b10884d750239938c1e582d0183a3", "patch": "@@ -1,3 +1,9 @@\n+2017-02-07  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* method.c (synthesized_method_base_walk): New.  Broken out of ...\n+\t(synthesized_method_walk): ... here.  Call it.  Cleanup\n+\tinitializations.\n+\n 2017-02-07  Patrick Palka  <ppalka@gcc.gnu.org>\n \n \tPR c++/79360"}, {"sha": "a6a9b4e7f7484289911710227618347b34a8a45e", "filename": "gcc/cp/method.c", "status": "modified", "additions": 99, "deletions": 112, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e956c22739b10884d750239938c1e582d0183a3/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e956c22739b10884d750239938c1e582d0183a3/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=8e956c22739b10884d750239938c1e582d0183a3", "patch": "@@ -1416,6 +1416,61 @@ walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n     }\n }\n \n+// Base walker helper for synthesized_method_walk.  Inspect a direct\n+// or virtual base.  BINFO is the parent type's binfo.  BASE_BINFO is\n+// the base binfo of interests.  All other parms are as for\n+// synthesized_method_walk, or its local vars.\n+\n+static tree\n+synthesized_method_base_walk (tree binfo, tree base_binfo, \n+\t\t\t      int quals, bool copy_arg_p,\n+\t\t\t      bool move_p, bool ctor_p,\n+\t\t\t      tree inheriting_ctor, tree inherited_parms,\n+\t\t\t      tree fnname, int flags, bool diag,\n+\t\t\t      tree *spec_p, bool *trivial_p,\n+\t\t\t      bool *deleted_p, bool *constexpr_p)\n+{\n+  bool inherited_binfo = false;\n+  tree argtype = NULL_TREE;\n+  \n+  if (copy_arg_p)\n+    argtype = build_stub_type (BINFO_TYPE (base_binfo), quals, move_p);\n+  else if ((inherited_binfo\n+\t    = binfo_inherited_from (binfo, base_binfo, inheriting_ctor)))\n+    {\n+      argtype = inherited_parms;\n+      /* Don't check access on the inherited constructor.  */\n+      if (flag_new_inheriting_ctors)\n+\tpush_deferring_access_checks (dk_deferred);\n+    }\n+  tree rval = locate_fn_flags (base_binfo, fnname, argtype, flags,\n+\t\t\t       diag ? tf_warning_or_error : tf_none);\n+  if (inherited_binfo && flag_new_inheriting_ctors)\n+    pop_deferring_access_checks ();\n+\n+  process_subob_fn (rval, spec_p, trivial_p, deleted_p,\n+\t\t    constexpr_p, diag, BINFO_TYPE (base_binfo));\n+  if (ctor_p &&\n+      (!BINFO_VIRTUAL_P (base_binfo)\n+       || TYPE_HAS_NONTRIVIAL_DESTRUCTOR (BINFO_TYPE (base_binfo))))\n+    {\n+      /* In a constructor we also need to check the subobject\n+\t destructors for cleanup of partially constructed objects.  */\n+      tree dtor = locate_fn_flags (base_binfo, complete_dtor_identifier,\n+\t\t\t\t   NULL_TREE, flags,\n+\t\t\t\t   diag ? tf_warning_or_error : tf_none);\n+\t  /* Note that we don't pass down trivial_p; the subobject\n+\t     destructors don't affect triviality of the constructor.  Nor\n+\t     do they affect constexpr-ness (a constant expression doesn't\n+\t     throw) or exception-specification (a throw from one of the\n+\t     dtors would be a double-fault).  */\n+      process_subob_fn (dtor, NULL, NULL, deleted_p, NULL, false,\n+\t\t\tBINFO_TYPE (base_binfo), /*dtor_from_ctor*/true);\n+    }\n+\n+  return rval;\n+}\n+\n /* The caller wants to generate an implicit declaration of SFK for\n    CTYPE which is const if relevant and CONST_P is set.  If SPEC_P,\n    TRIVIAL_P, DELETED_P or CONSTEXPR_P are non-null, set their\n@@ -1429,12 +1484,8 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n \t\t\t bool *constexpr_p, bool diag,\n \t\t\t tree inheriting_ctor, tree inherited_parms)\n {\n-  tree binfo, base_binfo, scope, fnname, rval, argtype;\n-  bool move_p, copy_arg_p, assign_p, expected_trivial, check_vdtor;\n-  vec<tree, va_gc> *vbases;\n-  int i, quals, flags;\n-  tsubst_flags_t complain;\n-  bool ctor_p;\n+  tree binfo, base_binfo, fnname;\n+  int i;\n \n   if (spec_p)\n     *spec_p = (cxx_dialect >= cxx11 ? noexcept_true_spec : empty_except_spec);\n@@ -1455,9 +1506,9 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n       *deleted_p = false;\n     }\n \n-  ctor_p = false;\n-  assign_p = false;\n-  check_vdtor = false;\n+  bool ctor_p = false;\n+  bool assign_p = false;\n+  bool check_vdtor = false;\n   switch (sfk)\n     {\n     case sfk_move_assignment:\n@@ -1497,19 +1548,18 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n       - the assignment operator selected to copy/move each direct base class\n \tsubobject is a constexpr function, and\n       - for each non-static data member of X that is of class type (or array\n-\tthereof), the assignment operator selected to copy/move that member is a\n-\tconstexpr function.  */\n+\tthereof), the assignment operator selected to copy/move that\n+\tmember is a constexpr function.  */\n   if (constexpr_p)\n-    *constexpr_p = ctor_p\n-      || (assign_p && cxx_dialect >= cxx14);\n+    *constexpr_p = ctor_p || (assign_p && cxx_dialect >= cxx14);\n \n-  move_p = false;\n+  bool move_p = false;\n+  bool copy_arg_p = false;\n   switch (sfk)\n     {\n     case sfk_constructor:\n     case sfk_destructor:\n     case sfk_inheriting_constructor:\n-      copy_arg_p = false;\n       break;\n \n     case sfk_move_constructor:\n@@ -1525,7 +1575,7 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n       gcc_unreachable ();\n     }\n \n-  expected_trivial = type_has_trivial_fn (ctype, sfk);\n+  bool expected_trivial = type_has_trivial_fn (ctype, sfk);\n   if (trivial_p)\n     *trivial_p = expected_trivial;\n \n@@ -1559,92 +1609,55 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n   ++c_inhibit_evaluation_warnings;\n   push_deferring_access_checks (dk_no_deferred);\n \n-  scope = push_scope (ctype);\n+  tree scope = push_scope (ctype);\n \n-  flags = LOOKUP_NORMAL|LOOKUP_SPECULATIVE;\n+  int flags = LOOKUP_NORMAL | LOOKUP_SPECULATIVE;\n   if (!inheriting_ctor)\n     flags |= LOOKUP_DEFAULTED;\n \n-  complain = diag ? tf_warning_or_error : tf_none;\n-\n-  if (const_p)\n-    quals = TYPE_QUAL_CONST;\n-  else\n-    quals = TYPE_UNQUALIFIED;\n-  argtype = NULL_TREE;\n+  tsubst_flags_t complain = diag ? tf_warning_or_error : tf_none;\n+  int quals = const_p ? TYPE_QUAL_CONST : TYPE_UNQUALIFIED;\n \n   for (binfo = TYPE_BINFO (ctype), i = 0;\n        BINFO_BASE_ITERATE (binfo, i, base_binfo); ++i)\n     {\n-      tree basetype = BINFO_TYPE (base_binfo);\n-\n       if (!assign_p && BINFO_VIRTUAL_P (base_binfo))\n \t/* We'll handle virtual bases below.  */\n \tcontinue;\n \n-      bool inherited_binfo = false;\n+      tree fn = synthesized_method_base_walk (binfo, base_binfo, quals,\n+\t\t\t\t\t      copy_arg_p, move_p, ctor_p,\n+\t\t\t\t\t      inheriting_ctor,\n+\t\t\t\t\t      inherited_parms,\n+\t\t\t\t\t      fnname, flags, diag,\n+\t\t\t\t\t      spec_p, trivial_p,\n+\t\t\t\t\t      deleted_p, constexpr_p);\n \n-      if (copy_arg_p)\n-\targtype = build_stub_type (basetype, quals, move_p);\n-      else if ((inherited_binfo\n-\t\t= binfo_inherited_from (binfo, base_binfo, inheriting_ctor)))\n-\t{\n-\t  /* Don't check access on the inherited constructor.  */\n-\t  argtype = inherited_parms;\n-\t  if (flag_new_inheriting_ctors)\n-\t    push_deferring_access_checks (dk_deferred);\n-\t}\n-      rval = locate_fn_flags (base_binfo, fnname, argtype, flags, complain);\n-      if (inherited_binfo)\n-\t{\n-\t  if (flag_new_inheriting_ctors)\n-\t    pop_deferring_access_checks ();\n-\t  argtype = NULL_TREE;\n-\t}\n-\n-      process_subob_fn (rval, spec_p, trivial_p, deleted_p,\n-\t\t\tconstexpr_p, diag, basetype);\n-      if (ctor_p)\n-\t{\n-\t  /* In a constructor we also need to check the subobject\n-\t     destructors for cleanup of partially constructed objects.  */\n-\t  rval = locate_fn_flags (base_binfo, complete_dtor_identifier,\n-\t\t\t\t  NULL_TREE, flags, complain);\n-\t  /* Note that we don't pass down trivial_p; the subobject\n-\t     destructors don't affect triviality of the constructor.  Nor\n-\t     do they affect constexpr-ness (a constant expression doesn't\n-\t     throw) or exception-specification (a throw from one of the\n-\t     dtors would be a double-fault).  */\n-\t  process_subob_fn (rval, NULL, NULL,\n-\t\t\t    deleted_p, NULL, false,\n-\t\t\t    basetype, /*dtor_from_ctor*/true);\n-\t}\n+      if (diag && assign_p && move_p\n+\t  && BINFO_VIRTUAL_P (base_binfo)\n+\t  && fn && TREE_CODE (fn) == FUNCTION_DECL\n+\t  && move_fn_p (fn) && !trivial_fn_p (fn)\n+\t  && vbase_has_user_provided_move_assign (BINFO_TYPE (base_binfo)))\n+\twarning (OPT_Wvirtual_move_assign,\n+\t\t \"defaulted move assignment for %qT calls a non-trivial \"\n+\t\t \"move assignment operator for virtual base %qT\",\n+\t\t ctype, BINFO_TYPE (base_binfo));\n \n-      if (check_vdtor && type_has_virtual_destructor (basetype))\n+      if (check_vdtor && type_has_virtual_destructor (BINFO_TYPE (base_binfo)))\n \t{\n-\t  rval = locate_fn_flags (ctype, cp_operator_id (DELETE_EXPR),\n-\t\t\t\t  ptr_type_node, flags, complain);\n+\t  fn = locate_fn_flags (ctype, cp_operator_id (DELETE_EXPR),\n+\t\t\t\tptr_type_node, flags, complain);\n \t  /* Unlike for base ctor/op=/dtor, for operator delete it's fine\n-\t     to have a null rval (no class-specific op delete).  */\n-\t  if (rval && rval == error_mark_node && deleted_p)\n+\t     to have a null fn (no class-specific op delete).  */\n+\t  if (fn && fn == error_mark_node && deleted_p)\n \t    *deleted_p = true;\n \t  check_vdtor = false;\n \t}\n-\n-      if (diag && assign_p && move_p\n-\t  && BINFO_VIRTUAL_P (base_binfo)\n-\t  && rval && TREE_CODE (rval) == FUNCTION_DECL\n-\t  && move_fn_p (rval) && !trivial_fn_p (rval)\n-\t  && vbase_has_user_provided_move_assign (basetype))\n-\twarning (OPT_Wvirtual_move_assign,\n-\t\t \"defaulted move assignment for %qT calls a non-trivial \"\n-\t\t \"move assignment operator for virtual base %qT\",\n-\t\t ctype, basetype);\n     }\n \n-  vbases = CLASSTYPE_VBASECLASSES (ctype);\n+  vec<tree, va_gc> *vbases = CLASSTYPE_VBASECLASSES (ctype);\n   if (assign_p)\n-    /* No need to examine vbases here.  */;\n+    /* Already examined vbases above.  */;\n   else if (vec_safe_is_empty (vbases))\n     /* No virtual bases to worry about.  */;\n   else if (ABSTRACT_CLASS_TYPE_P (ctype) && cxx_dialect >= cxx14)\n@@ -1654,38 +1667,12 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n       if (constexpr_p)\n \t*constexpr_p = false;\n       FOR_EACH_VEC_ELT (*vbases, i, base_binfo)\n-\t{\n-\t  tree basetype = BINFO_TYPE (base_binfo);\n-\t  bool inherited_binfo = false;\n-\n-\t  if (copy_arg_p)\n-\t    argtype = build_stub_type (basetype, quals, move_p);\n-\t  else if ((inherited_binfo\n-\t\t    = binfo_inherited_from (binfo, base_binfo, inheriting_ctor)))\n-\t    {\n-\t      argtype = inherited_parms;\n-\t      if (flag_new_inheriting_ctors)\n-\t\tpush_deferring_access_checks (dk_deferred);\n-\t    }\n-\t  rval = locate_fn_flags (base_binfo, fnname, argtype, flags, complain);\n-\t  if (inherited_binfo)\n-\t    {\n-\t      if (flag_new_inheriting_ctors)\n-\t\tpop_deferring_access_checks ();\n-\t      argtype = NULL_TREE;\n-\t    }\n-\n-\t  process_subob_fn (rval, spec_p, trivial_p, deleted_p,\n-\t\t\t    constexpr_p, diag, basetype);\n-\t  if (ctor_p && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (basetype))\n-\t    {\n-\t      rval = locate_fn_flags (base_binfo, complete_dtor_identifier,\n-\t\t\t\t      NULL_TREE, flags, complain);\n-\t      process_subob_fn (rval, NULL, NULL,\n-\t\t\t\tdeleted_p, NULL, false,\n-\t\t\t\tbasetype, /*dtor_from_ctor*/true);\n-\t    }\n-\t}\n+\tsynthesized_method_base_walk (binfo, base_binfo, quals,\n+\t\t\t\t      copy_arg_p, move_p, ctor_p,\n+\t\t\t\t      inheriting_ctor, inherited_parms,\n+\t\t\t\t      fnname, flags, diag,\n+\t\t\t\t      spec_p, trivial_p,\n+\t\t\t\t      deleted_p, constexpr_p);\n     }\n \n   /* Now handle the non-static data members.  */"}]}