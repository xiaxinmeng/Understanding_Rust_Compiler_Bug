{"sha": "96fd01679011379d6da0777e435078212c6bb325", "node_id": "C_kwDOANBUbNoAKDk2ZmQwMTY3OTAxMTM3OWQ2ZGEwNzc3ZTQzNTA3ODIxMmM2YmIzMjU", "commit": {"author": {"name": "Gaius Mulley", "email": "gaiusmod2@gmail.com", "date": "2023-01-24T19:21:20Z"}, "committer": {"name": "Gaius Mulley", "email": "gaiusmod2@gmail.com", "date": "2023-01-24T19:21:20Z"}, "message": "Change m2 lexical analysis to optionally consume C comments.\n\nThis patch allows a subsequent patch to turn on/off the consuming\nof C comments.\n\ngcc/m2/ChangeLog:\n\n\t* m2.flex (cpreprocessor): Add temporary variable\n\twhich is initialized to 0.\n\t(commentCLevel): New variable.\n\t(endOfCComment): New function.\n\t(splitSlashStar): New function to split /* into / and *\n\ttokens.\n\t(COMMENTC): New flex state.\n\t(\"/*\"): New rule to test whether we should treat /*\n\tas a single token or as two tokens.\n\t(<COMMENTC>.): New rule to skip a character.\n\t(<COMMENTC>\\n.*): New rule to consume the line.\n\t(<COMMENTC>\"*/\"): New rule to call endOfCComment.\n\nSigned-off-by: Gaius Mulley <gaiusmod2@gmail.com>", "tree": {"sha": "8f0b186c25fc0f5f613607158b9f673c20b3f3b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f0b186c25fc0f5f613607158b9f673c20b3f3b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96fd01679011379d6da0777e435078212c6bb325", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96fd01679011379d6da0777e435078212c6bb325", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96fd01679011379d6da0777e435078212c6bb325", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96fd01679011379d6da0777e435078212c6bb325/comments", "author": null, "committer": null, "parents": [{"sha": "b061fc94d70dc82f554eeb94434cf03cd5af03f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b061fc94d70dc82f554eeb94434cf03cd5af03f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b061fc94d70dc82f554eeb94434cf03cd5af03f7"}], "stats": {"total": 70, "additions": 69, "deletions": 1}, "files": [{"sha": "7b8f4f17f42958b2c0111c865152499aa1504326", "filename": "gcc/m2/m2.flex", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96fd01679011379d6da0777e435078212c6bb325/gcc%2Fm2%2Fm2.flex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96fd01679011379d6da0777e435078212c6bb325/gcc%2Fm2%2Fm2.flex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fm2%2Fm2.flex?ref=96fd01679011379d6da0777e435078212c6bb325", "patch": "@@ -27,6 +27,7 @@ along with GNU Modula-2; see the file COPYING3.  If not see\n #include \"input.h\"\n #include \"m2options.h\"\n \n+static int cpreprocessor = 0;  /* Replace this with correct getter.  */\n \n #if defined(GM2USEGGC)\n #  include \"ggc.h\"\n@@ -70,6 +71,7 @@ along with GNU Modula-2; see the file COPYING3.  If not see\n   static int                  lineno      =1;   /* a running count of the file line number */\n   static char                *filename    =NULL;\n   static int                  commentLevel=0;\n+  static int                  commentCLevel=0;\n   static struct lineInfo     *currentLine=NULL;\n   static struct functionInfo *currentFunction=NULL;\n   static int                  seenFunctionStart=FALSE;\n@@ -87,6 +89,8 @@ static  void updatepos                (void);\n static  void skippos                  (void);\n static  void poperrorskip             (const char *);\n static  void endOfComment             (void);\n+static  void endOfCComment            (void);\n+static  void splitSlashStar           (void);\n static  void handleDate               (void);\n static  void handleLine               (void);\n static  void handleFile               (void);\n@@ -117,7 +121,7 @@ extern  void  yylex                   (void);\n %}\n \n %option nounput\n-%x COMMENT COMMENT1 LINE0 LINE1 LINE2\n+%x COMMENT COMMENT1 COMMENTC LINE0 LINE1 LINE2\n \n %%\n \n@@ -145,6 +149,24 @@ extern  void  yylex                   (void);\n <COMMENT1><<EOF>>          { poperrorskip(\"unterminated source code directive, missing *>\"); BEGIN COMMENT; }\n <COMMENT><<EOF>>           { poperrorskip(\"unterminated comment found at the end of the file, missing *)\"); BEGIN INITIAL; }\n \n+\"/*\"                       { /* Possibly handle C preprocessor comment.  */\n+                             if (cpreprocessor)\n+\t\t\t       {\n+\t\t\t\t updatepos ();\n+\t\t\t\t commentCLevel++;\n+\t\t\t\t if (commentCLevel == 1)\n+\t\t\t\t   {\n+\t\t\t\t     pushLine ();\n+\t\t\t\t     skippos ();\n+\t\t\t\t   }\n+\t\t\t\t BEGIN COMMENTC;\n+\t\t\t       }\n+\t\t\t     else\n+\t\t\t       splitSlashStar ();\n+                           }\n+<COMMENTC>.                { updatepos(); skippos(); }\n+<COMMENTC>\\n.*             { consumeLine(); }\n+<COMMENTC>\"*/\"             { endOfCComment(); }\n ^\\#.*                      { consumeLine(); /* printf(\"found: %s\\n\", currentLine->linebuf); */ BEGIN LINE0; }\n \\n\\#.*                     { consumeLine(); /* printf(\"found: %s\\n\", currentLine->linebuf); */ BEGIN LINE0; }\n <LINE0>\\#[ \\t]*            { updatepos(); }\n@@ -436,6 +458,19 @@ static void endOfComment (void)\n     popLine();\n }\n \n+/*\n+ *  endOfCComment - handles the end of C comment.\n+ */\n+\n+static void endOfCComment (void)\n+{\n+  commentCLevel = 0;\n+  updatepos();\n+  skippos();\n+  BEGIN INITIAL;\n+  finishedLine();\n+}\n+\n /*\n  *  m2flex_M2Error - displays the error message, s, after the code line and pointer\n  *                   to the erroneous token.\n@@ -504,6 +539,39 @@ static void assert_location (location_t location ATTRIBUTE_UNUSED)\n #endif\n }\n \n+/*\n+ *  splitSlashStar - called if we are not tokenizing source code after it\n+ *                   has been preprocessed by cpp.  It is only called\n+ *                   if the current token was /* and therefore it will\n+ *                   be split into two m2 tokens:  / and *.\n+ */\n+\n+static void splitSlashStar (void)\n+{\n+  seenFunctionStart    = FALSE;\n+  seenEnd              = FALSE;\n+  seenModuleStart      = FALSE;\n+  currentLine->nextpos = currentLine->tokenpos+1;  /* \"/\".  */\n+  currentLine->toklen  = 1;\n+  currentLine->column = currentLine->tokenpos+1;\n+  currentLine->location =\n+    M2Options_OverrideLocation (GET_LOCATION (currentLine->column,\n+                                              currentLine->column+currentLine->toklen-1));\n+  assert_location (GET_LOCATION (currentLine->column,\n+                                 currentLine->column+currentLine->toklen-1));\n+  M2LexBuf_AddTok (M2Reserved_dividetok);\n+  currentLine->nextpos = currentLine->tokenpos+1;  /* \"*\".  */\n+  currentLine->toklen  = 1;\n+  currentLine->column = currentLine->tokenpos+1;\n+  currentLine->location =\n+    M2Options_OverrideLocation (GET_LOCATION (currentLine->column,\n+                                              currentLine->column+currentLine->toklen-1));\n+  assert_location (GET_LOCATION (currentLine->column,\n+                                 currentLine->column+currentLine->toklen-1));\n+  M2LexBuf_AddTok (M2Reserved_timestok);\n+}\n+\n+\n /*\n  *  updatepos - updates the current token position.\n  *              Should be used when a rule matches a token."}]}