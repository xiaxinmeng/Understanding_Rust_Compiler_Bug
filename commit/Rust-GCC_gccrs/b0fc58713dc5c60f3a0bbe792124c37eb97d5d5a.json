{"sha": "b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBmYzU4NzEzZGM1YzYwZjNhMGJiZTc5MjEyNGMzN2ViOTdkNWQ1YQ==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2002-11-17T00:10:24Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2002-11-17T00:10:24Z"}, "message": "Integrate work by Raif S.\n\n\tIntegrate work by Raif S. Naffah (raif@fl.net.au)\n\t* java/security/DummyKeyPairGenerator.java (clone): New method.\n\t* java/security/DummyMessageDigest.java (clone): New method.\n\t(engineUpdate): Now public.\n\t(engineReset): Likewise.\n\t(engineDigest): Likewise.\n\t(engineGetDigestLength): New method.\n\t* java/security/DummySignature.java (clone): New method.\n\t* java/security/KeyPairGenerator.java (provider): Now package private.\n\t(getInstance(String)): Use getInstance(String,Provider).\n\t(getInstance(String,String): Use getInstance(String,Provider)\n\t(getInstance(String,Provider): New method.\n\t(getInstance(String,String,Provider): Don't cast DummyKeyPairGenerator.\n\t* java/security/KeyPairGeneratorSpi.java (clone): New method.\n\t* java/security/MessageDigest.java (provider): Now package private.\n\t(getInstance(String): Use getInstance(String,Provider).\n\t(getInstance(String,String): Use getInstance(String,Provider)\n\t(getInstance(String,Provider): New method.\n\t* java/security/Provider.java (toCanonicalKey): New method.\n\t(get): New method that uses toCanonicalKey().\n\t(put): Use toCanonicalKey().\n\t(remove): Likewise.\n\t* java/security/Security.java (insertProviderAt): Provider index is one\n\tbased, not zero based.\n\t(addProvider): Likewise.\n\t(removeProvider): Likewise.\n\t* java/security/Signature.java (provider): Now package private.\n\t(getInstance(String)): Use getInstance(String,Provider).\n\t(getInstance(String,String): Use getInstance(String,Provider)\n\t(getInstance(String,Provider): New method.\n\t(getInstance(String,String,Provider): Don't cast DummySignature.\n\nFrom-SVN: r59179", "tree": {"sha": "413f3dd029186270eae12c491b26ff3d1f283b4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/413f3dd029186270eae12c491b26ff3d1f283b4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a/comments", "author": null, "committer": null, "parents": [{"sha": "aaefd21647444a82468b8bc3ef6c65721ef18598", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaefd21647444a82468b8bc3ef6c65721ef18598", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aaefd21647444a82468b8bc3ef6c65721ef18598"}], "stats": {"total": 467, "additions": 350, "deletions": 117}, "files": [{"sha": "5f53cdb6a292179cc9ae90bfb775930ad522f2ab", "filename": "libjava/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a", "patch": "@@ -1,3 +1,37 @@\n+2002-11-16  Mark Wielaard  <mark@klomp.org>\n+\n+\tIntegrate work by Raif S. Naffah (raif@fl.net.au)\n+\t* java/security/DummyKeyPairGenerator.java (clone): New method.\n+\t* java/security/DummyMessageDigest.java (clone): New method.\n+\t(engineUpdate): Now public.\n+\t(engineReset): Likewise.\n+\t(engineDigest): Likewise.\n+\t(engineGetDigestLength): New method.\n+\t* java/security/DummySignature.java (clone): New method.\n+\t* java/security/KeyPairGenerator.java (provider): Now package private.\n+\t(getInstance(String)): Use getInstance(String,Provider).\n+\t(getInstance(String,String): Use getInstance(String,Provider)\n+\t(getInstance(String,Provider): New method.\n+\t(getInstance(String,String,Provider): Don't cast DummyKeyPairGenerator.\n+\t* java/security/KeyPairGeneratorSpi.java (clone): New method.\n+\t* java/security/MessageDigest.java (provider): Now package private.\n+\t(getInstance(String): Use getInstance(String,Provider).\n+\t(getInstance(String,String): Use getInstance(String,Provider)\n+\t(getInstance(String,Provider): New method.\n+\t* java/security/Provider.java (toCanonicalKey): New method.\n+\t(get): New method that uses toCanonicalKey().\n+\t(put): Use toCanonicalKey().\n+\t(remove): Likewise.\n+\t* java/security/Security.java (insertProviderAt): Provider index is one\n+\tbased, not zero based.\n+\t(addProvider): Likewise.\n+\t(removeProvider): Likewise.\n+\t* java/security/Signature.java (provider): Now package private.\n+\t(getInstance(String)): Use getInstance(String,Provider).\n+\t(getInstance(String,String): Use getInstance(String,Provider)\n+\t(getInstance(String,Provider): New method.\n+\t(getInstance(String,String,Provider): Don't cast DummySignature.\n+\n 2002-11-15  Tom Tromey  <tromey@redhat.com>\n \n \tFor PR libgcj/8593:"}, {"sha": "3a88b86e01ba8a5899305f21bff6749283f1b516", "filename": "libjava/java/security/DummyKeyPairGenerator.java", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a/libjava%2Fjava%2Fsecurity%2FDummyKeyPairGenerator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a/libjava%2Fjava%2Fsecurity%2FDummyKeyPairGenerator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FDummyKeyPairGenerator.java?ref=b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a", "patch": "@@ -1,5 +1,5 @@\n-/* DummyKeyPairGenerator.java\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+/* DummyKeyPairGenerator.java - Wrapper for KeyPairGeneratorSpi\n+   Copyright (C) 1999, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -36,6 +36,7 @@\n exception statement from your version. */\n \n package java.security;\n+\n import java.security.spec.AlgorithmParameterSpec;\n \n final class DummyKeyPairGenerator extends KeyPairGenerator\n@@ -48,6 +49,17 @@ public DummyKeyPairGenerator(KeyPairGeneratorSpi kpgSpi, String algorithm)\n     this.kpgSpi = kpgSpi;\n   }\n \n+  public Object clone() throws CloneNotSupportedException\n+  {\n+    if (!(kpgSpi instanceof Cloneable))\n+      throw new CloneNotSupportedException();\n+\n+    KeyPairGenerator result = new DummyKeyPairGenerator\n+\t    ((KeyPairGeneratorSpi) kpgSpi.clone(), this.getAlgorithm());\n+    result.provider = this.getProvider();\n+    return result;\n+  }\n+\n   public void initialize(int keysize, SecureRandom random)\n   {\n     kpgSpi.initialize(keysize, random);"}, {"sha": "d7e769d328e60ba7aff7b580c39c387b4f3f5a00", "filename": "libjava/java/security/DummyMessageDigest.java", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a/libjava%2Fjava%2Fsecurity%2FDummyMessageDigest.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a/libjava%2Fjava%2Fsecurity%2FDummyMessageDigest.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FDummyMessageDigest.java?ref=b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a", "patch": "@@ -1,5 +1,5 @@\n-/* DummyMessageDigest.java\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+/* DummyMessageDigest.java - Wrapper for MessageDigestSpi\n+   Copyright (C) 1999, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,10 +37,6 @@\n \n package java.security;\n \n-import java.security.MessageDigest;\n-import java.security.MessageDigestSpi;\n-import java.security.DigestException;\n-\n final class DummyMessageDigest extends MessageDigest\n {\n   private MessageDigestSpi mdSpi = null;\n@@ -51,23 +47,47 @@ public DummyMessageDigest(MessageDigestSpi mdSpi, String algorithm)\n     this.mdSpi = mdSpi;\n   }\n \n-  protected void engineUpdate(byte input)\n+  public Object clone() throws CloneNotSupportedException\n   {\n-    mdSpi.engineUpdate(input);\n+    if (!(mdSpi instanceof Cloneable))\n+      throw new CloneNotSupportedException();\n+\n+    MessageDigest result = new DummyMessageDigest\n+\t((MessageDigestSpi) mdSpi.clone(), this.getAlgorithm());\n+    result.provider = this.getProvider();\n+    return result;\n   }\n \n-  protected void engineUpdate(byte[]input, int offset, int len)\n+  // java.security.MessageDigestSpi abstract methods implementation ---------\n+\n+  public byte[] engineDigest()\n   {\n-    mdSpi.engineUpdate(input, offset, len);\n+    return mdSpi.engineDigest();\n   }\n \n-  protected byte[] engineDigest()\n+  public int engineDigest(byte[] buf, int offset, int len)\n+    throws DigestException\n   {\n-    return mdSpi.engineDigest();\n+    return mdSpi.engineDigest(buf, offset, len);\n+  }\n+\n+  public int engineGetDigestLength()\n+  {\n+    return mdSpi.engineGetDigestLength();\n   }\n \n-  protected void engineReset()\n+  public void engineReset()\n   {\n     mdSpi.engineReset();\n   }\n+\n+  public void engineUpdate(byte input)\n+  {\n+    mdSpi.engineUpdate(input);\n+  }\n+\n+  public void engineUpdate(byte[] input, int offset, int len)\n+  {\n+    mdSpi.engineUpdate(input, offset, len);\n+  }\n }"}, {"sha": "850f86d9dbcfd797bd85d4b83d3f4f98fe03941e", "filename": "libjava/java/security/DummySignature.java", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a/libjava%2Fjava%2Fsecurity%2FDummySignature.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a/libjava%2Fjava%2Fsecurity%2FDummySignature.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FDummySignature.java?ref=b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a", "patch": "@@ -1,5 +1,5 @@\n-/* DummySignature.java\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+/* DummySignature.java - Signature wrapper for SignatureSpi.\n+   Copyright (C) 1999, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -47,6 +47,17 @@ public DummySignature(SignatureSpi sigSpi, String algorithm)\n     this.sigSpi = sigSpi;\n   }\n \n+  public Object clone() throws CloneNotSupportedException\n+  {\n+    if (!(sigSpi instanceof Cloneable))\n+      throw new CloneNotSupportedException();\n+\n+    Signature result = new DummySignature\n+\t    ((SignatureSpi) sigSpi.clone(), this.getAlgorithm());\n+    result.provider = this.getProvider();\n+    return result;\n+  }\n+\n   protected void engineInitVerify(PublicKey publicKey)\n     throws InvalidKeyException\n   {"}, {"sha": "9ca1aa8ee5e6ca8dc75b9842c106b47c70653d16", "filename": "libjava/java/security/KeyPairGenerator.java", "status": "modified", "additions": 40, "deletions": 15, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a/libjava%2Fjava%2Fsecurity%2FKeyPairGenerator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a/libjava%2Fjava%2Fsecurity%2FKeyPairGenerator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FKeyPairGenerator.java?ref=b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a", "patch": "@@ -1,5 +1,5 @@\n /* KeyPairGenerator.java --- Key Pair Generator Class\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -36,6 +36,7 @@\n exception statement from your version. */\n \n package java.security;\n+\n import java.security.spec.AlgorithmParameterSpec;\n \n /**\n@@ -51,7 +52,7 @@ The KeyPairGenerator is created with the getInstance()\n  */\n public abstract class KeyPairGenerator extends KeyPairGeneratorSpi\n {\n-  private Provider provider;\n+  Provider provider;\n   private String algorithm;\n \n   /**\n@@ -83,19 +84,21 @@ public String getAlgorithm()\n      @param algorithm the name of algorithm to choose\n      @return a AlgorithmParameterGenerator repesenting the desired algorithm\n \n-     @throws NoSuchAlgorithmException if the algorithm is not implemented by providers\n+     @throws NoSuchAlgorithmException if the algorithm is not implemented by\n+     \t\t\t\t      providers\n    */\n   public static KeyPairGenerator getInstance(String algorithm) throws\n     NoSuchAlgorithmException\n   {\n     Provider[] p = Security.getProviders();\n \n-    String name = \"KeyPairGenerator.\" + algorithm;\n     for (int i = 0; i < p.length; i++)\n       {\n-\tString classname = p[i].getProperty(name);\n-\tif (classname != null)\n-\t  return getInstance(classname, algorithm, p[i]);\n+\ttry\n+\t  {\n+\t    return getInstance(algorithm, p[i]);\n+\t  }\n+\tcatch (NoSuchAlgorithmException ignored) {}\n       }\n \n     throw new NoSuchAlgorithmException(algorithm);\n@@ -110,18 +113,43 @@ public static KeyPairGenerator getInstance(String algorithm) throws\n      @param provider the name of the provider to find the algorithm in\n      @return a AlgorithmParameterGenerator repesenting the desired algorithm\n \n-     @throws NoSuchAlgorithmException if the algorithm is not implemented by the provider\n+     @throws NoSuchAlgorithmException if the algorithm is not implemented by\n+     \t\t\t\t      the provider\n      @throws NoSuchProviderException if the provider is not found\n    */\n   public static KeyPairGenerator getInstance(String algorithm, String provider)\n     throws NoSuchAlgorithmException, NoSuchProviderException\n   {\n     Provider p = Security.getProvider(provider);\n     if (p == null)\n-      throw new NoSuchProviderException();\n+      throw new NoSuchProviderException(provider);\n+\n+    return getInstance(algorithm, p);\n+  }\n \n-    return getInstance(p.getProperty(\"KeyPairGenerator.\" + algorithm),\n-\t\t       algorithm, p);\n+  private static KeyPairGenerator getInstance(String algorithm, Provider p)\n+    throws NoSuchAlgorithmException\n+  {\n+    // try the name as is\n+    String className = p.getProperty(\"KeyPairGenerator.\" + algorithm);\n+    if (className == null) { // try all uppercase\n+      String upper = algorithm.toUpperCase();\n+      className = p.getProperty(\"KeyPairGenerator.\" + upper);\n+      if (className == null) { // try if it's an alias\n+        String alias = p.getProperty(\"Alg.Alias.KeyPairGenerator.\" + algorithm);\n+        if (alias == null) { // try all-uppercase alias name\n+          alias = p.getProperty(\"Alg.Alias.KeyPairGenerator.\" + upper);\n+          if (alias == null) { // spit the dummy\n+            throw new NoSuchAlgorithmException(algorithm);\n+          }\n+        }\n+        className = p.getProperty(\"KeyPairGenerator.\" + alias);\n+        if (className == null) {\n+          throw new NoSuchAlgorithmException(algorithm);\n+        }\n+      }\n+    }\n+    return getInstance(className, algorithm, p);\n   }\n \n   private static KeyPairGenerator getInstance(String classname,\n@@ -134,10 +162,7 @@ private static KeyPairGenerator getInstance(String classname,\n \tObject o = Class.forName(classname).newInstance();\n \tKeyPairGenerator kpg;\n \tif (o instanceof KeyPairGeneratorSpi)\n-\t  kpg =\n-\t    (KeyPairGenerator) (new\n-\t\t\t\tDummyKeyPairGenerator((KeyPairGeneratorSpi) o,\n-\t\t\t\t\t\t      algorithm));\n+\t  kpg = new DummyKeyPairGenerator((KeyPairGeneratorSpi) o, algorithm);\n \telse\n \t  {\n \t    kpg = (KeyPairGenerator) o;"}, {"sha": "735dd6498f97ea8b81b0bfa32e9770f851ef93b3", "filename": "libjava/java/security/KeyPairGeneratorSpi.java", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a/libjava%2Fjava%2Fsecurity%2FKeyPairGeneratorSpi.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a/libjava%2Fjava%2Fsecurity%2FKeyPairGeneratorSpi.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FKeyPairGeneratorSpi.java?ref=b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a", "patch": "@@ -1,5 +1,5 @@\n /* KeyPairGeneratorSpi.java --- Key Pair Generator SPI Class\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -90,4 +90,20 @@ public void initialize(AlgorithmParameterSpec params, SecureRandom random)\n      @return a key pair\n    */\n   public abstract KeyPair generateKeyPair();\n+\n+  /**\n+     Returns a clone of this class.\n+\n+     If cloning is not supported, then by default the class throws a\n+     CloneNotSupportedException.  The MessageDigestSpi provider\n+     implementation has to overload this class in order to be\n+     cloneable.\n+   */\n+  public Object clone() throws CloneNotSupportedException\n+  {\n+    if (this instanceof Cloneable)\n+      return super.clone();\n+    else\n+      throw new CloneNotSupportedException();\n+  }\n }"}, {"sha": "10032f220123ba55cfee46570fe376c61da07fab", "filename": "libjava/java/security/MessageDigest.java", "status": "modified", "additions": 53, "deletions": 17, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a/libjava%2Fjava%2Fsecurity%2FMessageDigest.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a/libjava%2Fjava%2Fsecurity%2FMessageDigest.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FMessageDigest.java?ref=b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a", "patch": "@@ -1,5 +1,6 @@\n+\n /* MessageDigest.java --- The message digest interface.\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -40,7 +41,7 @@\n public abstract class MessageDigest extends MessageDigestSpi\n {\n   private String algorithm;\n-  private Provider provider;\n+  Provider provider;\n   private byte[] lastDigest;\n \n   /**\n@@ -63,19 +64,20 @@ protected MessageDigest(String algorithm)\n      @param algorithm the name of digest algorithm to choose\n      @return a MessageDigest representing the desired algorithm\n \n-     @exception NoSuchAlgorithmException if the algorithm is not implemented by providers\n+     @exception NoSuchAlgorithmException if the algorithm is not implemented by\n+    \t\t\t\t\t providers\n    */\n   public static MessageDigest getInstance(String algorithm)\n     throws NoSuchAlgorithmException\n   {\n     Provider[] p = Security.getProviders();\n-    String name = \"MessageDigest.\" + algorithm;\n-\n     for (int i = 0; i < p.length; i++)\n       {\n-\tString classname = p[i].getProperty(name);\n-\tif (classname != null)\n-\t  return getInstance(classname, algorithm, p[i]);\n+\ttry\n+\t  {\n+\t    return getInstance(algorithm, p[i]);\n+\t  }\n+\tcatch (NoSuchAlgorithmException ignored) {}\n       }\n \n     throw new NoSuchAlgorithmException(algorithm);\n@@ -92,7 +94,8 @@ public static MessageDigest getInstance(String algorithm)\n      @param provider the name of the provider to find the algorithm in\n      @return a MessageDigest representing the desired algorithm\n \n-     @exception NoSuchAlgorithmException if the algorithm is not implemented by the provider\n+     @exception NoSuchAlgorithmException if the algorithm is not implemented by\n+     \t\t\t\t\t the provider\n      @exception NoSuchProviderException if the provider is not found\n    */\n \n@@ -104,8 +107,32 @@ public static MessageDigest getInstance(String algorithm, String provider)\n     if (p == null)\n       throw new NoSuchProviderException(provider);\n \n-    return getInstance(p.getProperty(\"MessageDigest.\" + algorithm),\n-\t\t       algorithm, p);\n+    return getInstance(algorithm, p);\n+  }\n+\n+  private static MessageDigest getInstance(String algorithm, Provider p)\n+    throws NoSuchAlgorithmException\n+  {\n+    // try the name as is\n+    String className = p.getProperty(\"MessageDigest.\" + algorithm);\n+    if (className == null) { // try all uppercase\n+      String upper = algorithm.toUpperCase();\n+      className = p.getProperty(\"MessageDigest.\" + upper);\n+      if (className == null) { // try if it's an alias\n+        String alias = p.getProperty(\"Alg.Alias.MessageDigest.\" +algorithm);\n+        if (alias == null) { // try all-uppercase alias name\n+          alias = p.getProperty(\"Alg.Alias.MessageDigest.\" +upper);\n+          if (alias == null) { // spit the dummy\n+            throw new NoSuchAlgorithmException(algorithm);\n+          }\n+        }\n+        className = p.getProperty(\"MessageDigest.\" + alias);\n+        if (className == null) {\n+          throw new NoSuchAlgorithmException(algorithm);\n+        }\n+      }\n+    }\n+    return getInstance(className, algorithm, p);\n   }\n \n   private static MessageDigest getInstance(String classname,\n@@ -116,13 +143,22 @@ private static MessageDigest getInstance(String classname,\n     if (classname == null)\n       throw new NoSuchAlgorithmException(algorithm);\n \n+    MessageDigest result = null;\n     try\n       {\n-\tMessageDigest m =\n-\t  (MessageDigest) Class.forName(classname).newInstance();\n-\tm.algorithm = algorithm;\n-\tm.provider = provider;\n-\treturn m;\n+        Object obj = Class.forName(classname).newInstance();\n+        if (obj instanceof MessageDigest) {\n+          result = (MessageDigest) obj;\n+          result.algorithm = algorithm;\n+        } else if (obj instanceof MessageDigestSpi) {\n+          result = new DummyMessageDigest((MessageDigestSpi) obj, algorithm);\n+        } else {\n+          throw new ClassCastException(\"Class \"+classname+\" from Provider \"\n+              +provider.getName()\n+              +\" does not extend java.security.MessageDigestSpi\");\n+        }\n+        result.provider = provider;\n+        return result;\n       }\n     catch (ClassNotFoundException cnfe)\n       {\n@@ -212,7 +248,7 @@ public int digest(byte[]buf, int offset, int len) throws DigestException\n      then computes a final digest and returns it. It calls \n      update(input) and then digest();\n \n-     @param buf An array of bytes to perform final update with\n+     @param input An array of bytes to perform final update with\n      @return a byte array representing the message digest\n    */\n   public byte[] digest(byte[]input)"}, {"sha": "c40a980aaa39ea804a6880620676ba0d8499355e", "filename": "libjava/java/security/Provider.java", "status": "modified", "additions": 41, "deletions": 8, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a/libjava%2Fjava%2Fsecurity%2FProvider.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a/libjava%2Fjava%2Fsecurity%2FProvider.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FProvider.java?ref=b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a", "patch": "@@ -1,5 +1,5 @@\n /* Provider.java -- Security provider information\n-   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -119,16 +119,40 @@ public String getInfo()\n   }\n \n   /**\n-   * This method sets the specified key to have the specified value.\n+   * Sets the key property to have the specified value.\n+   * <p>\n+   * <bold>NOT IMPLEMENTED YET</bold>[\n+   * First, if there is a security manager, its <code>checkSecurityAccess</code>\n+   * method is called with the string \"putProviderProperty.\"+name, where name is\n+   * the provider name, to see if it's ok to set this provider's property\n+   * values.\n+   * If the default implementation of <code>checkSecurityAccess</code> is used\n+   * (that is, that method is not overriden), then this results in a call to the\n+   * security manager's <code>checkPermission</code> method with a\n+   * <code>SecurityPermission(\"putProviderProperty.\"+name)</code>\n+   * permission.<br>]\n    *\n-   * @param key The property key\n-   * @param value The property value\n+   * @param key The property key.\n+   * @param value The property value.\n    *\n-   * @return The previous value for this key, or <code>null</code> if no previous value.\n+   * @return The previous value of the specified property (<code>key</code>),\n+   *         or <code>null</code> if it did not have one.\n+   * @throws SecurityException If a security manager exists and its\n+   * {@link java.lang.SecurityManager.checkSecurityAccess(java.lang.String)}\n+   * method denies access to set property values.\n+   * @since Classpath 0.4+cvs, JDK 1.2\n+   * @see java.lang.Object.equals(Object)\n+   * @see java.util.Hashtable.get(Object)\n    */\n   public Object put(Object key, Object value)\n   {\n-    return (super.put(key, value));\n+    return super.put(toCanonicalKey(key), value);\n+  }\n+  \n+  // overrides same in java.util.Hashtable\n+  public Object get(Object key)\n+  {\n+    return super.get(toCanonicalKey(key));\n   }\n \n   /**\n@@ -137,11 +161,12 @@ public Object put(Object key, Object value)\n    * \n    * @param key The key to remove\n    *\n-   * @return The previous value for this key, or <code>null</code> if no previous value.\n+   * @return The previous value for this key, or <code>null</code> if no\n+   * previous value.\n    */\n   public Object remove(Object key)\n   {\n-    return (super.remove(key));\n+    return super.remove(toCanonicalKey(key));\n   }\n \n   /**\n@@ -166,4 +191,12 @@ public String toString()\n     return (getClass().getName() + \": name=\" + getName() + \" version=\" +\n \t    version);\n   }\n+  \n+  private Object toCanonicalKey(Object key)\n+  {\n+    if (key.getClass().isAssignableFrom(String.class)) // is it ours?\n+      return ((String) key).toUpperCase(); // use default locale\n+    else\n+      return key;\n+  }\n }"}, {"sha": "8c84c3f79786242727be04e92e9152902687fc6c", "filename": "libjava/java/security/Security.java", "status": "modified", "additions": 59, "deletions": 38, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a/libjava%2Fjava%2Fsecurity%2FSecurity.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a/libjava%2Fjava%2Fsecurity%2FSecurity.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FSecurity.java?ref=b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a", "patch": "@@ -1,5 +1,5 @@\n /* Security.java --- Java base security class implmentation\n-   Copyright (C) 1999, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -127,8 +127,8 @@ private static void loadProviders(String dir, String vendor)\n   }\n \n   /**\n-     Gets a specific property for an algorithm. This is used to produce specialized\n-     algorithm parsers.\n+     Gets a specific property for an algorithm. This is used to produce\n+     specialized algorithm parsers.\n \n      @deprecated it used to a return the value of a propietary property\n      for the \"SUN\" Cryptographic Service Provider to obtain \n@@ -147,28 +147,45 @@ public static String getAlgorithmProperty(String algName, String propName)\n   }\n \n   /**\n-     Adds a new provider at the specified position. This allows dynamic loading\n-     of providers. It will check for duplication of providers.\n-\n-     This class checks the security manager with the call checkSecurityAccess\n-     with \"insertProvider.\"+provider.getName() to see if the user can add this\n-     provider.\n-\n-     @param provider the provider to add\n-     @param position position to add the provider at\n-\n-     @return the position the provider was added at, or -1 if a duplicate provider\n-     was found\n-\n-     @throws SecurityException - if the security manager denies access to add a \n-     new provider\n+     Adds a new provider, at a specified position. The position is the\n+     preference order in which providers are searched for requested algorithms.\n+     Note that it is not guaranteed that this preference will be respected. The\n+     position is 1-based, that is, 1 is most preferred, followed by 2, and so\n+     on.\n+     <p>\n+     If the given provider is installed at the requested position, the\n+     provider that used to be at that position, and all providers with a\n+     position greater than position, are shifted up one position (towards the\n+     end of the list of installed providers).\n+     <p>\n+     A provider cannot be added if it is already installed.\n+     <p>\n+     <b>NOT IMPLEMENTED YET:</b>[\n+     First, if there is a security manager, its <code>checkSecurityAccess</code>\n+     method is called with the string\n+     <code>\"insertProvider.\"+provider.getName()</code>\n+     to see if it's ok to add a new provider. If the default implementation of\n+     <code>checkSecurityAccess</code> is used (i.e., that method is not\n+     overriden), then this will result in a call to the security manager's\n+     <code>checkPermission</code> method with a <code>SecurityPermission(\n+     \"insertProvider.\"+provider.getName())</code> permission.]\n+\n+     @param provider the provider to be added.\n+     @param position the preference position that the caller would like for\n+     this provider.\n+     @return the actual preference position (1-based) in which the provider was\n+     added, or -1 if the provider was not added because it is already installed.\n+     @throws SecurityException if a security manager exists and its <code>\n+     SecurityManager.checkSecurityAccess(java.lang.String)</code> method denies\n+     access to add a new provider.\n    */\n   public static int insertProviderAt(Provider provider, int position)\n   {\n     SecurityManager sm = System.getSecurityManager();\n     if (sm != null)\n       sm.checkSecurityAccess(\"insertProvider.\" + provider.getName());\n \n+    position--;\n     int max = providers.size ();\n     for (int i = 0; i < max; i++)\n       {\n@@ -184,29 +201,33 @@ public static int insertProviderAt(Provider provider, int position)\n \n     providers.insertElementAt(provider, position);\n \n-    return position;\n+    return position + 1;\n   }\n \n \n   /**\n-     Adds a new provider. This allows dynamic loading\n-     of providers. It will check for duplication of providers.\n-\n-     This method checks the security manager with the call checkSecurityAccess\n-     with \"insertProvider.\"+provider.getName() to see if the user can add this\n-     provider.\n-\n-     @param provider the provider to add\n-\n-     @return the position the provider was added at, or -1 if a duplicate provider\n-     was found\n-\n-     @throws SecurityException - if the security manager denies access to add a \n-     new provider\n+     Adds a provider to the next position available.\n+     <p>\n+     <b>NOT IMPLEMENTED YET:</b> [\n+     First, if there is a security manager, its <code>checkSecurityAccess</code>\n+     method is called with the string\n+     <code>\"insertProvider.\"+provider.getName()</code>\n+     to see if it's ok to add a new provider. If the default implementation of\n+     <code>checkSecurityAccess</code> is used (i.e., that method is not\n+     overriden), then this will result in a call to the security manager's\n+     <code>checkPermission</code> method with a <code>SecurityPermission(\n+     \"insertProvider.\"+provider.getName())</code> permission.]\n+\n+     @param provider the provider to be added.\n+     @return the preference position in which the provider was added, or <code>\n+     -1</code> if the provider was not added because it is already installed.\n+     @throws SecurityException if a security manager exists and its <code>\n+     SecurityManager.checkSecurityAccess(java.lang.String)</code> method denies\n+     access to add a new provider.\n    */\n   public static int addProvider(Provider provider)\n   {\n-    return insertProviderAt (provider, providers.size ());\n+    return insertProviderAt (provider, providers.size () + 1);\n   }\n \n   /**\n@@ -215,13 +236,13 @@ public static int addProvider(Provider provider)\n      ranking. If the provider is not installed, it fails silently.\n \n      This method checks the security manager with the call checkSecurityAccess\n-     with \"removeProvider.\"+provider.getName() to see if the user can remove this\n-     provider.\n+     with \"removeProvider.\"+provider.getName() to see if the user can remove\n+     this provider.\n \n      @param name name of the provider to add\n \n-     @throws SecurityException - if the security manager denies access to remove a \n-     new provider\n+     @throws SecurityException - if the security manager denies access to\n+     remove a new provider\n    */\n   public static void removeProvider(String name)\n   {"}, {"sha": "209a7df7604f8493aff2b58653b46cf03eab4122", "filename": "libjava/java/security/Signature.java", "status": "modified", "additions": 46, "deletions": 21, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a/libjava%2Fjava%2Fsecurity%2FSignature.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a/libjava%2Fjava%2Fsecurity%2FSignature.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FSignature.java?ref=b0fc58713dc5c60f3a0bbe792124c37eb97d5d5a", "patch": "@@ -1,5 +1,5 @@\n /* Signature.java --- Signature Class\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -58,15 +58,12 @@\n \n    1. Initialing\n \n-   * It must be initialized with a private key for \n-   signing. \n-   * It must be initialized with a public key for \n-   verifying.\n+   * It must be initialized with a private key for signing.\n+   * It must be initialized with a public key for verifying.\n \n    2. Updating\n \n-   Update the bytes for signing or verifying with calls \n-   to update.\n+   Update the bytes for signing or verifying with calls to update.\n \n    3. Signing or Verify the signature on the currently stored\n    bytes by calling sign or verify.\n@@ -100,7 +97,7 @@ public abstract class Signature extends SignatureSpi\n   protected int state = UNINITIALIZED;\n \n   private String algorithm;\n-  private Provider provider;\n+  Provider provider;\n \n   /**\n      Creates a new signature for this algorithm.\n@@ -113,27 +110,29 @@ protected Signature(String algorithm)\n     state = UNINITIALIZED;\n   }\n \n-  /** \n+  /**\n      Gets an instance of the Signature class representing\n      the specified signature. If the algorithm is not found then, \n      it throws NoSuchAlgorithmException.\n \n      @param algorithm the name of signature algorithm to choose\n      @return a Signature repesenting the desired algorithm\n \n-     @throws NoSuchAlgorithmException if the algorithm is not implemented by providers\n+     @throws NoSuchAlgorithmException if the algorithm is not implemented by\n+     \t\t\t\t      providers\n    */\n   public static Signature getInstance(String algorithm)\n     throws NoSuchAlgorithmException\n   {\n-    String name = \"Signature.\" + algorithm;\n     Provider[] p = Security.getProviders();\n \n     for (int i = 0; i < p.length; i++)\n       {\n-\tString classname = p[i].getProperty(name);\n-\tif (classname != null)\n-\t  return getInstance(classname, algorithm, p[i]);\n+        try\n+          {\n+            return getInstance(algorithm, p[i]);\n+          }\n+        catch (NoSuchAlgorithmException ignored) {}\n       }\n \n     throw new NoSuchAlgorithmException(algorithm);\n@@ -150,17 +149,43 @@ public static Signature getInstance(String algorithm)\n      @param provider the name of the provider to find the algorithm in\n      @return a Signature repesenting the desired algorithm\n \n-     @throws NoSuchAlgorithmException if the algorithm is not implemented by the provider\n+     @throws NoSuchAlgorithmException if the algorithm is not implemented by\n+\t\t\t\t      the provider\n      @throws NoSuchProviderException if the provider is not found\n    */\n   public static Signature getInstance(String algorithm, String provider)\n     throws NoSuchAlgorithmException, NoSuchProviderException\n   {\n     Provider p = Security.getProvider(provider);\n     if (p == null)\n-      throw new NoSuchProviderException();\n+      throw new NoSuchProviderException(provider);\n+\n+    return getInstance(algorithm, p);\n+  }\n \n-    return getInstance(p.getProperty(\"Signature.\" + algorithm), algorithm, p);\n+  private static Signature getInstance(String algorithm, Provider p)\n+    throws NoSuchAlgorithmException\n+  {\n+    // try the name as is\n+    String className = p.getProperty(\"Signature.\" + algorithm);\n+    if (className == null) { // try all uppercase\n+      String upper = algorithm.toUpperCase();\n+      className = p.getProperty(\"Signature.\" + upper);\n+      if (className == null) { // try if it's an alias\n+        String alias = p.getProperty(\"Alg.Alias.Signature.\" + algorithm);\n+        if (alias == null) {\n+          alias = p.getProperty(\"Alg.Alias.Signature.\" + upper);\n+          if (alias == null) { // spit the dummy\n+            throw new NoSuchAlgorithmException(algorithm);\n+          }\n+        }\n+        className = p.getProperty(\"Signature.\" + alias);\n+        if (className == null) {\n+          throw new NoSuchAlgorithmException(algorithm);\n+        }\n+      }\n+    }\n+    return getInstance(className, algorithm, p);\n   }\n \n   private static Signature getInstance(String classname,\n@@ -173,7 +198,7 @@ private static Signature getInstance(String classname,\n \tObject o = Class.forName(classname).newInstance();\n \tSignature sig;\n \tif (o instanceof SignatureSpi)\n-\t  sig = (Signature) (new DummySignature((SignatureSpi) o, algorithm));\n+\t  sig = new DummySignature((SignatureSpi) o, algorithm);\n \telse\n \t  {\n \t    sig = (Signature) o;\n@@ -200,7 +225,7 @@ private static Signature getInstance(String classname,\n   /**\n      Gets the provider that the Signature is from.\n \n-     @return the provider the this Signature \n+     @return the provider of this Signature\n    */\n   public final Provider getProvider()\n   {\n@@ -310,7 +335,7 @@ public final byte[] sign() throws SignatureException\n      initial state and can be used to generate additional\n      signatures.\n \n-     @param outbuff array of bytes\n+     @param outbuf array of bytes\n      @param offset the offset to start at in the array\n      @param len the length of the bytes to put into the array. \n      Neither this method or the GNU provider will \n@@ -325,7 +350,7 @@ public final byte[] sign() throws SignatureException\n \n      @since JDK 1.2\n    */\n-  public final int sign(byte[]outbuf, int offset, int len)\n+  public final int sign(byte[] outbuf, int offset, int len)\n     throws SignatureException\n   {\n     if (state == SIGN)"}]}