{"sha": "ac8d99218adb7edeac58e9f1e87af09bb77dfdc0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM4ZDk5MjE4YWRiN2VkZWFjNThlOWYxZTg3YWYwOWJiNzdkZmRjMA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-08-15T20:46:48Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-08-15T20:46:48Z"}, "message": "jni.cc: Include IdentityHashMap.h, not Hashtable.h.\n\n\t* jni.cc: Include IdentityHashMap.h, not Hashtable.h.\n\t(local_ref_table, global_ref_table): Now IdentityHashMap.\n\t(_Jv_JNI_Init): Updated for new types.\n\t(mark_for_gc): Likewise.\n\t(unmark_for_gc): Likewise.\n\t* gcj/javaprims.h: Rebuilt class list.\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am (core_java_source_files): Added new file.\n\t* java/util/IdentityHashMap.java: New file.\n\nFrom-SVN: r44929", "tree": {"sha": "d099a29d870b1dc6ae2826afefdb9b3e3572acbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d099a29d870b1dc6ae2826afefdb9b3e3572acbc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac8d99218adb7edeac58e9f1e87af09bb77dfdc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac8d99218adb7edeac58e9f1e87af09bb77dfdc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac8d99218adb7edeac58e9f1e87af09bb77dfdc0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac8d99218adb7edeac58e9f1e87af09bb77dfdc0/comments", "author": null, "committer": null, "parents": [{"sha": "369e1d74c6c3ffc4acb1c6c3defabd9ba19401b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/369e1d74c6c3ffc4acb1c6c3defabd9ba19401b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/369e1d74c6c3ffc4acb1c6c3defabd9ba19401b9"}], "stats": {"total": 453, "additions": 442, "deletions": 11}, "files": [{"sha": "b78bcf3ccee0ea0908ead8028fa0585a66e49822", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8d99218adb7edeac58e9f1e87af09bb77dfdc0/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8d99218adb7edeac58e9f1e87af09bb77dfdc0/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=ac8d99218adb7edeac58e9f1e87af09bb77dfdc0", "patch": "@@ -1,5 +1,15 @@\n 2001-08-15  Tom Tromey  <tromey@redhat.com>\n \n+\t* jni.cc: Include IdentityHashMap.h, not Hashtable.h.\n+\t(local_ref_table, global_ref_table): Now IdentityHashMap.\n+\t(_Jv_JNI_Init): Updated for new types.\n+\t(mark_for_gc): Likewise.\n+\t(unmark_for_gc): Likewise.\n+\t* gcj/javaprims.h: Rebuilt class list.\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (core_java_source_files): Added new file.\n+\t* java/util/IdentityHashMap.java: New file.\n+\n \t* gnu/gcj/convert/natIconv.cc (read): Handle EINVAL and E2BIG\n \tcorrectly.\n "}, {"sha": "382d4ef0bcc7c5ce94e04e0711086f3680c21481", "filename": "libjava/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8d99218adb7edeac58e9f1e87af09bb77dfdc0/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8d99218adb7edeac58e9f1e87af09bb77dfdc0/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=ac8d99218adb7edeac58e9f1e87af09bb77dfdc0", "patch": "@@ -947,6 +947,7 @@ java/util/GregorianCalendar.java \\\n java/util/HashMap.java \\\n java/util/HashSet.java \\\n java/util/Hashtable.java \\\n+java/util/IdentityHashMap.java \\\n java/util/Iterator.java\t\\\n java/util/LinkedList.java \\\n java/util/List.java \\"}, {"sha": "26f08773bdd041f60bd7fc7c80f6d91fffb0ad0c", "filename": "libjava/Makefile.in", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8d99218adb7edeac58e9f1e87af09bb77dfdc0/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8d99218adb7edeac58e9f1e87af09bb77dfdc0/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=ac8d99218adb7edeac58e9f1e87af09bb77dfdc0", "patch": "@@ -717,6 +717,7 @@ java/util/GregorianCalendar.java \\\n java/util/HashMap.java \\\n java/util/HashSet.java \\\n java/util/Hashtable.java \\\n+java/util/IdentityHashMap.java \\\n java/util/Iterator.java\t\\\n java/util/LinkedList.java \\\n java/util/List.java \\\n@@ -1859,10 +1860,11 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/util/EventListener.P .deps/java/util/EventObject.P \\\n .deps/java/util/GregorianCalendar.P .deps/java/util/HashMap.P \\\n .deps/java/util/HashSet.P .deps/java/util/Hashtable.P \\\n-.deps/java/util/Iterator.P .deps/java/util/LinkedList.P \\\n-.deps/java/util/List.P .deps/java/util/ListIterator.P \\\n-.deps/java/util/ListResourceBundle.P .deps/java/util/Locale.P \\\n-.deps/java/util/Map.P .deps/java/util/MissingResourceException.P \\\n+.deps/java/util/IdentityHashMap.P .deps/java/util/Iterator.P \\\n+.deps/java/util/LinkedList.P .deps/java/util/List.P \\\n+.deps/java/util/ListIterator.P .deps/java/util/ListResourceBundle.P \\\n+.deps/java/util/Locale.P .deps/java/util/Map.P \\\n+.deps/java/util/MissingResourceException.P \\\n .deps/java/util/NoSuchElementException.P .deps/java/util/Observable.P \\\n .deps/java/util/Observer.P .deps/java/util/Properties.P \\\n .deps/java/util/PropertyPermission.P \\"}, {"sha": "2ecf2305c2025ef679a25ade811b3d1e608a35f8", "filename": "libjava/gcj/javaprims.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8d99218adb7edeac58e9f1e87af09bb77dfdc0/libjava%2Fgcj%2Fjavaprims.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8d99218adb7edeac58e9f1e87af09bb77dfdc0/libjava%2Fgcj%2Fjavaprims.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fjavaprims.h?ref=ac8d99218adb7edeac58e9f1e87af09bb77dfdc0", "patch": "@@ -280,6 +280,8 @@ extern \"Java\"\n       class Hashtable$Entry;\n       class Hashtable$Enumerator;\n       class Hashtable$HashIterator;\n+      class IdentityHashMap;\n+      class IdentityHashMap$IdentityIterator;\n       class Iterator;\n       class LinkedList;\n       class LinkedList$Entry;"}, {"sha": "374f09e70d1e4bb0aa25c826471e7b908aa7e768", "filename": "libjava/java/util/IdentityHashMap.java", "status": "added", "additions": 415, "deletions": 0, "changes": 415, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8d99218adb7edeac58e9f1e87af09bb77dfdc0/libjava%2Fjava%2Futil%2FIdentityHashMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8d99218adb7edeac58e9f1e87af09bb77dfdc0/libjava%2Fjava%2Futil%2FIdentityHashMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FIdentityHashMap.java?ref=ac8d99218adb7edeac58e9f1e87af09bb77dfdc0", "patch": "@@ -0,0 +1,415 @@\n+/* IdentityHashMap.java -- a class providing a hashtable data structure,\n+   mapping Object --> Object, which uses object identity for hashing.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+package java.util;\n+\n+import java.io.*;\n+\n+/**\n+ * This class provides a hashtable-backed implementation of the\n+ * Map interface.  Unlike HashMap, it uses object identity to\n+ * do its hashing.  Also, it uses a linear-probe hash table.\n+ *\n+ * @author Tom Tromey <tromey@redhat.com>\n+ * @since 1.4\n+ */\n+public class IdentityHashMap extends AbstractMap\n+  implements Map, Serializable, Cloneable\n+{\n+  private static final int DEFAULT_CAPACITY = 21;\n+\n+  /** Create a new IdentityHashMap with the default capacity (21\n+   * entries).\n+   */\n+  public IdentityHashMap ()\n+  {\n+    this (DEFAULT_CAPACITY);\n+  }\n+\n+  /** Create a new IdentityHashMap with the indicated number of\n+   * entries.  If the number of elements added to this hash map\n+   * exceeds this maximum, the map will grow itself; however, that\n+   * incurs a performance penalty.\n+   * @param max Initial size\n+   */\n+  public IdentityHashMap (int max)\n+  {\n+    if (max < 0)\n+      throw new IllegalArgumentException ();\n+    table = new Object[2 * max];\n+    Arrays.fill (table, emptyslot);\n+    size = 0;\n+  }\n+\n+  /** Create a new IdentityHashMap whose contents are taken from the\n+   * given Map.\n+   * @param m The map whose elements are to be put in this map.\n+   */\n+  public IdentityHashMap (Map m)\n+  {\n+    int len = 2 * Math.max (m.size (), DEFAULT_CAPACITY);\n+    table = new Object[len];\n+    Arrays.fill (table, emptyslot);\n+    putAll (m);\n+  }\n+\n+  public void clear ()\n+  {\n+    Arrays.fill (table, emptyslot);\n+    size = 0;\n+  }\n+\n+  public Object clone ()\n+  {\n+    IdentityHashMap copy = (IdentityHashMap) super.clone ();\n+    copy.table = (Object[]) table.clone ();\n+    return copy;\n+  }\n+\n+  public boolean containsKey (Object key)\n+  {\n+    int h = Math.abs (2 * System.identityHashCode (key) % table.length);\n+    int save = h;\n+    while (true)\n+      {\n+\tif (table[h] == key)\n+\t  return true;\n+\tif (table[h] == emptyslot)\n+\t  return false;\n+\th += 2;\n+\tif (h > table.length)\n+\t  h = 0;\n+\tif (h == save)\n+\t  return false;\n+      }\n+  }\n+\n+  public boolean containsValue (Object value)\n+  {\n+    for (int i = 1; i < table.length; i += 2)\n+      if (table[i] == value)\n+\treturn true;\n+    return false;\n+  }\n+\n+  public Set entrySet ()\n+  {\n+    return new AbstractSet ()\n+    {\n+      public int size ()\n+      {\n+\treturn size;\n+      }\n+\n+      public Iterator iterator ()\n+      {\n+\treturn new IdentityIterator (IdentityIterator.ENTRIES);\n+      }\n+\n+      public void clear ()\n+      {\n+\tIdentityHashMap.this.clear ();\n+      }\n+\n+      public boolean contains (Object o)\n+      {\n+\tif (! (o instanceof Map.Entry))\n+\t  return false;\n+\tMap.Entry m = (Map.Entry) o;\n+\treturn (IdentityHashMap.this.containsKey (m.getKey ())\n+\t\t&& IdentityHashMap.this.get (m.getKey ()) == m.getValue ());\n+      }\n+\n+      public boolean remove (Object o)\n+      {\n+\tif (! (o instanceof Map.Entry))\n+\t  return false;\n+\tMap.Entry m = (Map.Entry) o;\n+\tif (IdentityHashMap.this.containsKey (m.getKey ())\n+\t    && IdentityHashMap.this.get (m.getKey ()) == m.getValue ())\n+\t  {\n+\t    int oldsize = size;\n+\t    IdentityHashMap.this.remove (m.getKey ());\n+\t    return oldsize != size;\n+\t  }\n+\treturn false;\n+      }\n+    };\n+  }\n+\n+  public Object get (Object key)\n+  {\n+    int h = Math.abs (2 * System.identityHashCode (key) % table.length);\n+    int save = h;\n+    while (true)\n+      {\n+\tif (table[h] == key)\n+\t  return table[h + 1];\n+\tif (table[h] == emptyslot)\n+\t  return null;\n+\th += 2;\n+\tif (h > table.length)\n+\t  h = 0;\n+\tif (h == save)\n+\t  return null;\n+      }\n+  }\n+\n+  public boolean isEmpty ()\n+  {\n+    return size == 0;\n+  }\n+\n+  public Set keySet ()\n+  {\n+    return new AbstractSet ()\n+    {\n+      public int size ()\n+      {\n+\treturn size;\n+      }\n+\n+      public Iterator iterator ()\n+      {\n+\treturn new IdentityIterator (IdentityIterator.KEYS);\n+      }\n+\n+      public void clear ()\n+      {\n+\tIdentityHashMap.this.clear ();\n+      }\n+\n+      public boolean contains (Object o)\n+      {\n+\treturn IdentityHashMap.this.containsKey (o);\n+      }\n+\n+      public boolean remove (Object o)\n+      {\n+\tint oldsize = size;\n+\tIdentityHashMap.this.remove (o);\n+\treturn oldsize != size;\n+      }\n+    };\n+  }\n+\n+  public Object put (Object key, Object value)\n+  {\n+    // Rehash is the load factor is too high.\n+    if (size * 3 / 2 > table.length)\n+      {\n+\tObject[] old = table;\n+\ttable = new Object[old.length * 2];\n+\tArrays.fill (table, emptyslot);\n+\tsize = 0;\n+\tfor (int i = 0; i < old.length; ++i)\n+\t  {\n+\t    if (old[i] != tombstone && old[i] != emptyslot)\n+\t      {\n+\t\t// Just use put.  This isn't very efficient, but it is\n+\t\t// ok.\n+\t\tput (old[i], old[i + 1]);\n+\t      }\n+\t  }\n+      }\n+\n+    int h = Math.abs (2 * System.identityHashCode (key) % table.length);\n+    int save = h;\n+    int del = -1;\n+    while (true)\n+      {\n+\tif (table[h] == key)\n+\t  {\n+\t    Object r = table[h + 1];\n+\t    table[h + 1] = value;\n+\t    return r;\n+\t  }\n+\telse if (table[h] == tombstone && del == -1)\n+\t  del = h;\n+\telse if (table[h] == emptyslot)\n+\t  {\n+\t    if (del == -1)\n+\t      del = h;\n+\t    break;\n+\t  }\n+\th += 2;\n+\tif (h > table.length)\n+\t  h = 0;\n+\tif (h == save)\n+\t  break;\n+      }\n+\n+    if (del != -1)\n+      {\n+\ttable[del] = key;\n+\ttable[del + 1] = value;\n+\t++size;\n+\treturn null;\n+      }\n+\n+    // This is an error.\n+    return null;\n+  }\n+\n+  public Object remove (Object key)\n+  {\n+    int h = Math.abs (2 * System.identityHashCode (key) % table.length);\n+    int save = h;\n+    while (true)\n+      {\n+\tif (table[h] == key)\n+\t  {\n+\t    Object r = table[h + 1];\n+\t    table[h] = tombstone;\n+\t    table[h + 1] = tombstone;\n+\t    --size;\n+\t    return r;\n+\t  }\n+\th += 2;\n+\tif (h > table.length)\n+\t  h = 0;\n+\tif (h == save)\n+\t  break;\n+      }\n+\n+    return null;\n+  }\n+\n+  public int size ()\n+  {\n+    return size;\n+  }\n+\n+  public Collection values ()\n+  {\n+    return new AbstractCollection ()\n+    {\n+      public int size ()\n+      {\n+\treturn size;\n+      }\n+\n+      public Iterator iterator ()\n+      {\n+\treturn new IdentityIterator (IdentityIterator.VALUES);\n+      }\n+\n+      public void clear ()\n+      {\n+\tIdentityHashMap.this.clear ();\n+      }\n+    };\n+  }\n+\n+  private class IdentityIterator implements Iterator\n+  {\n+    static final int KEYS = 0;\n+    static final int VALUES = 1;\n+    static final int ENTRIES = 2;\n+\n+    // Type of iterator.\n+    int type;\n+    // Location in the table.\n+    int loc;\n+    // How many items we've seen.\n+    int seen;\n+\n+    IdentityIterator (int type)\n+    {\n+      this.type = type;\n+      loc = 0;\n+      seen = 0;\n+    }\n+\n+    public boolean hasNext ()\n+    {\n+      return seen < size;\n+    }\n+\n+    public Object next ()\n+    {\n+      while (true)\n+\t{\n+\t  loc += 2;\n+\t  if (loc >= table.length)\n+\t    throw new NoSuchElementException ();\n+\t  if (table[loc] != tombstone && table[loc] != emptyslot)\n+\t    {\n+\t      ++seen;\n+\t      return table[loc];\n+\t    }\n+\t}\n+    }\n+\n+    public void remove ()\n+    {\n+      if (loc >= table.length\n+\t  || table[loc] == tombstone\n+\t  || table[loc] == emptyslot)\n+\tthrow new IllegalStateException ();\n+      table[loc] = tombstone;\n+      table[loc + 1] = tombstone;\n+      --size;\n+    }\n+  }\n+\n+  private void readObject (ObjectInputStream s)\n+    throws IOException, ClassNotFoundException\n+  {\n+    int num = s.readInt ();\n+    for (int i = 0; i < num; ++i)\n+      {\n+\tObject key = s.readObject ();\n+\tObject value = s.readObject ();\n+\tput (key, value);\n+      }\n+  }\n+\n+  private void writeObject (ObjectOutputStream s)\n+    throws IOException\n+  {\n+    s.writeInt (size);\n+    Iterator it = entrySet ().iterator ();\n+    while (it.hasNext ())\n+      {\n+\tMap.Entry entry = (Map.Entry) it.next ();\n+\ts.writeObject (entry.getKey ());\n+\ts.writeObject (entry.getValue ());\n+      }\n+  }\n+\n+  // Number of items in hash table.\n+  private int size;\n+  // The table itself.\n+  private Object[] table;\n+\n+  // This object is used to mark deleted items.\n+  private Object tombstone = new Object ();\n+  // This object is used to mark empty slots.  We need this because\n+  // using null is ambiguous.\n+  private Object emptyslot = new Object ();\n+}"}, {"sha": "7b82908e8b859969568b505b55c79d63eb8df055", "filename": "libjava/jni.cc", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8d99218adb7edeac58e9f1e87af09bb77dfdc0/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8d99218adb7edeac58e9f1e87af09bb77dfdc0/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=ac8d99218adb7edeac58e9f1e87af09bb77dfdc0", "patch": "@@ -37,7 +37,7 @@ details.  */\n #include <java/lang/reflect/Method.h>\n #include <java/lang/reflect/Modifier.h>\n #include <java/lang/OutOfMemoryError.h>\n-#include <java/util/Hashtable.h>\n+#include <java/util/IdentityHashMap.h>\n #include <java/lang/Integer.h>\n #include <java/lang/ThreadGroup.h>\n #include <java/lang/Thread.h>\n@@ -91,9 +91,9 @@ struct _Jv_JNI_LocalFrame\n };\n \n // This holds a reference count for all local references.\n-static java::util::Hashtable *local_ref_table;\n+static java::util::IdentityHashMap *local_ref_table;\n // This holds a reference count for all global references.\n-static java::util::Hashtable *global_ref_table;\n+static java::util::IdentityHashMap *global_ref_table;\n \n // The only VM.\n static JavaVM *the_vm;\n@@ -148,8 +148,8 @@ jvmpiDisableEvent (jint event_type, void *)\n void\n _Jv_JNI_Init (void)\n {\n-  local_ref_table = new java::util::Hashtable;\n-  global_ref_table = new java::util::Hashtable;\n+  local_ref_table = new java::util::IdentityHashMap;\n+  global_ref_table = new java::util::IdentityHashMap;\n \n #ifdef ENABLE_JVMPI\n   _Jv_JVMPI_Interface.version = 1;\n@@ -163,7 +163,7 @@ _Jv_JNI_Init (void)\n \n // Tell the GC that a certain pointer is live.\n static void\n-mark_for_gc (jobject obj, java::util::Hashtable *ref_table)\n+mark_for_gc (jobject obj, java::util::IdentityHashMap *ref_table)\n {\n   JvSynchronize sync (ref_table);\n \n@@ -176,7 +176,7 @@ mark_for_gc (jobject obj, java::util::Hashtable *ref_table)\n \n // Unmark a pointer.\n static void\n-unmark_for_gc (jobject obj, java::util::Hashtable *ref_table)\n+unmark_for_gc (jobject obj, java::util::IdentityHashMap *ref_table)\n {\n   JvSynchronize sync (ref_table);\n "}, {"sha": "6fada16ed9b92e37797a6d7644073cc3ee189a1f", "filename": "libjava/testsuite/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8d99218adb7edeac58e9f1e87af09bb77dfdc0/libjava%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8d99218adb7edeac58e9f1e87af09bb77dfdc0/libjava%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2FMakefile.in?ref=ac8d99218adb7edeac58e9f1e87af09bb77dfdc0", "patch": "@@ -95,6 +95,7 @@ LIBGCJTESTSPEC = @LIBGCJTESTSPEC@\n LIBGCJ_CFLAGS = @LIBGCJ_CFLAGS@\n LIBGCJ_CXXFLAGS = @LIBGCJ_CXXFLAGS@\n LIBGCJ_JAVAFLAGS = @LIBGCJ_JAVAFLAGS@\n+LIBICONV = @LIBICONV@\n LIBLTDL = @LIBLTDL@\n LIBTOOL = @LIBTOOL@\n LN_S = @LN_S@"}]}