{"sha": "fdae509271b214cff9ec3c794f7f174af275cfef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRhZTUwOTI3MWIyMTRjZmY5ZWMzYzc5NGY3ZjE3NGFmMjc1Y2ZlZg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-05-01T14:26:55Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-05-01T14:26:55Z"}, "message": "genrecog.c (test): Rename to rtx_test.\n\ngcc/\n\t* genrecog.c (test): Rename to rtx_test.  Update rest of file\n\taccordingly.\n\nFrom-SVN: r222683", "tree": {"sha": "91e06a40af88d9491ff53922bd193c965dab9b4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91e06a40af88d9491ff53922bd193c965dab9b4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fdae509271b214cff9ec3c794f7f174af275cfef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdae509271b214cff9ec3c794f7f174af275cfef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdae509271b214cff9ec3c794f7f174af275cfef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdae509271b214cff9ec3c794f7f174af275cfef/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ab528787ff54f9a489f8a2496e238520d3b67eca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab528787ff54f9a489f8a2496e238520d3b67eca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab528787ff54f9a489f8a2496e238520d3b67eca"}], "stats": {"total": 452, "additions": 230, "deletions": 222}, "files": [{"sha": "f860e99a7ad8dca3acb9dad56eb3379862637313", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdae509271b214cff9ec3c794f7f174af275cfef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdae509271b214cff9ec3c794f7f174af275cfef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fdae509271b214cff9ec3c794f7f174af275cfef", "patch": "@@ -1,3 +1,8 @@\n+2015-05-01  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* genrecog.c (test): Rename to rtx_test.  Update rest of file\n+\taccordingly.\n+\n 2015-05-01  Andreas Schwab  <schwab@linux-m68k.org>\n \n \tPR translation/65959"}, {"sha": "29da09483febdac454b9abc73f39f7b37fe6bcc6", "filename": "gcc/genrecog.c", "status": "modified", "additions": 225, "deletions": 222, "changes": 447, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdae509271b214cff9ec3c794f7f174af275cfef/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdae509271b214cff9ec3c794f7f174af275cfef/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=fdae509271b214cff9ec3c794f7f174af275cfef", "patch": "@@ -1047,9 +1047,9 @@ struct pattern_use\n };\n \n /* Represents a test performed by a decision.  */\n-struct test\n+struct rtx_test\n {\n-  test ();\n+  rtx_test ();\n \n   /* The types of test that can be performed.  Most of them take as input\n      an rtx X.  Some also take as input a transition label LABEL; the others\n@@ -1140,203 +1140,203 @@ struct test\n     acceptance_type acceptance;\n   } u;\n \n-  static test code (position *);\n-  static test mode (position *);\n-  static test int_field (position *, int);\n-  static test wide_int_field (position *, int);\n-  static test veclen (position *);\n-  static test peep2_count (int);\n-  static test veclen_ge (position *, int);\n-  static test predicate (position *, const pred_data *, machine_mode);\n-  static test duplicate (position *, int);\n-  static test pattern (position *, pattern_use *);\n-  static test have_num_clobbers ();\n-  static test c_test (const char *);\n-  static test set_op (position *, int);\n-  static test accept (const acceptance_type &);\n+  static rtx_test code (position *);\n+  static rtx_test mode (position *);\n+  static rtx_test int_field (position *, int);\n+  static rtx_test wide_int_field (position *, int);\n+  static rtx_test veclen (position *);\n+  static rtx_test peep2_count (int);\n+  static rtx_test veclen_ge (position *, int);\n+  static rtx_test predicate (position *, const pred_data *, machine_mode);\n+  static rtx_test duplicate (position *, int);\n+  static rtx_test pattern (position *, pattern_use *);\n+  static rtx_test have_num_clobbers ();\n+  static rtx_test c_test (const char *);\n+  static rtx_test set_op (position *, int);\n+  static rtx_test accept (const acceptance_type &);\n \n   bool terminal_p () const;\n   bool single_outcome_p () const;\n \n private:\n-  test (position *, kind_enum);\n+  rtx_test (position *, kind_enum);\n };\n \n-test::test () {}\n+rtx_test::rtx_test () {}\n \n-test::test (position *pos_in, kind_enum kind_in)\n+rtx_test::rtx_test (position *pos_in, kind_enum kind_in)\n   : pos (pos_in), pos_operand (-1), kind (kind_in) {}\n \n-test\n-test::code (position *pos)\n+rtx_test\n+rtx_test::code (position *pos)\n {\n-  return test (pos, test::CODE);\n+  return rtx_test (pos, rtx_test::CODE);\n }\n \n-test\n-test::mode (position *pos)\n+rtx_test\n+rtx_test::mode (position *pos)\n {\n-  return test (pos, test::MODE);\n+  return rtx_test (pos, rtx_test::MODE);\n }\n \n-test\n-test::int_field (position *pos, int opno)\n+rtx_test\n+rtx_test::int_field (position *pos, int opno)\n {\n-  test res (pos, test::INT_FIELD);\n+  rtx_test res (pos, rtx_test::INT_FIELD);\n   res.u.opno = opno;\n   return res;\n }\n \n-test\n-test::wide_int_field (position *pos, int opno)\n+rtx_test\n+rtx_test::wide_int_field (position *pos, int opno)\n {\n-  test res (pos, test::WIDE_INT_FIELD);\n+  rtx_test res (pos, rtx_test::WIDE_INT_FIELD);\n   res.u.opno = opno;\n   return res;\n }\n \n-test\n-test::veclen (position *pos)\n+rtx_test\n+rtx_test::veclen (position *pos)\n {\n-  return test (pos, test::VECLEN);\n+  return rtx_test (pos, rtx_test::VECLEN);\n }\n \n-test\n-test::peep2_count (int min_len)\n+rtx_test\n+rtx_test::peep2_count (int min_len)\n {\n-  test res (0, test::PEEP2_COUNT);\n+  rtx_test res (0, rtx_test::PEEP2_COUNT);\n   res.u.min_len = min_len;\n   return res;\n }\n \n-test\n-test::veclen_ge (position *pos, int min_len)\n+rtx_test\n+rtx_test::veclen_ge (position *pos, int min_len)\n {\n-  test res (pos, test::VECLEN_GE);\n+  rtx_test res (pos, rtx_test::VECLEN_GE);\n   res.u.min_len = min_len;\n   return res;\n }\n \n-test\n-test::predicate (position *pos, const struct pred_data *data,\n-\t\t machine_mode mode)\n+rtx_test\n+rtx_test::predicate (position *pos, const struct pred_data *data,\n+\t\t     machine_mode mode)\n {\n-  test res (pos, test::PREDICATE);\n+  rtx_test res (pos, rtx_test::PREDICATE);\n   res.u.predicate.data = data;\n   res.u.predicate.mode_is_param = false;\n   res.u.predicate.mode = mode;\n   return res;\n }\n \n-test\n-test::duplicate (position *pos, int opno)\n+rtx_test\n+rtx_test::duplicate (position *pos, int opno)\n {\n-  test res (pos, test::DUPLICATE);\n+  rtx_test res (pos, rtx_test::DUPLICATE);\n   res.u.opno = opno;\n   return res;\n }\n \n-test\n-test::pattern (position *pos, pattern_use *pattern)\n+rtx_test\n+rtx_test::pattern (position *pos, pattern_use *pattern)\n {\n-  test res (pos, test::PATTERN);\n+  rtx_test res (pos, rtx_test::PATTERN);\n   res.u.pattern = pattern;\n   return res;\n }\n \n-test\n-test::have_num_clobbers ()\n+rtx_test\n+rtx_test::have_num_clobbers ()\n {\n-  return test (0, test::HAVE_NUM_CLOBBERS);\n+  return rtx_test (0, rtx_test::HAVE_NUM_CLOBBERS);\n }\n \n-test\n-test::c_test (const char *string)\n+rtx_test\n+rtx_test::c_test (const char *string)\n {\n-  test res (0, test::C_TEST);\n+  rtx_test res (0, rtx_test::C_TEST);\n   res.u.string = string;\n   return res;\n }\n \n-test\n-test::set_op (position *pos, int opno)\n+rtx_test\n+rtx_test::set_op (position *pos, int opno)\n {\n-  test res (pos, test::SET_OP);\n+  rtx_test res (pos, rtx_test::SET_OP);\n   res.u.opno = opno;\n   return res;\n }\n \n-test\n-test::accept (const acceptance_type &acceptance)\n+rtx_test\n+rtx_test::accept (const acceptance_type &acceptance)\n {\n-  test res (0, test::ACCEPT);\n+  rtx_test res (0, rtx_test::ACCEPT);\n   res.u.acceptance = acceptance;\n   return res;\n }\n \n /* Return true if the test represents an unconditionally successful match.  */\n \n bool\n-test::terminal_p () const\n+rtx_test::terminal_p () const\n {\n-  return kind == test::ACCEPT && u.acceptance.type != PEEPHOLE2;\n+  return kind == rtx_test::ACCEPT && u.acceptance.type != PEEPHOLE2;\n }\n \n /* Return true if the test is a boolean that is always true.  */\n \n bool\n-test::single_outcome_p () const\n+rtx_test::single_outcome_p () const\n {\n-  return terminal_p () || kind == test::SET_OP;\n+  return terminal_p () || kind == rtx_test::SET_OP;\n }\n \n bool\n-operator == (const test &a, const test &b)\n+operator == (const rtx_test &a, const rtx_test &b)\n {\n   if (a.pos != b.pos || a.kind != b.kind)\n     return false;\n   switch (a.kind)\n     {\n-    case test::CODE:\n-    case test::MODE:\n-    case test::VECLEN:\n-    case test::HAVE_NUM_CLOBBERS:\n+    case rtx_test::CODE:\n+    case rtx_test::MODE:\n+    case rtx_test::VECLEN:\n+    case rtx_test::HAVE_NUM_CLOBBERS:\n       return true;\n \n-    case test::PEEP2_COUNT:\n-    case test::VECLEN_GE:\n+    case rtx_test::PEEP2_COUNT:\n+    case rtx_test::VECLEN_GE:\n       return a.u.min_len == b.u.min_len;\n \n-    case test::INT_FIELD:\n-    case test::WIDE_INT_FIELD:\n-    case test::DUPLICATE:\n-    case test::SET_OP:\n+    case rtx_test::INT_FIELD:\n+    case rtx_test::WIDE_INT_FIELD:\n+    case rtx_test::DUPLICATE:\n+    case rtx_test::SET_OP:\n       return a.u.opno == b.u.opno;\n \n-    case test::SAVED_CONST_INT:\n+    case rtx_test::SAVED_CONST_INT:\n       return (a.u.integer.is_param == b.u.integer.is_param\n \t      && a.u.integer.value == b.u.integer.value);\n \n-    case test::PREDICATE:\n+    case rtx_test::PREDICATE:\n       return (a.u.predicate.data == b.u.predicate.data\n \t      && a.u.predicate.mode_is_param == b.u.predicate.mode_is_param\n \t      && a.u.predicate.mode == b.u.predicate.mode);\n \n-    case test::PATTERN:\n+    case rtx_test::PATTERN:\n       return (a.u.pattern->routine == b.u.pattern->routine\n \t      && a.u.pattern->params == b.u.pattern->params);\n \n-    case test::C_TEST:\n+    case rtx_test::C_TEST:\n       return strcmp (a.u.string, b.u.string) == 0;\n \n-    case test::ACCEPT:\n+    case rtx_test::ACCEPT:\n       return a.u.acceptance == b.u.acceptance;\n     }\n   gcc_unreachable ();\n }\n \n bool\n-operator != (const test &a, const test &b)\n+operator != (const rtx_test &a, const rtx_test &b)\n {\n   return !operator == (a, b);\n }\n@@ -1420,8 +1420,8 @@ struct transition\n   transition *prev, *next;\n \n   /* The transition should be taken when T has one of these values.\n-     E.g. for test::CODE this is a set of codes, while for booleans like\n-     test::PREDICATE it is always a singleton \"true\".  The labels are\n+     E.g. for rtx_test::CODE this is a set of codes, while for booleans like\n+     rtx_test::PREDICATE it is always a singleton \"true\".  The labels are\n      sorted in ascending order.  */\n   int_set labels;\n \n@@ -1439,7 +1439,7 @@ struct transition\n   bool optional;\n \n   /* True if LABELS contains parameter numbers rather than constants.\n-     E.g. if this is true for a test::CODE, the label is the number\n+     E.g. if this is true for a rtx_test::CODE, the label is the number\n      of an rtx_code parameter rather than an rtx_code itself.\n      LABELS is always a singleton when this variable is true.  */\n   bool is_param;\n@@ -1452,7 +1452,7 @@ struct transition\n    more decisions to try, fails the match.  */\n struct decision : list_head <transition>\n {\n-  decision (const test &);\n+  decision (const rtx_test &);\n \n   void set_parent (list_head <decision> *s);\n   bool if_statement_p (uint64_t * = 0) const;\n@@ -1464,7 +1464,7 @@ struct decision : list_head <transition>\n   decision *prev, *next;\n \n   /* The test to perform.  */\n-  struct test test;\n+  rtx_test test;\n };\n \n /* Represents one machine state.  For each state the machine tries a list\n@@ -1488,7 +1488,7 @@ transition::set_parent (list_head <transition> *from_in)\n   from = static_cast <decision *> (from_in);\n }\n \n-decision::decision (const struct test &test_in)\n+decision::decision (const rtx_test &test_in)\n   : prev (0), next (0), test (test_in) {}\n \n /* Set the state to which this decision belongs.  */\n@@ -1518,7 +1518,7 @@ decision::if_statement_p (uint64_t *label) const\n    TRANS.  */\n \n static void\n-add_decision (state *from, const test &test, transition *trans)\n+add_decision (state *from, const rtx_test &test, transition *trans)\n {\n   decision *d = new decision (test);\n   from->push_back (d);\n@@ -1530,7 +1530,7 @@ add_decision (state *from, const test &test, transition *trans)\n    should be optional.  Return the new state.  */\n \n static state *\n-add_decision (state *from, const test &test, int_set labels, bool optional)\n+add_decision (state *from, const rtx_test &test, int_set labels, bool optional)\n {\n   state *to = new state;\n   add_decision (from, test, new transition (labels, to, optional));\n@@ -1542,7 +1542,7 @@ add_decision (state *from, const test &test, int_set labels, bool optional)\n    optional.  */\n \n static decision *\n-insert_decision_before (state::range r, const test &test,\n+insert_decision_before (state::range r, const rtx_test &test,\n \t\t\tconst int_set &labels, bool optional)\n {\n   decision *newd = new decision (test);\n@@ -1593,18 +1593,18 @@ simplify_tests (state *s)\n       uint64_t label;\n       /* Convert checks for GET_CODE (x) == CONST_INT and XWINT (x, 0) == N\n \t into checks for const_int_rtx[N'], if N is suitably small.  */\n-      if (d->test.kind == test::CODE\n+      if (d->test.kind == rtx_test::CODE\n \t  && d->if_statement_p (&label)\n \t  && label == CONST_INT)\n \tif (decision *second = d->first->to->singleton ())\n \t  if (d->test.pos == second->test.pos\n-\t      && second->test.kind == test::WIDE_INT_FIELD\n+\t      && second->test.kind == rtx_test::WIDE_INT_FIELD\n \t      && second->test.u.opno == 0\n \t      && second->if_statement_p (&label)\n \t      && IN_RANGE (int64_t (label),\n \t\t\t   -MAX_SAVED_CONST_INT, MAX_SAVED_CONST_INT))\n \t    {\n-\t      d->test.kind = test::SAVED_CONST_INT;\n+\t      d->test.kind = rtx_test::SAVED_CONST_INT;\n \t      d->test.u.integer.is_param = false;\n \t      d->test.u.integer.value = label;\n \t      d->replace (d->first, second->release ());\n@@ -1619,7 +1619,7 @@ simplify_tests (state *s)\n \t paths that reach that code test require the same predicate\n \t to be true.  cse_tests will then put the predicate test in\n \t series with the code test.  */\n-      if (d->test.kind == test::CODE)\n+      if (d->test.kind == rtx_test::CODE)\n \tif (transition *trans = d->singleton ())\n \t  {\n \t    state *s = trans->to;\n@@ -1630,7 +1630,7 @@ simplify_tests (state *s)\n \t\ttransition *trans2 = d2->singleton ();\n \t\tif (!trans2)\n \t\t  break;\n-\t\tif (d2->test.kind == test::PREDICATE)\n+\t\tif (d2->test.kind == rtx_test::PREDICATE)\n \t\t  {\n \t\t    d->test = d2->test;\n \t\t    trans->labels = int_set (true);\n@@ -1654,7 +1654,7 @@ simplify_tests (state *s)\n static bool\n common_test_p (decision *d, transition *common, vec <transition *> *where)\n {\n-  if (d->test.kind == test::ACCEPT)\n+  if (d->test.kind == rtx_test::ACCEPT)\n     /* We found a successful return that didn't require COMMON.  */\n     return false;\n   if (d->test == common->from->test)\n@@ -1702,42 +1702,42 @@ struct known_conditions\n    as positive proof.  */\n \n static bool\n-safe_to_hoist_p (decision *d, const test &test, known_conditions *kc)\n+safe_to_hoist_p (decision *d, const rtx_test &test, known_conditions *kc)\n {\n   switch (test.kind)\n     {\n-    case test::C_TEST:\n+    case rtx_test::C_TEST:\n       /* In general, C tests require everything else to have been\n \t verified and all operands to have been set up.  */\n       return false;\n \n-    case test::ACCEPT:\n+    case rtx_test::ACCEPT:\n       /* Don't accept something before all conditions have been tested.  */\n       return false;\n \n-    case test::PREDICATE:\n+    case rtx_test::PREDICATE:\n       /* Don't move a predicate over a test for VECLEN_GE, since the\n \t predicate used in a match_parallel can legitimately expect the\n \t length to be checked first.  */\n       for (decision *subd = d;\n \t   subd->test != test;\n \t   subd = subd->first->to->first)\n \tif (subd->test.pos == test.pos\n-\t    && subd->test.kind == test::VECLEN_GE)\n+\t    && subd->test.kind == rtx_test::VECLEN_GE)\n \t  return false;\n       goto any_rtx;\n \n-    case test::DUPLICATE:\n+    case rtx_test::DUPLICATE:\n       /* Don't test for a match_dup until the associated operand has\n \t been set.  */\n       if (!kc->set_operands[test.u.opno])\n \treturn false;\n       goto any_rtx;\n \n-    case test::CODE:\n-    case test::MODE:\n-    case test::SAVED_CONST_INT:\n-    case test::SET_OP:\n+    case rtx_test::CODE:\n+    case rtx_test::MODE:\n+    case rtx_test::SAVED_CONST_INT:\n+    case rtx_test::SET_OP:\n     any_rtx:\n       /* Check whether it is safe to access the rtx under test.  */\n       switch (test.pos->type)\n@@ -1753,20 +1753,20 @@ safe_to_hoist_p (decision *d, const test &test, known_conditions *kc)\n \t}\n       gcc_unreachable ();\n \n-    case test::INT_FIELD:\n-    case test::WIDE_INT_FIELD:\n-    case test::VECLEN:\n-    case test::VECLEN_GE:\n+    case rtx_test::INT_FIELD:\n+    case rtx_test::WIDE_INT_FIELD:\n+    case rtx_test::VECLEN:\n+    case rtx_test::VECLEN_GE:\n       /* These tests access a specific part of an rtx, so are only safe\n \t once we know what the rtx is.  */\n       return kc->position_tests[test.pos->id] & TESTED_CODE;\n \n-    case test::PEEP2_COUNT:\n-    case test::HAVE_NUM_CLOBBERS:\n+    case rtx_test::PEEP2_COUNT:\n+    case rtx_test::HAVE_NUM_CLOBBERS:\n       /* These tests can be performed anywhere.  */\n       return true;\n \n-    case test::PATTERN:\n+    case rtx_test::PATTERN:\n       gcc_unreachable ();\n     }\n   gcc_unreachable ();\n@@ -1887,33 +1887,33 @@ cse_tests (position *pos, state *s, known_conditions *kc)\n       /* Make sure that safe_to_hoist_p isn't being overly conservative.\n \t It should realize that D's test is safe in the current\n \t environment.  */\n-      gcc_assert (d->test.kind == test::C_TEST\n-\t\t  || d->test.kind == test::ACCEPT\n+      gcc_assert (d->test.kind == rtx_test::C_TEST\n+\t\t  || d->test.kind == rtx_test::ACCEPT\n \t\t  || safe_to_hoist_p (d, d->test, kc));\n \n       /* D won't be changed any further by the current optimization.\n \t Recurse with the state temporarily updated to include D.  */\n       int prev = 0;\n       switch (d->test.kind)\n \t{\n-\tcase test::CODE:\n+\tcase rtx_test::CODE:\n \t  prev = kc->position_tests[d->test.pos->id];\n \t  kc->position_tests[d->test.pos->id] |= TESTED_CODE;\n \t  break;\n \n-\tcase test::VECLEN:\n-\tcase test::VECLEN_GE:\n+\tcase rtx_test::VECLEN:\n+\tcase rtx_test::VECLEN_GE:\n \t  prev = kc->position_tests[d->test.pos->id];\n \t  kc->position_tests[d->test.pos->id] |= TESTED_VECLEN;\n \t  break;\n \n-\tcase test::SET_OP:\n+\tcase rtx_test::SET_OP:\n \t  prev = kc->set_operands[d->test.u.opno];\n \t  gcc_assert (!prev);\n \t  kc->set_operands[d->test.u.opno] = true;\n \t  break;\n \n-\tcase test::PEEP2_COUNT:\n+\tcase rtx_test::PEEP2_COUNT:\n \t  prev = kc->peep2_count;\n \t  kc->peep2_count = MAX (prev, d->test.u.min_len);\n \t  break;\n@@ -1925,17 +1925,17 @@ cse_tests (position *pos, state *s, known_conditions *kc)\n \tcse_tests (d->test.pos ? d->test.pos : pos, trans->to, kc);\n       switch (d->test.kind)\n \t{\n-\tcase test::CODE:\n-\tcase test::VECLEN:\n-\tcase test::VECLEN_GE:\n+\tcase rtx_test::CODE:\n+\tcase rtx_test::VECLEN:\n+\tcase rtx_test::VECLEN_GE:\n \t  kc->position_tests[d->test.pos->id] = prev;\n \t  break;\n \n-\tcase test::SET_OP:\n+\tcase rtx_test::SET_OP:\n \t  kc->set_operands[d->test.u.opno] = prev;\n \t  break;\n \n-\tcase test::PEEP2_COUNT:\n+\tcase rtx_test::PEEP2_COUNT:\n \t  kc->peep2_count = prev;\n \t  break;\n \n@@ -1949,33 +1949,33 @@ cse_tests (position *pos, state *s, known_conditions *kc)\n    or parameter::UNSET if none.  */\n \n parameter::type_enum\n-transition_parameter_type (test::kind_enum kind)\n+transition_parameter_type (rtx_test::kind_enum kind)\n {\n   switch (kind)\n     {\n-    case test::CODE:\n+    case rtx_test::CODE:\n       return parameter::CODE;\n \n-    case test::MODE:\n+    case rtx_test::MODE:\n       return parameter::MODE;\n \n-    case test::INT_FIELD:\n-    case test::VECLEN:\n-    case test::PATTERN:\n+    case rtx_test::INT_FIELD:\n+    case rtx_test::VECLEN:\n+    case rtx_test::PATTERN:\n       return parameter::INT;\n \n-    case test::WIDE_INT_FIELD:\n+    case rtx_test::WIDE_INT_FIELD:\n       return parameter::WIDE_INT;\n \n-    case test::PEEP2_COUNT:\n-    case test::VECLEN_GE:\n-    case test::SAVED_CONST_INT:\n-    case test::PREDICATE:\n-    case test::DUPLICATE:\n-    case test::HAVE_NUM_CLOBBERS:\n-    case test::C_TEST:\n-    case test::SET_OP:\n-    case test::ACCEPT:\n+    case rtx_test::PEEP2_COUNT:\n+    case rtx_test::VECLEN_GE:\n+    case rtx_test::SAVED_CONST_INT:\n+    case rtx_test::PREDICATE:\n+    case rtx_test::DUPLICATE:\n+    case rtx_test::HAVE_NUM_CLOBBERS:\n+    case rtx_test::C_TEST:\n+    case rtx_test::SET_OP:\n+    case rtx_test::ACCEPT:\n       return parameter::UNSET;\n     }\n   gcc_unreachable ();\n@@ -1993,11 +1993,11 @@ find_operand_positions (state *s, vec <int> &operand_pos)\n       int this_operand = (d->test.pos ? operand_pos[d->test.pos->id] : -1);\n       if (this_operand >= 0)\n \td->test.pos_operand = this_operand;\n-      if (d->test.kind == test::SET_OP)\n+      if (d->test.kind == rtx_test::SET_OP)\n \toperand_pos[d->test.pos->id] = d->test.u.opno;\n       for (transition *trans = d->first; trans; trans = trans->next)\n \tfind_operand_positions (trans->to, operand_pos);\n-      if (d->test.kind == test::SET_OP)\n+      if (d->test.kind == rtx_test::SET_OP)\n \toperand_pos[d->test.pos->id] = this_operand;\n     }\n }\n@@ -2065,7 +2065,7 @@ get_stats (state *s)\n \t  for_d.num_decisions += 1;\n \t  for_d.longest_path += 1;\n \t}\n-      if (d->test.kind == test::ACCEPT)\n+      if (d->test.kind == rtx_test::ACCEPT)\n \t{\n \t  for_d.longest_path_code = d->test.u.acceptance.u.full.code;\n \t  for_d.longest_backtrack_code = d->test.u.acceptance.u.full.code;\n@@ -2379,21 +2379,21 @@ update_parameters (vec <parameter> &to, const vec <parameter> &from)\n    PARAMB alone.  */\n \n static bool\n-compatible_tests_p (const test &a, const test &b,\n+compatible_tests_p (const rtx_test &a, const rtx_test &b,\n \t\t    parameter *parama, parameter *paramb)\n {\n   if (a.kind != b.kind)\n     return false;\n   switch (a.kind)\n     {\n-    case test::PREDICATE:\n+    case rtx_test::PREDICATE:\n       if (a.u.predicate.data != b.u.predicate.data)\n \treturn false;\n       *parama = parameter (parameter::MODE, false, a.u.predicate.mode);\n       *paramb = parameter (parameter::MODE, false, b.u.predicate.mode);\n       return true;\n \n-    case test::SAVED_CONST_INT:\n+    case rtx_test::SAVED_CONST_INT:\n       *parama = parameter (parameter::INT, false, a.u.integer.value);\n       *paramb = parameter (parameter::INT, false, b.u.integer.value);\n       return true;\n@@ -2667,7 +2667,7 @@ merge_patterns (merge_state_info *sinfo1, merge_state_info *sinfo2)\n \t     parameterizing the first N const_ints of the vector\n \t     and then (once we reach the maximum number of parameters)\n \t     we go on to match the other elements exactly.  */\n-\t  if (d1->test.kind == test::WIDE_INT_FIELD)\n+\t  if (d1->test.kind == rtx_test::WIDE_INT_FIELD)\n \t    return false;\n \n \t  /* See whether the label has a generalizable type.  */\n@@ -2803,7 +2803,7 @@ init_pattern_use (create_pattern_info *cpi, merge_state_info *sinfo,\n   pattern_use *use = new pattern_use;\n   use->routine = pat->routine;\n   use->params.splice (params);\n-  decision *d = new decision (test::pattern (res->root, use));\n+  decision *d = new decision (rtx_test::pattern (res->root, use));\n \n   /* If the original decision could use an element of operands[] instead\n      of an rtx variable, try to transfer it to the new decision.  */\n@@ -2823,7 +2823,7 @@ add_pattern_acceptance (create_pattern_info *cpi, state *s)\n   acceptance.type = SUBPATTERN;\n   acceptance.partial_p = false;\n   acceptance.u.full.code = cpi->next_result;\n-  add_decision (s, test::accept (acceptance), true, false);\n+  add_decision (s, rtx_test::accept (acceptance), true, false);\n   cpi->next_result += 1;\n }\n \n@@ -2860,12 +2860,12 @@ populate_pattern_routine (create_pattern_info *cpi, merge_state_info *sinfo,\n       const parameter &param = params[pat->param_test];\n       switch (newd->test.kind)\n \t{\n-\tcase test::PREDICATE:\n+\tcase rtx_test::PREDICATE:\n \t  newd->test.u.predicate.mode_is_param = param.is_param;\n \t  newd->test.u.predicate.mode = param.value;\n \t  break;\n \n-\tcase test::SAVED_CONST_INT:\n+\tcase rtx_test::SAVED_CONST_INT:\n \t  newd->test.u.integer.is_param = param.is_param;\n \t  newd->test.u.integer.value = param.value;\n \t  break;\n@@ -2875,9 +2875,9 @@ populate_pattern_routine (create_pattern_info *cpi, merge_state_info *sinfo,\n \t  break;\n \t}\n     }\n-  if (d->test.kind == test::C_TEST)\n+  if (d->test.kind == rtx_test::C_TEST)\n     routine->insn_p = true;\n-  else if (d->test.kind == test::HAVE_NUM_CLOBBERS)\n+  else if (d->test.kind == rtx_test::HAVE_NUM_CLOBBERS)\n     routine->pnum_clobbers_p = true;\n   news->push_back (newd);\n \n@@ -3038,11 +3038,11 @@ split_out_patterns (vec <merge_state_info> &states)\n \t and so couldn't be shared between states).  */\n       if (decision *d = sinfo->s->singleton ())\n \t/* ACCEPT states are unique, so don't even try to merge them.  */\n-\tif (d->test.kind != test::ACCEPT\n+\tif (d->test.kind != rtx_test::ACCEPT\n \t    && (pattern_have_num_clobbers_p\n-\t\t|| d->test.kind != test::HAVE_NUM_CLOBBERS)\n+\t\t|| d->test.kind != rtx_test::HAVE_NUM_CLOBBERS)\n \t    && (pattern_c_test_p\n-\t\t|| d->test.kind != test::C_TEST))\n+\t\t|| d->test.kind != rtx_test::C_TEST))\n \t  {\n \t    merge_state_info **slot = hashtab.find_slot (sinfo, INSERT);\n \t    sinfo->prev_same_test = *slot;\n@@ -3290,7 +3290,7 @@ create_subroutine (routine_type type, state *s, vec <state *> &procs)\n   acceptance.partial_p = true;\n   acceptance.u.subroutine_id = procs.length ();\n   state *news = new state;\n-  add_decision (news, test::accept (acceptance), true, false);\n+  add_decision (news, rtx_test::accept (acceptance), true, false);\n   return news;\n }\n \n@@ -3327,8 +3327,8 @@ find_subroutines (routine_type type, state *s, vec <state *> &procs)\n \t\tif (!newd->test.single_outcome_p ())\n \t\t  size.num_statements += 1;\n \t\ttrans = newd->singleton ();\n-\t\tif (newd->test.kind == test::SET_OP\n-\t\t    || newd->test.kind == test::ACCEPT)\n+\t\tif (newd->test.kind == rtx_test::SET_OP\n+\t\t    || newd->test.kind == rtx_test::ACCEPT)\n \t\t  break;\n \t      }\n \t  /* The target of TRANS is a subroutine candidate.  First recurse\n@@ -3866,9 +3866,9 @@ match_pattern_2 (state *s, rtx top_pattern, position *pos, rtx pattern)\n \t    if (code == MATCH_PARALLEL || code == MATCH_PAR_DUP)\n \t      {\n \t\t/* Check that we have a parallel with enough elements.  */\n-\t\ts = add_decision (s, test::code (pos), PARALLEL, false);\n+\t\ts = add_decision (s, rtx_test::code (pos), PARALLEL, false);\n \t\tint min_len = XVECLEN (pattern, 2);\n-\t\ts = add_decision (s, test::veclen_ge (pos, min_len),\n+\t\ts = add_decision (s, rtx_test::veclen_ge (pos, min_len),\n \t\t\t\t  true, false);\n \t      }\n \t    else\n@@ -3883,7 +3883,7 @@ match_pattern_2 (state *s, rtx top_pattern, position *pos, rtx pattern)\n \t\tbool need_codes = (pred\n \t\t\t\t   && (code == MATCH_OPERATOR\n \t\t\t\t       || code == MATCH_OP_DUP));\n-\t\ts = add_decision (s, test::code (pos), codes, !need_codes);\n+\t\ts = add_decision (s, rtx_test::code (pos), codes, !need_codes);\n \t      }\n \n \t    /* Postpone the predicate check until we've checked the rest\n@@ -3924,7 +3924,7 @@ match_pattern_2 (state *s, rtx top_pattern, position *pos, rtx pattern)\n \tdefault:\n \t  {\n \t    /* Check that the rtx has the right code.  */\n-\t    s = add_decision (s, test::code (pos), code, false);\n+\t    s = add_decision (s, rtx_test::code (pos), code, false);\n \n \t    /* Queue a test for the mode if one is specified.  */\n \t    if (GET_MODE (pattern) != VOIDmode)\n@@ -3949,7 +3949,8 @@ match_pattern_2 (state *s, rtx top_pattern, position *pos, rtx pattern)\n \t\t      /* Make sure the vector has the right number of\n \t\t\t elements.  */\n \t\t      int length = XVECLEN (pattern, i);\n-\t\t      s = add_decision (s, test::veclen (pos), length, false);\n+\t\t      s = add_decision (s, rtx_test::veclen (pos),\n+\t\t\t\t\tlength, false);\n \n \t\t      position **subpos2_ptr = &pos->xvecexp0s;\n \t\t      for (int j = 0; j < length; j++)\n@@ -3965,13 +3966,13 @@ match_pattern_2 (state *s, rtx top_pattern, position *pos, rtx pattern)\n \n \t\t  case 'i':\n \t\t    /* Make sure that XINT (X, I) has the right value.  */\n-\t\t    s = add_decision (s, test::int_field (pos, i),\n+\t\t    s = add_decision (s, rtx_test::int_field (pos, i),\n \t\t\t\t      XINT (pattern, i), false);\n \t\t    break;\n \n \t\t  case 'w':\n \t\t    /* Make sure that XWINT (X, I) has the right value.  */\n-\t\t    s = add_decision (s, test::wide_int_field (pos, i),\n+\t\t    s = add_decision (s, rtx_test::wide_int_field (pos, i),\n \t\t\t\t      XWINT (pattern, 0), false);\n \t\t    break;\n \n@@ -4037,7 +4038,7 @@ match_pattern_2 (state *s, rtx top_pattern, position *pos, rtx pattern)\n \t\t   and DImode register_operands, as described above.  */\n \t\tmachine_mode mode = GET_MODE (e->pattern);\n \t\tif (safe_predicate_mode (pred, mode))\n-\t\t  s = add_decision (s, test::mode (e->pos), mode, true);\n+\t\t  s = add_decision (s, rtx_test::mode (e->pos), mode, true);\n \n \t\t/* Assign to operands[] first, so that the rtx usually doesn't\n \t\t   need to be live across the call to the predicate.\n@@ -4046,27 +4047,29 @@ match_pattern_2 (state *s, rtx top_pattern, position *pos, rtx pattern)\n \t\t   since we fully expect to assign to operands[] at some point,\n \t\t   and since the caller usually writes to other parts of\n \t\t   recog_data anyway.  */\n-\t\ts = add_decision (s, test::set_op (e->pos, opno), true, false);\n-\t\ts = add_decision (s, test::predicate (e->pos, pred, mode),\n+\t\ts = add_decision (s, rtx_test::set_op (e->pos, opno),\n+\t\t\t\t  true, false);\n+\t\ts = add_decision (s, rtx_test::predicate (e->pos, pred, mode),\n \t\t\t\t  true, false);\n \t      }\n \t    else\n \t      /* Historically we've ignored the mode when there's no\n \t\t predicate.  Just set up operands[] unconditionally.  */\n-\t      s = add_decision (s, test::set_op (e->pos, opno), true, false);\n+\t      s = add_decision (s, rtx_test::set_op (e->pos, opno),\n+\t\t\t\ttrue, false);\n \t    break;\n \t  }\n \n \tdefault:\n-\t  s = add_decision (s, test::mode (e->pos),\n+\t  s = add_decision (s, rtx_test::mode (e->pos),\n \t\t\t    GET_MODE (e->pattern), false);\n \t  break;\n \t}\n     }\n \n   /* Finally add rtx_equal_p checks for duplicated operands.  */\n   FOR_EACH_VEC_ELT (dup_tests, i, e)\n-    s = add_decision (s, test::duplicate (e->pos, XINT (e->pattern, 0)),\n+    s = add_decision (s, rtx_test::duplicate (e->pos, XINT (e->pattern, 0)),\n \t\t      true, false);\n   return s;\n }\n@@ -4098,7 +4101,7 @@ match_pattern_1 (state *s, rtx top_pattern, const char *c_test,\n \t      position *subpos = next_position (subpos_ptr, &root_pos,\n \t\t\t\t\t\tPOS_PEEP2_INSN, count);\n \t      if (count > 0)\n-\t\ts = add_decision (s, test::peep2_count (count + 1),\n+\t\ts = add_decision (s, rtx_test::peep2_count (count + 1),\n \t\t\t\t  true, false);\n \t      s = match_pattern_2 (s, top_pattern, subpos, x);\n \t      subpos_ptr = &subpos->next;\n@@ -4115,15 +4118,15 @@ match_pattern_1 (state *s, rtx top_pattern, const char *c_test,\n       /* If the match is only valid when extra clobbers are added,\n \t make sure we're able to pass that information to the caller.  */\n       if (acceptance.type == RECOG && acceptance.u.full.u.num_clobbers)\n-\ts = add_decision (s, test::have_num_clobbers (), true, false);\n+\ts = add_decision (s, rtx_test::have_num_clobbers (), true, false);\n     }\n \n   /* Make sure that the C test is true.  */\n   if (maybe_eval_c_test (c_test) != 1)\n-    s = add_decision (s, test::c_test (c_test), true, false);\n+    s = add_decision (s, rtx_test::c_test (c_test), true, false);\n \n   /* Accept the pattern.  */\n-  add_decision (s, test::accept (acceptance), true, false);\n+  add_decision (s, rtx_test::accept (acceptance), true, false);\n }\n \n /* Like match_pattern_1, but (if merge_states_p) try to merge the\n@@ -4321,7 +4324,7 @@ static bool\n terminal_pattern_p (decision *d, unsigned int *base_out,\n \t\t    unsigned int *count_out)\n {\n-  if (d->test.kind != test::PATTERN)\n+  if (d->test.kind != rtx_test::PATTERN)\n     return false;\n   unsigned int base = 0;\n   unsigned int count = 0;\n@@ -4330,7 +4333,7 @@ terminal_pattern_p (decision *d, unsigned int *base_out,\n       if (trans->is_param || trans->labels.length () != 1)\n \treturn false;\n       decision *subd = trans->to->singleton ();\n-      if (!subd || subd->test.kind != test::ACCEPT)\n+      if (!subd || subd->test.kind != rtx_test::ACCEPT)\n \treturn false;\n       unsigned int this_base = (subd->test.u.acceptance.u.full.code\n \t\t\t\t- trans->labels[0]);\n@@ -4349,7 +4352,7 @@ terminal_pattern_p (decision *d, unsigned int *base_out,\n    already available in state OS.  */\n \n static bool\n-test_position_available_p (output_state *os, const test &test)\n+test_position_available_p (output_state *os, const rtx_test &test)\n {\n   return (!test.pos\n \t  || test.pos_operand >= 0\n@@ -4461,7 +4464,7 @@ print_parameter_value (const parameter &param)\n /* Print the C expression for the rtx tested by TEST.  */\n \n static void\n-print_test_rtx (output_state *os, const test &test)\n+print_test_rtx (output_state *os, const rtx_test &test)\n {\n   if (test.pos_operand >= 0)\n     printf (\"operands[%d]\", test.pos_operand);\n@@ -4472,41 +4475,41 @@ print_test_rtx (output_state *os, const test &test)\n /* Print the C expression for non-boolean test TEST.  */\n \n static void\n-print_nonbool_test (output_state *os, const test &test)\n+print_nonbool_test (output_state *os, const rtx_test &test)\n {\n   switch (test.kind)\n     {\n-    case test::CODE:\n+    case rtx_test::CODE:\n       printf (\"GET_CODE (\");\n       print_test_rtx (os, test);\n       printf (\")\");\n       break;\n \n-    case test::MODE:\n+    case rtx_test::MODE:\n       printf (\"GET_MODE (\");\n       print_test_rtx (os, test);\n       printf (\")\");\n       break;\n \n-    case test::VECLEN:\n+    case rtx_test::VECLEN:\n       printf (\"XVECLEN (\");\n       print_test_rtx (os, test);\n       printf (\", 0)\");\n       break;\n \n-    case test::INT_FIELD:\n+    case rtx_test::INT_FIELD:\n       printf (\"XINT (\");\n       print_test_rtx (os, test);\n       printf (\", %d)\", test.u.opno);\n       break;\n \n-    case test::WIDE_INT_FIELD:\n+    case rtx_test::WIDE_INT_FIELD:\n       printf (\"XWINT (\");\n       print_test_rtx (os, test);\n       printf (\", %d)\", test.u.opno);\n       break;\n \n-    case test::PATTERN:\n+    case rtx_test::PATTERN:\n       {\n \tpattern_routine *routine = test.u.pattern->routine;\n \tprintf (\"pattern%d (\", routine->pattern_id);\n@@ -4536,15 +4539,15 @@ print_nonbool_test (output_state *os, const test &test)\n \tbreak;\n       }\n \n-    case test::PEEP2_COUNT:\n-    case test::VECLEN_GE:\n-    case test::SAVED_CONST_INT:\n-    case test::DUPLICATE:\n-    case test::PREDICATE:\n-    case test::SET_OP:\n-    case test::HAVE_NUM_CLOBBERS:\n-    case test::C_TEST:\n-    case test::ACCEPT:\n+    case rtx_test::PEEP2_COUNT:\n+    case rtx_test::VECLEN_GE:\n+    case rtx_test::SAVED_CONST_INT:\n+    case rtx_test::DUPLICATE:\n+    case rtx_test::PREDICATE:\n+    case rtx_test::SET_OP:\n+    case rtx_test::HAVE_NUM_CLOBBERS:\n+    case rtx_test::C_TEST:\n+    case rtx_test::ACCEPT:\n       gcc_unreachable ();\n     }\n }\n@@ -4553,7 +4556,7 @@ print_nonbool_test (output_state *os, const test &test)\n    decision performs TEST.  Print the C code for the label.  */\n \n static void\n-print_label_value (const test &test, bool is_param, uint64_t value)\n+print_label_value (const rtx_test &test, bool is_param, uint64_t value)\n {\n   print_parameter_value (parameter (transition_parameter_type (test.kind),\n \t\t\t\t    is_param, value));\n@@ -4564,24 +4567,24 @@ print_label_value (const test &test, bool is_param, uint64_t value)\n    Test for inequality if INVERT_P, otherwise test for equality.  */\n \n static void\n-print_test (output_state *os, const test &test, bool is_param, uint64_t value,\n-\t    bool invert_p)\n+print_test (output_state *os, const rtx_test &test, bool is_param,\n+\t    uint64_t value, bool invert_p)\n {\n   switch (test.kind)\n     {\n       /* Handle the non-boolean TESTs.  */\n-    case test::CODE:\n-    case test::MODE:\n-    case test::VECLEN:\n-    case test::INT_FIELD:\n-    case test::WIDE_INT_FIELD:\n-    case test::PATTERN:\n+    case rtx_test::CODE:\n+    case rtx_test::MODE:\n+    case rtx_test::VECLEN:\n+    case rtx_test::INT_FIELD:\n+    case rtx_test::WIDE_INT_FIELD:\n+    case rtx_test::PATTERN:\n       print_nonbool_test (os, test);\n       printf (\" %s \", invert_p ? \"!=\" : \"==\");\n       print_label_value (test, is_param, value);\n       break;\n \n-    case test::SAVED_CONST_INT:\n+    case rtx_test::SAVED_CONST_INT:\n       gcc_assert (!is_param && value == 1);\n       print_test_rtx (os, test);\n       printf (\" %s const_int_rtx[MAX_SAVED_CONST_INT + \",\n@@ -4592,20 +4595,20 @@ print_test (output_state *os, const test &test, bool is_param, uint64_t value,\n       printf (\"]\");\n       break;\n \n-    case test::PEEP2_COUNT:\n+    case rtx_test::PEEP2_COUNT:\n       gcc_assert (!is_param && value == 1);\n       printf (\"peep2_current_count %s %d\", invert_p ? \"<\" : \">=\",\n \t      test.u.min_len);\n       break;\n \n-    case test::VECLEN_GE:\n+    case rtx_test::VECLEN_GE:\n       gcc_assert (!is_param && value == 1);\n       printf (\"XVECLEN (\");\n       print_test_rtx (os, test);\n       printf (\", 0) %s %d\", invert_p ? \"<\" : \">=\", test.u.min_len);\n       break;\n \n-    case test::PREDICATE:\n+    case rtx_test::PREDICATE:\n       gcc_assert (!is_param && value == 1);\n       printf (\"%s%s (\", invert_p ? \"!\" : \"\", test.u.predicate.data->name);\n       print_test_rtx (os, test);\n@@ -4616,27 +4619,27 @@ print_test (output_state *os, const test &test, bool is_param, uint64_t value,\n       printf (\")\");\n       break;\n \n-    case test::DUPLICATE:\n+    case rtx_test::DUPLICATE:\n       gcc_assert (!is_param && value == 1);\n       printf (\"%srtx_equal_p (\", invert_p ? \"!\" : \"\");\n       print_test_rtx (os, test);\n       printf (\", operands[%d])\", test.u.opno);\n       break;\n \n-    case test::HAVE_NUM_CLOBBERS:\n+    case rtx_test::HAVE_NUM_CLOBBERS:\n       gcc_assert (!is_param && value == 1);\n       printf (\"pnum_clobbers %s NULL\", invert_p ? \"==\" : \"!=\");\n       break;\n \n-    case test::C_TEST:\n+    case rtx_test::C_TEST:\n       gcc_assert (!is_param && value == 1);\n       if (invert_p)\n \tprintf (\"!\");\n       print_c_condition (test.u.string);\n       break;\n \n-    case test::ACCEPT:\n-    case test::SET_OP:\n+    case rtx_test::ACCEPT:\n+    case rtx_test::SET_OP:\n       gcc_unreachable ();\n     }\n }\n@@ -4812,9 +4815,9 @@ print_decision (output_state *os, decision *d, unsigned int indent,\n \t  return ES_FALLTHROUGH;\n \t}\n     }\n-  else if (d->test.kind == test::ACCEPT)\n+  else if (d->test.kind == rtx_test::ACCEPT)\n     return print_acceptance (d->test.u.acceptance, indent, is_final);\n-  else if (d->test.kind == test::SET_OP)\n+  else if (d->test.kind == rtx_test::SET_OP)\n     {\n       printf_indent (indent, \"operands[%d] = \", d->test.u.opno);\n       print_test_rtx (os, d->test);\n@@ -4843,8 +4846,8 @@ print_decision (output_state *os, decision *d, unsigned int indent,\n \t{\n \t  d = trans->to->singleton ();\n \t  if (!d\n-\t      || d->test.kind == test::ACCEPT\n-\t      || d->test.kind == test::SET_OP\n+\t      || d->test.kind == rtx_test::ACCEPT\n+\t      || d->test.kind == rtx_test::SET_OP\n \t      || !d->if_statement_p (&label)\n \t      || !test_position_available_p (os, d->test))\n \t    break;\n@@ -4869,7 +4872,7 @@ print_decision (output_state *os, decision *d, unsigned int indent,\n \t  return print_state (os, to, indent, is_final);\n \t}\n       else if (to->singleton ()\n-\t       && to->first->test.kind == test::ACCEPT\n+\t       && to->first->test.kind == rtx_test::ACCEPT\n \t       && single_statement_p (to->first->test.u.acceptance))\n \t{\n \t  /* The target of the transition is a simple \"return\" statement."}]}