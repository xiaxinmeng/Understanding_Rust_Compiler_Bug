{"sha": "5d9ae53d70c72991e26648d915e7fb8e00b8e811", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ5YWU1M2Q3MGM3Mjk5MWUyNjY0OGQ5MTVlN2ZiOGUwMGI4ZTgxMQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2017-12-07T16:32:03Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-12-07T16:32:03Z"}, "message": "PR c/81544 - attribute noreturn and warn_unused_result on the same function accepted\n\nPR c/81544 - attribute noreturn and warn_unused_result on the same function accepted\nPR c/81566 - invalid attribute aligned accepted on functions\n\ngcc/ada/ChangeLog:\n\n\tPR c/81544\n\t* gcc-interface/utils.c (gnat_internal_attribute_table): Initialize\n\tnew member of struct attribute_spec.\n\ngcc/c/ChangeLog:\n\n\tPR c/81544\n\t* c-decl.c (c_decl_attributes): Look up existing declaration and\n\tpass it to decl_attributes.\n\ngcc/c-family/ChangeLog:\n\n\tPR c/81544\n\tPR c/81566\n\t* c-attribs.c (attr_aligned_exclusions): New array.\n\t(attr_alloc_exclusions, attr_cold_hot_exclusions): Same.\n\t(attr_common_exclusions, attr_const_pure_exclusions): Same.\n\t(attr_gnu_inline_exclusions, attr_inline_exclusions): Same.\n\t(attr_noreturn_exclusions, attr_returns_twice_exclusions): Same.\n\t(attr_warn_unused_result_exclusions): Same.\n\t(handle_hot_attribute, handle_cold_attribute): Simplify.\n\t(handle_const_attribute): Warn on function returning void.\n\t(handle_pure_attribute): Same.\n\t(handle_aligned_attribute): Diagnose conflicting attribute\n\tspecifications.\n\t* c-warn.c (diagnose_mismatched_attributes): Simplify.\n\ngcc/cp/ChangeLog:\n\n\tPR c/81544\n\t* cp-tree.h (decls_match): Add default argument.\n\t* decl.c (decls_match): Avoid calling into the target back end\n\tand triggering an error.\n\t* decl2.c (cplus_decl_attributes): Look up existing declaration and\n\tpass it to decl_attributes.\n\t* tree.c (cxx_attribute_table): Initialize new member of struct\n\tattribute_spec.\n\ngcc/fortran/ChangeLog:\n\n\tPR c/81544\n\t* f95-lang.c (gfc_attribute_table): Initialize new member of struct\n\tattribute_spec.\n\ngcc/lto/ChangeLog:\n\n\tPR c/81544\n\t* lto-lang.c (lto_attribute_table): Initialize new member of struct\n\tattribute_spec.\n\ngcc/ChangeLog:\n\n\tPR c/81544\n\t* attribs.c (empty_attribute_table): Initialize new member of\n\tstruct attribute_spec.\n\t(decl_attributes): Add argument.  Handle mutually exclusive\n\tcombinations of attributes.\n\t(selftests::test_attribute_exclusions): New function.\n\t(selftests::attribute_c_tests): Ditto.\n\t* attribs.h (decl_attributes): Add default argument.\n\t* selftest.h (attribute_c_tests): Declare.\n\t* selftest-run-tests.c (selftest::run_tests): Call attribute_c_tests.\n\t* tree-core.h (attribute_spec::exclusions, exclude): New type and\n\tmember.\n\t* doc/extend.texi (Common Function Attributes): Update const and pure.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c/81544\n\t* c-c++-common/Wattributes-2.c: New test.\n\t* c-c++-common/Wattributes.c: New test.\n\t* c-c++-common/attributes-3.c: Adjust.\n\t* gcc.dg/Wattributes-6.c: New test.\n\t* gcc.dg/Wattributes-7.c: New test.\n\t* gcc.dg/attr-noinline.c\n\t* gcc.dg/pr44964.c: Same.\n\t* gcc.dg/torture/pr42363.c: Same.\n\t* gcc.dg/tree-ssa/ssa-ccp-2.c: Same.\n\nFrom-SVN: r255469", "tree": {"sha": "a586e44e1f5c41fd8ae4cb8fd80446c763cc595d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a586e44e1f5c41fd8ae4cb8fd80446c763cc595d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d9ae53d70c72991e26648d915e7fb8e00b8e811", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d9ae53d70c72991e26648d915e7fb8e00b8e811", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d9ae53d70c72991e26648d915e7fb8e00b8e811", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d9ae53d70c72991e26648d915e7fb8e00b8e811/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1d8b0222b15f2188b659de4a731d8fd5ea23bed0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d8b0222b15f2188b659de4a731d8fd5ea23bed0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d8b0222b15f2188b659de4a731d8fd5ea23bed0"}], "stats": {"total": 1593, "additions": 1116, "deletions": 477}, "files": [{"sha": "f81665f650f93b93c864b9a0fcef66d2d1505d86", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -1,3 +1,50 @@\n+2017-12-07  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/81544\n+\t* attribs.c (empty_attribute_table): Initialize new member of\n+\tstruct attribute_spec.\n+\t(decl_attributes): Add argument.  Handle mutually exclusive\n+\tcombinations of attributes.\n+\t(selftests::test_attribute_exclusions): New function.\n+\t(selftests::attribute_c_tests): Ditto.\n+\t* attribs.h (decl_attributes): Add default argument.\n+\t* selftest.h (attribute_c_tests): Declare.\n+\t* selftest-run-tests.c (selftest::run_tests): Call attribute_c_tests.\n+\t* tree-core.h (attribute_spec::exclusions, exclude): New type and\n+\tmember.\n+\t* doc/extend.texi (Common Function Attributes): Update const and pure.\n+\t* config/alpha/alpha.c (vms_attribute_table): Initialize new member\n+\tof struct attribute_spec.\n+\t* config/arc/arc.c (arc_attribute_table): Same.\n+\t* config/arm/arm.c (arm_attribute_table): Same.\n+\t* config/avr/avr.c ( avr_attribute_table): Same.\n+\t* config/bfin/bfin.c (bfin_attribute_table): Same.\n+\t* config/cr16/cr16.c (cr16_attribute_table): Same.\n+\t* config/epiphany/epiphany.c (epiphany_attribute_table): Same.\n+\t* config/h8300/h8300.c (h8300_attribute_table): Same.\n+\t* config/i386/i386.c (ix86_attribute_table): Same.\n+\t* config/ia64/ia64.c (ia64_attribute_table): Same.\n+\t* config/m32c/m32c.c (m32c_attribute_table): Same.\n+\t* config/m32r/m32r.c (m32r_attribute_table): Same.\n+\t* config/m68k/m68k.c (m68k_attribute_table): Same.\n+\t* config/mcore/mcore.c (mcore_attribute_table): Same.\n+\t* config/microblaze/microblaze.c (microblaze_attribute_table): Same.\n+\t* config/mips/mips.c (mips_attribute_table): Same.\n+\t* config/msp430/msp430.c (msp430_attribute_table): Same.\n+\t* config/nds32/nds32.c (nds32_attribute_table): Same.\n+\t* config/nvptx/nvptx.c (nvptx_attribute_table): Same.\n+\t* config/powerpcspe/powerpcspe.c (rs6000_attribute_table): Same.\n+\t* config/rl78/rl78.c (rl78__attribute_table): Same.\n+\t* config/rs6000/rs6000.c (rs6000_attribute_table): Same.\n+\t* onfig/rx/rx.c (rx_attribute_table): Same.\n+\t* config/s390/s390.c (s390_handle_vectorbool_attribute): Same.\n+\t* config/sh/sh.c (sh_attribute_table): Same.\n+\t* config/sparc/sparc.c (sparc_attribute_table): Same.\n+\t* config/spu/spu.c (spu_attribute_table): Same.\n+\t* config/stormy16/stormy16.c (xstormy16_attribute_table): Same.\n+\t* config/v850/v850.c (v850_attribute_table): Same.\n+\t* config/visium/visium.c (visium_attribute_table): Same.\n+\n 2017-12-07  Tamar Christina  <tamar.christina@arm.com>\n \n \tPR target/82641"}, {"sha": "b43e50ab9ee382199dcc0d3d895a939505e008ff", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -1,3 +1,9 @@\n+2017-12-07  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/81544\n+\t* gcc-interface/utils.c (gnat_internal_attribute_table): Initialize\n+\tnew member of struct attribute_spec.\n+\n 2017-12-06  Simon Wright  <simon@pushface.org>\n \n \tPR ada/66205"}, {"sha": "ddeeb0370aed18cb0974defa211b2b931058286e", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -110,45 +110,47 @@ const struct attribute_spec gnat_internal_attribute_table[] =\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n        affects_type_identity } */\n   { \"const\",        0, 0,  true,  false, false, handle_const_attribute,\n-    false },\n+    false, NULL },\n   { \"nothrow\",      0, 0,  true,  false, false, handle_nothrow_attribute,\n-    false },\n+    false, NULL },\n   { \"pure\",         0, 0,  true,  false, false, handle_pure_attribute,\n-    false },\n+    false, NULL },\n   { \"no vops\",      0, 0,  true,  false, false, handle_novops_attribute,\n-    false },\n+    false, NULL },\n   { \"nonnull\",      0, -1, false, true,  true,  handle_nonnull_attribute,\n-    false },\n+    false, NULL },\n   { \"sentinel\",     0, 1,  false, true,  true,  handle_sentinel_attribute,\n-    false },\n+    false, NULL },\n   { \"noreturn\",     0, 0,  true,  false, false, handle_noreturn_attribute,\n-    false },\n+    false, NULL },\n   { \"noinline\",     0, 0,  true,  false, false, handle_noinline_attribute,\n-    false },\n+    false, NULL },\n   { \"noclone\",      0, 0,  true,  false, false, handle_noclone_attribute,\n-    false },\n+    false, NULL },\n   { \"leaf\",         0, 0,  true,  false, false, handle_leaf_attribute,\n-    false },\n+    false, NULL },\n   { \"always_inline\",0, 0,  true,  false, false, handle_always_inline_attribute,\n-    false },\n+    false, NULL },\n   { \"malloc\",       0, 0,  true,  false, false, handle_malloc_attribute,\n-    false },\n+    false, NULL },\n   { \"type generic\", 0, 0,  false, true, true, handle_type_generic_attribute,\n-    false },\n+    false, NULL },\n \n   { \"vector_size\",  1, 1,  false, true, false,  handle_vector_size_attribute,\n-    false },\n+    false, NULL },\n   { \"vector_type\",  0, 0,  false, true, false,  handle_vector_type_attribute,\n-    false },\n-  { \"may_alias\",    0, 0, false, true, false, NULL, false },\n+    false, NULL },\n+  { \"may_alias\",    0, 0, false, true, false, NULL, false, NULL },\n \n   /* ??? format and format_arg are heavy and not supported, which actually\n      prevents support for stdio builtins, which we however declare as part\n      of the common builtins.def contents.  */\n-  { \"format\",     3, 3,  false, true,  true,  fake_attribute_handler, false },\n-  { \"format_arg\", 1, 1,  false, true,  true,  fake_attribute_handler, false },\n+  { \"format\",     3, 3,  false, true,  true,  fake_attribute_handler, false,\n+    NULL },\n+  { \"format_arg\", 1, 1,  false, true,  true,  fake_attribute_handler, false,\n+    NULL },\n \n-  { NULL,         0, 0, false, false, false, NULL, false }\n+  { NULL,         0, 0, false, false, false, NULL, false, NULL }\n };\n \n /* Associates a GNAT tree node to a GCC tree node. It is used in"}, {"sha": "f65fd15814f818269aaa0437e5eb98725e718bd8", "filename": "gcc/attribs.c", "status": "modified", "additions": 268, "deletions": 9, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -28,6 +28,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stor-layout.h\"\n #include \"langhooks.h\"\n #include \"plugin.h\"\n+#include \"selftest.h\"\n+#include \"hash-set.h\"\n \n /* Table of the tables of attributes (common, language, format, machine)\n    searched.  */\n@@ -94,7 +96,7 @@ static bool attributes_initialized = false;\n \n static const struct attribute_spec empty_attribute_table[] =\n {\n-  { NULL, 0, 0, false, false, false, NULL, false }\n+  { NULL, 0, 0, false, false, false, NULL, false, NULL }\n };\n \n /* Return base name of the attribute.  Ie '__attr__' is turned into 'attr'.\n@@ -343,6 +345,97 @@ get_attribute_namespace (const_tree attr)\n   return get_identifier (\"gnu\");\n }\n \n+/* Check LAST_DECL and NODE of the same symbol for attributes that are\n+   recorded in SPEC to be mutually exclusive with ATTRNAME, diagnose\n+   them, and return true if any have been found.  NODE can be a DECL\n+   or a TYPE.  */\n+\n+static bool\n+diag_attr_exclusions (tree last_decl, tree node, tree attrname,\n+\t\t      const attribute_spec *spec)\n+{\n+  const attribute_spec::exclusions *excl = spec->exclude;\n+\n+  tree_code code = TREE_CODE (node);\n+\n+  if ((code == FUNCTION_DECL && !excl->function\n+       && (!excl->type || !spec->affects_type_identity))\n+      || (code == VAR_DECL && !excl->variable\n+\t  && (!excl->type || !spec->affects_type_identity))\n+      || (((code == TYPE_DECL || RECORD_OR_UNION_TYPE_P (node)) && !excl->type)))\n+    return false;\n+\n+  /* True if an attribute that's mutually exclusive with ATTRNAME\n+     has been found.  */\n+  bool found = false;\n+\n+  if (last_decl && last_decl != node && TREE_TYPE (last_decl) != node)\n+    {\n+      /* Check both the last DECL and its type for conflicts with\n+\t the attribute being added to the current decl or type.  */\n+      found |= diag_attr_exclusions (last_decl, last_decl, attrname, spec);\n+      tree decl_type = TREE_TYPE (last_decl);\n+      found |= diag_attr_exclusions (last_decl, decl_type, attrname, spec);\n+    }\n+\n+  /* NODE is either the current DECL to which the attribute is being\n+     applied or its TYPE.  For the former, consider the attributes on\n+     both the DECL and its type.  */\n+  tree attrs[2];\n+\n+  if (DECL_P (node))\n+    {\n+      attrs[0] = DECL_ATTRIBUTES (node);\n+      attrs[1] = TYPE_ATTRIBUTES (TREE_TYPE (node));\n+    }\n+  else\n+    {\n+      attrs[0] = TYPE_ATTRIBUTES (node);\n+      attrs[1] = NULL_TREE;\n+    }\n+\n+  /* Iterate over the mutually exclusive attribute names and verify\n+     that the symbol doesn't contain it.  */\n+  for (unsigned i = 0; i != sizeof attrs / sizeof *attrs; ++i)\n+    {\n+      if (!attrs[i])\n+\tcontinue;\n+\n+      for ( ; excl->name; ++excl)\n+\t{\n+\t  /* Avoid checking the attribute against itself.  */\n+\t  if (is_attribute_p (excl->name, attrname))\n+\t    continue;\n+\n+\t  if (!lookup_attribute (excl->name, attrs[i]))\n+\t    continue;\n+\n+\t  found = true;\n+\n+\t  /* Print a note?  */\n+\t  bool note = last_decl != NULL_TREE;\n+\n+\t  if (TREE_CODE (node) == FUNCTION_DECL\n+\t      && DECL_BUILT_IN (node))\n+\t    note &= warning (OPT_Wattributes,\n+\t\t\t     \"ignoring attribute %qE in declaration of \"\n+\t\t\t     \"a built-in function %qD because it conflicts \"\n+\t\t\t     \"with attribute %qs\",\n+\t\t\t     attrname, node, excl->name);\n+\t  else\n+\t    note &= warning (OPT_Wattributes,\n+\t\t\t     \"ignoring attribute %qE because \"\n+\t\t\t     \"it conflicts with attribute %qs\",\n+\t\t\t     attrname, excl->name);\n+\n+\t  if (note)\n+\t    inform (DECL_SOURCE_LOCATION (last_decl),\n+\t\t    \"previous declaration here\");\n+\t}\n+    }\n+\n+  return found;\n+}\n \n /* Process the attributes listed in ATTRIBUTES and install them in *NODE,\n    which is either a DECL (including a TYPE_DECL) or a TYPE.  If a DECL,\n@@ -354,7 +447,8 @@ get_attribute_namespace (const_tree attr)\n    a decl attribute to the declaration rather than to its type).  */\n \n tree\n-decl_attributes (tree *node, tree attributes, int flags)\n+decl_attributes (tree *node, tree attributes, int flags,\n+\t\t tree last_decl /* = NULL_TREE */)\n {\n   tree a;\n   tree returned_attrs = NULL_TREE;\n@@ -433,6 +527,8 @@ decl_attributes (tree *node, tree attributes, int flags)\n \n   targetm.insert_attributes (*node, &attributes);\n \n+  /* Note that attributes on the same declaration are not necessarily\n+     in the same order as in the source.  */\n   for (a = attributes; a; a = TREE_CHAIN (a))\n     {\n       tree ns = get_attribute_namespace (a);\n@@ -441,7 +537,6 @@ decl_attributes (tree *node, tree attributes, int flags)\n       tree *anode = node;\n       const struct attribute_spec *spec =\n \tlookup_scoped_attribute_spec (ns, name);\n-      bool no_add_attrs = 0;\n       int fn_ptr_quals = 0;\n       tree fn_ptr_tmp = NULL_TREE;\n \n@@ -490,7 +585,8 @@ decl_attributes (tree *node, tree attributes, int flags)\n \t\t       | (int) ATTR_FLAG_ARRAY_NEXT))\n \t    {\n \t      /* Pass on this attribute to be tried again.  */\n-\t      returned_attrs = tree_cons (name, args, returned_attrs);\n+\t      tree attr = tree_cons (name, args, NULL_TREE);\n+\t      returned_attrs = chainon (returned_attrs, attr);\n \t      continue;\n \t    }\n \t  else\n@@ -535,7 +631,8 @@ decl_attributes (tree *node, tree attributes, int flags)\n \t  else if (flags & (int) ATTR_FLAG_FUNCTION_NEXT)\n \t    {\n \t      /* Pass on this attribute to be tried again.  */\n-\t      returned_attrs = tree_cons (name, args, returned_attrs);\n+\t      tree attr = tree_cons (name, args, NULL_TREE);\n+\t      returned_attrs = chainon (returned_attrs, attr);\n \t      continue;\n \t    }\n \n@@ -557,15 +654,56 @@ decl_attributes (tree *node, tree attributes, int flags)\n \t  continue;\n \t}\n \n+      bool no_add_attrs = false;\n+\n       if (spec->handler != NULL)\n \t{\n \t  int cxx11_flag =\n \t    cxx11_attribute_p (a) ? ATTR_FLAG_CXX11 : 0;\n \n-\t  returned_attrs = chainon ((*spec->handler) (anode, name, args,\n-\t\t\t\t\t\t      flags|cxx11_flag,\n-\t\t\t\t\t\t      &no_add_attrs),\n-\t\t\t\t    returned_attrs);\n+\t  /* Pass in an array of the current declaration followed\n+\t     by the last pushed/merged declaration if  one exists.\n+\t     If the handler changes CUR_AND_LAST_DECL[0] replace\n+\t     *ANODE with its value.  */\n+\t  tree cur_and_last_decl[] = { *anode, last_decl };\n+\t  tree ret = (spec->handler) (cur_and_last_decl, name, args,\n+\t\t\t\t      flags|cxx11_flag, &no_add_attrs);\n+\n+\t  *anode = cur_and_last_decl[0];\n+\t  if (ret == error_mark_node)\n+\t    {\n+\t      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+\t      no_add_attrs = true;\n+\t    }\n+\t  else\n+\t    returned_attrs = chainon (ret, returned_attrs);\n+\t}\n+\n+      /* If the attribute was successfully handled on its own and is\n+\t about to be added check for exclusions with other attributes\n+\t on the current declation as well as the last declaration of\n+\t the same symbol already processed (if one exists).  */\n+      bool built_in = flags & ATTR_FLAG_BUILT_IN;\n+      if (spec->exclude\n+\t  && !no_add_attrs\n+\t  && (flag_checking || !built_in))\n+\t{\n+\t  /* Always check attributes on user-defined functions.\n+\t     Check them on built-ins only when -fchecking is set.\n+\t     Ignore __builtin_unreachable -- it's both const and\n+\t     noreturn.  */\n+\n+\t  if (!built_in\n+\t      || !DECL_P (*anode)\n+\t      || (DECL_FUNCTION_CODE (*anode) != BUILT_IN_UNREACHABLE\n+\t\t  && (DECL_FUNCTION_CODE (*anode)\n+\t\t      != BUILT_IN_UBSAN_HANDLE_BUILTIN_UNREACHABLE)))\n+\t    {\n+\t      bool no_add = diag_attr_exclusions (last_decl, *anode, name, spec);\n+\t      if (!no_add && anode != node)\n+\t\tno_add = diag_attr_exclusions (last_decl, *node, name, spec);\n+\t      no_add_attrs |= no_add;\n+\t    }\n \t}\n \n       /* Layout the decl in case anything changed.  */\n@@ -1647,3 +1785,124 @@ private_lookup_attribute (const char *attr_name, size_t attr_len, tree list)\n \n   return list;\n }\n+\n+#if CHECKING_P\n+\n+namespace selftest\n+{\n+\n+/* Helper types to verify the consistency attribute exclusions.  */\n+\n+typedef std::pair<const char *, const char *> excl_pair;\n+\n+struct excl_hash_traits: typed_noop_remove<excl_pair>\n+{\n+  typedef excl_pair  value_type;\n+  typedef value_type compare_type;\n+\n+  static hashval_t hash (const value_type &x)\n+  {\n+    hashval_t h1 = htab_hash_string (x.first);\n+    hashval_t h2 = htab_hash_string (x.second);\n+    return h1 ^ h2;\n+  }\n+\n+  static bool equal (const value_type &x, const value_type &y)\n+  {\n+    return !strcmp (x.first, y.first) && !strcmp (x.second, y.second);\n+  }\n+\n+  static void mark_deleted (value_type &x)\n+  {\n+    x = value_type (NULL, NULL);\n+  }\n+\n+  static void mark_empty (value_type &x)\n+  {\n+    x = value_type (\"\", \"\");\n+  }\n+\n+  static bool is_deleted (const value_type &x)\n+  {\n+    return !x.first && !x.second;\n+  }\n+\n+  static bool is_empty (const value_type &x)\n+  {\n+    return !*x.first && !*x.second;\n+  }\n+};\n+\n+\n+/* Self-test to verify that each attribute exclusion is symmetric,\n+   meaning that if attribute A is encoded as incompatible with\n+   attribute B then the opposite relationship is also encoded.\n+   This test also detects most cases of misspelled attribute names\n+   in exclusions.  */\n+\n+static void\n+test_attribute_exclusions ()\n+{\n+  /* Iterate over the array of attribute tables first (with TI0 as\n+     the index) and over the array of attribute_spec in each table\n+     (with SI0 as the index).  */\n+  const size_t ntables = ARRAY_SIZE (attribute_tables);\n+\n+  /* Set of pairs of mutually exclusive attributes.  */\n+  typedef hash_set<excl_pair, excl_hash_traits> exclusion_set;\n+  exclusion_set excl_set;\n+\n+  for (size_t ti0 = 0; ti0 != ntables; ++ti0)\n+    for (size_t s0 = 0; attribute_tables[ti0][s0].name; ++s0)\n+      {\n+\tconst attribute_spec::exclusions *excl\n+\t  = attribute_tables[ti0][s0].exclude;\n+\n+\t/* Skip each attribute that doesn't define exclusions.  */\n+\tif (!excl)\n+\t  continue;\n+\n+\tconst char *attr_name = attribute_tables[ti0][s0].name;\n+\n+\t/* Iterate over the set of exclusions for every attribute\n+\t   (with EI0 as the index) adding the exclusions defined\n+\t   for each to the set.  */\n+\tfor (size_t ei0 = 0; excl[ei0].name; ++ei0)\n+\t  {\n+\t    const char *excl_name = excl[ei0].name;\n+\n+\t    if (!strcmp (attr_name, excl_name))\n+\t      continue;\n+\n+\t    excl_set.add (excl_pair (attr_name, excl_name));\n+\t  }\n+      }\n+\n+  /* Traverse the set of mutually exclusive pairs of attributes\n+     and verify that they are symmetric.  */\n+  for (exclusion_set::iterator it = excl_set.begin ();\n+       it != excl_set.end ();\n+       ++it)\n+    {\n+      if (!excl_set.contains (excl_pair ((*it).second, (*it).first)))\n+\t{\n+\t  /* An exclusion for an attribute has been found that\n+\t     doesn't have a corresponding exclusion in the opposite\n+\t     direction.  */\n+\t  char desc[120];\n+\t  sprintf (desc, \"'%s' attribute exclusion '%s' must be symmetric\",\n+\t\t   (*it).first, (*it).second);\n+\t  fail (SELFTEST_LOCATION, desc);\n+\t}\n+    }\n+}\n+\n+void\n+attribute_c_tests ()\n+{\n+  test_attribute_exclusions ();\n+}\n+\n+} /* namespace selftest */\n+\n+#endif /* CHECKING_P */"}, {"sha": "182c71d27c8f60291fcfb0e03988b47f4b2d869f", "filename": "gcc/attribs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fattribs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fattribs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.h?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -31,7 +31,7 @@ extern void init_attributes (void);\n    from tree.h.  Depending on these flags, some attributes may be\n    returned to be applied at a later stage (for example, to apply\n    a decl attribute to the declaration rather than to its type).  */\n-extern tree decl_attributes (tree *, tree, int);\n+extern tree decl_attributes (tree *, tree, int, tree = NULL_TREE);\n \n extern bool cxx11_attribute_p (const_tree);\n extern tree get_attribute_name (const_tree);"}, {"sha": "2d9e8c06d12f1bd72d86e7fda1f596cefd7f09bb", "filename": "gcc/brig/brig-lang.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fbrig%2Fbrig-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fbrig%2Fbrig-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrig-lang.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -450,16 +450,16 @@ const struct attribute_spec brig_attribute_table[] =\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n        do_diagnostic } */\n   { \"leaf\",\t\t      0, 0, true,  false, false,\n-\t\t\t      handle_leaf_attribute, false },\n+\t\t\t      handle_leaf_attribute, false, NULL },\n   { \"const\",                  0, 0, true,  false, false,\n-\t\t\t      handle_const_attribute, false },\n+\t\t\t      handle_const_attribute, false, NULL },\n   { \"pure\",                   0, 0, true,  false, false,\n-\t\t\t      handle_pure_attribute, false },\n+\t\t\t      handle_pure_attribute, false, NULL },\n   { \"nothrow\",                0, 0, true,  false, false,\n-\t\t\t      handle_nothrow_attribute, false },\n+\t\t\t      handle_nothrow_attribute, false, NULL },\n   { \"returns_twice\",          0, 0, true,  false, false,\n-\t\t\t      handle_returns_twice_attribute, false },\n-  { NULL,                     0, 0, false, false, false, NULL, false }\n+\t\t\t      handle_returns_twice_attribute, false, NULL },\n+  { NULL,                     0, 0, false, false, false, NULL, false, NULL }\n };\n \n /* Attribute handlers.  */"}, {"sha": "4ad83f3628736bb32c18ed1a06659feeea4f785c", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -1,3 +1,20 @@\n+2017-12-07  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/81544\n+\tPR c/81566\n+\t* c-attribs.c (attr_aligned_exclusions): New array.\n+\t(attr_alloc_exclusions, attr_cold_hot_exclusions): Same.\n+\t(attr_common_exclusions, attr_const_pure_exclusions): Same.\n+\t(attr_gnu_inline_exclusions, attr_inline_exclusions): Same.\n+\t(attr_noreturn_exclusions, attr_returns_twice_exclusions): Same.\n+\t(attr_warn_unused_result_exclusions): Same.\n+\t(handle_hot_attribute, handle_cold_attribute): Simplify.\n+\t(handle_const_attribute): Warn on function returning void.\n+\t(handle_pure_attribute): Same.\n+\t(handle_aligned_attribute): Diagnose conflicting attribute\n+\tspecifications.\n+\t* c-warn.c (diagnose_mismatched_attributes): Simplify.\n+\n 2017-12-06  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c/83236"}, {"sha": "186df05eec58e5c6d81d0a8614b67ceb927582da", "filename": "gcc/c-family/c-attribs.c", "status": "modified", "additions": 279, "deletions": 131, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fc-family%2Fc-attribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fc-family%2Fc-attribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -150,6 +150,93 @@ static tree handle_fallthrough_attribute (tree *, tree, tree, int, bool *);\n static tree handle_patchable_function_entry_attribute (tree *, tree, tree,\n \t\t\t\t\t\t       int, bool *);\n \n+/* Helper to define attribute exclusions.  */\n+#define ATTR_EXCL(name, function, type, variable)\t\\\n+  { name, function, type, variable }\n+\n+/* Define attributes that are mutually exclusive with one another.  */\n+static const struct attribute_spec::exclusions attr_aligned_exclusions[] =\n+{\n+  /* Attribute name     exclusion applies to:\n+\t                function, type, variable */\n+  ATTR_EXCL (\"aligned\", true, false, false),\n+  ATTR_EXCL (\"packed\", true, false, false),\n+  ATTR_EXCL (NULL, false, false, false)\n+};\n+\n+static const struct attribute_spec::exclusions attr_cold_hot_exclusions[] =\n+{\n+  ATTR_EXCL (\"cold\", true, true, true),\n+  ATTR_EXCL (\"hot\", true, true, true),\n+  ATTR_EXCL (NULL, false, false, false)\n+};\n+\n+static const struct attribute_spec::exclusions attr_common_exclusions[] =\n+{\n+  ATTR_EXCL (\"common\", true, true, true),\n+  ATTR_EXCL (\"nocommon\", true, true, true),\n+  ATTR_EXCL (NULL, false, false, false),\n+};\n+\n+static const struct attribute_spec::exclusions attr_inline_exclusions[] =\n+{\n+  ATTR_EXCL (\"noinline\", true, true, true),\n+  ATTR_EXCL (NULL, false, false, false),\n+};\n+\n+static const struct attribute_spec::exclusions attr_noinline_exclusions[] =\n+{\n+  ATTR_EXCL (\"always_inline\", true, true, true),\n+  ATTR_EXCL (\"gnu_inline\", true, true, true),\n+  ATTR_EXCL (NULL, false, false, false),\n+};\n+\n+static const struct attribute_spec::exclusions attr_noreturn_exclusions[] =\n+{\n+  ATTR_EXCL (\"alloc_align\", true, true, true),\n+  ATTR_EXCL (\"alloc_size\", true, true, true),\n+  ATTR_EXCL (\"const\", true, true, true),\n+  ATTR_EXCL (\"malloc\", true, true, true),\n+  ATTR_EXCL (\"pure\", true, true, true),\n+  ATTR_EXCL (\"returns_twice\", true, true, true),\n+  ATTR_EXCL (\"warn_unused_result\", true, true, true),\n+  ATTR_EXCL (NULL, false, false, false),\n+};\n+\n+static const struct attribute_spec::exclusions\n+attr_warn_unused_result_exclusions[] =\n+{\n+  ATTR_EXCL (\"noreturn\", true, true, true),\n+  ATTR_EXCL (\"warn_unused_result\", true, true, true),\n+  ATTR_EXCL (NULL, false, false, false),\n+};\n+\n+static const struct attribute_spec::exclusions attr_returns_twice_exclusions[] =\n+{\n+  ATTR_EXCL (\"noreturn\", true, true, true),\n+  ATTR_EXCL (NULL, false, false, false),\n+};\n+\n+/* Exclusions that apply to attribute alloc_align, alloc_size, and malloc.  */\n+static const struct attribute_spec::exclusions attr_alloc_exclusions[] =\n+{\n+  ATTR_EXCL (\"const\", true, true, true),\n+  ATTR_EXCL (\"noreturn\", true, true, true),\n+  ATTR_EXCL (\"pure\", true, true, true),\n+  ATTR_EXCL (NULL, false, false, false),\n+};\n+\n+static const struct attribute_spec::exclusions attr_const_pure_exclusions[] =\n+{\n+  ATTR_EXCL (\"const\", true, true, true),\n+  ATTR_EXCL (\"alloc_align\", true, true, true),\n+  ATTR_EXCL (\"alloc_size\", true, true, true),\n+  ATTR_EXCL (\"malloc\", true, true, true),\n+  ATTR_EXCL (\"noreturn\", true, true, true),\n+  ATTR_EXCL (\"pure\", true, true, true),\n+  ATTR_EXCL (NULL, false, false, false)\n+};\n+\n /* Table of machine-independent attributes common to all C-like languages.\n \n    All attributes referencing arguments should be additionally processed\n@@ -161,214 +248,233 @@ const struct attribute_spec c_common_attribute_table[] =\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n        affects_type_identity } */\n   { \"packed\",                 0, 0, false, false, false,\n-\t\t\t      handle_packed_attribute , false},\n+\t\t\t      handle_packed_attribute, false,\n+\t                      attr_aligned_exclusions },\n   { \"nocommon\",               0, 0, true,  false, false,\n-\t\t\t      handle_nocommon_attribute, false},\n+\t\t\t      handle_nocommon_attribute, false,\n+\t                      attr_common_exclusions },\n   { \"common\",                 0, 0, true,  false, false,\n-\t\t\t      handle_common_attribute, false },\n+\t\t\t      handle_common_attribute, false,\n+\t                      attr_common_exclusions },\n   /* FIXME: logically, noreturn attributes should be listed as\n      \"false, true, true\" and apply to function types.  But implementing this\n      would require all the places in the compiler that use TREE_THIS_VOLATILE\n      on a decl to identify non-returning functions to be located and fixed\n      to check the function type instead.  */\n   { \"noreturn\",               0, 0, true,  false, false,\n-\t\t\t      handle_noreturn_attribute, false },\n+\t\t\t      handle_noreturn_attribute, false,\n+\t                      attr_noreturn_exclusions },\n   { \"volatile\",               0, 0, true,  false, false,\n-\t\t\t      handle_noreturn_attribute, false },\n+\t\t\t      handle_noreturn_attribute, false, NULL },\n   { \"stack_protect\",          0, 0, true,  false, false,\n-\t\t\t      handle_stack_protect_attribute, false },\n+\t\t\t      handle_stack_protect_attribute, false, NULL },\n   { \"noinline\",               0, 0, true,  false, false,\n-\t\t\t      handle_noinline_attribute, false },\n+\t\t\t      handle_noinline_attribute, false,\n+\t                      attr_noinline_exclusions },\n   { \"noclone\",                0, 0, true,  false, false,\n-\t\t\t      handle_noclone_attribute, false },\n+\t\t\t      handle_noclone_attribute, false, NULL },\n   { \"no_icf\",                 0, 0, true,  false, false,\n-\t\t\t      handle_noicf_attribute, false },\n+\t\t\t      handle_noicf_attribute, false, NULL },\n   { \"noipa\",\t\t      0, 0, true,  false, false,\n-\t\t\t      handle_noipa_attribute, false },\n+\t\t\t      handle_noipa_attribute, false, NULL },\n   { \"leaf\",                   0, 0, true,  false, false,\n-\t\t\t      handle_leaf_attribute, false },\n+\t\t\t      handle_leaf_attribute, false, NULL },\n   { \"always_inline\",          0, 0, true,  false, false,\n-\t\t\t      handle_always_inline_attribute, false },\n+\t\t\t      handle_always_inline_attribute, false,\n+\t                      attr_inline_exclusions },\n   { \"gnu_inline\",             0, 0, true,  false, false,\n-\t\t\t      handle_gnu_inline_attribute, false },\n+\t\t\t      handle_gnu_inline_attribute, false,\n+\t                      attr_inline_exclusions },\n   { \"artificial\",             0, 0, true,  false, false,\n-\t\t\t      handle_artificial_attribute, false },\n+\t\t\t      handle_artificial_attribute, false, NULL },\n   { \"flatten\",                0, 0, true,  false, false,\n-\t\t\t      handle_flatten_attribute, false },\n+\t\t\t      handle_flatten_attribute, false, NULL },\n   { \"used\",                   0, 0, true,  false, false,\n-\t\t\t      handle_used_attribute, false },\n+\t\t\t      handle_used_attribute, false, NULL },\n   { \"unused\",                 0, 0, false, false, false,\n-\t\t\t      handle_unused_attribute, false },\n+\t\t\t      handle_unused_attribute, false, NULL },\n   { \"externally_visible\",     0, 0, true,  false, false,\n-\t\t\t      handle_externally_visible_attribute, false },\n+\t\t\t      handle_externally_visible_attribute, false, NULL },\n   { \"no_reorder\",\t      0, 0, true, false, false,\n-                              handle_no_reorder_attribute, false },\n+\t                      handle_no_reorder_attribute, false, NULL },\n   /* The same comments as for noreturn attributes apply to const ones.  */\n   { \"const\",                  0, 0, true,  false, false,\n-\t\t\t      handle_const_attribute, false },\n+\t\t\t      handle_const_attribute, false,\n+\t                      attr_const_pure_exclusions },\n   { \"scalar_storage_order\",   1, 1, false, false, false,\n-\t\t\t      handle_scalar_storage_order_attribute, false },\n+\t\t\t      handle_scalar_storage_order_attribute, false, NULL },\n   { \"transparent_union\",      0, 0, false, false, false,\n-\t\t\t      handle_transparent_union_attribute, false },\n+\t\t\t      handle_transparent_union_attribute, false, NULL },\n   { \"constructor\",            0, 1, true,  false, false,\n-\t\t\t      handle_constructor_attribute, false },\n+\t\t\t      handle_constructor_attribute, false, NULL },\n   { \"destructor\",             0, 1, true,  false, false,\n-\t\t\t      handle_destructor_attribute, false },\n+\t\t\t      handle_destructor_attribute, false, NULL },\n   { \"mode\",                   1, 1, false,  true, false,\n-\t\t\t      handle_mode_attribute, false },\n+\t\t\t      handle_mode_attribute, false, NULL },\n   { \"section\",                1, 1, true,  false, false,\n-\t\t\t      handle_section_attribute, false },\n+\t\t\t      handle_section_attribute, false, NULL },\n   { \"aligned\",                0, 1, false, false, false,\n-\t\t\t      handle_aligned_attribute, false },\n+\t\t\t      handle_aligned_attribute, false,\n+\t                      attr_aligned_exclusions },\n   { \"warn_if_not_aligned\",    0, 1, false, false, false,\n \t\t\t      handle_warn_if_not_aligned_attribute,\n-\t\t\t      false },\n+\t\t\t      false, NULL },\n   { \"weak\",                   0, 0, true,  false, false,\n-\t\t\t      handle_weak_attribute, false },\n+\t\t\t      handle_weak_attribute, false, NULL },\n   { \"noplt\",                   0, 0, true,  false, false,\n-\t\t\t      handle_noplt_attribute, false },\n+\t\t\t      handle_noplt_attribute, false, NULL },\n   { \"ifunc\",                  1, 1, true,  false, false,\n-\t\t\t      handle_ifunc_attribute, false },\n+\t\t\t      handle_ifunc_attribute, false, NULL },\n   { \"alias\",                  1, 1, true,  false, false,\n-\t\t\t      handle_alias_attribute, false },\n+\t\t\t      handle_alias_attribute, false, NULL },\n   { \"weakref\",                0, 1, true,  false, false,\n-\t\t\t      handle_weakref_attribute, false },\n+\t\t\t      handle_weakref_attribute, false, NULL },\n   { \"no_instrument_function\", 0, 0, true,  false, false,\n \t\t\t      handle_no_instrument_function_attribute,\n-\t\t\t      false },\n+\t\t\t      false, NULL },\n   { \"no_profile_instrument_function\",  0, 0, true, false, false,\n \t\t\t      handle_no_profile_instrument_function_attribute,\n-\t\t\t      false },\n+\t\t\t      false, NULL },\n   { \"malloc\",                 0, 0, true,  false, false,\n-\t\t\t      handle_malloc_attribute, false },\n+\t\t\t      handle_malloc_attribute, false,\n+\t                      attr_alloc_exclusions },\n   { \"returns_twice\",          0, 0, true,  false, false,\n-\t\t\t      handle_returns_twice_attribute, false },\n+\t\t\t      handle_returns_twice_attribute, false,\n+\t                      attr_returns_twice_exclusions },\n   { \"no_stack_limit\",         0, 0, true,  false, false,\n-\t\t\t      handle_no_limit_stack_attribute, false },\n+\t\t\t      handle_no_limit_stack_attribute, false, NULL },\n   { \"pure\",                   0, 0, true,  false, false,\n-\t\t\t      handle_pure_attribute, false },\n+\t\t\t      handle_pure_attribute, false,\n+\t                      attr_const_pure_exclusions },\n   { \"transaction_callable\",   0, 0, false, true,  false,\n-\t\t\t      handle_tm_attribute, false },\n+\t\t\t      handle_tm_attribute, false, NULL },\n   { \"transaction_unsafe\",     0, 0, false, true,  false,\n-\t\t\t      handle_tm_attribute, true },\n+\t\t\t      handle_tm_attribute, true, NULL },\n   { \"transaction_safe\",       0, 0, false, true,  false,\n-\t\t\t      handle_tm_attribute, true },\n+\t\t\t      handle_tm_attribute, true, NULL },\n   { \"transaction_safe_dynamic\", 0, 0, true, false,  false,\n-\t\t\t      handle_tm_attribute, false },\n+\t\t\t      handle_tm_attribute, false, NULL },\n   { \"transaction_may_cancel_outer\", 0, 0, false, true, false,\n-\t\t\t      handle_tm_attribute, false },\n+\t\t\t      handle_tm_attribute, false, NULL },\n   /* ??? These two attributes didn't make the transition from the\n      Intel language document to the multi-vendor language document.  */\n   { \"transaction_pure\",       0, 0, false, true,  false,\n-\t\t\t      handle_tm_attribute, false },\n+\t\t\t      handle_tm_attribute, false, NULL },\n   { \"transaction_wrap\",       1, 1, true,  false,  false,\n-\t\t\t     handle_tm_wrap_attribute, false },\n+\t\t\t     handle_tm_wrap_attribute, false, NULL },\n   /* For internal use (marking of builtins) only.  The name contains space\n      to prevent its usage in source code.  */\n   { \"no vops\",                0, 0, true,  false, false,\n-\t\t\t      handle_novops_attribute, false },\n+\t\t\t      handle_novops_attribute, false, NULL },\n   { \"deprecated\",             0, 1, false, false, false,\n-\t\t\t      handle_deprecated_attribute, false },\n+\t\t\t      handle_deprecated_attribute, false, NULL },\n   { \"vector_size\",\t      1, 1, false, true, false,\n-\t\t\t      handle_vector_size_attribute, true },\n+\t\t\t      handle_vector_size_attribute, true, NULL },\n   { \"visibility\",\t      1, 1, false, false, false,\n-\t\t\t      handle_visibility_attribute, false },\n+\t\t\t      handle_visibility_attribute, false, NULL },\n   { \"tls_model\",\t      1, 1, true,  false, false,\n-\t\t\t      handle_tls_model_attribute, false },\n+\t\t\t      handle_tls_model_attribute, false, NULL },\n   { \"nonnull\",                0, -1, false, true, true,\n-\t\t\t      handle_nonnull_attribute, false },\n+\t\t\t      handle_nonnull_attribute, false, NULL },\n   { \"nonstring\",              0, 0, true, false, false,\n-\t\t\t      handle_nonstring_attribute, false },\n+\t\t\t      handle_nonstring_attribute, false, NULL },\n   { \"nothrow\",                0, 0, true,  false, false,\n-\t\t\t      handle_nothrow_attribute, false },\n-  { \"may_alias\",\t      0, 0, false, true, false, NULL, false },\n+\t\t\t      handle_nothrow_attribute, false, NULL },\n+  { \"may_alias\",\t      0, 0, false, true, false, NULL, false, NULL },\n   { \"cleanup\",\t\t      1, 1, true, false, false,\n-\t\t\t      handle_cleanup_attribute, false },\n+\t\t\t      handle_cleanup_attribute, false, NULL },\n   { \"warn_unused_result\",     0, 0, false, true, true,\n-\t\t\t      handle_warn_unused_result_attribute, false },\n+\t\t\t      handle_warn_unused_result_attribute, false,\n+\t                      attr_warn_unused_result_exclusions },\n   { \"sentinel\",               0, 1, false, true, true,\n-\t\t\t      handle_sentinel_attribute, false },\n+\t\t\t      handle_sentinel_attribute, false, NULL },\n   /* For internal use (marking of builtins) only.  The name contains space\n      to prevent its usage in source code.  */\n   { \"type generic\",           0, 0, false, true, true,\n-\t\t\t      handle_type_generic_attribute, false },\n+\t\t\t      handle_type_generic_attribute, false, NULL },\n   { \"alloc_size\",\t      1, 2, false, true, true,\n-\t\t\t      handle_alloc_size_attribute, false },\n+\t\t\t      handle_alloc_size_attribute, false,\n+\t                      attr_alloc_exclusions },\n   { \"cold\",                   0, 0, true,  false, false,\n-\t\t\t      handle_cold_attribute, false },\n+\t\t\t      handle_cold_attribute, false,\n+\t                      attr_cold_hot_exclusions },\n   { \"hot\",                    0, 0, true,  false, false,\n-\t\t\t      handle_hot_attribute, false },\n+\t\t\t      handle_hot_attribute, false,\n+\t                      attr_cold_hot_exclusions },\n   { \"no_address_safety_analysis\",\n \t\t\t      0, 0, true, false, false,\n \t\t\t      handle_no_address_safety_analysis_attribute,\n-\t\t\t      false },\n+\t\t\t      false, NULL },\n   { \"no_sanitize\",\t      1, 1, true, false, false,\n \t\t\t      handle_no_sanitize_attribute,\n-\t\t\t      false },\n+\t\t\t      false, NULL },\n   { \"no_sanitize_address\",    0, 0, true, false, false,\n \t\t\t      handle_no_sanitize_address_attribute,\n-\t\t\t      false },\n+\t\t\t      false, NULL },\n   { \"no_sanitize_thread\",     0, 0, true, false, false,\n \t\t\t      handle_no_sanitize_thread_attribute,\n-\t\t\t      false },\n+\t\t\t      false, NULL },\n   { \"no_sanitize_undefined\",  0, 0, true, false, false,\n \t\t\t      handle_no_sanitize_undefined_attribute,\n-\t\t\t      false },\n+\t\t\t      false, NULL },\n   { \"asan odr indicator\",     0, 0, true, false, false,\n \t\t\t      handle_asan_odr_indicator_attribute,\n-\t\t\t      false },\n+\t\t\t      false, NULL },\n   { \"warning\",\t\t      1, 1, true,  false, false,\n-\t\t\t      handle_error_attribute, false },\n+\t\t\t      handle_error_attribute, false, NULL },\n   { \"error\",\t\t      1, 1, true,  false, false,\n-\t\t\t      handle_error_attribute, false },\n+\t\t\t      handle_error_attribute, false, NULL },\n   { \"target\",                 1, -1, true, false, false,\n-\t\t\t      handle_target_attribute, false },\n+\t\t\t      handle_target_attribute, false, NULL },\n   { \"target_clones\",          1, -1, true, false, false,\n-\t\t\t      handle_target_clones_attribute, false },\n+\t\t\t      handle_target_clones_attribute, false, NULL },\n   { \"optimize\",               1, -1, true, false, false,\n-\t\t\t      handle_optimize_attribute, false },\n+\t\t\t      handle_optimize_attribute, false, NULL },\n   /* For internal use only.  The leading '*' both prevents its usage in\n      source code and signals that it may be overridden by machine tables.  */\n   { \"*tm regparm\",            0, 0, false, true, true,\n-\t\t\t      ignore_attribute, false },\n+\t\t\t      ignore_attribute, false, NULL },\n   { \"no_split_stack\",\t      0, 0, true,  false, false,\n-\t\t\t      handle_no_split_stack_attribute, false },\n+\t\t\t      handle_no_split_stack_attribute, false, NULL },\n   /* For internal use (marking of builtins and runtime functions) only.\n      The name contains space to prevent its usage in source code.  */\n   { \"fn spec\",\t\t      1, 1, false, true, true,\n-\t\t\t      handle_fnspec_attribute, false },\n+\t\t\t      handle_fnspec_attribute, false, NULL },\n   { \"warn_unused\",            0, 0, false, false, false,\n-\t\t\t      handle_warn_unused_attribute, false },\n+\t\t\t      handle_warn_unused_attribute, false, NULL },\n   { \"returns_nonnull\",        0, 0, false, true, true,\n-\t\t\t      handle_returns_nonnull_attribute, false },\n+\t\t\t      handle_returns_nonnull_attribute, false, NULL },\n   { \"omp declare simd\",       0, -1, true,  false, false,\n-\t\t\t      handle_omp_declare_simd_attribute, false },\n+\t\t\t      handle_omp_declare_simd_attribute, false, NULL },\n+  { \"cilk simd function\",     0, -1, true,  false, false,\n+\t\t\t      handle_omp_declare_simd_attribute, false, NULL },\n   { \"simd\",\t\t      0, 1, true,  false, false,\n-\t\t\t      handle_simd_attribute, false },\n+\t\t\t      handle_simd_attribute, false, NULL },\n   { \"omp declare target\",     0, 0, true, false, false,\n-\t\t\t      handle_omp_declare_target_attribute, false },\n+\t\t\t      handle_omp_declare_target_attribute, false, NULL },\n   { \"omp declare target link\", 0, 0, true, false, false,\n-\t\t\t      handle_omp_declare_target_attribute, false },\n+\t\t\t      handle_omp_declare_target_attribute, false, NULL },\n   { \"alloc_align\",\t      1, 1, false, true, true,\n-\t\t\t      handle_alloc_align_attribute, false },\n+\t\t\t      handle_alloc_align_attribute, false,\n+\t                      attr_alloc_exclusions },\n   { \"assume_aligned\",\t      1, 2, false, true, true,\n-\t\t\t      handle_assume_aligned_attribute, false },\n+\t\t\t      handle_assume_aligned_attribute, false, NULL },\n   { \"designated_init\",        0, 0, false, true, false,\n-\t\t\t      handle_designated_init_attribute, false },\n+\t\t\t      handle_designated_init_attribute, false, NULL },\n   { \"bnd_variable_size\",      0, 0, true,  false, false,\n-\t\t\t      handle_bnd_variable_size_attribute, false },\n+\t\t\t      handle_bnd_variable_size_attribute, false, NULL },\n   { \"bnd_legacy\",             0, 0, true, false, false,\n-\t\t\t      handle_bnd_legacy, false },\n+\t\t\t      handle_bnd_legacy, false, NULL },\n   { \"bnd_instrument\",         0, 0, true, false, false,\n-\t\t\t      handle_bnd_instrument, false },\n+\t\t\t      handle_bnd_instrument, false, NULL },\n   { \"fallthrough\",\t      0, 0, false, false, false,\n-\t\t\t      handle_fallthrough_attribute, false },\n+\t\t\t      handle_fallthrough_attribute, false, NULL },\n   { \"patchable_function_entry\",\t1, 2, true, false, false,\n \t\t\t      handle_patchable_function_entry_attribute,\n-\t\t\t      false },\n-  { \"nocf_check\",\t\t      0, 0, false, true, true,\n-\t\t\t      handle_nocf_check_attribute, true },\n-  { NULL,                     0, 0, false, false, false, NULL, false }\n+\t\t\t      false, NULL },\n+  { \"nocf_check\",\t      0, 0, false, true, true,\n+\t\t\t      handle_nocf_check_attribute, true, NULL },\n+  { NULL,                     0, 0, false, false, false, NULL, false, NULL }\n };\n \n /* Give the specifications for the format attributes, used by C and all\n@@ -383,10 +489,10 @@ const struct attribute_spec c_common_format_attribute_table[] =\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n        affects_type_identity } */\n   { \"format\",                 3, 3, false, true,  true,\n-\t\t\t      handle_format_attribute, false },\n+\t\t\t      handle_format_attribute, false, NULL },\n   { \"format_arg\",             1, 1, false, true,  true,\n-\t\t\t      handle_format_arg_attribute, false },\n-  { NULL,                     0, 0, false, false, false, NULL, false }\n+\t\t\t      handle_format_arg_attribute, false, NULL },\n+  { NULL,                     0, 0, false, false, false, NULL, false, NULL }\n };\n \n /* Returns TRUE iff the attribute indicated by ATTR_ID takes a plain\n@@ -524,14 +630,7 @@ handle_hot_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n   if (TREE_CODE (*node) == FUNCTION_DECL\n       || TREE_CODE (*node) == LABEL_DECL)\n     {\n-      if (lookup_attribute (\"cold\", DECL_ATTRIBUTES (*node)) != NULL)\n-\t{\n-\t  warning (OPT_Wattributes, \"%qE attribute ignored due to conflict \"\n-\t\t   \"with attribute %qs\", name, \"cold\");\n-\t  *no_add_attrs = true;\n-\t}\n-      /* Most of the rest of the hot processing is done later with\n-\t lookup_attribute.  */\n+      /* Attribute hot processing is done later with lookup_attribute.  */\n     }\n   else\n     {\n@@ -552,14 +651,7 @@ handle_cold_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n   if (TREE_CODE (*node) == FUNCTION_DECL\n       || TREE_CODE (*node) == LABEL_DECL)\n     {\n-      if (lookup_attribute (\"hot\", DECL_ATTRIBUTES (*node)) != NULL)\n-\t{\n-\t  warning (OPT_Wattributes, \"%qE attribute ignored due to conflict \"\n-\t\t   \"with attribute %qs\", name, \"hot\");\n-\t  *no_add_attrs = true;\n-\t}\n-      /* Most of the rest of the cold processing is done later with\n-\t lookup_attribute.  */\n+      /* Attribute cold processing is done later with lookup_attribute.  */\n     }\n   else\n     {\n@@ -1086,7 +1178,7 @@ handle_no_reorder_attribute (tree *pnode,\n \n static tree\n handle_const_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n-\t\t\tint ARG_UNUSED (flags), bool *no_add_attrs)\n+\t\t\tint flags, bool *no_add_attrs)\n {\n   tree type = TREE_TYPE (*node);\n \n@@ -1107,6 +1199,14 @@ handle_const_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n       *no_add_attrs = true;\n     }\n \n+  /* void __builtin_unreachable(void) is const.  Accept other such\n+     built-ins but warn on user-defined functions that return void.  */\n+  if (!(flags & ATTR_FLAG_BUILT_IN)\n+      && TREE_CODE (*node) == FUNCTION_DECL\n+      && VOID_TYPE_P (TREE_TYPE (type)))\n+    warning (OPT_Wattributes, \"%qE attribute on function \"\n+\t     \"returning %<void%>\", name);\n+\n   return NULL_TREE;\n }\n \n@@ -1689,15 +1789,19 @@ check_cxx_fundamental_alignment_constraints (tree node,\n    handle_aligned_attribute.  */\n \n static tree\n-common_handle_aligned_attribute (tree *node, tree args, int flags,\n+common_handle_aligned_attribute (tree *node, tree name, tree args, int flags,\n \t\t\t\t bool *no_add_attrs,\n \t\t\t\t bool warn_if_not_aligned_p)\n {\n   tree decl = NULL_TREE;\n   tree *type = NULL;\n-  int is_type = 0;\n+  bool is_type = false;\n   tree align_expr;\n-  int i;\n+\n+  /* The last (already pushed) declaration with all validated attributes\n+     merged in or the current about-to-be-pushed one if one hasn't been\n+     yet.  */\n+  tree last_decl = node[1] ? node[1] : *node;\n \n   if (args)\n     {\n@@ -1716,10 +1820,21 @@ common_handle_aligned_attribute (tree *node, tree args, int flags,\n       is_type = TREE_CODE (*node) == TYPE_DECL;\n     }\n   else if (TYPE_P (*node))\n-    type = node, is_type = 1;\n+    type = node, is_type = true;\n+\n+  /* Log2 of specified alignment.  */\n+  int pow2align = check_user_alignment (align_expr, true);\n+\n+  /* The alignment in bits corresponding to the specified alignment.  */\n+  unsigned bitalign = (1U << pow2align) * BITS_PER_UNIT;\n+\n+  /* The alignment of the current declaration and that of the last\n+     pushed declaration, determined on demand below.  */\n+  unsigned curalign = 0;\n+  unsigned lastalign = 0;\n \n-  if ((i = check_user_alignment (align_expr, true)) == -1\n-      || !check_cxx_fundamental_alignment_constraints (*node, i, flags))\n+  if (pow2align == -1\n+      || !check_cxx_fundamental_alignment_constraints (*node, pow2align, flags))\n     *no_add_attrs = true;\n   else if (is_type)\n     {\n@@ -1742,12 +1857,12 @@ common_handle_aligned_attribute (tree *node, tree args, int flags,\n \n       if (warn_if_not_aligned_p)\n \t{\n-\t  SET_TYPE_WARN_IF_NOT_ALIGN (*type, (1U << i) * BITS_PER_UNIT);\n+\t  SET_TYPE_WARN_IF_NOT_ALIGN (*type, bitalign);\n \t  warn_if_not_aligned_p = false;\n \t}\n       else\n \t{\n-\t  SET_TYPE_ALIGN (*type, (1U << i) * BITS_PER_UNIT);\n+\t  SET_TYPE_ALIGN (*type, bitalign);\n \t  TYPE_USER_ALIGN (*type) = 1;\n \t}\n     }\n@@ -1757,8 +1872,34 @@ common_handle_aligned_attribute (tree *node, tree args, int flags,\n       error (\"alignment may not be specified for %q+D\", decl);\n       *no_add_attrs = true;\n     }\n+  else if (TREE_CODE (decl) == FUNCTION_DECL\n+\t   && ((curalign = DECL_ALIGN (decl)) > bitalign\n+\t       || ((lastalign = DECL_ALIGN (last_decl)) > bitalign)))\n+    {\n+      /* Either a prior attribute on the same declaration or one\n+\t on a prior declaration of the same function specifies\n+\t stricter alignment than this attribute.  */\n+      bool note = lastalign != 0;\n+      if (lastalign)\n+\tcuralign = lastalign;\n+\n+      curalign /= BITS_PER_UNIT;\n+      bitalign /= BITS_PER_UNIT;\n+\n+      if (DECL_USER_ALIGN (decl) || DECL_USER_ALIGN (last_decl))\n+\twarning (OPT_Wattributes,\n+\t\t \"ignoring attribute %<%E (%u)%> because it conflicts with \"\n+\t\t \"attribute %<%E (%u)%>\", name, bitalign, name, curalign);\n+      else\n+\terror (\"alignment for %q+D must be at least %d\", decl, curalign);\n+\n+      if (note)\n+\tinform (DECL_SOURCE_LOCATION (last_decl), \"previous declaration here\");\n+\n+      *no_add_attrs = true;\n+    }\n   else if (DECL_USER_ALIGN (decl)\n-\t   && DECL_ALIGN (decl) > (1U << i) * BITS_PER_UNIT)\n+\t   && DECL_ALIGN (decl) > bitalign)\n     /* C++-11 [dcl.align/4]:\n \n \t   When multiple alignment-specifiers are specified for an\n@@ -1770,7 +1911,7 @@ common_handle_aligned_attribute (tree *node, tree args, int flags,\n     *no_add_attrs = true;\n   else if (!warn_if_not_aligned_p\n \t   && TREE_CODE (decl) == FUNCTION_DECL\n-\t   && DECL_ALIGN (decl) > (1U << i) * BITS_PER_UNIT)\n+\t   && DECL_ALIGN (decl) > bitalign)\n     {\n       /* Don't warn function alignment here if warn_if_not_aligned_p is\n \t true.  It will be warned later.  */\n@@ -1789,13 +1930,13 @@ common_handle_aligned_attribute (tree *node, tree args, int flags,\n \t{\n \t  if (TREE_CODE (decl) == FIELD_DECL && !DECL_C_BIT_FIELD (decl))\n \t    {\n-\t      SET_DECL_WARN_IF_NOT_ALIGN (decl, (1U << i) * BITS_PER_UNIT);\n+\t      SET_DECL_WARN_IF_NOT_ALIGN (decl, bitalign);\n \t      warn_if_not_aligned_p = false;\n \t    }\n \t}\n       else\n \t{\n-\t  SET_DECL_ALIGN (decl, (1U << i) * BITS_PER_UNIT);\n+\t  SET_DECL_ALIGN (decl, bitalign);\n \t  DECL_USER_ALIGN (decl) = 1;\n \t}\n     }\n@@ -1814,22 +1955,22 @@ common_handle_aligned_attribute (tree *node, tree args, int flags,\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_aligned_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n+handle_aligned_attribute (tree *node, tree name, tree args,\n \t\t\t  int flags, bool *no_add_attrs)\n {\n-  return common_handle_aligned_attribute (node, args, flags,\n+  return common_handle_aligned_attribute (node, name, args, flags,\n \t\t\t\t\t no_add_attrs, false);\n }\n \n /* Handle a \"warn_if_not_aligned\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_warn_if_not_aligned_attribute (tree *node, tree ARG_UNUSED (name),\n+handle_warn_if_not_aligned_attribute (tree *node, tree name,\n \t\t\t\t      tree args, int flags,\n \t\t\t\t      bool *no_add_attrs)\n {\n-  return common_handle_aligned_attribute (node, args, flags,\n+  return common_handle_aligned_attribute (node, name, args, flags,\n \t\t\t\t\t  no_add_attrs, true);\n }\n \n@@ -2538,8 +2679,15 @@ handle_pure_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n \t\t       int ARG_UNUSED (flags), bool *no_add_attrs)\n {\n   if (TREE_CODE (*node) == FUNCTION_DECL)\n-    DECL_PURE_P (*node) = 1;\n-  /* ??? TODO: Support types.  */\n+    {\n+      tree type = TREE_TYPE (*node);\n+      if (VOID_TYPE_P (TREE_TYPE (type)))\n+\twarning (OPT_Wattributes, \"%qE attribute on function \"\n+\t\t \"returning %<void%>\", name);\n+\n+      DECL_PURE_P (*node) = 1;\n+      /* ??? TODO: Support types.  */\n+    }\n   else\n     {\n       warning (OPT_Wattributes, \"%qE attribute ignored\", name);"}, {"sha": "6045d6e17a97f508b3b9b1d769a39949852cc0b0", "filename": "gcc/c-family/c-warn.c", "status": "modified", "additions": 6, "deletions": 23, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fc-family%2Fc-warn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fc-family%2Fc-warn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-warn.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -2230,36 +2230,19 @@ diagnose_mismatched_attributes (tree olddecl, tree newdecl)\n \t\t       newdecl);\n \n   /* Diagnose inline __attribute__ ((noinline)) which is silly.  */\n+  const char *noinline = \"noinline\";\n+\n   if (DECL_DECLARED_INLINE_P (newdecl)\n       && DECL_UNINLINABLE (olddecl)\n-      && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (olddecl)))\n+      && lookup_attribute (noinline, DECL_ATTRIBUTES (olddecl)))\n     warned |= warning (OPT_Wattributes, \"inline declaration of %qD follows \"\n-\t\t       \"declaration with attribute noinline\", newdecl);\n+\t\t       \"declaration with attribute %qs\", newdecl, noinline);\n   else if (DECL_DECLARED_INLINE_P (olddecl)\n \t   && DECL_UNINLINABLE (newdecl)\n \t   && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (newdecl)))\n     warned |= warning (OPT_Wattributes, \"declaration of %q+D with attribute \"\n-\t\t       \"noinline follows inline declaration \", newdecl);\n-  else if (lookup_attribute (\"noinline\", DECL_ATTRIBUTES (newdecl))\n-\t   && lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (olddecl)))\n-    warned |= warning (OPT_Wattributes, \"declaration of %q+D with attribute \"\n-\t\t       \"%qs follows declaration with attribute %qs\",\n-\t\t       newdecl, \"noinline\", \"always_inline\");\n-  else if (lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (newdecl))\n-\t   && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (olddecl)))\n-    warned |= warning (OPT_Wattributes, \"declaration of %q+D with attribute \"\n-\t\t       \"%qs follows declaration with attribute %qs\",\n-\t\t       newdecl, \"always_inline\", \"noinline\");\n-  else if (lookup_attribute (\"cold\", DECL_ATTRIBUTES (newdecl))\n-\t   && lookup_attribute (\"hot\", DECL_ATTRIBUTES (olddecl)))\n-    warned |= warning (OPT_Wattributes, \"declaration of %q+D with attribute \"\n-\t\t       \"%qs follows declaration with attribute %qs\",\n-\t\t       newdecl, \"cold\", \"hot\");\n-  else if (lookup_attribute (\"hot\", DECL_ATTRIBUTES (newdecl))\n-\t   && lookup_attribute (\"cold\", DECL_ATTRIBUTES (olddecl)))\n-    warned |= warning (OPT_Wattributes, \"declaration of %q+D with attribute \"\n-\t\t       \"%qs follows declaration with attribute %qs\",\n-\t\t       newdecl, \"hot\", \"cold\");\n+\t\t       \"%qs follows inline declaration \", newdecl, noinline);\n+\n   return warned;\n }\n "}, {"sha": "6e11827f39ccd154d91aaffa01dc1737ad81c9a1", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -1,3 +1,9 @@\n+2017-12-07  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/81544\n+\t* c-decl.c (c_decl_attributes): Look up existing declaration and\n+\tpass it to decl_attributes.\n+\n 2017-12-06  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c/83236"}, {"sha": "aaa967874727613e3fc955627ab18829340a53c6", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -4632,7 +4632,16 @@ c_decl_attributes (tree *node, tree attributes, int flags)\n \tattributes = tree_cons (get_identifier (\"omp declare target\"),\n \t\t\t\tNULL_TREE, attributes);\n     }\n-  return decl_attributes (node, attributes, flags);\n+\n+  /* Look up the current declaration with all the attributes merged\n+     so far so that attributes on the current declaration that's\n+     about to be pushed that conflict with the former can be detected,\n+     diagnosed, and rejected as appropriate.  */\n+  tree last_decl = lookup_name (DECL_NAME (*node));\n+  if (!last_decl)\n+    last_decl = lookup_name_in_scope (DECL_NAME (*node), external_scope);\n+\n+  return decl_attributes (node, attributes, flags, last_decl);\n }\n \n "}, {"sha": "edf9cb4af5932e1edbe251ffc996c1d3b0db3358", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -7506,9 +7506,10 @@ common_object_handler (tree *node, tree name ATTRIBUTE_UNUSED,\n static const struct attribute_spec vms_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n-       affects_type_identity } */\n-  { COMMON_OBJECT,   0, 1, true,  false, false, common_object_handler, false },\n-  { NULL,            0, 0, false, false, false, NULL, false }\n+       affects_type_identity, exclusions } */\n+  { COMMON_OBJECT,   0, 1, true,  false, false, common_object_handler, false,\n+    NULL },\n+  { NULL,            0, 0, false, false, false, NULL, false, NULL }\n };\n \n void"}, {"sha": "aaefc300a9f2296646c0db12d8d6928c780203fc", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -219,21 +219,23 @@ const struct attribute_spec arc_attribute_table[] =\n {\n  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n       affects_type_identity } */\n-  { \"interrupt\", 1, 1, true, false, false, arc_handle_interrupt_attribute, true },\n+  { \"interrupt\", 1, 1, true, false, false, arc_handle_interrupt_attribute,\n+      true, NULL },\n   /* Function calls made to this symbol must be done indirectly, because\n      it may lie outside of the 21/25 bit addressing range of a normal function\n      call.  */\n-  { \"long_call\",    0, 0, false, true,  true,  NULL, false },\n+  { \"long_call\",    0, 0, false, true,  true,  NULL, false, NULL },\n   /* Whereas these functions are always known to reside within the 25 bit\n      addressing range of unconditionalized bl.  */\n-  { \"medium_call\",   0, 0, false, true,  true,  NULL, false },\n+  { \"medium_call\",   0, 0, false, true,  true,  NULL, false, NULL },\n   /* And these functions are always known to reside within the 21 bit\n      addressing range of blcc.  */\n-  { \"short_call\",   0, 0, false, true,  true,  NULL, false },\n+  { \"short_call\",   0, 0, false, true,  true,  NULL, false, NULL },\n   /* Function which are not having the prologue and epilogue generated\n      by the compiler.  */\n-  { \"naked\", 0, 0, true, false, false, arc_handle_fndecl_attribute, false },\n-  { NULL, 0, 0, false, false, false, NULL, false }\n+  { \"naked\", 0, 0, true, false, false, arc_handle_fndecl_attribute, false,\n+    NULL },\n+  { NULL, 0, 0, false, false, false, NULL, false, NULL }\n };\n static int arc_comp_type_attributes (const_tree, const_tree);\n static void arc_file_start (void);"}, {"sha": "f34b6e0d93315e99372cc61d22c971f2641d7943", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -323,24 +323,24 @@ static HOST_WIDE_INT arm_constant_alignment (const_tree, HOST_WIDE_INT);\n static const struct attribute_spec arm_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n-       affects_type_identity } */\n+       affects_type_identity, exclusions } */\n   /* Function calls made to this symbol must be done indirectly, because\n      it may lie outside of the 26 bit addressing range of a normal function\n      call.  */\n-  { \"long_call\",    0, 0, false, true,  true,  NULL, false },\n+  { \"long_call\",    0, 0, false, true,  true,  NULL, false, NULL },\n   /* Whereas these functions are always known to reside within the 26 bit\n      addressing range.  */\n-  { \"short_call\",   0, 0, false, true,  true,  NULL, false },\n+  { \"short_call\",   0, 0, false, true,  true,  NULL, false, NULL },\n   /* Specify the procedure call conventions for a function.  */\n   { \"pcs\",          1, 1, false, true,  true,  arm_handle_pcs_attribute,\n-    false },\n+    false, NULL },\n   /* Interrupt Service Routines have special prologue and epilogue requirements.  */\n   { \"isr\",          0, 1, false, false, false, arm_handle_isr_attribute,\n-    false },\n+    false, NULL },\n   { \"interrupt\",    0, 1, false, false, false, arm_handle_isr_attribute,\n-    false },\n+    false, NULL },\n   { \"naked\",        0, 0, true,  false, false, arm_handle_fndecl_attribute,\n-    false },\n+    false, NULL },\n #ifdef ARM_PE\n   /* ARM/PE has three new attributes:\n      interfacearm - ?\n@@ -351,22 +351,24 @@ static const struct attribute_spec arm_attribute_table[] =\n      them with spaces.  We do NOT support this.  Instead, use __declspec\n      multiple times.\n   */\n-  { \"dllimport\",    0, 0, true,  false, false, NULL, false },\n-  { \"dllexport\",    0, 0, true,  false, false, NULL, false },\n+  { \"dllimport\",    0, 0, true,  false, false, NULL, false, NULL },\n+  { \"dllexport\",    0, 0, true,  false, false, NULL, false, NULL },\n   { \"interfacearm\", 0, 0, true,  false, false, arm_handle_fndecl_attribute,\n-    false },\n+    false, NULL },\n #elif TARGET_DLLIMPORT_DECL_ATTRIBUTES\n-  { \"dllimport\",    0, 0, false, false, false, handle_dll_attribute, false },\n-  { \"dllexport\",    0, 0, false, false, false, handle_dll_attribute, false },\n+  { \"dllimport\",    0, 0, false, false, false, handle_dll_attribute, false,\n+    NULL },\n+  { \"dllexport\",    0, 0, false, false, false, handle_dll_attribute, false,\n+    NULL },\n   { \"notshared\",    0, 0, false, true, false, arm_handle_notshared_attribute,\n-    false },\n+    false, NULL },\n #endif\n   /* ARMv8-M Security Extensions support.  */\n   { \"cmse_nonsecure_entry\", 0, 0, true, false, false,\n-    arm_handle_cmse_nonsecure_entry, false },\n+    arm_handle_cmse_nonsecure_entry, false, NULL },\n   { \"cmse_nonsecure_call\", 0, 0, true, false, false,\n-    arm_handle_cmse_nonsecure_call, true },\n-  { NULL,           0, 0, false, false, false, NULL, false }\n+    arm_handle_cmse_nonsecure_call, true, NULL },\n+  { NULL, 0, 0, false, false, false, NULL, false, NULL }\n };\n \f\n /* Initialize the GCC target structure.  */"}, {"sha": "7b654a620867b450159f61cec4325d08b05aadd1", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -9877,28 +9877,28 @@ avr_attribute_table[] =\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n        affects_type_identity } */\n   { \"progmem\",   0, 0, false, false, false,  avr_handle_progmem_attribute,\n-    false },\n+    false, NULL },\n   { \"signal\",    0, 0, true,  false, false,  avr_handle_fndecl_attribute,\n-    false },\n+    false, NULL },\n   { \"interrupt\", 0, 0, true,  false, false,  avr_handle_fndecl_attribute,\n-    false },\n+    false, NULL },\n   { \"no_gccisr\", 0, 0, true,  false, false,  avr_handle_fndecl_attribute,\n-    false },\n+    false, NULL },\n   { \"naked\",     0, 0, false, true,  true,   avr_handle_fntype_attribute,\n-    false },\n+    false, NULL },\n   { \"OS_task\",   0, 0, false, true,  true,   avr_handle_fntype_attribute,\n-    false },\n+    false, NULL },\n   { \"OS_main\",   0, 0, false, true,  true,   avr_handle_fntype_attribute,\n-    false },\n+    false, NULL },\n   { \"io\",        0, 1, true, false, false,  avr_handle_addr_attribute,\n-    false },\n+    false, NULL },\n   { \"io_low\",    0, 1, true, false, false,  avr_handle_addr_attribute,\n-    false },\n+    false, NULL },\n   { \"address\",   1, 1, true, false, false,  avr_handle_addr_attribute,\n-    false },\n+    false, NULL },\n   { \"absdata\",   0, 0, true, false, false,  avr_handle_absdata_attribute,\n-    false },\n-  { NULL,        0, 0, false, false, false, NULL, false }\n+    false, NULL },\n+  { NULL,        0, 0, false, false, false, NULL, false, NULL }\n };\n \n "}, {"sha": "a5947435f3e99e1200060b8185d6b7ce4bdfaac9", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -4906,29 +4906,30 @@ bfin_handle_l2_attribute (tree *node, tree ARG_UNUSED (name),\n static const struct attribute_spec bfin_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n-       affects_type_identity } */\n+       affects_type_identity, exclusions } */\n   { \"interrupt_handler\", 0, 0, false, true,  true, handle_int_attribute,\n-    false },\n+    false, NULL },\n   { \"exception_handler\", 0, 0, false, true,  true, handle_int_attribute,\n-    false },\n-  { \"nmi_handler\", 0, 0, false, true,  true, handle_int_attribute, false },\n-  { \"nesting\", 0, 0, false, true,  true, NULL, false },\n-  { \"kspisusp\", 0, 0, false, true,  true, NULL, false },\n-  { \"saveall\", 0, 0, false, true,  true, NULL, false },\n+    false, NULL },\n+  { \"nmi_handler\", 0, 0, false, true,  true, handle_int_attribute, false,\n+    NULL },\n+  { \"nesting\", 0, 0, false, true,  true, NULL, false, NULL },\n+  { \"kspisusp\", 0, 0, false, true,  true, NULL, false, NULL },\n+  { \"saveall\", 0, 0, false, true,  true, NULL, false, NULL },\n   { \"longcall\",  0, 0, false, true,  true,  bfin_handle_longcall_attribute,\n-    false },\n+    false, NULL },\n   { \"shortcall\", 0, 0, false, true,  true,  bfin_handle_longcall_attribute,\n-    false },\n+    false, NULL },\n   { \"l1_text\", 0, 0, true, false, false,  bfin_handle_l1_text_attribute,\n-    false },\n+    false, NULL },\n   { \"l1_data\", 0, 0, true, false, false,  bfin_handle_l1_data_attribute,\n-    false },\n+    false, NULL },\n   { \"l1_data_A\", 0, 0, true, false, false, bfin_handle_l1_data_attribute,\n-    false },\n+    false, NULL },\n   { \"l1_data_B\", 0, 0, true, false, false,  bfin_handle_l1_data_attribute,\n-    false },\n-  { \"l2\", 0, 0, true, false, false,  bfin_handle_l2_attribute, false },\n-  { NULL, 0, 0, false, false, false, NULL, false }\n+    false, NULL },\n+  { \"l2\", 0, 0, true, false, false,  bfin_handle_l2_attribute, false, NULL },\n+  { NULL, 0, 0, false, false, false, NULL, false, NULL }\n };\n \f\n /* Implementation of TARGET_ASM_INTEGER.  When using FD-PIC, we need to"}, {"sha": "bd4e028f328ecdff2e57aca05cbcd5717e116e4d", "filename": "gcc/config/cr16/cr16.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fcr16%2Fcr16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fcr16%2Fcr16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -207,9 +207,9 @@ static void cr16_print_operand_address (FILE *, machine_mode, rtx);\n static const struct attribute_spec cr16_attribute_table[] = {\n   /* ISRs have special prologue and epilogue requirements.  */\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n-       affects_type_identity }.  */\n-  {\"interrupt\", 0, 0, false, true, true, NULL, false},\n-  {NULL, 0, 0, false, false, false, NULL, false}\n+       affects_type_identity, exclusions }.  */\n+  {\"interrupt\", 0, 0, false, true, true, NULL, false, NULL},\n+  {NULL, 0, 0, false, false, false, NULL, false, NULL}\n };\n \n /* TARGET_ASM_UNALIGNED_xx_OP generates .?byte directive"}, {"sha": "dece119cdb80c50abd8305d9e60fc308b503e10a", "filename": "gcc/config/epiphany/epiphany.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -460,13 +460,14 @@ epiphany_init_reg_tables (void)\n \n static const struct attribute_spec epiphany_attribute_table[] =\n {\n-  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n-  { \"interrupt\",  0, 9, true,  false, false, epiphany_handle_interrupt_attribute, true },\n-  { \"forwarder_section\", 1, 1, true, false, false, epiphany_handle_forwarder_attribute, false },\n-  { \"long_call\",  0, 0, false, true, true, NULL, false },\n-  { \"short_call\", 0, 0, false, true, true, NULL, false },\n-  { \"disinterrupt\", 0, 0, false, true, true, NULL, true },\n-  { NULL,         0, 0, false, false, false, NULL, false }\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n+       affects_type_identity, exclusions } */\n+  { \"interrupt\",  0, 9, true,  false, false, epiphany_handle_interrupt_attribute, true, NULL },\n+  { \"forwarder_section\", 1, 1, true, false, false, epiphany_handle_forwarder_attribute, false, NULL },\n+  { \"long_call\",  0, 0, false, true, true, NULL, false, NULL },\n+  { \"short_call\", 0, 0, false, true, true, NULL, false, NULL },\n+  { \"disinterrupt\", 0, 0, false, true, true, NULL, true, NULL },\n+  { NULL,         0, 0, false, false, false, NULL, false, NULL }\n };\n \n /* Handle an \"interrupt\" attribute; arguments as in"}, {"sha": "d4e8c461c800c678ca1e0ae0b3e3b125a7868b86", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -5425,22 +5425,22 @@ h8300_insert_attributes (tree node, tree *attributes)\n static const struct attribute_spec h8300_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n-       affects_type_identity } */\n+       affects_type_identity, exclusions } */\n   { \"interrupt_handler\", 0, 0, true,  false, false,\n-    h8300_handle_fndecl_attribute, false },\n+    h8300_handle_fndecl_attribute, false, NULL },\n   { \"saveall\",           0, 0, true,  false, false,\n-    h8300_handle_fndecl_attribute, false },\n+    h8300_handle_fndecl_attribute, false, NULL },\n   { \"OS_Task\",           0, 0, true,  false, false,\n-    h8300_handle_fndecl_attribute, false },\n+    h8300_handle_fndecl_attribute, false, NULL },\n   { \"monitor\",           0, 0, true,  false, false,\n-    h8300_handle_fndecl_attribute, false },\n+    h8300_handle_fndecl_attribute, false, NULL },\n   { \"function_vector\",   0, 0, true,  false, false,\n-    h8300_handle_fndecl_attribute, false },\n+    h8300_handle_fndecl_attribute, false, NULL },\n   { \"eightbit_data\",     0, 0, true,  false, false,\n-    h8300_handle_eightbit_data_attribute, false },\n+    h8300_handle_eightbit_data_attribute, false, NULL },\n   { \"tiny_data\",         0, 0, true,  false, false,\n-    h8300_handle_tiny_data_attribute, false },\n-  { NULL,                0, 0, false, false, false, NULL, false }\n+    h8300_handle_tiny_data_attribute, false, NULL },\n+  { NULL,                0, 0, false, false, false, NULL, false, NULL }\n };\n \n "}, {"sha": "5d77f28dfa3d96cef8f32304f65d9e0d0c564109", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -44693,69 +44693,71 @@ ix86_expand_round_sse4 (rtx op0, rtx op1)\n static const struct attribute_spec ix86_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n-       affects_type_identity } */\n+       affects_type_identity, exclusions } */\n   /* Stdcall attribute says callee is responsible for popping arguments\n      if they are not variable.  */\n   { \"stdcall\",   0, 0, false, true,  true,  ix86_handle_cconv_attribute,\n-    true },\n+    true, NULL },\n   /* Fastcall attribute says callee is responsible for popping arguments\n      if they are not variable.  */\n   { \"fastcall\",  0, 0, false, true,  true,  ix86_handle_cconv_attribute,\n-    true },\n+    true, NULL },\n   /* Thiscall attribute says callee is responsible for popping arguments\n      if they are not variable.  */\n   { \"thiscall\",  0, 0, false, true,  true,  ix86_handle_cconv_attribute,\n-    true },\n+    true, NULL },\n   /* Cdecl attribute says the callee is a normal C declaration */\n   { \"cdecl\",     0, 0, false, true,  true,  ix86_handle_cconv_attribute,\n-    true },\n+    true, NULL },\n   /* Regparm attribute specifies how many integer arguments are to be\n      passed in registers.  */\n   { \"regparm\",   1, 1, false, true,  true,  ix86_handle_cconv_attribute,\n-    true },\n+    true, NULL },\n   /* Sseregparm attribute says we are using x86_64 calling conventions\n      for FP arguments.  */\n   { \"sseregparm\", 0, 0, false, true, true, ix86_handle_cconv_attribute,\n-    true },\n+    true, NULL },\n   /* The transactional memory builtins are implicitly regparm or fastcall\n      depending on the ABI.  Override the generic do-nothing attribute that\n      these builtins were declared with.  */\n   { \"*tm regparm\", 0, 0, false, true, true, ix86_handle_tm_regparm_attribute,\n-    true },\n+    true, NULL },\n   /* force_align_arg_pointer says this function realigns the stack at entry.  */\n   { (const char *)&ix86_force_align_arg_pointer_string, 0, 0,\n-    false, true,  true, ix86_handle_force_align_arg_pointer_attribute, false },\n+    false, true,  true, ix86_handle_force_align_arg_pointer_attribute, false,\n+    NULL },\n #if TARGET_DLLIMPORT_DECL_ATTRIBUTES\n-  { \"dllimport\", 0, 0, false, false, false, handle_dll_attribute, false },\n-  { \"dllexport\", 0, 0, false, false, false, handle_dll_attribute, false },\n+  { \"dllimport\", 0, 0, false, false, false, handle_dll_attribute, false, NULL },\n+  { \"dllexport\", 0, 0, false, false, false, handle_dll_attribute, false, NULL },\n   { \"shared\",    0, 0, true,  false, false, ix86_handle_shared_attribute,\n-    false },\n+    false, NULL },\n #endif\n   { \"ms_struct\", 0, 0, false, false,  false, ix86_handle_struct_attribute,\n-    false },\n+    false, NULL },\n   { \"gcc_struct\", 0, 0, false, false,  false, ix86_handle_struct_attribute,\n-    false },\n+    false, NULL },\n #ifdef SUBTARGET_ATTRIBUTE_TABLE\n   SUBTARGET_ATTRIBUTE_TABLE,\n #endif\n   /* ms_abi and sysv_abi calling convention function attributes.  */\n-  { \"ms_abi\", 0, 0, false, true, true, ix86_handle_abi_attribute, true },\n-  { \"sysv_abi\", 0, 0, false, true, true, ix86_handle_abi_attribute, true },\n-  { \"ms_abi va_list\", 0, 0, false, false, false, NULL, false },\n-  { \"sysv_abi va_list\", 0, 0, false, false, false, NULL, false },\n+  { \"ms_abi\", 0, 0, false, true, true, ix86_handle_abi_attribute, true, NULL },\n+  { \"sysv_abi\", 0, 0, false, true, true, ix86_handle_abi_attribute, true,\n+    NULL },\n+  { \"ms_abi va_list\", 0, 0, false, false, false, NULL, false, NULL },\n+  { \"sysv_abi va_list\", 0, 0, false, false, false, NULL, false, NULL },\n   { \"ms_hook_prologue\", 0, 0, true, false, false, ix86_handle_fndecl_attribute,\n-    false },\n+    false, NULL },\n   { \"callee_pop_aggregate_return\", 1, 1, false, true, true,\n-    ix86_handle_callee_pop_aggregate_return, true },\n+    ix86_handle_callee_pop_aggregate_return, true, NULL },\n   { \"interrupt\", 0, 0, false, true, true,\n-    ix86_handle_interrupt_attribute, false },\n+    ix86_handle_interrupt_attribute, false, NULL },\n   { \"no_caller_saved_registers\", 0, 0, false, true, true,\n-    ix86_handle_no_caller_saved_registers_attribute, false },\n+    ix86_handle_no_caller_saved_registers_attribute, false, NULL },\n   { \"naked\", 0, 0, true, false, false,\n-    ix86_handle_fndecl_attribute, false },\n+    ix86_handle_fndecl_attribute, false, NULL },\n \n   /* End element.  */\n-  { NULL,        0, 0, false, false, false, NULL, false }\n+  { NULL, 0, 0, false, false, false, NULL, false, NULL }\n };\n \n /* Implement targetm.vectorize.builtin_vectorization_cost.  */"}, {"sha": "ad4bb17d1adeb70a86f4eb410c4a8754649d0121", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -360,17 +360,17 @@ static bool ia64_expand_vec_perm_const_1 (struct expand_vec_perm_d *d);\n static const struct attribute_spec ia64_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n-       affects_type_identity } */\n-  { \"syscall_linkage\", 0, 0, false, true,  true,  NULL, false },\n+       affects_type_identity, exclusions } */\n+  { \"syscall_linkage\", 0, 0, false, true,  true,  NULL, false, NULL },\n   { \"model\",\t       1, 1, true, false, false, ia64_handle_model_attribute,\n-    false },\n+    false, NULL },\n #if TARGET_ABI_OPEN_VMS\n   { \"common_object\",   1, 1, true, false, false,\n-    ia64_vms_common_object_attribute, false },\n+    ia64_vms_common_object_attribute, false, NULL },\n #endif\n   { \"version_id\",      1, 1, true, false, false,\n-    ia64_handle_version_id_attribute, false },\n-  { NULL,\t       0, 0, false, false, false, NULL, false }\n+    ia64_handle_version_id_attribute, false, NULL },\n+  { NULL,\t       0, 0, false, false, false, NULL, false, NULL }\n };\n \n /* Initialize the GCC target structure.  */"}, {"sha": "281b54ca31c07e6f8109f387567def324e984aa2", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -3000,12 +3000,14 @@ current_function_special_page_vector (rtx x)\n #undef TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE m32c_attribute_table\n static const struct attribute_spec m32c_attribute_table[] = {\n-  {\"interrupt\", 0, 0, false, false, false, interrupt_handler, false},\n-  {\"bank_switch\", 0, 0, false, false, false, interrupt_handler, false},\n-  {\"fast_interrupt\", 0, 0, false, false, false, interrupt_handler, false},\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n+       affects_type_identity, exclusions } */\n+  {\"interrupt\", 0, 0, false, false, false, interrupt_handler, false, NULL},\n+  {\"bank_switch\", 0, 0, false, false, false, interrupt_handler, false, NULL},\n+  {\"fast_interrupt\", 0, 0, false, false, false, interrupt_handler, false, NULL},\n   {\"function_vector\", 1, 1, true,  false, false, function_vector_handler,\n-   false},\n-  {0, 0, 0, 0, 0, 0, 0, false}\n+   false, NULL},\n+  {0, 0, 0, 0, 0, 0, 0, false, NULL}\n };\n \n #undef TARGET_COMP_TYPE_ATTRIBUTES"}, {"sha": "bcca103aa2a9677355d087d9bbe6e98bded062e7", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -111,11 +111,11 @@ static HOST_WIDE_INT m32r_starting_frame_offset (void);\n static const struct attribute_spec m32r_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n-       affects_type_identity } */\n-  { \"interrupt\", 0, 0, true,  false, false, NULL, false },\n+       affects_type_identity, exclusions } */\n+  { \"interrupt\", 0, 0, true,  false, false, NULL, false, NULL },\n   { \"model\",     1, 1, true,  false, false, m32r_handle_model_attribute,\n-    false },\n-  { NULL,        0, 0, false, false, false, NULL, false }\n+    false, NULL },\n+  { NULL,        0, 0, false, false, false, NULL, false, NULL }\n };\n \f\n /* Initialize the GCC target structure.  */"}, {"sha": "c5b034a615d687e4cb37f540e5ed2e16ee92f0f6", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -348,14 +348,14 @@ static bool m68k_modes_tieable_p (machine_mode, machine_mode);\n static const struct attribute_spec m68k_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n-       affects_type_identity } */\n+       affects_type_identity, exclusions } */\n   { \"interrupt\", 0, 0, true,  false, false, m68k_handle_fndecl_attribute,\n     false },\n   { \"interrupt_handler\", 0, 0, true,  false, false,\n-    m68k_handle_fndecl_attribute, false },\n+    m68k_handle_fndecl_attribute, false, NULL },\n   { \"interrupt_thread\", 0, 0, true,  false, false,\n-    m68k_handle_fndecl_attribute, false },\n-  { NULL,                0, 0, false, false, false, NULL, false }\n+    m68k_handle_fndecl_attribute, false, NULL },\n+  { NULL, 0, 0, false, false, false, NULL, false, NULL }\n };\n \n struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "af36ebeb36fa0a486d55f6ec11a0b44483f63f55", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -152,12 +152,12 @@ static bool\t  mcore_modes_tieable_p\t\t(machine_mode, machine_mode);\n static const struct attribute_spec mcore_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n-       affects_type_identity } */\n-  { \"dllexport\", 0, 0, true,  false, false, NULL, false },\n-  { \"dllimport\", 0, 0, true,  false, false, NULL, false },\n+       affects_type_identity, exclusions } */\n+  { \"dllexport\", 0, 0, true,  false, false, NULL, false, NULL },\n+  { \"dllimport\", 0, 0, true,  false, false, NULL, false, NULL },\n   { \"naked\",     0, 0, true,  false, false, mcore_handle_naked_attribute,\n-    false },\n-  { NULL,        0, 0, false, false, false, NULL, false }\n+    false, NULL },\n+  { NULL,        0, 0, false, false, false, NULL, false, NULL }\n };\n \f\n /* Initialize the GCC target structure.  */"}, {"sha": "acdff6c655d05fcdc93079f1d8758812c46981f8", "filename": "gcc/config/microblaze/microblaze.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -216,17 +216,17 @@ int save_volatiles;\n \n const struct attribute_spec microblaze_attribute_table[] = {\n   /* name         min_len, max_len, decl_req, type_req, fn_type, req_handler,\n-     affects_type_identity */\n+     affects_type_identity, exclusions */\n   {\"interrupt_handler\", 0,       0,     true,    false,   false,        NULL,\n-    false },\n+    false, NULL },\n   {\"break_handler\",     0,       0,     true,    false,   false,        NULL,\n-    false },\n+    false, NULL },\n   {\"fast_interrupt\",    0,       0,     true,    false,   false,        NULL,\n-    false },\n+    false, NULL },\n   {\"save_volatiles\"   , 0,       0,     true,    false,   false,        NULL,\n-    false },\n+    false, NULL },\n   { NULL,        \t0,       0,    false,    false,   false,        NULL,\n-    false }\n+    false, NULL }\n };\n \n static int microblaze_interrupt_function_p (tree);"}, {"sha": "4e70a9b2572c4a72cbe231b370cda6df0e108ec5", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -597,27 +597,27 @@ static tree mips_handle_use_shadow_register_set_attr (tree *, tree, tree, int,\n static const struct attribute_spec mips_attribute_table[] = {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n        om_diagnostic } */\n-  { \"long_call\",   0, 0, false, true,  true,  NULL, false },\n-  { \"short_call\",  0, 0, false, true,  true,  NULL, false },\n-  { \"far\",     \t   0, 0, false, true,  true,  NULL, false },\n-  { \"near\",        0, 0, false, true,  true,  NULL, false },\n+  { \"long_call\",   0, 0, false, true,  true,  NULL, false, NULL },\n+  { \"short_call\",  0, 0, false, true,  true,  NULL, false, NULL },\n+  { \"far\",     \t   0, 0, false, true,  true,  NULL, false, NULL },\n+  { \"near\",        0, 0, false, true,  true,  NULL, false, NULL },\n   /* We would really like to treat \"mips16\" and \"nomips16\" as type\n      attributes, but GCC doesn't provide the hooks we need to support\n      the right conversion rules.  As declaration attributes, they affect\n      code generation but don't carry other semantics.  */\n-  { \"mips16\", \t   0, 0, true,  false, false, NULL, false },\n-  { \"nomips16\",    0, 0, true,  false, false, NULL, false },\n-  { \"micromips\",   0, 0, true,  false, false, NULL, false },\n-  { \"nomicromips\", 0, 0, true,  false, false, NULL, false },\n-  { \"nocompression\", 0, 0, true,  false, false, NULL, false },\n+  { \"mips16\", \t   0, 0, true,  false, false, NULL, false, NULL },\n+  { \"nomips16\",    0, 0, true,  false, false, NULL, false, NULL },\n+  { \"micromips\",   0, 0, true,  false, false, NULL, false, NULL },\n+  { \"nomicromips\", 0, 0, true,  false, false, NULL, false, NULL },\n+  { \"nocompression\", 0, 0, true,  false, false, NULL, false, NULL },\n   /* Allow functions to be specified as interrupt handlers */\n   { \"interrupt\",   0, 1, false, true,  true, mips_handle_interrupt_attr,\n-    false },\n+    false, NULL },\n   { \"use_shadow_register_set\",\t0, 1, false, true,  true,\n-    mips_handle_use_shadow_register_set_attr, false },\n-  { \"keep_interrupts_masked\",\t0, 0, false, true,  true, NULL, false },\n-  { \"use_debug_exception_return\", 0, 0, false, true,  true, NULL, false },\n-  { NULL,\t   0, 0, false, false, false, NULL, false }\n+    mips_handle_use_shadow_register_set_attr, false, NULL },\n+  { \"keep_interrupts_masked\",\t0, 0, false, true,  true, NULL, false, NULL },\n+  { \"use_debug_exception_return\", 0, 0, false, true,  true, NULL, false, NULL },\n+  { NULL,\t   0, 0, false, false, false, NULL, false, NULL }\n };\n \f\n /* A table describing all the processors GCC knows about; see"}, {"sha": "3d33f7caba84b9eced2f77a5d918ad916b576d1f", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -2052,20 +2052,25 @@ const struct attribute_spec msp430_attribute_table[] =\n   /* Name        min_num_args     type_req,             affects_type_identity\n                       max_num_args,     fn_type_req\n                           decl_req               handler.  */\n-  { ATTR_INTR,        0, 1, true,  false, false, msp430_attr, false },\n-  { ATTR_NAKED,       0, 0, true,  false, false, msp430_attr, false },\n-  { ATTR_REENT,       0, 0, true,  false, false, msp430_attr, false },\n-  { ATTR_CRIT,        0, 0, true,  false, false, msp430_attr, false },\n-  { ATTR_WAKEUP,      0, 0, true,  false, false, msp430_attr, false },\n-\n-  { ATTR_LOWER,       0, 0, true,  false, false, msp430_section_attr, false },\n-  { ATTR_UPPER,       0, 0, true,  false, false, msp430_section_attr, false },\n-  { ATTR_EITHER,      0, 0, true,  false, false, msp430_section_attr, false },\n-\n-  { ATTR_NOINIT,      0, 0, true,  false, false, msp430_data_attr, false },\n-  { ATTR_PERSIST,     0, 0, true,  false, false, msp430_data_attr, false },\n-\n-  { NULL,             0, 0, false, false, false, NULL, false }\n+  { ATTR_INTR,        0, 1, true,  false, false, msp430_attr, false, NULL },\n+  { ATTR_NAKED,       0, 0, true,  false, false, msp430_attr, false, NULL },\n+  { ATTR_REENT,       0, 0, true,  false, false, msp430_attr, false, NULL },\n+  { ATTR_CRIT,        0, 0, true,  false, false, msp430_attr, false, NULL },\n+  { ATTR_WAKEUP,      0, 0, true,  false, false, msp430_attr, false, NULL },\n+\n+  { ATTR_LOWER,       0, 0, true,  false, false, msp430_section_attr, false,\n+    NULL },\n+  { ATTR_UPPER,       0, 0, true,  false, false, msp430_section_attr, false,\n+    NULL },\n+  { ATTR_EITHER,      0, 0, true,  false, false, msp430_section_attr, false,\n+    NULL },\n+\n+  { ATTR_NOINIT,      0, 0, true,  false, false, msp430_data_attr, false,\n+    NULL },\n+  { ATTR_PERSIST,     0, 0, true,  false, false, msp430_data_attr, false,\n+    NULL },\n+\n+  { NULL,             0, 0, false, false, false, NULL, false, NULL }\n };\n \n #undef  TARGET_ASM_FUNCTION_PROLOGUE"}, {"sha": "8c3702c148befa818ba077835fbf02ef3c55e991", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -86,30 +86,30 @@ static const struct attribute_spec nds32_attribute_table[] =\n \t       function_type_required, handler, affects_type_identity } */\n \n   /* The interrupt vid: [0-63]+ (actual vector number starts from 9 to 72).  */\n-  { \"interrupt\",    1, 64, false, false, false, NULL, false },\n+  { \"interrupt\",    1, 64, false, false, false, NULL, false, NULL },\n   /* The exception vid: [1-8]+  (actual vector number starts from 1 to 8).  */\n-  { \"exception\",    1,  8, false, false, false, NULL, false },\n+  { \"exception\",    1,  8, false, false, false, NULL, false, NULL },\n   /* Argument is user's interrupt numbers.  The vector number is always 0.  */\n-  { \"reset\",        1,  1, false, false, false, NULL, false },\n+  { \"reset\",        1,  1, false, false, false, NULL, false, NULL },\n \n   /* The attributes describing isr nested type.  */\n-  { \"nested\",       0,  0, false, false, false, NULL, false },\n-  { \"not_nested\",   0,  0, false, false, false, NULL, false },\n-  { \"nested_ready\", 0,  0, false, false, false, NULL, false },\n+  { \"nested\",       0,  0, false, false, false, NULL, false, NULL },\n+  { \"not_nested\",   0,  0, false, false, false, NULL, false, NULL },\n+  { \"nested_ready\", 0,  0, false, false, false, NULL, false, NULL },\n \n   /* The attributes describing isr register save scheme.  */\n-  { \"save_all\",     0,  0, false, false, false, NULL, false },\n-  { \"partial_save\", 0,  0, false, false, false, NULL, false },\n+  { \"save_all\",     0,  0, false, false, false, NULL, false, NULL },\n+  { \"partial_save\", 0,  0, false, false, false, NULL, false, NULL },\n \n   /* The attributes used by reset attribute.  */\n-  { \"nmi\",          1,  1, false, false, false, NULL, false },\n-  { \"warm\",         1,  1, false, false, false, NULL, false },\n+  { \"nmi\",          1,  1, false, false, false, NULL, false, NULL },\n+  { \"warm\",         1,  1, false, false, false, NULL, false, NULL },\n \n   /* The attribute telling no prologue/epilogue.  */\n-  { \"naked\",        0,  0, false, false, false, NULL, false },\n+  { \"naked\",        0,  0, false, false, false, NULL, false, NULL },\n \n   /* The last attribute spec is set to be NULL.  */\n-  { NULL,           0,  0, false, false, false, NULL, false }\n+  { NULL,           0,  0, false, false, false, NULL, false, NULL }\n };\n \n "}, {"sha": "16ff370bb32eee2507afa020082d17a712dc2eee", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -4458,10 +4458,12 @@ nvptx_handle_shared_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n static const struct attribute_spec nvptx_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n-       affects_type_identity } */\n-  { \"kernel\", 0, 0, true, false,  false, nvptx_handle_kernel_attribute, false },\n-  { \"shared\", 0, 0, true, false,  false, nvptx_handle_shared_attribute, false },\n-  { NULL, 0, 0, false, false, false, NULL, false }\n+       affects_type_identity, exclusions } */\n+  { \"kernel\", 0, 0, true, false,  false, nvptx_handle_kernel_attribute, false,\n+    NULL },\n+  { \"shared\", 0, 0, true, false,  false, nvptx_handle_shared_attribute, false,\n+    NULL },\n+  { NULL, 0, 0, false, false, false, NULL, false, NULL }\n };\n \f\n /* Limit vector alignments to BIGGEST_ALIGNMENT.  */"}, {"sha": "44165802be4074710e9156b496c2c2dd12969cec", "filename": "gcc/config/powerpcspe/powerpcspe.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -1534,21 +1534,21 @@ static const char alt_reg_names[][8] =\n static const struct attribute_spec rs6000_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n-       affects_type_identity } */\n+       affects_type_identity, exclusions } */\n   { \"altivec\",   1, 1, false, true,  false, rs6000_handle_altivec_attribute,\n-    false },\n+    false, NULL },\n   { \"longcall\",  0, 0, false, true,  true,  rs6000_handle_longcall_attribute,\n-    false },\n+    false, NULL },\n   { \"shortcall\", 0, 0, false, true,  true,  rs6000_handle_longcall_attribute,\n-    false },\n+    false, NULL },\n   { \"ms_struct\", 0, 0, false, false, false, rs6000_handle_struct_attribute,\n-    false },\n+    false, NULL },\n   { \"gcc_struct\", 0, 0, false, false, false, rs6000_handle_struct_attribute,\n-    false },\n+    false, NULL },\n #ifdef SUBTARGET_ATTRIBUTE_TABLE\n   SUBTARGET_ATTRIBUTE_TABLE,\n #endif\n-  { NULL,        0, 0, false, false, false, NULL, false }\n+  { NULL,        0, 0, false, false, false, NULL, false, NULL }\n };\n \f\n #ifndef TARGET_PROFILE_KERNEL"}, {"sha": "58c8fe8ed1ca32a4fc0947246a640ee5d6b62be2", "filename": "gcc/config/rl78/rl78.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Frl78%2Frl78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Frl78%2Frl78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -860,14 +860,14 @@ const struct attribute_spec rl78_attribute_table[] =\n   /* Name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n      affects_type_identity.  */\n   { \"interrupt\",      0, 0, true, false, false, rl78_handle_func_attribute,\n-    false },\n+    false, NULL },\n   { \"brk_interrupt\",  0, 0, true, false, false, rl78_handle_func_attribute,\n-    false },\n+    false, NULL },\n   { \"naked\",          0, 0, true, false, false, rl78_handle_naked_attribute,\n-    false },\n+    false, NULL },\n   { \"saddr\",          0, 0, true, false, false, rl78_handle_saddr_attribute,\n-    false },\n-  { NULL,             0, 0, false, false, false, NULL, false }\n+    false, NULL },\n+  { NULL,             0, 0, false, false, false, NULL, false, NULL }\n };\n \n "}, {"sha": "155ea6e9d991048899173049a126904ea98f4c8f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -1518,21 +1518,21 @@ static const char alt_reg_names[][8] =\n static const struct attribute_spec rs6000_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n-       affects_type_identity } */\n+       affects_type_identity, exclusions } */\n   { \"altivec\",   1, 1, false, true,  false, rs6000_handle_altivec_attribute,\n-    false },\n+    false, NULL },\n   { \"longcall\",  0, 0, false, true,  true,  rs6000_handle_longcall_attribute,\n-    false },\n+    false, NULL },\n   { \"shortcall\", 0, 0, false, true,  true,  rs6000_handle_longcall_attribute,\n-    false },\n+    false, NULL },\n   { \"ms_struct\", 0, 0, false, false, false, rs6000_handle_struct_attribute,\n-    false },\n+    false, NULL },\n   { \"gcc_struct\", 0, 0, false, false, false, rs6000_handle_struct_attribute,\n-    false },\n+    false, NULL },\n #ifdef SUBTARGET_ATTRIBUTE_TABLE\n   SUBTARGET_ATTRIBUTE_TABLE,\n #endif\n-  { NULL,        0, 0, false, false, false, NULL, false }\n+  { NULL,        0, 0, false, false, false, NULL, false, NULL }\n };\n \f\n #ifndef TARGET_PROFILE_KERNEL"}, {"sha": "84032b70d388dc7b040516b63ea5a0bfce0c56c6", "filename": "gcc/config/rx/rx.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Frx%2Frx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Frx%2Frx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -2732,16 +2732,16 @@ rx_handle_vector_attribute (tree * node,\n const struct attribute_spec rx_attribute_table[] =\n {\n   /* Name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n-     affects_type_identity.  */\n+     affects_type_identity, exclusions.  */\n   { \"fast_interrupt\", 0, 0, true, false, false, rx_handle_func_attribute,\n-    false },\n+    false, NULL },\n   { \"interrupt\",      0, -1, true, false, false, rx_handle_func_attribute,\n-    false },\n+    false, NULL },\n   { \"naked\",          0, 0, true, false, false, rx_handle_func_attribute,\n-    false },\n+    false, NULL },\n   { \"vector\",         1, -1, true, false, false, rx_handle_vector_attribute,\n-    false },\n-  { NULL,             0, 0, false, false, false, NULL, false }\n+    false, NULL },\n+  { NULL,             0, 0, false, false, false, NULL, false, NULL }\n };\n \n /* Implement TARGET_OVERRIDE_OPTIONS_AFTER_CHANGE.  */"}, {"sha": "c87f44db29a289426884ee320fc0d2608e6adce7", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -1178,10 +1178,12 @@ s390_handle_vectorbool_attribute (tree *node, tree name ATTRIBUTE_UNUSED,\n }\n \n static const struct attribute_spec s390_attribute_table[] = {\n-  { \"hotpatch\", 2, 2, true, false, false, s390_handle_hotpatch_attribute, false },\n-  { \"s390_vector_bool\", 0, 0, false, true, false, s390_handle_vectorbool_attribute, true },\n+  { \"hotpatch\", 2, 2, true, false, false,\n+    s390_handle_hotpatch_attribute, false, NULL },\n+  { \"s390_vector_bool\", 0, 0, false, true, false,\n+    s390_handle_vectorbool_attribute, true, NULL },\n   /* End element.  */\n-  { NULL,        0, 0, false, false, false, NULL, false }\n+  { NULL,        0, 0, false, false, false, NULL, false, NULL }\n };\n \n /* Return the alignment for LABEL.  We default to the -falign-labels"}, {"sha": "0d7d7bc53ca21fdec925feddd67247b548e51d62", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -330,24 +330,24 @@ static bool sh_can_change_mode_class (machine_mode, machine_mode, reg_class_t);\n static const struct attribute_spec sh_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n-       affects_type_identity } */\n+       affects_type_identity, exclusions } */\n   { \"interrupt_handler\", 0, 0, true,  false, false,\n-    sh_handle_interrupt_handler_attribute, false },\n+    sh_handle_interrupt_handler_attribute, false, NULL },\n   { \"sp_switch\",         1, 1, true,  false, false,\n-     sh_handle_sp_switch_attribute, false },\n+     sh_handle_sp_switch_attribute, false, NULL },\n   { \"trap_exit\",         1, 1, true,  false, false,\n-    sh_handle_trap_exit_attribute, false },\n+    sh_handle_trap_exit_attribute, false, NULL },\n   { \"renesas\",           0, 0, false, true, false,\n-    sh_handle_renesas_attribute, false },\n+    sh_handle_renesas_attribute, false, NULL },\n   { \"trapa_handler\",     0, 0, true,  false, false,\n-    sh_handle_interrupt_handler_attribute, false },\n+    sh_handle_interrupt_handler_attribute, false, NULL },\n   { \"nosave_low_regs\",   0, 0, true,  false, false,\n-    sh_handle_interrupt_handler_attribute, false },\n+    sh_handle_interrupt_handler_attribute, false, NULL },\n   { \"resbank\",           0, 0, true,  false, false,\n-    sh_handle_resbank_handler_attribute, false },\n+    sh_handle_resbank_handler_attribute, false, NULL },\n   { \"function_vector\",   1, 1, true,  false, false,\n-    sh2a_handle_function_vector_handler_attribute, false },\n-  { NULL,                0, 0, false, false, false, NULL, false }\n+    sh2a_handle_function_vector_handler_attribute, false, NULL },\n+  { NULL,                0, 0, false, false, false, NULL, false, NULL }\n };\n \f\n /* Initialize the GCC target structure.  */"}, {"sha": "54e7a0e161a2e7bc38dd7a6e8bcd2ee79d8ae20e", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -691,9 +691,9 @@ static HOST_WIDE_INT sparc_constant_alignment (const_tree, HOST_WIDE_INT);\n static const struct attribute_spec sparc_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n-       do_diagnostic } */\n+       do_diagnostic, exclusions } */\n   SUBTARGET_ATTRIBUTE_TABLE,\n-  { NULL,        0, 0, false, false, false, NULL, false }\n+  { NULL,        0, 0, false, false, false, NULL, false, NULL }\n };\n #endif\n \f"}, {"sha": "dc9e13356baf6a591ae22a1890ce85c75b9b5a48", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -7215,12 +7215,12 @@ spu_constant_alignment (const_tree, HOST_WIDE_INT align)\n static const struct attribute_spec spu_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n-       affects_type_identity } */\n+       affects_type_identity, exclusions } */\n   { \"naked\",          0, 0, true,  false, false, spu_handle_fndecl_attribute,\n-    false },\n+    false, NULL },\n   { \"spu_vector\",     0, 0, false, true,  false, spu_handle_vector_attribute,\n-    false },\n-  { NULL,             0, 0, false, false, false, NULL, false }\n+    false, NULL },\n+  { NULL,             0, 0, false, false, false, NULL, false, NULL }\n };\n \n /*  TARGET overrides.  */"}, {"sha": "3a21260fda7c40e692c1480baa0497516248b7d2", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -2190,14 +2190,14 @@ static tree xstormy16_handle_below100_attribute\n static const struct attribute_spec xstormy16_attribute_table[] =\n {\n   /* name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n-     affects_type_identity.  */\n+     affects_type_identity, exclusions.  */\n   { \"interrupt\", 0, 0, false, true,  true,\n-    xstormy16_handle_interrupt_attribute , false },\n+    xstormy16_handle_interrupt_attribute , false, NULL },\n   { \"BELOW100\",  0, 0, false, false, false,\n-    xstormy16_handle_below100_attribute, false },\n+    xstormy16_handle_below100_attribute, false, NULL },\n   { \"below100\",  0, 0, false, false, false,\n-    xstormy16_handle_below100_attribute, false },\n-  { NULL,        0, 0, false, false, false, NULL, false }\n+    xstormy16_handle_below100_attribute, false, NULL },\n+  { NULL,        0, 0, false, false, false, NULL, false, NULL }\n };\n \n /* Handle an \"interrupt\" attribute;"}, {"sha": "3d0bbf55e2481ef8b1439bf65e24c57f8ecf246e", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -3188,18 +3188,18 @@ v850_adjust_insn_length (rtx_insn *insn, int length)\n static const struct attribute_spec v850_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n-       affects_type_identity } */\n+       affects_type_identity, exclusions } */\n   { \"interrupt_handler\", 0, 0, true,  false, false,\n-    v850_handle_interrupt_attribute, false },\n+    v850_handle_interrupt_attribute, false, NULL },\n   { \"interrupt\",         0, 0, true,  false, false,\n-    v850_handle_interrupt_attribute, false },\n+    v850_handle_interrupt_attribute, false, NULL },\n   { \"sda\",               0, 0, true,  false, false,\n-    v850_handle_data_area_attribute, false },\n+    v850_handle_data_area_attribute, false, NULL },\n   { \"tda\",               0, 0, true,  false, false,\n-    v850_handle_data_area_attribute, false },\n+    v850_handle_data_area_attribute, false, NULL },\n   { \"zda\",               0, 0, true,  false, false,\n-    v850_handle_data_area_attribute, false },\n-  { NULL,                0, 0, false, false, false, NULL, false }\n+    v850_handle_data_area_attribute, false, NULL },\n+  { NULL,                0, 0, false, false, false, NULL, false, NULL }\n };\n \f\n static void"}, {"sha": "a8b90019aa9b1e015c1bdc02656abf2f1bfc0f55", "filename": "gcc/config/visium/visium.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fvisium%2Fvisium.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fconfig%2Fvisium%2Fvisium.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -146,9 +146,10 @@ static inline bool current_function_has_lr_slot (void);\n static const struct attribute_spec visium_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n-       affects_type_identity } */\n-  {\"interrupt\", 0, 0, true, false, false, visium_handle_interrupt_attr, false},\n-  {NULL, 0, 0, false, false, false, NULL, false}\n+       affects_type_identity, exclusions } */\n+  {\"interrupt\", 0, 0, true, false, false, visium_handle_interrupt_attr, false,\n+   NULL},\n+  {NULL, 0, 0, false, false, false, NULL, false, NULL},\n };\n \n static struct machine_function *visium_init_machine_status (void);"}, {"sha": "e492f0a9867588d959cae9ce4789c32ceaec3d6c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -1,3 +1,14 @@\n+2017-12-07  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/81544\n+\t* cp-tree.h (decls_match): Add default argument.\n+\t* decl.c (decls_match): Avoid calling into the target back end\n+\tand triggering an error.\n+\t* decl2.c (cplus_decl_attributes): Look up existing declaration and\n+\tpass it to decl_attributes.\n+\t* tree.c (cxx_attribute_table): Initialize new member of struct\n+\tattribute_spec.\n+\n 2017-12-06  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/80259"}, {"sha": "708d172bf6176394c32e0368b236a64c059ab377", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -6116,7 +6116,7 @@ extern void note_break_stmt\t\t\t(void);\n extern bool note_iteration_stmt_body_start\t(void);\n extern void note_iteration_stmt_body_end\t(bool);\n extern tree make_lambda_name\t\t\t(void);\n-extern int decls_match\t\t\t\t(tree, tree);\n+extern int decls_match\t\t\t\t(tree, tree, bool = true);\n extern bool maybe_version_functions\t\t(tree, tree);\n extern tree duplicate_decls\t\t\t(tree, tree, bool);\n extern tree declare_local_label\t\t\t(tree);"}, {"sha": "99b22dc878c4a1525c48483f1fbf2f4bf5c89eef", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -992,7 +992,7 @@ push_local_name (tree decl)\n    `const int&'.  */\n \n int\n-decls_match (tree newdecl, tree olddecl)\n+decls_match (tree newdecl, tree olddecl, bool record_versions /* = true */)\n {\n   int types_match;\n \n@@ -1087,6 +1087,7 @@ decls_match (tree newdecl, tree olddecl)\n       if (types_match\n \t  && !DECL_EXTERN_C_P (newdecl)\n \t  && !DECL_EXTERN_C_P (olddecl)\n+\t  && record_versions\n \t  && maybe_version_functions (newdecl, olddecl))\n \treturn 0;\n     }"}, {"sha": "5d30369e80fec6fa4f14b7d984496c2875ea7ad5", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -1482,7 +1482,31 @@ cplus_decl_attributes (tree *decl, tree attributes, int flags)\n \t\t       attributes, flags);\n     }\n   else\n-    decl_attributes (decl, attributes, flags);\n+    {\n+      tree last_decl = (DECL_P (*decl) && DECL_NAME (*decl)\n+\t\t\t? lookup_name (DECL_NAME (*decl)) : NULL_TREE);\n+\n+      if (last_decl && TREE_CODE (last_decl) == OVERLOAD)\n+\tfor (ovl_iterator iter (last_decl, true); ; ++iter)\n+\t  {\n+\t    if (!iter)\n+\t      {\n+\t\tlast_decl = NULL_TREE;\n+\t\tbreak;\n+\t      }\n+\n+\t    if (TREE_CODE (*iter) == OVERLOAD)\n+\t      continue;\n+\n+\t    if (decls_match (*decl, *iter, /*record_decls=*/false))\n+\t      {\n+\t\tlast_decl = *iter;\n+\t\tbreak;\n+\t      }\n+\t  }\n+\n+      decl_attributes (decl, attributes, flags, last_decl);\n+    }\n \n   if (TREE_CODE (*decl) == TYPE_DECL)\n     SET_IDENTIFIER_TYPE_VALUE (DECL_NAME (*decl), TREE_TYPE (*decl));"}, {"sha": "0ae2eff4e1e42fabac05531d3ae43dcce794eb24", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -4330,24 +4330,24 @@ handle_nodiscard_attribute (tree *node, tree name, tree /*args*/,\n const struct attribute_spec cxx_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n-       affects_type_identity } */\n+       affects_type_identity, exclusions } */\n   { \"init_priority\",  1, 1, true,  false, false,\n-    handle_init_priority_attribute, false },\n+    handle_init_priority_attribute, false, NULL },\n   { \"abi_tag\", 1, -1, false, false, false,\n-    handle_abi_tag_attribute, true },\n-  { NULL,\t      0, 0, false, false, false, NULL, false }\n+    handle_abi_tag_attribute, true, NULL },\n+  { NULL, 0, 0, false, false, false, NULL, false, NULL }\n };\n \n /* Table of C++ standard attributes.  */\n const struct attribute_spec std_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n-       affects_type_identity } */\n+       affects_type_identity, exclusions } */\n   { \"maybe_unused\", 0, 0, false, false, false,\n-    handle_unused_attribute, false },\n+    handle_unused_attribute, false, NULL },\n   { \"nodiscard\", 0, 0, false, false, false,\n-    handle_nodiscard_attribute, false },\n-  { NULL,\t      0, 0, false, false, false, NULL, false }\n+    handle_nodiscard_attribute, false, NULL },\n+  { NULL, 0, 0, false, false, false, NULL, false, NULL }\n };\n \n /* Handle an \"init_priority\" attribute; arguments as in"}, {"sha": "ad4d9d313999ad0f87535e6c624970c545b4e6e0", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -2493,9 +2493,14 @@ are automatically detected and this attribute is ignored.\n @cindex @code{const} function attribute\n @cindex functions that have no side effects\n Many functions do not examine any values except their arguments, and\n-have no effects except the return value.  Basically this is just slightly\n-more strict class than the @code{pure} attribute below, since function is not\n-allowed to read global memory.\n+have no effects except to return a value.  Calls to such functions lend\n+themselves to optimization such as common subexpression elimination.\n+The @code{const} attribute imposes greater restrictions on a function's\n+definition than the similar @code{pure} attribute below because it prohibits\n+the function from reading global variables.  Consequently, the presence of\n+the attribute on a function declarations allows GCC to emit more efficient\n+code for some calls to the function.  Decorating the same function with\n+both the @code{const} and the @code{pure} attribute is diagnnosed.\n \n @cindex pointer arguments\n Note that a function that has pointer arguments and examines the data\n@@ -3190,7 +3195,7 @@ to prevent recursion.\n @cindex functions that have no side effects\n Many functions have no effects except the return value and their\n return value depends only on the parameters and/or global variables.\n-Such a function can be subject\n+Calls to such functions can be subject\n to common subexpression elimination and loop optimization just as an\n arithmetic operator would be.  These functions should be declared\n with the attribute @code{pure}.  For example,\n@@ -3208,6 +3213,11 @@ Interesting non-pure functions are functions with infinite loops or those\n depending on volatile memory or other system resource, that may change between\n two consecutive calls (such as @code{feof} in a multithreading environment).\n \n+The @code{pure} attribute imposes similar but looser restrictions on\n+a function's defintion than the @code{const} attribute: it allows the\n+function to read global variables.  Decorating the same function with\n+both the @code{pure} and the @code{const} attribute is diagnosed.\n+\n @item returns_nonnull\n @cindex @code{returns_nonnull} function attribute\n The @code{returns_nonnull} attribute specifies that the function"}, {"sha": "b48bac45e16960c57c9918d8604afd51c0a2514a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -1,3 +1,9 @@\n+2017-12-07  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/81544\n+\t* f95-lang.c (gfc_attribute_table): Initialize new member of struct\n+\tattribute_spec.\n+\n 2017-12-03  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/36313"}, {"sha": "0ecb2074dcc8482598a3770c03acfb60493157a9", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -92,12 +92,12 @@ static const struct attribute_spec gfc_attribute_table[] =\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n        affects_type_identity } */\n   { \"omp declare target\", 0, 0, true,  false, false,\n-    gfc_handle_omp_declare_target_attribute, false },\n+    gfc_handle_omp_declare_target_attribute, false, NULL },\n   { \"omp declare target link\", 0, 0, true,  false, false,\n-    gfc_handle_omp_declare_target_attribute, false },\n+    gfc_handle_omp_declare_target_attribute, false, NULL },\n   { \"oacc function\", 0, -1, true,  false, false,\n-    gfc_handle_omp_declare_target_attribute, false },\n-  { NULL,\t\t  0, 0, false, false, false, NULL, false }\n+    gfc_handle_omp_declare_target_attribute, false, NULL },\n+  { NULL,\t\t  0, 0, false, false, false, NULL, false, NULL }\n };\n \n #undef LANG_HOOKS_NAME"}, {"sha": "b8260a0690d9b9f151f48310945cb0f4e2450916", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -1,3 +1,9 @@\n+2017-12-07  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/81544\n+\t* lto-lang.c (lto_attribute_table): Initialize new member of struct\n+\tattribute_spec.\n+\n 2017-11-30  Jakub Jelinek  <jakub@redhat.com>\n \n \t* lto.c (create_subid_section_table): Use ; instead of ;;."}, {"sha": "89702a4e652a5ad7b4ee32fb51ca0dd5f383db49", "filename": "gcc/lto/lto-lang.c", "status": "modified", "additions": 61, "deletions": 21, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -57,46 +57,82 @@ static tree handle_format_attribute (tree *, tree, tree, int, bool *);\n static tree handle_fnspec_attribute (tree *, tree, tree, int, bool *);\n static tree handle_format_arg_attribute (tree *, tree, tree, int, bool *);\n \n+/* Helper to define attribute exclusions.  */\n+#define ATTR_EXCL(name, function, type, variable)\t\\\n+  { name, function, type, variable }\n+\n+/* Define attributes that are mutually exclusive with one another.  */\n+static const struct attribute_spec::exclusions attr_noreturn_exclusions[] =\n+{\n+  ATTR_EXCL (\"noreturn\", true, true, true),\n+  ATTR_EXCL (\"alloc_align\", true, true, true),\n+  ATTR_EXCL (\"alloc_size\", true, true, true),\n+  ATTR_EXCL (\"const\", true, true, true),\n+  ATTR_EXCL (\"malloc\", true, true, true),\n+  ATTR_EXCL (\"pure\", true, true, true),\n+  ATTR_EXCL (\"returns_twice\", true, true, true),\n+  ATTR_EXCL (\"warn_unused_result\", true, true, true),\n+  ATTR_EXCL (NULL, false, false, false),\n+};\n+\n+static const struct attribute_spec::exclusions attr_returns_twice_exclusions[] =\n+{\n+  ATTR_EXCL (\"noreturn\", true, true, true),\n+  ATTR_EXCL (NULL, false, false, false),\n+};\n+\n+static const struct attribute_spec::exclusions attr_const_pure_exclusions[] =\n+{\n+  ATTR_EXCL (\"const\", true, true, true),\n+  ATTR_EXCL (\"noreturn\", true, true, true),\n+  ATTR_EXCL (\"pure\", true, true, true),\n+  ATTR_EXCL (NULL, false, false, false)\n+};\n+\n /* Table of machine-independent attributes supported in GIMPLE.  */\n const struct attribute_spec lto_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n-       do_diagnostic } */\n+       do_diagnostic, exclusions } */\n   { \"noreturn\",               0, 0, true,  false, false,\n-\t\t\t      handle_noreturn_attribute, false },\n+\t\t\t      handle_noreturn_attribute, false,\n+\t\t\t      attr_noreturn_exclusions },\n   { \"leaf\",\t\t      0, 0, true,  false, false,\n-\t\t\t      handle_leaf_attribute, false },\n+\t\t\t      handle_leaf_attribute, false, NULL },\n   /* The same comments as for noreturn attributes apply to const ones.  */\n   { \"const\",                  0, 0, true,  false, false,\n-\t\t\t      handle_const_attribute, false },\n+\t\t\t      handle_const_attribute, false,\n+\t\t\t      attr_const_pure_exclusions },\n   { \"malloc\",                 0, 0, true,  false, false,\n-\t\t\t      handle_malloc_attribute, false },\n+\t\t\t      handle_malloc_attribute, false, NULL },\n   { \"pure\",                   0, 0, true,  false, false,\n-\t\t\t      handle_pure_attribute, false },\n+\t\t\t      handle_pure_attribute, false,\n+\t\t\t      attr_const_pure_exclusions },\n   { \"no vops\",                0, 0, true,  false, false,\n-\t\t\t      handle_novops_attribute, false },\n+\t\t\t      handle_novops_attribute, false, NULL },\n   { \"nonnull\",                0, -1, false, true, true,\n-\t\t\t      handle_nonnull_attribute, false },\n+\t\t\t      handle_nonnull_attribute, false, NULL },\n   { \"nothrow\",                0, 0, true,  false, false,\n-\t\t\t      handle_nothrow_attribute, false },\n+\t\t\t      handle_nothrow_attribute, false, NULL },\n   { \"patchable_function_entry\", 1, 2, true, false, false,\n \t\t\t      handle_patchable_function_entry_attribute,\n-\t\t\t      false },\n+\t\t\t      false, NULL },\n   { \"returns_twice\",          0, 0, true,  false, false,\n-\t\t\t      handle_returns_twice_attribute, false },\n+\t\t\t      handle_returns_twice_attribute, false,\n+\t\t\t      attr_returns_twice_exclusions },\n   { \"sentinel\",               0, 1, false, true, true,\n-\t\t\t      handle_sentinel_attribute, false },\n+\t\t\t      handle_sentinel_attribute, false, NULL },\n   { \"type generic\",           0, 0, false, true, true,\n-\t\t\t      handle_type_generic_attribute, false },\n+\t\t\t      handle_type_generic_attribute, false, NULL },\n   { \"fn spec\",\t \t      1, 1, false, true, true,\n-\t\t\t      handle_fnspec_attribute, false },\n+\t\t\t      handle_fnspec_attribute, false, NULL },\n   { \"transaction_pure\",\t      0, 0, false, true, true,\n-\t\t\t      handle_transaction_pure_attribute, false },\n+\t\t\t      handle_transaction_pure_attribute, false, NULL },\n   /* For internal use only.  The leading '*' both prevents its usage in\n      source code and signals that it may be overridden by machine tables.  */\n   { \"*tm regparm\",            0, 0, false, true, true,\n-\t\t\t      ignore_attribute, false },\n-  { NULL,                     0, 0, false, false, false, NULL, false }\n+\t\t\t      ignore_attribute, false, NULL },\n+  { NULL,                     0, 0, false, false, false, NULL, false, NULL }\n };\n \n /* Give the specifications for the format attributes, used by C and all\n@@ -105,12 +141,12 @@ const struct attribute_spec lto_attribute_table[] =\n const struct attribute_spec lto_format_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n-       affects_type_identity } */\n+       affects_type_identity, exclusions } */\n   { \"format\",                 3, 3, false, true,  true,\n-\t\t\t      handle_format_attribute, false },\n+\t\t\t      handle_format_attribute, false, NULL },\n   { \"format_arg\",             1, 1, false, true,  true,\n-\t\t\t      handle_format_arg_attribute, false },\n-  { NULL,                     0, 0, false, false, false, NULL, false }\n+\t\t\t      handle_format_arg_attribute, false, NULL },\n+  { NULL,                     0, 0, false, false, false, NULL, false, NULL }\n };\n \n enum built_in_attribute\n@@ -264,6 +300,10 @@ handle_const_attribute (tree *node, tree ARG_UNUSED (name),\n \t\t\ttree ARG_UNUSED (args), int ARG_UNUSED (flags),\n \t\t\tbool * ARG_UNUSED (no_add_attrs))\n {\n+  if (TREE_CODE (*node) != FUNCTION_DECL\n+      || !DECL_BUILT_IN (*node))\n+    inform (UNKNOWN_LOCATION, \"%s:%s: %E: %E\", __FILE__, __func__, *node, name);\n+\n   tree type = TREE_TYPE (*node);\n \n   /* See FIXME comment on noreturn in c_common_attribute_table.  */"}, {"sha": "d57ba992e5c295e3598cff166b2f3270510c5c65", "filename": "gcc/selftest-run-tests.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fselftest-run-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fselftest-run-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest-run-tests.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -25,6 +25,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"langhooks.h\"\n #include \"options.h\"\n+#include \"stringpool.h\"\n+#include \"attribs.h\"\n \n /* This function needed to be split out from selftest.c as it references\n    tests from the whole source tree, and so is within\n@@ -85,6 +87,7 @@ selftest::run_tests ()\n   spellcheck_c_tests ();\n   spellcheck_tree_c_tests ();\n   tree_cfg_c_tests ();\n+  attribute_c_tests ();\n \n   /* This one relies on most of the above.  */\n   function_tests_c_tests ();"}, {"sha": "d0aa3b217c013e469d74e7dd3ebbe41143a66036", "filename": "gcc/selftest.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -170,6 +170,7 @@ extern const char *path_to_selftest_files;\n \n /* Declarations for specific families of tests (by source file), in\n    alphabetical order.  */\n+extern void attribute_c_tests ();\n extern void bitmap_c_tests ();\n extern void sbitmap_c_tests ();\n extern void diagnostic_c_tests ();"}, {"sha": "4a4406a340594cd1719b9d87fb019ac8e94a7d4e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -1,3 +1,16 @@\n+2017-12-07  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/81544\n+\t* c-c++-common/Wattributes-2.c: New test.\n+\t* c-c++-common/Wattributes.c: New test.\n+\t* c-c++-common/attributes-3.c: Adjust.\n+\t* gcc.dg/Wattributes-6.c: New test.\n+\t* gcc.dg/Wattributes-7.c: New test.\n+\t* gcc.dg/attr-noinline.c\n+\t* gcc.dg/pr44964.c: Same.\n+\t* gcc.dg/torture/pr42363.c: Same.\n+\t* gcc.dg/tree-ssa/ssa-ccp-2.c: Same.\n+\n 2017-12-07  Tamar Christina  <tamar.christina@arm.com>\n \n \tPR target/82641"}, {"sha": "c2be4bbfbeacdfcb2a01c6da82d2a92ccfaa6e24", "filename": "gcc/testsuite/c-c++-common/attributes-3.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattributes-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattributes-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattributes-3.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -12,16 +12,16 @@ extern __attribute__((noinline)) int fn1 (void); /* { dg-message \"previous decla\n extern inline int fn1 (void); /* { dg-warning \"inline declaration of\" } */\n \n extern inline int fn2 (void); /* { dg-message \"previous declaration\" } */\n-extern __attribute__((noinline)) int fn2 (void); /* { dg-warning \"attribute noinline follows inline declaration\" } */\n+extern __attribute__((noinline)) int fn2 (void); /* { dg-warning \"attribute .noinline. follows inline declaration\" } */\n \n extern __attribute__((always_inline)) int fn3 (void); /* { dg-message \"previous declaration\" } */\n-extern __attribute__((noinline)) int fn3 (void); /* { dg-warning \"attribute .noinline. follows declaration with attribute .always_inline.\" } */\n+extern __attribute__((noinline)) int fn3 (void); /* { dg-warning \"attribute .noinline.\" } */\n \n extern __attribute__((noinline)) int fn4 (void); /* { dg-message \"previous declaration\" } */\n-extern __attribute__((always_inline)) int fn4 (void); /* { dg-warning \"attribute .always_inline. follows declaration with attribute .noinline.\" } */\n+extern __attribute__((always_inline)) int fn4 (void); /* { dg-warning \"attribute .always_inline.\" } */\n \n extern __attribute__((hot)) int fn5 (void); /* { dg-message \"previous declaration\" } */\n-extern __attribute__((cold)) int fn5 (void); /* { dg-warning \"attribute .cold. follows declaration with attribute .hot.\" } */\n+extern __attribute__((cold)) int fn5 (void); /* { dg-warning \"attribute .cold.\" } */\n \n extern __attribute__((cold)) int fn6 (void); /* { dg-message \"previous declaration\" } */\n-extern __attribute__((hot)) int fn6 (void); /* { dg-warning \"attribute .hot. follows declaration with attribute .cold.\" } */\n+extern __attribute__((hot)) int fn6 (void); /* { dg-warning \"attribute .hot.\" } */"}, {"sha": "13cc6600c28d36debc6a1aeee2ff096a7ecf5db4", "filename": "gcc/testsuite/gcc.dg/attr-noinline.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-noinline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-noinline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-noinline.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -17,7 +17,7 @@ static void function_declaration_both_after(void) {t();}\n \n static void function_declaration_noinline_before(void) __attribute__((__noinline__)); /* { dg-message \"note: previous declaration\" } */\n \n-static inline void function_declaration_noinline_before(void) {t();} /* { dg-warning \"follows declaration with attribute noinline\" } */\n+static inline void function_declaration_noinline_before(void) {t();} /* { dg-warning \"follows declaration with attribute .noinline.\" } */\n \n static inline void function_declaration_noinline_after(void) {t();} /* { dg-message \"note: previous definition\" } */\n \n@@ -41,7 +41,7 @@ static void function_declaration_inline_noinline_after(void) __attribute__((__no\n \n static void function_declaration_noinline_inline_before(void) __attribute__((__noinline__)); /* { dg-message \"note: previous declaration\" } */\n \n-static inline void function_declaration_noinline_inline_before(void); /* { dg-warning \"follows declaration with attribute noinline\" } */\n+static inline void function_declaration_noinline_inline_before(void); /* { dg-warning \"follows declaration with attribute .noinline.\" } */\n \n static void function_declaration_noinline_inline_before(void) {t();}\n "}, {"sha": "6c252ee2616b83a3b0ec6d88f3cf0344822bd707", "filename": "gcc/testsuite/gcc.dg/pr44964.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Ftestsuite%2Fgcc.dg%2Fpr44964.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Ftestsuite%2Fgcc.dg%2Fpr44964.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr44964.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -2,8 +2,9 @@\n /* { dg-options \"-fkeep-inline-functions -O\" } */\n \n static inline __attribute__ ((const))\n-void baz (int i)\n+int baz (int i)\n {\n+  return i;\n }\n \n static __attribute__ ((always_inline))"}, {"sha": "ad0eac8ceed51efd6a35057415f2b33c7f7ef8c7", "filename": "gcc/testsuite/gcc.dg/torture/pr42363.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr42363.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr42363.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr42363.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -46,16 +46,18 @@ int bizr (void)\n   return i + 1;\n }\n \n-/* This might be regarded as pure and folded, rather than inlined.\n-   It's pure evil.  */\n+/* This might be regarded as pure and folded, rather than inlined,\n+   but because it's pure evil it's diagnosed and the noreturn attribute\n+   is dropped.  The const attribute is dropped as well because it's\n+   mutually exclusive with pure.  */\n static int __attribute__ ((pure, const, noreturn))\n-barf (void)\n-{\n+barf (void) {\n+  /* { dg-warning \"ignoring attribute .const.\" \"const\" { target *-*-* } .-1 } */\n+  /* { dg-warning \"ignoring attribute .noreturn.\" \"noreturn\" { target *-*-* } .-2 } */\n } /* { dg-warning \"does return\" } */\n \n static int __attribute__ ((pure, const))\n-bark (void)\n-{\n+bark (void) {   /* { dg-warning \"ignoring attribute .const.\" } */\n   barf ();\n }\n "}, {"sha": "b8c5654ffc2255c8da48a9cadeccd23bf8143dec", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-2.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-2.c?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -113,17 +113,18 @@ int test9 (int *intarr)\n \n int test99 (int *intarr)\n {\n-  extern int foo9 (int) __attribute__ ((pure));\n+  extern int foo99 (int) __attribute__ ((pure));\n   int h, v;\n   g9 = 9;\n-  h = foo9 (g9);\n+  h = foo99 (g9);\n   v = g9;\n   if (v != 9)\n     link_error ();\n   return g9;\n }\n \n-extern int foo99 (int);\n+/* foo9 is const because of its declaration in test9.  */\n+extern int foo9 (int);\n \n int test999 (int *arr)\n {\n@@ -134,10 +135,12 @@ int test999 (int *arr)\n   v1 = g9;\n   if (v1 != 9)\n     link_error ();\n-  l = foo99 (l);\n+  l = foo9 (l);\n   return v1 + l;\n }\n \n+/* foo99 is pure because of its declaration in test99.  */\n+extern int foo9 (int);\n \n int test9999 (void)\n {"}, {"sha": "7672541f1b406fe84a430164a726bdb8293b0291", "filename": "gcc/tree-core.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -1938,6 +1938,20 @@ struct attribute_spec {\n \t\t   int flags, bool *no_add_attrs);\n   /* Specifies if attribute affects type's identity.  */\n   bool affects_type_identity;\n+\n+  /* Specifies the name of an attribute that's mutually exclusive with\n+     this one, and whether the relationship applies to the function,\n+     variable, or type form of the attribute.  */\n+  struct exclusions {\n+    const char *name;\n+    bool function;\n+    bool variable;\n+    bool type;\n+  };\n+\n+  /* An array of attribute exclusions describing names of other attributes\n+     that this attribute is mutually exclusive with.  */\n+  const exclusions *exclude;\n };\n \n /* These functions allow a front-end to perform a manual layout of a"}, {"sha": "f4a04fac43fedcb851069d3963e0a0fcc3b37eba", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -1,3 +1,9 @@\n+2017-12-07  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/81544\n+\t* include/ext/mt_allocator.h (_M_destroy_thread_key): Remove\n+\tattribute const.\n+\n 2017-12-05  Jason Merrill  <jason@redhat.com>\n \t    Jonathan Wakely  <jwakely@redhat.com>\n "}, {"sha": "99c20423f94b83d9dad65e8dac04ba1a08ba9c1d", "filename": "libstdc++-v3/include/ext/mt_allocator.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d9ae53d70c72991e26648d915e7fb8e00b8e811/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d9ae53d70c72991e26648d915e7fb8e00b8e811/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h?ref=5d9ae53d70c72991e26648d915e7fb8e00b8e811", "patch": "@@ -355,7 +355,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n       // XXX GLIBCXX_ABI Deprecated\n-      _GLIBCXX_CONST void \n+      void\n       _M_destroy_thread_key(void*) throw ();\n \n       size_t "}]}