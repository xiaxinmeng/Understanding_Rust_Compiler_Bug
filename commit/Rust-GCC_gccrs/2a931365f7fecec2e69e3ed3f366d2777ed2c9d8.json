{"sha": "2a931365f7fecec2e69e3ed3f366d2777ed2c9d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmE5MzEzNjVmN2ZlY2VjMmU2OWUzZWQzZjM2NmQyNzc3ZWQyYzlkOA==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2014-10-03T08:50:26Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2014-10-03T08:50:26Z"}, "message": "parser.c (cp_parser_assignment_expression, [...]): Add default arguments.\n\n2014-10-03  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* parser.c (cp_parser_assignment_expression,\n\tcp_parser_constant_expression): Add default arguments.\n\t(cp_parser_primary_expression,\n\tcp_parser_postfix_open_square_expression,\n\tcp_parser_parenthesized_expression_list,\n\tcp_parser_question_colon_clause,\n\tcp_parser_expression, cp_parser_constant_expression,\n\tcp_parser_label_for_labeled_statement, cp_parser_static_assert,\n\tcp_parser_template_argument, cp_parser_enumerator_definition,\n\tcp_parser_member_declaration, cp_parser_constant_initializer,\n\tcp_parser_noexcept_specification_opt, cp_parser_throw_expression,\n\tcp_parser_std_attribute_spec, cp_parser_objc_message_args,\n\tcp_parser_objc_class_ivars, cp_parser_omp_clause_collapse,\n\tcp_parser_omp_clause_aligned, cp_parser_omp_clause_safelen,\n\tcp_parser_omp_clause_simdlen, cp_parser_omp_clause_dist_schedule,\n\tcp_parser_omp_for_incr, cp_parser_omp_for_loop_init,\n\tcp_parser_cilk_simd_vectorlength, cp_parser_cilk_simd_linear): Adjust.\n\nFrom-SVN: r215840", "tree": {"sha": "de4690ee3ae20109a27f6989af956a05b1948b19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de4690ee3ae20109a27f6989af956a05b1948b19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a931365f7fecec2e69e3ed3f366d2777ed2c9d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a931365f7fecec2e69e3ed3f366d2777ed2c9d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a931365f7fecec2e69e3ed3f366d2777ed2c9d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a931365f7fecec2e69e3ed3f366d2777ed2c9d8/comments", "author": null, "committer": null, "parents": [{"sha": "54bddf1d58d0ff4c2625a0310b8ff7853d73b871", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54bddf1d58d0ff4c2625a0310b8ff7853d73b871", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54bddf1d58d0ff4c2625a0310b8ff7853d73b871"}], "stats": {"total": 115, "additions": 56, "deletions": 59}, "files": [{"sha": "80ed468ab5c2ceffc3429197cadd4ecca3c951f8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a931365f7fecec2e69e3ed3f366d2777ed2c9d8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a931365f7fecec2e69e3ed3f366d2777ed2c9d8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2a931365f7fecec2e69e3ed3f366d2777ed2c9d8", "patch": "@@ -1,3 +1,23 @@\n+2014-10-03  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* parser.c (cp_parser_assignment_expression,\n+\tcp_parser_constant_expression): Add default arguments.\n+\t(cp_parser_primary_expression,\n+\tcp_parser_postfix_open_square_expression,\n+\tcp_parser_parenthesized_expression_list,\n+\tcp_parser_question_colon_clause,\n+\tcp_parser_expression, cp_parser_constant_expression,\n+\tcp_parser_label_for_labeled_statement, cp_parser_static_assert,\n+\tcp_parser_template_argument, cp_parser_enumerator_definition,\n+\tcp_parser_member_declaration, cp_parser_constant_initializer,\n+\tcp_parser_noexcept_specification_opt, cp_parser_throw_expression,\n+\tcp_parser_std_attribute_spec, cp_parser_objc_message_args,\n+\tcp_parser_objc_class_ivars, cp_parser_omp_clause_collapse,\n+\tcp_parser_omp_clause_aligned, cp_parser_omp_clause_safelen,\n+\tcp_parser_omp_clause_simdlen, cp_parser_omp_clause_dist_schedule,\n+\tcp_parser_omp_for_incr, cp_parser_omp_for_loop_init,\n+\tcp_parser_cilk_simd_vectorlength, cp_parser_cilk_simd_linear): Adjust.\n+\n 2014-10-02  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/53025"}, {"sha": "0050b8d21a00c74ab9043e6be84aa557e81375b7", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 36, "deletions": 59, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a931365f7fecec2e69e3ed3f366d2777ed2c9d8/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a931365f7fecec2e69e3ed3f366d2777ed2c9d8/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=2a931365f7fecec2e69e3ed3f366d2777ed2c9d8", "patch": "@@ -1961,13 +1961,13 @@ static tree cp_parser_binary_expression\n static tree cp_parser_question_colon_clause\n   (cp_parser *, tree);\n static tree cp_parser_assignment_expression\n-  (cp_parser *, bool, cp_id_kind *);\n+  (cp_parser *, cp_id_kind * = NULL, bool = false, bool = false);\n static enum tree_code cp_parser_assignment_operator_opt\n   (cp_parser *);\n static tree cp_parser_expression\n   (cp_parser *, cp_id_kind * = NULL, bool = false, bool = false);\n static tree cp_parser_constant_expression\n-  (cp_parser *, bool, bool *);\n+  (cp_parser *, bool = false, bool * = NULL);\n static tree cp_parser_builtin_offsetof\n   (cp_parser *);\n static tree cp_parser_lambda_expression\n@@ -4451,8 +4451,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t    /* Look for the opening `('.  */\n \t    cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n \t    /* Now, parse the assignment-expression.  */\n-\t    expression = cp_parser_assignment_expression (parser,\n-\t\t\t\t\t\t\t  /*cast_p=*/false, NULL);\n+\t    expression = cp_parser_assignment_expression (parser);\n \t    /* Look for the `,'.  */\n \t    cp_parser_require (parser, CPP_COMMA, RT_COMMA);\n \t    type_location = cp_lexer_peek_token (parser->lexer)->location;\n@@ -6424,7 +6423,7 @@ cp_parser_postfix_open_square_expression (cp_parser *parser,\n      Rather than open the barn door too wide right away, allow only integer\n      constant expressions here.  */\n   if (for_offsetof)\n-    index = cp_parser_constant_expression (parser, false, NULL);\n+    index = cp_parser_constant_expression (parser);\n   else\n     {\n       if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n@@ -6807,8 +6806,8 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n \t\t    break;\n \t\t  }\n \t\tif (expr == NULL_TREE)\n-\t\t  expr = cp_parser_assignment_expression (parser, cast_p,\n-\t\t\t\t\t\t\t  NULL);\n+\t\t  expr = cp_parser_assignment_expression (parser, /*pidk=*/NULL,\n+\t\t\t\t\t\t\t  cast_p);\n \t      }\n \n \t    if (fold_expr_p)\n@@ -8239,7 +8238,7 @@ cp_parser_question_colon_clause (cp_parser* parser, tree logical_or_expr)\n   /* The next token should be a `:'.  */\n   cp_parser_require (parser, CPP_COLON, RT_COLON);\n   /* Parse the assignment-expression.  */\n-  assignment_expr = cp_parser_assignment_expression (parser, /*cast_p=*/false, NULL);\n+  assignment_expr = cp_parser_assignment_expression (parser);\n   c_inhibit_evaluation_warnings -= logical_or_expr == truthvalue_true_node;\n \n   /* Build the conditional-expression.  */\n@@ -8262,8 +8261,8 @@ cp_parser_question_colon_clause (cp_parser* parser, tree logical_or_expr)\n    Returns a representation for the expression.  */\n \n static tree\n-cp_parser_assignment_expression (cp_parser* parser, bool cast_p,\n-\t\t\t\t bool decltype_p, cp_id_kind * pidk)\n+cp_parser_assignment_expression (cp_parser* parser, cp_id_kind * pidk,\n+\t\t\t\t bool cast_p, bool decltype_p)\n {\n   tree expr;\n \n@@ -8323,14 +8322,6 @@ cp_parser_assignment_expression (cp_parser* parser, bool cast_p,\n   return expr;\n }\n \n-static tree\n-cp_parser_assignment_expression (cp_parser* parser, bool cast_p,\n-\t\t\t\t cp_id_kind * pidk)\n-{\n-  return cp_parser_assignment_expression (parser, cast_p,\n-\t\t\t\t\t  /*decltype*/false, pidk);\n-}\n-\n /* Parse an (optional) assignment-operator.\n \n    assignment-operator: one of\n@@ -8440,7 +8431,7 @@ cp_parser_expression (cp_parser* parser, cp_id_kind * pidk,\n \n       /* Parse the next assignment-expression.  */\n       assignment_expression\n-\t= cp_parser_assignment_expression (parser, cast_p, decltype_p, pidk);\n+\t= cp_parser_assignment_expression (parser, pidk, cast_p, decltype_p);\n \n       /* We don't create a temporary for a call that is the immediate operand\n \t of decltype or on the RHS of a comma.  But when we see a comma, we\n@@ -8532,7 +8523,7 @@ cp_parser_constant_expression (cp_parser* parser,\n      For example, cp_parser_initializer_clauses uses this function to\n      determine whether a particular assignment-expression is in fact\n      constant.  */\n-  expression = cp_parser_assignment_expression (parser, /*cast_p=*/false, NULL);\n+  expression = cp_parser_assignment_expression (parser);\n   /* Restore the old settings.  */\n   parser->integral_constant_expression_p\n     = saved_integral_constant_expression_p;\n@@ -9741,19 +9732,16 @@ cp_parser_label_for_labeled_statement (cp_parser* parser, tree attributes)\n \t/* Consume the `case' token.  */\n \tcp_lexer_consume_token (parser->lexer);\n \t/* Parse the constant-expression.  */\n-\texpr = cp_parser_constant_expression (parser,\n-\t\t\t\t\t      /*allow_non_constant_p=*/false,\n-\t\t\t\t\t      NULL);\n+\texpr = cp_parser_constant_expression (parser);\n \n \tellipsis = cp_lexer_peek_token (parser->lexer);\n \tif (ellipsis->type == CPP_ELLIPSIS)\n \t  {\n \t    /* Consume the `...' token.  */\n \t    cp_lexer_consume_token (parser->lexer);\n \t    expr_hi =\n-\t      cp_parser_constant_expression (parser,\n-\t\t\t\t\t     /*allow_non_constant_p=*/false,\n-\t\t\t\t\t     NULL);\n+\t      cp_parser_constant_expression (parser);\n+\n \t    /* We don't need to emit warnings here, as the common code\n \t       will do this for us.  */\n \t  }\n@@ -14231,9 +14219,8 @@ cp_parser_template_argument (cp_parser* parser)\n      because the argument could really be a type-id.  */\n   if (maybe_type_id)\n     cp_parser_parse_tentatively (parser);\n-  argument = cp_parser_constant_expression (parser,\n-\t\t\t\t\t    /*allow_non_constant_p=*/false,\n-\t\t\t\t\t    /*non_constant_p=*/NULL);\n+  argument = cp_parser_constant_expression (parser);\n+\n   if (!maybe_type_id)\n     return argument;\n   if (!cp_parser_next_token_ends_template_argument_p (parser))\n@@ -15894,9 +15881,7 @@ cp_parser_enumerator_definition (cp_parser* parser, tree type)\n       /* Consume the `=' token.  */\n       cp_lexer_consume_token (parser->lexer);\n       /* Parse the value.  */\n-      value = cp_parser_constant_expression (parser,\n-\t\t\t\t\t     /*allow_non_constant_p=*/false,\n-\t\t\t\t\t     NULL);\n+      value = cp_parser_constant_expression (parser);\n     }\n   else\n     value = NULL_TREE;\n@@ -20721,9 +20706,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t      cp_lexer_consume_token (parser->lexer);\n \t      /* Get the width of the bitfield.  */\n \t      width\n-\t\t= cp_parser_constant_expression (parser,\n-\t\t\t\t\t\t /*allow_non_constant=*/false,\n-\t\t\t\t\t\t NULL);\n+\t\t= cp_parser_constant_expression (parser);\n \n \t      /* Look for attributes that apply to the bitfield.  */\n \t      attributes = cp_parser_attributes_opt (parser);\n@@ -21048,9 +21031,7 @@ cp_parser_constant_initializer (cp_parser* parser)\n       return error_mark_node;\n     }\n \n-  return cp_parser_constant_expression (parser,\n-\t\t\t\t\t/*allow_non_constant=*/false,\n-\t\t\t\t\tNULL);\n+  return cp_parser_constant_expression (parser);\n }\n \n /* Derived classes [gram.class.derived] */\n@@ -21310,7 +21291,7 @@ cp_parser_noexcept_specification_opt (cp_parser* parser,\n \t      parser->type_definition_forbidden_message\n \t      = G_(\"types may not be defined in an exception-specification\");\n \n-\t      expr = cp_parser_constant_expression (parser, false, NULL);\n+\t      expr = cp_parser_constant_expression (parser);\n \n \t      /* Restore the saved message.  */\n \t      parser->type_definition_forbidden_message = saved_message;\n@@ -21621,8 +21602,7 @@ cp_parser_throw_expression (cp_parser* parser)\n       || token->type == CPP_COLON)\n     expression = NULL_TREE;\n   else\n-    expression = cp_parser_assignment_expression (parser,\n-\t\t\t\t\t\t  /*cast_p=*/false, NULL);\n+    expression = cp_parser_assignment_expression (parser);\n \n   return build_throw (expression);\n }\n@@ -22346,8 +22326,7 @@ cp_parser_std_attribute_spec (cp_parser *parser)\n \t\t      || alignas_expr == NULL_TREE);\n \n \t  alignas_expr =\n-\t    cp_parser_assignment_expression (parser, /*cast_p=*/false,\n-\t\t\t\t\t     /**cp_id_kind=*/NULL);\n+\t    cp_parser_assignment_expression (parser);\n \t  if (alignas_expr == error_mark_node)\n \t    cp_parser_skip_to_end_of_statement (parser);\n \t  if (alignas_expr == NULL_TREE\n@@ -25540,7 +25519,7 @@ cp_parser_objc_message_args (cp_parser* parser)\n \n       maybe_unary_selector_p = false;\n       cp_parser_require (parser, CPP_COLON, RT_COLON);\n-      arg = cp_parser_assignment_expression (parser, false, NULL);\n+      arg = cp_parser_assignment_expression (parser);\n \n       sel_args\n \t= chainon (sel_args,\n@@ -25555,7 +25534,7 @@ cp_parser_objc_message_args (cp_parser* parser)\n       tree arg;\n \n       cp_lexer_consume_token (parser->lexer);\n-      arg = cp_parser_assignment_expression (parser, false, NULL);\n+      arg = cp_parser_assignment_expression (parser);\n \n       addl_args\n \t= chainon (addl_args,\n@@ -26419,9 +26398,7 @@ cp_parser_objc_class_ivars (cp_parser* parser)\n \t      cp_lexer_consume_token (parser->lexer);  /* Eat ':'.  */\n \t      /* Get the width of the bitfield.  */\n \t      width\n-\t\t= cp_parser_constant_expression (parser,\n-\t\t\t\t\t\t /*allow_non_constant=*/false,\n-\t\t\t\t\t\t NULL);\n+\t\t= cp_parser_constant_expression (parser);\n \t    }\n \t  else\n \t    {\n@@ -27621,7 +27598,7 @@ cp_parser_omp_clause_collapse (cp_parser *parser, tree list, location_t location\n   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return list;\n \n-  num = cp_parser_constant_expression (parser, false, NULL);\n+  num = cp_parser_constant_expression (parser);\n \n   if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n@@ -28011,7 +27988,7 @@ cp_parser_omp_clause_schedule (cp_parser *parser, tree list, location_t location\n       cp_lexer_consume_token (parser->lexer);\n \n       token = cp_lexer_peek_token (parser->lexer);\n-      t = cp_parser_assignment_expression (parser, false, NULL);\n+      t = cp_parser_assignment_expression (parser);\n \n       if (t == error_mark_node)\n \tgoto resync_fail;\n@@ -28167,7 +28144,7 @@ cp_parser_omp_clause_aligned (cp_parser *parser, tree list)\n \n   if (colon)\n     {\n-      alignment = cp_parser_constant_expression (parser, false, NULL);\n+      alignment = cp_parser_constant_expression (parser);\n \n       if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n \tcp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n@@ -28237,7 +28214,7 @@ cp_parser_omp_clause_safelen (cp_parser *parser, tree list,\n   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return list;\n \n-  t = cp_parser_constant_expression (parser, false, NULL);\n+  t = cp_parser_constant_expression (parser);\n \n   if (t == error_mark_node\n       || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n@@ -28266,7 +28243,7 @@ cp_parser_omp_clause_simdlen (cp_parser *parser, tree list,\n   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return list;\n \n-  t = cp_parser_constant_expression (parser, false, NULL);\n+  t = cp_parser_constant_expression (parser);\n \n   if (t == error_mark_node\n       || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n@@ -28440,7 +28417,7 @@ cp_parser_omp_clause_dist_schedule (cp_parser *parser, tree list,\n     {\n       cp_lexer_consume_token (parser->lexer);\n \n-      t = cp_parser_assignment_expression (parser, false, NULL);\n+      t = cp_parser_assignment_expression (parser);\n \n       if (t == error_mark_node)\n \tgoto resync_fail;\n@@ -29390,7 +29367,7 @@ cp_parser_omp_for_incr (cp_parser *parser, tree decl)\n \n   if (op != NOP_EXPR)\n     {\n-      rhs = cp_parser_assignment_expression (parser, false, NULL);\n+      rhs = cp_parser_assignment_expression (parser);\n       rhs = build2 (op, TREE_TYPE (decl), decl, rhs);\n       return build2 (MODIFY_EXPR, TREE_TYPE (decl), decl, rhs);\n     }\n@@ -29563,7 +29540,7 @@ cp_parser_omp_for_loop_init (cp_parser *parser,\n \t    {\n \t      /* Consume '='.  */\n \t      cp_lexer_consume_token (parser->lexer);\n-\t      init = cp_parser_assignment_expression (parser, false, NULL);\n+\t      init = cp_parser_assignment_expression (parser);\n \n \t    non_class:\n \t      if (TREE_CODE (TREE_TYPE (decl)) == REFERENCE_TYPE)\n@@ -29599,7 +29576,7 @@ cp_parser_omp_for_loop_init (cp_parser *parser,\n \n \t  cp_parser_parse_definitely (parser);\n \t  cp_parser_require (parser, CPP_EQ, RT_EQ);\n-\t  rhs = cp_parser_assignment_expression (parser, false, NULL);\n+\t  rhs = cp_parser_assignment_expression (parser);\n \t  finish_expr_stmt (build_x_modify_expr (EXPR_LOCATION (rhs),\n \t\t\t\t\t\t decl, NOP_EXPR,\n \t\t\t\t\t\t rhs,\n@@ -32125,7 +32102,7 @@ cp_parser_cilk_simd_vectorlength (cp_parser *parser, tree clauses,\n   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return error_mark_node;\n \n-  expr = cp_parser_constant_expression (parser, false, NULL);\n+  expr = cp_parser_constant_expression (parser);\n   expr = maybe_constant_value (expr);\n \n   /* If expr == error_mark_node, then don't emit any errors nor\n@@ -32226,7 +32203,7 @@ cp_parser_cilk_simd_linear (cp_parser *parser, tree clauses)\n \t    {\n \t      cp_lexer_consume_token (parser->lexer);\n \n-\t      e = cp_parser_assignment_expression (parser, false, NULL);\n+\t      e = cp_parser_assignment_expression (parser);\n \t      e = maybe_constant_value (e);\n \n \t      if (e == error_mark_node)"}]}