{"sha": "42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJkYjUwNGMyZmIyYjQ2MGUyNGNhMGU3M2I4NTU5ZmMzM2IzY2YzMw==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2010-05-03T17:47:47Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2010-05-03T17:47:47Z"}, "message": "tm.texi (defmac SMALL_REGISTER_CLASSES): Remove.\n\n\t* doc/tm.texi (defmac SMALL_REGISTER_CLASSES): Remove.\n\t(TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P): Add documentation,\n\tbased on the above, for new target hook.\n\n\t* hooks.c (hook_bool_mode_true): New generic hook.\n\t* hooks.h (hook_bool_mode_true): Add prototype.\n\n\t* target.h (struct gcc_target): Add small_register_classes_for_mode_p\n\ttarget hook.\n\t* target-def.h (TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P): New default\n\ttarget hook, set to hook_bool_mode_false.\n\t* regs.h: Remove default definition of SMALL_REGISTER_CLASSES.\n\t* reload.c (push_secondary_reload): Replace SMALL_REGISTER_CLASSES\n\twith targetm.small_register_classes_for_mode_p.\n\t(find_reusable_reload): Likewise.\n\t(combine_reloads): Likewise.\n\t* reload1.c (reload_as_needed): Likewise.\n\t* cse.c (approx_reg_cost_1, hash_rtx_cb): Likewise.\n\t* ifcvt.c (noce_process_if_block, check_cond_move_block,\n\tdead_or_predicable): Likewise.\n\t* regmove.c (optimize_reg_copy_1): Likewise.\n\t* calls.c (prepare_call_address): Likewise.\n\t(precompute_register_parameters): Likewise.\n\n\t* config/sh/sh.h: Replace SMALL_REGISTER_CLASSES with new target\n\thook definition.\n\t* config/sh/sh.c (sh_small_register_classes_for_mode_p): Add\n\timplementation of the hook that considers all register classes\n\tsmall except for SH64.\n\t(sh_override_options): Use the new hook.\n\t* config/sh/sh-protos.h (sh_small_register_classes_for_mode_p):\n\tAdd prototype.\n\n\t* config/arm/arm.h: Replace SMALL_REGISTER_CLASSES with new target\n\thook definition.\n\t* config/arm/arm.c (arm_small_register_classes_for_mode_p): Add\n\timplementation of the hook that considers all register classes\n\tsmall for THUMB1.\n\t* config/arm/arm-protos.h (arm_small_register_classes_for_mode_p):\n\tAdd prototype.\n\n\t* config/mips/mips.h: Replace SMALL_REGISTER_CLASSES with new target\n\thook definition.\n\t* config/mips/mips.c (mips_small_register_classes_for_mode_p): Add\n\timplementation of the hook that considers all register classes\n\tsmall for MIPS16.\n\t* config/mips/mips-protos.h (mips_small_register_classes_for_mode_p):\n\tAdd prototype.\n\n\t* config/i386/i386.h: Replace SMALL_REGISTER_CLASSES with new target\n\thook definition.\n\t* config/m32c/m32c.h: Likewise.\n\t* config/pdp11/pdp11.h: Likewise.\n\t* config/avr/avr.h: Likewise.\n\t* config/xtensa/xtensa.h: Likewise.\n\t* config/m68hc11/m68hc11.h: Likewise.\n\t* config/mn10300/mn10300.h: Likewise.\n\t* config/mcore/mcore.h: Likewise.\n\t* config/h8300/h8300.h: Likewise.\n\t* config/bfin/bfin.h: Likewise.\n\n\t* config/iq2000/iq2000.h: Remove SMALL_REGISTER_CLASSES definition.\n\t* config/rx/rx.h: Remove SMALL_REGISTER_CLASSES definition.\n\nFrom-SVN: r158997", "tree": {"sha": "d6b919e11206907a280cef642b29741b31e6e929", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6b919e11206907a280cef642b29741b31e6e929"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/comments", "author": null, "committer": null, "parents": [{"sha": "d5ece0a1f59fd71e156bc58c8423eb7ea8d16480", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5ece0a1f59fd71e156bc58c8423eb7ea8d16480", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5ece0a1f59fd71e156bc58c8423eb7ea8d16480"}], "stats": {"total": 327, "additions": 229, "deletions": 98}, "files": [{"sha": "727f89724ce48d7e602a8fce2843b2bc0110f79f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -1,3 +1,69 @@\n+2010-05-03  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* doc/tm.texi (defmac SMALL_REGISTER_CLASSES): Remove.\n+\t(TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P): Add documentation,\n+\tbased on the above, for new target hook.\n+\n+\t* hooks.c (hook_bool_mode_true): New generic hook.\n+\t* hooks.h (hook_bool_mode_true): Add prototype.\n+\n+\t* target.h (struct gcc_target): Add small_register_classes_for_mode_p\n+\ttarget hook.\n+\t* target-def.h (TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P): New default\n+\ttarget hook, set to hook_bool_mode_false.\n+\t* regs.h: Remove default definition of SMALL_REGISTER_CLASSES.\n+\t* reload.c (push_secondary_reload): Replace SMALL_REGISTER_CLASSES\n+\twith targetm.small_register_classes_for_mode_p.\n+\t(find_reusable_reload): Likewise.\n+\t(combine_reloads): Likewise.\n+\t* reload1.c (reload_as_needed): Likewise.\n+\t* cse.c (approx_reg_cost_1, hash_rtx_cb): Likewise.\n+\t* ifcvt.c (noce_process_if_block, check_cond_move_block,\n+\tdead_or_predicable): Likewise.\n+\t* regmove.c (optimize_reg_copy_1): Likewise.\n+\t* calls.c (prepare_call_address): Likewise.\n+\t(precompute_register_parameters): Likewise.\n+\n+\t* config/sh/sh.h: Replace SMALL_REGISTER_CLASSES with new target\n+\thook definition.\n+\t* config/sh/sh.c (sh_small_register_classes_for_mode_p): Add\n+\timplementation of the hook that considers all register classes\n+\tsmall except for SH64.\n+\t(sh_override_options): Use the new hook.\n+\t* config/sh/sh-protos.h (sh_small_register_classes_for_mode_p):\n+\tAdd prototype.\n+\n+\t* config/arm/arm.h: Replace SMALL_REGISTER_CLASSES with new target\n+\thook definition.\n+\t* config/arm/arm.c (arm_small_register_classes_for_mode_p): Add\n+\timplementation of the hook that considers all register classes\n+\tsmall for THUMB1.\n+\t* config/arm/arm-protos.h (arm_small_register_classes_for_mode_p):\n+\tAdd prototype.\n+\n+\t* config/mips/mips.h: Replace SMALL_REGISTER_CLASSES with new target\n+\thook definition.\n+\t* config/mips/mips.c (mips_small_register_classes_for_mode_p): Add\n+\timplementation of the hook that considers all register classes\n+\tsmall for MIPS16.\n+\t* config/mips/mips-protos.h (mips_small_register_classes_for_mode_p):\n+\tAdd prototype.\n+\n+\t* config/i386/i386.h: Replace SMALL_REGISTER_CLASSES with new target\n+\thook definition.\n+\t* config/m32c/m32c.h: Likewise.\n+\t* config/pdp11/pdp11.h: Likewise.\n+\t* config/avr/avr.h: Likewise.\n+\t* config/xtensa/xtensa.h: Likewise.\n+\t* config/m68hc11/m68hc11.h: Likewise.\n+\t* config/mn10300/mn10300.h: Likewise.\n+\t* config/mcore/mcore.h: Likewise.\n+\t* config/h8300/h8300.h: Likewise.\n+\t* config/bfin/bfin.h: Likewise.\n+\n+\t* config/iq2000/iq2000.h: Remove SMALL_REGISTER_CLASSES definition.\n+\t* config/rx/rx.h: Remove SMALL_REGISTER_CLASSES definition.\n+\n 2010-05-03  Anatoly Sokolov  <aesok@post.ru>\n \n \t* double-int.h (tree_to_double_int): Remove macro."}, {"sha": "9c51f1a5a74e9b66f58c856e0455e9258dabea78", "filename": "gcc/calls.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -175,7 +175,8 @@ prepare_call_address (tree fndecl, rtx funexp, rtx static_chain_value,\n   if (GET_CODE (funexp) != SYMBOL_REF)\n     /* If we are using registers for parameters, force the\n        function address into a register now.  */\n-    funexp = ((SMALL_REGISTER_CLASSES && reg_parm_seen)\n+    funexp = ((reg_parm_seen\n+\t       && targetm.small_register_classes_for_mode_p (FUNCTION_MODE))\n \t      ? force_not_mem (memory_address (FUNCTION_MODE, funexp))\n \t      : memory_address (FUNCTION_MODE, funexp));\n   else if (! sibcallp)\n@@ -711,7 +712,8 @@ precompute_register_parameters (int num_actuals, struct arg_data *args,\n \t\t && args[i].mode != BLKmode\n \t\t && rtx_cost (args[i].value, SET, optimize_insn_for_speed_p ())\n \t\t    > COSTS_N_INSNS (1)\n-\t\t && ((SMALL_REGISTER_CLASSES && *reg_parm_seen)\n+\t\t && ((*reg_parm_seen\n+\t\t      && targetm.small_register_classes_for_mode_p (args[i].mode))\n \t\t     || optimize))\n \t  args[i].value = copy_to_mode_reg (args[i].mode, args[i].value);\n       }"}, {"sha": "7fb1873f53b66c8f589be59b7fe5099b20e9f94f", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -3123,10 +3123,10 @@ insert_insn_end_bb_new (rtx pat, basic_block bb)\n            && (!single_succ_p (bb)\n                || single_succ_edge (bb)->flags & EDGE_ABNORMAL))\n     {\n-      /* Keeping in mind SMALL_REGISTER_CLASSES and parameters in registers,\n-         we search backward and place the instructions before the first\n-         parameter is loaded.  Do this for everyone for consistency and a\n-         presumption that we'll get better code elsewhere as well.  */\n+      /* Keeping in mind targets with small register classes and parameters\n+         in registers, we search backward and place the instructions before\n+\t the first parameter is loaded.  Do this for everyone for consistency\n+\t and a presumption that we'll get better code elsewhere as well.  */\n \n       /* Since different machines initialize their parameter registers\n          in different orders, assume nothing.  Collect the set of all"}, {"sha": "2933201a1ebbce2ced1fb478de8b4574b5fc7c00", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -45,6 +45,7 @@ extern void arm_output_fn_unwind (FILE *, bool);\n \n #ifdef RTX_CODE\n extern bool arm_vector_mode_supported_p (enum machine_mode);\n+extern bool arm_small_register_classes_for_mode_p (enum machine_mode);\n extern int arm_hard_regno_mode_ok (unsigned int, enum machine_mode);\n extern int const_ok_for_arm (HOST_WIDE_INT);\n extern int arm_split_constant (RTX_CODE, enum machine_mode, rtx,"}, {"sha": "7f3cdfa239fff7b71f97c29fd4095e985d5963c7", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -20944,6 +20944,13 @@ arm_vector_mode_supported_p (enum machine_mode mode)\n   return false;\n }\n \n+/* Implements target hook small_register_classes_for_mode_p.  */\n+bool\n+arm_small_register_classes_for_mode_p (enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return TARGET_THUMB1;\n+}\n+\n /* Implement TARGET_SHIFT_TRUNCATION_MASK.  SImode shifts use normal\n    ARM insns and therefore guarantee that the shift count is modulo 256.\n    DImode shifts (those implemented by lib1funcs.asm or by optabs.c)"}, {"sha": "b672535c1c84637df505e854ac4292009786a1d9", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -1267,11 +1267,12 @@ enum reg_class\n    instead of BASE_REGS.  */\n #define MODE_BASE_REG_REG_CLASS(MODE) BASE_REG_CLASS\n \n-/* When SMALL_REGISTER_CLASSES is nonzero, the compiler allows\n+/* When this hook returns true for MODE, the compiler allows\n    registers explicitly used in the rtl to be used as spill registers\n    but prevents the compiler from extending the lifetime of these\n    registers.  */\n-#define SMALL_REGISTER_CLASSES   TARGET_THUMB1\n+#define TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P \\\n+  arm_small_register_classes_for_mode_p \n \n /* Given an rtx X being reloaded into a reg required to be\n    in class CLASS, return the class of reg to actually use."}, {"sha": "398b412dd911a5821a337c14a31f73b8e12ad6c4", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -333,7 +333,7 @@ enum reg_class {\n \n #define PREFERRED_RELOAD_CLASS(X, CLASS) preferred_reload_class(X,CLASS)\n \n-#define SMALL_REGISTER_CLASSES 1\n+#define TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P hook_bool_mode_true\n \n #define CLASS_LIKELY_SPILLED_P(c) class_likely_spilled_p(c)\n "}, {"sha": "a1bd556003e98f7ba83ff2d68932681d9de5260b", "filename": "gcc/config/bfin/bfin.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fbfin%2Fbfin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fbfin%2Fbfin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.h?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -756,10 +756,11 @@ enum reg_class\n     MOST_REGS, AREGS, CCREGS, LIM_REG_CLASSES\t\t\\\n }\n \n-/* When defined, the compiler allows registers explicitly used in the\n-   rtl to be used as spill registers but prevents the compiler from\n-   extending the lifetime of these registers. */\n-#define SMALL_REGISTER_CLASSES 1\n+/* When this hook returns true for MODE, the compiler allows\n+   registers explicitly used in the rtl to be used as spill registers\n+   but prevents the compiler from extending the lifetime of these\n+   registers.  */\n+#define TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P hook_bool_mode_true\n \n #define CLASS_LIKELY_SPILLED_P(CLASS) \\\n     ((CLASS) == PREGS_CLOBBERED \\"}, {"sha": "1ce1585544efc1fdafc67bbad177bcfb16f264d4", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -608,11 +608,11 @@ enum reg_class {\n \n #define FUNCTION_ARG_REGNO_P(N) (TARGET_QUICKCALL ? N < 3 : 0)\n \n-/* When defined, the compiler allows registers explicitly used in the\n-   rtl to be used as spill registers but prevents the compiler from\n-   extending the lifetime of these registers.  */\n-\n-#define SMALL_REGISTER_CLASSES 1\n+/* When this hook returns true for MODE, the compiler allows\n+   registers explicitly used in the rtl to be used as spill registers\n+   but prevents the compiler from extending the lifetime of these\n+   registers.  */\n+#define TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P hook_bool_mode_true\n \f\n /* Define a data type for recording info about an argument list\n    during the scan of that argument list.  This data type should"}, {"sha": "18e3eb3b45ad6f75e99515711aa4131b827fb631", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -1296,11 +1296,11 @@ enum reg_class\n \n #define REGNO_REG_CLASS(REGNO) (regclass_map[REGNO])\n \n-/* When defined, the compiler allows registers explicitly used in the\n-   rtl to be used as spill registers but prevents the compiler from\n-   extending the lifetime of these registers.  */\n-\n-#define SMALL_REGISTER_CLASSES 1\n+/* When this hook returns true for MODE, the compiler allows\n+   registers explicitly used in the rtl to be used as spill registers\n+   but prevents the compiler from extending the lifetime of these\n+   registers.  */\n+#define TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P hook_bool_mode_true\n \n #define QI_REG_P(X) (REG_P (X) && REGNO (X) <= BX_REG)\n "}, {"sha": "fe97f206f96246c6a6e0da76b77f54779b5d36a4", "filename": "gcc/config/iq2000/iq2000.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.h?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -247,8 +247,6 @@ enum reg_class\n \t ? (GR_REGS)\t\t\t\t\t\t\\\n \t : (CLASS))))\n \n-#define SMALL_REGISTER_CLASSES 0\n-\n #define CLASS_MAX_NREGS(CLASS, MODE)    \\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n "}, {"sha": "85dc2d1dce29c0be8c6779a57a8510fca5b1f5b8", "filename": "gcc/config/m32c/m32c.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fm32c%2Fm32c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fm32c%2Fm32c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.h?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -421,7 +421,7 @@ enum reg_class\n \n #define SECONDARY_RELOAD_CLASS(CLASS,MODE,X) m32c_secondary_reload_class (CLASS, MODE, X)\n \n-#define SMALL_REGISTER_CLASSES 1\n+#define TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P hook_bool_mode_true\n \n #define CLASS_LIKELY_SPILLED_P(C) m32c_class_likely_spilled_p (C)\n "}, {"sha": "b9626e1ecca6545e456e7207ff1ed9ee632dfaa9", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -707,7 +707,7 @@ extern enum reg_class m68hc11_tmp_regs_class;\n \n #define PREFERRED_RELOAD_CLASS(X,CLASS)\tpreferred_reload_class(X,CLASS)\n \n-#define SMALL_REGISTER_CLASSES 1\n+#define TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P hook_bool_mode_true\n \n /* A C expression that is nonzero if hard register number REGNO2 can be\n    considered for use as a rename register for REGNO1 */"}, {"sha": "8167400633f47ae04f7b8829c1ad91b20f9a54a0", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -406,10 +406,11 @@ enum reg_class\n extern const enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n #define REGNO_REG_CLASS(REGNO) regno_reg_class[REGNO]\n \n-/* When defined, the compiler allows registers explicitly used in the\n-   rtl to be used as spill registers but prevents the compiler from\n-   extending the lifetime of these registers.  */\n-#define SMALL_REGISTER_CLASSES 1\n+/* When this hook returns true for MODE, the compiler allows\n+   registers explicitly used in the rtl to be used as spill registers\n+   but prevents the compiler from extending the lifetime of these\n+   registers.  */\n+#define TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P hook_bool_mode_true\n  \n /* The class value for index registers, and the one for base regs.  */\n #define INDEX_REG_CLASS  NO_REGS"}, {"sha": "89a000728391b3f301d5ef503046a82ba7678e77", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -291,6 +291,7 @@ extern rtx mips_function_value (const_tree, const_tree, enum machine_mode);\n \n extern bool mips_cannot_change_mode_class (enum machine_mode,\n \t\t\t\t\t   enum machine_mode, enum reg_class);\n+extern bool mips_small_register_classes_for_mode_p (enum machine_mode);\n extern bool mips_dangerous_for_la25_p (rtx);\n extern bool mips_modes_tieable_p (enum machine_mode, enum machine_mode);\n extern enum reg_class mips_preferred_reload_class (rtx, enum reg_class);"}, {"sha": "e246981222e7d7dc242007d6c969208901bb9506", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -10718,6 +10718,15 @@ mips_cannot_change_mode_class (enum machine_mode from ATTRIBUTE_UNUSED,\n   return reg_classes_intersect_p (FP_REGS, rclass);\n }\n \n+/* Implement target hook small_register_classes_for_mode_p.  */\n+\n+static bool\n+mips_small_register_classes_for_mode_p (enum machine_mode mode\n+\t\t\t\t\tATTRIBUTE_UNUSED)\n+{\n+  return TARGET_MIPS16;\n+}\n+\n /* Return true if moves in mode MODE can use the FPU's mov.fmt instruction.  */\n \n static bool"}, {"sha": "d5c98a6ffb89d026ca4e23f3b2c074ce2af5af90", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -2006,12 +2006,12 @@ enum reg_class\n \n #define INDEX_REG_CLASS NO_REGS\n \n-/* When SMALL_REGISTER_CLASSES is nonzero, the compiler allows\n+/* When this hook returns true for MODE, the compiler allows\n    registers explicitly used in the rtl to be used as spill registers\n    but prevents the compiler from extending the lifetime of these\n    registers.  */\n-\n-#define SMALL_REGISTER_CLASSES (TARGET_MIPS16)\n+#define TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P \\\n+  mips_small_register_classes_for_mode_p\n \n /* We generally want to put call-clobbered registers ahead of\n    call-saved ones.  (IRA expects this.)  */"}, {"sha": "12e7861201430d87937490b068d79cd9c7a97936", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -237,7 +237,7 @@ extern enum processor_type mn10300_processor;\n \n /* 4 data, and effectively 3 address registers is small as far as I'm\n    concerned.  */\n-#define SMALL_REGISTER_CLASSES 1\n+#define TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P hook_bool_mode_true\n \f\n /* Define the classes of registers for register constraints in the\n    machine description.  Also define ranges of constants."}, {"sha": "a08f7239e10f7bd613236b59512602e0ef8cc11c", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -290,7 +290,7 @@ enum reg_class { NO_REGS, MUL_REGS, GENERAL_REGS, LOAD_FPU_REGS, NO_LOAD_FPU_REG\n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n /* have to allow this till cmpsi/tstsi are fixed in a better way !! */\n-#define SMALL_REGISTER_CLASSES 1\n+#define TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P hook_bool_mode_true\n \n /* Since GENERAL_REGS is the same class as ALL_REGS,\n    don't give it a different class number; just make it an alias.  */"}, {"sha": "8be66b53d9b18e7f8f7291a6fd23aa21e30699ff", "filename": "gcc/config/rx/rx.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Frx%2Frx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Frx%2Frx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.h?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -196,7 +196,6 @@ enum reg_class\n     GR_REGS, LIM_REG_CLASSES\t\t\t\t\\\n   }\n \n-#define SMALL_REGISTER_CLASSES \t\t0\n #define N_REG_CLASSES\t\t\t(int) LIM_REG_CLASSES\n #define CLASS_MAX_NREGS(CLASS, MODE)    ((GET_MODE_SIZE (MODE) \\\n \t\t\t\t\t  + UNITS_PER_WORD - 1) \\"}, {"sha": "d59cf6ab1182f61cb4e287c3035e8273a107be72", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -145,6 +145,7 @@ extern int sh_attr_renesas_p (const_tree);\n extern int sh_cfun_attr_renesas_p (void);\n extern bool sh_cannot_change_mode_class\n \t      (enum machine_mode, enum machine_mode, enum reg_class);\n+extern bool sh_small_register_classes_for_mode_p (enum machine_mode);\n extern void sh_mark_label (rtx, int);\n extern int sh_register_move_cost\n   (enum machine_mode mode, enum reg_class, enum reg_class);"}, {"sha": "c3293fe05a572afb3887355ca9c65eedf07ef5f8", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -865,7 +865,7 @@ sh_override_options (void)\n       || (TARGET_SHMEDIA && !TARGET_PT_FIXED))\n     flag_no_function_cse = 1;\n \n-  if (SMALL_REGISTER_CLASSES)\n+  if (targetm.small_register_classes_for_mode_p (VOIDmode))\t\t\\\n     {\n       /* Never run scheduling before reload, since that can\n \t break global alloc, and generates slower code anyway due\n@@ -9311,7 +9311,7 @@ get_free_reg (HARD_REG_SET regs_live)\n   if (! TEST_HARD_REG_BIT (regs_live, 1))\n     return gen_rtx_REG (Pmode, 1);\n \n-  /* Hard reg 1 is live; since this is a SMALL_REGISTER_CLASSES target,\n+  /* Hard reg 1 is live; since this is a small register classes target,\n      there shouldn't be anything but a jump before the function end.  */\n   gcc_assert (!TEST_HARD_REG_BIT (regs_live, 7));\n   return gen_rtx_REG (Pmode, 7);\n@@ -11252,6 +11252,14 @@ sh_cannot_change_mode_class (enum machine_mode from, enum machine_mode to,\n   return 0;\n }\n \n+/* Return true if registers in machine mode MODE will likely be\n+   allocated to registers in small register classes.  */\n+\n+static bool\n+sh_small_register_classes_for_mode_p (enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return (! TARGET_SHMEDIA);\n+}\n \n /* If ADDRESS refers to a CODE_LABEL, add NUSES to the number of times\n    that label is used.  */"}, {"sha": "4eb8f397ef97a0eee4c689f10b138aeca7f109e9", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -1209,11 +1209,12 @@ extern enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n   FPUL_REGS, LIM_REG_CLASSES\t\t\t\t\t\t     \\\n }\n \n-/* When defined, the compiler allows registers explicitly used in the\n-   rtl to be used as spill registers but prevents the compiler from\n-   extending the lifetime of these registers.  */\n-\n-#define SMALL_REGISTER_CLASSES (! TARGET_SHMEDIA)\n+/* When this hook returns true for MODE, the compiler allows\n+   registers explicitly used in the rtl to be used as spill registers\n+   but prevents the compiler from extending the lifetime of these\n+   registers.  */\n+#define TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P \\\n+  sh_small_register_classes_for_mode_p\n \n /* The order in which register should be allocated.  */\n /* Sometimes FP0_REGS becomes the preferred class of a floating point pseudo,"}, {"sha": "80c296d930ffe58d24d53c6ceddada1fa1d12aa1", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -477,10 +477,10 @@ extern const enum reg_class xtensa_regno_to_class[FIRST_PSEUDO_REGISTER];\n #define BASE_REG_CLASS AR_REGS\n #define INDEX_REG_CLASS NO_REGS\n \n-/* SMALL_REGISTER_CLASSES is required for Xtensa, because all of the\n-   16 AR registers may be explicitly used in the RTL, as either\n-   incoming or outgoing arguments.  */\n-#define SMALL_REGISTER_CLASSES 1\n+/* The small_register_classes_for_mode_p hook must always return true for\n+   Xtrnase, because all of the 16 AR registers may be explicitly used in\n+   the RTL, as either incoming or outgoing arguments.  */\n+#define TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P hook_bool_mode_true\n \n #define PREFERRED_RELOAD_CLASS(X, CLASS)\t\t\t\t\\\n   xtensa_preferred_reload_class (X, CLASS, 0)"}, {"sha": "98ef8d93d3cf3cf16d5d9fb2ad9936785014a347", "filename": "gcc/cse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -686,7 +686,7 @@ approx_reg_cost_1 (rtx *xp, void *data)\n \t{\n \t  if (regno < FIRST_PSEUDO_REGISTER)\n \t    {\n-\t      if (SMALL_REGISTER_CLASSES)\n+\t      if (targetm.small_register_classes_for_mode_p (GET_MODE (x)))\n \t\treturn 1;\n \t      *cost_p += 2;\n \t    }\n@@ -2304,7 +2304,7 @@ hash_rtx_cb (const_rtx x, enum machine_mode mode,\n \t      record = true;\n \t    else if (GET_MODE_CLASS (GET_MODE (x)) == MODE_CC)\n \t      record = true;\n-\t    else if (SMALL_REGISTER_CLASSES)\n+\t    else if (targetm.small_register_classes_for_mode_p (GET_MODE (x)))\n \t      record = false;\n \t    else if (CLASS_LIKELY_SPILLED_P (REGNO_REG_CLASS (regno)))\n \t      record = false;"}, {"sha": "3a36314d00fcfe4a5208a18e8e127d2449c0aefe", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 32, "deletions": 19, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -2868,25 +2868,6 @@ Do not define this macro if you do not define\n is @code{BITS_PER_WORD} bits wide is correct for your machine.\n @end defmac\n \n-@defmac SMALL_REGISTER_CLASSES\n-On some machines, it is risky to let hard registers live across arbitrary\n-insns.  Typically, these machines have instructions that require values\n-to be in specific registers (like an accumulator), and reload will fail\n-if the required hard register is used for another purpose across such an\n-insn.\n-\n-Define @code{SMALL_REGISTER_CLASSES} to be an expression with a nonzero\n-value on these machines.  When this macro has a nonzero value, the\n-compiler will try to minimize the lifetime of hard registers.\n-\n-It is always safe to define this macro with a nonzero value, but if you\n-unnecessarily define it, you will reduce the amount of optimizations\n-that can be performed in some cases.  If you do not define this macro\n-with a nonzero value when it is required, the compiler will run out of\n-spill registers and print a fatal error message.  For most machines, you\n-should not define this macro at all.\n-@end defmac\n-\n @defmac CLASS_LIKELY_SPILLED_P (@var{class})\n A C expression whose value is nonzero if pseudos that have been assigned\n to registers of class @var{class} would likely be spilled because\n@@ -4360,6 +4341,38 @@ insns involving vector mode @var{mode}.  At the very least, it\n must have move patterns for this mode.\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P (enum machine_mode @var{mode})\n+Define this to return nonzero for machine modes for which the port has\n+small register classes.  If this target hook returns nonzero for a given\n+@var{mode}, the compiler will try to minimize the lifetime of registers\n+in @var{mode}.  The hook may be called with @code{VOIDmode} as argument.\n+In this case, the hook is expected to return nonzero if it returns nonzero\n+for any mode.\n+\n+On some machines, it is risky to let hard registers live across arbitrary\n+insns.  Typically, these machines have instructions that require values\n+to be in specific registers (like an accumulator), and reload will fail\n+if the required hard register is used for another purpose across such an\n+insn.\n+\n+Passes before reload do not know which hard registers will be used\n+in an instruction, but the machine modes of the registers set or used in\n+the instruction are already known.  And for some machines, register\n+classes are small for, say, integer registers but not for floating point\n+registers.  For example, the AMD x86-64 architecture requires specific\n+registers for the legacy x86 integer instructions, but there are many\n+SSE registers for floating point operations.  On such targets, a good\n+strategy may be to return nonzero from this hook for @code{INTEGRAL_MODE_P}\n+machine modes but zero for the SSE register classes.\n+\n+The default version of this hook retuns false for any mode.  It is always\n+safe to redefine this hook to return with a nonzero value.  But if you\n+unnecessarily define it, you will reduce the amount of optimizations\n+that can be performed in some cases.  If you do not define this hook\n+to return a nonzero value when it is required, the compiler will run out\n+of spill registers and print a fatal error message.\n+@end deftypefn\n+\n @node Scalar Return\n @subsection How Scalar Function Values Are Returned\n @cindex return values in registers"}, {"sha": "033ec54f380f4db0229a5d7309a47458e4ac5d81", "filename": "gcc/gcse.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -3479,10 +3479,10 @@ insert_insn_end_basic_block (struct expr *expr, basic_block bb, int pre)\n \t   && (!single_succ_p (bb)\n \t       || single_succ_edge (bb)->flags & EDGE_ABNORMAL))\n     {\n-      /* Keeping in mind SMALL_REGISTER_CLASSES and parameters in registers,\n-\t we search backward and place the instructions before the first\n-\t parameter is loaded.  Do this for everyone for consistency and a\n-\t presumption that we'll get better code elsewhere as well.\n+      /* Keeping in mind targets with small register classes and parameters\n+         in registers, we search backward and place the instructions before\n+\t the first parameter is loaded.  Do this for everyone for consistency\n+\t and a presumption that we'll get better code elsewhere as well.\n \n \t It should always be the case that we can put these instructions\n \t anywhere in the basic block with performing PRE optimizations."}, {"sha": "aac44485898f0a794144d58121e63e63ea814ec7", "filename": "gcc/hooks.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -70,6 +70,13 @@ hook_bool_mode_false (enum machine_mode mode ATTRIBUTE_UNUSED)\n   return false;\n }\n \n+/* Generic hook that takes (enum machine_mode) and returns true.  */\n+bool\n+hook_bool_mode_true (enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return true;\n+}\n+\n /* Generic hook that takes (enum machine_mode, rtx) and returns false.  */\n bool\n hook_bool_mode_const_rtx_false (enum machine_mode mode ATTRIBUTE_UNUSED,"}, {"sha": "5fd8296c75a507a905d717ec64820f201619e089", "filename": "gcc/hooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -30,6 +30,7 @@ extern bool hook_bool_void_true (void);\n extern bool hook_bool_bool_false (bool);\n extern bool hook_bool_const_int_const_int_true (const int, const int);\n extern bool hook_bool_mode_false (enum machine_mode);\n+extern bool hook_bool_mode_true (enum machine_mode);\n extern bool hook_bool_mode_const_rtx_false (enum machine_mode, const_rtx);\n extern bool hook_bool_mode_const_rtx_true (enum machine_mode, const_rtx);\n extern bool hook_bool_tree_false (tree);"}, {"sha": "18c771bf51e3b0644ca9e65c1e499ba35d854fb0", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -2405,8 +2405,8 @@ noce_process_if_block (struct noce_if_info *if_info)\n      the lifetime of hard registers on small register class machines.  */\n   orig_x = x;\n   if (!REG_P (x)\n-      || (SMALL_REGISTER_CLASSES\n-\t  && REGNO (x) < FIRST_PSEUDO_REGISTER))\n+      || (HARD_REGISTER_P (x)\n+\t  && targetm.small_register_classes_for_mode_p (GET_MODE (x))))\n     {\n       if (GET_MODE (x) == BLKmode)\n \treturn FALSE;\n@@ -2605,7 +2605,8 @@ check_cond_move_block (basic_block bb, rtx *vals, VEC (int, heap) **regs,\n       dest = SET_DEST (set);\n       src = SET_SRC (set);\n       if (!REG_P (dest)\n-\t  || (SMALL_REGISTER_CLASSES && HARD_REGISTER_P (dest)))\n+\t  || (HARD_REGISTER_P (dest)\n+\t      && targetm.small_register_classes_for_mode_p (GET_MODE (dest))))\n \treturn FALSE;\n \n       if (!CONSTANT_P (src) && !register_operand (src, VOIDmode))\n@@ -4061,7 +4062,8 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \n       /* For small register class machines, don't lengthen lifetimes of\n \t hard registers before reload.  */\n-      if (SMALL_REGISTER_CLASSES && ! reload_completed)\n+      if (! reload_completed\n+\t  && targetm.small_register_classes_for_mode_p (VOIDmode))\n \t{\n           EXECUTE_IF_SET_IN_BITMAP (merge_set_noclobber, 0, i, bi)\n \t    {"}, {"sha": "c9e947eae6496e14a1ba64bcf4204ea31c030a9a", "filename": "gcc/regmove.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm_p.h\"\n #include \"insn-config.h\"\n #include \"recog.h\"\n+#include \"target.h\"\n #include \"output.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -239,7 +240,7 @@ optimize_reg_copy_1 (rtx insn, rtx dest, rtx src)\n \n   /* We don't want to mess with hard regs if register classes are small.  */\n   if (sregno == dregno\n-      || (SMALL_REGISTER_CLASSES\n+      || (targetm.small_register_classes_for_mode_p (GET_MODE (src))\n \t  && (sregno < FIRST_PSEUDO_REGISTER\n \t      || dregno < FIRST_PSEUDO_REGISTER))\n       /* We don't see all updates to SP if they are in an auto-inc memory"}, {"sha": "01325b09e91bfae97f3edc9c88f78d1eafe74892", "filename": "gcc/regs.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -37,10 +37,6 @@ along with GCC; see the file COPYING3.  If not see\n #define REGMODE_NATURAL_SIZE(MODE)\tUNITS_PER_WORD\n #endif\n \n-#ifndef SMALL_REGISTER_CLASSES\n-#define SMALL_REGISTER_CLASSES 0\n-#endif\n-\n /* Maximum register number used in this function, plus one.  */\n \n extern int max_regno;"}, {"sha": "ac2fa46cb40bad873564d0e54bad6c3074eb3fc2", "filename": "gcc/reload.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -438,7 +438,8 @@ push_secondary_reload (int in_p, rtx x, int opnum, int optional,\n \t    || (! in_p && rld[s_reload].secondary_out_reload == t_reload))\n \t&& ((in_p && rld[s_reload].secondary_in_icode == t_icode)\n \t    || (! in_p && rld[s_reload].secondary_out_icode == t_icode))\n-\t&& (SMALL_REGISTER_CLASS_P (rclass) || SMALL_REGISTER_CLASSES)\n+\t&& (SMALL_REGISTER_CLASS_P (rclass)\n+\t    || targetm.small_register_classes_for_mode_p (VOIDmode))\n \t&& MERGABLE_RELOADS (secondary_type, rld[s_reload].when_needed,\n \t\t\t     opnum, rld[s_reload].opnum))\n       {\n@@ -731,9 +732,9 @@ find_reusable_reload (rtx *p_in, rtx out, enum reg_class rclass,\n      and the other is at worst neutral.\n      (A zero compared against anything is neutral.)\n \n-     If SMALL_REGISTER_CLASSES, don't use existing reloads unless they are\n-     for the same thing since that can cause us to need more reload registers\n-     than we otherwise would.  */\n+     For targets with small register classes, don't use existing reloads\n+     unless they are for the same thing since that can cause us to need\n+     more reload registers than we otherwise would.  */\n \n   for (i = 0; i < n_reloads; i++)\n     if ((reg_class_subset_p (rclass, rld[i].rclass)\n@@ -747,7 +748,8 @@ find_reusable_reload (rtx *p_in, rtx out, enum reg_class rclass,\n \t    || (out != 0 && MATCHES (rld[i].out, out)\n \t\t&& (in == 0 || rld[i].in == 0 || MATCHES (rld[i].in, in))))\n \t&& (rld[i].out == 0 || ! earlyclobber_operand_p (rld[i].out))\n-\t&& (SMALL_REGISTER_CLASS_P (rclass) || SMALL_REGISTER_CLASSES)\n+\t&& (SMALL_REGISTER_CLASS_P (rclass)\n+\t    || targetm.small_register_classes_for_mode_p (VOIDmode))\n \t&& MERGABLE_RELOADS (type, rld[i].when_needed, opnum, rld[i].opnum))\n       return i;\n \n@@ -772,7 +774,8 @@ find_reusable_reload (rtx *p_in, rtx out, enum reg_class rclass,\n \t\t&& GET_RTX_CLASS (GET_CODE (in)) == RTX_AUTOINC\n \t\t&& MATCHES (XEXP (in, 0), rld[i].in)))\n \t&& (rld[i].out == 0 || ! earlyclobber_operand_p (rld[i].out))\n-\t&& (SMALL_REGISTER_CLASS_P (rclass) || SMALL_REGISTER_CLASSES)\n+\t&& (SMALL_REGISTER_CLASS_P (rclass)\n+\t    || targetm.small_register_classes_for_mode_p (VOIDmode))\n \t&& MERGABLE_RELOADS (type, rld[i].when_needed,\n \t\t\t     opnum, rld[i].opnum))\n       {\n@@ -1770,7 +1773,7 @@ combine_reloads (void)\n \t    || rtx_equal_p (secondary_memlocs_elim[(int) rld[output_reload].outmode][rld[i].opnum],\n \t\t\t    secondary_memlocs_elim[(int) rld[output_reload].outmode][rld[output_reload].opnum]))\n #endif\n-\t&& (SMALL_REGISTER_CLASSES\n+\t&& (targetm.small_register_classes_for_mode_p (VOIDmode)\n \t    ? (rld[i].rclass == rld[output_reload].rclass)\n \t    : (reg_class_subset_p (rld[i].rclass,\n \t\t\t\t   rld[output_reload].rclass)\n@@ -1794,7 +1797,7 @@ combine_reloads (void)\n \t&& ! reload_inner_reg_of_subreg (rld[i].in, rld[i].inmode,\n \t\t\t\t\t rld[i].when_needed != RELOAD_FOR_INPUT)\n \t&& (reg_class_size[(int) rld[i].rclass]\n-\t    || SMALL_REGISTER_CLASSES)\n+\t    || targetm.small_register_classes_for_mode_p (VOIDmode))\n \t/* We will allow making things slightly worse by combining an\n \t   input and an output, but no worse than that.  */\n \t&& (rld[i].when_needed == RELOAD_FOR_INPUT"}, {"sha": "ce0b602a7cf4a6c87498683c1ab6d4dddf2301cc", "filename": "gcc/reload1.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -4281,7 +4281,7 @@ reload_as_needed (int live_known)\n \t      /* Merge any reloads that we didn't combine for fear of\n \t\t increasing the number of spill registers needed but now\n \t\t discover can be safely merged.  */\n-\t      if (SMALL_REGISTER_CLASSES)\n+\t      if (targetm.small_register_classes_for_mode_p (VOIDmode))\n \t\tmerge_assigned_reloads (insn);\n \n \t      /* Generate the insns to reload operands into or out of\n@@ -6667,10 +6667,11 @@ deallocate_reload_reg (int r)\n   reload_spill_index[r] = -1;\n }\n \f\n-/* If SMALL_REGISTER_CLASSES is nonzero, we may not have merged two\n-   reloads of the same item for fear that we might not have enough reload\n-   registers. However, normally they will get the same reload register\n-   and hence actually need not be loaded twice.\n+/* If the small_register_classes_for_mode_p target hook returns true for\n+   some machine modes, we may not have merged two reloads of the same item\n+   for fear that we might not have enough reload registers.  However,\n+   normally they will get the same reload register and hence actually need\n+   not be loaded twice.\n \n    Here we check for the most common case of this phenomenon: when we have\n    a number of reloads for the same object, each of which were allocated"}, {"sha": "34d20e5f654614e017d9d0697d4583c94e3b9de1", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -3056,8 +3056,8 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn)\n      This insn must be a simple move of a hard reg to a pseudo or\n      vice-versa.\n \n-     We must avoid moving these insns for correctness on\n-     SMALL_REGISTER_CLASS machines, and for special registers like\n+     We must avoid moving these insns for correctness on targets\n+     with small register classes, and for special registers like\n      PIC_OFFSET_TABLE_REGNUM.  For simplicity, extend this to all\n      hard regs for all targets.  */\n "}, {"sha": "1c734369c23dd6ce26952f433959de81a0ab77ea", "filename": "gcc/target-def.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -539,6 +539,10 @@\n #define TARGET_VECTOR_MODE_SUPPORTED_P hook_bool_mode_false\n #endif\n \n+#ifndef TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P\n+#define TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P hook_bool_mode_false\n+#endif\n+\n /* In hooks.c.  */\n #define TARGET_CANNOT_MODIFY_JUMPS_P hook_bool_void_false\n #define TARGET_BRANCH_TARGET_REGISTER_CLASS \\\n@@ -975,6 +979,7 @@\n   TARGET_ADDR_SPACE_HOOKS,\t\t\t\\\n   TARGET_SCALAR_MODE_SUPPORTED_P,\t\t\\\n   TARGET_VECTOR_MODE_SUPPORTED_P,               \\\n+  TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P,\t\\\n   TARGET_RTX_COSTS,\t\t\t\t\\\n   TARGET_ADDRESS_COST,\t\t\t\t\\\n   TARGET_ALLOCATE_INITIAL_VALUE,\t\t\\\n@@ -986,7 +991,7 @@\n   TARGET_MACHINE_DEPENDENT_REORG,\t\t\\\n   TARGET_BUILD_BUILTIN_VA_LIST,\t\t\t\\\n   TARGET_FN_ABI_VA_LIST,\t\t\t\\\n-  TARGET_CANONICAL_VA_LIST_TYPE,\t\t\t\\\n+  TARGET_CANONICAL_VA_LIST_TYPE,\t\t\\\n   TARGET_EXPAND_BUILTIN_VA_START,\t\t\\\n   TARGET_GIMPLIFY_VA_ARG_EXPR,\t\t\t\\\n   TARGET_GET_PCH_VALIDITY,\t\t\t\\"}, {"sha": "6ff7d1d639e0368bea403b721025621cc1524bd1", "filename": "gcc/target.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42db504c2fb2b460e24ca0e73b8559fc33b3cf33/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=42db504c2fb2b460e24ca0e73b8559fc33b3cf33", "patch": "@@ -762,6 +762,12 @@ struct gcc_target\n      for further details.  */\n   bool (* vector_mode_supported_p) (enum machine_mode mode);\n \n+  /* True for MODE if the target expects that registers in this mode will\n+     be allocated to registers in a small register class.  The compiler is\n+     allowed to use registers explicitly used in the rtl as spill registers\n+     but it should prevent extending the lifetime of these registers.  */\n+  bool (* small_register_classes_for_mode_p) (enum machine_mode mode);\n+\n   /* Compute a (partial) cost for rtx X.  Return true if the complete\n      cost has been computed, and false if subexpressions should be\n      scanned.  In either case, *TOTAL contains the cost result.  */"}]}