{"sha": "b67b3838e94c69f500c84ff58ffa44720a0ec79c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY3YjM4MzhlOTRjNjlmNTAwYzg0ZmY1OGZmYTQ0NzIwYTBlYzc5Yw==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-08-09T15:58:04Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-08-09T15:58:04Z"}, "message": "re PR target/39423 ([SH]  performance regression: lost mov @(disp,Rn))\n\n\tPR target/39423\n\t* config/sh/predicates.md (mem_index_disp_operand): New predicate.\n\t* config/sh/sh.md (*movsi_index_disp): Rewrite insns to use the new\n\tmem_index_disp_operand predicate.\n\n\tPR target/39423\n\t* gcc.target/sh/pr39423-1.c: New.\n\nFrom-SVN: r190259", "tree": {"sha": "73061df4766994376ae31743dea39a322ad56681", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73061df4766994376ae31743dea39a322ad56681"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b67b3838e94c69f500c84ff58ffa44720a0ec79c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b67b3838e94c69f500c84ff58ffa44720a0ec79c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b67b3838e94c69f500c84ff58ffa44720a0ec79c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b67b3838e94c69f500c84ff58ffa44720a0ec79c/comments", "author": null, "committer": null, "parents": [{"sha": "78ff60c1ad15e72b056fe888a0b0d509c5e563a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78ff60c1ad15e72b056fe888a0b0d509c5e563a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78ff60c1ad15e72b056fe888a0b0d509c5e563a9"}], "stats": {"total": 227, "additions": 157, "deletions": 70}, "files": [{"sha": "dc96a3bad5821acb80811d82753420141e01f264", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b67b3838e94c69f500c84ff58ffa44720a0ec79c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b67b3838e94c69f500c84ff58ffa44720a0ec79c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b67b3838e94c69f500c84ff58ffa44720a0ec79c", "patch": "@@ -1,3 +1,10 @@\n+2012-08-09  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/39423\n+\t* config/sh/predicates.md (mem_index_disp_operand): New predicate.\n+\t* config/sh/sh.md (*movsi_index_disp): Rewrite insns to use the new\n+\tmem_index_disp_operand predicate.\n+\n 2012-08-09  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/51244"}, {"sha": "209ff29e8b600e0b25e81afa40fdab8f3f8b21bd", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b67b3838e94c69f500c84ff58ffa44720a0ec79c/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b67b3838e94c69f500c84ff58ffa44720a0ec79c/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=b67b3838e94c69f500c84ff58ffa44720a0ec79c", "patch": "@@ -507,6 +507,31 @@\n   return 0;\n })\n \n+;; Returns 1 if OP is a MEM that can be used in \"index_disp\" combiner\n+;; patterns.\n+(define_predicate \"mem_index_disp_operand\"\n+  (match_code \"mem\")\n+{\n+  rtx plus0_rtx, plus1_rtx, mult_rtx;\n+\n+  plus0_rtx = XEXP (op, 0);\n+  if (GET_CODE (plus0_rtx) != PLUS)\n+    return 0;\n+\n+  plus1_rtx = XEXP (plus0_rtx, 0);\n+  if (GET_CODE (plus1_rtx) != PLUS)\n+    return 0;\n+\n+  mult_rtx = XEXP (plus1_rtx, 0);\n+  if (GET_CODE (mult_rtx) != MULT)\n+    return 0;\n+ \n+  return REG_P (XEXP (mult_rtx, 0)) && CONST_INT_P (XEXP (mult_rtx, 1))\n+\t && exact_log2 (INTVAL (XEXP (mult_rtx, 1))) > 0\n+\t && REG_P (XEXP (plus1_rtx, 1))\n+\t && sh_legitimate_index_p (mode, XEXP (plus0_rtx, 1), TARGET_SH2A, true);\n+})\n+\n ;; TODO: Add a comment here.\n \n (define_predicate \"greater_comparison_operator\""}, {"sha": "e96ff7d40522b1b7b39904ccdb4ef42d84754536", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 72, "deletions": 70, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b67b3838e94c69f500c84ff58ffa44720a0ec79c/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b67b3838e94c69f500c84ff58ffa44720a0ec79c/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=b67b3838e94c69f500c84ff58ffa44720a0ec79c", "patch": "@@ -5119,114 +5119,116 @@ label:\n ;; FIXME: Combine never tries this kind of patterns for DImode.\n (define_insn_and_split \"*movsi_index_disp\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n-\t(mem:SI\n-\t  (plus:SI\n-\t    (plus:SI (mult:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")\n-\t\t\t      (match_operand:SI 2 \"const_int_operand\"))\n-\t\t     (match_operand:SI 3 \"arith_reg_operand\" \"r\"))\n-\t    (match_operand:SI 4 \"const_int_operand\"))))]\n-  \"TARGET_SH1 && sh_legitimate_index_p (SImode, operands[4], TARGET_SH2A, true)\n-   && exact_log2 (INTVAL (operands[2])) > 0\"\n+\t(match_operand:SI 1 \"mem_index_disp_operand\" \"m\"))]\n+  \"TARGET_SH1\"\n   \"#\"\n   \"&& can_create_pseudo_p ()\"\n   [(set (match_dup 5) (ashift:SI (match_dup 1) (match_dup 2)))\n    (set (match_dup 6) (plus:SI (match_dup 5) (match_dup 3)))\n-   (set (match_dup 0) (mem:SI (plus:SI (match_dup 6) (match_dup 4))))]\n+   (set (match_dup 0) (match_dup 7))]\n {\n+  rtx mem = operands[1];\n+  rtx plus0_rtx = XEXP (mem, 0);\n+  rtx plus1_rtx = XEXP (plus0_rtx, 0);\n+  rtx mult_rtx = XEXP (plus1_rtx, 0);\n+\n+  operands[1] = XEXP (mult_rtx, 0);\n+  operands[2] = GEN_INT (exact_log2 (INTVAL (XEXP (mult_rtx, 1))));\n+  operands[3] = XEXP (plus1_rtx, 1);\n+  operands[4] = XEXP (plus0_rtx, 1);\n   operands[5] = gen_reg_rtx (SImode);\n   operands[6] = gen_reg_rtx (SImode);\n-  operands[2] = GEN_INT (exact_log2 (INTVAL (operands[2])));\n+  operands[7] =\n+    replace_equiv_address (mem,\n+\t\t\t   gen_rtx_PLUS (SImode, operands[6], operands[4]));\n })\n \n (define_insn_and_split \"*movhi_index_disp\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n-\t(sign_extend:SI\n-\t  (mem:HI\n-\t    (plus:SI\n-\t      (plus:SI (mult:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")\n-\t\t\t\t(match_operand:SI 2 \"const_int_operand\"))\n-\t\t       (match_operand:SI 3 \"arith_reg_operand\" \"r\"))\n-\t      (match_operand:SI 4 \"const_int_operand\")))))]\n-  \"TARGET_SH1 && sh_legitimate_index_p (HImode, operands[4], TARGET_SH2A, true)\n-   && exact_log2 (INTVAL (operands[2])) > 0\"\n+\t(sign_extend:SI (match_operand:HI 1 \"mem_index_disp_operand\" \"m\")))]\n+  \"TARGET_SH1\"\n   \"#\"\n   \"&& can_create_pseudo_p ()\"\n   [(set (match_dup 5) (ashift:SI (match_dup 1) (match_dup 2)))\n    (set (match_dup 6) (plus:SI (match_dup 5) (match_dup 3)))\n-   (set (match_dup 0)\n-\t(sign_extend:SI (mem:HI (plus:SI (match_dup 6) (match_dup 4)))))]\n+   (set (match_dup 0) (sign_extend:SI (match_dup 7)))]\n {\n+  rtx mem = operands[1];\n+  rtx plus0_rtx = XEXP (mem, 0);\n+  rtx plus1_rtx = XEXP (plus0_rtx, 0);\n+  rtx mult_rtx = XEXP (plus1_rtx, 0);\n+\n+  operands[1] = XEXP (mult_rtx, 0);\n+  operands[2] = GEN_INT (exact_log2 (INTVAL (XEXP (mult_rtx, 1))));\n+  operands[3] = XEXP (plus1_rtx, 1);\n+  operands[4] = XEXP (plus0_rtx, 1);\n   operands[5] = gen_reg_rtx (SImode);\n   operands[6] = gen_reg_rtx (SImode);\n-  operands[2] = GEN_INT (exact_log2 (INTVAL (operands[2])));\n+  operands[7] =\n+    replace_equiv_address (mem,\n+\t\t\t   gen_rtx_PLUS (SImode, operands[6], operands[4]));\n })\n \n-(define_insn_and_split \"*movhi_index_disp\"\n-  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n-\t(zero_extend:SI\n-\t  (mem:HI\n-\t    (plus:SI\n-\t      (plus:SI (mult:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")\n-\t\t\t\t(match_operand:SI 2 \"const_int_operand\"))\n-\t\t       (match_operand:SI 3 \"arith_reg_operand\" \"r\"))\n-\t      (match_operand:SI 4 \"const_int_operand\")))))]\n-  \"TARGET_SH1 && sh_legitimate_index_p (HImode, operands[4], TARGET_SH2A, true)\n-   && exact_log2 (INTVAL (operands[2])) > 0\"\n-  \"#\"\n-  \"&& can_create_pseudo_p ()\"\n-  [(set (match_dup 5) (ashift:SI (match_dup 1) (match_dup 2)))\n-   (set (match_dup 6) (plus:SI (match_dup 5) (match_dup 3)))\n-   (set (match_dup 7)\n-\t(sign_extend:SI (mem:HI (plus:SI (match_dup 6) (match_dup 4)))))\n-   (set (match_dup 0) (zero_extend:SI (match_dup 8)))]\n+(define_split\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(zero_extend:SI (match_operand:HI 1 \"mem_index_disp_operand\")))]\n+  \"TARGET_SH1\"\n+  [(set (match_dup 0) (sign_extend:SI (match_dup 1)))\n+   (set (match_dup 0) (zero_extend:SI (match_dup 2)))]\n {\n-  operands[5] = gen_reg_rtx (SImode);\n-  operands[6] = gen_reg_rtx (SImode);\n-  operands[7] = gen_reg_rtx (SImode);\n-  operands[8] = gen_lowpart (HImode, operands[7]);\n-  operands[2] = GEN_INT (exact_log2 (INTVAL (operands[2])));\n+  operands[2] = gen_lowpart (HImode, operands[0]);\n })\n \n (define_insn_and_split \"*movsi_index_disp\"\n-  [(set (mem:SI\n-\t  (plus:SI\n-\t    (plus:SI (mult:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")\n-\t\t\t      (match_operand:SI 2 \"const_int_operand\"))\n-\t\t     (match_operand:SI 3 \"arith_reg_operand\" \"r\"))\n-\t  (match_operand:SI 4 \"const_int_operand\")))\n-\t(match_operand:SI 0 \"arith_reg_operand\" \"r\"))]\n-  \"TARGET_SH1 && sh_legitimate_index_p (SImode, operands[4], TARGET_SH2A, true)\n-   && exact_log2 (INTVAL (operands[2])) > 0\"\n+  [(set (match_operand:SI 0 \"mem_index_disp_operand\" \"=m\")\n+\t(match_operand:SI 1 \"arith_reg_operand\" \"r\"))]\n+  \"TARGET_SH1\"\n   \"#\"\n   \"&& can_create_pseudo_p ()\"\n-  [(set (match_dup 5) (ashift:SI (match_dup 1) (match_dup 2)))\n+  [(set (match_dup 5) (ashift:SI (match_dup 0) (match_dup 2)))\n    (set (match_dup 6) (plus:SI (match_dup 5) (match_dup 3)))\n-   (set (mem:SI (plus:SI (match_dup 6) (match_dup 4))) (match_dup 0))]\n+   (set (match_dup 7) (match_dup 1))]\n {\n+  rtx mem = operands[0];\n+  rtx plus0_rtx = XEXP (mem, 0);\n+  rtx plus1_rtx = XEXP (plus0_rtx, 0);\n+  rtx mult_rtx = XEXP (plus1_rtx, 0);\n+\n+  operands[0] = XEXP (mult_rtx, 0);\n+  operands[2] = GEN_INT (exact_log2 (INTVAL (XEXP (mult_rtx, 1))));\n+  operands[3] = XEXP (plus1_rtx, 1);\n+  operands[4] = XEXP (plus0_rtx, 1);\n   operands[5] = gen_reg_rtx (SImode);\n   operands[6] = gen_reg_rtx (SImode);\n-  operands[2] = GEN_INT (exact_log2 (INTVAL (operands[2])));\n+  operands[7] =\n+    replace_equiv_address (mem,\n+\t\t\t   gen_rtx_PLUS (SImode, operands[6], operands[4]));\n })\n \n-(define_insn_and_split \"*movhi_index_disp\"\n-  [(set (mem:HI\n-\t  (plus:SI\n-\t    (plus:SI (mult:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")\n-\t\t\t      (match_operand:SI 2 \"const_int_operand\"))\n-\t\t     (match_operand:SI 3 \"arith_reg_operand\" \"r\"))\n-\t  (match_operand:SI 4 \"const_int_operand\")))\n-\t(match_operand:HI 0 \"arith_reg_operand\" \"r\"))]\n-  \"TARGET_SH1 && sh_legitimate_index_p (HImode, operands[4], TARGET_SH2A, true)\n-   && exact_log2 (INTVAL (operands[2])) > 0\"\n+(define_insn_and_split \"*movsi_index_disp\"\n+  [(set (match_operand:HI 0 \"mem_index_disp_operand\" \"=m\")\n+\t(match_operand:HI 1 \"arith_reg_operand\" \"r\"))]\n+  \"TARGET_SH1\"\n   \"#\"\n   \"&& can_create_pseudo_p ()\"\n-  [(set (match_dup 5) (ashift:SI (match_dup 1) (match_dup 2)))\n+  [(set (match_dup 5) (ashift:SI (match_dup 0) (match_dup 2)))\n    (set (match_dup 6) (plus:SI (match_dup 5) (match_dup 3)))\n-   (set (mem:HI (plus:SI (match_dup 6) (match_dup 4))) (match_dup 0))]\n+   (set (match_dup 7) (match_dup 1))]\n {\n+  rtx mem = operands[0];\n+  rtx plus0_rtx = XEXP (mem, 0);\n+  rtx plus1_rtx = XEXP (plus0_rtx, 0);\n+  rtx mult_rtx = XEXP (plus1_rtx, 0);\n+\n+  operands[0] = XEXP (mult_rtx, 0);\n+  operands[2] = GEN_INT (exact_log2 (INTVAL (XEXP (mult_rtx, 1))));\n+  operands[3] = XEXP (plus1_rtx, 1);\n+  operands[4] = XEXP (plus0_rtx, 1);\n   operands[5] = gen_reg_rtx (SImode);\n   operands[6] = gen_reg_rtx (SImode);\n-  operands[2] = GEN_INT (exact_log2 (INTVAL (operands[2])));\n+  operands[7] =\n+    replace_equiv_address (mem,\n+\t\t\t   gen_rtx_PLUS (SImode, operands[6], operands[4]));\n })\n \n ;; Define additional pop for SH1 and SH2 so it does not get "}, {"sha": "790921fc14bb891cccfefe310d36805a2b85e2c7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b67b3838e94c69f500c84ff58ffa44720a0ec79c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b67b3838e94c69f500c84ff58ffa44720a0ec79c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b67b3838e94c69f500c84ff58ffa44720a0ec79c", "patch": "@@ -1,3 +1,8 @@\n+2012-08-09  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/39423\n+\t* gcc.target/sh/pr39423-1.c: New.\n+\n 2012-08-09  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/51244"}, {"sha": "dac0f89eea3346a8ccf24488b28caee0bb6f0df2", "filename": "gcc/testsuite/gcc.target/sh/pr39423-1.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b67b3838e94c69f500c84ff58ffa44720a0ec79c/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr39423-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b67b3838e94c69f500c84ff58ffa44720a0ec79c/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr39423-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr39423-1.c?ref=b67b3838e94c69f500c84ff58ffa44720a0ec79c", "patch": "@@ -0,0 +1,48 @@\n+/* Check that displacement addressing is used for indexed addresses with a\n+   small offset, instead of re-calculating the index.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\"} { \"\" } } */\n+/* { dg-final { scan-assembler-not \"add\\t#1\" } } */\n+\n+int\n+test_00 (int tab[], int index)\n+{\n+  return tab[index + 1];\n+}\n+\n+int\n+test_01 (short tab[], int index)\n+{\n+  return tab[index + 1];\n+}\n+\n+int\n+test_02 (unsigned short tab[], int index)\n+{\n+  return tab[index + 1];\n+}\n+\n+int\n+test_03 (long long tab[], int index)\n+{\n+  return (int)tab[index + 1];\n+}\n+\n+void\n+test_04 (int tab[], int index, int val)\n+{\n+  tab[index + 1] = val;\n+}\n+\n+void\n+test_05 (short tab[], int index, int val)\n+{\n+  tab[index + 1] = (short)val;\n+}\n+\n+void\n+test_06 (unsigned short tab[], int index, int val)\n+{\n+  tab[index + 1] = (unsigned short)val;\n+}"}]}