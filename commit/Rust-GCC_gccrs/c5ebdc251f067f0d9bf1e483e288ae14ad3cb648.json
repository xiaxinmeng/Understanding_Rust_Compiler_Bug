{"sha": "c5ebdc251f067f0d9bf1e483e288ae14ad3cb648", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVlYmRjMjUxZjA2N2YwZDliZjFlNDgzZTI4OGFlMTRhZDNjYjY0OA==", "commit": {"author": {"name": "Dimitrios Apostolou", "email": "jimis@gmx.net", "date": "2012-05-26T11:44:50Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2012-05-26T11:44:50Z"}, "message": "df-scan.c (df_def_record_1): Assert a parallel must contain an EXPR_LIST at this point.\n\n2012-05-26  Dimitrios Apostolou  <jimis@gmx.net>\n\t    Paolo Bonzini  <bonzini@gnu.org>\n\n\t* df-scan.c (df_def_record_1): Assert a parallel must contain an\n\tEXPR_LIST at this point.  Receive the LOC and move its extraction...\n\t(df_defs_record): ... here. Change if-else to a switch statement.\n\t(df_find_hard_reg_defs, df_find_hard_reg_defs_1): New.\n\t(df_get_call_refs): Changed defs_generated from bitmap to HARD_REG_SET\n\tand compute it from df_find_hard_reg_defs(). Record DF_REF_BASE\n\tDEFs in REGNO order. Use HARD_REG_SET instead of bitmap for\n\tregs_invalidated_by_call.\n\t(df_insn_refs_collect): Record DF_REF_REGULAR DEFs after\n\tdf_get_call_refs().\n\n\nCo-Authored-By: Paolo Bonzini <bonzini@gnu.org>\n\nFrom-SVN: r187911", "tree": {"sha": "6d0201512cc68742ac9c09ddfe0a89bad96e49d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d0201512cc68742ac9c09ddfe0a89bad96e49d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5ebdc251f067f0d9bf1e483e288ae14ad3cb648", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5ebdc251f067f0d9bf1e483e288ae14ad3cb648", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5ebdc251f067f0d9bf1e483e288ae14ad3cb648", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5ebdc251f067f0d9bf1e483e288ae14ad3cb648/comments", "author": {"login": "jimis", "id": 3584514, "node_id": "MDQ6VXNlcjM1ODQ1MTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3584514?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jimis", "html_url": "https://github.com/jimis", "followers_url": "https://api.github.com/users/jimis/followers", "following_url": "https://api.github.com/users/jimis/following{/other_user}", "gists_url": "https://api.github.com/users/jimis/gists{/gist_id}", "starred_url": "https://api.github.com/users/jimis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jimis/subscriptions", "organizations_url": "https://api.github.com/users/jimis/orgs", "repos_url": "https://api.github.com/users/jimis/repos", "events_url": "https://api.github.com/users/jimis/events{/privacy}", "received_events_url": "https://api.github.com/users/jimis/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "82ea8185b85e13fd59e854bdf4340fda5b39130f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82ea8185b85e13fd59e854bdf4340fda5b39130f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82ea8185b85e13fd59e854bdf4340fda5b39130f"}], "stats": {"total": 244, "additions": 158, "deletions": 86}, "files": [{"sha": "b9e442a359ae2d26c962348b3a279e52d34e23b3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5ebdc251f067f0d9bf1e483e288ae14ad3cb648/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5ebdc251f067f0d9bf1e483e288ae14ad3cb648/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5ebdc251f067f0d9bf1e483e288ae14ad3cb648", "patch": "@@ -1,3 +1,17 @@\n+2012-05-26  Dimitrios Apostolou  <jimis@gmx.net>\n+\t    Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* df-scan.c (df_def_record_1): Assert a parallel must contain an\n+\tEXPR_LIST at this point.  Receive the LOC and move its extraction...\n+\t(df_defs_record): ... here. Change if-else to a switch statement.\n+\t(df_find_hard_reg_defs, df_find_hard_reg_defs_1): New.\n+\t(df_get_call_refs): Changed defs_generated from bitmap to HARD_REG_SET\n+\tand compute it from df_find_hard_reg_defs(). Record DF_REF_BASE\n+\tDEFs in REGNO order. Use HARD_REG_SET instead of bitmap for\n+\tregs_invalidated_by_call.\n+\t(df_insn_refs_collect): Record DF_REF_REGULAR DEFs after\n+\tdf_get_call_refs().\n+\n 2012-05-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR lto/52178"}, {"sha": "9d39700369d661860d291a9d608ff788a000a7da", "filename": "gcc/df-scan.c", "status": "modified", "additions": 144, "deletions": 86, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5ebdc251f067f0d9bf1e483e288ae14ad3cb648/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5ebdc251f067f0d9bf1e483e288ae14ad3cb648/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=c5ebdc251f067f0d9bf1e483e288ae14ad3cb648", "patch": "@@ -111,7 +111,7 @@ static void df_ref_record (enum df_ref_class, struct df_collection_rec *,\n \t\t\t   rtx, rtx *,\n \t\t\t   basic_block, struct df_insn_info *,\n \t\t\t   enum df_ref_type, int ref_flags);\n-static void df_def_record_1 (struct df_collection_rec *, rtx,\n+static void df_def_record_1 (struct df_collection_rec *, rtx *,\n \t\t\t     basic_block, struct df_insn_info *,\n \t\t\t     int ref_flags);\n static void df_defs_record (struct df_collection_rec *, rtx,\n@@ -2917,40 +2917,27 @@ df_read_modify_subreg_p (rtx x)\n }\n \n \n-/* Process all the registers defined in the rtx, X.\n-   Autoincrement/decrement definitions will be picked up by\n-   df_uses_record.  */\n+/* Process all the registers defined in the rtx pointed by LOC.\n+   Autoincrement/decrement definitions will be picked up by df_uses_record.\n+   Any change here has to be matched in df_find_hard_reg_defs_1.  */\n \n static void\n df_def_record_1 (struct df_collection_rec *collection_rec,\n-                 rtx x, basic_block bb, struct df_insn_info *insn_info,\n+                 rtx *loc, basic_block bb, struct df_insn_info *insn_info,\n \t\t int flags)\n {\n-  rtx *loc;\n-  rtx dst;\n-\n- /* We may recursively call ourselves on EXPR_LIST when dealing with PARALLEL\n-     construct.  */\n-  if (GET_CODE (x) == EXPR_LIST || GET_CODE (x) == CLOBBER)\n-    loc = &XEXP (x, 0);\n-  else\n-    loc = &SET_DEST (x);\n-  dst = *loc;\n+  rtx dst = *loc;\n \n   /* It is legal to have a set destination be a parallel. */\n   if (GET_CODE (dst) == PARALLEL)\n     {\n       int i;\n-\n       for (i = XVECLEN (dst, 0) - 1; i >= 0; i--)\n \t{\n \t  rtx temp = XVECEXP (dst, 0, i);\n-\t  if (GET_CODE (temp) == EXPR_LIST || GET_CODE (temp) == CLOBBER\n-\t      || GET_CODE (temp) == SET)\n-\t    df_def_record_1 (collection_rec,\n-                             temp, bb, insn_info,\n-\t\t\t     GET_CODE (temp) == CLOBBER\n-\t\t\t     ? flags | DF_REF_MUST_CLOBBER : flags);\n+\t  gcc_assert (GET_CODE (temp) == EXPR_LIST);\n+\t  df_def_record_1 (collection_rec, &XEXP (temp, 0),\n+\t\t\t   bb, insn_info, flags);\n \t}\n       return;\n     }\n@@ -2996,34 +2983,108 @@ df_def_record_1 (struct df_collection_rec *collection_rec,\n }\n \n \n-/* Process all the registers defined in the pattern rtx, X.  */\n+/* Process all the registers defined in the pattern rtx, X.  Any change\n+   here has to be matched in df_find_hard_reg_defs.  */\n \n static void\n df_defs_record (struct df_collection_rec *collection_rec,\n                 rtx x, basic_block bb, struct df_insn_info *insn_info,\n \t\tint flags)\n {\n   RTX_CODE code = GET_CODE (x);\n+  int i;\n \n-  if (code == SET || code == CLOBBER)\n-    {\n-      /* Mark the single def within the pattern.  */\n-      int clobber_flags = flags;\n-      clobber_flags |= (code == CLOBBER) ? DF_REF_MUST_CLOBBER : 0;\n-      df_def_record_1 (collection_rec, x, bb, insn_info, clobber_flags);\n-    }\n-  else if (code == COND_EXEC)\n+  switch (code)\n     {\n+    case SET:\n+      df_def_record_1 (collection_rec, &SET_DEST (x), bb, insn_info, flags);\n+      break;\n+\n+    case CLOBBER:\n+      flags |= DF_REF_MUST_CLOBBER;\n+      df_def_record_1 (collection_rec, &XEXP (x, 0), bb, insn_info, flags);\n+      break;\n+\n+    case COND_EXEC:\n       df_defs_record (collection_rec, COND_EXEC_CODE (x),\n \t\t      bb, insn_info, DF_REF_CONDITIONAL);\n+      break;\n+\n+    case PARALLEL:\n+      for (i = 0; i < XVECLEN (x, 0); i++)\n+\tdf_defs_record (collection_rec, XVECEXP (x, 0, i),\n+\t\t\tbb, insn_info, flags);\n+      break;\n+    default:\n+      /* No DEFs to record in other cases */\n+      break;\n     }\n-  else if (code == PARALLEL)\n+}\n+\n+/* Set bits in *DEFS for hard registers found in the rtx DST, which is the\n+   destination of a set or clobber.  This has to match the logic in\n+   df_defs_record_1.  */\n+\n+static void\n+df_find_hard_reg_defs_1 (rtx dst, HARD_REG_SET *defs)\n+{\n+  /* It is legal to have a set destination be a parallel. */\n+  if (GET_CODE (dst) == PARALLEL)\n     {\n       int i;\n+      for (i = XVECLEN (dst, 0) - 1; i >= 0; i--)\n+\t{\n+\t  rtx temp = XVECEXP (dst, 0, i);\n+\t  gcc_assert (GET_CODE (temp) == EXPR_LIST);\n+\t  df_find_hard_reg_defs_1 (XEXP (temp, 0), defs);\n+\t}\n+      return;\n+    }\n+\n+  if (GET_CODE (dst) == STRICT_LOW_PART)\n+      dst = XEXP (dst, 0);\n+\n+  if (GET_CODE (dst) == ZERO_EXTRACT)\n+      dst = XEXP (dst, 0);\n+\n+  /* At this point if we do not have a reg or a subreg, just return.  */\n+  if (REG_P (dst) && HARD_REGISTER_P (dst))\n+    SET_HARD_REG_BIT (*defs, REGNO (dst));\n+  else if (GET_CODE (dst) == SUBREG\n+\t   && REG_P (SUBREG_REG (dst)) && HARD_REGISTER_P (dst))\n+    SET_HARD_REG_BIT (*defs, REGNO (SUBREG_REG (dst)));\n+}\n+\n+/* Set bits in *DEFS for hard registers defined in the pattern X.  This\n+   has to match the logic in df_defs_record.  */\n \n-      /* Mark the multiple defs within the pattern.  */\n-      for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n-\tdf_defs_record (collection_rec, XVECEXP (x, 0, i), bb, insn_info, flags);\n+static void\n+df_find_hard_reg_defs (rtx x, HARD_REG_SET *defs)\n+{\n+  RTX_CODE code = GET_CODE (x);\n+  int i;\n+\n+  switch (code)\n+    {\n+    case SET:\n+      df_find_hard_reg_defs_1 (SET_DEST (x), defs);\n+      break;\n+\n+    case CLOBBER:\n+      df_find_hard_reg_defs_1 (XEXP (x, 0), defs);\n+      break;\n+\n+    case COND_EXEC:\n+      df_find_hard_reg_defs (COND_EXEC_CODE (x), defs);\n+      break;\n+\n+    case PARALLEL:\n+      for (i = 0; i < XVECLEN (x, 0); i++)\n+\tdf_find_hard_reg_defs (XVECEXP (x, 0, i), defs);\n+      break;\n+    default:\n+      /* No DEFs to record in other cases */\n+      break;\n     }\n }\n \n@@ -3310,29 +3371,56 @@ df_get_conditional_uses (struct df_collection_rec *collection_rec)\n }\n \n \n-/* Get call's extra defs and uses. */\n+/* Get call's extra defs and uses (track caller-saved registers). */\n \n static void\n-df_get_call_refs (struct df_collection_rec * collection_rec,\n+df_get_call_refs (struct df_collection_rec *collection_rec,\n                   basic_block bb,\n                   struct df_insn_info *insn_info,\n                   int flags)\n {\n   rtx note;\n-  bitmap_iterator bi;\n-  unsigned int ui;\n   bool is_sibling_call;\n   unsigned int i;\n-  df_ref def;\n-  bitmap_head defs_generated;\n+  HARD_REG_SET defs_generated;\n \n-  bitmap_initialize (&defs_generated, &df_bitmap_obstack);\n+  CLEAR_HARD_REG_SET (defs_generated);\n+  df_find_hard_reg_defs (PATTERN (insn_info->insn), &defs_generated);\n+  is_sibling_call = SIBLING_CALL_P (insn_info->insn);\n \n-  /* Do not generate clobbers for registers that are the result of the\n-     call.  This causes ordering problems in the chain building code\n-     depending on which def is seen first.  */\n-  FOR_EACH_VEC_ELT (df_ref, collection_rec->def_vec, i, def)\n-    bitmap_set_bit (&defs_generated, DF_REF_REGNO (def));\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      if (i == STACK_POINTER_REGNUM)\n+\t/* The stack ptr is used (honorarily) by a CALL insn.  */\n+\tdf_ref_record (DF_REF_BASE, collection_rec, regno_reg_rtx[i],\n+\t\t       NULL, bb, insn_info, DF_REF_REG_USE,\n+\t\t       DF_REF_CALL_STACK_USAGE | flags);\n+      else if (global_regs[i])\n+\t{\n+\t  /* Calls to const functions cannot access any global registers and\n+\t     calls to pure functions cannot set them.  All other calls may\n+\t     reference any of the global registers, so they are recorded as\n+\t     used. */\n+\t  if (!RTL_CONST_CALL_P (insn_info->insn))\n+\t    {\n+\t      df_ref_record (DF_REF_BASE, collection_rec, regno_reg_rtx[i],\n+\t\t\t     NULL, bb, insn_info, DF_REF_REG_USE, flags);\n+\t      if (!RTL_PURE_CALL_P (insn_info->insn))\n+\t\tdf_ref_record (DF_REF_BASE, collection_rec, regno_reg_rtx[i],\n+\t\t\t       NULL, bb, insn_info, DF_REF_REG_DEF, flags);\n+\t    }\n+\t}\n+      else if (TEST_HARD_REG_BIT (regs_invalidated_by_call, i)\n+\t       /* no clobbers for regs that are the result of the call */\n+\t       && !TEST_HARD_REG_BIT (defs_generated, i)\n+\t       && (!is_sibling_call\n+\t\t   || !bitmap_bit_p (df->exit_block_uses, i)\n+\t\t   || refers_to_regno_p (i, i+1,\n+\t\t\t\t         crtl->return_rtx, NULL)))\n+\t  df_ref_record (DF_REF_BASE, collection_rec, regno_reg_rtx[i],\n+\t\t\t NULL, bb, insn_info, DF_REF_REG_DEF,\n+\t\t\t DF_REF_MAY_CLOBBER | flags);\n+    }\n \n   /* Record the registers used to pass arguments, and explicitly\n      noted as clobbered.  */\n@@ -3347,7 +3435,7 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n \t  if (REG_P (XEXP (XEXP (note, 0), 0)))\n \t    {\n \t      unsigned int regno = REGNO (XEXP (XEXP (note, 0), 0));\n-\t      if (!bitmap_bit_p (&defs_generated, regno))\n+\t      if (!TEST_HARD_REG_BIT (defs_generated, regno))\n \t\tdf_defs_record (collection_rec, XEXP (note, 0), bb,\n \t\t\t\tinsn_info, flags);\n \t    }\n@@ -3357,40 +3445,6 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n \t}\n     }\n \n-  /* The stack ptr is used (honorarily) by a CALL insn.  */\n-  df_ref_record (DF_REF_BASE, collection_rec, regno_reg_rtx[STACK_POINTER_REGNUM],\n-\t\t NULL, bb, insn_info, DF_REF_REG_USE,\n-\t\t DF_REF_CALL_STACK_USAGE | flags);\n-\n-  /* Calls to const functions cannot access any global registers and calls to\n-     pure functions cannot set them.  All other calls may reference any of the\n-     global registers, so they are recorded as used.  */\n-  if (!RTL_CONST_CALL_P (insn_info->insn))\n-    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-      if (global_regs[i])\n-\t{\n-\t  df_ref_record (DF_REF_BASE, collection_rec, regno_reg_rtx[i],\n-\t\t\t NULL, bb, insn_info, DF_REF_REG_USE, flags);\n-\t  if (!RTL_PURE_CALL_P (insn_info->insn))\n-\t    df_ref_record (DF_REF_BASE, collection_rec, regno_reg_rtx[i],\n-\t\t\t   NULL, bb, insn_info, DF_REF_REG_DEF, flags);\n-\t}\n-\n-  is_sibling_call = SIBLING_CALL_P (insn_info->insn);\n-  EXECUTE_IF_SET_IN_BITMAP (regs_invalidated_by_call_regset, 0, ui, bi)\n-    {\n-      if (!global_regs[ui]\n-\t  && (!bitmap_bit_p (&defs_generated, ui))\n-\t  && (!is_sibling_call\n-\t      || !bitmap_bit_p (df->exit_block_uses, ui)\n-\t      || refers_to_regno_p (ui, ui+1,\n-\t\t\t\t    crtl->return_rtx, NULL)))\n-        df_ref_record (DF_REF_BASE, collection_rec, regno_reg_rtx[ui],\n-\t\t       NULL, bb, insn_info, DF_REF_REG_DEF,\n-\t\t       DF_REF_MAY_CLOBBER | flags);\n-    }\n-\n-  bitmap_clear (&defs_generated);\n   return;\n }\n \n@@ -3400,7 +3454,7 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n    and reg chains. */\n \n static void\n-df_insn_refs_collect (struct df_collection_rec* collection_rec,\n+df_insn_refs_collect (struct df_collection_rec *collection_rec,\n \t\t      basic_block bb, struct df_insn_info *insn_info)\n {\n   rtx note;\n@@ -3412,9 +3466,6 @@ df_insn_refs_collect (struct df_collection_rec* collection_rec,\n   VEC_truncate (df_ref, collection_rec->eq_use_vec, 0);\n   VEC_truncate (df_mw_hardreg_ptr, collection_rec->mw_vec, 0);\n \n-  /* Record register defs.  */\n-  df_defs_record (collection_rec, PATTERN (insn_info->insn), bb, insn_info, 0);\n-\n   /* Process REG_EQUIV/REG_EQUAL notes.  */\n   for (note = REG_NOTES (insn_info->insn); note;\n        note = XEXP (note, 1))\n@@ -3445,10 +3496,17 @@ df_insn_refs_collect (struct df_collection_rec* collection_rec,\n         }\n     }\n \n+  /* For CALL_INSNs, first record DF_REF_BASE register defs, as well as\n+     uses from CALL_INSN_FUNCTION_USAGE. */\n   if (CALL_P (insn_info->insn))\n     df_get_call_refs (collection_rec, bb, insn_info,\n \t\t      (is_cond_exec) ? DF_REF_CONDITIONAL : 0);\n \n+  /* Record other defs.  These should be mostly for DF_REF_REGULAR, so\n+     that a qsort on the defs is unnecessary in most cases.  */\n+  df_defs_record (collection_rec,\n+\t\t  PATTERN (insn_info->insn), bb, insn_info, 0);\n+\n   /* Record the register uses.  */\n   df_uses_record (collection_rec,\n \t\t  &PATTERN (insn_info->insn), DF_REF_REG_USE, bb, insn_info, 0);"}]}