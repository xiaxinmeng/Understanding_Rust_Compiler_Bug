{"sha": "64f002ed7020b343935c2b84801dd54a4a64ae3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjRmMDAyZWQ3MDIwYjM0MzkzNWMyYjg0ODAxZGQ1NGE0YTY0YWUzYQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2010-04-14T05:43:30Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2010-04-14T05:43:30Z"}, "message": "re PR fortran/18918 (Eventually support Fortran 2008's coarrays [co-arrays])\n\n2010-04-14  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/18918\n        * array.c (gfc_find_array_ref): Handle codimensions.\n        (gfc_match_array_spec,gfc_match_array_ref): Use gfc_fatal_error.\n        * check.c (is_coarray, dim_corank_check, gfc_check_lcobound,\n        gfc_check_image_index, gfc_check_this_image, gfc_check_ucobound):\n        New functions.\n        * gfortran.h (gfc_isym_id): Add GFC_ISYM_IMAGE_INDEX,\n        GFC_ISYM_LCOBOUND, GFC_ISYM_THIS_IMAGE,\n        GFC_ISYM_UCOBOUND.\n        * intrinsic.h (add_functions): Add this_image, image_index,\n        lcobound and ucobound intrinsics.\n        * intrinsic.c (gfc_check_lcobound,gfc_check_ucobound,\n        gfc_check_image_index, gfc_check_this_image,\n        gfc_simplify_image_index, gfc_simplify_lcobound,\n        gfc_simplify_this_image, gfc_simplify_ucobound):\n        New function prototypes.\n        * intrinsic.texi (IMAGE_INDEX, LCOBOUND, THIS_IMAGE\n        IMAGE_INDEX): Document new intrinsic functions.\n        * match.c (gfc_match_critical, sync_statement): Make\n        * -fcoarray=none\n        error fatal.\n        * simplify.c (simplify_bound_dim): Handle coarrays.\n        (simplify_bound): Update simplify_bound_dim call.\n        (gfc_simplify_num_images): Add -fcoarray=none check.\n        (simplify_cobound, gfc_simplify_lcobound, gfc_simplify_ucobound,\n        gfc_simplify_ucobound, gfc_simplify_ucobound): New functions.\n\n2010-04-14  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/18918\n        * gfortran.dg/coarray_9.f90: Update dg-errors.\n        * gfortran.dg/coarray_10.f90: New test.\n        * gfortran.dg/coarray_11.f90: New test.\n\nFrom-SVN: r158292", "tree": {"sha": "5f8c9d8a0881e1935a608fe4a3ca638dbb713a55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f8c9d8a0881e1935a608fe4a3ca638dbb713a55"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64f002ed7020b343935c2b84801dd54a4a64ae3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64f002ed7020b343935c2b84801dd54a4a64ae3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64f002ed7020b343935c2b84801dd54a4a64ae3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64f002ed7020b343935c2b84801dd54a4a64ae3a/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e1859f333682076bd96c3ee607951216dd88a8ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1859f333682076bd96c3ee607951216dd88a8ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1859f333682076bd96c3ee607951216dd88a8ab"}], "stats": {"total": 952, "additions": 933, "deletions": 19}, "files": [{"sha": "72ede7ac752fb2f0f98c0cd159e702797d33fedb", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f002ed7020b343935c2b84801dd54a4a64ae3a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f002ed7020b343935c2b84801dd54a4a64ae3a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=64f002ed7020b343935c2b84801dd54a4a64ae3a", "patch": "@@ -1,3 +1,31 @@\n+2010-04-14  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/18918\n+\t* array.c (gfc_find_array_ref): Handle codimensions.\n+\t(gfc_match_array_spec,gfc_match_array_ref): Use gfc_fatal_error.\n+\t* check.c (is_coarray, dim_corank_check, gfc_check_lcobound,\n+\tgfc_check_image_index, gfc_check_this_image, gfc_check_ucobound):\n+\tNew functions.\n+\t* gfortran.h (gfc_isym_id): Add GFC_ISYM_IMAGE_INDEX,\n+\tGFC_ISYM_LCOBOUND, GFC_ISYM_THIS_IMAGE,\n+\tGFC_ISYM_UCOBOUND.\n+\t* intrinsic.h (add_functions): Add this_image, image_index,\n+\tlcobound and ucobound intrinsics.\n+\t* intrinsic.c (gfc_check_lcobound,gfc_check_ucobound,\n+\tgfc_check_image_index, gfc_check_this_image,\n+\tgfc_simplify_image_index, gfc_simplify_lcobound,\n+\tgfc_simplify_this_image, gfc_simplify_ucobound):\n+\tNew function prototypes.\n+\t* intrinsic.texi (IMAGE_INDEX, LCOBOUND, THIS_IMAGE\n+\tIMAGE_INDEX): Document new intrinsic functions.\n+\t* match.c (gfc_match_critical, sync_statement): Make -fcoarray=none\n+\terror fatal.\n+\t* simplify.c (simplify_bound_dim): Handle coarrays.\n+\t(simplify_bound): Update simplify_bound_dim call.\n+\t(gfc_simplify_num_images): Add -fcoarray=none check.\n+\t(simplify_cobound, gfc_simplify_lcobound, gfc_simplify_ucobound,\n+\tgfc_simplify_ucobound, gfc_simplify_ucobound): New functions.\n+\n 2010-04-14  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/43747"}, {"sha": "5487be7aa4fd589efaac32cc7a07591e9683724c", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f002ed7020b343935c2b84801dd54a4a64ae3a/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f002ed7020b343935c2b84801dd54a4a64ae3a/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=64f002ed7020b343935c2b84801dd54a4a64ae3a", "patch": "@@ -210,7 +210,7 @@ gfc_match_array_ref (gfc_array_ref *ar, gfc_array_spec *as, int init,\n \n   if (gfc_option.coarray == GFC_FCOARRAY_NONE)\n     {\n-      gfc_error (\"Coarrays disabled at %C, use -fcoarray= to enable\");\n+      gfc_fatal_error (\"Coarrays disabled at %C, use -fcoarray= to enable\");\n       return MATCH_ERROR;\n     }\n \n@@ -531,7 +531,7 @@ gfc_match_array_spec (gfc_array_spec **asp, bool match_dim, bool match_codim)\n \n   if (gfc_option.coarray == GFC_FCOARRAY_NONE)\n     {\n-      gfc_error (\"Coarrays disabled at %C, use -fcoarray= to enable\");\n+      gfc_fatal_error (\"Coarrays disabled at %C, use -fcoarray= to enable\");\n       goto cleanup;\n     }\n \n@@ -2223,7 +2223,8 @@ gfc_find_array_ref (gfc_expr *e)\n \n   for (ref = e->ref; ref; ref = ref->next)\n     if (ref->type == REF_ARRAY\n-\t&& (ref->u.ar.type == AR_FULL || ref->u.ar.type == AR_SECTION))\n+\t&& (ref->u.ar.type == AR_FULL || ref->u.ar.type == AR_SECTION\n+\t    || (ref->u.ar.type == AR_ELEMENT && ref->u.ar.dimen == 0)))\n       break;\n \n   if (ref == NULL)"}, {"sha": "799b8c9feeac0f533b28aaaae50049d679180f86", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 187, "deletions": 1, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f002ed7020b343935c2b84801dd54a4a64ae3a/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f002ed7020b343935c2b84801dd54a4a64ae3a/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=64f002ed7020b343935c2b84801dd54a4a64ae3a", "patch": "@@ -1,5 +1,5 @@\n /* Check functions\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught & Katherine Holcomb\n \n@@ -183,6 +183,32 @@ double_check (gfc_expr *d, int n)\n }\n \n \n+/* Check whether an expression is a coarray (without array designator).  */\n+\n+static bool\n+is_coarray (gfc_expr *e)\n+{\n+  bool coarray = false;\n+  gfc_ref *ref;\n+\n+  if (e->expr_type != EXPR_VARIABLE)\n+    return false;\n+\n+  coarray = e->symtree->n.sym->attr.codimension;\n+\n+  for (ref = e->ref; ref; ref = ref->next)\n+    {\n+      if (ref->type == REF_COMPONENT)\n+\tcoarray = ref->u.c.component->attr.codimension;\n+      else if (ref->type != REF_ARRAY || ref->u.ar.dimen != 0\n+\t       || ref->u.ar.codimen != 0) \n+\tcoarray = false;\n+    }\n+\n+  return coarray;\n+}\n+\n+\n /* Make sure the expression is a logical array.  */\n \n static gfc_try\n@@ -329,6 +355,36 @@ dim_check (gfc_expr *dim, int n, bool optional)\n }\n \n \n+/* If a coarray DIM parameter is a constant, make sure that it is greater than\n+   zero and less than or equal to the corank of the given array.  */\n+\n+static gfc_try\n+dim_corank_check (gfc_expr *dim, gfc_expr *array)\n+{\n+  gfc_array_ref *ar;\n+  int corank;\n+\n+  gcc_assert (array->expr_type == EXPR_VARIABLE);\n+\n+  if (dim->expr_type != EXPR_CONSTANT)\n+    return SUCCESS;\n+\n+  ar = gfc_find_array_ref (array);\n+  corank = ar->as->corank;\n+\n+  if (mpz_cmp_ui (dim->value.integer, 1) < 0\n+      || mpz_cmp_ui (dim->value.integer, corank) > 0)\n+    {\n+      gfc_error (\"'dim' argument of '%s' intrinsic at %L is not a valid \"\n+\t\t \"codimension index\", gfc_current_intrinsic, &dim->where);\n+\n+      return FAILURE;\n+    }\n+\n+  return SUCCESS;\n+}\n+\n+\n /* If a DIM parameter is a constant, make sure that it is greater than\n    zero and less than or equal to the rank of the given array.  If\n    allow_assumed is zero then dim must be less than the rank of the array\n@@ -1640,6 +1696,38 @@ gfc_check_lbound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n }\n \n \n+gfc_try\n+gfc_check_lcobound (gfc_expr *coarray, gfc_expr *dim, gfc_expr *kind)\n+{\n+  if (gfc_option.coarray == GFC_FCOARRAY_NONE)\n+    {\n+      gfc_fatal_error (\"Coarrays disabled at %C, use -fcoarray= to enable\");\n+      return FAILURE;\n+    }\n+\n+  if (!is_coarray (coarray))\n+    {\n+      gfc_error (\"Expected coarray variable as '%s' argument to the LCOBOUND \"\n+                 \"intrinsic at %L\", gfc_current_intrinsic_arg[0], &coarray->where);\n+      return FAILURE;\n+    }\n+\n+  if (dim != NULL)\n+    {\n+      if (dim_check (dim, 1, false) == FAILURE)\n+        return FAILURE;\n+\n+      if (dim_corank_check (dim, coarray) == FAILURE)\n+        return FAILURE;\n+    }\n+\n+  if (kind_check (kind, 2, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+\n+  return SUCCESS;\n+}\n+\n+\n gfc_try\n gfc_check_len_lentrim (gfc_expr *s, gfc_expr *kind)\n {\n@@ -3137,6 +3225,72 @@ gfc_check_stat_sub (gfc_expr *name, gfc_expr *array, gfc_expr *status)\n }\n \n \n+gfc_try\n+gfc_check_image_index (gfc_expr *coarray, gfc_expr *sub)\n+{\n+  if (gfc_option.coarray == GFC_FCOARRAY_NONE)\n+    {\n+      gfc_fatal_error (\"Coarrays disabled at %C, use -fcoarray= to enable\");\n+      return FAILURE;\n+    }\n+\n+  if (!is_coarray (coarray))\n+    {\n+      gfc_error (\"Expected coarray variable as '%s' argument to IMAGE_INDEX \"\n+                \"intrinsic at %L\", gfc_current_intrinsic_arg[0], &coarray->where);\n+      return FAILURE;\n+    }\n+\n+  if (sub->rank != 1)\n+    {\n+      gfc_error (\"%s argument to IMAGE_INDEX must be a rank one array at %L\",\n+                gfc_current_intrinsic_arg[1], &sub->where);\n+      return FAILURE;\n+    }\n+\n+  return SUCCESS;\n+}\n+\n+\n+gfc_try\n+gfc_check_this_image (gfc_expr *coarray, gfc_expr *dim)\n+{\n+  if (gfc_option.coarray == GFC_FCOARRAY_NONE)\n+    {\n+      gfc_fatal_error (\"Coarrays disabled at %C, use -fcoarray= to enable\");\n+      return FAILURE;\n+    }\n+\n+  if (dim != NULL &&  coarray == NULL)\n+    {\n+      gfc_error (\"DIM argument without ARRAY argument not allowed for THIS_IMAGE \"\n+                \"intrinsic at %L\", &dim->where);\n+      return FAILURE;\n+    }\n+\n+  if (coarray == NULL)\n+    return SUCCESS;\n+\n+  if (!is_coarray (coarray))\n+    {\n+      gfc_error (\"Expected coarray variable as '%s' argument to THIS_IMAGE \"\n+                \"intrinsic at %L\", gfc_current_intrinsic_arg[0], &coarray->where);\n+      return FAILURE;\n+    }\n+\n+  if (dim != NULL)\n+    {\n+      if (dim_check (dim, 1, false) == FAILURE)\n+       return FAILURE;\n+\n+      if (dim_corank_check (dim, coarray) == FAILURE)\n+       return FAILURE;\n+    }\n+\n+  return SUCCESS;\n+}\n+\n+\n gfc_try\n gfc_check_transfer (gfc_expr *source ATTRIBUTE_UNUSED,\n \t\t    gfc_expr *mold ATTRIBUTE_UNUSED, gfc_expr *size)\n@@ -3197,6 +3351,38 @@ gfc_check_ubound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n }\n \n \n+gfc_try\n+gfc_check_ucobound (gfc_expr *coarray, gfc_expr *dim, gfc_expr *kind)\n+{\n+  if (gfc_option.coarray == GFC_FCOARRAY_NONE)\n+    {\n+      gfc_fatal_error (\"Coarrays disabled at %C, use -fcoarray= to enable\");\n+      return FAILURE;\n+    }\n+\n+  if (!is_coarray (coarray))\n+    {\n+      gfc_error (\"Expected coarray variable as '%s' argument to the UCOBOUND \"\n+                \"intrinsic at %L\", gfc_current_intrinsic_arg[0], &coarray->where);\n+      return FAILURE;\n+    }\n+\n+  if (dim != NULL)\n+    {\n+      if (dim_check (dim, 1, false) == FAILURE)\n+        return FAILURE;\n+\n+      if (dim_corank_check (dim, coarray) == FAILURE)\n+        return FAILURE;\n+    }\n+\n+  if (kind_check (kind, 2, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+\n+  return SUCCESS;\n+}\n+\n+\n gfc_try\n gfc_check_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)\n {"}, {"sha": "48e80f637ee85885a428698a26b3fb5935eff9a0", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f002ed7020b343935c2b84801dd54a4a64ae3a/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f002ed7020b343935c2b84801dd54a4a64ae3a/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=64f002ed7020b343935c2b84801dd54a4a64ae3a", "patch": "@@ -404,6 +404,7 @@ enum gfc_isym_id\n   GFC_ISYM_IDATE,\n   GFC_ISYM_IEOR,\n   GFC_ISYM_IERRNO,\n+  GFC_ISYM_IMAGE_INDEX,\n   GFC_ISYM_INDEX,\n   GFC_ISYM_INT,\n   GFC_ISYM_INT2,\n@@ -423,6 +424,7 @@ enum gfc_isym_id\n   GFC_ISYM_KILL,\n   GFC_ISYM_KIND,\n   GFC_ISYM_LBOUND,\n+  GFC_ISYM_LCOBOUND,\n   GFC_ISYM_LEADZ,\n   GFC_ISYM_LEN,\n   GFC_ISYM_LEN_TRIM,\n@@ -509,6 +511,7 @@ enum gfc_isym_id\n   GFC_ISYM_SYSTEM_CLOCK,\n   GFC_ISYM_TAN,\n   GFC_ISYM_TANH,\n+  GFC_ISYM_THIS_IMAGE,\n   GFC_ISYM_TIME,\n   GFC_ISYM_TIME8,\n   GFC_ISYM_TINY,\n@@ -518,6 +521,7 @@ enum gfc_isym_id\n   GFC_ISYM_TRIM,\n   GFC_ISYM_TTYNAM,\n   GFC_ISYM_UBOUND,\n+  GFC_ISYM_UCOBOUND,\n   GFC_ISYM_UMASK,\n   GFC_ISYM_UNLINK,\n   GFC_ISYM_UNPACK,"}, {"sha": "470839af1044e65a7a9eacaf971630857afd4cdd", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f002ed7020b343935c2b84801dd54a4a64ae3a/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f002ed7020b343935c2b84801dd54a4a64ae3a/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=64f002ed7020b343935c2b84801dd54a4a64ae3a", "patch": "@@ -1081,7 +1081,8 @@ add_functions (void)\n     *y = \"y\", *sz = \"size\", *sta = \"string_a\", *stb = \"string_b\",\n     *z = \"z\", *ln = \"len\", *ut = \"unit\", *han = \"handler\",\n     *num = \"number\", *tm = \"time\", *nm = \"name\", *md = \"mode\",\n-    *vl = \"values\", *p1 = \"path1\", *p2 = \"path2\", *com = \"command\";\n+    *vl = \"values\", *p1 = \"path1\", *p2 = \"path2\", *com = \"command\",\n+    *ca = \"coarray\", *sub = \"sub\";\n \n   int di, dr, dd, dl, dc, dz, ii;\n \n@@ -1784,6 +1785,10 @@ add_functions (void)\n \n   make_generic (\"ierrno\", GFC_ISYM_IERRNO, GFC_STD_GNU);\n \n+  add_sym_2 (\"image_index\", GFC_ISYM_IMAGE_INDEX, CLASS_INQUIRY, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F2008,\n+\t     gfc_check_image_index, gfc_simplify_image_index, NULL,\n+\t     ca, BT_REAL, dr, REQUIRED, sub, BT_INTEGER, ii, REQUIRED);\n+\n   /* The resolution function for INDEX is called gfc_resolve_index_func\n      because the name gfc_resolve_index is already used in resolve.c.  */\n   add_sym_4 (\"index\", GFC_ISYM_INDEX, CLASS_ELEMENTAL, ACTUAL_YES,\n@@ -1919,6 +1924,14 @@ add_functions (void)\n \n   make_generic (\"lbound\", GFC_ISYM_LBOUND, GFC_STD_F95);\n \n+  add_sym_3 (\"lcobound\", GFC_ISYM_LCOBOUND, CLASS_INQUIRY, ACTUAL_NO,\n+\t     BT_INTEGER, di, GFC_STD_F95,\n+\t     gfc_check_lcobound, gfc_simplify_lcobound, NULL,\n+\t     ca, BT_REAL, dr, REQUIRED, dm, BT_INTEGER, ii, OPTIONAL,\n+\t     kind, BT_INTEGER, di, OPTIONAL);\n+\n+  make_generic (\"lcobound\", GFC_ISYM_LCOBOUND, GFC_STD_F95);\n+\n   add_sym_1 (\"leadz\", GFC_ISYM_LEADZ, CLASS_ELEMENTAL, ACTUAL_NO,\n \t     BT_INTEGER, di, GFC_STD_F2008,\n \t     gfc_check_i, gfc_simplify_leadz, NULL,\n@@ -2526,6 +2539,10 @@ add_functions (void)\n \n   make_generic (\"tanh\", GFC_ISYM_TANH, GFC_STD_F77);\n \n+  add_sym_2 (\"this_image\", GFC_ISYM_THIS_IMAGE, CLASS_INQUIRY, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F2008,\n+\t     gfc_check_this_image, gfc_simplify_this_image, NULL,\n+\t     ca, BT_REAL, dr, OPTIONAL, dm, BT_INTEGER, ii, OPTIONAL);\n+\n   add_sym_0 (\"time\", GFC_ISYM_TIME, NO_CLASS, ACTUAL_NO, BT_INTEGER, di, GFC_STD_GNU, \n \t     NULL, NULL, gfc_resolve_time);\n \n@@ -2582,6 +2599,14 @@ add_functions (void)\n \n   make_generic (\"ubound\", GFC_ISYM_UBOUND, GFC_STD_F95);\n \n+  add_sym_3 (\"ucobound\", GFC_ISYM_UCOBOUND, CLASS_INQUIRY, ACTUAL_NO,\n+            BT_INTEGER, di, GFC_STD_F95,\n+            gfc_check_ucobound, gfc_simplify_ucobound, NULL,\n+            ca, BT_REAL, dr, REQUIRED, dm, BT_INTEGER, ii, OPTIONAL,\n+            kind, BT_INTEGER, di, OPTIONAL);\n+\n+  make_generic (\"ucobound\", GFC_ISYM_UCOBOUND, GFC_STD_F95);\n+\n   /* g77 compatibility for UMASK.  */\n   add_sym_1 (\"umask\", GFC_ISYM_UMASK, NO_CLASS, ACTUAL_NO, BT_INTEGER, di,\n \t     GFC_STD_GNU, gfc_check_umask, NULL, gfc_resolve_umask,"}, {"sha": "de33a4f7dc288336740544c2cd40d743ea9735ff", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f002ed7020b343935c2b84801dd54a4a64ae3a/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f002ed7020b343935c2b84801dd54a4a64ae3a/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=64f002ed7020b343935c2b84801dd54a4a64ae3a", "patch": "@@ -91,6 +91,7 @@ gfc_try gfc_check_ishftc (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_try gfc_check_kill (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_kind (gfc_expr *);\n gfc_try gfc_check_lbound (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_lcobound (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_try gfc_check_len_lentrim (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_link (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_lge_lgt_lle_llt (gfc_expr *, gfc_expr *);\n@@ -143,6 +144,7 @@ gfc_try gfc_check_transpose (gfc_expr *);\n gfc_try gfc_check_trim (gfc_expr *);\n gfc_try gfc_check_ttynam (gfc_expr *);\n gfc_try gfc_check_ubound (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_ucobound (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_try gfc_check_umask (gfc_expr *);\n gfc_try gfc_check_unlink (gfc_expr *);\n gfc_try gfc_check_unpack (gfc_expr *, gfc_expr *, gfc_expr *);\n@@ -178,6 +180,7 @@ gfc_try gfc_check_fseek_sub (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_try gfc_check_ftell_sub (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_getcwd_sub (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_hostnm_sub (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_image_index (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_itime_idate (gfc_expr *);\n gfc_try gfc_check_kill_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_try gfc_check_ltime_gmtime (gfc_expr *, gfc_expr *);\n@@ -189,6 +192,7 @@ gfc_try gfc_check_signal_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_try gfc_check_sleep_sub (gfc_expr *);\n gfc_try gfc_check_stat_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_try gfc_check_system_sub (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_this_image (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_ttynam_sub (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_umask_sub (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_unlink_sub (gfc_expr *, gfc_expr *);\n@@ -255,6 +259,7 @@ gfc_expr *gfc_simplify_ibits (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_ibset (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_ichar (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_ieor (gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_image_index (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_index (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_int (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_int2 (gfc_expr *);\n@@ -270,6 +275,7 @@ gfc_expr *gfc_simplify_ishft (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_ishftc (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_kind (gfc_expr *);\n gfc_expr *gfc_simplify_lbound (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_lcobound (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_leadz (gfc_expr *);\n gfc_expr *gfc_simplify_len (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_len_trim (gfc_expr *, gfc_expr *);\n@@ -330,12 +336,14 @@ gfc_expr *gfc_simplify_sqrt (gfc_expr *);\n gfc_expr *gfc_simplify_sum (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_tan (gfc_expr *);\n gfc_expr *gfc_simplify_tanh (gfc_expr *);\n+gfc_expr *gfc_simplify_this_image (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_tiny (gfc_expr *);\n gfc_expr *gfc_simplify_trailz (gfc_expr *);\n gfc_expr *gfc_simplify_transfer (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_transpose (gfc_expr *);\n gfc_expr *gfc_simplify_trim (gfc_expr *);\n gfc_expr *gfc_simplify_ubound (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_ucobound (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_unpack (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_verify (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_xor (gfc_expr *, gfc_expr *);"}, {"sha": "63b8b2b98b08b0de424ecd6837a59512e3c0ef0d", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 187, "deletions": 3, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f002ed7020b343935c2b84801dd54a4a64ae3a/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f002ed7020b343935c2b84801dd54a4a64ae3a/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=64f002ed7020b343935c2b84801dd54a4a64ae3a", "patch": "@@ -154,6 +154,7 @@ Some basic guidelines for editing this document:\n * @code{INT8}:          INT8,      Convert to 64-bit integer type\n * @code{IOR}:           IOR,       Bitwise logical or\n * @code{IRAND}:         IRAND,     Integer pseudo-random number\n+* @code{IMAGE_INDEX}:   IMAGE_INDEX, Cosubscript to image index convertion\n * @code{IS_IOSTAT_END}:  IS_IOSTAT_END, Test for end-of-file value\n * @code{IS_IOSTAT_EOR}:  IS_IOSTAT_EOR, Test for end-of-record value\n * @code{ISATTY}:        ISATTY,    Whether a unit is a terminal device\n@@ -164,6 +165,7 @@ Some basic guidelines for editing this document:\n * @code{KILL}:          KILL,      Send a signal to a process\n * @code{KIND}:          KIND,      Kind of an entity\n * @code{LBOUND}:        LBOUND,    Lower dimension bounds of an array\n+* @code{LCOBOUND}:      LCOBOUND,  Lower codimension bounds of an array\n * @code{LEADZ}:         LEADZ,     Number of leading zero bits of an integer\n * @code{LEN}:           LEN,       Length of a character entity\n * @code{LEN_TRIM}:      LEN_TRIM,  Length of a character entity without trailing blank characters\n@@ -251,6 +253,7 @@ Some basic guidelines for editing this document:\n * @code{SYSTEM_CLOCK}:  SYSTEM_CLOCK, Time function\n * @code{TAN}:           TAN,       Tangent function\n * @code{TANH}:          TANH,      Hyperbolic tangent function\n+* @code{THIS_IMAGE}:    THIS_IMAGE, Cosubscript index of this image\n * @code{TIME}:          TIME,      Time function\n * @code{TIME8}:         TIME8,     Time function (64-bit)\n * @code{TINY}:          TINY,      Smallest positive number of a real kind\n@@ -260,6 +263,7 @@ Some basic guidelines for editing this document:\n * @code{TRIM}:          TRIM,      Remove trailing blank characters of a string\n * @code{TTYNAM}:        TTYNAM,    Get the name of a terminal device.\n * @code{UBOUND}:        UBOUND,    Upper dimension bounds of an array\n+* @code{UCOBOUND}:      UCOBOUND,  Upper codimension bounds of an array\n * @code{UMASK}:         UMASK,     Set the file creation mask\n * @code{UNLINK}:        UNLINK,    Remove a file from the file system\n * @code{UNPACK}:        UNPACK,    Unpack an array of rank one into an array\n@@ -6115,6 +6119,50 @@ end program test_irand\n \n \n \n+@node IMAGE_INDEX\n+@section @code{IMAGE_INDEX} --- Function that converts a cosubscript to an image index\n+@fnindex IMAGE_INDEX\n+@cindex coarray, IMAGE_INDEX\n+@cindex images, cosubscript to image index conversion\n+\n+@table @asis\n+@item @emph{Description}:\n+Returns the image index belonging to a cosubscript.\n+\n+@item @emph{Standard}:\n+Fortran 2008 and later\n+\n+@item @emph{Class}:\n+Inquiry function.\n+\n+@item @emph{Syntax}:\n+@code{RESULT = IMAGE_INDEX(COARRAY, SUB)}\n+\n+@item @emph{Arguments}: None.\n+@multitable @columnfractions .15 .70\n+@item @var{COARRAY} @tab Coarray of any type.\n+@item @var{SUB}     @tab default integer rank-1 array of a size equal to\n+the corank of @var{COARRAY}.\n+@end multitable\n+\n+\n+@item @emph{Return value}:\n+Scalar default integer with the value of the image index which corresponds\n+to the cosubscripts. For invalid cosubscripts the result is zero.\n+\n+@item @emph{Example}:\n+@smallexample\n+INTEGER :: array[2,-1:4,8,*]\n+! Writes  28 (or 0 if there are fewer than 28 images)\n+WRITE (*,*) IMAGE_INDEX (array, [2,0,3,1])\n+@end smallexample\n+\n+@item @emph{See also}:\n+@ref{THIS_IMAGE}, @ref{NUM_IMAGES}\n+@end table\n+\n+\n+\n @node IS_IOSTAT_END\n @section @code{IS_IOSTAT_END} --- Test for end-of-file value\n @fnindex IS_IOSTAT_END\n@@ -6535,7 +6583,46 @@ structure component, or if it has a zero extent along the relevant\n dimension, the lower bound is taken to be 1.\n \n @item @emph{See also}:\n-@ref{UBOUND}\n+@ref{UBOUND}, @ref{LCOBOUND}\n+@end table\n+\n+\n+\n+@node LCOBOUND\n+@section @code{LCOBOUND} --- Lower codimension bounds of an array\n+@fnindex LCOBOUND\n+@cindex coarray, lower bound\n+\n+@table @asis\n+@item @emph{Description}:\n+Returns the lower bounds of a coarray, or a single lower cobound\n+along the @var{DIM} codimension.\n+@item @emph{Standard}:\n+Fortran 2008 and later\n+\n+@item @emph{Class}:\n+Inquiry function\n+\n+@item @emph{Syntax}:\n+@code{RESULT = LCOBOUND(COARRAY [, DIM [, KIND]])}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{ARRAY} @tab Shall be an coarray, of any type.\n+@item @var{DIM} @tab (Optional) Shall be a scalar @code{INTEGER}.\n+@item @var{KIND} @tab (Optional) An @code{INTEGER} initialization\n+expression indicating the kind parameter of the result.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type @code{INTEGER} and of kind @var{KIND}. If\n+@var{KIND} is absent, the return value is of default integer kind.\n+If @var{DIM} is absent, the result is an array of the lower cobounds of\n+@var{COARRAY}.  If @var{DIM} is present, the result is a scalar\n+corresponding to the lower cobound of the array along that codimension.\n+\n+@item @emph{See also}:\n+@ref{UCOBOUND}, @ref{LBOUND}\n @end table\n \n \n@@ -8414,7 +8501,7 @@ END IF\n @end smallexample\n \n @item @emph{See also}:\n-@c FIXME: ref{THIS_IMAGE}\n+@ref{THIS_IMAGE}, @ref{IMAGE_INDEX}\n @end table\n \n \n@@ -10654,6 +10741,64 @@ end program test_tanh\n \n \n \n+@node THIS_IMAGE\n+@section @code{THIS_IMAGE} --- Function that returns the cosubscript index of this image\n+@fnindex THIS_IMAGE\n+@cindex coarray, THIS_IMAGE\n+@cindex images, index of this image\n+\n+@table @asis\n+@item @emph{Description}:\n+Returns the cosubscript for this image.\n+\n+@item @emph{Standard}:\n+Fortran 2008 and later\n+\n+@item @emph{Class}:\n+Transformational function\n+\n+@item @emph{Syntax}:\n+@multitable @columnfractions .80\n+@item @code{RESULT = THIS_IMAGE()}\n+@item @code{RESULT = THIS_IMAGE(COARRAY [, DIM])}\n+@end multitable\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{COARRAY} @tab Coarray of any type  (optional; if @var{DIM}\n+present, required).\n+@item @var{DIM}     @tab default integer scalar (optional). If present,\n+@var{DIM} shall be between one and the corank of @var{COARRAY}.\n+@end multitable\n+\n+\n+@item @emph{Return value}:\n+Default integer. If @var{COARRAY} is not present, it is scalar and its value\n+is the index of the invoking image. Otherwise, if @var{DIM} is not present,\n+a rank-1 array with corank elements is returned, containing the cosubscripts\n+for @var{COARRAY} specifying the invoking image. If @var{DIM} is present,\n+a scalar is returned, with the value of the @var{DIM} element of\n+@code{THIS_IMAGE(COARRAY)}.\n+\n+@item @emph{Example}:\n+@smallexample\n+INTEGER :: value[*]\n+INTEGER :: i\n+value = THIS_IMAGE()\n+SYNC ALL\n+IF (THIS_IMAGE() == 1) THEN\n+  DO i = 1, NUM_IMAGES()\n+    WRITE(*,'(2(a,i0))') 'value[', i, '] is ', value[i]\n+  END DO\n+END IF\n+@end smallexample\n+\n+@item @emph{See also}:\n+@ref{NUM_IMAGES}, @ref{IMAGE_INDEX}\n+@end table\n+\n+\n+\n @node TIME\n @section @code{TIME} --- Time function\n @fnindex TIME\n@@ -11030,7 +11175,46 @@ dimension, the upper bound is taken to be the number of elements along\n the relevant dimension.\n \n @item @emph{See also}:\n-@ref{LBOUND}\n+@ref{LBOUND}, @ref{LCOBOUND}\n+@end table\n+\n+\n+\n+@node UCOBOUND\n+@section @code{UCOBOUND} --- Upper codimension bounds of an array\n+@fnindex UCOBOUND\n+@cindex coarray, upper bound\n+\n+@table @asis\n+@item @emph{Description}:\n+Returns the upper cobounds of a coarray, or a single upper cobound\n+along the @var{DIM} codimension.\n+@item @emph{Standard}:\n+Fortran 2008 and later\n+\n+@item @emph{Class}:\n+Inquiry function\n+\n+@item @emph{Syntax}:\n+@code{RESULT = UCOBOUND(COARRAY [, DIM [, KIND]])}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{ARRAY} @tab Shall be an coarray, of any type.\n+@item @var{DIM} @tab (Optional) Shall be a scalar @code{INTEGER}.\n+@item @var{KIND} @tab (Optional) An @code{INTEGER} initialization\n+expression indicating the kind parameter of the result.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type @code{INTEGER} and of kind @var{KIND}. If\n+@var{KIND} is absent, the return value is of default integer kind.\n+If @var{DIM} is absent, the result is an array of the lower cobounds of\n+@var{COARRAY}.  If @var{DIM} is present, the result is a scalar\n+corresponding to the lower cobound of the array along that codimension.\n+\n+@item @emph{See also}:\n+@ref{LCOBOUND}, @ref{LBOUND}\n @end table\n \n "}, {"sha": "44e9f9d8a191e92ceef8251ebaa99bb712ca1768", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f002ed7020b343935c2b84801dd54a4a64ae3a/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f002ed7020b343935c2b84801dd54a4a64ae3a/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=64f002ed7020b343935c2b84801dd54a4a64ae3a", "patch": "@@ -1753,7 +1753,7 @@ gfc_match_critical (void)\n \n   if (gfc_option.coarray == GFC_FCOARRAY_NONE)\n     {\n-       gfc_error (\"Coarrays disabled at %C, use -fcoarray= to enable\");\n+       gfc_fatal_error (\"Coarrays disabled at %C, use -fcoarray= to enable\");\n        return MATCH_ERROR;\n     }\n \n@@ -2154,7 +2154,7 @@ sync_statement (gfc_statement st)\n \n   if (gfc_option.coarray == GFC_FCOARRAY_NONE)\n     {\n-       gfc_error (\"Coarrays disabled at %C, use -fcoarray= to enable\");\n+       gfc_fatal_error (\"Coarrays disabled at %C, use -fcoarray= to enable\");\n        return MATCH_ERROR;\n     }\n "}, {"sha": "1838c0071eacc14d3a6fd2b9b8985a57fba183d3", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 392, "deletions": 6, "changes": 398, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f002ed7020b343935c2b84801dd54a4a64ae3a/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f002ed7020b343935c2b84801dd54a4a64ae3a/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=64f002ed7020b343935c2b84801dd54a4a64ae3a", "patch": "@@ -2722,13 +2722,14 @@ gfc_simplify_kind (gfc_expr *e)\n \n static gfc_expr *\n simplify_bound_dim (gfc_expr *array, gfc_expr *kind, int d, int upper,\n-\t\t    gfc_array_spec *as, gfc_ref *ref)\n+\t\t    gfc_array_spec *as, gfc_ref *ref, bool coarray)\n {\n   gfc_expr *l, *u, *result;\n   int k;\n \n   /* The last dimension of an assumed-size array is special.  */\n-  if (d == as->rank && as->type == AS_ASSUMED_SIZE && !upper)\n+  if ((!coarray && d == as->rank && as->type == AS_ASSUMED_SIZE && !upper)\n+      || (coarray && d == as->rank + as->corank))\n     {\n       if (as->lower[d-1]->expr_type == EXPR_CONSTANT)\n \treturn gfc_copy_expr (as->lower[d-1]);\n@@ -2745,12 +2746,13 @@ simplify_bound_dim (gfc_expr *array, gfc_expr *kind, int d, int upper,\n \n \n   /* Then, we need to know the extent of the given dimension.  */\n-  if (ref->u.ar.type == AR_FULL)\n+  if (coarray || ref->u.ar.type == AR_FULL)\n     {\n       l = as->lower[d-1];\n       u = as->upper[d-1];\n \n-      if (l->expr_type != EXPR_CONSTANT || u->expr_type != EXPR_CONSTANT)\n+      if (l->expr_type != EXPR_CONSTANT || u == NULL\n+\t  || u->expr_type != EXPR_CONSTANT)\n \treturn NULL;\n \n       if (mpz_cmp (l->value.integer, u->value.integer) > 0)\n@@ -2861,7 +2863,8 @@ simplify_bound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind, int upper)\n       /* Simplify the bounds for each dimension.  */\n       for (d = 0; d < array->rank; d++)\n \t{\n-\t  bounds[d] = simplify_bound_dim (array, kind, d + 1, upper, as, ref);\n+\t  bounds[d] = simplify_bound_dim (array, kind, d + 1, upper, as, ref,\n+\t\t\t\t\t  false);\n \t  if (bounds[d] == NULL || bounds[d] == &gfc_bad_expr)\n \t    {\n \t      int j;\n@@ -2908,7 +2911,131 @@ simplify_bound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind, int upper)\n \t  return &gfc_bad_expr;\n \t}\n \n-      return simplify_bound_dim (array, kind, d, upper, as, ref);\n+      return simplify_bound_dim (array, kind, d, upper, as, ref, false);\n+    }\n+}\n+\n+\n+static gfc_expr *\n+simplify_cobound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind, int upper)\n+{\n+  gfc_ref *ref;\n+  gfc_array_spec *as;\n+  int d;\n+\n+  if (array->expr_type != EXPR_VARIABLE)\n+    return NULL;\n+\n+  /* Follow any component references.  */\n+  as = array->symtree->n.sym->as;\n+  for (ref = array->ref; ref; ref = ref->next)\n+    {\n+      switch (ref->type)\n+\t{\n+\tcase REF_ARRAY:\n+\t  switch (ref->u.ar.type)\n+\t    {\n+\t    case AR_ELEMENT:\n+\t      as = NULL;\n+\t      continue;\n+\n+\t    case AR_FULL:\n+\t      /* We're done because 'as' has already been set in the\n+\t\t previous iteration.  */\n+\t      if (!ref->next)\n+\t        goto done;\n+\n+\t    /* Fall through.  */\n+\n+\t    case AR_UNKNOWN:\n+\t      return NULL;\n+\n+\t    case AR_SECTION:\n+\t      as = ref->u.ar.as;\n+\t      goto done;\n+\t    }\n+\n+\t  gcc_unreachable ();\n+\n+\tcase REF_COMPONENT:\n+\t  as = ref->u.c.component->as;\n+\t  continue;\n+\n+\tcase REF_SUBSTRING:\n+\t  continue;\n+\t}\n+    }\n+\n+  gcc_unreachable ();\n+\n+ done:\n+\n+  if (as->type == AS_DEFERRED || as->type == AS_ASSUMED_SHAPE)\n+    return NULL;\n+\n+  if (dim == NULL)\n+    {\n+      /* Multi-dimensional cobounds.  */\n+      gfc_expr *bounds[GFC_MAX_DIMENSIONS];\n+      gfc_expr *e;\n+      int k;\n+\n+      /* Simplify the cobounds for each dimension.  */\n+      for (d = 0; d < as->corank; d++)\n+\t{\n+\t  bounds[d] = simplify_bound_dim (array, kind, d + 1 + array->rank,\n+\t\t\t\t\t  upper, as, ref, true);\n+\t  if (bounds[d] == NULL || bounds[d] == &gfc_bad_expr)\n+\t    {\n+\t      int j;\n+\n+\t      for (j = 0; j < d; j++)\n+\t\tgfc_free_expr (bounds[j]);\n+\t      return bounds[d];\n+\t    }\n+\t}\n+\n+      /* Allocate the result expression.  */\n+      e = gfc_get_expr ();\n+      e->where = array->where;\n+      e->expr_type = EXPR_ARRAY;\n+      e->ts.type = BT_INTEGER;\n+      k = get_kind (BT_INTEGER, kind, upper ? \"UCOBOUND\" : \"LCOBOUND\",\n+\t\t    gfc_default_integer_kind); \n+      if (k == -1)\n+\t{\n+\t  gfc_free_expr (e);\n+\t  return &gfc_bad_expr;\n+\t}\n+      e->ts.kind = k;\n+\n+      /* The result is a rank 1 array; its size is the rank of the first\n+\t argument to {L,U}COBOUND.  */\n+      e->rank = 1;\n+      e->shape = gfc_get_shape (1);\n+      mpz_init_set_ui (e->shape[0], as->corank);\n+\n+      /* Create the constructor for this array.  */\n+      for (d = 0; d < as->corank; d++)\n+\tgfc_constructor_append_expr (&e->value.constructor,\n+\t\t\t\t     bounds[d], &e->where);\n+      return e;\n+    }\n+  else\n+    {\n+      /* A DIM argument is specified.  */\n+      if (dim->expr_type != EXPR_CONSTANT)\n+\treturn NULL;\n+\n+      d = mpz_get_si (dim->value.integer);\n+\n+      if (d < 1 || d > as->corank)\n+\t{\n+\t  gfc_error (\"DIM argument at %L is out of bounds\", &dim->where);\n+\t  return &gfc_bad_expr;\n+\t}\n+\n+      return simplify_bound_dim (array, kind, d+array->rank, upper, as, ref, true);\n     }\n }\n \n@@ -2920,6 +3047,21 @@ gfc_simplify_lbound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n }\n \n \n+gfc_expr *\n+gfc_simplify_lcobound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n+{\n+  gfc_expr *e;\n+  /* return simplify_cobound (array, dim, kind, 0);*/\n+\n+  e = simplify_cobound (array, dim, kind, 0);\n+  if (e != NULL)\n+    return e;\n+\n+  gfc_error (\"Not yet implemented: LCOBOUND for coarray with non-constant \"\n+\t     \"cobounds at %L\", &array->where);\n+  return &gfc_bad_expr;\n+}\n+\n gfc_expr *\n gfc_simplify_leadz (gfc_expr *e)\n {\n@@ -3703,6 +3845,13 @@ gfc_expr *\n gfc_simplify_num_images (void)\n {\n   gfc_expr *result;\n+\n+  if (gfc_option.coarray == GFC_FCOARRAY_NONE)\n+    {\n+      gfc_fatal_error (\"Coarrays disabled at %C, use -fcoarray= to enable\");\n+      return &gfc_bad_expr;\n+    }\n+\n   /* FIXME: gfc_current_locus is wrong.  */\n   result = gfc_get_constant_expr (BT_INTEGER, gfc_default_integer_kind,\n \t\t\t\t  &gfc_current_locus);\n@@ -5173,12 +5322,249 @@ gfc_simplify_trim (gfc_expr *e)\n }\n \n \n+gfc_expr *\n+gfc_simplify_image_index (gfc_expr *coarray, gfc_expr *sub)\n+{\n+  gfc_expr *result;\n+  gfc_ref *ref;\n+  gfc_array_spec *as;\n+  gfc_constructor *sub_cons;\n+  bool first_image;\n+  int d;\n+\n+  if (!is_constant_array_expr (sub))\n+    goto not_implemented; /* return NULL;*/\n+\n+  /* Follow any component references.  */\n+  as = coarray->symtree->n.sym->as;\n+  for (ref = coarray->ref; ref; ref = ref->next)\n+    if (ref->type == REF_COMPONENT)\n+      as = ref->u.ar.as;\n+\n+  if (as->type == AS_DEFERRED)\n+    goto not_implemented; /* return NULL;*/\n+\n+  /* \"valid sequence of cosubscripts\" are required; thus, return 0 unless\n+     the cosubscript addresses the first image.  */\n+\n+  sub_cons = gfc_constructor_first (sub->value.constructor);\n+  first_image = true;\n+\n+  for (d = 1; d <= as->corank; d++)\n+    {\n+      gfc_expr *ca_bound;\n+      int cmp;\n+\n+      if (sub_cons == NULL)\n+\t{\n+\t  gfc_error (\"Too few elements in expression for SUB= argument at %L\",\n+\t\t     &sub->where);\n+\t  return &gfc_bad_expr;\n+\t}\n+\n+      ca_bound = simplify_bound_dim (coarray, NULL, d + as->rank, 0, as,\n+\t\t\t\t     NULL, true);\n+      if (ca_bound == NULL)\n+\tgoto not_implemented; /* return NULL */\n+\n+      if (ca_bound == &gfc_bad_expr)\n+\treturn ca_bound;\n+\n+      cmp = mpz_cmp (ca_bound->value.integer, sub_cons->expr->value.integer);\n+\n+      if (cmp == 0)\n+\t{\n+          gfc_free_expr (ca_bound);\n+\t  sub_cons = gfc_constructor_next (sub_cons);\n+\t  continue;\n+\t}\n+\n+      first_image = false;\n+\n+      if (cmp > 0)\n+\t{\n+\t  gfc_error (\"Out of bounds in IMAGE_INDEX at %L for dimension %d, \"\n+\t\t     \"SUB has %ld and COARRAY lower bound is %ld)\",\n+\t\t     &coarray->where, d,\n+\t\t     mpz_get_si (sub_cons->expr->value.integer),\n+\t\t     mpz_get_si (ca_bound->value.integer));\n+\t  gfc_free_expr (ca_bound);\n+\t  return &gfc_bad_expr;\n+\t}\n+\n+      gfc_free_expr (ca_bound);\n+\n+      /* Check whether upperbound is valid for the multi-images case.  */\n+      if (d < as->corank)\n+\t{\n+\t  ca_bound = simplify_bound_dim (coarray, NULL, d + as->rank, 1, as,\n+\t\t\t\t\t NULL, true);\n+\t  if (ca_bound == &gfc_bad_expr)\n+\t    return ca_bound;\n+\n+\t  if (ca_bound && ca_bound->expr_type == EXPR_CONSTANT\n+\t      && mpz_cmp (ca_bound->value.integer,\n+\t\t\t  sub_cons->expr->value.integer) < 0)\n+\t  {\n+\t    gfc_error (\"Out of bounds in IMAGE_INDEX at %L for dimension %d, \"\n+\t\t       \"SUB has %ld and COARRAY upper bound is %ld)\",\n+\t\t       &coarray->where, d,\n+\t\t       mpz_get_si (sub_cons->expr->value.integer),\n+\t\t       mpz_get_si (ca_bound->value.integer));\n+\t    gfc_free_expr (ca_bound);\n+\t    return &gfc_bad_expr;\n+\t  }\n+\n+\t  if (ca_bound)\n+\t    gfc_free_expr (ca_bound);\n+\t}\n+\n+      sub_cons = gfc_constructor_next (sub_cons);\n+    }\n+\n+  if (sub_cons != NULL)\n+    {\n+      gfc_error (\"Too many elements in expression for SUB= argument at %L\",\n+\t\t &sub->where);\n+      return &gfc_bad_expr;\n+    }\n+\n+  result = gfc_get_constant_expr (BT_INTEGER, gfc_default_integer_kind,\n+\t\t\t\t  &gfc_current_locus);\n+  if (first_image)\n+    mpz_set_si (result->value.integer, 1);\n+  else\n+    mpz_set_si (result->value.integer, 0);\n+\n+  return result;\n+\n+not_implemented:\n+  gfc_error (\"Not yet implemented: IMAGE_INDEX for coarray with non-constant \"\n+\t     \"cobounds at %L\", &coarray->where);\n+  return &gfc_bad_expr;\n+}\n+\n+\n+gfc_expr *\n+gfc_simplify_this_image (gfc_expr *coarray, gfc_expr *dim)\n+{\n+  gfc_ref *ref;\n+  gfc_array_spec *as;\n+  int d;\n+\n+  if (coarray == NULL)\n+    {\n+      gfc_expr *result;\n+      /* FIXME: gfc_current_locus is wrong.  */\n+      result = gfc_get_constant_expr (BT_INTEGER, gfc_default_integer_kind,\n+\t\t\t\t      &gfc_current_locus);\n+      mpz_set_si (result->value.integer, 1);\n+      return result;\n+    }\n+\n+  gcc_assert (coarray->expr_type == EXPR_VARIABLE);\n+\n+  /* Follow any component references.  */\n+  as = coarray->symtree->n.sym->as;\n+  for (ref = coarray->ref; ref; ref = ref->next)\n+    if (ref->type == REF_COMPONENT)\n+      as = ref->u.ar.as;\n+\n+  if (as->type == AS_DEFERRED)\n+    goto not_implemented; /* return NULL;*/\n+\n+  if (dim == NULL)\n+    {\n+      /* Multi-dimensional bounds.  */\n+      gfc_expr *bounds[GFC_MAX_DIMENSIONS];\n+      gfc_expr *e;\n+\n+      /* Simplify the bounds for each dimension.  */\n+      for (d = 0; d < as->corank; d++)\n+\t{\n+\t  bounds[d] = simplify_bound_dim (coarray, NULL, d + as->rank + 1, 0,\n+\t\t\t\t\t  as, NULL, true);\n+\t  if (bounds[d] == NULL || bounds[d] == &gfc_bad_expr)\n+\t    {\n+\t      int j;\n+\n+\t      for (j = 0; j < d; j++)\n+\t\tgfc_free_expr (bounds[j]);\n+\t      if (bounds[d] == NULL)\n+\t\tgoto not_implemented;\n+\t      return bounds[d];\n+\t    }\n+\t}\n+\n+      /* Allocate the result expression.  */\n+      e = gfc_get_expr ();\n+      e->where = coarray->where;\n+      e->expr_type = EXPR_ARRAY;\n+      e->ts.type = BT_INTEGER;\n+      e->ts.kind = gfc_default_integer_kind;\n+\n+      e->rank = 1;\n+      e->shape = gfc_get_shape (1);\n+      mpz_init_set_ui (e->shape[0], as->corank);\n+\n+      /* Create the constructor for this array.  */\n+      for (d = 0; d < as->corank; d++)\n+        gfc_constructor_append_expr (&e->value.constructor,\n+                                     bounds[d], &e->where);\n+\n+      return e;\n+    }\n+  else\n+    {\n+      gfc_expr *e;\n+      /* A DIM argument is specified.  */\n+      if (dim->expr_type != EXPR_CONSTANT)\n+\tgoto not_implemented; /*return NULL;*/\n+\n+      d = mpz_get_si (dim->value.integer);\n+\n+      if (d < 1 || d > as->corank)\n+\t{\n+\t  gfc_error (\"DIM argument at %L is out of bounds\", &dim->where);\n+\t  return &gfc_bad_expr;\n+\t}\n+\n+      /*return simplify_bound_dim (coarray, NULL, d + as->rank, 0, as, NULL, true);*/\n+      e = simplify_bound_dim (coarray, NULL, d + as->rank, 0, as, NULL, true);\n+      if (e != NULL)\n+\treturn e;\n+      else\n+\tgoto not_implemented;\n+   }\n+\n+not_implemented:\n+  gfc_error (\"Not yet implemented: THIS_IMAGE for coarray with non-constant \"\n+\t     \"cobounds at %L\", &coarray->where);\n+  return &gfc_bad_expr;\n+}\n+\n+\n gfc_expr *\n gfc_simplify_ubound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n {\n   return simplify_bound (array, dim, kind, 1);\n }\n \n+gfc_expr *\n+gfc_simplify_ucobound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n+{\n+  gfc_expr *e;\n+  /* return simplify_cobound (array, dim, kind, 1);*/\n+\n+  e = simplify_cobound (array, dim, kind, 1);\n+  if (e != NULL)\n+    return e;\n+\n+  gfc_error (\"Not yet implemented: UCOBOUND for coarray with non-constant \"\n+\t     \"cobounds at %L\", &array->where);\n+  return &gfc_bad_expr;\n+}\n+\n \n gfc_expr *\n gfc_simplify_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)"}, {"sha": "913b01a4c5796b589525cd157411d3e202f69ba8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f002ed7020b343935c2b84801dd54a4a64ae3a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f002ed7020b343935c2b84801dd54a4a64ae3a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=64f002ed7020b343935c2b84801dd54a4a64ae3a", "patch": "@@ -1,3 +1,10 @@\n+2010-04-14  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/18918\n+\t* gfortran.dg/coarray_9.f90: Update dg-errors.\n+\t* gfortran.dg/coarray_10.f90: New test.\n+\t* gfortran.dg/coarray_11.f90: New test.\n+\n 2010-04-14  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/43747"}, {"sha": "7a50c89fc3ccff3df10b35f2323cb97accce42e9", "filename": "gcc/testsuite/gfortran.dg/coarray_10.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f002ed7020b343935c2b84801dd54a4a64ae3a/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f002ed7020b343935c2b84801dd54a4a64ae3a/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_10.f90?ref=64f002ed7020b343935c2b84801dd54a4a64ae3a", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=single\" }\n+!\n+! PR fortran/18918\n+!\n+! Coarray intrinsics\n+!\n+\n+subroutine image_idx_test1()\n+  INTEGER,save :: array[2,-1:4,8,*]\n+  WRITE (*,*) IMAGE_INDEX (array, [2,0,3,1])\n+  WRITE (*,*) IMAGE_INDEX (array, [0,0,3,1])  ! { dg-error \"for dimension 1, SUB has 0 and COARRAY lower bound is 1\" }\n+  WRITE (*,*) IMAGE_INDEX (array, [1,2,9,0])  ! { dg-error \"for dimension 3, SUB has 9 and COARRAY upper bound is 8\" }\n+  WRITE (*,*) IMAGE_INDEX (array, [2,0,3])    ! { dg-error \"Too few elements\" }\n+  WRITE (*,*) IMAGE_INDEX (array, [2,0,3,1,1])! { dg-error \"Too many elements\" }\n+end subroutine\n+\n+subroutine this_image_check()\n+  integer,save :: a(1,2,3,5)[0:3,*]\n+  integer :: j\n+  integer,save :: z(4)[*], i\n+\n+  j = this_image(a,dim=3) ! { dg-error \"not a valid codimension index\" }\n+  j = this_image(dim=3) ! { dg-error \"DIM argument without ARRAY argument\" }\n+  i = image_index(i, [ 1 ]) ! { dg-error \"Expected coarray variable\" }\n+  i = image_index(z, 2) ! { dg-error \"must be a rank one array\" }\n+\n+end subroutine this_image_check"}, {"sha": "969d4911caa079adff72d9e9de72a5543f4cda5d", "filename": "gcc/testsuite/gfortran.dg/coarray_11.f90", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f002ed7020b343935c2b84801dd54a4a64ae3a/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_11.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f002ed7020b343935c2b84801dd54a4a64ae3a/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_11.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_11.f90?ref=64f002ed7020b343935c2b84801dd54a4a64ae3a", "patch": "@@ -0,0 +1,56 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=single -fdump-tree-original\" }\n+!\n+! PR fortran/18918\n+!\n+! Coarray intrinsics\n+!\n+\n+subroutine image_idx_test1()\n+  INTEGER,save :: array[2,-1:4,8,*]\n+  WRITE (*,*) IMAGE_INDEX (array, [2,0,3,1])\n+  if (IMAGE_INDEX (array, [1,-1,1,1]) /= 1) call not_existing()\n+  if (IMAGE_INDEX (array, [2,-1,1,1]) /= 0) call not_existing()\n+  if (IMAGE_INDEX (array, [1,-1,1,2]) /= 0) call not_existing()\n+end subroutine\n+\n+subroutine this_image_check()\n+  integer,save :: a(1,2,3,5)[0:3,*]\n+  integer :: j\n+  if (this_image() /= 1) call not_existing()\n+  if (this_image(a,dim=1) /= 0) call not_existing()\n+  if (this_image(a,dim=2) /= 1) call not_existing()\n+end subroutine this_image_check\n+\n+subroutine othercheck()\n+real,save :: a(5)[2,*]\n+complex,save :: c[4:5,6,9:*]\n+integer,save :: i, j[*]\n+dimension :: b(3)\n+codimension :: b[5:*]\n+dimension :: h(9:10)\n+codimension :: h[8:*]\n+save :: b,h\n+if (this_image() /= 1) call not_existing()\n+if (num_images() /= 1) call not_existing()\n+if(any(this_image(coarray=a) /= [ 1, 1 ])) call not_existing()\n+if(any(this_image(c) /= [4,1,9])) call not_existing()\n+if(this_image(c, dim=3) /= 9) call not_existing()\n+if(ubound(b,dim=1) /= 3 .or. this_image(coarray=b,dim=1) /= 5) call not_existing()\n+if(ubound(h,dim=1) /= 10 .or. this_image(h,dim=1) /= 8) call not_existing()\n+end subroutine othercheck\n+\n+subroutine andanother()\n+integer,save :: a(1)[2:9,4,-3:5,0:*]\n+print *, lcobound(a)\n+print *, lcobound(a,dim=3,kind=8)\n+print *, ucobound(a)\n+print *, ucobound(a,dim=1,kind=2)\n+if (any(lcobound(a) /= [2, 1, -3, 0])) call not_existing()\n+if (any(ucobound(a) /= [9, 4,  5, 0])) call not_existing()\n+if (lcobound(a,dim=3,kind=8) /= -3_8)  call not_existing()\n+if (ucobound(a,dim=1,kind=2) /=  9_2)  call not_existing()\n+end subroutine andanother\n+\n+! { dg-final { scan-tree-dump-times \"not_existing\" 0 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "cdfb4dc85a8442e1664f1729797b0566029d579c", "filename": "gcc/testsuite/gfortran.dg/coarray_9.f90", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64f002ed7020b343935c2b84801dd54a4a64ae3a/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64f002ed7020b343935c2b84801dd54a4a64ae3a/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_9.f90?ref=64f002ed7020b343935c2b84801dd54a4a64ae3a", "patch": "@@ -9,9 +9,10 @@\n integer :: b[*] ! { dg-error \"Coarrays disabled\" }\n \n error stop \"Error\"\n-sync all ! { dg-error \"Coarrays disabled\" }\n+sync all !  \"Coarrays disabled\"  (but error above is fatal)\n \n-critical ! { dg-error \"Coarrays disabled\" }\n-end critical ! { dg-error \"Expecting END PROGRAM statement\" }\n+critical ! \"Coarrays disabled\"  (but error above is fatal)\n+\n+end critical ! \"Expecting END PROGRAM statement\"  (but error above is fatal)\n \n end"}]}