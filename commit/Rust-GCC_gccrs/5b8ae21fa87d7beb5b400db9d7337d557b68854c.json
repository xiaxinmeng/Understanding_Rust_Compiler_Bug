{"sha": "5b8ae21fa87d7beb5b400db9d7337d557b68854c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI4YWUyMWZhODdkN2JlYjViNDAwZGI5ZDczMzdkNTU3YjY4ODU0Yw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@cygnus.com", "date": "1998-05-08T15:46:05Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1998-05-08T15:46:05Z"}, "message": "Hunk of m32r changes\n\nFrom-SVN: r19636", "tree": {"sha": "bf9756cb245c791dc1d7ea52fb2c2cf210e23056", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf9756cb245c791dc1d7ea52fb2c2cf210e23056"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b8ae21fa87d7beb5b400db9d7337d557b68854c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b8ae21fa87d7beb5b400db9d7337d557b68854c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b8ae21fa87d7beb5b400db9d7337d557b68854c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b8ae21fa87d7beb5b400db9d7337d557b68854c/comments", "author": null, "committer": null, "parents": [{"sha": "cf879efaf491d1baa09e884b2d5cf74e720a1c43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf879efaf491d1baa09e884b2d5cf74e720a1c43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf879efaf491d1baa09e884b2d5cf74e720a1c43"}], "stats": {"total": 1194, "additions": 722, "deletions": 472}, "files": [{"sha": "105e4f6d3a07da1c6f74b228cd714a1eda3f3e2d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b8ae21fa87d7beb5b400db9d7337d557b68854c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b8ae21fa87d7beb5b400db9d7337d557b68854c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5b8ae21fa87d7beb5b400db9d7337d557b68854c", "patch": "@@ -3,6 +3,54 @@ Fri May  8 18:23:08 1998  Michael Meissner  <meissner@cygnus.com>\n \t* final.c (final_scan_insn): Call fatal_insn instead of abort if\n \twe could not split an insn when required to.\n \n+\t* m32r.md ({add,sub}di3): Add define_splits and appropriate low\n+\tlevel insns.\n+\t(peepholes): Disable peepholes that call dead_or_set_p.\n+\t(movsi): Rewrite to handle addresses better after last change.\n+\tAdd define_split to split load of addresses in large/medium modes.\n+\t(prologue): Call m32r_expand_prologue.\n+\t(movsi_{push,pop}): Generators for push/pop.\n+\t(movsi): Support PRE_{INC,DEC}, POST_INC.\n+\t(mov{di,df}): Rewrite.  Always split the insns.\n+\t(movsf): Add define_split to get register load in correct mode.\n+\t(cmp_ne_small_const_insn): Use 'N' instead of 'S' constraint.\n+\t(attributes): Rewrite attributes so that type indicates both the\n+\ttype and the length of the insn directly.\n+\t(all insns): Change to use new type attributes.\n+\t(debug): New attribute to convey whether -mdebug was used.\n+\t(opt_space): New attribute to convey whether -Os was used.\n+\t(function units): Loads are 3 cycles, not 2.  Better classify all\n+\tinsns into short/long.\n+\t(load/store/extend insns): Add separate case for load/store\n+\tindirect operations without an offset.\n+\t(divsi3): Division is a long operation, not short.\n+\n+\t* m32r.h (LEGITIMATE_LO_SUM_ADDRESS_P): Do not allow LO_SUM for\n+\tmodes > 1 word.\n+\t(GO_IF_MODE_DEPENDENT_ADDRESS): LO_SUM is now mode dependent.\n+\t(CONST_OK_FOR_LETTER_P): Make 'N' handle reverse 8 bit compares.\n+\t(EXTRA_CONSTRAINT): Remove 'S' special support.  Add 'U' for\n+\toperands with PRE_{INC,DEC}, POST_INC.\n+\t(FUNCTION_PROFILER): Call abort instead of doing nothing.\n+\t(GO_IF_LEGITIMATE_ADDRESS): Allow PRE_{INC,DEC}, POST_INC of\n+\tSImode variables.\n+\t(gen_split_move_double): Declare.\n+\t(EXTRA_CONSTRAINT): Add 'T' for memory reference with no offset.\n+\n+\t* m32r.c (gen_split_move_double): Fix typo.  Also, don't call\n+\temit_move_insn, build up SET's directly.\n+\t(toplevel): Include system.h, not stdio.h.\n+\t(move_double_src_operand): Allow any DF or DI mode constant.\n+\t(gen_split_move_double): Split moves of DI or DF values into the\n+\tappropriate moves, loads, or stores.  Don't handle use of auto\n+\tinc/dec if using dead index.  Do handle overlapping moves, etc.\n+\t(m32r_frame_info): Remove prologue_size field.\n+\t(m32r_compute_frame_size): Don't calculate prologue size.\n+\t(m32r_output_function_prologue): Change to pretty much a NOP.\n+\t(m32r_expand_prologue): Expand prologue as a series of INSNs.\n+\t(m32r_print_operand): Add support for PRE_{INC,DEC}, POST_INC.\n+\t(m32r_print_operand_address): Ditto.\n+\t\n Fri May  8 14:13:21 1998  H.J. Lu  (hjl@gnu.org)\n \n \t* reload1.c (emit_reload_insns): When performing expensive"}, {"sha": "a667dbd9eac6448551b6ab3f354d968898908c5f", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 222, "deletions": 113, "changes": 335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b8ae21fa87d7beb5b400db9d7337d557b68854c/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b8ae21fa87d7beb5b400db9d7337d557b68854c/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=5b8ae21fa87d7beb5b400db9d7337d557b68854c", "patch": "@@ -19,7 +19,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n-#include <stdio.h>\n+#include \"system.h\"\n #include \"tree.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n@@ -729,10 +729,7 @@ move_double_src_operand (op, int_mode)\n     {\n     case CONST_INT :\n     case CONST_DOUBLE :\n-      if (mode == DFmode)\n-\treturn easy_df_const (op);\n-      else\n-\treturn easy_di_const (op);\n+      return 1;\n     case REG :\n       return register_operand (op, mode);\n     case SUBREG :\n@@ -1114,6 +1111,123 @@ gen_compare (int_code, x, y, need_compare)\n \n   return gen_rtx (branch_code, VOIDmode, cc_reg, CONST0_RTX (mode));\n }\n+\f\n+/* Split a 2 word move (DI or DF) into component parts.  */\n+\n+rtx\n+gen_split_move_double (operands)\n+     rtx operands[];\n+{\n+  enum machine_mode mode = GET_MODE (operands[0]);\n+  rtx dest = operands[0];\n+  rtx src  = operands[1];\n+  rtx val;\n+\n+  start_sequence ();\n+  if (GET_CODE (dest) == REG || GET_CODE (dest) == SUBREG)\n+    {\n+      /* reg = reg */\n+      if (GET_CODE (src) == REG || GET_CODE (src) == SUBREG)\n+\t{\n+\t  /* We normally copy the low-numbered register first.  However, if\n+\t     the first register operand 0 is the same as the second register of\n+\t     operand 1, we must copy in the opposite order.  */\n+\t  int reverse = (REGNO (operands[0]) == REGNO (operands[1]) + 1);\n+\t  emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t\t  operand_subword (dest, reverse, TRUE, mode),\n+\t\t\t\t  operand_subword (src,  reverse, TRUE, mode)));\n+\n+\t  emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t\t  operand_subword (dest, !reverse, TRUE, mode),\n+\t\t\t\t  operand_subword (src,  !reverse, TRUE, mode)));\n+\t}\n+\n+      /* reg = constant */\n+      else if (GET_CODE (src) == CONST_INT || GET_CODE (src) == CONST_DOUBLE)\n+\t{\n+\t  rtx words[2];\n+\t  split_double (src, &words[0], &words[1]);\n+\t  emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t\t  operand_subword (dest, 0, TRUE, mode),\n+\t\t\t\t  words[0]));\n+\n+\t  emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t\t  operand_subword (dest, 1, TRUE, mode),\n+\t\t\t\t  words[1]));\n+\t}\n+\n+      /* reg = mem */\n+      else if (GET_CODE (src) == MEM)\n+\t{\n+\t  /* If the high-address word is used in the address, we must load it\n+\t     last.  Otherwise, load it first.  */\n+\t  rtx addr = XEXP (src, 0);\n+\t  int reverse = (refers_to_regno_p (REGNO (dest), REGNO (dest)+1,\n+\t\t\t\t\t    addr, 0) != 0);\n+\n+\t  /* We used to optimize loads from single registers as\n+\n+\t\tld r1,r3+; ld r2,r3\n+\n+\t     if r3 were not used subsequently.  However, the REG_NOTES aren't\n+\t     propigated correctly by the reload phase, and it can cause bad\n+\t     code to be generated.  We could still try:\n+\n+\t\tld r1,r3+; ld r2,r3; addi r3,-4\n+\n+\t     which saves 2 bytes and doesn't force longword alignment.  */\n+\t  emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t\t  operand_subword (dest, reverse, TRUE, mode),\n+\t\t\t\t  change_address (src, SImode,\n+\t\t\t\t\t\t  plus_constant (addr,\n+\t\t\t\t\t\t\t\t reverse * UNITS_PER_WORD))));\n+\n+\t  emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t\t  operand_subword (dest, !reverse, TRUE, mode),\n+\t\t\t\t  change_address (src, SImode,\n+\t\t\t\t\t\t  plus_constant (addr,\n+\t\t\t\t\t\t\t\t (!reverse) * UNITS_PER_WORD))));\n+\t}\n+\n+      else\n+\tabort ();\n+    }\n+\n+  /* mem = reg */\n+  /* We used to optimize loads from single registers as\n+\n+\tst r1,r3; st r2,+r3\n+\n+     if r3 were not used subsequently.  However, the REG_NOTES aren't\n+     propigated correctly by the reload phase, and it can cause bad\n+     code to be generated.  We could still try:\n+\n+\tst r1,r3; st r2,+r3; addi r3,-4\n+\n+     which saves 2 bytes and doesn't force longword alignment.  */\n+  else if (GET_CODE (dest) == MEM\n+\t   && (GET_CODE (src) == REG || GET_CODE (src) == SUBREG))\n+    {\n+      rtx addr = XEXP (dest, 0);\n+\n+      emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t      change_address (dest, SImode, addr),\n+\t\t\t      operand_subword (src, 0, TRUE, mode)));\n+\n+      emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t      change_address (dest, SImode,\n+\t\t\t\t\t      plus_constant (addr, UNITS_PER_WORD)),\n+\t\t\t      operand_subword (src, 1, TRUE, mode)));\n+    }\n+\n+  else\n+    abort ();\n+\n+  val = gen_sequence ();\n+  end_sequence ();\n+  return val;\n+}\n+\n \f\n /* Implements the FUNCTION_ARG_PARTIAL_NREGS macro.  */\n \n@@ -1298,7 +1412,6 @@ struct m32r_frame_info\n   unsigned int args_size;\t/* # bytes that outgoing arguments take up */\n   unsigned int reg_size;\t/* # bytes needed to store regs */\n   unsigned int var_size;\t/* # bytes that variables take up */\n-  unsigned int prolog_size;\t/* # bytes that the prologue takes up */\n   unsigned int gmask;\t\t/* mask of saved gp registers */\n   unsigned int save_fp;\t\t/* nonzero if fp must be saved */\n   unsigned int save_lr;\t\t/* nonzero if lr (return addr) must be saved */\n@@ -1322,7 +1435,7 @@ static struct m32r_frame_info zero_frame_info;\n  && (regs_ever_live[regno] && (!call_used_regs[regno] || interrupt_p)))\n \n #define MUST_SAVE_FRAME_POINTER (regs_ever_live[FRAME_POINTER_REGNUM])\n-#define MUST_SAVE_RETURN_ADDR (regs_ever_live[RETURN_ADDR_REGNUM])\n+#define MUST_SAVE_RETURN_ADDR (regs_ever_live[RETURN_ADDR_REGNUM] || profile_flag)\n \n #define SHORT_INSN_SIZE 2\t/* size of small instructions */\n #define LONG_INSN_SIZE 4\t/* size of long instructions */\n@@ -1338,7 +1451,7 @@ m32r_compute_frame_size (size)\n {\n   int regno;\n   unsigned int total_size, var_size, args_size, pretend_size, extra_size;\n-  unsigned int reg_size, prolog_size, frame_size;\n+  unsigned int reg_size, frame_size;\n   unsigned int gmask;\n   enum m32r_function_type fn_type;\n   int interrupt_p;\n@@ -1349,7 +1462,6 @@ m32r_compute_frame_size (size)\n   extra_size\t= FIRST_PARM_OFFSET (0);\n   total_size\t= extra_size + pretend_size + args_size + var_size;\n   reg_size\t= 0;\n-  prolog_size\t= 0;\n   gmask\t\t= 0;\n \n   /* See if this is an interrupt handler.  Call used registers must be saved\n@@ -1379,41 +1491,15 @@ m32r_compute_frame_size (size)\n      handler will do the right thing if this changes total_size.  */\n   total_size = M32R_STACK_ALIGN (total_size);\n \n-  /* Calculate prologue size.  Obviously any changes to\n-     m32r_output_function_prologue must be mirrored here.  */\n-  if (pretend_size)\n-    prolog_size += SHORT_INSN_SIZE;\t\t/* addi sp,-pretend_size */\n-\n-  prolog_size += SHORT_INSN_SIZE * (reg_size / UNITS_PER_WORD);\t/* pushes */\n   frame_size = total_size - (pretend_size + reg_size);\n \n-  if (frame_size == 0)\n-    ;\t\t\t\t\t\t/* nothing to do */\n-  else if (frame_size <= 128)\n-    prolog_size += SHORT_INSN_SIZE;\t\t/* addi sp,-<frame> */\n-  else\n-    {\n-      if ((prolog_size % LONG_INSN_SIZE) != 0)\n-\tprolog_size += SHORT_INSN_SIZE;\t\t/* nop */\n-\n-      if (frame_size <= 32768)\n-\tprolog_size += LONG_INSN_SIZE;\t\t/* add3 sp,sp,-<frame> */\n-      else\n-\tprolog_size += (LONG_INSN_SIZE\t\t/* ld24 tmp,<frame>/sub sp,tmp */\n-\t\t\t+ SHORT_INSN_SIZE);\n-    }\n-\n-  if (frame_pointer_needed)\n-    prolog_size += SHORT_INSN_SIZE;\t\t/* mv fp,sp */\n-\n   /* Save computed information.  */\n   current_frame_info.total_size   = total_size;\n   current_frame_info.extra_size   = extra_size;\n   current_frame_info.pretend_size = pretend_size;\n   current_frame_info.var_size     = var_size;\n   current_frame_info.args_size    = args_size;\n   current_frame_info.reg_size\t  = reg_size;\n-  current_frame_info.prolog_size  = prolog_size;\n   current_frame_info.gmask\t  = gmask;\n   current_frame_info.initialized  = reload_completed;\n \n@@ -1431,74 +1517,37 @@ m32r_first_insn_address ()\n   if (! current_frame_info.initialized)\n     m32r_compute_frame_size (get_frame_size ());\n \n-  return current_frame_info.prolog_size;\n+  return 0;\n }\n \f\n-/* Set up the stack and frame pointer (if desired) for the function.\n-   Note, if this is changed, you need to mirror the changes in\n-   m32r_compute_frame_size which calculates the prolog size.  */\n+/* Expand the m32r prologue as a series of insns.  */\n \n void\n-m32r_output_function_prologue (file, size)\n-     FILE * file;\n-     int    size;\n+m32r_expand_prologue ()\n {\n   int regno;\n-  int total_size, frame_size;\n-  char *sp_str = reg_names[STACK_POINTER_REGNUM];\n-  char *fp_str = reg_names[FRAME_POINTER_REGNUM];\n+  int frame_size;\n   unsigned int gmask = current_frame_info.gmask;\n-  enum m32r_function_type fn_type = m32r_compute_function_type (current_function_decl);\n \n-  /* If this is an interrupt handler, mark it as such.  */\n-  if (M32R_INTERRUPT_P (fn_type))\n-    {\n-      fprintf (file, \"\\t%s interrupt handler\\n\",\n-\t       ASM_COMMENT_START);\n-    }\n-\n-  total_size = (! current_frame_info.initialized\n-\t\t? m32r_compute_frame_size (size)\n-\t\t: current_frame_info.total_size);\n+  if (! current_frame_info.initialized)\n+    m32r_compute_frame_size (get_frame_size ());\n \n-  /* This is only for the human reader.  */\n-  fprintf (file,\n-\t   \"\\t%s BEGIN PROLOGUE, vars= %d, regs= %d, args= %d, extra= %d, prolog= %d\\n\",\n-\t   ASM_COMMENT_START,\n-\t   current_frame_info.var_size,\n-\t   current_frame_info.reg_size / 4,\n-\t   current_frame_info.args_size,\n-\t   current_frame_info.extra_size,\n-\t   current_frame_info.prolog_size);\n+  gmask = current_frame_info.gmask;\n \n   /* These cases shouldn't happen.  Catch them now.  */\n-  if (total_size == 0 && gmask)\n+  if (current_frame_info.total_size == 0 && gmask)\n     abort ();\n \n-#if 1\n   /* Allocate space for register arguments if this is a variadic function.  */\n   if (current_frame_info.pretend_size != 0)\n-    fprintf (file, \"\\taddi %s,%s%d\\n\",\n-\t     sp_str, IMMEDIATE_PREFIX,\n-\t     -current_frame_info.pretend_size);\n-#else\n-  /* If there are unnamed args in registers, save them.  */\n-  if (current_function_stdarg || current_function_varargs)\n-    {\n-      int i;\n-      fprintf (file, \"\\taddi %s,%s%d\\n\",\n-\t       sp_str, IMMEDIATE_PREFIX,\n-\t       - M32R_MAX_PARM_REGS * UNITS_PER_WORD);\n-      for (i = 0; i < M32R_MAX_PARM_REGS; ++i)\n-\tfprintf (file, \"\\tst %s,@(sp,%d)\\n\",\n-\t\t reg_names[i], i * UNITS_PER_WORD);\n-    }\n-#endif\n+    emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t   stack_pointer_rtx,\n+\t\t\t   GEN_INT (-current_frame_info.pretend_size)));\n \n   /* Save any registers we need to and set up fp.  */\n \n   if (current_frame_info.save_fp)\n-    fprintf (file, \"\\tpush %s\\n\", fp_str);\n+    emit_insn (gen_movsi_push (stack_pointer_rtx, frame_pointer_rtx));\n \n   gmask &= ~(FRAME_POINTER_MASK | RETURN_ADDR_MASK);\n \n@@ -1507,33 +1556,68 @@ m32r_output_function_prologue (file, size)\n   for (regno = 0; regno <= M32R_MAX_INT_REGS; ++regno)\n     {\n       if ((gmask & (1 << regno)) != 0)\n-\tfprintf (file, \"\\tpush %s\\n\", reg_names[regno]);\n+\temit_insn (gen_movsi_push (stack_pointer_rtx,\n+\t\t\t\t   gen_rtx_REG (Pmode, regno)));\n     }\n \n   if (current_frame_info.save_lr)\n-    fprintf (file, \"\\tpush %s\\n\", reg_names[RETURN_ADDR_REGNUM]);\n+    emit_insn (gen_movsi_push (stack_pointer_rtx,\n+\t\t\t       gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM)));\n \n   /* Allocate the stack frame.  */\n-  frame_size = total_size - (current_frame_info.pretend_size\n-\t\t\t     + current_frame_info.reg_size);\n+  frame_size = (current_frame_info.total_size\n+\t\t- (current_frame_info.pretend_size\n+\t\t   + current_frame_info.reg_size));\n+\n   if (frame_size == 0)\n     ; /* nothing to do */\n-  else if (frame_size <= 128)\n-    fprintf (file, \"\\taddi %s,%s%d\\n\",\n-\t     sp_str, IMMEDIATE_PREFIX, -frame_size);\n   else if (frame_size <= 32768)\n-    fprintf (file, \"\\tadd3 %s,%s,%s%d\\n\",\n-\t     sp_str, sp_str, IMMEDIATE_PREFIX, -frame_size);\n+    emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t   GEN_INT (-frame_size)));\n   else\n-    fprintf (file, \"\\tld24 %s,%s%d\\n\\tsub %s,%s\\n\",\n-\t     reg_names[PROLOGUE_TMP_REGNUM],\n-\t     IMMEDIATE_PREFIX, frame_size,\n-\t     sp_str, reg_names[PROLOGUE_TMP_REGNUM]);\n+    {\n+      rtx tmp = gen_rtx_REG (Pmode, PROLOGUE_TMP_REGNUM);\n+      emit_insn (gen_movsi (tmp, GEN_INT (frame_size)));\n+      emit_insn (gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx, tmp));\n+    }\n \n   if (frame_pointer_needed)\n-    fprintf (file, \"\\tmv %s,%s\\n\", fp_str, sp_str);\n+    emit_insn (gen_movsi (frame_pointer_rtx, stack_pointer_rtx));\n+\n+  if (profile_flag || profile_block_flag)\n+    emit_insn (gen_blockage ());\n+}\n+\n+\f\n+/* Set up the stack and frame pointer (if desired) for the function.\n+   Note, if this is changed, you need to mirror the changes in\n+   m32r_compute_frame_size which calculates the prolog size.  */\n+\n+void\n+m32r_output_function_prologue (file, size)\n+     FILE * file;\n+     int    size;\n+{\n+  enum m32r_function_type fn_type = m32r_compute_function_type (current_function_decl);\n+\n+  /* If this is an interrupt handler, mark it as such.  */\n+  if (M32R_INTERRUPT_P (fn_type))\n+    {\n+      fprintf (file, \"\\t%s interrupt handler\\n\",\n+\t       ASM_COMMENT_START);\n+    }\n+\n+  if (! current_frame_info.initialized)\n+    m32r_compute_frame_size (size);\n \n-  fprintf (file, \"\\t%s END PROLOGUE\\n\", ASM_COMMENT_START);\n+  /* This is only for the human reader.  */\n+  fprintf (file,\n+\t   \"\\t%s PROLOGUE, vars= %d, regs= %d, args= %d, extra= %d\\n\",\n+\t   ASM_COMMENT_START,\n+\t   current_frame_info.var_size,\n+\t   current_frame_info.reg_size / 4,\n+\t   current_frame_info.args_size,\n+\t   current_frame_info.extra_size);\n }\n \f\n /* Do any necessary cleanup after a function to restore stack, frame,\n@@ -1695,6 +1779,8 @@ m32r_print_operand (file, x, code)\n      rtx    x;\n      int    code;\n {\n+  rtx addr;\n+\n   switch (code)\n     {\n     case 'R' :\n@@ -1866,16 +1952,34 @@ m32r_print_operand (file, x, code)\n       break;\n \n     case MEM :\n-      fprintf (file, \"@(\");\n-      if (GET_CODE (XEXP (x, 0)) == PRE_INC)\n-\toutput_address (plus_constant (XEXP (XEXP (x, 0), 0),\n-\t\t\t\t       GET_MODE_SIZE (GET_MODE (x))));\n-      else if (GET_CODE (XEXP (x, 0)) == PRE_DEC)\n-\toutput_address (plus_constant (XEXP (XEXP (x, 0), 0),\n-\t\t\t\t       - GET_MODE_SIZE (GET_MODE (x))));\n+      addr = XEXP (x, 0);\n+      if (GET_CODE (addr) == PRE_INC)\n+\t{\n+\t  if (GET_CODE (XEXP (addr, 0)) != REG)\n+\t    abort ();\n+\n+\t  fprintf (file, \"@+%s\", reg_names[REGNO (XEXP (addr, 0))]);\n+\t}\n+      else if (GET_CODE (addr) == PRE_DEC)\n+\t{\n+\t  if (GET_CODE (XEXP (addr, 0)) != REG)\n+\t    abort ();\n+\n+\t  fprintf (file, \"@-%s\", reg_names[REGNO (XEXP (addr, 0))]);\n+\t}\n+      else if (GET_CODE (addr) == POST_INC)\n+\t{\n+\t  if (GET_CODE (XEXP (addr, 0)) != REG)\n+\t    abort ();\n+\n+\t  fprintf (file, \"@%s+\", reg_names[REGNO (XEXP (addr, 0))]);\n+\t}\n       else\n-\toutput_address (XEXP (x, 0));\n-      fputc (')', file);\n+\t{\n+\t  fputs (\"@(\", file);\n+\t  output_address (XEXP (x, 0));\n+\t  fputc (')', file);\n+\t}\n       break;\n \n     case CONST_DOUBLE :\n@@ -1975,11 +2079,16 @@ m32r_print_operand_address (file, addr)\n       fputs (reg_names[REGNO (XEXP (addr, 0))], file);\n       break;\n \n-    case PRE_INC :\n-    case PRE_DEC :\n-      /* We shouldn't get here as we've lost the mode of the memory object\n-\t (which says how much to inc/dec by).  */\n-      abort ();\n+    case PRE_INC :\t/* Assume SImode */\n+      fprintf (file, \"+%s\", reg_names[REGNO (XEXP (addr, 0))]);\n+      break;\n+\n+    case PRE_DEC :\t/* Assume SImode */\n+      fprintf (file, \"-%s\", reg_names[REGNO (XEXP (addr, 0))]);\n+      break;\n+\n+    case POST_INC :\t/* Assume SImode */\n+      fprintf (file, \"%s+\", reg_names[REGNO (XEXP (addr, 0))]);\n       break;\n \n     default :"}, {"sha": "4e14770a2491f21fdab66e434164835843b2f30d", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 93, "deletions": 48, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b8ae21fa87d7beb5b400db9d7337d557b68854c/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b8ae21fa87d7beb5b400db9d7337d557b68854c/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=5b8ae21fa87d7beb5b400db9d7337d557b68854c", "patch": "@@ -606,25 +606,26 @@ extern enum reg_class m32r_regno_reg_class[FIRST_PSEUDO_REGISTER];\n #define INT32_P(X) ((X) >= (-(HOST_WIDE_INT) 0x7fffffff - 1) \\\n \t\t    && (X) <= (unsigned HOST_WIDE_INT) 0xffffffff)\n #define UINT5_P(X) ((unsigned) (X) < 32)\n+#define INVERTED_SIGNED_8BIT(VAL) ((VAL) >= -127 && (VAL) <= 128)\n \n-#define CONST_OK_FOR_LETTER_P(VALUE, C) \\\n-((C) == 'I' ? INT8_P (VALUE)\t\t\\\n- : (C) == 'J' ? INT16_P (VALUE)\t\\\n- : (C) == 'K' ? UINT16_P (VALUE)\t\\\n- : (C) == 'L' ? UPPER16_P (VALUE)\t\\\n- : (C) == 'M' ? UINT24_P (VALUE)\t\\\n- : (C) == 'N' ? INT32_P (VALUE)\t\t\\\n- : (C) == 'O' ? UINT5_P (VALUE)\t\t\\\n- : (C) == 'P' ? CMP_INT16_P (VALUE)\t\\\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\t\\\n+((C) == 'I' ? INT8_P (VALUE)\t\t\t\t\t\t\\\n+ : (C) == 'J' ? INT16_P (VALUE)\t\t\t\t\t\t\\\n+ : (C) == 'K' ? UINT16_P (VALUE)\t\t\t\t\t\\\n+ : (C) == 'L' ? UPPER16_P (VALUE)\t\t\t\t\t\\\n+ : (C) == 'M' ? UINT24_P (VALUE)\t\t\t\t\t\\\n+ : (C) == 'N' ? INVERTED_SIGNED_8BIT (VALUE)\t\t\t\t\\\n+ : (C) == 'O' ? UINT5_P (VALUE)\t\t\t\t\t\t\\\n+ : (C) == 'P' ? CMP_INT16_P (VALUE)\t\t\t\t\t\\\n  : 0)\n \n /* Similar, but for floating constants, and defining letters G and H.\n    Here VALUE is the CONST_DOUBLE rtx itself.\n    For the m32r, handle a few constants inline.\n    ??? We needn't treat DI and DF modes differently, but for now we do.  */\n #define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) \\\n-((C) == 'G' ? easy_di_const (VALUE) \\\n- : (C) == 'H' ? easy_df_const (VALUE) \\\n+((C) == 'G' ? easy_di_const (VALUE)\t\t\t\t\t\\\n+ : (C) == 'H' ? easy_df_const (VALUE)\t\t\t\t\t\\\n  : 0)\n \n /* A C expression that defines the optional machine-dependent constraint\n@@ -635,19 +636,25 @@ extern enum reg_class m32r_regno_reg_class[FIRST_PSEUDO_REGISTER];\n    be 0 regardless of VALUE.  */\n /* Q is for symbolic addresses loadable with ld24.\n    R is for symbolic addresses when ld24 can't be used.\n-   S is for an 8 bit signed integer in the range +128 to -127 */\n-\n-#define INVERTED_SIGNED_8BIT(VAL) ((VAL) >= -127 && (VAL) <= 128)\n-\n-#define EXTRA_CONSTRAINT(VALUE, C) \\\n-((C) == 'Q' \\\n- ? ((TARGET_ADDR24 && GET_CODE (VALUE) == LABEL_REF) \\\n-    || addr24_operand (VALUE, VOIDmode)) \\\n- : (C) == 'R' \\\n- ? ((TARGET_ADDR32 && GET_CODE (VALUE) == LABEL_REF) \\\n-    || addr32_operand (VALUE, VOIDmode)) \\\n- : (C) == 'S' \\\n- ?  ((GET_CODE (VALUE) == CONST_INT) && INVERTED_SIGNED_8BIT (INTVAL (VALUE))) \\\n+   S is unused.\n+   T is for indirect of a pointer.\n+   U is for pushes and pops of the stack pointer.  */\n+\n+#define EXTRA_CONSTRAINT(VALUE, C)\t\t\t\t\t\\\n+((C) == 'Q'\t\t\t\t\t\t\t\t\\\n+ ? ((TARGET_ADDR24 && GET_CODE (VALUE) == LABEL_REF)\t\t\t\\\n+    || addr24_operand (VALUE, VOIDmode))\t\t\t\t\\\n+ : (C) == 'R'\t\t\t\t\t\t\t\t\\\n+ ? ((TARGET_ADDR32 && GET_CODE (VALUE) == LABEL_REF)\t\t\t\\\n+    || addr32_operand (VALUE, VOIDmode))\t\t\t\t\\\n+ : (C) == 'S'\t\t\t\t\t\t\t\t\\\n+ ? 0\t\t\t\t\t\t\t\t\t\\\n+ : (C) == 'T'\t\t\t\t\t\t\t\t\\\n+ ?  (GET_CODE (VALUE) == MEM\t\t\t\t\t\t\\\n+     && memreg_operand (VALUE, GET_MODE (VALUE)))\t\t\t\\\n+ : (C) == 'U'\t\t\t\t\t\t\t\t\\\n+ ?  (GET_CODE (VALUE) == MEM\t\t\t\t\t\t\\\n+     && PUSH_POP_P (GET_MODE (VALUE), XEXP (VALUE, 0)))\t\t\t\\\n  : 0)\n \f\n /* Stack layout and stack pointer usage.  */\n@@ -1069,7 +1076,7 @@ m32r_output_function_epilogue (FILE, SIZE)\n \n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n-#define FUNCTION_PROFILER(FILE, LABELNO)\n+#define FUNCTION_PROFILER(FILE, LABELNO) abort ()\n \f\n /* Trampolines.  */\n \n@@ -1184,24 +1191,37 @@ do { \\\n (GET_CODE (X) == CONST_INT && INT16_P (INTVAL (X)))\n \n /* local to this file */\n-#define LEGITIMATE_OFFSET_ADDRESS_P(MODE, X) \\\n-(GET_CODE (X) == PLUS\t\t\t\t\\\n- && RTX_OK_FOR_BASE_P (XEXP (X, 0))\t\t\\\n+#define LEGITIMATE_OFFSET_ADDRESS_P(MODE, X)\t\t\t\t\\\n+(GET_CODE (X) == PLUS\t\t\t\t\t\t\t\\\n+ && RTX_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\t\\\n  && RTX_OK_FOR_OFFSET_P (XEXP (X, 1)))\n \n /* local to this file */\n-#define LEGITIMATE_LO_SUM_ADDRESS_P(MODE, X) \\\n-(GET_CODE (X) == LO_SUM\t\t\t\t\\\n- && RTX_OK_FOR_BASE_P (XEXP (X, 0))\t\t\\\n+/* For LO_SUM addresses, do not allow them if the MODE is > 1 word,\n+   since more than one instruction will be required.  */\n+#define LEGITIMATE_LO_SUM_ADDRESS_P(MODE, X)\t\t\t\t\\\n+(GET_CODE (X) == LO_SUM\t\t\t\t\t\t\t\\\n+ && (MODE != BLKmode && GET_MODE_SIZE (MODE) <= UNITS_PER_WORD)\t\t\\\n+ && RTX_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\t\\\n  && CONSTANT_P (XEXP (X, 1)))\n \n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) \\\n-{ if (RTX_OK_FOR_BASE_P (X))\t\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n-  if (LEGITIMATE_OFFSET_ADDRESS_P ((MODE), (X)))\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n-  if (LEGITIMATE_LO_SUM_ADDRESS_P ((MODE), (X)))\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n+/* local to this file */\n+/* Memory address that is a push/pop of the stack pointer.  */\n+#define PUSH_POP_P(MODE, X)\t\t\t\t\t\t\\\n+((MODE) == SImode\t\t\t\t\t\t\t\\\n+ && (GET_CODE (X) == POST_INC\t\t\t\t\t\t\\\n+     || GET_CODE (X) == PRE_INC\t\t\t\t\t\t\\\n+     || GET_CODE (X) == PRE_DEC))\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n+{ if (RTX_OK_FOR_BASE_P (X))\t\t\t\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\t\t\\\n+  if (LEGITIMATE_OFFSET_ADDRESS_P ((MODE), (X)))\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\t\t\\\n+  if (LEGITIMATE_LO_SUM_ADDRESS_P ((MODE), (X)))\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\t\t\\\n+  if (PUSH_POP_P ((MODE), (X)))\t\t\t\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\t\t\\\n }\n \n /* Try machine-dependent ways of modifying an illegitimate address\n@@ -1223,14 +1243,13 @@ do { \\\n \n /* Go to LABEL if ADDR (a legitimate address expression)\n    has an effect that depends on the machine mode it is used for.  */\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL) \\\n-do {\t\t\t\t\t\\\n-  if (GET_CODE (ADDR) == PRE_DEC)\t\\\n-    goto LABEL;\t\t\t\t\\\n-  if (GET_CODE (ADDR) == PRE_INC)\t\\\n-    goto LABEL;\t\t\t\t\\\n-  if (GET_CODE (ADDR) == POST_INC)\t\\\n-    goto LABEL;\t\t\t\t\\\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE (ADDR) == PRE_DEC\t\t\t\t\t\\\n+      || GET_CODE (ADDR) == PRE_INC\t\t\t\t\t\\\n+      || GET_CODE (ADDR) == POST_INC\t\t\t\t\t\\\n+      || GET_CODE (ADDR) == LO_SUM)\t\t\t\t\t\\\n+    goto LABEL;\t\t\t\t\t\t\t\t\\\n } while (0)\n \f\n /* Condition code usage.  */\n@@ -1286,7 +1305,7 @@ do {\t\t\t\t\t\\\n /* Compute the cost of moving data between registers and memory.  */\n /* Memory is 3 times as expensive as registers.\n    ??? Is that the right way to look at it?  */\n-#define MEMORY_MOVE_COST(MODE,CLASS,IN) \\\n+#define MEMORY_MOVE_COST(MODE,CLASS,IN_P) \\\n (GET_MODE_SIZE (MODE) <= UNITS_PER_WORD ? 6 : 12)\n \n /* The cost of a branch insn.  */\n@@ -1355,7 +1374,10 @@ do {\t\t\t\t\t\\\n #define HAIFA_P 0\n #endif\n \n-/* Indicate how many instructions can be issued at the same time.  */\n+/* Indicate how many instructions can be issued at the same time.\n+   This is 1/2 of a lie.  The m32r can issue only 1 long insn at\n+   once, but 2.  However doing so allows the scheduler to group\n+   the two short insns together.  */\n #define ISSUE_RATE 2\n \n /* When the `length' insn attribute is used, this macro specifies the\n@@ -1635,6 +1657,27 @@ do {\t\t\t\t\t\t\t\\\n   fprintf (FILE, \"%s%s\", USER_LABEL_PREFIX, real_name);\t\\\n } while (0)           \n \n+/* CYGNUS LOCAL -- m32rx/meissner */\n+/* For the m32r if -Os, don't force line number label to begin\n+   at the beginning of the word.  */\n+\n+#undef\tASM_OUTPUT_SOURCE_LINE\n+#define ASM_OUTPUT_SOURCE_LINE(file, line)\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    static int sym_lineno = 1;\t\t\t\t\t\t\\\n+    fprintf (file, \".stabn 68,0,%d,.LM%d-\",\t\t\t\t\\\n+\t     line, sym_lineno);\t\t\t\t\t\t\\\n+    assemble_name (file,\t\t\t\t\t\t\\\n+\t\t   XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));\\\n+    fprintf (file,\t\t\t\t\t\t\t\\\n+\t     (optimize_size) ? \"\\n\\t.debugsym .LM%d\\n\" : \"\\n.LM%d:\\n\",\t\\\n+\t     sym_lineno);\t\t\t\t\t\t\\\n+    sym_lineno += 1;\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+/* END CYGNUS LOCAL -- m32rx/meissner */\n+\n /* Store in OUTPUT a string (made with alloca) containing\n    an assembler-name for a local static variable named NAME.\n    LABELNO is an integer which is different for each call.  */\n@@ -1998,6 +2041,7 @@ extern int  small_insn_p\t\t\tPROTO((Rtx, int));\n extern int  large_insn_p\t\t\tPROTO((Rtx, int));\n extern int  m32r_select_cc_mode\t\t\tPROTO((int, Rtx, Rtx));\n extern Rtx  gen_compare\t\t\t\tPROTO((int, Rtx, Rtx, int));\n+extern Rtx  gen_split_move_double\t\tPROTO((Rtx *));\n extern int  function_arg_partial_nregs\t\tPROTO((CUMULATIVE_ARGS *,\n \t\t\t\t\t\t       int, Tree, int));\n extern void m32r_setup_incoming_varargs\t\tPROTO((CUMULATIVE_ARGS *,\n@@ -2008,6 +2052,7 @@ extern enum m32r_function_type m32r_compute_function_type\n \t\t\t\t\t\tPROTO((Tree));\n extern unsigned m32r_compute_frame_size\t\tPROTO((int));\n extern int  m32r_first_insn_address\t\tPROTO((void));\n+extern void m32r_expand_prologue\t\tPROTO((void));\n extern void m32r_output_function_prologue\tSTDIO_PROTO((FILE *, int));\n extern void m32r_output_function_epilogue\tSTDIO_PROTO((FILE *, int));\n extern void m32r_finalize_pic\t\t\tPROTO((void));"}, {"sha": "3c49e54954df8332233b0a801d268111cc0e661f", "filename": "gcc/config/m32r/m32r.md", "status": "modified", "additions": 359, "deletions": 311, "changes": 670, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b8ae21fa87d7beb5b400db9d7337d557b68854c/gcc%2Fconfig%2Fm32r%2Fm32r.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b8ae21fa87d7beb5b400db9d7337d557b68854c/gcc%2Fconfig%2Fm32r%2Fm32r.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.md?ref=5b8ae21fa87d7beb5b400db9d7337d557b68854c", "patch": "@@ -24,33 +24,20 @@\n ;; 0 - blockage\n ;; 1 - flush_icache\n ;; 2 - load_sda_base\n+;; 3 - setting carry in addx/subx instructions.\n \f\n ;; Insn type.  Used to default other attribute values.\n-;; move4 = 4 byte move\n (define_attr \"type\"\n-  \"move,move4,load,store,unary,binary,compare,shift,mul,div,uncond_branch,branch,call,multi,misc\"\n+  \"int2,int4,load2,load4,load8,store2,store4,store8,shift2,shift4,mul2,div4,uncond_branch,branch,call,multi,misc\"\n   (const_string \"misc\"))\n \n ;; Length in bytes.\n (define_attr \"length\" \"\"\n-  (cond [(eq_attr \"type\" \"move,unary,shift,mul,div\")\n+  (cond [(eq_attr \"type\" \"int2,load2,store2,shift2,mul2\")\n \t (const_int 2)\n \n-\t (eq_attr \"type\" \"binary\")\n-\t (if_then_else (match_operand 2 \"register_operand\" \"\")\n-\t\t       (const_int 2) (const_int 4))\n-\n-\t (eq_attr \"type\" \"compare\")\n-\t (if_then_else (match_operand 1 \"register_operand\" \"\")\n-\t\t       (const_int 2) (const_int 4))\n-\n-\t (eq_attr \"type\" \"load\")\n-\t (if_then_else (match_operand 1 \"memreg_operand\" \"\")\n-\t\t       (const_int 2) (const_int 4))\n-\n-\t (eq_attr \"type\" \"store\")\n-\t (if_then_else (match_operand 0 \"memreg_operand\" \"\")\n-\t\t       (const_int 2) (const_int 4))\n+\t (eq_attr \"type\" \"int4,load4,store4,shift4,div4\")\n+\t (const_int 4)\n \n \t (eq_attr \"type\" \"multi\")\n \t (const_int 8)\n@@ -69,10 +56,16 @@\n \n ;; Whether an instruction is 16-bit or 32-bit\n (define_attr \"insn_size\" \"short,long\"\n-  (if_then_else (eq_attr \"length\" \"2\")\n+  (if_then_else (eq_attr \"type\" \"int2,load2,store2,shift2,mul2\")\n \t\t(const_string \"short\")\n \t\t(const_string \"long\")))\n \n+(define_attr \"debug\" \"no,yes\"\n+  (const (symbol_ref \"(TARGET_DEBUG != 0)\")))\n+\n+(define_attr \"opt_size\" \"no,yes\"\n+  (const (symbol_ref \"(optimize_size != 0)\")))\n+\n (define_attr \"m32r\" \"no,yes\"\n   (const (symbol_ref \"(TARGET_M32R != 0)\")))\n \n@@ -196,39 +189,52 @@\n ;; (define_function_unit {name} {multiplicity} {simulataneity} {test}\n ;;                       {ready-delay} {issue-delay} [{conflict-list}])\n \n-;; References to loaded registers should wait a cycle.\n-;; Memory with load-delay of 1 (i.e. 2 cycle load).\n-(define_function_unit \"memory\" 1 1 (eq_attr \"type\" \"load\") 2 0)\n-\n ;; Hack to get GCC to better pack the instructions.\n ;; We pretend there is a separate long function unit that conflicts with\n ;; both the left and right 16 bit insn slots.\n \n-(define_function_unit \"left\" 1 1\n-  (eq_attr \"length\" \"2\")\n+(define_function_unit \"short\" 2 2\n+  (and (eq_attr \"m32r\" \"yes\")\n+       (and (eq_attr \"insn_size\" \"short\")\n+\t    (eq_attr \"type\" \"!load2\")))\n   1 0\n-  [(not (eq_attr \"length\" \"2\"))])\n+  [(eq_attr \"insn_size\" \"long\")])\n \n-(define_function_unit \"right\" 1 1\n-  (eq_attr \"length\" \"2\")\n-  1 0\n-  [(not (eq_attr \"length\" \"2\"))])\n+(define_function_unit \"short\" 2 2\t;; load delay of 1 clock for mem execution + 1 clock for WB\n+  (and (eq_attr \"m32r\" \"yes\")\n+       (eq_attr \"type\" \"load2\"))\n+  3 0\n+  [(eq_attr \"insn_size\" \"long\")])\n \n (define_function_unit \"long\" 1 1\n-  (not (eq_attr \"length\" \"2\"))\n+  (and (eq_attr \"m32r\" \"yes\")\n+       (and (eq_attr \"insn_size\" \"long\")\n+\t    (eq_attr \"type\" \"!load4,load8\")))\n   1 0\n-  [(eq_attr \"length\" \"2\")])\n+  [(eq_attr \"insn_size\" \"short\")])\n+\n+(define_function_unit \"long\" 1 1\t;; load delay of 1 clock for mem execution + 1 clock for WB\n+  (and (eq_attr \"m32r\" \"yes\")\n+       (and (eq_attr \"insn_size\" \"long\")\n+\t    (eq_attr \"type\" \"load4,load8\")))\n+  3 0\n+  [(eq_attr \"insn_size\" \"short\")])\n+\n+\n+\f\n+;; Instruction grouping\n \n \f\n ;; Expand prologue as RTL\n-;; ??? Unfinished.\n-\n-;(define_expand \"prologue\"\n-;  [(const_int 1)]\n-;  \"\"\n-;  \"\n-;{\n-;}\")\n+(define_expand \"prologue\"\n+  [(const_int 1)]\n+  \"\"\n+  \"\n+{\n+  m32r_expand_prologue ();\n+  DONE;\n+}\")\n+\n \f\n ;; Move instructions.\n ;;\n@@ -251,16 +257,19 @@\n }\")\n \n (define_insn \"*movqi_insn\"\n-  [(set (match_operand:QI 0 \"move_dest_operand\" \"=r,r,r,r,m\")\n-\t(match_operand:QI 1 \"move_src_operand\" \"r,I,JQR,m,r\"))]\n+  [(set (match_operand:QI 0 \"move_dest_operand\" \"=r,r,r,r,r,T,m\")\n+\t(match_operand:QI 1 \"move_src_operand\" \"r,I,JQR,T,m,r,r\"))]\n   \"register_operand (operands[0], QImode) || register_operand (operands[1], QImode)\"\n   \"@\n    mv %0,%1\n    ldi %0,%#%1\n    ldi %0,%#%1\n    ldub %0,%1\n+   ldub %0,%1\n+   stb %1,%0\n    stb %1,%0\"\n-  [(set_attr \"type\" \"move,move,move4,load,store\")])\n+  [(set_attr \"type\" \"int2,int2,int4,load2,load4,store2,store4\")\n+   (set_attr \"length\" \"2,2,4,2,4,2,4\")])\n \n (define_expand \"movhi\"\n   [(set (match_operand:HI 0 \"general_operand\" \"\")\n@@ -275,17 +284,32 @@\n }\")\n \n (define_insn \"*movhi_insn\"\n-  [(set (match_operand:HI 0 \"move_dest_operand\" \"=r,r,r,r,r,m\")\n-\t(match_operand:HI 1 \"move_src_operand\" \"r,I,JQR,K,m,r\"))]\n+  [(set (match_operand:HI 0 \"move_dest_operand\" \"=r,r,r,r,r,r,T,m\")\n+\t(match_operand:HI 1 \"move_src_operand\" \"r,I,JQR,K,T,m,r,r\"))]\n   \"register_operand (operands[0], HImode) || register_operand (operands[1], HImode)\"\n   \"@\n    mv %0,%1\n    ldi %0,%#%1\n    ldi %0,%#%1\n    ld24 %0,%#%1\n    lduh %0,%1\n+   lduh %0,%1\n+   sth %1,%0\n    sth %1,%0\"\n-  [(set_attr \"type\" \"move,move,move4,move4,load,store\")])\n+  [(set_attr \"type\" \"int2,int2,int4,int4,load2,load4,store2,store4\")\n+   (set_attr \"length\" \"2,2,4,4,2,4,2,4\")])\n+\n+(define_expand \"movsi_push\"\n+  [(set (mem:SI (pre_dec:SI (match_operand:SI 0 \"register_operand\" \"\")))\n+\t(match_operand:SI 1 \"register_operand\" \"\"))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"movsi_pop\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(mem:SI (post_inc:SI (match_operand:SI 1 \"register_operand\" \"\"))))]\n+  \"\"\n+  \"\")\n \n (define_expand \"movsi\"\n   [(set (match_operand:SI 0 \"general_operand\" \"\")\n@@ -314,21 +338,60 @@\n     }\n }\")\n \n-(define_insn \"*movsi_insn\"\n-  [(set (match_operand:SI 0 \"move_dest_operand\" \"=r,r,r,r,r,r,r,m\")\n ;; ??? Do we need a const_double constraint here for large unsigned values?\n-\t(match_operand:SI 1 \"move_src_operand\" \"r,I,J,MQ,L,N,m,r\"))]\n+(define_insn \"*movsi_insn\"\n+  [(set (match_operand:SI 0 \"move_dest_operand\" \"=r,r,r,r,r,r,r,r,r,T,U,m\")\n+\t(match_operand:SI 1 \"move_src_operand\" \"r,I,J,MQ,L,n,T,U,m,r,r,r\"))]\n   \"register_operand (operands[0], SImode) || register_operand (operands[1], SImode)\"\n-  \"@\n-   mv %0,%1\n-   ldi %0,%#%1 ; %X1\n-   ldi %0,%#%1 ; %X1\n-   ld24 %0,%#%1 ; %X1\n-   seth %0,%#%T1\n-   seth %0,%#%T1\\;or3 %0,%0,%#%B1\n-   ld %0,%1\n-   st %1,%0\"\n-  [(set_attr \"type\" \"move,move,move4,move4,move4,multi,load,store\")])\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == REG || GET_CODE (operands[1]) == SUBREG)\n+    {\n+      switch (GET_CODE (operands[1]))\n+\t{\n+\t  HOST_WIDE_INT value;\n+\n+\t  default:\n+\t    break;\n+\n+\t  case REG:\n+\t  case SUBREG:\n+\t    return \\\"mv %0,%1\\\";\n+\n+\t  case MEM:\n+\t    return \\\"ld %0,%1\\\";\n+\n+\t  case CONST_INT:\n+\t    value = INTVAL (operands[1]);\n+\t    if (INT16_P (value))\n+\t      return \\\"ldi %0,%#%1\\\\t; %X1\\\";\n+\n+\t    if (UINT24_P (value))\n+\t      return \\\"ld24 %0,%#%1\\\\t; %X1\\\";\n+\n+\t    if (UPPER16_P (value))\n+\t      return \\\"seth %0,%#%T1\\\\t; %X1\\\";\n+\n+\t    return \\\"#\\\";\n+\n+\t  case CONST:\n+\t  case SYMBOL_REF:\n+\t  case LABEL_REF:\n+\t    if (TARGET_ADDR24)\n+\t      return \\\"ld24 %0,%#%1\\\";\n+\n+\t    return \\\"#\\\";\n+\t}\n+    }\n+\n+  else if (GET_CODE (operands[0]) == MEM\n+\t   && (GET_CODE (operands[1]) == REG || GET_CODE (operands[1]) == SUBREG))\n+    return \\\"st %1,%0\\\";\n+\n+  fatal_insn (\\\"bad movsi insn\\\", insn);\n+}\"\n+  [(set_attr \"type\" \"int2,int2,int4,int4,int4,multi,load2,load2,load4,store2,store2,store4\")\n+   (set_attr \"length\" \"2,2,4,4,4,8,2,2,4,2,2,4\")])\n \n ; Try to use a four byte / two byte pair for constants not loadable with\n ; ldi, ld24, seth.\n@@ -376,6 +439,17 @@\n   operands[3] = GEN_INT ((val) & 0xffff);\n }\")\n \n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operand:SI 1 \"seth_add3_operand\" \"i\"))]\n+  \"TARGET_ADDR32\"\n+  [(set (match_dup 0)\n+\t(high:SI (match_dup 1)))\n+   (set (match_dup 0)\n+\t(lo_sum:SI (match_dup 0)\n+\t\t   (match_dup 1)))]\n+  \"\")\n+\n ;; Small data area support.\n ;; The address of _SDA_BASE_ is loaded into a register and all objects in\n ;; the small data area are indexed off that.  This is done for each reference\n@@ -413,7 +487,8 @@\n \t(unspec [(const_int 0)] 2))]\n   \"\"\n   \"ld24 %0,#_SDA_BASE_\"\n-  [(set_attr \"type\" \"move4\")])\n+  [(set_attr \"type\" \"int4\")\n+   (set_attr \"length\" \"4\")])\n \n ;; 32 bit address support.\n \n@@ -438,15 +513,17 @@\n \t(high:SI (match_operand 1 \"symbolic_operand\" \"\")))]\n   \"\"\n   \"seth %0,%#shigh(%1)\"\n-  [(set_attr \"type\" \"move4\")])\n+  [(set_attr \"type\" \"int4\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"lo_sum_si\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t   (match_operand:SI 2 \"immediate_operand\" \"in\")))]\n   \"\"\n   \"add3 %0,%1,%#%B2\"\n-  [(set_attr \"length\" \"4\")])\n+  [(set_attr \"type\" \"int4\")\n+   (set_attr \"length\" \"4\")])\n \n (define_expand \"movdi\"\n   [(set (match_operand:DI 0 \"general_operand\" \"\")\n@@ -458,85 +535,22 @@\n \n   if (GET_CODE (operands[0]) == MEM)\n     operands[1] = force_reg (DImode, operands[1]);\n-\n-  if (CONSTANT_P (operands[1])\n-      && ! easy_di_const (operands[1]))\n-    {\n-      rtx mem = force_const_mem (DImode, operands[1]);\n-      rtx reg = ((reload_in_progress || reload_completed)\n-\t\t ? copy_to_suggested_reg (XEXP (mem, 0),\n-\t\t\t\t\t  gen_rtx (REG, Pmode, REGNO (operands[0])),\n-\t\t\t\t\t  Pmode)\n-\t\t : force_reg (Pmode, XEXP (mem, 0)));\n-      operands[1] = change_address (mem, DImode, reg);\n-    }\n }\")\n \n (define_insn \"*movdi_insn\"\n-  [(set (match_operand:DI 0 \"move_dest_operand\" \"=r,r,r,m\")\n-\t(match_operand:DI 1 \"move_double_src_operand\" \"r,nG,m,r\"))]\n+  [(set (match_operand:DI 0 \"move_dest_operand\" \"=r,r,r,r,m\")\n+\t(match_operand:DI 1 \"move_double_src_operand\" \"r,nG,F,m,r\"))]\n   \"register_operand (operands[0], DImode) || register_operand (operands[1], DImode)\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0 :\n-      /* We normally copy the low-numbered register first.  However, if\n-\t the first register operand 0 is the same as the second register of\n-\t operand 1, we must copy in the opposite order.  */\n-      if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n-\treturn \\\"mv %R0,%R1\\;mv %0,%1\\\";\n-      else\n-\treturn \\\"mv %0,%1\\;mv %R0,%R1\\\";\n-    case 1 :\n-      return \\\"#\\\";\n-    case 2 :\n-      /* If the low-address word is used in the address, we must load it\n-\t last.  Otherwise, load it first.  Note that we cannot have\n-\t auto-increment in that case since the address register is known to be\n-\t dead.  */\n-      if (refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n-\t\t\t     operands [1], 0))\n-\t{\n-\t  return \\\"ld %R0,%R1\\;ld %0,%1\\\";\n-\t}\n-      else\n-\t{\n-\t  /* Try to use auto-inc addressing if we can.  */\n-\t  if (GET_CODE (XEXP (operands[1], 0)) == REG\n-\t      && dead_or_set_p (insn, XEXP (operands[1], 0)))\n-\t    {\n-\t      operands[1] = XEXP (operands[1], 0);\n-\t      return \\\"ld %0,@%1+\\;ld %R0,@%1\\\";\n-\t    }\n-\t  return \\\"ld %0,%1\\;ld %R0,%R1\\\";\n-\t}\n-    case 3 :\n-      /* Try to use auto-inc addressing if we can.  */\n-      if (GET_CODE (XEXP (operands[0], 0)) == REG\n-\t  && dead_or_set_p (insn, XEXP (operands[0], 0)))\n-\t{\n-\t  operands[0] = XEXP (operands[0], 0);\n-\t  return \\\"st %1,@%0\\;st %R1,@+%0\\\";\n-\t}\n-      return \\\"st %1,%0\\;st %R1,%R0\\\";\n-    }\n-}\"\n-  [(set_attr \"type\" \"multi,multi,multi,multi\")\n-   (set_attr \"length\" \"4,4,6,6\")])\n+  \"#\"\n+  [(set_attr \"type\" \"multi,multi,multi,load8,store8\")\n+   (set_attr \"length\" \"4,4,16,6,6\")])\n \n (define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(match_operand:DI 1 \"const_double_operand\" \"\"))]\n+  [(set (match_operand:DI 0 \"move_dest_operand\" \"\")\n+\t(match_operand:DI 1 \"move_double_src_operand\" \"\"))]\n   \"reload_completed\"\n-  [(set (match_dup 2) (match_dup 4))\n-   (set (match_dup 3) (match_dup 5))]\n-  \"\n-{\n-  operands[2] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN == 0);\n-  operands[3] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN != 0);\n-  split_double (operands[1], operands + 4, operands + 5);\n-}\")\n+  [(match_dup 2)]\n+  \"operands[2] = gen_split_move_double (operands);\")\n \f\n ;; Floating point move insns.\n \n@@ -553,37 +567,36 @@\n }\")\n \n (define_insn \"*movsf_insn\"\n-  [(set (match_operand:SF 0 \"move_dest_operand\" \"=r,r,r,m\")\n-\t(match_operand:SF 1 \"move_src_operand\" \"r,F,m,r\"))]\n+  [(set (match_operand:SF 0 \"move_dest_operand\" \"=r,r,r,r,T,m\")\n+\t(match_operand:SF 1 \"move_src_operand\" \"r,F,T,m,r,r\"))]\n   \"register_operand (operands[0], SFmode) || register_operand (operands[1], SFmode)\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0 :\n-      return \\\"mv %0,%1\\\";\n-    case 1 :\n-      {\n-\tREAL_VALUE_TYPE r;\n-\tlong l;\n-\tREAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n-\tREAL_VALUE_TO_TARGET_SINGLE (r, l);\n-\toperands[1] = GEN_INT (l);\n-\tif (l == 0)\n-\t  return \\\"ldi %0,%#0\\\";\n-\tif ((l & 0xffff) == 0)\n-\t  return \\\"seth %0,%#%T1\\\";\n-\telse\n-\t  return \\\"seth %0,%#%T1\\;or3 %0,%0,%#%B1\\\";\n-      }\n-    case 2 :\n-      return \\\"ld %0,%1\\\";\n-    case 3 :\n-      return \\\"st %1,%0\\\";\n-    }\n-}\"\n+  \"@\n+   mv %0,%1\n+   #\n+   ld %0,%1\n+   ld %0,%1\n+   st %1,%0\n+   st %1,%0\"\n   ;; ??? Length of alternative 1 is either 2, 4 or 8.\n-  [(set_attr \"type\" \"move,multi,load,store\")])\n+  [(set_attr \"type\" \"int2,multi,load2,load4,store2,store4\")\n+   (set_attr \"length\" \"2,8,2,4,2,4\")])\n+\n+(define_split\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(match_operand:SF 1 \"const_double_operand\" \"\"))]\n+  \"reload_completed\"\n+  [(set (match_dup 2) (match_dup 3))]\n+  \"\n+{\n+  long l;\n+  REAL_VALUE_TYPE rv;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n+  REAL_VALUE_TO_TARGET_SINGLE (rv, l);\n+\n+  operands[2] = operand_subword (operands[0], 0, 0, SFmode);\n+  operands[3] = GEN_INT (l);\n+}\")\n \n (define_expand \"movdf\"\n   [(set (match_operand:DF 0 \"general_operand\" \"\")\n@@ -595,118 +608,57 @@\n \n   if (GET_CODE (operands[0]) == MEM)\n     operands[1] = force_reg (DFmode, operands[1]);\n-\n-  if (GET_CODE (operands[1]) == CONST_DOUBLE\n-      && ! easy_df_const (operands[1]))\n-    {\n-      rtx mem = force_const_mem (DFmode, operands[1]);\n-      rtx reg = ((reload_in_progress || reload_completed)\n-\t\t ? copy_to_suggested_reg (XEXP (mem, 0),\n-\t\t\t\t\t  gen_rtx (REG, Pmode, REGNO (operands[0])),\n-\t\t\t\t\t  Pmode)\n-\t\t : force_reg (Pmode, XEXP (mem, 0)));\n-      operands[1] = change_address (mem, DFmode, reg);\n-    }\n }\")\n \n (define_insn \"*movdf_insn\"\n   [(set (match_operand:DF 0 \"move_dest_operand\" \"=r,r,r,m\")\n-\t(match_operand:DF 1 \"move_double_src_operand\" \"r,H,m,r\"))]\n+\t(match_operand:DF 1 \"move_double_src_operand\" \"r,F,m,r\"))]\n   \"register_operand (operands[0], DFmode) || register_operand (operands[1], DFmode)\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0 :\n-      /* We normally copy the low-numbered register first.  However, if\n-\t the first register operand 0 is the same as the second register of\n-\t operand 1, we must copy in the opposite order.  */\n-      if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n-\treturn \\\"mv %R0,%R1\\;mv %0,%1\\\";\n-      else\n-\treturn \\\"mv %0,%1\\;mv %R0,%R1\\\";\n-    case 1 :\n-      {\n-\tREAL_VALUE_TYPE r;\n-\tlong l[2];\n-\tREAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n-\tREAL_VALUE_TO_TARGET_DOUBLE (r, l);\n-\toperands[1] = GEN_INT (l[0]);\n-\tif (l[0] == 0 && l[1] == 0)\n-\t  return \\\"ldi %0,%#0\\;ldi %R0,%#0\\\";\n-\telse if (l[1] != 0)\n-\t  abort ();\n-\telse if ((l[0] & 0xffff) == 0)\n-\t  return \\\"seth %0,%#%T1\\;ldi %R0,%#0\\\";\n-\telse\n-\t  abort ();\n-      }\n-    case 2 :\n-      /* If the low-address word is used in the address, we must load it\n-\t last.  Otherwise, load it first.  Note that we cannot have\n-\t auto-increment in that case since the address register is known to be\n-\t dead.  */\n-      if (refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n-\t\t\t     operands [1], 0))\n-\t{\n-\t  return \\\"ld %R0,%R1\\;ld %0,%1\\\";\n-\t}\n-      else\n-\t{\n-\t  /* Try to use auto-inc addressing if we can.  */\n-\t  if (GET_CODE (XEXP (operands[1], 0)) == REG\n-\t      && dead_or_set_p (insn, XEXP (operands[1], 0)))\n-\t    {\n-\t      operands[1] = XEXP (operands[1], 0);\n-\t      return \\\"ld %0,@%1+\\;ld %R0,@%1\\\";\n-\t    }\n-\t  return \\\"ld %0,%1\\;ld %R0,%R1\\\";\n-\t}\n-    case 3 :\n-      /* Try to use auto-inc addressing if we can.  */\n-      if (GET_CODE (XEXP (operands[0], 0)) == REG\n-\t  && dead_or_set_p (insn, XEXP (operands[0], 0)))\n-\t{\n-\t  operands[0] = XEXP (operands[0], 0);\n-\t  return \\\"st %1,@%0\\;st %R1,@+%0\\\";\n-\t}\n-      return \\\"st %1,%0\\;st %R1,%R0\\\";\n-    }\n-}\"\n-  [(set_attr \"type\" \"multi,multi,multi,multi\")\n-   (set_attr \"length\" \"4,6,6,6\")])\n+  \"#\"\n+  [(set_attr \"type\" \"multi,multi,load8,store8\")\n+   (set_attr \"length\" \"4,16,6,6\")])\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"move_dest_operand\" \"\")\n+\t(match_operand:DF 1 \"move_double_src_operand\" \"\"))]\n+  \"reload_completed\"\n+  [(match_dup 2)]\n+  \"operands[2] = gen_split_move_double (operands);\")\n \f\n ;; Zero extension instructions.\n \n (define_insn \"zero_extendqihi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"r,m\")))]\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r\")\n+\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"r,T,m\")))]\n   \"\"\n   \"@\n    and3 %0,%1,%#255\n+   ldub %0,%1\n    ldub %0,%1\"\n-  [(set_attr \"type\" \"unary,load\")\n-   (set_attr \"length\" \"4,*\")])\n+  [(set_attr \"type\" \"int4,load2,load4\")\n+   (set_attr \"length\" \"4,2,4\")])\n \n (define_insn \"zero_extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"r,m\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"r,T,m\")))]\n   \"\"\n   \"@\n    and3 %0,%1,%#255\n+   ldub %0,%1\n    ldub %0,%1\"\n-  [(set_attr \"type\" \"unary,load\")\n-   (set_attr \"length\" \"4,*\")])\n+  [(set_attr \"type\" \"int4,load2,load4\")\n+   (set_attr \"length\" \"4,2,4\")])\n \n (define_insn \"zero_extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"r,m\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"r,T,m\")))]\n   \"\"\n   \"@\n    and3 %0,%1,%#65535\n+   lduh %0,%1\n    lduh %0,%1\"\n-  [(set_attr \"type\" \"unary,load\")\n-   (set_attr \"length\" \"4,*\")])\n+  [(set_attr \"type\" \"int4,load2,load4\")\n+   (set_attr \"length\" \"4,2,4\")])\n \f\n ;; Sign extension instructions.\n ;; ??? See v850.md.\n@@ -747,11 +699,12 @@\n }\")\n \n (define_insn \"*sign_extendqihi2_insn\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(sign_extend:HI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(sign_extend:HI (match_operand:QI 1 \"memory_operand\" \"T,m\")))]\n   \"\"\n   \"ldb %0,%1\"\n-  [(set_attr \"type\" \"load\")])\n+  [(set_attr \"type\" \"load2,load4\")\n+   (set_attr \"length\" \"2,4\")])\n \n (define_expand \"extendqisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -777,11 +730,12 @@\n }\")\n \n (define_insn \"*sign_extendqisi2_insn\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"T,m\")))]\n   \"\"\n   \"ldb %0,%1\"\n-  [(set_attr \"type\" \"load\")])\n+  [(set_attr \"type\" \"load2,load4\")\n+   (set_attr \"length\" \"2,4\")])\n \n (define_expand \"extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -807,11 +761,12 @@\n }\")\n \n (define_insn \"*sign_extendhisi2_insn\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"T,m\")))]\n   \"\"\n   \"ldh %0,%1\"\n-  [(set_attr \"type\" \"load\")])\n+  [(set_attr \"type\" \"load2,load4\")\n+   (set_attr \"length\" \"2,4\")])\n \f\n ;; Arithmetic instructions.\n \n@@ -828,7 +783,7 @@\n    add %0,%2\n    addi %0,%#%2\n    add3 %0,%1,%#%2\"\n-  [(set_attr \"type\" \"binary\")\n+  [(set_attr \"type\" \"int2,int2,int4\")\n    (set_attr \"length\" \"2,2,4\")])\n \n ;(define_split\n@@ -849,35 +804,121 @@\n \t\t (match_operand:DI 2 \"register_operand\" \"r\")))\n    (clobber (reg:CC 17))]\n   \"\"\n-  \"*\n-{\n-  /* ??? The cmp clears the condition bit.  Can we speed up somehow?  */\n-  return \\\"cmp %L0,%L0\\;addx %L0,%L2\\;addx %H0,%H2\\\";\n-}\"\n-  [(set_attr \"type\" \"binary\")\n+  \"#\"\n+  [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"6\")])\n \n+;; ??? The cmp clears the condition bit.  Can we speed up somehow?\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"\")))\n+   (clobber (match_operand 3 \"\" \"\"))]\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 3)\n+\t\t   (const_int 0))\n+\t      (use (match_dup 4))])\n+   (parallel [(set (match_dup 4)\n+\t\t   (plus:SI (match_dup 4)\n+\t\t\t    (plus:SI (match_dup 5)\n+\t\t\t\t     (match_dup 3))))\n+\t      (set (match_dup 3)\n+\t\t   (unspec [(const_int 0)] 3))])\n+   (parallel [(set (match_dup 6)\n+\t\t   (plus:SI (match_dup 6)\n+\t\t\t    (plus:SI (match_dup 7)\n+\t\t\t\t     (match_dup 3))))\n+\t      (set (match_dup 3)\n+\t\t   (unspec [(const_int 0)] 3))])]\n+  \"\n+{\n+  operands[4] = operand_subword (operands[0], (WORDS_BIG_ENDIAN != 0), 0, DImode);\n+  operands[5] = operand_subword (operands[2], (WORDS_BIG_ENDIAN != 0), 0, DImode);\n+  operands[6] = operand_subword (operands[0], (WORDS_BIG_ENDIAN == 0), 0, DImode);\n+  operands[7] = operand_subword (operands[2], (WORDS_BIG_ENDIAN == 0), 0, DImode);\n+}\")\n+\n+(define_insn \"*clear_c\"\n+  [(set (reg:CC 17)\n+\t(const_int 0))\n+   (use (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"cmp %0,%0\"\n+  [(set_attr \"type\" \"int2\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"*add_carry\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+\t\t (plus:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t  (reg:CC 17))))\n+   (set (reg:CC 17)\n+\t(unspec [(const_int 0)] 3))]\n+  \"\"\n+  \"addx %0,%2\"\n+  [(set_attr \"type\" \"int2\")\n+   (set_attr \"length\" \"2\")])\n+\n (define_insn \"subsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(minus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t  (match_operand:SI 2 \"register_operand\" \"r\")))]\n   \"\"\n   \"sub %0,%2\"\n-  [(set_attr \"type\" \"binary\")])\n+  [(set_attr \"type\" \"int2\")\n+   (set_attr \"length\" \"2\")])\n \n (define_insn \"subdi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(minus:DI (match_operand:DI 1 \"register_operand\" \"0\")\n \t\t  (match_operand:DI 2 \"register_operand\" \"r\")))\n    (clobber (reg:CC 17))]\n   \"\"\n-  \"*\n-{\n-  /* ??? The cmp clears the condition bit.  Can we speed up somehow?  */\n-  return \\\"cmp %L0,%L0\\;subx %L0,%L2\\;subx %H0,%H2\\\";\n-}\"\n-  [(set_attr \"type\" \"binary\")\n+  \"#\"\n+  [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"6\")])\n+\n+;; ??? The cmp clears the condition bit.  Can we speed up somehow?\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(minus:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t  (match_operand:DI 2 \"register_operand\" \"\")))\n+   (clobber (match_operand 3 \"\" \"\"))]\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 3)\n+\t\t   (const_int 0))\n+\t      (use (match_dup 4))])\n+   (parallel [(set (match_dup 4)\n+\t\t   (minus:SI (match_dup 4)\n+\t\t\t     (minus:SI (match_dup 5)\n+\t\t\t\t       (match_dup 3))))\n+\t      (set (match_dup 3)\n+\t\t   (unspec [(const_int 0)] 3))])\n+   (parallel [(set (match_dup 6)\n+\t\t   (minus:SI (match_dup 6)\n+\t\t\t     (minus:SI (match_dup 7)\n+\t\t\t\t       (match_dup 3))))\n+\t      (set (match_dup 3)\n+\t\t   (unspec [(const_int 0)] 3))])]\n+  \"\n+{\n+  operands[4] = operand_subword (operands[0], (WORDS_BIG_ENDIAN != 0), 0, DImode);\n+  operands[5] = operand_subword (operands[2], (WORDS_BIG_ENDIAN != 0), 0, DImode);\n+  operands[6] = operand_subword (operands[0], (WORDS_BIG_ENDIAN == 0), 0, DImode);\n+  operands[7] = operand_subword (operands[2], (WORDS_BIG_ENDIAN == 0), 0, DImode);\n+}\")\n+\n+(define_insn \"*sub_carry\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+\t\t  (minus:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t    (reg:CC 17))))\n+   (set (reg:CC 17)\n+\t(unspec [(const_int 0)] 3))]\n+  \"\"\n+  \"subx %0,%2\"\n+  [(set_attr \"type\" \"int2\")\n+   (set_attr \"length\" \"2\")])\n \f\n ; Multiply/Divide instructions.\n \n@@ -887,7 +928,7 @@\n \t\t (sign_extend:SI (match_operand:HI 2 \"register_operand\" \"r\"))))]\n   \"\"\n   \"mullo %1,%2\\;mvfacmi %0\"\n-  [(set_attr \"type\" \"mul\")\n+  [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"mulsi3\"\n@@ -896,39 +937,44 @@\n \t\t (match_operand:SI 2 \"register_operand\" \"r\")))]\n   \"\"\n   \"mul %0,%2\"\n-  [(set_attr \"type\" \"mul\")])\n+  [(set_attr \"type\" \"mul2\")\n+   (set_attr \"length\" \"2\")])\n \n (define_insn \"divsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(div:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n   \"\"\n   \"div %0,%2\"\n-  [(set_attr \"type\" \"div\")])\n+  [(set_attr \"type\" \"div4\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"udivsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(udiv:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t (match_operand:SI 2 \"register_operand\" \"r\")))]\n   \"\"\n   \"divu %0,%2\"\n-  [(set_attr \"type\" \"div\")])\n+  [(set_attr \"type\" \"div4\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"modsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(mod:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n   \"\"\n   \"rem %0,%2\"\n-  [(set_attr \"type\" \"div\")])\n+  [(set_attr \"type\" \"div4\")\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"umodsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(umod:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t (match_operand:SI 2 \"register_operand\" \"r\")))]\n   \"\"\n   \"remu %0,%2\"\n-  [(set_attr \"type\" \"div\")])\n+  [(set_attr \"type\" \"div4\")\n+   (set_attr \"length\" \"4\")])\n \f\n ;; Boolean instructions.\n ;;\n@@ -942,8 +988,9 @@\n   \"\"\n   \"@\n    and %0,%2\n-   and3 %0,%1,%#%2 ; %X2\"\n-  [(set_attr \"type\" \"binary\")])\n+   and3 %0,%1,%#%2\\\\t; %X2\"\n+  [(set_attr \"type\" \"int2,int4\")\n+   (set_attr \"length\" \"2,4\")])\n \n (define_insn \"iorsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n@@ -952,8 +999,9 @@\n   \"\"\n   \"@\n    or %0,%2\n-   or3 %0,%1,%#%2 ; %X2\"\n-  [(set_attr \"type\" \"binary\")])\n+   or3 %0,%1,%#%2\\\\t; %X2\"\n+  [(set_attr \"type\" \"int2,int4\")\n+   (set_attr \"length\" \"2,4\")])\n \n (define_insn \"xorsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n@@ -962,22 +1010,25 @@\n   \"\"\n   \"@\n    xor %0,%2\n-   xor3 %0,%1,%#%2 ; %X2\"\n-  [(set_attr \"type\" \"binary\")])\n+   xor3 %0,%1,%#%2\\\\t; %X2\"\n+  [(set_attr \"type\" \"int2,int4\")\n+   (set_attr \"length\" \"2,4\")])\n \n (define_insn \"negsi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(neg:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n   \"\"\n   \"neg %0,%1\"\n-  [(set_attr \"type\" \"unary\")])\n+  [(set_attr \"type\" \"int2\")\n+   (set_attr \"length\" \"2\")])\n \n (define_insn \"one_cmplsi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(not:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n   \"\"\n   \"not %0,%1\"\n-  [(set_attr \"type\" \"unary\")])\n+  [(set_attr \"type\" \"int2\")\n+   (set_attr \"length\" \"2\")])\n \f\n ;; Shift instructions.\n \n@@ -990,7 +1041,7 @@\n    sll %0,%2\n    slli %0,%#%2\n    sll3 %0,%1,%#%2\"\n-  [(set_attr \"type\" \"shift\")\n+  [(set_attr \"type\" \"shift2,shift2,shift4\")\n    (set_attr \"length\" \"2,2,4\")])\n \n (define_insn \"ashrsi3\"\n@@ -1002,7 +1053,7 @@\n    sra %0,%2\n    srai %0,%#%2\n    sra3 %0,%1,%#%2\"\n-  [(set_attr \"type\" \"shift\")\n+  [(set_attr \"type\" \"shift2,shift2,shift4\")\n    (set_attr \"length\" \"2,2,4\")])\n \n (define_insn \"lshrsi3\"\n@@ -1014,7 +1065,7 @@\n    srl %0,%2\n    srli %0,%#%2\n    srl3 %0,%1,%#%2\"\n-  [(set_attr \"type\" \"shift\")\n+  [(set_attr \"type\" \"shift2,shift2,shift4\")\n    (set_attr \"length\" \"2,2,4\")])\n \f\n ;; Compare instructions.\n@@ -1067,7 +1118,7 @@\n           return \\\"add3 %2,%0,%#%N1\\;cmpui %2,#1\\\";\n     }\n }\"\n-  [(set_attr \"type\" \"compare,compare\")\n+  [(set_attr \"type\" \"multi,multi\")\n    (set_attr \"length\" \"8,8\")])\n \n (define_insn \"cmp_ltsi_insn\"\n@@ -1078,23 +1129,19 @@\n   \"@\n    cmp %0,%1\n    cmpi %0,%#%1\"\n-  [(set_attr \"type\" \"compare,compare\")\n-   (set_attr \"length\" \"4,6\")])\n+  [(set_attr \"type\" \"int2,int4\")\n+   (set_attr \"length\" \"2,4\")])\n \n (define_insn \"cmp_ltusi_insn\"\n   [(set (reg:CC 17)\n \t(ltu:CC (match_operand:SI 0 \"register_operand\" \"r,r\")\n \t        (match_operand:SI 1 \"reg_or_uint16_operand\" \"r,K\")))]\n   \"\"\n-  \"*\n-{\n-  if (which_alternative == 0)\n-    return \\\"cmpu %0,%1\\\";\n-  else\n-   return \\\"cmpui %0,%#%1\\\";\n-}\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"4,6\")])\n+  \"@\n+   cmpu %0,%1\n+   cmpui %0,%#%1\"\n+  [(set_attr \"type\" \"int2,int4\")\n+   (set_attr \"length\" \"2,4\")])\n \n ;; reg == small constant comparisons are best handled by putting the result\n ;; of the comparison in a tmp reg and then using beqz/bnez.\n@@ -1104,12 +1151,12 @@\n (define_insn \"cmp_ne_small_const_insn\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(ne:SI (match_operand:SI 1 \"register_operand\" \"0,r\")\n-\t       (match_operand:SI 2 \"cmp_int16_operand\" \"S,P\")))]\n+\t       (match_operand:SI 2 \"cmp_int16_operand\" \"N,P\")))]\n   \"\"\n   \"@\n    addi %0,%#%N2\n    add3 %0,%1,%#%N2\"\n-  [(set_attr \"type\" \"compare\")\n+  [(set_attr \"type\" \"int2,int4\")\n    (set_attr \"length\" \"2,4\")])\n \f\n ;; These control RTL generation for conditional jump insns.\n@@ -1582,7 +1629,7 @@\n   [(const_int 0)]\n   \"\"\n   \"nop\"\n-  [(set_attr \"type\" \"misc\")\n+  [(set_attr \"type\" \"int2\")\n    (set_attr \"length\" \"2\")])\n \n ;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n@@ -1599,7 +1646,8 @@\n   [(unspec_volatile [(match_operand 0 \"memory_operand\" \"m\")] 0)]\n   \"\"\n   \"* return \\\"nop ; flush-icache\\\";\"\n-  [(set_attr \"type\" \"misc\")])\n+  [(set_attr \"type\" \"int2\")\n+   (set_attr \"length\" \"2\")])\n \f\n ;; Conditional move instructions\n ;; Based on those done for the d10v\n@@ -1638,7 +1686,7 @@\n    )]\n   \"zero_and_one (operands [2], operands[3])\"\n   \"* return emit_cond_move (operands, insn);\"\n-  [(set_attr \"type\"   \"move\")\n+  [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"8\")\n   ]\n )\n@@ -1657,9 +1705,9 @@\n   [(set (mem:SI (plus:SI (match_operand:SI 0 \"register_operand\" \"r\")\n \t\t\t (const_int 4)))\n         (match_operand:SI 1 \"register_operand\" \"r\"))]\n-  \"dead_or_set_p (insn, operands[0])\"\n+  \"0 && dead_or_set_p (insn, operands[0])\"\n   \"st %1,@+%0\"\n-  [(set_attr \"type\" \"store\")\n+  [(set_attr \"type\" \"store2\")\n    (set_attr \"length\" \"2\")])\n \n ;; This case is triggered by compiling this code:\n@@ -1698,9 +1746,9 @@\n         (match_dup 0)\n    )\n   ]\n-  \"dead_or_set_p (insn, operands [0])\"\n+  \"0 && dead_or_set_p (insn, operands [0])\"\n   \"st %1,@(%3,%2)\"\n-  [(set_attr \"type\" \"store\")\n+  [(set_attr \"type\" \"store4\")\n    (set_attr \"length\" \"4\")\n   ]\n )"}]}