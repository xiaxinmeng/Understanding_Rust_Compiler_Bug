{"sha": "2e4bc20e5107fbf05555ca34d4d6664835845729", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmU0YmMyMGU1MTA3ZmJmMDU1NTVjYTM0ZDRkNjY2NDgzNTg0NTcyOQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-01-06T01:35:19Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-01-06T01:35:19Z"}, "message": "Fix order in which recursive structs are converted to GENERIC.\n\nFrom-SVN: r168534", "tree": {"sha": "9db74ecffec3a6d70f53bc522036a91c803d7ffd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9db74ecffec3a6d70f53bc522036a91c803d7ffd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e4bc20e5107fbf05555ca34d4d6664835845729", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e4bc20e5107fbf05555ca34d4d6664835845729", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e4bc20e5107fbf05555ca34d4d6664835845729", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e4bc20e5107fbf05555ca34d4d6664835845729/comments", "author": null, "committer": null, "parents": [{"sha": "d3ee4aaae70586c4ee4adfb258703c8362d04eb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3ee4aaae70586c4ee4adfb258703c8362d04eb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3ee4aaae70586c4ee4adfb258703c8362d04eb6"}], "stats": {"total": 118, "additions": 95, "deletions": 23}, "files": [{"sha": "8bb2b72a5a75d6f4d0beeefdc50927229c3b207d", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 72, "deletions": 22, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e4bc20e5107fbf05555ca34d4d6664835845729/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e4bc20e5107fbf05555ca34d4d6664835845729/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=2e4bc20e5107fbf05555ca34d4d6664835845729", "patch": "@@ -3768,6 +3768,19 @@ Struct_type::fill_in_tree(Gogo* gogo, tree type)\n   return type;\n }\n \n+// Make sure that all structs which must be converted to the backend\n+// representation before this one are in fact converted.\n+\n+void\n+Struct_type::convert_prerequisites(Gogo* gogo)\n+{\n+  for (std::vector<Named_type*>::const_iterator p\n+\t = this->prerequisites_.begin();\n+       p != this->prerequisites_.end();\n+       ++p)\n+    (*p)->get_tree(gogo);\n+}\n+\n // Initialize struct fields.\n \n tree\n@@ -5977,20 +5990,44 @@ Interface_type::fill_in_tree(Gogo* gogo, tree type)\n {\n   gcc_assert(this->methods_ != NULL);\n \n+  // Because the methods may refer to the interface type itself, we\n+  // need to build the interface type first, and then update the\n+  // method pointer later.\n+\n+  tree field_trees = NULL_TREE;\n+  tree* pp = &field_trees;\n+\n+  tree name_tree = get_identifier(\"__methods\");\n+  tree methods_field = build_decl(this->location_, FIELD_DECL, name_tree,\n+\t\t\t\t  ptr_type_node);\n+  DECL_CONTEXT(methods_field) = type;\n+  *pp = methods_field;\n+  pp = &DECL_CHAIN(methods_field);\n+\n+  name_tree = get_identifier(\"__object\");\n+  tree field = build_decl(this->location_, FIELD_DECL, name_tree,\n+\t\t\t  ptr_type_node);\n+  DECL_CONTEXT(field) = type;\n+  *pp = field;\n+\n+  TYPE_FIELDS(type) = field_trees;\n+\n+  layout_type(type);\n+\n   // Build the type of the table of methods.\n \n   tree method_table = make_node(RECORD_TYPE);\n \n   // The first field is a pointer to the type descriptor.\n-  tree name_tree = get_identifier(\"__type_descriptor\");\n+  name_tree = get_identifier(\"__type_descriptor\");\n   tree dtype = Type::make_type_descriptor_type()->get_tree(gogo);\n   dtype = build_pointer_type(build_qualified_type(dtype, TYPE_QUAL_CONST));\n-  tree field = build_decl(this->location_, FIELD_DECL, name_tree, dtype);\n+  field = build_decl(this->location_, FIELD_DECL, name_tree, dtype);\n   DECL_CONTEXT(field) = method_table;\n   TYPE_FIELDS(method_table) = field;\n \n   std::string last_name = \"\";\n-  tree* pp = &DECL_CHAIN(field);\n+  pp = &DECL_CHAIN(field);\n   for (Typed_identifier_list::const_iterator p = this->methods_->begin();\n        p != this->methods_->end();\n        ++p)\n@@ -6010,25 +6047,9 @@ Interface_type::fill_in_tree(Gogo* gogo, tree type)\n     }\n   layout_type(method_table);\n \n-  tree mtype = build_pointer_type(method_table);\n-\n-  tree field_trees = NULL_TREE;\n-  pp = &field_trees;\n-\n-  name_tree = get_identifier(\"__methods\");\n-  field = build_decl(this->location_, FIELD_DECL, name_tree, mtype);\n-  DECL_CONTEXT(field) = type;\n-  *pp = field;\n-  pp = &DECL_CHAIN(field);\n-\n-  name_tree = get_identifier(\"__object\");\n-  field = build_decl(this->location_, FIELD_DECL, name_tree, ptr_type_node);\n-  DECL_CONTEXT(field) = type;\n-  *pp = field;\n-\n-  TYPE_FIELDS(type) = field_trees;\n-\n-  layout_type(type);\n+  // Update the type of the __methods field from a generic pointer to\n+  // a pointer to the method table.\n+  TREE_TYPE(methods_field) = build_pointer_type(method_table);\n \n   return type;\n }\n@@ -6864,6 +6885,26 @@ Named_type::do_verify()\n \treturn false;\n     }\n \n+  // If this is a struct, then if any of the fields of the struct\n+  // themselves have struct type, then this struct must be converted\n+  // to the backend representation before the field's type is\n+  // converted.  That may seem backward, but it works because if the\n+  // field's type refers to this one, e.g., via a pointer, then the\n+  // conversion process will pick up the half-built struct and do the\n+  // right thing.\n+  if (this->struct_type() != NULL)\n+    {\n+      const Struct_field_list* fields = this->struct_type()->fields();\n+      for (Struct_field_list::const_iterator p = fields->begin();\n+\t   p != fields->end();\n+\t   ++p)\n+\t{\n+\t  Struct_type* st = p->type()->struct_type();\n+\t  if (st != NULL)\n+\t    st->add_prerequisite(this);\n+\t}\n+    }\n+\n   return true;\n }\n \n@@ -6994,8 +7035,17 @@ Named_type::do_get_tree(Gogo* gogo)\n       break;\n \n     case TYPE_STRUCT:\n+      // If there are structs which must be converted first, do them.\n+      if (this->seen_ == 0)\n+\t{\n+\t  ++this->seen_;\n+\t  this->type_->struct_type()->convert_prerequisites(gogo);\n+\t  --this->seen_;\n+\t}\n+\n       if (this->named_tree_ != NULL_TREE)\n \treturn this->named_tree_;\n+\n       t = make_node(RECORD_TYPE);\n       this->named_tree_ = t;\n       t = this->type_->struct_type()->fill_in_tree(gogo, t);"}, {"sha": "a8d8a0b9ed4a360a6aca9d990f95ee946ed7a226", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e4bc20e5107fbf05555ca34d4d6664835845729/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e4bc20e5107fbf05555ca34d4d6664835845729/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=2e4bc20e5107fbf05555ca34d4d6664835845729", "patch": "@@ -1843,7 +1843,8 @@ class Struct_type : public Type\n  public:\n   Struct_type(Struct_field_list* fields, source_location location)\n     : Type(TYPE_STRUCT),\n-      fields_(fields), location_(location), all_methods_(NULL)\n+      fields_(fields), location_(location), all_methods_(NULL),\n+      prerequisites_()\n   { }\n \n   // Return the field NAME.  This only looks at local fields, not at\n@@ -1938,6 +1939,17 @@ class Struct_type : public Type\n   tree\n   fill_in_tree(Gogo*, tree);\n \n+  // Note that a struct must be converted to the backend\n+  // representation before we convert this struct.\n+  void\n+  add_prerequisite(Named_type* nt)\n+  { this->prerequisites_.push_back(nt); }\n+\n+  // If there are any structs which must be converted to the backend\n+  // representation before this one, convert them.\n+  void\n+  convert_prerequisites(Gogo*);\n+\n  protected:\n   int\n   do_traverse(Traverse*);\n@@ -1983,6 +1995,16 @@ class Struct_type : public Type\n   source_location location_;\n   // If this struct is unnamed, a list of methods.\n   Methods* all_methods_;\n+  // A list of structs which must be converted to the backend\n+  // representation before this struct can be converted.  This is for\n+  // cases like\n+  //   type S1 { p *S2 }\n+  //   type S2 { s S1 }\n+  // where we must start converting S2 before we start converting S1.\n+  // That is because we can fully convert S1 before S2 is complete,\n+  // but we can not fully convert S2 before S1 is complete.  If we\n+  // start converting S1 first, we won't be able to convert S2.\n+  std::vector<Named_type*> prerequisites_;\n };\n \n // The type of an array."}]}