{"sha": "4554e20d809b431126e2071ea14d0646db63a438", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU1NGUyMGQ4MDliNDMxMTI2ZTIwNzFlYTE0ZDA2NDZkYjYzYTQzOA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-10-02T10:25:57Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-10-02T10:25:57Z"}, "message": "caller-save.c (insert_save_restore): Break this function up into new functions insert_restore...\n\n\ufffd\n\t* caller-save.c (insert_save_restore): Break this function up\n\tinto new functions insert_restore, insert_save and insert_one_insn.\n\tAll callers changed.\n\t(insert_restore): New function, mostly broken out of\n\tinsert_save_restore.\n\t(insert_save): Likewise.\n\t(insert_one_insn): Likewise.\n\t(restore_referenced_regs): New argument BLOCK.  All callers changed.\n\t(save_call_clobbered_regs): Don't keep track of basic block boundaries\n\tin this function, do it in insert_one_insn instead.\n\nFrom-SVN: r22754", "tree": {"sha": "d3d4538f1bbdecbdf604369a64f7097eb667907b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3d4538f1bbdecbdf604369a64f7097eb667907b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4554e20d809b431126e2071ea14d0646db63a438", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4554e20d809b431126e2071ea14d0646db63a438", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4554e20d809b431126e2071ea14d0646db63a438", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4554e20d809b431126e2071ea14d0646db63a438/comments", "author": null, "committer": null, "parents": [{"sha": "f670c074b860ce1e1d538fa41aa4f07832f050f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f670c074b860ce1e1d538fa41aa4f07832f050f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f670c074b860ce1e1d538fa41aa4f07832f050f2"}], "stats": {"total": 278, "additions": 166, "deletions": 112}, "files": [{"sha": "acb9ba43241cc5f109d890fb799d67fcfdb90fa5", "filename": "gcc/caller-save.c", "status": "modified", "additions": 166, "deletions": 112, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4554e20d809b431126e2071ea14d0646db63a438/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4554e20d809b431126e2071ea14d0646db63a438/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=4554e20d809b431126e2071ea14d0646db63a438", "patch": "@@ -82,9 +82,14 @@ int n_regs_saved;\n \n static void set_reg_live\t\tPROTO((rtx, rtx));\n static void clear_reg_live\t\tPROTO((rtx));\n-static void restore_referenced_regs\tPROTO((rtx, rtx, enum machine_mode));\n-static int insert_save_restore\t\tPROTO((rtx, int, int,\n+static void restore_referenced_regs\tPROTO((rtx, rtx, enum machine_mode,\n+\t\t\t\t\t       int));\n+static int insert_restore\t\tPROTO((rtx, int, int,\n+\t\t\t\t\t       enum machine_mode, int, int));\n+static int insert_save\t\t\tPROTO((rtx, int, int,\n \t\t\t\t\t       enum machine_mode, int));\n+static void insert_one_insn\t\tPROTO((rtx, int, enum rtx_code,\n+\t\t\t\t\t       enum machine_mode, rtx, int));\n \f\n /* Initialize for caller-save.\n \n@@ -358,7 +363,6 @@ save_call_clobbered_regs (insn_mode)\n   for (b = 0; b < n_basic_blocks; b++)\n     {\n       regset regs_live = basic_block_live_at_start[b];\n-      rtx prev_block_last = PREV_INSN (basic_block_head[b]);\n       int i, j;\n       int regno;\n \n@@ -399,7 +403,7 @@ save_call_clobbered_regs (insn_mode)\n \t\t any of them.  We must restore them before the insn if so.  */\n \n \t      if (n_regs_saved)\n-\t\trestore_referenced_regs (PATTERN (insn), insn, insn_mode);\n+\t\trestore_referenced_regs (PATTERN (insn), insn, insn_mode, b);\n \n \t      /* NB: the normal procedure is to first enliven any\n \t\t registers set by insn, then deaden any registers that\n@@ -449,8 +453,7 @@ save_call_clobbered_regs (insn_mode)\n \t\t\t/* It must not be set by this instruction.  */\n \t\t        && ! TEST_HARD_REG_BIT (this_call_sets, regno)\n \t\t        && ! TEST_HARD_REG_BIT (hard_regs_saved, regno))\n-\t\t      regno += insert_save_restore (insn, 1, regno, \n-\t\t\t\t\t\t    insn_mode, 0);\n+\t\t      regno += insert_save (insn, 1, regno, insn_mode, b);\n \n \t\t  /* Put the information for this CALL_INSN on top of what\n \t\t     we already had.  */\n@@ -489,13 +492,9 @@ save_call_clobbered_regs (insn_mode)\n       if (n_regs_saved)\n \tfor (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t  if (TEST_HARD_REG_BIT (hard_regs_need_restore, regno))\n-\t    regno += insert_save_restore ((GET_CODE (insn) == JUMP_INSN\n-\t\t\t\t  ? insn : NEXT_INSN (insn)), 0,\n-\t\t\t\t  regno, insn_mode, MOVE_MAX / UNITS_PER_WORD);\n-\n-      /* If we added any insns at the start of the block, update the start\n-\t of the block to point at those insns.  */\n-      basic_block_head[b] = NEXT_INSN (prev_block_last);\n+\t    regno += insert_restore (insn, GET_CODE (insn) == JUMP_INSN,\n+\t\t\t\t     regno, insn_mode,\n+\t\t\t\t     MOVE_MAX / UNITS_PER_WORD, b);\n     }\n }\n \n@@ -562,10 +561,11 @@ clear_reg_live (reg)\n    INSN_MODE is the mode to assign to any insns that we add.  */\n \n static void\n-restore_referenced_regs (x, insn, insn_mode)\n+restore_referenced_regs (x, insn, insn_mode, block)\n      rtx x;\n      rtx insn;\n      enum machine_mode insn_mode;\n+     int block;\n {\n   enum rtx_code code = GET_CODE (x);\n   char *fmt;\n@@ -584,11 +584,11 @@ restore_referenced_regs (x, insn, insn_mode)\n       if (regno >= FIRST_PSEUDO_REGISTER\n \t  && reg_equiv_mem[regno] != 0)\n \trestore_referenced_regs (XEXP (reg_equiv_mem[regno], 0),\n-\t\t\t\t insn, insn_mode);\n+\t\t\t\t insn, insn_mode, block);\n       else if (regno >= FIRST_PSEUDO_REGISTER\n \t       && reg_equiv_address[regno] != 0)\n \trestore_referenced_regs (reg_equiv_address[regno],\n-\t\t\t\t insn, insn_mode);\n+\t\t\t\t insn, insn_mode, block);\n \n       /* Otherwise if this is a hard register, restore any piece of it that\n \t is currently saved.  */\n@@ -597,13 +597,13 @@ restore_referenced_regs (x, insn, insn_mode)\n \t{\n \t  int numregs = HARD_REGNO_NREGS (regno, GET_MODE (x));\n \t  /* Save at most SAVEREGS at a time.  This can not be larger than\n-\t     MOVE_MAX, because that causes insert_save_restore to fail.  */\n+\t     MOVE_MAX, because that causes insert_restore to fail.  */\n \t  int saveregs = MIN (numregs, MOVE_MAX / UNITS_PER_WORD);\n \t  int endregno = regno + numregs;\n \n \t  for (i = regno; i < endregno; i++)\n \t    if (TEST_HARD_REG_BIT (hard_regs_need_restore, i))\n-\t      i += insert_save_restore (insn, 0, i, insn_mode, saveregs);\n+\t      i += insert_restore (insn, 1, i, insn_mode, saveregs, block);\n \t}\n \n       return;\n@@ -613,18 +613,18 @@ restore_referenced_regs (x, insn, insn_mode)\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\trestore_referenced_regs (XEXP (x, i), insn, insn_mode);\n+\trestore_referenced_regs (XEXP (x, i), insn, insn_mode, block);\n       else if (fmt[i] == 'E')\n \tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  restore_referenced_regs (XVECEXP (x, i, j), insn, insn_mode);\n+\t  restore_referenced_regs (XVECEXP (x, i, j), insn, insn_mode, block);\n     }\n }\n \f\n-/* Insert a sequence of insns to save or restore, SAVE_P says which,\n-   REGNO.  Place these insns in front of INSN.  INSN_MODE is the mode\n+/* Insert a sequence of insns to restore REGNO.  Place these insns in front\n+   of or after INSN (determined by BEFORE_P).  INSN_MODE is the mode\n    to assign to these insns.   MAXRESTORE is the maximum number of registers\n-   which should be restored during this call (when SAVE_P == 0).  It should\n-   never be less than 1 since we only work with entire registers.\n+   which should be restored during this call.  It should never be less than\n+   1 since we only work with entire registers.\n \n    Note that we have verified in init_caller_save that we can do this\n    with a simple SET, so use it.  Set INSN_CODE to what we save there\n@@ -635,16 +635,19 @@ restore_referenced_regs (x, insn, insn_mode)\n    Return the extra number of registers saved.  */\n \n static int\n-insert_save_restore (insn, save_p, regno, insn_mode, maxrestore)\n+insert_restore (insn, before_p, regno, insn_mode, maxrestore, block)\n      rtx insn;\n-     int save_p;\n+     int before_p;\n      int regno;\n      enum machine_mode insn_mode;\n      int maxrestore;\n+     int block;\n {\n   rtx pat = NULL_RTX;\n   enum insn_code code = CODE_FOR_nothing;\n   int numregs = 0;\n+  int i, j, k;\n+  int ok;\n \n   /* A common failure mode if register status is not correct in the RTL\n      is for this routine to be called with a REGNO we didn't expect to\n@@ -656,108 +659,159 @@ insert_save_restore (insn, save_p, regno, insn_mode, maxrestore)\n   if (regno_save_mem[regno][1] == 0)\n     abort ();\n \n-#ifdef HAVE_cc0\n-  /* If INSN references CC0, put our insns in front of the insn that sets\n-     CC0.  This is always safe, since the only way we could be passed an\n-     insn that references CC0 is for a restore, and doing a restore earlier\n-     isn't a problem.  We do, however, assume here that CALL_INSNs don't\n-     reference CC0.  Guard against non-INSN's like CODE_LABEL.  */\n-\n-  if ((GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN)\n-      && reg_referenced_p (cc0_rtx, PATTERN (insn)))\n-    insn = prev_nonnote_insn (insn);\n-#endif\n-\n   /* Get the pattern to emit and update our status.  */\n-  if (save_p)\n+\n+  /* See if we can restore `maxrestore' registers at once.  Work\n+     backwards to the single register case.  */\n+  for (i = maxrestore; i > 0; i--)\n     {\n-      int i, j, k;\n-      int ok;\n+      ok = 1;\n+      if (regno_save_mem[regno][i])\n+\tfor (j = 0; j < i; j++)\n+\t  {\n+\t    if (! TEST_HARD_REG_BIT (hard_regs_need_restore, regno + j))\n+\t      ok = 0;\n+\t  }\n+      else\n+\tcontinue;\n+\n+      /* Must do this one restore at a time */\n+      if (! ok)\n+\tcontinue;\n+\t    \n+      pat = gen_rtx_SET (VOIDmode,\n+\t\t\t gen_rtx_REG (GET_MODE (regno_save_mem[regno][i]), \n+\t\t\t\t      regno), \n+\t\t\t regno_save_mem[regno][i]);\n+      code = reg_restore_code[regno][i];\n+\n \n-      /* See if we can save several registers with a single instruction.  \n-\t Work backwards to the single register case.  */\n-      for (i = MOVE_MAX / UNITS_PER_WORD; i > 0; i--)\n+      /* Clear status for all registers we restored.  */\n+      for (k = 0; k < i; k++)\n \t{\n-\t  ok = 1;\n-\t  if (regno_save_mem[regno][i] != 0)\n-\t    for (j = 0; j < i; j++)\n-\t      {\n-\t\tif (! call_used_regs[regno + j] || call_fixed_regs[regno + j]\n-\t\t    || ! TEST_HARD_REG_BIT (hard_regs_live, regno + j)\n-\t\t    || TEST_HARD_REG_BIT (hard_regs_saved, regno + j))\n-\t\t  ok = 0;\n-\t      }\n-\t  else \n-\t    continue;\n+\t  CLEAR_HARD_REG_BIT (hard_regs_need_restore, regno + k);\n+\t  n_regs_saved--;\n+\t}\n \n-\t  /* Must do this one save at a time */\n-\t  if (! ok)\n-\t    continue;\n+      numregs = i;\n+      break;\n+    }\n \n-          pat = gen_rtx_SET (VOIDmode, regno_save_mem[regno][i],\n-\t\t\t     gen_rtx_REG (GET_MODE (regno_save_mem[regno][i]),\n-\t\t\t\t\t  regno));\n-          code = reg_save_code[regno][i];\n+  insert_one_insn (insn, before_p, code, insn_mode, pat, block);\n \n-\t  /* Set hard_regs_saved for all the registers we saved.  */\n-\t  for (k = 0; k < i; k++)\n-\t    {\n-\t      SET_HARD_REG_BIT (hard_regs_saved, regno + k);\n-\t      SET_HARD_REG_BIT (hard_regs_need_restore, regno + k);\n-\t      n_regs_saved++;\n-\t    }\n+  /* Tell our callers how many extra registers we saved/restored */\n+  return numregs - 1;\n+}\n \n-\t  numregs = i;\n-\t  break;\n-        }\n-    }\n-  else\n-    {\n-      int i, j, k;\n-      int ok;\n+/* Like insert_restore, but emit code to save REGNO.  */\n+static int\n+insert_save (insn, before_p, regno, insn_mode, block)\n+     rtx insn;\n+     int before_p;\n+     int regno;\n+     enum machine_mode insn_mode;\n+     int block;\n+{\n+  rtx pat = NULL_RTX;\n+  enum insn_code code = CODE_FOR_nothing;\n+  int numregs = 0;\n+  int i, j, k;\n+  int ok;\n \n-      /* See if we can restore `maxrestore' registers at once.  Work\n-\t backwards to the single register case.  */\n-      for (i = maxrestore; i > 0; i--)\n-\t{\n-\t  ok = 1;\n-\t  if (regno_save_mem[regno][i])\n-\t    for (j = 0; j < i; j++)\n-\t      {\n-\t  \tif (! TEST_HARD_REG_BIT (hard_regs_need_restore, regno + j))\n-\t\t  ok = 0;\n-\t      }\n-\t  else\n-\t    continue;\n+  /* A common failure mode if register status is not correct in the RTL\n+     is for this routine to be called with a REGNO we didn't expect to\n+     save.  That will cause us to write an insn with a (nil) SET_DEST\n+     or SET_SRC.  Instead of doing so and causing a crash later, check\n+     for this common case and abort here instead.  This will remove one\n+     step in debugging such problems.  */\n \n-\t  /* Must do this one restore at a time */\n-\t  if (! ok)\n-\t    continue;\n-\t    \n-          pat = gen_rtx_SET (VOIDmode,\n-\t\t\t     gen_rtx_REG (GET_MODE (regno_save_mem[regno][i]), \n-\t\t\t\t\t  regno), \n-\t\t\t regno_save_mem[regno][i]);\n-          code = reg_restore_code[regno][i];\n+  if (regno_save_mem[regno][1] == 0)\n+    abort ();\n \n+  /* Get the pattern to emit and update our status.  */\n \n-\t  /* Clear status for all registers we restored.  */\n-\t  for (k = 0; k < i; k++)\n-\t    {\n-\t      CLEAR_HARD_REG_BIT (hard_regs_need_restore, regno + k);\n-\t      n_regs_saved--;\n-\t    }\n+  /* See if we can save several registers with a single instruction.  \n+     Work backwards to the single register case.  */\n+  for (i = MOVE_MAX / UNITS_PER_WORD; i > 0; i--)\n+    {\n+      ok = 1;\n+      if (regno_save_mem[regno][i] != 0)\n+\tfor (j = 0; j < i; j++)\n+\t  {\n+\t    if (! call_used_regs[regno + j] || call_fixed_regs[regno + j]\n+\t\t|| ! TEST_HARD_REG_BIT (hard_regs_live, regno + j)\n+\t\t|| TEST_HARD_REG_BIT (hard_regs_saved, regno + j))\n+\t      ok = 0;\n+\t  }\n+      else \n+\tcontinue;\n \n-\t  numregs = i;\n-\t  break;\n-        }\n+      /* Must do this one save at a time */\n+      if (! ok)\n+\tcontinue;\n+\n+      pat = gen_rtx_SET (VOIDmode, regno_save_mem[regno][i],\n+\t\t\t gen_rtx_REG (GET_MODE (regno_save_mem[regno][i]),\n+\t\t\t\t      regno));\n+      code = reg_save_code[regno][i];\n+\n+      /* Set hard_regs_saved for all the registers we saved.  */\n+      for (k = 0; k < i; k++)\n+\t{\n+\t  SET_HARD_REG_BIT (hard_regs_saved, regno + k);\n+\t  SET_HARD_REG_BIT (hard_regs_need_restore, regno + k);\n+\t  n_regs_saved++;\n+\t}\n+\n+      numregs = i;\n+      break;\n     }\n-  /* Emit the insn and set the code and mode.  */\n \n-  insn = emit_insn_before (pat, insn);\n-  PUT_MODE (insn, insn_mode);\n-  INSN_CODE (insn) = code;\n+  insert_one_insn (insn, before_p, code, insn_mode, pat, block);\n \n   /* Tell our callers how many extra registers we saved/restored */\n   return numregs - 1;\n }\n+\n+/* Emit one insn, set the code and mode, and update basic block\n+   boundaries.  */\n+static void\n+insert_one_insn (insn, before_p, code, mode, pat, block)\n+     rtx insn;\n+     int before_p;\n+     enum rtx_code code;\n+     enum machine_mode mode;\n+     rtx pat;\n+     int block;\n+{\n+  rtx insert_point = insn;\n+  rtx new;\n+#ifdef HAVE_cc0\n+  /* If INSN references CC0, put our insns in front of the insn that sets\n+     CC0.  This is always safe, since the only way we could be passed an\n+     insn that references CC0 is for a restore, and doing a restore earlier\n+     isn't a problem.  We do, however, assume here that CALL_INSNs don't\n+     reference CC0.  Guard against non-INSN's like CODE_LABEL.  */\n+\n+  if ((GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN)\n+      && before_p\n+      && reg_referenced_p (cc0_rtx, PATTERN (insn)))\n+    insert_point = prev_nonnote_insn (insn);\n+#endif\n+\n+  if (before_p)\n+    {\n+      new = emit_insn_before (pat, insert_point);\n+      if (insert_point == basic_block_head[block])\n+\tbasic_block_head[block] = new;\n+    }\n+  else\n+    {\n+      new = emit_insn_after (pat, insert_point);\n+      if (insert_point == basic_block_end[block])\n+\tbasic_block_end[block] = new;\n+    }\n+    \n+  PUT_MODE (new, mode);\n+  INSN_CODE (new) = code;\n+}"}]}