{"sha": "dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMzYWY3ZTI0ZjE1ZGVhYTllYTI4MWJlNWY0NmI2ZjFhYWUxY2JkNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-08-06T08:48:19Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-08-06T08:48:19Z"}, "message": "[multiple changes]\n\n2012-08-06  Arnaud Charlet  <charlet@adacore.com>\n\n\t* prj-attr.adb (Register_New_Package): Add missing blank.\n\n2012-08-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_aggr.adb (Is_Two_Dim_Packed_Array): New predicate,\n\tused when computing maximum size allowable to construct static\n\taggregate.\n\n2012-08-06  Vincent Pucci  <pucci@adacore.com>\n\n\t* freeze.adb (Freeze_Entity): Inherit_Aspects_At_Freeze_Point\n\tcalls added for derived types and subtypes.\n\t* sem_aux.adb, sem_aux.ads (Get_Rep_Item, Get_Rep_Pragma,\n\tHas_Rep_Pragma): New routines.\n\t* sem_ch13.ads (Inherit_Aspects_At_Freeze_Point): New routine.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Error message\n\tfor aspect Lock_Free fixed.\n\t(Inherits_Aspects_At_Freeze_Point): New routine.\n\t* sem_ch3.adb: Several flag settings removed since inheritance\n\tof aspects must be performed at freeze point.\n\n2012-08-06  Thomas Quinot  <quinot@adacore.com>\n\n\t* s-oscons-tmplt.c: Fix s-oscons.ads formatting on VxWorks.\n\n2012-08-06  Vincent Pucci  <pucci@adacore.com>\n\n\t* sem_dim.adb (Analyze_Dimension_Binary_Op): Issue an error message\n\tfor unknown exponent at compile-time.\n\n2012-08-06  Gary Dismukes  <dismukes@adacore.com>\n\n\t* sem_eval.ads (Compile_Time_Known_Value_Or_Aggr): Enhance\n\tcomment to make it clear that the aggregate's evaluation might\n\tstill involve run-time checks even though the aggregate is\n\tconsidered known at compile time.\n\t* sinfo.ads (Compile_Time_Known_Aggregate): Correct comment to\n\trefer to Exp_Aggr instead of Sem_Aggr.\n\nFrom-SVN: r190172", "tree": {"sha": "4f03209166c0b92edeec7e2ec9bef37a19eacb15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f03209166c0b92edeec7e2ec9bef37a19eacb15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4/comments", "author": null, "committer": null, "parents": [{"sha": "2eef7403a010176fe462257b6b29981e78d35602", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2eef7403a010176fe462257b6b29981e78d35602", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2eef7403a010176fe462257b6b29981e78d35602"}], "stats": {"total": 540, "additions": 468, "deletions": 72}, "files": [{"sha": "15c8ef2c9cf7ac8d972543a9a46ecc11cad25615", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4", "patch": "@@ -1,3 +1,44 @@\n+2012-08-06  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* prj-attr.adb (Register_New_Package): Add missing blank.\n+\n+2012-08-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_aggr.adb (Is_Two_Dim_Packed_Array): New predicate,\n+\tused when computing maximum size allowable to construct static\n+\taggregate.\n+\n+2012-08-06  Vincent Pucci  <pucci@adacore.com>\n+\n+\t* freeze.adb (Freeze_Entity): Inherit_Aspects_At_Freeze_Point\n+\tcalls added for derived types and subtypes.\n+\t* sem_aux.adb, sem_aux.ads (Get_Rep_Item, Get_Rep_Pragma,\n+\tHas_Rep_Pragma): New routines.\n+\t* sem_ch13.ads (Inherit_Aspects_At_Freeze_Point): New routine.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Error message\n+\tfor aspect Lock_Free fixed.\n+\t(Inherits_Aspects_At_Freeze_Point): New routine.\n+\t* sem_ch3.adb: Several flag settings removed since inheritance\n+\tof aspects must be performed at freeze point.\n+\n+2012-08-06  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* s-oscons-tmplt.c: Fix s-oscons.ads formatting on VxWorks.\n+\n+2012-08-06  Vincent Pucci  <pucci@adacore.com>\n+\n+\t* sem_dim.adb (Analyze_Dimension_Binary_Op): Issue an error message\n+\tfor unknown exponent at compile-time.\n+\n+2012-08-06  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* sem_eval.ads (Compile_Time_Known_Value_Or_Aggr): Enhance\n+\tcomment to make it clear that the aggregate's evaluation might\n+\tstill involve run-time checks even though the aggregate is\n+\tconsidered known at compile time.\n+\t* sinfo.ads (Compile_Time_Known_Aggregate): Correct comment to\n+\trefer to Exp_Aggr instead of Sem_Aggr.\n+\n 2012-08-06  Robert Dewar  <dewar@adacore.com>\n \n \t* xoscons.adb: Minor code reorganization (remove unused variable"}, {"sha": "bcfca25c6b023f011338d76a8bb6eccf9d3a11af", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4", "patch": "@@ -238,6 +238,14 @@ package body Exp_Aggr is\n    --  This is the top-level routine to perform array aggregate expansion.\n    --  N is the N_Aggregate node to be expanded.\n \n+   function Is_Two_Dim_Packed_Array (Typ : Entity_Id) return Boolean;\n+\n+   --  For two-dimensional packed aggregates with constant bounds and constant\n+   --  components, it is preferable to pack the inner aggregates because the\n+   --  whole matrix can then be presented to the back-end as a one-dimensional\n+   --  list of literals. This is much more efficient than expanding into single\n+   --  component assignments.\n+\n    function Late_Expansion\n      (N      : Node_Id;\n       Typ    : Entity_Id;\n@@ -306,13 +314,20 @@ package body Exp_Aggr is\n       --  increase the limit when Static_Elaboration_Desired, given that this\n       --  means that objects are intended to be placed in data memory.\n \n+      --  We also increase the limit if the aggregate is for a packed two-\n+      --  dimensional array, because if components are static it is much more\n+      --  efficient to construct a one-dimensional equivalent array with static\n+      --  components.\n+\n       Max_Aggr_Size : constant Nat :=\n                         5000 + (2 ** 24 - 5000) *\n                           Boolean'Pos\n                             (Restriction_Active (No_Elaboration_Code)\n                                or else\n                              Restriction_Active (No_Implicit_Loops)\n                                or else\n+                             Is_Two_Dim_Packed_Array (Typ)\n+                               or else\n                              ((Ekind (Current_Scope) = E_Package\n                                and then\n                                  Static_Elaboration_Desired (Current_Scope))));\n@@ -5900,6 +5915,19 @@ package body Exp_Aggr is\n                      and then Typ = RTE (RE_Interface_Data_Element)));\n    end Is_Static_Dispatch_Table_Aggregate;\n \n+   -----------------------------\n+   -- Is_Two_Dim_Packed_Array --\n+   -----------------------------\n+\n+   function Is_Two_Dim_Packed_Array (Typ : Entity_Id) return Boolean is\n+      C : constant Int := UI_To_Int (Component_Size (Typ));\n+   begin\n+      return Number_Dimensions (Typ) = 2\n+        and then Is_Bit_Packed_Array (Typ)\n+        and then\n+          (C = 1 or else C = 2 or else C = 4);\n+   end Is_Two_Dim_Packed_Array;\n+\n    --------------------\n    -- Late_Expansion --\n    --------------------"}, {"sha": "ad9f06a06754a895e50c6adfe0914fbd398a03ff", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4", "patch": "@@ -3434,11 +3434,22 @@ package body Freeze is\n                end if;\n             end if;\n \n+            --  A subtype inherits all the type-related representation aspects\n+            --  from its parents (RM 13.1(8)).\n+\n+            Inherit_Aspects_At_Freeze_Point (E);\n+\n          --  For a derived type, freeze its parent type first (RM 13.14(15))\n \n          elsif Is_Derived_Type (E) then\n             Freeze_And_Append (Etype (E), N, Result);\n             Freeze_And_Append (First_Subtype (Etype (E)), N, Result);\n+\n+            --  A derived type inherits each type-related representation aspect\n+            --  of its parent type that was directly specified before the\n+            --  declaration of the derived type (RM 13.1(15)).\n+\n+            Inherit_Aspects_At_Freeze_Point (E);\n          end if;\n \n          --  For array type, freeze index types and component type first"}, {"sha": "f2af8379100b037ae406e08bb67443f827b43c11", "filename": "gcc/ada/prj-attr.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4/gcc%2Fada%2Fprj-attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4/gcc%2Fada%2Fprj-attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr.adb?ref=dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4", "patch": "@@ -851,7 +851,7 @@ package body Prj.Attr is\n \n       for Index in Package_Attributes.First .. Package_Attributes.Last loop\n          if Package_Attributes.Table (Index).Name = Pkg_Name then\n-            Fail (\"cannot register a package with a non unique name\"\"\"\n+            Fail (\"cannot register a package with a non unique name \"\"\"\n                   & Name\n                   & \"\"\"\");\n             Id := Empty_Package;\n@@ -889,7 +889,7 @@ package body Prj.Attr is\n \n       for Index in Package_Attributes.First .. Package_Attributes.Last loop\n          if Package_Attributes.Table (Index).Name = Pkg_Name then\n-            Fail (\"cannot register a package with a non unique name\"\"\"\n+            Fail (\"cannot register a package with a non unique name \"\"\"\n                   & Name\n                   & \"\"\"\");\n             raise Project_Error;"}, {"sha": "eef71b4b7191947759187bfc3a05dd9291559459", "filename": "gcc/ada/s-oscons-tmplt.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4/gcc%2Fada%2Fs-oscons-tmplt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4/gcc%2Fada%2Fs-oscons-tmplt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-oscons-tmplt.c?ref=dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4", "patch": "@@ -628,13 +628,15 @@ CND(EILSEQ, \"Illegal byte sequence\")\n  **  Terminal/serial I/O constants\n  **/\n \n+#if defined(HAVE_TERMIOS) || defined(__MINGW32__)\n /*\n \n    ----------------------\n    -- Terminal control --\n    ----------------------\n \n */\n+#endif\n \n #ifdef HAVE_TERMIOS\n "}, {"sha": "bb24fc2e21ac5236064d9b2cbe9a732dbff479ca", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 86, "deletions": 22, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4", "patch": "@@ -489,6 +489,40 @@ package body Sem_Aux is\n       return Empty;\n    end Get_Rep_Item;\n \n+   function Get_Rep_Item\n+     (E             : Entity_Id;\n+      Nam1          : Name_Id;\n+      Nam2          : Name_Id;\n+      Check_Parents : Boolean := True) return Node_Id\n+   is\n+      Nam1_Item : constant Node_Id := Get_Rep_Item (E, Nam1, Check_Parents);\n+      Nam2_Item : constant Node_Id := Get_Rep_Item (E, Nam2, Check_Parents);\n+\n+      N : Node_Id;\n+\n+   begin\n+      --  Check both Nam1_Item and Nam2_Item are present\n+\n+      if No (Nam1_Item) then\n+         return Nam2_Item;\n+      elsif No (Nam2_Item) then\n+         return Nam1_Item;\n+      end if;\n+\n+      --  Return the first node encountered in the list\n+\n+      N := First_Rep_Item (E);\n+      while Present (N) loop\n+         if N = Nam1_Item or else N = Nam2_Item then\n+            return N;\n+         end if;\n+\n+         Next_Rep_Item (N);\n+      end loop;\n+\n+      return Empty;\n+   end Get_Rep_Item;\n+\n    --------------------\n    -- Get_Rep_Pragma --\n    --------------------\n@@ -501,31 +535,41 @@ package body Sem_Aux is\n       N : Node_Id;\n \n    begin\n-      N := First_Rep_Item (E);\n-      while Present (N) loop\n-         if Nkind (N) = N_Pragma\n-           and then\n-             (Pragma_Name (N) = Nam\n-               or else (Nam = Name_Interrupt_Priority\n-                         and then Pragma_Name (N) = Name_Priority))\n-         then\n-            if Check_Parents then\n-               return N;\n+      N := Get_Rep_Item (E, Nam, Check_Parents);\n \n-            --  If Check_Parents is False, return N if the pragma doesn't\n-            --  appear in the Rep_Item chain of the parent.\n+      if Present (N) and then Nkind (N) = N_Pragma then\n+         return N;\n+      end if;\n \n-            else\n-               declare\n-                  Par : constant Entity_Id := Nearest_Ancestor (E);\n-                  --  This node represents the parent type of type E (if any)\n+      return Empty;\n+   end Get_Rep_Pragma;\n \n-               begin\n-                  if No (Par) or else not Present_In_Rep_Item (Par, N) then\n-                     return N;\n-                  end if;\n-               end;\n-            end if;\n+   function Get_Rep_Pragma\n+     (E             : Entity_Id;\n+      Nam1          : Name_Id;\n+      Nam2          : Name_Id;\n+      Check_Parents : Boolean := True) return Node_Id\n+   is\n+      Nam1_Item : constant Node_Id := Get_Rep_Pragma (E, Nam1, Check_Parents);\n+      Nam2_Item : constant Node_Id := Get_Rep_Pragma (E, Nam2, Check_Parents);\n+\n+      N : Node_Id;\n+\n+   begin\n+      --  Check both Nam1_Item and Nam2_Item are present\n+\n+      if No (Nam1_Item) then\n+         return Nam2_Item;\n+      elsif No (Nam2_Item) then\n+         return Nam1_Item;\n+      end if;\n+\n+      --  Return the first node encountered in the list\n+\n+      N := First_Rep_Item (E);\n+      while Present (N) loop\n+         if N = Nam1_Item or else N = Nam2_Item then\n+            return N;\n          end if;\n \n          Next_Rep_Item (N);\n@@ -547,6 +591,16 @@ package body Sem_Aux is\n       return Present (Get_Rep_Item (E, Nam, Check_Parents));\n    end Has_Rep_Item;\n \n+   function Has_Rep_Item\n+     (E             : Entity_Id;\n+      Nam1          : Name_Id;\n+      Nam2          : Name_Id;\n+      Check_Parents : Boolean := True) return Boolean\n+   is\n+   begin\n+      return Present (Get_Rep_Item (E, Nam1, Nam2, Check_Parents));\n+   end Has_Rep_Item;\n+\n    --------------------\n    -- Has_Rep_Pragma --\n    --------------------\n@@ -560,6 +614,16 @@ package body Sem_Aux is\n       return Present (Get_Rep_Pragma (E, Nam, Check_Parents));\n    end Has_Rep_Pragma;\n \n+   function Has_Rep_Pragma\n+     (E             : Entity_Id;\n+      Nam1          : Name_Id;\n+      Nam2          : Name_Id;\n+      Check_Parents : Boolean := True) return Boolean\n+   is\n+   begin\n+      return Present (Get_Rep_Pragma (E, Nam1, Nam2, Check_Parents));\n+   end Has_Rep_Pragma;\n+\n    -------------------------------\n    -- Initialization_Suppressed --\n    -------------------------------"}, {"sha": "fafd70f7f457640e9e9a934bd09c33bea03ae076", "filename": "gcc/ada/sem_aux.ads", "status": "modified", "additions": 60, "deletions": 6, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4/gcc%2Fada%2Fsem_aux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4/gcc%2Fada%2Fsem_aux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.ads?ref=dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4", "patch": "@@ -168,18 +168,47 @@ package Sem_Aux is\n    --  otherwise Empty is returned. A special case is that when Nam is\n    --  Name_Priority, the call will also find Interrupt_Priority.\n \n+   function Get_Rep_Item\n+     (E             : Entity_Id;\n+      Nam1          : Name_Id;\n+      Nam2          : Name_Id;\n+      Check_Parents : Boolean := True) return Node_Id;\n+   --  Searches the Rep_Item chain for a given entity E, for an instance of a\n+   --  rep item (pragma, attribute definition clause, or aspect specification)\n+   --  whose name matches one of the given names Nam1 or Nam2. If Check_Parents\n+   --  is False then it only returns rep item that has been directly specified\n+   --  for E (and not inherited from its parents, if any). If one is found, it\n+   --  is returned, otherwise Empty is returned. A special case is that when\n+   --  one of the given names is Name_Priority, the call will also find\n+   --  Interrupt_Priority.\n+\n    function Get_Rep_Pragma\n      (E             : Entity_Id;\n       Nam           : Name_Id;\n       Check_Parents : Boolean := True) return Node_Id;\n-   --  Searches the Rep_Item chain for a given entity E, for an instance\n-   --  of a representation pragma whose name matches the given name Nam. If\n+   --  Searches the Rep_Item chain for a given entity E, for an instance of a\n+   --  representation pragma whose name matches the given name Nam. If\n    --  Check_Parents is False then it only returns representation pragma that\n    --  has been directly specified for E (and not inherited from its parents,\n-   --  if any). If one is found, it is returned, otherwise Empty is returned. A\n-   --  special case is that when Nam is Name_Priority, the call will also find\n+   --  if any). If one is found and if it is the first rep item in the list\n+   --  that matches Nam, it is returned, otherwise Empty is returned. A special\n+   --  case is that when Nam is Name_Priority, the call will also find\n    --  Interrupt_Priority.\n \n+   function Get_Rep_Pragma\n+     (E             : Entity_Id;\n+      Nam1          : Name_Id;\n+      Nam2          : Name_Id;\n+      Check_Parents : Boolean := True) return Node_Id;\n+   --  Searches the Rep_Item chain for a given entity E, for an instance of a\n+   --  representation pragma whose name matches one of the given names Nam1 or\n+   --  Nam2. If Check_Parents is False then it only returns representation\n+   --  pragma that has been directly specified for E (and not inherited from\n+   --  its parents, if any). If one is found and if it is the first rep item in\n+   --  the list that matches one of the given names, it is returned, otherwise\n+   --  Empty is returned. A special case is that when one of the given names is\n+   --  Name_Priority, the call will also find Interrupt_Priority.\n+\n    function Has_Rep_Item\n      (E             : Entity_Id;\n       Nam           : Name_Id;\n@@ -191,6 +220,18 @@ package Sem_Aux is\n    --  from its parents, if any). If found then True is returned, otherwise\n    --  False indicates that no matching entry was found.\n \n+   function Has_Rep_Item\n+     (E             : Entity_Id;\n+      Nam1          : Name_Id;\n+      Nam2          : Name_Id;\n+      Check_Parents : Boolean := True) return Boolean;\n+   --  Searches the Rep_Item chain for the given entity E, for an instance of a\n+   --  rep item (pragma, attribute definition clause, or aspect specification)\n+   --  with the given names Nam1 or Nam2. If Check_Parents is False then it\n+   --  only checks for a rep item that has been directly specified for E (and\n+   --  not inherited from its parents, if any). If found then True is returned,\n+   --  otherwise False indicates that no matching entry was found.\n+\n    function Has_Rep_Pragma\n      (E             : Entity_Id;\n       Nam           : Name_Id;\n@@ -199,8 +240,21 @@ package Sem_Aux is\n    --  representation pragma with the given name Nam. If Check_Parents is False\n    --  then it only checks for a representation pragma that has been directly\n    --  specified for E (and not inherited from its parents, if any). If found\n-   --  then True is returned, otherwise False indicates that no matching entry\n-   --  was found.\n+   --  and if it is the first rep item in the list that matches Nam then True\n+   --  is returned, otherwise False indicates that no matching entry was found.\n+\n+   function Has_Rep_Pragma\n+     (E             : Entity_Id;\n+      Nam1          : Name_Id;\n+      Nam2          : Name_Id;\n+      Check_Parents : Boolean := True) return Boolean;\n+   --  Searches the Rep_Item chain for the given entity E, for an instance of a\n+   --  representation pragma with the given names Nam1 or Nam2. If\n+   --  Check_Parents is False then it only checks for a rep item that has been\n+   --  directly specified for E (and not inherited from its parents, if any).\n+   --  If found and if it is the first rep item in the list that matches one of\n+   --  the given names then True is returned, otherwise False indicates that no\n+   --  matching entry was found.\n \n    function In_Generic_Body (Id : Entity_Id) return Boolean;\n    --  Determine whether entity Id appears inside a generic body"}, {"sha": "fff9bded5229bd51f0d8191d5fa129f757403e2d", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 219, "deletions": 3, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4", "patch": "@@ -856,9 +856,7 @@ package body Sem_Ch13 is\n    --  Start of processing for Analyze_Aspects_At_Freeze_Point\n \n    begin\n-      --  Must be visible in current scope. Note that this is needed for\n-      --  entities that creates their own scope such as protected objects,\n-      --  tasks, etc.\n+      --  Must be visible in current scope.\n \n       if not Scope_Within_Or_Same (Current_Scope, Scope (E)) then\n          return;\n@@ -1650,6 +1648,7 @@ package body Sem_Ch13 is\n \n                   if A_Id = Aspect_Lock_Free then\n                      if Ekind (E) /= E_Protected_Type then\n+                        Error_Msg_Name_1 := Nam;\n                         Error_Msg_N\n                           (\"aspect % only applies to a protected object\",\n                            Aspect);\n@@ -7943,6 +7942,223 @@ package body Sem_Ch13 is\n       end if;\n    end Get_Alignment_Value;\n \n+   -------------------------------------\n+   -- Inherit_Aspects_At_Freeze_Point --\n+   -------------------------------------\n+\n+   procedure Inherit_Aspects_At_Freeze_Point (Typ : Entity_Id) is\n+      function Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item\n+        (Rep_Item : Node_Id) return Boolean;\n+      --  This routine checks if Rep_Item is either a pragma or an aspect\n+      --  specification node whose correponding pragma (if any) is present in\n+      --  the Rep Item chain of the entity it has been specified to.\n+\n+      --------------------------------------------------\n+      -- Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item --\n+      --------------------------------------------------\n+\n+      function Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item\n+        (Rep_Item : Node_Id) return Boolean\n+      is\n+      begin\n+         return Nkind (Rep_Item) = N_Pragma\n+           or else Present_In_Rep_Item\n+                     (Entity (Rep_Item), Aspect_Rep_Item (Rep_Item));\n+      end Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item;\n+\n+   begin\n+      --  A representation item is either subtype-specific (Size and Alignment\n+      --  clauses) or type-related (all others).  Subtype-specific aspects may\n+      --  differ for different subtypes of the same type.(RM 13.1.8)\n+\n+      --  A derived type inherits each type-related representation aspect of\n+      --  its parent type that was directly specified before the declaration of\n+      --  the derived type. (RM 13.1.15)\n+\n+      --  A derived subtype inherits each subtype-specific representation\n+      --  aspect of its parent subtype that was directly specified before the\n+      --  declaration of the derived type .(RM 13.1.15)\n+\n+      --  The general processing involves inheriting a representation aspect\n+      --  from a parent type whenever the first rep item (aspect specification,\n+      --  attribute definition clause, pragma) corresponding to the given\n+      --  representation aspect in the rep item chain of Typ, if any, isn't\n+      --  directly specified to Typ but to one of its parents.\n+\n+      --  ??? Note that, for now, just a limited number of representation\n+      --  aspects have been inherited here so far. Many of them are still\n+      --  inherited in Sem_Ch3. This will be fixed soon. Here is a\n+      --  non-exhaustive list of aspects that likely also need to be moved to\n+      --  this routine: Alignment, Component_Alignment, Component_Size,\n+      --  Machine_Radix, Object_Size, Pack, Predicates,\n+      --  Preelaborable_Initialization, RM_Size and Small.\n+\n+      if Nkind (Parent (Typ)) = N_Private_Extension_Declaration then\n+         return;\n+      end if;\n+\n+      --  Ada_05/Ada_2005\n+\n+      if not Has_Rep_Item (Typ, Name_Ada_05, Name_Ada_2005, False)\n+        and then Has_Rep_Item (Typ, Name_Ada_05, Name_Ada_2005)\n+        and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item\n+                   (Get_Rep_Item (Typ, Name_Ada_05, Name_Ada_2005))\n+      then\n+         Set_Is_Ada_2005_Only (Typ);\n+      end if;\n+\n+      --  Ada_12/Ada_2012\n+\n+      if not Has_Rep_Item (Typ, Name_Ada_12, Name_Ada_2012, False)\n+        and then Has_Rep_Item (Typ, Name_Ada_12, Name_Ada_2012)\n+        and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item\n+                   (Get_Rep_Item (Typ, Name_Ada_12, Name_Ada_2012))\n+      then\n+         Set_Is_Ada_2012_Only (Typ);\n+      end if;\n+\n+      --  Atomic/Shared\n+\n+      if not Has_Rep_Item (Typ, Name_Atomic, Name_Shared, False)\n+        and then Has_Rep_Pragma (Typ, Name_Atomic, Name_Shared)\n+        and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item\n+                   (Get_Rep_Item (Typ, Name_Atomic, Name_Shared))\n+      then\n+         Set_Is_Atomic (Typ);\n+         Set_Treat_As_Volatile (Typ);\n+         Set_Is_Volatile (Typ);\n+      end if;\n+\n+      --  Default_Component_Value.\n+\n+      if Is_Array_Type (Typ)\n+        and then Has_Rep_Item (Typ, Name_Default_Component_Value, False)\n+        and then Has_Rep_Item (Typ, Name_Default_Component_Value)\n+      then\n+         Set_Default_Aspect_Component_Value (Typ,\n+           Default_Aspect_Component_Value\n+             (Entity (Get_Rep_Item (Typ, Name_Default_Component_Value))));\n+      end if;\n+\n+      --  Default_Value.\n+\n+      if Is_Scalar_Type (Typ)\n+        and then Has_Rep_Item (Typ, Name_Default_Value, False)\n+        and then Has_Rep_Item (Typ, Name_Default_Value)\n+      then\n+         Set_Default_Aspect_Value (Typ,\n+           Default_Aspect_Value\n+             (Entity (Get_Rep_Item (Typ, Name_Default_Value))));\n+      end if;\n+\n+      --  Discard_Names\n+\n+      if not Has_Rep_Item (Typ, Name_Discard_Names, False)\n+        and then Has_Rep_Item (Typ, Name_Discard_Names)\n+        and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item\n+                   (Get_Rep_Item (Typ, Name_Discard_Names))\n+      then\n+         Set_Discard_Names (Typ);\n+      end if;\n+\n+      --  Invariants\n+\n+      if not Has_Rep_Item (Typ, Name_Invariant, False)\n+        and then Has_Rep_Item (Typ, Name_Invariant)\n+        and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item\n+                   (Get_Rep_Item (Typ, Name_Invariant))\n+      then\n+         Set_Has_Invariants (Typ);\n+\n+         if Class_Present (Get_Rep_Item (Typ, Name_Invariant)) then\n+            Set_Has_Inheritable_Invariants (Typ);\n+         end if;\n+      end if;\n+\n+      --  Volatile\n+\n+      if not Has_Rep_Item (Typ, Name_Volatile, False)\n+        and then Has_Rep_Item (Typ, Name_Volatile)\n+        and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item\n+                   (Get_Rep_Item (Typ, Name_Volatile))\n+      then\n+         Set_Treat_As_Volatile (Typ);\n+         Set_Is_Volatile (Typ);\n+      end if;\n+\n+      --  Inheritance for derived types only\n+\n+      if Is_Derived_Type (Typ) then\n+         declare\n+            Bas_Typ     : constant Entity_Id := Base_Type (Typ);\n+            Imp_Bas_Typ : constant Entity_Id := Implementation_Base_Type (Typ);\n+\n+         begin\n+            --  Atomic_Components\n+\n+            if not Has_Rep_Item (Typ, Name_Atomic_Components, False)\n+              and then Has_Rep_Item (Typ, Name_Atomic_Components)\n+              and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item\n+                   (Get_Rep_Item (Typ, Name_Atomic_Components))\n+            then\n+               Set_Has_Atomic_Components (Imp_Bas_Typ);\n+            end if;\n+\n+            --  Volatile_Components\n+\n+            if not Has_Rep_Item (Typ, Name_Volatile_Components, False)\n+              and then Has_Rep_Item (Typ, Name_Volatile_Components)\n+              and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item\n+                   (Get_Rep_Item (Typ, Name_Volatile_Components))\n+            then\n+               Set_Has_Volatile_Components (Imp_Bas_Typ);\n+            end if;\n+\n+            --  Finalize_Storage_Only.\n+\n+            if not Has_Rep_Pragma (Typ, Name_Finalize_Storage_Only, False)\n+              and then Has_Rep_Pragma (Typ, Name_Finalize_Storage_Only)\n+            then\n+               Set_Finalize_Storage_Only (Bas_Typ);\n+            end if;\n+\n+            --  Universal_Aliasing\n+\n+            if not Has_Rep_Item (Typ, Name_Universal_Aliasing, False)\n+              and then Has_Rep_Item (Typ, Name_Universal_Aliasing)\n+              and then Is_Pragma_Or_Corr_Pragma_Present_In_Rep_Item\n+                   (Get_Rep_Item (Typ, Name_Universal_Aliasing))\n+            then\n+               Set_Universal_Aliasing (Imp_Bas_Typ);\n+            end if;\n+\n+            --  Record type specific aspects\n+\n+            if Is_Record_Type (Typ) then\n+               --  Bit_Order\n+\n+               if not Has_Rep_Item (Typ, Name_Bit_Order, False)\n+                 and then Has_Rep_Item (Typ, Name_Bit_Order)\n+               then\n+                  Set_Reverse_Bit_Order (Bas_Typ,\n+                    Reverse_Bit_Order (Entity (Name\n+                      (Get_Rep_Item (Typ, Name_Bit_Order)))));\n+               end if;\n+\n+               --  Scalar_Storage_Order\n+\n+               if not Has_Rep_Item (Typ, Name_Scalar_Storage_Order, False)\n+                 and then Has_Rep_Item (Typ, Name_Scalar_Storage_Order)\n+               then\n+                  Set_Reverse_Storage_Order (Bas_Typ,\n+                    Reverse_Storage_Order (Entity (Name\n+                      (Get_Rep_Item (Typ, Name_Scalar_Storage_Order)))));\n+               end if;\n+            end if;\n+         end;\n+      end if;\n+   end Inherit_Aspects_At_Freeze_Point;\n+\n    ----------------\n    -- Initialize --\n    ----------------"}, {"sha": "0ac7386e8782a727be24b3a7fd4679110eac3b5b", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4", "patch": "@@ -310,4 +310,8 @@ package Sem_Ch13 is\n    --  Performs the processing described above at the freeze all point, and\n    --  issues appropriate error messages if the visibility has indeed changed.\n    --  Again, ASN is the N_Aspect_Specification node for the aspect.\n+\n+   procedure Inherit_Aspects_At_Freeze_Point (Typ : Entity_Id);\n+   --  Given an entity Typ that denotes a derived type or a subtype, this\n+   --  routine performs the inheritance of aspects at the freeze point.\n end Sem_Ch13;"}, {"sha": "b61821e6549b6aace2f8ba9bc5023ed335431dbf", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 1, "deletions": 31, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4", "patch": "@@ -4048,12 +4048,9 @@ package body Sem_Ch3 is\n \n       --  Inherit common attributes\n \n-      Set_Is_Generic_Type   (Id, Is_Generic_Type   (Base_Type (T)));\n       Set_Is_Volatile       (Id, Is_Volatile       (T));\n       Set_Treat_As_Volatile (Id, Treat_As_Volatile (T));\n-      Set_Is_Atomic         (Id, Is_Atomic         (T));\n-      Set_Is_Ada_2005_Only  (Id, Is_Ada_2005_Only  (T));\n-      Set_Is_Ada_2012_Only  (Id, Is_Ada_2012_Only  (T));\n+      Set_Is_Generic_Type   (Id, Is_Generic_Type   (Base_Type (T)));\n       Set_Convention        (Id, Convention        (T));\n \n       --  If ancestor has predicates then so does the subtype, and in addition\n@@ -5855,13 +5852,6 @@ package body Sem_Ch3 is\n \n          Analyze (N);\n \n-         --  If pragma Discard_Names applies on the first subtype of the parent\n-         --  type, then it must be applied on this subtype as well.\n-\n-         if Einfo.Discard_Names (First_Subtype (Parent_Type)) then\n-            Set_Discard_Names (Derived_Type);\n-         end if;\n-\n          --  Apply a range check. Since this range expression doesn't have an\n          --  Etype, we have to specifically pass the Source_Typ parameter. Is\n          --  this right???\n@@ -7666,8 +7656,6 @@ package body Sem_Ch3 is\n \n       --  Fields inherited from the Parent_Type\n \n-      Set_Discard_Names\n-        (Derived_Type, Einfo.Discard_Names  (Parent_Type));\n       Set_Has_Specified_Layout\n         (Derived_Type, Has_Specified_Layout (Parent_Type));\n       Set_Is_Limited_Composite\n@@ -7711,20 +7699,9 @@ package body Sem_Ch3 is\n \n             Set_OK_To_Reorder_Components\n               (Derived_Type, OK_To_Reorder_Components (Parent_Full));\n-            Set_Reverse_Bit_Order\n-              (Derived_Type, Reverse_Bit_Order (Parent_Full));\n-            Set_Reverse_Storage_Order\n-              (Derived_Type, Reverse_Storage_Order (Parent_Full));\n          end;\n       end if;\n \n-      --  Direct controlled types do not inherit Finalize_Storage_Only flag\n-\n-      if not Is_Controlled (Parent_Type) then\n-         Set_Finalize_Storage_Only\n-           (Derived_Type, Finalize_Storage_Only (Parent_Type));\n-      end if;\n-\n       --  Set fields for private derived types\n \n       if Is_Private_Type (Derived_Type) then\n@@ -8043,11 +8020,6 @@ package body Sem_Ch3 is\n       --  they are inherited from the parent type, and these invariants can\n       --  be further inherited, so both flags are set.\n \n-      if Has_Inheritable_Invariants (Parent_Type) then\n-         Set_Has_Inheritable_Invariants (Derived_Type);\n-         Set_Has_Invariants (Derived_Type);\n-      end if;\n-\n       --  We similarly inherit predicates\n \n       if Has_Predicates (Parent_Type) then\n@@ -12218,7 +12190,6 @@ package body Sem_Ch3 is\n       Set_Component_Type           (T1, Component_Type           (T2));\n       Set_Component_Size           (T1, Component_Size           (T2));\n       Set_Has_Controlled_Component (T1, Has_Controlled_Component (T2));\n-      Set_Finalize_Storage_Only    (T1, Finalize_Storage_Only    (T2));\n       Set_Has_Non_Standard_Rep     (T1, Has_Non_Standard_Rep     (T2));\n       Set_Has_Task                 (T1, Has_Task                 (T2));\n       Set_Is_Packed                (T1, Is_Packed                (T2));\n@@ -12237,7 +12208,6 @@ package body Sem_Ch3 is\n \n       Set_First_Index          (T1, First_Index           (T2));\n       Set_Is_Aliased           (T1, Is_Aliased            (T2));\n-      Set_Is_Atomic            (T1, Is_Atomic             (T2));\n       Set_Is_Volatile          (T1, Is_Volatile           (T2));\n       Set_Treat_As_Volatile    (T1, Treat_As_Volatile     (T2));\n       Set_Is_Constrained       (T1, Is_Constrained        (T2));"}, {"sha": "a2dd53c4087af741e3c837a3d391da28866a603a", "filename": "gcc/ada/sem_dim.adb", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4/gcc%2Fada%2Fsem_dim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4/gcc%2Fada%2Fsem_dim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.adb?ref=dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4", "patch": "@@ -1322,9 +1322,12 @@ package body Sem_Dim is\n                --  value of the exponent must be known compile time. Otherwise,\n                --  the exponentiation evaluation will return an error message.\n \n-               if L_Has_Dimensions\n-                 and then Compile_Time_Known_Value (R)\n-               then\n+               if L_Has_Dimensions then\n+                  if not Compile_Time_Known_Value (R) then\n+                     Error_Msg_N (\"exponent of dimensioned operand must be \" &\n+                                  \"known at compile-time\", N);\n+                  end if;\n+\n                   declare\n                      Exponent_Value : Rational := Zero;\n "}, {"sha": "a2f69feac331bd0207137e0777dd728647fac9ae", "filename": "gcc/ada/sem_eval.ads", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4/gcc%2Fada%2Fsem_eval.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4/gcc%2Fada%2Fsem_eval.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.ads?ref=dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4", "patch": "@@ -225,7 +225,7 @@ package Sem_Eval is\n    --  are statically matching subtypes (RM 4.9.1(1-2)).\n \n    function Compile_Time_Known_Value (Op : Node_Id) return Boolean;\n-   --  Returns true if Op is an expression not raising constraint error whose\n+   --  Returns true if Op is an expression not raising Constraint_Error whose\n    --  value is known at compile time. This is true if Op is a static\n    --  expression, but can also be true for expressions which are technically\n    --  non-static but which are in fact known at compile time, such as the\n@@ -236,9 +236,12 @@ package Sem_Eval is\n \n    function Compile_Time_Known_Value_Or_Aggr (Op : Node_Id) return Boolean;\n    --  Similar to Compile_Time_Known_Value, but also returns True if the value\n-   --  is a compile time known aggregate, i.e. an aggregate all of whose\n-   --  constituent expressions are either compile time known values or compile\n-   --  time known aggregates.\n+   --  is a compile-time-known aggregate, i.e. an aggregate all of whose\n+   --  constituent expressions are either compile-time-known values (based on\n+   --  calling Compile_Time_Known_Value) or compile-time-known aggregates.\n+   --  Note that the aggregate could still involve run-time checks that might\n+   --  fail (such as for subtype checks in component associations), but the\n+   --  evaluation of the expressions themselves will not raise an exception.\n \n    function Compile_Time_Known_Bounds (T : Entity_Id) return Boolean;\n    --  If T is an array whose index bounds are all known at compile time, then"}, {"sha": "560d6c24b95d2777bcda6234371647b833e09c90", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=dc3af7e24f15deaa9ea281be5f46b6f1aae1cbd4", "patch": "@@ -669,7 +669,7 @@ package Sinfo is\n    --    Present in N_Aggregate nodes. Set for aggregates which can be fully\n    --    evaluated at compile time without raising constraint error. Such\n    --    aggregates can be passed as is to Gigi without any expansion. See\n-   --    Sem_Aggr for the specific conditions under which an aggregate has this\n+   --    Exp_Aggr for the specific conditions under which an aggregate has this\n    --    flag set.\n \n    --  Componentwise_Assignment (Flag14-Sem)"}]}