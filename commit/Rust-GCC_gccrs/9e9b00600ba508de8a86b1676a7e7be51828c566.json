{"sha": "9e9b00600ba508de8a86b1676a7e7be51828c566", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU5YjAwNjAwYmE1MDhkZThhODZiMTY3NmE3ZTdiZTUxODI4YzU2Ng==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-03-07T17:34:53Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-03-07T17:34:53Z"}, "message": "Initial revision\n\nFrom-SVN: r11490", "tree": {"sha": "b2a24e9d067dc4b308d861ec11d7161b96ed1710", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2a24e9d067dc4b308d861ec11d7161b96ed1710"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e9b00600ba508de8a86b1676a7e7be51828c566", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e9b00600ba508de8a86b1676a7e7be51828c566", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e9b00600ba508de8a86b1676a7e7be51828c566", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e9b00600ba508de8a86b1676a7e7be51828c566/comments", "author": null, "committer": null, "parents": [{"sha": "99561ab6ee54239ef7e435ab7c2ffc7c2f2313a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99561ab6ee54239ef7e435ab7c2ffc7c2f2313a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99561ab6ee54239ef7e435ab7c2ffc7c2f2313a9"}], "stats": {"total": 535, "additions": 535, "deletions": 0}, "files": [{"sha": "787bda75c0d1eb37b32735c90dd14c49154a9989", "filename": "gcc/config/pa/ee.asm", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9b00600ba508de8a86b1676a7e7be51828c566/gcc%2Fconfig%2Fpa%2Fee.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9b00600ba508de8a86b1676a7e7be51828c566/gcc%2Fconfig%2Fpa%2Fee.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fee.asm?ref=9e9b00600ba508de8a86b1676a7e7be51828c566", "patch": "@@ -0,0 +1,261 @@\n+;  Subroutines for out of line prologues and epilogues on for the HPPA\n+;  Copyright (C) 1994, 1995, 1996 Free Software Foundation, Inc.\n+\n+;  This file is part of GNU CC.\n+\n+;  GNU CC is free software; you can redistribute it and/or modify\n+;  it under the terms of the GNU General Public License as published by\n+;  the Free Software Foundation; either version 2, or (at your option)\n+;  any later version.\n+\n+;  GNU CC is distributed in the hope that it will be useful,\n+;  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;  GNU General Public License for more details.\n+\n+;  You should have received a copy of the GNU General Public License\n+;  along with GNU CC; see the file COPYING.  If not, write to\n+;  the Free Software Foundation, 59 Temple Place - Suite 330,\n+;  Boston, MA 02111-1307, USA.\n+\n+\t.SPACE $PRIVATE$\n+\t.SUBSPA $DATA$,QUAD=1,ALIGN=8,ACCESS=31\n+\t.SUBSPA $BSS$,QUAD=1,ALIGN=8,ACCESS=31,ZERO,SORT=82\n+\t.SPACE $TEXT$\n+\t.SUBSPA $LIT$,QUAD=0,ALIGN=8,ACCESS=44\n+\t.SUBSPA $CODE$,QUAD=0,ALIGN=8,ACCESS=44,CODE_ONLY\n+\t.SUBSPA $MILLICODE$,QUAD=0,ALIGN=8,ACCESS=44,SORT=8\n+\n+; This is an out-of-line prologue.\n+;\n+; It performs the following operations:\n+;\n+;\t* Saves the return pointer at sp - 20\n+;\n+;\t* Creates a new stack frame (sp'), size of the frame is passed in %r21\n+;\n+;\t* The old stack pointer is saved at sp (frame pointer version only).\n+;\n+;\t* Saves grs (passed in low 16 bits of %r22 into the stack frame\n+;\tat sp' + local_fsize (passed in %r19).\n+;\n+;\t* Saves frs (passed in high 16 bits of %r22) into the stack\n+;\tframe at sp' + local_fsize (passed in %r19).\n+;\n+;\t* Sets up a frame pointer (in %r3) (frame pointer version only).\n+;\n+;\t* Returns to the instruction _immediately_ after the call to\n+;\tthis function.\n+\n+\t.SPACE $TEXT$\n+\t.SUBSPA $MILLICODE$\n+\t.EXPORT __outline_prologue,MILLICODE\n+\t.align 32\n+__outline_prologue\n+\t.PROC\n+\t.CALLINFO FRAME=0,NO_CALLS\n+\t.ENTRY\n+\tcopy %r30,%r20\n+\n+\t; Subtract 4 from our return pointer so that we return to\n+\t; the right location.\n+        ldo -4(%r31),%r31\n+\n+\t; Save off %r2\n+\tstw %r2,-20(0,%r30)\n+\n+\t; Make our new frame.\n+\tadd %r21,%r30,%r30\n+\n+\t; Add in local_fsize to our frame pointer so we do register\n+\t; saves into the right place\n+\tadd %r20,%r19,%r20\n+\n+\t; %r22 tells us what registers we need to save.  The upper half\n+\t; is for fp registers, the lower half for integer registers.\n+\t; We put the lower half in %r1 and the upper half into %r22\n+\t; for later use.\n+\textru %r22,31,16,%r1\n+\textrs %r22,15,16,%r22\n+\n+\t; %r1 now olds a value 0-18 which corresponds to the number\n+\t; of grs we need to save.  We need to reverse that value so\n+\t; we can just into the table and straight-line execute to the\n+\t; end of the gr saves.\n+\tcomb,= %r0,%r1,L$0000\n+\tsubi 18,%r1,%r1\n+\tblr,n %r1,%r0\n+\tb,n L$0000\n+\tstws,ma %r18,4(0,%r20)\n+\tnop\n+\tstws,ma %r17,4(0,%r20)\n+\tnop\n+\tstws,ma %r16,4(0,%r20)\n+\tnop\n+\tstws,ma %r15,4(0,%r20)\n+\tnop\n+\tstws,ma %r14,4(0,%r20)\n+\tnop\n+\tstws,ma %r13,4(0,%r20)\n+\tnop\n+\tstws,ma %r12,4(0,%r20)\n+\tnop\n+\tstws,ma %r11,4(0,%r20)\n+\tnop\n+\tstws,ma %r10,4(0,%r20)\n+\tnop\n+\tstws,ma %r9,4(0,%r20)\n+\tnop\n+\tstws,ma %r8,4(0,%r20)\n+\tnop\n+\tstws,ma %r7,4(0,%r20)\n+\tnop\n+\tstws,ma %r6,4(0,%r20)\n+\tnop\n+\tstws,ma %r5,4(0,%r20)\n+\tnop\n+\tstws,ma %r4,4(0,%r20)\n+\tnop\n+\tstws,ma %r3,4(0,%r20)\n+\tnop\n+L$0000\n+\t; All gr saves are done.  Align the temporary frame pointer and\n+\t; do the fr saves.\n+\tldo 7(%r20),%r20\n+\tdepi 0,31,3,%r20\n+\n+\tcomb,= %r0,%r22,L$0001\n+\tsubi 21,%r22,%r22\n+\tblr,n %r22,%r0\n+\tb,n L$0001\n+\tfstws,ma %fr21,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr20,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr19,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr18,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr17,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr16,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr15,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr14,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr13,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr12,8(0,%r20)\n+\tnop\n+L$0001\n+\t; Return\n+\tbv,n 0(%r31)\n+\t.EXIT\n+\t.PROCEND\n+\n+\n+\n+\t.EXPORT __outline_epilogue,MILLICODE\n+\t.align 32\n+__outline_epilogue\n+\t.PROC\n+\t.CALLINFO FRAME=0,NO_CALLS\n+\t.ENTRY\n+\t; Get our original stack pointer and put it in %r20\n+\tsub %r30,%r21,%r20\n+\n+\t; Subtract 4 from our return pointer so that we return to\n+\t; the right location.\n+        ldo -4(%r31),%r31\n+\n+\t; Reload %r2\n+\tldw -20(0,%r20),%r2\n+\n+\t; Add in local_fsize (%r19) to the frame pointer to find\n+\t; the saved registers.\n+\tadd %r20,%r19,%r20\n+\n+\t; %r22 tells us what registers we need to restore.  The upper half\n+\t; is for fp registers, the lower half for integer registers.\n+\t; We put the lower half in %r1 and the upper half into %r22\n+\t; for later use.\n+\textru %r22,31,16,%r1\n+\textrs %r22,15,16,%r22\n+\n+\t; %r1 now olds a value 0-18 which corresponds to the number\n+\t; of grs we need to restore.  We need to reverse that value so\n+\t; we can just into the table and straight-line execute to the\n+\t; end of the gr restore.\n+\tcomb,= %r0,%r1,L$0004\n+\tsubi 18,%r1,%r1\n+\tblr,n %r1,%r0\n+\tb,n L$0004\n+\tldws,ma 4(0,%r20),%r18\n+\tnop\n+\tldws,ma 4(0,%r20),%r17\n+\tnop\n+\tldws,ma 4(0,%r20),%r16\n+\tnop\n+\tldws,ma 4(0,%r20),%r15\n+\tnop\n+\tldws,ma 4(0,%r20),%r14\n+\tnop\n+\tldws,ma 4(0,%r20),%r13\n+\tnop\n+\tldws,ma 4(0,%r20),%r12\n+\tnop\n+\tldws,ma 4(0,%r20),%r11\n+\tnop\n+\tldws,ma 4(0,%r20),%r10\n+\tnop\n+\tldws,ma 4(0,%r20),%r9\n+\tnop\n+\tldws,ma 4(0,%r20),%r8\n+\tnop\n+\tldws,ma 4(0,%r20),%r7\n+\tnop\n+\tldws,ma 4(0,%r20),%r6\n+\tnop\n+\tldws,ma 4(0,%r20),%r5\n+\tnop\n+\tldws,ma 4(0,%r20),%r4\n+\tnop\n+\tldws,ma 4(0,%r20),%r3\n+\tnop\n+L$0004\n+\t; All gr restore are done.  Align the temporary frame pointer and\n+\t; do the fr restore.\n+\tldo 7(%r20),%r20\n+\tdepi 0,31,3,%r20\n+\n+\tcomb,= %r0,%r22,L$0005\n+\tsubi 21,%r22,%r22\n+\tblr,n %r22,%r0\n+\tb,n L$0005\n+\tfldws,ma 8(0,%r20),%fr21\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr20\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr19\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr18\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr17\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr16\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr15\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr14\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr13\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr12\n+\tnop\n+L$0005\n+\t; Return and deallocate our frame.\n+\tbv 0(%r31)\n+\tsub %r30,%r21,%r30\n+\t.EXIT\n+\t.PROCEND"}, {"sha": "ef040cf7dad04e95a1650eae77f96758ed68f998", "filename": "gcc/config/pa/ee_fp.asm", "status": "added", "additions": 274, "deletions": 0, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e9b00600ba508de8a86b1676a7e7be51828c566/gcc%2Fconfig%2Fpa%2Fee_fp.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e9b00600ba508de8a86b1676a7e7be51828c566/gcc%2Fconfig%2Fpa%2Fee_fp.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fee_fp.asm?ref=9e9b00600ba508de8a86b1676a7e7be51828c566", "patch": "@@ -0,0 +1,274 @@\n+;  Subroutines for out of line prologues and epilogues on for the HPPA\n+;  Copyright (C) 1994, 1995, 1996 Free Software Foundation, Inc.\n+\n+;  This file is part of GNU CC.\n+\n+;  GNU CC is free software; you can redistribute it and/or modify\n+;  it under the terms of the GNU General Public License as published by\n+;  the Free Software Foundation; either version 2, or (at your option)\n+;  any later version.\n+\n+;  GNU CC is distributed in the hope that it will be useful,\n+;  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;  GNU General Public License for more details.\n+\n+;  You should have received a copy of the GNU General Public License\n+;  along with GNU CC; see the file COPYING.  If not, write to\n+;  the Free Software Foundation, 59 Temple Place - Suite 330,\n+;  Boston, MA 02111-1307, USA.\n+\n+\t.SPACE $PRIVATE$\n+\t.SUBSPA $DATA$,QUAD=1,ALIGN=8,ACCESS=31\n+\t.SUBSPA $BSS$,QUAD=1,ALIGN=8,ACCESS=31,ZERO,SORT=82\n+\t.SPACE $TEXT$\n+\t.SUBSPA $LIT$,QUAD=0,ALIGN=8,ACCESS=44\n+\t.SUBSPA $CODE$,QUAD=0,ALIGN=8,ACCESS=44,CODE_ONLY\n+\t.SUBSPA $MILLICODE$,QUAD=0,ALIGN=8,ACCESS=44,SORT=8\n+\n+\n+; This is an out-of-line prologue.\n+;\n+; It performs the following operations:\n+;\n+;\t* Saves the return pointer at sp - 20\n+;\n+;\t* Creates a new stack frame (sp'), size of the frame is passed in %r21\n+;\n+;\t* The old stack pointer is saved at sp (frame pointer version only).\n+;\n+;\t* Saves grs (passed in low 16 bits of %r22 into the stack frame\n+;\tat sp' + local_fsize (passed in %r19).\n+;\n+;\t* Saves frs (passed in high 16 bits of %r22) into the stack\n+;\tframe at sp' + local_fsize (passed in %r19).\n+;\n+;\t* Sets up a frame pointer (in %r3) (frame pointer version only).\n+;\n+;\t* Returns to the instruction _immediately_ after the call to\n+;\tthis function.\n+\n+\t.SPACE $TEXT$\n+\t.SUBSPA $MILLICODE$\n+\t.EXPORT __outline_prologue_fp,MILLICODE\n+\t.align 32\n+__outline_prologue_fp\n+\t.PROC\n+\t.CALLINFO FRAME=0,NO_CALLS\n+\t.ENTRY\n+\tcopy %r30,%r20\n+\n+\t; Subtract 4 from our return pointer so that we return to\n+\t; the right location.\n+        ldo -4(%r31),%r31\n+\n+\t; Save off %r2\n+\tstw %r2,-20(0,%r30)\n+\n+\t; Make our new frame.\n+\tadd %r21,%r30,%r30\n+\n+\t; Save our old stack pointer.\n+\tstw %r20,0(0,%r20)\n+\n+\t; Add in local_fsize to our frame pointer so we do register\n+\t; saves into the right place\n+\tadd %r20,%r19,%r20\n+\n+\t; %r22 tells us what registers we need to save.  The upper half\n+\t; is for fp registers, the lower half for integer registers.\n+\t; We put the lower half in %r1 and the upper half into %r22\n+\t; for later use.\n+\textru %r22,31,16,%r1\n+\textrs %r22,15,16,%r22\n+\n+\t; %r1 now olds a value 0-18 which corresponds to the number\n+\t; of grs we need to save.  We need to reverse that value so\n+\t; we can just into the table and straight-line execute to the\n+\t; end of the gr saves.\n+\tcomb,= %r0,%r1,L$0002\n+\tsubi 18,%r1,%r1\n+\tblr,n %r1,%r0\n+\tb,n L$0002\n+\tstws,ma %r18,4(0,%r20)\n+\tnop\n+\tstws,ma %r17,4(0,%r20)\n+\tnop\n+\tstws,ma %r16,4(0,%r20)\n+\tnop\n+\tstws,ma %r15,4(0,%r20)\n+\tnop\n+\tstws,ma %r14,4(0,%r20)\n+\tnop\n+\tstws,ma %r13,4(0,%r20)\n+\tnop\n+\tstws,ma %r12,4(0,%r20)\n+\tnop\n+\tstws,ma %r11,4(0,%r20)\n+\tnop\n+\tstws,ma %r10,4(0,%r20)\n+\tnop\n+\tstws,ma %r9,4(0,%r20)\n+\tnop\n+\tstws,ma %r8,4(0,%r20)\n+\tnop\n+\tstws,ma %r7,4(0,%r20)\n+\tnop\n+\tstws,ma %r6,4(0,%r20)\n+\tnop\n+\tstws,ma %r5,4(0,%r20)\n+\tnop\n+\tstws,ma %r4,4(0,%r20)\n+\tnop\n+\tstws,ma %r3,4(0,%r20)\n+\tnop\n+L$0002\n+\t; All gr saves are done.  Align the temporary frame pointer and\n+\t; do the fr saves.\n+\tldo 7(%r20),%r20\n+\tdepi 0,31,3,%r20\n+\n+\tcomb,= %r0,%r22,L$0003\n+\tsubi 21,%r22,%r22\n+\tblr,n %r22,%r0\n+\tb,n L$0003\n+\tfstws,ma %fr21,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr20,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr19,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr18,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr17,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr16,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr15,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr14,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr13,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr12,8(0,%r20)\n+\tnop\n+L$0003\n+\t; Return, setting up a frame pointer in the delay slot\n+\tbv 0(%r31)\n+\tsub %r30,%r21,%r3\n+\t.EXIT\n+\t.PROCEND\n+\n+\n+; This is an out-of-line epilogue.  It's operation is basically the reverse\n+; of the out-of-line prologue.\n+\n+\t.EXPORT __outline_epilogue_fp,MILLICODE\n+\t.align 32\n+__outline_epilogue_fp\n+\t.PROC\n+\t.CALLINFO FRAME=0,NO_CALLS\n+\t.ENTRY\n+\t; Make a copy of our frame pointer into %r20\n+\tcopy %r3,%r20\n+\n+\t; Subtract 4 from our return pointer so that we return to\n+\t; the right location.\n+        ldo -4(%r31),%r31\n+\n+\t; Reload %r2\n+\t; First save off %r2\n+\tldw -20(0,%r20),%r2\n+\n+\t; Load our old stack pointer, save it in %r21.\n+\tldw 0(0,%r20),%r21\n+\n+\t; Add in local_fsize (%r19) to the frame pointer to find\n+\t; the saved registers.\n+\tadd %r20,%r19,%r20\n+\n+\t; %r22 tells us what registers we need to restore.  The upper half\n+\t; is for fp registers, the lower half for integer registers.\n+\t; We put the lower half in %r1 and the upper half into %r22\n+\t; for later use.\n+\textru %r22,31,16,%r1\n+\textrs %r22,15,16,%r22\n+\n+\t; %r1 now olds a value 0-18 which corresponds to the number\n+\t; of grs we need to restore.  We need to reverse that value so\n+\t; we can just into the table and straight-line execute to the\n+\t; end of the gr restore.\n+\tcomb,= %r0,%r1,L$0006\n+\tsubi 18,%r1,%r1\n+\tblr,n %r1,%r0\n+\tb,n L$0006\n+\tldws,ma 4(0,%r20),%r18\n+\tnop\n+\tldws,ma 4(0,%r20),%r17\n+\tnop\n+\tldws,ma 4(0,%r20),%r16\n+\tnop\n+\tldws,ma 4(0,%r20),%r15\n+\tnop\n+\tldws,ma 4(0,%r20),%r14\n+\tnop\n+\tldws,ma 4(0,%r20),%r13\n+\tnop\n+\tldws,ma 4(0,%r20),%r12\n+\tnop\n+\tldws,ma 4(0,%r20),%r11\n+\tnop\n+\tldws,ma 4(0,%r20),%r10\n+\tnop\n+\tldws,ma 4(0,%r20),%r9\n+\tnop\n+\tldws,ma 4(0,%r20),%r8\n+\tnop\n+\tldws,ma 4(0,%r20),%r7\n+\tnop\n+\tldws,ma 4(0,%r20),%r6\n+\tnop\n+\tldws,ma 4(0,%r20),%r5\n+\tnop\n+\tldws,ma 4(0,%r20),%r4\n+\tnop\n+\tldws,ma 4(0,%r20),%r3\n+\tnop\n+L$0006\n+\t; All gr restore are done.  Align the temporary frame pointer and\n+\t; do the fr restore.\n+\tldo 7(%r20),%r20\n+\tdepi 0,31,3,%r20\n+\n+\tcomb,= %r0,%r22,L$0007\n+\tsubi 21,%r22,%r22\n+\tblr,n %r22,%r0\n+\tb,n L$0007\n+\tfldws,ma 8(0,%r20),%fr21\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr20\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr19\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr18\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr17\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr16\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr15\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr14\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr13\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr12\n+\tnop\n+L$0007\n+\t; Return and deallocate our frame.\n+\tbv 0(%r31)\n+\tcopy %r21,%r30\n+\t.EXIT\n+\t.PROCEND\n+\n+"}]}