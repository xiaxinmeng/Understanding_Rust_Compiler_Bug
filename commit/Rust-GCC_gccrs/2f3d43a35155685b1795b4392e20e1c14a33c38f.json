{"sha": "2f3d43a35155685b1795b4392e20e1c14a33c38f", "node_id": "C_kwDOANBUbNoAKDJmM2Q0M2EzNTE1NTY4NWIxNzk1YjQzOTJlMjBlMWMxNGEzM2MzOGY", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-13T00:51:25Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-13T00:51:25Z"}, "message": "Fix wrong code with modref and some builtins.\n\nipa-modref gets confused by EAF flags of memcpy becuase parameter 1 is\nescaping but used only directly.  In modref we do not track values saved to\nmemory and thus we clear all other flags on each store.  This needs to also\nhappen when called function escapes parameter.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/103182\n\t* ipa-modref.c (callee_to_caller_flags): Fix merging of flags.\n\t(modref_eaf_analysis::analyze_ssa_name): Fix merging of flags.", "tree": {"sha": "62c93bdcc3a21cb6f0f23479da2bc320a6c33e57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62c93bdcc3a21cb6f0f23479da2bc320a6c33e57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f3d43a35155685b1795b4392e20e1c14a33c38f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f3d43a35155685b1795b4392e20e1c14a33c38f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f3d43a35155685b1795b4392e20e1c14a33c38f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f3d43a35155685b1795b4392e20e1c14a33c38f/comments", "author": null, "committer": null, "parents": [{"sha": "60f761c7e54f96a287c73a71d0b09ee2b2f8426d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60f761c7e54f96a287c73a71d0b09ee2b2f8426d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60f761c7e54f96a287c73a71d0b09ee2b2f8426d"}], "stats": {"total": 30, "additions": 14, "deletions": 16}, "files": [{"sha": "90985cc13269504a188d6b3484ec91714ee6afc3", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f3d43a35155685b1795b4392e20e1c14a33c38f/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f3d43a35155685b1795b4392e20e1c14a33c38f/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=2f3d43a35155685b1795b4392e20e1c14a33c38f", "patch": "@@ -1888,19 +1888,18 @@ callee_to_caller_flags (int call_flags, bool ignore_stores,\n      that is not the same as caller returning it.  */\n   call_flags |= EAF_NOT_RETURNED_DIRECTLY\n \t\t| EAF_NOT_RETURNED_INDIRECTLY;\n-  /* TODO: We miss return value propagation.\n-     Be conservative and if value escapes to memory\n-     also mark it as escaping.  */\n   if (!ignore_stores && !(call_flags & EAF_UNUSED))\n     {\n+      /* If value escapes we are no longer able to track what happens\n+\t with it because we can read it from the escaped location\n+\t anytime.  */\n       if (!(call_flags & EAF_NO_DIRECT_ESCAPE))\n-\tlattice.merge (~(EAF_NOT_RETURNED_DIRECTLY\n-\t\t\t | EAF_NOT_RETURNED_INDIRECTLY\n-\t\t\t | EAF_NO_DIRECT_READ\n-\t\t\t | EAF_UNUSED));\n-      if (!(call_flags & EAF_NO_INDIRECT_ESCAPE))\n+\tlattice.merge (0);\n+      else if (!(call_flags & EAF_NO_INDIRECT_ESCAPE))\n \tlattice.merge (~(EAF_NOT_RETURNED_INDIRECTLY\n \t\t\t | EAF_NO_DIRECT_READ\n+\t\t\t | EAF_NO_INDIRECT_READ\n+\t\t\t | EAF_NO_INDIRECT_CLOBBER\n \t\t\t | EAF_UNUSED));\n     }\n   else\n@@ -2036,18 +2035,17 @@ modref_eaf_analysis::analyze_ssa_name (tree name)\n \t\t\t not_returned and escape has same meaning.\n \t\t\t However passing arg to return slot is different.  If\n \t\t\t the callee's return slot is returned it means that\n-\t\t\t arg is written to itself which is an escape.  */\n+\t\t\t arg is written to itself which is an escape.\n+\t\t\t Since we do not track the memory it is written to we\n+\t\t\t need to give up on analysisng it.  */\n \t\t      if (!isretslot)\n \t\t\t{\n \t\t\t  if (!(call_flags & (EAF_NOT_RETURNED_DIRECTLY\n \t\t\t\t\t      | EAF_UNUSED)))\n-\t\t\t    m_lattice[index].merge (~(EAF_NO_DIRECT_ESCAPE\n-\t\t\t\t\t\t      | EAF_UNUSED));\n-\t\t\t  if (!(call_flags & (EAF_NOT_RETURNED_INDIRECTLY\n-\t\t\t\t\t      | EAF_UNUSED)))\n-\t\t\t    m_lattice[index].merge (~(EAF_NO_INDIRECT_ESCAPE\n-\t\t\t\t\t\t      | EAF_NO_DIRECT_READ\n-\t\t\t\t\t\t      | EAF_UNUSED));\n+\t\t\t    m_lattice[index].merge (0);\n+\t\t\t  else gcc_checking_assert\n+\t\t\t\t(call_flags & (EAF_NOT_RETURNED_INDIRECTLY\n+\t\t\t\t\t       | EAF_UNUSED));\n \t\t\t  call_flags = callee_to_caller_flags\n \t\t\t\t\t   (call_flags, false,\n \t\t\t\t\t    m_lattice[index]);"}]}