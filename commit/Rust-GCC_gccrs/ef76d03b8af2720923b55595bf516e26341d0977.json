{"sha": "ef76d03b8af2720923b55595bf516e26341d0977", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWY3NmQwM2I4YWYyNzIwOTIzYjU1NTk1YmY1MTZlMjYzNDFkMDk3Nw==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1997-06-16T00:43:19Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1997-06-16T00:43:19Z"}, "message": "(dwarf2out_frame_debug): Handle IOR.\n\n(struct limbo_die_struct): Define.\n(TYPE_DECL_IS_STUB): Call decl_ultimate_origin if DECL_ABTRACT_ORIGIN\nis set.\n(limbo_die_count): Delete.\n(libmo_die_list): Define.\n(new_die): Add die to limbo_die_list instead of incrementing\nlimbo_die_count.\n(add_AT_location_description): Renamed from add_location_attribute.\nNew parameter attr_kind.\n(add_location_or_const_value_attribute, gen_subprogram_die,\nadd_bound_info): Change call to add_AT_location_description.\n(add_bound_info): Add call to contains_placeholder_p.  Ignore\nMAX_EXPR and VAR_DECL.\n(add_subscript_info): Ignore the index type if it is an unnamed\nintegral type.\n(scope_die_for): Move check for function-local tags after code setting\ncontaining_scope, and add check for non-NULL containing_scope\n(add_type_attribute): If unnamed type, use TREE_TYPE instead.\n(gen_enumeration_type_die, gen_struct_or_union_type_die): Call\nadd_child_die if die_parent is NULL.\n(gen_subprogram_die): Ifdef out DW_AT_static_link code.\n(decls_for_scope): Delete decrement of limbo_die_count.\n(dwarf2out_finish): Add code to traverse the limbo_die_list, and\ncall add_child_die if die_parent is NULL.  Delete limbo_die_count code.\n\nFrom-SVN: r14248", "tree": {"sha": "b0b892e4bb2295e71907be8c3aebbdd05342c8ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0b892e4bb2295e71907be8c3aebbdd05342c8ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef76d03b8af2720923b55595bf516e26341d0977", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef76d03b8af2720923b55595bf516e26341d0977", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef76d03b8af2720923b55595bf516e26341d0977", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef76d03b8af2720923b55595bf516e26341d0977/comments", "author": null, "committer": null, "parents": [{"sha": "babae559e20a35de8621284fa6e0712eb47383be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/babae559e20a35de8621284fa6e0712eb47383be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/babae559e20a35de8621284fa6e0712eb47383be"}], "stats": {"total": 153, "additions": 123, "deletions": 30}, "files": [{"sha": "4ef451f4efe55078e08bd6f8440da76dff94ec34", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 123, "deletions": 30, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef76d03b8af2720923b55595bf516e26341d0977/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef76d03b8af2720923b55595bf516e26341d0977/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=ef76d03b8af2720923b55595bf516e26341d0977", "patch": "@@ -850,6 +850,14 @@ dwarf2out_frame_debug (insn)\n \t  cfa_temp_value = INTVAL (src);\n \t  break;\n \n+\tcase IOR:\n+\t  assert (GET_CODE (XEXP (src, 0)) == REG\n+\t\t  && REGNO (XEXP (src, 0)) == cfa_temp_reg);\n+\t  assert (REGNO (dest) == cfa_temp_reg);\n+\t  assert (GET_CODE (XEXP (src, 1)) == CONST_INT);\n+\t  cfa_temp_value |= INTVAL (XEXP (src, 1));\n+\t  break;\n+\n \tdefault:\n \t  abort ();\n \t}\n@@ -1630,6 +1638,14 @@ typedef struct pubname_struct\n }\n pubname_entry;\n \n+/* The limbo die list structure.  */\n+typedef struct limbo_die_struct\n+{\n+  dw_die_ref die;\n+  struct limbo_die_struct *next;\n+}\n+limbo_die_node;\n+\n /* How to start an assembler comment.  */\n #ifndef ASM_COMMENT_START\n #define ASM_COMMENT_START \";#\"\n@@ -1649,7 +1665,12 @@ pubname_entry;\n   (DECL_NAME (decl) == NULL_TREE\t\t\t\\\n    || (DECL_ARTIFICIAL (decl)\t\t\t\t\\\n        && is_tagged_type (TREE_TYPE (decl))\t\t\\\n-       && decl == TYPE_STUB_DECL (TREE_TYPE (decl))))\n+       && ((decl == TYPE_STUB_DECL (TREE_TYPE (decl)))\t\\\n+\t   /* This is necessary for stub decls that\t\\\n+\t      appear in nested inline functions.  */\t\\\n+\t   || (DECL_ABSTRACT_ORIGIN (decl) != NULL_TREE\t\\\n+\t       && (decl_ultimate_origin (decl)\t\t\\\n+\t\t   == TYPE_STUB_DECL (TREE_TYPE (decl)))))))\n \n /* Information concerning the compilation unit's programming\n    language, and compiler version.  */\n@@ -1705,8 +1726,8 @@ static unsigned long next_die_offset;\n /* Record the root of the DIE's built for the current compilation unit.  */\n static dw_die_ref comp_unit_die;\n \n-/* The number of DIEs with a NULL parent waiting to be relocated.  */\n-static int limbo_die_count;\n+/* A list of DIEs with a NULL parent waiting to be relocated.  */\n+static limbo_die_node *limbo_die_list = 0;\n \n /* Pointer to an array of filenames referenced by this compilation unit.  */\n static char **file_table;\n@@ -1977,7 +1998,8 @@ static tree field_type\t\t\tPROTO((tree));\n static unsigned simple_type_align_in_bits PROTO((tree));\n static unsigned simple_type_size_in_bits PROTO((tree));\n static unsigned field_byte_offset\t\tPROTO((tree));\n-static void add_location_attribute\tPROTO((dw_die_ref, rtx));\n+static void add_AT_location_description\tPROTO((dw_die_ref,\n+\t\t\t\t\t       enum dwarf_attribute, rtx));\n static void add_data_member_location_attribute PROTO((dw_die_ref, tree));\n static void add_const_value_attribute\tPROTO((dw_die_ref, rtx));\n static void add_location_or_const_value_attribute PROTO((dw_die_ref, tree));\n@@ -3608,7 +3630,14 @@ new_die (tag_value, parent_die)\n   if (parent_die != NULL)\n     add_child_die (parent_die, die);\n   else\n-    ++limbo_die_count;\n+    {\n+      limbo_die_node *limbo_node;\n+\n+      limbo_node = (limbo_die_node *) xmalloc (sizeof (limbo_die_node));\n+      limbo_node->die = die;\n+      limbo_node->next = limbo_die_list;\n+      limbo_die_list = limbo_node;\n+    }\n \n   return die;\n }\n@@ -6097,14 +6126,16 @@ field_byte_offset (decl)\n /* The following routines define various Dwarf attributes and any data\n    associated with them.  */\n \n+/* Add a location description attribute value to a DIE.\n \n-/* Output the form of location attributes suitable for whole variables and\n+   This emits location attributes suitable for whole variables and\n    whole parameters.  Note that the location attributes for struct fields are\n    generated by the routine `data_member_location_attribute' below.  */\n \n static void\n-add_location_attribute (die, rtl)\n+add_AT_location_description (die, attr_kind, rtl)\n      dw_die_ref die;\n+     enum dwarf_attribute attr_kind;\n      register rtx rtl;\n {\n   dw_loc_descr_ref loc_descr = NULL;\n@@ -6138,7 +6169,7 @@ add_location_attribute (die, rtl)\n     loc_descr = loc_descriptor (gen_rtx (REG, word_mode, 0));\n #endif\n \n-  add_AT_loc (die, DW_AT_location, loc_descr);\n+  add_AT_loc (die, attr_kind, loc_descr);\n }\n \n /* Attach the specialized form of location attribute used for data\n@@ -6429,7 +6460,7 @@ add_location_or_const_value_attribute (die, decl)\n     case MEM:\n     case REG:\n     case SUBREG:\n-      add_location_attribute (die, rtl);\n+      add_AT_location_description (die, DW_AT_location, rtl);\n       break;\n \n     default:\n@@ -6459,6 +6490,13 @@ add_bound_info (subrange_die, bound_attr, bound)\n      register tree bound;\n {\n   register unsigned bound_value = 0;\n+\n+  /* If this is an Ada unconstrained array type, then don't emit any debug\n+     info because the array bounds are unknown.  They are parameterized when\n+     the type is instantiated.  */\n+  if (contains_placeholder_p (bound))\n+    return;\n+\n   switch (TREE_CODE (bound))\n     {\n     case ERROR_MARK:\n@@ -6510,13 +6548,20 @@ add_bound_info (subrange_die, bound_attr, bound)\n \t  register dw_die_ref decl_die = new_die (DW_TAG_variable, ctx);\n \t  add_AT_flag (decl_die, DW_AT_artificial, 1);\n \t  add_type_attribute (decl_die, TREE_TYPE (bound), 1, 0, ctx);\n-\t  add_location_attribute (decl_die, SAVE_EXPR_RTL (bound));\n+\t  add_AT_location_description (decl_die, DW_AT_location,\n+\t\t\t\t       SAVE_EXPR_RTL (bound));\n \t  add_AT_die_ref (subrange_die, bound_attr, decl_die);\n \t}\n \n       /* Else leave out the attribute.  */\n       break;\n \n+    case MAX_EXPR:\n+    case VAR_DECL:\n+      /* ??? These types of bounds can be created by the Ada front end,\n+\t and it isn't clear how to emit debug info for them.  */\n+      break;\n+\n     default:\n       abort ();\n     }\n@@ -6567,8 +6612,19 @@ add_subscript_info (type_die, type)\n \n \t  /* define the index type.  */\n \t  if (TREE_TYPE (domain))\n-\t    add_type_attribute (subrange_die, TREE_TYPE (domain), 0, 0,\n-\t\t\t\ttype_die);\n+\t    {\n+\t      /* ??? This is probably an Ada unnamed subrange type.  Ignore the\n+\t\t TREE_TYPE field.  We can't emit debug info for this\n+\t\t because it is an unnamed integral type.  */\n+\t      if (TREE_CODE (domain) == INTEGER_TYPE\n+\t\t  && TYPE_NAME (domain) == NULL_TREE\n+\t\t  && TREE_CODE (TREE_TYPE (domain)) == INTEGER_TYPE\n+\t\t  && TYPE_NAME (TREE_TYPE (domain)) == NULL_TREE)\n+\t\t;\t\n+\t      else\n+\t\tadd_type_attribute (subrange_die, TREE_TYPE (domain), 0, 0,\n+\t\t\t\t    type_die);\n+\t    }\n \n \t  add_bound_info (subrange_die, DW_AT_lower_bound, lower);\n \t  add_bound_info (subrange_die, DW_AT_upper_bound, upper);\n@@ -6818,12 +6874,6 @@ scope_die_for (t, context_die)\n   register tree containing_scope;\n   register unsigned long i;\n \n-  /* Function-local tags and functions get stuck in limbo until they are\n-     fixed up by decls_for_scope.  */\n-  if (context_die == NULL\n-      && (TREE_CODE (t) == FUNCTION_DECL || is_tagged_type (t)))\n-    return NULL;\n-\n   /* Walk back up the declaration tree looking for a place to define\n      this type.  */\n   if (TREE_CODE_CLASS (TREE_CODE (t)) == 't')\n@@ -6833,6 +6883,12 @@ scope_die_for (t, context_die)\n   else\n     containing_scope = DECL_CONTEXT (t);\n \n+  /* Function-local tags and functions get stuck in limbo until they are\n+     fixed up by decls_for_scope.  */\n+  if (context_die == NULL && containing_scope != NULL_TREE\n+      && (TREE_CODE (t) == FUNCTION_DECL || is_tagged_type (t)))\n+    return NULL;\n+\n   if (containing_scope == NULL_TREE)\n     scope_die = comp_unit_die;\n   else\n@@ -6877,8 +6933,10 @@ add_type_attribute (object_die, type, decl_const, decl_volatile, context_die)\n   register enum tree_code code  = TREE_CODE (type);\n   register dw_die_ref type_die  = NULL;\n \n-  /* If this type is an unnamed subtype of an integral or floating-point\n-     type, use the inner type.  */\n+  /* ??? If this type is an unnamed subrange type of an integral or\n+     floating-point type, use the inner type.  This is because we have no\n+     support for unnamed types in base_type_die.  This can happen if this is\n+     an Ada subrange type.  Correct solution is emit a subrange type die.  */\n   if ((code == INTEGER_TYPE || code == REAL_TYPE)\n       && TREE_TYPE (type) != 0 && TYPE_NAME (type) == 0)\n     type = TREE_TYPE (type), code = TREE_CODE (type);\n@@ -7177,6 +7235,11 @@ gen_enumeration_type_die (type, context_die)\n       if (type_tag (type))\n \tadd_src_coords_attributes (type_die, TYPE_STUB_DECL (type));\n \n+      /* If the first reference to this type was as the return type of an\n+\t inline function, then it may not have a parent.  Fix this now.  */\n+      if (type_die->die_parent == NULL)\n+\tadd_child_die (scope_die_for (type, context_die), type_die);\n+\n       for (link = TYPE_FIELDS (type);\n \t   link != NULL; link = TREE_CHAIN (link))\n \t{\n@@ -7486,9 +7549,13 @@ gen_subprogram_die (decl, context_die)\n \t= frame_pointer_needed ? hard_frame_pointer_rtx : stack_pointer_rtx;\n       add_AT_loc (subr_die, DW_AT_frame_base, reg_loc_descriptor (fp_reg));\n \n+#if 0\n+      /* ??? This fails for nested inline functions, because context_display\n+\t is not part of the state saved/restored for inline functions.  */\n       if (current_function_needs_context)\n-\tadd_AT_loc (subr_die, DW_AT_static_link,\n-\t\t    loc_descriptor (lookup_static_chain (decl)));\n+\tadd_AT_location_description (subr_die, DW_AT_static_link,\n+\t\t\t\t     lookup_static_chain (decl));\n+#endif\n     }\n \n   /* Now output descriptions of the arguments for this function. This gets\n@@ -8028,6 +8095,11 @@ gen_struct_or_union_type_die (type, context_die)\n       if (type_tag (type))\n \tadd_src_coords_attributes (type_die, TYPE_STUB_DECL (type));\n \n+      /* If the first reference to this type was as the return type of an\n+\t inline function, then it may not have a parent.  Fix this now.  */\n+      if (type_die->die_parent == NULL)\n+\tadd_child_die (scope_die, type_die);\n+\n       push_decl_scope (type);\n       gen_member_die (type, type_die);\n       pop_decl_scope ();\n@@ -8397,10 +8469,7 @@ decls_for_scope (stmt, context_die, depth)\n \tdie = NULL;\n \n       if (die != NULL && die->die_parent == NULL)\n-\t{\n-\t  add_child_die (context_die, die);\n-\t  --limbo_die_count;\n-\t}\n+\tadd_child_die (context_die, die);\n       else\n \tgen_decl_die (decl, context_die);\n     }\n@@ -8503,7 +8572,7 @@ gen_decl_die (decl, context_die)\n          having been instantiated from some other (original) TYPE_DECL node\n          (e.g. one which was generated within the original definition of an\n          inline function) we have to generate a special (abbreviated)\n-         DW_TAG_structure_type, DW_TAG_union_type, or DW_TAG_enumeration-type \n+         DW_TAG_structure_type, DW_TAG_union_type, or DW_TAG_enumeration_type \n          DIE here.  */\n       if (TYPE_DECL_IS_STUB (decl) && DECL_ABSTRACT_ORIGIN (decl) != NULL_TREE)\n \t{\n@@ -8968,6 +9037,33 @@ dwarf2out_init (asm_out_file, main_input_filename)\n void\n dwarf2out_finish ()\n {\n+  limbo_die_node *node, *next_node;\n+  dw_die_ref die;\n+  dw_attr_ref a;\n+\n+  /* Traverse the limbo die list, and add parent/child links.  The only\n+     dies without parents that should be here are concrete instances of\n+     inline functions, and the comp_unit_die.  We can ignore the comp_unit_die.\n+     For concrete instances, we can get the parent die from the abstract\n+     instance.  */\n+  for (node = limbo_die_list; node; node = next_node)\n+    {\n+      next_node = node->next;\n+      die = node->die;\n+\n+      if (die->die_parent == NULL)\n+\t{\n+\t  a = get_AT (die, DW_AT_abstract_origin);\n+\t  if (a)\n+\t    add_child_die (a->dw_attr_val.v.val_die_ref->die_parent, die);\n+\t  else if (die == comp_unit_die)\n+\t      ;\n+\t  else\n+\t    abort ();\n+\t}\n+      free (node);\n+    }\n+\n   /* Traverse the DIE tree and add sibling attributes to those DIE's\n      that have children.  */\n   add_sibling_attributes (comp_unit_die);\n@@ -9042,8 +9138,5 @@ dwarf2out_finish ()\n       ASM_OUTPUT_SECTION (asm_out_file, ARANGES_SECTION);\n       output_aranges ();\n     }\n-\n-  /* The only DIE we should have with a parent of NULL is comp_unit_die.  */\n-  assert (limbo_die_count == 1);\n }\n #endif /* DWARF2_DEBUGGING_INFO */"}]}