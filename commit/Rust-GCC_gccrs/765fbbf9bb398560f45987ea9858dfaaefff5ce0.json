{"sha": "765fbbf9bb398560f45987ea9858dfaaefff5ce0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY1ZmJiZjliYjM5ODU2MGY0NTk4N2VhOTg1OGRmYWFlZmZmNWNlMA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-07-15T14:38:35Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-07-15T14:41:30Z"}, "message": "c++: refactor some parser code\n\ncp_parser_declaration copies tokens to local variables, before inspecting\n(some of) their fields.  There's no need.  Just point at them in the token\nbuffer -- they don't move.  Also, we never look at the second token if the\nfirst is EOF, so no need for some kind of dummy value in that case.\n\n\tgcc/cp/\n\t* parser.c (cp_parser_declaration): Avoid copying tokens.\n\t(cp_parser_block_declaration): RAII token pointer.", "tree": {"sha": "e669911f01e67c1bb48cbb4c13009c629f018748", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e669911f01e67c1bb48cbb4c13009c629f018748"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/765fbbf9bb398560f45987ea9858dfaaefff5ce0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/765fbbf9bb398560f45987ea9858dfaaefff5ce0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/765fbbf9bb398560f45987ea9858dfaaefff5ce0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/765fbbf9bb398560f45987ea9858dfaaefff5ce0/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "790b1f64157b53265f85ad9a093cdce03761db87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/790b1f64157b53265f85ad9a093cdce03761db87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/790b1f64157b53265f85ad9a093cdce03761db87"}], "stats": {"total": 61, "additions": 27, "deletions": 34}, "files": [{"sha": "11db02418bc9722ceff2c34a9fbd9b0c50d1d7df", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 27, "deletions": 34, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/765fbbf9bb398560f45987ea9858dfaaefff5ce0/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/765fbbf9bb398560f45987ea9858dfaaefff5ce0/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=765fbbf9bb398560f45987ea9858dfaaefff5ce0", "patch": "@@ -13402,11 +13402,7 @@ cp_parser_declaration_seq_opt (cp_parser* parser)\n static void\n cp_parser_declaration (cp_parser* parser)\n {\n-  cp_token token1;\n-  cp_token token2;\n   int saved_pedantic;\n-  void *p;\n-  tree attributes = NULL_TREE;\n \n   /* Check for the `__extension__' keyword.  */\n   if (cp_parser_extension_opt (parser, &saved_pedantic))\n@@ -13420,76 +13416,74 @@ cp_parser_declaration (cp_parser* parser)\n     }\n \n   /* Try to figure out what kind of declaration is present.  */\n-  token1 = *cp_lexer_peek_token (parser->lexer);\n+  cp_token *token1 = cp_lexer_peek_token (parser->lexer);\n+  cp_token *token2 = NULL;\n \n-  if (token1.type != CPP_EOF)\n-    token2 = *cp_lexer_peek_nth_token (parser->lexer, 2);\n-  else\n-    {\n-      token2.type = CPP_EOF;\n-      token2.keyword = RID_MAX;\n-    }\n+  if (token1->type != CPP_EOF)\n+    token2 = cp_lexer_peek_nth_token (parser->lexer, 2);\n \n   /* Get the high-water mark for the DECLARATOR_OBSTACK.  */\n-  p = obstack_alloc (&declarator_obstack, 0);\n+  void *p = obstack_alloc (&declarator_obstack, 0);\n+\n+  tree attributes = NULL_TREE;\n \n   /* If the next token is `extern' and the following token is a string\n      literal, then we have a linkage specification.  */\n-  if (token1.keyword == RID_EXTERN\n-      && cp_parser_is_pure_string_literal (&token2))\n+  if (token1->keyword == RID_EXTERN\n+      && cp_parser_is_pure_string_literal (token2))\n     cp_parser_linkage_specification (parser);\n   /* If the next token is `template', then we have either a template\n      declaration, an explicit instantiation, or an explicit\n      specialization.  */\n-  else if (token1.keyword == RID_TEMPLATE)\n+  else if (token1->keyword == RID_TEMPLATE)\n     {\n       /* `template <>' indicates a template specialization.  */\n-      if (token2.type == CPP_LESS\n+      if (token2->type == CPP_LESS\n \t  && cp_lexer_peek_nth_token (parser->lexer, 3)->type == CPP_GREATER)\n \tcp_parser_explicit_specialization (parser);\n       /* `template <' indicates a template declaration.  */\n-      else if (token2.type == CPP_LESS)\n+      else if (token2->type == CPP_LESS)\n \tcp_parser_template_declaration (parser, /*member_p=*/false);\n       /* Anything else must be an explicit instantiation.  */\n       else\n \tcp_parser_explicit_instantiation (parser);\n     }\n   /* If the next token is `export', then we have a template\n      declaration.  */\n-  else if (token1.keyword == RID_EXPORT)\n+  else if (token1->keyword == RID_EXPORT)\n     cp_parser_template_declaration (parser, /*member_p=*/false);\n   /* If the next token is `extern', 'static' or 'inline' and the one\n      after that is `template', we have a GNU extended explicit\n      instantiation directive.  */\n   else if (cp_parser_allow_gnu_extensions_p (parser)\n-\t   && (token1.keyword == RID_EXTERN\n-\t       || token1.keyword == RID_STATIC\n-\t       || token1.keyword == RID_INLINE)\n-\t   && token2.keyword == RID_TEMPLATE)\n+\t   && token2->keyword == RID_TEMPLATE\n+\t   && (token1->keyword == RID_EXTERN\n+\t       || token1->keyword == RID_STATIC\n+\t       || token1->keyword == RID_INLINE))\n     cp_parser_explicit_instantiation (parser);\n   /* If the next token is `namespace', check for a named or unnamed\n      namespace definition.  */\n-  else if (token1.keyword == RID_NAMESPACE\n+  else if (token1->keyword == RID_NAMESPACE\n \t   && (/* A named namespace definition.  */\n-\t       (token2.type == CPP_NAME\n+\t       (token2->type == CPP_NAME\n \t\t&& (cp_lexer_peek_nth_token (parser->lexer, 3)->type\n \t\t    != CPP_EQ))\n-               || (token2.type == CPP_OPEN_SQUARE\n+               || (token2->type == CPP_OPEN_SQUARE\n                    && cp_lexer_peek_nth_token (parser->lexer, 3)->type\n                    == CPP_OPEN_SQUARE)\n \t       /* An unnamed namespace definition.  */\n-\t       || token2.type == CPP_OPEN_BRACE\n-\t       || token2.keyword == RID_ATTRIBUTE))\n+\t       || token2->type == CPP_OPEN_BRACE\n+\t       || token2->keyword == RID_ATTRIBUTE))\n     cp_parser_namespace_definition (parser);\n   /* An inline (associated) namespace definition.  */\n-  else if (token1.keyword == RID_INLINE\n-\t   && token2.keyword == RID_NAMESPACE)\n+  else if (token2->keyword == RID_NAMESPACE\n+\t   && token1->keyword == RID_INLINE)\n     cp_parser_namespace_definition (parser);\n   /* Objective-C++ declaration/definition.  */\n-  else if (c_dialect_objc () && OBJC_IS_AT_KEYWORD (token1.keyword))\n+  else if (c_dialect_objc () && OBJC_IS_AT_KEYWORD (token1->keyword))\n     cp_parser_objc_declaration (parser, NULL_TREE);\n   else if (c_dialect_objc ()\n-\t   && token1.keyword == RID_ATTRIBUTE\n+\t   && token1->keyword == RID_ATTRIBUTE\n \t   && cp_parser_objc_valid_prefix_attributes (parser, &attributes))\n     cp_parser_objc_declaration (parser, attributes);\n   /* At this point we may have a template declared by a concept\n@@ -13558,7 +13552,6 @@ static void\n cp_parser_block_declaration (cp_parser *parser,\n \t\t\t     bool      statement_p)\n {\n-  cp_token *token1;\n   int saved_pedantic;\n \n   /* Check for the `__extension__' keyword.  */\n@@ -13574,7 +13567,7 @@ cp_parser_block_declaration (cp_parser *parser,\n \n   /* Peek at the next token to figure out which kind of declaration is\n      present.  */\n-  token1 = cp_lexer_peek_token (parser->lexer);\n+  cp_token *token1 = cp_lexer_peek_token (parser->lexer);\n \n   /* If the next keyword is `asm', we have an asm-definition.  */\n   if (token1->keyword == RID_ASM)"}]}