{"sha": "ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2EzMTc5OGU3YmY4Zjg3ZDc4ZmYxZWU2NmMxMjBiMTM1YTFiMmViYw==", "commit": {"author": {"name": "Andre Vieira", "email": "andre.simoesdiasvieira@arm.com", "date": "2018-11-13T14:11:46Z"}, "committer": {"name": "Andre Vieira", "email": "avieira@gcc.gnu.org", "date": "2018-11-13T14:11:46Z"}, "message": "[PATCH][GCC] Make DR_TARGET_ALIGNMENT compile time variable\n\nThis patch enables targets to describe DR_TARGET_ALIGNMENT as a compile-time\nvariable.  It does so by turning the variable into a 'poly_uint64'.\n\ngcc/ChangeLog:\n2018-11-13  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n\n\t* config/aarch64/aarch64.c\n\t(aarch64_vectorize_preferred_vector_alignment): Change return type to\n\tpoly_uint64.\n\t(aarch64_simd_vector_alignment_reachable): Adapt to preferred vector\n\talignment being a poly int.\n\t* doc/tm.texi (TARGET_VECTORIZE_PREFERRED_VECTOR_ALIGNMENT): Change\n\treturn type to poly_uint64.\n\t* target.def (default_preferred_vector_alignment): Likewise.\n\t* targhooks.c (default_preferred_vector_alignment): Likewise.\n\t* targhooks.h (default_preferred_vector_alignment): Likewise.\n\t* tree-vect-data-refs.c (vect_calculate_target_alignment): Likewise.\n\t(vect_compute_data_ref_alignment): Adapt to vector alignment being a\n\tpoly int.\n\t(vect_update_misalignment_for_peel): Likewise.\n\t(vect_enhance_data_refs_alignment): Likewise.\n\t(vect_find_same_alignment_drs): Likewise.\n\t(vect_duplicate_ssa_name_ptr_info): Likewise.\n\t(vect_setup_realignment): Likewise.\n\t(vect_can_force_dr_alignment_p): Change alignment parameter type to\n\tpoly_uint64.\n\t* tree-vect-loop-manip.c (get_misalign_in_elems): Learn to construct a\n\tmask with a compile time variable vector alignment.\n\t(vect_gen_prolog_loop_niters): Adapt to vector alignment being a poly\n\tint.\n\t(vect_do_peeling): Exit early if vector alignment is not constant.\n\t* tree-vect-stmts.c (ensure_base_align): Adapt to vector alignment being\n\ta poly int.\n\t(vectorizable_store): Likewise.\n\t(vectorizable_load): Likweise.\n\t* tree-vectorizer.h (struct dr_vec_info): Make target_alignment field a\n\tpoly_uint64.\n\t(vect_known_alignment_in_bytes): Adapt to vector alignment being a\n\tpoly int.\n\t(vect_can_force_dr_alignment_p): Change alignment parameter type to\n\tpoly_uint64.\n\nFrom-SVN: r266072", "tree": {"sha": "6b158aa560b82ddda522c92fe49e7d2bffb256c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b158aa560b82ddda522c92fe49e7d2bffb256c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc/comments", "author": {"login": "avieira-arm", "id": 68072104, "node_id": "MDQ6VXNlcjY4MDcyMTA0", "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4", "gravatar_id": "", "url": "https://api.github.com/users/avieira-arm", "html_url": "https://github.com/avieira-arm", "followers_url": "https://api.github.com/users/avieira-arm/followers", "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}", "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions", "organizations_url": "https://api.github.com/users/avieira-arm/orgs", "repos_url": "https://api.github.com/users/avieira-arm/repos", "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/avieira-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "be2b68e4cd63e50f4dd5fca247b9a919fb0013a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be2b68e4cd63e50f4dd5fca247b9a919fb0013a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be2b68e4cd63e50f4dd5fca247b9a919fb0013a0"}], "stats": {"total": 222, "additions": 168, "deletions": 54}, "files": [{"sha": "9201af4945f04fde8e754116ba57b500f34a466b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc", "patch": "@@ -1,3 +1,41 @@\n+2018-11-13  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+\n+\t* config/aarch64/aarch64.c\n+\t(aarch64_vectorize_preferred_vector_alignment): Change return type to\n+\tpoly_uint64.\n+\t(aarch64_simd_vector_alignment_reachable): Adapt to preferred vector\n+\talignment being a poly int.\n+\t* doc/tm.texi (TARGET_VECTORIZE_PREFERRED_VECTOR_ALIGNMENT): Change\n+\treturn type to poly_uint64.\n+\t* target.def (default_preferred_vector_alignment): Likewise.\n+\t* targhooks.c (default_preferred_vector_alignment): Likewise.\n+\t* targhooks.h (default_preferred_vector_alignment): Likewise.\n+\t* tree-vect-data-refs.c (vect_calculate_target_alignment): Likewise.\n+\t(vect_compute_data_ref_alignment): Adapt to vector alignment being a\n+\tpoly int.\n+\t(vect_update_misalignment_for_peel): Likewise.\n+\t(vect_enhance_data_refs_alignment): Likewise.\n+\t(vect_find_same_alignment_drs): Likewise.\n+\t(vect_duplicate_ssa_name_ptr_info): Likewise.\n+\t(vect_setup_realignment): Likewise.\n+\t(vect_can_force_dr_alignment_p): Change alignment parameter type to\n+\tpoly_uint64.\n+\t* tree-vect-loop-manip.c (get_misalign_in_elems): Learn to construct a\n+\tmask with a compile time variable vector alignment.\n+\t(vect_gen_prolog_loop_niters): Adapt to vector alignment being a poly\n+\tint.\n+\t(vect_do_peeling): Exit early if vector alignment is not constant.\n+\t* tree-vect-stmts.c (ensure_base_align): Adapt to vector alignment being\n+\ta poly int.\n+\t(vectorizable_store): Likewise.\n+\t(vectorizable_load): Likweise.\n+\t* tree-vectorizer.h (struct dr_vec_info): Make target_alignment field a\n+\tpoly_uint64.\n+\t(vect_known_alignment_in_bytes): Adapt to vector alignment being a\n+\tpoly int.\n+\t(vect_can_force_dr_alignment_p): Change alignment parameter type to\n+\tpoly_uint64.\n+\n 2018-11-13  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/87962"}, {"sha": "0d89ba27e4a7a02903d6cb3de6c19b097cb84d16", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc", "patch": "@@ -14187,7 +14187,7 @@ aarch64_simd_vector_alignment (const_tree type)\n }\n \n /* Implement target hook TARGET_VECTORIZE_PREFERRED_VECTOR_ALIGNMENT.  */\n-static HOST_WIDE_INT\n+static poly_uint64\n aarch64_vectorize_preferred_vector_alignment (const_tree type)\n {\n   if (aarch64_sve_data_mode_p (TYPE_MODE (type)))\n@@ -14212,9 +14212,11 @@ aarch64_simd_vector_alignment_reachable (const_tree type, bool is_packed)\n   /* For fixed-length vectors, check that the vectorizer will aim for\n      full-vector alignment.  This isn't true for generic GCC vectors\n      that are wider than the ABI maximum of 128 bits.  */\n+  poly_uint64 preferred_alignment =\n+    aarch64_vectorize_preferred_vector_alignment (type);\n   if (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n-      && (wi::to_widest (TYPE_SIZE (type))\n-\t  != aarch64_vectorize_preferred_vector_alignment (type)))\n+      && maybe_ne (wi::to_widest (TYPE_SIZE (type)),\n+\t\t   preferred_alignment))\n     return false;\n \n   /* Vectors whose size is <= BIGGEST_ALIGNMENT are naturally aligned.  */"}, {"sha": "0a2ad9a745e5c6ada069d864b5b1394b7c5165c4", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc", "patch": "@@ -5901,7 +5901,7 @@ For vector memory operations the cost may depend on type (@var{vectype}) and\n misalignment value (@var{misalign}).\n @end deftypefn\n \n-@deftypefn {Target Hook} HOST_WIDE_INT TARGET_VECTORIZE_PREFERRED_VECTOR_ALIGNMENT (const_tree @var{type})\n+@deftypefn {Target Hook} poly_uint64 TARGET_VECTORIZE_PREFERRED_VECTOR_ALIGNMENT (const_tree @var{type})\n This hook returns the preferred alignment in bits for accesses to\n vectors of type @var{type} in vectorized code.  This might be less than\n or greater than the ABI-defined value returned by"}, {"sha": "f9469d69cb0775d1f74a94856d815a25f6d33d85", "filename": "gcc/target.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc", "patch": "@@ -1802,7 +1802,7 @@ for alignment.\\n\\\n \\n\\\n The default hook returns @code{TYPE_ALIGN (@var{type})}, which is\\n\\\n correct for most targets.\",\n- HOST_WIDE_INT, (const_tree type),\n+ poly_uint64, (const_tree type),\n  default_preferred_vector_alignment)\n \n /* Return true if vector alignment is reachable (by peeling N"}, {"sha": "bcbd534e32d7c6c80f4c42ff0f8a04e3d577027d", "filename": "gcc/targhooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc", "patch": "@@ -1260,7 +1260,7 @@ default_vector_alignment (const_tree type)\n /* The default implementation of\n    TARGET_VECTORIZE_PREFERRED_VECTOR_ALIGNMENT.  */\n \n-HOST_WIDE_INT\n+poly_uint64\n default_preferred_vector_alignment (const_tree type)\n {\n   return TYPE_ALIGN (type);"}, {"sha": "430c79e772868ec9301fe2a64f90b231799a18c3", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc", "patch": "@@ -102,7 +102,7 @@ extern HOST_WIDE_INT constant_alignment_word_strings (const_tree,\n \t\t\t\t\t\t      HOST_WIDE_INT);\n extern HOST_WIDE_INT default_vector_alignment (const_tree);\n \n-extern HOST_WIDE_INT default_preferred_vector_alignment (const_tree);\n+extern poly_uint64 default_preferred_vector_alignment (const_tree);\n extern bool default_builtin_vector_alignment_reachable (const_tree, bool);\n extern bool\n default_builtin_support_vector_misalignment (machine_mode mode,"}, {"sha": "8d9acd84f09551d59bda9f328b2907d7f16b6c82", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 65, "deletions": 29, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc", "patch": "@@ -819,7 +819,7 @@ vect_record_base_alignments (vec_info *vinfo)\n \n /* Return the target alignment for the vectorized form of DR_INFO.  */\n \n-static unsigned int\n+static poly_uint64\n vect_calculate_target_alignment (dr_vec_info *dr_info)\n {\n   tree vectype = STMT_VINFO_VECTYPE (dr_info->stmt);\n@@ -862,10 +862,14 @@ vect_compute_data_ref_alignment (dr_vec_info *dr_info)\n   innermost_loop_behavior *drb = vect_dr_behavior (dr_info);\n   bool step_preserves_misalignment_p;\n \n-  unsigned HOST_WIDE_INT vector_alignment\n-    = vect_calculate_target_alignment (dr_info) / BITS_PER_UNIT;\n+  poly_uint64 vector_alignment\n+    = exact_div (vect_calculate_target_alignment (dr_info), BITS_PER_UNIT);\n   DR_TARGET_ALIGNMENT (dr_info) = vector_alignment;\n \n+  unsigned HOST_WIDE_INT vect_align_c;\n+  if (!vector_alignment.is_constant (&vect_align_c))\n+    return;\n+\n   /* No step for BB vectorization.  */\n   if (!loop)\n     {\n@@ -882,7 +886,7 @@ vect_compute_data_ref_alignment (dr_vec_info *dr_info)\n   else if (nested_in_vect_loop_p (loop, stmt_info))\n     {\n       step_preserves_misalignment_p\n-\t= (DR_STEP_ALIGNMENT (dr_info->dr) % vector_alignment) == 0;\n+\t= (DR_STEP_ALIGNMENT (dr_info->dr) % vect_align_c) == 0;\n \n       if (dump_enabled_p ())\n \t{\n@@ -904,7 +908,7 @@ vect_compute_data_ref_alignment (dr_vec_info *dr_info)\n     {\n       poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n       step_preserves_misalignment_p\n-\t= multiple_p (DR_STEP_ALIGNMENT (dr_info->dr) * vf, vector_alignment);\n+\t= multiple_p (DR_STEP_ALIGNMENT (dr_info->dr) * vf, vect_align_c);\n \n       if (!step_preserves_misalignment_p && dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -923,7 +927,7 @@ vect_compute_data_ref_alignment (dr_vec_info *dr_info)\n       base_misalignment = (*entry)->base_misalignment;\n     }\n \n-  if (drb->offset_alignment < vector_alignment\n+  if (drb->offset_alignment < vect_align_c\n       || !step_preserves_misalignment_p\n       /* We need to know whether the step wrt the vectorized loop is\n \t negative when computing the starting misalignment below.  */\n@@ -935,13 +939,13 @@ vect_compute_data_ref_alignment (dr_vec_info *dr_info)\n       return;\n     }\n \n-  if (base_alignment < vector_alignment)\n+  if (base_alignment < vect_align_c)\n     {\n       unsigned int max_alignment;\n       tree base = get_base_for_alignment (drb->base_address, &max_alignment);\n-      if (max_alignment < vector_alignment\n+      if (max_alignment < vect_align_c\n \t  || !vect_can_force_dr_alignment_p (base,\n-\t\t\t\t\t     vector_alignment * BITS_PER_UNIT))\n+\t\t\t\t\t     vect_align_c * BITS_PER_UNIT))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n@@ -972,8 +976,7 @@ vect_compute_data_ref_alignment (dr_vec_info *dr_info)\n \t\t     * TREE_INT_CST_LOW (drb->step));\n \n   unsigned int const_misalignment;\n-  if (!known_misalignment (misalignment, vector_alignment,\n-\t\t\t   &const_misalignment))\n+  if (!known_misalignment (misalignment, vect_align_c, &const_misalignment))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -1027,12 +1030,14 @@ vect_update_misalignment_for_peel (dr_vec_info *dr_info,\n       return;\n     }\n \n-  if (known_alignment_for_access_p (dr_info)\n+  unsigned HOST_WIDE_INT alignment;\n+  if (DR_TARGET_ALIGNMENT (dr_info).is_constant (&alignment)\n+      && known_alignment_for_access_p (dr_info)\n       && known_alignment_for_access_p (dr_peel_info))\n     {\n       int misal = DR_MISALIGNMENT (dr_info);\n       misal += npeel * TREE_INT_CST_LOW (DR_STEP (dr_info->dr));\n-      misal &= DR_TARGET_ALIGNMENT (dr_info) - 1;\n+      misal &= alignment - 1;\n       SET_DR_MISALIGNMENT (dr_info, misal);\n       return;\n     }\n@@ -1676,7 +1681,12 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t\t\t\t\t\t    size_zero_node) < 0;\n \n \t      vectype = STMT_VINFO_VECTYPE (stmt_info);\n-\t      unsigned int target_align = DR_TARGET_ALIGNMENT (dr_info);\n+\t      /* If known_alignment_for_access_p then we have set\n+\t         DR_MISALIGNMENT which is only done if we know it at compiler\n+\t         time, so it is safe to assume target alignment is constant.\n+\t       */\n+\t      unsigned int target_align =\n+\t\tDR_TARGET_ALIGNMENT (dr_info).to_constant ();\n \t      unsigned int dr_size = vect_get_scalar_dr_size (dr_info);\n \t      mis = (negative\n \t\t     ? DR_MISALIGNMENT (dr_info)\n@@ -1953,7 +1963,12 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t      mis = (negative\n \t\t     ? DR_MISALIGNMENT (dr0_info)\n \t\t     : -DR_MISALIGNMENT (dr0_info));\n-\t      unsigned int target_align = DR_TARGET_ALIGNMENT (dr0_info);\n+\t      /* If known_alignment_for_access_p then we have set\n+\t         DR_MISALIGNMENT which is only done if we know it at compiler\n+\t         time, so it is safe to assume target alignment is constant.\n+\t       */\n+\t      unsigned int target_align =\n+\t\tDR_TARGET_ALIGNMENT (dr0_info).to_constant ();\n \t      npeel = ((mis & (target_align - 1))\n \t\t       / vect_get_scalar_dr_size (dr0_info));\n             }\n@@ -1993,9 +2008,19 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n               unsigned max_peel = npeel;\n               if (max_peel == 0)\n                 {\n-\t\t  unsigned int target_align = DR_TARGET_ALIGNMENT (dr0_info);\n-\t\t  max_peel = (target_align\n-\t\t\t      / vect_get_scalar_dr_size (dr0_info) - 1);\n+\t\t  poly_uint64 target_align = DR_TARGET_ALIGNMENT (dr0_info);\n+\t\t  unsigned HOST_WIDE_INT target_align_c;\n+\t\t  if (target_align.is_constant (&target_align_c))\n+\t\t    max_peel =\n+\t\t      target_align_c / vect_get_scalar_dr_size (dr0_info) - 1;\n+\t\t  else\n+\t\t    {\n+\t\t      do_peeling = false;\n+\t\t      if (dump_enabled_p ())\n+\t\t\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t  \"Disable peeling, max peels set and vector\"\n+\t\t\t  \" alignment unknown\\n\");\n+\t\t    }\n                 }\n               if (max_peel > max_allowed_peel)\n                 {\n@@ -2234,11 +2259,18 @@ vect_find_same_alignment_drs (vec_info *vinfo, data_dependence_relation *ddr)\n   if (maybe_ne (diff, 0))\n     {\n       /* Get the wider of the two alignments.  */\n-      unsigned int align_a = (vect_calculate_target_alignment (dr_info_a)\n-\t\t\t      / BITS_PER_UNIT);\n-      unsigned int align_b = (vect_calculate_target_alignment (dr_info_b)\n-\t\t\t      / BITS_PER_UNIT);\n-      unsigned int max_align = MAX (align_a, align_b);\n+      poly_uint64 align_a =\n+\texact_div (vect_calculate_target_alignment (dr_info_a),\n+\t\t   BITS_PER_UNIT);\n+      poly_uint64 align_b =\n+\texact_div (vect_calculate_target_alignment (dr_info_b),\n+\t\t   BITS_PER_UNIT);\n+      unsigned HOST_WIDE_INT align_a_c, align_b_c;\n+      if (!align_a.is_constant (&align_a_c)\n+\t  || !align_b.is_constant (&align_b_c))\n+\treturn;\n+\n+      unsigned HOST_WIDE_INT max_align = MAX (align_a_c, align_b_c);\n \n       /* Require the gap to be a multiple of the larger vector alignment.  */\n       if (!multiple_p (diff, max_align))\n@@ -4357,7 +4389,8 @@ vect_duplicate_ssa_name_ptr_info (tree name, dr_vec_info *dr_info)\n     mark_ptr_info_alignment_unknown (SSA_NAME_PTR_INFO (name));\n   else\n     set_ptr_info_alignment (SSA_NAME_PTR_INFO (name),\n-\t\t\t    DR_TARGET_ALIGNMENT (dr_info), misalign);\n+\t\t\t    known_alignment (DR_TARGET_ALIGNMENT (dr_info)),\n+\t\t\t    misalign);\n }\n \n /* Function vect_create_addr_base_for_vector_ref.\n@@ -5401,10 +5434,13 @@ vect_setup_realignment (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \tnew_temp = copy_ssa_name (ptr);\n       else\n \tnew_temp = make_ssa_name (TREE_TYPE (ptr));\n-      unsigned int align = DR_TARGET_ALIGNMENT (dr_info);\n+      poly_uint64 align = DR_TARGET_ALIGNMENT (dr_info);\n+      tree type = TREE_TYPE (ptr);\n       new_stmt = gimple_build_assign\n \t\t   (new_temp, BIT_AND_EXPR, ptr,\n-\t\t    build_int_cst (TREE_TYPE (ptr), -(HOST_WIDE_INT) align));\n+\t\t    fold_build2 (MINUS_EXPR, type,\n+\t\t\t\t build_int_cst (type, 0),\n+\t\t\t\t build_int_cst (type, align)));\n       new_bb = gsi_insert_on_edge_immediate (pe, new_stmt);\n       gcc_assert (!new_bb);\n       data_ref\n@@ -6287,7 +6323,7 @@ vect_record_grouped_load_vectors (stmt_vec_info stmt_info,\n    on ALIGNMENT bit boundary.  */\n \n bool\n-vect_can_force_dr_alignment_p (const_tree decl, unsigned int alignment)\n+vect_can_force_dr_alignment_p (const_tree decl, poly_uint64 alignment)\n {\n   if (!VAR_P (decl))\n     return false;\n@@ -6297,9 +6333,9 @@ vect_can_force_dr_alignment_p (const_tree decl, unsigned int alignment)\n     return false;\n \n   if (TREE_STATIC (decl))\n-    return (alignment <= MAX_OFILE_ALIGNMENT);\n+    return (known_le (alignment, MAX_OFILE_ALIGNMENT));\n   else\n-    return (alignment <= MAX_STACK_ALIGNMENT);\n+    return (known_le (alignment, (unsigned HOST_WIDE_INT) MAX_STACK_ALIGNMENT));\n }\n \n "}, {"sha": "857e57b4437b010bf9585d8786851204aa0cfe77", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 34, "deletions": 7, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc", "patch": "@@ -1567,8 +1567,9 @@ get_misalign_in_elems (gimple **seq, loop_vec_info loop_vinfo)\n   stmt_vec_info stmt_info = dr_info->stmt;\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n \n-  unsigned int target_align = DR_TARGET_ALIGNMENT (dr_info);\n-  gcc_assert (target_align != 0);\n+  poly_uint64 target_align = DR_TARGET_ALIGNMENT (dr_info);\n+  unsigned HOST_WIDE_INT target_align_c;\n+  tree target_align_minus_1;\n \n   bool negative = tree_int_cst_compare (DR_STEP (dr_info->dr),\n \t\t\t\t\tsize_zero_node) < 0;\n@@ -1578,7 +1579,18 @@ get_misalign_in_elems (gimple **seq, loop_vec_info loop_vinfo)\n   tree start_addr = vect_create_addr_base_for_vector_ref (stmt_info, seq,\n \t\t\t\t\t\t\t  offset);\n   tree type = unsigned_type_for (TREE_TYPE (start_addr));\n-  tree target_align_minus_1 = build_int_cst (type, target_align - 1);\n+  if (target_align.is_constant (&target_align_c))\n+    target_align_minus_1 = build_int_cst (type, target_align_c - 1);\n+  else\n+    {\n+      tree vla = build_int_cst (type, target_align);\n+      tree vla_align = fold_build2 (BIT_AND_EXPR, type, vla,\n+\t\t\t\t    fold_build2 (MINUS_EXPR, type,\n+\t\t\t\t\t\t build_int_cst (type, 0), vla));\n+      target_align_minus_1 = fold_build2 (MINUS_EXPR, type, vla_align,\n+\t\t\t\t\t  build_int_cst (type, 1));\n+    }\n+\n   HOST_WIDE_INT elem_size\n     = int_cst_value (TYPE_SIZE_UNIT (TREE_TYPE (vectype)));\n   tree elem_size_log = build_int_cst (type, exact_log2 (elem_size));\n@@ -1637,7 +1649,7 @@ vect_gen_prolog_loop_niters (loop_vec_info loop_vinfo,\n   tree iters, iters_name;\n   stmt_vec_info stmt_info = dr_info->stmt;\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-  unsigned int target_align = DR_TARGET_ALIGNMENT (dr_info);\n+  poly_uint64 target_align = DR_TARGET_ALIGNMENT (dr_info);\n \n   if (LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo) > 0)\n     {\n@@ -1656,8 +1668,12 @@ vect_gen_prolog_loop_niters (loop_vec_info loop_vinfo,\n       tree type = TREE_TYPE (misalign_in_elems);\n       HOST_WIDE_INT elem_size\n \t= int_cst_value (TYPE_SIZE_UNIT (TREE_TYPE (vectype)));\n-      HOST_WIDE_INT align_in_elems = target_align / elem_size;\n-      tree align_in_elems_minus_1 = build_int_cst (type, align_in_elems - 1);\n+      /* We only do prolog peeling if the target alignment is known at compile\n+         time.  */\n+      poly_uint64 align_in_elems =\n+\texact_div (target_align, elem_size);\n+      tree align_in_elems_minus_1 =\n+\tbuild_int_cst (type, align_in_elems - 1);\n       tree align_in_elems_tree = build_int_cst (type, align_in_elems);\n \n       /* Create:  (niters_type) ((align_in_elems - misalign_in_elems)\n@@ -1672,7 +1688,11 @@ vect_gen_prolog_loop_niters (loop_vec_info loop_vinfo,\n \t\t\t     misalign_in_elems);\n       iters = fold_build2 (BIT_AND_EXPR, type, iters, align_in_elems_minus_1);\n       iters = fold_convert (niters_type, iters);\n-      *bound = align_in_elems - 1;\n+      unsigned HOST_WIDE_INT align_in_elems_c;\n+      if (align_in_elems.is_constant (&align_in_elems_c))\n+\t*bound = align_in_elems_c - 1;\n+      else\n+\t*bound = -1;\n     }\n \n   if (dump_enabled_p ())\n@@ -2410,6 +2430,13 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n   profile_probability prob_prolog, prob_vector, prob_epilog;\n   int estimated_vf;\n   int prolog_peeling = 0;\n+  /* We currently do not support prolog peeling if the target alignment is not\n+     known at compile time.  'vect_gen_prolog_loop_niters' depends on the\n+     target alignment being constant.  */\n+  dr_vec_info *dr_info = LOOP_VINFO_UNALIGNED_DR (loop_vinfo);\n+  if (dr_info && !DR_TARGET_ALIGNMENT (dr_info).is_constant ())\n+    return NULL;\n+\n   if (!vect_use_loop_mask_for_alignment_p (loop_vinfo))\n     prolog_peeling = LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo);\n "}, {"sha": "51088cb0ba91e83c03f707e5cef9e126398733ab", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc", "patch": "@@ -6126,8 +6126,10 @@ ensure_base_align (dr_vec_info *dr_info)\n     {\n       tree base_decl = dr_info->base_decl;\n \n-      unsigned int align_base_to\n-\t= DR_TARGET_ALIGNMENT (dr_info) * BITS_PER_UNIT;\n+      // We should only be able to increase the alignment of a base object if\n+      // we know what its new alignment should be at compile time.\n+      unsigned HOST_WIDE_INT align_base_to =\n+\tDR_TARGET_ALIGNMENT (dr_info).to_constant () * BITS_PER_UNIT;\n \n       if (decl_in_symtab_p (base_decl))\n \tsymtab_node::get (base_decl)->increase_alignment (align_base_to);\n@@ -7075,7 +7077,8 @@ vectorizable_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t  stmt_vec_info next_stmt_info = first_stmt_info;\n \t  for (i = 0; i < vec_num; i++)\n \t    {\n-\t      unsigned align, misalign;\n+\t      unsigned misalign;\n+\t      unsigned HOST_WIDE_INT align;\n \n \t      tree final_mask = NULL_TREE;\n \t      if (loop_masks)\n@@ -7116,7 +7119,7 @@ vectorizable_store (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t   vect_permute_store_chain().  */\n \t\tvec_oprnd = result_chain[i];\n \n-\t      align = DR_TARGET_ALIGNMENT (first_dr_info);\n+\t      align = known_alignment (DR_TARGET_ALIGNMENT (first_dr_info));\n \t      if (aligned_access_p (first_dr_info))\n \t\tmisalign = 0;\n \t      else if (DR_MISALIGNMENT (first_dr_info) == -1)\n@@ -8304,7 +8307,8 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\tcase dr_aligned:\n \t\tcase dr_unaligned_supported:\n \t\t  {\n-\t\t    unsigned int align, misalign;\n+\t\t    unsigned int misalign;\n+\t\t    unsigned HOST_WIDE_INT align;\n \n \t\t    if (memory_access_type == VMAT_GATHER_SCATTER)\n \t\t      {\n@@ -8324,7 +8328,8 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t\tbreak;\n \t\t      }\n \n-\t\t    align = DR_TARGET_ALIGNMENT (dr_info);\n+\t\t    align =\n+\t\t      known_alignment (DR_TARGET_ALIGNMENT (first_dr_info));\n \t\t    if (alignment_support_scheme == dr_aligned)\n \t\t      {\n \t\t\tgcc_assert (aligned_access_p (first_dr_info));\n@@ -8391,7 +8396,10 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t      ptr = copy_ssa_name (dataref_ptr);\n \t\t    else\n \t\t      ptr = make_ssa_name (TREE_TYPE (dataref_ptr));\n-\t\t    unsigned int align = DR_TARGET_ALIGNMENT (first_dr_info);\n+\t\t    // For explicit realign the target alignment should be\n+\t\t    // known at compile time.\n+\t\t    unsigned HOST_WIDE_INT align =\n+\t\t      DR_TARGET_ALIGNMENT (first_dr_info).to_constant ();\n \t\t    new_stmt = gimple_build_assign\n \t\t\t\t (ptr, BIT_AND_EXPR, dataref_ptr,\n \t\t\t\t  build_int_cst\n@@ -8435,7 +8443,10 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t      new_temp = copy_ssa_name (dataref_ptr);\n \t\t    else\n \t\t      new_temp = make_ssa_name (TREE_TYPE (dataref_ptr));\n-\t\t    unsigned int align = DR_TARGET_ALIGNMENT (first_dr_info);\n+\t\t    // We should only be doing this if we know the target\n+\t\t    // alignment at compile time.\n+\t\t    unsigned HOST_WIDE_INT align =\n+\t\t      DR_TARGET_ALIGNMENT (first_dr_info).to_constant ();\n \t\t    new_stmt = gimple_build_assign\n \t\t      (new_temp, BIT_AND_EXPR, dataref_ptr,\n \t\t       build_int_cst (TREE_TYPE (dataref_ptr),"}, {"sha": "7f21622ebfe1a8f5026a8e2990923b1d347d2800", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=ca31798e7bf8f87d78ff1ee66c120b135a1b2ebc", "patch": "@@ -775,7 +775,7 @@ struct dr_vec_info {\n   int misalignment;\n   /* The byte alignment that we'd ideally like the reference to have,\n      and the value that misalignment is measured against.  */\n-  int target_alignment;\n+  poly_uint64 target_alignment;\n   /* If true the alignment of base_decl needs to be increased.  */\n   bool base_misaligned;\n   tree base_decl;\n@@ -1281,7 +1281,7 @@ vect_known_alignment_in_bytes (dr_vec_info *dr_info)\n   if (DR_MISALIGNMENT (dr_info) == DR_MISALIGNMENT_UNKNOWN)\n     return TYPE_ALIGN_UNIT (TREE_TYPE (DR_REF (dr_info->dr)));\n   if (DR_MISALIGNMENT (dr_info) == 0)\n-    return DR_TARGET_ALIGNMENT (dr_info);\n+    return known_alignment (DR_TARGET_ALIGNMENT (dr_info));\n   return DR_MISALIGNMENT (dr_info) & -DR_MISALIGNMENT (dr_info);\n }\n \n@@ -1503,7 +1503,7 @@ extern opt_result vect_get_vector_types_for_stmt (stmt_vec_info, tree *,\n extern opt_tree vect_get_mask_type_for_stmt (stmt_vec_info);\n \n /* In tree-vect-data-refs.c.  */\n-extern bool vect_can_force_dr_alignment_p (const_tree, unsigned int);\n+extern bool vect_can_force_dr_alignment_p (const_tree, poly_uint64);\n extern enum dr_alignment_support vect_supportable_dr_alignment\n                                            (dr_vec_info *, bool);\n extern tree vect_get_smallest_scalar_type (stmt_vec_info, HOST_WIDE_INT *,"}]}