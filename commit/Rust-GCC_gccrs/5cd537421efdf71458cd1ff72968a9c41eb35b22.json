{"sha": "5cd537421efdf71458cd1ff72968a9c41eb35b22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWNkNTM3NDIxZWZkZjcxNDU4Y2QxZmY3Mjk2OGE5YzQxZWIzNWIyMg==", "commit": {"author": {"name": "Dmitry Zhurikhin", "email": "zhur@ispras.ru", "date": "2007-11-07T16:07:29Z"}, "committer": {"name": "Andrey Belevantsev", "email": "abel@gcc.gnu.org", "date": "2007-11-07T16:07:29Z"}, "message": "modulo-sched.c (sms_order_nodes, [...]): Fix prototypes.\n\n        * modulo-sched.c (sms_order_nodes, permute_partial_schedule,\n        generate_prolog_epilog, duplicate_insns_of_cycles): Fix prototypes.\n        (calculate_order_params, sms_order_nodes): New parameter pmax_asap.\n        Save calculated max_asap in it.\n        (sms_schedule): Calculate maxii using max_asap.\n\n\nCo-Authored-By: Andrey Belevantsev <abel@ispras.ru>\n\nFrom-SVN: r129966", "tree": {"sha": "d7484c1ae7a5ee150247804e96c73dbc870644e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7484c1ae7a5ee150247804e96c73dbc870644e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5cd537421efdf71458cd1ff72968a9c41eb35b22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cd537421efdf71458cd1ff72968a9c41eb35b22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cd537421efdf71458cd1ff72968a9c41eb35b22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cd537421efdf71458cd1ff72968a9c41eb35b22/comments", "author": null, "committer": null, "parents": [{"sha": "d9c1dc68ad3646a9164ec0db28f964d289415fe8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9c1dc68ad3646a9164ec0db28f964d289415fe8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9c1dc68ad3646a9164ec0db28f964d289415fe8"}], "stats": {"total": 37, "additions": 23, "deletions": 14}, "files": [{"sha": "d604a746c4c1bec943f680266269957e72ce4155", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd537421efdf71458cd1ff72968a9c41eb35b22/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd537421efdf71458cd1ff72968a9c41eb35b22/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5cd537421efdf71458cd1ff72968a9c41eb35b22", "patch": "@@ -1,3 +1,12 @@\n+2007-11-07  Dmitry Zhurikhin  <zhur@ispras.ru>\n+\t    Andrey Belevantsev  <abel@ispras.ru>\n+\n+\t* modulo-sched.c (sms_order_nodes, permute_partial_schedule,\n+\tgenerate_prolog_epilog, duplicate_insns_of_cycles): Fix prototypes.\n+\t(calculate_order_params, sms_order_nodes): New parameter pmax_asap.\n+\tSave calculated max_asap in it. \t\n+\t(sms_schedule): Calculate maxii using max_asap.\n+\n 2007-11-07  Andreas Krebbel  <krebbel1@de.ibm.com>\n \n \t* doc/invoke.texi: Replace rs6000 dfp switches -mdfp/-mno-dfp"}, {"sha": "282cb80a05a30fc058e00ea823e1bc345a83de58", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cd537421efdf71458cd1ff72968a9c41eb35b22/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cd537421efdf71458cd1ff72968a9c41eb35b22/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=5cd537421efdf71458cd1ff72968a9c41eb35b22", "patch": "@@ -194,15 +194,14 @@ static int compute_split_row (sbitmap, int, int, int, ddg_node_ptr);\n \n static int issue_rate;\n \n-static int sms_order_nodes (ddg_ptr, int, int * result);\n+static int sms_order_nodes (ddg_ptr, int, int *, int *);\n static void set_node_sched_params (ddg_ptr);\n static partial_schedule_ptr sms_schedule_by_order (ddg_ptr, int, int, int *);\n-static void permute_partial_schedule (partial_schedule_ptr ps, rtx last);\n-static void generate_prolog_epilog (partial_schedule_ptr, struct loop *loop,\n+static void permute_partial_schedule (partial_schedule_ptr, rtx);\n+static void generate_prolog_epilog (partial_schedule_ptr, struct loop *,\n                                     rtx, rtx);\n-static void duplicate_insns_of_cycles (partial_schedule_ptr ps,\n-\t\t\t\t       int from_stage, int to_stage,\n-\t\t\t\t       int is_prolog, rtx count_reg);\n+static void duplicate_insns_of_cycles (partial_schedule_ptr,\n+\t\t\t\t       int, int, int, rtx);\n \n #define SCHED_ASAP(x) (((node_sched_params_ptr)(x)->aux.info)->asap)\n #define SCHED_TIME(x) (((node_sched_params_ptr)(x)->aux.info)->time)\n@@ -866,7 +865,7 @@ sms_schedule (void)\n   rtx insn;\n   ddg_ptr *g_arr, g;\n   int * node_order;\n-  int maxii;\n+  int maxii, max_asap;\n   loop_iterator li;\n   partial_schedule_ptr ps;\n   basic_block bb = NULL;\n@@ -1093,9 +1092,9 @@ sms_schedule (void)\n       node_order = XNEWVEC (int, g->num_nodes);\n \n       mii = 1; /* Need to pass some estimate of mii.  */\n-      rec_mii = sms_order_nodes (g, mii, node_order);\n+      rec_mii = sms_order_nodes (g, mii, node_order, &max_asap);\n       mii = MAX (res_MII (g), rec_mii);\n-      maxii = MAXII_FACTOR * mii;\n+      maxii = MAX (max_asap, MAXII_FACTOR * mii);\n \n       if (dump_file)\n \tfprintf (dump_file, \"SMS iis %d %d %d (rec_mii, mii, maxii)\\n\",\n@@ -1851,7 +1850,7 @@ typedef struct node_order_params * nopa;\n \n static void order_nodes_of_sccs (ddg_all_sccs_ptr, int * result);\n static int order_nodes_in_scc (ddg_ptr, sbitmap, sbitmap, int*, int);\n-static nopa  calculate_order_params (ddg_ptr, int mii);\n+static nopa  calculate_order_params (ddg_ptr, int, int *);\n static int find_max_asap (ddg_ptr, sbitmap);\n static int find_max_hv_min_mob (ddg_ptr, sbitmap);\n static int find_max_dv_min_mob (ddg_ptr, sbitmap);\n@@ -1896,15 +1895,15 @@ check_nodes_order (int *node_order, int num_nodes)\n \n /* Order the nodes of G for scheduling and pass the result in\n    NODE_ORDER.  Also set aux.count of each node to ASAP.\n-   Return the recMII for the given DDG.  */\n+   Put maximal ASAP to PMAX_ASAP.  Return the recMII for the given DDG.  */\n static int\n-sms_order_nodes (ddg_ptr g, int mii, int * node_order)\n+sms_order_nodes (ddg_ptr g, int mii, int * node_order, int *pmax_asap)\n {\n   int i;\n   int rec_mii = 0;\n   ddg_all_sccs_ptr sccs = create_ddg_all_sccs (g);\n \n-  nopa nops = calculate_order_params (g, mii);\n+  nopa nops = calculate_order_params (g, mii, pmax_asap);\n \n   if (dump_file)\n     print_sccs (dump_file, sccs, g);\n@@ -1979,7 +1978,7 @@ order_nodes_of_sccs (ddg_all_sccs_ptr all_sccs, int * node_order)\n \n /* MII is needed if we consider backarcs (that do not close recursive cycles).  */\n static struct node_order_params *\n-calculate_order_params (ddg_ptr g, int mii ATTRIBUTE_UNUSED)\n+calculate_order_params (ddg_ptr g, int mii ATTRIBUTE_UNUSED, int *pmax_asap)\n {\n   int u;\n   int max_asap;\n@@ -2042,6 +2041,7 @@ calculate_order_params (ddg_ptr g, int mii ATTRIBUTE_UNUSED)\n       }\n   }\n \n+  *pmax_asap = max_asap;\n   return node_order_params_arr;\n }\n "}]}