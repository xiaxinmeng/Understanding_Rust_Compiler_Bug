{"sha": "9e51aaf570ad8c2c6551c0c5bdf358df2655ca6b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU1MWFhZjU3MGFkOGMyYzY1NTFjMGM1YmRmMzU4ZGYyNjU1Y2E2Yg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-07-24T01:29:11Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-07-24T01:29:11Z"}, "message": "gimplify.c (gimplify_compound_lval): Check for no handled operations, rather than checking for explicit list of nodes.\n\n\t* gimplify.c (gimplify_compound_lval): Check for no handled\n\toperations, rather than checking for explicit list of nodes.\n\t(is_gimple_addr_expr_arg_or_indirect): New function.\n\t(gimplify_addr_expr): Call it and handle INDIRECT_REF; remove\n\tredundant setting of TREE_INVARIANT.\n\t(gimplify_expr, case VIEW_CONVERT_EXPR): Call gimplify_compound_lval.\n\t* tree-gimple.c (is_gimple_addr_expr_arg): Call handled_component_p.\n\nFrom-SVN: r85110", "tree": {"sha": "f3db9e6f9f7f86d544fb2a65e954a843aeee4eb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3db9e6f9f7f86d544fb2a65e954a843aeee4eb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e51aaf570ad8c2c6551c0c5bdf358df2655ca6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e51aaf570ad8c2c6551c0c5bdf358df2655ca6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e51aaf570ad8c2c6551c0c5bdf358df2655ca6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e51aaf570ad8c2c6551c0c5bdf358df2655ca6b/comments", "author": null, "committer": null, "parents": [{"sha": "ffe4e0376f66ff4db3a098f9c41fd8c8dd3c5ac7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffe4e0376f66ff4db3a098f9c41fd8c8dd3c5ac7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffe4e0376f66ff4db3a098f9c41fd8c8dd3c5ac7"}], "stats": {"total": 94, "additions": 37, "deletions": 57}, "files": [{"sha": "3a83c0a4cf6dc348a7ca12fde7fe11ed83e9cc01", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e51aaf570ad8c2c6551c0c5bdf358df2655ca6b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e51aaf570ad8c2c6551c0c5bdf358df2655ca6b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e51aaf570ad8c2c6551c0c5bdf358df2655ca6b", "patch": "@@ -1,3 +1,13 @@\n+2004-07-23  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* gimplify.c (gimplify_compound_lval): Check for no handled\n+\toperations, rather than checking for explicit list of nodes.\n+\t(is_gimple_addr_expr_arg_or_indirect): New function.\n+\t(gimplify_addr_expr): Call it and handle INDIRECT_REF; remove\n+\tredundant setting of TREE_INVARIANT.\n+\t(gimplify_expr, case VIEW_CONVERT_EXPR): Call gimplify_compound_lval.\n+\t* tree-gimple.c (is_gimple_addr_expr_arg): Call handled_component_p.\n+\t\n 2004-07-23  Diego Novillo  <dnovillo@redhat.com>\n \n \tPR tree-optimization/16688"}, {"sha": "079622b78d87a3d0c64994544c8fa1712718518f", "filename": "gcc/gimplify.c", "status": "modified", "additions": 25, "deletions": 50, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e51aaf570ad8c2c6551c0c5bdf358df2655ca6b/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e51aaf570ad8c2c6551c0c5bdf358df2655ca6b/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=9e51aaf570ad8c2c6551c0c5bdf358df2655ca6b", "patch": "@@ -1509,16 +1509,6 @@ gimplify_compound_lval (tree *expr_p, tree *pre_p,\n   enum gimplify_status ret = GS_OK, tret;\n   int i;\n \n-#if defined ENABLE_CHECKING\n-  if (TREE_CODE (*expr_p) != ARRAY_REF\n-      && TREE_CODE (*expr_p) != ARRAY_RANGE_REF\n-      && TREE_CODE (*expr_p) != COMPONENT_REF\n-      && TREE_CODE (*expr_p) != BIT_FIELD_REF\n-      && TREE_CODE (*expr_p) != REALPART_EXPR\n-      && TREE_CODE (*expr_p) != IMAGPART_EXPR)\n-    abort ();\n-#endif\n-\n   /* Create a stack of the subexpressions so later we can walk them in\n      order from inner to outer.  */\n   VARRAY_TREE_INIT (stack, 10, \"stack\");\n@@ -1531,6 +1521,11 @@ gimplify_compound_lval (tree *expr_p, tree *pre_p,\n        p = &TREE_OPERAND (*p, 0))\n     VARRAY_PUSH_TREE (stack, *p);\n \n+#if defined ENABLE_CHECKING\n+  if (VARRAY_ACTIVE_SIZE (stack) == 0)\n+    abort ();\n+#endif\n+\n   /* Now STACK is a stack of pointers to all the refs we've walked through\n      and P points to the innermost expression.\n \n@@ -2714,6 +2709,15 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p, tree *pre_p,\n   return ret;\n }\n \n+/* Return true if T is either a valid GIMPLE operand or is an\n+   INDIRECT_REF (the latter is valid since we'll strip it off).  */\n+\n+static bool\n+is_gimple_addr_expr_arg_or_indirect (tree t)\n+{\n+  return (TREE_CODE (t) == INDIRECT_REF || is_gimple_addr_expr_arg (t));\n+}\n+\n /* Gimplify the MODIFY_EXPR node pointed by EXPR_P.\n \n       modify_expr\n@@ -3023,9 +3027,18 @@ gimplify_addr_expr (tree *expr_p, tree *pre_p, tree *post_p)\n       /* We use fb_either here because the C frontend sometimes takes\n \t the address of a call that returns a struct.  */\n       ret = gimplify_expr (&TREE_OPERAND (expr, 0), pre_p, post_p,\n-\t\t\t   is_gimple_addr_expr_arg, fb_either);\n+\t\t\t   is_gimple_addr_expr_arg_or_indirect, fb_either);\n       if (ret != GS_ERROR)\n \t{\n+\t  /* The above may have made an INDIRECT ref (e.g, Ada's NULL_EXPR),\n+\t     so check for it here.  It's not worth checking for the other\n+\t     cases above.  */\n+\t  if (TREE_CODE (TREE_OPERAND (expr, 0)) == INDIRECT_REF)\n+\t    {\n+\t      *expr_p = TREE_OPERAND (TREE_OPERAND (expr, 0), 0);\n+\t      break;\n+\t    }\n+\n \t  /* Make sure TREE_INVARIANT, TREE_CONSTANT, and TREE_SIDE_EFFECTS\n \t     is set properly.  */\n \t  recompute_tree_invarant_for_addr_expr (expr);\n@@ -3036,11 +3049,6 @@ gimplify_addr_expr (tree *expr_p, tree *pre_p, tree *post_p)\n       break;\n     }\n \n-  /* If the operand is gimplified into a _DECL, mark the address expression\n-     as TREE_INVARIANT.  */\n-  if (DECL_P (TREE_OPERAND (expr, 0)))\n-    TREE_INVARIANT (expr) = 1;\n-\n   return ret;\n }\n \n@@ -3475,6 +3483,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \tcase REALPART_EXPR:\n \tcase IMAGPART_EXPR:\n \tcase COMPONENT_REF:\n+\tcase VIEW_CONVERT_EXPR:\n \t  ret = gimplify_compound_lval (expr_p, pre_p, post_p,\n \t\t\t\t\tfallback ? fallback : fb_rvalue);\n \t  break;\n@@ -3521,39 +3530,6 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  ret = gimplify_va_arg_expr (expr_p, pre_p, post_p);\n \t  break;\n \n-\tcase VIEW_CONVERT_EXPR:\n-\t  if (VOID_TYPE_P (TREE_TYPE (*expr_p))\n-\t      || fallback == fb_none)\n-\t    {\n-\t      /* Just strip a conversion to void (or in void context) and\n-\t\t try again.  */\n-\t      *expr_p = TREE_OPERAND (*expr_p, 0);\n-\t      break;\n-\t    }\n-\n-\t  /* If both types are BLKmode or if one type is of variable size,\n-\t     convert this into a pointer punning operation.  This avoids\n-\t     copies of large data or making a variable-size temporary.\n-\n-\t     ??? The interactions of VIEW_CONVERT_EXPR and aliasing is not at\n-\t     all clear.  The impact of this transformation is even less\n-\t     clear.  */\n-\n-\t  if ((TYPE_MODE (TREE_TYPE (*expr_p)) == BLKmode\n-\t       && TYPE_MODE (TREE_TYPE (TREE_OPERAND (*expr_p, 0))) == BLKmode)\n-\t      || !TREE_CONSTANT (TYPE_SIZE (TREE_TYPE (*expr_p)))\n-\t      || !TREE_CONSTANT (TYPE_SIZE (TREE_TYPE\n-\t\t\t\t\t    (TREE_OPERAND (*expr_p,0)))))\n-\t    {\n-\t      tree restype = TREE_TYPE (*expr_p);\n-\t      *expr_p = build1 (INDIRECT_REF, TREE_TYPE (*expr_p),\n-\t\t\t\tfold_convert (build_pointer_type (restype),\n-\t\t\t\t\t      build_fold_addr_expr\n-\t\t\t\t\t      (TREE_OPERAND (*expr_p, 0))));\n-\t      break;\n-\t    }\n-\t  goto unary;\n-\n \tcase CONVERT_EXPR:\n \tcase NOP_EXPR:\n \t  if (IS_EMPTY_STMT (*expr_p))\n@@ -3582,7 +3558,6 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \tcase FIX_CEIL_EXPR:\n \tcase FIX_FLOOR_EXPR:\n \tcase FIX_ROUND_EXPR:\n-\tunary:\n \t  /* unary_expr: ... | '(' cast ')' val | ...  */\n \t  ret = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, post_p,\n \t\t\t       is_gimple_val, fb_rvalue);"}, {"sha": "3d2fff897ed8dd1bd4edda17c70673e251dd78d4", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e51aaf570ad8c2c6551c0c5bdf358df2655ca6b/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e51aaf570ad8c2c6551c0c5bdf358df2655ca6b/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=9e51aaf570ad8c2c6551c0c5bdf358df2655ca6b", "patch": "@@ -322,13 +322,8 @@ is_gimple_condexpr (tree t)\n bool\n is_gimple_addr_expr_arg (tree t)\n {\n-  return (is_gimple_id (t)\n-\t  || TREE_CODE (t) == ARRAY_REF\n-\t  || TREE_CODE (t) == ARRAY_RANGE_REF\n-\t  || TREE_CODE (t) == COMPONENT_REF\n-\t  || TREE_CODE (t) == REALPART_EXPR\n-\t  || TREE_CODE (t) == IMAGPART_EXPR\n-\t  || TREE_CODE (t) == INDIRECT_REF);\n+  return (is_gimple_id (t) || handled_component_p (t)\n+\t  || TREE_CODE (t) == REALPART_EXPR || TREE_CODE (t) == IMAGPART_EXPR);\n }\n \n /* Return true if T is function invariant.  Or rather a restricted"}]}