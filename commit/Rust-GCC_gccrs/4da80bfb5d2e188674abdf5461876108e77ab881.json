{"sha": "4da80bfb5d2e188674abdf5461876108e77ab881", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRhODBiZmI1ZDJlMTg4Njc0YWJkZjU0NjE4NzYxMDhlNzdhYjg4MQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-11-10T15:28:57Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-11-10T15:28:57Z"}, "message": "re PR tree-optimization/51042 (endless recursion in phi_translate)\n\n2011-11-10  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/51042\n\t* tree-ssa-pre.c (phi_translate_1): Avoid recursing on\n\tself-referential expressions.  Refactor code to avoid duplication.\n\n\t* gcc.dg/torture/pr51042.c: New testcase.\n\nFrom-SVN: r181256", "tree": {"sha": "8c7ddc725098e69e509a4775363d0458e154e0d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c7ddc725098e69e509a4775363d0458e154e0d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4da80bfb5d2e188674abdf5461876108e77ab881", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4da80bfb5d2e188674abdf5461876108e77ab881", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4da80bfb5d2e188674abdf5461876108e77ab881", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4da80bfb5d2e188674abdf5461876108e77ab881/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c07a8cb3c903f5152e013748f773adecdb82122e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c07a8cb3c903f5152e013748f773adecdb82122e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c07a8cb3c903f5152e013748f773adecdb82122e"}], "stats": {"total": 146, "additions": 81, "deletions": 65}, "files": [{"sha": "404b8843dae3d807f7065f76fafe25697d0cee63", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da80bfb5d2e188674abdf5461876108e77ab881/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da80bfb5d2e188674abdf5461876108e77ab881/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4da80bfb5d2e188674abdf5461876108e77ab881", "patch": "@@ -1,3 +1,9 @@\n+2011-11-10  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/51042\n+\t* tree-ssa-pre.c (phi_translate_1): Avoid recursing on\n+\tself-referential expressions.  Refactor code to avoid duplication.\n+\n 2011-11-10  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/51070"}, {"sha": "ecfcdbe9b5e9049b1621a30675068e64563b3c01", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da80bfb5d2e188674abdf5461876108e77ab881/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da80bfb5d2e188674abdf5461876108e77ab881/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4da80bfb5d2e188674abdf5461876108e77ab881", "patch": "@@ -1,3 +1,8 @@\n+2011-11-10  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/51042\n+\t* gcc.dg/torture/pr51042.c: New testcase.\n+\n 2011-11-10  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/51070"}, {"sha": "05961c4acf59fd356aaa48b9ea2a84a346f9c2c7", "filename": "gcc/testsuite/gcc.dg/torture/pr51042.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da80bfb5d2e188674abdf5461876108e77ab881/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr51042.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da80bfb5d2e188674abdf5461876108e77ab881/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr51042.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr51042.c?ref=4da80bfb5d2e188674abdf5461876108e77ab881", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+\n+int a, b;\n+\n+void\n+foo (int x)\n+{\n+  int e[2];\n+  int d;\n+  while (x)\n+    {\n+      for (d = 0; d <= 1; d = 1)\n+\tif (e[a])\n+\t  break;\n+      for (b = 0; b <= 0; b = 1)\n+\t{\n+\t  e[a] = a;\n+\t  if (a)\n+\t    break;\n+\t}\n+    }\n+}"}, {"sha": "557b56a110d320409267bbbbcfecb35945280c73", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 48, "deletions": 65, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da80bfb5d2e188674abdf5461876108e77ab881/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da80bfb5d2e188674abdf5461876108e77ab881/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=4da80bfb5d2e188674abdf5461876108e77ab881", "patch": "@@ -1527,7 +1527,7 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n \ttree newvuse = vuse;\n \tVEC (vn_reference_op_s, heap) *newoperands = NULL;\n \tbool changed = false, same_valid = true;\n-\tunsigned int i, j;\n+\tunsigned int i, j, n;\n \tvn_reference_op_t operand;\n \tvn_reference_t newref;\n \n@@ -1536,100 +1536,83 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n \t  {\n \t    pre_expr opresult;\n \t    pre_expr leader;\n-\t    tree oldop0 = operand->op0;\n-\t    tree oldop1 = operand->op1;\n-\t    tree oldop2 = operand->op2;\n-\t    tree op0 = oldop0;\n-\t    tree op1 = oldop1;\n-\t    tree op2 = oldop2;\n+\t    tree op[3];\n \t    tree type = operand->type;\n \t    vn_reference_op_s newop = *operand;\n-\n-\t    if (op0 && TREE_CODE (op0) == SSA_NAME)\n+\t    op[0] = operand->op0;\n+\t    op[1] = operand->op1;\n+\t    op[2] = operand->op2;\n+\t    for (n = 0; n < 3; ++n)\n \t      {\n-\t\tunsigned int op_val_id = VN_INFO (op0)->value_id;\n-\t\tleader = find_leader_in_sets (op_val_id, set1, set2);\n-\t\topresult = phi_translate (leader, set1, set2, pred, phiblock);\n-\t\tif (opresult && opresult != leader)\n+\t\tunsigned int op_val_id;\n+\t\tif (!op[n])\n+\t\t  continue;\n+\t\tif (TREE_CODE (op[n]) != SSA_NAME)\n \t\t  {\n-\t\t    tree name = get_representative_for (opresult);\n-\t\t    if (!name)\n+\t\t    /* We can't possibly insert these.  */\n+\t\t    if (n != 0\n+\t\t\t&& !is_gimple_min_invariant (op[n]))\n \t\t      break;\n-\t\t    op0 = name;\n+\t\t    continue;\n \t\t  }\n-\t\telse if (!opresult)\n-\t\t  break;\n-\t      }\n-\t    changed |= op0 != oldop0;\n-\n-\t    if (op1 && TREE_CODE (op1) == SSA_NAME)\n-\t      {\n-\t\tunsigned int op_val_id = VN_INFO (op1)->value_id;\n+\t\top_val_id = VN_INFO (op[n])->value_id;\n \t\tleader = find_leader_in_sets (op_val_id, set1, set2);\n-\t\topresult = phi_translate (leader, set1, set2, pred, phiblock);\n-\t\tif (opresult && opresult != leader)\n+\t\tif (!leader)\n+\t\t  break;\n+\t\t/* Make sure we do not recursively translate ourselves\n+\t\t   like for translating a[n_1] with the leader for\n+\t\t   n_1 being a[n_1].  */\n+\t\tif (get_expression_id (leader) != get_expression_id (expr))\n \t\t  {\n-\t\t    tree name = get_representative_for (opresult);\n-\t\t    if (!name)\n+\t\t    opresult = phi_translate (leader, set1, set2,\n+\t\t\t\t\t      pred, phiblock);\n+\t\t    if (!opresult)\n \t\t      break;\n-\t\t    op1 = name;\n+\t\t    if (opresult != leader)\n+\t\t      {\n+\t\t\ttree name = get_representative_for (opresult);\n+\t\t\tif (!name)\n+\t\t\t  break;\n+\t\t\tchanged |= name != op[n];\n+\t\t\top[n] = name;\n+\t\t      }\n \t\t  }\n-\t\telse if (!opresult)\n-\t\t  break;\n \t      }\n-\t    /* We can't possibly insert these.  */\n-\t    else if (op1 && !is_gimple_min_invariant (op1))\n-\t      break;\n-\t    changed |= op1 != oldop1;\n-\t    if (op2 && TREE_CODE (op2) == SSA_NAME)\n+\t    if (n != 3)\n \t      {\n-\t\tunsigned int op_val_id = VN_INFO (op2)->value_id;\n-\t\tleader = find_leader_in_sets (op_val_id, set1, set2);\n-\t\topresult = phi_translate (leader, set1, set2, pred, phiblock);\n-\t\tif (opresult && opresult != leader)\n-\t\t  {\n-\t\t    tree name = get_representative_for (opresult);\n-\t\t    if (!name)\n-\t\t      break;\n-\t\t    op2 = name;\n-\t\t  }\n-\t\telse if (!opresult)\n-\t\t  break;\n+\t\tif (newoperands)\n+\t\t  VEC_free (vn_reference_op_s, heap, newoperands);\n+\t\treturn NULL;\n \t      }\n-\t    /* We can't possibly insert these.  */\n-\t    else if (op2 && !is_gimple_min_invariant (op2))\n-\t      break;\n-\t    changed |= op2 != oldop2;\n-\n \t    if (!newoperands)\n \t      newoperands = VEC_copy (vn_reference_op_s, heap, operands);\n \t    /* We may have changed from an SSA_NAME to a constant */\n-\t    if (newop.opcode == SSA_NAME && TREE_CODE (op0) != SSA_NAME)\n-\t      newop.opcode = TREE_CODE (op0);\n+\t    if (newop.opcode == SSA_NAME && TREE_CODE (op[0]) != SSA_NAME)\n+\t      newop.opcode = TREE_CODE (op[0]);\n \t    newop.type = type;\n-\t    newop.op0 = op0;\n-\t    newop.op1 = op1;\n-\t    newop.op2 = op2;\n+\t    newop.op0 = op[0];\n+\t    newop.op1 = op[1];\n+\t    newop.op2 = op[2];\n \t    /* If it transforms a non-constant ARRAY_REF into a constant\n \t       one, adjust the constant offset.  */\n \t    if (newop.opcode == ARRAY_REF\n \t\t&& newop.off == -1\n-\t\t&& TREE_CODE (op0) == INTEGER_CST\n-\t\t&& TREE_CODE (op1) == INTEGER_CST\n-\t\t&& TREE_CODE (op2) == INTEGER_CST)\n+\t\t&& TREE_CODE (op[0]) == INTEGER_CST\n+\t\t&& TREE_CODE (op[1]) == INTEGER_CST\n+\t\t&& TREE_CODE (op[2]) == INTEGER_CST)\n \t      {\n-\t\tdouble_int off = tree_to_double_int (op0);\n+\t\tdouble_int off = tree_to_double_int (op[0]);\n \t\toff = double_int_add (off,\n \t\t\t\t      double_int_neg\n-\t\t\t\t        (tree_to_double_int (op1)));\n-\t\toff = double_int_mul (off, tree_to_double_int (op2));\n+\t\t\t\t        (tree_to_double_int (op[1])));\n+\t\toff = double_int_mul (off, tree_to_double_int (op[2]));\n \t\tif (double_int_fits_in_shwi_p (off))\n \t\t  newop.off = off.low;\n \t      }\n \t    VEC_replace (vn_reference_op_s, newoperands, j, &newop);\n \t    /* If it transforms from an SSA_NAME to an address, fold with\n \t       a preceding indirect reference.  */\n-\t    if (j > 0 && op0 && TREE_CODE (op0) == ADDR_EXPR\n+\t    if (j > 0 && op[0] && TREE_CODE (op[0]) == ADDR_EXPR\n \t\t&& VEC_index (vn_reference_op_s,\n \t\t\t      newoperands, j - 1)->opcode == MEM_REF)\n \t      vn_reference_fold_indirect (&newoperands, &j);"}]}