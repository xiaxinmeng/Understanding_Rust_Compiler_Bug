{"sha": "cd648cec5c78e596fc86e570f243dac6752ad764", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Q2NDhjZWM1Yzc4ZTU5NmZjODZlNTcwZjI0M2RhYzY3NTJhZDc2NA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-03-14T20:15:13Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-03-14T20:15:13Z"}, "message": "cselib.c (clear_table): Do not take argument; always clear just used slots.\n\n\t* cselib.c (clear_table): Do not take argument; always clear just\n\tused slots.\n\t(cselib_process_insn):  Update call of clear_table\n\t(cselib_init): Do not call clear_table.\n\t(cselib_finish): Clear table.\n\n\t* cse.c (count_reg_usage): Do not check side_effects_p.\n\t* rtlanal.c (set_noop_p): Check side_effects_p only when set looks\n\tlike noop.\n\t(find_reg_equal_equiv_note): Do not use find_reg_note.\n\nFrom-SVN: r64369", "tree": {"sha": "3085a6e478e08536454831e0b1720bcba93526a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3085a6e478e08536454831e0b1720bcba93526a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd648cec5c78e596fc86e570f243dac6752ad764", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd648cec5c78e596fc86e570f243dac6752ad764", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd648cec5c78e596fc86e570f243dac6752ad764", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd648cec5c78e596fc86e570f243dac6752ad764/comments", "author": null, "committer": null, "parents": [{"sha": "82c34dcb178f76c9ce6c0a6b7fac79b3c6aaff8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82c34dcb178f76c9ce6c0a6b7fac79b3c6aaff8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82c34dcb178f76c9ce6c0a6b7fac79b3c6aaff8b"}], "stats": {"total": 70, "additions": 36, "deletions": 34}, "files": [{"sha": "1d7dbc2318c090b7b96299eb7104f16b61c0e69f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd648cec5c78e596fc86e570f243dac6752ad764/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd648cec5c78e596fc86e570f243dac6752ad764/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cd648cec5c78e596fc86e570f243dac6752ad764", "patch": "@@ -1,3 +1,16 @@\n+Thu Mar 13 18:39:42 CET 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cselib.c (clear_table): Do not take argument; always clear just\n+\tused slots.\n+\t(cselib_process_insn):  Update call of clear_table\n+\t(cselib_init): Do not call clear_table.\n+\t(cselib_finish): Clear table.\n+\n+\t* cse.c (count_reg_usage): Do not check side_effects_p.\n+\t* rtlanal.c (set_noop_p): Check side_effects_p only when set looks\n+\tlike noop.\n+\t(find_reg_equal_equiv_note): Do not use find_reg_note.\n+\n 2003-03-14  Richard Henderson  <rth@redhat.com>\n \n \tPR target/9700"}, {"sha": "9f6b96d20ceb328baef3ec8688aac95cfe963951", "filename": "gcc/cse.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd648cec5c78e596fc86e570f243dac6752ad764/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd648cec5c78e596fc86e570f243dac6752ad764/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=cd648cec5c78e596fc86e570f243dac6752ad764", "patch": "@@ -7494,15 +7494,8 @@ count_reg_usage (x, counts, dest, incr)\n       /* Unless we are setting a REG, count everything in SET_DEST.  */\n       if (GET_CODE (SET_DEST (x)) != REG)\n \tcount_reg_usage (SET_DEST (x), counts, NULL_RTX, incr);\n-\n-      /* If SRC has side-effects, then we can't delete this insn, so the\n-\t usage of SET_DEST inside SRC counts.\n-\n-\t ??? Strictly-speaking, we might be preserving this insn\n-\t because some other SET has side-effects, but that's hard\n-\t to do and can't happen now.  */\n       count_reg_usage (SET_SRC (x), counts,\n-\t\t       side_effects_p (SET_SRC (x)) ? NULL_RTX : SET_DEST (x),\n+\t\t       SET_DEST (x),\n \t\t       incr);\n       return;\n "}, {"sha": "3aac058df27e79a0097b0805e7b6e61a4405497a", "filename": "gcc/cselib.c", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd648cec5c78e596fc86e570f243dac6752ad764/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd648cec5c78e596fc86e570f243dac6752ad764/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=cd648cec5c78e596fc86e570f243dac6752ad764", "patch": "@@ -49,7 +49,7 @@ static struct elt_loc_list *new_elt_loc_list PARAMS ((struct elt_loc_list *,\n static void unchain_one_value\t\tPARAMS ((cselib_val *));\n static void unchain_one_elt_list\tPARAMS ((struct elt_list **));\n static void unchain_one_elt_loc_list\tPARAMS ((struct elt_loc_list **));\n-static void clear_table\t\t\tPARAMS ((int));\n+static void clear_table\t\t\tPARAMS ((void));\n static int discard_useless_locs\t\tPARAMS ((void **, void *));\n static int discard_useless_values\tPARAMS ((void **, void *));\n static void remove_useless_values\tPARAMS ((void));\n@@ -224,17 +224,12 @@ unchain_one_value (v)\n    which are known to have been used.  */\n \n static void\n-clear_table (clear_all)\n-     int clear_all;\n+clear_table ()\n {\n   unsigned int i;\n \n-  if (clear_all)\n-    for (i = 0; i < cselib_nregs; i++)\n-      REG_VALUES (i) = 0;\n-  else\n-    for (i = 0; i < VARRAY_ACTIVE_SIZE (used_regs); i++)\n-      REG_VALUES (VARRAY_UINT (used_regs, i)) = 0;\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (used_regs); i++)\n+    REG_VALUES (VARRAY_UINT (used_regs, i)) = 0;\n \n   max_value_regs = 0;\n \n@@ -1359,7 +1354,7 @@ cselib_process_insn (insn)\n \t  && GET_CODE (PATTERN (insn)) == ASM_OPERANDS\n \t  && MEM_VOLATILE_P (PATTERN (insn))))\n     {\n-      clear_table (0);\n+      clear_table ();\n       return;\n     }\n \n@@ -1437,8 +1432,6 @@ cselib_init ()\n     {\n       reg_values = reg_values_old;\n       used_regs = used_regs_old;\n-      VARRAY_CLEAR (reg_values);\n-      VARRAY_CLEAR (used_regs);\n     }\n   else\n     {\n@@ -1447,7 +1440,6 @@ cselib_init ()\n     }\n   hash_table = htab_create_ggc (31, get_value_hash, entry_and_rtx_equal_p, \n \t\t\t\tNULL);\n-  clear_table (1);\n   cselib_current_insn_in_libcall = false;\n }\n \n@@ -1456,6 +1448,7 @@ cselib_init ()\n void\n cselib_finish ()\n {\n+  clear_table ();\n   reg_values_old = reg_values;\n   reg_values = 0;\n   used_regs_old = used_regs;"}, {"sha": "4e604172f664bc902de3ee9d33705415ff738426", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd648cec5c78e596fc86e570f243dac6752ad764/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd648cec5c78e596fc86e570f243dac6752ad764/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=cd648cec5c78e596fc86e570f243dac6752ad764", "patch": "@@ -1327,19 +1327,17 @@ set_noop_p (set)\n   rtx src = SET_SRC (set);\n   rtx dst = SET_DEST (set);\n \n-  if (side_effects_p (src) || side_effects_p (dst))\n-    return 0;\n-\n-  if (GET_CODE (dst) == MEM && GET_CODE (src) == MEM)\n-    return rtx_equal_p (dst, src);\n-\n   if (dst == pc_rtx && src == pc_rtx)\n     return 1;\n \n+  if (GET_CODE (dst) == MEM && GET_CODE (src) == MEM)\n+    return rtx_equal_p (dst, src) && !side_effects_p (dst);\n+\n   if (GET_CODE (dst) == SIGN_EXTRACT\n       || GET_CODE (dst) == ZERO_EXTRACT)\n     return rtx_equal_p (XEXP (dst, 0), src)\n-\t   && ! BYTES_BIG_ENDIAN && XEXP (dst, 2) == const0_rtx;\n+\t   && ! BYTES_BIG_ENDIAN && XEXP (dst, 2) == const0_rtx\n+\t   && !side_effects_p (src);\n \n   if (GET_CODE (dst) == STRICT_LOW_PART)\n     dst = XEXP (dst, 0);\n@@ -2018,14 +2016,19 @@ rtx\n find_reg_equal_equiv_note (insn)\n      rtx insn;\n {\n-  rtx note;\n+  rtx link;\n \n-  if (single_set (insn) == 0)\n+  if (!INSN_P (insn))\n     return 0;\n-  else if ((note = find_reg_note (insn, REG_EQUIV, NULL_RTX)) != 0)\n-    return note;\n-  else\n-    return find_reg_note (insn, REG_EQUAL, NULL_RTX);\n+  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+    if (REG_NOTE_KIND (link) == REG_EQUAL\n+\t|| REG_NOTE_KIND (link) == REG_EQUIV)\n+      {\n+\tif (single_set (insn) == 0)\n+\t  return 0;\n+\treturn link;\n+      }\n+  return NULL;\n }\n \n /* Return true if DATUM, or any overlap of DATUM, of kind CODE is found"}]}