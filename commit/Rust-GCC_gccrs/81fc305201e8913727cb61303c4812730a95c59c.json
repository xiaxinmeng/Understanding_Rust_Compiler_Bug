{"sha": "81fc305201e8913727cb61303c4812730a95c59c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFmYzMwNTIwMWU4OTEzNzI3Y2I2MTMwM2M0ODEyNzMwYTk1YzU5Yw==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2005-05-25T21:36:24Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2005-05-25T21:36:24Z"}, "message": "tree-cfg.c (verify_expr, [...]): Verify invariant, constant and side_effects of the ADDR_EXPR are consistent.\n\n        * tree-cfg.c (verify_expr, case ADDR_EXPR): Verify invariant,\n        constant and side_effects of the ADDR_EXPR are consistent.\n\n        * tree-nested.c (convert_local_reference): Set CURRENT_FUNCTION_DECL\n        appropriately around calls to recompute_tree_invarant_for_addr_expr.\n\nCo-Authored-By: Jeff Law <law@redhat.com>\n\nFrom-SVN: r100168", "tree": {"sha": "97fb8429916e88ae81fa00fe312809a322531099", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97fb8429916e88ae81fa00fe312809a322531099"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81fc305201e8913727cb61303c4812730a95c59c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81fc305201e8913727cb61303c4812730a95c59c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81fc305201e8913727cb61303c4812730a95c59c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81fc305201e8913727cb61303c4812730a95c59c/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3d0994b83115f9da0a1e454c3693e0d93771cac3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d0994b83115f9da0a1e454c3693e0d93771cac3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d0994b83115f9da0a1e454c3693e0d93771cac3"}], "stats": {"total": 104, "additions": 79, "deletions": 25}, "files": [{"sha": "a24922b4430aac76f57765cae2152e2a0b03fc8b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fc305201e8913727cb61303c4812730a95c59c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fc305201e8913727cb61303c4812730a95c59c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=81fc305201e8913727cb61303c4812730a95c59c", "patch": "@@ -1,3 +1,12 @@\n+2005-05-25  Daniel Berlin  <dberlin@dberlin.org>\n+\t    Jeff Law  <law@redhat.com>\n+\n+\t* tree-cfg.c (verify_expr, case ADDR_EXPR): Verify invariant,\n+\tconstant and side_effects of the ADDR_EXPR are consistent.\n+\n+\t* tree-nested.c (convert_local_reference): Set CURRENT_FUNCTION_DECL\n+\tappropriately around calls to recompute_tree_invarant_for_addr_expr.\n+\n 2005-05-25  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* config/s390/s390.c (GP_ARG_NUM_REG, FP_ARG_NUM_REG): New defines."}, {"sha": "a219d8b760f097e3d0a4df55c983a9652d4dc003", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 60, "deletions": 25, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fc305201e8913727cb61303c4812730a95c59c/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fc305201e8913727cb61303c4812730a95c59c/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=81fc305201e8913727cb61303c4812730a95c59c", "patch": "@@ -3429,32 +3429,67 @@ verify_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n       break;\n \n     case ADDR_EXPR:\n-      /* ??? tree-ssa-alias.c may have overlooked dead PHI nodes, missing\n-\t dead PHIs that take the address of something.  But if the PHI\n-\t result is dead, the fact that it takes the address of anything\n-\t is irrelevant.  Because we can not tell from here if a PHI result\n-\t is dead, we just skip this check for PHIs altogether.  This means\n-\t we may be missing \"valid\" checks, but what can you do?\n-\t This was PR19217.  */\n-      if (in_phi)\n-\tbreak;\n+      {\n+\tbool old_invariant;\n+\tbool old_constant;\n+\tbool old_side_effects;\n+\tbool new_invariant;\n+\tbool new_constant;\n+\tbool new_side_effects;\n+\n+        /* ??? tree-ssa-alias.c may have overlooked dead PHI nodes, missing\n+\t   dead PHIs that take the address of something.  But if the PHI\n+\t   result is dead, the fact that it takes the address of anything\n+\t   is irrelevant.  Because we can not tell from here if a PHI result\n+\t   is dead, we just skip this check for PHIs altogether.  This means\n+\t   we may be missing \"valid\" checks, but what can you do?\n+\t   This was PR19217.  */\n+        if (in_phi)\n+\t  break;\n \n-      /* Skip any references (they will be checked when we recurse down the\n-\t tree) and ensure that any variable used as a prefix is marked\n-\t addressable.  */\n-      for (x = TREE_OPERAND (t, 0);\n-\t   handled_component_p (x);\n-\t   x = TREE_OPERAND (x, 0))\n-\t;\n-\n-      if (TREE_CODE (x) != VAR_DECL && TREE_CODE (x) != PARM_DECL)\n-\treturn NULL;\n-      if (!TREE_ADDRESSABLE (x))\n-\t{\n-\t  error (\"address taken, but ADDRESSABLE bit not set\");\n-\t  return x;\n-\t}\n-      break;\n+\told_invariant = TREE_INVARIANT (t);\n+\told_constant = TREE_CONSTANT (t);\n+\told_side_effects = TREE_SIDE_EFFECTS (t);\n+\n+\trecompute_tree_invarant_for_addr_expr (t);\n+\tnew_invariant = TREE_INVARIANT (t);\n+\tnew_side_effects = TREE_SIDE_EFFECTS (t);\n+\tnew_constant = TREE_CONSTANT (t);\n+\n+\tif (old_invariant != new_invariant)\n+\t  {\n+\t    error (\"invariant not recomputed when ADDR_EXPR changed\");\n+\t    return t;\n+\t  }\n+\n+        if (old_constant != new_constant)\n+\t  {\n+\t    error (\"constant not recomputed when ADDR_EXPR changed\");\n+\t    return t;\n+\t  }\n+\tif (old_side_effects != new_side_effects)\n+\t  {\n+\t    error (\"side effects not recomputed when ADDR_EXPR changed\");\n+\t    return t;\n+\t  }\n+\n+\t/* Skip any references (they will be checked when we recurse down the\n+\t   tree) and ensure that any variable used as a prefix is marked\n+\t   addressable.  */\n+\tfor (x = TREE_OPERAND (t, 0);\n+\t     handled_component_p (x);\n+\t     x = TREE_OPERAND (x, 0))\n+\t  ;\n+\n+\tif (TREE_CODE (x) != VAR_DECL && TREE_CODE (x) != PARM_DECL)\n+\t  return NULL;\n+\tif (!TREE_ADDRESSABLE (x))\n+\t  {\n+\t    error (\"address taken, but ADDRESSABLE bit not set\");\n+\t    return x;\n+\t  }\n+\tbreak;\n+      }\n \n     case COND_EXPR:\n       x = COND_EXPR_COND (t);"}, {"sha": "2f9985dcfac0227ee584127e9b12251a056f0456", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fc305201e8913727cb61303c4812730a95c59c/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fc305201e8913727cb61303c4812730a95c59c/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=81fc305201e8913727cb61303c4812730a95c59c", "patch": "@@ -871,9 +871,14 @@ convert_nonlocal_reference (tree *tp, int *walk_subtrees, void *data)\n \n \tif (wi->changed)\n \t  {\n+\t    tree save_context;\n+\n \t    /* If we changed anything, then TREE_INVARIANT is be wrong,\n \t       since we're no longer directly referencing a decl.  */\n+\t    save_context = current_function_decl;\n+\t    current_function_decl = info->context;\n \t    recompute_tree_invarant_for_addr_expr (t);\n+\t    current_function_decl = save_context;\n \n \t    /* If the callback converted the address argument in a context\n \t       where we only accept variables (and min_invariant, presumably),\n@@ -996,10 +1001,15 @@ convert_local_reference (tree *tp, int *walk_subtrees, void *data)\n \t/* If we converted anything ... */\n \tif (wi->changed)\n \t  {\n+\t    tree save_context;\n+\n \t    /* Then the frame decl is now addressable.  */\n \t    TREE_ADDRESSABLE (info->frame_decl) = 1;\n \t    \n+\t    save_context = current_function_decl;\n+\t    current_function_decl = info->context;\n \t    recompute_tree_invarant_for_addr_expr (t);\n+\t    current_function_decl = save_context;\n \n \t    /* If we are in a context where we only accept values, then\n \t       compute the address into a temporary.  */"}]}