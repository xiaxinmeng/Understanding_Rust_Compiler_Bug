{"sha": "eb5485341b9ded93334b9726f8309093df03587b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWI1NDg1MzQxYjlkZWQ5MzMzNGI5NzI2ZjgzMDkwOTNkZjAzNTg3Yg==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2019-11-21T18:14:28Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2019-11-21T18:14:28Z"}, "message": "rs6000: Don't split FP comparisons at expand time\n\nWe currently expand various floating point comparisons early, to some\nsequences with cror insns and the like.  This doesn't optimize well.\n\nChange that to allow any of the 14 floating point comparisons in the\ninstruction stream, and split them after combine (at split1).\n\n\n\t* config/rs6000/predicates.md (extra_insn_branch_comparison_operator):\n\tNew predicate.\n\t* config/rs6000/rs6000-protos.h (rs6000_emit_fp_cror): New declaration.\n\t* config/rs6000/rs6000.c (rs6000_generate_compare): Don't do anything\n\tspecial for FP comparisons that need a cror instruction eventually.\n\t(rs6000_emit_fp_cror): New function.\n\t(rs6000_emit_sCOND): Expand all floating point comparisons to one\n\tinstruction, for normal FP modes, with HONOR_NANS.\n\t(rs6000_emit_cbranch): Reformat.\n\t* config/rs6000/rs6000.md (fp_rev): New iterator.\n\t(fp_two): New iterator.\n\t*<code><mode>_cc for fp_rev and GPR: New define_insn_and_split.\n\t*<code><mode>_cc for fp_two and GPR: New define_insn_and_split.\n\t*cbranch_2insn: New define_insn_and_split.\n\nFrom-SVN: r278593", "tree": {"sha": "554af153a8113acdae4b89e39d6015ab11c52919", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/554af153a8113acdae4b89e39d6015ab11c52919"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb5485341b9ded93334b9726f8309093df03587b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb5485341b9ded93334b9726f8309093df03587b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb5485341b9ded93334b9726f8309093df03587b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb5485341b9ded93334b9726f8309093df03587b/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "557532d1728af193d47867dabbe26bd556fb8586", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/557532d1728af193d47867dabbe26bd556fb8586", "html_url": "https://github.com/Rust-GCC/gccrs/commit/557532d1728af193d47867dabbe26bd556fb8586"}], "stats": {"total": 204, "additions": 147, "deletions": 57}, "files": [{"sha": "2525bcd3bc8c62fc75bea725420168f5be212c4b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb5485341b9ded93334b9726f8309093df03587b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb5485341b9ded93334b9726f8309093df03587b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eb5485341b9ded93334b9726f8309093df03587b", "patch": "@@ -1,3 +1,20 @@\n+2019-11-21  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* config/rs6000/predicates.md (extra_insn_branch_comparison_operator):\n+\tNew predicate.\n+\t* config/rs6000/rs6000-protos.h (rs6000_emit_fp_cror): New declaration.\n+\t* config/rs6000/rs6000.c (rs6000_generate_compare): Don't do anything\n+\tspecial for FP comparisons that need a cror instruction eventually.\n+\t(rs6000_emit_fp_cror): New function.\n+\t(rs6000_emit_sCOND): Expand all floating point comparisons to one\n+\tinstruction, for normal FP modes, with HONOR_NANS.\n+\t(rs6000_emit_cbranch): Reformat.\n+\t* config/rs6000/rs6000.md (fp_rev): New iterator.\n+\t(fp_two): New iterator.\n+\t*<code><mode>_cc for fp_rev and GPR: New define_insn_and_split.\n+\t*<code><mode>_cc for fp_two and GPR: New define_insn_and_split.\n+\t*cbranch_2insn: New define_insn_and_split.\n+\n 2019-11-21  Richard Sandiford  <richard.sandiford@arm.com>\n \n \tPR tree-optimization/92526"}, {"sha": "42c41b323059b484f655e9a711236c9c672416c8", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb5485341b9ded93334b9726f8309093df03587b/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb5485341b9ded93334b9726f8309093df03587b/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=eb5485341b9ded93334b9726f8309093df03587b", "patch": "@@ -1143,6 +1143,16 @@\n \t\t\t\t\t      GET_MODE (XEXP (op, 0))),\n \t\t     1\")))\n \n+;; Return 1 if OP is a comparison that needs an extra instruction to do (a\n+;; crlogical or an extra branch).\n+(define_predicate \"extra_insn_branch_comparison_operator\"\n+   (and (match_operand 0 \"comparison_operator\")\n+\t(match_test \"GET_MODE (XEXP (op, 0)) == CCFPmode\")\n+\t(match_code \"ltgt,le,ge,unlt,ungt,uneq\")\n+\t(match_test \"validate_condition_mode (GET_CODE (op),\n+\t\t\t\t\t      GET_MODE (XEXP (op, 0))),\n+\t\t     1\")))\n+\n ;; Return 1 if OP is an unsigned comparison operator.\n (define_predicate \"unsigned_comparison_operator\"\n   (match_code \"ltu,gtu,leu,geu\"))"}, {"sha": "69e67ac8f096bcec752243b4bc0f42604f684977", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb5485341b9ded93334b9726f8309093df03587b/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb5485341b9ded93334b9726f8309093df03587b/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=eb5485341b9ded93334b9726f8309093df03587b", "patch": "@@ -112,6 +112,7 @@ extern const char *rs6000_pltseq_template (rtx *, int);\n extern enum rtx_code rs6000_reverse_condition (machine_mode,\n \t\t\t\t\t       enum rtx_code);\n extern rtx rs6000_emit_eqne (machine_mode, rtx, rtx, rtx);\n+extern rtx rs6000_emit_fp_cror (rtx_code, machine_mode, rtx);\n extern void rs6000_emit_sCOND (machine_mode, rtx[]);\n extern void rs6000_emit_cbranch (machine_mode, rtx[]);\n extern char * output_cbranch (rtx, const char *, int, rtx_insn *);"}, {"sha": "2995348f3ce2d0d0bde6a8b58d20f264380fa4b9", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 41, "deletions": 57, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb5485341b9ded93334b9726f8309093df03587b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb5485341b9ded93334b9726f8309093df03587b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=eb5485341b9ded93334b9726f8309093df03587b", "patch": "@@ -13954,42 +13954,6 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n \t\t\t\tgen_rtx_COMPARE (comp_mode, op0, op1)));\n     }\n \n-  /* Some kinds of FP comparisons need an OR operation;\n-     under flag_finite_math_only we don't bother.  */\n-  if (FLOAT_MODE_P (mode)\n-      && (!FLOAT128_IEEE_P (mode) || TARGET_FLOAT128_HW)\n-      && !flag_finite_math_only\n-      && (code == LE || code == GE\n-\t  || code == UNEQ || code == LTGT\n-\t  || code == UNGT || code == UNLT))\n-    {\n-      enum rtx_code or1, or2;\n-      rtx or1_rtx, or2_rtx, compare2_rtx;\n-      rtx or_result = gen_reg_rtx (CCEQmode);\n-\n-      switch (code)\n-\t{\n-\tcase LE: or1 = LT;  or2 = EQ;  break;\n-\tcase GE: or1 = GT;  or2 = EQ;  break;\n-\tcase UNEQ: or1 = UNORDERED;  or2 = EQ;  break;\n-\tcase LTGT: or1 = LT;  or2 = GT;  break;\n-\tcase UNGT: or1 = UNORDERED;  or2 = GT;  break;\n-\tcase UNLT: or1 = UNORDERED;  or2 = LT;  break;\n-\tdefault:  gcc_unreachable ();\n-\t}\n-      validate_condition_mode (or1, comp_mode);\n-      validate_condition_mode (or2, comp_mode);\n-      or1_rtx = gen_rtx_fmt_ee (or1, SImode, compare_result, const0_rtx);\n-      or2_rtx = gen_rtx_fmt_ee (or2, SImode, compare_result, const0_rtx);\n-      compare2_rtx = gen_rtx_COMPARE (CCEQmode,\n-\t\t\t\t      gen_rtx_IOR (SImode, or1_rtx, or2_rtx),\n-\t\t\t\t      const_true_rtx);\n-      emit_insn (gen_rtx_SET (or_result, compare2_rtx));\n-\n-      compare_result = or_result;\n-      code = EQ;\n-    }\n-\n   validate_condition_mode (code, GET_MODE (compare_result));\n \n   return gen_rtx_fmt_ee (code, VOIDmode, compare_result, const0_rtx);\n@@ -14301,21 +14265,44 @@ rs6000_emit_eqne (machine_mode mode, rtx op1, rtx op2, rtx scratch)\n   return scratch;\n }\n \n+/* Emit code doing a cror of two CR bits, for FP comparisons with a CODE that\n+   requires this.  The result is mode MODE.  */\n+rtx\n+rs6000_emit_fp_cror (rtx_code code, machine_mode mode, rtx x)\n+{\n+  rtx cond[2];\n+  int n = 0;\n+  if (code == LTGT || code == LE || code == UNLT)\n+    cond[n++] = gen_rtx_fmt_ee (LT, mode, x, const0_rtx);\n+  if (code == LTGT || code == GE || code == UNGT)\n+    cond[n++] = gen_rtx_fmt_ee (GT, mode, x, const0_rtx);\n+  if (code == LE || code == GE || code == UNEQ)\n+    cond[n++] = gen_rtx_fmt_ee (EQ, mode, x, const0_rtx);\n+  if (code == UNLT || code == UNGT || code == UNEQ)\n+    cond[n++] = gen_rtx_fmt_ee (UNORDERED, mode, x, const0_rtx);\n+\n+  gcc_assert (n == 2);\n+\n+  rtx cc = gen_reg_rtx (CCEQmode);\n+  rtx logical = gen_rtx_IOR (mode, cond[0], cond[1]);\n+  emit_insn (gen_cceq_ior_compare (mode, cc, logical, cond[0], x, cond[1], x));\n+\n+  return cc;\n+}\n+\n void\n rs6000_emit_sCOND (machine_mode mode, rtx operands[])\n {\n-  rtx condition_rtx;\n-  machine_mode op_mode;\n-  enum rtx_code cond_code;\n-  rtx result = operands[0];\n+  rtx condition_rtx = rs6000_generate_compare (operands[1], mode);\n+  rtx_code cond_code = GET_CODE (condition_rtx);\n \n-  condition_rtx = rs6000_generate_compare (operands[1], mode);\n-  cond_code = GET_CODE (condition_rtx);\n-\n-  if (cond_code == NE\n-      || cond_code == GE || cond_code == LE\n-      || cond_code == GEU || cond_code == LEU\n-      || cond_code == ORDERED || cond_code == UNGE || cond_code == UNLE)\n+  if (FLOAT_MODE_P (mode) && HONOR_NANS (mode)\n+      && !(FLOAT128_VECTOR_P (mode) && !TARGET_FLOAT128_HW))\n+    ;\n+  else if (cond_code == NE\n+\t   || cond_code == GE || cond_code == LE\n+\t   || cond_code == GEU || cond_code == LEU\n+\t   || cond_code == ORDERED || cond_code == UNGE || cond_code == UNLE)\n     {\n       rtx not_result = gen_reg_rtx (CCEQmode);\n       rtx not_op, rev_cond_rtx;\n@@ -14330,19 +14317,19 @@ rs6000_emit_sCOND (machine_mode mode, rtx operands[])\n       condition_rtx = gen_rtx_EQ (VOIDmode, not_result, const0_rtx);\n     }\n \n-  op_mode = GET_MODE (XEXP (operands[1], 0));\n+  machine_mode op_mode = GET_MODE (XEXP (operands[1], 0));\n   if (op_mode == VOIDmode)\n     op_mode = GET_MODE (XEXP (operands[1], 1));\n \n   if (TARGET_POWERPC64 && (op_mode == DImode || FLOAT_MODE_P (mode)))\n     {\n       PUT_MODE (condition_rtx, DImode);\n-      convert_move (result, condition_rtx, 0);\n+      convert_move (operands[0], condition_rtx, 0);\n     }\n   else\n     {\n       PUT_MODE (condition_rtx, SImode);\n-      emit_insn (gen_rtx_SET (result, condition_rtx));\n+      emit_insn (gen_rtx_SET (operands[0], condition_rtx));\n     }\n }\n \n@@ -14351,13 +14338,10 @@ rs6000_emit_sCOND (machine_mode mode, rtx operands[])\n void\n rs6000_emit_cbranch (machine_mode mode, rtx operands[])\n {\n-  rtx condition_rtx, loc_ref;\n-\n-  condition_rtx = rs6000_generate_compare (operands[0], mode);\n-  loc_ref = gen_rtx_LABEL_REF (VOIDmode, operands[3]);\n-  emit_jump_insn (gen_rtx_SET (pc_rtx,\n-\t\t\t       gen_rtx_IF_THEN_ELSE (VOIDmode, condition_rtx,\n-\t\t\t\t\t\t     loc_ref, pc_rtx)));\n+  rtx condition_rtx = rs6000_generate_compare (operands[0], mode);\n+  rtx loc_ref = gen_rtx_LABEL_REF (VOIDmode, operands[3]);\n+  rtx ite = gen_rtx_IF_THEN_ELSE (VOIDmode, condition_rtx, loc_ref, pc_rtx);\n+  emit_jump_insn (gen_rtx_SET (pc_rtx, ite));\n }\n \n /* Return the string to output a conditional branch to LABEL, which is"}, {"sha": "dff5680df0eac2a24f8e11e4e0e2124df82e2656", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb5485341b9ded93334b9726f8309093df03587b/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb5485341b9ded93334b9726f8309093df03587b/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=eb5485341b9ded93334b9726f8309093df03587b", "patch": "@@ -12373,6 +12373,44 @@\n \t(if_then_else (match_test \"operands[2] == const0_rtx\")\n \t\t      (const_string \"12\")\n \t\t      (const_string \"16\")))])\n+\n+\n+(define_code_iterator fp_rev [ordered ne unle unge])\n+(define_code_iterator fp_two [ltgt le ge unlt ungt uneq])\n+\n+(define_insn_and_split \"*<code><mode>_cc\"\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n+\t(fp_rev:GPR (match_operand:CCFP 1 \"cc_reg_operand\" \"y\")\n+\t\t    (const_int 0)))]\n+  \"!flag_finite_math_only\"\n+  \"#\"\n+  \"&& 1\"\n+  [(pc)]\n+{\n+  rtx_code revcode = reverse_condition_maybe_unordered (<CODE>);\n+  rtx eq = gen_rtx_fmt_ee (revcode, <MODE>mode, operands[1], const0_rtx);\n+  rtx tmp = gen_reg_rtx (<MODE>mode);\n+  emit_move_insn (tmp, eq);\n+  emit_insn (gen_xor<mode>3 (operands[0], tmp, const1_rtx));\n+  DONE;\n+}\n+  [(set_attr \"length\" \"12\")])\n+\n+(define_insn_and_split \"*<code><mode>_cc\"\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n+\t(fp_two:GPR (match_operand:CCFP 1 \"cc_reg_operand\" \"y\")\n+\t\t  (const_int 0)))]\n+  \"!flag_finite_math_only\"\n+  \"#\"\n+  \"&& 1\"\n+  [(pc)]\n+{\n+  rtx cc = rs6000_emit_fp_cror (<CODE>, <MODE>mode, operands[1]);\n+\n+  emit_move_insn (operands[0], gen_rtx_EQ (<MODE>mode, cc, const0_rtx));\n+  DONE;\n+}\n+  [(set_attr \"length\" \"12\")])\n \f\n ;; Conditional branches.\n ;; These either are a single bc insn, or a bc around a b.\n@@ -12397,6 +12435,46 @@\n \t\t      (const_int 4)\n \t\t      (const_int 8)))])\n \n+(define_insn_and_split \"*cbranch_2insn\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 1 \"extra_insn_branch_comparison_operator\"\n+\t\t\t\t      [(match_operand 2 \"cc_reg_operand\" \"y\")\n+\t\t\t\t       (const_int 0)])\n+\t\t      (label_ref (match_operand 0))\n+\t\t      (pc)))]\n+  \"!flag_finite_math_only\"\n+  \"#\"\n+  \"&& 1\"\n+  [(pc)]\n+{\n+  rtx cc = rs6000_emit_fp_cror (GET_CODE (operands[1]), SImode, operands[2]);\n+\n+  rtx note = find_reg_note (curr_insn, REG_BR_PROB, 0);\n+\n+  rtx loc_ref = gen_rtx_LABEL_REF (VOIDmode, operands[0]);\n+  rtx cond = gen_rtx_EQ (CCEQmode, cc, const0_rtx);\n+  rtx ite = gen_rtx_IF_THEN_ELSE (VOIDmode, cond, loc_ref, pc_rtx);\n+  emit_jump_insn (gen_rtx_SET (pc_rtx, ite));\n+\n+  if (note)\n+    {\n+      profile_probability prob\n+\t= profile_probability::from_reg_br_prob_note (XINT (note, 0));\n+\n+      add_reg_br_prob_note (get_last_insn (), prob);\n+    }\n+\n+  DONE;\n+}\n+  [(set_attr \"type\" \"branch\")\n+   (set (attr \"length\")\n+\t(if_then_else (and (ge (minus (match_dup 0) (pc))\n+\t\t\t       (const_int -32764))\n+\t\t\t   (lt (minus (match_dup 0) (pc))\n+\t\t\t       (const_int 32760)))\n+\t\t      (const_int 8)\n+\t\t      (const_int 16)))])\n+\n ;; Conditional return.\n (define_insn \"*creturn\"\n   [(set (pc)"}]}