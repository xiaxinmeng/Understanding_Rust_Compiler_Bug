{"sha": "eca9803844ddf459d3f5992aa88353603f0cb731", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWNhOTgwMzg0NGRkZjQ1OWQzZjU5OTJhYTg4MzUzNjAzZjBjYjczMQ==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.vnet.ibm.com", "date": "2016-12-02T08:22:34Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2016-12-02T08:22:34Z"}, "message": "S/390: Merge compare of compare results\n\nWith this patch EQ and NE compares on CC mode reader patterns are\nfolded.  This allows using the result of the vec_all_* and vec_any_*\nbuiltins directly in a conditional jump instruction as in the attached\ntestcase.\n\ngcc/ChangeLog:\n\n2016-12-02  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n\n\t* config/s390/s390-protos.h (s390_reverse_condition): New\n\tprototype.\n\t* config/s390/s390.c (s390_canonicalize_comparison): Fold compares\n\tof CC mode values.\n\t(s390_reverse_condition): New function.\n\t* config/s390/s390.h (REVERSE_CC_MODE, REVERSE_CONDITION): Define\n\ttarget macros.\n\ngcc/testsuite/ChangeLog:\n\n2016-12-02  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n\n\t* gcc.target/s390/zvector/vec-cmp-2.c: New test.\n\nFrom-SVN: r243155", "tree": {"sha": "175e6e75fad8aa9948599146110c6f81308ef43d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/175e6e75fad8aa9948599146110c6f81308ef43d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eca9803844ddf459d3f5992aa88353603f0cb731", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eca9803844ddf459d3f5992aa88353603f0cb731", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eca9803844ddf459d3f5992aa88353603f0cb731", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eca9803844ddf459d3f5992aa88353603f0cb731/comments", "author": null, "committer": null, "parents": [{"sha": "a6a2b532f9c4e92277e390febc8c07f773becb1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6a2b532f9c4e92277e390febc8c07f773becb1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6a2b532f9c4e92277e390febc8c07f773becb1b"}], "stats": {"total": 69, "additions": 69, "deletions": 0}, "files": [{"sha": "d06661e26c4fd7d1d83ad61f673b3ac2f7310c81", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eca9803844ddf459d3f5992aa88353603f0cb731/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eca9803844ddf459d3f5992aa88353603f0cb731/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eca9803844ddf459d3f5992aa88353603f0cb731", "patch": "@@ -1,3 +1,13 @@\n+2016-12-02  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\t* config/s390/s390-protos.h (s390_reverse_condition): New\n+\tprototype.\n+\t* config/s390/s390.c (s390_canonicalize_comparison): Fold compares\n+\tof CC mode values.\n+\t(s390_reverse_condition): New function.\n+\t* config/s390/s390.h (REVERSE_CC_MODE, REVERSE_CONDITION): Define\n+\ttarget macros.\n+\n 2016-12-02  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* config/s390/s390-modes.def (CCVEQANY, CCVH, CCVHANY, CCVHU)"}, {"sha": "000a6771c6827082775e1285489f707a7cbbc402", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eca9803844ddf459d3f5992aa88353603f0cb731/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eca9803844ddf459d3f5992aa88353603f0cb731/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=eca9803844ddf459d3f5992aa88353603f0cb731", "patch": "@@ -119,6 +119,7 @@ extern void s390_expand_atomic (machine_mode, enum rtx_code,\n extern void s390_expand_tbegin (rtx, rtx, rtx, bool);\n extern void s390_expand_vec_compare (rtx, enum rtx_code, rtx, rtx);\n extern void s390_expand_vec_compare_cc (rtx, enum rtx_code, rtx, rtx, bool);\n+extern enum rtx_code s390_reverse_condition (machine_mode, enum rtx_code);\n extern void s390_expand_vcond (rtx, rtx, rtx, enum rtx_code, rtx, rtx);\n extern void s390_expand_vec_init (rtx, rtx);\n extern rtx s390_return_addr_rtx (int, rtx);"}, {"sha": "dab4f43e37a33f1848f88d78f376d0a602bc9dde", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eca9803844ddf459d3f5992aa88353603f0cb731/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eca9803844ddf459d3f5992aa88353603f0cb731/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=eca9803844ddf459d3f5992aa88353603f0cb731", "patch": "@@ -1722,6 +1722,31 @@ s390_canonicalize_comparison (int *code, rtx *op0, rtx *op1,\n \t}\n       tmp = *op0; *op0 = *op1; *op1 = tmp;\n     }\n+\n+  /* A comparison result is compared against zero.  Replace it with\n+     the (perhaps inverted) original comparison.\n+     This probably should be done by simplify_relational_operation.  */\n+  if ((*code == EQ || *code == NE)\n+      && *op1 == const0_rtx\n+      && COMPARISON_P (*op0)\n+      && CC_REG_P (XEXP (*op0, 0)))\n+    {\n+      enum rtx_code new_code;\n+\n+      if (*code == EQ)\n+\tnew_code = reversed_comparison_code_parts (GET_CODE (*op0),\n+\t\t\t\t\t\t   XEXP (*op0, 0),\n+\t\t\t\t\t\t   XEXP (*op1, 0), NULL);\n+      else\n+\tnew_code = GET_CODE (*op0);\n+\n+      if (new_code != UNKNOWN)\n+\t{\n+\t  *code = new_code;\n+\t  *op1 = XEXP (*op0, 1);\n+\t  *op0 = XEXP (*op0, 0);\n+\t}\n+    }\n }\n \n /* Helper function for s390_emit_compare.  If possible emit a 64 bit\n@@ -6343,6 +6368,23 @@ s390_expand_vec_compare_cc (rtx target, enum rtx_code code,\n \t\t\t\t\ttmp_reg, target));\n }\n \n+/* Invert the comparison CODE applied to a CC mode.  This is only safe\n+   if we know whether there result was created by a floating point\n+   compare or not.  For the CCV modes this is encoded as part of the\n+   mode.  */\n+enum rtx_code\n+s390_reverse_condition (machine_mode mode, enum rtx_code code)\n+{\n+  /* Reversal of FP compares takes care -- an ordered compare\n+     becomes an unordered compare and vice versa.  */\n+  if (mode == CCVFALLmode || mode == CCVFANYmode)\n+    return reverse_condition_maybe_unordered (code);\n+  else if (mode == CCVIALLmode || mode == CCVIANYmode)\n+    return reverse_condition (code);\n+  else\n+    gcc_unreachable ();\n+}\n+\n /* Generate a vector comparison expression loading either elements of\n    THEN or ELS into TARGET depending on the comparison COND of CMP_OP1\n    and CMP_OP2.  */"}, {"sha": "1d6d7b25594ecf41a8478faefa56c45bb830f946", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eca9803844ddf459d3f5992aa88353603f0cb731/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eca9803844ddf459d3f5992aa88353603f0cb731/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=eca9803844ddf459d3f5992aa88353603f0cb731", "patch": "@@ -513,6 +513,18 @@ extern const char *s390_host_detect_local_cpu (int argc, const char **argv);\n #define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)\t\t        \\\n   s390_cannot_change_mode_class ((FROM), (TO), (CLASS))\n \n+/* We can reverse a CC mode safely if we know whether it comes from a\n+   floating point compare or not.  With the vector modes it is encoded\n+   as part of the mode.\n+   FIXME: It might make sense to do this for other cc modes as well.  */\n+#define REVERSIBLE_CC_MODE(MODE)\t\t\t\t\\\n+  ((MODE) == CCVIALLmode || (MODE) == CCVIANYmode\t\t\\\n+   || (MODE) == CCVFALLmode || (MODE) == CCVFANYmode)\n+\n+/* Given a condition code and a mode, return the inverse condition.  */\n+#define REVERSE_CONDITION(CODE, MODE) s390_reverse_condition (MODE, CODE)\n+\n+\n /* Register classes.  */\n \n /* We use the following register classes:"}, {"sha": "dc269ef178ffd9de93f552e3a9ea6ba95382e335", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eca9803844ddf459d3f5992aa88353603f0cb731/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eca9803844ddf459d3f5992aa88353603f0cb731/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=eca9803844ddf459d3f5992aa88353603f0cb731", "patch": "@@ -1,3 +1,7 @@\n+2016-12-02  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\t* gcc.target/s390/zvector/vec-cmp-2.c: New test.\n+\n 2016-12-02  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* gcc.target/s390/vector/vec-scalar-cmp-1.c: Fix and harden the"}]}