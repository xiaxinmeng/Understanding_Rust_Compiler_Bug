{"sha": "9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWUxMWJmZWY3YWJiMDk2ZGMxZTA2ZjFkOTM5MWZjN2FmZjZhNzEyNw==", "commit": {"author": {"name": "Trevor Saunders", "email": "tbsaunde+gcc@tbsaunde.org", "date": "2015-07-09T02:51:19Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2015-07-09T02:51:19Z"}, "message": "always define WORD_REGISTER_OPERATIONS\n\ngcc/ChangeLog:\n\n2015-07-08  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n\n\t* defaults.h: Provide default for WORD_REGISTER_OPERATIONS.\n\t* config/alpha/alpha.h: Define WORD_REGISTER_OPERATIONS to 1.\n\t* config/arc/arc.h: Likewise.\n\t* config/arm/arm.h: Likewise.\n\t* config/bfin/bfin.h: Likewise.\n\t* config/epiphany/epiphany.h: Likewise.\n\t* config/frv/frv.h: Likewise.\n\t* config/ia64/ia64.h: Likewise.\n\t* config/iq2000/iq2000.h: Likewise.\n\t* config/lm32/lm32.h: Likewise.\n\t* config/m32r/m32r.h: Likewise.\n\t* config/mcore/mcore.h: Likewise.\n\t* config/mep/mep.h: Likewise.\n\t* config/microblaze/microblaze.h: Likewise.\n\t* config/mips/mips.h: Likewise.\n\t* config/mmix/mmix.h: Likewise.\n\t* config/mn10300/mn10300.h: Likewise.\n\t* config/nds32/nds32.h: Likewise.\n\t* config/nios2/nios2.h: Likewise.\n\t* config/pa/pa.h: Likewise.\n\t* config/rl78/rl78.h: Likewise.\n\t* config/sh/sh.h: Likewise.\n\t* config/sparc/sparc.h: Likewise.\n\t* config/stormy16/stormy16.h: Likewise.\n\t* config/tilegx/tilegx.h: Likewise.\n\t* config/tilepro/tilepro.h: Likewise.\n\t* config/v850/v850.h: Likewise.\n\t* config/xtensa/xtensa.h: Likewise.\n\t* doc/tm.texi: Regenerate.\n\t* doc/tm.texi.in: Adjust.\n\t* combine.c (simplify_set): Likewise.\n\t(simplify_comparison): Likewise.\n\t* expr.c (store_constructor): Likewise.\n\t* internal-fn.c (expand_arith_overflow): Likewise.\n\t* reload.c (push_reload): Likewise.\n\t(find_reloads): Likewise.\n\t(find_reloads_subreg_address): Likewise.\n\t* reload1.c (eliminate_regs_1): Likewise.\n\t* rtlanal.c (nonzero_bits1): Likewise.\n\t(num_sign_bit_copies1): Likewise.\n\t* simplify-rtx.c (simplify_truncation): Likewise.\n\nFrom-SVN: r225597", "tree": {"sha": "0f911fdcff3136d1be7745fa3a9df698289ae2af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f911fdcff3136d1be7745fa3a9df698289ae2af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/comments", "author": null, "committer": null, "parents": [{"sha": "760edf20ba65b2d6b44a6a8c98683e4eb9490009", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/760edf20ba65b2d6b44a6a8c98683e4eb9490009", "html_url": "https://github.com/Rust-GCC/gccrs/commit/760edf20ba65b2d6b44a6a8c98683e4eb9490009"}], "stats": {"total": 190, "additions": 113, "deletions": 77}, "files": [{"sha": "c54e138220cda9b465cf1a2edec124834506577d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -1,3 +1,47 @@\n+2015-07-08  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n+\n+\t* defaults.h: Provide default for WORD_REGISTER_OPERATIONS.\n+\t* config/alpha/alpha.h: Define WORD_REGISTER_OPERATIONS to 1.\n+\t* config/arc/arc.h: Likewise.\n+\t* config/arm/arm.h: Likewise.\n+\t* config/bfin/bfin.h: Likewise.\n+\t* config/epiphany/epiphany.h: Likewise.\n+\t* config/frv/frv.h: Likewise.\n+\t* config/ia64/ia64.h: Likewise.\n+\t* config/iq2000/iq2000.h: Likewise.\n+\t* config/lm32/lm32.h: Likewise.\n+\t* config/m32r/m32r.h: Likewise.\n+\t* config/mcore/mcore.h: Likewise.\n+\t* config/mep/mep.h: Likewise.\n+\t* config/microblaze/microblaze.h: Likewise.\n+\t* config/mips/mips.h: Likewise.\n+\t* config/mmix/mmix.h: Likewise.\n+\t* config/mn10300/mn10300.h: Likewise.\n+\t* config/nds32/nds32.h: Likewise.\n+\t* config/nios2/nios2.h: Likewise.\n+\t* config/pa/pa.h: Likewise.\n+\t* config/rl78/rl78.h: Likewise.\n+\t* config/sh/sh.h: Likewise.\n+\t* config/sparc/sparc.h: Likewise.\n+\t* config/stormy16/stormy16.h: Likewise.\n+\t* config/tilegx/tilegx.h: Likewise.\n+\t* config/tilepro/tilepro.h: Likewise.\n+\t* config/v850/v850.h: Likewise.\n+\t* config/xtensa/xtensa.h: Likewise.\n+\t* doc/tm.texi: Regenerate.\n+\t* doc/tm.texi.in: Adjust.\n+\t* combine.c (simplify_set): Likewise.\n+\t(simplify_comparison): Likewise.\n+\t* expr.c (store_constructor): Likewise.\n+\t* internal-fn.c (expand_arith_overflow): Likewise.\n+\t* reload.c (push_reload): Likewise.\n+\t(find_reloads): Likewise.\n+\t(find_reloads_subreg_address): Likewise.\n+\t* reload1.c (eliminate_regs_1): Likewise.\n+\t* rtlanal.c (nonzero_bits1): Likewise.\n+\t(num_sign_bit_copies1): Likewise.\n+\t* simplify-rtx.c (simplify_truncation): Likewise.\n+\n 2015-07-08  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n \n \t* auto-inc-dec.c (pass_inc_dec::execute): Don't check the value"}, {"sha": "e4e1d3ab6565195bc5481ddbaadaf4dc4599ddfc", "filename": "gcc/combine.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -6716,10 +6716,9 @@ simplify_set (rtx x)\n \t   / UNITS_PER_WORD)\n \t  == ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (src)))\n \t       + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD))\n-#ifndef WORD_REGISTER_OPERATIONS\n-      && (GET_MODE_SIZE (GET_MODE (src))\n-\t< GET_MODE_SIZE (GET_MODE (SUBREG_REG (src))))\n-#endif\n+      && (WORD_REGISTER_OPERATIONS\n+\t  || (GET_MODE_SIZE (GET_MODE (src))\n+\t      < GET_MODE_SIZE (GET_MODE (SUBREG_REG (src)))))\n #ifdef CANNOT_CHANGE_MODE_CLASS\n       && ! (REG_P (dest) && REGNO (dest) < FIRST_PSEUDO_REGISTER\n \t    && REG_CANNOT_CHANGE_MODE_P (REGNO (dest),\n@@ -11424,7 +11423,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n   /* Try a few ways of applying the same transformation to both operands.  */\n   while (1)\n     {\n-#ifndef WORD_REGISTER_OPERATIONS\n+#if !WORD_REGISTER_OPERATIONS\n       /* The test below this one won't handle SIGN_EXTENDs on these machines,\n \t so check specially.  */\n       if (code != GTU && code != GEU && code != LTU && code != LEU\n@@ -12078,11 +12077,9 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t\t     However, if we commute the AND inside the SUBREG then\n \t\t     they no longer have defined values and the meaning of\n \t\t     the code has been changed.  */\n-\t\t  && (0\n-#ifdef WORD_REGISTER_OPERATIONS\n-\t\t      || (mode_width > GET_MODE_PRECISION (tmode)\n-\t\t\t  && mode_width <= BITS_PER_WORD)\n-#endif\n+\t\t  && ((WORD_REGISTER_OPERATIONS\n+\t\t       && mode_width > GET_MODE_PRECISION (tmode)\n+\t\t       && mode_width <= BITS_PER_WORD)\n \t\t      || (mode_width <= GET_MODE_PRECISION (tmode)\n \t\t\t  && subreg_lowpart_p (XEXP (op0, 0))))\n \t\t  && CONST_INT_P (XEXP (op0, 1))"}, {"sha": "3fb58b11b0ddd95c00428f8899abcfb73e653b47", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -888,7 +888,7 @@ do {\t\t\t\t\t\t\t\t\t     \\\n \n /* Define if operations between registers always perform the operation\n    on the full register even if a narrower mode is specified.  */\n-#define WORD_REGISTER_OPERATIONS\n+#define WORD_REGISTER_OPERATIONS 1\n \n /* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n    will either zero-extend or sign-extend.  The value of this macro should"}, {"sha": "d98cce112571d5554ac13a311305ac249cfdcc5b", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -1540,7 +1540,7 @@ extern int arc_return_address_regs[4];\n \n /* Define if operations between registers always perform the operation\n    on the full register even if a narrower mode is specified.  */\n-#define WORD_REGISTER_OPERATIONS\n+#define WORD_REGISTER_OPERATIONS 1\n \n /* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n    will either zero-extend or sign-extend.  The value of this macro should"}, {"sha": "836e5179d9b195ba416d506617115b94d8b595c8", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -1904,7 +1904,7 @@ enum arm_auto_incmodes\n \n /* Define if operations between registers always perform the operation\n    on the full register even if a narrower mode is specified.  */\n-#define WORD_REGISTER_OPERATIONS\n+#define WORD_REGISTER_OPERATIONS 1\n \n /* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n    will either zero-extend or sign-extend.  The value of this macro should"}, {"sha": "26ba7c2e0155bcb0aae399ee7521a4fe7d243f12", "filename": "gcc/config/bfin/bfin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fbfin%2Fbfin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fbfin%2Fbfin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.h?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -982,7 +982,7 @@ typedef struct {\n \n /* Define if operations between registers always perform the operation\n    on the full register even if a narrower mode is specified. \n-#define WORD_REGISTER_OPERATIONS\n+#define WORD_REGISTER_OPERATIONS 1\n */\n \n /* Evaluates to true if A and B are mac flags that can be used"}, {"sha": "62a3d9d7ee6d1482cc54b5ad2b62554c4904a582", "filename": "gcc/config/epiphany/epiphany.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fepiphany%2Fepiphany.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fepiphany%2Fepiphany.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.h?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -845,7 +845,7 @@ do \\\n \n /* Define if operations between registers always perform the operation\n    on the full register even if a narrower mode is specified.  */\n-#define WORD_REGISTER_OPERATIONS\n+#define WORD_REGISTER_OPERATIONS 1\n \n /* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n    will either zero-extend or sign-extend.  The value of this macro should"}, {"sha": "b0d66fdf610c811b7b1035fa5319a467b3367f5d", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -1882,7 +1882,7 @@ fprintf (STREAM, \"\\t.word .L%d\\n\", VALUE)\n /* Define this macro if operations between registers with integral mode smaller\n    than a word are always performed on the entire register.  Most RISC machines\n    have this property and most CISC machines do not.  */\n-#define WORD_REGISTER_OPERATIONS\n+#define WORD_REGISTER_OPERATIONS 1\n \n /* Define this macro to be a C expression indicating when insns that read\n    memory in MODE, an integral mode narrower than a word, set the bits outside"}, {"sha": "4b624237a486e652c9711a2298260c1425b037c6", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -1631,7 +1631,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* Define this macro if operations between registers with integral mode smaller\n    than a word are always performed on the entire register.  */\n \n-#define WORD_REGISTER_OPERATIONS\n+#define WORD_REGISTER_OPERATIONS 1\n \n /* Define this macro to be a C expression indicating when insns that read\n    memory in MODE, an integral mode narrower than a word, set the bits outside"}, {"sha": "73b1205db1cf07674daa97703cf4049facb568bc", "filename": "gcc/config/iq2000/iq2000.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.h?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -541,7 +541,7 @@ while (0)\n \n #define CASE_VECTOR_MODE SImode\n \n-#define WORD_REGISTER_OPERATIONS\n+#define WORD_REGISTER_OPERATIONS 1\n \n #define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n "}, {"sha": "986383f91b031397479eb733b28f4ef2830d59ff", "filename": "gcc/config/lm32/lm32.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Flm32%2Flm32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Flm32%2Flm32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flm32%2Flm32.h?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -521,7 +521,7 @@ do {                                                            \\\n \n #define CASE_VECTOR_MODE Pmode\n \n-#define WORD_REGISTER_OPERATIONS\n+#define WORD_REGISTER_OPERATIONS 1\n \n #define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n "}, {"sha": "fa061351f38a79010b32a6566889820fba6cc5ed", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -1004,7 +1004,7 @@ L2:     .word STATIC\n \n /* Define if operations between registers always perform the operation\n    on the full register even if a narrower mode is specified.  */\n-#define WORD_REGISTER_OPERATIONS\n+#define WORD_REGISTER_OPERATIONS 1\n \n /* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n    will either zero-extend or sign-extend.  The value of this macro should"}, {"sha": "999d53603e168dc3628db8cf3e4a7890f1261b6c", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -639,7 +639,7 @@ extern const enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n \n /* Define if operations between registers always perform the operation\n    on the full register even if a narrower mode is specified.  */\n-#define WORD_REGISTER_OPERATIONS\n+#define WORD_REGISTER_OPERATIONS 1\n \n /* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n    will either zero-extend or sign-extend.  The value of this macro should\n@@ -673,7 +673,7 @@ extern const enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n    and another.  All register moves are cheap.  */\n #define REGISTER_MOVE_COST(MODE, SRCCLASS, DSTCLASS) 2\n \n-#define WORD_REGISTER_OPERATIONS\n+#define WORD_REGISTER_OPERATIONS 1\n \n /* Assembler output control.  */\n #define ASM_COMMENT_START \"\\t//\""}, {"sha": "f7322cb7c56e0f7633e2b278726ea754907f4105", "filename": "gcc/config/mep/mep.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fmep%2Fmep.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fmep%2Fmep.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep.h?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -762,7 +762,7 @@ typedef struct\n \n #define CASE_VECTOR_MODE SImode\n \n-#define WORD_REGISTER_OPERATIONS\n+#define WORD_REGISTER_OPERATIONS 1\n #define LOAD_EXTEND_OP(MODE) SIGN_EXTEND\n \n #define SHORT_IMMEDIATES_SIGN_EXTEND 1"}, {"sha": "482c4a25d204faf22c415a30f3f78fc8417ab79a", "filename": "gcc/config/microblaze/microblaze.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.h?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -235,7 +235,7 @@ extern enum pipeline_type microblaze_pipe;\n        && TYPE_MODE (TREE_TYPE (TYPE)) == QImode)\t\t\t\\\n      && (ALIGN) < BITS_PER_WORD) ? BITS_PER_WORD : (ALIGN))\n \n-#define WORD_REGISTER_OPERATIONS\n+#define WORD_REGISTER_OPERATIONS 1\n \n #define LOAD_EXTEND_OP(MODE)  ZERO_EXTEND\n "}, {"sha": "37c85f0f05537a40da6a8f196dba3ca64d31ff98", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -1598,7 +1598,7 @@ FP_ASM_SPEC \"\\\n \n /* Define if operations between registers always perform the operation\n    on the full register even if a narrower mode is specified.  */\n-#define WORD_REGISTER_OPERATIONS\n+#define WORD_REGISTER_OPERATIONS 1\n \n /* When in 64-bit mode, move insns will sign extend SImode and CCmode\n    moves.  All other references are zero extended.  */"}, {"sha": "d15d90e54a37d24931cd3c4dd8ea7a29bf7f0aae", "filename": "gcc/config/mmix/mmix.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fmmix%2Fmmix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fmmix%2Fmmix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.h?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -793,7 +793,7 @@ typedef struct { int regs; int lib; } CUMULATIVE_ARGS;\n #define CASE_VECTOR_MODE DImode\n #define CASE_VECTOR_PC_RELATIVE 0\n \n-#define WORD_REGISTER_OPERATIONS\n+#define WORD_REGISTER_OPERATIONS 1\n \n /* We have a choice, which makes this yet another parameter to tweak.  The\n    gut feeling is currently that SIGN_EXTEND wins; \"int\" is more frequent"}, {"sha": "dbedb18e40cfda66febbc7a44d340721e456c34f", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -699,7 +699,7 @@ do {\t\t\t\t\t\t\t\t\t     \\\n \n /* Define if operations between registers always perform the operation\n    on the full register even if a narrower mode is specified.  */\n-#define WORD_REGISTER_OPERATIONS\n+#define WORD_REGISTER_OPERATIONS 1\n \n #define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n "}, {"sha": "126b5861d80abc3c48c039eb6c9c6f1727efb240", "filename": "gcc/config/nds32/nds32.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fnds32%2Fnds32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fnds32%2Fnds32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.h?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -1001,7 +1001,7 @@ enum reg_class\n \n /* Define this macro if operations between registers with integral mode\n    smaller than a word are always performed on the entire register.  */\n-#define WORD_REGISTER_OPERATIONS\n+#define WORD_REGISTER_OPERATIONS 1\n \n /* A C expression indicating when insns that read memory in mem_mode,\n    an integral mode narrower than a word, set the bits outside of mem_mode"}, {"sha": "5856d7dccf6a3e353dcc2ab9930f7f519b67ddf2", "filename": "gcc/config/nios2/nios2.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fnios2%2Fnios2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fnios2%2Fnios2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2.h?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -497,6 +497,6 @@ do {                                                                    \\\n \n #define LOAD_EXTEND_OP(MODE) (ZERO_EXTEND)\n \n-#define WORD_REGISTER_OPERATIONS\n+#define WORD_REGISTER_OPERATIONS 1\n \n #endif /* GCC_NIOS2_H */"}, {"sha": "d7daabf081ddc94efcf4b3fc8d03e580466f7bc3", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -1011,7 +1011,7 @@ do {\t\t\t\t\t\t\t\t\t     \\\n \n /* Define if operations between registers always perform the operation\n    on the full register even if a narrower mode is specified.  */\n-#define WORD_REGISTER_OPERATIONS\n+#define WORD_REGISTER_OPERATIONS 1\n \n /* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n    will either zero-extend or sign-extend.  The value of this macro should"}, {"sha": "6c72fac938b35b8963ce913fa103683b8226f7d8", "filename": "gcc/config/rl78/rl78.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Frl78%2Frl78.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Frl78%2Frl78.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.h?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -144,7 +144,7 @@\n #define POINTERS_EXTEND_UNSIGNED\t1\n #define FUNCTION_MODE \t\t\tHImode\n #define CASE_VECTOR_MODE\t\tPmode\n-#define WORD_REGISTER_OPERATIONS\t0\n+#define WORD_REGISTER_OPERATIONS\t1\n #define HAS_LONG_COND_BRANCH\t\t0\n #define HAS_LONG_UNCOND_BRANCH\t\t0\n "}, {"sha": "7aa489d6dc045a13a83994fab0d78cabf3204d6e", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -1813,7 +1813,7 @@ struct sh_args {\n \n /* Define if operations between registers always perform the operation\n    on the full register even if a narrower mode is specified.  */\n-#define WORD_REGISTER_OPERATIONS\n+#define WORD_REGISTER_OPERATIONS 1\n \n /* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n    will either zero-extend or sign-extend.  The value of this macro should"}, {"sha": "2cbe0d9b7fa2d7f5370bca44aae0f2a346f644ff", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -1460,7 +1460,7 @@ do {\t\t\t\t\t\t\t\t\t   \\\n \n /* Define if operations between registers always perform the operation\n    on the full register even if a narrower mode is specified.  */\n-#define WORD_REGISTER_OPERATIONS\n+#define WORD_REGISTER_OPERATIONS 1\n \n /* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n    will either zero-extend or sign-extend.  The value of this macro should"}, {"sha": "ef787fdd3fe6a57c194d4f616788264391cc9b3c", "filename": "gcc/config/stormy16/stormy16.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.h?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -487,7 +487,7 @@ enum reg_class\n \n #define CASE_VECTOR_MODE SImode\n \n-#define WORD_REGISTER_OPERATIONS\n+#define WORD_REGISTER_OPERATIONS 1\n \n #define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n "}, {"sha": "ac134b9d64cce5275432be38e6c7fd827192a976", "filename": "gcc/config/tilegx/tilegx.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Ftilegx%2Ftilegx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Ftilegx%2Ftilegx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.h?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -367,7 +367,7 @@ enum reg_class\n #define CLEAR_RATIO(speed) ((speed) ? 15 : TILEGX_CALL_RATIO)\n #define SET_RATIO(speed) ((speed) ? 15 : TILEGX_CALL_RATIO)\n \n-#define WORD_REGISTER_OPERATIONS\n+#define WORD_REGISTER_OPERATIONS 1\n \n #define LOAD_EXTEND_OP(MODE) ((MODE) == SImode ? SIGN_EXTEND : ZERO_EXTEND)\n "}, {"sha": "a6d8c4eceb0bdcd4b2b034e4f25894ed6e370f12", "filename": "gcc/config/tilepro/tilepro.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Ftilepro%2Ftilepro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Ftilepro%2Ftilepro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.h?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -331,7 +331,7 @@ enum reg_class\n #define CLEAR_RATIO(speed) ((speed) ? 15 : TILEPRO_CALL_RATIO)\n #define SET_RATIO(speed) ((speed) ? 15 : TILEPRO_CALL_RATIO)\n \n-#define WORD_REGISTER_OPERATIONS\n+#define WORD_REGISTER_OPERATIONS 1\n \n #define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n "}, {"sha": "45ff1d596d176cc41264830c5fc57a4de4f7b53c", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -864,7 +864,7 @@ typedef enum\n #define ASM_OUTPUT_BEFORE_CASE_LABEL(FILE,PREFIX,NUM,TABLE) \\\n   ASM_OUTPUT_ALIGN ((FILE), (TARGET_BIG_SWITCH ? 2 : 1));\n \n-#define WORD_REGISTER_OPERATIONS\n+#define WORD_REGISTER_OPERATIONS 1\n \n /* Byte and short loads sign extend the value to a word.  */\n #define LOAD_EXTEND_OP(MODE) SIGN_EXTEND"}, {"sha": "ebc8792f90a5648f3a84bb21602da9a32ec24ed8", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -197,7 +197,7 @@ extern unsigned xtensa_current_frame_size;\n \n /* Operations between registers always perform the operation\n    on the full register even if a narrower mode is specified.  */\n-#define WORD_REGISTER_OPERATIONS\n+#define WORD_REGISTER_OPERATIONS 1\n \n /* Xtensa loads are zero-extended by default.  */\n #define LOAD_EXTEND_OP(MODE) ZERO_EXTEND"}, {"sha": "9d38ba18ff417d3e76413b1102fb7cc5a2a7b2cd", "filename": "gcc/defaults.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -1269,6 +1269,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define SHORT_IMMEDIATES_SIGN_EXTEND 0\n #endif\n \n+#ifndef WORD_REGISTER_OPERATIONS\n+#define WORD_REGISTER_OPERATIONS 0\n+#endif\n+\n #ifdef GCC_INSN_FLAGS_H\n /* Dependent default target macro definitions\n "}, {"sha": "b911b7d4e260210059ce3ea527aaa816faa37bdc", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -10377,7 +10377,7 @@ five otherwise.  This is best for most machines.\n @end deftypefn\n \n @defmac WORD_REGISTER_OPERATIONS\n-Define this macro if operations between registers with integral mode\n+Define this macro to 1 if operations between registers with integral mode\n smaller than a word are always performed on the entire register.\n Most RISC machines have this property and most CISC machines do not.\n @end defmac"}, {"sha": "47550cc986100918467f3ea8d23498b0d92e6939", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -7501,7 +7501,7 @@ is in effect.\n @hook TARGET_CASE_VALUES_THRESHOLD\n \n @defmac WORD_REGISTER_OPERATIONS\n-Define this macro if operations between registers with integral mode\n+Define this macro to 1 if operations between registers with integral mode\n smaller than a word are always performed on the entire register.\n Most RISC machines have this property and most CISC machines do not.\n @end defmac"}, {"sha": "34930c506ed00dc0f32d7c719946026f56df93af", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -5979,9 +5979,7 @@ static void\n store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n {\n   tree type = TREE_TYPE (exp);\n-#ifdef WORD_REGISTER_OPERATIONS\n   HOST_WIDE_INT exp_size = int_size_in_bytes (type);\n-#endif\n \n   switch (TREE_CODE (type))\n     {\n@@ -6094,13 +6092,13 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t\t\t\t highest_pow2_factor (offset));\n \t      }\n \n-#ifdef WORD_REGISTER_OPERATIONS\n \t    /* If this initializes a field that is smaller than a\n \t       word, at the start of a word, try to widen it to a full\n \t       word.  This special case allows us to output C++ member\n \t       function initializations in a form that the optimizers\n \t       can understand.  */\n-\t    if (REG_P (target)\n+\t    if (WORD_REGISTER_OPERATIONS\n+\t\t&& REG_P (target)\n \t\t&& bitsize < BITS_PER_WORD\n \t\t&& bitpos % BITS_PER_WORD == 0\n \t\t&& GET_MODE_CLASS (mode) == MODE_INT\n@@ -6125,7 +6123,6 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\tbitsize = BITS_PER_WORD;\n \t\tmode = word_mode;\n \t      }\n-#endif\n \n \t    if (MEM_P (to_rtx) && !MEM_KEEP_ALIAS_SET_P (to_rtx)\n \t\t&& DECL_NONADDRESSABLE_P (field))"}, {"sha": "82d59c92ecfb3bc8590000784db0705642b911e2", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -1727,15 +1727,15 @@ expand_arith_overflow (enum tree_code code, gimple stmt)\n \t  return;\n \t}\n \n-#ifdef WORD_REGISTER_OPERATIONS\n       /* For sub-word operations, if target doesn't have them, start\n \t with precres widening right away, otherwise do it only\n \t if the most simple cases can't be used.  */\n-      if (orig_precres == precres && precres < BITS_PER_WORD)\n+      if (WORD_REGISTER_OPERATIONS\n+\t  && orig_precres == precres\n+\t  && precres < BITS_PER_WORD)\n \t;\n-      else\n-#endif\n-      if ((uns0_p && uns1_p && unsr_p && prec0 <= precres && prec1 <= precres)\n+      else if ((uns0_p && uns1_p && unsr_p && prec0 <= precres\n+\t\t&& prec1 <= precres)\n \t  || ((!uns0_p || !uns1_p) && !unsr_p\n \t      && prec0 + uns0_p <= precres\n \t      && prec1 + uns1_p <= precres))\n@@ -1764,7 +1764,7 @@ expand_arith_overflow (enum tree_code code, gimple stmt)\n       /* For sub-word operations, retry with a wider type first.  */\n       if (orig_precres == precres && precop <= BITS_PER_WORD)\n \t{\n-#ifdef WORD_REGISTER_OPERATIONS\n+#if WORD_REGISTER_OPERATIONS\n \t  int p = BITS_PER_WORD;\n #else\n \t  int p = precop;"}, {"sha": "cc61d771efa0ec21a45d8b084bd087ec5481e5a1", "filename": "gcc/reload.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -1086,7 +1086,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t\t      && INTEGRAL_MODE_P (GET_MODE (SUBREG_REG (in)))\n \t\t      && LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (in))) != UNKNOWN)\n #endif\n-#ifdef WORD_REGISTER_OPERATIONS\n+#if WORD_REGISTER_OPERATIONS\n \t\t  || ((GET_MODE_PRECISION (inmode)\n \t\t       < GET_MODE_PRECISION (GET_MODE (SUBREG_REG (in))))\n \t\t      && ((GET_MODE_SIZE (inmode) - 1) / UNITS_PER_WORD ==\n@@ -1124,8 +1124,9 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n #endif\n       inloc = &SUBREG_REG (in);\n       in = *inloc;\n-#if ! defined (LOAD_EXTEND_OP) && ! defined (WORD_REGISTER_OPERATIONS)\n-      if (MEM_P (in))\n+#if ! defined (LOAD_EXTEND_OP)\n+      if (!WORD_REGISTER_OPERATIONS\n+\t  && MEM_P (in))\n \t/* This is supposed to happen only for paradoxical subregs made by\n \t   combine.c.  (SUBREG (MEM)) isn't supposed to occur other ways.  */\n \tgcc_assert (GET_MODE_SIZE (GET_MODE (in)) <= GET_MODE_SIZE (inmode));\n@@ -1186,7 +1187,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t       || MEM_P (SUBREG_REG (out)))\n \t      && ((GET_MODE_PRECISION (outmode)\n \t\t   > GET_MODE_PRECISION (GET_MODE (SUBREG_REG (out))))\n-#ifdef WORD_REGISTER_OPERATIONS\n+#if WORD_REGISTER_OPERATIONS\n \t\t  || ((GET_MODE_PRECISION (outmode)\n \t\t       < GET_MODE_PRECISION (GET_MODE (SUBREG_REG (out))))\n \t\t      && ((GET_MODE_SIZE (outmode) - 1) / UNITS_PER_WORD ==\n@@ -1220,11 +1221,9 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n #endif\n       outloc = &SUBREG_REG (out);\n       out = *outloc;\n-#if ! defined (LOAD_EXTEND_OP) && ! defined (WORD_REGISTER_OPERATIONS)\n-      gcc_assert (!MEM_P (out)\n+      gcc_assert (WORD_REGISTER_OPERATIONS || !MEM_P (out)\n \t\t  || GET_MODE_SIZE (GET_MODE (out))\n \t\t     <= GET_MODE_SIZE (outmode));\n-#endif\n       outmode = GET_MODE (out);\n     }\n \n@@ -3152,7 +3151,7 @@ find_reloads (rtx_insn *insn, int replace, int ind_levels, int live_known,\n \t\t      || ((MEM_P (operand)\n \t\t\t   || (REG_P (operand)\n \t\t\t       && REGNO (operand) >= FIRST_PSEUDO_REGISTER))\n-#ifndef WORD_REGISTER_OPERATIONS\n+#if !WORD_REGISTER_OPERATIONS\n \t\t\t  && (((GET_MODE_BITSIZE (GET_MODE (operand))\n \t\t\t\t< BIGGEST_ALIGNMENT)\n \t\t\t       && (GET_MODE_SIZE (operand_mode[i])\n@@ -6160,12 +6159,11 @@ find_reloads_subreg_address (rtx x, int opnum, enum reload_type type,\n   if (paradoxical_subreg_p (x))\n     return NULL;\n \n-#ifdef WORD_REGISTER_OPERATIONS\n-  if (GET_MODE_SIZE (outer_mode) < GET_MODE_SIZE (inner_mode)\n+  if (WORD_REGISTER_OPERATIONS\n+      && GET_MODE_SIZE (outer_mode) < GET_MODE_SIZE (inner_mode)\n       && ((GET_MODE_SIZE (outer_mode) - 1) / UNITS_PER_WORD\n           == (GET_MODE_SIZE (inner_mode) - 1) / UNITS_PER_WORD))\n     return NULL;\n-#endif\n \n   /* Since we don't attempt to handle paradoxical subregs, we can just\n      call into simplify_subreg, which will handle all remaining checks"}, {"sha": "5192a99a3cec71316b844fc642b25d5033fd0f2b", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -2862,7 +2862,7 @@ eliminate_regs_1 (rtx x, machine_mode mem_mode, rtx insn,\n \n \t  if (MEM_P (new_rtx)\n \t      && ((x_size < new_size\n-#ifdef WORD_REGISTER_OPERATIONS\n+#if WORD_REGISTER_OPERATIONS\n \t\t   /* On these machines, combine can create rtl of the form\n \t\t      (set (subreg:m1 (reg:m2 R) 0) ...)\n \t\t      where m1 < m2, and expects something interesting to"}, {"sha": "cb20c2537dcbe41609b68ce51f1cab4689105f0a", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -4253,15 +4253,16 @@ nonzero_bits1 (const_rtx x, machine_mode mode, const_rtx known_x,\n        just return the mode mask.  Those tests will then be false.  */\n     return nonzero;\n \n-#ifndef WORD_REGISTER_OPERATIONS\n   /* If MODE is wider than X, but both are a single word for both the host\n      and target machines, we can compute this from which bits of the\n      object might be nonzero in its own mode, taking into account the fact\n      that on many CISC machines, accessing an object in a wider mode\n      causes the high-order bits to become undefined.  So they are\n      not known to be zero.  */\n \n-  if (GET_MODE (x) != VOIDmode && GET_MODE (x) != mode\n+  if (!WORD_REGISTER_OPERATIONS\n+      && GET_MODE (x) != VOIDmode\n+      && GET_MODE (x) != mode\n       && GET_MODE_PRECISION (GET_MODE (x)) <= BITS_PER_WORD\n       && GET_MODE_PRECISION (GET_MODE (x)) <= HOST_BITS_PER_WIDE_INT\n       && GET_MODE_PRECISION (mode) > GET_MODE_PRECISION (GET_MODE (x)))\n@@ -4271,7 +4272,6 @@ nonzero_bits1 (const_rtx x, machine_mode mode, const_rtx known_x,\n       nonzero |= GET_MODE_MASK (mode) & ~GET_MODE_MASK (GET_MODE (x));\n       return nonzero;\n     }\n-#endif\n \n   code = GET_CODE (x);\n   switch (code)\n@@ -4543,7 +4543,7 @@ nonzero_bits1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \t  nonzero &= cached_nonzero_bits (SUBREG_REG (x), mode,\n \t\t\t\t\t  known_x, known_mode, known_ret);\n \n-#if defined (WORD_REGISTER_OPERATIONS) && defined (LOAD_EXTEND_OP)\n+#if WORD_REGISTER_OPERATIONS && defined (LOAD_EXTEND_OP)\n \t  /* If this is a typical RISC machine, we only have to worry\n \t     about the way loads are extended.  */\n \t  if ((LOAD_EXTEND_OP (inner_mode) == SIGN_EXTEND\n@@ -4763,12 +4763,12 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \n   if (GET_MODE (x) != VOIDmode && bitwidth > GET_MODE_PRECISION (GET_MODE (x)))\n     {\n-#ifndef WORD_REGISTER_OPERATIONS\n       /* If this machine does not do all register operations on the entire\n \t register and MODE is wider than the mode of X, we can say nothing\n \t at all about the high-order bits.  */\n-      return 1;\n-#else\n+      if (!WORD_REGISTER_OPERATIONS)\n+\treturn 1;\n+\n       /* Likewise on machines that do, if the mode of the object is smaller\n \t than a word and loads of that size don't sign extend, we can say\n \t nothing about the high order bits.  */\n@@ -4778,7 +4778,6 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n #endif\n \t  )\n \treturn 1;\n-#endif\n     }\n \n   switch (code)\n@@ -4857,7 +4856,6 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \t\t\t\t   - bitwidth)));\n \t}\n \n-#ifdef WORD_REGISTER_OPERATIONS\n #ifdef LOAD_EXTEND_OP\n       /* For paradoxical SUBREGs on machines where all register operations\n \t affect the entire register, just look inside.  Note that we are\n@@ -4869,12 +4867,12 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \t then we lose all sign bit copies that existed before the store\n \t to the stack.  */\n \n-      if (paradoxical_subreg_p (x)\n+      if (WORD_REGISTER_OPERATIONS\n+\t  && paradoxical_subreg_p (x)\n \t  && LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (x))) == SIGN_EXTEND\n \t  && MEM_P (SUBREG_REG (x)))\n \treturn cached_num_sign_bit_copies (SUBREG_REG (x), mode,\n \t\t\t\t\t   known_x, known_mode, known_ret);\n-#endif\n #endif\n       break;\n "}, {"sha": "aeca187d83fc82ff3dbe235520f100c3a3719cb7", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11bfef7abb096dc1e06f1d9391fc7aff6a7127/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=9e11bfef7abb096dc1e06f1d9391fc7aff6a7127", "patch": "@@ -673,9 +673,7 @@ simplify_truncation (machine_mode mode, rtx op,\n      the truncation, i.e. simplify (truncate:QI (op:SI (x:SI) (y:SI))) into\n      (op:QI (truncate:QI (x:SI)) (truncate:QI (y:SI))).  */\n   if (1\n-#ifdef WORD_REGISTER_OPERATIONS\n-      && precision >= BITS_PER_WORD\n-#endif\n+      && (!WORD_REGISTER_OPERATIONS || precision >= BITS_PER_WORD)\n       && (GET_CODE (op) == PLUS\n \t  || GET_CODE (op) == MINUS\n \t  || GET_CODE (op) == MULT))"}]}