{"sha": "464fc7a19978df2b22cf8683279cd1f14a161a6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY0ZmM3YTE5OTc4ZGYyYjIyY2Y4NjgzMjc5Y2QxZjE0YTE2MWE2ZQ==", "commit": {"author": {"name": "Gary Benson", "email": "gbenson@redhat.com", "date": "2006-07-28T10:54:11Z"}, "committer": {"name": "Gary Benson", "email": "gary@gcc.gnu.org", "date": "2006-07-28T10:54:11Z"}, "message": "re PR libgcj/13604 (AccessController unfinished)\n\n2006-07-28  Gary Benson  <gbenson@redhat.com>\n\t    Casey Marshall <csm@gnu.org>\n\n\tPR libgcj/13604:\n\t* include/java-stack.h (GetClassMethodStack): Declare.\n\t* stacktrace.cc (GetClassMethodStack): New method.\n\t* java/security/AccessController.java: Removed.\n\t* java/security/VMAccessController.java: New file.\n\t* java/security/natVMAccessController.cc: Likewise.\n\t* Makefile.am (nat_source_files): Added the above.\n\t* sources.am, Makefile.in: Rebuilt.\n\n\nCo-Authored-By: Casey Marshall <csm@gnu.org>\n\nFrom-SVN: r115793", "tree": {"sha": "330a292f4d8ffc6685638990777d68888da955c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/330a292f4d8ffc6685638990777d68888da955c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/464fc7a19978df2b22cf8683279cd1f14a161a6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/464fc7a19978df2b22cf8683279cd1f14a161a6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/464fc7a19978df2b22cf8683279cd1f14a161a6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/464fc7a19978df2b22cf8683279cd1f14a161a6e/comments", "author": null, "committer": null, "parents": [{"sha": "99460c7e0f5b0e6dbeb5cf5aa4fb32b0c0350454", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99460c7e0f5b0e6dbeb5cf5aa4fb32b0c0350454", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99460c7e0f5b0e6dbeb5cf5aa4fb32b0c0350454"}], "stats": {"total": 623, "additions": 414, "deletions": 209}, "files": [{"sha": "e73c3e5956aaba4bf32dc8f5341b611d0936df10", "filename": "libjava/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464fc7a19978df2b22cf8683279cd1f14a161a6e/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464fc7a19978df2b22cf8683279cd1f14a161a6e/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=464fc7a19978df2b22cf8683279cd1f14a161a6e", "patch": "@@ -1,3 +1,15 @@\n+2006-07-28  Gary Benson  <gbenson@redhat.com>\n+\t    Casey Marshall <csm@gnu.org>\n+\n+\tPR libgcj/13604:\n+\t* include/java-stack.h (GetClassMethodStack): Declare.\n+\t* stacktrace.cc (GetClassMethodStack): New method.\n+\t* java/security/AccessController.java: Removed.\n+\t* java/security/VMAccessController.java: New file.\n+\t* java/security/natVMAccessController.cc: Likewise.\n+\t* Makefile.am (nat_source_files): Added the above.\n+\t* sources.am, Makefile.in: Rebuilt.\n+\n 2006-07-28  Gary Benson  <gbenson@redhat.com>\n \n \t* java/lang/SecurityManager.java (currentClassLoader,"}, {"sha": "45a493039ec7b135e9a05214c8964f5bfd444c33", "filename": "libjava/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464fc7a19978df2b22cf8683279cd1f14a161a6e/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464fc7a19978df2b22cf8683279cd1f14a161a6e/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=464fc7a19978df2b22cf8683279cd1f14a161a6e", "patch": "@@ -826,6 +826,7 @@ java/net/natVMNetworkInterface.cc \\\n java/net/natInetAddress.cc \\\n java/nio/channels/natVMChannels.cc \\\n java/nio/natDirectByteBufferImpl.cc \\\n+java/security/natVMAccessController.cc \\\n java/text/natCollator.cc \\\n java/util/natResourceBundle.cc \\\n java/util/natVMTimeZone.cc \\"}, {"sha": "631ebb87b89775e40c66e6dc5780ebf1cf575d1d", "filename": "libjava/Makefile.in", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464fc7a19978df2b22cf8683279cd1f14a161a6e/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464fc7a19978df2b22cf8683279cd1f14a161a6e/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=464fc7a19978df2b22cf8683279cd1f14a161a6e", "patch": "@@ -287,12 +287,13 @@ am__libgcj_la_SOURCES_DIST = prims.cc jni.cc jvmti.cc exception.cc \\\n \tjava/lang/reflect/natField.cc java/lang/reflect/natMethod.cc \\\n \tjava/net/natVMNetworkInterface.cc java/net/natInetAddress.cc \\\n \tjava/nio/channels/natVMChannels.cc \\\n-\tjava/nio/natDirectByteBufferImpl.cc java/text/natCollator.cc \\\n-\tjava/util/natResourceBundle.cc java/util/natVMTimeZone.cc \\\n-\tjava/util/logging/natLogger.cc java/util/zip/natDeflater.cc \\\n-\tjava/util/zip/natInflater.cc boehm.cc nogc.cc posix.cc \\\n-\twin32.cc darwin.cc posix-threads.cc win32-threads.cc \\\n-\tno-threads.cc\n+\tjava/nio/natDirectByteBufferImpl.cc \\\n+\tjava/security/natVMAccessController.cc \\\n+\tjava/text/natCollator.cc java/util/natResourceBundle.cc \\\n+\tjava/util/natVMTimeZone.cc java/util/logging/natLogger.cc \\\n+\tjava/util/zip/natDeflater.cc java/util/zip/natInflater.cc \\\n+\tboehm.cc nogc.cc posix.cc win32.cc darwin.cc posix-threads.cc \\\n+\twin32-threads.cc no-threads.cc\n am__objects_2 = gnu/classpath/natSystemProperties.lo \\\n \tgnu/gcj/natCore.lo gnu/gcj/convert/JIS0208_to_Unicode.lo \\\n \tgnu/gcj/convert/JIS0212_to_Unicode.lo \\\n@@ -328,10 +329,11 @@ am__objects_2 = gnu/classpath/natSystemProperties.lo \\\n \tjava/lang/reflect/natField.lo java/lang/reflect/natMethod.lo \\\n \tjava/net/natVMNetworkInterface.lo java/net/natInetAddress.lo \\\n \tjava/nio/channels/natVMChannels.lo \\\n-\tjava/nio/natDirectByteBufferImpl.lo java/text/natCollator.lo \\\n-\tjava/util/natResourceBundle.lo java/util/natVMTimeZone.lo \\\n-\tjava/util/logging/natLogger.lo java/util/zip/natDeflater.lo \\\n-\tjava/util/zip/natInflater.lo\n+\tjava/nio/natDirectByteBufferImpl.lo \\\n+\tjava/security/natVMAccessController.lo \\\n+\tjava/text/natCollator.lo java/util/natResourceBundle.lo \\\n+\tjava/util/natVMTimeZone.lo java/util/logging/natLogger.lo \\\n+\tjava/util/zip/natDeflater.lo java/util/zip/natInflater.lo\n @USING_BOEHMGC_TRUE@am__objects_3 = boehm.lo\n @USING_NOGC_TRUE@am__objects_4 = nogc.lo\n @USING_POSIX_PLATFORM_TRUE@am__objects_5 = posix.lo\n@@ -616,6 +618,7 @@ bindir = @bindir@\n build = @build@\n build_alias = @build_alias@\n build_cpu = @build_cpu@\n+build_libsubdir = @build_libsubdir@\n build_os = @build_os@\n build_subdir = @build_subdir@\n build_vendor = @build_vendor@\n@@ -4158,7 +4161,7 @@ java_rmi_server_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(\n java_security_source_files = \\\n classpath/java/security/AccessControlContext.java \\\n classpath/java/security/AccessControlException.java \\\n-java/security/AccessController.java \\\n+classpath/java/security/AccessController.java \\\n classpath/java/security/AlgorithmParameterGenerator.java \\\n classpath/java/security/AlgorithmParameterGeneratorSpi.java \\\n classpath/java/security/AlgorithmParameters.java \\\n@@ -4223,6 +4226,7 @@ classpath/java/security/SignedObject.java \\\n classpath/java/security/Signer.java \\\n classpath/java/security/UnrecoverableKeyException.java \\\n classpath/java/security/UnresolvedPermission.java \\\n+java/security/VMAccessController.java \\\n java/security/VMSecureRandom.java\n \n java_security_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(java_security_source_files)))\n@@ -7136,6 +7140,7 @@ java/net/natVMNetworkInterface.cc \\\n java/net/natInetAddress.cc \\\n java/nio/channels/natVMChannels.cc \\\n java/nio/natDirectByteBufferImpl.cc \\\n+java/security/natVMAccessController.cc \\\n java/text/natCollator.cc \\\n java/util/natResourceBundle.cc \\\n java/util/natVMTimeZone.cc \\\n@@ -7625,6 +7630,14 @@ java/nio/$(DEPDIR)/$(am__dirstamp):\n \t@: > java/nio/$(DEPDIR)/$(am__dirstamp)\n java/nio/natDirectByteBufferImpl.lo: java/nio/$(am__dirstamp) \\\n \tjava/nio/$(DEPDIR)/$(am__dirstamp)\n+java/security/$(am__dirstamp):\n+\t@$(mkdir_p) java/security\n+\t@: > java/security/$(am__dirstamp)\n+java/security/$(DEPDIR)/$(am__dirstamp):\n+\t@$(mkdir_p) java/security/$(DEPDIR)\n+\t@: > java/security/$(DEPDIR)/$(am__dirstamp)\n+java/security/natVMAccessController.lo: java/security/$(am__dirstamp) \\\n+\tjava/security/$(DEPDIR)/$(am__dirstamp)\n java/text/$(am__dirstamp):\n \t@$(mkdir_p) java/text\n \t@: > java/text/$(am__dirstamp)\n@@ -7926,6 +7939,8 @@ mostlyclean-compile:\n \t-rm -f java/nio/channels/natVMChannels.lo\n \t-rm -f java/nio/natDirectByteBufferImpl.$(OBJEXT)\n \t-rm -f java/nio/natDirectByteBufferImpl.lo\n+\t-rm -f java/security/natVMAccessController.$(OBJEXT)\n+\t-rm -f java/security/natVMAccessController.lo\n \t-rm -f java/text/natCollator.$(OBJEXT)\n \t-rm -f java/text/natCollator.lo\n \t-rm -f java/util/logging/natLogger.$(OBJEXT)\n@@ -8042,6 +8057,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@java/net/$(DEPDIR)/natVMNetworkInterface.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/nio/$(DEPDIR)/natDirectByteBufferImpl.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/nio/channels/$(DEPDIR)/natVMChannels.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@java/security/$(DEPDIR)/natVMAccessController.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/text/$(DEPDIR)/natCollator.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/util/$(DEPDIR)/natResourceBundle.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/util/$(DEPDIR)/natVMTimeZone.Plo@am__quote@\n@@ -8317,6 +8333,7 @@ clean-libtool:\n \t-rm -rf java/net/.libs java/net/_libs\n \t-rm -rf java/nio/.libs java/nio/_libs\n \t-rm -rf java/nio/channels/.libs java/nio/channels/_libs\n+\t-rm -rf java/security/.libs java/security/_libs\n \t-rm -rf java/text/.libs java/text/_libs\n \t-rm -rf java/util/.libs java/util/_libs\n \t-rm -rf java/util/logging/.libs java/util/logging/_libs\n@@ -8739,6 +8756,8 @@ distclean-generic:\n \t-rm -f java/nio/$(am__dirstamp)\n \t-rm -f java/nio/channels/$(DEPDIR)/$(am__dirstamp)\n \t-rm -f java/nio/channels/$(am__dirstamp)\n+\t-rm -f java/security/$(DEPDIR)/$(am__dirstamp)\n+\t-rm -f java/security/$(am__dirstamp)\n \t-rm -f java/text/$(DEPDIR)/$(am__dirstamp)\n \t-rm -f java/text/$(am__dirstamp)\n \t-rm -f java/util/$(DEPDIR)/$(am__dirstamp)\n@@ -8760,7 +8779,7 @@ clean-am: clean-binPROGRAMS clean-dbexecLTLIBRARIES clean-generic \\\n \n distclean: distclean-recursive\n \t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -rf ./$(DEPDIR) classpath/tools/$(DEPDIR) gnu/classpath/$(DEPDIR) gnu/gcj/$(DEPDIR) gnu/gcj/convert/$(DEPDIR) gnu/gcj/io/$(DEPDIR) gnu/gcj/runtime/$(DEPDIR) gnu/gcj/tools/gcj_dbtool/$(DEPDIR) gnu/gcj/util/$(DEPDIR) gnu/gcj/xlib/$(DEPDIR) gnu/java/lang/$(DEPDIR) gnu/java/net/$(DEPDIR) gnu/java/net/protocol/core/$(DEPDIR) gnu/java/nio/$(DEPDIR) gnu/java/nio/channels/$(DEPDIR) java/io/$(DEPDIR) java/lang/$(DEPDIR) java/lang/ref/$(DEPDIR) java/lang/reflect/$(DEPDIR) java/net/$(DEPDIR) java/nio/$(DEPDIR) java/nio/channels/$(DEPDIR) java/text/$(DEPDIR) java/util/$(DEPDIR) java/util/logging/$(DEPDIR) java/util/zip/$(DEPDIR)\n+\t-rm -rf ./$(DEPDIR) classpath/tools/$(DEPDIR) gnu/classpath/$(DEPDIR) gnu/gcj/$(DEPDIR) gnu/gcj/convert/$(DEPDIR) gnu/gcj/io/$(DEPDIR) gnu/gcj/runtime/$(DEPDIR) gnu/gcj/tools/gcj_dbtool/$(DEPDIR) gnu/gcj/util/$(DEPDIR) gnu/gcj/xlib/$(DEPDIR) gnu/java/lang/$(DEPDIR) gnu/java/net/$(DEPDIR) gnu/java/net/protocol/core/$(DEPDIR) gnu/java/nio/$(DEPDIR) gnu/java/nio/channels/$(DEPDIR) java/io/$(DEPDIR) java/lang/$(DEPDIR) java/lang/ref/$(DEPDIR) java/lang/reflect/$(DEPDIR) java/net/$(DEPDIR) java/nio/$(DEPDIR) java/nio/channels/$(DEPDIR) java/security/$(DEPDIR) java/text/$(DEPDIR) java/util/$(DEPDIR) java/util/logging/$(DEPDIR) java/util/zip/$(DEPDIR)\n \t-rm -f Makefile\n distclean-am: clean-am distclean-compile distclean-generic \\\n \tdistclean-libtool distclean-local distclean-tags\n@@ -8791,7 +8810,7 @@ installcheck-am:\n maintainer-clean: maintainer-clean-recursive\n \t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n \t-rm -rf $(top_srcdir)/autom4te.cache\n-\t-rm -rf ./$(DEPDIR) classpath/tools/$(DEPDIR) gnu/classpath/$(DEPDIR) gnu/gcj/$(DEPDIR) gnu/gcj/convert/$(DEPDIR) gnu/gcj/io/$(DEPDIR) gnu/gcj/runtime/$(DEPDIR) gnu/gcj/tools/gcj_dbtool/$(DEPDIR) gnu/gcj/util/$(DEPDIR) gnu/gcj/xlib/$(DEPDIR) gnu/java/lang/$(DEPDIR) gnu/java/net/$(DEPDIR) gnu/java/net/protocol/core/$(DEPDIR) gnu/java/nio/$(DEPDIR) gnu/java/nio/channels/$(DEPDIR) java/io/$(DEPDIR) java/lang/$(DEPDIR) java/lang/ref/$(DEPDIR) java/lang/reflect/$(DEPDIR) java/net/$(DEPDIR) java/nio/$(DEPDIR) java/nio/channels/$(DEPDIR) java/text/$(DEPDIR) java/util/$(DEPDIR) java/util/logging/$(DEPDIR) java/util/zip/$(DEPDIR)\n+\t-rm -rf ./$(DEPDIR) classpath/tools/$(DEPDIR) gnu/classpath/$(DEPDIR) gnu/gcj/$(DEPDIR) gnu/gcj/convert/$(DEPDIR) gnu/gcj/io/$(DEPDIR) gnu/gcj/runtime/$(DEPDIR) gnu/gcj/tools/gcj_dbtool/$(DEPDIR) gnu/gcj/util/$(DEPDIR) gnu/gcj/xlib/$(DEPDIR) gnu/java/lang/$(DEPDIR) gnu/java/net/$(DEPDIR) gnu/java/net/protocol/core/$(DEPDIR) gnu/java/nio/$(DEPDIR) gnu/java/nio/channels/$(DEPDIR) java/io/$(DEPDIR) java/lang/$(DEPDIR) java/lang/ref/$(DEPDIR) java/lang/reflect/$(DEPDIR) java/net/$(DEPDIR) java/nio/$(DEPDIR) java/nio/channels/$(DEPDIR) java/security/$(DEPDIR) java/text/$(DEPDIR) java/util/$(DEPDIR) java/util/logging/$(DEPDIR) java/util/zip/$(DEPDIR)\n \t-rm -f Makefile\n maintainer-clean-am: distclean-am maintainer-clean-generic\n "}, {"sha": "a1b0db670ea157436b624dfdd1441ce7d3d5e918", "filename": "libjava/include/java-stack.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464fc7a19978df2b22cf8683279cd1f14a161a6e/libjava%2Finclude%2Fjava-stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464fc7a19978df2b22cf8683279cd1f14a161a6e/libjava%2Finclude%2Fjava-stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-stack.h?ref=464fc7a19978df2b22cf8683279cd1f14a161a6e", "patch": "@@ -124,6 +124,7 @@ class _Jv_StackTrace\n   static void GetCallerInfo (jclass checkClass, jclass *, _Jv_Method **);\n   static JArray<jclass> *GetClassContext (jclass checkClass);\n   static ClassLoader *GetFirstNonSystemClassLoader (void);\n+  static JArray<jobjectArray> *GetClassMethodStack (_Jv_StackTrace *trace);\n   \n };\n "}, {"sha": "4f40edbcf467de006fb618018296cf17cb66f25c", "filename": "libjava/java/security/AccessController.java", "status": "removed", "additions": 0, "deletions": 195, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99460c7e0f5b0e6dbeb5cf5aa4fb32b0c0350454/libjava%2Fjava%2Fsecurity%2FAccessController.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99460c7e0f5b0e6dbeb5cf5aa4fb32b0c0350454/libjava%2Fjava%2Fsecurity%2FAccessController.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FAccessController.java?ref=99460c7e0f5b0e6dbeb5cf5aa4fb32b0c0350454", "patch": "@@ -1,195 +0,0 @@\n-/* AccessController.java --- Access control context and permission checker\n-   Copyright (C) 2001, 2004  Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-package java.security;\n-\n-/**\n- * Access control context and permission checker.\n- * Can check permissions in the access control context of the current thread\n- * through the <code>checkPermission()</code> method.\n- * Manipulates the access control context for code that needs to be executed\n- * the protection domain of the calling class (by explicitly ignoring the\n- * context of the calling code) in the <code>doPrivileged()</code> methods.\n- * And provides a <code>getContext()</code> method which gives the access\n- * control context of the current thread that can be used for checking\n- * permissions at a later time and/or in another thread.\n- * <p>\n- * XXX - Mostly a stub implementation at the moment. Needs native support\n- * from the VM to function correctly. XXX - Do not forget to think about\n- * how to handle <code>java.lang.reflect.Method.invoke()</code> on the\n- * <code>doPrivileged()</code> methods.\n- *\n- * @author Mark Wielaard (mark@klomp.org)\n- * @since 1.2\n- */\n-public final class AccessController\n-{\n-  /**\n-   * This class only has static methods so there is no public contructor.\n-   */\n-  private AccessController()\n-  {\n-  }\n-\n-  /**\n-   * Checks wether the access control context of the current thread allows\n-   * the given Permission. Throws an <code>AccessControlException</code>\n-   * when the permission is not allowed in the current context. Otherwise\n-   * returns silently without throwing an exception.\n-   *\n-   * @param perm the permission to be checked.\n-   * @exception AccessControlException thrown if the current context does not\n-   * allow the given permission.\n-   */\n-  public static void checkPermission(Permission perm)\n-    throws AccessControlException\n-  {\n-    getContext().checkPermission(perm);\n-  }\n-\n-  /**\n-   * Calls the <code>run()</code> method of the given action with as\n-   * (initial) access control context only the protection domain of the\n-   * calling class. Calls to <code>checkPermission()</code> in the\n-   * <code>run()</code> method ignore all earlier protection domains of\n-   * classes in the call chain. Note that the protection domains of classes\n-   * called by the code in the <code>run()</code> method are not ignored.\n-   *\n-   * @param action the <code>PrivilegedAction</code> whose <code>run()</code>\n-   * should be be called.\n-   * @return the result of the <code>action.run()</code> method.\n-   */\n-  public static Object doPrivileged(PrivilegedAction action)\n-  {\n-    return action.run();\n-  }\n-\n-  /**\n-   * Calls the <code>run()</code> method of the given action with as\n-   * (initial) access control context the given context combined with the\n-   * protection domain of the calling class. Calls to\n-   * <code>checkPermission()</code> in the <code>run()</code> method ignore\n-   * all earlier protection domains of classes in the call chain, but add\n-   * checks for the protection domains given in the supplied context.\n-   *\n-   * @param action the <code>PrivilegedAction</code> whose <code>run()</code>\n-   * should be be called.\n-   * @param context the <code>AccessControlContext</code> whose protection\n-   * domains should be added to the protection domain of the calling class.\n-   * @return the result of the <code>action.run()</code> method.\n-   */\n-  public static Object doPrivileged(PrivilegedAction action,\n-                                    AccessControlContext context)\n-  {\n-    return action.run();\n-  }\n-\n-  /**\n-   * Calls the <code>run()</code> method of the given action with as\n-   * (initial) access control context only the protection domain of the\n-   * calling class. Calls to <code>checkPermission()</code> in the\n-   * <code>run()</code> method ignore all earlier protection domains of\n-   * classes in the call chain. Note that the protection domains of classes\n-   * called by the code in the <code>run()</code> method are not ignored.\n-   * If the <code>run()</code> method throws an exception then this method\n-   * will wrap that exception in an <code>PrivilegedActionException</code>.\n-   *\n-   * @param action the <code>PrivilegedExceptionAction</code> whose\n-   * <code>run()</code> should be be called.\n-   * @return the result of the <code>action.run()</code> method.\n-   * @exception PrivilegedActionException wrapped around any exception that\n-   * is thrown in the <code>run()</code> method.\n-   */\n-  public static Object doPrivileged(PrivilegedExceptionAction action)\n-    throws PrivilegedActionException\n-  {\n-    try\n-      {\n-        return action.run();\n-      }\n-    catch (Exception e)\n-      {\n-        throw new PrivilegedActionException(e);\n-      }\n-  }\n-\n-  /**\n-   * Calls the <code>run()</code> method of the given action with as\n-   * (initial) access control context the given context combined with the\n-   * protection domain of the calling class. Calls to\n-   * <code>checkPermission()</code> in the <code>run()</code> method ignore\n-   * all earlier protection domains of classes in the call chain, but add\n-   * checks for the protection domains given in the supplied context.\n-   * If the <code>run()</code> method throws an exception then this method\n-   * will wrap that exception in an <code>PrivilegedActionException</code>.\n-   *\n-   * @param action the <code>PrivilegedExceptionAction</code> whose\n-   * <code>run()</code> should be be called.\n-   * @param context the <code>AccessControlContext</code> whose protection\n-   * domains should be added to the protection domain of the calling class.\n-   * @return the result of the <code>action.run()</code> method.\n-   * @exception PrivilegedActionException wrapped around any exception that\n-   * is thrown in the <code>run()</code> method.\n-   */\n-  public static Object doPrivileged(PrivilegedExceptionAction action,\n-                                    AccessControlContext context)\n-    throws PrivilegedActionException\n-  {\n-    try\n-      {\n-        return action.run();\n-      }\n-    catch (Exception e)\n-      {\n-        throw new PrivilegedActionException(e);\n-      }\n-  }\n-\n-  /**\n-   * Returns the complete access control context of the current thread.\n-   * <p>\n-   * XXX - Should this include all the protection domains in the call chain\n-   * or only the domains till the last <code>doPrivileged()</code> call?\n-   * <p>\n-   * XXX - needs native support. Currently returns an empty context.\n-   */\n-  public static AccessControlContext getContext()\n-  {\n-    // For now just return an new empty context\n-    return new AccessControlContext(new ProtectionDomain[0]);\n-  }\n-}"}, {"sha": "dfbd16f693b4377e15b83de7fbce81fc8e30e37a", "filename": "libjava/java/security/VMAccessController.java", "status": "added", "additions": 294, "deletions": 0, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464fc7a19978df2b22cf8683279cd1f14a161a6e/libjava%2Fjava%2Fsecurity%2FVMAccessController.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464fc7a19978df2b22cf8683279cd1f14a161a6e/libjava%2Fjava%2Fsecurity%2FVMAccessController.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FVMAccessController.java?ref=464fc7a19978df2b22cf8683279cd1f14a161a6e", "patch": "@@ -0,0 +1,294 @@\n+/* VMAccessController.java -- VM-specific access controller methods.\n+   Copyright (C) 2004, 2005, 2006  Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+This program is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.security;\n+\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+\n+final class VMAccessController\n+{\n+\n+  // Fields.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * This is a per-thread stack of AccessControlContext objects (which can\n+   * be null) for each call to AccessController.doPrivileged in each thread's\n+   * call stack. We use this to remember which context object corresponds to\n+   * which call.\n+   */\n+  private static final ThreadLocal contexts = new ThreadLocal();\n+\n+  /**\n+   * This is a Boolean that, if set, tells getContext that it has already\n+   * been called once, allowing us to handle recursive permission checks\n+   * caused by methods getContext calls.\n+   */\n+  private static final ThreadLocal inGetContext = new ThreadLocal();\n+\n+  /**\n+   * And we return this all-permissive context to ensure that privileged\n+   * methods called from getContext succeed.\n+   */\n+  private static final AccessControlContext DEFAULT_CONTEXT;\n+  static\n+  {\n+    CodeSource source = new CodeSource(null, null);\n+    Permissions permissions = new Permissions();\n+    permissions.add(new AllPermission());\n+    ProtectionDomain[] domain = new ProtectionDomain[] {\n+      new ProtectionDomain(source, permissions)\n+    };\n+    DEFAULT_CONTEXT = new AccessControlContext(domain);\n+  }\n+\n+  private static final boolean DEBUG = gnu.classpath.Configuration.DEBUG;\n+  private static void debug(String msg)\n+  {\n+    System.err.print(\">>> VMAccessController: \");\n+    System.err.println(msg);\n+  }\n+\n+  // Constructors.\n+  // -------------------------------------------------------------------------\n+\n+  private VMAccessController() { }\n+\n+  // Class methods.\n+  // -------------------------------------------------------------------------\n+\n+  /**\n+   * Relate a class (which should be an instance of {@link PrivilegedAction}\n+   * with an access control context. This method is used by {@link\n+   * AccessController#doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)}\n+   * to set up the context that will be returned by {@link #getContext()}.\n+   * This method relates the class to the current thread, so contexts\n+   * pushed from one thread will not be available to another.\n+   *\n+   * @param acc The access control context.\n+   */\n+  static void pushContext (AccessControlContext acc)\n+  {\n+    if (!runtimeInitialized())\n+      return;\n+\n+    if (DEBUG)\n+      debug(\"pushing \" + acc);\n+    LinkedList stack = (LinkedList) contexts.get();\n+    if (stack == null)\n+      {\n+         if (DEBUG)\n+           debug(\"no stack... creating \");\n+        stack = new LinkedList();\n+        contexts.set(stack);\n+      }\n+    stack.addFirst(acc);\n+  }\n+\n+  /**\n+   * Removes the relation of a class to an {@link AccessControlContext}.\n+   * This method is used by {@link AccessController} when exiting from a\n+   * call to {@link\n+   * AccessController#doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)}.\n+   */\n+  static void popContext()\n+  {\n+    if (!runtimeInitialized())\n+      return;\n+\n+    if (DEBUG)\n+      debug(\"popping context\");\n+\n+    // Stack should never be null, nor should it be empty, if this method\n+    // and its counterpart has been called properly.\n+    LinkedList stack = (LinkedList) contexts.get();\n+    if (stack != null)\n+      {\n+        stack.removeFirst();\n+        if (stack.isEmpty())\n+          contexts.set(null);\n+      }\n+    else if (DEBUG)\n+      {\n+        debug(\"no stack during pop?????\");\n+      }\n+  }\n+\n+  /**\n+   * Examine the method stack of the currently running thread, and create\n+   * an {@link AccessControlContext} filled in with the appropriate {@link\n+   * ProtectionDomain} objects given this stack.\n+   *\n+   * @return The context.\n+   */\n+  static AccessControlContext getContext()\n+  {\n+    // If the VM is initializing return the all-permissive context\n+    // so that any security checks succeed.\n+    //\n+    // XXX this might not be necessary, but it seems prudent.\n+    if (!runtimeInitialized())\n+      return DEFAULT_CONTEXT;\n+\n+    // If we are already in getContext, but called a method that needs\n+    // a permission check, return the all-permissive context so methods\n+    // called from here succeed.\n+    //\n+    // XXX is this necessary? We should verify if there are any calls in\n+    // the stack below this method that require permission checks.\n+    Boolean inCall = (Boolean) inGetContext.get();\n+    if (inCall != null && inCall.booleanValue())\n+      {\n+        if (DEBUG)\n+          debug(\"already in getContext\");\n+        return DEFAULT_CONTEXT;\n+      }\n+\n+    inGetContext.set(Boolean.TRUE);\n+\n+    Object[][] stack = getStack();\n+    Class[] classes = (Class[]) stack[0];\n+    String[] methods = (String[]) stack[1];\n+\n+    if (DEBUG)\n+      debug(\"got trace of length \" + classes.length);\n+\n+    HashSet domains = new HashSet();\n+    HashSet seenDomains = new HashSet();\n+    AccessControlContext context = null;\n+    int privileged = 0;\n+\n+    // We walk down the stack, adding each ProtectionDomain for each\n+    // class in the call stack. If we reach a call to doPrivileged,\n+    // we don't add any more stack frames. We skip the first three stack\n+    // frames, since they comprise the calls to getStack, getContext,\n+    // and AccessController.getContext.\n+    for (int i = 3; i < classes.length && privileged < 2; i++)\n+      {\n+        Class clazz = classes[i];\n+        String method = methods[i];\n+\n+        if (DEBUG)\n+          {\n+            debug(\"checking \" + clazz + \".\" + method);\n+            // subject to getClassLoader RuntimePermission\n+            debug(\"loader = \" + clazz.getClassLoader());\n+          }\n+\n+        // If the previous frame was a call to doPrivileged, then this is\n+        // the last frame we look at.\n+        if (privileged == 1)\n+          privileged = 2;\n+\n+        if (clazz.equals (AccessController.class)\n+            && method.equals (\"doPrivileged\"))\n+          {\n+            // If there was a call to doPrivileged with a supplied context,\n+            // return that context. If using JAAS doAs*, it should be \n+\t    // a context with a SubjectDomainCombiner\n+            LinkedList l = (LinkedList) contexts.get();\n+            if (l != null)\n+              context = (AccessControlContext) l.getFirst();\n+            privileged = 1;\n+          }\n+\n+        // subject to getProtectionDomain RuntimePermission\n+\tProtectionDomain domain = clazz.getProtectionDomain();\n+\n+        if (domain == null)\n+          continue;\n+        if (seenDomains.contains(domain))\n+          continue;\n+        seenDomains.add(domain);\n+\n+        // Create a static snapshot of this domain, which may change over time\n+        // if the current policy changes.\n+        domains.add(new ProtectionDomain(domain.getCodeSource(),\n+                                         domain.getPermissions()));\n+      }\n+\n+    if (DEBUG)\n+      debug(\"created domains: \" + domains);\n+\n+    ProtectionDomain[] result = (ProtectionDomain[])\n+      domains.toArray(new ProtectionDomain[domains.size()]);\n+\n+    if (context != null)\n+      {\n+        DomainCombiner dc = context.getDomainCombiner ();\n+        // If the supplied context had no explicit DomainCombiner, use\n+        // our private version, which computes the intersection of the\n+        // context's domains with the derived set.\n+        if (dc == null)\n+          context = new AccessControlContext\n+            (IntersectingDomainCombiner.SINGLETON.combine\n+             (result, context.getProtectionDomains ()));\n+        // Use the supplied DomainCombiner. This should be secure,\n+        // because only trusted code may create an\n+        // AccessControlContext with a custom DomainCombiner.\n+        else\n+          context = new AccessControlContext (result, context, dc);\n+      }\n+    // No context was supplied. Return the derived one.\n+    else\n+      context = new AccessControlContext (result);\n+\n+    inGetContext.set(Boolean.FALSE);\n+    return context;\n+  }\n+\n+  /**\n+   * Returns a snapshot of the current call stack as a pair of arrays:\n+   * the first an array of classes in the call stack, the second an array\n+   * of strings containing the method names in the call stack. The two\n+   * arrays match up, meaning that method <i>i</i> is declared in class\n+   * <i>i</i>. The arrays are clean; it will only contain Java methods,\n+   * and no element of the list should be null.\n+   *\n+   * @return A pair of arrays describing the current call stack. The first\n+   *    element is an array of Class objects, and the second is an array\n+   *    of Strings comprising the method names.\n+   */\n+  private static native Object[][] getStack();\n+\n+  /**\n+   * Tell whether runtime initialization is complete.\n+   *\n+   * @return whether runtime initialization is complete.\n+   */\n+  private static native boolean runtimeInitialized();\n+}"}, {"sha": "255034532848e7b60ff7ed29de3f55d6c86c7e7a", "filename": "libjava/java/security/natVMAccessController.cc", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464fc7a19978df2b22cf8683279cd1f14a161a6e/libjava%2Fjava%2Fsecurity%2FnatVMAccessController.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464fc7a19978df2b22cf8683279cd1f14a161a6e/libjava%2Fjava%2Fsecurity%2FnatVMAccessController.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FnatVMAccessController.cc?ref=464fc7a19978df2b22cf8683279cd1f14a161a6e", "patch": "@@ -0,0 +1,30 @@\n+// natVMAccessController.cc -- Native part of the VMAccessController class.\n+\n+/* Copyright (C) 2006 Free Software Foundation, Inc.\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <config.h>\n+\n+#include <gcj/cni.h>\n+#include <jvm.h>\n+#include <java-stack.h>\n+\n+#include <java/security/VMAccessController.h>\n+\n+JArray<jobjectArray> *\n+java::security::VMAccessController::getStack ()\n+{\n+  _Jv_StackTrace *trace = _Jv_StackTrace::GetStackTrace ();\n+  return _Jv_StackTrace::GetClassMethodStack (trace);\n+}\n+\n+jboolean\n+java::security::VMAccessController::runtimeInitialized ()\n+{\n+  return gcj::runtimeInitialized;\n+}"}, {"sha": "1b1ed620edf5a344939a0fd34b3a7cab759daa73", "filename": "libjava/sources.am", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464fc7a19978df2b22cf8683279cd1f14a161a6e/libjava%2Fsources.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464fc7a19978df2b22cf8683279cd1f14a161a6e/libjava%2Fsources.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsources.am?ref=464fc7a19978df2b22cf8683279cd1f14a161a6e", "patch": "@@ -5265,7 +5265,7 @@ java/rmi/server.list: $(java_rmi_server_source_files)\n java_security_source_files = \\\n classpath/java/security/AccessControlContext.java \\\n classpath/java/security/AccessControlException.java \\\n-java/security/AccessController.java \\\n+classpath/java/security/AccessController.java \\\n classpath/java/security/AlgorithmParameterGenerator.java \\\n classpath/java/security/AlgorithmParameterGeneratorSpi.java \\\n classpath/java/security/AlgorithmParameters.java \\\n@@ -5330,6 +5330,7 @@ classpath/java/security/SignedObject.java \\\n classpath/java/security/Signer.java \\\n classpath/java/security/UnrecoverableKeyException.java \\\n classpath/java/security/UnresolvedPermission.java \\\n+java/security/VMAccessController.java \\\n java/security/VMSecureRandom.java\n \n java_security_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(java_security_source_files)))"}, {"sha": "843c5124e7e2ee949a75aa4f78b4a259aed89a28", "filename": "libjava/stacktrace.cc", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/464fc7a19978df2b22cf8683279cd1f14a161a6e/libjava%2Fstacktrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/464fc7a19978df2b22cf8683279cd1f14a161a6e/libjava%2Fstacktrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fstacktrace.cc?ref=464fc7a19978df2b22cf8683279cd1f14a161a6e", "patch": "@@ -534,3 +534,45 @@ _Jv_StackTrace::GetFirstNonSystemClassLoader ()\n   \n   return NULL;\n }\n+\n+JArray<jobjectArray> *\n+_Jv_StackTrace::GetClassMethodStack (_Jv_StackTrace *trace)\n+{\n+  jint length = 0;\n+\n+  UpdateNCodeMap();\n+  for (int i = 0; i < trace->length; i++)\n+    {\n+      _Jv_StackFrame *frame = &trace->frames[i];\n+      FillInFrameInfo (frame);\n+\n+      if (frame->klass && frame->meth)\n+\tlength++;\n+    }\n+\n+  jclass array_class = _Jv_GetArrayClass (&::java::lang::Object::class$, NULL);\n+  JArray<jobjectArray> *result =\n+    (JArray<jobjectArray> *) _Jv_NewObjectArray (2, array_class, NULL);\n+  JArray<jclass> *classes = (JArray<jclass> *)\n+    _Jv_NewObjectArray (length, &::java::lang::Class::class$, NULL);\n+  JArray<jstring> *methods = (JArray<jstring> *)\n+    _Jv_NewObjectArray (length, &::java::lang::String::class$, NULL);\n+  jclass  *c = elements (classes);\n+  jstring *m = elements (methods);\n+\n+  for (int i = 0, j = 0; i < trace->length; i++)\n+    {\n+      _Jv_StackFrame *frame = &trace->frames[i];\n+      if (!frame->klass || !frame->meth)\n+\tcontinue;\n+      c[j] = frame->klass;\n+      m[j] = JvNewStringUTF (frame->meth->name->chars());\n+      j++;\n+    }\n+\n+  jobjectArray *elems = elements (result);\n+  elems[0] = (jobjectArray) classes;\n+  elems[1] = (jobjectArray) methods;\n+\n+  return result;\n+}"}]}