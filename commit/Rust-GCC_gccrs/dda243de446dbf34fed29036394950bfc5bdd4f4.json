{"sha": "dda243de446dbf34fed29036394950bfc5bdd4f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRhMjQzZGU0NDZkYmYzNGZlZDI5MDM2Mzk0OTUwYmZjNWJkZDRmNA==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2005-09-06T18:51:26Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-09-06T18:51:26Z"}, "message": "tree-ssa-pre.c (try_look_through_load): New function.\n\n\t* tree-ssa-pre.c (try_look_through_load): New function.\n\t(compute_avail): Use it to try to look through loads for some\n\tmore useful expressions.\n\nFrom-SVN: r103956", "tree": {"sha": "e47cf53c229c57716f4c3945b8d862da501dde18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e47cf53c229c57716f4c3945b8d862da501dde18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dda243de446dbf34fed29036394950bfc5bdd4f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dda243de446dbf34fed29036394950bfc5bdd4f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dda243de446dbf34fed29036394950bfc5bdd4f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dda243de446dbf34fed29036394950bfc5bdd4f4/comments", "author": null, "committer": null, "parents": [{"sha": "f5d1572a8a1aaba31679c2500e4a492936960531", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5d1572a8a1aaba31679c2500e4a492936960531", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5d1572a8a1aaba31679c2500e4a492936960531"}], "stats": {"total": 81, "additions": 81, "deletions": 0}, "files": [{"sha": "3d6de0f33ecddc0e261a2440765f03b0c119c94d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda243de446dbf34fed29036394950bfc5bdd4f4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda243de446dbf34fed29036394950bfc5bdd4f4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dda243de446dbf34fed29036394950bfc5bdd4f4", "patch": "@@ -1,3 +1,9 @@\n+2005-09-06  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* tree-ssa-pre.c (try_look_through_load): New function.\n+\t(compute_avail): Use it to try to look through loads for some\n+\tmore useful expressions.\n+\n 2005-09-06  Saurabh Verma  <saurabh.verma@codito.com>\n \n \t* simplify-rtx.c (simplify_binary_operation_1): Correct the "}, {"sha": "b0e79535ee15879d224cb4395c24017ceaf43dcc", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dda243de446dbf34fed29036394950bfc5bdd4f4/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dda243de446dbf34fed29036394950bfc5bdd4f4/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=dda243de446dbf34fed29036394950bfc5bdd4f4", "patch": "@@ -2136,6 +2136,75 @@ can_value_number_call (tree stmt)\n   return false;\n }\n \n+/* Given a statement STMT and its right hand side which is a load, try\n+   to look for the expression stored in the location for the load, and\n+   return true if a useful equivalence was recorded for LHS.  */\n+\n+static bool\n+try_look_through_load (tree lhs, tree mem_ref, tree stmt, basic_block block)\n+{\n+  tree store_stmt = NULL;\n+  tree rhs;\n+  ssa_op_iter i;\n+  tree vuse;\n+\n+  FOR_EACH_SSA_TREE_OPERAND (vuse, stmt, i, SSA_OP_VIRTUAL_USES)\n+    {\n+      tree def_stmt;\n+\n+      gcc_assert (TREE_CODE (vuse) == SSA_NAME);\n+      def_stmt = SSA_NAME_DEF_STMT (vuse);\n+\n+      /* If there is no useful statement for this VUSE, we'll not find a\n+\t useful expression to return either.  Likewise, if there is a\n+\t statement but it is not a simple assignment or it has virtual\n+\t uses, we can stop right here.  Note that this means we do\n+\t not look through PHI nodes, which is intentional.  */\n+      if (!def_stmt\n+\t  || TREE_CODE (def_stmt) != MODIFY_EXPR\n+\t  || !ZERO_SSA_OPERANDS (def_stmt, SSA_OP_VIRTUAL_USES))\n+\treturn false;\n+\n+      /* If this is not the same statement as one we have looked at for\n+\t another VUSE of STMT already, we have two statements producing\n+\t something that reaches our STMT.  */\n+      if (store_stmt && store_stmt != def_stmt)\n+\treturn false;\n+      else\n+\t{\n+\t  /* Is this a store to the exact same location as the one we are\n+\t     loading from in STMT?  */\n+\t  if (!operand_equal_p (TREE_OPERAND (def_stmt, 0), mem_ref, 0))\n+\t    return false;\n+\n+\t  /* Otherwise remember this statement and see if all other VUSEs\n+\t     come from the same statement.  */\n+\t  store_stmt = def_stmt;\n+\t}\n+    }\n+\n+  /* Alright then, we have visited all VUSEs of STMT and we've determined\n+     that all of them come from the same statement STORE_STMT.  See if there\n+     is a useful expression we can deduce from STORE_STMT.  */\n+  rhs = TREE_OPERAND (store_stmt, 1);\n+  if (TREE_CODE (rhs) == SSA_NAME\n+      || is_gimple_min_invariant (rhs)\n+      || TREE_CODE (rhs) == ADDR_EXPR\n+      || TREE_INVARIANT (rhs))\n+    {\n+      /* Yay!  Compute a value number for the RHS of the statement and\n+ \t add its value to the AVAIL_OUT set for the block.  Add the LHS\n+\t to TMP_GEN.  */\n+      add_to_sets (lhs, rhs, store_stmt, TMP_GEN (block), AVAIL_OUT (block));\n+      if (TREE_CODE (rhs) == SSA_NAME\n+\t  && !is_undefined_value (rhs))\n+\tvalue_insert_into_set (EXP_GEN (block), rhs);\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n /* Compute the AVAIL set for all basic blocks.\n \n    This function performs value numbering of the statements in each basic\n@@ -2226,6 +2295,12 @@ compute_avail (void)\n \t      tree lhs = TREE_OPERAND (stmt, 0);\n \t      tree rhs = TREE_OPERAND (stmt, 1);\n \n+\t      /* Try to look through loads.  */\n+\t      if (TREE_CODE (lhs) == SSA_NAME\n+\t\t  && !ZERO_SSA_OPERANDS (stmt, SSA_OP_VIRTUAL_USES)\n+\t\t  && try_look_through_load (lhs, rhs, stmt, block))\n+\t\tcontinue;\n+\n \t      STRIP_USELESS_TYPE_CONVERSION (rhs);\n \t      if (UNARY_CLASS_P (rhs)\n \t\t  || BINARY_CLASS_P (rhs)"}]}