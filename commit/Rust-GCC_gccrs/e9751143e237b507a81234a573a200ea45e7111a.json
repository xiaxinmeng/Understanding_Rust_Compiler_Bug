{"sha": "e9751143e237b507a81234a573a200ea45e7111a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk3NTExNDNlMjM3YjUwN2E4MTIzNGE1NzNhMjAwZWE0NWU3MTExYQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-10-29T00:09:04Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-10-29T00:09:04Z"}, "message": "analyzer: move svalue and region decls to their own header files\n\ngcc/ChangeLog:\n\t* Makefile.in (ANALYZER_OBJS): Add analyzer/complexity.o.\n\ngcc/analyzer/ChangeLog:\n\t* analyzer.h (class state_machine): New forward decl.\n\t(class logger): Likewise.\n\t(class visitor): Likewise.\n\t* complexity.cc: New file, taken from svalue.cc.\n\t* complexity.h: New file, taken from region-model.h.\n\t* region-model.h: Include \"analyzer/svalue.h\" and\n\t\"analyzer/region.h\".  Move struct complexity to complexity.h.\n\tMove svalue, its subclasses and supporting decls to svalue.h.\n\tMove region, its subclasses and supporting decls to region.h.\n\t* region.cc: Include \"analyzer/region.h\".\n\t(symbolic_region::symbolic_region): Move here from region-model.h.\n\t* region.h: New file, based on material from region-model.h.\n\t* svalue.cc: Include \"analyzer/svalue.h\".\n\t(complexity::complexity): Move to complexity.cc.\n\t(complexity::from_pair): Likewise.\n\t* svalue.h: New file, based on material from region-model.h.", "tree": {"sha": "67c5ae2a3112bd02c8b4aa98f8287251481a3e3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67c5ae2a3112bd02c8b4aa98f8287251481a3e3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9751143e237b507a81234a573a200ea45e7111a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9751143e237b507a81234a573a200ea45e7111a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9751143e237b507a81234a573a200ea45e7111a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9751143e237b507a81234a573a200ea45e7111a/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a36f5f21cd9dcaaf99e78d2ec995d6cb2918274", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a36f5f21cd9dcaaf99e78d2ec995d6cb2918274", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a36f5f21cd9dcaaf99e78d2ec995d6cb2918274"}], "stats": {"total": 4494, "additions": 2332, "deletions": 2162}, "files": [{"sha": "7fc03c8d9467c660276f59a7146fb3f13d744180", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9751143e237b507a81234a573a200ea45e7111a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9751143e237b507a81234a573a200ea45e7111a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=e9751143e237b507a81234a573a200ea45e7111a", "patch": "@@ -1230,6 +1230,7 @@ ANALYZER_OBJS = \\\n \tanalyzer/bar-chart.o \\\n \tanalyzer/call-string.o \\\n \tanalyzer/checker-path.o \\\n+\tanalyzer/complexity.o \\\n \tanalyzer/constraint-manager.o \\\n \tanalyzer/diagnostic-manager.o \\\n \tanalyzer/engine.o \\"}, {"sha": "c84d7fdcaab92f001e421ab96c99de84a15b313b", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9751143e237b507a81234a573a200ea45e7111a/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9751143e237b507a81234a573a200ea45e7111a/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=e9751143e237b507a81234a573a200ea45e7111a", "patch": "@@ -97,6 +97,9 @@ class state_change;\n class rewind_info_t;\n \n class engine;\n+class state_machine;\n+class logger;\n+class visitor;\n \n /* Forward decls of functions.  */\n "}, {"sha": "221f3a618e5ff1f4c49db2cc922e7961d4924f0e", "filename": "gcc/analyzer/complexity.cc", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9751143e237b507a81234a573a200ea45e7111a/gcc%2Fanalyzer%2Fcomplexity.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9751143e237b507a81234a573a200ea45e7111a/gcc%2Fanalyzer%2Fcomplexity.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcomplexity.cc?ref=e9751143e237b507a81234a573a200ea45e7111a", "patch": "@@ -0,0 +1,95 @@\n+/* Measuring the complexity of svalues/regions.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"diagnostic-core.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"diagnostic-core.h\"\n+#include \"graphviz.h\"\n+#include \"options.h\"\n+#include \"cgraph.h\"\n+#include \"tree-dfa.h\"\n+#include \"stringpool.h\"\n+#include \"convert.h\"\n+#include \"target.h\"\n+#include \"fold-const.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"tristate.h\"\n+#include \"bitmap.h\"\n+#include \"selftest.h\"\n+#include \"function.h\"\n+#include \"json.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"options.h\"\n+#include \"cgraph.h\"\n+#include \"cfg.h\"\n+#include \"digraph.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/store.h\"\n+#include \"analyzer/complexity.h\"\n+#include \"analyzer/svalue.h\"\n+#include \"analyzer/region.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+namespace ana {\n+\n+/* struct complexity.  */\n+\n+/* Get complexity for a new node that references REG\n+   (the complexity of REG, plus one for the new node).  */\n+\n+complexity::complexity (const region *reg)\n+: m_num_nodes (reg->get_complexity ().m_num_nodes + 1),\n+  m_max_depth (reg->get_complexity ().m_max_depth + 1)\n+{\n+}\n+\n+/* Get complexity for a new node that references SVAL.\n+   (the complexity of SVAL, plus one for the new node).  */\n+\n+complexity::complexity (const svalue *sval)\n+: m_num_nodes (sval->get_complexity ().m_num_nodes + 1),\n+  m_max_depth (sval->get_complexity ().m_max_depth + 1)\n+{\n+}\n+\n+/* Get complexity for a new node that references nodes with complexity\n+   C1 and C2.  */\n+\n+complexity\n+complexity::from_pair (const complexity &c1, const complexity &c2)\n+{\n+  return complexity (c1.m_num_nodes + c2.m_num_nodes + 1,\n+\t\t     MAX (c1.m_max_depth, c2.m_max_depth) + 1);\n+}\n+\n+} // namespace ana\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "e15967f26e5c482bd5e609f2e5ae08c459e97ef5", "filename": "gcc/analyzer/complexity.h", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9751143e237b507a81234a573a200ea45e7111a/gcc%2Fanalyzer%2Fcomplexity.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9751143e237b507a81234a573a200ea45e7111a/gcc%2Fanalyzer%2Fcomplexity.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcomplexity.h?ref=e9751143e237b507a81234a573a200ea45e7111a", "patch": "@@ -0,0 +1,51 @@\n+/* Measuring the complexity of svalues/regions.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_COMPLEXITY_H\n+#define GCC_ANALYZER_COMPLEXITY_H\n+\n+namespace ana {\n+\n+/* A measurement of the complexity of an svalue or region, so that\n+   we can impose bounds on the growth of these tree-like structures\n+   and thus avoid infinite chains of analysis.  */\n+\n+struct complexity\n+{\n+  complexity (unsigned num_nodes, unsigned max_depth)\n+  : m_num_nodes (num_nodes), m_max_depth (max_depth)\n+  {}\n+\n+  complexity (const region *reg);\n+  complexity (const svalue *sval);\n+  static complexity from_pair (const complexity &c1, const complexity &c);\n+\n+  /* The total number of svalues and regions in the tree of this\n+     entity, including the entity itself.  */\n+  unsigned m_num_nodes;\n+\n+  /* The maximum depth of the tree of this entity, including the\n+     entity itself.  */\n+  unsigned m_max_depth;\n+};\n+\n+} // namespace ana\n+\n+#endif /* GCC_ANALYZER_COMPLEXITY_H */"}, {"sha": "75f15128c560a403dc7d69ea95e299ad3a3f8fe3", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 3, "deletions": 2132, "changes": 2135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9751143e237b507a81234a573a200ea45e7111a/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9751143e237b507a81234a573a200ea45e7111a/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=e9751143e237b507a81234a573a200ea45e7111a", "patch": "@@ -26,6 +26,9 @@ along with GCC; see the file COPYING3.  If not see\n       (Zhongxing Xu, Ted Kremenek, and Jian Zhang)\n      http://lcs.ios.ac.cn/~xuzb/canalyze/memmodel.pdf  */\n \n+#include \"analyzer/svalue.h\"\n+#include \"analyzer/region.h\"\n+\n using namespace ana;\n \n namespace inchash\n@@ -147,29 +150,6 @@ struct purge_stats\n   int m_num_client_items;\n };\n \n-/* A measurement of the complexity of an svalue or region, so that\n-   we can impose bounds on the growth of these tree-like structures\n-   and thus avoid infinite chains of analysis.  */\n-\n-struct complexity\n-{\n-  complexity (unsigned num_nodes, unsigned max_depth)\n-  : m_num_nodes (num_nodes), m_max_depth (max_depth)\n-  {}\n-\n-  complexity (const region *reg);\n-  complexity (const svalue *sval);\n-  static complexity from_pair (const complexity &c1, const complexity &c);\n-\n-  /* The total number of svalues and regions in the tree of this\n-     entity, including the entity itself.  */\n-  unsigned m_num_nodes;\n-\n-  /* The maximum depth of the tree of this entity, including the\n-     entity itself.  */\n-  unsigned m_max_depth;\n-};\n-\n /* A base class for visiting regions and svalues, with do-nothing\n    base implementations of the per-subclass vfuncs.  */\n \n@@ -194,2119 +174,10 @@ class visitor\n   virtual void visit_region (const region *) {}\n };\n \n-/* An enum for discriminating between the different concrete subclasses\n-   of svalue.  */\n-\n-enum svalue_kind\n-{\n-  SK_REGION,\n-  SK_CONSTANT,\n-  SK_UNKNOWN,\n-  SK_POISONED,\n-  SK_SETJMP,\n-  SK_INITIAL,\n-  SK_UNARYOP,\n-  SK_BINOP,\n-  SK_SUB,\n-  SK_UNMERGEABLE,\n-  SK_PLACEHOLDER,\n-  SK_WIDENING,\n-  SK_COMPOUND,\n-  SK_CONJURED\n-};\n-\n-/* svalue and its subclasses.\n-\n-   The class hierarchy looks like this (using indentation to show\n-   inheritance, and with svalue_kinds shown for the concrete subclasses):\n-\n-   svalue\n-     region_svalue (SK_REGION): a pointer to a region\n-     constant_svalue (SK_CONSTANT): a constant\n-     unknown_svalue (SK_UNKNOWN): an unknowable value\n-     poisoned_svalue (SK_POISONED): a unusable value (undefined)\n-     setjmp_svalue (SK_SETJMP): a setjmp/longjmp buffer\n-     initial_svalue (SK_INITIAL): the initial value of a region\n-     unaryop_svalue (SK_UNARYOP): unary operation on another svalue\n-     binop_svalue (SK_BINOP): binary operation on two svalues\n-     sub_svalue (SK_SUB): the result of accessing a subregion\n-     unmergeable_svalue (SK_UNMERGEABLE): a value that is so interesting\n-       from a control-flow perspective that it can inhibit state-merging\n-     placeholder_svalue (SK_PLACEHOLDER): for use in selftests.\n-     widening_svalue (SK_WIDENING): a merger of two svalues (possibly\n-       in an iteration).\n-     compound_svalue (SK_COMPOUND): a mapping of bit-ranges to svalues\n-     conjured_svalue (SK_CONJURED): a value arising from a stmt.  */\n-\n-/* An abstract base class representing a value held by a region of memory.  */\n-\n-class svalue\n-{\n-public:\n-  virtual ~svalue () {}\n-\n-  tree get_type () const { return m_type; }\n-\n-  virtual enum svalue_kind get_kind () const = 0;\n-\n-  void print (const region_model &model,\n-\t      pretty_printer *pp) const;\n-\n-  virtual void dump_to_pp (pretty_printer *pp, bool simple) const = 0;\n-  void dump (bool simple=true) const;\n-  label_text get_desc (bool simple=true) const;\n-\n-  json::value *to_json () const;\n-\n-  virtual const region_svalue *\n-  dyn_cast_region_svalue () const { return NULL; }\n-  virtual const constant_svalue *\n-  dyn_cast_constant_svalue () const { return NULL; }\n-  virtual const poisoned_svalue *\n-  dyn_cast_poisoned_svalue () const { return NULL; }\n-  virtual const setjmp_svalue *\n-  dyn_cast_setjmp_svalue () const { return NULL; }\n-  virtual const initial_svalue *\n-  dyn_cast_initial_svalue () const { return NULL; }\n-  virtual const unaryop_svalue *\n-  dyn_cast_unaryop_svalue () const { return NULL; }\n-  virtual const binop_svalue *\n-  dyn_cast_binop_svalue () const { return NULL; }\n-  virtual const sub_svalue *\n-  dyn_cast_sub_svalue () const { return NULL; }\n-  virtual const unmergeable_svalue *\n-  dyn_cast_unmergeable_svalue () const { return NULL; }\n-  virtual const widening_svalue *\n-  dyn_cast_widening_svalue () const { return NULL; }\n-  virtual const compound_svalue *\n-  dyn_cast_compound_svalue () const { return NULL; }\n-  virtual const conjured_svalue *\n-  dyn_cast_conjured_svalue () const { return NULL; }\n-\n-  tree maybe_get_constant () const;\n-  const svalue *maybe_undo_cast () const;\n-  const svalue *unwrap_any_unmergeable () const;\n-\n-  const svalue *can_merge_p (const svalue *other,\n-\t\t\t      region_model_manager *mgr,\n-\t\t\t      model_merger *merger) const;\n-\n-  const complexity &get_complexity () const { return m_complexity; }\n-\n-  virtual void accept (visitor *v) const  = 0;\n-\n-  bool live_p (const svalue_set &live_svalues,\n-\t       const region_model *model) const;\n-  virtual bool implicitly_live_p (const svalue_set &live_svalues,\n-\t\t\t\t  const region_model *model) const;\n-\n-  static int cmp_ptr (const svalue *, const svalue *);\n-  static int cmp_ptr_ptr (const void *, const void *);\n-\n- protected:\n-  svalue (complexity c, tree type)\n-  : m_complexity (c), m_type (type)\n-  {}\n-\n- private:\n-  complexity m_complexity;\n-  tree m_type;\n-};\n-\n-/* Concrete subclass of svalue representing a pointer value that points to\n-   a known region  */\n-\n-class region_svalue : public svalue\n-{\n-public:\n-  /* A support class for uniquifying instances of region_svalue.  */\n-  struct key_t\n-  {\n-    key_t (tree type, const region *reg)\n-    : m_type (type), m_reg (reg)\n-    {}\n-\n-    hashval_t hash () const\n-    {\n-      inchash::hash hstate;\n-      hstate.add_ptr (m_type);\n-      hstate.add_ptr (m_reg);\n-      return hstate.end ();\n-    }\n-\n-    bool operator== (const key_t &other) const\n-    {\n-      return (m_type == other.m_type && m_reg == other.m_reg);\n-    }\n-\n-    void mark_deleted () { m_type = reinterpret_cast<tree> (1); }\n-    void mark_empty () { m_type = NULL_TREE; }\n-    bool is_deleted () const { return m_type == reinterpret_cast<tree> (1); }\n-    bool is_empty () const { return m_type == NULL_TREE; }\n-\n-    tree m_type;\n-    const region *m_reg;\n-  };\n-\n-  region_svalue (tree type, const region *reg)\n-  : svalue (complexity (reg), type),\n-    m_reg (reg)\n-  {\n-    gcc_assert (m_reg != NULL);\n-  }\n-\n-  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_REGION; }\n-  const region_svalue *\n-  dyn_cast_region_svalue () const FINAL OVERRIDE { return this; }\n-\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-  void accept (visitor *v) const FINAL OVERRIDE;\n-\n-  const region * get_pointee () const { return m_reg; }\n-\n-  static tristate eval_condition (const region_svalue *lhs_ptr,\n-\t\t\t\t  enum tree_code op,\n-\t\t\t\t  const region_svalue *rhs_ptr);\n-\n- private:\n-  const region *m_reg;\n-};\n-\n-} // namespace ana\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <const region_svalue *>::test (const svalue *sval)\n-{\n-  return sval->get_kind () == SK_REGION;\n-}\n-\n-template <> struct default_hash_traits<region_svalue::key_t>\n-: public member_function_hash_traits<region_svalue::key_t>\n-{\n-  static const bool empty_zero_p = true;\n-};\n-\n-namespace ana {\n-\n-/* Concrete subclass of svalue representing a specific constant value.  */\n-\n-class constant_svalue : public svalue\n-{\n-public:\n-  constant_svalue (tree cst_expr)\n-  : svalue (complexity (1, 1), TREE_TYPE (cst_expr)), m_cst_expr (cst_expr)\n-  {\n-    gcc_assert (cst_expr);\n-    gcc_assert (CONSTANT_CLASS_P (cst_expr));\n-  }\n-\n-  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_CONSTANT; }\n-  const constant_svalue *\n-  dyn_cast_constant_svalue () const FINAL OVERRIDE { return this; }\n-\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-  void accept (visitor *v) const FINAL OVERRIDE;\n-  bool implicitly_live_p (const svalue_set &,\n-\t\t\t  const region_model *) const FINAL OVERRIDE;\n-\n-  tree get_constant () const { return m_cst_expr; }\n-  static tristate eval_condition (const constant_svalue *lhs,\n-\t\t\t\t  enum tree_code op,\n-\t\t\t\t  const constant_svalue *rhs);\n-\n- private:\n-  tree m_cst_expr;\n-};\n-\n-} // namespace ana\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <const constant_svalue *>::test (const svalue *sval)\n-{\n-  return sval->get_kind () == SK_CONSTANT;\n-}\n-\n-namespace ana {\n-\n-/* Concrete subclass of svalue representing an unknowable value, the bottom\n-   value when thinking of svalues as a lattice.\n-   This is a singleton (w.r.t. its manager): there is a single unknown_svalue\n-   per type.  Self-comparisons of such instances yield \"unknown\".  */\n-\n-class unknown_svalue : public svalue\n-{\n-public:\n-  unknown_svalue (tree type)\n-  : svalue (complexity (1, 1), type)\n-  {}\n-\n-  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_UNKNOWN; }\n-\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-  void accept (visitor *v) const FINAL OVERRIDE;\n-};\n-\n-/* An enum describing a particular kind of \"poisoned\" value.  */\n-\n-enum poison_kind\n-{\n-  /* For use to describe freed memory.  */\n-  POISON_KIND_FREED,\n-\n-  /* For use on pointers to regions within popped stack frames.  */\n-  POISON_KIND_POPPED_STACK\n-};\n-\n-extern const char *poison_kind_to_str (enum poison_kind);\n-\n-/* Concrete subclass of svalue representing a value that should not\n-   be used (e.g. uninitialized memory, freed memory).  */\n-\n-class poisoned_svalue : public svalue\n-{\n-public:\n-  /* A support class for uniquifying instances of poisoned_svalue.  */\n-  struct key_t\n-  {\n-    key_t (enum poison_kind kind, tree type)\n-    : m_kind (kind), m_type (type)\n-    {}\n-\n-    hashval_t hash () const\n-    {\n-      inchash::hash hstate;\n-      hstate.add_int (m_kind);\n-      hstate.add_ptr (m_type);\n-      return hstate.end ();\n-    }\n-\n-    bool operator== (const key_t &other) const\n-    {\n-      return (m_kind == other.m_kind && m_type == other.m_type);\n-    }\n-\n-    void mark_deleted () { m_type = reinterpret_cast<tree> (1); }\n-    void mark_empty () { m_type = NULL_TREE; }\n-    bool is_deleted () const { return m_type == reinterpret_cast<tree> (1); }\n-    bool is_empty () const { return m_type == NULL_TREE; }\n-\n-    enum poison_kind m_kind;\n-    tree m_type;\n-  };\n-\n-  poisoned_svalue (enum poison_kind kind, tree type)\n-  : svalue (complexity (1, 1), type), m_kind (kind) {}\n-\n-  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_POISONED; }\n-  const poisoned_svalue *\n-  dyn_cast_poisoned_svalue () const FINAL OVERRIDE { return this; }\n-\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-  void accept (visitor *v) const FINAL OVERRIDE;\n-\n-  enum poison_kind get_poison_kind () const { return m_kind; }\n-\n- private:\n-  enum poison_kind m_kind;\n-};\n-\n-} // namespace ana\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <const poisoned_svalue *>::test (const svalue *sval)\n-{\n-  return sval->get_kind () == SK_POISONED;\n-}\n-\n-template <> struct default_hash_traits<poisoned_svalue::key_t>\n-: public member_function_hash_traits<poisoned_svalue::key_t>\n-{\n-  static const bool empty_zero_p = true;\n-};\n-\n-namespace ana {\n-\n-/* A bundle of information recording a setjmp/sigsetjmp call, corresponding\n-   roughly to a jmp_buf.  */\n-\n-struct setjmp_record\n-{\n-  setjmp_record (const exploded_node *enode,\n-\t\t const gcall *setjmp_call)\n-  : m_enode (enode), m_setjmp_call (setjmp_call)\n-  {\n-  }\n-\n-  bool operator== (const setjmp_record &other) const\n-  {\n-    return (m_enode == other.m_enode\n-\t    && m_setjmp_call == other.m_setjmp_call);\n-  }\n-\n-  void add_to_hash (inchash::hash *hstate) const\n-  {\n-    hstate->add_ptr (m_enode);\n-    hstate->add_ptr (m_setjmp_call);\n-  }\n-\n-  static int cmp (const setjmp_record &rec1, const setjmp_record &rec2);\n-\n-  const exploded_node *m_enode;\n-  const gcall *m_setjmp_call;\n-};\n-\n-/* Concrete subclass of svalue representing buffers for setjmp/sigsetjmp,\n-   so that longjmp/siglongjmp can potentially \"return\" to an entirely\n-   different function.  */\n-\n-class setjmp_svalue : public svalue\n-{\n-public:\n-  /* A support class for uniquifying instances of poisoned_svalue.  */\n-  struct key_t\n-  {\n-    key_t (const setjmp_record &record, tree type)\n-    : m_record (record), m_type (type)\n-    {}\n-\n-    hashval_t hash () const\n-    {\n-      inchash::hash hstate;\n-      m_record.add_to_hash (&hstate);\n-      hstate.add_ptr (m_type);\n-      return hstate.end ();\n-    }\n-\n-    bool operator== (const key_t &other) const\n-    {\n-      return (m_record == other.m_record && m_type == other.m_type);\n-    }\n-\n-    void mark_deleted () { m_type = reinterpret_cast<tree> (1); }\n-    void mark_empty () { m_type = NULL_TREE; }\n-    bool is_deleted () const { return m_type == reinterpret_cast<tree> (1); }\n-    bool is_empty () const { return m_type == NULL_TREE; }\n-\n-    setjmp_record m_record;\n-    tree m_type;\n-  };\n-\n-  setjmp_svalue (const setjmp_record &setjmp_record,\n-\t\t  tree type)\n-  : svalue (complexity (1, 1), type), m_setjmp_record (setjmp_record)\n-  {}\n-\n-  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_SETJMP; }\n-  const setjmp_svalue *\n-  dyn_cast_setjmp_svalue () const FINAL OVERRIDE { return this; }\n-\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-  void accept (visitor *v) const FINAL OVERRIDE;\n-\n-  int get_enode_index () const;\n-\n-  const setjmp_record &get_setjmp_record () const { return m_setjmp_record; }\n-\n- private:\n-  setjmp_record m_setjmp_record;\n-};\n-\n-} // namespace ana\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <const setjmp_svalue *>::test (const svalue *sval)\n-{\n-  return sval->get_kind () == SK_SETJMP;\n-}\n-\n-template <> struct default_hash_traits<setjmp_svalue::key_t>\n-: public member_function_hash_traits<setjmp_svalue::key_t>\n-{\n-  static const bool empty_zero_p = true;\n-};\n-\n-namespace ana {\n-\n-/* Concrete subclass of svalue representing the initial value of a\n-   specific region.\n-\n-   This represents the initial value at the start of the analysis path,\n-   as opposed to the first time the region is accessed during the path.\n-   Hence as soon as we have a call to an unknown function, all previously\n-   unmodelled globals become implicitly \"unknown\" rathen than \"initial\".  */\n-\n-class initial_svalue : public svalue\n-{\n-public:\n-  initial_svalue (tree type, const region *reg)\n-  : svalue (complexity (reg), type), m_reg (reg)\n-  {\n-    gcc_assert (m_reg != NULL);\n-  }\n-\n-  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_INITIAL; }\n-  const initial_svalue *\n-  dyn_cast_initial_svalue () const FINAL OVERRIDE { return this; }\n-\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-  void accept (visitor *v) const FINAL OVERRIDE;\n-  bool implicitly_live_p (const svalue_set &,\n-\t\t\t  const region_model *) const FINAL OVERRIDE;\n-\n-  const region *get_region () const { return m_reg; }\n-\n- private:\n-  const region *m_reg;\n-};\n-\n-} // namespace ana\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <const initial_svalue *>::test (const svalue *sval)\n-{\n-  return sval->get_kind () == SK_INITIAL;\n-}\n-\n-namespace ana {\n-\n-/* Concrete subclass of svalue representing a unary operation on\n-   another svalues (e.g. a cast).  */\n-\n-class unaryop_svalue : public svalue\n-{\n-public:\n-  /* A support class for uniquifying instances of unaryop_svalue.  */\n-  struct key_t\n-  {\n-    key_t (tree type, enum tree_code op, const svalue *arg)\n-    : m_type (type), m_op (op), m_arg (arg)\n-    {}\n-\n-    hashval_t hash () const\n-    {\n-      inchash::hash hstate;\n-      hstate.add_ptr (m_type);\n-      hstate.add_int (m_op);\n-      hstate.add_ptr (m_arg);\n-      return hstate.end ();\n-    }\n-\n-    bool operator== (const key_t &other) const\n-    {\n-      return (m_type == other.m_type\n-\t      && m_op == other.m_op\n-\t      && m_arg == other.m_arg);\n-    }\n-\n-    void mark_deleted () { m_type = reinterpret_cast<tree> (1); }\n-    void mark_empty () { m_type = NULL_TREE; }\n-    bool is_deleted () const { return m_type == reinterpret_cast<tree> (1); }\n-    bool is_empty () const { return m_type == NULL_TREE; }\n-\n-    tree m_type;\n-    enum tree_code m_op;\n-    const svalue *m_arg;\n-  };\n-\n-  unaryop_svalue (tree type, enum tree_code op, const svalue *arg)\n-  : svalue (complexity (arg), type), m_op (op), m_arg (arg)\n-  {\n-  }\n-\n-  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_UNARYOP; }\n-  const unaryop_svalue *\n-  dyn_cast_unaryop_svalue () const FINAL OVERRIDE { return this; }\n-\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-  void accept (visitor *v) const FINAL OVERRIDE;\n-  bool implicitly_live_p (const svalue_set &,\n-\t\t\t  const region_model *) const FINAL OVERRIDE;\n-\n-  enum tree_code get_op () const { return m_op; }\n-  const svalue *get_arg () const { return m_arg; }\n-\n- private:\n-  enum tree_code m_op;\n-  const svalue *m_arg;\n-};\n-\n-} // namespace ana\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <const unaryop_svalue *>::test (const svalue *sval)\n-{\n-  return sval->get_kind () == SK_UNARYOP;\n-}\n-\n-template <> struct default_hash_traits<unaryop_svalue::key_t>\n-: public member_function_hash_traits<unaryop_svalue::key_t>\n-{\n-  static const bool empty_zero_p = true;\n-};\n-\n-namespace ana {\n-\n-/* Concrete subclass of svalue representing a binary operation of\n-   two svalues.  */\n-\n-class binop_svalue : public svalue\n-{\n-public:\n-  /* A support class for uniquifying instances of binop_svalue.  */\n-  struct key_t\n-  {\n-    key_t (tree type, enum tree_code op,\n-\t   const svalue *arg0, const svalue *arg1)\n-    : m_type (type), m_op (op), m_arg0 (arg0), m_arg1 (arg1)\n-    {}\n-\n-    hashval_t hash () const\n-    {\n-      inchash::hash hstate;\n-      hstate.add_ptr (m_type);\n-      hstate.add_int (m_op);\n-      hstate.add_ptr (m_arg0);\n-      hstate.add_ptr (m_arg1);\n-      return hstate.end ();\n-    }\n-\n-    bool operator== (const key_t &other) const\n-    {\n-      return (m_type == other.m_type\n-\t      && m_op == other.m_op\n-\t      && m_arg0 == other.m_arg0\n-\t      && m_arg1 == other.m_arg1);\n-    }\n-\n-    void mark_deleted () { m_type = reinterpret_cast<tree> (1); }\n-    void mark_empty () { m_type = NULL_TREE; }\n-    bool is_deleted () const { return m_type == reinterpret_cast<tree> (1); }\n-    bool is_empty () const { return m_type == NULL_TREE; }\n-\n-    tree m_type;\n-    enum tree_code m_op;\n-    const svalue *m_arg0;\n-    const svalue *m_arg1;\n-  };\n-\n-  binop_svalue (tree type, enum tree_code op,\n-\t\t const svalue *arg0, const svalue *arg1)\n-  : svalue (complexity::from_pair (arg0->get_complexity (),\n-\t\t\t\t    arg1->get_complexity ()),\n-\t     type),\n-    m_op (op), m_arg0 (arg0), m_arg1 (arg1)\n-  {\n-  }\n-\n-  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_BINOP; }\n-  const binop_svalue *dyn_cast_binop_svalue () const FINAL OVERRIDE\n-  {\n-    return this;\n-  }\n-\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-  void accept (visitor *v) const FINAL OVERRIDE;\n-  bool implicitly_live_p (const svalue_set &,\n-\t\t\t  const region_model *) const FINAL OVERRIDE;\n-\n-  enum tree_code get_op () const { return m_op; }\n-  const svalue *get_arg0 () const { return m_arg0; }\n-  const svalue *get_arg1 () const { return m_arg1; }\n-\n- private:\n-  enum tree_code m_op;\n-  const svalue *m_arg0;\n-  const svalue *m_arg1;\n-};\n-\n } // namespace ana\n \n-template <>\n-template <>\n-inline bool\n-is_a_helper <const binop_svalue *>::test (const svalue *sval)\n-{\n-  return sval->get_kind () == SK_BINOP;\n-}\n-\n-template <> struct default_hash_traits<binop_svalue::key_t>\n-: public member_function_hash_traits<binop_svalue::key_t>\n-{\n-  static const bool empty_zero_p = true;\n-};\n-\n namespace ana {\n \n-/* Concrete subclass of svalue representing the result of accessing a subregion\n-   of another svalue (the value of a component/field of a struct, or an element\n-   from an array).  */\n-\n-class sub_svalue : public svalue\n-{\n-public:\n-  /* A support class for uniquifying instances of sub_svalue.  */\n-  struct key_t\n-  {\n-    key_t (tree type, const svalue *parent_svalue, const region *subregion)\n-    : m_type (type), m_parent_svalue (parent_svalue), m_subregion (subregion)\n-    {}\n-\n-    hashval_t hash () const\n-    {\n-      inchash::hash hstate;\n-      hstate.add_ptr (m_type);\n-      hstate.add_ptr (m_parent_svalue);\n-      hstate.add_ptr (m_subregion);\n-      return hstate.end ();\n-    }\n-\n-    bool operator== (const key_t &other) const\n-    {\n-      return (m_type == other.m_type\n-\t      && m_parent_svalue == other.m_parent_svalue\n-\t      && m_subregion == other.m_subregion);\n-    }\n-\n-    void mark_deleted () { m_type = reinterpret_cast<tree> (1); }\n-    void mark_empty () { m_type = NULL_TREE; }\n-    bool is_deleted () const { return m_type == reinterpret_cast<tree> (1); }\n-    bool is_empty () const { return m_type == NULL_TREE; }\n-\n-    tree m_type;\n-    const svalue *m_parent_svalue;\n-    const region *m_subregion;\n-  };\n-  sub_svalue (tree type, const svalue *parent_svalue,\n-\t       const region *subregion);\n-\n-  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_SUB; }\n-  const sub_svalue *dyn_cast_sub_svalue () const FINAL OVERRIDE\n-  {\n-    return this;\n-  }\n-\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-  void accept (visitor *v) const FINAL OVERRIDE;\n-  bool implicitly_live_p (const svalue_set &,\n-\t\t\t  const region_model *) const FINAL OVERRIDE;\n-\n-  const svalue *get_parent () const { return m_parent_svalue; }\n-  const region *get_subregion () const { return m_subregion; }\n-\n- private:\n-  const svalue *m_parent_svalue;\n-  const region *m_subregion;\n-};\n-\n-} // namespace ana\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <const sub_svalue *>::test (const svalue *sval)\n-{\n-  return sval->get_kind () == SK_SUB;\n-}\n-\n-template <> struct default_hash_traits<sub_svalue::key_t>\n-: public member_function_hash_traits<sub_svalue::key_t>\n-{\n-  static const bool empty_zero_p = true;\n-};\n-\n-namespace ana {\n-\n-/* Concrete subclass of svalue: decorate another svalue,\n-   so that the resulting svalue can be identified as being\n-   \"interesting to control flow\".\n-   For example, consider the return value from setjmp.  We\n-   don't want to merge states in which the result is 0 with\n-   those in which the result is non-zero.  By using an\n-   unmergeable_svalue for the result, we can inhibit such merges\n-   and have separate exploded nodes for those states, keeping\n-   the first and second returns from setjmp distinct in the exploded\n-   graph.  */\n-\n-class unmergeable_svalue : public svalue\n-{\n-public:\n-  unmergeable_svalue (const svalue *arg)\n-  : svalue (complexity (arg), arg->get_type ()), m_arg (arg)\n-  {\n-  }\n-\n-  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_UNMERGEABLE; }\n-  const unmergeable_svalue *\n-  dyn_cast_unmergeable_svalue () const FINAL OVERRIDE { return this; }\n-\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-  void accept (visitor *v) const FINAL OVERRIDE;\n-  bool implicitly_live_p (const svalue_set &,\n-\t\t\t  const region_model *) const FINAL OVERRIDE;\n-\n-  const svalue *get_arg () const { return m_arg; }\n-\n- private:\n-  const svalue *m_arg;\n-};\n-\n-} // namespace ana\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <const unmergeable_svalue *>::test (const svalue *sval)\n-{\n-  return sval->get_kind () == SK_UNMERGEABLE;\n-}\n-\n-namespace ana {\n-\n-/* Concrete subclass of svalue for use in selftests, where\n-   we want a specific but unknown svalue.\n-   Unlike other svalue subclasses these aren't managed by\n-   region_model_manager.  */\n-\n-class placeholder_svalue : public svalue\n-{\n-public:\n-  placeholder_svalue (tree type, const char *name)\n-  : svalue (complexity (1, 1), type), m_name (name)\n-  {\n-  }\n-\n-  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_PLACEHOLDER; }\n-\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-  void accept (visitor *v) const FINAL OVERRIDE;\n-\n-  const char *get_name () const { return m_name; }\n-\n- private:\n-  const char *m_name;\n-};\n-\n-} // namespace ana\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <placeholder_svalue *>::test (svalue *sval)\n-{\n-  return sval->get_kind () == SK_PLACEHOLDER;\n-}\n-\n-namespace ana {\n-\n-/* Concrete subclass of svalue representing a \"widening\" seen when merging\n-   states, widening from a base value to {base value, iter value} and thus\n-   representing a possible fixed point in an iteration from the base to\n-   +ve infinity, or -ve infinity, and thus useful for representing a value\n-   within a loop.\n-   We also need to capture the program_point at which the merger happens,\n-   so that distinguish between different iterators, and thus handle\n-   nested loops.  (currently we capture the function_point instead, for\n-   simplicity of hashing).  */\n-\n-class widening_svalue : public svalue\n-{\n-public:\n-  /* A support class for uniquifying instances of widening_svalue.  */\n-  struct key_t\n-  {\n-    key_t (tree type, const program_point &point,\n-\t   const svalue *base_sval, const svalue *iter_sval)\n-    : m_type (type), m_point (point.get_function_point ()),\n-      m_base_sval (base_sval), m_iter_sval (iter_sval)\n-    {}\n-\n-    hashval_t hash () const\n-    {\n-      inchash::hash hstate;\n-      hstate.add_ptr (m_base_sval);\n-      hstate.add_ptr (m_iter_sval);\n-      return hstate.end ();\n-    }\n-\n-    bool operator== (const key_t &other) const\n-    {\n-      return (m_type == other.m_type\n-\t      && m_point == other.m_point\n-\t      && m_base_sval == other.m_base_sval\n-\t      && m_iter_sval == other.m_iter_sval);\n-    }\n-\n-    void mark_deleted () { m_type = reinterpret_cast<tree> (1); }\n-    void mark_empty () { m_type = NULL_TREE; }\n-    bool is_deleted () const { return m_type == reinterpret_cast<tree> (1); }\n-    bool is_empty () const { return m_type == NULL_TREE; }\n-\n-    tree m_type;\n-    function_point m_point;\n-    const svalue *m_base_sval;\n-    const svalue *m_iter_sval;\n-  };\n-\n-  enum direction_t\n-    {\n-     DIR_ASCENDING,\n-     DIR_DESCENDING,\n-     DIR_UNKNOWN\n-    };\n-\n-  widening_svalue (tree type, const program_point &point,\n-\t\t   const svalue *base_sval, const svalue *iter_sval)\n-  : svalue (complexity::from_pair (base_sval->get_complexity (),\n-\t\t\t\t   iter_sval->get_complexity ()),\n-\t    type),\n-    m_point (point.get_function_point ()),\n-    m_base_sval (base_sval), m_iter_sval (iter_sval)\n-  {\n-  }\n-\n-  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_WIDENING; }\n-  const widening_svalue *dyn_cast_widening_svalue () const FINAL OVERRIDE\n-  {\n-    return this;\n-  }\n-\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-  void accept (visitor *v) const FINAL OVERRIDE;\n-\n-  const function_point &get_point () const { return m_point; }\n-  const svalue *get_base_svalue () const { return m_base_sval; }\n-  const svalue *get_iter_svalue () const { return m_iter_sval; }\n-\n-  enum direction_t get_direction () const;\n-\n-  tristate eval_condition_without_cm (enum tree_code op,\n-\t\t\t\t      tree rhs_cst) const;\n-\n- private:\n-  function_point m_point;\n-  const svalue *m_base_sval;\n-  const svalue *m_iter_sval;\n-};\n-\n-} // namespace ana\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <widening_svalue *>::test (svalue *sval)\n-{\n-  return sval->get_kind () == SK_WIDENING;\n-}\n-\n-template <> struct default_hash_traits<widening_svalue::key_t>\n-: public member_function_hash_traits<widening_svalue::key_t>\n-{\n-  static const bool empty_zero_p = true;\n-};\n-\n-namespace ana {\n-\n-/* Concrete subclass of svalue representing a mapping of bit-ranges\n-   to svalues, analogous to a cluster within the store.\n-\n-   This is for use in places where we want to represent a store-like\n-   mapping, but are required to use an svalue, such as when handling\n-   compound assignments and compound return values.\n-\n-   All keys within the underlying binding_map are required to be concrete,\n-   not symbolic.\n-\n-   Instances of this class shouldn't be bound as-is into the store;\n-   instead they should be unpacked.  Similarly, they should not be\n-   nested.  */\n-\n-class compound_svalue : public svalue\n-{\n-public:\n-  typedef binding_map::iterator_t iterator_t;\n-\n-  /* A support class for uniquifying instances of compound_svalue.\n-     Note that to avoid copies, keys store pointers to binding_maps,\n-     rather than the maps themselves.  */\n-  struct key_t\n-  {\n-    key_t (tree type, const binding_map *map_ptr)\n-    : m_type (type), m_map_ptr (map_ptr)\n-    {}\n-\n-    hashval_t hash () const\n-    {\n-      inchash::hash hstate;\n-      hstate.add_ptr (m_type);\n-      //hstate.add_ptr (m_map_ptr); // TODO\n-      return hstate.end ();\n-    }\n-\n-    bool operator== (const key_t &other) const\n-    {\n-      return (m_type == other.m_type\n-\t      && *m_map_ptr == *other.m_map_ptr);\n-    }\n-\n-    void mark_deleted () { m_type = reinterpret_cast<tree> (1); }\n-    void mark_empty () { m_type = NULL_TREE; }\n-    bool is_deleted () const { return m_type == reinterpret_cast<tree> (1); }\n-    bool is_empty () const { return m_type == NULL_TREE; }\n-\n-    tree m_type;\n-    const binding_map *m_map_ptr;\n-  };\n-\n-  compound_svalue (tree type, const binding_map &map);\n-\n-  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_COMPOUND; }\n-  const compound_svalue *dyn_cast_compound_svalue () const FINAL OVERRIDE\n-  {\n-    return this;\n-  }\n-\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-  void accept (visitor *v) const FINAL OVERRIDE;\n-\n-  const binding_map &get_map () const { return m_map; }\n-\n-  iterator_t begin () const { return m_map.begin (); }\n-  iterator_t end () const { return m_map.end (); }\n-\n-  struct key_t make_key () const\n-  {\n-    return key_t (get_type (), &m_map);\n-  }\n-\n- private:\n-  static complexity calc_complexity (const binding_map &map);\n-\n-  binding_map m_map;\n-};\n-\n-} // namespace ana\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <compound_svalue *>::test (svalue *sval)\n-{\n-  return sval->get_kind () == SK_COMPOUND;\n-}\n-\n-template <> struct default_hash_traits<compound_svalue::key_t>\n-: public member_function_hash_traits<compound_svalue::key_t>\n-{\n-  static const bool empty_zero_p = true;\n-};\n-\n-namespace ana {\n-\n-/* A defined value arising from a statement, where we want to identify a\n-   particular unknown value, rather than resorting to the unknown_value\n-   singleton, so that the value can have sm-state.\n-\n-   Comparisons of variables that share the same conjured_svalue are known\n-   to be equal, even if we don't know what the value is.\n-\n-   For example, this is used for the values of regions that may have been\n-   touched when calling an unknown function.\n-\n-   The value captures a region as well as a stmt in order to avoid falsely\n-   aliasing the various values that could arise in one statement.  For\n-   example, after:\n-      unknown_fn (&a, &b);\n-   we want values to clobber a and b with, but we don't want to use the\n-   same value, or it would falsely implicitly assume that a == b.  */\n-\n-class conjured_svalue : public svalue\n-{\n-public:\n-  typedef binding_map::iterator_t iterator_t;\n-\n-  /* A support class for uniquifying instances of conjured_svalue.  */\n-  struct key_t\n-  {\n-    key_t (tree type, const gimple *stmt, const region *id_reg)\n-    : m_type (type), m_stmt (stmt), m_id_reg (id_reg)\n-    {}\n-\n-    hashval_t hash () const\n-    {\n-      inchash::hash hstate;\n-      hstate.add_ptr (m_type);\n-      hstate.add_ptr (m_stmt);\n-      hstate.add_ptr (m_id_reg);\n-      return hstate.end ();\n-    }\n-\n-    bool operator== (const key_t &other) const\n-    {\n-      return (m_type == other.m_type\n-\t      && m_stmt == other.m_stmt\n-\t      && m_id_reg == other.m_id_reg);\n-    }\n-\n-    /* Use m_stmt to mark empty/deleted, as m_type can be NULL for\n-       legitimate instances.  */\n-    void mark_deleted () { m_stmt = reinterpret_cast<const gimple *> (1); }\n-    void mark_empty () { m_stmt = NULL; }\n-    bool is_deleted () const\n-    {\n-      return m_stmt == reinterpret_cast<const gimple *> (1);\n-    }\n-    bool is_empty () const { return m_stmt == NULL; }\n-\n-    tree m_type;\n-    const gimple *m_stmt;\n-    const region *m_id_reg;\n-  };\n-\n-  conjured_svalue (tree type, const gimple *stmt, const region *id_reg)\n-  : svalue (complexity (id_reg), type),\n-    m_stmt (stmt), m_id_reg (id_reg)\n-  {\n-    gcc_assert (m_stmt != NULL);\n-  }\n-\n-  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_CONJURED; }\n-  const conjured_svalue *dyn_cast_conjured_svalue () const FINAL OVERRIDE\n-  {\n-    return this;\n-  }\n-\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-  void accept (visitor *v) const FINAL OVERRIDE;\n-\n-  const gimple *get_stmt () const { return m_stmt; }\n-  const region *get_id_region () const { return m_id_reg; }\n-\n- private:\n-  const gimple *m_stmt;\n-  const region *m_id_reg;\n-};\n-\n-} // namespace ana\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <conjured_svalue *>::test (svalue *sval)\n-{\n-  return sval->get_kind () == SK_CONJURED;\n-}\n-\n-template <> struct default_hash_traits<conjured_svalue::key_t>\n-: public member_function_hash_traits<conjured_svalue::key_t>\n-{\n-  static const bool empty_zero_p = true;\n-};\n-\n-namespace ana {\n-\n-/* An enum for discriminating between the different concrete subclasses\n-   of region.  */\n-\n-enum region_kind\n-{\n-  RK_FRAME,\n-  RK_GLOBALS,\n-  RK_CODE,\n-  RK_FUNCTION,\n-  RK_LABEL,\n-  RK_STACK,\n-  RK_HEAP,\n-  RK_ROOT,\n-  RK_SYMBOLIC,\n-  RK_DECL,\n-  RK_FIELD,\n-  RK_ELEMENT,\n-  RK_OFFSET,\n-  RK_CAST,\n-  RK_HEAP_ALLOCATED,\n-  RK_ALLOCA,\n-  RK_STRING,\n-  RK_UNKNOWN\n-};\n-\n-/* Region and its subclasses.\n-\n-   The class hierarchy looks like this (using indentation to show\n-   inheritance, and with region_kinds shown for the concrete subclasses):\n-\n-   region\n-     space_region\n-       frame_region (RK_FRAME)\n-       globals_region (RK_GLOBALS)\n-       code_region (RK_CODE)\n-       stack_region (RK_STACK)\n-       heap_region (RK_HEAP)\n-     root_region (RK_ROOT)\n-     function_region (RK_FUNCTION)\n-     label_region (RK_LABEL)\n-     symbolic_region (RK_SYMBOLIC)\n-     decl_region (RK_DECL),\n-     field_region (RK_FIELD)\n-     element_region (RK_ELEMENT)\n-     offset_region (RK_OFFSET)\n-     cast_region (RK_CAST)\n-     heap_allocated_region (RK_HEAP_ALLOCATED)\n-     alloca_region (RK_ALLOCA)\n-     string_region (RK_STRING)\n-     unknown_region (RK_UNKNOWN).  */\n-\n-/* Abstract base class for representing ways of accessing chunks of memory.\n-\n-   Regions form a tree-like hierarchy, with a root region at the base,\n-   with memory space regions within it, representing the stack and\n-   globals, with frames within the stack, and regions for variables\n-   within the frames and the \"globals\" region.  Regions for structs\n-   can have subregions for fields.  */\n-\n-class region\n-{\n-public:\n-  virtual ~region ();\n-\n-  unsigned get_id () const { return m_id; }\n-  static int cmp_ids (const region *reg1, const region *reg2);\n-\n-  virtual enum region_kind get_kind () const = 0;\n-  virtual const frame_region *\n-  dyn_cast_frame_region () const { return NULL; }\n-  virtual const function_region *\n-  dyn_cast_function_region () const { return NULL; }\n-  virtual const symbolic_region *\n-  dyn_cast_symbolic_region () const { return NULL; }\n-  virtual const decl_region *\n-  dyn_cast_decl_region () const { return NULL; }\n-  virtual const field_region *\n-  dyn_cast_field_region () const { return NULL; }\n-  virtual const element_region *\n-  dyn_cast_element_region () const { return NULL; }\n-  virtual const offset_region *\n-  dyn_cast_offset_region () const { return NULL; }\n-  virtual const cast_region *\n-  dyn_cast_cast_region () const { return NULL; }\n-  virtual const string_region *\n-  dyn_cast_string_region () const { return NULL; }\n-\n-  virtual void accept (visitor *v) const;\n-\n-  const region *get_parent_region () const { return m_parent; }\n-  const region *get_base_region () const;\n-  bool base_region_p () const;\n-  bool descendent_of_p (const region *elder) const;\n-  const frame_region *maybe_get_frame_region () const;\n-\n-  tree maybe_get_decl () const;\n-\n-  tree get_type () const { return m_type; }\n-\n-  void print (const region_model &model,\n-\t      pretty_printer *pp) const;\n-  label_text get_desc (bool simple=true) const;\n-\n-  void dump_to_pp (const region_model &model,\n-\t\t   pretty_printer *pp,\n-\t\t   const char *prefix,\n-\t\t   bool is_last_child) const;\n-\n-  virtual void dump_to_pp (pretty_printer *pp, bool simple) const = 0;\n-  void dump (bool simple) const;\n-\n-  json::value *to_json () const;\n-\n-  bool non_null_p () const;\n-\n-  static int cmp_ptr_ptr (const void *, const void *);\n-\n-  region_offset get_offset () const;\n-  bool get_byte_size (byte_size_t *out) const;\n-  bool get_bit_size (bit_size_t *out) const;\n-\n-  void\n-  get_subregions_for_binding (region_model_manager *mgr,\n-\t\t\t      bit_offset_t start_bit_offset,\n-\t\t\t      bit_size_t size_in_bits,\n-\t\t\t      tree type,\n-\t\t\t      auto_vec <const region *> *out) const;\n-\n-  bool symbolic_for_unknown_ptr_p () const;\n-\n-  const complexity &get_complexity () const { return m_complexity; }\n-\n- protected:\n-  region (complexity c, unsigned id, const region *parent, tree type);\n-\n- private:\n-  region_offset calc_offset () const;\n-\n-  complexity m_complexity;\n-  unsigned m_id; // purely for deterministic sorting at this stage, for dumps\n-  const region *m_parent;\n-  tree m_type;\n-\n-  mutable region_offset *m_cached_offset;\n-};\n-\n-} // namespace ana\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <const region *>::test (const region *)\n-{\n-  return true;\n-}\n-\n-namespace ana {\n-\n-/* Abstract subclass of region, for regions that represent an untyped\n-   space within memory, such as the stack or the heap.  */\n-\n-class space_region : public region\n-{\n-protected:\n-  space_region (unsigned id, const region *parent)\n-  : region (complexity (parent), id, parent, NULL_TREE)\n-  {}\n-};\n-\n-/* Concrete space_region subclass, representing a function frame on the stack,\n-   to contain the locals.\n-   The parent is the stack region; there's also a hierarchy of call-stack\n-   prefixes expressed via m_calling_frame.\n-   For example, given \"oldest\" calling \"middle\" called \"newest\" we would have\n-   - a stack depth of 3\n-   - frame (A) for \"oldest\" with index 0 for depth 1, calling_frame == NULL\n-   - frame (B) for \"middle\" with index 1 for depth 2, calling_frame == (A)\n-   - frame (C) for \"newest\" with index 2 for depth 3, calling_frame == (B)\n-   where the parent region for each of the frames is the \"stack\" region.\n-   The index is the count of frames earlier than this in the stack.  */\n-\n-class frame_region : public space_region\n-{\n-public:\n-  /* A support class for uniquifying instances of frame_region.  */\n-  struct key_t\n-  {\n-    key_t (const frame_region *calling_frame, function *fun)\n-    : m_calling_frame (calling_frame), m_fun (fun)\n-    {\n-      /* calling_frame can be NULL.  */\n-      gcc_assert (fun);\n-    }\n-\n-    hashval_t hash () const\n-    {\n-      inchash::hash hstate;\n-      hstate.add_ptr (m_calling_frame);\n-      hstate.add_ptr (m_fun);\n-      return hstate.end ();\n-    }\n-\n-    bool operator== (const key_t &other) const\n-    {\n-      return (m_calling_frame == other.m_calling_frame && m_fun == other.m_fun);\n-    }\n-\n-    void mark_deleted () { m_fun = reinterpret_cast<function *> (1); }\n-    void mark_empty () { m_fun = NULL; }\n-    bool is_deleted () const\n-    {\n-      return m_fun == reinterpret_cast<function *> (1);\n-    }\n-    bool is_empty () const { return m_fun == NULL; }\n-\n-    const frame_region *m_calling_frame;\n-    function *m_fun;\n-  };\n-\n-  frame_region (unsigned id, const region *parent,\n-\t\tconst frame_region *calling_frame,\n-\t\tfunction *fun, int index)\n-  : space_region (id, parent), m_calling_frame (calling_frame),\n-    m_fun (fun), m_index (index)\n-  {}\n-  ~frame_region ();\n-\n-  /* region vfuncs.  */\n-  enum region_kind get_kind () const FINAL OVERRIDE { return RK_FRAME; }\n-  const frame_region * dyn_cast_frame_region () const FINAL OVERRIDE\n-  {\n-    return this;\n-  }\n-  void accept (visitor *v) const FINAL OVERRIDE;\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-\n-  /* Accessors.  */\n-  const frame_region *get_calling_frame () const { return m_calling_frame; }\n-  function *get_function () const { return m_fun; }\n-  int get_index () const { return m_index; }\n-  int get_stack_depth () const { return m_index + 1; }\n-\n-  const decl_region *get_region_for_local (region_model_manager *mgr,\n-\t\t\t\t\t   tree expr) const;\n-\n-  unsigned get_num_locals () const { return m_locals.elements (); }\n-\n- private:\n-  const frame_region *m_calling_frame;\n-  function *m_fun;\n-  int m_index;\n-\n-  /* The regions for the decls within this frame are managed by this\n-     object, rather than the region_model_manager, to make it a simple\n-     lookup by tree.  */\n-  typedef hash_map<tree, decl_region *> map_t;\n-  map_t m_locals;\n-};\n-\n-} // namespace ana\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <const frame_region *>::test (const region *reg)\n-{\n-  return reg->get_kind () == RK_FRAME;\n-}\n-\n-template <> struct default_hash_traits<frame_region::key_t>\n-: public member_function_hash_traits<frame_region::key_t>\n-{\n-  static const bool empty_zero_p = true;\n-};\n-\n-namespace ana {\n-\n-/* Concrete space_region subclass, to hold global variables (data and bss).  */\n-\n-class globals_region : public space_region\n-{\n- public:\n-  globals_region (unsigned id, const region *parent)\n-  : space_region (id, parent)\n-  {}\n-\n-  /* region vfuncs.  */\n-  enum region_kind get_kind () const FINAL OVERRIDE { return RK_GLOBALS; }\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-};\n-\n-} // namespace ana\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <const globals_region *>::test (const region *reg)\n-{\n-  return reg->get_kind () == RK_GLOBALS;\n-}\n-\n-namespace ana {\n-\n-/* Concrete space_region subclass, representing the code segment\n-   containing functions.  */\n-\n-class code_region : public space_region\n-{\n-public:\n-  code_region (unsigned id, const region *parent)\n-  : space_region (id, parent)\n-  {}\n-\n-  /* region vfuncs.  */\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-  enum region_kind get_kind () const FINAL OVERRIDE { return RK_CODE; }\n-\n-  const region *get_element (region_model *model,\n-\t\t\tconst svalue *index,\n-\t\t\tregion_model_context *ctxt);\n-};\n-\n-} // namespace ana\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <const code_region *>::test (const region *reg)\n-{\n-  return reg->get_kind () == RK_CODE;\n-}\n-\n-namespace ana {\n-\n-/* Concrete region subclass.  A region representing the code for\n-   a particular function.  */\n-\n-class function_region : public region\n-{\n-public:\n-  function_region (unsigned id, const code_region *parent, tree fndecl)\n-  : region (complexity (parent), id, parent, TREE_TYPE (fndecl)),\n-    m_fndecl (fndecl)\n-  {\n-    gcc_assert (FUNC_OR_METHOD_TYPE_P (TREE_TYPE (fndecl)));\n-  }\n-\n-  /* region vfuncs.  */\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-  enum region_kind get_kind () const FINAL OVERRIDE { return RK_FUNCTION; }\n-  const function_region *\n-  dyn_cast_function_region () const FINAL OVERRIDE{ return this; }\n-\n-  tree get_fndecl () const { return m_fndecl; }\n-\n-  region *get_element (region_model *model,\n-\t\t\tconst svalue *index_sid,\n-\t\t\tregion_model_context *ctxt);\n-\n-private:\n-  tree m_fndecl;\n-};\n-\n-} // namespace ana\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <const function_region *>::test (const region *reg)\n-{\n-  return reg->get_kind () == RK_FUNCTION;\n-}\n-\n-namespace ana {\n-\n-/* Concrete region subclass.  A region representing a particular label\n-   within a function.  */\n-\n-class label_region : public region\n-{\n-public:\n-  label_region (unsigned id, const function_region *parent, tree label)\n-  : region (complexity (parent), id, parent, NULL_TREE), m_label (label)\n-  {\n-    gcc_assert (TREE_CODE (label) == LABEL_DECL);\n-  }\n-\n-  /* region vfuncs.  */\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-  enum region_kind get_kind () const FINAL OVERRIDE { return RK_LABEL; }\n-\n-  tree get_label () const { return m_label; }\n-\n-private:\n-  tree m_label;\n-};\n-\n-} // namespace ana\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <const label_region *>::test (const region *reg)\n-{\n-  return reg->get_kind () == RK_LABEL;\n-}\n-\n-namespace ana {\n-\n-/* Concrete space_region subclass representing a stack, containing all stack\n-   frames.  */\n-\n-class stack_region : public space_region\n-{\n-public:\n-  stack_region (unsigned id, region *parent)\n-  : space_region (id, parent)\n-  {}\n-\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-\n-  enum region_kind get_kind () const FINAL OVERRIDE { return RK_STACK; }\n-};\n-\n-} // namespace ana\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <const stack_region *>::test (const region *reg)\n-{\n-  return reg->get_kind () == RK_STACK;\n-}\n-\n-namespace ana {\n-\n-/* Concrete space_region subclass: a region within which regions can be\n-   dynamically allocated.  */\n-\n-class heap_region : public space_region\n-{\n-public:\n-  heap_region (unsigned id, region *parent)\n-  : space_region (id, parent)\n-  {}\n-\n-  enum region_kind get_kind () const FINAL OVERRIDE { return RK_HEAP; }\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-};\n-\n-} // namespace ana\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <const heap_region *>::test (const region *reg)\n-{\n-  return reg->get_kind () == RK_HEAP;\n-}\n-\n-namespace ana {\n-\n-/* Concrete region subclass.  The root region, containing all regions\n-   (either directly, or as descendents).\n-   Unique within a region_model_manager.  */\n-\n-class root_region : public region\n-{\n-public:\n-  root_region (unsigned id);\n-\n-  enum region_kind get_kind () const FINAL OVERRIDE { return RK_ROOT; }\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-};\n-\n-} // namespace ana\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <const root_region *>::test (const region *reg)\n-{\n-  return reg->get_kind () == RK_ROOT;\n-}\n-\n-namespace ana {\n-\n-/* Concrete region subclass: a region to use when dereferencing an unknown\n-   pointer.  */\n-\n-class symbolic_region : public region\n-{\n-public:\n-  /* A support class for uniquifying instances of symbolic_region.  */\n-  struct key_t\n-  {\n-    key_t (const region *parent, const svalue *sval_ptr)\n-    : m_parent (parent), m_sval_ptr (sval_ptr)\n-    {\n-      gcc_assert (sval_ptr);\n-    }\n-\n-    hashval_t hash () const\n-    {\n-      inchash::hash hstate;\n-      hstate.add_ptr (m_parent);\n-      hstate.add_ptr (m_sval_ptr);\n-      return hstate.end ();\n-    }\n-\n-    bool operator== (const key_t &other) const\n-    {\n-      return (m_parent == other.m_parent && m_sval_ptr == other.m_sval_ptr);\n-    }\n-\n-    void mark_deleted () { m_sval_ptr = reinterpret_cast<const svalue *> (1); }\n-    void mark_empty () { m_sval_ptr = NULL; }\n-    bool is_deleted () const\n-    {\n-      return m_sval_ptr == reinterpret_cast<const svalue *> (1);\n-    }\n-    bool is_empty () const { return m_sval_ptr == NULL; }\n-\n-    const region *m_parent;\n-    const svalue *m_sval_ptr;\n-  };\n-\n-  symbolic_region (unsigned id, region *parent, const svalue *sval_ptr)\n-  : region (complexity::from_pair (parent, sval_ptr), id, parent,\n-\t    TREE_TYPE (sval_ptr->get_type ())),\n-    m_sval_ptr (sval_ptr)\n-  {}\n-\n-  const symbolic_region *\n-  dyn_cast_symbolic_region () const FINAL OVERRIDE { return this; }\n-\n-  enum region_kind get_kind () const FINAL OVERRIDE { return RK_SYMBOLIC; }\n-  void accept (visitor *v) const FINAL OVERRIDE;\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-\n-  const svalue *get_pointer () const { return m_sval_ptr; }\n-\n-private:\n-  const svalue *m_sval_ptr;\n-};\n-\n-} // namespace ana\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <const symbolic_region *>::test (const region *reg)\n-{\n-  return reg->get_kind () == RK_SYMBOLIC;\n-}\n-\n-template <> struct default_hash_traits<symbolic_region::key_t>\n-: public member_function_hash_traits<symbolic_region::key_t>\n-{\n-  static const bool empty_zero_p = true;\n-};\n-\n-namespace ana {\n-\n-/* Concrete region subclass representing the memory occupied by a\n-   variable (whether for a global or a local).  */\n-\n-class decl_region : public region\n-{\n-public:\n-  decl_region (unsigned id, const region *parent, tree decl)\n-  : region (complexity (parent), id, parent, TREE_TYPE (decl)), m_decl (decl)\n-  {}\n-\n-  enum region_kind get_kind () const FINAL OVERRIDE { return RK_DECL; }\n-  const decl_region *\n-  dyn_cast_decl_region () const FINAL OVERRIDE { return this; }\n-\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-\n-  tree get_decl () const { return m_decl; }\n-  int get_stack_depth () const;\n-\n-  const svalue *maybe_get_constant_value (region_model_manager *mgr) const;\n-  const svalue *get_svalue_for_constructor (tree ctor,\n-\t\t\t\t\t    region_model_manager *mgr) const;\n-  const svalue *get_svalue_for_initializer (region_model_manager *mgr) const;\n-\n-private:\n-  tree m_decl;\n-};\n-\n-} // namespace ana\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <const decl_region *>::test (const region *reg)\n-{\n-  return reg->get_kind () == RK_DECL;\n-}\n-\n-namespace ana {\n-\n-/* Concrete region subclass representing the memory occupied by a\n-   field within a struct or union.  */\n-\n-class field_region : public region\n-{\n-public:\n-  /* A support class for uniquifying instances of field_region.  */\n-  struct key_t\n-  {\n-    key_t (const region *parent, tree field)\n-    : m_parent (parent), m_field (field)\n-    {\n-      gcc_assert (field);\n-    }\n-\n-    hashval_t hash () const\n-    {\n-      inchash::hash hstate;\n-      hstate.add_ptr (m_parent);\n-      hstate.add_ptr (m_field);\n-      return hstate.end ();\n-    }\n-\n-    bool operator== (const key_t &other) const\n-    {\n-      return (m_parent == other.m_parent && m_field == other.m_field);\n-    }\n-\n-    void mark_deleted () { m_field = reinterpret_cast<tree> (1); }\n-    void mark_empty () { m_field = NULL_TREE; }\n-    bool is_deleted () const { return m_field == reinterpret_cast<tree> (1); }\n-    bool is_empty () const { return m_field == NULL_TREE; }\n-\n-    const region *m_parent;\n-    tree m_field;\n-  };\n-\n-  field_region (unsigned id, const region *parent, tree field)\n-  : region (complexity (parent), id, parent, TREE_TYPE (field)),\n-    m_field (field)\n-  {}\n-\n-  enum region_kind get_kind () const FINAL OVERRIDE { return RK_FIELD; }\n-\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-  const field_region *\n-  dyn_cast_field_region () const FINAL OVERRIDE { return this; }\n-\n-  tree get_field () const { return m_field; }\n-\n-private:\n-  tree m_field;\n-};\n-\n-} // namespace ana\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <const field_region *>::test (const region *reg)\n-{\n-  return reg->get_kind () == RK_FIELD;\n-}\n-\n-template <> struct default_hash_traits<field_region::key_t>\n-: public member_function_hash_traits<field_region::key_t>\n-{\n-  static const bool empty_zero_p = true;\n-};\n-\n-namespace ana {\n-\n-/* An element within an array.  */\n-\n-class element_region : public region\n-{\n-public:\n-  /* A support class for uniquifying instances of element_region.  */\n-  struct key_t\n-  {\n-    key_t (const region *parent, tree element_type, const svalue *index)\n-    : m_parent (parent), m_element_type (element_type), m_index (index)\n-    {\n-      gcc_assert (index);\n-    }\n-\n-    hashval_t hash () const\n-    {\n-      inchash::hash hstate;\n-      hstate.add_ptr (m_parent);\n-      hstate.add_ptr (m_element_type);\n-      hstate.add_ptr (m_index);\n-      return hstate.end ();\n-    }\n-\n-    bool operator== (const key_t &other) const\n-    {\n-      return (m_parent == other.m_parent\n-\t      && m_element_type == other.m_element_type\n-\t      && m_index == other.m_index);\n-    }\n-\n-    void mark_deleted () { m_index = reinterpret_cast<const svalue *> (1); }\n-    void mark_empty () { m_index = NULL; }\n-    bool is_deleted () const\n-    {\n-      return m_index == reinterpret_cast<const svalue *> (1);\n-    }\n-    bool is_empty () const { return m_index == NULL; }\n-\n-    const region *m_parent;\n-    tree m_element_type;\n-    const svalue *m_index;\n-  };\n-\n-  element_region (unsigned id, const region *parent, tree element_type,\n-\t\t  const svalue *index)\n-  : region (complexity::from_pair (parent, index), id, parent, element_type),\n-    m_index (index)\n-  {}\n-\n-  enum region_kind get_kind () const FINAL OVERRIDE { return RK_ELEMENT; }\n-  const element_region *\n-  dyn_cast_element_region () const FINAL OVERRIDE { return this; }\n-\n-  void accept (visitor *v) const FINAL OVERRIDE;\n-\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-\n-  const svalue *get_index () const { return m_index; }\n-\n-private:\n-  const svalue *m_index;\n-};\n-\n-} // namespace ana\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <const element_region *>::test (const region *reg)\n-{\n-  return reg->get_kind () == RK_ELEMENT;\n-}\n-\n-template <> struct default_hash_traits<element_region::key_t>\n-: public member_function_hash_traits<element_region::key_t>\n-{\n-  static const bool empty_zero_p = true;\n-};\n-\n-namespace ana {\n-\n-/* A byte-offset within another region, for handling pointer arithmetic\n-   as a region.  */\n-\n-class offset_region : public region\n-{\n-public:\n-  /* A support class for uniquifying instances of offset_region.  */\n-  struct key_t\n-  {\n-    key_t (const region *parent, tree element_type, const svalue *byte_offset)\n-    : m_parent (parent), m_element_type (element_type), m_byte_offset (byte_offset)\n-    {\n-      gcc_assert (byte_offset);\n-    }\n-\n-    hashval_t hash () const\n-    {\n-      inchash::hash hstate;\n-      hstate.add_ptr (m_parent);\n-      hstate.add_ptr (m_element_type);\n-      hstate.add_ptr (m_byte_offset);\n-      return hstate.end ();\n-    }\n-\n-    bool operator== (const key_t &other) const\n-    {\n-      return (m_parent == other.m_parent\n-\t      && m_element_type == other.m_element_type\n-\t      && m_byte_offset == other.m_byte_offset);\n-    }\n-\n-    void mark_deleted () { m_byte_offset = reinterpret_cast<const svalue *> (1); }\n-    void mark_empty () { m_byte_offset = NULL; }\n-    bool is_deleted () const\n-    {\n-      return m_byte_offset == reinterpret_cast<const svalue *> (1);\n-    }\n-    bool is_empty () const { return m_byte_offset == NULL; }\n-\n-    const region *m_parent;\n-    tree m_element_type;\n-    const svalue *m_byte_offset;\n-  };\n-\n-  offset_region (unsigned id, const region *parent, tree type,\n-\t\t const svalue *byte_offset)\n-  : region (complexity::from_pair (parent, byte_offset), id, parent, type),\n-    m_byte_offset (byte_offset)\n-  {}\n-\n-  enum region_kind get_kind () const FINAL OVERRIDE { return RK_OFFSET; }\n-  const offset_region *\n-  dyn_cast_offset_region () const FINAL OVERRIDE { return this; }\n-\n-  void accept (visitor *v) const FINAL OVERRIDE;\n-\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-\n-  const svalue *get_byte_offset () const { return m_byte_offset; }\n-\n-private:\n-  const svalue *m_byte_offset;\n-};\n-\n-} // namespace ana\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <const offset_region *>::test (const region *reg)\n-{\n-  return reg->get_kind () == RK_OFFSET;\n-}\n-\n-template <> struct default_hash_traits<offset_region::key_t>\n-: public member_function_hash_traits<offset_region::key_t>\n-{\n-  static const bool empty_zero_p = true;\n-};\n-\n-namespace ana {\n-\n-/* A region that views another region using a different type.  */\n-\n-class cast_region : public region\n-{\n-public:\n-  /* A support class for uniquifying instances of cast_region.  */\n-  struct key_t\n-  {\n-    key_t (const region *original_region, tree type)\n-    : m_original_region (original_region), m_type (type)\n-    {\n-      gcc_assert (type);\n-    }\n-\n-    hashval_t hash () const\n-    {\n-      inchash::hash hstate;\n-      hstate.add_ptr (m_original_region);\n-      hstate.add_ptr (m_type);\n-      return hstate.end ();\n-    }\n-\n-    bool operator== (const key_t &other) const\n-    {\n-      return (m_original_region == other.m_original_region\n-\t      && m_type == other.m_type);\n-    }\n-\n-    void mark_deleted () { m_type = reinterpret_cast<tree> (1); }\n-    void mark_empty () { m_type = NULL_TREE; }\n-    bool is_deleted () const { return m_type == reinterpret_cast<tree> (1); }\n-    bool is_empty () const { return m_type == NULL_TREE; }\n-\n-    const region *m_original_region;\n-    tree m_type;\n-  };\n-\n-  cast_region (unsigned id, const region *original_region, tree type)\n-  : region (complexity (original_region), id,\n-\t    original_region->get_parent_region (), type),\n-    m_original_region (original_region)\n-  {}\n-\n-  enum region_kind get_kind () const FINAL OVERRIDE { return RK_CAST; }\n-  const cast_region *\n-  dyn_cast_cast_region () const FINAL OVERRIDE { return this; }\n-  void accept (visitor *v) const FINAL OVERRIDE;\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-\n-  const region *get_original_region () const { return m_original_region; }\n-\n-private:\n-  const region *m_original_region;\n-};\n-\n-} // namespace ana\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <const cast_region *>::test (const region *reg)\n-{\n-  return reg->get_kind () == RK_CAST;\n-}\n-\n-template <> struct default_hash_traits<cast_region::key_t>\n-: public member_function_hash_traits<cast_region::key_t>\n-{\n-  static const bool empty_zero_p = true;\n-};\n-\n-namespace ana {\n-\n-/* An untyped region dynamically allocated on the heap via \"malloc\"\n-   or similar.  */\n-\n-class heap_allocated_region : public region\n-{\n-public:\n-  heap_allocated_region (unsigned id, const region *parent)\n-  : region (complexity (parent), id, parent, NULL_TREE)\n-  {}\n-\n-  enum region_kind\n-  get_kind () const FINAL OVERRIDE { return RK_HEAP_ALLOCATED; }\n-\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-};\n-\n-/* An untyped region dynamically allocated on the stack via \"alloca\".  */\n-\n-class alloca_region : public region\n-{\n-public:\n-  alloca_region (unsigned id, const frame_region *parent)\n-  : region (complexity (parent), id, parent, NULL_TREE)\n-  {}\n-\n-  enum region_kind get_kind () const FINAL OVERRIDE { return RK_ALLOCA; }\n-\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-};\n-\n-/* A region for a STRING_CST.  */\n-\n-class string_region : public region\n-{\n-public:\n-  string_region (unsigned id, const region *parent, tree string_cst)\n-  : region (complexity (parent), id, parent, TREE_TYPE (string_cst)),\n-    m_string_cst (string_cst)\n-  {}\n-\n-  const string_region *\n-  dyn_cast_string_region () const FINAL OVERRIDE { return this; }\n-\n-  enum region_kind get_kind () const FINAL OVERRIDE { return RK_STRING; }\n-\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-\n-  tree get_string_cst () const { return m_string_cst; }\n-\n-private:\n-  tree m_string_cst;\n-};\n-\n-} // namespace ana\n-\n-template <>\n-template <>\n-inline bool\n-is_a_helper <const string_region *>::test (const region *reg)\n-{\n-  return reg->get_kind () == RK_STRING;\n-}\n-\n-namespace ana {\n-\n-/* An unknown region, for handling unimplemented tree codes.  */\n-\n-class unknown_region : public region\n-{\n-public:\n-  unknown_region (unsigned id, const region *parent, tree type)\n-  : region (complexity (parent), id, parent, type)\n-  {}\n-\n-  enum region_kind get_kind () const FINAL OVERRIDE { return RK_UNKNOWN; }\n-\n-  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n-};\n-\n /* A class responsible for owning and consolidating region and svalue\n    instances.\n    region and svalue instances are immutable as far as clients are"}, {"sha": "cce366de56b911317fbcc2a14689a0e8f5b60958", "filename": "gcc/analyzer/region.cc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9751143e237b507a81234a573a200ea45e7111a/gcc%2Fanalyzer%2Fregion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9751143e237b507a81234a573a200ea45e7111a/gcc%2Fanalyzer%2Fregion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion.cc?ref=e9751143e237b507a81234a573a200ea45e7111a", "patch": "@@ -57,6 +57,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/call-string.h\"\n #include \"analyzer/program-point.h\"\n #include \"analyzer/store.h\"\n+#include \"analyzer/region.h\"\n #include \"analyzer/region-model.h\"\n \n #if ENABLE_ANALYZER\n@@ -825,6 +826,16 @@ root_region::dump_to_pp (pretty_printer *pp, bool simple) const\n \n /* class symbolic_region : public map_region.  */\n \n+/* symbolic_region's ctor.  */\n+\n+symbolic_region::symbolic_region (unsigned id, region *parent,\n+\t\t\t\t  const svalue *sval_ptr)\n+: region (complexity::from_pair (parent, sval_ptr), id, parent,\n+\t  TREE_TYPE (sval_ptr->get_type ())),\n+  m_sval_ptr (sval_ptr)\n+{\n+}\n+\n /* Implementation of region::accept vfunc for symbolic_region.  */\n \n void"}, {"sha": "8430650f756b4c8fdf7cea767eec6398a1dd1432", "filename": "gcc/analyzer/region.h", "status": "added", "additions": 1017, "deletions": 0, "changes": 1017, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9751143e237b507a81234a573a200ea45e7111a/gcc%2Fanalyzer%2Fregion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9751143e237b507a81234a573a200ea45e7111a/gcc%2Fanalyzer%2Fregion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion.h?ref=e9751143e237b507a81234a573a200ea45e7111a", "patch": "@@ -0,0 +1,1017 @@\n+/* Regions of memory.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_REGION_H\n+#define GCC_ANALYZER_REGION_H\n+\n+#include \"analyzer/complexity.h\"\n+\n+namespace ana {\n+\n+/* An enum for discriminating between the different concrete subclasses\n+   of region.  */\n+\n+enum region_kind\n+{\n+  RK_FRAME,\n+  RK_GLOBALS,\n+  RK_CODE,\n+  RK_FUNCTION,\n+  RK_LABEL,\n+  RK_STACK,\n+  RK_HEAP,\n+  RK_ROOT,\n+  RK_SYMBOLIC,\n+  RK_DECL,\n+  RK_FIELD,\n+  RK_ELEMENT,\n+  RK_OFFSET,\n+  RK_CAST,\n+  RK_HEAP_ALLOCATED,\n+  RK_ALLOCA,\n+  RK_STRING,\n+  RK_UNKNOWN\n+};\n+\n+/* Region and its subclasses.\n+\n+   The class hierarchy looks like this (using indentation to show\n+   inheritance, and with region_kinds shown for the concrete subclasses):\n+\n+   region\n+     space_region\n+       frame_region (RK_FRAME)\n+       globals_region (RK_GLOBALS)\n+       code_region (RK_CODE)\n+       stack_region (RK_STACK)\n+       heap_region (RK_HEAP)\n+     root_region (RK_ROOT)\n+     function_region (RK_FUNCTION)\n+     label_region (RK_LABEL)\n+     symbolic_region (RK_SYMBOLIC)\n+     decl_region (RK_DECL),\n+     field_region (RK_FIELD)\n+     element_region (RK_ELEMENT)\n+     offset_region (RK_OFFSET)\n+     cast_region (RK_CAST)\n+     heap_allocated_region (RK_HEAP_ALLOCATED)\n+     alloca_region (RK_ALLOCA)\n+     string_region (RK_STRING)\n+     unknown_region (RK_UNKNOWN).  */\n+\n+/* Abstract base class for representing ways of accessing chunks of memory.\n+\n+   Regions form a tree-like hierarchy, with a root region at the base,\n+   with memory space regions within it, representing the stack and\n+   globals, with frames within the stack, and regions for variables\n+   within the frames and the \"globals\" region.  Regions for structs\n+   can have subregions for fields.  */\n+\n+class region\n+{\n+public:\n+  virtual ~region ();\n+\n+  unsigned get_id () const { return m_id; }\n+  static int cmp_ids (const region *reg1, const region *reg2);\n+\n+  virtual enum region_kind get_kind () const = 0;\n+  virtual const frame_region *\n+  dyn_cast_frame_region () const { return NULL; }\n+  virtual const function_region *\n+  dyn_cast_function_region () const { return NULL; }\n+  virtual const symbolic_region *\n+  dyn_cast_symbolic_region () const { return NULL; }\n+  virtual const decl_region *\n+  dyn_cast_decl_region () const { return NULL; }\n+  virtual const field_region *\n+  dyn_cast_field_region () const { return NULL; }\n+  virtual const element_region *\n+  dyn_cast_element_region () const { return NULL; }\n+  virtual const offset_region *\n+  dyn_cast_offset_region () const { return NULL; }\n+  virtual const cast_region *\n+  dyn_cast_cast_region () const { return NULL; }\n+  virtual const string_region *\n+  dyn_cast_string_region () const { return NULL; }\n+\n+  virtual void accept (visitor *v) const;\n+\n+  const region *get_parent_region () const { return m_parent; }\n+  const region *get_base_region () const;\n+  bool base_region_p () const;\n+  bool descendent_of_p (const region *elder) const;\n+  const frame_region *maybe_get_frame_region () const;\n+\n+  tree maybe_get_decl () const;\n+\n+  tree get_type () const { return m_type; }\n+\n+  void print (const region_model &model,\n+\t      pretty_printer *pp) const;\n+  label_text get_desc (bool simple=true) const;\n+\n+  void dump_to_pp (const region_model &model,\n+\t\t   pretty_printer *pp,\n+\t\t   const char *prefix,\n+\t\t   bool is_last_child) const;\n+\n+  virtual void dump_to_pp (pretty_printer *pp, bool simple) const = 0;\n+  void dump (bool simple) const;\n+\n+  json::value *to_json () const;\n+\n+  bool non_null_p () const;\n+\n+  static int cmp_ptr_ptr (const void *, const void *);\n+\n+  region_offset get_offset () const;\n+  bool get_byte_size (byte_size_t *out) const;\n+  bool get_bit_size (bit_size_t *out) const;\n+\n+  void\n+  get_subregions_for_binding (region_model_manager *mgr,\n+\t\t\t      bit_offset_t start_bit_offset,\n+\t\t\t      bit_size_t size_in_bits,\n+\t\t\t      tree type,\n+\t\t\t      auto_vec <const region *> *out) const;\n+\n+  bool symbolic_for_unknown_ptr_p () const;\n+\n+  const complexity &get_complexity () const { return m_complexity; }\n+\n+ protected:\n+  region (complexity c, unsigned id, const region *parent, tree type);\n+\n+ private:\n+  region_offset calc_offset () const;\n+\n+  complexity m_complexity;\n+  unsigned m_id; // purely for deterministic sorting at this stage, for dumps\n+  const region *m_parent;\n+  tree m_type;\n+\n+  mutable region_offset *m_cached_offset;\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const region *>::test (const region *)\n+{\n+  return true;\n+}\n+\n+namespace ana {\n+\n+/* Abstract subclass of region, for regions that represent an untyped\n+   space within memory, such as the stack or the heap.  */\n+\n+class space_region : public region\n+{\n+protected:\n+  space_region (unsigned id, const region *parent)\n+  : region (complexity (parent), id, parent, NULL_TREE)\n+  {}\n+};\n+\n+/* Concrete space_region subclass, representing a function frame on the stack,\n+   to contain the locals.\n+   The parent is the stack region; there's also a hierarchy of call-stack\n+   prefixes expressed via m_calling_frame.\n+   For example, given \"oldest\" calling \"middle\" called \"newest\" we would have\n+   - a stack depth of 3\n+   - frame (A) for \"oldest\" with index 0 for depth 1, calling_frame == NULL\n+   - frame (B) for \"middle\" with index 1 for depth 2, calling_frame == (A)\n+   - frame (C) for \"newest\" with index 2 for depth 3, calling_frame == (B)\n+   where the parent region for each of the frames is the \"stack\" region.\n+   The index is the count of frames earlier than this in the stack.  */\n+\n+class frame_region : public space_region\n+{\n+public:\n+  /* A support class for uniquifying instances of frame_region.  */\n+  struct key_t\n+  {\n+    key_t (const frame_region *calling_frame, function *fun)\n+    : m_calling_frame (calling_frame), m_fun (fun)\n+    {\n+      /* calling_frame can be NULL.  */\n+      gcc_assert (fun);\n+    }\n+\n+    hashval_t hash () const\n+    {\n+      inchash::hash hstate;\n+      hstate.add_ptr (m_calling_frame);\n+      hstate.add_ptr (m_fun);\n+      return hstate.end ();\n+    }\n+\n+    bool operator== (const key_t &other) const\n+    {\n+      return (m_calling_frame == other.m_calling_frame && m_fun == other.m_fun);\n+    }\n+\n+    void mark_deleted () { m_fun = reinterpret_cast<function *> (1); }\n+    void mark_empty () { m_fun = NULL; }\n+    bool is_deleted () const\n+    {\n+      return m_fun == reinterpret_cast<function *> (1);\n+    }\n+    bool is_empty () const { return m_fun == NULL; }\n+\n+    const frame_region *m_calling_frame;\n+    function *m_fun;\n+  };\n+\n+  frame_region (unsigned id, const region *parent,\n+\t\tconst frame_region *calling_frame,\n+\t\tfunction *fun, int index)\n+  : space_region (id, parent), m_calling_frame (calling_frame),\n+    m_fun (fun), m_index (index)\n+  {}\n+  ~frame_region ();\n+\n+  /* region vfuncs.  */\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_FRAME; }\n+  const frame_region * dyn_cast_frame_region () const FINAL OVERRIDE\n+  {\n+    return this;\n+  }\n+  void accept (visitor *v) const FINAL OVERRIDE;\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+\n+  /* Accessors.  */\n+  const frame_region *get_calling_frame () const { return m_calling_frame; }\n+  function *get_function () const { return m_fun; }\n+  int get_index () const { return m_index; }\n+  int get_stack_depth () const { return m_index + 1; }\n+\n+  const decl_region *get_region_for_local (region_model_manager *mgr,\n+\t\t\t\t\t   tree expr) const;\n+\n+  unsigned get_num_locals () const { return m_locals.elements (); }\n+\n+ private:\n+  const frame_region *m_calling_frame;\n+  function *m_fun;\n+  int m_index;\n+\n+  /* The regions for the decls within this frame are managed by this\n+     object, rather than the region_model_manager, to make it a simple\n+     lookup by tree.  */\n+  typedef hash_map<tree, decl_region *> map_t;\n+  map_t m_locals;\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const frame_region *>::test (const region *reg)\n+{\n+  return reg->get_kind () == RK_FRAME;\n+}\n+\n+template <> struct default_hash_traits<frame_region::key_t>\n+: public member_function_hash_traits<frame_region::key_t>\n+{\n+  static const bool empty_zero_p = true;\n+};\n+\n+namespace ana {\n+\n+/* Concrete space_region subclass, to hold global variables (data and bss).  */\n+\n+class globals_region : public space_region\n+{\n+ public:\n+  globals_region (unsigned id, const region *parent)\n+  : space_region (id, parent)\n+  {}\n+\n+  /* region vfuncs.  */\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_GLOBALS; }\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const globals_region *>::test (const region *reg)\n+{\n+  return reg->get_kind () == RK_GLOBALS;\n+}\n+\n+namespace ana {\n+\n+/* Concrete space_region subclass, representing the code segment\n+   containing functions.  */\n+\n+class code_region : public space_region\n+{\n+public:\n+  code_region (unsigned id, const region *parent)\n+  : space_region (id, parent)\n+  {}\n+\n+  /* region vfuncs.  */\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_CODE; }\n+\n+  const region *get_element (region_model *model,\n+\t\t\tconst svalue *index,\n+\t\t\tregion_model_context *ctxt);\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const code_region *>::test (const region *reg)\n+{\n+  return reg->get_kind () == RK_CODE;\n+}\n+\n+namespace ana {\n+\n+/* Concrete region subclass.  A region representing the code for\n+   a particular function.  */\n+\n+class function_region : public region\n+{\n+public:\n+  function_region (unsigned id, const code_region *parent, tree fndecl)\n+  : region (complexity (parent), id, parent, TREE_TYPE (fndecl)),\n+    m_fndecl (fndecl)\n+  {\n+    gcc_assert (FUNC_OR_METHOD_TYPE_P (TREE_TYPE (fndecl)));\n+  }\n+\n+  /* region vfuncs.  */\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_FUNCTION; }\n+  const function_region *\n+  dyn_cast_function_region () const FINAL OVERRIDE{ return this; }\n+\n+  tree get_fndecl () const { return m_fndecl; }\n+\n+  region *get_element (region_model *model,\n+\t\t\tconst svalue *index_sid,\n+\t\t\tregion_model_context *ctxt);\n+\n+private:\n+  tree m_fndecl;\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const function_region *>::test (const region *reg)\n+{\n+  return reg->get_kind () == RK_FUNCTION;\n+}\n+\n+namespace ana {\n+\n+/* Concrete region subclass.  A region representing a particular label\n+   within a function.  */\n+\n+class label_region : public region\n+{\n+public:\n+  label_region (unsigned id, const function_region *parent, tree label)\n+  : region (complexity (parent), id, parent, NULL_TREE), m_label (label)\n+  {\n+    gcc_assert (TREE_CODE (label) == LABEL_DECL);\n+  }\n+\n+  /* region vfuncs.  */\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_LABEL; }\n+\n+  tree get_label () const { return m_label; }\n+\n+private:\n+  tree m_label;\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const label_region *>::test (const region *reg)\n+{\n+  return reg->get_kind () == RK_LABEL;\n+}\n+\n+namespace ana {\n+\n+/* Concrete space_region subclass representing a stack, containing all stack\n+   frames.  */\n+\n+class stack_region : public space_region\n+{\n+public:\n+  stack_region (unsigned id, region *parent)\n+  : space_region (id, parent)\n+  {}\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_STACK; }\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const stack_region *>::test (const region *reg)\n+{\n+  return reg->get_kind () == RK_STACK;\n+}\n+\n+namespace ana {\n+\n+/* Concrete space_region subclass: a region within which regions can be\n+   dynamically allocated.  */\n+\n+class heap_region : public space_region\n+{\n+public:\n+  heap_region (unsigned id, region *parent)\n+  : space_region (id, parent)\n+  {}\n+\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_HEAP; }\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const heap_region *>::test (const region *reg)\n+{\n+  return reg->get_kind () == RK_HEAP;\n+}\n+\n+namespace ana {\n+\n+/* Concrete region subclass.  The root region, containing all regions\n+   (either directly, or as descendents).\n+   Unique within a region_model_manager.  */\n+\n+class root_region : public region\n+{\n+public:\n+  root_region (unsigned id);\n+\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_ROOT; }\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const root_region *>::test (const region *reg)\n+{\n+  return reg->get_kind () == RK_ROOT;\n+}\n+\n+namespace ana {\n+\n+/* Concrete region subclass: a region to use when dereferencing an unknown\n+   pointer.  */\n+\n+class symbolic_region : public region\n+{\n+public:\n+  /* A support class for uniquifying instances of symbolic_region.  */\n+  struct key_t\n+  {\n+    key_t (const region *parent, const svalue *sval_ptr)\n+    : m_parent (parent), m_sval_ptr (sval_ptr)\n+    {\n+      gcc_assert (sval_ptr);\n+    }\n+\n+    hashval_t hash () const\n+    {\n+      inchash::hash hstate;\n+      hstate.add_ptr (m_parent);\n+      hstate.add_ptr (m_sval_ptr);\n+      return hstate.end ();\n+    }\n+\n+    bool operator== (const key_t &other) const\n+    {\n+      return (m_parent == other.m_parent && m_sval_ptr == other.m_sval_ptr);\n+    }\n+\n+    void mark_deleted () { m_sval_ptr = reinterpret_cast<const svalue *> (1); }\n+    void mark_empty () { m_sval_ptr = NULL; }\n+    bool is_deleted () const\n+    {\n+      return m_sval_ptr == reinterpret_cast<const svalue *> (1);\n+    }\n+    bool is_empty () const { return m_sval_ptr == NULL; }\n+\n+    const region *m_parent;\n+    const svalue *m_sval_ptr;\n+  };\n+\n+  symbolic_region (unsigned id, region *parent, const svalue *sval_ptr);\n+\n+  const symbolic_region *\n+  dyn_cast_symbolic_region () const FINAL OVERRIDE { return this; }\n+\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_SYMBOLIC; }\n+  void accept (visitor *v) const FINAL OVERRIDE;\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+\n+  const svalue *get_pointer () const { return m_sval_ptr; }\n+\n+private:\n+  const svalue *m_sval_ptr;\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const symbolic_region *>::test (const region *reg)\n+{\n+  return reg->get_kind () == RK_SYMBOLIC;\n+}\n+\n+template <> struct default_hash_traits<symbolic_region::key_t>\n+: public member_function_hash_traits<symbolic_region::key_t>\n+{\n+  static const bool empty_zero_p = true;\n+};\n+\n+namespace ana {\n+\n+/* Concrete region subclass representing the memory occupied by a\n+   variable (whether for a global or a local).  */\n+\n+class decl_region : public region\n+{\n+public:\n+  decl_region (unsigned id, const region *parent, tree decl)\n+  : region (complexity (parent), id, parent, TREE_TYPE (decl)), m_decl (decl)\n+  {}\n+\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_DECL; }\n+  const decl_region *\n+  dyn_cast_decl_region () const FINAL OVERRIDE { return this; }\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+\n+  tree get_decl () const { return m_decl; }\n+  int get_stack_depth () const;\n+\n+  const svalue *maybe_get_constant_value (region_model_manager *mgr) const;\n+  const svalue *get_svalue_for_constructor (tree ctor,\n+\t\t\t\t\t    region_model_manager *mgr) const;\n+  const svalue *get_svalue_for_initializer (region_model_manager *mgr) const;\n+\n+private:\n+  tree m_decl;\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const decl_region *>::test (const region *reg)\n+{\n+  return reg->get_kind () == RK_DECL;\n+}\n+\n+namespace ana {\n+\n+/* Concrete region subclass representing the memory occupied by a\n+   field within a struct or union.  */\n+\n+class field_region : public region\n+{\n+public:\n+  /* A support class for uniquifying instances of field_region.  */\n+  struct key_t\n+  {\n+    key_t (const region *parent, tree field)\n+    : m_parent (parent), m_field (field)\n+    {\n+      gcc_assert (field);\n+    }\n+\n+    hashval_t hash () const\n+    {\n+      inchash::hash hstate;\n+      hstate.add_ptr (m_parent);\n+      hstate.add_ptr (m_field);\n+      return hstate.end ();\n+    }\n+\n+    bool operator== (const key_t &other) const\n+    {\n+      return (m_parent == other.m_parent && m_field == other.m_field);\n+    }\n+\n+    void mark_deleted () { m_field = reinterpret_cast<tree> (1); }\n+    void mark_empty () { m_field = NULL_TREE; }\n+    bool is_deleted () const { return m_field == reinterpret_cast<tree> (1); }\n+    bool is_empty () const { return m_field == NULL_TREE; }\n+\n+    const region *m_parent;\n+    tree m_field;\n+  };\n+\n+  field_region (unsigned id, const region *parent, tree field)\n+  : region (complexity (parent), id, parent, TREE_TYPE (field)),\n+    m_field (field)\n+  {}\n+\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_FIELD; }\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+  const field_region *\n+  dyn_cast_field_region () const FINAL OVERRIDE { return this; }\n+\n+  tree get_field () const { return m_field; }\n+\n+private:\n+  tree m_field;\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const field_region *>::test (const region *reg)\n+{\n+  return reg->get_kind () == RK_FIELD;\n+}\n+\n+template <> struct default_hash_traits<field_region::key_t>\n+: public member_function_hash_traits<field_region::key_t>\n+{\n+  static const bool empty_zero_p = true;\n+};\n+\n+namespace ana {\n+\n+/* An element within an array.  */\n+\n+class element_region : public region\n+{\n+public:\n+  /* A support class for uniquifying instances of element_region.  */\n+  struct key_t\n+  {\n+    key_t (const region *parent, tree element_type, const svalue *index)\n+    : m_parent (parent), m_element_type (element_type), m_index (index)\n+    {\n+      gcc_assert (index);\n+    }\n+\n+    hashval_t hash () const\n+    {\n+      inchash::hash hstate;\n+      hstate.add_ptr (m_parent);\n+      hstate.add_ptr (m_element_type);\n+      hstate.add_ptr (m_index);\n+      return hstate.end ();\n+    }\n+\n+    bool operator== (const key_t &other) const\n+    {\n+      return (m_parent == other.m_parent\n+\t      && m_element_type == other.m_element_type\n+\t      && m_index == other.m_index);\n+    }\n+\n+    void mark_deleted () { m_index = reinterpret_cast<const svalue *> (1); }\n+    void mark_empty () { m_index = NULL; }\n+    bool is_deleted () const\n+    {\n+      return m_index == reinterpret_cast<const svalue *> (1);\n+    }\n+    bool is_empty () const { return m_index == NULL; }\n+\n+    const region *m_parent;\n+    tree m_element_type;\n+    const svalue *m_index;\n+  };\n+\n+  element_region (unsigned id, const region *parent, tree element_type,\n+\t\t  const svalue *index)\n+  : region (complexity::from_pair (parent, index), id, parent, element_type),\n+    m_index (index)\n+  {}\n+\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_ELEMENT; }\n+  const element_region *\n+  dyn_cast_element_region () const FINAL OVERRIDE { return this; }\n+\n+  void accept (visitor *v) const FINAL OVERRIDE;\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+\n+  const svalue *get_index () const { return m_index; }\n+\n+private:\n+  const svalue *m_index;\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const element_region *>::test (const region *reg)\n+{\n+  return reg->get_kind () == RK_ELEMENT;\n+}\n+\n+template <> struct default_hash_traits<element_region::key_t>\n+: public member_function_hash_traits<element_region::key_t>\n+{\n+  static const bool empty_zero_p = true;\n+};\n+\n+namespace ana {\n+\n+/* A byte-offset within another region, for handling pointer arithmetic\n+   as a region.  */\n+\n+class offset_region : public region\n+{\n+public:\n+  /* A support class for uniquifying instances of offset_region.  */\n+  struct key_t\n+  {\n+    key_t (const region *parent, tree element_type, const svalue *byte_offset)\n+    : m_parent (parent), m_element_type (element_type), m_byte_offset (byte_offset)\n+    {\n+      gcc_assert (byte_offset);\n+    }\n+\n+    hashval_t hash () const\n+    {\n+      inchash::hash hstate;\n+      hstate.add_ptr (m_parent);\n+      hstate.add_ptr (m_element_type);\n+      hstate.add_ptr (m_byte_offset);\n+      return hstate.end ();\n+    }\n+\n+    bool operator== (const key_t &other) const\n+    {\n+      return (m_parent == other.m_parent\n+\t      && m_element_type == other.m_element_type\n+\t      && m_byte_offset == other.m_byte_offset);\n+    }\n+\n+    void mark_deleted () { m_byte_offset = reinterpret_cast<const svalue *> (1); }\n+    void mark_empty () { m_byte_offset = NULL; }\n+    bool is_deleted () const\n+    {\n+      return m_byte_offset == reinterpret_cast<const svalue *> (1);\n+    }\n+    bool is_empty () const { return m_byte_offset == NULL; }\n+\n+    const region *m_parent;\n+    tree m_element_type;\n+    const svalue *m_byte_offset;\n+  };\n+\n+  offset_region (unsigned id, const region *parent, tree type,\n+\t\t const svalue *byte_offset)\n+  : region (complexity::from_pair (parent, byte_offset), id, parent, type),\n+    m_byte_offset (byte_offset)\n+  {}\n+\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_OFFSET; }\n+  const offset_region *\n+  dyn_cast_offset_region () const FINAL OVERRIDE { return this; }\n+\n+  void accept (visitor *v) const FINAL OVERRIDE;\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+\n+  const svalue *get_byte_offset () const { return m_byte_offset; }\n+\n+private:\n+  const svalue *m_byte_offset;\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const offset_region *>::test (const region *reg)\n+{\n+  return reg->get_kind () == RK_OFFSET;\n+}\n+\n+template <> struct default_hash_traits<offset_region::key_t>\n+: public member_function_hash_traits<offset_region::key_t>\n+{\n+  static const bool empty_zero_p = true;\n+};\n+\n+namespace ana {\n+\n+/* A region that views another region using a different type.  */\n+\n+class cast_region : public region\n+{\n+public:\n+  /* A support class for uniquifying instances of cast_region.  */\n+  struct key_t\n+  {\n+    key_t (const region *original_region, tree type)\n+    : m_original_region (original_region), m_type (type)\n+    {\n+      gcc_assert (type);\n+    }\n+\n+    hashval_t hash () const\n+    {\n+      inchash::hash hstate;\n+      hstate.add_ptr (m_original_region);\n+      hstate.add_ptr (m_type);\n+      return hstate.end ();\n+    }\n+\n+    bool operator== (const key_t &other) const\n+    {\n+      return (m_original_region == other.m_original_region\n+\t      && m_type == other.m_type);\n+    }\n+\n+    void mark_deleted () { m_type = reinterpret_cast<tree> (1); }\n+    void mark_empty () { m_type = NULL_TREE; }\n+    bool is_deleted () const { return m_type == reinterpret_cast<tree> (1); }\n+    bool is_empty () const { return m_type == NULL_TREE; }\n+\n+    const region *m_original_region;\n+    tree m_type;\n+  };\n+\n+  cast_region (unsigned id, const region *original_region, tree type)\n+  : region (complexity (original_region), id,\n+\t    original_region->get_parent_region (), type),\n+    m_original_region (original_region)\n+  {}\n+\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_CAST; }\n+  const cast_region *\n+  dyn_cast_cast_region () const FINAL OVERRIDE { return this; }\n+  void accept (visitor *v) const FINAL OVERRIDE;\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+\n+  const region *get_original_region () const { return m_original_region; }\n+\n+private:\n+  const region *m_original_region;\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const cast_region *>::test (const region *reg)\n+{\n+  return reg->get_kind () == RK_CAST;\n+}\n+\n+template <> struct default_hash_traits<cast_region::key_t>\n+: public member_function_hash_traits<cast_region::key_t>\n+{\n+  static const bool empty_zero_p = true;\n+};\n+\n+namespace ana {\n+\n+/* An untyped region dynamically allocated on the heap via \"malloc\"\n+   or similar.  */\n+\n+class heap_allocated_region : public region\n+{\n+public:\n+  heap_allocated_region (unsigned id, const region *parent)\n+  : region (complexity (parent), id, parent, NULL_TREE)\n+  {}\n+\n+  enum region_kind\n+  get_kind () const FINAL OVERRIDE { return RK_HEAP_ALLOCATED; }\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+};\n+\n+/* An untyped region dynamically allocated on the stack via \"alloca\".  */\n+\n+class alloca_region : public region\n+{\n+public:\n+  alloca_region (unsigned id, const frame_region *parent)\n+  : region (complexity (parent), id, parent, NULL_TREE)\n+  {}\n+\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_ALLOCA; }\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+};\n+\n+/* A region for a STRING_CST.  */\n+\n+class string_region : public region\n+{\n+public:\n+  string_region (unsigned id, const region *parent, tree string_cst)\n+  : region (complexity (parent), id, parent, TREE_TYPE (string_cst)),\n+    m_string_cst (string_cst)\n+  {}\n+\n+  const string_region *\n+  dyn_cast_string_region () const FINAL OVERRIDE { return this; }\n+\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_STRING; }\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+\n+  tree get_string_cst () const { return m_string_cst; }\n+\n+private:\n+  tree m_string_cst;\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const string_region *>::test (const region *reg)\n+{\n+  return reg->get_kind () == RK_STRING;\n+}\n+\n+namespace ana {\n+\n+/* An unknown region, for handling unimplemented tree codes.  */\n+\n+class unknown_region : public region\n+{\n+public:\n+  unknown_region (unsigned id, const region *parent, tree type)\n+  : region (complexity (parent), id, parent, type)\n+  {}\n+\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_UNKNOWN; }\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+};\n+\n+} // namespace ana\n+\n+#endif /* GCC_ANALYZER_REGION_H */"}, {"sha": "18d9c376f5e3bef06ce0a2a8cb45e6e6465cfbdc", "filename": "gcc/analyzer/svalue.cc", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9751143e237b507a81234a573a200ea45e7111a/gcc%2Fanalyzer%2Fsvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9751143e237b507a81234a573a200ea45e7111a/gcc%2Fanalyzer%2Fsvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsvalue.cc?ref=e9751143e237b507a81234a573a200ea45e7111a", "patch": "@@ -52,42 +52,13 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/call-string.h\"\n #include \"analyzer/program-point.h\"\n #include \"analyzer/store.h\"\n+#include \"analyzer/svalue.h\"\n #include \"analyzer/region-model.h\"\n \n #if ENABLE_ANALYZER\n \n namespace ana {\n \n-/* struct complexity.  */\n-\n-/* Get complexity for a new node that references REG\n-   (the complexity of REG, plus one for the new node).  */\n-\n-complexity::complexity (const region *reg)\n-: m_num_nodes (reg->get_complexity ().m_num_nodes + 1),\n-  m_max_depth (reg->get_complexity ().m_max_depth + 1)\n-{\n-}\n-\n-/* Get complexity for a new node that references SVAL.\n-   (the complexity of SVAL, plus one for the new node).  */\n-\n-complexity::complexity (const svalue *sval)\n-: m_num_nodes (sval->get_complexity ().m_num_nodes + 1),\n-  m_max_depth (sval->get_complexity ().m_max_depth + 1)\n-{\n-}\n-\n-/* Get complexity for a new node that references nodes with complexity\n-   C1 and C2.  */\n-\n-complexity\n-complexity::from_pair (const complexity &c1, const complexity &c2)\n-{\n-  return complexity (c1.m_num_nodes + c2.m_num_nodes + 1,\n-\t\t     MAX (c1.m_max_depth, c2.m_max_depth) + 1);\n-}\n-\n /* class svalue and its various subclasses.  */\n \n /* class svalue.  */"}, {"sha": "b519d26a77de722fa35e3d631a3ca9570e098887", "filename": "gcc/analyzer/svalue.h", "status": "added", "additions": 1150, "deletions": 0, "changes": 1150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9751143e237b507a81234a573a200ea45e7111a/gcc%2Fanalyzer%2Fsvalue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9751143e237b507a81234a573a200ea45e7111a/gcc%2Fanalyzer%2Fsvalue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsvalue.h?ref=e9751143e237b507a81234a573a200ea45e7111a", "patch": "@@ -0,0 +1,1150 @@\n+/* Symbolic values.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_SVALUE_H\n+#define GCC_ANALYZER_SVALUE_H\n+\n+#include \"analyzer/complexity.h\"\n+\n+using namespace ana;\n+\n+namespace ana {\n+\n+/* An enum for discriminating between the different concrete subclasses\n+   of svalue.  */\n+\n+enum svalue_kind\n+{\n+  SK_REGION,\n+  SK_CONSTANT,\n+  SK_UNKNOWN,\n+  SK_POISONED,\n+  SK_SETJMP,\n+  SK_INITIAL,\n+  SK_UNARYOP,\n+  SK_BINOP,\n+  SK_SUB,\n+  SK_UNMERGEABLE,\n+  SK_PLACEHOLDER,\n+  SK_WIDENING,\n+  SK_COMPOUND,\n+  SK_CONJURED\n+};\n+\n+/* svalue and its subclasses.\n+\n+   The class hierarchy looks like this (using indentation to show\n+   inheritance, and with svalue_kinds shown for the concrete subclasses):\n+\n+   svalue\n+     region_svalue (SK_REGION): a pointer to a region\n+     constant_svalue (SK_CONSTANT): a constant\n+     unknown_svalue (SK_UNKNOWN): an unknowable value\n+     poisoned_svalue (SK_POISONED): a unusable value (undefined)\n+     setjmp_svalue (SK_SETJMP): a setjmp/longjmp buffer\n+     initial_svalue (SK_INITIAL): the initial value of a region\n+     unaryop_svalue (SK_UNARYOP): unary operation on another svalue\n+     binop_svalue (SK_BINOP): binary operation on two svalues\n+     sub_svalue (SK_SUB): the result of accessing a subregion\n+     unmergeable_svalue (SK_UNMERGEABLE): a value that is so interesting\n+       from a control-flow perspective that it can inhibit state-merging\n+     placeholder_svalue (SK_PLACEHOLDER): for use in selftests.\n+     widening_svalue (SK_WIDENING): a merger of two svalues (possibly\n+       in an iteration).\n+     compound_svalue (SK_COMPOUND): a mapping of bit-ranges to svalues\n+     conjured_svalue (SK_CONJURED): a value arising from a stmt.  */\n+\n+/* An abstract base class representing a value held by a region of memory.  */\n+\n+class svalue\n+{\n+public:\n+  virtual ~svalue () {}\n+\n+  tree get_type () const { return m_type; }\n+\n+  virtual enum svalue_kind get_kind () const = 0;\n+\n+  void print (const region_model &model,\n+\t      pretty_printer *pp) const;\n+\n+  virtual void dump_to_pp (pretty_printer *pp, bool simple) const = 0;\n+  void dump (bool simple=true) const;\n+  label_text get_desc (bool simple=true) const;\n+\n+  json::value *to_json () const;\n+\n+  virtual const region_svalue *\n+  dyn_cast_region_svalue () const { return NULL; }\n+  virtual const constant_svalue *\n+  dyn_cast_constant_svalue () const { return NULL; }\n+  virtual const poisoned_svalue *\n+  dyn_cast_poisoned_svalue () const { return NULL; }\n+  virtual const setjmp_svalue *\n+  dyn_cast_setjmp_svalue () const { return NULL; }\n+  virtual const initial_svalue *\n+  dyn_cast_initial_svalue () const { return NULL; }\n+  virtual const unaryop_svalue *\n+  dyn_cast_unaryop_svalue () const { return NULL; }\n+  virtual const binop_svalue *\n+  dyn_cast_binop_svalue () const { return NULL; }\n+  virtual const sub_svalue *\n+  dyn_cast_sub_svalue () const { return NULL; }\n+  virtual const unmergeable_svalue *\n+  dyn_cast_unmergeable_svalue () const { return NULL; }\n+  virtual const widening_svalue *\n+  dyn_cast_widening_svalue () const { return NULL; }\n+  virtual const compound_svalue *\n+  dyn_cast_compound_svalue () const { return NULL; }\n+  virtual const conjured_svalue *\n+  dyn_cast_conjured_svalue () const { return NULL; }\n+\n+  tree maybe_get_constant () const;\n+  const svalue *maybe_undo_cast () const;\n+  const svalue *unwrap_any_unmergeable () const;\n+\n+  const svalue *can_merge_p (const svalue *other,\n+\t\t\t      region_model_manager *mgr,\n+\t\t\t      model_merger *merger) const;\n+\n+  const complexity &get_complexity () const { return m_complexity; }\n+\n+  virtual void accept (visitor *v) const  = 0;\n+\n+  bool live_p (const svalue_set &live_svalues,\n+\t       const region_model *model) const;\n+  virtual bool implicitly_live_p (const svalue_set &live_svalues,\n+\t\t\t\t  const region_model *model) const;\n+\n+  static int cmp_ptr (const svalue *, const svalue *);\n+  static int cmp_ptr_ptr (const void *, const void *);\n+\n+ protected:\n+  svalue (complexity c, tree type)\n+  : m_complexity (c), m_type (type)\n+  {}\n+\n+ private:\n+  complexity m_complexity;\n+  tree m_type;\n+};\n+\n+/* Concrete subclass of svalue representing a pointer value that points to\n+   a known region  */\n+\n+class region_svalue : public svalue\n+{\n+public:\n+  /* A support class for uniquifying instances of region_svalue.  */\n+  struct key_t\n+  {\n+    key_t (tree type, const region *reg)\n+    : m_type (type), m_reg (reg)\n+    {}\n+\n+    hashval_t hash () const\n+    {\n+      inchash::hash hstate;\n+      hstate.add_ptr (m_type);\n+      hstate.add_ptr (m_reg);\n+      return hstate.end ();\n+    }\n+\n+    bool operator== (const key_t &other) const\n+    {\n+      return (m_type == other.m_type && m_reg == other.m_reg);\n+    }\n+\n+    void mark_deleted () { m_type = reinterpret_cast<tree> (1); }\n+    void mark_empty () { m_type = NULL_TREE; }\n+    bool is_deleted () const { return m_type == reinterpret_cast<tree> (1); }\n+    bool is_empty () const { return m_type == NULL_TREE; }\n+\n+    tree m_type;\n+    const region *m_reg;\n+  };\n+\n+  region_svalue (tree type, const region *reg)\n+  : svalue (complexity (reg), type),\n+    m_reg (reg)\n+  {\n+    gcc_assert (m_reg != NULL);\n+  }\n+\n+  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_REGION; }\n+  const region_svalue *\n+  dyn_cast_region_svalue () const FINAL OVERRIDE { return this; }\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+  void accept (visitor *v) const FINAL OVERRIDE;\n+\n+  const region * get_pointee () const { return m_reg; }\n+\n+  static tristate eval_condition (const region_svalue *lhs_ptr,\n+\t\t\t\t  enum tree_code op,\n+\t\t\t\t  const region_svalue *rhs_ptr);\n+\n+ private:\n+  const region *m_reg;\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const region_svalue *>::test (const svalue *sval)\n+{\n+  return sval->get_kind () == SK_REGION;\n+}\n+\n+template <> struct default_hash_traits<region_svalue::key_t>\n+: public member_function_hash_traits<region_svalue::key_t>\n+{\n+  static const bool empty_zero_p = true;\n+};\n+\n+namespace ana {\n+\n+/* Concrete subclass of svalue representing a specific constant value.  */\n+\n+class constant_svalue : public svalue\n+{\n+public:\n+  constant_svalue (tree cst_expr)\n+  : svalue (complexity (1, 1), TREE_TYPE (cst_expr)), m_cst_expr (cst_expr)\n+  {\n+    gcc_assert (cst_expr);\n+    gcc_assert (CONSTANT_CLASS_P (cst_expr));\n+  }\n+\n+  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_CONSTANT; }\n+  const constant_svalue *\n+  dyn_cast_constant_svalue () const FINAL OVERRIDE { return this; }\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+  void accept (visitor *v) const FINAL OVERRIDE;\n+  bool implicitly_live_p (const svalue_set &,\n+\t\t\t  const region_model *) const FINAL OVERRIDE;\n+\n+  tree get_constant () const { return m_cst_expr; }\n+  static tristate eval_condition (const constant_svalue *lhs,\n+\t\t\t\t  enum tree_code op,\n+\t\t\t\t  const constant_svalue *rhs);\n+\n+ private:\n+  tree m_cst_expr;\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const constant_svalue *>::test (const svalue *sval)\n+{\n+  return sval->get_kind () == SK_CONSTANT;\n+}\n+\n+namespace ana {\n+\n+/* Concrete subclass of svalue representing an unknowable value, the bottom\n+   value when thinking of svalues as a lattice.\n+   This is a singleton (w.r.t. its manager): there is a single unknown_svalue\n+   per type.  Self-comparisons of such instances yield \"unknown\".  */\n+\n+class unknown_svalue : public svalue\n+{\n+public:\n+  unknown_svalue (tree type)\n+  : svalue (complexity (1, 1), type)\n+  {}\n+\n+  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_UNKNOWN; }\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+  void accept (visitor *v) const FINAL OVERRIDE;\n+};\n+\n+/* An enum describing a particular kind of \"poisoned\" value.  */\n+\n+enum poison_kind\n+{\n+  /* For use to describe freed memory.  */\n+  POISON_KIND_FREED,\n+\n+  /* For use on pointers to regions within popped stack frames.  */\n+  POISON_KIND_POPPED_STACK\n+};\n+\n+extern const char *poison_kind_to_str (enum poison_kind);\n+\n+/* Concrete subclass of svalue representing a value that should not\n+   be used (e.g. uninitialized memory, freed memory).  */\n+\n+class poisoned_svalue : public svalue\n+{\n+public:\n+  /* A support class for uniquifying instances of poisoned_svalue.  */\n+  struct key_t\n+  {\n+    key_t (enum poison_kind kind, tree type)\n+    : m_kind (kind), m_type (type)\n+    {}\n+\n+    hashval_t hash () const\n+    {\n+      inchash::hash hstate;\n+      hstate.add_int (m_kind);\n+      hstate.add_ptr (m_type);\n+      return hstate.end ();\n+    }\n+\n+    bool operator== (const key_t &other) const\n+    {\n+      return (m_kind == other.m_kind && m_type == other.m_type);\n+    }\n+\n+    void mark_deleted () { m_type = reinterpret_cast<tree> (1); }\n+    void mark_empty () { m_type = NULL_TREE; }\n+    bool is_deleted () const { return m_type == reinterpret_cast<tree> (1); }\n+    bool is_empty () const { return m_type == NULL_TREE; }\n+\n+    enum poison_kind m_kind;\n+    tree m_type;\n+  };\n+\n+  poisoned_svalue (enum poison_kind kind, tree type)\n+  : svalue (complexity (1, 1), type), m_kind (kind) {}\n+\n+  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_POISONED; }\n+  const poisoned_svalue *\n+  dyn_cast_poisoned_svalue () const FINAL OVERRIDE { return this; }\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+  void accept (visitor *v) const FINAL OVERRIDE;\n+\n+  enum poison_kind get_poison_kind () const { return m_kind; }\n+\n+ private:\n+  enum poison_kind m_kind;\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const poisoned_svalue *>::test (const svalue *sval)\n+{\n+  return sval->get_kind () == SK_POISONED;\n+}\n+\n+template <> struct default_hash_traits<poisoned_svalue::key_t>\n+: public member_function_hash_traits<poisoned_svalue::key_t>\n+{\n+  static const bool empty_zero_p = true;\n+};\n+\n+namespace ana {\n+\n+/* A bundle of information recording a setjmp/sigsetjmp call, corresponding\n+   roughly to a jmp_buf.  */\n+\n+struct setjmp_record\n+{\n+  setjmp_record (const exploded_node *enode,\n+\t\t const gcall *setjmp_call)\n+  : m_enode (enode), m_setjmp_call (setjmp_call)\n+  {\n+  }\n+\n+  bool operator== (const setjmp_record &other) const\n+  {\n+    return (m_enode == other.m_enode\n+\t    && m_setjmp_call == other.m_setjmp_call);\n+  }\n+\n+  void add_to_hash (inchash::hash *hstate) const\n+  {\n+    hstate->add_ptr (m_enode);\n+    hstate->add_ptr (m_setjmp_call);\n+  }\n+\n+  static int cmp (const setjmp_record &rec1, const setjmp_record &rec2);\n+\n+  const exploded_node *m_enode;\n+  const gcall *m_setjmp_call;\n+};\n+\n+/* Concrete subclass of svalue representing buffers for setjmp/sigsetjmp,\n+   so that longjmp/siglongjmp can potentially \"return\" to an entirely\n+   different function.  */\n+\n+class setjmp_svalue : public svalue\n+{\n+public:\n+  /* A support class for uniquifying instances of poisoned_svalue.  */\n+  struct key_t\n+  {\n+    key_t (const setjmp_record &record, tree type)\n+    : m_record (record), m_type (type)\n+    {}\n+\n+    hashval_t hash () const\n+    {\n+      inchash::hash hstate;\n+      m_record.add_to_hash (&hstate);\n+      hstate.add_ptr (m_type);\n+      return hstate.end ();\n+    }\n+\n+    bool operator== (const key_t &other) const\n+    {\n+      return (m_record == other.m_record && m_type == other.m_type);\n+    }\n+\n+    void mark_deleted () { m_type = reinterpret_cast<tree> (1); }\n+    void mark_empty () { m_type = NULL_TREE; }\n+    bool is_deleted () const { return m_type == reinterpret_cast<tree> (1); }\n+    bool is_empty () const { return m_type == NULL_TREE; }\n+\n+    setjmp_record m_record;\n+    tree m_type;\n+  };\n+\n+  setjmp_svalue (const setjmp_record &setjmp_record,\n+\t\t  tree type)\n+  : svalue (complexity (1, 1), type), m_setjmp_record (setjmp_record)\n+  {}\n+\n+  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_SETJMP; }\n+  const setjmp_svalue *\n+  dyn_cast_setjmp_svalue () const FINAL OVERRIDE { return this; }\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+  void accept (visitor *v) const FINAL OVERRIDE;\n+\n+  int get_enode_index () const;\n+\n+  const setjmp_record &get_setjmp_record () const { return m_setjmp_record; }\n+\n+ private:\n+  setjmp_record m_setjmp_record;\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const setjmp_svalue *>::test (const svalue *sval)\n+{\n+  return sval->get_kind () == SK_SETJMP;\n+}\n+\n+template <> struct default_hash_traits<setjmp_svalue::key_t>\n+: public member_function_hash_traits<setjmp_svalue::key_t>\n+{\n+  static const bool empty_zero_p = true;\n+};\n+\n+namespace ana {\n+\n+/* Concrete subclass of svalue representing the initial value of a\n+   specific region.\n+\n+   This represents the initial value at the start of the analysis path,\n+   as opposed to the first time the region is accessed during the path.\n+   Hence as soon as we have a call to an unknown function, all previously\n+   unmodelled globals become implicitly \"unknown\" rathen than \"initial\".  */\n+\n+class initial_svalue : public svalue\n+{\n+public:\n+  initial_svalue (tree type, const region *reg)\n+  : svalue (complexity (reg), type), m_reg (reg)\n+  {\n+    gcc_assert (m_reg != NULL);\n+  }\n+\n+  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_INITIAL; }\n+  const initial_svalue *\n+  dyn_cast_initial_svalue () const FINAL OVERRIDE { return this; }\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+  void accept (visitor *v) const FINAL OVERRIDE;\n+  bool implicitly_live_p (const svalue_set &,\n+\t\t\t  const region_model *) const FINAL OVERRIDE;\n+\n+  const region *get_region () const { return m_reg; }\n+\n+ private:\n+  const region *m_reg;\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const initial_svalue *>::test (const svalue *sval)\n+{\n+  return sval->get_kind () == SK_INITIAL;\n+}\n+\n+namespace ana {\n+\n+/* Concrete subclass of svalue representing a unary operation on\n+   another svalues (e.g. a cast).  */\n+\n+class unaryop_svalue : public svalue\n+{\n+public:\n+  /* A support class for uniquifying instances of unaryop_svalue.  */\n+  struct key_t\n+  {\n+    key_t (tree type, enum tree_code op, const svalue *arg)\n+    : m_type (type), m_op (op), m_arg (arg)\n+    {}\n+\n+    hashval_t hash () const\n+    {\n+      inchash::hash hstate;\n+      hstate.add_ptr (m_type);\n+      hstate.add_int (m_op);\n+      hstate.add_ptr (m_arg);\n+      return hstate.end ();\n+    }\n+\n+    bool operator== (const key_t &other) const\n+    {\n+      return (m_type == other.m_type\n+\t      && m_op == other.m_op\n+\t      && m_arg == other.m_arg);\n+    }\n+\n+    void mark_deleted () { m_type = reinterpret_cast<tree> (1); }\n+    void mark_empty () { m_type = NULL_TREE; }\n+    bool is_deleted () const { return m_type == reinterpret_cast<tree> (1); }\n+    bool is_empty () const { return m_type == NULL_TREE; }\n+\n+    tree m_type;\n+    enum tree_code m_op;\n+    const svalue *m_arg;\n+  };\n+\n+  unaryop_svalue (tree type, enum tree_code op, const svalue *arg)\n+  : svalue (complexity (arg), type), m_op (op), m_arg (arg)\n+  {\n+  }\n+\n+  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_UNARYOP; }\n+  const unaryop_svalue *\n+  dyn_cast_unaryop_svalue () const FINAL OVERRIDE { return this; }\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+  void accept (visitor *v) const FINAL OVERRIDE;\n+  bool implicitly_live_p (const svalue_set &,\n+\t\t\t  const region_model *) const FINAL OVERRIDE;\n+\n+  enum tree_code get_op () const { return m_op; }\n+  const svalue *get_arg () const { return m_arg; }\n+\n+ private:\n+  enum tree_code m_op;\n+  const svalue *m_arg;\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const unaryop_svalue *>::test (const svalue *sval)\n+{\n+  return sval->get_kind () == SK_UNARYOP;\n+}\n+\n+template <> struct default_hash_traits<unaryop_svalue::key_t>\n+: public member_function_hash_traits<unaryop_svalue::key_t>\n+{\n+  static const bool empty_zero_p = true;\n+};\n+\n+namespace ana {\n+\n+/* Concrete subclass of svalue representing a binary operation of\n+   two svalues.  */\n+\n+class binop_svalue : public svalue\n+{\n+public:\n+  /* A support class for uniquifying instances of binop_svalue.  */\n+  struct key_t\n+  {\n+    key_t (tree type, enum tree_code op,\n+\t   const svalue *arg0, const svalue *arg1)\n+    : m_type (type), m_op (op), m_arg0 (arg0), m_arg1 (arg1)\n+    {}\n+\n+    hashval_t hash () const\n+    {\n+      inchash::hash hstate;\n+      hstate.add_ptr (m_type);\n+      hstate.add_int (m_op);\n+      hstate.add_ptr (m_arg0);\n+      hstate.add_ptr (m_arg1);\n+      return hstate.end ();\n+    }\n+\n+    bool operator== (const key_t &other) const\n+    {\n+      return (m_type == other.m_type\n+\t      && m_op == other.m_op\n+\t      && m_arg0 == other.m_arg0\n+\t      && m_arg1 == other.m_arg1);\n+    }\n+\n+    void mark_deleted () { m_type = reinterpret_cast<tree> (1); }\n+    void mark_empty () { m_type = NULL_TREE; }\n+    bool is_deleted () const { return m_type == reinterpret_cast<tree> (1); }\n+    bool is_empty () const { return m_type == NULL_TREE; }\n+\n+    tree m_type;\n+    enum tree_code m_op;\n+    const svalue *m_arg0;\n+    const svalue *m_arg1;\n+  };\n+\n+  binop_svalue (tree type, enum tree_code op,\n+\t\t const svalue *arg0, const svalue *arg1)\n+  : svalue (complexity::from_pair (arg0->get_complexity (),\n+\t\t\t\t    arg1->get_complexity ()),\n+\t     type),\n+    m_op (op), m_arg0 (arg0), m_arg1 (arg1)\n+  {\n+  }\n+\n+  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_BINOP; }\n+  const binop_svalue *dyn_cast_binop_svalue () const FINAL OVERRIDE\n+  {\n+    return this;\n+  }\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+  void accept (visitor *v) const FINAL OVERRIDE;\n+  bool implicitly_live_p (const svalue_set &,\n+\t\t\t  const region_model *) const FINAL OVERRIDE;\n+\n+  enum tree_code get_op () const { return m_op; }\n+  const svalue *get_arg0 () const { return m_arg0; }\n+  const svalue *get_arg1 () const { return m_arg1; }\n+\n+ private:\n+  enum tree_code m_op;\n+  const svalue *m_arg0;\n+  const svalue *m_arg1;\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const binop_svalue *>::test (const svalue *sval)\n+{\n+  return sval->get_kind () == SK_BINOP;\n+}\n+\n+template <> struct default_hash_traits<binop_svalue::key_t>\n+: public member_function_hash_traits<binop_svalue::key_t>\n+{\n+  static const bool empty_zero_p = true;\n+};\n+\n+namespace ana {\n+\n+/* Concrete subclass of svalue representing the result of accessing a subregion\n+   of another svalue (the value of a component/field of a struct, or an element\n+   from an array).  */\n+\n+class sub_svalue : public svalue\n+{\n+public:\n+  /* A support class for uniquifying instances of sub_svalue.  */\n+  struct key_t\n+  {\n+    key_t (tree type, const svalue *parent_svalue, const region *subregion)\n+    : m_type (type), m_parent_svalue (parent_svalue), m_subregion (subregion)\n+    {}\n+\n+    hashval_t hash () const\n+    {\n+      inchash::hash hstate;\n+      hstate.add_ptr (m_type);\n+      hstate.add_ptr (m_parent_svalue);\n+      hstate.add_ptr (m_subregion);\n+      return hstate.end ();\n+    }\n+\n+    bool operator== (const key_t &other) const\n+    {\n+      return (m_type == other.m_type\n+\t      && m_parent_svalue == other.m_parent_svalue\n+\t      && m_subregion == other.m_subregion);\n+    }\n+\n+    void mark_deleted () { m_type = reinterpret_cast<tree> (1); }\n+    void mark_empty () { m_type = NULL_TREE; }\n+    bool is_deleted () const { return m_type == reinterpret_cast<tree> (1); }\n+    bool is_empty () const { return m_type == NULL_TREE; }\n+\n+    tree m_type;\n+    const svalue *m_parent_svalue;\n+    const region *m_subregion;\n+  };\n+  sub_svalue (tree type, const svalue *parent_svalue,\n+\t       const region *subregion);\n+\n+  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_SUB; }\n+  const sub_svalue *dyn_cast_sub_svalue () const FINAL OVERRIDE\n+  {\n+    return this;\n+  }\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+  void accept (visitor *v) const FINAL OVERRIDE;\n+  bool implicitly_live_p (const svalue_set &,\n+\t\t\t  const region_model *) const FINAL OVERRIDE;\n+\n+  const svalue *get_parent () const { return m_parent_svalue; }\n+  const region *get_subregion () const { return m_subregion; }\n+\n+ private:\n+  const svalue *m_parent_svalue;\n+  const region *m_subregion;\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const sub_svalue *>::test (const svalue *sval)\n+{\n+  return sval->get_kind () == SK_SUB;\n+}\n+\n+template <> struct default_hash_traits<sub_svalue::key_t>\n+: public member_function_hash_traits<sub_svalue::key_t>\n+{\n+  static const bool empty_zero_p = true;\n+};\n+\n+namespace ana {\n+\n+/* Concrete subclass of svalue: decorate another svalue,\n+   so that the resulting svalue can be identified as being\n+   \"interesting to control flow\".\n+   For example, consider the return value from setjmp.  We\n+   don't want to merge states in which the result is 0 with\n+   those in which the result is non-zero.  By using an\n+   unmergeable_svalue for the result, we can inhibit such merges\n+   and have separate exploded nodes for those states, keeping\n+   the first and second returns from setjmp distinct in the exploded\n+   graph.  */\n+\n+class unmergeable_svalue : public svalue\n+{\n+public:\n+  unmergeable_svalue (const svalue *arg)\n+  : svalue (complexity (arg), arg->get_type ()), m_arg (arg)\n+  {\n+  }\n+\n+  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_UNMERGEABLE; }\n+  const unmergeable_svalue *\n+  dyn_cast_unmergeable_svalue () const FINAL OVERRIDE { return this; }\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+  void accept (visitor *v) const FINAL OVERRIDE;\n+  bool implicitly_live_p (const svalue_set &,\n+\t\t\t  const region_model *) const FINAL OVERRIDE;\n+\n+  const svalue *get_arg () const { return m_arg; }\n+\n+ private:\n+  const svalue *m_arg;\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const unmergeable_svalue *>::test (const svalue *sval)\n+{\n+  return sval->get_kind () == SK_UNMERGEABLE;\n+}\n+\n+namespace ana {\n+\n+/* Concrete subclass of svalue for use in selftests, where\n+   we want a specific but unknown svalue.\n+   Unlike other svalue subclasses these aren't managed by\n+   region_model_manager.  */\n+\n+class placeholder_svalue : public svalue\n+{\n+public:\n+  placeholder_svalue (tree type, const char *name)\n+  : svalue (complexity (1, 1), type), m_name (name)\n+  {\n+  }\n+\n+  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_PLACEHOLDER; }\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+  void accept (visitor *v) const FINAL OVERRIDE;\n+\n+  const char *get_name () const { return m_name; }\n+\n+ private:\n+  const char *m_name;\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <placeholder_svalue *>::test (svalue *sval)\n+{\n+  return sval->get_kind () == SK_PLACEHOLDER;\n+}\n+\n+namespace ana {\n+\n+/* Concrete subclass of svalue representing a \"widening\" seen when merging\n+   states, widening from a base value to {base value, iter value} and thus\n+   representing a possible fixed point in an iteration from the base to\n+   +ve infinity, or -ve infinity, and thus useful for representing a value\n+   within a loop.\n+   We also need to capture the program_point at which the merger happens,\n+   so that distinguish between different iterators, and thus handle\n+   nested loops.  (currently we capture the function_point instead, for\n+   simplicity of hashing).  */\n+\n+class widening_svalue : public svalue\n+{\n+public:\n+  /* A support class for uniquifying instances of widening_svalue.  */\n+  struct key_t\n+  {\n+    key_t (tree type, const program_point &point,\n+\t   const svalue *base_sval, const svalue *iter_sval)\n+    : m_type (type), m_point (point.get_function_point ()),\n+      m_base_sval (base_sval), m_iter_sval (iter_sval)\n+    {}\n+\n+    hashval_t hash () const\n+    {\n+      inchash::hash hstate;\n+      hstate.add_ptr (m_base_sval);\n+      hstate.add_ptr (m_iter_sval);\n+      return hstate.end ();\n+    }\n+\n+    bool operator== (const key_t &other) const\n+    {\n+      return (m_type == other.m_type\n+\t      && m_point == other.m_point\n+\t      && m_base_sval == other.m_base_sval\n+\t      && m_iter_sval == other.m_iter_sval);\n+    }\n+\n+    void mark_deleted () { m_type = reinterpret_cast<tree> (1); }\n+    void mark_empty () { m_type = NULL_TREE; }\n+    bool is_deleted () const { return m_type == reinterpret_cast<tree> (1); }\n+    bool is_empty () const { return m_type == NULL_TREE; }\n+\n+    tree m_type;\n+    function_point m_point;\n+    const svalue *m_base_sval;\n+    const svalue *m_iter_sval;\n+  };\n+\n+  enum direction_t\n+    {\n+     DIR_ASCENDING,\n+     DIR_DESCENDING,\n+     DIR_UNKNOWN\n+    };\n+\n+  widening_svalue (tree type, const program_point &point,\n+\t\t   const svalue *base_sval, const svalue *iter_sval)\n+  : svalue (complexity::from_pair (base_sval->get_complexity (),\n+\t\t\t\t   iter_sval->get_complexity ()),\n+\t    type),\n+    m_point (point.get_function_point ()),\n+    m_base_sval (base_sval), m_iter_sval (iter_sval)\n+  {\n+  }\n+\n+  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_WIDENING; }\n+  const widening_svalue *dyn_cast_widening_svalue () const FINAL OVERRIDE\n+  {\n+    return this;\n+  }\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+  void accept (visitor *v) const FINAL OVERRIDE;\n+\n+  const function_point &get_point () const { return m_point; }\n+  const svalue *get_base_svalue () const { return m_base_sval; }\n+  const svalue *get_iter_svalue () const { return m_iter_sval; }\n+\n+  enum direction_t get_direction () const;\n+\n+  tristate eval_condition_without_cm (enum tree_code op,\n+\t\t\t\t      tree rhs_cst) const;\n+\n+ private:\n+  function_point m_point;\n+  const svalue *m_base_sval;\n+  const svalue *m_iter_sval;\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <widening_svalue *>::test (svalue *sval)\n+{\n+  return sval->get_kind () == SK_WIDENING;\n+}\n+\n+template <> struct default_hash_traits<widening_svalue::key_t>\n+: public member_function_hash_traits<widening_svalue::key_t>\n+{\n+  static const bool empty_zero_p = true;\n+};\n+\n+namespace ana {\n+\n+/* Concrete subclass of svalue representing a mapping of bit-ranges\n+   to svalues, analogous to a cluster within the store.\n+\n+   This is for use in places where we want to represent a store-like\n+   mapping, but are required to use an svalue, such as when handling\n+   compound assignments and compound return values.\n+\n+   All keys within the underlying binding_map are required to be concrete,\n+   not symbolic.\n+\n+   Instances of this class shouldn't be bound as-is into the store;\n+   instead they should be unpacked.  Similarly, they should not be\n+   nested.  */\n+\n+class compound_svalue : public svalue\n+{\n+public:\n+  typedef binding_map::iterator_t iterator_t;\n+\n+  /* A support class for uniquifying instances of compound_svalue.\n+     Note that to avoid copies, keys store pointers to binding_maps,\n+     rather than the maps themselves.  */\n+  struct key_t\n+  {\n+    key_t (tree type, const binding_map *map_ptr)\n+    : m_type (type), m_map_ptr (map_ptr)\n+    {}\n+\n+    hashval_t hash () const\n+    {\n+      inchash::hash hstate;\n+      hstate.add_ptr (m_type);\n+      //hstate.add_ptr (m_map_ptr); // TODO\n+      return hstate.end ();\n+    }\n+\n+    bool operator== (const key_t &other) const\n+    {\n+      return (m_type == other.m_type\n+\t      && *m_map_ptr == *other.m_map_ptr);\n+    }\n+\n+    void mark_deleted () { m_type = reinterpret_cast<tree> (1); }\n+    void mark_empty () { m_type = NULL_TREE; }\n+    bool is_deleted () const { return m_type == reinterpret_cast<tree> (1); }\n+    bool is_empty () const { return m_type == NULL_TREE; }\n+\n+    tree m_type;\n+    const binding_map *m_map_ptr;\n+  };\n+\n+  compound_svalue (tree type, const binding_map &map);\n+\n+  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_COMPOUND; }\n+  const compound_svalue *dyn_cast_compound_svalue () const FINAL OVERRIDE\n+  {\n+    return this;\n+  }\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+  void accept (visitor *v) const FINAL OVERRIDE;\n+\n+  const binding_map &get_map () const { return m_map; }\n+\n+  iterator_t begin () const { return m_map.begin (); }\n+  iterator_t end () const { return m_map.end (); }\n+\n+  struct key_t make_key () const\n+  {\n+    return key_t (get_type (), &m_map);\n+  }\n+\n+ private:\n+  static complexity calc_complexity (const binding_map &map);\n+\n+  binding_map m_map;\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <compound_svalue *>::test (svalue *sval)\n+{\n+  return sval->get_kind () == SK_COMPOUND;\n+}\n+\n+template <> struct default_hash_traits<compound_svalue::key_t>\n+: public member_function_hash_traits<compound_svalue::key_t>\n+{\n+  static const bool empty_zero_p = true;\n+};\n+\n+namespace ana {\n+\n+/* A defined value arising from a statement, where we want to identify a\n+   particular unknown value, rather than resorting to the unknown_value\n+   singleton, so that the value can have sm-state.\n+\n+   Comparisons of variables that share the same conjured_svalue are known\n+   to be equal, even if we don't know what the value is.\n+\n+   For example, this is used for the values of regions that may have been\n+   touched when calling an unknown function.\n+\n+   The value captures a region as well as a stmt in order to avoid falsely\n+   aliasing the various values that could arise in one statement.  For\n+   example, after:\n+      unknown_fn (&a, &b);\n+   we want values to clobber a and b with, but we don't want to use the\n+   same value, or it would falsely implicitly assume that a == b.  */\n+\n+class conjured_svalue : public svalue\n+{\n+public:\n+  typedef binding_map::iterator_t iterator_t;\n+\n+  /* A support class for uniquifying instances of conjured_svalue.  */\n+  struct key_t\n+  {\n+    key_t (tree type, const gimple *stmt, const region *id_reg)\n+    : m_type (type), m_stmt (stmt), m_id_reg (id_reg)\n+    {}\n+\n+    hashval_t hash () const\n+    {\n+      inchash::hash hstate;\n+      hstate.add_ptr (m_type);\n+      hstate.add_ptr (m_stmt);\n+      hstate.add_ptr (m_id_reg);\n+      return hstate.end ();\n+    }\n+\n+    bool operator== (const key_t &other) const\n+    {\n+      return (m_type == other.m_type\n+\t      && m_stmt == other.m_stmt\n+\t      && m_id_reg == other.m_id_reg);\n+    }\n+\n+    /* Use m_stmt to mark empty/deleted, as m_type can be NULL for\n+       legitimate instances.  */\n+    void mark_deleted () { m_stmt = reinterpret_cast<const gimple *> (1); }\n+    void mark_empty () { m_stmt = NULL; }\n+    bool is_deleted () const\n+    {\n+      return m_stmt == reinterpret_cast<const gimple *> (1);\n+    }\n+    bool is_empty () const { return m_stmt == NULL; }\n+\n+    tree m_type;\n+    const gimple *m_stmt;\n+    const region *m_id_reg;\n+  };\n+\n+  conjured_svalue (tree type, const gimple *stmt, const region *id_reg)\n+  : svalue (complexity (id_reg), type),\n+    m_stmt (stmt), m_id_reg (id_reg)\n+  {\n+    gcc_assert (m_stmt != NULL);\n+  }\n+\n+  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_CONJURED; }\n+  const conjured_svalue *dyn_cast_conjured_svalue () const FINAL OVERRIDE\n+  {\n+    return this;\n+  }\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+  void accept (visitor *v) const FINAL OVERRIDE;\n+\n+  const gimple *get_stmt () const { return m_stmt; }\n+  const region *get_id_region () const { return m_id_reg; }\n+\n+ private:\n+  const gimple *m_stmt;\n+  const region *m_id_reg;\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <conjured_svalue *>::test (svalue *sval)\n+{\n+  return sval->get_kind () == SK_CONJURED;\n+}\n+\n+template <> struct default_hash_traits<conjured_svalue::key_t>\n+: public member_function_hash_traits<conjured_svalue::key_t>\n+{\n+  static const bool empty_zero_p = true;\n+};\n+\n+#endif /* GCC_ANALYZER_SVALUE_H */"}]}