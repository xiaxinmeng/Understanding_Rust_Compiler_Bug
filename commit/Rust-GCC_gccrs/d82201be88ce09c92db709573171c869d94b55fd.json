{"sha": "d82201be88ce09c92db709573171c869d94b55fd", "node_id": "C_kwDOANBUbNoAKGQ4MjIwMWJlODhjZTA5YzkyZGI3MDk1NzMxNzFjODY5ZDk0YjU1ZmQ", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-07-05T16:53:05Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-07-18T15:24:13Z"}, "message": "resolver: Disambiguate generic args\n\nThis removes all the hacks previously introduced to resolve ambiguous\ngeneric args as types, and adds proper disambiguation.\n\nThe algorithm is as follows:\n\nis that name referring to a type?\n-> disambiguate to a type\nis that name referring to a value?\n-> disambiguate to a const value\nelse\n-> disambiguate to type\n\nSince types are the default expected behavior, this allows us to report\ntype errors properly during typechecking.", "tree": {"sha": "fc9fb4feb468bbbbca8265420e2b2f67ef1fe5be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc9fb4feb468bbbbca8265420e2b2f67ef1fe5be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d82201be88ce09c92db709573171c869d94b55fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d82201be88ce09c92db709573171c869d94b55fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d82201be88ce09c92db709573171c869d94b55fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d82201be88ce09c92db709573171c869d94b55fd/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6920d2294b3c6f106478fd3decaa511faf3cac84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6920d2294b3c6f106478fd3decaa511faf3cac84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6920d2294b3c6f106478fd3decaa511faf3cac84"}], "stats": {"total": 191, "additions": 140, "deletions": 51}, "files": [{"sha": "9332bb6ebfcbfcdfd27afdc0110ce957a7ac7a17", "filename": "gcc/rust/expand/rust-attribute-visitor.cc", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82201be88ce09c92db709573171c869d94b55fd/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82201be88ce09c92db709573171c869d94b55fd/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc?ref=d82201be88ce09c92db709573171c869d94b55fd", "patch": "@@ -134,20 +134,35 @@ AttrVisitor::expand_generic_args (AST::GenericArgs &args)\n   // expand type args - strip sub-types only\n   for (auto &arg : args.get_generic_args ())\n     {\n-      // FIXME: Arthur: Another ugly hack while waiting for disambiguation\n-      if (arg.get_kind () == AST::GenericArg::Kind::Either)\n-\targ = arg.disambiguate_to_type ();\n-\n-      if (arg.get_kind () == AST::GenericArg::Kind::Type)\n+      switch (arg.get_kind ())\n \t{\n-\t  auto &type = arg.get_type ();\n-\n-\t  type->accept_vis (*this);\n-\t  maybe_expand_type (type);\n-\n-\t  if (type->is_marked_for_strip ())\n-\t    rust_error_at (type->get_locus (),\n-\t\t\t   \"cannot strip type in this position\");\n+\t  case AST::GenericArg::Kind::Type: {\n+\t    auto &type = arg.get_type ();\n+\t    type->accept_vis (*this);\n+\t    maybe_expand_type (type);\n+\n+\t    if (type->is_marked_for_strip ())\n+\t      rust_error_at (type->get_locus (),\n+\t\t\t     \"cannot strip type in this position\");\n+\t    break;\n+\t  }\n+\t  case AST::GenericArg::Kind::Const: {\n+\t    auto &expr = arg.get_expression ();\n+\t    expr->accept_vis (*this);\n+\t    maybe_expand_expr (expr);\n+\n+\t    if (expr->is_marked_for_strip ())\n+\t      rust_error_at (expr->get_locus (),\n+\t\t\t     \"cannot strip expression in this position\");\n+\t    break;\n+\t  }\n+\tdefault:\n+\t  break;\n+\t  // FIXME: Figure out what to do here if there is ambiguity. Since the\n+\t  // resolver comes after the expansion, we need to figure out a way to\n+\t  // strip ambiguous values here\n+\t  // TODO: Arthur: Probably add a `mark_as_strip` method to `GenericArg`\n+\t  // or something. This would clean up this whole thing\n \t}\n     }\n "}, {"sha": "e31b95b07bda24294ef5356ad180e250475edb45", "filename": "gcc/rust/hir/rust-ast-lower-base.cc", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82201be88ce09c92db709573171c869d94b55fd/gcc%2Frust%2Fhir%2Frust-ast-lower-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82201be88ce09c92db709573171c869d94b55fd/gcc%2Frust%2Fhir%2Frust-ast-lower-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-base.cc?ref=d82201be88ce09c92db709573171c869d94b55fd", "patch": "@@ -623,13 +623,6 @@ ASTLoweringBase::lower_generic_args (AST::GenericArgs &args)\n \t\t\t\t    expr->get_locus ()));\n \t    break;\n \t  }\n-\t  // FIXME: Arthur: Other horrible hack waiting for disambiguation\n-\t  case AST::GenericArg::Kind::Either: {\n-\t    arg = arg.disambiguate_to_type ();\n-\t    auto type = ASTLoweringType::translate (arg.get_type ().get ());\n-\t    type_args.emplace_back (std::unique_ptr<HIR::Type> (type));\n-\t    break;\n-\t  }\n \tdefault:\n \t  gcc_unreachable ();\n \t}"}, {"sha": "46f765a3ea2cef7d02f10c73fdec5fbad6b77909", "filename": "gcc/rust/hir/rust-ast-lower-type.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82201be88ce09c92db709573171c869d94b55fd/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82201be88ce09c92db709573171c869d94b55fd/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h?ref=d82201be88ce09c92db709573171c869d94b55fd", "patch": "@@ -356,12 +356,9 @@ class ASTLowerGenericParam : public ASTLoweringBase\n \t\t\t\t   mappings->get_next_localdef_id (crate_num));\n \n     auto type = ASTLoweringType::translate (param.get_type ().get ());\n-    // FIXME: Arthur: Remove the second guard once we disambiguate in the\n-    // resolveer\n+\n     HIR::Expr *default_expr = nullptr;\n-    if (param.has_default_value ()\n-\t&& param.get_default_value ().get_kind ()\n-\t     == AST::GenericArg::Kind::Const)\n+    if (param.has_default_value ())\n       default_expr = ASTLoweringExpr::translate (\n \tparam.get_default_value ().get_expression ().get ());\n "}, {"sha": "4cc4e26e3e94bbff6496b96834f35a70830e089a", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82201be88ce09c92db709573171c869d94b55fd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82201be88ce09c92db709573171c869d94b55fd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc?ref=d82201be88ce09c92db709573171c869d94b55fd", "patch": "@@ -87,7 +87,7 @@ ResolveExpr::visit (AST::MethodCallExpr &expr)\n   if (expr.get_method_name ().has_generic_args ())\n     {\n       AST::GenericArgs &args = expr.get_method_name ().get_generic_args ();\n-      ResolveGenericArgs::go (args);\n+      ResolveGenericArgs::go (args, prefix, canonical_prefix);\n     }\n \n   auto const &in_params = expr.get_params ();"}, {"sha": "a8931ce72c2f60998b72381ac0becca52f266aab", "filename": "gcc/rust/resolve/rust-ast-resolve-type.cc", "status": "modified", "additions": 73, "deletions": 25, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82201be88ce09c92db709573171c869d94b55fd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82201be88ce09c92db709573171c869d94b55fd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc?ref=d82201be88ce09c92db709573171c869d94b55fd", "patch": "@@ -384,32 +384,21 @@ ResolveTypeToCanonicalPath::visit (AST::TypePath &path)\n \t    std::vector<CanonicalPath> args;\n \t    if (s->has_generic_args ())\n \t      {\n+\t\tResolveGenericArgs::go (s->get_generic_args ());\n \t\tfor (auto &generic : s->get_generic_args ().get_generic_args ())\n \t\t  {\n \t\t    // FIXME: What do we want to do here in case there is a\n \t\t    // constant or an ambiguous const generic?\n \t\t    // TODO: At that point, will all generics have been\n \t\t    // disambiguated? Can we thus canonical resolve types and\n \t\t    // const and `gcc_unreachable` on ambiguous types?\n-\t\t    //\n-\t\t    // FIXME: Arthur: This is an ugly hack to resolve just as\n-\t\t    // much as before despite not handling ambiguity yet. The\n-\t\t    // calls to `clone_type` will be removed.\n-\t\t    std::unique_ptr<AST::Type> gt = nullptr;\n-\n+\t\t    // This is probably fine as we just want to canonicalize\n+\t\t    // types, right?\n \t\t    if (generic.get_kind () == AST::GenericArg::Kind::Type)\n-\t\t      gt = generic.get_type ()->clone_type ();\n-\t\t    else if (generic.get_kind ()\n-\t\t\t     == AST::GenericArg::Kind::Either)\n-\t\t      gt = generic.disambiguate_to_type ()\n-\t\t\t     .get_type ()\n-\t\t\t     ->clone_type ();\n-\n-\t\t    if (gt)\n \t\t      {\n \t\t\tCanonicalPath arg = CanonicalPath::create_empty ();\n-\t\t\tbool ok\n-\t\t\t  = ResolveTypeToCanonicalPath::go (gt.get (), arg);\n+\t\t\tbool ok = ResolveTypeToCanonicalPath::go (\n+\t\t\t  generic.get_type ().get (), arg);\n \t\t\tif (ok)\n \t\t\t  args.push_back (std::move (arg));\n \t\t      }\n@@ -492,20 +481,79 @@ ResolveTypeToCanonicalPath::ResolveTypeToCanonicalPath ()\n   : ResolverBase (), result (CanonicalPath::create_empty ())\n {}\n \n+bool\n+ResolveGenericArgs::is_const_value_name (const CanonicalPath &path)\n+{\n+  NodeId resolved;\n+  auto found = resolver->get_name_scope ().lookup (path, &resolved);\n+\n+  return found;\n+}\n+\n+bool\n+ResolveGenericArgs::is_type_name (const CanonicalPath &path)\n+{\n+  NodeId resolved;\n+  auto found = resolver->get_type_scope ().lookup (path, &resolved);\n+\n+  return found;\n+}\n+\n void\n-ResolveGenericArgs::go (AST::GenericArgs &args)\n+ResolveGenericArgs::disambiguate (AST::GenericArg &arg)\n {\n-  for (auto &arg : args.get_generic_args ())\n+  auto path = canonical_prefix.append (\n+    CanonicalPath::new_seg (UNKNOWN_NODEID, arg.get_path ()));\n+\n+  auto is_type = is_type_name (path);\n+  auto is_value = is_const_value_name (path);\n+\n+  // In case we cannot find anything, we resolve the ambiguity to a type.\n+  // This causes the typechecker to error out properly and when necessary.\n+  // But types also take priority over const values in the case of\n+  // ambiguities, hence the weird control flow\n+  if (is_type || (!is_type && !is_value))\n+    arg = arg.disambiguate_to_type ();\n+  else if (is_value)\n+    arg = arg.disambiguate_to_const ();\n+}\n+\n+void\n+ResolveGenericArgs::resolve_disambiguated_generic (AST::GenericArg &arg)\n+{\n+  switch (arg.get_kind ())\n     {\n-      // FIXME: Arthur: Ugly hack while waiting for disambiguation\n-      if (arg.get_kind () == AST::GenericArg::Kind::Either)\n-\targ = arg.disambiguate_to_type ();\n+    case AST::GenericArg::Kind::Const:\n+      ResolveExpr::go (arg.get_expression ().get (), prefix, canonical_prefix);\n+      break;\n+    case AST::GenericArg::Kind::Type:\n+      ResolveType::go (arg.get_type ().get ());\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+void\n+ResolveGenericArgs::go (AST::GenericArgs &generic_args)\n+{\n+  auto empty = CanonicalPath::create_empty ();\n \n-      if (arg.get_kind () == AST::GenericArg::Kind::Type)\n-\tResolveType::go (arg.get_type ().get ());\n+  go (generic_args, empty, empty);\n+}\n+\n+void\n+ResolveGenericArgs::go (AST::GenericArgs &generic_args,\n+\t\t\tconst CanonicalPath &prefix,\n+\t\t\tconst CanonicalPath &canonical_prefix)\n+{\n+  auto resolver = ResolveGenericArgs (prefix, canonical_prefix);\n+\n+  for (auto &arg : generic_args.get_generic_args ())\n+    {\n+      if (arg.get_kind () == AST::GenericArg::Kind::Either)\n+\tresolver.disambiguate (arg);\n \n-      // else...\n-      // We need to use a switch instead\n+      resolver.resolve_disambiguated_generic (arg);\n     }\n }\n "}, {"sha": "b57b51386569c8a492c2c00c6d15e1092e34c1d4", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82201be88ce09c92db709573171c869d94b55fd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82201be88ce09c92db709573171c869d94b55fd/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=d82201be88ce09c92db709573171c869d94b55fd", "patch": "@@ -254,6 +254,30 @@ class ResolveGenericArgs : public ResolverBase\n \n public:\n   static void go (AST::GenericArgs &generic_args);\n+  static void go (AST::GenericArgs &generic_args, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix);\n+\n+private:\n+  ResolveGenericArgs (const CanonicalPath &prefix,\n+\t\t      const CanonicalPath &canonical_prefix)\n+    : ResolverBase (), prefix (prefix), canonical_prefix (canonical_prefix)\n+  {}\n+\n+  bool is_type_name (const CanonicalPath &path);\n+  bool is_const_value_name (const CanonicalPath &path);\n+\n+  /**\n+   * Resolve a disambiguated generic arg\n+   */\n+  void disambiguate (AST::GenericArg &arg);\n+\n+  /**\n+   * Resolve a disambiguated generic arg\n+   */\n+  void resolve_disambiguated_generic (AST::GenericArg &arg);\n+\n+  const CanonicalPath &prefix;\n+  const CanonicalPath &canonical_prefix;\n };\n \n } // namespace Resolver"}, {"sha": "5344e31a140499aff5de49c2c0a2f3096fcbc8d1", "filename": "gcc/testsuite/rust/compile/const_generics_5.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82201be88ce09c92db709573171c869d94b55fd/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst_generics_5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82201be88ce09c92db709573171c869d94b55fd/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst_generics_5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst_generics_5.rs?ref=d82201be88ce09c92db709573171c869d94b55fd", "patch": "@@ -0,0 +1,12 @@\n+struct Foo<const N: usize = { 14 }>;\n+\n+const M: usize = 15;\n+type N = Foo<3>;\n+\n+fn main() {\n+    let _: Foo<15> = Foo;\n+    let _: Foo<{ M }> = Foo;\n+    let _: Foo<M> = Foo;\n+    // bogus error, but it means the above const generic gets disambiguated properly\n+    let _: Foo<N> = Foo; // { dg-error \"TypePath Foo<N> declares generic arguments but the type Foo{Foo {}} does not have any\" }\n+}"}]}