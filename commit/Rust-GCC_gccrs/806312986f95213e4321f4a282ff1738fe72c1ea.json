{"sha": "806312986f95213e4321f4a282ff1738fe72c1ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA2MzEyOTg2Zjk1MjEzZTQzMjFmNGEyODJmZjE3MzhmZTcyYzFlYQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2018-01-11T08:51:39Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-01-11T08:51:39Z"}, "message": "[Ada] Different runtime behavior of Predicate_Failure\n\nThis patch corrects the generation of predicate checks to handle the case where\nPredicate_Failure appears as a pragma.\n\n------------\n-- Source --\n------------\n\n--  main.adb\n\nwith Ada.Assertions; use Ada.Assertions;\nwith Ada.Exceptions; use Ada.Exceptions;\nwith Ada.Text_IO;    use Ada.Text_IO;\n\nprocedure Main is\n   subtype Even_Asp is Integer\n     with Predicate => Even_Asp mod 2 = 0,\n          Predicate_Failure => \"Even_Asp failed\";\n\n   subtype Even_Prag is Integer\n     with Predicate => Even_Prag mod 2 = 0;\n   pragma Predicate_Failure (Even_Prag, \"Even_Prag failed\");\n\nbegin\n   begin\n      declare\n         Val : constant Even_Asp := 1;\n      begin\n         Put_Line (\"ERROR: Even_Asp: did not fail\");\n      end;\n   exception\n      when AE : Assertion_Error => Put_Line (Exception_Message (AE));\n      when others => Put_Line (\"ERROR: Even_Asp: raised unexpected error\");\n   end;\n\n   begin\n      declare\n         Val : constant Even_Prag := 3;\n      begin\n         Put_Line (\"ERROR: Even_Prag: did not fail\");\n      end;\n   exception\n      when AE : Assertion_Error => Put_Line (Exception_Message (AE));\n      when others => Put_Line (\"ERROR: Even_Prag: raised unexpected error\");\n   end;\nend Main;\n\n----------------------------\n-- Compilation and output --\n----------------------------\n\n$ gnatmake -q main.adb\n$ ./main\nEven_Asp failed\nEven_Prag failed\n\n2018-01-11  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* exp_util.adb (Add_Failure_Expression): New routine.\n\t(Make_Predicate_Check): Reimplement the handling of Predicate_Failure.\n\t* sem_util.adb (Is_Current_Instance): Code cleanup.\n\nFrom-SVN: r256493", "tree": {"sha": "1d6b19fff5051188563921dccc1eb44ac05b1754", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d6b19fff5051188563921dccc1eb44ac05b1754"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/806312986f95213e4321f4a282ff1738fe72c1ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/806312986f95213e4321f4a282ff1738fe72c1ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/806312986f95213e4321f4a282ff1738fe72c1ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/806312986f95213e4321f4a282ff1738fe72c1ea/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6a5e79b44f0d0d06c793ec200ef3b597b07ebc1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a5e79b44f0d0d06c793ec200ef3b597b07ebc1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a5e79b44f0d0d06c793ec200ef3b597b07ebc1a"}], "stats": {"total": 211, "additions": 171, "deletions": 40}, "files": [{"sha": "7b55c1065fd1ba897cb66d4ae0183e6c861b3a5a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/806312986f95213e4321f4a282ff1738fe72c1ea/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/806312986f95213e4321f4a282ff1738fe72c1ea/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=806312986f95213e4321f4a282ff1738fe72c1ea", "patch": "@@ -1,3 +1,9 @@\n+2018-01-11  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_util.adb (Add_Failure_Expression): New routine.\n+\t(Make_Predicate_Check): Reimplement the handling of Predicate_Failure.\n+\t* sem_util.adb (Is_Current_Instance): Code cleanup.\n+\n 2018-01-11  Patrick Bernardi  <bernardi@adacore.com>\n \n \t* libgnat/s-parame*.adb, libgnat/s-parame*.ads: Remove unneeded"}, {"sha": "dea89c4d1023f2d70bfbb064104d369dabaf5313", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 162, "deletions": 36, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/806312986f95213e4321f4a282ff1738fe72c1ea/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/806312986f95213e4321f4a282ff1738fe72c1ea/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=806312986f95213e4321f4a282ff1738fe72c1ea", "patch": "@@ -9310,36 +9310,172 @@ package body Exp_Util is\n      (Typ  : Entity_Id;\n       Expr : Node_Id) return Node_Id\n    is\n-      procedure Replace_Subtype_Reference (N : Node_Id);\n-      --  Replace current occurrences of the subtype to which a dynamic\n-      --  predicate applies, by the expression that triggers a predicate\n-      --  check. This is needed for aspect Predicate_Failure, for which\n-      --  we do not generate a wrapper procedure, but simply modify the\n-      --  expression for the pragma of the predicate check.\n+      Loc : constant Source_Ptr := Sloc (Expr);\n \n-      --------------------------------\n-      --  Replace_Subtype_Reference --\n-      --------------------------------\n+      procedure Add_Failure_Expression (Args : List_Id);\n+      --  Add the failure expression of pragma Predicate_Failure (if any) to\n+      --  list Args.\n+\n+      ----------------------------\n+      -- Add_Failure_Expression --\n+      ----------------------------\n+\n+      procedure Add_Failure_Expression (Args : List_Id) is\n+         function Failure_Expression return Node_Id;\n+         pragma Inline (Failure_Expression);\n+         --  Find aspect or pragma Predicate_Failure that applies to type Typ\n+         --  and return its expression. Return Empty if no such annotation is\n+         --  available.\n+\n+         function Is_OK_PF_Aspect (Asp : Node_Id) return Boolean;\n+         pragma Inline (Is_OK_PF_Aspect);\n+         --  Determine whether aspect Asp is a suitable Predicate_Failure\n+         --  aspect that applies to type Typ.\n+\n+         function Is_OK_PF_Pragma (Prag : Node_Id) return Boolean;\n+         pragma Inline (Is_OK_PF_Pragma);\n+         --  Determine whether pragma Prag is a suitable Predicate_Failure\n+         --  pragma that applies to type Typ.\n+\n+         procedure Replace_Subtype_Reference (N : Node_Id);\n+         --  Replace the current instance of type Typ denoted by N with\n+         --  expression Expr.\n+\n+         ------------------------\n+         -- Failure_Expression --\n+         ------------------------\n+\n+         function Failure_Expression return Node_Id is\n+            Item : Node_Id;\n+\n+         begin\n+            --  The management of the rep item chain involves \"inheritance\" of\n+            --  parent type chains. If a parent [sub]type is already subject to\n+            --  pragma Predicate_Failure, then the pragma will also appear in\n+            --  the chain of the child [sub]type, which in turn may possess a\n+            --  pragma of its own. Avoid order-dependent issues by inspecting\n+            --  the rep item chain directly. Note that routine Get_Pragma may\n+            --  return a parent pragma.\n+\n+            Item := First_Rep_Item (Typ);\n+            while Present (Item) loop\n+\n+               --  Predicate_Failure appears as an aspect\n+\n+               if Nkind (Item) = N_Aspect_Specification\n+                 and then Is_OK_PF_Aspect (Item)\n+               then\n+                  return Expression (Item);\n+\n+               --  Predicate_Failure appears as a pragma\n+\n+               elsif Nkind (Item) = N_Pragma\n+                 and then Is_OK_PF_Pragma (Item)\n+               then\n+                  return\n+                    Get_Pragma_Arg\n+                      (Next (First (Pragma_Argument_Associations (Item))));\n+               end if;\n+\n+               Item := Next_Rep_Item (Item);\n+            end loop;\n+\n+            return Empty;\n+         end Failure_Expression;\n+\n+         ---------------------\n+         -- Is_OK_PF_Aspect --\n+         ---------------------\n+\n+         function Is_OK_PF_Aspect (Asp : Node_Id) return Boolean is\n+         begin\n+            --  To qualify, the aspect must apply to the type subjected to the\n+            --  predicate check.\n+\n+            return\n+              Chars (Identifier (Asp)) = Name_Predicate_Failure\n+                and then Present (Entity (Asp))\n+                and then Entity (Asp) = Typ;\n+         end Is_OK_PF_Aspect;\n+\n+         ---------------------\n+         -- Is_OK_PF_Pragma --\n+         ---------------------\n+\n+         function Is_OK_PF_Pragma (Prag : Node_Id) return Boolean is\n+            Args    : constant List_Id := Pragma_Argument_Associations (Prag);\n+            Typ_Arg : Node_Id;\n+\n+         begin\n+            --  Nothing to do when the pragma does not denote Predicate_Failure\n+\n+            if Pragma_Name (Prag) /= Name_Predicate_Failure then\n+               return False;\n+\n+            --  Nothing to do when the pragma lacks arguments, in which case it\n+            --  is illegal.\n+\n+            elsif No (Args) or else Is_Empty_List (Args) then\n+               return False;\n+            end if;\n+\n+            Typ_Arg := Get_Pragma_Arg (First (Args));\n+\n+            --  To qualify, the local name argument of the pragma must denote\n+            --  the type subjected to the predicate check.\n+\n+            return\n+              Is_Entity_Name (Typ_Arg)\n+                and then Present (Entity (Typ_Arg))\n+                and then Entity (Typ_Arg) = Typ;\n+         end Is_OK_PF_Pragma;\n+\n+         --------------------------------\n+         --  Replace_Subtype_Reference --\n+         --------------------------------\n+\n+         procedure Replace_Subtype_Reference (N : Node_Id) is\n+         begin\n+            Rewrite (N, New_Copy_Tree (Expr));\n+\n+            --  We want to treat the node as if it comes from source, so that\n+            --  ASIS will not ignore it.\n+\n+            Set_Comes_From_Source (N, True);\n+         end Replace_Subtype_Reference;\n+\n+         procedure Replace_Subtype_References is\n+           new Replace_Type_References_Generic (Replace_Subtype_Reference);\n+\n+         --  Local variables\n+\n+         PF_Expr : constant Node_Id := Failure_Expression;\n+         Expr    : Node_Id;\n+\n+      --  Start of processing for Add_Failure_Expression\n \n-      procedure Replace_Subtype_Reference (N : Node_Id) is\n       begin\n-         Rewrite (N, New_Copy_Tree (Expr));\n+         if Present (PF_Expr) then\n \n-         --  We want to treat the node as if it comes from source, so\n-         --  that ASIS will not ignore it.\n+            --  Replace any occurrences of the current instance of the type\n+            --  with the object subjected to the predicate check.\n \n-         Set_Comes_From_Source (N, True);\n-      end Replace_Subtype_Reference;\n+            Expr := New_Copy_Tree (PF_Expr);\n+            Replace_Subtype_References (Expr, Typ);\n \n-      procedure Replace_Subtype_References is\n-        new Replace_Type_References_Generic (Replace_Subtype_Reference);\n+            --  The failure expression appears as the third argument of the\n+            --  Check pragma.\n+\n+            Append_To (Args,\n+              Make_Pragma_Argument_Association (Loc,\n+                Expression => Expr));\n+         end if;\n+      end Add_Failure_Expression;\n \n       --  Local variables\n \n-      Loc       : constant Source_Ptr := Sloc (Expr);\n-      Arg_List  : List_Id;\n-      Fail_Expr : Node_Id;\n-      Nam       : Name_Id;\n+      Args : List_Id;\n+      Nam  : Name_Id;\n \n    --  Start of processing for Make_Predicate_Check\n \n@@ -9370,31 +9506,21 @@ package body Exp_Util is\n          Nam := Name_Predicate;\n       end if;\n \n-      Arg_List := New_List (\n+      Args := New_List (\n         Make_Pragma_Argument_Association (Loc,\n           Expression => Make_Identifier (Loc, Nam)),\n         Make_Pragma_Argument_Association (Loc,\n           Expression => Make_Predicate_Call (Typ, Expr)));\n \n-      --  If subtype has Predicate_Failure defined, add the correponding\n-      --  expression as an additional pragma parameter, after replacing\n-      --  current instances with the expression being checked.\n-\n-      if Has_Aspect (Typ, Aspect_Predicate_Failure) then\n-         Fail_Expr :=\n-           New_Copy_Tree\n-             (Expression (Find_Aspect (Typ, Aspect_Predicate_Failure)));\n-         Replace_Subtype_References (Fail_Expr, Typ);\n+      --  If the subtype is subject to pragma Predicate_Failure, add the\n+      --  failure expression as an additional parameter.\n \n-         Append_To (Arg_List,\n-           Make_Pragma_Argument_Association (Loc,\n-             Expression => Fail_Expr));\n-      end if;\n+      Add_Failure_Expression (Args);\n \n       return\n         Make_Pragma (Loc,\n           Chars                        => Name_Check,\n-          Pragma_Argument_Associations => Arg_List);\n+          Pragma_Argument_Associations => Args);\n    end Make_Predicate_Check;\n \n    ----------------------------"}, {"sha": "bd0d4584ba4302f31b54a3f6538eb7fd88da53c6", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/806312986f95213e4321f4a282ff1738fe72c1ea/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/806312986f95213e4321f4a282ff1738fe72c1ea/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=806312986f95213e4321f4a282ff1738fe72c1ea", "patch": "@@ -13318,8 +13318,8 @@ package body Sem_Util is\n \n    begin\n       --  Simplest case: entity is a concurrent type and we are currently\n-      --  inside the body. This will eventually be expanded into a\n-      --  call to Self (for tasks) or _object (for protected objects).\n+      --  inside the body. This will eventually be expanded into a call to\n+      --  Self (for tasks) or _object (for protected objects).\n \n       if Is_Concurrent_Type (Typ) and then In_Open_Scopes (Typ) then\n          return True;\n@@ -13350,8 +13350,7 @@ package body Sem_Util is\n                return True;\n \n             elsif Nkind (P) = N_Pragma\n-              and then\n-                Get_Pragma_Id (P) = Pragma_Predicate_Failure\n+              and then Get_Pragma_Id (P) = Pragma_Predicate_Failure\n             then\n                return True;\n             end if;"}]}