{"sha": "e800d6dc2cb329a1b64bb3af136164910778a40c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTgwMGQ2ZGMyY2IzMjlhMWI2NGJiM2FmMTM2MTY0OTEwNzc4YTQwYw==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2019-05-29T21:50:09Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2019-05-29T21:50:09Z"}, "message": "rs6000.c (rs6000_call_template_1): Handle pcrel calls here...\n\n[gcc]\n\n2019-05-29  Bill Schmidt  <wschmidt@linux.ibm.com>\n\t    Alan Modra  <amodra@gmail.com>\n\n\t* config/rs6000/rs6000.c (rs6000_call_template_1): Handle pcrel\n\tcalls here...\n\t(rs6000_indirect_call_template_1): ...and here.\n\t(rs6000_pltseq_template): Handle plt_pcrel34.  Rework tocsave,\n\tplt16_ha, plt16_lo, mtctr indirect calls.  Use\n\trs6000_pltseq_enum.\n\t(rs6000_decl_ok_for_sibcall): New function.\n\t(rs6000_function_ok_for_sibcall): Refactor.\n\t(rs6000_longcall_ref): Use UNSPEC_PLT_PCREL when pcrel.\n\t(rs6000_call_aix): Don't emit toc restore rtl for indirect calls\n\twhen pcrel.  Reorganize.\n\t(rs6000_sibcall_aix): Don't add r2 to function usage when pcrel.\n\t* rs6000.h (rs6000_pltseq_enum): New enum.\n\t* rs6000.md (UNSPEC_PLT_PCREL): New unspec.\n\t(*pltseq_tocsave): Use rs6000_pltseq_enum.\n\t(*pltseq_plt16_ha): Likewise.\n\t(*pltseq_plt16_lo): Likewise.\n\t(*pltseq_mtctr): Likewise.\n\t(*pltseq_plt_pcrel): New insn.\n\t(*call_local_aix): Handle @notoc calls.\n\t(*call_value_local_aix): Likewise.\n\t(*call_nonlocal_aix): Adjust lengths for pcrel calls.\n\t(*call_value_nonlocal_aix): Likewise.\n\t(*call_indirect_pcrel): New insn.\n\t(*call_value_indirect_pcrel): Likewise.\n\n\n[gcc/testsuite]\n\n2019-05-29  Bill Schmidt  <wschmidt@linux.ibm.com>\n\n\t* gcc.target/powerpc/notoc-direct-1.c: New.\n\t* gcc.target/powerpc/pcrel-sibcall-1.c: New.\n\n\nCo-Authored-By: Alan Modra <amodra@gmail.com>\n\nFrom-SVN: r271753", "tree": {"sha": "a01860addae26089649bb9282df8abd616887b77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a01860addae26089649bb9282df8abd616887b77"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e800d6dc2cb329a1b64bb3af136164910778a40c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e800d6dc2cb329a1b64bb3af136164910778a40c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e800d6dc2cb329a1b64bb3af136164910778a40c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e800d6dc2cb329a1b64bb3af136164910778a40c/comments", "author": null, "committer": null, "parents": [{"sha": "874f88c43bc504d49228f53365d2fd565077ecdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/874f88c43bc504d49228f53365d2fd565077ecdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/874f88c43bc504d49228f53365d2fd565077ecdd"}], "stats": {"total": 466, "additions": 368, "deletions": 98}, "files": [{"sha": "cc1b6b4d9fa6b4e4344915239a2a58c8c56b275f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e800d6dc2cb329a1b64bb3af136164910778a40c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e800d6dc2cb329a1b64bb3af136164910778a40c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e800d6dc2cb329a1b64bb3af136164910778a40c", "patch": "@@ -1,3 +1,33 @@\n+2019-05-29  Bill Schmidt  <wschmidt@linux.ibm.com>\n+\t    Alan Modra  <amodra@gmail.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_call_template_1): Handle pcrel\n+\tcalls here...\n+\t(rs6000_indirect_call_template_1): ...and here.\n+\t(rs6000_pltseq_template): Handle plt_pcrel34.  Rework tocsave,\n+\tplt16_ha, plt16_lo, mtctr indirect calls.  Use\n+\trs6000_pltseq_enum.\n+\t(rs6000_decl_ok_for_sibcall): New function.\n+\t(rs6000_function_ok_for_sibcall): Refactor.\n+\t(rs6000_longcall_ref): Use UNSPEC_PLT_PCREL when pcrel.\n+\t(rs6000_call_aix): Don't emit toc restore rtl for indirect calls\n+\twhen pcrel.  Reorganize.\n+\t(rs6000_sibcall_aix): Don't add r2 to function usage when pcrel.\n+\t* rs6000.h (rs6000_pltseq_enum): New enum.\n+\t* rs6000.md (UNSPEC_PLT_PCREL): New unspec.\n+\t(*pltseq_tocsave): Use rs6000_pltseq_enum.\n+\t(*pltseq_plt16_ha): Likewise.\n+\t(*pltseq_plt16_lo): Likewise.\n+\t(*pltseq_mtctr): Likewise.\n+\t(*pltseq_plt_pcrel): New insn.\n+\t(*call_local_aix): Handle @notoc calls.\n+\t(*call_value_local_aix): Likewise.\n+\t(*call_nonlocal_aix): Adjust lengths for pcrel calls.\n+\t(*call_value_nonlocal_aix): Likewise.\n+\t(*call_indirect_pcrel): New insn.\n+\t(*call_value_indirect_pcrel): Likewise.\n+\n+\n 2019-05-29  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/sse.md (*save_multiple<mode>): Rename from"}, {"sha": "cfc2a6853c1fb0ee15fd66daf128de19fea60cf5", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 156, "deletions": 86, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e800d6dc2cb329a1b64bb3af136164910778a40c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e800d6dc2cb329a1b64bb3af136164910778a40c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e800d6dc2cb329a1b64bb3af136164910778a40c", "patch": "@@ -21267,8 +21267,10 @@ rs6000_call_template_1 (rtx *operands, unsigned int funop, bool sibcall)\n \t   (DEFAULT_ABI == ABI_V4 && TARGET_SECURE_PLT && flag_pic == 2\n \t    ? \"+32768\" : \"\"));\n \n-  static char str[32];  /* 2 spare */\n-  if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n+  static char str[32];  /* 1 spare */\n+  if (rs6000_pcrel_p (cfun))\n+    sprintf (str, \"b%s %s@notoc%s\", sibcall ? \"\" : \"l\", z, arg);\n+  else if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n     sprintf (str, \"b%s %s%s%s\", sibcall ? \"\" : \"l\", z, arg,\n \t     sibcall ? \"\" : \"\\n\\tnop\");\n   else if (DEFAULT_ABI == ABI_V4)\n@@ -21333,6 +21335,16 @@ rs6000_indirect_call_template_1 (rtx *operands, unsigned int funop,\n   /* Currently, funop is either 0 or 1.  The maximum string is always\n      a !speculate 64-bit __tls_get_addr call.\n \n+     ABI_ELFv2, pcrel:\n+     . 27\t.reloc .,R_PPC64_TLSGD,%2\\n\\t\n+     . 35\t.reloc .,R_PPC64_PLTSEQ_NOTOC,%z1\\n\\t\n+     .  9\tcrset 2\\n\\t\n+     . 27\t.reloc .,R_PPC64_TLSGD,%2\\n\\t\n+     . 36\t.reloc .,R_PPC64_PLTCALL_NOTOC,%z1\\n\\t\n+     .  8\tbeq%T1l-\n+     .---\n+     .142\n+\n      ABI_AIX:\n      .  9\tld 2,%3\\n\\t\n      . 27\t.reloc .,R_PPC64_TLSGD,%2\\n\\t\n@@ -21398,23 +21410,31 @@ rs6000_indirect_call_template_1 (rtx *operands, unsigned int funop,\n \t    gcc_unreachable ();\n \t}\n \n+      const char *notoc = rs6000_pcrel_p (cfun) ? \"_NOTOC\" : \"\";\n       const char *addend = (DEFAULT_ABI == ABI_V4 && TARGET_SECURE_PLT\n \t\t\t    && flag_pic == 2 ? \"+32768\" : \"\");\n       if (!speculate)\n \t{\n \t  s += sprintf (s,\n-\t\t\t\"%s.reloc .,R_PPC%s_PLTSEQ,%%z%u%s\\n\\t\",\n-\t\t\ttls, rel64, funop, addend);\n+\t\t\t\"%s.reloc .,R_PPC%s_PLTSEQ%s,%%z%u%s\\n\\t\",\n+\t\t\ttls, rel64, notoc, funop, addend);\n \t  s += sprintf (s, \"crset 2\\n\\t\");\n \t}\n       s += sprintf (s,\n-\t\t    \"%s.reloc .,R_PPC%s_PLTCALL,%%z%u%s\\n\\t\",\n-\t\t    tls, rel64, funop, addend);\n+\t\t    \"%s.reloc .,R_PPC%s_PLTCALL%s,%%z%u%s\\n\\t\",\n+\t\t    tls, rel64, notoc, funop, addend);\n     }\n   else if (!speculate)\n     s += sprintf (s, \"crset 2\\n\\t\");\n \n-  if (DEFAULT_ABI == ABI_AIX)\n+  if (rs6000_pcrel_p (cfun))\n+    {\n+      if (speculate)\n+\tsprintf (s, \"b%%T%ul\", funop);\n+      else\n+\tsprintf (s, \"beq%%T%ul-\", funop);\n+    }\n+  else if (DEFAULT_ABI == ABI_AIX)\n     {\n       if (speculate)\n \tsprintf (s,\n@@ -21467,64 +21487,72 @@ rs6000_indirect_sibcall_template (rtx *operands, unsigned int funop)\n }\n \n #if HAVE_AS_PLTSEQ\n-/* Output indirect call insns.\n-   WHICH is 0 for tocsave, 1 for plt16_ha, 2 for plt16_lo, 3 for mtctr.  */\n+/* Output indirect call insns.  WHICH identifies the type of sequence.  */\n const char *\n rs6000_pltseq_template (rtx *operands, int which)\n {\n   const char *rel64 = TARGET_64BIT ? \"64\" : \"\";\n-  char tls[28];\n+  char tls[30];\n   tls[0] = 0;\n   if (TARGET_TLS_MARKERS && GET_CODE (operands[3]) == UNSPEC)\n     {\n+      char off = which == RS6000_PLTSEQ_PLT_PCREL34 ? '8' : '4';\n       if (XINT (operands[3], 1) == UNSPEC_TLSGD)\n-\tsprintf (tls, \".reloc .,R_PPC%s_TLSGD,%%3\\n\\t\",\n-\t\t rel64);\n+\tsprintf (tls, \".reloc .-%c,R_PPC%s_TLSGD,%%3\\n\\t\",\n+\t\t off, rel64);\n       else if (XINT (operands[3], 1) == UNSPEC_TLSLD)\n-\tsprintf (tls, \".reloc .,R_PPC%s_TLSLD,%%&\\n\\t\",\n-\t\t rel64);\n+\tsprintf (tls, \".reloc .-%c,R_PPC%s_TLSLD,%%&\\n\\t\",\n+\t\t off, rel64);\n       else\n \tgcc_unreachable ();\n     }\n \n   gcc_assert (DEFAULT_ABI == ABI_ELFv2 || DEFAULT_ABI == ABI_V4);\n-  static char str[96];  /* 15 spare */\n-  const char *off = WORDS_BIG_ENDIAN ? \"+2\" : \"\";\n+  static char str[96];  /* 10 spare */\n+  char off = WORDS_BIG_ENDIAN ? '2' : '4';\n   const char *addend = (DEFAULT_ABI == ABI_V4 && TARGET_SECURE_PLT\n \t\t\t&& flag_pic == 2 ? \"+32768\" : \"\");\n   switch (which)\n     {\n-    case 0:\n+    case RS6000_PLTSEQ_TOCSAVE:\n       sprintf (str,\n-\t       \"%s.reloc .,R_PPC%s_PLTSEQ,%%z2\\n\\t\"\n-\t       \"st%s\",\n-\t       tls, rel64, TARGET_64BIT ? \"d 2,24(1)\" : \"w 2,12(1)\");\n+\t       \"st%s\\n\\t\"\n+\t       \"%s.reloc .-4,R_PPC%s_PLTSEQ,%%z2\",\n+\t       TARGET_64BIT ? \"d 2,24(1)\" : \"w 2,12(1)\",\n+\t       tls, rel64);\n       break;\n-    case 1:\n+    case RS6000_PLTSEQ_PLT16_HA:\n       if (DEFAULT_ABI == ABI_V4 && !flag_pic)\n \tsprintf (str,\n-\t\t \"%s.reloc .%s,R_PPC%s_PLT16_HA,%%z2\\n\\t\"\n-\t\t \"lis %%0,0\",\n+\t\t \"lis %%0,0\\n\\t\"\n+\t\t \"%s.reloc .-%c,R_PPC%s_PLT16_HA,%%z2\",\n \t\t tls, off, rel64);\n       else\n \tsprintf (str,\n-\t\t \"%s.reloc .%s,R_PPC%s_PLT16_HA,%%z2%s\\n\\t\"\n-\t\t \"addis %%0,%%1,0\",\n+\t\t \"addis %%0,%%1,0\\n\\t\"\n+\t\t \"%s.reloc .-%c,R_PPC%s_PLT16_HA,%%z2%s\",\n \t\t tls, off, rel64, addend);\n       break;\n-    case 2:\n+    case RS6000_PLTSEQ_PLT16_LO:\n       sprintf (str,\n-\t       \"%s.reloc .%s,R_PPC%s_PLT16_LO%s,%%z2%s\\n\\t\"\n-\t       \"l%s %%0,0(%%1)\",\n-\t       tls, off, rel64, TARGET_64BIT ? \"_DS\" : \"\", addend,\n-\t       TARGET_64BIT ? \"d\" : \"wz\");\n+\t       \"l%s %%0,0(%%1)\\n\\t\"\n+\t       \"%s.reloc .-%c,R_PPC%s_PLT16_LO%s,%%z2%s\",\n+\t       TARGET_64BIT ? \"d\" : \"wz\",\n+\t       tls, off, rel64, TARGET_64BIT ? \"_DS\" : \"\", addend);\n       break;\n-    case 3:\n+    case RS6000_PLTSEQ_MTCTR:\n       sprintf (str,\n-\t       \"%s.reloc .,R_PPC%s_PLTSEQ,%%z2%s\\n\\t\"\n-\t       \"mtctr %%1\",\n+\t       \"mtctr %%1\\n\\t\"\n+\t       \"%s.reloc .-4,R_PPC%s_PLTSEQ,%%z2%s\",\n \t       tls, rel64, addend);\n       break;\n+    case RS6000_PLTSEQ_PLT_PCREL34:\n+      sprintf (str,\n+\t       \"pl%s %%0,0(0),1\\n\\t\"\n+\t       \"%s.reloc .-8,R_PPC%s_PLT_PCREL34_NOTOC,%%z2\",\n+\t       TARGET_64BIT ? \"d\" : \"wz\",\n+\t       tls, rel64);\n+      break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -24703,6 +24731,52 @@ rs6000_return_addr (int count, rtx frame)\n   return get_hard_reg_initial_val (Pmode, LR_REGNO);\n }\n \n+/* Helper function for rs6000_function_ok_for_sibcall.  */\n+\n+static bool\n+rs6000_decl_ok_for_sibcall (tree decl)\n+{\n+  /* Sibcalls are always fine for the Darwin ABI.  */\n+  if (DEFAULT_ABI == ABI_DARWIN)\n+    return true;\n+\n+  if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n+    {\n+      /* Under the AIX or ELFv2 ABIs we can't allow calls to non-local\n+\t functions, because the callee may have a different TOC pointer to\n+\t the caller and there's no way to ensure we restore the TOC when\n+\t we return.  */\n+      if (!decl || DECL_EXTERNAL (decl) || DECL_WEAK (decl)\n+\t  || !(*targetm.binds_local_p) (decl))\n+\treturn false;\n+\n+      /* Similarly, if the caller preserves the TOC pointer and the callee\n+\t doesn't (or vice versa), proper TOC setup or restoration will be\n+\t missed.  For example, suppose A, B, and C are in the same binary\n+\t and A -> B -> C.  A and B preserve the TOC pointer but C does not,\n+\t and B -> C is eligible as a sibcall.  A will call B through its\n+\t local entry point, so A will not restore its TOC itself.  B calls\n+\t C with a sibcall, so it will not restore the TOC.  C does not\n+\t preserve the TOC, so it may clobber r2 with impunity.  Returning\n+\t from C will result in a corrupted TOC for A.  */\n+      else if (rs6000_fndecl_pcrel_p (decl) != rs6000_pcrel_p (cfun))\n+\treturn false;\n+\n+      else\n+\treturn true;\n+    }\n+\n+  /*  With the secure-plt SYSV ABI we can't make non-local calls when\n+      -fpic/PIC because the plt call stubs use r30.  */\n+  if (DEFAULT_ABI != ABI_V4\n+      || (TARGET_SECURE_PLT\n+\t  && flag_pic\n+\t  && (!decl || !((*targetm.binds_local_p) (decl)))))\n+    return false;\n+\n+  return true;\n+}\n+\n /* Say whether a function is a candidate for sibcall handling or not.  */\n \n static bool\n@@ -24748,22 +24822,7 @@ rs6000_function_ok_for_sibcall (tree decl, tree exp)\n \treturn false;\n     }\n \n-  /* Under the AIX or ELFv2 ABIs we can't allow calls to non-local\n-     functions, because the callee may have a different TOC pointer to\n-     the caller and there's no way to ensure we restore the TOC when\n-     we return.  With the secure-plt SYSV ABI we can't make non-local\n-     calls when -fpic/PIC because the plt call stubs use r30.  */\n-  if (DEFAULT_ABI == ABI_DARWIN\n-      || ((DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n-\t  && decl\n-\t  && !DECL_EXTERNAL (decl)\n-\t  && !DECL_WEAK (decl)\n-\t  && (*targetm.binds_local_p) (decl))\n-      || (DEFAULT_ABI == ABI_V4\n-\t  && (!TARGET_SECURE_PLT\n-\t      || !flag_pic\n-\t      || (decl\n-\t\t  && (*targetm.binds_local_p) (decl)))))\n+  if (rs6000_decl_ok_for_sibcall (decl))\n     {\n       tree attr_list = TYPE_ATTRIBUTES (fntype);\n \n@@ -32591,12 +32650,18 @@ rs6000_longcall_ref (rtx call_ref, rtx arg)\n   if (TARGET_PLTSEQ)\n     {\n       rtx base = const0_rtx;\n-      int regno;\n-      if (DEFAULT_ABI == ABI_ELFv2)\n+      int regno = 12;\n+      if (rs6000_pcrel_p (cfun))\n \t{\n-\t  base = gen_rtx_REG (Pmode, TOC_REGISTER);\n-\t  regno = 12;\n+\t  rtx reg = gen_rtx_REG (Pmode, regno);\n+\t  rtx u = gen_rtx_UNSPEC (Pmode, gen_rtvec (3, base, call_ref, arg),\n+\t\t\t\t  UNSPEC_PLT_PCREL);\n+\t  emit_insn (gen_rtx_SET (reg, u));\n+\t  return reg;\n \t}\n+\n+      if (DEFAULT_ABI == ABI_ELFv2)\n+\tbase = gen_rtx_REG (Pmode, TOC_REGISTER);\n       else\n \t{\n \t  if (flag_pic)\n@@ -37705,37 +37770,38 @@ rs6000_call_aix (rtx value, rtx func_desc, rtx tlsarg, rtx cookie)\n   if (!SYMBOL_REF_P (func)\n       || (DEFAULT_ABI == ABI_AIX && !SYMBOL_REF_FUNCTION_P (func)))\n     {\n-      /* Save the TOC into its reserved slot before the call,\n-\t and prepare to restore it after the call.  */\n-      rtx stack_toc_offset = GEN_INT (RS6000_TOC_SAVE_SLOT);\n-      rtx stack_toc_unspec = gen_rtx_UNSPEC (Pmode,\n-\t\t\t\t\t     gen_rtvec (1, stack_toc_offset),\n-\t\t\t\t\t     UNSPEC_TOCSLOT);\n-      toc_restore = gen_rtx_SET (toc_reg, stack_toc_unspec);\n-\n-      /* Can we optimize saving the TOC in the prologue or\n-\t do we need to do it at every call?  */\n-      if (TARGET_SAVE_TOC_INDIRECT && !cfun->calls_alloca)\n-\tcfun->machine->save_toc_in_prologue = true;\n-      else\n+      if (!rs6000_pcrel_p (cfun))\n \t{\n-\t  rtx stack_ptr = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n-\t  rtx stack_toc_mem = gen_frame_mem (Pmode,\n-\t\t\t\t\t     gen_rtx_PLUS (Pmode, stack_ptr,\n-\t\t\t\t\t\t\t   stack_toc_offset));\n-\t  MEM_VOLATILE_P (stack_toc_mem) = 1;\n-\t  if (is_pltseq_longcall)\n+\t  /* Save the TOC into its reserved slot before the call,\n+\t     and prepare to restore it after the call.  */\n+\t  rtx stack_toc_offset = GEN_INT (RS6000_TOC_SAVE_SLOT);\n+\t  rtx stack_toc_unspec = gen_rtx_UNSPEC (Pmode,\n+\t\t\t\t\t\t gen_rtvec (1, stack_toc_offset),\n+\t\t\t\t\t\t UNSPEC_TOCSLOT);\n+\t  toc_restore = gen_rtx_SET (toc_reg, stack_toc_unspec);\n+\n+\t  /* Can we optimize saving the TOC in the prologue or\n+\t     do we need to do it at every call?  */\n+\t  if (TARGET_SAVE_TOC_INDIRECT && !cfun->calls_alloca)\n+\t    cfun->machine->save_toc_in_prologue = true;\n+\t  else\n \t    {\n-\t      /* Use USPEC_PLTSEQ here to emit every instruction in an\n-\t\t inline PLT call sequence with a reloc, enabling the\n-\t\t linker to edit the sequence back to a direct call\n-\t\t when that makes sense.  */\n-\t      rtvec v = gen_rtvec (3, toc_reg, func_desc, tlsarg);\n-\t      rtx mark_toc_reg = gen_rtx_UNSPEC (Pmode, v, UNSPEC_PLTSEQ);\n-\t      emit_insn (gen_rtx_SET (stack_toc_mem, mark_toc_reg));\n+\t      rtx stack_ptr = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n+\t      rtx stack_toc_mem = gen_frame_mem (Pmode,\n+\t\t\t\t\t\t gen_rtx_PLUS (Pmode, stack_ptr,\n+\t\t\t\t\t\t\t       stack_toc_offset));\n+\t      MEM_VOLATILE_P (stack_toc_mem) = 1;\n+\t      if (HAVE_AS_PLTSEQ\n+\t\t  && DEFAULT_ABI == ABI_ELFv2\n+\t\t  && GET_CODE (func_desc) == SYMBOL_REF)\n+\t\t{\n+\t\t  rtvec v = gen_rtvec (3, toc_reg, func_desc, tlsarg);\n+\t\t  rtx mark_toc_reg = gen_rtx_UNSPEC (Pmode, v, UNSPEC_PLTSEQ);\n+\t\t  emit_insn (gen_rtx_SET (stack_toc_mem, mark_toc_reg));\n+\t\t}\n+\t      else\n+\t\temit_move_insn (stack_toc_mem, toc_reg);\n \t    }\n-\t  else\n-\t    emit_move_insn (stack_toc_mem, toc_reg);\n \t}\n \n       if (DEFAULT_ABI == ABI_ELFv2)\n@@ -37812,10 +37878,12 @@ rs6000_call_aix (rtx value, rtx func_desc, rtx tlsarg, rtx cookie)\n     }\n   else\n     {\n-      /* Direct calls use the TOC: for local calls, the callee will\n-\t assume the TOC register is set; for non-local calls, the\n-\t PLT stub needs the TOC register.  */\n-      abi_reg = toc_reg;\n+      /* No TOC register needed for calls from PC-relative callers.  */\n+      if (!rs6000_pcrel_p (cfun))\n+\t/* Direct calls use the TOC: for local calls, the callee will\n+\t   assume the TOC register is set; for non-local calls, the\n+\t   PLT stub needs the TOC register.  */\n+\tabi_reg = toc_reg;\n       func_addr = func;\n     }\n \n@@ -37865,7 +37933,9 @@ rs6000_sibcall_aix (rtx value, rtx func_desc, rtx tlsarg, rtx cookie)\n   insn = emit_call_insn (insn);\n \n   /* Note use of the TOC register.  */\n-  use_reg (&CALL_INSN_FUNCTION_USAGE (insn), gen_rtx_REG (Pmode, TOC_REGNUM));\n+  if (!rs6000_pcrel_p (cfun))\n+    use_reg (&CALL_INSN_FUNCTION_USAGE (insn),\n+\t     gen_rtx_REG (Pmode, TOC_REGNUM));\n }\n \n /* Expand code to perform a call under the SYSV4 ABI.  */"}, {"sha": "f50ae946b322442c024932e37a194c09aa64cbc7", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e800d6dc2cb329a1b64bb3af136164910778a40c/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e800d6dc2cb329a1b64bb3af136164910778a40c/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=e800d6dc2cb329a1b64bb3af136164910778a40c", "patch": "@@ -1490,6 +1490,15 @@ extern enum reg_class rs6000_constraints[RS6000_CONSTRAINT_MAX];\n #define CALL_LONG\t\t0x00000008\t/* always call indirect */\n #define CALL_LIBCALL\t\t0x00000010\t/* libcall */\n \n+/* Identify PLT sequence for rs6000_pltseq_template.  */\n+enum rs6000_pltseq_enum {\n+  RS6000_PLTSEQ_TOCSAVE,\n+  RS6000_PLTSEQ_PLT16_HA,\n+  RS6000_PLTSEQ_PLT16_LO,\n+  RS6000_PLTSEQ_MTCTR,\n+  RS6000_PLTSEQ_PLT_PCREL34\n+};\n+\n #define IS_V4_FP_ARGS(OP) \\\n   ((INTVAL (OP) & (CALL_V4_CLEAR_FP_ARGS | CALL_V4_SET_FP_ARGS)) != 0)\n "}, {"sha": "47cbba8944398da38036cbb378aa0473902e8b8f", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 81, "deletions": 12, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e800d6dc2cb329a1b64bb3af136164910778a40c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e800d6dc2cb329a1b64bb3af136164910778a40c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=e800d6dc2cb329a1b64bb3af136164910778a40c", "patch": "@@ -147,6 +147,7 @@\n    UNSPEC_PLTSEQ\n    UNSPEC_PLT16_HA\n    UNSPEC_PLT16_LO\n+   UNSPEC_PLT_PCREL\n   ])\n \n ;;\n@@ -10231,7 +10232,7 @@\n   \"TARGET_PLTSEQ\n    && DEFAULT_ABI == ABI_ELFv2\"\n {\n-  return rs6000_pltseq_template (operands, 0);\n+  return rs6000_pltseq_template (operands, RS6000_PLTSEQ_TOCSAVE);\n })\n \n (define_insn \"*pltseq_plt16_ha_<mode>\"\n@@ -10242,7 +10243,7 @@\n \t\t  UNSPEC_PLT16_HA))]\n   \"TARGET_PLTSEQ\"\n {\n-  return rs6000_pltseq_template (operands, 1);\n+  return rs6000_pltseq_template (operands, RS6000_PLTSEQ_PLT16_HA);\n })\n \n (define_insn \"*pltseq_plt16_lo_<mode>\"\n@@ -10253,7 +10254,7 @@\n \t\t  UNSPEC_PLT16_LO))]\n   \"TARGET_PLTSEQ\"\n {\n-  return rs6000_pltseq_template (operands, 2);\n+  return rs6000_pltseq_template (operands, RS6000_PLTSEQ_PLT16_LO);\n }\n   [(set_attr \"type\" \"load\")])\n \n@@ -10265,8 +10266,22 @@\n \t\t  UNSPEC_PLTSEQ))]\n   \"TARGET_PLTSEQ\"\n {\n-  return rs6000_pltseq_template (operands, 3);\n+  return rs6000_pltseq_template (operands, RS6000_PLTSEQ_MTCTR);\n })\n+\n+(define_insn \"*pltseq_plt_pcrel<mode>\"\n+  [(set (match_operand:P 0 \"gpc_reg_operand\" \"=r\")\n+\t(unspec:P [(match_operand:P 1 \"\" \"\")\n+\t\t   (match_operand:P 2 \"symbol_ref_operand\" \"s\")\n+\t\t   (match_operand:P 3 \"\" \"\")]\n+\t\t  UNSPEC_PLT_PCREL))]\n+  \"HAVE_AS_PLTSEQ && TARGET_TLS_MARKERS\n+   && rs6000_pcrel_p (cfun)\"\n+{\n+  return rs6000_pltseq_template (operands, RS6000_PLTSEQ_PLT_PCREL34);\n+}\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"12\")])\n \f\n ;; Call and call_value insns\n ;; For the purposes of expanding calls, Darwin is very similar to SYSV.\n@@ -10582,7 +10597,11 @@\n \t (match_operand 1))\n    (clobber (reg:P LR_REGNO))]\n   \"DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2\"\n-  \"bl %z0\"\n+{\n+  if (rs6000_pcrel_p (cfun))\n+    return \"bl %z0@notoc\";\n+  return \"bl %z0\";\n+}\n   [(set_attr \"type\" \"branch\")])\n \n (define_insn \"*call_value_local_aix<mode>\"\n@@ -10592,7 +10611,11 @@\n    (clobber (reg:P LR_REGNO))]\n   \"(DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n    && !IS_NOMARK_TLSGETADDR (operands[2])\"\n-  \"bl %z1\"\n+{\n+  if (rs6000_pcrel_p (cfun))\n+    return \"bl %z1@notoc\";\n+  return \"bl %z1\";\n+}\n   [(set_attr \"type\" \"branch\")])\n \n ;; Call to AIX abi function which may be in another module.\n@@ -10607,7 +10630,10 @@\n   return rs6000_call_template (operands, 0);\n }\n   [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"8\")])\n+   (set (attr \"length\")\n+\t(if_then_else (match_test \"rs6000_pcrel_p (cfun)\")\n+\t  (const_int 4)\n+\t  (const_int 8)))])\n \n (define_insn \"*call_value_nonlocal_aix<mode>\"\n   [(set (match_operand 0 \"\" \"\")\n@@ -10623,11 +10649,14 @@\n }\n   [(set_attr \"type\" \"branch\")\n    (set (attr \"length\")\n-\t(if_then_else (match_test \"IS_NOMARK_TLSGETADDR (operands[2])\")\n-\t  (if_then_else (match_test \"TARGET_CMODEL != CMODEL_SMALL\")\n-\t    (const_int 16)\n-\t    (const_int 12))\n-\t  (const_int 8)))])\n+\t(plus (if_then_else (match_test \"IS_NOMARK_TLSGETADDR (operands[2])\")\n+\t\t(if_then_else (match_test \"TARGET_CMODEL != CMODEL_SMALL\")\n+\t\t  (const_int 8)\n+\t\t  (const_int 4))\n+\t\t(const_int 0))\n+\t      (if_then_else (match_test \"rs6000_pcrel_p (cfun)\")\n+\t\t(const_int 4)\n+\t\t(const_int 8))))])\n \n ;; Call to indirect functions with the AIX abi using a 3 word descriptor.\n ;; Operand0 is the addresss of the function to call\n@@ -10700,6 +10729,21 @@\n \t\t      (const_string \"12\")\n \t\t      (const_string \"8\")))])\n \n+(define_insn \"*call_indirect_pcrel<mode>\"\n+  [(call (mem:SI (match_operand:P 0 \"indirect_call_operand\" \"c,*l,X\"))\n+\t (match_operand 1))\n+   (clobber (reg:P LR_REGNO))]\n+  \"rs6000_pcrel_p (cfun)\"\n+{\n+  return rs6000_indirect_call_template (operands, 0);\n+}\n+  [(set_attr \"type\" \"jmpreg\")\n+   (set (attr \"length\")\n+\t(if_then_else (and (match_test \"!rs6000_speculate_indirect_jumps\")\n+\t\t\t   (match_test \"which_alternative != 1\"))\n+\t\t      (const_string \"8\")\n+\t\t      (const_string \"4\")))])\n+\n (define_insn \"*call_value_indirect_elfv2<mode>\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:SI (match_operand:P 1 \"indirect_call_operand\" \"c,*l,X\"))\n@@ -10728,6 +10772,31 @@\n \t    (const_string \"12\")\n \t    (const_string \"8\"))))])\n \n+(define_insn \"*call_value_indirect_pcrel<mode>\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:SI (match_operand:P 1 \"indirect_call_operand\" \"c,*l,X\"))\n+\t      (match_operand:P 2 \"unspec_tls\" \"\")))\n+   (clobber (reg:P LR_REGNO))]\n+  \"rs6000_pcrel_p (cfun)\"\n+{\n+  if (IS_NOMARK_TLSGETADDR (operands[2]))\n+    rs6000_output_tlsargs (operands);\n+\n+  return rs6000_indirect_call_template (operands, 1);\n+}\n+  [(set_attr \"type\" \"jmpreg\")\n+   (set (attr \"length\")\n+\t(plus\n+\t  (if_then_else (match_test \"IS_NOMARK_TLSGETADDR (operands[2])\")\n+\t    (if_then_else (match_test \"TARGET_CMODEL != CMODEL_SMALL\")\n+\t      (const_int 8)\n+\t      (const_int 4))\n+\t    (const_int 0))\n+\t  (if_then_else (and (match_test \"!rs6000_speculate_indirect_jumps\")\n+\t\t\t     (match_test \"which_alternative != 1\"))\n+\t    (const_string \"8\")\n+\t    (const_string \"4\"))))])\n+\n ;; Call subroutine returning any type.\n (define_expand \"untyped_call\"\n   [(parallel [(call (match_operand 0 \"\")"}, {"sha": "60dc28209e927c6cf5d5e60010d36dbc868e4e62", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e800d6dc2cb329a1b64bb3af136164910778a40c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e800d6dc2cb329a1b64bb3af136164910778a40c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e800d6dc2cb329a1b64bb3af136164910778a40c", "patch": "@@ -1,3 +1,8 @@\n+2019-05-29  Bill Schmidt  <wschmidt@linux.ibm.com>\n+\n+\t* gcc.target/powerpc/notoc-direct-1.c: New.\n+\t* gcc.target/powerpc/pcrel-sibcall-1.c: New.\n+\n 2019-05-29  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/90598"}, {"sha": "31497261ddf4be10c2b6b4c2cc59fdae4380ab10", "filename": "gcc/testsuite/gcc.target/powerpc/notoc-direct-1.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e800d6dc2cb329a1b64bb3af136164910778a40c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fnotoc-direct-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e800d6dc2cb329a1b64bb3af136164910778a40c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fnotoc-direct-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fnotoc-direct-1.c?ref=e800d6dc2cb329a1b64bb3af136164910778a40c", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mdejagnu-cpu=future -O2\" } */\n+/* { dg-require-effective-target powerpc_elfv2 } */\n+\n+/* Test that calls generated from PC-relative code are\n+   annotated with @notoc.  */\n+\n+extern int yy0 (int);\n+extern void yy1 (int);\n+\n+int zz0 (void) __attribute__((noinline));\n+void zz1 (int) __attribute__((noinline));\n+\n+int xx (void)\n+{\n+  yy1 (7);\n+  return yy0 (5);\n+}\n+\n+int zz0 ()\n+{\n+  asm (\"\");\n+  return 16;\n+};\n+\n+void zz1 (int a __attribute__((__unused__)))\n+{\n+  asm (\"\");\n+};\n+\n+int ww (void)\n+{\n+  zz1 (zz0 ());\n+  return 4;\n+}\n+\n+/* { dg-final { scan-assembler {yy1@notoc} } } */\n+/* { dg-final { scan-assembler {yy0@notoc} } } */\n+/* { dg-final { scan-assembler {zz1@notoc} } } */\n+/* { dg-final { scan-assembler {zz0@notoc} } } */\n+"}, {"sha": "7c767e2ba322f073a853c4c726c93c6b35350cb9", "filename": "gcc/testsuite/gcc.target/powerpc/pcrel-sibcall-1.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e800d6dc2cb329a1b64bb3af136164910778a40c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-sibcall-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e800d6dc2cb329a1b64bb3af136164910778a40c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-sibcall-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpcrel-sibcall-1.c?ref=e800d6dc2cb329a1b64bb3af136164910778a40c", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mdejagnu-cpu=future -O2\" } */\n+/* { dg-require-effective-target powerpc_elfv2 } */\n+\n+/* Test that potential sibcalls are not generated when the caller preserves\n+   the TOC and the callee doesn't, or vice versa.  */\n+\n+int x (void) __attribute__((noinline));\n+int y (void) __attribute__((noinline));\n+int xx (void) __attribute__((noinline));\n+  \n+int x (void)\n+{\n+  return 1;\n+}\n+\n+int y (void)\n+{\n+  return 2;\n+}\n+\n+int sib_call (void)\n+{\n+  return x ();\n+}\n+\n+#pragma GCC target (\"cpu=power9\")\n+int normal_call (void)\n+{\n+  return y ();\n+}\n+\n+int xx (void)\n+{\n+  return 1;\n+}\n+\n+#pragma GCC target (\"cpu=future\")\n+int notoc_call (void)\n+{\n+  return xx ();\n+}\n+\n+/* { dg-final { scan-assembler {\\mb x@notoc\\M} } } */\n+/* { dg-final { scan-assembler {\\mbl y\\M} } } */\n+/* { dg-final { scan-assembler {\\mbl xx@notoc\\M} } } */"}]}