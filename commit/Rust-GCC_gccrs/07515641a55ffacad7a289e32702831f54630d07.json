{"sha": "07515641a55ffacad7a289e32702831f54630d07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc1MTU2NDFhNTVmZmFjYWQ3YTI4OWUzMjcwMjgzMWY1NDYzMGQwNw==", "commit": {"author": {"name": "Warren Levy", "email": "warrenl@cygnus.com", "date": "1999-05-28T19:29:53Z"}, "committer": {"name": "Warren Levy", "email": "warrenl@gcc.gnu.org", "date": "1999-05-28T19:29:53Z"}, "message": "DatagramSocket.java (laddr): Removed.\n\n\t* java/net/DatagramSocket.java (laddr): Removed.\n\t(DatagramSocket): Removed attempts to get or set laddr if null.\n\t(getLocalAddress): Reimplemented per spec.\n\t* java/net/MulticastSocket.java (setTimeToLive): Throw exception\n\twhen ttl is 0.\n\t(joinGroup): Throw NullPointerException if any argument is null.\n\t(leaveGroup): ditto.\n\t* java/net/PlainDatagramSocketImpl.java: Updated comments.\n\t* java/net/PlainSocketImpl.java (timeout): Added.\n\t(getInputStream): Added FIXME comment on how to support timeouts\n\tfor TCP.\n\t* java/net/ServerSocket.java (ServerSocket): Added FIXME comment.\n\t* java/net/Socket.java: Added FIXME comments to identify\n\tconflicting specs between the JCL and JDK 1.2 documents.\n\t* java/net/natPlainDatagramSocketImpl.cc (bind): Use INADDR_ANY\n\tif host is null.  Get localport value resolved by kernel if bind\n\tlport is 0.\n\t(receive): Implemented support for timeouts in UDP.\n\t(setOption): Implemented based on natPlainSocketImpl version.\n\t(getOption): ditto.\n\t* java/net/natPlainSocketImpl.cc (bind): Get localport value\n\tresolved by kernel if bind lport is 0.\n\t(connect): Get localport value resolved by kernel if bind wasn't\n\tdone to set localport.\n\t(accept): Implemented support for timeouts for ServerSocket.\n\t(setOption): Save value for SO_TIMEOUT.\n\t(getOption): Return timeout for SO_TIMEOUT.\n\nFrom-SVN: r27230", "tree": {"sha": "2be352b9baec3fecd8a60eda2e771c4cb2819327", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2be352b9baec3fecd8a60eda2e771c4cb2819327"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07515641a55ffacad7a289e32702831f54630d07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07515641a55ffacad7a289e32702831f54630d07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07515641a55ffacad7a289e32702831f54630d07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07515641a55ffacad7a289e32702831f54630d07/comments", "author": null, "committer": null, "parents": [{"sha": "930248932e3864264cdfe7d40b00a0544f3d4de9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/930248932e3864264cdfe7d40b00a0544f3d4de9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/930248932e3864264cdfe7d40b00a0544f3d4de9"}], "stats": {"total": 381, "additions": 327, "deletions": 54}, "files": [{"sha": "d6111392b68395b207e812479c92c1a252f9b128", "filename": "libjava/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07515641a55ffacad7a289e32702831f54630d07/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07515641a55ffacad7a289e32702831f54630d07/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=07515641a55ffacad7a289e32702831f54630d07", "patch": "@@ -1,3 +1,33 @@\n+1999-05-28  Warren Levy  <warrenl@cygnus.com>\n+\n+\t* java/net/DatagramSocket.java (laddr): Removed.\n+\t(DatagramSocket): Removed attempts to get or set laddr if null.\n+\t(getLocalAddress): Reimplemented per spec.\n+\t* java/net/MulticastSocket.java (setTimeToLive): Throw exception\n+\twhen ttl is 0.\n+\t(joinGroup): Throw NullPointerException if any argument is null.\n+\t(leaveGroup): ditto.\n+\t* java/net/PlainDatagramSocketImpl.java: Updated comments.\n+\t* java/net/PlainSocketImpl.java (timeout): Added.\n+\t(getInputStream): Added FIXME comment on how to support timeouts\n+\tfor TCP.\n+\t* java/net/ServerSocket.java (ServerSocket): Added FIXME comment.\n+\t* java/net/Socket.java: Added FIXME comments to identify\n+\tconflicting specs between the JCL and JDK 1.2 documents.\n+\t* java/net/natPlainDatagramSocketImpl.cc (bind): Use INADDR_ANY\n+\tif host is null.  Get localport value resolved by kernel if bind\n+\tlport is 0.\n+\t(receive): Implemented support for timeouts in UDP.\n+\t(setOption): Implemented based on natPlainSocketImpl version.\n+\t(getOption): ditto.\n+\t* java/net/natPlainSocketImpl.cc (bind): Get localport value\n+\tresolved by kernel if bind lport is 0.\n+\t(connect): Get localport value resolved by kernel if bind wasn't\n+\tdone to set localport.\n+\t(accept): Implemented support for timeouts for ServerSocket.\n+\t(setOption): Save value for SO_TIMEOUT.\n+\t(getOption): Return timeout for SO_TIMEOUT.\n+\n 1999-05-26  Bryce McKinlay <bryce@albatross.co.nz>\n \n \t* java/net/DatagramSocket.java (getSoTimeout): Verify class type."}, {"sha": "96d9555590be646a96d8a0f50d33636c188faf71", "filename": "libjava/java/net/DatagramSocket.java", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07515641a55ffacad7a289e32702831f54630d07/libjava%2Fjava%2Fnet%2FDatagramSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07515641a55ffacad7a289e32702831f54630d07/libjava%2Fjava%2Fnet%2FDatagramSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FDatagramSocket.java?ref=07515641a55ffacad7a289e32702831f54630d07", "patch": "@@ -25,8 +25,6 @@\n public class DatagramSocket\n {\n   DatagramSocketImpl impl;\n-  // FIXME: Shouldn't this be determined by getsockname() instead?\n-  InetAddress laddr;\n \n   public DatagramSocket() throws SocketException\n   {\n@@ -53,23 +51,12 @@ public DatagramSocket(int port, InetAddress laddr) throws SocketException\n     impl = (DatagramSocketImpl) Class.forName(\"java.net.\" + propVal +\n \t\t\t\t\t\"DatagramSocketImpl\").newInstance();\n     impl.create();\n-    // TBD: if this is right then the same should be done in Socket().\n-    try\n-    {\n-      if (laddr == null)\n-\tladdr = InetAddress.getLocalHost();\n-    }\n-    catch (UnknownHostException e)\n-    {\n-      throw new BindException(e.getMessage());\n-    }\n \n     // For multicasting, set the socket to be reused (Stevens pp. 195-6).\n     if (this instanceof MulticastSocket)\n       impl.setOption(SocketOptions.SO_REUSEADDR, new Boolean(true));\n \n     impl.bind(port, laddr);\n-    this.laddr = laddr;\n   }\n \n   public void close()\n@@ -79,7 +66,40 @@ public void close()\n \n   public InetAddress getLocalAddress()\n   {\n-    return laddr;\n+    SecurityManager s = System.getSecurityManager();\n+    // FIXME: JCL p. 510 says this should call checkConnect.  But what\n+    // string should be used as the hostname?  Maybe this is just a side\n+    // effect of calling InetAddress.getLocalHost.\n+    //\n+    // And is getOption with SO_BINDADDR the right way to get the address?\n+    // Doesn't seem to be since this method doesn't throw a SocketException\n+    // and SO_BINADDR can throw one.\n+    //\n+    // Also see RETURNS section in JCL p. 510 about returning any local\n+    // addr \"if the current execution context is not allowed to connect to\n+    // the network interface that is actually bound to this datagram socket.\"\n+    // How is that done?  via InetAddress.getLocalHost?  But that throws\n+    // an UnknownHostException and this method doesn't.\n+    //\n+    // if (s != null)\n+    //   s.checkConnect(\"localhost\", -1);\n+    try\n+      {\n+\treturn (InetAddress)impl.getOption(SocketOptions.SO_BINDADDR);\n+      }\n+    catch (SocketException ex)\n+      {\n+      }\n+\n+    try\n+      {\n+\treturn InetAddress.getLocalHost();\n+      }\n+    catch (UnknownHostException ex)\n+      {\n+\t// FIXME: This should never happen, so how can we avoid this construct?\n+\treturn null;\n+      }\n   }\n \n   public int getLocalPort()"}, {"sha": "6759e3bc3ca5c5d39518ad17af3068c885c9e9de", "filename": "libjava/java/net/MulticastSocket.java", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07515641a55ffacad7a289e32702831f54630d07/libjava%2Fjava%2Fnet%2FMulticastSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07515641a55ffacad7a289e32702831f54630d07/libjava%2Fjava%2Fnet%2FMulticastSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FMulticastSocket.java?ref=07515641a55ffacad7a289e32702831f54630d07", "patch": "@@ -76,14 +76,18 @@ public void setTTL(byte ttl) throws IOException\n   // JDK1.2\n   public void setTimeToLive(int ttl) throws IOException\n   {\n-    if (ttl < 0 || ttl > 255)\n+    if (ttl <= 0 || ttl > 255)\n       throw new IllegalArgumentException(\"Invalid ttl: \" + ttl);\n \n     impl.setTimeToLive(ttl);\n   }\n \n   public void joinGroup(InetAddress mcastaddr) throws IOException\n   {\n+    // FIXME: We can't currently rely on NullPointerException being\n+    // thrown when we invoke a method on a null object.\n+    if (mcastaddr == null)\n+      throw new NullPointerException(\"Null address\");\n     if (! mcastaddr.isMulticastAddress())\n       throw new IOException(\"Not a Multicast address\");\n \n@@ -96,6 +100,10 @@ public void joinGroup(InetAddress mcastaddr) throws IOException\n \n   public void leaveGroup(InetAddress mcastaddr) throws IOException\n   {\n+    // FIXME: We can't currently rely on NullPointerException being\n+    // thrown when we invoke a method on a null object.\n+    if (mcastaddr == null)\n+      throw new NullPointerException(\"Null address\");\n     if (! mcastaddr.isMulticastAddress())\n       throw new IOException(\"Not a Multicast address\");\n "}, {"sha": "90e296f174935ee2dcfcfa9e097a6c803119ae01", "filename": "libjava/java/net/PlainDatagramSocketImpl.java", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07515641a55ffacad7a289e32702831f54630d07/libjava%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07515641a55ffacad7a289e32702831f54630d07/libjava%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FPlainDatagramSocketImpl.java?ref=07515641a55ffacad7a289e32702831f54630d07", "patch": "@@ -36,8 +36,11 @@ class PlainDatagramSocketImpl extends DatagramSocketImpl\n                    _Jv_SO_RCVBUF_ = SocketOptions.SO_RCVBUF;\n \n   int fnum = -1;\n-  InetAddress address;\t// TBD: DatagramSocket.getLocalAddress()?\n-  // FIXME: These values are set/read by setOption/getOption.\n+\n+  // FIXME: Is this necessary?  Could it help w/ DatagramSocket.getLocalAddress?\n+  InetAddress address;\t\n+\n+  // These values are set/read by setOption/getOption.\n   int timeout = 0;\n   InetAddress iface = null;\n   int ttl = -1;"}, {"sha": "17c8071ac39716d3136973adf92ca90774288c1f", "filename": "libjava/java/net/PlainSocketImpl.java", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07515641a55ffacad7a289e32702831f54630d07/libjava%2Fjava%2Fnet%2FPlainSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07515641a55ffacad7a289e32702831f54630d07/libjava%2Fjava%2Fnet%2FPlainSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FPlainSocketImpl.java?ref=07515641a55ffacad7a289e32702831f54630d07", "patch": "@@ -37,6 +37,9 @@ class PlainSocketImpl extends SocketImpl\n \n   int fnum = -1;\n \n+  // This value is set/read by setOption/getOption.\n+  int timeout = 0;\n+\n   public native void setOption(int optID, Object value) throws SocketException;\n \n   public native Object getOption(int optID) throws SocketException;\n@@ -66,6 +69,7 @@ protected void accept (SocketImpl s) throws IOException\n \n   protected InputStream getInputStream() throws IOException\n   {\n+    // FIXME: TODO - Implement class SocketInputStream timeouts in read();\n     if (in == null)\n       in = new FileInputStream (fd);\n     return in;"}, {"sha": "96690faad88db1dec044805386c361f77084a569", "filename": "libjava/java/net/ServerSocket.java", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07515641a55ffacad7a289e32702831f54630d07/libjava%2Fjava%2Fnet%2FServerSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07515641a55ffacad7a289e32702831f54630d07/libjava%2Fjava%2Fnet%2FServerSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FServerSocket.java?ref=07515641a55ffacad7a289e32702831f54630d07", "patch": "@@ -28,6 +28,8 @@\n   public ServerSocket (int port)\n     throws java.io.IOException\n   {\n+    // FIXME: JCL p. 1526 says backlog defaults to 50; is 5 to save space\n+    // or a typo?\n     this(port, 5);\n   }\n "}, {"sha": "db46db18e45acf7fb5591104af537a4b4451b59b", "filename": "libjava/java/net/Socket.java", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07515641a55ffacad7a289e32702831f54630d07/libjava%2Fjava%2Fnet%2FSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07515641a55ffacad7a289e32702831f54630d07/libjava%2Fjava%2Fnet%2FSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocket.java?ref=07515641a55ffacad7a289e32702831f54630d07", "patch": "@@ -42,6 +42,9 @@ public Socket (String host, int port)\n     if (s != null)\n       s.checkConnect(host, port);\n     impl.create(true);\n+    // FIXME: JCL p. 1586 says if localPort is unspecified, bind to any port,\n+    // i.e. '0' and if localAddr is unspecified, use getLocalAddress() as\n+    // that default.  JDK 1.2 doc infers not to do a bind.\n     impl.connect(host, port);\n   }\n \n@@ -53,6 +56,9 @@ public Socket (InetAddress address, int port)\n     if (s != null)\n       s.checkConnect(address.getHostName(), port);\n     impl.create(true);\n+    // FIXME: JCL p. 1586 says if localPort is unspecified, bind to any port,\n+    // i.e. '0' and if localAddr is unspecified, use getLocalAddress() as\n+    // that default.  JDK 1.2 doc infers not to do a bind.\n     impl.connect(address, port);\n   }\n \n@@ -64,6 +70,7 @@ public Socket (String host, int port,\n     if (s != null)\n       s.checkConnect(host, port);\n     impl.create(true);\n+    // FIXME: JCL p. 1587 says if localAddr is null, use getLocalAddress().\n     impl.bind(localAddr, localPort);\n     impl.connect(host, port);\n   }\n@@ -76,6 +83,7 @@ public Socket (InetAddress address, int port,\n     if (s != null)\n       s.checkConnect(address.getHostName(), port);\n     impl.create(true);\n+    // FIXME: JCL p. 1587 says if localAddr is null, use getLocalAddress().\n     impl.bind(localAddr, localPort);\n     impl.connect(address, port);\n   }\n@@ -91,6 +99,9 @@ public Socket (String host, int port, boolean stream) throws IOException\n     SecurityManager s = System.getSecurityManager();\n     if (s != null)\n       s.checkConnect(host, port);\n+    // FIXME: JCL p. 1586 says if localPort is unspecified, bind to any port,\n+    // i.e. '0' and if localAddr is unspecified, use getLocalAddress() as\n+    // that default.  JDK 1.2 doc infers not to do a bind.\n     impl.connect(host, port);\n   }\n \n@@ -105,6 +116,9 @@ public Socket (InetAddress host, int port, boolean stream) throws IOException\n     SecurityManager s = System.getSecurityManager();\n     if (s != null)\n       s.checkConnect(host.getHostName(), port);\n+    // FIXME: JCL p. 1586 says if localPort is unspecified, bind to any port,\n+    // i.e. '0' and if localAddr is unspecified, use getLocalAddress() as\n+    // that default.  JDK 1.2 doc infers not to do a bind.\n     impl.connect(host, port);\n   }\n "}, {"sha": "74de74fd0dea2a675c429386d463a7c2f8264f4c", "filename": "libjava/java/net/natPlainDatagramSocketImpl.cc", "status": "modified", "additions": 184, "deletions": 21, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07515641a55ffacad7a289e32702831f54630d07/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07515641a55ffacad7a289e32702831f54630d07/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc?ref=07515641a55ffacad7a289e32702831f54630d07", "patch": "@@ -10,6 +10,8 @@ details.  */\n \n #include <sys/types.h>\n #include <sys/socket.h>\n+#include <sys/time.h>\n+#include <sys/select.h>\n #include <netinet/in.h>\n #include <errno.h>\n #include <stdio.h>\n@@ -18,12 +20,16 @@ details.  */\n #include <cni.h>\n #include <java/io/IOException.h>\n #include <java/io/FileDescriptor.h>\n+#include <java/io/InterruptedIOException.h>\n #include <java/net/BindException.h>\n #include <java/net/SocketException.h>\n #include <java/net/PlainDatagramSocketImpl.h>\n #include <java/net/InetAddress.h>\n #include <java/net/DatagramPacket.h>\n+#include <java/lang/InternalError.h>\n+#include <java/lang/Object.h>\n #include <java/lang/Boolean.h>\n+#include <java/lang/Integer.h>\n \n #ifndef HAVE_SOCKLEN_T\n typedef int socklen_t;\n@@ -70,14 +76,25 @@ java::net::PlainDatagramSocketImpl::bind (jint lport,\n {\n   // FIXME: prob. need to do a setsockopt with SO_BROADCAST to allow multicast.\n   union SockAddr u;\n-  jbyteArray haddress = host->address;\n-  jbyte *bytes = elements (haddress);\n-  int len = haddress->length;\n   struct sockaddr *ptr = (struct sockaddr *) &u.address;\n+  jbyte *bytes = NULL;\n+  // FIXME: Use getaddrinfo() to get actual protocol instead of assuming ipv4.\n+  int len = 4;\t// Initialize for INADDR_ANY in case host is NULL.\n+\n+  if (host != NULL)\n+    {\n+      jbyteArray haddress = host->address;\n+      bytes = elements (haddress);\n+      len = haddress->length;\n+    }\n+\n   if (len == 4)\n     {\n       u.address.sin_family = AF_INET;\n-      memcpy (&u.address.sin_addr, bytes, len);\n+      if (host != NULL)\n+\tmemcpy (&u.address.sin_addr, bytes, len);\n+      else\n+\tu.address.sin_addr.s_addr = htonl (INADDR_ANY);\n       len = sizeof (struct sockaddr_in);\n       u.address.sin_port = htons (lport);\n     }\n@@ -94,8 +111,15 @@ java::net::PlainDatagramSocketImpl::bind (jint lport,\n     goto error;\n   if (::bind (fnum, ptr, len) == 0)\n     {\n+      // FIXME: Is address really necessary to set?\n       address = host;\n-      localport = lport;\n+      socklen_t addrlen = sizeof(u);\n+      if (lport != 0)\n+        localport = lport;\n+      else if (::getsockname (fnum, (sockaddr*) &u, &addrlen) == 0)\n+        localport = ntohs (u.address.sin_port);\n+      else\n+        goto error;\n       return;\n     }\n  error:\n@@ -190,7 +214,25 @@ java::net::PlainDatagramSocketImpl::receive (java::net::DatagramPacket *p)\n   union SockAddr u;\n   socklen_t addrlen = sizeof(u);\n   jbyte *dbytes = elements (p->getData());\n-  ssize_t retlen =\n+  ssize_t retlen = 0;\n+\n+  // Do timeouts via select since SO_RCVTIMEO is not always available.\n+  if (timeout > 0)\n+    {\n+      fd_set rset;\n+      struct timeval tv;\n+      FD_ZERO(&rset);\n+      FD_SET(fnum, &rset);\n+      tv.tv_sec = timeout / 1000;\n+      tv.tv_usec = (timeout % 1000) * 1000;\n+      int retval;\n+      if ((retval = select (fnum + 1, &rset, NULL, NULL, &tv)) < 0)\n+\tgoto error;\n+      else if (retval == 0)\n+\tJvThrow (new java::io::InterruptedIOException ());\n+    }\n+\n+  retlen =\n     ::recvfrom (fnum, (char *) dbytes, p->getLength(), 0, (sockaddr*) &u,\n       &addrlen);\n   if (retlen < 0)\n@@ -288,17 +330,74 @@ void\n java::net::PlainDatagramSocketImpl::setOption (jint optID,\n   java::lang::Object *value)\n {\n-  if (optID == _Jv_SO_REUSEADDR_)\n+  int val;\n+  socklen_t val_len = sizeof (val);\n+\n+  if ( _Jv_IsInstanceOf(value,\n+    java::lang::Class::forName(JvNewStringUTF(\"java.lang.Boolean\"))))\n     {\n-      // FIXME: Is it possible that a Boolean wasn't passed in?\n-      const int on = (((java::lang::Boolean *) value)->booleanValue()) ? 1 : 0;\n-      if (::setsockopt (fnum, SOL_SOCKET, SO_REUSEADDR, (char *) &on,\n-\t  sizeof (int)) == 0)\n+      java::lang::Boolean *boolobj = \n+        static_cast<java::lang::Boolean *> (value);\n+      val = boolobj->booleanValue() ? 1 : 0;\n+    }\n+  else if ( _Jv_IsInstanceOf(value,\n+      java::lang::Class::forName(JvNewStringUTF(\"java.lang.Integer\"))))\n+    {\n+      java::lang::Integer *intobj = \n+        static_cast<java::lang::Integer *> (value);          \n+      val = (int) intobj->intValue();\n+    }\n+  // Else assume value to be an InetAddress for use with IP_MULTICAST_IF.\n+\n+  switch (optID) \n+    {\n+      case _Jv_TCP_NODELAY_ :\n+        JvThrow (new java::net::SocketException (\n+          JvNewStringUTF (\"TCP_NODELAY not valid for UDP\")));      \n+        return;\n+      case _Jv_SO_LINGER_ :\n+        JvThrow (new java::net::SocketException (\n+          JvNewStringUTF (\"SO_LINGER not valid for UDP\")));      \n+        return;\n+      case _Jv_SO_SNDBUF_ :\n+      case _Jv_SO_RCVBUF_ :\n+#if defined(SO_SNDBUF) && defined(SO_RCVBUF)\n+        int opt;\n+        optID == _Jv_SO_SNDBUF_ ? opt = SO_SNDBUF : opt = SO_RCVBUF;\n+        if (::setsockopt (fnum, SOL_SOCKET, opt, (char *) &val, val_len) != 0)\n+\t  goto error;    \n+#else\n+        JvThrow (new java::lang::InternalError (\n+          JvNewStringUTF (\"SO_RCVBUF/SO_SNDBUF not supported\")));\n+#endif \n+        return;\n+      case _Jv_SO_REUSEADDR_ :\n+#if defined(SO_REUSEADDR)\n+\tif (::setsockopt (fnum, SOL_SOCKET, SO_REUSEADDR, (char *) &val,\n+\t    val_len) != 0)\n+\t  goto error;\n+#else\n+        JvThrow (new java::lang::InternalError (\n+          JvNewStringUTF (\"SO_REUSEADDR not supported\")));\n+#endif \n+\treturn;\n+      case _Jv_SO_BINDADDR_ :\n+        JvThrow (new java::net::SocketException (\n+          JvNewStringUTF (\"SO_BINDADDR: read only option\")));\n         return;\n+      case _Jv_IP_MULTICAST_IF_ :\n+\t// FIXME: TODO - Implement IP_MULTICAST_IF.\n+        JvThrow (new java::lang::InternalError (\n+          JvNewStringUTF (\"IP_MULTICAST_IF: option not implemented\")));\n+        return;\n+      case _Jv_SO_TIMEOUT_ :\n+\ttimeout = val;\n+        return;\n+      default :\n+        errno = ENOPROTOOPT;\n     }\n-  else\n-    errno = ENOPROTOOPT;\n \n+ error:\n   char msg[100];\n   char* strerr = strerror (errno);\n   sprintf (msg, \"DatagramSocketImpl.setOption: %.*s\", 80, strerr);\n@@ -308,17 +407,81 @@ java::net::PlainDatagramSocketImpl::setOption (jint optID,\n java::lang::Object *\n java::net::PlainDatagramSocketImpl::getOption (jint optID)\n {\n-  if (optID == _Jv_SO_REUSEADDR_)\n+  int val;\n+  socklen_t val_len = sizeof(val);\n+  union SockAddr u;\n+  socklen_t addrlen = sizeof(u);\n+\n+  switch (optID)\n     {\n-      int on;\n-      socklen_t len;\n-      if (::getsockopt (fnum, SOL_SOCKET, SO_REUSEADDR, (char *) &on,\n-\t  (socklen_t *) &len) == 0)\n-        return new java::lang::Boolean (on == 1);\n+      case _Jv_TCP_NODELAY_ :\n+        JvThrow (new java::net::SocketException (\n+          JvNewStringUTF (\"TCP_NODELAY not valid for UDP\")));      \n+        break;\n+\n+      case _Jv_SO_LINGER_ :\n+        JvThrow (new java::net::SocketException (\n+          JvNewStringUTF (\"SO_LINGER not valid for UDP\")));      \n+        break;    \n+      case _Jv_SO_RCVBUF_ :\n+      case _Jv_SO_SNDBUF_ :\n+#if defined(SO_SNDBUF) && defined(SO_RCVBUF)\n+        int opt;\n+        optID == _Jv_SO_SNDBUF_ ? opt = SO_SNDBUF : opt = SO_RCVBUF;\n+        if (::getsockopt (fnum, SOL_SOCKET, opt, (char *) &val, &val_len) != 0)\n+\t  goto error;    \n+        else\n+\t  return new java::lang::Integer (val);\n+#else\n+        JvThrow (new java::lang::InternalError (\n+          JvNewStringUTF (\"SO_RCVBUF/SO_SNDBUF not supported\")));\n+#endif    \n+\tbreak;\n+      case _Jv_SO_BINDADDR_:\n+\t// FIXME: Should cache the laddr as an optimization.\n+\tjbyteArray laddr;\n+\tif (::getsockname (fnum, (sockaddr*) &u, &addrlen) != 0)\n+\t  goto error;\n+\tif (u.address.sin_family == AF_INET)\n+\t  {\n+\t    laddr = JvNewByteArray (4);\n+\t    memcpy (elements (laddr), &u.address.sin_addr, 4);\n+\t  }\n+#ifdef HAVE_INET6\n+        else if (u.address.sin_family == AF_INET6)\n+\t  {\n+\t    laddr = JvNewByteArray (16);\n+\t    memcpy (elements (laddr), &u.address6.sin6_addr, 16);\n+\t  }\n+#endif\n+\telse\n+\t  goto error;\n+\treturn new java::net::InetAddress (laddr, NULL);\n+\tbreak;\n+      case _Jv_SO_REUSEADDR_ :\n+#if defined(SO_REUSEADDR)\n+\tif (::getsockopt (fnum, SOL_SOCKET, SO_REUSEADDR, (char *) &val,\n+\t    &val_len) != 0)\n+\t  goto error;\n+\treturn new java::lang::Boolean (val != 0);\n+#else\n+        JvThrow (new java::lang::InternalError (\n+          JvNewStringUTF (\"SO_REUSEADDR not supported\")));\n+#endif \n+\tbreak;\n+      case _Jv_IP_MULTICAST_IF_ :\n+\t// FIXME: TODO - Implement IP_MULTICAST_IF.\n+\tJvThrow (new java::lang::InternalError (\n+\t  JvNewStringUTF (\"IP_MULTICAST_IF: option not implemented\")));\n+\tbreak;\n+      case _Jv_SO_TIMEOUT_ :\n+\treturn new java::lang::Integer (timeout);\n+\tbreak;\n+      default :\n+\terrno = ENOPROTOOPT;\n     }\n-  else\n-    errno = ENOPROTOOPT;\n \n+ error:\n   char msg[100];\n   char* strerr = strerror (errno);\n   sprintf (msg, \"DatagramSocketImpl.getOption: %.*s\", 80, strerr);"}, {"sha": "8ad23cbab6917316a57dc8ecebbdb7a71dc84858", "filename": "libjava/java/net/natPlainSocketImpl.cc", "status": "modified", "additions": 45, "deletions": 16, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07515641a55ffacad7a289e32702831f54630d07/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07515641a55ffacad7a289e32702831f54630d07/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc?ref=07515641a55ffacad7a289e32702831f54630d07", "patch": "@@ -10,6 +10,8 @@ details.  */\n \n #include <sys/types.h>\n #include <sys/socket.h>\n+#include <sys/time.h>\n+#include <sys/select.h>\n #include <netinet/in.h>\n #include <netinet/tcp.h>\n #include <errno.h>\n@@ -20,6 +22,7 @@ details.  */\n #include <javaprims.h>\n #include <java/io/IOException.h>\n #include <java/io/FileDescriptor.h>\n+#include <java/io/InterruptedIOException.h>\n #include <java/net/BindException.h>\n #include <java/net/ConnectException.h>\n #include <java/net/PlainSocketImpl.h>\n@@ -87,7 +90,13 @@ java::net::PlainSocketImpl::bind (java::net::InetAddress *host, jint lport)\n   if (::bind (fnum, ptr, len) == 0)\n     {\n       address = host;\n-      localport = lport;\n+      socklen_t addrlen = sizeof(u);\n+      if (lport != 0)\n+        localport = lport;\n+      else if (::getsockname (fnum, (sockaddr*) &u, &addrlen) == 0)\n+        localport = ntohs (u.address.sin_port);\n+      else\n+        goto error;\n       return;\n     }\n  error:\n@@ -128,9 +137,12 @@ java::net::PlainSocketImpl::connect (java::net::InetAddress *host, jint rport)\n     goto error;\n   address = host;\n   port = rport;\n-  if (::getsockname (fnum, (sockaddr*) &u, &addrlen) != 0)\n-    goto error;\n-  localport = ntohs (u.address.sin_port);\n+  // A bind may not have been done on this socket; if so, set localport now.\n+  if (localport == 0)\n+    if (::getsockname (fnum, (sockaddr*) &u, &addrlen) == 0)\n+      localport = ntohs (u.address.sin_port);\n+    else\n+      goto error;\n   return;  \n  error:\n   char msg[100];\n@@ -156,7 +168,25 @@ java::net::PlainSocketImpl::accept (java::net::PlainSocketImpl *s)\n {\n   union SockAddr u;\n   socklen_t addrlen = sizeof(u);\n-  int new_socket = ::accept (fnum, (sockaddr*) &u, &addrlen);\n+  int new_socket = 0; \n+\n+  // Do timeouts via select since SO_RCVTIMEO is not always available.\n+  if (timeout > 0)\n+    {\n+      fd_set rset;\n+      struct timeval tv;\n+      FD_ZERO(&rset);\n+      FD_SET(fnum, &rset);\n+      tv.tv_sec = timeout / 1000;\n+      tv.tv_usec = (timeout % 1000) * 1000;\n+      int retval;\n+      if ((retval = select (fnum + 1, &rset, NULL, NULL, &tv)) < 0)\n+\tgoto error;\n+      else if (retval == 0)\n+\tJvThrow (new java::io::InterruptedIOException ());\n+    }\n+\n+  new_socket = ::accept (fnum, (sockaddr*) &u, &addrlen);\n   if (new_socket < 0)\n     goto error;\n   jbyteArray raddr;\n@@ -260,16 +290,15 @@ java::net::PlainSocketImpl::setOption (jint optID, java::lang::Object *value)\n           JvNewStringUTF (\"SO_BINDADDR: read only option\")));\n         return;\n       case _Jv_IP_MULTICAST_IF_ :\n-        JvThrow (new java::lang::InternalError (\n+        JvThrow (new java::net::SocketException (\n           JvNewStringUTF (\"IP_MULTICAST_IF: not valid for TCP\")));\n         return;\n       case _Jv_SO_REUSEADDR_ :\n-        JvThrow (new java::lang::InternalError (\n-          JvNewStringUTF (\"SO_REUSEADDR: option not implemented\")));\n+        JvThrow (new java::net::SocketException (\n+          JvNewStringUTF (\"SO_REUSEADDR: not valid for TCP\")));\n         return;\n       case _Jv_SO_TIMEOUT_ :\n-        JvThrow (new java::lang::InternalError (\n-          JvNewStringUTF (\"SO_TIMEOUT: option not implemented\")));\n+\ttimeout = val;\n         return;\n       default :\n         errno = ENOPROTOOPT;\n@@ -336,6 +365,7 @@ java::net::PlainSocketImpl::getOption (jint optID)\n #endif    \n \tbreak;\n       case _Jv_SO_BINDADDR_:\n+\t// FIXME: Should cache the laddr as an optimization.\n \tjbyteArray laddr;\n \tif (::getsockname (fnum, (sockaddr*) &u, &addrlen) != 0)\n \t  goto error;\n@@ -356,16 +386,15 @@ java::net::PlainSocketImpl::getOption (jint optID)\n \treturn new java::net::InetAddress (laddr, NULL);\n \tbreak;\n       case _Jv_IP_MULTICAST_IF_ :\n-\tJvThrow (new java::lang::InternalError (\n-\t  JvNewStringUTF (\"IP_MULTICAST_IF: option not implemented\")));\n+\tJvThrow (new java::net::SocketException (\n+\t  JvNewStringUTF (\"IP_MULTICAST_IF: not valid for TCP\")));\n \tbreak;\n       case _Jv_SO_REUSEADDR_ :\n-\tJvThrow (new java::lang::InternalError (\n-\t  JvNewStringUTF (\"SO_REUSEADDR: option not implemented\")));\n+\tJvThrow (new java::net::SocketException (\n+\t  JvNewStringUTF (\"SO_REUSEADDR: not valid for TCP\")));\n \tbreak;\n       case _Jv_SO_TIMEOUT_ :\n-\tJvThrow (new java::lang::InternalError (\n-\t  JvNewStringUTF (\"SO_TIMEOUT: option not implemented\")));\n+\treturn new java::lang::Integer (timeout);\n \tbreak;\n       default :\n \terrno = ENOPROTOOPT;"}]}