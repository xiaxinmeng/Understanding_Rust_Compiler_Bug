{"sha": "00bfffa4c0730935f8cb16d59a72683b6d4c82bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBiZmZmYTRjMDczMDkzNWY4Y2IxNmQ1OWE3MjY4M2I2ZDRjODJiZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2004-04-30T17:25:42Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2004-04-30T17:25:42Z"}, "message": "Refer to base members using COMPONENT_REFs where possible.\n\n        * class.c (build_simple_base_path): New fn.\n        (build_base_path): Use it for non-virtual base references.\n        (layout_class_type): Change base fields to their real type\n        after layout is done.\n        * cp-tree.h (IS_FAKE_BASE_TYPE): New macro.\n        * cp-lang.c (cxx_get_alias_set): Use it.\n\nFrom-SVN: r81349", "tree": {"sha": "4ac93946f88f9d873dc4b509f6b118ec816ee667", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ac93946f88f9d873dc4b509f6b118ec816ee667"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00bfffa4c0730935f8cb16d59a72683b6d4c82bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00bfffa4c0730935f8cb16d59a72683b6d4c82bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00bfffa4c0730935f8cb16d59a72683b6d4c82bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00bfffa4c0730935f8cb16d59a72683b6d4c82bd/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ed9676cf0ca3101a8933826b0dcc9aacae689f23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed9676cf0ca3101a8933826b0dcc9aacae689f23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed9676cf0ca3101a8933826b0dcc9aacae689f23"}], "stats": {"total": 108, "additions": 99, "deletions": 9}, "files": [{"sha": "0f0a5e2cf7fb55383a93cc9a4d07ba6f300aee33", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00bfffa4c0730935f8cb16d59a72683b6d4c82bd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00bfffa4c0730935f8cb16d59a72683b6d4c82bd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=00bfffa4c0730935f8cb16d59a72683b6d4c82bd", "patch": "@@ -1,3 +1,13 @@\n+2004-04-30  Jason Merrill  <jason@redhat.com>\n+\n+\tRefer to base members using COMPONENT_REFs where possible.\n+\t* class.c (build_simple_base_path): New fn.\n+\t(build_base_path): Use it for non-virtual base references.\n+\t(layout_class_type): Change base fields to their real type\n+\tafter layout is done.\n+\t* cp-tree.h (IS_FAKE_BASE_TYPE): New macro.\n+\t* cp-lang.c (cxx_get_alias_set): Use it.\n+\n 2004-04-30  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* class.c, cp-tree.h, decl.c, decl2.c, pt.c, rtti.c: Fix"}, {"sha": "13d6d03c9a595d6a9c32bbcd1e3d2c2f91bed087", "filename": "gcc/cp/class.c", "status": "modified", "additions": 81, "deletions": 6, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00bfffa4c0730935f8cb16d59a72683b6d4c82bd/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00bfffa4c0730935f8cb16d59a72683b6d4c82bd/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=00bfffa4c0730935f8cb16d59a72683b6d4c82bd", "patch": "@@ -129,6 +129,7 @@ static void add_implicitly_declared_members (tree, int, int, int);\n static tree fixed_type_or_null (tree, int *, int *);\n static tree resolve_address_of_overloaded_function (tree, tree, tsubst_flags_t,\n \t\t\t\t\t\t    bool, tree);\n+static tree build_simple_base_path (tree expr, tree binfo);\n static tree build_vtbl_ref_1 (tree, tree);\n static tree build_vtbl_initializer (tree, tree, tree, tree, int *);\n static int count_fields (tree);\n@@ -253,27 +254,34 @@ build_base_path (enum tree_code code,\n   tree ptr_target_type;\n   int fixed_type_p;\n   int want_pointer = TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE;\n+  bool has_empty = false;\n \n   if (expr == error_mark_node || binfo == error_mark_node || !binfo)\n     return error_mark_node;\n \n   for (probe = binfo; probe; probe = BINFO_INHERITANCE_CHAIN (probe))\n     {\n       d_binfo = probe;\n+      if (is_empty_class (BINFO_TYPE (probe)))\n+\thas_empty = true;\n       if (!v_binfo && TREE_VIA_VIRTUAL (probe))\n \tv_binfo = probe;\n     }\n \n   probe = TYPE_MAIN_VARIANT (TREE_TYPE (expr));\n   if (want_pointer)\n     probe = TYPE_MAIN_VARIANT (TREE_TYPE (probe));\n-  \n+\n   my_friendly_assert (code == MINUS_EXPR\n \t\t      ? same_type_p (BINFO_TYPE (binfo), probe)\n \t\t      : code == PLUS_EXPR\n \t\t      ? same_type_p (BINFO_TYPE (d_binfo), probe)\n \t\t      : false, 20010723);\n   \n+  if (binfo == d_binfo)\n+    /* Nothing to do.  */\n+    return expr;\n+\n   if (code == MINUS_EXPR && v_binfo)\n     {\n       error (\"cannot convert from base `%T' to derived type `%T' via virtual base `%T'\",\n@@ -285,16 +293,36 @@ build_base_path (enum tree_code code,\n     /* This must happen before the call to save_expr.  */\n     expr = build_unary_op (ADDR_EXPR, expr, 0);\n \n+  offset = BINFO_OFFSET (binfo);\n   fixed_type_p = resolves_to_fixed_type_p (expr, &nonnull);\n-  if (fixed_type_p <= 0 && TREE_SIDE_EFFECTS (expr))\n+\n+  if (want_pointer && !nonnull\n+      && (!integer_zerop (offset) || (v_binfo && fixed_type_p <= 0)))\n+    null_test = error_mark_node;\n+\n+  if (TREE_SIDE_EFFECTS (expr)\n+      && (null_test || (v_binfo && fixed_type_p <= 0)))\n     expr = save_expr (expr);\n \n-  if (want_pointer && !nonnull)\n+  if (null_test)\n     null_test = fold (build2 (NE_EXPR, boolean_type_node,\n \t\t\t      expr, integer_zero_node));\n-  \n-  offset = BINFO_OFFSET (binfo);\n-  \n+\n+  /* If this is a simple base reference, express it as a COMPONENT_REF.  */\n+  if (code == PLUS_EXPR\n+      && (v_binfo == NULL_TREE || fixed_type_p > 0)\n+      /* We don't build base fields for empty bases, and they aren't very\n+\t interesting to the optimizers anyway.  */\n+      && !has_empty)\n+    {\n+      expr = build_indirect_ref (expr, NULL);\n+      expr = build_simple_base_path (expr, binfo);\n+      if (want_pointer)\n+\texpr = build_unary_op (ADDR_EXPR, expr, 0);\n+      target_type = TREE_TYPE (expr);\n+      goto out;\n+    }\n+\n   if (v_binfo && fixed_type_p <= 0)\n     {\n       /* Going via virtual base V_BINFO.  We need the static offset\n@@ -365,6 +393,7 @@ build_base_path (enum tree_code code,\n   if (!want_pointer)\n     expr = build_indirect_ref (expr, NULL);\n \n+ out:\n   if (null_test)\n     expr = fold (build3 (COND_EXPR, target_type, null_test, expr,\n \t\t\t fold (build1 (NOP_EXPR, target_type,\n@@ -373,6 +402,47 @@ build_base_path (enum tree_code code,\n   return expr;\n }\n \n+/* Subroutine of build_base_path; EXPR and BINFO are as in that function.\n+   Perform a derived-to-base conversion by recursively building up a\n+   sequence of COMPONENT_REFs to the appropriate base fields.  */\n+\n+static tree\n+build_simple_base_path (tree expr, tree binfo)\n+{\n+  tree type = BINFO_TYPE (binfo);\n+  tree d_binfo;\n+  tree field;\n+\n+  /* For primary virtual bases, we can't just follow\n+     BINFO_INHERITANCE_CHAIN.  */\n+  d_binfo = BINFO_PRIMARY_BASE_OF (binfo);\n+  if (d_binfo == NULL_TREE)\n+    d_binfo = BINFO_INHERITANCE_CHAIN (binfo);\n+\n+  if (d_binfo == NULL_TREE)\n+    {\n+      if (TYPE_MAIN_VARIANT (TREE_TYPE (expr)) != type)\n+\tabort ();\n+      return expr;\n+    }\n+\n+  /* Recurse.  */\n+  expr = build_simple_base_path (expr, d_binfo);\n+\n+  for (field = TYPE_FIELDS (BINFO_TYPE (d_binfo));\n+       field; field = TREE_CHAIN (field))\n+    /* Is this the base field created by build_base_field?  */\n+    if (TREE_CODE (field) == FIELD_DECL\n+\t&& TREE_TYPE (field) == type\n+\t&& DECL_ARTIFICIAL (field)\n+\t&& DECL_IGNORED_P (field))\n+      return build_class_member_access_expr (expr, field,\n+\t\t\t\t\t     NULL_TREE, false);\n+\n+  /* Didn't find the base field?!?  */\n+  abort ();\n+}\n+\n /* Convert OBJECT to the base TYPE.  If CHECK_ACCESS is true, an error\n    message is emitted if TYPE is inaccessible.  OBJECT is assumed to\n    be non-NULL.  */\n@@ -4885,6 +4955,11 @@ layout_class_type (tree t, tree *virtuals_p)\n   /* Warn about bases that can't be talked about due to ambiguity.  */\n   warn_about_ambiguous_bases (t);\n \n+  /* Now that we're done with layout, give the base fields the real types.  */\n+  for (field = TYPE_FIELDS (t); field; field = TREE_CHAIN (field))\n+    if (DECL_ARTIFICIAL (field) && IS_FAKE_BASE_TYPE (TREE_TYPE (field)))\n+      TREE_TYPE (field) = TYPE_CONTEXT (TREE_TYPE (field));\n+\n   /* Clean up.  */\n   splay_tree_delete (empty_base_offsets);\n }"}, {"sha": "3c2a311e9ca109a52f47d8c6e37ac8714b324579", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00bfffa4c0730935f8cb16d59a72683b6d4c82bd/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00bfffa4c0730935f8cb16d59a72683b6d4c82bd/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=00bfffa4c0730935f8cb16d59a72683b6d4c82bd", "patch": "@@ -292,9 +292,7 @@ ok_to_generate_alias_set_for_type (tree t)\n static HOST_WIDE_INT\n cxx_get_alias_set (tree t)\n {\n-  if (TREE_CODE (t) == RECORD_TYPE\n-      && TYPE_CONTEXT (t) && CLASS_TYPE_P (TYPE_CONTEXT (t))\n-      && CLASSTYPE_AS_BASE (TYPE_CONTEXT (t)) == t)\n+  if (IS_FAKE_BASE_TYPE (t))\n     /* The base variant of a type must be in the same alias set as the\n        complete type.  */\n     return get_alias_set (TYPE_CONTEXT (t));"}, {"sha": "c3c7c868e25f229ccb865e6bf938b93020c70456", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00bfffa4c0730935f8cb16d59a72683b6d4c82bd/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00bfffa4c0730935f8cb16d59a72683b6d4c82bd/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=00bfffa4c0730935f8cb16d59a72683b6d4c82bd", "patch": "@@ -1302,6 +1302,13 @@ struct lang_type GTY(())\n \n #define CLASSTYPE_AS_BASE(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->as_base)\n \n+/* True iff NODE is the CLASSTYPE_AS_BASE version of some type.  */\n+\n+#define IS_FAKE_BASE_TYPE(NODE)\t\t\t\t\t\\\n+  (TREE_CODE (NODE) == RECORD_TYPE\t\t\t\t\\\n+   && TYPE_CONTEXT (NODE) && CLASS_TYPE_P (TYPE_CONTEXT (NODE))\t\\\n+   && CLASSTYPE_AS_BASE (TYPE_CONTEXT (NODE)) == (NODE))\n+\n /* These are the size and alignment of the type without its virtual\n    base classes, for when we use this type as a base itself.  */\n #define CLASSTYPE_SIZE(NODE) TYPE_SIZE (CLASSTYPE_AS_BASE (NODE))"}]}