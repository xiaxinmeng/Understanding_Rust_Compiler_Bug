{"sha": "3862ef76c66219fd7adbbd6e3884bc9c1ba9c606", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzg2MmVmNzZjNjYyMTlmZDdhZGJiZDZlMzg4NGJjOWMxYmE5YzYwNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-05-04T11:37:05Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-05-04T11:37:05Z"}, "message": "Cap niter_for_unrolled_loop to upper bound\n\nFor the reasons explained in PR77536, niter_for_unrolled_loop assumes 5\niterations in the absence of profiling information, although it doesn't\nincrease beyond the estimate for the original loop.  This left a hole in\nwhich the new estimate could be less than the old one but still greater\nthan the limit imposed by CEIL (nb_iterations_upper_bound, unroll factor).\n\n2017-05-04  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* tree-ssa-loop-manip.c (niter_for_unrolled_loop): Add commentary\n\tto explain the use of truncating division.  Cap the number of\n\titerations to the maximum given by nb_iterations_upper_bound,\n\tif defined.\n\ngcc/testsuite/\n\t* gcc.dg/vect/vect-profile-1.c: New test.\n\nFrom-SVN: r247591", "tree": {"sha": "9e4572707089e2b42a80ecb24d4d3b00ae89d8a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e4572707089e2b42a80ecb24d4d3b00ae89d8a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3862ef76c66219fd7adbbd6e3884bc9c1ba9c606", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3862ef76c66219fd7adbbd6e3884bc9c1ba9c606", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3862ef76c66219fd7adbbd6e3884bc9c1ba9c606", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3862ef76c66219fd7adbbd6e3884bc9c1ba9c606/comments", "author": null, "committer": null, "parents": [{"sha": "6d0da573d22e446f7740f6340131b11f605715bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d0da573d22e446f7740f6340131b11f605715bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d0da573d22e446f7740f6340131b11f605715bc"}], "stats": {"total": 58, "additions": 58, "deletions": 0}, "files": [{"sha": "854884537963aae739a9e37fb1b4b6c038b67956", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3862ef76c66219fd7adbbd6e3884bc9c1ba9c606/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3862ef76c66219fd7adbbd6e3884bc9c1ba9c606/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3862ef76c66219fd7adbbd6e3884bc9c1ba9c606", "patch": "@@ -1,3 +1,10 @@\n+2017-05-04  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* tree-ssa-loop-manip.c (niter_for_unrolled_loop): Add commentary\n+\tto explain the use of truncating division.  Cap the number of\n+\titerations to the maximum given by nb_iterations_upper_bound,\n+\tif defined.\n+\n 2017-05-04  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n \n \t* configure.ac (--enable-mingw-wildcard): Add new configurable feature."}, {"sha": "39fc9284da382797f817995733d067e97327d2c4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3862ef76c66219fd7adbbd6e3884bc9c1ba9c606/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3862ef76c66219fd7adbbd6e3884bc9c1ba9c606/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3862ef76c66219fd7adbbd6e3884bc9c1ba9c606", "patch": "@@ -1,3 +1,7 @@\n+2017-05-04  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* gcc.dg/vect/vect-profile-1.c: New test.\n+\n 2017-05-04  Marek Polacek  <polacek@redhat.com>\n \n \tPR tree-optimization/80612"}, {"sha": "93d7ad13147534f7dc95db763a487e326619fed6", "filename": "gcc/testsuite/gcc.dg/vect/vect-profile-1.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3862ef76c66219fd7adbbd6e3884bc9c1ba9c606/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-profile-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3862ef76c66219fd7adbbd6e3884bc9c1ba9c606/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-profile-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-profile-1.c?ref=3862ef76c66219fd7adbbd6e3884bc9c1ba9c606", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-additional-options \"-fdump-tree-vect-details-blocks\" } */\n+\n+/* At least one of these should correspond to a full vector.  */\n+\n+void\n+f1 (int *x)\n+{\n+  for (int j = 0; j < 2; ++j)\n+    x[j] += 1;\n+}\n+\n+void\n+f2 (int *x)\n+{\n+  for (int j = 0; j < 4; ++j)\n+    x[j] += 1;\n+}\n+\n+void\n+f3 (int *x)\n+{\n+  for (int j = 0; j < 8; ++j)\n+    x[j] += 1;\n+}\n+\n+void\n+f4 (int *x)\n+{\n+  for (int j = 0; j < 16; ++j)\n+    x[j] += 1;\n+}\n+\n+/* { dg-final { scan-tree-dump {goto <bb [0-9]+>; \\[0+.0*%\\]} vect } } */"}, {"sha": "d3a57f124fb294b1bb90e8e0dcf5dfe895e99038", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3862ef76c66219fd7adbbd6e3884bc9c1ba9c606/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3862ef76c66219fd7adbbd6e3884bc9c1ba9c606/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=3862ef76c66219fd7adbbd6e3884bc9c1ba9c606", "patch": "@@ -1104,6 +1104,9 @@ niter_for_unrolled_loop (struct loop *loop, unsigned factor)\n   gcc_assert (factor != 0);\n   bool profile_p = false;\n   gcov_type est_niter = expected_loop_iterations_unbounded (loop, &profile_p);\n+  /* Note that this is really CEIL (est_niter + 1, factor) - 1, where the\n+     \"+ 1\" converts latch iterations to loop iterations and the \"- 1\"\n+     converts back.  */\n   gcov_type new_est_niter = est_niter / factor;\n \n   /* Without profile feedback, loops for which we do not know a better estimate\n@@ -1120,6 +1123,15 @@ niter_for_unrolled_loop (struct loop *loop, unsigned factor)\n \tnew_est_niter = 5;\n     }\n \n+  if (loop->any_upper_bound)\n+    {\n+      /* As above, this is really CEIL (upper_bound + 1, factor) - 1.  */\n+      widest_int bound = wi::udiv_floor (loop->nb_iterations_upper_bound,\n+\t\t\t\t\t factor);\n+      if (wi::ltu_p (bound, new_est_niter))\n+\tnew_est_niter = bound.to_uhwi ();\n+    }\n+\n   return new_est_niter;\n }\n "}]}