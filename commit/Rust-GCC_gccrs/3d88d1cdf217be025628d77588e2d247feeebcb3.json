{"sha": "3d88d1cdf217be025628d77588e2d247feeebcb3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q4OGQxY2RmMjE3YmUwMjU2MjhkNzc1ODhlMmQyNDdmZWVlYmNiMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:13:59Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:13:59Z"}, "message": "[36/77] Use scalar_int_mode in the RTL iv routines\n\nThis patch changes the iv modes in rtx_iv from machine_mode\nto scalar_int_mode.  It also passes the mode of the iv down\nto subroutines; this avoids the previous situation in which\nthe mode information was sometimes lost and had to be added\nby the caller on return.\n\nSome routines already took a mode argument, but the patch\ntries to standardise on passing it immediately before the\nargument it describes.\n\ngcc/\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\n\t* cfgloop.h (rtx_iv): Change type of extend_mode and mode to\n\tscalar_int_mode.\n\t(niter_desc): Likewise mode.\n\t(iv_analyze): Add a mode parameter.\n\t(biv_p): Likewise.\n\t(iv_analyze_expr): Pass the mode paraeter before the rtx it describes\n\tand change its type to scalar_int_mode.\n\t* loop-iv.c: Update commentary at head of file.\n\t(iv_constant): Pass the mode paraeter before the rtx it describes\n\tand change its type to scalar_int_mode.  Remove VOIDmode handling.\n\t(iv_subreg): Change the type of the mode parameter to scalar_int_mode.\n\t(iv_extend): Likewise.\n\t(shorten_into_mode): Likewise.\n\t(iv_add): Use scalar_int_mode.\n\t(iv_mult): Likewise.\n\t(iv_shift): Likewise.\n\t(canonicalize_iv_subregs): Likewise.\n\t(get_biv_step_1): Pass the outer_mode parameter before the rtx\n\tit describes and change its mode to scalar_int_mode.   Also change\n\tthe type of the returned inner_mode to scalar_int_mode.\n\t(get_biv_step): Likewise, turning outer_mode from a pointer\n\tinto a direct parameter.  Update call to get_biv_step_1.\n\t(iv_analyze_biv): Add an outer_mode parameter.  Update calls to\n\tiv_constant and get_biv_step.\n\t(iv_analyze_expr): Pass the mode parameter before the rtx it describes\n\tand change its type to scalar_int_mode.  Don't initialise iv->mode\n\tto VOIDmode and remove later checks for its still being VOIDmode.\n\tUpdate calls to iv_analyze_op and iv_analyze_expr.  Check\n\tis_a <scalar_int_mode> when changing the mode under consideration.\n\t(iv_analyze_def): Ignore registers that don't have a scalar_int_mode.\n\tUpdate call to iv_analyze_expr.\n\t(iv_analyze_op): Add a mode parameter.  Reject subregs whose\n\tinner register is not also a scalar_int_mode.  Update call to\n\tiv_analyze_biv.\n\t(iv_analyze): Add a mode parameter.  Update call to iv_analyze_op.\n\t(biv_p): Add a mode parameter.  Update call to iv_analyze_biv.\n\t(iv_number_of_iterations): Use is_a <scalar_int_mode> instead of\n\tseparate mode class checks.  Update calls to iv_analyze.  Remove\n\tfix-up of VOIDmodes after iv_analyze_biv.\n\t* loop-unroll.c (analyze_iv_to_split_insn): Reject registers that\n\tdon't have a scalar_int_mode.  Update call to biv_p.\n\nFrom-SVN: r251488", "tree": {"sha": "c41c4e9ddde50854af5723c91183567add14e12a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c41c4e9ddde50854af5723c91183567add14e12a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d88d1cdf217be025628d77588e2d247feeebcb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d88d1cdf217be025628d77588e2d247feeebcb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d88d1cdf217be025628d77588e2d247feeebcb3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d88d1cdf217be025628d77588e2d247feeebcb3/comments", "author": null, "committer": null, "parents": [{"sha": "c7ad039d8d75666f4f188a913033da36206503b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7ad039d8d75666f4f188a913033da36206503b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7ad039d8d75666f4f188a913033da36206503b8"}], "stats": {"total": 180, "additions": 85, "deletions": 95}, "files": [{"sha": "fcf366745dfdf2dacaa83459d90853a14248ff0f", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d88d1cdf217be025628d77588e2d247feeebcb3/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d88d1cdf217be025628d77588e2d247feeebcb3/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=3d88d1cdf217be025628d77588e2d247feeebcb3", "patch": "@@ -421,10 +421,10 @@ struct rtx_iv\n   rtx delta, mult;\n \n   /* The mode it is extended to.  */\n-  machine_mode extend_mode;\n+  scalar_int_mode extend_mode;\n \n   /* The mode the variable iterates in.  */\n-  machine_mode mode;\n+  scalar_int_mode mode;\n \n   /* Whether the first iteration needs to be handled specially.  */\n   unsigned first_special : 1;\n@@ -465,19 +465,19 @@ struct GTY(()) niter_desc\n   bool signed_p;\n \n   /* The mode in that niter_expr should be computed.  */\n-  machine_mode mode;\n+  scalar_int_mode mode;\n \n   /* The number of iterations of the loop.  */\n   rtx niter_expr;\n };\n \n extern void iv_analysis_loop_init (struct loop *);\n-extern bool iv_analyze (rtx_insn *, rtx, struct rtx_iv *);\n+extern bool iv_analyze (rtx_insn *, scalar_int_mode, rtx, struct rtx_iv *);\n extern bool iv_analyze_result (rtx_insn *, rtx, struct rtx_iv *);\n-extern bool iv_analyze_expr (rtx_insn *, rtx, machine_mode,\n+extern bool iv_analyze_expr (rtx_insn *, scalar_int_mode, rtx,\n \t\t\t     struct rtx_iv *);\n extern rtx get_iv_value (struct rtx_iv *, rtx);\n-extern bool biv_p (rtx_insn *, rtx);\n+extern bool biv_p (rtx_insn *, scalar_int_mode, rtx);\n extern void find_simple_exit (struct loop *, struct niter_desc *);\n extern void iv_analysis_done (void);\n "}, {"sha": "1d0c66f2b2ffca0cd96689216dfd00ec91303ff3", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 76, "deletions": 87, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d88d1cdf217be025628d77588e2d247feeebcb3/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d88d1cdf217be025628d77588e2d247feeebcb3/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=3d88d1cdf217be025628d77588e2d247feeebcb3", "patch": "@@ -35,16 +35,17 @@ along with GCC; see the file COPYING3.  If not see\n \n    The available functions are:\n \n-   iv_analyze (insn, reg, iv): Stores the description of the induction variable\n-     corresponding to the use of register REG in INSN to IV.  Returns true if\n-     REG is an induction variable in INSN. false otherwise.\n-     If use of REG is not found in INSN, following insns are scanned (so that\n-     we may call this function on insn returned by get_condition).\n+   iv_analyze (insn, mode, reg, iv): Stores the description of the induction\n+     variable corresponding to the use of register REG in INSN to IV, given\n+     that REG has mode MODE.  Returns true if REG is an induction variable\n+     in INSN. false otherwise.  If a use of REG is not found in INSN,\n+     the following insns are scanned (so that we may call this function\n+     on insns returned by get_condition).\n    iv_analyze_result (insn, def, iv):  Stores to IV the description of the iv\n      corresponding to DEF, which is a register defined in INSN.\n-   iv_analyze_expr (insn, rhs, mode, iv):  Stores to IV the description of iv\n+   iv_analyze_expr (insn, mode, expr, iv):  Stores to IV the description of iv\n      corresponding to expression EXPR evaluated at INSN.  All registers used bu\n-     EXPR must also be used in INSN.\n+     EXPR must also be used in INSN.  MODE is the mode of EXPR.\n */\n \n #include \"config.h\"\n@@ -133,7 +134,7 @@ biv_entry_hasher::equal (const biv_entry *b, const rtx_def *r)\n \n static hash_table<biv_entry_hasher> *bivs;\n \n-static bool iv_analyze_op (rtx_insn *, rtx, struct rtx_iv *);\n+static bool iv_analyze_op (rtx_insn *, scalar_int_mode, rtx, struct rtx_iv *);\n \n /* Return the RTX code corresponding to the IV extend code EXTEND.  */\n static inline enum rtx_code\n@@ -383,11 +384,8 @@ iv_get_reaching_def (rtx_insn *insn, rtx reg, df_ref *def)\n    consistency with other iv manipulation functions that may fail).  */\n \n static bool\n-iv_constant (struct rtx_iv *iv, rtx cst, machine_mode mode)\n+iv_constant (struct rtx_iv *iv, scalar_int_mode mode, rtx cst)\n {\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (cst);\n-\n   iv->mode = mode;\n   iv->base = cst;\n   iv->step = const0_rtx;\n@@ -403,7 +401,7 @@ iv_constant (struct rtx_iv *iv, rtx cst, machine_mode mode)\n /* Evaluates application of subreg to MODE on IV.  */\n \n static bool\n-iv_subreg (struct rtx_iv *iv, machine_mode mode)\n+iv_subreg (struct rtx_iv *iv, scalar_int_mode mode)\n {\n   /* If iv is invariant, just calculate the new value.  */\n   if (iv->step == const0_rtx\n@@ -445,7 +443,7 @@ iv_subreg (struct rtx_iv *iv, machine_mode mode)\n /* Evaluates application of EXTEND to MODE on IV.  */\n \n static bool\n-iv_extend (struct rtx_iv *iv, enum iv_extend_code extend, machine_mode mode)\n+iv_extend (struct rtx_iv *iv, enum iv_extend_code extend, scalar_int_mode mode)\n {\n   /* If iv is invariant, just calculate the new value.  */\n   if (iv->step == const0_rtx\n@@ -508,7 +506,7 @@ iv_neg (struct rtx_iv *iv)\n static bool\n iv_add (struct rtx_iv *iv0, struct rtx_iv *iv1, enum rtx_code op)\n {\n-  machine_mode mode;\n+  scalar_int_mode mode;\n   rtx arg;\n \n   /* Extend the constant to extend_mode of the other operand if necessary.  */\n@@ -578,7 +576,7 @@ iv_add (struct rtx_iv *iv0, struct rtx_iv *iv1, enum rtx_code op)\n static bool\n iv_mult (struct rtx_iv *iv, rtx mby)\n {\n-  machine_mode mode = iv->extend_mode;\n+  scalar_int_mode mode = iv->extend_mode;\n \n   if (GET_MODE (mby) != VOIDmode\n       && GET_MODE (mby) != mode)\n@@ -603,7 +601,7 @@ iv_mult (struct rtx_iv *iv, rtx mby)\n static bool\n iv_shift (struct rtx_iv *iv, rtx mby)\n {\n-  machine_mode mode = iv->extend_mode;\n+  scalar_int_mode mode = iv->extend_mode;\n \n   if (GET_MODE (mby) != VOIDmode\n       && GET_MODE (mby) != mode)\n@@ -628,9 +626,9 @@ iv_shift (struct rtx_iv *iv, rtx mby)\n    at get_biv_step.  */\n \n static bool\n-get_biv_step_1 (df_ref def, rtx reg,\n-\t\trtx *inner_step, machine_mode *inner_mode,\n-\t\tenum iv_extend_code *extend, machine_mode outer_mode,\n+get_biv_step_1 (df_ref def, scalar_int_mode outer_mode, rtx reg,\n+\t\trtx *inner_step, scalar_int_mode *inner_mode,\n+\t\tenum iv_extend_code *extend,\n \t\trtx *outer_step)\n {\n   rtx set, rhs, op0 = NULL_RTX, op1 = NULL_RTX;\n@@ -732,8 +730,8 @@ get_biv_step_1 (df_ref def, rtx reg,\n       *inner_mode = outer_mode;\n       *outer_step = const0_rtx;\n     }\n-  else if (!get_biv_step_1 (next_def, reg,\n-\t\t\t    inner_step, inner_mode, extend, outer_mode,\n+  else if (!get_biv_step_1 (next_def, outer_mode, reg,\n+\t\t\t    inner_step, inner_mode, extend,\n \t\t\t    outer_step))\n     return false;\n \n@@ -793,19 +791,17 @@ get_biv_step_1 (df_ref def, rtx reg,\n    LAST_DEF is the definition of REG that dominates loop latch.  */\n \n static bool\n-get_biv_step (df_ref last_def, rtx reg, rtx *inner_step,\n-\t      machine_mode *inner_mode, enum iv_extend_code *extend,\n-\t      machine_mode *outer_mode, rtx *outer_step)\n+get_biv_step (df_ref last_def, scalar_int_mode outer_mode, rtx reg,\n+\t      rtx *inner_step, scalar_int_mode *inner_mode,\n+\t      enum iv_extend_code *extend, rtx *outer_step)\n {\n-  *outer_mode = GET_MODE (reg);\n-\n-  if (!get_biv_step_1 (last_def, reg,\n-\t\t       inner_step, inner_mode, extend, *outer_mode,\n+  if (!get_biv_step_1 (last_def, outer_mode, reg,\n+\t\t       inner_step, inner_mode, extend,\n \t\t       outer_step))\n     return false;\n \n-  gcc_assert ((*inner_mode == *outer_mode) != (*extend != IV_UNKNOWN_EXTEND));\n-  gcc_assert (*inner_mode != *outer_mode || *outer_step == const0_rtx);\n+  gcc_assert ((*inner_mode == outer_mode) != (*extend != IV_UNKNOWN_EXTEND));\n+  gcc_assert (*inner_mode != outer_mode || *outer_step == const0_rtx);\n \n   return true;\n }\n@@ -850,13 +846,13 @@ record_biv (rtx def, struct rtx_iv *iv)\n }\n \n /* Determines whether DEF is a biv and if so, stores its description\n-   to *IV.  */\n+   to *IV.  OUTER_MODE is the mode of DEF.  */\n \n static bool\n-iv_analyze_biv (rtx def, struct rtx_iv *iv)\n+iv_analyze_biv (scalar_int_mode outer_mode, rtx def, struct rtx_iv *iv)\n {\n   rtx inner_step, outer_step;\n-  machine_mode inner_mode, outer_mode;\n+  scalar_int_mode inner_mode;\n   enum iv_extend_code extend;\n   df_ref last_def;\n \n@@ -872,7 +868,7 @@ iv_analyze_biv (rtx def, struct rtx_iv *iv)\n       if (!CONSTANT_P (def))\n \treturn false;\n \n-      return iv_constant (iv, def, VOIDmode);\n+      return iv_constant (iv, outer_mode, def);\n     }\n \n   if (!latch_dominating_def (def, &last_def))\n@@ -883,7 +879,7 @@ iv_analyze_biv (rtx def, struct rtx_iv *iv)\n     }\n \n   if (!last_def)\n-    return iv_constant (iv, def, VOIDmode);\n+    return iv_constant (iv, outer_mode, def);\n \n   if (analyzed_for_bivness_p (def, iv))\n     {\n@@ -892,8 +888,8 @@ iv_analyze_biv (rtx def, struct rtx_iv *iv)\n       return iv->base != NULL_RTX;\n     }\n \n-  if (!get_biv_step (last_def, def, &inner_step, &inner_mode, &extend,\n-\t\t     &outer_mode, &outer_step))\n+  if (!get_biv_step (last_def, outer_mode, def, &inner_step, &inner_mode,\n+\t\t     &extend, &outer_step))\n     {\n       iv->base = NULL_RTX;\n       goto end;\n@@ -930,16 +926,15 @@ iv_analyze_biv (rtx def, struct rtx_iv *iv)\n    The mode of the induction variable is MODE.  */\n \n bool\n-iv_analyze_expr (rtx_insn *insn, rtx rhs, machine_mode mode,\n+iv_analyze_expr (rtx_insn *insn, scalar_int_mode mode, rtx rhs,\n \t\t struct rtx_iv *iv)\n {\n   rtx mby = NULL_RTX;\n   rtx op0 = NULL_RTX, op1 = NULL_RTX;\n   struct rtx_iv iv0, iv1;\n   enum rtx_code code = GET_CODE (rhs);\n-  machine_mode omode = mode;\n+  scalar_int_mode omode = mode;\n \n-  iv->mode = VOIDmode;\n   iv->base = NULL_RTX;\n   iv->step = NULL_RTX;\n \n@@ -948,18 +943,7 @@ iv_analyze_expr (rtx_insn *insn, rtx rhs, machine_mode mode,\n   if (CONSTANT_P (rhs)\n       || REG_P (rhs)\n       || code == SUBREG)\n-    {\n-      if (!iv_analyze_op (insn, rhs, iv))\n-\treturn false;\n-\n-      if (iv->mode == VOIDmode)\n-\t{\n-\t  iv->mode = mode;\n-\t  iv->extend_mode = mode;\n-\t}\n-\n-      return true;\n-    }\n+    return iv_analyze_op (insn, mode, rhs, iv);\n \n   switch (code)\n     {\n@@ -971,7 +955,9 @@ iv_analyze_expr (rtx_insn *insn, rtx rhs, machine_mode mode,\n     case ZERO_EXTEND:\n     case NEG:\n       op0 = XEXP (rhs, 0);\n-      omode = GET_MODE (op0);\n+      /* We don't know how many bits there are in a sign-extended constant.  */\n+      if (!is_a <scalar_int_mode> (GET_MODE (op0), &omode))\n+\treturn false;\n       break;\n \n     case PLUS:\n@@ -1001,11 +987,11 @@ iv_analyze_expr (rtx_insn *insn, rtx rhs, machine_mode mode,\n     }\n \n   if (op0\n-      && !iv_analyze_expr (insn, op0, omode, &iv0))\n+      && !iv_analyze_expr (insn, omode, op0, &iv0))\n     return false;\n \n   if (op1\n-      && !iv_analyze_expr (insn, op1, omode, &iv1))\n+      && !iv_analyze_expr (insn, omode, op1, &iv1))\n     return false;\n \n   switch (code)\n@@ -1075,11 +1061,11 @@ iv_analyze_def (df_ref def, struct rtx_iv *iv)\n       return iv->base != NULL_RTX;\n     }\n \n-  iv->mode = VOIDmode;\n   iv->base = NULL_RTX;\n   iv->step = NULL_RTX;\n \n-  if (!REG_P (reg))\n+  scalar_int_mode mode;\n+  if (!REG_P (reg) || !is_a <scalar_int_mode> (GET_MODE (reg), &mode))\n     return false;\n \n   set = single_set (insn);\n@@ -1096,7 +1082,7 @@ iv_analyze_def (df_ref def, struct rtx_iv *iv)\n   else\n     rhs = SET_SRC (set);\n \n-  iv_analyze_expr (insn, rhs, GET_MODE (reg), iv);\n+  iv_analyze_expr (insn, mode, rhs, iv);\n   record_iv (def, iv);\n \n   if (dump_file)\n@@ -1112,10 +1098,11 @@ iv_analyze_def (df_ref def, struct rtx_iv *iv)\n   return iv->base != NULL_RTX;\n }\n \n-/* Analyzes operand OP of INSN and stores the result to *IV.  */\n+/* Analyzes operand OP of INSN and stores the result to *IV.  MODE is the\n+   mode of OP.  */\n \n static bool\n-iv_analyze_op (rtx_insn *insn, rtx op, struct rtx_iv *iv)\n+iv_analyze_op (rtx_insn *insn, scalar_int_mode mode, rtx op, struct rtx_iv *iv)\n {\n   df_ref def = NULL;\n   enum iv_grd_result res;\n@@ -1132,13 +1119,15 @@ iv_analyze_op (rtx_insn *insn, rtx op, struct rtx_iv *iv)\n     res = GRD_INVARIANT;\n   else if (GET_CODE (op) == SUBREG)\n     {\n-      if (!subreg_lowpart_p (op))\n+      scalar_int_mode inner_mode;\n+      if (!subreg_lowpart_p (op)\n+\t  || !is_a <scalar_int_mode> (GET_MODE (SUBREG_REG (op)), &inner_mode))\n \treturn false;\n \n-      if (!iv_analyze_op (insn, SUBREG_REG (op), iv))\n+      if (!iv_analyze_op (insn, inner_mode, SUBREG_REG (op), iv))\n \treturn false;\n \n-      return iv_subreg (iv, GET_MODE (op));\n+      return iv_subreg (iv, mode);\n     }\n   else\n     {\n@@ -1153,7 +1142,7 @@ iv_analyze_op (rtx_insn *insn, rtx op, struct rtx_iv *iv)\n \n   if (res == GRD_INVARIANT)\n     {\n-      iv_constant (iv, op, VOIDmode);\n+      iv_constant (iv, mode, op);\n \n       if (dump_file)\n \t{\n@@ -1165,15 +1154,16 @@ iv_analyze_op (rtx_insn *insn, rtx op, struct rtx_iv *iv)\n     }\n \n   if (res == GRD_MAYBE_BIV)\n-    return iv_analyze_biv (op, iv);\n+    return iv_analyze_biv (mode, op, iv);\n \n   return iv_analyze_def (def, iv);\n }\n \n-/* Analyzes value VAL at INSN and stores the result to *IV.  */\n+/* Analyzes value VAL at INSN and stores the result to *IV.  MODE is the\n+   mode of VAL.  */\n \n bool\n-iv_analyze (rtx_insn *insn, rtx val, struct rtx_iv *iv)\n+iv_analyze (rtx_insn *insn, scalar_int_mode mode, rtx val, struct rtx_iv *iv)\n {\n   rtx reg;\n \n@@ -1192,7 +1182,7 @@ iv_analyze (rtx_insn *insn, rtx val, struct rtx_iv *iv)\n \tinsn = NEXT_INSN (insn);\n     }\n \n-  return iv_analyze_op (insn, val, iv);\n+  return iv_analyze_op (insn, mode, val, iv);\n }\n \n /* Analyzes definition of DEF in INSN and stores the result to IV.  */\n@@ -1210,11 +1200,13 @@ iv_analyze_result (rtx_insn *insn, rtx def, struct rtx_iv *iv)\n }\n \n /* Checks whether definition of register REG in INSN is a basic induction\n-   variable.  IV analysis must have been initialized (via a call to\n+   variable.  MODE is the mode of REG.\n+\n+   IV analysis must have been initialized (via a call to\n    iv_analysis_loop_init) for this function to produce a result.  */\n \n bool\n-biv_p (rtx_insn *insn, rtx reg)\n+biv_p (rtx_insn *insn, scalar_int_mode mode, rtx reg)\n {\n   struct rtx_iv iv;\n   df_ref def, last_def;\n@@ -1229,7 +1221,7 @@ biv_p (rtx_insn *insn, rtx reg)\n   if (last_def != def)\n     return false;\n \n-  if (!iv_analyze_biv (reg, &iv))\n+  if (!iv_analyze_biv (mode, reg, &iv))\n     return false;\n \n   return iv.step != const0_rtx;\n@@ -2078,7 +2070,7 @@ simplify_using_initial_values (struct loop *loop, enum rtx_code op, rtx *expr)\n    is SIGNED_P to DESC.  */\n \n static void\n-shorten_into_mode (struct rtx_iv *iv, machine_mode mode,\n+shorten_into_mode (struct rtx_iv *iv, scalar_int_mode mode,\n \t\t   enum rtx_code cond, bool signed_p, struct niter_desc *desc)\n {\n   rtx mmin, mmax, cond_over, cond_under;\n@@ -2140,7 +2132,7 @@ static bool\n canonicalize_iv_subregs (struct rtx_iv *iv0, struct rtx_iv *iv1,\n \t\t\t enum rtx_code cond, struct niter_desc *desc)\n {\n-  machine_mode comp_mode;\n+  scalar_int_mode comp_mode;\n   bool signed_p;\n \n   /* If the ivs behave specially in the first iteration, or are\n@@ -2318,7 +2310,8 @@ iv_number_of_iterations (struct loop *loop, rtx_insn *insn, rtx condition,\n   struct rtx_iv iv0, iv1;\n   rtx assumption, may_not_xform;\n   enum rtx_code cond;\n-  machine_mode mode, comp_mode;\n+  machine_mode nonvoid_mode;\n+  scalar_int_mode comp_mode;\n   rtx mmin, mmax, mode_mmin, mode_mmax;\n   uint64_t s, size, d, inv, max, up, down;\n   int64_t inc, step_val;\n@@ -2343,28 +2336,24 @@ iv_number_of_iterations (struct loop *loop, rtx_insn *insn, rtx condition,\n   cond = GET_CODE (condition);\n   gcc_assert (COMPARISON_P (condition));\n \n-  mode = GET_MODE (XEXP (condition, 0));\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (XEXP (condition, 1));\n+  nonvoid_mode = GET_MODE (XEXP (condition, 0));\n+  if (nonvoid_mode == VOIDmode)\n+    nonvoid_mode = GET_MODE (XEXP (condition, 1));\n   /* The constant comparisons should be folded.  */\n-  gcc_assert (mode != VOIDmode);\n+  gcc_assert (nonvoid_mode != VOIDmode);\n \n   /* We only handle integers or pointers.  */\n-  if (GET_MODE_CLASS (mode) != MODE_INT\n-      && GET_MODE_CLASS (mode) != MODE_PARTIAL_INT)\n+  scalar_int_mode mode;\n+  if (!is_a <scalar_int_mode> (nonvoid_mode, &mode))\n     goto fail;\n \n   op0 = XEXP (condition, 0);\n-  if (!iv_analyze (insn, op0, &iv0))\n+  if (!iv_analyze (insn, mode, op0, &iv0))\n     goto fail;\n-  if (iv0.extend_mode == VOIDmode)\n-    iv0.mode = iv0.extend_mode = mode;\n \n   op1 = XEXP (condition, 1);\n-  if (!iv_analyze (insn, op1, &iv1))\n+  if (!iv_analyze (insn, mode, op1, &iv1))\n     goto fail;\n-  if (iv1.extend_mode == VOIDmode)\n-    iv1.mode = iv1.extend_mode = mode;\n \n   if (GET_MODE_BITSIZE (iv0.extend_mode) > HOST_BITS_PER_WIDE_INT\n       || GET_MODE_BITSIZE (iv1.extend_mode) > HOST_BITS_PER_WIDE_INT)"}, {"sha": "8cf305b24c59aa27a0db4c39cbeaa6e98795c8f9", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d88d1cdf217be025628d77588e2d247feeebcb3/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d88d1cdf217be025628d77588e2d247feeebcb3/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=3d88d1cdf217be025628d77588e2d247feeebcb3", "patch": "@@ -1509,6 +1509,7 @@ analyze_iv_to_split_insn (rtx_insn *insn)\n   rtx set, dest;\n   struct rtx_iv iv;\n   struct iv_to_split *ivts;\n+  scalar_int_mode mode;\n   bool ok;\n \n   /* For now we just split the basic induction variables.  Later this may be\n@@ -1518,10 +1519,10 @@ analyze_iv_to_split_insn (rtx_insn *insn)\n     return NULL;\n \n   dest = SET_DEST (set);\n-  if (!REG_P (dest))\n+  if (!REG_P (dest) || !is_a <scalar_int_mode> (GET_MODE (dest), &mode))\n     return NULL;\n \n-  if (!biv_p (insn, dest))\n+  if (!biv_p (insn, mode, dest))\n     return NULL;\n \n   ok = iv_analyze_result (insn, dest, &iv);"}]}