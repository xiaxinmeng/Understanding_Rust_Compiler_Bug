{"sha": "31104818b707112ad18f985f4d1ab3689bf6625e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzExMDQ4MThiNzA3MTEyYWQxOGY5ODVmNGQxYWIzNjg5YmY2NjI1ZQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2007-06-06T10:24:07Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:24:07Z"}, "message": "exp_attr.adb (Expand_N_Attribute_Reference): Case Callable and Terminated...\n\n2007-04-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\n\t* exp_attr.adb (Expand_N_Attribute_Reference): Case Callable and\n\tTerminated: Add unchecked type conversion from System.Address to\n\tSystem.Tasking.Task_Id when calling the predefined primitive\n\t_disp_get_task_id.\n\tDisable new Ada 05 accessibility check for JVM.NET targets, which\n\tcannot be implemented in a practical way.\n\t(Expand_N_Attribute_Reference: case Attribute_Tag): The use of 'Tag in\n\tthe sources always references the tag of the actual object. Therefore,\n\tif 'Tag is applied in the sources to class-wide interface objects we\n\tgenerate code that displaces \"this\" to reference the base of the object.\n\t(Expand_N_Attribute_Reference, case Size): Return specified size if\n\tknown to front end.\n\t(Expand_N_Attribute_Reference): The expansion of the 'Address attribute\n\thas code that displaces the pointer of the object to manage interface\n\ttypes. However this code must not be executed when the prefix is a\n\tsubprogram. This bug caused the wrong expansion of the internally\n\tgenerated assignment that fills the dispatch table when the primitive\n\tis a function returning a class-wide interface type.\n\t(Expand_N_Attribute_Reference:Attribute_Valid): Remove incorrect call to\n\tSet_Attribute_Name for Name_Unaligned_Valid.\n\nFrom-SVN: r125393", "tree": {"sha": "f74f8dfa25caf5f5c947cc68976eec95de808602", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f74f8dfa25caf5f5c947cc68976eec95de808602"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31104818b707112ad18f985f4d1ab3689bf6625e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31104818b707112ad18f985f4d1ab3689bf6625e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31104818b707112ad18f985f4d1ab3689bf6625e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31104818b707112ad18f985f4d1ab3689bf6625e/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0f95b178458d196841d4d4778cfd1c244088b55b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f95b178458d196841d4d4778cfd1c244088b55b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f95b178458d196841d4d4778cfd1c244088b55b"}], "stats": {"total": 160, "additions": 114, "deletions": 46}, "files": [{"sha": "d230666e1a3d01381a15af0fe2596901dec24165", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 114, "deletions": 46, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31104818b707112ad18f985f4d1ab3689bf6625e/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31104818b707112ad18f985f4d1ab3689bf6625e/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=31104818b707112ad18f985f4d1ab3689bf6625e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -38,7 +38,6 @@ with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Exp_VFpt; use Exp_VFpt;\n with Gnatvsn;  use Gnatvsn;\n-with Hostparm; use Hostparm;\n with Lib;      use Lib;\n with Namet;    use Namet;\n with Nmake;    use Nmake;\n@@ -57,6 +56,7 @@ with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n+with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Ttypes;   use Ttypes;\n with Uintp;    use Uintp;\n@@ -186,7 +186,7 @@ package body Exp_Attr is\n         and then not In_Open_Scopes (Scop)\n         and then Ekind (Scop) = E_Package\n       then\n-         New_Scope (Scop);\n+         Push_Scope (Scop);\n          Install_Visible_Declarations (Scop);\n          Install_Private_Declarations (Scop);\n          Installed := True;\n@@ -196,7 +196,7 @@ package body Exp_Attr is\n          --  enclosing stream function) so that itypes all have their proper\n          --  scopes.\n \n-         New_Scope (Curr);\n+         Push_Scope (Curr);\n       end if;\n \n       if Check then\n@@ -810,7 +810,9 @@ package body Exp_Attr is\n          --  address of the object.\n \n          elsif Is_Class_Wide_Type (Etype (Pref))\n-            and then Is_Interface (Etype (Pref))\n+           and then Is_Interface (Etype (Pref))\n+           and then not (Nkind (Pref) in N_Has_Entity\n+                          and then Is_Subprogram (Entity (Pref)))\n          then\n             Rewrite (N,\n               Make_Function_Call (Loc,\n@@ -1119,23 +1121,28 @@ package body Exp_Attr is\n          --  We have an object of a task interface class-wide type as a prefix\n          --  to Callable. Generate:\n \n-         --    callable (Pref._disp_get_task_id);\n+         --    callable (Task_Id (Pref._disp_get_task_id));\n \n          if Ada_Version >= Ada_05\n            and then Ekind (Etype (Pref)) = E_Class_Wide_Type\n-           and then Is_Interface      (Etype (Pref))\n+           and then Is_Interface (Etype (Pref))\n            and then Is_Task_Interface (Etype (Pref))\n          then\n             Rewrite (N,\n               Make_Function_Call (Loc,\n                 Name =>\n                   New_Reference_To (RTE (RE_Callable), Loc),\n                 Parameter_Associations => New_List (\n-                  Make_Selected_Component (Loc,\n-                    Prefix =>\n-                      New_Copy_Tree (Pref),\n-                    Selector_Name =>\n-                      Make_Identifier (Loc, Name_uDisp_Get_Task_Id)))));\n+                  Make_Unchecked_Type_Conversion (Loc,\n+                    Subtype_Mark =>\n+                      New_Reference_To (RTE (RO_ST_Task_Id), Loc),\n+                    Expression =>\n+                      Make_Selected_Component (Loc,\n+                        Prefix =>\n+                          New_Copy_Tree (Pref),\n+                        Selector_Name =>\n+                          Make_Identifier (Loc, Name_uDisp_Get_Task_Id))))));\n+\n          else\n             Rewrite (N,\n               Build_Call_With_Task (Pref, RTE (RE_Callable)));\n@@ -1534,12 +1541,15 @@ package body Exp_Attr is\n                if Nkind (Nod) = N_Selected_Component then\n                   Make_Elab_String (Prefix (Nod));\n \n-                  if Java_VM then\n-                     Store_String_Char ('$');\n-                  else\n-                     Store_String_Char ('_');\n-                     Store_String_Char ('_');\n-                  end if;\n+                  case VM_Target is\n+                     when JVM_Target =>\n+                        Store_String_Char ('$');\n+                     when CLI_Target =>\n+                        Store_String_Char ('.');\n+                     when No_VM =>\n+                        Store_String_Char ('_');\n+                        Store_String_Char ('_');\n+                  end case;\n \n                   Get_Name_String (Chars (Selector_Name (Nod)));\n \n@@ -1560,12 +1570,12 @@ package body Exp_Attr is\n             Start_String;\n             Make_Elab_String (Pref);\n \n-            if Java_VM then\n-               Store_String_Chars (\"._elab\");\n-               Lang := Make_Identifier (Loc, Name_Ada);\n-            else\n+            if VM_Target = No_VM then\n                Store_String_Chars (\"___elab\");\n                Lang := Make_Identifier (Loc, Name_C);\n+            else\n+               Store_String_Chars (\"._elab\");\n+               Lang := Make_Identifier (Loc, Name_Ada);\n             end if;\n \n             if Id = Attribute_Elab_Body then\n@@ -2717,7 +2727,7 @@ package body Exp_Attr is\n                      Make_Function_Call (Loc,\n                        Name => New_Occurrence_Of (Wfunc, Loc),\n                        Parameter_Associations => New_List (\n-                         Convert_To (Etype (First_Formal (Wfunc)),\n+                         OK_Convert_To (Etype (First_Formal (Wfunc)),\n                            Relocate_Node (Next (First (Exprs)))))))));\n \n                Analyze (N);\n@@ -2770,19 +2780,24 @@ package body Exp_Attr is\n                   Item : constant Node_Id := Next (Strm);\n \n                begin\n-                  --  The code is:\n+                  --  Ada 2005 (AI-344): Check that the accessibility level\n+                  --  of the type of the output object is not deeper than\n+                  --  that of the attribute's prefix type.\n+\n                   --  if Get_Access_Level (Item'Tag)\n                   --       /= Get_Access_Level (P_Type'Tag)\n                   --  then\n                   --     raise Tag_Error;\n                   --  end if;\n+\n                   --  String'Output (Strm, External_Tag (Item'Tag));\n \n-                  --  Ada 2005 (AI-344): Check that the accessibility level\n-                  --  of the type of the output object is not deeper than\n-                  --  that of the attribute's prefix type.\n+                  --  We cannot figure out a practical way to implement this\n+                  --  accessibility check on virtual machines, so we omit it.\n \n-                  if Ada_Version >= Ada_05 then\n+                  if Ada_Version >= Ada_05\n+                    and then VM_Target = No_VM\n+                  then\n                      Insert_Action (N,\n                        Make_Implicit_If_Statement (N,\n                          Condition =>\n@@ -3232,7 +3247,7 @@ package body Exp_Attr is\n                Rfunc := Entity (Expression (Arg2));\n                Lhs := Relocate_Node (Next (First (Exprs)));\n                Rhs :=\n-                 Convert_To (B_Type,\n+                 OK_Convert_To (B_Type,\n                    Make_Function_Call (Loc,\n                      Name => New_Occurrence_Of (Rfunc, Loc),\n                      Parameter_Associations => New_List (\n@@ -3532,7 +3547,35 @@ package body Exp_Attr is\n \n             Rewrite (N, New_Node);\n             Analyze_And_Resolve (N, Typ);\n-            return;\n+               return;\n+\n+         --  Case of known RM_Size of a type\n+\n+         elsif (Id = Attribute_Size or else Id = Attribute_Value_Size)\n+           and then Is_Entity_Name (Pref)\n+           and then Is_Type (Entity (Pref))\n+           and then Known_Static_RM_Size (Entity (Pref))\n+         then\n+            Siz := RM_Size (Entity (Pref));\n+\n+         --  Case of known Esize of a type\n+\n+         elsif Id = Attribute_Object_Size\n+           and then Is_Entity_Name (Pref)\n+           and then Is_Type (Entity (Pref))\n+           and then Known_Static_Esize (Entity (Pref))\n+         then\n+            Siz := Esize (Entity (Pref));\n+\n+         --  Case of known size of object\n+\n+         elsif Id = Attribute_Size\n+           and then Is_Entity_Name (Pref)\n+           and then Is_Object (Entity (Pref))\n+           and then Known_Esize (Entity (Pref))\n+           and then Known_Static_Esize (Entity (Pref))\n+         then\n+            Siz := Esize (Entity (Pref));\n \n          --  For an array component, we can do Size in the front end\n          --  if the component_size of the array is set.\n@@ -3583,10 +3626,9 @@ package body Exp_Attr is\n                Analyze_And_Resolve (N, Typ);\n             end if;\n \n-            --  If Size is applied to a dereference of an access to\n-            --  unconstrained packed array, GIGI needs to see its\n-            --  unconstrained nominal type, but also a hint to the actual\n-            --  constrained type.\n+            --  If Size applies to a dereference of an access to unconstrained\n+            --  packed array, GIGI needs to see its unconstrained nominal type,\n+            --  but also a hint to the actual constrained type.\n \n             if Nkind (Pref) = N_Explicit_Dereference\n               and then Is_Array_Type (Etype (Pref))\n@@ -3602,7 +3644,7 @@ package body Exp_Attr is\n \n          --  Common processing for record and array component case\n \n-         if Siz /= 0 then\n+         if Siz /= No_Uint and then Siz /= 0 then\n             Rewrite (N, Make_Integer_Literal (Loc, Siz));\n \n             Analyze_And_Resolve (N, Typ);\n@@ -3896,17 +3938,40 @@ package body Exp_Attr is\n \n          if Prefix_Is_Type then\n \n-            --  For JGNAT we leave the type attribute unexpanded because\n+            --  For VMs we leave the type attribute unexpanded because\n             --  there's not a dispatching table to reference.\n \n-            if not Java_VM then\n+            if VM_Target = No_VM then\n                Rewrite (N,\n                  Unchecked_Convert_To (RTE (RE_Tag),\n                    New_Reference_To\n                      (Node (First_Elmt (Access_Disp_Table (Ttyp))), Loc)));\n                Analyze_And_Resolve (N, RTE (RE_Tag));\n             end if;\n \n+         --  (Ada 2005 (AI-251): The use of 'Tag in the sources always\n+         --  references the primary tag of the actual object. If 'Tag is\n+         --  applied to class-wide interface objects we generate code that\n+         --  displaces \"this\" to reference the base of the object.\n+\n+         elsif Comes_From_Source (N)\n+            and then Is_Class_Wide_Type (Etype (Prefix (N)))\n+            and then Is_Interface (Etype (Prefix (N)))\n+         then\n+            --  Generate:\n+            --    (To_Tag_Ptr (Prefix'Address)).all\n+\n+            --  Note that Prefix'Address is recursively expanded into a call\n+            --  to Base_Address (Obj.Tag)\n+\n+            Rewrite (N,\n+              Make_Explicit_Dereference (Loc,\n+                Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n+                  Make_Attribute_Reference (Loc,\n+                    Prefix => Relocate_Node (Pref),\n+                    Attribute_Name => Name_Address))));\n+            Analyze_And_Resolve (N, RTE (RE_Tag));\n+\n          else\n             Rewrite (N,\n               Make_Selected_Component (Loc,\n@@ -3928,23 +3993,27 @@ package body Exp_Attr is\n          --  The prefix of Terminated is of a task interface class-wide type.\n          --  Generate:\n \n-         --    terminated (Pref._disp_get_task_id);\n+         --    terminated (Task_Id (Pref._disp_get_task_id));\n \n          if Ada_Version >= Ada_05\n            and then Ekind (Etype (Pref)) = E_Class_Wide_Type\n-           and then Is_Interface      (Etype (Pref))\n+           and then Is_Interface (Etype (Pref))\n            and then Is_Task_Interface (Etype (Pref))\n          then\n             Rewrite (N,\n               Make_Function_Call (Loc,\n                 Name =>\n                   New_Reference_To (RTE (RE_Terminated), Loc),\n                 Parameter_Associations => New_List (\n-                  Make_Selected_Component (Loc,\n-                    Prefix =>\n-                      New_Copy_Tree (Pref),\n-                    Selector_Name =>\n-                      Make_Identifier (Loc, Name_uDisp_Get_Task_Id)))));\n+                  Make_Unchecked_Type_Conversion (Loc,\n+                    Subtype_Mark =>\n+                      New_Reference_To (RTE (RO_ST_Task_Id), Loc),\n+                    Expression =>\n+                      Make_Selected_Component (Loc,\n+                        Prefix =>\n+                          New_Copy_Tree (Pref),\n+                        Selector_Name =>\n+                          Make_Identifier (Loc, Name_uDisp_Get_Task_Id))))));\n \n          elsif Restricted_Profile then\n             Rewrite (N,\n@@ -4257,7 +4326,6 @@ package body Exp_Attr is\n                   --  obj'Address (see Unaligned_Valid routine in Fat_Gen).\n \n                   if Is_Possibly_Unaligned_Object (Pref) then\n-                     Set_Attribute_Name (N, Name_Unaligned_Valid);\n                      Expand_Fpt_Attribute\n                        (N, Pkg, Name_Unaligned_Valid,\n                         New_List (\n@@ -4702,7 +4770,7 @@ package body Exp_Attr is\n                      Make_Function_Call (Loc,\n                        Name => New_Occurrence_Of (Wfunc, Loc),\n                        Parameter_Associations => New_List (\n-                         Convert_To (Etype (First_Formal (Wfunc)),\n+                         OK_Convert_To (Etype (First_Formal (Wfunc)),\n                            Relocate_Node (Next (First (Exprs)))))))));\n \n                Analyze (N);"}]}