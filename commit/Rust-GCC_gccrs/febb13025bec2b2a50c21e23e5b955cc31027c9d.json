{"sha": "febb13025bec2b2a50c21e23e5b955cc31027c9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmViYjEzMDI1YmVjMmIyYTUwYzIxZTIzZTViOTU1Y2MzMTAyN2M5ZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-06-23T16:45:08Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-06-23T16:45:08Z"}, "message": "re PR middle-end/49373 (Many testcase failures)\n\n\tPR tree-optimize/49373\n\t* tree-pass.h (all_late_ipa_passes): Declare.\n\t* cgraphunit.c (init_lowered_empty_function): Fix properties.\n\t(cgraph_optimize): Execute late passes; remove unreachable funcions after\n\tmaterialization.\n\t* ipa-inline.c (gate_ipa_inline): Enable only when optimizing or LTOing.\n\t* passes.c (all_late_ipa_passes): Declare.\n\t(dump_passes, register_pass): Handle late ipa passes.\n\t(init_optimization_passes): Move ipa_pta to late passes; schedule fixup_cfg\n\tat beggining of all_passes.\n\t(apply_ipa_transforms): New function.\n\t(execute_one_pass): When doing simple ipa pass, apply all transforms.\n\nFrom-SVN: r175336", "tree": {"sha": "bc119ccc3a2b2d6675fc6bbabd3fb8cff5b454d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc119ccc3a2b2d6675fc6bbabd3fb8cff5b454d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/febb13025bec2b2a50c21e23e5b955cc31027c9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/febb13025bec2b2a50c21e23e5b955cc31027c9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/febb13025bec2b2a50c21e23e5b955cc31027c9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/febb13025bec2b2a50c21e23e5b955cc31027c9d/comments", "author": null, "committer": null, "parents": [{"sha": "4c77620d6dedebfb9f5092de3da0c9870587a734", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c77620d6dedebfb9f5092de3da0c9870587a734", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c77620d6dedebfb9f5092de3da0c9870587a734"}], "stats": {"total": 78, "additions": 67, "deletions": 11}, "files": [{"sha": "1d1dbd1d9581a3cc62423aea26232de15f7739cf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/febb13025bec2b2a50c21e23e5b955cc31027c9d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/febb13025bec2b2a50c21e23e5b955cc31027c9d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=febb13025bec2b2a50c21e23e5b955cc31027c9d", "patch": "@@ -1,3 +1,18 @@\n+2011-06-23  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR tree-optimize/49373\n+\t* tree-pass.h (all_late_ipa_passes): Declare.\n+\t* cgraphunit.c (init_lowered_empty_function): Fix properties.\n+\t(cgraph_optimize): Execute late passes; remove unreachable funcions after\n+\tmaterialization.\n+\t* ipa-inline.c (gate_ipa_inline): Enable only when optimizing or LTOing.\n+\t* passes.c (all_late_ipa_passes): Declare.\n+\t(dump_passes, register_pass): Handle late ipa passes.\n+\t(init_optimization_passes): Move ipa_pta to late passes; schedule fixup_cfg\n+\tat beggining of all_passes.\n+\t(apply_ipa_transforms): New function.\n+\t(execute_one_pass): When doing simple ipa pass, apply all transforms.\n+\n 2011-06-23  Joseph Myers  <joseph@codesourcery.com>\n \n \t* params.c: Include common/common-target.h.  Don't include tm.h."}, {"sha": "e470d85acc61eec02f3846c4cfbb9f736b4b57df", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/febb13025bec2b2a50c21e23e5b955cc31027c9d/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/febb13025bec2b2a50c21e23e5b955cc31027c9d/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=febb13025bec2b2a50c21e23e5b955cc31027c9d", "patch": "@@ -1420,7 +1420,7 @@ init_lowered_empty_function (tree decl)\n   DECL_SAVED_TREE (decl) = error_mark_node;\n   cfun->curr_properties |=\n     (PROP_gimple_lcf | PROP_gimple_leh | PROP_cfg | PROP_referenced_vars |\n-     PROP_ssa);\n+     PROP_ssa | PROP_gimple_any);\n \n   /* Create BB for body of the function and connect it properly.  */\n   bb = create_basic_block (NULL, (void *) 0, ENTRY_BLOCK_PTR);\n@@ -2102,6 +2102,13 @@ cgraph_optimize (void)\n #endif\n \n   cgraph_materialize_all_clones ();\n+  bitmap_obstack_initialize (NULL);\n+  execute_ipa_pass_list (all_late_ipa_passes);\n+  cgraph_remove_unreachable_nodes (true, dump_file);\n+#ifdef ENABLE_CHECKING\n+  verify_cgraph ();\n+#endif\n+  bitmap_obstack_release (NULL);\n   cgraph_mark_functions_to_output ();\n \n   cgraph_state = CGRAPH_STATE_EXPANSION;"}, {"sha": "2f57e2d9f14f32c79275e39faa3524bd72202753", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/febb13025bec2b2a50c21e23e5b955cc31027c9d/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/febb13025bec2b2a50c21e23e5b955cc31027c9d/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=febb13025bec2b2a50c21e23e5b955cc31027c9d", "patch": "@@ -1972,17 +1972,15 @@ struct gimple_opt_pass pass_early_inline =\n \n \n /* When to run IPA inlining.  Inlining of always-inline functions\n-   happens during early inlining.  */\n+   happens during early inlining.\n+\n+   Enable inlining unconditoinally at -flto.  We need size estimates to\n+   drive partitioning.  */\n \n static bool\n gate_ipa_inline (void)\n {\n-  /* ???  We'd like to skip this if not optimizing or not inlining as\n-     all always-inline functions have been processed by early\n-     inlining already.  But this at least breaks EH with C++ as\n-     we need to unconditionally run fixup_cfg even at -O0.\n-     So leave it on unconditionally for now.  */\n-  return 1;\n+  return optimize || flag_lto || flag_wpa;\n }\n \n struct ipa_opt_pass_d pass_ipa_inline ="}, {"sha": "a03aa3f48c0120e7890a822186a070703f84c30b", "filename": "gcc/passes.c", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/febb13025bec2b2a50c21e23e5b955cc31027c9d/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/febb13025bec2b2a50c21e23e5b955cc31027c9d/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=febb13025bec2b2a50c21e23e5b955cc31027c9d", "patch": "@@ -332,7 +332,7 @@ struct rtl_opt_pass pass_postreload =\n \n /* The root of the compilation pass tree, once constructed.  */\n struct opt_pass *all_passes, *all_small_ipa_passes, *all_lowering_passes,\n-  *all_regular_ipa_passes, *all_lto_gen_passes;\n+  *all_regular_ipa_passes, *all_late_ipa_passes, *all_lto_gen_passes;\n \n /* This is used by plugins, and should also be used in register_pass.  */\n #define DEF_PASS_LIST(LIST) &LIST,\n@@ -617,6 +617,7 @@ dump_passes (void)\n   dump_pass_list (all_small_ipa_passes, 1);\n   dump_pass_list (all_regular_ipa_passes, 1);\n   dump_pass_list (all_lto_gen_passes, 1);\n+  dump_pass_list (all_late_ipa_passes, 1);\n   dump_pass_list (all_passes, 1);\n \n   pop_cfun ();\n@@ -1102,6 +1103,8 @@ register_pass (struct register_pass_info *pass_info)\n     success |= position_pass (pass_info, &all_regular_ipa_passes);\n   if (!success || all_instances)\n     success |= position_pass (pass_info, &all_lto_gen_passes);\n+  if (!success || all_instances)\n+    success |= position_pass (pass_info, &all_late_ipa_passes);\n   if (!success || all_instances)\n     success |= position_pass (pass_info, &all_passes);\n   if (!success)\n@@ -1249,17 +1252,23 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_ipa_inline);\n   NEXT_PASS (pass_ipa_pure_const);\n   NEXT_PASS (pass_ipa_reference);\n-  NEXT_PASS (pass_ipa_pta);\n   *p = NULL;\n \n   p = &all_lto_gen_passes;\n   NEXT_PASS (pass_ipa_lto_gimple_out);\n   NEXT_PASS (pass_ipa_lto_finish_out);  /* This must be the last LTO pass.  */\n   *p = NULL;\n \n+  /* Simple IPA passes executed after the regular passes.  In WHOPR mode the\n+     passes are executed after partitioning and thus see just parts of the\n+     compiled unit.  */\n+  p = &all_late_ipa_passes;\n+  NEXT_PASS (pass_ipa_pta);\n+  *p = NULL;\n   /* These passes are run after IPA passes on every function that is being\n      output to the assembler file.  */\n   p = &all_passes;\n+  NEXT_PASS (pass_fixup_cfg);\n   NEXT_PASS (pass_lower_eh_dispatch);\n   NEXT_PASS (pass_all_optimizations);\n     {\n@@ -1517,6 +1526,9 @@ init_optimization_passes (void)\n   register_dump_files (all_lto_gen_passes,\n \t\t       PROP_gimple_any | PROP_gimple_lcf | PROP_gimple_leh\n \t\t       | PROP_cfg);\n+  register_dump_files (all_late_ipa_passes,\n+\t\t       PROP_gimple_any | PROP_gimple_lcf | PROP_gimple_leh\n+\t\t       | PROP_cfg);\n   register_dump_files (all_passes,\n \t\t       PROP_gimple_any | PROP_gimple_lcf | PROP_gimple_leh\n \t\t       | PROP_cfg);\n@@ -1935,6 +1947,20 @@ execute_all_ipa_transforms (void)\n     }\n }\n \n+/* Callback for do_per_function to apply all IPA transforms.  */\n+\n+static void\n+apply_ipa_transforms (void *data)\n+{\n+  struct cgraph_node *node = cgraph_get_node (current_function_decl);\n+  if (!node->global.inlined_to && node->ipa_transforms_to_apply)\n+    {\n+      *(bool *)data = true;\n+      execute_all_ipa_transforms();\n+      rebuild_cgraph_edges ();\n+    }\n+}\n+\n /* Check if PASS is explicitly disabled or enabled and return\n    the gate status.  FUNC is the function to be processed, and\n    GATE_STATUS is the gate status determined by pass manager by\n@@ -1996,6 +2022,16 @@ execute_one_pass (struct opt_pass *pass)\n      executed.  */\n   invoke_plugin_callbacks (PLUGIN_PASS_EXECUTION, pass);\n \n+  /* SIPLE IPA passes do not handle callgraphs with IPA transforms in it.\n+     Apply all trnasforms first.  */\n+  if (pass->type == SIMPLE_IPA_PASS)\n+    {\n+      bool applied = false;\n+      do_per_function (apply_ipa_transforms, (void *)&applied);\n+      if (applied)\n+        cgraph_remove_unreachable_nodes (true, dump_file);\n+    }\n+\n   if (!quiet_flag && !cfun)\n     fprintf (stderr, \" <%s>\", pass->name ? pass->name : \"\");\n "}, {"sha": "a17ef3581423620fc552207f1845ee8debf72236", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/febb13025bec2b2a50c21e23e5b955cc31027c9d/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/febb13025bec2b2a50c21e23e5b955cc31027c9d/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=febb13025bec2b2a50c21e23e5b955cc31027c9d", "patch": "@@ -577,7 +577,7 @@ extern struct gimple_opt_pass pass_convert_switch;\n \n /* The root of the compilation pass tree, once constructed.  */\n extern struct opt_pass *all_passes, *all_small_ipa_passes, *all_lowering_passes,\n-                       *all_regular_ipa_passes, *all_lto_gen_passes;\n+                       *all_regular_ipa_passes, *all_lto_gen_passes, *all_late_ipa_passes;\n \n /* Define a list of pass lists so that both passes.c and plugins can easily\n    find all the pass lists.  */"}]}