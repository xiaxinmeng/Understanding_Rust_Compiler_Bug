{"sha": "c45da1ca925d67685ca633b48a4ca1ec44dfaca1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQ1ZGExY2E5MjVkNjc2ODVjYTYzM2I0OGE0Y2ExZWM0NGRmYWNhMQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-03-02T20:14:32Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-03-02T20:14:32Z"}, "message": "cppfiles.c (cpp_read_file): New function.\n\n\t* cppfiles.c (cpp_read_file): New function.\n\n\t* cpphash.c (collect_expansion): Make sure to reset last_token\n\tto NORM when we hit a string.  Handle trailing whitespace\n\tproperly when the expansion is empty.\n\t(create_definition): Disable line commands while parsing the\n\tdirective line.\n\t(dump_definition): If pfile->lineno == 0, output a line\n\tcommand ahead of the dump, and add a trailing newline.\n\n\t* cppinit.c (append_include_chain): Add fifth argument, which\n\tindicates whether or not system headers are C++ aware.\n\t(initialize_standard_includes): New function,\n\tbroken out of read_and_prescan.  Pass 'cxx_aware' value from\n\tthe include_defaults_array on to append_include_chain.\n\t(dump_special_to_buffer): Const-ify char array.\n\t(builtin_array): Don't dump __BASE_FILE__.\n\t(cpp_start_read): Use cpp_read_file.  Reorder code for\n\tclarity.  Don't output line commands here for -D/-A/-U\n\tswitches.  Don't call deps_output for files included with\n\t-include or -imacros.\n\n\t* cpplib.c (do_define): Don't pay any attention to the second\n\targument.\n\t(cpp_expand_to_buffer): Disable line commands while scanning.\n\t(output_line_command): Work in the file buffer.\n\t* cpplib.h: Remove no_record_file flag from struct cpp_reader.\n\tFix formatting of comments.  Prototype cpp_read_file.\n\nFrom-SVN: r32293", "tree": {"sha": "83b50be95e2db0783f35dfe9f8625210e9368a40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83b50be95e2db0783f35dfe9f8625210e9368a40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c45da1ca925d67685ca633b48a4ca1ec44dfaca1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c45da1ca925d67685ca633b48a4ca1ec44dfaca1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c45da1ca925d67685ca633b48a4ca1ec44dfaca1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c45da1ca925d67685ca633b48a4ca1ec44dfaca1/comments", "author": null, "committer": null, "parents": [{"sha": "e97f22c9757e8c7bbf123b6ec1af68791f41d6fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e97f22c9757e8c7bbf123b6ec1af68791f41d6fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e97f22c9757e8c7bbf123b6ec1af68791f41d6fa"}], "stats": {"total": 576, "additions": 299, "deletions": 277}, "files": [{"sha": "00485c663591be892c199281a85f7eea68c1e29a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45da1ca925d67685ca633b48a4ca1ec44dfaca1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45da1ca925d67685ca633b48a4ca1ec44dfaca1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c45da1ca925d67685ca633b48a4ca1ec44dfaca1", "patch": "@@ -1,3 +1,34 @@\n+2000-03-02  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cppfiles.c (cpp_read_file): New function.\n+\n+\t* cpphash.c (collect_expansion): Make sure to reset last_token\n+\tto NORM when we hit a string.  Handle trailing whitespace\n+\tproperly when the expansion is empty.\n+\t(create_definition): Disable line commands while parsing the\n+\tdirective line.\n+\t(dump_definition): If pfile->lineno == 0, output a line\n+\tcommand ahead of the dump, and add a trailing newline.\n+\n+\t* cppinit.c (append_include_chain): Add fifth argument, which\n+\tindicates whether or not system headers are C++ aware.\n+\t(initialize_standard_includes): New function,\n+\tbroken out of read_and_prescan.  Pass 'cxx_aware' value from\n+\tthe include_defaults_array on to append_include_chain.\n+\t(dump_special_to_buffer): Const-ify char array.\n+\t(builtin_array): Don't dump __BASE_FILE__.\n+\t(cpp_start_read): Use cpp_read_file.  Reorder code for\n+\tclarity.  Don't output line commands here for -D/-A/-U\n+\tswitches.  Don't call deps_output for files included with\n+\t-include or -imacros.\n+\n+\t* cpplib.c (do_define): Don't pay any attention to the second\n+\targument.\n+\t(cpp_expand_to_buffer): Disable line commands while scanning.\n+\t(output_line_command): Work in the file buffer.\n+\t* cpplib.h: Remove no_record_file flag from struct cpp_reader.\n+\tFix formatting of comments.  Prototype cpp_read_file.\n+\n Thu Mar  2 13:29:46 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* c-common.c (c_common_nodes_and_builtins): Make sizetype_endlink"}, {"sha": "add627208e29de9575e267810c652c6d50ad44b6", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45da1ca925d67685ca633b48a4ca1ec44dfaca1/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45da1ca925d67685ca633b48a4ca1ec44dfaca1/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=c45da1ca925d67685ca633b48a4ca1ec44dfaca1", "patch": "@@ -609,6 +609,62 @@ remap_filename (pfile, name, loc)\n   return name;\n }\n \n+/* Push an input buffer and load it up with the contents of FNAME.\n+   If FNAME is \"\" or NULL, read standard input.  */\n+int\n+cpp_read_file (pfile, fname)\n+     cpp_reader *pfile;\n+     const char *fname;\n+{\n+  struct include_hash *ih_fake;\n+  int f;\n+\n+  if (fname == NULL || *fname == 0)\n+    {\n+      fname = \"\";\n+      f = 0;\n+    }\n+\n+  /* Open the file in nonblocking mode, so we don't get stuck if\n+     someone clever has asked cpp to process /dev/rmt0.  finclude()\n+     will check that we have a real file to work with.  Also take\n+     care not to acquire a controlling terminal by mistake (this can't\n+     happen on sane systems, but paranoia is a virtue).  */\n+  else if ((f = open (fname, O_RDONLY|O_NONBLOCK|O_NOCTTY, 0666)) < 0)\n+    {\n+      cpp_notice_from_errno (pfile, fname);\n+      return 0;\n+    }\n+\n+  /* Push the buffer.  */\n+  if (!cpp_push_buffer (pfile, NULL, 0))\n+    goto failed_push;\n+  \n+  /* Gin up an include_hash structure for this file and feed it\n+     to finclude.  */\n+\n+  ih_fake = (struct include_hash *) xmalloc (sizeof (struct include_hash));\n+  ih_fake->next = 0;\n+  ih_fake->next_this_file = 0;\n+  ih_fake->foundhere = ABSOLUTE_PATH;  /* well sort of ... */\n+  ih_fake->name = fname;\n+  ih_fake->control_macro = 0;\n+  ih_fake->buf = (char *)-1;\n+  ih_fake->limit = 0;\n+  if (!finclude (pfile, f, ih_fake))\n+    goto failed_finclude;\n+\n+  return 1;\n+\n+ failed_finclude:\n+  /* If finclude fails, it pops the buffer.  */\n+  free (ih_fake);\n+ failed_push:\n+  if (f)\n+    close (f);\n+  return 0;\n+}\n+\n /* Read the contents of FD into the buffer on the top of PFILE's stack.\n    IHASH points to the include hash entry for the file associated with\n    FD."}, {"sha": "ae5df16546891fb66cbc5f3de80f3aec6ee87001", "filename": "gcc/cpphash.c", "status": "modified", "additions": 35, "deletions": 16, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45da1ca925d67685ca633b48a4ca1ec44dfaca1/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45da1ca925d67685ca633b48a4ca1ec44dfaca1/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=c45da1ca925d67685ca633b48a4ca1ec44dfaca1", "patch": "@@ -424,6 +424,7 @@ collect_expansion (pfile, arglist)\n       continue;\n \n     maybe_trad_stringify:\n+      last_token = NORM;\n       {\n \tU_CHAR *base, *p, *limit;\n \tstruct reflist *tpat;\n@@ -487,21 +488,31 @@ collect_expansion (pfile, arglist)\n   else if (last_token == PASTE)\n     cpp_error (pfile, \"`##' at end of macro definition\");\n \n-  /* Trim trailing white space from definition.  */\n-  here = CPP_WRITTEN (pfile);\n-  while (here > last && is_hspace (pfile->token_buffer [here-1]))\n-    here--;\n-  CPP_SET_WRITTEN (pfile, here);\n+  if (last_token == START)\n+    {\n+      /* Empty macro definition.  */\n+      exp = xstrdup (\"\\r \\r \");\n+      len = 1;\n+    }\n+  else\n+    {\n+      /* Trim trailing white space from definition.  */\n+      here = CPP_WRITTEN (pfile);\n+      while (here > last && is_hspace (pfile->token_buffer [here-1]))\n+\there--;\n+      CPP_SET_WRITTEN (pfile, here);\n   \n-  CPP_NUL_TERMINATE (pfile);\n-  len = CPP_WRITTEN (pfile) - start + 1;\n-  exp = xmalloc (len + 4); /* space for no-concat markers at either end */\n-  exp[0] = '\\r';\n-  exp[1] = ' ';\n-  exp[len + 1] = '\\r';\n-  exp[len + 2] = ' ';\n-  exp[len + 3] = '\\0';\n-  memcpy (&exp[2], pfile->token_buffer + start, len - 1);\n+      CPP_NUL_TERMINATE (pfile);\n+      len = CPP_WRITTEN (pfile) - start + 1;\n+      exp = xmalloc (len + 4); /* space for no-concat markers at either end */\n+      exp[0] = '\\r';\n+      exp[1] = ' ';\n+      exp[len + 1] = '\\r';\n+      exp[len + 2] = ' ';\n+      exp[len + 3] = '\\0';\n+      memcpy (&exp[2], pfile->token_buffer + start, len - 1);\n+    }\n+\n   CPP_SET_WRITTEN (pfile, start);\n \n   defn = (DEFINITION *) xmalloc (sizeof (DEFINITION));\n@@ -700,6 +711,7 @@ create_definition (pfile, funlike)\n   pfile->no_macro_expand++;\n   pfile->parsing_define_directive++;\n   CPP_OPTIONS (pfile)->discard_comments++;\n+  CPP_OPTIONS (pfile)->no_line_commands++;\n   \n   if (funlike)\n     {\n@@ -719,12 +731,14 @@ create_definition (pfile, funlike)\n   pfile->no_macro_expand--;\n   pfile->parsing_define_directive--;\n   CPP_OPTIONS (pfile)->discard_comments--;\n+  CPP_OPTIONS (pfile)->no_line_commands--;\n   return defn;\n \n  err:\n   pfile->no_macro_expand--;\n   pfile->parsing_define_directive--;\n   CPP_OPTIONS (pfile)->discard_comments--;\n+  CPP_OPTIONS (pfile)->no_line_commands--;\n   return 0;\n }\n \n@@ -1560,6 +1574,9 @@ dump_definition (pfile, sym, len, defn)\n      long len;\n      DEFINITION *defn;\n {\n+  if (pfile->lineno == 0)\n+    output_line_command (pfile, same_file);\n+\n   CPP_RESERVE (pfile, len + sizeof \"#define \");\n   CPP_PUTS_Q (pfile, \"#define \", sizeof \"#define \" -1);\n   CPP_PUTS_Q (pfile, sym, len);\n@@ -1573,7 +1590,6 @@ dump_definition (pfile, sym, len, defn)\n \t So we need length-4 chars of space, plus one for the NUL.  */\n       CPP_RESERVE (pfile, defn->length - 4 + 1);\n       CPP_PUTS_Q (pfile, defn->expansion + 2, defn->length - 4);\n-      CPP_NUL_TERMINATE_Q (pfile);\n     }\n   else\n     {\n@@ -1644,6 +1660,9 @@ dump_definition (pfile, sym, len, defn)\n       i = defn->length - (x - defn->expansion) - 2;\n       if (*x == '\\r') x += 2, i -= 2;\n       if (i > 0) CPP_PUTS (pfile, x, i);\n-      CPP_NUL_TERMINATE (pfile);\n     }\n+\n+  if (pfile->lineno == 0)\n+    CPP_PUTC (pfile, '\\n');\n+  CPP_NUL_TERMINATE (pfile);\n }"}, {"sha": "4ec4ea58b26bfa01cb4bfdf4eb0c11192d9ebc00", "filename": "gcc/cppinit.c", "status": "modified", "additions": 155, "deletions": 232, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45da1ca925d67685ca633b48a4ca1ec44dfaca1/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45da1ca925d67685ca633b48a4ca1ec44dfaca1/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=c45da1ca925d67685ca633b48a4ca1ec44dfaca1", "patch": "@@ -111,7 +111,7 @@ static struct default_include\n   int cplusplus;\t\t/* Only look here if we're compiling C++.  */\n   int cxx_aware;\t\t/* Includes in this directory don't need to\n \t\t\t\t   be wrapped in extern \"C\" when compiling\n-\t\t\t\t   C++.  This is not used anymore.  */\n+\t\t\t\t   C++.  */\n }\n include_defaults_array[]\n #ifdef INCLUDE_DEFAULTS\n@@ -193,14 +193,15 @@ static void path_include\t\tPARAMS ((cpp_reader *,\n static void initialize_builtins\t\tPARAMS ((cpp_reader *));\n static void append_include_chain\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t struct cpp_pending *,\n-\t\t\t\t\t\t char *, int));\n+\t\t\t\t\t\t char *, int, int));\n static char *base_name\t\t\tPARAMS ((const char *));\n static void dump_special_to_buffer\tPARAMS ((cpp_reader *, const char *));\n static void initialize_dependency_output PARAMS ((cpp_reader *));\n+static void initialize_standard_includes PARAMS ((cpp_reader *));\n static void new_pending_define\t\tPARAMS ((struct cpp_options *,\n \t\t\t\t\t\t const char *));\n \n-/* Last argument to append_include_chain: chain to use */\n+/* Fourth argument to append_include_chain: chain to use */\n enum { QUOTE = 0, BRACKET, SYSTEM, AFTER };\n \n /* If gcc is in use (stage2/stage3) we can make this table initialized data. */\n@@ -289,7 +290,7 @@ path_include (pfile, pend, list, path)\n \t  name[q - p] = 0;\n \t}\n \n-      append_include_chain (pfile, pend, name, path);\n+      append_include_chain (pfile, pend, name, path, 0);\n \n       /* Advance past this name.  */\n       if (*q == 0)\n@@ -325,11 +326,12 @@ base_name (fname)\n /* Append DIR to include path PATH.  DIR must be permanently allocated\n    and writable. */\n static void\n-append_include_chain (pfile, pend, dir, path)\n+append_include_chain (pfile, pend, dir, path, cxx_aware)\n      cpp_reader *pfile;\n      struct cpp_pending *pend;\n      char *dir;\n      int path;\n+     int cxx_aware;\n {\n   struct file_name_list *new;\n   struct stat st;\n@@ -361,7 +363,10 @@ append_include_chain (pfile, pend, dir, path)\n   new->nlen = len;\n   new->ino  = st.st_ino;\n   new->dev  = st.st_dev;\n-  new->sysp = (path == SYSTEM);\n+  if (path == SYSTEM)\n+    new->sysp = cxx_aware ? 1 : 2;\n+  else\n+    new->sysp = 0;\n   new->name_map = NULL;\n   new->next = NULL;\n   new->alloc = NULL;\n@@ -384,7 +389,7 @@ dump_special_to_buffer (pfile, macro_name)\n      cpp_reader *pfile;\n      const char *macro_name;\n {\n-  static char define_directive[] = \"#define \";\n+  static const char define_directive[] = \"#define \";\n   int macro_name_length = strlen (macro_name);\n   output_line_command (pfile, same_file);\n   CPP_RESERVE (pfile, sizeof(define_directive) + macro_name_length);\n@@ -513,7 +518,7 @@ static const struct builtin builtin_array[] =\n   { \"__TIME__\",\t\t\t0, T_TIME,\t\tDUMP },\n   { \"__DATE__\",\t\t\t0, T_DATE,\t\tDUMP },\n   { \"__FILE__\",\t\t\t0, T_FILE,\t\t0    },\n-  { \"__BASE_FILE__\",\t\t0, T_BASE_FILE,\t\tDUMP },\n+  { \"__BASE_FILE__\",\t\t0, T_BASE_FILE,\t\t0    },\n   { \"__LINE__\",\t\t\t0, T_SPECLINE,\t\t0    },\n   { \"__INCLUDE_LEVEL__\",\t0, T_INCLUDE_LEVEL,\t0    },\n   { \"__VERSION__\",\t\t0, T_VERSION,\t\tDUMP },\n@@ -656,6 +661,99 @@ initialize_dependency_output (pfile)\n     }\n }\n \n+/* And another subroutine.  This one sets up the standard include path.  */\n+static void\n+initialize_standard_includes (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_options *opts = CPP_OPTIONS (pfile);\n+  char *path;\n+  struct default_include *p = include_defaults_array;\n+  char *specd_prefix = opts->include_prefix;\n+\n+  /* Several environment variables may add to the include search path.\n+     CPATH specifies an additional list of directories to be searched\n+     as if specified with -I, while C_INCLUDE_PATH, CPLUS_INCLUDE_PATH,\n+     etc. specify an additional list of directories to be searched as\n+     if specified with -isystem, for the language indicated.  */\n+\n+  GET_ENV_PATH_LIST (path, \"CPATH\");\n+  if (path != 0 && *path != 0)\n+    path_include (pfile, opts->pending, path, BRACKET);\n+\n+  switch ((opts->objc << 1) + opts->cplusplus)\n+    {\n+    case 0:\n+      GET_ENV_PATH_LIST (path, \"C_INCLUDE_PATH\");\n+      break;\n+    case 1:\n+      GET_ENV_PATH_LIST (path, \"CPLUS_INCLUDE_PATH\");\n+      break;\n+    case 2:\n+      GET_ENV_PATH_LIST (path, \"OBJC_INCLUDE_PATH\");\n+      break;\n+    case 3:\n+      GET_ENV_PATH_LIST (path, \"OBJCPLUS_INCLUDE_PATH\");\n+      break;\n+    }\n+  if (path != 0 && *path != 0)\n+    path_include (pfile, opts->pending, path, SYSTEM);\n+\n+  /* Search \"translated\" versions of GNU directories.\n+     These have /usr/local/lib/gcc... replaced by specd_prefix.  */\n+  if (specd_prefix != 0)\n+    {\n+      char *default_prefix = alloca (sizeof GCC_INCLUDE_DIR - 7);\n+      /* Remove the `include' from /usr/local/lib/gcc.../include.\n+\t GCC_INCLUDE_DIR will always end in /include. */\n+      int default_len = sizeof GCC_INCLUDE_DIR - 8;\n+      int specd_len = strlen (specd_prefix);\n+\n+      memcpy (default_prefix, GCC_INCLUDE_DIR, default_len);\n+      default_prefix[default_len] = '\\0';\n+\n+      for (p = include_defaults_array; p->fname; p++)\n+\t{\n+\t  /* Some standard dirs are only for C++.  */\n+\t  if (!p->cplusplus\n+\t      || (opts->cplusplus\n+\t\t  && !opts->no_standard_cplusplus_includes))\n+\t    {\n+\t      /* Does this dir start with the prefix?  */\n+\t      if (!strncmp (p->fname, default_prefix, default_len))\n+\t\t{\n+\t\t  /* Yes; change prefix and add to search list.  */\n+\t\t  int flen = strlen (p->fname);\n+\t\t  int this_len = specd_len + flen - default_len;\n+\t\t  char *str = (char *) xmalloc (this_len + 1);\n+\t\t  memcpy (str, specd_prefix, specd_len);\n+\t\t  memcpy (str + specd_len,\n+\t\t\t  p->fname + default_len,\n+\t\t\t  flen - default_len + 1);\n+\n+\t\t  append_include_chain (pfile, opts->pending,\n+\t\t\t\t\tstr, SYSTEM, p->cxx_aware);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  /* Search ordinary names for GNU include directories.  */\n+  for (p = include_defaults_array; p->fname; p++)\n+    {\n+      /* Some standard dirs are only for C++.  */\n+      if (!p->cplusplus\n+\t  || (opts->cplusplus\n+\t      && !opts->no_standard_cplusplus_includes))\n+\t{\n+\t  /* XXX Potential memory leak! */\n+\t  char *str = xstrdup (update_path (p->fname, p->component));\n+\t  append_include_chain (pfile, opts->pending, str, SYSTEM,\n+\t\t\t\tp->cxx_aware);\n+\t}\n+    }\n+}\n+\n /* This is called after options have been processed.\n  * Check options for consistency, and setup for processing input\n  * from the file named FNAME.  (Use standard input if FNAME==NULL.)\n@@ -669,9 +767,6 @@ cpp_start_read (pfile, fname)\n {\n   struct cpp_options *opts = CPP_OPTIONS (pfile);\n   struct pending_option *p, *q;\n-  int f;\n-  cpp_buffer *fp;\n-  struct include_hash *ih_fake;\n \n   /* -MG doesn't select the form of output and must be specified with one of\n      -M or -MM.  -MG doesn't make sense with -MD or -MMD since they don't\n@@ -693,6 +788,11 @@ cpp_start_read (pfile, fname)\n   /* Set this if it hasn't been set already. */\n   if (user_label_prefix == NULL)\n     user_label_prefix = USER_LABEL_PREFIX;\n+\n+  /* Don't bother trying to do macro expansion if we've already done\n+     preprocessing.  */\n+  if (opts->preprocessed)\n+    pfile->no_macro_expand++;\n   \n   /* Now that we know dollars_in_ident, we can initialize the syntax\n      tables. */\n@@ -702,30 +802,52 @@ cpp_start_read (pfile, fname)\n   if (opts->dollars_in_ident)\n     IStable['$'] = ISidstart|ISidnum;\n \n-  /* Do partial setup of input buffer for the sake of generating\n-     early #line directives (when -g is in effect).  */\n-  fp = cpp_push_buffer (pfile, NULL, 0);\n-  if (!fp)\n-    return 0;\n+  /* Set up the include search path now.  */\n+  if (! opts->no_standard_includes)\n+    initialize_standard_includes (pfile);\n+\n+  merge_include_chains (opts);\n+\n+  /* With -v, print the list of dirs to search.  */\n+  if (opts->verbose)\n+    {\n+      struct file_name_list *l;\n+      fprintf (stderr, _(\"#include \\\"...\\\" search starts here:\\n\"));\n+      for (l = opts->quote_include; l; l = l->next)\n+\t{\n+\t  if (l == opts->bracket_include)\n+\t    fprintf (stderr, _(\"#include <...> search starts here:\\n\"));\n+\t  fprintf (stderr, \" %s\\n\", l->name);\n+\t}\n+      fprintf (stderr, _(\"End of search list.\\n\"));\n+    }\n+\n+  initialize_dependency_output (pfile);\n+  \n+  /* Open the main input file.  This must be done before -D processing\n+     so we have a buffer to stand on.  */\n   if (opts->in_fname == NULL || *opts->in_fname == 0)\n     {\n       opts->in_fname = fname;\n       if (opts->in_fname == NULL)\n \topts->in_fname = \"\";\n     }\n-  fp->nominal_fname = fp->fname = opts->in_fname;\n-  fp->lineno = 0;\n \n-  /* Install __LINE__, etc.  Must follow initialize_char_syntax\n-     and option processing.  */\n+  if (!cpp_read_file (pfile, fname))\n+    return 0;\n+\n+  /* -D and friends may produce output, which should be identified\n+     as line 0.  */\n+\n+  CPP_BUFFER (pfile)->lineno = 0;\n+\n+  /* Install __LINE__, etc.  */\n   initialize_builtins (pfile);\n \n   /* Do -U's, -D's and -A's in the order they were seen.  */\n   p = opts->pending->define_head;\n   while (p)\n     {\n-      if (opts->debug_output)\n-\toutput_line_command (pfile, same_file);\n       if (p->undef)\n \tcpp_undef (pfile, p->arg);\n       else\n@@ -739,8 +861,6 @@ cpp_start_read (pfile, fname)\n   p = opts->pending->assert_head;\n   while (p)\n     {\n-      if (opts->debug_output)\n-\toutput_line_command (pfile, same_file);\n       if (p->undef)\n \tcpp_unassert (pfile, p->arg);\n       else\n@@ -752,152 +872,8 @@ cpp_start_read (pfile, fname)\n     }\n   \n   opts->done_initializing = 1;\n+  CPP_BUFFER (pfile)->lineno = 1;\n \n-  /* Several environment variables may add to the include search path.\n-     CPATH specifies an additional list of directories to be searched\n-     as if specified with -I, while C_INCLUDE_PATH, CPLUS_INCLUDE_PATH,\n-     etc. specify an additional list of directories to be searched as\n-     if specified with -isystem, for the language indicated.\n-\n-     These variables are ignored if -nostdinc is on.  */\n-  if (! opts->no_standard_includes)\n-    {\n-      char *path;\n-      GET_ENV_PATH_LIST (path, \"CPATH\");\n-      if (path != 0 && *path != 0)\n-\tpath_include (pfile, opts->pending, path, BRACKET);\n-\n-      switch ((opts->objc << 1) + opts->cplusplus)\n-\t{\n-\tcase 0:\n-\t  GET_ENV_PATH_LIST (path, \"C_INCLUDE_PATH\");\n-\t  break;\n-\tcase 1:\n-\t  GET_ENV_PATH_LIST (path, \"CPLUS_INCLUDE_PATH\");\n-\t  break;\n-\tcase 2:\n-\t  GET_ENV_PATH_LIST (path, \"OBJC_INCLUDE_PATH\");\n-\t  break;\n-\tcase 3:\n-\t  GET_ENV_PATH_LIST (path, \"OBJCPLUS_INCLUDE_PATH\");\n-\t  break;\n-\t}\n-      if (path != 0 && *path != 0)\n-\tpath_include (pfile, opts->pending, path, SYSTEM);\n-    }\n-\n-  /* Unless -nostdinc, add the compiled-in include path to the list,\n-     translating prefixes. */\n-  if (!opts->no_standard_includes)\n-    {\n-      struct default_include *p = include_defaults_array;\n-      char *specd_prefix = opts->include_prefix;\n-\n-      /* Search \"translated\" versions of GNU directories.\n-\t These have /usr/local/lib/gcc... replaced by specd_prefix.  */\n-      if (specd_prefix != 0)\n-\t{\n-\t  char *default_prefix = alloca (sizeof GCC_INCLUDE_DIR - 7);\n-\t  /* Remove the `include' from /usr/local/lib/gcc.../include.\n-\t     GCC_INCLUDE_DIR will always end in /include. */\n-\t  int default_len = sizeof GCC_INCLUDE_DIR - 8;\n-\t  int specd_len = strlen (specd_prefix);\n-\n-\t  memcpy (default_prefix, GCC_INCLUDE_DIR, default_len);\n-\t  default_prefix[default_len] = '\\0';\n-\n-\t  for (p = include_defaults_array; p->fname; p++)\n-\t    {\n-\t      /* Some standard dirs are only for C++.  */\n-\t      if (!p->cplusplus\n-\t\t  || (opts->cplusplus\n-\t\t      && !opts->no_standard_cplusplus_includes))\n-\t\t{\n-\t\t  /* Does this dir start with the prefix?  */\n-\t\t  if (!strncmp (p->fname, default_prefix, default_len))\n-\t\t    {\n-\t\t      /* Yes; change prefix and add to search list.  */\n-\t\t      int flen = strlen (p->fname);\n-\t\t      int this_len = specd_len + flen - default_len;\n-\t\t      char *str = (char *) xmalloc (this_len + 1);\n-\t\t      memcpy (str, specd_prefix, specd_len);\n-\t\t      memcpy (str + specd_len,\n-\t\t\t      p->fname + default_len,\n-\t\t\t      flen - default_len + 1);\n-\n-\t\t      append_include_chain (pfile, opts->pending,\n-\t\t\t\t\t    str, SYSTEM);\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* Search ordinary names for GNU include directories.  */\n-      for (p = include_defaults_array; p->fname; p++)\n-\t{\n-\t  /* Some standard dirs are only for C++.  */\n-\t  if (!p->cplusplus\n-\t      || (opts->cplusplus\n-\t\t  && !opts->no_standard_cplusplus_includes))\n-\t    {\n-\t      /* XXX Potential memory leak! */\n-\t      char *str = xstrdup (update_path (p->fname, p->component));\n-\t      append_include_chain (pfile, opts->pending, str, SYSTEM);\n-\t    }\n-\t}\n-    }\n-\n-  merge_include_chains (opts);\n-\n-  /* With -v, print the list of dirs to search.  */\n-  if (opts->verbose)\n-    {\n-      struct file_name_list *p;\n-      fprintf (stderr, _(\"#include \\\"...\\\" search starts here:\\n\"));\n-      for (p = opts->quote_include; p; p = p->next)\n-\t{\n-\t  if (p == opts->bracket_include)\n-\t    fprintf (stderr, _(\"#include <...> search starts here:\\n\"));\n-\t  fprintf (stderr, \" %s\\n\", p->name);\n-\t}\n-      fprintf (stderr, _(\"End of search list.\\n\"));\n-    }\n-\n-  /* Don't bother trying to do macro expansion if we've already done\n-     preprocessing.  */\n-  if (opts->preprocessed)\n-    pfile->no_macro_expand++;\n-\n-  /* Open the main input file.\n-     We do this in nonblocking mode so we don't get stuck here if\n-     someone clever has asked cpp to process /dev/rmt0;\n-     finclude() will check that we have a real file to work with.  */\n-  if (fname == NULL || *fname == 0)\n-    {\n-      fname = \"\";\n-      f = 0;\n-    }\n-  else if ((f = open (fname, O_RDONLY|O_NONBLOCK|O_NOCTTY, 0666)) < 0)\n-    {\n-      cpp_notice_from_errno (pfile, fname);\n-      return 0;\n-    }\n-\n-  initialize_dependency_output (pfile);\n-\n-  /* Must call finclude() on the main input before processing\n-     -include switches; otherwise the -included text winds up\n-     after the main input. */\n-  ih_fake = (struct include_hash *) xmalloc (sizeof (struct include_hash));\n-  ih_fake->next = 0;\n-  ih_fake->next_this_file = 0;\n-  ih_fake->foundhere = ABSOLUTE_PATH;  /* well sort of ... */\n-  ih_fake->name = fname;\n-  ih_fake->control_macro = 0;\n-  ih_fake->buf = (char *)-1;\n-  ih_fake->limit = 0;\n-  if (!finclude (pfile, f, ih_fake))\n-    return 0;\n   if (opts->preprocessed)\n     /* If we've already processed this code, we want to trust the #line\n        directives in the input.  But we still need to update our line\n@@ -911,82 +887,29 @@ cpp_start_read (pfile, fname)\n      have to be pushed onto the include stack and processed later,\n      in the main loop calling cpp_get_token.  */\n   \n-  pfile->no_record_file++;\n   opts->no_output++;\n   p = opts->pending->imacros_head;\n   while (p)\n     {\n-      int fd = open (p->arg, O_RDONLY|O_NONBLOCK|O_NOCTTY, 0666);\n-      if (fd < 0)\n-\t{\n-\t  cpp_notice_from_errno (pfile, p->arg);\n-\t  return 0;\n-\t}\n-      if (!cpp_push_buffer (pfile, NULL, 0))\n-\treturn 0;\n-\n-      ih_fake = (struct include_hash *)\n-\txmalloc (sizeof (struct include_hash));\n-      ih_fake->next = 0;\n-      ih_fake->next_this_file = 0;\n-      ih_fake->foundhere = ABSOLUTE_PATH;  /* well sort of ... */\n-      ih_fake->name = p->arg;\n-      ih_fake->control_macro = 0;\n-      ih_fake->buf = (char *)-1;\n-      ih_fake->limit = 0;\n-      if (finclude (pfile, fd, ih_fake))\n-\t{\n-\t  if (CPP_PRINT_DEPS (pfile))\n-\t    deps_output (pfile, ih_fake->name, ' ');\n-\n-\t  cpp_scan_buffer (pfile);\n-\t}\n-      else\n-\tcpp_pop_buffer (pfile);\n-      free (ih_fake);\n+      if (cpp_read_file (pfile, p->arg))\n+\tcpp_scan_buffer (pfile);\n \n       q = p->next;\n       free (p);\n       p = q;\n     }\n-\n   opts->no_output--;\n \n   p = opts->pending->include_head;\n   while (p)\n     {\n-      int fd = open (p->arg, O_RDONLY|O_NONBLOCK|O_NOCTTY, 0666);\n-      if (fd < 0)\n-\t{\n-\t  cpp_notice_from_errno (pfile, p->arg);\n-\t  return 0;\n-\t}\n-      if (!cpp_push_buffer (pfile, NULL, 0))\n-\treturn 0;\n-\n-      ih_fake = (struct include_hash *)\n-\txmalloc (sizeof (struct include_hash));\n-      ih_fake->next = 0;\n-      ih_fake->next_this_file = 0;\n-      ih_fake->foundhere = ABSOLUTE_PATH;  /* well sort of ... */\n-      ih_fake->name = p->arg;\n-      ih_fake->control_macro = 0;\n-      ih_fake->buf = (char *)-1;\n-      ih_fake->limit = 0;\n-      if (finclude (pfile, fd, ih_fake))\n-\t{\n-\t  if (CPP_PRINT_DEPS (pfile))\n-\t    deps_output (pfile, ih_fake->name, ' ');\n-\t  \n-\t  output_line_command (pfile, enter_file);\n-\t}\n-      else\n-\tcpp_pop_buffer (pfile);\n+      if (cpp_read_file (pfile, p->arg))\n+\toutput_line_command (pfile, enter_file);\n+\n       q = p->next;\n       free (p);\n       p = q;\n     }\n-  pfile->no_record_file--;\n \n   free (opts->pending);\n   opts->pending = NULL;\n@@ -1141,7 +1064,7 @@ cpp_handle_option (pfile, argc, argv)\n \t    else\n \t      fname = argv[++i];\n \t    append_include_chain (pfile, opts->pending,\n-\t\t\t\t  xstrdup (fname), BRACKET);\n+\t\t\t\t  xstrdup (fname), BRACKET, 0);\n \t  }\n \tbreak;\n \n@@ -1153,7 +1076,7 @@ cpp_handle_option (pfile, argc, argv)\n \t    if (i + 1 == argc)\n \t      goto missing_filename;\n \t    append_include_chain (pfile, opts->pending,\n-\t\t\t\t  xstrdup (argv[++i]), SYSTEM);\n+\t\t\t\t  xstrdup (argv[++i]), SYSTEM, 0);\n \t  }\n \telse if (!strcmp (argv[i], \"-include\"))\n \t  {\n@@ -1210,7 +1133,7 @@ cpp_handle_option (pfile, argc, argv)\n \t\tmemcpy (fname + sizeof GCC_INCLUDE_DIR - 9, argv[i], len + 1);\n \t      }\n \t  \n-\t    append_include_chain (pfile, opts->pending, fname, SYSTEM);\n+\t    append_include_chain (pfile, opts->pending, fname, SYSTEM, 0);\n \t  }\n \t/* Add directory to main path for includes,\n \t   with the default prefix at the front of its name.  */\n@@ -1236,15 +1159,15 @@ cpp_handle_option (pfile, argc, argv)\n \t\tmemcpy (fname + sizeof GCC_INCLUDE_DIR - 9, argv[i], len + 1);\n \t      }\n \t  \n-\t    append_include_chain (pfile, opts->pending, fname, BRACKET);\n+\t    append_include_chain (pfile, opts->pending, fname, BRACKET, 0);\n \t  }\n \t/* Add directory to end of path for includes.  */\n \telse if (!strcmp (argv[i], \"-idirafter\"))\n \t  {\n \t    if (i + 1 == argc)\n \t      goto missing_dirname;\n \t    append_include_chain (pfile, opts->pending,\n-\t\t\t\t  xstrdup (argv[++i]), AFTER);\n+\t\t\t\t  xstrdup (argv[++i]), AFTER, 0);\n \t  }\n \telse if (!strcmp (argv[i], \"-iprefix\"))\n \t  {"}, {"sha": "c5cf67436247cfd9cd8d0edbb978d07fafb7d3e2", "filename": "gcc/cpplib.c", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45da1ca925d67685ca633b48a4ca1ec44dfaca1/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45da1ca925d67685ca633b48a4ca1ec44dfaca1/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=c45da1ca925d67685ca633b48a4ca1ec44dfaca1", "patch": "@@ -654,7 +654,7 @@ get_macro_name (pfile)\n static int\n do_define (pfile, keyword)\n      cpp_reader *pfile;\n-     const struct directive *keyword;\n+     const struct directive *keyword ATTRIBUTE_UNUSED;\n {\n   HASHNODE *hp;\n   DEFINITION *def;\n@@ -728,14 +728,11 @@ do_define (pfile, keyword)\n   else\n     cpp_install (pfile, sym, len, T_MACRO, (char *) def);\n \n-  if (keyword != NULL && keyword->type == T_DEFINE)\n-    {\n-      if (CPP_OPTIONS (pfile)->debug_output\n-\t  || CPP_OPTIONS (pfile)->dump_macros == dump_definitions)\n-\tdump_definition (pfile, sym, len, def);\n-      else if (CPP_OPTIONS (pfile)->dump_macros == dump_names)\n-\tpass_thru_directive (sym, len, pfile, keyword);\n-    }\n+  if (CPP_OPTIONS (pfile)->debug_output\n+      || CPP_OPTIONS (pfile)->dump_macros == dump_definitions)\n+    dump_definition (pfile, sym, len, def);\n+  else if (CPP_OPTIONS (pfile)->dump_macros == dump_names)\n+    pass_thru_directive (sym, len, pfile, keyword);\n \n   return 0;\n }\n@@ -876,7 +873,9 @@ cpp_expand_to_buffer (pfile, buf, length)\n   /* Scan the input, create the output.  */\n   save_no_output = CPP_OPTIONS (pfile)->no_output;\n   CPP_OPTIONS (pfile)->no_output = 0;\n+  CPP_OPTIONS (pfile)->no_line_commands++;\n   cpp_scan_buffer (pfile);\n+  CPP_OPTIONS (pfile)->no_line_commands--;\n   CPP_OPTIONS (pfile)->no_output = save_no_output;\n \n   CPP_NUL_TERMINATE (pfile);\n@@ -926,16 +925,14 @@ output_line_command (pfile, file_change)\n      enum file_change_code file_change;\n {\n   long line;\n-  cpp_buffer *ip = CPP_BUFFER (pfile);\n-\n-  if (ip->fname == NULL)\n-    return;\n+  cpp_buffer *ip;\n \n   if (CPP_OPTIONS (pfile)->no_line_commands\n       || CPP_OPTIONS (pfile)->no_output)\n     return;\n \n-  cpp_buf_line_and_col (CPP_BUFFER (pfile), &line, NULL);\n+  ip = cpp_file_buffer (pfile);\n+  cpp_buf_line_and_col (ip, &line, NULL);\n \n   /* If the current file has not changed, we omit the #line if it would\n      appear to be a no-op, and we output a few newlines instead"}, {"sha": "60d0eed1e14dc0b3ab513cdf9649deed72d34e64", "filename": "gcc/cpplib.h", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c45da1ca925d67685ca633b48a4ca1ec44dfaca1/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c45da1ca925d67685ca633b48a4ca1ec44dfaca1/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=c45da1ca925d67685ca633b48a4ca1ec44dfaca1", "patch": "@@ -34,7 +34,8 @@ typedef struct cpp_reader cpp_reader;\n typedef struct cpp_buffer cpp_buffer;\n typedef struct cpp_options cpp_options;\n \n-enum cpp_token {\n+enum cpp_token\n+{\n   CPP_EOF = -1,\n   CPP_OTHER = 0,\n   CPP_COMMENT = 1,\n@@ -188,23 +189,23 @@ struct cpp_reader\n   struct if_stack *if_stack;\n \n   /* Nonzero means we have printed (while error reporting) a list of\n-     containing files that matches the current status. */\n+     containing files that matches the current status.  */\n   char input_stack_listing_current;\n \n-  /* If non-zero, macros are not expanded. */\n+  /* If non-zero, macros are not expanded.  */\n   char no_macro_expand;\n \n   /* If non-zero, directives cause a hard error.  Used when parsing\n      macro arguments.  */\n   char no_directives;\n \n-  /* Print column number in error messages. */\n+  /* Print column number in error messages.  */\n   char show_column;\n \n-  /* We're printed a warning recommending against using #import. */\n+  /* We're printed a warning recommending against using #import.  */\n   char import_warning;\n \n-  /* If true, character between '<' and '>' are a single (string) token. */\n+  /* If true, character between '<' and '>' are a single (string) token.  */\n   char parsing_include_directive;\n \n   /* If true, # introduces an assertion (see do_assert) */\n@@ -214,18 +215,13 @@ struct cpp_reader\n   char parsing_define_directive;\n \n   /* True if escape sequences (as described for has_escapes in\n-     parse_buffer) should be emitted. */\n+     parse_buffer) should be emitted.  */\n   char output_escapes;\n \n   /* 0: Have seen non-white-space on this line.\n      1: Only seen white space so far on this line.\n-     2: Only seen white space so far in this file. */\n-   char only_seen_white;\n-\n-  /* Nonzero means this file was included with a -imacros or -include\n-     command line and should not be recorded as an include file.  */\n-\n-  char no_record_file;\n+     2: Only seen white space so far in this file.  */\n+  char only_seen_white;\n \n   long lineno;\n \n@@ -432,7 +428,6 @@ struct cpp_options {\n   char remap;\n \n   /* Nonzero means don't output line number information.  */\n-\n   char no_line_commands;\n \n   /* Nonzero means -I- has been seen,\n@@ -713,6 +708,7 @@ extern int find_include_file\t\tPARAMS ((cpp_reader *, const char *,\n \t\t\t\t\t\tint *));\n extern int finclude\t\t\tPARAMS ((cpp_reader *, int,\n \t\t\t\t\t        struct include_hash *));\n+extern int cpp_read_file\t\tPARAMS ((cpp_reader *, const char *));\n extern void deps_output\t\t\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\tconst char *, int));\n extern struct include_hash *include_hash PARAMS ((cpp_reader *, const char *, int));"}]}