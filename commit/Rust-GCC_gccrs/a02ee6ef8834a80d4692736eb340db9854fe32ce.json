{"sha": "a02ee6ef8834a80d4692736eb340db9854fe32ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTAyZWU2ZWY4ODM0YTgwZDQ2OTI3MzZlYjM0MGRiOTg1NGZlMzJjZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-20T12:53:12Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-20T12:53:12Z"}, "message": "poly_int: rtx_addr_can_trap_p_1\n\nThis patch changes the offset and size arguments of\nrtx_addr_can_trap_p_1 from HOST_WIDE_INT to poly_int64.  It also\nuses a size of -1 rather than 0 to represent an unknown size and\nBLKmode rather than VOIDmode to represent an unknown mode.\n\n2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* rtlanal.c (rtx_addr_can_trap_p_1): Take the offset and size\n\tas poly_int64s rather than HOST_WIDE_INTs.  Use a size of -1\n\trather than 0 to represent an unknown size.  Assert that the size\n\tis known when the mode isn't BLKmode.\n\t(may_trap_p_1): Use -1 for unknown sizes.\n\t(rtx_addr_can_trap_p): Likewise.  Pass BLKmode rather than VOIDmode.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255874", "tree": {"sha": "8efbeb8e2635bca8270351647151119cc25cd0a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8efbeb8e2635bca8270351647151119cc25cd0a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a02ee6ef8834a80d4692736eb340db9854fe32ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a02ee6ef8834a80d4692736eb340db9854fe32ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a02ee6ef8834a80d4692736eb340db9854fe32ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a02ee6ef8834a80d4692736eb340db9854fe32ce/comments", "author": null, "committer": null, "parents": [{"sha": "02ce5d903e74829a10d98fc25cbe84c3b4d5f023", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02ce5d903e74829a10d98fc25cbe84c3b4d5f023", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02ce5d903e74829a10d98fc25cbe84c3b4d5f023"}], "stats": {"total": 69, "additions": 40, "deletions": 29}, "files": [{"sha": "48865ad23b2f0fc6e12a9410f321de1465a6b616", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a02ee6ef8834a80d4692736eb340db9854fe32ce/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a02ee6ef8834a80d4692736eb340db9854fe32ce/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a02ee6ef8834a80d4692736eb340db9854fe32ce", "patch": "@@ -1,3 +1,14 @@\n+2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* rtlanal.c (rtx_addr_can_trap_p_1): Take the offset and size\n+\tas poly_int64s rather than HOST_WIDE_INTs.  Use a size of -1\n+\trather than 0 to represent an unknown size.  Assert that the size\n+\tis known when the mode isn't BLKmode.\n+\t(may_trap_p_1): Use -1 for unknown sizes.\n+\t(rtx_addr_can_trap_p): Likewise.  Pass BLKmode rather than VOIDmode.\n+\n 2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "54f94df80da61159765a4cf901ba1d36675c2822", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a02ee6ef8834a80d4692736eb340db9854fe32ce/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a02ee6ef8834a80d4692736eb340db9854fe32ce/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=a02ee6ef8834a80d4692736eb340db9854fe32ce", "patch": "@@ -457,16 +457,17 @@ get_initial_register_offset (int from, int to)\n    references on strict alignment machines.  */\n \n static int\n-rtx_addr_can_trap_p_1 (const_rtx x, HOST_WIDE_INT offset, HOST_WIDE_INT size,\n+rtx_addr_can_trap_p_1 (const_rtx x, poly_int64 offset, poly_int64 size,\n \t\t       machine_mode mode, bool unaligned_mems)\n {\n   enum rtx_code code = GET_CODE (x);\n+  gcc_checking_assert (mode == BLKmode || known_size_p (size));\n \n   /* The offset must be a multiple of the mode size if we are considering\n      unaligned memory references on strict alignment machines.  */\n-  if (STRICT_ALIGNMENT && unaligned_mems && GET_MODE_SIZE (mode) != 0)\n+  if (STRICT_ALIGNMENT && unaligned_mems && mode != BLKmode)\n     {\n-      HOST_WIDE_INT actual_offset = offset;\n+      poly_int64 actual_offset = offset;\n \n #ifdef SPARC_STACK_BOUNDARY_HACK\n       /* ??? The SPARC port may claim a STACK_BOUNDARY higher than\n@@ -477,7 +478,7 @@ rtx_addr_can_trap_p_1 (const_rtx x, HOST_WIDE_INT offset, HOST_WIDE_INT size,\n \tactual_offset -= STACK_POINTER_OFFSET;\n #endif\n \n-      if (actual_offset % GET_MODE_SIZE (mode) != 0)\n+      if (!multiple_p (actual_offset, GET_MODE_SIZE (mode)))\n \treturn 1;\n     }\n \n@@ -489,14 +490,12 @@ rtx_addr_can_trap_p_1 (const_rtx x, HOST_WIDE_INT offset, HOST_WIDE_INT size,\n       if (!CONSTANT_POOL_ADDRESS_P (x) && !SYMBOL_REF_FUNCTION_P (x))\n \t{\n \t  tree decl;\n-\t  HOST_WIDE_INT decl_size;\n+\t  poly_int64 decl_size;\n \n-\t  if (offset < 0)\n+\t  if (maybe_lt (offset, 0))\n \t    return 1;\n-\t  if (size == 0)\n-\t    size = GET_MODE_SIZE (mode);\n-\t  if (size == 0)\n-\t    return offset != 0;\n+\t  if (!known_size_p (size))\n+\t    return maybe_ne (offset, 0);\n \n \t  /* If the size of the access or of the symbol is unknown,\n \t     assume the worst.  */\n@@ -507,17 +506,20 @@ rtx_addr_can_trap_p_1 (const_rtx x, HOST_WIDE_INT offset, HOST_WIDE_INT size,\n \t  if (!decl)\n \t    decl_size = -1;\n \t  else if (DECL_P (decl) && DECL_SIZE_UNIT (decl))\n-\t    decl_size = (tree_fits_shwi_p (DECL_SIZE_UNIT (decl))\n-\t\t\t ? tree_to_shwi (DECL_SIZE_UNIT (decl))\n-\t\t\t : -1);\n+\t    {\n+\t      if (!poly_int_tree_p (DECL_SIZE_UNIT (decl), &decl_size))\n+\t\tdecl_size = -1;\n+\t    }\n \t  else if (TREE_CODE (decl) == STRING_CST)\n \t    decl_size = TREE_STRING_LENGTH (decl);\n \t  else if (TYPE_SIZE_UNIT (TREE_TYPE (decl)))\n \t    decl_size = int_size_in_bytes (TREE_TYPE (decl));\n \t  else\n \t    decl_size = -1;\n \n-\t  return (decl_size <= 0 ? offset != 0 : offset + size > decl_size);\n+\t  return (!known_size_p (decl_size) || known_eq (decl_size, 0)\n+\t\t  ? maybe_ne (offset, 0)\n+\t\t  : maybe_gt (offset + size, decl_size));\n         }\n \n       return 0;\n@@ -534,17 +536,14 @@ rtx_addr_can_trap_p_1 (const_rtx x, HOST_WIDE_INT offset, HOST_WIDE_INT size,\n \t || (x == arg_pointer_rtx && fixed_regs[ARG_POINTER_REGNUM]))\n \t{\n #ifdef RED_ZONE_SIZE\n-\t  HOST_WIDE_INT red_zone_size = RED_ZONE_SIZE;\n+\t  poly_int64 red_zone_size = RED_ZONE_SIZE;\n #else\n-\t  HOST_WIDE_INT red_zone_size = 0;\n+\t  poly_int64 red_zone_size = 0;\n #endif\n-\t  HOST_WIDE_INT stack_boundary = PREFERRED_STACK_BOUNDARY\n-\t\t\t\t\t / BITS_PER_UNIT;\n-\t  HOST_WIDE_INT low_bound, high_bound;\n+\t  poly_int64 stack_boundary = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;\n+\t  poly_int64 low_bound, high_bound;\n \n-\t  if (size == 0)\n-\t    size = GET_MODE_SIZE (mode);\n-\t  if (size == 0)\n+\t  if (!known_size_p (size))\n \t    return 1;\n \n \t  if (x == frame_pointer_rtx)\n@@ -562,10 +561,10 @@ rtx_addr_can_trap_p_1 (const_rtx x, HOST_WIDE_INT offset, HOST_WIDE_INT size,\n \t    }\n \t  else if (x == hard_frame_pointer_rtx)\n \t    {\n-\t      HOST_WIDE_INT sp_offset\n+\t      poly_int64 sp_offset\n \t\t= get_initial_register_offset (STACK_POINTER_REGNUM,\n \t\t\t\t\t       HARD_FRAME_POINTER_REGNUM);\n-\t      HOST_WIDE_INT ap_offset\n+\t      poly_int64 ap_offset\n \t\t= get_initial_register_offset (ARG_POINTER_REGNUM,\n \t\t\t\t\t       HARD_FRAME_POINTER_REGNUM);\n \n@@ -589,7 +588,7 @@ rtx_addr_can_trap_p_1 (const_rtx x, HOST_WIDE_INT offset, HOST_WIDE_INT size,\n \t    }\n \t  else if (x == stack_pointer_rtx)\n \t    {\n-\t      HOST_WIDE_INT ap_offset\n+\t      poly_int64 ap_offset\n \t\t= get_initial_register_offset (ARG_POINTER_REGNUM,\n \t\t\t\t\t       STACK_POINTER_REGNUM);\n \n@@ -629,7 +628,8 @@ rtx_addr_can_trap_p_1 (const_rtx x, HOST_WIDE_INT offset, HOST_WIDE_INT size,\n #endif\n \t    }\n \n-\t  if (offset >= low_bound && offset <= high_bound - size)\n+\t  if (known_ge (offset, low_bound)\n+\t      && known_le (offset, high_bound - size))\n \t    return 0;\n \t  return 1;\n \t}\n@@ -649,7 +649,7 @@ rtx_addr_can_trap_p_1 (const_rtx x, HOST_WIDE_INT offset, HOST_WIDE_INT size,\n       if (XEXP (x, 0) == pic_offset_table_rtx\n \t  && GET_CODE (XEXP (x, 1)) == CONST\n \t  && GET_CODE (XEXP (XEXP (x, 1), 0)) == UNSPEC\n-\t  && offset == 0)\n+\t  && known_eq (offset, 0))\n \treturn 0;\n \n       /* - or it is an address that can't trap plus a constant integer.  */\n@@ -686,7 +686,7 @@ rtx_addr_can_trap_p_1 (const_rtx x, HOST_WIDE_INT offset, HOST_WIDE_INT size,\n int\n rtx_addr_can_trap_p (const_rtx x)\n {\n-  return rtx_addr_can_trap_p_1 (x, 0, 0, VOIDmode, false);\n+  return rtx_addr_can_trap_p_1 (x, 0, -1, BLKmode, false);\n }\n \n /* Return true if X contains a MEM subrtx.  */\n@@ -2796,7 +2796,7 @@ may_trap_p_1 (const_rtx x, unsigned flags)\n \t  code_changed\n \t  || !MEM_NOTRAP_P (x))\n \t{\n-\t  HOST_WIDE_INT size = MEM_SIZE_KNOWN_P (x) ? MEM_SIZE (x) : 0;\n+\t  HOST_WIDE_INT size = MEM_SIZE_KNOWN_P (x) ? MEM_SIZE (x) : -1;\n \t  return rtx_addr_can_trap_p_1 (XEXP (x, 0), 0, size,\n \t\t\t\t\tGET_MODE (x), code_changed);\n \t}"}]}