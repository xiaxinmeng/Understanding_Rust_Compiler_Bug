{"sha": "c5a35c3c50228be69ecbb579b53925d7be73377d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVhMzVjM2M1MDIyOGJlNjllY2JiNTc5YjUzOTI1ZDdiZTczMzc3ZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2005-11-06T19:41:18Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2005-11-06T19:41:18Z"}, "message": "re PR c++/21308 (Very high compile time)\n\n\tPR c++/21308\n\t* class.c (sizeof_biggest_empty_class): New variable.\n\t(record_subobject_offsets): Don't record offsets past biggest\n\tempty class for data members.  Replace vbases_p parameter with\n\tis_data_member parameter.\n\t(build_base_field): Adjust call.\n\t(layout_class_type): Likewise.  Maintain\n\tsizeof_biggest_empty_class.\n\nFrom-SVN: r106566", "tree": {"sha": "77425e35325959db6ea6ad913424e48a072f7455", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77425e35325959db6ea6ad913424e48a072f7455"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5a35c3c50228be69ecbb579b53925d7be73377d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5a35c3c50228be69ecbb579b53925d7be73377d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5a35c3c50228be69ecbb579b53925d7be73377d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5a35c3c50228be69ecbb579b53925d7be73377d/comments", "author": null, "committer": null, "parents": [{"sha": "4523d51b35a2a83b9632658067833000079081a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4523d51b35a2a83b9632658067833000079081a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4523d51b35a2a83b9632658067833000079081a9"}], "stats": {"total": 55, "additions": 46, "deletions": 9}, "files": [{"sha": "af13226a5282fe48caf453e1ba5e11c9f22e28de", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a35c3c50228be69ecbb579b53925d7be73377d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a35c3c50228be69ecbb579b53925d7be73377d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c5a35c3c50228be69ecbb579b53925d7be73377d", "patch": "@@ -1,3 +1,14 @@\n+2005-11-06  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/21308\n+\t* class.c (sizeof_biggest_empty_class): New variable.\n+\t(record_subobject_offsets): Don't record offsets past biggest\n+\tempty class for data members.  Replace vbases_p parameter with\n+\tis_data_member parameter.\n+\t(build_base_field): Adjust call.\n+\t(layout_class_type): Likewise.  Maintain\n+\tsizeof_biggest_empty_class.\n+\t\n 2005-11-05  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* decl2.c, init.c, typeck.c: Fix comment typos."}, {"sha": "77f025b7acc8b8ddf8ed910f2f31d37ab53fd002", "filename": "gcc/cp/class.c", "status": "modified", "additions": 35, "deletions": 9, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a35c3c50228be69ecbb579b53925d7be73377d/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a35c3c50228be69ecbb579b53925d7be73377d/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=c5a35c3c50228be69ecbb579b53925d7be73377d", "patch": "@@ -103,6 +103,9 @@ typedef int (*subobject_offset_fn) (tree, tree, splay_tree);\n static int current_class_stack_size;\n static class_stack_node_t current_class_stack;\n \n+/* The size of the largest empty class seen in this translation unit.  */\n+static GTY (()) tree sizeof_biggest_empty_class;\n+\n /* An array of all local classes present in this translation unit, in\n    declaration order.  */\n VEC(tree,gc) *local_classes;\n@@ -192,7 +195,7 @@ static int record_subobject_offset (tree, tree, splay_tree);\n static int check_subobject_offset (tree, tree, splay_tree);\n static int walk_subobject_offsets (tree, subobject_offset_fn,\n \t\t\t\t   tree, splay_tree, tree, int);\n-static void record_subobject_offsets (tree, tree, splay_tree, int);\n+static void record_subobject_offsets (tree, tree, splay_tree, bool);\n static int layout_conflict_p (tree, tree, splay_tree, int);\n static int splay_tree_compare_integer_csts (splay_tree_key k1,\n \t\t\t\t\t    splay_tree_key k2);\n@@ -3284,17 +3287,35 @@ walk_subobject_offsets (tree type,\n }\n \n /* Record all of the empty subobjects of TYPE (located at OFFSET) in\n-   OFFSETS.  If VBASES_P is nonzero, virtual bases of TYPE are\n-   examined.  */\n+   OFFSETS.  If IS_DATA_MEMBER is true, then a non-static data member\n+   is being placed at OFFSET; otherwise, it is a base class that is\n+   being placed at OFFSET.  */\n \n static void\n record_subobject_offsets (tree type,\n \t\t\t  tree offset,\n \t\t\t  splay_tree offsets,\n-\t\t\t  int vbases_p)\n-{\n+\t\t\t  bool is_data_member)\n+{\n+  tree max_offset;\n+  /* If recording subobjects for a non-static data member, do not need\n+     to record offsets beyond the size of the biggest empty class.\n+     Additional data members will go at the end of the class.\n+     Additional base classes will go either at offset zero (if empty,\n+     in which case they cannot overlap with offsets past the size of\n+     the biggest empty class) or at the end of the class.  \n+\n+     However, if we are placing an empty class, then we must record\n+     all offsets, as either the empty class is at offset zero (where\n+     other empty classes might later be placed) or at the end of the\n+     class (where other objects might then be placed, so other empty\n+     subobjects might later overlap).  */\n+  if (is_data_member)\n+    max_offset = sizeof_biggest_empty_class;\n+  else\n+    max_offset = NULL_TREE;\n   walk_subobject_offsets (type, record_subobject_offset, offset,\n-\t\t\t  offsets, /*max_offset=*/NULL_TREE, vbases_p);\n+\t\t\t  offsets, max_offset, is_data_member);\n }\n \n /* Returns nonzero if any of the empty subobjects of TYPE (located at\n@@ -3553,7 +3574,7 @@ build_base_field (record_layout_info rli, tree binfo,\n \t{\n \t  if (atend)\n \t    CLASSTYPE_NEARLY_EMPTY_P (t) = 0;\n-\t  /* The check above (used in G++ 3.2) is insufficient  because\n+\t  /* The check above (used in G++ 3.2) is insufficient because\n \t     an empty class placed at offset zero might itself have an\n \t     empty base at a nonzero offset.  */\n \t  else if (walk_subobject_offsets (basetype,\n@@ -3587,7 +3608,7 @@ build_base_field (record_layout_info rli, tree binfo,\n   record_subobject_offsets (binfo,\n \t\t\t    BINFO_OFFSET (binfo),\n \t\t\t    offsets,\n-\t\t\t    /*vbases_p=*/0);\n+\t\t\t    /*is_data_member=*/false);\n \n   return next_field;\n }\n@@ -4649,7 +4670,7 @@ layout_class_type (tree t, tree *virtuals_p)\n \trecord_subobject_offsets (TREE_TYPE (field),\n \t\t\t\t  byte_position(field),\n \t\t\t\t  empty_base_offsets,\n-\t\t\t\t  /*vbases_p=*/1);\n+\t\t\t\t  /*is_data_member=*/true);\n \n       /* If a bit-field does not immediately follow another bit-field,\n \t and yet it starts in the middle of a byte, we have failed to\n@@ -4827,6 +4848,10 @@ layout_class_type (tree t, tree *virtuals_p)\n \n   /* Clean up.  */\n   splay_tree_delete (empty_base_offsets);\n+\n+  if (CLASSTYPE_EMPTY_P (t)\n+      && tree_int_cst_lt (sizeof_biggest_empty_class, TYPE_SIZE (t)))\n+    sizeof_biggest_empty_class = TYPE_SIZE (t);\n }\n \n /* Determine the \"key method\" for the class type indicated by TYPE,\n@@ -5308,6 +5333,7 @@ init_class_processing (void)\n   current_class_stack\n     = xmalloc (current_class_stack_size * sizeof (struct class_stack_node));\n   local_classes = VEC_alloc (tree, gc, 8);\n+  sizeof_biggest_empty_class = size_zero_node;\n \n   ridpointers[(int) RID_PUBLIC] = access_public_node;\n   ridpointers[(int) RID_PRIVATE] = access_private_node;"}]}