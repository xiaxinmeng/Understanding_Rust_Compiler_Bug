{"sha": "c5cb5d18b3e49588aadba045a8b4eb42cf343cb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVjYjVkMThiM2U0OTU4OGFhZGJhMDQ1YThiNGViNDJjZjM0M2NiMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2008-06-27T17:20:32Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2008-06-27T17:20:32Z"}, "message": "mips-protos.h (mips_split_const_insns): Declare.\n\ngcc/\n\t* config/mips/mips-protos.h (mips_split_const_insns): Declare.\n\t* config/mips/mips.c (mips_split_const_insns): New function.\n\t* config/mips/mips.md (move_type): New attribute.\n\t(mode): Move attribute definition earlier in file.  Add \"TI\"\n\tand \"TF\".\n\t(dword_mode): New attribute.\n\t(type): Avoid long line.  Map \"move_type\"s to \"type\"s,\n\tchoosing \"multi\" for doubleword moves if appropriate.\n\tSwap MTC/MFC comments to match their declaration order.\n\t(extended_mips16): Default to \"yes\" if \"move_type\" is \"sll0\",\n\t\"type\" is \"branch\" or \"jal\" is \"direct\".\n\t(length): Handle \"extended_mips16\" first.  Make the default\n\t\"0\" for \"ghost\" instructions.  Set the length from \"move_type\".\n\t(truncdisi2, truncdihi2, truncdiqi2): Use \"move_type\" instead\n\tof \"type\", with \"sll0\" for the register alternative.  Remove the\n\t\"extended_mips16\" attribute.\n\t(zero_extendsidi2, *clear_upper32): Use \"move_type\" instead\n\tof \"type\", with \"shift_shift\" for the register alternative.\n\tRemove the \"length\" attribute.\n\t(*extend<SHORT:mode><GPR:mode>2, *extendqihi2): Likewise.\n\t(*zero_extend<SHORT:mode><GPR:mode>2): Use \"move_type\" instead\n\tof \"type\", with \"andi\" for the register alternative.\n\t(*zero_extendqihi2): Likewise.\n\t(*zero_extend<SHORT:mode><GPR:mode>2_mips16e): Use a \"move_type\"\n\tof \"andi\" instead of a \"type\" of \"arith\".\n\t(*zero_extend<SHORT:mode><GPR:mode>2_mips16): Use \"move_type\"\n\tinstead of \"type\".\n\t(*zero_extendqihi2_mips16, mov_<load>l, mov_<load>r, mov_<store>l)\n\t(mov_<store>r, *mov<mode>_ra): Likewise.\n\t(extendsidi2): Use \"move_type\" instead of \"type\", with \"move\"\n\tfor the register alternative.\n\t(*extend<SHORT:mode><GPR:mode>2_mips16e): Use \"move_type\" instead\n\tof \"type\", with \"signext\" for the register alternative.\n\t(*extend<SHORT:mode><GPR:mode>2_se<SHORT:size>): Likewise.\n\t(*extendqihi2_mips16e, *extendqihi2_seb): Likewise.\n\t(fix_truncdfsi2_insn, fix_truncsfsi2_insn, fix_truncdfdi2)\n\t(fix_truncsfdi2, floatsidf2, floatdidf2, floatsisf2, floatdisf2)\n\t(floatdisf2, *branch_equality<mode>_mips16): Likewise.\n\t(unnamed branch insn): Likewise.\n\t(*movdi_gp32_fp64): Fold into...\n\t(*movdi_32bit): ...here.\n\t(*movdf_hardfloat_64bit, *movdf_hardfloat_32bit): Combine into...\n\t(*movdf_hardfloat): ...this new pattern.\n\t(*movdf_softfloat): Remove redundant FPR alternatives.\n\t(*movti, *movti_mips16, *movtf, *movtf_mips16): Add \"mode\" attributes.\n\t(*movv2sf_hardfloat_64bit, *movv2sf_hardfloat_32bit): Combine into...\n\t(*movv2sf): ...this new pattern.  Use \"DF\" rather than \"SF\" for\n\tthe \"move\" attribute.\n\t(*movdi_32bit): Use \"move_type\" instead of \"type\" and remove the\n\t\"length\" attribute.  Use \"fpload\" and \"fpstore\" instead of \"load\"\n\tand \"store\" for COP loads and stores.\n\t(*movdi_32bit_mips16, *movdi_64bit, *movsi_internal, movcc)\n\t(*movhi_internal, *movhi_mips16, *movqi_internal, *movqi_mips16)\n\t(*movsf_hardfloat, *movsf_softfloat, *movsi_mips16, *movdf_hardfloat)\n\t(*movdf_softfloat, *movdf_mips16, *movti, *movti_mips16, *movtf)\n\t(*movtf_mips16, *movv2sf): Likewise.\n\t(mfhi<GPR:mode>_<HILO:mode>, mflo<GPR:mode>_<HILO:mode>)\n\t(load_low<mode>, load_high<mode>, store_word<mode>, mthc1<mode>)\n\t(mfhc1<mode>): Use \"move_type\" instead of \"move\".\n\t(*low<mode>_mips16): Use \"extended_mips16\" instead of \"length\".\n\t(loadgp_blockage): Remove the \"length\" attribute.\n\t(blockage, set_got_version, update_got_version): Likewise.\n\t(call_internal): Remove the \"extended_mips16\" attribute.\n\t(call_value_internal, call_value_multiple_internal): Likewise.\n\t* config/mips/loongson.md (mov<mode>_internal): Use \"move_type\"\n\tinstead of \"move\".\n\t* config/mips/mips-dsp.md (mips_lbux, mips_lhx, mips_lwx): Remove\n\tthe \"length\" attribute.\n\nFrom-SVN: r137194", "tree": {"sha": "fff81f4b0a191eaf2782f66ba5b265c6b8290736", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fff81f4b0a191eaf2782f66ba5b265c6b8290736"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5cb5d18b3e49588aadba045a8b4eb42cf343cb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5cb5d18b3e49588aadba045a8b4eb42cf343cb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5cb5d18b3e49588aadba045a8b4eb42cf343cb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5cb5d18b3e49588aadba045a8b4eb42cf343cb1/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7d71283c1ab34e906016b1ddfb74750c0594689d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d71283c1ab34e906016b1ddfb74750c0594689d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d71283c1ab34e906016b1ddfb74750c0594689d"}], "stats": {"total": 583, "additions": 325, "deletions": 258}, "files": [{"sha": "30dea0f21fd186cbcf95f46eb53dcd8e91bf0982", "filename": "gcc/ChangeLog", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cb5d18b3e49588aadba045a8b4eb42cf343cb1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cb5d18b3e49588aadba045a8b4eb42cf343cb1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5cb5d18b3e49588aadba045a8b4eb42cf343cb1", "patch": "@@ -1,3 +1,74 @@\n+2008-06-27  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* config/mips/mips-protos.h (mips_split_const_insns): Declare.\n+\t* config/mips/mips.c (mips_split_const_insns): New function.\n+\t* config/mips/mips.md (move_type): New attribute.\n+\t(mode): Move attribute definition earlier in file.  Add \"TI\"\n+\tand \"TF\".\n+\t(dword_mode): New attribute.\n+\t(type): Avoid long line.  Map \"move_type\"s to \"type\"s,\n+\tchoosing \"multi\" for doubleword moves if appropriate.\n+\tSwap MTC/MFC comments to match their declaration order.\n+\t(extended_mips16): Default to \"yes\" if \"move_type\" is \"sll0\",\n+\t\"type\" is \"branch\" or \"jal\" is \"direct\".\n+\t(length): Handle \"extended_mips16\" first.  Make the default\n+\t\"0\" for \"ghost\" instructions.  Set the length from \"move_type\".\n+\t(truncdisi2, truncdihi2, truncdiqi2): Use \"move_type\" instead\n+\tof \"type\", with \"sll0\" for the register alternative.  Remove the\n+\t\"extended_mips16\" attribute.\n+\t(zero_extendsidi2, *clear_upper32): Use \"move_type\" instead\n+\tof \"type\", with \"shift_shift\" for the register alternative.\n+\tRemove the \"length\" attribute.\n+\t(*extend<SHORT:mode><GPR:mode>2, *extendqihi2): Likewise.\n+\t(*zero_extend<SHORT:mode><GPR:mode>2): Use \"move_type\" instead\n+\tof \"type\", with \"andi\" for the register alternative.\n+\t(*zero_extendqihi2): Likewise.\n+\t(*zero_extend<SHORT:mode><GPR:mode>2_mips16e): Use a \"move_type\"\n+\tof \"andi\" instead of a \"type\" of \"arith\".\n+\t(*zero_extend<SHORT:mode><GPR:mode>2_mips16): Use \"move_type\"\n+\tinstead of \"type\".\n+\t(*zero_extendqihi2_mips16, mov_<load>l, mov_<load>r, mov_<store>l)\n+\t(mov_<store>r, *mov<mode>_ra): Likewise.\n+\t(extendsidi2): Use \"move_type\" instead of \"type\", with \"move\"\n+\tfor the register alternative.\n+\t(*extend<SHORT:mode><GPR:mode>2_mips16e): Use \"move_type\" instead\n+\tof \"type\", with \"signext\" for the register alternative.\n+\t(*extend<SHORT:mode><GPR:mode>2_se<SHORT:size>): Likewise.\n+\t(*extendqihi2_mips16e, *extendqihi2_seb): Likewise.\n+\t(fix_truncdfsi2_insn, fix_truncsfsi2_insn, fix_truncdfdi2)\n+\t(fix_truncsfdi2, floatsidf2, floatdidf2, floatsisf2, floatdisf2)\n+\t(floatdisf2, *branch_equality<mode>_mips16): Likewise.\n+\t(unnamed branch insn): Likewise.\n+\t(*movdi_gp32_fp64): Fold into...\n+\t(*movdi_32bit): ...here.\n+\t(*movdf_hardfloat_64bit, *movdf_hardfloat_32bit): Combine into...\n+\t(*movdf_hardfloat): ...this new pattern.\n+\t(*movdf_softfloat): Remove redundant FPR alternatives.\n+\t(*movti, *movti_mips16, *movtf, *movtf_mips16): Add \"mode\" attributes.\n+\t(*movv2sf_hardfloat_64bit, *movv2sf_hardfloat_32bit): Combine into...\n+\t(*movv2sf): ...this new pattern.  Use \"DF\" rather than \"SF\" for\n+\tthe \"move\" attribute.\n+\t(*movdi_32bit): Use \"move_type\" instead of \"type\" and remove the\n+\t\"length\" attribute.  Use \"fpload\" and \"fpstore\" instead of \"load\"\n+\tand \"store\" for COP loads and stores.\n+\t(*movdi_32bit_mips16, *movdi_64bit, *movsi_internal, movcc)\n+\t(*movhi_internal, *movhi_mips16, *movqi_internal, *movqi_mips16)\n+\t(*movsf_hardfloat, *movsf_softfloat, *movsi_mips16, *movdf_hardfloat)\n+\t(*movdf_softfloat, *movdf_mips16, *movti, *movti_mips16, *movtf)\n+\t(*movtf_mips16, *movv2sf): Likewise.\n+\t(mfhi<GPR:mode>_<HILO:mode>, mflo<GPR:mode>_<HILO:mode>)\n+\t(load_low<mode>, load_high<mode>, store_word<mode>, mthc1<mode>)\n+\t(mfhc1<mode>): Use \"move_type\" instead of \"move\".\n+\t(*low<mode>_mips16): Use \"extended_mips16\" instead of \"length\".\n+\t(loadgp_blockage): Remove the \"length\" attribute.\n+\t(blockage, set_got_version, update_got_version): Likewise.\n+\t(call_internal): Remove the \"extended_mips16\" attribute.\n+\t(call_value_internal, call_value_multiple_internal): Likewise.\n+\t* config/mips/loongson.md (mov<mode>_internal): Use \"move_type\"\n+\tinstead of \"move\".\n+\t* config/mips/mips-dsp.md (mips_lbux, mips_lhx, mips_lwx): Remove\n+\tthe \"length\" attribute.\n+\n 2008-06-27  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* c-format.c (handle_format_attribute): Fix -Wc++-compat and/or"}, {"sha": "98b5113fbb56d89b7665736cb483655fd6cf2994", "filename": "gcc/config/mips/loongson.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cb5d18b3e49588aadba045a8b4eb42cf343cb1/gcc%2Fconfig%2Fmips%2Floongson.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cb5d18b3e49588aadba045a8b4eb42cf343cb1/gcc%2Fconfig%2Fmips%2Floongson.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Floongson.md?ref=c5cb5d18b3e49588aadba045a8b4eb42cf343cb1", "patch": "@@ -83,7 +83,7 @@\n \t(match_operand:VWHB 1 \"move_operand\"          \"f,m,f,dYG,dYG,dYG,m\"))]\n   \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\" \"fpstore,fpload,mfc,mtc,move,store,load\")\n+  [(set_attr \"move_type\" \"fpstore,fpload,mfc,mtc,move,store,load\")\n    (set_attr \"mode\" \"DI\")])\n \n ;; Initialization of a vector."}, {"sha": "9a70b665d22222c411218e83fab8477b03947090", "filename": "gcc/config/mips/mips-dsp.md", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cb5d18b3e49588aadba045a8b4eb42cf343cb1/gcc%2Fconfig%2Fmips%2Fmips-dsp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cb5d18b3e49588aadba045a8b4eb42cf343cb1/gcc%2Fconfig%2Fmips%2Fmips-dsp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-dsp.md?ref=c5cb5d18b3e49588aadba045a8b4eb42cf343cb1", "patch": "@@ -1017,8 +1017,7 @@\n   \"ISA_HAS_DSP\"\n   \"lbux\\t%0,%2(%1)\"\n   [(set_attr \"type\"\t\"load\")\n-   (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"4\")])\n+   (set_attr \"mode\"\t\"SI\")])\n \n (define_insn \"mips_lhx\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n@@ -1029,8 +1028,7 @@\n   \"ISA_HAS_DSP\"\n   \"lhx\\t%0,%2(%1)\"\n   [(set_attr \"type\"\t\"load\")\n-   (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"4\")])\n+   (set_attr \"mode\"\t\"SI\")])\n \n (define_insn \"mips_lwx\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n@@ -1039,8 +1037,7 @@\n   \"ISA_HAS_DSP\"\n   \"lwx\\t%0,%2(%1)\"\n   [(set_attr \"type\"\t\"load\")\n-   (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"4\")])\n+   (set_attr \"mode\"\t\"SI\")])\n \n ;; Table 2-8. MIPS DSP ASE Instructions: Branch\n ;; BPOSGE32"}, {"sha": "d092cb6f5c12e2c998c420078dc699402045114a", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cb5d18b3e49588aadba045a8b4eb42cf343cb1/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cb5d18b3e49588aadba045a8b4eb42cf343cb1/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=c5cb5d18b3e49588aadba045a8b4eb42cf343cb1", "patch": "@@ -171,6 +171,7 @@ extern bool mips_legitimate_address_p (enum machine_mode, rtx, bool);\n extern bool mips_stack_address_p (rtx, enum machine_mode);\n extern int mips_address_insns (rtx, enum machine_mode, bool);\n extern int mips_const_insns (rtx);\n+extern int mips_split_const_insns (rtx);\n extern int mips_load_store_insns (rtx, rtx);\n extern int mips_idiv_insns (void);\n extern rtx mips_emit_move (rtx, rtx);"}, {"sha": "48ba54b1cef6dcae5924a032d24336ea8d3c6350", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cb5d18b3e49588aadba045a8b4eb42cf343cb1/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cb5d18b3e49588aadba045a8b4eb42cf343cb1/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=c5cb5d18b3e49588aadba045a8b4eb42cf343cb1", "patch": "@@ -2121,6 +2121,21 @@ mips_const_insns (rtx x)\n     }\n }\n \n+/* X is a doubleword constant that can be handled by splitting it into\n+   two words and loading each word separately.  Return the number of\n+   instructions required to do this.  */\n+\n+int\n+mips_split_const_insns (rtx x)\n+{\n+  unsigned int low, high;\n+\n+  low = mips_const_insns (mips_subword (x, false));\n+  high = mips_const_insns (mips_subword (x, true));\n+  gcc_assert (low > 0 && high > 0);\n+  return low + high;\n+}\n+\n /* Return the number of instructions needed to implement INSN,\n    given that it loads from or stores to MEM.  Count extended\n    MIPS16 instructions as two instructions.  */"}, {"sha": "6b2f5fac64d3fc23e687357d4871af2f7648c492", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 234, "deletions": 251, "changes": 485, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5cb5d18b3e49588aadba045a8b4eb42cf343cb1/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5cb5d18b3e49588aadba045a8b4eb42cf343cb1/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=c5cb5d18b3e49588aadba045a8b4eb42cf343cb1", "patch": "@@ -280,6 +280,44 @@\n \t (symbol_ref \"TARGET_CALL_CLOBBERED_GP\")]\n \t(const_string \"no\")))\n \n+;; Classification of moves, extensions and truncations.  Most values\n+;; are as for \"type\" (see below) but there are also the following\n+;; move-specific values:\n+;;\n+;; constN\tmove an N-constraint integer into a MIPS16 register\n+;; sll0\t\t\"sll DEST,SRC,0\", which on 64-bit targets is guaranteed\n+;;\t\tto produce a sign-extended DEST, even if SRC is not\n+;;\t\tproperly sign-extended\n+;; andi\t\ta single ANDI instruction\n+;; loadpool\tmove a constant into a MIPS16 register by loading it\n+;;\t\tfrom the pool\n+;; shift_shift\ta shift left followed by a shift right\n+;; lui_movf\tan LUI followed by a MOVF (for d<-z CC moves)\n+;;\n+;; This attribute is used to determine the instruction's length and\n+;; scheduling type.  For doubleword moves, the attribute always describes\n+;; the split instructions; in some cases, it is more appropriate for the\n+;; scheduling type to be \"multi\" instead.\n+(define_attr \"move_type\"\n+  \"unknown,load,fpload,store,fpstore,mtc,mfc,mthilo,mfhilo,move,fmove,\n+   const,constN,signext,sll0,andi,loadpool,shift_shift,lui_movf\"\n+  (const_string \"unknown\"))\n+\n+;; Main data type used by the insn\n+(define_attr \"mode\" \"unknown,none,QI,HI,SI,DI,TI,SF,DF,TF,FPSW\"\n+  (const_string \"unknown\"))\n+\n+;; True if the main data type is twice the size of a word.\n+(define_attr \"dword_mode\" \"no,yes\"\n+  (cond [(and (eq_attr \"mode\" \"DI,DF\")\n+\t      (eq (symbol_ref \"TARGET_64BIT\") (const_int 0)))\n+\t (const_string \"yes\")\n+\n+\t (and (eq_attr \"mode\" \"TI,TF\")\n+\t      (ne (symbol_ref \"TARGET_64BIT\") (const_int 0)))\n+\t (const_string \"yes\")]\n+\t(const_string \"no\")))\n+\n ;; Classification of each insn.\n ;; branch\tconditional branch\n ;; jump\t\tunconditional jump\n@@ -293,8 +331,8 @@\n ;; prefetch\tmemory prefetch (register + offset)\n ;; prefetchx\tmemory indexed prefetch (register + register)\n ;; condmove\tconditional moves\n-;; mfc\t\ttransfer from coprocessor\n ;; mtc\t\ttransfer to coprocessor\n+;; mfc\t\ttransfer from coprocessor\n ;; mthilo\ttransfer to hi/lo registers\n ;; mfhilo\ttransfer from hi/lo registers\n ;; const\tload constant\n@@ -330,15 +368,45 @@\n ;; nop\t\tno operation\n ;; ghost\tan instruction that produces no real code\n (define_attr \"type\"\n-  \"unknown,branch,jump,call,load,fpload,fpidxload,store,fpstore,fpidxstore,prefetch,prefetchx,condmove,mfc,mtc,mthilo,mfhilo,const,arith,logical,shift,slt,signext,clz,trap,imul,imul3,imadd,idiv,move,fmove,fadd,fmul,fmadd,fdiv,frdiv,frdiv1,frdiv2,fabs,fneg,fcmp,fcvt,fsqrt,frsqrt,frsqrt1,frsqrt2,multi,nop,ghost\"\n+  \"unknown,branch,jump,call,load,fpload,fpidxload,store,fpstore,fpidxstore,\n+   prefetch,prefetchx,condmove,mtc,mfc,mthilo,mfhilo,const,arith,logical,\n+   shift,slt,signext,clz,trap,imul,imul3,imadd,idiv,move,fmove,fadd,fmul,\n+   fmadd,fdiv,frdiv,frdiv1,frdiv2,fabs,fneg,fcmp,fcvt,fsqrt,frsqrt,frsqrt1,\n+   frsqrt2,multi,nop,ghost\"\n   (cond [(eq_attr \"jal\" \"!unset\") (const_string \"call\")\n-\t (eq_attr \"got\" \"load\") (const_string \"load\")]\n+\t (eq_attr \"got\" \"load\") (const_string \"load\")\n+\n+\t ;; If a doubleword move uses these expensive instructions,\n+\t ;; it is usually better to schedule them in the same way\n+\t ;; as the singleword form, rather than as \"multi\".\n+\t (eq_attr \"move_type\" \"load\") (const_string \"load\")\n+\t (eq_attr \"move_type\" \"fpload\") (const_string \"fpload\")\n+\t (eq_attr \"move_type\" \"store\") (const_string \"store\")\n+\t (eq_attr \"move_type\" \"fpstore\") (const_string \"fpstore\")\n+\t (eq_attr \"move_type\" \"mtc\") (const_string \"mtc\")\n+\t (eq_attr \"move_type\" \"mfc\") (const_string \"mfc\")\n+\t (eq_attr \"move_type\" \"mthilo\") (const_string \"mthilo\")\n+\t (eq_attr \"move_type\" \"mfhilo\") (const_string \"mfhilo\")\n+\n+\t ;; These types of move are always single insns.\n+\t (eq_attr \"move_type\" \"fmove\") (const_string \"fmove\")\n+\t (eq_attr \"move_type\" \"loadpool\") (const_string \"load\")\n+\t (eq_attr \"move_type\" \"signext\") (const_string \"signext\")\n+\t (eq_attr \"move_type\" \"sll0\") (const_string \"shift\")\n+\t (eq_attr \"move_type\" \"andi\") (const_string \"logical\")\n+\n+\t ;; These types of move are always split.\n+\t (eq_attr \"move_type\" \"constN,lui_movf,shift_shift\")\n+\t   (const_string \"multi\")\n+\n+\t ;; These types of move are split for doubleword modes only.\n+\t (and (eq_attr \"move_type\" \"move,const\")\n+\t      (eq_attr \"dword_mode\" \"yes\"))\n+\t   (const_string \"multi\")\n+\t (eq_attr \"move_type\" \"move\") (const_string \"move\")\n+\t (eq_attr \"move_type\" \"const\") (const_string \"const\")]\n \t(const_string \"unknown\")))\n \n-;; Main data type used by the insn\n-(define_attr \"mode\" \"unknown,none,QI,HI,SI,DI,SF,DF,FPSW\"\n-  (const_string \"unknown\"))\n-\n ;; Mode for conversion types (fcvt)\n ;; I2S          integer to float single (SI/DI to SF)\n ;; I2D          integer to float double (SI/DI to DF)\n@@ -352,11 +420,19 @@\n \n ;; Is this an extended instruction in mips16 mode?\n (define_attr \"extended_mips16\" \"no,yes\"\n-  (const_string \"no\"))\n+  (if_then_else (ior (eq_attr \"move_type\" \"sll0\")\n+\t\t     (eq_attr \"type\" \"branch\")\n+\t\t     (eq_attr \"jal\" \"direct\"))\n+\t\t(const_string \"yes\")\n+\t\t(const_string \"no\")))\n \n ;; Length of instruction in bytes.\n (define_attr \"length\" \"\"\n-   (cond [;; Direct branch instructions have a range of [-0x40000,0x3fffc].\n+   (cond [(and (eq_attr \"extended_mips16\" \"yes\")\n+\t       (ne (symbol_ref \"TARGET_MIPS16\") (const_int 0)))\n+\t  (const_int 8)\n+\n+\t  ;; Direct branch instructions have a range of [-0x40000,0x3fffc].\n \t  ;; If a branch is outside this range, we have a choice of two\n \t  ;; sequences.  For PIC, an out-of-range branch like:\n \t  ;;\n@@ -396,16 +472,49 @@\n \t\t (const_int 24)\n \t\t ] (const_int 12))\n \n+\t  ;; \"Ghost\" instructions occupy no space.\n+\t  (eq_attr \"type\" \"ghost\")\n+\t  (const_int 0)\n+\n \t  (eq_attr \"got\" \"load\")\n \t  (const_int 4)\n \t  (eq_attr \"got\" \"xgot_high\")\n \t  (const_int 8)\n \n-\t  (eq_attr \"type\" \"const\")\n+\t  ;; In general, constant-pool loads are extended instructions.\n+\t  (eq_attr \"move_type\" \"loadpool\")\n+\t  (const_int 8)\n+\n+\t  ;; LUI_MOVFs are decomposed into two separate instructions.\n+\t  (eq_attr \"move_type\" \"lui_movf\")\n+\t  (const_int 8)\n+\n+\t  ;; SHIFT_SHIFTs are decomposed into two separate instructions.\n+\t  ;; They are extended instructions on MIPS16 targets.\n+\t  (eq_attr \"move_type\" \"shift_shift\")\n+\t  (if_then_else (ne (symbol_ref \"TARGET_MIPS16\") (const_int 0))\n+\t\t\t(const_int 16)\n+\t\t\t(const_int 8))\n+\n+\t  ;; Check for doubleword moves that are decomposed into two\n+\t  ;; instructions.\n+\t  (and (eq_attr \"move_type\" \"mtc,mfc,mthilo,mfhilo,move\")\n+\t       (eq_attr \"dword_mode\" \"yes\"))\n+\t  (const_int 8)\n+\n+\t  ;; Doubleword CONST{,N} moves are split into two word\n+\t  ;; CONST{,N} moves.\n+\t  (and (eq_attr \"move_type\" \"const,constN\")\n+\t       (eq_attr \"dword_mode\" \"yes\"))\n+\t  (symbol_ref \"mips_split_const_insns (operands[1]) * 4\")\n+\n+\t  ;; Otherwise, constants, loads and stores are handled by external\n+\t  ;; routines.\n+\t  (eq_attr \"move_type\" \"const,constN\")\n \t  (symbol_ref \"mips_const_insns (operands[1]) * 4\")\n-\t  (eq_attr \"type\" \"load,fpload\")\n+\t  (eq_attr \"move_type\" \"load,fpload\")\n \t  (symbol_ref \"mips_load_store_insns (operands[1], insn) * 4\")\n-\t  (eq_attr \"type\" \"store,fpstore\")\n+\t  (eq_attr \"move_type\" \"store,fpstore\")\n \t  (symbol_ref \"mips_load_store_insns (operands[0], insn) * 4\")\n \n \t  ;; In the worst case, a call macro will take 8 instructions:\n@@ -421,10 +530,6 @@\n \t  (eq_attr \"jal_macro\" \"yes\")\n \t  (const_int 32)\n \n-\t  (and (eq_attr \"extended_mips16\" \"yes\")\n-\t       (ne (symbol_ref \"TARGET_MIPS16\") (const_int 0)))\n-\t  (const_int 8)\n-\n \t  ;; Various VR4120 errata require a nop to be inserted after a macc\n \t  ;; instruction.  The assembler does this for us, so account for\n \t  ;; the worst-case length here.\n@@ -2509,9 +2614,8 @@\n   \"@\n     sll\\t%0,%1,0\n     sw\\t%1,%0\"\n-  [(set_attr \"type\" \"shift,store\")\n-   (set_attr \"mode\" \"SI\")\n-   (set_attr \"extended_mips16\" \"yes,*\")])\n+  [(set_attr \"move_type\" \"sll0,store\")\n+   (set_attr \"mode\" \"SI\")])\n \n (define_insn \"truncdihi2\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,m\")\n@@ -2520,9 +2624,8 @@\n   \"@\n     sll\\t%0,%1,0\n     sh\\t%1,%0\"\n-  [(set_attr \"type\" \"shift,store\")\n-   (set_attr \"mode\" \"SI\")\n-   (set_attr \"extended_mips16\" \"yes,*\")])\n+  [(set_attr \"move_type\" \"sll0,store\")\n+   (set_attr \"mode\" \"SI\")])\n \n (define_insn \"truncdiqi2\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,m\")\n@@ -2531,9 +2634,8 @@\n   \"@\n     sll\\t%0,%1,0\n     sb\\t%1,%0\"\n-  [(set_attr \"type\" \"shift,store\")\n-   (set_attr \"mode\" \"SI\")\n-   (set_attr \"extended_mips16\" \"yes,*\")])\n+  [(set_attr \"move_type\" \"sll0,store\")\n+   (set_attr \"mode\" \"SI\")])\n \n ;; Combiner patterns to optimize shift/truncate combinations.\n \n@@ -2648,9 +2750,8 @@\n    (set (match_dup 0)\n         (lshiftrt:DI (match_dup 0) (const_int 32)))]\n   { operands[1] = gen_lowpart (DImode, operands[1]); }\n-  [(set_attr \"type\" \"multi,load\")\n-   (set_attr \"mode\" \"DI\")\n-   (set_attr \"length\" \"8,*\")])\n+  [(set_attr \"move_type\" \"shift_shift,load\")\n+   (set_attr \"mode\" \"DI\")])\n \n ;; Combine is not allowed to convert this insn into a zero_extendsidi2\n ;; because of TRULY_NOOP_TRUNCATION.\n@@ -2673,9 +2774,8 @@\n    (set (match_dup 0)\n         (lshiftrt:DI (match_dup 0) (const_int 32)))]\n   \"\"\n-  [(set_attr \"type\" \"multi,load\")\n-   (set_attr \"mode\" \"DI\")\n-   (set_attr \"length\" \"8,*\")])\n+  [(set_attr \"move_type\" \"shift_shift,load\")\n+   (set_attr \"mode\" \"DI\")])\n \n (define_expand \"zero_extend<SHORT:mode><GPR:mode>2\"\n   [(set (match_operand:GPR 0 \"register_operand\")\n@@ -2701,23 +2801,24 @@\n   \"@\n    andi\\t%0,%1,<SHORT:mask>\n    l<SHORT:size>u\\t%0,%1\"\n-  [(set_attr \"type\" \"logical,load\")\n+  [(set_attr \"move_type\" \"andi,load\")\n    (set_attr \"mode\" \"<GPR:MODE>\")])\n \n (define_insn \"*zero_extend<SHORT:mode><GPR:mode>2_mips16e\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n         (zero_extend:GPR (match_operand:SHORT 1 \"register_operand\" \"0\")))]\n   \"GENERATE_MIPS16E\"\n   \"ze<SHORT:size>\\t%0\"\n-  [(set_attr \"type\" \"arith\")\n+  ;; This instruction is effectively a special encoding of ANDI.\n+  [(set_attr \"move_type\" \"andi\")\n    (set_attr \"mode\" \"<GPR:MODE>\")])\n \n (define_insn \"*zero_extend<SHORT:mode><GPR:mode>2_mips16\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n         (zero_extend:GPR (match_operand:SHORT 1 \"memory_operand\" \"m\")))]\n   \"TARGET_MIPS16\"\n   \"l<SHORT:size>u\\t%0,%1\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"move_type\" \"load\")\n    (set_attr \"mode\" \"<GPR:MODE>\")])\n \n (define_expand \"zero_extendqihi2\"\n@@ -2740,15 +2841,15 @@\n   \"@\n    andi\\t%0,%1,0x00ff\n    lbu\\t%0,%1\"\n-  [(set_attr \"type\" \"logical,load\")\n+  [(set_attr \"move_type\" \"andi,load\")\n    (set_attr \"mode\" \"HI\")])\n \n (define_insn \"*zero_extendqihi2_mips16\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n         (zero_extend:HI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n   \"TARGET_MIPS16\"\n   \"lbu\\t%0,%1\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"move_type\" \"load\")\n    (set_attr \"mode\" \"HI\")])\n \f\n ;;\n@@ -2782,7 +2883,7 @@\n   emit_note (NOTE_INSN_DELETED);\n   DONE;\n }\n-  [(set_attr \"type\" \"arith,load\")\n+  [(set_attr \"move_type\" \"move,load\")\n    (set_attr \"mode\" \"DI\")])\n \n (define_expand \"extend<SHORT:mode><GPR:mode>2\"\n@@ -2797,7 +2898,7 @@\n   \"@\n    se<SHORT:size>\\t%0\n    l<SHORT:size>\\t%0,%1\"\n-  [(set_attr \"type\" \"signext,load\")\n+  [(set_attr \"move_type\" \"signext,load\")\n    (set_attr \"mode\" \"<GPR:MODE>\")])\n \n (define_insn_and_split \"*extend<SHORT:mode><GPR:mode>2\"\n@@ -2816,9 +2917,8 @@\n   operands[2] = GEN_INT (GET_MODE_BITSIZE (<GPR:MODE>mode)\n \t\t\t - GET_MODE_BITSIZE (<SHORT:MODE>mode));\n }\n-  [(set_attr \"type\" \"arith,load\")\n-   (set_attr \"mode\" \"<GPR:MODE>\")\n-   (set_attr \"length\" \"8,*\")])\n+  [(set_attr \"move_type\" \"shift_shift,load\")\n+   (set_attr \"mode\" \"<GPR:MODE>\")])\n \n (define_insn \"*extend<SHORT:mode><GPR:mode>2_se<SHORT:size>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=d,d\")\n@@ -2828,7 +2928,7 @@\n   \"@\n    se<SHORT:size>\\t%0,%1\n    l<SHORT:size>\\t%0,%1\"\n-  [(set_attr \"type\" \"signext,load\")\n+  [(set_attr \"move_type\" \"signext,load\")\n    (set_attr \"mode\" \"<GPR:MODE>\")])\n \n (define_expand \"extendqihi2\"\n@@ -2843,7 +2943,7 @@\n   \"@\n    seb\\t%0\n    lb\\t%0,%1\"\n-  [(set_attr \"type\" \"signext,load\")\n+  [(set_attr \"move_type\" \"signext,load\")\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn_and_split \"*extendqihi2\"\n@@ -2863,9 +2963,8 @@\n   operands[2] = GEN_INT (GET_MODE_BITSIZE (SImode)\n \t\t\t - GET_MODE_BITSIZE (QImode));\n }\n-  [(set_attr \"type\" \"multi,load\")\n-   (set_attr \"mode\" \"SI\")\n-   (set_attr \"length\" \"8,*\")])\n+  [(set_attr \"move_type\" \"shift_shift,load\")\n+   (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*extendqihi2_seb\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=d,d\")\n@@ -2875,7 +2974,7 @@\n   \"@\n    seb\\t%0,%1\n    lb\\t%0,%1\"\n-  [(set_attr \"type\" \"signext,load\")\n+  [(set_attr \"move_type\" \"signext,load\")\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"extendsfdf2\"\n@@ -2913,8 +3012,7 @@\n   \"trunc.w.d %0,%1\"\n   [(set_attr \"type\"\t\"fcvt\")\n    (set_attr \"mode\"\t\"DF\")\n-   (set_attr \"cnv_mode\"\t\"D2I\")\n-   (set_attr \"length\"\t\"4\")])\n+   (set_attr \"cnv_mode\"\t\"D2I\")])\n \n (define_insn \"fix_truncdfsi2_macro\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n@@ -2951,8 +3049,7 @@\n   \"trunc.w.s %0,%1\"\n   [(set_attr \"type\"\t\"fcvt\")\n    (set_attr \"mode\"\t\"SF\")\n-   (set_attr \"cnv_mode\"\t\"S2I\")\n-   (set_attr \"length\"\t\"4\")])\n+   (set_attr \"cnv_mode\"\t\"S2I\")])\n \n (define_insn \"fix_truncsfsi2_macro\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n@@ -2978,8 +3075,7 @@\n   \"trunc.l.d %0,%1\"\n   [(set_attr \"type\"\t\"fcvt\")\n    (set_attr \"mode\"\t\"DF\")\n-   (set_attr \"cnv_mode\"\t\"D2I\")\n-   (set_attr \"length\"\t\"4\")])\n+   (set_attr \"cnv_mode\"\t\"D2I\")])\n \n \n (define_insn \"fix_truncsfdi2\"\n@@ -2989,8 +3085,7 @@\n   \"trunc.l.s %0,%1\"\n   [(set_attr \"type\"\t\"fcvt\")\n    (set_attr \"mode\"\t\"SF\")\n-   (set_attr \"cnv_mode\"\t\"S2I\")\n-   (set_attr \"length\"\t\"4\")])\n+   (set_attr \"cnv_mode\"\t\"S2I\")])\n \n \n (define_insn \"floatsidf2\"\n@@ -3000,8 +3095,7 @@\n   \"cvt.d.w\\t%0,%1\"\n   [(set_attr \"type\"\t\"fcvt\")\n    (set_attr \"mode\"\t\"DF\")\n-   (set_attr \"cnv_mode\"\t\"I2D\")   \n-   (set_attr \"length\"\t\"4\")])\n+   (set_attr \"cnv_mode\"\t\"I2D\")])\n \n \n (define_insn \"floatdidf2\"\n@@ -3011,8 +3105,7 @@\n   \"cvt.d.l\\t%0,%1\"\n   [(set_attr \"type\"\t\"fcvt\")\n    (set_attr \"mode\"\t\"DF\")\n-   (set_attr \"cnv_mode\"\t\"I2D\")   \n-   (set_attr \"length\"\t\"4\")])\n+   (set_attr \"cnv_mode\"\t\"I2D\")])\n \n \n (define_insn \"floatsisf2\"\n@@ -3022,8 +3115,7 @@\n   \"cvt.s.w\\t%0,%1\"\n   [(set_attr \"type\"\t\"fcvt\")\n    (set_attr \"mode\"\t\"SF\")\n-   (set_attr \"cnv_mode\"\t\"I2S\")   \n-   (set_attr \"length\"\t\"4\")])\n+   (set_attr \"cnv_mode\"\t\"I2S\")])\n \n \n (define_insn \"floatdisf2\"\n@@ -3033,8 +3125,7 @@\n   \"cvt.s.l\\t%0,%1\"\n   [(set_attr \"type\"\t\"fcvt\")\n    (set_attr \"mode\"\t\"SF\")\n-   (set_attr \"cnv_mode\"\t\"I2S\")   \n-   (set_attr \"length\"\t\"4\")])\n+   (set_attr \"cnv_mode\"\t\"I2S\")])\n \n \n (define_expand \"fixuns_truncdfsi2\"\n@@ -3325,7 +3416,7 @@\n \t\t    UNSPEC_LOAD_LEFT))]\n   \"!TARGET_MIPS16 && mips_mem_fits_mode_p (<MODE>mode, operands[1])\"\n   \"<load>l\\t%0,%2\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"move_type\" \"load\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"mov_<load>r\"\n@@ -3336,7 +3427,7 @@\n \t\t    UNSPEC_LOAD_RIGHT))]\n   \"!TARGET_MIPS16 && mips_mem_fits_mode_p (<MODE>mode, operands[1])\"\n   \"<load>r\\t%0,%2\"\n-  [(set_attr \"type\" \"load\")\n+  [(set_attr \"move_type\" \"load\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"mov_<store>l\"\n@@ -3346,7 +3437,7 @@\n \t\t    UNSPEC_STORE_LEFT))]\n   \"!TARGET_MIPS16 && mips_mem_fits_mode_p (<MODE>mode, operands[0])\"\n   \"<store>l\\t%z1,%2\"\n-  [(set_attr \"type\" \"store\")\n+  [(set_attr \"move_type\" \"store\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"mov_<store>r\"\n@@ -3357,7 +3448,7 @@\n \t\t    UNSPEC_STORE_RIGHT))]\n   \"!TARGET_MIPS16 && mips_mem_fits_mode_p (<MODE>mode, operands[0])\"\n   \"<store>r\\t%z1,%2\"\n-  [(set_attr \"type\" \"store\")\n+  [(set_attr \"move_type\" \"store\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n ;; An instruction to calculate the high part of a 64-bit SYMBOL_ABSOLUTE.\n@@ -3563,7 +3654,7 @@\n   \"<d>addiu\\t%0,%R2\"\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"mode\" \"<MODE>\")\n-   (set_attr \"length\" \"8\")])\n+   (set_attr \"extended_mips16\" \"yes\")])\n \n ;; Allow combine to split complex const_int load sequences, using operand 2\n ;; to store the intermediate results.  See move_operand for details.\n@@ -3614,30 +3705,18 @@\n \t(reg:GPR 31))]\n   \"TARGET_MIPS16\"\n   \"<store>\\t$31,%0\"\n-  [(set_attr \"type\" \"store\")\n+  [(set_attr \"move_type\" \"store\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*movdi_32bit\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,m,*a,*d,*B*C*D,*B*C*D,*d,*m\")\n-\t(match_operand:DI 1 \"move_operand\" \"d,i,m,d,*J*d,*a,*d,*m,*B*C*D,*B*C*D\"))]\n-  \"!TARGET_64BIT && !TARGET_FLOAT64 && !TARGET_MIPS16\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,m,*a,*d,*f,*f,*d,*m,*B*C*D,*B*C*D,*d,*m\")\n+\t(match_operand:DI 1 \"move_operand\" \"d,i,m,d,*J*d,*a,*J*d,*m,*f,*f,*d,*m,*B*C*D,*B*C*D\"))]\n+  \"!TARGET_64BIT && !TARGET_MIPS16\n    && (register_operand (operands[0], DImode)\n        || reg_or_0_operand (operands[1], DImode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"multi,multi,load,store,multi,multi,mtc,load,mfc,store\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"   \"8,16,*,*,8,8,8,*,8,*\")])\n-\n-(define_insn \"*movdi_gp32_fp64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,m,*a,*d,*f,*f,*d,*m\")\n-\t(match_operand:DI 1 \"move_operand\" \"d,i,m,d,*J*d,*a,*J*d,*m,*f,*f\"))]\n-  \"!TARGET_64BIT && TARGET_FLOAT64 && !TARGET_MIPS16\n-   && (register_operand (operands[0], DImode)\n-       || reg_or_0_operand (operands[1], DImode))\"\n-  { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"multi,multi,load,store,multi,multi,mtc,fpload,mfc,fpstore\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"   \"8,16,*,*,8,8,8,*,8,*\")])\n+  [(set_attr \"move_type\" \"move,const,load,store,mthilo,mfhilo,mtc,fpload,mfc,fpstore,mtc,fpload,mfc,fpstore\")\n+   (set_attr \"mode\" \"DI\")])\n \n (define_insn \"*movdi_32bit_mips16\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,m,*d\")\n@@ -3646,9 +3725,8 @@\n    && (register_operand (operands[0], DImode)\n        || register_operand (operands[1], DImode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"multi,multi,multi,multi,multi,load,store,multi\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"8,8,8,8,12,*,*,8\")])\n+  [(set_attr \"move_type\" \"move,move,move,const,constN,load,store,mfhilo\")\n+   (set_attr \"mode\" \"DI\")])\n \n (define_insn \"*movdi_64bit\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,e,d,m,*f,*f,*d,*m,*a,*d,*B*C*D,*B*C*D,*d,*m\")\n@@ -3657,35 +3735,18 @@\n    && (register_operand (operands[0], DImode)\n        || reg_or_0_operand (operands[1], DImode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"move,const,const,load,store,mtc,fpload,mfc,fpstore,mthilo,mfhilo,mtc,load,mfc,store\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"4,*,*,*,*,4,*,4,*,4,4,8,*,8,*\")])\n+  [(set_attr \"move_type\" \"move,const,const,load,store,mtc,fpload,mfc,fpstore,mthilo,mfhilo,mtc,fpload,mfc,fpstore\")\n+   (set_attr \"mode\" \"DI\")])\n \n (define_insn \"*movdi_64bit_mips16\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,d,d,m,*d\")\n-\t(match_operand:DI 1 \"move_operand\" \"d,d,y,K,N,kf,U,m,d,*a\"))]\n+\t(match_operand:DI 1 \"move_operand\" \"d,d,y,K,N,U,kf,m,d,*a\"))]\n   \"TARGET_64BIT && TARGET_MIPS16\n    && (register_operand (operands[0], DImode)\n        || register_operand (operands[1], DImode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"move,move,move,arith,arith,load,const,load,store,mfhilo\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr_alternative \"length\"\n-\t\t[(const_int 4)\n-\t\t (const_int 4)\n-\t\t (const_int 4)\n-\t\t (if_then_else (match_operand:VOID 1 \"m16_uimm8_1\")\n-\t\t\t       (const_int 4)\n-\t\t\t       (const_int 8))\n-\t\t (if_then_else (match_operand:VOID 1 \"m16_nuimm8_1\")\n-\t\t\t       (const_int 8)\n-\t\t\t       (const_int 12))\n-\t\t (const_int 8)\n-\t\t (const_string \"*\")\n-\t\t (const_string \"*\")\n-\t\t (const_string \"*\")\n-\t\t (const_int 4)])])\n-\n+  [(set_attr \"move_type\" \"move,move,move,const,constN,const,loadpool,load,store,mfhilo\")\n+   (set_attr \"mode\" \"DI\")])\n \n ;; On the mips16, we can split ld $r,N($r) into an add and a load,\n ;; when the original load is a 4 byte instruction but the add and the\n@@ -3752,34 +3813,18 @@\n    && (register_operand (operands[0], SImode)\n        || reg_or_0_operand (operands[1], SImode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"move,const,const,load,store,mtc,fpload,mfc,fpstore,mfc,mtc,mthilo,mfhilo,mtc,load,mfc,store\")\n-   (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"4,*,*,*,*,4,*,4,*,4,4,4,4,4,*,4,*\")])\n+  [(set_attr \"move_type\" \"move,const,const,load,store,mtc,fpload,mfc,fpstore,mfc,mtc,mthilo,mfhilo,mtc,fpload,mfc,fpstore\")\n+   (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*movsi_mips16\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,d,d,m,*d\")\n-\t(match_operand:SI 1 \"move_operand\" \"d,d,y,K,N,kf,U,m,d,*a\"))]\n+\t(match_operand:SI 1 \"move_operand\" \"d,d,y,K,N,U,kf,m,d,*a\"))]\n   \"TARGET_MIPS16\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"move,move,move,arith,arith,load,const,load,store,mfhilo\")\n-   (set_attr \"mode\"\t\"SI\")\n-   (set_attr_alternative \"length\"\n-\t\t[(const_int 4)\n-\t\t (const_int 4)\n-\t\t (const_int 4)\n-\t\t (if_then_else (match_operand:VOID 1 \"m16_uimm8_1\")\n-\t\t\t       (const_int 4)\n-\t\t\t       (const_int 8))\n-\t\t (if_then_else (match_operand:VOID 1 \"m16_nuimm8_1\")\n-\t\t\t       (const_int 8)\n-\t\t\t       (const_int 12))\n-\t\t (const_int 8)\n-\t\t (const_string \"*\")\n-\t\t (const_string \"*\")\n-\t\t (const_string \"*\")\n-\t\t (const_int 4)])])\n+  [(set_attr \"move_type\" \"move,move,move,const,constN,const,loadpool,load,store,mfhilo\")\n+   (set_attr \"mode\" \"SI\")])\n \n ;; On the mips16, we can split lw $r,N($r) into an add and a load,\n ;; when the original load is a 4 byte instruction but the add and the\n@@ -3849,9 +3894,8 @@\n \t(match_operand:CC 1 \"general_operand\" \"z,*d,*m,*d,*f,*d,*f,*m,*f\"))]\n   \"ISA_HAS_8CC && TARGET_HARD_FLOAT\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"multi,move,load,store,mfc,mtc,fmove,fpload,fpstore\")\n-   (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"8,4,*,*,4,4,4,*,*\")])\n+  [(set_attr \"move_type\" \"lui_movf,move,load,store,mfc,mtc,fmove,fpload,fpstore\")\n+   (set_attr \"mode\" \"SI\")])\n \n ;; Reload condition code registers.  reload_incc and reload_outcc\n ;; both handle moves from arbitrary operands into condition code\n@@ -3930,8 +3974,7 @@\n   \"ISA_HAS_LWXS\"\n   \"lwxs\\t%0,%1(%2)\"\n   [(set_attr \"type\"\t\"load\")\n-   (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"   \"4\")])\n+   (set_attr \"mode\"\t\"SI\")])\n \n ;; 16-bit Integer moves\n \n@@ -3956,9 +3999,8 @@\n    && (register_operand (operands[0], HImode)\n        || reg_or_0_operand (operands[1], HImode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"move,arith,load,store,mthilo,mfhilo\")\n-   (set_attr \"mode\"\t\"HI\")\n-   (set_attr \"length\"\t\"4,4,*,*,4,4\")])\n+  [(set_attr \"move_type\" \"move,const,load,store,mthilo,mfhilo\")\n+   (set_attr \"mode\" \"HI\")])\n \n (define_insn \"*movhi_mips16\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,m,*d\")\n@@ -3967,22 +4009,8 @@\n    && (register_operand (operands[0], HImode)\n        || register_operand (operands[1], HImode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"move,move,move,arith,arith,load,store,mfhilo\")\n-   (set_attr \"mode\"\t\"HI\")\n-   (set_attr_alternative \"length\"\n-\t\t[(const_int 4)\n-\t\t (const_int 4)\n-\t\t (const_int 4)\n-\t\t (if_then_else (match_operand:VOID 1 \"m16_uimm8_1\")\n-\t\t\t       (const_int 4)\n-\t\t\t       (const_int 8))\n-\t\t (if_then_else (match_operand:VOID 1 \"m16_nuimm8_1\")\n-\t\t\t       (const_int 8)\n-\t\t\t       (const_int 12))\n-\t\t (const_string \"*\")\n-\t\t (const_string \"*\")\n-\t\t (const_string \"*\")])])\n-\n+  [(set_attr \"move_type\" \"move,move,move,const,constN,load,store,mfhilo\")\n+   (set_attr \"mode\" \"HI\")])\n \n ;; On the mips16, we can split lh $r,N($r) into an add and a load,\n ;; when the original load is a 4 byte instruction but the add and the\n@@ -4046,9 +4074,8 @@\n    && (register_operand (operands[0], QImode)\n        || reg_or_0_operand (operands[1], QImode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"move,arith,load,store,mthilo,mfhilo\")\n-   (set_attr \"mode\"\t\"QI\")\n-   (set_attr \"length\"\t\"4,4,*,*,4,4\")])\n+  [(set_attr \"move_type\" \"move,const,load,store,mthilo,mfhilo\")\n+   (set_attr \"mode\" \"QI\")])\n \n (define_insn \"*movqi_mips16\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,m,*d\")\n@@ -4057,9 +4084,8 @@\n    && (register_operand (operands[0], QImode)\n        || register_operand (operands[1], QImode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"move,move,move,arith,arith,load,store,mfhilo\")\n-   (set_attr \"mode\"\t\"QI\")\n-   (set_attr \"length\"\t\"4,4,4,4,8,*,*,4\")])\n+  [(set_attr \"move_type\" \"move,move,move,const,constN,load,store,mfhilo\")\n+   (set_attr \"mode\" \"QI\")])\n \n ;; On the mips16, we can split lb $r,N($r) into an add and a load,\n ;; when the original load is a 4 byte instruction but the add and the\n@@ -4106,9 +4132,8 @@\n    && (register_operand (operands[0], SFmode)\n        || reg_or_0_operand (operands[1], SFmode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"fmove,mtc,fpload,fpstore,store,mtc,mfc,move,load,store\")\n-   (set_attr \"mode\"\t\"SF\")\n-   (set_attr \"length\"\t\"4,4,*,*,*,4,4,4,*,*\")])\n+  [(set_attr \"move_type\" \"fmove,mtc,fpload,fpstore,store,mtc,mfc,move,load,store\")\n+   (set_attr \"mode\" \"SF\")])\n \n (define_insn \"*movsf_softfloat\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=d,d,m\")\n@@ -4117,9 +4142,8 @@\n    && (register_operand (operands[0], SFmode)\n        || reg_or_0_operand (operands[1], SFmode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"move,load,store\")\n-   (set_attr \"mode\"\t\"SF\")\n-   (set_attr \"length\"\t\"4,*,*\")])\n+  [(set_attr \"move_type\" \"move,load,store\")\n+   (set_attr \"mode\" \"SF\")])\n \n (define_insn \"*movsf_mips16\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=d,y,d,d,m\")\n@@ -4128,10 +4152,8 @@\n    && (register_operand (operands[0], SFmode)\n        || register_operand (operands[1], SFmode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"move,move,move,load,store\")\n-   (set_attr \"mode\"\t\"SF\")\n-   (set_attr \"length\"\t\"4,4,4,*,*\")])\n-\n+  [(set_attr \"move_type\" \"move,move,move,load,store\")\n+   (set_attr \"mode\" \"SF\")])\n \n ;; 64-bit floating point moves\n \n@@ -4144,39 +4166,25 @@\n     DONE;\n })\n \n-(define_insn \"*movdf_hardfloat_64bit\"\n+(define_insn \"*movdf_hardfloat\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,f,f,m,m,*f,*d,*d,*d,*m\")\n \t(match_operand:DF 1 \"move_operand\" \"f,G,m,f,G,*d,*f,*d*G,*m,*d\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_64BIT\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n    && (register_operand (operands[0], DFmode)\n        || reg_or_0_operand (operands[1], DFmode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"fmove,mtc,fpload,fpstore,store,mtc,mfc,move,load,store\")\n-   (set_attr \"mode\"\t\"DF\")\n-   (set_attr \"length\"\t\"4,4,*,*,*,4,4,4,*,*\")])\n-\n-;; This pattern applies to both !TARGET_FLOAT64 and TARGET_FLOAT64.\n-(define_insn \"*movdf_hardfloat_32bit\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,f,f,m,m,*f,*d,*d,*d,*m\")\n-\t(match_operand:DF 1 \"move_operand\" \"f,G,m,f,G,*d,*f,*d*G,*m,*d\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && !TARGET_64BIT\n-   && (register_operand (operands[0], DFmode)\n-       || reg_or_0_operand (operands[1], DFmode))\"\n-  { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"fmove,mtc,fpload,fpstore,store,mtc,mfc,move,load,store\")\n-   (set_attr \"mode\"\t\"DF\")\n-   (set_attr \"length\"\t\"4,8,*,*,*,8,8,8,*,*\")])\n+  [(set_attr \"move_type\" \"fmove,mtc,fpload,fpstore,store,mtc,mfc,move,load,store\")\n+   (set_attr \"mode\" \"DF\")])\n \n (define_insn \"*movdf_softfloat\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=d,d,m,d,f,f\")\n-\t(match_operand:DF 1 \"move_operand\" \"dG,m,dG,f,d,f\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=d,d,m\")\n+\t(match_operand:DF 1 \"move_operand\" \"dG,m,dG\"))]\n   \"(TARGET_SOFT_FLOAT || TARGET_SINGLE_FLOAT) && !TARGET_MIPS16\n    && (register_operand (operands[0], DFmode)\n        || reg_or_0_operand (operands[1], DFmode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"multi,load,store,mfc,mtc,fmove\")\n-   (set_attr \"mode\"\t\"DF\")\n-   (set_attr \"length\"\t\"8,*,*,4,4,4\")])\n+  [(set_attr \"move_type\" \"move,load,store\")\n+   (set_attr \"mode\" \"DF\")])\n \n (define_insn \"*movdf_mips16\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=d,y,d,d,m\")\n@@ -4185,9 +4193,8 @@\n    && (register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"multi,multi,multi,load,store\")\n-   (set_attr \"mode\"\t\"DF\")\n-   (set_attr \"length\"\t\"8,8,8,*,*\")])\n+  [(set_attr \"move_type\" \"move,move,move,load,store\")\n+   (set_attr \"mode\" \"DF\")])\n \n ;; 128-bit integer moves\n \n@@ -4201,15 +4208,15 @@\n })\n \n (define_insn \"*movti\"\n-  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=d,d,m,*a,*d\")\n-\t(match_operand:TI 1 \"move_operand\" \"di,m,dJ,*d*J,*a\"))]\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=d,d,d,m,*a,*d\")\n+\t(match_operand:TI 1 \"move_operand\" \"d,i,m,dJ,*d*J,*a\"))]\n   \"TARGET_64BIT\n    && !TARGET_MIPS16\n    && (register_operand (operands[0], TImode)\n        || reg_or_0_operand (operands[1], TImode))\"\n   \"#\"\n-  [(set_attr \"type\" \"multi,load,store,multi,multi\")\n-   (set_attr \"length\" \"8,*,*,8,8\")])\n+  [(set_attr \"move_type\" \"move,const,load,store,mthilo,mfhilo\")\n+   (set_attr \"mode\" \"TI\")])\n \n (define_insn \"*movti_mips16\"\n   [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,m,*d\")\n@@ -4219,8 +4226,8 @@\n    && (register_operand (operands[0], TImode)\n        || register_operand (operands[1], TImode))\"\n   \"#\"\n-  [(set_attr \"type\" \"multi,multi,multi,multi,multi,load,store,multi\")\n-   (set_attr \"length\" \"8,8,8,12,16,*,*,8\")])\n+  [(set_attr \"move_type\" \"move,move,move,const,constN,load,store,mfhilo\")\n+   (set_attr \"mode\" \"TI\")])\n \n ;; 128-bit floating point moves\n \n@@ -4242,8 +4249,8 @@\n    && (register_operand (operands[0], TFmode)\n        || reg_or_0_operand (operands[1], TFmode))\"\n   \"#\"\n-  [(set_attr \"type\" \"multi,load,store,multi,multi,fpload,fpstore\")\n-   (set_attr \"length\" \"8,*,*,8,8,*,*\")])\n+  [(set_attr \"move_type\" \"move,load,store,mtc,mfc,fpload,fpstore\")\n+   (set_attr \"mode\" \"TF\")])\n \n (define_insn \"*movtf_mips16\"\n   [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=d,y,d,d,m\")\n@@ -4253,8 +4260,8 @@\n    && (register_operand (operands[0], TFmode)\n        || register_operand (operands[1], TFmode))\"\n   \"#\"\n-  [(set_attr \"type\" \"multi,multi,multi,load,store\")\n-   (set_attr \"length\" \"8,8,8,*,*\")])\n+  [(set_attr \"move_type\" \"move,move,move,load,store\")\n+   (set_attr \"mode\" \"TF\")])\n \n (define_split\n   [(set (match_operand:MOVE64 0 \"nonimmediate_operand\")\n@@ -4303,31 +4310,16 @@\n     DONE;\n })\n \n-(define_insn \"movv2sf_hardfloat_64bit\"\n-  [(set (match_operand:V2SF 0 \"nonimmediate_operand\" \"=f,f,f,m,m,*f,*d,*d,*d,*m\")\n-\t(match_operand:V2SF 1 \"move_operand\" \"f,YG,m,f,YG,*d,*f,*d*YG,*m,*d\"))]\n-  \"TARGET_HARD_FLOAT\n-   && TARGET_PAIRED_SINGLE_FLOAT\n-   && TARGET_64BIT\n-   && (register_operand (operands[0], V2SFmode)\n-       || reg_or_0_operand (operands[1], V2SFmode))\"\n-  { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\" \"fmove,mtc,fpload,fpstore,store,mtc,mfc,move,load,store\")\n-   (set_attr \"mode\" \"SF\")\n-   (set_attr \"length\" \"4,4,*,*,*,4,4,4,*,*\")])\n-\n-(define_insn \"movv2sf_hardfloat_32bit\"\n+(define_insn \"*movv2sf\"\n   [(set (match_operand:V2SF 0 \"nonimmediate_operand\" \"=f,f,f,m,m,*f,*d,*d,*d,*m\")\n \t(match_operand:V2SF 1 \"move_operand\" \"f,YG,m,f,YG,*d,*f,*d*YG,*m,*d\"))]\n   \"TARGET_HARD_FLOAT\n    && TARGET_PAIRED_SINGLE_FLOAT\n-   && !TARGET_64BIT\n    && (register_operand (operands[0], V2SFmode)\n        || reg_or_0_operand (operands[1], V2SFmode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\" \"fmove,mtc,fpload,fpstore,store,mtc,mfc,move,load,store\")\n-   (set_attr \"mode\" \"SF\")\n-   (set_attr \"length\" \"4,8,*,*,*,8,8,8,*,*\")])\n+  [(set_attr \"move_type\" \"fmove,mtc,fpload,fpstore,store,mtc,mfc,move,load,store\")\n+   (set_attr \"mode\" \"DF\")])\n \n ;; Extract the high part of a HI/LO value.  See mips_hard_regno_mode_ok_p\n ;; for the reason why we can't just use (reg:GPR HI_REGNUM).\n@@ -4341,7 +4333,7 @@\n \t\t    UNSPEC_MFHI))]\n   \"\"\n   { return ISA_HAS_MACCHI ? \"<GPR:d>macchi\\t%0,%.,%.\" : \"mfhi\\t%0\"; }\n-  [(set_attr \"type\" \"mfhilo\")\n+  [(set_attr \"move_type\" \"mfhilo\")\n    (set_attr \"mode\" \"<GPR:MODE>\")])\n \n ;; Set the high part of a HI/LO value, given that the low part has\n@@ -4354,7 +4346,7 @@\n \t\t     UNSPEC_MTHI))]\n   \"\"\n   \"mthi\\t%z1\"\n-  [(set_attr \"type\" \"mthilo\")\n+  [(set_attr \"move_type\" \"mthilo\")\n    (set_attr \"mode\" \"SI\")])\n \n ;; Emit a doubleword move in which exactly one of the operands is\n@@ -4402,7 +4394,7 @@\n   operands[0] = mips_subword (operands[0], 0);\n   return mips_output_move (operands[0], operands[1]);\n }\n-  [(set_attr \"type\" \"mtc,fpload\")\n+  [(set_attr \"move_type\" \"mtc,fpload\")\n    (set_attr \"mode\" \"<HALFMODE>\")])\n \n ;; Load the high word of operand 0 from operand 1, preserving the value\n@@ -4417,7 +4409,7 @@\n   operands[0] = mips_subword (operands[0], 1);\n   return mips_output_move (operands[0], operands[1]);\n }\n-  [(set_attr \"type\" \"mtc,fpload\")\n+  [(set_attr \"move_type\" \"mtc,fpload\")\n    (set_attr \"mode\" \"<HALFMODE>\")])\n \n ;; Store one word of operand 1 in operand 0.  Operand 2 is 1 to store the\n@@ -4432,7 +4424,7 @@\n   operands[1] = mips_subword (operands[1], INTVAL (operands[2]));\n   return mips_output_move (operands[0], operands[1]);\n }\n-  [(set_attr \"type\" \"mfc,fpstore\")\n+  [(set_attr \"move_type\" \"mfc,fpstore\")\n    (set_attr \"mode\" \"<HALFMODE>\")])\n \n ;; Move operand 1 to the high word of operand 0 using mthc1, preserving the\n@@ -4444,7 +4436,7 @@\n \t\t       UNSPEC_MTHC1))]\n   \"TARGET_HARD_FLOAT && ISA_HAS_MXHC1\"\n   \"mthc1\\t%z1,%0\"\n-  [(set_attr \"type\" \"mtc\")\n+  [(set_attr \"move_type\" \"mtc\")\n    (set_attr \"mode\" \"<HALFMODE>\")])\n \n ;; Move high word of operand 1 to operand 0 using mfhc1.\n@@ -4454,7 +4446,7 @@\n \t\t\t    UNSPEC_MFHC1))]\n   \"TARGET_HARD_FLOAT && ISA_HAS_MXHC1\"\n   \"mfhc1\\t%0,%1\"\n-  [(set_attr \"type\" \"mfc\")\n+  [(set_attr \"move_type\" \"mfc\")\n    (set_attr \"mode\" \"<HALFMODE>\")])\n \n ;; Move a constant that satisfies CONST_GP_P into operand 0.\n@@ -4505,8 +4497,7 @@\n   \"\"\n   \"\"\n   [(set_attr \"type\" \"ghost\")\n-   (set_attr \"mode\" \"none\")\n-   (set_attr \"length\" \"0\")])\n+   (set_attr \"mode\" \"none\")])\n \n ;; Initialize $gp for RTP PIC.  Operand 0 is the __GOTT_BASE__ symbol\n ;; and operand 1 is the __GOTT_INDEX__ symbol.\n@@ -5493,8 +5484,7 @@\n     }\n }\n   [(set_attr \"type\" \"branch\")\n-   (set_attr \"mode\" \"none\")\n-   (set_attr \"length\" \"8\")])\n+   (set_attr \"mode\" \"none\")])\n \n (define_expand \"b<code>\"\n   [(set (pc)\n@@ -5746,9 +5736,8 @@\n \t(label_ref (match_operand 0 \"\" \"\")))]\n   \"TARGET_MIPS16\"\n   \"b\\t%l0\"\n-  [(set_attr \"type\"\t\"branch\")\n-   (set_attr \"mode\"\t\"none\")\n-   (set_attr \"length\"\t\"8\")])\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"mode\" \"none\")])\n \n (define_expand \"indirect_jump\"\n   [(set (pc) (match_operand 0 \"register_operand\"))]\n@@ -5883,8 +5872,7 @@\n   \"\"\n   \"\"\n   [(set_attr \"type\" \"ghost\")\n-   (set_attr \"mode\" \"none\")\n-   (set_attr \"length\" \"0\")])\n+   (set_attr \"mode\" \"none\")])\n \n (define_expand \"epilogue\"\n   [(const_int 2)]\n@@ -6070,16 +6058,14 @@\n \t(unspec_volatile:SI [(const_int 0)] UNSPEC_SET_GOT_VERSION))]\n   \"TARGET_USE_GOT\"\n   \"\"\n-  [(set_attr \"length\" \"0\")\n-   (set_attr \"type\" \"ghost\")])\n+  [(set_attr \"type\" \"ghost\")])\n \n (define_insn \"update_got_version\"\n   [(set (reg:SI GOT_VERSION_REGNUM)\n \t(unspec:SI [(reg:SI GOT_VERSION_REGNUM)] UNSPEC_UPDATE_GOT_VERSION))]\n   \"TARGET_USE_GOT\"\n   \"\"\n-  [(set_attr \"length\" \"0\")\n-   (set_attr \"type\" \"ghost\")])\n+  [(set_attr \"type\" \"ghost\")])\n \n ;; Sibling calls.  All these patterns use jump instructions.\n \n@@ -6205,8 +6191,7 @@\n     mips_restore_gp ();\n   DONE;\n }\n-  [(set_attr \"jal\" \"indirect,direct\")\n-   (set_attr \"extended_mips16\" \"no,yes\")])\n+  [(set_attr \"jal\" \"indirect,direct\")])\n \n ;; A pattern for calls that must be made directly.  It is used for\n ;; MIPS16 calls that the linker may need to redirect to a hard-float\n@@ -6258,8 +6243,7 @@\n     mips_restore_gp ();\n   DONE;\n }\n-  [(set_attr \"jal\" \"indirect,direct\")\n-   (set_attr \"extended_mips16\" \"no,yes\")])\n+  [(set_attr \"jal\" \"indirect,direct\")])\n \n (define_insn \"call_value_split\"\n   [(set (match_operand 0 \"register_operand\" \"\")\n@@ -6301,8 +6285,7 @@\n     mips_restore_gp ();\n   DONE;\n }\n-  [(set_attr \"jal\" \"indirect,direct\")\n-   (set_attr \"extended_mips16\" \"no,yes\")])\n+  [(set_attr \"jal\" \"indirect,direct\")])\n \n (define_insn \"call_value_multiple_split\"\n   [(set (match_operand 0 \"register_operand\" \"\")"}]}