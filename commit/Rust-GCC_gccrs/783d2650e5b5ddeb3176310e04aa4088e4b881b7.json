{"sha": "783d2650e5b5ddeb3176310e04aa4088e4b881b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzgzZDI2NTBlNWI1ZGRlYjMxNzYzMTBlMDRhYTQwODhlNGI4ODFiNw==", "commit": {"author": {"name": "J. D. Johnston", "email": "jjohnst@us.ibm.com", "date": "2005-01-14T14:27:42Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2005-01-14T14:27:42Z"}, "message": "tpf-unwind.h (s390_fallback_frame_state): Correct end-of-stack check.\n\n2005-01-14  J. D. Johnston  <jjohnst@us.ibm.com>\n\n\t* config/s390/tpf-unwind.h (s390_fallback_frame_state): Correct\n\tend-of-stack check.\n\t(__tpf_eh_return): Copy TPF private stack area from the module\n\tboundary stack frame.  Add check for when module addresses are\n\tequal, but no stub address is found.\n\nFrom-SVN: r93643", "tree": {"sha": "61ecb3ca4252d06c4a059d3c7d9610b9162fb1bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61ecb3ca4252d06c4a059d3c7d9610b9162fb1bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/783d2650e5b5ddeb3176310e04aa4088e4b881b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/783d2650e5b5ddeb3176310e04aa4088e4b881b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/783d2650e5b5ddeb3176310e04aa4088e4b881b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/783d2650e5b5ddeb3176310e04aa4088e4b881b7/comments", "author": {"login": "jjohnst-us", "id": 28395979, "node_id": "MDQ6VXNlcjI4Mzk1OTc5", "avatar_url": "https://avatars.githubusercontent.com/u/28395979?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jjohnst-us", "html_url": "https://github.com/jjohnst-us", "followers_url": "https://api.github.com/users/jjohnst-us/followers", "following_url": "https://api.github.com/users/jjohnst-us/following{/other_user}", "gists_url": "https://api.github.com/users/jjohnst-us/gists{/gist_id}", "starred_url": "https://api.github.com/users/jjohnst-us/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jjohnst-us/subscriptions", "organizations_url": "https://api.github.com/users/jjohnst-us/orgs", "repos_url": "https://api.github.com/users/jjohnst-us/repos", "events_url": "https://api.github.com/users/jjohnst-us/events{/privacy}", "received_events_url": "https://api.github.com/users/jjohnst-us/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b12a00f173122aef3c77d763e75aeeb872ec4852", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b12a00f173122aef3c77d763e75aeeb872ec4852", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b12a00f173122aef3c77d763e75aeeb872ec4852"}], "stats": {"total": 204, "additions": 108, "deletions": 96}, "files": [{"sha": "5626607baf02f52f360b5a26cbae707ddd57f104", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/783d2650e5b5ddeb3176310e04aa4088e4b881b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/783d2650e5b5ddeb3176310e04aa4088e4b881b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=783d2650e5b5ddeb3176310e04aa4088e4b881b7", "patch": "@@ -1,3 +1,11 @@\n+2005-01-14  J. D. Johnston  <jjohnst@us.ibm.com>\n+\n+\t* config/s390/tpf-unwind.h (s390_fallback_frame_state): Correct\n+\tend-of-stack check.\n+\t(__tpf_eh_return): Copy TPF private stack area from the module\n+\tboundary stack frame.  Add check for when module addresses are\n+\tequal, but no stub address is found.\n+\n 2005-01-14  Richard Earnshaw  <rearnsha@arm.com>\n \n \tPR target/7525"}, {"sha": "3289df98ea75e60598feb9983cc13ddfef4320eb", "filename": "gcc/config/s390/tpf-unwind.h", "status": "modified", "additions": 100, "deletions": 96, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/783d2650e5b5ddeb3176310e04aa4088e4b881b7/gcc%2Fconfig%2Fs390%2Ftpf-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/783d2650e5b5ddeb3176310e04aa4088e4b881b7/gcc%2Fconfig%2Fs390%2Ftpf-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Ftpf-unwind.h?ref=783d2650e5b5ddeb3176310e04aa4088e4b881b7", "patch": "@@ -52,8 +52,8 @@ __isPATrange (void *addr)\n     return 0;\n }\n \n-/* TPF stack placeholder offset.  */\n-#define TPF_LOC_DIFF_OFFSET 168\n+/* TPF return address offset from start of stack frame.  */\n+#define TPFRA_OFFSET 168\n \n /* Exceptions macro defined for TPF so that functions without \n    dwarf frame information can be used with exceptions.  */\n@@ -67,12 +67,18 @@ s390_fallback_frame_state (struct _Unwind_Context *context,\n   unsigned long int new_cfa;\n   int i;\n \n-  if (context->cfa == NULL)\n-    return _URC_END_OF_STACK;\n+  regs = *((unsigned long int *)\n+        (((unsigned long int) context->cfa) - STACK_POINTER_OFFSET));\n \n   /* Are we going through special linkage code?  */\n   if (__isPATrange (context->ra))\n     {\n+\n+      /* Our return register isn't zero for end of stack, so\n+         check backward stackpointer to see if it is zero.  */\n+      if (regs == NULL)\n+         return _URC_END_OF_STACK;\n+\n       /* No stack frame.  */\n       fs->cfa_how = CFA_REG_OFFSET;\n       fs->cfa_reg = 15;\n@@ -88,7 +94,7 @@ s390_fallback_frame_state (struct _Unwind_Context *context,\n       /* ... except for %r14, which is stored at CFA-112\n \t and used as return address.  */\n       fs->regs.reg[14].how = REG_SAVED_OFFSET;\n-      fs->regs.reg[14].loc.offset = TPF_LOC_DIFF_OFFSET - STACK_POINTER_OFFSET;\n+      fs->regs.reg[14].loc.offset = TPFRA_OFFSET - STACK_POINTER_OFFSET;\n       fs->retaddr_column = 14;\n \n       return _URC_NO_REASON;\n@@ -136,9 +142,10 @@ s390_fallback_frame_state (struct _Unwind_Context *context,\n #define PREVIOUS_STACK_PTR() \\\n   ((unsigned long int *)(*(CURRENT_STACK_PTR())))\n \n-#define RA_OFFSET_FROM_START_OF_STACK_FRAME 112\n-#define CURRENT_STACK_PTR_OFFSET 120\n-#define TPFRA_OFFSET_FROM_START_OF_STACK_FRAME 168\n+#define RA_OFFSET 112\n+#define R15_OFFSET 120\n+#define TPFAREA_OFFSET 160\n+#define TPFAREA_SIZE STACK_POINTER_OFFSET-TPFAREA_OFFSET\n #define INVALID_RETURN 0\n \n void * __tpf_eh_return (void *target);\n@@ -148,110 +155,107 @@ __tpf_eh_return (void *target)\n {\n   Dl_info targetcodeInfo, currentcodeInfo;\n   int retval;\n-  void *current, *stackptr;\n-  unsigned long int shifter;\n+  void *current, *stackptr, *destination_frame;\n+  unsigned long int shifter, is_a_stub;\n+\n+  is_a_stub = 0;\n \n   /* Get code info for target return's address.  */\n   retval = dladdr (target, &targetcodeInfo);\n \n-  /* Get the return address of the stack frame to be replaced by\n-     the exception unwinder.  So that the __cxa_throw return is\n-     replaced by the target return.  */\n-  current = (void *) *((unsigned long int *)\n-                 ((*((unsigned long int *)*(PREVIOUS_STACK_PTR()))) \n-                             + RA_OFFSET_FROM_START_OF_STACK_FRAME));\n-\n   /* Ensure the code info is valid (for target).  */\n-  if (retval != INVALID_RETURN) \n+  if (retval != INVALID_RETURN)\n     {\n-      /* Now check to see if the current RA is a PAT\n-         stub return address.  */\n-      if ( __isPATrange(current)) \n-        {\n-          /* It was!  Then go into the TPF private stack area and fetch\n-             the real address.  */\n-          current = (void *) *((unsigned long int *) \n-                           ((unsigned long int)*((unsigned long int *)\n-                           *(PREVIOUS_STACK_PTR())) \n-                           +TPFRA_OFFSET_FROM_START_OF_STACK_FRAME));\n-        }\n \n-      /* Get code info for current return address.  */\n-      retval = dladdr (current, &currentcodeInfo);\n+      /* Get the stack pointer of the stack frame to be modified by\n+         the exception unwinder.  So that we can begin our climb\n+         there.  */\n+      stackptr = (void *) *((unsigned long int *) (*(PREVIOUS_STACK_PTR())));\n \n-      /* Ensure the code info is valid (for current frame).  */\n-      if (retval != INVALID_RETURN) \n+      /* Begin looping through stack frames.  Stop if invalid\n+         code information is retrieved or if a match between the\n+         current stack frame iteration shared object's address \n+         matches that of the target, calculated above.  */\n+      do\n         {\n-          /* Get the stack pointer of the stack frame to be replaced by\n-             the exception unwinder.  So that we can begin our climb\n-             there.  */\n-          stackptr = (void *) (*((unsigned long int *)\n-                      (*((unsigned long int *)(*(PREVIOUS_STACK_PTR()))))));\n-\n-          /* Begin looping through stack frames.  Stop if invalid\n-             code information is retrieved or if a match between the\n-             current stack frame iteration shared object's address \n-             matches that of the target, calculated above.  */\n-          while (retval != INVALID_RETURN\n-                 && targetcodeInfo.dli_fbase != currentcodeInfo.dli_fbase)\n+          /* Get return address based on our stackptr iterator.  */\n+          current = (void *) *((unsigned long int *) \n+                      (stackptr+RA_OFFSET));\n+\n+          /* Is it a Pat Stub?  */\n+          if (__isPATrange (current)) \n             {\n-              /* Get return address based on our stackptr iterator.  */\n+              /* Yes it was, get real return address \n+                 in TPF stack area.  */\n               current = (void *) *((unsigned long int *) \n-                     (stackptr+RA_OFFSET_FROM_START_OF_STACK_FRAME));\n-\n-              /* Is it a Pat Stub?  */\n-              if (__isPATrange (current)) \n-                {\n-                  /* Yes it was, get real return address \n-                     in TPF stack area.  */\n-                  current = (void *) *((unsigned long int *) \n-                         (stackptr+TPFRA_OFFSET_FROM_START_OF_STACK_FRAME));\n-                }\n-\n-              /* Get codeinfo on RA so that we can figure out\n-                 the module address.  */\n-              retval = dladdr (current, &currentcodeInfo);\n-\n-              /* Check that codeinfo for current stack frame is valid.\n-                 Then compare the module address of current stack frame\n-                 to target stack frame to determine if we have the pat\n-                 stub address we want.  */\n-              if (retval != INVALID_RETURN\n-                  && targetcodeInfo.dli_fbase == currentcodeInfo.dli_fbase)\n-                {\n-                  /* Yes!  They are in the same module.  Now store the\n-                     real target address into the TPF stack area of\n-                     the target frame we are jumping to.  */\n-                  *((unsigned long int *)(*((unsigned long int *) \n-                          (*PREVIOUS_STACK_PTR() + CURRENT_STACK_PTR_OFFSET))\n-                          + TPFRA_OFFSET_FROM_START_OF_STACK_FRAME)) \n-                          = (unsigned long int) target;\n-\n-                  /* Before returning the desired pat stub address to\n-                     the exception handling unwinder so that it can \n-                     actually do the \"leap\" shift out the low order \n-                     bit designated to determine if we are in 64BIT mode.\n-                     This is necessary for CTOA stubs.\n-                     Otherwise we leap one byte past where we want to \n-                     go to in the TPF pat stub linkage code.  */\n-                  shifter = *((unsigned long int *) \n-                       (stackptr + RA_OFFSET_FROM_START_OF_STACK_FRAME));\n-\n-                  shifter &= ~1ul;\n-\n-                  return (void *) shifter;\n-                }\n-\n-              /* Desired module pat stub not found ...\n-                 Bump stack frame iterator.  */\n-              stackptr = (void *) *(unsigned long int *) stackptr;\n+                          (stackptr+TPFRA_OFFSET));\n+              is_a_stub = 1;\n             }\n-        }\n+\n+          /* Get codeinfo on RA so that we can figure out\n+             the module address.  */\n+          retval = dladdr (current, &currentcodeInfo);\n+\n+          /* Check that codeinfo for current stack frame is valid.\n+             Then compare the module address of current stack frame\n+             to target stack frame to determine if we have the pat\n+             stub address we want.  Also ensure we are dealing\n+             with a module crossing, stub return address. */\n+          if (is_a_stub && retval != INVALID_RETURN\n+             && targetcodeInfo.dli_fbase == currentcodeInfo.dli_fbase)\n+             {\n+               /* Yes! They are in the same module.\n+                  Force copy of TPF private stack area to\n+                  destination stack frame TPF private area. */\n+               destination_frame = (void *) *((unsigned long int *) \n+                   (*PREVIOUS_STACK_PTR() + R15_OFFSET));\n+\n+               /* Copy TPF linkage area from current frame to\n+                  destination frame.  */\n+               memcpy((void *) (destination_frame + TPFAREA_OFFSET),\n+                 (void *) (stackptr + TPFAREA_OFFSET), TPFAREA_SIZE);\n+\n+               /* Now overlay the\n+                  real target address into the TPF stack area of\n+                  the target frame we are jumping to.  */\n+               *((unsigned long int *) (destination_frame + \n+                   TPFRA_OFFSET)) = (unsigned long int) target;\n+\n+               /* Before returning the desired pat stub address to\n+                  the exception handling unwinder so that it can \n+                  actually do the \"leap\" shift out the low order \n+                  bit designated to determine if we are in 64BIT mode.\n+                  This is necessary for CTOA stubs.\n+                  Otherwise we leap one byte past where we want to \n+                  go to in the TPF pat stub linkage code.  */\n+               shifter = *((unsigned long int *) \n+                     (stackptr + RA_OFFSET));\n+\n+               shifter &= ~1ul;\n+\n+               /* Store Pat Stub Address in destination Stack Frame.  */\n+               *((unsigned long int *) (destination_frame +\n+                   RA_OFFSET)) = shifter;               \n+\n+               /* Re-adjust pat stub address to go to correct place\n+                  in linkage.  */\n+               shifter = shifter - 4;\n+\n+               return (void *) shifter;\n+             }\n+\n+          /* Desired module pat stub not found ...\n+             Bump stack frame iterator.  */\n+          stackptr = (void *) *(unsigned long int *) stackptr;\n+\n+          is_a_stub = 0;\n+\n+        }  while (stackptr && retval != INVALID_RETURN\n+                && targetcodeInfo.dli_fbase != currentcodeInfo.dli_fbase);\n     }\n \n   /* No pat stub found, could be a problem?  Simply return unmodified\n      target address.  */\n   return target;\n }\n \n-"}]}