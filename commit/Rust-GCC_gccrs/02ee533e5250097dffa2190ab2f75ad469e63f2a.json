{"sha": "02ee533e5250097dffa2190ab2f75ad469e63f2a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJlZTUzM2U1MjUwMDk3ZGZmYTIxOTBhYjJmNzVhZDQ2OWU2M2YyYQ==", "commit": {"author": {"name": "Stephane Carrez", "email": "stcarrez@nerim.fr", "date": "2005-05-08T19:53:42Z"}, "committer": {"name": "Stephane Carrez", "email": "ciceron@gcc.gnu.org", "date": "2005-05-08T19:53:42Z"}, "message": "predicates.md (reg_or_some_mem_operand): Do not allow the 68HC12 address indirect addressing mode as it is not supported...\n\n\t* config/m68hc11/predicates.md (reg_or_some_mem_operand): Do not allow\n\tthe 68HC12 address indirect addressing mode as it is not supported by\n\tbset and bclr.\n\t* config/m68hc11/m68hc11-protos.h (m68hc11_valid_addressing_p): Declare.\n\t(m68hc11_add_mode): Declare.\n\t* config/m68hc11/m68hc11.c (m68hc11_valid_addressing_p): Rename from\n\tregister_indirect_p and export it.\n\t(m68hc11_z_replacement): Use emit_insn_after when adding the save Z\n\tinstruction so that it is part of the good BB.\n\t(m68hc11_gen_movhi): Fix invalid generation of indexed indirect\n\taddressing with movw.\n\t(m68hc11_gen_movqi): Use pula and pulb instead of lda and ldb for\n\t68HC12.\n\t* config/m68hc11/m68hc11.h (ADDR_STRICT, ADDR_INCDEC, ADDR_INDEXED,\n\tADDR_OFFSET, ADDR_INDIRECT, ADDR__CONST): Moved from m68hc11.c.\n\t* config/m68hc11/m68hc11.md (\"movhi_const0\"): Use this pattern only\n\tfor 68HC11.\n\t(\"*movhi_68hc12\"): Handle movhi_const0.\n\t(\"*subhi3\", \"subqi3\"): Use general_operand for operand 1.\n\t(\"*subhi3_zext\"): Likewise.\n\nFrom-SVN: r99405", "tree": {"sha": "bb1a6b7aeef5ee07c5493dd8342cab3f2a66dfe2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb1a6b7aeef5ee07c5493dd8342cab3f2a66dfe2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02ee533e5250097dffa2190ab2f75ad469e63f2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02ee533e5250097dffa2190ab2f75ad469e63f2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02ee533e5250097dffa2190ab2f75ad469e63f2a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02ee533e5250097dffa2190ab2f75ad469e63f2a/comments", "author": null, "committer": null, "parents": [{"sha": "011699d905f883656dc0bb5e65274645a860e999", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/011699d905f883656dc0bb5e65274645a860e999", "html_url": "https://github.com/Rust-GCC/gccrs/commit/011699d905f883656dc0bb5e65274645a860e999"}], "stats": {"total": 220, "additions": 148, "deletions": 72}, "files": [{"sha": "3cb7bf42d3d0eb7c61a8380b815037367343a0d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ee533e5250097dffa2190ab2f75ad469e63f2a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ee533e5250097dffa2190ab2f75ad469e63f2a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=02ee533e5250097dffa2190ab2f75ad469e63f2a", "patch": "@@ -1,3 +1,26 @@\n+2005-05-08  Stephane Carrez  <stcarrez@nerim.fr>\n+\n+\t* config/m68hc11/predicates.md (reg_or_some_mem_operand): Do not allow\n+\tthe 68HC12 address indirect addressing mode as it is not supported by\n+\tbset and bclr.\n+\t* config/m68hc11/m68hc11-protos.h (m68hc11_valid_addressing_p): Declare.\n+\t(m68hc11_add_mode): Declare.\n+\t* config/m68hc11/m68hc11.c (m68hc11_valid_addressing_p): Rename from\n+\tregister_indirect_p and export it.\n+\t(m68hc11_z_replacement): Use emit_insn_after when adding the save Z\n+\tinstruction so that it is part of the good BB.\n+\t(m68hc11_gen_movhi): Fix invalid generation of indexed indirect\n+\taddressing with movw.\n+\t(m68hc11_gen_movqi): Use pula and pulb instead of lda and ldb for\n+\t68HC12.\n+\t* config/m68hc11/m68hc11.h (ADDR_STRICT, ADDR_INCDEC, ADDR_INDEXED,\n+\tADDR_OFFSET, ADDR_INDIRECT, ADDR__CONST): Moved from m68hc11.c.\n+\t* config/m68hc11/m68hc11.md (\"movhi_const0\"): Use this pattern only\n+\tfor 68HC11.\n+\t(\"*movhi_68hc12\"): Handle movhi_const0.\n+\t(\"*subhi3\", \"subqi3\"): Use general_operand for operand 1.\n+\t(\"*subhi3_zext\"): Likewise.\n+\n 2005-05-08  Stephane Carrez  <stcarrez@nerim.fr>\n \n \tPR target/19051"}, {"sha": "aad6f4ad0b8d4c98a08ba5a7c08c0b05f6d7fa75", "filename": "gcc/config/m68hc11/m68hc11-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ee533e5250097dffa2190ab2f75ad469e63f2a/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ee533e5250097dffa2190ab2f75ad469e63f2a/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h?ref=02ee533e5250097dffa2190ab2f75ad469e63f2a", "patch": "@@ -98,6 +98,7 @@ extern int memory_indexed_operand (rtx, enum machine_mode);\n extern void m68hc11_split_logical (enum machine_mode, int, rtx*);\n \n extern int m68hc11_register_indirect_p (rtx, enum machine_mode);\n+extern int m68hc11_valid_addressing_p (rtx, enum machine_mode, int);\n \n extern int symbolic_memory_operand (rtx, enum machine_mode);\n \n@@ -123,6 +124,7 @@ extern int m68hc11_page0_symbol_p (rtx x);\n \n extern HOST_WIDE_INT m68hc11_min_offset;\n extern HOST_WIDE_INT m68hc11_max_offset;\n+extern int m68hc11_addr_mode;\n \n #endif /* HAVE_MACHINE_MODES */\n #endif /* RTX_CODE */"}, {"sha": "17d0dd49b86c51babb3f2c8bd3b251c6eda157db", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 71, "deletions": 40, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ee533e5250097dffa2190ab2f75ad469e63f2a/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ee533e5250097dffa2190ab2f75ad469e63f2a/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=02ee533e5250097dffa2190ab2f75ad469e63f2a", "patch": "@@ -65,7 +65,6 @@ static rtx simplify_logical (enum machine_mode, int, rtx, rtx *);\n static void m68hc11_emit_logical (enum machine_mode, int, rtx *);\n static void m68hc11_reorg (void);\n static int go_if_legitimate_address_internal (rtx, enum machine_mode, int);\n-static int register_indirect_p (rtx, enum machine_mode, int);\n static rtx m68hc11_expand_compare (enum rtx_code, rtx, rtx);\n static int must_parenthesize (rtx);\n static int m68hc11_address_cost (rtx);\n@@ -140,13 +139,6 @@ unsigned char m68hc11_reg_valid_for_index[FIRST_PSEUDO_REGISTER];\n    This is 1 for 68HC11 and 0 for 68HC12.  */\n int m68hc11_sp_correction;\n \n-#define ADDR_STRICT       0x01  /* Accept only registers in class A_REGS  */\n-#define ADDR_INCDEC       0x02  /* Post/Pre inc/dec */\n-#define ADDR_INDEXED      0x04  /* D-reg index */\n-#define ADDR_OFFSET       0x08\n-#define ADDR_INDIRECT     0x10  /* Accept (mem (mem ...)) for [n,X] */\n-#define ADDR_CONST        0x20  /* Accept const and symbol_ref  */\n-\n int m68hc11_addr_mode;\n int m68hc11_mov_addr_mode;\n \n@@ -560,26 +552,26 @@ preferred_reload_class (rtx operand, enum reg_class class)\n /* Return 1 if the operand is a valid indexed addressing mode.\n    For 68hc11:  n,r    with n in [0..255] and r in A_REGS class\n    For 68hc12:  n,r    no constraint on the constant, r in A_REGS class.  */\n-static int\n-register_indirect_p (rtx operand, enum machine_mode mode, int addr_mode)\n+int\n+m68hc11_valid_addressing_p (rtx operand, enum machine_mode mode, int addr_mode)\n {\n   rtx base, offset;\n \n   switch (GET_CODE (operand))\n     {\n     case MEM:\n       if ((addr_mode & ADDR_INDIRECT) && GET_MODE_SIZE (mode) <= 2)\n-        return register_indirect_p (XEXP (operand, 0), mode,\n-                                    addr_mode & (ADDR_STRICT | ADDR_OFFSET));\n+        return m68hc11_valid_addressing_p (XEXP (operand, 0), mode,\n+                                   addr_mode & (ADDR_STRICT | ADDR_OFFSET));\n       return 0;\n \n     case POST_INC:\n     case PRE_INC:\n     case POST_DEC:\n     case PRE_DEC:\n       if (addr_mode & ADDR_INCDEC)\n-\treturn register_indirect_p (XEXP (operand, 0), mode,\n-                                    addr_mode & ADDR_STRICT);\n+\treturn m68hc11_valid_addressing_p (XEXP (operand, 0), mode,\n+                                   addr_mode & ADDR_STRICT);\n       return 0;\n \n     case PLUS:\n@@ -675,7 +667,7 @@ m68hc11_small_indexed_indirect_p (rtx operand, enum machine_mode mode)\n     return 1;\n \n   addr_mode = m68hc11_mov_addr_mode | (reload_completed ? ADDR_STRICT : 0);\n-  if (!register_indirect_p (operand, mode, addr_mode))\n+  if (!m68hc11_valid_addressing_p (operand, mode, addr_mode))\n     return 0;\n \n   if (TARGET_M6812 && GET_CODE (operand) == PLUS\n@@ -730,7 +722,7 @@ m68hc11_register_indirect_p (rtx operand, enum machine_mode mode)\n \n   operand = XEXP (operand, 0);\n   addr_mode = m68hc11_addr_mode | (reload_completed ? ADDR_STRICT : 0);\n-  return register_indirect_p (operand, mode, addr_mode);\n+  return m68hc11_valid_addressing_p (operand, mode, addr_mode);\n }\n \n static int\n@@ -749,7 +741,7 @@ go_if_legitimate_address_internal (rtx operand, enum machine_mode mode,\n       return 1;\n     }\n   addr_mode = m68hc11_addr_mode | (strict ? ADDR_STRICT : 0);\n-  if (register_indirect_p (operand, mode, addr_mode))\n+  if (m68hc11_valid_addressing_p (operand, mode, addr_mode))\n     {\n       return 1;\n     }\n@@ -995,7 +987,7 @@ m68hc11_indirect_p (rtx operand, enum machine_mode mode)\n \n       operand = XEXP (operand, 0);\n       addr_mode = m68hc11_addr_mode | (reload_completed ? ADDR_STRICT : 0);\n-      return register_indirect_p (operand, mode, addr_mode);\n+      return m68hc11_valid_addressing_p (operand, mode, addr_mode);\n     }\n   return 0;\n }\n@@ -3110,10 +3102,13 @@ m68hc11_gen_movhi (rtx insn, rtx *operands)\n \n   if (TARGET_M6812)\n     {\n-      if (IS_STACK_PUSH (operands[0]) && H_REG_P (operands[1]))\n+      rtx from = operands[1];\n+      rtx to = operands[0];\n+\n+      if (IS_STACK_PUSH (to) && H_REG_P (from))\n \t{\n           cc_status = cc_prev_status;\n-\t  switch (REGNO (operands[1]))\n+\t  switch (REGNO (from))\n \t    {\n \t    case HARD_X_REGNUM:\n \t    case HARD_Y_REGNUM:\n@@ -3128,10 +3123,10 @@ m68hc11_gen_movhi (rtx insn, rtx *operands)\n \t    }\n \t  return;\n \t}\n-      if (IS_STACK_POP (operands[1]) && H_REG_P (operands[0]))\n+      if (IS_STACK_POP (from) && H_REG_P (to))\n \t{\n           cc_status = cc_prev_status;\n-\t  switch (REGNO (operands[0]))\n+\t  switch (REGNO (to))\n \t    {\n \t    case HARD_X_REGNUM:\n \t    case HARD_Y_REGNUM:\n@@ -3162,11 +3157,52 @@ m68hc11_gen_movhi (rtx insn, rtx *operands)\n \t  else\n \t    output_asm_insn (\"st%1\\t%0\", operands);\n \t}\n+\n+      /* The 68hc12 does not support (MEM:HI (MEM:HI)) with the movw\n+         instruction.  We have to use a scratch register as temporary location.\n+         Trying to use a specific pattern or constrain failed.  */\n+      else if (GET_CODE (to) == MEM && GET_CODE (XEXP (to, 0)) == MEM)\n+        {\n+          rtx ops[4];\n+\n+          ops[0] = to;\n+          ops[2] = from;\n+          ops[3] = 0;\n+          if (dead_register_here (insn, d_reg))\n+            ops[1] = d_reg;\n+          else if (dead_register_here (insn, ix_reg))\n+            ops[1] = ix_reg;\n+          else if (dead_register_here (insn, iy_reg))\n+            ops[1] = iy_reg;\n+          else\n+            {\n+              ops[1] = d_reg;\n+              ops[3] = d_reg;\n+              output_asm_insn (\"psh%3\", ops);\n+            }\n+\n+          ops[0] = to;\n+          ops[2] = from;\n+          output_asm_insn (\"ld%1\\t%2\", ops);\n+          output_asm_insn (\"st%1\\t%0\", ops);\n+          if (ops[3])\n+            output_asm_insn (\"pul%3\", ops);\n+        }\n+\n+      /* Use movw for non-null constants or when we are clearing\n+         a volatile memory reference.  However, this is possible\n+         only if the memory reference has a small offset or is an\n+         absolute address.  */\n+      else if (GET_CODE (from) == CONST_INT\n+               && INTVAL (from) == 0\n+               && (MEM_VOLATILE_P (to) == 0\n+                   || m68hc11_small_indexed_indirect_p (to, HImode) == 0))\n+        {\n+          output_asm_insn (\"clr\\t%h0\", operands);\n+          output_asm_insn (\"clr\\t%b0\", operands);\n+        }\n       else\n \t{\n-\t  rtx from = operands[1];\n-\t  rtx to = operands[0];\n-\n \t  if ((m68hc11_register_indirect_p (from, GET_MODE (from))\n \t       && !m68hc11_small_indexed_indirect_p (from, GET_MODE (from)))\n \t      || (m68hc11_register_indirect_p (to, GET_MODE (to))\n@@ -3183,26 +3219,19 @@ m68hc11_gen_movhi (rtx insn, rtx *operands)\n \t\t  ops[0] = to;\n \t\t  ops[1] = operands[2];\n \t\t  m68hc11_gen_movhi (insn, ops);\n+                  return;\n \t\t}\n \t      else\n \t\t{\n \t\t  /* !!!! SCz wrong here.  */\n                   fatal_insn (\"move insn not handled\", insn);\n \t\t}\n \t    }\n-\t  else\n-\t    {\n-\t      if (GET_CODE (from) == CONST_INT && INTVAL (from) == 0)\n-\t\t{\n-\t\t  output_asm_insn (\"clr\\t%h0\", operands);\n-\t\t  output_asm_insn (\"clr\\t%b0\", operands);\n-\t\t}\n-\t      else\n-\t\t{\n-                  m68hc11_notice_keep_cc (operands[0]);\n-\t\t  output_asm_insn (\"movw\\t%1,%0\", operands);\n-\t\t}\n-\t    }\n+          else\n+            {\n+              m68hc11_notice_keep_cc (operands[0]);\n+              output_asm_insn (\"movw\\t%1,%0\", operands);\n+            }\n \t}\n       return;\n     }\n@@ -3530,8 +3559,10 @@ m68hc11_gen_movqi (rtx insn, rtx *operands)\n \t}\n       else if (H_REG_P (operands[0]))\n \t{\n-\t  if (Q_REG_P (operands[0]))\n-\t    output_asm_insn (\"lda%0\\t%b1\", operands);\n+          if (IS_STACK_POP (operands[1]))\n+            output_asm_insn (\"pul%b0\", operands);\n+\t  else if (Q_REG_P (operands[0]))\n+            output_asm_insn (\"lda%0\\t%b1\", operands);\n \t  else if (D_REG_P (operands[0]))\n \t    output_asm_insn (\"ldab\\t%b1\", operands);\n \t  else"}, {"sha": "02b085665556b4aa9a3db84ecc41dd0d3c933ac6", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ee533e5250097dffa2190ab2f75ad469e63f2a/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ee533e5250097dffa2190ab2f75ad469e63f2a/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=02ee533e5250097dffa2190ab2f75ad469e63f2a", "patch": "@@ -1037,6 +1037,13 @@ typedef struct m68hc11_args\n \f\n /* Addressing modes, and classification of registers for them.  */\n \n+#define ADDR_STRICT       0x01  /* Accept only registers in class A_REGS  */\n+#define ADDR_INCDEC       0x02  /* Post/Pre inc/dec */\n+#define ADDR_INDEXED      0x04  /* D-reg index */\n+#define ADDR_OFFSET       0x08\n+#define ADDR_INDIRECT     0x10  /* Accept (mem (mem ...)) for [n,X] */\n+#define ADDR_CONST        0x20  /* Accept const and symbol_ref  */\n+\n /* The 68HC12 has all the post/pre increment/decrement modes.  */\n #define HAVE_POST_INCREMENT (TARGET_M6812 && TARGET_AUTO_INC_DEC)\n #define HAVE_PRE_INCREMENT  (TARGET_M6812 && TARGET_AUTO_INC_DEC)"}, {"sha": "c03191c73379c4706e4053d74dbe718906d6a3c4", "filename": "gcc/config/m68hc11/m68hc11.md", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ee533e5250097dffa2190ab2f75ad469e63f2a/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ee533e5250097dffa2190ab2f75ad469e63f2a/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md?ref=02ee533e5250097dffa2190ab2f75ad469e63f2a", "patch": "@@ -689,8 +689,8 @@\n    DONE;\")\n \n (define_insn_and_split \"movdf_internal\"\n-  [(set (match_operand:DF 0 \"non_push_operand\" \"=mu,U,!u,U,m,m,!u\")\n-\t(match_operand:DF 1 \"general_operand\" \"G,iU,iU,!u,mi,!u,!mu\"))\n+  [(set (match_operand:DF 0 \"non_push_operand\" \"=mu,U,m,!u,U,m,!u\")\n+\t(match_operand:DF 1 \"general_operand\" \"G,iU,mi,iU,!u,!u,!mu\"))\n    (clobber (match_scratch:HI 2 \"=X,&d,&d,&d,&d,&d,&d\"))]\n   \"\"\n   \"#\"\n@@ -886,25 +886,25 @@\n     }\n }\")\n \n-(define_insn \"movhi_const0\"\n-  [(set (match_operand:HI 0 \"splitable_operand\" \"=d,A,um\")\n-\t(const_int 0))]\n-  \"\"\n-  \"@\n-   clra\\\\n\\\\tclrb\n-   ld%0\\\\t#0\n-   clr\\\\t%b0\\\\n\\\\tclr\\\\t%h0\")\n-\n (define_insn \"*movhi_68hc12\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=U,dAw,dAw,U,U,m,!u\")\n-\t(match_operand:HI 1 \"general_operand\" \"U,dAwim,!u,dAwi,!u,dAw,riU\"))]\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=U,dAw,dAw,m,U,U,m,!u\")\n+\t(match_operand:HI 1 \"general_operand\" \"U,dAwim,!u,K,dAwi,!u,dAw,riU\"))]\n   \"TARGET_M6812\"\n   \"*\n {\n   m68hc11_gen_movhi (insn, operands);\n   return \\\"\\\";\n }\")\n \n+(define_insn \"movhi_const0\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,A,um\")\n+\t(const_int 0))]\n+  \"TARGET_M6811\"\n+  \"@\n+   clra\\\\n\\\\tclrb\n+   ld%0\\\\t#0\n+   clr\\\\t%b0\\\\n\\\\tclr\\\\t%h0\")\n+\n (define_insn \"*movhi_m68hc11\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=dAw,!u,m,m,dAw,!*u\")\n \t(match_operand:HI 1 \"general_operand\" \"dAwim,dAw,dA,?Aw,!*u,dAw\"))]\n@@ -1237,7 +1237,7 @@\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=m,m,!u,!u\")\n \t(zero_extend:DI \n \t    (match_operand:SI 1 \"nonimmediate_operand\" \"m,Du,m,Du\")))\n-   (clobber (match_scratch:HI 2 \"=d,d,&d,d\"))]\n+   (clobber (match_scratch:HI 2 \"=d,d,d,d\"))]\n   \"\"\n   \"#\")\n \n@@ -2382,7 +2382,7 @@\n   [(set (match_operand:HI 0 \"hard_reg_operand\" \"=A,d\")\n \t(plus:HI (zero_extend:HI \n \t\t     (match_operand:QI 1 \"nonimmediate_operand\" \"d,um*A\"))\n-\t\t (match_operand:HI 2 \"hard_reg_operand\" \"0,0\")))]\n+\t\t (match_operand:HI 2 \"general_operand\" \"0,0\")))]\n   \"\"\n   \"*\n {\n@@ -2716,7 +2716,7 @@\n \n (define_insn \"*subhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=d,*A,d,*A\")\n-\t(minus:HI (match_operand:HI 1 \"register_operand\" \"0,0,0,0\")\n+\t(minus:HI (match_operand:HI 1 \"general_operand\" \"0,0,0,0\")\n \t\t  (match_operand:HI 2 \"general_operand\" \"im*A*d,im*d*A,u,!u\")))]\n   \"\"\n   \"*\n@@ -2731,7 +2731,7 @@\n \n (define_insn \"*subhi3_zext\"\n   [(set (match_operand:HI 0 \"hard_reg_operand\" \"=d,d\")\n-\t(minus:HI (match_operand:HI 1 \"hard_reg_operand\" \"0,0\")\n+\t(minus:HI (match_operand:HI 1 \"general_operand\" \"0,0\")\n            (zero_extend:HI (match_operand:QI 2 \"general_operand\" \"mi*A,!u\"))))]\n   \"\"\n   \"*\n@@ -2751,7 +2751,7 @@\n \n (define_insn \"subqi3\"\n   [(set (match_operand:QI 0 \"hard_reg_operand\" \"=dq,!*x*y\")\n-        (minus:QI (match_operand:QI 1 \"hard_reg_operand\" \"0,0\")\n+        (minus:QI (match_operand:QI 1 \"general_operand\" \"0,0\")\n                   (match_operand:QI 2 \"general_operand\" \"uim*A*d,uim*A*d\")))]\n   \"\"\n   \"*\n@@ -3326,8 +3326,8 @@\n \n (define_insn \"*andqi3_gen\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d,d,d,?*A,?*A,!*q\")\n-        (and:QI (match_operand:QI 1 \"register_operand\" \"%0,0,0,0,0,0\")\n-             (match_operand:QI 2 \"general_operand\" \"mi,!u,?*A,!um,?*A*d,!um*A\")))]\n+        (and:QI (match_operand:QI 1 \"general_operand\" \"%0,0,0,0,0,0\")\n+             (match_operand:QI 2 \"general_operand\" \"mi,!*u,?*A,!*um,?*A*d,!*um*A\")))]\n   \"\"\n   \"*\n {\n@@ -3544,8 +3544,8 @@\n \n (define_insn \"*iorqi3_gen\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d,d,d,?*A,?*A,!*q\")\n-\t(ior:QI (match_operand:QI 1 \"register_operand\" \"%0,0,0,0,0,0\")\n-\t     (match_operand:QI 2 \"general_operand\" \"mi,!u,!*A,!um,?*A*d,!um*A\")))]\n+\t(ior:QI (match_operand:QI 1 \"general_operand\" \"%0,0,0,0,0,0\")\n+\t     (match_operand:QI 2 \"general_operand\" \"mi,!*u,!*A,!*um,?*A*d,!*um*A\")))]\n   \"\"\n   \"*\n {\n@@ -3636,8 +3636,8 @@\n \n (define_insn \"xorqi3\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d,d,d,?*A,?*A,!*q\")\n-        (xor:QI (match_operand:QI 1 \"register_operand\" \"%0,0,0,0,0,0\")\n-             (match_operand:QI 2 \"general_operand\" \"im,!u,!*A,!ium,?*A*d,!ium*A\")))]\n+        (xor:QI (match_operand:QI 1 \"general_operand\" \"%0,0,0,0,0,0\")\n+             (match_operand:QI 2 \"general_operand\" \"im,!*u,!*A,!i*um,?*A*d,!i*um*A\")))]\n   \"\"\n   \"*\n {\n@@ -6914,14 +6914,16 @@\n ;;\n ;; Replace \"leas 2,sp\" with a \"pulx\" or a \"puly\".\n ;; On 68HC12, this is one cycle slower but one byte smaller.\n-;; pr target/6899: This peephole is not valid because a register CSE\n-;; pass removes the pulx/puly.\n+;; pr target/6899: This peephole was not valid because a register CSE\n+;; pass removes the pulx/puly.  The 'use' clause ensure that the pulx is\n+;; not removed.\n ;;\n (define_peephole2\n   [(set (reg:HI SP_REGNUM) (plus:HI (reg:HI SP_REGNUM) (const_int 2)))\n    (match_scratch:HI 0 \"xy\")]\n-  \"0 && TARGET_M6812 && optimize_size\"\n-  [(set (match_dup 0) (match_dup 1))]\n+  \"TARGET_M6812 && optimize_size\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (use (match_dup 0))]\n   \"operands[1] = gen_rtx_MEM (HImode,\n \t\t\t  gen_rtx_POST_INC (HImode,\n \t\t\t\t   gen_rtx_REG (HImode, HARD_SP_REGNUM)));\")"}, {"sha": "904c5b1194ab969deaf50789eafb772bedefefe9", "filename": "gcc/config/m68hc11/predicates.md", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ee533e5250097dffa2190ab2f75ad469e63f2a/gcc%2Fconfig%2Fm68hc11%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ee533e5250097dffa2190ab2f75ad469e63f2a/gcc%2Fconfig%2Fm68hc11%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fpredicates.md?ref=02ee533e5250097dffa2190ab2f75ad469e63f2a", "patch": "@@ -173,17 +173,28 @@\n   if (GET_CODE (op) == MEM)\n     {\n       rtx op0 = XEXP (op, 0);\n+      int addr_mode;\n \n       if (symbolic_memory_operand (op0, mode))\n \treturn 1;\n \n       if (IS_STACK_PUSH (op))\n \treturn 1;\n \n-      if (m68hc11_register_indirect_p (op, mode))\n-\treturn 1;\n-\n-      return 0;\n+      if (GET_CODE (op) == REG && reload_in_progress\n+          && REGNO (op) >= FIRST_PSEUDO_REGISTER\n+          && reg_equiv_memory_loc[REGNO (op)])\n+         {\n+            op = reg_equiv_memory_loc[REGNO (op)];\n+            op = eliminate_regs (op, 0, NULL_RTX);\n+         }\n+      if (GET_CODE (op) != MEM)\n+         return 0;\n+\n+      op0 = XEXP (op, 0);\n+      addr_mode = m68hc11_addr_mode | (reload_completed ? ADDR_STRICT : 0);\n+      addr_mode &= ~ADDR_INDIRECT;\n+      return m68hc11_valid_addressing_p (op0, mode, addr_mode);\n     }\n \n   return register_operand (op, mode);"}]}