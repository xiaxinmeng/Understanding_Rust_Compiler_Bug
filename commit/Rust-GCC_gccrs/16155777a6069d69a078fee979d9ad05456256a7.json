{"sha": "16155777a6069d69a078fee979d9ad05456256a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTYxNTU3NzdhNjA2OWQ2OWEwNzhmZWU5NzlkOWFkMDU0NTYyNTZhNw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2017-12-20T16:56:20Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-12-20T16:56:20Z"}, "message": "PR testsuite/83131 - c-c++/common/attr-nonstring-3 failure for strcmp tests on PowerPC\n\ngcc/ChangeLog:\n\n\tPR testsuite/83131\n\t* builtins.c (expand_builtin_strlen): Use get_callee_fndecl.\n\t(expand_builtin_strcmp): Call maybe_warn_nonstring_arg.\t\n\t(expand_builtin_strncmp): Same.\n\ngcc/testsuite/ChangeLog:\n\n\tPR testsuite/83131\n\t* c-c++-common/attr-nonstring-4.c: New test.\n\nFrom-SVN: r255898", "tree": {"sha": "d7498b1f18e85c3e5c5835f12f2c5d49fe34567a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7498b1f18e85c3e5c5835f12f2c5d49fe34567a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16155777a6069d69a078fee979d9ad05456256a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16155777a6069d69a078fee979d9ad05456256a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16155777a6069d69a078fee979d9ad05456256a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16155777a6069d69a078fee979d9ad05456256a7/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "35c4515b8b8e306684a3837d40ffa2c9fcdd9899", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35c4515b8b8e306684a3837d40ffa2c9fcdd9899", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35c4515b8b8e306684a3837d40ffa2c9fcdd9899"}], "stats": {"total": 591, "additions": 342, "deletions": 249}, "files": [{"sha": "2f23a2b88600911f631c0db7ea080180485d3413", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16155777a6069d69a078fee979d9ad05456256a7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16155777a6069d69a078fee979d9ad05456256a7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=16155777a6069d69a078fee979d9ad05456256a7", "patch": "@@ -1,3 +1,10 @@\n+2017-12-20  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR testsuite/83131\n+\t* builtins.c (expand_builtin_strlen): Use get_callee_fndecl.\n+\t(expand_builtin_strcmp): Call maybe_warn_nonstring_arg.\t\n+\t(expand_builtin_strncmp): Same.\n+\n 2017-12-20  Alexandre Oliva <aoliva@redhat.com>\n \n \tPR bootstrap/83396"}, {"sha": "f8b853c6ecd03466a771b06831ada7feaf6e2f54", "filename": "gcc/builtins.c", "status": "modified", "additions": 251, "deletions": 249, "changes": 500, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16155777a6069d69a078fee979d9ad05456256a7/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16155777a6069d69a078fee979d9ad05456256a7/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=16155777a6069d69a078fee979d9ad05456256a7", "patch": "@@ -2829,102 +2829,100 @@ expand_builtin_strlen (tree exp, rtx target,\n {\n   if (!validate_arglist (exp, POINTER_TYPE, VOID_TYPE))\n     return NULL_RTX;\n-  else\n-    {\n-      struct expand_operand ops[4];\n-      rtx pat;\n-      tree len;\n-      tree src = CALL_EXPR_ARG (exp, 0);\n-      rtx src_reg;\n-      rtx_insn *before_strlen;\n-      machine_mode insn_mode;\n-      enum insn_code icode = CODE_FOR_nothing;\n-      unsigned int align;\n \n-      /* If the length can be computed at compile-time, return it.  */\n-      len = c_strlen (src, 0);\n-      if (len)\n-\treturn expand_expr (len, target, target_mode, EXPAND_NORMAL);\n-\n-      /* If the length can be computed at compile-time and is constant\n-\t integer, but there are side-effects in src, evaluate\n-\t src for side-effects, then return len.\n-\t E.g. x = strlen (i++ ? \"xfoo\" + 1 : \"bar\");\n-\t can be optimized into: i++; x = 3;  */\n-      len = c_strlen (src, 1);\n-      if (len && TREE_CODE (len) == INTEGER_CST)\n-\t{\n-\t  expand_expr (src, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\t  return expand_expr (len, target, target_mode, EXPAND_NORMAL);\n-\t}\n+  struct expand_operand ops[4];\n+  rtx pat;\n+  tree len;\n+  tree src = CALL_EXPR_ARG (exp, 0);\n+  rtx src_reg;\n+  rtx_insn *before_strlen;\n+  machine_mode insn_mode;\n+  enum insn_code icode = CODE_FOR_nothing;\n+  unsigned int align;\n \n-      align = get_pointer_alignment (src) / BITS_PER_UNIT;\n+  /* If the length can be computed at compile-time, return it.  */\n+  len = c_strlen (src, 0);\n+  if (len)\n+    return expand_expr (len, target, target_mode, EXPAND_NORMAL);\n \n-      /* If SRC is not a pointer type, don't do this operation inline.  */\n-      if (align == 0)\n-\treturn NULL_RTX;\n+  /* If the length can be computed at compile-time and is constant\n+     integer, but there are side-effects in src, evaluate\n+     src for side-effects, then return len.\n+     E.g. x = strlen (i++ ? \"xfoo\" + 1 : \"bar\");\n+     can be optimized into: i++; x = 3;  */\n+  len = c_strlen (src, 1);\n+  if (len && TREE_CODE (len) == INTEGER_CST)\n+    {\n+      expand_expr (src, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+      return expand_expr (len, target, target_mode, EXPAND_NORMAL);\n+    }\n \n-      /* Bail out if we can't compute strlen in the right mode.  */\n-      FOR_EACH_MODE_FROM (insn_mode, target_mode)\n-\t{\n-\t  icode = optab_handler (strlen_optab, insn_mode);\n-\t  if (icode != CODE_FOR_nothing)\n-\t    break;\n-\t}\n-      if (insn_mode == VOIDmode)\n-\treturn NULL_RTX;\n+  align = get_pointer_alignment (src) / BITS_PER_UNIT;\n+\n+  /* If SRC is not a pointer type, don't do this operation inline.  */\n+  if (align == 0)\n+    return NULL_RTX;\n \n-      /* Make a place to hold the source address.  We will not expand\n-\t the actual source until we are sure that the expansion will\n-\t not fail -- there are trees that cannot be expanded twice.  */\n-      src_reg = gen_reg_rtx (Pmode);\n+  /* Bail out if we can't compute strlen in the right mode.  */\n+  FOR_EACH_MODE_FROM (insn_mode, target_mode)\n+    {\n+      icode = optab_handler (strlen_optab, insn_mode);\n+      if (icode != CODE_FOR_nothing)\n+\tbreak;\n+    }\n+  if (insn_mode == VOIDmode)\n+    return NULL_RTX;\n \n-      /* Mark the beginning of the strlen sequence so we can emit the\n-\t source operand later.  */\n-      before_strlen = get_last_insn ();\n+  /* Make a place to hold the source address.  We will not expand\n+     the actual source until we are sure that the expansion will\n+     not fail -- there are trees that cannot be expanded twice.  */\n+  src_reg = gen_reg_rtx (Pmode);\n \n-      create_output_operand (&ops[0], target, insn_mode);\n-      create_fixed_operand (&ops[1], gen_rtx_MEM (BLKmode, src_reg));\n-      create_integer_operand (&ops[2], 0);\n-      create_integer_operand (&ops[3], align);\n-      if (!maybe_expand_insn (icode, 4, ops))\n-\treturn NULL_RTX;\n+  /* Mark the beginning of the strlen sequence so we can emit the\n+     source operand later.  */\n+  before_strlen = get_last_insn ();\n \n-      /* Check to see if the argument was declared attribute nonstring\n-\t and if so, issue a warning since at this point it's not known\n-\t to be nul-terminated.  */\n-      maybe_warn_nonstring_arg (TREE_OPERAND (CALL_EXPR_FN (exp), 0), exp);\n+  create_output_operand (&ops[0], target, insn_mode);\n+  create_fixed_operand (&ops[1], gen_rtx_MEM (BLKmode, src_reg));\n+  create_integer_operand (&ops[2], 0);\n+  create_integer_operand (&ops[3], align);\n+  if (!maybe_expand_insn (icode, 4, ops))\n+    return NULL_RTX;\n \n-      /* Now that we are assured of success, expand the source.  */\n-      start_sequence ();\n-      pat = expand_expr (src, src_reg, Pmode, EXPAND_NORMAL);\n-      if (pat != src_reg)\n-\t{\n+  /* Check to see if the argument was declared attribute nonstring\n+     and if so, issue a warning since at this point it's not known\n+     to be nul-terminated.  */\n+  maybe_warn_nonstring_arg (get_callee_fndecl (exp), exp);\n+\n+  /* Now that we are assured of success, expand the source.  */\n+  start_sequence ();\n+  pat = expand_expr (src, src_reg, Pmode, EXPAND_NORMAL);\n+  if (pat != src_reg)\n+    {\n #ifdef POINTERS_EXTEND_UNSIGNED\n-\t  if (GET_MODE (pat) != Pmode)\n-\t    pat = convert_to_mode (Pmode, pat,\n-\t\t\t\t   POINTERS_EXTEND_UNSIGNED);\n+      if (GET_MODE (pat) != Pmode)\n+\tpat = convert_to_mode (Pmode, pat,\n+\t\t\t       POINTERS_EXTEND_UNSIGNED);\n #endif\n-\t  emit_move_insn (src_reg, pat);\n-\t}\n-      pat = get_insns ();\n-      end_sequence ();\n+      emit_move_insn (src_reg, pat);\n+    }\n+  pat = get_insns ();\n+  end_sequence ();\n \n-      if (before_strlen)\n-\temit_insn_after (pat, before_strlen);\n-      else\n-\temit_insn_before (pat, get_insns ());\n+  if (before_strlen)\n+    emit_insn_after (pat, before_strlen);\n+  else\n+    emit_insn_before (pat, get_insns ());\n \n-      /* Return the value in the proper mode for this function.  */\n-      if (GET_MODE (ops[0].value) == target_mode)\n-\ttarget = ops[0].value;\n-      else if (target != 0)\n-\tconvert_move (target, ops[0].value, 0);\n-      else\n-\ttarget = convert_to_mode (target_mode, ops[0].value, 0);\n+  /* Return the value in the proper mode for this function.  */\n+  if (GET_MODE (ops[0].value) == target_mode)\n+    target = ops[0].value;\n+  else if (target != 0)\n+    convert_move (target, ops[0].value, 0);\n+  else\n+    target = convert_to_mode (target_mode, ops[0].value, 0);\n \n-      return target;\n-    }\n+  return target;\n }\n \n /* Callback routine for store_by_pieces.  Read GET_MODE_BITSIZE (MODE)\n@@ -4485,102 +4483,104 @@ expand_builtin_strcmp (tree exp, ATTRIBUTE_UNUSED rtx target)\n \n   insn_code cmpstr_icode = direct_optab_handler (cmpstr_optab, SImode);\n   insn_code cmpstrn_icode = direct_optab_handler (cmpstrn_optab, SImode);\n-  if (cmpstr_icode != CODE_FOR_nothing || cmpstrn_icode != CODE_FOR_nothing)\n-    {\n-      rtx arg1_rtx, arg2_rtx;\n-      tree fndecl, fn;\n-      tree arg1 = CALL_EXPR_ARG (exp, 0);\n-      tree arg2 = CALL_EXPR_ARG (exp, 1);\n-      rtx result = NULL_RTX;\n+  if (cmpstr_icode == CODE_FOR_nothing && cmpstrn_icode == CODE_FOR_nothing)\n+    return NULL_RTX;\n \n-      unsigned int arg1_align = get_pointer_alignment (arg1) / BITS_PER_UNIT;\n-      unsigned int arg2_align = get_pointer_alignment (arg2) / BITS_PER_UNIT;\n+  tree arg1 = CALL_EXPR_ARG (exp, 0);\n+  tree arg2 = CALL_EXPR_ARG (exp, 1);\n \n-      /* If we don't have POINTER_TYPE, call the function.  */\n-      if (arg1_align == 0 || arg2_align == 0)\n-\treturn NULL_RTX;\n+  unsigned int arg1_align = get_pointer_alignment (arg1) / BITS_PER_UNIT;\n+  unsigned int arg2_align = get_pointer_alignment (arg2) / BITS_PER_UNIT;\n \n-      /* Stabilize the arguments in case gen_cmpstr(n)si fail.  */\n-      arg1 = builtin_save_expr (arg1);\n-      arg2 = builtin_save_expr (arg2);\n+  /* If we don't have POINTER_TYPE, call the function.  */\n+  if (arg1_align == 0 || arg2_align == 0)\n+    return NULL_RTX;\n \n-      arg1_rtx = get_memory_rtx (arg1, NULL);\n-      arg2_rtx = get_memory_rtx (arg2, NULL);\n+  /* Stabilize the arguments in case gen_cmpstr(n)si fail.  */\n+  arg1 = builtin_save_expr (arg1);\n+  arg2 = builtin_save_expr (arg2);\n \n-      /* Try to call cmpstrsi.  */\n-      if (cmpstr_icode != CODE_FOR_nothing)\n-\tresult = expand_cmpstr (cmpstr_icode, target, arg1_rtx, arg2_rtx,\n-\t\t\t\tMIN (arg1_align, arg2_align));\n+  rtx arg1_rtx = get_memory_rtx (arg1, NULL);\n+  rtx arg2_rtx = get_memory_rtx (arg2, NULL);\n \n-      /* Try to determine at least one length and call cmpstrnsi.  */\n-      if (!result && cmpstrn_icode != CODE_FOR_nothing)\n-\t{\n-\t  tree len;\n-\t  rtx arg3_rtx;\n-\n-\t  tree len1 = c_strlen (arg1, 1);\n-\t  tree len2 = c_strlen (arg2, 1);\n-\n-\t  if (len1)\n-\t    len1 = size_binop (PLUS_EXPR, ssize_int (1), len1);\n-\t  if (len2)\n-\t    len2 = size_binop (PLUS_EXPR, ssize_int (1), len2);\n-\n-\t  /* If we don't have a constant length for the first, use the length\n-\t     of the second, if we know it.  We don't require a constant for\n-\t     this case; some cost analysis could be done if both are available\n-\t     but neither is constant.  For now, assume they're equally cheap,\n-\t     unless one has side effects.  If both strings have constant lengths,\n-\t     use the smaller.  */\n-\n-\t  if (!len1)\n-\t    len = len2;\n-\t  else if (!len2)\n-\t    len = len1;\n-\t  else if (TREE_SIDE_EFFECTS (len1))\n-\t    len = len2;\n-\t  else if (TREE_SIDE_EFFECTS (len2))\n-\t    len = len1;\n-\t  else if (TREE_CODE (len1) != INTEGER_CST)\n-\t    len = len2;\n-\t  else if (TREE_CODE (len2) != INTEGER_CST)\n-\t    len = len1;\n-\t  else if (tree_int_cst_lt (len1, len2))\n-\t    len = len1;\n-\t  else\n-\t    len = len2;\n+  rtx result = NULL_RTX;\n+  /* Try to call cmpstrsi.  */\n+  if (cmpstr_icode != CODE_FOR_nothing)\n+    result = expand_cmpstr (cmpstr_icode, target, arg1_rtx, arg2_rtx,\n+\t\t\t    MIN (arg1_align, arg2_align));\n \n-\t  /* If both arguments have side effects, we cannot optimize.  */\n-\t  if (len && !TREE_SIDE_EFFECTS (len))\n-\t    {\n-\t      arg3_rtx = expand_normal (len);\n-\t      result = expand_cmpstrn_or_cmpmem\n-\t\t(cmpstrn_icode, target, arg1_rtx, arg2_rtx, TREE_TYPE (len),\n-\t\t arg3_rtx, MIN (arg1_align, arg2_align));\n-\t    }\n-\t}\n+  /* Try to determine at least one length and call cmpstrnsi.  */\n+  if (!result && cmpstrn_icode != CODE_FOR_nothing)\n+    {\n+      tree len;\n+      rtx arg3_rtx;\n+\n+      tree len1 = c_strlen (arg1, 1);\n+      tree len2 = c_strlen (arg2, 1);\n+\n+      if (len1)\n+\tlen1 = size_binop (PLUS_EXPR, ssize_int (1), len1);\n+      if (len2)\n+\tlen2 = size_binop (PLUS_EXPR, ssize_int (1), len2);\n+\n+      /* If we don't have a constant length for the first, use the length\n+\t of the second, if we know it.  We don't require a constant for\n+\t this case; some cost analysis could be done if both are available\n+\t but neither is constant.  For now, assume they're equally cheap,\n+\t unless one has side effects.  If both strings have constant lengths,\n+\t use the smaller.  */\n+\n+      if (!len1)\n+\tlen = len2;\n+      else if (!len2)\n+\tlen = len1;\n+      else if (TREE_SIDE_EFFECTS (len1))\n+\tlen = len2;\n+      else if (TREE_SIDE_EFFECTS (len2))\n+\tlen = len1;\n+      else if (TREE_CODE (len1) != INTEGER_CST)\n+\tlen = len2;\n+      else if (TREE_CODE (len2) != INTEGER_CST)\n+\tlen = len1;\n+      else if (tree_int_cst_lt (len1, len2))\n+\tlen = len1;\n+      else\n+\tlen = len2;\n \n-      if (result)\n+      /* If both arguments have side effects, we cannot optimize.  */\n+      if (len && !TREE_SIDE_EFFECTS (len))\n \t{\n-\t  /* Return the value in the proper mode for this function.  */\n-\t  machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n-\t  if (GET_MODE (result) == mode)\n-\t    return result;\n-\t  if (target == 0)\n-\t    return convert_to_mode (mode, result, 0);\n-\t  convert_move (target, result, 0);\n-\t  return target;\n+\t  arg3_rtx = expand_normal (len);\n+\t  result = expand_cmpstrn_or_cmpmem\n+\t    (cmpstrn_icode, target, arg1_rtx, arg2_rtx, TREE_TYPE (len),\n+\t     arg3_rtx, MIN (arg1_align, arg2_align));\n \t}\n+    }\n \n-      /* Expand the library call ourselves using a stabilized argument\n-\t list to avoid re-evaluating the function's arguments twice.  */\n-      fndecl = get_callee_fndecl (exp);\n-      fn = build_call_nofold_loc (EXPR_LOCATION (exp), fndecl, 2, arg1, arg2);\n-      gcc_assert (TREE_CODE (fn) == CALL_EXPR);\n-      CALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (exp);\n-      return expand_call (fn, target, target == const0_rtx);\n+  /* Check to see if the argument was declared attribute nonstring\n+     and if so, issue a warning since at this point it's not known\n+     to be nul-terminated.  */\n+  tree fndecl = get_callee_fndecl (exp);\n+  maybe_warn_nonstring_arg (fndecl, exp);\n+\n+  if (result)\n+    {\n+      /* Return the value in the proper mode for this function.  */\n+      machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n+      if (GET_MODE (result) == mode)\n+\treturn result;\n+      if (target == 0)\n+\treturn convert_to_mode (mode, result, 0);\n+      convert_move (target, result, 0);\n+      return target;\n     }\n-  return NULL_RTX;\n+\n+  /* Expand the library call ourselves using a stabilized argument\n+     list to avoid re-evaluating the function's arguments twice.  */\n+  tree fn = build_call_nofold_loc (EXPR_LOCATION (exp), fndecl, 2, arg1, arg2);\n+  gcc_assert (TREE_CODE (fn) == CALL_EXPR);\n+  CALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (exp);\n+  return expand_call (fn, target, target == const0_rtx);\n }\n \n /* Expand expression EXP, which is a call to the strncmp builtin. Return\n@@ -4591,8 +4591,6 @@ static rtx\n expand_builtin_strncmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n \t\t\tATTRIBUTE_UNUSED machine_mode mode)\n {\n-  location_t loc ATTRIBUTE_UNUSED = EXPR_LOCATION (exp);\n-\n   if (!validate_arglist (exp,\n  \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return NULL_RTX;\n@@ -4601,88 +4599,92 @@ expand_builtin_strncmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n      lengths, and it doesn't have side effects, then emit cmpstrnsi\n      using length MIN(strlen(string)+1, arg3).  */\n   insn_code cmpstrn_icode = direct_optab_handler (cmpstrn_optab, SImode);\n-  if (cmpstrn_icode != CODE_FOR_nothing)\n-  {\n-    tree len, len1, len2, len3;\n-    rtx arg1_rtx, arg2_rtx, arg3_rtx;\n-    rtx result;\n-    tree fndecl, fn;\n-    tree arg1 = CALL_EXPR_ARG (exp, 0);\n-    tree arg2 = CALL_EXPR_ARG (exp, 1);\n-    tree arg3 = CALL_EXPR_ARG (exp, 2);\n-\n-    unsigned int arg1_align = get_pointer_alignment (arg1) / BITS_PER_UNIT;\n-    unsigned int arg2_align = get_pointer_alignment (arg2) / BITS_PER_UNIT;\n-\n-    len1 = c_strlen (arg1, 1);\n-    len2 = c_strlen (arg2, 1);\n-\n-    if (len1)\n-      len1 = size_binop_loc (loc, PLUS_EXPR, ssize_int (1), len1);\n-    if (len2)\n-      len2 = size_binop_loc (loc, PLUS_EXPR, ssize_int (1), len2);\n-\n-    len3 = fold_convert_loc (loc, sizetype, arg3);\n-\n-    /* If we don't have a constant length for the first, use the length\n-       of the second, if we know it.  If neither string is constant length,\n-       use the given length argument.  We don't require a constant for\n-       this case; some cost analysis could be done if both are available\n-       but neither is constant.  For now, assume they're equally cheap,\n-       unless one has side effects.  If both strings have constant lengths,\n-       use the smaller.  */\n-\n-    if (!len1 && !len2)\n-      len = len3;\n-    else if (!len1)\n-      len = len2;\n-    else if (!len2)\n-      len = len1;\n-    else if (TREE_SIDE_EFFECTS (len1))\n-      len = len2;\n-    else if (TREE_SIDE_EFFECTS (len2))\n-      len = len1;\n-    else if (TREE_CODE (len1) != INTEGER_CST)\n-      len = len2;\n-    else if (TREE_CODE (len2) != INTEGER_CST)\n-      len = len1;\n-    else if (tree_int_cst_lt (len1, len2))\n-      len = len1;\n-    else\n-      len = len2;\n-\n-    /* If we are not using the given length, we must incorporate it here.\n-       The actual new length parameter will be MIN(len,arg3) in this case.  */\n-    if (len != len3)\n-      len = fold_build2_loc (loc, MIN_EXPR, TREE_TYPE (len), len, len3);\n-    arg1_rtx = get_memory_rtx (arg1, len);\n-    arg2_rtx = get_memory_rtx (arg2, len);\n-    arg3_rtx = expand_normal (len);\n-    result = expand_cmpstrn_or_cmpmem (cmpstrn_icode, target, arg1_rtx,\n-\t\t\t\t       arg2_rtx, TREE_TYPE (len), arg3_rtx,\n-\t\t\t\t       MIN (arg1_align, arg2_align));\n-    if (result)\n-      {\n-\t/* Return the value in the proper mode for this function.  */\n-\tmode = TYPE_MODE (TREE_TYPE (exp));\n-\tif (GET_MODE (result) == mode)\n-\t  return result;\n-\tif (target == 0)\n-\t  return convert_to_mode (mode, result, 0);\n-\tconvert_move (target, result, 0);\n-\treturn target;\n-      }\n+  if (cmpstrn_icode == CODE_FOR_nothing)\n+    return NULL_RTX;\n \n-    /* Expand the library call ourselves using a stabilized argument\n-       list to avoid re-evaluating the function's arguments twice.  */\n-    fndecl = get_callee_fndecl (exp);\n-    fn = build_call_nofold_loc (EXPR_LOCATION (exp), fndecl, 3,\n-\t\t\t\targ1, arg2, len);\n-    gcc_assert (TREE_CODE (fn) == CALL_EXPR);\n-    CALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (exp);\n-    return expand_call (fn, target, target == const0_rtx);\n-  }\n-  return NULL_RTX;\n+  tree len;\n+\n+  tree arg1 = CALL_EXPR_ARG (exp, 0);\n+  tree arg2 = CALL_EXPR_ARG (exp, 1);\n+  tree arg3 = CALL_EXPR_ARG (exp, 2);\n+\n+  unsigned int arg1_align = get_pointer_alignment (arg1) / BITS_PER_UNIT;\n+  unsigned int arg2_align = get_pointer_alignment (arg2) / BITS_PER_UNIT;\n+\n+  tree len1 = c_strlen (arg1, 1);\n+  tree len2 = c_strlen (arg2, 1);\n+\n+  location_t loc = EXPR_LOCATION (exp);\n+\n+  if (len1)\n+    len1 = size_binop_loc (loc, PLUS_EXPR, ssize_int (1), len1);\n+  if (len2)\n+    len2 = size_binop_loc (loc, PLUS_EXPR, ssize_int (1), len2);\n+\n+  tree len3 = fold_convert_loc (loc, sizetype, arg3);\n+\n+  /* If we don't have a constant length for the first, use the length\n+     of the second, if we know it.  If neither string is constant length,\n+     use the given length argument.  We don't require a constant for\n+     this case; some cost analysis could be done if both are available\n+     but neither is constant.  For now, assume they're equally cheap,\n+     unless one has side effects.  If both strings have constant lengths,\n+     use the smaller.  */\n+\n+  if (!len1 && !len2)\n+    len = len3;\n+  else if (!len1)\n+    len = len2;\n+  else if (!len2)\n+    len = len1;\n+  else if (TREE_SIDE_EFFECTS (len1))\n+    len = len2;\n+  else if (TREE_SIDE_EFFECTS (len2))\n+    len = len1;\n+  else if (TREE_CODE (len1) != INTEGER_CST)\n+    len = len2;\n+  else if (TREE_CODE (len2) != INTEGER_CST)\n+    len = len1;\n+  else if (tree_int_cst_lt (len1, len2))\n+    len = len1;\n+  else\n+    len = len2;\n+\n+  /* If we are not using the given length, we must incorporate it here.\n+     The actual new length parameter will be MIN(len,arg3) in this case.  */\n+  if (len != len3)\n+    len = fold_build2_loc (loc, MIN_EXPR, TREE_TYPE (len), len, len3);\n+  rtx arg1_rtx = get_memory_rtx (arg1, len);\n+  rtx arg2_rtx = get_memory_rtx (arg2, len);\n+  rtx arg3_rtx = expand_normal (len);\n+  rtx result = expand_cmpstrn_or_cmpmem (cmpstrn_icode, target, arg1_rtx,\n+\t\t\t\t\t arg2_rtx, TREE_TYPE (len), arg3_rtx,\n+\t\t\t\t\t MIN (arg1_align, arg2_align));\n+\n+  /* Check to see if the argument was declared attribute nonstring\n+     and if so, issue a warning since at this point it's not known\n+     to be nul-terminated.  */\n+  tree fndecl = get_callee_fndecl (exp);\n+  maybe_warn_nonstring_arg (fndecl, exp);\n+\n+  if (result)\n+    {\n+      /* Return the value in the proper mode for this function.  */\n+      mode = TYPE_MODE (TREE_TYPE (exp));\n+      if (GET_MODE (result) == mode)\n+\treturn result;\n+      if (target == 0)\n+\treturn convert_to_mode (mode, result, 0);\n+      convert_move (target, result, 0);\n+      return target;\n+    }\n+\n+  /* Expand the library call ourselves using a stabilized argument\n+     list to avoid re-evaluating the function's arguments twice.  */\n+  tree fn = build_call_nofold_loc (loc, fndecl, 3, arg1, arg2, len);\n+  gcc_assert (TREE_CODE (fn) == CALL_EXPR);\n+  CALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (exp);\n+  return expand_call (fn, target, target == const0_rtx);\n }\n \n /* Expand a call to __builtin_saveregs, generating the result in TARGET,"}, {"sha": "3eb1f534cf32922f4f6585686101da3e6911a0c9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16155777a6069d69a078fee979d9ad05456256a7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16155777a6069d69a078fee979d9ad05456256a7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=16155777a6069d69a078fee979d9ad05456256a7", "patch": "@@ -1,3 +1,8 @@\n+2017-12-20  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR testsuite/83131\n+\t* c-c++-common/attr-nonstring-4.c: New test.\n+\n 2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* gcc.dg/plugin/poly-int-tests.h (test_nonpoly_multiple_p): New"}, {"sha": "0571e46fc4d6f261d918516784a6e36aa5be4292", "filename": "gcc/testsuite/c-c++-common/attr-nonstring-4.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16155777a6069d69a078fee979d9ad05456256a7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16155777a6069d69a078fee979d9ad05456256a7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-4.c?ref=16155777a6069d69a078fee979d9ad05456256a7", "patch": "@@ -0,0 +1,79 @@\n+/* PR middle-end/83131 - c-c++/common/attr-nonstring-3 failure for strcmp\n+   tests on PowerPC\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wstringop-overflow -ftrack-macro-expansion=0\" }  */\n+\n+#if __cplusplus\n+extern \"C\" {\n+#endif\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern int strcmp (const char*, const char*);\n+extern int strncmp (const char*, const char*, size_t);\n+\n+#if __cplusplus\n+}   /* extern \"C\" */\n+#endif\n+\n+extern char arx[] __attribute__ ((nonstring));\n+extern char ar5[5] __attribute__ ((nonstring));\n+extern char str[];\n+\n+enum { N = sizeof ar5 };\n+enum { X = sizeof ar5 + 1 };\n+\n+\n+int warn_strcmp_cst_1 (void)\n+{\n+  return strcmp (\"bar\", arx);       /* { dg-warning \"argument 2 declared attribute .nonstring.\" } */\n+}\n+\n+int warn_strcmp_cst_2 (void)\n+{\n+  return strcmp (arx, \"foo\");       /* { dg-warning \"argument 1 declared attribute .nonstring.\" } */\n+}\n+\n+\n+int warn_strncmp_cst_1 (void)\n+{\n+  return strncmp (\"bar\", ar5, X);   /* { dg-warning \"argument 2 declared attribute .nonstring.\" } */\n+}\n+\n+int warn_strncmp_cst_2 (void)\n+{\n+  return strncmp (ar5, \"foo\", X);   /* { dg-warning \"argument 1 declared attribute .nonstring.\" } */\n+}\n+\n+\n+int nowarn_strncmp_cst_1 (void)\n+{\n+  return strncmp (\"bar\", ar5, N);\n+}\n+\n+int nowarn_strncmp_cst_2 (void)\n+{\n+  return strncmp (ar5, \"foo\", N);\n+}\n+\n+\n+int warn_strncmp_var_1 (void)\n+{\n+  return strncmp (str, ar5, X);     /* { dg-warning \"argument 2 declared attribute .nonstring.\" } */\n+}\n+\n+int warn_strncmp_var_2 (void)\n+{\n+  return strncmp (ar5, str, X);     /* { dg-warning \"argument 1 declared attribute .nonstring.\" } */\n+}\n+\n+\n+int nowarn_strncmp_var_1 (void)\n+{\n+  return strncmp (str, ar5, N);\n+}\n+\n+int nowarn_strncmp_var_2 (void)\n+{\n+  return strncmp (ar5, str, N);\n+}"}]}