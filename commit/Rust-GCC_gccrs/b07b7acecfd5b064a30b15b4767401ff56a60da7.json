{"sha": "b07b7acecfd5b064a30b15b4767401ff56a60da7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjA3YjdhY2VjZmQ1YjA2NGEzMGIxNWI0NzY3NDAxZmY1NmE2MGRhNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-16T14:29:36Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-16T14:29:36Z"}, "message": "[multiple changes]\n\n2014-07-16  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch7.adb (Process_Declarations): Reinstate the check on\n\ta hook object to ensure that the related transient declaration\n\tis finalizable.\n\t* exp_util.adb (Is_Aliased): Do not consider expresison with\n\tactions as a special context.\n\t(Requires_Cleanup_Actions): Reinstate the check on a hook object to\n\tensure that the related transient declaration is finalizable.\n\n2014-07-16  Robert Dewar  <dewar@adacore.com>\n\n\t* checks.ads, checks.adb (Allocation_Checks_Suppressed): New function.\n\t* snames.ads-tmpl: Add Allocation_Check to list of check names.\n\t* types.ads: Add Allocation_Check to list of check names.\n\n2014-07-16  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_util.adb (Enter_Name): replace bogus test for presence of\n\tCorresponding_Remote_Type with correct test on Ekind.\n\t* sem_res.adb (Valid_Conversion): ditto; also clarify validity\n\tof calls to Corresponding_ Remote_Type (documentation fix).\n\n2014-07-16  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_rm.texi: Document illegal case of Unrestricted_Access.\n\t* sem_attr.adb (Analyze_Access_Attribute): Set_Non_Aliased_Prefix\n\twhere it applies.\n\t(Resolve_Attribute, case Access): Flag illegal Unrestricted_Access use.\n\t* sinfo.ads, sinfo.adb (Non_Aliased_Prefix): New flag.\n\nFrom-SVN: r212655", "tree": {"sha": "270eac77157878d2ac1d4ba2c4b9f07f95787c34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/270eac77157878d2ac1d4ba2c4b9f07f95787c34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b07b7acecfd5b064a30b15b4767401ff56a60da7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b07b7acecfd5b064a30b15b4767401ff56a60da7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b07b7acecfd5b064a30b15b4767401ff56a60da7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b07b7acecfd5b064a30b15b4767401ff56a60da7/comments", "author": null, "committer": null, "parents": [{"sha": "904aac81db2a08a89fcfd6321cdf5b1f328d94ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/904aac81db2a08a89fcfd6321cdf5b1f328d94ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/904aac81db2a08a89fcfd6321cdf5b1f328d94ee"}], "stats": {"total": 321, "additions": 254, "deletions": 67}, "files": [{"sha": "a71091158fe9a05b698eab484dc1edb1609c5b18", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b07b7acecfd5b064a30b15b4767401ff56a60da7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b07b7acecfd5b064a30b15b4767401ff56a60da7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b07b7acecfd5b064a30b15b4767401ff56a60da7", "patch": "@@ -1,3 +1,34 @@\n+2014-07-16  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch7.adb (Process_Declarations): Reinstate the check on\n+\ta hook object to ensure that the related transient declaration\n+\tis finalizable.\n+\t* exp_util.adb (Is_Aliased): Do not consider expresison with\n+\tactions as a special context.\n+\t(Requires_Cleanup_Actions): Reinstate the check on a hook object to\n+\tensure that the related transient declaration is finalizable.\n+\n+2014-07-16  Robert Dewar  <dewar@adacore.com>\n+\n+\t* checks.ads, checks.adb (Allocation_Checks_Suppressed): New function.\n+\t* snames.ads-tmpl: Add Allocation_Check to list of check names.\n+\t* types.ads: Add Allocation_Check to list of check names.\n+\n+2014-07-16  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_util.adb (Enter_Name): replace bogus test for presence of\n+\tCorresponding_Remote_Type with correct test on Ekind.\n+\t* sem_res.adb (Valid_Conversion): ditto; also clarify validity\n+\tof calls to Corresponding_ Remote_Type (documentation fix).\n+\n+2014-07-16  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat_rm.texi: Document illegal case of Unrestricted_Access.\n+\t* sem_attr.adb (Analyze_Access_Attribute): Set_Non_Aliased_Prefix\n+\twhere it applies.\n+\t(Resolve_Attribute, case Access): Flag illegal Unrestricted_Access use.\n+\t* sinfo.ads, sinfo.adb (Non_Aliased_Prefix): New flag.\n+\n 2014-07-16  Robert Dewar  <dewar@adacore.com>\n \n \t* gnat_ugn.texi: Document binder switch -Ra."}, {"sha": "87777debae71dbcd92fa42075fb2e6072416488d", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b07b7acecfd5b064a30b15b4767401ff56a60da7/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b07b7acecfd5b064a30b15b4767401ff56a60da7/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=b07b7acecfd5b064a30b15b4767401ff56a60da7", "patch": "@@ -419,6 +419,19 @@ package body Checks is\n       end if;\n    end Alignment_Checks_Suppressed;\n \n+   ----------------------------------\n+   -- Allocation_Checks_Suppressed --\n+   ----------------------------------\n+\n+   function Allocation_Checks_Suppressed (E : Entity_Id) return Boolean is\n+   begin\n+      if Present (E) and then Checks_May_Be_Suppressed (E) then\n+         return Is_Check_Suppressed (E, Allocation_Check);\n+      else\n+         return Scope_Suppress.Suppress (Allocation_Check);\n+      end if;\n+   end Allocation_Checks_Suppressed;\n+\n    -------------------------\n    -- Append_Range_Checks --\n    -------------------------"}, {"sha": "f825e5e22a4a857ed8b75917dd76a872d071ef92", "filename": "gcc/ada/checks.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b07b7acecfd5b064a30b15b4767401ff56a60da7/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b07b7acecfd5b064a30b15b4767401ff56a60da7/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=b07b7acecfd5b064a30b15b4767401ff56a60da7", "patch": "@@ -50,6 +50,7 @@ package Checks is\n    function Access_Checks_Suppressed          (E : Entity_Id) return Boolean;\n    function Accessibility_Checks_Suppressed   (E : Entity_Id) return Boolean;\n    function Alignment_Checks_Suppressed       (E : Entity_Id) return Boolean;\n+   function Allocation_Checks_Suppressed      (E : Entity_Id) return Boolean;\n    function Atomic_Synchronization_Disabled   (E : Entity_Id) return Boolean;\n    function Discriminant_Checks_Suppressed    (E : Entity_Id) return Boolean;\n    function Division_Checks_Suppressed        (E : Entity_Id) return Boolean;"}, {"sha": "bee169d32ad47d59e8f0363f46b13e956fefbd8f", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b07b7acecfd5b064a30b15b4767401ff56a60da7/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b07b7acecfd5b064a30b15b4767401ff56a60da7/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=b07b7acecfd5b064a30b15b4767401ff56a60da7", "patch": "@@ -1825,6 +1825,8 @@ package body Exp_Ch7 is\n                  and then Present (Status_Flag_Or_Transient_Decl (Obj_Id))\n                  and then Nkind (Status_Flag_Or_Transient_Decl (Obj_Id)) =\n                                    N_Object_Declaration\n+                 and then Is_Finalizable_Transient\n+                            (Status_Flag_Or_Transient_Decl (Obj_Id), Decl)\n                then\n                   Processing_Actions (Has_No_Init => True);\n "}, {"sha": "2d2d7f59c1e16f28ca03aadf71af6860fe71fdc9", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b07b7acecfd5b064a30b15b4767401ff56a60da7/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b07b7acecfd5b064a30b15b4767401ff56a60da7/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=b07b7acecfd5b064a30b15b4767401ff56a60da7", "patch": "@@ -4562,18 +4562,7 @@ package body Exp_Util is\n             elsif Nkind (Stmt) = N_Object_Renaming_Declaration then\n                Ren_Obj := Find_Renamed_Object (Stmt);\n \n-               if Present (Ren_Obj)\n-                 and then Ren_Obj = Trans_Id\n-\n-                 --  When the related context is an expression with actions,\n-                 --  both the transient controlled object and its renaming are\n-                 --  bound by the \"scope\" of the expression with actions. In\n-                 --  other words, the two cannot be visible outside the scope,\n-                 --  therefore the lifetime of the transient object is not\n-                 --  really extended by the renaming.\n-\n-                 and then Nkind (Rel_Node) /= N_Expression_With_Actions\n-               then\n+               if Present (Ren_Obj) and then Ren_Obj = Trans_Id then\n                   return True;\n                end if;\n             end if;\n@@ -7344,6 +7333,8 @@ package body Exp_Util is\n               and then Present (Status_Flag_Or_Transient_Decl (Obj_Id))\n               and then Nkind (Status_Flag_Or_Transient_Decl (Obj_Id)) =\n                                                         N_Object_Declaration\n+              and then Is_Finalizable_Transient\n+                         (Status_Flag_Or_Transient_Decl (Obj_Id), Decl)\n             then\n                return True;\n "}, {"sha": "07816984b3750bed0a5a3033d4cb70d06b7e81f8", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 58, "deletions": 14, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b07b7acecfd5b064a30b15b4767401ff56a60da7/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b07b7acecfd5b064a30b15b4767401ff56a60da7/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=b07b7acecfd5b064a30b15b4767401ff56a60da7", "patch": "@@ -9551,22 +9551,65 @@ is in scope (normal Ada accessibility rules restrict this usage).\n \n It is possible to use @code{Unrestricted_Access} for any type, but care\n must be exercised if it is used to create pointers to unconstrained array\n-objects. In this case, the resulting pointer has the same scope as the\n+objects.  In this case, the resulting pointer has the same scope as the\n context of the attribute, and may not be returned to some enclosing\n-scope. For instance, a function cannot use @code{Unrestricted_Access}\n+scope.  For instance, a function cannot use @code{Unrestricted_Access}\n to create a unconstrained pointer and then return that value to the\n-caller. In addition, it is only valid to create pointers to unconstrained\n+caller.  In addition, it is only valid to create pointers to unconstrained\n arrays using this attribute if the pointer has the normal default ``fat''\n representation where a pointer has two components, one points to the array\n-and one points to the bounds. If a size clause is used to force ``thin''\n+and one points to the bounds.  If a size clause is used to force ``thin''\n representation for a pointer to unconstrained where there is only space for\n-a single pointer, then any use of @code{Unrestricted_Access}\n-to create a value of such a type (e.g. by conversion from fat to\n-thin pointers) is erroneous. Consider the following example:\n+a single pointer, then the resulting pointer is not usable.\n+\n+In the simple case where a direct use of Unrestricted_Access attempts\n+to make a thin pointer for a non-aliased object, the compiler will\n+reject the use as illegal, as shown in the following example:\n \n @smallexample @c ada\n with System; use System;\n+procedure SliceUA2 is\n+   type A is access all String;\n+   for A'Size use Standard'Address_Size;\n+\n+   procedure P (Arg : A) is\n+   begin\n+      null;\n+   end P;\n+\n+   X : String := \"hello world!\";\n+   X2 : aliased String := \"hello world!\";\n+\n+   AV : A := X'Unrestricted_Access;    -- ERROR\n+             |\n+>>> illegal use of Unrestricted_Access attribute\n+>>> attempt to generate thin pointer to unaliased object\n+\n+begin\n+   P (X'Unrestricted_Access);          -- ERROR\n+      |\n+>>> illegal use of Unrestricted_Access attribute\n+>>> attempt to generate thin pointer to unaliased object\n+\n+   P (X(7 .. 12)'Unrestricted_Access); -- ERROR\n+      |\n+>>> illegal use of Unrestricted_Access attribute\n+>>> attempt to generate thin pointer to unaliased object\n+\n+   P (X2'Unrestricted_Access);         -- OK\n+end;\n+@end smallexample\n+\n+@noindent\n+but other cases cannot be detected by the compiler, and are\n+considered to be erroneous. Consider the following example:\n+\n+@smallexample @c ada\n+with System; use System;\n+with System; use System;\n procedure SliceUA is\n+   type AF is access all String;\n+\n    type A is access all String;\n    for A'Size use Standard'Address_Size;\n \n@@ -9578,28 +9621,29 @@ procedure SliceUA is\n    end P;\n \n    X : String := \"hello world!\";\n+   Y : AF := X (7 .. 12)'Unrestricted_Access;\n \n begin\n-   P (X(7 .. 12)'Unrestricted_Access);\n+   P (A (Y));\n end;\n @end smallexample\n \n @noindent\n-This inevitably raises @code{Program_Error}.\n A normal unconstrained array value\n or a constrained array object marked as aliased has the bounds in memory\n just before the array, so a thin pointer can retrieve both the data and\n-the bounds. But in this case, the non-aliased object @code{X} does not have the\n-bounds before the string. If the size clause for type @code{A}\n+the bounds.  But in this case, the non-aliased object @code{X} does not have the\n+bounds before the string.  If the size clause for type @code{A}\n were not present, then the pointer\n would be a fat pointer, where one component is a pointer to the bounds,\n-and all would be well. But with the size clause present, the conversion from\n-fat pointer to think pointer in the call looses the bounds.\n+and all would be well.  But with the size clause present, the conversion from\n+fat pointer to thin pointer in the call looses the bounds, and so this\n+program raises a @code{Program_Error} exception if executed.\n \n In general, it is advisable to completely\n avoid mixing the use of thin pointers and the use of\n @code{Unrestricted_Access} where the designated type is an\n-unconstrained array. The use of thin pointers should be restricted to\n+unconstrained array.  The use of thin pointers should be restricted to\n cases of porting legacy code which implicitly assumes the size of pointers,\n and such code should not in any case be using this attribute.\n "}, {"sha": "8c46dd87f707e8309c11554cd3f976bdf3bbccf0", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 77, "deletions": 22, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b07b7acecfd5b064a30b15b4767401ff56a60da7/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b07b7acecfd5b064a30b15b4767401ff56a60da7/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=b07b7acecfd5b064a30b15b4767401ff56a60da7", "patch": "@@ -764,9 +764,7 @@ package body Sem_Attr is\n \n          --  Case of access to subprogram\n \n-         if Is_Entity_Name (P)\n-           and then Is_Overloadable (Entity (P))\n-         then\n+         if Is_Entity_Name (P) and then Is_Overloadable (Entity (P)) then\n             if Has_Pragma_Inline_Always (Entity (P)) then\n                Error_Attr_P\n                  (\"prefix of % attribute cannot be Inline_Always subprogram\");\n@@ -961,15 +959,17 @@ package body Sem_Attr is\n             end if;\n          end if;\n \n-         --  If we fall through, we have a normal access to object case.\n-         --  Unrestricted_Access is legal wherever an allocator would be\n-         --  legal, so its Etype is set to E_Allocator. The expected type\n+         --  If we fall through, we have a normal access to object case\n+\n+         --  Unrestricted_Access is (for now) legal wherever an allocator would\n+         --  be legal, so its Etype is set to E_Allocator. The expected type\n          --  of the other attributes is a general access type, and therefore\n          --  we label them with E_Access_Attribute_Type.\n \n          if not Is_Overloaded (P) then\n             Acc_Type := Build_Access_Object_Type (P_Type);\n             Set_Etype (N, Acc_Type);\n+\n          else\n             declare\n                Index : Interp_Index;\n@@ -1022,21 +1022,42 @@ package body Sem_Attr is\n             end loop;\n          end;\n \n-         --  Check for aliased view unless unrestricted case. We allow a\n-         --  nonaliased prefix when within an instance because the prefix may\n-         --  have been a tagged formal object, which is defined to be aliased\n-         --  even when the actual might not be (other instance cases will have\n-         --  been caught in the generic). Similarly, within an inlined body we\n-         --  know that the attribute is legal in the original subprogram, and\n-         --  therefore legal in the expansion.\n+         --  Check for aliased view.. We allow a nonaliased prefix when within\n+         --  an instance because the prefix may have been a tagged formal\n+         --  object, which is defined to be aliased even when the actual\n+         --  might not be (other instance cases will have been caught in the\n+         --  generic). Similarly, within an inlined body we know that the\n+         --  attribute is legal in the original subprogram, and therefore\n+         --  legal in the expansion.\n \n-         if Aname /= Name_Unrestricted_Access\n-           and then not Is_Aliased_View (P)\n+         if not Is_Aliased_View (P)\n            and then not In_Instance\n            and then not In_Inlined_Body\n          then\n-            Error_Attr_P (\"prefix of % attribute must be aliased\");\n-            Check_No_Implicit_Aliasing (P);\n+            --  Here we have a non-aliased view. This is illegal unless we\n+            --  have the case of Unrestricted_Access, where for now we allow\n+            --  this (we will reject later if expected type is access to an\n+            --  unconstrained array with a thin pointer).\n+\n+            if Aname /= Name_Unrestricted_Access then\n+               Error_Attr_P (\"prefix of % attribute must be aliased\");\n+               Check_No_Implicit_Aliasing (P);\n+\n+            --  For Unrestricted_Access, record that prefix is not aliased\n+            --  to simplify legality check later on.\n+\n+            else\n+               Set_Non_Aliased_Prefix (N);\n+            end if;\n+\n+         --  If we have an aliased view, and we have Unrestricted_Access, then\n+         --  output a warning that Unchecked_Access would have been fine, and\n+         --  change the node to be Unchecked_Access.\n+\n+         else\n+            --  For now, hold off on this change ???\n+\n+            null;\n          end if;\n       end Analyze_Access_Attribute;\n \n@@ -9726,10 +9747,10 @@ package body Sem_Attr is\n                Note_Possible_Modification (P, Sure => False);\n             end if;\n \n-            --  The following comes from a query by Adam Beneschan, concerning\n-            --  improper use of universal_access in equality tests involving\n-            --  anonymous access types. Another good reason for 'Ref, but\n-            --  for now disable the test, which breaks several filed tests.\n+            --  The following comes from a query concerning improper use of\n+            --  universal_access in equality tests involving anonymous access\n+            --  types. Another good reason for 'Ref, but for now disable the\n+            --  test, which breaks several filed tests???\n \n             if Ekind (Typ) = E_Anonymous_Access_Type\n               and then Nkind_In (Parent (N), N_Op_Eq, N_Op_Ne)\n@@ -9739,7 +9760,12 @@ package body Sem_Attr is\n                Error_Msg_N (\"\\qualify attribute with some access type\", N);\n             end if;\n \n+            --  Case where prefix is an entity name\n+\n             if Is_Entity_Name (P) then\n+\n+               --  Deal with case where prefix itself is overloaded\n+\n                if Is_Overloaded (P) then\n                   Get_First_Interp (P, Index, It);\n                   while Present (It.Nam) loop\n@@ -9772,12 +9798,19 @@ package body Sem_Attr is\n                      Freeze_Before (N, Entity (P));\n                   end if;\n \n+               --  Nothing to do if prefix is a type name\n+\n                elsif Is_Type (Entity (P)) then\n                   null;\n+\n+               --  Otherwise non-overloaded other case, resolve the prefix\n+\n                else\n                   Resolve (P);\n                end if;\n \n+               --  Some further error checks\n+\n                Error_Msg_Name_1 := Aname;\n \n                if not Is_Entity_Name (P) then\n@@ -10109,7 +10142,7 @@ package body Sem_Attr is\n                   or else\n                 Attr_Id = Attribute_Unchecked_Access)\n               and then (Ekind (Btyp) = E_General_Access_Type\n-                          or else Ekind (Btyp) = E_Anonymous_Access_Type)\n+                         or else Ekind (Btyp) = E_Anonymous_Access_Type)\n             then\n                --  Ada 2005 (AI-230): Check the accessibility of anonymous\n                --  access types for stand-alone objects, record and array\n@@ -10358,6 +10391,28 @@ package body Sem_Attr is\n                end if;\n             end if;\n \n+            --  Check for unrestricted access where expected type is a thin\n+            --  pointer to an unconstrained array.\n+\n+            if Non_Aliased_Prefix (N)\n+              and then Has_Size_Clause (Typ)\n+              and then RM_Size (Typ) = System_Address_Size\n+            then\n+               declare\n+                  DT : constant Entity_Id := Designated_Type (Typ);\n+               begin\n+                  if Is_Array_Type (DT) and then not Is_Constrained (DT) then\n+                     Error_Msg_N\n+                       (\"illegal use of Unrestricted_Access attribute\", P);\n+                     Error_Msg_N\n+                       (\"\\attempt to generate thin pointer to unaliased \"\n+                        & \"object\", P);\n+                  end if;\n+               end;\n+            end if;\n+\n+            --  Mark that address of entity is taken\n+\n             if Is_Entity_Name (P) then\n                Set_Address_Taken (Entity (P));\n             end if;"}, {"sha": "4ad60a95cb5903d79b0373ccbb63521f15ca3c11", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b07b7acecfd5b064a30b15b4767401ff56a60da7/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b07b7acecfd5b064a30b15b4767401ff56a60da7/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=b07b7acecfd5b064a30b15b4767401ff56a60da7", "patch": "@@ -11799,7 +11799,12 @@ package body Sem_Res is\n       --  after the return.\n \n       elsif Is_Access_Subprogram_Type (Target_Type)\n-        and then No (Corresponding_Remote_Type (Opnd_Type))\n+\n+        --  Note: this test of Ekind (Opnd_Type) is there to prevent entering\n+        --  this branch in the case of a remote access to subprogram type,\n+        --  which is internally represented as an E_Record_Type.\n+\n+        and then Ekind (Opnd_Type) in Access_Kind\n       then\n          if Ekind (Base_Type (Opnd_Type)) = E_Anonymous_Access_Subprogram_Type\n            and then Is_Entity_Name (Operand)\n@@ -11864,14 +11869,23 @@ package body Sem_Res is\n \n          return True;\n \n-      --  Remote subprogram access types\n+      --  Remote access to subprogram types\n \n       elsif Is_Remote_Access_To_Subprogram_Type (Target_Type)\n         and then Is_Remote_Access_To_Subprogram_Type (Opnd_Type)\n       then\n          --  It is valid to convert from one RAS type to another provided\n          --  that their specification statically match.\n \n+         --  Note: at this point, remote access to subprogram types have been\n+         --  expanded to their E_Record_Type representation, and we need to\n+         --  go back to the original access type definition using the\n+         --  Corresponding_Remote_Type attribute in order to check that the\n+         --  designated profiles match.\n+\n+         pragma Assert (Ekind (Target_Type) = E_Record_Type);\n+         pragma Assert (Ekind (Opnd_Type) = E_Record_Type);\n+\n          Check_Subtype_Conformant\n            (New_Id  =>\n               Designated_Type (Corresponding_Remote_Type (Target_Type)),"}, {"sha": "4aae4f8672c59e07fb373598ee660c6dd26d42b4", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b07b7acecfd5b064a30b15b4767401ff56a60da7/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b07b7acecfd5b064a30b15b4767401ff56a60da7/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=b07b7acecfd5b064a30b15b4767401ff56a60da7", "patch": "@@ -5045,6 +5045,7 @@ package body Sem_Util is\n          --  visibility list (see below).\n \n          elsif Nkind (Parent (Def_Id)) = N_Full_Type_Declaration\n+           and then Ekind (Def_Id) = E_Record_Type\n            and then Present (Corresponding_Remote_Type (Def_Id))\n          then\n             null;"}, {"sha": "ade3b4e643179208c18b3002e919bf390495d984", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b07b7acecfd5b064a30b15b4767401ff56a60da7/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b07b7acecfd5b064a30b15b4767401ff56a60da7/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=b07b7acecfd5b064a30b15b4767401ff56a60da7", "patch": "@@ -2338,6 +2338,14 @@ package body Sinfo is\n       return Flag17 (N);\n    end No_Truncation;\n \n+   function Non_Aliased_Prefix\n+     (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Attribute_Reference);\n+      return Flag18 (N);\n+   end Non_Aliased_Prefix;\n+\n    function Null_Present\n       (N : Node_Id) return Boolean is\n    begin\n@@ -5487,6 +5495,14 @@ package body Sinfo is\n       Set_Flag17 (N, Val);\n    end Set_No_Truncation;\n \n+   procedure Set_Non_Aliased_Prefix\n+     (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Attribute_Reference);\n+      Set_Flag18 (N, Val);\n+   end Set_Non_Aliased_Prefix;\n+\n    procedure Set_Null_Present\n       (N : Node_Id; Val : Boolean := True) is\n    begin"}, {"sha": "521ab0bd9a57e380e3ad7ab927d2cffa6f13f4dc", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b07b7acecfd5b064a30b15b4767401ff56a60da7/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b07b7acecfd5b064a30b15b4767401ff56a60da7/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=b07b7acecfd5b064a30b15b4767401ff56a60da7", "patch": "@@ -1809,6 +1809,13 @@ package Sinfo is\n    --    is used for properly setting out of range values for use by pragmas\n    --    Initialize_Scalars and Normalize_Scalars.\n \n+   --  Non_Aliased_Prefix (Flag18-Sem)\n+   --    Present in N_Attribute_Reference nodes. Set only for the case of an\n+   --    Unrestricted_Access reference whose prefix is non-aliased, which is\n+   --    the case that is permitted for Unrestricted_Access except when the\n+   --    expected type is a thin pointer to unconstrained array. This flag is\n+   --    to assist in detecting this illegal use of Unrestricted_Access.\n+\n    --  Original_Discriminant (Node2-Sem)\n    --    Present in identifiers. Used in references to discriminants that\n    --    appear in generic units. Because the names of the discriminants may be\n@@ -3621,8 +3628,10 @@ package Sinfo is\n       --  Associated_Node (Node4-Sem)\n       --  Do_Overflow_Check (Flag17-Sem)\n       --  Header_Size_Added (Flag11-Sem)\n+      --  Must_Be_Byte_Aligned (Flag14-Sem)\n+      --  Non_Aliased_Prefix (Flag18-Sem)\n       --  Redundant_Use (Flag13-Sem)\n-      --  Must_Be_Byte_Aligned (Flag14)\n+\n       --  plus fields for expression\n \n       --  Note: in Modify_Tree_For_C mode, Max and Min attributes are expanded\n@@ -9242,6 +9251,9 @@ package Sinfo is\n    function No_Truncation\n      (N : Node_Id) return Boolean;    -- Flag17\n \n+   function Non_Aliased_Prefix\n+     (N : Node_Id) return Boolean;    -- Flag18\n+\n    function Null_Present\n      (N : Node_Id) return Boolean;    -- Flag13\n \n@@ -10244,6 +10256,9 @@ package Sinfo is\n    procedure Set_No_Truncation\n      (N : Node_Id; Val : Boolean := True);    -- Flag17\n \n+   procedure Set_Non_Aliased_Prefix\n+     (N : Node_Id; Val : Boolean := True);    -- Flag18\n+\n    procedure Set_Null_Present\n      (N : Node_Id; Val : Boolean := True);    -- Flag13\n \n@@ -12510,6 +12525,7 @@ package Sinfo is\n    pragma Inline (No_Initialization);\n    pragma Inline (No_Minimize_Eliminate);\n    pragma Inline (No_Truncation);\n+   pragma Inline (Non_Aliased_Prefix);\n    pragma Inline (Null_Present);\n    pragma Inline (Null_Exclusion_Present);\n    pragma Inline (Null_Exclusion_In_Return_Present);\n@@ -12840,6 +12856,7 @@ package Sinfo is\n    pragma Inline (Set_No_Initialization);\n    pragma Inline (Set_No_Minimize_Eliminate);\n    pragma Inline (Set_No_Truncation);\n+   pragma Inline (Set_Non_Aliased_Prefix);\n    pragma Inline (Set_Null_Exclusion_Present);\n    pragma Inline (Set_Null_Exclusion_In_Return_Present);\n    pragma Inline (Set_Null_Present);"}, {"sha": "0ea1beb43cb18d905a074870c90b1677029fbd5e", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b07b7acecfd5b064a30b15b4767401ff56a60da7/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b07b7acecfd5b064a30b15b4767401ff56a60da7/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=b07b7acecfd5b064a30b15b4767401ff56a60da7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1096,6 +1096,7 @@ package Snames is\n    Name_Access_Check                   : constant Name_Id := N + $;\n    Name_Accessibility_Check            : constant Name_Id := N + $;\n    Name_Alignment_Check                : constant Name_Id := N + $; -- GNAT\n+   Name_Allocation_Check               : constant Name_Id := N + $;\n    Name_Atomic_Synchronization         : constant Name_Id := N + $; -- GNAT\n    Name_Discriminant_Check             : constant Name_Id := N + $;\n    Name_Division_Check                 : constant Name_Id := N + $;"}, {"sha": "76e95d670920492b9a210f06ba1bc1e4e920ad2d", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b07b7acecfd5b064a30b15b4767401ff56a60da7/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b07b7acecfd5b064a30b15b4767401ff56a60da7/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=b07b7acecfd5b064a30b15b4767401ff56a60da7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -665,23 +665,24 @@ package Types is\n    Access_Check           : constant :=  1;\n    Accessibility_Check    : constant :=  2;\n    Alignment_Check        : constant :=  3;\n-   Atomic_Synchronization : constant :=  4;\n-   Discriminant_Check     : constant :=  5;\n-   Division_Check         : constant :=  6;\n-   Elaboration_Check      : constant :=  7;\n-   Index_Check            : constant :=  8;\n-   Length_Check           : constant :=  9;\n-   Overflow_Check         : constant := 10;\n-   Predicate_Check        : constant := 11;\n-   Range_Check            : constant := 12;\n-   Storage_Check          : constant := 13;\n-   Tag_Check              : constant := 14;\n-   Validity_Check         : constant := 15;\n+   Allocation_Check       : constant :=  4;\n+   Atomic_Synchronization : constant :=  5;\n+   Discriminant_Check     : constant :=  6;\n+   Division_Check         : constant :=  7;\n+   Elaboration_Check      : constant :=  8;\n+   Index_Check            : constant :=  9;\n+   Length_Check           : constant := 10;\n+   Overflow_Check         : constant := 11;\n+   Predicate_Check        : constant := 12;\n+   Range_Check            : constant := 13;\n+   Storage_Check          : constant := 14;\n+   Tag_Check              : constant := 15;\n+   Validity_Check         : constant := 16;\n    --  Values used to represent individual predefined checks (including the\n    --  setting of Atomic_Synchronization, which is implemented internally using\n    --  a \"check\" whose name is Atomic_Synchronization).\n \n-   All_Checks : constant := 16;\n+   All_Checks : constant := 17;\n    --  Value used to represent All_Checks value\n \n    subtype Predefined_Check_Id is Check_Id range 1 .. All_Checks;\n@@ -704,7 +705,7 @@ package Types is\n \n    --  To add a new check type to GNAT, the following steps are required:\n \n-   --    1.  Add an entry to Snames spec and body for the new name\n+   --    1.  Add an entry to Snames spec for the new name\n    --    2.  Add an entry to the definition of Check_Id above\n    --    3.  Add a new function to Checks to handle the new check test\n    --    4.  Add a new Do_xxx_Check flag to Sinfo (if required)"}]}