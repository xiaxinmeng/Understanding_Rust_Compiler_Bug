{"sha": "ae9c3507829ca139749ac3f9cf4a78707a036d3b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWU5YzM1MDc4MjljYTEzOTc0OWFjM2Y5Y2Y0YTc4NzA3YTAzNmQzYg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-09-16T14:22:36Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-09-16T14:22:36Z"}, "message": "Rewrite part of and_comparisons_1 into match.pd.\n\n2019-09-16  Martin Liska  <mliska@suse.cz>\n\n\t* genmatch.c (dt_node::append_simplify): Do not print\n\twarning when we have duplicate patterns belonging\n\tto a same simplify rule.\n\t* gimple-fold.c (and_comparisons_1): Remove matching moved to match.pd.\n\t(maybe_fold_comparisons_from_match_pd): Handle\n\ttcc_comparison as a results.\n\t* match.pd: Handle (X == CST1) && (X OP2 CST2) conditions.\n\nFrom-SVN: r275750", "tree": {"sha": "7638b464e77dcc7c79132b726b28dbfc8aa0f2a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7638b464e77dcc7c79132b726b28dbfc8aa0f2a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae9c3507829ca139749ac3f9cf4a78707a036d3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae9c3507829ca139749ac3f9cf4a78707a036d3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae9c3507829ca139749ac3f9cf4a78707a036d3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae9c3507829ca139749ac3f9cf4a78707a036d3b/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c16504f6eabad7e173e4fbcfacf52820fffcb9ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c16504f6eabad7e173e4fbcfacf52820fffcb9ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c16504f6eabad7e173e4fbcfacf52820fffcb9ec"}], "stats": {"total": 223, "additions": 92, "deletions": 131}, "files": [{"sha": "cc3a397d7c12f575c40fc8c1878ffb4955192e22", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae9c3507829ca139749ac3f9cf4a78707a036d3b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae9c3507829ca139749ac3f9cf4a78707a036d3b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ae9c3507829ca139749ac3f9cf4a78707a036d3b", "patch": "@@ -1,3 +1,13 @@\n+2019-09-16  Martin Liska  <mliska@suse.cz>\n+\n+\t* genmatch.c (dt_node::append_simplify): Do not print\n+\twarning when we have duplicate patterns belonging\n+\tto a same simplify rule.\n+\t* gimple-fold.c (and_comparisons_1): Remove matching moved to match.pd.\n+\t(maybe_fold_comparisons_from_match_pd): Handle\n+\ttcc_comparison as a results.\n+\t* match.pd: Handle (X == CST1) && (X OP2 CST2) conditions.\n+\n 2019-09-16  Li Jia He  <helijia@linux.ibm.com>\n \t    Qi Feng  <ffengqi@linux.ibm.com>\n "}, {"sha": "cede432cdc9d1d45aea674f6a3ce7f276fd5477b", "filename": "gcc/genmatch.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae9c3507829ca139749ac3f9cf4a78707a036d3b/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae9c3507829ca139749ac3f9cf4a78707a036d3b/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=ae9c3507829ca139749ac3f9cf4a78707a036d3b", "patch": "@@ -1894,10 +1894,15 @@ dt_node *\n dt_node::append_simplify (simplify *s, unsigned pattern_no,\n \t\t\t  dt_operand **indexes)\n {\n+  dt_simplify *s2;\n   dt_simplify *n = new dt_simplify (s, pattern_no, indexes);\n   for (unsigned i = 0; i < kids.length (); ++i)\n-    if (dt_simplify *s2 = dyn_cast <dt_simplify *> (kids[i]))\n+    if ((s2 = dyn_cast <dt_simplify *> (kids[i]))\n+\t&& (verbose >= 1\n+\t    || s->match->location != s2->s->match->location))\n       {\n+\t/* With a nested patters, it's hard to avoid these in order\n+\t   to keep match.pd rules relatively small.  */\n \twarning_at (s->match->location, \"duplicate pattern\");\n \twarning_at (s2->s->match->location, \"previous pattern defined here\");\n \tprint_operand (s->match, stderr);"}, {"sha": "f82bedc6593c8e900199c78758fa95eb3237da3c", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 10, "deletions": 130, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae9c3507829ca139749ac3f9cf4a78707a036d3b/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae9c3507829ca139749ac3f9cf4a78707a036d3b/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=ae9c3507829ca139749ac3f9cf4a78707a036d3b", "patch": "@@ -5620,136 +5620,6 @@ and_comparisons_1 (tree type, enum tree_code code1, tree op1a, tree op1b,\n \treturn t;\n     }\n \n-  /* If both comparisons are of the same value against constants, we might\n-     be able to merge them.  */\n-  if (operand_equal_p (op1a, op2a, 0)\n-      && TREE_CODE (op1b) == INTEGER_CST\n-      && TREE_CODE (op2b) == INTEGER_CST)\n-    {\n-      int cmp = tree_int_cst_compare (op1b, op2b);\n-\n-      /* If we have (op1a == op1b), we should either be able to\n-\t return that or FALSE, depending on whether the constant op1b\n-\t also satisfies the other comparison against op2b.  */\n-      if (code1 == EQ_EXPR)\n-\t{\n-\t  bool done = true;\n-\t  bool val;\n-\t  switch (code2)\n-\t    {\n-\t    case EQ_EXPR: val = (cmp == 0); break;\n-\t    case NE_EXPR: val = (cmp != 0); break;\n-\t    case LT_EXPR: val = (cmp < 0); break;\n-\t    case GT_EXPR: val = (cmp > 0); break;\n-\t    case LE_EXPR: val = (cmp <= 0); break;\n-\t    case GE_EXPR: val = (cmp >= 0); break;\n-\t    default: done = false;\n-\t    }\n-\t  if (done)\n-\t    {\n-\t      if (val)\n-\t\treturn fold_build2 (code1, boolean_type_node, op1a, op1b);\n-\t      else\n-\t\treturn boolean_false_node;\n-\t    }\n-\t}\n-      /* Likewise if the second comparison is an == comparison.  */\n-      else if (code2 == EQ_EXPR)\n-\t{\n-\t  bool done = true;\n-\t  bool val;\n-\t  switch (code1)\n-\t    {\n-\t    case EQ_EXPR: val = (cmp == 0); break;\n-\t    case NE_EXPR: val = (cmp != 0); break;\n-\t    case LT_EXPR: val = (cmp > 0); break;\n-\t    case GT_EXPR: val = (cmp < 0); break;\n-\t    case LE_EXPR: val = (cmp >= 0); break;\n-\t    case GE_EXPR: val = (cmp <= 0); break;\n-\t    default: done = false;\n-\t    }\n-\t  if (done)\n-\t    {\n-\t      if (val)\n-\t\treturn fold_build2 (code2, boolean_type_node, op2a, op2b);\n-\t      else\n-\t\treturn boolean_false_node;\n-\t    }\n-\t}\n-\n-      /* Same business with inequality tests.  */\n-      else if (code1 == NE_EXPR)\n-\t{\n-\t  bool val;\n-\t  switch (code2)\n-\t    {\n-\t    case EQ_EXPR: val = (cmp != 0); break;\n-\t    case NE_EXPR: val = (cmp == 0); break;\n-\t    case LT_EXPR: val = (cmp >= 0); break;\n-\t    case GT_EXPR: val = (cmp <= 0); break;\n-\t    case LE_EXPR: val = (cmp > 0); break;\n-\t    case GE_EXPR: val = (cmp < 0); break;\n-\t    default:\n-\t      val = false;\n-\t    }\n-\t  if (val)\n-\t    return fold_build2 (code2, boolean_type_node, op2a, op2b);\n-\t}\n-      else if (code2 == NE_EXPR)\n-\t{\n-\t  bool val;\n-\t  switch (code1)\n-\t    {\n-\t    case EQ_EXPR: val = (cmp == 0); break;\n-\t    case NE_EXPR: val = (cmp != 0); break;\n-\t    case LT_EXPR: val = (cmp <= 0); break;\n-\t    case GT_EXPR: val = (cmp >= 0); break;\n-\t    case LE_EXPR: val = (cmp < 0); break;\n-\t    case GE_EXPR: val = (cmp > 0); break;\n-\t    default:\n-\t      val = false;\n-\t    }\n-\t  if (val)\n-\t    return fold_build2 (code1, boolean_type_node, op1a, op1b);\n-\t}\n-\n-      /* Chose the more restrictive of two < or <= comparisons.  */\n-      else if ((code1 == LT_EXPR || code1 == LE_EXPR)\n-\t       && (code2 == LT_EXPR || code2 == LE_EXPR))\n-\t{\n-\t  if ((cmp < 0) || (cmp == 0 && code1 == LT_EXPR))\n-\t    return fold_build2 (code1, boolean_type_node, op1a, op1b);\n-\t  else\n-\t    return fold_build2 (code2, boolean_type_node, op2a, op2b);\n-\t}\n-\n-      /* Likewise chose the more restrictive of two > or >= comparisons.  */\n-      else if ((code1 == GT_EXPR || code1 == GE_EXPR)\n-\t       && (code2 == GT_EXPR || code2 == GE_EXPR))\n-\t{\n-\t  if ((cmp > 0) || (cmp == 0 && code1 == GT_EXPR))\n-\t    return fold_build2 (code1, boolean_type_node, op1a, op1b);\n-\t  else\n-\t    return fold_build2 (code2, boolean_type_node, op2a, op2b);\n-\t}\n-\n-      /* Check for singleton ranges.  */\n-      else if (cmp == 0\n-\t       && ((code1 == LE_EXPR && code2 == GE_EXPR)\n-\t\t   || (code1 == GE_EXPR && code2 == LE_EXPR)))\n-\treturn fold_build2 (EQ_EXPR, boolean_type_node, op1a, op2b);\n-\n-      /* Check for disjoint ranges. */\n-      else if (cmp <= 0\n-\t       && (code1 == LT_EXPR || code1 == LE_EXPR)\n-\t       && (code2 == GT_EXPR || code2 == GE_EXPR))\n-\treturn boolean_false_node;\n-      else if (cmp >= 0\n-\t       && (code1 == GT_EXPR || code1 == GE_EXPR)\n-\t       && (code2 == LT_EXPR || code2 == LE_EXPR))\n-\treturn boolean_false_node;\n-    }\n-\n   /* Perhaps the first comparison is (NAME != 0) or (NAME == 1) where\n      NAME's definition is a truth value.  See if there are any simplifications\n      that can be done against the NAME's definition.  */\n@@ -5899,6 +5769,16 @@ maybe_fold_comparisons_from_match_pd (tree type, enum tree_code code,\n \t  else\n \t    return res;\n \t}\n+      else if (op.code.is_tree_code ()\n+\t       && TREE_CODE_CLASS ((tree_code)op.code) == tcc_comparison)\n+\t{\n+\t  tree op0 = op.ops[0];\n+\t  tree op1 = op.ops[1];\n+\t  if (op0 == lhs1 || op0 == lhs2 || op1 == lhs1 || op1 == lhs2)\n+\t    return NULL_TREE;  /* not simple */\n+\n+\t  return build2 ((enum tree_code)op.code, op.type, op0, op1);\n+\t}\n     }\n \n   return NULL_TREE;"}, {"sha": "ac80dd7dd152546de1e99ff57bf7163bfdaec35e", "filename": "gcc/match.pd", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae9c3507829ca139749ac3f9cf4a78707a036d3b/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae9c3507829ca139749ac3f9cf4a78707a036d3b/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=ae9c3507829ca139749ac3f9cf4a78707a036d3b", "patch": "@@ -1958,6 +1958,72 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n     (if (eqne == NE_EXPR)\n      { constant_boolean_node (true, type); }))))\n \n+/* Convert (X == CST1) && (X OP2 CST2) to a known value\n+   based on CST1 OP2 CST2.  Similarly for (X != CST1).  */\n+\n+(for code1 (eq ne)\n+ (for code2 (eq ne lt gt le ge)\n+  (simplify\n+   (bit_and:c (code1@3 @0 INTEGER_CST@1) (code2@4 @0 INTEGER_CST@2))\n+    (with\n+     {\n+      int cmp = tree_int_cst_compare (@1, @2);\n+      bool val;\n+      switch (code2)\n+\t {\n+\tcase EQ_EXPR: val = (cmp == 0); break;\n+\tcase NE_EXPR: val = (cmp != 0); break;\n+\tcase LT_EXPR: val = (cmp < 0); break;\n+\tcase GT_EXPR: val = (cmp > 0); break;\n+\tcase LE_EXPR: val = (cmp <= 0); break;\n+\tcase GE_EXPR: val = (cmp >= 0); break;\n+\tdefault: gcc_unreachable ();\n+\t}\n+     }\n+     (switch\n+      (if (code1 == EQ_EXPR && val) @3)\n+      (if (code1 == EQ_EXPR && !val) { constant_boolean_node (false, type); })\n+      (if (code1 == NE_EXPR && !val) @4))))))\n+\n+/* Convert (X OP1 CST1) && (X OP2 CST2).  */\n+\n+(for code1 (lt le gt ge)\n+ (for code2 (lt le gt ge)\n+  (simplify\n+  (bit_and (code1:c@3 @0 INTEGER_CST@1) (code2:c@4 @0 INTEGER_CST@2))\n+   (with\n+    {\n+     int cmp = tree_int_cst_compare (@1, @2);\n+    }\n+    (switch\n+     /* Choose the more restrictive of two < or <= comparisons.  */\n+     (if ((code1 == LT_EXPR || code1 == LE_EXPR)\n+\t  && (code2 == LT_EXPR || code2 == LE_EXPR))\n+      (if ((cmp < 0) || (cmp == 0 && code1 == LT_EXPR))\n+       @3\n+       @4))\n+     /* Likewise chose the more restrictive of two > or >= comparisons.  */\n+     (if ((code1 == GT_EXPR || code1 == GE_EXPR)\n+\t  && (code2 == GT_EXPR || code2 == GE_EXPR))\n+      (if ((cmp > 0) || (cmp == 0 && code1 == GT_EXPR))\n+       @3\n+       @4))\n+     /* Check for singleton ranges.  */\n+     (if (cmp == 0\n+\t  && ((code1 == LE_EXPR && code2 == GE_EXPR)\n+\t    || (code1 == GE_EXPR && code2 == LE_EXPR)))\n+      (eq @0 @1))\n+     /* Check for disjoint ranges.  */\n+     (if (cmp <= 0\n+\t  && (code1 == LT_EXPR || code1 == LE_EXPR)\n+\t  && (code2 == GT_EXPR || code2 == GE_EXPR))\n+      { constant_boolean_node (false, type); })\n+     (if (cmp >= 0\n+\t  && (code1 == GT_EXPR || code1 == GE_EXPR)\n+\t  && (code2 == LT_EXPR || code2 == LE_EXPR))\n+      { constant_boolean_node (false, type); })\n+     )))))\n+\n /* We can't reassociate at all for saturating types.  */\n (if (!TYPE_SATURATING (type))\n "}]}