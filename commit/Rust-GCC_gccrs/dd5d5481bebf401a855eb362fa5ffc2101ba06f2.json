{"sha": "dd5d5481bebf401a855eb362fa5ffc2101ba06f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQ1ZDU0ODFiZWJmNDAxYTg1NWViMzYyZmE1ZmZjMjEwMWJhMDZmMg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2014-09-30T17:13:10Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2014-09-30T17:13:10Z"}, "message": "c-common.h (enum rid): Add RID_IS_TRIVIALLY_ASSIGNABLE and RID_IS_TRIVIALLY_CONSTRUCTIBLE.\n\nc-family/\n\t* c-common.h (enum rid): Add RID_IS_TRIVIALLY_ASSIGNABLE and\n\tRID_IS_TRIVIALLY_CONSTRUCTIBLE.\n\t* c-common.c (c_common_reswords): Add __is_trivially_copyable.\ncp/\n\t* cp-tree.h (cp_trait_kind): Add CPTK_IS_TRIVIALLY_ASSIGNABLE and\n\tCPTK_IS_TRIVIALLY_CONSTRUCTIBLE.\n\t* cxx-pretty-print.c (pp_cxx_trait_expression): Likewise.\n\t* parser.c (cp_parser_primary_expression): Likewise.\n\t(cp_parser_trait_expr): Likewise.  Handle variadic trait.\n\t* semantics.c (trait_expr_value): Likewise.\n\t(finish_trait_expr): Likewise.\n\t(check_trait_type): Handle variadic trait.  Return bool.\n\t* method.c (build_stub_object): Add rvalue reference here.\n\t(locate_fn_flags): Not here.\n\t(check_nontriv, assignable_expr, constructible_expr): New.\n\t(is_trivially_xible): New.\n\nFrom-SVN: r215738", "tree": {"sha": "c1f56382a31559ddcfb99ad632527d6e8849d1e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1f56382a31559ddcfb99ad632527d6e8849d1e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd5d5481bebf401a855eb362fa5ffc2101ba06f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd5d5481bebf401a855eb362fa5ffc2101ba06f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd5d5481bebf401a855eb362fa5ffc2101ba06f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd5d5481bebf401a855eb362fa5ffc2101ba06f2/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b752325e946487109cd3301f81b0301d0bad346d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b752325e946487109cd3301f81b0301d0bad346d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b752325e946487109cd3301f81b0301d0bad346d"}], "stats": {"total": 230, "additions": 221, "deletions": 9}, "files": [{"sha": "b3a71312ad6357e494f177877327b23e170df556", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5d5481bebf401a855eb362fa5ffc2101ba06f2/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5d5481bebf401a855eb362fa5ffc2101ba06f2/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=dd5d5481bebf401a855eb362fa5ffc2101ba06f2", "patch": "@@ -1,5 +1,9 @@\n 2014-09-30  Jason Merrill  <jason@redhat.com>\n \n+\t* c-common.h (enum rid): Add RID_IS_TRIVIALLY_ASSIGNABLE and\n+\tRID_IS_TRIVIALLY_CONSTRUCTIBLE.\n+\t* c-common.c (c_common_reswords): Add __is_trivially_copyable.\n+\n \t* c-common.h (enum rid): Add RID_IS_TRIVIALLY_COPYABLE.\n \t* c-common.c (c_common_reswords): Add __is_trivially_copyable.\n "}, {"sha": "b16d030ae2bcba16ee4ab0d814727035a6f7a0d6", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5d5481bebf401a855eb362fa5ffc2101ba06f2/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5d5481bebf401a855eb362fa5ffc2101ba06f2/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=dd5d5481bebf401a855eb362fa5ffc2101ba06f2", "patch": "@@ -480,6 +480,8 @@ const struct c_common_resword c_common_reswords[] =\n   { \"__is_polymorphic\",\tRID_IS_POLYMORPHIC, D_CXXONLY },\n   { \"__is_standard_layout\", RID_IS_STD_LAYOUT, D_CXXONLY },\n   { \"__is_trivial\",     RID_IS_TRIVIAL, D_CXXONLY },\n+  { \"__is_trivially_assignable\", RID_IS_TRIVIALLY_ASSIGNABLE, D_CXXONLY },\n+  { \"__is_trivially_constructible\", RID_IS_TRIVIALLY_CONSTRUCTIBLE, D_CXXONLY },\n   { \"__is_trivially_copyable\", RID_IS_TRIVIALLY_COPYABLE, D_CXXONLY },\n   { \"__is_union\",\tRID_IS_UNION,\tD_CXXONLY },\n   { \"__label__\",\tRID_LABEL,\t0 },"}, {"sha": "1e3477f7058597abdca2c0e5f00fd7f2024f8e8e", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5d5481bebf401a855eb362fa5ffc2101ba06f2/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5d5481bebf401a855eb362fa5ffc2101ba06f2/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=dd5d5481bebf401a855eb362fa5ffc2101ba06f2", "patch": "@@ -143,6 +143,7 @@ enum rid\n   RID_IS_FINAL,                RID_IS_LITERAL_TYPE,\n   RID_IS_POD,                  RID_IS_POLYMORPHIC,\n   RID_IS_STD_LAYOUT,           RID_IS_TRIVIAL,\n+  RID_IS_TRIVIALLY_ASSIGNABLE, RID_IS_TRIVIALLY_CONSTRUCTIBLE,\n   RID_IS_TRIVIALLY_COPYABLE,\n   RID_IS_UNION,                RID_UNDERLYING_TYPE,\n "}, {"sha": "2fedd372a48fb1605ec46c50defdd6917cffabbf", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5d5481bebf401a855eb362fa5ffc2101ba06f2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5d5481bebf401a855eb362fa5ffc2101ba06f2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=dd5d5481bebf401a855eb362fa5ffc2101ba06f2", "patch": "@@ -1,5 +1,18 @@\n 2014-09-30  Jason Merrill  <jason@redhat.com>\n \n+\t* cp-tree.h (cp_trait_kind): Add CPTK_IS_TRIVIALLY_ASSIGNABLE and\n+\tCPTK_IS_TRIVIALLY_CONSTRUCTIBLE.\n+\t* cxx-pretty-print.c (pp_cxx_trait_expression): Likewise.\n+\t* parser.c (cp_parser_primary_expression): Likewise.\n+\t(cp_parser_trait_expr): Likewise.  Handle variadic trait.\n+\t* semantics.c (trait_expr_value): Likewise.\n+\t(finish_trait_expr): Likewise.\n+\t(check_trait_type): Handle variadic trait.  Return bool.\n+\t* method.c (build_stub_object): Add rvalue reference here.\n+\t(locate_fn_flags): Not here.\n+\t(check_nontriv, assignable_expr, constructible_expr): New.\n+\t(is_trivially_xible): New.\n+\n \t* cp-tree.h (cp_trait_kind): Add CPTK_IS_TRIVIALLY_COPYABLE.\n \t* cxx-pretty-print.c (pp_cxx_trait_expression): Likewise.\n \t* parser.c (cp_parser_primary_expression): Likewise."}, {"sha": "b2b9063a3655605bdaa8aeb4f12bcd402151c115", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5d5481bebf401a855eb362fa5ffc2101ba06f2/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5d5481bebf401a855eb362fa5ffc2101ba06f2/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=dd5d5481bebf401a855eb362fa5ffc2101ba06f2", "patch": "@@ -653,6 +653,8 @@ typedef enum cp_trait_kind\n   CPTK_IS_POLYMORPHIC,\n   CPTK_IS_STD_LAYOUT,\n   CPTK_IS_TRIVIAL,\n+  CPTK_IS_TRIVIALLY_ASSIGNABLE,\n+  CPTK_IS_TRIVIALLY_CONSTRUCTIBLE,\n   CPTK_IS_TRIVIALLY_COPYABLE,\n   CPTK_IS_UNION,\n   CPTK_UNDERLYING_TYPE\n@@ -5521,6 +5523,7 @@ extern tree make_thunk\t\t\t\t(tree, bool, tree, tree);\n extern void finish_thunk\t\t\t(tree);\n extern void use_thunk\t\t\t\t(tree, bool);\n extern bool trivial_fn_p\t\t\t(tree);\n+extern bool is_trivially_xible\t\t\t(enum tree_code, tree, tree);\n extern tree get_defaulted_eh_spec\t\t(tree);\n extern tree unevaluated_noexcept_spec\t\t(void);\n extern void after_nsdmi_defaulted_late_checks   (tree);"}, {"sha": "67e84c0a2405301ee473aea21a447387e42ed167", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5d5481bebf401a855eb362fa5ffc2101ba06f2/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5d5481bebf401a855eb362fa5ffc2101ba06f2/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=dd5d5481bebf401a855eb362fa5ffc2101ba06f2", "patch": "@@ -2393,6 +2393,12 @@ pp_cxx_trait_expression (cxx_pretty_printer *pp, tree t)\n     case CPTK_IS_TRIVIAL:\n       pp_cxx_ws_string (pp, \"__is_trivial\");\n       break;\n+    case CPTK_IS_TRIVIALLY_ASSIGNABLE:\n+      pp_cxx_ws_string (pp, \"__is_trivially_assignable\");\n+      break;\n+    case CPTK_IS_TRIVIALLY_CONSTRUCTIBLE:\n+      pp_cxx_ws_string (pp, \"__is_trivially_constructible\");\n+      break;\n     case CPTK_IS_TRIVIALLY_COPYABLE:\n       pp_cxx_ws_string (pp, \"__is_trivially_copyable\");\n       break;"}, {"sha": "9a2bd0f1055c8561f9640ab52228bd5c3748d345", "filename": "gcc/cp/method.c", "status": "modified", "additions": 109, "deletions": 2, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5d5481bebf401a855eb362fa5ffc2101ba06f2/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5d5481bebf401a855eb362fa5ffc2101ba06f2/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=dd5d5481bebf401a855eb362fa5ffc2101ba06f2", "patch": "@@ -852,6 +852,8 @@ build_stub_type (tree type, int quals, bool rvalue)\n static tree\n build_stub_object (tree reftype)\n {\n+  if (TREE_CODE (reftype) != REFERENCE_TYPE)\n+    reftype = cp_build_reference_type (reftype, /*rval*/true);\n   tree stub = build1 (CONVERT_EXPR, reftype, integer_one_node);\n   return convert_from_reference (stub);\n }\n@@ -889,8 +891,6 @@ locate_fn_flags (tree type, tree name, tree argtype, int flags,\n \t       elt = TREE_CHAIN (elt))\n \t    {\n \t      tree type = TREE_VALUE (elt);\n-\t      if (TREE_CODE (type) != REFERENCE_TYPE)\n-\t\ttype = cp_build_reference_type (type, /*rval*/true);\n \t      tree arg = build_stub_object (type);\n \t      vec_safe_push (args, arg);\n \t    }\n@@ -1001,6 +1001,113 @@ get_inherited_ctor (tree ctor)\n   return fn;\n }\n \n+/* walk_tree helper function for is_trivially_xible.  If *TP is a call,\n+   return it if it calls something other than a trivial special member\n+   function.  */\n+\n+static tree\n+check_nontriv (tree *tp, int *, void *)\n+{\n+  tree fn;\n+  if (TREE_CODE (*tp) == CALL_EXPR)\n+    fn = CALL_EXPR_FN (*tp);\n+  else if (TREE_CODE (*tp) == AGGR_INIT_EXPR)\n+    fn = AGGR_INIT_EXPR_FN (*tp);\n+  else\n+    return NULL_TREE;\n+\n+  if (TREE_CODE (fn) == ADDR_EXPR)\n+    fn = TREE_OPERAND (fn, 0);\n+\n+  if (TREE_CODE (fn) != FUNCTION_DECL\n+      || !trivial_fn_p (fn))\n+    return fn;\n+  return NULL_TREE;\n+}\n+\n+/* Return declval<T>() = declval<U>() treated as an unevaluated operand.  */\n+\n+static tree\n+assignable_expr (tree to, tree from)\n+{\n+  ++cp_unevaluated_operand;\n+  to = build_stub_object (to);\n+  from = build_stub_object (from);\n+  tree r = cp_build_modify_expr (to, NOP_EXPR, from, tf_none);\n+  --cp_unevaluated_operand;\n+  return r;\n+}\n+\n+/* The predicate condition for a template specialization\n+   is_constructible<T, Args...> shall be satisfied if and only if the\n+   following variable definition would be well-formed for some invented\n+   variable t: T t(create<Args>()...);\n+\n+   Return something equivalent in well-formedness and triviality.  */\n+\n+static tree\n+constructible_expr (tree to, tree from)\n+{\n+  tree expr;\n+  if (CLASS_TYPE_P (to))\n+    {\n+      tree ctype = to;\n+      vec<tree, va_gc> *args = NULL;\n+      if (TREE_CODE (to) != REFERENCE_TYPE)\n+\tto = cp_build_reference_type (to, /*rval*/false);\n+      tree ob = build_stub_object (to);\n+      for (; from; from = TREE_CHAIN (from))\n+\tvec_safe_push (args, build_stub_object (TREE_VALUE (from)));\n+      expr = build_special_member_call (ob, complete_ctor_identifier, &args,\n+\t\t\t\t\tctype, LOOKUP_NORMAL, tf_none);\n+      if (expr == error_mark_node)\n+\treturn error_mark_node;\n+      /* The current state of the standard vis-a-vis LWG 2116 is that\n+\t is_*constructible involves destruction as well.  */\n+      if (type_build_dtor_call (ctype))\n+\t{\n+\t  tree dtor = build_special_member_call (ob, complete_dtor_identifier,\n+\t\t\t\t\t\t NULL, ctype, LOOKUP_NORMAL,\n+\t\t\t\t\t\t tf_none);\n+\t  if (dtor == error_mark_node)\n+\t    return error_mark_node;\n+\t  if (!TYPE_HAS_TRIVIAL_DESTRUCTOR (ctype))\n+\t    expr = build2 (COMPOUND_EXPR, void_type_node, expr, dtor);\n+\t}\n+    }\n+  else\n+    {\n+      if (TREE_CHAIN (from))\n+\treturn error_mark_node; // too many initializers\n+      from = build_stub_object (TREE_VALUE (from));\n+      expr = perform_direct_initialization_if_possible (to, from,\n+\t\t\t\t\t\t\t/*cast*/false,\n+\t\t\t\t\t\t\ttf_none);\n+    }\n+  return expr;\n+}\n+\n+/* Returns true iff TO is trivially assignable (if CODE is MODIFY_EXPR) or\n+   constructible (otherwise) from FROM, which is a single type for\n+   assignment or a list of types for construction.  */\n+\n+bool\n+is_trivially_xible (enum tree_code code, tree to, tree from)\n+{\n+  tree expr;\n+  if (code == MODIFY_EXPR)\n+    expr = assignable_expr (to, from);\n+  else if (from && TREE_CHAIN (from))\n+    return false; // only 0- and 1-argument ctors can be trivial\n+  else\n+    expr = constructible_expr (to, from);\n+\n+  if (expr == error_mark_node)\n+    return false;\n+  tree nt = cp_walk_tree_without_duplicates (&expr, check_nontriv, NULL);\n+  return !nt;\n+}\n+\n /* Subroutine of synthesized_method_walk.  Update SPEC_P, TRIVIAL_P and\n    DELETED_P or give an error message MSG with argument ARG.  */\n "}, {"sha": "e4aaf53fa6c8759cd6efbcd0012135b1cf35540d", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5d5481bebf401a855eb362fa5ffc2101ba06f2/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5d5481bebf401a855eb362fa5ffc2101ba06f2/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=dd5d5481bebf401a855eb362fa5ffc2101ba06f2", "patch": "@@ -4490,6 +4490,8 @@ cp_parser_primary_expression (cp_parser *parser,\n \tcase RID_IS_POLYMORPHIC:\n \tcase RID_IS_STD_LAYOUT:\n \tcase RID_IS_TRIVIAL:\n+\tcase RID_IS_TRIVIALLY_ASSIGNABLE:\n+\tcase RID_IS_TRIVIALLY_CONSTRUCTIBLE:\n \tcase RID_IS_TRIVIALLY_COPYABLE:\n \tcase RID_IS_UNION:\n \t  return cp_parser_trait_expr (parser, token->keyword);\n@@ -8664,6 +8666,7 @@ cp_parser_trait_expr (cp_parser* parser, enum rid keyword)\n   cp_trait_kind kind;\n   tree type1, type2 = NULL_TREE;\n   bool binary = false;\n+  bool variadic = false;\n \n   switch (keyword)\n     {\n@@ -8725,6 +8728,14 @@ cp_parser_trait_expr (cp_parser* parser, enum rid keyword)\n     case RID_IS_TRIVIAL:\n       kind = CPTK_IS_TRIVIAL;\n       break;\n+    case RID_IS_TRIVIALLY_ASSIGNABLE:\n+      kind = CPTK_IS_TRIVIALLY_ASSIGNABLE;\n+      binary = true;\n+      break;\n+    case RID_IS_TRIVIALLY_CONSTRUCTIBLE:\n+      kind = CPTK_IS_TRIVIALLY_CONSTRUCTIBLE;\n+      variadic = true;\n+      break;\n     case RID_IS_TRIVIALLY_COPYABLE:\n       kind = CPTK_IS_TRIVIALLY_COPYABLE;\n       break;\n@@ -8763,6 +8774,17 @@ cp_parser_trait_expr (cp_parser* parser, enum rid keyword)\n       if (type2 == error_mark_node)\n \treturn error_mark_node;\n     }\n+  else if (variadic)\n+    {\n+      while (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  tree elt = cp_parser_type_id (parser);\n+\t  if (elt == error_mark_node)\n+\t    return error_mark_node;\n+\t  type2 = tree_cons (NULL_TREE, elt, type2);\n+\t}\n+    }\n \n   cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n "}, {"sha": "756982667b1b02abbfa9016b4647be904dd70abb", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5d5481bebf401a855eb362fa5ffc2101ba06f2/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5d5481bebf401a855eb362fa5ffc2101ba06f2/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=dd5d5481bebf401a855eb362fa5ffc2101ba06f2", "patch": "@@ -7379,6 +7379,12 @@ trait_expr_value (cp_trait_kind kind, tree type1, tree type2)\n     case CPTK_IS_TRIVIAL:\n       return (trivial_type_p (type1));\n \n+    case CPTK_IS_TRIVIALLY_ASSIGNABLE:\n+      return is_trivially_xible (MODIFY_EXPR, type1, type2);\n+\n+    case CPTK_IS_TRIVIALLY_CONSTRUCTIBLE:\n+      return is_trivially_xible (INIT_EXPR, type1, type2);\n+\n     case CPTK_IS_TRIVIALLY_COPYABLE:\n       return (trivially_copyable_p (type1));\n \n@@ -7392,19 +7398,26 @@ trait_expr_value (cp_trait_kind kind, tree type1, tree type2)\n }\n \n /* If TYPE is an array of unknown bound, or (possibly cv-qualified)\n-   void, or a complete type, returns it, otherwise NULL_TREE.  */\n+   void, or a complete type, returns true, otherwise false.  */\n \n-static tree\n+static bool\n check_trait_type (tree type)\n {\n+  if (type == NULL_TREE)\n+    return true;\n+\n+  if (TREE_CODE (type) == TREE_LIST)\n+    return (check_trait_type (TREE_VALUE (type))\n+\t    && check_trait_type (TREE_CHAIN (type)));\n+\n   if (TREE_CODE (type) == ARRAY_TYPE && !TYPE_DOMAIN (type)\n       && COMPLETE_TYPE_P (TREE_TYPE (type)))\n-    return type;\n+    return true;\n \n   if (VOID_TYPE_P (type))\n-    return type;\n+    return true;\n \n-  return complete_type_or_else (strip_array_types (type), NULL_TREE);\n+  return !!complete_type_or_else (strip_array_types (type), NULL_TREE);\n }\n \n /* Process a trait expression.  */\n@@ -7413,8 +7426,7 @@ tree\n finish_trait_expr (cp_trait_kind kind, tree type1, tree type2)\n {\n   if (type1 == error_mark_node\n-      || ((kind == CPTK_IS_BASE_OF)\n-\t  && type2 == error_mark_node))\n+      || type2 == error_mark_node)\n     return error_mark_node;\n \n   if (processing_template_decl)\n@@ -7450,6 +7462,13 @@ finish_trait_expr (cp_trait_kind kind, tree type1, tree type2)\n \treturn error_mark_node;\n       break;\n \n+    case CPTK_IS_TRIVIALLY_ASSIGNABLE:\n+    case CPTK_IS_TRIVIALLY_CONSTRUCTIBLE:\n+      if (!check_trait_type (type1)\n+\t  || !check_trait_type (type2))\n+\treturn error_mark_node;\n+      break;\n+\n     case CPTK_IS_BASE_OF:\n       if (NON_UNION_CLASS_TYPE_P (type1) && NON_UNION_CLASS_TYPE_P (type2)\n \t  && !same_type_ignoring_top_level_qualifiers_p (type1, type2)"}, {"sha": "f558538694c69f6980a040683ac163e83549c832", "filename": "gcc/testsuite/g++.dg/ext/is_trivially_constructible1.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5d5481bebf401a855eb362fa5ffc2101ba06f2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_trivially_constructible1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5d5481bebf401a855eb362fa5ffc2101ba06f2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_trivially_constructible1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fis_trivially_constructible1.C?ref=dd5d5481bebf401a855eb362fa5ffc2101ba06f2", "patch": "@@ -0,0 +1,35 @@\n+// { dg-do compile { target c++11 } }\n+\n+struct A { };\n+struct B { B(); operator int(); };\n+struct C {\n+  C() = default;\n+  C(const C&);\n+  C(C&&) = default;\n+  C& operator=(C&&);\n+  C& operator= (const C&) = default;\n+};\n+struct D { ~D() {} };\n+\n+#define SA(X) static_assert((X),#X)\n+\n+SA(__is_trivially_constructible(A));\n+SA(__is_trivially_constructible(A,A));\n+SA(!__is_trivially_constructible(B));\n+SA(__is_trivially_constructible(B,B));\n+\n+SA(!__is_trivially_constructible(A,B));\n+SA(!__is_trivially_constructible(B,A));\n+\n+SA(__is_trivially_constructible(C));\n+SA(__is_trivially_constructible(C,C));\n+SA(!__is_trivially_constructible(C,C&));\n+SA(__is_trivially_assignable(C,C&));\n+SA(!__is_trivially_assignable(C,C));\n+SA(!__is_trivially_assignable(C,C&&));\n+\n+SA(__is_trivially_constructible(int,int));\n+SA(__is_trivially_constructible(int,double));\n+SA(!__is_trivially_constructible(int,B));\n+\n+SA(!__is_trivially_constructible(D));"}]}