{"sha": "d9cf932c33070383b9e4f9917ecee76a28e762aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDljZjkzMmMzMzA3MDM4M2I5ZTRmOTkxN2VjZWU3NmEyOGU3NjJhYQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2014-11-13T03:02:49Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2014-11-13T03:02:49Z"}, "message": "common.opt (flra-remat): New.\n\n2014-11-12  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* common.opt (flra-remat): New.\n\t* opts.c (default_options_table): Add entry for flra_remat.\n\t* timevar_def (TV_LRA_REMAT): New.\n\t* doc/invoke.texi (-flra-remat): Add description of the new\n\toption.\n\t* doc/passes.texi (-flra-remat): Remove lra-equivs.c and\n\tlra-saves.c.  Add lra-remat.c.\n\t* Makefile.in (OBJS): Add lra-remat.o.\n\t* lra-remat.c: New file.\n\t* lra.c: Add info about the rematerialization pass in the top\n\tcomment.\n\t(collect_non_operand_hard_regs, add_regs_to_insn_regno_info):\n\tProcess unallocatable regs too.\n\t(lra_constraint_new_insn_uid_start): Remove.\n\t(lra): Add code for calling rematerialization sub-pass.\n\t* lra-int.h (lra_constraint_new_insn_uid_start): Remove.\n\t(lra_constrain_insn, lra_remat): New prototypes.\n\t(lra_eliminate_regs_1): Add parameter.\n\t* lra-lives.c (make_hard_regno_born, make_hard_regno_dead):\n\tProcess unallocatable hard regs too.\n\t(process_bb_lives): Ditto.\n\t* lra-spills.c (remove_pseudos): Add argument to\n\tlra_eliminate_regs_1 call.\n\t* lra-eliminations.c (lra_eliminate_regs_1): Add parameter.  Use it\n\tfor sp offset calculation.\n\t(lra_eliminate_regs): Add argument for lra_eliminate_regs_1 call.\n\t(eliminate_regs_in_insn): Add parameter.  Use it for sp offset\n\tcalculation.\n\t(process_insn_for_elimination): Add argument for\n\teliminate_regs_in_insn call.\n\t* lra-constraints.c (get_equiv_with_elimination):  Add argument\n\tfor lra_eliminate_regs_1 call.\n\t(process_addr_reg): Add parameter.  Use it.\n\t(process_address_1): Ditto.  Add argument for process_addr_reg\n\tcall.\n\t(process_address): Ditto.\n\t(curr_insn_transform): Add parameter.  Use it.  Add argument for\n\tprocess_address calls.\n\t(lra_constrain_insn): New function.\n\t(lra_constraints): Add argument for curr_insn_transform call.\n\nFrom-SVN: r217458", "tree": {"sha": "6e275a0a0d4c96a79407def2c6bc8fc0ee919f34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e275a0a0d4c96a79407def2c6bc8fc0ee919f34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9cf932c33070383b9e4f9917ecee76a28e762aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9cf932c33070383b9e4f9917ecee76a28e762aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9cf932c33070383b9e4f9917ecee76a28e762aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9cf932c33070383b9e4f9917ecee76a28e762aa/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "778e02fdc4da78fede96faf39566060bc040727d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/778e02fdc4da78fede96faf39566060bc040727d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/778e02fdc4da78fede96faf39566060bc040727d"}], "stats": {"total": 1692, "additions": 1531, "deletions": 161}, "files": [{"sha": "b089cb8a6e0e7cfd3a91779bc339d5af0d883a55", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9cf932c33070383b9e4f9917ecee76a28e762aa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9cf932c33070383b9e4f9917ecee76a28e762aa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d9cf932c33070383b9e4f9917ecee76a28e762aa", "patch": "@@ -1,3 +1,46 @@\n+2014-11-12  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* common.opt (flra-remat): New.\n+\t* opts.c (default_options_table): Add entry for flra_remat.\n+\t* timevar_def (TV_LRA_REMAT): New.\n+\t* doc/invoke.texi (-flra-remat): Add description of the new\n+\toption.\n+\t* doc/passes.texi (-flra-remat): Remove lra-equivs.c and\n+\tlra-saves.c.  Add lra-remat.c.\n+\t* Makefile.in (OBJS): Add lra-remat.o.\n+\t* lra-remat.c: New file.\n+\t* lra.c: Add info about the rematerialization pass in the top\n+\tcomment.\n+\t(collect_non_operand_hard_regs, add_regs_to_insn_regno_info):\n+\tProcess unallocatable regs too.\n+\t(lra_constraint_new_insn_uid_start): Remove.\n+\t(lra): Add code for calling rematerialization sub-pass.\n+\t* lra-int.h (lra_constraint_new_insn_uid_start): Remove.\n+\t(lra_constrain_insn, lra_remat): New prototypes.\n+\t(lra_eliminate_regs_1): Add parameter.\n+\t* lra-lives.c (make_hard_regno_born, make_hard_regno_dead):\n+\tProcess unallocatable hard regs too.\n+\t(process_bb_lives): Ditto.\n+\t* lra-spills.c (remove_pseudos): Add argument to\n+\tlra_eliminate_regs_1 call.\n+\t* lra-eliminations.c (lra_eliminate_regs_1): Add parameter.  Use it\n+\tfor sp offset calculation.\n+\t(lra_eliminate_regs): Add argument for lra_eliminate_regs_1 call.\n+\t(eliminate_regs_in_insn): Add parameter.  Use it for sp offset\n+\tcalculation.\n+\t(process_insn_for_elimination): Add argument for\n+\teliminate_regs_in_insn call.\n+\t* lra-constraints.c (get_equiv_with_elimination):  Add argument\n+\tfor lra_eliminate_regs_1 call.\n+\t(process_addr_reg): Add parameter.  Use it.\n+\t(process_address_1): Ditto.  Add argument for process_addr_reg\n+\tcall.\n+\t(process_address): Ditto.\n+\t(curr_insn_transform): Add parameter.  Use it.  Add argument for\n+\tprocess_address calls.\n+\t(lra_constrain_insn): New function.\n+\t(lra_constraints): Add argument for curr_insn_transform call.\n+\n 2014-11-13  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \t* opts-global.c (postpone_unknown_option_warning): Fix spelling."}, {"sha": "88c3f8975ff7390d1601b12c88a64cc90c82ec96", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9cf932c33070383b9e4f9917ecee76a28e762aa/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9cf932c33070383b9e4f9917ecee76a28e762aa/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d9cf932c33070383b9e4f9917ecee76a28e762aa", "patch": "@@ -1304,6 +1304,7 @@ OBJS = \\\n \tlra-constraints.o \\\n \tlra-eliminations.o \\\n \tlra-lives.o \\\n+\tlra-remat.o \\\n \tlra-spills.o \\\n \tlto-cgraph.o \\\n \tlto-streamer.o \\"}, {"sha": "1a58cfb0385cb1c56e11351472a36e5e8fbe1c06", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9cf932c33070383b9e4f9917ecee76a28e762aa/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9cf932c33070383b9e4f9917ecee76a28e762aa/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=d9cf932c33070383b9e4f9917ecee76a28e762aa", "patch": "@@ -1551,6 +1551,10 @@ floop-optimize\n Common Ignore\n Does nothing.  Preserved for backward compatibility.\n \n+flra-remat\n+Common Report Var(flag_lra_remat) Optimization\n+Do CFG-sensitive rematerialization in LRA\n+\n flto\n Common\n Enable link-time optimization."}, {"sha": "12dbb2767f4c31faed8daee0ca72d4b7f092235d", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9cf932c33070383b9e4f9917ecee76a28e762aa/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9cf932c33070383b9e4f9917ecee76a28e762aa/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d9cf932c33070383b9e4f9917ecee76a28e762aa", "patch": "@@ -392,7 +392,7 @@ Objective-C and Objective-C++ Dialects}.\n -fisolate-erroneous-paths-dereference -fisolate-erroneous-paths-attribute @gol\n -fivopts -fkeep-inline-functions -fkeep-static-consts -flive-range-shrinkage @gol\n -floop-block -floop-interchange -floop-strip-mine -floop-nest-optimize @gol\n--floop-parallelize-all -flto -flto-compression-level @gol\n+-floop-parallelize-all -flra-remat -flto -flto-compression-level @gol\n -flto-partition=@var{alg} -flto-report -flto-report-wpa -fmerge-all-constants @gol\n -fmerge-constants -fmodulo-sched -fmodulo-sched-allow-regmoves @gol\n -fmove-loop-invariants -fno-branch-count-reg @gol\n@@ -7183,6 +7183,7 @@ also turns on the following optimization flags:\n -fipa-sra @gol\n -fipa-icf @gol\n -fisolate-erroneous-paths-dereference @gol\n+-flra-remat @gol\n -foptimize-sibling-calls @gol\n -foptimize-strlen @gol\n -fpartial-inlining @gol\n@@ -7811,6 +7812,14 @@ Control the verbosity of the dump file for the integrated register allocator.\n The default value is 5.  If the value @var{n} is greater or equal to 10,\n the dump output is sent to stderr using the same format as @var{n} minus 10.\n \n+@item -flra-remat\n+@opindex fcaller-saves\n+Enable CFG-sensitive rematerialization in LRA.  Instead of loading\n+values of spilled pseudos, LRA tries to rematerialize (recalculate)\n+values if it is profitable.\n+\n+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item -fdelayed-branch\n @opindex fdelayed-branch\n If supported for the target machine, attempt to reorder instructions"}, {"sha": "090eb0a6cbcad9d5de73a6ce1f858fbf7c3e4196", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9cf932c33070383b9e4f9917ecee76a28e762aa/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9cf932c33070383b9e4f9917ecee76a28e762aa/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=d9cf932c33070383b9e4f9917ecee76a28e762aa", "patch": "@@ -911,10 +911,10 @@ Source files are @file{reload.c} and @file{reload1.c}, plus the header\n This pass is a modern replacement of the reload pass.  Source files\n are @file{lra.c}, @file{lra-assign.c}, @file{lra-coalesce.c},\n @file{lra-constraints.c}, @file{lra-eliminations.c},\n-@file{lra-equivs.c}, @file{lra-lives.c}, @file{lra-saves.c},\n-@file{lra-spills.c}, the header @file{lra-int.h} used for\n-communication between them, and the header @file{lra.h} used for\n-communication between LRA and the rest of compiler.\n+@file{lra-lives.c}, @file{lra-remat.c}, @file{lra-spills.c}, the\n+header @file{lra-int.h} used for communication between them, and the\n+header @file{lra.h} used for communication between LRA and the rest of\n+compiler.\n \n Unlike the reload pass, intermediate LRA decisions are reflected in\n RTL as much as possible.  This reduces the number of target-dependent"}, {"sha": "a67bf8a2f7ca446495f24e42daca47bbd41e34a4", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 124, "deletions": 64, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9cf932c33070383b9e4f9917ecee76a28e762aa/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9cf932c33070383b9e4f9917ecee76a28e762aa/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=d9cf932c33070383b9e4f9917ecee76a28e762aa", "patch": "@@ -506,7 +506,8 @@ get_equiv_with_elimination (rtx x, rtx_insn *insn)\n \n   if (x == res || CONSTANT_P (res))\n     return res;\n-  return lra_eliminate_regs_1 (insn, res, GET_MODE (res), false, false, true);\n+  return lra_eliminate_regs_1 (insn, res, GET_MODE (res),\n+\t\t\t       0, false, false, true);\n }\n \n /* Set up curr_operand_mode.  */\n@@ -1243,12 +1244,16 @@ static bool no_input_reloads_p, no_output_reloads_p;\n    insn.  */\n static int curr_swapped;\n \n-/* Arrange for address element *LOC to be a register of class CL.\n-   Add any input reloads to list BEFORE.  AFTER is nonnull if *LOC is an\n-   automodified value; handle that case by adding the required output\n-   reloads to list AFTER.  Return true if the RTL was changed.  */\n+/* if CHECK_ONLY_P is false, arrange for address element *LOC to be a\n+   register of class CL.  Add any input reloads to list BEFORE.  AFTER\n+   is nonnull if *LOC is an automodified value; handle that case by\n+   adding the required output reloads to list AFTER.  Return true if\n+   the RTL was changed.\n+\n+   if CHECK_ONLY_P is true, check that the *LOC is a correct address\n+   register.  Return false if the address register is correct.  */\n static bool\n-process_addr_reg (rtx *loc, rtx_insn **before, rtx_insn **after,\n+process_addr_reg (rtx *loc, bool check_only_p, rtx_insn **before, rtx_insn **after,\n \t\t  enum reg_class cl)\n {\n   int regno;\n@@ -1265,6 +1270,8 @@ process_addr_reg (rtx *loc, rtx_insn **before, rtx_insn **after,\n   mode = GET_MODE (reg);\n   if (! REG_P (reg))\n     {\n+      if (check_only_p)\n+\treturn true;\n       /* Always reload memory in an address even if the target supports\n \t such addresses.  */\n       new_reg = lra_create_new_reg_with_unique_value (mode, reg, cl, \"address\");\n@@ -1274,7 +1281,8 @@ process_addr_reg (rtx *loc, rtx_insn **before, rtx_insn **after,\n     {\n       regno = REGNO (reg);\n       rclass = get_reg_class (regno);\n-      if ((*loc = get_equiv_with_elimination (reg, curr_insn)) != reg)\n+      if (! check_only_p\n+\t  && (*loc = get_equiv_with_elimination (reg, curr_insn)) != reg)\n \t{\n \t  if (lra_dump_file != NULL)\n \t    {\n@@ -1288,13 +1296,17 @@ process_addr_reg (rtx *loc, rtx_insn **before, rtx_insn **after,\n \t}\n       if (*loc != reg || ! in_class_p (reg, cl, &new_class))\n \t{\n+\t  if (check_only_p)\n+\t    return true;\n \t  reg = *loc;\n \t  if (get_reload_reg (after == NULL ? OP_IN : OP_INOUT,\n \t\t\t      mode, reg, cl, subreg_p, \"address\", &new_reg))\n \t    before_p = true;\n \t}\n       else if (new_class != NO_REGS && rclass != new_class)\n \t{\n+\t  if (check_only_p)\n+\t    return true;\n \t  lra_change_class (regno, new_class, \"\t   Change to\", true);\n \t  return false;\n \t}\n@@ -2740,8 +2752,9 @@ equiv_address_substitution (struct address_info *ad)\n   return change_p;\n }\n \n-/* Major function to make reloads for an address in operand NOP.\n-   The supported cases are:\n+/* Major function to make reloads for an address in operand NOP or\n+   check its correctness (If CHECK_ONLY_P is true). The supported\n+   cases are:\n \n    1) an address that existed before LRA started, at which point it\n    must have been valid.  These addresses are subject to elimination\n@@ -2761,18 +2774,19 @@ equiv_address_substitution (struct address_info *ad)\n    address.  Return true for any RTL change.\n \n    The function is a helper function which does not produce all\n-   transformations which can be necessary.  It does just basic steps.\n-   To do all necessary transformations use function\n-   process_address.  */\n+   transformations (when CHECK_ONLY_P is false) which can be\n+   necessary.  It does just basic steps.  To do all necessary\n+   transformations use function process_address.  */\n static bool\n-process_address_1 (int nop, rtx_insn **before, rtx_insn **after)\n+process_address_1 (int nop, bool check_only_p,\n+\t\t   rtx_insn **before, rtx_insn **after)\n {\n   struct address_info ad;\n   rtx new_reg;\n   rtx op = *curr_id->operand_loc[nop];\n   const char *constraint = curr_static_id->operand[nop].constraint;\n   enum constraint_num cn = lookup_constraint (constraint);\n-  bool change_p;\n+  bool change_p = false;\n \n   if (insn_extra_address_constraint (cn))\n     decompose_lea_address (&ad, curr_id->operand_loc[nop]);\n@@ -2783,10 +2797,11 @@ process_address_1 (int nop, rtx_insn **before, rtx_insn **after)\n     decompose_mem_address (&ad, SUBREG_REG (op));\n   else\n     return false;\n-  change_p = equiv_address_substitution (&ad);\n+  if (! check_only_p)\n+    change_p = equiv_address_substitution (&ad);\n   if (ad.base_term != NULL\n       && (process_addr_reg\n-\t  (ad.base_term, before,\n+\t  (ad.base_term, check_only_p, before,\n \t   (ad.autoinc_p\n \t    && !(REG_P (*ad.base_term)\n \t\t && find_regno_note (curr_insn, REG_DEAD,\n@@ -2800,7 +2815,8 @@ process_address_1 (int nop, rtx_insn **before, rtx_insn **after)\n \t*ad.base_term2 = *ad.base_term;\n     }\n   if (ad.index_term != NULL\n-      && process_addr_reg (ad.index_term, before, NULL, INDEX_REG_CLASS))\n+      && process_addr_reg (ad.index_term, check_only_p,\n+\t\t\t   before, NULL, INDEX_REG_CLASS))\n     change_p = true;\n \n   /* Target hooks sometimes don't treat extra-constraint addresses as\n@@ -2809,6 +2825,9 @@ process_address_1 (int nop, rtx_insn **before, rtx_insn **after)\n       && satisfies_address_constraint_p (&ad, cn))\n     return change_p;\n \n+  if (check_only_p)\n+    return change_p;\n+\n   /* There are three cases where the shape of *AD.INNER may now be invalid:\n \n      1) the original address was valid, but either elimination or\n@@ -2977,15 +2996,24 @@ process_address_1 (int nop, rtx_insn **before, rtx_insn **after)\n   return true;\n }\n \n-/* Do address reloads until it is necessary.  Use process_address_1 as\n-   a helper function.  Return true for any RTL changes.  */\n+/* If CHECK_ONLY_P is false, do address reloads until it is necessary.\n+   Use process_address_1 as a helper function.  Return true for any\n+   RTL changes.\n+\n+   If CHECK_ONLY_P is true, just check address correctness.  Return\n+   false if the address correct.  */\n static bool\n-process_address (int nop, rtx_insn **before, rtx_insn **after)\n+process_address (int nop, bool check_only_p,\n+\t\t rtx_insn **before, rtx_insn **after)\n {\n   bool res = false;\n \n-  while (process_address_1 (nop, before, after))\n-    res = true;\n+  while (process_address_1 (nop, check_only_p, before, after))\n+    {\n+      if (check_only_p)\n+\treturn true;\n+      res = true;\n+    }\n   return res;\n }\n \n@@ -3157,9 +3185,15 @@ swap_operands (int nop)\n    model can be changed in future.  Make commutative operand exchange\n    if it is chosen.\n \n-   Return true if some RTL changes happened during function call.  */\n+   if CHECK_ONLY_P is false, do RTL changes to satisfy the\n+   constraints.  Return true if any change happened during function\n+   call.\n+\n+   If CHECK_ONLY_P is true then don't do any transformation.  Just\n+   check that the insn satisfies all constraints.  If the insn does\n+   not satisfy any constraint, return true.  */\n static bool\n-curr_insn_transform (void)\n+curr_insn_transform (bool check_only_p)\n {\n   int i, j, k;\n   int n_operands;\n@@ -3226,50 +3260,53 @@ curr_insn_transform (void)\n   curr_swapped = false;\n   goal_alt_swapped = false;\n \n-  /* Make equivalence substitution and memory subreg elimination\n-     before address processing because an address legitimacy can\n-     depend on memory mode.  */\n-  for (i = 0; i < n_operands; i++)\n-    {\n-      rtx op = *curr_id->operand_loc[i];\n-      rtx subst, old = op;\n-      bool op_change_p = false;\n-\n-      if (GET_CODE (old) == SUBREG)\n-\told = SUBREG_REG (old);\n-      subst = get_equiv_with_elimination (old, curr_insn);\n-      if (subst != old)\n-\t{\n-\t  subst = copy_rtx (subst);\n-\t  lra_assert (REG_P (old));\n-\t  if (GET_CODE (op) == SUBREG)\n-\t    SUBREG_REG (op) = subst;\n-\t  else\n-\t    *curr_id->operand_loc[i] = subst;\n-\t  if (lra_dump_file != NULL)\n-\t    {\n-\t      fprintf (lra_dump_file,\n-\t\t       \"Changing pseudo %d in operand %i of insn %u on equiv \",\n-\t\t       REGNO (old), i, INSN_UID (curr_insn));\n-\t      dump_value_slim (lra_dump_file, subst, 1);\n+  if (! check_only_p)\n+    /* Make equivalence substitution and memory subreg elimination\n+       before address processing because an address legitimacy can\n+       depend on memory mode.  */\n+    for (i = 0; i < n_operands; i++)\n+      {\n+\trtx op = *curr_id->operand_loc[i];\n+\trtx subst, old = op;\n+\tbool op_change_p = false;\n+\t\n+\tif (GET_CODE (old) == SUBREG)\n+\t  old = SUBREG_REG (old);\n+\tsubst = get_equiv_with_elimination (old, curr_insn);\n+\tif (subst != old)\n+\t  {\n+\t    subst = copy_rtx (subst);\n+\t    lra_assert (REG_P (old));\n+\t    if (GET_CODE (op) == SUBREG)\n+\t      SUBREG_REG (op) = subst;\n+\t    else\n+\t      *curr_id->operand_loc[i] = subst;\n+\t    if (lra_dump_file != NULL)\n+\t      {\n+\t\tfprintf (lra_dump_file,\n+\t\t\t \"Changing pseudo %d in operand %i of insn %u on equiv \",\n+\t\t\t REGNO (old), i, INSN_UID (curr_insn));\n+\t\tdump_value_slim (lra_dump_file, subst, 1);\n \t      fprintf (lra_dump_file, \"\\n\");\n-\t    }\n-\t  op_change_p = change_p = true;\n-\t}\n-      if (simplify_operand_subreg (i, GET_MODE (old)) || op_change_p)\n-\t{\n-\t  change_p = true;\n-\t  lra_update_dup (curr_id, i);\n-\t}\n-    }\n+\t      }\n+\t    op_change_p = change_p = true;\n+\t  }\n+\tif (simplify_operand_subreg (i, GET_MODE (old)) || op_change_p)\n+\t  {\n+\t    change_p = true;\n+\t    lra_update_dup (curr_id, i);\n+\t  }\n+      }\n \n   /* Reload address registers and displacements.  We do it before\n      finding an alternative because of memory constraints.  */\n   before = after = NULL;\n   for (i = 0; i < n_operands; i++)\n     if (! curr_static_id->operand[i].is_operator\n-\t&& process_address (i, &before, &after))\n+\t&& process_address (i, check_only_p, &before, &after))\n       {\n+\tif (check_only_p)\n+\t  return true;\n \tchange_p = true;\n \tlra_update_dup (curr_id, i);\n       }\n@@ -3279,20 +3316,23 @@ curr_insn_transform (void)\n        we chose previously may no longer be valid.  */\n     lra_set_used_insn_alternative (curr_insn, -1);\n \n-  if (curr_insn_set != NULL_RTX\n+  if (! check_only_p && curr_insn_set != NULL_RTX\n       && check_and_process_move (&change_p, &sec_mem_p))\n     return change_p;\n \n  try_swapped:\n \n-  reused_alternative_num = curr_id->used_insn_alternative;\n+  reused_alternative_num = check_only_p ? -1 : curr_id->used_insn_alternative;\n   if (lra_dump_file != NULL && reused_alternative_num >= 0)\n     fprintf (lra_dump_file, \"Reusing alternative %d for insn #%u\\n\",\n \t     reused_alternative_num, INSN_UID (curr_insn));\n \n   if (process_alt_operands (reused_alternative_num))\n     alt_p = true;\n \n+  if (check_only_p)\n+    return ! alt_p || best_losers != 0;\n+\n   /* If insn is commutative (it's safe to exchange a certain pair of\n      operands) then we need to try each alternative twice, the second\n      time matching those two operands as if we had exchanged them.  To\n@@ -3522,7 +3562,7 @@ curr_insn_transform (void)\n \n \t    *curr_id->operand_loc[i] = tem;\n \t    lra_update_dup (curr_id, i);\n-\t    process_address (i, &before, &after);\n+\t    process_address (i, false, &before, &after);\n \n \t    /* If the alternative accepts constant pool refs directly\n \t       there will be no reload needed at all.  */\n@@ -3746,6 +3786,26 @@ curr_insn_transform (void)\n   return change_p;\n }\n \n+/* Return true if INSN satisfies all constraints.  In other words, no\n+   reload insns are needed.  */\n+bool\n+lra_constrain_insn (rtx_insn *insn)\n+{\n+  int saved_new_regno_start = new_regno_start;\n+  int saved_new_insn_uid_start = new_insn_uid_start;\n+  bool change_p;\n+\n+  curr_insn = insn;\n+  curr_id = lra_get_insn_recog_data (curr_insn);\n+  curr_static_id = curr_id->insn_static_data;\n+  new_insn_uid_start = get_max_uid ();\n+  new_regno_start = max_reg_num ();\n+  change_p = curr_insn_transform (true);\n+  new_regno_start = saved_new_regno_start;\n+  new_insn_uid_start = saved_new_insn_uid_start;\n+  return ! change_p;\n+}\n+\n /* Return true if X is in LIST.\t */\n static bool\n in_list_p (rtx x, rtx list)\n@@ -4238,7 +4298,7 @@ lra_constraints (bool first_p)\n \t  curr_static_id = curr_id->insn_static_data;\n \t  init_curr_insn_input_reloads ();\n \t  init_curr_operand_mode ();\n-\t  if (curr_insn_transform ())\n+\t  if (curr_insn_transform (false))\n \t    changed_p = true;\n \t  /* Check non-transformed insns too for equiv change as USE\n \t     or CLOBBER don't need reloads but can contain pseudos"}, {"sha": "8ab0222ae501fe6bb8c61f4bb5b68b76077c64bc", "filename": "gcc/lra-eliminations.c", "status": "modified", "additions": 62, "deletions": 35, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9cf932c33070383b9e4f9917ecee76a28e762aa/gcc%2Flra-eliminations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9cf932c33070383b9e4f9917ecee76a28e762aa/gcc%2Flra-eliminations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-eliminations.c?ref=d9cf932c33070383b9e4f9917ecee76a28e762aa", "patch": "@@ -298,7 +298,8 @@ get_elimination (rtx reg)\n    a change in the offset between the eliminable register and its\n    substitution if UPDATE_P, or the full offset if FULL_P, or\n    otherwise zero.  If FULL_P, we also use the SP offsets for\n-   elimination to SP.\n+   elimination to SP.  If UPDATE_P, use UPDATE_SP_OFFSET for updating\n+   offsets of register elimnable to SP.\n \n    MEM_MODE is the mode of an enclosing MEM.  We need this to know how\n    much to adjust a register for, e.g., PRE_DEC.  Also, if we are\n@@ -311,7 +312,8 @@ get_elimination (rtx reg)\n    sp offset.  */\n rtx\n lra_eliminate_regs_1 (rtx_insn *insn, rtx x, machine_mode mem_mode,\n-\t\t      bool subst_p, bool update_p, bool full_p)\n+\t\t      bool subst_p, bool update_p,\n+\t\t      HOST_WIDE_INT update_sp_offset, bool full_p)\n {\n   enum rtx_code code = GET_CODE (x);\n   struct lra_elim_table *ep;\n@@ -346,7 +348,10 @@ lra_eliminate_regs_1 (rtx_insn *insn, rtx x, machine_mode mem_mode,\n \t  rtx to = subst_p ? ep->to_rtx : ep->from_rtx;\n \n \t  if (update_p)\n-\t    return plus_constant (Pmode, to, ep->offset - ep->previous_offset);\n+\t    return plus_constant (Pmode, to,\n+\t\t\t\t  ep->offset - ep->previous_offset\n+\t\t\t\t  + (ep->to_rtx == stack_pointer_rtx\n+\t\t\t\t     ? update_sp_offset : 0));\n \t  else if (full_p)\n \t    return plus_constant (Pmode, to,\n \t\t\t\t  ep->offset\n@@ -373,7 +378,10 @@ lra_eliminate_regs_1 (rtx_insn *insn, rtx x, machine_mode mem_mode,\n \t\treturn gen_rtx_PLUS (Pmode, to, XEXP (x, 1));\n \n \t      offset = (update_p\n-\t\t\t? ep->offset - ep->previous_offset : ep->offset);\n+\t\t\t? ep->offset - ep->previous_offset\n+\t\t\t+ (ep->to_rtx == stack_pointer_rtx\n+\t\t\t   ? update_sp_offset : 0)\n+\t\t\t: ep->offset);\n \t      if (full_p && insn != NULL_RTX && ep->to_rtx == stack_pointer_rtx)\n \t\toffset -= lra_get_insn_recog_data (insn)->sp_offset;\n \t      if (CONST_INT_P (XEXP (x, 1))\n@@ -402,9 +410,11 @@ lra_eliminate_regs_1 (rtx_insn *insn, rtx x, machine_mode mem_mode,\n \n       {\n \trtx new0 = lra_eliminate_regs_1 (insn, XEXP (x, 0), mem_mode,\n-\t\t\t\t\t subst_p, update_p, full_p);\n+\t\t\t\t\t subst_p, update_p,\n+\t\t\t\t\t update_sp_offset, full_p);\n \trtx new1 = lra_eliminate_regs_1 (insn, XEXP (x, 1), mem_mode,\n-\t\t\t\t\t subst_p, update_p, full_p);\n+\t\t\t\t\t subst_p, update_p,\n+\t\t\t\t\t update_sp_offset, full_p);\n \n \tif (new0 != XEXP (x, 0) || new1 != XEXP (x, 1))\n \t  return form_sum (new0, new1);\n@@ -423,11 +433,12 @@ lra_eliminate_regs_1 (rtx_insn *insn, rtx x, machine_mode mem_mode,\n \t  rtx to = subst_p ? ep->to_rtx : ep->from_rtx;\n \n \t  if (update_p)\n-\t    return\n-\t      plus_constant (Pmode,\n-\t\t\t     gen_rtx_MULT (Pmode, to, XEXP (x, 1)),\n-\t\t\t     (ep->offset - ep->previous_offset)\n-\t\t\t     * INTVAL (XEXP (x, 1)));\n+\t    return plus_constant (Pmode,\n+\t\t\t\t  gen_rtx_MULT (Pmode, to, XEXP (x, 1)),\n+\t\t\t\t  (ep->offset - ep->previous_offset\n+\t\t\t\t   + (ep->to_rtx == stack_pointer_rtx\n+\t\t\t\t      ? update_sp_offset : 0))\n+\t\t\t\t  * INTVAL (XEXP (x, 1)));\n \t  else if (full_p)\n \t    {\n \t      HOST_WIDE_INT offset = ep->offset;\n@@ -459,10 +470,12 @@ lra_eliminate_regs_1 (rtx_insn *insn, rtx x, machine_mode mem_mode,\n     case LE:\t   case LT:\t  case LEU:    case LTU:\n       {\n \trtx new0 = lra_eliminate_regs_1 (insn, XEXP (x, 0), mem_mode,\n-\t\t\t\t\t subst_p, update_p, full_p);\n+\t\t\t\t\t subst_p, update_p, \n+\t\t\t\t\t update_sp_offset, full_p);\n \trtx new1 = XEXP (x, 1)\n \t\t   ? lra_eliminate_regs_1 (insn, XEXP (x, 1), mem_mode,\n-\t\t\t\t\t   subst_p, update_p, full_p) : 0;\n+\t\t\t\t\t   subst_p, update_p,\n+\t\t\t\t\t   update_sp_offset, full_p) : 0;\n \n \tif (new0 != XEXP (x, 0) || new1 != XEXP (x, 1))\n \t  return gen_rtx_fmt_ee (code, GET_MODE (x), new0, new1);\n@@ -475,7 +488,8 @@ lra_eliminate_regs_1 (rtx_insn *insn, rtx x, machine_mode mem_mode,\n       if (XEXP (x, 0))\n \t{\n \t  new_rtx = lra_eliminate_regs_1 (insn, XEXP (x, 0), mem_mode,\n-\t\t\t\t\t  subst_p, update_p, full_p);\n+\t\t\t\t\t  subst_p, update_p,\n+\t\t\t\t\t  update_sp_offset, full_p);\n \t  if (new_rtx != XEXP (x, 0))\n \t    {\n \t      /* If this is a REG_DEAD note, it is not valid anymore.\n@@ -484,7 +498,8 @@ lra_eliminate_regs_1 (rtx_insn *insn, rtx x, machine_mode mem_mode,\n \t      if (REG_NOTE_KIND (x) == REG_DEAD)\n \t\treturn (XEXP (x, 1)\n \t\t\t? lra_eliminate_regs_1 (insn, XEXP (x, 1), mem_mode,\n-\t\t\t\t\t\tsubst_p, update_p, full_p)\n+\t\t\t\t\t\tsubst_p, update_p,\n+\t\t\t\t\t\tupdate_sp_offset, full_p)\n \t\t\t: NULL_RTX);\n \n \t      x = alloc_reg_note (REG_NOTE_KIND (x), new_rtx, XEXP (x, 1));\n@@ -501,7 +516,8 @@ lra_eliminate_regs_1 (rtx_insn *insn, rtx x, machine_mode mem_mode,\n       if (XEXP (x, 1))\n \t{\n \t  new_rtx = lra_eliminate_regs_1 (insn, XEXP (x, 1), mem_mode,\n-\t\t\t\t\t  subst_p, update_p, full_p);\n+\t\t\t\t\t  subst_p, update_p,\n+\t\t\t\t\t  update_sp_offset, full_p);\n \t  if (new_rtx != XEXP (x, 1))\n \t    return\n \t      gen_rtx_fmt_ee (GET_CODE (x), GET_MODE (x),\n@@ -528,8 +544,8 @@ lra_eliminate_regs_1 (rtx_insn *insn, rtx x, machine_mode mem_mode,\n \t  && XEXP (XEXP (x, 1), 0) == XEXP (x, 0))\n \t{\n \t  rtx new_rtx = lra_eliminate_regs_1 (insn, XEXP (XEXP (x, 1), 1),\n-\t\t\t\t\t      mem_mode,\n-\t\t\t\t\t      subst_p, update_p, full_p);\n+\t\t\t\t\t      mem_mode, subst_p, update_p,\n+\t\t\t\t\t      update_sp_offset, full_p);\n \n \t  if (new_rtx != XEXP (XEXP (x, 1), 1))\n \t    return gen_rtx_fmt_ee (code, GET_MODE (x), XEXP (x, 0),\n@@ -553,14 +569,16 @@ lra_eliminate_regs_1 (rtx_insn *insn, rtx x, machine_mode mem_mode,\n     case PARITY:\n     case BSWAP:\n       new_rtx = lra_eliminate_regs_1 (insn, XEXP (x, 0), mem_mode,\n-\t\t\t\t      subst_p, update_p, full_p);\n+\t\t\t\t      subst_p, update_p,\n+\t\t\t\t      update_sp_offset, full_p);\n       if (new_rtx != XEXP (x, 0))\n \treturn gen_rtx_fmt_e (code, GET_MODE (x), new_rtx);\n       return x;\n \n     case SUBREG:\n       new_rtx = lra_eliminate_regs_1 (insn, SUBREG_REG (x), mem_mode,\n-\t\t\t\t      subst_p, update_p, full_p);\n+\t\t\t\t      subst_p, update_p,\n+\t\t\t\t      update_sp_offset, full_p);\n \n       if (new_rtx != SUBREG_REG (x))\n \t{\n@@ -598,12 +616,12 @@ lra_eliminate_regs_1 (rtx_insn *insn, rtx x, machine_mode mem_mode,\n \treplace_equiv_address_nv\n \t(x,\n \t lra_eliminate_regs_1 (insn, XEXP (x, 0), GET_MODE (x),\n-\t\t\t       subst_p, update_p, full_p));\n+\t\t\t       subst_p, update_p, update_sp_offset, full_p));\n \n     case USE:\n       /* Handle insn_list USE that a call to a pure function may generate.  */\n       new_rtx = lra_eliminate_regs_1 (insn, XEXP (x, 0), VOIDmode,\n-\t\t\t\t      subst_p, update_p, full_p);\n+\t\t\t\t      subst_p, update_p, update_sp_offset, full_p);\n       if (new_rtx != XEXP (x, 0))\n \treturn gen_rtx_USE (GET_MODE (x), new_rtx);\n       return x;\n@@ -624,7 +642,8 @@ lra_eliminate_regs_1 (rtx_insn *insn, rtx x, machine_mode mem_mode,\n       if (*fmt == 'e')\n \t{\n \t  new_rtx = lra_eliminate_regs_1 (insn, XEXP (x, i), mem_mode,\n-\t\t\t\t\t  subst_p, update_p, full_p);\n+\t\t\t\t\t  subst_p, update_p,\n+\t\t\t\t\t  update_sp_offset, full_p);\n \t  if (new_rtx != XEXP (x, i) && ! copied)\n \t    {\n \t      x = shallow_copy_rtx (x);\n@@ -638,7 +657,8 @@ lra_eliminate_regs_1 (rtx_insn *insn, rtx x, machine_mode mem_mode,\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    {\n \t      new_rtx = lra_eliminate_regs_1 (insn, XVECEXP (x, i, j), mem_mode,\n-\t\t\t\t\t      subst_p, update_p, full_p);\n+\t\t\t\t\t      subst_p, update_p,\n+\t\t\t\t\t      update_sp_offset, full_p);\n \t      if (new_rtx != XVECEXP (x, i, j) && ! copied_vec)\n \t\t{\n \t\t  rtvec new_v = gen_rtvec_v (XVECLEN (x, i),\n@@ -665,7 +685,7 @@ rtx\n lra_eliminate_regs (rtx x, machine_mode mem_mode,\n \t\t    rtx insn ATTRIBUTE_UNUSED)\n {\n-  return lra_eliminate_regs_1 (NULL, x, mem_mode, true, false, true);\n+  return lra_eliminate_regs_1 (NULL, x, mem_mode, true, false, 0, true);\n }\n \n /* Stack pointer offset before the current insn relative to one at the\n@@ -850,13 +870,15 @@ remove_reg_equal_offset_note (rtx insn, rtx what)\n \n    If REPLACE_P is false, just update the offsets while keeping the\n    base register the same.  If FIRST_P, use the sp offset for\n-   elimination to sp.  Attach the note about used elimination for\n-   insns setting frame pointer to update elimination easy (without\n-   parsing already generated elimination insns to find offset\n-   previously used) in future.  */\n+   elimination to sp.  Otherwise, use UPDATE_SP_OFFSET for this.\n+   Attach the note about used elimination for insns setting frame\n+   pointer to update elimination easy (without parsing already\n+   generated elimination insns to find offset previously used) in\n+   future.  */\n \n-static void\n-eliminate_regs_in_insn (rtx_insn *insn, bool replace_p, bool first_p)\n+void\n+eliminate_regs_in_insn (rtx_insn *insn, bool replace_p, bool first_p,\n+\t\t\tHOST_WIDE_INT update_sp_offset)\n {\n   int icode = recog_memoized (insn);\n   rtx old_set = single_set (insn);\n@@ -986,8 +1008,13 @@ eliminate_regs_in_insn (rtx_insn *insn, bool replace_p, bool first_p)\n \t  if (! replace_p)\n \t    {\n \t      offset += (ep->offset - ep->previous_offset);\n-\t      if (first_p && ep->to_rtx == stack_pointer_rtx)\n-\t\toffset -= lra_get_insn_recog_data (insn)->sp_offset;\n+\t      if (ep->to_rtx == stack_pointer_rtx)\n+\t\t{\n+\t\t  if (first_p)\n+\t\t    offset -= lra_get_insn_recog_data (insn)->sp_offset;\n+\t\t  else\n+\t\t    offset += update_sp_offset;\n+\t\t}\n \t      offset = trunc_int_for_mode (offset, GET_MODE (plus_cst_src));\n \t    }\n \n@@ -1061,7 +1088,7 @@ eliminate_regs_in_insn (rtx_insn *insn, bool replace_p, bool first_p)\n \t  substed_operand[i]\n \t    = lra_eliminate_regs_1 (insn, *id->operand_loc[i], VOIDmode,\n \t\t\t\t    replace_p, ! replace_p && ! first_p,\n-\t\t\t\t    first_p);\n+\t\t\t\t    update_sp_offset, first_p);\n \t  if (substed_operand[i] != orig_operand[i])\n \t    validate_p = true;\n \t}\n@@ -1349,7 +1376,7 @@ lra_eliminate_reg_if_possible (rtx *loc)\n static void\n process_insn_for_elimination (rtx_insn *insn, bool final_p, bool first_p)\n {\n-  eliminate_regs_in_insn (insn, final_p, first_p);\n+  eliminate_regs_in_insn (insn, final_p, first_p, 0);\n   if (! final_p)\n     {\n       /* Check that insn changed its code.  This is a case when a move"}, {"sha": "92dc40cb7da36206a2e588e9e7d6d02f3f1c8435", "filename": "gcc/lra-int.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9cf932c33070383b9e4f9917ecee76a28e762aa/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9cf932c33070383b9e4f9917ecee76a28e762aa/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=d9cf932c33070383b9e4f9917ecee76a28e762aa", "patch": "@@ -328,7 +328,6 @@ extern bitmap_head lra_inheritance_pseudos;\n extern bitmap_head lra_split_regs;\n extern bitmap_head lra_subreg_reload_pseudos;\n extern bitmap_head lra_optional_reload_pseudos;\n-extern int lra_constraint_new_insn_uid_start;\n \n /* lra-constraints.c: */\n \n@@ -339,6 +338,7 @@ extern int lra_constraint_iter;\n extern bool lra_risky_transformations_p;\n extern int lra_inheritance_iter;\n extern int lra_undo_inheritance_iter;\n+extern bool lra_constrain_insn (rtx_insn *);\n extern bool lra_constraints (bool);\n extern void lra_constraints_init (void);\n extern void lra_constraints_finish (void);\n@@ -389,13 +389,17 @@ extern bool lra_need_for_spills_p (void);\n extern void lra_spill (void);\n extern void lra_final_code_change (void);\n \n+/* lra-remat.c:  */\n+\n+extern bool lra_remat (void);\n \n /* lra-elimination.c: */\n \n extern void lra_debug_elim_table (void);\n extern int lra_get_elimination_hard_regno (int);\n-extern rtx lra_eliminate_regs_1 (rtx_insn *, rtx, machine_mode, bool,\n-\t\t\t\t bool, bool);\n+extern rtx lra_eliminate_regs_1 (rtx_insn *, rtx, machine_mode,\n+\t\t\t\t bool, bool, HOST_WIDE_INT, bool);\n+extern void eliminate_regs_in_insn (rtx_insn *insn, bool, bool, HOST_WIDE_INT);\n extern void lra_eliminate (bool, bool);\n \n extern void lra_eliminate_reg_if_possible (rtx *);"}, {"sha": "5ea5ecdcc524d1eb1aaa23efaf2954d5d6b96743", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9cf932c33070383b9e4f9917ecee76a28e762aa/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9cf932c33070383b9e4f9917ecee76a28e762aa/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=d9cf932c33070383b9e4f9917ecee76a28e762aa", "patch": "@@ -252,8 +252,7 @@ make_hard_regno_born (int regno)\n   unsigned int i;\n \n   lra_assert (regno < FIRST_PSEUDO_REGISTER);\n-  if (TEST_HARD_REG_BIT (lra_no_alloc_regs, regno)\n-      || TEST_HARD_REG_BIT (hard_regs_live, regno))\n+  if (TEST_HARD_REG_BIT (hard_regs_live, regno))\n     return;\n   SET_HARD_REG_BIT (hard_regs_live, regno);\n   sparseset_set_bit (start_living, regno);\n@@ -267,8 +266,7 @@ static void\n make_hard_regno_dead (int regno)\n {\n   lra_assert (regno < FIRST_PSEUDO_REGISTER);\n-  if (TEST_HARD_REG_BIT (lra_no_alloc_regs, regno)\n-      || ! TEST_HARD_REG_BIT (hard_regs_live, regno))\n+  if (! TEST_HARD_REG_BIT (hard_regs_live, regno))\n     return;\n   sparseset_set_bit (start_dying, regno);\n   CLEAR_HARD_REG_BIT (hard_regs_live, regno);\n@@ -662,7 +660,6 @@ process_bb_lives (basic_block bb, int &curr_point)\n   sparseset_clear (pseudos_live_through_setjumps);\n   REG_SET_TO_HARD_REG_SET (hard_regs_live, reg_live_out);\n   AND_COMPL_HARD_REG_SET (hard_regs_live, eliminable_regset);\n-  AND_COMPL_HARD_REG_SET (hard_regs_live, lra_no_alloc_regs);\n   EXECUTE_IF_SET_IN_BITMAP (reg_live_out, FIRST_PSEUDO_REGISTER, j, bi)\n     mark_pseudo_live (j, curr_point);\n "}, {"sha": "51a94caf162cf9a767ecaf37a1731c84b004ded1", "filename": "gcc/lra-remat.c", "status": "added", "additions": 1212, "deletions": 0, "changes": 1212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9cf932c33070383b9e4f9917ecee76a28e762aa/gcc%2Flra-remat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9cf932c33070383b9e4f9917ecee76a28e762aa/gcc%2Flra-remat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-remat.c?ref=d9cf932c33070383b9e4f9917ecee76a28e762aa", "patch": "@@ -0,0 +1,1212 @@\n+/* Rematerialize pseudos values.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+   Contributed by Vladimir Makarov <vmakarov@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.\tIf not see\n+<http://www.gnu.org/licenses/>.\t */\n+\n+/* This code objective is to rematerialize spilled pseudo values.  To\n+   do this we calculate available insn candidates.  The candidate is\n+   available at some point if there is dominated set of insns with the\n+   same pattern, the insn inputs are not dying or modified on any path\n+   from the set, the outputs are not modified.\n+\n+   The insns containing memory or spilled pseudos (except for the\n+   rematerialized pseudo) are not considered as such insns are not\n+   profitable in comparison with regular loads of spilled pseudo\n+   values.  That simplifies the implementation as we don't need to\n+   deal with memory aliasing.\n+\n+   To speed up available candidate calculation, we calculate partially\n+   available candidates first and use them for initialization of the\n+   availability.  That is because (partial) availability sets are\n+   sparse.\n+\n+   The rematerialization sub-pass could be improved further in the\n+   following ways:\n+\n+   o We could make longer live ranges of inputs in the\n+     rematerialization candidates if their hard registers are not used\n+     for other purposes.  This could be complicated if we need to\n+     update BB live info information as LRA does not use\n+     DF-infrastructure for compile-time reasons.  This problem could\n+     be overcome if constrain making live ranges longer only in BB/EBB\n+     scope.\n+   o We could use cost-based decision to choose rematerialization insn\n+     (currently all insns without memory is can be used).\n+   o We could use other free hard regs for unused output pseudos in\n+     rematerialization candidates although such cases probably will\n+     be very rare.  */\n+\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"hard-reg-set.h\"\n+#include \"rtl.h\"\n+#include \"rtl-error.h\"\n+#include \"tm_p.h\"\n+#include \"target.h\"\n+#include \"insn-config.h\"\n+#include \"recog.h\"\n+#include \"output.h\"\n+#include \"regs.h\"\n+#include \"hashtab.h\"\n+#include \"hash-set.h\"\n+#include \"vec.h\"\n+#include \"machmode.h\"\n+#include \"input.h\"\n+#include \"function.h\"\n+#include \"expr.h\"\n+#include \"predict.h\"\n+#include \"dominance.h\"\n+#include \"cfg.h\"\n+#include \"basic-block.h\"\n+#include \"except.h\"\n+#include \"df.h\"\n+#include \"ira.h\"\n+#include \"sparseset.h\"\n+#include \"params.h\"\n+#include \"df.h\"\n+#include \"lra-int.h\"\n+\n+/* Number of candidates for rematerialization.  */\n+static unsigned int cands_num;\n+\n+/* The following is used for representation of call_used_reg_set in\n+   form array whose elements are hard register numbers with nonzero bit\n+   in CALL_USED_REG_SET. */\n+static int call_used_regs_arr_len;\n+static int call_used_regs_arr[FIRST_PSEUDO_REGISTER];\n+\n+/* Bitmap used for different calculations.  */\n+static bitmap_head temp_bitmap;\n+\n+typedef struct cand *cand_t;\n+typedef const struct cand *const_cand_t;\n+\n+/* Insn candidates for rematerialization.  The candidate insn should\n+   have the following properies:\n+   o no any memory (as access to memory is non-profitable)\n+   o no INOUT regs (it means no non-paradoxical subreg of output reg)\n+   o one output spilled pseudo (or reload pseudo of a spilled pseudo)\n+   o all other pseudos are with assigned hard regs.  */\n+struct cand\n+{\n+  /* Index of the candidates in all_cands. */\n+  int index;\n+  /* The candidate insn.  */\n+  rtx_insn *insn;\n+  /* Insn pseudo regno for rematerialization.  */\n+  int regno;\n+  /* Non-negative if a reload pseudo is in the insn instead of the\n+     pseudo for rematerialization.  */\n+  int reload_regno;\n+  /* Number of the operand containing the regno or its reload\n+     regno.  */\n+  int nop;\n+  /* Next candidate for the same regno.  */\n+  cand_t next_regno_cand;\n+};\n+\n+/* Vector containing all candidates.  */\n+static vec<cand_t> all_cands;\n+/* Map: insn -> candidate representing it.  It is null if the insn can\n+   not be used for rematerialization.  */\n+static cand_t *insn_to_cand;\n+\n+/* Map regno -> candidates can be used for the regno\n+   rematerialization.  */\n+static cand_t *regno_cands;\n+\n+/* Data about basic blocks used for the rematerialization\n+   sub-pass.  */\n+struct remat_bb_data\n+{\n+  /* Basic block about which the below data are.  */\n+  basic_block bb;\n+  /* Registers changed in the basic block: */\n+  bitmap_head changed_regs;\n+  /* Registers becoming dead in the BB.  */\n+  bitmap_head dead_regs;\n+  /* Cands present in the BB whose in/out regs are not changed after\n+     the cands occurence and are not dead (except the reload\n+     regno).  */\n+  bitmap_head gen_cands;\n+  bitmap_head livein_cands; /* cands whose inputs live at the BB start.  */\n+  bitmap_head pavin_cands; /* cands partially available at BB entry.  */\n+  bitmap_head pavout_cands; /* cands partially available at BB exit.  */\n+  bitmap_head avin_cands; /* cands available at the entry of the BB.  */\n+  bitmap_head avout_cands; /* cands available at the exit of the BB.  */\n+};\n+\n+/* Array for all BB data.  Indexed by the corresponding BB index.  */\n+typedef struct remat_bb_data *remat_bb_data_t;\n+\n+/* Basic blocks for data flow problems -- all bocks except the special\n+   ones.  */\n+static bitmap_head all_blocks;\n+\n+/* All basic block data are referred through the following array.  */\n+static remat_bb_data_t remat_bb_data;\n+\n+/* Two small functions for access to the bb data.  */\n+static inline remat_bb_data_t\n+get_remat_bb_data (basic_block bb)\n+{\n+  return &remat_bb_data[(bb)->index];\n+}\n+\n+static inline remat_bb_data_t\n+get_remat_bb_data_by_index (int index)\n+{\n+  return &remat_bb_data[index];\n+}\n+\n+\f\n+\n+/* Recursive hash function for RTL X.  */\n+static hashval_t\n+rtx_hash (rtx x)\n+{\n+  int i, j;\n+  enum rtx_code code;\n+  const char *fmt;\n+  hashval_t val = 0;\n+\n+  if (x == 0)\n+    return val;\n+\n+  code = GET_CODE (x);\n+  val += (int) code + 4095;\n+\n+  /* Some RTL can be compared nonrecursively.  */\n+  switch (code)\n+    {\n+    case REG:\n+      return val + REGNO (x);\n+\n+    case LABEL_REF:\n+      return iterative_hash_object (XEXP (x, 0), val);\n+\n+    case SYMBOL_REF:\n+      return iterative_hash_object (XSTR (x, 0), val);\n+\n+    case SCRATCH:\n+    case CONST_DOUBLE:\n+    case CONST_INT:\n+    case CONST_VECTOR:\n+      return val;\n+\n+    default:\n+      break;\n+    }\n+\n+  /* Hash the elements.  */\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      switch (fmt[i])\n+\t{\n+\tcase 'w':\n+\t  val += XWINT (x, i);\n+\t  break;\n+\n+\tcase 'n':\n+\tcase 'i':\n+\t  val += XINT (x, i);\n+\t  break;\n+\n+\tcase 'V':\n+\tcase 'E':\n+\t  val += XVECLEN (x, i);\n+\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    val += rtx_hash (XVECEXP (x, i, j));\n+\t  break;\n+\n+\tcase 'e':\n+\t  val += rtx_hash (XEXP (x, i));\n+\t  break;\n+\n+\tcase 'S':\n+\tcase 's':\n+\t  val += htab_hash_string (XSTR (x, i));\n+\t  break;\n+\n+\tcase 'u':\n+\tcase '0':\n+\tcase 't':\n+\t  break;\n+\n+\t  /* It is believed that rtx's at this level will never\n+\t     contain anything but integers and other rtx's, except for\n+\t     within LABEL_REFs and SYMBOL_REFs.  */\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+  return val;\n+}\n+\n+\f\n+\n+/* Hash table for the candidates.  Different insns (e.g. structurally\n+   the same insns or even insns with different unused output regs) can\n+   be represented by the same candidate in the table.  */\n+static htab_t cand_table;\n+\n+/* Hash function for candidate CAND.  */\n+static hashval_t\n+cand_hash (const void *cand)\n+{\n+  const_cand_t c = (const_cand_t) cand;\n+  lra_insn_recog_data_t id = lra_get_insn_recog_data (c->insn);\n+  struct lra_static_insn_data *static_id = id->insn_static_data;\n+  int nops = static_id->n_operands;\n+  hashval_t hash = 0;\n+\n+  for (int i = 0; i < nops; i++)\n+    if (i == c->nop)\n+      hash = iterative_hash_object (c->regno, hash);\n+    else if (static_id->operand[i].type == OP_IN)\n+      hash = iterative_hash_object (*id->operand_loc[i], hash);\n+  return hash;\n+}\n+\n+/* Equal function for candidates CAND1 and CAND2.  They are equal if\n+   the corresponding candidate insns have the same code, the same\n+   regno for rematerialization, the same input operands.  */\n+static int\n+cand_eq_p (const void *cand1, const void *cand2)\n+{\n+  const_cand_t c1 = (const_cand_t) cand1;\n+  const_cand_t c2 = (const_cand_t) cand2;\n+  lra_insn_recog_data_t id1 = lra_get_insn_recog_data (c1->insn);\n+  lra_insn_recog_data_t id2 = lra_get_insn_recog_data (c2->insn);\n+  struct lra_static_insn_data *static_id1 = id1->insn_static_data;\n+  int nops = static_id1->n_operands;\n+\n+  if (c1->regno != c2->regno\n+      || INSN_CODE (c1->insn) < 0\n+      || INSN_CODE (c1->insn) != INSN_CODE (c2->insn))\n+    return false;\n+  gcc_assert (c1->nop == c2->nop);\n+  for (int i = 0; i < nops; i++)\n+    if (i != c1->nop && static_id1->operand[i].type == OP_IN\n+\t&& *id1->operand_loc[i] != *id2->operand_loc[i])\n+      return false;\n+  return true;\n+}\n+\n+/* Insert candidate CAND into the table if it is not there yet.\n+   Return candidate which is in the table.  */\n+static cand_t\n+insert_cand (cand_t cand)\n+{\n+  void **entry_ptr;\n+\n+  entry_ptr = htab_find_slot (cand_table, cand, INSERT);\n+  if (*entry_ptr == NULL)\n+    *entry_ptr = (void *) cand;\n+  return (cand_t) *entry_ptr;\n+}\n+\n+/* Free candidate CAND memory.  */\n+static void\n+free_cand (void *cand)\n+{\n+  free (cand);\n+}\n+\n+/* Initiate the candidate table.  */\n+static void\n+initiate_cand_table (void)\n+{\n+  cand_table = htab_create (8000, cand_hash, cand_eq_p,\n+\t\t\t    (htab_del) free_cand);\n+}\n+\n+/* Finish the candidate table.  */\n+static void\n+finish_cand_table (void)\n+{\n+  htab_delete (cand_table);\n+}\n+\n+\f\n+\n+/* Return true if X contains memory or UNSPEC.  We can not just check\n+   insn operands as memory or unspec might be not an operand itself\n+   but contain an operand.  Insn with memory access is not profitable\n+   for rematerialization.  Rematerialization of UNSPEC might result in\n+   wrong code generation as the UNPEC effect is unknown\n+   (e.g. generating a label).  */\n+static bool\n+bad_for_rematerialization_p (rtx x)\n+{\n+  int i, j;\n+  const char *fmt;\n+  enum rtx_code code;\n+\n+  if (MEM_P (x) || GET_CODE (x) == UNSPEC)\n+    return true;\n+  code = GET_CODE (x);\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  if (bad_for_rematerialization_p (XEXP (x, i)))\n+\t    return true;\n+\t}\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t    if (bad_for_rematerialization_p (XVECEXP (x, i, j)))\n+\t      return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* If INSN can not be used for rematerialization, return negative\n+   value.  If INSN can be considered as a candidate for\n+   rematerialization, return value which is the operand number of the\n+   pseudo for which the insn can be used for rematerialization.  Here\n+   we consider the insns without any memory, spilled pseudo (except\n+   for the rematerialization pseudo), or dying or unused regs.  */\n+static int\n+operand_to_remat (rtx_insn *insn)\n+{\n+  lra_insn_recog_data_t id = lra_get_insn_recog_data (insn);\n+  struct lra_static_insn_data *static_id = id->insn_static_data;\n+  struct lra_insn_reg *reg, *found_reg = NULL;\n+\n+  /* First find a pseudo which can be rematerialized.  */\n+  for (reg = id->regs; reg != NULL; reg = reg->next)\n+    if (reg->type == OP_OUT && ! reg->subreg_p\n+\t&& find_regno_note (insn, REG_UNUSED, reg->regno) == NULL)\n+      {\n+\t/* We permits only one spilled reg.  */\n+\tif (found_reg != NULL)\n+\t  return -1;\n+\tfound_reg = reg;\n+      }\n+  if (found_reg == NULL)\n+    return -1;\n+  if (found_reg->regno < FIRST_PSEUDO_REGISTER)\n+    return -1;\n+  if (bad_for_rematerialization_p (PATTERN (insn)))\n+    return -1;\n+  /* Check the other regs are not spilled. */\n+  for (reg = id->regs; reg != NULL; reg = reg->next)\n+    if (found_reg == reg)\n+      continue;\n+    else if (reg->type == OP_INOUT)\n+      return -1;\n+    else if (reg->regno >= FIRST_PSEUDO_REGISTER\n+\t     && reg_renumber[reg->regno] < 0)\n+      /* Another spilled reg.  */\n+      return -1;\n+    else if (reg->type == OP_IN)\n+      {\n+\tif (find_regno_note (insn, REG_DEAD, reg->regno) != NULL)\n+\t  /* We don't want to make live ranges longer.  */\n+\t  return -1;\n+\t/* Check that there is no output reg as the input one.  */\n+\tfor (struct lra_insn_reg *reg2 = id->regs;\n+\t     reg2 != NULL;\n+\t     reg2 = reg2->next)\n+\t  if (reg2->type == OP_OUT && reg->regno == reg2->regno)\n+\t    return -1;\n+      }\n+  /* Find the rematerialization operand.  */\n+  int nop = static_id->n_operands;\n+  for (int i = 0; i < nop; i++)\n+    if (REG_P (*id->operand_loc[i])\n+\t&& (int) REGNO (*id->operand_loc[i]) == found_reg->regno)\n+      return i;\n+  return -1;\n+}\n+\n+/* Create candidate for INSN with rematerialization operand NOP and\n+   REGNO.  Insert the candidate into the table and set up the\n+   corresponding INSN_TO_CAND element.  */\n+static void\n+create_cand (rtx_insn *insn, int nop, int regno)\n+{\n+  lra_insn_recog_data_t id = lra_get_insn_recog_data (insn);\n+  rtx reg = *id->operand_loc[nop];\n+  gcc_assert (REG_P (reg));\n+  int op_regno = REGNO (reg);\n+  gcc_assert (op_regno >= FIRST_PSEUDO_REGISTER);\n+  cand_t cand = XNEW (struct cand);\n+  cand->insn = insn;\n+  cand->nop = nop;\n+  cand->regno = regno;\n+  cand->reload_regno = op_regno == regno ? -1 : op_regno;\n+  gcc_assert (cand->regno >= 0);\n+  cand_t cand_in_table = insert_cand (cand);\n+  insn_to_cand[INSN_UID (insn)] = cand_in_table;\n+  if (cand != cand_in_table)\n+    free (cand);\n+  else\n+    {\n+      /* A new cand.  */\n+      cand->index = all_cands.length ();\n+      all_cands.safe_push (cand);\n+      cand->next_regno_cand = regno_cands[cand->regno];\n+      regno_cands[cand->regno] = cand;\n+    }\n+}\n+\n+/* Create rematerialization candidates (inserting them into the\n+   table).  */\n+static void\n+create_cands (void)\n+{\n+  rtx_insn *insn;\n+  struct potential_cand\n+  {\n+    rtx_insn *insn;\n+    int nop;\n+  };\n+  struct potential_cand *regno_potential_cand;\n+\n+  /* Create candidates.  */\n+  regno_potential_cand = XCNEWVEC (struct potential_cand, max_reg_num ());\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    if (INSN_P (insn))\n+      {\n+\trtx set;\n+\tint src_regno, dst_regno;\n+\trtx_insn *insn2;\n+\tlra_insn_recog_data_t id = lra_get_insn_recog_data (insn);\n+\tint nop = operand_to_remat (insn);\n+\tint regno = -1;\n+\n+\tif ((set = single_set (insn)) != NULL\n+\t    && REG_P (SET_SRC (set)) && REG_P (SET_DEST (set))\n+\t    && (src_regno = REGNO (SET_SRC (set))) >= FIRST_PSEUDO_REGISTER\n+\t    && (dst_regno = REGNO (SET_DEST (set))) >= FIRST_PSEUDO_REGISTER\n+\t    && reg_renumber[dst_regno] < 0\n+\t    && (insn2 = regno_potential_cand[src_regno].insn) != NULL\n+\t    && BLOCK_FOR_INSN (insn2) == BLOCK_FOR_INSN (insn))\n+\t  create_cand (insn2, regno_potential_cand[src_regno].nop, dst_regno);\n+\tif (nop < 0)\n+\t  goto fail;\n+\tgcc_assert (REG_P (*id->operand_loc[nop]));\n+ \tregno = REGNO (*id->operand_loc[nop]);\n+\tgcc_assert (regno >= FIRST_PSEUDO_REGISTER);\n+\tif (reg_renumber[regno] < 0)\n+\t  create_cand (insn, nop, regno);\n+\telse\n+\t  {\n+\t    regno_potential_cand[regno].insn = insn;\n+\t    regno_potential_cand[regno].nop = nop;\n+\t    goto fail;\n+\t  }\n+\tregno = -1;\n+      fail:\n+\tfor (struct lra_insn_reg *reg = id->regs; reg != NULL; reg = reg->next)\n+\t  if (reg->type != OP_IN && reg->regno != regno\n+\t      && reg->regno >= FIRST_PSEUDO_REGISTER)\n+\t    regno_potential_cand[reg->regno].insn = NULL;\n+      }\n+  cands_num = all_cands.length ();\n+  free (regno_potential_cand);\n+}\n+\n+\f\n+\n+/* Create and initialize BB data.  */\n+static void\n+create_remat_bb_data (void)\n+{\n+  basic_block bb;\n+  remat_bb_data_t bb_info;\n+\n+  remat_bb_data = XNEWVEC (struct remat_bb_data,\n+\t\t\t   last_basic_block_for_fn (cfun));\n+  FOR_ALL_BB_FN (bb, cfun)\n+    {\n+#ifdef ENABLE_CHECKING\n+      if (bb->index < 0 || bb->index >= last_basic_block_for_fn (cfun))\n+\tabort ();\n+#endif\n+      bb_info = get_remat_bb_data (bb);\n+      bb_info->bb = bb;\n+      bitmap_initialize (&bb_info->changed_regs, &reg_obstack);\n+      bitmap_initialize (&bb_info->dead_regs, &reg_obstack);\n+      bitmap_initialize (&bb_info->gen_cands, &reg_obstack);\n+      bitmap_initialize (&bb_info->livein_cands, &reg_obstack);\n+      bitmap_initialize (&bb_info->pavin_cands, &reg_obstack);\n+      bitmap_initialize (&bb_info->pavout_cands, &reg_obstack);\n+      bitmap_initialize (&bb_info->avin_cands, &reg_obstack);\n+      bitmap_initialize (&bb_info->avout_cands, &reg_obstack);\n+    }\n+}\n+\n+/* Dump all candidates to DUMP_FILE.  */\n+static void\n+dump_cands (FILE *dump_file)\n+{\n+  int i;\n+  cand_t cand;\n+\n+  fprintf (dump_file, \"\\nCands:\\n\");\n+  for (i = 0; i < (int) cands_num; i++)\n+    {\n+      cand = all_cands[i];\n+      fprintf (dump_file, \"%d (nop=%d, remat_regno=%d, reload_regno=%d):\\n\",\n+\t       i, cand->nop, cand->regno, cand->reload_regno);\n+      print_inline_rtx (dump_file, cand->insn, 6);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+}\n+\n+/* Dump all candidates and BB data.  */\n+static void\n+dump_candidates_and_remat_bb_data (void)\n+{\n+  basic_block bb;\n+\n+  if (lra_dump_file == NULL)\n+    return;\n+  dump_cands (lra_dump_file);\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      fprintf (lra_dump_file, \"\\nBB %d:\\n\", bb->index);\n+      /* Livein */\n+      fprintf (lra_dump_file, \"  register live in:\");\n+      dump_regset (df_get_live_in (bb), lra_dump_file);\n+      putc ('\\n', lra_dump_file);\n+      /* Liveout */\n+      fprintf (lra_dump_file, \"  register live out:\");\n+      dump_regset (df_get_live_out (bb), lra_dump_file);\n+      putc ('\\n', lra_dump_file);\n+      /* Changed/dead regs: */\n+      fprintf (lra_dump_file, \"  changed regs:\");\n+      dump_regset (&get_remat_bb_data (bb)->changed_regs, lra_dump_file);\n+      putc ('\\n', lra_dump_file);\n+      fprintf (lra_dump_file, \"  dead regs:\");\n+      dump_regset (&get_remat_bb_data (bb)->dead_regs, lra_dump_file);\n+      putc ('\\n', lra_dump_file);\n+      lra_dump_bitmap_with_title (\"cands generated in BB\",\n+\t\t\t\t  &get_remat_bb_data (bb)->gen_cands, bb->index);\n+      lra_dump_bitmap_with_title (\"livein cands in BB\",\n+\t\t\t\t  &get_remat_bb_data (bb)->livein_cands, bb->index);\n+      lra_dump_bitmap_with_title (\"pavin cands in BB\",\n+\t\t\t\t  &get_remat_bb_data (bb)->pavin_cands, bb->index);\n+      lra_dump_bitmap_with_title (\"pavout cands in BB\",\n+\t\t\t\t  &get_remat_bb_data (bb)->pavout_cands, bb->index);\n+      lra_dump_bitmap_with_title (\"avin cands in BB\",\n+\t\t\t\t  &get_remat_bb_data (bb)->avin_cands, bb->index);\n+      lra_dump_bitmap_with_title (\"avout cands in BB\",\n+\t\t\t\t  &get_remat_bb_data (bb)->avout_cands, bb->index);\n+    }\n+}\n+\n+/* Free all BB data.  */\n+static void\n+finish_remat_bb_data (void)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      bitmap_clear (&get_remat_bb_data (bb)->avout_cands);\n+      bitmap_clear (&get_remat_bb_data (bb)->avin_cands);\n+      bitmap_clear (&get_remat_bb_data (bb)->pavout_cands);\n+      bitmap_clear (&get_remat_bb_data (bb)->pavin_cands);\n+      bitmap_clear (&get_remat_bb_data (bb)->livein_cands);\n+      bitmap_clear (&get_remat_bb_data (bb)->gen_cands);\n+      bitmap_clear (&get_remat_bb_data (bb)->dead_regs);\n+      bitmap_clear (&get_remat_bb_data (bb)->changed_regs);\n+    }\n+  free (remat_bb_data);\n+}\n+\n+\f\n+\n+/* Update changed_regs and dead_regs of BB from INSN.  */\n+static void\n+set_bb_regs (basic_block bb, rtx_insn *insn)\n+{\n+  lra_insn_recog_data_t id = lra_get_insn_recog_data (insn);\n+  struct lra_insn_reg *reg;\n+\n+  for (reg = id->regs; reg != NULL; reg = reg->next)\n+    if (reg->type != OP_IN)\n+      bitmap_set_bit (&get_remat_bb_data (bb)->changed_regs, reg->regno);\n+    else\n+      {\n+\tif (find_regno_note (insn, REG_DEAD, (unsigned) reg->regno) != NULL)\n+\t  bitmap_set_bit (&get_remat_bb_data (bb)->dead_regs, reg->regno);\n+      }\n+  if (CALL_P (insn))\n+    for (int i = 0; i < call_used_regs_arr_len; i++)\n+      bitmap_set_bit (&get_remat_bb_data (bb)->dead_regs,\n+\t\t      call_used_regs_arr[i]);\n+}\n+\n+/* Calculate changed_regs and dead_regs for each BB.  */\n+static void\n+calculate_local_reg_remat_bb_data (void)\n+{\n+  basic_block bb;\n+  rtx_insn *insn;\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    FOR_BB_INSNS (bb, insn)\n+      if (INSN_P (insn))\n+\tset_bb_regs (bb, insn);\n+}\n+\n+\f\n+\n+/* Return true if REGNO is an input operand of INSN.  */\n+static bool\n+input_regno_present_p (rtx_insn *insn, int regno)\n+{\n+  lra_insn_recog_data_t id = lra_get_insn_recog_data (insn);\n+  struct lra_insn_reg *reg;\n+\n+  for (reg = id->regs; reg != NULL; reg = reg->next)\n+    if (reg->type == OP_IN && reg->regno == regno)\n+      return true;\n+  return false;\n+}\n+\n+/* Return true if a call used register is an input operand of INSN.  */\n+static bool\n+call_used_input_regno_present_p (rtx_insn *insn)\n+{\n+  lra_insn_recog_data_t id = lra_get_insn_recog_data (insn);\n+  struct lra_insn_reg *reg;\n+\n+  for (reg = id->regs; reg != NULL; reg = reg->next)\n+    if (reg->type == OP_IN && reg->regno <= FIRST_PSEUDO_REGISTER\n+\t&& TEST_HARD_REG_BIT (call_used_reg_set, reg->regno))\n+      return true;\n+  return false;\n+}\n+\n+/* Calculate livein_cands for each BB.  */\n+static void\n+calculate_livein_cands (void)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      bitmap livein_regs = df_get_live_in (bb);\n+      bitmap livein_cands = &get_remat_bb_data (bb)->livein_cands;\n+      for (unsigned int i = 0; i < cands_num; i++)\n+\t{\n+\t  cand_t cand = all_cands[i];\n+\t  lra_insn_recog_data_t id = lra_get_insn_recog_data (cand->insn);\n+\t  struct lra_insn_reg *reg;\n+\n+\t  for (reg = id->regs; reg != NULL; reg = reg->next)\n+\t    if (reg->type == OP_IN && ! bitmap_bit_p (livein_regs, reg->regno))\n+\t      break;\n+\t  if (reg == NULL)\n+\t    bitmap_set_bit (livein_cands, i);\n+\t}\n+    }\n+}\n+\n+/* Calculate gen_cands for each BB.  */\n+static void\n+calculate_gen_cands (void)\n+{\n+  basic_block bb;\n+  bitmap gen_cands;\n+  bitmap_head gen_insns;\n+  rtx_insn *insn;\n+\n+  bitmap_initialize (&gen_insns, &reg_obstack);\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      gen_cands = &get_remat_bb_data (bb)->gen_cands;\n+      bitmap_clear (&gen_insns);\n+      FOR_BB_INSNS (bb, insn)\n+\tif (INSN_P (insn))\n+\t  {\n+\t    lra_insn_recog_data_t id = lra_get_insn_recog_data (insn);\n+\t    struct lra_insn_reg *reg;\n+\t    unsigned int uid;\n+\t    bitmap_iterator bi;\n+\t    cand_t cand;\n+\t    rtx set;\n+\t    int src_regno = -1, dst_regno = -1;\n+\n+\t    if ((set = single_set (insn)) != NULL\n+\t\t&& REG_P (SET_SRC (set)) && REG_P (SET_DEST (set)))\n+\t      {\n+\t\tsrc_regno = REGNO (SET_SRC (set));\n+\t\tdst_regno = REGNO (SET_DEST (set));\n+\t      }\n+\n+\t    /* Update gen_cands:  */\n+\t    bitmap_clear (&temp_bitmap);\n+\t    for (reg = id->regs; reg != NULL; reg = reg->next)\n+\t      if (reg->type != OP_IN\n+\t\t  || find_regno_note (insn, REG_DEAD, reg->regno) != NULL)\n+\t\tEXECUTE_IF_SET_IN_BITMAP (&gen_insns, 0, uid, bi)\n+\t\t  {\n+\t\t    rtx_insn *insn2 = lra_insn_recog_data[uid]->insn;\n+\n+\t\t    cand = insn_to_cand[INSN_UID (insn2)];\n+\t\t    gcc_assert (cand != NULL);\n+\t\t    /* Ignore the reload insn.  */\n+\t\t    if (src_regno == cand->reload_regno\n+\t\t\t&& dst_regno == cand->regno)\n+\t\t      continue;\n+\t\t    if (cand->regno == reg->regno\n+\t\t\t|| input_regno_present_p (insn2, reg->regno))\n+\t\t      {\n+\t\t\tbitmap_clear_bit (gen_cands, cand->index);\n+\t\t\tbitmap_set_bit (&temp_bitmap, uid);\n+\t\t      }\n+\t\t  }\n+\t    \n+\t    if (CALL_P (insn))\n+\t      EXECUTE_IF_SET_IN_BITMAP (&gen_insns, 0, uid, bi)\n+\t\t{\n+\t\t  rtx_insn *insn2 = lra_insn_recog_data[uid]->insn;\n+\t\t  \n+\t\t  cand = insn_to_cand[INSN_UID (insn2)];\n+\t\t  gcc_assert (cand != NULL);\n+\t\t  if (call_used_input_regno_present_p (insn2))\n+\t\t    {\n+\t\t      bitmap_clear_bit (gen_cands, cand->index);\n+\t\t      bitmap_set_bit (&temp_bitmap, uid);\n+\t\t    }\n+\t\t}\n+\t    bitmap_and_compl_into (&gen_insns, &temp_bitmap);\n+\n+\t    cand = insn_to_cand[INSN_UID (insn)];\n+\t    if (cand != NULL)\n+\t      {\n+\t\tbitmap_set_bit (gen_cands, cand->index);\n+\t\tbitmap_set_bit (&gen_insns, INSN_UID (insn));\n+\t      }\n+\t  }\n+    }  \n+  bitmap_clear (&gen_insns);\n+}\n+\n+\f\n+\n+/* The common transfer function used by the DF equation solver to\n+   propagate (partial) availability info BB_IN to BB_OUT through block\n+   with BB_INDEX according to the following equation:\n+\n+      bb.out =  ((bb.in & bb.livein) - bb.killed) OR  bb.gen\n+*/\n+static bool\n+cand_trans_fun (int bb_index, bitmap bb_in, bitmap bb_out)\n+{\n+  remat_bb_data_t bb_info;\n+  bitmap bb_livein, bb_changed_regs, bb_dead_regs;\n+  unsigned int cid;\n+  bitmap_iterator bi;\n+\n+  bb_info = get_remat_bb_data_by_index (bb_index);\n+  bb_livein = &bb_info->livein_cands;\n+  bb_changed_regs = &bb_info->changed_regs;\n+  bb_dead_regs = &bb_info->dead_regs;\n+  /* Calculate killed avin cands -- cands whose regs are changed or\n+     becoming dead in the BB.  We calculate it here as we hope that\n+     repeated calculations are compensated by smaller size of BB_IN in\n+     comparison with all candidates number.  */\n+  bitmap_clear (&temp_bitmap);\n+  EXECUTE_IF_SET_IN_BITMAP (bb_in, 0, cid, bi)\n+    {\n+      cand_t cand = all_cands[cid];\n+      lra_insn_recog_data_t id = lra_get_insn_recog_data (cand->insn);\n+      struct lra_insn_reg *reg;\n+\n+      if (! bitmap_bit_p (bb_livein, cid))\n+\t{\n+\t  bitmap_set_bit (&temp_bitmap, cid);\n+\t  continue;\n+\t}\n+      for (reg = id->regs; reg != NULL; reg = reg->next)\n+\t/* Ignore all outputs which are not the regno for\n+\t   rematerialization.  */\n+\tif (reg->type == OP_OUT && reg->regno != cand->regno)\n+\t  continue;\n+\telse if (bitmap_bit_p (bb_changed_regs, reg->regno)\n+\t\t || bitmap_bit_p (bb_dead_regs, reg->regno))\n+\t  {\n+\t    bitmap_set_bit (&temp_bitmap, cid);\n+\t    break;\n+\t  }\n+    }\n+  return bitmap_ior_and_compl (bb_out,\n+\t\t\t       &bb_info->gen_cands, bb_in, &temp_bitmap);\n+}\n+\n+\f\n+\n+/* The transfer function used by the DF equation solver to propagate\n+   partial candidate availability info through block with BB_INDEX\n+   according to the following equation:\n+\n+     bb.pavout = ((bb.pavin & bb.livein) - bb.killed) OR bb.gen\n+*/\n+static bool\n+cand_pav_trans_fun (int bb_index)\n+{\n+  remat_bb_data_t bb_info;\n+\n+  bb_info = get_remat_bb_data_by_index (bb_index);\n+  return cand_trans_fun (bb_index, &bb_info->pavin_cands,\n+\t\t\t &bb_info->pavout_cands);\n+}\n+\n+/* The confluence function used by the DF equation solver to set up\n+   cand_pav info for a block BB without predecessor.  */\n+static void\n+cand_pav_con_fun_0 (basic_block bb)\n+{\n+  bitmap_clear (&get_remat_bb_data (bb)->pavin_cands);\n+}\n+\n+/* The confluence function used by the DF equation solver to propagate\n+   partial candidate availability info from predecessor to successor\n+   on edge E (pred->bb) according to the following equation:\n+\n+      bb.pavin_cands = 0 for entry block | OR (pavout_cands of predecessors)\n+ */\n+static bool\n+cand_pav_con_fun_n (edge e)\n+{\n+  basic_block pred = e->src;\n+  basic_block bb = e->dest;\n+  remat_bb_data_t bb_info;\n+  bitmap bb_pavin, pred_pavout;\n+  \n+  bb_info = get_remat_bb_data (bb);\n+  bb_pavin = &bb_info->pavin_cands;\n+  pred_pavout = &get_remat_bb_data (pred)->pavout_cands;\n+  return bitmap_ior_into (bb_pavin, pred_pavout);\n+}\n+\n+\f\n+\n+/* The transfer function used by the DF equation solver to propagate\n+   candidate availability info through block with BB_INDEX according\n+   to the following equation:\n+\n+      bb.avout =  ((bb.avin & bb.livein) - bb.killed) OR  bb.gen\n+*/\n+static bool\n+cand_av_trans_fun (int bb_index)\n+{\n+  remat_bb_data_t bb_info;\n+\n+  bb_info = get_remat_bb_data_by_index (bb_index);\n+  return cand_trans_fun (bb_index, &bb_info->avin_cands,\n+\t\t\t &bb_info->avout_cands);\n+}\n+\n+/* The confluence function used by the DF equation solver to set up\n+   cand_av info for a block BB without predecessor.  */\n+static void\n+cand_av_con_fun_0 (basic_block bb)\n+{\n+  bitmap_clear (&get_remat_bb_data (bb)->avin_cands);\n+}\n+\n+/* The confluence function used by the DF equation solver to propagate\n+   cand_av info from predecessor to successor on edge E (pred->bb)\n+   according to the following equation:\n+\n+      bb.avin_cands = 0 for entry block | AND (avout_cands of predecessors)\n+ */\n+static bool\n+cand_av_con_fun_n (edge e)\n+{\n+  basic_block pred = e->src;\n+  basic_block bb = e->dest;\n+  remat_bb_data_t bb_info;\n+  bitmap bb_avin, pred_avout;\n+  \n+  bb_info = get_remat_bb_data (bb);\n+  bb_avin = &bb_info->avin_cands;\n+  pred_avout = &get_remat_bb_data (pred)->avout_cands;\n+  return bitmap_and_into (bb_avin, pred_avout);\n+}\n+\n+/* Calculate available candidates for each BB.  */\n+static void\n+calculate_global_remat_bb_data (void)\n+{\n+  basic_block bb;\n+\n+  df_simple_dataflow\n+    (DF_FORWARD, NULL, cand_pav_con_fun_0, cand_pav_con_fun_n,\n+     cand_pav_trans_fun, &all_blocks,\n+     df_get_postorder (DF_FORWARD), df_get_n_blocks (DF_FORWARD));\n+  /* Initialize avin by pavin.  */\n+  FOR_EACH_BB_FN (bb, cfun)\n+    bitmap_copy (&get_remat_bb_data (bb)->avin_cands,\n+\t\t &get_remat_bb_data (bb)->pavin_cands);\n+  df_simple_dataflow\n+    (DF_FORWARD, NULL, cand_av_con_fun_0, cand_av_con_fun_n,\n+     cand_av_trans_fun, &all_blocks,\n+     df_get_postorder (DF_FORWARD), df_get_n_blocks (DF_FORWARD));\n+}\n+\n+\f\n+\n+/* Setup sp offset attribute to SP_OFFSET for all INSNS.  */\n+static void\n+change_sp_offset (rtx_insn *insns, HOST_WIDE_INT sp_offset)\n+{\n+  for (rtx_insn *insn = insns; insn != NULL; insn = NEXT_INSN (insn))\n+    eliminate_regs_in_insn (insn, false, false, sp_offset);\n+}\n+\n+/* Return start hard register of REG (can be a hard or a pseudo reg)\n+   or -1 (if it is a spilled pseudo).  Return number of hard registers\n+   occupied by REG through parameter NREGS if the start hard reg is\n+   not negative.  */\n+static int\n+get_hard_regs (struct lra_insn_reg *reg, int &nregs)\n+{\n+  int regno = reg->regno;\n+  int hard_regno = regno < FIRST_PSEUDO_REGISTER ? regno : reg_renumber[regno];\n+\n+  if (hard_regno >= 0)\n+    nregs = hard_regno_nregs[hard_regno][reg->biggest_mode];\n+  return hard_regno;\n+}\n+\n+/* Insert rematerialization insns using the data-flow data calculated\n+   earlier.  */\n+static bool\n+do_remat (void)\n+{\n+  rtx_insn *insn;\n+  basic_block bb;\n+  bitmap_head avail_cands;\n+  bool changed_p = false;\n+  /* Living hard regs and hard registers of living pseudos.  */\n+  HARD_REG_SET live_hard_regs;\n+\n+  bitmap_initialize (&avail_cands, &reg_obstack);\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      REG_SET_TO_HARD_REG_SET (live_hard_regs, df_get_live_out (bb));\n+      bitmap_and (&avail_cands, &get_remat_bb_data (bb)->avin_cands,\n+\t\t  &get_remat_bb_data (bb)->livein_cands);\n+      FOR_BB_INSNS (bb, insn)\n+\t{\n+\t  if (!NONDEBUG_INSN_P (insn))\n+\t    continue;\n+\n+\t  lra_insn_recog_data_t id = lra_get_insn_recog_data (insn);\n+\t  struct lra_insn_reg *reg;\n+\t  cand_t cand;\n+\t  unsigned int cid;\n+\t  bitmap_iterator bi;\n+\t  rtx set;\n+\t  int src_regno = -1, dst_regno = -1;\n+\n+\t  if ((set = single_set (insn)) != NULL\n+\t      && REG_P (SET_SRC (set)) && REG_P (SET_DEST (set)))\n+\t    {\n+\t      src_regno = REGNO (SET_SRC (set));\n+\t      dst_regno = REGNO (SET_DEST (set));\n+\t    }\n+\n+\t  cand = NULL;\n+\t  /* Check possibility of rematerialization (hard reg or\n+\t     unpsilled pseudo <- spilled pseudo): */\n+\t  if (dst_regno >= 0 && src_regno >= FIRST_PSEUDO_REGISTER\n+\t      && reg_renumber[src_regno] < 0\n+\t      && (dst_regno < FIRST_PSEUDO_REGISTER\n+\t\t  || reg_renumber[dst_regno] >= 0))\n+\t    {\n+\t      for (cand = regno_cands[src_regno];\n+\t\t   cand != NULL;\n+\t\t   cand = cand->next_regno_cand)\n+\t\tif (bitmap_bit_p (&avail_cands, cand->index))\n+\t\t  break;\n+\t    }\n+\t  int i, hard_regno, nregs;\n+\t  rtx_insn *remat_insn = NULL;\n+\t  HOST_WIDE_INT cand_sp_offset = 0;\n+\t  if (cand != NULL)\n+\t    {\n+\t      lra_insn_recog_data_t cand_id = lra_get_insn_recog_data (cand->insn);\n+\t      rtx saved_op = *cand_id->operand_loc[cand->nop];\n+\n+\t      /* Check clobbers do not kill something living.  */\n+\t      gcc_assert (REG_P (saved_op));\n+\t      int ignore_regno = REGNO (saved_op); \n+\n+\t      for (reg = cand_id->regs; reg != NULL; reg = reg->next)\n+\t\tif (reg->type != OP_IN && reg->regno != ignore_regno)\n+\t\t  {\n+\t\t    hard_regno = get_hard_regs (reg, nregs);\n+\t\t    gcc_assert (hard_regno >= 0);\n+\t\t    for (i = 0; i < nregs; i++)\n+\t\t      if (TEST_HARD_REG_BIT (live_hard_regs, hard_regno + i))\n+\t\t\tbreak;\n+\t\t    if (i < nregs)\n+\t\t      break;\n+\t\t  }\n+\n+\t      if (reg == NULL)\n+\t\t{\n+\t\t  *cand_id->operand_loc[cand->nop] = SET_DEST (set);\n+\t\t  lra_update_insn_regno_info (cand->insn);\n+\t\t  bool ok_p = lra_constrain_insn (cand->insn);\n+\t\t  if (ok_p)\n+\t\t    {\n+\t\t      rtx remat_pat = copy_insn (PATTERN (cand->insn));\n+\t\t      \n+\t\t      start_sequence ();\n+\t\t      emit_insn (remat_pat);\n+\t\t      remat_insn = get_insns ();\n+\t\t      end_sequence ();\n+\t\t      if (recog_memoized (remat_insn) < 0)\n+\t\t\tremat_insn = NULL;\n+\t\t      cand_sp_offset = cand_id->sp_offset;\n+\t\t    }\n+\t\t  *cand_id->operand_loc[cand->nop] = saved_op;\n+\t\t  lra_update_insn_regno_info (cand->insn);\n+\t\t}\n+\t    }\n+\n+\t  /* Update avail_cands (see analogous code for\n+\t     calculate_gen_cands).  */\n+\t  for (reg = id->regs; reg != NULL; reg = reg->next)\n+\t    if (reg->type != OP_IN\n+\t\t|| find_regno_note (insn, REG_DEAD, reg->regno) != NULL)\n+\t      EXECUTE_IF_SET_IN_BITMAP (&avail_cands, 0, cid, bi)\n+\t\t{\n+\t\t  cand = all_cands[cid];\n+\n+\t\t  /* Ignore the reload insn.  */\n+\t\t  if (src_regno == cand->reload_regno\n+\t\t      && dst_regno == cand->regno)\n+\t\t    continue;\n+\t\t  if (cand->regno == reg->regno\n+\t\t      || input_regno_present_p (cand->insn, reg->regno))\n+\t\t    bitmap_clear_bit (&avail_cands, cand->index);\n+\t\t}\n+\n+\t  if (CALL_P (insn))\n+\t    EXECUTE_IF_SET_IN_BITMAP (&avail_cands, 0, cid, bi)\n+\t      {\n+\t\tcand = all_cands[cid];\n+\t\t\n+\t\tif (call_used_input_regno_present_p (cand->insn))\n+\t\t  bitmap_clear_bit (&avail_cands, cand->index);\n+\t      }\n+\n+\t  if ((cand = insn_to_cand[INSN_UID (insn)]) != NULL)\n+\t    bitmap_set_bit (&avail_cands, cand->index);\n+\t    \n+\t  if (remat_insn != NULL)\n+\t    {\n+\t      HOST_WIDE_INT sp_offset_change = cand_sp_offset - id->sp_offset;\n+\t      if (sp_offset_change != 0)\n+\t\tchange_sp_offset (remat_insn, sp_offset_change);\n+\t      lra_process_new_insns (insn, remat_insn, NULL,\n+\t\t\t\t     \"Inserting rematerialization insn\");\n+\t      lra_set_insn_deleted (insn);\n+\t      changed_p = true;\n+\t      continue;\n+\t    }\n+\n+\t  /* Update live hard regs: */\n+\t  for (reg = id->regs; reg != NULL; reg = reg->next)\n+\t    if (reg->type == OP_IN\n+\t\t&& find_regno_note (insn, REG_DEAD, reg->regno) != NULL)\n+\t      {\n+\t\tif ((hard_regno = get_hard_regs (reg, nregs)) < 0)\n+\t\t  continue;\n+\t\tfor (i = 0; i < nregs; i++)\n+\t\t  CLEAR_HARD_REG_BIT (live_hard_regs, hard_regno + i);\n+\t      }\n+\t    else if (reg->type != OP_IN\n+\t\t     && find_regno_note (insn, REG_UNUSED, reg->regno) == NULL)\n+\t      {\n+\t\tif ((hard_regno = get_hard_regs (reg, nregs)) < 0)\n+\t\t  continue;\n+\t\tfor (i = 0; i < nregs; i++)\n+\t\t  SET_HARD_REG_BIT (live_hard_regs, hard_regno + i);\n+\t      }\n+\t}\n+    }\n+  bitmap_clear (&avail_cands);\n+  return changed_p;\n+}\n+\n+\f\n+\n+/* Entry point of the rematerialization sub-pass.  Return true if we\n+   did any rematerialization.  */\n+bool\n+lra_remat (void)\n+{\n+  basic_block bb;\n+  bool result;\n+  int max_regno = max_reg_num ();\n+\n+  if (! flag_lra_remat)\n+    return false;\n+  timevar_push (TV_LRA_REMAT);\n+  insn_to_cand = XCNEWVEC (cand_t, get_max_uid ());\n+  regno_cands = XCNEWVEC (cand_t, max_regno);\n+  all_cands.create (8000);\n+  call_used_regs_arr_len = 0;\n+  for (int i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (call_used_regs[i])\n+      call_used_regs_arr[call_used_regs_arr_len++] = i;\n+  initiate_cand_table ();\n+  create_cands ();\n+  create_remat_bb_data ();\n+  bitmap_initialize (&temp_bitmap, &reg_obstack);\n+  calculate_local_reg_remat_bb_data ();\n+  calculate_livein_cands ();\n+  calculate_gen_cands ();\n+  bitmap_initialize (&all_blocks, &reg_obstack);\n+  FOR_ALL_BB_FN (bb, cfun)\n+    bitmap_set_bit (&all_blocks, bb->index);\n+  calculate_global_remat_bb_data ();\n+  dump_candidates_and_remat_bb_data ();\n+  result = do_remat ();\n+  all_cands.release ();\n+  bitmap_clear (&temp_bitmap);\n+  finish_remat_bb_data ();\n+  finish_cand_table ();\n+  bitmap_clear (&all_blocks);\n+  free (regno_cands);\n+  free (insn_to_cand);\n+  timevar_pop (TV_LRA_REMAT);\n+  return result;\n+}"}, {"sha": "f21a3abcd6f666af23d6ebf66cbfa7f8cc206992", "filename": "gcc/lra-spills.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9cf932c33070383b9e4f9917ecee76a28e762aa/gcc%2Flra-spills.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9cf932c33070383b9e4f9917ecee76a28e762aa/gcc%2Flra-spills.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-spills.c?ref=d9cf932c33070383b9e4f9917ecee76a28e762aa", "patch": "@@ -445,7 +445,7 @@ remove_pseudos (rtx *loc, rtx_insn *insn)\n \t{\n \t  rtx x = lra_eliminate_regs_1 (insn, pseudo_slots[i].mem,\n \t\t\t\t\tGET_MODE (pseudo_slots[i].mem),\n-\t\t\t\t\tfalse, false, true);\n+\t\t\t\t\t0, false, false, true);\n \t  *loc = x != pseudo_slots[i].mem ? x : copy_rtx (x);\n \t}\n       return;"}, {"sha": "a140f2ab89a4d835db97b03912428f53ef0e4aba", "filename": "gcc/lra.c", "status": "modified", "additions": 59, "deletions": 48, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9cf932c33070383b9e4f9917ecee76a28e762aa/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9cf932c33070383b9e4f9917ecee76a28e762aa/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=d9cf932c33070383b9e4f9917ecee76a28e762aa", "patch": "@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.\tIf not see\n        generated;\n      o Some pseudos might be spilled to assign hard registers to\n        new reload pseudos;\n+     o Recalculating spilled pseudo values (rematerialization);\n      o Changing spilled pseudos to stack memory or their equivalences;\n      o Allocation stack memory changes the address displacement and\n        new iteration is needed.\n@@ -57,19 +58,26 @@ along with GCC; see the file COPYING3.\tIf not see\n  -----------      |              ----------------                   |\n                   |                      |                          |\n                   |                      V         New              |\n-         ----------------    No    ------------  pseudos   -------------------\n-        | Spilled pseudo | change |Constraints:| or insns | Inheritance/split |\n-        |    to memory   |<-------|    RTL     |--------->|  transformations  |\n-        |  substitution  |        | transfor-  |          |    in EBB scope   |\n-         ----------------         |  mations   |           -------------------\n-                |                   ------------\n-                V\n-    -------------------------\n-   | Hard regs substitution, |\n-   |  devirtalization, and   |------> Finish\n-   | restoring scratches got |\n-   |         memory          |\n-    -------------------------\n+                  |                 ------------  pseudos   -------------------\n+                  |                |Constraints:| or insns | Inheritance/split |\n+                  |                |    RTL     |--------->|  transformations  |\n+                  |                | transfor-  |          |    in EBB scope   |\n+                  | substi-        |  mations   |           -------------------\n+                  | tutions         ------------\n+                  |                     | No change\n+          ----------------              V\n+         | Spilled pseudo |      -------------------\n+         |    to memory   |<----| Rematerialization |\n+         |  substitution  |      -------------------\n+          ----------------        \n+                  | No susbtitions\n+                  V                \n+      -------------------------\n+     | Hard regs substitution, |\n+     |  devirtalization, and   |------> Finish\n+     | restoring scratches got |\n+     |         memory          |\n+      -------------------------\n \n    To speed up the process:\n      o We process only insns affected by changes on previous\n@@ -849,38 +857,38 @@ collect_non_operand_hard_regs (rtx *x, lra_insn_recog_data_t data,\n     {\n       if ((regno = REGNO (op)) >= FIRST_PSEUDO_REGISTER)\n \treturn list;\n+      /* Process all regs even unallocatable ones as we need info\n+\t about all regs for rematerialization pass.  */\n       for (last = regno + hard_regno_nregs[regno][mode];\n \t   regno < last;\n \t   regno++)\n-\tif (! TEST_HARD_REG_BIT (lra_no_alloc_regs, regno)\n-\t    || TEST_HARD_REG_BIT (eliminable_regset, regno))\n-\t  {\n-\t    for (curr = list; curr != NULL; curr = curr->next)\n-\t      if (curr->regno == regno && curr->subreg_p == subreg_p\n-\t\t  && curr->biggest_mode == mode)\n-\t\t{\n-\t\t  if (curr->type != type)\n-\t\t    curr->type = OP_INOUT;\n-\t\t  if (curr->early_clobber != early_clobber)\n-\t\t    curr->early_clobber = true;\n-\t\t  break;\n-\t\t}\n-\t    if (curr == NULL)\n+\t{\n+\t  for (curr = list; curr != NULL; curr = curr->next)\n+\t    if (curr->regno == regno && curr->subreg_p == subreg_p\n+\t\t&& curr->biggest_mode == mode)\n \t      {\n-\t\t/* This is a new hard regno or the info can not be\n-\t\t   integrated into the found structure.\t */\n+\t\tif (curr->type != type)\n+\t\t  curr->type = OP_INOUT;\n+\t\tif (curr->early_clobber != early_clobber)\n+\t\t  curr->early_clobber = true;\n+\t\tbreak;\n+\t      }\n+\t  if (curr == NULL)\n+\t    {\n+\t      /* This is a new hard regno or the info can not be\n+\t\t integrated into the found structure.\t */\n #ifdef STACK_REGS\n-\t\tearly_clobber\n-\t\t  = (early_clobber\n-\t\t     /* This clobber is to inform popping floating\n-\t\t\tpoint stack only.  */\n-\t\t     && ! (FIRST_STACK_REG <= regno\n-\t\t\t   && regno <= LAST_STACK_REG));\n+\t      early_clobber\n+\t\t= (early_clobber\n+\t\t   /* This clobber is to inform popping floating\n+\t\t      point stack only.  */\n+\t\t   && ! (FIRST_STACK_REG <= regno\n+\t\t\t && regno <= LAST_STACK_REG));\n #endif\n-\t\tlist = new_insn_reg (data->insn, regno, type, mode, subreg_p,\n-\t\t\t\t     early_clobber, list);\n-\t      }\n-\t  }\n+\t      list = new_insn_reg (data->insn, regno, type, mode, subreg_p,\n+\t\t\t\t   early_clobber, list);\n+\t    }\n+\t}\n       return list;\n     }\n   switch (code)\n@@ -1456,10 +1464,8 @@ add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x, int uid,\n   if (REG_P (x))\n     {\n       regno = REGNO (x);\n-      if (regno < FIRST_PSEUDO_REGISTER\n-\t  && TEST_HARD_REG_BIT (lra_no_alloc_regs, regno)\n-\t  && ! TEST_HARD_REG_BIT (eliminable_regset, regno))\n-\treturn;\n+      /* Process all regs even unallocatable ones as we need info about\n+\t all regs for rematerialization pass.  */\n       expand_reg_info ();\n       if (bitmap_set_bit (&lra_reg_info[regno].insn_bitmap, uid))\n \t{\n@@ -2152,9 +2158,6 @@ bitmap_head lra_optional_reload_pseudos;\n    pass.  */\n bitmap_head lra_subreg_reload_pseudos;\n \n-/* First UID of insns generated before a new spill pass.  */\n-int lra_constraint_new_insn_uid_start;\n-\n /* File used for output of LRA debug information.  */\n FILE *lra_dump_file;\n \n@@ -2252,7 +2255,6 @@ lra (FILE *f)\n   lra_curr_reload_num = 0;\n   push_insns (get_last_insn (), NULL);\n   /* It is needed for the 1st coalescing.  */\n-  lra_constraint_new_insn_uid_start = get_max_uid ();\n   bitmap_initialize (&lra_inheritance_pseudos, &reg_obstack);\n   bitmap_initialize (&lra_split_regs, &reg_obstack);\n   bitmap_initialize (&lra_optional_reload_pseudos, &reg_obstack);\n@@ -2345,12 +2347,21 @@ lra (FILE *f)\n \t  lra_create_live_ranges (lra_reg_spill_p);\n \t  live_p = true;\n \t}\n+      /* Now we know what pseudos should be spilled.  Try to\n+\t rematerialize them first.  */\n+      if (lra_remat ())\n+\t{\n+\t  /* We need full live info -- see the comment above.  */\n+\t  lra_create_live_ranges (lra_reg_spill_p);\n+\t  live_p = true;\n+\t  if (! lra_need_for_spills_p ())\n+\t    break;\n+\t}\n       lra_spill ();\n       /* Assignment of stack slots changes elimination offsets for\n \t some eliminations.  So update the offsets here.  */\n       lra_eliminate (false, false);\n       lra_constraint_new_regno_start = max_reg_num ();\n-      lra_constraint_new_insn_uid_start = get_max_uid ();\n       lra_assignment_iter_after_spill = 0;\n     }\n   restore_scratches ();"}, {"sha": "4df7389fc78af06d75982b2ac8dca57093a857e0", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9cf932c33070383b9e4f9917ecee76a28e762aa/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9cf932c33070383b9e4f9917ecee76a28e762aa/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=d9cf932c33070383b9e4f9917ecee76a28e762aa", "patch": "@@ -500,6 +500,7 @@ static const struct default_options default_options_table[] =\n     { OPT_LEVELS_2_PLUS, OPT_fipa_icf, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_fisolate_erroneous_paths_dereference, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_fuse_caller_save, NULL, 1 },\n+    { OPT_LEVELS_2_PLUS, OPT_flra_remat, NULL, 1 },\n \n     /* -O3 optimizations.  */\n     { OPT_LEVELS_3_PLUS, OPT_ftree_loop_distribute_patterns, NULL, 1 },"}, {"sha": "95c84ad98574d01e03870879a1fb3782cd42e5d0", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9cf932c33070383b9e4f9917ecee76a28e762aa/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9cf932c33070383b9e4f9917ecee76a28e762aa/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=d9cf932c33070383b9e4f9917ecee76a28e762aa", "patch": "@@ -237,6 +237,7 @@ DEFTIMEVAR (TV_LRA_INHERITANCE\t     , \"LRA reload inheritance\")\n DEFTIMEVAR (TV_LRA_CREATE_LIVE_RANGES, \"LRA create live ranges\")\n DEFTIMEVAR (TV_LRA_ASSIGN\t     , \"LRA hard reg assignment\")\n DEFTIMEVAR (TV_LRA_COALESCE\t     , \"LRA coalesce pseudo regs\")\n+DEFTIMEVAR (TV_LRA_REMAT\t     , \"LRA rematerialization\")\n DEFTIMEVAR (TV_RELOAD\t\t     , \"reload\")\n DEFTIMEVAR (TV_RELOAD_CSE_REGS       , \"reload CSE regs\")\n DEFTIMEVAR (TV_GCSE_AFTER_RELOAD     , \"load CSE after reload\")"}]}