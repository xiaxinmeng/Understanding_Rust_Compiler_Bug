{"sha": "de22184bb226fedca7b991f096b8d8befb9aba6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGUyMjE4NGJiMjI2ZmVkY2E3Yjk5MWYwOTZiOGQ4YmVmYjlhYmE2Zg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-01-21T21:32:30Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-01-21T21:32:30Z"}, "message": "90th Cygnus<->FSF quick merge\n\nFrom-SVN: r13542", "tree": {"sha": "92bcfc0ecf826b973e72cd47cdbea7f390107f9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92bcfc0ecf826b973e72cd47cdbea7f390107f9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de22184bb226fedca7b991f096b8d8befb9aba6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de22184bb226fedca7b991f096b8d8befb9aba6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de22184bb226fedca7b991f096b8d8befb9aba6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de22184bb226fedca7b991f096b8d8befb9aba6f/comments", "author": null, "committer": null, "parents": [{"sha": "85b119d1b75639e119c2723d1a4cd3c422e16ed4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85b119d1b75639e119c2723d1a4cd3c422e16ed4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85b119d1b75639e119c2723d1a4cd3c422e16ed4"}], "stats": {"total": 543, "additions": 346, "deletions": 197}, "files": [{"sha": "932e4962e6f5144387062427bc0d8d08245a1c10", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=de22184bb226fedca7b991f096b8d8befb9aba6f", "patch": "@@ -1,3 +1,120 @@\n+Mon Jan 20 17:59:51 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* call.c (standard_conversion): Handle getting references.  Tack\n+ \ton RVALUE_CONV here.  Do it for non-class types, too.\n+\t(reference_binding): Pass references to standard_conversion.\n+\t(implicit_conversion): Likewise.\n+\t(add_builtin_candidate): Disable one ?: kludge.\n+\t(convert_like): Handle RVALUE_CONVs for non-class types.\n+\t(joust): Disable the other ?: kludge.\n+\n+Mon Jan 20 14:53:13 1997  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* decl.c (init_decl_processing): Add code to build up common\n+\tfunction types beforehand, to avoid creation then removal of\n+\tthings already in the hash table.\n+\n+Mon Jan 20 14:43:49 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (finish_function): Also zero out DECL_INCOMING_RTL for\n+ \tthe arguments.\n+\n+\t* error.c (dump_expr, TEMPLATE_CONST_PARM): Don't require\n+ \tcurrent_template_parms.\n+\n+Fri Jan 17 10:25:42 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* search.c (lookup_field): Don't return a function, check want_type.\n+\n+Thu Jan 16 18:14:35 1997  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* init.c (build_new): Make sure PLACEMENT has a type.\n+\n+Thu Jan 16 17:40:28 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* init.c (build_new): Support new (nothrow).\n+\n+Wed Jan 15 12:38:14 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (instantiate_decl): Also do push_to_top_level before setting\n+\tup DECL_INITIAL.\n+\n+\t* cp-tree.h (PARM_DEFAULT_FROM_TEMPLATE): New macro.\n+\t* pt.c (tsubst): Defer instantiation of default args.\n+\t* call.c (build_over_call): Until here.\n+\n+Wed Jan 15 10:08:10 1997  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* search.c (lookup_field): Make sure we have an\n+\tIDENTIFIER_CLASS_VALUE before we try to return it.\n+\n+Thu Jan  9 07:19:01 1997  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* call.c (build_method_call): Delete unused var PARM.\n+\t(build_overload_call_real): Likewise.\n+\t(build_object_call): Delete unused var P.\n+\t(build_new_op): Likewise.\n+\t* decl.c (builtin_type_tdescs_{arr, len, max}): #if 0 out static\n+\tvar definitions, which are never used.\n+\t(shadow_tag): Delete unused var FN.\n+\t* expr.c (cplus_expand_expr): Delete unused var ORIGINAL_TARGET.\n+\t* init.c (build_new): Delete unused var ALLOC_TEMP.\n+\t* method.c (hack_identifier): Delete unused var CONTEXT.\n+\t(do_build_copy_constructor): Delete unused var NAME.\n+\t(synthesize_method): Delete unused var BASE.\n+\t* pt.c (lookup_template_class): Delete unused var CODE_TYPE_NODE.\n+\t* rtti.c (build_headof): Delete unused var VPTR.\n+\t(get_typeid): Delete unused var T.\n+\t* typeck.c (build_conditional_expr): Delete unused vars ORIG_OP1\n+\tand ORIG_OP2.\n+\t(build_ptrmemfunc): Delete unused vars U and NINDEX.\n+\t* typeck2.c (build_functional_cast): Delete unused var BINFO.\n+\n+Wed Jan  8 13:09:54 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* search.c (lookup_field): Use IDENTIFIER_CLASS_VALUE to look up\n+\tthings in a type being defined.\n+\t* decl.c (finish_enum): Reverse the values so that they are in\n+\tthe correct order.\n+\n+\t* pt.c (instantiate_class_template): Don't initialize\n+ \tBINFO_BASETYPES until the vector is filled out.\n+\t(unify): Don't abort on conflicting bindings, just fail.\n+\t(instantiate_decl): Do push_tinst_level before any tsubsting.\n+\n+\t* method.c (build_overload_value): Handle getting a\n+ \tTEMPLATE_CONST_PARM for a pointer.\n+\n+Tue Jan  7 14:00:58 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* init.c (expand_member_init): Don't give 'not a base' error for\n+ \ttemplates.\n+\n+\t* pt.c (instantiate_decl): Call import_export_decl later.\n+\n+\t* pt.c (instantiate_class_template): Return a value.\n+\n+\t* parse.y (extension): New rule for __extension__.\n+\t(extdef, unary_expr, decl, component_decl): Use it.\n+\n+Tue Jan  7 09:20:28 1997  Mike Stump  <mrs@cygnus.com>\n+\n+\t* class.c (base_binfo): Remove unused base_has_virtual member.\n+\t(finish_base_struct): Likewise.\n+\t(finish_struct_1): Likewise.\n+\n+Tue Dec 31 20:25:50 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* search.c (expand_upcast_fixups): Fix bogus code generation\n+\tproblem where the generated code uses the wrong index into the\n+\truntime built vtable on the stack.  Old code could clobber random\n+\tstack values.\n+\n+Tue Dec 31 15:16:56 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* init.c (perform_member_init): Make sure the partial EH cleanups\n+ \tlive on the function_obstack.\n+\n Fri Dec 27 10:31:40 1996  Paul Eggert  <eggert@twinsun.com>\n \n \t* Make-lang.in (g++spec.o): Don't use $< with an explicit target;"}, {"sha": "c2c0eddc71057d7835587fcb88dcafa8b0aac9da", "filename": "gcc/cp/call.c", "status": "modified", "additions": 66, "deletions": 36, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=de22184bb226fedca7b991f096b8d8befb9aba6f", "patch": "@@ -1650,7 +1650,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n {\n   register tree function, fntype, value_type;\n   register tree basetype, save_basetype;\n-  register tree baselink, result, parmtypes, parm;\n+  register tree baselink, result, parmtypes;\n   tree last;\n   int pass;\n   tree access = access_public_node;\n@@ -2629,7 +2629,7 @@ build_overload_call_real (fnname, parms, flags, final_cp, require_complete)\n      int require_complete;\n {\n   /* must check for overloading here */\n-  tree functions, function, parm;\n+  tree functions, function;\n   tree parmtypes, last;\n   register tree outer;\n   int length;\n@@ -2976,6 +2976,15 @@ non_reference (t)\n   return t;\n }\n \n+tree\n+strip_top_quals (t)\n+     tree t;\n+{\n+  if (TREE_CODE (t) == ARRAY_TYPE)\n+    return t;\n+  return TYPE_MAIN_VARIANT (t);\n+}\n+\n /* Returns the standard conversion path (see [conv]) from type FROM to type\n    TO, if any.  For proper handling of null pointer constants, you must\n    also pass the expression EXPR to convert from.  */\n@@ -2986,15 +2995,23 @@ standard_conversion (to, from, expr)\n {\n   enum tree_code fcode, tcode;\n   tree conv;\n+  int fromref = 0;\n+\n+  if (TREE_CODE (to) == REFERENCE_TYPE)\n+    to = TREE_TYPE (to);\n+  if (TREE_CODE (from) == REFERENCE_TYPE)\n+    {\n+      fromref = 1;\n+      from = TREE_TYPE (from);\n+    }\n+  to = strip_top_quals (to);\n+  from = strip_top_quals (from);\n \n   fcode = TREE_CODE (from);\n   tcode = TREE_CODE (to);\n \n   conv = build1 (IDENTITY_CONV, from, expr);\n \n-  if (from == to)\n-    return conv;\n-\n   if (fcode == FUNCTION_TYPE)\n     {\n       from = build_pointer_type (from);\n@@ -3007,6 +3024,11 @@ standard_conversion (to, from, expr)\n       fcode = TREE_CODE (from);\n       conv = build_conv (LVALUE_CONV, from, conv);\n     }\n+  else if (fromref || (expr && real_lvalue_p (expr)))\n+    conv = build_conv (RVALUE_CONV, from, conv);\n+\n+  if (from == to)\n+    return conv;\n \n   if ((tcode == POINTER_TYPE || TYPE_PTRMEMFUNC_P (to))\n       && expr && null_ptr_cst_p (expr))\n@@ -3129,15 +3151,6 @@ standard_conversion (to, from, expr)\n   return conv;\n }\n \n-tree\n-strip_top_quals (t)\n-     tree t;\n-{\n-  if (TREE_CODE (t) == ARRAY_TYPE)\n-    return t;\n-  return TYPE_MAIN_VARIANT (t);\n-}\n-\n /* Returns the conversion path from type FROM to reference type TO for\n    purposes of reference binding.  For lvalue binding, either pass a\n    reference type to FROM or an lvalue expression to EXPR.\n@@ -3146,13 +3159,14 @@ strip_top_quals (t)\n    an lvalue and a temporary.  Should it?  */\n \n tree\n-reference_binding (rto, from, expr, flags)\n-     tree rto, from, expr;\n+reference_binding (rto, rfrom, expr, flags)\n+     tree rto, rfrom, expr;\n      int flags;\n {\n   tree conv;\n   int lvalue = 1;\n   tree to = TREE_TYPE (rto);\n+  tree from = rfrom;\n \n   if (TREE_CODE (from) == REFERENCE_TYPE)\n     from = TREE_TYPE (from);\n@@ -3181,13 +3195,13 @@ reference_binding (rto, from, expr, flags)\n \n   if (! conv)\n     {\n-      conv = standard_conversion\n-\t(TYPE_MAIN_VARIANT (to), strip_top_quals (from), expr);\n+      conv = standard_conversion (to, rfrom, expr);\n       if (conv)\n \t{\n \t  conv = build_conv (REF_BIND, rto, conv);\n \n-\t  /* Bind directly to a base subobject of a class rvalue.  */\n+\t  /* Bind directly to a base subobject of a class rvalue.  Do it\n+             after building the conversion for proper handling of ICS_RANK.  */\n \t  if (TREE_CODE (TREE_OPERAND (conv, 0)) == BASE_CONV)\n \t    TREE_OPERAND (conv, 0) = TREE_OPERAND (TREE_OPERAND (conv, 0), 0);\n \t}\n@@ -3223,16 +3237,10 @@ implicit_conversion (to, from, expr, flags)\n   if (TREE_CODE (to) == REFERENCE_TYPE)\n     conv = reference_binding (to, from, expr, flags);\n   else\n-    conv = standard_conversion\n-      (TYPE_MAIN_VARIANT (non_reference (to)),\n-       strip_top_quals (non_reference (from)), expr);\n+    conv = standard_conversion (to, from, expr);\n \n   if (conv)\n-    {\n-      if (TREE_CODE (conv) == IDENTITY_CONV && IS_AGGR_TYPE (to)\n-\t  && (TREE_CODE (from) == REFERENCE_TYPE || (expr && real_lvalue_p (expr))))\n-\tconv = build_conv (RVALUE_CONV, to, conv);\n-    }\n+    ;\n   else if ((IS_AGGR_TYPE (non_reference (from))\n \t    || IS_AGGR_TYPE (non_reference (to)))\n \t   && (flags & LOOKUP_NO_CONVERSION) == 0)\n@@ -3833,9 +3841,18 @@ add_builtin_candidate (candidates, code, code2, fnname, type1, type2,\n       break;\n \n     case COND_EXPR:\n+#if 0\n       /* Kludge around broken overloading rules whereby\n-\t bool ? const char& : enum is ambiguous.  */\n+\t bool ? const char& : enum is ambiguous\n+\t (between int and const char&).  */\n+      /* Not needed for compiles without -pedantic, since the rank compare\n+\t in joust will pick the int promotion.  Let's just leave this out\n+\t for now.  */\n       flags |= LOOKUP_NO_TEMP_BIND;\n+#endif\n+\n+      /* Extension: Support ?: of enumeral type.  Hopefully this will not\n+         be an extension for long.  */\n       if (TREE_CODE (type1) == ENUMERAL_TYPE && type1 == type2)\n \tbreak;\n       else if (TREE_CODE (type1) == ENUMERAL_TYPE\n@@ -4342,8 +4359,7 @@ build_object_call (obj, args)\n      tree obj, args;\n {\n   struct z_candidate *candidates = 0, *cand;\n-  tree fns, convs, mem_args, *p;\n-  enum tree_code code2 = NOP_EXPR;\n+  tree fns, convs, mem_args;\n   tree type = TREE_TYPE (obj);\n \n   fns = lookup_fnfields (TYPE_BINFO (type), ansi_opname [CALL_EXPR], 0);\n@@ -4442,7 +4458,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n      tree arg1, arg2, arg3;\n {\n   struct z_candidate *candidates = 0, *cand;\n-  tree fns, mem_arglist, arglist, fnname, *p;\n+  tree fns, mem_arglist, arglist, fnname;\n   enum tree_code code2 = NOP_EXPR;\n   tree templates = NULL_TREE;\n \n@@ -4893,8 +4909,11 @@ convert_like (convs, expr)\n \n   switch (TREE_CODE (convs))\n     {\n-    case BASE_CONV:\n     case RVALUE_CONV:\n+      if (! IS_AGGR_TYPE (TREE_TYPE (convs)))\n+\treturn expr;\n+      /* else fall through */\n+    case BASE_CONV:\n       return build_user_type_conversion\n \t(TREE_TYPE (convs), expr, LOOKUP_NORMAL);\n     case REF_BIND:\n@@ -5035,10 +5054,18 @@ build_over_call (fn, convs, args, flags)\n \n   /* Default arguments */\n   for (; parm && parm != void_list_node; parm = TREE_CHAIN (parm))\n-    converted_args = tree_cons\n-      (NULL_TREE,\n-       convert_default_arg (TREE_VALUE (parm), TREE_PURPOSE (parm)),\n-       converted_args);\n+    {\n+      tree arg = TREE_PURPOSE (parm);\n+\n+      if (PARM_DEFAULT_FROM_TEMPLATE (parm))\n+\t/* This came from a template.  Instantiate the default arg here,\n+\t   not in tsubst.  */\n+\targ = tsubst_expr (arg, &TREE_VEC_ELT (DECL_TI_ARGS (fn), 0),\n+\t\t\t   TREE_VEC_LENGTH (DECL_TI_ARGS (fn)), NULL_TREE);\n+      converted_args = tree_cons\n+\t(NULL_TREE, convert_default_arg (TREE_VALUE (parm), arg),\n+\t converted_args);\n+    }\n \n   /* Ellipsis */\n   for (; arg; arg = TREE_CHAIN (arg))\n@@ -5667,8 +5694,10 @@ joust (cand1, cand2)\n \t  break;\n       if (i == TREE_VEC_LENGTH (cand1->convs))\n \treturn 1;\n+#if 0\n       /* Kludge around broken overloading rules whereby\n \t bool ? void *const & : void *const & is ambiguous.  */\n+      /* Huh?  Explain the problem better.  */\n       if (cand1->fn == ansi_opname[COND_EXPR])\n \t{\n \t  tree c1 = TREE_VEC_ELT (cand1->convs, 1);\n@@ -5684,6 +5713,7 @@ joust (cand1, cand2)\n \t\treturn -1;\n \t    }\n \t}\n+#endif\n     }\n \n tweak:"}, {"sha": "42732cc924a42b8787c7634f6b57410aa412128b", "filename": "gcc/cp/class.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=de22184bb226fedca7b991f096b8d8befb9aba6f", "patch": "@@ -1429,7 +1429,6 @@ struct base_info\n   char cant_have_default_ctor;\n   char cant_have_const_ctor;\n   char no_const_asn_ref;\n-  char base_has_virtual;\n };\n \n /* Record information about type T derived from its base classes.\n@@ -1547,9 +1546,6 @@ finish_base_struct (t, b, t_binfo)\n \n       if (TYPE_VIRTUAL_P (basetype))\n \t{\n-\t  /* Remember that the baseclass has virtual members.  */\n-\t  b->base_has_virtual = 1;\n-\n \t  /* Ensure that this is set from at least a virtual base\n              class.  */\n \t  if (b->rtti == NULL_TREE)\n@@ -3026,7 +3022,6 @@ finish_struct_1 (t, warn_anon)\n   tree fields = TYPE_FIELDS (t);\n   tree fn_fields = TYPE_METHODS (t);\n   tree x, last_x, method_vec;\n-  int base_has_virtual;\n   int all_virtual;\n   int has_virtual;\n   int max_has_virtual;\n@@ -3126,7 +3121,6 @@ finish_struct_1 (t, warn_anon)\n       cant_have_default_ctor = base_info.cant_have_default_ctor;\n       cant_have_const_ctor = base_info.cant_have_const_ctor;\n       no_const_asn_ref = base_info.no_const_asn_ref;\n-      base_has_virtual = base_info.base_has_virtual;\n       n_baseclasses = TREE_VEC_LENGTH (BINFO_BASETYPES (t_binfo));\n       aggregate = 0;\n     }\n@@ -3142,7 +3136,6 @@ finish_struct_1 (t, warn_anon)\n       cant_have_default_ctor = 0;\n       cant_have_const_ctor = 0;\n       no_const_asn_ref = 0;\n-      base_has_virtual = 0;\n     }\n \n #if 0"}, {"sha": "c1ab7b09b986c6b59b5d50309adf4a80238c0a63", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=de22184bb226fedca7b991f096b8d8befb9aba6f", "patch": "@@ -1095,6 +1095,10 @@ struct lang_decl\n #define DELETE_EXPR_USE_VEC(NODE)\tTREE_LANG_FLAG_1 (NODE)\n #define LOOKUP_EXPR_GLOBAL(NODE)\tTREE_LANG_FLAG_0 (NODE)\n \n+/* For a TREE_LIST node representing a function parm type and its default arg,\n+   did the default arg come from a template?  */\n+#define PARM_DEFAULT_FROM_TEMPLATE(NODE) TREE_LANG_FLAG_0 (NODE)\n+\n /* Nonzero in INT_CST means that this int is negative by dint of\n    using a twos-complement negated operand.  */\n #define TREE_NEGATED_INT(NODE) (TREE_LANG_FLAG_0 (NODE))"}, {"sha": "1cc297f3d5ba12e529b60689b1e9b2ce38bc3dc6", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 41, "deletions": 73, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=de22184bb226fedca7b991f096b8d8befb9aba6f", "patch": "@@ -4531,10 +4531,13 @@ signal_catch (sig)\n   my_friendly_abort (0);\n }\n \n+#if 0\n+/* Unused -- brendan 970107 */\n /* Array for holding types considered \"built-in\".  These types\n    are output in the module in which `main' is defined.  */\n static tree *builtin_type_tdescs_arr;\n static int builtin_type_tdescs_len, builtin_type_tdescs_max;\n+#endif\n \n /* Push the declarations of builtin types into the namespace.\n    RID_INDEX, if < RID_MAX is the index of the builtin type\n@@ -4612,7 +4615,7 @@ void\n init_decl_processing ()\n {\n   tree decl;\n-  register tree endlink, int_endlink, double_endlink;\n+  register tree endlink, int_endlink, double_endlink, unsigned_endlink;\n   tree fields[20];\n   /* Data type of memcpy.  */\n   tree memcpy_ftype, strlen_ftype;\n@@ -4623,6 +4626,9 @@ init_decl_processing ()\n   tree vb_off_identifier;\n   /* Function type `char *(char *, char *)' and similar ones */\n   tree string_ftype_ptr_ptr, int_ftype_string_string;\n+  tree sizetype_endlink;\n+  tree ptr_ftype, ptr_ftype_unsigned, ptr_ftype_sizetype;\n+  tree void_ftype, void_ftype_int, void_ftype_ptr;\n \n   /* Have to make these distinct before we try using them.  */\n   lang_name_cplusplus = get_identifier (\"C++\");\n@@ -4878,6 +4884,19 @@ init_decl_processing ()\n   endlink = void_list_node;\n   int_endlink = tree_cons (NULL_TREE, integer_type_node, endlink);\n   double_endlink = tree_cons (NULL_TREE, double_type_node, endlink);\n+  unsigned_endlink = tree_cons (NULL_TREE, unsigned_type_node, endlink);\n+\n+  ptr_ftype = build_function_type (ptr_type_node, NULL_TREE);\n+  ptr_ftype_unsigned = build_function_type (ptr_type_node, unsigned_endlink);\n+  sizetype_endlink = tree_cons (NULL_TREE, sizetype, endlink);\n+  /* We realloc here because sizetype could be int or unsigned.  S'ok.  */\n+  ptr_ftype_sizetype = build_function_type (ptr_type_node, sizetype_endlink);\n+\n+  void_ftype = build_function_type (void_type_node, endlink);\n+  void_ftype_int = build_function_type (void_type_node, int_endlink);\n+  void_ftype_ptr\n+    = build_function_type (void_type_node,\n+ \t\t\t   tree_cons (NULL_TREE, ptr_type_node, endlink));\n \n   float_ftype_float\n     = build_function_type (float_type_node,\n@@ -4935,9 +4954,7 @@ init_decl_processing ()\n     = build_function_type (ptr_type_node,\n \t\t\t   tree_cons (NULL_TREE, ptr_type_node,\n \t\t\t\t      tree_cons (NULL_TREE, const_ptr_type_node,\n-\t\t\t\t\t\t tree_cons (NULL_TREE,\n-\t\t\t\t\t\t\t    sizetype,\n-\t\t\t\t\t\t\t    endlink))));\n+\t\t\t\t\t\t sizetype_endlink)));\n \n   if (flag_huge_objects)\n     delta_type_node = long_integer_type_node;\n@@ -4948,44 +4965,27 @@ init_decl_processing ()\n \t\t    BUILT_IN_CONSTANT_P, NULL_PTR);\n \n   builtin_return_address_fndecl =\n-  builtin_function (\"__builtin_return_address\",\n-\t\t    build_function_type (ptr_type_node, \n-\t\t\t\t\t tree_cons (NULL_TREE,\n-\t\t\t\t\t\t    unsigned_type_node,\n-\t\t\t\t\t\t    endlink)),\n+  builtin_function (\"__builtin_return_address\", ptr_ftype_unsigned,\n \t\t    BUILT_IN_RETURN_ADDRESS, NULL_PTR);\n \n-  builtin_function (\"__builtin_frame_address\",\n-\t\t    build_function_type (ptr_type_node, \n-\t\t\t\t\t tree_cons (NULL_TREE,\n-\t\t\t\t\t\t    unsigned_type_node,\n-\t\t\t\t\t\t    endlink)),\n+  builtin_function (\"__builtin_frame_address\", ptr_ftype_unsigned,\n \t\t    BUILT_IN_FRAME_ADDRESS, NULL_PTR);\n \n-  builtin_function (\"__builtin_alloca\",\n-\t\t    build_function_type (ptr_type_node,\n-\t\t\t\t\t tree_cons (NULL_TREE,\n-\t\t\t\t\t\t    sizetype,\n-\t\t\t\t\t\t    endlink)),\n+  builtin_function (\"__builtin_alloca\", ptr_ftype_sizetype,\n \t\t    BUILT_IN_ALLOCA, \"alloca\");\n   builtin_function (\"__builtin_ffs\", int_ftype_int, BUILT_IN_FFS, NULL_PTR);\n   /* Define alloca, ffs as builtins.\n      Declare _exit just to mark it as volatile.  */\n   if (! flag_no_builtin && !flag_no_nonansi_builtin)\n     {\n-      temp = builtin_function (\"alloca\",\n-\t\t\t       build_function_type (ptr_type_node,\n-\t\t\t\t\t\t    tree_cons (NULL_TREE,\n-\t\t\t\t\t\t\t       sizetype,\n-\t\t\t\t\t\t\t       endlink)),\n+      temp = builtin_function (\"alloca\", ptr_ftype_sizetype,\n \t\t\t       BUILT_IN_ALLOCA, NULL_PTR);\n       /* Suppress error if redefined as a non-function.  */\n       DECL_BUILT_IN_NONANSI (temp) = 1;\n       temp = builtin_function (\"ffs\", int_ftype_int, BUILT_IN_FFS, NULL_PTR);\n       /* Suppress error if redefined as a non-function.  */\n       DECL_BUILT_IN_NONANSI (temp) = 1;\n-      temp = builtin_function (\"_exit\", build_function_type (void_type_node,\n-\t\t\t\t\t\t\t     int_endlink),\n+      temp = builtin_function (\"_exit\", void_ftype_int,\n \t\t\t       NOT_BUILT_IN, NULL_PTR);\n       TREE_THIS_VOLATILE (temp) = 1;\n       TREE_SIDE_EFFECTS (temp) = 1;\n@@ -5002,42 +5002,27 @@ init_decl_processing ()\n \t\t    NULL_PTR);\n   builtin_function (\"__builtin_labs\", long_ftype_long,\n \t\t    BUILT_IN_LABS, NULL_PTR);\n-  builtin_function (\"__builtin_saveregs\",\n-\t\t    build_function_type (ptr_type_node, NULL_TREE),\n+  builtin_function (\"__builtin_saveregs\", ptr_ftype,\n \t\t    BUILT_IN_SAVEREGS, NULL_PTR);\n   builtin_function (\"__builtin_classify_type\", default_function_type,\n \t\t    BUILT_IN_CLASSIFY_TYPE, NULL_PTR);\n-  builtin_function (\"__builtin_next_arg\",\n-\t\t    build_function_type (ptr_type_node, NULL_TREE),\n+  builtin_function (\"__builtin_next_arg\", ptr_ftype,\n \t\t    BUILT_IN_NEXT_ARG, NULL_PTR);\n-  builtin_function (\"__builtin_args_info\",\n-\t\t    build_function_type (integer_type_node,\n-\t\t\t\t\t tree_cons (NULL_TREE,\n-\t\t\t\t\t\t    integer_type_node,\n-\t\t\t\t\t\t    endlink)),\n+  builtin_function (\"__builtin_args_info\", int_ftype_int,\n \t\t    BUILT_IN_ARGS_INFO, NULL_PTR);\n \n   /* Untyped call and return.  */\n-  builtin_function (\"__builtin_apply_args\",\n-\t\t    build_function_type (ptr_type_node, NULL_TREE),\n+  builtin_function (\"__builtin_apply_args\", ptr_ftype,\n \t\t    BUILT_IN_APPLY_ARGS, NULL_PTR);\n \n   temp = tree_cons (NULL_TREE,\n \t\t    build_pointer_type (build_function_type (void_type_node,\n \t\t\t\t\t\t\t     NULL_TREE)),\n-\t\t    tree_cons (NULL_TREE,\n-\t\t\t       ptr_type_node,\n-\t\t\t       tree_cons (NULL_TREE,\n-\t\t\t\t\t  sizetype,\n-\t\t\t\t\t  endlink)));\n+\t\t    ptr_ftype_sizetype);\n   builtin_function (\"__builtin_apply\",\n \t\t    build_function_type (ptr_type_node, temp),\n \t\t    BUILT_IN_APPLY, NULL_PTR);\n-  builtin_function (\"__builtin_return\",\n-\t\t    build_function_type (void_type_node,\n-\t\t\t\t\t tree_cons (NULL_TREE,\n-\t\t\t\t\t\t    ptr_type_node,\n-\t\t\t\t\t\t    endlink)),\n+  builtin_function (\"__builtin_return\", void_ftype_ptr,\n \t\t    BUILT_IN_RETURN, NULL_PTR);\n \n   /* Currently under experimentation.  */\n@@ -5101,16 +5086,14 @@ init_decl_processing ()\n \n       /* Declare these functions volatile\n \t to avoid spurious \"control drops through\" warnings.  */\n-      temp = builtin_function (\"abort\",\n-\t\t\t       build_function_type (void_type_node, endlink),\n+      temp = builtin_function (\"abort\", void_ftype,\n \t\t\t       NOT_BUILT_IN, NULL_PTR);\n       TREE_THIS_VOLATILE (temp) = 1;\n       TREE_SIDE_EFFECTS (temp) = 1;\n       /* Well, these are actually ANSI, but we can't set DECL_BUILT_IN on\n          them...  */\n       DECL_BUILT_IN_NONANSI (temp) = 1;\n-      temp = builtin_function (\"exit\", build_function_type (void_type_node,\n-\t\t\t\t\t\t\t    int_endlink),\n+      temp = builtin_function (\"exit\", void_ftype_int,\n \t\t\t       NOT_BUILT_IN, NULL_PTR);\n       TREE_THIS_VOLATILE (temp) = 1;\n       TREE_SIDE_EFFECTS (temp) = 1;\n@@ -5375,30 +5358,17 @@ init_decl_processing ()\n   /* Now, C++.  */\n   current_lang_name = lang_name_cplusplus;\n \n-  auto_function (ansi_opname[(int) NEW_EXPR],\n-\t\t build_function_type (ptr_type_node,\n-\t\t\t\t      tree_cons (NULL_TREE, sizetype,\n-\t\t\t\t\t\t void_list_node)),\n+  auto_function (ansi_opname[(int) NEW_EXPR], ptr_ftype_sizetype,\n \t\t NOT_BUILT_IN);\n-  auto_function (ansi_opname[(int) VEC_NEW_EXPR],\n-\t\t build_function_type (ptr_type_node,\n-\t\t\t\t      tree_cons (NULL_TREE, sizetype,\n-\t\t\t\t\t\t void_list_node)),\n+  auto_function (ansi_opname[(int) VEC_NEW_EXPR], ptr_ftype_sizetype,\n \t\t NOT_BUILT_IN);\n-  auto_function (ansi_opname[(int) DELETE_EXPR],\n-\t\t build_function_type (void_type_node,\n-\t\t\t\t      tree_cons (NULL_TREE, ptr_type_node,\n-\t\t\t\t\t\t void_list_node)),\n+  auto_function (ansi_opname[(int) DELETE_EXPR], void_ftype_ptr,\n \t\t NOT_BUILT_IN);\n-  auto_function (ansi_opname[(int) VEC_DELETE_EXPR],\n-\t\t build_function_type (void_type_node,\n-\t\t\t\t      tree_cons (NULL_TREE, ptr_type_node,\n-\t\t\t\t\t\t void_list_node)),\n+  auto_function (ansi_opname[(int) VEC_DELETE_EXPR], void_ftype_ptr,\n \t\t NOT_BUILT_IN);\n \n   abort_fndecl\n-    = define_function (\"__pure_virtual\",\n-\t\t       build_function_type (void_type_node, void_list_node),\n+    = define_function (\"__pure_virtual\", void_ftype,\n \t\t       NOT_BUILT_IN, 0, 0);\n \n   /* Perform other language dependent initializations.  */\n@@ -5600,8 +5570,6 @@ shadow_tag (declspecs)\n \t      && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))))\n     {\n       /* See also grok_x_components.  */\n-\n-      tree fn;\n       tree *q;\n \n       /* Wipe out memory of synthesized methods */\n@@ -10644,7 +10612,7 @@ finish_enum (enumtype, values)\n   else\n     maxnode = minnode = integer_zero_node;\n \n-  TYPE_VALUES (enumtype) = values;\n+  TYPE_VALUES (enumtype) = nreverse (values);\n \n   if (processing_template_decl)\n     return enumtype;\n@@ -12013,7 +11981,7 @@ finish_function (lineno, call_poplevel, nested)\n \t was an actual function definition.  */\n       DECL_INITIAL (fndecl) = error_mark_node;\n       for (t = DECL_ARGUMENTS (fndecl); t; t = TREE_CHAIN (t))\n-\tDECL_RTL (t) = NULL_RTX;\n+\tDECL_RTL (t) = DECL_INCOMING_RTL (t) = NULL_RTX;\n     }\n \n   if (DECL_STATIC_CONSTRUCTOR (fndecl))"}, {"sha": "31431e75adfbd910524d41de5f70340cc7b58070", "filename": "gcc/cp/error.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=de22184bb226fedca7b991f096b8d8befb9aba6f", "patch": "@@ -1323,12 +1323,19 @@ dump_expr (t, nop)\n       }\n \n     case TEMPLATE_CONST_PARM:\n-      {\n-\ttree r = TREE_VEC_ELT (TREE_VALUE (current_template_parms),\n-\t\t\t       TEMPLATE_CONST_IDX (t));\n-\tdump_decl (TREE_VALUE (r), -1);\n-\tbreak;\n-      }\n+      if (current_template_parms)\n+\t{\n+\t  tree r = TREE_VEC_ELT (TREE_VALUE (current_template_parms),\n+\t\t\t\t TEMPLATE_CONST_IDX (t));\n+\t  dump_decl (TREE_VALUE (r), -1);\n+\t}\n+      else\n+\t{\n+\t  OB_PUTS (\"<tparm \");\n+\t  OB_PUTI (TEMPLATE_CONST_IDX (t));\n+\t  OB_PUTS (\">\");\n+\t}\n+      break;\n \n     case IDENTIFIER_NODE:\n       OB_PUTID (t);"}, {"sha": "118db30930d405cee8e4e74c9535868c389e0362", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=de22184bb226fedca7b991f096b8d8befb9aba6f", "patch": "@@ -39,11 +39,10 @@ cplus_expand_expr (exp, target, tmode, modifier)\n   tree type = TREE_TYPE (exp);\n   register enum machine_mode mode = TYPE_MODE (type);\n   register enum tree_code code = TREE_CODE (exp);\n-  rtx original_target = target;\n   int ignore = target == const0_rtx;\n \n   if (ignore)\n-    target = 0, original_target = 0;\n+    target = 0;\n \n   /* No sense saving up arithmetic to be done\n      if it's all in the wrong mode to form part of an address."}, {"sha": "7f43d8d96bb26026e4a434a3d67ae60403ebac5d", "filename": "gcc/cp/init.c", "status": "modified", "additions": 35, "deletions": 23, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=de22184bb226fedca7b991f096b8d8befb9aba6f", "patch": "@@ -235,12 +235,20 @@ perform_member_init (member, name, init, explicit)\n \n   if (TYPE_NEEDS_DESTRUCTOR (type))\n     {\n-      tree expr = build_component_ref (current_class_ref, name, NULL_TREE, explicit);\n+      tree expr;\n+\n+      /* All cleanups must be on the function_obstack.  */\n+      push_obstacks_nochange ();\n+      resume_temporary_allocation ();\n+\n+      expr = build_component_ref (current_class_ref, name, NULL_TREE, explicit);\n       expr = build_delete (type, expr, integer_zero_node,\n \t\t\t   LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR, 0);\n \n       if (expr != error_mark_node)\n \tadd_partial_entry (expr);\n+\n+      pop_obstacks ();\n     }\n }\n \n@@ -997,22 +1005,21 @@ expand_member_init (exp, name, init)\n \t\t}\n #endif\n \t    }\n-\t  else\n+\t  else if (basetype != type\n+\t\t   && ! current_template_parms\n+\t\t   && ! vec_binfo_member (basetype,\n+\t\t\t\t\t  TYPE_BINFO_BASETYPES (type))\n+\t\t   && ! binfo_member (basetype, CLASSTYPE_VBASECLASSES (type)))\n \t    {\n-\t      if (basetype != type\n-\t\t  && ! vec_binfo_member (basetype, TYPE_BINFO_BASETYPES (type))\n-\t\t  && ! binfo_member (basetype, CLASSTYPE_VBASECLASSES (type)))\n-\t\t{\n-\t\t  if (IDENTIFIER_CLASS_VALUE (name))\n-\t\t    goto try_member;\n-\t\t  if (TYPE_USES_VIRTUAL_BASECLASSES (type))\n-\t\t    cp_error (\"type `%T' is not an immediate or virtual basetype for `%T'\",\n-\t\t\t      basetype, type);\n-\t\t  else\n-\t\t    cp_error (\"type `%T' is not an immediate basetype for `%T'\",\n-\t\t\t      basetype, type);\n-\t\t  return;\n-\t\t}\n+\t      if (IDENTIFIER_CLASS_VALUE (name))\n+\t\tgoto try_member;\n+\t      if (TYPE_USES_VIRTUAL_BASECLASSES (type))\n+\t\tcp_error (\"type `%T' is not an immediate or virtual basetype for `%T'\",\n+\t\t\t  basetype, type);\n+\t      else\n+\t\tcp_error (\"type `%T' is not an immediate basetype for `%T'\",\n+\t\t\t  basetype, type);\n+\t      return;\n \t    }\n \n \t  if (purpose_member (basetype, current_base_init_list))\n@@ -2637,10 +2644,10 @@ build_new (placement, decl, init, use_global_new)\n {\n   tree type, true_type, size, rval;\n   tree nelts;\n-  tree alloc_expr, alloc_temp;\n+  tree alloc_expr;\n   int has_array = 0;\n   enum tree_code code = NEW_EXPR;\n-  int use_cookie;\n+  int use_cookie, nothrow, check_new;\n \n   tree pending_sizes = NULL_TREE;\n \n@@ -2841,6 +2848,14 @@ build_new (placement, decl, init, use_global_new)\n       return error_mark_node;\n     }\n \n+  nothrow = (placement\n+\t     && TREE_TYPE (placement)\n+\t     && IS_AGGR_TYPE (TREE_TYPE (placement))\n+\t     && (TYPE_IDENTIFIER (TREE_TYPE (placement))\n+\t\t == get_identifier (\"nothrow_t\")));\n+\n+  check_new = flag_check_new || nothrow;\n+\n #if 1\n   /* Get a little extra space to store a couple of things before the new'ed\n      array, if this isn't the default placement new.  */\n@@ -2853,10 +2868,7 @@ build_new (placement, decl, init, use_global_new)\n      array, if this is either non-placement new or new (nothrow).  */\n   \n   use_cookie = (has_array && TYPE_VEC_NEW_USES_COOKIE (true_type)\n-\t\t&& (! placement\n-\t\t    || (IS_AGGR_TYPE (TREE_TYPE (placement))\n-\t\t\t&& (TYPE_IDENTIFIER (TREE_TYPE (placement))\n-\t\t\t    == get_identifier (\"nothrow_t\")))));\n+\t\t&& (! placement || nothrow));\n #endif\n \n   if (use_cookie)\n@@ -2904,7 +2916,7 @@ build_new (placement, decl, init, use_global_new)\n       TREE_CALLS_NEW (rval) = 1;\n     }\n \n-  if (flag_check_new && rval)\n+  if (check_new && rval)\n     alloc_expr = rval = save_expr (rval);\n   else\n     alloc_expr = NULL_TREE;"}, {"sha": "233606e5e9d4500da9ed0afb0d9c66b4af6e7459", "filename": "gcc/cp/method.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=de22184bb226fedca7b991f096b8d8befb9aba6f", "patch": "@@ -530,7 +530,8 @@ build_overload_value (type, value)\n \t  sorry (\"template instantiation with pointer to method that is too complex\");\n \t  return;\n \t}\n-      if (TREE_CODE (value) == INTEGER_CST)\n+      if (TREE_CODE (value) == INTEGER_CST\n+\t  || TREE_CODE (value) == TEMPLATE_CONST_PARM)\n \t{\n \t  build_overload_int (value);\n \t  numeric_output_need_bar = 1;\n@@ -1465,7 +1466,7 @@ tree\n hack_identifier (value, name)\n      tree value, name;\n {\n-  tree type, context;\n+  tree type;\n \n   if (TREE_CODE (value) == ERROR_MARK)\n     {\n@@ -1981,7 +1982,7 @@ do_build_copy_constructor (fndecl)\n \t}\n       for (; fields; fields = TREE_CHAIN (fields))\n \t{\n-\t  tree name, init, t;\n+\t  tree init, t;\n \t  tree field = fields;\n \n \t  if (TREE_CODE (field) != FIELD_DECL)\n@@ -2114,7 +2115,6 @@ synthesize_method (fndecl)\n {\n   int nested = (current_function_decl != NULL_TREE);\n   tree context = hack_decl_function_context (fndecl);\n-  tree base = DECL_CLASS_CONTEXT (fndecl);\n \n   if (! context)\n     push_to_top_level ();"}, {"sha": "c34a6876b38ad91ad9b8c39eb6f99b160bee390a", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=de22184bb226fedca7b991f096b8d8befb9aba6f", "patch": "@@ -340,6 +340,12 @@ extdefs_opt:\n \t\t{ have_extern_spec = 0; }\n \t;\n \n+extension:\n+\tEXTENSION\n+\t\t{ $<itype>$ = pedantic;\n+\t\t  pedantic = 0; }\n+\t;\n+\n asm_keyword:\n \t  ASM_KEYWORD\n \t| GCC_ASM_KEYWORD\n@@ -384,6 +390,8 @@ extdef:\n \t\t{ do_toplevel_using_decl ($1); }\n \t| USING NAMESPACE any_id ';'\n \t\t{ do_using_directive ($3); }\n+\t| extension extdef\n+\t\t{ pedantic = $<itype>1; }\n \t;\n \n using_decl:\n@@ -1021,11 +1029,8 @@ unary_expr:\n \t  primary  %prec UNARY\n \t\t{ $$ = $1; }\n \t/* __extension__ turns off -pedantic for following primary.  */\n-\t| EXTENSION\n-\t\t{ $<itype>1 = pedantic;\n-\t\t  pedantic = 0; }\n-\t  cast_expr  \t  %prec UNARY\n-\t\t{ $$ = $3;\n+\t| extension cast_expr  \t  %prec UNARY\n+\t\t{ $$ = $2;\n \t\t  pedantic = $<itype>1; }\n \t| '*' cast_expr   %prec UNARY\n \t\t{ $$ = build_x_indirect_ref ($2, \"unary *\"); }\n@@ -1664,6 +1669,8 @@ decl:\n \t\t}\n \t| declmods ';'\n \t\t{ warning (\"empty declaration\"); }\n+\t| extension decl\n+\t\t{ pedantic = $<itype>1; }\n \t;\n \n /* Any kind of declarator (thus, all declarators allowed\n@@ -2625,6 +2632,9 @@ component_decl:\n \t\t{ $$ = finish_method ($$); }\n \t| ';'\n \t\t{ $$ = NULL_TREE; }\n+\t| extension component_decl\n+\t\t{ $$ = $2;\n+\t\t  pedantic = $<itype>1; }\n \t;\n \n component_decl_1:"}, {"sha": "3d627064a4cc1feb0cf69d6ff09f26e62c7fc1db", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 37, "deletions": 31, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=de22184bb226fedca7b991f096b8d8befb9aba6f", "patch": "@@ -674,7 +674,6 @@ lookup_template_class (d1, arglist, in_decl)\n   tree template, parmlist;\n   char *mangled_name;\n   tree id, t;\n-  tree code_type_node;\n \n   if (TREE_CODE (d1) == IDENTIFIER_NODE)\n     {\n@@ -1078,7 +1077,7 @@ instantiate_class_template (type)\n \t    }\n \t}\n       TYPE_BEING_DEFINED (type) = 1;\n-      return;\n+      return error_mark_node;\n     }\n   else if (t)\n     pattern = TREE_TYPE (t);\n@@ -1160,7 +1159,7 @@ instantiate_class_template (type)\n \ttree bases;\n \tint i;\n \tint len = TREE_VEC_LENGTH (pbases);\n-\tBINFO_BASETYPES (binfo) = bases = make_tree_vec (len);\n+\tbases = make_tree_vec (len);\n \tfor (i = 0; i < len; ++i)\n \t  {\n \t    tree elt;\n@@ -1175,6 +1174,9 @@ instantiate_class_template (type)\n \t      cp_error (\"base class `%T' of `%T' has incomplete type\",\n \t\t\tTREE_TYPE (elt), type);\n \t  }\n+\t/* Don't initialize this until the vector is filled out, or\n+\t   lookups will crash.  */\n+\tBINFO_BASETYPES (binfo) = bases;\n       }\n   }\n \n@@ -1812,10 +1814,14 @@ tsubst (t, args, nargs, in_decl)\n \t      {\n \t\ttree value = TYPE_MAIN_VARIANT (type_decays_to\n \t\t  (tsubst (TREE_VALUE (values), args, nargs, in_decl)));\n-\t\ttree purpose = tsubst_expr (TREE_PURPOSE (values),\n-\t\t\t\t\t    args, nargs, in_decl);\n+\t\t/* Don't instantiate default args unless they are used.\n+\t\t   Handle it in build_over_call instead.  */\n+\t\ttree purpose = TREE_PURPOSE (values);\n \t\ttree x = build_tree_list (purpose, value);\n \n+\t\tif (purpose)\n+\t\t  PARM_DEFAULT_FROM_TEMPLATE (x) = 1;\n+\n \t\tif (first)\n \t\t  TREE_CHAIN (last) = x;\n \t\telse\n@@ -2757,7 +2763,7 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts, strict)\n \t      default:\n \t\t;\n \t      }\n-\t  my_friendly_abort (87);\n+\t  /* else we get two different bindings, so deduction fails.  */\n \t  return 1;\n \t}\n /*\telse if (typeof arg != tparms[idx])\n@@ -3345,7 +3351,29 @@ instantiate_decl (d)\n \n   if (d_defined)\n     return d;\n-  else if (pattern_defined)\n+\n+  /* This needs to happen before any tsubsting.  */\n+  if (! push_tinst_level (d))\n+    return d;\n+\n+  push_to_top_level ();\n+  lineno = DECL_SOURCE_LINE (d);\n+  input_filename = DECL_SOURCE_FILE (d);\n+\n+  /* We need to set up DECL_INITIAL regardless of pattern_defined if the\n+     variable is a static const initialized in the class body.  */\n+  if (TREE_CODE (d) == VAR_DECL\n+      && ! DECL_INITIAL (d) && DECL_INITIAL (pattern))\n+    {\n+      pushclass (DECL_CONTEXT (d), 2);\n+      DECL_INITIAL (d) = tsubst_expr\n+\t(DECL_INITIAL (pattern), &TREE_VEC_ELT (args, 0),\n+\t TREE_VEC_LENGTH (args), tmpl);\n+      popclass (1);\n+    }\n+\n+  /* import_export_decl has to happen after DECL_INITIAL is set up.  */\n+  if (pattern_defined)\n     {\n       repo_template_used (d);\n \n@@ -3369,24 +3397,6 @@ instantiate_decl (d)\n \timport_export_decl (d);\n     }\n \n-  /* We need to set up DECL_INITIAL regardless of pattern_defined if the\n-     variable is a static const initialized in the class body.  */\n-  if (TREE_CODE (d) == VAR_DECL\n-      && ! DECL_INITIAL (d) && DECL_INITIAL (pattern))\n-    {\n-      lineno = DECL_SOURCE_LINE (d);\n-      input_filename = DECL_SOURCE_FILE (d);\n-\n-      pushclass (DECL_CONTEXT (d), 2);\n-      DECL_INITIAL (d) = tsubst_expr\n-\t(DECL_INITIAL (pattern), &TREE_VEC_ELT (args, 0),\n-\t TREE_VEC_LENGTH (args), tmpl);\n-      popclass (1);\n-\n-      lineno = line;\n-      input_filename = file;\n-    }\n-\n   if (! pattern_defined\n       || (TREE_CODE (d) == FUNCTION_DECL && ! DECL_INLINE (d)\n \t  && (! DECL_INTERFACE_KNOWN (d)\n@@ -3398,14 +3408,9 @@ instantiate_decl (d)\n       || (TREE_CODE (d) == FUNCTION_DECL && ! nested && ! at_eof))\n     {\n       add_pending_template (d);\n-      return d;\n+      goto out;\n     }\n \n-  if (! push_tinst_level (d))\n-    return d;\n-\n-  push_to_top_level ();\n-\n   lineno = DECL_SOURCE_LINE (d);\n   input_filename = DECL_SOURCE_FILE (d);\n \n@@ -3482,6 +3487,7 @@ instantiate_decl (d)\n       finish_function (lineno, 0, nested);\n     }\n \n+out:\n   lineno = line;\n   input_filename = file;\n "}, {"sha": "d9bc3c518a83a277e93d9e30e2e3fab33823590c", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=de22184bb226fedca7b991f096b8d8befb9aba6f", "patch": "@@ -81,7 +81,7 @@ build_headof (exp)\n {\n   tree type = TREE_TYPE (exp);\n   tree aref;\n-  tree vptr, offset;\n+  tree offset;\n \n   if (TREE_CODE (type) != POINTER_TYPE)\n     {\n@@ -373,8 +373,6 @@ tree\n get_typeid (type)\n      tree type;\n {\n-  tree t;\n-\n   if (type == error_mark_node)\n     return error_mark_node;\n   "}, {"sha": "ec7a52bfa22aefe00a3785b96a18a0f776c8f0ae", "filename": "gcc/cp/search.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=de22184bb226fedca7b991f096b8d8befb9aba6f", "patch": "@@ -1,6 +1,6 @@\n /* Breadth-first and depth-first routines for\n    searching multiple-inheritance lattice for GNU C++.\n-   Copyright (C) 1987, 89, 92, 93, 94, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 89, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -1131,6 +1131,15 @@ lookup_field (xbasetype, name, protect, want_type)\n     name = constructor_name (name);\n #endif\n \n+  if (xbasetype == current_class_type && TYPE_BEING_DEFINED (xbasetype)\n+      && IDENTIFIER_CLASS_VALUE (name))\n+    {\n+      tree field = IDENTIFIER_CLASS_VALUE (name);\n+      if (TREE_CODE (field) != FUNCTION_DECL\n+\t  && ! (want_type && TREE_CODE (field) != TYPE_DECL))\n+\treturn field;\n+    }\n+\n   if (TREE_CODE (xbasetype) == TREE_VEC)\n     {\n       type = BINFO_TYPE (xbasetype);\n@@ -2784,7 +2793,7 @@ expand_upcast_fixups (binfo, addr, orig_addr, vbase, vbase_addr, t,\n \t  && (vc=virtual_context (current_fndecl, t, vbase)) != vbase)\n \t{\n \t  /* This may in fact need a runtime fixup.  */\n-\t  tree idx = DECL_VINDEX (current_fndecl);\n+\t  tree idx = build_int_2 (n, 0);\n \t  tree vtbl = BINFO_VTABLE (binfo);\n \t  tree nvtbl = lookup_name (DECL_NAME (vtbl), 0);\n \t  tree aref, ref, naref;"}, {"sha": "d43ff81a38942f82179b3cc0ef55c0e1ad5acff6", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=de22184bb226fedca7b991f096b8d8befb9aba6f", "patch": "@@ -4734,7 +4734,6 @@ build_conditional_expr (ifexp, op1, op2)\n   register enum tree_code code1;\n   register enum tree_code code2;\n   register tree result_type = NULL_TREE;\n-  tree orig_op1 = op1, orig_op2 = op2;\n \n   /* If second operand is omitted, it is the same as the first one;\n      make sure it is calculated only once.  */\n@@ -6236,12 +6235,11 @@ build_ptrmemfunc (type, pfn, force)\n   tree delta2 = integer_zero_node;\n   tree vfield_offset;\n   tree npfn = NULL_TREE;\n-  tree u;\n \n   /* Handle multiple conversions of pointer to member functions.  */\n   if (TYPE_PTRMEMFUNC_P (TREE_TYPE (pfn)))\n     {\n-      tree ndelta, ndelta2, nindex;\n+      tree ndelta, ndelta2;\n       tree e1, e2, e3, n;\n \n       /* Is is already the right type? */"}, {"sha": "d499846c5a4ed08fb2639b5f117ddb2682cdbb1a", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de22184bb226fedca7b991f096b8d8befb9aba6f/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=de22184bb226fedca7b991f096b8d8befb9aba6f", "patch": "@@ -1390,8 +1390,6 @@ build_functional_cast (exp, parms)\n      tree exp;\n      tree parms;\n {\n-  tree binfo;\n-\n   /* This is either a call to a constructor,\n      or a C cast in C++'s `functional' notation.  */\n   tree type;"}]}