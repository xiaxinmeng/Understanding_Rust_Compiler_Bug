{"sha": "dc2a24eddf28bf75a8869168202fa19a856af055", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMyYTI0ZWRkZjI4YmY3NWE4ODY5MTY4MjAyZmExOWE4NTZhZjA1NQ==", "commit": {"author": {"name": "David S. Miller", "email": "davem@davemloft.net", "date": "2015-09-22T03:52:45Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "2015-09-22T03:52:45Z"}, "message": "Revert LRA SPARC changes for now.\n\ngcc/\n\n\tPR/67622\n\tRevert:\n\t2015-09-11  David S. Miller  <davem@davemloft.net>\n\n\t\t* config/sparc/constraints.md: Make \"U\" constraint a real register\n\t\tconstraint.\n\t\t* config/sparc/sparc.c (TARGET_LRA_P): Define.\n\t\t(D_MODES, DF_MODES): Add missing cast.\n\t\t(TF_MODES, TF_MODES_NO_S): Include T_MODE.\n\t\t(OF_MODES, OF_MODES_NO_S): Include O_MODE.\n\t\t(sparc_register_move_cost): Decrease Niagara/UltrsSPARC memory\n\t\tcost to 8.\n\t\t* config/sparc/sparc.h (PROMOTE_MODE): Define.\n\t\t* config/sparc/sparc.md (*movsi_lo_sum, *movsi_high): Do not\n\t\tprovide these insn when flag_pic.\n\n\t2015-09-17  David S. Miller  <davem@davemloft.net>\n\n\t\t* config/sparc/sparc-protos.h (sparc_secondary_memory_needed):\n\t\tDeclare.\n\t\t* config/sparc/sparc.c (sparc_secondary_memory_needed): New\n\t\tfunction.\n\t\t* config/sparc/sparc.h (SECONDARY_MEMORY_NEEDED): Use it.\n\t\t(HARD_REGNO_CALLER_SAVE_MODE): Define.\n\t\t* config/sparc/sparc.md (sethi_di_medlow, losum_di_medlow, seth44)\n\t\t(setm44, setl44, sethh, setlm, sethm, setlo, embmedany_sethi)\n\t\t(embmedany_losum, embmedany_brsum, embmedany_textuhi)\n\t\t(embmedany_texthi, embmedany_textulo, embmedany_textlo): Do not\n\t\tprovide when flag_pic.\n\nFrom-SVN: r227993", "tree": {"sha": "f7382ab512b78f3f74daf0367e98f6f77b2852c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7382ab512b78f3f74daf0367e98f6f77b2852c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc2a24eddf28bf75a8869168202fa19a856af055", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc2a24eddf28bf75a8869168202fa19a856af055", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc2a24eddf28bf75a8869168202fa19a856af055", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc2a24eddf28bf75a8869168202fa19a856af055/comments", "author": {"login": "davem330", "id": 1053866, "node_id": "MDQ6VXNlcjEwNTM4NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1053866?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davem330", "html_url": "https://github.com/davem330", "followers_url": "https://api.github.com/users/davem330/followers", "following_url": "https://api.github.com/users/davem330/following{/other_user}", "gists_url": "https://api.github.com/users/davem330/gists{/gist_id}", "starred_url": "https://api.github.com/users/davem330/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davem330/subscriptions", "organizations_url": "https://api.github.com/users/davem330/orgs", "repos_url": "https://api.github.com/users/davem330/repos", "events_url": "https://api.github.com/users/davem330/events{/privacy}", "received_events_url": "https://api.github.com/users/davem330/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "36d0586f56dfa8dd94ce31db587f7ac0188e5a55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36d0586f56dfa8dd94ce31db587f7ac0188e5a55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36d0586f56dfa8dd94ce31db587f7ac0188e5a55"}], "stats": {"total": 181, "additions": 107, "deletions": 74}, "files": [{"sha": "8ffb990dd28ac9badf166fcd0ee1c405ec477de5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc2a24eddf28bf75a8869168202fa19a856af055/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc2a24eddf28bf75a8869168202fa19a856af055/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc2a24eddf28bf75a8869168202fa19a856af055", "patch": "@@ -1,3 +1,35 @@\n+2015-09-21  David S. Miller  <davem@davemloft.net>\n+\n+\tPR/67622\n+\tRevert:\n+\t2015-09-11  David S. Miller  <davem@davemloft.net>\n+\n+\t\t* config/sparc/constraints.md: Make \"U\" constraint a real register\n+\t\tconstraint.\n+\t\t* config/sparc/sparc.c (TARGET_LRA_P): Define.\n+\t\t(D_MODES, DF_MODES): Add missing cast.\n+\t\t(TF_MODES, TF_MODES_NO_S): Include T_MODE.\n+\t\t(OF_MODES, OF_MODES_NO_S): Include O_MODE.\n+\t\t(sparc_register_move_cost): Decrease Niagara/UltrsSPARC memory\n+\t\tcost to 8.\n+\t\t* config/sparc/sparc.h (PROMOTE_MODE): Define.\n+\t\t* config/sparc/sparc.md (*movsi_lo_sum, *movsi_high): Do not\n+\t\tprovide these insn when flag_pic.\n+\n+\t2015-09-17  David S. Miller  <davem@davemloft.net>\n+\n+\t\t* config/sparc/sparc-protos.h (sparc_secondary_memory_needed):\n+\t\tDeclare.\n+\t\t* config/sparc/sparc.c (sparc_secondary_memory_needed): New\n+\t\tfunction.\n+\t\t* config/sparc/sparc.h (SECONDARY_MEMORY_NEEDED): Use it.\n+\t\t(HARD_REGNO_CALLER_SAVE_MODE): Define.\n+\t\t* config/sparc/sparc.md (sethi_di_medlow, losum_di_medlow, seth44)\n+\t\t(setm44, setl44, sethh, setlm, sethm, setlo, embmedany_sethi)\n+\t\t(embmedany_losum, embmedany_brsum, embmedany_textuhi)\n+\t\t(embmedany_texthi, embmedany_textulo, embmedany_textlo): Do not\n+\t\tprovide when flag_pic.\n+\n 2015-09-21  Jeff Law  <law@redhat.com>\n \n \t* config/h8300/h8300.md (andsi3_ashift_n_lower): Avoid undefined"}, {"sha": "e12efa12fdf0c0b484196aab6087795adba31f63", "filename": "gcc/config/sparc/constraints.md", "status": "modified", "additions": 45, "deletions": 2, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc2a24eddf28bf75a8869168202fa19a856af055/gcc%2Fconfig%2Fsparc%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc2a24eddf28bf75a8869168202fa19a856af055/gcc%2Fconfig%2Fsparc%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fconstraints.md?ref=dc2a24eddf28bf75a8869168202fa19a856af055", "patch": "@@ -44,8 +44,6 @@\n (define_register_constraint \"h\" \"(TARGET_V9 && TARGET_V8PLUS ? I64_REGS : NO_REGS)\"\n  \"64-bit global or out register in V8+ mode\")\n \n-(define_register_constraint \"U\" \"(TARGET_ARCH32 ? GENERAL_REGS : NO_REGS)\")\n-\n ;; Floating-point constant constraints\n \n (define_constraint \"G\"\n@@ -137,6 +135,51 @@\n       (match_code \"mem\")\n       (match_test \"memory_ok_for_ldd (op)\")))\n \n+;; This awkward register constraint is necessary because it is not\n+;; possible to express the \"must be even numbered register\" condition\n+;; using register classes.  The problem is that membership in a\n+;; register class requires that all registers of a multi-regno\n+;; register be included in the set.  It is add_to_hard_reg_set\n+;; and in_hard_reg_set_p which populate and test regsets with these\n+;; semantics.\n+;;\n+;; So this means that we would have to put both the even and odd\n+;; register into the register class, which would not restrict things\n+;; at all.\n+;;\n+;; Using a combination of GENERAL_REGS and HARD_REGNO_MODE_OK is not a\n+;; full solution either.  In fact, even though IRA uses the macro\n+;; HARD_REGNO_MODE_OK to calculate which registers are prohibited from\n+;; use in certain modes, it still can allocate an odd hard register\n+;; for DImode values.  This is due to how IRA populates the table\n+;; ira_useful_class_mode_regs[][].  It suffers from the same problem\n+;; as using a register class to describe this restriction.  Namely, it\n+;; sets both the odd and even part of an even register pair in the\n+;; regset.  Therefore IRA can and will allocate odd registers for\n+;; DImode values on 32-bit.\n+;;\n+;; There are legitimate cases where DImode values can end up in odd\n+;; hard registers, the most notable example is argument passing.\n+;;\n+;; What saves us is reload and the DImode splitters.  Both are\n+;; necessary.  The odd register splitters cannot match if, for\n+;; example, we have a non-offsetable MEM.  Reload will notice this\n+;; case and reload the address into a single hard register.\n+;;\n+;; The real downfall of this awkward register constraint is that it does\n+;; not evaluate to a true register class like a bonafide use of\n+;; define_register_constraint would.  This currently means that we cannot\n+;; use LRA on Sparc, since the constraint processing of LRA really depends\n+;; upon whether an extra constraint is for registers or not.  It uses\n+;; reg_class_for_constraint, and checks it against NO_REGS.\n+(define_constraint \"U\"\n+ \"Pseudo-register or hard even-numbered integer register\"\n+ (and (match_test \"TARGET_ARCH32\")\n+      (match_code \"reg\")\n+      (ior (match_test \"REGNO (op) < FIRST_PSEUDO_REGISTER\")\n+\t   (not (match_test \"reload_in_progress && reg_renumber [REGNO (op)] < 0\")))\n+      (match_test \"register_ok_for_ldd (op)\")))\n+\n ;; Equivalent to 'T' but available in 64-bit mode\n (define_memory_constraint \"W\"\n  \"Memory reference for 'e' constraint floating-point register\""}, {"sha": "143143709d1c3a6368c85a65c43ec9e9d7bad978", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc2a24eddf28bf75a8869168202fa19a856af055/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc2a24eddf28bf75a8869168202fa19a856af055/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=dc2a24eddf28bf75a8869168202fa19a856af055", "patch": "@@ -62,8 +62,6 @@ extern bool constant_address_p (rtx);\n extern bool legitimate_pic_operand_p (rtx);\n extern rtx sparc_legitimize_reload_address (rtx, machine_mode, int, int,\n \t\t\t\t\t    int, int *win);\n-extern bool sparc_secondary_memory_needed (enum reg_class, enum reg_class,\n-\t\t\t\t\t   machine_mode);\n extern void load_got_register (void);\n extern void sparc_emit_call_insn (rtx, rtx);\n extern void sparc_defer_case_vector (rtx, rtx, int);"}, {"sha": "ed8a1665e6a296e37a95dae986073dfb8f976b41", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 7, "deletions": 32, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc2a24eddf28bf75a8869168202fa19a856af055/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc2a24eddf28bf75a8869168202fa19a856af055/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=dc2a24eddf28bf75a8869168202fa19a856af055", "patch": "@@ -808,9 +808,6 @@ char sparc_hard_reg_printed[8];\n #undef TARGET_CAN_ELIMINATE\n #define TARGET_CAN_ELIMINATE sparc_can_eliminate\n \n-#undef TARGET_LRA_P\n-#define TARGET_LRA_P hook_bool_void_true\n-\n #undef  TARGET_PREFERRED_RELOAD_CLASS\n #define TARGET_PREFERRED_RELOAD_CLASS sparc_preferred_reload_class\n \n@@ -4694,7 +4691,7 @@ enum sparc_mode_class {\n   ((1 << (int) H_MODE) | (1 << (int) S_MODE) | (1 << (int) SF_MODE))\n \n /* Modes for double-word and smaller quantities.  */\n-#define D_MODES (S_MODES | (1 << (int) D_MODE) | (1 << (int) DF_MODE))\n+#define D_MODES (S_MODES | (1 << (int) D_MODE) | (1 << DF_MODE))\n \n /* Modes for quad-word and smaller quantities.  */\n #define T_MODES (D_MODES | (1 << (int) T_MODE) | (1 << (int) TF_MODE))\n@@ -4706,24 +4703,22 @@ enum sparc_mode_class {\n #define SF_MODES ((1 << (int) S_MODE) | (1 << (int) SF_MODE))\n \n /* Modes for double-float and smaller quantities.  */\n-#define DF_MODES (SF_MODES | (1 << (int) D_MODE) | (1 << (int) DF_MODE))\n+#define DF_MODES (SF_MODES | (1 << (int) D_MODE) | (1 << DF_MODE))\n \n /* Modes for quad-float and smaller quantities.  */\n-#define TF_MODES (DF_MODES | (1 << (int) T_MODE) | (1 << (int) TF_MODE))\n+#define TF_MODES (DF_MODES | (1 << (int) TF_MODE))\n \n /* Modes for quad-float pairs and smaller quantities.  */\n-#define OF_MODES (TF_MODES | (1 << (int) O_MODE) | (1 << (int) OF_MODE))\n+#define OF_MODES (TF_MODES | (1 << (int) OF_MODE))\n \n /* Modes for double-float only quantities.  */\n #define DF_MODES_NO_S ((1 << (int) D_MODE) | (1 << (int) DF_MODE))\n \n /* Modes for quad-float and double-float only quantities.  */\n-#define TF_MODES_NO_S \\\n-  (DF_MODES_NO_S | (1 << (int) T_MODE) | (1 << (int) TF_MODE))\n+#define TF_MODES_NO_S (DF_MODES_NO_S | (1 << (int) TF_MODE))\n \n /* Modes for quad-float pairs and double-float only quantities.  */\n-#define OF_MODES_NO_S \\\n-  (TF_MODES_NO_S | (1 << (int) O_MODE) | (1 << (int) OF_MODE))\n+#define OF_MODES_NO_S (TF_MODES_NO_S | (1 << (int) OF_MODE))\n \n /* Modes for condition codes.  */\n #define CC_MODES (1 << (int) CC_MODE)\n@@ -11193,7 +11188,7 @@ sparc_register_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n \t  || sparc_cpu == PROCESSOR_NIAGARA2\n \t  || sparc_cpu == PROCESSOR_NIAGARA3\n \t  || sparc_cpu == PROCESSOR_NIAGARA4)\n-\treturn 8;\n+\treturn 12;\n \n       return 6;\n     }\n@@ -12283,26 +12278,6 @@ sparc_expand_vector_init (rtx target, rtx vals)\n   emit_move_insn (target, mem);\n }\n \n-bool sparc_secondary_memory_needed (enum reg_class class1, enum reg_class class2,\n-\t\t\t\t    machine_mode mode)\n-{\n-  if (FP_REG_CLASS_P (class1) != FP_REG_CLASS_P (class2))\n-    {\n-      if (! TARGET_VIS3\n-\t  || GET_MODE_SIZE (mode) > 8\n-\t  || GET_MODE_SIZE (mode) < 4)\n-\treturn true;\n-      return false;\n-    }\n-\n-  if (GET_MODE_SIZE (mode) == 4\n-      && ((class1 == FP_REGS && class2 == EXTRA_FP_REGS)\n-\t  || (class1 == EXTRA_FP_REGS && class2 == FP_REGS)))\n-    return true;\n-\n-  return false;\n-}\n-\n /* Implement TARGET_SECONDARY_RELOAD.  */\n \n static reg_class_t"}, {"sha": "2cbe0d9b7fa2d7f5370bca44aae0f2a346f644ff", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc2a24eddf28bf75a8869168202fa19a856af055/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc2a24eddf28bf75a8869168202fa19a856af055/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=dc2a24eddf28bf75a8869168202fa19a856af055", "patch": "@@ -452,17 +452,6 @@ extern enum cmodel sparc_cmodel;\n \f\n /* target machine storage layout */\n \n-/* Define this macro if it is advisable to hold scalars in registers\n-   in a wider mode than that declared by the program.  In such cases,\n-   the value is constrained to be within the bounds of the declared\n-   type, but kept valid in the wider mode.  The signedness of the\n-   extension may differ from that of the type.  */\n-\n-#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)\t\\\n-  if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n-      && GET_MODE_SIZE (MODE) < (TARGET_ARCH64 ? 8 : 4)) \\\n-    (MODE) = TARGET_ARCH64 ? DImode : SImode;\n-\n /* Define this if most significant bit is lowest numbered\n    in instructions that operate on numbered bit-fields.  */\n #define BITS_BIG_ENDIAN 1\n@@ -747,12 +736,6 @@ extern int sparc_mode_class[];\n    register window instruction in the prologue.  */\n #define HARD_REGNO_RENAME_OK(FROM, TO) ((FROM) != 1)\n \n-/* Select a register mode required for caller save of hard regno REGNO.  */\n-#define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS, MODE) \\\n-    (((MODE) == VOIDmode) ? \\\n-     choose_hard_reg_mode ((REGNO), (NREGS), false) : \\\n-     (MODE))\n-\n #define MODES_TIEABLE_P(MODE1, MODE2) sparc_modes_tieable_p (MODE1, MODE2)\n \n /* Specify the registers used for certain standard purposes.\n@@ -1050,10 +1033,12 @@ extern char leaf_reg_remap[];\n   (SPARC_SETHI_P ((unsigned HOST_WIDE_INT) (X) & GET_MODE_MASK (SImode)))\n \n /* On SPARC when not VIS3 it is not possible to directly move data\n-   between GENERAL_REGS and FP_REGS.  We also cannot move 4-byte values\n-   between FP_REGS and EXTRA_FP_REGS.  */\n+   between GENERAL_REGS and FP_REGS.  */\n #define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE) \\\n-  sparc_secondary_memory_needed (CLASS1, CLASS2, MODE)\n+  ((FP_REG_CLASS_P (CLASS1) != FP_REG_CLASS_P (CLASS2)) \\\n+   && (! TARGET_VIS3 \\\n+       || GET_MODE_SIZE (MODE) > 8 \\\n+       || GET_MODE_SIZE (MODE) < 4))\n \n /* Get_secondary_mem widens its argument to BITS_PER_WORD which loses on v9\n    because the movsi and movsf patterns don't handle r/f moves."}, {"sha": "5b9f0517b90831490d3a8473cf1331bb5d061c6f", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc2a24eddf28bf75a8869168202fa19a856af055/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc2a24eddf28bf75a8869168202fa19a856af055/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=dc2a24eddf28bf75a8869168202fa19a856af055", "patch": "@@ -1467,13 +1467,13 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n                    (match_operand:SI 2 \"immediate_operand\" \"in\")))]\n-  \"! flag_pic\"\n+  \"\"\n   \"or\\t%1, %%lo(%a2), %0\")\n \n (define_insn \"*movsi_high\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(high:SI (match_operand:SI 1 \"immediate_operand\" \"in\")))]\n-  \"! flag_pic\"\n+  \"\"\n   \"sethi\\t%%hi(%a1), %0\")\n \n ;; The next two patterns must wrap the SYMBOL_REF in an UNSPEC\n@@ -1745,105 +1745,105 @@\n (define_insn \"*sethi_di_medlow\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (high:DI (match_operand:DI 1 \"symbolic_operand\" \"\")))]\n-  \"TARGET_CM_MEDLOW && !flag_pic\"\n+  \"TARGET_CM_MEDLOW && check_pic (1)\"\n   \"sethi\\t%%hi(%a1), %0\")\n \n (define_insn \"*losum_di_medlow\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n                    (match_operand:DI 2 \"symbolic_operand\" \"\")))]\n-  \"TARGET_CM_MEDLOW && !flag_pic\"\n+  \"TARGET_CM_MEDLOW\"\n   \"or\\t%1, %%lo(%a2), %0\")\n \n (define_insn \"seth44\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (high:DI (unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")] UNSPEC_SETH44)))]\n-  \"TARGET_CM_MEDMID && !flag_pic\"\n+  \"TARGET_CM_MEDMID\"\n   \"sethi\\t%%h44(%a1), %0\")\n \n (define_insn \"setm44\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n                    (unspec:DI [(match_operand:DI 2 \"symbolic_operand\" \"\")] UNSPEC_SETM44)))]\n-  \"TARGET_CM_MEDMID && !flag_pic\"\n+  \"TARGET_CM_MEDMID\"\n   \"or\\t%1, %%m44(%a2), %0\")\n \n (define_insn \"setl44\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n                    (match_operand:DI 2 \"symbolic_operand\" \"\")))]\n-  \"TARGET_CM_MEDMID && !flag_pic\"\n+  \"TARGET_CM_MEDMID\"\n   \"or\\t%1, %%l44(%a2), %0\")\n \n (define_insn \"sethh\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (high:DI (unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")] UNSPEC_SETHH)))]\n-  \"TARGET_CM_MEDANY && !flag_pic\"\n+  \"TARGET_CM_MEDANY\"\n   \"sethi\\t%%hh(%a1), %0\")\n \n (define_insn \"setlm\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (high:DI (unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")] UNSPEC_SETLM)))]\n-  \"TARGET_CM_MEDANY && !flag_pic\"\n+  \"TARGET_CM_MEDANY\"\n   \"sethi\\t%%lm(%a1), %0\")\n \n (define_insn \"sethm\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n                    (unspec:DI [(match_operand:DI 2 \"symbolic_operand\" \"\")] UNSPEC_EMB_SETHM)))]\n-  \"TARGET_CM_MEDANY && !flag_pic\"\n+  \"TARGET_CM_MEDANY\"\n   \"or\\t%1, %%hm(%a2), %0\")\n \n (define_insn \"setlo\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n                    (match_operand:DI 2 \"symbolic_operand\" \"\")))]\n-  \"TARGET_CM_MEDANY && !flag_pic\"\n+  \"TARGET_CM_MEDANY\"\n   \"or\\t%1, %%lo(%a2), %0\")\n \n (define_insn \"embmedany_sethi\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (high:DI (unspec:DI [(match_operand:DI 1 \"data_segment_operand\" \"\")] UNSPEC_EMB_HISUM)))]\n-  \"TARGET_CM_EMBMEDANY && !flag_pic\"\n+  \"TARGET_CM_EMBMEDANY && check_pic (1)\"\n   \"sethi\\t%%hi(%a1), %0\")\n \n (define_insn \"embmedany_losum\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n                    (match_operand:DI 2 \"data_segment_operand\" \"\")))]\n-  \"TARGET_CM_EMBMEDANY && !flag_pic\"\n+  \"TARGET_CM_EMBMEDANY\"\n   \"add\\t%1, %%lo(%a2), %0\")\n \n (define_insn \"embmedany_brsum\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (unspec:DI [(match_operand:DI 1 \"register_operand\" \"r\")] UNSPEC_EMB_HISUM))]\n-  \"TARGET_CM_EMBMEDANY && !flag_pic\"\n+  \"TARGET_CM_EMBMEDANY\"\n   \"add\\t%1, %_, %0\")\n \n (define_insn \"embmedany_textuhi\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (high:DI (unspec:DI [(match_operand:DI 1 \"text_segment_operand\" \"\")] UNSPEC_EMB_TEXTUHI)))]\n-  \"TARGET_CM_EMBMEDANY && !flag_pic\"\n+  \"TARGET_CM_EMBMEDANY && check_pic (1)\"\n   \"sethi\\t%%uhi(%a1), %0\")\n \n (define_insn \"embmedany_texthi\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (high:DI (unspec:DI [(match_operand:DI 1 \"text_segment_operand\" \"\")] UNSPEC_EMB_TEXTHI)))]\n-  \"TARGET_CM_EMBMEDANY && !flag_pic\"\n+  \"TARGET_CM_EMBMEDANY && check_pic (1)\"\n   \"sethi\\t%%hi(%a1), %0\")\n \n (define_insn \"embmedany_textulo\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n                    (unspec:DI [(match_operand:DI 2 \"text_segment_operand\" \"\")] UNSPEC_EMB_TEXTULO)))]\n-  \"TARGET_CM_EMBMEDANY && !flag_pic\"\n+  \"TARGET_CM_EMBMEDANY\"\n   \"or\\t%1, %%ulo(%a2), %0\")\n \n (define_insn \"embmedany_textlo\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n                    (match_operand:DI 2 \"text_segment_operand\" \"\")))]\n-  \"TARGET_CM_EMBMEDANY && !flag_pic\"\n+  \"TARGET_CM_EMBMEDANY\"\n   \"or\\t%1, %%lo(%a2), %0\")\n \n ;; Now some patterns to help reload out a bit."}]}