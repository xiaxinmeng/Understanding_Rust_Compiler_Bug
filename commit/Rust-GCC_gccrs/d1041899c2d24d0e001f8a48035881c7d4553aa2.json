{"sha": "d1041899c2d24d0e001f8a48035881c7d4553aa2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDEwNDE4OTljMmQyNGQwZTAwMWY4YTQ4MDM1ODgxYzdkNDU1M2FhMg==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2019-08-29T18:15:13Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2019-08-29T18:15:13Z"}, "message": "i386.c (inline_secondary_memory_needed): Return true for moves between SSE and non-general registers and between mask...\n\n\t* config/i386/i386.c (inline_secondary_memory_needed): Return true\n\tfor moves between SSE and non-general registers and between\n\tmask and non-general registers.\n\t(ix86_register_move_cost): Remove stalled comment.\n\nFrom-SVN: r275050", "tree": {"sha": "3c52a7f6603f5e15415e2c5853065a55dab040db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c52a7f6603f5e15415e2c5853065a55dab040db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1041899c2d24d0e001f8a48035881c7d4553aa2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1041899c2d24d0e001f8a48035881c7d4553aa2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1041899c2d24d0e001f8a48035881c7d4553aa2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1041899c2d24d0e001f8a48035881c7d4553aa2/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ce189a6254e0fdcdf81d6131010b177104cb654e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce189a6254e0fdcdf81d6131010b177104cb654e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce189a6254e0fdcdf81d6131010b177104cb654e"}], "stats": {"total": 37, "additions": 20, "deletions": 17}, "files": [{"sha": "f73e8be7df2ae6572369cd237322dc6d5dedd692", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1041899c2d24d0e001f8a48035881c7d4553aa2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1041899c2d24d0e001f8a48035881c7d4553aa2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d1041899c2d24d0e001f8a48035881c7d4553aa2", "patch": "@@ -1,3 +1,10 @@\n+2019-08-29  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.c (inline_secondary_memory_needed): Return true\n+\tfor moves between SSE and non-general registers and between\n+\tmask and non-general registers.\n+\t(ix86_register_move_cost): Remove stalled comment.\n+\n 2019-08-29  Richard Biener  <rguenther@suse.de>\n \n \t* config/i386/i386-features.c (general_scalar_chain::convert_insn):"}, {"sha": "1c9c719f22a337e2debd87156431744685d5990c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1041899c2d24d0e001f8a48035881c7d4553aa2/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1041899c2d24d0e001f8a48035881c7d4553aa2/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d1041899c2d24d0e001f8a48035881c7d4553aa2", "patch": "@@ -18306,32 +18306,36 @@ inline_secondary_memory_needed (machine_mode mode, reg_class_t class1,\n   if (FLOAT_CLASS_P (class1) != FLOAT_CLASS_P (class2))\n     return true;\n \n-  /* Between mask and general, we have moves no larger than word size.  */\n-  if ((MASK_CLASS_P (class1) != MASK_CLASS_P (class2))\n-      && (GET_MODE_SIZE (mode) > UNITS_PER_WORD))\n-  return true;\n-\n   /* ??? This is a lie.  We do have moves between mmx/general, and for\n      mmx/sse2.  But by saying we need secondary memory we discourage the\n      register allocator from using the mmx registers unless needed.  */\n   if (MMX_CLASS_P (class1) != MMX_CLASS_P (class2))\n     return true;\n \n+  /* Between mask and general, we have moves no larger than word size.  */\n+  if (MASK_CLASS_P (class1) != MASK_CLASS_P (class2))\n+    {\n+      if (!(INTEGER_CLASS_P (class1) || INTEGER_CLASS_P (class2))\n+\t  || GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n+\treturn true;\n+    }\n+\n   if (SSE_CLASS_P (class1) != SSE_CLASS_P (class2))\n     {\n       /* SSE1 doesn't have any direct moves from other classes.  */\n       if (!TARGET_SSE2)\n \treturn true;\n \n+      /* Between SSE and general, we have moves no larger than word size.  */\n+      if (!(INTEGER_CLASS_P (class1) || INTEGER_CLASS_P (class2))\n+\t  || GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n+\treturn true;\n+\n       /* If the target says that inter-unit moves are more expensive\n \t than moving through memory, then don't generate them.  */\n       if ((SSE_CLASS_P (class1) && !TARGET_INTER_UNIT_MOVES_FROM_VEC)\n \t  || (SSE_CLASS_P (class2) && !TARGET_INTER_UNIT_MOVES_TO_VEC))\n \treturn true;\n-\n-      /* Between SSE and general, we have moves no larger than word size.  */\n-      if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n-\treturn true;\n     }\n \n   return false;\n@@ -18608,15 +18612,7 @@ ix86_register_move_cost (machine_mode mode, reg_class_t class1_i,\n   if (MMX_CLASS_P (class1) != MMX_CLASS_P (class2))\n     gcc_unreachable ();\n \n-  /* Moves between SSE and integer units are expensive.  */\n   if (SSE_CLASS_P (class1) != SSE_CLASS_P (class2))\n-\n-    /* ??? By keeping returned value relatively high, we limit the number\n-       of moves between integer and SSE registers for all targets.\n-       Additionally, high value prevents problem with x86_modes_tieable_p(),\n-       where integer modes in SSE registers are not tieable\n-       because of missing QImode and HImode moves to, from or between\n-       MMX/SSE registers.  */\n     return (SSE_CLASS_P (class1)\n \t    ? ix86_cost->hard_register.sse_to_integer\n \t    : ix86_cost->hard_register.integer_to_sse);"}]}