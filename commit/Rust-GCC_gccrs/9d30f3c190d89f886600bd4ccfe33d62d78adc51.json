{"sha": "9d30f3c190d89f886600bd4ccfe33d62d78adc51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQzMGYzYzE5MGQ4OWY4ODY2MDBiZDRjY2ZlMzNkNjJkNzhhZGM1MQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2005-04-09T17:19:58Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2005-04-09T17:19:58Z"}, "message": "tree.h (enum tree_index): Add TI_VA_LIST_GPR_COUNTER_FIELD and TI_VA_LIST_FPR_COUNTER_FIELD.\n\n\t* tree.h (enum tree_index): Add TI_VA_LIST_GPR_COUNTER_FIELD\n\tand TI_VA_LIST_FPR_COUNTER_FIELD.\n\t(va_list_gpr_counter_field, va_list_fpr_counter_field): Define.\n\t* tree-pass.h (pass_stdarg): Add.\n\t* tree-optimize.c (init_tree_optimization_passes): Add pass_stdarg.\n\t* tree-stdarg.c: New file.\n\t* tree-stdarg.h: New file.\n\t* Makefile.in (OBJS-common): Add tree-stdarg.o.\n\t(tree-stdarg.o): Add dependencies.\n\t* function.h (struct function): Add va_list_gpr_size and\n\tva_list_fpr_size fields.\n\t* function.c (allocate_struct_function): Initialize them.\n\t* target.h (struct gcc_target): Add stdarg_optimize_hook.\n\t* target-def.h (TARGET_STDARG_OPTIMIZE_HOOK): Define.\n\t(TARGET_INITIALIZER): Add it.\n\n\t* config/i386/i386.c (ix86_build_builtin_va_list): Initialize\n\tva_list_{g,f}pr_counter_field.\n\t(ix86_setup_incoming_varargs): Don't do anything if reg_save\n\tarea will not be used.  Only save registers that tree-stdarg.c\n\tdetected they need saving.\n\t(ix86_va_start): Don't set up fields that won't be used.\n\n\t* config/rs6000/rs6000.c (rs6000_build_builtin_va_list): Initialize\n\tva_list_{g,f}pr_counter_field.\n\t(setup_incoming_varargs): Don't do anything if reg_save\n\tarea will not be used.  Only save registers that tree-stdarg.c\n\tdetected they need saving.\n\t(rs6000_va_start): Don't set up fields that won't be used.\n\n\t* config/alpha/alpha.c: Include tree-flow.h and tree-stdarg.h.\n\t(alpha_build_builtin_va_list): Initialize va_list_gpr_counter_field.\n\t(va_list_skip_additions, alpha_stdarg_optimize_hook): New functions.\n\t(TARGET_STDARG_OPTIMIZE_HOOK): Define.\n\n\t* gcc.dg/tree-ssa/stdarg-1.c: New test.\n\t* gcc.dg/tree-ssa/stdarg-2.c: New test.\n\t* gcc.dg/tree-ssa/stdarg-3.c: New test.\n\t* gcc.dg/tree-ssa/stdarg-4.c: New test.\n\t* gcc.dg/tree-ssa/stdarg-5.c: New test.\n\t* gcc.c-torture/execute/stdarg-4.c: New test.\n\n\t* gcc.dg/vmx/varargs-1.c (f1, f2, f3): Add missing va_end.\n\nFrom-SVN: r97916", "tree": {"sha": "61752d61b3fcec7c9f45123820661900d12f5e36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61752d61b3fcec7c9f45123820661900d12f5e36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d30f3c190d89f886600bd4ccfe33d62d78adc51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d30f3c190d89f886600bd4ccfe33d62d78adc51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d30f3c190d89f886600bd4ccfe33d62d78adc51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d30f3c190d89f886600bd4ccfe33d62d78adc51/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1b80335583a3b3713ed66afbc48d6ba886ce514c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b80335583a3b3713ed66afbc48d6ba886ce514c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b80335583a3b3713ed66afbc48d6ba886ce514c"}], "stats": {"total": 2037, "additions": 2005, "deletions": 32}, "files": [{"sha": "7366371cd235533fdfef8df6215dd53c6da38f64", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9d30f3c190d89f886600bd4ccfe33d62d78adc51", "patch": "@@ -1,3 +1,40 @@\n+2005-04-09  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* tree.h (enum tree_index): Add TI_VA_LIST_GPR_COUNTER_FIELD\n+\tand TI_VA_LIST_FPR_COUNTER_FIELD.\n+\t(va_list_gpr_counter_field, va_list_fpr_counter_field): Define.\n+\t* tree-pass.h (pass_stdarg): Add.\n+\t* tree-optimize.c (init_tree_optimization_passes): Add pass_stdarg.\n+\t* tree-stdarg.c: New file.\n+\t* tree-stdarg.h: New file.\n+\t* Makefile.in (OBJS-common): Add tree-stdarg.o.\n+\t(tree-stdarg.o): Add dependencies.\n+\t* function.h (struct function): Add va_list_gpr_size and\n+\tva_list_fpr_size fields.\n+\t* function.c (allocate_struct_function): Initialize them.\n+\t* target.h (struct gcc_target): Add stdarg_optimize_hook.\n+\t* target-def.h (TARGET_STDARG_OPTIMIZE_HOOK): Define.\n+\t(TARGET_INITIALIZER): Add it.\n+\n+\t* config/i386/i386.c (ix86_build_builtin_va_list): Initialize\n+\tva_list_{g,f}pr_counter_field.\n+\t(ix86_setup_incoming_varargs): Don't do anything if reg_save\n+\tarea will not be used.  Only save registers that tree-stdarg.c\n+\tdetected they need saving.\n+\t(ix86_va_start): Don't set up fields that won't be used.\n+\n+\t* config/rs6000/rs6000.c (rs6000_build_builtin_va_list): Initialize\n+\tva_list_{g,f}pr_counter_field.\n+\t(setup_incoming_varargs): Don't do anything if reg_save\n+\tarea will not be used.  Only save registers that tree-stdarg.c\n+\tdetected they need saving.\n+\t(rs6000_va_start): Don't set up fields that won't be used.\n+\n+\t* config/alpha/alpha.c: Include tree-flow.h and tree-stdarg.h.\n+\t(alpha_build_builtin_va_list): Initialize va_list_gpr_counter_field.\n+\t(va_list_skip_additions, alpha_stdarg_optimize_hook): New functions.\n+\t(TARGET_STDARG_OPTIMIZE_HOOK): Define.\n+\n 2005-04-09  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/20795"}, {"sha": "02599fb3bfb1c0ed4a35195c6986d16142369ac6", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=9d30f3c190d89f886600bd4ccfe33d62d78adc51", "patch": "@@ -959,7 +959,7 @@ OBJS-common = \\\n  et-forest.o cfghooks.o bt-load.o pretty-print.o $(GGC) web.o passes.o\t   \\\n  rtl-profile.o tree-profile.o rtlhooks.o cfgexpand.o lambda-mat.o          \\\n  lambda-trans.o lambda-code.o tree-loop-linear.o tree-ssa-sink.o           \\\n- tree-vrp.o\n+ tree-vrp.o tree-stdarg.o\n \n OBJS-md = $(out_object_file)\n OBJS-archive = $(EXTRA_OBJS) $(host_hook_obj) tree-inline.o\t\t   \\\n@@ -1814,6 +1814,9 @@ tree-loop-linear.o: tree-loop-linear.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_\n    errors.h $(GGC_H) $(OPTABS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) diagnostic.h \\\n    $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) cfgloop.h tree-pass.h \\\n    $(TREE_DATA_REF_H) $(SCEV_H) $(EXPR_H)\n+tree-stdarg.o: tree-stdarg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(TREE_H) function.h diagnostic.h $(TREE_FLOW_H) tree-pass.h tree-stdarg.h \\\n+   $(TARGET_H)\n tree-gimple.o : tree-gimple.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(EXPR_H) \\\n \t$(RTL_H) $(TREE_GIMPLE_H) $(TM_H) coretypes.h bitmap.h $(GGC_H)\n tree-mudflap.o : $(CONFIG_H) errors.h $(SYSTEM_H) $(TREE_H) tree-inline.h \\"}, {"sha": "39ad4a7aaa8e569867870f3ca7b8c3f9e85d0fc3", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=9d30f3c190d89f886600bd4ccfe33d62d78adc51", "patch": "@@ -53,6 +53,8 @@ Boston, MA 02111-1307, USA.  */\n #include <splay-tree.h>\n #include \"cfglayout.h\"\n #include \"tree-gimple.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-stdarg.h\"\n \n /* Specify which cpu to schedule for.  */\n enum processor_type alpha_tune;\n@@ -5576,9 +5578,156 @@ alpha_build_builtin_va_list (void)\n   TYPE_FIELDS (record) = base;\n   layout_type (record);\n \n+  va_list_gpr_counter_field = ofs;\n   return record;\n }\n \n+/* Helper function for alpha_stdarg_optimize_hook.  Skip over casts\n+   and constant additions.  */\n+\n+static tree\n+va_list_skip_additions (tree lhs)\n+{\n+  tree rhs, stmt;\n+\n+  if (TREE_CODE (lhs) != SSA_NAME)\n+    return lhs;\n+\n+  for (;;)\n+    {\n+      stmt = SSA_NAME_DEF_STMT (lhs);\n+\n+      if (TREE_CODE (stmt) == PHI_NODE)\n+\treturn stmt;\n+\n+      if (TREE_CODE (stmt) != MODIFY_EXPR\n+\t  || TREE_OPERAND (stmt, 0) != lhs)\n+\treturn lhs;\n+\n+      rhs = TREE_OPERAND (stmt, 1);\n+      if (TREE_CODE (rhs) == WITH_SIZE_EXPR)\n+\trhs = TREE_OPERAND (rhs, 0);\n+\n+      if ((TREE_CODE (rhs) != NOP_EXPR\n+\t   && TREE_CODE (rhs) != CONVERT_EXPR\n+\t   && (TREE_CODE (rhs) != PLUS_EXPR\n+\t       || TREE_CODE (TREE_OPERAND (rhs, 1)) != INTEGER_CST\n+\t       || !host_integerp (TREE_OPERAND (rhs, 1), 1)))\n+\t  || TREE_CODE (TREE_OPERAND (rhs, 0)) != SSA_NAME)\n+\treturn rhs;\n+\n+      lhs = TREE_OPERAND (rhs, 0);\n+    }\n+}\n+\n+/* Check if LHS = RHS statement is\n+   LHS = *(ap.__base + ap.__offset + cst)\n+   or\n+   LHS = *(ap.__base\n+\t   + ((ap.__offset + cst <= 47)\n+\t      ? ap.__offset + cst - 48 : ap.__offset + cst) + cst2).\n+   If the former, indicate that GPR registers are needed,\n+   if the latter, indicate that FPR registers are needed.\n+   On alpha, cfun->va_list_gpr_size is used as size of the needed\n+   regs and cfun->va_list_fpr_size is a bitmask, bit 0 set if\n+   GPR registers are needed and bit 1 set if FPR registers are needed.\n+   Return true if va_list references should not be scanned for the current\n+   statement.  */\n+\n+static bool\n+alpha_stdarg_optimize_hook (struct stdarg_info *si, tree lhs, tree rhs)\n+{\n+  tree base, offset, arg1, arg2;\n+  int offset_arg = 1;\n+\n+  if (TREE_CODE (rhs) != INDIRECT_REF\n+      || TREE_CODE (TREE_OPERAND (rhs, 0)) != SSA_NAME)\n+    return false;\n+\n+  lhs = va_list_skip_additions (TREE_OPERAND (rhs, 0));\n+  if (lhs == NULL_TREE\n+      || TREE_CODE (lhs) != PLUS_EXPR)\n+    return false;\n+\n+  base = TREE_OPERAND (lhs, 0);\n+  if (TREE_CODE (base) == SSA_NAME)\n+    base = va_list_skip_additions (base);\n+\n+  if (TREE_CODE (base) != COMPONENT_REF\n+      || TREE_OPERAND (base, 1) != TYPE_FIELDS (va_list_type_node))\n+    {\n+      base = TREE_OPERAND (lhs, 0);\n+      if (TREE_CODE (base) == SSA_NAME)\n+\tbase = va_list_skip_additions (base);\n+\n+      if (TREE_CODE (base) != COMPONENT_REF\n+\t  || TREE_OPERAND (base, 1) != TYPE_FIELDS (va_list_type_node))\n+\treturn false;\n+\n+      offset_arg = 0;\n+    }\n+\n+  base = get_base_address (base);\n+  if (TREE_CODE (base) != VAR_DECL\n+      || !bitmap_bit_p (si->va_list_vars, var_ann (base)->uid))\n+    return false;\n+\n+  offset = TREE_OPERAND (lhs, offset_arg);\n+  if (TREE_CODE (offset) == SSA_NAME)\n+    offset = va_list_skip_additions (offset);\n+\n+  if (TREE_CODE (offset) == PHI_NODE)\n+    {\n+      HOST_WIDE_INT sub;\n+\n+      if (PHI_NUM_ARGS (offset) != 2)\n+\tgoto escapes;\n+\n+      arg1 = va_list_skip_additions (PHI_ARG_DEF (offset, 0));\n+      arg2 = va_list_skip_additions (PHI_ARG_DEF (offset, 1));\n+      if (TREE_CODE (arg1) != COMPONENT_REF)\n+\t{\n+\t  tree tem = arg1;\n+\n+\t  arg1 = arg2;\n+\t  arg2 = tem;\n+\t}\n+\n+      if ((TREE_CODE (arg2) != MINUS_EXPR\n+\t   && TREE_CODE (arg2) != PLUS_EXPR)\n+\t  || !host_integerp (TREE_OPERAND (arg2, 1), 0))\n+\tgoto escapes;\n+\n+      sub = tree_low_cst (TREE_OPERAND (arg2, 1), 0);\n+      if (TREE_CODE (arg2) == MINUS_EXPR)\n+\tsub = -sub;\n+      if (sub < -48 || sub > -32)\n+\tgoto escapes;\n+\n+      arg2 = va_list_skip_additions (TREE_OPERAND (arg2, 0));\n+      if (arg1 != arg2\n+\t  || TREE_CODE (arg1) != COMPONENT_REF\n+\t  || TREE_OPERAND (arg1, 1) != va_list_gpr_counter_field\n+\t  || get_base_address (arg1) != base)\n+\tgoto escapes;\n+\n+      /* Need floating point regs.  */\n+      cfun->va_list_fpr_size |= 2;\n+    }\n+  else if (TREE_CODE (offset) != COMPONENT_REF\n+\t   || TREE_OPERAND (offset, 1) != va_list_gpr_counter_field\n+\t   || get_base_address (offset) != base)\n+    goto escapes;\n+  else\n+    /* Need general regs.  */\n+    cfun->va_list_fpr_size |= 1;\n+  return false;\n+\n+escapes:\n+  si->va_list_escapes = true;\n+  return false;\n+}\n+\n /* Perform any needed actions needed for a function that is receiving a\n    variable number of arguments.  */\n \n@@ -10205,6 +10354,9 @@ alpha_init_libfuncs (void)\n #undef TARGET_HANDLE_OPTION\n #define TARGET_HANDLE_OPTION alpha_handle_option\n \n+#undef TARGET_STDARG_OPTIMIZE_HOOK\n+#define TARGET_STDARG_OPTIMIZE_HOOK alpha_stdarg_optimize_hook\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n \f"}, {"sha": "9634ff44ab1d40a98c044a423ece6d66cb7b2f88", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 34, "deletions": 16, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=9d30f3c190d89f886600bd4ccfe33d62d78adc51", "patch": "@@ -3256,6 +3256,9 @@ ix86_build_builtin_va_list (void)\n   f_sav = build_decl (FIELD_DECL, get_identifier (\"reg_save_area\"),\n \t\t      ptr_type_node);\n \n+  va_list_gpr_counter_field = f_gpr;\n+  va_list_fpr_counter_field = f_fpr;\n+\n   DECL_FIELD_CONTEXT (f_gpr) = record;\n   DECL_FIELD_CONTEXT (f_fpr) = record;\n   DECL_FIELD_CONTEXT (f_ovf) = record;\n@@ -3295,6 +3298,9 @@ ix86_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   if (!TARGET_64BIT)\n     return;\n \n+  if (! cfun->va_list_gpr_size && ! cfun->va_list_fpr_size)\n+    return;\n+\n   /* Indicate to allocate space on the stack for varargs save area.  */\n   ix86_save_varrargs_registers = 1;\n \n@@ -3316,7 +3322,10 @@ ix86_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \n   set = get_varargs_alias_set ();\n \n-  for (i = next_cum.regno; i < ix86_regparm; i++)\n+  for (i = next_cum.regno;\n+       i < ix86_regparm\n+       && i < next_cum.regno + cfun->va_list_gpr_size / UNITS_PER_WORD;\n+       i++)\n     {\n       mem = gen_rtx_MEM (Pmode,\n \t\t\t plus_constant (save_area, i * UNITS_PER_WORD));\n@@ -3325,7 +3334,7 @@ ix86_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t\t\t\tx86_64_int_parameter_registers[i]));\n     }\n \n-  if (next_cum.sse_nregs)\n+  if (next_cum.sse_nregs && cfun->va_list_fpr_size)\n     {\n       /* Now emit code to save SSE registers.  The AX parameter contains number\n \t of SSE parameter registers used to call this function.  We use\n@@ -3408,15 +3417,21 @@ ix86_va_start (tree valist, rtx nextarg)\n     fprintf (stderr, \"va_start: words = %d, n_gpr = %d, n_fpr = %d\\n\",\n \t     (int) words, (int) n_gpr, (int) n_fpr);\n \n-  t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr,\n-\t     build_int_cst (NULL_TREE, n_gpr * 8));\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+  if (cfun->va_list_gpr_size)\n+    {\n+      t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr,\n+\t\t build_int_cst (NULL_TREE, n_gpr * 8));\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+    }\n \n-  t = build (MODIFY_EXPR, TREE_TYPE (fpr), fpr,\n-\t     build_int_cst (NULL_TREE, n_fpr * 16 + 8*REGPARM_MAX));\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+  if (cfun->va_list_fpr_size)\n+    {\n+      t = build (MODIFY_EXPR, TREE_TYPE (fpr), fpr,\n+\t\t build_int_cst (NULL_TREE, n_fpr * 16 + 8*REGPARM_MAX));\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+    }\n \n   /* Find the overflow area.  */\n   t = make_tree (TREE_TYPE (ovf), virtual_incoming_args_rtx);\n@@ -3427,12 +3442,15 @@ ix86_va_start (tree valist, rtx nextarg)\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-  /* Find the register save area.\n-     Prologue of the function save it right above stack frame.  */\n-  t = make_tree (TREE_TYPE (sav), frame_pointer_rtx);\n-  t = build (MODIFY_EXPR, TREE_TYPE (sav), sav, t);\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+  if (cfun->va_list_gpr_size || cfun->va_list_fpr_size)\n+    {\n+      /* Find the register save area.\n+\t Prologue of the function save it right above stack frame.  */\n+      t = make_tree (TREE_TYPE (sav), frame_pointer_rtx);\n+      t = build (MODIFY_EXPR, TREE_TYPE (sav), sav, t);\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+    }\n }\n \n /* Implement va_arg.  */"}, {"sha": "4bbe70279f7486a1061c0ab3e9281ae8e6944dee", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 49, "deletions": 15, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=9d30f3c190d89f886600bd4ccfe33d62d78adc51", "patch": "@@ -5115,25 +5115,42 @@ setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n     }\n \n   set = get_varargs_alias_set ();\n-  if (! no_rtl && first_reg_offset < GP_ARG_NUM_REG)\n+  if (! no_rtl && first_reg_offset < GP_ARG_NUM_REG\n+      && cfun->va_list_gpr_size)\n     {\n+      int nregs = GP_ARG_NUM_REG - first_reg_offset;\n+\n+      if (va_list_gpr_counter_field)\n+\t{\n+\t  /* V4 va_list_gpr_size counts number of registers needed.  */\n+\t  if (nregs > cfun->va_list_gpr_size)\n+\t    nregs = cfun->va_list_gpr_size;\n+\t}\n+      else\n+\t{\n+\t  /* char * va_list instead counts number of bytes needed.  */\n+\t  if (nregs > cfun->va_list_gpr_size / reg_size)\n+\t    nregs = cfun->va_list_gpr_size / reg_size;\n+\t}\n+\n       mem = gen_rtx_MEM (BLKmode,\n \t\t\t plus_constant (save_area,\n \t\t\t\t\tfirst_reg_offset * reg_size)),\n       set_mem_alias_set (mem, set);\n       set_mem_align (mem, BITS_PER_WORD);\n \n       rs6000_move_block_from_reg (GP_ARG_MIN_REG + first_reg_offset, mem,\n-\t\t\t\t  GP_ARG_NUM_REG - first_reg_offset);\n+\t\t\t\t  nregs);\n     }\n \n   /* Save FP registers if needed.  */\n   if (DEFAULT_ABI == ABI_V4\n       && TARGET_HARD_FLOAT && TARGET_FPRS\n       && ! no_rtl\n-      && next_cum.fregno <= FP_ARG_V4_MAX_REG)\n+      && next_cum.fregno <= FP_ARG_V4_MAX_REG\n+      && cfun->va_list_fpr_size)\n     {\n-      int fregno = next_cum.fregno;\n+      int fregno = next_cum.fregno, nregs;\n       rtx cr1 = gen_rtx_REG (CCmode, CR1_REGNO);\n       rtx lab = gen_label_rtx ();\n       int off = (GP_ARG_NUM_REG * reg_size) + ((fregno - FP_ARG_MIN_REG) * 8);\n@@ -5147,14 +5164,14 @@ setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t\t\t\t    gen_rtx_LABEL_REF (VOIDmode, lab),\n \t\t\t\t\t    pc_rtx)));\n \n-      while (fregno <= FP_ARG_V4_MAX_REG)\n+      for (nregs = 0;\n+\t   fregno <= FP_ARG_V4_MAX_REG && nregs < cfun->va_list_fpr_size;\n+\t   fregno++, off += 8, nregs++)\n \t{\n \t  mem = gen_rtx_MEM (DFmode, plus_constant (save_area, off));\n \t  set_mem_alias_set (mem, set);\n \t  set_mem_align (mem, GET_MODE_ALIGNMENT (DFmode));\n \t  emit_move_insn (mem, gen_rtx_REG (DFmode, fregno));\n-\t  fregno++;\n-\t  off += 8;\n \t}\n \n       emit_label (lab);\n@@ -5189,6 +5206,9 @@ rs6000_build_builtin_va_list (void)\n   f_sav = build_decl (FIELD_DECL, get_identifier (\"reg_save_area\"),\n \t\t      ptr_type_node);\n \n+  va_list_gpr_counter_field = f_gpr;\n+  va_list_fpr_counter_field = f_fpr;\n+\n   DECL_FIELD_CONTEXT (f_gpr) = record;\n   DECL_FIELD_CONTEXT (f_fpr) = record;\n   DECL_FIELD_CONTEXT (f_res) = record;\n@@ -5249,15 +5269,21 @@ rs6000_va_start (tree valist, rtx nextarg)\n \t     HOST_WIDE_INT_PRINT_DEC\", n_fpr = \"HOST_WIDE_INT_PRINT_DEC\"\\n\",\n \t     words, n_gpr, n_fpr);\n \n-  t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr,\n-\t     build_int_cst (NULL_TREE, n_gpr));\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+  if (cfun->va_list_gpr_size)\n+    {\n+      t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr,\n+\t\t build_int_cst (NULL_TREE, n_gpr));\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+    }\n \n-  t = build (MODIFY_EXPR, TREE_TYPE (fpr), fpr,\n-\t     build_int_cst (NULL_TREE, n_fpr));\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+  if (cfun->va_list_fpr_size)\n+    {\n+      t = build (MODIFY_EXPR, TREE_TYPE (fpr), fpr,\n+\t\t build_int_cst (NULL_TREE, n_fpr));\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+    }\n \n   /* Find the overflow area.  */\n   t = make_tree (TREE_TYPE (ovf), virtual_incoming_args_rtx);\n@@ -5268,6 +5294,14 @@ rs6000_va_start (tree valist, rtx nextarg)\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n+  /* If there were no va_arg invocations, don't set up the register\n+     save area.  */\n+  if (!cfun->va_list_gpr_size\n+      && !cfun->va_list_fpr_size\n+      && n_gpr < GP_ARG_NUM_REG\n+      && n_fpr < FP_ARG_V4_MAX_REG)\n+    return;\n+\n   /* Find the register save area.  */\n   t = make_tree (TREE_TYPE (sav), virtual_stack_vars_rtx);\n   t = build (PLUS_EXPR, TREE_TYPE (sav), t,"}, {"sha": "909204fdccc95e0f1412baad9c418ae4b6795bd3", "filename": "gcc/function.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=9d30f3c190d89f886600bd4ccfe33d62d78adc51", "patch": "@@ -3944,6 +3944,10 @@ allocate_struct_function (tree fndecl)\n        && TYPE_ARG_TYPES (fntype) != 0\n        && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))\n \t   != void_type_node));\n+\n+  /* Assume all registers in stdarg functions need to be saved.  */\n+  cfun->va_list_gpr_size = VA_LIST_MAX_GPR_SIZE;\n+  cfun->va_list_fpr_size = VA_LIST_MAX_FPR_SIZE;\n }\n \n /* Reset cfun, and other non-struct-function variables to defaults as"}, {"sha": "b772752552f27877ad0ad05ff1f47a91ca2b9934", "filename": "gcc/function.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=9d30f3c190d89f886600bd4ccfe33d62d78adc51", "patch": "@@ -423,8 +423,22 @@ struct function GTY(())\n \n   /* Nonzero if code to initialize arg_pointer_save_area has been emitted.  */\n   unsigned int arg_pointer_save_area_init : 1;\n+\n+  /* Number of units of general registers that need saving in stdarg\n+     function.  What unit is depends on the backend, either it is number\n+     of bytes, or it can be number of registers.  */\n+  unsigned int va_list_gpr_size : 8;\n+\n+  /* Number of units of floating point registers that need saving in stdarg\n+     function.  */\n+  unsigned int va_list_fpr_size : 8;\n };\n \n+/* If va_list_[gf]pr_size is set to this, it means we don't know how\n+   many units need to be saved.  */\n+#define VA_LIST_MAX_GPR_SIZE\t255\n+#define VA_LIST_MAX_FPR_SIZE\t255\n+\n /* The function currently being compiled.  */\n extern GTY(()) struct function *cfun;\n "}, {"sha": "aa65e37c5ace288934c3833314f59bc58dcf362b", "filename": "gcc/target-def.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=9d30f3c190d89f886600bd4ccfe33d62d78adc51", "patch": "@@ -385,6 +385,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n \n #define TARGET_DWARF_HANDLE_FRAME_UNSPEC 0\n \n+#define TARGET_STDARG_OPTIMIZE_HOOK 0\n+\n #define TARGET_PROMOTE_FUNCTION_ARGS hook_bool_tree_false\n #define TARGET_PROMOTE_FUNCTION_RETURN hook_bool_tree_false\n #define TARGET_PROMOTE_PROTOTYPES hook_bool_tree_false\n@@ -538,6 +540,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n   TARGET_MD_ASM_CLOBBERS,\t\t\t\\\n   TARGET_DWARF_CALLING_CONVENTION,              \\\n   TARGET_DWARF_HANDLE_FRAME_UNSPEC,\t\t\\\n+  TARGET_STDARG_OPTIMIZE_HOOK,\t\t\t\\\n   TARGET_CALLS,\t\t\t\t\t\\\n   TARGET_CXX,\t\t\t\t\t\\\n   TARGET_HAVE_NAMED_SECTIONS,\t\t\t\\"}, {"sha": "42a721ce2af9f51ef85abda398b096b0ef0f91ee", "filename": "gcc/target.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=9d30f3c190d89f886600bd4ccfe33d62d78adc51", "patch": "@@ -50,6 +50,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"tm.h\"\n #include \"insn-modes.h\"\n \n+struct stdarg_info;\n+\n struct gcc_target\n {\n   /* Functions that output assembler for the target.  */\n@@ -506,6 +508,12 @@ struct gcc_target\n      to let the backend emit the call frame instructions.  */\n   void (* dwarf_handle_frame_unspec) (const char *, rtx, int);\n \n+  /* Perform architecture specific checking of statements gimplified\n+     from VA_ARG_EXPR.  LHS is left hand side of MODIFY_EXPR, RHS\n+     is right hand side.  Returns true if the statements doesn't need\n+     to be checked for va_list references.  */\n+  bool (*stdarg_optimize_hook) (struct stdarg_info *ai, tree lhs, tree rhs);\n+\n   /* Functions relating to calls - argument passing, returns, etc.  */\n   struct calls {\n     bool (*promote_function_args) (tree fntype);"}, {"sha": "0cee677a70e28414811bfedce1412c980a62d4ed", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9d30f3c190d89f886600bd4ccfe33d62d78adc51", "patch": "@@ -1,5 +1,14 @@\n 2005-04-09  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* gcc.dg/tree-ssa/stdarg-1.c: New test.\n+\t* gcc.dg/tree-ssa/stdarg-2.c: New test.\n+\t* gcc.dg/tree-ssa/stdarg-3.c: New test.\n+\t* gcc.dg/tree-ssa/stdarg-4.c: New test.\n+\t* gcc.dg/tree-ssa/stdarg-5.c: New test.\n+\t* gcc.c-torture/execute/stdarg-4.c: New test.\n+\n+\t* gcc.dg/vmx/varargs-1.c (f1, f2, f3): Add missing va_end.\n+\n \tPR target/20795\n \t* g++.dg/abi/param2.C: New test.\n "}, {"sha": "f820bcee4aa8fde4f36687fe98799f843b05dbd4", "filename": "gcc/testsuite/gcc.c-torture/execute/stdarg-4.c", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstdarg-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstdarg-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstdarg-4.c?ref=9d30f3c190d89f886600bd4ccfe33d62d78adc51", "patch": "@@ -0,0 +1,137 @@\n+#include <stdarg.h>\n+\n+extern void abort (void);\n+long x, y;\n+\n+inline void __attribute__((always_inline))\n+f1i (va_list ap)\n+{\n+  x = va_arg (ap, double);\n+  x += va_arg (ap, long);\n+  x += va_arg (ap, double);\n+}\n+\n+void\n+f1 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  f1i (ap);\n+  va_end (ap);\n+}\n+\n+inline void __attribute__((always_inline))\n+f2i (va_list ap)\n+{\n+  y = va_arg (ap, int);\n+  y += va_arg (ap, long);\n+  y += va_arg (ap, double);\n+  f1i (ap);\n+}\n+\n+void\n+f2 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  f2i (ap);\n+  va_end (ap);\n+}\n+\n+long\n+f3h (int i, long arg0, long arg1, long arg2, long arg3)\n+{\n+  return i + arg0 + arg1 + arg2 + arg3;\n+}\n+\n+long\n+f3 (int i, ...)\n+{\n+  long t, arg0, arg1, arg2, arg3;\n+  va_list ap;\n+\n+  va_start (ap, i);\n+  switch (i)\n+    {\n+    case 0:\n+      t = f3h (i, 0, 0, 0, 0);\n+      break;\n+    case 1:\n+      arg0 = va_arg (ap, long);\n+      t = f3h (i, arg0, 0, 0, 0);\n+      break;\n+    case 2:\n+      arg0 = va_arg (ap, long);\n+      arg1 = va_arg (ap, long);\n+      t = f3h (i, arg0, arg1, 0, 0);\n+      break;\n+    case 3:\n+      arg0 = va_arg (ap, long);\n+      arg1 = va_arg (ap, long);\n+      arg2 = va_arg (ap, long);\n+      t = f3h (i, arg0, arg1, arg2, 0);\n+      break;\n+    case 4:\n+      arg0 = va_arg (ap, long);\n+      arg1 = va_arg (ap, long);\n+      arg2 = va_arg (ap, long);\n+      arg3 = va_arg (ap, long);\n+      t = f3h (i, arg0, arg1, arg2, arg3);\n+      break;\n+    default:\n+      abort ();\n+    }\n+  va_end (ap);\n+\n+  return t;\n+}\n+\n+void\n+f4 (int i, ...)\n+{\n+  va_list ap;\n+\n+  va_start (ap, i);\n+  switch (i)\n+    {\n+    case 4:\n+      y = va_arg (ap, double);\n+      break;\n+    case 5:\n+      y = va_arg (ap, double);\n+      y += va_arg (ap, double);\n+      break;\n+    default:\n+      abort ();\n+    }\n+  f1i (ap);\n+  va_end (ap);\n+}\n+\n+int\n+main (void)\n+{\n+  f1 (3, 16.0, 128L, 32.0);\n+  if (x != 176L)\n+    abort ();\n+  f2 (6, 5, 7L, 18.0, 19.0, 17L, 64.0);\n+  if (x != 100L || y != 30L)\n+    abort ();\n+  if (f3 (0) != 0)\n+    abort ();\n+  if (f3 (1, 18L) != 19L)\n+    abort ();\n+  if (f3 (2, 18L, 100L) != 120L)\n+    abort ();\n+  if (f3 (3, 18L, 100L, 300L) != 421L)\n+    abort ();\n+  if (f3 (4, 18L, 71L, 64L, 86L) != 243L)\n+    abort ();\n+  f4 (4, 6.0, 9.0, 16L, 18.0);\n+  if (x != 43L || y != 6L)\n+    abort ();\n+  f4 (5, 7.0, 21.0, 1.0, 17L, 126.0);\n+  if (x != 144L || y != 28L)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "39b61c9eb8df52d22029c5b202b27e35e667b396", "filename": "gcc/testsuite/gcc.dg/tree-ssa/stdarg-1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-1.c?ref=9d30f3c190d89f886600bd4ccfe33d62d78adc51", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-stdarg\" } */\n+\n+#include <stdarg.h>\n+\n+/* This can be handled on all arches.  If there is no va_start, registers don't need\n+   to be saved.  */\n+void\n+f1 (int i, ...)\n+{\n+}\n+/* { dg-final { scan-tree-dump \"f1: va_list escapes 0, needs to save 0 GPR units and 0 FPR units\" \"stdarg\" } } */"}, {"sha": "e1b2cab5e1e9bc83068e609cc57735c7255e96a7", "filename": "gcc/testsuite/gcc.dg/tree-ssa/stdarg-2.c", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-2.c?ref=9d30f3c190d89f886600bd4ccfe33d62d78adc51", "patch": "@@ -0,0 +1,267 @@\n+/* First dg-final line after each function is for architectures that use\n+   a struct {...} va_list[1] with separate GPR and FPR counters in the\n+   structure.  Second dg-final line is for architectures that use void *\n+   or char * va_list.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-stdarg\" } */\n+\n+#include <stdarg.h>\n+\n+extern void foo (int, va_list);\n+extern void bar (int);\n+long x;\n+double d;\n+va_list gap;\n+va_list *pap;\n+\n+void\n+f1 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  va_end (ap);\n+}\n+/* { dg-final { scan-tree-dump \"f1: va_list escapes 0, needs to save 0 GPR units and 0 FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f1: va_list escapes 0, needs to save 0 GPR units and 0 FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f1: va_list escapes 0, needs to save 0 GPR units and 0 FPR units\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f1: va_list escapes 0, needs to save 0 GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f1: va_list escapes 0, needs to save 0 GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */\n+\n+void\n+f2 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  bar (d);\n+  x = va_arg (ap, long);\n+  bar (x);\n+  va_end (ap);\n+}\n+/* Assume the counters can be number of registers or bytes on 32-bit\n+   architecture or bytes on 64-bit architecture.  */\n+/* { dg-final { scan-tree-dump \"f2: va_list escapes 0, needs to save \\[148\\] GPR units and 0 FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f2: va_list escapes 0, needs to save \\[148\\] GPR units and 0 FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f2: va_list escapes 0, needs to save 8 GPR units and 1\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f2: va_list escapes 0, needs to save \\[148\\] GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f2: va_list escapes 0, needs to save \\[148\\] GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */\n+\n+void\n+f3 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  d = va_arg (ap, double);\n+  va_end (ap);\n+}\n+/* { dg-final { scan-tree-dump \"f3: va_list escapes 0, needs to save 0 GPR units and \\[1-9\\]\\[0-9\\]* FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f3: va_list escapes 0, needs to save 0 GPR units and \\[1-9\\]\\[0-9\\]* FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f3: va_list escapes 0, needs to save 8 GPR units and 2\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f3: va_list escapes 0, needs to save \\[1-9\\]\\[0-9\\]* GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f3: va_list escapes 0, needs to save \\[1-9\\]\\[0-9\\]* GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */\n+\n+void\n+f4 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  x = va_arg (ap, double);\n+  foo (i, ap);\n+  va_end (ap);\n+}\n+/* { dg-final { scan-tree-dump \"f4: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f4: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f4: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f4: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f4: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */\n+\n+void\n+f5 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  va_copy (gap, ap);\n+  bar (i);\n+  va_end (ap);\n+  va_end (gap);\n+}\n+/* { dg-final { scan-tree-dump \"f5: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f5: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f5: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f5: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f5: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */\n+\n+void\n+f6 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  bar (d);\n+  va_arg (ap, long);\n+  va_arg (ap, long);\n+  x = va_arg (ap, long);\n+  bar (x);\n+  va_end (ap);\n+}\n+/* { dg-final { scan-tree-dump \"f6: va_list escapes 0, needs to save (3|12|24) GPR units and 0 FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f6: va_list escapes 0, needs to save (3|12|24) GPR units and 0 FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f6: va_list escapes 0, needs to save 24 GPR units and 1\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f6: va_list escapes 0, needs to save (3|12|24) GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f6: va_list escapes 0, needs to save (3|12|24) GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */\n+\n+void\n+f7 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  pap = &ap;\n+  bar (6);\n+  va_end (ap);\n+}\n+/* { dg-final { scan-tree-dump \"f7: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f7: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f7: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f7: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f7: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */\n+\n+void\n+f8 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  pap = &ap;\n+  bar (d);\n+  x = va_arg (ap, long);\n+  bar (x);\n+  va_end (ap);\n+}\n+/* { dg-final { scan-tree-dump \"f8: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f8: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f8: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f8: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f8: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */\n+\n+void\n+f9 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  __asm __volatile (\"\" : \"=r\" (pap) : \"0\" (&ap));\n+  bar (6);\n+  va_end (ap);\n+}\n+/* { dg-final { scan-tree-dump \"f9: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f9: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f9: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f9: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f9: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */\n+\n+void\n+f10 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  __asm __volatile (\"\" : \"=r\" (pap) : \"0\" (&ap));\n+  bar (d);\n+  x = va_arg (ap, long);\n+  bar (x);\n+  va_end (ap);\n+}\n+/* { dg-final { scan-tree-dump \"f10: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f10: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f10: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f10: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f10: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */\n+\n+void\n+f11 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  bar (d);\n+  x = va_arg (ap, long);\n+  x += va_arg (ap, long);\n+  x += va_arg (ap, long);\n+  bar (x);\n+  va_end (ap);\n+}\n+/* { dg-final { scan-tree-dump \"f11: va_list escapes 0, needs to save (3|12|24) GPR units and 0 FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f11: va_list escapes 0, needs to save (3|12|24) GPR units and 0 FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f11: va_list escapes 0, needs to save 24 GPR units and 1\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f11: va_list escapes 0, needs to save (3|12|24) GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f11: va_list escapes 0, needs to save (3|12|24) GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */\n+\n+void\n+f12 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  bar (d);\n+  va_arg (ap, double);\n+  va_arg (ap, double);\n+  x = va_arg (ap, double);\n+  bar (x);\n+  va_end (ap);\n+}\n+/* { dg-final { scan-tree-dump \"f12: va_list escapes 0, needs to save 0 GPR units and \\[1-9\\]\\[0-9\\]* FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f12: va_list escapes 0, needs to save 0 GPR units and \\[1-9\\]\\[0-9\\]* FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f12: va_list escapes 0, needs to save 24 GPR units and 2\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f12: va_list escapes 0, needs to save \\[1-9]\\[0-9\\]* GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f12: va_list escapes 0, needs to save \\[1-9]\\[0-9\\]* GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */\n+\n+void\n+f13 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  bar (d);\n+  x = va_arg (ap, double);\n+  x += va_arg (ap, double);\n+  x += va_arg (ap, double);\n+  bar (x);\n+  va_end (ap);\n+}\n+/* { dg-final { scan-tree-dump \"f13: va_list escapes 0, needs to save 0 GPR units and \\[1-9\\]\\[0-9\\]* FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f13: va_list escapes 0, needs to save 0 GPR units and \\[1-9\\]\\[0-9\\]* FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f13: va_list escapes 0, needs to save 24 GPR units and 2\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f13: va_list escapes 0, needs to save \\[1-9]\\[0-9\\]* GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f13: va_list escapes 0, needs to save \\[1-9]\\[0-9\\]* GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */\n+\n+void\n+f14 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  bar (d);\n+  x = va_arg (ap, double);\n+  x += va_arg (ap, long);\n+  x += va_arg (ap, double);\n+  bar (x);\n+  va_end (ap);\n+}\n+/* { dg-final { scan-tree-dump \"f14: va_list escapes 0, needs to save \\[148\\] GPR units and \\[1-9\\]\\[0-9\\]* FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f14: va_list escapes 0, needs to save \\[148\\] GPR units and \\[1-9\\]\\[0-9\\]* FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f14: va_list escapes 0, needs to save 24 GPR units and 3\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f14: va_list escapes 0, needs to save \\[1-9]\\[0-9\\]* GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f14: va_list escapes 0, needs to save \\[1-9]\\[0-9\\]* GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */\n+\n+inline void __attribute__((always_inline))\n+f15_1 (va_list ap)\n+{\n+  x = va_arg (ap, double);\n+  x += va_arg (ap, long);\n+  x += va_arg (ap, double);\n+}\n+\n+void\n+f15 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  f15_1 (ap);\n+  va_end (ap);\n+}\n+/* { dg-final { scan-tree-dump \"f15: va_list escapes 0, needs to save \\[148\\] GPR units and \\[1-9\\]\\[0-9\\]* FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f15: va_list escapes 0, needs to save \\[148\\] GPR units and \\[1-9\\]\\[0-9\\]* FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f15: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump-not \"f15: va_list escapes 0, needs to save 0 GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump-not \"f15: va_list escapes 0, needs to save 0 GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */"}, {"sha": "1fcf616d7e5fe3a9399cf8689361d54da41d2266", "filename": "gcc/testsuite/gcc.dg/tree-ssa/stdarg-3.c", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-3.c?ref=9d30f3c190d89f886600bd4ccfe33d62d78adc51", "patch": "@@ -0,0 +1,170 @@\n+/* First dg-final line after each function is for architectures that use\n+   a struct {...} va_list[1] with separate GPR and FPR counters in the\n+   structure.  Second dg-final line is for architectures that use void *\n+   or char * va_list.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-stdarg\" } */\n+\n+#include <stdarg.h>\n+\n+extern void foo (int, va_list);\n+extern void bar (int);\n+long x;\n+va_list gap;\n+\n+/* If va_list is not local variable, it escapes the function.  */\n+void\n+f1 (int i, ...)\n+{\n+  va_start (gap, i);\n+  x = va_arg (gap, long);\n+  va_end (gap);\n+}\n+/* { dg-final { scan-tree-dump \"f1: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f1: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f1: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f1: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f1: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */\n+\n+void\n+f2 (int i, ...)\n+{\n+  va_start (gap, i);\n+  bar (i);\n+  va_end (gap);\n+}\n+/* { dg-final { scan-tree-dump \"f2: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f2: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f2: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f2: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f2: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */\n+\n+/* tree-stdarg.c only handles va_list variables, not arrays of them or\n+   va_list fields embedded in structures.  */\n+void\n+f3 (int i, ...)\n+{\n+  va_list aps[10];\n+  va_start (aps[4], i);\n+  x = va_arg (aps[4], long);\n+  va_end (aps[4]);\n+}\n+/* { dg-final { scan-tree-dump \"f3: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f3: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f3: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f3: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f3: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */\n+\n+void\n+f4 (int i, ...)\n+{\n+  va_list aps[10];\n+  va_start (aps[4], i);\n+  bar (i);\n+  va_end (aps[4]);\n+}\n+/* { dg-final { scan-tree-dump \"f4: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f4: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f4: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f4: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f4: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */\n+\n+void\n+f5 (int i, ...)\n+{\n+  va_list aps[10];\n+  va_start (aps[4], i);\n+  foo (i, aps[4]);\n+  va_end (aps[4]);\n+}\n+/* { dg-final { scan-tree-dump \"f5: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f5: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f5: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f5: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f5: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */\n+\n+struct A { int i; va_list g; va_list h[2]; };\n+\n+void\n+f6 (int i, ...)\n+{\n+  struct A a;\n+  va_start (a.g, i);\n+  x = va_arg (a.g, long);\n+  va_end (a.g);\n+}\n+/* { dg-final { scan-tree-dump \"f6: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f6: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f6: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f6: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f6: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */\n+\n+void\n+f7 (int i, ...)\n+{\n+  struct A a;\n+  va_start (a.g, i);\n+  bar (i);\n+  va_end (a.g);\n+}\n+/* { dg-final { scan-tree-dump \"f7: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f7: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f7: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f7: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f7: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */\n+\n+void\n+f8 (int i, ...)\n+{\n+  struct A a;\n+  va_start (a.g, i);\n+  foo (i, a.g);\n+  va_end (a.g);\n+}\n+/* { dg-final { scan-tree-dump \"f8: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f8: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f8: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f8: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f8: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */\n+\n+void\n+f10 (int i, ...)\n+{\n+  struct A a;\n+  va_start (a.h[1], i);\n+  x = va_arg (a.h[1], long);\n+  va_end (a.h[1]);\n+}\n+/* { dg-final { scan-tree-dump \"f10: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f10: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f10: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f10: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f10: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */\n+\n+void\n+f11 (int i, ...)\n+{\n+  struct A a;\n+  va_start (a.h[1], i);\n+  bar (i);\n+  va_end (a.h[1]);\n+}\n+/* { dg-final { scan-tree-dump \"f11: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f11: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f11: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f11: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f11: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */\n+\n+void\n+f12 (int i, ...)\n+{\n+  struct A a;\n+  va_start (a.h[1], i);\n+  foo (i, a.h[1]);\n+  va_end (a.h[1]);\n+}\n+/* { dg-final { scan-tree-dump \"f12: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f12: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f12: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f12: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f12: va_list escapes 1, needs to save all GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */"}, {"sha": "51b50140bdd8c745d4e884f8f3434ff9a7f87099", "filename": "gcc/testsuite/gcc.dg/tree-ssa/stdarg-4.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-4.c?ref=9d30f3c190d89f886600bd4ccfe33d62d78adc51", "patch": "@@ -0,0 +1,85 @@\n+/* First dg-final line after each function is for architectures that use\n+   a struct {...} va_list[1] with separate GPR and FPR counters in the\n+   structure.  Second dg-final line is for architectures that use void *\n+   or char * va_list.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-stdarg\" } */\n+\n+#include <stdarg.h>\n+\n+extern void foo (int, va_list);\n+extern void bar (int);\n+long x;\n+double d;\n+\n+/* Here va_arg can be executed more than once for one va_start.  All GPR\n+   registers needs to be saved.  */\n+void\n+f1 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  while (i-- > 0)\n+    x = va_arg (ap, long);\n+  va_end (ap);\n+}\n+/* { dg-final { scan-tree-dump \"f1: va_list escapes 0, needs to save all GPR units and 0 FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f1: va_list escapes 0, needs to save all GPR units and 0 FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f1: va_list escapes 0, needs to save all GPR units and 1\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f1: va_list escapes \\[01\\], needs to save all GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f1: va_list escapes \\[01\\], needs to save all GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */\n+\n+void\n+f2 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  while (i-- > 0)\n+    d = va_arg (ap, double);\n+  va_end (ap);\n+}\n+/* { dg-final { scan-tree-dump \"f2: va_list escapes 0, needs to save 0 GPR units and all FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f2: va_list escapes 0, needs to save 0 GPR units and all FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f2: va_list escapes 0, needs to save all GPR units and 2\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f2: va_list escapes \\[01\\], needs to save all GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f2: va_list escapes \\[01\\], needs to save all GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */\n+\n+/* Here va_arg can be executed at most as many times as va_start.\n+   Only one GPR needs to be saved.  */\n+void\n+f3 (int i, ...)\n+{\n+  va_list ap;\n+  int j = i;\n+  while (j-- > 0)\n+    {\n+      va_start (ap, i);\n+      x = va_arg (ap, long);\n+      va_end (ap);\n+      bar (x);\n+    }\n+}\n+/* { dg-final { scan-tree-dump \"f3: va_list escapes 0, needs to save \\[148\\] GPR units and 0 FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f3: va_list escapes 0, needs to save \\[148\\] GPR units and 0 FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f3: va_list escapes 0, needs to save 8 GPR units and 1\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f3: va_list escapes 0, needs to save \\[148\\] GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f3: va_list escapes 0, needs to save \\[148\\] GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */\n+\n+void\n+f4 (int i, ...)\n+{\n+  va_list ap;\n+  int j = i;\n+  while (j-- > 0)\n+    {\n+      va_start (ap, i);\n+      d = va_arg (ap, double);\n+      va_end (ap);\n+      bar (d + 2.5);\n+    }\n+}\n+/* { dg-final { scan-tree-dump \"f4: va_list escapes 0, needs to save 0 GPR units and \\[1-9\\]\\[0-9\\]* FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f4: va_list escapes 0, needs to save 0 GPR units and \\[1-9\\]\\[0-9\\]* FPR units\" \"stdarg\" { target { powerpc*-*-linux* && ilp32 } } } } */\n+/* { dg-final { scan-tree-dump \"f4: va_list escapes 0, needs to save 8 GPR units and 2\" \"stdarg\" { target alpha*-*-linux* } } } */\n+/* { dg-final { scan-tree-dump \"f4: va_list escapes 0, needs to save \\[148\\] GPR units\" \"stdarg\" { target i?86-*-* ia64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f4: va_list escapes 0, needs to save \\[148\\] GPR units\" \"stdarg\" { target { powerpc*-*-* && lp64 } } } } */"}, {"sha": "e219ca80bc91219c449eccdc402ac626af5d5a08", "filename": "gcc/testsuite/gcc.dg/tree-ssa/stdarg-5.c", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-5.c?ref=9d30f3c190d89f886600bd4ccfe33d62d78adc51", "patch": "@@ -0,0 +1,111 @@\n+/* This test has architecture specific function passing details.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-stdarg\" } */\n+\n+#include <stdarg.h>\n+\n+extern void foo (int, va_list);\n+extern void bar (int);\n+struct S1 { int i; double d; int j; double e; } s1;\n+struct S2 { double d; long i; } s2;\n+int y;\n+_Complex int ci;\n+_Complex double cd;\n+\n+/* Here va_arg can be executed more than once for one va_start.  */\n+void\n+f1 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  while (i-- > 0)\n+    s1 = va_arg (ap, struct S1);\n+  va_end (ap);\n+}\n+/* { dg-final { scan-tree-dump \"f1: va_list escapes 0, needs to save 0 GPR units and 0 FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f1: va_list escapes 0, needs to save all GPR units and 1\" \"stdarg\" { target alpha*-*-linux* } } } */\n+\n+void\n+f2 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  while (i-- > 0)\n+    s2 = va_arg (ap, struct S2);\n+  va_end (ap);\n+}\n+/* { dg-final { scan-tree-dump \"f2: va_list escapes 0, needs to save all GPR units and all FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f2: va_list escapes 0, needs to save all GPR units and 1\" \"stdarg\" { target alpha*-*-linux* } } } */\n+\n+/* Here va_arg can be executed at most as many times as va_start.  */\n+void\n+f3 (int i, ...)\n+{\n+  va_list ap;\n+  int j = i;\n+  while (j-- > 0)\n+    {\n+      va_start (ap, i);\n+      s1 = va_arg (ap, struct S1);\n+      va_end (ap);\n+      bar (s1.i);\n+    }\n+}\n+/* { dg-final { scan-tree-dump \"f3: va_list escapes 0, needs to save 0 GPR units and 0 FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f3: va_list escapes 0, needs to save 32 GPR units and 1\" \"stdarg\" { target alpha*-*-linux* } } } */\n+\n+void\n+f4 (int i, ...)\n+{\n+  va_list ap;\n+  int j = i;\n+  while (j-- > 0)\n+    {\n+      va_start (ap, i);\n+      s2 = va_arg (ap, struct S2);\n+      y = va_arg (ap, int);\n+      va_end (ap);\n+      bar (s2.i);\n+    }\n+}\n+/* { dg-final { scan-tree-dump \"f4: va_list escapes 0, needs to save 16 GPR units and 16 FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f4: va_list escapes 0, needs to save 24 GPR units and 1\" \"stdarg\" { target alpha*-*-linux* } } } */\n+\n+void\n+f5 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  ci = va_arg (ap, _Complex int);\n+  ci += va_arg (ap, _Complex int);\n+  va_end (ap);\n+  bar (__real__ ci + __imag__ ci);\n+}\n+/* { dg-final { scan-tree-dump \"f5: va_list escapes 0, needs to save 16 GPR units and 0 FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f5: va_list escapes 0, needs to save 32 GPR units and 1\" \"stdarg\" { target alpha*-*-linux* } } } */\n+\n+void\n+f6 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  ci = va_arg (ap, _Complex int);\n+  cd = va_arg (ap, _Complex double);\n+  va_end (ap);\n+  bar (__real__ ci + __imag__ cd);\n+}\n+/* { dg-final { scan-tree-dump \"f6: va_list escapes 0, needs to save 8 GPR units and 32 FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f6: va_list escapes 0, needs to save 32 GPR units and 3\" \"stdarg\" { target alpha*-*-linux* } } } */\n+\n+void\n+f7 (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  cd = va_arg (ap, _Complex double);\n+  cd += va_arg (ap, _Complex double);\n+  va_end (ap);\n+  bar (__real__ cd + __imag__ cd);\n+}\n+/* { dg-final { scan-tree-dump \"f7: va_list escapes 0, needs to save 0 GPR units and 64 FPR units\" \"stdarg\" { target { x86_64-*-* && lp64 } } } } */\n+/* { dg-final { scan-tree-dump \"f7: va_list escapes 0, needs to save 32 GPR units and 2\" \"stdarg\" { target alpha*-*-linux* } } } */"}, {"sha": "596137464835fbeafcf7c22fc202a206e1f868d9", "filename": "gcc/testsuite/gcc.dg/vmx/varargs-1.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2Fvarargs-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2Fvarargs-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2Fvarargs-1.c?ref=9d30f3c190d89f886600bd4ccfe33d62d78adc51", "patch": "@@ -25,6 +25,7 @@ void f1(int a, ...)\n   va_start (ap, a);\n   while (a-- > 0)\n     printx(va_arg(ap, T));\n+  va_end (ap);\n }\n \n void f2(int a, T b, ...)\n@@ -35,6 +36,7 @@ void f2(int a, T b, ...)\n   va_start (ap, b);\n   while (a-- > 0)\n     printx(va_arg(ap, T));\n+  va_end (ap);\n }\n \n void f3(int a, T b, T c, ...)\n@@ -47,6 +49,7 @@ void f3(int a, T b, T c, ...)\n   va_start (ap, c);\n   while (a-- > 0)\n     printx(va_arg(ap, T));\n+  va_end (ap);\n }\n \n void f4(int a, T b, T c,"}, {"sha": "48842290a46a68cba3a39ec89edd5155f5e48be5", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=9d30f3c190d89f886600bd4ccfe33d62d78adc51", "patch": "@@ -364,6 +364,7 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_tail_recursion);\n   NEXT_PASS (pass_ch);\n   NEXT_PASS (pass_profile);\n+  NEXT_PASS (pass_stdarg);\n   NEXT_PASS (pass_sra);\n   /* FIXME: SRA may generate arbitrary gimple code, exposing new\n      aliased and call-clobbered variables.  As mentioned below,"}, {"sha": "557a3e52d3b0cb8d28bce250f8fd13b19c54c0c1", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=9d30f3c190d89f886600bd4ccfe33d62d78adc51", "patch": "@@ -190,6 +190,7 @@ extern struct tree_opt_pass pass_profile;\n extern struct tree_opt_pass pass_pre_expand;\n extern struct tree_opt_pass pass_lower_vector_ssa;\n extern struct tree_opt_pass pass_fold_builtins;\n+extern struct tree_opt_pass pass_stdarg;\n extern struct tree_opt_pass pass_early_warn_uninitialized;\n extern struct tree_opt_pass pass_late_warn_uninitialized;\n extern struct tree_opt_pass pass_warn_function_return;"}, {"sha": "6d1b4dd473dc88a84f253a6a324fc9e45b77257c", "filename": "gcc/tree-stdarg.c", "status": "added", "additions": 863, "deletions": 0, "changes": 863, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=9d30f3c190d89f886600bd4ccfe33d62d78adc51", "patch": "@@ -0,0 +1,863 @@\n+/* Pass computing data for optimizing stdarg functions.\n+   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+   Contributed by Jakub Jelinek <jakub@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"langhooks.h\"\n+#include \"diagnostic.h\"\n+#include \"target.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-pass.h\"\n+#include \"tree-stdarg.h\"\n+\n+/* A simple pass that attempts to optimize stdarg functions on architectures\n+   that need to save register arguments to stack on entry to stdarg functions.\n+   If the function doesn't use any va_start macros, no registers need to\n+   be saved.  If va_start macros are used, the va_list variables don't escape\n+   the function, it is only necessary to save registers that will be used\n+   in va_arg macros.  E.g. if va_arg is only used with integral types\n+   in the function, floating point registers don't need to be saved, etc.  */\n+\n+\n+/* Return true if basic block VA_ARG_BB is dominated by VA_START_BB and\n+   is executed at most as many times as VA_START_BB.  */\n+\n+static bool\n+reachable_at_most_once (basic_block va_arg_bb, basic_block va_start_bb)\n+{\n+  edge *stack, e;\n+  edge_iterator ei;\n+  int sp;\n+  sbitmap visited;\n+  bool ret;\n+\n+  if (va_arg_bb == va_start_bb)\n+    return true;\n+\n+  if (! dominated_by_p (CDI_DOMINATORS, va_arg_bb, va_start_bb))\n+    return false;\n+\n+  stack = xmalloc ((n_basic_blocks + 1) * sizeof (edge));\n+  sp = 0;\n+\n+  visited = sbitmap_alloc (last_basic_block);\n+  sbitmap_zero (visited);\n+  ret = true;\n+\n+  FOR_EACH_EDGE (e, ei, va_arg_bb->preds)\n+    stack[sp++] = e;\n+\n+  while (sp)\n+    {\n+      basic_block src;\n+\n+      --sp;\n+      e = stack[sp];\n+      src = e->src;\n+\n+      if (e->flags & EDGE_COMPLEX)\n+\t{\n+\t  ret = false;\n+\t  break;\n+\t}\n+\n+      if (src == va_start_bb)\n+\tcontinue;\n+\n+      /* va_arg_bb can be executed more times than va_start_bb.  */\n+      if (src == va_arg_bb)\n+\t{\n+\t  ret = false;\n+\t  break;\n+\t}\n+\n+      gcc_assert (src != ENTRY_BLOCK_PTR);\n+\n+      if (! TEST_BIT (visited, src->index))\n+\t{\n+\t  SET_BIT (visited, src->index);\n+\t  FOR_EACH_EDGE (e, ei, src->preds)\n+\t    stack[sp++] = e;\n+\t}\n+    }\n+\n+  free (stack);\n+  sbitmap_free (visited);\n+  return ret;\n+}\n+\n+\n+/* For statement COUNTER = RHS, if RHS is COUNTER + constant,\n+   return constant, otherwise return (unsigned HOST_WIDE_INT) -1.\n+   GPR_P is true if this is GPR counter.  */\n+\n+static unsigned HOST_WIDE_INT\n+va_list_counter_bump (struct stdarg_info *si, tree counter, tree rhs,\n+\t\t      bool gpr_p)\n+{\n+  tree stmt, lhs, orig_lhs;\n+  unsigned HOST_WIDE_INT ret = 0, val, counter_val;\n+  unsigned int max_size;\n+\n+  if (si->offsets == NULL)\n+    {\n+      unsigned int i;\n+\n+      si->offsets = xmalloc (num_ssa_names * sizeof (int));\n+      for (i = 0; i < num_ssa_names; ++i)\n+\tsi->offsets[i] = -1;\n+    }\n+\n+  counter_val = gpr_p ? cfun->va_list_gpr_size : cfun->va_list_fpr_size;\n+  max_size = gpr_p ? VA_LIST_MAX_GPR_SIZE : VA_LIST_MAX_FPR_SIZE;\n+  orig_lhs = lhs = rhs;\n+  while (lhs)\n+    {\n+      if (si->offsets[SSA_NAME_VERSION (lhs)] != -1)\n+\t{\n+\t  if (counter_val >= max_size)\n+\t    {\n+\t      ret = max_size;\n+\t      break;\n+\t    }\n+\n+\t  ret -= counter_val - si->offsets[SSA_NAME_VERSION (lhs)];\n+\t  break;\n+\t}\n+\n+      stmt = SSA_NAME_DEF_STMT (lhs);\n+\n+      if (TREE_CODE (stmt) != MODIFY_EXPR\n+\t  || TREE_OPERAND (stmt, 0) != lhs)\n+\treturn (unsigned HOST_WIDE_INT) -1;\n+\n+      rhs = TREE_OPERAND (stmt, 1);\n+      if (TREE_CODE (rhs) == WITH_SIZE_EXPR)\n+\trhs = TREE_OPERAND (rhs, 0);\n+\n+      if (TREE_CODE (rhs) == SSA_NAME)\n+\t{\n+\t  lhs = rhs;\n+\t  continue;\n+\t}\n+\n+      if ((TREE_CODE (rhs) == NOP_EXPR\n+\t   || TREE_CODE (rhs) == CONVERT_EXPR)\n+\t  && TREE_CODE (TREE_OPERAND (rhs, 0)) == SSA_NAME)\n+\t{\n+\t  lhs = TREE_OPERAND (rhs, 0);\n+\t  continue;\n+\t}\n+\n+      if (TREE_CODE (rhs) == PLUS_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (rhs, 0)) == SSA_NAME\n+\t  && TREE_CODE (TREE_OPERAND (rhs, 1)) == INTEGER_CST\n+\t  && host_integerp (TREE_OPERAND (rhs, 1), 1))\n+\t{\n+\t  ret += tree_low_cst (TREE_OPERAND (rhs, 1), 1);\n+\t  lhs = TREE_OPERAND (rhs, 0);\n+\t  continue;\n+\t}\n+\n+      if (TREE_CODE (counter) != TREE_CODE (rhs))\n+\treturn (unsigned HOST_WIDE_INT) -1;\n+\n+      if (TREE_CODE (counter) == COMPONENT_REF)\n+\t{\n+\t  if (get_base_address (counter) != get_base_address (rhs)\n+\t      || TREE_CODE (TREE_OPERAND (rhs, 1)) != FIELD_DECL\n+\t      || TREE_OPERAND (counter, 1) != TREE_OPERAND (rhs, 1))\n+\t    return (unsigned HOST_WIDE_INT) -1;\n+\t}\n+      else if (counter != rhs)\n+\treturn (unsigned HOST_WIDE_INT) -1;\n+\n+      lhs = NULL;\n+    }\n+\n+  lhs = orig_lhs;\n+  val = ret + counter_val;\n+  while (lhs)\n+    {\n+      if (si->offsets[SSA_NAME_VERSION (lhs)] != -1)\n+\tbreak;\n+\n+      if (val >= max_size)\n+\tsi->offsets[SSA_NAME_VERSION (lhs)] = max_size;\n+      else\n+\tsi->offsets[SSA_NAME_VERSION (lhs)] = val;\n+\n+      stmt = SSA_NAME_DEF_STMT (lhs);\n+\n+      rhs = TREE_OPERAND (stmt, 1);\n+      if (TREE_CODE (rhs) == WITH_SIZE_EXPR)\n+\trhs = TREE_OPERAND (rhs, 0);\n+\n+      if (TREE_CODE (rhs) == SSA_NAME)\n+\t{\n+\t  lhs = rhs;\n+\t  continue;\n+\t}\n+\n+      if ((TREE_CODE (rhs) == NOP_EXPR\n+\t   || TREE_CODE (rhs) == CONVERT_EXPR)\n+\t  && TREE_CODE (TREE_OPERAND (rhs, 0)) == SSA_NAME)\n+\t{\n+\t  lhs = TREE_OPERAND (rhs, 0);\n+\t  continue;\n+\t}\n+\n+      if (TREE_CODE (rhs) == PLUS_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (rhs, 0)) == SSA_NAME\n+\t  && TREE_CODE (TREE_OPERAND (rhs, 1)) == INTEGER_CST\n+\t  && host_integerp (TREE_OPERAND (rhs, 1), 1))\n+\t{\n+\t  val -= tree_low_cst (TREE_OPERAND (rhs, 1), 1);\n+\t  lhs = TREE_OPERAND (rhs, 0);\n+\t  continue;\n+\t}\n+\n+      lhs = NULL;\n+    }\n+\n+  return ret;\n+}\n+\n+\n+/* Called by walk_tree to look for references to va_list variables.  */\n+\n+static tree\n+find_va_list_reference (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t\t\tvoid *data)\n+{\n+  bitmap va_list_vars = (bitmap) data;\n+  tree var = *tp;\n+\n+  if (TREE_CODE (var) == SSA_NAME)\n+    var = SSA_NAME_VAR (var);\n+\n+  if (TREE_CODE (var) == VAR_DECL\n+      && bitmap_bit_p (va_list_vars, var_ann (var)->uid))\n+    return var;\n+\n+  return NULL_TREE;\n+}\n+\n+\n+/* Helper function of va_list_counter_struct_op.  Compute\n+   cfun->va_list_{g,f}pr_size.  AP is a va_list GPR/FPR counter,\n+   if WRITE_P is true, seen in AP = VAR, otherwise seen in VAR = AP\n+   statement.  GPR_P is true if AP is a GPR counter, false if it is\n+   a FPR counter.  */\n+\n+static void\n+va_list_counter_op (struct stdarg_info *si, tree ap, tree var, bool gpr_p,\n+\t\t    bool write_p)\n+{\n+  unsigned HOST_WIDE_INT increment;\n+\n+  if (si->compute_sizes < 0)\n+    {\n+      si->compute_sizes = 0;\n+      if (si->va_start_count == 1\n+\t  && reachable_at_most_once (si->bb, si->va_start_bb))\n+\tsi->compute_sizes = 1;\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"bb%d will %sbe executed at most once for each va_start \"\n+\t\t \"in bb%d\\n\", si->bb->index, si->compute_sizes ? \"\" : \"not \",\n+\t\t si->va_start_bb->index);\n+    }\n+\n+  if (write_p\n+      && si->compute_sizes\n+      && (increment = va_list_counter_bump (si, ap, var, gpr_p)) + 1 > 1)\n+    {\n+      if (gpr_p && cfun->va_list_gpr_size + increment < VA_LIST_MAX_GPR_SIZE)\n+\t{\n+\t  cfun->va_list_gpr_size += increment;\n+\t  return;\n+\t}\n+\n+      if (!gpr_p && cfun->va_list_fpr_size + increment < VA_LIST_MAX_FPR_SIZE)\n+\t{\n+\t  cfun->va_list_fpr_size += increment;\n+\t  return;\n+\t}\n+    }\n+\n+  if (write_p || !si->compute_sizes)\n+    {\n+      if (gpr_p)\n+\tcfun->va_list_gpr_size = VA_LIST_MAX_GPR_SIZE;\n+      else\n+\tcfun->va_list_fpr_size = VA_LIST_MAX_FPR_SIZE;\n+    }\n+}\n+\n+\n+/* If AP is a va_list GPR/FPR counter, compute cfun->va_list_{g,f}pr_size.\n+   If WRITE_P is true, AP has been seen in AP = VAR assignment, if WRITE_P\n+   is false, AP has been seen in VAR = AP assignment.\n+   Return true if the AP = VAR (resp. VAR = AP) statement is a recognized\n+   va_arg operation that doesn't cause the va_list variable to escape\n+   current function.  */\n+\n+static bool\n+va_list_counter_struct_op (struct stdarg_info *si, tree ap, tree var,\n+\t\t\t   bool write_p)\n+{\n+  tree base;\n+\n+  if (TREE_CODE (ap) != COMPONENT_REF\n+      || TREE_CODE (TREE_OPERAND (ap, 1)) != FIELD_DECL)\n+    return false;\n+\n+  if (TREE_CODE (var) != SSA_NAME\n+      || bitmap_bit_p (si->va_list_vars, var_ann (SSA_NAME_VAR (var))->uid))\n+    return false;\n+\n+  base = get_base_address (ap);\n+  if (TREE_CODE (base) != VAR_DECL\n+      || !bitmap_bit_p (si->va_list_vars, var_ann (base)->uid))\n+    return false;\n+\n+  if (TREE_OPERAND (ap, 1) == va_list_gpr_counter_field)\n+    va_list_counter_op (si, ap, var, true, write_p);\n+  else if (TREE_OPERAND (ap, 1) == va_list_fpr_counter_field)\n+    va_list_counter_op (si, ap, var, false, write_p);\n+\n+  return true;\n+}\n+\n+\n+/* Check for TEM = AP.  Return true if found and the caller shouldn't\n+   search for va_list references in the statement.  */\n+\n+static bool\n+va_list_ptr_read (struct stdarg_info *si, tree ap, tree tem)\n+{\n+  if (TREE_CODE (ap) != VAR_DECL\n+      || !bitmap_bit_p (si->va_list_vars, var_ann (ap)->uid))\n+    return false;\n+\n+  if (TREE_CODE (tem) != SSA_NAME\n+      || bitmap_bit_p (si->va_list_vars,\n+\t\t       var_ann (SSA_NAME_VAR (tem))->uid)\n+      || is_global_var (SSA_NAME_VAR (tem)))\n+    return false;\n+\n+  if (si->compute_sizes < 0)\n+    {\n+      si->compute_sizes = 0;\n+      if (si->va_start_count == 1\n+\t  && reachable_at_most_once (si->bb, si->va_start_bb))\n+\tsi->compute_sizes = 1;\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"bb%d will %sbe executed at most once for each va_start \"\n+\t\t \"in bb%d\\n\", si->bb->index, si->compute_sizes ? \"\" : \"not \",\n+\t\t si->va_start_bb->index);\n+    }\n+\n+  /* For void * or char * va_list types, there is just one counter.\n+     If va_arg is used in a loop, we don't know how many registers need\n+     saving.  */\n+  if (! si->compute_sizes)\n+    return false;\n+\n+  if (va_list_counter_bump (si, ap, tem, true) == (unsigned HOST_WIDE_INT) -1)\n+    return false;\n+\n+  /* Note the temporary, as we need to track whether it doesn't escape\n+     the current function.  */\n+  bitmap_set_bit (si->va_list_escape_vars,\n+\t\t  var_ann (SSA_NAME_VAR (tem))->uid);\n+  return true;\n+}\n+\n+\n+/* Check for:\n+     tem1 = AP;\n+     TEM2 = tem1 + CST;\n+     AP = TEM2;\n+   sequence and update cfun->va_list_gpr_size.  Return true if found.  */\n+\n+static bool\n+va_list_ptr_write (struct stdarg_info *si, tree ap, tree tem2)\n+{\n+  unsigned HOST_WIDE_INT increment;\n+\n+  if (TREE_CODE (ap) != VAR_DECL\n+      || !bitmap_bit_p (si->va_list_vars, var_ann (ap)->uid))\n+    return false;\n+\n+  if (TREE_CODE (tem2) != SSA_NAME\n+      || bitmap_bit_p (si->va_list_vars, var_ann (SSA_NAME_VAR (tem2))->uid))\n+    return false;\n+\n+  if (si->compute_sizes <= 0)\n+    return false;\n+\n+  increment = va_list_counter_bump (si, ap, tem2, true);\n+  if (increment + 1 <= 1)\n+    return false;\n+\n+  if (cfun->va_list_gpr_size + increment < VA_LIST_MAX_GPR_SIZE)\n+    cfun->va_list_gpr_size += increment;\n+  else\n+    cfun->va_list_gpr_size = VA_LIST_MAX_GPR_SIZE;\n+\n+  return true;\n+}\n+\n+\n+/* If RHS is X, (some type *) X or X + CST for X a temporary variable\n+   containing value of some va_list variable plus optionally some constant,\n+   either set si->va_list_escapes or add LHS to si->va_list_escape_vars,\n+   depending whether LHS is a function local temporary.  */\n+\n+static void\n+check_va_list_escapes (struct stdarg_info *si, tree lhs, tree rhs)\n+{\n+  if (! POINTER_TYPE_P (TREE_TYPE (rhs)))\n+    return;\n+\n+  if ((TREE_CODE (rhs) == PLUS_EXPR\n+       && TREE_CODE (TREE_OPERAND (rhs, 1)) == INTEGER_CST)\n+      || TREE_CODE (rhs) == NOP_EXPR\n+      || TREE_CODE (rhs) == CONVERT_EXPR)\n+    rhs = TREE_OPERAND (rhs, 0);\n+\n+  if (TREE_CODE (rhs) != SSA_NAME\n+      || ! bitmap_bit_p (si->va_list_escape_vars,\n+\t\t\t var_ann (SSA_NAME_VAR (rhs))->uid))\n+    return;\n+\n+  if (TREE_CODE (lhs) != SSA_NAME || is_global_var (SSA_NAME_VAR (lhs)))\n+    {\n+      si->va_list_escapes = true;\n+      return;\n+    }\n+\n+  if (si->compute_sizes < 0)\n+    {\n+      si->compute_sizes = 0;\n+      if (si->va_start_count == 1\n+\t  && reachable_at_most_once (si->bb, si->va_start_bb))\n+\tsi->compute_sizes = 1;\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"bb%d will %sbe executed at most once for each va_start \"\n+\t\t \"in bb%d\\n\", si->bb->index, si->compute_sizes ? \"\" : \"not \",\n+\t\t si->va_start_bb->index);\n+    }\n+\n+  /* For void * or char * va_list types, there is just one counter.\n+     If va_arg is used in a loop, we don't know how many registers need\n+     saving.  */\n+  if (! si->compute_sizes)\n+    {\n+      si->va_list_escapes = true;\n+      return;\n+    }\n+\n+  if (va_list_counter_bump (si, si->va_start_ap, lhs, true)\n+      == (unsigned HOST_WIDE_INT) -1)\n+    {\n+      si->va_list_escapes = true;\n+      return;\n+    }\n+\n+  bitmap_set_bit (si->va_list_escape_vars,\n+\t\t  var_ann (SSA_NAME_VAR (lhs))->uid);\n+}\n+\n+\n+/* Check all uses of temporaries from si->va_list_escape_vars bitmap.\n+   Return true if va_list might be escaping.  */\n+\n+static bool\n+check_all_va_list_escapes (struct stdarg_info *si)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      block_stmt_iterator i;\n+\n+      for (i = bsi_start (bb); !bsi_end_p (i); bsi_next (&i))\n+\t{\n+\t  tree stmt = bsi_stmt (i), use;\n+\t  ssa_op_iter iter;\n+\n+\t  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_ALL_USES)\n+\t    {\n+\t      if (! bitmap_bit_p (si->va_list_escape_vars,\n+\t\t\t\t  var_ann (SSA_NAME_VAR (use))->uid))\n+\t\tcontinue;\n+\n+\t      if (TREE_CODE (stmt) == MODIFY_EXPR)\n+\t\t{\n+\t\t  tree lhs = TREE_OPERAND (stmt, 0);\n+\t\t  tree rhs = TREE_OPERAND (stmt, 1);\n+\n+\t\t  if (TREE_CODE (rhs) == WITH_SIZE_EXPR)\n+\t\t    rhs = TREE_OPERAND (rhs, 0);\n+\n+\t\t  /* x = *ap_temp;  */\n+\t\t  if (TREE_CODE (rhs) == INDIRECT_REF\n+\t\t      && TREE_OPERAND (rhs, 0) == use\n+\t\t      && TYPE_SIZE_UNIT (TREE_TYPE (rhs))\n+\t\t      && host_integerp (TYPE_SIZE_UNIT (TREE_TYPE (rhs)), 1)\n+\t\t      && si->offsets[SSA_NAME_VERSION (use)] != -1)\n+\t\t    {\n+\t\t      unsigned HOST_WIDE_INT gpr_size;\n+\t\t      tree access_size = TYPE_SIZE_UNIT (TREE_TYPE (rhs));\n+\n+\t\t      gpr_size = si->offsets[SSA_NAME_VERSION (use)]\n+\t\t\t\t + tree_low_cst (access_size, 1);\n+\t\t      if (gpr_size >= VA_LIST_MAX_GPR_SIZE)\n+\t\t\tcfun->va_list_gpr_size = VA_LIST_MAX_GPR_SIZE;\n+\t\t      else if (gpr_size > cfun->va_list_gpr_size)\n+\t\t\tcfun->va_list_gpr_size = gpr_size;\n+\t\t      continue;\n+\t\t    }\n+\n+\t\t  /* va_arg sequences may contain\n+\t\t     other_ap_temp = ap_temp;\n+\t\t     other_ap_temp = ap_temp + constant;\n+\t\t     other_ap_temp = (some_type *) ap_temp;\n+\t\t     ap = ap_temp;\n+\t\t     statements.  */\n+\t\t  if ((TREE_CODE (rhs) == PLUS_EXPR\n+\t\t       && TREE_CODE (TREE_OPERAND (rhs, 1)) == INTEGER_CST)\n+\t\t      || TREE_CODE (rhs) == NOP_EXPR\n+\t\t      || TREE_CODE (rhs) == CONVERT_EXPR)\n+\t\t    rhs = TREE_OPERAND (rhs, 0);\n+\n+\t\t  if (rhs == use)\n+\t\t    {\n+\t\t      if (TREE_CODE (lhs) == SSA_NAME\n+\t\t\t  && bitmap_bit_p (si->va_list_escape_vars,\n+\t\t\t\t\t   var_ann (SSA_NAME_VAR (lhs))->uid))\n+\t\t\tcontinue;\n+\n+\t\t      if (TREE_CODE (lhs) == VAR_DECL\n+\t\t\t  && bitmap_bit_p (si->va_list_vars,\n+\t\t\t\t\t   var_ann (lhs)->uid))\n+\t\t\tcontinue;\n+\t\t    }\n+\t\t}\n+\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fputs (\"va_list escapes in \", dump_file);\n+\t\t  print_generic_expr (dump_file, stmt, dump_flags);\n+\t\t  fputc ('\\n', dump_file);\n+\t\t}\n+\t      return true;\n+\t    }\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+\n+/* Return true if this optimization pass should be done.\n+   It makes only sense for stdarg functions.  */\n+\n+static bool\n+gate_optimize_stdarg (void)\n+{\n+  /* This optimization is only for stdarg functions.  */\n+  return current_function_stdarg != 0;\n+}\n+\n+\n+/* Entry point to the stdarg optimization pass.  */\n+\n+static void\n+execute_optimize_stdarg (void)\n+{\n+  basic_block bb;\n+  bool va_list_escapes = false;\n+  bool va_list_simple_ptr;\n+  struct stdarg_info si;\n+  const char *funcname = NULL;\n+\n+  cfun->va_list_gpr_size = 0;\n+  cfun->va_list_fpr_size = 0;\n+  memset (&si, 0, sizeof (si));\n+  si.va_list_vars = BITMAP_ALLOC (NULL);\n+  si.va_list_escape_vars = BITMAP_ALLOC (NULL);\n+\n+  if (dump_file)\n+    funcname = lang_hooks.decl_printable_name (current_function_decl, 2);\n+\n+  va_list_simple_ptr = POINTER_TYPE_P (va_list_type_node)\n+\t\t       && (TREE_TYPE (va_list_type_node) == void_type_node\n+\t\t\t   || TREE_TYPE (va_list_type_node) == char_type_node);\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      block_stmt_iterator i;\n+\n+      for (i = bsi_start (bb); !bsi_end_p (i); bsi_next (&i))\n+\t{\n+\t  tree stmt = bsi_stmt (i);\n+\t  tree call = get_call_expr_in (stmt), callee;\n+\t  tree ap;\n+\n+\t  if (!call)\n+\t    continue;\n+\n+\t  callee = get_callee_fndecl (call);\n+\t  if (!callee\n+\t      || DECL_BUILT_IN_CLASS (callee) != BUILT_IN_NORMAL)\n+\t    continue;\n+\n+\t  switch (DECL_FUNCTION_CODE (callee))\n+\t    {\n+\t    case BUILT_IN_VA_START:\n+\t      break;\n+\t      /* If old style builtins are used, don't optimize anything.  */\n+\t    case BUILT_IN_SAVEREGS:\n+\t    case BUILT_IN_STDARG_START:\n+\t    case BUILT_IN_ARGS_INFO:\n+\t    case BUILT_IN_NEXT_ARG:\n+\t      va_list_escapes = true;\n+\t      continue;\n+\t    default:\n+\t      continue;\n+\t    }\n+\n+\t  si.va_start_count++;\n+\t  ap = TREE_VALUE (TREE_OPERAND (call, 1));\n+\t  if (TREE_CODE (ap) != ADDR_EXPR\n+\t      || TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (ap, 0)))\n+\t\t != TYPE_MAIN_VARIANT (va_list_type_node)\n+\t      || TREE_CODE (TREE_OPERAND (ap, 0)) != VAR_DECL)\n+\t    {\n+\t      va_list_escapes = true;\n+\t      break;\n+\t    }\n+\n+\t  ap = TREE_OPERAND (ap, 0);\n+\t  if (is_global_var (ap))\n+\t    {\n+\t      va_list_escapes = true;\n+\t      break;\n+\t    }\n+\n+\t  bitmap_set_bit (si.va_list_vars, var_ann (ap)->uid);\n+\n+\t  /* VA_START_BB and VA_START_AP will be only used if there is just\n+\t     one va_start in the function.  */\n+\t  si.va_start_bb = bb;\n+\t  si.va_start_ap = ap;\n+\t}\n+\n+      if (va_list_escapes)\n+\tbreak;\n+    }\n+\n+  /* If there were no va_start uses in the function, there is no need to\n+     save anything.  */\n+  if (si.va_start_count == 0)\n+    goto finish;\n+\n+  /* If some va_list arguments weren't local, we can't optimize.  */\n+  if (va_list_escapes)\n+    goto finish;\n+\n+  /* For void * or char * va_list, something useful can be done only\n+     if there is just one va_start.  */\n+  if (va_list_simple_ptr && si.va_start_count > 1)\n+    {\n+      va_list_escapes = true;\n+      goto finish;\n+    }\n+\n+  /* For struct * va_list, if the backend didn't tell us what the counter fields\n+     are, there is nothing more we can do.  */\n+  if (!va_list_simple_ptr\n+      && va_list_gpr_counter_field == NULL_TREE\n+      && va_list_fpr_counter_field == NULL_TREE)\n+    {\n+      va_list_escapes = true;\n+      goto finish;\n+    }\n+\n+  /* For void * or char * va_list there is just one counter\n+     (va_list itself).  Use VA_LIST_GPR_SIZE for it.  */\n+  if (va_list_simple_ptr)\n+    cfun->va_list_fpr_size = VA_LIST_MAX_FPR_SIZE;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      block_stmt_iterator i;\n+\n+      si.compute_sizes = -1;\n+      si.bb = bb;\n+      for (i = bsi_start (bb);\n+\t   !bsi_end_p (i) && !va_list_escapes;\n+\t   bsi_next (&i))\n+\t{\n+\t  tree stmt = bsi_stmt (i);\n+\t  tree call;\n+\n+\t  /* Don't look at __builtin_va_{start,end}, they are ok.  */\n+\t  call = get_call_expr_in (stmt);\n+\t  if (call)\n+\t    {\n+\t      tree callee = get_callee_fndecl (call);\n+\n+\t      if (callee\n+\t\t  && DECL_BUILT_IN_CLASS (callee) == BUILT_IN_NORMAL\n+\t\t  && (DECL_FUNCTION_CODE (callee) == BUILT_IN_VA_START\n+\t\t      || DECL_FUNCTION_CODE (callee) == BUILT_IN_VA_END))\n+\t\tcontinue;\n+\t    }\n+\n+\t  if (TREE_CODE (stmt) == MODIFY_EXPR)\n+\t    {\n+\t      tree lhs = TREE_OPERAND (stmt, 0);\n+\t      tree rhs = TREE_OPERAND (stmt, 1);\n+\n+\t      if (TREE_CODE (rhs) == WITH_SIZE_EXPR)\n+\t\trhs = TREE_OPERAND (rhs, 0);\n+\n+\t      if (va_list_simple_ptr)\n+\t\t{\n+\t\t  /* Check for tem = ap.  */\n+\t\t  if (va_list_ptr_read (&si, rhs, lhs))\n+\t\t    continue;\n+\n+\t\t  /* Check for the last insn in:\n+\t\t     tem1 = ap;\n+\t\t     tem2 = tem1 + CST;\n+\t\t     ap = tem2;\n+\t\t     sequence.  */\n+\t\t  else if (va_list_ptr_write (&si, lhs, rhs))\n+\t\t    continue;\n+\n+\t\t  else\n+\t\t    check_va_list_escapes (&si, lhs, rhs);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Check for ap[0].field = temp.  */\n+\t\t  if (va_list_counter_struct_op (&si, lhs, rhs, true))\n+\t\t    continue;\n+\n+\t\t  /* Check for temp = ap[0].field.  */\n+\t\t  else if (va_list_counter_struct_op (&si, rhs, lhs, false))\n+\t\t    continue;\n+\n+\t\t  /* Do any architecture specific checking.  */\n+\t\t  else if (targetm.stdarg_optimize_hook\n+\t\t\t   && (*targetm.stdarg_optimize_hook) (&si, lhs, rhs))\n+\t\t    continue;\n+\t\t}\n+\t    }\n+\n+\t  /* All other uses of va_list are either va_copy (that is not handled\n+\t     in this optimization), taking address of va_list variable or\n+\t     passing va_list to other functions (in that case va_list might\n+\t     escape the function and therefore va_start needs to set it up\n+\t     fully), or some unexpected use of va_list.  None of these should\n+\t     happen in a gimplified VA_ARG_EXPR.  */\n+\t  if (si.va_list_escapes\n+\t      || walk_tree (&stmt, find_va_list_reference,\n+\t\t\t    si.va_list_vars, NULL))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fputs (\"va_list escapes in \", dump_file);\n+\t\t  print_generic_expr (dump_file, stmt, dump_flags);\n+\t\t  fputc ('\\n', dump_file);\n+\t\t}\n+\t      va_list_escapes = true;\n+\t    }\n+\t}\n+\n+      if (va_list_escapes)\n+\tbreak;\n+    }\n+\n+  if (! va_list_escapes\n+      && va_list_simple_ptr\n+      && ! bitmap_empty_p (si.va_list_escape_vars)\n+      && check_all_va_list_escapes (&si))\n+    va_list_escapes = true;\n+\n+finish:\n+  if (va_list_escapes)\n+    {\n+      cfun->va_list_gpr_size = VA_LIST_MAX_GPR_SIZE;\n+      cfun->va_list_fpr_size = VA_LIST_MAX_FPR_SIZE;\n+    }\n+  BITMAP_FREE (si.va_list_vars);\n+  BITMAP_FREE (si.va_list_escape_vars);\n+  free (si.offsets);\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"%s: va_list escapes %d, needs to save \",\n+\t       funcname, (int) va_list_escapes);\n+      if (cfun->va_list_gpr_size >= VA_LIST_MAX_GPR_SIZE)\n+\tfputs (\"all\", dump_file);\n+      else\n+\tfprintf (dump_file, \"%d\", cfun->va_list_gpr_size);\n+      fputs (\" GPR units and \", dump_file);\n+      if (cfun->va_list_fpr_size >= VA_LIST_MAX_FPR_SIZE)\n+\tfputs (\"all\", dump_file);\n+      else\n+\tfprintf (dump_file, \"%d\", cfun->va_list_fpr_size);\n+      fputs (\" FPR units.\\n\", dump_file);\n+    }\n+}\n+\n+\n+struct tree_opt_pass pass_stdarg =\n+{\n+  \"stdarg\",\t\t\t\t/* name */\n+  gate_optimize_stdarg,\t\t\t/* gate */\n+  execute_optimize_stdarg,\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  0,\t\t\t\t\t/* tv_id */\n+  PROP_cfg | PROP_ssa | PROP_alias,\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func,\t\t\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};"}, {"sha": "100737a79fbf466714c827ef35696bb22e3119a9", "filename": "gcc/tree-stdarg.h", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftree-stdarg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftree-stdarg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.h?ref=9d30f3c190d89f886600bd4ccfe33d62d78adc51", "patch": "@@ -0,0 +1,37 @@\n+/* Header for a pass computing data for optimizing stdarg functions.\n+   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+   Contributed by Jakub Jelinek <jakub@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#ifndef GCC_TREE_STDARG_H\n+#define GCC_TREE_STDARG_H 1\n+\n+struct stdarg_info\n+{\n+  bitmap va_list_vars, va_list_escape_vars;\n+  basic_block bb;\n+  int compute_sizes, va_start_count;\n+  bool va_list_escapes;\n+  int *offsets;\n+  /* These 2 fields are only meaningful if va_start_count == 1.  */\n+  basic_block va_start_bb;\n+  tree va_start_ap;\n+};\n+\n+#endif"}, {"sha": "9c1fd6c2df7f75ed2f709bb135c418d9f557ca1c", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d30f3c190d89f886600bd4ccfe33d62d78adc51/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=9d30f3c190d89f886600bd4ccfe33d62d78adc51", "patch": "@@ -2612,6 +2612,8 @@ enum tree_index\n   TI_PID_TYPE,\n   TI_PTRDIFF_TYPE,\n   TI_VA_LIST_TYPE,\n+  TI_VA_LIST_GPR_COUNTER_FIELD,\n+  TI_VA_LIST_FPR_COUNTER_FIELD,\n   TI_BOOLEAN_TYPE,\n   TI_FILEPTR_TYPE,\n \n@@ -2678,6 +2680,8 @@ extern GTY(()) tree global_trees[TI_MAX];\n #define pid_type_node                   global_trees[TI_PID_TYPE]\n #define ptrdiff_type_node\t\tglobal_trees[TI_PTRDIFF_TYPE]\n #define va_list_type_node\t\tglobal_trees[TI_VA_LIST_TYPE]\n+#define va_list_gpr_counter_field\tglobal_trees[TI_VA_LIST_GPR_COUNTER_FIELD]\n+#define va_list_fpr_counter_field\tglobal_trees[TI_VA_LIST_FPR_COUNTER_FIELD]\n /* The C type `FILE *'.  */\n #define fileptr_type_node\t\tglobal_trees[TI_FILEPTR_TYPE]\n "}]}