{"sha": "04f0546e3e468e67dcd8cd20265796887805de3e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDRmMDU0NmUzZTQ2OGU2N2RjZDhjZDIwMjY1Nzk2ODg3ODA1ZGUzZQ==", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@gcc.gnu.org", "date": "2020-06-12T06:14:40Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2020-06-12T07:18:20Z"}, "message": "vect: Factor out and rename some functions/macros\n\nPower supports vector memory access with length (in bytes) instructions.\nLike existing fully masking for SVE, it is another approach to vectorize\nthe loop using partially-populated vectors.\n\nAs Richard Sandiford suggested, we should share the codes in approaches\nwith partial vectors if possible.  This patch is to:\n  1) factor out two functions:\n     - vect_min_prec_for_max_niters\n     - vect_known_niters_smaller_than_vf.\n  2) rename four functions:\n     - vect_iv_limit_for_full_masking\n     - check_load_store_masking\n     - vect_set_loop_condition_masked\n     - vect_set_loop_condition_unmasked\n  3) rename macros LOOP_VINFO_MASK_COMPARE_TYPE and LOOP_VINFO_MASK_IV_TYPE.\n\nBootstrapped/regtested on aarch64-linux-gnu.\n\ngcc/ChangeLog:\n\n\t* tree-vect-loop-manip.c (vect_set_loop_controls_directly): Rename\n\tLOOP_VINFO_MASK_COMPARE_TYPE to LOOP_VINFO_RGROUP_COMPARE_TYPE.  Rename\n\tLOOP_VINFO_MASK_IV_TYPE to LOOP_VINFO_RGROUP_IV_TYPE.\n\t(vect_set_loop_condition_masked): Renamed to ...\n\t(vect_set_loop_condition_partial_vectors): ... this.  Rename\n\tLOOP_VINFO_MASK_COMPARE_TYPE to LOOP_VINFO_RGROUP_COMPARE_TYPE.  Rename\n\tvect_iv_limit_for_full_masking to vect_iv_limit_for_partial_vectors.\n\t(vect_set_loop_condition_unmasked): Renamed to ...\n\t(vect_set_loop_condition_normal): ... this.\n\t(vect_set_loop_condition): Rename vect_set_loop_condition_unmasked to\n\tvect_set_loop_condition_normal.  Rename vect_set_loop_condition_masked\n\tto vect_set_loop_condition_partial_vectors.\n\t(vect_prepare_for_masked_peels): Rename LOOP_VINFO_MASK_COMPARE_TYPE\n\tto LOOP_VINFO_RGROUP_COMPARE_TYPE.\n\t* tree-vect-loop.c (vect_known_niters_smaller_than_vf): New, factored\n\tout from ...\n\t(vect_analyze_loop_costing): ... this.\n\t(_loop_vec_info::_loop_vec_info): Rename mask_compare_type to\n\tcompare_type.\n\t(vect_min_prec_for_max_niters): New, factored out from ...\n\t(vect_verify_full_masking): ... this.  Rename\n\tvect_iv_limit_for_full_masking to vect_iv_limit_for_partial_vectors.\n\tRename LOOP_VINFO_MASK_COMPARE_TYPE to LOOP_VINFO_RGROUP_COMPARE_TYPE.\n\tRename LOOP_VINFO_MASK_IV_TYPE to LOOP_VINFO_RGROUP_IV_TYPE.\n\t(vectorizable_reduction): Update some dumpings with partial\n\tvectors instead of fully-masked.\n\t(vectorizable_live_operation): Likewise.\n\t(vect_iv_limit_for_full_masking): Renamed to ...\n\t(vect_iv_limit_for_partial_vectors): ... this.\n\t* tree-vect-stmts.c (check_load_store_masking): Renamed to ...\n\t(check_load_store_for_partial_vectors): ... this.  Update some\n\tdumpings with partial vectors instead of fully-masked.\n\t(vectorizable_store): Rename check_load_store_masking to\n\tcheck_load_store_for_partial_vectors.\n\t(vectorizable_load): Likewise.\n\t* tree-vectorizer.h (LOOP_VINFO_MASK_COMPARE_TYPE): Renamed to ...\n\t(LOOP_VINFO_RGROUP_COMPARE_TYPE): ... this.\n\t(LOOP_VINFO_MASK_IV_TYPE): Renamed to ...\n\t(LOOP_VINFO_RGROUP_IV_TYPE): ... this.\n\t(vect_iv_limit_for_full_masking): Renamed to ...\n\t(vect_iv_limit_for_partial_vectors): this.\n\t(_loop_vec_info): Rename mask_compare_type to rgroup_compare_type.\n\tRename iv_type to rgroup_iv_type.", "tree": {"sha": "6545e2205e4a7f87d8eb992bb09ab582918d484d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6545e2205e4a7f87d8eb992bb09ab582918d484d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04f0546e3e468e67dcd8cd20265796887805de3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04f0546e3e468e67dcd8cd20265796887805de3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04f0546e3e468e67dcd8cd20265796887805de3e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04f0546e3e468e67dcd8cd20265796887805de3e/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a179232a743b2b1987b21034cd5bb3bc660ee85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a179232a743b2b1987b21034cd5bb3bc660ee85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a179232a743b2b1987b21034cd5bb3bc660ee85"}], "stats": {"total": 221, "additions": 128, "deletions": 93}, "files": [{"sha": "458a6675c4705f2f34295c232998a27f487c68b2", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f0546e3e468e67dcd8cd20265796887805de3e/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f0546e3e468e67dcd8cd20265796887805de3e/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=04f0546e3e468e67dcd8cd20265796887805de3e", "patch": "@@ -420,8 +420,8 @@ vect_set_loop_controls_directly (class loop *loop, loop_vec_info loop_vinfo,\n \t\t\t\t rgroup_controls *rgc, tree niters,\n \t\t\t\t tree niters_skip, bool might_wrap_p)\n {\n-  tree compare_type = LOOP_VINFO_MASK_COMPARE_TYPE (loop_vinfo);\n-  tree iv_type = LOOP_VINFO_MASK_IV_TYPE (loop_vinfo);\n+  tree compare_type = LOOP_VINFO_RGROUP_COMPARE_TYPE (loop_vinfo);\n+  tree iv_type = LOOP_VINFO_RGROUP_IV_TYPE (loop_vinfo);\n   tree ctrl_type = rgc->type;\n   unsigned int nscalars_per_iter = rgc->max_nscalars_per_iter;\n   poly_uint64 nscalars_per_ctrl = TYPE_VECTOR_SUBPARTS (ctrl_type);\n@@ -644,15 +644,15 @@ vect_set_loop_controls_directly (class loop *loop, loop_vec_info loop_vinfo,\n    final gcond.  */\n \n static gcond *\n-vect_set_loop_condition_masked (class loop *loop, loop_vec_info loop_vinfo,\n-\t\t\t\ttree niters, tree final_iv,\n-\t\t\t\tbool niters_maybe_zero,\n-\t\t\t\tgimple_stmt_iterator loop_cond_gsi)\n+vect_set_loop_condition_partial_vectors (class loop *loop,\n+\t\t\t\t\t loop_vec_info loop_vinfo, tree niters,\n+\t\t\t\t\t tree final_iv, bool niters_maybe_zero,\n+\t\t\t\t\t gimple_stmt_iterator loop_cond_gsi)\n {\n   gimple_seq preheader_seq = NULL;\n   gimple_seq header_seq = NULL;\n \n-  tree compare_type = LOOP_VINFO_MASK_COMPARE_TYPE (loop_vinfo);\n+  tree compare_type = LOOP_VINFO_RGROUP_COMPARE_TYPE (loop_vinfo);\n   unsigned int compare_precision = TYPE_PRECISION (compare_type);\n   tree orig_niters = niters;\n \n@@ -678,7 +678,7 @@ vect_set_loop_condition_masked (class loop *loop, loop_vec_info loop_vinfo,\n   else\n     niters = gimple_convert (&preheader_seq, compare_type, niters);\n \n-  widest_int iv_limit = vect_iv_limit_for_full_masking (loop_vinfo);\n+  widest_int iv_limit = vect_iv_limit_for_partial_vectors (loop_vinfo);\n \n   /* Iterate over all the rgroups and fill in their controls.  We could use\n      the first control from any rgroup for the loop condition; here we\n@@ -748,14 +748,13 @@ vect_set_loop_condition_masked (class loop *loop, loop_vec_info loop_vinfo,\n   return cond_stmt;\n }\n \n-/* Like vect_set_loop_condition, but handle the case in which there\n-   are no loop masks.  */\n+/* Like vect_set_loop_condition, but handle the case in which the vector\n+   loop handles exactly VF scalars per iteration.  */\n \n static gcond *\n-vect_set_loop_condition_unmasked (class loop *loop, tree niters,\n-\t\t\t\t  tree step, tree final_iv,\n-\t\t\t\t  bool niters_maybe_zero,\n-\t\t\t\t  gimple_stmt_iterator loop_cond_gsi)\n+vect_set_loop_condition_normal (class loop *loop, tree niters, tree step,\n+\t\t\t\ttree final_iv, bool niters_maybe_zero,\n+\t\t\t\tgimple_stmt_iterator loop_cond_gsi)\n {\n   tree indx_before_incr, indx_after_incr;\n   gcond *cond_stmt;\n@@ -914,13 +913,14 @@ vect_set_loop_condition (class loop *loop, loop_vec_info loop_vinfo,\n   gimple_stmt_iterator loop_cond_gsi = gsi_for_stmt (orig_cond);\n \n   if (loop_vinfo && LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo))\n-    cond_stmt = vect_set_loop_condition_masked (loop, loop_vinfo, niters,\n-\t\t\t\t\t\tfinal_iv, niters_maybe_zero,\n-\t\t\t\t\t\tloop_cond_gsi);\n+    cond_stmt = vect_set_loop_condition_partial_vectors (loop, loop_vinfo,\n+\t\t\t\t\t\t\t niters, final_iv,\n+\t\t\t\t\t\t\t niters_maybe_zero,\n+\t\t\t\t\t\t\t loop_cond_gsi);\n   else\n-    cond_stmt = vect_set_loop_condition_unmasked (loop, niters, step,\n-\t\t\t\t\t\t  final_iv, niters_maybe_zero,\n-\t\t\t\t\t\t  loop_cond_gsi);\n+    cond_stmt = vect_set_loop_condition_normal (loop, niters, step, final_iv,\n+\t\t\t\t\t\tniters_maybe_zero,\n+\t\t\t\t\t\tloop_cond_gsi);\n \n   /* Remove old loop exit test.  */\n   stmt_vec_info orig_cond_info;\n@@ -1775,7 +1775,7 @@ void\n vect_prepare_for_masked_peels (loop_vec_info loop_vinfo)\n {\n   tree misalign_in_elems;\n-  tree type = LOOP_VINFO_MASK_COMPARE_TYPE (loop_vinfo);\n+  tree type = LOOP_VINFO_RGROUP_COMPARE_TYPE (loop_vinfo);\n \n   gcc_assert (vect_use_loop_mask_for_alignment_p (loop_vinfo));\n "}, {"sha": "6311e795204a6c143177021ee10c10694ebcb6f5", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 72, "deletions": 44, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f0546e3e468e67dcd8cd20265796887805de3e/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f0546e3e468e67dcd8cd20265796887805de3e/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=04f0546e3e468e67dcd8cd20265796887805de3e", "patch": "@@ -802,7 +802,7 @@ _loop_vec_info::_loop_vec_info (class loop *loop_in, vec_info_shared *shared)\n     vectorization_factor (0),\n     max_vectorization_factor (0),\n     mask_skip_niters (NULL_TREE),\n-    mask_compare_type (NULL_TREE),\n+    rgroup_compare_type (NULL_TREE),\n     simd_if_cond (NULL_TREE),\n     unaligned_dr (NULL),\n     peeling_for_alignment (0),\n@@ -963,14 +963,39 @@ vect_get_max_nscalars_per_iter (loop_vec_info loop_vinfo)\n   return res;\n }\n \n+/* Calculate the minimum precision necessary to represent:\n+\n+      MAX_NITERS * FACTOR\n+\n+   as an unsigned integer, where MAX_NITERS is the maximum number of\n+   loop header iterations for the original scalar form of LOOP_VINFO.  */\n+\n+static unsigned\n+vect_min_prec_for_max_niters (loop_vec_info loop_vinfo, unsigned int factor)\n+{\n+  class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+\n+  /* Get the maximum number of iterations that is representable\n+     in the counter type.  */\n+  tree ni_type = TREE_TYPE (LOOP_VINFO_NITERSM1 (loop_vinfo));\n+  widest_int max_ni = wi::to_widest (TYPE_MAX_VALUE (ni_type)) + 1;\n+\n+  /* Get a more refined estimate for the number of iterations.  */\n+  widest_int max_back_edges;\n+  if (max_loop_iterations (loop, &max_back_edges))\n+    max_ni = wi::smin (max_ni, max_back_edges + 1);\n+\n+  /* Work out how many bits we need to represent the limit.  */\n+  return wi::min_precision (max_ni * factor, UNSIGNED);\n+}\n+\n /* Each statement in LOOP_VINFO can be masked where necessary.  Check\n    whether we can actually generate the masks required.  Return true if so,\n-   storing the type of the scalar IV in LOOP_VINFO_MASK_COMPARE_TYPE.  */\n+   storing the type of the scalar IV in LOOP_VINFO_RGROUP_COMPARE_TYPE.  */\n \n static bool\n vect_verify_full_masking (loop_vec_info loop_vinfo)\n {\n-  class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   unsigned int min_ni_width;\n   unsigned int max_nscalars_per_iter\n     = vect_get_max_nscalars_per_iter (loop_vinfo);\n@@ -981,27 +1006,15 @@ vect_verify_full_masking (loop_vec_info loop_vinfo)\n   if (LOOP_VINFO_MASKS (loop_vinfo).is_empty ())\n     return false;\n \n-  /* Get the maximum number of iterations that is representable\n-     in the counter type.  */\n-  tree ni_type = TREE_TYPE (LOOP_VINFO_NITERSM1 (loop_vinfo));\n-  widest_int max_ni = wi::to_widest (TYPE_MAX_VALUE (ni_type)) + 1;\n-\n-  /* Get a more refined estimate for the number of iterations.  */\n-  widest_int max_back_edges;\n-  if (max_loop_iterations (loop, &max_back_edges))\n-    max_ni = wi::smin (max_ni, max_back_edges + 1);\n-\n-  /* Account for rgroup masks, in which each bit is replicated N times.  */\n-  max_ni *= max_nscalars_per_iter;\n-\n   /* Work out how many bits we need to represent the limit.  */\n-  min_ni_width = wi::min_precision (max_ni, UNSIGNED);\n+  min_ni_width\n+    = vect_min_prec_for_max_niters (loop_vinfo, max_nscalars_per_iter);\n \n   /* Find a scalar mode for which WHILE_ULT is supported.  */\n   opt_scalar_int_mode cmp_mode_iter;\n   tree cmp_type = NULL_TREE;\n   tree iv_type = NULL_TREE;\n-  widest_int iv_limit = vect_iv_limit_for_full_masking (loop_vinfo);\n+  widest_int iv_limit = vect_iv_limit_for_partial_vectors (loop_vinfo);\n   unsigned int iv_precision = UINT_MAX;\n \n   if (iv_limit != -1)\n@@ -1054,8 +1067,8 @@ vect_verify_full_masking (loop_vec_info loop_vinfo)\n   if (!cmp_type)\n     return false;\n \n-  LOOP_VINFO_MASK_COMPARE_TYPE (loop_vinfo) = cmp_type;\n-  LOOP_VINFO_MASK_IV_TYPE (loop_vinfo) = iv_type;\n+  LOOP_VINFO_RGROUP_COMPARE_TYPE (loop_vinfo) = cmp_type;\n+  LOOP_VINFO_RGROUP_IV_TYPE (loop_vinfo) = iv_type;\n   return true;\n }\n \n@@ -1624,6 +1637,27 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n   return opt_result::success ();\n }\n \n+/* Return true if we know that the iteration count is smaller than the\n+   vectorization factor.  Return false if it isn't, or if we can't be sure\n+   either way.  */\n+\n+static bool\n+vect_known_niters_smaller_than_vf (loop_vec_info loop_vinfo)\n+{\n+  unsigned int assumed_vf = vect_vf_for_cost (loop_vinfo);\n+\n+  HOST_WIDE_INT max_niter;\n+  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n+    max_niter = LOOP_VINFO_INT_NITERS (loop_vinfo);\n+  else\n+    max_niter = max_stmt_executions_int (LOOP_VINFO_LOOP (loop_vinfo));\n+\n+  if (max_niter != -1 && (unsigned HOST_WIDE_INT) max_niter < assumed_vf)\n+    return true;\n+\n+  return false;\n+}\n+\n /* Analyze the cost of the loop described by LOOP_VINFO.  Decide if it\n    is worthwhile to vectorize.  Return 1 if definitely yes, 0 if\n    definitely no, or -1 if it's worth retrying.  */\n@@ -1638,15 +1672,7 @@ vect_analyze_loop_costing (loop_vec_info loop_vinfo)\n      counts less than the vectorization factor.  */\n   if (!LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo))\n     {\n-      HOST_WIDE_INT max_niter;\n-\n-      if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n-\tmax_niter = LOOP_VINFO_INT_NITERS (loop_vinfo);\n-      else\n-\tmax_niter = max_stmt_executions_int (loop);\n-\n-      if (max_niter != -1\n-\t  && (unsigned HOST_WIDE_INT) max_niter < assumed_vf)\n+      if (vect_known_niters_smaller_than_vf (loop_vinfo))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -6794,8 +6820,8 @@ vectorizable_reduction (loop_vec_info loop_vinfo,\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"can't use a fully-masked loop because no\"\n-\t\t\t     \" conditional operation is available.\\n\");\n+\t\t\t     \"can't operate on partial vectors because\"\n+\t\t\t     \" no conditional operation is available.\\n\");\n \t  LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo) = false;\n \t}\n       else if (reduction_type == FOLD_LEFT_REDUCTION\n@@ -6806,8 +6832,8 @@ vectorizable_reduction (loop_vec_info loop_vinfo,\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"can't use a fully-masked loop because no\"\n-\t\t\t     \" conditional operation is available.\\n\");\n+\t\t\t     \"can't operate on partial vectors because\"\n+\t\t\t     \" no conditional operation is available.\\n\");\n \t  LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo) = false;\n \t}\n       else\n@@ -7886,25 +7912,26 @@ vectorizable_live_operation (loop_vec_info loop_vinfo,\n \t    {\n \t      if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"can't use a fully-masked loop because \"\n-\t\t\t\t \"the target doesn't support extract last \"\n-\t\t\t\t \"reduction.\\n\");\n+\t\t\t\t \"can't operate on partial vectors \"\n+\t\t\t\t \"because the target doesn't support extract \"\n+\t\t\t\t \"last reduction.\\n\");\n \t      LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo) = false;\n \t    }\n \t  else if (slp_node)\n \t    {\n \t      if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"can't use a fully-masked loop because an \"\n-\t\t\t\t \"SLP statement is live after the loop.\\n\");\n+\t\t\t\t \"can't operate on partial vectors \"\n+\t\t\t\t \"because an SLP statement is live after \"\n+\t\t\t\t \"the loop.\\n\");\n \t      LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo) = false;\n \t    }\n \t  else if (ncopies > 1)\n \t    {\n \t      if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"can't use a fully-masked loop because\"\n-\t\t\t\t \" ncopies is greater than 1.\\n\");\n+\t\t\t\t \"can't operate on partial vectors \"\n+\t\t\t\t \"because ncopies is greater than 1.\\n\");\n \t      LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo) = false;\n \t    }\n \t  else\n@@ -9056,12 +9083,13 @@ optimize_mask_stores (class loop *loop)\n }\n \n /* Decide whether it is possible to use a zero-based induction variable\n-   when vectorizing LOOP_VINFO with a fully-masked loop.  If it is,\n-   return the value that the induction variable must be able to hold\n-   in order to ensure that the loop ends with an all-false mask.\n+   when vectorizing LOOP_VINFO with partial vectors.  If it is, return\n+   the value that the induction variable must be able to hold in order\n+   to ensure that the rgroups eventually have no active vector elements.\n    Return -1 otherwise.  */\n+\n widest_int\n-vect_iv_limit_for_full_masking (loop_vec_info loop_vinfo)\n+vect_iv_limit_for_partial_vectors (loop_vec_info loop_vinfo)\n {\n   tree niters_skip = LOOP_VINFO_MASK_SKIP_NITERS (loop_vinfo);\n   class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);"}, {"sha": "cdd6f6c5e5d08e9b2e1584daefd56bac3b02673f", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f0546e3e468e67dcd8cd20265796887805de3e/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f0546e3e468e67dcd8cd20265796887805de3e/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=04f0546e3e468e67dcd8cd20265796887805de3e", "patch": "@@ -1655,9 +1655,9 @@ static tree permute_vec_elements (vec_info *, tree, tree, tree, stmt_vec_info,\n \t\t\t\t  gimple_stmt_iterator *);\n \n /* Check whether a load or store statement in the loop described by\n-   LOOP_VINFO is possible in a fully-masked loop.  This is testing\n-   whether the vectorizer pass has the appropriate support, as well as\n-   whether the target does.\n+   LOOP_VINFO is possible in a loop using partial vectors.  This is\n+   testing whether the vectorizer pass has the appropriate support,\n+   as well as whether the target does.\n \n    VLS_TYPE says whether the statement is a load or store and VECTYPE\n    is the type of the vector being loaded or stored.  MEMORY_ACCESS_TYPE\n@@ -1667,14 +1667,18 @@ static tree permute_vec_elements (vec_info *, tree, tree, tree, stmt_vec_info,\n    its arguments.  If the load or store is conditional, SCALAR_MASK is the\n    condition under which it occurs.\n \n-   Clear LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P if a fully-masked loop is not\n-   supported, otherwise record the required mask types.  */\n+   Clear LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P if a loop using partial\n+   vectors is not supported, otherwise record the required rgroup control\n+   types.  */\n \n static void\n-check_load_store_masking (loop_vec_info loop_vinfo, tree vectype,\n-\t\t\t  vec_load_store_type vls_type, int group_size,\n-\t\t\t  vect_memory_access_type memory_access_type,\n-\t\t\t  gather_scatter_info *gs_info, tree scalar_mask)\n+check_load_store_for_partial_vectors (loop_vec_info loop_vinfo, tree vectype,\n+\t\t\t\t      vec_load_store_type vls_type,\n+\t\t\t\t      int group_size,\n+\t\t\t\t      vect_memory_access_type\n+\t\t\t\t      memory_access_type,\n+\t\t\t\t      gather_scatter_info *gs_info,\n+\t\t\t\t      tree scalar_mask)\n {\n   /* Invariant loads need no special support.  */\n   if (memory_access_type == VMAT_INVARIANT)\n@@ -1691,8 +1695,8 @@ check_load_store_masking (loop_vec_info loop_vinfo, tree vectype,\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"can't use a fully-masked loop because the\"\n-\t\t\t     \" target doesn't have an appropriate masked\"\n+\t\t\t     \"can't operate on partial vectors because\"\n+\t\t\t     \" the target doesn't have an appropriate\"\n \t\t\t     \" load/store-lanes instruction.\\n\");\n \t  LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo) = false;\n \t  return;\n@@ -1714,8 +1718,8 @@ check_load_store_masking (loop_vec_info loop_vinfo, tree vectype,\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"can't use a fully-masked loop because the\"\n-\t\t\t     \" target doesn't have an appropriate masked\"\n+\t\t\t     \"can't operate on partial vectors because\"\n+\t\t\t     \" the target doesn't have an appropriate\"\n \t\t\t     \" gather load or scatter store instruction.\\n\");\n \t  LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo) = false;\n \t  return;\n@@ -1732,8 +1736,8 @@ check_load_store_masking (loop_vec_info loop_vinfo, tree vectype,\n \t scalar loop.  We need more work to support other mappings.  */\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"can't use a fully-masked loop because an access\"\n-\t\t\t \" isn't contiguous.\\n\");\n+\t\t\t \"can't operate on partial vectors because an\"\n+\t\t\t \" access isn't contiguous.\\n\");\n       LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo) = false;\n       return;\n     }\n@@ -7140,8 +7144,9 @@ vectorizable_store (vec_info *vinfo,\n \n       if (loop_vinfo\n \t  && LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo))\n-\tcheck_load_store_masking (loop_vinfo, vectype, vls_type, group_size,\n-\t\t\t\t  memory_access_type, &gs_info, mask);\n+\tcheck_load_store_for_partial_vectors (loop_vinfo, vectype, vls_type,\n+\t\t\t\t\t      group_size, memory_access_type,\n+\t\t\t\t\t      &gs_info, mask);\n \n       if (slp_node\n \t  && !vect_maybe_update_slp_op_vectype (SLP_TREE_CHILDREN (slp_node)[0],\n@@ -8433,8 +8438,9 @@ vectorizable_load (vec_info *vinfo,\n \n       if (loop_vinfo\n \t  && LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo))\n-\tcheck_load_store_masking (loop_vinfo, vectype, VLS_LOAD, group_size,\n-\t\t\t\t  memory_access_type, &gs_info, mask);\n+\tcheck_load_store_for_partial_vectors (loop_vinfo, vectype, VLS_LOAD,\n+\t\t\t\t\t      group_size, memory_access_type,\n+\t\t\t\t\t      &gs_info, mask);\n \n       STMT_VINFO_TYPE (orig_stmt_info) = load_vec_info_type;\n       vect_model_load_cost (vinfo, stmt_info, ncopies, vf, memory_access_type,"}, {"sha": "6c830ad09f45821b470d6ea1b9360752d7499636", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04f0546e3e468e67dcd8cd20265796887805de3e/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04f0546e3e468e67dcd8cd20265796887805de3e/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=04f0546e3e468e67dcd8cd20265796887805de3e", "patch": "@@ -545,9 +545,10 @@ typedef class _loop_vec_info : public vec_info {\n      elements that should be false in the first mask).  */\n   tree mask_skip_niters;\n \n-  /* Type of the variables to use in the WHILE_ULT call for fully-masked\n-     loops.  */\n-  tree mask_compare_type;\n+  /* The type that the loop control IV should be converted to before\n+     testing which of the VF scalars are active and inactive.\n+     Only meaningful if LOOP_VINFO_USING_PARTIAL_VECTORS_P.  */\n+  tree rgroup_compare_type;\n \n   /* For #pragma omp simd if (x) loops the x expression.  If constant 0,\n      the loop should not be vectorized, if constant non-zero, simd_if_cond\n@@ -556,9 +557,9 @@ typedef class _loop_vec_info : public vec_info {\n      is false and vectorized loop otherwise.  */\n   tree simd_if_cond;\n \n-  /* Type of the IV to use in the WHILE_ULT call for fully-masked\n-     loops.  */\n-  tree iv_type;\n+  /* The type that the vector loop control IV should have when\n+     LOOP_VINFO_USING_PARTIAL_VECTORS_P is true.  */\n+  tree rgroup_iv_type;\n \n   /* Unknown DRs according to which loop was peeled.  */\n   class dr_vec_info *unaligned_dr;\n@@ -710,8 +711,8 @@ typedef class _loop_vec_info : public vec_info {\n #define LOOP_VINFO_MAX_VECT_FACTOR(L)      (L)->max_vectorization_factor\n #define LOOP_VINFO_MASKS(L)                (L)->masks\n #define LOOP_VINFO_MASK_SKIP_NITERS(L)     (L)->mask_skip_niters\n-#define LOOP_VINFO_MASK_COMPARE_TYPE(L)    (L)->mask_compare_type\n-#define LOOP_VINFO_MASK_IV_TYPE(L)         (L)->iv_type\n+#define LOOP_VINFO_RGROUP_COMPARE_TYPE(L)  (L)->rgroup_compare_type\n+#define LOOP_VINFO_RGROUP_IV_TYPE(L)       (L)->rgroup_iv_type\n #define LOOP_VINFO_PTR_MASK(L)             (L)->ptr_mask\n #define LOOP_VINFO_LOOP_NEST(L)            (L)->shared->loop_nest\n #define LOOP_VINFO_DATAREFS(L)             (L)->shared->datarefs\n@@ -1847,7 +1848,7 @@ extern tree vect_create_addr_base_for_vector_ref (vec_info *,\n \t\t\t\t\t\t  tree, tree = NULL_TREE);\n \n /* In tree-vect-loop.c.  */\n-extern widest_int vect_iv_limit_for_full_masking (loop_vec_info loop_vinfo);\n+extern widest_int vect_iv_limit_for_partial_vectors (loop_vec_info loop_vinfo);\n /* Used in tree-vect-loop-manip.c */\n extern void determine_peel_for_niter (loop_vec_info);\n /* Used in gimple-loop-interchange.c and tree-parloops.c.  */"}]}