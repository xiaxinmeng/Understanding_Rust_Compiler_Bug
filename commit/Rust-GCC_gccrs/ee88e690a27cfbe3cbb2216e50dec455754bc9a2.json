{"sha": "ee88e690a27cfbe3cbb2216e50dec455754bc9a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWU4OGU2OTBhMjdjZmJlM2NiYjIyMTZlNTBkZWM0NTU3NTRiYzlhMg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2012-11-23T16:00:26Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-11-23T16:00:26Z"}, "message": "re PR rtl-optimization/55388 (ICE in int_mode_for_mode at stor-layout.c:423)\n\n\tPR rtl-optimization/55388\n\t* alias.c (nonoverlapping_component_refs_p): Handle bitfields.\n\t* emit-rtl.c (adjust_address_1): Deal with VOIDmode early.\n\t* expmed.c (store_bit_field): Turn the call to adjust_address\n\tinto a call to adjust_bitfield_address_size.\n\nFrom-SVN: r193760", "tree": {"sha": "a14567480c026683cf12be27a8dd0c65837a7be2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a14567480c026683cf12be27a8dd0c65837a7be2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee88e690a27cfbe3cbb2216e50dec455754bc9a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee88e690a27cfbe3cbb2216e50dec455754bc9a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee88e690a27cfbe3cbb2216e50dec455754bc9a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee88e690a27cfbe3cbb2216e50dec455754bc9a2/comments", "author": null, "committer": null, "parents": [{"sha": "afa22e29eed02941a7d6d21f539ce5fb8716eba1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afa22e29eed02941a7d6d21f539ce5fb8716eba1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afa22e29eed02941a7d6d21f539ce5fb8716eba1"}], "stats": {"total": 36, "additions": 29, "deletions": 7}, "files": [{"sha": "b1a9d32a3e02f2359cb55a947c38735ce6f5c788", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee88e690a27cfbe3cbb2216e50dec455754bc9a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee88e690a27cfbe3cbb2216e50dec455754bc9a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ee88e690a27cfbe3cbb2216e50dec455754bc9a2", "patch": "@@ -1,3 +1,11 @@\n+2012-11-23  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR rtl-optimization/55388\n+\t* alias.c (nonoverlapping_component_refs_p): Handle bitfields.\n+\t* emit-rtl.c (adjust_address_1): Deal with VOIDmode early.\n+\t* expmed.c (store_bit_field): Turn the call to adjust_address\n+\tinto a call to adjust_bitfield_address_size.\n+\n 2012-11-23  Vladimir Makarov  <vmakarov@redhat.com>\n \n \t* lra.c (lra): Move init_reg_info and expand_reg_info calls before"}, {"sha": "21daa5fdb4f2520f96009fb4a59181d03311c46f", "filename": "gcc/alias.c", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee88e690a27cfbe3cbb2216e50dec455754bc9a2/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee88e690a27cfbe3cbb2216e50dec455754bc9a2/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=ee88e690a27cfbe3cbb2216e50dec455754bc9a2", "patch": "@@ -2236,11 +2236,20 @@ nonoverlapping_component_refs_p (const_rtx rtlx, const_rtx rtly)\n       return false;\n \n     found:\n-      /* If we're left with accessing different fields of a structure,\n-\t then no overlap.  */\n-      if (TREE_CODE (typex) == RECORD_TYPE\n-\t  && fieldx != fieldy)\n-\treturn true;\n+      /* If we're left with accessing different fields of a structure, then no\n+\t possible overlap, unless they are both true bitfields, i.e. bitfields\n+\t for which the size isn't a multiple of the (memory) unit.  */\n+      if (TREE_CODE (typex) == RECORD_TYPE && fieldx != fieldy)\n+\t{\n+\t  if (!DECL_BIT_FIELD (fieldx) || !DECL_BIT_FIELD (fieldy))\n+\t    return true;\n+\n+\t  if ((tree_low_cst (DECL_SIZE (fieldx), 1) % BITS_PER_UNIT) == 0\n+\t      || (tree_low_cst (DECL_SIZE (fieldy), 1) % BITS_PER_UNIT) == 0)\n+\t    return true;\n+\n+\t  return false;\n+\t}\n \n       /* The comparison on the current field failed.  If we're accessing\n \t a very nested structure, look at the next outer level.  */"}, {"sha": "836ff2f50256e03482936af54ebec225e6d0c7dc", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee88e690a27cfbe3cbb2216e50dec455754bc9a2/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee88e690a27cfbe3cbb2216e50dec455754bc9a2/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=ee88e690a27cfbe3cbb2216e50dec455754bc9a2", "patch": "@@ -2072,6 +2072,10 @@ adjust_address_1 (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset,\n     = targetm.addr_space.pointer_mode (attrs.addrspace);\n #endif\n \n+  /* VOIDmode means no mode change for change_address_1.  */\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (memref);\n+\n   /* Take the size of non-BLKmode accesses from the mode.  */\n   defattrs = mode_mem_attrs[(int) mode];\n   if (defattrs->size_known_p)"}, {"sha": "fc29ac41d72998d31ef76dab6439bb07e0ae0347", "filename": "gcc/expmed.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee88e690a27cfbe3cbb2216e50dec455754bc9a2/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee88e690a27cfbe3cbb2216e50dec455754bc9a2/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=ee88e690a27cfbe3cbb2216e50dec455754bc9a2", "patch": "@@ -869,19 +869,20 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n   if (MEM_P (str_rtx) && bitregion_start > 0)\n     {\n       enum machine_mode bestmode;\n-      unsigned HOST_WIDE_INT offset;\n+      HOST_WIDE_INT offset, size;\n \n       gcc_assert ((bitregion_start % BITS_PER_UNIT) == 0);\n \n       offset = bitregion_start / BITS_PER_UNIT;\n       bitnum -= bitregion_start;\n+      size = (bitnum + bitsize + BITS_PER_UNIT - 1) / BITS_PER_UNIT;\n       bitregion_end -= bitregion_start;\n       bitregion_start = 0;\n       bestmode = get_best_mode (bitsize, bitnum,\n \t\t\t\tbitregion_start, bitregion_end,\n \t\t\t\tMEM_ALIGN (str_rtx), VOIDmode,\n \t\t\t\tMEM_VOLATILE_P (str_rtx));\n-      str_rtx = adjust_address (str_rtx, bestmode, offset);\n+      str_rtx = adjust_bitfield_address_size (str_rtx, bestmode, offset, size);\n     }\n \n   if (!store_bit_field_1 (str_rtx, bitsize, bitnum,"}]}