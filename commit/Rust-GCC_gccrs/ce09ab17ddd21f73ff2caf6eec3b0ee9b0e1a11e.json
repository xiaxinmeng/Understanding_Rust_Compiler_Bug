{"sha": "ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e", "node_id": "C_kwDOANBUbNoAKGNlMDlhYjE3ZGRkMjFmNzNmZjJjYWY2ZWVjM2IwZWU5YjBlMWExMWU", "commit": {"author": {"name": "Dan Li", "email": "ashimida@linux.alibaba.com", "date": "2022-02-21T20:01:14Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-02-21T20:01:14Z"}, "message": "aarch64: Add compiler support for Shadow Call Stack\n\nShadow Call Stack can be used to protect the return address of a\nfunction at runtime, and clang already supports this feature[1].\n\nTo enable SCS in user mode, in addition to compiler, other support\nis also required (as discussed in [2]). This patch only adds basic\nsupport for SCS from the compiler side, and provides convenience\nfor users to enable SCS.\n\nFor linux kernel, only the support of the compiler is required.\n\n[1] https://clang.llvm.org/docs/ShadowCallStack.html\n[2] https://gcc.gnu.org/bugzilla/show_bug.cgi?id=102768\n\nSigned-off-by: Dan Li <ashimida@linux.alibaba.com>\n\ngcc/ChangeLog:\n\n\t* config/aarch64/aarch64.cc (SLOT_REQUIRED):\n\tChange wb_candidate[12] to wb_push_candidate[12].\n\t(aarch64_layout_frame): Likewise, and\n\tchange callee_adjust when scs is enabled.\n\t(aarch64_save_callee_saves):\n\tChange wb_candidate[12] to wb_push_candidate[12].\n\t(aarch64_restore_callee_saves):\n\tChange wb_candidate[12] to wb_pop_candidate[12].\n\t(aarch64_get_separate_components):\n\tChange wb_candidate[12] to wb_push_candidate[12].\n\t(aarch64_expand_prologue): Push x30 onto SCS before it's\n\tpushed onto stack.\n\t(aarch64_expand_epilogue): Pop x30 frome SCS, while\n\tpreventing it from being popped from the regular stack again.\n\t(aarch64_override_options_internal): Add SCS compile option check.\n\t(TARGET_HAVE_SHADOW_CALL_STACK): New hook.\n\t* config/aarch64/aarch64.h (struct GTY): Add is_scs_enabled,\n\twb_pop_candidate[12], and rename wb_candidate[12] to\n\twb_push_candidate[12].\n\t* config/aarch64/aarch64.md (scs_push): New template.\n\t(scs_pop): Likewise.\n\t* doc/invoke.texi: Document -fsanitize=shadow-call-stack.\n\t* doc/tm.texi: Regenerate.\n\t* doc/tm.texi.in: Add hook have_shadow_call_stack.\n\t* flag-types.h (enum sanitize_code):\n\tAdd SANITIZE_SHADOW_CALL_STACK.\n\t* opts.cc (parse_sanitizer_options): Add shadow-call-stack\n\tand exclude SANITIZE_SHADOW_CALL_STACK.\n\t* target.def: New hook.\n\t* toplev.cc (process_options): Add SCS compile option check.\n\t* ubsan.cc (ubsan_expand_null_ifn): Enum type conversion.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/aarch64/shadow_call_stack_1.c: New test.\n\t* gcc.target/aarch64/shadow_call_stack_2.c: New test.\n\t* gcc.target/aarch64/shadow_call_stack_3.c: New test.\n\t* gcc.target/aarch64/shadow_call_stack_4.c: New test.\n\t* gcc.target/aarch64/shadow_call_stack_5.c: New test.\n\t* gcc.target/aarch64/shadow_call_stack_6.c: New test.\n\t* gcc.target/aarch64/shadow_call_stack_7.c: New test.\n\t* gcc.target/aarch64/shadow_call_stack_8.c: New test.", "tree": {"sha": "08702dec30a499e78265cd09be5847b496104c0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08702dec30a499e78265cd09be5847b496104c0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/comments", "author": {"login": "ashimida123", "id": 26736862, "node_id": "MDQ6VXNlcjI2NzM2ODYy", "avatar_url": "https://avatars.githubusercontent.com/u/26736862?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ashimida123", "html_url": "https://github.com/ashimida123", "followers_url": "https://api.github.com/users/ashimida123/followers", "following_url": "https://api.github.com/users/ashimida123/following{/other_user}", "gists_url": "https://api.github.com/users/ashimida123/gists{/gist_id}", "starred_url": "https://api.github.com/users/ashimida123/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ashimida123/subscriptions", "organizations_url": "https://api.github.com/users/ashimida123/orgs", "repos_url": "https://api.github.com/users/ashimida123/repos", "events_url": "https://api.github.com/users/ashimida123/events{/privacy}", "received_events_url": "https://api.github.com/users/ashimida123/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02aedc6f269b5e3c1f354edcf5b84d27b0a15946", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02aedc6f269b5e3c1f354edcf5b84d27b0a15946", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02aedc6f269b5e3c1f354edcf5b84d27b0a15946"}], "stats": {"total": 364, "additions": 330, "deletions": 34}, "files": [{"sha": "8bcee8be9eb91aebebac9504f9538cb5d906437a", "filename": "gcc/config/aarch64/aarch64.cc", "status": "modified", "additions": 85, "deletions": 28, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.cc?ref=ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e", "patch": "@@ -80,6 +80,7 @@\n #include \"fractional-cost.h\"\n #include \"rtlanal.h\"\n #include \"tree-dfa.h\"\n+#include \"asan.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -7547,8 +7548,8 @@ aarch64_layout_frame (void)\n #define SLOT_NOT_REQUIRED (-2)\n #define SLOT_REQUIRED     (-1)\n \n-  frame.wb_candidate1 = INVALID_REGNUM;\n-  frame.wb_candidate2 = INVALID_REGNUM;\n+  frame.wb_push_candidate1 = INVALID_REGNUM;\n+  frame.wb_push_candidate2 = INVALID_REGNUM;\n   frame.spare_pred_reg = INVALID_REGNUM;\n \n   /* First mark all the registers that really need to be saved...  */\n@@ -7663,20 +7664,20 @@ aarch64_layout_frame (void)\n     {\n       /* FP and LR are placed in the linkage record.  */\n       frame.reg_offset[R29_REGNUM] = offset;\n-      frame.wb_candidate1 = R29_REGNUM;\n+      frame.wb_push_candidate1 = R29_REGNUM;\n       frame.reg_offset[R30_REGNUM] = offset + UNITS_PER_WORD;\n-      frame.wb_candidate2 = R30_REGNUM;\n+      frame.wb_push_candidate2 = R30_REGNUM;\n       offset += 2 * UNITS_PER_WORD;\n     }\n \n   for (regno = R0_REGNUM; regno <= R30_REGNUM; regno++)\n     if (known_eq (frame.reg_offset[regno], SLOT_REQUIRED))\n       {\n \tframe.reg_offset[regno] = offset;\n-\tif (frame.wb_candidate1 == INVALID_REGNUM)\n-\t  frame.wb_candidate1 = regno;\n-\telse if (frame.wb_candidate2 == INVALID_REGNUM)\n-\t  frame.wb_candidate2 = regno;\n+\tif (frame.wb_push_candidate1 == INVALID_REGNUM)\n+\t  frame.wb_push_candidate1 = regno;\n+\telse if (frame.wb_push_candidate2 == INVALID_REGNUM)\n+\t  frame.wb_push_candidate2 = regno;\n \toffset += UNITS_PER_WORD;\n       }\n \n@@ -7699,11 +7700,11 @@ aarch64_layout_frame (void)\n \t  }\n \n \tframe.reg_offset[regno] = offset;\n-\tif (frame.wb_candidate1 == INVALID_REGNUM)\n-\t  frame.wb_candidate1 = regno;\n-\telse if (frame.wb_candidate2 == INVALID_REGNUM\n-\t\t && frame.wb_candidate1 >= V0_REGNUM)\n-\t  frame.wb_candidate2 = regno;\n+\tif (frame.wb_push_candidate1 == INVALID_REGNUM)\n+\t  frame.wb_push_candidate1 = regno;\n+\telse if (frame.wb_push_candidate2 == INVALID_REGNUM\n+\t\t && frame.wb_push_candidate1 >= V0_REGNUM)\n+\t  frame.wb_push_candidate2 = regno;\n \toffset += vector_save_size;\n       }\n \n@@ -7734,10 +7735,38 @@ aarch64_layout_frame (void)\n   frame.sve_callee_adjust = 0;\n   frame.callee_offset = 0;\n \n+  frame.wb_pop_candidate1 = frame.wb_push_candidate1;\n+  frame.wb_pop_candidate2 = frame.wb_push_candidate2;\n+\n+  /* Shadow call stack only deals with functions where the LR is pushed\n+     onto the stack and without specifying the \"no_sanitize\" attribute\n+     with the argument \"shadow-call-stack\".  */\n+  frame.is_scs_enabled\n+    = (!crtl->calls_eh_return\n+       && sanitize_flags_p (SANITIZE_SHADOW_CALL_STACK)\n+       && known_ge (cfun->machine->frame.reg_offset[LR_REGNUM], 0));\n+\n+  /* When shadow call stack is enabled, the scs_pop in the epilogue will\n+     restore x30, and we don't need to pop x30 again in the traditional\n+     way.  Pop candidates record the registers that need to be popped\n+     eventually.  */\n+  if (frame.is_scs_enabled)\n+    {\n+      if (frame.wb_pop_candidate2 == R30_REGNUM)\n+\tframe.wb_pop_candidate2 = INVALID_REGNUM;\n+      else if (frame.wb_pop_candidate1 == R30_REGNUM)\n+\tframe.wb_pop_candidate1 = INVALID_REGNUM;\n+    }\n+\n+  /* If candidate2 is INVALID_REGNUM, we need to adjust max_push_offset to\n+     256 to ensure that the offset meets the requirements of emit_move_insn.\n+     Similarly, if candidate1 is INVALID_REGNUM, we need to set\n+     max_push_offset to 0, because no registers are popped at this time,\n+     so callee_adjust cannot be adjusted.  */\n   HOST_WIDE_INT max_push_offset = 0;\n-  if (frame.wb_candidate2 != INVALID_REGNUM)\n+  if (frame.wb_pop_candidate2 != INVALID_REGNUM)\n     max_push_offset = 512;\n-  else if (frame.wb_candidate1 != INVALID_REGNUM)\n+  else if (frame.wb_pop_candidate1 != INVALID_REGNUM)\n     max_push_offset = 256;\n \n   HOST_WIDE_INT const_size, const_outgoing_args_size, const_fp_offset;\n@@ -7827,8 +7856,8 @@ aarch64_layout_frame (void)\n     {\n       /* We've decided not to associate any register saves with the initial\n \t stack allocation.  */\n-      frame.wb_candidate1 = INVALID_REGNUM;\n-      frame.wb_candidate2 = INVALID_REGNUM;\n+      frame.wb_pop_candidate1 = frame.wb_push_candidate1 = INVALID_REGNUM;\n+      frame.wb_pop_candidate2 = frame.wb_push_candidate2 = INVALID_REGNUM;\n     }\n \n   frame.laid_out = true;\n@@ -8141,8 +8170,8 @@ aarch64_save_callee_saves (poly_int64 start_offset,\n       bool frame_related_p = aarch64_emit_cfi_for_reg_p (regno);\n \n       if (skip_wb\n-\t  && (regno == cfun->machine->frame.wb_candidate1\n-\t      || regno == cfun->machine->frame.wb_candidate2))\n+\t  && (regno == cfun->machine->frame.wb_push_candidate1\n+\t      || regno == cfun->machine->frame.wb_push_candidate2))\n \tcontinue;\n \n       if (cfun->machine->reg_is_wrapped_separately[regno])\n@@ -8252,8 +8281,8 @@ aarch64_restore_callee_saves (poly_int64 start_offset, unsigned start,\n       rtx reg, mem;\n \n       if (skip_wb\n-\t  && (regno == cfun->machine->frame.wb_candidate1\n-\t      || regno == cfun->machine->frame.wb_candidate2))\n+\t  && (regno == cfun->machine->frame.wb_pop_candidate1\n+\t      || regno == cfun->machine->frame.wb_pop_candidate2))\n \tcontinue;\n \n       machine_mode mode = aarch64_reg_save_mode (regno);\n@@ -8424,8 +8453,8 @@ aarch64_get_separate_components (void)\n   if (cfun->machine->frame.spare_pred_reg != INVALID_REGNUM)\n     bitmap_clear_bit (components, cfun->machine->frame.spare_pred_reg);\n \n-  unsigned reg1 = cfun->machine->frame.wb_candidate1;\n-  unsigned reg2 = cfun->machine->frame.wb_candidate2;\n+  unsigned reg1 = cfun->machine->frame.wb_push_candidate1;\n+  unsigned reg2 = cfun->machine->frame.wb_push_candidate2;\n   /* If registers have been chosen to be stored/restored with\n      writeback don't interfere with them to avoid having to output explicit\n      stack adjustment instructions.  */\n@@ -9034,8 +9063,8 @@ aarch64_expand_prologue (void)\n   poly_int64 sve_callee_adjust = cfun->machine->frame.sve_callee_adjust;\n   poly_int64 below_hard_fp_saved_regs_size\n     = cfun->machine->frame.below_hard_fp_saved_regs_size;\n-  unsigned reg1 = cfun->machine->frame.wb_candidate1;\n-  unsigned reg2 = cfun->machine->frame.wb_candidate2;\n+  unsigned reg1 = cfun->machine->frame.wb_push_candidate1;\n+  unsigned reg2 = cfun->machine->frame.wb_push_candidate2;\n   bool emit_frame_chain = cfun->machine->frame.emit_frame_chain;\n   rtx_insn *insn;\n \n@@ -9066,6 +9095,10 @@ aarch64_expand_prologue (void)\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n+  /* Push return address to shadow call stack.  */\n+  if (cfun->machine->frame.is_scs_enabled)\n+    emit_insn (gen_scs_push ());\n+\n   if (flag_stack_usage_info)\n     current_function_static_stack_size = constant_lower_bound (frame_size);\n \n@@ -9212,8 +9245,10 @@ aarch64_expand_epilogue (bool for_sibcall)\n   poly_int64 sve_callee_adjust = cfun->machine->frame.sve_callee_adjust;\n   poly_int64 below_hard_fp_saved_regs_size\n     = cfun->machine->frame.below_hard_fp_saved_regs_size;\n-  unsigned reg1 = cfun->machine->frame.wb_candidate1;\n-  unsigned reg2 = cfun->machine->frame.wb_candidate2;\n+  unsigned reg1 = cfun->machine->frame.wb_pop_candidate1;\n+  unsigned reg2 = cfun->machine->frame.wb_pop_candidate2;\n+  unsigned int last_gpr = (cfun->machine->frame.is_scs_enabled\n+\t\t\t   ? R29_REGNUM : R30_REGNUM);\n   rtx cfi_ops = NULL;\n   rtx_insn *insn;\n   /* A stack clash protection prologue may not have left EP0_REGNUM or\n@@ -9283,8 +9318,12 @@ aarch64_expand_epilogue (bool for_sibcall)\n \t\t\t\tfalse, &cfi_ops);\n   if (maybe_ne (sve_callee_adjust, 0))\n     aarch64_add_sp (NULL_RTX, NULL_RTX, sve_callee_adjust, true);\n+\n+  /* When shadow call stack is enabled, the scs_pop in the epilogue will\n+     restore x30, we don't need to restore x30 again in the traditional\n+     way.  */\n   aarch64_restore_callee_saves (callee_offset - sve_callee_adjust,\n-\t\t\t\tR0_REGNUM, R30_REGNUM,\n+\t\t\t\tR0_REGNUM, last_gpr,\n \t\t\t\tcallee_adjust != 0, &cfi_ops);\n \n   if (need_barrier_p)\n@@ -9322,6 +9361,17 @@ aarch64_expand_epilogue (bool for_sibcall)\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n+  /* Pop return address from shadow call stack.  */\n+  if (cfun->machine->frame.is_scs_enabled)\n+    {\n+      machine_mode mode = aarch64_reg_save_mode (R30_REGNUM);\n+      rtx reg = gen_rtx_REG (mode, R30_REGNUM);\n+\n+      insn = emit_insn (gen_scs_pop ());\n+      add_reg_note (insn, REG_CFA_RESTORE, reg);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+\n   /* We prefer to emit the combined return/authenticate instruction RETAA,\n      however there are three cases in which we must instead emit an explicit\n      authentication instruction.\n@@ -16878,6 +16928,10 @@ aarch64_override_options_internal (struct gcc_options *opts)\n       aarch64_stack_protector_guard_offset = offs;\n     }\n \n+  if ((flag_sanitize & SANITIZE_SHADOW_CALL_STACK)\n+      && !fixed_regs[R18_REGNUM])\n+    error (\"%<-fsanitize=shadow-call-stack%> requires %<-ffixed-x18%>\");\n+\n   initialize_aarch64_code_model (opts);\n   initialize_aarch64_tls_size (opts);\n \n@@ -27084,6 +27138,9 @@ aarch64_libgcc_floating_mode_supported_p\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE aarch64_sls_emit_blr_function_thunks\n \n+#undef TARGET_HAVE_SHADOW_CALL_STACK\n+#define TARGET_HAVE_SHADOW_CALL_STACK true\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-aarch64.h\""}, {"sha": "27ba4f4ca3fa78585733cfe68e2dee32c55282a7", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e", "patch": "@@ -922,16 +922,31 @@ struct GTY (()) aarch64_frame\n \t Indicated by CALLEE_ADJUST == 0 && EMIT_FRAME_CHAIN.\n \n      These fields indicate which registers we've decided to handle using\n-     (1) or (2), or INVALID_REGNUM if none.  */\n-  unsigned wb_candidate1;\n-  unsigned wb_candidate2;\n+     (1) or (2), or INVALID_REGNUM if none.\n+\n+     In some cases we don't always need to pop all registers in the push\n+     candidates, pop candidates record which registers need to be popped\n+     eventually.  The initial value of a pop candidate is copied from its\n+     corresponding push candidate.\n+\n+     Currently, different pop candidates are only used for shadow call\n+     stack.  When \"-fsanitize=shadow-call-stack\" is specified, we replace\n+     x30 in the pop candidate with INVALID_REGNUM to ensure that x30 is\n+     not popped twice.  */\n+  unsigned wb_push_candidate1;\n+  unsigned wb_push_candidate2;\n+  unsigned wb_pop_candidate1;\n+  unsigned wb_pop_candidate2;\n \n   /* Big-endian SVE frames need a spare predicate register in order\n      to save vector registers in the correct layout for unwinding.\n      This is the register they should use.  */\n   unsigned spare_pred_reg;\n \n   bool laid_out;\n+\n+  /* True if shadow call stack should be enabled for the current function.  */\n+  bool is_scs_enabled;\n };\n \n typedef struct GTY (()) machine_function"}, {"sha": "c98525075a0baf584b9201cd63c67a1f8ab9aad3", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e", "patch": "@@ -7093,6 +7093,16 @@\n   \"hint\\t7 // xpaclri\"\n )\n \n+;; Save X30 in the X18-based POST_INC stack (consistent with clang).\n+(define_expand \"scs_push\"\n+  [(set (mem:DI (post_inc:DI (reg:DI R18_REGNUM)))\n+\t(reg:DI R30_REGNUM))])\n+\n+;; Load X30 form the X18-based PRE_DEC stack (consistent with clang).\n+(define_expand \"scs_pop\"\n+  [(set (reg:DI R30_REGNUM)\n+\t(mem:DI (pre_dec:DI (reg:DI R18_REGNUM))))])\n+\n ;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n ;; all of memory.  This blocks insns from being moved across this point.\n "}, {"sha": "635c5f79278d8a8e652570a59e7779d70058e626", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e", "patch": "@@ -15620,6 +15620,36 @@ add @code{detect_invalid_pointer_pairs=2} to the environment variable\n @env{ASAN_OPTIONS}. Using @code{detect_invalid_pointer_pairs=1} detects\n invalid operation only when both pointers are non-null.\n \n+@item -fsanitize=shadow-call-stack\n+@opindex fsanitize=shadow-call-stack\n+Enable ShadowCallStack, a security enhancement mechanism used to protect\n+programs against return address overwrites (e.g. stack buffer overflows.)\n+It works by saving a function's return address to a separately allocated\n+shadow call stack in the function prologue and restoring the return address\n+from the shadow call stack in the function epilogue.  Instrumentation only\n+occurs in functions that need to save the return address to the stack.\n+\n+Currently it only supports the aarch64 platform.  It is specifically\n+designed for linux kernels that enable the CONFIG_SHADOW_CALL_STACK option.\n+For the user space programs, runtime support is not currently provided\n+in libc and libgcc.  Users who want to use this feature in user space need\n+to provide their own support for the runtime.  It should be noted that\n+this may cause the ABI rules to be broken.\n+\n+On aarch64, the instrumentation makes use of the platform register @code{x18}.\n+This generally means that any code that may run on the same thread as code\n+compiled with ShadowCallStack must be compiled with the flag\n+@option{-ffixed-x18}, otherwise functions compiled without\n+@option{-ffixed-x18} might clobber @code{x18} and so corrupt the shadow\n+stack pointer.\n+\n+Also, because there is no userspace runtime support, code compiled with\n+ShadowCallStack cannot use exception handling.  Use @option{-fno-exceptions}\n+to turn off exceptions.\n+\n+See @uref{https://clang.llvm.org/docs/ShadowCallStack.html} for more\n+details.\n+\n @item -fsanitize=thread\n @opindex fsanitize=thread\n Enable ThreadSanitizer, a fast data race detector."}, {"sha": "49864dd79f8136a459cc820b5b0fdb4d920b4b1d", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e", "patch": "@@ -12596,3 +12596,8 @@ counters are incremented using atomic operations.  Targets not supporting\n 64-bit atomic operations may override the default value and request a 32-bit\n type.\n @end deftypefn\n+\n+@deftypevr {Target Hook} bool TARGET_HAVE_SHADOW_CALL_STACK\n+This value is true if the target platform supports\n+@option{-fsanitize=shadow-call-stack}.  The default value is false.\n+@end deftypevr"}, {"sha": "95e5e341f07076f1c25a82ddfeaa415067a934ef", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e", "patch": "@@ -8181,3 +8181,5 @@ maintainer is familiar with.\n @hook TARGET_MEMTAG_UNTAGGED_POINTER\n \n @hook TARGET_GCOV_TYPE_SIZE\n+\n+@hook TARGET_HAVE_SHADOW_CALL_STACK"}, {"sha": "2c8498169e0c4c5e04090c18f6f8076c95786878", "filename": "gcc/flag-types.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e", "patch": "@@ -321,6 +321,8 @@ enum sanitize_code {\n   SANITIZE_HWADDRESS = 1UL << 28,\n   SANITIZE_USER_HWADDRESS = 1UL << 29,\n   SANITIZE_KERNEL_HWADDRESS = 1UL << 30,\n+  /* Shadow Call Stack.  */\n+  SANITIZE_SHADOW_CALL_STACK = 1UL << 31,\n   SANITIZE_SHIFT = SANITIZE_SHIFT_BASE | SANITIZE_SHIFT_EXPONENT,\n   SANITIZE_UNDEFINED = SANITIZE_SHIFT | SANITIZE_DIVIDE | SANITIZE_UNREACHABLE\n \t\t       | SANITIZE_VLA | SANITIZE_NULL | SANITIZE_RETURN"}, {"sha": "19c68aed065f362cf164bbf3c3ec08055b7b6a71", "filename": "gcc/opts.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Fopts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Fopts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.cc?ref=ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e", "patch": "@@ -2017,6 +2017,7 @@ const struct sanitizer_opts_s sanitizer_opts[] =\n   SANITIZER_OPT (vptr, SANITIZE_VPTR, true),\n   SANITIZER_OPT (pointer-overflow, SANITIZE_POINTER_OVERFLOW, true),\n   SANITIZER_OPT (builtin, SANITIZE_BUILTIN, true),\n+  SANITIZER_OPT (shadow-call-stack, SANITIZE_SHADOW_CALL_STACK, false),\n   SANITIZER_OPT (all, ~0U, true),\n #undef SANITIZER_OPT\n   { NULL, 0U, 0UL, false }\n@@ -2143,7 +2144,8 @@ parse_sanitizer_options (const char *p, location_t loc, int scode,\n \t\t  }\n \t\telse\n \t\t  flags |= ~(SANITIZE_THREAD | SANITIZE_LEAK\n-\t\t\t     | SANITIZE_UNREACHABLE | SANITIZE_RETURN);\n+\t\t\t     | SANITIZE_UNREACHABLE | SANITIZE_RETURN\n+\t\t\t     | SANITIZE_SHADOW_CALL_STACK);\n \t      }\n \t    else if (value)\n \t      {"}, {"sha": "72c2e1ef756cf70a1c92abe81f8a6577eaaa2501", "filename": "gcc/target.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e", "patch": "@@ -7096,6 +7096,14 @@ counters are incremented using atomic operations.  Targets not supporting\\n\\\n type.\",\n  HOST_WIDE_INT, (void), default_gcov_type_size)\n \n+/* This value represents whether the shadow call stack is implemented on\n+   the target platform.  */\n+DEFHOOKPOD\n+(have_shadow_call_stack,\n+ \"This value is true if the target platform supports\\n\\\n+@option{-fsanitize=shadow-call-stack}.  The default value is false.\",\n+ bool, false)\n+\n /* Close the 'struct gcc_target' definition.  */\n HOOK_VECTOR_END (C90_EMPTY_HACK)\n "}, {"sha": "ab68d6e84825260ea07a5c96ada31bddb338be4f", "filename": "gcc/testsuite/gcc.target/aarch64/shadow_call_stack_1.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fshadow_call_stack_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fshadow_call_stack_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fshadow_call_stack_1.c?ref=ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fsanitize=shadow-call-stack -fno-exceptions\" } */\n+\n+int i;\n+\n+/* { dg-error \"'-fsanitize=shadow-call-stack' requires '-ffixed-x18'\" \"\" {target \"aarch64*-*-*\" } 0 } */"}, {"sha": "b5139a245597b645c6c54b966aba82c1e4e6230f", "filename": "gcc/testsuite/gcc.target/aarch64/shadow_call_stack_2.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fshadow_call_stack_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fshadow_call_stack_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fshadow_call_stack_2.c?ref=ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fsanitize=shadow-call-stack -ffixed-x18 -fexceptions\" } */\n+\n+int i;\n+\n+/* { dg-error \"'-fsanitize=shadow-call-stack' requires '-fno-exceptions'\" \"\" {target \"aarch64*-*-*\" } 0 } */"}, {"sha": "b88e490f3ae71dcd6e262c70d71bbf7837aa7630", "filename": "gcc/testsuite/gcc.target/aarch64/shadow_call_stack_3.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fshadow_call_stack_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fshadow_call_stack_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fshadow_call_stack_3.c?ref=ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e", "patch": "@@ -0,0 +1,45 @@\n+/* Testing shadow call stack.  */\n+/* scs_push: str x30, [x18], #8 */\n+/* scs_pop: ldr x30, [x18, #-8]! */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fsanitize=shadow-call-stack -ffixed-x18 -fno-exceptions\" } */\n+\n+int foo (int);\n+\n+/* function not use x30.  */\n+int func1 (void)\n+{\n+  return 0;\n+}\n+\n+/* function use x30.  */\n+int func2 (void)\n+{\n+  /* scs push */\n+  asm volatile (\"\":::\"x30\");\n+\n+  return 0;\n+  /* scs pop */\n+}\n+\n+/* sibcall.  */\n+int func3 (int a, int b)\n+{\n+  /* scs push */\n+  asm volatile (\"\":::\"x30\");\n+\n+  return foo (a+b);\n+  /* scs pop */\n+}\n+\n+/* eh_return.  */\n+int func4 (long offset, void *handler)\n+{\n+  /* Do not emit scs push/pop */\n+  asm volatile (\"\":::\"x30\");\n+\n+  __builtin_eh_return (offset, handler);\n+}\n+\n+/* { dg-final { scan-assembler-times {str\\tx30, \\[x18\\], #?8} 2 } } */\n+/* { dg-final { scan-assembler-times {ldr\\tx30, \\[x18, #?-8\\]!} 2 } } */"}, {"sha": "f63169340e12585f09250164ba0e7dc932b3aa0b", "filename": "gcc/testsuite/gcc.target/aarch64/shadow_call_stack_4.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fshadow_call_stack_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fshadow_call_stack_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fshadow_call_stack_4.c?ref=ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e", "patch": "@@ -0,0 +1,20 @@\n+/* Testing the disable of shadow call stack.  */\n+/* scs_push: str x30, [x18], #8 */\n+/* scs_pop: ldr x30, [x18, #-8]! */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-omit-frame-pointer -fsanitize=shadow-call-stack -ffixed-x18 -fno-exceptions\" } */\n+\n+int foo (int);\n+\n+/* function disable shadow call stack.  */\n+int __attribute__((no_sanitize(\"shadow-call-stack\"))) func1 (void)\n+{\n+  asm volatile (\"\":::\"x30\");\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-not {str\\tx30, \\[x18\\], #?8} } } */\n+/* { dg-final { scan-assembler-not {ldr\\tx30, \\[x18, #?-8\\]!} } } */\n+/* { dg-final { scan-assembler-times {stp\\tx29, x30, \\[sp, -[0-9]+\\]!} 1 } } */\n+/* { dg-final { scan-assembler-times {ldp\\tx29, x30, \\[sp\\], [0-9]+} 1 } } */"}, {"sha": "d88357ca04dadde0eaf870c3eb2b3ec1cd4959b9", "filename": "gcc/testsuite/gcc.target/aarch64/shadow_call_stack_5.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fshadow_call_stack_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fshadow_call_stack_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fshadow_call_stack_5.c?ref=ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e", "patch": "@@ -0,0 +1,18 @@\n+/* Verify:\n+     * -fno-omit-frame-pointer -fsanitize=shadow-call-stack -fno-exceptions -ffixed-x18.\n+     * without outgoing.\n+     * total frame size <= 512 but > 256.\n+     * callee-saved reg: x29, x30.\n+     * optimized code should use \"stp\tx29, x30, [sp]\" to save frame chain.\n+     * optimized code should use \"ldr\tx29, [sp]\" to restore x29 only.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-omit-frame-pointer -fsanitize=shadow-call-stack -fno-exceptions -ffixed-x18 --save-temps\" } */\n+\n+#include \"test_frame_common.h\"\n+\n+t_frame_pattern (func1, 400, )\n+\n+/* { dg-final { scan-assembler-times {stp\\tx29, x30, \\[sp\\]} 1 } } */\n+/* { dg-final { scan-assembler {ldr\\tx29, \\[sp\\]} } } */\n+"}, {"sha": "83b74834c6a71a0b9a9745fb1e5975ed84872575", "filename": "gcc/testsuite/gcc.target/aarch64/shadow_call_stack_6.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fshadow_call_stack_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fshadow_call_stack_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fshadow_call_stack_6.c?ref=ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e", "patch": "@@ -0,0 +1,18 @@\n+/* Verify:\n+     * -fomit-frame-pointer -fsanitize=shadow-call-stack -fno-exceptions -ffixed-x18.\n+     * without outgoing.\n+     * total frame size <= 256.\n+     * callee-saved reg: x30 only.\n+     * optimized code should use \"str   x30, [sp]\" to save x30 in prologue.\n+     * optimized code should not restore x30 in epilogue.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fomit-frame-pointer -fsanitize=shadow-call-stack -fno-exceptions -ffixed-x18 --save-temps\" } */\n+\n+#include \"test_frame_common.h\"\n+\n+t_frame_pattern (func1, 200, )\n+\n+/* { dg-final { scan-assembler-times {str\\tx30, \\[sp\\]} 1 } } */\n+/* { dg-final { scan-assembler-not {ld[r|p]\\tx30, \\[sp} } } */\n+"}, {"sha": "5537fb3293aa9fd5059267bdbfc7d5b53e22fa8e", "filename": "gcc/testsuite/gcc.target/aarch64/shadow_call_stack_7.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fshadow_call_stack_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fshadow_call_stack_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fshadow_call_stack_7.c?ref=ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e", "patch": "@@ -0,0 +1,18 @@\n+/* Verify:\n+     * -fomit-frame-pointer -fsanitize=shadow-call-stack -fno-exceptions -ffixed-x18.\n+     * without outgoing.\n+     * total frame size <= 256.\n+     * callee-saved reg: x19, x30.\n+     * optimized code should use \"stp   x19, x30, [sp, -x]!\" to save x19, x30 in prologue.\n+     * optimized code should use \"ldr   x19, [sp], x\" to restore x19 only.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fomit-frame-pointer -fsanitize=shadow-call-stack -fno-exceptions -ffixed-x18 --save-temps\" } */\n+\n+#include \"test_frame_common.h\"\n+\n+t_frame_pattern (func1, 200, \"x19\")\n+\n+/* { dg-final { scan-assembler-times {stp\\tx19, x30, \\[sp, -[0-9]+\\]!} 1 } } */\n+/* { dg-final { scan-assembler {ldr\\tx19, \\[sp\\], [0-9]+} } } */\n+"}, {"sha": "b03f26f7bcfa95dfe03a3fea3fbe60beb6ff0873", "filename": "gcc/testsuite/gcc.target/aarch64/shadow_call_stack_8.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fshadow_call_stack_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fshadow_call_stack_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fshadow_call_stack_8.c?ref=ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e", "patch": "@@ -0,0 +1,24 @@\n+/* Verify:\n+     * -fomit-frame-pointer -fsanitize=shadow-call-stack -fno-exceptions -ffixed-x18.\n+     * without outgoing.\n+     * total frame <= 512 but > 256.\n+     * callee-saved reg: x19, x20, x30.\n+     * optimized code should use \"stp   x19, x20, [sp, -x]!\" to save x19, x20 in prologue.\n+     * optimized code should use \"str\tx30, [sp \" to save x30 in prologue.\n+     * optimized code should use \"ldp\tx19, x20, [sp], x\" to retore x19, x20 in epilogue.\n+     * optimized code should not restore x30 in epilogue.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -fomit-frame-pointer -fsanitize=shadow-call-stack -fno-exceptions -ffixed-x18 --save-temps\" } */\n+\n+int func1 (void)\n+{\n+  unsigned char a[200];\n+  __asm__ (\"\":::\"x19\",\"x20\",\"x30\");\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times {stp\\tx19, x20, \\[sp, -[0-9]+\\]!} 1 } } */\n+/* { dg-final { scan-assembler-times {str\\tx30, \\[sp} 1 } } */\n+/* { dg-final { scan-assembler {ldp\\tx19, x20, \\[sp\\], [0-9]+} } } */\n+/* { dg-final { scan-assembler-not {ld[r|p]\\tx30, \\[sp} } } */"}, {"sha": "2d432fb2d8464635c69518848e9467cba770b002", "filename": "gcc/toplev.cc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Ftoplev.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Ftoplev.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.cc?ref=ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e", "patch": "@@ -1679,6 +1679,16 @@ process_options (bool no_backend)\n       flag_sanitize &= ~SANITIZE_HWADDRESS;\n     }\n \n+  if (flag_sanitize & SANITIZE_SHADOW_CALL_STACK)\n+    {\n+      if (!targetm.have_shadow_call_stack)\n+\tsorry (\"%<-fsanitize=shadow-call-stack%> not supported \"\n+\t       \"in current platform\");\n+      else if (flag_exceptions)\n+\terror_at (UNKNOWN_LOCATION, \"%<-fsanitize=shadow-call-stack%> \"\n+\t\t  \"requires %<-fno-exceptions%>\");\n+    }\n+\n   HOST_WIDE_INT patch_area_size, patch_area_start;\n   parse_and_check_patch_area (flag_patchable_function_entry, false,\n \t\t\t      &patch_area_size, &patch_area_start);"}, {"sha": "a858994c841f89511c7d545f35db38b001ea40b2", "filename": "gcc/ubsan.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Fubsan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e/gcc%2Fubsan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.cc?ref=ce09ab17ddd21f73ff2caf6eec3b0ee9b0e1a11e", "patch": "@@ -832,8 +832,8 @@ ubsan_expand_null_ifn (gimple_stmt_iterator *gsip)\n   else\n     {\n       enum built_in_function bcode\n-\t= (flag_sanitize_recover & ((check_align ? SANITIZE_ALIGNMENT : 0)\n-\t\t\t\t    | (check_null ? SANITIZE_NULL : 0)))\n+\t= (flag_sanitize_recover & ((check_align ? SANITIZE_ALIGNMENT + 0 : 0)\n+\t\t\t\t    | (check_null ? SANITIZE_NULL + 0 : 0)))\n \t  ? BUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH_V1\n \t  : BUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH_V1_ABORT;\n       tree fn = builtin_decl_implicit (bcode);"}]}