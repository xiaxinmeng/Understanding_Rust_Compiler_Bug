{"sha": "703ad42b4be14b9b1e84816dede360721361ed86", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzAzYWQ0MmI0YmUxNGI5YjFlODQ4MTZkZWRlMzYwNzIxMzYxZWQ4Ng==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2003-07-19T14:47:15Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2003-07-19T14:47:15Z"}, "message": "alias.c [...]: Remove unnecessary casts.\n\n\t* alias.c alloc-pool.c bitmap.c bitmap.h bt-load.c builtins.c\n\tc-common.c c-decl.c c-incpath.c c-lex.c c-opts.c c-parse.in\n\tc-pragma.c c-typeck.c calls.c cfg.c cfganal.c cfgloop.c cfgrtl.c\n\tcollect2.c combine.c conflict.c coverage.c cppexp.c cppfiles.c\n\tcpphash.c cppinit.c cpplex.c cpplib.c cppmacro.c cppspec.c\n\tcpptrad.c cse.c cselib.c dbxout.c defaults.h df.c dominance.c\n\tdwarf2out.c dwarfout.c emit-rtl.c except.c expmed.c expr.c final.c\n\tfix-header.c flow.c fold-const.c function.c gcc.c gccspec.c gcov.c\n\tgcse.c genattr.c genattrtab.c genautomata.c genconditions.c\n\tgenemit.c genextract.c genoutput.c genrecog.c gensupport.c\n\tggc-page.c ggc-simple.c global.c graph.c haifa-sched.c hashtable.c\n\tintegrate.c jump.c langhooks.c lcm.c line-map.c local-alloc.c\n\tloop.c mips-tdump.c mips-tfile.c mkdeps.c optabs.c params.c\n\tpostreload.c prefix.c print-tree.c protoize.c ra-build.c\n\tra-colorize.c ra-rewrite.c ra.c recog.c reg-stack.c regclass.c\n\tregmove.c regrename.c reload.c reload1.c reorg.c resource.c\n\tsbitmap.c sched-deps.c sched-rgn.c sched-vis.c sdbout.c\n\tsimplify-rtx.c ssa-ccp.c ssa.c stmt.c stor-layout.c timevar.c\n\ttlink.c toplev.c tree-dump.c tree.c unroll.c unwind-dw2-fde.c\n\tvarasm.c varray.c vmsdbgout.c xcoffout.c: Remove unnecessary\n\tcasts.\n\nFrom-SVN: r69587", "tree": {"sha": "f3d03226f923b6c64639256ed34bd193427950a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3d03226f923b6c64639256ed34bd193427950a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/703ad42b4be14b9b1e84816dede360721361ed86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/703ad42b4be14b9b1e84816dede360721361ed86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/703ad42b4be14b9b1e84816dede360721361ed86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/703ad42b4be14b9b1e84816dede360721361ed86/comments", "author": null, "committer": null, "parents": [{"sha": "308ca868d327f306ac4b87741ed828a56e524fd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/308ca868d327f306ac4b87741ed828a56e524fd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/308ca868d327f306ac4b87741ed828a56e524fd0"}], "stats": {"total": 2107, "additions": 957, "deletions": 1150}, "files": [{"sha": "6bb655ae09f4fcc4bacc9ee65d3db0dffa1eb298", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -1,3 +1,27 @@\n+2003-07-19  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* alias.c alloc-pool.c bitmap.c bitmap.h bt-load.c builtins.c\n+\tc-common.c c-decl.c c-incpath.c c-lex.c c-opts.c c-parse.in\n+\tc-pragma.c c-typeck.c calls.c cfg.c cfganal.c cfgloop.c cfgrtl.c\n+\tcollect2.c combine.c conflict.c coverage.c cppexp.c cppfiles.c\n+\tcpphash.c cppinit.c cpplex.c cpplib.c cppmacro.c cppspec.c\n+\tcpptrad.c cse.c cselib.c dbxout.c defaults.h df.c dominance.c\n+\tdwarf2out.c dwarfout.c emit-rtl.c except.c expmed.c expr.c final.c\n+\tfix-header.c flow.c fold-const.c function.c gcc.c gccspec.c gcov.c\n+\tgcse.c genattr.c genattrtab.c genautomata.c genconditions.c\n+\tgenemit.c genextract.c genoutput.c genrecog.c gensupport.c\n+\tggc-page.c ggc-simple.c global.c graph.c haifa-sched.c hashtable.c\n+\tintegrate.c jump.c langhooks.c lcm.c line-map.c local-alloc.c\n+\tloop.c mips-tdump.c mips-tfile.c mkdeps.c optabs.c params.c\n+\tpostreload.c prefix.c print-tree.c protoize.c ra-build.c\n+\tra-colorize.c ra-rewrite.c ra.c recog.c reg-stack.c regclass.c\n+\tregmove.c regrename.c reload.c reload1.c reorg.c resource.c\n+\tsbitmap.c sched-deps.c sched-rgn.c sched-vis.c sdbout.c\n+\tsimplify-rtx.c ssa-ccp.c ssa.c stmt.c stor-layout.c timevar.c\n+\ttlink.c toplev.c tree-dump.c tree.c unroll.c unwind-dw2-fde.c\n+\tvarasm.c varray.c vmsdbgout.c xcoffout.c: Remove unnecessary\n+\tcasts.\n+\n 2003-07-19  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* c-pragma.c (apply_pragma_weak): Don't use warning_with_decl."}, {"sha": "edd8a3deb3f73eadc7080edc1b1e6ee522c9f876", "filename": "gcc/alias.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -632,8 +632,7 @@ record_alias_subset (HOST_WIDE_INT superset, HOST_WIDE_INT subset)\n     {\n       /* Create an entry for the SUPERSET, so that we have a place to\n \t attach the SUBSET.  */\n-      superset_entry\n-\t= (alias_set_entry) xmalloc (sizeof (struct alias_set_entry));\n+      superset_entry = xmalloc (sizeof (struct alias_set_entry));\n       superset_entry->alias_set = superset;\n       superset_entry->children\n \t= splay_tree_new (splay_tree_compare_ints, 0, 0);\n@@ -2717,17 +2716,16 @@ init_alias_analysis (void)\n      optimization.  Loop unrolling can create a large number of\n      registers.  */\n   reg_base_value_size = maxreg * 2;\n-  reg_base_value = (rtx *) ggc_alloc_cleared (reg_base_value_size\n-\t\t\t\t\t      * sizeof (rtx));\n+  reg_base_value = ggc_alloc_cleared (reg_base_value_size * sizeof (rtx));\n \n-  new_reg_base_value = (rtx *) xmalloc (reg_base_value_size * sizeof (rtx));\n-  reg_seen = (char *) xmalloc (reg_base_value_size);\n+  new_reg_base_value = xmalloc (reg_base_value_size * sizeof (rtx));\n+  reg_seen = xmalloc (reg_base_value_size);\n   if (! reload_completed && flag_old_unroll_loops)\n     {\n       /* ??? Why are we realloc'ing if we're just going to zero it?  */\n-      alias_invariant = (rtx *)xrealloc (alias_invariant,\n-\t\t\t\t\t reg_base_value_size * sizeof (rtx));\n-      memset ((char *)alias_invariant, 0, reg_base_value_size * sizeof (rtx));\n+      alias_invariant = xrealloc (alias_invariant,\n+\t\t\t\t  reg_base_value_size * sizeof (rtx));\n+      memset (alias_invariant, 0, reg_base_value_size * sizeof (rtx));\n     }\n \n   /* The basic idea is that each pass through this loop will use the\n@@ -2764,10 +2762,10 @@ init_alias_analysis (void)\n       copying_arguments = true;\n \n       /* Wipe the potential alias information clean for this pass.  */\n-      memset ((char *) new_reg_base_value, 0, reg_base_value_size * sizeof (rtx));\n+      memset (new_reg_base_value, 0, reg_base_value_size * sizeof (rtx));\n \n       /* Wipe the reg_seen array clean.  */\n-      memset ((char *) reg_seen, 0, reg_base_value_size);\n+      memset (reg_seen, 0, reg_base_value_size);\n \n       /* Mark all hard registers which may contain an address.\n \t The stack, frame and argument pointers may contain an address."}, {"sha": "d275cd86cff049b28f30b035941f056b482fa826", "filename": "gcc/alloc-pool.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Falloc-pool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Falloc-pool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -105,7 +105,7 @@ create_alloc_pool (const char *name, size_t size, size_t num)\n   pool_size = sizeof (struct alloc_pool_def);\n \n   /* and allocate that much memory.  */\n-  pool = (alloc_pool) xmalloc (pool_size);\n+  pool = xmalloc (pool_size);\n \n   /* Now init the various pieces of our pool structure.  */\n   pool->name = xstrdup (name);\n@@ -176,7 +176,7 @@ pool_alloc (alloc_pool pool)\n       alloc_pool_list block_header;\n \n       /* Make the block.  */\n-      block = (char *) xmalloc (pool->block_size);\n+      block = xmalloc (pool->block_size);\n       block_header = (alloc_pool_list) block;\n       block += align_eight (sizeof (struct alloc_pool_list_def));\n "}, {"sha": "84d4be2ec38c7f92a6663774bef305dfbe361124", "filename": "gcc/bitmap.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -131,8 +131,7 @@ bitmap_element_allocate (bitmap head)\n \t\t\t\t\t  obstack_chunk_free);\n \t    }\n \n-\t  element = (bitmap_element *) obstack_alloc (&bitmap_obstack,\n-\t\t\t\t\t\t      sizeof (bitmap_element));\n+\t  element = obstack_alloc (&bitmap_obstack, sizeof (bitmap_element));\n \t}\n     }\n   else"}, {"sha": "d722003488047100adf0144e2629217067b07c86", "filename": "gcc/bitmap.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -128,15 +128,15 @@ extern int bitmap_last_set_bit (bitmap);\n \n /* Allocate a bitmap with oballoc.  */\n #define BITMAP_OBSTACK_ALLOC(OBSTACK)\t\t\t\t\\\n-  bitmap_initialize ((bitmap) obstack_alloc (OBSTACK, sizeof (bitmap_head)), 1)\n+  bitmap_initialize (obstack_alloc (OBSTACK, sizeof (bitmap_head)), 1)\n \n /* Allocate a bitmap with ggc_alloc.  */\n #define BITMAP_GGC_ALLOC()\t\t\t\\\n   bitmap_initialize (NULL, 0)\n \n /* Allocate a bitmap with xmalloc.  */\n #define BITMAP_XMALLOC()                                        \\\n-  bitmap_initialize ((bitmap) xmalloc (sizeof (bitmap_head)), 1)\n+  bitmap_initialize (xmalloc (sizeof (bitmap_head)), 1)\n \n /* Do any cleanup needed on a bitmap when it is no longer used.  */\n #define BITMAP_FREE(BITMAP)\t\t\t\\"}, {"sha": "b3ba22b83eecdb9936f439a8b6069f8eb808ed04", "filename": "gcc/bt-load.c", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -277,9 +277,8 @@ find_btr_def_group (btr_def_group *all_btr_def_groups, btr_def def)\n \n       if (!this_group)\n \t{\n-\t  this_group = (btr_def_group)\n-\t    obstack_alloc (&migrate_btrl_obstack,\n-\t\t\t   sizeof (struct btr_def_group_s));\n+\t  this_group = obstack_alloc (&migrate_btrl_obstack,\n+\t\t\t\t      sizeof (struct btr_def_group_s));\n \t  this_group->src = def_src;\n \t  this_group->members = NULL;\n \t  this_group->next = *all_btr_def_groups;\n@@ -301,8 +300,8 @@ add_btr_def (fibheap_t all_btr_defs, basic_block bb, int insn_luid, rtx insn,\n \t     unsigned int dest_reg, int other_btr_uses_before_def,\n \t     btr_def_group *all_btr_def_groups)\n {\n-  btr_def this = (btr_def)\n-    obstack_alloc (&migrate_btrl_obstack, sizeof (struct btr_def_s));\n+  btr_def this\n+    = obstack_alloc (&migrate_btrl_obstack, sizeof (struct btr_def_s));\n   this->bb = bb;\n   this->luid = insn_luid;\n   this->insn = insn;\n@@ -353,8 +352,7 @@ new_btr_user (basic_block bb, int insn_luid, rtx insn)\n \tusep = NULL;\n     }\n   use = usep ? *usep : NULL_RTX;\n-  user = (btr_user)\n-    obstack_alloc (&migrate_btrl_obstack, sizeof (struct btr_user_s));\n+  user = obstack_alloc (&migrate_btrl_obstack, sizeof (struct btr_user_s));\n   user->bb = bb;\n   user->luid = insn_luid;\n   user->insn = insn;\n@@ -736,8 +734,7 @@ build_btr_def_use_webs (fibheap_t all_btr_defs)\n   sbitmap *btr_defset   = sbitmap_vector_alloc (\n \t\t\t   (last_btr - first_btr) + 1, max_uid);\n   sbitmap *bb_gen      = sbitmap_vector_alloc (n_basic_blocks, max_uid);\n-  HARD_REG_SET *btrs_written = (HARD_REG_SET *) xcalloc (\n-\t\t\t       n_basic_blocks, sizeof (HARD_REG_SET));\n+  HARD_REG_SET *btrs_written = xcalloc (n_basic_blocks, sizeof (HARD_REG_SET));\n   sbitmap *bb_kill;\n   sbitmap *bb_out;\n \n@@ -841,8 +838,7 @@ augment_live_range (bitmap live_range, HARD_REG_SET *btrs_live_in_range,\n {\n   basic_block *worklist, *tos;\n \n-  tos = worklist =\n-    (basic_block *) xmalloc (sizeof (basic_block) * (n_basic_blocks + 1));\n+  tos = worklist = xmalloc (sizeof (basic_block) * (n_basic_blocks + 1));\n \n   if (dominated_by_p (dom, new_bb, head_bb))\n     *tos++ = new_bb;\n@@ -1318,8 +1314,7 @@ migrate_btr_defs (enum reg_class btr_class, int allow_callee_save)\n \t  first_btr = reg;\n       }\n \n-  btrs_live =\n-    (HARD_REG_SET *) xcalloc (n_basic_blocks, sizeof (HARD_REG_SET));\n+  btrs_live = xcalloc (n_basic_blocks, sizeof (HARD_REG_SET));\n \n   build_btr_def_use_webs (all_btr_defs);\n "}, {"sha": "0a44edf064d96748d96c23b87fda39289877edf0", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -1082,7 +1082,7 @@ result_vector (int savep, rtx result)\n   int regno, size, align, nelts;\n   enum machine_mode mode;\n   rtx reg, mem;\n-  rtx *savevec = (rtx *) alloca (FIRST_PSEUDO_REGISTER * sizeof (rtx));\n+  rtx *savevec = alloca (FIRST_PSEUDO_REGISTER * sizeof (rtx));\n \n   size = nelts = 0;\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)"}, {"sha": "ed2c989d0580a142f813c8a3b7b7a1896d554490", "filename": "gcc/c-common.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -875,12 +875,12 @@ c_expand_start_cond (tree cond, int compstmt_count, tree if_stmt)\n   if (if_stack_space == 0)\n     {\n       if_stack_space = 10;\n-      if_stack = (if_elt *) xmalloc (10 * sizeof (if_elt));\n+      if_stack = xmalloc (10 * sizeof (if_elt));\n     }\n   else if (if_stack_space == if_stack_pointer)\n     {\n       if_stack_space += 10;\n-      if_stack = (if_elt *) xrealloc (if_stack, if_stack_space * sizeof (if_elt));\n+      if_stack = xrealloc (if_stack, if_stack_space * sizeof (if_elt));\n     }\n \n   IF_COND (if_stmt) = cond;\n@@ -1354,7 +1354,7 @@ static struct tlist *\n new_tlist (struct tlist *next, tree t, tree writer)\n {\n   struct tlist *l;\n-  l = (struct tlist *) obstack_alloc (&tlist_obstack, sizeof *l);\n+  l = obstack_alloc (&tlist_obstack, sizeof *l);\n   l->next = next;\n   l->expr = t;\n   l->writer = writer;\n@@ -1624,8 +1624,7 @@ verify_tree (tree x, struct tlist **pbefore_sp, struct tlist **pno_sp,\n \n \tif (! t)\n \t  {\n-\t    t = (struct tlist_cache *) obstack_alloc (&tlist_obstack,\n-\t\t\t\t\t\t      sizeof *t);\n+\t    t = obstack_alloc (&tlist_obstack, sizeof *t);\n \t    t->next = save_expr_cache;\n \t    t->expr = x;\n \t    save_expr_cache = t;\n@@ -4313,7 +4312,7 @@ c_expand_builtin_printf (tree arglist, rtx target, enum machine_mode tmode,\n \t  /* Create a NULL-terminated string that's one char shorter\n \t     than the original, stripping off the trailing '\\n'.  */\n \t  const int newlen = TREE_STRING_LENGTH (stripped_string) - 1;\n-\t  char *newstr = (char *) alloca (newlen);\n+\t  char *newstr = alloca (newlen);\n \t  memcpy (newstr, TREE_STRING_POINTER (stripped_string), newlen - 1);\n \t  newstr[newlen - 1] = 0;\n \n@@ -4877,7 +4876,7 @@ handle_mode_attribute (tree *node, tree name, tree args ATTRIBUTE_UNUSED,\n       if (len > 4 && p[0] == '_' && p[1] == '_'\n \t  && p[len - 1] == '_' && p[len - 2] == '_')\n \t{\n-\t  char *newp = (char *) alloca (len - 1);\n+\t  char *newp = alloca (len - 1);\n \n \t  strcpy (newp, &p[2]);\n \t  newp[len - 4] = '\\0';"}, {"sha": "bd3b76140cbcbca72c5539c0ec33cd141ebb4818", "filename": "gcc/c-decl.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -360,8 +360,7 @@ make_binding_level (void)\n       memset (result, 0, sizeof(struct binding_level));\n     }\n   else\n-    result = (struct binding_level *)\n-      ggc_alloc_cleared (sizeof (struct binding_level));\n+    result = ggc_alloc_cleared (sizeof (struct binding_level));\n \n   return result;\n }\n@@ -1732,8 +1731,7 @@ pushdecl (tree x)\n \n   /* Functions need the lang_decl data.  */\n   if (TREE_CODE (x) == FUNCTION_DECL && ! DECL_LANG_SPECIFIC (x))\n-    DECL_LANG_SPECIFIC (x) = (struct lang_decl *)\n-      ggc_alloc_cleared (sizeof (struct lang_decl));\n+    DECL_LANG_SPECIFIC (x) = ggc_alloc_cleared (sizeof (struct lang_decl));\n \n   /* A local extern declaration for a function doesn't constitute nesting.\n      A local auto declaration does, since it's a forward decl\n@@ -4375,8 +4373,8 @@ grokdeclarator (tree declarator, tree declspecs,\n \tdecl = build_decl (FUNCTION_DECL, declarator, type);\n \tdecl = build_decl_attribute_variant (decl, decl_attr);\n \n-\tDECL_LANG_SPECIFIC (decl) = (struct lang_decl *)\n-\t  ggc_alloc_cleared (sizeof (struct lang_decl));\n+\tDECL_LANG_SPECIFIC (decl)\n+\t  = ggc_alloc_cleared (sizeof (struct lang_decl));\n \n \tif (pedantic && type_quals && ! DECL_IN_SYSTEM_HEADER (decl))\n \t  pedwarn (\"ISO C forbids qualified function types\");\n@@ -6630,8 +6628,7 @@ void\n c_push_function_context (struct function *f)\n {\n   struct language_function *p;\n-  p = ((struct language_function *)\n-       ggc_alloc (sizeof (struct language_function)));\n+  p = ggc_alloc (sizeof (struct language_function));\n   f->language = p;\n \n   p->base.x_stmt_tree = c_stmt_tree;\n@@ -6694,9 +6691,8 @@ c_dup_lang_specific_decl (tree decl)\n   if (!DECL_LANG_SPECIFIC (decl))\n     return;\n \n-  ld = (struct lang_decl *) ggc_alloc (sizeof (struct lang_decl));\n-  memcpy ((char *) ld, (char *) DECL_LANG_SPECIFIC (decl),\n-\t  sizeof (struct lang_decl));\n+  ld = ggc_alloc (sizeof (struct lang_decl));\n+  memcpy (ld, DECL_LANG_SPECIFIC (decl), sizeof (struct lang_decl));\n   DECL_LANG_SPECIFIC (decl) = ld;\n }\n \n@@ -6943,7 +6939,7 @@ merge_translation_unit_decls (void)\n       if (TREE_PUBLIC (decl) && DECL_EXTERNAL (decl))\n \t{\n \t  tree global_decl;\n-\t  global_decl = (tree) htab_find (link_hash_table, decl);\n+\t  global_decl = htab_find (link_hash_table, decl);\n \t  \n \t  if (! global_decl)\n \t    continue;\n@@ -6967,7 +6963,7 @@ c_write_global_declarations(void)\n     {\n       tree globals = BLOCK_VARS (DECL_INITIAL (link));\n       int len = list_length (globals);\n-      tree *vec = (tree *) xmalloc (sizeof (tree) * len);\n+      tree *vec = xmalloc (sizeof (tree) * len);\n       int i;\n       tree decl;\n       "}, {"sha": "6ec42cc0bfdb885b386a897dd7c7d27ccd8fc1a7", "filename": "gcc/c-incpath.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fc-incpath.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fc-incpath.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-incpath.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -306,7 +306,7 @@ add_path (char *path, int chain, int cxx_aware)\n {\n   struct cpp_path *p;\n \n-  p = (struct cpp_path *) xmalloc (sizeof (struct cpp_path));\n+  p = xmalloc (sizeof (struct cpp_path));\n   p->next = NULL;\n   p->name = path;\n   if (chain == SYSTEM || chain == AFTER)"}, {"sha": "b6720da2b5bb388a6ce4b56a11565543623a205b", "filename": "gcc/c-lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -123,7 +123,7 @@ get_fileinfo (const char *name)\n   if (n)\n     return (struct c_fileinfo *) n->value;\n \n-  fi = (struct c_fileinfo *) xmalloc (sizeof (struct c_fileinfo));\n+  fi = xmalloc (sizeof (struct c_fileinfo));\n   fi->time = 0;\n   fi->interface_only = 0;\n   fi->interface_unknown = 1;"}, {"sha": "44b6c1abf1977b4348e25ba5faea95677195624c", "filename": "gcc/c-opts.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -220,8 +220,7 @@ c_common_init_options (unsigned int argc, const char **argv ATTRIBUTE_UNUSED)\n   flag_exceptions = c_dialect_cxx ();\n   warn_pointer_arith = c_dialect_cxx ();\n \n-  deferred_opts = (struct deferred_opt *)\n-    xmalloc (argc * sizeof (struct deferred_opt));\n+  deferred_opts = xmalloc (argc * sizeof (struct deferred_opt));\n \n   result = lang_flags[c_language];\n "}, {"sha": "a009895951ed1c630e6f690a7e1573f189465c8f", "filename": "gcc/c-parse.in", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -75,15 +75,13 @@ do {\t\t\t\t\t\t\t\t\t\\\n   newsize = *(YYSSZ) *= 2;\t\t\t\t\t\t\\\n   if (malloced_yyss)\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      newss = (short *)\t\t\t\t\t\t\t\\\n-\treally_call_realloc (*(SS), newsize * sizeof (short));\t\t\\\n-      newvs = (YYSTYPE *)\t\t\t\t\t\t\\\n-\treally_call_realloc (*(VS), newsize * sizeof (YYSTYPE));\t\\\n+      newss = really_call_realloc (*(SS), newsize * sizeof (short));\t\\\n+      newvs = really_call_realloc (*(VS), newsize * sizeof (YYSTYPE));\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      newss = (short *) really_call_malloc (newsize * sizeof (short));\t\\\n-      newvs = (YYSTYPE *) really_call_malloc (newsize * sizeof (YYSTYPE)); \\\n+      newss = really_call_malloc (newsize * sizeof (short));\t\t\\\n+      newvs = really_call_malloc (newsize * sizeof (YYSTYPE));\t\t\\\n       if (newss)\t\t\t\t\t\t\t\\\n         memcpy (newss, *(SS), (SSSIZE));\t\t\t\t\\\n       if (newvs)\t\t\t\t\t\t\t\\\n@@ -3524,7 +3522,7 @@ init_reswords (void)\n   if (!c_dialect_objc ())\n      mask |= D_OBJC;\n \n-  ridpointers = (tree *) ggc_calloc ((int) RID_MAX, sizeof (tree));\n+  ridpointers = ggc_calloc ((int) RID_MAX, sizeof (tree));\n   for (i = 0; i < N_reswords; i++)\n     {\n       /* If a keyword is disabled, do not enter it into the table"}, {"sha": "dc9573397ec7c7bf6ede667aa5224f6f0117b4be", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -74,7 +74,7 @@ push_alignment (int alignment, tree id)\n     {\n       align_stack * entry;\n \n-      entry = (align_stack *) ggc_alloc (sizeof (* entry));\n+      entry = ggc_alloc (sizeof (* entry));\n \n       entry->alignment  = alignment;\n       entry->num_pushes = 1;"}, {"sha": "1fea1c534597df652584fc0121413ac3deb8e9ed", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 19, "deletions": 26, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -3617,35 +3617,33 @@ warn_for_assignment (const char *msgid, const char *opname, tree function,\n \t    {\n \t      /* Function name is known; supply it.  */\n \t      const char *const argstring = _(\"passing arg of `%s'\");\n-\t      new_opname = (char *) alloca (IDENTIFIER_LENGTH (function)\n-\t\t\t\t\t    + strlen (argstring) + 1\n-\t\t\t\t\t    + 1);\n+\t      new_opname = alloca (IDENTIFIER_LENGTH (function)\n+\t\t\t\t   + strlen (argstring) + 1 + 1);\n \t      sprintf (new_opname, argstring,\n \t\t       IDENTIFIER_POINTER (function));\n \t    }\n \t  else\n \t    {\n \t      /* Function name unknown (call through ptr).  */\n \t      const char *const argnofun = _(\"passing arg of pointer to function\");\n-\t      new_opname = (char *) alloca (strlen (argnofun) + 1 + 1);\n+\t      new_opname = alloca (strlen (argnofun) + 1 + 1);\n \t      sprintf (new_opname, argnofun);\n \t    }\n \t}\n       else if (function)\n \t{\n \t  /* Function name is known; supply it.  */\n \t  const char *const argstring = _(\"passing arg %d of `%s'\");\n-\t  new_opname = (char *) alloca (IDENTIFIER_LENGTH (function)\n-\t\t\t\t\t+ strlen (argstring) + 1 + 25\n-\t\t\t\t\t/*%d*/ + 1);\n+\t  new_opname = alloca (IDENTIFIER_LENGTH (function)\n+\t\t\t       + strlen (argstring) + 1 + 25 /*%d*/ + 1);\n \t  sprintf (new_opname, argstring, argnum,\n \t\t   IDENTIFIER_POINTER (function));\n \t}\n       else\n \t{\n \t  /* Function name unknown (call through ptr); just give arg number.  */\n \t  const char *const argnofun = _(\"passing arg %d of pointer to function\");\n-\t  new_opname = (char *) alloca (strlen (argnofun) + 1 + 25 /*%d*/ + 1);\n+\t  new_opname = alloca (strlen (argnofun) + 1 + 25 /*%d*/ + 1);\n \t  sprintf (new_opname, argnofun, argnum);\n \t}\n       opname = new_opname;\n@@ -3777,12 +3775,10 @@ static int spelling_size;\t\t/* Size of the spelling stack.  */\n     {\t\t\t\t\t\t\t\t\t\\\n       spelling_size += 10;\t\t\t\t\t\t\\\n       if (spelling_base == 0)\t\t\t\t\t\t\\\n-\tspelling_base\t\t\t\t\t\t\t\\\n-\t  = (struct spelling *) xmalloc (spelling_size * sizeof (struct spelling));\t\\\n+\tspelling_base = xmalloc (spelling_size * sizeof (struct spelling)); \\\n       else\t\t\t\t\t\t\t\t\\\n-        spelling_base\t\t\t\t\t\t\t\\\n-\t  = (struct spelling *) xrealloc (spelling_base,\t\t\\\n-\t\t\t\t\t  spelling_size * sizeof (struct spelling));\t\\\n+        spelling_base = xrealloc (spelling_base,\t\t\\\n+\t\t\t\t  spelling_size * sizeof (struct spelling)); \\\n       RESTORE_SPELLING_DEPTH (depth);\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n@@ -3872,7 +3868,7 @@ error_init (const char *msgid)\n   char *ofwhat;\n \n   error (\"%s\", _(msgid));\n-  ofwhat = print_spelling ((char *) alloca (spelling_length () + 1));\n+  ofwhat = print_spelling (alloca (spelling_length () + 1));\n   if (*ofwhat)\n     error (\"(near initialization for `%s')\", ofwhat);\n }\n@@ -3887,7 +3883,7 @@ pedwarn_init (const char *msgid)\n   char *ofwhat;\n \n   pedwarn (\"%s\", _(msgid));\n-  ofwhat = print_spelling ((char *) alloca (spelling_length () + 1));\n+  ofwhat = print_spelling (alloca (spelling_length () + 1));\n   if (*ofwhat)\n     pedwarn (\"(near initialization for `%s')\", ofwhat);\n }\n@@ -3902,7 +3898,7 @@ warning_init (const char *msgid)\n   char *ofwhat;\n \n   warning (\"%s\", _(msgid));\n-  ofwhat = print_spelling ((char *) alloca (spelling_length () + 1));\n+  ofwhat = print_spelling (alloca (spelling_length () + 1));\n   if (*ofwhat)\n     warning (\"(near initialization for `%s')\", ofwhat);\n }\n@@ -4286,8 +4282,7 @@ void\n start_init (tree decl, tree asmspec_tree, int top_level)\n {\n   const char *locus;\n-  struct initializer_stack *p\n-    = (struct initializer_stack *) xmalloc (sizeof (struct initializer_stack));\n+  struct initializer_stack *p = xmalloc (sizeof (struct initializer_stack));\n   const char *asmspec = 0;\n \n   if (asmspec_tree)\n@@ -4387,8 +4382,7 @@ finish_init (void)\n void\n really_start_incremental_init (tree type)\n {\n-  struct constructor_stack *p\n-    = (struct constructor_stack *) xmalloc (sizeof (struct constructor_stack));\n+  struct constructor_stack *p = xmalloc (sizeof (struct constructor_stack));\n \n   if (type == 0)\n     type = TREE_TYPE (constructor_decl);\n@@ -4524,7 +4518,7 @@ push_init_level (int implicit)\n \tvalue = find_init_member (constructor_index);\n     }\n \n-  p = (struct constructor_stack *) xmalloc (sizeof (struct constructor_stack));\n+  p = xmalloc (sizeof (struct constructor_stack));\n   p->type = constructor_type;\n   p->fields = constructor_fields;\n   p->index = constructor_index;\n@@ -4908,8 +4902,7 @@ push_range_stack (tree range_end)\n {\n   struct constructor_range_stack *p;\n \n-  p = (struct constructor_range_stack *)\n-      ggc_alloc (sizeof (struct constructor_range_stack));\n+  p = ggc_alloc (sizeof (struct constructor_range_stack));\n   p->prev = constructor_range_stack;\n   p->next = 0;\n   p->fields = constructor_fields;\n@@ -5081,7 +5074,7 @@ add_pending_init (tree purpose, tree value)\n \t}\n     }\n \n-  r = (struct init_node *) ggc_alloc (sizeof (struct init_node));\n+  r = ggc_alloc (sizeof (struct init_node));\n   r->purpose = purpose;\n   r->value = value;\n \n@@ -6183,7 +6176,7 @@ c_expand_asm_operands (tree string, tree outputs, tree inputs,\n   int noutputs = list_length (outputs);\n   int i;\n   /* o[I] is the place that output number I should be written.  */\n-  tree *o = (tree *) alloca (noutputs * sizeof (tree));\n+  tree *o = alloca (noutputs * sizeof (tree));\n   tree tail;\n \n   /* Record the contents of OUTPUTS before it is modified.  */\n@@ -6381,7 +6374,7 @@ c_start_case (tree exp)\n     }\n \n   /* Add this new SWITCH_STMT to the stack.  */\n-  cs = (struct c_switch *) xmalloc (sizeof (*cs));\n+  cs = xmalloc (sizeof (*cs));\n   cs->switch_stmt = build_stmt (SWITCH_STMT, exp, NULL_TREE, orig_type);\n   cs->cases = splay_tree_new (case_compare, NULL, NULL);\n   cs->next = switch_stack;"}, {"sha": "7add542656f3067e27a0beb1a359749c0d88972e", "filename": "gcc/calls.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -942,8 +942,7 @@ store_unaligned_arguments_into_pseudos (struct arg_data *args, int num_actuals)\n \tint endian_correction = 0;\n \n \targs[i].n_aligned_regs = args[i].partial ? args[i].partial : nregs;\n-\targs[i].aligned_regs = (rtx *) xmalloc (sizeof (rtx)\n-\t\t\t\t\t\t* args[i].n_aligned_regs);\n+\targs[i].aligned_regs = xmalloc (sizeof (rtx) * args[i].n_aligned_regs);\n \n \t/* Structures smaller than a word are normally aligned to the\n \t   least significant byte.  On a BYTES_BIG_ENDIAN machine,\n@@ -2367,8 +2366,8 @@ expand_call (tree exp, rtx target, int ignore)\n   INIT_CUMULATIVE_ARGS (args_so_far, funtype, NULL_RTX, fndecl);\n \n   /* Make a vector to hold all the information about each arg.  */\n-  args = (struct arg_data *) alloca (num_actuals * sizeof (struct arg_data));\n-  memset ((char *) args, 0, num_actuals * sizeof (struct arg_data));\n+  args = alloca (num_actuals * sizeof (struct arg_data));\n+  memset (args, 0, num_actuals * sizeof (struct arg_data));\n \n   /* Build up entries in the ARGS array, compute the size of the\n      arguments into ARGS_SIZE, etc.  */\n@@ -2758,8 +2757,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t\t  highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n \t\t\t\t\t\t     needed);\n #endif\n-\t\t  stack_usage_map\n-\t\t    = (char *) alloca (highest_outgoing_arg_in_use);\n+\t\t  stack_usage_map = alloca (highest_outgoing_arg_in_use);\n \n \t\t  if (initial_highest_arg_in_use)\n \t\t    memcpy (stack_usage_map, initial_stack_usage_map,\n@@ -2864,8 +2862,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t\t    = stack_arg_under_construction;\n \t\t  stack_arg_under_construction = 0;\n \t\t  /* Make a new map for the new argument list.  */\n-\t\t  stack_usage_map = (char *)\n-\t\t    alloca (highest_outgoing_arg_in_use);\n+\t\t  stack_usage_map = alloca (highest_outgoing_arg_in_use);\n \t\t  memset (stack_usage_map, 0, highest_outgoing_arg_in_use);\n \t\t  highest_outgoing_arg_in_use = 0;\n \t\t}\n@@ -3659,8 +3656,8 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n      of the full argument passing conventions to limit complexity here since\n      library functions shouldn't have many args.  */\n \n-  argvec = (struct arg *) alloca ((nargs + 1) * sizeof (struct arg));\n-  memset ((char *) argvec, 0, (nargs + 1) * sizeof (struct arg));\n+  argvec = alloca ((nargs + 1) * sizeof (struct arg));\n+  memset (argvec, 0, (nargs + 1) * sizeof (struct arg));\n \n #ifdef INIT_CUMULATIVE_LIBCALL_ARGS\n   INIT_CUMULATIVE_LIBCALL_ARGS (args_so_far, outmode, fun);\n@@ -3895,7 +3892,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n       highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n \t\t\t\t\t needed);\n #endif\n-      stack_usage_map = (char *) alloca (highest_outgoing_arg_in_use);\n+      stack_usage_map = alloca (highest_outgoing_arg_in_use);\n \n       if (initial_highest_arg_in_use)\n \tmemcpy (stack_usage_map, initial_stack_usage_map,"}, {"sha": "779bc4fb79a5838d1b0988dcc8c6977381679e95", "filename": "gcc/cfg.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -155,15 +155,15 @@ init_flow (void)\n   if (!initialized)\n     {\n       gcc_obstack_init (&flow_obstack);\n-      flow_firstobj = (char *) obstack_alloc (&flow_obstack, 0);\n+      flow_firstobj = obstack_alloc (&flow_obstack, 0);\n       initialized = 1;\n     }\n   else\n     {\n       free_alloc_pool (bb_pool);\n       free_alloc_pool (edge_pool);\n       obstack_free (&flow_obstack, flow_firstobj);\n-      flow_firstobj = (char *) obstack_alloc (&flow_obstack, 0);\n+      flow_firstobj = obstack_alloc (&flow_obstack, 0);\n     }\n   bb_pool = create_alloc_pool (\"Basic block pool\",\n \t\t\t       sizeof (struct basic_block_def), 100);\n@@ -697,7 +697,7 @@ alloc_aux_for_blocks (int size)\n   /* Check whether AUX data are still allocated.  */\n   else if (first_block_aux_obj)\n     abort ();\n-  first_block_aux_obj = (char *) obstack_alloc (&block_aux_obstack, 0);\n+  first_block_aux_obj = obstack_alloc (&block_aux_obstack, 0);\n   if (size)\n     {\n       basic_block bb;\n@@ -763,7 +763,7 @@ alloc_aux_for_edges (int size)\n   else if (first_edge_aux_obj)\n     abort ();\n \n-  first_edge_aux_obj = (char *) obstack_alloc (&edge_aux_obstack, 0);\n+  first_edge_aux_obj = obstack_alloc (&edge_aux_obstack, 0);\n   if (size)\n     {\n       basic_block bb;\n@@ -819,9 +819,8 @@ verify_flow_info (void)\n   basic_block bb, last_bb_seen;\n   basic_block *last_visited;\n \n-  last_visited = (basic_block *) xcalloc (last_basic_block + 2,\n-\t\t\t\t\t  sizeof (basic_block));\n-  edge_checksum = (size_t *) xcalloc (last_basic_block + 2, sizeof (size_t));\n+  last_visited = xcalloc (last_basic_block + 2, sizeof (basic_block));\n+  edge_checksum = xcalloc (last_basic_block + 2, sizeof (size_t));\n \n   /* Check bb chain & numbers.  */\n   last_bb_seen = ENTRY_BLOCK_PTR;"}, {"sha": "e45b48465e2c1539dc66ebeeebc892ce26697ded", "filename": "gcc/cfganal.c", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -139,11 +139,11 @@ mark_dfs_back_edges (void)\n   bool found = false;\n \n   /* Allocate the preorder and postorder number arrays.  */\n-  pre = (int *) xcalloc (last_basic_block, sizeof (int));\n-  post = (int *) xcalloc (last_basic_block, sizeof (int));\n+  pre = xcalloc (last_basic_block, sizeof (int));\n+  post = xcalloc (last_basic_block, sizeof (int));\n \n   /* Allocate stack for back-tracking up CFG.  */\n-  stack = (edge *) xmalloc ((n_basic_blocks + 1) * sizeof (edge));\n+  stack = xmalloc ((n_basic_blocks + 1) * sizeof (edge));\n   sp = 0;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n@@ -402,8 +402,7 @@ find_unreachable_blocks (void)\n   edge e;\n   basic_block *tos, *worklist, bb;\n \n-  tos = worklist =\n-\t(basic_block *) xmalloc (sizeof (basic_block) * n_basic_blocks);\n+  tos = worklist = xmalloc (sizeof (basic_block) * n_basic_blocks);\n \n   /* Clear all the reachability flags.  */\n \n@@ -473,10 +472,10 @@ create_edge_list (void)\n \tnum_edges++;\n     }\n \n-  elist = (struct edge_list *) xmalloc (sizeof (struct edge_list));\n+  elist = xmalloc (sizeof (struct edge_list));\n   elist->num_blocks = block_count;\n   elist->num_edges = num_edges;\n-  elist->index_to_edge = (edge *) xmalloc (sizeof (edge) * num_edges);\n+  elist->index_to_edge = xmalloc (sizeof (edge) * num_edges);\n \n   num_edges = 0;\n \n@@ -735,7 +734,7 @@ flow_reverse_top_sort_order_compute (int *rts_order)\n   sbitmap visited;\n \n   /* Allocate stack for back-tracking up CFG.  */\n-  stack = (edge *) xmalloc ((n_basic_blocks + 1) * sizeof (edge));\n+  stack = xmalloc ((n_basic_blocks + 1) * sizeof (edge));\n   sp = 0;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n@@ -804,7 +803,7 @@ flow_depth_first_order_compute (int *dfs_order, int *rc_order)\n   sbitmap visited;\n \n   /* Allocate stack for back-tracking up CFG.  */\n-  stack = (edge *) xmalloc ((n_basic_blocks + 1) * sizeof (edge));\n+  stack = xmalloc ((n_basic_blocks + 1) * sizeof (edge));\n   sp = 0;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n@@ -909,12 +908,11 @@ flow_preorder_transversal_compute (int *pot_order)\n   basic_block bb;\n \n   /* Allocate stack for back-tracking up CFG.  */\n-  stack = (edge *) xmalloc ((n_basic_blocks + 1) * sizeof (edge));\n+  stack = xmalloc ((n_basic_blocks + 1) * sizeof (edge));\n   sp = 0;\n \n   /* Allocate the tree.  */\n-  dfst = (struct dfst_node *) xcalloc (last_basic_block,\n-\t\t\t\t       sizeof (struct dfst_node));\n+  dfst = xcalloc (last_basic_block, sizeof (struct dfst_node));\n \n   FOR_EACH_BB (bb)\n     {\n@@ -924,9 +922,7 @@ flow_preorder_transversal_compute (int *pot_order)\n \n       dfst[bb->index].node\n \t= (max_successors\n-\t   ? (struct dfst_node **) xcalloc (max_successors,\n-\t\t\t\t\t    sizeof (struct dfst_node *))\n-\t   : NULL);\n+\t   ? xcalloc (max_successors, sizeof (struct dfst_node *)) : NULL);\n     }\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n@@ -1038,8 +1034,8 @@ static void\n flow_dfs_compute_reverse_init (depth_first_search_ds data)\n {\n   /* Allocate stack for back-tracking up CFG.  */\n-  data->stack = (basic_block *) xmalloc ((n_basic_blocks - (INVALID_BLOCK + 1))\n-\t\t\t\t\t * sizeof (basic_block));\n+  data->stack = xmalloc ((n_basic_blocks - (INVALID_BLOCK + 1))\n+\t\t\t * sizeof (basic_block));\n   data->sp = 0;\n \n   /* Allocate bitmap to track nodes that have been visited.  */"}, {"sha": "2f3ff3e4513dae19d65d5a448d540e71695b18b3", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -241,7 +241,7 @@ flow_loop_entry_edges_find (struct loop *loop)\n   if (! num_entries)\n     abort ();\n \n-  loop->entry_edges = (edge *) xmalloc (num_entries * sizeof (edge *));\n+  loop->entry_edges = xmalloc (num_entries * sizeof (edge *));\n \n   num_entries = 0;\n   for (e = loop->header->pred; e; e = e->pred_next)\n@@ -288,7 +288,7 @@ flow_loop_exit_edges_find (struct loop *loop)\n       return;\n     }\n \n-  loop->exit_edges = (edge *) xmalloc (num_exits * sizeof (edge *));\n+  loop->exit_edges = xmalloc (num_exits * sizeof (edge *));\n \n   /* Store all exiting edges into an array.  */\n   num_exits = 0;\n@@ -322,7 +322,7 @@ flow_loop_nodes_find (basic_block header, struct loop *loop)\n \n   if (loop->latch->loop_father != loop)\n     {\n-      stack = (basic_block *) xmalloc (n_basic_blocks * sizeof (basic_block));\n+      stack = xmalloc (n_basic_blocks * sizeof (basic_block));\n       sp = 0;\n       num_nodes++;\n       stack[sp++] = loop->latch;\n@@ -380,7 +380,7 @@ flow_loop_pre_header_scan (struct loop *loop)\n        num++)\n     ebb = ebb->pred->src;\n \n-  loop->pre_header_edges = (edge *) xmalloc (num * sizeof (edge));\n+  loop->pre_header_edges = xmalloc (num * sizeof (edge));\n   loop->num_pre_header_edges = num;\n \n   /* Store edges in order that they are followed.  The source of the first edge\n@@ -817,7 +817,7 @@ flow_loops_find (struct loops *loops, int flags)\n     }\n \n   /* Allocate loop structures.  */\n-  loops->parray = (struct loop **) xcalloc (num_loops + 1, sizeof (struct loop *));\n+  loops->parray = xcalloc (num_loops + 1, sizeof (struct loop *));\n \n   /* Dummy loop containing whole function.  */\n   loops->parray[0] = xcalloc (1, sizeof (struct loop));\n@@ -844,8 +844,8 @@ flow_loops_find (struct loops *loops, int flags)\n     {\n       /* Compute depth first search order of the CFG so that outer\n \t natural loops will be found before inner natural loops.  */\n-      dfs_order = (int *) xmalloc (n_basic_blocks * sizeof (int));\n-      rc_order = (int *) xmalloc (n_basic_blocks * sizeof (int));\n+      dfs_order = xmalloc (n_basic_blocks * sizeof (int));\n+      rc_order = xmalloc (n_basic_blocks * sizeof (int));\n       flow_depth_first_order_compute (dfs_order, rc_order);\n \n       /* Save CFG derived information to avoid recomputing it.  */"}, {"sha": "45ca18987ca8fcfef80392a090275359742d23eb", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -1721,12 +1721,9 @@ print_rtl_with_bb (FILE *outf, rtx rtx_first)\n     {\n       enum bb_state { NOT_IN_BB, IN_ONE_BB, IN_MULTIPLE_BB };\n       int max_uid = get_max_uid ();\n-      basic_block *start\n-\t= (basic_block *) xcalloc (max_uid, sizeof (basic_block));\n-      basic_block *end\n-\t= (basic_block *) xcalloc (max_uid, sizeof (basic_block));\n-      enum bb_state *in_bb_p\n-\t= (enum bb_state *) xcalloc (max_uid, sizeof (enum bb_state));\n+      basic_block *start = xcalloc (max_uid, sizeof (basic_block));\n+      basic_block *end = xcalloc (max_uid, sizeof (basic_block));\n+      enum bb_state *in_bb_p = xcalloc (max_uid, sizeof (enum bb_state));\n \n       basic_block bb;\n \n@@ -1832,7 +1829,7 @@ rtl_verify_flow_info_1 (void)\n   int err = 0;\n   basic_block bb, last_bb_seen;\n \n-  bb_info = (basic_block *) xcalloc (max_uid, sizeof (basic_block));\n+  bb_info = xcalloc (max_uid, sizeof (basic_block));\n \n   /* Check bb chain & numbers.  */\n   last_bb_seen = ENTRY_BLOCK_PTR;"}, {"sha": "356eda96f6b56d16ad5e4cd3d2e7e127212b0373", "filename": "gcc/collect2.c", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -689,7 +689,7 @@ add_prefix (struct path_prefix *pprefix, const char *prefix)\n   if (len > pprefix->max_len)\n     pprefix->max_len = len;\n \n-  pl = (struct prefix_list *) xmalloc (sizeof (struct prefix_list));\n+  pl = xmalloc (sizeof (struct prefix_list));\n   pl->prefix = xstrdup (prefix);\n \n   if (*prev)\n@@ -716,7 +716,7 @@ static void\n prefix_from_string (const char *p, struct path_prefix *pprefix)\n {\n   const char *startp, *endp;\n-  char *nstore = (char *) xmalloc (strlen (p) + 3);\n+  char *nstore = xmalloc (strlen (p) + 3);\n \n   if (debug)\n     fprintf (stderr, \"Convert string '%s' into prefixes, separator = '%c'\\n\", p, PATH_SEPARATOR);\n@@ -838,9 +838,9 @@ main (int argc, char **argv)\n   /* Do not invoke xcalloc before this point, since locale needs to be\n      set first, in case a diagnostic is issued.  */\n \n-  ld1 = (const char **)(ld1_argv = (char **) xcalloc(sizeof (char *), argc+3));\n-  ld2 = (const char **)(ld2_argv = (char **) xcalloc(sizeof (char *), argc+10));\n-  object = (const char **)(object_lst = (char **) xcalloc(sizeof (char *), argc));\n+  ld1 = (const char **)(ld1_argv = xcalloc(sizeof (char *), argc+3));\n+  ld2 = (const char **)(ld2_argv = xcalloc(sizeof (char *), argc+10));\n+  object = (const char **)(object_lst = xcalloc(sizeof (char *), argc));\n \n #ifdef DEBUG\n   debug = 1;\n@@ -865,7 +865,7 @@ main (int argc, char **argv)\n #endif\n \n   obstack_begin (&temporary_obstack, 0);\n-  temporary_firstobj = (char *) obstack_alloc (&temporary_obstack, 0);\n+  temporary_firstobj = obstack_alloc (&temporary_obstack, 0);\n \n   current_demangling_style = auto_demangling;\n   p = getenv (\"COLLECT_GCC_OPTIONS\");\n@@ -880,8 +880,7 @@ main (int argc, char **argv)\n   /* -fno-exceptions -w */\n   num_c_args += 2;\n \n-  c_ptr = (const char **)\n-    (c_argv = (char **) xcalloc (sizeof (char *), num_c_args));\n+  c_ptr = (const char **) (c_argv = xcalloc (sizeof (char *), num_c_args));\n \n   if (argc < 2)\n     fatal (\"no arguments\");\n@@ -1337,7 +1336,7 @@ main (int argc, char **argv)\n       /* Strip now if it was requested on the command line.  */\n       if (strip_flag)\n \t{\n-\t  char **real_strip_argv = (char **) xcalloc (sizeof (char *), 3);\n+\t  char **real_strip_argv = xcalloc (sizeof (char *), 3);\n \t  const char ** strip_argv = (const char **) real_strip_argv;\n \n \t  strip_argv[0] = strip_file_name;\n@@ -1579,8 +1578,7 @@ static long sequence_number = 0;\n static void\n add_to_list (struct head *head_ptr, const char *name)\n {\n-  struct id *newid\n-    = (struct id *) xcalloc (sizeof (struct id) + strlen (name), 1);\n+  struct id *newid = xcalloc (sizeof (struct id) + strlen (name), 1);\n   struct id *p;\n   strcpy (newid->name, name);\n \n@@ -2278,7 +2276,7 @@ locatelib (const char *name)\n \t      cnt++;\n \t  q = xstrdup (p);\n \t}\n-      l = (const char **) xmalloc ((cnt + 3) * sizeof (char *));\n+      l = xmalloc ((cnt + 3) * sizeof (char *));\n       pp = l;\n       if (ldr)\n \t{"}, {"sha": "bf356e9be39a26876a5949bca42ebe32977234d6", "filename": "gcc/combine.c", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -456,7 +456,7 @@ do_SUBST (rtx *into, rtx newval)\n   if (undobuf.frees)\n     buf = undobuf.frees, undobuf.frees = buf->next;\n   else\n-    buf = (struct undo *) xmalloc (sizeof (struct undo));\n+    buf = xmalloc (sizeof (struct undo));\n \n   buf->is_int = 0;\n   buf->where.r = into;\n@@ -484,7 +484,7 @@ do_SUBST_INT (int *into, int newval)\n   if (undobuf.frees)\n     buf = undobuf.frees, undobuf.frees = buf->next;\n   else\n-    buf = (struct undo *) xmalloc (sizeof (struct undo));\n+    buf = xmalloc (sizeof (struct undo));\n \n   buf->is_int = 1;\n   buf->where.i = into;\n@@ -520,23 +520,18 @@ combine_instructions (rtx f, unsigned int nregs)\n \n   combine_max_regno = nregs;\n \n-  reg_nonzero_bits = ((unsigned HOST_WIDE_INT *)\n-\t\t      xcalloc (nregs, sizeof (unsigned HOST_WIDE_INT)));\n-  reg_sign_bit_copies\n-    = (unsigned char *) xcalloc (nregs, sizeof (unsigned char));\n-\n-  reg_last_death = (rtx *) xmalloc (nregs * sizeof (rtx));\n-  reg_last_set = (rtx *) xmalloc (nregs * sizeof (rtx));\n-  reg_last_set_value = (rtx *) xmalloc (nregs * sizeof (rtx));\n-  reg_last_set_table_tick = (int *) xmalloc (nregs * sizeof (int));\n-  reg_last_set_label = (int *) xmalloc (nregs * sizeof (int));\n-  reg_last_set_invalid = (char *) xmalloc (nregs * sizeof (char));\n-  reg_last_set_mode\n-    = (enum machine_mode *) xmalloc (nregs * sizeof (enum machine_mode));\n-  reg_last_set_nonzero_bits\n-    = (unsigned HOST_WIDE_INT *) xmalloc (nregs * sizeof (HOST_WIDE_INT));\n-  reg_last_set_sign_bit_copies\n-    = (char *) xmalloc (nregs * sizeof (char));\n+  reg_nonzero_bits = xcalloc (nregs, sizeof (unsigned HOST_WIDE_INT));\n+  reg_sign_bit_copies = xcalloc (nregs, sizeof (unsigned char));\n+\n+  reg_last_death = xmalloc (nregs * sizeof (rtx));\n+  reg_last_set = xmalloc (nregs * sizeof (rtx));\n+  reg_last_set_value = xmalloc (nregs * sizeof (rtx));\n+  reg_last_set_table_tick = xmalloc (nregs * sizeof (int));\n+  reg_last_set_label = xmalloc (nregs * sizeof (int));\n+  reg_last_set_invalid = xmalloc (nregs * sizeof (char));\n+  reg_last_set_mode = xmalloc (nregs * sizeof (enum machine_mode));\n+  reg_last_set_nonzero_bits = xmalloc (nregs * sizeof (HOST_WIDE_INT));\n+  reg_last_set_sign_bit_copies = xmalloc (nregs * sizeof (char));\n \n   init_reg_last_arrays ();\n \n@@ -548,7 +543,7 @@ combine_instructions (rtx f, unsigned int nregs)\n     if (INSN_UID (insn) > i)\n       i = INSN_UID (insn);\n \n-  uid_cuid = (int *) xmalloc ((i + 1) * sizeof (int));\n+  uid_cuid = xmalloc ((i + 1) * sizeof (int));\n   max_uid_cuid = i;\n \n   nonzero_bits_mode = mode_for_size (HOST_BITS_PER_WIDE_INT, MODE_INT, 0);\n@@ -788,14 +783,14 @@ init_reg_last_arrays (void)\n {\n   unsigned int nregs = combine_max_regno;\n \n-  memset ((char *) reg_last_death, 0, nregs * sizeof (rtx));\n-  memset ((char *) reg_last_set, 0, nregs * sizeof (rtx));\n-  memset ((char *) reg_last_set_value, 0, nregs * sizeof (rtx));\n-  memset ((char *) reg_last_set_table_tick, 0, nregs * sizeof (int));\n-  memset ((char *) reg_last_set_label, 0, nregs * sizeof (int));\n+  memset (reg_last_death, 0, nregs * sizeof (rtx));\n+  memset (reg_last_set, 0, nregs * sizeof (rtx));\n+  memset (reg_last_set_value, 0, nregs * sizeof (rtx));\n+  memset (reg_last_set_table_tick, 0, nregs * sizeof (int));\n+  memset (reg_last_set_label, 0, nregs * sizeof (int));\n   memset (reg_last_set_invalid, 0, nregs * sizeof (char));\n-  memset ((char *) reg_last_set_mode, 0, nregs * sizeof (enum machine_mode));\n-  memset ((char *) reg_last_set_nonzero_bits, 0, nregs * sizeof (HOST_WIDE_INT));\n+  memset (reg_last_set_mode, 0, nregs * sizeof (enum machine_mode));\n+  memset (reg_last_set_nonzero_bits, 0, nregs * sizeof (HOST_WIDE_INT));\n   memset (reg_last_set_sign_bit_copies, 0, nregs * sizeof (char));\n }\n \f"}, {"sha": "9b637737411826143e60454f3eedbf642b40cd48", "filename": "gcc/conflict.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fconflict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fconflict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconflict.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -148,8 +148,7 @@ arc_eq (const void *arcp1, const void *arcp2)\n conflict_graph\n conflict_graph_new (int num_regs)\n {\n-  conflict_graph graph\n-    = (conflict_graph) xmalloc (sizeof (struct conflict_graph_def));\n+  conflict_graph graph = xmalloc (sizeof (struct conflict_graph_def));\n   graph->num_regs = num_regs;\n \n   /* Set up the hash table.  No delete action is specified; memory\n@@ -161,8 +160,7 @@ conflict_graph_new (int num_regs)\n   obstack_init (&graph->arc_obstack);\n \t     \n   /* Create and zero the lookup table by register number.  */\n-  graph->neighbor_heads\n-    = (conflict_graph_arc *) xmalloc (num_regs * sizeof (conflict_graph_arc));\n+  graph->neighbor_heads = xmalloc (num_regs * sizeof (conflict_graph_arc));\n \n   memset (graph->neighbor_heads, 0, num_regs * sizeof (conflict_graph_arc));\n   return graph;\n@@ -206,8 +204,7 @@ conflict_graph_add (conflict_graph graph, int reg1, int reg2)\n \n   /* Allocate an arc.  */\n   arc\n-    = (conflict_graph_arc)\n-      obstack_alloc (&graph->arc_obstack,\n+    = obstack_alloc (&graph->arc_obstack,\n \t\t     sizeof (struct conflict_graph_arc_def));\n   \n   /* Record the reg numbers.  */"}, {"sha": "6facdce39f695db4044f2f30bb8ab88f47fc3c07", "filename": "gcc/coverage.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -888,12 +888,12 @@ coverage_init (const char *filename)\n   int len = strlen (filename);\n \n   /* Name of da file.  */\n-  da_file_name = (char *) xmalloc (len + strlen (GCOV_DATA_SUFFIX) + 1);\n+  da_file_name = xmalloc (len + strlen (GCOV_DATA_SUFFIX) + 1);\n   strcpy (da_file_name, filename);\n   strcat (da_file_name, GCOV_DATA_SUFFIX);\n \n   /* Name of bbg file.  */\n-  bbg_file_name = (char *) xmalloc (len + strlen (GCOV_NOTE_SUFFIX) + 1);\n+  bbg_file_name = xmalloc (len + strlen (GCOV_NOTE_SUFFIX) + 1);\n   strcpy (bbg_file_name, filename);\n   strcat (bbg_file_name, GCOV_NOTE_SUFFIX);\n "}, {"sha": "ef2c1ea07124a6bf02eb0af0a58b3e4349d2e973", "filename": "gcc/cppexp.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -966,8 +966,7 @@ _cpp_expand_op_stack (cpp_reader *pfile)\n   size_t old_size = (size_t) (pfile->op_limit - pfile->op_stack);\n   size_t new_size = old_size * 2 + 20;\n \n-  pfile->op_stack = (struct op *) xrealloc (pfile->op_stack,\n-\t\t\t\t\t    new_size * sizeof (struct op));\n+  pfile->op_stack = xrealloc (pfile->op_stack, new_size * sizeof (struct op));\n   pfile->op_limit = pfile->op_stack + new_size;\n \n   return pfile->op_stack + old_size;"}, {"sha": "55eaed3d8c14b322240eeb81c507fae48ae396a8", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -459,7 +459,7 @@ read_include_file (cpp_reader *pfile, struct include_file *inc)\n       size = inc->st.st_size;\n \n \t{\n-\t  buf = (uchar *) xmalloc (size + 1);\n+\t  buf = xmalloc (size + 1);\n \t  offset = 0;\n \t  while (offset < size)\n \t    {\n@@ -494,7 +494,7 @@ read_include_file (cpp_reader *pfile, struct include_file *inc)\n \t bigger than the majority of C source files.  */\n       size = 8 * 1024;\n \n-      buf = (uchar *) xmalloc (size + 1);\n+      buf = xmalloc (size + 1);\n       offset = 0;\n       while ((count = read (inc->fd, buf + offset, size - offset)) > 0)\n \t{\n@@ -553,7 +553,7 @@ cpp_included (cpp_reader *pfile, const char *fname)\n     }\n \n   /* Search directory path for the file.  */\n-  name = (char *) alloca (strlen (fname) + pfile->max_include_len + 2);\n+  name = alloca (strlen (fname) + pfile->max_include_len + 2);\n   for (path = pfile->quote_include; path; path = path->next)\n     {\n       memcpy (name, path->name, path->len);\n@@ -611,7 +611,7 @@ find_include_file (cpp_reader *pfile, const char *fname, int angle_brackets,\n     }\n \n   /* Search directory path for the file.  */\n-  name = (char *) alloca (strlen (fname) + pfile->max_include_len + 2);\n+  name = alloca (strlen (fname) + pfile->max_include_len + 2);\n   for (; path; path = path->next)\n     {\n       int len = path->len;\n@@ -924,14 +924,13 @@ read_name_map (cpp_reader *pfile, const char *dirname)\n     if (! strcmp (map_list_ptr->map_list_name, dirname))\n       return map_list_ptr->map_list_map;\n \n-  map_list_ptr = ((struct file_name_map_list *)\n-\t\t  xmalloc (sizeof (struct file_name_map_list)));\n+  map_list_ptr = xmalloc (sizeof (struct file_name_map_list));\n   map_list_ptr->map_list_name = xstrdup (dirname);\n \n   /* The end of the list ends in NULL.  */\n   map_list_ptr->map_list_map = NULL;\n \n-  name = (char *) alloca (strlen (dirname) + strlen (FILE_NAME_MAP_FILE) + 2);\n+  name = alloca (strlen (dirname) + strlen (FILE_NAME_MAP_FILE) + 2);\n   strcpy (name, dirname);\n   if (*dirname)\n     strcat (name, \"/\");\n@@ -955,8 +954,7 @@ read_name_map (cpp_reader *pfile, const char *dirname)\n \t    ;\n \t  to = read_filename_string (ch, f);\n \n-\t  ptr = ((struct file_name_map *)\n-\t\t xmalloc (sizeof (struct file_name_map)));\n+\t  ptr = xmalloc (sizeof (struct file_name_map));\n \t  ptr->map_from = from;\n \n \t  /* Make the real filename absolute.  */\n@@ -1025,7 +1023,7 @@ remap_filename (cpp_reader *pfile, char *name, struct cpp_path *loc)\n   if (p == name)\n     cpp_error (pfile, DL_ICE, \"absolute file name in remap_filename\");\n \n-  dir = (char *) alloca (p - name + 1);\n+  dir = alloca (p - name + 1);\n   memcpy (dir, name, p - name);\n   dir[p - name] = '\\0';\n   from = p + 1;"}, {"sha": "1e07f41f7ac332c11b536c856a0920284c0e5d06", "filename": "gcc/cpphash.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -37,8 +37,7 @@ alloc_node (hash_table *table)\n {\n   cpp_hashnode *node;\n \n-  node = (cpp_hashnode *) obstack_alloc (&table->pfile->hash_ob,\n-\t\t\t\t\t sizeof (cpp_hashnode));\n+  node = obstack_alloc (&table->pfile->hash_ob, sizeof (cpp_hashnode));\n   memset (node, 0, sizeof (cpp_hashnode));\n   return node;\n }"}, {"sha": "d019ee83ed04a440a0fe2ce3fbe58a1753d127ee", "filename": "gcc/cppinit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -130,7 +130,7 @@ cpp_create_reader (enum c_lang lang, hash_table *table)\n   /* Initialize this instance of the library if it hasn't been already.  */\n   init_library ();\n \n-  pfile = (cpp_reader *) xcalloc (1, sizeof (cpp_reader));\n+  pfile = xcalloc (1, sizeof (cpp_reader));\n \n   cpp_set_lang (pfile, lang);\n   CPP_OPTION (pfile, warn_import) = 1;"}, {"sha": "025d72986fb1f34d40c403c4fd7a9aa40ea24fa2", "filename": "gcc/cpplex.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -88,8 +88,8 @@ add_line_note (cpp_buffer *buffer, const uchar *pos, unsigned int type)\n   if (buffer->notes_used == buffer->notes_cap)\n     {\n       buffer->notes_cap = buffer->notes_cap * 2 + 200;\n-      buffer->notes = (_cpp_line_note *)\n-\txrealloc (buffer->notes, buffer->notes_cap * sizeof (_cpp_line_note));\n+      buffer->notes = xrealloc (buffer->notes,\n+\t\t\t\tbuffer->notes_cap * sizeof (_cpp_line_note));\n     }\n \n   buffer->notes[buffer->notes_used].pos = pos;"}, {"sha": "69a1169c8e2fa6f6f0f0ece9e87bed508a550583", "filename": "gcc/cpplib.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -1805,7 +1805,7 @@ cpp_define (cpp_reader *pfile, const char *str)\n      tack \" 1\" on the end.  */\n \n   count = strlen (str);\n-  buf = (char *) alloca (count + 3);\n+  buf = alloca (count + 3);\n   memcpy (buf, str, count);\n \n   p = strchr (str, '=');\n@@ -1866,7 +1866,7 @@ handle_assertion (cpp_reader *pfile, const char *str, int type)\n \n   /* Copy the entire option so we can modify it.  Change the first\n      \"=\" in the string to a '(', and tack a ')' on the end.  */\n-  char *buf = (char *) alloca (count + 2);\n+  char *buf = alloca (count + 2);\n \n   memcpy (buf, str, count);\n   if (p)"}, {"sha": "1cf55efa0029ecfa9b781270bb59820909833fd4", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -414,7 +414,7 @@ paste_tokens (cpp_reader *pfile, const cpp_token **plhs, const cpp_token *rhs)\n \n   lhs = *plhs;\n   len = cpp_token_len (lhs) + cpp_token_len (rhs) + 1;\n-  buf = (unsigned char *) alloca (len);\n+  buf = alloca (len);\n   end = cpp_spell_token (pfile, lhs, buf);\n \n   /* Avoid comment headers, since they are still processed in stage 3.\n@@ -991,8 +991,7 @@ expand_arg (cpp_reader *pfile, macro_arg *arg)\n \n   /* Loop, reading in the arguments.  */\n   capacity = 256;\n-  arg->expanded = (const cpp_token **)\n-    xmalloc (capacity * sizeof (cpp_token *));\n+  arg->expanded = xmalloc (capacity * sizeof (cpp_token *));\n \n   push_ptoken_context (pfile, NULL, NULL, arg->first, arg->count + 1);\n   for (;;)\n@@ -1002,8 +1001,8 @@ expand_arg (cpp_reader *pfile, macro_arg *arg)\n       if (arg->expanded_count + 1 >= capacity)\n \t{\n \t  capacity *= 2;\n-\t  arg->expanded = (const cpp_token **)\n-\t    xrealloc (arg->expanded, capacity * sizeof (cpp_token *));\n+\t  arg->expanded = xrealloc (arg->expanded,\n+\t\t\t\t    capacity * sizeof (cpp_token *));\n \t}\n \n       token = cpp_get_token (pfile);\n@@ -1257,7 +1256,7 @@ _cpp_save_parameter (cpp_reader *pfile, cpp_macro *macro, cpp_hashnode *node)\n   len = macro->paramc * sizeof (union _cpp_hashnode_value);\n   if (len > pfile->macro_buffer_len)\n     {\n-      pfile->macro_buffer = (uchar *) xrealloc (pfile->macro_buffer, len);\n+      pfile->macro_buffer = xrealloc (pfile->macro_buffer, len);\n       pfile->macro_buffer_len = len;\n     }\n   ((union _cpp_hashnode_value *) pfile->macro_buffer)[macro->paramc - 1]\n@@ -1648,7 +1647,7 @@ cpp_macro_definition (cpp_reader *pfile, const cpp_hashnode *node)\n \n   if (len > pfile->macro_buffer_len)\n     {\n-      pfile->macro_buffer = (uchar *) xrealloc (pfile->macro_buffer, len);\n+      pfile->macro_buffer = xrealloc (pfile->macro_buffer, len);\n       pfile->macro_buffer_len = len;\n     }\n "}, {"sha": "f53cff2a5c1a3d0d29395b67839022b01f988244", "filename": "gcc/cppspec.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcppspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcppspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppspec.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -172,7 +172,7 @@ lang_specific_driver (int *in_argc, const char *const **in_argv,\n     return;\n \n   /* One more slot for a terminating null.  */\n-  new_argv = (const char **) xmalloc ((new_argc + 1) * sizeof(char *));\n+  new_argv = xmalloc ((new_argc + 1) * sizeof(char *));\n \n   new_argv[0] = argv[0];\n   j = 1;"}, {"sha": "caeda891253cde12216f5f028941f5305f67fc58", "filename": "gcc/cpptrad.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcpptrad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcpptrad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpptrad.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -107,8 +107,7 @@ check_output_buffer (cpp_reader *pfile, size_t n)\n       size_t size = pfile->out.cur - pfile->out.base;\n       size_t new_size = (size + n) * 3 / 2;\n \n-      pfile->out.base\n-\t= (uchar *) xrealloc (pfile->out.base, new_size);\n+      pfile->out.base = xrealloc (pfile->out.base, new_size);\n       pfile->out.limit = pfile->out.base + new_size;\n       pfile->out.cur = pfile->out.base + size;\n     }"}, {"sha": "a311be13171c8501f37673d2088a8e8e1079a17d", "filename": "gcc/cse.c", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -929,7 +929,7 @@ get_cse_reg_info (unsigned int regno)\n \t  cse_reg_info_free_list = p->next;\n \t}\n       else\n-\tp = (struct cse_reg_info *) xmalloc (sizeof (struct cse_reg_info));\n+\tp = xmalloc (sizeof (struct cse_reg_info));\n \n       /* Insert into hash table.  */\n       p->hash_next = *hash_head;\n@@ -967,7 +967,7 @@ new_basic_block (void)\n \n   /* Clear out hash table state for this pass.  */\n \n-  memset ((char *) reg_hash, 0, sizeof reg_hash);\n+  memset (reg_hash, 0, sizeof reg_hash);\n \n   if (cse_reg_info_used_list)\n     {\n@@ -1540,7 +1540,7 @@ insert (rtx x, struct table_elt *classp, unsigned int hash, enum machine_mode mo\n   else\n     {\n       n_elements_made++;\n-      elt = (struct table_elt *) xmalloc (sizeof (struct table_elt));\n+      elt = xmalloc (sizeof (struct table_elt));\n     }\n \n   elt->exp = x;\n@@ -4693,7 +4693,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \n   if (GET_CODE (x) == SET)\n     {\n-      sets = (struct set *) alloca (sizeof (struct set));\n+      sets = alloca (sizeof (struct set));\n       sets[0].rtl = x;\n \n       /* Ignore SETs that are unconditional jumps.\n@@ -4728,7 +4728,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n     {\n       int lim = XVECLEN (x, 0);\n \n-      sets = (struct set *) alloca (lim * sizeof (struct set));\n+      sets = alloca (lim * sizeof (struct set));\n \n       /* Find all regs explicitly clobbered in this insn,\n \t and ensure they are not replaced with any other regs\n@@ -6940,8 +6940,7 @@ cse_main (rtx f, int nregs, int after_loop, FILE *file)\n \n   max_insn_uid = get_max_uid ();\n \n-  reg_eqv_table = (struct reg_eqv_elem *)\n-    xmalloc (nregs * sizeof (struct reg_eqv_elem));\n+  reg_eqv_table = xmalloc (nregs * sizeof (struct reg_eqv_elem));\n \n #ifdef LOAD_EXTEND_OP\n \n@@ -6957,7 +6956,7 @@ cse_main (rtx f, int nregs, int after_loop, FILE *file)\n   /* Find the largest uid.  */\n \n   max_uid = get_max_uid ();\n-  uid_cuid = (int *) xcalloc (max_uid + 1, sizeof (int));\n+  uid_cuid = xcalloc (max_uid + 1, sizeof (int));\n \n   /* Compute the mapping from uids to cuids.\n      CUIDs are numbers assigned to insns, like uids,\n@@ -7076,9 +7075,7 @@ cse_basic_block (rtx from, rtx to, struct branch_path *next_branch,\n   /* This array is undefined before max_reg, so only allocate\n      the space actually needed and adjust the start.  */\n \n-  qty_table\n-    = (struct qty_table_elem *) xmalloc ((max_qty - max_reg)\n-\t\t\t\t\t * sizeof (struct qty_table_elem));\n+  qty_table = xmalloc ((max_qty - max_reg) * sizeof (struct qty_table_elem));\n   qty_table -= max_reg;\n \n   new_basic_block ();\n@@ -7537,7 +7534,7 @@ delete_trivially_dead_insns (rtx insns, int nreg)\n \n   timevar_push (TV_DELETE_TRIVIALLY_DEAD);\n   /* First count the number of times each register is used.  */\n-  counts = (int *) xcalloc (nreg, sizeof (int));\n+  counts = xcalloc (nreg, sizeof (int));\n   for (insn = next_real_insn (insns); insn; insn = next_real_insn (insn))\n     count_reg_usage (insn, counts, NULL_RTX, 1);\n "}, {"sha": "8cb325d61a5ece14ba4879e4520edd5346736258", "filename": "gcc/cselib.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -147,7 +147,7 @@ new_elt_list (struct elt_list *next, cselib_val *elt)\n   if (el)\n     empty_elt_lists = el->next;\n   else\n-    el = (struct elt_list *) ggc_alloc (sizeof (struct elt_list));\n+    el = ggc_alloc (sizeof (struct elt_list));\n   el->next = next;\n   el->elt = elt;\n   return el;\n@@ -164,7 +164,7 @@ new_elt_loc_list (struct elt_loc_list *next, rtx loc)\n   if (el)\n     empty_elt_loc_lists = el->next;\n   else\n-    el = (struct elt_loc_list *) ggc_alloc (sizeof (struct elt_loc_list));\n+    el = ggc_alloc (sizeof (struct elt_loc_list));\n   el->next = next;\n   el->loc = loc;\n   el->setting_insn = cselib_current_insn;\n@@ -704,7 +704,7 @@ new_cselib_val (unsigned int value, enum machine_mode mode)\n   if (e)\n     empty_vals = e->u.next_free;\n   else\n-    e = (cselib_val *) ggc_alloc (sizeof (cselib_val));\n+    e = ggc_alloc (sizeof (cselib_val));\n \n   if (value == 0)\n     abort ();"}, {"sha": "2501c947ef1a5e54052cb1308ed4dbf3b71c357c", "filename": "gcc/dbxout.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -459,7 +459,7 @@ dbxout_init (const char *input_file_name)\n   asmfile = asm_out_file;\n \n   typevec_len = 100;\n-  typevec = (struct typeinfo *) ggc_calloc (typevec_len, sizeof typevec[0]);\n+  typevec = ggc_calloc (typevec_len, sizeof typevec[0]);\n \n   /* Convert Ltext into the appropriate format for local labels in case\n      the system doesn't insert underscores in front of user generated\n@@ -513,7 +513,7 @@ dbxout_init (const char *input_file_name)\n   next_type_number = 1;\n \n #ifdef DBX_USE_BINCL\n-  current_file = (struct dbx_file *) ggc_alloc (sizeof *current_file);\n+  current_file = ggc_alloc (sizeof *current_file);\n   current_file->next = NULL;\n   current_file->file_number = 0;\n   current_file->next_type_number = 1;\n@@ -626,7 +626,7 @@ dbxout_start_source_file (unsigned int line ATTRIBUTE_UNUSED,\n \t\t\t  const char *filename ATTRIBUTE_UNUSED)\n {\n #ifdef DBX_USE_BINCL\n-  struct dbx_file *n = (struct dbx_file *) ggc_alloc (sizeof *n);\n+  struct dbx_file *n = ggc_alloc (sizeof *n);\n \n   n->next = current_file;\n   n->next_type_number = 1;\n@@ -1262,11 +1262,8 @@ dbxout_type (tree type, int full)\n       if (next_type_number == typevec_len)\n \t{\n \t  typevec\n-\t    = (struct typeinfo *) ggc_realloc (typevec,\n-\t\t\t\t\t       (typevec_len * 2\n-\t\t\t\t\t\t* sizeof typevec[0]));\n-\t  memset ((char *) (typevec + typevec_len), 0,\n-\t\t typevec_len * sizeof typevec[0]);\n+\t    = ggc_realloc (typevec, (typevec_len * 2 * sizeof typevec[0]));\n+\t  memset (typevec + typevec_len, 0, typevec_len * sizeof typevec[0]);\n \t  typevec_len *= 2;\n \t}\n "}, {"sha": "60e29253510a630b2b1d61376478a4defd9eb754", "filename": "gcc/defaults.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -66,7 +66,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #ifndef ASM_FORMAT_PRIVATE_NAME\n # define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO) \\\n   do { const char *const name_ = (NAME); \\\n-       char *const output_ = (OUTPUT) = (char *) alloca (strlen (name_) + 32);\\\n+       char *const output_ = (OUTPUT) = alloca (strlen (name_) + 32);\\\n        sprintf (output_, ASM_PN_FORMAT, name_, (unsigned long)(LABELNO)); \\\n   } while (0)\n #endif"}, {"sha": "ae99d8eb64f5b525caf603c064ede4ea63795160", "filename": "gcc/df.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -316,8 +316,7 @@ df_insn_table_realloc (struct df *df, unsigned int size)\n      to enlarge it so often.  */\n   size += df->insn_size / 4;\n \n-  df->insns = (struct insn_info *)\n-    xrealloc (df->insns, size * sizeof (struct insn_info));\n+  df->insns = xrealloc (df->insns, size * sizeof (struct insn_info));\n \n   memset (df->insns + df->insn_size, 0,\n \t  (size - df->insn_size) * sizeof (struct insn_info));\n@@ -344,8 +343,7 @@ df_reg_table_realloc (struct df *df, int size)\n   if (size < max_reg_num ())\n     size = max_reg_num ();\n \n-  df->regs = (struct reg_info *)\n-    xrealloc (df->regs, size * sizeof (struct reg_info));\n+  df->regs = xrealloc (df->regs, size * sizeof (struct reg_info));\n \n   /* Zero the new entries.  */\n   memset (df->regs + df->reg_size, 0,"}, {"sha": "944aaf81127e3aab9459ad696aef48a7b2b0af14", "filename": "gcc/dominance.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -133,10 +133,10 @@ void debug_dominance_info (dominance_info);\n     {\t\t\t\t\t\t\t\t\\\n       unsigned int i = 1;    /* Catch content == i.  */\t\t\\\n       if (! (content))\t\t\t\t\t\t\\\n-\t(var) = (type *) xcalloc ((num), sizeof (type));\t\\\n+\t(var) = xcalloc ((num), sizeof (type));\t\t\t\\\n       else\t\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\\\n-\t  (var) = (type *) xmalloc ((num) * sizeof (type));\t\\\n+\t  (var) = xmalloc ((num) * sizeof (type));\t\t\\\n \t  for (i = 0; i < num; i++)\t\t\t\t\\\n \t    (var)[i] = (content);\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\\\n@@ -212,7 +212,7 @@ calc_dfs_tree_nonrec (struct dom_info *di, basic_block bb, enum cdi_direction re\n   /* Ending block.  */\n   basic_block ex_block;\n \n-  stack = (edge *) xmalloc ((n_basic_blocks + 3) * sizeof (edge));\n+  stack = xmalloc ((n_basic_blocks + 3) * sizeof (edge));\n   sp = 0;\n \n   /* Initialize our border blocks, and the first edge.  */"}, {"sha": "368927168d2217411d1850499ebf4b855f6e0372", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 37, "deletions": 43, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -553,7 +553,7 @@ dwarf_cfi_name (unsigned int cfi_opc)\n static inline dw_cfi_ref\n new_cfi (void)\n {\n-  dw_cfi_ref cfi = (dw_cfi_ref) ggc_alloc (sizeof (dw_cfi_node));\n+  dw_cfi_ref cfi = ggc_alloc (sizeof (dw_cfi_node));\n \n   cfi->dw_cfi_next = NULL;\n   cfi->dw_cfi_oprnd1.dw_cfi_reg_num = 0;\n@@ -2248,8 +2248,7 @@ void\n dwarf2out_frame_init (void)\n {\n   /* Allocate the initial hunk of the fde_table.  */\n-  fde_table = (dw_fde_ref) ggc_alloc_cleared (FDE_TABLE_INCREMENT\n-\t\t\t\t\t      * sizeof (dw_fde_node));\n+  fde_table = ggc_alloc_cleared (FDE_TABLE_INCREMENT * sizeof (dw_fde_node));\n   fde_table_allocated = FDE_TABLE_INCREMENT;\n   fde_table_in_use = 0;\n \n@@ -2719,8 +2718,7 @@ static inline dw_loc_descr_ref\n new_loc_descr (enum dwarf_location_atom op, long unsigned int oprnd1,\n \t       long unsigned int oprnd2)\n {\n-  dw_loc_descr_ref descr\n-    = (dw_loc_descr_ref) ggc_alloc_cleared (sizeof (dw_loc_descr_node));\n+  dw_loc_descr_ref descr = ggc_alloc_cleared (sizeof (dw_loc_descr_node));\n \n   descr->dw_loc_opc = op;\n   descr->dw_loc_oprnd1.val_class = dw_val_class_unsigned_const;\n@@ -4444,7 +4442,7 @@ AT_class (dw_attr_ref a)\n static inline void\n add_AT_flag (dw_die_ref die, enum dwarf_attribute attr_kind, unsigned int flag)\n {\n-  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = ggc_alloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4467,7 +4465,7 @@ AT_flag (dw_attr_ref a)\n static inline void\n add_AT_int (dw_die_ref die, enum dwarf_attribute attr_kind, long int int_val)\n {\n-  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = ggc_alloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4491,7 +4489,7 @@ static inline void\n add_AT_unsigned (dw_die_ref die, enum dwarf_attribute attr_kind,\n \t\t long unsigned int unsigned_val)\n {\n-  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = ggc_alloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4515,7 +4513,7 @@ static inline void\n add_AT_long_long (dw_die_ref die, enum dwarf_attribute attr_kind,\n \t\t  long unsigned int val_hi, long unsigned int val_low)\n {\n-  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = ggc_alloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4531,7 +4529,7 @@ static inline void\n add_AT_float (dw_die_ref die, enum dwarf_attribute attr_kind,\n \t      unsigned int length, long int *array)\n {\n-  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = ggc_alloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4561,7 +4559,7 @@ debug_str_eq (const void *x1, const void *x2)\n static inline void\n add_AT_string (dw_die_ref die, enum dwarf_attribute attr_kind, const char *str)\n {\n-  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = ggc_alloc (sizeof (dw_attr_node));\n   struct indirect_string_node *node;\n   void **slot;\n \n@@ -4638,7 +4636,7 @@ AT_string_form (dw_attr_ref a)\n static inline void\n add_AT_die_ref (dw_die_ref die, enum dwarf_attribute attr_kind, dw_die_ref targ_die)\n {\n-  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = ggc_alloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4680,7 +4678,7 @@ set_AT_ref_external (dw_attr_ref a, int i)\n static inline void\n add_AT_fde_ref (dw_die_ref die, enum dwarf_attribute attr_kind, unsigned int targ_fde)\n {\n-  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = ggc_alloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4694,7 +4692,7 @@ add_AT_fde_ref (dw_die_ref die, enum dwarf_attribute attr_kind, unsigned int tar\n static inline void\n add_AT_loc (dw_die_ref die, enum dwarf_attribute attr_kind, dw_loc_descr_ref loc)\n {\n-  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = ggc_alloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4715,7 +4713,7 @@ AT_loc (dw_attr_ref a)\n static inline void\n add_AT_loc_list (dw_die_ref die, enum dwarf_attribute attr_kind, dw_loc_list_ref loc_list)\n {\n-  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = ggc_alloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4739,7 +4737,7 @@ AT_loc_list (dw_attr_ref a)\n static inline void\n add_AT_addr (dw_die_ref die, enum dwarf_attribute attr_kind, rtx addr)\n {\n-  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = ggc_alloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4762,7 +4760,7 @@ AT_addr (dw_attr_ref a)\n static inline void\n add_AT_lbl_id (dw_die_ref die, enum dwarf_attribute attr_kind, const char *lbl_id)\n {\n-  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = ggc_alloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4776,7 +4774,7 @@ add_AT_lbl_id (dw_die_ref die, enum dwarf_attribute attr_kind, const char *lbl_i\n static inline void\n add_AT_lbl_offset (dw_die_ref die, enum dwarf_attribute attr_kind, const char *label)\n {\n-  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = ggc_alloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4790,7 +4788,7 @@ add_AT_lbl_offset (dw_die_ref die, enum dwarf_attribute attr_kind, const char *l\n static inline void\n add_AT_offset (dw_die_ref die, enum dwarf_attribute attr_kind, long unsigned int offset)\n {\n-  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = ggc_alloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4805,7 +4803,7 @@ static void\n add_AT_range_list (dw_die_ref die, enum dwarf_attribute attr_kind,\n \t\t   long unsigned int offset)\n {\n-  dw_attr_ref attr = (dw_attr_ref) ggc_alloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = ggc_alloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -5089,7 +5087,7 @@ splice_child_die (dw_die_ref parent, dw_die_ref child)\n static inline dw_die_ref\n new_die (enum dwarf_tag tag_value, dw_die_ref parent_die, tree t)\n {\n-  dw_die_ref die = (dw_die_ref) ggc_alloc_cleared (sizeof (die_node));\n+  dw_die_ref die = ggc_alloc_cleared (sizeof (die_node));\n \n   die->die_tag = tag_value;\n \n@@ -5153,7 +5151,7 @@ equate_decl_number_to_die (tree decl, dw_die_ref decl_die)\n       decl_die_table = ggc_realloc (decl_die_table,\n \t\t\t\t    sizeof (dw_die_ref) * num_allocated);\n \n-      memset ((char *) &decl_die_table[decl_die_table_allocated], 0,\n+      memset (&decl_die_table[decl_die_table_allocated], 0,\n \t     (num_allocated - decl_die_table_allocated) * sizeof (dw_die_ref));\n       decl_die_table_allocated = num_allocated;\n     }\n@@ -5663,7 +5661,7 @@ compute_section_prefix (dw_die_ref unit_die)\n {\n   const char *die_name = get_AT_string (unit_die, DW_AT_name);\n   const char *base = die_name ? lbasename (die_name) : \"anonymous\";\n-  char *name = (char *) alloca (strlen (base) + 64);\n+  char *name = alloca (strlen (base) + 64);\n   char *p;\n   int i, mark;\n   unsigned char checksum[16];\n@@ -6054,7 +6052,7 @@ build_abbrev_table (dw_die_ref die)\n \t  abbrev_die_table = ggc_realloc (abbrev_die_table,\n \t\t\t\t\t  sizeof (dw_die_ref) * n_alloc);\n \n-\t  memset ((char *) &abbrev_die_table[abbrev_die_table_allocated], 0,\n+\t  memset (&abbrev_die_table[abbrev_die_table_allocated], 0,\n \t\t (n_alloc - abbrev_die_table_allocated) * sizeof (dw_die_ref));\n \t  abbrev_die_table_allocated = n_alloc;\n \t}\n@@ -6724,7 +6722,7 @@ output_comp_unit (dw_die_ref die, int output_if_empty)\n   oldsym = die->die_symbol;\n   if (oldsym)\n     {\n-      tmp = (char *) alloca (strlen (oldsym) + 24);\n+      tmp = alloca (strlen (oldsym) + 24);\n \n       sprintf (tmp, \".gnu.linkonce.wi.%s\", oldsym);\n       secname = tmp;\n@@ -6771,9 +6769,8 @@ add_pubname (tree decl, dw_die_ref die)\n     {\n       pubname_table_allocated += PUBNAME_TABLE_INCREMENT;\n       pubname_table\n-\t= (pubname_ref) ggc_realloc (pubname_table,\n-\t\t\t\t     (pubname_table_allocated\n-\t\t\t\t      * sizeof (pubname_entry)));\n+\t= ggc_realloc (pubname_table,\n+\t\t       (pubname_table_allocated * sizeof (pubname_entry)));\n       memset (pubname_table + pubname_table_in_use, 0,\n \t      PUBNAME_TABLE_INCREMENT * sizeof (pubname_entry));\n     }\n@@ -6932,9 +6929,9 @@ add_ranges (tree block)\n   if (in_use == ranges_table_allocated)\n     {\n       ranges_table_allocated += RANGES_TABLE_INCREMENT;\n-      ranges_table = (dw_ranges_ref)\n-\tggc_realloc (ranges_table, (ranges_table_allocated\n-\t\t\t\t    * sizeof (struct dw_ranges_struct)));\n+      ranges_table\n+\t= ggc_realloc (ranges_table, (ranges_table_allocated\n+\t\t\t\t      * sizeof (struct dw_ranges_struct)));\n       memset (ranges_table + ranges_table_in_use, 0,\n \t      RANGES_TABLE_INCREMENT * sizeof (struct dw_ranges_struct));\n     }\n@@ -7084,10 +7081,8 @@ output_file_names (void)\n     }\n \n   /* Allocate the various arrays we need.  */\n-  files = (struct file_info *) alloca (VARRAY_ACTIVE_SIZE (file_table)\n-\t\t\t\t       * sizeof (struct file_info));\n-  dirs = (struct dir_info *) alloca (VARRAY_ACTIVE_SIZE (file_table)\n-\t\t\t\t     * sizeof (struct dir_info));\n+  files = alloca (VARRAY_ACTIVE_SIZE (file_table) * sizeof (struct file_info));\n+  dirs = alloca (VARRAY_ACTIVE_SIZE (file_table) * sizeof (struct dir_info));\n \n   /* Sort the file names.  */\n   for (i = 1; i < VARRAY_ACTIVE_SIZE (file_table); i++)\n@@ -7162,8 +7157,8 @@ output_file_names (void)\n      where we would have to check out every combination of every single\n      possible prefix.  Instead we use a heuristic which provides nearly optimal\n      results in most cases and never is much off.  */\n-  saved = (int *) alloca (ndirs * sizeof (int));\n-  savehere = (int *) alloca (ndirs * sizeof (int));\n+  saved = alloca (ndirs * sizeof (int));\n+  savehere = alloca (ndirs * sizeof (int));\n \n   memset (saved, '\\0', ndirs * sizeof (saved[0]));\n   for (i = 0; i < ndirs; i++)\n@@ -7220,7 +7215,7 @@ output_file_names (void)\n   /* We have to emit them in the order they appear in the file_table array\n      since the index is used in the debug info generation.  To do this\n      efficiently we generate a back-mapping of the indices first.  */\n-  backmap = (int *) alloca (VARRAY_ACTIVE_SIZE (file_table) * sizeof (int));\n+  backmap = alloca (VARRAY_ACTIVE_SIZE (file_table) * sizeof (int));\n   for (i = 1; i < VARRAY_ACTIVE_SIZE (file_table); i++)\n     {\n       backmap[files[i].file_idx] = i;\n@@ -9092,7 +9087,7 @@ add_const_value_attribute (dw_die_ref die, rtx rtl)\n \tif (GET_MODE_CLASS (mode) == MODE_FLOAT)\n \t  {\n \t    unsigned length = GET_MODE_SIZE (mode) / 4;\n-\t    long *array = (long *) ggc_alloc (sizeof (long) * length);\n+\t    long *array = ggc_alloc (sizeof (long) * length);\n \t    REAL_VALUE_TYPE rv;\n \n \t    REAL_VALUE_FROM_CONST_DOUBLE (rv, rtl);\n@@ -12213,12 +12208,11 @@ dwarf2out_source_line (unsigned int line, const char *filename)\n \t    {\n \t      separate_line_info_table_allocated += LINE_INFO_TABLE_INCREMENT;\n \t      separate_line_info_table\n-\t\t= (dw_separate_line_info_ref)\n-\t\t  ggc_realloc (separate_line_info_table,\n+\t\t= ggc_realloc (separate_line_info_table,\n \t\t\t       separate_line_info_table_allocated\n \t\t\t       * sizeof (dw_separate_line_info_entry));\n-\t      memset ((separate_line_info_table\n-\t\t       + separate_line_info_table_in_use),\n+\t      memset (separate_line_info_table\n+\t\t       + separate_line_info_table_in_use,\n \t\t      0,\n \t\t      (LINE_INFO_TABLE_INCREMENT\n \t\t       * sizeof (dw_separate_line_info_entry)));"}, {"sha": "ab80df16a0a6de637188d12179e7851f7399f1e7", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -3517,8 +3517,8 @@ dienum_push (void)\n     {\n       pending_siblings_allocated += PENDING_SIBLINGS_INCREMENT;\n       pending_sibling_stack\n-\t= (unsigned *) xrealloc (pending_sibling_stack,\n-\t\t\t\t pending_siblings_allocated * sizeof(unsigned));\n+\t= xrealloc (pending_sibling_stack,\n+\t\t    pending_siblings_allocated * sizeof(unsigned));\n     }\n \n   pending_siblings++;\n@@ -4406,8 +4406,8 @@ pend_type (tree type)\n     {\n       pending_types_allocated += PENDING_TYPES_INCREMENT;\n       pending_types_list\n-\t= (tree *) xrealloc (pending_types_list,\n-\t\t\t     sizeof (tree) * pending_types_allocated);\n+\t= xrealloc (pending_types_list,\n+\t\t    sizeof (tree) * pending_types_allocated);\n     }\n   pending_types_list[pending_types++] = type;\n \n@@ -4533,8 +4533,8 @@ add_incomplete_type (tree type)\n     {\n       incomplete_types_allocated += INCOMPLETE_TYPES_INCREMENT;\n       incomplete_types_list\n-\t= (tree *) xrealloc (incomplete_types_list,\n-\t\t\t     sizeof (tree) * incomplete_types_allocated);\n+\t= xrealloc (incomplete_types_list,\n+\t\t    sizeof (tree) * incomplete_types_allocated);\n     }\n \n   incomplete_types_list[incomplete_types++] = type;\n@@ -5851,8 +5851,7 @@ lookup_filename (const char *file_name)\n     {\n       ft_entries_allocated += FT_ENTRIES_INCREMENT;\n       filename_table\n-\t= (filename_entry *)\n-\t  xrealloc (filename_table,\n+\t= xrealloc (filename_table,\n \t\t    ft_entries_allocated * sizeof (filename_entry));\n     }\n \n@@ -6035,23 +6034,19 @@ dwarfout_init (const char *main_input_filename)\n   /* Allocate the initial hunk of the pending_sibling_stack.  */\n \n   pending_sibling_stack\n-    = (unsigned *)\n-\txmalloc (PENDING_SIBLINGS_INCREMENT * sizeof (unsigned));\n+    = xmalloc (PENDING_SIBLINGS_INCREMENT * sizeof (unsigned));\n   pending_siblings_allocated = PENDING_SIBLINGS_INCREMENT;\n   pending_siblings = 1;\n \n   /* Allocate the initial hunk of the filename_table.  */\n \n-  filename_table\n-    = (filename_entry *)\n-\txmalloc (FT_ENTRIES_INCREMENT * sizeof (filename_entry));\n+  filename_table = xmalloc (FT_ENTRIES_INCREMENT * sizeof (filename_entry));\n   ft_entries_allocated = FT_ENTRIES_INCREMENT;\n   ft_entries = 0;\n \n   /* Allocate the initial hunk of the pending_types_list.  */\n \n-  pending_types_list\n-    = (tree *) xmalloc (PENDING_TYPES_INCREMENT * sizeof (tree));\n+  pending_types_list = xmalloc (PENDING_TYPES_INCREMENT * sizeof (tree));\n   pending_types_allocated = PENDING_TYPES_INCREMENT;\n   pending_types = 0;\n "}, {"sha": "f88c5bf09030ad564bce545f5bd6d2ffab57daff", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -772,7 +772,7 @@ gen_rtvec (int n, ...)\n   if (n == 0)\n     return NULL_RTVEC;\t\t/* Don't allocate an empty rtvec...\t*/\n \n-  vector = (rtx *) alloca (n * sizeof (rtx));\n+  vector = alloca (n * sizeof (rtx));\n \n   for (i = 0; i < n; i++)\n     vector[i] = va_arg (p, rtx);\n@@ -845,8 +845,8 @@ gen_reg_rtx (enum machine_mode mode)\n       memset (new + old_size, 0, old_size);\n       f->emit->regno_pointer_align = (unsigned char *) new;\n \n-      new1 = (rtx *) ggc_realloc (f->emit->x_regno_reg_rtx,\n-\t\t\t\t  old_size * 2 * sizeof (rtx));\n+      new1 = ggc_realloc (f->emit->x_regno_reg_rtx,\n+\t\t\t  old_size * 2 * sizeof (rtx));\n       memset (new1 + old_size, 0, old_size * sizeof (rtx));\n       regno_reg_rtx = new1;\n \n@@ -4874,7 +4874,7 @@ start_sequence (void)\n       free_sequence_stack = tem->next;\n     }\n   else\n-    tem = (struct sequence_stack *) ggc_alloc (sizeof (struct sequence_stack));\n+    tem = ggc_alloc (sizeof (struct sequence_stack));\n \n   tem->next = seq_stack;\n   tem->first = first_insn;\n@@ -5205,7 +5205,7 @@ init_emit (void)\n {\n   struct function *f = cfun;\n \n-  f->emit = (struct emit_status *) ggc_alloc (sizeof (struct emit_status));\n+  f->emit = ggc_alloc (sizeof (struct emit_status));\n   first_insn = NULL;\n   last_insn = NULL;\n   seq_rtl_expr = NULL;\n@@ -5222,11 +5222,11 @@ init_emit (void)\n   f->emit->regno_pointer_align_length = LAST_VIRTUAL_REGISTER + 101;\n \n   f->emit->regno_pointer_align\n-    = (unsigned char *) ggc_alloc_cleared (f->emit->regno_pointer_align_length\n-\t\t\t\t\t   * sizeof (unsigned char));\n+    = ggc_alloc_cleared (f->emit->regno_pointer_align_length\n+\t\t\t * sizeof (unsigned char));\n \n   regno_reg_rtx\n-    = (rtx *) ggc_alloc (f->emit->regno_pointer_align_length * sizeof (rtx));\n+    = ggc_alloc (f->emit->regno_pointer_align_length * sizeof (rtx));\n \n   /* Put copies of all the hard registers into regno_reg_rtx.  */\n   memcpy (regno_reg_rtx,"}, {"sha": "c34dcd9b5214dc1ecc2cb652363d0a817c01c4e2", "filename": "gcc/except.c", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -458,8 +458,7 @@ init_eh (void)\n void\n init_eh_for_function (void)\n {\n-  cfun->eh = (struct eh_status *)\n-    ggc_alloc_cleared (sizeof (struct eh_status));\n+  cfun->eh = ggc_alloc_cleared (sizeof (struct eh_status));\n }\n \f\n /* Start an exception handling region.  All instructions emitted\n@@ -477,7 +476,7 @@ expand_eh_region_start (void)\n     return;\n \n   /* Insert a new blank region as a leaf in the tree.  */\n-  new_region = (struct eh_region *) ggc_alloc_cleared (sizeof (*new_region));\n+  new_region = ggc_alloc_cleared (sizeof (*new_region));\n   cur_region = cfun->eh->cur_region;\n   new_region->outer = cur_region;\n   if (cur_region)\n@@ -1158,7 +1157,7 @@ add_ehl_entry (rtx label, struct eh_region *region)\n \n   LABEL_PRESERVE_P (label) = 1;\n \n-  entry = (struct ehl_map_entry *) ggc_alloc (sizeof (*entry));\n+  entry = ggc_alloc (sizeof (*entry));\n   entry->label = label;\n   entry->region = region;\n \n@@ -1237,8 +1236,7 @@ current_function_has_exception_handlers (void)\n static struct eh_region *\n duplicate_eh_region_1 (struct eh_region *o, struct inline_remap *map)\n {\n-  struct eh_region *n\n-    = (struct eh_region *) ggc_alloc_cleared (sizeof (struct eh_region));\n+  struct eh_region *n = ggc_alloc_cleared (sizeof (struct eh_region));\n \n   n->region_number = o->region_number + cfun->eh->last_region_number;\n   n->type = o->type;\n@@ -1493,7 +1491,7 @@ add_ttypes_entry (htab_t ttypes_hash, tree type)\n     {\n       /* Filter value is a 1 based table index.  */\n \n-      n = (struct ttypes_filter *) xmalloc (sizeof (*n));\n+      n = xmalloc (sizeof (*n));\n       n->t = type;\n       n->filter = VARRAY_ACTIVE_SIZE (cfun->eh->ttype_data) + 1;\n       *slot = n;\n@@ -1521,7 +1519,7 @@ add_ehspec_entry (htab_t ehspec_hash, htab_t ttypes_hash, tree list)\n     {\n       /* Filter value is a -1 based byte index into a uleb128 buffer.  */\n \n-      n = (struct ttypes_filter *) xmalloc (sizeof (*n));\n+      n = xmalloc (sizeof (*n));\n       n->t = list;\n       n->filter = -(VARRAY_ACTIVE_SIZE (cfun->eh->ehspec_data) + 1);\n       *slot = n;\n@@ -2187,8 +2185,8 @@ sjlj_build_landing_pads (void)\n {\n   struct sjlj_lp_info *lp_info;\n \n-  lp_info = (struct sjlj_lp_info *) xcalloc (cfun->eh->last_region_number + 1,\n-\t\t\t\t\t     sizeof (struct sjlj_lp_info));\n+  lp_info = xcalloc (cfun->eh->last_region_number + 1,\n+\t\t     sizeof (struct sjlj_lp_info));\n \n   if (sjlj_find_directly_reachable_regions (lp_info))\n     {\n@@ -3108,7 +3106,7 @@ add_action_record (htab_t ar_hash, int filter, int next)\n \n   if ((new = *slot) == NULL)\n     {\n-      new = (struct action_record *) xmalloc (sizeof (*new));\n+      new = xmalloc (sizeof (*new));\n       new->offset = VARRAY_ACTIVE_SIZE (cfun->eh->action_record_data) + 1;\n       new->filter = filter;\n       new->next = next;\n@@ -3239,8 +3237,7 @@ add_call_site (rtx landing_pad, int action)\n   if (used >= size)\n     {\n       size = (size ? size * 2 : 64);\n-      data = (struct call_site_record *)\n-\tggc_realloc (data, sizeof (*data) * size);\n+      data = ggc_realloc (data, sizeof (*data) * size);\n       cfun->eh->call_site_data = data;\n       cfun->eh->call_site_data_size = size;\n     }"}, {"sha": "68163e9ba2b0627533b8ed2a43265fff69e3a543", "filename": "gcc/expmed.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -2096,8 +2096,8 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n \n   /* We'll be needing a couple extra algorithm structures now.  */\n \n-  alg_in = (struct algorithm *)alloca (sizeof (struct algorithm));\n-  best_alg = (struct algorithm *)alloca (sizeof (struct algorithm));\n+  alg_in = alloca (sizeof (struct algorithm));\n+  best_alg = alloca (sizeof (struct algorithm));\n \n   /* If we have a group of zero bits at the low-order part of T, try\n      multiplying by the remaining bits and then doing a shift.  */"}, {"sha": "e76e364c891dd1ac24a46901d0263d966bc67fcf", "filename": "gcc/expr.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -339,7 +339,7 @@ init_expr_once (void)\n void\n init_expr (void)\n {\n-  cfun->expr = (struct expr_status *) ggc_alloc (sizeof (struct expr_status));\n+  cfun->expr = ggc_alloc (sizeof (struct expr_status));\n \n   pending_chain = 0;\n   pending_stack_adjust = 0;\n@@ -2224,7 +2224,7 @@ gen_group_rtx (rtx orig)\n     abort ();\n \n   length = XVECLEN (orig, 0);\n-  tmps = (rtx *) alloca (sizeof (rtx) * length);\n+  tmps = alloca (sizeof (rtx) * length);\n \n   /* Skip a NULL entry in first slot.  */\n   i = XEXP (XVECEXP (orig, 0, 0), 0) ? 0 : 1;\n@@ -2264,7 +2264,7 @@ emit_group_load (rtx dst, rtx orig_src, tree type ATTRIBUTE_UNUSED, int ssize)\n   else\n     start = 1;\n \n-  tmps = (rtx *) alloca (sizeof (rtx) * XVECLEN (dst, 0));\n+  tmps = alloca (sizeof (rtx) * XVECLEN (dst, 0));\n \n   /* Process the pieces.  */\n   for (i = start; i < XVECLEN (dst, 0); i++)\n@@ -2421,7 +2421,7 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED, int ssize)\n   else\n     start = 1;\n \n-  tmps = (rtx *) alloca (sizeof (rtx) * XVECLEN (src, 0));\n+  tmps = alloca (sizeof (rtx) * XVECLEN (src, 0));\n \n   /* Copy the (probable) hard regs into pseudos.  */\n   for (i = start; i < XVECLEN (src, 0); i++)\n@@ -5388,7 +5388,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t{\n \t  unsigned int set_word_size = TYPE_ALIGN (TREE_TYPE (exp));\n \t  enum machine_mode mode = mode_for_size (set_word_size, MODE_INT, 1);\n-\t  char *bit_buffer = (char *) alloca (nbits);\n+\t  char *bit_buffer = alloca (nbits);\n \t  HOST_WIDE_INT word = 0;\n \t  unsigned int bit_pos = 0;\n \t  unsigned int ibit = 0;"}, {"sha": "6f2b5fb55ebb0b10ceb6e7729f058dd2640fb764", "filename": "gcc/final.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -658,8 +658,8 @@ compute_alignments (void)\n \n   max_labelno = max_label_num ();\n   min_labelno = get_first_label_num ();\n-  label_align = (struct label_alignment *)\n-    xcalloc (max_labelno - min_labelno + 1, sizeof (struct label_alignment));\n+  label_align = xcalloc (max_labelno - min_labelno + 1,\n+\t\t\t sizeof (struct label_alignment));\n \n   /* If not optimizing or optimizing for size, don't assign any alignments.  */\n   if (! optimize || optimize_size)\n@@ -766,7 +766,7 @@ shorten_branches (rtx first ATTRIBUTE_UNUSED)\n   /* Compute maximum UID and allocate label_align / uid_shuid.  */\n   max_uid = get_max_uid ();\n \n-  uid_shuid = (int *) xmalloc (max_uid * sizeof *uid_shuid);\n+  uid_shuid = xmalloc (max_uid * sizeof *uid_shuid);\n \n   if (max_labelno != max_label_num ())\n     {\n@@ -779,8 +779,8 @@ shorten_branches (rtx first ATTRIBUTE_UNUSED)\n       n_labels = max_labelno - min_labelno + 1;\n       n_old_labels = old - min_labelno + 1;\n \n-      label_align = (struct label_alignment *) xrealloc\n-\t(label_align, n_labels * sizeof (struct label_alignment));\n+      label_align = xrealloc (label_align,\n+\t\t\t      n_labels * sizeof (struct label_alignment));\n \n       /* Range of labels grows monotonically in the function.  Abort here\n          means that the initialization of array got lost.  */\n@@ -875,20 +875,20 @@ shorten_branches (rtx first ATTRIBUTE_UNUSED)\n #ifdef HAVE_ATTR_length\n \n   /* Allocate the rest of the arrays.  */\n-  insn_lengths = (int *) xmalloc (max_uid * sizeof (*insn_lengths));\n+  insn_lengths = xmalloc (max_uid * sizeof (*insn_lengths));\n   insn_lengths_max_uid = max_uid;\n   /* Syntax errors can lead to labels being outside of the main insn stream.\n      Initialize insn_addresses, so that we get reproducible results.  */\n   INSN_ADDRESSES_ALLOC (max_uid);\n \n-  varying_length = (char *) xcalloc (max_uid, sizeof (char));\n+  varying_length = xcalloc (max_uid, sizeof (char));\n \n   /* Initialize uid_align.  We scan instructions\n      from end to start, and keep in align_tab[n] the last seen insn\n      that does an alignment of at least n+1, i.e. the successor\n      in the alignment chain for an insn that does / has a known\n      alignment of n.  */\n-  uid_align = (rtx *) xcalloc (max_uid, sizeof *uid_align);\n+  uid_align = xcalloc (max_uid, sizeof *uid_align);\n \n   for (i = MAX_CODE_ALIGN; --i >= 0;)\n     align_tab[i] = NULL_RTX;\n@@ -1566,7 +1566,7 @@ final (rtx first, FILE *file, int optimize, int prescan)\n \t  max_line = NOTE_LINE_NUMBER (insn);\n     }\n \n-  line_note_exists = (char *) xcalloc (max_line + 1, sizeof (char));\n+  line_note_exists = xcalloc (max_line + 1, sizeof (char));\n \n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     {\n@@ -2055,7 +2055,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \tif (asm_noperands (body) >= 0)\n \t  {\n \t    unsigned int noperands = asm_noperands (body);\n-\t    rtx *ops = (rtx *) alloca (noperands * sizeof (rtx));\n+\t    rtx *ops = alloca (noperands * sizeof (rtx));\n \t    const char *string;\n \n \t    /* There's no telling what that did to the condition codes.  */\n@@ -3865,8 +3865,8 @@ debug_queue_symbol (tree decl)\n   if (symbol_queue_index >= symbol_queue_size)\n     {\n       symbol_queue_size += 10;\n-      symbol_queue = (tree *) xrealloc (symbol_queue,\n-                                        symbol_queue_size * sizeof (tree));\n+      symbol_queue = xrealloc (symbol_queue,\n+\t\t\t       symbol_queue_size * sizeof (tree));\n     }\n \n   symbol_queue[symbol_queue_index++] = decl;"}, {"sha": "0c55481b4efa51abd72fba11cc26fd2bc4837fc2", "filename": "gcc/fix-header.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -544,8 +544,7 @@ recognized_function (const cpp_token *fname, unsigned int line, int kind,\n   /* We only have a partial function declaration,\n      so remember that we have to add a complete prototype.  */\n   partial_count++;\n-  partial = (struct partial_proto *)\n-    obstack_alloc (&scan_file_obstack, sizeof (struct partial_proto));\n+  partial = obstack_alloc (&scan_file_obstack, sizeof (struct partial_proto));\n   partial->line_seen = line;\n   partial->fn = fn;\n   fn->partial = partial;\n@@ -1169,7 +1168,7 @@ main (int argc, char **argv)\n       exit (FATAL_EXIT_CODE);\n     }\n   inf_size = sbuf.st_size;\n-  inf_buffer = (char *) xmalloc (inf_size + 2);\n+  inf_buffer = xmalloc (inf_size + 2);\n   inf_ptr = inf_buffer;\n \n   to_read = inf_size;"}, {"sha": "4bc33e286027c40e9bcdbbf4a82217df6df6e66f", "filename": "gcc/flow.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -1082,7 +1082,7 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n   /* Create a worklist.  Allocate an extra slot for ENTRY_BLOCK, and one\n      because the `head == tail' style test for an empty queue doesn't\n      work with a full queue.  */\n-  queue = (basic_block *) xmalloc ((n_basic_blocks + 2) * sizeof (*queue));\n+  queue = xmalloc ((n_basic_blocks + 2) * sizeof (*queue));\n   qtail = queue;\n   qhead = qend = queue + n_basic_blocks + 2;\n \n@@ -1850,7 +1850,7 @@ init_propagate_block_info (basic_block bb, regset live, regset local_set,\n   pbi->flags = flags;\n \n   if (flags & (PROP_LOG_LINKS | PROP_AUTOINC))\n-    pbi->reg_next_use = (rtx *) xcalloc (max_reg_num (), sizeof (rtx));\n+    pbi->reg_next_use = xcalloc (max_reg_num (), sizeof (rtx));\n   else\n     pbi->reg_next_use = NULL;\n \n@@ -1932,7 +1932,7 @@ init_propagate_block_info (basic_block bb, regset live, regset local_set,\n \t       struct reg_cond_life_info *rcli;\n \t       rtx cond;\n \n-\t       rcli = (struct reg_cond_life_info *) xmalloc (sizeof (*rcli));\n+\t       rcli = xmalloc (sizeof (*rcli));\n \n \t       if (REGNO_REG_SET_P (bb_true->global_live_at_start, i))\n \t\t cond = cond_false;\n@@ -2867,7 +2867,7 @@ mark_regno_cond_dead (struct propagate_block_info *pbi, int regno, rtx cond)\n \t  /* The register was unconditionally live previously.\n \t     Record the current condition as the condition under\n \t     which it is dead.  */\n-\t  rcli = (struct reg_cond_life_info *) xmalloc (sizeof (*rcli));\n+\t  rcli = xmalloc (sizeof (*rcli));\n \t  rcli->condition = cond;\n \t  rcli->stores = cond;\n \t  rcli->orig_condition = const0_rtx;\n@@ -3644,7 +3644,7 @@ mark_used_reg (struct propagate_block_info *pbi, rtx reg,\n \t    {\n \t      /* The register was not previously live at all.  Record\n \t\t the condition under which it is still dead.  */\n-\t      rcli = (struct reg_cond_life_info *) xmalloc (sizeof (*rcli));\n+\t      rcli = xmalloc (sizeof (*rcli));\n \t      rcli->condition = not_reg_cond (cond);\n \t      rcli->stores = const0_rtx;\n \t      rcli->orig_condition = const0_rtx;"}, {"sha": "9fd4f001242b5b5dbcc7f0f3b264f357a635b52a", "filename": "gcc/fold-const.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -313,7 +313,7 @@ mul_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n   encode (arg1, l1, h1);\n   encode (arg2, l2, h2);\n \n-  memset ((char *) prod, 0, sizeof prod);\n+  memset (prod, 0, sizeof prod);\n \n   for (i = 0; i < 4; i++)\n     {\n@@ -591,10 +591,10 @@ div_and_round_double (enum tree_code code, int uns,\n       goto finish_up;\n     }\n \n-  memset ((char *) quo, 0, sizeof quo);\n+  memset (quo, 0, sizeof quo);\n \n-  memset ((char *) num, 0, sizeof num);\t/* to zero 9th element */\n-  memset ((char *) den, 0, sizeof den);\n+  memset (num, 0, sizeof num);\t/* to zero 9th element */\n+  memset (den, 0, sizeof den);\n \n   encode (num, lnum, hnum);\n   encode (den, lden, hden);"}, {"sha": "f8cc5a509ad34d5269d4e938517eba3be2dc1177", "filename": "gcc/function.c", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -692,7 +692,7 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size, int keep\n \n \t  if (best_p->size - rounded_size >= alignment)\n \t    {\n-\t      p = (struct temp_slot *) ggc_alloc (sizeof (struct temp_slot));\n+\t      p = ggc_alloc (sizeof (struct temp_slot));\n \t      p->in_use = p->addr_taken = 0;\n \t      p->size = best_p->size - rounded_size;\n \t      p->base_offset = best_p->base_offset + rounded_size;\n@@ -723,7 +723,7 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size, int keep\n     {\n       HOST_WIDE_INT frame_offset_old = frame_offset;\n \n-      p = (struct temp_slot *) ggc_alloc (sizeof (struct temp_slot));\n+      p = ggc_alloc (sizeof (struct temp_slot));\n \n       /* We are passing an explicit alignment request to assign_stack_local.\n \t One side effect of that is assign_stack_local will not round SIZE\n@@ -1477,8 +1477,7 @@ schedule_fixup_var_refs (struct function *function, rtx reg, tree type,\n     {\n       struct var_refs_queue *temp;\n \n-      temp\n-\t= (struct var_refs_queue *) ggc_alloc (sizeof (struct var_refs_queue));\n+      temp = ggc_alloc (sizeof (struct var_refs_queue));\n       temp->modified = reg;\n       temp->promoted_mode = promoted_mode;\n       temp->unsignedp = unsigned_p;\n@@ -1553,7 +1552,7 @@ find_fixup_replacement (struct fixup_replacement **replacements, rtx x)\n \n   if (p == 0)\n     {\n-      p = (struct fixup_replacement *) xmalloc (sizeof (struct fixup_replacement));\n+      p = xmalloc (sizeof (struct fixup_replacement));\n       p->old = x;\n       p->new = 0;\n       p->next = *replacements;\n@@ -1627,7 +1626,7 @@ fixup_var_refs_insns_with_hash (htab_t ht, rtx var, enum machine_mode promoted_m\n   rtx insn_list;\n \n   tmp.key = var;\n-  ime = (struct insns_for_mem_entry *) htab_find (ht, &tmp);\n+  ime = htab_find (ht, &tmp);\n   for (insn_list = ime->insns; insn_list != 0; insn_list = XEXP (insn_list, 1))\n     if (INSN_P (XEXP (insn_list, 0)))\n       fixup_var_refs_insn (XEXP (insn_list, 0), var, promoted_mode,\n@@ -3295,7 +3294,7 @@ insns_for_mem_walk (rtx *r, void *data)\n     {\n       struct insns_for_mem_entry *ifme;\n       tmp.key = *r;\n-      ifme = (struct insns_for_mem_entry *) htab_find (ifmwi->ht, &tmp);\n+      ifme = htab_find (ifmwi->ht, &tmp);\n \n       /* If we have not already recorded this INSN, do so now.  Since\n \t we process the INSNs in order, we know that if we have\n@@ -4281,7 +4280,7 @@ assign_parms (tree fndecl)\n   orig_fnargs = fnargs;\n \n   max_parm_reg = LAST_VIRTUAL_REGISTER + 1;\n-  parm_reg_stack_loc = (rtx *) ggc_alloc_cleared (max_parm_reg * sizeof (rtx));\n+  parm_reg_stack_loc = ggc_alloc_cleared (max_parm_reg * sizeof (rtx));\n \n   if (SPLIT_COMPLEX_ARGS)\n     fnargs = split_complex_args (fnargs);\n@@ -4944,10 +4943,10 @@ assign_parms (tree fndecl)\n \t\t but it's also rare and we need max_parm_reg to be\n \t\t precisely correct.  */\n \t      max_parm_reg = regno + 1;\n-\t      new = (rtx *) ggc_realloc (parm_reg_stack_loc,\n-\t\t\t\t      max_parm_reg * sizeof (rtx));\n-\t      memset ((char *) (new + old_max_parm_reg), 0,\n-\t\t     (max_parm_reg - old_max_parm_reg) * sizeof (rtx));\n+\t      new = ggc_realloc (parm_reg_stack_loc,\n+\t\t\t\t max_parm_reg * sizeof (rtx));\n+\t      memset (new + old_max_parm_reg, 0,\n+\t\t      (max_parm_reg - old_max_parm_reg) * sizeof (rtx));\n \t      parm_reg_stack_loc = new;\n \t    }\n \n@@ -5885,7 +5884,7 @@ identify_blocks (void)\n   /* Fill the BLOCK_VECTOR with all of the BLOCKs in this function, in\n      depth-first order.  */\n   block_vector = get_block_vector (block, &n_blocks);\n-  block_stack = (tree *) xmalloc (n_blocks * sizeof (tree));\n+  block_stack = xmalloc (n_blocks * sizeof (tree));\n \n   last_block_vector = identify_blocks_1 (get_insns (),\n \t\t\t\t\t block_vector + 1,\n@@ -6189,7 +6188,7 @@ get_block_vector (tree block, int *n_blocks_p)\n   tree *block_vector;\n \n   *n_blocks_p = all_blocks (block, NULL);\n-  block_vector = (tree *) xmalloc (*n_blocks_p * sizeof (tree));\n+  block_vector = xmalloc (*n_blocks_p * sizeof (tree));\n   all_blocks (block, block_vector);\n \n   return block_vector;\n@@ -6252,7 +6251,7 @@ debug_find_var_in_block_tree (tree var, tree block)\n static void\n prepare_function_start (void)\n {\n-  cfun = (struct function *) ggc_alloc_cleared (sizeof (struct function));\n+  cfun = ggc_alloc_cleared (sizeof (struct function));\n \n   init_stmt_for_function ();\n   init_eh_for_function ();"}, {"sha": "a7a9cc9399613cb97b01f8c632a2734325319122", "filename": "gcc/gcc.c", "status": "modified", "additions": 53, "deletions": 74, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -1107,8 +1107,7 @@ translate_options (int *argcp, const char *const **argvp)\n   int argc = *argcp;\n   const char *const *argv = *argvp;\n   int newvsize = (argc + 2) * 2 * sizeof (const char *);\n-  const char **newv =\n-    (const char **) xmalloc (newvsize);\n+  const char **newv = xmalloc (newvsize);\n   int newindex = 0;\n \n   i = 0;\n@@ -1138,7 +1137,7 @@ translate_options (int *argcp, const char *const **argvp)\n \t\t}\n \n \t      newvsize += spaces * sizeof (const char *);\n-\t      newv = (const char **) xrealloc (newv, newvsize);\n+\t      newv =  xrealloc (newv, newvsize);\n \n \t      sp = target_option_translations[tott_idx].replacements;\n \t      np = xstrdup (sp);\n@@ -1574,8 +1573,8 @@ init_spec (void)\n     notice (\"Using built-in specs.\\n\");\n \n #ifdef EXTRA_SPECS\n-  extra_specs = (struct spec_list *)\n-    xcalloc (sizeof (struct spec_list), ARRAY_SIZE (extra_specs_1));\n+  extra_specs = xcalloc (sizeof (struct spec_list),\n+\t\t\t ARRAY_SIZE (extra_specs_1));\n \n   for (i = ARRAY_SIZE (extra_specs_1) - 1; i >= 0; i--)\n     {\n@@ -1733,7 +1732,7 @@ set_spec (const char *name, const char *spec)\n   if (!sl)\n     {\n       /* Not found - make it.  */\n-      sl = (struct spec_list *) xmalloc (sizeof (struct spec_list));\n+      sl = xmalloc (sizeof (struct spec_list));\n       sl->name = xstrdup (name);\n       sl->name_len = name_len;\n       sl->ptr_spec = &sl->ptr;\n@@ -1805,7 +1804,7 @@ static void\n alloc_args (void)\n {\n   argbuf_length = 10;\n-  argbuf = (const char **) xmalloc (argbuf_length * sizeof (const char *));\n+  argbuf = xmalloc (argbuf_length * sizeof (const char *));\n }\n \n /* Clear out the vector of arguments (after a command is executed).  */\n@@ -1827,9 +1826,7 @@ static void\n store_arg (const char *arg, int delete_always, int delete_failure)\n {\n   if (argbuf_index + 1 == argbuf_length)\n-    argbuf\n-      = (const char **) xrealloc (argbuf,\n-\t\t\t\t  (argbuf_length *= 2) * sizeof (const char *));\n+    argbuf = xrealloc (argbuf, (argbuf_length *= 2) * sizeof (const char *));\n \n   argbuf[argbuf_index++] = arg;\n   argbuf[argbuf_index] = 0;\n@@ -2119,9 +2116,8 @@ read_specs (const char *filename, int main_p)\n \t{\n \t  /* Add this pair to the vector.  */\n \t  compilers\n-\t    = ((struct compiler *)\n-\t       xrealloc (compilers,\n-\t\t\t (n_compilers + 2) * sizeof (struct compiler)));\n+\t    = xrealloc (compilers,\n+\t\t\t(n_compilers + 2) * sizeof (struct compiler));\n \n \t  compilers[n_compilers].suffix = suffix;\n \t  compilers[n_compilers].spec = spec;\n@@ -2188,7 +2184,7 @@ record_temp_file (const char *filename, int always_delete, int fail_delete)\n \tif (! strcmp (name, temp->name))\n \t  goto already1;\n \n-      temp = (struct temp_file *) xmalloc (sizeof (struct temp_file));\n+      temp = xmalloc (sizeof (struct temp_file));\n       temp->next = always_delete_queue;\n       temp->name = name;\n       always_delete_queue = temp;\n@@ -2203,7 +2199,7 @@ record_temp_file (const char *filename, int always_delete, int fail_delete)\n \tif (! strcmp (name, temp->name))\n \t  goto already2;\n \n-      temp = (struct temp_file *) xmalloc (sizeof (struct temp_file));\n+      temp = xmalloc (sizeof (struct temp_file));\n       temp->next = failure_delete_queue;\n       temp->name = name;\n       failure_delete_queue = temp;\n@@ -2553,7 +2549,7 @@ add_prefix (struct path_prefix *pprefix, const char *prefix,\n   if (len > pprefix->max_len)\n     pprefix->max_len = len;\n \n-  pl = (struct prefix_list *) xmalloc (sizeof (struct prefix_list));\n+  pl = xmalloc (sizeof (struct prefix_list));\n   pl->prefix = prefix;\n   pl->require_machine_suffix = require_machine_suffix;\n   pl->used_flag_ptr = warn;\n@@ -2622,7 +2618,7 @@ execute (void)\n       n_commands++;\n \n   /* Get storage for each command.  */\n-  commands = (struct command *) alloca (n_commands * sizeof (struct command));\n+  commands = alloca (n_commands * sizeof (struct command));\n \n   /* Split argbuf into its separate piped processes,\n      and record info about each one.\n@@ -3034,12 +3030,10 @@ add_preprocessor_option (const char *option, int len)\n   n_preprocessor_options++;\n \n   if (! preprocessor_options)\n-    preprocessor_options\n-      = (char **) xmalloc (n_preprocessor_options * sizeof (char *));\n+    preprocessor_options = xmalloc (n_preprocessor_options * sizeof (char *));\n   else\n-    preprocessor_options\n-      = (char **) xrealloc (preprocessor_options,\n-\t\t\t    n_preprocessor_options * sizeof (char *));\n+    preprocessor_options = xrealloc (preprocessor_options,\n+\t\t\t\t     n_preprocessor_options * sizeof (char *));\n \n   preprocessor_options [n_preprocessor_options - 1] =\n     save_string (option, len);\n@@ -3051,12 +3045,10 @@ add_assembler_option (const char *option, int len)\n   n_assembler_options++;\n \n   if (! assembler_options)\n-    assembler_options\n-      = (char **) xmalloc (n_assembler_options * sizeof (char *));\n+    assembler_options = xmalloc (n_assembler_options * sizeof (char *));\n   else\n-    assembler_options\n-      = (char **) xrealloc (assembler_options,\n-\t\t\t    n_assembler_options * sizeof (char *));\n+    assembler_options = xrealloc (assembler_options,\n+\t\t\t\t  n_assembler_options * sizeof (char *));\n \n   assembler_options [n_assembler_options - 1] = save_string (option, len);\n }\n@@ -3067,12 +3059,10 @@ add_linker_option (const char *option, int len)\n   n_linker_options++;\n \n   if (! linker_options)\n-    linker_options\n-      = (char **) xmalloc (n_linker_options * sizeof (char *));\n+    linker_options = xmalloc (n_linker_options * sizeof (char *));\n   else\n-    linker_options\n-      = (char **) xrealloc (linker_options,\n-\t\t\t    n_linker_options * sizeof (char *));\n+    linker_options = xrealloc (linker_options,\n+\t\t\t       n_linker_options * sizeof (char *));\n \n   linker_options [n_linker_options - 1] = save_string (option, len);\n }\n@@ -3213,7 +3203,7 @@ process_command (int argc, const char *const *argv)\n   if (temp)\n     {\n       const char *startp, *endp;\n-      char *nstore = (char *) alloca (strlen (temp) + 3);\n+      char *nstore = alloca (strlen (temp) + 3);\n \n       startp = endp = temp;\n       while (1)\n@@ -3248,7 +3238,7 @@ process_command (int argc, const char *const *argv)\n   if (temp && *cross_compile == '0')\n     {\n       const char *startp, *endp;\n-      char *nstore = (char *) alloca (strlen (temp) + 3);\n+      char *nstore = alloca (strlen (temp) + 3);\n \n       startp = endp = temp;\n       while (1)\n@@ -3281,7 +3271,7 @@ process_command (int argc, const char *const *argv)\n   if (temp && *cross_compile == '0')\n     {\n       const char *startp, *endp;\n-      char *nstore = (char *) alloca (strlen (temp) + 3);\n+      char *nstore = alloca (strlen (temp) + 3);\n \n       startp = endp = temp;\n       while (1)\n@@ -3484,8 +3474,7 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n \t}\n       else if (strcmp (argv[i], \"-specs\") == 0)\n \t{\n-\t  struct user_specs *user = (struct user_specs *)\n-\t    xmalloc (sizeof (struct user_specs));\n+\t  struct user_specs *user = xmalloc (sizeof (struct user_specs));\n \t  if (++i >= argc)\n \t    fatal (\"argument to `-specs' is missing\");\n \n@@ -3499,8 +3488,7 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n \t}\n       else if (strncmp (argv[i], \"-specs=\", 7) == 0)\n \t{\n-\t  struct user_specs *user = (struct user_specs *)\n-\t    xmalloc (sizeof (struct user_specs));\n+\t  struct user_specs *user = xmalloc (sizeof (struct user_specs));\n \t  if (strlen (argv[i]) == 7)\n \t    fatal (\"argument to `-specs=' is missing\");\n \n@@ -3673,9 +3661,8 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n \t      for (j = 0; j < ARRAY_SIZE (modify_target); j++)\n \t\tif (! strcmp (argv[i], modify_target[j].sw))\n \t\t  {\n-\t\t    char *new_name\n-\t\t      = (char *) xmalloc (strlen (modify_target[j].str)\n-\t\t\t\t\t  + strlen (spec_machine));\n+\t\t    char *new_name = xmalloc (strlen (modify_target[j].str)\n+\t\t\t\t\t      + strlen (spec_machine));\n \t\t    const char *p, *r;\n \t\t    char *q;\n \t\t    int made_addition = 0;\n@@ -3818,9 +3805,8 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n \n   /* Then create the space for the vectors and scan again.  */\n \n-  switches = ((struct switchstr *)\n-\t      xmalloc ((n_switches + 1) * sizeof (struct switchstr)));\n-  infiles = (struct infile *) xmalloc ((n_infiles + 1) * sizeof (struct infile));\n+  switches = xmalloc ((n_switches + 1) * sizeof (struct switchstr));\n+  infiles = xmalloc ((n_infiles + 1) * sizeof (struct infile));\n   n_switches = 0;\n   n_infiles = 0;\n   last_language_n_infiles = -1;\n@@ -3969,7 +3955,7 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n \t      if (i + n_args >= argc)\n \t\tfatal (\"argument to `-%s' is missing\", p);\n \t      switches[n_switches].args\n-\t\t= (const char **) xmalloc ((n_args + 1) * sizeof(const char *));\n+\t\t= xmalloc ((n_args + 1) * sizeof(const char *));\n \t      while (j < n_args)\n \t\tswitches[n_switches].args[j++] = argv[++i];\n \t      /* Null-terminate the vector.  */\n@@ -3979,13 +3965,12 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n \t    {\n \t      /* On some systems, ld cannot handle some options without\n \t\t a space.  So split the option from its argument.  */\n-\t      char *part1 = (char *) xmalloc (2);\n+\t      char *part1 = xmalloc (2);\n \t      part1[0] = c;\n \t      part1[1] = '\\0';\n \n \t      switches[n_switches].part1 = part1;\n-\t      switches[n_switches].args\n-\t\t= (const char **) xmalloc (2 * sizeof (const char *));\n+\t      switches[n_switches].args = xmalloc (2 * sizeof (const char *));\n \t      switches[n_switches].args[0] = xstrdup (p+1);\n \t      switches[n_switches].args[1] = 0;\n \t    }\n@@ -4453,7 +4438,7 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t    {\n \t      struct prefix_list *pl = startfile_prefixes.plist;\n \t      size_t bufsize = 100;\n-\t      char *buffer = (char *) xmalloc (bufsize);\n+\t      char *buffer = xmalloc (bufsize);\n \t      int idx;\n \n \t      for (; pl; pl = pl->next)\n@@ -4481,7 +4466,7 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t\t\t      >= bufsize)\n \t\t\t    bufsize = (strlen (pl->prefix)\n \t\t\t\t       + strlen (machine_suffix)) * 2 + 1;\n-\t\t\t  buffer = (char *) xrealloc (buffer, bufsize);\n+\t\t\t  buffer = xrealloc (buffer, bufsize);\n \t\t\t  strcpy (buffer, pl->prefix);\n \t\t\t  strcat (buffer, machine_suffix);\n \t\t\t  if (is_directory (buffer, multilib_dir, 1))\n@@ -4523,7 +4508,7 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t\t\t  /* Remove slash from machine_suffix.  */\n \t\t\t  if (strlen (machine_suffix) >= bufsize)\n \t\t\t    bufsize = strlen (machine_suffix) * 2 + 1;\n-\t\t\t  buffer = (char *) xrealloc (buffer, bufsize);\n+\t\t\t  buffer = xrealloc (buffer, bufsize);\n \t\t\t  strcpy (buffer, machine_suffix);\n \t\t\t  idx = strlen (buffer);\n \t\t\t  if (IS_DIR_SEPARATOR (buffer[idx - 1]))\n@@ -4544,7 +4529,7 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t\t\t  /* Remove slash from pl->prefix.  */\n \t\t\t  if (strlen (pl->prefix) >= bufsize)\n \t\t\t    bufsize = strlen (pl->prefix) * 2 + 1;\n-\t\t\t  buffer = (char *) xrealloc (buffer, bufsize);\n+\t\t\t  buffer = xrealloc (buffer, bufsize);\n \t\t\t  strcpy (buffer, pl->prefix);\n \t\t\t  idx = strlen (buffer);\n \t\t\t  if (IS_DIR_SEPARATOR (buffer[idx - 1]))\n@@ -4567,7 +4552,7 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t      char *buf;\n \t      while (*p != 0 && *p != '\\n')\n \t\tp++;\n-\t      buf = (char *) alloca (p - q + 1);\n+\t      buf = alloca (p - q + 1);\n \t      strncpy (buf, q, p - q);\n \t      buf[p - q] = 0;\n \t      error (\"%s\", buf);\n@@ -4581,7 +4566,7 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t      char *buf;\n \t      while (*p != 0 && *p != '\\n')\n \t\tp++;\n-\t      buf = (char *) alloca (p - q + 1);\n+\t      buf = alloca (p - q + 1);\n \t      strncpy (buf, q, p - q);\n \t      buf[p - q] = 0;\n \t      notice (\"%s\\n\", buf);\n@@ -4663,8 +4648,8 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t\t    else\n \t\t      {\n \t\t\tsaved_suffix\n-\t\t\t  = (char *) xmalloc (suffix_length\n-\t\t\t\t\t      + strlen (TARGET_OBJECT_SUFFIX));\n+\t\t\t  = xmalloc (suffix_length\n+\t\t\t\t     + strlen (TARGET_OBJECT_SUFFIX));\n \t\t\tstrncpy (saved_suffix, suffix, suffix_length);\n \t\t\tstrcpy (saved_suffix + suffix_length,\n \t\t\t\tTARGET_OBJECT_SUFFIX);\n@@ -4735,7 +4720,7 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t\t  {\n \t\t    if (t == 0)\n \t\t      {\n-\t\t\tt = (struct temp_name *) xmalloc (sizeof (struct temp_name));\n+\t\t\tt = xmalloc (sizeof (struct temp_name));\n \t\t\tt->next = temp_names;\n \t\t\ttemp_names = t;\n \t\t      }\n@@ -5131,7 +5116,7 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      char *x = (char *) alloca (strlen (name) * 2 + 1);\n+\t\t      char *x = alloca (strlen (name) * 2 + 1);\n \t\t      char *buf = x;\n \t\t      const char *y = name;\n \t\t      int flag = 0;\n@@ -5812,7 +5797,7 @@ is_directory (const char *path1, const char *path2, int linker)\n {\n   int len1 = strlen (path1);\n   int len2 = strlen (path2);\n-  char *path = (char *) alloca (3 + len1 + len2);\n+  char *path = alloca (3 + len1 + len2);\n   char *cp;\n   struct stat st;\n \n@@ -6016,9 +6001,8 @@ main (int argc, const char *const *argv)\n   /* Initialize the vector of specs to just the default.\n      This means one element containing 0s, as a terminator.  */\n \n-  compilers = (struct compiler *) xmalloc (sizeof default_compilers);\n-  memcpy ((char *) compilers, (char *) default_compilers,\n-\t  sizeof default_compilers);\n+  compilers = xmalloc (sizeof default_compilers);\n+  memcpy (compilers, default_compilers, sizeof default_compilers);\n   n_compilers = n_default_compilers;\n \n   /* Read specs from a file if there is one.  */\n@@ -6036,9 +6020,8 @@ main (int argc, const char *const *argv)\n \n   /* We need to check standard_exec_prefix/just_machine_suffix/specs\n      for any override of as, ld and libraries.  */\n-  specs_file = (char *) alloca (strlen (standard_exec_prefix)\n-\t\t\t\t+ strlen (just_machine_suffix)\n-\t\t\t\t+ sizeof (\"specs\"));\n+  specs_file = alloca (strlen (standard_exec_prefix)\n+\t\t       + strlen (just_machine_suffix) + sizeof (\"specs\"));\n \n   strcpy (specs_file, standard_exec_prefix);\n   strcat (specs_file, just_machine_suffix);\n@@ -6297,7 +6280,7 @@ main (int argc, const char *const *argv)\n \n   i = n_infiles;\n   i += lang_specific_extra_outfiles;\n-  outfiles = (const char **) xcalloc (i, sizeof (char *));\n+  outfiles = xcalloc (i, sizeof (char *));\n \n   /* Record which files were specified explicitly as link input.  */\n \n@@ -6751,8 +6734,7 @@ used_arg (const char *p, int len)\n \tif (*q == ';')\n \t  cnt++;\n \n-      matches =\n-\t(struct mswitchstr *) alloca ((sizeof (struct mswitchstr)) * cnt);\n+      matches = alloca ((sizeof (struct mswitchstr)) * cnt);\n       i = 0;\n       q = multilib_matches;\n       while (*q != '\\0')\n@@ -6784,8 +6766,7 @@ used_arg (const char *p, int len)\n \t xmalloc from calling fatal, and prevents us from re-executing this\n \t block of code.  */\n       mswitches\n-\t= (struct mswitchstr *)\n-\t  xmalloc (sizeof (struct mswitchstr)\n+\t= xmalloc (sizeof (struct mswitchstr)\n \t\t   * (n_mdswitches + (n_switches ? n_switches : 1)));\n       for (i = 0; i < n_switches; i++)\n \t{\n@@ -6912,9 +6893,7 @@ set_multilib_dir (void)\n     {\n       int i = 0;\n \n-      mdswitches\n-        = (struct mdswitchstr *) xmalloc (sizeof (struct mdswitchstr)\n-\t\t\t\t\t  * n_mdswitches);\n+      mdswitches = xmalloc (sizeof (struct mdswitchstr) * n_mdswitches);\n       for (start = multilib_defaults; *start != '\\0'; start = end + 1)\n \t{\n \t  while (*start == ' ' || *start == '\\t')"}, {"sha": "fce784b2ede5316febf8f1ef2f3958d4b9936512", "filename": "gcc/gccspec.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fgccspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fgccspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgccspec.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -73,7 +73,7 @@ lang_specific_driver (int *in_argc ATTRIBUTE_UNUSED,\n   if  (shared_libgcc)\n     {\n       /* Make sure to have room for the trailing NULL argument.  */\n-      arglist = (const char **) xmalloc ((argc+2) * sizeof (char *));\n+      arglist = xmalloc ((argc+2) * sizeof (char *));\n \n       i = 0;\n       do"}, {"sha": "ff63274929125cec803d618847411fd49d83e04d", "filename": "gcc/gcov.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -520,7 +520,7 @@ process_file (const char *file_name)\n   for (fn = functions; fn; fn = fn->next)\n     solve_flow_graph (fn);\n   for (src = sources; src; src = src->next)\n-    src->lines = (line_t *) xcalloc (src->num_lines, sizeof (line_t));\n+    src->lines = xcalloc (src->num_lines, sizeof (line_t));\n   for (fn = functions; fn; fn = fn->next)\n     {\n       coverage_t coverage;\n@@ -682,7 +682,7 @@ find_source (const char *file_name)\n     if (!strcmp (file_name, src->name))\n       return src;\n \n-  src = (source_t *)xcalloc (1, sizeof (source_t));\n+  src = xcalloc (1, sizeof (source_t));\n   src->name = xstrdup (file_name);\n   src->coverage.name = src->name;\n   src->index = sources ? sources->index + 1 : 1;\n@@ -748,7 +748,7 @@ read_graph_file (void)\n \t  src = find_source (gcov_read_string ());\n \t  lineno = gcov_read_unsigned ();\n \n-\t  fn = (function_t *)xcalloc (1, sizeof (function_t));\n+\t  fn = xcalloc (1, sizeof (function_t));\n \t  fn->name = function_name;\n \t  fn->ident = ident;\n \t  fn->checksum = checksum;\n@@ -784,8 +784,7 @@ read_graph_file (void)\n \t      unsigned ix, num_blocks = GCOV_TAG_BLOCKS_NUM (length);\n \t      fn->num_blocks = num_blocks;\n \n-\t      fn->blocks\n-\t\t= (block_t *)xcalloc (fn->num_blocks, sizeof (block_t));\n+\t      fn->blocks = xcalloc (fn->num_blocks, sizeof (block_t));\n \t      for (ix = 0; ix != num_blocks; ix++)\n \t\tfn->blocks[ix].flags = gcov_read_unsigned ();\n \t    }\n@@ -806,7 +805,7 @@ read_graph_file (void)\n \n \t      if (dest >= fn->num_blocks)\n \t\tgoto corrupt;\n-\t      arc = (arc_t *) xcalloc (1, sizeof (arc_t));\n+\t      arc = xcalloc (1, sizeof (arc_t));\n \n \t      arc->dst = &fn->blocks[dest];\n \t      arc->src = &fn->blocks[src];\n@@ -851,8 +850,7 @@ read_graph_file (void)\n       else if (fn && tag == GCOV_TAG_LINES)\n \t{\n \t  unsigned blockno = gcov_read_unsigned ();\n-\t  unsigned *line_nos\n-\t    = (unsigned *)xcalloc (length - 1, sizeof (unsigned));\n+\t  unsigned *line_nos = xcalloc (length - 1, sizeof (unsigned));\n \n \t  if (blockno >= fn->num_blocks || fn->blocks[blockno].u.line.encoding)\n \t    goto corrupt;\n@@ -1047,8 +1045,7 @@ read_count_file (void)\n \t    goto mismatch;\n \n \t  if (!fn->counts)\n-\t    fn->counts\n-\t      = (gcov_type *)xcalloc (fn->num_counts, sizeof (gcov_type));\n+\t    fn->counts = xcalloc (fn->num_counts, sizeof (gcov_type));\n \n \t  for (ix = 0; ix != fn->num_counts; ix++)\n \t    fn->counts[ix] += gcov_read_counter ();"}, {"sha": "3b57aa1a85600043b13f0249a444851191fb5e8f", "filename": "gcc/gcse.c", "status": "modified", "additions": 57, "deletions": 64, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -549,9 +549,9 @@ struct null_pointer_info\n };\n \f\n static void compute_can_copy (void);\n-static char *gmalloc (unsigned int);\n-static char *grealloc (char *, unsigned int);\n-static char *gcse_alloc (unsigned long);\n+static void *gmalloc (unsigned int);\n+static void *grealloc (void *, unsigned int);\n+static void *gcse_alloc (unsigned long);\n static void alloc_gcse_mem (rtx);\n static void free_gcse_mem (void);\n static void alloc_reg_set_mem (int);\n@@ -821,12 +821,11 @@ gcse_main (rtx f, FILE *file)\n \t  if (changed)\n \t    {\n \t      free_modify_mem_tables ();\n-\t      modify_mem_list\n-\t\t= (rtx *) gmalloc (last_basic_block * sizeof (rtx));\n+\t      modify_mem_list = gmalloc (last_basic_block * sizeof (rtx));\n \t      canon_modify_mem_list\n-\t\t= (rtx *) gmalloc (last_basic_block * sizeof (rtx));\n-\t      memset ((char *) modify_mem_list, 0, last_basic_block * sizeof (rtx));\n-\t      memset ((char *) canon_modify_mem_list, 0, last_basic_block * sizeof (rtx));\n+\t\t= gmalloc (last_basic_block * sizeof (rtx));\n+\t      memset (modify_mem_list, 0, last_basic_block * sizeof (rtx));\n+\t      memset (canon_modify_mem_list, 0, last_basic_block * sizeof (rtx));\n \t    }\n \t  free_reg_set_mem ();\n \t  alloc_reg_set_mem (max_reg_num ());\n@@ -954,7 +953,7 @@ can_copy_p (enum machine_mode mode)\n \f\n /* Cover function to xmalloc to record bytes allocated.  */\n \n-static char *\n+static void *\n gmalloc (unsigned int size)\n {\n   bytes_used += size;\n@@ -965,19 +964,19 @@ gmalloc (unsigned int size)\n    We don't record the additional size since we don't know it.\n    It won't affect memory usage stats much anyway.  */\n \n-static char *\n-grealloc (char *ptr, unsigned int size)\n+static void *\n+grealloc (void *ptr, unsigned int size)\n {\n   return xrealloc (ptr, size);\n }\n \n /* Cover function to obstack_alloc.  */\n \n-static char *\n+static void *\n gcse_alloc (unsigned long size)\n {\n   bytes_used += size;\n-  return (char *) obstack_alloc (&gcse_obstack, size);\n+  return obstack_alloc (&gcse_obstack, size);\n }\n \n /* Allocate memory for the cuid mapping array,\n@@ -997,8 +996,8 @@ alloc_gcse_mem (rtx f)\n \n   max_uid = get_max_uid ();\n   n = (max_uid + 1) * sizeof (int);\n-  uid_cuid = (int *) gmalloc (n);\n-  memset ((char *) uid_cuid, 0, n);\n+  uid_cuid = gmalloc (n);\n+  memset (uid_cuid, 0, n);\n   for (insn = f, i = 0; insn; insn = NEXT_INSN (insn))\n     {\n       if (INSN_P (insn))\n@@ -1011,8 +1010,8 @@ alloc_gcse_mem (rtx f)\n \n   max_cuid = i;\n   n = (max_cuid + 1) * sizeof (rtx);\n-  cuid_insn = (rtx *) gmalloc (n);\n-  memset ((char *) cuid_insn, 0, n);\n+  cuid_insn = gmalloc (n);\n+  memset (cuid_insn, 0, n);\n   for (insn = f, i = 0; insn; insn = NEXT_INSN (insn))\n     if (INSN_P (insn))\n       CUID_INSN (i++) = insn;\n@@ -1021,14 +1020,13 @@ alloc_gcse_mem (rtx f)\n   reg_set_bitmap = BITMAP_XMALLOC ();\n \n   /* Allocate vars to track sets of regs, memory per block.  */\n-  reg_set_in_block = (sbitmap *) sbitmap_vector_alloc (last_basic_block,\n-\t\t\t\t\t\t       max_gcse_regno);\n+  reg_set_in_block = sbitmap_vector_alloc (last_basic_block, max_gcse_regno);\n   /* Allocate array to keep a list of insns which modify memory in each\n      basic block.  */\n-  modify_mem_list = (rtx *) gmalloc (last_basic_block * sizeof (rtx));\n-  canon_modify_mem_list = (rtx *) gmalloc (last_basic_block * sizeof (rtx));\n-  memset ((char *) modify_mem_list, 0, last_basic_block * sizeof (rtx));\n-  memset ((char *) canon_modify_mem_list, 0, last_basic_block * sizeof (rtx));\n+  modify_mem_list = gmalloc (last_basic_block * sizeof (rtx));\n+  canon_modify_mem_list = gmalloc (last_basic_block * sizeof (rtx));\n+  memset (modify_mem_list, 0, last_basic_block * sizeof (rtx));\n+  memset (canon_modify_mem_list, 0, last_basic_block * sizeof (rtx));\n   modify_mem_list_set = BITMAP_XMALLOC ();\n   canon_modify_mem_list_set = BITMAP_XMALLOC ();\n }\n@@ -1195,8 +1193,8 @@ alloc_reg_set_mem (int n_regs)\n \n   reg_set_table_size = n_regs + REG_SET_TABLE_SLOP;\n   n = reg_set_table_size * sizeof (struct reg_set *);\n-  reg_set_table = (struct reg_set **) gmalloc (n);\n-  memset ((char *) reg_set_table, 0, n);\n+  reg_set_table = gmalloc (n);\n+  memset (reg_set_table, 0, n);\n \n   gcc_obstack_init (&reg_set_obstack);\n }\n@@ -1221,16 +1219,14 @@ record_one_set (int regno, rtx insn)\n     {\n       int new_size = regno + REG_SET_TABLE_SLOP;\n \n-      reg_set_table\n-\t= (struct reg_set **) grealloc ((char *) reg_set_table,\n-\t\t\t\t\tnew_size * sizeof (struct reg_set *));\n-      memset ((char *) (reg_set_table + reg_set_table_size), 0,\n+      reg_set_table = grealloc (reg_set_table,\n+\t\t\t\tnew_size * sizeof (struct reg_set *));\n+      memset (reg_set_table + reg_set_table_size, 0,\n \t      (new_size - reg_set_table_size) * sizeof (struct reg_set *));\n       reg_set_table_size = new_size;\n     }\n \n-  new_reg_info = (struct reg_set *) obstack_alloc (&reg_set_obstack,\n-\t\t\t\t\t\t   sizeof (struct reg_set));\n+  new_reg_info = obstack_alloc (&reg_set_obstack, sizeof (struct reg_set));\n   bytes_used += sizeof (struct reg_set);\n   new_reg_info->insn = insn;\n   new_reg_info->next = reg_set_table[regno];\n@@ -1937,7 +1933,7 @@ insert_expr_in_table (rtx x, enum machine_mode mode, rtx insn, int antic_p,\n \n   if (! found)\n     {\n-      cur_expr = (struct expr *) gcse_alloc (sizeof (struct expr));\n+      cur_expr = gcse_alloc (sizeof (struct expr));\n       bytes_used += sizeof (struct expr);\n       if (table->table[hash] == NULL)\n \t/* This is the first pattern that hashed to this index.  */\n@@ -1976,7 +1972,7 @@ insert_expr_in_table (rtx x, enum machine_mode mode, rtx insn, int antic_p,\n       else\n \t{\n \t  /* First occurrence of this expression in this basic block.  */\n-\t  antic_occr = (struct occr *) gcse_alloc (sizeof (struct occr));\n+\t  antic_occr = gcse_alloc (sizeof (struct occr));\n \t  bytes_used += sizeof (struct occr);\n \t  /* First occurrence of this expression in any block?  */\n \t  if (cur_expr->antic_occr == NULL)\n@@ -2011,7 +2007,7 @@ insert_expr_in_table (rtx x, enum machine_mode mode, rtx insn, int antic_p,\n       else\n \t{\n \t  /* First occurrence of this expression in this basic block.  */\n-\t  avail_occr = (struct occr *) gcse_alloc (sizeof (struct occr));\n+\t  avail_occr = gcse_alloc (sizeof (struct occr));\n \t  bytes_used += sizeof (struct occr);\n \n \t  /* First occurrence of this expression in any block?  */\n@@ -2058,7 +2054,7 @@ insert_set_in_table (rtx x, rtx insn, struct hash_table *table)\n \n   if (! found)\n     {\n-      cur_expr = (struct expr *) gcse_alloc (sizeof (struct expr));\n+      cur_expr = gcse_alloc (sizeof (struct expr));\n       bytes_used += sizeof (struct expr);\n       if (table->table[hash] == NULL)\n \t/* This is the first pattern that hashed to this index.  */\n@@ -2097,7 +2093,7 @@ insert_set_in_table (rtx x, rtx insn, struct hash_table *table)\n   else\n     {\n       /* First occurrence of this expression in this basic block.  */\n-      cur_occr = (struct occr *) gcse_alloc (sizeof (struct occr));\n+      cur_occr = gcse_alloc (sizeof (struct occr));\n       bytes_used += sizeof (struct occr);\n \n       /* First occurrence of this expression in any block?  */\n@@ -2286,9 +2282,8 @@ dump_hash_table (FILE *file, const char *name, struct hash_table *table)\n   unsigned int *hash_val;\n   struct expr *expr;\n \n-  flat_table\n-    = (struct expr **) xcalloc (table->n_elems, sizeof (struct expr *));\n-  hash_val = (unsigned int *) xmalloc (table->n_elems * sizeof (unsigned int));\n+  flat_table = xcalloc (table->n_elems, sizeof (struct expr *));\n+  hash_val = xmalloc (table->n_elems * sizeof (unsigned int));\n \n   for (i = 0; i < (int) table->size; i++)\n     for (expr = table->table[i]; expr != NULL; expr = expr->next_same_hash)\n@@ -2459,8 +2454,7 @@ compute_hash_table_work (struct hash_table *table)\n   /* re-Cache any INSN_LIST nodes we have allocated.  */\n   clear_modify_mem_tables ();\n   /* Some working arrays used to track first and last set in each block.  */\n-  reg_avail_info = (struct reg_avail_info*)\n-    gmalloc (max_gcse_regno * sizeof (struct reg_avail_info));\n+  reg_avail_info = gmalloc (max_gcse_regno * sizeof (struct reg_avail_info));\n \n   for (i = 0; i < max_gcse_regno; ++i)\n     reg_avail_info[i].last_bb = NULL;\n@@ -2550,7 +2544,7 @@ alloc_hash_table (int n_insns, struct hash_table *table, int set_p)\n      ??? Later take some measurements.  */\n   table->size |= 1;\n   n = table->size * sizeof (struct expr *);\n-  table->table = (struct expr **) gmalloc (n);\n+  table->table = gmalloc (n);\n   table->set_p = set_p;\n }\n \n@@ -2570,8 +2564,7 @@ compute_hash_table (struct hash_table *table)\n {\n   /* Initialize count of number of entries in hash table.  */\n   table->n_elems = 0;\n-  memset ((char *) table->table, 0,\n-\t  table->size * sizeof (struct expr *));\n+  memset (table->table, 0, table->size * sizeof (struct expr *));\n \n   compute_hash_table_work (table);\n }\n@@ -2842,16 +2835,16 @@ mark_oprs_set (rtx insn)\n static void\n alloc_rd_mem (int n_blocks, int n_insns)\n {\n-  rd_kill = (sbitmap *) sbitmap_vector_alloc (n_blocks, n_insns);\n+  rd_kill = sbitmap_vector_alloc (n_blocks, n_insns);\n   sbitmap_vector_zero (rd_kill, n_blocks);\n \n-  rd_gen = (sbitmap *) sbitmap_vector_alloc (n_blocks, n_insns);\n+  rd_gen = sbitmap_vector_alloc (n_blocks, n_insns);\n   sbitmap_vector_zero (rd_gen, n_blocks);\n \n-  reaching_defs = (sbitmap *) sbitmap_vector_alloc (n_blocks, n_insns);\n+  reaching_defs = sbitmap_vector_alloc (n_blocks, n_insns);\n   sbitmap_vector_zero (reaching_defs, n_blocks);\n \n-  rd_out = (sbitmap *) sbitmap_vector_alloc (n_blocks, n_insns);\n+  rd_out = sbitmap_vector_alloc (n_blocks, n_insns);\n   sbitmap_vector_zero (rd_out, n_blocks);\n }\n \n@@ -2969,16 +2962,16 @@ compute_rd (void)\n static void\n alloc_avail_expr_mem (int n_blocks, int n_exprs)\n {\n-  ae_kill = (sbitmap *) sbitmap_vector_alloc (n_blocks, n_exprs);\n+  ae_kill = sbitmap_vector_alloc (n_blocks, n_exprs);\n   sbitmap_vector_zero (ae_kill, n_blocks);\n \n-  ae_gen = (sbitmap *) sbitmap_vector_alloc (n_blocks, n_exprs);\n+  ae_gen = sbitmap_vector_alloc (n_blocks, n_exprs);\n   sbitmap_vector_zero (ae_gen, n_blocks);\n \n-  ae_in = (sbitmap *) sbitmap_vector_alloc (n_blocks, n_exprs);\n+  ae_in = sbitmap_vector_alloc (n_blocks, n_exprs);\n   sbitmap_vector_zero (ae_in, n_blocks);\n \n-  ae_out = (sbitmap *) sbitmap_vector_alloc (n_blocks, n_exprs);\n+  ae_out = sbitmap_vector_alloc (n_blocks, n_exprs);\n   sbitmap_vector_zero (ae_out, n_blocks);\n }\n \n@@ -3175,7 +3168,7 @@ expr_reaches_here_p (struct occr *occr, struct expr *expr, basic_block bb,\n \t\t     int check_self_loop)\n {\n   int rval;\n-  char *visited = (char *) xcalloc (last_basic_block, 1);\n+  char *visited = xcalloc (last_basic_block, 1);\n \n   rval = expr_reaches_here_p_work (occr, expr, bb, check_self_loop, visited);\n \n@@ -4591,7 +4584,7 @@ one_cprop_pass (int pass, int cprop_jumps, int bypass_jumps)\n   local_cprop_pass (cprop_jumps);\n \n   /* Determine implicit sets.  */\n-  implicit_sets = (rtx *) xcalloc (last_basic_block, sizeof (rtx));\n+  implicit_sets = xcalloc (last_basic_block, sizeof (rtx));\n   find_implicit_sets ();\n \n   alloc_hash_table (max_cuid, &set_hash_table, 1);\n@@ -5108,7 +5101,7 @@ static int\n pre_expr_reaches_here_p (basic_block occr_bb, struct expr *expr, basic_block bb)\n {\n   int rval;\n-  char *visited = (char *) xcalloc (last_basic_block, 1);\n+  char *visited = xcalloc (last_basic_block, 1);\n \n   rval = pre_expr_reaches_here_p_work (occr_bb, expr, bb, visited);\n \n@@ -5577,7 +5570,7 @@ pre_gcse (void)\n   /* Compute a mapping from expression number (`bitmap_index') to\n      hash table entry.  */\n \n-  index_map = (struct expr **) xcalloc (expr_hash_table.n_elems, sizeof (struct expr *));\n+  index_map = xcalloc (expr_hash_table.n_elems, sizeof (struct expr *));\n   for (i = 0; i < expr_hash_table.size; i++)\n     for (expr = expr_hash_table.table[i]; expr != NULL; expr = expr->next_same_hash)\n       index_map[expr->bitmap_index] = expr;\n@@ -5988,7 +5981,7 @@ delete_null_pointer_checks (rtx f ATTRIBUTE_UNUSED)\n   /* Go through the basic blocks, seeing whether or not each block\n      ends with a conditional branch whose condition is a comparison\n      against zero.  Record the register compared in BLOCK_REG.  */\n-  block_reg = (unsigned int *) xcalloc (last_basic_block, sizeof (int));\n+  block_reg = xcalloc (last_basic_block, sizeof (int));\n   FOR_EACH_BB (bb)\n     {\n       rtx last_insn = bb->end;\n@@ -6220,7 +6213,7 @@ hoist_code (void)\n   /* Compute a mapping from expression number (`bitmap_index') to\n      hash table entry.  */\n \n-  index_map = (struct expr **) xcalloc (expr_hash_table.n_elems, sizeof (struct expr *));\n+  index_map = xcalloc (expr_hash_table.n_elems, sizeof (struct expr *));\n   for (i = 0; i < expr_hash_table.size; i++)\n     for (expr = expr_hash_table.table[i]; expr != NULL; expr = expr->next_same_hash)\n       index_map[expr->bitmap_index] = expr;\n@@ -6433,7 +6426,7 @@ ldst_entry (rtx x)\n \n   if (!ptr)\n     {\n-      ptr = (struct ls_expr *) xmalloc (sizeof (struct ls_expr));\n+      ptr = xmalloc (sizeof (struct ls_expr));\n \n       ptr->next         = pre_ldst_mems;\n       ptr->expr         = NULL;\n@@ -7079,7 +7072,7 @@ compute_store_table (void)\n \n   max_gcse_regno = max_reg_num ();\n \n-  reg_set_in_block = (sbitmap *) sbitmap_vector_alloc (last_basic_block,\n+  reg_set_in_block = sbitmap_vector_alloc (last_basic_block,\n \t\t\t\t\t\t       max_gcse_regno);\n   sbitmap_vector_zero (reg_set_in_block, last_basic_block);\n   pre_ldst_mems = 0;\n@@ -7379,10 +7372,10 @@ build_store_vectors (void)\n \n   /* Build the gen_vector. This is any store in the table which is not killed\n      by aliasing later in its block.  */\n-  ae_gen = (sbitmap *) sbitmap_vector_alloc (last_basic_block, num_stores);\n+  ae_gen = sbitmap_vector_alloc (last_basic_block, num_stores);\n   sbitmap_vector_zero (ae_gen, last_basic_block);\n \n-  st_antloc = (sbitmap *) sbitmap_vector_alloc (last_basic_block, num_stores);\n+  st_antloc = sbitmap_vector_alloc (last_basic_block, num_stores);\n   sbitmap_vector_zero (st_antloc, last_basic_block);\n \n   for (ptr = first_ls_expr (); ptr != NULL; ptr = next_ls_expr (ptr))\n@@ -7415,10 +7408,10 @@ build_store_vectors (void)\n \t}\n     }\n \n-  ae_kill = (sbitmap *) sbitmap_vector_alloc (last_basic_block, num_stores);\n+  ae_kill = sbitmap_vector_alloc (last_basic_block, num_stores);\n   sbitmap_vector_zero (ae_kill, last_basic_block);\n \n-  transp = (sbitmap *) sbitmap_vector_alloc (last_basic_block, num_stores);\n+  transp = sbitmap_vector_alloc (last_basic_block, num_stores);\n   sbitmap_vector_zero (transp, last_basic_block);\n   regs_set_in_block = xmalloc (sizeof (int) * max_gcse_regno);\n "}, {"sha": "49f368e53fced343cab53513ccc22a3e9cc3dbe0", "filename": "gcc/genattr.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fgenattr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fgenattr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattr.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -268,8 +268,7 @@ main (int argc, char **argv)\n \n \t  if (unit == 0)\n \t    {\n-\t      unit = (struct function_unit *)\n-\t\txmalloc (sizeof (struct function_unit));\n+\t      unit = xmalloc (sizeof (struct function_unit));\n \t      unit->name = xstrdup (name);\n \t      unit->multiplicity = multiplicity;\n \t      unit->simultaneity = simultaneity;"}, {"sha": "30a889ca70d5c359cae89540e7fbb4a6ee4a9970", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 28, "deletions": 35, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -500,8 +500,7 @@ attr_hash_add_rtx (int hashcode, rtx rtl)\n {\n   struct attr_hash *h;\n \n-  h = (struct attr_hash *) obstack_alloc (hash_obstack,\n-\t\t\t\t\t  sizeof (struct attr_hash));\n+  h = obstack_alloc (hash_obstack, sizeof (struct attr_hash));\n   h->hashcode = hashcode;\n   h->u.rtl = rtl;\n   h->next = attr_hash_table[hashcode % RTL_HASH_SIZE];\n@@ -515,8 +514,7 @@ attr_hash_add_string (int hashcode, char *str)\n {\n   struct attr_hash *h;\n \n-  h = (struct attr_hash *) obstack_alloc (hash_obstack,\n-\t\t\t\t\t  sizeof (struct attr_hash));\n+  h = obstack_alloc (hash_obstack, sizeof (struct attr_hash));\n   h->hashcode = -hashcode;\n   h->u.str = str;\n   h->next = attr_hash_table[hashcode % RTL_HASH_SIZE];\n@@ -779,7 +777,7 @@ attr_string (const char *str, int len)\n       return h->u.str;\t\t\t/* <-- return if found.  */\n \n   /* Not found; create a permanent copy and add it to the hash table.  */\n-  new_str = (char *) obstack_alloc (hash_obstack, len + 1);\n+  new_str = obstack_alloc (hash_obstack, len + 1);\n   memcpy (new_str, str, len);\n   new_str[len] = '\\0';\n   attr_hash_add_string (hashcode, new_str);\n@@ -1459,7 +1457,7 @@ get_attr_value (rtx value, struct attr_desc *attr, int insn_code)\n \t    || insn_alternatives[av->first_insn->insn_code]))\n       return av;\n \n-  av = (struct attr_value *) oballoc (sizeof (struct attr_value));\n+  av = oballoc (sizeof (struct attr_value));\n   av->value = value;\n   av->next = attr->first_value;\n   attr->first_value = av;\n@@ -1875,29 +1873,26 @@ expand_units (void)\n \n   /* Create an array of ops for each unit.  Add an extra unit for the\n      result_ready_cost function that has the ops of all other units.  */\n-  unit_ops = (struct function_unit_op ***)\n-    xmalloc ((num_units + 1) * sizeof (struct function_unit_op **));\n-  unit_num = (struct function_unit **)\n-    xmalloc ((num_units + 1) * sizeof (struct function_unit *));\n+  unit_ops = xmalloc ((num_units + 1) * sizeof (struct function_unit_op **));\n+  unit_num = xmalloc ((num_units + 1) * sizeof (struct function_unit *));\n \n-  unit_num[num_units] = unit = (struct function_unit *)\n-    xmalloc (sizeof (struct function_unit));\n+  unit_num[num_units] = unit = xmalloc (sizeof (struct function_unit));\n   unit->num = num_units;\n   unit->num_opclasses = 0;\n \n   for (unit = units; unit; unit = unit->next)\n     {\n       unit_num[num_units]->num_opclasses += unit->num_opclasses;\n       unit_num[unit->num] = unit;\n-      unit_ops[unit->num] = op_array = (struct function_unit_op **)\n+      unit_ops[unit->num] = op_array =\n \txmalloc (unit->num_opclasses * sizeof (struct function_unit_op *));\n \n       for (op = unit->ops; op; op = op->next)\n \top_array[op->num] = op;\n     }\n \n   /* Compose the array of ops for the extra unit.  */\n-  unit_ops[num_units] = op_array = (struct function_unit_op **)\n+  unit_ops[num_units] = op_array =\n     xmalloc (unit_num[num_units]->num_opclasses\n \t    * sizeof (struct function_unit_op *));\n \n@@ -2253,7 +2248,7 @@ fill_attr (struct attr_desc *attr)\n       else\n \tav = get_attr_value (value, attr, id->insn_code);\n \n-      ie = (struct insn_ent *) oballoc (sizeof (struct insn_ent));\n+      ie = oballoc (sizeof (struct insn_ent));\n       ie->insn_code = id->insn_code;\n       ie->insn_index = id->insn_code;\n       insert_insn_ent (av, ie);\n@@ -2379,7 +2374,7 @@ make_length_attrs (void)\n \t\t\t\t\t\t\t no_address_fn[i],\n \t\t\t\t\t\t\t address_fn[i]),\n \t\t\t\t     new_attr, ie->insn_code);\n-\t    new_ie = (struct insn_ent *) oballoc (sizeof (struct insn_ent));\n+\t    new_ie = oballoc (sizeof (struct insn_ent));\n \t    new_ie->insn_code = ie->insn_code;\n \t    new_ie->insn_index = ie->insn_index;\n \t    insert_insn_ent (new_av, new_ie);\n@@ -2458,7 +2453,7 @@ simplify_cond (rtx exp, int insn_code, int insn_index)\n   rtx defval = XEXP (exp, 1);\n   rtx new_defval = XEXP (exp, 1);\n   int len = XVECLEN (exp, 0);\n-  rtx *tests = (rtx *) xmalloc (len * sizeof (rtx));\n+  rtx *tests = xmalloc (len * sizeof (rtx));\n   int allsame = 1;\n   rtx ret;\n \n@@ -3398,17 +3393,15 @@ optimize_attrs (void)\n     return;\n \n   /* Make 2 extra elements, for \"code\" values -2 and -1.  */\n-  insn_code_values\n-    = (struct attr_value_list **) xmalloc ((insn_code_number + 2)\n-\t\t\t\t\t  * sizeof (struct attr_value_list *));\n-  memset ((char *) insn_code_values, 0,\n-\t (insn_code_number + 2) * sizeof (struct attr_value_list *));\n+  insn_code_values = xmalloc ((insn_code_number + 2)\n+\t\t\t      * sizeof (struct attr_value_list *));\n+  memset (insn_code_values, 0,\n+\t  (insn_code_number + 2) * sizeof (struct attr_value_list *));\n \n   /* Offset the table address so we can index by -2 or -1.  */\n   insn_code_values += 2;\n \n-  iv = ivbuf = ((struct attr_value_list *)\n-\t\txmalloc (num_insn_ents * sizeof (struct attr_value_list)));\n+  iv = ivbuf = xmalloc (num_insn_ents * sizeof (struct attr_value_list));\n \n   for (i = 0; i < MAX_ATTRS_INDEX; i++)\n     for (attr = attrs[i]; attr; attr = attr->next)\n@@ -3499,7 +3492,7 @@ simplify_by_exploding (rtx exp)\n      cover the domain of the attribute.  This makes the expanded COND form\n      order independent.  */\n \n-  space = (struct dimension *) xmalloc (ndim * sizeof (struct dimension));\n+  space = xmalloc (ndim * sizeof (struct dimension));\n \n   total = 1;\n   for (ndim = 0; list; ndim++)\n@@ -3554,8 +3547,8 @@ simplify_by_exploding (rtx exp)\n   for (i = 0; i < ndim; i++)\n     space[i].current_value = space[i].values;\n \n-  condtest = (rtx *) xmalloc (total * sizeof (rtx));\n-  condval = (rtx *) xmalloc (total * sizeof (rtx));\n+  condtest = xmalloc (total * sizeof (rtx));\n+  condval = xmalloc (total * sizeof (rtx));\n \n   /* Expand the tests and values by iterating over all values in the\n      attribute space.  */\n@@ -4052,7 +4045,7 @@ gen_attr (rtx exp, int lineno)\n       name_ptr = XSTR (exp, 1);\n       while ((p = next_comma_elt (&name_ptr)) != NULL)\n \t{\n-\t  av = (struct attr_value *) oballoc (sizeof (struct attr_value));\n+\t  av = oballoc (sizeof (struct attr_value));\n \t  av->value = attr_rtx (CONST_STRING, p);\n \t  av->next = attr->first_value;\n \t  attr->first_value = av;\n@@ -4196,7 +4189,7 @@ gen_insn (rtx exp, int lineno)\n {\n   struct insn_def *id;\n \n-  id = (struct insn_def *) oballoc (sizeof (struct insn_def));\n+  id = oballoc (sizeof (struct insn_def));\n   id->next = defs;\n   defs = id;\n   id->def = exp;\n@@ -4260,7 +4253,7 @@ gen_delay (rtx def, int lineno)\n \thave_annul_false = 1;\n     }\n \n-  delay = (struct delay_desc *) oballoc (sizeof (struct delay_desc));\n+  delay = oballoc (sizeof (struct delay_desc));\n   delay->def = def;\n   delay->num = ++num_delays;\n   delay->next = delays;\n@@ -4307,7 +4300,7 @@ gen_unit (rtx def, int lineno)\n \n   if (unit == 0)\n     {\n-      unit = (struct function_unit *) oballoc (sizeof (struct function_unit));\n+      unit = oballoc (sizeof (struct function_unit));\n       unit->name = name;\n       unit->multiplicity = multiplicity;\n       unit->simultaneity = simultaneity;\n@@ -4322,7 +4315,7 @@ gen_unit (rtx def, int lineno)\n     }\n \n   /* Make a new operation class structure entry and initialize it.  */\n-  op = (struct function_unit_op *) oballoc (sizeof (struct function_unit_op));\n+  op = oballoc (sizeof (struct function_unit_op));\n   op->condexp = condexp;\n   op->num = unit->num_opclasses++;\n   op->ready = ready_cost;\n@@ -5579,7 +5572,7 @@ find_attr (const char *name, int create)\n   if (! create)\n     return NULL;\n \n-  attr = (struct attr_desc *) oballoc (sizeof (struct attr_desc));\n+  attr = oballoc (sizeof (struct attr_desc));\n   attr->name = attr_string (name, strlen (name));\n   attr->first_value = attr->default_val = NULL;\n   attr->is_numeric = attr->negative_ok = attr->is_const = attr->is_special = 0;\n@@ -5896,13 +5889,13 @@ from the machine description file `md'.  */\\n\\n\");\n   printf (\"#define operands recog_data.operand\\n\\n\");\n \n   /* Make `insn_alternatives'.  */\n-  insn_alternatives = (int *) oballoc (insn_code_number * sizeof (int));\n+  insn_alternatives = oballoc (insn_code_number * sizeof (int));\n   for (id = defs; id; id = id->next)\n     if (id->insn_code >= 0)\n       insn_alternatives[id->insn_code] = (1 << id->num_alternatives) - 1;\n \n   /* Make `insn_n_alternatives'.  */\n-  insn_n_alternatives = (int *) oballoc (insn_code_number * sizeof (int));\n+  insn_n_alternatives = oballoc (insn_code_number * sizeof (int));\n   for (id = defs; id; id = id->next)\n     if (id->insn_code >= 0)\n       insn_n_alternatives[id->insn_code] = id->num_alternatives;"}, {"sha": "a5783e6f80db24f6e8dc48a893a5622e39af8a6a", "filename": "gcc/genautomata.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -1922,15 +1922,15 @@ gen_automaton (rtx def)\n void\n gen_automata_option (rtx def)\n {\n-  if (strcmp ((char *) XSTR (def, 0), NO_MINIMIZATION_OPTION + 1) == 0)\n+  if (strcmp (XSTR (def, 0), NO_MINIMIZATION_OPTION + 1) == 0)\n     no_minimization_flag = 1;\n-  else if (strcmp ((char *) XSTR (def, 0), TIME_OPTION + 1) == 0)\n+  else if (strcmp (XSTR (def, 0), TIME_OPTION + 1) == 0)\n     time_flag = 1;\n-  else if (strcmp ((char *) XSTR (def, 0), V_OPTION + 1) == 0)\n+  else if (strcmp (XSTR (def, 0), V_OPTION + 1) == 0)\n     v_flag = 1;\n-  else if (strcmp ((char *) XSTR (def, 0), W_OPTION + 1) == 0)\n+  else if (strcmp (XSTR (def, 0), W_OPTION + 1) == 0)\n     w_flag = 1;\n-  else if (strcmp ((char *) XSTR (def, 0), NDFA_OPTION + 1) == 0)\n+  else if (strcmp (XSTR (def, 0), NDFA_OPTION + 1) == 0)\n     ndfa_flag = 1;\n   else\n     fatal (\"invalid option `%s' in automata_option\", XSTR (def, 0));\n@@ -8842,8 +8842,7 @@ output_get_cpu_unit_code_func (void)\n \t   LOW_VARIABLE_NAME, MIDDLE_VARIABLE_NAME, HIGH_VARIABLE_NAME);\n   fprintf (output_file, \"  static struct %s %s [] =\\n    {\\n\",\n \t   NAME_CODE_STRUCT_NAME, NAME_CODE_TABLE_NAME);\n-  units = (unit_decl_t *) xmalloc (sizeof (unit_decl_t)\n-\t\t\t\t   * description->units_num);\n+  units = xmalloc (sizeof (unit_decl_t) * description->units_num);\n   memcpy (units, units_array, sizeof (unit_decl_t) * description->units_num);\n   qsort (units, description->units_num, sizeof (unit_decl_t), units_cmp);\n   for (i = 0; i < description->units_num; i++)\n@@ -8927,7 +8926,7 @@ output_dfa_start_func (void)\n   fprintf (output_file,\n \t   \"void\\n%s (void)\\n{\\n  %s = get_max_uid ();\\n\",\n \t   DFA_START_FUNC_NAME, DFA_INSN_CODES_LENGTH_VARIABLE_NAME);\n-  fprintf (output_file, \"  %s = (int *) xmalloc (%s * sizeof (int));\\n\",\n+  fprintf (output_file, \"  %s = xmalloc (%s * sizeof (int));\\n\",\n \t   DFA_INSN_CODES_VARIABLE_NAME, DFA_INSN_CODES_LENGTH_VARIABLE_NAME);\n   fprintf (output_file, \"  %s ();\\n}\\n\\n\", DFA_CLEAN_INSN_CACHE_FUNC_NAME);\n }"}, {"sha": "32ac5aef475f04c944058d19d07c13fb9a8dc470", "filename": "gcc/genconditions.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fgenconditions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fgenconditions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconditions.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -57,7 +57,7 @@ add_condition (const char *expr)\n   if (expr[0] == 0)\n     return;\n \n-  test = (struct c_test *) xmalloc (sizeof (struct c_test));\n+  test = xmalloc (sizeof (struct c_test));\n   test->expr = expr;\n \n   *(htab_find_slot (condition_table, test, INSERT)) = test;"}, {"sha": "8a821d67bc27e06b2cd784c2344ec0f7c6049be5", "filename": "gcc/genemit.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -317,8 +317,7 @@ gen_insn (rtx insn, int lineno)\n       if (i != XVECLEN (insn, 1) - 1)\n \t{\n \t  struct clobber_pat *p;\n-\t  struct clobber_ent *link\n-\t    = (struct clobber_ent *) xmalloc (sizeof (struct clobber_ent));\n+\t  struct clobber_ent *link = xmalloc (sizeof (struct clobber_ent));\n \t  int j;\n \n \t  link->code_number = insn_code_number;\n@@ -354,7 +353,7 @@ gen_insn (rtx insn, int lineno)\n \n \t  if (p == 0)\n \t    {\n-\t      p = (struct clobber_pat *) xmalloc (sizeof (struct clobber_pat));\n+\t      p = xmalloc (sizeof (struct clobber_pat));\n \n \t      p->insns = 0;\n \t      p->pattern = insn;"}, {"sha": "d3365736510af167dbb5d246e6c1534427c06e1b", "filename": "gcc/genextract.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fgenextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fgenextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenextract.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -129,7 +129,7 @@ gen_insn (rtx insn)\n \twalk_rtx (XVECEXP (insn, 1, i), path);\n       }\n \n-  link = (struct code_ptr *) xmalloc (sizeof (struct code_ptr));\n+  link = xmalloc (sizeof (struct code_ptr));\n   link->insn_code = insn_code_number;\n \n   /* See if we find something that already had this extraction method.  */\n@@ -164,7 +164,7 @@ gen_insn (rtx insn)\n \n   /* Otherwise, make a new extraction method.  */\n \n-  p = (struct extraction *) xmalloc (sizeof (struct extraction));\n+  p = xmalloc (sizeof (struct extraction));\n   p->op_count = op_count;\n   p->dup_count = dup_count;\n   p->next = extractions;\n@@ -220,7 +220,7 @@ walk_rtx (rtx x, const char *path)\n       dupnums[dup_count] = XINT (x, 0);\n       dup_count++;\n \n-      newpath = (char *) xmalloc (depth + 2);\n+      newpath = xmalloc (depth + 2);\n       strcpy (newpath, path);\n       newpath[depth + 1] = 0;\n \n@@ -236,7 +236,7 @@ walk_rtx (rtx x, const char *path)\n       oplocs[XINT (x, 0)] = xstrdup (path);\n       op_count = MAX (op_count, XINT (x, 0) + 1);\n \n-      newpath = (char *) xmalloc (depth + 2);\n+      newpath = xmalloc (depth + 2);\n       strcpy (newpath, path);\n       newpath[depth + 1] = 0;\n \n@@ -252,7 +252,7 @@ walk_rtx (rtx x, const char *path)\n       oplocs[XINT (x, 0)] = xstrdup (path);\n       op_count = MAX (op_count, XINT (x, 0) + 1);\n \n-      newpath = (char *) xmalloc (depth + 2);\n+      newpath = xmalloc (depth + 2);\n       strcpy (newpath, path);\n       newpath[depth + 1] = 0;\n \n@@ -272,7 +272,7 @@ walk_rtx (rtx x, const char *path)\n       break;\n     }\n \n-  newpath = (char *) xmalloc (depth + 2);\n+  newpath = xmalloc (depth + 2);\n   strcpy (newpath, path);\n   newpath[depth + 1] = 0;\n \n@@ -412,8 +412,7 @@ from the machine description file `md'.  */\\n\\n\");\n \n       else if (GET_CODE (desc) == DEFINE_PEEPHOLE)\n \t{\n-\t  struct code_ptr *link\n-\t    = (struct code_ptr *) xmalloc (sizeof (struct code_ptr));\n+\t  struct code_ptr *link = xmalloc (sizeof (struct code_ptr));\n \n \t  link->insn_code = insn_code_number;\n \t  link->next = peepholes;\n@@ -509,8 +508,7 @@ record_insn_name (int code, const char *name)\n     {\n       int new_size;\n       new_size = (insn_name_ptr_size ? insn_name_ptr_size * 2 : 512);\n-      insn_name_ptr =\n-\t(char **) xrealloc (insn_name_ptr, sizeof(char *) * new_size);\n+      insn_name_ptr = xrealloc (insn_name_ptr, sizeof(char *) * new_size);\n       memset (insn_name_ptr + insn_name_ptr_size, 0,\n \t      sizeof(char *) * (new_size - insn_name_ptr_size));\n       insn_name_ptr_size = new_size;"}, {"sha": "74725fa57b312388b8741e8c5954762a9d2da2e3", "filename": "gcc/genoutput.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -782,7 +782,7 @@ validate_insn_operands (struct data *d)\n static void\n gen_insn (rtx insn, int lineno)\n {\n-  struct data *d = (struct data *) xmalloc (sizeof (struct data));\n+  struct data *d = xmalloc (sizeof (struct data));\n   int i;\n \n   d->code_number = next_code_number;\n@@ -823,7 +823,7 @@ gen_insn (rtx insn, int lineno)\n static void\n gen_peephole (rtx peep, int lineno)\n {\n-  struct data *d = (struct data *) xmalloc (sizeof (struct data));\n+  struct data *d = xmalloc (sizeof (struct data));\n   int i;\n \n   d->code_number = next_code_number;\n@@ -861,7 +861,7 @@ gen_peephole (rtx peep, int lineno)\n static void\n gen_expand (rtx insn, int lineno)\n {\n-  struct data *d = (struct data *) xmalloc (sizeof (struct data));\n+  struct data *d = xmalloc (sizeof (struct data));\n   int i;\n \n   d->code_number = next_code_number;\n@@ -904,7 +904,7 @@ gen_expand (rtx insn, int lineno)\n static void\n gen_split (rtx split, int lineno)\n {\n-  struct data *d = (struct data *) xmalloc (sizeof (struct data));\n+  struct data *d = xmalloc (sizeof (struct data));\n   int i;\n \n   d->code_number = next_code_number;"}, {"sha": "65387123436a1dbf55a1e3d13dcc0eb8dd708dae", "filename": "gcc/genrecog.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -316,8 +316,7 @@ extern void debug_decision_list\n static struct decision *\n new_decision (const char *position, struct decision_head *last)\n {\n-  struct decision *new\n-    = (struct decision *) xmalloc (sizeof (struct decision));\n+  struct decision *new = xmalloc (sizeof (struct decision));\n \n   memset (new, 0, sizeof (*new));\n   new->success = *last;\n@@ -336,7 +335,7 @@ new_decision_test (enum decision_type type, struct decision_test ***pplace)\n   struct decision_test **place = *pplace;\n   struct decision_test *test;\n \n-  test = (struct decision_test *) xmalloc (sizeof (*test));\n+  test = xmalloc (sizeof (*test));\n   test->next = *place;\n   test->type = type;\n   *place = test;\n@@ -770,7 +769,7 @@ add_to_sequence (rtx pattern, struct decision_head *last, const char *position,\n   if (depth > max_depth)\n     max_depth = depth;\n \n-  subpos = (char *) xmalloc (depth + 2);\n+  subpos = xmalloc (depth + 2);\n   strcpy (subpos, position);\n   subpos[depth + 1] = 0;\n \n@@ -2667,8 +2666,7 @@ record_insn_name (int code, const char *name)\n     {\n       int new_size;\n       new_size = (insn_name_ptr_size ? insn_name_ptr_size * 2 : 512);\n-      insn_name_ptr =\n-\t(char **) xrealloc (insn_name_ptr, sizeof(char *) * new_size);\n+      insn_name_ptr = xrealloc (insn_name_ptr, sizeof(char *) * new_size);\n       memset (insn_name_ptr + insn_name_ptr_size, 0,\n \t      sizeof(char *) * (new_size - insn_name_ptr_size));\n       insn_name_ptr_size = new_size;"}, {"sha": "23f8e3f32cdb660578f21633f7c228e196093e12", "filename": "gcc/gensupport.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -140,7 +140,7 @@ static void\n queue_pattern (rtx pattern, struct queue_elem ***list_tail,\n \t       const char *filename, int lineno)\n {\n-  struct queue_elem *e = (struct queue_elem *) xmalloc (sizeof (*e));\n+  struct queue_elem *e = xmalloc (sizeof (*e));\n   e->data = pattern;\n   e->filename = filename;\n   e->lineno = lineno;\n@@ -583,7 +583,7 @@ alter_predicate_for_insn (rtx pattern, int alt, int max_op, int lineno)\n \t  {\n \t    size_t c_len = strlen (c);\n \t    size_t len = alt * (c_len + 1);\n-\t    char *new_c = (char *) xmalloc (len);\n+\t    char *new_c = xmalloc (len);\n \n \t    memcpy (new_c, c, c_len);\n \t    for (i = 1; i < alt; ++i)\n@@ -876,8 +876,7 @@ init_md_reader_args (int argc, char **argv)\n \t      {\n \t\tstruct file_name_list *dirtmp;\n \n-\t\tdirtmp = (struct file_name_list *)\n-\t\t  xmalloc (sizeof (struct file_name_list));\n+\t\tdirtmp = xmalloc (sizeof (struct file_name_list));\n \t\tdirtmp->next = 0;\t/* New one goes on the end */\n \t\tif (first_dir_md_include == 0)\n \t\t  first_dir_md_include = dirtmp;\n@@ -1078,7 +1077,7 @@ maybe_eval_c_test (const char *expr)\n     return -1;\n \n   dummy.expr = expr;\n-  test = (const struct c_test *) htab_find (condition_table, &dummy);\n+  test = htab_find (condition_table, &dummy);\n   if (!test)\n     abort ();\n "}, {"sha": "7b0697e9fa877822e0bcac81cfc85b109d32b3ff", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -478,8 +478,7 @@ push_depth (unsigned int i)\n   if (G.depth_in_use >= G.depth_max)\n     {\n       G.depth_max *= 2;\n-      G.depth = (unsigned int *) xrealloc ((char *) G.depth,\n-\t\t\t\t\t   G.depth_max * sizeof (unsigned int));\n+      G.depth = xrealloc (G.depth, G.depth_max * sizeof (unsigned int));\n     }\n   G.depth[G.depth_in_use++] = i;\n }\n@@ -492,10 +491,10 @@ push_by_depth (page_entry *p, unsigned long *s)\n   if (G.by_depth_in_use >= G.by_depth_max)\n     {\n       G.by_depth_max *= 2;\n-      G.by_depth = (page_entry **) xrealloc ((char *) G.by_depth,\n-\t\t\t\t\t     G.by_depth_max * sizeof (page_entry *));\n-      G.save_in_use = (unsigned long **) xrealloc ((char *) G.save_in_use,\n-\t\t\t\t\t\t   G.by_depth_max * sizeof (unsigned long *));\n+      G.by_depth = xrealloc (G.by_depth,\n+\t\t\t     G.by_depth_max * sizeof (page_entry *));\n+      G.save_in_use = xrealloc (G.save_in_use,\n+\t\t\t\tG.by_depth_max * sizeof (unsigned long *));\n     }\n   G.by_depth[G.by_depth_in_use] = p;\n   G.save_in_use[G.by_depth_in_use++] = s;\n@@ -587,7 +586,7 @@ set_page_table_entry (void *p, page_entry *entry)\n       goto found;\n \n   /* Not found -- allocate a new table.  */\n-  table = (page_table) xcalloc (1, sizeof(*table));\n+  table = xcalloc (1, sizeof(*table));\n   table->next = G.lookup;\n   table->high_bits = high_bits;\n   G.lookup = table;\n@@ -600,7 +599,7 @@ set_page_table_entry (void *p, page_entry *entry)\n   L2 = LOOKUP_L2 (p);\n \n   if (base[L1] == NULL)\n-    base[L1] = (page_entry **) xcalloc (PAGE_L2_SIZE, sizeof (page_entry *));\n+    base[L1] = xcalloc (PAGE_L2_SIZE, sizeof (page_entry *));\n \n   base[L1][L2] = entry;\n }\n@@ -748,7 +747,7 @@ alloc_page (unsigned order)\n \t memory order.  */\n       for (i = GGC_QUIRE_SIZE - 1; i >= 1; i--)\n \t{\n-\t  e = (struct page_entry *) xcalloc (1, page_entry_size);\n+\t  e = xcalloc (1, page_entry_size);\n \t  e->order = order;\n \t  e->bytes = G.pagesize;\n \t  e->page = page + (i << G.lg_pagesize);\n@@ -820,7 +819,7 @@ alloc_page (unsigned order)\n \t  struct page_entry *e, *f = G.free_pages;\n \t  for (a = enda - G.pagesize; a != page; a -= G.pagesize)\n \t    {\n-\t      e = (struct page_entry *) xcalloc (1, page_entry_size);\n+\t      e = xcalloc (1, page_entry_size);\n \t      e->order = order;\n \t      e->bytes = G.pagesize;\n \t      e->page = a;\n@@ -834,7 +833,7 @@ alloc_page (unsigned order)\n #endif\n \n   if (entry == NULL)\n-    entry = (struct page_entry *) xcalloc (1, page_entry_size);\n+    entry = xcalloc (1, page_entry_size);\n \n   entry->bytes = entry_size;\n   entry->page = page;\n@@ -1327,7 +1326,7 @@ init_ggc (void)\n       }\n \n     /* We have a good page, might as well hold onto it...  */\n-    e = (struct page_entry *) xcalloc (1, sizeof (struct page_entry));\n+    e = xcalloc (1, sizeof (struct page_entry));\n     e->bytes = G.pagesize;\n     e->page = p;\n     e->next = G.free_pages;\n@@ -1373,12 +1372,12 @@ init_ggc (void)\n \n   G.depth_in_use = 0;\n   G.depth_max = 10;\n-  G.depth = (unsigned int *) xmalloc (G.depth_max * sizeof (unsigned int));\n+  G.depth = xmalloc (G.depth_max * sizeof (unsigned int));\n \n   G.by_depth_in_use = 0;\n   G.by_depth_max = INITIAL_PTE_COUNT;\n-  G.by_depth = (page_entry **) xmalloc (G.by_depth_max * sizeof (page_entry *));\n-  G.save_in_use = (unsigned long **) xmalloc (G.by_depth_max * sizeof (unsigned long *));\n+  G.by_depth = xmalloc (G.by_depth_max * sizeof (page_entry *));\n+  G.save_in_use = xmalloc (G.by_depth_max * sizeof (unsigned long *));\n }\n \n /* Increment the `GC context'.  Objects allocated in an outer context\n@@ -2017,8 +2016,8 @@ move_ptes_to_front (int count_old_page_tables, int count_new_page_tables)\n   page_entry **new_by_depth;\n   unsigned long **new_save_in_use;\n \n-  new_by_depth = (page_entry **) xmalloc (G.by_depth_max * sizeof (page_entry *));\n-  new_save_in_use = (unsigned long **) xmalloc (G.by_depth_max * sizeof (unsigned long *));\n+  new_by_depth = xmalloc (G.by_depth_max * sizeof (page_entry *));\n+  new_save_in_use = xmalloc (G.by_depth_max * sizeof (unsigned long *));\n \n   memcpy (&new_by_depth[0],\n \t  &G.by_depth[count_old_page_tables],"}, {"sha": "eee33a568af144bdca6336b2c02b81e6f8a39f67", "filename": "gcc/ggc-simple.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fggc-simple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fggc-simple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-simple.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -166,7 +166,7 @@ ggc_alloc (size_t size)\n {\n   struct ggc_mem *x;\n \n-  x = (struct ggc_mem *) xmalloc (offsetof (struct ggc_mem, u) + size);\n+  x = xmalloc (offsetof (struct ggc_mem, u) + size);\n   x->sub[0] = NULL;\n   x->sub[1] = NULL;\n   x->mark = 0;"}, {"sha": "c808e2074067cbb45912974e99c2f169a94a4f4e", "filename": "gcc/global.c", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -398,14 +398,14 @@ global_alloc (FILE *file)\n   /* Establish mappings from register number to allocation number\n      and vice versa.  In the process, count the allocnos.  */\n \n-  reg_allocno = (int *) xmalloc (max_regno * sizeof (int));\n+  reg_allocno = xmalloc (max_regno * sizeof (int));\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     reg_allocno[i] = -1;\n \n   /* Initialize the shared-hard-reg mapping\n      from the list of pairs that may share.  */\n-  reg_may_share = (int *) xcalloc (max_regno, sizeof (int));\n+  reg_may_share = xcalloc (max_regno, sizeof (int));\n   for (x = regs_may_share; x; x = XEXP (XEXP (x, 1), 1))\n     {\n       int r1 = REGNO (XEXP (x, 0));\n@@ -436,7 +436,7 @@ global_alloc (FILE *file)\n     else\n       reg_allocno[i] = -1;\n \n-  allocno = (struct allocno *) xcalloc (max_allocno, sizeof (struct allocno));\n+  allocno = xcalloc (max_allocno, sizeof (struct allocno));\n \n   for (i = FIRST_PSEUDO_REGISTER; i < (size_t) max_regno; i++)\n     if (reg_allocno[i] >= 0)\n@@ -454,9 +454,9 @@ global_alloc (FILE *file)\n   /* Calculate amount of usage of each hard reg by pseudos\n      allocated by local-alloc.  This is to see if we want to\n      override it.  */\n-  memset ((char *) local_reg_live_length, 0, sizeof local_reg_live_length);\n-  memset ((char *) local_reg_n_refs, 0, sizeof local_reg_n_refs);\n-  memset ((char *) local_reg_freq, 0, sizeof local_reg_freq);\n+  memset (local_reg_live_length, 0, sizeof local_reg_live_length);\n+  memset (local_reg_n_refs, 0, sizeof local_reg_n_refs);\n+  memset (local_reg_freq, 0, sizeof local_reg_freq);\n   for (i = FIRST_PSEUDO_REGISTER; i < (size_t) max_regno; i++)\n     if (reg_renumber[i] >= 0)\n       {\n@@ -482,10 +482,9 @@ global_alloc (FILE *file)\n   /* We used to use alloca here, but the size of what it would try to\n      allocate would occasionally cause it to exceed the stack limit and\n      cause unpredictable core dumps.  Some examples were > 2Mb in size.  */\n-  conflicts = (INT_TYPE *) xcalloc (max_allocno * allocno_row_words,\n-\t\t\t\t    sizeof (INT_TYPE));\n+  conflicts = xcalloc (max_allocno * allocno_row_words, sizeof (INT_TYPE));\n \n-  allocnos_live = (INT_TYPE *) xmalloc (allocno_row_words * sizeof (INT_TYPE));\n+  allocnos_live = xmalloc (allocno_row_words * sizeof (INT_TYPE));\n \n   /* If there is work to be done (at least one reg to allocate),\n      perform global conflict analysis and allocate the regs.  */\n@@ -522,7 +521,7 @@ global_alloc (FILE *file)\n \n       /* Determine the order to allocate the remaining pseudo registers.  */\n \n-      allocno_order = (int *) xmalloc (max_allocno * sizeof (int));\n+      allocno_order = xmalloc (max_allocno * sizeof (int));\n       for (i = 0; i < (size_t) max_allocno; i++)\n \tallocno_order[i] = i;\n \n@@ -633,13 +632,13 @@ global_conflicts (void)\n   int *block_start_allocnos;\n \n   /* Make a vector that mark_reg_{store,clobber} will store in.  */\n-  regs_set = (rtx *) xmalloc (max_parallel * sizeof (rtx) * 2);\n+  regs_set = xmalloc (max_parallel * sizeof (rtx) * 2);\n \n-  block_start_allocnos = (int *) xmalloc (max_allocno * sizeof (int));\n+  block_start_allocnos = xmalloc (max_allocno * sizeof (int));\n \n   FOR_EACH_BB (b)\n     {\n-      memset ((char *) allocnos_live, 0, allocno_row_words * sizeof (INT_TYPE));\n+      memset (allocnos_live, 0, allocno_row_words * sizeof (INT_TYPE));\n \n       /* Initialize table of registers currently live\n \t to the state at the beginning of this basic block.\n@@ -903,7 +902,7 @@ prune_preferences (void)\n {\n   int i;\n   int num;\n-  int *allocno_to_order = (int *) xmalloc (max_allocno * sizeof (int));\n+  int *allocno_to_order = xmalloc (max_allocno * sizeof (int));\n \n   /* Scan least most important to most important.\n      For each allocno, remove from preferences registers that cannot be used,"}, {"sha": "9ff50c18130f681c8df361852d32ffac9533e65e", "filename": "gcc/graph.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -225,7 +225,7 @@ print_rtl_graph_with_bb (const char *base, const char *suffix, rtx rtx_first)\n   size_t namelen = strlen (base);\n   size_t suffixlen = strlen (suffix);\n   size_t extlen = strlen (graph_ext[graph_dump_format]) + 1;\n-  char *buf = (char *) alloca (namelen + suffixlen + extlen);\n+  char *buf = alloca (namelen + suffixlen + extlen);\n   FILE *fp;\n \n   if (basic_block_info == NULL)\n@@ -245,10 +245,9 @@ print_rtl_graph_with_bb (const char *base, const char *suffix, rtx rtx_first)\n     {\n       enum bb_state { NOT_IN_BB, IN_ONE_BB, IN_MULTIPLE_BB };\n       int max_uid = get_max_uid ();\n-      int *start = (int *) xmalloc (max_uid * sizeof (int));\n-      int *end = (int *) xmalloc (max_uid * sizeof (int));\n-      enum bb_state *in_bb_p = (enum bb_state *)\n-\txmalloc (max_uid * sizeof (enum bb_state));\n+      int *start = xmalloc (max_uid * sizeof (int));\n+      int *end = xmalloc (max_uid * sizeof (int));\n+      enum bb_state *in_bb_p = xmalloc (max_uid * sizeof (enum bb_state));\n       basic_block bb;\n       int i;\n \n@@ -390,7 +389,7 @@ clean_graph_dump_file (const char *base, const char *suffix)\n   size_t namelen = strlen (base);\n   size_t suffixlen = strlen (suffix);\n   size_t extlen = strlen (graph_ext[graph_dump_format]) + 1;\n-  char *buf = (char *) alloca (namelen + extlen + suffixlen);\n+  char *buf = alloca (namelen + extlen + suffixlen);\n   FILE *fp;\n \n   memcpy (buf, base, namelen);\n@@ -422,7 +421,7 @@ finish_graph_dump_file (const char *base, const char *suffix)\n   size_t namelen = strlen (base);\n   size_t suffixlen = strlen (suffix);\n   size_t extlen = strlen (graph_ext[graph_dump_format]) + 1;\n-  char *buf = (char *) alloca (namelen + suffixlen + extlen);\n+  char *buf = alloca (namelen + suffixlen + extlen);\n   FILE *fp;\n \n   memcpy (buf, base, namelen);"}, {"sha": "1043f09e95c550880162e4a2b31d8e2a976580a0", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -658,9 +658,9 @@ get_unit_last_insn (int instance)\n static void\n clear_units (void)\n {\n-  memset ((char *) unit_last_insn, 0, sizeof (unit_last_insn));\n-  memset ((char *) unit_tick, 0, sizeof (unit_tick));\n-  memset ((char *) unit_n_insns, 0, sizeof (unit_n_insns));\n+  memset (unit_last_insn, 0, sizeof (unit_last_insn));\n+  memset (unit_tick, 0, sizeof (unit_tick));\n+  memset (unit_n_insns, 0, sizeof (unit_n_insns));\n }\n \n /* Return the issue-delay of an insn.  The scheduler using only DFA\n@@ -2130,21 +2130,20 @@ schedule_block (int b, int rgn_n_insns)\n   /* Allocate the ready list.  */\n   ready.veclen = rgn_n_insns + 1 + issue_rate;\n   ready.first = ready.veclen - 1;\n-  ready.vec = (rtx *) xmalloc (ready.veclen * sizeof (rtx));\n+  ready.vec = xmalloc (ready.veclen * sizeof (rtx));\n   ready.n_ready = 0;\n \n   if (targetm.sched.use_dfa_pipeline_interface\n       && (*targetm.sched.use_dfa_pipeline_interface) ())\n     {\n       /* It is used for first cycle multipass scheduling.  */\n       temp_state = alloca (dfa_state_size);\n-      ready_try = (char *) xmalloc ((rgn_n_insns + 1) * sizeof (char));\n+      ready_try = xmalloc ((rgn_n_insns + 1) * sizeof (char));\n       memset (ready_try, 0, (rgn_n_insns + 1) * sizeof (char));\n-      choice_stack\n-\t= (struct choice_entry *) xmalloc ((rgn_n_insns + 1)\n-\t\t\t\t\t   * sizeof (struct choice_entry));\n+      choice_stack = xmalloc ((rgn_n_insns + 1)\n+\t\t\t      * sizeof (struct choice_entry));\n       for (i = 0; i <= rgn_n_insns; i++)\n-\tchoice_stack[i].state = (state_t) xmalloc (dfa_state_size);\n+\tchoice_stack[i].state = xmalloc (dfa_state_size);\n     }\n \n   (*current_sched_info->init_ready_list) (&ready);\n@@ -2166,8 +2165,8 @@ schedule_block (int b, int rgn_n_insns)\n   else\n     max_insn_queue_index_macro_value = max_insn_queue_index;\n \n-  insn_queue = (rtx *) alloca ((MAX_INSN_QUEUE_INDEX + 1) * sizeof (rtx));\n-  memset ((char *) insn_queue, 0, (MAX_INSN_QUEUE_INDEX + 1) * sizeof (rtx));\n+  insn_queue = alloca ((MAX_INSN_QUEUE_INDEX + 1) * sizeof (rtx));\n+  memset (insn_queue, 0, (MAX_INSN_QUEUE_INDEX + 1) * sizeof (rtx));\n   last_clock_var = -1;\n \n   /* Start just before the beginning of time.  */\n@@ -2582,7 +2581,7 @@ sched_init (FILE *dump_file)\n      pseudos which do not cross calls.  */\n   old_max_uid = get_max_uid () + 1;\n \n-  h_i_d = (struct haifa_insn_data *) xcalloc (old_max_uid, sizeof (*h_i_d));\n+  h_i_d = xcalloc (old_max_uid, sizeof (*h_i_d));\n \n   for (i = 0; i < old_max_uid; i++)\n     h_i_d [i].cost = -1;\n@@ -2632,7 +2631,7 @@ sched_init (FILE *dump_file)\n     {\n       rtx line;\n \n-      line_note_head = (rtx *) xcalloc (last_basic_block, sizeof (rtx));\n+      line_note_head = xcalloc (last_basic_block, sizeof (rtx));\n \n       /* Save-line-note-head:\n          Determine the line-number at the start of each basic block."}, {"sha": "4740f1d5b21603e8625b6a568c504b42440f5e80", "filename": "gcc/hashtable.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fhashtable.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fhashtable.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhashtable.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -57,7 +57,7 @@ ht_create (unsigned int order)\n   unsigned int nslots = 1 << order;\n   hash_table *table;\n \n-  table = (hash_table *) xmalloc (sizeof (hash_table));\n+  table = xmalloc (sizeof (hash_table));\n   memset (table, 0, sizeof (hash_table));\n \n   /* Strings need no alignment.  */\n@@ -67,7 +67,7 @@ ht_create (unsigned int order)\n \n   obstack_alignment_mask (&table->stack) = 0;\n \n-  table->entries = (hashnode *) xcalloc (nslots, sizeof (hashnode));\n+  table->entries = xcalloc (nslots, sizeof (hashnode));\n   table->nslots = nslots;\n   return table;\n }\n@@ -158,7 +158,7 @@ ht_expand (hash_table *table)\n   unsigned int size, sizemask;\n \n   size = table->nslots * 2;\n-  nentries = (hashnode *) xcalloc (size, sizeof (hashnode));\n+  nentries = xcalloc (size, sizeof (hashnode));\n   sizemask = size - 1;\n \n   p = table->entries;"}, {"sha": "a8ee4faa5f3857c313dacb60ca63aee806e2ffe7", "filename": "gcc/integrate.c", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -283,7 +283,7 @@ initialize_for_inline (tree fndecl)\n   tree parms;\n \n   /* Clear out PARMDECL_MAP.  It was allocated in the caller's frame.  */\n-  memset ((char *) parmdecl_map, 0, max_parm_reg * sizeof (tree));\n+  memset (parmdecl_map, 0, max_parm_reg * sizeof (tree));\n   arg_vector = rtvec_alloc (list_length (DECL_ARGUMENTS (fndecl)));\n \n   for (parms = DECL_ARGUMENTS (fndecl), i = 0;\n@@ -442,7 +442,7 @@ save_for_inline (tree fndecl)\n      for the parms, prior to elimination of virtual registers.\n      These values are needed for substituting parms properly.  */\n   if (! flag_no_inline)\n-    parmdecl_map = (tree *) xmalloc (max_parm_reg * sizeof (tree));\n+    parmdecl_map = xmalloc (max_parm_reg * sizeof (tree));\n \n   /* Make and emit a return-label if we have not already done so.  */\n \n@@ -724,8 +724,8 @@ expand_inline_function (tree fndecl, tree parms, rtx target, int ignore,\n   /* Expand the function arguments.  Do this first so that any\n      new registers get created before we allocate the maps.  */\n \n-  arg_vals = (rtx *) xmalloc (nargs * sizeof (rtx));\n-  arg_trees = (tree *) xmalloc (nargs * sizeof (tree));\n+  arg_vals = xmalloc (nargs * sizeof (rtx));\n+  arg_trees = xmalloc (nargs * sizeof (tree));\n \n   for (formal = DECL_ARGUMENTS (fndecl), actual = parms, i = 0;\n        formal;\n@@ -820,22 +820,21 @@ expand_inline_function (tree fndecl, tree parms, rtx target, int ignore,\n \n   /* Allocate the structures we use to remap things.  */\n \n-  map = (struct inline_remap *) xcalloc (1, sizeof (struct inline_remap));\n+  map = xcalloc (1, sizeof (struct inline_remap));\n   map->fndecl = fndecl;\n \n   VARRAY_TREE_INIT (map->block_map, 10, \"block_map\");\n-  map->reg_map = (rtx *) xcalloc (max_regno, sizeof (rtx));\n+  map->reg_map = xcalloc (max_regno, sizeof (rtx));\n \n   /* We used to use alloca here, but the size of what it would try to\n      allocate would occasionally cause it to exceed the stack limit and\n      cause unpredictable core dumps.  */\n-  real_label_map\n-    = (rtx *) xmalloc ((max_labelno) * sizeof (rtx));\n+  real_label_map = xmalloc ((max_labelno) * sizeof (rtx));\n   map->label_map = real_label_map;\n   map->local_return_label = NULL_RTX;\n \n   inl_max_uid = (inl_f->emit->x_cur_insn_uid + 1);\n-  map->insn_map = (rtx *) xcalloc (inl_max_uid, sizeof (rtx));\n+  map->insn_map = xcalloc (inl_max_uid, sizeof (rtx));\n   map->min_insnno = 0;\n   map->max_insnno = inl_max_uid;\n \n@@ -1185,8 +1184,8 @@ expand_inline_function (tree fndecl, tree parms, rtx target, int ignore,\n \n   /* Initialize label_map.  get_label_from_map will actually make\n      the labels.  */\n-  memset ((char *) &map->label_map[min_labelno], 0,\n-\t (max_labelno - min_labelno) * sizeof (rtx));\n+  memset (&map->label_map[min_labelno], 0,\n+\t  (max_labelno - min_labelno) * sizeof (rtx));\n \n   /* Make copies of the decls of the symbols in the inline function, so that\n      the copies of the variables get declared in the current function.  Set\n@@ -3051,20 +3050,19 @@ get_func_hard_reg_initial_val (struct function *fun, rtx reg)\n \n   if (ivs == 0)\n     {\n-      fun->hard_reg_initial_vals = (void *) ggc_alloc (sizeof (initial_value_struct));\n+      fun->hard_reg_initial_vals = ggc_alloc (sizeof (initial_value_struct));\n       ivs = fun->hard_reg_initial_vals;\n       ivs->num_entries = 0;\n       ivs->max_entries = 5;\n-      ivs->entries = (initial_value_pair *) ggc_alloc (5 * sizeof (initial_value_pair));\n+      ivs->entries = ggc_alloc (5 * sizeof (initial_value_pair));\n     }\n \n   if (ivs->num_entries >= ivs->max_entries)\n     {\n       ivs->max_entries += 5;\n-      ivs->entries =\n-\t(initial_value_pair *) ggc_realloc (ivs->entries,\n-\t\t\t\t\t    ivs->max_entries\n-\t\t\t\t\t    * sizeof (initial_value_pair));\n+      ivs->entries = ggc_realloc (ivs->entries,\n+\t\t\t\t  ivs->max_entries\n+\t\t\t\t  * sizeof (initial_value_pair));\n     }\n \n   ivs->entries[ivs->num_entries].hard_reg = reg;"}, {"sha": "dd9d8d41a2b4b8005d679ae12404b466d84be582", "filename": "gcc/jump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -386,7 +386,7 @@ duplicate_loop_exit_test (rtx loop_start)\n \t    /* We can do the replacement.  Allocate reg_map if this is the\n \t       first replacement we found.  */\n \t    if (reg_map == 0)\n-\t      reg_map = (rtx *) xcalloc (max_reg, sizeof (rtx));\n+\t      reg_map = xcalloc (max_reg, sizeof (rtx));\n \n \t    REG_LOOP_TEST_P (reg) = 1;\n "}, {"sha": "124f38b7aa9901cbc99e18efe9a67f1d22fe86eb", "filename": "gcc/langhooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -461,7 +461,7 @@ write_global_declarations (void)\n \n   tree globals = (*lang_hooks.decls.getdecls) ();\n   int len = list_length (globals);\n-  tree *vec = (tree *) xmalloc (sizeof (tree) * len);\n+  tree *vec = xmalloc (sizeof (tree) * len);\n   int i;\n   tree decl;\n "}, {"sha": "0e47507752d6fb264dd75087f1c5dd4f66fd7bde", "filename": "gcc/lcm.c", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -106,8 +106,7 @@ compute_antinout_edge (sbitmap *antloc, sbitmap *transp, sbitmap *antin,\n   /* Allocate a worklist array/queue.  Entries are only added to the\n      list if they were not already on the list.  So the size is\n      bounded by the number of basic blocks.  */\n-  qin = qout = worklist\n-    = (basic_block *) xmalloc (sizeof (basic_block) * n_basic_blocks);\n+  qin = qout = worklist = xmalloc (sizeof (basic_block) * n_basic_blocks);\n \n   /* We want a maximal solution, so make an optimistic initialization of\n      ANTIN.  */\n@@ -259,7 +258,7 @@ compute_laterin (struct edge_list *edge_list, sbitmap *earliest,\n      list if they were not already on the list.  So the size is\n      bounded by the number of basic blocks.  */\n   qin = qout = worklist\n-    = (basic_block *) xmalloc (sizeof (basic_block) * (n_basic_blocks + 1));\n+    = xmalloc (sizeof (basic_block) * (n_basic_blocks + 1));\n \n   /* Initialize a mapping from each edge to its index.  */\n   for (i = 0; i < num_edges; i++)\n@@ -480,8 +479,7 @@ compute_available (sbitmap *avloc, sbitmap *kill, sbitmap *avout,\n   /* Allocate a worklist array/queue.  Entries are only added to the\n      list if they were not already on the list.  So the size is\n      bounded by the number of basic blocks.  */\n-  qin = qout = worklist\n-    = (basic_block *) xmalloc (sizeof (basic_block) * n_basic_blocks);\n+  qin = qout = worklist = xmalloc (sizeof (basic_block) * n_basic_blocks);\n \n   /* We want a maximal solution.  */\n   sbitmap_vector_ones (avout, last_basic_block);\n@@ -608,8 +606,7 @@ compute_nearerout (struct edge_list *edge_list, sbitmap *farthest,\n   /* Allocate a worklist array/queue.  Entries are only added to the\n      list if they were not already on the list.  So the size is\n      bounded by the number of basic blocks.  */\n-  tos = worklist\n-    = (basic_block *) xmalloc (sizeof (basic_block) * (n_basic_blocks + 1));\n+  tos = worklist = xmalloc (sizeof (basic_block) * (n_basic_blocks + 1));\n \n   /* Initialize NEARER for each edge and build a mapping from an edge to\n      its index.  */\n@@ -717,8 +714,8 @@ pre_edge_rev_lcm (FILE *file ATTRIBUTE_UNUSED, int n_exprs, sbitmap *transp,\n   edge_list = create_edge_list ();\n   num_edges = NUM_EDGES (edge_list);\n \n-  st_antin = (sbitmap *) sbitmap_vector_alloc (last_basic_block, n_exprs);\n-  st_antout = (sbitmap *) sbitmap_vector_alloc (last_basic_block, n_exprs);\n+  st_antin = sbitmap_vector_alloc (last_basic_block, n_exprs);\n+  st_antout = sbitmap_vector_alloc (last_basic_block, n_exprs);\n   sbitmap_vector_zero (st_antin, last_basic_block);\n   sbitmap_vector_zero (st_antout, last_basic_block);\n   compute_antinout_edge (st_antloc, transp, st_antin, st_antout);\n@@ -997,8 +994,7 @@ optimize_mode_switching (FILE *file)\n \tentry_exit_extra = 2;\n #endif\n \tbb_info[n_entities]\n-\t  = (struct bb_info *) xcalloc (last_basic_block + entry_exit_extra,\n-\t\t\t\t\tsizeof **bb_info);\n+\t  = xcalloc (last_basic_block + entry_exit_extra, sizeof **bb_info);\n \tentity_map[n_entities++] = e;\n \tif (num_modes[e] > max_num_modes)\n \t  max_num_modes = num_modes[e];"}, {"sha": "897af21b1a5ce17956fa7e555f5ad0aaea93b8d8", "filename": "gcc/line-map.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fline-map.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -80,8 +80,7 @@ add_line_map (struct line_maps *set, enum lc_reason reason,\n   if (set->used == set->allocated)\n     {\n       set->allocated = 2 * set->allocated + 256;\n-      set->maps = (struct line_map *)\n-\txrealloc (set->maps, set->allocated * sizeof (struct line_map));\n+      set->maps = xrealloc (set->maps, set->allocated * sizeof (struct line_map));\n     }\n \n   map = &set->maps[set->used++];"}, {"sha": "26cb7edaca38aac292d9045a3423ceffc7230388", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -356,16 +356,15 @@ local_alloc (void)\n      See the declarations of these variables, above,\n      for what they mean.  */\n \n-  qty = (struct qty *) xmalloc (max_qty * sizeof (struct qty));\n-  qty_phys_copy_sugg\n-    = (HARD_REG_SET *) xmalloc (max_qty * sizeof (HARD_REG_SET));\n-  qty_phys_num_copy_sugg = (short *) xmalloc (max_qty * sizeof (short));\n-  qty_phys_sugg = (HARD_REG_SET *) xmalloc (max_qty * sizeof (HARD_REG_SET));\n-  qty_phys_num_sugg = (short *) xmalloc (max_qty * sizeof (short));\n+  qty = xmalloc (max_qty * sizeof (struct qty));\n+  qty_phys_copy_sugg = xmalloc (max_qty * sizeof (HARD_REG_SET));\n+  qty_phys_num_copy_sugg = xmalloc (max_qty * sizeof (short));\n+  qty_phys_sugg = xmalloc (max_qty * sizeof (HARD_REG_SET));\n+  qty_phys_num_sugg = xmalloc (max_qty * sizeof (short));\n \n-  reg_qty = (int *) xmalloc (max_regno * sizeof (int));\n-  reg_offset = (char *) xmalloc (max_regno * sizeof (char));\n-  reg_next_in_qty = (int *) xmalloc (max_regno * sizeof (int));\n+  reg_qty = xmalloc (max_regno * sizeof (int));\n+  reg_offset = xmalloc (max_regno * sizeof (char));\n+  reg_next_in_qty = xmalloc (max_regno * sizeof (int));\n \n   /* Determine which pseudo-registers can be allocated by local-alloc.\n      In general, these are the registers used only in a single block and\n@@ -409,7 +408,7 @@ local_alloc (void)\n       else\n \t{\n #define CLEAR(vector)  \\\n-\t  memset ((char *) (vector), 0, (sizeof (*(vector))) * next_qty);\n+\t  memset ((vector), 0, (sizeof (*(vector))) * next_qty);\n \n \t  CLEAR (qty_phys_copy_sugg);\n \t  CLEAR (qty_phys_num_copy_sugg);\n@@ -798,7 +797,7 @@ update_equiv_regs (void)\n   regset_head cleared_regs;\n   int clear_regnos = 0;\n \n-  reg_equiv = (struct equivalence *) xcalloc (max_regno, sizeof *reg_equiv);\n+  reg_equiv = xcalloc (max_regno, sizeof *reg_equiv);\n   INIT_REG_SET (&cleared_regs);\n \n   init_alias_analysis ();\n@@ -1218,8 +1217,7 @@ block_alloc (int b)\n \n   /* +2 to leave room for a post_mark_life at the last insn and for\n      the birth of a CLOBBER in the first insn.  */\n-  regs_live_at = (HARD_REG_SET *) xcalloc ((2 * insn_count + 2),\n-\t\t\t\t\t   sizeof (HARD_REG_SET));\n+  regs_live_at = xcalloc ((2 * insn_count + 2), sizeof (HARD_REG_SET));\n \n   /* Initialize table of hardware registers currently live.  */\n \n@@ -1475,7 +1473,7 @@ block_alloc (int b)\n      number of suggested registers they need so we allocate those with\n      the most restrictive needs first.  */\n \n-  qty_order = (int *) xmalloc (next_qty * sizeof (int));\n+  qty_order = xmalloc (next_qty * sizeof (int));\n   for (i = 0; i < next_qty; i++)\n     qty_order[i] = i;\n "}, {"sha": "ba25dff5696c4a022c9c9dba98a22e149c4c4e90", "filename": "gcc/loop.c", "status": "modified", "additions": 24, "deletions": 32, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -460,13 +460,11 @@ loop_optimize (rtx f, FILE *dumpfile, int flags)\n      Leave some space for labels allocated by find_and_verify_loops.  */\n   max_uid_for_loop = get_max_uid () + 1 + max_loop_num * 32;\n \n-  uid_luid = (int *) xcalloc (max_uid_for_loop, sizeof (int));\n-  uid_loop = (struct loop **) xcalloc (max_uid_for_loop,\n-\t\t\t\t       sizeof (struct loop *));\n+  uid_luid = xcalloc (max_uid_for_loop, sizeof (int));\n+  uid_loop = xcalloc (max_uid_for_loop, sizeof (struct loop *));\n \n   /* Allocate storage for array of loops.  */\n-  loops->array = (struct loop *)\n-    xcalloc (loops->num, sizeof (struct loop));\n+  loops->array = xcalloc (loops->num, sizeof (struct loop));\n \n   /* Find and process each loop.\n      First, find them, and record them in order of their beginnings.  */\n@@ -908,7 +906,7 @@ scan_loop (struct loop *loop, int flags)\n \t\t      continue;\n \t\t    }\n \n-\t\t  m = (struct movable *) xmalloc (sizeof (struct movable));\n+\t\t  m = xmalloc (sizeof (struct movable));\n \t\t  m->next = 0;\n \t\t  m->insn = p;\n \t\t  m->set_src = src;\n@@ -996,7 +994,7 @@ scan_loop (struct loop *loop, int flags)\n \t\t  if (regs->array[regno].set_in_loop == 2)\n \t\t    {\n \t\t      struct movable *m;\n-\t\t      m = (struct movable *) xmalloc (sizeof (struct movable));\n+\t\t      m = xmalloc (sizeof (struct movable));\n \t\t      m->next = 0;\n \t\t      m->insn = p;\n \t\t      m->set_dest = SET_DEST (set);\n@@ -1440,7 +1438,7 @@ static void\n combine_movables (struct loop_movables *movables, struct loop_regs *regs)\n {\n   struct movable *m;\n-  char *matched_regs = (char *) xmalloc (regs->num);\n+  char *matched_regs = xmalloc (regs->num);\n   enum machine_mode mode;\n \n   /* Regs that are set more than once are not allowed to match\n@@ -1775,8 +1773,8 @@ move_movables (struct loop *loop, struct loop_movables *movables,\n   /* Map of pseudo-register replacements to handle combining\n      when we move several insns that load the same value\n      into different pseudo-registers.  */\n-  rtx *reg_map = (rtx *) xcalloc (nregs, sizeof (rtx));\n-  char *already_moved = (char *) xcalloc (nregs, sizeof (char));\n+  rtx *reg_map = xcalloc (nregs, sizeof (rtx));\n+  char *already_moved = xcalloc (nregs, sizeof (char));\n \n   for (m = movables->head; m; m = m->next)\n     {\n@@ -2120,8 +2118,8 @@ move_movables (struct loop *loop, struct loop_movables *movables,\n \t\t\t}\n \t\t      else if (m->insert_temp)\n \t\t\t{\n-\t\t\t  rtx *reg_map2 = (rtx *) xcalloc (REGNO (newreg),\n-\t\t\t\tsizeof(rtx));\n+\t\t\t  rtx *reg_map2 = xcalloc (REGNO (newreg),\n+\t\t\t\t\t\t   sizeof(rtx));\n \t\t\t  reg_map2 [m->regno] = newreg;\n \n \t\t\t  i1 = loop_insn_hoist (loop, copy_rtx (PATTERN (p)));\n@@ -5068,7 +5066,7 @@ strength_reduce (struct loop *loop, int flags)\n   addr_placeholder = gen_reg_rtx (Pmode);\n \n   ivs->n_regs = max_reg_before_loop;\n-  ivs->regs = (struct iv *) xcalloc (ivs->n_regs, sizeof (struct iv));\n+  ivs->regs = xcalloc (ivs->n_regs, sizeof (struct iv));\n \n   /* Find all BIVs in loop.  */\n   loop_bivs_find (loop);\n@@ -5122,7 +5120,7 @@ strength_reduce (struct loop *loop, int flags)\n      Some givs might have been made from biv increments, so look at\n      ivs->reg_iv_type for a suitable size.  */\n   reg_map_size = ivs->n_regs;\n-  reg_map = (rtx *) xcalloc (reg_map_size, sizeof (rtx));\n+  reg_map = xcalloc (reg_map_size, sizeof (rtx));\n \n   /* Examine each iv class for feasibility of strength reduction/induction\n      variable elimination.  */\n@@ -5385,8 +5383,7 @@ check_insn_for_bivs (struct loop *loop, rtx p, int not_every_iteration,\n \t      /* It is a possible basic induction variable.\n \t         Create and initialize an induction structure for it.  */\n \n-\t      struct induction *v\n-\t\t= (struct induction *) xmalloc (sizeof (struct induction));\n+\t      struct induction *v = xmalloc (sizeof (struct induction));\n \n \t      record_biv (loop, v, p, dest_reg, inc_val, mult_val, location,\n \t\t\t  not_every_iteration, maybe_multiple);\n@@ -5449,8 +5446,7 @@ check_insn_for_givs (struct loop *loop, rtx p, int not_every_iteration,\n \t\t\t\t\t     &add_val, &mult_val, &ext_val,\n \t\t\t\t\t     &last_consec_insn))))\n \t{\n-\t  struct induction *v\n-\t    = (struct induction *) xmalloc (sizeof (struct induction));\n+\t  struct induction *v = xmalloc (sizeof (struct induction));\n \n \t  /* If this is a library call, increase benefit.  */\n \t  if (find_reg_note (p, REG_RETVAL, NULL_RTX))\n@@ -5567,8 +5563,7 @@ find_mem_givs (const struct loop *loop, rtx x, rtx insn,\n \t\t\t\t   GET_MODE (x)))\n \t  {\n \t    /* Found one; record it.  */\n-\t    struct induction *v\n-\t      = (struct induction *) xmalloc (sizeof (struct induction));\n+\t    struct induction *v = xmalloc (sizeof (struct induction));\n \n \t    record_giv (loop, v, insn, src_reg, addr_placeholder, mult_val,\n \t\t\tadd_val, ext_val, benefit, DEST_ADDR,\n@@ -5641,7 +5636,7 @@ record_biv (struct loop *loop, struct induction *v, rtx insn, rtx dest_reg,\n     {\n       /* Create and initialize new iv_class.  */\n \n-      bl = (struct iv_class *) xmalloc (sizeof (struct iv_class));\n+      bl = xmalloc (sizeof (struct iv_class));\n \n       bl->regno = REGNO (dest_reg);\n       bl->biv = 0;\n@@ -7008,7 +7003,7 @@ consec_sets_giv (const struct loop *loop, int first_benefit, rtx p,\n   if (REG_IV_TYPE (ivs, REGNO (dest_reg)) != UNKNOWN_INDUCT)\n     return 0;\n \n-  v = (struct induction *) alloca (sizeof (struct induction));\n+  v = alloca (sizeof (struct induction));\n   v->src_reg = src_reg;\n   v->mult_val = *mult_val;\n   v->add_val = *add_val;\n@@ -7564,15 +7559,14 @@ combine_givs (struct loop_regs *regs, struct iv_class *bl)\n     if (!g1->ignore)\n       giv_count++;\n \n-  giv_array\n-    = (struct induction **) alloca (giv_count * sizeof (struct induction *));\n+  giv_array = alloca (giv_count * sizeof (struct induction *));\n   i = 0;\n   for (g1 = bl->giv; g1; g1 = g1->next_iv)\n     if (!g1->ignore)\n       giv_array[i++] = g1;\n \n-  stats = (struct combine_givs_stats *) xcalloc (giv_count, sizeof (*stats));\n-  can_combine = (rtx *) xcalloc (giv_count, giv_count * sizeof (rtx));\n+  stats = xcalloc (giv_count, sizeof (*stats));\n+  can_combine = xcalloc (giv_count, giv_count * sizeof (rtx));\n \n   for (i = 0; i < giv_count; i++)\n     {\n@@ -9520,9 +9514,8 @@ insert_loop_mem (rtx *mem, void *data ATTRIBUTE_UNUSED)\n       else\n \tloop_info->mems_allocated = 32;\n \n-      loop_info->mems = (loop_mem_info *)\n-\txrealloc (loop_info->mems,\n-\t\t  loop_info->mems_allocated * sizeof (loop_mem_info));\n+      loop_info->mems = xrealloc (loop_info->mems,\n+\t\t\t\t  loop_info->mems_allocated * sizeof (loop_mem_info));\n     }\n \n   /* Actually insert the MEM.  */\n@@ -9573,8 +9566,7 @@ loop_regs_scan (const struct loop *loop, int extra_size)\n     {\n       regs->size = regs->num + extra_size;\n \n-      regs->array = (struct loop_reg *)\n-\txrealloc (regs->array, regs->size * sizeof (*regs->array));\n+      regs->array = xrealloc (regs->array, regs->size * sizeof (*regs->array));\n \n       /* Zero the new elements.  */\n       memset (regs->array + old_nregs, 0,\n@@ -9589,7 +9581,7 @@ loop_regs_scan (const struct loop *loop, int extra_size)\n       regs->array[i].single_usage = NULL_RTX;\n     }\n \n-  last_set = (rtx *) xcalloc (regs->num, sizeof (rtx));\n+  last_set = xcalloc (regs->num, sizeof (rtx));\n \n   /* Scan the loop, recording register usage.  */\n   for (insn = loop->top ? loop->top : loop->start; insn != loop->end;"}, {"sha": "e25c175ef54dd9444e67ab0b99f90aebf8c56e8d", "filename": "gcc/mips-tdump.c", "status": "modified", "additions": 31, "deletions": 57, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fmips-tdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fmips-tdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tdump.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -884,7 +884,7 @@ print_symbol (SYMR *sym_ptr, int number, const char *strbase, AUXU *aux_base,\n \tif (want_scope)\n \t  {\n \t    if (free_scope == (scope_t *) 0)\n-\t      scope_ptr = (scope_t *) xmalloc (sizeof (scope_t));\n+\t      scope_ptr = xmalloc (sizeof (scope_t));\n \t    else\n \t      {\n \t\tscope_ptr = free_scope;\n@@ -938,7 +938,7 @@ print_symbol (SYMR *sym_ptr, int number, const char *strbase, AUXU *aux_base,\n \tif (want_scope)\n \t  {\n \t    if (free_scope == (scope_t *) 0)\n-\t      scope_ptr = (scope_t *) xmalloc (sizeof (scope_t));\n+\t      scope_ptr = xmalloc (sizeof (scope_t));\n \t    else\n \t      {\n \t\tscope_ptr = free_scope;\n@@ -1324,13 +1324,12 @@ read_tfile (void)\n   short magic;\n   off_t sym_hdr_offset = 0;\n \n-  (void) read_seek (&magic, sizeof (magic), (off_t) 0, \"Magic number\");\n+  read_seek (&magic, sizeof (magic), 0, \"Magic number\");\n   if (!tfile)\n     {\n       /* Print out the global header, since this is not a T-file.  */\n \n-      (void) read_seek (&global_hdr, sizeof (global_hdr), (off_t) 0,\n-\t\t\t\"Global file header\");\n+      read_seek (&global_hdr, sizeof (global_hdr), 0, \"Global file header\");\n \n       print_global_hdr (&global_hdr);\n \n@@ -1343,70 +1342,45 @@ read_tfile (void)\n       sym_hdr_offset = global_hdr.f_symptr;\n     }\n \n-  (void) read_seek (&sym_hdr,\n-\t\t    sizeof (sym_hdr),\n-\t\t    sym_hdr_offset,\n-\t\t    \"Symbolic header\");\n+  read_seek (&sym_hdr, sizeof (sym_hdr), sym_hdr_offset, \"Symbolic header\");\n \n   print_sym_hdr (&sym_hdr);\n \n-  lines = (LINER *) read_seek (NULL,\n-\t\t\t       sym_hdr.cbLine,\n-\t\t\t       sym_hdr.cbLineOffset,\n-\t\t\t       \"Line numbers\");\n+  lines = read_seek (NULL, sym_hdr.cbLine, sym_hdr.cbLineOffset,\n+\t\t     \"Line numbers\");\n \n-  dense_nums = (DNR *) read_seek (NULL,\n-\t\t\t\t  sym_hdr.idnMax * sizeof (DNR),\n-\t\t\t\t  sym_hdr.cbDnOffset,\n-\t\t\t\t  \"Dense numbers\");\n+  dense_nums = read_seek (NULL, sym_hdr.idnMax * sizeof (DNR),\n+\t\t\t  sym_hdr.cbDnOffset, \"Dense numbers\");\n \n-  proc_desc = (PDR *) read_seek (NULL,\n-\t\t\t\t sym_hdr.ipdMax * sizeof (PDR),\n-\t\t\t\t sym_hdr.cbPdOffset,\n-\t\t\t\t \"Procedure tables\");\n+  proc_desc = read_seek (NULL, sym_hdr.ipdMax * sizeof (PDR),\n+\t\t\t sym_hdr.cbPdOffset, \"Procedure tables\");\n \n-  l_symbols = (SYMR *) read_seek (NULL,\n-\t\t\t\t  sym_hdr.isymMax * sizeof (SYMR),\n-\t\t\t\t  sym_hdr.cbSymOffset,\n-\t\t\t\t  \"Local symbols\");\n+  l_symbols = read_seek (NULL, sym_hdr.isymMax * sizeof (SYMR),\n+\t\t\t sym_hdr.cbSymOffset, \"Local symbols\");\n \n-  opt_symbols = (OPTR *) read_seek (NULL,\n-\t\t\t\t    sym_hdr.ioptMax * sizeof (OPTR),\n-\t\t\t\t    sym_hdr.cbOptOffset,\n-\t\t\t\t    \"Optimization symbols\");\n+  opt_symbols = read_seek (NULL, sym_hdr.ioptMax * sizeof (OPTR),\n+\t\t\t   sym_hdr.cbOptOffset, \"Optimization symbols\");\n \n-  aux_symbols = (AUXU *) read_seek (NULL,\n-\t\t\t\t    sym_hdr.iauxMax * sizeof (AUXU),\n-\t\t\t\t    sym_hdr.cbAuxOffset,\n-\t\t\t\t    \"Auxiliary symbols\");\n+  aux_symbols = read_seek (NULL, sym_hdr.iauxMax * sizeof (AUXU),\n+\t\t\t   sym_hdr.cbAuxOffset, \"Auxiliary symbols\");\n \n   if (sym_hdr.iauxMax > 0)\n     aux_used = xcalloc (sym_hdr.iauxMax, 1);\n \n-  l_strings = (char *) read_seek (NULL,\n-\t\t\t\t  sym_hdr.issMax,\n-\t\t\t\t  sym_hdr.cbSsOffset,\n-\t\t\t\t  \"Local string table\");\n-\n-  e_strings = (char *) read_seek (NULL,\n-\t\t\t\t  sym_hdr.issExtMax,\n-\t\t\t\t  sym_hdr.cbSsExtOffset,\n-\t\t\t\t  \"External string table\");\n-\n-  file_desc = (FDR *) read_seek (NULL,\n-\t\t\t\t sym_hdr.ifdMax * sizeof (FDR),\n-\t\t\t\t sym_hdr.cbFdOffset,\n-\t\t\t\t \"File tables\");\n-\n-  rfile_desc = (ulong *) read_seek (NULL,\n-\t\t\t\t    sym_hdr.crfd * sizeof (ulong),\n-\t\t\t\t    sym_hdr.cbRfdOffset,\n-\t\t\t\t    \"Relative file tables\");\n-\n-  e_symbols = (EXTR *) read_seek (NULL,\n-\t\t\t\t  sym_hdr.iextMax * sizeof (EXTR),\n-\t\t\t\t  sym_hdr.cbExtOffset,\n-\t\t\t\t  \"External symbols\");\n+  l_strings = read_seek (NULL, sym_hdr.issMax,\n+\t\t\t sym_hdr.cbSsOffset, \"Local string table\");\n+\n+  e_strings = read_seek (NULL, sym_hdr.issExtMax,\n+\t\t\t sym_hdr.cbSsExtOffset, \"External string table\");\n+\n+  file_desc = read_seek (NULL, sym_hdr.ifdMax * sizeof (FDR),\n+\t\t\t sym_hdr.cbFdOffset, \"File tables\");\n+\n+  rfile_desc = read_seek (NULL, sym_hdr.crfd * sizeof (ulong),\n+\t\t\t  sym_hdr.cbRfdOffset, \"Relative file tables\");\n+\n+  e_symbols = read_seek (NULL, sym_hdr.iextMax * sizeof (EXTR),\n+\t\t\t sym_hdr.cbExtOffset, \"External symbols\");\n }\n \n \f"}, {"sha": "4a284611f78ee61efb934b619b1d0da45a938911", "filename": "gcc/mips-tfile.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fmips-tfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fmips-tfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tfile.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -1637,7 +1637,7 @@ add_varray_page (varray_t *vp)\n \n #ifdef MALLOC_CHECK\n   if (vp->object_size > 1)\n-    new_links->datum = (page_t *) xcalloc (1, vp->object_size);\n+    new_links->datum = xcalloc (1, vp->object_size);\n   else\n #endif\n     new_links->datum = allocate_page ();\n@@ -2353,7 +2353,7 @@ add_procedure (const char *func_start,  /* 1st byte of func name */\n STATIC void\n initialize_init_file (void)\n {\n-  memset ((void*) &init_file, 0, sizeof (init_file));\n+  memset (&init_file, 0, sizeof (init_file));\n \n   init_file.fdr.lang = langC;\n   init_file.fdr.fMerge = 1;\n@@ -4257,7 +4257,7 @@ read_seek (Size_t size,\t\t/* # bytes to read */\n #ifndef MALLOC_CHECK\n   ptr = allocate_multiple_pages ((size + PAGE_USIZE - 1) / PAGE_USIZE);\n #else\n-  ptr = (page_t *) xcalloc (1, size);\n+  ptr = xcalloc (1, size);\n #endif\n \n   /* If we need to seek, and the distance is nearby, just do some reads,\n@@ -4379,61 +4379,61 @@ copy_object (void)\n   file_offset =  orig_file_header.f_symptr + sizeof (struct filehdr);\n \n   if (orig_sym_hdr.cbLine > 0)\t\t\t/* line numbers */\n-    orig_linenum = (char *) read_seek ((Size_t) orig_sym_hdr.cbLine,\n+    orig_linenum = (char *) read_seek (orig_sym_hdr.cbLine,\n \t\t\t\t       orig_sym_hdr.cbLineOffset,\n \t\t\t\t       \"Line numbers\");\n \n   if (orig_sym_hdr.ipdMax > 0)\t\t\t/* procedure tables */\n-    orig_procs = (PDR *) read_seek ((Size_t) orig_sym_hdr.ipdMax * sizeof (PDR),\n+    orig_procs = (PDR *) read_seek (orig_sym_hdr.ipdMax * sizeof (PDR),\n \t\t\t\t    orig_sym_hdr.cbPdOffset,\n \t\t\t\t    \"Procedure tables\");\n \n   if (orig_sym_hdr.isymMax > 0)\t\t\t/* local symbols */\n-    orig_local_syms = (SYMR *) read_seek ((Size_t) orig_sym_hdr.isymMax * sizeof (SYMR),\n+    orig_local_syms = (SYMR *) read_seek (orig_sym_hdr.isymMax * sizeof (SYMR),\n \t\t\t\t\t  orig_sym_hdr.cbSymOffset,\n \t\t\t\t\t  \"Local symbols\");\n \n   if (orig_sym_hdr.iauxMax > 0)\t\t\t/* aux symbols */\n-    orig_aux_syms = (AUXU *) read_seek ((Size_t) orig_sym_hdr.iauxMax * sizeof (AUXU),\n+    orig_aux_syms = (AUXU *) read_seek (orig_sym_hdr.iauxMax * sizeof (AUXU),\n \t\t\t\t\torig_sym_hdr.cbAuxOffset,\n \t\t\t\t\t\"Aux. symbols\");\n \n   if (orig_sym_hdr.issMax > 0)\t\t\t/* local strings */\n-    orig_local_strs = (char *) read_seek ((Size_t) orig_sym_hdr.issMax,\n+    orig_local_strs = (char *) read_seek (orig_sym_hdr.issMax,\n \t\t\t\t\t  orig_sym_hdr.cbSsOffset,\n \t\t\t\t\t  \"Local strings\");\n \n   if (orig_sym_hdr.issExtMax > 0)\t\t/* external strings */\n-    orig_ext_strs = (char *) read_seek ((Size_t) orig_sym_hdr.issExtMax,\n+    orig_ext_strs = (char *) read_seek (orig_sym_hdr.issExtMax,\n \t\t\t\t\torig_sym_hdr.cbSsExtOffset,\n \t\t\t\t\t\"External strings\");\n \n   if (orig_sym_hdr.ifdMax > 0)\t\t\t/* file tables */\n-    orig_files = (FDR *) read_seek ((Size_t) orig_sym_hdr.ifdMax * sizeof (FDR),\n+    orig_files = (FDR *) read_seek (orig_sym_hdr.ifdMax * sizeof (FDR),\n \t\t\t\t    orig_sym_hdr.cbFdOffset,\n \t\t\t\t    \"File tables\");\n \n   if (orig_sym_hdr.crfd > 0)\t\t\t/* relative file descriptors */\n-    orig_rfds = (symint_t *) read_seek ((Size_t) orig_sym_hdr.crfd * sizeof (symint_t),\n+    orig_rfds = (symint_t *) read_seek (orig_sym_hdr.crfd * sizeof (symint_t),\n \t\t\t\t\torig_sym_hdr.cbRfdOffset,\n \t\t\t\t\t\"Relative file descriptors\");\n \n   if (orig_sym_hdr.issExtMax > 0)\t\t/* external symbols */\n-    orig_ext_syms = (EXTR *) read_seek ((Size_t) orig_sym_hdr.iextMax * sizeof (EXTR),\n+    orig_ext_syms = (EXTR *) read_seek (orig_sym_hdr.iextMax * sizeof (EXTR),\n \t\t\t\t\torig_sym_hdr.cbExtOffset,\n \t\t\t\t\t\"External symbols\");\n \n   if (orig_sym_hdr.idnMax > 0)\t\t\t/* dense numbers */\n     {\n-      orig_dense = (DNR *) read_seek ((Size_t) orig_sym_hdr.idnMax * sizeof (DNR),\n+      orig_dense = (DNR *) read_seek (orig_sym_hdr.idnMax * sizeof (DNR),\n \t\t\t\t      orig_sym_hdr.cbDnOffset,\n \t\t\t\t      \"Dense numbers\");\n \n-      add_bytes (&dense_num, (char *) orig_dense, (Size_t) orig_sym_hdr.idnMax);\n+      add_bytes (&dense_num, (char *) orig_dense, orig_sym_hdr.idnMax);\n     }\n \n   if (orig_sym_hdr.ioptMax > 0)\t\t\t/* opt symbols */\n-    orig_opt_syms = (OPTR *) read_seek ((Size_t) orig_sym_hdr.ioptMax * sizeof (OPTR),\n+    orig_opt_syms = (OPTR *) read_seek (orig_sym_hdr.ioptMax * sizeof (OPTR),\n \t\t\t\t\torig_sym_hdr.cbOptOffset,\n \t\t\t\t\t\"Optimizer symbols\");\n \n@@ -4464,7 +4464,7 @@ copy_object (void)\n      (in case there are duplicate filenames, we collapse them into one\n      file section, the MIPS assembler may or may not collapse them).  */\n \n-  remap_file_number = (int *) alloca (sizeof (int) * orig_sym_hdr.ifdMax);\n+  remap_file_number = alloca (sizeof (int) * orig_sym_hdr.ifdMax);\n \n   for (fd = delete_ifd; fd < orig_sym_hdr.ifdMax; fd++)\n     {\n@@ -4972,7 +4972,7 @@ out_of_bounds (symint_t indx,\t/* index that is out of bounds */\n STATIC page_t *\n allocate_cluster (Size_t npages)\n {\n-  page_t *value = (page_t *) xcalloc (npages, PAGE_USIZE);\n+  page_t *value = xcalloc (npages, PAGE_USIZE);\n \n   if (debug > 3)\n     fprintf (stderr, \"\\talloc\\tnpages = %d, value = 0x%.8x\\n\", npages, value);\n@@ -5038,7 +5038,7 @@ allocate_multiple_pages (Size_t npages)\n   return allocate_cluster (npages);\n \n #else\t/* MALLOC_CHECK */\n-  return (page_t *) xcalloc (npages, PAGE_SIZE);\n+  return xcalloc (npages, PAGE_SIZE);\n \n #endif\t/* MALLOC_CHECK */\n }\n@@ -5089,7 +5089,7 @@ allocate_page (void)\n   return cluster_ptr++;\n \n #else\t/* MALLOC_CHECK */\n-  return (page_t *) xcalloc (1, PAGE_SIZE);\n+  return xcalloc (1, PAGE_SIZE);\n \n #endif\t/* MALLOC_CHECK */\n }\n@@ -5125,7 +5125,7 @@ allocate_scope (void)\n     }\n \n #else\n-  ptr = (scope_t *) xmalloc (sizeof (scope_t));\n+  ptr = xmalloc (sizeof (scope_t));\n \n #endif\n \n@@ -5175,7 +5175,7 @@ allocate_vlinks (void)\n   alloc_counts[ (int) alloc_type_vlinks ].unallocated = unallocated;\n \n #else\n-  ptr = (vlinks_t *) xmalloc (sizeof (vlinks_t));\n+  ptr = xmalloc (sizeof (vlinks_t));\n \n #endif\n \n@@ -5208,7 +5208,7 @@ allocate_shash (void)\n   alloc_counts[ (int) alloc_type_shash ].unallocated = unallocated;\n \n #else\n-  ptr = (shash_t *) xmalloc (sizeof (shash_t));\n+  ptr = xmalloc (sizeof (shash_t));\n \n #endif\n \n@@ -5241,7 +5241,7 @@ allocate_thash (void)\n   alloc_counts[ (int) alloc_type_thash ].unallocated = unallocated;\n \n #else\n-  ptr = (thash_t *) xmalloc (sizeof (thash_t));\n+  ptr = xmalloc (sizeof (thash_t));\n \n #endif\n \n@@ -5281,7 +5281,7 @@ allocate_tag (void)\n     }\n \n #else\n-  ptr = (tag_t *) xmalloc (sizeof (tag_t));\n+  ptr = xmalloc (sizeof (tag_t));\n \n #endif\n \n@@ -5338,7 +5338,7 @@ allocate_forward (void)\n     }\n \n #else\n-  ptr = (forward_t *) xmalloc (sizeof (forward_t));\n+  ptr = xmalloc (sizeof (forward_t));\n \n #endif\n \n@@ -5395,7 +5395,7 @@ allocate_thead (void)\n     }\n \n #else\n-  ptr = (thead_t *) xmalloc (sizeof (thead_t));\n+  ptr = xmalloc (sizeof (thead_t));\n \n #endif\n "}, {"sha": "23af9d83f7805d3e96037b9c3b9507966428b633", "filename": "gcc/mkdeps.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fmkdeps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fmkdeps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmkdeps.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -110,7 +110,7 @@ munge (const char *filename)\n struct deps *\n deps_init (void)\n {\n-  struct deps *d = (struct deps *) xmalloc (sizeof (struct deps));\n+  struct deps *d = xmalloc (sizeof (struct deps));\n \n   /* Allocate space for the vectors only if we need it.  */\n \n@@ -155,7 +155,7 @@ deps_add_target (struct deps *d, const char *t, int quote)\n   if (d->ntargets == d->targets_size)\n     {\n       d->targets_size = d->targets_size * 2 + 4;\n-      d->targetv = (const char **) xrealloc (d->targetv,\n+      d->targetv = xrealloc (d->targetv,\n \t\t\t     d->targets_size * sizeof (const char *));\n     }\n \n@@ -185,7 +185,7 @@ deps_add_default_target (struct deps *d, const char *tgt)\n # define TARGET_OBJECT_SUFFIX \".o\"\n #endif\n       const char *start = lbasename (tgt);\n-      char *o = (char *) alloca (strlen (start) + strlen (TARGET_OBJECT_SUFFIX) + 1);\n+      char *o = alloca (strlen (start) + strlen (TARGET_OBJECT_SUFFIX) + 1);\n       char *suffix;\n \n       strcpy (o, start);\n@@ -207,8 +207,7 @@ deps_add_dep (struct deps *d, const char *t)\n   if (d->ndeps == d->deps_size)\n     {\n       d->deps_size = d->deps_size * 2 + 8;\n-      d->depv = (const char **)\n-\txrealloc (d->depv, d->deps_size * sizeof (const char *));\n+      d->depv = xrealloc (d->depv, d->deps_size * sizeof (const char *));\n     }\n   d->depv[d->ndeps++] = t;\n }\n@@ -315,7 +314,7 @@ deps_restore (struct deps *deps, FILE *fd, const char *self)\n   unsigned int i, count;\n   size_t num_to_read;\n   size_t buf_size = 512;\n-  char *buf = (char *) xmalloc (buf_size);\n+  char *buf = xmalloc (buf_size);\n \n   /* Number of dependences.  */\n   if (fread (&count, 1, sizeof (count), fd) != sizeof (count))"}, {"sha": "9e4ba2b06a21b39119c41f89f155c22fe4ac53cd", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -5201,7 +5201,7 @@ static optab\n new_optab (void)\n {\n   int i;\n-  optab op = (optab) ggc_alloc (sizeof (struct optab));\n+  optab op = ggc_alloc (sizeof (struct optab));\n   for (i = 0; i < NUM_MACHINE_MODES; i++)\n     {\n       op->handlers[i].insn_code = CODE_FOR_nothing;"}, {"sha": "e109d3adb3fe863517346b35af1798325f42bbea", "filename": "gcc/params.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fparams.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fparams.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -43,10 +43,8 @@ void\n add_params (const param_info params[], size_t n)\n {\n   /* Allocate enough space for the new parameters.  */\n-  compiler_params =\n-    ((param_info *)\n-     xrealloc (compiler_params,\n-\t       (num_compiler_params + n) * sizeof (param_info)));\n+  compiler_params = xrealloc (compiler_params,\n+\t\t\t      (num_compiler_params + n) * sizeof (param_info));\n   /* Copy them into the table.  */\n   memcpy (compiler_params + num_compiler_params,\n \t  params,"}, {"sha": "2875dbdffd0e51afea7fd4c1d333dc7b4fee35c2", "filename": "gcc/postreload.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -377,11 +377,11 @@ reload_cse_simplify_operands (rtx insn, rtx testreg)\n   if (! constrain_operands (1))\n     fatal_insn_not_found (insn);\n \n-  alternative_reject = (int *) alloca (recog_data.n_alternatives * sizeof (int));\n-  alternative_nregs = (int *) alloca (recog_data.n_alternatives * sizeof (int));\n-  alternative_order = (int *) alloca (recog_data.n_alternatives * sizeof (int));\n-  memset ((char *) alternative_reject, 0, recog_data.n_alternatives * sizeof (int));\n-  memset ((char *) alternative_nregs, 0, recog_data.n_alternatives * sizeof (int));\n+  alternative_reject = alloca (recog_data.n_alternatives * sizeof (int));\n+  alternative_nregs = alloca (recog_data.n_alternatives * sizeof (int));\n+  alternative_order = alloca (recog_data.n_alternatives * sizeof (int));\n+  memset (alternative_reject, 0, recog_data.n_alternatives * sizeof (int));\n+  memset (alternative_nregs, 0, recog_data.n_alternatives * sizeof (int));\n \n   /* For each operand, find out which regs are equivalent.  */\n   for (i = 0; i < recog_data.n_operands; i++)\n@@ -414,7 +414,7 @@ reload_cse_simplify_operands (rtx insn, rtx testreg)\n       int regno;\n       const char *p;\n \n-      op_alt_regno[i] = (int *) alloca (recog_data.n_alternatives * sizeof (int));\n+      op_alt_regno[i] = alloca (recog_data.n_alternatives * sizeof (int));\n       for (j = 0; j < recog_data.n_alternatives; j++)\n \top_alt_regno[i][j] = -1;\n \n@@ -659,7 +659,7 @@ reload_combine (void)\n      destination.  */\n   min_labelno = get_first_label_num ();\n   n_labels = max_label_num () - min_labelno;\n-  label_live = (HARD_REG_SET *) xmalloc (n_labels * sizeof (HARD_REG_SET));\n+  label_live = xmalloc (n_labels * sizeof (HARD_REG_SET));\n   CLEAR_HARD_REG_SET (ever_live_at_start);\n \n   FOR_EACH_BB_REVERSE (bb)"}, {"sha": "df556aaa30c0f9ab4bedf648ffc91259884a954c", "filename": "gcc/prefix.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fprefix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fprefix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprefix.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -155,12 +155,12 @@ lookup_key (char *key)\n     }\n \n   size = 32;\n-  dst = (char *) xmalloc (size);\n+  dst = xmalloc (size);\n \n   res = RegQueryValueExA (reg_key, key, 0, &type, dst, &size);\n   if (res == ERROR_MORE_DATA && type == REG_SZ)\n     {\n-      dst = (char *) xrealloc (dst, size);\n+      dst = xrealloc (dst, size);\n       res = RegQueryValueExA (reg_key, key, 0, &type, dst, &size);\n     }\n \n@@ -197,7 +197,7 @@ translate_name (char *name)\n \t   keylen++)\n \t;\n \n-      key = (char *) alloca (keylen + 1);\n+      key = alloca (keylen + 1);\n       strncpy (key, &name[1], keylen);\n       key[keylen] = 0;\n "}, {"sha": "651fb094f23d103df11d77b4b9abe741ee294055", "filename": "gcc/print-tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -49,7 +49,7 @@ static struct bucket **table;\n void\n debug_tree (tree node)\n {\n-  table = (struct bucket **) xcalloc (HASH_SIZE, sizeof (struct bucket *));\n+  table = xcalloc (HASH_SIZE, sizeof (struct bucket *));\n   print_node (stderr, \"\", node, 0);\n   free (table);\n   table = 0;\n@@ -200,7 +200,7 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n       }\n \n   /* Add this node to the table.  */\n-  b = (struct bucket *) xmalloc (sizeof (struct bucket));\n+  b = xmalloc (sizeof (struct bucket));\n   b->node = node;\n   b->next = table[hash];\n   table[hash] = b;"}, {"sha": "58be683b9d86eb6b77f94386cc554d82870c9bd2", "filename": "gcc/protoize.c", "status": "modified", "additions": 37, "deletions": 42, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fprotoize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fprotoize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprotoize.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -521,7 +521,7 @@ notice (const char *msgid, ...)\n static char *\n savestring (const char *input, unsigned int size)\n {\n-  char *output = (char *) xmalloc (size + 1);\n+  char *output = xmalloc (size + 1);\n   strcpy (output, input);\n   return output;\n }\n@@ -542,7 +542,7 @@ fancy_abort (void)\n static char *\n dupnstr (const char *s, size_t n)\n {\n-  char *ret_val = (char *) xmalloc (n + 1);\n+  char *ret_val = xmalloc (n + 1);\n \n   strncpy (ret_val, s, n);\n   ret_val[n] = '\\0';\n@@ -692,7 +692,7 @@ in_system_include_dir (const char *path)\n static int\n file_could_be_converted (const char *path)\n {\n-  char *const dir_name = (char *) alloca (strlen (path) + 1);\n+  char *const dir_name = alloca (strlen (path) + 1);\n \n   if (access (path, R_OK))\n     return 0;\n@@ -898,8 +898,7 @@ file_excluded_p (const char *name)\n static struct string_list *\n string_list_cons (const char *string, struct string_list *rest)\n {\n-  struct string_list *temp\n-    = (struct string_list *) xmalloc (sizeof (struct string_list));\n+  struct string_list *temp = xmalloc (sizeof (struct string_list));\n \n   temp->next = rest;\n   temp->name = string;\n@@ -973,7 +972,7 @@ lookup (hash_table_entry *hash_tab_p, const char *search_symbol)\n       if (!strcmp (p->symbol, search_symbol))\n \treturn p;\n     }\n-  p->hash_next = (hash_table_entry *) xmalloc (sizeof (hash_table_entry));\n+  p->hash_next = xmalloc (sizeof (hash_table_entry));\n   p = p->hash_next;\n   return add_symbol (p, search_symbol);\n }\n@@ -1022,7 +1021,7 @@ unexpand_if_needed (const char *aux_info_line)\n   if (line_buf == 0)\n     {\n       line_buf_size = 1024;\n-      line_buf = (char *) xmalloc (line_buf_size);\n+      line_buf = xmalloc (line_buf_size);\n     }\n \n   copy_p = line_buf;\n@@ -1045,7 +1044,7 @@ unexpand_if_needed (const char *aux_info_line)\n \t\t  int offset = copy_p - line_buf;\n \t\t  line_buf_size *= 2;\n \t\t  line_buf_size += size;\n-\t\t  line_buf = (char *) xrealloc (line_buf, line_buf_size);\n+\t\t  line_buf = xrealloc (line_buf, line_buf_size);\n \t\t  copy_p = line_buf + offset;\n \t\t}\n \t      strcpy (copy_p, unexp_p->contracted);\n@@ -1062,7 +1061,7 @@ unexpand_if_needed (const char *aux_info_line)\n \t{\n \t  int offset = copy_p - line_buf;\n \t  line_buf_size *= 2;\n-\t  line_buf = (char *) xrealloc (line_buf, line_buf_size);\n+\t  line_buf = xrealloc (line_buf, line_buf_size);\n \t  copy_p = line_buf + offset;\n \t}\n       *copy_p++ = *s++;\n@@ -1072,7 +1071,7 @@ continue_outer: ;\n     {\n       int offset = copy_p - line_buf;\n       line_buf_size *= 2;\n-      line_buf = (char *) xrealloc (line_buf, line_buf_size);\n+      line_buf = xrealloc (line_buf, line_buf_size);\n       copy_p = line_buf + offset;\n     }\n   *copy_p++ = '\\n';\n@@ -1096,8 +1095,7 @@ abspath (const char *cwd, const char *rel_filename)\n {\n   /* Setup the current working directory as needed.  */\n   const char *const cwd2 = (cwd) ? cwd : cwd_buffer;\n-  char *const abs_buffer\n-    = (char *) alloca (strlen (cwd2) + strlen (rel_filename) + 2);\n+  char *const abs_buffer = alloca (strlen (cwd2) + strlen (rel_filename) + 2);\n   char *endp = abs_buffer;\n   char *outp, *inp;\n \n@@ -1219,7 +1217,7 @@ shortpath (const char *cwd, const char *filename)\n   size_t filename_len = strlen (filename);\n \n   path_p = abspath (cwd, filename);\n-  rel_buf_p = rel_buffer = (char *) xmalloc (filename_len);\n+  rel_buf_p = rel_buffer = xmalloc (filename_len);\n \n   while (*cwd_p && IS_SAME_PATH_CHAR (*cwd_p, *path_p))\n     {\n@@ -1306,7 +1304,7 @@ find_file (const char *filename, int do_not_stat)\n   else\n     {\n       struct stat stat_buf;\n-      file_info *file_p = (file_info *) xmalloc (sizeof (file_info));\n+      file_info *file_p = xmalloc (sizeof (file_info));\n \n       /* If we cannot get status on any given source file, give a warning\n \t and then just set its time of last modification to infinity.  */\n@@ -1404,7 +1402,7 @@ referenced_file_is_newer (const char *l, time_t aux_info_mtime)\n #endif\n \t   )\n       p++;\n-    filename = (char *) alloca ((size_t) (p - filename_start) + 1);\n+    filename = alloca ((size_t) (p - filename_start) + 1);\n     strncpy (filename, filename_start, (size_t) (p - filename_start));\n     filename[p-filename_start] = '\\0';\n   }\n@@ -1439,7 +1437,7 @@ save_def_or_dec (const char *l, int is_syscalls)\n {\n   const char *p;\n   const char *semicolon_p;\n-  def_dec_info *def_dec_p = (def_dec_info *) xmalloc (sizeof (def_dec_info));\n+  def_dec_info *def_dec_p = xmalloc (sizeof (def_dec_info));\n \n #ifndef UNPROTOIZE\n   def_dec_p->written = 0;\n@@ -1464,7 +1462,7 @@ save_def_or_dec (const char *l, int is_syscalls)\n #endif\n \t   )\n       p++;\n-    filename = (char *) alloca ((size_t) (p - filename_start) + 1);\n+    filename = alloca ((size_t) (p - filename_start) + 1);\n     strncpy (filename, filename_start, (size_t) (p - filename_start));\n     filename[p-filename_start] = '\\0';\n \n@@ -1594,8 +1592,7 @@ save_def_or_dec (const char *l, int is_syscalls)\n       const char *left_paren_p = find_corresponding_lparen (p);\n #ifndef UNPROTOIZE\n       {\n-\tf_list_chain_item *cip\n-\t  = (f_list_chain_item *) xmalloc (sizeof (f_list_chain_item));\n+\tf_list_chain_item *cip = xmalloc (sizeof (f_list_chain_item));\n \n \tcip->formals_list\n \t  = dupnstr (left_paren_p + 1, (size_t) (p - (left_paren_p+1)));\n@@ -1637,7 +1634,7 @@ save_def_or_dec (const char *l, int is_syscalls)\n     /* p now points to the leftmost character of the function name.  */\n \n     {\n-      char *fn_string = (char *) alloca (past_fn - p + 1);\n+      char *fn_string = alloca (past_fn - p + 1);\n \n       strncpy (fn_string, p, (size_t) (past_fn - p));\n       fn_string[past_fn-p] = '\\0';\n@@ -1833,7 +1830,7 @@ munge_compile_params (const char *params_list)\n   /* Build up the contents in a temporary vector\n      that is so big that to has to be big enough.  */\n   const char **temp_params\n-    = (const char **) alloca ((strlen (params_list) + 8) * sizeof (char *));\n+    = alloca ((strlen (params_list) + 8) * sizeof (char *));\n   int param_count = 0;\n   const char *param;\n   struct stat st;\n@@ -1902,8 +1899,7 @@ munge_compile_params (const char *params_list)\n \n   /* Make a copy of the compile_params in heap space.  */\n \n-  compile_params\n-    = (const char **) xmalloc (sizeof (char *) * (param_count+1));\n+  compile_params = xmalloc (sizeof (char *) * (param_count+1));\n   memcpy (compile_params, temp_params, sizeof (char *) * param_count);\n }\n \n@@ -1979,8 +1975,7 @@ process_aux_info_file (const char *base_source_filename, int keep_it,\n \t\t       int is_syscalls)\n {\n   size_t base_len = strlen (base_source_filename);\n-  char * aux_info_filename\n-    = (char *) alloca (base_len + strlen (aux_info_suffix) + 1);\n+  char * aux_info_filename = alloca (base_len + strlen (aux_info_suffix) + 1);\n   char *aux_info_base;\n   char *aux_info_limit;\n   char *aux_info_relocated_name;\n@@ -2309,8 +2304,8 @@ rename_c_file (const hash_table_entry *hp)\n {\n   const char *filename = hp->symbol;\n   int last_char_index = strlen (filename) - 1;\n-  char *const new_filename = (char *) alloca (strlen (filename)\n-\t                                      + strlen (cplus_suffix) + 1);\n+  char *const new_filename = alloca (strlen (filename)\n+\t\t\t\t     + strlen (cplus_suffix) + 1);\n \n   /* Note that we don't care here if the given file was converted or not.  It\n      is possible that the given file was *not* converted, simply because there\n@@ -2517,7 +2512,7 @@ find_extern_def (const def_dec_info *head, const def_dec_info *user)\n \t      {\n \t\t/* Why copy this string into `needed' at all?\n \t\t   Why not just use user->ansi_decl without copying?  */\n-\t\tchar *needed = (char *) alloca (strlen (user->ansi_decl) + 1);\n+\t\tchar *needed = alloca (strlen (user->ansi_decl) + 1);\n \t        char *p;\n \n \t        strcpy (needed, user->ansi_decl);\n@@ -2815,7 +2810,7 @@ output_bytes (const char *str, size_t len)\n   if ((repl_write_ptr + 1) + len >= repl_text_limit)\n     {\n       size_t new_size = (repl_text_limit - repl_text_base) << 1;\n-      char *new_buf = (char *) xrealloc (repl_text_base, new_size);\n+      char *new_buf = xrealloc (repl_text_base, new_size);\n \n       repl_write_ptr = new_buf + (repl_write_ptr - repl_text_base);\n       repl_text_base = new_buf;\n@@ -3887,7 +3882,7 @@ scan_for_missed_items (const file_info *file_p)\n \t\t    goto not_missed;\n \n \t\t  {\n-\t\t    char *func_name = (char *) alloca (id_length + 1);\n+\t\t    char *func_name = alloca (id_length + 1);\n \t\t    static const char * const stmt_keywords[]\n \t\t      = { \"if\", \"else\", \"do\", \"while\", \"for\", \"switch\", \"case\", \"return\", 0 };\n \t\t    const char * const *stmt_keyword;\n@@ -4010,12 +4005,12 @@ edit_file (const hash_table_entry *hp)\n \n   /* Allocate a buffer to hold the original text.  */\n \n-  orig_text_base = new_orig_text_base = (char *) xmalloc (orig_size + 2);\n+  orig_text_base = new_orig_text_base = xmalloc (orig_size + 2);\n   orig_text_limit = new_orig_text_limit = new_orig_text_base + orig_size;\n \n   /* Allocate a buffer to hold the cleaned-up version of the original text.  */\n \n-  clean_text_base = new_clean_text_base = (char *) xmalloc (orig_size + 2);\n+  clean_text_base = new_clean_text_base = xmalloc (orig_size + 2);\n   clean_text_limit = new_clean_text_limit = new_clean_text_base + orig_size;\n   clean_read_ptr = clean_text_base - 1;\n \n@@ -4025,7 +4020,7 @@ edit_file (const hash_table_entry *hp)\n      buffer can be expanded later as needed.  */\n \n   repl_size = orig_size + (orig_size >> 2) + 4096;\n-  repl_text_base = (char *) xmalloc (repl_size + 2);\n+  repl_text_base = xmalloc (repl_size + 2);\n   repl_text_limit = repl_text_base + repl_size - 1;\n   repl_write_ptr = repl_text_base - 1;\n \n@@ -4083,7 +4078,7 @@ edit_file (const hash_table_entry *hp)\n   {\n     int clean_file;\n     size_t clean_size = orig_text_limit - orig_text_base;\n-    char *const clean_filename = (char *) alloca (strlen (convert_filename) + 6 + 1);\n+    char *const clean_filename = alloca (strlen (convert_filename) + 6 + 1);\n \n     /* Open (and create) the clean file.  */\n \n@@ -4183,7 +4178,7 @@ edit_file (const hash_table_entry *hp)\n   if (!nosave_flag)\n     {\n       char *new_filename\n-\t= (char *) xmalloc (strlen (convert_filename) + strlen (save_suffix) + 2);\n+\t= xmalloc (strlen (convert_filename) + strlen (save_suffix) + 2);\n \n       strcpy (new_filename, convert_filename);\n #ifdef __MSDOS__\n@@ -4310,8 +4305,8 @@ do_processing (void)\n   if (nondefault_syscalls_dir)\n     {\n       syscalls_absolute_filename\n-\t= (char *) xmalloc (strlen (nondefault_syscalls_dir) + 1\n-\t                    + sizeof (syscalls_filename));\n+\t= xmalloc (strlen (nondefault_syscalls_dir) + 1\n+\t\t   + sizeof (syscalls_filename));\n       strcpy (syscalls_absolute_filename, nondefault_syscalls_dir);\n     }\n   else\n@@ -4322,10 +4317,10 @@ do_processing (void)\n \t  default_syscalls_dir = standard_exec_prefix;\n \t}\n       syscalls_absolute_filename\n-\t= (char *) xmalloc (strlen (default_syscalls_dir) + 0\n-\t\t\t    + strlen (target_machine) + 1\n-\t\t\t    + strlen (target_version) + 1\n-\t                    + sizeof (syscalls_filename));\n+\t= xmalloc (strlen (default_syscalls_dir) + 0\n+\t\t   + strlen (target_machine) + 1\n+\t\t   + strlen (target_version) + 1\n+\t\t   + sizeof (syscalls_filename));\n       strcpy (syscalls_absolute_filename, default_syscalls_dir);\n       strcat (syscalls_absolute_filename, target_machine);\n       strcat (syscalls_absolute_filename, \"/\");\n@@ -4528,7 +4523,7 @@ main (int argc, char **const argv)\n   /* Now actually make a list of the base source filenames.  */\n \n   base_source_filenames\n-    = (const char **) xmalloc ((n_base_source_files + 1) * sizeof (char *));\n+    = xmalloc ((n_base_source_files + 1) * sizeof (char *));\n   n_base_source_files = 0;\n   for (; optind < argc; optind++)\n     {"}, {"sha": "d00369ec14e0a47a91b91709300c58f02c7d6e0e", "filename": "gcc/ra-build.c", "status": "modified", "additions": 28, "deletions": 40, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fra-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fra-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-build.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -331,8 +331,7 @@ get_sub_conflicts (wp, size_word)\n   bitmap b = find_sub_conflicts (wp, size_word);\n   if (!b)\n     {\n-      struct tagged_conflict *cl =\n-\t(struct tagged_conflict *) ra_alloc (sizeof *cl);\n+      struct tagged_conflict *cl = ra_alloc (sizeof *cl);\n       cl->conflicts = BITMAP_XMALLOC ();\n       cl->size_word = size_word;\n       cl->next = wp->sub_conflicts;\n@@ -583,10 +582,10 @@ remember_move (insn)\n \t subwebs could be source and target of coalescing).  */\n       if (GET_CODE (s) == REG && GET_CODE (d) == REG)\n \t{\n-\t  struct move *m = (struct move *) ra_calloc (sizeof (struct move));\n+\t  struct move *m = ra_calloc (sizeof (struct move));\n \t  struct move_list *ml;\n \t  m->insn = insn;\n-\t  ml = (struct move_list *) ra_alloc (sizeof (struct move_list));\n+\t  ml = ra_alloc (sizeof (struct move_list));\n \t  ml->move = m;\n \t  ml->next = wl_moves;\n \t  wl_moves = ml;\n@@ -1112,8 +1111,7 @@ init_bb_info ()\n   basic_block bb;\n   FOR_ALL_BB (bb)\n     {\n-      struct ra_bb_info *info =\n-\t(struct ra_bb_info *) xcalloc (1, sizeof *info);\n+      struct ra_bb_info *info = xcalloc (1, sizeof *info);\n       info->regnos_mentioned = BITMAP_XMALLOC ();\n       info->live_throughout = BITMAP_XMALLOC ();\n       info->old_aux = bb->aux;\n@@ -1149,9 +1147,8 @@ build_web_parts_and_conflicts (df)\n   struct curr_use use;\n   basic_block bb;\n \n-  number_seen = (int *) xcalloc (get_max_uid (), sizeof (int));\n-  visit_trace = (struct visit_trace *) xcalloc (get_max_uid (),\n-\t\t\t\t\t\tsizeof (visit_trace[0]));\n+  number_seen = xcalloc (get_max_uid (), sizeof (int));\n+  visit_trace = xcalloc (get_max_uid (), sizeof (visit_trace[0]));\n   update_regnos_mentioned ();\n \n   /* Here's the main loop.\n@@ -1252,7 +1249,7 @@ init_one_web_common (web, reg)\n   web->orig_x = reg;\n   if (!web->dlink)\n     {\n-      web->dlink = (struct dlist *) ra_calloc (sizeof (struct dlist));\n+      web->dlink = ra_calloc (sizeof (struct dlist));\n       DLIST_WEB (web->dlink) = web;\n     }\n   /* XXX\n@@ -1384,7 +1381,7 @@ add_subweb (web, reg)\n   struct web *w;\n   if (GET_CODE (reg) != SUBREG)\n     abort ();\n-  w = (struct web *) xmalloc (sizeof (struct web));\n+  w = xmalloc (sizeof (struct web));\n   /* Copy most content from parent-web.  */\n   *w = *web;\n   /* And initialize the private stuff.  */\n@@ -1519,7 +1516,7 @@ copy_conflict_list (web)\n   for (cl = web->conflict_list; cl; cl = cl->next)\n     {\n       struct conflict_link *ncl;\n-      ncl = (struct conflict_link *) ra_alloc (sizeof *ncl);\n+      ncl = ra_alloc (sizeof *ncl);\n       ncl->t = cl->t;\n       ncl->sub = NULL;\n       ncl->next = web->orig_conflict_list;\n@@ -1529,7 +1526,7 @@ copy_conflict_list (web)\n \t  struct sub_conflict *sl, *nsl;\n \t  for (sl = cl->sub; sl; sl = sl->next)\n \t    {\n-\t      nsl = (struct sub_conflict *) ra_alloc (sizeof *nsl);\n+\t      nsl = ra_alloc (sizeof *nsl);\n \t      nsl->s = sl->s;\n \t      nsl->t = sl->t;\n \t      nsl->next = ncl->sub;\n@@ -1571,7 +1568,7 @@ add_conflict_edge (from, to)\n \tcopy_conflict_list (pfrom);\n       if (!TEST_BIT (sup_igraph, (pfrom->id * num_webs + pto->id)))\n \t{\n-\t  cl = (struct conflict_link *) ra_alloc (sizeof (*cl));\n+\t  cl = ra_alloc (sizeof (*cl));\n \t  cl->t = pto;\n \t  cl->sub = NULL;\n \t  cl->next = pfrom->conflict_list;\n@@ -1596,7 +1593,7 @@ add_conflict_edge (from, to)\n \t     means we are not interested in this subconflict.  */\n \t  if (!may_delete || cl->sub != NULL)\n \t    {\n-\t      sl = (struct sub_conflict *) ra_alloc (sizeof (*sl));\n+\t      sl = ra_alloc (sizeof (*sl));\n \t      sl->s = from;\n \t      sl->t = to;\n \t      sl->next = cl->sub;\n@@ -1698,8 +1695,8 @@ copy_web (web, wl)\n      struct web *web;\n      struct web_link **wl;\n {\n-  struct web *cweb = (struct web *) xmalloc (sizeof *cweb);\n-  struct web_link *link = (struct web_link *) ra_alloc (sizeof *link);\n+  struct web *cweb = xmalloc (sizeof *cweb);\n+  struct web_link *link = ra_alloc (sizeof *link);\n   link->next = *wl;\n   *wl = link;\n   link->web = cweb;\n@@ -1776,11 +1773,9 @@ init_webs_defs_uses ()\n \t  continue;\n \t}\n       if (web->num_defs)\n-        web->defs = (struct ref **) xmalloc (web->num_defs *\n-\t\t\t\t\t     sizeof (web->defs[0]));\n+        web->defs = xmalloc (web->num_defs * sizeof (web->defs[0]));\n       if (web->num_uses)\n-        web->uses = (struct ref **) xmalloc (web->num_uses *\n-\t\t\t\t\t     sizeof (web->uses[0]));\n+        web->uses = xmalloc (web->num_uses * sizeof (web->uses[0]));\n       def_i = use_i = 0;\n       for (link = web->temp_refs; link; link = link->next)\n \t{\n@@ -1840,7 +1835,7 @@ parts_to_webs_1 (df, copy_webs, all_refs)\n \t     allocate a new one.  */\n \t  if (ra_pass == 1)\n \t    {\n-\t      web = (struct web *) xmalloc (sizeof (struct web));\n+\t      web = xmalloc (sizeof (struct web));\n \t      newid = last_num_webs++;\n \t      init_one_web (web, GET_CODE (reg) == SUBREG\n \t\t\t         ? SUBREG_REG (reg) : reg);\n@@ -1873,7 +1868,7 @@ parts_to_webs_1 (df, copy_webs, all_refs)\n \t\t  else\n \t\t    {\n \t\t      /* Else allocate a new one.  */\n-\t\t      web = (struct web *) xmalloc (sizeof (struct web));\n+\t\t      web = xmalloc (sizeof (struct web));\n \t\t      newid = last_num_webs++;\n \t\t    }\n \t\t}\n@@ -2032,16 +2027,15 @@ parts_to_webs (df)\n   num_subwebs = 0;\n \n   /* First build webs and ordinary subwebs.  */\n-  all_refs = (struct df_link *) xcalloc (df->def_id + df->use_id,\n-\t\t\t\t\t sizeof (all_refs[0]));\n+  all_refs = xcalloc (df->def_id + df->use_id, sizeof (all_refs[0]));\n   webnum = parts_to_webs_1 (df, &copy_webs, all_refs);\n \n   /* Setup the webs for hardregs which are still missing (weren't\n      mentioned in the code).  */\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (!hardreg2web[i])\n       {\n-\tstruct web *web = (struct web *) xmalloc (sizeof (struct web));\n+\tstruct web *web = xmalloc (sizeof (struct web));\n \tinit_one_web (web, gen_rtx_REG (reg_raw_mode[i], i));\n \tweb->id = last_num_webs++;\n \thardreg2web[web->regno] = web;\n@@ -2089,7 +2083,7 @@ parts_to_webs (df)\n     }\n \n   /* Now that everyone has an ID, we can setup the id2web array.  */\n-  id2web = (struct web **) xcalloc (webnum, sizeof (id2web[0]));\n+  id2web = xcalloc (webnum, sizeof (id2web[0]));\n   for (d = WEBS(INITIAL); d; d = d->next)\n     {\n       struct web *web = DLIST_WEB (d);\n@@ -2243,7 +2237,7 @@ conflicts_between_webs (df)\n #endif\n   bitmap ignore_defs = BITMAP_XMALLOC ();\n   unsigned int have_ignored;\n-  unsigned int *pass_cache = (unsigned int *) xcalloc (num_webs, sizeof (int));\n+  unsigned int *pass_cache = xcalloc (num_webs, sizeof (int));\n   unsigned int pass = 0;\n \n   if (ra_pass > 1)\n@@ -2831,8 +2825,7 @@ moves_to_webs (df)\n \t      for (; test && test->move != m; test = test->next);\n \t      if (! test)\n \t\t{\n-\t\t  newml = (struct move_list*)\n-\t\t    ra_alloc (sizeof (struct move_list));\n+\t\t  newml = ra_alloc (sizeof (struct move_list));\n \t\t  newml->move = m;\n \t\t  newml->next = m->source_web->moves;\n \t\t  m->source_web->moves = newml;\n@@ -2841,8 +2834,7 @@ moves_to_webs (df)\n \t      for (; test && test->move != m; test = test->next);\n \t      if (! test)\n \t\t{\n-\t\t  newml = (struct move_list*)\n-\t\t    ra_alloc (sizeof (struct move_list));\n+\t\t  newml = ra_alloc (sizeof (struct move_list));\n \t\t  newml->move = m;\n \t\t  newml->next = m->target_web->moves;\n \t\t  m->target_web->moves = newml;\n@@ -3079,10 +3071,8 @@ ra_build_realloc (df)\n   unsigned int i;\n   struct dlist *d;\n   move_handled = sbitmap_alloc (get_max_uid () );\n-  web_parts = (struct web_part *) xcalloc (df->def_id + df->use_id,\n-\t\t\t\t\t   sizeof web_parts[0]);\n-  def2web = (struct web **) xcalloc (df->def_id + df->use_id,\n-\t\t\t\t     sizeof def2web[0]);\n+  web_parts = xcalloc (df->def_id + df->use_id, sizeof web_parts[0]);\n+  def2web = xcalloc (df->def_id + df->use_id, sizeof def2web[0]);\n   use2web = &def2web[df->def_id];\n   live_over_abnormal = sbitmap_alloc (df->use_id);\n   sbitmap_zero (live_over_abnormal);\n@@ -3172,14 +3162,12 @@ ra_build_realloc (df)\n   if (!last_max_uid)\n     {\n       /* Setup copy cache, for copy_insn_p ().  */\n-      copy_cache = (struct copy_p_cache *)\n-\txcalloc (get_max_uid (), sizeof (copy_cache[0]));\n+      copy_cache = xcalloc (get_max_uid (), sizeof (copy_cache[0]));\n       init_bb_info ();\n     }\n   else\n     {\n-      copy_cache = (struct copy_p_cache *)\n-\txrealloc (copy_cache, get_max_uid () * sizeof (copy_cache[0]));\n+      copy_cache = xrealloc (copy_cache, get_max_uid () * sizeof (copy_cache[0]));\n       memset (&copy_cache[last_max_uid], 0,\n \t      (get_max_uid () - last_max_uid) * sizeof (copy_cache[0]));\n     }"}, {"sha": "07d2196749b1c4acf4e04fecff775c511783761e", "filename": "gcc/ra-colorize.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fra-colorize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fra-colorize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-colorize.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -348,7 +348,7 @@ build_worklists (df)\n       unsigned int i, num, max_num;\n       struct web **order2web;\n       max_num = num_webs - num_subwebs;\n-      order2web = (struct web **) xmalloc (max_num * sizeof (order2web[0]));\n+      order2web = xmalloc (max_num * sizeof (order2web[0]));\n       for (i = 0, num = 0; i < max_num; i++)\n \tif (id2web[i]->regno >= max_normal_pseudo)\n \t  order2web[num++] = id2web[i];\n@@ -397,7 +397,7 @@ build_worklists (df)\n     if (ml->move)\n       {\n \tstruct move *m = ml->move;\n-        d = (struct dlist *) ra_calloc (sizeof (struct dlist));\n+        d = ra_calloc (sizeof (struct dlist));\n         DLIST_MOVE (d) = m;\n         m->dlink = d;\n \tput_move (m, WORKLIST);\n@@ -1702,11 +1702,10 @@ try_recolor_web (web)\n   int newcol, c;\n   HARD_REG_SET precolored_neighbors, spill_temps;\n   HARD_REG_SET possible_begin, wide_seen;\n-  cost_neighbors = (unsigned HOST_WIDE_INT *)\n-    xcalloc (FIRST_PSEUDO_REGISTER, sizeof (cost_neighbors[0]));\n+  cost_neighbors = xcalloc (FIRST_PSEUDO_REGISTER, sizeof (cost_neighbors[0]));\n   /* For each hard-regs count the number of preceding hardregs, which\n      would overlap this color, if used in WEB's mode.  */\n-  min_color = (unsigned int *) xcalloc (FIRST_PSEUDO_REGISTER, sizeof (int));\n+  min_color = xcalloc (FIRST_PSEUDO_REGISTER, sizeof (int));\n   CLEAR_HARD_REG_SET (possible_begin);\n   for (c = 0; c < FIRST_PSEUDO_REGISTER; c++)\n     {\n@@ -1805,7 +1804,7 @@ try_recolor_web (web)\n       remove_list (web->dlink, &WEBS(SPILLED));\n       put_web (web, COLORED);\n       web->color = newcol;\n-      old_colors = (int *) xcalloc (num_webs, sizeof (int));\n+      old_colors = xcalloc (num_webs, sizeof (int));\n       for (wl = web->conflict_list; wl; wl = wl_next)\n \t{\n \t  struct web *web2 = alias (wl->t);\n@@ -1972,7 +1971,7 @@ recolor_spills ()\n   unsigned int i, num;\n   struct web **order2web;\n   num = num_webs - num_subwebs;\n-  order2web = (struct web **) xmalloc (num * sizeof (order2web[0]));\n+  order2web = xmalloc (num * sizeof (order2web[0]));\n   for (i = 0; i < num; i++)\n     {\n       order2web[i] = id2web[i];\n@@ -2431,7 +2430,7 @@ add_web_pair_cost (web1, web2, cost, conflicts)\n \tp->conflicts += conflicts;\n \treturn;\n       }\n-  p = (struct web_pair *) ra_alloc (sizeof *p);\n+  p = ra_alloc (sizeof *p);\n   p->next_hash = web_pair_hash[hash];\n   p->next_list = web_pair_list;\n   p->smaller = web1;\n@@ -2477,7 +2476,7 @@ sort_and_combine_web_pairs (for_move)\n   struct web_pair *p;\n   if (!num_web_pairs)\n     return;\n-  sorted = (struct web_pair **) xmalloc (num_web_pairs * sizeof (sorted[0]));\n+  sorted = xmalloc (num_web_pairs * sizeof (sorted[0]));\n   for (p = web_pair_list, i = 0; p; p = p->next_list)\n     sorted[i++] = p;\n   if (i != num_web_pairs)"}, {"sha": "ef2cca1c166b874b14113d297789c532c81a778d", "filename": "gcc/ra-rewrite.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fra-rewrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fra-rewrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-rewrite.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -329,8 +329,7 @@ static void\n choose_spill_colors ()\n {\n   struct dlist *d;\n-  unsigned HOST_WIDE_INT *costs = (unsigned HOST_WIDE_INT *)\n-    xmalloc (FIRST_PSEUDO_REGISTER * sizeof (costs[0]));\n+  unsigned HOST_WIDE_INT *costs = xmalloc (FIRST_PSEUDO_REGISTER * sizeof (costs[0]));\n   for (d = WEBS(SPILLED); d; d = d->next)\n     {\n       struct web *web = DLIST_WEB (d);\n@@ -545,7 +544,7 @@ remember_slot (list, x)\n {\n   struct rtx_list *l;\n   /* PRE: X is not already in LIST.  */\n-  l = (struct rtx_list *) ra_alloc (sizeof (*l));\n+  l = ra_alloc (sizeof (*l));\n   l->next = *list;\n   l->x = x;\n   *list = l;\n@@ -1089,7 +1088,7 @@ rewrite_program2 (new_deaths)\n   int nl_first_reload;\n   struct rewrite_info ri;\n   rtx insn;\n-  ri.needed_loads = (struct web **) xmalloc (num_webs * sizeof (struct web *));\n+  ri.needed_loads = xmalloc (num_webs * sizeof (struct web *));\n   ri.need_reload = BITMAP_XMALLOC ();\n   ri.scratch = BITMAP_XMALLOC ();\n   ri.live = sbitmap_alloc (num_webs);\n@@ -1750,7 +1749,7 @@ emit_colors (df)\n     }\n   ra_max_regno = max_regno = max_reg_num ();\n   allocate_reg_info (max_regno, FALSE, FALSE);\n-  ra_reg_renumber = (short *) xmalloc (max_regno * sizeof (short));\n+  ra_reg_renumber = xmalloc (max_regno * sizeof (short));\n   for (si = 0; si < max_regno; si++)\n     ra_reg_renumber[si] = -1;\n "}, {"sha": "1f24abd45d1c560b335b8db7af30a6fcdeb78156", "filename": "gcc/ra.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -375,8 +375,7 @@ alloc_mem (df)\n   ra_build_realloc (df);\n   if (!live_at_end)\n     {\n-      live_at_end = (bitmap *) xmalloc ((last_basic_block + 2)\n-\t\t\t\t\t* sizeof (bitmap));\n+      live_at_end = xmalloc ((last_basic_block + 2) * sizeof (bitmap));\n       for (i = 0; i < last_basic_block + 2; i++)\n \tlive_at_end[i] = BITMAP_XMALLOC ();\n       live_at_end += 2;\n@@ -907,7 +906,7 @@ reg_alloc ()\n \t\t\t \"after allocation/spilling, before reload\", NULL);\n \n   /* Allocate the reg_equiv_memory_loc array for reload.  */\n-  reg_equiv_memory_loc = (rtx *) xcalloc (max_regno, sizeof (rtx));\n+  reg_equiv_memory_loc = xcalloc (max_regno, sizeof (rtx));\n   /* And possibly initialize it.  */\n   allocate_initial_values (reg_equiv_memory_loc);\n   /* And one last regclass pass just before reload.  */"}, {"sha": "508baeeed3a90eaac6c918c9910e25cc5b04155f", "filename": "gcc/recog.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -150,8 +150,8 @@ check_asm_operands (rtx x)\n   if (noperands == 0)\n     return 1;\n \n-  operands = (rtx *) alloca (noperands * sizeof (rtx));\n-  constraints = (const char **) alloca (noperands * sizeof (char *));\n+  operands = alloca (noperands * sizeof (rtx));\n+  constraints = alloca (noperands * sizeof (char *));\n \n   decode_asm_operands (x, operands, NULL, constraints, NULL);\n \n@@ -226,9 +226,7 @@ validate_change (rtx object, rtx *loc, rtx new, int in_group)\n       else\n \tchanges_allocated *= 2;\n \n-      changes =\n-\t(change_t*) xrealloc (changes,\n-\t\t\t      sizeof (change_t) * changes_allocated);\n+      changes = xrealloc (changes, sizeof (change_t) * changes_allocated);\n     }\n \n   changes[num_changes].object = object;"}, {"sha": "016c5c7c2c66087bb50a3930d35591d9218b4318", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -630,7 +630,7 @@ check_asm_stack_operands (rtx insn)\n \n   if (GET_CODE (body) == PARALLEL)\n     {\n-      clobber_reg = (rtx *) alloca (XVECLEN (body, 0) * sizeof (rtx));\n+      clobber_reg = alloca (XVECLEN (body, 0) * sizeof (rtx));\n \n       for (i = 0; i < XVECLEN (body, 0); i++)\n \tif (GET_CODE (XVECEXP (body, 0, i)) == CLOBBER)\n@@ -1946,9 +1946,9 @@ subst_asm_stack_regs (rtx insn, stack regstack)\n   for (i = 0, note = REG_NOTES (insn); note; note = XEXP (note, 1))\n     i++;\n \n-  note_reg = (rtx *) alloca (i * sizeof (rtx));\n-  note_loc = (rtx **) alloca (i * sizeof (rtx *));\n-  note_kind = (enum reg_note *) alloca (i * sizeof (enum reg_note));\n+  note_reg = alloca (i * sizeof (rtx));\n+  note_loc = alloca (i * sizeof (rtx *));\n+  note_kind = alloca (i * sizeof (enum reg_note));\n \n   n_notes = 0;\n   for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n@@ -1979,8 +1979,8 @@ subst_asm_stack_regs (rtx insn, stack regstack)\n \n   if (GET_CODE (body) == PARALLEL)\n     {\n-      clobber_reg = (rtx *) alloca (XVECLEN (body, 0) * sizeof (rtx));\n-      clobber_loc = (rtx **) alloca (XVECLEN (body, 0) * sizeof (rtx *));\n+      clobber_reg = alloca (XVECLEN (body, 0) * sizeof (rtx));\n+      clobber_loc = alloca (XVECLEN (body, 0) * sizeof (rtx *));\n \n       for (i = 0; i < XVECLEN (body, 0); i++)\n \tif (GET_CODE (XVECEXP (body, 0, i)) == CLOBBER)\n@@ -2800,7 +2800,7 @@ convert_regs_2 (FILE *file, basic_block block)\n   basic_block *stack, *sp;\n   int inserted;\n \n-  stack = (basic_block *) xmalloc (sizeof (*stack) * n_basic_blocks);\n+  stack = xmalloc (sizeof (*stack) * n_basic_blocks);\n   sp = stack;\n \n   *sp++ = block;"}, {"sha": "b48f2e657fb639d82ad01244294d4e7f97dc9d9d", "filename": "gcc/regclass.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -311,7 +311,7 @@ init_reg_sets_1 (void)\n \n   /* Compute number of hard regs in each class.  */\n \n-  memset ((char *) reg_class_size, 0, sizeof reg_class_size);\n+  memset (reg_class_size, 0, sizeof reg_class_size);\n   for (i = 0; i < N_REG_CLASSES; i++)\n     for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n       if (TEST_HARD_REG_BIT (reg_class_contents[i], j))\n@@ -1202,11 +1202,11 @@ regclass (rtx f, int nregs, FILE *dump)\n \n   init_recog ();\n \n-  costs = (struct costs *) xmalloc (nregs * sizeof (struct costs));\n+  costs = xmalloc (nregs * sizeof (struct costs));\n \n #ifdef FORBIDDEN_INC_DEC_CLASSES\n \n-  in_inc_dec = (char *) xmalloc (nregs);\n+  in_inc_dec = xmalloc (nregs);\n \n #endif /* FORBIDDEN_INC_DEC_CLASSES */\n \n@@ -1223,7 +1223,7 @@ regclass (rtx f, int nregs, FILE *dump)\n \tfprintf (dump, \"\\n\\nPass %i\\n\\n\",pass);\n       /* Zero out our accumulation of the cost of each class for each reg.  */\n \n-      memset ((char *) costs, 0, nregs * sizeof (struct costs));\n+      memset (costs, 0, nregs * sizeof (struct costs));\n \n #ifdef FORBIDDEN_INC_DEC_CLASSES\n       memset (in_inc_dec, 0, nregs);\n@@ -1423,7 +1423,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t  if (*p == 0)\n \t    {\n \t      if (GET_CODE (op) == REG && REGNO (op) >= FIRST_PSEUDO_REGISTER)\n-\t\tmemset ((char *) &this_op_costs[i], 0, sizeof this_op_costs[i]);\n+\t\tmemset (&this_op_costs[i], 0, sizeof this_op_costs[i]);\n \n \t      continue;\n \t    }\n@@ -2162,9 +2162,9 @@ allocate_reg_info (size_t num_regs, int new_p, int renumber_p)\n       if (!reg_n_info)\n \t{\n \t  VARRAY_REG_INIT (reg_n_info, regno_allocated, \"reg_n_info\");\n-\t  renumber = (short *) xmalloc (size_renumber);\n-\t  reg_pref_buffer = (struct reg_pref *) xmalloc (regno_allocated\n-\t\t\t\t\t      * sizeof (struct reg_pref));\n+\t  renumber = xmalloc (size_renumber);\n+\t  reg_pref_buffer = xmalloc (regno_allocated\n+\t\t\t\t     * sizeof (struct reg_pref));\n \t}\n \n       else\n@@ -2175,23 +2175,23 @@ allocate_reg_info (size_t num_regs, int new_p, int renumber_p)\n \t    {\n \t      free ((char *) renumber);\n \t      free ((char *) reg_pref);\n-\t      renumber = (short *) xmalloc (size_renumber);\n-\t      reg_pref_buffer = (struct reg_pref *) xmalloc (regno_allocated\n-\t\t\t\t\t\t  * sizeof (struct reg_pref));\n+\t      renumber = xmalloc (size_renumber);\n+\t      reg_pref_buffer = xmalloc (regno_allocated\n+\t\t\t\t\t * sizeof (struct reg_pref));\n \t    }\n \n \t  else\n \t    {\n-\t      renumber = (short *) xrealloc ((char *) renumber, size_renumber);\n-\t      reg_pref_buffer = (struct reg_pref *) xrealloc ((char *) reg_pref_buffer,\n-\t\t\t\t\t\t   regno_allocated\n-\t\t\t\t\t\t   * sizeof (struct reg_pref));\n+\t      renumber = xrealloc (renumber, size_renumber);\n+\t      reg_pref_buffer = xrealloc (reg_pref_buffer,\n+\t\t\t\t\t  regno_allocated\n+\t\t\t\t\t  * sizeof (struct reg_pref));\n \t    }\n \t}\n \n       size_info = (regno_allocated - old_allocated) * sizeof (reg_info)\n \t+ sizeof (struct reg_info_data) - sizeof (reg_info);\n-      reg_data = (struct reg_info_data *) xcalloc (size_info, 1);\n+      reg_data = xcalloc (size_info, 1);\n       reg_data->min_index = old_allocated;\n       reg_data->max_index = regno_allocated - 1;\n       reg_data->next = reg_info_head;\n@@ -2221,8 +2221,8 @@ allocate_reg_info (size_t num_regs, int new_p, int renumber_p)\n \t  if (!reg_data->used_p)\t/* page just allocated with calloc */\n \t    reg_data->used_p = 1;\t/* no need to zero */\n \t  else\n-\t    memset ((char *) &reg_data->data[local_min], 0,\n-\t\t   sizeof (reg_info) * (max - min_index - local_min + 1));\n+\t    memset (&reg_data->data[local_min], 0,\n+\t\t    sizeof (reg_info) * (max - min_index - local_min + 1));\n \n \t  for (i = min_index+local_min; i <= max; i++)\n \t    {"}, {"sha": "435a1565cc2ac6f1ee10d69e221fabd9e9da05ce", "filename": "gcc/regmove.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -1055,10 +1055,10 @@ regmove_optimize (rtx f, int nregs, FILE *regmove_dump_file)\n      can suppress some optimizations in those zones.  */\n   mark_flags_life_zones (discover_flags_reg ());\n \n-  regno_src_regno = (int *) xmalloc (sizeof *regno_src_regno * nregs);\n+  regno_src_regno = xmalloc (sizeof *regno_src_regno * nregs);\n   for (i = nregs; --i >= 0; ) regno_src_regno[i] = -1;\n \n-  regmove_bb_head = (int *) xmalloc (sizeof (int) * (old_max_uid + 1));\n+  regmove_bb_head = xmalloc (sizeof (int) * (old_max_uid + 1));\n   for (i = old_max_uid; i >= 0; i--) regmove_bb_head[i] = -1;\n   FOR_EACH_BB (bb)\n     regmove_bb_head[INSN_UID (bb->head)] = bb->index;\n@@ -2198,7 +2198,7 @@ record_one_stack_memref (rtx insn, rtx *mem, struct csa_memlist *next_memlist)\n {\n   struct csa_memlist *ml;\n \n-  ml = (struct csa_memlist *) xmalloc (sizeof (*ml));\n+  ml = xmalloc (sizeof (*ml));\n \n   if (XEXP (*mem, 0) == stack_pointer_rtx)\n     ml->sp_offset = 0;"}, {"sha": "c1ff6255316c62196e875276f4f1b334b974cfaa", "filename": "gcc/regrename.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -194,7 +194,7 @@ regrename_optimize (void)\n   memset (tick, 0, sizeof tick);\n \n   gcc_obstack_init (&rename_obstack);\n-  first_obj = (char *) obstack_alloc (&rename_obstack, 0);\n+  first_obj = obstack_alloc (&rename_obstack, 0);\n \n   FOR_EACH_BB (bb)\n     {\n@@ -395,8 +395,8 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class class,\n     {\n       if (type == OP_OUT)\n \t{\n-\t  struct du_chain *this = (struct du_chain *)\n-\t    obstack_alloc (&rename_obstack, sizeof (struct du_chain));\n+\t  struct du_chain *this\n+\t    = obstack_alloc (&rename_obstack, sizeof (struct du_chain));\n \t  this->next_use = 0;\n \t  this->next_chain = open_chains;\n \t  this->loc = loc;\n@@ -450,8 +450,7 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class class,\n \t\t be replaced with, terminate the chain.  */\n \t      if (class != NO_REGS)\n \t\t{\n-\t\t  this = (struct du_chain *)\n-\t\t    obstack_alloc (&rename_obstack, sizeof (struct du_chain));\n+\t\t  this = obstack_alloc (&rename_obstack, sizeof (struct du_chain));\n \t\t  this->next_use = 0;\n \t\t  this->next_chain = (*p)->next_chain;\n \t\t  this->loc = loc;"}, {"sha": "dc088730e67bd5e65f659480c99b5f8787efabe6", "filename": "gcc/reload.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -651,7 +651,7 @@ get_secondary_mem (rtx x ATTRIBUTE_UNUSED, enum machine_mode mode,\n void\n clear_secondary_mem (void)\n {\n-  memset ((char *) secondary_memlocs, 0, sizeof secondary_memlocs);\n+  memset (secondary_memlocs, 0, sizeof secondary_memlocs);\n }\n #endif /* SECONDARY_MEMORY_NEEDED */\n \f\n@@ -2539,7 +2539,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n   /* The eliminated forms of any secondary memory locations are per-insn, so\n      clear them out here.  */\n \n-  memset ((char *) secondary_memlocs_elim, 0, sizeof secondary_memlocs_elim);\n+  memset (secondary_memlocs_elim, 0, sizeof secondary_memlocs_elim);\n #endif\n \n   /* Dispose quickly of (set (reg..) (reg..)) if both have hard regs and it"}, {"sha": "37cc4b2809209bf6a57cc3ce3e8d9a8f2b2b2677", "filename": "gcc/reload1.c", "status": "modified", "additions": 27, "deletions": 34, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -475,7 +475,7 @@ init_reload (void)\n \n   /* Initialize obstack for our rtl allocation.  */\n   gcc_obstack_init (&reload_obstack);\n-  reload_startobj = (char *) obstack_alloc (&reload_obstack, 0);\n+  reload_startobj = obstack_alloc (&reload_obstack, 0);\n \n   INIT_REG_SET (&spilled_pseudos);\n   INIT_REG_SET (&pseudos_counted);\n@@ -492,8 +492,7 @@ new_insn_chain (void)\n \n   if (unused_insn_chains == 0)\n     {\n-      c = (struct insn_chain *)\n-\tobstack_alloc (&reload_obstack, sizeof (struct insn_chain));\n+      c = obstack_alloc (&reload_obstack, sizeof (struct insn_chain));\n       INIT_REG_SET (&c->live_throughout);\n       INIT_REG_SET (&c->dead_or_set);\n     }\n@@ -638,7 +637,7 @@ reload (rtx first, int global)\n \n   failure = 0;\n \n-  reload_firstobj = (char *) obstack_alloc (&reload_obstack, 0);\n+  reload_firstobj = obstack_alloc (&reload_obstack, 0);\n \n   /* Make sure that the last insn in the chain\n      is not something that needs reloading.  */\n@@ -653,8 +652,8 @@ reload (rtx first, int global)\n #endif\n \n   /* We don't have a stack slot for any spill reg yet.  */\n-  memset ((char *) spill_stack_slot, 0, sizeof spill_stack_slot);\n-  memset ((char *) spill_stack_slot_width, 0, sizeof spill_stack_slot_width);\n+  memset (spill_stack_slot, 0, sizeof spill_stack_slot);\n+  memset (spill_stack_slot_width, 0, sizeof spill_stack_slot_width);\n \n   /* Initialize the save area information for caller-save, in case some\n      are needed.  */\n@@ -684,17 +683,15 @@ reload (rtx first, int global)\n      Record memory equivalents in reg_mem_equiv so they can\n      be substituted eventually by altering the REG-rtx's.  */\n \n-  reg_equiv_constant = (rtx *) xcalloc (max_regno, sizeof (rtx));\n-  reg_equiv_mem = (rtx *) xcalloc (max_regno, sizeof (rtx));\n-  reg_equiv_init = (rtx *) xcalloc (max_regno, sizeof (rtx));\n-  reg_equiv_address = (rtx *) xcalloc (max_regno, sizeof (rtx));\n-  reg_max_ref_width = (unsigned int *) xcalloc (max_regno, sizeof (int));\n-  reg_old_renumber = (short *) xcalloc (max_regno, sizeof (short));\n+  reg_equiv_constant = xcalloc (max_regno, sizeof (rtx));\n+  reg_equiv_mem = xcalloc (max_regno, sizeof (rtx));\n+  reg_equiv_init = xcalloc (max_regno, sizeof (rtx));\n+  reg_equiv_address = xcalloc (max_regno, sizeof (rtx));\n+  reg_max_ref_width = xcalloc (max_regno, sizeof (int));\n+  reg_old_renumber = xcalloc (max_regno, sizeof (short));\n   memcpy (reg_old_renumber, reg_renumber, max_regno * sizeof (short));\n-  pseudo_forbidden_regs\n-    = (HARD_REG_SET *) xmalloc (max_regno * sizeof (HARD_REG_SET));\n-  pseudo_previous_regs\n-    = (HARD_REG_SET *) xcalloc (max_regno, sizeof (HARD_REG_SET));\n+  pseudo_forbidden_regs = xmalloc (max_regno * sizeof (HARD_REG_SET));\n+  pseudo_previous_regs = xcalloc (max_regno, sizeof (HARD_REG_SET));\n \n   CLEAR_HARD_REG_SET (bad_spill_regs_global);\n \n@@ -819,9 +816,7 @@ reload (rtx first, int global)\n      allocate would occasionally cause it to exceed the stack limit and\n      cause a core dump.  */\n   offsets_known_at = xmalloc (num_labels);\n-  offsets_at\n-    = (int (*)[NUM_ELIMINABLE_REGS])\n-    xmalloc (num_labels * NUM_ELIMINABLE_REGS * sizeof (int));\n+  offsets_at = xmalloc (num_labels * NUM_ELIMINABLE_REGS * sizeof (int));\n \n   /* Alter each pseudo-reg rtx to contain its hard reg number.\n      Assign stack slots to the pseudos that lack hard regs or equivalents.\n@@ -953,7 +948,7 @@ reload (rtx first, int global)\n \t{\n \t  save_call_clobbered_regs ();\n \t  /* That might have allocated new insn_chain structures.  */\n-\t  reload_firstobj = (char *) obstack_alloc (&reload_obstack, 0);\n+\t  reload_firstobj = obstack_alloc (&reload_obstack, 0);\n \t}\n \n       calculate_needs_all_insns (global);\n@@ -1381,11 +1376,10 @@ static void\n copy_reloads (struct insn_chain *chain)\n {\n   chain->n_reloads = n_reloads;\n-  chain->rld\n-    = (struct reload *) obstack_alloc (&reload_obstack,\n-\t\t\t\t       n_reloads * sizeof (struct reload));\n+  chain->rld = obstack_alloc (&reload_obstack,\n+\t\t\t      n_reloads * sizeof (struct reload));\n   memcpy (chain->rld, rld, n_reloads * sizeof (struct reload));\n-  reload_insn_firstobj = (char *) obstack_alloc (&reload_obstack, 0);\n+  reload_insn_firstobj = obstack_alloc (&reload_obstack, 0);\n }\n \n /* Walk the chain of insns, and determine for each whether it needs reloads\n@@ -1399,7 +1393,7 @@ calculate_needs_all_insns (int global)\n \n   something_needs_elimination = 0;\n \n-  reload_insn_firstobj = (char *) obstack_alloc (&reload_obstack, 0);\n+  reload_insn_firstobj = obstack_alloc (&reload_obstack, 0);\n   for (chain = reload_insn_chain; chain != 0; chain = next)\n     {\n       rtx insn = chain->insn;\n@@ -3442,8 +3436,7 @@ init_elim_table (void)\n #endif\n \n   if (!reg_eliminate)\n-    reg_eliminate = (struct elim_table *)\n-      xcalloc (sizeof (struct elim_table), NUM_ELIMINABLE_REGS);\n+    reg_eliminate = xcalloc (sizeof (struct elim_table), NUM_ELIMINABLE_REGS);\n \n   /* Does this function require a frame pointer?  */\n \n@@ -3589,7 +3582,7 @@ finish_spills (int global)\n   /* Retry global register allocation if possible.  */\n   if (global)\n     {\n-      memset ((char *) pseudo_forbidden_regs, 0, max_regno * sizeof (HARD_REG_SET));\n+      memset (pseudo_forbidden_regs, 0, max_regno * sizeof (HARD_REG_SET));\n       /* For every insn that needs reloads, set the registers used as spill\n \t regs in pseudo_forbidden_regs for every pseudo live across the\n \t insn.  */\n@@ -3759,10 +3752,10 @@ reload_as_needed (int live_known)\n #endif\n   rtx x;\n \n-  memset ((char *) spill_reg_rtx, 0, sizeof spill_reg_rtx);\n-  memset ((char *) spill_reg_store, 0, sizeof spill_reg_store);\n-  reg_last_reload_reg = (rtx *) xcalloc (max_regno, sizeof (rtx));\n-  reg_has_output_reload = (char *) xmalloc (max_regno);\n+  memset (spill_reg_rtx, 0, sizeof spill_reg_rtx);\n+  memset (spill_reg_store, 0, sizeof spill_reg_store);\n+  reg_last_reload_reg = xcalloc (max_regno, sizeof (rtx));\n+  reg_has_output_reload = xmalloc (max_regno);\n   CLEAR_HARD_REG_SET (reg_reloaded_valid);\n \n   set_initial_elim_offsets ();\n@@ -5156,8 +5149,8 @@ choose_reload_regs_init (struct insn_chain *chain, rtx *save_reload_reg_rtx)\n     rld[i].reg_rtx = save_reload_reg_rtx[i];\n \n   memset (reload_inherited, 0, MAX_RELOADS);\n-  memset ((char *) reload_inheritance_insn, 0, MAX_RELOADS * sizeof (rtx));\n-  memset ((char *) reload_override_in, 0, MAX_RELOADS * sizeof (rtx));\n+  memset (reload_inheritance_insn, 0, MAX_RELOADS * sizeof (rtx));\n+  memset (reload_override_in, 0, MAX_RELOADS * sizeof (rtx));\n \n   CLEAR_HARD_REG_SET (reload_reg_used);\n   CLEAR_HARD_REG_SET (reload_reg_used_at_all);"}, {"sha": "3d7159daa7c9d7be62366c33f26765dff46acc0b", "filename": "gcc/reorg.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -3587,15 +3587,15 @@ dbr_schedule (rtx first, FILE *file)\n \tepilogue_insn = insn;\n     }\n \n-  uid_to_ruid = (int *) xmalloc ((max_uid + 1) * sizeof (int));\n+  uid_to_ruid = xmalloc ((max_uid + 1) * sizeof (int));\n   for (i = 0, insn = first; insn; i++, insn = NEXT_INSN (insn))\n     uid_to_ruid[INSN_UID (insn)] = i;\n \n   /* Initialize the list of insns that need filling.  */\n   if (unfilled_firstobj == 0)\n     {\n       gcc_obstack_init (&unfilled_slots_obstack);\n-      unfilled_firstobj = (rtx *) obstack_alloc (&unfilled_slots_obstack, 0);\n+      unfilled_firstobj = obstack_alloc (&unfilled_slots_obstack, 0);\n     }\n \n   for (insn = next_active_insn (first); insn; insn = next_active_insn (insn))\n@@ -3629,8 +3629,8 @@ dbr_schedule (rtx first, FILE *file)\n   end_of_function_label = 0;\n \n   /* Initialize the statistics for this function.  */\n-  memset ((char *) num_insns_needing_delays, 0, sizeof num_insns_needing_delays);\n-  memset ((char *) num_filled_delays, 0, sizeof num_filled_delays);\n+  memset (num_insns_needing_delays, 0, sizeof num_insns_needing_delays);\n+  memset (num_filled_delays, 0, sizeof num_filled_delays);\n \n   /* Now do the delay slot filling.  Try everything twice in case earlier\n      changes make more slots fillable.  */\n@@ -3670,7 +3670,7 @@ dbr_schedule (rtx first, FILE *file)\n   obstack_free (&unfilled_slots_obstack, unfilled_firstobj);\n \n   /* It is not clear why the line below is needed, but it does seem to be.  */\n-  unfilled_firstobj = (rtx *) obstack_alloc (&unfilled_slots_obstack, 0);\n+  unfilled_firstobj = obstack_alloc (&unfilled_slots_obstack, 0);\n \n   if (file)\n     {\n@@ -3703,8 +3703,8 @@ dbr_schedule (rtx first, FILE *file)\n \t      fprintf (file, \"\\n\");\n \t    }\n \t}\n-      memset ((char *) total_delay_slots, 0, sizeof total_delay_slots);\n-      memset ((char *) total_annul_slots, 0, sizeof total_annul_slots);\n+      memset (total_delay_slots, 0, sizeof total_delay_slots);\n+      memset (total_annul_slots, 0, sizeof total_annul_slots);\n       for (insn = first; insn; insn = NEXT_INSN (insn))\n \t{\n \t  if (! INSN_DELETED_P (insn)"}, {"sha": "2aab94c525d4b1eded58234e1e253538c7878437", "filename": "gcc/resource.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -947,7 +947,7 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n \t{\n \t  /* Allocate a place to put our results and chain it into the\n \t     hash table.  */\n-\t  tinfo = (struct target_info *) xmalloc (sizeof (struct target_info));\n+\t  tinfo = xmalloc (sizeof (struct target_info));\n \t  tinfo->uid = INSN_UID (target);\n \t  tinfo->block = b;\n \t  tinfo->next\n@@ -1223,9 +1223,8 @@ init_resource_info (rtx epilogue_insn)\n \t\t\tMARK_SRC_DEST_CALL);\n \n   /* Allocate and initialize the tables used by mark_target_live_regs.  */\n-  target_hash_table = (struct target_info **)\n-    xcalloc (TARGET_HASH_PRIME, sizeof (struct target_info *));\n-  bb_ticks = (int *) xcalloc (last_basic_block, sizeof (int));\n+  target_hash_table = xcalloc (TARGET_HASH_PRIME, sizeof (struct target_info *));\n+  bb_ticks = xcalloc (last_basic_block, sizeof (int));\n }\n \f\n /* Free up the resources allocated to mark_target_live_regs ().  This"}, {"sha": "3cec45de6278f82013a8fffd037bf50853c1e908", "filename": "gcc/sbitmap.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -41,7 +41,7 @@ sbitmap_alloc (unsigned int n_elms)\n   bytes = size * sizeof (SBITMAP_ELT_TYPE);\n   amt = (sizeof (struct simple_bitmap_def)\n \t + bytes - sizeof (SBITMAP_ELT_TYPE));\n-  bmap = (sbitmap) xmalloc (amt);\n+  bmap = xmalloc (amt);\n   bmap->n_bits = n_elms;\n   bmap->size = size;\n   bmap->bytes = bytes;\n@@ -64,7 +64,7 @@ sbitmap_resize (sbitmap bmap, unsigned int n_elms, int def)\n     {\n       amt = (sizeof (struct simple_bitmap_def)\n \t    + bytes - sizeof (SBITMAP_ELT_TYPE));\n-      bmap = (sbitmap) xrealloc (bmap, amt);\n+      bmap = xrealloc (bmap, amt);\n     }\n \n   if (n_elms > bmap->n_bits)\n@@ -130,7 +130,7 @@ sbitmap_vector_alloc (unsigned int n_vecs, unsigned int n_elms)\n   }\n \n   amt = vector_bytes + (n_vecs * elm_bytes);\n-  bitmap_vector = (sbitmap *) xmalloc (amt);\n+  bitmap_vector = xmalloc (amt);\n \n   for (i = 0, offset = vector_bytes; i < n_vecs; i++, offset += elm_bytes)\n     {"}, {"sha": "1a41e9989c905947f88ad2719e6a75cdd8194983", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -1390,8 +1390,7 @@ init_deps (struct deps *deps)\n   int max_reg = (reload_completed ? FIRST_PSEUDO_REGISTER : max_reg_num ());\n \n   deps->max_reg = max_reg;\n-  deps->reg_last = (struct deps_reg *)\n-    xcalloc (max_reg, sizeof (struct deps_reg));\n+  deps->reg_last = xcalloc (max_reg, sizeof (struct deps_reg));\n   INIT_REG_SET (&deps->reg_last_in_use);\n   INIT_REG_SET (&deps->reg_conditional_sets);\n "}, {"sha": "cb5e52d48a652df4ce3cd00944d57f15ab5b810a", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -398,9 +398,9 @@ build_control_flow (struct edge_list *edge_list)\n     }\n \n   /* ??? We can kill these soon.  */\n-  in_edges = (int *) xcalloc (last_basic_block, sizeof (int));\n-  out_edges = (int *) xcalloc (last_basic_block, sizeof (int));\n-  edge_table = (haifa_edge *) xcalloc (num_edges, sizeof (haifa_edge));\n+  in_edges = xcalloc (last_basic_block, sizeof (int));\n+  out_edges = xcalloc (last_basic_block, sizeof (int));\n+  edge_table = xcalloc (num_edges, sizeof (haifa_edge));\n \n   nr_edges = 0;\n   for (i = 0; i < num_edges; i++)\n@@ -650,9 +650,9 @@ find_rgns (struct edge_list *edge_list, dominance_info dom)\n      STACK, SP and DFS_NR are only used during the first traversal.  */\n \n   /* Allocate and initialize variables for the first traversal.  */\n-  max_hdr = (int *) xmalloc (last_basic_block * sizeof (int));\n-  dfs_nr = (int *) xcalloc (last_basic_block, sizeof (int));\n-  stack = (int *) xmalloc (nr_edges * sizeof (int));\n+  max_hdr = xmalloc (last_basic_block * sizeof (int));\n+  dfs_nr = xcalloc (last_basic_block, sizeof (int));\n+  stack = xmalloc (nr_edges * sizeof (int));\n \n   inner = sbitmap_alloc (last_basic_block);\n   sbitmap_ones (inner);\n@@ -796,7 +796,7 @@ find_rgns (struct edge_list *edge_list, dominance_info dom)\n       /* Second traversal:find reducible inner loops and topologically sort\n \t block of each region.  */\n \n-      queue = (int *) xmalloc (n_basic_blocks * sizeof (int));\n+      queue = xmalloc (n_basic_blocks * sizeof (int));\n \n       /* Find blocks which are inner loop headers.  We still have non-reducible\n \t loops to consider at this point.  */\n@@ -1117,7 +1117,7 @@ compute_dom_prob_ps (int bb)\n static void\n split_edges (int bb_src, int bb_trg, edgelst *bl)\n {\n-  sbitmap src = (edgeset) sbitmap_alloc (pot_split[bb_src]->n_bits);\n+  sbitmap src = sbitmap_alloc (pot_split[bb_src]->n_bits);\n   sbitmap_copy (src, pot_split[bb_src]);\n \n   sbitmap_difference (src, src, pot_split[bb_trg]);\n@@ -1181,7 +1181,7 @@ compute_trg_info (int trg)\n \t     add the TO block to the update block list.  This list can end\n \t     up with a lot of duplicates.  We need to weed them out to avoid\n \t     overrunning the end of the bblst_table.  */\n-\t  update_blocks = (char *) alloca (last_basic_block);\n+\t  update_blocks = alloca (last_basic_block);\n \t  memset (update_blocks, 0, last_basic_block);\n \n \t  update_idx = 0;\n@@ -1734,19 +1734,18 @@ init_ready_list (struct ready_list *ready)\n   /* Prepare current target block info.  */\n   if (current_nr_blocks > 1)\n     {\n-      candidate_table = (candidate *) xmalloc (current_nr_blocks\n-\t\t\t\t\t       * sizeof (candidate));\n+      candidate_table = xmalloc (current_nr_blocks * sizeof (candidate));\n \n       bblst_last = 0;\n       /* bblst_table holds split blocks and update blocks for each block after\n \t the current one in the region.  split blocks and update blocks are\n \t the TO blocks of region edges, so there can be at most rgn_nr_edges\n \t of them.  */\n       bblst_size = (current_nr_blocks - target_bb) * rgn_nr_edges;\n-      bblst_table = (int *) xmalloc (bblst_size * sizeof (int));\n+      bblst_table = xmalloc (bblst_size * sizeof (int));\n \n       bitlst_table_last = 0;\n-      bitlst_table = (int *) xmalloc (rgn_nr_edges * sizeof (int));\n+      bitlst_table = xmalloc (rgn_nr_edges * sizeof (int));\n \n       compute_trg_info (target_bb);\n     }\n@@ -2388,7 +2387,7 @@ schedule_region (int rgn)\n   init_deps_global ();\n \n   /* Initializations for region data dependence analysis.  */\n-  bb_deps = (struct deps *) xmalloc (sizeof (struct deps) * current_nr_blocks);\n+  bb_deps = xmalloc (sizeof (struct deps) * current_nr_blocks);\n   for (bb = 0; bb < current_nr_blocks; bb++)\n     init_deps (bb_deps + bb);\n \n@@ -2423,17 +2422,17 @@ schedule_region (int rgn)\n     {\n       int i;\n \n-      prob = (float *) xmalloc ((current_nr_blocks) * sizeof (float));\n+      prob = xmalloc ((current_nr_blocks) * sizeof (float));\n \n       dom = sbitmap_vector_alloc (current_nr_blocks, current_nr_blocks);\n       sbitmap_vector_zero (dom, current_nr_blocks);\n       /* Edge to bit.  */\n       rgn_nr_edges = 0;\n-      edge_to_bit = (int *) xmalloc (nr_edges * sizeof (int));\n+      edge_to_bit = xmalloc (nr_edges * sizeof (int));\n       for (i = 1; i < nr_edges; i++)\n \tif (CONTAINING_RGN (FROM_BLOCK (i)) == rgn)\n \t  EDGE_TO_BIT (i) = rgn_nr_edges++;\n-      rgn_edges = (int *) xmalloc (rgn_nr_edges * sizeof (int));\n+      rgn_edges = xmalloc (rgn_nr_edges * sizeof (int));\n \n       rgn_nr_edges = 0;\n       for (i = 1; i < nr_edges; i++)\n@@ -2564,10 +2563,10 @@ init_regions (void)\n   int rgn;\n \n   nr_regions = 0;\n-  rgn_table = (region *) xmalloc ((n_basic_blocks) * sizeof (region));\n-  rgn_bb_table = (int *) xmalloc ((n_basic_blocks) * sizeof (int));\n-  block_to_bb = (int *) xmalloc ((last_basic_block) * sizeof (int));\n-  containing_rgn = (int *) xmalloc ((last_basic_block) * sizeof (int));\n+  rgn_table = xmalloc ((n_basic_blocks) * sizeof (region));\n+  rgn_bb_table = xmalloc ((n_basic_blocks) * sizeof (int));\n+  block_to_bb = xmalloc ((last_basic_block) * sizeof (int));\n+  containing_rgn = xmalloc ((last_basic_block) * sizeof (int));\n \n   /* Compute regions for scheduling.  */\n   if (reload_completed\n@@ -2621,7 +2620,7 @@ init_regions (void)\n   if (CHECK_DEAD_NOTES)\n     {\n       blocks = sbitmap_alloc (last_basic_block);\n-      deaths_in_region = (int *) xmalloc (sizeof (int) * nr_regions);\n+      deaths_in_region = xmalloc (sizeof (int) * nr_regions);\n       /* Remove all death notes from the subroutine.  */\n       for (rgn = 0; rgn < nr_regions; rgn++)\n \t{"}, {"sha": "55741d14c0be0673449b853feac201d95565509e", "filename": "gcc/sched-vis.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -134,7 +134,7 @@ get_visual_tbl_length (void)\n     }\n \n   /* Compute length of one field in line.  */\n-  s = (char *) alloca (INSN_LEN + 6);\n+  s = alloca (INSN_LEN + 6);\n   sprintf (s, \"  %33s\", \"uname\");\n   n1 = strlen (s);\n "}, {"sha": "5d1a3d56c2b7284d8fe4071060c135363d527d71", "filename": "gcc/sdbout.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -1452,7 +1452,7 @@ sdbout_finish (const char *main_filename ATTRIBUTE_UNUSED)\n {\n   tree decl = (*lang_hooks.decls.getdecls) ();\n   unsigned int len = list_length (decl);\n-  tree *vec = (tree *) xmalloc (sizeof (tree) * len);\n+  tree *vec = xmalloc (sizeof (tree) * len);\n   unsigned int i;\n \n   /* Process the decls in reverse order--earliest first.  Put them\n@@ -1645,7 +1645,7 @@ sdbout_start_source_file (unsigned int line ATTRIBUTE_UNUSED,\n \t\t\t  const char *filename ATTRIBUTE_UNUSED)\n {\n #ifdef MIPS_DEBUGGING_INFO\n-  struct sdb_file *n = (struct sdb_file *) xmalloc (sizeof *n);\n+  struct sdb_file *n = xmalloc (sizeof *n);\n \n   n->next = current_file;\n   n->name = filename;\n@@ -1675,7 +1675,7 @@ static void\n sdbout_init (const char *input_file_name ATTRIBUTE_UNUSED)\n {\n #ifdef MIPS_DEBUGGING_INFO\n-  current_file = (struct sdb_file *) xmalloc (sizeof *current_file);\n+  current_file = xmalloc (sizeof *current_file);\n   current_file->next = NULL;\n   current_file->name = input_file_name;\n #endif"}, {"sha": "84127daebceb42ae7ef3b7fecf09cd0243a71c4e", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -1907,7 +1907,7 @@ simplify_plus_minus (enum rtx_code code, enum machine_mode mode, rtx op0,\n   int first, negate, changed;\n   int i, j;\n \n-  memset ((char *) ops, 0, sizeof ops);\n+  memset (ops, 0, sizeof ops);\n \n   /* Set up the two operands and then expand them until nothing has been\n      changed.  If we run out of room in our array, give up; this should"}, {"sha": "7ff305a9d3d24ed6926b4027c5944f601e77bc9c", "filename": "gcc/ssa-ccp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa-ccp.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -989,7 +989,7 @@ ssa_const_prop (void)\n   edges = create_edge_list ();\n \n   /* Initialize the values array with everything as undefined.  */\n-  values = (value *) xmalloc (VARRAY_SIZE (ssa_definition) * sizeof (value));\n+  values = xmalloc (VARRAY_SIZE (ssa_definition) * sizeof (value));\n   for (i = 0; i < VARRAY_SIZE (ssa_definition); i++)\n     {\n       if (i < FIRST_PSEUDO_REGISTER)\n@@ -1008,7 +1008,7 @@ ssa_const_prop (void)\n   executable_edges = sbitmap_alloc (NUM_EDGES (edges));\n   sbitmap_zero (executable_edges);\n \n-  edge_info = (edge *) xmalloc (NUM_EDGES (edges) * sizeof (edge));\n+  edge_info = xmalloc (NUM_EDGES (edges) * sizeof (edge));\n   flow_edges = ENTRY_BLOCK_PTR->succ;\n \n   /* Add the successors of the entry block to the edge worklist.  That"}, {"sha": "c12cdbe7afb493f81113180856a948a5f0d6c636", "filename": "gcc/ssa.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -253,8 +253,7 @@ ssa_rename_from_lookup (int reg)\n   ssa_rename_from_pair *answer;\n   srfp.reg = reg;\n   srfp.original = NULL_RTX;\n-  answer = (ssa_rename_from_pair *)\n-    htab_find_with_hash (ssa_rename_from_ht, (void *) &srfp, reg);\n+  answer = htab_find_with_hash (ssa_rename_from_ht, (void *) &srfp, reg);\n   return (answer == 0 ? NULL_RTX : answer->original);\n }\n \n@@ -673,7 +672,7 @@ static void\n create_delayed_rename (struct rename_context *c, rtx *reg_loc)\n {\n   struct rename_set_data *r;\n-  r = (struct rename_set_data *) xmalloc (sizeof(*r));\n+  r = xmalloc (sizeof(*r));\n \n   if (GET_CODE (*reg_loc) != REG\n       || !CONVERT_REGISTER_TO_SSA_P (REGNO (*reg_loc)))\n@@ -1064,10 +1063,10 @@ rename_registers (int nregs, dominance_info idom)\n   VARRAY_RTX_INIT (ssa_definition, nregs * 3, \"ssa_definition\");\n   ssa_rename_from_initialize ();\n \n-  ssa_rename_to_pseudo = (rtx *) alloca (nregs * sizeof(rtx));\n-  memset ((char *) ssa_rename_to_pseudo, 0, nregs * sizeof(rtx));\n-  memset ((char *) ssa_rename_to_hard, 0,\n-\t FIRST_PSEUDO_REGISTER * NUM_MACHINE_MODES * sizeof (rtx));\n+  ssa_rename_to_pseudo = alloca (nregs * sizeof(rtx));\n+  memset (ssa_rename_to_pseudo, 0, nregs * sizeof(rtx));\n+  memset (ssa_rename_to_hard, 0,\n+\t  FIRST_PSEUDO_REGISTER * NUM_MACHINE_MODES * sizeof (rtx));\n \n   rename_block (0, idom);\n \n@@ -1313,7 +1312,7 @@ eliminate_phi (edge e, partition reg_partition)\n      present in Phi(B).  There is an edge from FIND(T0)->FIND(T1) for\n      each T0 = PHI(...,T1,...), where T1 is for the edge from block C.  */\n \n-  nodes = (rtx *) alloca (n_nodes * sizeof(rtx));\n+  nodes = alloca (n_nodes * sizeof(rtx));\n   pred = sbitmap_vector_alloc (n_nodes, n_nodes);\n   succ = sbitmap_vector_alloc (n_nodes, n_nodes);\n   sbitmap_vector_zero (pred, n_nodes);\n@@ -1362,7 +1361,7 @@ eliminate_phi (edge e, partition reg_partition)\n   visited = sbitmap_alloc (n_nodes);\n   sbitmap_zero (visited);\n \n-  tstack = stack = (int *) alloca (n_nodes * sizeof (int));\n+  tstack = stack = alloca (n_nodes * sizeof (int));\n \n   for (i = 0; i < n_nodes; ++i)\n     if (! TEST_BIT (visited, i))"}, {"sha": "7dba03013d26f0f1b5e03b45f48dc33cd0ad2f3c", "filename": "gcc/stmt.c", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -252,8 +252,7 @@ struct nesting GTY(())\n \n /* Allocate and return a new `struct nesting'.  */\n \n-#define ALLOC_NESTING() \\\n- (struct nesting *) ggc_alloc (sizeof (struct nesting))\n+#define ALLOC_NESTING() ggc_alloc (sizeof (struct nesting))\n \n /* Pop the nesting stack element by element until we pop off\n    the element which is at the top of STACK.\n@@ -434,7 +433,7 @@ using_eh_for_cleanups (void)\n void\n init_stmt_for_function (void)\n {\n-  cfun->stmt = ((struct stmt_status *)ggc_alloc (sizeof (struct stmt_status)));\n+  cfun->stmt =ggc_alloc (sizeof (struct stmt_status));\n \n   /* We are not currently within any block, conditional, loop or case.  */\n   block_stack = 0;\n@@ -588,7 +587,7 @@ expand_label (tree label)\n \n   if (stack_block_stack != 0)\n     {\n-      p = (struct label_chain *) ggc_alloc (sizeof (struct label_chain));\n+      p = ggc_alloc (sizeof (struct label_chain));\n       p->next = stack_block_stack->data.block.label_chain;\n       stack_block_stack->data.block.label_chain = p;\n       p->label = label;\n@@ -851,8 +850,7 @@ expand_fixup (tree tree_label, rtx rtl_label, rtx last_insn)\n   if (block != end_block)\n     {\n       /* Ok, a fixup is needed.  Add a fixup to the list of such.  */\n-      struct goto_fixup *fixup\n-\t= (struct goto_fixup *) ggc_alloc (sizeof (struct goto_fixup));\n+      struct goto_fixup *fixup = ggc_alloc (sizeof (struct goto_fixup));\n       /* In case an old stack level is restored, make sure that comes\n \t after any pending stack adjust.  */\n       /* ?? If the fixup isn't to come at the present position,\n@@ -1471,13 +1469,13 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n   tree t;\n   int i;\n   /* Vector of RTX's of evaluated output operands.  */\n-  rtx *output_rtx = (rtx *) alloca (noutputs * sizeof (rtx));\n-  int *inout_opnum = (int *) alloca (noutputs * sizeof (int));\n-  rtx *real_output_rtx = (rtx *) alloca (noutputs * sizeof (rtx));\n+  rtx *output_rtx = alloca (noutputs * sizeof (rtx));\n+  int *inout_opnum = alloca (noutputs * sizeof (int));\n+  rtx *real_output_rtx = alloca (noutputs * sizeof (rtx));\n   enum machine_mode *inout_mode\n-    = (enum machine_mode *) alloca (noutputs * sizeof (enum machine_mode));\n+    = alloca (noutputs * sizeof (enum machine_mode));\n   const char **constraints\n-    = (const char **) alloca ((noutputs + ninputs) * sizeof (const char *));\n+    = alloca ((noutputs + ninputs) * sizeof (const char *));\n   int old_generating_concat_p = generating_concat_p;\n \n   /* An ASM with no outputs needs to be treated as volatile, for now.  */\n@@ -3082,7 +3080,7 @@ expand_return (tree retval)\n       int n_regs = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n       unsigned int bitsize\n \t= MIN (TYPE_ALIGN (TREE_TYPE (retval_rhs)), BITS_PER_WORD);\n-      rtx *result_pseudos = (rtx *) alloca (sizeof (rtx) * n_regs);\n+      rtx *result_pseudos = alloca (sizeof (rtx) * n_regs);\n       rtx result_reg, src = NULL_RTX, dst = NULL_RTX;\n       rtx result_val = expand_expr (retval_rhs, NULL_RTX, VOIDmode, 0);\n       enum machine_mode tmpmode, result_reg_mode;\n@@ -3257,7 +3255,7 @@ tail_recursion_args (tree actuals, tree formals)\n \n   /* Compute all the actuals.  */\n \n-  argvec = (rtx *) alloca (i * sizeof (rtx));\n+  argvec = alloca (i * sizeof (rtx));\n \n   for (a = actuals, i = 0; a; a = TREE_CHAIN (a), i++)\n     argvec[i] = expand_expr (TREE_VALUE (a), NULL_RTX, VOIDmode, 0);\n@@ -4592,7 +4590,7 @@ add_case_node (tree low, tree high, tree label, tree *duplicate)\n \n   /* Add this label to the chain, and succeed.  */\n \n-  r = (struct case_node *) ggc_alloc (sizeof (struct case_node));\n+  r = ggc_alloc (sizeof (struct case_node));\n   r->low = low;\n \n   /* If the bounds are equal, turn this into the one-value case.  */\n@@ -5025,8 +5023,7 @@ check_for_full_enumeration_handling (tree type)\n       /* We deliberately use calloc here, not cmalloc, so that we can suppress\n \t this optimization if we don't have enough memory rather than\n \t aborting, as xmalloc would do.  */\n-      && (cases_seen =\n-\t  (unsigned char *) really_call_calloc (bytes_needed, 1)) != NULL)\n+      && (cases_seen = really_call_calloc (bytes_needed, 1)) != NULL)\n     {\n       HOST_WIDE_INT i;\n       tree v = TYPE_VALUES (type);\n@@ -5540,8 +5537,8 @@ expand_end_case_type (tree orig_index, tree orig_type)\n \t  /* Get table of labels to jump to, in order of case index.  */\n \n \t  ncases = tree_low_cst (range, 0) + 1;\n-\t  labelvec = (rtx *) alloca (ncases * sizeof (rtx));\n-\t  memset ((char *) labelvec, 0, ncases * sizeof (rtx));\n+\t  labelvec = alloca (ncases * sizeof (rtx));\n+\t  memset (labelvec, 0, ncases * sizeof (rtx));\n \n \t  for (n = thiscase->data.case_stmt.case_list; n; n = n->right)\n \t    {"}, {"sha": "041fe6257c9fe889aa616ac05490d977d91fd616", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -553,8 +553,7 @@ set_lang_adjust_rli (void (*f) (record_layout_info))\n record_layout_info\n start_record_layout (tree t)\n {\n-  record_layout_info rli\n-    = (record_layout_info) xmalloc (sizeof (struct record_layout_info_s));\n+  record_layout_info rli = xmalloc (sizeof (struct record_layout_info_s));\n \n   rli->t = t;\n "}, {"sha": "9746488c649ba4322cd115f17dcb8555e016ef75", "filename": "gcc/timevar.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Ftimevar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Ftimevar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -226,7 +226,7 @@ timevar_init (void)\n   timevar_enable = true;\n \n   /* Zero all elapsed times.  */\n-  memset ((void *) timevars, 0, sizeof (timevars));\n+  memset (timevars, 0, sizeof (timevars));\n \n   /* Initialize the names of timing variables.  */\n #define DEFTIMEVAR(identifier__, name__) \\\n@@ -286,8 +286,7 @@ timevar_push (timevar_id_t timevar)\n       unused_stack_instances = unused_stack_instances->next;\n     }\n   else\n-    context = (struct timevar_stack_def *)\n-      xmalloc (sizeof (struct timevar_stack_def));\n+    context = xmalloc (sizeof (struct timevar_stack_def));\n \n   /* Fill it in and put it on the stack.  */\n   context->timevar = tv;"}, {"sha": "6406615b5e3ec8a5d06caa665cf757f4fb365114", "filename": "gcc/tlink.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Ftlink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Ftlink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftlink.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -192,7 +192,7 @@ struct file_stack_entry *file_stack;\n static void\n symbol_push (symbol *p)\n {\n-  struct symbol_stack_entry *ep = (struct symbol_stack_entry *) obstack_alloc\n+  struct symbol_stack_entry *ep = obstack_alloc\n     (&symbol_stack_obstack, sizeof (struct symbol_stack_entry));\n   ep->value = p;\n   ep->next = symbol_stack;\n@@ -220,7 +220,7 @@ file_push (file *p)\n   if (p->tweaking)\n     return;\n \n-  ep = (struct file_stack_entry *) obstack_alloc\n+  ep = obstack_alloc\n     (&file_stack_obstack, sizeof (struct file_stack_entry));\n   ep->value = p;\n   ep->next = file_stack;"}, {"sha": "93fc1856714be6a02236ab33df90482388780cab", "filename": "gcc/toplev.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -1706,7 +1706,7 @@ push_srcloc (const char *file, int line)\n {\n   struct file_stack *fs;\n \n-  fs = (struct file_stack *) xmalloc (sizeof (struct file_stack));\n+  fs = xmalloc (sizeof (struct file_stack));\n   fs->location = input_location;\n   fs->next = input_file_stack;\n   input_filename = file;\n@@ -2135,7 +2135,7 @@ rest_of_handle_old_regalloc (tree decl, rtx insns, int *rebuild_notes)\n   allocate_reg_info (max_regno, FALSE, TRUE);\n \n   /* And the reg_equiv_memory_loc array.  */\n-  reg_equiv_memory_loc = (rtx *) xcalloc (max_regno, sizeof (rtx));\n+  reg_equiv_memory_loc = xcalloc (max_regno, sizeof (rtx));\n \n   allocate_initial_values (reg_equiv_memory_loc);\n \n@@ -4053,7 +4053,7 @@ init_asm_output (const char *name)\n       if (asm_file_name == 0)\n \t{\n \t  int len = strlen (dump_base_name);\n-\t  char *dumpname = (char *) xmalloc (len + 6);\n+\t  char *dumpname = xmalloc (len + 6);\n \t  memcpy (dumpname, dump_base_name, len + 1);\n \t  strip_off_ending (dumpname, len);\n \t  strcat (dumpname, \".s\");\n@@ -4068,7 +4068,7 @@ init_asm_output (const char *name)\n     }\n \n #ifdef IO_BUFFER_SIZE\n-  setvbuf (asm_out_file, (char *) xmalloc (IO_BUFFER_SIZE),\n+  setvbuf (asm_out_file, xmalloc (IO_BUFFER_SIZE),\n \t   _IOFBF, IO_BUFFER_SIZE);\n #endif\n "}, {"sha": "c3696336c4465f6e4e044ba0f916a8ffc4da79ba", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -57,10 +57,10 @@ queue (dump_info_p di, tree t, int flags)\n       di->free_list = dq->next;\n     }\n   else\n-    dq = (dump_queue_p) xmalloc (sizeof (struct dump_queue));\n+    dq = xmalloc (sizeof (struct dump_queue));\n \n   /* Create a new entry in the splay-tree.  */\n-  dni = (dump_node_info_p) xmalloc (sizeof (struct dump_node_info));\n+  dni = xmalloc (sizeof (struct dump_node_info));\n   dni->index = index;\n   dni->binfo_p = ((flags & DUMP_BINFO) != 0);\n   dq->node = splay_tree_insert (di->nodes, (splay_tree_key) t,"}, {"sha": "5590598148e1ffd60b139dbc1859aab5eb91cb2b", "filename": "gcc/tree.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -494,7 +494,7 @@ real_value_from_int_cst (tree type ATTRIBUTE_UNUSED, tree i)\n \n   /* Clear all bits of the real value type so that we can later do\n      bitwise comparisons to see if two values are the same.  */\n-  memset ((char *) &d, 0, sizeof d);\n+  memset (&d, 0, sizeof d);\n \n   if (! TREE_UNSIGNED (TREE_TYPE (i)))\n     REAL_VALUE_FROM_INT (d, TREE_INT_CST_LOW (i), TREE_INT_CST_HIGH (i),\n@@ -2985,7 +2985,7 @@ type_hash_add (unsigned int hashcode, tree type)\n   struct type_hash *h;\n   void **loc;\n \n-  h = (struct type_hash *) ggc_alloc (sizeof (struct type_hash));\n+  h = ggc_alloc (sizeof (struct type_hash));\n   h->hash = hashcode;\n   h->type = type;\n   loc = htab_find_slot_with_hash (type_hash_table, h, hashcode, INSERT);\n@@ -4517,7 +4517,7 @@ get_file_function_name_long (const char *type)\n \tfile = input_filename;\n \n       len = strlen (file);\n-      q = (char *) alloca (9 * 2 + len);\n+      q = alloca (9 * 2 + len);\n       memcpy (q, file, len + 1);\n       clean_symbol_name (q);\n \n@@ -4527,8 +4527,7 @@ get_file_function_name_long (const char *type)\n       p = q;\n     }\n \n-  buf = (char *) alloca (sizeof (FILE_FUNCTION_FORMAT) + strlen (p)\n-\t\t\t + strlen (type));\n+  buf = alloca (sizeof (FILE_FUNCTION_FORMAT) + strlen (p) + strlen (type));\n \n   /* Set up the name of the file-level functions we may need.\n      Use a global object (which is already required to be unique over\n@@ -4623,7 +4622,7 @@ get_set_constructor_bytes (tree init, unsigned char *buffer, int wd_size)\n   int bit_size = wd_size * set_word_size;\n   int bit_pos = 0;\n   unsigned char *bytep = buffer;\n-  char *bit_buffer = (char *) alloca (bit_size);\n+  char *bit_buffer = alloca (bit_size);\n   tree non_const_bits = get_set_constructor_bits (init, bit_buffer, bit_size);\n \n   for (i = 0; i < wd_size; i++)"}, {"sha": "62b8152daf46f6fc2de08342034eb41efc87abd1", "filename": "gcc/unroll.c", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -671,14 +671,14 @@ unroll_loop (struct loop *loop, int insn_count, int strength_reduce_p)\n      without initializing fields within the map structure.\n \n      To be safe, we use xcalloc to zero the memory.  */\n-  map = (struct inline_remap *) xcalloc (1, sizeof (struct inline_remap));\n+  map = xcalloc (1, sizeof (struct inline_remap));\n \n   /* Allocate the label map.  */\n \n   if (max_labelno > 0)\n     {\n-      map->label_map = (rtx *) xcalloc (max_labelno, sizeof (rtx));\n-      local_label = (char *) xcalloc (max_labelno, sizeof (char));\n+      map->label_map = xcalloc (max_labelno, sizeof (rtx));\n+      local_label = xcalloc (max_labelno, sizeof (char));\n     }\n \n   /* Search the loop and mark all local labels, i.e. the ones which have to\n@@ -722,7 +722,7 @@ unroll_loop (struct loop *loop, int insn_count, int strength_reduce_p)\n \n   /* Allocate space for the insn map.  */\n \n-  map->insn_map = (rtx *) xmalloc (max_insnno * sizeof (rtx));\n+  map->insn_map = xmalloc (max_insnno * sizeof (rtx));\n \n   /* Set this to zero, to indicate that we are doing loop unrolling,\n      not function inlining.  */\n@@ -748,11 +748,10 @@ unroll_loop (struct loop *loop, int insn_count, int strength_reduce_p)\n      preconditioning code and find_splittable_regs will never be used\n      to access the splittable_regs[] and addr_combined_regs[] arrays.  */\n \n-  splittable_regs = (rtx *) xcalloc (maxregnum, sizeof (rtx));\n-  splittable_regs_updates = (int *) xcalloc (maxregnum, sizeof (int));\n-  addr_combined_regs\n-    = (struct induction **) xcalloc (maxregnum, sizeof (struct induction *));\n-  local_regno = (char *) xcalloc (maxregnum, sizeof (char));\n+  splittable_regs = xcalloc (maxregnum, sizeof (rtx));\n+  splittable_regs_updates = xcalloc (maxregnum, sizeof (int));\n+  addr_combined_regs = xcalloc (maxregnum, sizeof (struct induction *));\n+  local_regno = xcalloc (maxregnum, sizeof (char));\n \n   /* Mark all local registers, i.e. the ones which are referenced only\n      inside the loop.  */\n@@ -854,7 +853,7 @@ unroll_loop (struct loop *loop, int insn_count, int strength_reduce_p)\n \t  int less_p     = (cc == LE  || cc == LEU || cc == LT  || cc == LTU);\n \t  int unsigned_p = (cc == LEU || cc == GEU || cc == LTU || cc == GTU);\n \n-\t  map->reg_map = (rtx *) xmalloc (maxregnum * sizeof (rtx));\n+\t  map->reg_map = xmalloc (maxregnum * sizeof (rtx));\n \n \t  VARRAY_CONST_EQUIV_INIT (map->const_equiv_varray, maxregnum,\n \t\t\t\t   \"unroll_loop_precondition\");\n@@ -921,7 +920,7 @@ unroll_loop (struct loop *loop, int insn_count, int strength_reduce_p)\n \t  /* Now emit a sequence of branches to jump to the proper precond\n \t     loop entry point.  */\n \n-\t  labels = (rtx *) xmalloc (sizeof (rtx) * unroll_number);\n+\t  labels = xmalloc (sizeof (rtx) * unroll_number);\n \t  for (i = 0; i < unroll_number; i++)\n \t    labels[i] = gen_label_rtx ();\n \n@@ -1054,8 +1053,8 @@ unroll_loop (struct loop *loop, int insn_count, int strength_reduce_p)\n \t      emit_label_after (labels[unroll_number - i],\n \t\t\t\tPREV_INSN (loop_start));\n \n-\t      memset ((char *) map->insn_map, 0, max_insnno * sizeof (rtx));\n-\t      memset ((char *) &VARRAY_CONST_EQUIV (map->const_equiv_varray, 0),\n+\t      memset (map->insn_map, 0, max_insnno * sizeof (rtx));\n+\t      memset (&VARRAY_CONST_EQUIV (map->const_equiv_varray, 0),\n \t\t      0, (VARRAY_SIZE (map->const_equiv_varray)\n \t\t\t  * sizeof (struct const_equiv_data)));\n \t      map->const_age = 0;\n@@ -1158,7 +1157,7 @@ unroll_loop (struct loop *loop, int insn_count, int strength_reduce_p)\n      the constant maps also.  */\n \n   maxregnum = max_reg_num ();\n-  map->reg_map = (rtx *) xmalloc (maxregnum * sizeof (rtx));\n+  map->reg_map = xmalloc (maxregnum * sizeof (rtx));\n \n   init_reg_map (map, maxregnum);\n \n@@ -1206,8 +1205,8 @@ unroll_loop (struct loop *loop, int insn_count, int strength_reduce_p)\n \n   for (i = 0; i < unroll_number; i++)\n     {\n-      memset ((char *) map->insn_map, 0, max_insnno * sizeof (rtx));\n-      memset ((char *) &VARRAY_CONST_EQUIV (map->const_equiv_varray, 0), 0,\n+      memset (map->insn_map, 0, max_insnno * sizeof (rtx));\n+      memset (&VARRAY_CONST_EQUIV (map->const_equiv_varray, 0), 0,\n \t      VARRAY_SIZE (map->const_equiv_varray) * sizeof (struct const_equiv_data));\n       map->const_age = 0;\n "}, {"sha": "21d86b03bc1a818cc7eaf27c2d58f7701f865415", "filename": "gcc/unwind-dw2-fde.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Funwind-dw2-fde.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Funwind-dw2-fde.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2-fde.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -115,7 +115,7 @@ __register_frame (void *begin)\n   if (*(uword *) begin == 0)\n     return;\n \n-  ob = (struct object *) malloc (sizeof (struct object));\n+  ob = malloc (sizeof (struct object));\n   __register_frame_info (begin, ob);\n }\n \n@@ -153,7 +153,7 @@ __register_frame_info_table (void *begin, struct object *ob)\n void\n __register_frame_table (void *begin)\n {\n-  struct object *ob = (struct object *) malloc (sizeof (struct object));\n+  struct object *ob = malloc (sizeof (struct object));\n   __register_frame_info_table (begin, ob);\n }\n \n@@ -395,10 +395,10 @@ start_fde_sort (struct fde_accumulator *accu, size_t count)\n     return 0;\n \n   size = sizeof (struct fde_vector) + sizeof (fde *) * count;\n-  if ((accu->linear = (struct fde_vector *) malloc (size)))\n+  if ((accu->linear = malloc (size)))\n     {\n       accu->linear->count = 0;\n-      if ((accu->erratic = (struct fde_vector *) malloc (size)))\n+      if ((accu->erratic = malloc (size)))\n \taccu->erratic->count = 0;\n       return 1;\n     }"}, {"sha": "073fcdf375401415e958323bff88c2080c8d7996", "filename": "gcc/varasm.c", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -372,7 +372,7 @@ set_named_section_flags (const char *section, unsigned int flags)\n \n   if (!entry)\n     {\n-      entry = (struct in_named_entry *) ggc_alloc (sizeof (*entry));\n+      entry = ggc_alloc (sizeof (*entry));\n       *slot = entry;\n       entry->name = ggc_strdup (section);\n       entry->flags = flags;\n@@ -2128,7 +2128,7 @@ const_hash_1 (const tree exp)\n \t  char *tmp;\n \n \t  len = int_size_in_bytes (TREE_TYPE (exp));\n-\t  tmp = (char *) alloca (len);\n+\t  tmp = alloca (len);\n \t  get_set_constructor_bytes (exp, (unsigned char *) tmp, len);\n \t  p = tmp;\n \t  break;\n@@ -2258,8 +2258,8 @@ compare_constant (const tree t1, const tree t2)\n \t  if (int_size_in_bytes (TREE_TYPE (t1)) != len)\n \t    return 0;\n \n-\t  tmp1 = (unsigned char *) alloca (len);\n-\t  tmp2 = (unsigned char *) alloca (len);\n+\t  tmp1 = alloca (len);\n+\t  tmp2 = alloca (len);\n \n \t  if (get_set_constructor_bytes (t1, tmp1, len) != NULL_TREE)\n \t    return 0;\n@@ -2634,16 +2634,14 @@ void\n init_varasm_status (struct function *f)\n {\n   struct varasm_status *p;\n-  p = (struct varasm_status *) ggc_alloc (sizeof (struct varasm_status));\n+  p = ggc_alloc (sizeof (struct varasm_status));\n   f->varasm = p;\n   p->x_const_rtx_hash_table\n-    = ((struct constant_descriptor_rtx **)\n-       ggc_alloc_cleared (MAX_RTX_HASH_TABLE\n-\t\t\t  * sizeof (struct constant_descriptor_rtx *)));\n+    = ggc_alloc_cleared (MAX_RTX_HASH_TABLE\n+\t\t\t * sizeof (struct constant_descriptor_rtx *));\n   p->x_const_rtx_sym_hash_table\n-    = ((struct pool_constant **)\n-       ggc_alloc_cleared (MAX_RTX_HASH_TABLE\n-\t\t\t  * sizeof (struct pool_constant *)));\n+    = ggc_alloc_cleared (MAX_RTX_HASH_TABLE\n+\t\t\t * sizeof (struct pool_constant *));\n \n   p->x_first_pool = p->x_last_pool = 0;\n   p->x_pool_offset = 0;\n@@ -2896,7 +2894,7 @@ record_constant_rtx (enum machine_mode mode, rtx x)\n {\n   struct constant_descriptor_rtx *ptr;\n \n-  ptr = (struct constant_descriptor_rtx *) ggc_alloc (sizeof (*ptr));\n+  ptr = ggc_alloc (sizeof (*ptr));\n   decode_rtx_const (mode, x, &ptr->value);\n \n   return ptr;\n@@ -2950,7 +2948,7 @@ force_const_mem (enum machine_mode mode, rtx x)\n     LABEL_PRESERVE_P (XEXP (x, 0)) = 1;\n \n   /* Allocate a pool constant descriptor, fill it in, and chain it in.  */\n-  pool = (struct pool_constant *) ggc_alloc (sizeof (struct pool_constant));\n+  pool = ggc_alloc (sizeof (struct pool_constant));\n   pool->desc = desc;\n   pool->constant = x;\n   pool->mode = mode;\n@@ -3767,7 +3765,7 @@ output_constant (tree exp, unsigned HOST_WIDE_INT size, unsigned int align)\n \t\t\t  thissize, align, 1);\n       else if (TREE_CODE (exp) == CONSTRUCTOR)\n \t{\n-\t  unsigned char *buffer = (unsigned char *) alloca (thissize);\n+\t  unsigned char *buffer = alloca (thissize);\n \t  if (get_set_constructor_bytes (exp, buffer, thissize))\n \t    abort ();\n \t  assemble_string ((char *) buffer, thissize);"}, {"sha": "7901471bd798034b750a85a9e42da4a91a12c724", "filename": "gcc/varray.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fvarray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fvarray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarray.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -68,9 +68,9 @@ varray_init (size_t num_elements, enum varray_data_enum element_kind,\n   size_t data_size = num_elements * element[element_kind].size;\n   varray_type ptr;\n   if (element[element_kind].uses_ggc)\n-    ptr = (varray_type) ggc_alloc_cleared (VARRAY_HDR_SIZE + data_size);\n+    ptr = ggc_alloc_cleared (VARRAY_HDR_SIZE + data_size);\n   else\n-    ptr = (varray_type) xcalloc (VARRAY_HDR_SIZE + data_size, 1);\n+    ptr = xcalloc (VARRAY_HDR_SIZE + data_size, 1);\n \n   ptr->num_elements = num_elements;\n   ptr->elements_used = 0;\n@@ -93,9 +93,9 @@ varray_grow (varray_type va, size_t n)\n       size_t data_size = n * elem_size;\n \n       if (element[va->type].uses_ggc)\n-\tva = (varray_type) ggc_realloc (va, VARRAY_HDR_SIZE + data_size);\n+\tva = ggc_realloc (va, VARRAY_HDR_SIZE + data_size);\n       else\n-\tva = (varray_type) xrealloc ((char *) va, VARRAY_HDR_SIZE + data_size);\n+\tva = xrealloc (va, VARRAY_HDR_SIZE + data_size);\n       va->num_elements = n;\n       if (n > old_elements)\n \tmemset (&va->data.c[old_data_size], 0, data_size - old_data_size);"}, {"sha": "4f7f62d2e976290f84221a8fc84123e3ed221bfa", "filename": "gcc/vmsdbgout.c", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fvmsdbgout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fvmsdbgout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsdbgout.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -1362,8 +1362,8 @@ vmsdbgout_begin_function (tree decl)\n   if (func_table_in_use == func_table_allocated)\n     {\n       func_table_allocated += FUNC_TABLE_INCREMENT;\n-      func_table = (char **) xrealloc (func_table,\n-\t\t\t\t       func_table_allocated * sizeof (char *));\n+      func_table = xrealloc (func_table,\n+\t\t\t     func_table_allocated * sizeof (char *));\n     }\n \n   /* Add the new entry to the end of the function name table.  */\n@@ -1481,10 +1481,9 @@ lookup_filename (const char *file_name)\n     {\n \n       file_info_table_allocated += FILE_TABLE_INCREMENT;\n-      file_info_table\n-\t= (dst_file_info_ref) xrealloc (file_info_table,\n-\t\t\t\t\t(file_info_table_allocated\n-\t\t\t\t\t * sizeof (dst_file_info_entry)));\n+      file_info_table = xrealloc (file_info_table,\n+\t\t\t\t  (file_info_table_allocated\n+\t\t\t\t   * sizeof (dst_file_info_entry)));\n     }\n \n   /* Add the new entry to the end of the filename table.  */\n@@ -1521,10 +1520,9 @@ vmsdbgout_source_line (register unsigned line, register const char *filename)\n       if (line_info_table_in_use == line_info_table_allocated)\n \t{\n \t  line_info_table_allocated += LINE_INFO_TABLE_INCREMENT;\n-\t  line_info_table\n-\t    = (dst_line_info_ref) xrealloc (line_info_table,\n-\t\t\t\t\t    (line_info_table_allocated\n-\t\t\t\t\t     * sizeof (dst_line_info_entry)));\n+\t  line_info_table = xrealloc (line_info_table,\n+\t\t\t\t      (line_info_table_allocated\n+\t\t\t\t       * sizeof (dst_line_info_entry)));\n \t}\n \n       /* Add the new entry at the end of the line_info_table.  */\n@@ -1574,21 +1572,19 @@ vmsdbgout_init (const char *main_input_filename)\n \n   /* Allocate the initial hunk of the file_info_table.  */\n   file_info_table\n-    = (dst_file_info_ref) xcalloc (FILE_TABLE_INCREMENT,\n-\t\t\t\t   sizeof (dst_file_info_entry));\n+    = xcalloc (FILE_TABLE_INCREMENT, sizeof (dst_file_info_entry));\n   file_info_table_allocated = FILE_TABLE_INCREMENT;\n \n   /* Skip the first entry - file numbers begin at 1 */\n   file_info_table_in_use = 1;\n \n-  func_table = (char **) xcalloc (FUNC_TABLE_INCREMENT, sizeof (char *));\n+  func_table = xcalloc (FUNC_TABLE_INCREMENT, sizeof (char *));\n   func_table_allocated = FUNC_TABLE_INCREMENT;\n   func_table_in_use = 1;\n \n   /* Allocate the initial hunk of the line_info_table.  */\n   line_info_table\n-    = (dst_line_info_ref) xcalloc (LINE_INFO_TABLE_INCREMENT,\n-\t\t\t\t   sizeof (dst_line_info_entry));\n+    = xcalloc (LINE_INFO_TABLE_INCREMENT, sizeof (dst_line_info_entry));\n   line_info_table_allocated = LINE_INFO_TABLE_INCREMENT;\n   /* zero-th entry is allocated, but unused */\n   line_info_table_in_use = 1;"}, {"sha": "7c03ca5b096cc3f5d97ce2a4d6c68fcb35eba24d", "filename": "gcc/xcoffout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fxcoffout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/703ad42b4be14b9b1e84816dede360721361ed86/gcc%2Fxcoffout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fxcoffout.c?ref=703ad42b4be14b9b1e84816dede360721361ed86", "patch": "@@ -400,7 +400,7 @@ xcoffout_declare_function (FILE *file, tree decl, const char *name)\n       {\n \tif (name[i] == '[')\n \t  {\n-\t    char *n = (char *) alloca (i + 1);\n+\t    char *n = alloca (i + 1);\n \t    strncpy (n, name, i);\n \t    n[i] = '\\0';\n \t    name = n;"}]}