{"sha": "6b5eea611c9ac83a9b377c93bff7748edf1efdab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI1ZWVhNjExYzlhYzgzYTliMzc3YzkzYmZmNzc0OGVkZjFlZmRhYg==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.vnet.ibm.com", "date": "2012-08-15T13:27:29Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2012-08-15T13:27:29Z"}, "message": "re PR tree-optimization/54245 (incorrect optimisation)\n\ngcc:\n\n2012-08-15  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\tPR tree-optimization/54245\n\t* gimple-ssa-strength-reduction.c (legal_cast_p_1): New function.\n\t(legal_cast_p): Split out logic to legal_cast_p_1.\n\t(analyze_increments): Avoid introducing multiplies in smaller types.\n\n\ngcc/testsuite:\n\n2012-08-15  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\tPR tree-optimization/54245\n\t* gcc.dg/tree-ssa/pr54245.c: New test.\n\nFrom-SVN: r190412", "tree": {"sha": "8b8d8e8da91d64da19cc0ebabb571e0a4df27739", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b8d8e8da91d64da19cc0ebabb571e0a4df27739"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b5eea611c9ac83a9b377c93bff7748edf1efdab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b5eea611c9ac83a9b377c93bff7748edf1efdab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b5eea611c9ac83a9b377c93bff7748edf1efdab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b5eea611c9ac83a9b377c93bff7748edf1efdab/comments", "author": {"login": "wschmidt-ibm", "id": 5520937, "node_id": "MDQ6VXNlcjU1MjA5Mzc=", "avatar_url": "https://avatars.githubusercontent.com/u/5520937?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wschmidt-ibm", "html_url": "https://github.com/wschmidt-ibm", "followers_url": "https://api.github.com/users/wschmidt-ibm/followers", "following_url": "https://api.github.com/users/wschmidt-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/wschmidt-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/wschmidt-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wschmidt-ibm/subscriptions", "organizations_url": "https://api.github.com/users/wschmidt-ibm/orgs", "repos_url": "https://api.github.com/users/wschmidt-ibm/repos", "events_url": "https://api.github.com/users/wschmidt-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/wschmidt-ibm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0a5f2683732f0fc6edd1367295e8a218300d01c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a5f2683732f0fc6edd1367295e8a218300d01c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a5f2683732f0fc6edd1367295e8a218300d01c9"}], "stats": {"total": 131, "additions": 113, "deletions": 18}, "files": [{"sha": "8ca696614427cc91ce744964857731537bc39527", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5eea611c9ac83a9b377c93bff7748edf1efdab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5eea611c9ac83a9b377c93bff7748edf1efdab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6b5eea611c9ac83a9b377c93bff7748edf1efdab", "patch": "@@ -1,3 +1,10 @@\n+2012-08-15  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\tPR tree-optimization/54245\n+\t* gimple-ssa-strength-reduction.c (legal_cast_p_1): New function.\n+\t(legal_cast_p): Split out logic to legal_cast_p_1.\n+\t(analyze_increments): Avoid introducing multiplies in smaller types.\n+\n 2012-08-15  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \tPR tree-optimization/54240"}, {"sha": "8806f48a5a0439baeafd8dfe5df1067c7f52e347", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 52, "deletions": 18, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5eea611c9ac83a9b377c93bff7748edf1efdab/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5eea611c9ac83a9b377c93bff7748edf1efdab/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=6b5eea611c9ac83a9b377c93bff7748edf1efdab", "patch": "@@ -1089,6 +1089,32 @@ slsr_process_neg (gimple gs, tree rhs1, bool speed)\n   add_cand_for_stmt (gs, c);\n }\n \n+/* Help function for legal_cast_p, operating on two trees.  Checks\n+   whether it's allowable to cast from RHS to LHS.  See legal_cast_p\n+   for more details.  */\n+\n+static bool\n+legal_cast_p_1 (tree lhs, tree rhs)\n+{\n+  tree lhs_type, rhs_type;\n+  unsigned lhs_size, rhs_size;\n+  bool lhs_wraps, rhs_wraps;\n+\n+  lhs_type = TREE_TYPE (lhs);\n+  rhs_type = TREE_TYPE (rhs);\n+  lhs_size = TYPE_PRECISION (lhs_type);\n+  rhs_size = TYPE_PRECISION (rhs_type);\n+  lhs_wraps = TYPE_OVERFLOW_WRAPS (lhs_type);\n+  rhs_wraps = TYPE_OVERFLOW_WRAPS (rhs_type);\n+\n+  if (lhs_size < rhs_size\n+      || (rhs_wraps && !lhs_wraps)\n+      || (rhs_wraps && lhs_wraps && rhs_size != lhs_size))\n+    return false;\n+\n+  return true;\n+}\n+\n /* Return TRUE if GS is a statement that defines an SSA name from\n    a conversion and is legal for us to combine with an add and multiply\n    in the candidate table.  For example, suppose we have:\n@@ -1129,28 +1155,11 @@ slsr_process_neg (gimple gs, tree rhs1, bool speed)\n static bool\n legal_cast_p (gimple gs, tree rhs)\n {\n-  tree lhs, lhs_type, rhs_type;\n-  unsigned lhs_size, rhs_size;\n-  bool lhs_wraps, rhs_wraps;\n-\n   if (!is_gimple_assign (gs)\n       || !CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (gs)))\n     return false;\n \n-  lhs = gimple_assign_lhs (gs);\n-  lhs_type = TREE_TYPE (lhs);\n-  rhs_type = TREE_TYPE (rhs);\n-  lhs_size = TYPE_PRECISION (lhs_type);\n-  rhs_size = TYPE_PRECISION (rhs_type);\n-  lhs_wraps = TYPE_OVERFLOW_WRAPS (lhs_type);\n-  rhs_wraps = TYPE_OVERFLOW_WRAPS (rhs_type);\n-\n-  if (lhs_size < rhs_size\n-      || (rhs_wraps && !lhs_wraps)\n-      || (rhs_wraps && lhs_wraps && rhs_size != lhs_size))\n-    return false;\n-\n-  return true;\n+  return legal_cast_p_1 (gimple_assign_lhs (gs), rhs);\n }\n \n /* Given GS which is a cast to a scalar integer type, determine whether\n@@ -1996,6 +2005,31 @@ analyze_increments (slsr_cand_t first_dep, enum machine_mode mode, bool speed)\n \t\t       != POINTER_PLUS_EXPR)))\n \tincr_vec[i].cost = COST_NEUTRAL;\n       \n+      /* FORNOW: If we need to add an initializer, give up if a cast from\n+\t the candidate's type to its stride's type can lose precision.\n+\t This could eventually be handled better by expressly retaining the\n+\t result of a cast to a wider type in the stride.  Example:\n+\n+           short int _1;\n+\t   _2 = (int) _1;\n+\t   _3 = _2 * 10;\n+\t   _4 = x + _3;    ADD: x + (10 * _1) : int\n+\t   _5 = _2 * 15;\n+\t   _6 = x + _3;    ADD: x + (15 * _1) : int\n+\n+         Right now replacing _6 would cause insertion of an initializer\n+\t of the form \"short int T = _1 * 5;\" followed by a cast to \n+\t int, which could overflow incorrectly.  Had we recorded _2 or\n+\t (int)_1 as the stride, this wouldn't happen.  However, doing\n+         this breaks other opportunities, so this will require some\n+\t care.  */\n+      else if (!incr_vec[i].initializer\n+\t       && TREE_CODE (first_dep->stride) != INTEGER_CST\n+\t       && !legal_cast_p_1 (first_dep->stride,\n+\t\t\t\t   gimple_assign_lhs (first_dep->cand_stmt)))\n+\n+\tincr_vec[i].cost = COST_INFINITE;\n+\n       /* For any other increment, if this is a multiply candidate, we\n \t must introduce a temporary T and initialize it with\n \t T_0 = stride * increment.  When optimizing for speed, walk the"}, {"sha": "6af76ee9e965e753806d781d986e150f0d277b8d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5eea611c9ac83a9b377c93bff7748edf1efdab/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5eea611c9ac83a9b377c93bff7748edf1efdab/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6b5eea611c9ac83a9b377c93bff7748edf1efdab", "patch": "@@ -1,3 +1,8 @@\n+2012-08-15  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\tPR tree-optimization/54245\n+\t* gcc.dg/tree-ssa/pr54245.c: New test.\n+\n 2012-08-15  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \tPR tree-optimization/54240"}, {"sha": "0e11d06ed85f36cb3a7ff38da1ca5e245f67a727", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr54245.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5eea611c9ac83a9b377c93bff7748edf1efdab/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr54245.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5eea611c9ac83a9b377c93bff7748edf1efdab/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr54245.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr54245.c?ref=6b5eea611c9ac83a9b377c93bff7748edf1efdab", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-tree-slsr-details\" } */\n+\n+#include <stdio.h>\n+\n+#define W1  22725\n+#define W2  21407\n+#define W3  19266\n+#define W6  8867\n+\n+void idct_row(short *row, int *dst)\n+{\n+    int a0, a1, b0, b1;\n+\n+    a0 = W1 * row[0];\n+    a1 = a0;\n+\n+    a0 += W2 * row[2];\n+    a1 += W6 * row[2];\n+\n+    b0 = W1 * row[1];\n+    b1 = W3 * row[1];\n+\n+    dst[0] = a0 + b0;\n+    dst[1] = a0 - b0;\n+    dst[2] = a1 + b1;\n+    dst[3] = a1 - b1;\n+}\n+\n+static short block[8] = { 1, 2, 3, 4 };\n+\n+int main(void)\n+{\n+    int out[4];\n+    int i;\n+\n+    idct_row(block, out);\n+\n+    for (i = 0; i < 4; i++)\n+        printf(\"%d\\n\", out[i]);\n+\n+    return !(out[2] == 87858 && out[3] == 10794);\n+}\n+\n+/* For now, disable inserting an initializer when the multiplication will\n+   take place in a smaller type than originally.  This test may be deleted\n+   in future when this case is handled more precisely.  */\n+/* { dg-final { scan-tree-dump-times \"Inserting initializer\" 0 \"slsr\" } } */\n+/* { dg-final { cleanup-tree-dump \"slsr\" } } */"}]}