{"sha": "972fcc764a94eedb83aa9c15d6ba43a32e64a198", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTcyZmNjNzY0YTk0ZWVkYjgzYWE5YzE1ZDZiYTQzYTMyZTY0YTE5OA==", "commit": {"author": {"name": "Stuart Hastings", "email": "stuart@apple.com", "date": "2005-06-29T16:14:17Z"}, "committer": {"name": "Stuart Hastings", "email": "stuart@gcc.gnu.org", "date": "2005-06-29T16:14:17Z"}, "message": "mmintrin.h: Mark vector intrinsics always_inline.\n\n2005-06-29  Stuart Hastings  <stuart@apple.com>\n\n        * gcc/config/i386/mmintrin.h: Mark vector intrinsics always_inline.\n        * gcc/config/i386/emmintrin.h: Likewise.\n        * gcc/config/i386/pmmintrin.h: Likewise.\n        * gcc/config/i386/xmmintrin.h: Likewise.\n\nFrom-SVN: r101425", "tree": {"sha": "af929de776b2945487ddfa474a86a2f72239a529", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af929de776b2945487ddfa474a86a2f72239a529"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/972fcc764a94eedb83aa9c15d6ba43a32e64a198", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/972fcc764a94eedb83aa9c15d6ba43a32e64a198", "html_url": "https://github.com/Rust-GCC/gccrs/commit/972fcc764a94eedb83aa9c15d6ba43a32e64a198", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/972fcc764a94eedb83aa9c15d6ba43a32e64a198/comments", "author": null, "committer": null, "parents": [{"sha": "e972ccce2c4a4c66fa8541f69f3e8e60fd273ada", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e972ccce2c4a4c66fa8541f69f3e8e60fd273ada", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e972ccce2c4a4c66fa8541f69f3e8e60fd273ada"}], "stats": {"total": 995, "additions": 501, "deletions": 494}, "files": [{"sha": "c1517d2e500a1d79cb5061080c21b2a460aa0e48", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972fcc764a94eedb83aa9c15d6ba43a32e64a198/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972fcc764a94eedb83aa9c15d6ba43a32e64a198/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=972fcc764a94eedb83aa9c15d6ba43a32e64a198", "patch": "@@ -1,3 +1,10 @@\n+2005-06-29  Stuart Hastings  <stuart@apple.com>\n+\n+\t* gcc/config/i386/mmintrin.h: Mark vector intrinsics always_inline.\n+\t* gcc/config/i386/emmintrin.h: Likewise.\n+\t* gcc/config/i386/pmmintrin.h: Likewise.\n+\t* gcc/config/i386/xmmintrin.h: Likewise.\n+\t\t\t\t\t\n 2005-06-29  Steve Ellcey  <sje@cup.hp.com>\n \n \tPR middle-end/21969"}, {"sha": "9ee58b6b9b39a26991a13b06353522ae02533b42", "filename": "gcc/config/i386/emmintrin.h", "status": "modified", "additions": 210, "deletions": 210, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972fcc764a94eedb83aa9c15d6ba43a32e64a198/gcc%2Fconfig%2Fi386%2Femmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972fcc764a94eedb83aa9c15d6ba43a32e64a198/gcc%2Fconfig%2Fi386%2Femmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Femmintrin.h?ref=972fcc764a94eedb83aa9c15d6ba43a32e64a198", "patch": "@@ -48,365 +48,365 @@ typedef __v2df __m128d;\n  (((fp1) << 1) | (fp0))\n \n /* Create a vector with element 0 as F and the rest zero.  */\n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_set_sd (double __F)\n {\n   return __extension__ (__m128d){ __F, 0 };\n }\n \n /* Create a vector with both elements equal to F.  */\n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_set1_pd (double __F)\n {\n   return __extension__ (__m128d){ __F, __F };\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_set_pd1 (double __F)\n {\n   return _mm_set1_pd (__F);\n }\n \n /* Create a vector with the lower value X and upper value W.  */\n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_set_pd (double __W, double __X)\n {\n   return __extension__ (__m128d){ __X, __W };\n }\n \n /* Create a vector with the lower value W and upper value X.  */\n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_setr_pd (double __W, double __X)\n {\n   return __extension__ (__m128d){ __W, __X };\n }\n \n /* Create a vector of zeros.  */\n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_setzero_pd (void)\n {\n   return __extension__ (__m128d){ 0.0, 0.0 };\n }\n \n /* Sets the low DPFP value of A from the low value of B.  */\n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_move_sd (__m128d __A, __m128d __B)\n {\n   return (__m128d) __builtin_ia32_movsd ((__v2df)__A, (__v2df)__B);\n }\n \n /* Load two DPFP values from P.  The address must be 16-byte aligned.  */\n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_load_pd (double const *__P)\n {\n   return *(__m128d *)__P;\n }\n \n /* Load two DPFP values from P.  The address need not be 16-byte aligned.  */\n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_loadu_pd (double const *__P)\n {\n   return __builtin_ia32_loadupd (__P);\n }\n \n /* Create a vector with all two elements equal to *P.  */\n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_load1_pd (double const *__P)\n {\n   return _mm_set1_pd (*__P);\n }\n \n /* Create a vector with element 0 as *P and the rest zero.  */\n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_load_sd (double const *__P)\n {\n   return _mm_set_sd (*__P);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_load_pd1 (double const *__P)\n {\n   return _mm_load1_pd (__P);\n }\n \n /* Load two DPFP values in reverse order.  The address must be aligned.  */\n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_loadr_pd (double const *__P)\n {\n   __m128d __tmp = _mm_load_pd (__P);\n   return __builtin_ia32_shufpd (__tmp, __tmp, _MM_SHUFFLE2 (0,1));\n }\n \n /* Store two DPFP values.  The address must be 16-byte aligned.  */\n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_store_pd (double *__P, __m128d __A)\n {\n   *(__m128d *)__P = __A;\n }\n \n /* Store two DPFP values.  The address need not be 16-byte aligned.  */\n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_storeu_pd (double *__P, __m128d __A)\n {\n   __builtin_ia32_storeupd (__P, __A);\n }\n \n /* Stores the lower DPFP value.  */\n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_store_sd (double *__P, __m128d __A)\n {\n   *__P = __builtin_ia32_vec_ext_v2df (__A, 0);\n }\n \n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_storel_pd (double *__P, __m128d __A)\n {\n   _mm_store_sd (__P, __A);\n }\n \n /* Stores the upper DPFP value.  */\n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_storeh_pd (double *__P, __m128d __A)\n {\n   *__P = __builtin_ia32_vec_ext_v2df (__A, 1);\n }\n \n /* Store the lower DPFP value across two words.\n    The address must be 16-byte aligned.  */\n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_store1_pd (double *__P, __m128d __A)\n {\n   _mm_store_pd (__P, __builtin_ia32_shufpd (__A, __A, _MM_SHUFFLE2 (0,0)));\n }\n \n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_store_pd1 (double *__P, __m128d __A)\n {\n   _mm_store1_pd (__P, __A);\n }\n \n /* Store two DPFP values in reverse order.  The address must be aligned.  */\n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_storer_pd (double *__P, __m128d __A)\n {\n   _mm_store_pd (__P, __builtin_ia32_shufpd (__A, __A, _MM_SHUFFLE2 (0,1)));\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_cvtsi128_si32 (__m128i __A)\n {\n   return __builtin_ia32_vec_ext_v4si ((__v4si)__A, 0);\n }\n \n #ifdef __x86_64__\n-static __inline long long\n+static __inline long long __attribute__((__always_inline__))\n _mm_cvtsi128_si64x (__m128i __A)\n {\n   return __builtin_ia32_vec_ext_v2di ((__v2di)__A, 0);\n }\n #endif\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_add_pd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_addpd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_add_sd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_addsd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_sub_pd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_subpd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_sub_sd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_subsd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_mul_pd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_mulpd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_mul_sd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_mulsd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_div_pd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_divpd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_div_sd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_divsd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_sqrt_pd (__m128d __A)\n {\n   return (__m128d)__builtin_ia32_sqrtpd ((__v2df)__A);\n }\n \n /* Return pair {sqrt (A[0), B[1]}.  */\n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_sqrt_sd (__m128d __A, __m128d __B)\n {\n   __v2df __tmp = __builtin_ia32_movsd ((__v2df)__A, (__v2df)__B);\n   return (__m128d)__builtin_ia32_sqrtsd ((__v2df)__tmp);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_min_pd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_minpd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_min_sd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_minsd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_max_pd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_maxpd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_max_sd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_maxsd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_and_pd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_andpd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_andnot_pd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_andnpd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_or_pd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_orpd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_xor_pd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_xorpd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cmpeq_pd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_cmpeqpd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cmplt_pd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_cmpltpd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cmple_pd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_cmplepd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cmpgt_pd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_cmpgtpd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cmpge_pd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_cmpgepd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cmpneq_pd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_cmpneqpd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cmpnlt_pd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_cmpnltpd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cmpnle_pd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_cmpnlepd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cmpngt_pd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_cmpngtpd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cmpnge_pd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_cmpngepd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cmpord_pd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_cmpordpd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cmpunord_pd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_cmpunordpd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cmpeq_sd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_cmpeqsd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cmplt_sd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_cmpltsd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cmple_sd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_cmplesd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cmpgt_sd (__m128d __A, __m128d __B)\n {\n   return (__m128d) __builtin_ia32_movsd ((__v2df) __A,\n@@ -416,7 +416,7 @@ _mm_cmpgt_sd (__m128d __A, __m128d __B)\n \t\t\t\t\t\t\t\t __A));\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cmpge_sd (__m128d __A, __m128d __B)\n {\n   return (__m128d) __builtin_ia32_movsd ((__v2df) __A,\n@@ -426,25 +426,25 @@ _mm_cmpge_sd (__m128d __A, __m128d __B)\n \t\t\t\t\t\t\t\t __A));\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cmpneq_sd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_cmpneqsd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cmpnlt_sd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_cmpnltsd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cmpnle_sd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_cmpnlesd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cmpngt_sd (__m128d __A, __m128d __B)\n {\n   return (__m128d) __builtin_ia32_movsd ((__v2df) __A,\n@@ -454,7 +454,7 @@ _mm_cmpngt_sd (__m128d __A, __m128d __B)\n \t\t\t\t\t\t\t\t  __A));\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cmpnge_sd (__m128d __A, __m128d __B)\n {\n   return (__m128d) __builtin_ia32_movsd ((__v2df) __A,\n@@ -464,119 +464,119 @@ _mm_cmpnge_sd (__m128d __A, __m128d __B)\n \t\t\t\t\t\t\t\t  __A));\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cmpord_sd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_cmpordsd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cmpunord_sd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_cmpunordsd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_comieq_sd (__m128d __A, __m128d __B)\n {\n   return __builtin_ia32_comisdeq ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_comilt_sd (__m128d __A, __m128d __B)\n {\n   return __builtin_ia32_comisdlt ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_comile_sd (__m128d __A, __m128d __B)\n {\n   return __builtin_ia32_comisdle ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_comigt_sd (__m128d __A, __m128d __B)\n {\n   return __builtin_ia32_comisdgt ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_comige_sd (__m128d __A, __m128d __B)\n {\n   return __builtin_ia32_comisdge ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_comineq_sd (__m128d __A, __m128d __B)\n {\n   return __builtin_ia32_comisdneq ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_ucomieq_sd (__m128d __A, __m128d __B)\n {\n   return __builtin_ia32_ucomisdeq ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_ucomilt_sd (__m128d __A, __m128d __B)\n {\n   return __builtin_ia32_ucomisdlt ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_ucomile_sd (__m128d __A, __m128d __B)\n {\n   return __builtin_ia32_ucomisdle ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_ucomigt_sd (__m128d __A, __m128d __B)\n {\n   return __builtin_ia32_ucomisdgt ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_ucomige_sd (__m128d __A, __m128d __B)\n {\n   return __builtin_ia32_ucomisdge ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_ucomineq_sd (__m128d __A, __m128d __B)\n {\n   return __builtin_ia32_ucomisdneq ((__v2df)__A, (__v2df)__B);\n }\n \n /* Create a vector of Qi, where i is the element number.  */\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_set_epi64x (long long __q1, long long __q0)\n {\n   return __extension__ (__m128i)(__v2di){ __q0, __q1 };\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_set_epi64 (__m64 __q1,  __m64 __q0)\n {\n   return _mm_set_epi64x ((long long)__q1, (long long)__q0);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_set_epi32 (int __q3, int __q2, int __q1, int __q0)\n {\n   return __extension__ (__m128i)(__v4si){ __q0, __q1, __q2, __q3 };\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_set_epi16 (short __q7, short __q6, short __q5, short __q4,\n \t       short __q3, short __q2, short __q1, short __q0)\n {\n   return __extension__ (__m128i)(__v8hi){\n     __q0, __q1, __q2, __q3, __q4, __q5, __q6, __q7 };\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_set_epi8 (char __q15, char __q14, char __q13, char __q12,\n \t      char __q11, char __q10, char __q09, char __q08,\n \t      char __q07, char __q06, char __q05, char __q04,\n@@ -590,31 +590,31 @@ _mm_set_epi8 (char __q15, char __q14, char __q13, char __q12,\n \n /* Set all of the elements of the vector to A.  */\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_set1_epi64x (long long __A)\n {\n   return _mm_set_epi64x (__A, __A);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_set1_epi64 (__m64 __A)\n {\n   return _mm_set_epi64 (__A, __A);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_set1_epi32 (int __A)\n {\n   return _mm_set_epi32 (__A, __A, __A, __A);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_set1_epi16 (short __A)\n {\n   return _mm_set_epi16 (__A, __A, __A, __A, __A, __A, __A, __A);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_set1_epi8 (char __A)\n {\n   return _mm_set_epi8 (__A, __A, __A, __A, __A, __A, __A, __A,\n@@ -624,26 +624,26 @@ _mm_set1_epi8 (char __A)\n /* Create a vector of Qi, where i is the element number.\n    The parameter order is reversed from the _mm_set_epi* functions.  */\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_setr_epi64 (__m64 __q0, __m64 __q1)\n {\n   return _mm_set_epi64 (__q1, __q0);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_setr_epi32 (int __q0, int __q1, int __q2, int __q3)\n {\n   return _mm_set_epi32 (__q3, __q2, __q1, __q0);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_setr_epi16 (short __q0, short __q1, short __q2, short __q3,\n \t        short __q4, short __q5, short __q6, short __q7)\n {\n   return _mm_set_epi16 (__q7, __q6, __q5, __q4, __q3, __q2, __q1, __q0);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_setr_epi8 (char __q00, char __q01, char __q02, char __q03,\n \t       char __q04, char __q05, char __q06, char __q07,\n \t       char __q08, char __q09, char __q10, char __q11,\n@@ -655,436 +655,436 @@ _mm_setr_epi8 (char __q00, char __q01, char __q02, char __q03,\n \n /* Create a vector with element 0 as *P and the rest zero.  */\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_load_si128 (__m128i const *__P)\n {\n   return *__P;\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_loadu_si128 (__m128i const *__P)\n {\n   return (__m128i) __builtin_ia32_loaddqu ((char const *)__P);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_loadl_epi64 (__m128i const *__P)\n {\n   return _mm_set_epi64 ((__m64)0LL, *(__m64 *)__P);\n }\n \n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_store_si128 (__m128i *__P, __m128i __B)\n {\n   *__P = __B;\n }\n \n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_storeu_si128 (__m128i *__P, __m128i __B)\n {\n   __builtin_ia32_storedqu ((char *)__P, (__v16qi)__B);\n }\n \n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_storel_epi64 (__m128i *__P, __m128i __B)\n {\n   *(long long *)__P = __builtin_ia32_vec_ext_v2di ((__v2di)__B, 0);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_movepi64_pi64 (__m128i __B)\n {\n   return (__m64) __builtin_ia32_vec_ext_v2di ((__v2di)__B, 0);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_movpi64_epi64 (__m64 __A)\n {\n   return _mm_set_epi64 ((__m64)0LL, __A);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_move_epi64 (__m128i __A)\n {\n   return _mm_set_epi64 ((__m64)0LL, _mm_movepi64_pi64 (__A));\n }\n \n /* Create a vector of zeros.  */\n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_setzero_si128 (void)\n {\n   return __extension__ (__m128i)(__v4si){ 0, 0, 0, 0 };\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cvtepi32_pd (__m128i __A)\n {\n   return (__m128d)__builtin_ia32_cvtdq2pd ((__v4si) __A);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cvtepi32_ps (__m128i __A)\n {\n   return (__m128)__builtin_ia32_cvtdq2ps ((__v4si) __A);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_cvtpd_epi32 (__m128d __A)\n {\n   return (__m128i)__builtin_ia32_cvtpd2dq ((__v2df) __A);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_cvtpd_pi32 (__m128d __A)\n {\n   return (__m64)__builtin_ia32_cvtpd2pi ((__v2df) __A);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cvtpd_ps (__m128d __A)\n {\n   return (__m128)__builtin_ia32_cvtpd2ps ((__v2df) __A);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_cvttpd_epi32 (__m128d __A)\n {\n   return (__m128i)__builtin_ia32_cvttpd2dq ((__v2df) __A);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_cvttpd_pi32 (__m128d __A)\n {\n   return (__m64)__builtin_ia32_cvttpd2pi ((__v2df) __A);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cvtpi32_pd (__m64 __A)\n {\n   return (__m128d)__builtin_ia32_cvtpi2pd ((__v2si) __A);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_cvtps_epi32 (__m128 __A)\n {\n   return (__m128i)__builtin_ia32_cvtps2dq ((__v4sf) __A);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_cvttps_epi32 (__m128 __A)\n {\n   return (__m128i)__builtin_ia32_cvttps2dq ((__v4sf) __A);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cvtps_pd (__m128 __A)\n {\n   return (__m128d)__builtin_ia32_cvtps2pd ((__v4sf) __A);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_cvtsd_si32 (__m128d __A)\n {\n   return __builtin_ia32_cvtsd2si ((__v2df) __A);\n }\n \n #ifdef __x86_64__\n-static __inline long long\n+static __inline long long __attribute__((__always_inline__))\n _mm_cvtsd_si64x (__m128d __A)\n {\n   return __builtin_ia32_cvtsd2si64 ((__v2df) __A);\n }\n #endif\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_cvttsd_si32 (__m128d __A)\n {\n   return __builtin_ia32_cvttsd2si ((__v2df) __A);\n }\n \n #ifdef __x86_64__\n-static __inline long long\n+static __inline long long __attribute__((__always_inline__))\n _mm_cvttsd_si64x (__m128d __A)\n {\n   return __builtin_ia32_cvttsd2si64 ((__v2df) __A);\n }\n #endif\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cvtsd_ss (__m128 __A, __m128d __B)\n {\n   return (__m128)__builtin_ia32_cvtsd2ss ((__v4sf) __A, (__v2df) __B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cvtsi32_sd (__m128d __A, int __B)\n {\n   return (__m128d)__builtin_ia32_cvtsi2sd ((__v2df) __A, __B);\n }\n \n #ifdef __x86_64__\n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cvtsi64x_sd (__m128d __A, long long __B)\n {\n   return (__m128d)__builtin_ia32_cvtsi642sd ((__v2df) __A, __B);\n }\n #endif\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_cvtss_sd (__m128d __A, __m128 __B)\n {\n   return (__m128d)__builtin_ia32_cvtss2sd ((__v2df) __A, (__v4sf)__B);\n }\n \n #define _mm_shuffle_pd(__A, __B, __C) ((__m128d)__builtin_ia32_shufpd ((__v2df)__A, (__v2df)__B, (__C)))\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_unpackhi_pd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_unpckhpd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_unpacklo_pd (__m128d __A, __m128d __B)\n {\n   return (__m128d)__builtin_ia32_unpcklpd ((__v2df)__A, (__v2df)__B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_loadh_pd (__m128d __A, double const *__B)\n {\n   return (__m128d)__builtin_ia32_loadhpd ((__v2df)__A, __B);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_loadl_pd (__m128d __A, double const *__B)\n {\n   return (__m128d)__builtin_ia32_loadlpd ((__v2df)__A, __B);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_movemask_pd (__m128d __A)\n {\n   return __builtin_ia32_movmskpd ((__v2df)__A);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_packs_epi16 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_packsswb128 ((__v8hi)__A, (__v8hi)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_packs_epi32 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_packssdw128 ((__v4si)__A, (__v4si)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_packus_epi16 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_packuswb128 ((__v8hi)__A, (__v8hi)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_unpackhi_epi8 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_punpckhbw128 ((__v16qi)__A, (__v16qi)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_unpackhi_epi16 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_punpckhwd128 ((__v8hi)__A, (__v8hi)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_unpackhi_epi32 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_punpckhdq128 ((__v4si)__A, (__v4si)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_unpackhi_epi64 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_punpckhqdq128 ((__v2di)__A, (__v2di)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_unpacklo_epi8 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_punpcklbw128 ((__v16qi)__A, (__v16qi)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_unpacklo_epi16 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_punpcklwd128 ((__v8hi)__A, (__v8hi)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_unpacklo_epi32 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_punpckldq128 ((__v4si)__A, (__v4si)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_unpacklo_epi64 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_punpcklqdq128 ((__v2di)__A, (__v2di)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_add_epi8 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_paddb128 ((__v16qi)__A, (__v16qi)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_add_epi16 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_paddw128 ((__v8hi)__A, (__v8hi)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_add_epi32 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_paddd128 ((__v4si)__A, (__v4si)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_add_epi64 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_paddq128 ((__v2di)__A, (__v2di)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_adds_epi8 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_paddsb128 ((__v16qi)__A, (__v16qi)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_adds_epi16 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_paddsw128 ((__v8hi)__A, (__v8hi)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_adds_epu8 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_paddusb128 ((__v16qi)__A, (__v16qi)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_adds_epu16 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_paddusw128 ((__v8hi)__A, (__v8hi)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_sub_epi8 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_psubb128 ((__v16qi)__A, (__v16qi)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_sub_epi16 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_psubw128 ((__v8hi)__A, (__v8hi)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_sub_epi32 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_psubd128 ((__v4si)__A, (__v4si)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_sub_epi64 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_psubq128 ((__v2di)__A, (__v2di)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_subs_epi8 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_psubsb128 ((__v16qi)__A, (__v16qi)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_subs_epi16 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_psubsw128 ((__v8hi)__A, (__v8hi)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_subs_epu8 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_psubusb128 ((__v16qi)__A, (__v16qi)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_subs_epu16 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_psubusw128 ((__v8hi)__A, (__v8hi)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_madd_epi16 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_pmaddwd128 ((__v8hi)__A, (__v8hi)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_mulhi_epi16 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_pmulhw128 ((__v8hi)__A, (__v8hi)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_mullo_epi16 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_pmullw128 ((__v8hi)__A, (__v8hi)__B);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_mul_su32 (__m64 __A, __m64 __B)\n {\n   return (__m64)__builtin_ia32_pmuludq ((__v2si)__A, (__v2si)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_mul_epu32 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_pmuludq128 ((__v4si)__A, (__v4si)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_slli_epi16 (__m128i __A, int __B)\n {\n   return (__m128i)__builtin_ia32_psllwi128 ((__v8hi)__A, __B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_slli_epi32 (__m128i __A, int __B)\n {\n   return (__m128i)__builtin_ia32_pslldi128 ((__v4si)__A, __B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_slli_epi64 (__m128i __A, int __B)\n {\n   return (__m128i)__builtin_ia32_psllqi128 ((__v2di)__A, __B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_srai_epi16 (__m128i __A, int __B)\n {\n   return (__m128i)__builtin_ia32_psrawi128 ((__v8hi)__A, __B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_srai_epi32 (__m128i __A, int __B)\n {\n   return (__m128i)__builtin_ia32_psradi128 ((__v4si)__A, __B);\n@@ -1109,145 +1109,145 @@ _mm_srli_si128 (__m128i __A, const int __B)\n   ((__m128i)__builtin_ia32_pslldqi128 (__A, (__B) * 8))\n #endif\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_srli_epi16 (__m128i __A, int __B)\n {\n   return (__m128i)__builtin_ia32_psrlwi128 ((__v8hi)__A, __B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_srli_epi32 (__m128i __A, int __B)\n {\n   return (__m128i)__builtin_ia32_psrldi128 ((__v4si)__A, __B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_srli_epi64 (__m128i __A, int __B)\n {\n   return (__m128i)__builtin_ia32_psrlqi128 ((__v2di)__A, __B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_sll_epi16 (__m128i __A, __m128i __B)\n {\n   return _mm_slli_epi16 (__A, _mm_cvtsi128_si32 (__B));\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_sll_epi32 (__m128i __A, __m128i __B)\n {\n   return _mm_slli_epi32 (__A, _mm_cvtsi128_si32 (__B));\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_sll_epi64 (__m128i __A, __m128i __B)\n {\n   return _mm_slli_epi64 (__A, _mm_cvtsi128_si32 (__B));\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_sra_epi16 (__m128i __A, __m128i __B)\n {\n   return _mm_srai_epi16 (__A, _mm_cvtsi128_si32 (__B));\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_sra_epi32 (__m128i __A, __m128i __B)\n {\n   return _mm_srai_epi32 (__A, _mm_cvtsi128_si32 (__B));\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_srl_epi16 (__m128i __A, __m128i __B)\n {\n   return _mm_srli_epi16 (__A, _mm_cvtsi128_si32 (__B));\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_srl_epi32 (__m128i __A, __m128i __B)\n {\n   return _mm_srli_epi32 (__A, _mm_cvtsi128_si32 (__B));\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_srl_epi64 (__m128i __A, __m128i __B)\n {\n   return _mm_srli_epi64 (__A, _mm_cvtsi128_si32 (__B));\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_and_si128 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_pand128 ((__v2di)__A, (__v2di)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_andnot_si128 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_pandn128 ((__v2di)__A, (__v2di)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_or_si128 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_por128 ((__v2di)__A, (__v2di)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_xor_si128 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_pxor128 ((__v2di)__A, (__v2di)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_cmpeq_epi8 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_pcmpeqb128 ((__v16qi)__A, (__v16qi)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_cmpeq_epi16 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_pcmpeqw128 ((__v8hi)__A, (__v8hi)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_cmpeq_epi32 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_pcmpeqd128 ((__v4si)__A, (__v4si)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_cmplt_epi8 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_pcmpgtb128 ((__v16qi)__B, (__v16qi)__A);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_cmplt_epi16 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_pcmpgtw128 ((__v8hi)__B, (__v8hi)__A);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_cmplt_epi32 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_pcmpgtd128 ((__v4si)__B, (__v4si)__A);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_cmpgt_epi8 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_pcmpgtb128 ((__v16qi)__A, (__v16qi)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_cmpgt_epi16 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_pcmpgtw128 ((__v8hi)__A, (__v8hi)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_cmpgt_epi32 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_pcmpgtd128 ((__v4si)__A, (__v4si)__B);\n@@ -1272,37 +1272,37 @@ _mm_insert_epi16 (__m128i const __A, int const __D, int const __N)\n   ((__m128i) __builtin_ia32_vec_set_v8hi ((__v8hi)(A), (D), (N)))\n #endif\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_max_epi16 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_pmaxsw128 ((__v8hi)__A, (__v8hi)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_max_epu8 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_pmaxub128 ((__v16qi)__A, (__v16qi)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_min_epi16 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_pminsw128 ((__v8hi)__A, (__v8hi)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_min_epu8 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_pminub128 ((__v16qi)__A, (__v16qi)__B);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_movemask_epi8 (__m128i __A)\n {\n   return __builtin_ia32_pmovmskb128 ((__v16qi)__A);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_mulhi_epu16 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_pmulhuw128 ((__v8hi)__A, (__v8hi)__B);\n@@ -1312,74 +1312,74 @@ _mm_mulhi_epu16 (__m128i __A, __m128i __B)\n #define _mm_shufflelo_epi16(__A, __B) ((__m128i)__builtin_ia32_pshuflw ((__v8hi)__A, __B))\n #define _mm_shuffle_epi32(__A, __B) ((__m128i)__builtin_ia32_pshufd ((__v4si)__A, __B))\n \n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_maskmoveu_si128 (__m128i __A, __m128i __B, char *__C)\n {\n   __builtin_ia32_maskmovdqu ((__v16qi)__A, (__v16qi)__B, __C);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_avg_epu8 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_pavgb128 ((__v16qi)__A, (__v16qi)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_avg_epu16 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_pavgw128 ((__v8hi)__A, (__v8hi)__B);\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_sad_epu8 (__m128i __A, __m128i __B)\n {\n   return (__m128i)__builtin_ia32_psadbw128 ((__v16qi)__A, (__v16qi)__B);\n }\n \n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_stream_si32 (int *__A, int __B)\n {\n   __builtin_ia32_movnti (__A, __B);\n }\n \n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_stream_si128 (__m128i *__A, __m128i __B)\n {\n   __builtin_ia32_movntdq ((__v2di *)__A, (__v2di)__B);\n }\n \n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_stream_pd (double *__A, __m128d __B)\n {\n   __builtin_ia32_movntpd (__A, (__v2df)__B);\n }\n \n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_clflush (void const *__A)\n {\n   __builtin_ia32_clflush (__A);\n }\n \n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_lfence (void)\n {\n   __builtin_ia32_lfence ();\n }\n \n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_mfence (void)\n {\n   __builtin_ia32_mfence ();\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_cvtsi32_si128 (int __A)\n {\n   return _mm_set_epi32 (0, 0, 0, __A);\n }\n \n #ifdef __x86_64__\n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_cvtsi64x_si128 (long long __A)\n {\n   return _mm_set_epi64x (0, __A);\n@@ -1388,37 +1388,37 @@ _mm_cvtsi64x_si128 (long long __A)\n \n /* Casts between various SP, DP, INT vector types.  Note that these do no\n    conversion of values, they just change the type.  */\n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_castpd_ps(__m128d __A)\n {\n   return (__m128) __A;\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_castpd_si128(__m128d __A)\n {\n   return (__m128i) __A;\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_castps_pd(__m128 __A)\n {\n   return (__m128d) __A;\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_castps_si128(__m128 __A)\n {\n   return (__m128i) __A;\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_castsi128_ps(__m128i __A)\n {\n   return (__m128) __A;\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_castsi128_pd(__m128i __A)\n {\n   return (__m128d) __A;"}, {"sha": "252364b803e115547168129fabe0c451f89801a0", "filename": "gcc/config/i386/mmintrin.h", "status": "modified", "additions": 125, "deletions": 125, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972fcc764a94eedb83aa9c15d6ba43a32e64a198/gcc%2Fconfig%2Fi386%2Fmmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972fcc764a94eedb83aa9c15d6ba43a32e64a198/gcc%2Fconfig%2Fi386%2Fmmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmmintrin.h?ref=972fcc764a94eedb83aa9c15d6ba43a32e64a198", "patch": "@@ -42,63 +42,63 @@ typedef short __v4hi __attribute__ ((__vector_size__ (8)));\n typedef char __v8qi __attribute__ ((__vector_size__ (8)));\n \n /* Empty the multimedia state.  */\n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_empty (void)\n {\n   __builtin_ia32_emms ();\n }\n \n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _m_empty (void)\n {\n   _mm_empty ();\n }\n \n /* Convert I to a __m64 object.  The integer is zero-extended to 64-bits.  */\n-static __inline __m64 \n+static __inline __m64  __attribute__((__always_inline__))\n _mm_cvtsi32_si64 (int __i)\n {\n   return (__m64) __builtin_ia32_vec_init_v2si (__i, 0);\n }\n \n-static __inline __m64 \n+static __inline __m64  __attribute__((__always_inline__))\n _m_from_int (int __i)\n {\n   return _mm_cvtsi32_si64 (__i);\n }\n \n #ifdef __x86_64__\n /* Convert I to a __m64 object.  */\n-static __inline __m64 \n+static __inline __m64  __attribute__((__always_inline__))\n _mm_cvtsi64x_si64 (long long __i)\n {\n   return (__m64) __i;\n }\n \n /* Convert I to a __m64 object.  */\n-static __inline __m64 \n+static __inline __m64  __attribute__((__always_inline__))\n _mm_set_pi64x (long long __i)\n {\n   return (__m64) __i;\n }\n #endif\n \n /* Convert the lower 32 bits of the __m64 object into an integer.  */\n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_cvtsi64_si32 (__m64 __i)\n {\n   return __builtin_ia32_vec_ext_v2si ((__v2si)__i, 0);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _m_to_int (__m64 __i)\n {\n   return _mm_cvtsi64_si32 (__i);\n }\n \n #ifdef __x86_64__\n /* Convert the lower 32 bits of the __m64 object into an integer.  */\n-static __inline long long\n+static __inline long long __attribute__((__always_inline__))\n _mm_cvtsi64_si64x (__m64 __i)\n {\n   return (long long)__i;\n@@ -108,13 +108,13 @@ _mm_cvtsi64_si64x (__m64 __i)\n /* Pack the four 16-bit values from M1 into the lower four 8-bit values of\n    the result, and the four 16-bit values from M2 into the upper four 8-bit\n    values of the result, all with signed saturation.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_packs_pi16 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_packsswb ((__v4hi)__m1, (__v4hi)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_packsswb (__m64 __m1, __m64 __m2)\n {\n   return _mm_packs_pi16 (__m1, __m2);\n@@ -123,13 +123,13 @@ _m_packsswb (__m64 __m1, __m64 __m2)\n /* Pack the two 32-bit values from M1 in to the lower two 16-bit values of\n    the result, and the two 32-bit values from M2 into the upper two 16-bit\n    values of the result, all with signed saturation.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_packs_pi32 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_packssdw ((__v2si)__m1, (__v2si)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_packssdw (__m64 __m1, __m64 __m2)\n {\n   return _mm_packs_pi32 (__m1, __m2);\n@@ -138,301 +138,301 @@ _m_packssdw (__m64 __m1, __m64 __m2)\n /* Pack the four 16-bit values from M1 into the lower four 8-bit values of\n    the result, and the four 16-bit values from M2 into the upper four 8-bit\n    values of the result, all with unsigned saturation.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_packs_pu16 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_packuswb ((__v4hi)__m1, (__v4hi)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_packuswb (__m64 __m1, __m64 __m2)\n {\n   return _mm_packs_pu16 (__m1, __m2);\n }\n \n /* Interleave the four 8-bit values from the high half of M1 with the four\n    8-bit values from the high half of M2.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_unpackhi_pi8 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_punpckhbw ((__v8qi)__m1, (__v8qi)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_punpckhbw (__m64 __m1, __m64 __m2)\n {\n   return _mm_unpackhi_pi8 (__m1, __m2);\n }\n \n /* Interleave the two 16-bit values from the high half of M1 with the two\n    16-bit values from the high half of M2.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_unpackhi_pi16 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_punpckhwd ((__v4hi)__m1, (__v4hi)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_punpckhwd (__m64 __m1, __m64 __m2)\n {\n   return _mm_unpackhi_pi16 (__m1, __m2);\n }\n \n /* Interleave the 32-bit value from the high half of M1 with the 32-bit\n    value from the high half of M2.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_unpackhi_pi32 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_punpckhdq ((__v2si)__m1, (__v2si)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_punpckhdq (__m64 __m1, __m64 __m2)\n {\n   return _mm_unpackhi_pi32 (__m1, __m2);\n }\n \n /* Interleave the four 8-bit values from the low half of M1 with the four\n    8-bit values from the low half of M2.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_unpacklo_pi8 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_punpcklbw ((__v8qi)__m1, (__v8qi)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_punpcklbw (__m64 __m1, __m64 __m2)\n {\n   return _mm_unpacklo_pi8 (__m1, __m2);\n }\n \n /* Interleave the two 16-bit values from the low half of M1 with the two\n    16-bit values from the low half of M2.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_unpacklo_pi16 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_punpcklwd ((__v4hi)__m1, (__v4hi)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_punpcklwd (__m64 __m1, __m64 __m2)\n {\n   return _mm_unpacklo_pi16 (__m1, __m2);\n }\n \n /* Interleave the 32-bit value from the low half of M1 with the 32-bit\n    value from the low half of M2.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_unpacklo_pi32 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_punpckldq ((__v2si)__m1, (__v2si)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_punpckldq (__m64 __m1, __m64 __m2)\n {\n   return _mm_unpacklo_pi32 (__m1, __m2);\n }\n \n /* Add the 8-bit values in M1 to the 8-bit values in M2.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_add_pi8 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_paddb ((__v8qi)__m1, (__v8qi)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_paddb (__m64 __m1, __m64 __m2)\n {\n   return _mm_add_pi8 (__m1, __m2);\n }\n \n /* Add the 16-bit values in M1 to the 16-bit values in M2.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_add_pi16 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_paddw ((__v4hi)__m1, (__v4hi)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_paddw (__m64 __m1, __m64 __m2)\n {\n   return _mm_add_pi16 (__m1, __m2);\n }\n \n /* Add the 32-bit values in M1 to the 32-bit values in M2.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_add_pi32 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_paddd ((__v2si)__m1, (__v2si)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_paddd (__m64 __m1, __m64 __m2)\n {\n   return _mm_add_pi32 (__m1, __m2);\n }\n \n /* Add the 64-bit values in M1 to the 64-bit values in M2.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_add_si64 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_paddq ((long long)__m1, (long long)__m2);\n }\n \n /* Add the 8-bit values in M1 to the 8-bit values in M2 using signed\n    saturated arithmetic.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_adds_pi8 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_paddsb ((__v8qi)__m1, (__v8qi)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_paddsb (__m64 __m1, __m64 __m2)\n {\n   return _mm_adds_pi8 (__m1, __m2);\n }\n \n /* Add the 16-bit values in M1 to the 16-bit values in M2 using signed\n    saturated arithmetic.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_adds_pi16 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_paddsw ((__v4hi)__m1, (__v4hi)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_paddsw (__m64 __m1, __m64 __m2)\n {\n   return _mm_adds_pi16 (__m1, __m2);\n }\n \n /* Add the 8-bit values in M1 to the 8-bit values in M2 using unsigned\n    saturated arithmetic.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_adds_pu8 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_paddusb ((__v8qi)__m1, (__v8qi)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_paddusb (__m64 __m1, __m64 __m2)\n {\n   return _mm_adds_pu8 (__m1, __m2);\n }\n \n /* Add the 16-bit values in M1 to the 16-bit values in M2 using unsigned\n    saturated arithmetic.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_adds_pu16 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_paddusw ((__v4hi)__m1, (__v4hi)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_paddusw (__m64 __m1, __m64 __m2)\n {\n   return _mm_adds_pu16 (__m1, __m2);\n }\n \n /* Subtract the 8-bit values in M2 from the 8-bit values in M1.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_sub_pi8 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_psubb ((__v8qi)__m1, (__v8qi)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_psubb (__m64 __m1, __m64 __m2)\n {\n   return _mm_sub_pi8 (__m1, __m2);\n }\n \n /* Subtract the 16-bit values in M2 from the 16-bit values in M1.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_sub_pi16 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_psubw ((__v4hi)__m1, (__v4hi)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_psubw (__m64 __m1, __m64 __m2)\n {\n   return _mm_sub_pi16 (__m1, __m2);\n }\n \n /* Subtract the 32-bit values in M2 from the 32-bit values in M1.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_sub_pi32 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_psubd ((__v2si)__m1, (__v2si)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_psubd (__m64 __m1, __m64 __m2)\n {\n   return _mm_sub_pi32 (__m1, __m2);\n }\n \n /* Add the 64-bit values in M1 to the 64-bit values in M2.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_sub_si64 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_psubq ((long long)__m1, (long long)__m2);\n }\n \n /* Subtract the 8-bit values in M2 from the 8-bit values in M1 using signed\n    saturating arithmetic.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_subs_pi8 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_psubsb ((__v8qi)__m1, (__v8qi)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_psubsb (__m64 __m1, __m64 __m2)\n {\n   return _mm_subs_pi8 (__m1, __m2);\n }\n \n /* Subtract the 16-bit values in M2 from the 16-bit values in M1 using\n    signed saturating arithmetic.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_subs_pi16 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_psubsw ((__v4hi)__m1, (__v4hi)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_psubsw (__m64 __m1, __m64 __m2)\n {\n   return _mm_subs_pi16 (__m1, __m2);\n }\n \n /* Subtract the 8-bit values in M2 from the 8-bit values in M1 using\n    unsigned saturating arithmetic.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_subs_pu8 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_psubusb ((__v8qi)__m1, (__v8qi)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_psubusb (__m64 __m1, __m64 __m2)\n {\n   return _mm_subs_pu8 (__m1, __m2);\n }\n \n /* Subtract the 16-bit values in M2 from the 16-bit values in M1 using\n    unsigned saturating arithmetic.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_subs_pu16 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_psubusw ((__v4hi)__m1, (__v4hi)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_psubusw (__m64 __m1, __m64 __m2)\n {\n   return _mm_subs_pu16 (__m1, __m2);\n@@ -441,400 +441,400 @@ _m_psubusw (__m64 __m1, __m64 __m2)\n /* Multiply four 16-bit values in M1 by four 16-bit values in M2 producing\n    four 32-bit intermediate results, which are then summed by pairs to\n    produce two 32-bit results.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_madd_pi16 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_pmaddwd ((__v4hi)__m1, (__v4hi)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_pmaddwd (__m64 __m1, __m64 __m2)\n {\n   return _mm_madd_pi16 (__m1, __m2);\n }\n \n /* Multiply four signed 16-bit values in M1 by four signed 16-bit values in\n    M2 and produce the high 16 bits of the 32-bit results.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_mulhi_pi16 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_pmulhw ((__v4hi)__m1, (__v4hi)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_pmulhw (__m64 __m1, __m64 __m2)\n {\n   return _mm_mulhi_pi16 (__m1, __m2);\n }\n \n /* Multiply four 16-bit values in M1 by four 16-bit values in M2 and produce\n    the low 16 bits of the results.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_mullo_pi16 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_pmullw ((__v4hi)__m1, (__v4hi)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_pmullw (__m64 __m1, __m64 __m2)\n {\n   return _mm_mullo_pi16 (__m1, __m2);\n }\n \n /* Shift four 16-bit values in M left by COUNT.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_sll_pi16 (__m64 __m, __m64 __count)\n {\n   return (__m64) __builtin_ia32_psllw ((__v4hi)__m, (long long)__count);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_psllw (__m64 __m, __m64 __count)\n {\n   return _mm_sll_pi16 (__m, __count);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_slli_pi16 (__m64 __m, int __count)\n {\n   return (__m64) __builtin_ia32_psllw ((__v4hi)__m, __count);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_psllwi (__m64 __m, int __count)\n {\n   return _mm_slli_pi16 (__m, __count);\n }\n \n /* Shift two 32-bit values in M left by COUNT.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_sll_pi32 (__m64 __m, __m64 __count)\n {\n   return (__m64) __builtin_ia32_pslld ((__v2si)__m, (long long)__count);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_pslld (__m64 __m, __m64 __count)\n {\n   return _mm_sll_pi32 (__m, __count);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_slli_pi32 (__m64 __m, int __count)\n {\n   return (__m64) __builtin_ia32_pslld ((__v2si)__m, __count);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_pslldi (__m64 __m, int __count)\n {\n   return _mm_slli_pi32 (__m, __count);\n }\n \n /* Shift the 64-bit value in M left by COUNT.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_sll_si64 (__m64 __m, __m64 __count)\n {\n   return (__m64) __builtin_ia32_psllq ((long long)__m, (long long)__count);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_psllq (__m64 __m, __m64 __count)\n {\n   return _mm_sll_si64 (__m, __count);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_slli_si64 (__m64 __m, int __count)\n {\n   return (__m64) __builtin_ia32_psllq ((long long)__m, (long long)__count);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_psllqi (__m64 __m, int __count)\n {\n   return _mm_slli_si64 (__m, __count);\n }\n \n /* Shift four 16-bit values in M right by COUNT; shift in the sign bit.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_sra_pi16 (__m64 __m, __m64 __count)\n {\n   return (__m64) __builtin_ia32_psraw ((__v4hi)__m, (long long)__count);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_psraw (__m64 __m, __m64 __count)\n {\n   return _mm_sra_pi16 (__m, __count);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_srai_pi16 (__m64 __m, int __count)\n {\n   return (__m64) __builtin_ia32_psraw ((__v4hi)__m, __count);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_psrawi (__m64 __m, int __count)\n {\n   return _mm_srai_pi16 (__m, __count);\n }\n \n /* Shift two 32-bit values in M right by COUNT; shift in the sign bit.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_sra_pi32 (__m64 __m, __m64 __count)\n {\n   return (__m64) __builtin_ia32_psrad ((__v2si)__m, (long long)__count);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_psrad (__m64 __m, __m64 __count)\n {\n   return _mm_sra_pi32 (__m, __count);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_srai_pi32 (__m64 __m, int __count)\n {\n   return (__m64) __builtin_ia32_psrad ((__v2si)__m, __count);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_psradi (__m64 __m, int __count)\n {\n   return _mm_srai_pi32 (__m, __count);\n }\n \n /* Shift four 16-bit values in M right by COUNT; shift in zeros.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_srl_pi16 (__m64 __m, __m64 __count)\n {\n   return (__m64) __builtin_ia32_psrlw ((__v4hi)__m, (long long)__count);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_psrlw (__m64 __m, __m64 __count)\n {\n   return _mm_srl_pi16 (__m, __count);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_srli_pi16 (__m64 __m, int __count)\n {\n   return (__m64) __builtin_ia32_psrlw ((__v4hi)__m, __count);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_psrlwi (__m64 __m, int __count)\n {\n   return _mm_srli_pi16 (__m, __count);\n }\n \n /* Shift two 32-bit values in M right by COUNT; shift in zeros.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_srl_pi32 (__m64 __m, __m64 __count)\n {\n   return (__m64) __builtin_ia32_psrld ((__v2si)__m, (long long)__count);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_psrld (__m64 __m, __m64 __count)\n {\n   return _mm_srl_pi32 (__m, __count);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_srli_pi32 (__m64 __m, int __count)\n {\n   return (__m64) __builtin_ia32_psrld ((__v2si)__m, __count);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_psrldi (__m64 __m, int __count)\n {\n   return _mm_srli_pi32 (__m, __count);\n }\n \n /* Shift the 64-bit value in M left by COUNT; shift in zeros.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_srl_si64 (__m64 __m, __m64 __count)\n {\n   return (__m64) __builtin_ia32_psrlq ((long long)__m, (long long)__count);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_psrlq (__m64 __m, __m64 __count)\n {\n   return _mm_srl_si64 (__m, __count);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_srli_si64 (__m64 __m, int __count)\n {\n   return (__m64) __builtin_ia32_psrlq ((long long)__m, (long long)__count);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_psrlqi (__m64 __m, int __count)\n {\n   return _mm_srli_si64 (__m, __count);\n }\n \n /* Bit-wise AND the 64-bit values in M1 and M2.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_and_si64 (__m64 __m1, __m64 __m2)\n {\n   return __builtin_ia32_pand (__m1, __m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_pand (__m64 __m1, __m64 __m2)\n {\n   return _mm_and_si64 (__m1, __m2);\n }\n \n /* Bit-wise complement the 64-bit value in M1 and bit-wise AND it with the\n    64-bit value in M2.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_andnot_si64 (__m64 __m1, __m64 __m2)\n {\n   return __builtin_ia32_pandn (__m1, __m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_pandn (__m64 __m1, __m64 __m2)\n {\n   return _mm_andnot_si64 (__m1, __m2);\n }\n \n /* Bit-wise inclusive OR the 64-bit values in M1 and M2.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_or_si64 (__m64 __m1, __m64 __m2)\n {\n   return __builtin_ia32_por (__m1, __m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_por (__m64 __m1, __m64 __m2)\n {\n   return _mm_or_si64 (__m1, __m2);\n }\n \n /* Bit-wise exclusive OR the 64-bit values in M1 and M2.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_xor_si64 (__m64 __m1, __m64 __m2)\n {\n   return __builtin_ia32_pxor (__m1, __m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_pxor (__m64 __m1, __m64 __m2)\n {\n   return _mm_xor_si64 (__m1, __m2);\n }\n \n /* Compare eight 8-bit values.  The result of the comparison is 0xFF if the\n    test is true and zero if false.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_cmpeq_pi8 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_pcmpeqb ((__v8qi)__m1, (__v8qi)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_pcmpeqb (__m64 __m1, __m64 __m2)\n {\n   return _mm_cmpeq_pi8 (__m1, __m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_cmpgt_pi8 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_pcmpgtb ((__v8qi)__m1, (__v8qi)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_pcmpgtb (__m64 __m1, __m64 __m2)\n {\n   return _mm_cmpgt_pi8 (__m1, __m2);\n }\n \n /* Compare four 16-bit values.  The result of the comparison is 0xFFFF if\n    the test is true and zero if false.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_cmpeq_pi16 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_pcmpeqw ((__v4hi)__m1, (__v4hi)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_pcmpeqw (__m64 __m1, __m64 __m2)\n {\n   return _mm_cmpeq_pi16 (__m1, __m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_cmpgt_pi16 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_pcmpgtw ((__v4hi)__m1, (__v4hi)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_pcmpgtw (__m64 __m1, __m64 __m2)\n {\n   return _mm_cmpgt_pi16 (__m1, __m2);\n }\n \n /* Compare two 32-bit values.  The result of the comparison is 0xFFFFFFFF if\n    the test is true and zero if false.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_cmpeq_pi32 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_pcmpeqd ((__v2si)__m1, (__v2si)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_pcmpeqd (__m64 __m1, __m64 __m2)\n {\n   return _mm_cmpeq_pi32 (__m1, __m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_cmpgt_pi32 (__m64 __m1, __m64 __m2)\n {\n   return (__m64) __builtin_ia32_pcmpgtd ((__v2si)__m1, (__v2si)__m2);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_pcmpgtd (__m64 __m1, __m64 __m2)\n {\n   return _mm_cmpgt_pi32 (__m1, __m2);\n }\n \n /* Creates a 64-bit zero.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_setzero_si64 (void)\n {\n   return (__m64)0LL;\n }\n \n /* Creates a vector of two 32-bit values; I0 is least significant.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_set_pi32 (int __i1, int __i0)\n {\n   return (__m64) __builtin_ia32_vec_init_v2si (__i0, __i1);\n }\n \n /* Creates a vector of four 16-bit values; W0 is least significant.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_set_pi16 (short __w3, short __w2, short __w1, short __w0)\n {\n   return (__m64) __builtin_ia32_vec_init_v4hi (__w0, __w1, __w2, __w3);\n }\n \n /* Creates a vector of eight 8-bit values; B0 is least significant.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_set_pi8 (char __b7, char __b6, char __b5, char __b4,\n \t     char __b3, char __b2, char __b1, char __b0)\n {\n@@ -843,41 +843,41 @@ _mm_set_pi8 (char __b7, char __b6, char __b5, char __b4,\n }\n \n /* Similar, but with the arguments in reverse order.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_setr_pi32 (int __i0, int __i1)\n {\n   return _mm_set_pi32 (__i1, __i0);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_setr_pi16 (short __w0, short __w1, short __w2, short __w3)\n {\n   return _mm_set_pi16 (__w3, __w2, __w1, __w0);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_setr_pi8 (char __b0, char __b1, char __b2, char __b3,\n \t      char __b4, char __b5, char __b6, char __b7)\n {\n   return _mm_set_pi8 (__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);\n }\n \n /* Creates a vector of two 32-bit values, both elements containing I.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_set1_pi32 (int __i)\n {\n   return _mm_set_pi32 (__i, __i);\n }\n \n /* Creates a vector of four 16-bit values, all elements containing W.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_set1_pi16 (short __w)\n {\n   return _mm_set_pi16 (__w, __w, __w, __w);\n }\n \n /* Creates a vector of eight 8-bit values, all elements containing B.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_set1_pi8 (char __b)\n {\n   return _mm_set_pi8 (__b, __b, __b, __b, __b, __b, __b, __b);"}, {"sha": "ca2955906e3b37b1dc9ea81139466145cb2ed764", "filename": "gcc/config/i386/pmmintrin.h", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972fcc764a94eedb83aa9c15d6ba43a32e64a198/gcc%2Fconfig%2Fi386%2Fpmmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972fcc764a94eedb83aa9c15d6ba43a32e64a198/gcc%2Fconfig%2Fi386%2Fpmmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpmmintrin.h?ref=972fcc764a94eedb83aa9c15d6ba43a32e64a198", "patch": "@@ -44,80 +44,80 @@\n #define _MM_GET_DENORMALS_ZERO_MODE() \\\n   (_mm_getcsr() & _MM_DENORMALS_ZERO_MASK)\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_addsub_ps (__m128 __X, __m128 __Y)\n {\n   return (__m128) __builtin_ia32_addsubps ((__v4sf)__X, (__v4sf)__Y);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_hadd_ps (__m128 __X, __m128 __Y)\n {\n   return (__m128) __builtin_ia32_haddps ((__v4sf)__X, (__v4sf)__Y);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_hsub_ps (__m128 __X, __m128 __Y)\n {\n   return (__m128) __builtin_ia32_hsubps ((__v4sf)__X, (__v4sf)__Y);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_movehdup_ps (__m128 __X)\n {\n   return (__m128) __builtin_ia32_movshdup ((__v4sf)__X);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_moveldup_ps (__m128 __X)\n {\n   return (__m128) __builtin_ia32_movsldup ((__v4sf)__X);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_addsub_pd (__m128d __X, __m128d __Y)\n {\n   return (__m128d) __builtin_ia32_addsubpd ((__v2df)__X, (__v2df)__Y);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_hadd_pd (__m128d __X, __m128d __Y)\n {\n   return (__m128d) __builtin_ia32_haddpd ((__v2df)__X, (__v2df)__Y);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_hsub_pd (__m128d __X, __m128d __Y)\n {\n   return (__m128d) __builtin_ia32_hsubpd ((__v2df)__X, (__v2df)__Y);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_loaddup_pd (double const *__P)\n {\n   return _mm_load1_pd (__P);\n }\n \n-static __inline __m128d\n+static __inline __m128d __attribute__((__always_inline__))\n _mm_movedup_pd (__m128d __X)\n {\n   return _mm_shuffle_pd (__X, __X, _MM_SHUFFLE2 (0,0));\n }\n \n-static __inline __m128i\n+static __inline __m128i __attribute__((__always_inline__))\n _mm_lddqu_si128 (__m128i const *__P)\n {\n   return (__m128i) __builtin_ia32_lddqu ((char const *)__P);\n }\n \n #if 0\n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_monitor (void const * __P, unsigned int __E, unsigned int __H)\n {\n   __builtin_ia32_monitor (__P, __E, __H);\n }\n \n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_mwait (unsigned int __E, unsigned int __H)\n {\n   __builtin_ia32_mwait (__E, __H);"}, {"sha": "b80d6b58ec7f023d1dafb7851a9339f4f7d88be5", "filename": "gcc/config/i386/xmmintrin.h", "status": "modified", "additions": 146, "deletions": 146, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972fcc764a94eedb83aa9c15d6ba43a32e64a198/gcc%2Fconfig%2Fi386%2Fxmmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972fcc764a94eedb83aa9c15d6ba43a32e64a198/gcc%2Fconfig%2Fi386%2Fxmmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fxmmintrin.h?ref=972fcc764a94eedb83aa9c15d6ba43a32e64a198", "patch": "@@ -87,7 +87,7 @@ enum _mm_hint\n #define _MM_FLUSH_ZERO_OFF    0x0000\n \n /* Create a vector of zeros.  */\n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_setzero_ps (void)\n {\n   return __extension__ (__m128){ 0.0f, 0.0f, 0.0f, 0.0f };\n@@ -97,137 +97,137 @@ _mm_setzero_ps (void)\n    floating-point) values of A and B; the upper three SPFP values are\n    passed through from A.  */\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_add_ss (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_addss ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_sub_ss (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_subss ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_mul_ss (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_mulss ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_div_ss (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_divss ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_sqrt_ss (__m128 __A)\n {\n   return (__m128) __builtin_ia32_sqrtss ((__v4sf)__A);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_rcp_ss (__m128 __A)\n {\n   return (__m128) __builtin_ia32_rcpss ((__v4sf)__A);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_rsqrt_ss (__m128 __A)\n {\n   return (__m128) __builtin_ia32_rsqrtss ((__v4sf)__A);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_min_ss (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_minss ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_max_ss (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_maxss ((__v4sf)__A, (__v4sf)__B);\n }\n \n /* Perform the respective operation on the four SPFP values in A and B.  */\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_add_ps (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_addps ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_sub_ps (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_subps ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_mul_ps (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_mulps ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_div_ps (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_divps ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_sqrt_ps (__m128 __A)\n {\n   return (__m128) __builtin_ia32_sqrtps ((__v4sf)__A);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_rcp_ps (__m128 __A)\n {\n   return (__m128) __builtin_ia32_rcpps ((__v4sf)__A);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_rsqrt_ps (__m128 __A)\n {\n   return (__m128) __builtin_ia32_rsqrtps ((__v4sf)__A);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_min_ps (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_minps ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_max_ps (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_maxps ((__v4sf)__A, (__v4sf)__B);\n }\n \n /* Perform logical bit-wise operations on 128-bit values.  */\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_and_ps (__m128 __A, __m128 __B)\n {\n   return __builtin_ia32_andps (__A, __B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_andnot_ps (__m128 __A, __m128 __B)\n {\n   return __builtin_ia32_andnps (__A, __B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_or_ps (__m128 __A, __m128 __B)\n {\n   return __builtin_ia32_orps (__A, __B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_xor_ps (__m128 __A, __m128 __B)\n {\n   return __builtin_ia32_xorps (__A, __B);\n@@ -237,25 +237,25 @@ _mm_xor_ps (__m128 __A, __m128 __B)\n    comparison is true, place a mask of all ones in the result, otherwise a\n    mask of zeros.  The upper three SPFP values are passed through from A.  */\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cmpeq_ss (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_cmpeqss ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cmplt_ss (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_cmpltss ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cmple_ss (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_cmpless ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cmpgt_ss (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_movss ((__v4sf) __A,\n@@ -265,7 +265,7 @@ _mm_cmpgt_ss (__m128 __A, __m128 __B)\n \t\t\t\t\t\t\t\t__A));\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cmpge_ss (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_movss ((__v4sf) __A,\n@@ -275,25 +275,25 @@ _mm_cmpge_ss (__m128 __A, __m128 __B)\n \t\t\t\t\t\t\t\t__A));\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cmpneq_ss (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_cmpneqss ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cmpnlt_ss (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_cmpnltss ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cmpnle_ss (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_cmpnless ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cmpngt_ss (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_movss ((__v4sf) __A,\n@@ -303,7 +303,7 @@ _mm_cmpngt_ss (__m128 __A, __m128 __B)\n \t\t\t\t\t\t\t\t __A));\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cmpnge_ss (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_movss ((__v4sf) __A,\n@@ -313,13 +313,13 @@ _mm_cmpnge_ss (__m128 __A, __m128 __B)\n \t\t\t\t\t\t\t\t __A));\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cmpord_ss (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_cmpordss ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cmpunord_ss (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_cmpunordss ((__v4sf)__A, (__v4sf)__B);\n@@ -329,73 +329,73 @@ _mm_cmpunord_ss (__m128 __A, __m128 __B)\n    element, if the comparison is true, place a mask of all ones in the\n    result, otherwise a mask of zeros.  */\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cmpeq_ps (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_cmpeqps ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cmplt_ps (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_cmpltps ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cmple_ps (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_cmpleps ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cmpgt_ps (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_cmpgtps ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cmpge_ps (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_cmpgeps ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cmpneq_ps (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_cmpneqps ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cmpnlt_ps (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_cmpnltps ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cmpnle_ps (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_cmpnleps ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cmpngt_ps (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_cmpngtps ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cmpnge_ps (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_cmpngeps ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cmpord_ps (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_cmpordps ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cmpunord_ps (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_cmpunordps ((__v4sf)__A, (__v4sf)__B);\n@@ -404,87 +404,87 @@ _mm_cmpunord_ps (__m128 __A, __m128 __B)\n /* Compare the lower SPFP values of A and B and return 1 if true\n    and 0 if false.  */\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_comieq_ss (__m128 __A, __m128 __B)\n {\n   return __builtin_ia32_comieq ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_comilt_ss (__m128 __A, __m128 __B)\n {\n   return __builtin_ia32_comilt ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_comile_ss (__m128 __A, __m128 __B)\n {\n   return __builtin_ia32_comile ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_comigt_ss (__m128 __A, __m128 __B)\n {\n   return __builtin_ia32_comigt ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_comige_ss (__m128 __A, __m128 __B)\n {\n   return __builtin_ia32_comige ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_comineq_ss (__m128 __A, __m128 __B)\n {\n   return __builtin_ia32_comineq ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_ucomieq_ss (__m128 __A, __m128 __B)\n {\n   return __builtin_ia32_ucomieq ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_ucomilt_ss (__m128 __A, __m128 __B)\n {\n   return __builtin_ia32_ucomilt ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_ucomile_ss (__m128 __A, __m128 __B)\n {\n   return __builtin_ia32_ucomile ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_ucomigt_ss (__m128 __A, __m128 __B)\n {\n   return __builtin_ia32_ucomigt ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_ucomige_ss (__m128 __A, __m128 __B)\n {\n   return __builtin_ia32_ucomige ((__v4sf)__A, (__v4sf)__B);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_ucomineq_ss (__m128 __A, __m128 __B)\n {\n   return __builtin_ia32_ucomineq ((__v4sf)__A, (__v4sf)__B);\n }\n \n /* Convert the lower SPFP value to a 32-bit integer according to the current\n    rounding mode.  */\n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_cvtss_si32 (__m128 __A)\n {\n   return __builtin_ia32_cvtss2si ((__v4sf) __A);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_cvt_ss2si (__m128 __A)\n {\n   return _mm_cvtss_si32 (__A);\n@@ -493,7 +493,7 @@ _mm_cvt_ss2si (__m128 __A)\n #ifdef __x86_64__\n /* Convert the lower SPFP value to a 32-bit integer according to the current\n    rounding mode.  */\n-static __inline long long\n+static __inline long long __attribute__((__always_inline__))\n _mm_cvtss_si64x (__m128 __A)\n {\n   return __builtin_ia32_cvtss2si64 ((__v4sf) __A);\n@@ -502,34 +502,34 @@ _mm_cvtss_si64x (__m128 __A)\n \n /* Convert the two lower SPFP values to 32-bit integers according to the\n    current rounding mode.  Return the integers in packed form.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_cvtps_pi32 (__m128 __A)\n {\n   return (__m64) __builtin_ia32_cvtps2pi ((__v4sf) __A);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_cvt_ps2pi (__m128 __A)\n {\n   return _mm_cvtps_pi32 (__A);\n }\n \n /* Truncate the lower SPFP value to a 32-bit integer.  */\n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_cvttss_si32 (__m128 __A)\n {\n   return __builtin_ia32_cvttss2si ((__v4sf) __A);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_cvtt_ss2si (__m128 __A)\n {\n   return _mm_cvttss_si32 (__A);\n }\n \n #ifdef __x86_64__\n /* Truncate the lower SPFP value to a 32-bit integer.  */\n-static __inline long long\n+static __inline long long __attribute__((__always_inline__))\n _mm_cvttss_si64x (__m128 __A)\n {\n   return __builtin_ia32_cvttss2si64 ((__v4sf) __A);\n@@ -538,34 +538,34 @@ _mm_cvttss_si64x (__m128 __A)\n \n /* Truncate the two lower SPFP values to 32-bit integers.  Return the\n    integers in packed form.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_cvttps_pi32 (__m128 __A)\n {\n   return (__m64) __builtin_ia32_cvttps2pi ((__v4sf) __A);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_cvtt_ps2pi (__m128 __A)\n {\n   return _mm_cvttps_pi32 (__A);\n }\n \n /* Convert B to a SPFP value and insert it as element zero in A.  */\n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cvtsi32_ss (__m128 __A, int __B)\n {\n   return (__m128) __builtin_ia32_cvtsi2ss ((__v4sf) __A, __B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cvt_si2ss (__m128 __A, int __B)\n {\n   return _mm_cvtsi32_ss (__A, __B);\n }\n \n #ifdef __x86_64__\n /* Convert B to a SPFP value and insert it as element zero in A.  */\n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cvtsi64x_ss (__m128 __A, long long __B)\n {\n   return (__m128) __builtin_ia32_cvtsi642ss ((__v4sf) __A, __B);\n@@ -574,20 +574,20 @@ _mm_cvtsi64x_ss (__m128 __A, long long __B)\n \n /* Convert the two 32-bit values in B to SPFP form and insert them\n    as the two lower elements in A.  */\n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cvtpi32_ps (__m128 __A, __m64 __B)\n {\n   return (__m128) __builtin_ia32_cvtpi2ps ((__v4sf) __A, (__v2si)__B);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cvt_pi2ps (__m128 __A, __m64 __B)\n {\n   return _mm_cvtpi32_ps (__A, __B);\n }\n \n /* Convert the four signed 16-bit values in A to SPFP form.  */\n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cvtpi16_ps (__m64 __A)\n {\n   __v4hi __sign;\n@@ -613,7 +613,7 @@ _mm_cvtpi16_ps (__m64 __A)\n }\n \n /* Convert the four unsigned 16-bit values in A to SPFP form.  */\n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cvtpu16_ps (__m64 __A)\n {\n   __v2si __hisi, __losi;\n@@ -633,7 +633,7 @@ _mm_cvtpu16_ps (__m64 __A)\n }\n \n /* Convert the low four signed 8-bit values in A to SPFP form.  */\n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cvtpi8_ps (__m64 __A)\n {\n   __v8qi __sign;\n@@ -650,15 +650,15 @@ _mm_cvtpi8_ps (__m64 __A)\n }\n \n /* Convert the low four unsigned 8-bit values in A to SPFP form.  */\n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cvtpu8_ps(__m64 __A)\n {\n   __A = (__m64) __builtin_ia32_punpcklbw ((__v8qi)__A, (__v8qi)0LL);\n   return _mm_cvtpu16_ps(__A);\n }\n \n /* Convert the four signed 32-bit values in A and B to SPFP form.  */\n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_cvtpi32x2_ps(__m64 __A, __m64 __B)\n {\n   __v4sf __zero = (__v4sf) _mm_setzero_ps ();\n@@ -668,7 +668,7 @@ _mm_cvtpi32x2_ps(__m64 __A, __m64 __B)\n }\n \n /* Convert the four SPFP values in A to four signed 16-bit integers.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_cvtps_pi16(__m128 __A)\n {\n   __v4sf __hisf = (__v4sf)__A;\n@@ -679,7 +679,7 @@ _mm_cvtps_pi16(__m128 __A)\n }\n \n /* Convert the four SPFP values in A to four signed 8-bit integers.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_cvtps_pi8(__m128 __A)\n {\n   __v4hi __tmp = (__v4hi) _mm_cvtps_pi16 (__A);\n@@ -688,7 +688,7 @@ _mm_cvtps_pi8(__m128 __A)\n \n /* Selects four specific SPFP values from A and B based on MASK.  */\n #if 0\n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_shuffle_ps (__m128 __A, __m128 __B, int __mask)\n {\n   return (__m128) __builtin_ia32_shufps ((__v4sf)__A, (__v4sf)__B, __mask);\n@@ -700,248 +700,248 @@ _mm_shuffle_ps (__m128 __A, __m128 __B, int __mask)\n \n \n /* Selects and interleaves the upper two SPFP values from A and B.  */\n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_unpackhi_ps (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_unpckhps ((__v4sf)__A, (__v4sf)__B);\n }\n \n /* Selects and interleaves the lower two SPFP values from A and B.  */\n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_unpacklo_ps (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_unpcklps ((__v4sf)__A, (__v4sf)__B);\n }\n \n /* Sets the upper two SPFP values with 64-bits of data loaded from P;\n    the lower two values are passed through from A.  */\n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_loadh_pi (__m128 __A, __m64 const *__P)\n {\n   return (__m128) __builtin_ia32_loadhps ((__v4sf)__A, (__v2si *)__P);\n }\n \n /* Stores the upper two SPFP values of A into P.  */\n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_storeh_pi (__m64 *__P, __m128 __A)\n {\n   __builtin_ia32_storehps ((__v2si *)__P, (__v4sf)__A);\n }\n \n /* Moves the upper two values of B into the lower two values of A.  */\n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_movehl_ps (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_movhlps ((__v4sf)__A, (__v4sf)__B);\n }\n \n /* Moves the lower two values of B into the upper two values of A.  */\n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_movelh_ps (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_movlhps ((__v4sf)__A, (__v4sf)__B);\n }\n \n /* Sets the lower two SPFP values with 64-bits of data loaded from P;\n    the upper two values are passed through from A.  */\n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_loadl_pi (__m128 __A, __m64 const *__P)\n {\n   return (__m128) __builtin_ia32_loadlps ((__v4sf)__A, (__v2si *)__P);\n }\n \n /* Stores the lower two SPFP values of A into P.  */\n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_storel_pi (__m64 *__P, __m128 __A)\n {\n   __builtin_ia32_storelps ((__v2si *)__P, (__v4sf)__A);\n }\n \n /* Creates a 4-bit mask from the most significant bits of the SPFP values.  */\n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_movemask_ps (__m128 __A)\n {\n   return __builtin_ia32_movmskps ((__v4sf)__A);\n }\n \n /* Return the contents of the control register.  */\n-static __inline unsigned int\n+static __inline unsigned int __attribute__((__always_inline__))\n _mm_getcsr (void)\n {\n   return __builtin_ia32_stmxcsr ();\n }\n \n /* Read exception bits from the control register.  */\n-static __inline unsigned int\n+static __inline unsigned int __attribute__((__always_inline__))\n _MM_GET_EXCEPTION_STATE (void)\n {\n   return _mm_getcsr() & _MM_EXCEPT_MASK;\n }\n \n-static __inline unsigned int\n+static __inline unsigned int __attribute__((__always_inline__))\n _MM_GET_EXCEPTION_MASK (void)\n {\n   return _mm_getcsr() & _MM_MASK_MASK;\n }\n \n-static __inline unsigned int\n+static __inline unsigned int __attribute__((__always_inline__))\n _MM_GET_ROUNDING_MODE (void)\n {\n   return _mm_getcsr() & _MM_ROUND_MASK;\n }\n \n-static __inline unsigned int\n+static __inline unsigned int __attribute__((__always_inline__))\n _MM_GET_FLUSH_ZERO_MODE (void)\n {\n   return _mm_getcsr() & _MM_FLUSH_ZERO_MASK;\n }\n \n /* Set the control register to I.  */\n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_setcsr (unsigned int __I)\n {\n   __builtin_ia32_ldmxcsr (__I);\n }\n \n /* Set exception bits in the control register.  */\n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _MM_SET_EXCEPTION_STATE(unsigned int __mask)\n {\n   _mm_setcsr((_mm_getcsr() & ~_MM_EXCEPT_MASK) | __mask);\n }\n \n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _MM_SET_EXCEPTION_MASK (unsigned int __mask)\n {\n   _mm_setcsr((_mm_getcsr() & ~_MM_MASK_MASK) | __mask);\n }\n \n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _MM_SET_ROUNDING_MODE (unsigned int __mode)\n {\n   _mm_setcsr((_mm_getcsr() & ~_MM_ROUND_MASK) | __mode);\n }\n \n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _MM_SET_FLUSH_ZERO_MODE (unsigned int __mode)\n {\n   _mm_setcsr((_mm_getcsr() & ~_MM_FLUSH_ZERO_MASK) | __mode);\n }\n \n /* Create a vector with element 0 as F and the rest zero.  */\n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_set_ss (float __F)\n {\n   return __extension__ (__m128)(__v4sf){ __F, 0, 0, 0 };\n }\n \n /* Create a vector with all four elements equal to F.  */\n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_set1_ps (float __F)\n {\n   return __extension__ (__m128)(__v4sf){ __F, __F, __F, __F };\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_set_ps1 (float __F)\n {\n   return _mm_set1_ps (__F);\n }\n \n /* Create a vector with element 0 as *P and the rest zero.  */\n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_load_ss (float const *__P)\n {\n   return _mm_set_ss (*__P);\n }\n \n /* Create a vector with all four elements equal to *P.  */\n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_load1_ps (float const *__P)\n {\n   return _mm_set1_ps (*__P);\n }\n \n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_load_ps1 (float const *__P)\n {\n   return _mm_load1_ps (__P);\n }\n \n /* Load four SPFP values from P.  The address must be 16-byte aligned.  */\n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_load_ps (float const *__P)\n {\n   return (__m128) *(__v4sf *)__P;\n }\n \n /* Load four SPFP values from P.  The address need not be 16-byte aligned.  */\n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_loadu_ps (float const *__P)\n {\n   return (__m128) __builtin_ia32_loadups (__P);\n }\n \n /* Load four SPFP values in reverse order.  The address must be aligned.  */\n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_loadr_ps (float const *__P)\n {\n   __v4sf __tmp = *(__v4sf *)__P;\n   return (__m128) __builtin_ia32_shufps (__tmp, __tmp, _MM_SHUFFLE (0,1,2,3));\n }\n \n /* Create the vector [Z Y X W].  */\n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_set_ps (const float __Z, const float __Y, const float __X, const float __W)\n {\n   return __extension__ (__m128)(__v4sf){ __W, __X, __Y, __Z };\n }\n \n /* Create the vector [W X Y Z].  */\n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_setr_ps (float __Z, float __Y, float __X, float __W)\n {\n   return __extension__ (__m128)(__v4sf){ __Z, __Y, __X, __W };\n }\n \n /* Stores the lower SPFP value.  */\n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_store_ss (float *__P, __m128 __A)\n {\n   *__P = __builtin_ia32_vec_ext_v4sf ((__v4sf)__A, 0);\n }\n \n /* Store four SPFP values.  The address must be 16-byte aligned.  */\n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_store_ps (float *__P, __m128 __A)\n {\n   *(__v4sf *)__P = (__v4sf)__A;\n }\n \n /* Store four SPFP values.  The address need not be 16-byte aligned.  */\n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_storeu_ps (float *__P, __m128 __A)\n {\n   __builtin_ia32_storeups (__P, (__v4sf)__A);\n }\n \n /* Store the lower SPFP value across four words.  */\n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_store1_ps (float *__P, __m128 __A)\n {\n   __v4sf __va = (__v4sf)__A;\n   __v4sf __tmp = __builtin_ia32_shufps (__va, __va, _MM_SHUFFLE (0,0,0,0));\n   _mm_storeu_ps (__P, __tmp);\n }\n \n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_store_ps1 (float *__P, __m128 __A)\n {\n   _mm_store1_ps (__P, __A);\n }\n \n /* Store four SPFP values in reverse order.  The address must be aligned.  */\n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_storer_ps (float *__P, __m128 __A)\n {\n   __v4sf __va = (__v4sf)__A;\n@@ -950,7 +950,7 @@ _mm_storer_ps (float *__P, __m128 __A)\n }\n \n /* Sets the low SPFP value of A from the low value of B.  */\n-static __inline __m128\n+static __inline __m128 __attribute__((__always_inline__))\n _mm_move_ss (__m128 __A, __m128 __B)\n {\n   return (__m128) __builtin_ia32_movss ((__v4sf)__A, (__v4sf)__B);\n@@ -995,79 +995,79 @@ _m_pinsrw (__m64 const __A, int const __D, int const __N)\n #endif\n \n /* Compute the element-wise maximum of signed 16-bit values.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_max_pi16 (__m64 __A, __m64 __B)\n {\n   return (__m64) __builtin_ia32_pmaxsw ((__v4hi)__A, (__v4hi)__B);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_pmaxsw (__m64 __A, __m64 __B)\n {\n   return _mm_max_pi16 (__A, __B);\n }\n \n /* Compute the element-wise maximum of unsigned 8-bit values.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_max_pu8 (__m64 __A, __m64 __B)\n {\n   return (__m64) __builtin_ia32_pmaxub ((__v8qi)__A, (__v8qi)__B);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_pmaxub (__m64 __A, __m64 __B)\n {\n   return _mm_max_pu8 (__A, __B);\n }\n \n /* Compute the element-wise minimum of signed 16-bit values.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_min_pi16 (__m64 __A, __m64 __B)\n {\n   return (__m64) __builtin_ia32_pminsw ((__v4hi)__A, (__v4hi)__B);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_pminsw (__m64 __A, __m64 __B)\n {\n   return _mm_min_pi16 (__A, __B);\n }\n \n /* Compute the element-wise minimum of unsigned 8-bit values.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_min_pu8 (__m64 __A, __m64 __B)\n {\n   return (__m64) __builtin_ia32_pminub ((__v8qi)__A, (__v8qi)__B);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_pminub (__m64 __A, __m64 __B)\n {\n   return _mm_min_pu8 (__A, __B);\n }\n \n /* Create an 8-bit mask of the signs of 8-bit values.  */\n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _mm_movemask_pi8 (__m64 __A)\n {\n   return __builtin_ia32_pmovmskb ((__v8qi)__A);\n }\n \n-static __inline int\n+static __inline int __attribute__((__always_inline__))\n _m_pmovmskb (__m64 __A)\n {\n   return _mm_movemask_pi8 (__A);\n }\n \n /* Multiply four unsigned 16-bit values in A by four unsigned 16-bit values\n    in B and produce the high 16 bits of the 32-bit results.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_mulhi_pu16 (__m64 __A, __m64 __B)\n {\n   return (__m64) __builtin_ia32_pmulhuw ((__v4hi)__A, (__v4hi)__B);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_pmulhuw (__m64 __A, __m64 __B)\n {\n   return _mm_mulhi_pu16 (__A, __B);\n@@ -1076,13 +1076,13 @@ _m_pmulhuw (__m64 __A, __m64 __B)\n /* Return a combination of the four 16-bit values in A.  The selector\n    must be an immediate.  */\n #if 0\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_shuffle_pi16 (__m64 __A, int __N)\n {\n   return (__m64) __builtin_ia32_pshufw ((__v4hi)__A, __N);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_pshufw (__m64 __A, int __N)\n {\n   return _mm_shuffle_pi16 (__A, __N);\n@@ -1096,39 +1096,39 @@ _m_pshufw (__m64 __A, int __N)\n /* Conditionally store byte elements of A into P.  The high bit of each\n    byte in the selector N determines whether the corresponding byte from\n    A is stored.  */\n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_maskmove_si64 (__m64 __A, __m64 __N, char *__P)\n {\n   __builtin_ia32_maskmovq ((__v8qi)__A, (__v8qi)__N, __P);\n }\n \n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _m_maskmovq (__m64 __A, __m64 __N, char *__P)\n {\n   _mm_maskmove_si64 (__A, __N, __P);\n }\n \n /* Compute the rounded averages of the unsigned 8-bit values in A and B.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_avg_pu8 (__m64 __A, __m64 __B)\n {\n   return (__m64) __builtin_ia32_pavgb ((__v8qi)__A, (__v8qi)__B);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_pavgb (__m64 __A, __m64 __B)\n {\n   return _mm_avg_pu8 (__A, __B);\n }\n \n /* Compute the rounded averages of the unsigned 16-bit values in A and B.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_avg_pu16 (__m64 __A, __m64 __B)\n {\n   return (__m64) __builtin_ia32_pavgw ((__v4hi)__A, (__v4hi)__B);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_pavgw (__m64 __A, __m64 __B)\n {\n   return _mm_avg_pu16 (__A, __B);\n@@ -1137,13 +1137,13 @@ _m_pavgw (__m64 __A, __m64 __B)\n /* Compute the sum of the absolute differences of the unsigned 8-bit\n    values in A and B.  Return the value in the lower 16-bit word; the\n    upper words are cleared.  */\n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _mm_sad_pu8 (__m64 __A, __m64 __B)\n {\n   return (__m64) __builtin_ia32_psadbw ((__v8qi)__A, (__v8qi)__B);\n }\n \n-static __inline __m64\n+static __inline __m64 __attribute__((__always_inline__))\n _m_psadbw (__m64 __A, __m64 __B)\n {\n   return _mm_sad_pu8 (__A, __B);\n@@ -1152,7 +1152,7 @@ _m_psadbw (__m64 __A, __m64 __B)\n /* Loads one cache line from address P to a location \"closer\" to the\n    processor.  The selector I specifies the type of prefetch operation.  */\n #if 0\n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_prefetch (void *__P, enum _mm_hint __I)\n {\n   __builtin_prefetch (__P, 0, __I);\n@@ -1163,22 +1163,22 @@ _mm_prefetch (void *__P, enum _mm_hint __I)\n #endif\n \n /* Stores the data in A to the address P without polluting the caches.  */\n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_stream_pi (__m64 *__P, __m64 __A)\n {\n   __builtin_ia32_movntq ((unsigned long long *)__P, (unsigned long long)__A);\n }\n \n /* Likewise.  The address must be 16-byte aligned.  */\n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_stream_ps (float *__P, __m128 __A)\n {\n   __builtin_ia32_movntps (__P, (__v4sf)__A);\n }\n \n /* Guarantees that every preceding store is globally visible before\n    any subsequent store.  */\n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_sfence (void)\n {\n   __builtin_ia32_sfence ();\n@@ -1187,7 +1187,7 @@ _mm_sfence (void)\n /* The execution of the next instruction is delayed by an implementation\n    specific amount of time.  The instruction does not modify the\n    architectural state.  */\n-static __inline void\n+static __inline void __attribute__((__always_inline__))\n _mm_pause (void)\n {\n   __asm__ __volatile__ (\"rep; nop\" : : );"}]}