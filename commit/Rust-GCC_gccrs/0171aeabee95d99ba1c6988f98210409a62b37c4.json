{"sha": "0171aeabee95d99ba1c6988f98210409a62b37c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE3MWFlYWJlZTk1ZDk5YmExYzY5ODhmOTgyMTA0MDlhNjJiMzdjNA==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1994-10-11T18:39:14Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1994-10-11T18:39:14Z"}, "message": "(do_build_copy_constructor): Handle anonymous unions.\n\n        (do_build_assign_ref): Ditto.\n        (largest_union_member): Move from lex.c.\n\nFrom-SVN: r8253", "tree": {"sha": "2a8b84d728ba429a675a6a9f4d1ab449ec0a3632", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a8b84d728ba429a675a6a9f4d1ab449ec0a3632"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0171aeabee95d99ba1c6988f98210409a62b37c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0171aeabee95d99ba1c6988f98210409a62b37c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0171aeabee95d99ba1c6988f98210409a62b37c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0171aeabee95d99ba1c6988f98210409a62b37c4/comments", "author": null, "committer": null, "parents": [{"sha": "fef71f9d2bc4f87bd2ea6c8874a00f76ba8b0676", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fef71f9d2bc4f87bd2ea6c8874a00f76ba8b0676", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fef71f9d2bc4f87bd2ea6c8874a00f76ba8b0676"}], "stats": {"total": 35, "additions": 33, "deletions": 2}, "files": [{"sha": "23fffe4eecfd0a3ea2c0cceda9dfc65ad5913359", "filename": "gcc/cp/method.c", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0171aeabee95d99ba1c6988f98210409a62b37c4/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0171aeabee95d99ba1c6988f98210409a62b37c4/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=0171aeabee95d99ba1c6988f98210409a62b37c4", "patch": "@@ -1980,6 +1980,23 @@ build_default_constructor (fndecl)\n   finish_function (lineno, 0);\n }\n \n+/* For the anonymous union in TYPE, return the member that is at least as\n+   large as the rest of the members, so we can copy it.  */\n+static tree\n+largest_union_member (type)\n+     tree type;\n+{\n+  tree f, type_size = TYPE_SIZE (type);\n+\n+  for (f = TYPE_FIELDS (type); f; f = TREE_CHAIN (f))\n+    if (simple_cst_equal (DECL_SIZE (f), type_size))\n+      return f;\n+\n+  /* We should always find one.  */\n+  my_friendly_abort (323);\n+  return NULL_TREE;\n+}\n+\n /* Generate code for default X(X&) constructor.  */\n void\n build_copy_constructor (fndecl)\n@@ -2034,7 +2051,7 @@ build_copy_constructor (fndecl)\n \t}\n       for (; fields; fields = TREE_CHAIN (fields))\n \t{\n-\t  tree name, init;\n+\t  tree name, init, t;\n \t  if (TREE_CODE (fields) != FIELD_DECL)\n \t    continue;\n \t  if (DECL_NAME (fields))\n@@ -2048,6 +2065,13 @@ build_copy_constructor (fndecl)\n \t      if (IDENTIFIER_CLASS_VALUE (DECL_NAME (fields)) != fields)\n \t\tcontinue;\n \t    }\n+\t  else if ((t = TREE_TYPE (fields)) != NULL_TREE\n+\t\t   && TREE_CODE (t) == UNION_TYPE\n+\t\t   && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t))\n+\t\t   && TYPE_FIELDS (t) != NULL_TREE)\n+\t    fields = largest_union_member (t);\n+\t  else\n+\t    continue;\n \n \t  init = build (COMPONENT_REF, TREE_TYPE (fields), parm, fields);\n \t  init = build_tree_list (NULL_TREE, init);\n@@ -2103,7 +2127,7 @@ build_assign_ref (fndecl)\n \t}\n       for (; fields; fields = TREE_CHAIN (fields))\n \t{\n-\t  tree comp, init;\n+\t  tree comp, init, t;\n \t  if (TREE_CODE (fields) != FIELD_DECL)\n \t    continue;\n \t  if (DECL_NAME (fields))\n@@ -2117,6 +2141,13 @@ build_assign_ref (fndecl)\n \t      if (IDENTIFIER_CLASS_VALUE (DECL_NAME (fields)) != fields)\n \t\tcontinue;\n \t    }\n+\t  else if ((t = TREE_TYPE (fields)) != NULL_TREE\n+\t\t   && TREE_CODE (t) == UNION_TYPE\n+\t\t   && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t))\n+\t\t   && TYPE_FIELDS (t) != NULL_TREE)\n+\t    fields = largest_union_member (t);\n+\t  else\n+\t    continue;\n \n \t  comp = build (COMPONENT_REF, TREE_TYPE (fields), C_C_D, fields);\n \t  init = build (COMPONENT_REF, TREE_TYPE (fields), parm, fields);"}]}