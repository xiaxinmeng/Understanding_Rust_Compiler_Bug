{"sha": "33f7f3538517099ebde6568a519d1449a08cb37d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzNmN2YzNTM4NTE3MDk5ZWJkZTY1NjhhNTE5ZDE0NDlhMDhjYjM3ZA==", "commit": {"author": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1998-03-06T14:54:07Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1998-03-06T14:54:07Z"}, "message": "rtl.h (addr_diff_vec_flags): New typedef.\n\n\t* rtl.h (addr_diff_vec_flags): New typedef.\n\t(union rtunion_def): New member rt_addr_diff_vec_flags.\n\t(ADDR_DIFF_VEC_FLAGS): New macro.\n\t* sh.c (output_branch): Fix offset overflow problems.\n\t* final.c (shorten_branches): Implement CASE_VECTOR_SHORTEN_MODE.\n\t(final_scan_insn): New argument BODY for ASM_OUTPUT_ADDR_DIFF_ELT.\n\t* rtl.def (ADDR_DIFF_VEC): Three new fields (min, max and flags).\n\t* stmt.c (expand_end_case): Supply new arguments to\n\tgen_rtx_ADDR_DIFF_VEC.\n\t* 1750a.h (ASM_OUTPUT_ADDR_DIFF_ELT): New argument BODY.\n\t* alpha.h, arc.h, clipper.h, convex.h : Likewise.\n\t* dsp16xx.h, elxsi.h, fx80.h, gmicro.h, h8300.h : Likewise.\n\t* i370.h, i386.h, i860.h, i960.h, m32r.h, m68k.h, m88k.h : Likewise.\n\t* mips.h, mn10200.h, mn10300.h, ns32k.h, pa.h, pyr.h : Likewise.\n\t* rs6000.h, sh.h, sparc.h, spur.h, tahoe.h, v850.h : Likewise.\n\t* vax.h, we32k.h, alpha/vms.h, arm/aof.h, arm/aout.h : Likewise.\n\t* i386/386bsd.h, i386/freebsd-elf.h : Likewise.\n\t* i386/freebsd.h, i386/linux.h : Likewise.\n\t* i386/netbsd.h, i386/osfrose.h, i386/ptx4-i.h, i386/sco5.h : Likewise.\n\t* i386/sysv4.h, m68k/3b1.h, m68k/dpx2.h, m68k/hp320.h : Likewise.\n\t* m68k/mot3300.h, m68k/sgs.h : Likewise.\n\t* m68k/tower-as.h, ns32k/encore.h, sparc/pbd.h : Likewise.\n\t* sh.h (INSN_ALIGN, INSN_LENGTH_ALIGNMENT): Define.\n\t(CASE_VECTOR_SHORTEN_MODE): Define.\n\t(short_cbranch_p, align_length, addr_diff_vec_adjust): Don't declare.\n\t(med_branch_p, braf_branch_p): Don't declare.\n\t(mdep_reorg_phase, barrier_align): Declare.\n\t(ADJUST_INSN_LENGTH): Remove alignment handling.\n\t* sh.c (uid_align, uid_align_max): Deleted.\n\t(max_uid_before_fixup_addr_diff_vecs, branch_offset): Deleted.\n\t(short_cbranch_p, med_branch_p, braf_branch_p, align_length): Deleted.\n\t(cache_align_p, fixup_aligns, addr_diff_vec_adjust): Deleted.\n\t(output_far_jump): Don't use braf_branch_p.\n\t(output_branchy_insn): Don't use branch_offset.\n\t(find_barrier): Remove checks for max_uid_before_fixup_addr_diff_vecs.\n\tRemove paired barrier stuff.\n\tDon't use cache_align_p.\n\tTake alignment insns into account.\n\t(fixup_addr_diff_vecs): Reduce to only fixing up the base label of\n\tthe addr_diff_vec.\n\t(barrier_align, branch_dest): New function.\n\t(machine_dependent_reorg, split_branches): Remove infrastructure\n\tfor branch shortening that is now provided in the backend.\n\t* sh.md (short_cbranch_p, med_branch_p, med_cbranch_p): New attributes.\n\t(braf_branch_p, braf_cbranch_p): Likewise.\n\t(attribute length): Use new attributes.\n\t(casesi_worker): Get mode and unsignednedd from ADDR_DIFF_VEC.\n\t(addr_diff_vec_adjust): Delete.\n\t(align_2): Now a define_expand.\n\t(align_log): Now length 0.\n\nFrom-SVN: r18433", "tree": {"sha": "c69562295412a4bbb90276f4abbb3f6d1cfe26cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c69562295412a4bbb90276f4abbb3f6d1cfe26cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33f7f3538517099ebde6568a519d1449a08cb37d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33f7f3538517099ebde6568a519d1449a08cb37d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33f7f3538517099ebde6568a519d1449a08cb37d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33f7f3538517099ebde6568a519d1449a08cb37d/comments", "author": null, "committer": null, "parents": [{"sha": "170a16c7f6f3de8ba786d3a18dab44296c387b9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/170a16c7f6f3de8ba786d3a18dab44296c387b9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/170a16c7f6f3de8ba786d3a18dab44296c387b9d"}], "stats": {"total": 1428, "additions": 681, "deletions": 747}, "files": [{"sha": "00f842f9c4ddd0293fbddf67410590bcc653730e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 56, "deletions": 1, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -1,3 +1,58 @@\n+Fri Mar  6 21:28:45 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* rtl.h (addr_diff_vec_flags): New typedef.\n+\t(union rtunion_def): New member rt_addr_diff_vec_flags.\n+\t(ADDR_DIFF_VEC_FLAGS): New macro.\n+\n+\t* sh.c (output_branch): Fix offset overflow problems.\n+\n+\t* final.c (shorten_branches): Implement CASE_VECTOR_SHORTEN_MODE.\n+\t(final_scan_insn): New argument BODY for ASM_OUTPUT_ADDR_DIFF_ELT.\n+\t* rtl.def (ADDR_DIFF_VEC): Three new fields (min, max and flags).\n+\t* stmt.c (expand_end_case): Supply new arguments to\n+\tgen_rtx_ADDR_DIFF_VEC.\n+\t* 1750a.h (ASM_OUTPUT_ADDR_DIFF_ELT): New argument BODY.\n+\t* alpha.h, arc.h, clipper.h, convex.h : Likewise.\n+\t* dsp16xx.h, elxsi.h, fx80.h, gmicro.h, h8300.h : Likewise.\n+\t* i370.h, i386.h, i860.h, i960.h, m32r.h, m68k.h, m88k.h : Likewise.\n+\t* mips.h, mn10200.h, mn10300.h, ns32k.h, pa.h, pyr.h : Likewise.\n+\t* rs6000.h, sh.h, sparc.h, spur.h, tahoe.h, v850.h : Likewise.\n+\t* vax.h, we32k.h, alpha/vms.h, arm/aof.h, arm/aout.h : Likewise.\n+\t* i386/386bsd.h, i386/freebsd-elf.h : Likewise.\n+\t* i386/freebsd.h, i386/linux.h : Likewise.\n+\t* i386/netbsd.h, i386/osfrose.h, i386/ptx4-i.h, i386/sco5.h : Likewise.\n+\t* i386/sysv4.h, m68k/3b1.h, m68k/dpx2.h, m68k/hp320.h : Likewise.\n+\t* m68k/mot3300.h, m68k/sgs.h : Likewise.\n+\t* m68k/tower-as.h, ns32k/encore.h, sparc/pbd.h : Likewise.\n+\t* sh.h (INSN_ALIGN, INSN_LENGTH_ALIGNMENT): Define.\n+\t(CASE_VECTOR_SHORTEN_MODE): Define.\n+\t(short_cbranch_p, align_length, addr_diff_vec_adjust): Don't declare.\n+\t(med_branch_p, braf_branch_p): Don't declare.\n+\t(mdep_reorg_phase, barrier_align): Declare.\n+\t(ADJUST_INSN_LENGTH): Remove alignment handling.\n+\t* sh.c (uid_align, uid_align_max): Deleted.\n+\t(max_uid_before_fixup_addr_diff_vecs, branch_offset): Deleted.\n+\t(short_cbranch_p, med_branch_p, braf_branch_p, align_length): Deleted.\n+\t(cache_align_p, fixup_aligns, addr_diff_vec_adjust): Deleted.\n+\t(output_far_jump): Don't use braf_branch_p.\n+\t(output_branchy_insn): Don't use branch_offset.\n+\t(find_barrier): Remove checks for max_uid_before_fixup_addr_diff_vecs.\n+\tRemove paired barrier stuff.\n+\tDon't use cache_align_p.\n+\tTake alignment insns into account.\n+\t(fixup_addr_diff_vecs): Reduce to only fixing up the base label of\n+\tthe addr_diff_vec.\n+\t(barrier_align, branch_dest): New function.\n+\t(machine_dependent_reorg, split_branches): Remove infrastructure\n+\tfor branch shortening that is now provided in the backend.\n+\t* sh.md (short_cbranch_p, med_branch_p, med_cbranch_p): New attributes.\n+\t(braf_branch_p, braf_cbranch_p): Likewise.\n+\t(attribute length): Use new attributes.\n+\t(casesi_worker): Get mode and unsignednedd from ADDR_DIFF_VEC.\n+\t(addr_diff_vec_adjust): Delete.\n+\t(align_2): Now a define_expand.\n+\t(align_log): Now length 0.\n+\n Fri Mar  6 14:41:33 1998  Michael Meissner  <meissner@cygnus.com>\n \n \t* m32r.md (right): Correctly check for length == 2, not 1.\n@@ -2670,7 +2725,7 @@ Fri Dec 19 17:31:11 1997  Ian Lance Taylor  <ian@cygnus.com>\n \t* stmt.c (expand_end_case): Likewise.\n \t* alpha.h (CASE_VECTOR_PC_RELATIVE): Update.\n \t* fx80.h, gmicro.h, m68k.h, m88k.h, ns32k.h: Likewise.\n-\t* rs6000.h, sh.h, tahoe.h, v850.h vax.h z8k.h: Likewise.\n+\t* rs6000.h, sh.h, tahoe.h, v850.h, vax.h: Likewise.\n \n Tue Dec 16 15:14:09 1997  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.de>\n "}, {"sha": "ad6c4be9c2e684515e8072d0472ba663009c9f61", "filename": "gcc/config/1750a/1750a.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2F1750a%2F1750a.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2F1750a%2F1750a.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -1265,7 +1265,7 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n \tfprintf (FILE, \"\\tdata\\tL%d-L%d ;addr_diff_elt\\n\", VALUE,REL)\n \n /* This is how to output an assembler line"}, {"sha": "3e52db740ad1e9ee96d6a98a8377ac1fe22b93d2", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -1984,7 +1984,7 @@ literal_section ()\t\t\t\t\t\t\\\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n   fprintf (FILE, \"\\t.%s $L%d\\n\", TARGET_WINDOWS_NT ? \"long\" : \"gprel32\", \\\n \t   (VALUE))\n "}, {"sha": "d43a60d67a2e00ae734aa43f2e2494035da0fbcb", "filename": "gcc/config/alpha/vms.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Falpha%2Fvms.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Falpha%2Fvms.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -324,7 +324,7 @@ literals_section ()\t\t\t\t\t\t\\\n }\n \n #undef ASM_OUTPUT_ADDR_DIFF_ELT\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) abort ()\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) abort ()\n \n #undef ASM_OUTPUT_ADDR_VEC_ELT\n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) \\"}, {"sha": "3d7f2b2910f5823477ac2c9f1a5264c0fd4b7b24", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -1492,7 +1492,7 @@ do {\t\t\t\t\t\t\t\\\n } while (0)\n \n /* This is how to output an element of a case-vector that is relative.  */\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n do {\t\t\t\t\t\t\t\\\n   char label[30];\t\t\t\t\t\\\n   ASM_GENERATE_INTERNAL_LABEL (label, \"L\", VALUE);\t\\"}, {"sha": "6c2185007f92d7738ca671e9388d84b12c4e6d18", "filename": "gcc/config/arm/aof.h", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Farm%2Faof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Farm%2Faof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faof.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler, for Advanced RISC Machines\n    ARM compilation, AOF Assembler.\n-   Copyright (C) 1995, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.\n    Contributed by Richard Earnshaw (rearnsha@armltd.co.uk)\n \n This file is part of GNU CC.\n@@ -60,12 +60,13 @@ char *aof_text_section ();\n char *aof_data_section ();\n #define DATA_SECTION_ASM_OP aof_data_section ()\n \n-#define EXTRA_SECTIONS in_zero_init, in_ctor, in_dtor\n+#define EXTRA_SECTIONS in_zero_init, in_ctor, in_dtor, in_common\n \n #define EXTRA_SECTION_FUNCTIONS\t\\\n ZERO_INIT_SECTION\t\t\\\n CTOR_SECTION\t\t\t\\\n-DTOR_SECTION\n+DTOR_SECTION\t\t\t\\\n+COMMON_SECTION\n \n #define ZERO_INIT_SECTION\t\t\t\t\t\\\n void\t\t\t\t\t\t\t\t\\\n@@ -118,6 +119,18 @@ dtor_section ()\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n }\n \n+/* Used by ASM_OUTPUT_COMMON (below) to tell varasm.c that we've\n+   changed areas.  */\n+#define COMMON_SECTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+common_section ()\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  static int common_count = 1;\t\t\t\t\t\\\n+  if (in_section != in_common)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      in_section = in_common;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n #define CTOR_LIST_BEGIN\t\t\t\t\t\\\n asm (CTORS_SECTION_ASM_OP);\t\t\t\t\\\n extern func_ptr __CTOR_END__[1];\t\t\t\\\n@@ -194,7 +207,7 @@ do {\t\t\t\t\t\\\n /* Some systems use __main in a way incompatible with its use in gcc, in these\n    cases use the macros NAME__MAIN to give a quoted symbol and SYMBOL__MAIN to\n    give the same symbol without quotes for an alternative entry point.  You\n-   must define both, or niether. */\n+   must define both, or neither. */\n #define NAME__MAIN \"__gccmain\"\n #define SYMBOL__MAIN __gccmain\n \n@@ -277,7 +290,8 @@ do {\t\t\t\t\t\t\t\\\n /* Output of Uninitialized Variables */\n \n #define ASM_OUTPUT_COMMON(STREAM,NAME,SIZE,ROUNDED)\t\t\\\n-  (fprintf ((STREAM), \"\\tAREA \"),\t\t\t\t\\\n+  (common_section (),\t\t\t\t\t\t\\\n+   fprintf ((STREAM), \"\\tAREA \"),\t\t\t\t\\\n    assemble_name ((STREAM), (NAME)),\t\t\t\t\\\n    fprintf ((STREAM), \", DATA, COMMON\\n\\t%% %d\\t%s size=%d\\n\",\t\\\n \t    (ROUNDED), ASM_COMMENT_START, SIZE))\n@@ -302,7 +316,7 @@ do {\t\t\t\t\t\t\t\\\n     arm_main_function = 1;\t\t\t\t\\\n } while (0)\n \n-#define ARM_OUTPUT_LABEL(STREAM,NAME)\t\\\n+#define ASM_OUTPUT_LABEL(STREAM,NAME)\t\\\n do {\t\t\t\t\t\\\n   assemble_name (STREAM,NAME);\t\t\\\n   fputs (\"\\n\", STREAM);\t\t\t\\\n@@ -408,7 +422,7 @@ do {\t\t\t\t\t\t\\\n \n /* Output of Dispatch Tables */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM,VALUE,REL)\t\t\\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM,BODY,VALUE,REL)\t\t\\\n   fprintf ((STREAM), \"\\tb\\t|L..%d|\\n\", (VALUE))\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(STREAM,VALUE)\t\\"}, {"sha": "5d3d78959be8bb9f86f3fe6dd09a9fd32a523b1b", "filename": "gcc/config/arm/aout.h", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Farm%2Faout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Farm%2Faout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faout.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -114,7 +114,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define ASM_DECLARE_FUNCTION_NAME(STREAM,NAME,DECL) \\\n     ASM_OUTPUT_LABEL(STREAM, NAME)\n \n-#define ARM_OUTPUT_LABEL(STREAM,NAME)\t\\\n+#define ASM_OUTPUT_LABEL(STREAM,NAME)\t\\\n do {\t\t\t\t\t\\\n   assemble_name (STREAM,NAME);\t\t\\\n   fputs (\":\\n\", STREAM);\t\t\\\n@@ -143,7 +143,7 @@ do {\t\t\t\t\t\\\n #define ASM_OUTPUT_ADDR_VEC_ELT(STREAM,VALUE)  \\\n    fprintf (STREAM, \"\\t.word\\t%sL%d\\n\", LOCAL_LABEL_PREFIX, VALUE)\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM,VALUE,REL)  \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM,BODY,VALUE,REL)  \\\n    fprintf (STREAM, \"\\tb\\t%sL%d\\n\", LOCAL_LABEL_PREFIX, (VALUE))\n \n /* Output various types of constants.  For real numbers we output hex, with\n@@ -224,10 +224,15 @@ do { char dstr[30];\t\t\t\t\t\t\t\\\n    assemble_name ((STREAM), (NAME)),\t\t     \t\t\t\\\n    fprintf(STREAM, \", %d\\t%s %d\\n\", ROUNDED, ASM_COMMENT_START, SIZE))\n \n-/* Output a local common block.  /bin/as can't do this, so hack a `.space' into\n-   the bss segment.  Note that this is *bad* practice.  */\n-#define ASM_OUTPUT_ALIGNED_LOCAL(STREAM,NAME,SIZE,ALIGN)  \\\n-  output_lcomm_directive (STREAM, NAME, SIZE, ALIGN)\n+/* Output a local common block.  /bin/as can't do this, so hack a\n+   `.space' into the bss segment.  Note that this is *bad* practice.  */\n+#define ASM_OUTPUT_ALIGNED_LOCAL(STREAM,NAME,SIZE,ALIGN)\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    bss_section ();\t\t\t\t\t\t\t\\\n+    ASM_OUTPUT_ALIGN (STREAM, floor_log2 (ALIGN / BITS_PER_UNIT));\t\\\n+    ASM_OUTPUT_LABEL (STREAM, NAME);\t\t\t\t\t\\\n+    fprintf (STREAM, \"\\t.space\\t%d\\n\", SIZE);\t\t\t\t\\\n+  } while (0)\n \n /* Output a zero-initialized block.  */\n #define ASM_OUTPUT_ALIGNED_BSS(STREAM,DECL,NAME,SIZE,ALIGN) \\"}, {"sha": "407caa2345fc2232964dac14218bd87a82b2a22c", "filename": "gcc/config/clipper/clipper.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fclipper%2Fclipper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fclipper%2Fclipper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fclipper.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -1045,7 +1045,7 @@ do\t\t\t\t\t\t\t\t\t      \\\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n   fprintf (FILE, \"\\t.word .L%d-.L%d\\n\", VALUE, REL)\n \n /* This is how to output an assembler line"}, {"sha": "42aec68d6fe2630e21b06ec9b774e1c34cd3ab14", "filename": "gcc/config/convex/convex.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fconvex%2Fconvex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fconvex%2Fconvex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -1402,7 +1402,7 @@ extern double atof();\n /* This is how to output an element of a case-vector that is relative.  \n    (not used on Convex) */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n   fprintf (FILE, \"\\tds.w L%d-L%d\\n\", VALUE, REL)\n \n /* This is how to output an assembler line"}, {"sha": "1c0f4dd53085aacbdad099cd1d3f40311aba16e6", "filename": "gcc/config/dsp16xx/dsp16xx.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -1880,7 +1880,7 @@ const_section ()                                                   \\\n \n /* This macro should be provided on machines where the addresses in a dispatch\n    table are relative to the table's own address. */\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n   fprintf (FILE, \"\\tint L%d-L%d\\n\", VALUE, REL)\n \n /* This macro should be provided on machines where the addresses in a dispatch"}, {"sha": "5d35acef74f9e756aaa0e04fe4c81bf4505d5786", "filename": "gcc/config/elxsi/elxsi.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Felxsi%2Felxsi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Felxsi%2Felxsi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felxsi%2Felxsi.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -875,7 +875,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n   fprintf (FILE, \"\\t.data .L%d-.L%d{32}\\n\", VALUE, REL)\n \n /* This is how to output an assembler line"}, {"sha": "0826236b6442ac62a7194157ad2cfa77aabb338f", "filename": "gcc/config/fx80/fx80.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Ffx80%2Ffx80.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Ffx80%2Ffx80.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffx80%2Ffx80.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -1153,7 +1153,7 @@ do { int i; unsigned char *pp = (unsigned char *) (PTR);\t\\\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n   fprintf (FILE, \"\\t.word L%d-L%d\\n\", VALUE, REL)\n \n /* This is how to output an assembler line"}, {"sha": "2c44dd03aff18a1500c3a48f36fe691c58611f11", "filename": "gcc/config/gmicro/gmicro.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fgmicro%2Fgmicro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fgmicro%2Fgmicro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgmicro%2Fgmicro.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -1444,7 +1444,7 @@ do { union { float f; long l;} tem;\t\t\t\\\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n   fprintf (FILE, \"\\t.data.w L%d-L%d\\n\", VALUE, REL)\n \n "}, {"sha": "6315684577a0e9823ee4a85a0b98953ac98fb308", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -1273,7 +1273,7 @@ do { char dstr[30];\t\t\t\t\t\\\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n   fprintf (FILE, \"\\t%s .L%d-.L%d\\n\", ASM_WORD_OP, VALUE, REL)\n \n /* This is how to output an assembler line"}, {"sha": "8f7658f7cb943ca25f6175d75b9cd98ef156de86", "filename": "gcc/config/i370/i370.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fi370%2Fi370.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fi370%2Fi370.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -1029,7 +1029,7 @@ enum reg_class\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \t\t\t\\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \t\t\\\n   mvs_check_page (FILE, 4, 0);\t\t\t\t\t\t\\\n   fprintf (FILE, \"\\tDC\\tA(L%d-L%d)\\n\", VALUE, REL)\n "}, {"sha": "25994376aea2c1043c4dcf622f0c7cea23ca6cb1", "filename": "gcc/config/i386/386bsd.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fi386%2F386bsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fi386%2F386bsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2F386bsd.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -63,7 +63,7 @@\n    i386.md for an explanation of the expression this outputs. */\n \n #undef ASM_OUTPUT_ADDR_DIFF_ELT\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n   fprintf (FILE, \"\\t.long _GLOBAL_OFFSET_TABLE_+[.-%s%d]\\n\", LPREFIX, VALUE)\n \n /* Indicate that jump tables go in the text section.  This is"}, {"sha": "b0abdf262fcc5064f3727ff1633040a542b1e8e4", "filename": "gcc/config/i386/freebsd-elf.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fi386%2Ffreebsd-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fi386%2Ffreebsd-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ffreebsd-elf.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -2,7 +2,7 @@\n    Copyright (C) 1996 Free Software Foundation, Inc.\n    Contributed by Eric Youngdale.\n    Modified for stabs-in-ELF by H.J. Lu.\n-   Adapted from Linux version by John Polstra.\n+   Adapted from GNU/Linux version by John Polstra.\n \n This file is part of GNU CC.\n \n@@ -33,7 +33,7 @@ Boston, MA 02111-1307, USA.  */\n    This is only used for PIC code.  See comments by the `casesi' insn in\n    i386.md for an explanation of the expression this outputs. */\n #undef ASM_OUTPUT_ADDR_DIFF_ELT\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n   fprintf (FILE, \"\\t.long _GLOBAL_OFFSET_TABLE_+[.-%s%d]\\n\", LPREFIX, VALUE)\n \n /* Indicate that jump tables go in the text section.  This is"}, {"sha": "1156f19ea917735a44ca0a7975b22fb721f0def4", "filename": "gcc/config/i386/freebsd.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fi386%2Ffreebsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fi386%2Ffreebsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ffreebsd.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -75,7 +75,7 @@ Boston, MA 02111-1307, USA.  */\n    i386.md for an explanation of the expression this outputs. */\n \n #undef ASM_OUTPUT_ADDR_DIFF_ELT\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n   fprintf (FILE, \"\\t.long _GLOBAL_OFFSET_TABLE_+[.-%s%d]\\n\", LPREFIX, VALUE)\n \n /* Indicate that jump tables go in the text section.  This is"}, {"sha": "fad11838780c76cbd5e0445ea18a92360e9e2ce9", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -2484,7 +2484,7 @@ do { long l;\t\t\t\t\t\t\\\n    forward reference the differences.  \n  */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n   fprintf (FILE, \"\\t.word %s%d-%s%d\\n\",LPREFIX, VALUE,LPREFIX, REL)\n \n /* Define the parentheses used to group arithmetic operations"}, {"sha": "4b23b91bf2cebb4bf3a2554d4df7e99b80b72dc6", "filename": "gcc/config/i386/linux.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fi386%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fi386%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Flinux.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -41,7 +41,7 @@ Boston, MA 02111-1307, USA.  */\n    This is only used for PIC code.  See comments by the `casesi' insn in\n    i386.md for an explanation of the expression this outputs. */\n #undef ASM_OUTPUT_ADDR_DIFF_ELT\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n   fprintf (FILE, \"\\t.long _GLOBAL_OFFSET_TABLE_+[.-%s%d]\\n\", LPREFIX, VALUE)\n \n /* Indicate that jump tables go in the text section.  This is"}, {"sha": "1c3353e9045534c7281b04a27e09696270159bb5", "filename": "gcc/config/i386/netbsd.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fi386%2Fnetbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fi386%2Fnetbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fnetbsd.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -44,7 +44,7 @@\n    i386.md for an explanation of the expression this outputs. */\n \n #undef ASM_OUTPUT_ADDR_DIFF_ELT\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n   fprintf (FILE, \"\\t.long _GLOBAL_OFFSET_TABLE_+[.-%s%d]\\n\", LPREFIX, VALUE)\n \n /* Indicate that jump tables go in the text section.  This is"}, {"sha": "e2e6231ed877e37fe97c34a1f5a1bfd98993fdbe", "filename": "gcc/config/i386/osfrose.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fi386%2Fosfrose.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fi386%2Fosfrose.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fosfrose.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -381,7 +381,7 @@ while (0)\n    i386.md for an explanation of the expression this outputs. */\n \n #undef ASM_OUTPUT_ADDR_DIFF_ELT\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n   fprintf (FILE, \"\\t.long _GLOBAL_OFFSET_TABLE_+[.-%s%d]\\n\", LPREFIX, VALUE)\n \n /* Output a definition */"}, {"sha": "8ac98bedde2ca526909e6438e4ff08a8c320945a", "filename": "gcc/config/i386/ptx4-i.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fi386%2Fptx4-i.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fi386%2Fptx4-i.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fptx4-i.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -238,7 +238,7 @@ do { long value[3];\t\t\t\t\t\t\t\\\n    i386.md for an explanation of the expression this outputs. */\n \n #undef ASM_OUTPUT_ADDR_DIFF_ELT\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n   fprintf (FILE, \"\\t.long _GLOBAL_OFFSET_TABLE_+[.-%s%d]\\n\", LPREFIX, VALUE)\n \n /* Indicate that jump tables go in the text section.  This is"}, {"sha": "70d1bdd66c279cfad4c7ca60d8b62ef3608e642a", "filename": "gcc/config/i386/sco5.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fi386%2Fsco5.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fi386%2Fsco5.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsco5.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -243,7 +243,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n } while (0)\n \n #undef ASM_OUTPUT_ADDR_DIFF_ELT\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n do {\t\t\t\t\t\t\t\t\t\\\n   if (TARGET_ELF)\t\t\t\t\t\t\t\\\n     fprintf (FILE, \"%s _GLOBAL_OFFSET_TABLE_+[.-%s%d]\\n\", ASM_LONG, LPREFIX, VALUE); \\"}, {"sha": "d05280a76fdf3ff0400c15be52426f8155322f8c", "filename": "gcc/config/i386/sysv4.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fi386%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fi386%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsysv4.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -236,7 +236,7 @@ do { long value[3];\t\t\t\t\t\t\t\\\n    i386.md for an explanation of the expression this outputs. */\n \n #undef ASM_OUTPUT_ADDR_DIFF_ELT\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n   fprintf (FILE, \"\\t.long _GLOBAL_OFFSET_TABLE_+[.-%s%d]\\n\", LPREFIX, VALUE)\n \n /* Indicate that jump tables go in the text section.  This is"}, {"sha": "8486d8d656dfca783390f0a875228559beda4114", "filename": "gcc/config/i860/i860.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fi860%2Fi860.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fi860%2Fi860.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -1146,7 +1146,7 @@ do { ASM_OUTPUT_ALIGN ((FILE), 2);\t\t\t\t\t\\\n    (The i860 does not use such vectors,\n    but we must define this macro anyway.)  */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n   fprintf (FILE, \"\\t.word .L%d-.L%d\\n\", VALUE, REL)\n \n /* This is how to output an assembler line"}, {"sha": "556c755ea721698af01474a515a22829ce9c45c9", "filename": "gcc/config/i960/i960.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fi960%2Fi960.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fi960%2Fi960.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -1348,7 +1348,7 @@ extern struct rtx_def *gen_compare_reg ();\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n   fprintf (FILE, \"\\t.word L%d-L%d\\n\", VALUE, REL)\n \n /* This is how to output an assembler line that says to advance the"}, {"sha": "79233e5d56054db8c7a61ee266085b2a810090fd", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -1661,7 +1661,7 @@ do {\t\t\t\t\t\t\t\\\n } while (0)\n \n /* This is how to output an element of a case-vector that is relative.  */\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n do {\t\t\t\t\t\t\t\\\n   char label[30];\t\t\t\t\t\\\n   ASM_GENERATE_INTERNAL_LABEL (label, \"L\", VALUE);\t\\"}, {"sha": "2b6611ae814fc23e62386d5f8b6a07713b42a42a", "filename": "gcc/config/m68k/3b1.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fm68k%2F3b1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fm68k%2F3b1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2F3b1.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -364,7 +364,7 @@ do { long l;\t\t\t\t\t\\\n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)\t\\\n     fprintf (FILE, \"\\tlong L%%%d\\n\", (VALUE))\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)\t\\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)\t\\\n     fprintf (FILE, \"\\tshort L%%%d-L%%%d\\n\", (VALUE), (REL))\n \n /* ihnp4!lmayk!lgm says that `short 0' triggers assembler bug;"}, {"sha": "b3779743532176f1bbd9280720b420702c672f36", "filename": "gcc/config/m68k/dpx2.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fm68k%2Fdpx2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fm68k%2Fdpx2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fdpx2.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -605,7 +605,7 @@ do { long l;\t\t\t\t\t\t\\\n \n /* This is how to output an element of a case-vector that is relative.  */\n #undef ASM_OUTPUT_ADDR_DIFF_ELT\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n   asm_fprintf (FILE, \"\\tdc.w %LL%d-%LL%d\\n\", VALUE, REL)\n \n /* Currently, JUMP_TABLES_IN_TEXT_SECTION must be defined in order to"}, {"sha": "98165029962b7e584461973d7bbca4b0d4bba110", "filename": "gcc/config/m68k/hp320.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fm68k%2Fhp320.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fm68k%2Fhp320.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fhp320.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -316,7 +316,7 @@ do { long l[3];\t\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n   fprintf (FILE, \"\\tlong L%d\\n\", VALUE)\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n   fprintf (FILE, \"\\tshort L%d-L%d\\n\", VALUE, REL)\n \n #define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\"}, {"sha": "600fab430c7a56eabbd2e736e04860b4f6d47c0e", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -1920,7 +1920,7 @@ do { long l;\t\t\t\t\t\t\\\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n   asm_fprintf (FILE, \"\\t.word %LL%d-%LL%d\\n\", VALUE, REL)\n \n /* This is how to output an assembler line"}, {"sha": "e1b4060080844a9df0ec87530f0902653d0a5f0c", "filename": "gcc/config/m68k/mot3300.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fm68k%2Fmot3300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fm68k%2Fmot3300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fmot3300.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -547,7 +547,7 @@ do { long l;\t\t\t\t\t\\\n /* This is how to output an element of a case-vector that is relative.  */\n \n #undef ASM_OUTPUT_ADDR_DIFF_ELT\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)\t\\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)\t\\\n     asm_fprintf (FILE, \"\\t%s %LL%d-%LL%d\\n\", ASM_SHORT, (VALUE), (REL))\n \n #ifndef USE_GAS"}, {"sha": "62d2336fc580ec9880018b4f510671a05e2abb59", "filename": "gcc/config/m68k/sgs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fm68k%2Fsgs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fm68k%2Fsgs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fsgs.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -427,7 +427,7 @@ extern int switch_table_difference_label_flag;\n /* This is how to output an element of a case-vector that is relative.  */\n \n #undef ASM_OUTPUT_ADDR_DIFF_ELT\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)\t\\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)\t\\\n   asm_fprintf (FILE, \"\\t%s %LL%d-%LL%d\\n\", WORD_ASM_OP, VALUE, REL)\n \n /* Currently, JUMP_TABLES_IN_TEXT_SECTION must be defined in order to"}, {"sha": "7b5771a1ef45d3e23015f1d77fce140f97e76314", "filename": "gcc/config/m68k/tower-as.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fm68k%2Ftower-as.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fm68k%2Ftower-as.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Ftower-as.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -315,7 +315,7 @@ do { long l;\t\t\t\t\t\\\n   fprintf (FILE, \"\\tlong L%%%d\\n\", (VALUE))\n \n #undef ASM_OUTPUT_ADDR_DIFF_ELT\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n   fprintf (FILE, \"\\tshort L%%%d-L%%%d\\n\", (VALUE), (REL))\n \n #undef ASM_OUTPUT_ALIGN"}, {"sha": "e35b87e70d77a10e35ad4279e67cfb1404a8726d", "filename": "gcc/config/m88k/m88k.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fm88k%2Fm88k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fm88k%2Fm88k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -198,13 +198,13 @@ extern char * reg_names[];\n    Redefined in sysv4.h, and luna.h.  */\n #define VERSION_INFO1\t\"m88k, \"\n #ifndef VERSION_INFO2\n-#define VERSION_INFO2   \"$Revision: 1.4 $\"\n+#define VERSION_INFO2   \"$Revision: 1.11 $\"\n #endif\n \n #ifndef VERSION_STRING\n #define VERSION_STRING  version_string\n #ifdef __STDC__\n-#define TM_RCS_ID      \"@(#)\" __FILE__ \" $Revision: 1.4 $ \" __DATE__\n+#define TM_RCS_ID      \"@(#)\" __FILE__ \" $Revision: 1.11 $ \" __DATE__\n #else\n #define TM_RCS_ID      \"$What: <@(#) m88k.h,v\t1.1.1.2.2.2> $\"\n #endif  /* __STDC__ */\n@@ -2199,7 +2199,7 @@ do {\t\t\t\t\t\t\t\t\t \\\n   } while (0)\n \n /* This is how to output an element of a case-vector that is relative.  */\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n   ASM_OUTPUT_ADDR_VEC_ELT (FILE, VALUE)\n \n /* This is how to output an assembler line"}, {"sha": "92368f65eb4ca44f911e3cf8ec6f3f3c9e62aa1b", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -4154,7 +4154,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n    This is used for pc-relative code (e.g. when TARGET_ABICALLS or\n    TARGET_EMBEDDED_PIC).  */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, VALUE, REL)\t\t\t\\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, BODY, VALUE, REL)\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   if (TARGET_MIPS16)\t\t\t\t\t\t\t\\\n     fprintf (STREAM, \"\\t.half\\t%sL%d-%sL%d\\n\",\t\t\t\t\\"}, {"sha": "20db8a5ad0955b1fdade31edc6b9c21c71747571", "filename": "gcc/config/mn10200/mn10200.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fmn10200%2Fmn10200.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fmn10200%2Fmn10200.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fmn10200.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -946,7 +946,7 @@ do { char dstr[30];\t\t\t\t\t\\\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n   fprintf (FILE, \"\\t%s .L%d-.L%d\\n\", \".long\", VALUE, REL)\n \n #define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\"}, {"sha": "ac1fe2e025afa3d5cec1bb7a65f8d1921e207c52", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -929,7 +929,7 @@ do { char dstr[30];\t\t\t\t\t\\\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n   fprintf (FILE, \"\\t%s .L%d-.L%d\\n\", \".long\", VALUE, REL)\n \n #define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\"}, {"sha": "31e28946e4f69b2e5f72b3e61ada5d128ba3d604", "filename": "gcc/config/ns32k/encore.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fns32k%2Fencore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fns32k%2Fencore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fencore.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -90,7 +90,7 @@ output_file_directive ((FILE), main_input_filename)\n \tsprintf (LABEL, \"*.%s%d\", PREFIX, NUM)\n #define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\t\t\\\n \tfprintf (FILE, \".%s%d:\\n\", PREFIX, NUM)\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)\t\t\t\\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)\t\t\\\n \tfprintf (FILE, \"\\t.double .L%d-.LI%d\\n\", VALUE, REL)\n \n /*"}, {"sha": "7c138a4d18b3605deadc286ddf98fc9285688660", "filename": "gcc/config/ns32k/ns32k.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fns32k%2Fns32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fns32k%2Fns32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -1396,7 +1396,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* This is how to output an element of a case-vector that is relative.  */\n /* ** Notice that the second element is LI format! */\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n   fprintf (FILE, \"\\t.long L%d-LI%d\\n\", VALUE, REL)\n \n /* This is how to output an assembler line"}, {"sha": "4a0b43cb333efa90cf7f9bd7e5b0409ea4ad1195", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -2269,7 +2269,7 @@ DTORS_SECTION_FUNCTION\n    on the PA since ASM_OUTPUT_ADDR_VEC_ELT uses pc-relative jump instructions\n    rather than a table of absolute addresses.  */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n   if (TARGET_BIG_SWITCH)\t\t\t\t\t\\\n     fprintf (FILE, \"\\tstw %%r1,-16(%%r30)\\n\\tldw T'L$%04d(%%r19),%%r1\\n\\tbv 0(%%r1)\\n\\tldw -16(%%r30),%%r1\\n\", VALUE);\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\\"}, {"sha": "a6194851599e214db0839c312ac6bf3d9b3b1d8c", "filename": "gcc/config/pyr/pyr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fpyr%2Fpyr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fpyr%2Fpyr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpyr%2Fpyr.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -1258,7 +1258,7 @@ extern int swap_operands;\n /* This is how to output an element of a case-vector that is relative.  */\n \n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n   fprintf (FILE, \"\\t.word L%d-L%d\\n\", VALUE, REL)\n \n /* This is how to output an assembler line"}, {"sha": "0982a641fbaeb2a26cd29989ee778ce6ea19de6b", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -2957,7 +2957,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)\t\\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)\\\n   do { char buf[100];\t\t\t\t\t\\\n        fputs ((TARGET_32BIT) ? \"\\t.long \" : \"\\t.llong \", FILE);\t\\\n        ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", VALUE);\t\\"}, {"sha": "ee97013208ae7435bedd2fadcb0bbc7cc66bf80e", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 171, "deletions": 576, "changes": 747, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -87,8 +87,6 @@ rtx sh_compare_op0;\n rtx sh_compare_op1;\n \n enum machine_mode sh_addr_diff_vec_mode;\n-rtx *uid_align;\n-int uid_align_max;\n \n /* Provides the class number of the smallest class containing\n    reg number.  */\n@@ -550,10 +548,11 @@ output_far_jump (insn, op)\n   struct { rtx lab, reg, op; } this;\n   char *jump;\n   int far;\n+  int offset = branch_dest (insn) - insn_addresses[INSN_UID (insn)];\n \n   this.lab = gen_label_rtx ();\n \n-  if (braf_branch_p (insn, 0))\n+  if (offset >= -32764 && offset - get_attr_length (insn) <= 32766)\n     {\n       far = 0;\n       jump = \"mov.w\t%O0,%1;braf\t%1\";\n@@ -606,57 +605,52 @@ output_branch (logic, insn, operands)\n      rtx insn;\n      rtx *operands;\n {\n-  int offset\n-    = (insn_addresses[INSN_UID (XEXP (XEXP (SET_SRC (PATTERN (insn)), 1), 0))]\n-       - insn_addresses[INSN_UID (insn)]);\n-\n-  if (offset == 260\n-      && final_sequence\n-      && ! INSN_ANNULLED_BRANCH_P (XVECEXP (final_sequence, 0, 0)))\n-    {\n-      /* The filling of the delay slot has caused a forward branch to exceed\n-\t its range.\n-         Just emit the insn from the delay slot in front of the branch.  */\n-      /* The call to print_slot will clobber the operands.  */\n-      rtx op0 = operands[0];\n-      print_slot (final_sequence);\n-      operands[0] = op0;\n-    }\n-  else if (offset < -252 || offset > 258)\n+  switch (get_attr_length (insn))\n     {\n-      /* This can happen when other condbranches hoist delay slot insn\n+    case 6:\n+      /* This can happen if filling the delay slot has caused a forward\n+\t branch to exceed its range (we could reverse it, but only\n+\t when we know we won't overextend other branches; this should\n+\t best be handled by relaxation).\n+\t It can also happen when other condbranches hoist delay slot insn\n \t from their destination, thus leading to code size increase.\n \t But the branch will still be in the range -4092..+4098 bytes.  */\n \n-      int label = lf++;\n-      /* The call to print_slot will clobber the operands.  */\n-      rtx op0 = operands[0];\n-\n-      /* If the instruction in the delay slot is annulled (true), then\n-\t there is no delay slot where we can put it now.  The only safe\n-\t place for it is after the label.  final will do that by default.  */\n-\n-      if (final_sequence\n-\t  && ! INSN_ANNULLED_BRANCH_P (XVECEXP (final_sequence, 0, 0)))\n+      if (! TARGET_RELAX)\n \t{\n-\t  asm_fprintf (asm_out_file, \"\\tb%s%ss\\t%LLF%d\\n\", logic ? \"f\" : \"t\",\n-\t\t       ASSEMBLER_DIALECT ? \"/\" : \".\", label);\n-\t  print_slot (final_sequence);\n+\t  int label = lf++;\n+\t  /* The call to print_slot will clobber the operands.  */\n+\t  rtx op0 = operands[0];\n+    \n+\t  /* If the instruction in the delay slot is annulled (true), then\n+\t     there is no delay slot where we can put it now.  The only safe\n+\t     place for it is after the label.  final will do that by default.  */\n+    \n+\t  if (final_sequence\n+\t      && ! INSN_ANNULLED_BRANCH_P (XVECEXP (final_sequence, 0, 0)))\n+\t    {\n+\t      asm_fprintf (asm_out_file, \"\\tb%s%ss\\t%LLF%d\\n\", logic ? \"f\" : \"t\",\n+\t                   ASSEMBLER_DIALECT ? \"/\" : \".\", label);\n+\t      print_slot (final_sequence);\n+\t    }\n+\t  else\n+\t    asm_fprintf (asm_out_file, \"\\tb%s\\t%LLF%d\\n\", logic ? \"f\" : \"t\", label);\n+    \n+\t  output_asm_insn (\"bra\\t%l0\", &op0);\n+\t  fprintf (asm_out_file, \"\\tnop\\n\");\n+\t  ASM_OUTPUT_INTERNAL_LABEL(asm_out_file, \"LF\", label);\n+    \n+\t  return \"\";\n \t}\n-      else\n-\tasm_fprintf (asm_out_file, \"\\tb%s\\t%LLF%d\\n\", logic ? \"f\" : \"t\", label);\n-\n-      output_asm_insn (\"bra\\t%l0\", &op0);\n-      fprintf (asm_out_file, \"\\tnop\\n\");\n-      ASM_OUTPUT_INTERNAL_LABEL(asm_out_file, \"LF\", label);\n-\n-      return \"\";\n+      /* When relaxing, handle this like a short branch.  The linker\n+\t will fix it up if it still doesn't fit after relaxation.  */\n+    case 2:\n+      return logic ? \"bt%.\\t%l0\" : \"bf%.\\t%l0\";\n+    default:\n+      abort ();\n     }\n-  return logic ? \"bt%.\\t%l0\" : \"bf%.\\t%l0\";\n }\n \n-int branch_offset ();\n-\n char *\n output_branchy_insn (code, template, insn, operands)\n      char *template;\n@@ -679,8 +673,9 @@ output_branchy_insn (code, template, insn, operands)\n \t}\n       else\n \t{\n-\t  int offset = branch_offset (next_insn) + 4;\n-\t  if (offset >= -252 && offset <= 256)\n+\t  int offset = (branch_dest (next_insn)\n+\t\t\t- insn_addresses[INSN_UID (next_insn)] + 4);\n+\t  if (offset >= -252 && offset <= 258)\n \t    {\n \t      if (GET_CODE (src) == IF_THEN_ELSE)\n \t\t/* branch_true */\n@@ -1694,8 +1689,6 @@ typedef struct\n static pool_node pool_vector[MAX_POOL_SIZE];\n static int pool_size;\n \n-static int max_uid_before_fixup_addr_diff_vecs;\n-\n /* ??? If we need a constant in HImode which is the truncated value of a\n    constant we need in SImode, we could combine the two entries thus saving\n    two bytes.  Is this common enough to be worth the effort of implementing\n@@ -1860,24 +1853,6 @@ broken_move (insn)\n   return 0;\n }\n \n-int\n-cache_align_p (insn)\n-     rtx insn;\n-{\n-  rtx pat;\n-\n-  if (! insn)\n-    return 1;\n-\n-  if (GET_CODE (insn) != INSN)\n-    return 0;\n-\n-  pat = PATTERN (insn);\n-  return (GET_CODE (pat) == UNSPEC_VOLATILE\n-\t  && XINT (pat, 1) == 1\n-\t  && INTVAL (XVECEXP (pat, 0, 0)) == CACHE_LOG);\n-}\n-\n static int\n mova_p (insn)\n      rtx insn;\n@@ -1901,6 +1876,8 @@ find_barrier (num_mova, mova, from)\n   int count_hi = 0;\n   int found_hi = 0;\n   int found_si = 0;\n+  int hi_align = 2;\n+  int si_align = 2;\n   int leading_mova = num_mova;\n   rtx barrier_before_mova, found_barrier = 0, good_barrier = 0;\n   int si_limit;\n@@ -1927,21 +1904,21 @@ find_barrier (num_mova, mova, from)\n \n   while (from && count_si < si_limit && count_hi < hi_limit)\n     {\n-      int inc = 0;\n+      int inc = get_attr_length (from);\n+      int new_align = 1;\n \n-      /* The instructions created by fixup_addr_diff_vecs have no valid length\n-       info yet.  They should be considered to have zero at this point.  */\n-      if (INSN_UID (from) < max_uid_before_fixup_addr_diff_vecs)\n-\tinc = get_attr_length (from);\n+      if (GET_CODE (from) == CODE_LABEL)\n+\tnew_align = optimize ? 1 << label_to_alignment (from) : 1;\n \n       if (GET_CODE (from) == BARRIER)\n \t{\n+\n \t  found_barrier = from;\n+\n \t  /* If we are at the end of the function, or in front of an alignment\n \t     instruction, we need not insert an extra alignment.  We prefer\n \t     this kind of barrier.  */\n-\t\n-\t  if (cache_align_p (next_real_insn (found_barrier)))\n+\t  if (barrier_align (from) > 2)\n \t    good_barrier = from;\n \t}\n \n@@ -1971,6 +1948,8 @@ find_barrier (num_mova, mova, from)\n \t    }\n \t  else\n \t    {\n+\t      while (si_align > 2 && found_si + si_align - 2 > count_si)\n+\t\tsi_align >>= 1;\n \t      if (found_si > count_si)\n \t\tcount_si = found_si;\n \t      found_si += GET_MODE_SIZE (mode);\n@@ -1979,10 +1958,7 @@ find_barrier (num_mova, mova, from)\n \t    }\n \t}\n \n-      if (GET_CODE (from) == INSN\n-\t  && GET_CODE (PATTERN (from)) == SET\n-\t  && GET_CODE (SET_SRC (PATTERN (from))) == UNSPEC\n-\t  && XINT (SET_SRC (PATTERN (from)), 1) == 1)\n+      if (mova_p (from))\n \t{\n \t  if (! num_mova++)\n \t    {\n@@ -1999,7 +1975,7 @@ find_barrier (num_mova, mova, from)\n \t{\n \t  if (num_mova)\n \t    num_mova--;\n-\t  if (cache_align_p (NEXT_INSN (next_nonnote_insn (from))))\n+\t  if (found_barrier == good_barrier)\n \t    {\n \t      /* We have just passed the barrier in front front of the\n \t\t ADDR_DIFF_VEC.  Since the ADDR_DIFF_VEC is accessed\n@@ -2008,15 +1984,32 @@ find_barrier (num_mova, mova, from)\n \t\t If we waited any longer, we could end up at a barrier in\n \t\t front of code, which gives worse cache usage for separated\n \t\t instruction / data caches.  */\n-\t      good_barrier = found_barrier;\n \t      break;\n \t    }\n \t}\n \n       if (found_si)\n-\tcount_si += inc;\n+\t{\n+\t  if (new_align > si_align)\n+\t    {\n+\t      count_si = count_si + new_align - 1 & -si_align;\n+\t      si_align = new_align;\n+\t    }\n+\t  else\n+\t    count_si = count_si + new_align - 1 & -new_align;\n+\t  count_si += inc;\n+\t}\n       if (found_hi)\n-\tcount_hi += inc;\n+\t{\n+\t  if (new_align > hi_align)\n+\t    {\n+\t      count_hi = count_hi + new_align - 1 & -hi_align;\n+\t      hi_align = new_align;\n+\t    }\n+\t  else\n+\t    count_hi = count_hi + new_align - 1 & -new_align;\n+\t  count_hi += inc;\n+\t}\n       from = NEXT_INSN (from);\n     }\n \n@@ -2039,21 +2032,8 @@ find_barrier (num_mova, mova, from)\n \n   if (found_barrier)\n     {\n-      /* We have before prepared barriers to come in pairs, with an\n-\t alignment instruction in-between.  We want to use the first\n-\t barrier, so that the alignment applies to the code.\n-\t If we are compiling for SH3 or newer, there are some exceptions\n-\t when the second barrier and the alignment doesn't exist yet, so\n-\t we have to add it.  */\n-      if (good_barrier)\n+      if (good_barrier && next_real_insn (found_barrier))\n \tfound_barrier = good_barrier;\n-      else if (! TARGET_SMALLCODE)\n-\t{\n-\t  found_barrier\n-\t    = emit_insn_before (gen_align_log (GEN_INT (CACHE_LOG)),\n-\t\t\t\tfound_barrier);\n-\t  found_barrier = emit_barrier_before (found_barrier);\n-\t}\n     }\n   else\n     {\n@@ -2083,11 +2063,6 @@ find_barrier (num_mova, mova, from)\n       LABEL_NUSES (label) = 1;\n       found_barrier = emit_barrier_after (from);\n       emit_label_after (label, found_barrier);\n-      if (! TARGET_SMALLCODE)\n-\t{\n-\t  emit_barrier_after (found_barrier);\n-\t  emit_insn_after (gen_align_log (GEN_INT (CACHE_LOG)), found_barrier);\n-\t}\n     }\n \n   return found_barrier;\n@@ -2470,227 +2445,116 @@ gen_far_branch (bp)\n   gen_block_redirect (jump, bp->address += 2, 2);\n }\n \n-static void\n-fixup_aligns ()\n-{\n-  rtx insn = get_last_insn ();\n-  rtx align_tab[MAX_BITS_PER_WORD];\n-  int i;\n-\n-  for (i = CACHE_LOG; i >= 0; i--)\n-    align_tab[i] = insn;\n-  bzero ((char *) uid_align, uid_align_max * sizeof *uid_align);\n-  for (; insn; insn = PREV_INSN (insn))\n-    {\n-      int uid = INSN_UID (insn);\n-      if (uid < uid_align_max)\n-\tuid_align[uid] = align_tab[1];\n-      if (GET_CODE (insn) == INSN)\n-\t{\n-\t  rtx pat = PATTERN (insn);\n-\t  if (GET_CODE (pat) == UNSPEC_VOLATILE && XINT (pat, 1) == 1)\n-\t    {\n-\t      /* Found an alignment instruction.  */\n-\t      int log = INTVAL (XVECEXP (pat, 0, 0));\n-\t      uid_align[uid] = align_tab[log];\n-\t      for (i = log - 1; i >= 0; i--)\n-\t\talign_tab[i] = insn;\n-\t    }\n-\t}\n-      else if (GET_CODE (insn) == JUMP_INSN\n-\t       && GET_CODE (PATTERN (insn)) == SET)\n-\t{\n-\t  rtx dest = SET_SRC (PATTERN (insn));\n-\t  if (GET_CODE (dest) == IF_THEN_ELSE)\n-\t    dest = XEXP (dest, 1);\n-\t  if (GET_CODE (dest) == LABEL_REF)\n-\t    {\n-\t      dest = XEXP (dest, 0);\n-\t      if (! uid_align[INSN_UID (dest)])\n-\t\t/* Mark backward branch.  */\n-\t\tuid_align[uid] = 0;\n-\t    }\n-\t}\n-    }\n-}\n-\n /* Fix up ADDR_DIFF_VECs.  */\n void\n fixup_addr_diff_vecs (first)\n      rtx first;\n {\n   rtx insn;\n-  int max_address;\n-  int need_fixup_aligns = 0;\n-  \n-  if (optimize)\n-    max_address = insn_addresses[INSN_UID (get_last_insn ())] + 2;\n+\n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     {\n-      rtx vec_lab, rel_lab, pat, min_lab, max_lab, adj;\n-      int len, i, min, max, size;\n+      rtx vec_lab, pat, prev, prevpat, x;\n \n       if (GET_CODE (insn) != JUMP_INSN\n \t  || GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC)\n \tcontinue;\n       pat = PATTERN (insn);\n-      rel_lab = vec_lab = XEXP (XEXP (pat, 0), 0);\n-      if (TARGET_SH2)\n-\t{\n-\t  rtx prev, prevpat, x;\n+      vec_lab = XEXP (XEXP (pat, 0), 0);\n \n-\t  /* Search the matching casesi_jump_2.  */\n-\t  for (prev = vec_lab; ; prev = PREV_INSN (prev))\n-\t    {\n-\t      if (GET_CODE (prev) != JUMP_INSN)\n-\t\tcontinue;\n-\t      prevpat = PATTERN (prev);\n-\t      if (GET_CODE (prevpat) != PARALLEL || XVECLEN (prevpat, 0) != 2)\n-\t\tcontinue;\n-\t      x = XVECEXP (prevpat, 0, 1);\n-\t      if (GET_CODE (x) != USE)\n-\t\tcontinue;\n-\t      x = XEXP (x, 0);\n-\t      if (GET_CODE (x) == LABEL_REF && XEXP (x, 0) == vec_lab)\n-\t\tbreak;\n-\t    }\n-\t  /* Fix up the ADDR_DIF_VEC to be relative\n-\t     to the reference address of the braf.  */\n-\t  XEXP (XEXP (pat, 0), 0)\n-\t    = rel_lab = XEXP (XEXP (SET_SRC (XVECEXP (prevpat, 0, 0)), 1), 0);\n-\t}\n-      if (! optimize)\n-\tcontinue;\n-      len = XVECLEN (pat, 1);\n-      if (len <= 0)\n-\tabort ();\n-      for (min = max_address, max = 0, i = len - 1; i >= 0; i--)\n-\t{\n-\t  rtx lab = XEXP (XVECEXP (pat, 1, i), 0);\n-\t  int addr = insn_addresses[INSN_UID (lab)];\n-\t  if (addr < min)\n-\t    {\n-\t      min = addr;\n-\t      min_lab = lab;\n-\t    }\n-\t  if (addr > max)\n-\t    {\n-\t      max = addr;\n-\t      max_lab = lab;\n-\t    }\n-\t}\n-      adj\n-\t= emit_insn_before (gen_addr_diff_vec_adjust (min_lab, max_lab, rel_lab,\n-\t\t\t\t\t\t      GEN_INT (len)), vec_lab);\n-      size = (XVECLEN (pat, 1) * GET_MODE_SIZE (GET_MODE (pat))\n-\t      - addr_diff_vec_adjust (adj, 0));\n-      /* If this is a very small table, we want to remove the alignment after\n-\t the table.  */\n-      if (! TARGET_SMALLCODE && size <= 1 << (CACHE_LOG - 2))\n+      /* Search the matching casesi_jump_2.  */\n+      for (prev = vec_lab; ; prev = PREV_INSN (prev))\n \t{\n-\t  rtx align = NEXT_INSN (next_nonnote_insn (insn));\n-\t  PUT_CODE (align, NOTE);\n-\t  NOTE_LINE_NUMBER (align) = NOTE_INSN_DELETED;\n-\t  NOTE_SOURCE_FILE (align) = 0;\n-\t  need_fixup_aligns = 1;\n+\t  if (GET_CODE (prev) != JUMP_INSN)\n+\t    continue;\n+\t  prevpat = PATTERN (prev);\n+\t  if (GET_CODE (prevpat) != PARALLEL || XVECLEN (prevpat, 0) != 2)\n+\t    continue;\n+\t  x = XVECEXP (prevpat, 0, 1);\n+\t  if (GET_CODE (x) != USE)\n+\t    continue;\n+\t  x = XEXP (x, 0);\n+\t  if (GET_CODE (x) == LABEL_REF && XEXP (x, 0) == vec_lab)\n+\t    break;\n \t}\n+      /* Fix up the ADDR_DIF_VEC to be relative\n+\t to the reference address of the braf.  */\n+      XEXP (XEXP (pat, 0), 0)\n+\t= XEXP (XEXP (SET_SRC (XVECEXP (prevpat, 0, 0)), 1), 0);\n     }\n-  if (need_fixup_aligns)\n-    fixup_aligns ();\n }\n \n-/* Say how much the ADDR_DIFF_VEC following INSN can be shortened.\n-   If FIRST_PASS is nonzero, all addresses and length of following\n-   insns are still uninitialized.  */\n+/* BARRIER_OR_LABEL is either a BARRIER or a CODE_LABEL immediately following\n+   a barrier.  Return the base 2 logarithm of the desired alignment.  */\n int\n-addr_diff_vec_adjust (insn, first_pass)\n-     rtx insn;\n-     int first_pass;\n+barrier_align (barrier_or_label)\n+     rtx barrier_or_label;\n {\n-  rtx pat = PATTERN (insn);\n-  rtx min_lab = XEXP (XVECEXP (pat, 0, 0), 0);\n-  rtx max_lab = XEXP (XVECEXP (pat, 0, 1), 0);\n-  rtx rel_lab = XEXP (XVECEXP (pat, 0, 2), 0);\n-  int len = INTVAL (XVECEXP (pat, 0, 3));\n-  int addr, min_addr, max_addr, saving, prev_saving = 0, offset;\n-  rtx align_insn = uid_align[INSN_UID (rel_lab)];\n-  int standard_size = TARGET_BIGTABLE ? 4 : 2;\n-  int last_size = GET_MODE_SIZE ( GET_MODE(pat));\n-  int align_fuzz = 0;\n-\n-  if (! insn_addresses)\n+  rtx next = next_real_insn (barrier_or_label), pat, prev;\n+  int slot, credit;\n+ \n+  if (! next)\n     return 0;\n-  if (first_pass)\n-    /* If optimizing, we may start off with an optimistic guess.  */\n-    return optimize ? len & ~1 : 0;\n-  addr = insn_addresses[INSN_UID (rel_lab)];\n-  min_addr = insn_addresses[INSN_UID (min_lab)];\n-  max_addr = insn_addresses[INSN_UID (max_lab)];\n-  if (! last_size)\n-    last_size = standard_size;\n-  if (TARGET_SH2)\n-    prev_saving = ((standard_size - last_size) * len) & ~1;\n \n-  /* The savings are linear to the vector length.  However, if we have an\n-     odd saving, we need one byte again to reinstate 16 bit alignment.  */\n-  saving = ((standard_size - 1) * len) & ~1;\n-  offset = prev_saving - saving;\n+  pat = PATTERN (next);\n \n-  if ((insn_addresses[INSN_UID (align_insn)] < max_addr\n-       || (insn_addresses[INSN_UID (align_insn)] == max_addr\n-           && next_real_insn (max_lab) != align_insn))\n-      && GET_CODE (align_insn) == INSN)\n-    {\n-      int align = 1 << INTVAL (XVECEXP (PATTERN (align_insn), 0, 0));\n-      int align_addr = insn_addresses[INSN_UID (align_insn)];\n-      if (align_addr > insn_addresses[INSN_UID (insn)])\n-\t{\n-\t  int old_offset = offset;\n-\t  offset = (align_addr - 1 & align - 1) + offset & -align;\n-\t  align_addr += old_offset;\n-\t}\n-      align_fuzz += (align_addr - 1)  & (align - 2);\n-      align_insn = uid_align[INSN_UID (align_insn)];\n-      if (insn_addresses[INSN_UID (align_insn)] <= max_addr\n-          && GET_CODE (align_insn) == INSN)\n-        {\n-          int align2 = 1 << INTVAL (XVECEXP (PATTERN (align_insn), 0, 0));\n-          align_addr = insn_addresses[INSN_UID (align_insn)];\n-\t  if (align_addr > insn_addresses[INSN_UID (insn)])\n-\t    {\n-\t      int old_offset = offset;\n-\t      offset = (align_addr - 1 & align2 - 1) + offset & -align2;\n-\t      align_addr += old_offset;\n-\t    }\n-          align_fuzz += (align_addr - 1)  & (align2 - align);\n-        }\n-    }\n+  if (GET_CODE (pat) == ADDR_DIFF_VEC)\n+    return 2;\n+\n+  if (GET_CODE (pat) == UNSPEC_VOLATILE && XINT (pat, 1) == 1)\n+    /* This is a barrier in front of a constant table.  */\n+    return 0;\n \n-  if (min_addr >= addr\n-      && max_addr + offset - addr + align_fuzz <= 255)\n+  prev = prev_real_insn (barrier_or_label);\n+  if (GET_CODE (PATTERN (prev)) == ADDR_DIFF_VEC)\n     {\n-      PUT_MODE (pat, QImode);\n-      return saving;\n+      pat = PATTERN (prev);\n+      /* If this is a very small table, we want to keep the alignment after\n+\t the table to the minimum for proper code alignment.  */\n+      return ((TARGET_SMALLCODE\n+\t       || (XVECLEN (pat, 1) * GET_MODE_SIZE (GET_MODE (pat))\n+\t\t   <= 1 << (CACHE_LOG - 2)))\n+\t      ? 1 : CACHE_LOG);\n     }\n-  saving = 2 * len;\n-/* Since alignment might play a role in min_addr if it is smaller than addr,\n-   we may not use it without exact alignment compensation; a 'worst case'\n-   estimate is not good enough, because it won't prevent infinite oscillation\n-   of shorten_branches.\n-   ??? We should fix that eventually, but the code to deal with alignments\n-   should go in a new function.  */\n-#if 0\n-  if (TARGET_BIGTABLE && min_addr - ((1 << CACHE_LOG) - 2) - addr >= -32768\n-#else\n-  if (TARGET_BIGTABLE && (min_addr >= addr || addr <= 32768)\n-#endif\n-      && max_addr - addr <= 32767 + saving - prev_saving)\n+\n+  if (TARGET_SMALLCODE)\n+    return 0;\n+\n+  if (! TARGET_SH3 || ! optimize)\n+    return CACHE_LOG;\n+\n+  /* Check if there is an immediately preceding branch to the insn beyond\n+     the barrier.  We must weight the cost of discarding useful information\n+     from the current cache line when executing this branch and there is\n+     an alignment, against that of fetching unneeded insn in front of the\n+     branch target when there is no alignment.  */\n+\n+  /* PREV is presumed to be the JUMP_INSN for the barrier under\n+     investigation.  Skip to the insn before it.  */\n+  prev = prev_real_insn (prev);\n+\n+  for (slot = 2, credit = 1 << (CACHE_LOG - 2) + 2;\n+       credit >= 0 && prev && GET_CODE (prev) == INSN;\n+       prev = prev_real_insn (prev))\n     {\n-      PUT_MODE (pat, HImode);\n-      return saving;\n-    }\n-  PUT_MODE (pat, TARGET_BIGTABLE ? SImode : HImode);\n-  return 0;\n+      if (GET_CODE (PATTERN (prev)) == USE\n+          || GET_CODE (PATTERN (prev)) == CLOBBER)\n+        continue;\n+      if (GET_CODE (PATTERN (prev)) == SEQUENCE)\n+\tprev = XVECEXP (PATTERN (prev), 0, 1);\n+      if (slot &&\n+          get_attr_in_delay_slot (prev) == IN_DELAY_SLOT_YES)\n+        slot = 0;\n+      credit -= get_attr_length (prev);\n+    }\n+  if (prev\n+      && GET_CODE (prev) == JUMP_INSN\n+      && JUMP_LABEL (prev)\n+      && next_real_insn (JUMP_LABEL (prev)) == next_real_insn (barrier_or_label)\n+      && (credit - slot >= (GET_CODE (SET_SRC (PATTERN (prev))) == PC ? 2 : 0)))\n+    return 0;\n+\n+  return CACHE_LOG;\n }\n \n /* Exported to toplev.c.\n@@ -2935,118 +2799,14 @@ machine_dependent_reorg (first)\n \t}\n     }\n \n-  /* The following processing passes need length information.\n-     addr_diff_vec_adjust needs to know if insn_addresses is valid.  */\n-  insn_addresses = 0;\n-\n-  /* If not optimizing for space, we want extra alignment for code after\n-     a barrier, so that it starts on a word / cache line boundary.\n-     We used to emit the alignment for the barrier itself and associate the\n-     instruction length with the following instruction, but that had two\n-     problems:\n-     i) A code label that follows directly after a barrier gets too low an\n-     address.  When there is a forward branch to it, the incorrect distance\n-     calculation can lead to out of range branches.  That happened with\n-     compile/920625-2 -O -fomit-frame-pointer in copyQueryResult.\n-     ii) barriers before constant tables get the extra alignment too.\n-     That is just a waste of space.\n-\n-     So what we do now is to insert align_* instructions after the\n-     barriers.  By doing that before literal tables are generated, we\n-     don't have to care about these.  */\n-  /* We also want alignment in front of ADDR_DIFF_VECs; this is done already\n-     by ASM_OUTPUT_CASE_LABEL, but when optimizing, we have to make it\n-     explicit in the RTL in order to correctly shorten branches.  */\n-    \n-  if (optimize)\n-    for (insn = first; insn; insn = NEXT_INSN (insn))\n-      {\n-\trtx addr_diff_vec;\n-\n-\tif (GET_CODE (insn) == BARRIER\n-\t    && (addr_diff_vec = next_real_insn (insn)))\n-\t  if (GET_CODE (PATTERN (addr_diff_vec)) == ADDR_DIFF_VEC)\n-\t    emit_insn_before (gen_align_4 (),\n-\t\t\t      XEXP (XEXP (PATTERN (addr_diff_vec), 0), 0));\n-\t  else if (TARGET_SMALLCODE)\n-\t    continue;\n-\t  else if (TARGET_SH3)\n-\t    {\n-\t      /* We align for an entire cache line.  If there is a immediately\n-\t\t preceding branch to the insn beyond the barrier, it does not\n-\t\t make sense to insert the align, because we are more likely\n-\t\t to discard useful information from the current cache line\n-\t\t when doing the align than to fetch unneeded insns when not.  */\n-\t      rtx prev = prev_real_insn (prev_real_insn (insn));\n-\t      int slot, credit;\n-\n-\t      for (slot = 2, credit = 1 << (CACHE_LOG - 2) + 2;\n-\t\t   credit >= 0 && prev && GET_CODE (prev) == INSN;\n-\t\t   prev = prev_real_insn (prev))\n-\t\t{\n-\t\t  if (GET_CODE (PATTERN (prev)) == USE\n-\t\t      || GET_CODE (PATTERN (prev)) == CLOBBER)\n-\t\t    continue;\n-\t\t  if (slot &&\n-\t\t      get_attr_in_delay_slot (prev) == IN_DELAY_SLOT_YES)\n-\t\t    slot = 0;\n-\t\t  credit -= get_attr_length (prev);\n-\t\t}\n-\t      if (! prev || GET_CODE (prev) != JUMP_INSN\n-\t\t  || (next_real_insn (JUMP_LABEL (prev))\n-\t\t      != next_real_insn (insn))\n-\t\t  || (credit - slot\n-\t\t      < (GET_CODE (SET_SRC (PATTERN (prev))) == PC ? 2 : 0)))\n-\t\t{\n-\t\t  insn = emit_insn_after (gen_align_log (GEN_INT (CACHE_LOG)),\n-\t\t\t\t\t  insn);\n-\t\t  insn = emit_barrier_after (insn);\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      insn = emit_insn_after (gen_align_4 (), insn);\n-\t      insn = emit_barrier_after (insn);\n-\t    }\n-\telse if (TARGET_SMALLCODE)\n-\t  continue;\n-\telse if (GET_CODE (insn) == NOTE\n-\t\t && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n-\t  {\n-\t    rtx next = next_nonnote_insn (insn);\n-            if (next && GET_CODE (next) == CODE_LABEL)\n-\t      emit_insn_after (gen_align_4 (), insn);\n-\t  }\n-      }\n-\n-  /* If TARGET_IEEE, we might have to split some branches before fixup_align.\n-     If optimizing, the double call to shorten_branches will split insns twice,\n-     unless we split now all that is to split and delete the original insn.  */\n-  if (TARGET_IEEE || optimize)\n-    for (insn = NEXT_INSN (first); insn; insn = NEXT_INSN (insn))\n-      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i' && ! INSN_DELETED_P (insn))\n-\t{\n-\t  rtx old = insn;\n-\t  insn = try_split (PATTERN (insn), insn, 1);\n-\t  if (INSN_DELETED_P (old))\n-\t    {\n-\t      PUT_CODE (old, NOTE);\n-\t      NOTE_LINE_NUMBER (old) = NOTE_INSN_DELETED;\n-\t      NOTE_SOURCE_FILE (old) = 0;\n-\t    }\n-\t}\n-\n-  max_uid_before_fixup_addr_diff_vecs = get_max_uid ();\n+  if (TARGET_SH2)\n+    fixup_addr_diff_vecs (first);\n \n   if (optimize)\n     {\n-      uid_align_max = get_max_uid ();\n-      uid_align = (rtx *) alloca (uid_align_max * sizeof *uid_align);\n-      fixup_aligns ();\n       mdep_reorg_phase = SH_SHORTEN_BRANCHES0;\n       shorten_branches (first);\n     }\n-  fixup_addr_diff_vecs (first);\n   /* Scan the function looking for move instructions which have to be\n      changed to pc-relative loads and insert the literal tables.  */\n \n@@ -3070,8 +2830,7 @@ machine_dependent_reorg (first)\n \t  /* Some code might have been inserted between the mova and\n \t     its ADDR_DIFF_VEC.  Check if the mova is still in range.  */\n \t  for (scan = mova, total = 0; scan != insn; scan = NEXT_INSN (scan))\n-\t    if (INSN_UID (scan) < max_uid_before_fixup_addr_diff_vecs)\n-\t      total += get_attr_length (scan);\n+\t    total += get_attr_length (scan);\n \n \t  /* range of mova is 1020, add 4 because pc counts from address of\n \t     second instruction after this one, subtract 2 in case pc is 2\n@@ -3234,9 +2993,6 @@ split_branches (first)\n   int max_uid = get_max_uid ();\n \n   /* Find out which branches are out of range.  */\n-  uid_align_max = get_max_uid ();\n-  uid_align = (rtx *) alloca (uid_align_max * sizeof *uid_align);\n-  fixup_aligns ();\n   shorten_branches (first);\n \n   uid_branch = (struct far_branch **) alloca (max_uid * sizeof *uid_branch);\n@@ -3335,13 +3091,15 @@ split_branches (first)\n \t\t   is too far away.  */\n \t\t/* We can't use JUMP_LABEL here because it might be undefined\n \t\t   when not optimizing.  */\n+\t\t/* A syntax error might cause beyond to be NULL_RTX.  */\n \t\tbeyond\n \t\t  = next_active_insn (XEXP (XEXP (SET_SRC (PATTERN (insn)), 1),\n \t\t\t\t\t    0));\n \t\n-\t\tif ((GET_CODE (beyond) == JUMP_INSN\n-\t\t     || (GET_CODE (beyond = next_active_insn (beyond))\n-\t\t\t == JUMP_INSN))\n+\t\tif (beyond\n+\t\t    && (GET_CODE (beyond) == JUMP_INSN\n+\t\t\t|| (GET_CODE (beyond = next_active_insn (beyond))\n+\t\t\t    == JUMP_INSN))\n \t\t    && GET_CODE (PATTERN (beyond)) == SET\n \t\t    && recog_memoized (beyond) == CODE_FOR_jump\n \t\t    && ((insn_addresses[INSN_UID (XEXP (SET_SRC (PATTERN (beyond)), 0))]\n@@ -3432,9 +3190,6 @@ split_branches (first)\n \tdelete_insn (far_branch_list->far_label);\n       far_branch_list = far_branch_list->prev;\n     }\n-  uid_align_max = get_max_uid ();\n-  uid_align = (rtx *) oballoc (uid_align_max * sizeof *uid_align);\n-  fixup_aligns ();\n }\n \n /* Dump out instruction addresses, which is useful for debugging the\n@@ -4193,180 +3948,20 @@ braf_label_ref_operand(op, mode)\n     return 0;\n }\n \f\n-/* Return the offset of a branch.  Offsets for backward branches are\n-   reported relative to the branch instruction, while offsets for forward\n-   branches are reported relative to the following instruction.  */\n+/* Return the destination address of a branch.  */\n    \n int\n-branch_offset (branch)\n+branch_dest (branch)\n      rtx branch;\n {\n-  rtx dest = SET_SRC (PATTERN (branch)), dest_next;\n-  int branch_uid = INSN_UID (branch);\n-  int dest_uid, dest_addr;\n-  rtx branch_align = uid_align[branch_uid];\n+  rtx dest = SET_SRC (PATTERN (branch));\n+  int dest_uid;\n \n   if (GET_CODE (dest) == IF_THEN_ELSE)\n     dest = XEXP (dest, 1);\n   dest = XEXP (dest, 0);\n   dest_uid = INSN_UID (dest);\n-  dest_addr = insn_addresses[dest_uid];\n-  if (branch_align)\n-    {\n-      /* Forward branch. */\n-      /* If branch is in a sequence, get the successor of the sequence.  */\n-      rtx next = NEXT_INSN (NEXT_INSN (PREV_INSN (branch)));\n-      int next_addr = insn_addresses[INSN_UID (next)];\n-      int diff;\n-\n-      /* If NEXT has been hoisted in a sequence further on, it address has\n-\t been clobbered in the previous pass.  However, if that is the case,\n-\t we know that it is exactly 2 bytes long (because it fits in a delay\n-\t slot), and that there is a following label (the destination of the\n-\t instruction that filled its delay slot with NEXT).  The address of\n-\t this label is reliable.  */\n-      if (NEXT_INSN (next))\n-\t{\n-\t  int next_next_addr = insn_addresses[INSN_UID (NEXT_INSN (next))];\n-\t  if (next_addr > next_next_addr)\n-\t    next_addr = next_next_addr - 2;\n-\t}\n-      diff = dest_addr - next_addr;\n-      /* If BRANCH_ALIGN has been the last insn, it might be a barrier or\n-\t a note.  */\n-      if ((insn_addresses[INSN_UID (branch_align)] < dest_addr\n-\t   || (insn_addresses[INSN_UID (branch_align)] == dest_addr\n-\t       && next_real_insn (dest) != branch_align))\n-\t  && GET_CODE (branch_align) == INSN)\n-\t{\n-\t  int align = 1 << INTVAL (XVECEXP (PATTERN (branch_align), 0, 0));\n-\t  int align_addr = insn_addresses[INSN_UID (branch_align)];\n-\t  diff += (align_addr - 1)  & (align - 2);\n-\t  branch_align = uid_align[INSN_UID (branch_align)];\n-\t  if (insn_addresses[INSN_UID (branch_align)] <= dest_addr\n-\t      && GET_CODE (branch_align) == INSN)\n-\t    {\n-\t      int align2 = 1 << INTVAL (XVECEXP (PATTERN (branch_align), 0, 0));\n-\t      align_addr = insn_addresses[INSN_UID (branch_align)];\n-\t      diff += (align_addr - 1)  & (align2 - align);\n-\t    }\n-\t}\n-      return diff;\n-    }\n-  else\n-    {\n-      /* Backward branch. */\n-      int branch_addr = insn_addresses[branch_uid];\n-      int diff = dest_addr - branch_addr;\n-      int old_align = 2;\n-\n-      while (dest_uid >= uid_align_max || ! uid_align[dest_uid])\n-\t{\n-\t  /* Label might be outside the insn stream, or even in a separate\n-\t     insn stream, after a syntax error.  */\n-\t  if (! NEXT_INSN (dest))\n-\t    return 0;\n-\t  dest = NEXT_INSN (dest), dest_uid = INSN_UID (dest);\n-\t}\n-      \n-      /* By searching for a known destination, we might already have\n-\t stumbled on the alignment instruction.  */\n-      if (GET_CODE (dest) == INSN\n-\t  && GET_CODE (PATTERN (dest)) == UNSPEC_VOLATILE\n-\t  && XINT (PATTERN (dest), 1) == 1\n-\t  && INTVAL (XVECEXP (PATTERN (dest), 0, 0)) > 1)\n-\tbranch_align = dest;\n-      else\n-\tbranch_align = uid_align[dest_uid];\n-      while (insn_addresses[INSN_UID (branch_align)] <= branch_addr\n-\t     && GET_CODE (branch_align) == INSN)\n-\t{\n-\t  int align = 1 << INTVAL (XVECEXP (PATTERN (branch_align), 0, 0));\n-\t  int align_addr = insn_addresses[INSN_UID (branch_align)];\n-\t  diff -= (align_addr - 1)  & (align - old_align);\n-\t  old_align = align;\n-\t  branch_align = uid_align[INSN_UID (branch_align)];\n-\t}\n-      return diff;\n-    }\n-}\n-\n-int\n-short_cbranch_p (branch)\n-     rtx branch;\n-{\n-  int offset;\n-\n-  if (! insn_addresses)\n-    return 0;\n-  if (mdep_reorg_phase <= SH_FIXUP_PCLOAD)\n-    return 0;\n-  offset = branch_offset (branch);\n-  return (offset >= -252\n-\t  && offset <= (NEXT_INSN (PREV_INSN (branch)) == branch ? 256 : 254));\n-}\n-\n-/* The maximum range used for SImode constant pool entrys is 1018.  A final\n-   instruction can add 8 bytes while only being 4 bytes in size, thus we\n-   can have a total of 1022 bytes in the pool.  Add 4 bytes for a branch\n-   instruction around the pool table, 2 bytes of alignment before the table,\n-   and 30 bytes of alignment after the table.  That gives a maximum total\n-   pool size of 1058 bytes.\n-   Worst case code/pool content size ratio is 1:2 (using asms).\n-   Thus, in the worst case, there is one instruction in front of a maximum\n-   sized pool, and then there are 1052 bytes of pool for every 508 bytes of\n-   code.  For the last n bytes of code, there are 2n + 36 bytes of pool.\n-   If we have a forward branch, the initial table will be put after the\n-   unconditional branch.\n-\n-   ??? We could do much better by keeping track of the actual pcloads within\n-   the branch range and in the pcload range in front of the branch range.  */\n-\n-int\n-med_branch_p (branch, condlen)\n-     rtx branch;\n-     int condlen;\n-{\n-  int offset;\n-\n-  if (! insn_addresses)\n-    return 0;\n-  offset = branch_offset (branch);\n-  if (mdep_reorg_phase <= SH_FIXUP_PCLOAD)\n-    return offset - condlen >= -990 && offset <= 998;\n-  return offset - condlen >= -4092 && offset <= 4094;\n-}\n-\n-int\n-braf_branch_p (branch, condlen)\n-     rtx branch;\n-     int condlen;\n-{\n-  int offset;\n-\n-  if (! insn_addresses)\n-    return 0;\n-  if (! TARGET_SH2)\n-    return 0;\n-  offset = branch_offset (branch);\n-  if (mdep_reorg_phase <= SH_FIXUP_PCLOAD)\n-    return offset - condlen >= -10330 && offset <= 10330;\n-  return offset -condlen >= -32764 && offset <= 32766;\n-}\n-\n-int\n-align_length (insn)\n-     rtx insn;\n-{\n-  int align = 1 << INTVAL (XVECEXP (PATTERN (insn), 0, 0));\n-  if (! insn_addresses)\n-    if (optimize\n-\t&& (mdep_reorg_phase == SH_SHORTEN_BRANCHES0\n-\t    || mdep_reorg_phase == SH_SHORTEN_BRANCHES1))\n-      return 0;\n-    else\n-      return align - 2;\n-  return align - 2 - ((insn_addresses[INSN_UID (insn)] - 2) & (align - 2));\n+  return insn_addresses[dest_uid];\n }\n \f\n /* Return non-zero if REG is not used after INSN."}, {"sha": "746da4fdf715c6741864f78dab7bafda2ac30ac1", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 45, "deletions": 36, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -265,6 +265,33 @@ do {\t\t\t\t\t\t\t\t\\\n /* Set this nonzero if move instructions will actually fail to work\n    when given unaligned data.  */\n #define STRICT_ALIGNMENT 1\n+\n+/* If LABEL_AFTER_BARRIER demands an alignment, return its base 2 logarithm.  */\n+#define LABEL_ALIGN_AFTER_BARRIER(LABEL_AFTER_BARRIER) \\\n+  barrier_align (LABEL_AFTER_BARRIER)\n+\n+#define LOOP_ALIGN(A_LABEL) (TARGET_SMALLCODE ? 0 : 2)\n+\n+#define LABEL_ALIGN(A_LABEL) \\\n+(\t\t\t\t\t\t\t\t\t\\\n+  (PREV_INSN (A_LABEL)\t\t\t\t\t\t\t\\\n+   && GET_CODE (PREV_INSN (A_LABEL)) == INSN\t\t\t\t\\\n+   && GET_CODE (PATTERN (PREV_INSN (A_LABEL))) == UNSPEC_VOLATILE\t\\\n+   && XINT (PATTERN (PREV_INSN (A_LABEL)), 1) == 1)\t\t\t\\\n+   /* explicit alignment insn in constant tables. */\t\t\t\\\n+  ? INTVAL (XVECEXP (PATTERN (PREV_INSN (A_LABEL)), 0, 0))\t\t\\\n+  : 0)\n+\n+/* Jump tables must be 32 bit aligned, no matter the size of the element.  */\n+#define ADDR_VEC_ALIGN(ADDR_VEC) 2\n+\n+/* The base two logarithm of the known minimum alignment of an insn length.  */\n+#define INSN_LENGTH_ALIGNMENT(A_INSN)\t\t\t\t\t\\\n+  (GET_CODE (A_INSN) == INSN\t\t\t\t\t\t\\\n+   ? 1\t\t\t\t\t\t\t\t\t\\\n+   : GET_CODE (A_INSN) == JUMP_INSN || GET_CODE (A_INSN) == CALL_INSN\t\\\n+   ? 1\t\t\t\t\t\t\t\t\t\\\n+   : CACHE_LOG)\n \f\n /* Standard register usage.  */\n \n@@ -1188,6 +1215,14 @@ extern struct rtx_def *sh_builtin_saveregs ();\n    for the index in the tablejump instruction.  */\n #define CASE_VECTOR_MODE (TARGET_BIGTABLE ? SImode : HImode)\n \n+#define CASE_VECTOR_SHORTEN_MODE(MIN_OFFSET, MAX_OFFSET, BODY) \\\n+((MIN_OFFSET) >= 0 && (MAX_OFFSET) <= 127 \\\n+ ? (ADDR_DIFF_VEC_FLAGS (BODY).offset_unsigned = 1, QImode) \\\n+ : (MIN_OFFSET) >= 0 && (MAX_OFFSET) <= 255 \\\n+ ? (ADDR_DIFF_VEC_FLAGS (BODY).offset_unsigned = 0, QImode) \\\n+ : (MIN_OFFSET) >= -32768 && (MAX_OFFSET) <= 32767 ? HImode \\\n+ : SImode)\n+\n /* Define as C expression which evaluates to nonzero if the tablejump\n    instruction expects the table to contain offsets from the address of the\n    table.\n@@ -1520,14 +1555,10 @@ dtors_section()\t\t\t\t\t\t\t\\\n   ((OUTVAR) = (char *) alloca (strlen (NAME) + 10),\t\\\n    sprintf ((OUTVAR), \"%s.%d\", (NAME), (NUMBER)))\n \n-/* Jump tables must be 32 bit aligned, no matter the size of the element.  */\n-#define ASM_OUTPUT_CASE_LABEL(STREAM,PREFIX,NUM,TABLE) \\\n-  fprintf ((STREAM), \"\\t.align 2\\n%s%d:\\n\",  (PREFIX), (NUM));\n-\n /* Output a relative address table.  */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM,VALUE,REL)  \t\t\t\\\n-  switch (sh_addr_diff_vec_mode)\t\t\t\t\t\\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM,BODY,VALUE,REL)  \t\t\\\n+  switch (GET_MODE (BODY))\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n     case SImode:\t\t\t\t\t\t\t\\\n       asm_fprintf ((STREAM), \"\\t.long\\t%LL%d-%LL%d\\n\", (VALUE),(REL));\t\\\n@@ -1672,7 +1703,9 @@ extern enum processor_type sh_cpu;\n \n extern enum machine_mode sh_addr_diff_vec_mode;\n \n-extern int optimize; /* needed for gen_casesi, and addr_diff_vec_adjust.  */\n+extern int optimize; /* needed for gen_casesi.  */\n+\n+extern short *label_align;\n \n /* Declare functions defined in sh.c and used in templates.  */\n \n@@ -1695,13 +1728,11 @@ enum mdep_reorg_phase_e\n   SH_AFTER_MDEP_REORG\n };\n \n+extern enum mdep_reorg_phase_e mdep_reorg_phase;\n+\n void machine_dependent_reorg ();\n-int short_cbranch_p ();\n-int med_branch_p ();\n-int braf_branch_p ();\n-int align_length ();\n-int addr_diff_vec_adjust ();\n struct rtx_def *sfunc_uses_reg ();\n+int barrier_align ();\n \n #define MACHINE_DEPENDENT_REORG(X) machine_dependent_reorg(X)\n \n@@ -1736,11 +1767,7 @@ sh_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n #define MOVE_RATIO (TARGET_SMALLCODE ? 2 : 16)\n \f\n /* Instructions with unfilled delay slots take up an extra two bytes for\n-   the nop in the delay slot.  Instructions at the start of loops, or\n-   after unconditional branches, may take up extra room when they are\n-   aligned.  ??? We would get more accurate results if we did instruction\n-   alignment based on the value of INSN_CURRENT_ADDRESS; the approach used\n-   here is too conservative.  */\n+   the nop in the delay slot.  */\n \n #define ADJUST_INSN_LENGTH(X, LENGTH)\t\t\t\t\\\n   if (((GET_CODE (X) == INSN\t\t\t\t\t\\\n@@ -1752,25 +1779,7 @@ sh_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n \t   && GET_CODE (PATTERN (X)) != ADDR_VEC))\t\t\\\n       && GET_CODE (PATTERN (NEXT_INSN (PREV_INSN (X)))) != SEQUENCE \\\n       && get_attr_needs_delay_slot (X) == NEEDS_DELAY_SLOT_YES)\t\\\n-    (LENGTH) += 2;\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == INSN\t\t\t\t\t\\\n-      && GET_CODE (PATTERN (X)) == UNSPEC_VOLATILE\t\t\\\n-      && XINT (PATTERN (X), 1) == 7)\t\t\t\t\\\n-    (LENGTH) -= addr_diff_vec_adjust (X, LENGTH);\t\t\\\n-  if (GET_CODE (X) == INSN\t\t\t\t\t\\\n-      && GET_CODE (PATTERN (X)) == UNSPEC_VOLATILE\t\t\\\n-      && XINT (PATTERN (X), 1) == 1)\t\t\t\t\\\n-    (LENGTH) = align_length (X);\t\t\t\t\\\n-  if (GET_CODE (X) == JUMP_INSN\t\t\t\t\t\\\n-      && GET_CODE (PATTERN (X)) == ADDR_DIFF_VEC)\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      /* The code before an ADDR_DIFF_VEC is even aligned,\t\\\n-\t thus any odd estimate is wrong.  */\t\t\t\\\n-      (LENGTH) &= ~1;\t\t\t\t\t\t\\\n-      /* If not optimizing, the alignment is implicit.  */\t\\\n-      if (! optimize)\t\t\t\t\t\t\\\n-\t(LENGTH) += 2;\t\t\t\t\t\t\\\n-    }\n+    (LENGTH) += 2;\n \n /* Enable a bug fix for the shorten_branches pass.  */\n #define SHORTEN_WITH_ADJUST_INSN_LENGTH"}, {"sha": "93a2ec8b4e49af454403697f8c60a1b846516d3b", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 102, "deletions": 56, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -114,6 +114,83 @@\n ; In machine_dependent_reorg, we split all branches that are longer than\n ; 2 bytes.\n \n+;; The maximum range used for SImode constant pool entrys is 1018.  A final\n+;; instruction can add 8 bytes while only being 4 bytes in size, thus we\n+;; can have a total of 1022 bytes in the pool.  Add 4 bytes for a branch\n+;; instruction around the pool table, 2 bytes of alignment before the table,\n+;; and 30 bytes of alignment after the table.  That gives a maximum total\n+;; pool size of 1058 bytes.\n+;; Worst case code/pool content size ratio is 1:2 (using asms).\n+;; Thus, in the worst case, there is one instruction in front of a maximum\n+;; sized pool, and then there are 1052 bytes of pool for every 508 bytes of\n+;; code.  For the last n bytes of code, there are 2n + 36 bytes of pool.\n+;; If we have a forward branch, the initial table will be put after the\n+;; unconditional branch.\n+;;\n+;; ??? We could do much better by keeping track of the actual pcloads within\n+;; the branch range and in the pcload range in front of the branch range.\n+\n+;; ??? This looks ugly because genattrtab won't allow if_then_else or cond\n+;; inside an le.\n+(define_attr \"short_cbranch_p\" \"no,yes\"\n+  (cond [(ne (symbol_ref \"mdep_reorg_phase <= SH_FIXUP_PCLOAD\") (const_int 0))\n+\t (const_string \"no\")\n+\t (leu (plus (minus (match_dup 0) (pc)) (const_int 252)) (const_int 506))\n+\t (const_string \"yes\")\n+\t (ne (symbol_ref \"NEXT_INSN (PREV_INSN (insn)) != insn\") (const_int 0))\n+\t (const_string \"no\")\n+\t (leu (plus (minus (match_dup 0) (pc)) (const_int 252)) (const_int 508))\n+\t (const_string \"yes\")\n+         ] (const_string \"no\")))\n+\n+(define_attr \"med_branch_p\" \"no,yes\"\n+  (cond [(leu (plus (minus (match_dup 0) (pc)) (const_int 990))\n+\t      (const_int 1988))\n+\t (const_string \"yes\")\n+\t (ne (symbol_ref \"mdep_reorg_phase <= SH_FIXUP_PCLOAD\") (const_int 0))\n+\t (const_string \"no\")\n+\t (leu (plus (minus (match_dup 0) (pc)) (const_int 4092))\n+\t      (const_int 8186))\n+\t (const_string \"yes\")\n+\t ] (const_string \"no\")))\n+\n+(define_attr \"med_cbranch_p\" \"no,yes\"\n+  (cond [(leu (plus (minus (match_dup 0) (pc)) (const_int 988))\n+\t      (const_int 1986))\n+\t (const_string \"yes\")\n+\t (ne (symbol_ref \"mdep_reorg_phase <= SH_FIXUP_PCLOAD\") (const_int 0))\n+\t (const_string \"no\")\n+\t (leu (plus (minus (match_dup 0) (pc)) (const_int 4090))\n+\t       (const_int 8184))\n+\t (const_string \"yes\")\n+\t ] (const_string \"no\")))\n+\n+(define_attr \"braf_branch_p\" \"no,yes\"\n+  (cond [(ne (symbol_ref \"! TARGET_SH2\") (const_int 0))\n+\t (const_string \"no\")\n+\t (leu (plus (minus (match_dup 0) (pc)) (const_int 10330))\n+\t      (const_int 20660))\n+\t (const_string \"yes\")\n+\t (ne (symbol_ref \"mdep_reorg_phase <= SH_FIXUP_PCLOAD\") (const_int 0))\n+\t (const_string \"no\")\n+\t (leu (plus (minus (match_dup 0) (pc)) (const_int 32764))\n+\t      (const_int 65530))\n+\t (const_string \"yes\")\n+\t ] (const_string \"no\")))\n+\n+(define_attr \"braf_cbranch_p\" \"no,yes\"\n+  (cond [(ne (symbol_ref \"! TARGET_SH2\") (const_int 0))\n+\t (const_string \"no\")\n+\t (leu (plus (minus (match_dup 0) (pc)) (const_int 10328))\n+\t      (const_int 20658))\n+\t (const_string \"yes\")\n+\t (ne (symbol_ref \"mdep_reorg_phase <= SH_FIXUP_PCLOAD\") (const_int 0))\n+\t (const_string \"no\")\n+\t (leu (plus (minus (match_dup 0) (pc)) (const_int 32762))\n+\t      (const_int 65528))\n+\t (const_string \"yes\")\n+\t ] (const_string \"no\")))\n+\n ; An unconditional jump in the range -4092..4098 can be 2 bytes long.\n ; For wider ranges, we need a combination of a code and a data part.\n ; If we can get a scratch register for a long range jump, the code\n@@ -123,31 +200,34 @@\n \n ; All other instructions are two bytes long by default.\n \n+;; ??? This should use something like *branch_p (minus (match_dup 0) (pc)),\n+;; but getattrtab doesn't understand this.\n (define_attr \"length\" \"\"\n   (cond [(eq_attr \"type\" \"cbranch\")\n-\t (cond [(ne (symbol_ref \"short_cbranch_p (insn)\") (const_int 0))\n+\t (cond [(eq_attr \"short_cbranch_p\" \"yes\")\n \t\t(const_int 2)\n-\t\t(ne (symbol_ref \"med_branch_p (insn, 2)\") (const_int 0))\n+\t\t(eq_attr \"med_cbranch_p\" \"yes\")\n \t\t(const_int 6)\n-\t\t(ne (symbol_ref \"braf_branch_p (insn, 2)\") (const_int 0))\n-\t\t(const_int 10)\n-\t\t(ne (pc) (pc))\n+\t\t(eq_attr \"braf_cbranch_p\" \"yes\")\n \t\t(const_int 12)\n+;; ??? using pc is not computed transitively.\n+\t\t(ne (match_dup 0) (match_dup 0))\n+\t\t(const_int 14)\n \t\t] (const_int 16))\n \t (eq_attr \"type\" \"jump\")\n-\t (cond [(ne (symbol_ref \"med_branch_p (insn, 0)\") (const_int 0))\n+\t (cond [(eq_attr \"med_branch_p\" \"yes\")\n \t\t(const_int 2)\n \t\t(and (eq (symbol_ref \"GET_CODE (PREV_INSN (insn))\")\n \t\t\t (symbol_ref \"INSN\"))\n \t\t     (eq (symbol_ref \"INSN_CODE (PREV_INSN (insn))\")\n \t\t\t (symbol_ref \"code_for_indirect_jump_scratch\")))\n-\t\t(if_then_else (ne (symbol_ref \"braf_branch_p (insn, 0)\")\n-\t\t\t\t  (const_int 0))\n+\t\t(if_then_else (eq_attr \"braf_branch_p\" \"yes\")\n \t\t\t      (const_int 6)\n \t\t\t      (const_int 10))\n-\t\t(ne (symbol_ref \"braf_branch_p (insn, 0)\") (const_int 0))\n+\t\t(eq_attr \"braf_branch_p\" \"yes\")\n \t\t(const_int 10)\n-\t\t(ne (pc) (pc))\n+;; ??? using pc is not computed transitively.\n+\t\t(ne (match_dup 0) (match_dup 0))\n \t\t(const_int 12)\n \t\t] (const_int 14))\n \t ] (const_int 2)))\n@@ -2605,55 +2685,27 @@\n   \"\"\n   \"*\n {\n-  enum machine_mode mode\n-    = optimize\n-\t? GET_MODE (PATTERN (prev_real_insn (operands[2])))\n-\t: sh_addr_diff_vec_mode;\n-  switch (mode)\n+  rtx diff_vec = PATTERN (next_real_insn (operands[2]));\n+\n+  if (GET_CODE (diff_vec) != ADDR_DIFF_VEC)\n+    abort ();\n+\n+  switch (GET_MODE (diff_vec))\n     {\n     case SImode:\n       return \\\"shll2\t%1\\;mov.l\t@(r0,%1),%0\\\";\n     case HImode:\n       return \\\"add\t%1,%1\\;mov.w\t@(r0,%1),%0\\\";\n     case QImode:\n-      {\n-\trtx adj = PATTERN (prev_real_insn (operands[2]));\n-\tif ((insn_addresses[INSN_UID (XEXP ( XVECEXP (adj, 0, 1), 0))]\n-\t     - insn_addresses[INSN_UID (XEXP (XVECEXP (adj, 0, 2), 0))])\n-\t    <= 126)\n-\t  return \\\"mov.b\t@(r0,%1),%0\\\";\n+      if (ADDR_DIFF_VEC_FLAGS (diff_vec).offset_unsigned)\n \treturn \\\"mov.b\t@(r0,%1),%0\\;extu.b\t%0,%0\\\";\n-      }\n+      return \\\"mov.b\t@(r0,%1),%0\\\";\n     default:\n       abort ();\n     }\n }\"\n   [(set_attr \"length\" \"4\")])\n \n-;; Include ADDR_DIFF_VECS in the shorten_branches pass; we have to\n-;; use a negative-length instruction to actually accomplish this.\n-(define_insn \"addr_diff_vec_adjust\"\n-  [(unspec_volatile [(label_ref (match_operand 0 \"\" \"\"))\n-\t\t     (label_ref (match_operand 1 \"\" \"\"))\n-\t\t     (label_ref (match_operand 2 \"\" \"\"))\n-\t\t     (match_operand 3 \"const_int_operand\" \"\")] 7)]\n-  \"\"\n-  \"*\n-{\n-  /* ??? ASM_OUTPUT_ADDR_DIFF_ELT gets passed no context information, so\n-     we must use a kludge with a global variable.  */\n-  sh_addr_diff_vec_mode = GET_MODE (PATTERN (insn));\n-  return \\\"\\\";\n-}\"\n-;; Need a variable length for this to be processed in each shorten_branch pass.\n-;; The actual work is done in ADJUST_INSN_LENGTH, because length attributes\n-;; need to be (a choice of) constants.\n-;; We use the calculated length before ADJUST_INSN_LENGTH to\n-;; determine if the insn_addresses array contents are valid.\n-  [(set (attr \"length\")\n-\t(if_then_else (eq (pc) (const_int -1))\n-\t\t      (const_int 2) (const_int 0)))])\n-\n (define_insn \"return\"\n   [(return)]\n   \"reload_completed\"\n@@ -2900,12 +2952,10 @@\n \n ; align to a two byte boundary\n \n-(define_insn \"align_2\"\n+(define_expand \"align_2\"\n  [(unspec_volatile [(const_int 1)] 1)]\n  \"\"\n- \".align 1\"\n- [(set_attr \"length\" \"0\")\n-  (set_attr \"in_delay_slot\" \"no\")])\n+ \"\")\n \n ; align to a four byte boundary\n ;; align_4 and align_log are instructions for the starts of loops, or\n@@ -2921,12 +2971,8 @@\n (define_insn \"align_log\"\n  [(unspec_volatile [(match_operand 0 \"const_int_operand\" \"\")] 1)]\n  \"\"\n- \".align %O0\"\n-;; Need a variable length for this to be processed in each shorten_branch pass.\n-;; The actual work is done in ADJUST_INSN_LENGTH, because length attributes\n-;; need to be (a choice of) constants.\n-  [(set (attr \"length\")\n-\t(if_then_else (ne (pc) (pc)) (const_int 2) (const_int 0)))\n+ \"\"\n+ [(set_attr \"length\" \"0\")\n   (set_attr \"in_delay_slot\" \"no\")])\n \n ; emitted at the end of the literal table, used to emit the"}, {"sha": "459bffd901bc13a32d148efff6caa29a4f7f2a31", "filename": "gcc/config/sparc/pbd.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fsparc%2Fpbd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fsparc%2Fpbd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fpbd.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -133,7 +133,7 @@ Boston, MA 02111-1307, USA.  */\n /* This is how to output an element of a case-vector that is relative.  */\n \n #undef  ASM_OUTPUT_ADDR_DIFF_ELT\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n   fprintf (FILE, \"\\t.word .L%d-.L%d\\n\", VALUE, REL)\n \n /* This is how to output an element of a case-vector that is absolute."}, {"sha": "9ec92c872a91466a807e6785ebe1c0079a348d08", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -2969,7 +2969,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* This is how to output an element of a case-vector that is relative.\n    (SPARC uses such vectors only when generating PIC.)  */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)\t\t\t\\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   char label[30];\t\t\t\t\t\t\t\\\n   ASM_GENERATE_INTERNAL_LABEL (label, \"L\", VALUE);\t\t\t\\"}, {"sha": "c75caf6f5f12e0284564ff6539e466db6bf4d904", "filename": "gcc/config/spur/spur.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fspur%2Fspur.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fspur%2Fspur.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspur%2Fspur.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -947,7 +947,7 @@ extern int current_function_pretend_args_size;\n    (SPUR does not use such vectors,\n    but we must define this macro anyway.)  */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n   fprintf (FILE, \"\\t.word L%d-L%d\\n\", VALUE, REL)\n \n /* This is how to output an assembler line"}, {"sha": "29ac01392e724e6514050c68913f890c0299e510", "filename": "gcc/config/tahoe/tahoe.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Ftahoe%2Ftahoe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Ftahoe%2Ftahoe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftahoe%2Ftahoe.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -896,7 +896,7 @@ do {\tregister int i;\t\t\t\t\t\\\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n   fprintf (FILE, \"\\t.word L%d-L%d\\n\", VALUE, REL)\n \n /* This is how to output an assembler line"}, {"sha": "9282cba911573e0976e5b7e40cf8b65c3586b517", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -1287,7 +1287,7 @@ do { char dstr[30];\t\t\t\t\t\\\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n   fprintf (FILE, \"\\t%s .L%d-.L%d\\n\",\t\t\t\t\t\\\n \t   (TARGET_BIG_SWITCH ? \".long\" : \".short\"),\t\t\t\\\n \t   VALUE, REL)"}, {"sha": "ecf7ead149a8af4cfbaeae32f599ad4fdc209aca", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -1159,7 +1159,7 @@ do { char dstr[30];\t\t\t\t\t\t\t\\\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n   fprintf (FILE, \"\\t.word L%d-L%d\\n\", VALUE, REL)\n \n /* This is how to output an assembler line"}, {"sha": "8d8593bc26b3307e7b54605a638ca57ea01d4d7b", "filename": "gcc/config/we32k/we32k.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fwe32k%2Fwe32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fconfig%2Fwe32k%2Fwe32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fwe32k%2Fwe32k.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -889,7 +889,7 @@ do {\t\t\t\t\t\t\t\\\n \n /* This is how to output an element of a case-vector that is relative.  */\n \n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n   fprintf (FILE, \"\\t.word .L%d-.L%d\\n\", VALUE, REL)\n \n /* This is how to output an assembler line"}, {"sha": "99d20d14e55908b5f8054aabcfe24dc06947cc58", "filename": "gcc/final.c", "status": "modified", "additions": 161, "deletions": 8, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -893,6 +893,7 @@ insn_current_reference_address (branch)\n        any alignment we'd encounter, so we skip the call to align_fuzz.  */\n     return insn_current_address;\n   dest = JUMP_LABEL (branch);\n+  /* BRANCH has no proper alignment chain set, so use SEQ.  */\n   if (INSN_SHUID (branch) < INSN_SHUID (dest))\n     {\n       /* Forward branch. */\n@@ -1085,28 +1086,76 @@ shorten_branches (first)\n   for (i = MAX_CODE_ALIGN; --i >= 0; )\n     align_tab[i] = NULL_RTX;\n   seq = get_last_insn ();\n-  for (insn_current_address = 0; seq; seq = PREV_INSN (seq))\n+  for (; seq; seq = PREV_INSN (seq))\n     {\n       int uid = INSN_UID (seq);\n       int log;\n       log = (GET_CODE (seq) == CODE_LABEL ? LABEL_TO_ALIGNMENT (seq) : 0);\n       uid_align[uid] = align_tab[0];\n-      insn_addresses[uid] = --insn_current_address;\n       if (log)\n \t{\n \t  /* Found an alignment label.  */\n \t  uid_align[uid] = align_tab[log];\n \t  for (i = log - 1; i >= 0; i--)\n \t    align_tab[i] = seq;\n \t}\n-      if (GET_CODE (seq) != INSN || GET_CODE (PATTERN (seq)) != SEQUENCE)\n-\tinsn = seq;\n-      else\n+    }\n+#ifdef CASE_VECTOR_SHORTEN_MODE\n+  if (optimize)\n+    {\n+      /* Look for ADDR_DIFF_VECs, and initialize their minimum and maximum\n+         label fields.  */\n+\n+      int min_shuid = INSN_SHUID (get_insns ()) - 1;\n+      int max_shuid = INSN_SHUID (get_last_insn ()) + 1;\n+      int rel;\n+\n+      for (insn = first; insn != 0; insn = NEXT_INSN (insn))\n \t{\n-\t  insn = XVECEXP (PATTERN (seq), 0, 0);\n-\t  uid = INSN_UID (insn);\n+\t  rtx min_lab = NULL_RTX, max_lab = NULL_RTX, pat;\n+\t  int len, i, min, max, insn_shuid;\n+\t  int min_align;\n+\t  addr_diff_vec_flags flags;\n+\n+\t  if (GET_CODE (insn) != JUMP_INSN\n+\t      || GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC)\n+\t    continue;\n+\t  pat = PATTERN (insn);\n+\t  len = XVECLEN (pat, 1);\n+\t  if (len <= 0)\n+\t    abort ();\n+\t  min_align = MAX_CODE_ALIGN;\n+\t  for (min = max_shuid, max = min_shuid, i = len - 1; i >= 0; i--)\n+\t    {\n+\t      rtx lab = XEXP (XVECEXP (pat, 1, i), 0);\n+\t      int shuid = INSN_SHUID (lab);\n+\t      if (shuid < min)\n+\t\t{\n+\t\t  min = shuid;\n+\t\t  min_lab = lab;\n+\t\t}\n+\t      if (shuid > max)\n+\t\t{\n+\t\t  max = shuid;\n+\t\t  max_lab = lab;\n+\t\t}\n+\t      if (min_align > LABEL_TO_ALIGNMENT (lab))\n+\t\tmin_align = LABEL_TO_ALIGNMENT (lab);\n+\t    }\n+\t  XEXP (pat, 2) = gen_rtx_LABEL_REF (VOIDmode, min_lab);\n+\t  XEXP (pat, 3) = gen_rtx_LABEL_REF (VOIDmode, max_lab);\n+\t  insn_shuid = INSN_SHUID (insn);\n+\t  rel = INSN_SHUID (XEXP (XEXP (pat, 0), 0));\n+\t  flags.min_align = min_align;\n+\t  flags.base_after_vec = rel > insn_shuid;\n+\t  flags.min_after_vec  = min > insn_shuid;\n+\t  flags.max_after_vec  = max > insn_shuid;\n+\t  flags.min_after_base = min > rel;\n+\t  flags.max_after_base = max > rel;\n+\t  ADDR_DIFF_VEC_FLAGS (pat) = flags;\n \t}\n     }\n+#endif /* CASE_VECTOR_SHORTEN_MODE */\n \n \n   /* Compute initial lengths, addresses, and varying flags for each insn.  */\n@@ -1247,7 +1296,110 @@ shorten_branches (first)\n \t  insn_last_address = insn_addresses[uid];\n \t  insn_addresses[uid] = insn_current_address;\n \n-\t  if (! varying_length[uid])\n+\t  if (optimize && GET_CODE (insn) == JUMP_INSN\n+\t      && GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC)\n+\t    {\n+#ifdef CASE_VECTOR_SHORTEN_MODE\n+\t      rtx body = PATTERN (insn);\n+\t      int old_length = insn_lengths[uid];\n+\t      rtx rel_lab = XEXP (XEXP (body, 0), 0);\n+\t      rtx min_lab = XEXP (XEXP (body, 2), 0);\n+\t      rtx max_lab = XEXP (XEXP (body, 3), 0);\n+\t      addr_diff_vec_flags flags = ADDR_DIFF_VEC_FLAGS (body);\n+\t      int rel_addr = insn_addresses[INSN_UID (rel_lab)];\n+\t      int min_addr = insn_addresses[INSN_UID (min_lab)];\n+\t      int max_addr = insn_addresses[INSN_UID (max_lab)];\n+\t      rtx prev;\n+\t      int rel_align = 0;\n+\n+\t      /* Try to find a known alignment for rel_lab.  */\n+\t      for (prev = rel_lab;\n+\t\t   prev\n+\t\t   && ! insn_lengths[INSN_UID (prev)]\n+\t\t   && ! (varying_length[INSN_UID (prev)] & 1);\n+\t\t   prev = PREV_INSN (prev))\n+\t\tif (varying_length[INSN_UID (prev)] & 2)\n+\t\t  {\n+\t\t    rel_align = LABEL_TO_ALIGNMENT (prev);\n+\t\t    break;\n+\t\t  }\n+\n+\t      /* See the comment on addr_diff_vec_flags in rtl.h for the\n+\t\t meaning of the flags values.  base: REL_LAB   vec: INSN  */\n+\t      /* Anything after INSN has still addresses from the last\n+\t\t pass; adjust these so that they reflect our current\n+\t\t estimate for this pass.  */\n+\t      if (flags.base_after_vec)\n+\t\trel_addr += insn_current_address - insn_last_address;\n+\t      if (flags.min_after_vec)\n+\t\tmin_addr += insn_current_address - insn_last_address;\n+\t      if (flags.max_after_vec)\n+\t\tmax_addr += insn_current_address - insn_last_address;\n+\t      /* We want to know the worst case, i.e. lowest possible value\n+\t\t for the offset of MIN_LAB.  If MIN_LAB is after REL_LAB,\n+\t\t its offset is positive, and we have to be wary of code shrink;\n+\t\t otherwise, it is negative, and we have to be vary of code\n+\t\t size increase.  */\n+\t      if (flags.min_after_base)\n+\t\t{\n+\t\t  /* If INSN is between REL_LAB and MIN_LAB, the size\n+\t\t     changes we are about to make can change the alignment\n+\t\t     within the observed offset, therefore we have to break\n+\t\t     it up into two parts that are independent.  */\n+\t\t  if (! flags.base_after_vec && flags.min_after_vec)\n+\t\t    {\n+\t\t      min_addr -= align_fuzz (rel_lab, insn, rel_align, 0);\n+\t\t      min_addr -= align_fuzz (insn, min_lab, 0, 0);\n+\t\t    }\n+\t\t  else\n+\t\t    min_addr -= align_fuzz (rel_lab, min_lab, rel_align, 0);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (flags.base_after_vec && ! flags.min_after_vec)\n+\t\t    {\n+\t\t      min_addr -= align_fuzz (min_lab, insn, 0, ~0);\n+\t\t      min_addr -= align_fuzz (insn, rel_lab, 0, ~0);\n+\t\t    }\n+\t\t  else\n+\t\t    min_addr -= align_fuzz (min_lab, rel_lab, 0, ~0);\n+\t\t}\n+\t      /* Likewise, determine the highest lowest possible value\n+\t\t for the offset of MAX_LAB.  */\n+\t      if (flags.max_after_base)\n+\t\t{\n+\t\t  if (! flags.base_after_vec && flags.max_after_vec)\n+\t\t    {\n+\t\t      max_addr += align_fuzz (rel_lab, insn, rel_align, ~0);\n+\t\t      max_addr += align_fuzz (insn, max_lab, 0, ~0);\n+\t\t    }\n+\t\t  else\n+\t\t    max_addr += align_fuzz (rel_lab, max_lab, rel_align, ~0);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (flags.base_after_vec && ! flags.max_after_vec)\n+\t\t    {\n+\t\t      max_addr += align_fuzz (max_lab, insn, 0, 0);\n+\t\t      max_addr += align_fuzz (insn, rel_lab, 0, 0);\n+\t\t    }\n+\t\t  else\n+\t\t    max_addr += align_fuzz (max_lab, rel_lab, 0, 0);\n+\t\t}\n+\t      PUT_MODE (body, CASE_VECTOR_SHORTEN_MODE (min_addr - rel_addr,\n+\t\t\t\t\t\t\tmax_addr - rel_addr,\n+\t\t\t\t\t\t\tbody));\n+#if !defined(READONLY_DATA_SECTION) || defined(JUMP_TABLES_IN_TEXT_SECTION)\n+\t      insn_lengths[uid]\n+\t\t= (XVECLEN (body, 1) * GET_MODE_SIZE (GET_MODE (body)));\n+\t      insn_current_address += insn_lengths[uid];\n+\t      if (insn_lengths[uid] != old_length)\n+\t\tsomething_changed = 1;\n+#endif\n+\t      continue;\n+#endif /* CASE_VECTOR_SHORTEN_MODE */\n+\t    }\n+\t  else if (! (varying_length[uid]))\n \t    {\n \t      insn_current_address += insn_lengths[uid];\n \t      continue;\n@@ -2161,6 +2313,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n #ifdef ASM_OUTPUT_ADDR_DIFF_ELT\n \t\t    ASM_OUTPUT_ADDR_DIFF_ELT\n \t\t      (file,\n+\t\t       body,\n \t\t       CODE_LABEL_NUMBER (XEXP (XVECEXP (body, 1, idx), 0)),\n \t\t       CODE_LABEL_NUMBER (XEXP (XEXP (body, 0), 0)));\n #else"}, {"sha": "c8ed3e0a6c29136c8abd49a4a86ec5c702935f70", "filename": "gcc/rtl.def", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -442,8 +442,27 @@ DEF_RTL_EXPR(ADDR_VEC, \"addr_vec\", \"E\", 'x')\n /* Vector of address differences X0 - BASE, X1 - BASE, ...\n    First operand is BASE; the vector contains the X's.\n    The machine mode of this rtx says how much space to leave\n-   for each difference.  */\n-DEF_RTL_EXPR(ADDR_DIFF_VEC, \"addr_diff_vec\", \"eE\", 'x')\n+   for each difference and is adjusted by branch shortening if\n+   CASE_VECTOR_SHORTEN_MODE is defined.\n+   The third and fourth operands store the target labels with the\n+   minimum and maximum addresses respectively.\n+   The fifth operand stores flags for use by branch shortening.\n+  Set at the start of shorten_branches:\n+   min_align: the minimum alignment for any of the target labels.\n+   base_after_vec: true iff BASE is after the ADDR_DIFF_VEC.\n+   min_after_vec: true iff minimum addr target label is after the ADDR_DIFF_VEC.\n+   max_after_vec: true iff maximum addr target label is after the ADDR_DIFF_VEC.\n+   min_after_base: true iff minimum address target label is after BASE.\n+   max_after_base: true iff maximum address target label is after BASE.\n+  Set by the actual branch shortening process:\n+   offset_unsigned: true iff offsets have to be treated as unsigned.\n+   scale: scaling that is necessary to make offsets fit into the mode.\n+\n+   The third, fourth and fifth operands are only valid when\n+   CASE_VECTOR_SHORTEN_MODE is defined, and only in an optimizing\n+   compilations.  */\n+     \n+DEF_RTL_EXPR(ADDR_DIFF_VEC, \"addr_diff_vec\", \"eEeei\", 'x')\n \n /* ----------------------------------------------------------------------\n    At the top level of an instruction (perhaps under PARALLEL)."}, {"sha": "c78b9478258abd864c69842c6555f7071729f950", "filename": "gcc/rtl.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -60,6 +60,24 @@ extern char *rtx_format[];\n extern char rtx_class[];\n #define GET_RTX_CLASS(CODE)\t\t(rtx_class[(int) (CODE)])\n \f\n+/* The flags and bitfields of an ADDR_DIFF_VEC.  BASE is the base label\n+   relative to which the offsets are calculated, as explained in rtl.def.  */\n+typedef struct\n+{\n+  /* Set at the start of shorten_branches - ONLY WHEN OPTIMIZING - : */\n+  unsigned min_align: 8;\n+  /* Flags: */\n+  unsigned base_after_vec: 1; /* BASE is after the ADDR_DIFF_VEC.  */\n+  unsigned min_after_vec: 1;  /* minimum address target label is after the ADDR_DIFF_VEC.  */\n+  unsigned max_after_vec: 1;  /* maximum address target label is after the ADDR_DIFF_VEC.  */\n+  unsigned min_after_base: 1; /* minimum address target label is after BASE.  */\n+  unsigned max_after_base: 1; /* maximum address target label is after BASE.  */\n+  /* Set by the actual branch shortening process - ONLY WHEN OPTIMIZING - : */\n+  unsigned offset_unsigned: 1; /* offsets have to be treated as unsigned.  */\n+  unsigned : 2;\n+  unsigned scale : 8;\n+} addr_diff_vec_flags;\n+\n /* Common union for an element of an rtx.  */\n \n typedef union rtunion_def\n@@ -70,6 +88,7 @@ typedef union rtunion_def\n   struct rtx_def *rtx;\n   struct rtvec_def *rtvec;\n   enum machine_mode rttype;\n+  addr_diff_vec_flags rt_addr_diff_vec_flags;\n } rtunion;\n \n /* RTL expression (\"rtx\").  */\n@@ -318,6 +337,8 @@ typedef struct rtvec_def{\n \n #define REG_NOTES(INSN)\t((INSN)->fld[6].rtx)\n \n+#define ADDR_DIFF_VEC_FLAGS(RTX) ((RTX)->fld[4].rt_addr_diff_vec_flags)\n+\n /* Don't forget to change reg_note_name in rtl.c.  */\n enum reg_note { REG_DEAD = 1, REG_INC = 2, REG_EQUIV = 3, REG_WAS_0 = 4,\n \t\tREG_EQUAL = 5, REG_RETVAL = 6, REG_LIBCALL = 7,"}, {"sha": "6d9cf7f95e111d64817d59f1c061ebd8f8851542", "filename": "gcc/rtl.texi", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.texi?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -2004,11 +2004,15 @@ how much space is given to each address; normally @var{m} would be\n @code{Pmode}.\n \n @findex addr_diff_vec\n-@item (addr_diff_vec:@var{m} @var{base} [@var{lr0} @var{lr1} @dots{}])\n+@item (addr_diff_vec:@var{m} @var{base} [@var{lr0} @var{lr1} @dots{}] @var{min} @var{max} @var{flags})\n Represents a table of jump addresses expressed as offsets from\n @var{base}.  The vector elements @var{lr0}, etc., are @code{label_ref}\n expressions and so is @var{base}.  The mode @var{m} specifies how much\n-space is given to each address-difference.@refill\n+space is given to each address-difference.  @var{min} and @var{max}\n+are set up by branch shortening and hold a label with a minimum and a\n+maximum address, respectively.  @var{flags} indicates the relative\n+position of @var{base}, @var{min} and @var{max} to the cointaining insn\n+and of @var{min} and @var{max} to @var{base}.  See rtl.def for details.@refill\n @end table\n \n @node Incdec, Assembler, Side Effects, RTL"}, {"sha": "8d5d73ec7e838eb6300d08670774738a7e32a704", "filename": "gcc/stmt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -4937,7 +4937,8 @@ expand_end_case (orig_index)\n \t  if (CASE_VECTOR_PC_RELATIVE || flag_pic)\n \t    emit_jump_insn (gen_rtx_ADDR_DIFF_VEC (CASE_VECTOR_MODE,\n \t\t\t\t\t\t   gen_rtx_LABEL_REF (Pmode, table_label),\n-\t\t\t\t\t\t   gen_rtvec_v (ncases, labelvec)));\n+\t\t\t\t\t\t   gen_rtvec_v (ncases, labelvec),\n+\t\t\t\t\t\t    const0_rtx, const0_rtx, 0));\n \t  else\n \t    emit_jump_insn (gen_rtx_ADDR_VEC (CASE_VECTOR_MODE,\n \t\t\t\t\t      gen_rtvec_v (ncases, labelvec)));"}, {"sha": "e0e31fda7721160971782af68c07440cf4919e81", "filename": "gcc/tm.texi", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f7f3538517099ebde6568a519d1449a08cb37d/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=33f7f3538517099ebde6568a519d1449a08cb37d", "patch": "@@ -6004,7 +6004,7 @@ This concerns dispatch tables.\n @table @code\n @cindex dispatch table\n @findex ASM_OUTPUT_ADDR_DIFF_ELT\n-@item ASM_OUTPUT_ADDR_DIFF_ELT (@var{stream}, @var{value}, @var{rel})\n+@item ASM_OUTPUT_ADDR_DIFF_ELT (@var{stream}, @var{body}, @var{value}, @var{rel})\n A C statement to output to the stdio stream @var{stream} an assembler\n pseudo-instruction to generate a difference between two labels.\n @var{value} and @var{rel} are the numbers of two internal labels.  The\n@@ -6020,6 +6020,8 @@ fprintf (@var{stream}, \"\\t.word L%d-L%d\\n\",\n You must provide this macro on machines where the addresses in a\n dispatch table are relative to the table's own address.  If defined, GNU\n CC will also use this macro on all machines when producing PIC.\n+@var{body} is the body of the ADDR_DIFF_VEC; it is provided so that the\n+mode and flags can be read.\n \n @findex ASM_OUTPUT_ADDR_VEC_ELT\n @item ASM_OUTPUT_ADDR_VEC_ELT (@var{stream}, @var{value})\n@@ -6857,6 +6859,16 @@ patterns.\n An alias for a machine mode name.  This is the machine mode that\n elements of a jump-table should have.\n \n+@findex CASE_VECTOR_SHORTEN_MODE\n+@item CASE_VECTOR_SHORTEN_MODE (@var{min_offset}, @var{max_offset}, @var{body})\n+Optional: return the preferred mode for an @code{addr_diff_vec}\n+when the minimum and maximum offset are known.  If you define this,\n+it enables extra code in branch shortening to deal with @code{addr_diff_vec}.\n+To make this work, you also have to define INSN_ALIGN and \n+make the alignment for @code{addr_diff_vec} explicit.\n+The @var{body} argument is provided so that teh offset_unsigned and scale\n+flags can be updated.\n+\n @findex CASE_VECTOR_PC_RELATIVE\n @item CASE_VECTOR_PC_RELATIVE\n Define this macro to be a C expression to indicate when jump-tables"}]}