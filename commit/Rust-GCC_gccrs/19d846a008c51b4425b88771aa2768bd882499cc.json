{"sha": "19d846a008c51b4425b88771aa2768bd882499cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTlkODQ2YTAwOGM1MWI0NDI1Yjg4NzcxYWEyNzY4YmQ4ODI0OTljYw==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2010-06-18T09:41:49Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-18T09:41:49Z"}, "message": "checks.adb (Safe_To_Capture_In_Parameter_Value): Deal with case expression (cannot count on a particular branch being executed).\n\n2010-06-18  Robert Dewar  <dewar@adacore.com>\n\n\t* checks.adb (Safe_To_Capture_In_Parameter_Value): Deal with case\n\texpression (cannot count on a particular branch being executed).\n\t* exp_ch4.adb (Expand_N_Case_Expression): New procedure.\n\t* exp_ch4.ads (Expand_N_Case_Expression): New procedure.\n\t* exp_util.adb (Insert_Actions): Deal with proper insertion of actions\n\twithin case expression.\n\t* expander.adb (Expand): Add call to Expand_N_Case_Expression\n\t* par-ch4.adb Add calls to P_Case_Expression at appropriate points\n\t(P_Case_Expression): New procedure\n\t(P_Case_Expression_Alternative): New procedure\n\t* par.adb (P_Case_Expression): New procedure\n\t* par_sco.adb (Process_Decisions): Add dummy place holder entry for\n\tN_Case_Expression.\n\t* sem.adb (Analyze): Add call to Analyze_Case_Expression\n\t* sem_case.ads (Analyze_Choices): Also used for case expressions now,\n\tthis is a documentation change only.\n\t* sem_ch4.ads, sem_ch4.adb (Analyze_Case_Expression): New procedure.\n\t* sem_ch6.adb (Fully_Conformant_Expressions): Add handling of case\n\texpressions.\n\t* sem_eval.ads, sem_eval.adb (Eval_Case_Expression): New procedure.\n\t* sem_res.adb (Resolve_Case_Expression): New procedure.\n\t* sem_scil.adb (Find_SCIL_Node): Add processing for\n\tN_Case_Expression_Alternative.\n\t* sinfo.ads, sinfo.adb (N_Case_Expression): New node.\n\t(N_Case_Expression_Alternative): New node.\n\t* sprint.adb (Sprint_Node_Actual): Add processing for new nodes\n\tN_Case_Expression and N_Case_Expression_Alternative.\n\n2010-06-18  Robert Dewar  <dewar@adacore.com>\n\n\t* par-ch7.adb, sem_warn.adb, types.ads, par-ch3.adb: Minor reformatting.\n\t* gnat1drv.adb: Fix typo.\n\n2010-06-18  Robert Dewar  <dewar@adacore.com>\n\n\t* par-prag.adb (Prag, case Style_Checks): All_Checks sets gnat style\n\tfor -gnatg.\n\t* sem_prag.adb (Analyze_Pragma, case Style_Checks): All_Checks sets\n\tgnat style for -gnatg.\n\t* gnat_rm.texi: Add documentation for ALL_CHECKS in GNAT mode.\n\nFrom-SVN: r160971", "tree": {"sha": "6345fad875d9b717d4e71879be479d45f16114aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6345fad875d9b717d4e71879be479d45f16114aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19d846a008c51b4425b88771aa2768bd882499cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19d846a008c51b4425b88771aa2768bd882499cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19d846a008c51b4425b88771aa2768bd882499cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19d846a008c51b4425b88771aa2768bd882499cc/comments", "author": null, "committer": null, "parents": [{"sha": "305caf424d1720f082b9cdfc072d29ae553afebc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/305caf424d1720f082b9cdfc072d29ae553afebc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/305caf424d1720f082b9cdfc072d29ae553afebc"}], "stats": {"total": 1219, "additions": 978, "deletions": 241}, "files": [{"sha": "f76b284c1d605fd24213906071867763fc46d8fb", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=19d846a008c51b4425b88771aa2768bd882499cc", "patch": "@@ -1,3 +1,46 @@\n+2010-06-18  Robert Dewar  <dewar@adacore.com>\n+\n+\t* checks.adb (Safe_To_Capture_In_Parameter_Value): Deal with case\n+\texpression (cannot count on a particular branch being executed).\n+\t* exp_ch4.adb (Expand_N_Case_Expression): New procedure.\n+\t* exp_ch4.ads (Expand_N_Case_Expression): New procedure.\n+\t* exp_util.adb (Insert_Actions): Deal with proper insertion of actions\n+\twithin case expression.\n+\t* expander.adb (Expand): Add call to Expand_N_Case_Expression\n+\t* par-ch4.adb Add calls to P_Case_Expression at appropriate points\n+\t(P_Case_Expression): New procedure\n+\t(P_Case_Expression_Alternative): New procedure\n+\t* par.adb (P_Case_Expression): New procedure\n+\t* par_sco.adb (Process_Decisions): Add dummy place holder entry for\n+\tN_Case_Expression.\n+\t* sem.adb (Analyze): Add call to Analyze_Case_Expression\n+\t* sem_case.ads (Analyze_Choices): Also used for case expressions now,\n+\tthis is a documentation change only.\n+\t* sem_ch4.ads, sem_ch4.adb (Analyze_Case_Expression): New procedure.\n+\t* sem_ch6.adb (Fully_Conformant_Expressions): Add handling of case\n+\texpressions.\n+\t* sem_eval.ads, sem_eval.adb (Eval_Case_Expression): New procedure.\n+\t* sem_res.adb (Resolve_Case_Expression): New procedure.\n+\t* sem_scil.adb (Find_SCIL_Node): Add processing for\n+\tN_Case_Expression_Alternative.\n+\t* sinfo.ads, sinfo.adb (N_Case_Expression): New node.\n+\t(N_Case_Expression_Alternative): New node.\n+\t* sprint.adb (Sprint_Node_Actual): Add processing for new nodes\n+\tN_Case_Expression and N_Case_Expression_Alternative.\n+\n+2010-06-18  Robert Dewar  <dewar@adacore.com>\n+\n+\t* par-ch7.adb, sem_warn.adb, types.ads, par-ch3.adb: Minor reformatting.\n+\t* gnat1drv.adb: Fix typo.\n+\n+2010-06-18  Robert Dewar  <dewar@adacore.com>\n+\n+\t* par-prag.adb (Prag, case Style_Checks): All_Checks sets gnat style\n+\tfor -gnatg.\n+\t* sem_prag.adb (Analyze_Pragma, case Style_Checks): All_Checks sets\n+\tgnat style for -gnatg.\n+\t* gnat_rm.texi: Add documentation for ALL_CHECKS in GNAT mode.\n+\n 2010-06-18  Thomas Quinot  <quinot@adacore.com>\n \n \t* sem_eval.adb (Test_In_Range): New subprogram, factoring duplicated"}, {"sha": "89f52a9954d6609631fa9b571c68bb99f956145c", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=19d846a008c51b4425b88771aa2768bd882499cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2741,9 +2741,11 @@ package body Checks is\n          end case;\n \n          if K = N_Op_And then\n-            Error_Msg_N (\"use `AND THEN` instead of AND?\", P);\n+            Error_Msg_N -- CODEFIX\n+              (\"use `AND THEN` instead of AND?\", P);\n          else\n-            Error_Msg_N (\"use `OR ELSE` instead of OR?\", P);\n+            Error_Msg_N -- CODEFIX\n+              (\"use `OR ELSE` instead of OR?\", P);\n          end if;\n \n          --  If not short-circuited, we need the ckeck\n@@ -2849,7 +2851,7 @@ package body Checks is\n          --  applied to an access [sub]type.\n \n          if not Is_Access_Type (Typ) then\n-            Error_Msg_N\n+            Error_Msg_N -- CODEFIX???\n               (\"`NOT NULL` allowed only for an access type\", Error_Node);\n \n          --  Enforce legality rule RM 3.10(14/1): A null exclusion can only\n@@ -2858,7 +2860,7 @@ package body Checks is\n          elsif Can_Never_Be_Null (Typ)\n            and then Comes_From_Source (Typ)\n          then\n-            Error_Msg_NE\n+            Error_Msg_NE -- CODEFIX???\n               (\"`NOT NULL` not allowed (& already excludes null)\",\n                Error_Node, Typ);\n          end if;\n@@ -5293,6 +5295,16 @@ package body Checks is\n                   return False;\n                end if;\n \n+               --  If we are in a case eexpression, and not part of the\n+               --  expression, then we return False, since a particular\n+               --  branch may not always be elaborated\n+\n+               if Nkind (P) = N_Case_Expression\n+                 and then N /= Expression (P)\n+               then\n+                  return False;\n+               end if;\n+\n                --  While traversing the parent chain, we find that N\n                --  belongs to a statement, thus it may never appear in\n                --  a declarative region."}, {"sha": "9a67fa9cdd8029d30c7742983668665cd8539471", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=19d846a008c51b4425b88771aa2768bd882499cc", "patch": "@@ -3878,6 +3878,137 @@ package body Exp_Ch4 is\n    procedure Expand_N_And_Then (N : Node_Id)\n      renames Expand_Short_Circuit_Operator;\n \n+   ------------------------------\n+   -- Expand_N_Case_Expression --\n+   ------------------------------\n+\n+   procedure Expand_N_Case_Expression (N : Node_Id) is\n+      Loc     : constant Source_Ptr := Sloc (N);\n+      Typ     : constant Entity_Id  := Etype (N);\n+      Cstmt   : Node_Id;\n+      Tnn     : Entity_Id;\n+      Pnn     : Entity_Id;\n+      Actions : List_Id;\n+      Ttyp    : Entity_Id;\n+      Alt     : Node_Id;\n+      Fexp    : Node_Id;\n+\n+   begin\n+      --  We expand\n+\n+      --    case X is when A => AX, when B => BX ...\n+\n+      --  to\n+\n+      --    do\n+      --       Tnn : typ;\n+      --       case X is\n+      --          when A =>\n+      --             Tnn := AX;\n+      --          when B =>\n+      --             Tnn := BX;\n+      --          ...\n+      --       end case;\n+      --    in Tnn end;\n+\n+      --  However, this expansion is wrong for limited types, and also\n+      --  wrong for unconstrained types (since the bounds may not be the\n+      --  same in all branches). Furthermore it involves an extra copy\n+      --  for large objects. So we take care of this by using the following\n+      --  modified expansion for non-scalar types:\n+\n+      --    do\n+      --       type Pnn is access all typ;\n+      --       Tnn : Pnn;\n+      --       case X is\n+      --          when A =>\n+      --             T := AX'Unrestricted_Access;\n+      --          when B =>\n+      --             T := BX'Unrestricted_Access;\n+      --          ...\n+      --       end case;\n+      --    in Tnn.all end;\n+\n+      Cstmt :=\n+        Make_Case_Statement (Loc,\n+          Expression   => Expression (N),\n+          Alternatives => New_List);\n+\n+      Actions := New_List;\n+\n+      --  Scalar case\n+\n+      if Is_Scalar_Type (Typ) then\n+         Ttyp := Typ;\n+\n+      else\n+         Pnn := Make_Temporary (Loc, 'P');\n+         Append_To (Actions,\n+           Make_Full_Type_Declaration (Loc,\n+             Defining_Identifier => Pnn,\n+             Type_Definition =>\n+               Make_Access_To_Object_Definition (Loc,\n+                 All_Present => True,\n+                 Subtype_Indication =>\n+                   New_Reference_To (Typ, Loc))));\n+         Ttyp := Pnn;\n+      end if;\n+\n+      Tnn := Make_Temporary (Loc, 'T');\n+      Append_To (Actions,\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Tnn,\n+          Object_Definition   => New_Occurrence_Of (Ttyp, Loc)));\n+\n+      --  Now process the alternatives\n+\n+      Alt := First (Alternatives (N));\n+      while Present (Alt) loop\n+         declare\n+            Aexp : Node_Id             := Expression (Alt);\n+            Aloc : constant Source_Ptr := Sloc (Aexp);\n+\n+         begin\n+            if not Is_Scalar_Type (Typ) then\n+               Aexp :=\n+                 Make_Attribute_Reference (Aloc,\n+                   Prefix         => Relocate_Node (Aexp),\n+                   Attribute_Name => Name_Unrestricted_Access);\n+            end if;\n+\n+            Append_To\n+              (Alternatives (Cstmt),\n+               Make_Case_Statement_Alternative (Sloc (Alt),\n+                 Discrete_Choices => Discrete_Choices (Alt),\n+                 Statements       => New_List (\n+                   Make_Assignment_Statement (Aloc,\n+                     Name       => New_Occurrence_Of (Tnn, Loc),\n+                     Expression => Aexp))));\n+         end;\n+\n+         Next (Alt);\n+      end loop;\n+\n+      Append_To (Actions, Cstmt);\n+\n+      --  Construct and return final expression with actions\n+\n+      if Is_Scalar_Type (Typ) then\n+         Fexp := New_Occurrence_Of (Tnn, Loc);\n+      else\n+         Fexp :=\n+           Make_Explicit_Dereference (Loc,\n+             Prefix => New_Occurrence_Of (Tnn, Loc));\n+      end if;\n+\n+      Rewrite (N,\n+        Make_Expression_With_Actions (Loc,\n+          Expression => Fexp,\n+          Actions    => Actions));\n+\n+      Analyze_And_Resolve (N, Typ);\n+   end Expand_N_Case_Expression;\n+\n    -------------------------------------\n    -- Expand_N_Conditional_Expression --\n    -------------------------------------"}, {"sha": "745ce294d6ad67fb6f6c85e1cd5c515cfa92d932", "filename": "gcc/ada/exp_ch4.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fexp_ch4.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fexp_ch4.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.ads?ref=19d846a008c51b4425b88771aa2768bd882499cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,6 +31,7 @@ package Exp_Ch4 is\n \n    procedure Expand_N_Allocator                   (N : Node_Id);\n    procedure Expand_N_And_Then                    (N : Node_Id);\n+   procedure Expand_N_Case_Expression             (N : Node_Id);\n    procedure Expand_N_Conditional_Expression      (N : Node_Id);\n    procedure Expand_N_Explicit_Dereference        (N : Node_Id);\n    procedure Expand_N_In                          (N : Node_Id);"}, {"sha": "e8a85103be8714d383e8b1580a115541d3ebf99d", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=19d846a008c51b4425b88771aa2768bd882499cc", "patch": "@@ -2417,6 +2417,21 @@ package body Exp_Util is\n                   end if;\n                end;\n \n+            --  Alternative of case expression, we place the action in\n+            --  the Actions field of the case expression alternative, this\n+            --  will be handled when the case expression is expanded.\n+\n+            when N_Case_Expression_Alternative =>\n+               if Present (Actions (P)) then\n+                  Insert_List_After_And_Analyze\n+                    (Last (Actions (P)), Ins_Actions);\n+               else\n+                  Set_Actions (P, Ins_Actions);\n+                  Analyze_List (Then_Actions (P));\n+               end if;\n+\n+               return;\n+\n             --  Case of appearing within an Expressions_With_Actions node. We\n             --  prepend the actions to the list of actions already there.\n \n@@ -2679,6 +2694,7 @@ package body Exp_Util is\n                N_Access_To_Object_Definition            |\n                N_Aggregate                              |\n                N_Allocator                              |\n+               N_Case_Expression                        |\n                N_Case_Statement_Alternative             |\n                N_Character_Literal                      |\n                N_Compilation_Unit                       |"}, {"sha": "cc2122dd6e60857bb7b928c20d0982619e156105", "filename": "gcc/ada/expander.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fexpander.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fexpander.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexpander.adb?ref=19d846a008c51b4425b88771aa2768bd882499cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -163,6 +163,9 @@ package body Expander is\n                when N_Block_Statement =>\n                   Expand_N_Block_Statement (N);\n \n+               when N_Case_Expression =>\n+                  Expand_N_Case_Expression (N);\n+\n                when N_Case_Statement =>\n                   Expand_N_Case_Statement (N);\n \n@@ -470,7 +473,6 @@ package body Expander is\n \n          Debug_A_Exit (\"expanding  \", N, \"  (done)\");\n       end if;\n-\n    end Expand;\n \n    ---------------------------"}, {"sha": "a69f732a54a49d482eb3551c18509f73385e61d0", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=19d846a008c51b4425b88771aa2768bd882499cc", "patch": "@@ -366,7 +366,7 @@ procedure Gnat1drv is\n \n       --  Debug flag -gnatd.L decisively sets usage on\n \n-      if Debug_Flag_Dot_XX then\n+      if Debug_Flag_Dot_LL then\n          Back_End_Handles_Limited_Types := True;\n \n       --  If no debug flag, usage off for AAMP, VM, SCIL cases"}, {"sha": "accb855111cdce5c7ed33512065586b73d1ba21f", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=19d846a008c51b4425b88771aa2768bd882499cc", "patch": "@@ -4536,7 +4536,11 @@ gcc -c -gnatyl @dots{}\n The form ALL_CHECKS activates all standard checks (its use is equivalent\n to the use of the @code{gnaty} switch with no options.  @xref{Top,\n @value{EDITION} User's Guide, About This Guide, gnat_ugn,\n-@value{EDITION} User's Guide}, for details.\n+@value{EDITION} User's Guide}, for details.)\n+\n+Note: the behavior is slightly different in GNAT mode (@option{-gnatg} used).\n+In this case, ALL_CHECKS implies the standard set of GNAT mode style check\n+options (i.e. equivalent to -gnatyg).\n \n The forms with @code{Off} and @code{On}\n can be used to temporarily disable style checks"}, {"sha": "c0ae8b326696f060c1cc8238a4dafd588906d616", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=19d846a008c51b4425b88771aa2768bd882499cc", "patch": "@@ -111,7 +111,6 @@ package body Ch3 is\n    --  current token, and if this is the first such message issued, saves\n    --  the message id in Missing_Begin_Msg, for possible later replacement.\n \n-\n    ---------------------------------\n    -- Check_Restricted_Expression --\n    ---------------------------------"}, {"sha": "bb2063f04dc25406686afcc8707b31647ba675f4", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 151, "deletions": 18, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=19d846a008c51b4425b88771aa2768bd882499cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -63,6 +63,7 @@ package body Ch4 is\n \n    function P_Aggregate_Or_Paren_Expr                 return Node_Id;\n    function P_Allocator                               return Node_Id;\n+   function P_Case_Expression_Alternative             return Node_Id;\n    function P_Record_Or_Array_Component_Association   return Node_Id;\n    function P_Factor                                  return Node_Id;\n    function P_Primary                                 return Node_Id;\n@@ -366,7 +367,8 @@ package body Ch4 is\n             begin\n                if Token_Is_At_Start_Of_Line then\n                   Restore_Scan_State (Scan_State); -- to apostrophe\n-                  Error_Msg_SC (\"|\"\"''\"\" should be \"\";\"\"\");\n+                  Error_Msg_SC -- CODEFIX???\n+                    (\"|\"\"''\"\" should be \"\";\"\"\");\n                   Token := Tok_Semicolon;\n                   return True;\n                else\n@@ -738,7 +740,8 @@ package body Ch4 is\n          --  a possible fix.\n \n          if Nkind (Expr_Node) = N_Op_Eq then\n-            Error_Msg_N (\"\\maybe `='>` was intended\", Expr_Node);\n+            Error_Msg_N -- CODEFIX???\n+              (\"\\maybe `='>` was intended\", Expr_Node);\n          end if;\n \n          --  We go back to scanning out expressions, so that we do not get\n@@ -1089,7 +1092,7 @@ package body Ch4 is\n            and then\n          Nkind (Aggr_Node) /= N_Extension_Aggregate\n       then\n-         Error_Msg\n+         Error_Msg -- CODEFIX???\n            (\"aggregate may not have single positional component\", Aggr_Sloc);\n          return Error;\n       else\n@@ -1164,6 +1167,13 @@ package body Ch4 is\n          T_Right_Paren;\n          return Expr_Node;\n \n+      --  Case expression case\n+\n+      elsif Token = Tok_Case then\n+         Expr_Node := P_Case_Expression;\n+         T_Right_Paren;\n+         return Expr_Node;\n+\n       --  Note: the mechanism used here of rescanning the initial expression\n       --  is distinctly unpleasant, but it saves a lot of fiddling in scanning\n       --  out the discrete choice list.\n@@ -1254,7 +1264,7 @@ package body Ch4 is\n             if Nkind (Expr_Node) = N_Attribute_Reference\n               and then Attribute_Name (Expr_Node) = Name_Range\n             then\n-               Error_Msg\n+               Error_Msg -- CODEFIX???\n                  (\"|parentheses not allowed for range attribute\", Lparen_Sloc);\n                Scan; -- past right paren\n                return Expr_Node;\n@@ -1332,7 +1342,7 @@ package body Ch4 is\n            or else Token = Tok_Semicolon\n          then\n             if Present (Assoc_List) then\n-               Error_Msg_BC\n+               Error_Msg_BC -- CODEFIX\n                   (\"\"\"='>\"\" expected (positional association cannot follow \" &\n                    \"named association)\");\n             end if;\n@@ -1570,12 +1580,14 @@ package body Ch4 is\n    end P_Expression;\n \n    --  This function is identical to the normal P_Expression, except that it\n-   --  also permits the appearence of a conditional expression without the\n-   --  usual surrounding parentheses.\n+   --  also permits the appearence of a case of conditional expression without\n+   --  the usual surrounding parentheses.\n \n    function P_Expression_If_OK return Node_Id is\n    begin\n-      if Token = Tok_If then\n+      if Token = Tok_Case then\n+         return P_Case_Expression;\n+      elsif Token = Tok_If then\n          return P_Conditional_Expression;\n       else\n          return P_Expression;\n@@ -1672,11 +1684,13 @@ package body Ch4 is\n       end if;\n    end P_Expression_Or_Range_Attribute;\n \n-   --  Version that allows a non-parenthesized conditional expression\n+   --  Version that allows a non-parenthesized case or conditional expression\n \n    function P_Expression_Or_Range_Attribute_If_OK return Node_Id is\n    begin\n-      if Token = Tok_If then\n+      if Token = Tok_Case then\n+         return P_Case_Expression;\n+      elsif Token = Tok_If then\n          return P_Conditional_Expression;\n       else\n          return P_Expression_Or_Range_Attribute;\n@@ -2117,7 +2131,8 @@ package body Ch4 is\n                   Scan; -- scan past right paren if present\n                end if;\n \n-               Error_Msg (\"parentheses not allowed for range attribute\", Lptr);\n+               Error_Msg -- CODEFIX???\n+                 (\"parentheses not allowed for range attribute\", Lptr);\n \n                return Attr_Node;\n             end if;\n@@ -2339,10 +2354,10 @@ package body Ch4 is\n                   return Error;\n \n                --  If this looks like a conditional expression, then treat it\n-               --  that way with an error messasge.\n+               --  that way with an error message.\n \n                elsif Extensions_Allowed then\n-                  Error_Msg_SC\n+                  Error_Msg_SC -- CODEFIX???\n                     (\"conditional expression must be parenthesized\");\n                   return P_Conditional_Expression;\n \n@@ -2352,6 +2367,32 @@ package body Ch4 is\n                   return P_Identifier;\n                end if;\n \n+            --  Deal with CASE (possible unparenthesized case expression)\n+\n+            when Tok_Case =>\n+\n+               --  If this looks like a real case, defined as a CASE appearing\n+               --  the start of a new line, then we consider we have a missing\n+               --  operand.\n+\n+               if Token_Is_At_Start_Of_Line then\n+                  Error_Msg_AP (\"missing operand\");\n+                  return Error;\n+\n+               --  If this looks like a case expression, then treat it that way\n+               --  with an error message.\n+\n+               elsif Extensions_Allowed then\n+                  Error_Msg_SC -- CODEFIX???\n+                    (\"case expression must be parenthesized\");\n+                  return P_Case_Expression;\n+\n+               --  Otherwise treat as misused identifier\n+\n+               else\n+                  return P_Identifier;\n+               end if;\n+\n             --  Anything else is illegal as the first token of a primary, but\n             --  we test for a reserved identifier so that it is treated nicely\n \n@@ -2360,7 +2401,8 @@ package body Ch4 is\n                   return P_Identifier;\n \n                elsif Prev_Token = Tok_Comma then\n-                  Error_Msg_SP (\"|extra \"\",\"\" ignored\");\n+                  Error_Msg_SP -- CODEFIX\n+                    (\"|extra \"\",\"\" ignored\");\n                   raise Error_Resync;\n \n                else\n@@ -2458,7 +2500,8 @@ package body Ch4 is\n \n    begin\n       if Token = Tok_Box then\n-         Error_Msg_SC (\"|\"\"'<'>\"\" should be \"\"/=\"\"\");\n+         Error_Msg_SC -- CODEFIX\n+           (\"|\"\"'<'>\"\" should be \"\"/=\"\"\");\n       end if;\n \n       Op_Kind := Relop_Node (Token);\n@@ -2620,6 +2663,95 @@ package body Ch4 is\n       return Alloc_Node;\n    end P_Allocator;\n \n+   -----------------------\n+   -- P_Case_Expression --\n+   -----------------------\n+\n+   function P_Case_Expression return Node_Id is\n+      Loc        : constant Source_Ptr := Token_Ptr;\n+      Case_Node  : Node_Id;\n+      Save_State : Saved_Scan_State;\n+\n+   begin\n+      if not Extensions_Allowed then\n+         Error_Msg_SC (\"|case expression is an Ada extension\");\n+         Error_Msg_SC (\"\\|use -gnatX switch to compile this unit\");\n+      end if;\n+\n+      Scan; -- past CASE\n+      Case_Node :=\n+        Make_Case_Expression (Loc,\n+          Expression   => P_Expression_No_Right_Paren,\n+          Alternatives => New_List);\n+      T_Is;\n+\n+      --  We now have scanned out CASE expression IS, scan alternatives\n+\n+      loop\n+         T_When;\n+         Append_To (Alternatives (Case_Node), P_Case_Expression_Alternative);\n+\n+         --  Missing comma if WHEN (more alternatives present)\n+\n+         if Token = Tok_When then\n+            T_Comma;\n+\n+         --  If comma/WHEN, skip comma and we have another alternative\n+\n+         elsif Token = Tok_Comma then\n+            Save_Scan_State (Save_State);\n+            Scan; -- past comma\n+\n+            if Token /= Tok_When then\n+               Restore_Scan_State (Save_State);\n+               exit;\n+            end if;\n+\n+         --  If no comma or WHEN, definitely done\n+\n+         else\n+            exit;\n+         end if;\n+      end loop;\n+\n+      --  If we have an END CASE, diagnose as not needed\n+\n+      if Token = Tok_End then\n+         Error_Msg_SC -- CODEFIX???\n+           (\"`END CASE` not allowed at end of case expression\");\n+         Scan; -- past END\n+\n+         if Token = Tok_Case then\n+            Scan; -- past CASE;\n+         end if;\n+      end if;\n+\n+      --  Return the Case_Expression node\n+\n+      return Case_Node;\n+   end P_Case_Expression;\n+\n+   -----------------------------------\n+   -- P_Case_Expression_Alternative --\n+   -----------------------------------\n+\n+   --  CASE_STATEMENT_ALTERNATIVE ::=\n+   --    when DISCRETE_CHOICE_LIST =>\n+   --      EXPRESSION\n+\n+   --  The caller has checked that and scanned past the initial WHEN token\n+   --  Error recovery: can raise Error_Resync\n+\n+   function P_Case_Expression_Alternative return Node_Id is\n+      Case_Alt_Node : Node_Id;\n+   begin\n+      Case_Alt_Node := New_Node (N_Case_Expression_Alternative, Token_Ptr);\n+      Set_Discrete_Choices (Case_Alt_Node, P_Discrete_Choice_List);\n+      TF_Arrow;\n+      Set_Expression (Case_Alt_Node, P_Expression);\n+      return Case_Alt_Node;\n+   end P_Case_Expression_Alternative;\n+\n    ------------------------------\n    -- P_Conditional_Expression --\n    ------------------------------\n@@ -2652,7 +2784,8 @@ package body Ch4 is\n          Scan; -- past semicolon\n \n          if Token = Tok_Else or else Token = Tok_Elsif then\n-            Error_Msg_SP (\"|extra \"\";\"\" ignored\");\n+            Error_Msg_SP -- CODEFIX\n+              (\"|extra \"\";\"\" ignored\");\n \n          else\n             Restore_Scan_State (State);\n@@ -2684,7 +2817,7 @@ package body Ch4 is\n       --  If we have an END IF, diagnose as not needed\n \n       if Token = Tok_End then\n-         Error_Msg_SC\n+         Error_Msg_SC -- CODEFIX???\n            (\"`END IF` not allowed at end of conditional expression\");\n          Scan; -- past END\n "}, {"sha": "50a113f5f36300e0a2e822c5d4a005535878f060", "filename": "gcc/ada/par-ch7.adb", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fpar-ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fpar-ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch7.adb?ref=19d846a008c51b4425b88771aa2768bd882499cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -69,10 +69,10 @@ package body Ch7 is\n    --    Pf_Flags.Rnam                 Set if renaming declaration OK\n    --    Pf_Flags.Stub                 Set if body stub OK\n \n-   --  If an inappropriate form is encountered, it is scanned out but an\n-   --  error message indicating that it is appearing in an inappropriate\n-   --  context is issued. The only possible settings for Pf_Flags are those\n-   --  defined as constants in package Par.\n+   --  If an inappropriate form is encountered, it is scanned out but an error\n+   --  message indicating that it is appearing in an inappropriate context is\n+   --  issued. The only possible settings for Pf_Flags are those defined as\n+   --  constants in package Par.\n \n    --  Note: in all contexts where a package specification is required, there\n    --  is a terminating semicolon. This semicolon is scanned out in the case\n@@ -101,7 +101,8 @@ package body Ch7 is\n       Scan; -- past PACKAGE\n \n       if Token = Tok_Type then\n-         Error_Msg_SC (\"TYPE not allowed here\");\n+         Error_Msg_SC -- CODEFIX\n+           (\"TYPE not allowed here\");\n          Scan; -- past TYPE\n       end if;\n \n@@ -204,7 +205,7 @@ package body Ch7 is\n                      if Token_Is_At_Start_Of_Line\n                        and then Start_Column /= Error_Msg_Col\n                      then\n-                        Error_Msg_SC\n+                        Error_Msg_SC -- CODEFIX???\n                           (\"(style) PRIVATE in wrong column, should be@\");\n                      end if;\n                   end if;\n@@ -216,7 +217,7 @@ package body Ch7 is\n                   --  Deal gracefully with multiple PRIVATE parts\n \n                   while Token = Tok_Private loop\n-                     Error_Msg_SC\n+                     Error_Msg_SC -- CODEFIX???\n                        (\"only one private part allowed per package\");\n                      Scan; -- past PRIVATE\n                      Append_List (P_Basic_Declarative_Items,\n@@ -233,7 +234,8 @@ package body Ch7 is\n                end if;\n \n                if Token = Tok_Begin then\n-                  Error_Msg_SC (\"begin block not allowed in package spec\");\n+                  Error_Msg_SC -- CODEFIX???\n+                    (\"begin block not allowed in package spec\");\n                   Scan; -- past BEGIN\n                   Discard_Junk_List (P_Sequence_Of_Statements (SS_None));\n                end if;"}, {"sha": "4b532e2299ca26b08f0d5ca344de5a6c8c981b0d", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=19d846a008c51b4425b88771aa2768bd882499cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -150,7 +150,7 @@ function Prag (Pragma_Node : Node_Id; Semi : Source_Ptr) return Node_Id is\n          Error_Msg_Name_2 := Name_On;\n          Error_Msg_Name_3 := Name_Off;\n \n-         Error_Msg\n+         Error_Msg -- CODEFIX???\n            (\"argument for pragma% must be% or%\", Sloc (Argx));\n          raise Error_Resync;\n       end if;\n@@ -539,7 +539,7 @@ begin\n \n                for J in 1 .. Name_Len loop\n                   if Is_Directory_Separator (Name_Buffer (J)) then\n-                     Error_Msg\n+                     Error_Msg -- CODEFIX???\n                        (\"directory separator character not allowed\",\n                         Sloc (Expression (Arg)) + Source_Ptr (J));\n                   end if;\n@@ -606,7 +606,7 @@ begin\n                   end if;\n                end if;\n \n-               Error_Msg_N\n+               Error_Msg_N -- CODEFIX???\n                  (\"Casing argument for pragma% must be \" &\n                   \"one of Mixedcase, Lowercase, Uppercase\",\n                   Arg);\n@@ -943,7 +943,11 @@ begin\n                OK := False;\n \n             elsif Chars (A) = Name_All_Checks then\n-               Stylesw.Set_Default_Style_Check_Options;\n+               if GNAT_Mode then\n+                  Stylesw.Set_GNAT_Style_Check_Options;\n+               else\n+                  Stylesw.Set_Default_Style_Check_Options;\n+               end if;\n \n             elsif Chars (A) = Name_On then\n                Style_Check := True;"}, {"sha": "bf3dc1e6b51819845b44f747b0e89ee5f9c58894", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=19d846a008c51b4425b88771aa2768bd882499cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -676,8 +676,13 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       function P_Simple_Expression                    return Node_Id;\n       function P_Simple_Expression_Or_Range_Attribute return Node_Id;\n \n+      function P_Case_Expression return Node_Id;\n+      --  Scans out a case expression. Called with Token pointing to the CASE\n+      --  keyword, and returns pointing to the terminating right parent,\n+      --  semicolon, or comma, but does not consume this terminating token.\n+\n       function P_Conditional_Expression return Node_Id;\n-      --  Scans out a conditional expression. Called with token pointing to\n+      --  Scans out a conditional expression. Called with Token pointing to\n       --  the IF keyword, and returns pointing to the terminating right paren,\n       --  semicolon or comma, but does not consume this terminating token.\n "}, {"sha": "7dbaf93af891d92498d379de0faf7d01c266aae7", "filename": "gcc/ada/par_sco.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fpar_sco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fpar_sco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.adb?ref=19d846a008c51b4425b88771aa2768bd882499cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2009, Free Software Foundation, Inc.           --\n+--          Copyright (C) 2009-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -573,6 +573,11 @@ package body Par_SCO is\n                   return Skip;\n                end;\n \n+            --  Case expression\n+\n+            when N_Case_Expression =>\n+               return OK; -- ???\n+\n             --  Conditional expression, processed like an if statement\n \n             when N_Conditional_Expression =>"}, {"sha": "8a9628e6c08e441af9aab0cdebd9ebff8bfa5e93", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=19d846a008c51b4425b88771aa2768bd882499cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -158,6 +158,9 @@ package body Sem is\n          when N_Block_Statement =>\n             Analyze_Block_Statement (N);\n \n+         when N_Case_Expression =>\n+            Analyze_Case_Expression (N);\n+\n          when N_Case_Statement =>\n             Analyze_Case_Statement (N);\n \n@@ -632,6 +635,7 @@ package body Sem is\n            N_Access_Function_Definition             |\n            N_Access_Procedure_Definition            |\n            N_Access_To_Object_Definition            |\n+           N_Case_Expression_Alternative            |\n            N_Case_Statement_Alternative             |\n            N_Compilation_Unit_Aux                   |\n            N_Component_Association                  |"}, {"sha": "78ae7c61b3be525016132cd4b580ab6a012ffef5", "filename": "gcc/ada/sem_case.ads", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fsem_case.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fsem_case.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.ads?ref=19d846a008c51b4425b88771aa2768bd882499cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1996-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1996-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -68,17 +68,17 @@ package Sem_Case is\n       --  Processing to carry out for a non static Choice\n \n       with procedure Process_Associated_Node (A : Node_Id);\n-      --  Associated to each case alternative, aggregate component\n+      --  Associated with each case alternative, aggregate component\n       --  association or record variant A there is a node or list of nodes\n       --  that need semantic processing. This routine implements that\n       --  processing.\n \n    package Generic_Choices_Processing is\n \n       function Number_Of_Choices (N : Node_Id) return Nat;\n-      --  Iterates through the choices of N, (N can be a case statement,\n-      --  array aggregate or record variant), counting all the Choice nodes\n-      --  except for the Others choice.\n+      --  Iterates through the choices of N, (N can be a case expression, case\n+      --  statement, array aggregate or record variant), counting all the\n+      --  Choice nodes except for the Others choice.\n \n       procedure Analyze_Choices\n         (N              : Node_Id;\n@@ -87,10 +87,10 @@ package Sem_Case is\n          Last_Choice    : out Nat;\n          Raises_CE      : out Boolean;\n          Others_Present : out Boolean);\n-      --  From a case statement, array aggregate or record variant N, this\n-      --  routine analyzes the corresponding list of discrete choices.\n-      --  Subtyp is the subtype of the discrete choices. The type against\n-      --  which the discrete choices must be resolved is its base type.\n+      --  From a case expression, case statement, array aggregate or record\n+      --  variant N, this routine analyzes the corresponding list of discrete\n+      --  choices. Subtyp is the subtype of the discrete choices. The type\n+      --  against which the discrete choices must be resolved is its base type.\n       --\n       --  On entry Choice_Table must be big enough to contain all the discrete\n       --  choices encountered. The lower bound of Choice_Table must be one."}, {"sha": "49775b9cd7c89f37d775e46a24ead8765e9780a8", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 187, "deletions": 26, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=19d846a008c51b4425b88771aa2768bd882499cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -43,6 +43,7 @@ with Restrict; use Restrict;\n with Rident;   use Rident;\n with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n+with Sem_Case; use Sem_Case;\n with Sem_Cat;  use Sem_Cat;\n with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch6;  use Sem_Ch6;\n@@ -52,8 +53,9 @@ with Sem_Disp; use Sem_Disp;\n with Sem_Dist; use Sem_Dist;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n-with Sem_Util; use Sem_Util;\n with Sem_Type; use Sem_Type;\n+with Sem_Util; use Sem_Util;\n+with Sem_Warn; use Sem_Warn;\n with Stand;    use Stand;\n with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n@@ -305,10 +307,10 @@ package body Sem_Ch4 is\n          end if;\n \n          if Opnd = Left_Opnd (N) then\n-            Error_Msg_N\n+            Error_Msg_N -- CODEFIX???\n               (\"\\left operand has the following interpretations\", N);\n          else\n-            Error_Msg_N\n+            Error_Msg_N -- CODEFIX???\n               (\"\\right operand has the following interpretations\", N);\n             Err := Opnd;\n          end if;\n@@ -320,13 +322,16 @@ package body Sem_Ch4 is\n \n    begin\n       if Nkind (N) in N_Membership_Test then\n-         Error_Msg_N (\"ambiguous operands for membership\",  N);\n+         Error_Msg_N -- CODEFIX???\n+           (\"ambiguous operands for membership\",  N);\n \n       elsif Nkind_In (N, N_Op_Eq, N_Op_Ne) then\n-         Error_Msg_N (\"ambiguous operands for equality\",  N);\n+         Error_Msg_N -- CODEFIX???\n+           (\"ambiguous operands for equality\",  N);\n \n       else\n-         Error_Msg_N (\"ambiguous operands for comparison\",  N);\n+         Error_Msg_N -- CODEFIX???\n+           (\"ambiguous operands for comparison\",  N);\n       end if;\n \n       if All_Errors_Mode then\n@@ -1048,6 +1053,141 @@ package body Sem_Ch4 is\n       end if;\n    end Analyze_Call;\n \n+   -----------------------------\n+   -- Analyze_Case_Expression --\n+   -----------------------------\n+\n+   procedure Analyze_Case_Expression (N : Node_Id) is\n+      Expr      : constant Node_Id := Expression (N);\n+      FirstX    : constant Node_Id := Expression (First (Alternatives (N)));\n+      Alt       : Node_Id;\n+      Exp_Type  : Entity_Id;\n+      Exp_Btype : Entity_Id;\n+\n+      Last_Choice    : Nat;\n+      Dont_Care      : Boolean;\n+      Others_Present : Boolean;\n+\n+      procedure Non_Static_Choice_Error (Choice : Node_Id);\n+      --  Error routine invoked by the generic instantiation below when\n+      --  the case expression has a non static choice.\n+\n+      package Case_Choices_Processing is new\n+        Generic_Choices_Processing\n+          (Get_Alternatives          => Alternatives,\n+           Get_Choices               => Discrete_Choices,\n+           Process_Empty_Choice      => No_OP,\n+           Process_Non_Static_Choice => Non_Static_Choice_Error,\n+           Process_Associated_Node   => No_OP);\n+      use Case_Choices_Processing;\n+\n+      Case_Table : Choice_Table_Type (1 .. Number_Of_Choices (N));\n+\n+      -----------------------------\n+      -- Non_Static_Choice_Error --\n+      -----------------------------\n+\n+      procedure Non_Static_Choice_Error (Choice : Node_Id) is\n+      begin\n+         Flag_Non_Static_Expr\n+           (\"choice given in case expression is not static!\", Choice);\n+      end Non_Static_Choice_Error;\n+\n+   --  Start of processing for Analyze_Case_Expression\n+\n+   begin\n+      if Comes_From_Source (N) then\n+         Check_Compiler_Unit (N);\n+      end if;\n+\n+      Analyze_And_Resolve (Expr, Any_Discrete);\n+      Check_Unset_Reference (Expr);\n+      Exp_Type := Etype (Expr);\n+      Exp_Btype := Base_Type (Exp_Type);\n+\n+      Alt := First (Alternatives (N));\n+      while Present (Alt) loop\n+         Analyze (Expression (Alt));\n+         Next (Alt);\n+      end loop;\n+\n+      if not Is_Overloaded (FirstX) then\n+         Set_Etype (N, Etype (FirstX));\n+\n+      else\n+         declare\n+            I  : Interp_Index;\n+            It : Interp;\n+\n+         begin\n+            Set_Etype (N, Any_Type);\n+\n+            Get_First_Interp (FirstX, I, It);\n+            while Present (It.Nam) loop\n+\n+               --  For each intepretation of the first expression, we only\n+               --  add the intepretation if every other expression in the\n+               --  case expression alternatives has a compatible type.\n+\n+               Alt := Next (First (Alternatives (N)));\n+               while Present (Alt) loop\n+                  exit when not Has_Compatible_Type (Expression (Alt), It.Typ);\n+                  Next (Alt);\n+               end loop;\n+\n+               if No (Alt) then\n+                  Add_One_Interp (N, It.Typ, It.Typ);\n+               end if;\n+\n+               Get_Next_Interp (I, It);\n+            end loop;\n+         end;\n+      end if;\n+\n+      Exp_Btype := Base_Type (Exp_Type);\n+\n+      --  The expression must be of a discrete type which must be determinable\n+      --  independently of the context in which the expression occurs, but\n+      --  using the fact that the expression must be of a discrete type.\n+      --  Moreover, the type this expression must not be a character literal\n+      --  (which is always ambiguous).\n+\n+      --  If error already reported by Resolve, nothing more to do\n+\n+      if Exp_Btype = Any_Discrete\n+        or else Exp_Btype = Any_Type\n+      then\n+         return;\n+\n+      elsif Exp_Btype = Any_Character then\n+         Error_Msg_N\n+           (\"character literal as case expression is ambiguous\", Expr);\n+         return;\n+      end if;\n+\n+      --  If the case expression is a formal object of mode in out, then\n+      --  treat it as having a nonstatic subtype by forcing use of the base\n+      --  type (which has to get passed to Check_Case_Choices below).  Also\n+      --  use base type when the case expression is parenthesized.\n+\n+      if Paren_Count (Expr) > 0\n+        or else (Is_Entity_Name (Expr)\n+                  and then Ekind (Entity (Expr)) = E_Generic_In_Out_Parameter)\n+      then\n+         Exp_Type := Exp_Btype;\n+      end if;\n+\n+      --  Call instantiated Analyze_Choices which does the rest of the work\n+\n+      Analyze_Choices\n+        (N, Exp_Type, Case_Table, Last_Choice, Dont_Care, Others_Present);\n+\n+      if Exp_Type = Universal_Integer and then not Others_Present then\n+         Error_Msg_N\n+           (\"case on universal integer requires OTHERS choice\", Expr);\n+      end if;\n+   end Analyze_Case_Expression;\n+\n    ---------------------------\n    -- Analyze_Comparison_Op --\n    ---------------------------\n@@ -1263,8 +1403,13 @@ package body Sem_Ch4 is\n          Analyze_Expression (Else_Expr);\n       end if;\n \n+      --  If then expression not overloaded, then that decides the type\n+\n       if not Is_Overloaded (Then_Expr) then\n          Set_Etype (N, Etype (Then_Expr));\n+\n+      --  Case where then expression is overloaded\n+\n       else\n          declare\n             I  : Interp_Index;\n@@ -1274,6 +1419,12 @@ package body Sem_Ch4 is\n             Set_Etype (N, Any_Type);\n             Get_First_Interp (Then_Expr, I, It);\n             while Present (It.Nam) loop\n+\n+               --  For each possible intepretation of the Then Expression,\n+               --  add it only if the else expression has a compatible type.\n+\n+               --  Is this right if Else_Expr is empty?\n+\n                if Has_Compatible_Type (Else_Expr, It.Typ) then\n                   Add_One_Interp (N, It.Typ, It.Typ);\n                end if;\n@@ -3997,28 +4148,33 @@ package body Sem_Ch4 is\n \n       elsif Nkind (Expr) = N_Null then\n          Error_Msg_N (\"argument of conversion cannot be null\", N);\n-         Error_Msg_N (\"\\use qualified expression instead\", N);\n+         Error_Msg_N -- CODEFIX???\n+           (\"\\use qualified expression instead\", N);\n          Set_Etype (N, Any_Type);\n \n       elsif Nkind (Expr) = N_Aggregate then\n          Error_Msg_N (\"argument of conversion cannot be aggregate\", N);\n-         Error_Msg_N (\"\\use qualified expression instead\", N);\n+         Error_Msg_N -- CODEFIX???\n+           (\"\\use qualified expression instead\", N);\n \n       elsif Nkind (Expr) = N_Allocator then\n          Error_Msg_N (\"argument of conversion cannot be an allocator\", N);\n-         Error_Msg_N (\"\\use qualified expression instead\", N);\n+         Error_Msg_N -- CODEFIX???\n+           (\"\\use qualified expression instead\", N);\n \n       elsif Nkind (Expr) = N_String_Literal then\n          Error_Msg_N (\"argument of conversion cannot be string literal\", N);\n-         Error_Msg_N (\"\\use qualified expression instead\", N);\n+         Error_Msg_N -- CODEFIX???\n+           (\"\\use qualified expression instead\", N);\n \n       elsif Nkind (Expr) = N_Character_Literal then\n          if Ada_Version = Ada_83 then\n             Resolve (Expr, T);\n          else\n             Error_Msg_N (\"argument of conversion cannot be character literal\",\n               N);\n-            Error_Msg_N (\"\\use qualified expression instead\", N);\n+            Error_Msg_N -- CODEFIX???\n+              (\"\\use qualified expression instead\", N);\n          end if;\n \n       elsif Nkind (Expr) = N_Attribute_Reference\n@@ -4028,7 +4184,8 @@ package body Sem_Ch4 is\n            Attribute_Name (Expr) = Name_Unrestricted_Access)\n       then\n          Error_Msg_N (\"argument of conversion cannot be access\", N);\n-         Error_Msg_N (\"\\use qualified expression instead\", N);\n+         Error_Msg_N -- CODEFIX???\n+           (\"\\use qualified expression instead\", N);\n       end if;\n    end Analyze_Type_Conversion;\n \n@@ -4502,7 +4659,7 @@ package body Sem_Ch4 is\n              and then From_With_Type (Etype (Actual))\n             then\n                Error_Msg_Qual_Level := 1;\n-               Error_Msg_NE\n+               Error_Msg_NE -- CODEFIX???\n                 (\"missing with_clause for scope of imported type&\",\n                   Actual, Etype (Actual));\n                Error_Msg_Qual_Level := 0;\n@@ -5360,10 +5517,11 @@ package body Sem_Ch4 is\n                   end if;\n                end if;\n \n-               Error_Msg_NE\n+               Error_Msg_NE -- CODEFIX\n                  (\"operator for} is not directly visible!\",\n                   N, First_Subtype (Candidate_Type));\n-               Error_Msg_N (\"use clause would make operation legal!\",  N);\n+               Error_Msg_N -- CODEFIX\n+                 (\"use clause would make operation legal!\",  N);\n                return;\n \n             --  If either operand is a junk operand (e.g. package name), then\n@@ -5522,9 +5680,9 @@ package body Sem_Ch4 is\n                                  (R,\n                                   Etype (Next_Formal (First_Formal (Op_Id))))\n                            then\n-                              Error_Msg_N\n+                              Error_Msg_N -- CODEFIX???\n                                 (\"No legal interpretation for operator&\", N);\n-                              Error_Msg_NE\n+                              Error_Msg_NE -- CODEFIX???\n                                 (\"\\use clause on& would make operation legal\",\n                                    N, Scope (Op_Id));\n                               exit;\n@@ -6215,7 +6373,7 @@ package body Sem_Ch4 is\n                 Prefix => Relocate_Node (Obj)));\n \n             if not Is_Aliased_View (Obj) then\n-               Error_Msg_NE\n+               Error_Msg_NE -- CODEFIX???\n                  (\"object in prefixed call to& must be aliased\"\n                       & \" (RM-2005 4.3.1 (13))\",\n                  Prefix (First_Actual), Subprog);\n@@ -6270,27 +6428,28 @@ package body Sem_Ch4 is\n \n          if Access_Formal and then not Access_Actual then\n             if Nkind (Parent (Op)) = N_Full_Type_Declaration then\n-               Error_Msg_N\n+               Error_Msg_N -- CODEFIX???\n                  (\"\\possible interpretation\"\n                    & \" (inherited, with implicit 'Access) #\", N);\n             else\n-               Error_Msg_N\n+               Error_Msg_N -- CODEFIX???\n                  (\"\\possible interpretation (with implicit 'Access) #\", N);\n             end if;\n \n          elsif not Access_Formal and then Access_Actual then\n             if Nkind (Parent (Op)) = N_Full_Type_Declaration then\n-               Error_Msg_N\n+               Error_Msg_N -- CODEFIX???\n                  (\"\\possible interpretation\"\n                    & \" ( inherited, with implicit dereference) #\", N);\n             else\n-               Error_Msg_N\n+               Error_Msg_N -- CODEFIX???\n                  (\"\\possible interpretation (with implicit dereference) #\", N);\n             end if;\n \n          else\n             if Nkind (Parent (Op)) = N_Full_Type_Declaration then\n-               Error_Msg_N (\"\\possible interpretation (inherited)#\", N);\n+               Error_Msg_N -- CODEFIX???\n+                 (\"\\possible interpretation (inherited)#\", N);\n             else\n                Error_Msg_N -- CODEFIX\n                  (\"\\possible interpretation#\", N);\n@@ -6491,7 +6650,8 @@ package body Sem_Ch4 is\n                      if Present (Valid_Candidate (Success, Call_Node, Hom))\n                        and then Nkind (Call_Node) /= N_Function_Call\n                      then\n-                        Error_Msg_NE (\"ambiguous call to&\", N, Hom);\n+                        Error_Msg_NE -- CODEFIX???\n+                          (\"ambiguous call to&\", N, Hom);\n                         Report_Ambiguity (Matching_Op);\n                         Report_Ambiguity (Hom);\n                         Error := True;\n@@ -6908,7 +7068,8 @@ package body Sem_Ch4 is\n                   if Present (Valid_Candidate (Success, Call_Node, Prim_Op))\n                     and then Nkind (Call_Node) /= N_Function_Call\n                   then\n-                     Error_Msg_NE (\"ambiguous call to&\", N, Prim_Op);\n+                     Error_Msg_NE -- CODEFIX???\n+                       (\"ambiguous call to&\", N, Prim_Op);\n                      Report_Ambiguity (Matching_Op);\n                      Report_Ambiguity (Prim_Op);\n                      return True;"}, {"sha": "e5c646f9bb8c817386e7b781a8e7c3a9da8e39cc", "filename": "gcc/ada/sem_ch4.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fsem_ch4.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fsem_ch4.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.ads?ref=19d846a008c51b4425b88771aa2768bd882499cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,6 +30,7 @@ package Sem_Ch4  is\n    procedure Analyze_Allocator                          (N : Node_Id);\n    procedure Analyze_Arithmetic_Op                      (N : Node_Id);\n    procedure Analyze_Call                               (N : Node_Id);\n+   procedure Analyze_Case_Expression                    (N : Node_Id);\n    procedure Analyze_Comparison_Op                      (N : Node_Id);\n    procedure Analyze_Concatenation                      (N : Node_Id);\n    procedure Analyze_Conditional_Expression             (N : Node_Id);"}, {"sha": "7e897ffac50ea64d90fd1d96fd29721ab648fb54", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 96, "deletions": 43, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=19d846a008c51b4425b88771aa2768bd882499cc", "patch": "@@ -315,7 +315,7 @@ package body Sem_Ch6 is\n          --  extended_return_statement.\n \n          if Returns_Object then\n-            Error_Msg_N\n+            Error_Msg_N -- CODEFIX???\n               (\"extended_return_statement cannot return value; \" &\n                \"use `\"\"RETURN;\"\"`\", N);\n          end if;\n@@ -1126,7 +1126,8 @@ package body Sem_Ch6 is\n            and then No (Actuals)\n            and then Comes_From_Source (N)\n          then\n-            Error_Msg_N (\"missing explicit dereference in call\", N);\n+            Error_Msg_N -- CODEFIX???\n+              (\"missing explicit dereference in call\", N);\n          end if;\n \n          Analyze_Call_And_Resolve;\n@@ -1174,7 +1175,8 @@ package body Sem_Ch6 is\n          if Present (Actuals) then\n             Analyze_Call_And_Resolve;\n          else\n-            Error_Msg_N (\"missing explicit dereference in call \", N);\n+            Error_Msg_N -- CODEFIX???\n+              (\"missing explicit dereference in call \", N);\n          end if;\n \n       --  If not an access to subprogram, then the prefix must resolve to the\n@@ -1827,20 +1829,20 @@ package body Sem_Ch6 is\n                null;\n \n             elsif not Is_Overriding_Operation (Spec_Id) then\n-               Error_Msg_NE\n+               Error_Msg_NE -- CODEFIX???\n                  (\"subprogram& is not overriding\", Body_Spec, Spec_Id);\n             end if;\n \n          elsif Must_Not_Override (Body_Spec) then\n             if Is_Overriding_Operation (Spec_Id) then\n-               Error_Msg_NE\n+               Error_Msg_NE -- CODEFIX???\n                  (\"subprogram& overrides inherited operation\",\n                   Body_Spec, Spec_Id);\n \n             elsif Nkind (Spec_Id) = N_Defining_Operator_Symbol\n               and then  Operator_Matches_Spec (Spec_Id, Spec_Id)\n             then\n-               Error_Msg_NE\n+               Error_Msg_NE -- CODEFIX???\n                  (\"subprogram & overrides predefined operator \",\n                     Body_Spec, Spec_Id);\n \n@@ -1850,9 +1852,10 @@ package body Sem_Ch6 is\n             elsif not Is_Primitive (Spec_Id)\n               and then Ekind (Scope (Spec_Id)) /= E_Protected_Type\n             then\n-               Error_Msg_N (\"overriding indicator only allowed \" &\n-                \"if subprogram is primitive\",\n-                Body_Spec);\n+               Error_Msg_N -- CODEFIX???\n+                 (\"overriding indicator only allowed \" &\n+                  \"if subprogram is primitive\",\n+                  Body_Spec);\n             end if;\n \n          elsif Style_Check --  ??? incorrect use of Style_Check!\n@@ -2057,7 +2060,8 @@ package body Sem_Ch6 is\n          Set_Is_Child_Unit       (Body_Id, Is_Child_Unit       (Spec_Id));\n \n          if Is_Abstract_Subprogram (Spec_Id) then\n-            Error_Msg_N (\"an abstract subprogram cannot have a body\", N);\n+            Error_Msg_N -- CODEFIX???\n+              (\"an abstract subprogram cannot have a body\", N);\n             return;\n \n          else\n@@ -2634,7 +2638,7 @@ package body Sem_Ch6 is\n          end loop;\n \n          if Is_Protected_Type (Current_Scope) then\n-            Error_Msg_N\n+            Error_Msg_N -- CODEFIX???\n               (\"protected operation cannot be a null procedure\", N);\n          end if;\n       end if;\n@@ -2731,7 +2735,7 @@ package body Sem_Ch6 is\n                               and then Null_Present (Specification (N)))\n             then\n                Error_Msg_Name_1 := Chars (Defining_Entity (N));\n-               Error_Msg_N\n+               Error_Msg_N -- CODEFIX???\n                  (\"(Ada 2005) interface subprogram % must be abstract or null\",\n                   N);\n             end if;\n@@ -2908,7 +2912,7 @@ package body Sem_Ch6 is\n            and then\n              (Nkind (Parent (N))) /= N_Formal_Abstract_Subprogram_Declaration\n          then\n-            Error_Msg_N\n+            Error_Msg_N -- CODEFIX???\n               (\"function that returns abstract type must be abstract\", N);\n          end if;\n       end if;\n@@ -4003,7 +4007,7 @@ package body Sem_Ch6 is\n                if Is_Interface_Conformant (Typ, Iface_Prim, Op)\n                  and then Convention (Iface_Prim) /= Convention (Op)\n                then\n-                  Error_Msg_N\n+                  Error_Msg_N -- CODEFIX???\n                     (\"inconsistent conventions in primitive operations\", Typ);\n \n                   Error_Msg_Name_1 := Chars (Op);\n@@ -4012,24 +4016,28 @@ package body Sem_Ch6 is\n \n                   if Comes_From_Source (Op) then\n                      if not Is_Overriding_Operation (Op) then\n-                        Error_Msg_N (\"\\\\primitive % defined #\", Typ);\n+                        Error_Msg_N -- CODEFIX???\n+                          (\"\\\\primitive % defined #\", Typ);\n                      else\n-                        Error_Msg_N (\"\\\\overriding operation % with \" &\n-                                     \"convention % defined #\", Typ);\n+                        Error_Msg_N -- CODEFIX???\n+                          (\"\\\\overriding operation % with \" &\n+                           \"convention % defined #\", Typ);\n                      end if;\n \n                   else pragma Assert (Present (Alias (Op)));\n                      Error_Msg_Sloc := Sloc (Alias (Op));\n-                     Error_Msg_N (\"\\\\inherited operation % with \" &\n-                                  \"convention % defined #\", Typ);\n+                     Error_Msg_N -- CODEFIX???\n+                       (\"\\\\inherited operation % with \" &\n+                        \"convention % defined #\", Typ);\n                   end if;\n \n                   Error_Msg_Name_1 := Chars (Op);\n                   Error_Msg_Name_2 :=\n                     Get_Convention_Name (Convention (Iface_Prim));\n                   Error_Msg_Sloc := Sloc (Iface_Prim);\n-                  Error_Msg_N (\"\\\\overridden operation % with \" &\n-                               \"convention % defined #\", Typ);\n+                  Error_Msg_N -- CODEFIX???\n+                    (\"\\\\overridden operation % with \" &\n+                     \"convention % defined #\", Typ);\n \n                   --  Avoid cascading errors\n \n@@ -4447,7 +4455,8 @@ package body Sem_Ch6 is\n                then\n                   Error_Msg_Node_2 := Alias (Overridden_Subp);\n                   Error_Msg_Sloc := Sloc (Error_Msg_Node_2);\n-                  Error_Msg_NE (\"& does not match corresponding formal of&#\",\n+                  Error_Msg_NE -- CODEFIX???\n+                    (\"& does not match corresponding formal of&#\",\n                      Form1, Form1);\n                   exit;\n                end if;\n@@ -6074,8 +6083,9 @@ package body Sem_Ch6 is\n             when N_Aggregate =>\n                return\n                  FCL (Expressions (E1), Expressions (E2))\n-                   and then FCL (Component_Associations (E1),\n-                                 Component_Associations (E2));\n+                   and then\n+                 FCL (Component_Associations (E1),\n+                      Component_Associations (E2));\n \n             when N_Allocator =>\n                if Nkind (Expression (E1)) = N_Qualified_Expression\n@@ -6145,14 +6155,47 @@ package body Sem_Ch6 is\n                    and then\n                  FCE (Right_Opnd (E1), Right_Opnd (E2));\n \n+            when N_Case_Expression =>\n+               declare\n+                  Alt1 : Node_Id;\n+                  Alt2 : Node_Id;\n+\n+               begin\n+                  if not FCE (Expression (E1), Expression (E2)) then\n+                     return False;\n+\n+                  else\n+                     Alt1 := First (Alternatives (E1));\n+                     Alt2 := First (Alternatives (E2));\n+                     loop\n+                        if Present (Alt1) /= Present (Alt2) then\n+                           return False;\n+                        elsif No (Alt1) then\n+                           return True;\n+                        end if;\n+\n+                        if not FCE (Expression (Alt1), Expression (Alt2))\n+                          or else not FCL (Discrete_Choices (Alt1),\n+                                           Discrete_Choices (Alt2))\n+                        then\n+                           return False;\n+                        end if;\n+\n+                        Next (Alt1);\n+                        Next (Alt2);\n+                     end loop;\n+                  end if;\n+               end;\n+\n             when N_Character_Literal =>\n                return\n                  Char_Literal_Value (E1) = Char_Literal_Value (E2);\n \n             when N_Component_Association =>\n                return\n                  FCL (Choices (E1), Choices (E2))\n-                   and then FCE (Expression (E1), Expression (E2));\n+                   and then\n+                 FCE (Expression (E1), Expression (E2));\n \n             when N_Conditional_Expression =>\n                return\n@@ -6173,13 +6216,15 @@ package body Sem_Ch6 is\n             when N_Function_Call =>\n                return\n                  FCE (Name (E1), Name (E2))\n-                   and then FCL (Parameter_Associations (E1),\n-                                 Parameter_Associations (E2));\n+                   and then\n+                 FCL (Parameter_Associations (E1),\n+                      Parameter_Associations (E2));\n \n             when N_Indexed_Component =>\n                return\n                  FCE (Prefix (E1), Prefix (E2))\n-                   and then FCL (Expressions (E1), Expressions (E2));\n+                   and then\n+                 FCL (Expressions (E1), Expressions (E2));\n \n             when N_Integer_Literal =>\n                return (Intval (E1) = Intval (E2));\n@@ -6203,25 +6248,29 @@ package body Sem_Ch6 is\n             when N_Qualified_Expression =>\n                return\n                  FCE (Subtype_Mark (E1), Subtype_Mark (E2))\n-                   and then FCE (Expression (E1), Expression (E2));\n+                   and then\n+                 FCE (Expression (E1), Expression (E2));\n \n             when N_Range =>\n                return\n                  FCE (Low_Bound (E1), Low_Bound (E2))\n-                   and then FCE (High_Bound (E1), High_Bound (E2));\n+                   and then\n+                 FCE (High_Bound (E1), High_Bound (E2));\n \n             when N_Real_Literal =>\n                return (Realval (E1) = Realval (E2));\n \n             when N_Selected_Component =>\n                return\n                  FCE (Prefix (E1), Prefix (E2))\n-                   and then FCE (Selector_Name (E1), Selector_Name (E2));\n+                   and then\n+                 FCE (Selector_Name (E1), Selector_Name (E2));\n \n             when N_Slice =>\n                return\n                  FCE (Prefix (E1), Prefix (E2))\n-                   and then FCE (Discrete_Range (E1), Discrete_Range (E2));\n+                   and then\n+                 FCE (Discrete_Range (E1), Discrete_Range (E2));\n \n             when N_String_Literal =>\n                declare\n@@ -6250,17 +6299,20 @@ package body Sem_Ch6 is\n             when N_Type_Conversion =>\n                return\n                  FCE (Subtype_Mark (E1), Subtype_Mark (E2))\n-                   and then FCE (Expression (E1), Expression (E2));\n+                   and then\n+                 FCE (Expression (E1), Expression (E2));\n \n             when N_Unary_Op =>\n                return\n                  Entity (E1) = Entity (E2)\n-                   and then FCE (Right_Opnd (E1), Right_Opnd (E2));\n+                   and then\n+                 FCE (Right_Opnd (E1), Right_Opnd (E2));\n \n             when N_Unchecked_Type_Conversion =>\n                return\n                  FCE (Subtype_Mark (E1), Subtype_Mark (E2))\n-                   and then FCE (Expression (E1), Expression (E2));\n+                   and then\n+                 FCE (Expression (E1), Expression (E2));\n \n             --  All other node types cannot appear in this context. Strictly\n             --  we should raise a fatal internal error. Instead we just ignore\n@@ -6864,18 +6916,19 @@ package body Sem_Ch6 is\n                  and then (not Is_Overriding\n                             or else not Is_Abstract_Subprogram (E))\n                then\n-                  Error_Msg_N (\"abstract subprograms must be visible \"\n-                                   & \"(RM 3.9.3(10))!\", S);\n+                  Error_Msg_N -- CODEFIX???\n+                    (\"abstract subprograms must be visible \"\n+                     & \"(RM 3.9.3(10))!\", S);\n \n                elsif Ekind (S) = E_Function\n                  and then Is_Tagged_Type (T)\n                  and then T = Base_Type (Etype (S))\n                  and then not Is_Overriding\n                then\n-                  Error_Msg_N\n+                  Error_Msg_N -- CODEFIX???\n                     (\"private function with tagged result must\"\n                      & \" override visible-part function\", S);\n-                  Error_Msg_N\n+                  Error_Msg_N -- CODEFIX???\n                     (\"\\move subprogram to the visible part\"\n                      & \" (RM 3.9.3(10))\", S);\n                end if;\n@@ -8031,14 +8084,14 @@ package body Sem_Ch6 is\n               and then Null_Exclusion_Present (Param_Spec)\n             then\n                if not Is_Access_Type (Formal_Type) then\n-                  Error_Msg_N\n+                  Error_Msg_N -- CODEFIX???\n                     (\"`NOT NULL` allowed only for an access type\", Param_Spec);\n \n                else\n                   if Can_Never_Be_Null (Formal_Type)\n                     and then Comes_From_Source (Related_Nod)\n                   then\n-                     Error_Msg_NE\n+                     Error_Msg_NE -- CODEFIX???\n                        (\"`NOT NULL` not allowed (& already excludes null)\",\n                         Param_Spec,\n                         Formal_Type);\n@@ -8096,7 +8149,7 @@ package body Sem_Ch6 is\n \n          if Present (Default) then\n             if Out_Present (Param_Spec) then\n-               Error_Msg_N\n+               Error_Msg_N -- CODEFIX???\n                  (\"default initialization only allowed for IN parameters\",\n                   Param_Spec);\n             end if;\n@@ -8760,7 +8813,7 @@ package body Sem_Ch6 is\n          N := N + 1;\n \n          if Present (Default_Value (F)) then\n-            Error_Msg_N\n+            Error_Msg_N -- CODEFIX???\n               (\"default values not allowed for operator parameters\",\n                Parent (F));\n          end if;"}, {"sha": "448872d9cbdbc4fc4232796d83dd7dee24fafa09", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=19d846a008c51b4425b88771aa2768bd882499cc", "patch": "@@ -1666,6 +1666,27 @@ package body Sem_Eval is\n       end if;\n    end Eval_Call;\n \n+   --------------------------\n+   -- Eval_Case_Expression --\n+   --------------------------\n+\n+   --  Right now we do not attempt folding of any case expressions, and the\n+   --  language does not require it, so the only required processing is to\n+   --  do the check for all expressions appearing in the case expression.\n+\n+   procedure Eval_Case_Expression (N : Node_Id) is\n+      Alt : Node_Id;\n+\n+   begin\n+      Check_Non_Static_Context (Expression (N));\n+\n+      Alt := First (Alternatives (N));\n+      while Present (Alt) loop\n+         Check_Non_Static_Context (Expression (Alt));\n+         Next (Alt);\n+      end loop;\n+   end Eval_Case_Expression;\n+\n    ------------------------\n    -- Eval_Concatenation --\n    ------------------------\n@@ -1783,15 +1804,14 @@ package body Sem_Eval is\n    -- Eval_Conditional_Expression --\n    ---------------------------------\n \n-   --  This GNAT internal construct can never be statically folded, so the\n-   --  only required processing is to do the check for non-static context\n-   --  for the two expression operands.\n+   --  We never attempt folding of conditional expressions (and the language)\n+   --  does not require it, so the only required processing is to do the check\n+   --  for non-static context for the then and else expressions.\n \n    procedure Eval_Conditional_Expression (N : Node_Id) is\n       Condition : constant Node_Id := First (Expressions (N));\n       Then_Expr : constant Node_Id := Next (Condition);\n       Else_Expr : constant Node_Id := Next (Then_Expr);\n-\n    begin\n       Check_Non_Static_Context (Then_Expr);\n       Check_Non_Static_Context (Else_Expr);"}, {"sha": "078ac375c351b7919f8a30cc2d8a0a8d161b9468", "filename": "gcc/ada/sem_eval.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fsem_eval.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fsem_eval.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.ads?ref=19d846a008c51b4425b88771aa2768bd882499cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -282,6 +282,7 @@ package Sem_Eval is\n    procedure Eval_Allocator              (N : Node_Id);\n    procedure Eval_Arithmetic_Op          (N : Node_Id);\n    procedure Eval_Call                   (N : Node_Id);\n+   procedure Eval_Case_Expression        (N : Node_Id);\n    procedure Eval_Character_Literal      (N : Node_Id);\n    procedure Eval_Concatenation          (N : Node_Id);\n    procedure Eval_Conditional_Expression (N : Node_Id);"}, {"sha": "f9f738431a4dbd995e9e01015dc0e521030aa5d5", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 39, "deletions": 30, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=19d846a008c51b4425b88771aa2768bd882499cc", "patch": "@@ -1049,7 +1049,8 @@ package body Sem_Prag is\n                           (\"parameters out of order for pragma%\", Arg);\n                         Error_Msg_Name_1 := Names (K);\n                         Error_Msg_Name_2 := Names (Highest_So_Far);\n-                        Error_Msg_N (\"\\% must appear before %\", Arg);\n+                        Error_Msg_N -- CODEFIX???\n+                          (\"\\% must appear before %\", Arg);\n                         raise Pragma_Exit;\n \n                      else\n@@ -2617,7 +2618,7 @@ package body Sem_Prag is\n \n          else\n             if Warn_On_Export_Import and not OpenVMS_On_Target then\n-               Error_Msg_N\n+               Error_Msg_N -- CODEFIX???\n                  (\"?unrecognized convention name, C assumed\",\n                   Expression (Arg1));\n             end if;\n@@ -3728,11 +3729,11 @@ package body Sem_Prag is\n             --  these types have been supported this way for some time.\n \n             if not Is_Limited_Type (Def_Id) then\n-               Error_Msg_N\n+               Error_Msg_N -- CODEFIX???\n                  (\"imported 'C'P'P type should be \" &\n                     \"explicitly declared limited?\",\n                   Get_Pragma_Arg (Arg2));\n-               Error_Msg_N\n+               Error_Msg_N -- CODEFIX???\n                  (\"\\type will be considered limited\",\n                   Get_Pragma_Arg (Arg2));\n             end if;\n@@ -3854,7 +3855,8 @@ package body Sem_Prag is\n                if Front_End_Inlining\n                  and then Analyzed (Corresponding_Body (Decl))\n                then\n-                  Error_Msg_N (\"pragma appears too late, ignored?\", N);\n+                  Error_Msg_N -- CODEFIX???\n+                    (\"pragma appears too late, ignored?\", N);\n                   return True;\n \n                --  If the subprogram is a renaming as body, the body is just a\n@@ -4078,10 +4080,10 @@ package body Sem_Prag is\n               and then not Suppress_All_Inlining\n             then\n                if Inlining_Not_Possible (Subp) then\n-                  Error_Msg_NE\n+                  Error_Msg_NE -- CODEFIX???\n                     (\"pragma Inline for& is ignored?\", N, Entity (Subp_Id));\n                else\n-                  Error_Msg_NE\n+                  Error_Msg_NE -- CODEFIX???\n                     (\"pragma Inline for& is redundant?\", N, Entity (Subp_Id));\n                end if;\n             end if;\n@@ -4153,7 +4155,7 @@ package body Sem_Prag is\n                                         or else\n                                       Get_Character (C) = '/'))\n                then\n-                  Error_Msg\n+                  Error_Msg -- CODEFIX???\n                     (\"?interface name contains illegal character\",\n                      Sloc (SN) + Source_Ptr (J));\n                end if;\n@@ -4687,11 +4689,11 @@ package body Sem_Prag is\n       procedure Set_Exported (E : Entity_Id; Arg : Node_Id) is\n       begin\n          if Is_Imported (E) then\n-            Error_Pragma_Arg\n+            Error_Pragma_Arg -- CODEFIX???\n               (\"cannot export entity& that was previously imported\", Arg);\n \n          elsif Present (Address_Clause (E)) then\n-            Error_Pragma_Arg\n+            Error_Pragma_Arg -- CODEFIX???\n               (\"cannot export entity& that has an address clause\", Arg);\n          end if;\n \n@@ -4710,7 +4712,8 @@ package body Sem_Prag is\n             --  Not allowed at all for subprograms\n \n             if Is_Subprogram (E) then\n-               Error_Pragma_Arg (\"local subprogram& cannot be exported\", Arg);\n+               Error_Pragma_Arg -- CODEFIX???\n+                 (\"local subprogram& cannot be exported\", Arg);\n \n             --  Otherwise set public and statically allocated\n \n@@ -4736,7 +4739,7 @@ package body Sem_Prag is\n          end if;\n \n          if Warn_On_Export_Import and then Is_Type (E) then\n-            Error_Msg_NE\n+            Error_Msg_NE -- CODEFIX???\n               (\"exporting a type has no effect?\", Arg, E);\n          end if;\n \n@@ -4859,7 +4862,8 @@ package body Sem_Prag is\n               (\"\\(pragma% applies to all previous entities)\", N);\n \n             Error_Msg_Sloc  := Sloc (E);\n-            Error_Msg_NE (\"\\import not allowed for& declared#\", N, E);\n+            Error_Msg_NE -- CODEFIX???\n+              (\"\\import not allowed for& declared#\", N, E);\n \n          --  Here if not previously imported or exported, OK to import\n \n@@ -6372,7 +6376,7 @@ package body Sem_Prag is\n \n          begin\n             if Warn_On_Obsolescent_Feature then\n-               Error_Msg_N\n+               Error_Msg_N -- CODEFIX???\n                  (\"'G'N'A'T pragma cpp'_class is now obsolete; replace it\" &\n                   \" by pragma import?\", N);\n             end if;\n@@ -6408,7 +6412,7 @@ package body Sem_Prag is\n             --  been supported this way for some time.\n \n             if not Is_Limited_Type (Typ) then\n-               Error_Msg_N\n+               Error_Msg_N -- CODEFIX???\n                  (\"imported 'C'P'P type should be \" &\n                     \"explicitly declared limited?\",\n                   Get_Pragma_Arg (Arg1));\n@@ -6571,7 +6575,7 @@ package body Sem_Prag is\n             GNAT_Pragma;\n \n             if Warn_On_Obsolescent_Feature then\n-               Error_Msg_N\n+               Error_Msg_N -- CODEFIX???\n                  (\"'G'N'A'T pragma cpp'_virtual is now obsolete and has \" &\n                   \"no effect?\", N);\n             end if;\n@@ -6586,7 +6590,7 @@ package body Sem_Prag is\n             GNAT_Pragma;\n \n             if Warn_On_Obsolescent_Feature then\n-               Error_Msg_N\n+               Error_Msg_N -- CODEFIX???\n                  (\"'G'N'A'T pragma cpp'_vtable is now obsolete and has \" &\n                   \"no effect?\", N);\n             end if;\n@@ -6829,7 +6833,7 @@ package body Sem_Prag is\n             if Elab_Warnings and not Dynamic_Elaboration_Checks then\n                Error_Msg_N\n                  (\"?use of pragma Elaborate may not be safe\", N);\n-               Error_Msg_N\n+               Error_Msg_N -- CODEFIX???\n                  (\"?use pragma Elaborate_All instead if possible\", N);\n             end if;\n          end Elaborate;\n@@ -10467,13 +10471,13 @@ package body Sem_Prag is\n             Check_Too_Long (Internal);\n \n             if Is_Imported (Def_Id) or else Is_Exported (Def_Id) then\n-               Error_Pragma_Arg\n+               Error_Pragma_Arg -- CODEFIX???\n                  (\"cannot use pragma% for imported/exported object\",\n                   Internal);\n             end if;\n \n             if Is_Concurrent_Type (Etype (Internal)) then\n-               Error_Pragma_Arg\n+               Error_Pragma_Arg -- CODEFIX???\n                  (\"cannot specify pragma % for task/protected object\",\n                   Internal);\n             end if;\n@@ -10486,7 +10490,7 @@ package body Sem_Prag is\n             end if;\n \n             if Ekind (Def_Id) = E_Constant then\n-               Error_Pragma_Arg\n+               Error_Pragma_Arg -- CODEFIX???\n                  (\"cannot specify pragma % for a constant\", Internal);\n             end if;\n \n@@ -10647,8 +10651,9 @@ package body Sem_Prag is\n                if not Effective\n                  and then Warn_On_Redundant_Constructs\n                then\n-                  Error_Msg_NE (\"pragma Pure_Function on& is redundant?\",\n-                    N, Entity (E_Id));\n+                  Error_Msg_NE -- CODEFIX???\n+                    (\"pragma Pure_Function on& is redundant?\",\n+                     N, Entity (E_Id));\n                end if;\n             end if;\n          end Pure_Function;\n@@ -10821,9 +10826,9 @@ package body Sem_Prag is\n             Set_Ravenscar_Profile (N);\n \n             if Warn_On_Obsolescent_Feature then\n-               Error_Msg_N\n+               Error_Msg_N -- CODEFIX???\n                  (\"pragma Ravenscar is an obsolescent feature?\", N);\n-               Error_Msg_N\n+               Error_Msg_N -- CODEFIX???\n                  (\"|use pragma Profile (Ravenscar) instead\", N);\n             end if;\n \n@@ -10841,9 +10846,9 @@ package body Sem_Prag is\n               (Restricted, N, Warn => Treat_Restrictions_As_Warnings);\n \n             if Warn_On_Obsolescent_Feature then\n-               Error_Msg_N\n+               Error_Msg_N -- CODEFIX???\n                  (\"pragma Restricted_Run_Time is an obsolescent feature?\", N);\n-               Error_Msg_N\n+               Error_Msg_N -- CODEFIX???\n                  (\"|use pragma Profile (Restricted) instead\", N);\n             end if;\n \n@@ -11327,7 +11332,11 @@ package body Sem_Prag is\n \n                elsif Nkind (A) = N_Identifier then\n                   if Chars (A) = Name_All_Checks then\n-                     Set_Default_Style_Check_Options;\n+                     if GNAT_Mode then\n+                        Set_GNAT_Style_Check_Options;\n+                     else\n+                        Set_Default_Style_Check_Options;\n+                     end if;\n \n                   elsif Chars (A) = Name_On then\n                      Style_Check := True;\n@@ -11790,14 +11799,14 @@ package body Sem_Prag is\n                return;\n \n             elsif Is_Limited_Type (Typ) then\n-               Error_Msg_N\n+               Error_Msg_N -- CODEFIX???\n                  (\"Unchecked_Union must not be limited record type\", Typ);\n                Explain_Limited_Type (Typ, Typ);\n                return;\n \n             else\n                if not Has_Discriminants (Typ) then\n-                  Error_Msg_N\n+                  Error_Msg_N -- CODEFIX???\n                     (\"Unchecked_Union must have one discriminant\", Typ);\n                   return;\n                end if;"}, {"sha": "7fb17fd08a2747831aa04c829203744834b0f750", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=19d846a008c51b4425b88771aa2768bd882499cc", "patch": "@@ -160,6 +160,7 @@ package body Sem_Res is\n    procedure Resolve_Allocator                 (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve_Arithmetic_Op             (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve_Call                      (N : Node_Id; Typ : Entity_Id);\n+   procedure Resolve_Case_Expression           (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve_Character_Literal         (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve_Comparison_Op             (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve_Conditional_Expression    (N : Node_Id; Typ : Entity_Id);\n@@ -2187,6 +2188,9 @@ package body Sem_Res is\n                   Set_Entity (N, Seen);\n                   Generate_Reference (Seen, N);\n \n+               elsif Nkind (N) = N_Case_Expression then\n+                  Set_Etype (N, Expr_Type);\n+\n                elsif Nkind (N) = N_Character_Literal then\n                   Set_Etype (N, Expr_Type);\n \n@@ -2542,6 +2546,9 @@ package body Sem_Res is\n             when N_Attribute_Reference\n                              => Resolve_Attribute                (N, Ctx_Type);\n \n+            when N_Case_Expression\n+                             => Resolve_Case_Expression          (N, Ctx_Type);\n+\n             when N_Character_Literal\n                              => Resolve_Character_Literal        (N, Ctx_Type);\n \n@@ -2640,7 +2647,6 @@ package body Sem_Res is\n \n             when N_Unchecked_Type_Conversion =>\n                Resolve_Unchecked_Type_Conversion                 (N, Ctx_Type);\n-\n          end case;\n \n          --  If the subexpression was replaced by a non-subexpression, then\n@@ -5471,6 +5477,24 @@ package body Sem_Res is\n       Warn_On_Overlapping_Actuals (Nam, N);\n    end Resolve_Call;\n \n+   -----------------------------\n+   -- Resolve_Case_Expression --\n+   -----------------------------\n+\n+   procedure Resolve_Case_Expression (N : Node_Id; Typ : Entity_Id) is\n+      Alt : Node_Id;\n+\n+   begin\n+      Alt := First (Alternatives (N));\n+      while Present (Alt) loop\n+         Resolve (Expression (Alt), Typ);\n+         Next (Alt);\n+      end loop;\n+\n+      Set_Etype (N, Typ);\n+      Eval_Case_Expression (N);\n+   end Resolve_Case_Expression;\n+\n    -------------------------------\n    -- Resolve_Character_Literal --\n    -------------------------------"}, {"sha": "9a2425b4f37c23047daa30075e62ff3a28b0351b", "filename": "gcc/ada/sem_scil.adb", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fsem_scil.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fsem_scil.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_scil.adb?ref=19d846a008c51b4425b88771aa2768bd882499cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2009, Free Software Foundation, Inc.           --\n+--          Copyright (C) 2009-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -317,6 +317,15 @@ package body Sem_SCIL is\n                   return Found_Node;\n                end if;\n \n+            --  Actions of case expressions\n+\n+            when N_Case_Expression_Alternative =>\n+               if Present (Actions (P))\n+                 and then Find_SCIL_Node (Actions (P))\n+               then\n+                  return Found_Node;\n+               end if;\n+\n             --  Actions of conditional expressions\n \n             when N_Conditional_Expression =>\n@@ -513,6 +522,7 @@ package body Sem_SCIL is\n                N_Access_To_Object_Definition            |\n                N_Aggregate                              |\n                N_Allocator                              |\n+               N_Case_Expression                        |\n                N_Case_Statement_Alternative             |\n                N_Character_Literal                      |\n                N_Compilation_Unit                       |"}, {"sha": "bcfff4e043c6f5df68c855c7ffb2046f3b6c0073", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 71, "deletions": 61, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=19d846a008c51b4425b88771aa2768bd882499cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1999-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1999-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -199,15 +199,15 @@ package body Sem_Warn is\n       Setup_Asm_Inputs (N);\n \n       if No (Asm_Input_Value) then\n-         Error_Msg_F\n+         Error_Msg_F -- CODEFIX???\n            (\"?code statement with no inputs should usually be Volatile!\", N);\n          return;\n       end if;\n \n       Setup_Asm_Outputs (N);\n \n       if No (Asm_Output_Variable) then\n-         Error_Msg_F\n+         Error_Msg_F -- CODEFIX???\n            (\"?code statement with no outputs should usually be Volatile!\", N);\n          return;\n       end if;\n@@ -218,7 +218,7 @@ package body Sem_Warn is\n         and then Present (Prev (N))\n         and then Nkind (Prev (N)) = N_Code_Statement\n       then\n-         Error_Msg_F\n+         Error_Msg_F -- CODEFIX???\n            (\"?code statements in sequence should usually be Volatile!\", N);\n          Error_Msg_F\n            (\"\\?(suggest using template with multiple instructions)!\", N);\n@@ -1083,7 +1083,7 @@ package body Sem_Warn is\n                   if (Is_Volatile (E1) or else Has_Volatile_Components (E1))\n                     and then not Is_Imported (E1)\n                   then\n-                     Error_Msg_N\n+                     Error_Msg_N -- CODEFIX???\n                        (\"?& is not modified, volatile has no effect!\", E1);\n \n                   --  Another special case, Exception_Occurrence, this catches\n@@ -1275,7 +1275,7 @@ package body Sem_Warn is\n                        and then Present (Hiding_Loop_Variable (E1))\n                        and then not Warnings_Off_E1\n                      then\n-                        Error_Msg_N\n+                        Error_Msg_N -- CODEFIX???\n                           (\"?for loop implicitly declares loop variable!\",\n                            Hiding_Loop_Variable (E1));\n \n@@ -1463,21 +1463,17 @@ package body Sem_Warn is\n                --  a separate spec.\n \n                and then not (Is_Formal (E1)\n-                               and then\n-                             Ekind (Scope (E1)) = E_Subprogram_Body\n-                               and then\n-                             Present (Spec_Entity (E1))\n-                               and then\n-                             Referenced (Spec_Entity (E1)))\n+                              and then Ekind (Scope (E1)) = E_Subprogram_Body\n+                              and then Present (Spec_Entity (E1))\n+                              and then Referenced (Spec_Entity (E1)))\n \n                --  Consider private type referenced if full view is referenced.\n                --  If there is not full view, this is a generic type on which\n                --  warnings are also useful.\n \n                and then\n                  not (Is_Private_Type (E1)\n-                   and then\n-                     Present (Full_View (E1))\n+                       and then Present (Full_View (E1))\n                        and then Referenced (Full_View (E1)))\n \n                --  Don't worry about full view, only about private type\n@@ -1507,16 +1503,15 @@ package body Sem_Warn is\n                --  be non-referenced, since they start up tasks!\n \n                and then ((Ekind (E1) /= E_Variable\n-                             and then Ekind (E1) /= E_Constant\n-                             and then Ekind (E1) /= E_Component)\n-                           or else not Is_Task_Type (E1T))\n+                           and then Ekind (E1) /= E_Constant\n+                           and then Ekind (E1) /= E_Component)\n+                          or else not Is_Task_Type (E1T))\n \n                --  For subunits, only place warnings on the main unit itself,\n                --  since parent units are not completely compiled.\n \n                and then (Nkind (Unit (Cunit (Main_Unit))) /= N_Subunit\n-                           or else\n-                         Get_Source_Unit (E1) = Main_Unit)\n+                          or else Get_Source_Unit (E1) = Main_Unit)\n \n                --  No warning on a return object, because these are often\n                --  created with a single expression and an implicit return.\n@@ -1531,9 +1526,8 @@ package body Sem_Warn is\n                --  since they refer to problems in internal units).\n \n                if GNAT_Mode\n-                 or else not\n-                   Is_Internal_File_Name\n-                     (Unit_File_Name (Get_Source_Unit (E1)))\n+                 or else not Is_Internal_File_Name\n+                               (Unit_File_Name (Get_Source_Unit (E1)))\n                then\n                   --  We do not immediately flag the error. This is because we\n                   --  have not expanded generic bodies yet, and they may have\n@@ -2103,7 +2097,7 @@ package body Sem_Warn is\n                   while Present (Nam) loop\n                      if Entity (Nam) = Pack then\n                         Error_Msg_Qual_Level := 1;\n-                        Error_Msg_NE\n+                        Error_Msg_NE -- CODEFIX\n                           (\"?no entities of package& are referenced!\",\n                              Nam, Pack);\n                         Error_Msg_Qual_Level := 0;\n@@ -2300,7 +2294,7 @@ package body Sem_Warn is\n                      --  else or a pragma elaborate with a body library task).\n \n                      elsif Has_Visible_Entities (Entity (Name (Item))) then\n-                        Error_Msg_N\n+                        Error_Msg_N -- CODEFIX\n                           (\"?unit& is not referenced!\", Name (Item));\n                      end if;\n                   end if;\n@@ -2377,7 +2371,7 @@ package body Sem_Warn is\n                               if not\n                                 Has_Unreferenced (Entity (Name (Item)))\n                               then\n-                                 Error_Msg_N\n+                                 Error_Msg_N -- CODEFIX\n                                    (\"?no entities of & are referenced!\",\n                                     Name (Item));\n                               end if;\n@@ -2393,7 +2387,7 @@ package body Sem_Warn is\n                                 and then not Has_Warnings_Off (Lunit)\n                                 and then not Has_Unreferenced (Pack)\n                               then\n-                                 Error_Msg_NE\n+                                 Error_Msg_NE -- CODEFIX\n                                    (\"?no entities of & are referenced!\",\n                                      Unit_Declaration_Node (Pack),\n                                      Pack);\n@@ -2433,12 +2427,12 @@ package body Sem_Warn is\n                            end if;\n \n                            if Unreferenced_In_Spec (Item) then\n-                              Error_Msg_N\n+                              Error_Msg_N -- CODEFIX\n                                 (\"?unit& is not referenced in spec!\",\n                                  Name (Item));\n \n                            elsif No_Entities_Ref_In_Spec (Item) then\n-                              Error_Msg_N\n+                              Error_Msg_N -- CODEFIX\n                                 (\"?no entities of & are referenced in spec!\",\n                                  Name (Item));\n \n@@ -2777,7 +2771,7 @@ package body Sem_Warn is\n                   if Warn_On_Constant then\n                      Error_Msg_N\n                        (\"?formal parameter & is not modified!\", E1);\n-                     Error_Msg_N\n+                     Error_Msg_N -- CODEFIX???\n                        (\"\\?mode could be IN instead of `IN OUT`!\", E1);\n \n                      --  We do not generate warnings for IN OUT parameters\n@@ -2787,8 +2781,9 @@ package body Sem_Warn is\n                      --  default mode.\n \n                   elsif Check_Unreferenced then\n-                     Error_Msg_N (\"?formal parameter& is read but \"\n-                                  & \"never assigned!\", E1);\n+                     Error_Msg_N -- CODEFIX???\n+                       (\"?formal parameter& is read but \"\n+                        & \"never assigned!\", E1);\n                   end if;\n                end if;\n \n@@ -2973,21 +2968,21 @@ package body Sem_Warn is\n             --  Used only in context where Unmodified would have worked\n \n             elsif Warnings_Off_Used_Unmodified (E) then\n-               Error_Msg_NE\n+               Error_Msg_NE -- CODEFIX???\n                  (\"?could use Unmodified instead of \"\n                   & \"Warnings Off for &\", Pragma_Identifier (N), E);\n \n             --  Used only in context where Unreferenced would have worked\n \n             elsif Warnings_Off_Used_Unreferenced (E) then\n-               Error_Msg_NE\n+               Error_Msg_NE -- CODEFIX???\n                  (\"?could use Unreferenced instead of \"\n                   & \"Warnings Off for &\", Pragma_Identifier (N), E);\n \n             --  Not used at all\n \n             else\n-               Error_Msg_NE\n+               Error_Msg_NE -- CODEFIX???\n                  (\"?pragma Warnings Off for & unused, \"\n                   & \"could be omitted\", N, E);\n             end if;\n@@ -3611,17 +3606,19 @@ package body Sem_Warn is\n                   if Is_Entity_Name (Original_Node (C))\n                     and then Nkind (Cond) /= N_Op_Not\n                   then\n-                     Error_Msg_NE\n+                     Error_Msg_NE -- CODEFIX???\n                        (\"object & is always True?\", Cond, Original_Node (C));\n                      Track (Original_Node (C), Cond);\n \n                   else\n-                     Error_Msg_N (\"condition is always True?\", Cond);\n+                     Error_Msg_N -- CODEFIX???\n+                       (\"condition is always True?\", Cond);\n                      Track (Cond, Cond);\n                   end if;\n \n                else\n-                  Error_Msg_N (\"condition is always False?\", Cond);\n+                  Error_Msg_N -- CODEFIX???\n+                    (\"condition is always False?\", Cond);\n                   Track (Cond, Cond);\n                end if;\n             end;\n@@ -3861,7 +3858,8 @@ package body Sem_Warn is\n          procedure Warn1 is\n          begin\n             Error_Msg_Uint_1 := Low_Bound;\n-            Error_Msg_FE (\"?index for& may assume lower bound of^\", X, Ent);\n+            Error_Msg_FE -- CODEFIX\n+              (\"?index for& may assume lower bound of^\", X, Ent);\n          end Warn1;\n \n       --  Start of processing for Test_Suspicious_Index\n@@ -3885,11 +3883,11 @@ package body Sem_Warn is\n \n             if Nkind (Original_Node (X)) = N_Integer_Literal then\n                if Intval (X) = Low_Bound then\n-                  Error_Msg_FE --  CODEFIX\n+                  Error_Msg_FE -- CODEFIX\n                     (\"\\suggested replacement: `&''First`\", X, Ent);\n                else\n                   Error_Msg_Uint_1 := Intval (X) - Low_Bound;\n-                  Error_Msg_FE --  CODEFIX\n+                  Error_Msg_FE -- CODEFIX\n                     (\"\\suggested replacement: `&''First + ^`\", X, Ent);\n \n                end if;\n@@ -3995,7 +3993,7 @@ package body Sem_Warn is\n \n                --  Replacement subscript is now in string buffer\n \n-               Error_Msg_FE --  CODEFIX\n+               Error_Msg_FE -- CODEFIX\n                  (\"\\suggested replacement: `&~`\", Original_Node (X), Ent);\n             end if;\n \n@@ -4004,7 +4002,7 @@ package body Sem_Warn is\n          elsif Length_Reference (X) then\n             Warn1;\n             Error_Msg_Node_2 := Ent;\n-            Error_Msg_FE\n+            Error_Msg_FE -- CODEFIX???\n               (\"\\suggest replacement of `&''Length` by `&''Last`\",\n                X, Ent);\n \n@@ -4015,7 +4013,7 @@ package body Sem_Warn is\n          then\n             Warn1;\n             Error_Msg_Node_2 := Ent;\n-            Error_Msg_FE\n+            Error_Msg_FE -- CODEFIX???\n               (\"\\suggest replacement of `&''Length` by `&''Last`\",\n                Left_Opnd (X), Ent);\n          end if;\n@@ -4167,10 +4165,10 @@ package body Sem_Warn is\n                      if Present (Renamed_Object (E))\n                        and then Comes_From_Source (Renamed_Object (E))\n                      then\n-                        Error_Msg_N\n+                        Error_Msg_N -- CODEFIX\n                           (\"?renamed variable & is not referenced!\", E);\n                      else\n-                        Error_Msg_N\n+                        Error_Msg_N -- CODEFIX\n                           (\"?variable & is not referenced!\", E);\n                      end if;\n                   end if;\n@@ -4180,10 +4178,11 @@ package body Sem_Warn is\n                if Present (Renamed_Object (E))\n                  and then Comes_From_Source (Renamed_Object (E))\n                then\n-                  Error_Msg_N\n+                  Error_Msg_N -- CODEFIX\n                     (\"?renamed constant & is not referenced!\", E);\n                else\n-                  Error_Msg_N (\"?constant & is not referenced!\", E);\n+                  Error_Msg_N -- CODEFIX\n+                    (\"?constant & is not referenced!\", E);\n                end if;\n \n             when E_In_Parameter     |\n@@ -4208,7 +4207,7 @@ package body Sem_Warn is\n                      end if;\n \n                      if not Is_Trivial_Subprogram (Scope (E)) then\n-                        Error_Msg_NE\n+                        Error_Msg_NE -- CODEFIX\n                           (\"?formal parameter & is not referenced!\",\n                            E, Spec_E);\n                      end if;\n@@ -4219,32 +4218,41 @@ package body Sem_Warn is\n                null;\n \n             when E_Discriminant =>\n-               Error_Msg_N (\"?discriminant & is not referenced!\", E);\n+               Error_Msg_N -- CODEFIX???\n+                 (\"?discriminant & is not referenced!\", E);\n \n             when E_Named_Integer |\n                  E_Named_Real    =>\n-               Error_Msg_N (\"?named number & is not referenced!\", E);\n+               Error_Msg_N -- CODEFIX\n+                 (\"?named number & is not referenced!\", E);\n \n             when Formal_Object_Kind =>\n-               Error_Msg_N (\"?formal object & is not referenced!\", E);\n+               Error_Msg_N -- CODEFIX\n+                 (\"?formal object & is not referenced!\", E);\n \n             when E_Enumeration_Literal =>\n-               Error_Msg_N (\"?literal & is not referenced!\", E);\n+               Error_Msg_N -- CODEFIX\n+                 (\"?literal & is not referenced!\", E);\n \n             when E_Function =>\n-               Error_Msg_N (\"?function & is not referenced!\", E);\n+               Error_Msg_N -- CODEFIX\n+                 (\"?function & is not referenced!\", E);\n \n             when E_Procedure =>\n-               Error_Msg_N (\"?procedure & is not referenced!\", E);\n+               Error_Msg_N -- CODEFIX\n+                 (\"?procedure & is not referenced!\", E);\n \n             when E_Package =>\n-               Error_Msg_N (\"?package & is not referenced!\", E);\n+               Error_Msg_N -- CODEFIX\n+                 (\"?package & is not referenced!\", E);\n \n             when E_Exception =>\n-               Error_Msg_N (\"?exception & is not referenced!\", E);\n+               Error_Msg_N -- CODEFIX\n+                 (\"?exception & is not referenced!\", E);\n \n             when E_Label =>\n-               Error_Msg_N (\"?label & is not referenced!\", E);\n+               Error_Msg_N -- CODEFIX\n+                 (\"?label & is not referenced!\", E);\n \n             when E_Generic_Procedure =>\n                Error_Msg_N -- CODEFIX\n@@ -4255,10 +4263,12 @@ package body Sem_Warn is\n                  (\"?generic function & is never instantiated!\", E);\n \n             when Type_Kind =>\n-               Error_Msg_N (\"?type & is not referenced!\", E);\n+               Error_Msg_N -- CODEFIX\n+                 (\"?type & is not referenced!\", E);\n \n             when others =>\n-               Error_Msg_N (\"?& is not referenced!\", E);\n+               Error_Msg_N -- CODEFIX\n+                 (\"?& is not referenced!\", E);\n          end case;\n \n          --  Kill warnings on the entity on which the message has been posted\n@@ -4355,7 +4365,7 @@ package body Sem_Warn is\n                           (\"?& modified by call, but value never referenced\",\n                            Last_Assignment (Ent), Ent);\n                      else\n-                        Error_Msg_NE\n+                        Error_Msg_NE -- CODEFIX\n                           (\"?useless assignment to&, value never referenced!\",\n                            Last_Assignment (Ent), Ent);\n                      end if;\n@@ -4371,7 +4381,7 @@ package body Sem_Warn is\n                        (\"?& modified by call, but value overwritten #!\",\n                         Last_Assignment (Ent), Ent);\n                   else\n-                     Error_Msg_NE\n+                     Error_Msg_NE -- CODEFIX\n                        (\"?useless assignment to&, value overwritten #!\",\n                         Last_Assignment (Ent), Ent);\n                   end if;"}, {"sha": "ff77ebbd8dcdccd968cf10e2aa414652c61f6f6c", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=19d846a008c51b4425b88771aa2768bd882499cc", "patch": "@@ -146,6 +146,7 @@ package body Sinfo is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_And_Then\n+        or else NT (N).Nkind = N_Case_Expression_Alternative\n         or else NT (N).Nkind = N_Compilation_Unit_Aux\n         or else NT (N).Nkind = N_Expression_With_Actions\n         or else NT (N).Nkind = N_Freeze_Entity\n@@ -230,6 +231,7 @@ package body Sinfo is\n       (N : Node_Id) return List_Id is\n    begin\n       pragma Assert (False\n+        or else NT (N).Nkind = N_Case_Expression\n         or else NT (N).Nkind = N_Case_Statement\n         or else NT (N).Nkind = N_In\n         or else NT (N).Nkind = N_Not_In);\n@@ -792,6 +794,7 @@ package body Sinfo is\n       (N : Node_Id) return List_Id is\n    begin\n       pragma Assert (False\n+        or else NT (N).Nkind = N_Case_Expression_Alternative\n         or else NT (N).Nkind = N_Case_Statement_Alternative\n         or else NT (N).Nkind = N_Variant);\n       return List4 (N);\n@@ -1170,6 +1173,8 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Assignment_Statement\n         or else NT (N).Nkind = N_At_Clause\n         or else NT (N).Nkind = N_Attribute_Definition_Clause\n+        or else NT (N).Nkind = N_Case_Expression\n+        or else NT (N).Nkind = N_Case_Expression_Alternative\n         or else NT (N).Nkind = N_Case_Statement\n         or else NT (N).Nkind = N_Code_Statement\n         or else NT (N).Nkind = N_Component_Association\n@@ -3067,6 +3072,7 @@ package body Sinfo is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_And_Then\n+        or else NT (N).Nkind = N_Case_Expression_Alternative\n         or else NT (N).Nkind = N_Compilation_Unit_Aux\n         or else NT (N).Nkind = N_Expression_With_Actions\n         or else NT (N).Nkind = N_Freeze_Entity\n@@ -3151,6 +3157,7 @@ package body Sinfo is\n       (N : Node_Id; Val : List_Id) is\n    begin\n       pragma Assert (False\n+        or else NT (N).Nkind = N_Case_Expression\n         or else NT (N).Nkind = N_Case_Statement\n         or else NT (N).Nkind = N_In\n         or else NT (N).Nkind = N_Not_In);\n@@ -3713,6 +3720,7 @@ package body Sinfo is\n       (N : Node_Id; Val : List_Id) is\n    begin\n       pragma Assert (False\n+        or else NT (N).Nkind = N_Case_Expression_Alternative\n         or else NT (N).Nkind = N_Case_Statement_Alternative\n         or else NT (N).Nkind = N_Variant);\n       Set_List4_With_Parent (N, Val);\n@@ -4082,6 +4090,8 @@ package body Sinfo is\n         or else NT (N).Nkind = N_Assignment_Statement\n         or else NT (N).Nkind = N_At_Clause\n         or else NT (N).Nkind = N_Attribute_Definition_Clause\n+        or else NT (N).Nkind = N_Case_Expression\n+        or else NT (N).Nkind = N_Case_Expression_Alternative\n         or else NT (N).Nkind = N_Case_Statement\n         or else NT (N).Nkind = N_Code_Statement\n         or else NT (N).Nkind = N_Component_Association\n@@ -6050,7 +6060,6 @@ package body Sinfo is\n              T = V8;\n    end Nkind_In;\n \n-\n    function Nkind_In\n      (T  : Node_Kind;\n       V1 : Node_Kind;"}, {"sha": "24075c70c5e90eaee431f099138e1ddd29cdbb2b", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 56, "deletions": 4, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=19d846a008c51b4425b88771aa2768bd882499cc", "patch": "@@ -6543,10 +6543,46 @@ package Sinfo is\n    --  reconstructed tree printed by Sprint, and the node descriptions here\n    --  show this syntax.\n \n-   --  Note: Conditional_Expression is in this section for historical reasons.\n-   --  We will move it to its appropriate place when it is officially approved\n-   --  as an extension (and then we will know what the exact grammar and place\n-   --  in the Reference Manual is!)\n+   --  Note: Case_Expression and Conditional_Expression is in this section for\n+   --  now, since they are extensions. We will move them to their appropriate\n+   --  places when they are officially approved as extensions (and then we will\n+   --  know what the exact grammar and place in the Reference Manual is!)\n+\n+      ---------------------\n+      -- Case Expression --\n+      ---------------------\n+\n+      --  CASE_EXPRESSION ::=\n+      --    case EXPRESSION is\n+      --      CASE_EXPRESSION_ALTERNATIVE\n+      --      {CASE_EXPRESSION_ALTERNATIVE}\n+\n+      --  Note that the Alternatives cannot include pragmas (this constrasts\n+      --  with the situation of case statements where pragmas are allowed).\n+\n+      --  N_Case_Expression\n+      --  Sloc points to CASE\n+      --  Expression (Node3)\n+      --  Alternatives (List4)\n+\n+      ---------------------------------\n+      -- Case Expression Alternative --\n+      ---------------------------------\n+\n+      --  CASE_STATEMENT_ALTERNATIVE ::=\n+      --    when DISCRETE_CHOICE_LIST =>\n+      --      EXPRESSION\n+\n+      --  N_Case_Expression_Alternative\n+      --  Sloc points to WHEN\n+      --  Actions (List1)\n+      --  Discrete_Choices (List4)\n+      --  Expression (Node3)\n+\n+      --  Note: The Actions field temporarily holds any actions associated with\n+      --  evaluation of the Expression. During expansion of the case expression\n+      --  these actions are wrapped into the an N_Expressions_With_Actions node\n+      --  replacing the original expression.\n \n       ----------------------------\n       -- Conditional Expression --\n@@ -7259,6 +7295,7 @@ package Sinfo is\n \n       N_Aggregate,\n       N_Allocator,\n+      N_Case_Expression,\n       N_Extension_Aggregate,\n       N_Range,\n       N_Real_Literal,\n@@ -7437,6 +7474,7 @@ package Sinfo is\n       N_Abstract_Subprogram_Declaration,\n       N_Access_Definition,\n       N_Access_To_Object_Definition,\n+      N_Case_Expression_Alternative,\n       N_Case_Statement_Alternative,\n       N_Compilation_Unit,\n       N_Compilation_Unit_Aux,\n@@ -10260,6 +10298,20 @@ package Sinfo is\n         4 => False,   --  unused\n         5 => False),  --  unused\n \n+     N_Case_Expression =>\n+       (1 => False,   --  unused\n+        2 => False,   --  unused\n+        3 => True,    --  Expression (Node3)\n+        4 => True,    --  Alternatives (List4)\n+        5 => False),  --  unused\n+\n+     N_Case_Expression_Alternative =>\n+       (1 => False,   --  Actions (List1-Sem)\n+        2 => False,   --  unused\n+        3 => True,    --  Statements (List3)\n+        4 => True,    --  Expression (Node4)\n+        5 => False),  --  unused\n+\n      N_Case_Statement =>\n        (1 => False,   --  unused\n         2 => False,   --  unused"}, {"sha": "bc1f35dea2a4e79851527f46eb3743f1165477f7", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=19d846a008c51b4425b88771aa2768bd882499cc", "patch": "@@ -1084,6 +1084,32 @@ package body Sprint is\n \n             Write_Char (';');\n \n+         when N_Case_Expression =>\n+            declare\n+               Alt : Node_Id;\n+\n+            begin\n+               Write_Str_With_Col_Check_Sloc (\"(case \");\n+               Sprint_Node (Expression (Node));\n+               Write_Str_With_Col_Check (\" is\");\n+\n+               Alt := First (Alternatives (Node));\n+               loop\n+                  Sprint_Node (Alt);\n+                  Next (Alt);\n+                  exit when No (Alt);\n+                  Write_Char (',');\n+               end loop;\n+\n+               Write_Char (')');\n+            end;\n+\n+         when N_Case_Expression_Alternative =>\n+            Write_Str_With_Col_Check (\" when \");\n+            Sprint_Bar_List (Discrete_Choices (Node));\n+            Write_Str (\" => \");\n+            Sprint_Node (Expression (Node));\n+\n          when N_Case_Statement =>\n             Write_Indent_Str_Sloc (\"case \");\n             Sprint_Node (Expression (Node));"}, {"sha": "5467f4efe9ca984cc37223ad3754f672b3cb082a", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d846a008c51b4425b88771aa2768bd882499cc/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=19d846a008c51b4425b88771aa2768bd882499cc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -730,14 +730,14 @@ package Types is\n    -- Parameter Mechanism Control --\n    ---------------------------------\n \n-   --  Function and parameter entities have a field that records the\n-   --  passing mechanism. See specification of Sem_Mech for full details.\n-   --  The following subtype is used to represent values of this type:\n+   --  Function and parameter entities have a field that records the passing\n+   --  mechanism. See specification of Sem_Mech for full details. The following\n+   --  subtype is used to represent values of this type:\n \n    subtype Mechanism_Type is Int range -18 .. Int'Last;\n-   --  Type used to represent a mechanism value. This is a subtype rather\n-   --  than a type to avoid some annoying processing problems with certain\n-   --  routines in Einfo (processing them to create the corresponding C).\n+   --  Type used to represent a mechanism value. This is a subtype rather than\n+   --  a type to avoid some annoying processing problems with certain routines\n+   --  in Einfo (processing them to create the corresponding C).\n \n    ------------------------------\n    -- Run-Time Exception Codes --\n@@ -762,12 +762,12 @@ package Types is\n    --    1. Modify the type and subtype declarations below appropriately,\n    --       keeping things in alphabetical order.\n \n-   --    2. Modify the corresponding definitions in types.h, including\n-   --       the definition of last_reason_code.\n+   --    2. Modify the corresponding definitions in types.h, including the\n+   --       definition of last_reason_code.\n \n-   --    3. Add a new routine in Ada.Exceptions with the appropriate call\n-   --       and static string constant. Note that there is more than one\n-   --       version of a-except.adb which must be modified.\n+   --    3. Add a new routine in Ada.Exceptions with the appropriate call and\n+   --       static string constant. Note that there is more than one version\n+   --       of a-except.adb which must be modified.\n \n    type RT_Exception_Code is\n      (CE_Access_Check_Failed,            -- 00"}]}