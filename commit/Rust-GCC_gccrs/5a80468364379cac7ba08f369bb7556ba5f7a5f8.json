{"sha": "5a80468364379cac7ba08f369bb7556ba5f7a5f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWE4MDQ2ODM2NDM3OWNhYzdiYTA4ZjM2OWJiNzU1NmJhNWY3YTVmOA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2014-11-19T03:03:34Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2014-11-19T03:03:34Z"}, "message": "constexpr.c (cxx_eval_constant_expression): Give jump_target a default argument.\n\n\t* constexpr.c (cxx_eval_constant_expression): Give jump_target a\n\tdefault argument.\n\t(lots): Omit NULL jump_target arguments.\n\nFrom-SVN: r217747", "tree": {"sha": "2b1c80036e3fc3780f983572438441d09ac46dcd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b1c80036e3fc3780f983572438441d09ac46dcd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a80468364379cac7ba08f369bb7556ba5f7a5f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a80468364379cac7ba08f369bb7556ba5f7a5f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a80468364379cac7ba08f369bb7556ba5f7a5f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a80468364379cac7ba08f369bb7556ba5f7a5f8/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2b3ab879c7e00d1d9a86357bf13ebb0859ab9c88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b3ab879c7e00d1d9a86357bf13ebb0859ab9c88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b3ab879c7e00d1d9a86357bf13ebb0859ab9c88"}], "stats": {"total": 93, "additions": 44, "deletions": 49}, "files": [{"sha": "e508c5ce2fb289ec421e8d9f823dfe1a1b0a570d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a80468364379cac7ba08f369bb7556ba5f7a5f8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a80468364379cac7ba08f369bb7556ba5f7a5f8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5a80468364379cac7ba08f369bb7556ba5f7a5f8", "patch": "@@ -1,5 +1,9 @@\n 2014-11-18  Jason Merrill  <jason@redhat.com>\n \n+\t* constexpr.c (cxx_eval_constant_expression): Give jump_target a\n+\tdefault argument.\n+\t(lots): Omit NULL jump_target arguments.\n+\n \t* constexpr.c (struct constexpr_ctx): Add quiet field.\n \t(cxx_eval_outermost_constant_expr, is_sub_constant_expr): Set it.\n \t(lots): Replace allow_non_constant parameter with ctx->quiet."}, {"sha": "4669586ca21e50ca5b1e971597d82d8e89c20e18", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 40, "deletions": 49, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a80468364379cac7ba08f369bb7556ba5f7a5f8/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a80468364379cac7ba08f369bb7556ba5f7a5f8/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=5a80468364379cac7ba08f369bb7556ba5f7a5f8", "patch": "@@ -872,7 +872,7 @@ struct constexpr_ctx {\n static GTY (()) hash_table<constexpr_call_hasher> *constexpr_call_table;\n \n static tree cxx_eval_constant_expression (const constexpr_ctx *, tree,\n-\t\t\t\t\t  bool, bool *, bool *, tree *);\n+\t\t\t\t\t  bool, bool *, bool *, tree * = NULL);\n \n /* Compute a hash value for a constexpr call representation.  */\n \n@@ -994,8 +994,7 @@ cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t,\n     {\n       args[i] = cxx_eval_constant_expression (ctx, CALL_EXPR_ARG (t, i),\n \t\t\t\t\t      addr,\n-\t\t\t\t\t      non_constant_p, overflow_p,\n-\t\t\t\t\t      NULL);\n+\t\t\t\t\t      non_constant_p, overflow_p);\n       if (ctx->quiet && *non_constant_p)\n \treturn t;\n     }\n@@ -1069,7 +1068,7 @@ cxx_bind_parameters_in_call (const constexpr_ctx *ctx, tree t,\n \t}\n       arg = cxx_eval_constant_expression (ctx, x,\n \t\t\t\t\t  TREE_CODE (type) == REFERENCE_TYPE,\n-\t\t\t\t\t  non_constant_p, overflow_p, NULL);\n+\t\t\t\t\t  non_constant_p, overflow_p);\n       /* Don't VERIFY_CONSTANT here.  */\n       if (*non_constant_p && ctx->quiet)\n \treturn;\n@@ -1150,7 +1149,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n       /* Might be a constexpr function pointer.  */\n       fun = cxx_eval_constant_expression (ctx, fun,\n \t\t\t\t\t  /*addr*/false, non_constant_p,\n-\t\t\t\t\t  overflow_p, NULL);\n+\t\t\t\t\t  overflow_p);\n       STRIP_NOPS (fun);\n       if (TREE_CODE (fun) == ADDR_EXPR)\n \tfun = TREE_OPERAND (fun, 0);\n@@ -1187,7 +1186,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t  tree arg = convert_from_reference (get_nth_callarg (t, 1));\n \t  return cxx_eval_constant_expression (ctx, arg,\n \t\t\t\t\t       addr, non_constant_p,\n-\t\t\t\t\t       overflow_p, NULL);\n+\t\t\t\t\t       overflow_p);\n \t}\n       else if (TREE_CODE (t) == AGGR_INIT_EXPR\n \t       && AGGR_INIT_ZERO_FIRST (t))\n@@ -1283,7 +1282,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t      result = (cxx_eval_constant_expression\n \t\t\t(&new_ctx, new_call.fundef->body,\n \t\t\t addr,\n-\t\t\t non_constant_p, overflow_p, NULL));\n+\t\t\t non_constant_p, overflow_p));\n \t    }\n \t  else\n \t    {\n@@ -1458,8 +1457,7 @@ cxx_eval_unary_expression (const constexpr_ctx *ctx, tree t,\n   tree r;\n   tree orig_arg = TREE_OPERAND (t, 0);\n   tree arg = cxx_eval_constant_expression (ctx, orig_arg,\n-\t\t\t\t\t   addr, non_constant_p, overflow_p,\n-\t\t\t\t\t   NULL);\n+\t\t\t\t\t   addr, non_constant_p, overflow_p);\n   VERIFY_CONSTANT (arg);\n   location_t loc = EXPR_LOCATION (t);\n   enum tree_code code = TREE_CODE (t);\n@@ -1490,11 +1488,11 @@ cxx_eval_binary_expression (const constexpr_ctx *ctx, tree t,\n   tree lhs, rhs;\n   lhs = cxx_eval_constant_expression (ctx, orig_lhs,\n \t\t\t\t      addr,\n-\t\t\t\t      non_constant_p, overflow_p, NULL);\n+\t\t\t\t      non_constant_p, overflow_p);\n   VERIFY_CONSTANT (lhs);\n   rhs = cxx_eval_constant_expression (ctx, orig_rhs,\n \t\t\t\t      addr,\n-\t\t\t\t      non_constant_p, overflow_p, NULL);\n+\t\t\t\t      non_constant_p, overflow_p);\n   VERIFY_CONSTANT (rhs);\n \n   location_t loc = EXPR_LOCATION (t);\n@@ -1524,8 +1522,7 @@ cxx_eval_conditional_expression (const constexpr_ctx *ctx, tree t,\n {\n   tree val = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),\n \t\t\t\t\t   addr,\n-\t\t\t\t\t   non_constant_p, overflow_p,\n-\t\t\t\t\t   NULL);\n+\t\t\t\t\t   non_constant_p, overflow_p);\n   VERIFY_CONSTANT (val);\n   /* Don't VERIFY_CONSTANT the other operands.  */\n   if (integer_zerop (val))\n@@ -1550,7 +1547,7 @@ cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,\n   tree oldary = TREE_OPERAND (t, 0);\n   tree ary = cxx_eval_constant_expression (ctx, oldary,\n \t\t\t\t\t   addr,\n-\t\t\t\t\t   non_constant_p, overflow_p, NULL);\n+\t\t\t\t\t   non_constant_p, overflow_p);\n   tree index, oldidx;\n   HOST_WIDE_INT i;\n   tree elem_type;\n@@ -1560,7 +1557,7 @@ cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,\n   oldidx = TREE_OPERAND (t, 1);\n   index = cxx_eval_constant_expression (ctx, oldidx,\n \t\t\t\t\tfalse,\n-\t\t\t\t\tnon_constant_p, overflow_p, NULL);\n+\t\t\t\t\tnon_constant_p, overflow_p);\n   VERIFY_CONSTANT (index);\n   if (addr && ary == oldary && index == oldidx)\n     return t;\n@@ -1591,8 +1588,7 @@ cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,\n \t  tree val = build_value_init (elem_type, tf_warning_or_error);\n \t  return cxx_eval_constant_expression (ctx, val,\n \t\t\t\t\t       addr,\n-\t\t\t\t\t       non_constant_p, overflow_p,\n-\t\t\t\t\t       NULL);\n+\t\t\t\t\t       non_constant_p, overflow_p);\n \t}\n \n       if (!ctx->quiet)\n@@ -1638,7 +1634,7 @@ cxx_eval_component_reference (const constexpr_ctx *ctx, tree t,\n   tree orig_whole = TREE_OPERAND (t, 0);\n   tree whole = cxx_eval_constant_expression (ctx, orig_whole,\n \t\t\t\t\t     addr,\n-\t\t\t\t\t     non_constant_p, overflow_p, NULL);\n+\t\t\t\t\t     non_constant_p, overflow_p);\n   if (whole == orig_whole)\n     return t;\n   if (addr)\n@@ -1697,7 +1693,7 @@ cxx_eval_component_reference (const constexpr_ctx *ctx, tree t,\n   value = build_value_init (TREE_TYPE (t), tf_warning_or_error);\n   return cxx_eval_constant_expression (ctx, value,\n \t\t\t\t       addr,\n-\t\t\t\t       non_constant_p, overflow_p, NULL);\n+\t\t\t\t       non_constant_p, overflow_p);\n }\n \n /* Subroutine of cxx_eval_constant_expression.\n@@ -1715,7 +1711,7 @@ cxx_eval_bit_field_ref (const constexpr_ctx *ctx, tree t,\n   HOST_WIDE_INT istart, isize;\n   tree whole = cxx_eval_constant_expression (ctx, orig_whole,\n \t\t\t\t\t     addr,\n-\t\t\t\t\t     non_constant_p, overflow_p, NULL);\n+\t\t\t\t\t     non_constant_p, overflow_p);\n   tree start, field, value;\n   unsigned HOST_WIDE_INT i;\n \n@@ -1798,14 +1794,14 @@ cxx_eval_logical_expression (const constexpr_ctx *ctx, tree t,\n   tree r;\n   tree lhs = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),\n \t\t\t\t\t   addr,\n-\t\t\t\t\t   non_constant_p, overflow_p, NULL);\n+\t\t\t\t\t   non_constant_p, overflow_p);\n   VERIFY_CONSTANT (lhs);\n   if (tree_int_cst_equal (lhs, bailout_value))\n     return lhs;\n   gcc_assert (tree_int_cst_equal (lhs, continue_value));\n   r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n \t\t\t\t    addr, non_constant_p,\n-\t\t\t\t    overflow_p, NULL);\n+\t\t\t\t    overflow_p);\n   VERIFY_CONSTANT (r);\n   return r;\n }\n@@ -1948,8 +1944,7 @@ cxx_eval_bare_aggregate (const constexpr_ctx *ctx, tree t,\n \tCONSTRUCTOR_APPEND_ELT (*p, index, new_ctx.ctor);\n       tree elt = cxx_eval_constant_expression (&new_ctx, value,\n \t\t\t\t\t       addr,\n-\t\t\t\t\t       non_constant_p, overflow_p,\n-\t\t\t\t\t       NULL);\n+\t\t\t\t\t       non_constant_p, overflow_p);\n       /* Don't VERIFY_CONSTANT here.  */\n       if (ctx->quiet && *non_constant_p)\n \tbreak;\n@@ -2067,7 +2062,7 @@ cxx_eval_vec_init_1 (const constexpr_ctx *ctx, tree atype, tree init,\n \t     we just pre-built above.  */\n \t  eltinit = (cxx_eval_constant_expression\n \t\t     (&new_ctx, init,\n-\t\t      addr, non_constant_p, overflow_p, NULL));\n+\t\t      addr, non_constant_p, overflow_p));\n \t}\n       else\n \t{\n@@ -2081,7 +2076,7 @@ cxx_eval_vec_init_1 (const constexpr_ctx *ctx, tree atype, tree init,\n \t  eltinit = force_rvalue (eltinit, tf_warning_or_error);\n \t  eltinit = (cxx_eval_constant_expression\n \t\t     (&new_ctx, eltinit, addr,\n-\t\t      non_constant_p, overflow_p, NULL));\n+\t\t      non_constant_p, overflow_p));\n \t}\n       if (*non_constant_p && !ctx->quiet)\n \tbreak;\n@@ -2318,7 +2313,7 @@ cxx_eval_indirect_ref (const constexpr_ctx *ctx, tree t,\n   tree orig_op0 = TREE_OPERAND (t, 0);\n   tree op0 = cxx_eval_constant_expression (ctx, orig_op0,\n \t\t\t\t\t   /*addr*/false, non_constant_p,\n-\t\t\t\t\t   overflow_p, NULL);\n+\t\t\t\t\t   overflow_p);\n   bool empty_base = false;\n   tree r;\n \n@@ -2331,7 +2326,7 @@ cxx_eval_indirect_ref (const constexpr_ctx *ctx, tree t,\n \n   if (r)\n     r = cxx_eval_constant_expression (ctx, r,\n-\t\t\t\t      addr, non_constant_p, overflow_p, NULL);\n+\t\t\t\t      addr, non_constant_p, overflow_p);\n   else\n     {\n       tree sub = op0;\n@@ -2433,8 +2428,7 @@ cxx_eval_trinary_expression (const constexpr_ctx *ctx, tree t,\n     {\n       args[i] = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, i),\n \t\t\t\t\t      addr,\n-\t\t\t\t\t      non_constant_p, overflow_p,\n-\t\t\t\t\t      NULL);\n+\t\t\t\t\t      non_constant_p, overflow_p);\n       VERIFY_CONSTANT (args[i]);\n     }\n \n@@ -2467,7 +2461,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n   tree target = TREE_OPERAND (t, 0);\n   target = cxx_eval_constant_expression (ctx, target,\n \t\t\t\t\t true,\n-\t\t\t\t\t non_constant_p, overflow_p, NULL);\n+\t\t\t\t\t non_constant_p, overflow_p);\n   if (*non_constant_p)\n     return t;\n \n@@ -2543,7 +2537,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n \n   tree init = cxx_eval_constant_expression (&new_ctx, TREE_OPERAND (t, 1),\n \t\t\t\t\t    false,\n-\t\t\t\t\t    non_constant_p, overflow_p, NULL);\n+\t\t\t\t\t    non_constant_p, overflow_p);\n   if (target == object)\n     /* The hash table might have moved since the get earlier.  */\n     ctx->values->put (object, init);\n@@ -2573,12 +2567,12 @@ cxx_eval_increment_expression (const constexpr_ctx *ctx, tree t,\n \n   /* The operand as an lvalue.  */\n   op = cxx_eval_constant_expression (ctx, op, true,\n-\t\t\t\t     non_constant_p, overflow_p, NULL);\n+\t\t\t\t     non_constant_p, overflow_p);\n \n   /* The operand as an rvalue.  */\n   tree val = rvalue (op);\n   val = cxx_eval_constant_expression (ctx, val, false,\n-\t\t\t\t      non_constant_p, overflow_p, NULL);\n+\t\t\t\t      non_constant_p, overflow_p);\n   VERIFY_CONSTANT (val);\n \n   /* The modified value.  */\n@@ -2599,7 +2593,7 @@ cxx_eval_increment_expression (const constexpr_ctx *ctx, tree t,\n   /* Storing the modified value.  */\n   tree store = build2 (MODIFY_EXPR, type, op, mod);\n   cxx_eval_constant_expression (ctx, store,\n-\t\t\t\ttrue, non_constant_p, overflow_p, NULL);\n+\t\t\t\ttrue, non_constant_p, overflow_p);\n \n   /* And the value of the expression.  */\n   if (code == PREINCREMENT_EXPR || code == PREDECREMENT_EXPR)\n@@ -2754,7 +2748,7 @@ cxx_eval_switch_expr (const constexpr_ctx *ctx, tree t,\n {\n   tree cond = TREE_OPERAND (t, 0);\n   cond = cxx_eval_constant_expression (ctx, cond, false,\n-\t\t\t\t       non_constant_p, overflow_p, NULL);\n+\t\t\t\t       non_constant_p, overflow_p);\n   VERIFY_CONSTANT (cond);\n   *jump_target = cond;\n \n@@ -2876,8 +2870,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t  {\n \t    init = cxx_eval_constant_expression (ctx, init,\n \t\t\t\t\t\t false,\n-\t\t\t\t\t\t non_constant_p, overflow_p,\n-\t\t\t\t\t\t NULL);\n+\t\t\t\t\t\t non_constant_p, overflow_p);\n \t    ctx->values->put (r, init);\n \t  }\n \telse if (ctx == &new_ctx)\n@@ -2915,7 +2908,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t initialization of a temporary.  */\n       r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n \t\t\t\t\tfalse,\n-\t\t\t\t\tnon_constant_p, overflow_p, NULL);\n+\t\t\t\t\tnon_constant_p, overflow_p);\n       if (!*non_constant_p)\n \t/* Adjust the type of the result to the type of the temporary.  */\n \tr = adjust_temp_type (TREE_TYPE (t), r);\n@@ -2928,7 +2921,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t     not the side-effect of the initialization.  */\n \t  r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n \t\t\t\t\t    false,\n-\t\t\t\t\t    non_constant_p, overflow_p, NULL);\n+\t\t\t\t\t    non_constant_p, overflow_p);\n \t  break;\n \t}\n       /* else fall through */\n@@ -2940,13 +2933,13 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case SCOPE_REF:\n       r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n \t\t\t\t\taddr,\n-\t\t\t\t\tnon_constant_p, overflow_p, NULL);\n+\t\t\t\t\tnon_constant_p, overflow_p);\n       break;\n \n     case RETURN_EXPR:\n       r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),\n \t\t\t\t\taddr,\n-\t\t\t\t\tnon_constant_p, overflow_p, NULL);\n+\t\t\t\t\tnon_constant_p, overflow_p);\n       *jump_target = t;\n       break;\n \n@@ -2976,8 +2969,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \ttree oldop = TREE_OPERAND (t, 0);\n \ttree op = cxx_eval_constant_expression (ctx, oldop,\n \t\t\t\t\t\t/*addr*/true,\n-\t\t\t\t\t\tnon_constant_p, overflow_p,\n-\t\t\t\t\t\tNULL);\n+\t\t\t\t\t\tnon_constant_p, overflow_p);\n \t/* Don't VERIFY_CONSTANT here.  */\n \tif (*non_constant_p)\n \t  return t;\n@@ -3165,8 +3157,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \ttree oldop = TREE_OPERAND (t, 0);\n \ttree op = cxx_eval_constant_expression (ctx, oldop,\n \t\t\t\t\t\taddr,\n-\t\t\t\t\t\tnon_constant_p, overflow_p,\n-\t\t\t\t\t\tNULL);\n+\t\t\t\t\t\tnon_constant_p, overflow_p);\n \tif (*non_constant_p)\n \t  return t;\n \tif (POINTER_TYPE_P (TREE_TYPE (t))\n@@ -3256,7 +3247,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t\t      (TREE_TYPE (t), TREE_TYPE (ctor)));\n \t  return cxx_eval_constant_expression\n \t    (ctx, ctor, addr,\n-\t     non_constant_p, overflow_p, NULL);\n+\t     non_constant_p, overflow_p);\n \t}\n       break;\n \n@@ -3333,7 +3324,7 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n     }\n \n   r = cxx_eval_constant_expression (&ctx, r,\n-\t\t\t\t    false, &non_constant_p, &overflow_p, NULL);\n+\t\t\t\t    false, &non_constant_p, &overflow_p);\n \n   verify_constant (r, allow_non_constant, &non_constant_p, &overflow_p);\n \n@@ -3410,7 +3401,7 @@ is_sub_constant_expr (tree t)\n   hash_map <tree, tree> map;\n   ctx.values = &map;\n   cxx_eval_constant_expression (&ctx, t, false, &non_constant_p,\n-\t\t\t\t&overflow_p, NULL);\n+\t\t\t\t&overflow_p);\n   return !non_constant_p && !overflow_p;\n }\n "}]}