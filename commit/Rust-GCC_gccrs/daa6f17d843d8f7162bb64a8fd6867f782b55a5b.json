{"sha": "daa6f17d843d8f7162bb64a8fd6867f782b55a5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGFhNmYxN2Q4NDNkOGY3MTYyYmI2NGE4ZmQ2ODY3Zjc4MmI1NWE1Yg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-11-12T19:03:37Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-11-12T19:03:37Z"}, "message": "(allocno_compare): Use `const void *' arguments.\n\nFrom-SVN: r13131", "tree": {"sha": "d40a1022ecd25effbf6a2f5f6dcadba1b8432eaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d40a1022ecd25effbf6a2f5f6dcadba1b8432eaf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/daa6f17d843d8f7162bb64a8fd6867f782b55a5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daa6f17d843d8f7162bb64a8fd6867f782b55a5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/daa6f17d843d8f7162bb64a8fd6867f782b55a5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daa6f17d843d8f7162bb64a8fd6867f782b55a5b/comments", "author": null, "committer": null, "parents": [{"sha": "c6d4074117c804c3a498100e9b32d5b368a2978e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6d4074117c804c3a498100e9b32d5b368a2978e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6d4074117c804c3a498100e9b32d5b368a2978e"}], "stats": {"total": 22, "additions": 12, "deletions": 10}, "files": [{"sha": "12088d880b988266d6c1b08a5df9517febf50457", "filename": "gcc/global.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daa6f17d843d8f7162bb64a8fd6867f782b55a5b/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daa6f17d843d8f7162bb64a8fd6867f782b55a5b/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=daa6f17d843d8f7162bb64a8fd6867f782b55a5b", "patch": "@@ -251,7 +251,7 @@ static int n_regs_set;\n \n static HARD_REG_SET eliminable_regset;\n \n-static int allocno_compare\tPROTO((int *, int *));\n+static int allocno_compare\tPROTO((const GENERIC_PTR, const GENERIC_PTR));\n static void global_conflicts\tPROTO((void));\n static void expand_preferences\tPROTO((void));\n static void prune_preferences\tPROTO((void));\n@@ -584,27 +584,29 @@ global_alloc (file)\n    Returns -1 (1) if *v1 should be allocated before (after) *v2.  */\n \n static int\n-allocno_compare (v1, v2)\n-     int *v1, *v2;\n+allocno_compare (v1p, v2p)\n+     const GENERIC_PTR v1p;\n+     const GENERIC_PTR v2p;\n {\n+  int v1 = *(int *)v1p, v2 = *(int *)v2p;\n   /* Note that the quotient will never be bigger than\n      the value of floor_log2 times the maximum number of\n      times a register can occur in one insn (surely less than 100).\n      Multiplying this by 10000 can't overflow.  */\n   register int pri1\n-    = (((double) (floor_log2 (allocno_n_refs[*v1]) * allocno_n_refs[*v1])\n-\t/ allocno_live_length[*v1])\n-       * 10000 * allocno_size[*v1]);\n+    = (((double) (floor_log2 (allocno_n_refs[v1]) * allocno_n_refs[v1])\n+\t/ allocno_live_length[v1])\n+       * 10000 * allocno_size[v1]);\n   register int pri2\n-    = (((double) (floor_log2 (allocno_n_refs[*v2]) * allocno_n_refs[*v2])\n-\t/ allocno_live_length[*v2])\n-       * 10000 * allocno_size[*v2]);\n+    = (((double) (floor_log2 (allocno_n_refs[v2]) * allocno_n_refs[v2])\n+\t/ allocno_live_length[v2])\n+       * 10000 * allocno_size[v2]);\n   if (pri2 - pri1)\n     return pri2 - pri1;\n \n   /* If regs are equally good, sort by allocno,\n      so that the results of qsort leave nothing to chance.  */\n-  return *v1 - *v2;\n+  return v1 - v2;\n }\n \f\n /* Scan the rtl code and record all conflicts and register preferences in the"}]}