{"sha": "d8e103f96ff66b964a5487c437600fdc759f4b07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDhlMTAzZjk2ZmY2NmI5NjRhNTQ4N2M0Mzc2MDBmZGM3NTlmNGIwNw==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2014-12-17T16:25:58Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2014-12-17T16:25:58Z"}, "message": "dwarf2out.c: do not short-circuit add_bound_info in array descr. lang-hook\n\ngcc/\n\t* dwarf2out.h (struct array_descr_info): Remove the base_decl field.\n\t* dwarf2out.c (enum dw_scalar_form): New.\n\t(struct loc_descr_context): New.\n\t(add_scalar_info): New.\n\t(add_bound_info): Add a context parameter.  Use add_scalar_info.\n\t(loc_list_from_tree): Add a context parameter.  Handle PLACEHOLDER_EXPR\n\tnodes for type-related expressions.  Likewise for base declarations.\n\t(loc_descriptor_from_tree): Add a context parameter.\n\t(subrange_type_die): Update calls to add_bound_info.\n\t(tls_mem_loc_descriptor): Likewise.\n\t(loc_list_for_address_of_addr_expr_of_indirect_ref): Add a context\n\tparameter.  Update calls to loc_list_from_tree.\n\t(add_subscript_info): Update calls to add_bound_info.\n\t(gen_array_type_die): Update calls to loc_list_from_tree and to\n\tadd_bound_info.\n\t(descr_info_loc): Remove.\n\t(add_descr_info_field): Remove.\n\t(gen_descr_array_type_die): Switch add_descr_info_field calls into\n\tadd_scalar_info/add_bound_info ones.\n\t(gen_subprogram_die): Update calls to loc_list_from_tree.\n\t(gen_variable_die): Likewise.\n\nFrom-SVN: r218827", "tree": {"sha": "794e19cefd43901817566278fd6d038be41a3b4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/794e19cefd43901817566278fd6d038be41a3b4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8e103f96ff66b964a5487c437600fdc759f4b07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8e103f96ff66b964a5487c437600fdc759f4b07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8e103f96ff66b964a5487c437600fdc759f4b07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8e103f96ff66b964a5487c437600fdc759f4b07/comments", "author": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f08649c02d8ca0b788e9d2663738e42744e6d10d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f08649c02d8ca0b788e9d2663738e42744e6d10d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f08649c02d8ca0b788e9d2663738e42744e6d10d"}], "stats": {"total": 599, "additions": 324, "deletions": 275}, "files": [{"sha": "b1b0b394f6bd854af552a1be6b490a9c3fa6021f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e103f96ff66b964a5487c437600fdc759f4b07/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e103f96ff66b964a5487c437600fdc759f4b07/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d8e103f96ff66b964a5487c437600fdc759f4b07", "patch": "@@ -1,3 +1,27 @@\n+2014-12-17  Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+\t* dwarf2out.h (struct array_descr_info): Remove the base_decl field.\n+\t* dwarf2out.c (enum dw_scalar_form): New.\n+\t(struct loc_descr_context): New.\n+\t(add_scalar_info): New.\n+\t(add_bound_info): Add a context parameter.  Use add_scalar_info.\n+\t(loc_list_from_tree): Add a context parameter.  Handle PLACEHOLDER_EXPR\n+\tnodes for type-related expressions.  Likewise for base declarations.\n+\t(loc_descriptor_from_tree): Add a context parameter.\n+\t(subrange_type_die): Update calls to add_bound_info.\n+\t(tls_mem_loc_descriptor): Likewise.\n+\t(loc_list_for_address_of_addr_expr_of_indirect_ref): Add a context\n+\tparameter.  Update calls to loc_list_from_tree.\n+\t(add_subscript_info): Update calls to add_bound_info.\n+\t(gen_array_type_die): Update calls to loc_list_from_tree and to\n+\tadd_bound_info.\n+\t(descr_info_loc): Remove.\n+\t(add_descr_info_field): Remove.\n+\t(gen_descr_array_type_die): Switch add_descr_info_field calls into\n+\tadd_scalar_info/add_bound_info ones.\n+\t(gen_subprogram_die): Update calls to loc_list_from_tree.\n+\t(gen_variable_die): Likewise.\n+\n 2014-12-17  Pierre-Marie de Rodat  <derodat@adacore.com>\n \n \t* dwarf2out.c (print_loc_descr): New."}, {"sha": "601be8532b2384a022da4b8e9b01c64af404ad4b", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 300, "deletions": 275, "changes": 575, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e103f96ff66b964a5487c437600fdc759f4b07/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e103f96ff66b964a5487c437600fdc759f4b07/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=d8e103f96ff66b964a5487c437600fdc759f4b07", "patch": "@@ -3029,6 +3029,15 @@ static bool frame_pointer_fb_offset_valid;\n \n static vec<dw_die_ref> base_types;\n \n+/* Flags to represent a set of attribute classes for attributes that represent\n+   a scalar value (bounds, pointers, ...).  */\n+enum dw_scalar_form\n+{\n+  dw_scalar_form_constant = 0x01,\n+  dw_scalar_form_exprloc = 0x02,\n+  dw_scalar_form_reference = 0x04\n+};\n+\n /* Forward declarations for functions defined in this file.  */\n \n static int is_pseudo_reg (const_rtx);\n@@ -3203,8 +3212,11 @@ static dw_loc_descr_ref concat_loc_descriptor (rtx, rtx,\n \t\t\t\t\t       enum var_init_status);\n static dw_loc_descr_ref loc_descriptor (rtx, machine_mode mode,\n \t\t\t\t\tenum var_init_status);\n-static dw_loc_list_ref loc_list_from_tree (tree, int);\n-static dw_loc_descr_ref loc_descriptor_from_tree (tree, int);\n+struct loc_descr_context;\n+static dw_loc_list_ref loc_list_from_tree (tree, int,\n+\t\t\t\t\t   const struct loc_descr_context *);\n+static dw_loc_descr_ref loc_descriptor_from_tree (tree, int,\n+\t\t\t\t\t\t  const struct loc_descr_context *);\n static HOST_WIDE_INT ceiling (HOST_WIDE_INT, unsigned int);\n static tree field_type (const_tree);\n static unsigned int simple_type_align_in_bits (const_tree);\n@@ -3226,7 +3238,10 @@ static bool tree_add_const_value_attribute_for_decl (dw_die_ref, tree);\n static void add_name_attribute (dw_die_ref, const char *);\n static void add_gnat_descriptive_type_attribute (dw_die_ref, tree, dw_die_ref);\n static void add_comp_dir_attribute (dw_die_ref);\n-static void add_bound_info (dw_die_ref, enum dwarf_attribute, tree);\n+static void add_scalar_info (dw_die_ref, enum dwarf_attribute, tree, int,\n+\t\t\t     const struct loc_descr_context *);\n+static void add_bound_info (dw_die_ref, enum dwarf_attribute, tree,\n+\t\t\t    const struct loc_descr_context *);\n static void add_subscript_info (dw_die_ref, tree, bool);\n static void add_byte_size_attribute (dw_die_ref, tree);\n static void add_bit_offset_attribute (dw_die_ref, tree);\n@@ -10556,9 +10571,9 @@ subrange_type_die (tree type, tree low, tree high, dw_die_ref context_die)\n     }\n \n   if (low)\n-    add_bound_info (subrange_die, DW_AT_lower_bound, low);\n+    add_bound_info (subrange_die, DW_AT_lower_bound, low, NULL);\n   if (high)\n-    add_bound_info (subrange_die, DW_AT_upper_bound, high);\n+    add_bound_info (subrange_die, DW_AT_upper_bound, high, NULL);\n \n   return subrange_die;\n }\n@@ -11539,7 +11554,7 @@ tls_mem_loc_descriptor (rtx mem)\n       || !DECL_THREAD_LOCAL_P (base))\n     return NULL;\n \n-  loc_result = loc_descriptor_from_tree (MEM_EXPR (mem), 1);\n+  loc_result = loc_descriptor_from_tree (MEM_EXPR (mem), 1, NULL);\n   if (loc_result == NULL)\n     return NULL;\n \n@@ -14277,10 +14292,13 @@ cst_pool_loc_descr (tree loc)\n \n /* Return dw_loc_list representing address of addr_expr LOC\n    by looking for inner INDIRECT_REF expression and turning\n-   it into simple arithmetics.  */\n+   it into simple arithmetics.\n+\n+   See loc_list_from_tree for the meaning of CONTEXT.  */\n \n static dw_loc_list_ref\n-loc_list_for_address_of_addr_expr_of_indirect_ref (tree loc, bool toplev)\n+loc_list_for_address_of_addr_expr_of_indirect_ref (tree loc, bool toplev,\n+\t\t\t\t\t\t   const loc_descr_context *context)\n {\n   tree obj, offset;\n   HOST_WIDE_INT bitsize, bitpos, bytepos;\n@@ -14304,18 +14322,19 @@ loc_list_for_address_of_addr_expr_of_indirect_ref (tree loc, bool toplev)\n       return 0;\n     }\n   if (!offset && !bitpos)\n-    list_ret = loc_list_from_tree (TREE_OPERAND (obj, 0), toplev ? 2 : 1);\n+    list_ret = loc_list_from_tree (TREE_OPERAND (obj, 0), toplev ? 2 : 1,\n+\t\t\t\t   context);\n   else if (toplev\n \t   && int_size_in_bytes (TREE_TYPE (loc)) <= DWARF2_ADDR_SIZE\n \t   && (dwarf_version >= 4 || !dwarf_strict))\n     {\n-      list_ret = loc_list_from_tree (TREE_OPERAND (obj, 0), 0);\n+      list_ret = loc_list_from_tree (TREE_OPERAND (obj, 0), 0, context);\n       if (!list_ret)\n \treturn 0;\n       if (offset)\n \t{\n \t  /* Variable offset.  */\n-\t  list_ret1 = loc_list_from_tree (offset, 0);\n+\t  list_ret1 = loc_list_from_tree (offset, 0, context);\n \t  if (list_ret1 == 0)\n \t    return 0;\n \t  add_loc_list (&list_ret, list_ret1);\n@@ -14338,15 +14357,36 @@ loc_list_for_address_of_addr_expr_of_indirect_ref (tree loc, bool toplev)\n }\n \n \n+/* Helper structure for location descriptions generation.  */\n+struct loc_descr_context\n+{\n+  /* The type that is implicitly referenced by DW_OP_push_object_address, or\n+     NULL_TREE if DW_OP_push_object_address in invalid for this location\n+     description.  This is used when processing PLACEHOLDER_EXPR nodes.  */\n+  tree context_type;\n+  /* The ..._DECL node that should be translated as a\n+     DW_OP_push_object_address operation.  */\n+  tree base_decl;\n+};\n+\n /* Generate Dwarf location list representing LOC.\n    If WANT_ADDRESS is false, expression computing LOC will be computed\n    If WANT_ADDRESS is 1, expression computing address of LOC will be returned\n    if WANT_ADDRESS is 2, expression computing address useable in location\n      will be returned (i.e. DW_OP_reg can be used\n-     to refer to register values).  */\n+     to refer to register values).\n+\n+   CONTEXT provides information to customize the location descriptions\n+   generation.  Its context_type field specifies what type is implicitly\n+   referenced by DW_OP_push_object_address.  If it is NULL_TREE, this operation\n+   will not be generated.\n+\n+   If CONTEXT is NULL, the behavior is the same as if both context_type and\n+   base_decl fields were NULL_TREE.  */\n \n static dw_loc_list_ref\n-loc_list_from_tree (tree loc, int want_address)\n+loc_list_from_tree (tree loc, int want_address,\n+\t\t    const struct loc_descr_context *context)\n {\n   dw_loc_descr_ref ret = NULL, ret1 = NULL;\n   dw_loc_list_ref list_ret = NULL, list_ret1 = NULL;\n@@ -14357,6 +14397,17 @@ loc_list_from_tree (tree loc, int want_address)\n      extending the values properly.  Hopefully this won't be a real\n      problem...  */\n \n+  if (context != NULL\n+      && context->base_decl == loc\n+      && want_address == 0)\n+    {\n+      if (dwarf_version >= 3 || !dwarf_strict)\n+\treturn new_loc_list (new_loc_descr (DW_OP_push_object_address, 0, 0),\n+\t\t\t     NULL, NULL, NULL);\n+      else\n+\treturn NULL;\n+    }\n+\n   switch (TREE_CODE (loc))\n     {\n     case ERROR_MARK:\n@@ -14365,11 +14416,26 @@ loc_list_from_tree (tree loc, int want_address)\n \n     case PLACEHOLDER_EXPR:\n       /* This case involves extracting fields from an object to determine the\n-\t position of other fields.  We don't try to encode this here.  The\n-\t only user of this is Ada, which encodes the needed information using\n-\t the names of types.  */\n-      expansion_failed (loc, NULL_RTX, \"PLACEHOLDER_EXPR\");\n-      return 0;\n+\t position of other fields. It is supposed to appear only as the first\n+         operand of COMPONENT_REF nodes and to reference precisely the type\n+         that the context allows.  */\n+      if (context != NULL\n+          && TREE_TYPE (loc) == context->context_type\n+\t  && want_address >= 1)\n+\t{\n+\t  if (dwarf_version >= 3 || !dwarf_strict)\n+\t    {\n+\t      ret = new_loc_descr (DW_OP_push_object_address, 0, 0);\n+\t      have_address = 1;\n+\t      break;\n+\t    }\n+\t  else\n+\t    return NULL;\n+\t}\n+      else\n+\texpansion_failed (loc, NULL_RTX,\n+\t\t\t  \"PLACEHOLDER_EXPR for an unexpected type\");\n+      break;\n \n     case CALL_EXPR:\n       expansion_failed (loc, NULL_RTX, \"CALL_EXPR\");\n@@ -14390,7 +14456,7 @@ loc_list_from_tree (tree loc, int want_address)\n       if (want_address)\n \t{\n \t  list_ret = loc_list_for_address_of_addr_expr_of_indirect_ref\n-\t\t       (loc, want_address == 2);\n+\t\t       (loc, want_address == 2, context);\n \t  if (list_ret)\n \t    have_address = 1;\n \t  else if (decl_address_ip_invariant_p (TREE_OPERAND (loc, 0))\n@@ -14399,7 +14465,7 @@ loc_list_from_tree (tree loc, int want_address)\n \t}\n         /* Otherwise, process the argument and look for the address.  */\n       if (!list_ret && !ret)\n-        list_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 1);\n+        list_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 1, context);\n       else\n \t{\n \t  if (want_address)\n@@ -14469,7 +14535,7 @@ loc_list_from_tree (tree loc, int want_address)\n     case RESULT_DECL:\n       if (DECL_HAS_VALUE_EXPR_P (loc))\n \treturn loc_list_from_tree (DECL_VALUE_EXPR (loc),\n-\t\t\t\t   want_address);\n+\t\t\t\t   want_address, context);\n       /* FALLTHRU */\n \n     case FUNCTION_DECL:\n@@ -14543,7 +14609,7 @@ loc_list_from_tree (tree loc, int want_address)\n \t}\n       /* Fallthru.  */\n     case INDIRECT_REF:\n-      list_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 0);\n+      list_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 0, context);\n       have_address = 1;\n       break;\n \n@@ -14552,13 +14618,13 @@ loc_list_from_tree (tree loc, int want_address)\n       return NULL;\n \n     case COMPOUND_EXPR:\n-      return loc_list_from_tree (TREE_OPERAND (loc, 1), want_address);\n+      return loc_list_from_tree (TREE_OPERAND (loc, 1), want_address, context);\n \n     CASE_CONVERT:\n     case VIEW_CONVERT_EXPR:\n     case SAVE_EXPR:\n     case MODIFY_EXPR:\n-      return loc_list_from_tree (TREE_OPERAND (loc, 0), want_address);\n+      return loc_list_from_tree (TREE_OPERAND (loc, 0), want_address, context);\n \n     case COMPONENT_REF:\n     case BIT_FIELD_REF:\n@@ -14579,7 +14645,8 @@ loc_list_from_tree (tree loc, int want_address)\n \n \tlist_ret = loc_list_from_tree (obj,\n \t\t\t\t       want_address == 2\n-\t\t\t\t       && !bitpos && !offset ? 2 : 1);\n+\t\t\t\t       && !bitpos && !offset ? 2 : 1,\n+\t\t\t\t       context);\n \t/* TODO: We can extract value of the small expression via shifting even\n \t   for nonzero bitpos.  */\n \tif (list_ret == 0)\n@@ -14594,7 +14661,7 @@ loc_list_from_tree (tree loc, int want_address)\n \tif (offset != NULL_TREE)\n \t  {\n \t    /* Variable offset.  */\n-\t    list_ret1 = loc_list_from_tree (offset, 0);\n+\t    list_ret1 = loc_list_from_tree (offset, 0, context);\n \t    if (list_ret1 == 0)\n \t      return 0;\n \t    add_loc_list (&list_ret, list_ret1);\n@@ -14684,8 +14751,8 @@ loc_list_from_tree (tree loc, int want_address)\n \t  op = DW_OP_mod;\n \t  goto do_binop;\n \t}\n-      list_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 0);\n-      list_ret1 = loc_list_from_tree (TREE_OPERAND (loc, 1), 0);\n+      list_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 0, context);\n+      list_ret1 = loc_list_from_tree (TREE_OPERAND (loc, 1), 0, context);\n       if (list_ret == 0 || list_ret1 == 0)\n \treturn 0;\n \n@@ -14716,7 +14783,7 @@ loc_list_from_tree (tree loc, int want_address)\n     do_plus:\n       if (tree_fits_shwi_p (TREE_OPERAND (loc, 1)))\n \t{\n-\t  list_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 0);\n+\t  list_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 0, context);\n \t  if (list_ret == 0)\n \t    return 0;\n \n@@ -14764,8 +14831,8 @@ loc_list_from_tree (tree loc, int want_address)\n       goto do_binop;\n \n     do_binop:\n-      list_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 0);\n-      list_ret1 = loc_list_from_tree (TREE_OPERAND (loc, 1), 0);\n+      list_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 0, context);\n+      list_ret1 = loc_list_from_tree (TREE_OPERAND (loc, 1), 0, context);\n       if (list_ret == 0 || list_ret1 == 0)\n \treturn 0;\n \n@@ -14789,7 +14856,7 @@ loc_list_from_tree (tree loc, int want_address)\n       goto do_unop;\n \n     do_unop:\n-      list_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 0);\n+      list_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 0, context);\n       if (list_ret == 0)\n \treturn 0;\n \n@@ -14813,12 +14880,12 @@ loc_list_from_tree (tree loc, int want_address)\n     case COND_EXPR:\n       {\n \tdw_loc_descr_ref lhs\n-\t  = loc_descriptor_from_tree (TREE_OPERAND (loc, 1), 0);\n+\t  = loc_descriptor_from_tree (TREE_OPERAND (loc, 1), 0, context);\n \tdw_loc_list_ref rhs\n-\t  = loc_list_from_tree (TREE_OPERAND (loc, 2), 0);\n+\t  = loc_list_from_tree (TREE_OPERAND (loc, 2), 0, context);\n \tdw_loc_descr_ref bra_node, jump_node, tmp;\n \n-\tlist_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 0);\n+\tlist_ret = loc_list_from_tree (TREE_OPERAND (loc, 0), 0, context);\n \tif (list_ret == 0 || lhs == 0 || rhs == 0)\n \t  return 0;\n \n@@ -14924,9 +14991,10 @@ loc_list_from_tree (tree loc, int want_address)\n \n /* Same as above but return only single location expression.  */\n static dw_loc_descr_ref\n-loc_descriptor_from_tree (tree loc, int want_address)\n+loc_descriptor_from_tree (tree loc, int want_address,\n+\t\t\t  const struct loc_descr_context *context)\n {\n-  dw_loc_list_ref ret = loc_list_from_tree (loc, want_address);\n+  dw_loc_list_ref ret = loc_list_from_tree (loc, want_address, context);\n   if (!ret)\n     return NULL;\n   if (ret->dw_loc_next)\n@@ -15984,7 +16052,8 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl, bool cache_p,\n     }\n   if (list == NULL)\n     {\n-      list = loc_list_from_tree (decl, decl_by_reference_p (decl) ? 0 : 2);\n+      list = loc_list_from_tree (decl, decl_by_reference_p (decl) ? 0 : 2,\n+\t\t\t\t NULL);\n       /* It is usually worth caching this result if the decl is from\n \t BLOCK_NONLOCALIZED_VARS and if the list has at least two elements.  */\n       if (cache_p && list && list->dw_loc_next)\n@@ -16478,6 +16547,143 @@ add_comp_dir_attribute (dw_die_ref die)\n     add_AT_string (die, DW_AT_comp_dir, wd);\n }\n \n+/* Given a tree node VALUE describing a scalar attribute ATTR (i.e. a bound, a\n+   pointer computation, ...), output a representation for that bound according\n+   to the accepted FORMS (see enum dw_scalar_form) and add it to DIE.  See\n+   loc_list_from_tree for the meaning of CONTEXT.  */\n+\n+static void\n+add_scalar_info (dw_die_ref die, enum dwarf_attribute attr, tree value,\n+\t\t int forms, const struct loc_descr_context *context)\n+{\n+  dw_die_ref ctx, decl_die;\n+  dw_loc_list_ref list;\n+\n+  bool strip_conversions = true;\n+\n+  while (strip_conversions)\n+    switch (TREE_CODE (value))\n+      {\n+      case ERROR_MARK:\n+      case SAVE_EXPR:\n+\treturn;\n+\n+      CASE_CONVERT:\n+      case VIEW_CONVERT_EXPR:\n+\tvalue = TREE_OPERAND (value, 0);\n+\tbreak;\n+\n+      default:\n+\tstrip_conversions = false;\n+\tbreak;\n+      }\n+\n+  /* If possible and permitted, output the attribute as a constant.  */\n+  if ((forms & dw_scalar_form_constant) != 0\n+      && TREE_CODE (value) == INTEGER_CST)\n+    {\n+      unsigned int prec = simple_type_size_in_bits (TREE_TYPE (value));\n+\n+      /* If HOST_WIDE_INT is big enough then represent the bound as\n+\t a constant value.  We need to choose a form based on\n+\t whether the type is signed or unsigned.  We cannot just\n+\t call add_AT_unsigned if the value itself is positive\n+\t (add_AT_unsigned might add the unsigned value encoded as\n+\t DW_FORM_data[1248]).  Some DWARF consumers will lookup the\n+\t bounds type and then sign extend any unsigned values found\n+\t for signed types.  This is needed only for\n+\t DW_AT_{lower,upper}_bound, since for most other attributes,\n+\t consumers will treat DW_FORM_data[1248] as unsigned values,\n+\t regardless of the underlying type.  */\n+      if (prec <= HOST_BITS_PER_WIDE_INT\n+\t  || tree_fits_uhwi_p (value))\n+\t{\n+\t  if (TYPE_UNSIGNED (TREE_TYPE (value)))\n+\t    add_AT_unsigned (die, attr, TREE_INT_CST_LOW (value));\n+\t  else\n+\t    add_AT_int (die, attr, TREE_INT_CST_LOW (value));\n+\t}\n+      else\n+\t/* Otherwise represent the bound as an unsigned value with\n+\t   the precision of its type.  The precision and signedness\n+\t   of the type will be necessary to re-interpret it\n+\t   unambiguously.  */\n+\tadd_AT_wide (die, attr, value);\n+      return;\n+    }\n+\n+  /* Otherwise, if it's possible and permitted too, output a reference to\n+     another DIE.  */\n+  if ((forms & dw_scalar_form_reference) != 0)\n+    {\n+      tree decl = NULL_TREE;\n+\n+      /* Some type attributes reference an outer type.  For instance, the upper\n+\t bound of an array may reference an embedding record (this happens in\n+\t Ada).  */\n+      if (TREE_CODE (value) == COMPONENT_REF\n+\t  && TREE_CODE (TREE_OPERAND (value, 0)) == PLACEHOLDER_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (value, 1)) == FIELD_DECL)\n+\tdecl = TREE_OPERAND (value, 1);\n+\n+      else if (TREE_CODE (value) == VAR_DECL\n+\t       || TREE_CODE (value) == PARM_DECL\n+\t       || TREE_CODE (value) == RESULT_DECL)\n+\tdecl = value;\n+\n+      if (decl != NULL_TREE)\n+\t{\n+\t  dw_die_ref decl_die = lookup_decl_die (decl);\n+\n+\t  /* ??? Can this happen, or should the variable have been bound\n+\t     first?  Probably it can, since I imagine that we try to create\n+\t     the types of parameters in the order in which they exist in\n+\t     the list, and won't have created a forward reference to a\n+\t     later parameter.  */\n+\t  if (decl_die != NULL)\n+\t    {\n+\t      add_AT_die_ref (die, attr, decl_die);\n+\t      return;\n+\t    }\n+\t}\n+    }\n+\n+  /* Last chance: try to create a stack operation procedure to evaluate the\n+     value.  Do nothing if even that is not possible or permitted.  */\n+  if ((forms & dw_scalar_form_exprloc) == 0)\n+    return;\n+\n+  list = loc_list_from_tree (value, 2, context);\n+  if (list == NULL || single_element_loc_list_p (list))\n+    {\n+      /* If this attribute is not a reference nor constant, it is\n+\t a DWARF expression rather than location description.  For that\n+\t loc_list_from_tree (value, 0, &context) is needed.  */\n+      dw_loc_list_ref list2 = loc_list_from_tree (value, 0, context);\n+      if (list2 && single_element_loc_list_p (list2))\n+\t{\n+\t  add_AT_loc (die, attr, list2->expr);\n+\t  return;\n+\t}\n+    }\n+\n+  /* If that failed to give a single element location list, fall back to\n+     outputting this as a reference... still if permitted.  */\n+  if (list == NULL || (forms & dw_scalar_form_reference) == 0)\n+    return;\n+\n+  if (current_function_decl == 0)\n+    ctx = comp_unit_die ();\n+  else\n+    ctx = lookup_decl_die (current_function_decl);\n+\n+  decl_die = new_die (DW_TAG_variable, ctx, value);\n+  add_AT_flag (decl_die, DW_AT_artificial, 1);\n+  add_type_attribute (decl_die, TREE_TYPE (value), TYPE_QUAL_CONST, ctx);\n+  add_AT_location_description (decl_die, DW_AT_location, list);\n+  add_AT_die_ref (die, attr, decl_die);\n+}\n+\n /* Return the default for DW_AT_lower_bound, or -1 if there is not any\n    default.  */\n \n@@ -16522,121 +16728,41 @@ lower_bound_default (void)\n    a representation for that bound.  */\n \n static void\n-add_bound_info (dw_die_ref subrange_die, enum dwarf_attribute bound_attr, tree bound)\n+add_bound_info (dw_die_ref subrange_die, enum dwarf_attribute bound_attr,\n+\t\ttree bound, const struct loc_descr_context *context)\n {\n-  switch (TREE_CODE (bound))\n-    {\n-    case ERROR_MARK:\n-      return;\n+  int dflt;\n \n-    /* All fixed-bounds are represented by INTEGER_CST nodes.  */\n-    case INTEGER_CST:\n+  while (1)\n+    switch (TREE_CODE (bound))\n       {\n-\tunsigned int prec = simple_type_size_in_bits (TREE_TYPE (bound));\n-\tint dflt;\n+      /* Strip all conversions.  */\n+      CASE_CONVERT:\n+      case VIEW_CONVERT_EXPR:\n+\tbound = TREE_OPERAND (bound, 0);\n+\tbreak;\n \n-\t/* Use the default if possible.  */\n+      /* All fixed-bounds are represented by INTEGER_CST nodes.  Lower bounds\n+\t are even omitted when they are the default.  */\n+      case INTEGER_CST:\n+\t/* If the value for this bound is the default one, we can even omit the\n+\t   attribute.  */\n \tif (bound_attr == DW_AT_lower_bound\n \t    && tree_fits_shwi_p (bound)\n \t    && (dflt = lower_bound_default ()) != -1\n \t    && tree_to_shwi (bound) == dflt)\n-\t  ;\n-\n-\t/* If HOST_WIDE_INT is big enough then represent the bound as\n-\t   a constant value.  We need to choose a form based on\n-\t   whether the type is signed or unsigned.  We cannot just\n-\t   call add_AT_unsigned if the value itself is positive\n-\t   (add_AT_unsigned might add the unsigned value encoded as\n-\t   DW_FORM_data[1248]).  Some DWARF consumers will lookup the\n-\t   bounds type and then sign extend any unsigned values found\n-\t   for signed types.  This is needed only for\n-\t   DW_AT_{lower,upper}_bound, since for most other attributes,\n-\t   consumers will treat DW_FORM_data[1248] as unsigned values,\n-\t   regardless of the underlying type.  */\n-\telse if (prec <= HOST_BITS_PER_WIDE_INT\n-\t\t || tree_fits_uhwi_p (bound))\n-\t  {\n-\t    if (TYPE_UNSIGNED (TREE_TYPE (bound)))\n-\t      add_AT_unsigned (subrange_die, bound_attr,\n-\t\t\t       TREE_INT_CST_LOW (bound));\n-\t    else\n-\t      add_AT_int (subrange_die, bound_attr, TREE_INT_CST_LOW (bound));\n-\t  }\n-\telse\n-\t  /* Otherwise represent the bound as an unsigned value with\n-\t     the precision of its type.  The precision and signedness\n-\t     of the type will be necessary to re-interpret it\n-\t     unambiguously.  */\n-\t  add_AT_wide (subrange_die, bound_attr, bound);\n-      }\n-      break;\n-\n-    CASE_CONVERT:\n-    case VIEW_CONVERT_EXPR:\n-      add_bound_info (subrange_die, bound_attr, TREE_OPERAND (bound, 0));\n-      break;\n-\n-    case SAVE_EXPR:\n-      break;\n-\n-    case VAR_DECL:\n-    case PARM_DECL:\n-    case RESULT_DECL:\n-      {\n-\tdw_die_ref decl_die = lookup_decl_die (bound);\n-\n-\t/* ??? Can this happen, or should the variable have been bound\n-\t   first?  Probably it can, since I imagine that we try to create\n-\t   the types of parameters in the order in which they exist in\n-\t   the list, and won't have created a forward reference to a\n-\t   later parameter.  */\n-\tif (decl_die != NULL)\n-\t  {\n-\t    add_AT_die_ref (subrange_die, bound_attr, decl_die);\n-\t    break;\n-\t  }\n-      }\n-      /* FALLTHRU */\n-\n-    default:\n-      {\n-\t/* Otherwise try to create a stack operation procedure to\n-\t   evaluate the value of the array bound.  */\n-\n-\tdw_die_ref ctx, decl_die;\n-\tdw_loc_list_ref list;\n-\n-\tlist = loc_list_from_tree (bound, 2);\n-\tif (list == NULL || single_element_loc_list_p (list))\n-\t  {\n-\t    /* If DW_AT_*bound is not a reference nor constant, it is\n-\t       a DWARF expression rather than location description.\n-\t       For that loc_list_from_tree (bound, 0) is needed.\n-\t       If that fails to give a single element list,\n-\t       fall back to outputting this as a reference anyway.  */\n-\t    dw_loc_list_ref list2 = loc_list_from_tree (bound, 0);\n-\t    if (list2 && single_element_loc_list_p (list2))\n-\t      {\n-\t\tadd_AT_loc (subrange_die, bound_attr, list2->expr);\n-\t\tbreak;\n-\t      }\n-\t  }\n-\tif (list == NULL)\n-\t  break;\n+\t  return;\n \n-\tif (current_function_decl == 0)\n-\t  ctx = comp_unit_die ();\n-\telse\n-\t  ctx = lookup_decl_die (current_function_decl);\n+\t/* FALLTHRU */\n \n-\tdecl_die = new_die (DW_TAG_variable, ctx, bound);\n-\tadd_AT_flag (decl_die, DW_AT_artificial, 1);\n-\tadd_type_attribute (decl_die, TREE_TYPE (bound), TYPE_QUAL_CONST, ctx);\n-\tadd_AT_location_description (decl_die, DW_AT_location, list);\n-\tadd_AT_die_ref (subrange_die, bound_attr, decl_die);\n-\tbreak;\n+      default:\n+\tadd_scalar_info (subrange_die, bound_attr, bound,\n+\t\t\t dw_scalar_form_constant\n+\t\t\t | dw_scalar_form_exprloc\n+\t\t\t | dw_scalar_form_reference,\n+\t\t\t context);\n+\treturn;\n       }\n-    }\n }\n \n /* Add subscript info to TYPE_DIE, describing an array TYPE, collapsing\n@@ -16693,9 +16819,9 @@ add_subscript_info (dw_die_ref type_die, tree type, bool collapse_p)\n \t     to produce useful results, go ahead and output the lower\n \t     bound solo, and hope the debugger can cope.  */\n \n-\t  add_bound_info (subrange_die, DW_AT_lower_bound, lower);\n+\t  add_bound_info (subrange_die, DW_AT_lower_bound, lower, NULL);\n \t  if (upper)\n-\t    add_bound_info (subrange_die, DW_AT_upper_bound, upper);\n+\t    add_bound_info (subrange_die, DW_AT_upper_bound, upper, NULL);\n \t}\n \n       /* Otherwise we have an array type with an unspecified length.  The\n@@ -17364,7 +17490,7 @@ gen_array_type_die (tree type, dw_die_ref context_die)\n \t       && DECL_P (TYPE_MAX_VALUE (TYPE_DOMAIN (type))))\n \t{\n \t  tree szdecl = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n-\t  dw_loc_list_ref loc = loc_list_from_tree (szdecl, 2);\n+\t  dw_loc_list_ref loc = loc_list_from_tree (szdecl, 2, NULL);\n \n \t  size = int_size_in_bytes (TREE_TYPE (szdecl));\n \t  if (loc && size > 0)\n@@ -17406,9 +17532,9 @@ gen_array_type_die (tree type, dw_die_ref context_die)\n     {\n       /* For VECTOR_TYPEs we use an array die with appropriate bounds.  */\n       dw_die_ref subrange_die = new_die (DW_TAG_subrange_type, array_die, NULL);\n-      add_bound_info (subrange_die, DW_AT_lower_bound, size_zero_node);\n+      add_bound_info (subrange_die, DW_AT_lower_bound, size_zero_node, NULL);\n       add_bound_info (subrange_die, DW_AT_upper_bound,\n-\t\t      size_int (TYPE_VECTOR_SUBPARTS (type) - 1));\n+\t\t      size_int (TYPE_VECTOR_SUBPARTS (type) - 1), NULL);\n     }\n   else\n     add_subscript_info (array_die, type, collapse_nested_arrays);\n@@ -17434,99 +17560,6 @@ gen_array_type_die (tree type, dw_die_ref context_die)\n     add_pubtype (type, array_die);\n }\n \n-static dw_loc_descr_ref\n-descr_info_loc (tree val, tree base_decl)\n-{\n-  HOST_WIDE_INT size;\n-  dw_loc_descr_ref loc, loc2;\n-  enum dwarf_location_atom op;\n-\n-  if (val == base_decl)\n-    return new_loc_descr (DW_OP_push_object_address, 0, 0);\n-\n-  switch (TREE_CODE (val))\n-    {\n-    CASE_CONVERT:\n-      return descr_info_loc (TREE_OPERAND (val, 0), base_decl);\n-    case VAR_DECL:\n-      return loc_descriptor_from_tree (val, 0);\n-    case INTEGER_CST:\n-      if (tree_fits_shwi_p (val))\n-\treturn int_loc_descriptor (tree_to_shwi (val));\n-      break;\n-    case INDIRECT_REF:\n-      size = int_size_in_bytes (TREE_TYPE (val));\n-      if (size < 0)\n-\tbreak;\n-      loc = descr_info_loc (TREE_OPERAND (val, 0), base_decl);\n-      if (!loc)\n-\tbreak;\n-      if (size == DWARF2_ADDR_SIZE)\n-\tadd_loc_descr (&loc, new_loc_descr (DW_OP_deref, 0, 0));\n-      else\n-\tadd_loc_descr (&loc, new_loc_descr (DW_OP_deref_size, size, 0));\n-      return loc;\n-    case POINTER_PLUS_EXPR:\n-    case PLUS_EXPR:\n-      if (tree_fits_uhwi_p (TREE_OPERAND (val, 1))\n-\t  && tree_to_uhwi (TREE_OPERAND (val, 1)) < 16384)\n-\t{\n-\t  loc = descr_info_loc (TREE_OPERAND (val, 0), base_decl);\n-\t  if (!loc)\n-\t    break;\n-\t  loc_descr_plus_const (&loc, tree_to_shwi (TREE_OPERAND (val, 1)));\n-\t}\n-      else\n-\t{\n-\t  op = DW_OP_plus;\n-\tdo_binop:\n-\t  loc = descr_info_loc (TREE_OPERAND (val, 0), base_decl);\n-\t  if (!loc)\n-\t    break;\n-\t  loc2 = descr_info_loc (TREE_OPERAND (val, 1), base_decl);\n-\t  if (!loc2)\n-\t    break;\n-\t  add_loc_descr (&loc, loc2);\n-\t  add_loc_descr (&loc2, new_loc_descr (op, 0, 0));\n-\t}\n-      return loc;\n-    case MINUS_EXPR:\n-      op = DW_OP_minus;\n-      goto do_binop;\n-    case MULT_EXPR:\n-      op = DW_OP_mul;\n-      goto do_binop;\n-    case EQ_EXPR:\n-      op = DW_OP_eq;\n-      goto do_binop;\n-    case NE_EXPR:\n-      op = DW_OP_ne;\n-      goto do_binop;\n-    default:\n-      break;\n-    }\n-  return NULL;\n-}\n-\n-static void\n-add_descr_info_field (dw_die_ref die, enum dwarf_attribute attr,\n-\t\t      tree val, tree base_decl)\n-{\n-  dw_loc_descr_ref loc;\n-\n-  if (tree_fits_shwi_p (val))\n-    {\n-      add_AT_unsigned (die, attr, tree_to_shwi (val));\n-      return;\n-    }\n-\n-  loc = descr_info_loc (val, base_decl);\n-  if (!loc)\n-    return;\n-\n-  add_AT_loc (die, attr, loc);\n-}\n-\n /* This routine generates DIE for array with hidden descriptor, details\n    are filled into *info by a langhook.  */\n \n@@ -17536,6 +17569,7 @@ gen_descr_array_type_die (tree type, struct array_descr_info *info,\n {\n   const dw_die_ref scope_die = scope_die_for (type, context_die);\n   const dw_die_ref array_die = new_die (DW_TAG_array_type, scope_die, type);\n+  const struct loc_descr_context context = { type, info->base_decl };\n   int dim;\n \n   add_name_attribute (array_die, type_tag (type));\n@@ -17557,15 +17591,18 @@ gen_descr_array_type_die (tree type, struct array_descr_info *info,\n   if (dwarf_version >= 3 || !dwarf_strict)\n     {\n       if (info->data_location)\n-\tadd_descr_info_field (array_die, DW_AT_data_location,\n-\t\t\t      info->data_location,\n-\t\t\t      info->base_decl);\n+\tadd_scalar_info (array_die, DW_AT_data_location, info->data_location,\n+\t\t\t dw_scalar_form_exprloc, &context);\n       if (info->associated)\n-\tadd_descr_info_field (array_die, DW_AT_associated, info->associated,\n-\t\t\t      info->base_decl);\n+\tadd_scalar_info (array_die, DW_AT_associated, info->associated,\n+\t\t\t dw_scalar_form_constant\n+\t\t\t | dw_scalar_form_exprloc\n+\t\t\t | dw_scalar_form_reference, &context);\n       if (info->allocated)\n-\tadd_descr_info_field (array_die, DW_AT_allocated, info->allocated,\n-\t\t\t      info->base_decl);\n+\tadd_scalar_info (array_die, DW_AT_allocated, info->allocated,\n+\t\t\t dw_scalar_form_constant\n+\t\t\t | dw_scalar_form_exprloc\n+\t\t\t | dw_scalar_form_reference, &context);\n     }\n \n   add_gnat_descriptive_type_attribute (array_die, type, context_die);\n@@ -17580,30 +17617,18 @@ gen_descr_array_type_die (tree type, struct array_descr_info *info,\n \t\t\t    info->dimen[dim].bounds_type, 0,\n \t\t\t    context_die);\n       if (info->dimen[dim].lower_bound)\n-\t{\n-\t  /* If it is the default value, omit it.  */\n-\t  int dflt;\n-\n-\t  if (tree_fits_shwi_p (info->dimen[dim].lower_bound)\n-\t      && (dflt = lower_bound_default ()) != -1\n-\t      && tree_to_shwi (info->dimen[dim].lower_bound) == dflt)\n-\t    ;\n-\t  else\n-\t    add_descr_info_field (subrange_die, DW_AT_lower_bound,\n-\t\t\t\t  info->dimen[dim].lower_bound,\n-\t\t\t\t  info->base_decl);\n-\t}\n+\tadd_bound_info (subrange_die, DW_AT_lower_bound,\n+\t\t\tinfo->dimen[dim].lower_bound, &context);\n       if (info->dimen[dim].upper_bound)\n-\tadd_descr_info_field (subrange_die, DW_AT_upper_bound,\n-\t\t\t      info->dimen[dim].upper_bound,\n-\t\t\t      info->base_decl);\n-      if (dwarf_version >= 3 || !dwarf_strict)\n-\t{\n-\t  if (info->dimen[dim].stride)\n-\t    add_descr_info_field (subrange_die, DW_AT_byte_stride,\n-\t\t\t\t  info->dimen[dim].stride,\n-\t\t\t\t  info->base_decl);\n-\t}\n+\tadd_bound_info (subrange_die, DW_AT_upper_bound,\n+\t\t\tinfo->dimen[dim].upper_bound, &context);\n+      if ((dwarf_version >= 3 || !dwarf_strict) && info->dimen[dim].stride)\n+\tadd_scalar_info (subrange_die, DW_AT_byte_stride,\n+\t\t\t info->dimen[dim].stride,\n+\t\t\t dw_scalar_form_constant\n+\t\t\t | dw_scalar_form_exprloc\n+\t\t\t | dw_scalar_form_reference,\n+\t\t\t &context);\n     }\n \n   gen_type_die (info->element_type, context_die);\n@@ -18670,7 +18695,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \n       if (fun->static_chain_decl)\n \tadd_AT_location_description (subr_die, DW_AT_static_link,\n-\t\t loc_list_from_tree (fun->static_chain_decl, 2));\n+\t\t loc_list_from_tree (fun->static_chain_decl, 2, NULL));\n     }\n \n   /* Generate child dies for template paramaters.  */\n@@ -18999,7 +19024,7 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n \t{\n \t  if (get_AT (var_die, DW_AT_location) == NULL)\n \t    {\n-\t      loc = loc_list_from_tree (com_decl, off ? 1 : 2);\n+\t      loc = loc_list_from_tree (com_decl, off ? 1 : 2, NULL);\n \t      if (loc)\n \t\t{\n \t\t  if (off)\n@@ -19031,7 +19056,7 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n       com_die_arg.decl_id = DECL_UID (com_decl);\n       com_die_arg.die_parent = context_die;\n       com_die = common_block_die_table->find (&com_die_arg);\n-      loc = loc_list_from_tree (com_decl, 2);\n+      loc = loc_list_from_tree (com_decl, 2, NULL);\n       if (com_die == NULL)\n \t{\n \t  const char *cnam\n@@ -19045,7 +19070,7 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n \t      add_AT_location_description (com_die, DW_AT_location, loc);\n \t      /* Avoid sharing the same loc descriptor between\n \t\t DW_TAG_common_block and DW_TAG_variable.  */\n-\t      loc = loc_list_from_tree (com_decl, 2);\n+\t      loc = loc_list_from_tree (com_decl, 2, NULL);\n \t    }\n           else if (DECL_EXTERNAL (decl))\n \t    add_AT_flag (com_die, DW_AT_declaration, 1);\n@@ -19058,7 +19083,7 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n       else if (get_AT (com_die, DW_AT_location) == NULL && loc)\n \t{\n \t  add_AT_location_description (com_die, DW_AT_location, loc);\n-\t  loc = loc_list_from_tree (com_decl, 2);\n+\t  loc = loc_list_from_tree (com_decl, 2, NULL);\n \t  remove_AT (com_die, DW_AT_declaration);\n \t}\n       var_die = new_die (DW_TAG_variable, com_die, decl);"}]}