{"sha": "57d75eebe2eb48709fd9086236bb0757778ad617", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTdkNzVlZWJlMmViNDg3MDlmZDkwODYyMzZiYjA3NTc3NzhhZDYxNw==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-12-21T11:24:27Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-12-21T11:24:27Z"}, "message": "In libobjc/: 2010-12-21 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn libobjc/:\n2010-12-21  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* hash.c: Tidied up comments and indentation.  No code changes.\n\nFrom-SVN: r168110", "tree": {"sha": "2c8c83f8cc423f63fbb9207dea0fb297f26faaac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c8c83f8cc423f63fbb9207dea0fb297f26faaac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57d75eebe2eb48709fd9086236bb0757778ad617", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57d75eebe2eb48709fd9086236bb0757778ad617", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57d75eebe2eb48709fd9086236bb0757778ad617", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57d75eebe2eb48709fd9086236bb0757778ad617/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d4d92cd36ce35667006d3542d4f1f4e5fd89c97f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4d92cd36ce35667006d3542d4f1f4e5fd89c97f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4d92cd36ce35667006d3542d4f1f4e5fd89c97f"}], "stats": {"total": 291, "additions": 154, "deletions": 137}, "files": [{"sha": "d784696f3fe8f3c0cc51c12f16d4501b0c0c0563", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d75eebe2eb48709fd9086236bb0757778ad617/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d75eebe2eb48709fd9086236bb0757778ad617/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=57d75eebe2eb48709fd9086236bb0757778ad617", "patch": "@@ -1,3 +1,7 @@\n+2010-12-21  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* hash.c: Tidied up comments and indentation.  No code changes.\n+\n 2010-12-19  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tPR libobjc/47012"}, {"sha": "e699f024172ddea9e4cef3cc8d48f295b83c152a", "filename": "libobjc/hash.c", "status": "modified", "additions": 150, "deletions": 137, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d75eebe2eb48709fd9086236bb0757778ad617/libobjc%2Fhash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d75eebe2eb48709fd9086236bb0757778ad617/libobjc%2Fhash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fhash.c?ref=57d75eebe2eb48709fd9086236bb0757778ad617", "patch": "@@ -23,12 +23,12 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"objc-private/common.h\"\n-#include <assert.h> /* For assert */\n+#include <assert.h>               /* For assert.  */\n \n-#include \"objc/runtime.h\" /* For objc_calloc */\n-#include \"objc/thr.h\"     /* Required by objc-private/runtime.h.  */\n+#include \"objc/runtime.h\"         /* For objc_calloc.  */\n+#include \"objc/thr.h\"             /* Required by objc-private/runtime.h.  */\n #include \"objc-private/hash.h\"\n-#include \"objc-private/runtime.h\"\t\t/* for DEBUG_PRINTF */\n+#include \"objc-private/runtime.h\" /* for DEBUG_PRINTF.  */\n \n /* These two macros determine when a hash table is full and\n    by how much it should be expanded respectively.\n@@ -49,27 +49,27 @@ objc_hash_new (unsigned int size, hash_func_type hash_func,\n   assert (size);\n   assert (! (size & (size - 1)));\n \n-  /* Allocate the cache structure.  calloc insures\n-     its initialization for default values.  */\n+  /* Allocate the cache structure.  calloc insures its initialization\n+     for default values.  */\n   cache = (cache_ptr) objc_calloc (1, sizeof (struct cache));\n   assert (cache);\n \n-  /* Allocate the array of buckets for the cache.\n-     calloc initializes all of the pointers to NULL.  */\n+  /* Allocate the array of buckets for the cache.  calloc initializes\n+     all of the pointers to NULL.  */\n   cache->node_table\n     = (node_ptr *) objc_calloc (size, sizeof (node_ptr));\n   assert (cache->node_table);\n \n   cache->size  = size;\n \n-  /* This should work for all processor architectures? */\n+  /* This should work for all processor architectures (?).  */\n   cache->mask = (size - 1);\n \t\n   /* Store the hashing function so that codes can be computed.  */\n   cache->hash_func = hash_func;\n \n-  /* Store the function that compares hash keys to\n-     determine if they are equal.  */\n+  /* Store the function that compares hash keys to determine if they\n+     are equal.  */\n   cache->compare_func = compare_func;\n \n   return cache;\n@@ -85,19 +85,22 @@ objc_hash_delete (cache_ptr cache)\n \n   /* Purge all key/value pairs from the table.  */\n   /* Step through the nodes one by one and remove every node WITHOUT\n-     using objc_hash_next. this makes objc_hash_delete much more efficient. */\n-  for (i = 0;i < cache->size;i++) {\n-    if ((node = cache->node_table[i])) {\n-      /* an entry in the hash table has been found, now step through the\n-\t nodes next in the list and free them. */\n-      while ((next_node = node->next)) {\n-\tobjc_hash_remove (cache,node->key);\n-\tnode = next_node;\n-      }\n-\n-      objc_hash_remove (cache,node->key);\n+     using objc_hash_next. this makes objc_hash_delete much more\n+     efficient. */\n+  for (i = 0; i < cache->size; i++)\n+    {\n+      if ((node = cache->node_table[i]))\n+\t{\n+\t  /* An entry in the hash table has been found.  Now step\n+\t     through the nodes next in the list and free them.  */\n+\t  while ((next_node = node->next))\n+\t    {\n+\t      objc_hash_remove (cache,node->key);\n+\t      node = next_node;\n+\t    }\n+\t  objc_hash_remove (cache,node->key);\n+\t}\n     }\n-  }\n \n   /* Release the array of nodes and the cache itself.  */\n   objc_free(cache->node_table);\n@@ -108,27 +111,25 @@ objc_hash_delete (cache_ptr cache)\n void\n objc_hash_add (cache_ptr *cachep, const void *key, void *value)\n {\n-  size_t indx = (*(*cachep)->hash_func)(*cachep, key);\n+  size_t indx = (*(*cachep)->hash_func) (*cachep, key);\n   node_ptr node = (node_ptr) objc_calloc (1, sizeof (struct cache_node));\n \n-\n   assert (node);\n \n   /* Initialize the new node.  */\n   node->key    = key;\n   node->value  = value;\n   node->next  = (*cachep)->node_table[indx];\n \n-  /* Debugging.\n-     Check the list for another key.  */\n+  /* Debugging.  Check the list for another key.  */\n #ifdef DEBUG\n-  { node_ptr node1 = (*cachep)->node_table[indx];\n-\n-    while (node1) {\n-\n-      assert (node1->key != key);\n-      node1 = node1->next;\n-    }\n+  {\n+    node_ptr node1 = (*cachep)->node_table[indx];\n+    while (node1)\n+      {\n+\tassert (node1->key != key);\n+\tnode1 = node1->next;\n+      }\n   }\n #endif\n \n@@ -137,69 +138,72 @@ objc_hash_add (cache_ptr *cachep, const void *key, void *value)\n \n   /* Bump the number of entries in the cache.  */\n   ++(*cachep)->used;\n-\n-  /* Check the hash table's fullness.   We're going\n-     to expand if it is above the fullness level.  */\n-  if (FULLNESS (*cachep)) {\n-\n-    /* The hash table has reached its fullness level.  Time to\n-       expand it.\n-\n-       I'm using a slow method here but is built on other\n-       primitive functions thereby increasing its\n-       correctness.  */\n-    node_ptr node1 = NULL;\n-    cache_ptr new = objc_hash_new (EXPANSION (*cachep),\n-\t\t\t\t   (*cachep)->hash_func,\n-\t\t\t\t   (*cachep)->compare_func);\n-\n-    DEBUG_PRINTF (\"Expanding cache %#x from %d to %d\\n\",\n-\t\t  (int) *cachep, (*cachep)->size, new->size);\n-\n-    /* Copy the nodes from the first hash table to the new one.  */\n-    while ((node1 = objc_hash_next (*cachep, node1)))\n-      objc_hash_add (&new, node1->key, node1->value);\n-\n-    /* Trash the old cache.  */\n-    objc_hash_delete (*cachep);\n-\n-    /* Return a pointer to the new hash table.  */\n-    *cachep = new;\n-  }\n+  \n+  /* Check the hash table's fullness.  We're going to expand if it is\n+     above the fullness level.  */\n+  if (FULLNESS (*cachep))\n+    {\n+      /* The hash table has reached its fullness level.  Time to\n+\t expand it.\n+\n+\t I'm using a slow method here but is built on other primitive\n+\t functions thereby increasing its correctness.  */\n+      node_ptr node1 = NULL;\n+      cache_ptr new = objc_hash_new (EXPANSION (*cachep),\n+\t\t\t\t     (*cachep)->hash_func,\n+\t\t\t\t     (*cachep)->compare_func);\n+      \n+      DEBUG_PRINTF (\"Expanding cache %#x from %d to %d\\n\",\n+\t\t    (int) *cachep, (*cachep)->size, new->size);\n+      \n+      /* Copy the nodes from the first hash table to the new one.  */\n+      while ((node1 = objc_hash_next (*cachep, node1)))\n+\tobjc_hash_add (&new, node1->key, node1->value);\n+      \n+      /* Trash the old cache.  */\n+      objc_hash_delete (*cachep);\n+      \n+      /* Return a pointer to the new hash table.  */\n+      *cachep = new;\n+    }\n }\n \n-\n void\n objc_hash_remove (cache_ptr cache, const void *key)\n {\n-  size_t indx = (*cache->hash_func)(cache, key);\n+  size_t indx = (*cache->hash_func) (cache, key);\n   node_ptr node = cache->node_table[indx];\n \n-\n-  /* We assume there is an entry in the table.  Error if it is not.  */\n+  /* We assume there is an entry in the table.  Error if it is\n+     not.  */\n   assert (node);\n \n-  /* Special case.  First element is the key/value pair to be removed.  */\n-  if ((*cache->compare_func)(node->key, key)) {\n-    cache->node_table[indx] = node->next;\n-    objc_free(node);\n-  } else {\n-\n-    /* Otherwise, find the hash entry.  */\n-    node_ptr prev = node;\n-    BOOL removed = NO;\n-\n-    do {\n-\n-      if ((*cache->compare_func)(node->key, key)) {\n-        prev->next = node->next, removed = YES;\n-        objc_free(node);\n-      } else\n-        prev = node, node = node->next;\n-    } while (! removed && node);\n-    assert (removed);\n-  }\n-\n+  /* Special case.  First element is the key/value pair to be\n+     removed.  */\n+  if ((*cache->compare_func) (node->key, key))\n+    {\n+      cache->node_table[indx] = node->next;\n+      objc_free(node);\n+    }\n+  else\n+    {\n+      /* Otherwise, find the hash entry.  */\n+      node_ptr prev = node;\n+      BOOL removed = NO;\n+      do\n+\t{\n+\t  if ((*cache->compare_func) (node->key, key))\n+\t    {\n+\t      prev->next = node->next, removed = YES;\n+\t      objc_free(node);\n+\t    }\n+\t  else\n+\t    prev = node, node = node->next;\n+\t}\n+      while (!removed && node);\n+      assert (removed);\n+    }\n+  \n   /* Decrement the number of entries in the hash table.  */\n   --cache->used;\n }\n@@ -208,76 +212,85 @@ objc_hash_remove (cache_ptr cache, const void *key)\n node_ptr\n objc_hash_next (cache_ptr cache, node_ptr node)\n {\n-  /* If the scan is being started then reset the last node\n-     visitied pointer and bucket index.  */\n-  if (! node)\n+  /* If the scan is being started then reset the last node visitied\n+     pointer and bucket index.  */\n+  if (!node)\n     cache->last_bucket  = 0;\n-\n-  /* If there is a node visited last then check for another\n-     entry in the same bucket;  Otherwise step to the next bucket.  */\n-  if (node) {\n-    if (node->next)\n-      /* There is a node which follows the last node\n-\t returned.  Step to that node and retun it.  */\n-      return node->next;\n-    else\n-      ++cache->last_bucket;\n-  }\n-\n-  /* If the list isn't exhausted then search the buckets for\n-     other nodes.  */\n-  if (cache->last_bucket < cache->size) {\n-    /*  Scan the remainder of the buckets looking for an entry\n-\tat the head of the list.  Return the first item found.  */\n-    while (cache->last_bucket < cache->size)\n-      if (cache->node_table[cache->last_bucket])\n-        return cache->node_table[cache->last_bucket];\n+  \n+  /* If there is a node visited last then check for another entry in\n+     the same bucket.  Otherwise step to the next bucket.  */\n+  if (node)\n+    {\n+      if (node->next)\n+\t{\n+\t  /* There is a node which follows the last node returned.\n+\t     Step to that node and retun it.  */\n+\t  return node->next;\n+\t}\n       else\n-        ++cache->last_bucket;\n+\t++cache->last_bucket;\n+  }\n \n-    /* No further nodes were found in the hash table.  */\n-    return NULL;\n-  } else\n+  /* If the list isn't exhausted then search the buckets for other\n+     nodes.  */\n+  if (cache->last_bucket < cache->size)\n+    {\n+      /*  Scan the remainder of the buckets looking for an entry at\n+\t  the head of the list.  Return the first item found.  */\n+      while (cache->last_bucket < cache->size)\n+\tif (cache->node_table[cache->last_bucket])\n+\t  return cache->node_table[cache->last_bucket];\n+\telse\n+\t  ++cache->last_bucket;\n+      \n+      /* No further nodes were found in the hash table.  */\n+      return NULL;\n+    }\n+  else\n     return NULL;\n }\n \n \n-/* Given KEY, return corresponding value for it in CACHE.\n-   Return NULL if the KEY is not recorded.  */\n-\n+/* Given KEY, return corresponding value for it in CACHE.  Return NULL\n+   if the KEY is not recorded.  */\n void *\n objc_hash_value_for_key (cache_ptr cache, const void *key)\n {\n-  node_ptr node = cache->node_table[(*cache->hash_func)(cache, key)];\n+  node_ptr node = cache->node_table[(*cache->hash_func) (cache, key)];\n   void *retval = NULL;\n \n   if (node)\n-    do {\n-      if ((*cache->compare_func)(node->key, key)) {\n-        retval = node->value;\n-              break;\n-      } else\n-        node = node->next;\n-    } while (! retval && node);\n-\n+    do\n+      {\n+\tif ((*cache->compare_func) (node->key, key))\n+\t  {\n+\t    retval = node->value;\n+\t    break;\n+\t  }\n+\telse\n+\t  node = node->next;\n+      }\n+    while (! retval && node);\n+  \n   return retval;\n }\n \n-/* Given KEY, return YES if it exists in the CACHE.\n-   Return NO if it does not */\n-\n+/* Given KEY, return YES if it exists in the CACHE.  Return NO if it\n+   does not */\n BOOL\n objc_hash_is_key_in_hash (cache_ptr cache, const void *key)\n {\n-  node_ptr node = cache->node_table[(*cache->hash_func)(cache, key)];\n-\n+  node_ptr node = cache->node_table[(*cache->hash_func) (cache, key)];\n+  \n   if (node)\n-    do {\n-      if ((*cache->compare_func)(node->key, key))\n+    do\n+      {\n+\tif ((*cache->compare_func)(node->key, key))\n \t  return YES;\n-      else\n-        node = node->next;\n-    } while (node);\n+\telse\n+\t  node = node->next;\n+      }\n+    while (node);\n \n   return NO;\n }"}]}