{"sha": "1244a8b735508cea75ab03c7a72f221d31b2bb4f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTI0NGE4YjczNTUwOGNlYTc1YWIwM2M3YTcyZjIyMWQzMWIyYmI0Zg==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2009-04-13T20:02:41Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2009-04-13T20:02:41Z"}, "message": "genautomata.c: Put blank after comma.\n\n2009-04-13  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* genautomata.c: Put blank after comma.\n\t(automaton_decls): New.\n\t(struct unit_usage): Add comments to member next.\n\t(store_alt_unit_usage): Keep the list ordered.\n\t(unit_present_on_list_p, equal_alternatives_p): New.\n\t(check_regexp_units_distribution): Check units distribution\n\tcorrectness correctly.\n\t(main): Don't write automata if error is found.  Return correct\n\texit code.\n\t\n\t* config/m68k/cf.md (cfv4_ds): Remove.\n\t(cfv4_pOEP1, cfv4_sOEP1, cfv4_pOEP2,cfv4_sOEP2, cfv4_pOEP3,\n\tcfv4_sOEP3): Assign to cfv4_oep instead of cfv4_ds.\n\n\t* config/rs6000/power4.md (lsuq_power4, iq_power4, fpq_power4,\n\tpower4-load-ext, power4-store, power4-store-update,\n\tpower4-fpstore, power4-fpstore-update, power4-two, power4-three,\n\tpower4-insert, power4-compare, power4-lmul-cmp, power4-imul-cmp,\n\tpower4-lmul, , power4-imul, power4-imul3, power4-sdiv,\n\tpower4-sqrt, power4-isync): Modify reservation to make correct\n\tunit distribution to automata.\n\n\t* config/rs6000/power5.md (iq_power5, fpq_power5, power5-store,\n\tpower5-store-update, power5-two, power5-three, power5-lmul,\n\tpower5-imul, power5-imul3, power5-sdiv, power5-sqrt): Ditto.\n\nFrom-SVN: r146010", "tree": {"sha": "8e03669edca040b9c986cf51258ec8c31a29a0fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e03669edca040b9c986cf51258ec8c31a29a0fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1244a8b735508cea75ab03c7a72f221d31b2bb4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1244a8b735508cea75ab03c7a72f221d31b2bb4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1244a8b735508cea75ab03c7a72f221d31b2bb4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1244a8b735508cea75ab03c7a72f221d31b2bb4f/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1b1c508f21760e3d2c52c80c6195d2509cfc7daf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b1c508f21760e3d2c52c80c6195d2509cfc7daf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b1c508f21760e3d2c52c80c6195d2509cfc7daf"}], "stats": {"total": 710, "additions": 423, "deletions": 287}, "files": [{"sha": "8d81aca9d216428b3cc3fa7cc35070bff16f968a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1244a8b735508cea75ab03c7a72f221d31b2bb4f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1244a8b735508cea75ab03c7a72f221d31b2bb4f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1244a8b735508cea75ab03c7a72f221d31b2bb4f", "patch": "@@ -1,3 +1,31 @@\n+2009-04-13  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* genautomata.c: Put blank after comma.\n+\t(automaton_decls): New.\n+\t(struct unit_usage): Add comments to member next.\n+\t(store_alt_unit_usage): Keep the list ordered.\n+\t(unit_present_on_list_p, equal_alternatives_p): New.\n+\t(check_regexp_units_distribution): Check units distribution\n+\tcorrectness correctly.\n+\t(main): Don't write automata if error is found.  Return correct\n+\texit code.\n+\t\n+\t* config/m68k/cf.md (cfv4_ds): Remove.\n+\t(cfv4_pOEP1, cfv4_sOEP1, cfv4_pOEP2,cfv4_sOEP2, cfv4_pOEP3,\n+\tcfv4_sOEP3): Assign to cfv4_oep instead of cfv4_ds.\n+\n+\t* config/rs6000/power4.md (lsuq_power4, iq_power4, fpq_power4,\n+\tpower4-load-ext, power4-store, power4-store-update,\n+\tpower4-fpstore, power4-fpstore-update, power4-two, power4-three,\n+\tpower4-insert, power4-compare, power4-lmul-cmp, power4-imul-cmp,\n+\tpower4-lmul, , power4-imul, power4-imul3, power4-sdiv,\n+\tpower4-sqrt, power4-isync): Modify reservation to make correct\n+\tunit distribution to automata.\n+\n+\t* config/rs6000/power5.md (iq_power5, fpq_power5, power5-store,\n+\tpower5-store-update, power5-two, power5-three, power5-lmul,\n+\tpower5-imul, power5-imul3, power5-sdiv, power5-sqrt): Ditto.\n+\t\n 2009-04-13  Adam Nemet  <anemet@caviumnetworks.com>\n \n \t* except.c (pass_set_nothrow_function_flags): Set name and add"}, {"sha": "d6f1e92c3c96ae0f26fcd57e808445d326feba5c", "filename": "gcc/config/m68k/cf.md", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1244a8b735508cea75ab03c7a72f221d31b2bb4f/gcc%2Fconfig%2Fm68k%2Fcf.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1244a8b735508cea75ab03c7a72f221d31b2bb4f/gcc%2Fconfig%2Fm68k%2Fcf.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fcf.md?ref=1244a8b735508cea75ab03c7a72f221d31b2bb4f", "patch": "@@ -1872,15 +1872,12 @@ move_l,tst_l\"))\n (define_cpu_unit \"cfv4_oag,cfv4_oc1,cfv4_oc2,cfv4_ex,cfv4_da\"\n   \"cfv4_oep\")\n \n-;; This automaton is used to support CFv4 dual-issue.\n-(define_automaton \"cfv4_ds\")\n-\n ;; V4 has 3 cases of dual-issue.\n ;; After issuing a cfv4_pOEPx instruction, it'll be possible to issue\n ;; a cfv4_sOEPx instruction on the same cycle (see final_presence_sets below).\n (define_cpu_unit \"cfv4_pOEP1,cfv4_sOEP1,\n                   cfv4_pOEP2,cfv4_sOEP2,\n-                  cfv4_pOEP3,cfv4_sOEP3\" \"cfv4_ds\")\n+                  cfv4_pOEP3,cfv4_sOEP3\" \"cfv4_oep\")\n \n (final_presence_set \"cfv4_sOEP1\" \"cfv4_pOEP1\")\n (final_presence_set \"cfv4_sOEP2\" \"cfv4_pOEP2\")"}, {"sha": "0214c98b139d370d1df3dd42961fe72a8a36b5a5", "filename": "gcc/config/rs6000/power4.md", "status": "modified", "additions": 77, "deletions": 77, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1244a8b735508cea75ab03c7a72f221d31b2bb4f/gcc%2Fconfig%2Frs6000%2Fpower4.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1244a8b735508cea75ab03c7a72f221d31b2bb4f/gcc%2Fconfig%2Frs6000%2Fpower4.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpower4.md?ref=1244a8b735508cea75ab03c7a72f221d31b2bb4f", "patch": "@@ -41,21 +41,18 @@\n \t\t    |(du4_power4,lsu1_power4)\")\n \n (define_reservation \"lsuq_power4\"\n-\t\t    \"(du1_power4+du2_power4,lsu1_power4+iu2_power4)\\\n-\t\t    |(du2_power4+du3_power4,lsu2_power4+iu2_power4)\\\n-\t\t    |(du3_power4+du4_power4,lsu2_power4+iu1_power4)\")\n+\t\t    \"((du1_power4+du2_power4,lsu1_power4)\\\n+\t\t      |(du2_power4+du3_power4,lsu2_power4)\\\n+\t\t      |(du3_power4+du4_power4,lsu2_power4))\\\n+                     +(nothing,iu2_power4|nothing,iu1_power4)\")\n \n (define_reservation \"iq_power4\"\n-\t\t    \"(du1_power4,iu1_power4)\\\n-\t\t    |(du2_power4,iu2_power4)\\\n-\t\t    |(du3_power4,iu2_power4)\\\n-\t\t    |(du4_power4,iu1_power4)\")\n+\t\t    \"(du1_power4|du2_power4|du3_power4|du4_power4),\\\n+                     (iu1_power4|iu2_power4)\")\n \n (define_reservation \"fpq_power4\"\n-\t\t    \"(du1_power4,fpu1_power4)\\\n-\t\t    |(du2_power4,fpu2_power4)\\\n-\t\t    |(du3_power4,fpu2_power4)\\\n-\t\t    |(du4_power4,fpu1_power4)\")\n+\t\t    \"(du1_power4|du2_power4|du3_power4|du4_power4),\\\n+                     (fpu1_power4|fpu2_power4)\")\n \n (define_reservation \"vq_power4\"\n \t\t    \"(du1_power4,vec_power4)\\\n@@ -86,9 +83,11 @@\n (define_insn_reservation \"power4-load-ext\" 5\n   (and (eq_attr \"type\" \"load_ext\")\n        (eq_attr \"cpu\" \"power4\"))\n-  \"(du1_power4+du2_power4,lsu1_power4,nothing,nothing,iu2_power4)\\\n-  |(du2_power4+du3_power4,lsu2_power4,nothing,nothing,iu2_power4)\\\n-  |(du3_power4+du4_power4,lsu2_power4,nothing,nothing,iu1_power4)\")\n+  \"(du1_power4+du2_power4,lsu1_power4\\\n+    |du2_power4+du3_power4,lsu2_power4\\\n+    |du3_power4+du4_power4,lsu2_power4),\\\n+   nothing,nothing,\\\n+   (iu2_power4|iu1_power4)\")\n \n (define_insn_reservation \"power4-load-ext-update\" 5\n   (and (eq_attr \"type\" \"load_ext_u\")\n@@ -131,18 +130,23 @@\n (define_insn_reservation \"power4-store\" 12\n   (and (eq_attr \"type\" \"store\")\n        (eq_attr \"cpu\" \"power4\"))\n-  \"(du1_power4,lsu1_power4,iu1_power4)\\\n-  |(du2_power4,lsu2_power4,iu2_power4)\\\n-  |(du3_power4,lsu2_power4,iu2_power4)\\\n-  |(du4_power4,lsu1_power4,iu1_power4)\")\n+  \"((du1_power4,lsu1_power4)\\\n+    |(du2_power4,lsu2_power4)\\\n+    |(du3_power4,lsu2_power4)\\\n+    |(du4_power4,lsu1_power4)),\\\n+   (iu1_power4|iu2_power4)\")\n \n (define_insn_reservation \"power4-store-update\" 12\n   (and (eq_attr \"type\" \"store_u\")\n        (eq_attr \"cpu\" \"power4\"))\n-  \"(du1_power4+du2_power4,lsu1_power4+iu2_power4,iu1_power4)\\\n-  |(du2_power4+du3_power4,lsu2_power4+iu2_power4,iu2_power4)\\\n-  |(du3_power4+du4_power4,lsu2_power4+iu1_power4,iu2_power4)\\\n-  |(du3_power4+du4_power4,lsu2_power4,iu1_power4,iu2_power4)\")\n+  \"((du1_power4+du2_power4,lsu1_power4)\\\n+    |(du2_power4+du3_power4,lsu2_power4)\\\n+    |(du3_power4+du4_power4,lsu2_power4)\\\n+    |(du3_power4+du4_power4,lsu2_power4))+\\\n+   ((nothing,iu2_power4,iu1_power4)\\\n+    |(nothing,iu2_power4,iu2_power4)\\\n+    |(nothing,iu1_power4,iu2_power4)\\\n+    |(nothing,iu1_power4,iu2_power4))\")\n \n (define_insn_reservation \"power4-store-update-indexed\" 12\n   (and (eq_attr \"type\" \"store_ux\")\n@@ -153,17 +157,19 @@\n (define_insn_reservation \"power4-fpstore\" 12\n   (and (eq_attr \"type\" \"fpstore\")\n        (eq_attr \"cpu\" \"power4\"))\n-  \"(du1_power4,lsu1_power4,fpu1_power4)\\\n-  |(du2_power4,lsu2_power4,fpu2_power4)\\\n-  |(du3_power4,lsu2_power4,fpu2_power4)\\\n-  |(du4_power4,lsu1_power4,fpu1_power4)\")\n+  \"((du1_power4,lsu1_power4)\\\n+    |(du2_power4,lsu2_power4)\\\n+    |(du3_power4,lsu2_power4)\\\n+    |(du4_power4,lsu1_power4)),\\\n+   (fpu1_power4|fpu2_power4)\")\n \n (define_insn_reservation \"power4-fpstore-update\" 12\n   (and (eq_attr \"type\" \"fpstore_u,fpstore_ux\")\n        (eq_attr \"cpu\" \"power4\"))\n-  \"(du1_power4+du2_power4,lsu1_power4+iu2_power4,fpu1_power4)\\\n-  |(du2_power4+du3_power4,lsu2_power4+iu2_power4,fpu2_power4)\\\n-  |(du3_power4+du4_power4,lsu2_power4+iu1_power4,fpu2_power4)\")\n+  \"((du1_power4+du2_power4,lsu1_power4)\\\n+    |(du2_power4+du3_power4,lsu2_power4)\\\n+    |(du3_power4+du4_power4,lsu2_power4))\\\n+   +(nothing,(iu1_power4|iu2_power4),(fpu1_power4|fpu2_power4))\")\n \n (define_insn_reservation \"power4-vecstore\" 12\n   (and (eq_attr \"type\" \"vecstore\")\n@@ -176,8 +182,7 @@\n (define_insn_reservation \"power4-llsc\" 11\n   (and (eq_attr \"type\" \"load_l,store_c,sync\")\n        (eq_attr \"cpu\" \"power4\"))\n-  \"du1_power4+du2_power4+du3_power4+du4_power4,\\\n-  lsu1_power4\")\n+  \"du1_power4+du2_power4+du3_power4+du4_power4,lsu1_power4\")\n \n \n ; Integer latency is 2 cycles\n@@ -190,29 +195,32 @@\n (define_insn_reservation \"power4-two\" 2\n   (and (eq_attr \"type\" \"two\")\n        (eq_attr \"cpu\" \"power4\"))\n-  \"(du1_power4+du2_power4,iu1_power4,nothing,iu2_power4)\\\n-  |(du2_power4+du3_power4,iu2_power4,nothing,iu2_power4)\\\n-  |(du3_power4+du4_power4,iu2_power4,nothing,iu1_power4)\\\n-  |(du4_power4+du1_power4,iu1_power4,nothing,iu1_power4)\")\n+  \"((du1_power4+du2_power4)\\\n+    |(du2_power4+du3_power4)\\\n+    |(du3_power4+du4_power4)\\\n+    |(du4_power4+du1_power4)),\\\n+    ((iu1_power4,nothing,iu2_power4)\\\n+     |(iu2_power4,nothing,iu2_power4)\\\n+     |(iu2_power4,nothing,iu1_power4)\\\n+     |(iu1_power4,nothing,iu1_power4))\")\n \n (define_insn_reservation \"power4-three\" 2\n   (and (eq_attr \"type\" \"three\")\n        (eq_attr \"cpu\" \"power4\"))\n-  \"(du1_power4+du2_power4+du3_power4,\\\n-    iu1_power4,nothing,iu2_power4,nothing,iu2_power4)\\\n-  |(du2_power4+du3_power4+du4_power4,\\\n-    iu2_power4,nothing,iu2_power4,nothing,iu1_power4)\\\n-  |(du3_power4+du4_power4+du1_power4,\\\n-    iu2_power4,nothing,iu1_power4,nothing,iu1_power4)\\\n-  |(du4_power4+du1_power4+du2_power4,\\\n-    iu1_power4,nothing,iu2_power4,nothing,iu2_power4)\")\n+  \"(du1_power4+du2_power4+du3_power4|du2_power4+du3_power4+du4_power4\\\n+    |du3_power4+du4_power4+du1_power4|du4_power4+du1_power4+du2_power4),\\\n+   ((iu1_power4,nothing,iu2_power4,nothing,iu2_power4)\\\n+    |(iu2_power4,nothing,iu2_power4,nothing,iu1_power4)\\\n+    |(iu2_power4,nothing,iu1_power4,nothing,iu1_power4)\\\n+    |(iu1_power4,nothing,iu2_power4,nothing,iu2_power4))\")\n \n (define_insn_reservation \"power4-insert\" 4\n   (and (eq_attr \"type\" \"insert_word\")\n        (eq_attr \"cpu\" \"power4\"))\n-  \"(du1_power4+du2_power4,iu1_power4,nothing,iu2_power4)\\\n-  |(du2_power4+du3_power4,iu2_power4,nothing,iu2_power4)\\\n-  |(du3_power4+du4_power4,iu2_power4,nothing,iu1_power4)\")\n+  \"(du1_power4+du2_power4|du2_power4+du3_power4|du3_power4+du4_power4),\\\n+   ((iu1_power4,nothing,iu2_power4)\\\n+    |(iu2_power4,nothing,iu2_power4)\\\n+    |(iu2_power4,nothing,iu1_power4))\")\n \n (define_insn_reservation \"power4-cmp\" 3\n   (and (eq_attr \"type\" \"cmp,fast_compare\")\n@@ -222,53 +230,50 @@\n (define_insn_reservation \"power4-compare\" 2\n   (and (eq_attr \"type\" \"compare,delayed_compare,var_delayed_compare\")\n        (eq_attr \"cpu\" \"power4\"))\n-  \"(du1_power4+du2_power4,iu1_power4,iu2_power4)\\\n-  |(du2_power4+du3_power4,iu2_power4,iu2_power4)\\\n-  |(du3_power4+du4_power4,iu2_power4,iu1_power4)\")\n+  \"(du1_power4+du2_power4|du2_power4+du3_power4|du3_power4+du4_power4),\\\n+   ((iu1_power4,iu2_power4)\\\n+    |(iu2_power4,iu2_power4)\\\n+    |(iu2_power4,iu1_power4))\")\n \n (define_bypass 4 \"power4-compare\" \"power4-branch,power4-crlogical,power4-delayedcr,power4-mfcr,power4-mfcrf\")\n \n (define_insn_reservation \"power4-lmul-cmp\" 7\n   (and (eq_attr \"type\" \"lmul_compare\")\n        (eq_attr \"cpu\" \"power4\"))\n-  \"(du1_power4+du2_power4,iu1_power4*6,iu2_power4)\\\n-  |(du2_power4+du3_power4,iu2_power4*6,iu2_power4)\\\n-  |(du3_power4+du4_power4,iu2_power4*6,iu1_power4)\")\n+  \"(du1_power4+du2_power4|du2_power4+du3_power4|du3_power4+du4_power4),\\\n+   ((iu1_power4*6,iu2_power4)\\\n+    |(iu2_power4*6,iu2_power4)\\\n+    |(iu2_power4*6,iu1_power4))\")\n \n (define_bypass 10 \"power4-lmul-cmp\" \"power4-branch,power4-crlogical,power4-delayedcr,power4-mfcr,power4-mfcrf\")\n \n (define_insn_reservation \"power4-imul-cmp\" 5\n   (and (eq_attr \"type\" \"imul_compare\")\n        (eq_attr \"cpu\" \"power4\"))\n-  \"(du1_power4+du2_power4,iu1_power4*4,iu2_power4)\\\n-  |(du2_power4+du3_power4,iu2_power4*4,iu2_power4)\\\n-  |(du3_power4+du4_power4,iu2_power4*4,iu1_power4)\")\n+  \"(du1_power4+du2_power4|du2_power4+du3_power4|du3_power4+du4_power4),\\\n+   ((iu1_power4*4,iu2_power4)\\\n+    |(iu2_power4*4,iu2_power4)\\\n+    |(iu2_power4*4,iu1_power4))\")\n \n (define_bypass 8 \"power4-imul-cmp\" \"power4-branch,power4-crlogical,power4-delayedcr,power4-mfcr,power4-mfcrf\")\n \n (define_insn_reservation \"power4-lmul\" 7\n   (and (eq_attr \"type\" \"lmul\")\n        (eq_attr \"cpu\" \"power4\"))\n-  \"(du1_power4,iu1_power4*6)\\\n-  |(du2_power4,iu2_power4*6)\\\n-  |(du3_power4,iu2_power4*6)\\\n-  |(du4_power4,iu1_power4*6)\")\n+  \"(du1_power4|du2_power4|du3_power4|du4_power4),\\\n+   (iu1_power4*6|iu2_power4*6)\")\n \n (define_insn_reservation \"power4-imul\" 5\n   (and (eq_attr \"type\" \"imul\")\n        (eq_attr \"cpu\" \"power4\"))\n-  \"(du1_power4,iu1_power4*4)\\\n-  |(du2_power4,iu2_power4*4)\\\n-  |(du3_power4,iu2_power4*4)\\\n-  |(du4_power4,iu1_power4*4)\")\n+  \"(du1_power4|du2_power4|du3_power4|du4_power4),\\\n+   (iu1_power4*4|iu2_power4*4)\")\n \n (define_insn_reservation \"power4-imul3\" 4\n   (and (eq_attr \"type\" \"imul2,imul3\")\n        (eq_attr \"cpu\" \"power4\"))\n-  \"(du1_power4,iu1_power4*3)\\\n-  |(du2_power4,iu2_power4*3)\\\n-  |(du3_power4,iu2_power4*3)\\\n-  |(du4_power4,iu1_power4*3)\")\n+  \"(du1_power4|du2_power4|du3_power4|du4_power4),\\\n+   (iu1_power4*3|iu2_power4*3)\")\n \n \n ; SPR move only executes in first IU.\n@@ -347,24 +352,19 @@\n (define_insn_reservation \"power4-sdiv\" 33\n   (and (eq_attr \"type\" \"sdiv,ddiv\")\n        (eq_attr \"cpu\" \"power4\"))\n-  \"(du1_power4,fpu1_power4*28)\\\n-  |(du2_power4,fpu2_power4*28)\\\n-  |(du3_power4,fpu2_power4*28)\\\n-  |(du4_power4,fpu1_power4*28)\")\n+  \"(du1_power4|du2_power4|du3_power4|du4_power4),\\\n+   (fpu1_power4*28|fpu2_power4*28)\")\n \n (define_insn_reservation \"power4-sqrt\" 40\n   (and (eq_attr \"type\" \"ssqrt,dsqrt\")\n        (eq_attr \"cpu\" \"power4\"))\n-  \"(du1_power4,fpu1_power4*35)\\\n-  |(du2_power4,fpu2_power4*35)\\\n-  |(du3_power4,fpu2_power4*35)\\\n-  |(du4_power4,fpu2_power4*35)\")\n+  \"(du1_power4|du2_power4|du3_power4|du4_power4),\\\n+   (fpu1_power4*35|fpu2_power4*35)\")\n \n (define_insn_reservation \"power4-isync\" 2\n   (and (eq_attr \"type\" \"isync\")\n        (eq_attr \"cpu\" \"power4\"))\n-  \"du1_power4+du2_power4+du3_power4+du4_power4,\\\n-  lsu1_power4\")\n+  \"du1_power4+du2_power4+du3_power4+du4_power4,lsu1_power4\")\n \n \n ; VMX"}, {"sha": "83ffabcfb3a4d5be50668241e86d08d78b87f68a", "filename": "gcc/config/rs6000/power5.md", "status": "modified", "additions": 35, "deletions": 48, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1244a8b735508cea75ab03c7a72f221d31b2bb4f/gcc%2Fconfig%2Frs6000%2Fpower5.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1244a8b735508cea75ab03c7a72f221d31b2bb4f/gcc%2Fconfig%2Frs6000%2Fpower5.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpower5.md?ref=1244a8b735508cea75ab03c7a72f221d31b2bb4f", "patch": "@@ -40,16 +40,12 @@\n \t\t    |(du4_power5,lsu1_power5)\")\n \n (define_reservation \"iq_power5\"\n-\t\t    \"(du1_power5,iu1_power5)\\\n-\t\t    |(du2_power5,iu2_power5)\\\n-\t\t    |(du3_power5,iu2_power5)\\\n-\t\t    |(du4_power5,iu1_power5)\")\n+\t\t    \"(du1_power5|du2_power5|du3_power5|du4_power5),\\\n+                     (iu1_power5|iu2_power5)\")\n \n (define_reservation \"fpq_power5\"\n-\t\t    \"(du1_power5,fpu1_power5)\\\n-\t\t    |(du2_power5,fpu2_power5)\\\n-\t\t    |(du3_power5,fpu2_power5)\\\n-\t\t    |(du4_power5,fpu1_power5)\")\n+\t\t    \"(du1_power5|du2_power5|du3_power5|du4_power5),\\\n+                     (fpu1_power5|fpu2_power5)\")\n \n ; Dispatch slots are allocated in order conforming to program order.\n (absence_set \"du1_power5\" \"du2_power5,du3_power5,du4_power5,du5_power5\")\n@@ -105,10 +101,11 @@\n (define_insn_reservation \"power5-store\" 12\n   (and (eq_attr \"type\" \"store\")\n        (eq_attr \"cpu\" \"power5\"))\n-  \"(du1_power5,lsu1_power5,iu1_power5)\\\n-  |(du2_power5,lsu2_power5,iu2_power5)\\\n-  |(du3_power5,lsu2_power5,iu2_power5)\\\n-  |(du4_power5,lsu1_power5,iu1_power5)\")\n+  \"((du1_power5,lsu1_power5)\\\n+    |(du2_power5,lsu2_power5)\\\n+    |(du3_power5,lsu2_power5)\\\n+    |(du4_power5,lsu1_power5)),\\\n+    (iu1_power5|iu2_power5)\")\n \n (define_insn_reservation \"power5-store-update\" 12\n   (and (eq_attr \"type\" \"store_u\")\n@@ -124,10 +121,11 @@\n (define_insn_reservation \"power5-fpstore\" 12\n   (and (eq_attr \"type\" \"fpstore\")\n        (eq_attr \"cpu\" \"power5\"))\n-  \"(du1_power5,lsu1_power5,fpu1_power5)\\\n-  |(du2_power5,lsu2_power5,fpu2_power5)\\\n-  |(du3_power5,lsu2_power5,fpu2_power5)\\\n-  |(du4_power5,lsu1_power5,fpu1_power5)\")\n+  \"((du1_power5,lsu1_power5)\\\n+    |(du2_power5,lsu2_power5)\\\n+    |(du3_power5,lsu2_power5)\\\n+    |(du4_power5,lsu1_power5)),\\\n+    (fpu1_power5|fpu2_power5)\")\n \n (define_insn_reservation \"power5-fpstore-update\" 12\n   (and (eq_attr \"type\" \"fpstore_u,fpstore_ux\")\n@@ -151,22 +149,24 @@\n (define_insn_reservation \"power5-two\" 2\n   (and (eq_attr \"type\" \"two\")\n        (eq_attr \"cpu\" \"power5\"))\n-  \"(du1_power5+du2_power5,iu1_power5,nothing,iu2_power5)\\\n-  |(du2_power5+du3_power5,iu2_power5,nothing,iu2_power5)\\\n-  |(du3_power5+du4_power5,iu2_power5,nothing,iu1_power5)\\\n-  |(du4_power5+du1_power5,iu1_power5,nothing,iu1_power5)\")\n+  \"((du1_power5+du2_power5)\\\n+    |(du2_power5+du3_power5)\\\n+    |(du3_power5+du4_power5)\\\n+    |(du4_power5+du1_power5)),\\\n+    ((iu1_power5,nothing,iu2_power5)\\\n+     |(iu2_power5,nothing,iu2_power5)\\\n+     |(iu2_power5,nothing,iu1_power5)\\\n+     |(iu1_power5,nothing,iu1_power5))\")\n \n (define_insn_reservation \"power5-three\" 2\n   (and (eq_attr \"type\" \"three\")\n        (eq_attr \"cpu\" \"power5\"))\n-  \"(du1_power5+du2_power5+du3_power5,\\\n-    iu1_power5,nothing,iu2_power5,nothing,iu2_power5)\\\n-  |(du2_power5+du3_power5+du4_power5,\\\n-    iu2_power5,nothing,iu2_power5,nothing,iu1_power5)\\\n-  |(du3_power5+du4_power5+du1_power5,\\\n-    iu2_power5,nothing,iu1_power5,nothing,iu1_power5)\\\n-  |(du4_power5+du1_power5+du2_power5,\\\n-    iu1_power5,nothing,iu2_power5,nothing,iu2_power5)\")\n+  \"(du1_power5+du2_power5+du3_power5|du2_power5+du3_power5+du4_power5\\\n+    |du3_power5+du4_power5+du1_power5|du4_power5+du1_power5+du2_power5),\\\n+   ((iu1_power5,nothing,iu2_power5,nothing,iu2_power5)\\\n+    |(iu2_power5,nothing,iu2_power5,nothing,iu1_power5)\\\n+    |(iu2_power5,nothing,iu1_power5,nothing,iu1_power5)\\\n+    |(iu1_power5,nothing,iu2_power5,nothing,iu2_power5))\")\n \n (define_insn_reservation \"power5-insert\" 4\n   (and (eq_attr \"type\" \"insert_word\")\n@@ -202,26 +202,17 @@\n (define_insn_reservation \"power5-lmul\" 7\n   (and (eq_attr \"type\" \"lmul\")\n        (eq_attr \"cpu\" \"power5\"))\n-  \"(du1_power5,iu1_power5*6)\\\n-  |(du2_power5,iu2_power5*6)\\\n-  |(du3_power5,iu2_power5*6)\\\n-  |(du4_power5,iu1_power5*6)\")\n+  \"(du1_power5|du2_power5|du3_power5|du4_power5),(iu1_power5*6|iu2_power5*6)\")\n \n (define_insn_reservation \"power5-imul\" 5\n   (and (eq_attr \"type\" \"imul\")\n        (eq_attr \"cpu\" \"power5\"))\n-  \"(du1_power5,iu1_power5*4)\\\n-  |(du2_power5,iu2_power5*4)\\\n-  |(du3_power5,iu2_power5*4)\\\n-  |(du4_power5,iu1_power5*4)\")\n+  \"(du1_power5|du2_power5|du3_power5|du4_power5),(iu1_power5*4|iu2_power5*4)\")\n \n (define_insn_reservation \"power5-imul3\" 4\n   (and (eq_attr \"type\" \"imul2,imul3\")\n        (eq_attr \"cpu\" \"power5\"))\n-  \"(du1_power5,iu1_power5*3)\\\n-  |(du2_power5,iu2_power5*3)\\\n-  |(du3_power5,iu2_power5*3)\\\n-  |(du4_power5,iu1_power5*3)\")\n+  \"(du1_power5|du2_power5|du3_power5|du4_power5),(iu1_power5*3|iu2_power5*3)\")\n \n \n ; SPR move only executes in first IU.\n@@ -300,18 +291,14 @@\n (define_insn_reservation \"power5-sdiv\" 33\n   (and (eq_attr \"type\" \"sdiv,ddiv\")\n        (eq_attr \"cpu\" \"power5\"))\n-  \"(du1_power5,fpu1_power5*28)\\\n-  |(du2_power5,fpu2_power5*28)\\\n-  |(du3_power5,fpu2_power5*28)\\\n-  |(du4_power5,fpu1_power5*28)\")\n+  \"(du1_power5|du2_power5|du3_power5|du4_power5),\\\n+   (fpu1_power5*28|fpu2_power5*28)\")\n \n (define_insn_reservation \"power5-sqrt\" 40\n   (and (eq_attr \"type\" \"ssqrt,dsqrt\")\n        (eq_attr \"cpu\" \"power5\"))\n-  \"(du1_power5,fpu1_power5*35)\\\n-  |(du2_power5,fpu2_power5*35)\\\n-  |(du3_power5,fpu2_power5*35)\\\n-  |(du4_power5,fpu2_power5*35)\")\n+  \"(du1_power5|du2_power5|du3_power5|du4_power5),\\\n+   (fpu1_power5*35|fpu2_power5*35)\")\n \n (define_insn_reservation \"power5-isync\" 2 \n   (and (eq_attr \"type\" \"isync\")"}, {"sha": "514c2e69255deca94caea48640f7583572825f59", "filename": "gcc/genautomata.c", "status": "modified", "additions": 282, "deletions": 158, "changes": 440, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1244a8b735508cea75ab03c7a72f221d31b2bb4f/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1244a8b735508cea75ab03c7a72f221d31b2bb4f/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=1244a8b735508cea75ab03c7a72f221d31b2bb4f", "patch": "@@ -213,19 +213,19 @@ static struct obstack irp;\n /* Declare vector types for various data structures: */\n \n DEF_VEC_P(alt_state_t);\n-DEF_VEC_ALLOC_P(alt_state_t,heap);\n+DEF_VEC_ALLOC_P(alt_state_t, heap);\n DEF_VEC_P(ainsn_t);\n-DEF_VEC_ALLOC_P(ainsn_t,heap);\n+DEF_VEC_ALLOC_P(ainsn_t, heap);\n DEF_VEC_P(state_t);\n-DEF_VEC_ALLOC_P(state_t,heap);\n+DEF_VEC_ALLOC_P(state_t, heap);\n DEF_VEC_P(decl_t);\n-DEF_VEC_ALLOC_P(decl_t,heap);\n+DEF_VEC_ALLOC_P(decl_t, heap);\n DEF_VEC_P(reserv_sets_t);\n-DEF_VEC_ALLOC_P(reserv_sets_t,heap);\n+DEF_VEC_ALLOC_P(reserv_sets_t, heap);\n \n DEF_VEC_I(vect_el_t);\n DEF_VEC_ALLOC_I(vect_el_t, heap);\n-typedef VEC(vect_el_t,heap) *vla_hwint_t;\n+typedef VEC(vect_el_t, heap) *vla_hwint_t;\n \f\n /* Forward declarations of functions used before their definitions, only.  */\n static regexp_t gen_regexp_sequence    (const char *);\n@@ -1137,7 +1137,7 @@ check_name (const char * name, pos_t pos ATTRIBUTE_UNUSED)\n \n /* Pointers to all declarations during IR generation are stored in the\n    following.  */\n-static VEC(decl_t,heap) *decls;\n+static VEC(decl_t, heap) *decls;\n \n /* Given a pointer to a (char *) and a separator, return an alloc'ed\n    string containing the next separated element, taking parentheses\n@@ -1265,7 +1265,7 @@ gen_cpu_unit (rtx def)\n       DECL_UNIT (decl)->query_p = 0;\n       DECL_UNIT (decl)->min_occ_cycle_num = -1;\n       DECL_UNIT (decl)->in_set_p = 0;\n-      VEC_safe_push (decl_t,heap, decls, decl);\n+      VEC_safe_push (decl_t, heap, decls, decl);\n     }\n }\n \n@@ -1293,7 +1293,7 @@ gen_query_cpu_unit (rtx def)\n       DECL_UNIT (decl)->name = check_name (str_cpu_units [i], decl->pos);\n       DECL_UNIT (decl)->automaton_name = XSTR (def, 1);\n       DECL_UNIT (decl)->query_p = 1;\n-      VEC_safe_push (decl_t,heap, decls, decl);\n+      VEC_safe_push (decl_t, heap, decls, decl);\n     }\n }\n \n@@ -1328,7 +1328,7 @@ gen_bypass (rtx def)\n \tDECL_BYPASS (decl)->out_insn_name = out_insns [i];\n \tDECL_BYPASS (decl)->in_insn_name = in_insns [j];\n \tDECL_BYPASS (decl)->bypass_guard_name = XSTR (def, 3);\n-\tVEC_safe_push (decl_t,heap, decls, decl);\n+\tVEC_safe_push (decl_t, heap, decls, decl);\n       }\n }\n \n@@ -1367,7 +1367,7 @@ gen_excl_set (rtx def)\n     else\n       DECL_EXCL (decl)->names [i]\n \t= second_str_cpu_units [i - first_vect_length];\n-  VEC_safe_push (decl_t,heap, decls, decl);\n+  VEC_safe_push (decl_t, heap, decls, decl);\n }\n \n /* Process a PRESENCE_SET, a FINAL_PRESENCE_SET, an ABSENCE_SET,\n@@ -1436,7 +1436,7 @@ gen_presence_absence_set (rtx def, int presence_p, int final_p)\n       DECL_ABSENCE (decl)->patterns_num = patterns_length;\n       DECL_ABSENCE (decl)->final_p = final_p;\n     }\n-  VEC_safe_push (decl_t,heap, decls, decl);\n+  VEC_safe_push (decl_t, heap, decls, decl);\n }\n \n /* Process a PRESENCE_SET.\n@@ -1505,7 +1505,7 @@ gen_automaton (rtx def)\n       decl->mode = dm_automaton;\n       decl->pos = 0;\n       DECL_AUTOMATON (decl)->name = check_name (str_automata [i], decl->pos);\n-      VEC_safe_push (decl_t,heap, decls, decl);\n+      VEC_safe_push (decl_t, heap, decls, decl);\n     }\n }\n \n@@ -1706,7 +1706,7 @@ gen_reserv (rtx def)\n   decl->pos = 0;\n   DECL_RESERV (decl)->name = check_name (XSTR (def, 0), decl->pos);\n   DECL_RESERV (decl)->regexp = gen_regexp (XSTR (def, 1));\n-  VEC_safe_push (decl_t,heap, decls, decl);\n+  VEC_safe_push (decl_t, heap, decls, decl);\n }\n \n /* Process a DEFINE_INSN_RESERVATION.\n@@ -1727,7 +1727,7 @@ gen_insn_reserv (rtx def)\n   DECL_INSN_RESERV (decl)->default_latency = XINT (def, 1);\n   DECL_INSN_RESERV (decl)->condexp = XEXP (def, 2);\n   DECL_INSN_RESERV (decl)->regexp = gen_regexp (XSTR (def, 3));\n-  VEC_safe_push (decl_t,heap, decls, decl);\n+  VEC_safe_push (decl_t, heap, decls, decl);\n }\n \n \f\n@@ -3239,7 +3239,7 @@ static alt_state_t\n uniq_sort_alt_states (alt_state_t alt_states_list)\n {\n   alt_state_t curr_alt_state;\n-  VEC(alt_state_t,heap) *alt_states;\n+  VEC(alt_state_t, heap) *alt_states;\n   size_t i;\n   size_t prev_unique_state_ind;\n   alt_state_t result;\n@@ -3249,11 +3249,11 @@ uniq_sort_alt_states (alt_state_t alt_states_list)\n   if (alt_states_list->next_alt_state == 0)\n     return alt_states_list;\n \n-  alt_states = VEC_alloc (alt_state_t,heap, 150);\n+  alt_states = VEC_alloc (alt_state_t, heap, 150);\n   for (curr_alt_state = alt_states_list;\n        curr_alt_state != NULL;\n        curr_alt_state = curr_alt_state->next_alt_state)\n-    VEC_safe_push (alt_state_t,heap, alt_states, curr_alt_state);\n+    VEC_safe_push (alt_state_t, heap, alt_states, curr_alt_state);\n \n   qsort (VEC_address (alt_state_t, alt_states),\n \t VEC_length  (alt_state_t, alt_states),\n@@ -3277,7 +3277,7 @@ uniq_sort_alt_states (alt_state_t alt_states_list)\n \n   result = VEC_index (alt_state_t, alt_states, 0);\n \n-  VEC_free (alt_state_t,heap, alt_states);\n+  VEC_free (alt_state_t, heap, alt_states);\n   return result;\n }\n \n@@ -4918,18 +4918,23 @@ transform_insn_regexps (void)\n    about units to automata distribution has been output.  */\n static int annotation_message_reported_p;\n \n+/* The vector contains all decls which are automata.  */\n+static VEC(decl_t, heap) *automaton_decls;\n+\n /* The following structure describes usage of a unit in a reservation.  */\n struct unit_usage\n {\n   unit_decl_t unit_decl;\n   /* The following forms a list of units used on the same cycle in the\n-     same alternative.  */\n+     same alternative.  The list is ordered by the correspdoning unit\n+     declarations and there is no unit declaration duplication in the\n+     list.  */\n   struct unit_usage *next;\n };\n typedef struct unit_usage *unit_usage_t;\n \n DEF_VEC_P(unit_usage_t);\n-DEF_VEC_ALLOC_P(unit_usage_t,heap);\n+DEF_VEC_ALLOC_P(unit_usage_t, heap);\n \n /* Obstack for unit_usage structures.  */\n static struct obstack unit_usages;\n@@ -4938,9 +4943,9 @@ static struct obstack unit_usages;\n    structures.  There is an element for each combination of\n    (alternative number, cycle).  Unit usages on given cycle in\n    alternative with given number are referred through element with\n-   index equals to the cycle * number of all alternatives in the regexp\n-   + the alternative number.  */\n-static VEC(unit_usage_t,heap) *cycle_alt_unit_usages;\n+   index equals to the cycle * number of all alternatives in the\n+   regexp + the alternative number.  */\n+static VEC(unit_usage_t, heap) *cycle_alt_unit_usages;\n \n /* The following function creates the structure unit_usage for UNIT on\n    CYCLE in REGEXP alternative with ALT_NUM.  The structure is made\n@@ -4951,7 +4956,7 @@ store_alt_unit_usage (regexp_t regexp, regexp_t unit, int cycle,\n {\n   size_t length;\n   unit_decl_t unit_decl;\n-  unit_usage_t unit_usage_ptr;\n+  unit_usage_t unit_usage_ptr, curr, prev;\n   int index;\n \n   gcc_assert (regexp && regexp->mode == rm_oneof\n@@ -4960,33 +4965,100 @@ store_alt_unit_usage (regexp_t regexp, regexp_t unit, int cycle,\n \n   length = (cycle + 1) * REGEXP_ONEOF (regexp)->regexps_num;\n   while (VEC_length (unit_usage_t, cycle_alt_unit_usages) < length)\n-    VEC_safe_push (unit_usage_t,heap, cycle_alt_unit_usages, 0);\n+    VEC_safe_push (unit_usage_t, heap, cycle_alt_unit_usages, 0);\n   \n+  index = cycle * REGEXP_ONEOF (regexp)->regexps_num + alt_num;\n+  prev = NULL;\n+  for (curr = VEC_index (unit_usage_t, cycle_alt_unit_usages, index);\n+       curr != NULL;\n+       prev = curr, curr = curr->next)\n+    if (curr->unit_decl >= unit_decl)\n+      break;\n+  if (curr != NULL && curr->unit_decl == unit_decl)\n+    return;\n   obstack_blank (&unit_usages, sizeof (struct unit_usage));\n   unit_usage_ptr = (struct unit_usage *) obstack_base (&unit_usages);\n   obstack_finish (&unit_usages);\n   unit_usage_ptr->unit_decl = unit_decl;\n-  index = cycle * REGEXP_ONEOF (regexp)->regexps_num + alt_num;\n-  unit_usage_ptr->next = VEC_index (unit_usage_t, cycle_alt_unit_usages, index);\n-  VEC_replace (unit_usage_t, cycle_alt_unit_usages, index, unit_usage_ptr);\n   unit_decl->last_distribution_check_cycle = -1; /* undefined */\n+  unit_usage_ptr->next = curr;\n+  if (prev == NULL)\n+    VEC_replace (unit_usage_t, cycle_alt_unit_usages, index, unit_usage_ptr);\n+  else\n+    prev->next = unit_usage_ptr;\n+}\n+\n+/* Return true if unit UNIT_DECL is present on the LIST.  */\n+static bool\n+unit_present_on_list_p (unit_usage_t list, unit_decl_t unit_decl)\n+{\n+  while (list != NULL)\n+    {\n+      if (list->unit_decl == unit_decl)\n+\treturn true;\n+      list = list->next;\n+    }\n+  return false;\n+}\n+\n+/* The function returns true if reservations of alternatives ALT1 and\n+   ALT2 are equal after excluding reservations of units of\n+   EXCLUDED_AUTOMATON_DECL.  */\n+static bool\n+equal_alternatives_p (int alt1, int alt2, int n_alts,\n+\t\t      struct automaton_decl *excluded_automaton_decl)\n+{\n+  int i;\n+  unit_usage_t list1, list2;\n+\n+  for (i = 0;\n+       i < (int) VEC_length (unit_usage_t, cycle_alt_unit_usages);\n+       i += n_alts)\n+    {\n+      for (list1 = VEC_index (unit_usage_t, cycle_alt_unit_usages, i + alt1),\n+\t     list2 = VEC_index (unit_usage_t, cycle_alt_unit_usages, i + alt2);;\n+\t   list1 = list1->next, list2 = list2->next)\n+\t{\n+\t  while (list1 != NULL\n+\t\t && list1->unit_decl->automaton_decl == excluded_automaton_decl)\n+\t    list1 = list1->next;\n+\t  while (list2 != NULL\n+\t\t && list2->unit_decl->automaton_decl == excluded_automaton_decl)\n+\t    list2 = list2->next;\n+\t  if (list1 == NULL || list2 == NULL)\n+\t    {\n+\t      if (list1 != list2)\n+\t\treturn false;\n+\t      else\n+\t\tbreak;\n+\t    }\n+\t  if (list1->unit_decl != list2->unit_decl)\n+\t    return false;\n+\t}\n+    }\n+  return true;\n }\n \n+DEF_VEC_I(int);\n+DEF_VEC_ALLOC_I(int, heap);\n+\n /* The function processes given REGEXP to find units with the wrong\n    distribution.  */\n static void\n check_regexp_units_distribution (const char *insn_reserv_name,\n \t\t\t\t regexp_t regexp)\n {\n-  int i, j, k, cycle;\n+  int i, j, k, cycle, cycle2, start, n_alts, alt, alt2;\n+  bool annotation_reservation_message_reported_p;\n   regexp_t seq, allof, unit;\n-  struct unit_usage *unit_usage_ptr, *other_unit_usage_ptr;\n+  struct unit_usage *unit_usage_ptr;\n+  VEC(int, heap) *marked;\n \n   if (regexp == NULL || regexp->mode != rm_oneof)\n     return;\n   /* Store all unit usages in the regexp:  */\n   obstack_init (&unit_usages);\n-  cycle_alt_unit_usages = 0;\n+  cycle_alt_unit_usages = VEC_alloc (unit_usage_t, heap, 10);\n \n   for (i = REGEXP_ONEOF (regexp)->regexps_num - 1; i >= 0; i--)\n     {\n@@ -5054,49 +5126,86 @@ check_regexp_units_distribution (const char *insn_reserv_name,\n \t}\n     }\n   /* Check distribution:  */\n+  for (i = 0; i < (int) VEC_length (unit_usage_t, cycle_alt_unit_usages); i++)\n+    for (unit_usage_ptr = VEC_index (unit_usage_t, cycle_alt_unit_usages, i);\n+\t unit_usage_ptr != NULL;\n+\t unit_usage_ptr = unit_usage_ptr->next)\n+      unit_usage_ptr->unit_decl->last_distribution_check_cycle = -1;\n+  n_alts = REGEXP_ONEOF (regexp)->regexps_num;\n+  marked = VEC_alloc (int, heap, n_alts);\n+  for (i = 0; i < n_alts; i++)\n+    VEC_safe_push (int, heap, marked, 0);\n+  annotation_reservation_message_reported_p = false;\n   for (i = 0; i < (int) VEC_length (unit_usage_t, cycle_alt_unit_usages); i++)\n     {\n-      cycle = i / REGEXP_ONEOF (regexp)->regexps_num;\n+      cycle = i / n_alts;\n+      start = cycle * n_alts;\n       for (unit_usage_ptr = VEC_index (unit_usage_t, cycle_alt_unit_usages, i);\n \t   unit_usage_ptr != NULL;\n \t   unit_usage_ptr = unit_usage_ptr->next)\n-\tif (cycle != unit_usage_ptr->unit_decl->last_distribution_check_cycle)\n-\t  {\n-\t    unit_usage_ptr->unit_decl->last_distribution_check_cycle = cycle;\n-\t    for (k = cycle * REGEXP_ONEOF (regexp)->regexps_num;\n-\t\t k < (int) VEC_length (unit_usage_t, cycle_alt_unit_usages)\n-\t\t   && k == cycle * REGEXP_ONEOF (regexp)->regexps_num;\n-\t\t k++)\n-\t      {\n-\t\tfor (other_unit_usage_ptr\n-\t\t       = VEC_index (unit_usage_t, cycle_alt_unit_usages, k);\n-\t\t     other_unit_usage_ptr != NULL;\n-\t\t     other_unit_usage_ptr = other_unit_usage_ptr->next)\n-\t\t  if (unit_usage_ptr->unit_decl->automaton_decl\n-\t\t      == other_unit_usage_ptr->unit_decl->automaton_decl)\n-\t\t    break;\n-\t\tif (other_unit_usage_ptr == NULL\n-\t\t    && (VEC_index (unit_usage_t, cycle_alt_unit_usages, k)\n-\t\t\t!= NULL))\n-\t\t  break;\n-\t      }\n-\t    if (k < (int) VEC_length (unit_usage_t, cycle_alt_unit_usages)\n-\t\t&& k == cycle * REGEXP_ONEOF (regexp)->regexps_num)\n-\t      {\n-\t\tif (!annotation_message_reported_p)\n-\t\t  {\n-\t\t    fprintf (stderr, \"\\n\");\n-\t\t    error (\"The following units do not satisfy units-automata distribution rule\");\n-\t\t    error (\" (A unit of given unit automaton should be on each reserv. altern.)\");\n-\t\t    annotation_message_reported_p = TRUE;\n-\t\t  }\n-\t\terror (\"Unit %s, reserv. %s, cycle %d\",\n-\t\t       unit_usage_ptr->unit_decl->name, insn_reserv_name,\n-\t\t       cycle);\n-\t      }\n-\t  }\n+\t{\n+\t  if (unit_usage_ptr->unit_decl->last_distribution_check_cycle == cycle)\n+\t    continue;\n+\t  unit_usage_ptr->unit_decl->last_distribution_check_cycle = cycle;\n+\t  for (alt = 0; alt < n_alts; alt++)\n+\t    if (! unit_present_on_list_p (VEC_index (unit_usage_t,\n+\t\t\t\t\t\t     cycle_alt_unit_usages,\n+\t\t\t\t\t\t     start + alt),\n+\t\t\t\t\t  unit_usage_ptr->unit_decl))\n+\t      break;\n+\t  if (alt >= n_alts)\n+\t    continue;\n+\t  memset (VEC_address (int, marked), 0, n_alts * sizeof (int));\n+\t  for (alt = 0; alt < n_alts; alt++)\n+\t    {\n+\t      if (! unit_present_on_list_p (VEC_index (unit_usage_t,\n+\t\t\t\t\t\t       cycle_alt_unit_usages,\n+\t\t\t\t\t\t       start + alt),\n+\t\t\t\t\t    unit_usage_ptr->unit_decl))\n+\t\tcontinue;\n+\t      for (j = 0;\n+\t\t   j < (int) VEC_length (unit_usage_t, cycle_alt_unit_usages);\n+\t\t   j++)\n+\t\t{\n+\t\t  cycle2 = j / n_alts;\n+\t\t  alt2 = j % n_alts;\n+\t\t  if (! unit_present_on_list_p\n+\t\t        (VEC_index (unit_usage_t, cycle_alt_unit_usages,\n+\t\t\t\t    start + alt2),\n+\t\t\t unit_usage_ptr->unit_decl)\n+\t\t      && equal_alternatives_p (alt, alt2, n_alts,\n+\t\t\t\t\t       unit_usage_ptr\n+\t\t\t\t\t       ->unit_decl->automaton_decl))\n+\t\t    {\n+\t\t      VEC_replace (int, marked, alt, 1);\n+\t\t      VEC_replace (int, marked, alt2, 1);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  for (alt = 0; alt < n_alts && VEC_index (int, marked, alt); alt++)\n+\t    ;\n+\t  if (alt < n_alts && 0)\n+\t    {\n+\t      if (! annotation_message_reported_p)\n+\t\t{\n+\t\t  fprintf (stderr, \"\\n\");\n+\t\t  error (\"The following units do not satisfy units-automata distribution rule\");\n+\t\t  error (\"(Unit presence on one alt and its absence on other alt\\n\");\n+\t\t  error (\" result in different other automata reservations)\");\n+\t\t  annotation_message_reported_p = TRUE;\n+\t\t}\n+\t      if (! annotation_reservation_message_reported_p)\n+\t\t{\n+\t\t  error (\"Reserv %s:\", insn_reserv_name);\n+\t\t  annotation_reservation_message_reported_p = true;\n+\t\t}\n+\t      error (\"  Unit %s, cycle %d, alt %d, another alt %d\",\n+\t\t     unit_usage_ptr->unit_decl->name, cycle, i % n_alts, alt);\n+\t    }\n+\t}\n     }\n-  VEC_free (unit_usage_t,heap, cycle_alt_unit_usages);\n+  VEC_free (int, heap, marked);\n+  VEC_free (unit_usage_t, heap, cycle_alt_unit_usages);\n   obstack_free (&unit_usages, NULL);\n }\n \n@@ -5110,15 +5219,26 @@ check_unit_distributions_to_automata (void)\n \n   if (progress_flag)\n     fprintf (stderr, \"Check unit distributions to automata...\");\n-  annotation_message_reported_p = FALSE;\n+  automaton_decls = NULL;\n   for (i = 0; i < description->decls_num; i++)\n     {\n       decl = description->decls [i];\n-      if (decl->mode == dm_insn_reserv)\n-\tcheck_regexp_units_distribution\n-\t  (DECL_INSN_RESERV (decl)->name,\n-\t   DECL_INSN_RESERV (decl)->transformed_regexp);\n+      if (decl->mode == dm_automaton)\n+\tVEC_safe_push (decl_t, heap, automaton_decls, decl);\n+    }\n+  if (VEC_length (decl_t, automaton_decls) > 1)\n+    {\n+      annotation_message_reported_p = FALSE;\n+      for (i = 0; i < description->decls_num; i++)\n+\t{\n+\t  decl = description->decls [i];\n+\t  if (decl->mode == dm_insn_reserv)\n+\t    check_regexp_units_distribution\n+\t      (DECL_INSN_RESERV (decl)->name,\n+\t       DECL_INSN_RESERV (decl)->transformed_regexp);\n+\t}\n     }\n+  VEC_free (decl_t, heap, automaton_decls);\n   if (progress_flag)\n     fprintf (stderr, \"done\\n\");\n }\n@@ -5278,7 +5398,7 @@ form_ainsn_with_same_reservs (automaton_t automaton)\n {\n   ainsn_t curr_ainsn;\n   size_t i;\n-  VEC(ainsn_t,heap) *last_insns = VEC_alloc (ainsn_t,heap, 150);\n+  VEC(ainsn_t, heap) *last_insns = VEC_alloc (ainsn_t, heap, 150);\n \n   for (curr_ainsn = automaton->ainsn_list;\n        curr_ainsn != NULL;\n@@ -5310,7 +5430,7 @@ form_ainsn_with_same_reservs (automaton_t automaton)\n             curr_ainsn->first_insn_with_same_reservs = 1;\n           }\n       }\n-  VEC_free (ainsn_t,heap, last_insns);\n+  VEC_free (ainsn_t, heap, last_insns);\n }\n \n /* Forming unit reservations which can affect creating the automaton\n@@ -5354,15 +5474,15 @@ make_automaton (automaton_t automaton)\n   state_t state2;\n   ainsn_t advance_cycle_ainsn;\n   arc_t added_arc;\n-  VEC(state_t,heap) *state_stack = VEC_alloc(state_t,heap, 150);\n+  VEC(state_t, heap) *state_stack = VEC_alloc(state_t, heap, 150);\n   int states_n;\n   reserv_sets_t reservs_matter = form_reservs_matter (automaton);\n \n   /* Create the start state (empty state).  */\n   start_state = insert_state (get_free_state (1, automaton));\n   automaton->start_state = start_state;\n   start_state->it_was_placed_in_stack_for_NDFA_forming = 1;\n-  VEC_safe_push (state_t,heap, state_stack, start_state);\n+  VEC_safe_push (state_t, heap, state_stack, start_state);\n   states_n = 1;\n   while (VEC_length (state_t, state_stack) != 0)\n     {\n@@ -5391,7 +5511,7 @@ make_automaton (automaton_t automaton)\n                           {\n                             state2->it_was_placed_in_stack_for_NDFA_forming\n \t\t\t      = 1;\n-                            VEC_safe_push (state_t,heap, state_stack, state2);\n+                            VEC_safe_push (state_t, heap, state_stack, state2);\n \t\t\t    states_n++;\n \t\t\t    if (progress_flag && states_n % 100 == 0)\n \t\t\t      fprintf (stderr, \".\");\n@@ -5417,15 +5537,15 @@ make_automaton (automaton_t automaton)\n       if (!state2->it_was_placed_in_stack_for_NDFA_forming)\n         {\n           state2->it_was_placed_in_stack_for_NDFA_forming = 1;\n-          VEC_safe_push (state_t,heap, state_stack, state2);\n+          VEC_safe_push (state_t, heap, state_stack, state2);\n \t  states_n++;\n \t  if (progress_flag && states_n % 100 == 0)\n \t    fprintf (stderr, \".\");\n         }\n       gcc_assert (advance_cycle_ainsn);\n       add_arc (state, state2, advance_cycle_ainsn);\n     }\n-  VEC_free (state_t,heap, state_stack);\n+  VEC_free (state_t, heap, state_stack);\n }\n \n /* Form lists of all arcs of STATE marked by the same ainsn.  */\n@@ -5458,7 +5578,7 @@ form_arcs_marked_by_insn (state_t state)\n \n static int\n create_composed_state (state_t original_state, arc_t arcs_marked_by_insn,\n-\t\t       VEC(state_t,heap) **state_stack)\n+\t\t       VEC(state_t, heap) **state_stack)\n {\n   state_t state;\n   alt_state_t alt_state, curr_alt_state;\n@@ -5548,7 +5668,7 @@ create_composed_state (state_t original_state, arc_t arcs_marked_by_insn,\n   if (!state->it_was_placed_in_stack_for_DFA_forming)\n     {\n       state->it_was_placed_in_stack_for_DFA_forming = 1;\n-      VEC_safe_push (state_t,heap, *state_stack, state);\n+      VEC_safe_push (state_t, heap, *state_stack, state);\n     }\n   return new_state_p;\n }\n@@ -5562,16 +5682,16 @@ NDFA_to_DFA (automaton_t automaton)\n   state_t start_state;\n   state_t state;\n   decl_t decl;\n-  VEC(state_t,heap) *state_stack;\n+  VEC(state_t, heap) *state_stack;\n   int i;\n   int states_n;\n \n-  state_stack = VEC_alloc (state_t,heap, 0);\n+  state_stack = VEC_alloc (state_t, heap, 0);\n \n   /* Create the start state (empty state).  */\n   start_state = automaton->start_state;\n   start_state->it_was_placed_in_stack_for_DFA_forming = 1;\n-  VEC_safe_push (state_t,heap, state_stack, start_state);\n+  VEC_safe_push (state_t, heap, state_stack, start_state);\n   states_n = 1;\n   while (VEC_length (state_t, state_stack) != 0)\n     {\n@@ -5591,7 +5711,7 @@ NDFA_to_DFA (automaton_t automaton)\n \t    }\n \t}\n     }\n-  VEC_free (state_t,heap, state_stack);\n+  VEC_free (state_t, heap, state_stack);\n }\n \n /* The following variable value is current number (1, 2, ...) of passing\n@@ -5633,14 +5753,14 @@ initiate_pass_states (void)\n \n /* The following vla is used for storing pointers to all achieved\n    states.  */\n-static VEC(state_t,heap) *all_achieved_states;\n+static VEC(state_t, heap) *all_achieved_states;\n \n /* This function is called by function pass_states to add an achieved\n    STATE.  */\n static void\n add_achieved_state (state_t state)\n {\n-  VEC_safe_push (state_t,heap, all_achieved_states, state);\n+  VEC_safe_push (state_t, heap, all_achieved_states, state);\n }\n \n /* The function sets up equivalence numbers of insns which mark all\n@@ -5779,21 +5899,21 @@ compare_states_for_equiv (const void *state_ptr_1,\n    classes and saves it into *CLASSES.  This function requires the input\n    to be sorted via compare_states_for_equiv().  */\n static int\n-init_equiv_class (VEC(state_t,heap) *states, VEC (state_t,heap) **classes)\n+init_equiv_class (VEC(state_t, heap) *states, VEC (state_t, heap) **classes)\n {\n   size_t i;\n   state_t prev = 0;\n   int class_num = 1;\n \n-  *classes = VEC_alloc (state_t,heap, 150);\n+  *classes = VEC_alloc (state_t, heap, 150);\n   for (i = 0; i < VEC_length (state_t, states); i++)\n     {\n       state_t state = VEC_index (state_t, states, i);\n       if (prev)\n         {\n \t  if (compare_states_for_equiv (&prev, &state) != 0)\n \t    {\n-\t      VEC_safe_push (state_t,heap, *classes, prev);\n+\t      VEC_safe_push (state_t, heap, *classes, prev);\n \t      class_num++;\n \t      prev = NULL;\n \t    }\n@@ -5803,17 +5923,17 @@ init_equiv_class (VEC(state_t,heap) *states, VEC (state_t,heap) **classes)\n       prev = state;\n     }\n   if (prev)\n-    VEC_safe_push (state_t,heap, *classes, prev);\n+    VEC_safe_push (state_t, heap, *classes, prev);\n   return class_num;\n }\n \n /* The function copies pointers to equivalent states from vla FROM\n    into vla TO.  */\n static void\n-copy_equiv_class (VEC(state_t,heap) **to, VEC(state_t,heap) *from)\n+copy_equiv_class (VEC(state_t, heap) **to, VEC(state_t, heap) *from)\n {\n-  VEC_free (state_t,heap, *to);\n-  *to = VEC_copy (state_t,heap, from);\n+  VEC_free (state_t, heap, *to);\n+  *to = VEC_copy (state_t, heap, from);\n }\n \n /* The function processes equivalence class given by its first state,\n@@ -5825,7 +5945,7 @@ copy_equiv_class (VEC(state_t,heap) **to, VEC(state_t,heap) *from)\n    partitioned, the function returns nonzero value.  */\n static int\n partition_equiv_class (state_t first_state, int odd_iteration_flag,\n-\t\t       VEC(state_t,heap) **next_iteration_classes,\n+\t\t       VEC(state_t, heap) **next_iteration_classes,\n \t\t       int *new_equiv_class_num_ptr)\n {\n   state_t new_equiv_class;\n@@ -5871,7 +5991,7 @@ partition_equiv_class (state_t first_state, int odd_iteration_flag,\n \t  clear_arc_insns_equiv_num (first_state);\n \t}\n       if (new_equiv_class != NULL)\n-\tVEC_safe_push (state_t,heap, *next_iteration_classes, new_equiv_class);\n+\tVEC_safe_push (state_t, heap, *next_iteration_classes, new_equiv_class);\n       first_state = new_equiv_class;\n     }\n   return partition_p;\n@@ -5880,15 +6000,15 @@ partition_equiv_class (state_t first_state, int odd_iteration_flag,\n /* The function finds equivalent states of AUTOMATON.  */\n static void\n evaluate_equiv_classes (automaton_t automaton,\n-\t\t\tVEC(state_t,heap) **equiv_classes)\n+\t\t\tVEC(state_t, heap) **equiv_classes)\n {\n   int new_equiv_class_num;\n   int odd_iteration_flag;\n   int finish_flag;\n-  VEC (state_t,heap) *next_iteration_classes;\n+  VEC (state_t, heap) *next_iteration_classes;\n   size_t i;\n \n-  all_achieved_states = VEC_alloc (state_t,heap, 1500);\n+  all_achieved_states = VEC_alloc (state_t, heap, 1500);\n   pass_states (automaton, add_achieved_state);\n   pass_states (automaton, cache_presence);\n   qsort (VEC_address (state_t, all_achieved_states),\n@@ -5922,13 +6042,13 @@ evaluate_equiv_classes (automaton_t automaton,\n \t  finish_flag = 0;\n     }\n   while (!finish_flag);\n-  VEC_free (state_t,heap, next_iteration_classes);\n-  VEC_free (state_t,heap, all_achieved_states);\n+  VEC_free (state_t, heap, next_iteration_classes);\n+  VEC_free (state_t, heap, all_achieved_states);\n }\n \n /* The function merges equivalent states of AUTOMATON.  */\n static void\n-merge_states (automaton_t automaton, VEC(state_t,heap) *equiv_classes)\n+merge_states (automaton_t automaton, VEC(state_t, heap) *equiv_classes)\n {\n   state_t curr_state;\n   state_t new_state;\n@@ -6043,13 +6163,13 @@ set_new_cycle_flags (state_t state)\n static void\n minimize_DFA (automaton_t automaton)\n {\n-  VEC(state_t,heap) *equiv_classes = 0;\n+  VEC(state_t, heap) *equiv_classes = 0;\n \n   evaluate_equiv_classes (automaton, &equiv_classes);\n   merge_states (automaton, equiv_classes);\n   pass_states (automaton, set_new_cycle_flags);\n \n-  VEC_free (state_t,heap, equiv_classes);\n+  VEC_free (state_t, heap, equiv_classes);\n }\n \n /* Values of two variables are counted number of states and arcs in an\n@@ -6984,7 +7104,7 @@ output_translate_vect (automaton_t automaton)\n   int insn_value;\n   vla_hwint_t translate_vect;\n \n-  translate_vect = VEC_alloc (vect_el_t,heap, description->insns_num);\n+  translate_vect = VEC_alloc (vect_el_t, heap, description->insns_num);\n \n   for (insn_value = 0; insn_value < description->insns_num; insn_value++)\n     /* Undefined value */\n@@ -7005,7 +7125,7 @@ output_translate_vect (automaton_t automaton)\n   fprintf (output_file, \"[] ATTRIBUTE_UNUSED = {\\n\");\n   output_vect (translate_vect);\n   fprintf (output_file, \"};\\n\\n\");\n-  VEC_free (vect_el_t,heap, translate_vect);\n+  VEC_free (vect_el_t, heap, translate_vect);\n }\n \n /* The value in a table state x ainsn -> something which represents\n@@ -7032,16 +7152,16 @@ create_state_ainsn_table (automaton_t automaton)\n   tab = XCREATENODE (struct state_ainsn_table);\n   tab->automaton = automaton;\n \n-  tab->comb_vect  = VEC_alloc (vect_el_t,heap, 10000);\n-  tab->check_vect = VEC_alloc (vect_el_t,heap, 10000);\n+  tab->comb_vect  = VEC_alloc (vect_el_t, heap, 10000);\n+  tab->check_vect = VEC_alloc (vect_el_t, heap, 10000);\n \n   tab->base_vect  = 0;\n-  VEC_safe_grow (vect_el_t,heap, tab->base_vect,\n+  VEC_safe_grow (vect_el_t, heap, tab->base_vect,\n \t\t automaton->achieved_states_num);\n \n   full_vect_length = (automaton->insn_equiv_classes_num\n                       * automaton->achieved_states_num);\n-  tab->full_vect  = VEC_alloc (vect_el_t,heap, full_vect_length);\n+  tab->full_vect  = VEC_alloc (vect_el_t, heap, full_vect_length);\n   for (i = 0; i < full_vect_length; i++)\n     VEC_quick_push (vect_el_t, tab->full_vect, undefined_vect_el_value);\n \n@@ -7129,7 +7249,7 @@ add_vect (state_ainsn_table_t tab, int vect_num, vla_hwint_t vect)\n   {\n     size_t full_base = tab->automaton->insn_equiv_classes_num * vect_num;\n     if (VEC_length (vect_el_t, tab->full_vect) < full_base + vect_length)\n-      VEC_safe_grow (vect_el_t,heap, tab->full_vect,\n+      VEC_safe_grow (vect_el_t, heap, tab->full_vect,\n \t\t     full_base + vect_length);\n     for (i = 0; i < vect_length; i++)\n       VEC_replace (vect_el_t, tab->full_vect, full_base + i,\n@@ -7229,8 +7349,8 @@ add_vect (state_ainsn_table_t tab, int vect_num, vla_hwint_t vect)\n   no_state_value = tab->automaton->achieved_states_num;\n   while (additional_els_num > 0)\n     {\n-      VEC_safe_push (vect_el_t,heap, tab->comb_vect, vect_el);\n-      VEC_safe_push (vect_el_t,heap, tab->check_vect, no_state_value);\n+      VEC_safe_push (vect_el_t, heap, tab->comb_vect, vect_el);\n+      VEC_safe_push (vect_el_t, heap, tab->check_vect, no_state_value);\n       additional_els_num--;\n     }\n   gcc_assert (VEC_length (vect_el_t, tab->comb_vect)\n@@ -7313,19 +7433,19 @@ add_vect_el (vla_hwint_t *vect, ainsn_t ainsn, int el_value)\n   for (vect_index = VEC_length (vect_el_t, *vect);\n        vect_index <= equiv_class_num;\n        vect_index++)\n-    VEC_safe_push (vect_el_t,heap, *vect, undefined_vect_el_value);\n+    VEC_safe_push (vect_el_t, heap, *vect, undefined_vect_el_value);\n   VEC_replace (vect_el_t, *vect, equiv_class_num, el_value);\n }\n \n /* This is for forming vector of states of an automaton.  */\n-static VEC(state_t,heap) *output_states_vect;\n+static VEC(state_t, heap) *output_states_vect;\n \n /* The function is called by function pass_states.  The function adds\n    STATE to `output_states_vect'.  */\n static void\n add_states_vect_el (state_t state)\n {\n-  VEC_safe_push (state_t,heap, output_states_vect, state);\n+  VEC_safe_push (state_t, heap, output_states_vect, state);\n }\n \n /* Form and output vectors (comb, check, base or full vector)\n@@ -7368,8 +7488,8 @@ output_trans_table (automaton_t automaton)\n      output_trans_full_vect_name, output_trans_comb_vect_name,\n      output_trans_check_vect_name, output_trans_base_vect_name);\n \n-  VEC_free (state_t,heap, output_states_vect);\n-  VEC_free (vect_el_t,heap, transition_vect);\n+  VEC_free (state_t, heap, output_states_vect);\n+  VEC_free (vect_el_t, heap, transition_vect);\n }\n \n /* The current number of passing states to find minimal issue delay\n@@ -7459,7 +7579,7 @@ output_min_issue_delay_table (automaton_t automaton)\n \n   min_issue_delay_len = (VEC_length (state_t, output_states_vect)\n \t\t\t * automaton->insn_equiv_classes_num);\n-  min_issue_delay_vect = VEC_alloc (vect_el_t,heap, min_issue_delay_len);\n+  min_issue_delay_vect = VEC_alloc (vect_el_t, heap, min_issue_delay_len);\n   for (i = 0; i < min_issue_delay_len; i++)\n     VEC_quick_push (vect_el_t, min_issue_delay_vect, 0);\n \n@@ -7501,7 +7621,7 @@ output_min_issue_delay_table (automaton_t automaton)\n \n   compressed_min_issue_delay_len = (min_issue_delay_len+cfactor-1) / cfactor;\n   compressed_min_issue_delay_vect\n-    = VEC_alloc (vect_el_t,heap, compressed_min_issue_delay_len);\n+    = VEC_alloc (vect_el_t, heap, compressed_min_issue_delay_len);\n \n   for (i = 0; i < compressed_min_issue_delay_len; i++)\n     VEC_quick_push (vect_el_t, compressed_min_issue_delay_vect, 0);\n@@ -7517,9 +7637,9 @@ output_min_issue_delay_table (automaton_t automaton)\n     }\n   output_vect (compressed_min_issue_delay_vect);\n   fprintf (output_file, \"};\\n\\n\");\n-  VEC_free (state_t,heap, output_states_vect);\n-  VEC_free (vect_el_t,heap, min_issue_delay_vect);\n-  VEC_free (vect_el_t,heap, compressed_min_issue_delay_vect);\n+  VEC_free (state_t, heap, output_states_vect);\n+  VEC_free (vect_el_t, heap, min_issue_delay_vect);\n+  VEC_free (vect_el_t, heap, compressed_min_issue_delay_vect);\n }\n \n /* Form and output vector representing the locked states of\n@@ -7538,7 +7658,7 @@ output_dead_lock_vect (automaton_t automaton)\n   output_states_vect = 0;\n   pass_states (automaton, add_states_vect_el);\n \n-  VEC_safe_grow (vect_el_t,heap, dead_lock_vect, \n+  VEC_safe_grow (vect_el_t, heap, dead_lock_vect, \n \t\t VEC_length (state_t, output_states_vect));\n   for (i = 0; i < VEC_length (state_t, output_states_vect); i++)\n     {\n@@ -7566,8 +7686,8 @@ output_dead_lock_vect (automaton_t automaton)\n   fprintf (output_file, \"[] = {\\n\");\n   output_vect (dead_lock_vect);\n   fprintf (output_file, \"};\\n\\n\");\n-  VEC_free (state_t,heap, output_states_vect);\n-  VEC_free (vect_el_t,heap, dead_lock_vect);\n+  VEC_free (state_t, heap, output_states_vect);\n+  VEC_free (vect_el_t, heap, dead_lock_vect);\n }\n \n /* Form and output vector representing reserved units of the states of\n@@ -7592,7 +7712,7 @@ output_reserved_units_table (automaton_t automaton)\n   reserved_units_size = (VEC_length (state_t, output_states_vect)\n \t\t\t * state_byte_size);\n \n-  reserved_units_table = VEC_alloc (vect_el_t,heap, reserved_units_size);\n+  reserved_units_table = VEC_alloc (vect_el_t, heap, reserved_units_size);\n \t\t \n   for (i = 0; i < reserved_units_size; i++)\n     VEC_quick_push (vect_el_t, reserved_units_table, 0);\n@@ -7622,8 +7742,8 @@ output_reserved_units_table (automaton_t automaton)\n   fprintf (output_file, \"};\\n#endif /* #if %s */\\n\\n\",\n \t   CPU_UNITS_QUERY_MACRO_NAME);\n \n-  VEC_free (state_t,heap, output_states_vect);\n-  VEC_free (vect_el_t,heap, reserved_units_table);\n+  VEC_free (state_t, heap, output_states_vect);\n+  VEC_free (vect_el_t, heap, reserved_units_table);\n }\n \n /* The function outputs all tables representing DFA(s) used for fast\n@@ -8728,7 +8848,7 @@ output_automaton_units (automaton_t automaton)\n \n /* The following variable is used for forming array of all possible cpu unit\n    reservations described by the current DFA state.  */\n-static VEC(reserv_sets_t,heap) *state_reservs;\n+static VEC(reserv_sets_t, heap) *state_reservs;\n \n /* The function forms `state_reservs' for STATE.  */\n static void\n@@ -8742,7 +8862,7 @@ add_state_reservs (state_t state)\n          curr_alt_state = curr_alt_state->next_sorted_alt_state)\n       add_state_reservs (curr_alt_state->state);\n   else\n-    VEC_safe_push (reserv_sets_t,heap, state_reservs, state->reservs);\n+    VEC_safe_push (reserv_sets_t, heap, state_reservs, state->reservs);\n }\n \n /* The function outputs readable representation of all out arcs of\n@@ -8840,7 +8960,7 @@ output_state (state_t state)\n \t VEC_length (reserv_sets_t, state_reservs),\n          sizeof (reserv_sets_t), state_reservs_cmp);\n   remove_state_duplicate_reservs ();\n-  for (i = 1; i < VEC_length (reserv_sets_t, state_reservs); i++)\n+  for (i = 0; i < VEC_length (reserv_sets_t, state_reservs); i++)\n     {\n       fprintf (output_description_file, \"    \");\n       output_reserv_sets (output_description_file,\n@@ -8849,7 +8969,7 @@ output_state (state_t state)\n     }\n   fprintf (output_description_file, \"\\n\");\n   output_state_arcs (state);\n-  VEC_free (reserv_sets_t,heap, state_reservs);\n+  VEC_free (reserv_sets_t, heap, state_reservs);\n }\n \n /* The following function output readable representation of\n@@ -9134,14 +9254,14 @@ check_automata_insn_issues (void)\n \n /* The following vla is used for storing pointers to all achieved\n    states.  */\n-static VEC(state_t,heap) *automaton_states;\n+static VEC(state_t, heap) *automaton_states;\n \n /* This function is called by function pass_states to add an achieved\n    STATE.  */\n static void\n add_automaton_state (state_t state)\n {\n-  VEC_safe_push (state_t,heap, automaton_states, state);\n+  VEC_safe_push (state_t, heap, automaton_states, state);\n }\n \n /* The following function forms list of important automata (whose\n@@ -9180,7 +9300,7 @@ form_important_insn_automata_lists (void)\n \t      }\n \t}\n     }\n-  VEC_free (state_t,heap, automaton_states);\n+  VEC_free (state_t, heap, automaton_states);\n \n   /* Create automata sets for the insns.  */\n   for (i = 0; i < description->decls_num; i++)\n@@ -9434,30 +9554,34 @@ main (int argc, char **argv)\n   if (have_error)\n     return FATAL_EXIT_CODE;\n \n-  puts (\"/* Generated automatically by the program `genautomata'\\n\"\n-\t\"   from the machine description file `md'.  */\\n\\n\"\n-\t\"#include \\\"config.h\\\"\\n\"\n-\t\"#include \\\"system.h\\\"\\n\"\n-\t\"#include \\\"coretypes.h\\\"\\n\"\n-\t\"#include \\\"tm.h\\\"\\n\"\n-\t\"#include \\\"rtl.h\\\"\\n\"\n-\t\"#include \\\"tm_p.h\\\"\\n\"\n-\t\"#include \\\"insn-config.h\\\"\\n\"\n-\t\"#include \\\"recog.h\\\"\\n\"\n-\t\"#include \\\"regs.h\\\"\\n\"\n-\t\"#include \\\"real.h\\\"\\n\"\n-\t\"#include \\\"output.h\\\"\\n\"\n-\t\"#include \\\"insn-attr.h\\\"\\n\"\n-\t\"#include \\\"toplev.h\\\"\\n\"\n-\t\"#include \\\"flags.h\\\"\\n\"\n-\t\"#include \\\"function.h\\\"\\n\");\n-\n   if (VEC_length (decl_t, decls) > 0)\n     {\n       expand_automata ();\n-      write_automata ();\n+      if (!have_error)\n+\t{\n+\t  puts (\"/* Generated automatically by the program `genautomata'\\n\"\n+\t\t\"   from the machine description file `md'.  */\\n\\n\"\n+\t\t\"#include \\\"config.h\\\"\\n\"\n+\t\t\"#include \\\"system.h\\\"\\n\"\n+\t\t\"#include \\\"coretypes.h\\\"\\n\"\n+\t\t\"#include \\\"tm.h\\\"\\n\"\n+\t\t\"#include \\\"rtl.h\\\"\\n\"\n+\t\t\"#include \\\"tm_p.h\\\"\\n\"\n+\t\t\"#include \\\"insn-config.h\\\"\\n\"\n+\t\t\"#include \\\"recog.h\\\"\\n\"\n+\t\t\"#include \\\"regs.h\\\"\\n\"\n+\t\t\"#include \\\"real.h\\\"\\n\"\n+\t\t\"#include \\\"output.h\\\"\\n\"\n+\t\t\"#include \\\"insn-attr.h\\\"\\n\"\n+\t\t\"#include \\\"toplev.h\\\"\\n\"\n+\t\t\"#include \\\"flags.h\\\"\\n\"\n+\t\t\"#include \\\"function.h\\\"\\n\");\n+\n+\t  write_automata ();\n+\t}\n     }\n \n   fflush (stdout);\n-  return (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);\n+  return (ferror (stdout) != 0 || have_error\n+\t  ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);\n }"}]}