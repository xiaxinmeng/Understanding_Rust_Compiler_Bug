{"sha": "8cad07cfd2244ad9a40027a4306b81b4553a4797", "node_id": "C_kwDOANBUbNoAKDhjYWQwN2NmZDIyNDRhZDlhNDAwMjdhNDMwNmI4MWI0NTUzYTQ3OTc", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-05-17T10:11:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-17T10:11:04Z"}, "message": "Merge #1246\n\n1246: Report simple privacy violations r=CohenArthur a=CohenArthur\n\nThis adds a base visitor for reporting basic privacy violations. For now, only function calls are implemented.\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "ce267318444308626518420adf10b563c2bad96c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce267318444308626518420adf10b563c2bad96c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8cad07cfd2244ad9a40027a4306b81b4553a4797", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJig3S4CRBK7hj4Ov3rIwAAon0IAC6FiS6TM8OVhwVl4e7W7CT+\nwZ6ri9oGAxEov4uzBLT1HwgAaLXFuSxCIcnlPWoEdIiOY8xyPpwSoPsYUIHVZSzx\nKzmmCGYKhlj0xZRW/rNeKhMcyPYWOPNsG0gc1OKdntfxqwF0sw0PvFna8+UzxZiP\nXnJHT22f0LjSkedueXZTfjo72bYfN4KTVLfOjmZC5os6ji4Y71eL2Ur8AyvHhgja\nQu72q2FmAvAjvxEeox67Qx89dvqwID/mDEl+rm58Zm7B6Zi1Rccbneio5AAXOnFY\nQj7+5Az6Q6nLJhsWiPEFokthr4rs/gujDRgqHCM7CauIr8zJKj9aQ2Y3zyIMgt0=\n=QxRM\n-----END PGP SIGNATURE-----\n", "payload": "tree ce267318444308626518420adf10b563c2bad96c\nparent e4213b9568ae8cb8a4e31326e0e78c79db0a99cc\nparent 48fc2df91b07709f41ab80499a661ac9f12f3be3\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1652782264 +0000\ncommitter GitHub <noreply@github.com> 1652782264 +0000\n\nMerge #1246\n\n1246: Report simple privacy violations r=CohenArthur a=CohenArthur\n\nThis adds a base visitor for reporting basic privacy violations. For now, only function calls are implemented.\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cad07cfd2244ad9a40027a4306b81b4553a4797", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cad07cfd2244ad9a40027a4306b81b4553a4797", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cad07cfd2244ad9a40027a4306b81b4553a4797/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4213b9568ae8cb8a4e31326e0e78c79db0a99cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4213b9568ae8cb8a4e31326e0e78c79db0a99cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4213b9568ae8cb8a4e31326e0e78c79db0a99cc"}, {"sha": "48fc2df91b07709f41ab80499a661ac9f12f3be3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48fc2df91b07709f41ab80499a661ac9f12f3be3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48fc2df91b07709f41ab80499a661ac9f12f3be3"}], "stats": {"total": 1262, "additions": 1164, "deletions": 98}, "files": [{"sha": "f87ad5476226cdc95aa24ad2a8fb20543c3135fe", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=8cad07cfd2244ad9a40027a4306b81b4553a4797", "patch": "@@ -100,6 +100,7 @@ GRS_OBJS = \\\n     rust/rust-reachability.o \\\n     rust/rust-visibility-resolver.o \\\n     rust/rust-pub-restricted-visitor.o \\\n+    rust/rust-privacy-reporter.o \\\n     rust/rust-tyty.o \\\n     rust/rust-tyctx.o \\\n     rust/rust-tyty-bounds.o \\\n@@ -120,6 +121,7 @@ GRS_OBJS = \\\n     rust/rust-compile-pattern.o \\\n     rust/rust-compile-fnparam.o \\\n     rust/rust-base62.o \\\n+    rust/rust-optional-test.o \\\n     rust/rust-compile-item.o \\\n     rust/rust-compile-implitem.o \\\n     rust/rust-compile-expr.o \\"}, {"sha": "dca5235806f9092da4fa3b96640f10e1a7394a5a", "filename": "gcc/rust/privacy/rust-privacy-check.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Fprivacy%2Frust-privacy-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Fprivacy%2Frust-privacy-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fprivacy%2Frust-privacy-check.cc?ref=8cad07cfd2244ad9a40027a4306b81b4553a4797", "patch": "@@ -23,6 +23,7 @@\n #include \"rust-name-resolver.h\"\n #include \"rust-visibility-resolver.h\"\n #include \"rust-pub-restricted-visitor.h\"\n+#include \"rust-privacy-reporter.h\"\n \n extern bool\n saw_errors (void);\n@@ -40,6 +41,7 @@ Resolver::resolve (HIR::Crate &crate)\n \n   VisibilityResolver (*mappings, *resolver).go (crate);\n   PubRestrictedVisitor (*mappings).go (crate);\n+  PrivacyReporter (*mappings, *resolver).go (crate);\n \n   auto visitor = ReachabilityVisitor (ctx, *ty_ctx);\n "}, {"sha": "ceafe91d8867e2cd2b88c22f3dd2ca68b35f2fc8", "filename": "gcc/rust/privacy/rust-privacy-common.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Fprivacy%2Frust-privacy-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Fprivacy%2Frust-privacy-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fprivacy%2Frust-privacy-common.h?ref=8cad07cfd2244ad9a40027a4306b81b4553a4797", "patch": "@@ -24,14 +24,16 @@ namespace Privacy {\n /**\n  * Visibility class related specifically to DefIds. This class allows defining\n  * the visibility of an item with regard to a specific module.\n+ *\n+ * Items are either public throughout a crate, or restricted to a specific\n+ * module. Private items are simply restricted to the current module.\n  */\n class ModuleVisibility\n {\n public:\n   enum Type\n   {\n     Unknown,\n-    Private,\n     Public,\n     Restricted,\n   };"}, {"sha": "4c18adb8615eecfaccd1b65ff402ee6b4c4a0af5", "filename": "gcc/rust/privacy/rust-privacy-reporter.cc", "status": "added", "additions": 645, "deletions": 0, "changes": 645, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Fprivacy%2Frust-privacy-reporter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Fprivacy%2Frust-privacy-reporter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fprivacy%2Frust-privacy-reporter.cc?ref=8cad07cfd2244ad9a40027a4306b81b4553a4797", "patch": "@@ -0,0 +1,645 @@\n+#include \"rust-privacy-reporter.h\"\n+#include \"rust-hir-expr.h\"\n+#include \"rust-hir-stmt.h\"\n+#include \"rust-hir-item.h\"\n+\n+namespace Rust {\n+namespace Privacy {\n+\n+PrivacyReporter::PrivacyReporter (Analysis::Mappings &mappings,\n+\t\t\t\t  Resolver::Resolver &resolver)\n+  : mappings (mappings), resolver (resolver),\n+    current_module (Optional<NodeId>::none ())\n+{}\n+\n+void\n+PrivacyReporter::go (HIR::Crate &crate)\n+{\n+  for (auto &item : crate.items)\n+    item->accept_vis (*this);\n+}\n+\n+static bool\n+is_child_module (NodeId current_module,\n+\t\t Optional<std::vector<NodeId> &> children)\n+{\n+  if (!children)\n+    return false;\n+\n+  // FIXME: This checks for one step - we need to go deeper\n+  for (auto &child : *children)\n+    if (child == current_module)\n+      return true;\n+\n+  return false;\n+}\n+\n+// FIXME: This function needs a lot of refactoring\n+void\n+PrivacyReporter::check_for_privacy_violation (const NodeId &use_id,\n+\t\t\t\t\t      const Location &locus)\n+{\n+  NodeId ref_node_id;\n+\n+  // FIXME: Don't assert here - we might be dealing with a type\n+  rust_assert (resolver.lookup_resolved_name (use_id, &ref_node_id));\n+\n+  ModuleVisibility vis;\n+\n+  // FIXME: Can we really return here if the item has no visibility?\n+  if (!mappings.lookup_visibility (ref_node_id, vis))\n+    return;\n+\n+  auto valid = true;\n+\n+  switch (vis.get_kind ())\n+    {\n+    case ModuleVisibility::Public:\n+      break;\n+      case ModuleVisibility::Restricted: {\n+\t// If we are in the crate, everything is restricted correctly, but we\n+\t// can't get a module for it\n+\tif (current_module.is_none ())\n+\t  return;\n+\n+\tauto module = mappings.lookup_defid (vis.get_module_id ());\n+\trust_assert (module != nullptr);\n+\n+\tauto mod_node_id = module->get_mappings ().get_nodeid ();\n+\n+\t// We are in the module referenced by the pub(restricted) visibility.\n+\t// This is valid\n+\tif (mod_node_id == current_module.get ())\n+\t  break;\n+\n+\tauto children = mappings.lookup_module_children (mod_node_id);\n+\n+\t// FIXME: This needs a LOT of TLC: hinting about the definition, a\n+\t// string to say if it's a module, function, type, etc...\n+\tif (!is_child_module (current_module.get (), children))\n+\t  valid = false;\n+      }\n+      break;\n+    case ModuleVisibility::Unknown:\n+      rust_unreachable ();\n+      break;\n+    }\n+\n+  if (!valid)\n+    rust_error_at (locus, \"definition is private in this context\");\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::IdentifierExpr &ident_expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::Lifetime &lifetime)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::LifetimeParam &lifetime_param)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::PathInExpression &path)\n+{\n+  check_for_privacy_violation (path.get_mappings ().get_nodeid (),\n+\t\t\t       path.get_locus ());\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::TypePathSegment &segment)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::TypePathSegmentGeneric &segment)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::TypePathSegmentFunction &segment)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::TypePath &path)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::QualifiedPathInExpression &path)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::QualifiedPathInType &path)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::LiteralExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::BorrowExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::DereferenceExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::ErrorPropagationExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::NegationExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::ArithmeticOrLogicalExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::ComparisonExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::LazyBooleanExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::TypeCastExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::AssignmentExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::CompoundAssignmentExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::GroupedExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::ArrayElemsValues &elems)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::ArrayElemsCopied &elems)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::ArrayExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::ArrayIndexExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::TupleExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::TupleIndexExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::StructExprStruct &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::StructExprFieldIdentifier &field)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::StructExprFieldIdentifierValue &field)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::StructExprFieldIndexValue &field)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::StructExprStructFields &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::StructExprStructBase &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::CallExpr &expr)\n+{\n+  expr.get_fnexpr ()->accept_vis (*this);\n+\n+  // rust_assert (mappings.lookup_visibility (definition_id, def_vis));\n+  // check_for_privacy_violation (def_vis, expr.get_locus ());\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::MethodCallExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::FieldAccessExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::ClosureExprInner &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::BlockExpr &expr)\n+{\n+  for (auto &stmt : expr.get_statements ())\n+    stmt->accept_vis (*this);\n+\n+  auto &last_expr = expr.get_final_expr ();\n+  if (last_expr)\n+    last_expr->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::ClosureExprInnerTyped &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::ContinueExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::BreakExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::RangeFromToExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::RangeFromExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::RangeToExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::RangeFullExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::RangeFromToInclExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::RangeToInclExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::ReturnExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::UnsafeBlockExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::LoopExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::WhileLoopExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::WhileLetLoopExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::ForLoopExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::IfExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::IfExprConseqElse &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::IfExprConseqIf &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::IfExprConseqIfLet &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::IfLetExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::IfLetExprConseqElse &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::IfLetExprConseqIf &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::IfLetExprConseqIfLet &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::MatchExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::AwaitExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::AsyncBlockExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::TypeParam &param)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::LifetimeWhereClauseItem &item)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::TypeBoundWhereClauseItem &item)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::Module &module)\n+{\n+  auto old_module = current_module;\n+  current_module\n+    = Optional<NodeId>::some (module.get_mappings ().get_nodeid ());\n+\n+  for (auto &item : module.get_items ())\n+    item->accept_vis (*this);\n+\n+  current_module = old_module;\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::ExternCrate &crate)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::UseTreeGlob &use_tree)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::UseTreeList &use_tree)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::UseTreeRebind &use_tree)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::UseDeclaration &use_decl)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::Function &function)\n+{\n+  function.get_definition ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::TypeAlias &type_alias)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::StructStruct &struct_item)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::TupleStruct &tuple_struct)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::EnumItem &item)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::EnumItemTuple &item)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::EnumItemStruct &item)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::EnumItemDiscriminant &item)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::Enum &enum_item)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::Union &union_item)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::ConstantItem &const_item)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::StaticItem &static_item)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::TraitItemFunc &item)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::TraitItemConst &item)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::TraitItemType &item)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::Trait &trait)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::ImplBlock &impl)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::ExternalStaticItem &item)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::ExternalFunctionItem &item)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::ExternBlock &block)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::LiteralPattern &pattern)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::IdentifierPattern &pattern)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::WildcardPattern &pattern)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::RangePatternBoundLiteral &bound)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::RangePatternBoundPath &bound)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::RangePatternBoundQualPath &bound)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::RangePattern &pattern)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::ReferencePattern &pattern)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::StructPatternFieldTuplePat &field)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::StructPatternFieldIdentPat &field)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::StructPatternFieldIdent &field)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::StructPattern &pattern)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::TupleStructItemsNoRange &tuple_items)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::TupleStructItemsRange &tuple_items)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::TupleStructPattern &pattern)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::TuplePatternItemsMultiple &tuple_items)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::TuplePatternItemsRanged &tuple_items)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::TuplePattern &pattern)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::GroupedPattern &pattern)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::SlicePattern &pattern)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::EmptyStmt &stmt)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::LetStmt &stmt)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::ExprStmtWithoutBlock &stmt)\n+{\n+  stmt.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::ExprStmtWithBlock &stmt)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::TraitBound &bound)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::ImplTraitType &type)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::TraitObjectType &type)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::ParenthesisedType &type)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::ImplTraitTypeOneBound &type)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::TupleType &type)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::NeverType &type)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::RawPointerType &type)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::ReferenceType &type)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::ArrayType &type)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::SliceType &type)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::InferredType &type)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::BareFunctionType &type)\n+{}\n+\n+} // namespace Privacy\n+} // namespace Rust"}, {"sha": "fafcec1edac808465f65cf04e23ddd014b860913", "filename": "gcc/rust/privacy/rust-privacy-reporter.h", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Fprivacy%2Frust-privacy-reporter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Fprivacy%2Frust-privacy-reporter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fprivacy%2Frust-privacy-reporter.h?ref=8cad07cfd2244ad9a40027a4306b81b4553a4797", "patch": "@@ -0,0 +1,201 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_PRIVACY_REPORTER_H\n+#define RUST_PRIVACY_REPORTER_H\n+\n+#include \"rust-hir-map.h\"\n+#include \"rust-hir-visitor.h\"\n+#include \"rust-mapping-common.h\"\n+#include \"rust-name-resolver.h\"\n+\n+namespace Rust {\n+namespace Privacy {\n+\n+/**\n+ * This visitor visits all items and expressions of a crate and reports privacy\n+ * violations. It should be started after using the `VisibilityResolver` visitor\n+ * which resolves the visibilities of all items of a crate.\n+ */\n+class PrivacyReporter : public HIR::HIRFullVisitor\n+{\n+public:\n+  PrivacyReporter (Analysis::Mappings &mappings,\n+\t\t   Rust::Resolver::Resolver &resolver);\n+\n+  /**\n+   * Perform privacy error reporting on an entire crate\n+   */\n+  void go (HIR::Crate &crate);\n+\n+private:\n+  /**\n+   * Check if a given item's visibility is accessible from the current module.\n+   *\n+   * This function reports the errors it finds.\n+   *\n+   * @param use_id NodeId of the expression/statement referencing an item with\n+   * \t\ta visibility\n+   * @param locus Location of said expression/statement\n+   */\n+  void check_for_privacy_violation (const NodeId &use_id,\n+\t\t\t\t    const Location &locus);\n+\n+  virtual void visit (HIR::IdentifierExpr &ident_expr);\n+  virtual void visit (HIR::Lifetime &lifetime);\n+  virtual void visit (HIR::LifetimeParam &lifetime_param);\n+  virtual void visit (HIR::PathInExpression &path);\n+  virtual void visit (HIR::TypePathSegment &segment);\n+  virtual void visit (HIR::TypePathSegmentGeneric &segment);\n+  virtual void visit (HIR::TypePathSegmentFunction &segment);\n+  virtual void visit (HIR::TypePath &path);\n+  virtual void visit (HIR::QualifiedPathInExpression &path);\n+  virtual void visit (HIR::QualifiedPathInType &path);\n+  virtual void visit (HIR::LiteralExpr &expr);\n+  virtual void visit (HIR::BorrowExpr &expr);\n+  virtual void visit (HIR::DereferenceExpr &expr);\n+  virtual void visit (HIR::ErrorPropagationExpr &expr);\n+  virtual void visit (HIR::NegationExpr &expr);\n+  virtual void visit (HIR::ArithmeticOrLogicalExpr &expr);\n+  virtual void visit (HIR::ComparisonExpr &expr);\n+  virtual void visit (HIR::LazyBooleanExpr &expr);\n+  virtual void visit (HIR::TypeCastExpr &expr);\n+  virtual void visit (HIR::AssignmentExpr &expr);\n+  virtual void visit (HIR::CompoundAssignmentExpr &expr);\n+  virtual void visit (HIR::GroupedExpr &expr);\n+  virtual void visit (HIR::ArrayElemsValues &elems);\n+  virtual void visit (HIR::ArrayElemsCopied &elems);\n+  virtual void visit (HIR::ArrayExpr &expr);\n+  virtual void visit (HIR::ArrayIndexExpr &expr);\n+  virtual void visit (HIR::TupleExpr &expr);\n+  virtual void visit (HIR::TupleIndexExpr &expr);\n+  virtual void visit (HIR::StructExprStruct &expr);\n+  virtual void visit (HIR::StructExprFieldIdentifier &field);\n+  virtual void visit (HIR::StructExprFieldIdentifierValue &field);\n+  virtual void visit (HIR::StructExprFieldIndexValue &field);\n+  virtual void visit (HIR::StructExprStructFields &expr);\n+  virtual void visit (HIR::StructExprStructBase &expr);\n+  virtual void visit (HIR::CallExpr &expr);\n+  virtual void visit (HIR::MethodCallExpr &expr);\n+  virtual void visit (HIR::FieldAccessExpr &expr);\n+  virtual void visit (HIR::ClosureExprInner &expr);\n+  virtual void visit (HIR::BlockExpr &expr);\n+  virtual void visit (HIR::ClosureExprInnerTyped &expr);\n+  virtual void visit (HIR::ContinueExpr &expr);\n+  virtual void visit (HIR::BreakExpr &expr);\n+  virtual void visit (HIR::RangeFromToExpr &expr);\n+  virtual void visit (HIR::RangeFromExpr &expr);\n+  virtual void visit (HIR::RangeToExpr &expr);\n+  virtual void visit (HIR::RangeFullExpr &expr);\n+  virtual void visit (HIR::RangeFromToInclExpr &expr);\n+  virtual void visit (HIR::RangeToInclExpr &expr);\n+  virtual void visit (HIR::ReturnExpr &expr);\n+  virtual void visit (HIR::UnsafeBlockExpr &expr);\n+  virtual void visit (HIR::LoopExpr &expr);\n+  virtual void visit (HIR::WhileLoopExpr &expr);\n+  virtual void visit (HIR::WhileLetLoopExpr &expr);\n+  virtual void visit (HIR::ForLoopExpr &expr);\n+  virtual void visit (HIR::IfExpr &expr);\n+  virtual void visit (HIR::IfExprConseqElse &expr);\n+  virtual void visit (HIR::IfExprConseqIf &expr);\n+  virtual void visit (HIR::IfExprConseqIfLet &expr);\n+  virtual void visit (HIR::IfLetExpr &expr);\n+  virtual void visit (HIR::IfLetExprConseqElse &expr);\n+  virtual void visit (HIR::IfLetExprConseqIf &expr);\n+  virtual void visit (HIR::IfLetExprConseqIfLet &expr);\n+  virtual void visit (HIR::MatchExpr &expr);\n+  virtual void visit (HIR::AwaitExpr &expr);\n+  virtual void visit (HIR::AsyncBlockExpr &expr);\n+  virtual void visit (HIR::TypeParam &param);\n+  virtual void visit (HIR::LifetimeWhereClauseItem &item);\n+  virtual void visit (HIR::TypeBoundWhereClauseItem &item);\n+  virtual void visit (HIR::Module &module);\n+  virtual void visit (HIR::ExternCrate &crate);\n+  virtual void visit (HIR::UseTreeGlob &use_tree);\n+  virtual void visit (HIR::UseTreeList &use_tree);\n+  virtual void visit (HIR::UseTreeRebind &use_tree);\n+  virtual void visit (HIR::UseDeclaration &use_decl);\n+  virtual void visit (HIR::Function &function);\n+  virtual void visit (HIR::TypeAlias &type_alias);\n+  virtual void visit (HIR::StructStruct &struct_item);\n+  virtual void visit (HIR::TupleStruct &tuple_struct);\n+  virtual void visit (HIR::EnumItem &item);\n+  virtual void visit (HIR::EnumItemTuple &item);\n+  virtual void visit (HIR::EnumItemStruct &item);\n+  virtual void visit (HIR::EnumItemDiscriminant &item);\n+  virtual void visit (HIR::Enum &enum_item);\n+  virtual void visit (HIR::Union &union_item);\n+  virtual void visit (HIR::ConstantItem &const_item);\n+  virtual void visit (HIR::StaticItem &static_item);\n+  virtual void visit (HIR::TraitItemFunc &item);\n+  virtual void visit (HIR::TraitItemConst &item);\n+  virtual void visit (HIR::TraitItemType &item);\n+  virtual void visit (HIR::Trait &trait);\n+  virtual void visit (HIR::ImplBlock &impl);\n+  virtual void visit (HIR::ExternalStaticItem &item);\n+  virtual void visit (HIR::ExternalFunctionItem &item);\n+  virtual void visit (HIR::ExternBlock &block);\n+  virtual void visit (HIR::LiteralPattern &pattern);\n+  virtual void visit (HIR::IdentifierPattern &pattern);\n+  virtual void visit (HIR::WildcardPattern &pattern);\n+  virtual void visit (HIR::RangePatternBoundLiteral &bound);\n+  virtual void visit (HIR::RangePatternBoundPath &bound);\n+  virtual void visit (HIR::RangePatternBoundQualPath &bound);\n+  virtual void visit (HIR::RangePattern &pattern);\n+  virtual void visit (HIR::ReferencePattern &pattern);\n+  virtual void visit (HIR::StructPatternFieldTuplePat &field);\n+  virtual void visit (HIR::StructPatternFieldIdentPat &field);\n+  virtual void visit (HIR::StructPatternFieldIdent &field);\n+  virtual void visit (HIR::StructPattern &pattern);\n+  virtual void visit (HIR::TupleStructItemsNoRange &tuple_items);\n+  virtual void visit (HIR::TupleStructItemsRange &tuple_items);\n+  virtual void visit (HIR::TupleStructPattern &pattern);\n+  virtual void visit (HIR::TuplePatternItemsMultiple &tuple_items);\n+  virtual void visit (HIR::TuplePatternItemsRanged &tuple_items);\n+  virtual void visit (HIR::TuplePattern &pattern);\n+  virtual void visit (HIR::GroupedPattern &pattern);\n+  virtual void visit (HIR::SlicePattern &pattern);\n+  virtual void visit (HIR::EmptyStmt &stmt);\n+  virtual void visit (HIR::LetStmt &stmt);\n+  virtual void visit (HIR::ExprStmtWithoutBlock &stmt);\n+  virtual void visit (HIR::ExprStmtWithBlock &stmt);\n+  virtual void visit (HIR::TraitBound &bound);\n+  virtual void visit (HIR::ImplTraitType &type);\n+  virtual void visit (HIR::TraitObjectType &type);\n+  virtual void visit (HIR::ParenthesisedType &type);\n+  virtual void visit (HIR::ImplTraitTypeOneBound &type);\n+  virtual void visit (HIR::TupleType &type);\n+  virtual void visit (HIR::NeverType &type);\n+  virtual void visit (HIR::RawPointerType &type);\n+  virtual void visit (HIR::ReferenceType &type);\n+  virtual void visit (HIR::ArrayType &type);\n+  virtual void visit (HIR::SliceType &type);\n+  virtual void visit (HIR::InferredType &type);\n+  virtual void visit (HIR::BareFunctionType &type);\n+\n+  Analysis::Mappings &mappings;\n+  Rust::Resolver::Resolver &resolver;\n+\n+  // `None` means we're in the root module - the crate\n+  Optional<NodeId> current_module;\n+};\n+\n+} // namespace Privacy\n+} // namespace Rust\n+\n+#endif // !RUST_PRIVACY_REPORTER_H"}, {"sha": "e391653ea26f392daa19e5d52b88d7ac8ccb8a12", "filename": "gcc/rust/privacy/rust-pub-restricted-visitor.cc", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Fprivacy%2Frust-pub-restricted-visitor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Fprivacy%2Frust-pub-restricted-visitor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fprivacy%2Frust-pub-restricted-visitor.cc?ref=8cad07cfd2244ad9a40027a4306b81b4553a4797", "patch": "@@ -24,14 +24,15 @@ namespace Rust {\n namespace Privacy {\n \n bool\n-PubRestrictedVisitor::is_restriction_valid (DefId item_id,\n+PubRestrictedVisitor::is_restriction_valid (NodeId item_id,\n \t\t\t\t\t    const Location &locus)\n {\n   ModuleVisibility visibility;\n \n   // If there is no visibility in the mappings, then the item is private and\n   // does not contain any restriction\n-  if (!mappings.lookup_visibility (item_id, &visibility))\n+  // FIXME: Is that correct?\n+  if (!mappings.lookup_visibility (item_id, visibility))\n     return true;\n \n   for (auto mod = module_stack.rbegin (); mod != module_stack.rend (); mod++)\n@@ -72,7 +73,7 @@ PubRestrictedVisitor::visit (HIR::Module &mod)\n   // FIXME: We need to update `super` and `self` here\n   module_stack.push_back (mod.get_mappings ().get_defid ());\n \n-  is_restriction_valid (mod.get_mappings ().get_defid (), mod.get_locus ());\n+  is_restriction_valid (mod.get_mappings ().get_nodeid (), mod.get_locus ());\n \n   for (auto &item : mod.get_items ())\n     {\n@@ -89,89 +90,92 @@ PubRestrictedVisitor::visit (HIR::Module &mod)\n void\n PubRestrictedVisitor::visit (HIR::ExternCrate &crate)\n {\n-  is_restriction_valid (crate.get_mappings ().get_defid (), crate.get_locus ());\n+  is_restriction_valid (crate.get_mappings ().get_nodeid (),\n+\t\t\tcrate.get_locus ());\n }\n \n void\n PubRestrictedVisitor::visit (HIR::UseDeclaration &use_decl)\n {\n-  is_restriction_valid (use_decl.get_mappings ().get_defid (),\n+  is_restriction_valid (use_decl.get_mappings ().get_nodeid (),\n \t\t\tuse_decl.get_locus ());\n }\n \n void\n PubRestrictedVisitor::visit (HIR::Function &func)\n {\n-  is_restriction_valid (func.get_mappings ().get_defid (), func.get_locus ());\n+  is_restriction_valid (func.get_mappings ().get_nodeid (), func.get_locus ());\n }\n \n void\n PubRestrictedVisitor::visit (HIR::TypeAlias &type_alias)\n {\n-  is_restriction_valid (type_alias.get_mappings ().get_defid (),\n+  is_restriction_valid (type_alias.get_mappings ().get_nodeid (),\n \t\t\ttype_alias.get_locus ());\n }\n \n void\n PubRestrictedVisitor::visit (HIR::StructStruct &struct_item)\n {\n-  is_restriction_valid (struct_item.get_mappings ().get_defid (),\n+  is_restriction_valid (struct_item.get_mappings ().get_nodeid (),\n \t\t\tstruct_item.get_locus ());\n   // FIXME: Check fields here as well\n }\n \n void\n PubRestrictedVisitor::visit (HIR::TupleStruct &tuple_struct)\n {\n-  is_restriction_valid (tuple_struct.get_mappings ().get_defid (),\n+  is_restriction_valid (tuple_struct.get_mappings ().get_nodeid (),\n \t\t\ttuple_struct.get_locus ());\n   // FIXME: Check fields here as well\n }\n \n void\n PubRestrictedVisitor::visit (HIR::Enum &enum_item)\n {\n-  is_restriction_valid (enum_item.get_mappings ().get_defid (),\n+  is_restriction_valid (enum_item.get_mappings ().get_nodeid (),\n \t\t\tenum_item.get_locus ());\n }\n \n void\n PubRestrictedVisitor::visit (HIR::Union &union_item)\n {\n-  is_restriction_valid (union_item.get_mappings ().get_defid (),\n+  is_restriction_valid (union_item.get_mappings ().get_nodeid (),\n \t\t\tunion_item.get_locus ());\n }\n \n void\n PubRestrictedVisitor::visit (HIR::ConstantItem &const_item)\n {\n-  is_restriction_valid (const_item.get_mappings ().get_defid (),\n+  is_restriction_valid (const_item.get_mappings ().get_nodeid (),\n \t\t\tconst_item.get_locus ());\n }\n \n void\n PubRestrictedVisitor::visit (HIR::StaticItem &static_item)\n {\n-  is_restriction_valid (static_item.get_mappings ().get_defid (),\n+  is_restriction_valid (static_item.get_mappings ().get_nodeid (),\n \t\t\tstatic_item.get_locus ());\n }\n \n void\n PubRestrictedVisitor::visit (HIR::Trait &trait)\n {\n-  is_restriction_valid (trait.get_mappings ().get_defid (), trait.get_locus ());\n+  is_restriction_valid (trait.get_mappings ().get_nodeid (),\n+\t\t\ttrait.get_locus ());\n }\n \n void\n PubRestrictedVisitor::visit (HIR::ImplBlock &impl)\n {\n-  is_restriction_valid (impl.get_mappings ().get_defid (), impl.get_locus ());\n+  is_restriction_valid (impl.get_mappings ().get_nodeid (), impl.get_locus ());\n }\n \n void\n PubRestrictedVisitor::visit (HIR::ExternBlock &block)\n {\n-  is_restriction_valid (block.get_mappings ().get_defid (), block.get_locus ());\n+  is_restriction_valid (block.get_mappings ().get_nodeid (),\n+\t\t\tblock.get_locus ());\n }\n \n } // namespace Privacy"}, {"sha": "2685f3d1488a421c8fdf6a2029b5c3d517adaddb", "filename": "gcc/rust/privacy/rust-pub-restricted-visitor.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Fprivacy%2Frust-pub-restricted-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Fprivacy%2Frust-pub-restricted-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fprivacy%2Frust-pub-restricted-visitor.h?ref=8cad07cfd2244ad9a40027a4306b81b4553a4797", "patch": "@@ -82,12 +82,12 @@ class PubRestrictedVisitor : public HIR::HIRVisItemVisitor\n    *\n    * In case of error, this function will emit the errors and return.\n    *\n-   * @param item_id DefId of the item to check the restriction of\n+   * @param item_id NodeId of the item to check the restriction of\n    * @param locus Location of the item being checked\n    *\n    * @return true if the visibility restriction is valid, false otherwise.\n    */\n-  bool is_restriction_valid (DefId item_id, const Location &locus);\n+  bool is_restriction_valid (NodeId item_id, const Location &locus);\n \n   virtual void visit (HIR::Module &mod);\n   virtual void visit (HIR::ExternCrate &crate);"}, {"sha": "421dff0ef3dfb690b269c250b7970b909ae96b8b", "filename": "gcc/rust/privacy/rust-visibility-resolver.cc", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Fprivacy%2Frust-visibility-resolver.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Fprivacy%2Frust-visibility-resolver.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fprivacy%2Frust-visibility-resolver.cc?ref=8cad07cfd2244ad9a40027a4306b81b4553a4797", "patch": "@@ -32,9 +32,11 @@ VisibilityResolver::VisibilityResolver (Analysis::Mappings &mappings,\n void\n VisibilityResolver::go (HIR::Crate &crate)\n {\n-  mappings.insert_visibility (crate.get_mappings ().get_defid (),\n+  mappings.insert_visibility (crate.get_mappings ().get_nodeid (),\n \t\t\t      ModuleVisibility::create_public ());\n \n+  current_module = crate.get_mappings ().get_defid ();\n+\n   for (auto &item : crate.items)\n     {\n       if (item->get_hir_kind () == HIR::Node::VIS_ITEM)\n@@ -103,15 +105,18 @@ VisibilityResolver::resolve_visibility (const HIR::Visibility &visibility,\n   switch (visibility.get_vis_type ())\n     {\n     case HIR::Visibility::PRIVATE:\n+      to_resolve = ModuleVisibility::create_restricted (current_module);\n       return true;\n     case HIR::Visibility::PUBLIC:\n       to_resolve = ModuleVisibility::create_public ();\n       return true;\n-    case HIR::Visibility::RESTRICTED:\n-      // FIXME: We also need to handle 2015 vs 2018 edition conflicts\n-      to_resolve = ModuleVisibility::create_public ();\n-      return resolve_module_path (visibility.get_path (),\n-\t\t\t\t  to_resolve.get_module_id ());\n+      case HIR::Visibility::RESTRICTED: {\n+\t// FIXME: We also need to handle 2015 vs 2018 edition conflicts\n+\tauto id = UNKNOWN_DEFID;\n+\tauto result = resolve_module_path (visibility.get_path (), id);\n+\tto_resolve = ModuleVisibility::create_restricted (id);\n+\treturn result;\n+      }\n     default:\n       gcc_unreachable ();\n       return false;\n@@ -125,12 +130,15 @@ VisibilityResolver::resolve_and_update (const HIR::VisItem *item)\n   if (!resolve_visibility (item->get_visibility (), module_vis))\n     return; // we will already have emitted errors\n \n-  mappings.insert_visibility (item->get_mappings ().get_defid (), module_vis);\n+  mappings.insert_visibility (item->get_mappings ().get_nodeid (), module_vis);\n }\n \n void\n VisibilityResolver::visit (HIR::Module &mod)\n {\n+  auto old_module = current_module;\n+  current_module = mod.get_mappings ().get_defid ();\n+\n   for (auto &item : mod.get_items ())\n     {\n       if (item->get_hir_kind () == HIR::Node::VIS_ITEM)\n@@ -139,6 +147,8 @@ VisibilityResolver::visit (HIR::Module &mod)\n \t  vis_item->accept_vis (*this);\n \t}\n     }\n+\n+  current_module = old_module;\n }\n \n void\n@@ -180,9 +190,9 @@ VisibilityResolver::visit (HIR::Enum &enum_item)\n   if (!resolve_visibility (enum_item.get_visibility (), vis))\n     return;\n \n-  mappings.insert_visibility (enum_item.get_mappings ().get_defid (), vis);\n+  mappings.insert_visibility (enum_item.get_mappings ().get_nodeid (), vis);\n   for (auto &variant : enum_item.get_variants ())\n-    mappings.insert_visibility (variant->get_mappings ().get_defid (), vis);\n+    mappings.insert_visibility (variant->get_mappings ().get_nodeid (), vis);\n }\n \n void\n@@ -208,9 +218,9 @@ VisibilityResolver::visit (HIR::Trait &trait)\n   if (!resolve_visibility (trait.get_visibility (), vis))\n     return;\n \n-  mappings.insert_visibility (trait.get_mappings ().get_defid (), vis);\n+  mappings.insert_visibility (trait.get_mappings ().get_nodeid (), vis);\n   for (auto &item : trait.get_trait_items ())\n-    mappings.insert_visibility (item->get_mappings ().get_defid (), vis);\n+    mappings.insert_visibility (item->get_mappings ().get_nodeid (), vis);\n }\n \n void"}, {"sha": "20a581c16d4a3a485e8917ddb3e2de2dd4dd920d", "filename": "gcc/rust/privacy/rust-visibility-resolver.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Fprivacy%2Frust-visibility-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Fprivacy%2Frust-visibility-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fprivacy%2Frust-visibility-resolver.h?ref=8cad07cfd2244ad9a40027a4306b81b4553a4797", "patch": "@@ -94,6 +94,7 @@ class VisibilityResolver : public HIR::HIRVisItemVisitor\n private:\n   Analysis::Mappings &mappings;\n   Rust::Resolver::Resolver &resolver;\n+  DefId current_module;\n };\n \n } // namespace Privacy"}, {"sha": "9c1f0a10ac8d78eecad97f4ce0df6040b4366bfc", "filename": "gcc/rust/resolve/rust-ast-resolve-base.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h?ref=8cad07cfd2244ad9a40027a4306b81b4553a4797", "patch": "@@ -199,9 +199,10 @@ class ResolverBase : public AST::ASTVisitor\n   void visit (AST::BareFunctionType &);\n \n protected:\n-  ResolverBase (NodeId parent)\n+  ResolverBase (NodeId parent, NodeId current_module = UNKNOWN_NODEID)\n     : resolver (Resolver::get ()), mappings (Analysis::Mappings::get ()),\n-      resolved_node (UNKNOWN_NODEID), parent (parent), locus (Location ())\n+      resolved_node (UNKNOWN_NODEID), parent (parent),\n+      current_module (current_module), locus (Location ())\n   {}\n \n   bool resolved () const { return resolved_node != UNKNOWN_NODEID; }\n@@ -215,6 +216,7 @@ class ResolverBase : public AST::ASTVisitor\n   Analysis::Mappings *mappings;\n   NodeId resolved_node;\n   NodeId parent;\n+  NodeId current_module;\n   Location locus;\n };\n "}, {"sha": "38e7713e45dfd603465cc33c5afeae2fda8c66e1", "filename": "gcc/rust/resolve/rust-ast-resolve-item.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc?ref=8cad07cfd2244ad9a40027a4306b81b4553a4797", "patch": "@@ -250,8 +250,11 @@ ResolveItem::visit (AST::Module &module)\n   resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n   resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n \n+  // FIXME: Should we reinsert a child here? Any reason we ResolveTopLevel::go\n+  // in ResolveTopLevel::visit (AST::Module) as well as here?\n   for (auto &item : module.get_items ())\n-    ResolveTopLevel::go (item.get (), CanonicalPath::create_empty (), cpath);\n+    ResolveTopLevel::go (item.get (), CanonicalPath::create_empty (), cpath,\n+\t\t\t module.get_node_id ());\n \n   for (auto &item : module.get_items ())\n     ResolveItem::go (item.get (), path, cpath);"}, {"sha": "7cfaa72f5a509b1fcbe17d5b383e5fcf5af9fadd", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=8cad07cfd2244ad9a40027a4306b81b4553a4797", "patch": "@@ -34,12 +34,12 @@ class ResolveTopLevel : public ResolverBase\n \n public:\n   static void go (AST::Item *item, const CanonicalPath &prefix,\n-\t\t  const CanonicalPath &canonical_prefix)\n+\t\t  const CanonicalPath &canonical_prefix, NodeId current_module)\n   {\n     if (item->is_marked_for_strip ())\n       return;\n \n-    ResolveTopLevel resolver (prefix, canonical_prefix);\n+    ResolveTopLevel resolver (prefix, canonical_prefix, current_module);\n     item->accept_vis (resolver);\n   };\n \n@@ -62,8 +62,10 @@ class ResolveTopLevel : public ResolverBase\n \t\t\t\t     Definition{module.get_node_id (),\n \t\t\t\t\t\tmodule.get_node_id ()});\n \n+    mappings->insert_module_child (current_module, module.get_node_id ());\n+\n     for (auto &item : module.get_items ())\n-      ResolveTopLevel::go (item.get (), path, cpath);\n+      ResolveTopLevel::go (item.get (), path, cpath, module.get_node_id ());\n \n     mappings->insert_canonical_path (mappings->get_current_crate (),\n \t\t\t\t     module.get_node_id (), cpath);\n@@ -123,7 +125,7 @@ class ResolveTopLevel : public ResolverBase\n       });\n \n     for (auto &variant : enum_decl.get_variants ())\n-      ResolveTopLevel::go (variant.get (), path, cpath);\n+      ResolveTopLevel::go (variant.get (), path, cpath, current_module);\n \n     mappings->insert_canonical_path (mappings->get_current_crate (),\n \t\t\t\t     enum_decl.get_node_id (), cpath);\n@@ -403,8 +405,8 @@ class ResolveTopLevel : public ResolverBase\n \n private:\n   ResolveTopLevel (const CanonicalPath &prefix,\n-\t\t   const CanonicalPath &canonical_prefix)\n-    : ResolverBase (UNKNOWN_NODEID), prefix (prefix),\n+\t\t   const CanonicalPath &canonical_prefix, NodeId current_module)\n+    : ResolverBase (UNKNOWN_NODEID, current_module), prefix (prefix),\n       canonical_prefix (canonical_prefix)\n   {}\n "}, {"sha": "945ff28c1953e841a41c9411134fc09ac480a2dd", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=8cad07cfd2244ad9a40027a4306b81b4553a4797", "patch": "@@ -86,7 +86,7 @@ NameResolution::go (AST::Crate &crate)\n   // a Self type Foo which is defined after the impl block for example.\n   for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n     ResolveTopLevel::go (it->get (), CanonicalPath::create_empty (),\n-\t\t\t crate_prefix);\n+\t\t\t crate_prefix, scope_node_id);\n \n   // FIXME remove this\n   if (saw_errors ())"}, {"sha": "934331bd7aa71523fdbd8988f05daec4dd1c3b26", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=8cad07cfd2244ad9a40027a4306b81b4553a4797", "patch": "@@ -832,21 +832,41 @@ Mappings::lookup_macro_def (NodeId id, AST::MacroRulesDefinition **def)\n }\n \n void\n-Mappings::insert_visibility (DefId id, Privacy::ModuleVisibility visibility)\n+Mappings::insert_visibility (NodeId id, Privacy::ModuleVisibility visibility)\n {\n   visibility_map.insert ({id, visibility});\n }\n \n bool\n-Mappings::lookup_visibility (DefId id, Privacy::ModuleVisibility *def)\n+Mappings::lookup_visibility (NodeId id, Privacy::ModuleVisibility &def)\n {\n   auto it = visibility_map.find (id);\n   if (it == visibility_map.end ())\n     return false;\n \n-  *def = it->second;\n+  def = it->second;\n   return true;\n }\n \n+void\n+Mappings::insert_module_child (NodeId module, NodeId child)\n+{\n+  auto it = module_child_map.find (module);\n+  if (it == module_child_map.end ())\n+    module_child_map.insert ({module, {child}});\n+  else\n+    it->second.emplace_back (child);\n+}\n+\n+Optional<std::vector<NodeId> &>\n+Mappings::lookup_module_children (NodeId module)\n+{\n+  auto it = module_child_map.find (module);\n+  if (it == module_child_map.end ())\n+    return Optional<std::vector<NodeId> &>::none ();\n+\n+  return Optional<std::vector<NodeId> &>::some (it->second);\n+}\n+\n } // namespace Analysis\n } // namespace Rust"}, {"sha": "03bfd5f1a72739aa88c6bdc9937150685c35c40a", "filename": "gcc/rust/util/rust-hir-map.h", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=8cad07cfd2244ad9a40027a4306b81b4553a4797", "patch": "@@ -19,6 +19,7 @@\n #ifndef RUST_HIR_MAP_H\n #define RUST_HIR_MAP_H\n \n+#include \"rust-optional.h\"\n #include \"rust-system.h\"\n #include \"rust-location.h\"\n #include \"rust-mapping-common.h\"\n@@ -318,8 +319,11 @@ class Mappings\n \n   bool lookup_macro_def (NodeId id, AST::MacroRulesDefinition **def);\n \n-  void insert_visibility (DefId id, Privacy::ModuleVisibility visibility);\n-  bool lookup_visibility (DefId id, Privacy::ModuleVisibility *def);\n+  void insert_visibility (NodeId id, Privacy::ModuleVisibility visibility);\n+  bool lookup_visibility (NodeId id, Privacy::ModuleVisibility &def);\n+\n+  void insert_module_child (NodeId module, NodeId child);\n+  Optional<std::vector<NodeId> &> lookup_module_children (NodeId module);\n \n private:\n   Mappings ();\n@@ -385,7 +389,12 @@ class Mappings\n   std::map<CrateNum, std::string> crate_names;\n \n   // Low level visibility map for each DefId\n-  std::map<DefId, Privacy::ModuleVisibility> visibility_map;\n+  std::map<NodeId, Privacy::ModuleVisibility> visibility_map;\n+\n+  // Module tree maps\n+\n+  // Maps each module's node id to a list of its children\n+  std::map<NodeId, std::vector<NodeId>> module_child_map;\n };\n \n } // namespace Analysis"}, {"sha": "9045ac33b0d28b38d4c6508003ca92fc938fc064", "filename": "gcc/rust/util/rust-optional-test.cc", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Futil%2Frust-optional-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Futil%2Frust-optional-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-optional-test.cc?ref=8cad07cfd2244ad9a40027a4306b81b4553a4797", "patch": "@@ -0,0 +1,104 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-optional.h\"\n+\n+#include \"config.h\"\n+#include \"selftest.h\"\n+\n+static void\n+rust_optional_create ()\n+{\n+  auto opt = Rust::Optional<int>::some (15);\n+\n+  ASSERT_TRUE (opt.is_some ());\n+  ASSERT_EQ (opt.get (), 15);\n+\n+  Rust::Optional<int> const_opt = Rust::Optional<int>::some (15);\n+  const int &value = const_opt.get ();\n+\n+  ASSERT_EQ (value, 15);\n+}\n+\n+static void\n+rust_optional_operators ()\n+{\n+  auto opt = Rust::Optional<int>::some (15);\n+\n+  // as bool\n+  ASSERT_TRUE (opt);\n+\n+  // deref\n+  ASSERT_EQ (*opt, 15);\n+\n+  class Methodable\n+  {\n+  public:\n+    int method () { return 15; }\n+  };\n+\n+  auto m_opt = Rust::Optional<Methodable>::some (Methodable ());\n+  ASSERT_EQ (m_opt->method (), 15);\n+}\n+\n+static void\n+rust_optional_take ()\n+{\n+  auto opt = Rust::Optional<int>::some (15);\n+  auto value = opt.take ();\n+\n+  ASSERT_EQ (value, 15);\n+  ASSERT_TRUE (opt.is_none ());\n+}\n+\n+static void\n+rust_optional_map ()\n+{\n+  auto opt = Rust::Optional<int>::some (15);\n+  auto twice = opt.map<int> ([] (int value) { return value * 2; });\n+\n+  ASSERT_FALSE (opt);\n+  ASSERT_TRUE (twice);\n+  ASSERT_EQ (*twice, 30);\n+}\n+\n+static void\n+rust_optional_reference ()\n+{\n+  auto value = std::vector<std::string> ();\n+  value.emplace_back (\"rust\");\n+  value.emplace_back (\"+\");\n+  value.emplace_back (\"gcc\");\n+  value.emplace_back (\"=\");\n+  value.emplace_back (\"<3\");\n+\n+  auto opt = Rust::Optional<std::vector<std::string> &>::some (value);\n+\n+  ASSERT_EQ (opt->at (0), \"rust\");\n+  ASSERT_EQ (opt->at (2), \"gcc\");\n+}\n+\n+void\n+rust_optional_test ()\n+{\n+  rust_optional_create ();\n+  rust_optional_operators ();\n+  rust_optional_take ();\n+  rust_optional_map ();\n+  rust_optional_reference ();\n+}"}, {"sha": "56465400250f096b7811c57784e1fe545c8c2028", "filename": "gcc/rust/util/rust-optional.h", "status": "modified", "additions": 89, "deletions": 52, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Futil%2Frust-optional.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Frust%2Futil%2Frust-optional.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-optional.h?ref=8cad07cfd2244ad9a40027a4306b81b4553a4797", "patch": "@@ -96,6 +96,7 @@ template <typename T> class Optional\n \n public:\n   Optional (const Optional &other) = default;\n+  Optional &operator= (const Optional &other) = default;\n   Optional (Optional &&other) = default;\n \n   static Optional<T> some (T value)\n@@ -167,74 +168,110 @@ template <typename T> class Optional\n   }\n };\n \n-} // namespace Rust\n+template <typename T> class Optional<T &>\n+{\n+private:\n+  struct Empty\n+  {\n+  };\n \n-#ifdef CHECKING_P\n+  enum Kind\n+  {\n+    Some,\n+    None\n+  } kind;\n \n-static void\n-rust_optional_create ()\n-{\n-  auto opt = Rust::Optional<int>::some (15);\n+  union Content\n+  {\n+    Empty empty;\n+    T *value;\n \n-  ASSERT_TRUE (opt.is_some ());\n-  ASSERT_EQ (opt.get (), 15);\n+    Content () = default;\n+  } content;\n \n-  Rust::Optional<int> const_opt = Rust::Optional<int>::some (15);\n-  const int &value = const_opt.get ();\n+  Optional<T &> (Kind kind, Content content) : kind (kind), content (content) {}\n \n-  ASSERT_EQ (value, 15);\n-}\n+public:\n+  Optional (const Optional &other) = default;\n+  Optional (Optional &&other) = default;\n \n-static void\n-rust_optional_operators ()\n-{\n-  auto opt = Rust::Optional<int>::some (15);\n+  static Optional<T &> some (T &value)\n+  {\n+    Content content;\n+    content.value = &value;\n+\n+    return Optional (Kind::Some, content);\n+  }\n+\n+  static Optional<T &> none ()\n+  {\n+    Content content;\n+    content.empty = Empty ();\n+\n+    return Optional (Kind::None, content);\n+  }\n+\n+  bool is_some () const { return kind == Kind::Some; }\n+  bool is_none () const { return !is_some (); }\n+\n+  // FIXME: Can we factor this in a single class?\n+\n+  /**\n+   * Enable boolean-like comparisons.\n+   */\n+  operator bool () { return is_some (); }\n \n-  // as bool\n-  ASSERT_TRUE (opt);\n+  /**\n+   * Enables dereferencing to access the contained value\n+   */\n+  T &operator* () { return get (); }\n+  const T &operator* () const { return get (); }\n+  T *operator-> () { return &get (); }\n+  const T *operator-> () const { return &get (); }\n \n-  // deref\n-  ASSERT_EQ (*opt, 15);\n+  const T &get () const\n+  {\n+    rust_assert (is_some ());\n+\n+    return *content.value;\n+  }\n \n-  class Methodable\n+  T &get ()\n   {\n-  public:\n-    int method () { return 15; }\n-  };\n+    rust_assert (is_some ());\n \n-  auto m_opt = Rust::Optional<Methodable>::some (Methodable ());\n-  ASSERT_EQ (m_opt->method (), 15);\n-}\n+    return *content.value;\n+  }\n \n-static void\n-rust_optional_take ()\n-{\n-  auto opt = Rust::Optional<int>::some (15);\n-  auto value = opt.take ();\n+  T &take ()\n+  {\n+    rust_assert (is_some ());\n \n-  ASSERT_EQ (value, 15);\n-  ASSERT_TRUE (opt.is_none ());\n-}\n+    auto to_return = std::move (content.value);\n \n-static void\n-rust_optional_map ()\n-{\n-  auto opt = Rust::Optional<int>::some (15);\n-  auto twice = opt.map<int> ([] (int value) { return value * 2; });\n+    content.empty = Empty ();\n+    kind = Kind::None;\n+\n+    return *to_return;\n+  }\n \n-  ASSERT_FALSE (opt);\n-  ASSERT_TRUE (twice);\n-  ASSERT_EQ (*twice, 30);\n-}\n+  template <typename U> Optional<U &> map (std::function<U &(T &)> functor)\n+  {\n+    if (is_none ())\n+      return Optional::none ();\n \n-static void\n-rust_optional_test ()\n-{\n-  rust_optional_create ();\n-  rust_optional_operators ();\n-  rust_optional_take ();\n-  rust_optional_map ();\n-}\n+    auto value = functor (take ());\n+\n+    return Optional::some (value);\n+  }\n+};\n+\n+} // namespace Rust\n+\n+#ifdef CHECKING_P\n+\n+void\n+rust_optional_test ();\n \n #endif // !CHECKING_P\n "}, {"sha": "1cc83c04abe8c6568e3b8f81ec9f84db85087a77", "filename": "gcc/testsuite/rust/compile/privacy1.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Ftestsuite%2Frust%2Fcompile%2Fprivacy1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Ftestsuite%2Frust%2Fcompile%2Fprivacy1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fprivacy1.rs?ref=8cad07cfd2244ad9a40027a4306b81b4553a4797", "patch": "@@ -0,0 +1,11 @@\n+mod orange {\n+    mod green {\n+        fn sain() {}\n+        pub fn doux() {}\n+    }\n+\n+    fn brown() {\n+        green::sain(); // { dg-error \"definition is private in this context\" }\n+        green::doux();\n+    }\n+}"}, {"sha": "d477385d761fb8093aa32685c489d6e42f8920bf", "filename": "gcc/testsuite/rust/compile/pub_restricted_3.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Ftestsuite%2Frust%2Fcompile%2Fpub_restricted_3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cad07cfd2244ad9a40027a4306b81b4553a4797/gcc%2Ftestsuite%2Frust%2Fcompile%2Fpub_restricted_3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fpub_restricted_3.rs?ref=8cad07cfd2244ad9a40027a4306b81b4553a4797", "patch": "@@ -0,0 +1,11 @@\n+// { dg-additional-options \"-w\" }\n+\n+mod foo {\n+    mod bar {\n+        pub(in foo) fn baz() {}\n+    }\n+\n+    fn baz() {\n+        bar::baz(); // no error, foo::bar::baz is public in foo\n+    }\n+}"}]}