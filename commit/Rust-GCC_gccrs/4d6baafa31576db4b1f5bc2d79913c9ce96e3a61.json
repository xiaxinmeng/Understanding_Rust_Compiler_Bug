{"sha": "4d6baafa31576db4b1f5bc2d79913c9ce96e3a61", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ2YmFhZmEzMTU3NmRiNGIxZjViYzJkNzk5MTNjOWNlOTZlM2E2MQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-11-26T23:44:54Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-11-26T23:44:54Z"}, "message": "cppfiles.c (stack_include_file): Don't optimize zero-length files.\n\n\t* cppfiles.c (stack_include_file): Don't optimize zero-length\n\tfiles.\n\t(read_include_file): NUL-terminate read files.\n\t* cpplex.c (handle_newline, skip_escaped_newlines,\n\tget_effective_char, skip_whitespace, parse_identifier,\n\tparse_identifier_slow, parse_number, parse_string,\n\t_cpp_lex_direct): Optimize for the fact that buffers are guaranteed\n\tNUL-terminated.\n\t* cpplib.c (destringize_and_run, cpp_define, handle_assertion):\n\tBe sure buffers are NUL terminated.\n\t* cppmacro.c (warn_of_redefinition): Kill compile warning.\n\n\t* c-common.c: Include tree-inline.h.\n\t(c_language): Move separate definitions here.\n\t(c_common_init_options, c_common_post_options): New.\n\t(c_common_lang_init): Rename c_common_init.\n\t* c-common.h (c_common_lang_init): Similarly.\n\t(c_common_init_options, c_common_post_options): New.\n\t* c-lang.c (c_post_options): Move body to c_common_post_options.\n\t(c_init_options): Use c_common_init_options.\n\t(c_init): Update.\n\t* langhooks.def: Rearrange.\n\t* langhooks.h: Rearrange, and improve comments.\n\t* toplev.c (do_compile): New function.\n\t(toplev_main): Use it.\n\t(lang_independent_f_options, parse_options_and_default_flags,\n\tprocess_options): Remove trailing periods.\n\t* Makefile.in: Update.\ncp:\t* decl2.c (c_language): Move to c-common.c.\n\t* lex.c (cxx_post_options, cxx_init_options): Use c-common.c\n\tfunctions.\n\t(cxx_init): Update.\nobjc:\t* objc-act.c (objc_post_options, objc_init_options): Use c-common.c\n\tfunctions.\n\t(ojbc_init): Update.\n\nFrom-SVN: r47362", "tree": {"sha": "c1a2c9c7c2d1ce0412550e13966b5458cdbb8bbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1a2c9c7c2d1ce0412550e13966b5458cdbb8bbe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/comments", "author": null, "committer": null, "parents": [{"sha": "d4b4b319a23400caa59bbf0e2db01a8f0e38b34e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4b4b319a23400caa59bbf0e2db01a8f0e38b34e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4b4b319a23400caa59bbf0e2db01a8f0e38b34e"}], "stats": {"total": 419, "additions": 241, "deletions": 178}, "files": [{"sha": "496fd5aa723c99d27d66d446d61f3ae98eea76ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d6baafa31576db4b1f5bc2d79913c9ce96e3a61", "patch": "@@ -1,3 +1,39 @@\n+2001-11-26  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cppfiles.c (stack_include_file): Don't optimize zero-length\n+\tfiles.\n+\t(read_include_file): NUL-terminate read files.\n+\t* cpplex.c (handle_newline, skip_escaped_newlines,\n+\tget_effective_char, skip_whitespace, parse_identifier,\n+\tparse_identifier_slow, parse_number, parse_string,\n+\t_cpp_lex_direct): Optimize for the fact that buffers are guaranteed\n+\tNUL-terminated.\n+\t* cpplib.c (destringize_and_run, cpp_define, handle_assertion):\n+\tBe sure buffers are NUL terminated.\n+\t* cppmacro.c (warn_of_redefinition): Kill compile warning.\n+\n+2001-11-26  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* c-common.c: Include tree-inline.h.\n+\t(c_language): Move separate definitions here.\n+\t(c_common_init_options, c_common_post_options): New.\n+\t(c_common_lang_init): Rename c_common_init.\n+\t* c-common.h (c_common_lang_init): Similarly.\n+\t(c_common_init_options, c_common_post_options): New.\n+\t* c-lang.c (c_post_options): Move body to c_common_post_options.\n+\t(c_init_options): Use c_common_init_options.\n+\t(c_init): Update.\n+\t* langhooks.def: Rearrange.\n+\t* langhooks.h: Rearrange, and improve comments.\n+\t* toplev.c (do_compile): New function.\n+\t(toplev_main): Use it.\n+\t(lang_independent_f_options, parse_options_and_default_flags,\n+\tprocess_options): Remove trailing periods.\n+\t* Makefile.in: Update.\n+objc:\t* objc-act.c (objc_post_options, objc_init_options): Use c-common.c\n+\tfunctions.\n+\t(ojbc_init): Update.\n+\n 2001-11-26  Richard Henderson  <rth@redhat.com>\n \n \t* config/alpha/alpha.md (unop): Add 0 offset for some gas versions."}, {"sha": "1cb15998f7302f4578b3e15b36b61735ddeb1d68", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=4d6baafa31576db4b1f5bc2d79913c9ce96e3a61", "patch": "@@ -1250,7 +1250,7 @@ s-under: $(GCC_PASSES)\n c-common.o : c-common.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(OBSTACK_H) \\\n \t$(C_COMMON_H) flags.h toplev.h output.h c-pragma.h $(RTL_H) $(GGC_H) \\\n \t$(EXPR_H) $(TM_P_H) builtin-types.def builtin-attrs.def $(TARGET_H) \\\n-\tdiagnostic.h\n+\tdiagnostic.h tree-inline.h\n \n # A file used by all variants of C and some other languages.\n "}, {"sha": "a7d005b04ed4203656eafdbafd242addbb4709ca", "filename": "gcc/c-common.c", "status": "modified", "additions": 51, "deletions": 8, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=4d6baafa31576db4b1f5bc2d79913c9ce96e3a61", "patch": "@@ -30,6 +30,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"ggc.h\"\n #include \"expr.h\"\n #include \"c-common.h\"\n+#include \"tree-inline.h\"\n #include \"diagnostic.h\"\n #include \"tm_p.h\"\n #include \"obstack.h\"\n@@ -79,6 +80,10 @@ cpp_reader *parse_in;\t\t/* Declared in c-lex.h.  */\n \t\t\t: \"long long unsigned int\"))\n #endif\n \n+/* The variant of the C language being processed.  */\n+\n+enum c_language_kind c_language;\n+\n /* The following symbols are subsumed in the c_global_trees array, and\n    listed here individually for documentation purposes.\n \n@@ -2371,7 +2376,7 @@ c_common_nodes_and_builtins ()\n   tree va_list_arg_type_node;\n \n   /* We must initialize this before any builtin functions (which might have\n-     attributes) are declared.  (c_common_lang_init is too late.)  */\n+     attributes) are declared.  (c_common_init is too late.)  */\n   format_attribute_table = c_format_attribute_table;\n \n   /* Define `int' and `char' first so that dbx will output them first.  */\n@@ -3858,17 +3863,43 @@ static bool c_attrs_initialized = false;\n \n static void c_init_attributes PARAMS ((void));\n \n-/* Do the parts of lang_init common to C and C++.  */\n-const char *\n-c_common_lang_init (filename)\n-     const char *filename;\n+/* Common initialization before parsing options.  */\n+void\n+c_common_init_options (lang)\n+     enum c_language_kind lang;\n {\n-  filename = init_c_lex (filename);\n+  c_language = lang;\n+  parse_in = cpp_create_reader (lang == clk_c ? CLK_GNUC89:\n+\t\t\t\tlang == clk_cplusplus ? CLK_GNUCXX: CLK_OBJC);\n \n-  init_pragma ();\n+  /* Mark as \"unspecified\" (see c_common_post_options).  */\n+  flag_bounds_check = -1;\n+}\n+\n+/* Post-switch processing.  */\n+void\n+c_common_post_options ()\n+{\n+  cpp_post_options (parse_in);\n+\n+  /* Use tree inlining if possible.  Function instrumentation is only\n+     done in the RTL level, so we disable tree inlining.  */\n+  if (! flag_instrument_function_entry_exit)\n+    {\n+      if (!flag_no_inline)\n+\t{\n+\t  flag_inline_trees = 1;\n+\t  flag_no_inline = 1;\n+\t}\n+      if (flag_inline_functions)\n+\t{\n+\t  flag_inline_trees = 2;\n+\t  flag_inline_functions = 0;\n+\t}\n+    }\n \n   /* If still \"unspecified\", make it match -fbounded-pointers.  */\n-  if (flag_bounds_check < 0)\n+  if (flag_bounds_check == -1)\n     flag_bounds_check = flag_bounded_pointers;\n \n   /* Special format checking options don't work without -Wformat; warn if\n@@ -3883,6 +3914,18 @@ c_common_lang_init (filename)\n     warning (\"-Wformat-security ignored without -Wformat\");\n   if (warn_missing_format_attribute && !warn_format)\n     warning (\"-Wmissing-format-attribute ignored without -Wformat\");\n+}\n+\n+/* Front end initialization common to C, ObjC and C++.  */\n+const char *\n+c_common_init (filename)\n+     const char *filename;\n+{\n+  /* Do this before initializing pragmas, as then cpplib's hash table\n+     has been set up.  */\n+  filename = init_c_lex (filename);\n+\n+  init_pragma ();\n \n   if (!c_attrs_initialized)\n     c_init_attributes ();"}, {"sha": "84e4bb95824ca9ee2da990e77894c37d68b55666", "filename": "gcc/c-common.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=4d6baafa31576db4b1f5bc2d79913c9ce96e3a61", "patch": "@@ -534,7 +534,9 @@ extern void disable_builtin_function\t\tPARAMS ((const char *));\n \n extern tree build_va_arg\t\t\tPARAMS ((tree, tree));\n \n-extern const char *c_common_lang_init\t\tPARAMS ((const char *));\n+extern void c_common_init_options\t\tPARAMS ((enum c_language_kind));\n+extern void c_common_post_options\t\tPARAMS ((void));\n+extern const char *c_common_init\t\tPARAMS ((const char *));\n extern void c_common_finish\t\t\tPARAMS ((void));\n extern HOST_WIDE_INT c_common_get_alias_set\tPARAMS ((tree));\n extern bool c_promoting_integer_type_p\t\tPARAMS ((tree));"}, {"sha": "a5c86625b30f800264cb795d0d4524956ee13f73", "filename": "gcc/c-lang.c", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=4d6baafa31576db4b1f5bc2d79913c9ce96e3a61", "patch": "@@ -88,32 +88,13 @@ static varray_type deferred_fns;\n static void\n c_post_options ()\n {\n-  cpp_post_options (parse_in);\n-\n-  /* Use tree inlining if possible.  Function instrumentation is only\n-     done in the RTL level, so we disable tree inlining.  */\n-  if (! flag_instrument_function_entry_exit)\n-    {\n-      if (!flag_no_inline)\n-\t{\n-\t  flag_inline_trees = 1;\n-\t  flag_no_inline = 1;\n-\t}\n-      if (flag_inline_functions)\n-\t{\n-\t  flag_inline_trees = 2;\n-\t  flag_inline_functions = 0;\n-\t}\n-    }\n+  c_common_post_options ();\n }\n \n static void\n c_init_options ()\n {\n-  parse_in = cpp_create_reader (CLK_GNUC89);\n-\n-  /* Mark as \"unspecified\".  */\n-  flag_bounds_check = -1;\n+  c_common_init_options (clk_c);\n }\n \n static const char *\n@@ -122,7 +103,7 @@ c_init (filename)\n {\n   c_init_decl_processing ();\n \n-  filename = c_common_lang_init (filename);\n+  filename = c_common_init (filename);\n \n   add_c_tree_codes ();\n "}, {"sha": "110f7c40e8e988656e09a5d01c5bc598415fa6ea", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4d6baafa31576db4b1f5bc2d79913c9ce96e3a61", "patch": "@@ -1,3 +1,10 @@\n+2001-11-26  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* decl2.c (c_language): Move to c-common.c.\n+\t* lex.c (cxx_post_options, cxx_init_options): Use c-common.c\n+\tfunctions.\n+\t(cxx_init): Update.\n+\n 2001-11-26  Jason Merrill  <jason@redhat.com>\n \n \t* call.c (joust): Remove COND_EXPR hack."}, {"sha": "c316da034fa06eff790ec281700b1c4e76492fec", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=4d6baafa31576db4b1f5bc2d79913c9ce96e3a61", "patch": "@@ -400,10 +400,6 @@ int flag_permissive;\n \n int flag_enforce_eh_specs = 1;\n \n-/* The variant of the C language being processed.  */\n-\n-c_language_kind c_language = clk_cplusplus;\n-\n /* Table of language-dependent -f options.\n    STRING is the option name.  VARIABLE is the address of the variable.\n    ON_VALUE is the value to store in VARIABLE"}, {"sha": "ba93ca5f5faaee73bc34c5231ed5ae4aed16305e", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=4d6baafa31576db4b1f5bc2d79913c9ce96e3a61", "patch": "@@ -241,18 +241,17 @@ static const char *const cplus_tree_code_name[] = {\n void\n cxx_post_options ()\n {\n-  cpp_post_options (parse_in);\n+  c_common_post_options ();\n }\n \n+/* Initialization before switch parsing.  */\n void\n cxx_init_options ()\n {\n-  parse_in = cpp_create_reader (CLK_GNUCXX);\n+  c_common_init_options (clk_cplusplus);\n \n   /* Default exceptions on.  */\n   flag_exceptions = 1;\n-  /* Mark as \"unspecified\".  */\n-  flag_bounds_check = -1;\n   /* By default wrap lines at 80 characters.  Is getenv (\"COLUMNS\")\n      preferable?  */\n   diagnostic_line_cutoff (global_dc) = 80;\n@@ -720,18 +719,15 @@ cxx_init (filename)\n \n   cxx_init_decl_processing ();\n \n-  /* Create the built-in __null node.  Note that we can't yet call for\n-     type_for_size here because integer_type_node and so forth are not\n-     set up.  Therefore, we don't set the type of these nodes until\n-     cxx_init_decl_processing.  */\n+  /* Create the built-in __null node.  */\n   null_node = build_int_2 (0, 0);\n   TREE_TYPE (null_node) = type_for_size (POINTER_SIZE, 0);\n   ridpointers[RID_NULL] = null_node;\n \n   token_count = init_cpp_parse ();\n   interface_unknown = 1;\n \n-  filename = c_common_lang_init (filename);\n+  filename = c_common_init (filename);\n \n   init_cp_pragma ();\n "}, {"sha": "f0d85d9bf3759048b521b7dd02be3427cff1babc", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=4d6baafa31576db4b1f5bc2d79913c9ce96e3a61", "patch": "@@ -296,17 +296,17 @@ stack_include_file (pfile, inc)\n   /* Not in cache?  */\n   if (! inc->buffer)\n     {\n-      /* Mark a regular, zero-length file never-reread.  Zero-length\n-\t files are stacked the first time, so preprocessing a main\n-\t file of zero length does not raise an error.  */\n-      if (S_ISREG (inc->st.st_mode) && inc->st.st_size == 0)\n-\t_cpp_never_reread (inc);\n-      else if (read_include_file (pfile, inc))\n+      if (read_include_file (pfile, inc))\n \t{\n \t  /* If an error occurs, do not try to read this file again.  */\n \t  _cpp_never_reread (inc);\n \t  return false;\n \t}\n+      /* Mark a regular, zero-length file never-reread.  We read it,\n+\t NUL-terminate it, and stack it once, so preprocessing a main\n+\t file of zero length does not raise an error.  */\n+      if (S_ISREG (inc->st.st_mode) && inc->st.st_size == 0)\n+\t_cpp_never_reread (inc);\n       close (inc->fd);\n       inc->fd = -1;\n     }\n@@ -382,7 +382,8 @@ read_include_file (pfile, inc)\n       if (pagesize == -1)\n \tpagesize = getpagesize ();\n \n-      if (size / pagesize >= MMAP_THRESHOLD)\n+      if (size / pagesize >= MMAP_THRESHOLD\n+\t  && (size % pagesize) != 0)\n \t{\n \t  buf = (U_CHAR *) mmap (0, size, PROT_READ, MAP_PRIVATE, inc->fd, 0);\n \t  if (buf == (U_CHAR *)-1)\n@@ -392,7 +393,7 @@ read_include_file (pfile, inc)\n       else\n #endif\n \t{\n-\t  buf = (U_CHAR *) xmalloc (size);\n+\t  buf = (U_CHAR *) xmalloc (size + 1);\n \t  offset = 0;\n \t  while (offset < size)\n \t    {\n@@ -410,6 +411,8 @@ read_include_file (pfile, inc)\n \t\t}\n \t      offset += count;\n \t    }\n+\t  /* The lexer requires that the buffer be NUL-terminated.  */\n+\t  buf[size] = '\\0';\n \t}\n     }\n   else if (S_ISBLK (inc->st.st_mode))\n@@ -424,19 +427,25 @@ read_include_file (pfile, inc)\n \t bigger than the majority of C source files.  */\n       size = 8 * 1024;\n \n-      buf = (U_CHAR *) xmalloc (size);\n+      buf = (U_CHAR *) xmalloc (size + 1);\n       offset = 0;\n       while ((count = read (inc->fd, buf + offset, size - offset)) > 0)\n \t{\n \t  offset += count;\n \t  if (offset == size)\n-\t    buf = xrealloc (buf, (size *= 2));\n+\t    {\n+\t      size *= 2;\n+\t      buf = xrealloc (buf, size + 1);\n+\t    }\n \t}\n       if (count < 0)\n \tgoto perror_fail;\n \n-      if (offset < size)\n-\tbuf = xrealloc (buf, offset);\n+      if (offset + 1 < size)\n+\tbuf = xrealloc (buf, offset + 1);\n+\n+      /* The lexer requires that the buffer be NUL-terminated.  */\n+      buf[offset] = '\\0';\n       inc->st.st_size = offset;\n     }\n "}, {"sha": "08223bd49b7c3644133c87bed3deb446d0268481", "filename": "gcc/cpplex.c", "status": "modified", "additions": 42, "deletions": 61, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=4d6baafa31576db4b1f5bc2d79913c9ce96e3a61", "patch": "@@ -75,7 +75,7 @@ static cppchar_t get_effective_char PARAMS ((cpp_reader *));\n static int skip_block_comment PARAMS ((cpp_reader *));\n static int skip_line_comment PARAMS ((cpp_reader *));\n static void adjust_column PARAMS ((cpp_reader *));\n-static void skip_whitespace PARAMS ((cpp_reader *, cppchar_t));\n+static int skip_whitespace PARAMS ((cpp_reader *, cppchar_t));\n static cpp_hashnode *parse_identifier PARAMS ((cpp_reader *));\n static cpp_hashnode *parse_identifier_slow PARAMS ((cpp_reader *,\n \t\t\t\t\t\t    const U_CHAR *));\n@@ -119,12 +119,8 @@ handle_newline (pfile)\n   cpp_buffer *buffer = pfile->buffer;\n \n   /* Handle CR-LF and LF-CR.  Most other implementations (e.g. java)\n-     only accept CR-LF; maybe we should fall back to that behaviour?\n-\n-     NOTE: the EOF case in _cpp_lex_direct currently requires the\n-     buffer->cur != buffer->rlimit test here for 0-length files.  */\n-  if (buffer->cur != buffer->rlimit\n-      && buffer->cur[-1] + buffer->cur[0] == '\\r' + '\\n')\n+     only accept CR-LF; maybe we should fall back to that behaviour?  */\n+  if (buffer->cur[-1] + buffer->cur[0] == '\\r' + '\\n')\n     buffer->cur++;\n \n   buffer->line_base = buffer->cur;\n@@ -190,24 +186,21 @@ skip_escaped_newlines (pfile)\n \n       do\n \t{\n-\t  if (buffer->cur == buffer->rlimit)\n-\t    break;\n-      \n \t  if (next == '?')\n \t    {\n-\t      if (buffer->cur[0] != '?' || buffer->cur + 1 == buffer->rlimit)\n-\t\tbreak;\n-\n-\t      if (!trigraph_p (pfile))\n+\t      if (buffer->cur[0] != '?' || !trigraph_p (pfile))\n \t\tbreak;\n \n \t      /* Translate the trigraph.  */\n \t      next = _cpp_trigraph_map[buffer->cur[1]];\n \t      buffer->cur += 2;\n-\t      if (next != '\\\\' || buffer->cur == buffer->rlimit)\n+\t      if (next != '\\\\')\n \t\tbreak;\n \t    }\n \n+\t  if (buffer->cur == buffer->rlimit)\n+\t    break;\n+\n \t  /* We have a backslash, and room for at least one more\n \t     character.  Skip horizontal whitespace.  */\n \t  saved_cur = buffer->cur;\n@@ -250,16 +243,13 @@ static cppchar_t\n get_effective_char (pfile)\n      cpp_reader *pfile;\n {\n-  cppchar_t next = EOF;\n+  cppchar_t next;\n   cpp_buffer *buffer = pfile->buffer;\n \n   buffer->backup_to = buffer->cur;\n-  if (buffer->cur < buffer->rlimit)\n-    {\n-      next = *buffer->cur++;\n-      if (__builtin_expect (next == '?' || next == '\\\\', 0))\n-\tnext = skip_escaped_newlines (pfile);\n-    }\n+  next = *buffer->cur++;\n+  if (__builtin_expect (next == '?' || next == '\\\\', 0))\n+    next = skip_escaped_newlines (pfile);\n \n    return next;\n }\n@@ -295,7 +285,6 @@ skip_block_comment (pfile)\n \t     comes immediately before the true comment delimiter.\n \t     Don't bother to get it right across escaped newlines.  */\n \t  if (CPP_OPTION (pfile, warn_comments)\n-\t      && buffer->cur + 1 < buffer->rlimit\n \t      && buffer->cur[0] == '*' && buffer->cur[1] != '/')\n \t    cpp_warning_with_line (pfile,\n \t\t\t\t   pfile->line, CPP_BUF_COL (buffer),\n@@ -360,7 +349,7 @@ adjust_column (pfile)\n /* Skips whitespace, saving the next non-whitespace character.\n    Adjusts pfile->col_adjust to account for tabs.  Without this,\n    tokens might be assigned an incorrect column.  */\n-static void\n+static int\n skip_whitespace (pfile, c)\n      cpp_reader *pfile;\n      cppchar_t c;\n@@ -378,6 +367,8 @@ skip_whitespace (pfile, c)\n       /* Just \\f \\v or \\0 left.  */\n       else if (c == '\\0')\n \t{\n+\t  if (buffer->cur - 1 == buffer->rlimit)\n+\t    return 0;\n \t  if (!warned)\n \t    {\n \t      cpp_warning (pfile, \"null character(s) ignored\");\n@@ -390,14 +381,13 @@ skip_whitespace (pfile, c)\n \t\t\t       \"%s in preprocessing directive\",\n \t\t\t       c == '\\f' ? \"form feed\" : \"vertical tab\");\n \n-      if (buffer->cur == buffer->rlimit)\n-\treturn;\n       c = *buffer->cur++;\n     }\n   /* We only want non-vertical space, i.e. ' ' \\t \\f \\v \\0.  */\n   while (is_nvspace (c));\n \n   buffer->cur--;\n+  return 1;\n }\n \n /* See if the characters of a number token are valid in a name (no\n@@ -430,18 +420,16 @@ parse_identifier (pfile)\n      cpp_reader *pfile;\n {\n   cpp_hashnode *result;\n-  const U_CHAR *cur, *rlimit;\n+  const U_CHAR *cur;\n \n   /* Fast-path loop.  Skim over a normal identifier.\n      N.B. ISIDNUM does not include $.  */\n-  cur    = pfile->buffer->cur - 1;\n-  rlimit = pfile->buffer->rlimit;\n-  do\n+  cur = pfile->buffer->cur;\n+  while (ISIDNUM (*cur))\n     cur++;\n-  while (cur < rlimit && ISIDNUM (*cur));\n \n   /* Check for slow-path cases.  */\n-  if (cur < rlimit && (*cur == '?' || *cur == '\\\\' || *cur == '$'))\n+  if (*cur == '?' || *cur == '\\\\' || *cur == '$')\n     result = parse_identifier_slow (pfile, cur);\n   else\n     {\n@@ -501,9 +489,6 @@ parse_identifier_slow (pfile, cur)\n           if (c == '$')\n             saw_dollar++;\n \n-          if (buffer->cur == buffer->rlimit)\n-            goto at_eof;\n-\n           c = *buffer->cur++;\n         }\n \n@@ -515,9 +500,8 @@ parse_identifier_slow (pfile, cur)\n     }\n   while (is_idchar (c));\n \n-  /* Step back over the unwanted char, except at EOF.  */\n+  /* Step back over the unwanted char.  */\n   BACKUP ();\n- at_eof:\n \n   /* $ is not an identifier character in the standard, but is commonly\n      accepted as an extension.  Don't warn about it in skipped\n@@ -573,9 +557,6 @@ parse_number (pfile, number, c, leading_period)\n \t    }\n \t  *dest++ = c;\n \n-\t  if (buffer->cur == buffer->rlimit)\n-\t    goto at_eof;\n-\n \t  c = *buffer->cur++;\n \t}\n       while (is_numchar (c) || c == '.' || VALID_SIGN (c, dest[-1]));\n@@ -588,9 +569,8 @@ parse_number (pfile, number, c, leading_period)\n     }\n   while (is_numchar (c) || c == '.' || VALID_SIGN (c, dest[-1]));\n \n-  /* Step back over the unwanted char, except at EOF.  */\n+  /* Step back over the unwanted char.  */\n   BACKUP ();\n- at_eof:\n \n   /* Null-terminate the number.  */\n   *dest = '\\0';\n@@ -671,12 +651,6 @@ parse_string (pfile, token, terminator)\n \t  limit = BUFF_LIMIT (pfile->u_buff);\n \t}\n \n-      if (buffer->cur == buffer->rlimit)\n-\t{\n-\t  unterminated (pfile, terminator);\n-\t  break;\n-\t}\n-\n       /* Handle trigraphs, escaped newlines etc.  */\n       c = *buffer->cur++;\n       if (c == '?' || c == '\\\\')\n@@ -724,10 +698,19 @@ parse_string (pfile, token, terminator)\n \t  handle_newline (pfile);\n \t  c = '\\n';\n \t}\n-      else if (c == '\\0' && !warned_nulls)\n+      else if (c == '\\0')\n \t{\n-\t  warned_nulls = true;\n-\t  cpp_warning (pfile, \"null character(s) preserved in literal\");\n+\t  if (buffer->cur - 1 == buffer->rlimit)\n+\t    {\n+\t      unterminated (pfile, terminator);\n+\t      buffer->cur--;\n+\t      break;\n+\t    }\n+\t  if (!warned_nulls)\n+\t    {\n+\t      warned_nulls = true;\n+\t      cpp_warning (pfile, \"null character(s) preserved in literal\");\n+\t    }\n \t}\n \n       *dest++ = c;\n@@ -907,15 +890,19 @@ _cpp_lex_direct (pfile)\n   result->line = pfile->line;\n \n  skipped_white:\n-  if (buffer->cur == buffer->rlimit)\n-    goto at_eof;\n   c = *buffer->cur++;\n   result->col = CPP_BUF_COLUMN (buffer, buffer->cur);\n \n  trigraph:\n   switch (c)\n     {\n-    at_eof:\n+    case ' ': case '\\t': case '\\f': case '\\v': case '\\0':\n+      result->flags |= PREV_WHITE;\n+      if (skip_whitespace (pfile, c))\n+\tgoto skipped_white;\n+\n+      /* EOF.  */\n+      buffer->cur--;\n       buffer->saved_flags = BOL;\n       if (!pfile->state.parsing_args && !pfile->state.in_directive)\n \t{\n@@ -941,11 +928,6 @@ _cpp_lex_direct (pfile)\n       result->type = CPP_EOF;\n       break;\n \n-    case ' ': case '\\t': case '\\f': case '\\v': case '\\0':\n-      skip_whitespace (pfile, c);\n-      result->flags |= PREV_WHITE;\n-      goto skipped_white;\n-\n     case '\\n': case '\\r':\n       handle_newline (pfile);\n       buffer->saved_flags = BOL;\n@@ -1016,8 +998,7 @@ _cpp_lex_direct (pfile)\n       result->val.node = parse_identifier (pfile);\n \n       /* 'L' may introduce wide characters or strings.  */\n-      if (result->val.node == pfile->spec_nodes.n_L\n-\t  && buffer->cur < buffer->rlimit)\n+      if (result->val.node == pfile->spec_nodes.n_L)\n \t{\n \t  c = *buffer->cur;\n \t  if (c == '\\'' || c == '\"')"}, {"sha": "ea1d9f86860b2059b3671ef116aebc75c290ff2f", "filename": "gcc/cpplib.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=4d6baafa31576db4b1f5bc2d79913c9ce96e3a61", "patch": "@@ -1158,14 +1158,15 @@ destringize_and_run (pfile, in)\n   const unsigned char *src, *limit;\n   char *dest, *result;\n \n-  dest = result = alloca (in->len);\n+  dest = result = alloca (in->len + 1);\n   for (src = in->text, limit = src + in->len; src < limit;)\n     {\n       /* We know there is a character following the backslash.  */\n       if (*src == '\\\\' && (src[1] == '\\\\' || src[1] == '\"'))\n \tsrc++;\n       *dest++ = *src++;\n     }\n+  *dest = '\\0';\n \n   run_directive (pfile, T_PRAGMA, result, dest - result);\n }\n@@ -1647,9 +1648,8 @@ cpp_define (pfile, str)\n      Change the first \"=\" in the string to a space.  If there is none,\n      tack \" 1\" on the end.  */\n \n-  /* Length including the null.  */  \n   count = strlen (str);\n-  buf = (char *) alloca (count + 2);\n+  buf = (char *) alloca (count + 3);\n   memcpy (buf, str, count);\n \n   p = strchr (str, '=');\n@@ -1660,6 +1660,7 @@ cpp_define (pfile, str)\n       buf[count++] = ' ';\n       buf[count++] = '1';\n     }\n+  buf[count] = '\\0';\n \n   run_directive (pfile, T_DEFINE, buf, count);\n }\n@@ -1714,11 +1715,12 @@ handle_assertion (pfile, str, type)\n     {\n       /* Copy the entire option so we can modify it.  Change the first\n \t \"=\" in the string to a '(', and tack a ')' on the end.  */\n-      char *buf = (char *) alloca (count + 1);\n+      char *buf = (char *) alloca (count + 2);\n \n       memcpy (buf, str, count);\n       buf[p - str] = '(';\n       buf[count++] = ')';\n+      buf[count] = '\\0';\n       str = buf;\n     }\n "}, {"sha": "21d3cb1296b5224dda7b3ae73ed13d8b9e404708", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=4d6baafa31576db4b1f5bc2d79913c9ce96e3a61", "patch": "@@ -82,7 +82,7 @@ static _cpp_buff *funlike_invocation_p PARAMS ((cpp_reader *, cpp_hashnode *));\n \n static cpp_token *alloc_expansion_token PARAMS ((cpp_reader *, cpp_macro *));\n static cpp_token *lex_expansion_token PARAMS ((cpp_reader *, cpp_macro *));\n-static int warn_of_redefinition PARAMS ((cpp_reader *, const cpp_hashnode *,\n+static int warn_of_redefinition PARAMS ((const cpp_hashnode *,\n \t\t\t\t\t const cpp_macro *));\n static int save_parameter PARAMS ((cpp_reader *, cpp_macro *, cpp_hashnode *));\n static int parse_params PARAMS ((cpp_reader *, cpp_macro *));\n@@ -380,6 +380,7 @@ paste_tokens (pfile, plhs, rhs)\n       && (rhs->type == CPP_MULT || rhs->type == CPP_DIV))\n     *end++ = ' ';\n   end = cpp_spell_token (pfile, rhs, end);\n+  *end = '\\0';\n \n   cpp_push_buffer (pfile, buf, end - buf, /* from_stage3 */ true, 1);\n \n@@ -1112,8 +1113,7 @@ _cpp_backup_tokens (pfile, count)\n \n /* Returns non-zero if a macro redefinition warning is required.  */\n static int\n-warn_of_redefinition (pfile, node, macro2)\n-     cpp_reader *pfile;\n+warn_of_redefinition (node, macro2)\n      const cpp_hashnode *node;\n      const cpp_macro *macro2;\n {\n@@ -1408,7 +1408,7 @@ _cpp_create_definition (pfile, node)\n \n   if (node->type != NT_VOID)\n     {\n-      if (warn_of_redefinition (pfile, node, macro))\n+      if (warn_of_redefinition (node, macro))\n \t{\n \t  cpp_pedwarn_with_line (pfile, pfile->directive_line, 0,\n \t\t\t\t \"\\\"%s\\\" redefined\", NODE_NAME (node));"}, {"sha": "bb38e01cc7152b99816e83cc8b54a17ffe708e3b", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=4d6baafa31576db4b1f5bc2d79913c9ce96e3a61", "patch": "@@ -119,12 +119,12 @@ int lhd_tree_dump_type_quals\t\t\tPARAMS ((tree));\n #define LANG_HOOKS_INITIALIZER { \\\n   LANG_HOOKS_NAME, \\\n   LANG_HOOKS_IDENTIFIER_SIZE, \\\n-  LANG_HOOKS_INIT, \\\n-  LANG_HOOKS_FINISH, \\\n-  LANG_HOOKS_CLEAR_BINDING_STACK, \\\n   LANG_HOOKS_INIT_OPTIONS, \\\n   LANG_HOOKS_DECODE_OPTION, \\\n   LANG_HOOKS_POST_OPTIONS, \\\n+  LANG_HOOKS_INIT, \\\n+  LANG_HOOKS_FINISH, \\\n+  LANG_HOOKS_CLEAR_BINDING_STACK, \\\n   LANG_HOOKS_GET_ALIAS_SET, \\\n   LANG_HOOKS_HONOR_READONLY, \\\n   LANG_HOOKS_PRINT_STATISTICS, \\"}, {"sha": "befdb0f68383d42f598a55c274353b10417dc2ad", "filename": "gcc/langhooks.h", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=4d6baafa31576db4b1f5bc2d79913c9ce96e3a61", "patch": "@@ -71,21 +71,8 @@ struct lang_hooks\n      identifier nodes long enough for the language-specific slots.  */\n   size_t identifier_size;\n \n-  /* Called after options parsing, to initialize the front end.  The\n-     main input filename is passed, which may be NULL; the front end\n-     should return the original filename (e.g. foo.i -> foo.c).\n-     Return NULL to indicate a serious error of some sort; in that\n-     case no compilation is performed, and the finish hook is called\n-     immediately.  */\n-  const char * (*init) PARAMS ((const char *));\n-\n-  /* Called last, as a finalizer.  */\n-  void (*finish) PARAMS ((void));\n-\n-  /* Called immediately after parsing to clear the binding stack.  */\n-  void (*clear_binding_stack) PARAMS ((void));\n-\n-  /* Called to initialize options, before any calls to decode_option.  */\n+  /* The first callback made to the front end, for simple\n+     initialization needed before any calls to decode_option.  */\n   void (*init_options) PARAMS ((void));\n \n   /* Function called with an option vector as argument, to decode a\n@@ -98,9 +85,26 @@ struct lang_hooks\n      done for this option.  */\n   int (*decode_option) PARAMS ((int, char **));\n \n-  /* Called when all command line options have been parsed.  */\n+  /* Called when all command line options have been parsed.  Should do\n+     any required consistency checks, modifications etc.  Complex\n+     initialization should be left to the \"init\" callback, since GC\n+     and the identifier hashes are set up between now and then.  */\n   void (*post_options) PARAMS ((void));\n \n+  /* Called after post_options, to initialize the front end.  The main\n+     input filename is passed, which may be NULL; the front end should\n+     return the original filename (e.g. foo.i -> foo.c).  Return NULL\n+     to indicate a serious error of some sort; in that case no\n+     compilation is performed, and the finish hook is called\n+     immediately.  */\n+  const char * (*init) PARAMS ((const char *));\n+\n+  /* Called at the end of compilation, as a finalizer.  */\n+  void (*finish) PARAMS ((void));\n+\n+  /* Called immediately after parsing to clear the binding stack.  */\n+  void (*clear_binding_stack) PARAMS ((void));\n+\n   /* Called to obtain the alias set to be used for an expression or type.\n      Returns -1 if the language does nothing special for it.  */\n   HOST_WIDE_INT (*get_alias_set) PARAMS ((tree));"}, {"sha": "474df1afdba054d3a5b2e3d25e29240c88ecd90b", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=4d6baafa31576db4b1f5bc2d79913c9ce96e3a61", "patch": "@@ -478,7 +478,7 @@ static varray_type deferred_fns;\n static void\n objc_post_options ()\n {\n-  cpp_post_options (parse_in);\n+  c_common_post_options ();\n }\n \n /* Some platforms pass small structures through registers versus through\n@@ -547,8 +547,7 @@ generate_struct_by_value_array ()\n static void\n objc_init_options ()\n {\n-  parse_in = cpp_create_reader (CLK_OBJC);\n-  c_language = clk_objective_c;\n+  c_common_init_options (clk_objective_c);\n }\n \n static const char *\n@@ -557,7 +556,7 @@ objc_init (filename)\n {\n   c_init_decl_processing ();\n \n-  filename = c_common_lang_init (filename);\n+  filename = c_common_init (filename);\n \n   add_c_tree_codes ();\n "}, {"sha": "72c93a799b2eacfabb7900627a986bb68a02405c", "filename": "gcc/toplev.c", "status": "modified", "additions": 36, "deletions": 29, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d6baafa31576db4b1f5bc2d79913c9ce96e3a61/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=4d6baafa31576db4b1f5bc2d79913c9ce96e3a61", "patch": "@@ -126,6 +126,7 @@ extern tree last_assemble_variable_decl;\n \n static void general_init PARAMS ((char *));\n static void parse_options_and_default_flags PARAMS ((int, char **));\n+static void do_compile PARAMS ((void));\n static void process_options PARAMS ((void));\n static void lang_independent_init PARAMS ((void));\n static int lang_dependent_init PARAMS ((const char *));\n@@ -1177,7 +1178,7 @@ lang_independent_options f_options[] =\n   {\"mem-report\", &mem_report, 1,\n    N_(\"Report on permanent memory allocation at end of run\") },\n   { \"trapv\", &flag_trapv, 1,\n-   N_(\"Trap for signed overflow in addition / subtraction / multiplication.\") },\n+   N_(\"Trap for signed overflow in addition / subtraction / multiplication\") },\n };\n \n /* Table of language-specific options.  */\n@@ -4787,7 +4788,8 @@ parse_options_and_default_flags (argc, argv)\n \t}\n     }\n \n-  /* All command line options have been processed.  */\n+  /* All command line options have been parsed; allow the front end to\n+     perform consistency checks, etc.  */\n   (*lang_hooks.post_options) ();\n }\n \f\n@@ -4837,7 +4839,7 @@ process_options ()\n \n   if (profile_block_flag == 3)\n     {\n-      warning (\"`-ax' and `-a' are conflicting options. `-a' ignored.\");\n+      warning (\"`-ax' and `-a' are conflicting options. `-a' ignored\");\n       profile_block_flag = 2;\n     }\n \n@@ -4951,26 +4953,26 @@ process_options ()\n     {\n       if (flag_function_sections)\n \t{\n-\t  warning (\"-ffunction-sections not supported for this target.\");\n+\t  warning (\"-ffunction-sections not supported for this target\");\n \t  flag_function_sections = 0;\n \t}\n       if (flag_data_sections)\n \t{\n-\t  warning (\"-fdata-sections not supported for this target.\");\n+\t  warning (\"-fdata-sections not supported for this target\");\n \t  flag_data_sections = 0;\n \t}\n     }\n \n   if (flag_function_sections\n       && (profile_flag || profile_block_flag))\n     {\n-      warning (\"-ffunction-sections disabled; it makes profiling impossible.\");\n+      warning (\"-ffunction-sections disabled; it makes profiling impossible\");\n       flag_function_sections = 0;\n     }\n \n #ifndef OBJECT_FORMAT_ELF\n   if (flag_function_sections && write_symbols != NO_DEBUG)\n-    warning (\"-ffunction-sections may affect debugging on some targets.\");\n+    warning (\"-ffunction-sections may affect debugging on some targets\");\n #endif\n }\n \f\n@@ -5127,29 +5129,10 @@ finalize ()\n   (*lang_hooks.finish) ();\n }\n \f\n-/* Entry point of cc1, cc1plus, jc1, f771, etc.\n-   Decode command args, then call compile_file.\n-   Exit code is FATAL_EXIT_CODE if can't open files or if there were\n-   any errors, or SUCCESS_EXIT_CODE if compilation succeeded.\n-\n-   It is not safe to call this function more than once.  */\n-\n-int\n-toplev_main (argc, argv)\n-     int argc;\n-     char **argv;\n+/* Initialize the compiler, and compile the input file.  */\n+static void\n+do_compile ()\n {\n-  /* Initialization of GCC's environment, and diagnostics.  */\n-  general_init (argv [0]);\n-\n-  /* Parse the options and do minimal processing; basically just\n-     enough to default flags appropriately.  */\n-  parse_options_and_default_flags (argc, argv);\n-\n-  /* Exit early if we can (e.g. -help).  */\n-  if (exit_after_options)\n-    return (SUCCESS_EXIT_CODE);\n-\n   /* The bulk of command line switch processing.  */\n   process_options ();\n \n@@ -5171,6 +5154,30 @@ toplev_main (argc, argv)\n   /* Stop timing and print the times.  */\n   timevar_stop (TV_TOTAL);\n   timevar_print (stderr);\n+}\n+\f\n+/* Entry point of cc1, cc1plus, jc1, f771, etc.\n+   Decode command args, then call compile_file.\n+   Exit code is FATAL_EXIT_CODE if can't open files or if there were\n+   any errors, or SUCCESS_EXIT_CODE if compilation succeeded.\n+\n+   It is not safe to call this function more than once.  */\n+\n+int\n+toplev_main (argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  /* Initialization of GCC's environment, and diagnostics.  */\n+  general_init (argv [0]);\n+\n+  /* Parse the options and do minimal processing; basically just\n+     enough to default flags appropriately.  */\n+  parse_options_and_default_flags (argc, argv);\n+\n+  /* Exit early if we can (e.g. -help).  */\n+  if (!exit_after_options)\n+    do_compile ();\n \n   if (errorcount || sorrycount)\n     return (FATAL_EXIT_CODE);"}]}